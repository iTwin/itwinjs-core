# @itwin/core-quantity

- [@itwin/core-quantity](#itwincore-quantity)
  - [Terms and Concepts](#terms-and-concepts)
    - [Common Terms](#common-terms)
    - [Concepts](#concepts)
      - [Units Provider](#units-provider)
      - [Unit Conversion](#unit-conversion)
    - [Examples of Usage](#examples-of-usage)
      - [Numeric Format](#numeric-format)
      - [Mathematical Operation Parsing](#mathematical-operation-parsing)
  - [Contributing](#contributing)
- [Licensing](#licensing)

The __@itwin/core-quantity__ package contains classes for quantity formatting and parsing.

## Terms and Concepts

### Common Terms

- [Unit]($quantity)/[UnitProps]($quantity) - A named unit of measure which can be located by its name or label. The definition of any unit is represented through it's `UnitProps`.
- [UnitsProvider]($quantity) - An interface that locates the UnitProps for a unit given name or label. This interface also provides methods for [UnitConversion]($quantity) to allow converting from one unit to another.
- Unit Family/[Phenomenon]($ecschema-metadata) - A physical quantity that can be measured (e.g., length, temperature, pressure).  Only units in the same phenomenon can be converted between.
- Persistence Unit - The unit used to store the quantity value in memory or to persist the value in an editable IModel.
- Format/FormatProp - The display format for the quantity value. For example, an angle may be persisted in radians but formatted and shown to user in degrees.
  - CompositeValue - An addition to the format specification that allows the explicit specification of a unit label, it also allows the persisted value to be displayed as up to 4 sub-units. Typical multi-unit composites are used to display `feet'-inches"` and `degree°minutes'seconds"`.
- [FormatterSpec]($quantity) - Holds the format specification as well as the [UnitConversion]($quantity) between the persistence unit and all units defined in the format. This is done to avoid any async calls by the UnitsProvider during the formatting process.
- [ParserSpec]($quantity) - Holds the format specification as well as the [UnitConversion]($quantity) between the persistence unit and all other units in the same phenomenon. This is done to avoid async calls by the UnitsProvider and also done to allow a user to enter `43in` even when in "metric" unit system and have the string properly converted to meters.
- [Formatter]($quantity) - A class that holds methods to format a quantity value into a text string. Given a FormatterSpec object - containing one or many Unit definitions each with their own Unit Conversion info and a Format passed in - and a single `magnitude` number, the Formatter can convert that number into a text string, adhering to the properties passed to the formatTraits of a Format.
- [Parser]($quantity) - A class that holds methods to parse a text string into a single number. Given a ParserSpec object containing a Format's Units and their Unit Conversions, as well as an input string, the Parser can either return an object `QuantityParseResult` that contains the magnitude of type `number`, or an object `ParseQuantityError`.

See the [iTwin.js](https://www.itwinjs.org/learning/frontend/quantityformatting/#quantity-package) documentation on quantity formatting for more information.

### Concepts

#### Units Provider

To appropriately parse and output formatted values, A units provider is used to define all available units and provides conversion factors between units. There are a couple implementations of the UnitsProvider across iTwin.js:

The [BasicUnitsProvider]($frontend) holds many common units and their conversions between each other.

The [SchemaUnitProvider]($ecschema-metadata) is another example, used to load unit definitions of schemas from an iModel. This holds more extensive units through the Units schema, while also allowing users to define their own units.

#### Unit Conversion

Unit conversion is performed through [UnitConversionSpec]($quantity). These objects are generated by a UnitsProvider, with the implementation determined by each specific provider. During initialization, a ParserSpec/FormatterSpec can ask for UnitConversionSpec objects provided via the UnitsProvider. During parsing and formatting, the specification will retrieve the UnitConversionSpec between the source and destination units to apply the unit conversion.

<!-- #### How a value is formatted

#### How a string is parsed into a value -->

### Examples of Usage

#### Numeric Format

  The example below uses a simple numeric format and generates a formatted string with 4 decimal place precision. For numeric formats there is no conversion to other units, the unit passed in is the unit returned with the unit label appended if "showUnitLabel" trait is set.
<details>
<summary>Example Code</summary>

```ts
    const unitsProvider = new BasicUnitsProvider();
    const formatData = {
      formatTraits: ["keepSingleZero", "applyRounding", "showUnitLabel", "trailZeroes", "use1000Separator"],
      precision: 4,
      type: "Decimal",
      uomSeparator: " ",
      thousandSeparator: ",",
      decimalSeparator: ".",
    };

    // generate a Format from FormatProps to display 4 decimal place value
    const format = new Format("4d");
    // load the format props into the format, since unit provider is used to validate units the call must be asynchronous.
    await format.fromJSON(unitsProvider, formatData);

    // define input/output unit
    const unitName = "Units.FT";
    const unitLabel = "ft";
    const unitFamily = "Units.LENGTH";
    const inUnit = new BasicUnit(unitName, unitLabel, unitFamily);

    const magnitude = -12.5416666666667;

    // create the formatter spec - the name is not used by the formatter it is only
    // provided so user can cache formatter spec and then retrieve spec via its name.
    const spec = await FormatterSpec.create("test", format, unitsProvider, inUnit);

    // apply the formatting held in FormatterSpec
    const formattedValue = spec.applyFormatting(magnitude);

    // result in formattedValue of "-12.5417 ft"
```

</details>

#### Mathematical Operation Parsing

The quantity formatter supports parsing mathematical operations. The operation is solved, formatting every values present, according to the specified format. This makes it possible to process several different units at once.

<details>
<summary>Example Code</summary>

```Typescript
const unitsProvider = new BasicUnitsProvider();
const formatData = {
  formatTraits: ["keepSingleZero", "showUnitLabel"],
  precision: 8,
  type: "Fractional",
  uomSeparator: "",
  allowMathematicOperations: true,
};

const format = new Format("exampleFormat");
await format.fromJSON(unitsProvider, formatData);
// Operation containing many units (feet, inches, yards).
const mathematicalOperation = "5 ft + 12 in + 1 yd -1 ft 6 in";

// Asynchronous implementation
const quantityProps = await Parser.parseIntoQuantity(mathematicalOperation, format, unitsProvider);
// quantityProps.magnitude 7.5 (value in feet)

// Synchronous implementation
const parseResult = Parser.parseToQuantityValue(mathematicalOperation, format, feetConversionSpecs);
// parseResult.value 7.5 (value in feet)
```

</details>

## Contributing

When adding new APIs or updating documentation for this package, review if [QuantityFormatting.md](https://github.com/iTwin/itwinjs-core/blob/master/docs/learning/frontend/QuantityFormatting.md) needs to be updated as well. When adding or editing code examples, it's encouraged to keep the examples consistent between this file and the linked file above.

See the [Contributing.md](https://github.com/iTwin/itwinjs-core/blob/master/CONTRIBUTING.md) for more details.

# Licensing

Copyright © Bentley Systems, Incorporated. All rights reserved. See LICENSE.md for license terms and full copyright notice.
