/*---------------------------------------------------------------------------------------------
* Copyright (c) Bentley Systems, Incorporated. All rights reserved.
* See LICENSE.md in the project root for license terms and full copyright notice.
*--------------------------------------------------------------------------------------------*/
/** @packageDocumentation
 * @module Editing
 */

import { AnyDiagnostic } from "../Validation/Diagnostic";
import { SchemaKey } from "@itwin/ecschema-metadata";
import { AnyIdentifier, ClassId, CustomAttributeId, EnumeratorId, PropertyId, RelationshipConstraintId, SchemaId, SchemaItemId, SchemaTypeIdentifiers } from "./SchemaItemIdentifiers";
import { SchemaEditType } from "./SchemaEditType";

/** @alpha */
export enum ECEditingStatus {
  Unknown = "Unknown",
  RuleViolation = "RuleViolation",
  SchemaNotFound = "SchemaNotFound",
  SchemaItemNotFound = "SchemaItemNotFound",
  SchemaItemNotFoundInContext = "SchemaItemNotFoundInContext",
  PropertyAlreadyExists = "PropertyAlreadyExists",
  PropertyNotFound = "PropertyNotFound",
  InvalidPropertyType = "InvalidPropertyType",
  BasePropertyDifferentType = "BasePropertyDifferentType",
  BaseClassIsNotElement = "BaseClassIsNotElement",
  BaseClassIsNotElementUniqueAspect = "BaseClassIsNotElementUniqueAspect",
  BaseClassIsNotElementMultiAspect = "BaseClassIsNotElementMultiAspect",
  SchemaItemNameNotSpecified = "SchemaItemNameNotSpecified",
  InvalidSchemaItemType = "InvalidSchemaItemType",
  SchemaItemNameAlreadyExists = "SchemaItemNameAlreadyExists",
  InvalidEnumeratorType = "InvalidEnumeratorType",
  InvalidBaseClass = "InvalidBaseClass",
  EnumeratorDoesNotExist = "EnumeratorDoesNotExist",
  InvalidECName = "InvalidECName",
  InvalidSchemaAlias = "InvalidSchemaAlias",
  InvalidFormatUnitsSpecified = "InvalidFormatUnitsSpecified",
  SchemaAliasAlreadyExists = "SchemaAliasAlreadyExists",
}

/**
 * A type that constrains the possible error types handled by SchemaEditingError
 * @alpha
 */
export type AnyEditingError = SchemaEditingError | Error;

/**
 * An exception class for the ecschema-editing API. Contains identifiers for schema types involved in the
 * exception. An example being SchemaItemId which contains the name of the SchemaItem, SchemaItemKey, SchemaItemType, etc.
 * Typically will contain an innerError of type SchemaEditingError containing the identifier of the schema item that
 * caused the exception. The containing error instance will identify the method called (identified by the schemaEditType)
 * and the identifier of the schema item being modified/created.
 * @alpha
 */
export class SchemaEditingError extends Error {
  private _ruleViolations?: AnyDiagnostic[];
  private _schemaKey: SchemaKey;

  /** The ISchemaTypeIdentifier instance containing information about the EC object involved with the exception. */
  public readonly identifier: AnyIdentifier
  /** The unique ECEditingStatus identifying the error. */
  public readonly errorStatus: ECEditingStatus;
  /** The unique SchemaEditType code identifying the editing task that caused the exception. */
  public readonly schemaEditType?: SchemaEditType;
  /** The SchemaEditingError or generic Error identifying the cause of the initial exception. */
  public readonly innerError?: AnyEditingError

  /**
   * Constructs a new SchemaEditingError instance.
   * @param errorStatus The unique ECEditingStatus identifying the error.
   * @param identifier The ISchemaTypeIdentifier instance containing information about the EC object involved with the exception.
   * @param innerError The SchemaEditingError or generic Error identifying the cause of the initial exception.
   * @param ruleViolations Will contain EC rule violations of type [[AnyDiagnostic]] for exceptions with the error code ECEditingStatus.RuleViolation.
   * @param message Optional error message. Most messages on automatically generated by this class based on the ECEditingStatus code.
   */
  public constructor(errorStatus: ECEditingStatus, identifier: AnyIdentifier, innerError?: AnyEditingError, ruleViolations?: AnyDiagnostic[], message?: string);
  /**
 * Constructs a new SchemaEditingError instance.
 * @param schemaEditType The unique SchemaEditType code identifying the editing task being performed.
 * @param identifier The identifier instance containing information about the EC object involved with the exception.
 * @param innerError The SchemaEditingError containing the identifier of the EC object that caused the initial exception. Required if using this constructor.
 * @param ruleViolations Will contain EC rule violations of type [[AnyDiagnostic]] for exceptions with the error code ECEditingStatus.RuleViolation.
 * @param message Optional error message. Most messages on automatically generated by this class based on the ECEditingStatus code.
 */
  public constructor(schemaEditType: SchemaEditType, identifier: AnyIdentifier, innerError?: AnyEditingError, ruleViolations?: AnyDiagnostic[], message?: string);
  public constructor(errorStatusOrEditType: ECEditingStatus | SchemaEditType, identifier: AnyIdentifier, innerError?: AnyEditingError, ruleViolations?: AnyDiagnostic[], message?: string) {
    super(message);
    this._ruleViolations = ruleViolations;
    this._schemaKey = identifier.schemaKey;
    this.identifier = identifier;
    this.innerError = innerError;

    if (this.isSchemaEditType(errorStatusOrEditType)) {
      if (!innerError)
        throw new Error("innerError is required if a schemaEditType was specified");
      this.schemaEditType = errorStatusOrEditType;
      this.errorStatus = this.isSchemaEditingError(innerError) ? innerError.errorStatus : ECEditingStatus.Unknown;
    } else {
      this.errorStatus = errorStatusOrEditType;
    }


    this.generateMessage();
  }

  /** Gets rule violations that were reported during validation. Returns an array of [[AnyDiagnostic]] if
   * the errorNumber is ECEditingStatus.RuleViolation, otherwise undefined.
   */
  public get ruleViolations(): AnyDiagnostic[] | undefined {
    return this._ruleViolations;
  }

  /**
   * Returns a readable string containing the SchemaEditType and/or ECEditingStatus along with the error message. Any
   * innerError will also be appended.
   * @returns
   */
  public toDebugString(): string {
    let innerMessage = "";
    if (this.innerError) {
      if (this.innerError instanceof SchemaEditingError)
        innerMessage = ` Inner error: ${this.innerError.toDebugString()}`;
      else
        innerMessage = ` Inner error: ${this.innerError.message}`;
    }
    const statusText = this.schemaEditType ? `SchemaEditType.${this.schemaEditType}` : `ECEditingStatus.${this.errorStatus}`;
    return this._appendMessage(`${statusText}`) + innerMessage;
  }

  private isSchemaEditType(code: string): code is SchemaEditType {
    return code in SchemaEditType;
  }

  private isSchemaEditingError(error: AnyEditingError): error is SchemaEditingError {
    return "errorStatus" in error;
  }

  /**
   * Gets the SchemaId instance.
   * @throws Error if the identifier is not an instance of SchemaId.
   */
  private get _schemaId(): SchemaId {
    if (this.identifier.typeIdentifier !== SchemaTypeIdentifiers.SchemaIdentifier)
      throw new Error("identifier is not a SchemaId.");
    return this.identifier as SchemaId;
  }

  /**
   * Gets the SchemaItemId instance.
   * @throws Error if the identifier is not an instance of SchemaItemId.
   */
  private get _schemaItemId(): SchemaItemId {
    if (this.isSchemaItemIdentifier(this.identifier))
      throw new Error("identifier is not a SchemaItemId.");
    return this.identifier as SchemaItemId;
  }

  /**
   * Gets the ClassId instance.
   * @throws Error if the identifier is not an instance of ClassId.
   */
  private get _classId(): ClassId {
    if (this.identifier.typeIdentifier !== SchemaTypeIdentifiers.ClassIdentifier)
      throw new Error("identifier is not a ClassId.");
    return this.identifier as ClassId;
  }

  /**
   * Gets the PropertyId instance.
   * @throws Error if the identifier is not an instance of PropertyId.
   */
  private get _propertyId(): PropertyId {
    if (this.identifier.typeIdentifier !== SchemaTypeIdentifiers.PropertyIdentifier)
      throw new Error("identifier is not a PropertyId.");
    return this.identifier;
  }

  /**
   * Gets the EnumeratorId instance.
   * @throws Error if the identifier is not an instance of EnumeratorId.
   */
  private get _enumeratorId(): EnumeratorId {
    if (this.identifier.typeIdentifier !== SchemaTypeIdentifiers.EnumeratorIdentifier)
      throw new Error("identifier is not a EnumeratorId.");
    return this.identifier as EnumeratorId;
  }

  /**
   * Gets the CustomAttributeId instance.
   * @throws Error if the identifier is not an instance of CustomAttributeId.
   */
  private get _customAttributeId(): CustomAttributeId {
    if (this.identifier.typeIdentifier !== SchemaTypeIdentifiers.CustomAttributeIdentifier)
      throw new Error("identifier is not a CustomAttributeId.");
    return this.identifier;
  }

  /**
   * Gets the RelationshipConstraintId instance.
   * @throws Error if the identifier is not an instance of RelationshipConstraintId.
   */
  private get _relationshipConstraintId(): RelationshipConstraintId {
    if (this.identifier.typeIdentifier !== SchemaTypeIdentifiers.RelationshipConstraintIdentifier)
      throw new Error("identifier is not a RelationshipConstraintId.");
    return this.identifier;
  }


  private generateMessage() {
    if (this.message)
      return;

    if (this.schemaEditType) {
      this.message = this._createTaskErrorMessage();
      return;
    }

    switch (this.errorStatus) {
      case ECEditingStatus.SchemaNotFound:
        this.message = `Schema Key ${this._schemaKey.toString(true)} could not be found in the context.`;
        return;
      case ECEditingStatus.SchemaItemNotFound:
        this.message = `${this._schemaItemId.schemaItemType} ${this._schemaItemId.name} could not be found in the schema ${this._schemaKey.name}.`;
        return;
      case ECEditingStatus.SchemaItemNotFoundInContext:
        this.message = `${this._schemaItemId.schemaItemType} ${this._schemaItemId.name} could not be found in the schema context.`;
        return;
      case ECEditingStatus.InvalidSchemaItemType:
        this.message = `Expected ${this._schemaItemId.name} to be of type ${this._schemaItemId.schemaItemType}.`;
        return;
      case ECEditingStatus.SchemaItemNameNotSpecified:
        this.message = `Could not create a new ${this._schemaItemId.schemaItemType} in schema ${this._schemaKey.name}. No name was supplied within props.`;
        return;
      case ECEditingStatus.SchemaItemNameAlreadyExists:
        this.message = `${this._schemaItemId.schemaItemType} ${this._schemaItemId.name} already exists in the schema ${this._schemaKey.name}.`;
        return;
      case ECEditingStatus.RuleViolation:
        this.message = this._getRuleViolationMessage();
        return;
      case ECEditingStatus.PropertyNotFound:
        this.message = `An ECProperty with the name ${this._propertyId.name} could not be found in the class ${this._propertyId.ecClass.name}.`;
        return;
      case ECEditingStatus.PropertyAlreadyExists:
        this.message = `An ECProperty with the name ${this._propertyId.name} already exists in the class ${this._propertyId.ecClass.name}.`;
        return;
      case ECEditingStatus.InvalidPropertyType:
        this.message = `Expected property ${this._propertyId.name} to be of type ${this._propertyId.typeName}.`;
        return;
      case ECEditingStatus.BasePropertyDifferentType:
        this.message = `Base property ${this._propertyId.name} `
      case ECEditingStatus.BaseClassIsNotElement:
        this.message = `Expected base class ${this._schemaItemId.name} to derive from BisCore.Element.`;
        return;
      case ECEditingStatus.BaseClassIsNotElementUniqueAspect:
        this.message = `Expected base class ${this._schemaItemId.name} to derive from BisCore.ElementUniqueAspect.`;
        return;
      case ECEditingStatus.BaseClassIsNotElementMultiAspect:
        this.message = `Expected base class ${this._schemaItemId.name} to derive from BisCore.ElementMultiAspect.`;
        return;
      case ECEditingStatus.InvalidFormatUnitsSpecified:
        this.message = `The specified Format unit ${this._schemaItemId.name} is not of type Unit or InvertedUnit`;
        return;
      case ECEditingStatus.InvalidEnumeratorType:
        this.message = `The Enumeration ${this._enumeratorId.enumeration.fullName} has type ${this._enumeratorId.enumerationType}, while Enumerator ${this._enumeratorId.name} has type ${this._enumeratorId.enumeratorType}.`;
        return;
      case ECEditingStatus.EnumeratorDoesNotExist:
        this.message = `Enumerator ${this._enumeratorId.name} does not exists in Enumeration ${this._enumeratorId.enumeration.name}.`;
        return;
      case ECEditingStatus.InvalidECName:
        this.message = `Could not rename class ${this._schemaItemId.name} because the specified name is not a valid ECName.`;
        return;
      case ECEditingStatus.InvalidSchemaAlias:
        this.message = `Could not set the alias for schema ${this._schemaKey.name} because the specified alias is not a valid ECName.`;
        return;
      default:
        this.message = "";
    }
  }

  private _appendMessage(e: string) {
    return this.message ? `${e}: ${this.message}` : e;
  }

  private _getRuleViolationMessage(): string {
    if (!this._ruleViolations)
      return "";

    let violations = "";
    for (const diagnostic of this._ruleViolations) {
      violations += `${diagnostic.code}: ${diagnostic.messageText}\r\n`;
    }

    switch (this.identifier.typeIdentifier) {
      case SchemaTypeIdentifiers.SchemaIdentifier:
        return `Rule violations occurred from Schema ${this._schemaId.name}: ${violations}`;
      case SchemaTypeIdentifiers.SchemaItemIdentifier:
        return `Rule violations occurred from ${this._schemaItemId.schemaItemType} ${this._schemaItemId.name}: ${violations}`;
      case SchemaTypeIdentifiers.ClassIdentifier:
        return `Rule violations occurred from ${this._schemaItemId.schemaItemType} ${this._schemaItemId.name}: ${violations}`;
      case SchemaTypeIdentifiers.CustomAttributeIdentifier:
        return `Rule violations occurred from CustomAttribute ${this._customAttributeId.name}, container ${this._customAttributeId.containerFullName}: ${violations}`;
      case SchemaTypeIdentifiers.RelationshipConstraintIdentifier:
        return `Rule violations occurred from ${this._relationshipConstraintId.name} constraint of RelationshipClass ${this._relationshipConstraintId.relationshipKey.fullName}: ${violations}`;
      default:
        throw new Error("Invalid identifier.");
    }
  }

  private _createTaskErrorMessage() {
    // Make sure we have an inner error or else it is not a task error
    if (!this.innerError || !this.schemaEditType)
      return "";

    switch (this.identifier.typeIdentifier) {
      case SchemaTypeIdentifiers.SchemaIdentifier:
      case SchemaTypeIdentifiers.SchemaItemIdentifier:
      case SchemaTypeIdentifiers.ClassIdentifier:
      case SchemaTypeIdentifiers.RelationshipConstraintIdentifier:
        return `While performing task '${this.schemaEditType}' an error occurred editing ${this.identifier.typeIdentifier} ${this.identifier.name}.`;
      case SchemaTypeIdentifiers.PropertyIdentifier:
        return `While performing task '${this.schemaEditType}' an error occurred editing ${this.identifier.typeIdentifier} ${this.identifier.fullName}.`;
      default:
        throw new Error("Invalid identifier.");
    }
  }

  private isSchemaItemIdentifier(identifier: AnyIdentifier) {
    if (identifier.typeIdentifier !== SchemaTypeIdentifiers.SchemaItemIdentifier &&
      identifier.typeIdentifier !== SchemaTypeIdentifiers.ClassIdentifier)
      return true;

    return false;
  }
}
