/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Tile */

import {
  ByteStream,
  Id64String,
  JsonUtils,
} from "@bentley/bentleyjs-core";
import {
  Point3d,
  Transform,
  Vector3d,
} from "@bentley/geometry-core";
import {
  B3dmHeader,
  BatchType,
  ElementAlignedBox3d,
  Feature,
  FeatureTable,
  TileReadStatus,
} from "@bentley/imodeljs-common";
import {
  GltfReader,
  GltfReaderProps,
  GltfReaderResult,
  ShouldAbortReadGltf,
} from "./GltfReader";
import { RenderSystem } from "../render/System";
import { Mesh } from "../render/primitives/mesh/MeshPrimitives";
import { IModelConnection } from "../IModelConnection";
import { BatchedTileIdMap } from "./TileTree";

/**
 * Deserializes a tile in [b3dm](https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/specification/TileFormats/Batched3DModel) format.
 * @internal
 */
export class B3dmReader extends GltfReader {
  public static create(stream: ByteStream, iModel: IModelConnection, modelId: Id64String, is3d: boolean, range: ElementAlignedBox3d,
    system: RenderSystem, yAxisUp: boolean, isLeaf: boolean, tileCenter: Point3d, transformToRoot?: Transform,
    isCanceled?: ShouldAbortReadGltf, idMap?: BatchedTileIdMap): B3dmReader | undefined {
    const header = new B3dmHeader(stream);
    if (!header.isValid)
      return undefined;

    let returnToCenterTransform, pseudoRtcBias;
    if (header.featureTableJson && Array.isArray(header.featureTableJson.RTC_CENTER)) {
      returnToCenterTransform = Transform.createTranslationXYZ(header.featureTableJson.RTC_CENTER[0], header.featureTableJson.RTC_CENTER[1], header.featureTableJson.RTC_CENTER[2]);
    } else {
      /**
       * This is a workaround for tiles generated by
       * context capture which have a large offset from the tileset origin that exceeds the
       * capacity of 32 bit integers. It is essentially an ad hoc RTC applied at read time only if the tile is far from the
       * origin and there is no RTC supplied either with the B3DM of the GLTF.
       * as the vertices are supplied in a quantized format, applying the RTC bias to
       * quantization origin will make these tiles work correctly.
       */
      pseudoRtcBias = Vector3d.create(tileCenter.x, tileCenter.y, tileCenter.z);
    }

    if (undefined !== returnToCenterTransform)
      transformToRoot = transformToRoot ? transformToRoot.multiplyTransformTransform(returnToCenterTransform) : returnToCenterTransform;

    const props = GltfReaderProps.create(stream, yAxisUp);
    const batchTableLength = header.featureTableJson ? JsonUtils.asInt(header.featureTableJson.BATCH_LENGTH, 0) : 0;

    return undefined !== props ? new B3dmReader(props, iModel, modelId, is3d, system, range, isLeaf, batchTableLength,
      transformToRoot, header.batchTableJson, isCanceled, idMap, pseudoRtcBias) : undefined;
  }

  private constructor(props: GltfReaderProps, iModel: IModelConnection, modelId: Id64String, is3d: boolean, system: RenderSystem,
    private _range: ElementAlignedBox3d, private _isLeaf: boolean, private _batchTableLength: number, private _transformToRoot?: Transform, private _batchTableJson?: any
    , isCanceled?: ShouldAbortReadGltf, private _idMap?: BatchedTileIdMap, private _pseudoRtcBias?: Vector3d) {
    super(props, iModel, modelId, is3d, system, BatchType.Primary, isCanceled);
  }

  public async read(): Promise<GltfReaderResult> {
    // NB: For reality models with no batch table, we want the model ID in the feature table
    const featureTable: FeatureTable = new FeatureTable(this._batchTableLength ? this._batchTableLength : 1, this._modelId, this._type);
    if (this._batchTableLength > 0 && this._idMap !== undefined && this._batchTableJson !== undefined) {
      for (let i = 0; i < this._batchTableLength; i++) {
        const feature: any = {};
        for (const key in this._batchTableJson)
          feature[key] = this._batchTableJson[key][i];

        featureTable.insert(new Feature(this._idMap.getBatchId(feature)));
      }
    } else {
      const feature = new Feature(this._modelId);
      featureTable.insert(feature);
    }

    await this.loadTextures();
    if (this._isCanceled)
      return Promise.resolve({ readStatus: TileReadStatus.Canceled, isLeaf: this._isLeaf });

    return Promise.resolve(this.readGltfAndCreateGraphics(this._isLeaf, featureTable, this._range, this._transformToRoot, this._pseudoRtcBias));
  }

  protected readFeatures(features: Mesh.Features, json: any): boolean {
    let batchIds: any;
    if (this._batchTableLength > 0 && undefined !== this._batchTableJson && undefined !== json.attributes && undefined !== (batchIds = super.readBufferData32(json.attributes, "_BATCHID"))) {
      const indices = [];
      for (let i = 0; i < batchIds.count; i++)
        indices.push(batchIds.buffer[i]);

      features.setIndices(indices);
      return true;
    }

    const feature = new Feature(this._modelId);
    features.add(feature, 1);
    return true;
  }
}
