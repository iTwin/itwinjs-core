{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/IndexedEdgeGeometry.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { assert, dispose } from \"@itwin/core-bentley\";\nimport { RenderMode } from \"@itwin/core-common\";\nimport { TextureHandle } from \"./Texture\";\nimport { BufferHandle, BufferParameters, BuffersContainer } from \"./AttributeBuffers\";\nimport { MeshGeometry } from \"./MeshGeometry\";\nimport { AttributeMap } from \"./AttributeMap\";\nimport { GL } from \"./GL\";\nimport { System } from \"./System\";\n/** @see [[EdgeTable]]\n * @internal\n */\nexport class EdgeLUT {\n    constructor(texture, numSegments, silhouettePadding) {\n        this.texture = texture;\n        this.numSegments = numSegments;\n        this.silhouettePadding = silhouettePadding;\n    }\n    dispose() {\n        dispose(this.texture);\n    }\n    static create(table) {\n        const texture = TextureHandle.createForData(table.width, table.height, table.data);\n        return texture ? new EdgeLUT(texture, table.numSegments, table.silhouettePadding) : undefined;\n    }\n    get bytesUsed() {\n        return this.texture.bytesUsed;\n    }\n    get isDisposed() {\n        return this.texture.isDisposed;\n    }\n}\n/** @see [[IndexedEdgeParams]]\n * @internal\n */\nexport class IndexedEdgeGeometry extends MeshGeometry {\n    get lutBuffers() { return this._buffers; }\n    get asIndexedEdge() { return this; }\n    constructor(mesh, indices, numIndices, lut) {\n        super(mesh, numIndices);\n        this.edgeLut = lut;\n        this._buffers = BuffersContainer.create();\n        const attrPos = AttributeMap.findAttribute(\"a_pos\", 6 /* TechniqueId.IndexedEdge */, false);\n        assert(undefined !== attrPos);\n        this._buffers.addBuffer(indices, [BufferParameters.create(attrPos.location, 3, GL.DataType.UnsignedByte, false, 0, 0, false)]);\n        this._indices = indices;\n    }\n    dispose() {\n        dispose(this._buffers);\n        dispose(this._indices);\n        dispose(this.edgeLut);\n    }\n    get isDisposed() {\n        return this._buffers.isDisposed && this._indices.isDisposed && this.edgeLut.isDisposed;\n    }\n    static create(mesh, params) {\n        const indexBuffer = BufferHandle.createArrayBuffer(params.indices.data);\n        const lut = EdgeLUT.create(params.edges);\n        return indexBuffer && lut ? new IndexedEdgeGeometry(mesh, indexBuffer, params.indices.length, lut) : undefined;\n    }\n    collectStatistics(stats) {\n        stats.addIndexedEdges(this._indices.bytesUsed);\n        stats.addEdgeTable(this.edgeLut.bytesUsed);\n    }\n    _draw(numInstances, instances) {\n        const bufs = instances ?? this._buffers;\n        bufs.bind();\n        System.instance.drawArrays(GL.PrimitiveType.Triangles, 0, this._numIndices, numInstances);\n        bufs.unbind();\n    }\n    _wantWoWReversal() { return true; }\n    _getLineCode(params) { return this.computeEdgeLineCode(params); }\n    get techniqueId() { return 6 /* TechniqueId.IndexedEdge */; }\n    getPass(target) { return this.computeEdgePass(target); }\n    get renderOrder() { return this.isPlanar ? 14 /* RenderOrder.PlanarEdge */ : 6 /* RenderOrder.Edge */; }\n    getColor(target) { return this.computeEdgeColor(target); }\n    wantMonochrome(target) { return target.currentViewFlags.renderMode === RenderMode.Wireframe; }\n}\n//# sourceMappingURL=IndexedEdgeGeometry.js.map",
      "start": 1693508124581,
      "end": 1693508124657,
      "sourcemaps": null
    }
  ]
}
