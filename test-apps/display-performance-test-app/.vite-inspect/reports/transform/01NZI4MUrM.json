{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tile/ThreeDTileFormatInterpreter.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\nimport { JsonUtils, Logger, RealityDataStatus } from \"@itwin/core-bentley\";\nimport { Cartographic, EcefLocation } from \"@itwin/core-common\";\nimport { Matrix3d, Point3d, Range3d, Transform, Vector3d, YawPitchRollAngles } from \"@itwin/core-geometry\";\nimport { FrontendLoggerCategory } from \"../common/FrontendLoggerCategory\";\nimport { RealityDataError } from \"../RealityDataSource\";\nconst loggerCategory = FrontendLoggerCategory.RealityData;\n/**\n * This class provide methods used to interpret Cesium 3dTile format\n * @internal\n */\nexport class ThreeDTileFormatInterpreter {\n    /** Gets reality data spatial location and extents\n     * @param json root document file in json format\n     * @returns spatial location and volume of interest, in meters, centered around `spatial location`\n     * @throws [[RealityDataError]] if source is invalid or cannot be read\n     * @internal\n     */\n    static getSpatialLocationAndExtents(json) {\n        const worldRange = new Range3d();\n        let isGeolocated = true;\n        let location;\n        Logger.logTrace(loggerCategory, \"RealityData getSpatialLocationAndExtents\");\n        if (undefined === json?.root) {\n            Logger.logWarning(loggerCategory, `Error getSpatialLocationAndExtents - no root in json`);\n            // return first 1024 char from the json\n            const getMetaData = () => {\n                return { json: JSON.stringify(json).substring(0, 1024) };\n            };\n            const error = new RealityDataError(RealityDataStatus.InvalidData, \"Invalid or unknown data - no root in json\", getMetaData);\n            throw error;\n        }\n        try {\n            if (undefined !== json?.root?.boundingVolume?.region) {\n                const region = JsonUtils.asArray(json.root.boundingVolume.region);\n                Logger.logTrace(loggerCategory, \"RealityData json.root.boundingVolume.region\", () => ({ ...region }));\n                if (undefined === region) {\n                    Logger.logError(loggerCategory, `Error getSpatialLocationAndExtents - region undefined`);\n                    throw new TypeError(\"Unable to determine GeoLocation - no root Transform or Region on root.\");\n                }\n                const ecefLow = (Cartographic.fromRadians({ longitude: region[0], latitude: region[1], height: region[4] })).toEcef();\n                const ecefHigh = (Cartographic.fromRadians({ longitude: region[2], latitude: region[3], height: region[5] })).toEcef();\n                const ecefRange = Range3d.create(ecefLow, ecefHigh);\n                const cartoCenter = Cartographic.fromRadians({ longitude: (region[0] + region[2]) / 2.0, latitude: (region[1] + region[3]) / 2.0, height: (region[4] + region[5]) / 2.0 });\n                location = cartoCenter;\n                const ecefLocation = EcefLocation.createFromCartographicOrigin(cartoCenter);\n                // iModelDb.setEcefLocation(ecefLocation);\n                const ecefToWorld = ecefLocation.getTransform().inverse();\n                worldRange.extendRange(Range3d.fromJSON(ecefToWorld.multiplyRange(ecefRange)));\n            }\n            else {\n                let worldToEcefTransform = ThreeDTileFormatInterpreter.transformFromJson(json.root.transform);\n                Logger.logTrace(loggerCategory, \"RealityData json.root.transform\", () => ({ ...worldToEcefTransform }));\n                const range = ThreeDTileFormatInterpreter.rangeFromBoundingVolume(json.root.boundingVolume);\n                if (undefined === worldToEcefTransform)\n                    worldToEcefTransform = Transform.createIdentity();\n                const ecefRange = worldToEcefTransform.multiplyRange(range); // range in model -> range in ecef\n                const ecefCenter = worldToEcefTransform.multiplyPoint3d(range.center); // range center in model -> range center in ecef\n                const cartoCenter = Cartographic.fromEcef(ecefCenter); // ecef center to cartographic center\n                const isNotNearEarthSurface = cartoCenter && (cartoCenter.height < -5000); // 5 km under ground!\n                const earthCenterToRangeCenterRayLenght = range.center.magnitude();\n                if (worldToEcefTransform.matrix.isIdentity && (earthCenterToRangeCenterRayLenght < 1.0E5 || isNotNearEarthSurface)) {\n                    isGeolocated = false;\n                    worldRange.extendRange(Range3d.fromJSON(ecefRange));\n                    const centerOfEarth = new EcefLocation({ origin: { x: 0.0, y: 0.0, z: 0.0 }, orientation: { yaw: 0.0, pitch: 0.0, roll: 0.0 } });\n                    location = centerOfEarth;\n                    Logger.logTrace(loggerCategory, \"RealityData NOT Geolocated\", () => ({ ...location }));\n                }\n                else {\n                    let ecefLocation;\n                    const locationOrientation = YawPitchRollAngles.tryFromTransform(worldToEcefTransform);\n                    // Fix Bug 445630: [RDV][Regression] Orientation of georeferenced Reality Mesh is wrong.\n                    // Use json.root.transform only if defined and not identity -> otherwise will use a transform computed from cartographic center.\n                    if (!worldToEcefTransform.matrix.isIdentity && locationOrientation !== undefined && locationOrientation.angles !== undefined)\n                        ecefLocation = new EcefLocation({ origin: locationOrientation.origin, orientation: locationOrientation.angles.toJSON() });\n                    else\n                        ecefLocation = EcefLocation.createFromCartographicOrigin(cartoCenter);\n                    location = ecefLocation;\n                    Logger.logTrace(loggerCategory, \"RealityData is worldToEcefTransform.matrix.isIdentity\", () => ({ isIdentity: worldToEcefTransform.matrix.isIdentity }));\n                    // iModelDb.setEcefLocation(ecefLocation);\n                    const ecefToWorld = ecefLocation.getTransform().inverse();\n                    worldRange.extendRange(Range3d.fromJSON(ecefToWorld.multiplyRange(ecefRange)));\n                    Logger.logTrace(loggerCategory, \"RealityData ecefToWorld\", () => ({ ...ecefToWorld }));\n                }\n            }\n        }\n        catch (e) {\n            Logger.logWarning(loggerCategory, `Error getSpatialLocationAndExtents - cannot interpret json`);\n            // return first 1024 char from the json\n            const getMetaData = () => {\n                return { json: JSON.stringify(json).substring(0, 1024) };\n            };\n            const error = new RealityDataError(RealityDataStatus.InvalidData, \"Invalid or unknown data\", getMetaData);\n            throw error;\n        }\n        const spatialLocation = { location, worldRange, isGeolocated };\n        return spatialLocation;\n    }\n    /** Gets information to identify the product and engine that create this reality data\n     * Will return undefined if cannot be resolved\n     * @param rootDocjson root document file in json format\n     * @returns information to identify the product and engine that create this reality data\n     * @alpha\n     */\n    static getPublisherProductInfo(rootDocjson) {\n        const info = { product: \"\", engine: \"\", version: \"\" };\n        if (rootDocjson && rootDocjson.root) {\n            if (rootDocjson.root.SMPublisherInfo) {\n                info.product = rootDocjson.root.SMPublisherInfo.Product ? rootDocjson.root.SMPublisherInfo.Product : \"\";\n                info.engine = rootDocjson.root.SMPublisherInfo.Publisher ? rootDocjson.root.SMPublisherInfo.Publisher : \"\";\n                info.version = rootDocjson.root.SMPublisherInfo[\"Publisher Version\"] ? rootDocjson.root.SMPublisherInfo[\"Publisher Version\"] : \"\";\n            }\n        }\n        return info;\n    }\n    /** Gets information about 3dTile file for this reality data\n     * Will return undefined if cannot be resolved\n     * @param rootDocjson root document file in json format\n     * @returns information about 3dTile file for this reality data\n     * @internal\n     */\n    static getFileInfo(rootDocjson) {\n        const info = {\n            rootChildren: rootDocjson?.root?.children?.length ?? 0,\n        };\n        return info;\n    }\n    /** Convert a boundingVolume into a range\n     * @param boundingVolume the bounding volume to convert\n     * @returns the range or undefined if cannot convert\n     * @internal\n     */\n    static rangeFromBoundingVolume(boundingVolume) {\n        if (undefined === boundingVolume)\n            return undefined;\n        if (Array.isArray(boundingVolume.box)) {\n            const box = boundingVolume.box;\n            const center = Point3d.create(box[0], box[1], box[2]);\n            const ux = Vector3d.create(box[3], box[4], box[5]);\n            const uy = Vector3d.create(box[6], box[7], box[8]);\n            const uz = Vector3d.create(box[9], box[10], box[11]);\n            const corners = [];\n            for (let j = 0; j < 2; j++) {\n                for (let k = 0; k < 2; k++) {\n                    for (let l = 0; l < 2; l++) {\n                        corners.push(center.plus3Scaled(ux, (j ? -1.0 : 1.0), uy, (k ? -1.0 : 1.0), uz, (l ? -1.0 : 1.0)));\n                    }\n                }\n            }\n            return Range3d.createArray(corners);\n        }\n        else if (Array.isArray(boundingVolume.sphere)) {\n            const sphere = boundingVolume.sphere;\n            const center = Point3d.create(sphere[0], sphere[1], sphere[2]);\n            const radius = sphere[3];\n            return Range3d.createXYZXYZ(center.x - radius, center.y - radius, center.z - radius, center.x + radius, center.y + radius, center.z + radius);\n        }\n        return undefined;\n    }\n    /** Convert a boundingVolume into a range\n     * @internal\n     */\n    static maximumSizeFromGeometricTolerance(range, geometricError) {\n        const minToleranceRatio = .5; // Nominally the error on screen size of a tile.  Increasing generally increases performance (fewer draw calls) at expense of higher load times.\n        return minToleranceRatio * range.diagonal().magnitude() / geometricError;\n    }\n    /** Convert a boundingVolume into a range\n     * @internal\n     */\n    static transformFromJson(jTrans) {\n        return (jTrans === undefined) ? undefined : Transform.createOriginAndMatrix(Point3d.create(jTrans[12], jTrans[13], jTrans[14]), Matrix3d.createRowValues(jTrans[0], jTrans[4], jTrans[8], jTrans[1], jTrans[5], jTrans[9], jTrans[2], jTrans[6], jTrans[10]));\n    }\n}\n//# sourceMappingURL=ThreeDTileFormatInterpreter.js.map",
      "start": 1693508121974,
      "end": 1693508122153,
      "sourcemaps": null
    }
  ]
}
