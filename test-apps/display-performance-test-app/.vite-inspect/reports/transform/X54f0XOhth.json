{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tile/OPCFormatInterpreter.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\nimport { Cartographic, EcefLocation } from \"@itwin/core-common\";\nimport { Range3d } from \"@itwin/core-geometry\";\nimport { CRSManager, Downloader, DownloaderXhr, OnlineEngine, OPCReader, OrbitGtBounds, PageCachedFile, UrlFS } from \"@itwin/core-orbitgt\";\nimport { FrontendLoggerCategory } from \"../common/FrontendLoggerCategory\";\nimport { BentleyError, Logger, RealityDataStatus } from \"@itwin/core-bentley\";\nimport { RealityDataError } from \"../RealityDataSource\";\nconst loggerCategory = FrontendLoggerCategory.RealityData;\n/**\n * This class provide methods used to interpret Orbit Point Cloud (OPC) format\n * @internal\n */\nexport class OPCFormatInterpreter {\n    /** Gets an OPC file reader from a blobFileUrl\n     * @param blobFileURL the name of the file.\n     * @returns return a file reader open to read provided blob file\n     * @internal\n     */\n    static async getFileReaderFromBlobFileURL(blobFileURL) {\n        if (Downloader.INSTANCE == null)\n            Downloader.INSTANCE = new DownloaderXhr();\n        if (CRSManager.ENGINE == null)\n            CRSManager.ENGINE = await OnlineEngine.create();\n        // let blobFileURL: string = rdUrl;\n        // if (accountName.length > 0) blobFileURL = UrlFS.getAzureBlobSasUrl(opcConfig.accountName, opcConfig.containerName, opcConfig.blobFileName, opcConfig.sasToken);\n        const urlFS = new UrlFS();\n        // wrap a caching layer (16 MB) around the blob file\n        const blobFileSize = await urlFS.getFileLength(blobFileURL);\n        Logger.logTrace(loggerCategory, `OPC File Size is ${blobFileSize}`);\n        const blobFile = new PageCachedFile(urlFS, blobFileURL, blobFileSize, 128 * 1024 /* pageSize */, 128 /* maxPageCount */);\n        const fileReader = await OPCReader.openFile(blobFile, blobFileURL, true /* lazyLoading */);\n        return fileReader;\n    }\n    /** Gets reality data spatial location and extents\n     * @param fileReader a file reader instance obtains from call to getFileReaderFromBlobFileURL\n     * @returns spatial location and volume of interest, in meters, centered around `spatial location`\n     * @throws [[RealityDataError]] if source is invalid or cannot be read\n     * @internal\n     */\n    static async getSpatialLocationAndExtents(fileReader) {\n        let worldRange = new Range3d();\n        let location;\n        let isGeolocated = true;\n        const bounds = fileReader.getFileBounds();\n        worldRange = Range3d.createXYZXYZ(bounds.getMinX(), bounds.getMinY(), bounds.getMinZ(), bounds.getMaxX(), bounds.getMaxY(), bounds.getMaxZ());\n        isGeolocated = false;\n        const fileCrs = fileReader.getFileCRS();\n        if (fileCrs) {\n            try {\n                await CRSManager.ENGINE.prepareForArea(fileCrs, bounds);\n                const wgs84ECEFCrs = \"4978\";\n                await CRSManager.ENGINE.prepareForArea(wgs84ECEFCrs, new OrbitGtBounds());\n                const ecefBounds = CRSManager.transformBounds(bounds, fileCrs, wgs84ECEFCrs);\n                const ecefRange = Range3d.createXYZXYZ(ecefBounds.getMinX(), ecefBounds.getMinY(), ecefBounds.getMinZ(), ecefBounds.getMaxX(), ecefBounds.getMaxY(), ecefBounds.getMaxZ());\n                const ecefCenter = ecefRange.localXYZToWorld(.5, .5, .5);\n                const cartoCenter = Cartographic.fromEcef(ecefCenter);\n                cartoCenter.height = 0;\n                const ecefLocation = EcefLocation.createFromCartographicOrigin(cartoCenter);\n                location = ecefLocation;\n                // this.iModelDb.setEcefLocation(ecefLocation);\n                const ecefToWorld = ecefLocation.getTransform().inverse();\n                worldRange = ecefToWorld.multiplyRange(ecefRange);\n                isGeolocated = true;\n            }\n            catch (e) {\n                Logger.logWarning(loggerCategory, `Error getSpatialLocationAndExtents - cannot interpret point cloud`);\n                const errorProps = BentleyError.getErrorProps(e);\n                const getMetaData = () => {\n                    return { errorProps };\n                };\n                const error = new RealityDataError(RealityDataStatus.InvalidData, \"Invalid or unknown data\", getMetaData);\n                throw error;\n            }\n        }\n        else {\n            // NoGCS case\n            isGeolocated = false;\n            const centerOfEarth = new EcefLocation({ origin: { x: 0.0, y: 0.0, z: 0.0 }, orientation: { yaw: 0.0, pitch: 0.0, roll: 0.0 } });\n            location = centerOfEarth;\n            Logger.logTrace(loggerCategory, \"OPC RealityData NOT Geolocated\", () => ({ ...location }));\n        }\n        const spatialLocation = { location, worldRange, isGeolocated };\n        return spatialLocation;\n    }\n}\n//# sourceMappingURL=OPCFormatInterpreter.js.map",
      "start": 1693508121993,
      "end": 1693508122160,
      "sourcemaps": null
    }
  ]
}
