{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/geometry3d/CoincidentGeometryOps.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module CartesianGeometry\n */\nimport { assert } from \"@itwin/core-bentley\";\nimport { CurveLocationDetail, CurveLocationDetailPair } from \"../curve/CurveLocationDetail\";\nimport { Geometry } from \"../Geometry\";\nimport { AngleSweep } from \"./AngleSweep\";\nimport { Vector3d } from \"./Point3dVector3d\";\nimport { Segment1d } from \"./Segment1d\";\n/**\n * `CoincidentGeometryQuery` has methods useful in testing for overlapping geometry.\n * * Each instance carries tolerance information that can be reused over extended call sequences.\n * * These methods are expected to be called internally by CurveCurve intersection methods.\n * @internal\n */\nexport class CoincidentGeometryQuery {\n    get tolerance() {\n        return this._tolerance;\n    }\n    constructor(tolerance = Geometry.smallMetricDistance) {\n        this._tolerance = tolerance;\n    }\n    static create(tolerance = Geometry.smallMetricDistance) {\n        return new CoincidentGeometryQuery(tolerance);\n    }\n    /**\n     * * Assign both the fraction and fraction1 values in the detail, possibly swapped.\n     * * reevaluate the points as simple interpolation between given points.\n     */\n    static assignDetailInterpolatedFractionsAndPoints(detail, f0, f1, pointA, pointB, swap = false) {\n        if (swap) {\n            detail.fraction = f1;\n            detail.fraction1 = f0;\n        }\n        else {\n            detail.fraction = f0;\n            detail.fraction1 = f1;\n        }\n        detail.point = pointA.interpolate(detail.fraction, pointB, detail.point);\n        detail.point1 = pointA.interpolate(detail.fraction1, pointB, detail.point1);\n    }\n    /** Return a curve location detail with projection of a `spacePoint` to the line segment with `pointA` and `pointB`\n     *\n     */\n    projectPointToSegmentXY(spacePoint, pointA, pointB) {\n        this._vectorU = Vector3d.createStartEnd(pointA, pointB, this._vectorU);\n        this._vectorV = Vector3d.createStartEnd(pointA, spacePoint, this._vectorV);\n        const uDotU = this._vectorU.dotProductXY(this._vectorU);\n        const uDotV = this._vectorU.dotProductXY(this._vectorV);\n        const fraction = Geometry.safeDivideFraction(uDotV, uDotU, 0.0);\n        return CurveLocationDetail.createCurveFractionPoint(undefined, fraction, pointA.interpolate(fraction, pointB));\n    }\n    /**\n     * * project `pointA0` and `pointA1` onto the segment with `pointB0` and `pointB1`\n     * * In the returned detail pair, the `detailA` has fractions along segmentA, and `detailB` has fractions along segment B\n     * @param pointA0 start point of segment A\n     * @param pointA1 end point of segment A\n     * @param pointB0 start point of segment B\n     * @param pointB1 end point of segment B\n     */\n    coincidentSegmentRangeXY(pointA0, pointA1, pointB0, pointB1, restrictToBounds = true) {\n        const detailA0OnB = this.projectPointToSegmentXY(pointA0, pointB0, pointB1);\n        if (pointA0.distanceXY(detailA0OnB.point) > this._tolerance)\n            return undefined;\n        const detailA1OnB = this.projectPointToSegmentXY(pointA1, pointB0, pointB1);\n        if (pointA1.distanceXY(detailA1OnB.point) > this._tolerance)\n            return undefined;\n        const detailB0OnA = this.projectPointToSegmentXY(pointB0, pointA0, pointA1);\n        if (pointB0.distanceXY(detailB0OnA.point) > this._tolerance)\n            return undefined;\n        const detailB1OnA = this.projectPointToSegmentXY(pointB1, pointA0, pointA1);\n        if (pointB1.distanceXY(detailB1OnA.point) > this._tolerance)\n            return undefined;\n        detailA0OnB.fraction1 = detailA1OnB.fraction;\n        detailA0OnB.point1 = detailA1OnB.point; // capture -- detailA1OnB is not reused.\n        detailB0OnA.fraction1 = detailB1OnA.fraction;\n        detailB0OnA.point1 = detailB1OnA.point;\n        if (!restrictToBounds)\n            return CurveLocationDetailPair.createCapture(detailB0OnA, detailA0OnB);\n        const segment = Segment1d.create(detailB0OnA.fraction, detailB0OnA.fraction1);\n        if (segment.clampDirectedTo01()) {\n            const f0 = segment.x0;\n            const f1 = segment.x1;\n            const h0 = detailB0OnA.inverseInterpolateFraction(f0);\n            const h1 = detailB0OnA.inverseInterpolateFraction(f1);\n            // recompute fractions and points..\n            CoincidentGeometryQuery.assignDetailInterpolatedFractionsAndPoints(detailB0OnA, f0, f1, pointA0, pointA1, f0 > f1);\n            CoincidentGeometryQuery.assignDetailInterpolatedFractionsAndPoints(detailA0OnB, h0, h1, pointB0, pointB1, h0 > h1);\n            return CurveLocationDetailPair.createCapture(detailB0OnA, detailA0OnB);\n        }\n        else {\n            if (segment.signedDelta() < 0.0) {\n                if (detailB0OnA.point.isAlmostEqual(pointA0, this.tolerance)) {\n                    detailB0OnA.collapseToStart();\n                    detailA0OnB.collapseToStart();\n                    return CurveLocationDetailPair.createCapture(detailB0OnA, detailA0OnB);\n                }\n                if (detailB0OnA.point1.isAlmostEqual(pointA1, this.tolerance)) {\n                    detailB0OnA.collapseToEnd();\n                    detailA0OnB.collapseToEnd();\n                    return CurveLocationDetailPair.createCapture(detailB0OnA, detailA0OnB);\n                }\n            }\n            else {\n                if (detailB0OnA.point.isAlmostEqual(pointA1, this.tolerance)) {\n                    detailB0OnA.collapseToStart();\n                    detailA0OnB.collapseToEnd();\n                    return CurveLocationDetailPair.createCapture(detailB0OnA, detailA0OnB);\n                }\n                if (detailB0OnA.point1.isAlmostEqual(pointA0, this.tolerance)) {\n                    detailB0OnA.collapseToEnd();\n                    detailA0OnB.collapseToStart();\n                    return CurveLocationDetailPair.createCapture(detailB0OnA, detailA0OnB);\n                }\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Create a CurveLocationDetailPair for a coincident interval of two overlapping curves\n     * @param cpA curveA\n     * @param cpB curveB\n     * @param fractionsOnA coincident interval of curveB in fraction space of curveA\n     * @param fractionB0 curveB start in fraction space of curveA\n     * @param fractionB1 curveB end in fraction space of curveA\n     * @param reverse whether curveB and curveA have opposite direction\n     */\n    createDetailPair(cpA, cpB, fractionsOnA, fractionB0, fractionB1, reverse) {\n        const deltaB = fractionB1 - fractionB0;\n        const g0 = Geometry.conditionalDivideFraction(fractionsOnA.x0 - fractionB0, deltaB);\n        const g1 = Geometry.conditionalDivideFraction(fractionsOnA.x1 - fractionB0, deltaB);\n        if (g0 !== undefined && g1 !== undefined) {\n            const detailA = CurveLocationDetail.createCurveEvaluatedFractionFraction(cpA, fractionsOnA.x0, fractionsOnA.x1);\n            const detailB = CurveLocationDetail.createCurveEvaluatedFractionFraction(cpB, g0, g1);\n            if (reverse)\n                detailA.swapFractionsAndPoints();\n            return CurveLocationDetailPair.createCapture(detailA, detailB);\n        }\n        return undefined;\n    }\n    appendDetailPair(result, pair) {\n        if (pair === undefined)\n            return result;\n        if (result === undefined)\n            return [pair];\n        result.push(pair);\n        return result;\n    }\n    /**\n     * Test if 2 arcs have coinciding portions.\n     * @param arcA\n     * @param arcB\n     * @param _restrictToBounds\n     * @return 0, 1, or 2 overlap points/intervals\n     */\n    coincidentArcIntersectionXY(arcA, arcB, _restrictToBounds = true) {\n        let result;\n        if (arcA.center.isAlmostEqual(arcB.center, this.tolerance)) {\n            const matrixBToA = arcA.matrixRef.multiplyMatrixInverseMatrix(arcB.matrixRef);\n            if (matrixBToA) {\n                const ux = matrixBToA.at(0, 0);\n                const uy = matrixBToA.at(1, 0);\n                const vx = matrixBToA.at(0, 1);\n                const vy = matrixBToA.at(1, 1);\n                const ru = Geometry.hypotenuseXY(ux, uy);\n                const rv = Geometry.hypotenuseXY(vx, vy);\n                const dot = Geometry.dotProductXYXY(ux, uy, vx, vy);\n                const cross = Geometry.crossProductXYXY(ux, uy, vx, vy);\n                if (Geometry.isAlmostEqualNumber(ru, 1.0)\n                    && Geometry.isAlmostEqualNumber(rv, 1.0)\n                    && Geometry.isAlmostEqualNumber(0, dot)) {\n                    const alphaB0Radians = Math.atan2(uy, ux); // angular position of arcB 0 point in arcA sweep\n                    const sweepDirection = cross > 0 ? 1.0 : -1.0; // 1 if arcB parameter space sweeps in same direction as arcA, -1 if opposite\n                    const betaStartRadians = alphaB0Radians + sweepDirection * arcB.sweep.startRadians; // arcB start in arcA parameter space\n                    const betaEndRadians = alphaB0Radians + sweepDirection * arcB.sweep.endRadians; // arcB end in arcA parameter space\n                    const fractionSpacesReversed = (sweepDirection * arcA.sweep.sweepRadians * arcB.sweep.sweepRadians) < 0;\n                    const sweepB = AngleSweep.createStartEndRadians(betaStartRadians, betaEndRadians);\n                    const sweepA = arcA.sweep;\n                    const fractionPeriodA = sweepA.fractionPeriod();\n                    const fractionB0 = sweepA.radiansToPositivePeriodicFraction(sweepB.startRadians); // arcB start in arcA fraction space\n                    assert(fractionB0 >= 0.0);\n                    const fractionSweep = sweepB.sweepRadians / sweepA.sweepRadians; // arcB sweep in arcA fraction space\n                    const fractionB1 = fractionB0 + fractionSweep; // arcB end in arcA fraction space\n                    const fractionSweepB = Segment1d.create(fractionB0, fractionB1);\n                    /** lambda to add a coincident interval or isolated intersection, given inputs in arcA fraction space\n                     * @param arcBInArcAFractionSpace span of arcB in arcA fraction space. On return, clamped to [0,1] if nontrivial.\n                     * @param testStartOfArcA if no nontrivial coincident interval was found, look for an isolated intersection at the start (true) or end (false) of arcA\n                     * @returns whether a detail pair was appended to result\n                     */\n                    const appendCoincidentIntersection = (arcBInArcAFractionSpace, testStartOfArcA) => {\n                        const size = result ? result.length : 0;\n                        const arcBStart = arcBInArcAFractionSpace.x0;\n                        const arcBEnd = arcBInArcAFractionSpace.x1;\n                        if (arcBInArcAFractionSpace.clampDirectedTo01() && !Geometry.isSmallRelative(arcBInArcAFractionSpace.absoluteDelta())) {\n                            result = this.appendDetailPair(result, this.createDetailPair(arcA, arcB, arcBInArcAFractionSpace, arcBStart, arcBEnd, fractionSpacesReversed));\n                        }\n                        else { // test isolated intersection\n                            const testStartOfArcB = fractionSpacesReversed ? testStartOfArcA : !testStartOfArcA;\n                            const arcAPt = this._point0 = testStartOfArcA ? arcA.startPoint(this._point0) : arcA.endPoint(this._point0);\n                            const arcBPt = this._point1 = testStartOfArcB ? arcB.startPoint(this._point1) : arcB.endPoint(this._point1);\n                            if (arcAPt.isAlmostEqual(arcBPt, this.tolerance)) {\n                                const detailA = CurveLocationDetail.createCurveFractionPoint(arcA, testStartOfArcA ? 0 : 1, arcAPt);\n                                const detailB = CurveLocationDetail.createCurveFractionPoint(arcB, testStartOfArcB ? 0 : 1, arcBPt);\n                                result = this.appendDetailPair(result, CurveLocationDetailPair.createCapture(detailA, detailB));\n                            }\n                        }\n                        return result !== undefined && result.length > size;\n                    };\n                    appendCoincidentIntersection(fractionSweepB, false); // compute overlap in strict interior, or at end of arcA\n                    // check overlap at start of arcA with a periodic shift of fractionSweepB\n                    if (fractionB1 >= fractionPeriodA)\n                        appendCoincidentIntersection(Segment1d.create(fractionB0 - fractionPeriodA, fractionB1 - fractionPeriodA), true);\n                    else if (fractionB0 === 0.0)\n                        appendCoincidentIntersection(Segment1d.create(fractionB0 + fractionPeriodA, fractionB1 + fractionPeriodA), true);\n                }\n            }\n        }\n        return result;\n    }\n}\n//# sourceMappingURL=CoincidentGeometryOps.js.map",
      "start": 1693508124962,
      "end": 1693508125038,
      "sourcemaps": null
    }
  ]
}
