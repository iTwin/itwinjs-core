{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tools/ToolAdmin.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tools\n */\nimport { AbandonedError, assert, BeEvent, BeTimePoint, IModelStatus, Logger } from \"@itwin/core-bentley\";\nimport { Matrix3d, Point2d, Point3d, Transform } from \"@itwin/core-geometry\";\nimport { Easing, NpcCenter } from \"@itwin/core-common\";\nimport { TentativeOrAccuSnap } from \"../AccuSnap\";\nimport { FrontendLoggerCategory } from \"../common/FrontendLoggerCategory\";\nimport { IModelApp } from \"../IModelApp\";\nimport { linePlaneIntersect } from \"../LinePlaneIntersect\";\nimport { MessageBoxIconType, MessageBoxType } from \"../NotificationManager\";\nimport { IconSprites } from \"../Sprites\";\nimport { DynamicsContext } from \"../ViewContext\";\nimport { ScreenViewport } from \"../Viewport\";\nimport { ViewStatus } from \"../ViewStatus\";\nimport { PrimitiveTool } from \"./PrimitiveTool\";\nimport { BeButton, BeButtonEvent, BeButtonState, BeModifierKeys, BeTouchEvent, BeWheelEvent, CoordinateLockOverrides, CoordSource, EventHandled, InputSource, } from \"./Tool\";\nimport { ToolSettings } from \"./ToolSettings\";\n/**\n * @public\n * @extensions\n */\nexport var StartOrResume;\n(function (StartOrResume) {\n    StartOrResume[StartOrResume[\"Start\"] = 1] = \"Start\";\n    StartOrResume[StartOrResume[\"Resume\"] = 2] = \"Resume\";\n})(StartOrResume || (StartOrResume = {}));\n/**\n * @public\n * @extensions\n */\nexport var ManipulatorToolEvent;\n(function (ManipulatorToolEvent) {\n    ManipulatorToolEvent[ManipulatorToolEvent[\"Start\"] = 1] = \"Start\";\n    ManipulatorToolEvent[ManipulatorToolEvent[\"Stop\"] = 2] = \"Stop\";\n    ManipulatorToolEvent[ManipulatorToolEvent[\"Suspend\"] = 3] = \"Suspend\";\n    ManipulatorToolEvent[ManipulatorToolEvent[\"Unsuspend\"] = 4] = \"Unsuspend\";\n})(ManipulatorToolEvent || (ManipulatorToolEvent = {}));\n/** Maintains the state of tool settings properties for the current session.\n * @see [[ToolAdmin.toolSettingsState]] to access the state for the current session.\n * @public\n */\nexport class ToolSettingsState {\n    /** Retrieve saved tool settings DialogItemValue by property name. */\n    getInitialToolSettingValue(toolId, propertyName) {\n        const key = `${toolId}:${propertyName}`;\n        const savedValue = window.sessionStorage.getItem(key);\n        if (null !== savedValue) {\n            return JSON.parse(savedValue);\n        }\n        return undefined;\n    }\n    /** Retrieve an array of DialogPropertyItem with the values latest values that were used in the session. */\n    getInitialToolSettingValues(toolId, propertyNames) {\n        const initializedProperties = [];\n        let propertyValue;\n        propertyNames.forEach((propertyName) => {\n            propertyValue = this.getInitialToolSettingValue(toolId, propertyName);\n            if (propertyValue)\n                initializedProperties.push({ value: propertyValue, propertyName });\n        });\n        return initializedProperties.length ? initializedProperties : undefined;\n    }\n    /** Save single tool settings value to session storage. */\n    saveToolSettingProperty(toolId, item) {\n        const key = `${toolId}:${item.propertyName}`;\n        const objectAsString = JSON.stringify(item.value);\n        window.sessionStorage.setItem(key, objectAsString);\n    }\n    /** Save an array of tool settings values to session storage */\n    saveToolSettingProperties(toolId, tsProps) {\n        tsProps.forEach((item) => this.saveToolSettingProperty(toolId, item));\n    }\n}\n/** @internal */\nexport class ToolState {\n    constructor() {\n        this.coordLockOvr = CoordinateLockOverrides.None;\n        this.locateCircleOn = false;\n    }\n    setFrom(other) {\n        this.coordLockOvr = other.coordLockOvr;\n        this.locateCircleOn = other.locateCircleOn;\n    }\n    clone() {\n        const val = new ToolState();\n        val.setFrom(this);\n        return val;\n    }\n}\n/** @internal */\nexport class SuspendedToolState {\n    constructor() {\n        this._shuttingDown = false;\n        const { toolAdmin, viewManager, accuSnap, locateManager } = IModelApp;\n        toolAdmin.setIncompatibleViewportCursor(true); // Don't save this\n        this._toolState = toolAdmin.toolState.clone();\n        this._accuSnapState = accuSnap.toolState.clone();\n        this._locateOptions = locateManager.options.clone();\n        this._viewCursor = viewManager.cursor;\n        this._inDynamics = viewManager.inDynamicsMode;\n        if (this._inDynamics)\n            viewManager.endDynamicsMode();\n    }\n    stop() {\n        if (this._shuttingDown)\n            return;\n        const { toolAdmin, viewManager, accuSnap, locateManager } = IModelApp;\n        toolAdmin.setIncompatibleViewportCursor(true); // Don't restore this\n        toolAdmin.toolState.setFrom(this._toolState);\n        accuSnap.toolState.setFrom(this._accuSnapState);\n        locateManager.options.setFrom(this._locateOptions);\n        viewManager.setViewCursor(this._viewCursor);\n        if (this._inDynamics)\n            viewManager.beginDynamicsMode();\n        else\n            viewManager.endDynamicsMode();\n    }\n}\n/** @internal */\nexport class CurrentInputState {\n    constructor() {\n        this._rawPoint = new Point3d();\n        this._point = new Point3d();\n        this._viewPoint = new Point3d();\n        this.qualifiers = BeModifierKeys.None;\n        this.button = [new BeButtonState(), new BeButtonState(), new BeButtonState()];\n        this.lastButton = BeButton.Data;\n        this.inputSource = InputSource.Unknown;\n        this.lastMotion = new Point2d();\n    }\n    get rawPoint() { return this._rawPoint; }\n    set rawPoint(pt) { this._rawPoint.setFrom(pt); }\n    get point() { return this._point; }\n    set point(pt) { this._point.setFrom(pt); }\n    get viewPoint() { return this._viewPoint; }\n    set viewPoint(pt) { this._viewPoint.setFrom(pt); }\n    get isShiftDown() { return 0 !== (this.qualifiers & BeModifierKeys.Shift); }\n    get isControlDown() { return 0 !== (this.qualifiers & BeModifierKeys.Control); }\n    get isAltDown() { return 0 !== (this.qualifiers & BeModifierKeys.Alt); }\n    isDragging(button) { return this.button[button].isDragging; }\n    onStartDrag(button) { this.button[button].isDragging = true; }\n    onInstallTool() {\n        this.clearKeyQualifiers();\n        this.lastWheelEvent = undefined;\n        this.lastTouchStart = this.touchTapTimer = this.touchTapCount = undefined;\n    }\n    clearKeyQualifiers() { this.qualifiers = BeModifierKeys.None; }\n    clearViewport(vp) {\n        if (vp === this.viewport)\n            this.viewport = undefined;\n    }\n    isAnyDragging() { return this.button.some((button) => button.isDragging); }\n    setKeyQualifier(qual, down) {\n        this.qualifiers = down ? (this.qualifiers | qual) : (this.qualifiers & (~qual));\n    }\n    setKeyQualifiers(ev) {\n        this.setKeyQualifier(BeModifierKeys.Shift, ev.shiftKey);\n        this.setKeyQualifier(BeModifierKeys.Control, ev.ctrlKey);\n        this.setKeyQualifier(BeModifierKeys.Alt, ev.altKey);\n    }\n    onMotion(pt2d) {\n        this.lastMotion.x = pt2d.x;\n        this.lastMotion.y = pt2d.y;\n    }\n    changeButtonToDownPoint(ev) {\n        ev.point = this.button[ev.button].downUorPt;\n        ev.rawPoint = this.button[ev.button].downRawPt;\n        if (ev.viewport)\n            ev.viewPoint = ev.viewport.worldToView(ev.rawPoint);\n    }\n    updateDownPoint(ev) { this.button[ev.button].downUorPt = ev.point; }\n    onButtonDown(button) {\n        const viewPt = this.viewport.worldToView(this.button[button].downRawPt);\n        const center = this.viewport.npcToView(NpcCenter);\n        viewPt.z = center.z;\n        const now = Date.now();\n        const isDoubleClick = ((now - this.button[button].downTime) < ToolSettings.doubleClickTimeout.milliseconds) && (viewPt.distance(this.viewPoint) < this.viewport.pixelsFromInches(ToolSettings.doubleClickToleranceInches));\n        this.button[button].init(this.point, this.rawPoint, now, true, isDoubleClick, false, this.inputSource);\n        this.lastButton = button;\n    }\n    onButtonUp(button) {\n        this.button[button].isDown = false;\n        this.button[button].isDragging = false;\n        this.lastButton = button;\n    }\n    toEvent(ev, useSnap) {\n        let coordsFrom = CoordSource.User;\n        const point = this.point.clone();\n        let viewport = this.viewport;\n        if (useSnap) {\n            const snap = TentativeOrAccuSnap.getCurrentSnap(false);\n            if (snap) {\n                coordsFrom = snap.isHot ? CoordSource.ElemSnap : CoordSource.User;\n                point.setFrom(snap.isPointAdjusted ? snap.adjustedPoint : snap.getPoint()); // NOTE: adjustedPoint can be set by adjustSnapPoint even when not hot...\n                viewport = snap.viewport;\n            }\n            else if (IModelApp.tentativePoint.isActive) {\n                coordsFrom = CoordSource.TentativePoint;\n                point.setFrom(IModelApp.tentativePoint.getPoint());\n                viewport = IModelApp.tentativePoint.viewport;\n            }\n        }\n        const buttonState = this.button[this.lastButton];\n        ev.init({\n            point, rawPoint: this.rawPoint, viewPoint: this.viewPoint, viewport, coordsFrom,\n            keyModifiers: this.qualifiers, button: this.lastButton, isDown: buttonState.isDown,\n            isDoubleClick: buttonState.isDoubleClick, isDragging: buttonState.isDragging,\n            inputSource: this.inputSource,\n        });\n    }\n    adjustLastDataPoint(ev) {\n        const state = this.button[BeButton.Data];\n        state.downUorPt = ev.point;\n        state.downRawPt = ev.point;\n        this.viewport = ev.viewport;\n    }\n    toEventFromLastDataPoint(ev) {\n        const state = this.button[BeButton.Data];\n        const point = state.downUorPt;\n        const rawPoint = state.downRawPt;\n        const viewPoint = this.viewport ? this.viewport.worldToView(rawPoint) : Point3d.create(); // BeButtonEvent is invalid when viewport is undefined\n        ev.init({\n            point, rawPoint, viewPoint, viewport: this.viewport, coordsFrom: CoordSource.User,\n            keyModifiers: this.qualifiers, button: BeButton.Data, isDown: state.isDown,\n            isDoubleClick: state.isDoubleClick, isDragging: state.isDragging, inputSource: state.inputSource,\n        });\n    }\n    fromPoint(vp, pt, source) {\n        this.viewport = vp;\n        this._viewPoint.x = pt.x;\n        this._viewPoint.y = pt.y;\n        this._viewPoint.z = vp.npcToView(NpcCenter).z;\n        vp.viewToWorld(this._viewPoint, this._rawPoint);\n        this.point = this._rawPoint;\n        this.inputSource = source;\n    }\n    fromButton(vp, pt, source, applyLocks) {\n        this.fromPoint(vp, pt, source);\n        // NOTE: Using the hit point on the element is preferable to ignoring a snap that is not \"hot\" completely\n        if (TentativeOrAccuSnap.getCurrentSnap(false)) {\n            if (applyLocks)\n                IModelApp.toolAdmin.adjustSnapPoint();\n            return;\n        }\n        IModelApp.toolAdmin.adjustPoint(this._point, vp, true, applyLocks);\n    }\n    isStartDrag(button) {\n        // First make sure we aren't already dragging any button\n        if (this.isAnyDragging())\n            return false;\n        const state = this.button[button];\n        if (!state.isDown)\n            return false;\n        if ((Date.now() - state.downTime) <= ToolSettings.startDragDelay.milliseconds)\n            return false;\n        const viewPt = this.viewport.worldToView(state.downRawPt);\n        const deltaX = Math.abs(this._viewPoint.x - viewPt.x);\n        const deltaY = Math.abs(this._viewPoint.y - viewPt.y);\n        return ((deltaX + deltaY) > this.viewport.pixelsFromInches(ToolSettings.startDragDistanceInches));\n    }\n}\n/** Controls the operation of [[Tool]]s, administering the current [[ViewTool]], [[PrimitiveTool]], and [[IdleTool]] and forwarding events to the appropriate tool.\n * @see [[IModelApp.toolAdmin]] to access the session's `ToolAdmin`.\n * @public\n * @extensions\n */\nclass ToolAdmin {\n    constructor() {\n        /** @internal */\n        this.currentInputState = new CurrentInputState();\n        /** @internal */\n        this.toolState = new ToolState();\n        /** Maintains the state of tool settings properties for the current session. */\n        this.toolSettingsState = new ToolSettingsState();\n        this._saveLocateCircle = false;\n        this._defaultToolId = \"Select\";\n        /** Apply operations such as transform, copy or delete to all members of an assembly. */\n        this.assemblyLock = false;\n        /** If Grid Lock is on, project data points to grid. */\n        this.gridLock = false;\n        /** If ACS Snap Lock is on, project snap points to the ACS plane. */\n        this.acsPlaneSnapLock = false;\n        /** If ACS Plane Lock is on, standard view rotations are relative to the ACS instead of global. */\n        this.acsContextLock = false;\n        /** The registered handler method that will update the UI with any property value changes.\n         *  @internal\n         */\n        this._toolSettingsChangeHandler = undefined;\n        /** The registered handler method that will inform the UI to reload tool setting with properties from active tool.\n       *  @internal\n       */\n        this._reloadToolSettingsHandler = undefined;\n        /** The registered handler method that will trigger UI Sync processing.\n         *  @internal\n         */\n        this._toolSyncUiEventDispatcher = undefined;\n        this._processingEvent = false;\n        /**\n         * Event raised whenever the active tool changes. This includes PrimitiveTool, ViewTool, and InputCollector.\n         * @param newTool The newly activated tool\n         */\n        this.activeToolChanged = new BeEvent();\n        /**\n         * Event raised by tools that support edit manipulators like the SelectTool.\n         * @param tool The current tool\n         */\n        this.manipulatorToolEvent = new BeEvent();\n    }\n    /** The name of the [[PrimitiveTool]] to use as the default tool. Defaults to \"Select\", referring to [[SelectionTool]].\n     * @see [[startDefaultTool]] to activate the default tool.\n     * @see [[defaultToolArgs]] to supply arguments when starting the tool.\n     */\n    get defaultToolId() {\n        return this._defaultToolId;\n    }\n    set defaultToolId(toolId) {\n        this._defaultToolId = toolId;\n    }\n    /** The arguments supplied to the default [[Tool]]'s [[Tool.run]] method from [[startDefaultTool]].\n     * @see [[defaultToolId]] to configure the default tool.\n     */\n    get defaultToolArgs() {\n        return this._defaultToolArgs;\n    }\n    set defaultToolArgs(args) {\n        this._defaultToolArgs = args;\n    }\n    /** A function that catches otherwise-uncaught exceptions occurring inside ToolAdmin.eventLoop.\n     * To customize the behavior of this function, modify [[ToolAdmin.exceptionOptions]].\n     * To replace it within your own handler, simply assign to it, e.g.:\n     * ```ts\n     * ToolAdmin.exceptionHandler = (exception: any): Promise<any> => {\n     *  ... your implementation here\n     * }\n     * ```\n     */\n    static async exceptionHandler(exception) {\n        const opts = ToolAdmin.exceptionOptions;\n        const msg = undefined !== exception.stack ? exception.stack : exception.toString();\n        if (opts.log)\n            Logger.logError(`${FrontendLoggerCategory.Package}.unhandledException`, msg);\n        if (opts.launchDebugger) // this does nothing if the debugger window is not already opened\n            debugger; // eslint-disable-line no-debugger\n        if (!opts.alertBox)\n            return;\n        let out = `<h2>${IModelApp.localization.getLocalizedString(\"iModelJs:Errors.ReloadPage\")}</h2>`;\n        if (opts.details) {\n            out += `<h3>${IModelApp.localization.getLocalizedString(\"iModelJs:Errors.Details\")}</h3><h4>`;\n            msg.split(\"\\n\").forEach((line) => out += `${line}<br>`);\n            out += \"</h4>\";\n        }\n        const div = document.createElement(\"div\");\n        div.innerHTML = out;\n        return IModelApp.notifications.openMessageBox(MessageBoxType.MediumAlert, div, MessageBoxIconType.Critical);\n    }\n    /** Returns the handler registered by the UI layer that allows it to display property changes made by the active Tool. */\n    get toolSettingsChangeHandler() { return this._toolSettingsChangeHandler; }\n    set toolSettingsChangeHandler(handler) {\n        this._toolSettingsChangeHandler = handler;\n    }\n    /** Returns the handler registered by the UI layer that allows it to display property changes made by the active Tool. */\n    get reloadToolSettingsHandler() { return this._reloadToolSettingsHandler; }\n    set reloadToolSettingsHandler(handler) {\n        this._reloadToolSettingsHandler = handler;\n    }\n    /** Returns the handler registered by the UI layer that will trigger UiSyncEvent processing that informs UI component to refresh their state. */\n    get toolSyncUiEventDispatcher() { return this._toolSyncUiEventDispatcher; }\n    set toolSyncUiEventDispatcher(handler) {\n        this._toolSyncUiEventDispatcher = handler;\n    }\n    /** @internal */\n    onInitialized() {\n        if (typeof document === \"undefined\")\n            return; // if document isn't defined, we're probably running in a test environment. At any rate, we can't have interactive tools.\n        this._idleTool = IModelApp.tools.create(\"Idle\");\n        [\"keydown\", \"keyup\"].forEach((type) => {\n            document.addEventListener(type, ToolAdmin._keyEventHandler, false);\n            ToolAdmin._removals.push(() => document.removeEventListener(type, ToolAdmin._keyEventHandler, false));\n        });\n        ToolAdmin._removals.push(() => window.onfocus = null);\n    }\n    /** @internal */\n    onShutDown() {\n        this.clearMotionPromises();\n        this._idleTool = undefined;\n        IconSprites.emptyAll(); // clear cache of icon sprites\n        ToolAdmin._removals.forEach((remove) => remove());\n        ToolAdmin._removals.length = 0;\n    }\n    /** Get the ScreenViewport where the cursor is currently, if any. */\n    get cursorView() { return this.currentInputState.viewport; }\n    /** Called from ViewManager.dropViewport to prevent tools from continuing to operate on the dropped viewport.\n     * @internal\n     */\n    forgetViewport(vp) {\n        // Ignore pending motion promises on fulfillment.\n        this.clearMotionPromises();\n        // make sure tools don't think the cursor is still in this viewport.\n        this.onMouseLeave(vp);\n        // Remove any events associated with this viewport.\n        ToolAdmin._toolEvents = ToolAdmin._toolEvents.filter((ev) => ev.vp !== vp);\n    }\n    getMousePosition(event) {\n        return event.vp.mousePosFromEvent(event.ev);\n    }\n    getMouseMovement(event) {\n        return event.vp.mouseMovementFromEvent(event.ev);\n    }\n    getMouseButton(button) {\n        switch (button) {\n            case 1 /* MouseButton.Middle */: return BeButton.Middle;\n            case 2 /* MouseButton.Right */: return BeButton.Reset;\n            default: return BeButton.Data;\n        }\n    }\n    async onMouseButton(event, isDown) {\n        const ev = event.ev;\n        const vp = event.vp;\n        const pos = this.getMousePosition(event);\n        const button = this.getMouseButton(ev.button);\n        this.currentInputState.setKeyQualifiers(ev);\n        return isDown ? this.onButtonDown(vp, pos, button, InputSource.Mouse) : this.onButtonUp(vp, pos, button, InputSource.Mouse);\n    }\n    async onWheel(event) {\n        const ev = event.ev;\n        const vp = event.vp;\n        if (this.filterViewport(vp))\n            return EventHandled.Yes;\n        const current = this.currentInputState;\n        current.setKeyQualifiers(ev);\n        if (ev.deltaY === 0)\n            return EventHandled.No;\n        let delta;\n        switch (ev.deltaMode) {\n            case ev.DOM_DELTA_LINE:\n                delta = -ev.deltaY * ToolSettings.wheelLineFactor; // 40\n                break;\n            case ev.DOM_DELTA_PAGE:\n                delta = -ev.deltaY * ToolSettings.wheelPageFactor; // 120;\n                break;\n            default: // DOM_DELTA_PIXEL:\n                delta = -ev.deltaY;\n                break;\n        }\n        const pt2d = this.getMousePosition(event);\n        vp.setAnimator();\n        current.fromButton(vp, pt2d, InputSource.Mouse, true);\n        const wheelEvent = new BeWheelEvent();\n        wheelEvent.wheelDelta = delta;\n        current.toEvent(wheelEvent, true);\n        const overlayHit = this.pickCanvasDecoration(wheelEvent);\n        if (undefined !== overlayHit && undefined !== overlayHit.onWheel && overlayHit.onWheel(wheelEvent))\n            return EventHandled.Yes;\n        const tool = this.activeTool;\n        if (undefined === tool || EventHandled.Yes !== await tool.onMouseWheel(wheelEvent) && vp !== this.markupView)\n            return this.idleTool.onMouseWheel(wheelEvent);\n        return EventHandled.Yes;\n    }\n    async sendTapEvent(touchEv) {\n        touchEv.viewport.setAnimator();\n        const overlayHit = this.pickCanvasDecoration(touchEv);\n        if (undefined !== overlayHit && undefined !== overlayHit.onMouseButton && overlayHit.onMouseButton(touchEv))\n            return EventHandled.Yes;\n        if (await IModelApp.accuSnap.onTouchTap(touchEv))\n            return EventHandled.Yes;\n        const tool = this.activeTool;\n        if (undefined !== tool && EventHandled.Yes === await tool.onTouchTap(touchEv))\n            return EventHandled.Yes;\n        return this.idleTool.onTouchTap(touchEv);\n    }\n    async doubleTapTimeout() {\n        const current = this.currentInputState;\n        if (undefined === current.touchTapTimer)\n            return;\n        const touchEv = current.lastTouchStart;\n        const numTouches = (undefined !== current.lastTouchStart ? current.lastTouchStart.touchCount : 0);\n        const numTaps = (undefined !== current.touchTapCount ? current.touchTapCount : 0);\n        current.touchTapTimer = current.touchTapCount = current.lastTouchStart = undefined;\n        if (undefined === touchEv || 0 > numTouches || 0 > numTaps)\n            return;\n        touchEv.tapCount = numTaps;\n        await this.sendTapEvent(touchEv);\n    }\n    async onTouch(event) {\n        const touchEvent = event.ev;\n        const vp = event.vp;\n        if (this.filterViewport(vp))\n            return;\n        const ev = new BeTouchEvent({ touchEvent });\n        const current = this.currentInputState;\n        const pos = BeTouchEvent.getTouchListCentroid(0 !== touchEvent.targetTouches.length ? touchEvent.targetTouches : touchEvent.changedTouches, vp);\n        switch (touchEvent.type) {\n            case \"touchstart\":\n                if (touchEvent.changedTouches.length === touchEvent.targetTouches.length)\n                    vp.setAnimator(); // Clear viewport animator on start of new touch input (first contact point added)...\n                current.setKeyQualifiers(touchEvent);\n                break;\n            case \"touchend\":\n                current.setKeyQualifiers(touchEvent);\n                break;\n        }\n        current.fromButton(vp, undefined !== pos ? pos : Point2d.createZero(), InputSource.Touch, true);\n        current.toEvent(ev, false);\n        const tool = this.activeTool;\n        switch (touchEvent.type) {\n            case \"touchstart\": {\n                current.lastTouchStart = ev;\n                IModelApp.accuSnap.onTouchStart(ev);\n                if (undefined !== tool)\n                    await tool.onTouchStart(ev);\n                return;\n            }\n            case \"touchend\": {\n                IModelApp.accuSnap.onTouchEnd(ev);\n                if (undefined !== tool) {\n                    await tool.onTouchEnd(ev);\n                    if (0 === ev.touchCount)\n                        await tool.onTouchComplete(ev);\n                }\n                if (undefined === current.lastTouchStart)\n                    return;\n                if (ev.touchEvent.timeStamp - current.lastTouchStart.touchEvent.timeStamp > (2.0 * ToolSettings.doubleTapTimeout.milliseconds))\n                    return; // Too much time has passed from touchstart to be considered a tap...\n                // eslint-disable-next-line @typescript-eslint/prefer-for-of\n                for (let i = 0; i < ev.touchEvent.changedTouches.length; i++) {\n                    const currTouch = ev.touchEvent.changedTouches[i];\n                    const startTouch = BeTouchEvent.findTouchById(current.lastTouchStart.touchEvent.targetTouches, currTouch.identifier);\n                    if (undefined !== startTouch) {\n                        const currPt = BeTouchEvent.getTouchPosition(currTouch, vp);\n                        const startPt = BeTouchEvent.getTouchPosition(startTouch, vp);\n                        if (currPt.distance(startPt) < vp.pixelsFromInches(ToolSettings.touchMoveDistanceInches))\n                            continue; // Hasn't moved appreciably....\n                    }\n                    current.lastTouchStart = undefined; // Not a tap...\n                    return;\n                }\n                if (0 !== ev.touchCount || undefined === current.lastTouchStart)\n                    return;\n                // All fingers off, defer processing tap until we've waited long enough to detect double tap...\n                if (undefined === current.touchTapTimer) {\n                    current.touchTapTimer = Date.now();\n                    current.touchTapCount = 1;\n                    // eslint-disable-next-line @typescript-eslint/unbound-method\n                    await ToolSettings.doubleTapTimeout.executeAfter(this.doubleTapTimeout, this);\n                }\n                else if (undefined !== current.touchTapCount) {\n                    current.touchTapCount++;\n                }\n                return;\n            }\n            case \"touchcancel\": {\n                current.lastTouchStart = undefined;\n                IModelApp.accuSnap.onTouchCancel(ev);\n                if (undefined !== tool)\n                    await tool.onTouchCancel(ev);\n                return;\n            }\n            case \"touchmove\": {\n                if (!IModelApp.accuSnap.onTouchMove(ev) && undefined !== tool)\n                    await tool.onTouchMove(ev);\n                if (undefined === current.lastTouchStart)\n                    return;\n                if (ev.touchEvent.timeStamp - current.lastTouchStart.touchEvent.timeStamp < ToolSettings.touchMoveDelay.milliseconds)\n                    return;\n                // eslint-disable-next-line @typescript-eslint/prefer-for-of\n                for (let i = 0; i < ev.touchEvent.changedTouches.length; ++i) {\n                    const currTouch = ev.touchEvent.changedTouches[i];\n                    const startTouch = BeTouchEvent.findTouchById(current.lastTouchStart.touchEvent.targetTouches, currTouch.identifier);\n                    if (undefined === startTouch)\n                        continue;\n                    const currPt = BeTouchEvent.getTouchPosition(currTouch, vp);\n                    const startPt = BeTouchEvent.getTouchPosition(startTouch, vp);\n                    if (currPt.distance(startPt) < vp.pixelsFromInches(ToolSettings.touchMoveDistanceInches))\n                        continue; // Hasn't moved appreciably....\n                    const touchStart = current.lastTouchStart;\n                    current.lastTouchStart = undefined;\n                    if (IModelApp.accuSnap.onTouchMoveStart(ev, touchStart))\n                        return;\n                    if (undefined === tool || EventHandled.Yes !== await tool.onTouchMoveStart(ev, touchStart))\n                        await this.idleTool.onTouchMoveStart(ev, touchStart);\n                    return;\n                }\n                return;\n            }\n        }\n    }\n    static tryReplace(ev, vp) {\n        if (ToolAdmin._toolEvents.length < 1)\n            return false;\n        const last = ToolAdmin._toolEvents[ToolAdmin._toolEvents.length - 1];\n        const lastType = last.ev.type;\n        if (lastType !== ev.type || (lastType !== \"mousemove\" && lastType !== \"touchmove\"))\n            return false; // only mousemove and touchmove can replace previous\n        last.ev = ev; // sequential moves are not important. Replace the previous one with this one.\n        last.vp = vp;\n        return true;\n    }\n    /** @internal */\n    static getNextEvent() {\n        if (ToolAdmin._toolEvents.length > 1) // if there is more than one event, we're going to need another animation frame to process it.\n            IModelApp.requestNextAnimation();\n        return ToolAdmin._toolEvents.shift(); // pull first event from the queue\n    }\n    /** Called from HTML event listeners. Events are processed in the order they're received in ToolAdmin.eventLoop\n     * @internal\n     */\n    static addEvent(ev, vp) {\n        if (!ToolAdmin.tryReplace(ev, vp)) // see if this event replaces the last event in the queue\n            this._toolEvents.push({ ev, vp }); // otherwise put it at the end of the queue.\n        IModelApp.requestNextAnimation(); // wake up event loop, if\n    }\n    /** Process the next event in the event queue, if any. */\n    async processNextEvent() {\n        const event = ToolAdmin.getNextEvent(); // pull first event from the queue\n        if (undefined === event)\n            return; // nothing in queue\n        switch (event.ev.type) {\n            case \"mousedown\": return this.onMouseButton(event, true);\n            case \"mouseup\": return this.onMouseButton(event, false);\n            case \"mousemove\": return this.onMouseMove(event);\n            case \"mouseover\": return this.onMouseEnter(event);\n            case \"mouseout\": return this.onMouseLeave(event.vp);\n            case \"wheel\": return this.onWheel(event);\n            case \"keydown\": return this.onKeyTransition(event, true);\n            case \"keyup\": return this.onKeyTransition(event, false);\n            case \"touchstart\": return this.onTouch(event);\n            case \"touchend\": return this.onTouch(event);\n            case \"touchcancel\": return this.onTouch(event);\n            case \"touchmove\": return this.onTouch(event);\n        }\n    }\n    /**\n     * Process a single event, plus timer events. Don't start work on new events if the previous one has not finished.\n     * @internal\n     */\n    async processEvent() {\n        if (this._processingEvent)\n            return; // we're still working on the previous event.\n        try {\n            this._processingEvent = true; // we can't allow any further event processing until the current event completes.\n            await this.processNextEvent();\n        }\n        catch (exception) {\n            await ToolAdmin.exceptionHandler(exception); // we don't attempt to exit here\n        }\n        finally {\n            this._processingEvent = false; // this event is now finished. Allow processing next time through.\n        }\n    }\n    /** The idleTool handles events that are not otherwise processed. */\n    get idleTool() {\n        assert(undefined !== this._idleTool);\n        return this._idleTool;\n    }\n    set idleTool(idleTool) {\n        this._idleTool = idleTool;\n    }\n    /** Return true to filter (ignore) events to the given viewport */\n    filterViewport(vp) {\n        if (undefined === vp || vp.isDisposed)\n            return true;\n        const tool = this.activeTool;\n        return (undefined !== tool ? !tool.isCompatibleViewport(vp, false) : false);\n    }\n    /** @internal */\n    async onInstallTool(tool) {\n        this.currentInputState.onInstallTool();\n        return tool.onInstall();\n    }\n    /** @internal */\n    async onPostInstallTool(tool) { return tool.onPostInstall(); }\n    get viewTool() { return this._viewTool; }\n    get primitiveTool() { return this._primitiveTool; }\n    /** The currently active InteractiveTool. May be ViewTool, InputCollector, PrimitiveTool, undefined - in that priority order. */\n    get activeTool() {\n        return this._viewTool ? this._viewTool : (this._inputCollector ? this._inputCollector : this._primitiveTool); // NOTE: Viewing tools suspend input collectors as well as primitives\n    }\n    /** The current tool. May be ViewTool, InputCollector, PrimitiveTool, or IdleTool - in that priority order. */\n    get currentTool() { return this.activeTool ? this.activeTool : this.idleTool; }\n    /** Ask the current tool to provide tooltip contents for the supplied HitDetail. */\n    async getToolTip(hit) { return this.currentTool.getToolTip(hit); }\n    async onMouseEnter(event) {\n        const vp = event.vp;\n        const current = this.currentInputState;\n        current.viewport = vp;\n        // Detect if drag was active and button was released outside the view...\n        const tool = this.activeTool;\n        if (undefined === tool)\n            return;\n        const buttonMask = event.ev.buttons;\n        let cancelDrag = false;\n        current.button.forEach((button, buttonNum) => {\n            if (button.isDragging && !(buttonMask & (1 << buttonNum))) {\n                button.isDragging = button.isDown = false;\n                cancelDrag = true;\n            }\n        });\n        if (cancelDrag)\n            await tool.onReinitialize();\n    }\n    /** @internal */\n    onMouseLeave(vp) {\n        if (this._mouseMoveOverTimeout !== undefined)\n            clearTimeout(this._mouseMoveOverTimeout);\n        IModelApp.accuSnap.clear();\n        this.currentInputState.clearViewport(vp);\n        this.setCanvasDecoration(vp);\n        vp.invalidateDecorations(); // stop drawing locate circle...\n    }\n    /** @internal */\n    updateDynamics(ev, useLastData, adjustPoint) {\n        if (undefined === this.activeTool)\n            return;\n        if (undefined === ev) {\n            ev = new BeButtonEvent();\n            if (useLastData)\n                this.fillEventFromLastDataButton(ev);\n            else\n                this.fillEventFromCursorLocation(ev);\n            // NOTE: Do not call adjustPoint when snapped, refer to CurrentInputState.fromButton\n            if (adjustPoint && undefined !== ev.viewport && undefined === TentativeOrAccuSnap.getCurrentSnap(false))\n                this.adjustPoint(ev.point, ev.viewport);\n        }\n        if (undefined === ev.viewport)\n            return;\n        // Support tools requesting async information in onMouseMotion for use in decorate or onDynamicFrame...\n        const toolPromise = this._toolMotionPromise = this.activeTool.onMouseMotion(ev);\n        const tool = this.activeTool;\n        const vp = ev.viewport;\n        const motion = ev;\n        toolPromise.then(() => {\n            if (undefined === this._toolMotionPromise)\n                return; // Only early return if canceled, result from a previous motion is preferable to showing nothing...\n            // Update decorations when dynamics are inactive...\n            if (!IModelApp.viewManager.inDynamicsMode) {\n                vp.invalidateDecorations();\n                return;\n            }\n            // Update dynamics and decorations only after motion...\n            const context = new DynamicsContext(vp);\n            tool.onDynamicFrame(motion, context);\n            context.changeDynamics();\n        }).catch((_) => { });\n    }\n    async sendEndDragEvent(ev) {\n        let tool = this.activeTool;\n        if (undefined !== tool) {\n            if (!tool.isValidLocation(ev, true))\n                tool = undefined;\n            else if (tool.receivedDownEvent)\n                tool.receivedDownEvent = false;\n            else\n                tool = undefined;\n        }\n        // Don't send tool end drag event if it didn't get the start drag event\n        if (undefined === tool || EventHandled.Yes !== await tool.onMouseEndDrag(ev))\n            return this.idleTool.onMouseEndDrag(ev);\n    }\n    setCanvasDecoration(vp, dec, ev) {\n        if (dec === this._canvasDecoration)\n            return;\n        if (this._canvasDecoration && this._canvasDecoration.onMouseLeave)\n            this._canvasDecoration.onMouseLeave();\n        this._canvasDecoration = dec;\n        if (ev && dec && dec.onMouseEnter)\n            dec.onMouseEnter(ev);\n        vp.canvas.style.cursor = dec ? (dec.decorationCursor ? dec.decorationCursor : \"pointer\") : IModelApp.viewManager.cursor;\n        vp.invalidateDecorations();\n    }\n    pickCanvasDecoration(ev) {\n        const vp = ev.viewport;\n        const decoration = (undefined === this.viewTool) ? vp.pickCanvasDecoration(ev.viewPoint) : undefined;\n        this.setCanvasDecoration(vp, decoration, ev);\n        return decoration;\n    }\n    clearMotionPromises() {\n        this._snapMotionPromise = this._toolMotionPromise = undefined;\n    }\n    async forceOnMotionSnap(ev) {\n        // Make sure that we fire the motion snap event correctly\n        this._lastHandledMotionTime = undefined;\n        return this.onMotionSnap(ev);\n    }\n    async onMotionSnap(ev) {\n        try {\n            await this.onMotionSnapOrSkip(ev);\n            return true;\n        }\n        catch (error) {\n            if (error instanceof AbandonedError)\n                return false; // expected, not a problem. Just ignore this motion and return.\n            throw error; // unknown error\n        }\n    }\n    // Call accuSnap.onMotion\n    async onMotionSnapOrSkip(ev) {\n        if (this.shouldSkipOnMotionSnap())\n            return;\n        await IModelApp.accuSnap.onMotion(ev);\n        this._lastHandledMotionTime = BeTimePoint.now();\n    }\n    // Should the current onMotionSnap event be skipped to avoid unnecessary ReadPixel calls?\n    shouldSkipOnMotionSnap() {\n        if (this._lastHandledMotionTime === undefined)\n            return false;\n        const now = BeTimePoint.now();\n        const msSinceLastCall = now.milliseconds - this._lastHandledMotionTime.milliseconds;\n        const delay = 1000 / ToolSettings.maxOnMotionSnapCallPerSecond;\n        return msSinceLastCall < delay;\n    }\n    async onStartDrag(ev, tool) {\n        if (undefined !== tool && EventHandled.Yes === await tool.onMouseStartDrag(ev))\n            return EventHandled.Yes;\n        // Pass start drag event to idle tool if active tool doesn't explicitly handle it\n        return this.idleTool.onMouseStartDrag(ev);\n    }\n    async onMotion(vp, pt2d, inputSource, forceStartDrag = false, movement) {\n        const current = this.currentInputState;\n        current.onMotion(pt2d);\n        if (this.filterViewport(vp)) {\n            this.setIncompatibleViewportCursor(false);\n            return;\n        }\n        // Detect when the motion stops by setting a timeout\n        if (this._mouseMoveOverTimeout !== undefined)\n            clearTimeout(this._mouseMoveOverTimeout); // If a previous timeout was up, it is cancelled: the movement is not over yet\n        const ev = new BeButtonEvent();\n        current.fromPoint(vp, pt2d, inputSource);\n        current.toEvent(ev, false);\n        const overlayHit = this.pickCanvasDecoration(ev);\n        if (undefined !== overlayHit) {\n            if (overlayHit.onMouseMove)\n                overlayHit.onMouseMove(ev);\n            if (undefined === overlayHit.propagateMouseMove || !overlayHit.propagateMouseMove(ev))\n                return; // we're inside a pickable decoration that doesn't want event sent to tool\n        }\n        this._mouseMoveOverTimeout = setTimeout(async () => {\n            await this.onMotionEnd(vp, pt2d, inputSource);\n        }, 100);\n        const processMotion = async () => {\n            // Update event to account for AccuSnap adjustments...\n            current.fromButton(vp, pt2d, inputSource, true);\n            current.toEvent(ev, true);\n            ev.movement = movement;\n            IModelApp.accuDraw.onMotion(ev);\n            let tool = this.activeTool;\n            const isValidLocation = (undefined !== tool ? tool.isValidLocation(ev, false) : true);\n            this.setIncompatibleViewportCursor(isValidLocation);\n            if (forceStartDrag || current.isStartDrag(ev.button)) {\n                current.onStartDrag(ev.button);\n                current.changeButtonToDownPoint(ev);\n                ev.isDragging = true;\n                if (undefined !== tool) {\n                    if (!isValidLocation)\n                        tool = undefined;\n                    else if (forceStartDrag)\n                        tool.receivedDownEvent = true;\n                    else if (!tool.receivedDownEvent)\n                        tool = undefined;\n                }\n                await this.onStartDrag(ev, tool);\n                return;\n            }\n            this.updateDynamics(ev);\n        };\n        const snapPromise = this._snapMotionPromise = this.onMotionSnap(ev);\n        /** When forceStartDrag is true, make sure we don't return a fulfilled promise until we've processed the motion so callers can await it.\n         * The .then below happens AFTER this method returns its (fulfilled) promise so we can't use that.\n         */\n        if (forceStartDrag) {\n            await snapPromise;\n            return processMotion();\n        }\n        if (this.isLocateCircleOn)\n            vp.invalidateDecorations();\n        snapPromise.then(async (snapOk) => {\n            if (!snapOk || snapPromise !== this._snapMotionPromise)\n                return;\n            return processMotion();\n        }).catch((_) => { });\n    }\n    // Called when we detect that the motion stopped\n    async onMotionEnd(vp, pos, inputSource) {\n        const current = this.currentInputState;\n        const ev = new BeButtonEvent();\n        current.fromPoint(vp, pos, inputSource);\n        current.toEvent(ev, false);\n        await this.forceOnMotionSnap(ev);\n    }\n    async onMouseMove(event) {\n        const vp = event.vp;\n        const pos = this.getMousePosition(event);\n        const mov = this.getMouseMovement(event);\n        // Sometimes the mouse goes down in a view, but we lose focus while its down so we never receive the up event.\n        // That makes it look like the motion is a drag. Fix that by clearing the \"isDown\" based on the buttons member of the MouseEvent.\n        const buttonMask = event.ev.buttons;\n        if (!(buttonMask & 1))\n            this.currentInputState.button[BeButton.Data].isDown = false;\n        return this.onMotion(vp, pos, InputSource.Mouse, false, mov);\n    }\n    adjustPointToACS(pointActive, vp, perpendicular) {\n        // The \"I don't want ACS lock\" flag can be set by tools to override the default behavior\n        if (0 !== (this.toolState.coordLockOvr & CoordinateLockOverrides.ACS))\n            return;\n        let viewZRoot;\n        // Lock to the construction plane\n        if (vp.view.is3d() && vp.view.isCameraOn)\n            viewZRoot = vp.view.camera.eye.vectorTo(pointActive);\n        else\n            viewZRoot = vp.rotation.getRow(2);\n        const auxOriginRoot = vp.getAuxCoordOrigin();\n        const auxRMatrixRoot = vp.getAuxCoordRotation();\n        let auxNormalRoot = auxRMatrixRoot.getRow(2);\n        // If ACS xy plane is perpendicular to view and not snapping, project to closest xz or yz plane instead\n        if (auxNormalRoot.isPerpendicularTo(viewZRoot) && !TentativeOrAccuSnap.isHot) {\n            const auxXRoot = auxRMatrixRoot.getRow(0);\n            const auxYRoot = auxRMatrixRoot.getRow(1);\n            auxNormalRoot = (Math.abs(auxXRoot.dotProduct(viewZRoot)) > Math.abs(auxYRoot.dotProduct(viewZRoot))) ? auxXRoot : auxYRoot;\n        }\n        linePlaneIntersect(pointActive, pointActive, viewZRoot, auxOriginRoot, auxNormalRoot, perpendicular);\n    }\n    adjustPointToGrid(pointActive, vp) {\n        // The \"I don't want grid lock\" flag can be set by tools to override the default behavior\n        if (!this.gridLock || 0 !== (this.toolState.coordLockOvr & CoordinateLockOverrides.Grid))\n            return;\n        vp.pointToGrid(pointActive);\n    }\n    adjustPoint(pointActive, vp, projectToACS = true, applyLocks = true) {\n        if (Math.abs(pointActive.z) < 1.0e-7)\n            pointActive.z = 0.0; // remove Z fuzz introduced by active depth when near 0\n        let handled = false;\n        if (applyLocks && !(IModelApp.tentativePoint.isActive || IModelApp.accuSnap.isHot))\n            handled = IModelApp.accuDraw.adjustPoint(pointActive, vp, false);\n        // NOTE: We don't need to support axis lock, it is worthless if you have AccuDraw\n        if (!handled && vp.isPointAdjustmentRequired) {\n            if (applyLocks)\n                this.adjustPointToGrid(pointActive, vp);\n            if (projectToACS)\n                this.adjustPointToACS(pointActive, vp, false);\n        }\n        else if (applyLocks) {\n            const savePoint = pointActive.clone();\n            this.adjustPointToGrid(pointActive, vp);\n            // if grid lock changes point, resend point to accudraw\n            if (handled && !pointActive.isExactEqual(savePoint))\n                IModelApp.accuDraw.adjustPoint(pointActive, vp, false);\n        }\n        if (Math.abs(pointActive.z) < 1.0e-7)\n            pointActive.z = 0.0;\n    }\n    adjustSnapPoint(perpendicular = true) {\n        const snap = TentativeOrAccuSnap.getCurrentSnap(false);\n        if (!snap)\n            return;\n        const vp = snap.viewport;\n        const isHot = snap.isHot;\n        const point = snap.getPoint().clone();\n        const savePt = point.clone();\n        if (!isHot) // Want point adjusted to grid for a hit that isn't hot\n            this.adjustPointToGrid(point, vp);\n        if (!IModelApp.accuDraw.adjustPoint(point, vp, isHot)) {\n            if (vp.isSnapAdjustmentRequired)\n                this.adjustPointToACS(point, vp, perpendicular || IModelApp.accuDraw.isActive);\n        }\n        if (!point.isExactEqual(savePt))\n            snap.adjustedPoint.setFrom(point);\n    }\n    /** @internal */\n    async sendButtonEvent(ev) {\n        const overlayHit = this.pickCanvasDecoration(ev);\n        if (undefined !== overlayHit && undefined !== overlayHit.onMouseButton && overlayHit.onMouseButton(ev))\n            return;\n        if (IModelApp.accuSnap.onPreButtonEvent(ev))\n            return;\n        const activeTool = this.activeTool;\n        let tool = activeTool;\n        if (undefined !== tool) {\n            if (!tool.isValidLocation(ev, true))\n                tool = undefined;\n            else if (ev.isDown)\n                tool.receivedDownEvent = true;\n            else if (tool.receivedDownEvent)\n                tool.receivedDownEvent = false;\n            else\n                tool = undefined;\n        }\n        if (IModelApp.accuDraw.onPreButtonEvent(ev))\n            return;\n        let updateDynamics = false;\n        switch (ev.button) {\n            case BeButton.Data: {\n                if (undefined === tool) {\n                    if (undefined !== activeTool)\n                        break;\n                    tool = this.idleTool; // Pass data button event to idle tool when no active tool present\n                }\n                if (ev.isDown) {\n                    await tool.onDataButtonDown(ev);\n                }\n                else {\n                    await tool.onDataButtonUp(ev);\n                    break;\n                }\n                // Lock tool to target model of this view on first data button\n                if (tool instanceof PrimitiveTool)\n                    tool.autoLockTarget();\n                updateDynamics = true; // AccuDraw.onPostButtonEvent needs to process the active tool's pending hints from onDataButtonDown before calling updateDynamics...\n                break;\n            }\n            case BeButton.Reset: {\n                if (undefined === tool) {\n                    if (undefined !== activeTool)\n                        break;\n                    tool = this.idleTool; // Pass reset button event to idle tool when no active tool present\n                }\n                if (ev.isDown)\n                    await tool.onResetButtonDown(ev);\n                else\n                    await tool.onResetButtonUp(ev);\n                break;\n            }\n            case BeButton.Middle: {\n                // Pass middle button event to idle tool when active tool doesn't explicitly handle it\n                if (ev.isDown) {\n                    if (undefined === tool || EventHandled.Yes !== await tool.onMiddleButtonDown(ev))\n                        await this.idleTool.onMiddleButtonDown(ev);\n                }\n                else {\n                    if (undefined === tool || EventHandled.Yes !== await tool.onMiddleButtonUp(ev))\n                        await this.idleTool.onMiddleButtonUp(ev);\n                }\n                break;\n            }\n        }\n        IModelApp.tentativePoint.onButtonEvent(ev);\n        IModelApp.accuDraw.onPostButtonEvent(ev);\n        if (!updateDynamics)\n            return;\n        // Update tool dynamics. Use last data button location which was potentially adjusted by onDataButtonDown and not current event\n        this.updateDynamics(undefined, true, true);\n    }\n    async onButtonDown(vp, pt2d, button, inputSource) {\n        const filtered = this.filterViewport(vp);\n        if (undefined === this._viewTool && button === BeButton.Data)\n            await IModelApp.viewManager.setSelectedView(vp);\n        if (filtered)\n            return;\n        vp.setAnimator();\n        const ev = new BeButtonEvent();\n        const current = this.currentInputState;\n        current.fromButton(vp, pt2d, inputSource, true);\n        current.onButtonDown(button);\n        current.toEvent(ev, true);\n        current.updateDownPoint(ev);\n        return this.sendButtonEvent(ev);\n    }\n    async onButtonUp(vp, pt2d, button, inputSource) {\n        if (this.filterViewport(vp))\n            return;\n        const ev = new BeButtonEvent();\n        const current = this.currentInputState;\n        const wasDragging = current.isDragging(button);\n        current.fromButton(vp, pt2d, inputSource, true);\n        current.onButtonUp(button);\n        current.toEvent(ev, true);\n        if (wasDragging)\n            return this.sendEndDragEvent(ev);\n        current.changeButtonToDownPoint(ev);\n        return this.sendButtonEvent(ev);\n    }\n    /** Called when any *modifier* (Shift, Alt, or Control) key is pressed or released. */\n    async onModifierKeyTransition(wentDown, modifier, event) {\n        const activeTool = this.activeTool;\n        const changed = activeTool ? await activeTool.onModifierKeyTransition(wentDown, modifier, event) : EventHandled.No;\n        if (changed === EventHandled.Yes) {\n            IModelApp.viewManager.invalidateDecorationsAllViews();\n            this.updateDynamics(undefined, undefined, true); // Don't wait for motion to update dynamics...\n        }\n    }\n    static getModifierKey(event) {\n        switch (event.key) {\n            case \"Alt\": return BeModifierKeys.Alt;\n            case \"Shift\": return BeModifierKeys.Shift;\n            case \"Control\": return BeModifierKeys.Control;\n        }\n        return BeModifierKeys.None;\n    }\n    /** Process key down events while the Ctrl key is pressed */\n    async onCtrlKeyPressed(keyEvent) {\n        let handled = false;\n        let result = false;\n        switch (keyEvent.key) {\n            case \"z\":\n            case \"Z\":\n                result = await this.doUndoOperation();\n                handled = true;\n                break;\n            case \"y\":\n            case \"Y\":\n                result = await this.doRedoOperation();\n                handled = true;\n                break;\n            case \"F2\":\n                result = IModelApp.uiAdmin.showKeyinPalette();\n                handled = true;\n                break;\n        }\n        return { handled, result };\n    }\n    /** Process shortcut key events */\n    async processShortcutKey(_keyEvent, _wentDown) {\n        return false;\n    }\n    /** Event for every key down and up transition. */\n    async onKeyTransition(event, wentDown) {\n        const keyEvent = event.ev;\n        this.currentInputState.setKeyQualifiers(keyEvent);\n        const modifierKey = ToolAdmin.getModifierKey(keyEvent);\n        if (BeModifierKeys.None !== modifierKey)\n            return this.onModifierKeyTransition(wentDown, modifierKey, keyEvent);\n        if (wentDown && keyEvent.ctrlKey) {\n            const { handled, result } = await this.onCtrlKeyPressed(keyEvent);\n            if (handled)\n                return result;\n        }\n        const activeTool = this.activeTool;\n        if (activeTool) {\n            if (EventHandled.Yes === await activeTool.onKeyTransition(wentDown, keyEvent))\n                return EventHandled.Yes;\n        }\n        if (await this.processShortcutKey(keyEvent, wentDown))\n            return EventHandled.Yes;\n        return EventHandled.No;\n    }\n    /** Called to undo previous data button for primitive tools or undo last write operation. */\n    async doUndoOperation() {\n        const activeTool = this.activeTool;\n        if (activeTool instanceof PrimitiveTool) {\n            // ### TODO Add method so UI can be showing string to inform user that undo of last data point is available...\n            if (await activeTool.undoPreviousStep())\n                return true;\n        }\n        const imodel = IModelApp.viewManager.selectedView?.view.iModel;\n        if (undefined === imodel || imodel.isReadonly || !imodel.isBriefcaseConnection())\n            return false;\n        if (IModelStatus.Success !== await imodel.txns.reverseSingleTxn())\n            return false;\n        // ### TODO Restart of primitive tool should be handled by Txn event listener...needs to happen even if not the active tool...\n        if (undefined !== this._primitiveTool)\n            await this._primitiveTool.onRestartTool();\n        return true;\n    }\n    /** Called to redo previous data button for primitive tools or undo last write operation. */\n    async doRedoOperation() {\n        const activeTool = this.activeTool;\n        if (activeTool instanceof PrimitiveTool) {\n            // ### TODO Add method so UI can be showing string to inform user that undo of last data point is available...\n            if (await activeTool.redoPreviousStep())\n                return true;\n        }\n        const imodel = IModelApp.viewManager.selectedView?.view.iModel;\n        if (undefined === imodel || imodel.isReadonly || !imodel.isBriefcaseConnection())\n            return false;\n        if (IModelStatus.Success !== await imodel.txns.reinstateTxn())\n            return false;\n        // ### TODO Restart of primitive tool should be handled by Txn event listener...needs to happen even if not the active tool...\n        if (undefined !== this._primitiveTool)\n            await this._primitiveTool.onRestartTool();\n        return true;\n    }\n    onActiveToolChanged(tool, start) {\n        this.clearMotionPromises();\n        this.activeToolChanged.raiseEvent(tool, start);\n    }\n    async onUnsuspendTool() {\n        const tool = this.activeTool;\n        if (tool === undefined)\n            return;\n        await tool.onUnsuspend();\n        this.onActiveToolChanged(tool, StartOrResume.Resume);\n    }\n    /** @internal */\n    async setInputCollector(newTool) {\n        if (undefined !== this._inputCollector) {\n            await this._inputCollector.onCleanup();\n            this._inputCollector = undefined;\n        }\n        this._inputCollector = newTool;\n    }\n    /** @internal */\n    async exitInputCollector() {\n        if (undefined === this._inputCollector)\n            return;\n        let unsuspend = false;\n        if (this._suspendedByInputCollector) {\n            this._suspendedByInputCollector.stop();\n            this._suspendedByInputCollector = undefined;\n            unsuspend = true;\n        }\n        IModelApp.viewManager.invalidateDecorationsAllViews();\n        await this.setInputCollector(undefined);\n        if (unsuspend)\n            await this.onUnsuspendTool();\n        IModelApp.accuDraw.onInputCollectorExit();\n        this.updateDynamics(undefined, undefined, true);\n    }\n    /** @internal */\n    async startInputCollector(newTool) {\n        IModelApp.notifications.outputPrompt(\"\");\n        IModelApp.accuDraw.onInputCollectorInstall();\n        if (undefined !== this._inputCollector) {\n            await this.setInputCollector(undefined);\n        }\n        else {\n            const tool = this.activeTool;\n            if (tool)\n                await tool.onSuspend();\n            this._suspendedByInputCollector = new SuspendedToolState();\n        }\n        IModelApp.viewManager.endDynamicsMode();\n        IModelApp.viewManager.invalidateDecorationsAllViews();\n        await this.setInputCollector(newTool);\n        // it is important to raise event after setInputCollector is called\n        this.onActiveToolChanged(newTool, StartOrResume.Start);\n    }\n    /** @internal */\n    async setViewTool(newTool) {\n        if (undefined !== this._viewTool) {\n            await this._viewTool.onCleanup();\n            this._viewTool = undefined;\n        }\n        this._viewTool = newTool;\n    }\n    /** @internal */\n    async exitViewTool() {\n        if (undefined === this._viewTool)\n            return;\n        let unsuspend = false;\n        if (undefined !== this._suspendedByViewTool) {\n            this._suspendedByViewTool.stop(); // Restore state of suspended tool\n            this._suspendedByViewTool = undefined;\n            unsuspend = true;\n        }\n        IModelApp.viewManager.invalidateDecorationsAllViews();\n        await this.setViewTool(undefined);\n        if (unsuspend)\n            await this.onUnsuspendTool();\n        IModelApp.accuDraw.onViewToolExit();\n        this.updateDynamics(undefined, undefined, true);\n    }\n    /** @internal */\n    async startViewTool(newTool) {\n        IModelApp.notifications.outputPrompt(\"\");\n        IModelApp.accuDraw.onViewToolInstall();\n        if (undefined !== this._viewTool) {\n            await this.setViewTool(undefined);\n        }\n        else {\n            const tool = this.activeTool;\n            if (tool)\n                await tool.onSuspend();\n            this._suspendedByViewTool = new SuspendedToolState();\n        }\n        IModelApp.viewManager.endDynamicsMode();\n        IModelApp.viewManager.invalidateDecorationsAllViews();\n        this.toolState.coordLockOvr = CoordinateLockOverrides.All;\n        this.toolState.locateCircleOn = false;\n        IModelApp.accuSnap.onStartTool();\n        this.setCursor(IModelApp.viewManager.crossHairCursor);\n        await this.setViewTool(newTool);\n        // it is important to raise event after setViewTool is called\n        this.onActiveToolChanged(newTool, StartOrResume.Start);\n    }\n    /** @internal */\n    async setPrimitiveTool(newTool) {\n        if (undefined !== this._primitiveTool) {\n            await this._primitiveTool.onCleanup();\n            this._primitiveTool = undefined;\n        }\n        this._primitiveTool = newTool;\n    }\n    /** @internal */\n    async startPrimitiveTool(newTool) {\n        IModelApp.notifications.outputPrompt(\"\");\n        await this.exitViewTool();\n        if (undefined !== this._primitiveTool)\n            await this.setPrimitiveTool(undefined);\n        // clear the primitive tool first so following call does not trigger the refreshing of the ToolSetting for the previous primitive tool\n        await this.exitInputCollector();\n        IModelApp.viewManager.endDynamicsMode();\n        this.setIncompatibleViewportCursor(true); // Don't restore this\n        IModelApp.viewManager.invalidateDecorationsAllViews();\n        this.toolState.coordLockOvr = CoordinateLockOverrides.None;\n        this.toolState.locateCircleOn = false;\n        IModelApp.accuDraw.onPrimitiveToolInstall();\n        IModelApp.accuSnap.onStartTool();\n        if (undefined !== newTool) {\n            this.setCursor(IModelApp.viewManager.crossHairCursor);\n            await this.setPrimitiveTool(newTool);\n        }\n        // it is important to raise event after setPrimitiveTool is called\n        this.onActiveToolChanged(undefined !== newTool ? newTool : this.idleTool, StartOrResume.Start);\n    }\n    /** Method used by interactive tools to send updated values to UI components, typically showing tool settings.\n     * @beta\n     */\n    syncToolSettingsProperties(toolId, syncProperties) {\n        if (this.toolSettingsChangeHandler)\n            this.toolSettingsChangeHandler(toolId, syncProperties);\n    }\n    /** Method used by interactive tools to send request to reload UI from properties returned via method supplyToolSettingsProperties.\n     * @beta\n     */\n    reloadToolSettingsProperties() {\n        if (this.reloadToolSettingsHandler)\n            this.reloadToolSettingsHandler();\n    }\n    /** Method used to \"bump\" the value of a tool setting for the current tool.\n     * To \"bump\" a setting means to toggle a boolean value or cycle through enum values.\n     * If no `settingIndex` param is specified, the first setting is bumped.\n     * Returns true if the setting was successfully bumped.\n     */\n    async bumpToolSetting(settingIndex) {\n        return this.currentTool.bumpToolSetting(settingIndex);\n    }\n    /** Method used by interactive tools to inform one or more UI components to refresh. This is typically used to update labels or icons associated with a specific tool.\n     * This method should be used when the caller wants the UI layer to process the sync event immediately. Use dispatchUiSyncEvent when the event may be triggered while other\n     * more important user interaction processing is required.\n     * @param specificSyncEventId Optional sync event id. If not specified then \"tool-admin-refresh-ui\" is used.\n     * @param toolId Optional, will be used if specificSyncEventId is not specified. If used, the resulting sync event Id will be created using `tool-admin-refresh-ui-${toolId}`.toLowerCase()\n     */\n    dispatchImmediateUiSyncEvent(specificSyncEventId, toolId) {\n        const defaultRefreshEventId = \"tool-admin-refresh-ui\";\n        if (this.toolSyncUiEventDispatcher) {\n            if (specificSyncEventId)\n                this.toolSyncUiEventDispatcher(specificSyncEventId.toLowerCase(), true);\n            else if (toolId)\n                this.toolSyncUiEventDispatcher(`${defaultRefreshEventId}-${toolId}`.toLowerCase(), true);\n            else\n                this.toolSyncUiEventDispatcher(defaultRefreshEventId, true);\n        }\n    }\n    /** Method used by interactive tools to inform one or more UI components to refresh. This is typically used to update labels or icons associated with a specific tool.\n     * This method should be used when the caller wants the UI layer to process the sync event on a timer, waiting a few 100 ms, allowing other events that may require a UI refresh\n     * to be processed together.\n     * @param specificSyncEventId Optional sync event id. If not specified then \"tool-admin-refresh-ui\" is used.\n     * @param toolId Optional, will be used if specificSyncEventId is not specified. If used, the resulting sync event Id will be created using `tool-admin-refresh-ui-${toolId}`.toLowerCase()\n     */\n    dispatchUiSyncEvent(specificSyncEventId, toolId) {\n        const defaultRefreshEventId = \"tool-admin-refresh-ui\";\n        if (this.toolSyncUiEventDispatcher) {\n            if (specificSyncEventId)\n                this.toolSyncUiEventDispatcher(specificSyncEventId.toLowerCase());\n            else if (toolId)\n                this.toolSyncUiEventDispatcher(`${defaultRefreshEventId}-${toolId}`.toLowerCase());\n            else\n                this.toolSyncUiEventDispatcher(defaultRefreshEventId);\n        }\n    }\n    /**\n     * Starts the default [[Tool]], if any. Generally invoked automatically when other tools exit, so shouldn't be called directly.\n     * @note The default tool is expected to be a subclass of [[PrimitiveTool]]. A call to startDefaultTool is required to terminate\n     * an active [[ViewTool]] or [[InputCollector]] and replace or clear the current [[PrimitiveTool]].\n     * The tool's [[Tool.run]] method is invoked with arguments specified by [[defaultToolArgs]].\n     * @see [[defaultToolId]] to configure the default tool.\n     */\n    async startDefaultTool() {\n        if (!await IModelApp.tools.run(this.defaultToolId, this.defaultToolArgs))\n            return this.startPrimitiveTool(undefined);\n    }\n    setCursor(cursor) {\n        if (undefined === this._saveCursor)\n            IModelApp.viewManager.setViewCursor(cursor);\n        else\n            this._saveCursor = cursor;\n    }\n    /** @internal */\n    testDecorationHit(id) { return this.currentTool.testDecorationHit(id); }\n    /** @internal */\n    getDecorationGeometry(hit) { return this.currentTool.getDecorationGeometry(hit); }\n    /** @internal */\n    decorate(context) {\n        const tool = this.activeTool;\n        if (undefined !== tool) {\n            tool.decorate(context);\n            if (undefined !== this._inputCollector && tool !== this._inputCollector)\n                this._inputCollector.decorateSuspended(context);\n            if (undefined !== this._primitiveTool && tool !== this._primitiveTool)\n                this._primitiveTool.decorateSuspended(context);\n        }\n        const viewport = this.currentInputState.viewport;\n        if (viewport !== context.viewport)\n            return;\n        const ev = new BeButtonEvent();\n        this.fillEventFromCursorLocation(ev);\n        const hit = IModelApp.accuDraw.isActive ? undefined : IModelApp.accuSnap.currHit; // NOTE: Show surface normal until AccuDraw becomes active\n        viewport.drawLocateCursor(context, ev.viewPoint, viewport.pixelsFromInches(IModelApp.locateManager.apertureInches), this.isLocateCircleOn, hit);\n    }\n    get isLocateCircleOn() {\n        if (!this.toolState.locateCircleOn || undefined !== this._canvasDecoration)\n            return false;\n        if (InputSource.Mouse === this.currentInputState.inputSource)\n            return true;\n        return (InputSource.Touch === this.currentInputState.inputSource && undefined !== IModelApp.accuSnap.touchCursor);\n    }\n    /** @internal */\n    beginDynamics() {\n        IModelApp.accuDraw.onBeginDynamics();\n        IModelApp.viewManager.beginDynamicsMode();\n        this.setCursor(IModelApp.viewManager.dynamicsCursor);\n    }\n    /** @internal */\n    endDynamics() {\n        IModelApp.accuDraw.onEndDynamics();\n        IModelApp.viewManager.endDynamicsMode();\n        this.setCursor(IModelApp.viewManager.crossHairCursor);\n    }\n    /** Fill the supplied button event from the current cursor location. */\n    fillEventFromCursorLocation(ev, useSnap = true) { this.currentInputState.toEvent(ev, useSnap); }\n    /** Fill the supplied button event from the last data button location. */\n    fillEventFromLastDataButton(ev) { this.currentInputState.toEventFromLastDataPoint(ev); }\n    /** @internal */\n    setAdjustedDataPoint(ev) { this.currentInputState.adjustLastDataPoint(ev); }\n    /** Can be called by tools that wish to emulate mouse button down/up events for onTouchTap. */\n    async convertTouchTapToButtonDownAndUp(ev, button = BeButton.Data) {\n        const pt2d = ev.viewPoint;\n        await this.onButtonDown(ev.viewport, pt2d, button, InputSource.Touch);\n        return this.onButtonUp(ev.viewport, pt2d, button, InputSource.Touch);\n    }\n    /** Can be called by tools that wish to emulate moving the mouse with a button depressed for onTouchMoveStart.\n     * @note Calls the tool's onMouseStartDrag method from onMotion.\n     */\n    async convertTouchMoveStartToButtonDownAndMotion(startEv, ev, button = BeButton.Data) {\n        await this.onButtonDown(startEv.viewport, startEv.viewPoint, button, InputSource.Touch);\n        return this.onMotion(ev.viewport, ev.viewPoint, InputSource.Touch, true);\n    }\n    /** Can be called by tools that wish to emulate pressing the mouse button for onTouchStart or onTouchMoveStart. */\n    async convertTouchStartToButtonDown(ev, button = BeButton.Data) {\n        return this.onButtonDown(ev.viewport, ev.viewPoint, button, InputSource.Touch);\n    }\n    /** Can be called by tools that wish to emulate releasing the mouse button for onTouchEnd or onTouchComplete.\n     * @note Calls the tool's onMouseEndDrag method if convertTouchMoveStartToButtonDownAndMotion was called for onTouchMoveStart.\n     */\n    async convertTouchEndToButtonUp(ev, button = BeButton.Data) {\n        return this.onButtonUp(ev.viewport, ev.viewPoint, button, InputSource.Touch);\n    }\n    /** Can be called by tools that wish to emulate a mouse motion event for onTouchMove. */\n    async convertTouchMoveToMotion(ev) {\n        return this.onMotion(ev.viewport, ev.viewPoint, InputSource.Touch);\n    }\n    /** @internal */\n    setIncompatibleViewportCursor(restore) {\n        if (restore) {\n            if (undefined === this._saveCursor)\n                return;\n            this.toolState.locateCircleOn = this._saveLocateCircle;\n            IModelApp.viewManager.setViewCursor(this._saveCursor);\n            this._saveCursor = undefined;\n            return;\n        }\n        if (undefined !== this._saveCursor)\n            return;\n        this._saveLocateCircle = this.toolState.locateCircleOn;\n        this._saveCursor = IModelApp.viewManager.cursor;\n        this.toolState.locateCircleOn = false;\n        IModelApp.viewManager.setViewCursor(\"not-allowed\");\n    }\n    /** Performs default handling of mouse wheel event (zoom in/out) */\n    async processWheelEvent(ev, doUpdate) {\n        await WheelEventProcessor.process(ev, doUpdate);\n        IModelApp.viewManager.invalidateDecorationsAllViews();\n        this.updateDynamics(ev);\n        return EventHandled.Yes;\n    }\n    /** @internal */\n    async onSelectedViewportChanged(previous, current) {\n        IModelApp.accuDraw.onSelectedViewportChanged(previous, current);\n        if (undefined === current)\n            return this.callOnCleanup();\n        if (undefined !== this._viewTool)\n            this._viewTool.onSelectedViewportChanged(previous, current);\n        if (undefined !== this._inputCollector)\n            this._inputCollector.onSelectedViewportChanged(previous, current);\n        if (undefined !== this._primitiveTool)\n            await this._primitiveTool.onSelectedViewportChanged(previous, current);\n    }\n    setLocateCircleOn(locateOn) {\n        if (undefined === this._saveCursor)\n            this.toolState.locateCircleOn = locateOn;\n        else\n            this._saveLocateCircle = locateOn;\n    }\n    setLocateCursor(enableLocate) {\n        const viewManager = IModelApp.viewManager;\n        this.setCursor(viewManager.inDynamicsMode ? viewManager.dynamicsCursor : viewManager.crossHairCursor);\n        this.setLocateCircleOn(enableLocate);\n        viewManager.invalidateDecorationsAllViews();\n    }\n    /** Controls how the button event location is adjusted for the active tool */\n    get coordinateLockOverrides() { return this.toolState.coordLockOvr; }\n    set coordinateLockOverrides(coordLockOvr) { this.toolState.coordLockOvr = coordLockOvr; }\n    /** @internal */\n    async callOnCleanup() {\n        await this.exitViewTool();\n        await this.exitInputCollector();\n        if (undefined !== this._primitiveTool)\n            await this._primitiveTool.onCleanup();\n    }\n}\n/** Options for how uncaught exceptions should be handled by [[ToolAdmin.exceptionHandler]]. */\nToolAdmin.exceptionOptions = {\n    /** Log exception to Logger. */\n    log: true,\n    /** Show an alert box explaining that a problem happened. */\n    alertBox: true,\n    /** Include the \"gory details\" (e.g. stack trace) in the alert box. */\n    details: true,\n    /** break into debugger (only works if debugger is already opened) */\n    launchDebugger: true,\n};\nToolAdmin._removals = [];\n/** Handler for keyboard events. */\nToolAdmin._keyEventHandler = (ev) => {\n    if (!ev.repeat) // we don't want repeated keyboard events. If we keep them they interfere with replacing mouse motion events, since they come as a stream.\n        ToolAdmin.addEvent(ev);\n};\n/** A first-in-first-out queue of ToolEvents. */\nToolAdmin._toolEvents = [];\nexport { ToolAdmin };\n/**\n * Default processor to handle wheel events.\n * @internal\n */\nexport class WheelEventProcessor {\n    static async process(ev, doUpdate) {\n        const vp = ev.viewport;\n        if (undefined === vp)\n            return;\n        await this.doZoom(ev);\n        if (doUpdate) {\n            // AccuSnap hit won't be invalidated without cursor motion (closes info window, etc.).\n            IModelApp.accuSnap.clear();\n        }\n    }\n    static async doZoom(ev) {\n        const vp = ev.viewport;\n        if (undefined === vp)\n            return ViewStatus.InvalidViewport;\n        let zoomRatio = ToolSettings.wheelZoomRatio;\n        if (zoomRatio < 1)\n            zoomRatio = 1;\n        if (ev.wheelDelta > 0)\n            zoomRatio = 1 / zoomRatio;\n        let isSnapOrPrecision = false;\n        const target = Point3d.create();\n        if (IModelApp.tentativePoint.isActive) {\n            // Always use Tentative location, adjusted point, not cross\n            isSnapOrPrecision = true;\n            target.setFrom(IModelApp.tentativePoint.getPoint());\n        }\n        else {\n            // Never use AccuSnap location as initial zoom clears snap causing zoom center to \"jump\"\n            isSnapOrPrecision = CoordSource.Precision === ev.coordsFrom;\n            target.setFrom(isSnapOrPrecision ? ev.point : ev.rawPoint);\n        }\n        const view = vp.view;\n        let globalAlignment;\n        if (view.is3d() && view.iModel.ecefLocation)\n            globalAlignment = { target, transition: zoomRatio > 1 };\n        const animationOptions = {\n            animateFrustumChange: true,\n            cancelOnAbort: true,\n            animationTime: ScreenViewport.animation.time.wheel.milliseconds,\n            easingFunction: Easing.Cubic.Out,\n            onExtentsError: (err) => view.outputStatusMessage(err),\n            globalAlignment,\n        };\n        const currentInputState = IModelApp.toolAdmin.currentInputState;\n        let status;\n        const now = Date.now();\n        if (view.is3d() && view.isCameraOn) {\n            if (!isSnapOrPrecision) {\n                let lastEvent = currentInputState.lastWheelEvent;\n                if (undefined !== lastEvent && lastEvent.viewport &&\n                    now - lastEvent.time < ToolSettings.doubleClickTimeout.milliseconds &&\n                    lastEvent.viewport.view.equals(view) && lastEvent.viewPoint.distanceSquaredXY(ev.viewPoint) < 10) {\n                    target.setFrom(lastEvent.point);\n                    lastEvent.time = now;\n                }\n                else {\n                    const newTarget = vp.pickNearestVisibleGeometry(target);\n                    if (undefined !== newTarget) {\n                        target.setFrom(newTarget);\n                    }\n                    else {\n                        view.getTargetPoint(target);\n                    }\n                    currentInputState.lastWheelEvent = lastEvent = ev.clone();\n                    lastEvent.point.setFrom(target);\n                }\n            }\n            const transform = Transform.createFixedPointAndMatrix(target, Matrix3d.createScale(zoomRatio, zoomRatio, zoomRatio));\n            const eye = view.getEyePoint();\n            const newEye = transform.multiplyPoint3d(eye);\n            const offset = eye.vectorTo(newEye);\n            // when you're too close to an object, the wheel zoom operation will stop. We set a \"bump distance\" so you can blast through obstacles.\n            const bumpDist = Math.max(ToolSettings.wheelZoomBumpDistance, view.minimumFrontDistance());\n            if (offset.magnitude() < bumpDist) {\n                offset.scaleToLength(bumpDist, offset); // move bump distance, just to get to the other side.\n                target.addInPlace(offset);\n                newEye.setFrom(eye.plus(offset));\n                currentInputState.lastWheelEvent = undefined; // we need to search on the \"other side\" of what we were bumping into\n            }\n            const zDir = view.getZVector();\n            target.setFrom(newEye.plusScaled(zDir, zDir.dotProduct(newEye.vectorTo(target))));\n            if (ViewStatus.Success === (status = view.lookAt({ eyePoint: newEye, targetPoint: target, upVector: view.getYVector(), lensAngle: view.camera.lens, opts: animationOptions })))\n                vp.synchWithView(animationOptions);\n        }\n        else {\n            const targetNpc = vp.worldToNpc(target);\n            const trans = Transform.createFixedPointAndMatrix(targetNpc, Matrix3d.createScale(zoomRatio, zoomRatio, 1));\n            const viewCenter = trans.multiplyPoint3d(Point3d.create(.5, .5, .5));\n            vp.npcToWorld(viewCenter, viewCenter);\n            return vp.zoom(viewCenter, zoomRatio, animationOptions);\n        }\n        // if we scrolled out, we may have invalidated the current AccuSnap path\n        await IModelApp.accuSnap.reEvaluate();\n        return status;\n    }\n}\n//# sourceMappingURL=ToolAdmin.js.map",
      "start": 1693508119773,
      "end": 1693508120096,
      "sourcemaps": null
    }
  ]
}
