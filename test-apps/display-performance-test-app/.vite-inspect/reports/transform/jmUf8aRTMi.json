{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tile/TileAdmin.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tiles\n */\nimport { assert, BeDuration, BeEvent, BentleyStatus, BeTimePoint, Id64, IModelStatus, ProcessDetector, } from \"@itwin/core-bentley\";\nimport { BackendError, defaultTileOptions, getMaximumMajorTileFormatVersion, IModelError, IModelTileRpcInterface, RpcOperation, RpcResponseCacheControl, ServerTimeoutError, TileContentSource, } from \"@itwin/core-common\";\nimport { IModelApp } from \"../IModelApp\";\nimport { IpcApp } from \"../IpcApp\";\nimport { IModelConnection } from \"../IModelConnection\";\nimport { Viewport } from \"../Viewport\";\nimport { DisclosedTileTreeSet, FetchCloudStorage, LRUTileList, TileLoadStatus, TileRequest, TileRequestChannels, TileStorage, UniqueTileUserSets, } from \"./internal\";\n/** Manages [[Tile]]s and [[TileTree]]s on behalf of [[IModelApp]]. Its responsibilities include scheduling requests for tile content via a priority queue;\n * keeping track of and imposing limits upon the amount of GPU memory consumed by tiles; and notifying listeners of tile-related events.\n * @see [[IModelApp.tileAdmin]] to access the instance of the TileAdmin.\n * @see [[TileAdmin.Props]] to configure the TileAdmin at startup.\n * @public\n * @extensions\n */\nexport class TileAdmin {\n    /** Create a TileAdmin suitable for passing to [[IModelApp.startup]] via [[IModelAppOptions.tileAdmin]] to customize aspects of\n     * its behavior.\n     * @param props Options for customizing the behavior of the TileAdmin.\n     * @returns the TileAdmin\n     */\n    static async create(props) {\n        const rpcConcurrency = IpcApp.isValid ? (await IpcApp.appFunctionIpc.queryConcurrency(\"cpu\")) : undefined;\n        const isMobile = ProcessDetector.isMobileBrowser;\n        return new TileAdmin(isMobile, rpcConcurrency, props);\n    }\n    /** @internal */\n    get emptyTileUserSet() { return UniqueTileUserSets.emptySet; }\n    /** Returns basic statistics about the TileAdmin's current state. */\n    get statistics() {\n        let numActiveTileTreePropsRequests = 0;\n        for (const req of this._tileTreePropsRequests) {\n            if (!req.isDispatched)\n                break;\n            ++numActiveTileTreePropsRequests;\n        }\n        return {\n            ...this.channels.statistics,\n            totalElidedTiles: this._totalElided,\n            numActiveTileTreePropsRequests,\n            numPendingTileTreePropsRequests: this._tileTreePropsRequests.length - numActiveTileTreePropsRequests,\n        };\n    }\n    /** Resets the cumulative (per-session) statistics like totalCompletedRequests, totalEmptyTiles, etc. */\n    resetStatistics() {\n        this.channels.resetStatistics();\n        this._totalElided = 0;\n    }\n    /** Exposed as public strictly for tests.\n     * @internal\n     */\n    constructor(isMobile, rpcConcurrency, options) {\n        this._users = new Set();\n        this._requestsPerUser = new Map();\n        this._tileUsagePerUser = new Map();\n        this._selectedAndReady = new Map();\n        this._tileUserSetsForRequests = new UniqueTileUserSets();\n        this._totalElided = 0;\n        this._rpcInitialized = false;\n        this._tileTreePropsRequests = [];\n        this._lruList = new LRUTileList();\n        this._gpuMemoryLimit = \"none\";\n        /** Event raised when a request to load a tile's content completes. */\n        this.onTileLoad = new BeEvent();\n        /** Event raised when a request to load a tile tree completes. */\n        this.onTileTreeLoad = new BeEvent();\n        /** Event raised when a request to load a tile's child tiles completes. */\n        this.onTileChildrenLoad = new BeEvent();\n        this._isMobile = isMobile;\n        if (undefined === options)\n            options = {};\n        this.channels = new TileRequestChannels(rpcConcurrency, true === options.cacheTileMetadata);\n        this._maxActiveTileTreePropsRequests = options.maxActiveTileTreePropsRequests ?? 10;\n        this._defaultTileSizeModifier = (undefined !== options.defaultTileSizeModifier && options.defaultTileSizeModifier > 0) ? options.defaultTileSizeModifier : 1.0;\n        this._retryInterval = undefined !== options.retryInterval ? options.retryInterval : 1000;\n        this._enableInstancing = options.enableInstancing ?? defaultTileOptions.enableInstancing;\n        this.edgeOptions = {\n            type: false === options.enableIndexedEdges ? \"non-indexed\" : \"compact\",\n            smooth: options.generateAllPolyfaceEdges ?? true,\n        };\n        this.enableImprovedElision = options.enableImprovedElision ?? defaultTileOptions.enableImprovedElision;\n        this.enableFrontendScheduleScripts = options.enableFrontendScheduleScripts ?? false;\n        this.decodeImdlInWorker = options.decodeImdlInWorker ?? true;\n        this.ignoreAreaPatterns = options.ignoreAreaPatterns ?? defaultTileOptions.ignoreAreaPatterns;\n        this.enableExternalTextures = options.enableExternalTextures ?? defaultTileOptions.enableExternalTextures;\n        this.disableMagnification = options.disableMagnification ?? defaultTileOptions.disableMagnification;\n        this.alwaysRequestEdges = true === options.alwaysRequestEdges;\n        this.alwaysSubdivideIncompleteTiles = options.alwaysSubdivideIncompleteTiles ?? defaultTileOptions.alwaysSubdivideIncompleteTiles;\n        this.maximumMajorTileFormatVersion = options.maximumMajorTileFormatVersion ?? defaultTileOptions.maximumMajorTileFormatVersion;\n        this.useProjectExtents = options.useProjectExtents ?? defaultTileOptions.useProjectExtents;\n        this.optimizeBRepProcessing = options.optimizeBRepProcessing ?? defaultTileOptions.optimizeBRepProcessing;\n        this.useLargerTiles = options.useLargerTiles ?? defaultTileOptions.useLargerTiles;\n        this.mobileRealityTileMinToleranceRatio = Math.max(options.mobileRealityTileMinToleranceRatio ?? 3.0, 1.0);\n        this.cesiumIonKey = options.cesiumIonKey;\n        this._cloudStorage = options.tileStorage;\n        const gpuMemoryLimits = options.gpuMemoryLimits;\n        let gpuMemoryLimit;\n        if (typeof gpuMemoryLimits === \"object\")\n            gpuMemoryLimit = isMobile ? gpuMemoryLimits.mobile : gpuMemoryLimits.nonMobile;\n        else\n            gpuMemoryLimit = gpuMemoryLimits;\n        if (undefined === gpuMemoryLimit && isMobile)\n            gpuMemoryLimit = \"default\";\n        if (undefined !== gpuMemoryLimit)\n            this.gpuMemoryLimit = gpuMemoryLimit;\n        if (undefined !== options.maximumLevelsToSkip)\n            this.maximumLevelsToSkip = Math.floor(Math.max(0, options.maximumLevelsToSkip));\n        else\n            this.maximumLevelsToSkip = 1;\n        const minSpatialTol = options.minimumSpatialTolerance;\n        this.minimumSpatialTolerance = undefined !== minSpatialTol ? Math.max(minSpatialTol, 0) : 0.001;\n        const clamp = (seconds, min, max) => {\n            seconds = Math.min(seconds, max);\n            seconds = Math.max(seconds, min);\n            return BeDuration.fromSeconds(seconds);\n        };\n        const ignoreMinimums = true === options.ignoreMinimumExpirationTimes;\n        const minTileTime = ignoreMinimums ? 0.1 : 5;\n        const minTreeTime = ignoreMinimums ? 0.1 : 10;\n        // If unspecified, tile expiration time defaults to 20 seconds.\n        this.tileExpirationTime = clamp((options.tileExpirationTime ?? 20), minTileTime, 60);\n        // If unspecified, trees never expire (will change this to use a default later).\n        this.tileTreeExpirationTime = clamp(options.tileTreeExpirationTime ?? 300, minTreeTime, 3600);\n        const now = BeTimePoint.now();\n        this._nextPruneTime = now.plus(this.tileExpirationTime);\n        this._nextPurgeTime = now.plus(this.tileTreeExpirationTime);\n        this._removeIModelConnectionOnCloseListener = IModelConnection.onClose.addListener((iModel) => this.onIModelClosed(iModel));\n        // If unspecified preload 2 levels of parents for context tiles.\n        this.contextPreloadParentDepth = Math.max(0, Math.min((options.contextPreloadParentDepth === undefined ? 2 : options.contextPreloadParentDepth), 8));\n        // If unspecified skip one level before preloading  of parents of context tiles.\n        this.contextPreloadParentSkip = Math.max(0, Math.min((options.contextPreloadParentSkip === undefined ? 1 : options.contextPreloadParentSkip), 5));\n        const removals = [\n            this.onTileLoad.addListener(() => this.invalidateAllScenes()),\n            this.onTileChildrenLoad.addListener(() => this.invalidateAllScenes()),\n            this.onTileTreeLoad.addListener(() => {\n                // A reality model tile tree's range may extend outside of the project extents - we'll want to recompute the extents\n                // of any spatial view's that may be displaying the reality model.\n                for (const user of this.tileUsers)\n                    if (user instanceof Viewport && user.view.isSpatialView())\n                        user.invalidateController();\n            }),\n        ];\n        this._cleanup = () => {\n            removals.forEach((removal) => removal());\n        };\n    }\n    async getTileStorage() {\n        if (this._tileStorage !== undefined)\n            return this._tileStorage;\n        // if custom implementation is provided, construct a new TileStorage instance and return it.\n        if (this._cloudStorage !== undefined) {\n            this._tileStorage = new TileStorage(this._cloudStorage);\n            return this._tileStorage;\n        }\n        const fetchStorage = new FetchCloudStorage();\n        this._tileStorage = new TileStorage(fetchStorage);\n        return this._tileStorage;\n    }\n    /** @internal */\n    get enableInstancing() { return this._enableInstancing; }\n    /** Given a numeric combined major+minor tile format version (typically obtained from a request to the backend to query the maximum tile format version it supports),\n     * return the maximum *major* format version to be used to request tile content from the backend.\n     * @see [[TileAdmin.Props.maximumMajorTileFormatVersion]]\n     * @see [[CurrentImdlVersion]]\n     */\n    getMaximumMajorTileFormatVersion(formatVersion) {\n        return getMaximumMajorTileFormatVersion(this.maximumMajorTileFormatVersion, formatVersion);\n    }\n    /** A default multiplier applied to the size in pixels of a [[Tile]] during tile selection for any [[Viewport]].\n     * Individual Viewports can override this multiplier if desired.\n     * A value greater than 1.0 causes lower-resolution tiles to be selected; a value < 1.0 selects higher-resolution tiles.\n     * This can allow an application to sacrifice quality for performance or vice-versa.\n     * This property is initialized from the value supplied by the [[TileAdmin.Props.defaultTileSizeModifier]] used to initialize the TileAdmin at startup.\n     * Changing it after startup will change it for all Viewports that do not explicitly override it with their own multiplier.\n     * This value must be greater than zero.\n     */\n    get defaultTileSizeModifier() { return this._defaultTileSizeModifier; }\n    set defaultTileSizeModifier(modifier) {\n        if (modifier !== this._defaultTileSizeModifier && modifier > 0 && !Number.isNaN(modifier)) {\n            this._defaultTileSizeModifier = modifier;\n            IModelApp.viewManager.invalidateScenes();\n        }\n    }\n    /** The total number of bytes of GPU memory allocated to [[Tile]] contents.\n     * @see [[gpuMemoryLimit]] to impose limits on how high this can grow.\n     */\n    get totalTileContentBytes() {\n        return this._lruList.totalBytesUsed;\n    }\n    /** The maximum number of bytes of GPU memory that can be allocated to the contents of [[Tile]]s. When this limit is exceeded, the contents of the least-recently-drawn\n     * tiles are discarded until the total is below this limit or all undisplayed tiles' contents have been discarded.\n     * @see [[totalTileContentBytes]] for the current GPU memory usage.\n     * @see [[gpuMemoryLimit]] to adjust this maximum.\n     */\n    get maxTotalTileContentBytes() {\n        return this._maxTotalTileContentBytes;\n    }\n    /** The strategy for limiting the amount of GPU memory allocated to [[Tile]] graphics.\n     * @see [[TileAdmin.Props.gpuMemoryLimits]] to configure this at startup.\n     * @see [[maxTotalTileContentBytes]] for the limit as a maximum number of bytes.\n     */\n    get gpuMemoryLimit() {\n        return this._gpuMemoryLimit;\n    }\n    set gpuMemoryLimit(limit) {\n        if (limit === this.gpuMemoryLimit)\n            return;\n        let maxBytes;\n        if (typeof limit === \"number\") {\n            limit = Math.max(0, limit);\n            maxBytes = limit;\n        }\n        else {\n            switch (limit) {\n                case \"default\":\n                case \"aggressive\":\n                case \"relaxed\":\n                    const spec = this._isMobile ? TileAdmin.mobileGpuMemoryLimits : TileAdmin.nonMobileGpuMemoryLimits;\n                    maxBytes = spec[limit];\n                    break;\n                default:\n                    limit = \"none\";\n                // eslint-disable-next-line no-fallthrough\n                case \"none\":\n                    maxBytes = undefined;\n                    break;\n            }\n        }\n        this._gpuMemoryLimit = limit;\n        this._maxTotalTileContentBytes = maxBytes;\n    }\n    /** Invoked from the [[ToolAdmin]] event loop to process any pending or active requests for tiles.\n     * @internal\n     */\n    process() {\n        this.processQueue();\n        // Prune expired tiles and purge expired tile trees. This may free up some memory.\n        this.pruneAndPurge();\n        // Free up any additional memory as required to keep within our limit.\n        this.freeMemory();\n    }\n    /** Iterate over the tiles that have content loaded but are not in use by any [[TileUser]].\n     * @alpha\n     */\n    get unselectedLoadedTiles() {\n        return this._lruList.unselectedTiles;\n    }\n    /** Iterate over the tiles that have content loaded and are in use by any [[TileUser]].\n     * @alpha\n     */\n    get selectedLoadedTiles() {\n        return this._lruList.selectedTiles;\n    }\n    /** Returns the number of pending and active requests associated with the specified viewport. */\n    getNumRequestsForViewport(vp) {\n        return this.getNumRequestsForUser(vp);\n    }\n    /** Returns the number of pending and active requests associated with the specified user. */\n    getNumRequestsForUser(user) {\n        const requests = this.getRequestsForUser(user);\n        let count = requests?.size ?? 0;\n        const tiles = this.getTilesForUser(user);\n        if (tiles)\n            count += tiles.external.requested;\n        return count;\n    }\n    /** Returns the current set of Tiles requested by the specified TileUser.\n     * Do not modify the set or the Tiles.\n     * @internal\n     */\n    getRequestsForUser(user) {\n        return this._requestsPerUser.get(user);\n    }\n    /** Specifies the set of tiles currently requested for use by a TileUser. This set replaces any previously specified for the same user.\n     * The requests are not actually processed until the next call to [[TileAdmin.process].\n     * This is typically invoked when a viewport recreates its scene, e.g. in response to camera movement.\n     * @internal\n     */\n    requestTiles(user, tiles) {\n        this._requestsPerUser.set(user, tiles);\n    }\n    /** Returns two sets of tiles associated with the specified user - typically, a viewport's current scene.\n     * Do not modify the returned sets.\n     * @internal\n     */\n    getTilesForUser(user) {\n        return this._selectedAndReady.get(user);\n    }\n    /** Adds the specified tiles to the sets of selected and ready tiles for the specified TileUser.\n     * The TileAdmin takes ownership of the `ready` set - do not modify it after passing it in.\n     * @internal\n     */\n    addTilesForUser(user, selected, ready, touched) {\n        // \"selected\" are tiles we are drawing.\n        this._lruList.markUsed(user.tileUserId, selected);\n        // \"ready\" are tiles we want to draw but can't yet because, for example, their siblings are not yet ready to be drawn.\n        this._lruList.markUsed(user.tileUserId, ready);\n        // \"touched\" are tiles whose contents we want to keep in memory regardless of whether they are \"selected\" or \"ready\".\n        this._lruList.markUsed(user.tileUserId, touched);\n        const entry = this.getTilesForUser(user);\n        if (undefined === entry) {\n            this._selectedAndReady.set(user, { ready, selected: new Set(selected), external: { selected: 0, requested: 0, ready: 0 } });\n            return;\n        }\n        for (const tile of selected)\n            entry.selected.add(tile);\n        for (const tile of ready)\n            entry.ready.add(tile);\n    }\n    /** Disclose statistics about tiles that are handled externally from TileAdmin. At this time, that means OrbitGT point cloud tiles.\n     * These statistics are included in the return value of [[getTilesForUser]].\n     * @internal\n     */\n    addExternalTilesForUser(user, statistics) {\n        const entry = this.getTilesForUser(user);\n        if (!entry) {\n            this._selectedAndReady.set(user, { ready: new Set(), selected: new Set(), external: { ...statistics } });\n            return;\n        }\n        entry.external.requested += statistics.requested;\n        entry.external.selected += statistics.selected;\n        entry.external.ready += statistics.ready;\n    }\n    /** Clears the sets of tiles associated with a TileUser. */\n    clearTilesForUser(user) {\n        this._selectedAndReady.delete(user);\n        this._lruList.clearUsed(user.tileUserId);\n    }\n    /** Indicates that the TileAdmin should cease tracking the specified TileUser, e.g. because it is about to be destroyed.\n     * Any requests which are of interest only to the specified user will be canceled.\n     */\n    forgetUser(user) {\n        this.onUserIModelClosed(user);\n        this._users.delete(user);\n    }\n    /** Indicates that the TileAdmin should track tile requests for the specified TileUser.\n     * This is invoked by the Viewport constructor and should be invoked manually for any non-Viewport TileUser.\n     * [[forgetUser]] must be later invoked to unregister the user.\n     */\n    registerUser(user) {\n        this._users.add(user);\n    }\n    /** Iterable over all TileUsers registered with TileAdmin. This may include [[OffScreenViewport]]s.\n     * @alpha\n     */\n    get tileUsers() {\n        return this._users;\n    }\n    /** @internal */\n    invalidateAllScenes() {\n        for (const user of this.tileUsers)\n            if (user instanceof Viewport)\n                user.invalidateScene();\n    }\n    /** @internal */\n    onShutDown() {\n        if (this._cleanup) {\n            this._cleanup();\n            this._cleanup = undefined;\n        }\n        this._removeIModelConnectionOnCloseListener();\n        this.channels.onShutDown();\n        for (const req of this._tileTreePropsRequests)\n            req.abandon();\n        this._requestsPerUser.clear();\n        this._tileUserSetsForRequests.clear();\n        this._tileUsagePerUser.clear();\n        this._tileTreePropsRequests.length = 0;\n        this._lruList.dispose();\n    }\n    /** Returns the union of the input set and the input TileUser, to be associated with a [[TileRequest]].\n     * @internal\n     */\n    getTileUserSetForRequest(user, users) {\n        return this._tileUserSetsForRequests.getTileUserSet(user, users);\n    }\n    /** Marks the Tile as \"in use\" by the specified TileUser, where the tile defines what \"in use\" means.\n     * A tile will not be discarded while it is in use by any TileUser.\n     * @see [[TileTree.prune]]\n     * @internal\n     */\n    markTileUsed(marker, user) {\n        let set = this._tileUsagePerUser.get(user);\n        if (!set)\n            this._tileUsagePerUser.set(user, set = new Set());\n        set.add(marker);\n    }\n    /** Returns true if the Tile is currently in use by any TileUser.\n     * @see [[markTileUsed]].\n     * @internal\n     */\n    isTileInUse(marker) {\n        // eslint-disable-next-line @typescript-eslint/naming-convention\n        for (const [_user, markers] of this._tileUsagePerUser)\n            if (markers.has(marker))\n                return true;\n        return false;\n    }\n    /** Indicates that the TileAdmin should reset usage tracking for the specified TileUser, e.g. because the user is a Viewport about\n     * to recreate its scene. Any tiles currently marked as \"in use\" by this user no longer will be.\n     * @internal\n     */\n    clearUsageForUser(user) {\n        this._tileUsagePerUser.delete(user);\n    }\n    /** @internal */\n    async requestTileTreeProps(iModel, treeId) {\n        this.initializeRpc();\n        const requests = this._tileTreePropsRequests;\n        return new Promise((resolve, reject) => {\n            const request = new TileTreePropsRequest(iModel, treeId, resolve, reject);\n            requests.push(request);\n            if (this._tileTreePropsRequests.length <= this._maxActiveTileTreePropsRequests)\n                request.dispatch();\n        });\n    }\n    /** Temporary workaround for authoring applications. Usage:\n     * ```ts\n     *  async function handleModelChanged(modelId: Id64String, iModel: IModelConnection): Promise<void> {\n     *    await iModel.tiles.purgeTileTrees([modelId]);\n     *    IModelApp.viewManager.refreshForModifiedModels(modelId);\n     *  }\n     * ```\n     * @internal\n     */\n    async purgeTileTrees(iModel, modelIds) {\n        this.initializeRpc();\n        return IModelTileRpcInterface.getClient().purgeTileTrees(iModel.getRpcProps(), modelIds);\n    }\n    /** @internal */\n    async requestCachedTileContent(tile) {\n        if (tile.iModelTree.iModel.iModelId === undefined)\n            throw new Error(\"Provided iModel has no iModelId\");\n        const { guid, tokenProps, treeId } = this.getTileRequestProps(tile);\n        const content = await (await this.getTileStorage()).downloadTile(tokenProps, tile.iModelTree.iModel.iModelId, tile.iModelTree.iModel.changeset.id, treeId, tile.contentId, guid);\n        return content;\n    }\n    /** @internal */\n    async generateTileContent(tile) {\n        this.initializeRpc();\n        const props = this.getTileRequestProps(tile);\n        const retrieveMethod = await IModelTileRpcInterface.getClient().generateTileContent(props.tokenProps, props.treeId, props.contentId, props.guid);\n        if (tile.request?.isCanceled) {\n            // the content is no longer needed, return an empty array.\n            return new Uint8Array();\n        }\n        if (retrieveMethod === TileContentSource.ExternalCache) {\n            const tileContent = await this.requestCachedTileContent(tile);\n            if (tileContent === undefined)\n                throw new IModelError(IModelStatus.NoContent, \"Failed to fetch generated tile from external cache\");\n            return tileContent;\n        }\n        else if (retrieveMethod === TileContentSource.Backend) {\n            return IModelTileRpcInterface.getClient().retrieveTileContent(props.tokenProps, this.getTileRequestProps(tile));\n        }\n        throw new BackendError(BentleyStatus.ERROR, \"\", \"Invalid response from RPC backend\");\n    }\n    /** @internal */\n    getTileRequestProps(tile) {\n        const tree = tile.iModelTree;\n        const tokenProps = tree.iModel.getRpcProps();\n        let guid = tree.geometryGuid || tokenProps.changeset?.id || \"first\";\n        if (tree.contentIdQualifier)\n            guid = `${guid}_${tree.contentIdQualifier}`;\n        const contentId = tile.contentId;\n        const treeId = tree.id;\n        return { tokenProps, treeId, contentId, guid };\n    }\n    /** Request graphics for a single element or geometry stream.\n     * @see [[readElementGraphics]] to convert the result into a [[RenderGraphic]] for display.\n     * @public\n     */\n    async requestElementGraphics(iModel, requestProps) {\n        if (true !== requestProps.omitEdges && undefined === requestProps.edgeType)\n            requestProps = { ...requestProps, edgeType: \"non-indexed\" !== this.edgeOptions.type ? 2 : 1 };\n        // For backwards compatibility, these options default to true in the backend. Explicitly set them to false in (newer) frontends if not supplied.\n        if (undefined === requestProps.quantizePositions || undefined === requestProps.useAbsolutePositions) {\n            requestProps = {\n                ...requestProps,\n                quantizePositions: requestProps.quantizePositions ?? false,\n                useAbsolutePositions: requestProps.useAbsolutePositions ?? false,\n            };\n        }\n        this.initializeRpc();\n        const intfc = IModelTileRpcInterface.getClient();\n        return intfc.requestElementGraphics(iModel.getRpcProps(), requestProps);\n    }\n    /** Obtain information about the version/format of the tiles supplied by the backend. */\n    async queryVersionInfo() {\n        if (!this._versionInfo) {\n            this.initializeRpc();\n            this._versionInfo = await IModelTileRpcInterface.getClient().queryVersionInfo();\n        }\n        return this._versionInfo;\n    }\n    /** @internal */\n    onTilesElided(numElided) {\n        this._totalElided += numElided;\n    }\n    /** Invoked when a Tile marks itself as \"ready\" - i.e., its content is loaded (or determined not to exist, or not to be needed).\n     * If the tile has content, it is added to the LRU list of tiles with content.\n     * The `onTileLoad` event will also be raised.\n     * @internal\n     */\n    onTileContentLoaded(tile) {\n        // It may already be present if it previously had content - perhaps we're replacing its content.\n        this._lruList.drop(tile);\n        this._lruList.add(tile);\n        this.onTileLoad.raiseEvent(tile);\n    }\n    /** Invoked when a Tile's content is disposed of. It will be removed from the LRU list of tiles with content.\n     * @internal\n     */\n    onTileContentDisposed(tile) {\n        this._lruList.drop(tile);\n    }\n    /** @internal */\n    terminateTileTreePropsRequest(request) {\n        const index = this._tileTreePropsRequests.indexOf(request);\n        if (index >= 0) {\n            this._tileTreePropsRequests.splice(index, 1);\n            this.dispatchTileTreePropsRequests();\n        }\n    }\n    /** Subscribe to [[onTileLoad]], [[onTileTreeLoad]], and [[onTileChildrenLoad]]. */\n    addLoadListener(callback) {\n        const tileLoad = this.onTileLoad.addListener((tile) => callback(tile.tree.iModel));\n        const treeLoad = this.onTileTreeLoad.addListener((tree) => callback(tree.iModel));\n        const childLoad = this.onTileChildrenLoad.addListener((tile) => callback(tile.tree.iModel));\n        return () => {\n            tileLoad();\n            treeLoad();\n            childLoad();\n        };\n    }\n    /** Determine what information about the schedule script is needed to produce tiles.\n     * If no script, or the script doesn't require batching, then no information is needed - normal tiles can be used.\n     * If possible and enabled, normal tiles can be requested and then processed on the frontend based on the ModelTimeline.\n     * Otherwise, special tiles must be requested based on the script's sourceId (RenderTimeline or DisplayStyle element).\n     * @internal\n     */\n    getScriptInfoForTreeId(modelId, script) {\n        if (!script || !script.script.requiresBatching)\n            return undefined;\n        const timeline = script.script.modelTimelines.find((x) => x.modelId === modelId);\n        if (!timeline || (!timeline.requiresBatching && !timeline.containsTransform))\n            return undefined;\n        // Frontend schedule scripts require the element Ids to be included in the script - previously saved views may have omitted them.\n        if (!Id64.isValidId64(script.sourceId) || (this.enableFrontendScheduleScripts && !timeline.omitsElementIds))\n            return { timeline };\n        return { animationId: script.sourceId };\n    }\n    dispatchTileTreePropsRequests() {\n        for (let i = 0; i < this._maxActiveTileTreePropsRequests && i < this._tileTreePropsRequests.length; i++)\n            this._tileTreePropsRequests[i].dispatch();\n    }\n    processQueue() {\n        // Mark all requests as being associated with no users, indicating they are no longer needed.\n        this._tileUserSetsForRequests.clearAll();\n        // Notify channels that we are enqueuing new requests.\n        this.channels.swapPending();\n        // Repopulate pending requests queue from each user. We do NOT sort by priority while doing so.\n        this._requestsPerUser.forEach((value, key) => this.processRequests(key, value));\n        // Ask channels to update their queues and dispatch requests.\n        this.channels.process();\n    }\n    /** Exported strictly for tests. @internal */\n    freeMemory() {\n        if (undefined !== this._maxTotalTileContentBytes)\n            this._lruList.freeMemory(this._maxTotalTileContentBytes);\n    }\n    pruneAndPurge() {\n        const now = BeTimePoint.now();\n        const needPrune = this._nextPruneTime.before(now);\n        const needPurge = this._nextPurgeTime.before(now);\n        if (!needPrune && !needPurge)\n            return;\n        // Identify all of the TileTrees in use by all of the TileUsers known to the TileAdmin.\n        // NOTE: A single viewport can display tiles from more than one IModelConnection.\n        // NOTE: A viewport may be displaying no trees - but we need to record its IModel so we can purge those which are NOT being displayed\n        //  NOTE: That won't catch external tile trees previously used by that viewport.\n        const trees = new DisclosedTileTreeSet();\n        const treesByIModel = needPurge ? new Map() : undefined;\n        for (const user of this._users) {\n            if (!user.iModel.isOpen) // case of closing an IModelConnection while keeping the Viewport open, possibly for reuse with a different IModelConnection.\n                continue;\n            user.discloseTileTrees(trees);\n            if (treesByIModel && undefined === treesByIModel.get(user.iModel))\n                treesByIModel.set(user.iModel, new Set());\n        }\n        if (needPrune) {\n            // Request that each displayed tile tree discard any tiles and/or tile content that is no longer needed.\n            for (const tree of trees)\n                tree.prune();\n            this._nextPruneTime = now.plus(this.tileExpirationTime);\n        }\n        if (treesByIModel) {\n            for (const tree of trees) {\n                let set = treesByIModel.get(tree.iModel);\n                if (undefined === set)\n                    treesByIModel.set(tree.iModel, set = new Set());\n                set.add(tree);\n            }\n            // Discard any tile trees that are no longer in use by any user.\n            const olderThan = now.minus(this.tileTreeExpirationTime);\n            for (const entry of treesByIModel)\n                entry[0].tiles.purge(olderThan, entry[1]);\n            this._nextPurgeTime = now.plus(this.tileTreeExpirationTime);\n        }\n    }\n    processRequests(user, tiles) {\n        for (const tile of tiles) {\n            if (undefined === tile.request) {\n                // ###TODO: This assertion triggers for AttachmentViewports used for rendering 3d sheet attachments.\n                // Determine why and fix.\n                // assert(tile.loadStatus === Tile.LoadStatus.NotLoaded);\n                if (TileLoadStatus.NotLoaded === tile.loadStatus) {\n                    const request = new TileRequest(tile, user);\n                    tile.request = request;\n                    assert(this.channels.has(request.channel));\n                    request.channel.append(request);\n                }\n            }\n            else {\n                const req = tile.request;\n                assert(undefined !== req);\n                if (undefined !== req) {\n                    // Request may already be dispatched (in channel's active requests) - if so do not re-enqueue!\n                    if (req.isQueued && 0 === req.users.length)\n                        req.channel.append(req);\n                    req.addUser(user);\n                    assert(0 < req.users.length);\n                }\n            }\n        }\n    }\n    // NB: This does *not* remove from this._users - a viewport could later be reused with a different IModelConnection.\n    onUserIModelClosed(user) {\n        this.clearUsageForUser(user);\n        this.clearTilesForUser(user);\n        // NB: user will be removed from TileUserSets in process() - but if we can establish that only this user wants a given tile, cancel its request immediately.\n        const tiles = this._requestsPerUser.get(user);\n        if (undefined !== tiles) {\n            for (const tile of tiles) {\n                const request = tile.request;\n                if (undefined !== request && 1 === request.users.length)\n                    request.cancel();\n            }\n            this._requestsPerUser.delete(user);\n        }\n    }\n    onIModelClosed(iModel) {\n        this._requestsPerUser.forEach((_req, user) => {\n            if (user.iModel === iModel)\n                this.onUserIModelClosed(user);\n        });\n        // Remove any TileTreeProps requests associated with this iModel.\n        this._tileTreePropsRequests = this._tileTreePropsRequests.filter((req) => {\n            if (req.iModel !== iModel)\n                return true;\n            req.abandon();\n            return false;\n        });\n        // Dispatch TileTreeProps requests not associated with this iModel.\n        this.dispatchTileTreePropsRequests();\n        this.channels.onIModelClosed(iModel);\n    }\n    initializeRpc() {\n        // Would prefer to do this in constructor - but nothing enforces that the app initializes the rpc interfaces before it creates the TileAdmin (via IModelApp.startup()) - so do it on first request instead.\n        if (this._rpcInitialized)\n            return;\n        this._rpcInitialized = true;\n        const retryInterval = this._retryInterval;\n        RpcOperation.lookup(IModelTileRpcInterface, \"requestTileTreeProps\").policy.retryInterval = () => retryInterval;\n        const policy = RpcOperation.lookup(IModelTileRpcInterface, \"generateTileContent\").policy;\n        policy.retryInterval = () => retryInterval;\n        policy.allowResponseCaching = () => RpcResponseCacheControl.Immutable; // eslint-disable-line deprecation/deprecation\n    }\n}\n/** @public */\n(function (TileAdmin) {\n    /** The number of bytes of GPU memory associated with the various [[GpuMemoryLimit]]s for non-mobile devices.\n     * @see [[TileAdmin.Props.gpuMemoryLimits]] to specify the limit at startup.\n     * @see [[TileAdmin.gpuMemoryLimit]] to adjust the actual limit after startup.\n     * @see [[TileAdmin.mobileMemoryLimits]] for mobile devices.\n     */\n    TileAdmin.nonMobileGpuMemoryLimits = {\n        default: 1024 * 1024 * 1024,\n        aggressive: 500 * 1024 * 1024,\n        relaxed: 2.5 * 1024 * 1024 * 1024, // 2.5 GB\n    };\n    /** The number of bytes of GPU memory associated with the various [[GpuMemoryLimit]]s for mobile devices.\n     * @see [[TileAdmin.Props.gpuMemoryLimits]] to specify the limit at startup.\n     * @see [[TileAdmin.gpuMemoryLimit]] to adjust the actual limit after startup.\n     * @see [[TileAdmin.nonMobileMemoryLimits]] for non-mobile devices.\n     */\n    TileAdmin.mobileGpuMemoryLimits = {\n        default: 200 * 1024 * 1024,\n        aggressive: 75 * 1024 * 1024,\n        relaxed: 500 * 1024 * 1024, // 500 MB\n    };\n})(TileAdmin || (TileAdmin = {}));\n/** Some views contain thousands of models. When we open such a view, the first thing we do is request the IModelTileTreeProps for each model. This involves a http request per model,\n * which can exceed the maximum number of simultaneous requests permitted by the browser.\n * Similar to how we throttle requests for tile *content*, we throttle requests for IModelTileTreeProps based on `TileAdmin.Props.maxActiveTileTreePropsRequests`, heretofore referred to as `N`.\n * TileAdmin maintains a FIFO queue of requests for IModelTileTreeProps. The first N of those requests have been dispatched; the remainder are waiting for their turn.\n * When `TileAdmin.requestTileTreeProps` is called, it appends a new request to the queue, and if the queue length < N, dispatches it immediately.\n * When a request completes, throws an error, or is canceled, it is removed from the queue, and any not-yet-dispatched requests are dispatched (not exceeding N total in flight).\n * When an IModelConnection is closed, any requests associated with that iModel are canceled.\n * NOTE: This request queue currently does not interact at all with the tile content request queue.\n * NOTE: We rely on TreeOwner to not request the same IModelTileTreeProps multiple times - we do not check the queue for presence of a requested tree before enqeueing it.\n */\nclass TileTreePropsRequest {\n    constructor(iModel, _treeId, _resolve, _reject) {\n        this.iModel = iModel;\n        this._treeId = _treeId;\n        this._resolve = _resolve;\n        this._reject = _reject;\n        this._isDispatched = false;\n    }\n    get isDispatched() { return this._isDispatched; }\n    dispatch() {\n        if (this.isDispatched)\n            return;\n        this._isDispatched = true;\n        requestTileTreeProps(this.iModel, this._treeId).then((props) => {\n            this.terminate();\n            this._resolve(props);\n        }).catch((err) => {\n            this.terminate();\n            this._reject(err);\n        });\n    }\n    /** The IModelConnection was closed, or IModelApp was shut down. Don't call terminate(), because we don't want to dispatch pending requests as a result.\n     * Just reject if not yet dispatched.\n     */\n    abandon() {\n        if (!this.isDispatched) {\n            // A little white lie that tells the TileTreeOwner it can try to load again later if needed, rather than treating rejection as failure to load.\n            this._reject(new ServerTimeoutError(\"requestTileTreeProps cancelled\"));\n        }\n    }\n    terminate() {\n        IModelApp.tileAdmin.terminateTileTreePropsRequest(this);\n    }\n}\nlet requestTileTreePropsOverride;\nasync function requestTileTreeProps(iModel, treeId) {\n    if (requestTileTreePropsOverride)\n        return requestTileTreePropsOverride(iModel, treeId);\n    return IModelTileRpcInterface.getClient().requestTileTreeProps(iModel.getRpcProps(), treeId);\n}\n/** Strictly for tests - overrides the call to IModelTileRpcInterface.requestTileTreeProps with a custom function, or clears the override.\n * @internal\n */\nexport function overrideRequestTileTreeProps(func) {\n    requestTileTreePropsOverride = func;\n}\n//# sourceMappingURL=TileAdmin.js.map",
      "start": 1693508121566,
      "end": 1693508121665,
      "sourcemaps": null
    }
  ]
}
