{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/orbitgt/lib/esm/spatial/ecrs/projection/TransverseMercator.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module OrbitGT\n */\nimport { OperationMethod } from \"../OperationMethod\";\n/**\n * Class TransverseMercator defines a Transverse Mercator projection.\n *\n * The 'source' CRS is the geographic CRS.\n * The 'target' CRS is the projected CRS.\n *\n * Based on the following document:\n *\n * Coordinate Conversions and Transformations including Formulas\n * Guidance Note Number 7, part 2\n * Revised August 2006\n * Available at: http://www.epsg.org/\n *\n * Formulas: see 1.4.5.1: General Case\n *\n * @version 1.0 January 2007\n */\n/** @internal */\nclass TransverseMercator extends OperationMethod {\n    /**\n       * Create a new projection.\n       * @param parameters the values of the parameters.\n       */\n    constructor(parameters) {\n        super(TransverseMercator.METHOD_CODE, \"Transverse Mercator\", parameters);\n        /* Store the parameters */\n        this._latN = parameters.getValue(8801);\n        this._lonN = parameters.getValue(8802);\n        this._k0 = parameters.getValue(8805);\n        this._fE = parameters.getValue(8806);\n        this._fN = parameters.getValue(8807);\n    }\n    /**\n       * Get the power of a number (must be able to handle negative 'n' values).\n       */\n    static pow(n, e) {\n        let p = 1.0;\n        for (let i = 0; i < e; i++)\n            p *= n;\n        return p;\n    }\n    /**\n       * Calculate M.\n       */\n    calcM(lat) {\n        const M = lat * (1.0 - this._e2 / 4 - 3 * this._e4 / 64 - 5 * this._e6 / 256) - Math.sin(2.0 * lat) * (3 * this._e2 / 8 + 3 * this._e4 / 32 + 45 * this._e6 / 1024) + Math.sin(4.0 * lat) * (15 * this._e4 / 256 + 45 * this._e6 / 1024) - Math.sin(6.0 * lat) * (35 * this._e6 / 3072);\n        return this._a * M;\n    }\n    /**\n       * Initialize the projection.\n       * @param ellipsoid the ellipsoid to use.\n       * @return this projection (for convenience).\n       */\n    initializeProjection(ellipsoid) {\n        /* Prepare the forward parameters */\n        this._a = ellipsoid.getA();\n        this._e = ellipsoid.getE();\n        this._e2 = this._e * this._e;\n        this._e4 = this._e2 * this._e2;\n        this._e6 = this._e2 * this._e4;\n        this._e_2 = this._e2 / (1.0 - this._e2);\n        this._m0 = this.calcM(this._latN);\n        /* Prepare the reverse parameters */\n        const temp = Math.sqrt(1 - this._e2);\n        this._e1 = (1.0 - temp) / (1.0 + temp);\n        const e1_2 = this._e1 * this._e1;\n        const e1_3 = this._e1 * e1_2;\n        const e1_4 = e1_2 * e1_2;\n        this._R1 = (3 * this._e1 / 2 - 27 * e1_3 / 32);\n        this._R2 = (21 * e1_2 / 16 - 55 * e1_4 / 32);\n        this._R3 = (151 * e1_3 / 96);\n        this._R4 = (1097 * e1_4 / 512);\n        /* Return the projection */\n        return this;\n    }\n    /**\n       * Do the projection.\n       * @param lon the longitude (radians).\n       * @param lat the latitude (radians).\n       * @param projected the target projected coordinate (X and Y will be set).\n       */\n    toProjection(lon, lat, projected) {\n        /* Calculate parameters */\n        const tan = Math.tan(lat);\n        const T = tan * tan;\n        const cos = Math.cos(lat);\n        const C = this._e2 * cos * cos / (1.0 - this._e2);\n        const A = (lon - this._lonN) * cos;\n        const eSin = this._e * Math.sin(lat);\n        const v = this._a / Math.sqrt(1.0 - eSin * eSin);\n        const m = this.calcM(lat);\n        /* Make the calculation */\n        const temp1 = A + (1.0 - T + C) * TransverseMercator.pow(A, 3) / 6 + (5 - 18 * T + T * T + 72 * C - 58 * this._e_2) * TransverseMercator.pow(A, 5) / 120.0;\n        const E = this._fE + this._k0 * v * (temp1);\n        const temp2 = m - this._m0 + v * tan * (A * A / 2 + (5 - T + 9 * C + 4 * C * C) * TransverseMercator.pow(A, 4) / 24.0 + (61 - 58 * T + T * T + 600 * C - 330 * this._e_2) * TransverseMercator.pow(A, 6) / 720.0);\n        const N = this._fN + this._k0 * (temp2);\n        /* Save the position */\n        projected.setX(E);\n        projected.setY(N);\n    }\n    /**\n       * Do the inverse projection.\n       * @param x the easting.\n       * @param y the northing.\n       * @param geographic the target geographic coordinate (X/Lon and Y/Lat will be set) (radians).\n       */\n    toGeoGraphic(x, y, geographic) {\n        /* Get the parameters */\n        const E = x;\n        const N = y;\n        /* Calculate parameters */\n        const m1 = this._m0 + (N - this._fN) / this._k0;\n        const u1 = m1 / (this._a * (1.0 - this._e2 / 4 - 3 * this._e4 / 64 - 5 * this._e6 / 256));\n        const lat1 = u1 + this._R1 * Math.sin(2 * u1) + this._R2 * Math.sin(4 * u1) + this._R3 * Math.sin(6 * u1) + this._R4 * Math.sin(8 * u1);\n        const eSin1 = this._e * Math.sin(lat1);\n        const temp = Math.sqrt(1.0 - eSin1 * eSin1);\n        const v1 = this._a / temp;\n        const rho1 = this._a * (1.0 - this._e2) / TransverseMercator.pow(temp, 3);\n        const tan = Math.tan(lat1);\n        const T1 = tan * tan;\n        const T1_2 = T1 * T1;\n        const cos = Math.cos(lat1);\n        const C1 = this._e_2 * cos * cos;\n        const C1_2 = C1 * C1;\n        const D = (E - this._fE) / (v1 * this._k0);\n        const D_2 = D * D;\n        /* Make the calculation */\n        const temp1 = D_2 / 2 - (5 + 3 * T1 + 10 * C1 - 4 * C1_2 - 9 * this._e_2) * TransverseMercator.pow(D, 4) / 24.0 + (61 + 90 * T1 + 298 * C1 + 45 * T1_2 - 252 * this._e_2 - 3 * C1_2) * TransverseMercator.pow(D, 6) / 720.0;\n        const lat = lat1 - (v1 * tan / rho1) * (temp1);\n        const temp2 = D - (1 + 2 * T1 + C1) * TransverseMercator.pow(D, 3) / 6 + (5 - 2 * C1 + 28 * T1 - 3 * C1_2 + 8 * this._e_2 + 24 * T1_2) * TransverseMercator.pow(D, 5) / 120;\n        const lon = this._lonN + (temp2) / cos;\n        /* Save the position */\n        geographic.setX(lon);\n        geographic.setY(lat);\n    }\n    /**\n       * OperationMethod method.\n       * @see OperationMethod#initialize\n       */\n    initialize(operation) {\n        this.initializeProjection(operation.getSourceCRS().getEllipsoid()); // should this use getTargetCRS? (while testing OSTN15 RoI)\n    }\n    /**\n       * OperationMethod interface method.\n       * @see OperationMethod#forward\n       */\n    forward(sourceCRS, source, targetCRS, target) {\n        /* Get the parameters */\n        const lon = source.getX();\n        const lat = source.getY();\n        /* Do the projection */\n        this.toProjection(lon, lat, target);\n        target.setZ(source.getZ()); // Copy the Z value\n    }\n    /**\n       * OperationMethod interface method.\n       * @see OperationMethod#reverse\n       */\n    reverse(sourceCRS, source, targetCRS, target) {\n        /* Get the parameters */\n        const E = target.getX();\n        const N = target.getY();\n        /* Do the inverse projection */\n        this.toGeoGraphic(E, N, source);\n        source.setZ(target.getZ()); // Copy the Z value\n    }\n}\n/** The code of this method */\nTransverseMercator.METHOD_CODE = 9807;\n/** The value of PI */\nTransverseMercator.PI = Math.PI;\nexport { TransverseMercator };\n//# sourceMappingURL=TransverseMercator.js.map",
      "start": 1693508125638,
      "end": 1693508125684,
      "sourcemaps": null
    }
  ]
}
