{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/hypermodeling/lib/esm/SectionMarkers.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module HyperModeling\n */\nimport { assert, BeEvent } from \"@itwin/core-bentley\";\nimport { Point2d, Point3d } from \"@itwin/core-geometry\";\nimport { IModelReadRpcInterface } from \"@itwin/core-common\";\nimport { BeButton, IModelApp, InputSource, Marker, MarkerSet, ViewClipTool, } from \"@itwin/core-frontend\";\nimport { HyperModeling } from \"./HyperModeling\";\nconst markerSize = Point2d.create(40, 40);\n/** A [Marker]($frontend) associated with a [[SectionDrawingLocationState]], displayed as a canvas decoration at the location of the section.\n * Clicking on the marker toggles display of the section graphics. Mousing over the marker produces a toolbar with additional interactions.\n * @see [[HyperModelingDecorator]] for a [Decorator]($frontend) capable of displaying section markers for each section drawing location.\n * @see [[SectionMarkerHandler]] to customize the marker interactions.\n * @public\n */\nexport class SectionMarker extends Marker {\n    /** Constructor, typically invoked indirectly via [[HyperModelingDecorator]].\n     * @param state The section drawing location state this marker will represent.\n     * @param pos The world coordinates at which to display the marker.\n     * @param description A brief description of this marker, used as part of the tooltip when this marker is part of a cluster.\n     * @param icon The icon displayed by the marker.\n     * @param tooltip Optional detailed tooltip displayed on mouse hover. If undefined, the `description` is used instead.\n     */\n    constructor(state) {\n        super(state.placement.origin.clone(), markerSize);\n        /** @internal */\n        this.onMouseEnterEvent = new BeEvent();\n        /** @internal */\n        this.onMouseButtonEvent = new BeEvent();\n        /** @internal */\n        this._isActive = false;\n        this.state = state;\n        const data = HyperModeling.getMarkerData(state.sectionType);\n        this.description = data.label;\n        if (data.image)\n            this.setImage(data.image);\n        this.setScaleFactor({ low: .2, high: 1.4 }); // make size 20% at back of frustum and 140% at front of frustum (if camera is on)\n    }\n    /** @internal */\n    get isHilited() { return this._isHilited; }\n    /** Returns true if this is the \"active\" section marker. At most one marker is active at a given time.\n     * @see [[HyperModelingDecorator.activeMarker]].\n     * @see [[HyperModelingDecorator.setActiveMarker]].\n     * @see [[SectionMarkerHandler.toggleMarker]].\n     */\n    get isActive() {\n        return this._isActive;\n    }\n    /** @internal */\n    setActive(active) {\n        this._isActive = active;\n    }\n    /** @internal */\n    drawActive(ctx) {\n        ctx.shadowBlur = 30;\n        ctx.shadowColor = \"gold\";\n        return false;\n    }\n    /** @internal */\n    drawDecoration(ctx) {\n        if (!this.isActive || !this.drawActive(ctx))\n            super.drawDecoration(ctx);\n    }\n    /** @internal */\n    onMouseEnter(ev) {\n        // Lazily load the tooltip.\n        if (undefined === this.title) {\n            IModelReadRpcInterface.getClientForRouting(this.state.iModel.routingContext.token).getToolTipMessage(this.state.iModel.getRpcProps(), this.state.id).then((tooltipMsg) => {\n                this.title = IModelApp.formatElementToolTip(tooltipMsg);\n            }).catch((_) => {\n                this.title = this.description;\n            });\n        }\n        super.onMouseEnter(ev);\n        this.onMouseEnterEvent.raiseEvent(this);\n    }\n    /** @internal */\n    onMouseButton(ev) {\n        if (InputSource.Mouse === ev.inputSource && BeButton.Data === ev.button && ev.isDown && ev.viewport)\n            this.onMouseButtonEvent.raiseEvent(this);\n        return true; // Don't allow clicks to be sent to active tool...\n    }\n    /** @internal */\n    addMarker(context) {\n        super.addMarker(context);\n        if (this.isHilited)\n            ViewClipTool.drawClip(context, this.state.clip, undefined, { fillClipPlanes: true, hasPrimaryPlane: true });\n    }\n}\n/** A Marker used to show a cluster of section locations.\n * @internal\n */\nexport class SectionMarkerCluster extends Marker {\n    /** Create a new cluster marker */\n    constructor(location, size, cluster, image) {\n        super(location, size);\n        this.imageOffset = new Point3d(0, 30);\n        this.label = cluster.markers.length.toLocaleString();\n        this.labelColor = \"black\";\n        this.labelFont = \"bold 14px sans-serif\";\n        const maxLen = 10;\n        let title = \"\";\n        cluster.markers.forEach((marker, index) => {\n            if (index < maxLen) {\n                if (title !== \"\")\n                    title += \"<br>\";\n                title += marker.description;\n            }\n        });\n        if (cluster.markers.length > maxLen)\n            title += \"<br>...\";\n        const div = document.createElement(\"div\");\n        div.innerHTML = title;\n        this.title = div;\n        if (image)\n            this.setImage(image);\n    }\n    /** Show the cluster as a white circle with an outline */\n    drawFunc(ctx) {\n        ctx.beginPath();\n        ctx.strokeStyle = \"#372528\";\n        ctx.fillStyle = \"white\";\n        ctx.lineWidth = 5;\n        ctx.arc(0, 0, 13, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.stroke();\n    }\n    onMouseButton(_ev) { return true; } // Don't allow clicks to be sent to active tool...\n}\n/** A [MarkerSet]($frontend) containing [[SectionMarker]]s identifying [SectionDrawingLocation]($backend)s within a spatial view.\n * Typically used indirectly via [[HyperModelingDecorator]].\n * @public\n */\nexport class SectionMarkerSet extends MarkerSet {\n    /** Constructor\n     * @param viewport The viewport in which the markers are to be displayed.\n     * @param markers The markers to be displayed.\n     * @note Each marker's [[SectionDrawingLocationState]] must be associated with the same [IModelConnection]($frontend) as the viewport; any markers from other iModels will be omitted.\n     */\n    constructor(viewport, markers) {\n        super(viewport);\n        this.minimumClusterSize = 5;\n        for (const marker of markers) {\n            if (marker.state.iModel === viewport.iModel)\n                this.markers.add(marker);\n        }\n    }\n    /** The viewport in which the markers are to be displayed. */\n    get viewport() {\n        assert(undefined !== super.viewport);\n        return super.viewport;\n    }\n    /** @internal */\n    getClusterMarker(cluster) {\n        return new SectionMarkerCluster(cluster.getClusterLocation(), cluster.markers[0].size, cluster, cluster.markers[0].image);\n    }\n    /** Find the SectionMarker corresponding to the specified [SectionDrawingLocation]($backend) Id. */\n    findMarkerById(sectionDrawingLocationId) {\n        for (const marker of this.markers)\n            if (marker.state.id === sectionDrawingLocationId)\n                return marker;\n        return undefined;\n    }\n}\n//# sourceMappingURL=SectionMarkers.js.map",
      "start": 1693508120977,
      "end": 1693508121057,
      "sourcemaps": null
    }
  ]
}
