{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tile/map/MapTileAvailability.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tiles\n */\nimport { Cartographic } from \"@itwin/core-common\";\nimport { MapCartoRectangle } from \"../internal\";\nimport { SortedArray } from \"@itwin/core-bentley\";\n// portions adapted from Cesium.js Copyright 2011 - 2017 Cesium Contributors\n/** @internal */\nclass RectangleWithLevel extends MapCartoRectangle {\n    constructor(level, west, south, east, north) {\n        super(west, south, east, north);\n        this.level = level;\n    }\n}\n/** @internal */\nclass QuadTreeNode {\n    constructor(tilingScheme, parent, level, x, y) {\n        this.tilingScheme = tilingScheme;\n        this.parent = parent;\n        this.level = level;\n        this.x = x;\n        this.y = y;\n        this.rectangles = new SortedArray((lhs, rhs) => lhs.level - rhs.level, true);\n        this.extent = tilingScheme.tileXYToRectangle(x, y, level + 1);\n    }\n    get nw() {\n        if (!this.nwNode)\n            this.nwNode = new QuadTreeNode(this.tilingScheme, this, this.level + 1, this.x * 2, this.y * 2);\n        return this.nwNode;\n    }\n    get ne() {\n        if (!this.neNode)\n            this.neNode = new QuadTreeNode(this.tilingScheme, this, this.level + 1, this.x * 2 + 1, this.y * 2);\n        return this.neNode;\n    }\n    get sw() {\n        if (!this.swNode)\n            this.swNode = new QuadTreeNode(this.tilingScheme, this, this.level + 1, this.x * 2, this.y * 2 + 1);\n        return this.swNode;\n    }\n    get se() {\n        if (!this.seNode)\n            this.seNode = new QuadTreeNode(this.tilingScheme, this, this.level + 1, this.x * 2 + 1, this.y * 2 + 1);\n        return this.seNode;\n    }\n}\n/** @internal */\nfunction putRectangleInQuadtree(maxDepth, node, rectangle) {\n    while (node.level < maxDepth) {\n        if (node.nw.extent.containsRange(rectangle)) {\n            node = node.nw;\n        }\n        else if (node.ne.extent.containsRange(rectangle)) {\n            node = node.ne;\n        }\n        else if (node.sw.extent.containsRange(rectangle)) {\n            node = node.sw;\n        }\n        else if (node.se.extent.containsRange(rectangle)) {\n            node = node.se;\n        }\n        else {\n            break;\n        }\n    }\n    node.rectangles.insert(rectangle);\n}\n/** @internal */\nclass TileAvailability {\n    constructor(_tilingScheme, _maximumLevel) {\n        this._tilingScheme = _tilingScheme;\n        this._maximumLevel = _maximumLevel;\n        this._rootNodes = new Array();\n        this._cartographicScratch = Cartographic.createZero();\n    }\n    findNode(level, x, y, nodes) {\n        for (const node of nodes) {\n            if (node.x === x && node.y === y && node.level === level) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Marks a rectangular range of tiles in a particular level as being available.  For best performance,\n     * add your ranges in order of increasing level.\n     *\n     * @param {Number} level The level.\n     * @param {Number} startX The X coordinate of the first available tiles at the level.\n     * @param {Number} startY The Y coordinate of the first available tiles at the level.\n     * @param {Number} endX The X coordinate of the last available tiles at the level.\n     * @param {Number} endY The Y coordinate of the last available tiles at the level.\n     */\n    addAvailableTileRange(level, startX, startY, endX, endY) {\n        const tilingScheme = this._tilingScheme;\n        const rootNodes = this._rootNodes;\n        if (level === 0) {\n            for (let y = startY; y <= endY; ++y) {\n                for (let x = startX; x <= endX; ++x) {\n                    if (!this.findNode(level, x, y, rootNodes)) {\n                        rootNodes.push(new QuadTreeNode(tilingScheme, undefined, 0, x, y));\n                    }\n                }\n            }\n        }\n        tilingScheme.tileXYToRectangle(startX, startY, level + 1, TileAvailability.rectangleScratch);\n        const west = TileAvailability.rectangleScratch.west;\n        const south = TileAvailability.rectangleScratch.south;\n        tilingScheme.tileXYToRectangle(endX, endY, level + 1, TileAvailability.rectangleScratch);\n        const east = TileAvailability.rectangleScratch.east;\n        const north = TileAvailability.rectangleScratch.north;\n        const rectangleWithLevel = new RectangleWithLevel(level, west, south, east, north);\n        for (const rootNode of rootNodes) {\n            if (rootNode.extent.intersectsRange(rectangleWithLevel)) {\n                putRectangleInQuadtree(this._maximumLevel, rootNode, rectangleWithLevel);\n            }\n        }\n    }\n    computeMaximumLevelAtPosition(position) {\n        // Find the root node that contains this position.\n        let node;\n        for (const rootNode of this._rootNodes) {\n            if (rootNode.extent.containsCartographic(position)) {\n                node = rootNode;\n                break;\n            }\n        }\n        if (undefined === node) {\n            return -1;\n        }\n        return this.findMaxLevelFromNode(undefined, node, position);\n    }\n    /**\n     * Determines if a particular tile is available.\n     * @param {Number} level The tile level to check.\n     * @param {Number} x The X coordinate of the tile to check.\n     * @param {Number} y The Y coordinate of the tile to check.\n     * @return {Boolean} True if the tile is available; otherwise, false.\n     */\n    isTileAvailable(level, x, y) {\n        // Get the center of the tile and find the maximum level at that position.\n        // Because availability is by tile, if the level is available at that point, it\n        // is sure to be available for the whole tile.  We assume that if a tile at level n exists,\n        // then all its parent tiles back to level 0 exist too.  This isn't really enforced\n        // anywhere, but Cesium would never load a tile for which this is not true.\n        const rectangle = this._tilingScheme.tileXYToRectangle(x, y, level + 1, TileAvailability.rectangleScratch);\n        rectangle.getCenter(this._cartographicScratch);\n        return this.computeMaximumLevelAtPosition(this._cartographicScratch) >= level;\n    }\n    findMaxLevelFromNode(stopNode, node, position) {\n        let maxLevel = 0;\n        // Find the deepest quadtree node containing this point.\n        let found = false;\n        while (!found && node !== undefined) {\n            const nw = node.nwNode && node.nwNode.extent.containsCartographic(position);\n            const ne = node.neNode && node.neNode.extent.containsCartographic(position);\n            const sw = node.swNode && node.swNode.extent.containsCartographic(position);\n            const se = node.seNode && node.seNode.extent.containsCartographic(position);\n            // The common scenario is that the point is in only one quadrant and we can simply\n            // iterate down the tree.  But if the point is on a boundary between tiles, it is\n            // in multiple tiles and we need to check all of them, so use recursion.\n            if ((nw ? 1 : 0) + (ne ? 1 : 0) + (sw ? 1 : 0) + (se ? 1 : 0) > 1) {\n                if (nw) {\n                    maxLevel = Math.max(maxLevel, this.findMaxLevelFromNode(node, node.nwNode, position));\n                }\n                if (ne) {\n                    maxLevel = Math.max(maxLevel, this.findMaxLevelFromNode(node, node.neNode, position));\n                }\n                if (sw) {\n                    maxLevel = Math.max(maxLevel, this.findMaxLevelFromNode(node, node.swNode, position));\n                }\n                if (se) {\n                    maxLevel = Math.max(maxLevel, this.findMaxLevelFromNode(node, node.seNode, position));\n                }\n                break;\n            }\n            else if (nw) {\n                node = node.nwNode;\n            }\n            else if (ne) {\n                node = node.neNode;\n            }\n            else if (sw) {\n                node = node.swNode;\n            }\n            else if (se) {\n                node = node.seNode;\n            }\n            else {\n                found = true;\n            }\n        }\n        // Work up the tree until we find a rectangle that contains this point.\n        while (node !== stopNode) {\n            const rectangles = node.rectangles;\n            // Rectangles are sorted by level, lowest first.\n            for (let i = rectangles.length - 1; i >= 0 && rectangles.get(i).level > maxLevel; --i) {\n                const rectangle = rectangles.get(i);\n                if (rectangle.containsCartographic(position))\n                    maxLevel = rectangle.level;\n            }\n            node = node.parent;\n        }\n        return maxLevel;\n    }\n}\nTileAvailability.rectangleScratch = MapCartoRectangle.createMaximum();\nexport { TileAvailability };\n//# sourceMappingURL=MapTileAvailability.js.map",
      "start": 1693508121882,
      "end": 1693508122022,
      "sourcemaps": null
    }
  ]
}
