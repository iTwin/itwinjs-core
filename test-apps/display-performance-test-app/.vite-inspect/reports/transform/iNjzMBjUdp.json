{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/orbitgt/lib/esm/pointcloud/model/PointCloudReader.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module OrbitGT\n */\nimport { ALong } from \"../../system/runtime/ALong\";\n/**\n * Abstract class PointCloudReader allows reading of blocks, tiles and points from pointcloud files using the two-step content loader technique.\n *\n * Point cloud access often results in many requests for small parts of the point cloud file. To avoid making too many requests a content loader can be used.\n *\n * Create a new content loader and call the needed methods to gather the file ranges to fetch from storage, ignoring the method results.\n * Then await the content loader request to load all needed data and wait for the results.\n * Then call the needed method again, they will have access to the data and return the right results.\n * This technique allows a single fetch request from storage to return multiple small file content ranges.\n *\n * @version 1.0 March 2016\n */\n/** @internal */\nexport class PointCloudReader {\n    /**\n     * Create a new reader.\n     */\n    constructor() {\n    }\n    /**\n     * Close the reader.\n     */\n    close() {\n    }\n    /**\n     * Get a certain property of the reader.\n     * @return the value (null if not defined).\n     */\n    getProperty(propertyName) {\n        return null;\n    }\n    /**\n     * Get the storage of the file.\n     * @return the storage of the file.\n     */\n    getFileStorage() {\n        return null;\n    }\n    /**\n     * Get the name of the file.\n     * @return the name of the file.\n     */\n    getFileName() {\n        return null;\n    }\n    /**\n     * Get the CRS of the file.\n     * @return the CRS of the file.\n     */\n    getFileCRS() {\n        return null;\n    }\n    /**\n     * Get the spatial bounds of the file.\n     * @return the spatial bounds of the file.\n     */\n    getFileBounds() {\n        return null;\n    }\n    /**\n     * Get the attributes of the points.\n     * @return the attributes of the points.\n     */\n    getPointAttributes() {\n        return null;\n    }\n    /**\n     * Get the minimum value of an attribute.\n     * @param attribute the attribute.\n     * @return the minimum value (null if unknown).\n     */\n    getMinAttributeValue(attribute) {\n        return null;\n    }\n    /**\n     * Get the maximum value of an attribute.\n     * @param attribute the attribute.\n     * @return the maximum value (null if unknown).\n     */\n    getMaxAttributeValue(attribute) {\n        return null;\n    }\n    /**\n     * Get the number of levels.\n     * @return the number of levels.\n     */\n    getLevelCount() {\n        return 0;\n    }\n    /**\n     * Get the number of points.\n     * @param level the index of the level.\n     * @return the number of points.\n     */\n    getLevelPointCount(level) {\n        return ALong.ZERO;\n    }\n    /**\n     * Get the bounds of points.\n     * @param level the index of the level.\n     * @return the bounds of points.\n     */\n    getLevelPointBounds(level) {\n        return null;\n    }\n    /**\n     * Get the block grid.\n     * @param level the index of the level.\n     * @return the block grid (null if there is no spatial grid).\n     */\n    getLevelBlockGrid(level) {\n        return null;\n    }\n    /**\n     * Get the tile grid.\n     * @param level the index of the level.\n     * @return the tile grid (null if there is no spatial grid).\n     */\n    getLevelTileGrid(level) {\n        return null;\n    }\n    /**\n     * Peek at block indexes.\n     * @param level the index of the level.\n     * @return the block indexes (zero length if the level has not yet been accessed in case of lazy loading).\n     */\n    peekBlockIndexes(level) {\n        return null;\n    }\n    /**\n     * Read block indexes (with a 2-step file content fetching sequence).\n     * @param level the index of the level.\n     * @param fileContents the file contents.\n     * @return the tile indexes.\n     */\n    readBlockIndexes(level, fileContents) {\n        return null;\n    }\n    /**\n     * Read tile indexes (with a 2-step file content fetching sequence).\n     * @param block the index of the block.\n     * @param fileContents the file contents.\n     * @return the tile indexes.\n     */\n    readTileIndexes(block, fileContents) {\n        return null;\n    }\n    /**\n     * Read the points of a tile (with a 2-step file content fetching sequence).\n     * @param tileIndex the tile index.\n     * @param parameters the read parameters (contains the result read statistics).\n     * @param fileContents the file contents.\n     * @param processor the point processor.\n     */\n    readPoints(tileIndex, parameters, fileContents) {\n        return null;\n    }\n    /**\n     * Read the points of a tile (with a 2-step file content fetching sequence).\n     * @param tileIndex the tile index.\n     * @param dataFormat the data format.\n     * @param accessTime the current access time.\n     * @param fileContents the file contents.\n     */\n    readPointData(tileIndex, dataFormat, accessTime, fileContents) {\n        return null;\n    }\n    /**\n     * Clip the reader to a certain range of levels.\n     * @param levelOffset the index of the first level.\n     * @param levelCount the number of levels.\n     * @return the clipped pointcloud.\n     */\n    clipToLevelRange(levelOffset, levelCount) {\n        return null;\n    }\n}\n//# sourceMappingURL=PointCloudReader.js.map",
      "start": 1693508124857,
      "end": 1693508124959,
      "sourcemaps": null
    }
  ]
}
