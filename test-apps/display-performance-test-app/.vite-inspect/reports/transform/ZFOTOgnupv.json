{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/geometry3d/Ray2d.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module CartesianGeometry\n */\nimport { Geometry } from \"../Geometry\";\n// cspell:word CCWXY, CWXY\n/**\n * Ray with xy origin and direction\n * @public\n */\nexport class Ray2d {\n    constructor(origin, direction) {\n        this._origin = origin;\n        this._direction = direction;\n    }\n    /** Copy coordinates from origin and direction. */\n    set(origin, direction) {\n        this._origin.setFrom(origin);\n        this._direction.setFrom(direction);\n    }\n    /**\n     * Create from `origin` and `target` points.\n     * @param origin ray origin, cloned\n     * @param target end of ray direction vector. The direction vector is `target - origin`.\n     * @param result optional pre-allocated object to return\n     */\n    static createOriginAndTarget(origin, target, result) {\n        if (result) {\n            result._origin.setFrom(origin);\n            result._direction.set(target.x - origin.x, target.y - origin.y);\n            return result;\n        }\n        return new Ray2d(origin.clone(), origin.vectorTo(target));\n    }\n    /**\n     * Create by copying coordinates from `origin` and `direction`.\n     * @param origin ray origin\n     * @param direction ray direction\n     * @param result optional pre-allocated object to return\n     */\n    static createOriginAndDirection(origin, direction, result) {\n        if (result) {\n            result.set(origin, direction);\n            return result;\n        }\n        return new Ray2d(origin.clone(), direction.clone());\n    }\n    /** Create from captured `origin` and `direction`. */\n    static createOriginAndDirectionCapture(origin, direction, result) {\n        if (result) {\n            result._origin = origin;\n            result._direction = direction;\n            return result;\n        }\n        return new Ray2d(origin, direction);\n    }\n    /** Get the reference to the ray origin. */\n    get origin() { return this._origin; }\n    /** Get the reference to the ray direction. */\n    get direction() { return this._direction; }\n    /**\n     * Return a parallel ray to the left of this ray.\n     * @param leftFraction distance between rays, as a fraction of the magnitude of this ray's direction vector\n     */\n    parallelRay(leftFraction, result) {\n        if (result) {\n            this._origin.addForwardLeft(0.0, leftFraction, this._direction, result._origin);\n            result._direction.setFrom(this._direction);\n            return result;\n        }\n        return new Ray2d(this._origin.addForwardLeft(0.0, leftFraction, this._direction), this._direction.clone());\n    }\n    /** Return a ray with cloned origin and with direction rotated 90 degrees counterclockwise */\n    ccwPerpendicularRay(result) {\n        if (result) {\n            result._origin.setFrom(this._origin);\n            this._direction.rotate90CCWXY(result._direction);\n            return result;\n        }\n        return new Ray2d(this._origin.clone(), this._direction.rotate90CCWXY());\n    }\n    /** Return a ray with cloned origin and with direction rotated 90 degrees clockwise */\n    cwPerpendicularRay(result) {\n        if (result) {\n            result._origin.setFrom(this._origin);\n            this._direction.rotate90CWXY(result._direction);\n            return result;\n        }\n        return new Ray2d(this._origin.clone(), this._direction.rotate90CWXY());\n    }\n    /**\n     * Normalize the direction vector in place.\n     * @param defaultX value to set `this.direction.x` if normalization fails. Default value 1.\n     * @param defaultY value to set `this.direction.y` if normalization fails. Default value 0.\n     * @returns whether normalization succeeded (i.e., direction is nonzero)\n     */\n    normalizeDirectionInPlace(defaultX = 1, defaultY = 0) {\n        if (this._direction.normalize(this._direction))\n            return true;\n        this._direction.x = defaultX;\n        this._direction.y = defaultY;\n        return false;\n    }\n    /**\n     * Intersect this ray with the unbounded line defined by the given points.\n     * @param linePointA start of the line\n     * @param linePointB end of the line\n     * @returns object with named values:\n     * * `hasIntersection`: whether the intersection exists.\n     * * `fraction`: ray parameter of intersection, or 0.0 if `!hasIntersection`. If the instance is normalized, this is the signed distance along the ray to the intersection point.\n     * * `cross`: the 2D cross product `this.direction x (linePointB - linePointA)`, useful for determining orientation of the line and ray.\n     */\n    intersectUnboundedLine(linePointA, linePointB) {\n        const lineDirection = linePointA.vectorTo(linePointB);\n        const vector0 = linePointA.vectorTo(this._origin);\n        const h0 = vector0.crossProduct(lineDirection);\n        const dHds = this._direction.crossProduct(lineDirection);\n        // h = h0 + s * dh\n        const ff = Geometry.conditionalDivideFraction(-h0, dHds);\n        const hasIntersection = ff !== undefined;\n        return { hasIntersection, fraction: hasIntersection ? ff : 0.0, cross: dHds };\n    }\n    /** Return the ray fraction where the given point projects onto the ray. */\n    projectionFraction(point) {\n        return this._origin.vectorTo(point).fractionOfProjectionToVector(this._direction);\n    }\n    /** Return the ray fraction where the given point projects onto the perpendicular ray. */\n    perpendicularProjectionFraction(point) {\n        const uv = this._direction.crossProduct(this._origin.vectorTo(point));\n        const uu = this._direction.magnitudeSquared();\n        // Want zero returned if failure case, not undefined\n        return Geometry.safeDivideFraction(uv, uu, 0.0);\n    }\n    /** Compute and return origin plus scaled direction. */\n    fractionToPoint(f, result) {\n        return this._origin.plusScaled(this._direction, f, result);\n    }\n}\n//# sourceMappingURL=Ray2d.js.map",
      "start": 1693508122405,
      "end": 1693508122546,
      "sourcemaps": null
    }
  ]
}
