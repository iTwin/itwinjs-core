{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tile/DynamicIModelTile.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tiles\n */\nimport { assert, ByteStream, compareStrings, DbOpcode, Id64, partitionArray, SortedArray, } from \"@itwin/core-bentley\";\nimport { Range3d } from \"@itwin/core-geometry\";\nimport { TileFormat, } from \"@itwin/core-common\";\nimport { IModelApp } from \"../IModelApp\";\nimport { ImdlReader, IModelTileTree, Tile, } from \"./internal\";\n/** The root tile for the branch of an [[IModelTileTree]] containing graphics for elements that have been modified during the current\n * Not intended for direct consumption - exported for use by [[IModelTileTree]].\n * [[GraphicalEditingScope]].\n * @internal\n */\nexport class DynamicIModelTile extends Tile {\n    constructor(params, tree) {\n        super(params, tree);\n    }\n    static create(root, elements) {\n        return new RootTile(root, elements);\n    }\n}\n/** The child tiles of the root tile, representing inserted or modified elements and sorted by element Id. */\nclass ElementTiles extends SortedArray {\n    constructor() {\n        super((lhs, rhs) => compareStrings(lhs.contentId, rhs.contentId));\n    }\n    get array() {\n        return this._array;\n    }\n}\n/** The root tile. Each of its children represent a newly-inserted or modified element. */\nclass RootTile extends DynamicIModelTile {\n    get _imodelRoot() { return this.parent; }\n    get _elementChildren() {\n        assert(undefined !== this.children);\n        assert(this.children === this._elements.array);\n        return this._elements.array;\n    }\n    constructor(parent, elements) {\n        const params = {\n            parent,\n            isLeaf: false,\n            contentId: \"dynamic\",\n            range: Range3d.createNull(),\n            maximumSize: parent.tileScreenSize,\n        };\n        super(params, parent.tree);\n        this._hiddenElements = new Id64.Uint32Set();\n        const inverseTransform = parent.tree.iModelTransform.inverse();\n        assert(undefined !== inverseTransform);\n        this.transformToTree = inverseTransform;\n        this._elements = new ElementTiles();\n        this.loadChildren(); // initially empty.\n        assert(undefined !== this.children);\n        this.setIsReady();\n        this.handleGeometryChanges(elements);\n    }\n    get hiddenElements() {\n        return this._hiddenElements.toId64Array();\n    }\n    get appearanceProvider() {\n        return this;\n    }\n    getFeatureAppearance(source, elemLo, elemHi, subcatLo, subcatHi, geomClass, modelLo, modelHi, type, animationNodeId) {\n        if (this._hiddenElements.has(elemLo, elemHi))\n            return undefined;\n        return source.getAppearance(elemLo, elemHi, subcatLo, subcatHi, geomClass, modelLo, modelHi, type, animationNodeId);\n    }\n    handleGeometryChanges(changes) {\n        assert(undefined !== this.children);\n        for (const change of changes) {\n            if (change.type !== DbOpcode.Insert)\n                this._hiddenElements.addId(change.id);\n            let tile = this._elements.findEquivalent((t) => compareStrings(t.contentId, change.id));\n            if (change.type === DbOpcode.Delete) {\n                if (tile) {\n                    tile.dispose();\n                    this._elements.remove(tile);\n                }\n            }\n            else {\n                const range = change.range.isNull ? change.range.clone() : this.transformToTree.multiplyRange(change.range);\n                if (tile)\n                    tile.update(range);\n                else\n                    this._elements.insert(tile = new ElementTile(this, change.id, range));\n            }\n        }\n        // Recompute range.\n        this.range.setNull();\n        for (const element of this._elements)\n            this.range.extendRange(element.range);\n        this._imodelRoot.updateDynamicRange(this);\n    }\n    _loadChildren(resolve, _reject) {\n        // This is invoked from constructor. We will add a child per element later - for now just mark the children as having been loaded.\n        resolve(this._elements.array);\n    }\n    get channel() {\n        throw new Error(\"Root dynamic tile has no content\");\n    }\n    async requestContent() {\n        assert(false, \"Root dynamic tile has no content\");\n        return undefined;\n    }\n    async readContent(_data, _system, _isCanceled) {\n        throw new Error(\"Root dynamic tile has no content\");\n    }\n    selectTiles(selected, args) {\n        for (const child of this._elementChildren)\n            child.selectTiles(selected, args);\n    }\n    pruneChildren(olderThan) {\n        // Never discard ElementTiles - do discard not-recently-used graphics.\n        for (const child of this._elementChildren)\n            child.pruneChildren(olderThan);\n    }\n}\n/** Represents a single element that has been inserted or had its geometric properties modified during the current [[GraphicalEditingScope]].\n * It has no graphics of its own; it has any number of child tiles, each of which have graphics of a different level of detail.\n * Its contentId is the element's Id.\n */\nclass ElementTile extends Tile {\n    constructor(parent, elementId, range) {\n        super({\n            parent,\n            isLeaf: false,\n            contentId: elementId,\n            range,\n            maximumSize: parent.maximumSize,\n        }, parent.tree);\n        this.loadChildren();\n        this.setIsReady();\n    }\n    _loadChildren(resolve, _reject) {\n        // Invoked from constructor. We'll add child tiles later as needed.\n        resolve([]);\n    }\n    get channel() {\n        throw new Error(\"ElementTile has no content\");\n    }\n    async requestContent(_isCanceled) {\n        assert(false, \"ElementTile has no content\");\n        return undefined;\n    }\n    async readContent(_data, _system, _isCanceled) {\n        throw new Error(\"ElementTile has no content\");\n    }\n    pruneChildren(olderThan) {\n        const children = this.children;\n        assert(undefined !== children);\n        const partitionIndex = partitionArray(children, (child) => !child.usageMarker.isExpired(olderThan));\n        // Remove expired children.\n        if (partitionIndex < children.length) {\n            const expired = children.splice(partitionIndex);\n            for (const child of expired)\n                child.dispose();\n        }\n        // Restore ordering.\n        children.sort((x, y) => y.toleranceLog10 - x.toleranceLog10);\n    }\n    selectTiles(selected, args) {\n        assert(undefined !== this.children);\n        if (this.isRegionCulled(args))\n            return;\n        args.markUsed(this);\n        // ###TODO: Test content range culled.\n        // Compute the ideal chord tolerance.\n        assert(this.maximumSize > 0);\n        const pixelSize = args.getPixelSizeInMetersAtClosestPoint(this);\n        assert(pixelSize > 0);\n        // Round down to the nearest power of ten.\n        const toleranceLog10 = Math.floor(Math.log10(pixelSize));\n        // Find (or create) a child tile of desired tolerance. Also find a child tile that can be substituted for the desired tile if that tile's content is not yet loaded.\n        // NB: Children are sorted in descending order by log10(tolerance)\n        const children = this.children;\n        let closestMatch;\n        let exactMatch;\n        for (let i = 0; i < children.length; i++) {\n            const child = children[i];\n            const tol = child.toleranceLog10;\n            if (tol > toleranceLog10) {\n                assert(undefined === exactMatch);\n                if (child.hasGraphics)\n                    closestMatch = child;\n            }\n            else if (tol === toleranceLog10) {\n                exactMatch = child;\n            }\n            else if (tol < toleranceLog10) {\n                if (!exactMatch)\n                    children.splice(i++, 0, exactMatch = new GraphicsTile(this, toleranceLog10));\n                if (child.hasGraphics && (!closestMatch || closestMatch.toleranceLog10 > toleranceLog10))\n                    closestMatch = child;\n            }\n        }\n        if (!exactMatch) {\n            assert(children.length === 0 || children[children.length - 1].toleranceLog10 > toleranceLog10);\n            children.push(exactMatch = new GraphicsTile(this, toleranceLog10));\n        }\n        if (!exactMatch.isReady) {\n            args.insertMissing(exactMatch);\n            if (closestMatch) {\n                selected.push(closestMatch);\n                args.markUsed(closestMatch);\n            }\n        }\n        else if (exactMatch.hasGraphics) {\n            selected.push(exactMatch);\n            args.markUsed(exactMatch);\n        }\n    }\n    update(range) {\n        range.clone(this.range);\n        // Discard out-dated graphics.\n        assert(undefined !== this.children);\n        for (const child of this.children)\n            child.dispose();\n        this.children.length = 0;\n    }\n}\nfunction* makeIdSequence() {\n    let current = 0;\n    while (true) {\n        if (current >= Number.MAX_SAFE_INTEGER)\n            current = 0;\n        yield ++current;\n    }\n}\nconst requestIdSequence = makeIdSequence();\n/** Supplies graphics of a specific LOD for a single element. */\nclass GraphicsTile extends Tile {\n    constructor(parent, toleranceLog10) {\n        assert(Math.round(toleranceLog10) === toleranceLog10);\n        super({\n            parent,\n            isLeaf: true,\n            contentId: `${parent.contentId}_${toleranceLog10}`,\n            range: parent.range,\n            maximumSize: parent.maximumSize,\n        }, parent.tree);\n        this.toleranceLog10 = toleranceLog10;\n        this.tolerance = 10 ** toleranceLog10;\n    }\n    computeLoadPriority() {\n        // We want the element's graphics to be updated as soon as possible\n        return 0;\n    }\n    _loadChildren(resolve, _reject) {\n        resolve(undefined);\n    }\n    get channel() {\n        return IModelApp.tileAdmin.channels.elementGraphicsRpc;\n    }\n    async requestContent(_isCanceled) {\n        // ###TODO tree flags (enforce display priority)\n        // ###TODO classifiers, animation\n        assert(undefined !== this.parent);\n        const requestId = requestIdSequence.next();\n        assert(!requestId.done);\n        assert(this.tree instanceof IModelTileTree);\n        const idProvider = this.tree.contentIdProvider;\n        const props = {\n            id: requestId.value.toString(16),\n            elementId: this.parent.contentId,\n            toleranceLog10: this.toleranceLog10,\n            formatVersion: idProvider.majorFormatVersion,\n            location: this.tree.iModelTransform.toJSON(),\n            contentFlags: idProvider.contentFlags,\n            omitEdges: !this.tree.edgeOptions,\n            edgeType: this.tree.edgeOptions && \"non-indexed\" !== this.tree.edgeOptions.type ? 2 : 1,\n            smoothPolyfaceEdges: this.tree.edgeOptions && this.tree.edgeOptions.smooth,\n            clipToProjectExtents: true,\n            sectionCut: this.tree.stringifiedSectionClip,\n        };\n        return IModelApp.tileAdmin.requestElementGraphics(this.tree.iModel, props);\n    }\n    async readContent(data, system, isCanceled) {\n        if (undefined === isCanceled)\n            isCanceled = () => !this.isLoading;\n        assert(data instanceof Uint8Array);\n        const stream = ByteStream.fromUint8Array(data);\n        const position = stream.curPos;\n        const format = stream.readUint32();\n        stream.curPos = position;\n        // ###TODO: IModelGraphics format wraps IModel format.\n        assert(TileFormat.IModel === format);\n        const tree = this.tree;\n        assert(tree instanceof IModelTileTree);\n        const { iModel, modelId, is3d, containsTransformNodes } = tree;\n        const reader = ImdlReader.create({\n            stream, iModel, modelId, is3d, system, isCanceled, containsTransformNodes,\n            type: tree.batchType,\n            loadEdges: false !== tree.edgeOptions,\n            options: { tileId: this.contentId },\n        });\n        let content = { isLeaf: true };\n        if (reader) {\n            try {\n                content = await reader.read();\n            }\n            catch {\n                //\n            }\n        }\n        return content;\n    }\n}\n//# sourceMappingURL=DynamicIModelTile.js.map",
      "start": 1693508121903,
      "end": 1693508122057,
      "sourcemaps": null
    }
  ]
}
