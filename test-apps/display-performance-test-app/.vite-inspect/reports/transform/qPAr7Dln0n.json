{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/curve/Query/CurveSplitContext.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Curve\n */\nimport { Geometry } from \"../../Geometry\";\nimport { CurveChain } from \"../CurveCollection\";\nimport { CurveCurve } from \"../CurveCurve\";\nimport { CurvePrimitive } from \"../CurvePrimitive\";\nimport { Path } from \"../Path\";\n/**\n * Data about a curve cut.\n */\nclass CutFractionDescriptor {\n    constructor(fraction, otherCurveDetail) {\n        this.fraction = fraction;\n        this.otherCurveDetail = otherCurveDetail;\n    }\n    /** Transfer data from other to this.\n     * * Optionally look at both to set `otherCurveDetail`\n     *   * `other.otherCurveDetail` wins over `this.otherCurveDetail`\n     */\n    setFrom(other, combineCutFlag) {\n        if (combineCutFlag && this.isSameFraction(other))\n            this.otherCurveDetail = other.otherCurveDetail ? other.otherCurveDetail : this.otherCurveDetail;\n        this.fraction = other.fraction;\n    }\n    /** Test if a the fractions are almost equal. */\n    isSameFraction(other) {\n        return Geometry.isSmallAngleRadians(this.fraction - other.fraction);\n    }\n    /** set from direct data */\n    set(fraction, otherCurveDetail) {\n        this.fraction = fraction;\n        this.otherCurveDetail = otherCurveDetail;\n    }\n}\n/**\n * Context for splitting curves.\n * * Sets startCut and endCut details on CurvePrimitive fragments.\n * @internal\n */\nexport class CurveSplitContext {\n    // return true if data has one or more non-endpoint intersections.\n    static hasInteriorDetailAIntersections(data, fractionTolerance = Geometry.smallAngleRadians) {\n        if (data.length === 0)\n            return false;\n        for (const pair of data) {\n            if (pair.detailA.fraction > fractionTolerance || pair.detailA.fraction < 1 - fractionTolerance)\n                return true;\n        }\n        return false;\n    }\n    collectFragmentAndAdvanceCut(curveToCut, cutA, cutB, dest) {\n        if (!cutA.isSameFraction(cutB)) {\n            const fragment = curveToCut.clonePartialCurve(cutA.fraction, cutB.fraction);\n            if (fragment !== undefined) {\n                fragment.startCut = cutA.otherCurveDetail;\n                fragment.endCut = cutB.otherCurveDetail;\n                dest.push(fragment);\n            }\n        }\n        cutA.setFrom(cutB, true);\n    }\n    /** Collect fragments from an intersections array, with the array detailA entries all referencing to curveToCut.\n     * * The `intersections` array is sorted on its detailA field.\n     */\n    collectSinglePrimitiveFragments(curveToCut, intersections, fragments) {\n        if (intersections === undefined || !CurveSplitContext.hasInteriorDetailAIntersections(intersections)) {\n            fragments.push(curveToCut.clone());\n            return;\n        }\n        intersections.sort((pairA, pairB) => (pairA.detailA.fraction - pairB.detailA.fraction));\n        const cutA = new CutFractionDescriptor(0.0, undefined);\n        const cutB = new CutFractionDescriptor(1.0, undefined); // but those values are immediately reset before use.\n        for (const pair of intersections) {\n            cutB.set(pair.detailA.fraction, pair.detailB);\n            this.collectFragmentAndAdvanceCut(curveToCut, cutA, cutB, fragments);\n        }\n        cutB.set(1.0, undefined);\n        this.collectFragmentAndAdvanceCut(curveToCut, cutA, cutB, fragments);\n    }\n    static cloneCurvesWithXYSplits(curvesToCut, cutterCurves) {\n        const context = new CurveSplitContext();\n        if (curvesToCut instanceof CurvePrimitive) {\n            const result = [];\n            const intersections = CurveCurve.intersectionXYPairs(curvesToCut, false, cutterCurves, false);\n            context.collectSinglePrimitiveFragments(curvesToCut, intersections, result);\n            if (result.length === 1)\n                return result[0];\n            return Path.createArray(result);\n        }\n        else if (curvesToCut instanceof CurveChain) {\n            const result = [];\n            for (const primitive of curvesToCut.children) {\n                const intersections = CurveCurve.intersectionXYPairs(primitive, false, cutterCurves, false);\n                context.collectSinglePrimitiveFragments(primitive, intersections, result);\n            }\n            return Path.createArray(result);\n        }\n        return undefined;\n    }\n}\n//# sourceMappingURL=CurveSplitContext.js.map",
      "start": 1693508124189,
      "end": 1693508124328,
      "sourcemaps": null
    }
  ]
}
