{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/solid/RuledSweep.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Solid\n */\nimport { ConstructCurveBetweenCurves } from \"../curve/ConstructCurveBetweenCurves\";\nimport { CurveChain, CurveCollection } from \"../curve/CurveCollection\";\nimport { CurvePrimitive } from \"../curve/CurvePrimitive\";\nimport { Geometry } from \"../Geometry\";\nimport { SolidPrimitive } from \"./SolidPrimitive\";\nimport { SweepContour } from \"./SweepContour\";\n/**\n * A ruled sweep (surface) is a collection of 2 or more contours.\n * * All contours must have identical number and type of geometry. (paths, loops, parity regions, lines, arcs, other curves)\n * @public\n */\nexport class RuledSweep extends SolidPrimitive {\n    constructor(contours, capped) {\n        super(capped);\n        /** String name for schema properties */\n        this.solidPrimitiveType = \"ruledSweep\";\n        this._contours = contours;\n    }\n    /**\n     * Create a ruled sweep from an array of contours.\n     * * the contours are CAPTURED (not cloned)\n     */\n    static create(contours, capped) {\n        const sweepContours = [];\n        for (const contour of contours) {\n            const sweepable = SweepContour.createForLinearSweep(contour);\n            if (sweepable === undefined)\n                return undefined;\n            sweepContours.push(sweepable);\n        }\n        return new RuledSweep(sweepContours, capped);\n    }\n    /** Return a reference to the array of SweepContour. */\n    sweepContoursRef() { return this._contours; }\n    /** Return clones of all the sweep contours\n     * * See also cloneContours, which returns the spatial contours without their local coordinate system definitions)\n     */\n    cloneSweepContours() {\n        const result = [];\n        for (const sweepable of this._contours) {\n            result.push(sweepable.clone());\n        }\n        return result;\n    }\n    /** Return clones of all the contours\n     * * See also cloneContours, which returns the contours in their local coordinate systems\n     */\n    cloneContours() {\n        const result = [];\n        for (const sweepable of this._contours) {\n            result.push(sweepable.curves.clone());\n        }\n        return result;\n    }\n    /** Return a deep clone */\n    clone() {\n        return new RuledSweep(this.cloneSweepContours(), this.capped);\n    }\n    /** Transform all contours in place. */\n    tryTransformInPlace(transform) {\n        if (transform.matrix.isSingular())\n            return false;\n        for (const contour of this._contours) {\n            contour.tryTransformInPlace(transform);\n        }\n        return true;\n    }\n    /** Return a cloned transform. */\n    cloneTransformed(transform) {\n        const result = this.clone();\n        result.tryTransformInPlace(transform);\n        return result;\n    }\n    /** Return a coordinate frame (right handed unit vectors)\n     * * origin on base contour\n     * * x, y directions from base contour.\n     * * z direction perpendicular\n     */\n    getConstructiveFrame() {\n        if (this._contours.length === 0)\n            return undefined;\n        return this._contours[0].localToWorld.cloneRigid();\n    }\n    /** Test if `other` is an instance of a `RuledSweep` */\n    isSameGeometryClass(other) { return other instanceof RuledSweep; }\n    /** test same contour geometry and capping. */\n    isAlmostEqual(other) {\n        if (other instanceof RuledSweep) {\n            if (this.capped !== other.capped)\n                return false;\n            if (this._contours.length !== other._contours.length)\n                return false;\n            for (let i = 0; i < this._contours.length; i++) {\n                if (!this._contours[i].isAlmostEqual(other._contours[i]))\n                    return false;\n            }\n            return true;\n        }\n        return false;\n    }\n    /** dispatch to strongly typed `handler.handleRuledSweep(this)` */\n    dispatchToGeometryHandler(handler) {\n        return handler.handleRuledSweep(this);\n    }\n    /**\n     * Return the section curves at a fraction of the sweep\n     * @param vFraction fractional position along the sweep direction\n     */\n    constantVSection(vFraction) {\n        const numSection = this._contours.length;\n        if (numSection < 2)\n            return undefined;\n        const q = vFraction * numSection;\n        let section0 = 0;\n        if (vFraction >= 1.0)\n            section0 = numSection - 1;\n        else\n            section0 = Math.floor(q);\n        if (section0 + 1 >= numSection)\n            section0 = numSection - 2;\n        const section1 = section0 + 1;\n        const localFraction = Geometry.clampToStartEnd(q - section0, 0, 1);\n        return RuledSweep.mutatePartners(this._contours[section0].curves, this._contours[section1].curves, (primitive0, primitive1) => {\n            const newPrimitive = ConstructCurveBetweenCurves.interpolateBetween(primitive0, localFraction, primitive1);\n            if (newPrimitive instanceof CurvePrimitive)\n                return newPrimitive;\n            return undefined;\n        });\n    }\n    /** Pass each contour to `extendRange` */\n    extendRange(rangeToExtend, transform) {\n        for (const contour of this._contours)\n            contour.curves.extendRange(rangeToExtend, transform);\n    }\n    /** Construct a CurveCollection with the same structure as collectionA and collectionB, with primitives constructed by the caller-supplied primitiveMutator function.\n     * @returns Returns undefined if there is any type mismatch between the two collections.\n     */\n    static mutatePartners(collectionA, collectionB, primitiveMutator) {\n        if (!collectionA.isSameGeometryClass(collectionB))\n            return undefined;\n        if (collectionA instanceof CurveChain && collectionB instanceof CurveChain) {\n            const chainA = collectionA;\n            const chainB = collectionB;\n            const chainC = chainA.cloneEmptyPeer();\n            const childrenA = chainA.children;\n            const childrenB = chainB.children;\n            if (childrenA.length !== childrenB.length)\n                return undefined;\n            for (let i = 0; i < childrenA.length; i++) {\n                const newChild = primitiveMutator(childrenA[i], childrenB[i]);\n                if (!newChild)\n                    return undefined;\n                chainC.children.push(newChild);\n            }\n            return chainC;\n        }\n        else if (collectionA instanceof CurveCollection && collectionB instanceof CurveCollection) {\n            const collectionC = collectionA.cloneEmptyPeer();\n            const childrenA = collectionA.children;\n            const childrenB = collectionB.children;\n            const childrenC = collectionC.children;\n            if (childrenA === undefined || childrenB === undefined || childrenC === undefined || childrenA.length !== childrenB.length)\n                return undefined;\n            for (let i = 0; i < childrenA.length; i++) {\n                const childA = childrenA[i];\n                const childB = childrenB[i];\n                if (childA instanceof CurvePrimitive && childB instanceof CurvePrimitive) {\n                    const newPrimitive = primitiveMutator(childA, childB);\n                    if (!newPrimitive)\n                        return undefined;\n                    childrenC.push(newPrimitive);\n                }\n                else if (childA instanceof CurveCollection && childB instanceof CurveCollection) {\n                    const newChild = this.mutatePartners(childA, childB, primitiveMutator);\n                    if (!newChild)\n                        return undefined;\n                    if (newChild instanceof CurveCollection)\n                        childrenC.push(newChild);\n                }\n            }\n            return collectionC;\n        }\n        return undefined;\n    }\n    /**\n     * Return true if this is a closed volume, as observed by\n     * * cap flag\n     * identical first and last contours.\n     */\n    get isClosedVolume() {\n        const n = this._contours.length;\n        return n > 1 && (this.capped || this._contours[0].isAlmostEqual(this._contours[n - 1]));\n    }\n}\n//# sourceMappingURL=RuledSweep.js.map",
      "start": 1693508122908,
      "end": 1693508123057,
      "sourcemaps": null
    }
  ]
}
