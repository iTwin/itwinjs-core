{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/common/lib/esm/SpatialClassification.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module DisplayStyles\n */\nimport { assert } from \"@itwin/core-bentley\";\n/** Describes how a [[SpatialClassifier]] affects the display of classified geometry - that is, geometry intersecting\n * the classifier.\n * @public\n * @extensions\n */\nexport var SpatialClassifierInsideDisplay;\n(function (SpatialClassifierInsideDisplay) {\n    /** The geometry is not displayed. */\n    SpatialClassifierInsideDisplay[SpatialClassifierInsideDisplay[\"Off\"] = 0] = \"Off\";\n    /** The geometry is displayed without alteration. */\n    SpatialClassifierInsideDisplay[SpatialClassifierInsideDisplay[\"On\"] = 1] = \"On\";\n    /** The geometry is darkened. */\n    SpatialClassifierInsideDisplay[SpatialClassifierInsideDisplay[\"Dimmed\"] = 2] = \"Dimmed\";\n    /** The geometry is tinted by the [Viewport.hilite]($frontend) color. */\n    SpatialClassifierInsideDisplay[SpatialClassifierInsideDisplay[\"Hilite\"] = 3] = \"Hilite\";\n    /** The geometry is tinted with the colors of the classifier elements. */\n    SpatialClassifierInsideDisplay[SpatialClassifierInsideDisplay[\"ElementColor\"] = 4] = \"ElementColor\";\n})(SpatialClassifierInsideDisplay || (SpatialClassifierInsideDisplay = {}));\n/** Describes how a [[SpatialClassifier]] affects the display of unclassified geometry - that is, geometry not intersecting\n * the classifier.\n * @public\n * @extensions\n */\nexport var SpatialClassifierOutsideDisplay;\n(function (SpatialClassifierOutsideDisplay) {\n    /** The geometry is not displayed. */\n    SpatialClassifierOutsideDisplay[SpatialClassifierOutsideDisplay[\"Off\"] = 0] = \"Off\";\n    /** The geometry is displayed without alteration. */\n    SpatialClassifierOutsideDisplay[SpatialClassifierOutsideDisplay[\"On\"] = 1] = \"On\";\n    /** The geometry is darkened. */\n    SpatialClassifierOutsideDisplay[SpatialClassifierOutsideDisplay[\"Dimmed\"] = 2] = \"Dimmed\";\n})(SpatialClassifierOutsideDisplay || (SpatialClassifierOutsideDisplay = {}));\n/** Flags affecting how a [[SpatialClassifier]] is applied.\n * @public\n */\nexport class SpatialClassifierFlags {\n    /** Construct new flags. */\n    constructor(inside = SpatialClassifierInsideDisplay.ElementColor, outside = SpatialClassifierOutsideDisplay.Dimmed, isVolumeClassifier = false) {\n        this.inside = insideDisplay(inside);\n        this.outside = outsideDisplay(outside);\n        this.isVolumeClassifier = isVolumeClassifier;\n    }\n    /** Construct from JSON representation. */\n    static fromJSON(props) {\n        return new SpatialClassifierFlags(props.inside, props.outside, true === props.isVolumeClassifier);\n    }\n    /** Convert to JSON representation. */\n    toJSON() {\n        const props = {\n            inside: this.inside,\n            outside: this.outside,\n        };\n        if (this.isVolumeClassifier)\n            props.isVolumeClassifier = true;\n        return props;\n    }\n    /** Create flags indentical to these ones except for any properties explicitly specified by `changedProps`. */\n    clone(changedProps) {\n        if (!changedProps)\n            return this;\n        return SpatialClassifierFlags.fromJSON({ ...this.toJSON(), ...changedProps });\n    }\n    /** Return true if these flags are equivalent to `other`. */\n    equals(other) {\n        if (other === this)\n            return true;\n        return other.inside === this.inside && other.outside === this.outside && other.isVolumeClassifier === this.isVolumeClassifier;\n    }\n    /** Return true if these flags are equivalent to `props`. */\n    equalsProps(props) {\n        return this.inside === props.inside && this.outside === props.outside && this.isVolumeClassifier === (true === props.isVolumeClassifier);\n    }\n}\n/** Describes how to use the geometry of one [GeometricModel]($backend) to classify the contents of other models - most typically, reality models.\n * Applying a classifier divides the geometry of the classified model into two groups:\n *  - Classified (intersecting the classifier); and\n *  - Unclassified (not intersecting the classifier).\n * For example, a model containing the building footprints for a city block could be used to classify a reality mesh captured from photographs of the\n * real-world block. Then, buildings within the reality mesh can be selected individually, and present the properties of the classifier geometry (e.g.,\n * the address of the building). The appearance of the geometry can also be customized based using [[SpatialClassifierInsideDisplay]] and [[SpatialClassifierOutsideDisplay]].\n * Two types of classification are supported:\n *  - Planar classification, in which the geometry of the classifier model is projected onto a plane to classify geometry within a region extruded perpendicular\n * the plane (e.g., the building footprints example); and\n *  - Volume classification, in which closed, non-intersecting volumes within the classifier classify geometry that intersects (i.e. is contained within) those same volumes (e.g., imagine using boxes instead\n * of footprints to classify buildings, or floors of buildings).\n * @see this (interactive example)[https://www.itwinjs.org/sample-showcase/?group=Viewer+Features&sample=classifier-sample].\n * @see [[SpatialClassifiers]] to define a set of classifiers.\n * @see [[ContextRealityModel.classifiers]] to classify a context reality model.\n * @see [SpatialModelState.classifiers]($frontend) to classify a persistent reality model.\n * @public\n */\nexport class SpatialClassifier {\n    /** Construct a new classifier. */\n    constructor(modelId, name, flags = new SpatialClassifierFlags(), expand = 0) {\n        this.modelId = modelId;\n        this.expand = expand;\n        this.flags = flags;\n        this.name = name;\n    }\n    /** Construct from JSON representation. */\n    static fromJSON(props) {\n        return new SpatialClassifier(props.modelId, props.name, SpatialClassifierFlags.fromJSON(props.flags), props.expand);\n    }\n    /** Convert to JSON representation.\n     * @note This method always sets the [[SpatialClassifierProps.isActive]] property to `false`.\n     */\n    toJSON() {\n        return {\n            modelId: this.modelId,\n            expand: this.expand,\n            flags: this.flags.toJSON(),\n            name: this.name,\n            isActive: false,\n        };\n    }\n    /** Construct from Model Map Layer.\n     * @beta\n     */\n    static fromModelMapLayer(mapLayer) {\n        const flags = SpatialClassifierFlags.fromJSON({ inside: SpatialClassifierInsideDisplay.Off, outside: SpatialClassifierOutsideDisplay.Off });\n        return new SpatialClassifier(mapLayer.modelId, mapLayer.name, flags);\n    }\n    /** Create a classifier identical to this one except for any properties explicitly specified by `changedProps`. */\n    clone(changedProps) {\n        if (!changedProps)\n            return this;\n        return SpatialClassifier.fromJSON({ ...this.toJSON(), ...changedProps });\n    }\n    /** Return true if this classifier is equivalent to `other`. */\n    equals(other) {\n        if (other === this)\n            return true;\n        return this.modelId === other.modelId && this.expand === other.expand && this.name === other.name && this.flags.equals(other.flags);\n    }\n    /** Return true if this classifier is equivalent to `props`. */\n    equalsProps(props) {\n        return this.modelId === props.modelId && this.expand === props.expand && this.name === props.name && this.flags.equalsProps(props.flags);\n    }\n}\n/** A set of [[SpatialClassifier]]s for a given reality model. At most one of the classifiers can be actively classifying the model at any given time.\n * The set of classifiers can be presented to the user, listed by name, so that the active classifier can be changed.\n * The set of classifiers is populated from its JSON representation and that representation is kept in sync as the set of classifiers is modified.\n * @see this (interactive example)[https://www.itwinjs.org/sample-showcase/?group=Viewer+Features&sample=classifier-sample].\n * @see [[SpatialClassifier]] for details on how spatial classification works.\n * @see [[ContextRealityModel.classifiers]] to define classifiers for a context reality model.\n * @see [SpatialModelState.classifiers]($frontend) to define classifiers for a persistent reality model.\n * @public\n */\nexport class SpatialClassifiers {\n    /** Construct a new set of classifiers from the JSON representation. The set will be initialized from `container.classifiers` and that JSON representation\n     * will be kept in sync with changes made to the set. The caller should not directly modify `container.classifiers` or its contents as that will cause the set to become out\n     * of sync with the JSON representation.\n     * The [[active]] classifier will be determined by the first [[SpatialClassifierProps]] whose `isActive` property is set to `true`, if any.\n     */\n    constructor(container) {\n        this._classifiers = [];\n        this._json = container;\n        const json = this._array;\n        if (!json)\n            return;\n        for (const props of json) {\n            const classifier = SpatialClassifier.fromJSON(props);\n            this._classifiers.push(classifier);\n            if (props.isActive) {\n                if (!this._active)\n                    this._active = classifier;\n                else\n                    props.isActive = false;\n            }\n        }\n    }\n    /** The classifier currently classifying the target reality model. The classifier passed to the setter must be one obtained from this set, or one equivalent to\n     * one contained in this set; in the latter case, the equivalent classifier contained in this set becomes active.\n     */\n    /** The classifier currently classifying the target reality model, if any.\n     * @see [[setActive]] to change the active classifier.\n     */\n    get active() {\n        return this._active;\n    }\n    /** Change the [[active]] classifier. The input must be a classifier belonging to this set, or equivalent to one in the set.\n     * If no equivalent classifier exists in the set, the active classifier remains unchanged.\n     * @param The classifier to set as active, or `undefined` to clear the active classifier.\n     * @returns the active classifier.\n     */\n    setActive(active) {\n        const array = this._array;\n        if (!array)\n            return this.active;\n        if (active) {\n            active = this.findEquivalent(active);\n            if (!active)\n                return this.active;\n        }\n        if (active === this.active)\n            return this.active;\n        let propsIndex = -1;\n        if (active) {\n            propsIndex = array.findIndex((x) => active.equalsProps(x));\n            if (-1 === propsIndex)\n                return this.active;\n        }\n        this._active = active;\n        for (let i = 0; i < array.length; i++)\n            array[i].isActive = (i === propsIndex);\n        return this.active;\n    }\n    /** Obtain an iterator over the classifiers contained in this set. */\n    [Symbol.iterator]() {\n        return this._classifiers[Symbol.iterator]();\n    }\n    /** The number of classifiers in this set. */\n    get size() {\n        return this._array?.length ?? 0;\n    }\n    /** Returns the first classifier that satisfies `criterion`, or `undefined` if no classifier satisfies it. */\n    find(criterion) {\n        return this._classifiers.find(criterion);\n    }\n    /** Find the first classifier that is equivalent to the supplied classifier, or `undefined` if no equivalent classifier exists in this set. */\n    findEquivalent(classifier) {\n        return this.find((x) => x.equals(classifier));\n    }\n    /** Return true if the specified classifier or one equivalent to it exists in this set. */\n    has(classifier) {\n        return undefined !== this.findEquivalent(classifier);\n    }\n    /** Add a classifier to this set. If an equivalent classifier already exists, the supplied classifier is not added.\n     * @param classifier The classifier to add.\n     * @returns The equivalent pre-existing classifier, if one existed; or the supplied classifier, if it was added to the set.\n     */\n    add(classifier) {\n        const existing = this.findEquivalent(classifier);\n        if (existing)\n            return existing;\n        let array = this._array;\n        if (!array)\n            array = this._json.classifiers = [];\n        this._classifiers.push(classifier);\n        array.push(classifier.toJSON());\n        return classifier;\n    }\n    /** Replace an existing classifier with a different one.\n     * @param toReplace The classifier to be replaced.\n     * @param replacement The classifier to replace `toReplace`.\n     * @returns true if a classifier equivalent to `toReplace` existed in the set and was replaced by `replacement`.\n     * @note If `toReplace` was the [[active]] classifier, `replacement` will become active.\n     */\n    replace(toReplace, replacement) {\n        const list = this._array;\n        if (!list)\n            return false;\n        const classifierIndex = this._classifiers.findIndex((x) => x.equals(toReplace));\n        if (-1 === classifierIndex)\n            return false;\n        const propsIndex = list.findIndex((x) => toReplace.equalsProps(x));\n        assert(propsIndex === classifierIndex);\n        if (-1 === propsIndex)\n            return false;\n        toReplace = this._classifiers[classifierIndex];\n        const wasActive = this.active === toReplace;\n        this._classifiers[classifierIndex] = replacement;\n        const props = list[propsIndex] = replacement.toJSON();\n        if (wasActive) {\n            props.isActive = true;\n            this._active = replacement;\n        }\n        return true;\n    }\n    /** Remove the first classifier equivalent to `classifier` from this set.\n     * @param classifier The classifier to remove.\n     * @returns The classifier that was actually removed, or `undefined` if none was removed.\n     */\n    delete(classifier) {\n        const list = this._array;\n        if (!list)\n            return undefined;\n        const classifierIndex = this._classifiers.findIndex((x) => x.equals(classifier));\n        if (-1 === classifierIndex)\n            return undefined;\n        classifier = this._classifiers[classifierIndex];\n        const propsIndex = list.findIndex((x) => classifier.equalsProps(x));\n        assert(propsIndex === classifierIndex);\n        if (-1 === propsIndex)\n            return undefined;\n        list.splice(propsIndex, 1);\n        this._classifiers.splice(classifierIndex, 1);\n        if (list.length === 0)\n            this._json.classifiers = undefined;\n        if (classifier === this.active)\n            this._active = undefined;\n        return classifier;\n    }\n    /** Remove all classifiers from this set. */\n    clear() {\n        this._classifiers.length = 0;\n        this._json.classifiers = undefined;\n        this._active = undefined;\n    }\n    get _array() {\n        return Array.isArray(this._json.classifiers) ? this._json.classifiers : undefined;\n    }\n}\nfunction insideDisplay(display) {\n    switch (display) {\n        case SpatialClassifierInsideDisplay.Off:\n        case SpatialClassifierInsideDisplay.On:\n        case SpatialClassifierInsideDisplay.Dimmed:\n        case SpatialClassifierInsideDisplay.Hilite:\n        case SpatialClassifierInsideDisplay.ElementColor:\n            return display;\n        default:\n            return SpatialClassifierInsideDisplay.ElementColor;\n    }\n}\nfunction outsideDisplay(display) {\n    switch (display) {\n        case SpatialClassifierOutsideDisplay.Off:\n        case SpatialClassifierOutsideDisplay.On:\n        case SpatialClassifierOutsideDisplay.Dimmed:\n            return display;\n        default:\n            return SpatialClassifierOutsideDisplay.Dimmed;\n    }\n}\n//# sourceMappingURL=SpatialClassification.js.map",
      "start": 1693508120761,
      "end": 1693508120821,
      "sourcemaps": null
    }
  ]
}
