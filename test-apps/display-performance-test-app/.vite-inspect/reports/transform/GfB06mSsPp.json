{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/glsl/Blur.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { BlurType } from \"../CachedGeometry\";\nimport { TextureUnit } from \"../RenderFlags\";\nimport { Texture2DHandle } from \"../Texture\";\nimport { addRenderOrderConstants } from \"./FeatureSymbology\";\nimport { addWindowToTexCoords, assignFragColor } from \"./Fragment\";\nimport { addViewport } from \"./Viewport\";\nimport { createViewportQuadBuilder } from \"./ViewportQuad\";\n// This shader applies a Gaussian blur in one dimension.\nconst computeBlur = `\r\n  float delta = u_blurSettings.x;\r\n  float sigma = u_blurSettings.y;\r\n  float texelStepSize = u_blurSettings.z;\r\n\r\n  vec2 tc = windowCoordsToTexCoords(gl_FragCoord.xy);\r\n  vec2 step = texelStepSize / u_viewport;\r\n\r\n  vec3 gaussian;\r\n  const float twoPi = 6.283185307179586;\r\n  gaussian.x = 1.0 / (sqrt(twoPi) * sigma);\r\n  gaussian.y = exp((-0.5 * delta * delta) / (sigma * sigma));\r\n  gaussian.z = gaussian.y * gaussian.y;\r\n\r\n  vec4 origColor = TEXTURE(u_textureToBlur, tc);\r\n  vec4 result = origColor * gaussian.x;\r\n  for (int i = 1; i < 8; i++) {\r\n    gaussian.xy *= gaussian.yz;\r\n\r\n    vec2 offset = float(i) * u_blurDir * step;\r\n    vec2 tcMinusOffset = tc - offset;\r\n    vec2 tcPlusOffset = tc + offset;\r\n\r\n    result += TEXTURE(u_textureToBlur, tcMinusOffset) * gaussian.x;\r\n    result += TEXTURE(u_textureToBlur, tcPlusOffset) * gaussian.x;\r\n  }\r\n\r\n  return result;\r\n`;\n// This optionally skips adding in the blur texture result if the current pixel is a linear/edge/silhouette.\nconst testRenderOrder = `\r\n  vec2 rotc = windowCoordsToTexCoords(gl_FragCoord.xy);\r\n  vec4 pdo = TEXTURE(u_pickDepthAndOrder, rotc);\r\n  float order = floor(pdo.x * 16.0 + 0.5);\r\n  if (order >= kRenderOrder_PlanarBit)\r\n    order = order - kRenderOrder_PlanarBit;\r\n  if (order >= kRenderOrder_Linear && order <= kRenderOrder_Silhouette)\r\n    return vec4(1.0);\r\n\r\n`;\n/** @internal */\nexport function createBlurProgram(context, type) {\n    const builder = createViewportQuadBuilder(true);\n    const frag = builder.frag;\n    addWindowToTexCoords(frag);\n    if (BlurType.TestOrder === type) {\n        addRenderOrderConstants(frag);\n        frag.set(1 /* FragmentShaderComponent.ComputeBaseColor */, testRenderOrder + computeBlur);\n    }\n    else {\n        frag.set(1 /* FragmentShaderComponent.ComputeBaseColor */, computeBlur);\n    }\n    frag.set(16 /* FragmentShaderComponent.AssignFragData */, assignFragColor);\n    addViewport(frag);\n    frag.addUniform(\"u_textureToBlur\", 8 /* VariableType.Sampler2D */, (prog) => {\n        prog.addGraphicUniform(\"u_textureToBlur\", (uniform, params) => {\n            const geom = params.geometry;\n            Texture2DHandle.bindSampler(uniform, geom.textureToBlur, TextureUnit.Zero);\n        });\n    });\n    frag.addUniform(\"u_blurDir\", 3 /* VariableType.Vec2 */, (prog) => {\n        prog.addGraphicUniform(\"u_blurDir\", (uniform, params) => {\n            const geom = params.geometry;\n            uniform.setUniform2fv(new Float32Array([geom.blurDir.x, geom.blurDir.y]));\n        });\n    });\n    frag.addUniform(\"u_blurSettings\", 4 /* VariableType.Vec3 */, (prog) => {\n        prog.addProgramUniform(\"u_blurSettings\", (uniform, params) => {\n            const hbaoSettings = new Float32Array([\n                // ###TODO: If we want to apply this blur shader to situations other than AO, we should move these settings away from the ambient occlusion params.\n                params.target.ambientOcclusionSettings.blurDelta,\n                params.target.ambientOcclusionSettings.blurSigma,\n                params.target.ambientOcclusionSettings.blurTexelStepSize\n            ]);\n            uniform.setUniform3fv(hbaoSettings);\n        });\n    }, 3 /* VariablePrecision.High */);\n    if (BlurType.TestOrder === type) {\n        frag.addUniform(\"u_pickDepthAndOrder\", 8 /* VariableType.Sampler2D */, (prog) => {\n            prog.addGraphicUniform(\"u_pickDepthAndOrder\", (uniform, params) => {\n                const geom = params.geometry;\n                if (params.target.compositor.needHiddenEdges)\n                    Texture2DHandle.bindSampler(uniform, geom.depthAndOrderHidden, TextureUnit.One);\n                else\n                    Texture2DHandle.bindSampler(uniform, geom.depthAndOrder, TextureUnit.One);\n            });\n        });\n        builder.vert.headerComment = \"//!V! BlurTestOrder\";\n        builder.frag.headerComment = \"//!F! BlurTestOrder\";\n    }\n    else {\n        builder.vert.headerComment = \"//!V! Blur\";\n        builder.frag.headerComment = \"//!F! Blur\";\n    }\n    return builder.buildProgram(context);\n}\n//# sourceMappingURL=Blur.js.map",
      "start": 1693508124604,
      "end": 1693508124706,
      "sourcemaps": null
    }
  ]
}
