{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/geometry3d/PointStreaming.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\nimport { GrowableXYZArray } from \"./GrowableXYZArray\";\nimport { IndexedXYZCollection } from \"./IndexedXYZCollection\";\n/* eslint-disable @typescript-eslint/naming-convention, no-empty */\nimport { Point3d } from \"./Point3dVector3d\";\nimport { Range3d } from \"./Range\";\n//\n// remarks: point array variants . . .\n//  * [[x,y,z], ...]\n//  * [[Point3d, Point3d]\n//  * [GrowableXYZArray, ..]\n//\n/**\n * \"no-op\" base class for stream handlers\n * @internal\n */\nexport class PointStreamXYZHandlerBase {\n    startChain(_chainData, _isLeaf) { }\n    handleXYZ(_x, _y, _z) { }\n    endChain(_chainData, _isLeaf) { }\n}\n/** Base class for handling points in pairs.\n * * Callers implement handleXYZXYZ to receive point pairs.\n * * Callers may implement startChain and endChain.\n *   * Beware that if startChain is implemented it must call super.startChain () to reset internal x0, y0,z0 to undefined.\n *   * If that is not done, a point pair will appear from the end of previous chain to start of new chain.\n *   * This (intermediate base) class does NOT override startChain\n */\nexport class PointStreamXYZXYZHandlerBase extends PointStreamXYZHandlerBase {\n    handleXYZ(x, y, z) {\n        if (this._x0 !== undefined)\n            this.handleXYZXYZ(this._x0, this._y0, this._z0, x, y, z);\n        this._x0 = x;\n        this._y0 = y;\n        this._z0 = z;\n    }\n    startChain(_chainData, _isLeaf) {\n        this._x0 = this._y0 = this._z0 = undefined;\n    }\n    /**\n     * Handler function called successively for each point0, point1 pair.  Concrete class should implement this.\n     * @param _x0 x coordinate at point 0\n     * @param _y0 y coordinate of point 0\n     * @param _z0 z coordinate of point 0\n     * @param _x1 x coordinate of point 1\n     * @param _y1 y coordinate of point 1\n     * @param _z1 z coordinate of point 1\n     */\n    handleXYZXYZ(_x0, _y0, _z0, _x1, _y1, _z1) { }\n}\n/**\n * Concrete class to handle startChain, handleXYZ and endChain calls and return a (one-level deep array of\n * GrowableXYZArray\n */\nexport class PointStreamGrowableXYZArrayCollector extends PointStreamXYZHandlerBase {\n    startChain(_chainData, _isLeaf) {\n        this._currentData = undefined;\n    }\n    handleXYZ(x, y, z) {\n        if (!this._currentData)\n            this._currentData = new GrowableXYZArray();\n        this._currentData.pushXYZ(x, y, z);\n    }\n    endChain(_chainData, _isLeaf) {\n        if (this._currentData !== undefined) {\n            if (this._pointArrays === undefined)\n                this._pointArrays = [];\n            this._pointArrays.push(this._currentData);\n            this._currentData = undefined;\n        }\n    }\n    /** Return MultiLineStringDataVariant as an array of GrowableXYZArray */\n    claimArrayOfGrowableXYZArray() {\n        const result = this._pointArrays;\n        this._pointArrays = undefined;\n        return result;\n    }\n}\n/**\n * PointStream handler to collect the range of points.\n */\nexport class PointStreamRangeCollector extends PointStreamXYZHandlerBase {\n    constructor() {\n        super(...arguments);\n        this._range = Range3d.createNull();\n    }\n    handleXYZ(x, y, z) {\n        if (!this._range)\n            this._range = Range3d.createNull();\n        this._range.extendXYZ(x, y, z);\n    }\n    claimResult() {\n        const range = this._range;\n        this._range = undefined;\n        if (!range)\n            return Range3d.createNull();\n        return range;\n    }\n}\nexport class PointStringDeepXYZArrayCollector {\n    /**\n     *\n     * @param xyzFunction function to map (x,y,z) to the leaf object type in the arrays.\n     */\n    constructor(xyzFunction) {\n        this._xyzFunction = xyzFunction;\n        this._resultStack = [];\n        // create the [0] placeholder.\n        this._resultStack.push([]);\n    }\n    startChain(_chainData, _isLeaf) {\n        this._resultStack.push([]);\n    }\n    handleXYZ(x, y, z) {\n        this._resultStack[this._resultStack.length - 1].push(this._xyzFunction(x, y, z));\n    }\n    endChain(_chainData, _isLeaf) {\n        const q = this._resultStack[this._resultStack.length - 1];\n        this._resultStack.pop();\n        this._resultStack[this._resultStack.length - 1].push(q);\n    }\n    claimResult() {\n        const r = this._resultStack[0];\n        if (r.length === 1)\n            return r[0];\n        return r;\n    }\n}\n/**\n * class for converting variant point data into more specific forms.\n * @internal\n */\nexport class VariantPointDataStream {\n    /** Invoke a callback with each x,y,z from an array of points in variant forms.\n     * @param startChainCallback called to announce the beginning of points (or recursion)\n     * @param pointCallback (index, x,y,z) = function to receive point coordinates one by one\n     * @param endChainCallback called to announce the end of handling of an array.\n     */\n    static streamXYZ(data, handler) {\n        let numPoint = 0;\n        if (Array.isArray(data)) {\n            // If the first entry is a point, expect the entire array to be points.\n            // otherwise recurse to each member of this array.\n            if (data.length > 0 && Point3d.isAnyImmediatePointType(data[0])) {\n                handler.startChain(data, true);\n                for (const p of data) {\n                    const x = Point3d.accessX(p);\n                    const y = Point3d.accessY(p);\n                    const z = Point3d.accessZ(p, 0);\n                    if (x !== undefined && y !== undefined)\n                        handler.handleXYZ(x, y, z);\n                    numPoint++;\n                }\n                handler.endChain(data, true);\n            }\n            else {\n                // This is an array that does not immediately have points.\n                handler.startChain(data, false);\n                for (const child of data) {\n                    numPoint += this.streamXYZ(child, handler);\n                }\n                handler.endChain(data, false);\n            }\n        }\n        else if (data instanceof IndexedXYZCollection) {\n            handler.startChain(data, true);\n            const q = VariantPointDataStream._workPoint = Point3d.create(0, 0, 0, VariantPointDataStream._workPoint);\n            for (let i = 0; i < data.length; i++) {\n                data.getPoint3dAtCheckedPointIndex(i, q);\n                numPoint++;\n                handler.handleXYZ(q.x, q.y, q.z);\n            }\n            handler.endChain(data, true);\n        }\n        return numPoint;\n    }\n}\n//# sourceMappingURL=PointStreaming.js.map",
      "start": 1693508124070,
      "end": 1693508124142,
      "sourcemaps": null
    }
  ]
}
