{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/ThematicSensors.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { assert, dispose } from \"@itwin/core-bentley\";\nimport { Range3d, Transform } from \"@itwin/core-geometry\";\nimport { ThematicDisplaySensor } from \"@itwin/core-common\";\nimport { GL } from \"./GL\";\nimport { Texture2DHandle } from \"./Texture\";\nimport { TextureUnit } from \"./RenderFlags\";\n/** Maintains a floating-point texture representing a list of thematic sensors.\n * @internal\n */\nexport class ThematicSensors {\n    get numSensors() { return this._sensors.length; }\n    matchesTarget(target) {\n        return target === this.target && this.sensorSettings === target.plan.thematic?.sensorSettings;\n    }\n    static create(target, range) {\n        let sensors = [];\n        if (target.plan.thematic !== undefined) {\n            sensors = _accumulateSensorsInRange(target.plan.thematic.sensorSettings.sensors, range, target.currentTransform, target.plan.thematic.sensorSettings.distanceCutoff);\n        }\n        const obj = this.createFloat(target, range, sensors);\n        obj._update(obj.target.uniforms.frustum.viewMatrix);\n        return obj;\n    }\n    get isDisposed() { return this._texture.handle.isDisposed; }\n    dispose() {\n        dispose(this._texture.handle);\n    }\n    bindNumSensors(uniform) {\n        uniform.setUniform1i(this.numSensors);\n    }\n    bindTexture(uniform) {\n        this._texture.handle.bindSampler(uniform, TextureUnit.ThematicSensors);\n    }\n    get bytesUsed() { return this._texture.handle.bytesUsed; }\n    get texture() { return this._texture.handle; }\n    _update(viewMatrix) {\n        this._viewMatrix.setFrom(viewMatrix);\n        this.reset();\n        for (const sensor of this._sensors) {\n            const position = this._viewMatrix.multiplyPoint3d(sensor.position);\n            this.appendSensor(position, sensor.value);\n        }\n        this._texture.handle.replaceTextureData(this._texture.data);\n    }\n    update(viewMatrix) {\n        if (!this._viewMatrix.isAlmostEqual(viewMatrix)) {\n            this._update(viewMatrix);\n        }\n    }\n    constructor(texture, target, range, sensors) {\n        /** Position at which to write next texture data. */\n        this._curPos = 0;\n        this._viewMatrix = Transform.createIdentity();\n        this.target = target;\n        this.range = range;\n        this.sensorSettings = target.plan.thematic?.sensorSettings;\n        this._sensors = sensors;\n        this._texture = texture;\n        this._view = new DataView(texture.data.buffer);\n    }\n    static createFloat(target, range, sensors) {\n        const data = new Float32Array(sensors.length * 4);\n        const handle = Texture2DHandle.createForData(1, sensors.length, data, false, GL.Texture.WrapMode.ClampToEdge, GL.Texture.Format.Rgba);\n        assert(undefined !== handle);\n        return new this({ handle, data }, target, range, sensors);\n    }\n    append(value) { this.appendFloat(value); }\n    appendFloat(value) {\n        this._view.setFloat32(this._curPos, value, true);\n        this.advance(4);\n    }\n    appendUint8(value) {\n        this._view.setUint8(this._curPos, value);\n        this.advance(1);\n    }\n    advance(numBytes) { this._curPos += numBytes; }\n    reset() { this._curPos = 0; }\n    appendValues(a, b, c, d) {\n        this.append(a);\n        this.append(b);\n        this.append(c);\n        this.append(d);\n    }\n    appendSensor(position, value) { this.appendValues(position.x, position.y, position.z, value); }\n}\nfunction _sensorRadiusAffectsRange(sensor, sensorRadius, range) {\n    const distance = range.distanceToPoint(sensor.position);\n    return !(distance > sensorRadius);\n}\nconst scratchRange = Range3d.createNull();\nfunction _accumulateSensorsInRange(sensors, range, transform, distanceCutoff) {\n    const retSensors = [];\n    transform.multiplyRange(range, scratchRange);\n    for (const sensor of sensors) {\n        const position = sensor.position;\n        if (distanceCutoff <= 0 || _sensorRadiusAffectsRange(sensor, distanceCutoff, scratchRange)) {\n            const value = sensor.value;\n            retSensors.push(ThematicDisplaySensor.fromJSON({ position, value }));\n        }\n    }\n    return retSensors;\n}\n//# sourceMappingURL=ThematicSensors.js.map",
      "start": 1693508123733,
      "end": 1693508123973,
      "sourcemaps": null
    }
  ]
}
