{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/RenderCommands.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { assert } from \"@itwin/core-bentley\";\nimport { Range3d } from \"@itwin/core-geometry\";\nimport { Frustum, FrustumPlanes, RenderMode } from \"@itwin/core-common\";\nimport { SurfaceType } from \"../../common/render/primitives/SurfaceParams\";\nimport { PopBatchCommand, PopBranchCommand, PopClipCommand, PrimitiveCommand, PushBatchCommand, PushBranchCommand, PushClipCommand, PushStateCommand, } from \"./DrawCommand\";\nimport { Branch, GraphicsArray } from \"./Graphic\";\nimport { LayerCommandLists } from \"./LayerCommands\";\nimport { MeshGraphic } from \"./Mesh\";\nimport { Pass } from \"./RenderFlags\";\n/** A list of DrawCommands to be rendered, ordered by render pass.\n * @internal\n */\nexport class RenderCommands {\n    get target() { return this._target; }\n    [Symbol.iterator]() {\n        return this._commands[Symbol.iterator]();\n    }\n    get isEmpty() {\n        for (const commands of this._commands)\n            if (0 < commands.length)\n                return false;\n        return true;\n    }\n    get isDrawingLayers() {\n        switch (this._forcedRenderPass) {\n            case 1 /* RenderPass.OpaqueLayers */:\n            case 7 /* RenderPass.TranslucentLayers */:\n            case 11 /* RenderPass.OverlayLayers */:\n                return true;\n            default:\n                return false;\n        }\n    }\n    get currentViewFlags() { return this._stack.top.viewFlags; }\n    get compositeFlags() {\n        let flags = 0 /* CompositeFlags.None */;\n        if (this.hasCommands(8 /* RenderPass.Translucent */))\n            flags |= 1 /* CompositeFlags.Translucent */;\n        if (this.hasCommands(10 /* RenderPass.Hilite */) || this.hasCommands(16 /* RenderPass.HiliteClassification */) || this.hasCommands(18 /* RenderPass.HilitePlanarClassification */))\n            flags |= 2 /* CompositeFlags.Hilite */;\n        if (this.target.wantAmbientOcclusion)\n            flags |= 4 /* CompositeFlags.AmbientOcclusion */;\n        return flags;\n    }\n    get _curBatch() { return this._batchState.currentBatch; }\n    hasCommands(pass) { return 0 !== this.getCommands(pass).length; }\n    isOpaquePass(pass) { return pass >= 2 /* RenderPass.OpaqueLinear */ && pass <= 5 /* RenderPass.OpaqueGeneral */; }\n    constructor(target, stack, batchState) {\n        this._scratchFrustum = new Frustum();\n        this._scratchRange = new Range3d();\n        this._commands = new Array(21 /* RenderPass.COUNT */);\n        this._forcedRenderPass = 255 /* RenderPass.None */;\n        this._addLayersAsNormalGraphics = false;\n        this._opaqueOverrides = false;\n        this._translucentOverrides = false;\n        this._addTranslucentAsOpaque = false; // true when rendering for _ReadPixels to force translucent items to be drawn in opaque pass.\n        this._target = target;\n        this._stack = stack;\n        this._batchState = batchState;\n        this._layers = new LayerCommandLists(this);\n        for (let i = 0; i < 21 /* RenderPass.COUNT */; ++i)\n            this._commands[i] = [];\n    }\n    reset(target, stack, batchState) {\n        this._target = target;\n        this._stack = stack;\n        this._batchState = batchState;\n        this.clear();\n    }\n    collectGraphicsForPlanarProjection(scene) {\n        assert(this._forcedRenderPass === 255 /* RenderPass.None */);\n        assert(!this._addLayersAsNormalGraphics);\n        this._addLayersAsNormalGraphics = true;\n        this.addGraphics(scene);\n        this._addLayersAsNormalGraphics = false;\n    }\n    addGraphics(scene, forcedPass = 255 /* RenderPass.None */) {\n        this._forcedRenderPass = forcedPass;\n        scene.forEach((entry) => entry.addCommands(this));\n        this._forcedRenderPass = 255 /* RenderPass.None */;\n    }\n    /** Add backgroundMap graphics to their own render pass. */\n    addBackgroundMapGraphics(backgroundMapGraphics) {\n        this._forcedRenderPass = 15 /* RenderPass.BackgroundMap */;\n        backgroundMapGraphics.forEach((entry) => entry.addCommands(this));\n        this._forcedRenderPass = 255 /* RenderPass.None */;\n    }\n    /** Add overlay graphics to the world overlay pass */\n    addOverlayGraphics(overlayGraphics) {\n        this._forcedRenderPass = 12 /* RenderPass.WorldOverlay */;\n        overlayGraphics.forEach((entry) => entry.addCommands(this));\n        this._forcedRenderPass = 255 /* RenderPass.None */;\n    }\n    addDecorations(dec, forcedPass = 255 /* RenderPass.None */) {\n        this._forcedRenderPass = forcedPass;\n        for (const entry of dec) {\n            entry.addCommands(this);\n        }\n        this._forcedRenderPass = 255 /* RenderPass.None */;\n    }\n    addWorldDecorations(decs) {\n        const world = this.target.getWorldDecorations(decs);\n        this.pushAndPopBranch(world, () => {\n            for (const entry of world.branch.entries) {\n                entry.addCommands(this);\n            }\n        });\n    }\n    addPickableDecorations(decs) {\n        if (undefined !== decs.normal) {\n            for (const normal of decs.normal) {\n                const gf = normal;\n                if (gf.isPickable)\n                    gf.addCommands(this);\n            }\n        }\n        if (undefined !== decs.world) {\n            const world = this.target.getWorldDecorations(decs.world);\n            this.pushAndPopBranch(world, () => {\n                for (const gf of world.branch.entries) {\n                    if (gf.isPickable)\n                        gf.addCommands(this);\n                }\n            });\n        }\n    }\n    addBackground(gf) {\n        if (undefined === gf)\n            return;\n        assert(255 /* RenderPass.None */ === this._forcedRenderPass);\n        this._forcedRenderPass = 0 /* RenderPass.Background */;\n        this.pushAndPopState(this.target.decorationsState, () => gf.addCommands(this));\n        this._forcedRenderPass = 255 /* RenderPass.None */;\n    }\n    addSkyBox(gf) {\n        if (undefined === gf)\n            return;\n        assert(255 /* RenderPass.None */ === this._forcedRenderPass);\n        this._forcedRenderPass = 14 /* RenderPass.SkyBox */;\n        this.pushAndPopState(this.target.decorationsState, () => gf.addCommands(this));\n        this._forcedRenderPass = 255 /* RenderPass.None */;\n    }\n    addPrimitiveCommand(command, pass) {\n        if (undefined === pass)\n            pass = command.getPass(this.target);\n        if (\"none\" === pass) // Edges will return none if they don't want to draw at all (edges not turned on).\n            return;\n        if (255 /* RenderPass.None */ !== this._forcedRenderPass) {\n            // Add the command to the forced render pass (background).\n            this.getCommands(this._forcedRenderPass).push(command);\n            return;\n        }\n        if (!command.hasFeatures) {\n            // Draw in general opaque pass so they are not in pick data.\n            switch (pass) {\n                case \"opaque-linear\":\n                case \"opaque-planar\":\n                    pass = \"opaque\";\n                    break;\n                case \"opaque-planar-translucent\":\n                    pass = \"opaque-translucent\";\n                    break;\n            }\n        }\n        const haveFeatureOverrides = (this._opaqueOverrides || this._translucentOverrides) && command.opcode && command.hasFeatures;\n        if (Pass.rendersTranslucent(pass) && this._addTranslucentAsOpaque) {\n            switch (command.renderOrder) {\n                case 12 /* RenderOrder.PlanarLitSurface */:\n                case 11 /* RenderOrder.PlanarUnlitSurface */:\n                case 2 /* RenderOrder.BlankingRegion */:\n                    pass = \"opaque-planar\";\n                    break;\n                case 4 /* RenderOrder.LitSurface */:\n                case 3 /* RenderOrder.UnlitSurface */:\n                    pass = \"opaque\";\n                    break;\n                default:\n                    pass = \"opaque-linear\";\n                    break;\n            }\n        }\n        const isDoublePass = Pass.rendersOpaqueAndTranslucent(pass);\n        const renderTranslucentDuringOpaque = isDoublePass || (this._opaqueOverrides && haveFeatureOverrides);\n        if (renderTranslucentDuringOpaque && Pass.rendersTranslucent(pass) && !command.primitive.cachedGeometry.alwaysRenderTranslucent) {\n            let opaquePass;\n            if (Pass.rendersOpaqueAndTranslucent(pass)) {\n                opaquePass = Pass.toOpaquePass(pass);\n            }\n            else {\n                switch (command.renderOrder) {\n                    case 12 /* RenderOrder.PlanarLitSurface */:\n                    case 11 /* RenderOrder.PlanarUnlitSurface */:\n                    case 2 /* RenderOrder.BlankingRegion */:\n                        opaquePass = 3 /* RenderPass.OpaquePlanar */;\n                        break;\n                    case 4 /* RenderOrder.LitSurface */:\n                    case 3 /* RenderOrder.UnlitSurface */:\n                        opaquePass = 5 /* RenderPass.OpaqueGeneral */;\n                        break;\n                    default:\n                        opaquePass = 2 /* RenderPass.OpaqueLinear */;\n                        break;\n                }\n            }\n            this.getCommands(opaquePass).push(command);\n        }\n        const renderOpaqueDuringTranslucent = isDoublePass || (this._translucentOverrides && haveFeatureOverrides);\n        if (renderOpaqueDuringTranslucent && Pass.rendersOpaque(pass) && !this._addTranslucentAsOpaque)\n            this.getCommands(8 /* RenderPass.Translucent */).push(command);\n        if (!Pass.rendersOpaqueAndTranslucent(pass))\n            this.getCommands(Pass.toRenderPass(pass)).push(command);\n    }\n    getCommands(pass) {\n        let idx = pass;\n        assert(idx < this._commands.length);\n        if (idx >= this._commands.length)\n            idx -= 1;\n        return this._commands[idx];\n    }\n    replaceCommands(pass, cmds) {\n        const idx = pass;\n        this._commands[idx].splice(0);\n        this._commands[idx] = cmds;\n    }\n    addHiliteBranch(branch, pass) {\n        this.pushAndPopBranchForPass(pass, branch, () => {\n            branch.branch.entries.forEach((entry) => entry.addHiliteCommands(this, pass));\n        });\n    }\n    processLayers(container) {\n        assert(255 /* RenderPass.None */ === this._forcedRenderPass);\n        if (255 /* RenderPass.None */ !== this._forcedRenderPass)\n            return;\n        this._forcedRenderPass = container.renderPass;\n        this._layers.processLayers(container, () => container.graphic.addCommands(this));\n        this._forcedRenderPass = 255 /* RenderPass.None */;\n    }\n    addLayerCommands(layer) {\n        if (this._addLayersAsNormalGraphics) {\n            // GraphicsCollectorDrawArgs wants to collect graphics to project to a plane for masking.\n            // It bypasses PlanProjectionTreeReference.createDrawArgs which would otherwise wrap the graphics in a LayerContainer.\n            assert(this._forcedRenderPass === 255 /* RenderPass.None */);\n            this._forcedRenderPass = 5 /* RenderPass.OpaqueGeneral */;\n            layer.graphic.addCommands(this);\n            this._forcedRenderPass = 255 /* RenderPass.None */;\n            return;\n        }\n        assert(this.isDrawingLayers);\n        if (!this.isDrawingLayers)\n            return;\n        // Let the graphic add its commands. Afterward, pull them out and add them to the LayerCommands.\n        this._layers.currentLayer = layer;\n        layer.graphic.addCommands(this);\n        const cmds = this.getCommands(this._forcedRenderPass);\n        this._layers.addCommands(cmds);\n        cmds.length = 0;\n        this._layers.currentLayer = undefined;\n    }\n    addHiliteLayerCommands(graphic, pass) {\n        assert(this.isDrawingLayers || this._addLayersAsNormalGraphics);\n        if (!this.isDrawingLayers && !this._addLayersAsNormalGraphics)\n            return;\n        const prevPass = this._forcedRenderPass;\n        this._forcedRenderPass = 255 /* RenderPass.None */;\n        graphic.addHiliteCommands(this, pass);\n        this._forcedRenderPass = prevPass;\n    }\n    getAnimationBranchState(branch) {\n        const animId = branch.branch.animationId;\n        return undefined !== animId ? this.target.animationBranches?.branchStates.get(animId) : undefined;\n    }\n    pushAndPopBranchForPass(pass, branch, func) {\n        assert(!this.isDrawingLayers);\n        const animState = this.getAnimationBranchState(branch);\n        if (animState?.omit)\n            return;\n        assert(255 /* RenderPass.None */ !== pass);\n        this._stack.pushBranch(branch);\n        if (branch.planarClassifier)\n            branch.planarClassifier.pushBatchState(this._batchState);\n        if (branch.secondaryClassifiers)\n            branch.secondaryClassifiers.forEach((classifier) => classifier.pushBatchState(this._batchState));\n        const cmds = this.getCommands(pass);\n        const clip = animState?.clip;\n        const pushClip = undefined !== clip ? new PushClipCommand(clip) : undefined;\n        if (pushClip)\n            cmds.push(pushClip);\n        const push = new PushBranchCommand(branch);\n        cmds.push(push);\n        func();\n        this._stack.pop();\n        if (cmds[cmds.length - 1] === push) {\n            cmds.pop();\n            if (pushClip)\n                cmds.pop();\n        }\n        else {\n            cmds.push(PopBranchCommand.instance);\n            if (pushClip)\n                cmds.push(PopClipCommand.instance);\n        }\n    }\n    pushAndPop(push, pop, func) {\n        if (this.isDrawingLayers) {\n            this._commands[10 /* RenderPass.Hilite */].push(push);\n            this._layers.pushAndPop(push, pop, func);\n            const cmds = this._commands[10 /* RenderPass.Hilite */];\n            if (0 < cmds.length && cmds[cmds.length - 1] === push)\n                cmds.pop();\n            else\n                cmds.push(pop);\n            return;\n        }\n        if (255 /* RenderPass.None */ === this._forcedRenderPass) {\n            // Need to make sure the push command precedes any subsequent commands added to any render pass.\n            for (const cmds of this._commands)\n                cmds.push(push);\n        }\n        else {\n            // May want to add hilite commands as well - add the push command to that pass.\n            this._commands[this._forcedRenderPass].push(push);\n            this._commands[10 /* RenderPass.Hilite */].push(push);\n        }\n        func();\n        // Remove push command from any passes that didn't receive any commands; add the pop command to any passes that did.\n        if (255 /* RenderPass.None */ === this._forcedRenderPass) {\n            for (const cmds of this._commands) {\n                assert(0 < cmds.length);\n                if (0 < cmds.length && cmds[cmds.length - 1] === push)\n                    cmds.pop();\n                else\n                    cmds.push(pop);\n            }\n        }\n        else {\n            assert(0 < this._commands[this._forcedRenderPass].length);\n            assert(0 < this._commands[10 /* RenderPass.Hilite */].length);\n            let cmds = this._commands[this._forcedRenderPass];\n            if (cmds[cmds.length - 1] === push)\n                cmds.pop();\n            else\n                cmds.push(pop);\n            cmds = this._commands[10 /* RenderPass.Hilite */];\n            if (cmds[cmds.length - 1] === push)\n                cmds.pop();\n            else\n                cmds.push(pop);\n        }\n    }\n    pushAndPopBranch(branch, func) {\n        const animState = this.getAnimationBranchState(branch);\n        if (animState?.omit)\n            return;\n        if (animState?.clip)\n            this.pushAndPop(new PushClipCommand(animState.clip), PopClipCommand.instance, () => this._pushAndPopBranch(branch, func));\n        else\n            this._pushAndPopBranch(branch, func);\n    }\n    _pushAndPopBranch(branch, func) {\n        this._stack.pushBranch(branch);\n        if (branch.planarClassifier)\n            branch.planarClassifier.pushBatchState(this._batchState);\n        if (branch.secondaryClassifiers)\n            branch.secondaryClassifiers.forEach((classifier) => classifier.pushBatchState(this._batchState));\n        this.pushAndPop(new PushBranchCommand(branch), PopBranchCommand.instance, func);\n        this._stack.pop();\n    }\n    pushAndPopState(state, func) {\n        this._stack.pushState(state);\n        this.pushAndPop(new PushStateCommand(state), PopBranchCommand.instance, func);\n        this._stack.pop();\n    }\n    clear() {\n        assert(this._batchState.isEmpty);\n        this._clearCommands();\n    }\n    _clearCommands() {\n        this._commands.forEach((cmds) => cmds.splice(0));\n        this._layers.clear();\n    }\n    initForPickOverlayDecorations(overlays) {\n        for (const overlay of overlays) {\n            const gf = overlay;\n            if (gf.isPickable)\n                gf.addCommands(this);\n        }\n    }\n    initForPickOverlays(sceneOverlays, worldOverlayDecorations, viewOverlayDecorations) {\n        this._clearCommands();\n        this._addTranslucentAsOpaque = true;\n        for (const sceneGf of sceneOverlays)\n            sceneGf.addCommands(this);\n        if (worldOverlayDecorations?.length) {\n            this.pushAndPopState(this.target.decorationsState, () => {\n                this.initForPickOverlayDecorations(worldOverlayDecorations);\n            });\n        }\n        if (viewOverlayDecorations?.length) {\n            this.pushAndPopState(this.target.decorationsState.withViewCoords(), () => {\n                this.initForPickOverlayDecorations(viewOverlayDecorations);\n            });\n        }\n        this._addTranslucentAsOpaque = false;\n    }\n    initForReadPixels(gfx) {\n        this.clear();\n        // Set flag to force translucent geometry to be put into the opaque pass.\n        this._addTranslucentAsOpaque = true;\n        // Add the scene graphics.\n        this.addGraphics(gfx.foreground);\n        // Also add any pickable decorations.\n        if (undefined !== gfx.decorations)\n            this.addPickableDecorations(gfx.decorations);\n        // Also background map is pickable\n        this.addBackgroundMapGraphics(gfx.background);\n        this._addTranslucentAsOpaque = false;\n        this.setupClassificationByVolume();\n        this._layers.outputCommands();\n    }\n    initForRender(gfx) {\n        this.clear();\n        this.addGraphics(gfx.foreground);\n        this.addBackgroundMapGraphics(gfx.background);\n        this.addOverlayGraphics(gfx.overlays);\n        const dynamics = gfx.dynamics;\n        if (dynamics && dynamics.length > 0)\n            this.addDecorations(dynamics);\n        const dec = gfx.decorations;\n        if (undefined !== dec) {\n            this.addBackground(dec.viewBackground);\n            this.addSkyBox(dec.skyBox);\n            if (undefined !== dec.normal && 0 < dec.normal.length)\n                this.addGraphics(dec.normal);\n            if (undefined !== dec.world && 0 < dec.world.length)\n                this.addWorldDecorations(dec.world);\n            this.pushAndPopState(this.target.decorationsState, () => {\n                if (undefined !== dec.viewOverlay && 0 < dec.viewOverlay.length)\n                    this.addDecorations(dec.viewOverlay, 13 /* RenderPass.ViewOverlay */);\n                if (undefined !== dec.worldOverlay && 0 < dec.worldOverlay.length)\n                    this.addDecorations(dec.worldOverlay, 12 /* RenderPass.WorldOverlay */);\n            });\n        }\n        this.setupClassificationByVolume();\n        this._layers.outputCommands();\n    }\n    addPrimitive(prim) {\n        // ###TODO Would be nice if we could detect outside active volume here, but active volume only applies to specific render passes\n        // if (this.target.isGeometryOutsideActiveVolume(prim.cachedGeometry))\n        //   return;\n        if (undefined !== this._frustumPlanes) { // See if we can cull this primitive.\n            if (\"classification\" === prim.getPass(this.target)) {\n                const geom = prim.cachedGeometry;\n                geom.computeRange(this._scratchRange);\n                let frustum = Frustum.fromRange(this._scratchRange, this._scratchFrustum);\n                frustum = frustum.transformBy(this.target.currentTransform, frustum);\n                if (FrustumPlanes.Containment.Outside === this._frustumPlanes.computeFrustumContainment(frustum)) {\n                    return;\n                }\n            }\n        }\n        const command = new PrimitiveCommand(prim);\n        this.addPrimitiveCommand(command);\n        if (255 /* RenderPass.None */ === this._forcedRenderPass && prim.isEdge) {\n            const vf = this.target.currentViewFlags;\n            if (vf.renderMode !== RenderMode.Wireframe && vf.hiddenEdges)\n                this.getCommands(9 /* RenderPass.HiddenEdge */).push(command);\n        }\n    }\n    addBranch(branch) {\n        this.pushAndPopBranch(branch, () => {\n            branch.branch.entries.forEach((entry) => entry.addCommands(this));\n        });\n    }\n    computeBatchHiliteRenderPass(batch) {\n        let pass = 10 /* RenderPass.Hilite */;\n        if (batch.graphic instanceof MeshGraphic) {\n            const mg = batch.graphic;\n            if (SurfaceType.VolumeClassifier === mg.surfaceType)\n                pass = 16 /* RenderPass.HiliteClassification */;\n        }\n        else if (batch.graphic instanceof GraphicsArray) {\n            const ga = batch.graphic;\n            if (ga.graphics[0] instanceof MeshGraphic) {\n                const mg = ga.graphics[0];\n                if (SurfaceType.VolumeClassifier === mg.surfaceType)\n                    pass = 16 /* RenderPass.HiliteClassification */;\n            }\n            else if (ga.graphics[0] instanceof Branch) {\n                const b = ga.graphics[0];\n                if (b.branch.entries.length > 0 && b.branch.entries[0] instanceof MeshGraphic) {\n                    const mg = b.branch.entries[0];\n                    if (SurfaceType.VolumeClassifier === mg.surfaceType)\n                        pass = 16 /* RenderPass.HiliteClassification */;\n                }\n            }\n        }\n        return pass;\n    }\n    addBatch(batch) {\n        if (batch.locateOnly && !this.target.isReadPixelsInProgress)\n            return;\n        // Batches (aka element tiles) should only draw during ordinary (translucent or opaque) passes.\n        // They may draw during both, or neither.\n        // NB: This is no longer true - pickable overlay decorations are defined as Batches. Problem?\n        // assert(RenderPass.None === this._forcedRenderPass);\n        assert(!this._opaqueOverrides && !this._translucentOverrides);\n        assert(undefined === this._curBatch);\n        // If all features are overridden to be invisible, draw no graphics in this batch\n        const overrides = batch.getOverrides(this.target);\n        if (overrides.allHidden)\n            return;\n        if (!batch.range.isNull) {\n            // ###TODO Would be nice if we could detect outside active volume here, but active volume only applies to specific render passes\n            // if (this.target.isRangeOutsideActiveVolume(batch.range))\n            //   return;\n            if (undefined !== this._frustumPlanes) {\n                let frustum = Frustum.fromRange(batch.range, this._scratchFrustum);\n                frustum = frustum.transformBy(this.target.currentTransform, frustum);\n                if (FrustumPlanes.Containment.Outside === this._frustumPlanes.computeFrustumContainment(frustum)) {\n                    return;\n                }\n            }\n        }\n        const classifier = this._stack.top.planarClassifier;\n        this._batchState.push(batch, true);\n        this.pushAndPop(new PushBatchCommand(batch), PopBatchCommand.instance, () => {\n            if (this.currentViewFlags.transparency || overrides.anyViewIndependentTranslucent) {\n                this._opaqueOverrides = overrides.anyOpaque;\n                this._translucentOverrides = overrides.anyTranslucent;\n                if (undefined !== classifier) {\n                    this._opaqueOverrides = this._opaqueOverrides || classifier.anyOpaque;\n                    this._translucentOverrides = this._translucentOverrides || classifier.anyTranslucent;\n                }\n            }\n            // If we have an active volume classifier then force all batches for the reality data being classified into a special render pass.\n            let savedForcedRenderPass = 255 /* RenderPass.None */;\n            if (undefined !== this.target.activeVolumeClassifierModelId && batch.featureTable.batchModelId === this.target.activeVolumeClassifierModelId) {\n                savedForcedRenderPass = this._forcedRenderPass;\n                this._forcedRenderPass = 20 /* RenderPass.VolumeClassifiedRealityData */;\n            }\n            batch.graphic.addCommands(this);\n            if (20 /* RenderPass.VolumeClassifiedRealityData */ === this._forcedRenderPass)\n                this._forcedRenderPass = savedForcedRenderPass;\n            // If the batch contains hilited features, need to render them in the hilite pass\n            const anyHilited = overrides.anyHilited;\n            const planarClassifierHilited = undefined !== classifier && classifier.anyHilited;\n            if (anyHilited || planarClassifierHilited)\n                batch.graphic.addHiliteCommands(this, planarClassifierHilited ? 18 /* RenderPass.HilitePlanarClassification */ : this.computeBatchHiliteRenderPass(batch));\n        });\n        this._opaqueOverrides = this._translucentOverrides = false;\n        this._batchState.pop();\n    }\n    // Define a culling frustum. Commands associated with Graphics whose ranges do not intersect the frustum will be skipped.\n    setCheckRange(frustum) { this._frustumPlanes = FrustumPlanes.fromFrustum(frustum); }\n    // Clear the culling frustum.\n    clearCheckRange() { this._frustumPlanes = undefined; }\n    setupClassificationByVolume() {\n        // To make it easier to process the classifiers individually, set up a secondary command list for them where they\n        // are each separated by their own pushes & pops so that they can easily be drawn individually.  This now supports\n        // nested branches and batches.\n        const groupedCmds = this._commands[6 /* RenderPass.Classification */];\n        const byIndexCmds = this._commands[17 /* RenderPass.ClassificationByIndex */];\n        const pushCommands = []; // will contain current set of pushes ahead of a primitive\n        for (const cmd of groupedCmds) {\n            switch (cmd.opcode) {\n                case \"pushBranch\":\n                case \"pushBatch\":\n                case \"pushState\":\n                    pushCommands.push(cmd);\n                    break;\n                case \"drawPrimitive\":\n                    for (const pushCmd of pushCommands) {\n                        byIndexCmds.push(pushCmd);\n                    }\n                    byIndexCmds.push(cmd);\n                    for (let i = pushCommands.length - 1; i >= 0; --i) {\n                        if (\"pushBatch\" === pushCommands[i].opcode)\n                            byIndexCmds.push(PopBatchCommand.instance);\n                        else // should be eith pushBranch or pushState opcode\n                            byIndexCmds.push(PopBranchCommand.instance);\n                    }\n                    break;\n                case \"popBatch\":\n                case \"popBranch\":\n                    pushCommands.pop();\n                    break;\n            }\n        }\n    }\n    dump() {\n        const dump = [\n            { name: \"Primitives\", count: 0 },\n            { name: \"Batches\", count: 0 },\n            { name: \"Branches\", count: 0 },\n        ];\n        for (const cmds of this._commands) {\n            for (const cmd of cmds) {\n                let index;\n                switch (cmd.opcode) {\n                    case \"drawPrimitive\":\n                        index = 0;\n                        break;\n                    case \"pushBatch\":\n                        index = 1;\n                        break;\n                    case \"pushBranch\":\n                        index = 2;\n                        break;\n                    default:\n                        continue;\n                }\n                dump[index].count++;\n            }\n        }\n        return dump;\n    }\n}\n//# sourceMappingURL=RenderCommands.js.map",
      "start": 1693508123716,
      "end": 1693508123862,
      "sourcemaps": null
    }
  ]
}
