{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/solid/Box.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\nimport { LineString3d } from \"../curve/LineString3d\";\nimport { Loop } from \"../curve/Loop\";\nimport { Geometry } from \"../Geometry\";\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\nimport { Transform } from \"../geometry3d/Transform\";\nimport { SolidPrimitive } from \"./SolidPrimitive\";\n/**\n * A box-like solid defined by\n * * A local coordinate frame\n *   * (0,0,0) is left lower rear corner of box (considering \"left\" to reference x, \"lower\" to reference y, \"rear and front\" to reference z=0 and z=1)\n *   * (0,0,1) is left lower front corner.\n *   * (baseX,baseY,z) is right upper corner at z\n *   * note that the frame x and y columns are usually unit vectors in local space, but z is full rear to front vector\n * * The separate values for base and top x and y allow the box to be a \"view frustum\" with parallel back and front planes but independent x and y bellows effects.\n * @public\n */\nexport class Box extends SolidPrimitive {\n    constructor(map, baseX, baseY, topX, topY, capped) {\n        super(capped);\n        /** String name for schema properties */\n        this.solidPrimitiveType = \"box\";\n        this._localToWorld = map;\n        this._baseX = baseX;\n        this._baseY = baseY;\n        this._topX = topX;\n        this._topY = topY;\n    }\n    /** Return a clone */\n    clone() {\n        return new Box(this._localToWorld.clone(), this._baseX, this._baseY, this._topX, this._topY, this.capped);\n    }\n    /** Return a coordinate frame (right handed unit vectors)\n     * * origin lower left of box\n     * * x direction on base rectangle x edge\n     * * y direction in base rectangle\n     * * z direction perpendicular\n     */\n    getConstructiveFrame() {\n        return this._localToWorld.cloneRigid();\n    }\n    /** Apply the transform to the box's `localToWorld` frame.\n     * * Note that this may make the frame nonrigid.\n     */\n    tryTransformInPlace(transform) {\n        if (transform.matrix.isSingular())\n            return false;\n        transform.multiplyTransformTransform(this._localToWorld, this._localToWorld);\n        return true;\n    }\n    /** Clone the box and immediately apply `transform` to the local frame of the clone. */\n    cloneTransformed(transform) {\n        const result = this.clone();\n        transform.multiplyTransformTransform(result._localToWorld, result._localToWorld);\n        return result;\n    }\n    /**\n     * Create a new box from vector and size daa.\n     * @param origin Origin of base rectangle\n     * @param vectorX  Direction for base rectangle\n     * @param vectorY Direction for base rectangle\n     * @param topOrigin origin of top rectangle\n     * @param baseX size factor for base rectangle (multiplies vectorX)\n     * @param baseY size factor for base rectangle (multiplies vectorY)\n     * @param topX size factor for top rectangle (multiplies vectorX)\n     * @param topY size factor for top rectangle (multiplies vectorY)\n     * @param capped true to define top and bottom closure caps\n     */\n    static createDgnBox(origin, vectorX, vectorY, topOrigin, baseX, baseY, topX, topY, capped) {\n        const vectorZ = origin.vectorTo(topOrigin);\n        const localToWorld = Transform.createOriginAndMatrixColumns(origin, vectorX, vectorY, vectorZ);\n        return new Box(localToWorld, baseX, baseY, topX, topY, capped);\n    }\n    /**\n     * Create a new box with xy directions taken from columns of the `axes` matrix.\n     * @param origin Origin of base rectangle\n     * @param axes  Direction for base rectangle\n     * @param topOrigin origin of top rectangle\n     * @param baseX size factor for base rectangle (multiplies vectorX)\n     * @param baseY size factor for base rectangle (multiplies vectorY)\n     * @param topX size factor for top rectangle (multiplies vectorX)\n     * @param topY size factor for top rectangle (multiplies vectorY)\n     * @param capped true to define top and bottom closure caps\n     */\n    static createDgnBoxWithAxes(origin, axes, topOrigin, baseX, baseY, topX, topY, capped) {\n        return Box.createDgnBox(origin, axes.columnX(), axes.columnY(), topOrigin, baseX, baseY, topX, topY, capped);\n    }\n    /**\n     * Create an axis-aligned `Box` primitive for a range.\n     * @param range range corners Origin of base rectangle\n     * @param capped true to define top and bottom closure caps\n     */\n    static createRange(range, capped) {\n        if (!range.isNull) {\n            const lowPoint = range.low;\n            const xSize = range.xLength();\n            const ySize = range.yLength();\n            const zPoint = range.low.clone();\n            zPoint.z = zPoint.z + range.zLength();\n            return Box.createDgnBox(lowPoint, Vector3d.unitX(), Vector3d.unitY(), zPoint, xSize, ySize, xSize, ySize, capped);\n        }\n        return undefined;\n    }\n    /** (property accessor) return the x length at z = 0 */\n    getBaseX() { return this._baseX; }\n    /** (property accessor) return the y length at z = 0 */\n    getBaseY() { return this._baseY; }\n    /** (property accessor) return the x length at z = 1 */\n    getTopX() { return this._topX; }\n    /** (property accessor) return the x length at z = 1 */\n    getTopY() { return this._topY; }\n    /** (property accessor) return the local coordinates point (0,0,0) to world */\n    getBaseOrigin() { return this._localToWorld.multiplyXYZ(0, 0, 0); }\n    /** (property accessor) return the local coordinates point (0,0,1) to world */\n    getTopOrigin() { return this._localToWorld.multiplyXYZ(0, 0, 1); }\n    /** (property accessor) return the local coordinate frame x vector */\n    getVectorX() { return this._localToWorld.matrix.columnX(); }\n    /** (property accessor) return the local coordinate frame y vector */\n    getVectorY() { return this._localToWorld.matrix.columnY(); }\n    /** (property accessor) return the local coordinate frame z vector */\n    getVectorZ() { return this._localToWorld.matrix.columnZ(); }\n    /** Test of `other` is also of class `Box` */\n    isSameGeometryClass(other) { return other instanceof Box; }\n    /** test for near equality */\n    isAlmostEqual(other) {\n        if (other instanceof Box) {\n            if (this.capped !== other.capped)\n                return false;\n            if (!this._localToWorld.isAlmostEqual(other._localToWorld))\n                return false;\n            return Geometry.isSameCoordinate(this._baseX, other._baseX)\n                && Geometry.isSameCoordinate(this._baseY, other._baseY)\n                && Geometry.isSameCoordinate(this._topX, other._topX)\n                && Geometry.isSameCoordinate(this._topY, other._topY);\n        }\n        return false;\n    }\n    /** Second step of double dispatch:  call `handler.handleBox(this)` */\n    dispatchToGeometryHandler(handler) {\n        return handler.handleBox(this);\n    }\n    /** Return strokes of the cross-section rectangle at local z coordinate */\n    strokeConstantVSection(zFraction) {\n        const ax = Geometry.interpolate(this._baseX, zFraction, this._topX);\n        const ay = Geometry.interpolate(this._baseY, zFraction, this._topY);\n        const result = LineString3d.create();\n        const transform = this._localToWorld;\n        const workPoint = Point3d.create();\n        transform.multiplyXYZ(0, 0, zFraction, workPoint);\n        result.addPoint(workPoint);\n        transform.multiplyXYZ(ax, 0, zFraction, workPoint);\n        result.addPoint(workPoint);\n        transform.multiplyXYZ(ax, ay, zFraction, workPoint);\n        result.addPoint(workPoint);\n        transform.multiplyXYZ(0, ay, zFraction, workPoint);\n        result.addPoint(workPoint);\n        transform.multiplyXYZ(0, 0, zFraction, workPoint);\n        result.addPoint(workPoint);\n        return result;\n    }\n    /**\n     * Returns the 8 corners in x fastest, then y, finally z lexical order.\n     */\n    getCorners() {\n        const transform = this._localToWorld;\n        const ax = this._baseX;\n        const ay = this._baseY;\n        const bx = this._topX;\n        const by = this._topY;\n        return [\n            transform.multiplyXYZ(0, 0, 0),\n            transform.multiplyXYZ(ax, 0, 0),\n            transform.multiplyXYZ(0, ay, 0),\n            transform.multiplyXYZ(ax, ay, 0),\n            transform.multiplyXYZ(0, 0, 1),\n            transform.multiplyXYZ(bx, 0, 1),\n            transform.multiplyXYZ(0, by, 1),\n            transform.multiplyXYZ(bx, by, 1),\n        ];\n    }\n    /**\n     * Consider the box sides (not top and bottom) as a (u,v) surface with\n     * * v = 0 as the z=0 local plane\n     * * v = 1 as the z=1 local plane\n     * Return the (rectangular) section at fractional v\n     */\n    constantVSection(zFraction) {\n        const ls = this.strokeConstantVSection(zFraction);\n        return Loop.create(ls);\n    }\n    /** Extend  `rangeToExtend` by each of the 8 corners */\n    extendRange(rangeToExtend, transform) {\n        const boxTransform = this._localToWorld;\n        const ax = this._baseX;\n        const ay = this._baseY;\n        const bx = this._topX;\n        const by = this._topY;\n        if (transform) {\n            rangeToExtend.extendTransformTransformedXYZ(transform, boxTransform, 0, 0, 0);\n            rangeToExtend.extendTransformTransformedXYZ(transform, boxTransform, ax, 0, 0);\n            rangeToExtend.extendTransformTransformedXYZ(transform, boxTransform, 0, ay, 0);\n            rangeToExtend.extendTransformTransformedXYZ(transform, boxTransform, ax, ay, 0);\n            rangeToExtend.extendTransformTransformedXYZ(transform, boxTransform, 0, 0, 1);\n            rangeToExtend.extendTransformTransformedXYZ(transform, boxTransform, bx, 0, 1);\n            rangeToExtend.extendTransformTransformedXYZ(transform, boxTransform, 0, by, 1);\n            rangeToExtend.extendTransformTransformedXYZ(transform, boxTransform, bx, by, 1);\n        }\n        else {\n            rangeToExtend.extendTransformedXYZ(boxTransform, 0, 0, 0);\n            rangeToExtend.extendTransformedXYZ(boxTransform, ax, 0, 0);\n            rangeToExtend.extendTransformedXYZ(boxTransform, 0, ay, 0);\n            rangeToExtend.extendTransformedXYZ(boxTransform, ax, ay, 0);\n            rangeToExtend.extendTransformedXYZ(boxTransform, 0, 0, 1);\n            rangeToExtend.extendTransformedXYZ(boxTransform, bx, 0, 1);\n            rangeToExtend.extendTransformedXYZ(boxTransform, 0, by, 1);\n            rangeToExtend.extendTransformedXYZ(boxTransform, bx, by, 1);\n        }\n    }\n    /**\n     * @return true if this is a closed volume.\n     */\n    get isClosedVolume() {\n        return this.capped;\n    }\n}\n//# sourceMappingURL=Box.js.map",
      "start": 1693508122883,
      "end": 1693508123033,
      "sourcemaps": null
    }
  ]
}
