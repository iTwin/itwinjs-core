{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/common/lib/esm/geometry/ElementGeometry.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Geometry\n */\nimport { flatbuffers } from \"flatbuffers\";\nimport { Id64 } from \"@itwin/core-bentley\";\nimport { Angle, AngleSweep, Arc3d, BentleyGeometryFlatBuffer, FrameBuilder, LineString3d, Loop, Matrix3d, Plane3dByOriginAndUnitNormal, Point2d, Point3d, Point3dArray, PointString3d, PolyfaceQuery, Range3d, Transform, Vector3d, YawPitchRollAngles } from \"@itwin/core-geometry\";\nimport { EGFBAccessors } from \"./ElementGeometryFB\";\nimport { Base64EncodedString } from \"../Base64EncodedString\";\nimport { TextString } from \"./TextString\";\nimport { ColorDef } from \"../ColorDef\";\nimport { BackgroundFill, FillDisplay, GeometryClass, GeometryParams } from \"../GeometryParams\";\nimport { Gradient } from \"../Gradient\";\nimport { ThematicGradientSettings } from \"../ThematicDisplay\";\nimport { AreaPattern } from \"./AreaPattern\";\nimport { BRepEntity } from \"./GeometryStream\";\nimport { ImageGraphic, ImageGraphicCorners } from \"./ImageGraphic\";\nimport { LineStyle } from \"./LineStyle\";\nimport { Placement2d, Placement3d } from \"./Placement\";\nimport { isPlacement2dProps } from \"../ElementProps\";\n/** Specifies the type of an entry in a geometry stream.\n * @see [[ElementGeometryDataEntry.opcode]].\n * @public\n * @extensions\n */\nexport var ElementGeometryOpcode;\n(function (ElementGeometryOpcode) {\n    /** Local range of the next geometric primitive in the geometry stream. */\n    ElementGeometryOpcode[ElementGeometryOpcode[\"SubGraphicRange\"] = 2] = \"SubGraphicRange\";\n    /** A reference to a [GeometryPart]($backend). */\n    ElementGeometryOpcode[ElementGeometryOpcode[\"PartReference\"] = 3] = \"PartReference\";\n    /** Sets symbology for subsequent geometry to override [SubCategory]($backend) appearance */\n    ElementGeometryOpcode[ElementGeometryOpcode[\"BasicSymbology\"] = 4] = \"BasicSymbology\";\n    /** A line, line string, shape, or point string (automatic simplification of a [CurvePrimitive]($core-geometry) or [CurveCollection]($core-geometry)) */\n    ElementGeometryOpcode[ElementGeometryOpcode[\"PointPrimitive\"] = 5] = \"PointPrimitive\";\n    /** A 2d line, line string, shape, or point string (automatic simplification of a [CurvePrimitive]($core-geometry) or [CurveCollection]($core-geometry)) */\n    ElementGeometryOpcode[ElementGeometryOpcode[\"PointPrimitive2d\"] = 6] = \"PointPrimitive2d\";\n    /** Arc or ellipse (automatic simplification of a [CurvePrimitive]($core-geometry) or [CurveCollection]($core-geometry)) */\n    ElementGeometryOpcode[ElementGeometryOpcode[\"ArcPrimitive\"] = 7] = \"ArcPrimitive\";\n    /** [CurveCollection]($core-geometry) */\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    ElementGeometryOpcode[ElementGeometryOpcode[\"CurveCollection\"] = 8] = \"CurveCollection\";\n    /** [Polyface]($core-geometry) */\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    ElementGeometryOpcode[ElementGeometryOpcode[\"Polyface\"] = 9] = \"Polyface\";\n    /** [CurvePrimitive]($core-geometry) */\n    ElementGeometryOpcode[ElementGeometryOpcode[\"CurvePrimitive\"] = 10] = \"CurvePrimitive\";\n    /** [SolidPrimitive]($core-geometry) */\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    ElementGeometryOpcode[ElementGeometryOpcode[\"SolidPrimitive\"] = 11] = \"SolidPrimitive\";\n    /** [BSplineSurface3d]($core-geometry) */\n    ElementGeometryOpcode[ElementGeometryOpcode[\"BsplineSurface\"] = 12] = \"BsplineSurface\";\n    /** Opaque and [[Gradient]] fills. */\n    ElementGeometryOpcode[ElementGeometryOpcode[\"Fill\"] = 19] = \"Fill\";\n    /** Hatch, cross-hatch, or [[AreaPattern]]. */\n    ElementGeometryOpcode[ElementGeometryOpcode[\"Pattern\"] = 20] = \"Pattern\";\n    /** [[RenderMaterial]] */\n    ElementGeometryOpcode[ElementGeometryOpcode[\"Material\"] = 21] = \"Material\";\n    /** [[TextString]] */\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    ElementGeometryOpcode[ElementGeometryOpcode[\"TextString\"] = 22] = \"TextString\";\n    /** Specifies line style overrides as a [[LineStyle.Modifier]] */\n    ElementGeometryOpcode[ElementGeometryOpcode[\"LineStyleModifiers\"] = 23] = \"LineStyleModifiers\";\n    /** Boundary represention solid, sheet, or wire body as a [[BRepEntity.DataProps]] */\n    ElementGeometryOpcode[ElementGeometryOpcode[\"BRep\"] = 25] = \"BRep\";\n    /** Small single-tile raster image as an [[ImageGraphic]] */\n    ElementGeometryOpcode[ElementGeometryOpcode[\"Image\"] = 28] = \"Image\";\n})(ElementGeometryOpcode || (ElementGeometryOpcode = {}));\n/** Values for [[BRepGeometryCreate.operation]]\n * @alpha\n */\nexport var BRepGeometryOperation;\n(function (BRepGeometryOperation) {\n    /** Unite target (first entry) with one or more tool entities. */\n    BRepGeometryOperation[BRepGeometryOperation[\"Unite\"] = 0] = \"Unite\";\n    /** Subtract one or more tool entities from target entity (first entry) */\n    BRepGeometryOperation[BRepGeometryOperation[\"Subtract\"] = 1] = \"Subtract\";\n    /** Intersect target (first entry) with one or more tool entities */\n    BRepGeometryOperation[BRepGeometryOperation[\"Intersect\"] = 2] = \"Intersect\";\n    /** Sew the given set of surfaces together by joining those that share edges in common */\n    BRepGeometryOperation[BRepGeometryOperation[\"Sew\"] = 3] = \"Sew\";\n    /** Create a cut in the target (first entry) using a planar region (second entry) and optional depth */\n    BRepGeometryOperation[BRepGeometryOperation[\"Cut\"] = 4] = \"Cut\";\n    /** Create a pad or pocket in the target (first entry) using a planar region (second entry) */\n    BRepGeometryOperation[BRepGeometryOperation[\"Emboss\"] = 5] = \"Emboss\";\n    /** Create a solid from a surface by offsetting using the specified forward and backward distances */\n    BRepGeometryOperation[BRepGeometryOperation[\"Thicken\"] = 6] = \"Thicken\";\n    /** Create a shelled solid by offsetting all faces by the supplied distance */\n    BRepGeometryOperation[BRepGeometryOperation[\"Hollow\"] = 7] = \"Hollow\";\n    /** Create a solid or surface by sweeping a planar profile (first entry) along a path (second entry) */\n    BRepGeometryOperation[BRepGeometryOperation[\"Sweep\"] = 8] = \"Sweep\";\n    /** Create a solid or surface by lofting through a set of paths or regions */\n    BRepGeometryOperation[BRepGeometryOperation[\"Loft\"] = 9] = \"Loft\";\n    /** Create a solid or sheet with all non-smooth/non-laminar edges rounded */\n    BRepGeometryOperation[BRepGeometryOperation[\"Round\"] = 10] = \"Round\";\n    /** Offset all faces of a solid or sheet target by the supplied distance. */\n    BRepGeometryOperation[BRepGeometryOperation[\"Offset\"] = 11] = \"Offset\";\n})(BRepGeometryOperation || (BRepGeometryOperation = {}));\n/** Provides utility functions for working with [[ElementGeometryDataEntry]].\n * @beta\n */\nexport var ElementGeometry;\n(function (ElementGeometry) {\n    /** [[ElementGeometry.Builder]] is a helper class for populating a [[ElementGeometryDataEntry]] array needed to create a [[GeometricElement]] or [[GeometryPart]]. */\n    class Builder {\n        constructor() {\n            /** GeometryStream entries */\n            this.entries = [];\n        }\n        /** Current placement transform, converts local coordinate (placement relative) input to world */\n        get localToWorld() { return this._localToWorld; }\n        /** Current inverse placement transform, converts world coordinate input to local (placement relative) */\n        get worldToLocal() { return this._worldToLocal; }\n        /** Supply optional local to world transform. Used to transform world coordinate input relative to element placement.\n         * For a [[GeometricElement]]'s placement to be meaningful, world coordinate geometry should never be appended to an element with an identity placement.\n         * Can be called with undefined or identity transform to start appending geometry supplied in local coordinates again.\n         */\n        setLocalToWorld(localToWorld) {\n            this._localToWorld = (undefined === localToWorld || localToWorld.isIdentity ? undefined : localToWorld.clone());\n            this._worldToLocal = (undefined === this._localToWorld ? undefined : this._localToWorld.inverse());\n        }\n        /** Supply local to world transform from a Point3d and optional YawPitchRollAngles.\n         * @see [[Placement3d]]\n         */\n        setLocalToWorld3d(origin, angles = YawPitchRollAngles.createDegrees(0.0, 0.0, 0.0)) {\n            this.setLocalToWorld(Transform.createOriginAndMatrix(origin, angles.toMatrix3d()));\n        }\n        /** Supply local to world transform from a Point2d and optional Angle.\n         * @see [[Placement2d]]\n         */\n        setLocalToWorld2d(origin, angle = Angle.createDegrees(0.0)) {\n            this.setLocalToWorld(Transform.createOriginAndMatrix(Point3d.createFrom(origin), Matrix3d.createRotationAroundVector(Vector3d.unitZ(), angle)));\n        }\n        /** Supply local to world transform from a PlacementProps2d or PlacementProps3d.\n         * @see [[PlacementProps]]\n         */\n        setLocalToWorldFromPlacement(props) {\n            const placement = isPlacement2dProps(props) ? Placement2d.fromJSON(props) : Placement3d.fromJSON(props);\n            this.setLocalToWorld(placement.transform);\n        }\n        /** Compute angles suitable for passing to [[setLocalToWorld3d]] from an array of 3d points. */\n        static placementAnglesFromPoints(pts, defaultUp, result) {\n            const angles = result ? result : new YawPitchRollAngles();\n            const zVec = defaultUp ? defaultUp.clone() : Vector3d.unitZ();\n            const matrix = Matrix3d.createRigidHeadsUp(zVec);\n            YawPitchRollAngles.createFromMatrix3d(matrix, angles);\n            if (pts.length < 2 || pts[0].isAlmostEqual(pts[1]))\n                return angles;\n            // Check if points have a well defined normal to use instead of defaultUp...\n            const frameTransform = FrameBuilder.createFrameToDistantPoints(pts);\n            if (undefined !== frameTransform) {\n                const plane = Plane3dByOriginAndUnitNormal.create(pts[0], frameTransform.matrix.getColumn(2));\n                if (undefined !== plane && Point3dArray.isCloseToPlane(pts, plane))\n                    zVec.setFrom(plane.getNormalRef());\n            }\n            const xVec = Vector3d.createStartEnd(pts[0], pts[1]);\n            if (xVec.isParallelTo(zVec, true))\n                return angles;\n            const yVec = xVec.unitCrossProduct(zVec);\n            if (undefined === yVec)\n                return angles;\n            Matrix3d.createColumns(xVec, yVec, zVec, matrix);\n            if (undefined === Matrix3d.createRigidFromMatrix3d(matrix, undefined, matrix))\n                return angles;\n            YawPitchRollAngles.createFromMatrix3d(matrix, angles);\n            return angles;\n        }\n        /** Compute angle suitable for passing to [[setLocalToWorld2d]] from an array of xy plane points. */\n        static placementAngleFromPoints(pts, result) {\n            const angles = ElementGeometry.Builder.placementAnglesFromPoints(pts);\n            if (undefined === result)\n                return angles.yaw;\n            result.setFrom(angles.yaw);\n            return result;\n        }\n        /** Store local ranges for all subsequent geometry appended. Can improve performance of range testing for elements with a GeometryStream\n         * containing more than one [[GeometryQuery]] differentiable by range. Not useful for a single [[GeometryQuery]] as its range and that of the [[GeometricElement]] are the same.\n         * Ignored when defining a [[GeometryPart]] and not needed when only appending [[GeometryPart]] instances to a [[GeometricElement]] as these store their own range.\n         */\n        appendGeometryRanges() {\n            const entry = fromSubGraphicRange(Range3d.create()); // Computed on backend, just need opcode...\n            if (undefined === entry)\n                return false;\n            this.entries.push(entry);\n            return true;\n        }\n        /** Change [[GeometryParams]] for subsequent geometry.\n         * It is not valid to change the sub-category when defining a [[GeometryPart]]. A [[GeometryPart]] inherits the symbology of their instance for anything not explicitly overridden.\n         */\n        appendGeometryParamsChange(geomParams) {\n            return appendGeometryParams(geomParams, this.entries, this._worldToLocal);\n        }\n        /** Append a [[GeometryQuery]] supplied in either local or world coordinates to the [[ElementGeometryDataEntry]] array */\n        appendGeometryQuery(geometry) {\n            const entry = ElementGeometry.fromGeometryQuery(geometry, this._worldToLocal);\n            if (undefined === entry)\n                return false;\n            this.entries.push(entry);\n            return true;\n        }\n        /** Append a [[TextString]] supplied in either local or world coordinates to the [[ElementGeometryDataEntry]] array */\n        appendTextString(text) {\n            const entry = ElementGeometry.fromTextString(text.toJSON(), this._worldToLocal);\n            if (undefined === entry)\n                return false;\n            this.entries.push(entry);\n            return true;\n        }\n        /** Append a [[ImageGraphic]] supplied in either local or world coordinates to the [[ElementGeometryDataEntry]] array */\n        appendImageGraphic(image) {\n            const entry = ElementGeometry.fromImageGraphic(image.toJSON(), this._worldToLocal);\n            if (undefined === entry)\n                return false;\n            this.entries.push(entry);\n            return true;\n        }\n        /** Append a [[BRepEntity.DataProps]] supplied in either local or world coordinates to the [[ElementGeometryDataEntry]] array.\n         * Provided for compatibility with GeometryStreamBuilder only.\n         * Backend code should use IModelDb.createBRepGeometry to create a brep [[ElementGeometryDataEntry]] directly.\n         */\n        appendBRepData(brep) {\n            const entry = ElementGeometry.fromBRep(brep, this._worldToLocal);\n            if (undefined === entry)\n                return false;\n            this.entries.push(entry);\n            return true;\n        }\n        /** Append a [[GeometryPart]] instance with relative transform to the [[ElementGeometryDataEntry]] array for creating a [[GeometricElement]].\n         * Not valid when defining a [[GeometryPart]] as nesting of parts is not supported.\n         */\n        appendGeometryPart(partId, partTransform) {\n            const entry = ElementGeometry.fromGeometryPart(partId, partTransform, this._worldToLocal);\n            if (undefined === entry)\n                return false;\n            this.entries.push(entry);\n            return true;\n        }\n        /** Append a [[GeometryPart]] instance with relative position, orientation, and scale to the [[ElementGeometryDataEntry]] array for creating a [[GeometricElement3d]].\n         * Not valid when defining a [[GeometryPart]] as nesting of parts is not supported.\n         */\n        appendGeometryPart3d(partId, instanceOrigin, instanceRotation, instanceScale) {\n            const partTransform = Transform.createOriginAndMatrix(instanceOrigin, instanceRotation ? instanceRotation.toMatrix3d() : Matrix3d.createIdentity());\n            if (undefined !== instanceScale)\n                partTransform.matrix.scaleColumnsInPlace(instanceScale, instanceScale, instanceScale);\n            return this.appendGeometryPart(partId, partTransform);\n        }\n        /** Append a [[GeometryPart]] instance with relative position, orientation, and scale to the [[ElementGeometryDataEntry]] array for creating a [[GeometricElement2d]].\n         * Not valid when defining a [[GeometryPart]] as nesting of parts is not supported.\n         */\n        appendGeometryPart2d(partId, instanceOrigin, instanceRotation, instanceScale) {\n            return this.appendGeometryPart3d(partId, instanceOrigin ? Point3d.createFrom(instanceOrigin) : undefined, instanceRotation ? new YawPitchRollAngles(instanceRotation) : undefined, instanceScale);\n        }\n    }\n    ElementGeometry.Builder = Builder;\n    class IteratorEntry {\n        constructor(geomParams, localToWorld, applyLocalToWorld) {\n            this.geomParams = geomParams;\n            this.localToWorld = localToWorld;\n            this._applyLocalToWorld = applyLocalToWorld ? !localToWorld.isIdentity : false;\n        }\n        get value() { return this._value; }\n        set value(value) { this._value = value; }\n        get outputTransform() {\n            return this._applyLocalToWorld ? this.localToWorld : undefined;\n        }\n        /** Return the [[GeometryQuery]] representation for the current entry */\n        toGeometryQuery() {\n            return toGeometryQuery(this.value, this.outputTransform);\n        }\n        /** Return the [[BRepEntity.DataProps]] representation for the current entry for checking brep type and face attachments. */\n        toBRepData(wantBRepData = false) {\n            return toBRep(this.value, wantBRepData, this.outputTransform);\n        }\n        /** Return the [[TextString]] representation for the current entry */\n        toTextString() {\n            const props = toTextString(this.value, this.outputTransform);\n            return (undefined !== props ? new TextString(props) : undefined);\n        }\n        /** Return the [[ImageGraphic]] representation for the current entry */\n        toImageGraphic() {\n            const props = toImageGraphic(this.value, this.outputTransform);\n            return (undefined !== props ? ImageGraphic.fromJSON(props) : undefined);\n        }\n        /** Return the GeometryPart information for the current entry */\n        toGeometryPart(partToLocal, partToWorld) {\n            if (undefined === partToLocal && undefined !== partToWorld)\n                partToLocal = Transform.createIdentity();\n            const partId = toGeometryPart(this.value, partToLocal);\n            if (undefined === partId || undefined === partToLocal || undefined === partToWorld)\n                return partId;\n            if (undefined !== this.localToWorld)\n                this.localToWorld.multiplyTransformTransform(partToLocal, partToWorld);\n            return partId;\n        }\n    }\n    ElementGeometry.IteratorEntry = IteratorEntry;\n    /** [[ElementGeometry.Iterator]] is a helper class for iterating a [[ElementGeometryDataEntry]] array.\n     * Each [[ElementGeometryDataEntry]] returned by the iterator represents exactly one displayable entry.\n     */\n    class Iterator {\n        /** Construct a new Iterator given a [[ElementGeometryInfo]] from either a [[GeometricElement3d]], [[GeometricElement2d]], or [[GeometryPart]].\n         * Supply the optional [[GeometryParams]] and localToWorld transform to iterate a [[GeometryPart]] in the context of a [[GeometricElement]] reference.\n        */\n        constructor(info, categoryOrGeometryParams, localToWorld) {\n            /** Current entry position */\n            this._index = 0;\n            /** Whether deserialized entry data is returned in world or local coordinates */\n            this._applyLocalToWorld = false;\n            this.entryArray = info.entryArray;\n            this.viewIndependent = info.viewIndependent;\n            this.brepsPresent = info.brepsPresent;\n            if (undefined !== info.categoryId)\n                categoryOrGeometryParams = info.categoryId;\n            if (undefined !== categoryOrGeometryParams)\n                this._appearance = typeof categoryOrGeometryParams === \"string\" ? new GeometryParams(categoryOrGeometryParams) : categoryOrGeometryParams;\n            else\n                this._appearance = new GeometryParams(Id64.invalid);\n            if (undefined !== info.sourceToWorld)\n                localToWorld = ElementGeometry.toTransform(info.sourceToWorld);\n            if (undefined !== localToWorld)\n                this._localToWorld = localToWorld;\n            else\n                this._localToWorld = Transform.createIdentity();\n            const orgAng = YawPitchRollAngles.tryFromTransform(this._localToWorld);\n            if (undefined === orgAng.angles)\n                orgAng.angles = YawPitchRollAngles.createDegrees(0, 0, 0);\n            let bbox = (undefined !== info.bbox ? ElementGeometry.toElementAlignedBox3d(info.bbox) : undefined);\n            if (undefined === bbox)\n                bbox = Range3d.createNull();\n            this.placement = new Placement3d(orgAng.origin, orgAng.angles, bbox);\n        }\n        /** Call to return deserialized entry data in world coordinates */\n        requestWorldCoordinates() {\n            this._applyLocalToWorld = !this._localToWorld.isIdentity;\n        }\n        // eslint-disable-next-line @typescript-eslint/naming-convention\n        get entry() {\n            if (undefined === this._entry)\n                this._entry = new IteratorEntry(this._appearance, this._localToWorld, this._applyLocalToWorld);\n            return this._entry;\n        }\n        /** Advance to next displayable opcode (geometric entry or geometry part) while updating the current [[GeometryParams]] from appearance related opcodes. */\n        next() {\n            while (this._index < this.entryArray.length) {\n                const value = this.entryArray[this._index++];\n                if (ElementGeometry.isAppearanceEntry(value)) {\n                    const localToWorld = (this._applyLocalToWorld ? this._localToWorld : undefined);\n                    ElementGeometry.updateGeometryParams(value, this.entry.geomParams, localToWorld);\n                }\n                else if (ElementGeometryOpcode.SubGraphicRange === value.opcode) {\n                    // NOTE: localRange remains valid until the next sub-range entry is encountered...\n                    this.entry.localRange = ElementGeometry.toSubGraphicRange(value);\n                }\n                else if (ElementGeometryOpcode.PartReference === value.opcode) {\n                    this.entry.value = value;\n                    return { value: this.entry, done: false };\n                }\n                else if (ElementGeometry.isGeometricEntry(value)) {\n                    this.entry.value = value;\n                    return { value: this.entry, done: false };\n                }\n            }\n            return { value: this.entry, done: true };\n        }\n        [Symbol.iterator]() {\n            return this;\n        }\n    }\n    ElementGeometry.Iterator = Iterator;\n    /** Return whether the supplied entry can be represented as a [[GeometryQuery]] */\n    function isGeometryQueryEntry(entry) {\n        switch (entry.opcode) {\n            case ElementGeometryOpcode.PointPrimitive:\n            case ElementGeometryOpcode.PointPrimitive2d:\n            case ElementGeometryOpcode.ArcPrimitive:\n            case ElementGeometryOpcode.CurveCollection:\n            case ElementGeometryOpcode.Polyface:\n            case ElementGeometryOpcode.CurvePrimitive:\n            case ElementGeometryOpcode.SolidPrimitive:\n            case ElementGeometryOpcode.BsplineSurface:\n                return true;\n            default:\n                return false;\n        }\n    }\n    ElementGeometry.isGeometryQueryEntry = isGeometryQueryEntry;\n    /** Return whether the supplied entry is displayable geometry [[GeometryQuery]], [[BRepEntity.DataProps]], [[TextString]], or [[ImageGraphic]] */\n    function isGeometricEntry(entry) {\n        switch (entry.opcode) {\n            case ElementGeometryOpcode.BRep:\n            case ElementGeometryOpcode.TextString:\n            case ElementGeometryOpcode.Image:\n                return true;\n            default:\n                return isGeometryQueryEntry(entry);\n        }\n    }\n    ElementGeometry.isGeometricEntry = isGeometricEntry;\n    /** Return whether the supplied entry is geometric or a part reference */\n    function isDisplayableEntry(entry) {\n        switch (entry.opcode) {\n            case ElementGeometryOpcode.PartReference:\n                return true;\n            default:\n                return isGeometricEntry(entry);\n        }\n    }\n    ElementGeometry.isDisplayableEntry = isDisplayableEntry;\n    /** Return whether the supplied entry represents appearance information */\n    function isAppearanceEntry(entry) {\n        switch (entry.opcode) {\n            case ElementGeometryOpcode.BasicSymbology:\n            case ElementGeometryOpcode.Fill:\n            case ElementGeometryOpcode.Pattern:\n            case ElementGeometryOpcode.Material:\n            case ElementGeometryOpcode.LineStyleModifiers:\n                return true;\n            default:\n                return false;\n        }\n    }\n    ElementGeometry.isAppearanceEntry = isAppearanceEntry;\n    /** Return whether the supplied entry represents a single open curve or path */\n    function isCurve(entry) {\n        switch (entry.opcode) {\n            case ElementGeometryOpcode.PointPrimitive: {\n                const buffer = new flatbuffers.ByteBuffer(entry.data);\n                const ppfb = EGFBAccessors.PointPrimitive.getRootAsPointPrimitive(buffer);\n                return (EGFBAccessors.BoundaryType.Open === ppfb.boundary());\n            }\n            case ElementGeometryOpcode.PointPrimitive2d: {\n                const buffer = new flatbuffers.ByteBuffer(entry.data);\n                const ppfb = EGFBAccessors.PointPrimitive2d.getRootAsPointPrimitive2d(buffer);\n                return (EGFBAccessors.BoundaryType.Open === ppfb.boundary());\n            }\n            case ElementGeometryOpcode.ArcPrimitive: {\n                const buffer = new flatbuffers.ByteBuffer(entry.data);\n                const ppfb = EGFBAccessors.ArcPrimitive.getRootAsArcPrimitive(buffer);\n                return (EGFBAccessors.BoundaryType.Open === ppfb.boundary());\n            }\n            case ElementGeometryOpcode.CurvePrimitive: {\n                // should never be a point string or closed bcurve...\n                return true;\n            }\n            case ElementGeometryOpcode.CurveCollection: {\n                const geom = BentleyGeometryFlatBuffer.bytesToGeometry(entry.data, true);\n                if (undefined === geom || Array.isArray(geom))\n                    return false;\n                return (\"curveCollection\" === geom.geometryCategory && !geom.isAnyRegionType);\n            }\n            default:\n                return false;\n        }\n    }\n    ElementGeometry.isCurve = isCurve;\n    /** Return whether the supplied entry represents a loop, planar region, open polyface, or sheet body */\n    function isSurface(entry) {\n        switch (entry.opcode) {\n            case ElementGeometryOpcode.PointPrimitive: {\n                const buffer = new flatbuffers.ByteBuffer(entry.data);\n                const ppfb = EGFBAccessors.PointPrimitive.getRootAsPointPrimitive(buffer);\n                return (EGFBAccessors.BoundaryType.Closed === ppfb.boundary());\n            }\n            case ElementGeometryOpcode.PointPrimitive2d: {\n                const buffer = new flatbuffers.ByteBuffer(entry.data);\n                const ppfb = EGFBAccessors.PointPrimitive2d.getRootAsPointPrimitive2d(buffer);\n                return (EGFBAccessors.BoundaryType.Closed === ppfb.boundary());\n            }\n            case ElementGeometryOpcode.ArcPrimitive: {\n                const buffer = new flatbuffers.ByteBuffer(entry.data);\n                const ppfb = EGFBAccessors.ArcPrimitive.getRootAsArcPrimitive(buffer);\n                return (EGFBAccessors.BoundaryType.Closed === ppfb.boundary());\n            }\n            case ElementGeometryOpcode.CurvePrimitive: {\n                // should never be a closed bcurve...\n                return false;\n            }\n            case ElementGeometryOpcode.CurveCollection: {\n                const geom = BentleyGeometryFlatBuffer.bytesToGeometry(entry.data, true);\n                if (undefined === geom || Array.isArray(geom))\n                    return false;\n                return (\"curveCollection\" === geom.geometryCategory && geom.isAnyRegionType);\n            }\n            case ElementGeometryOpcode.SolidPrimitive: {\n                const geom = BentleyGeometryFlatBuffer.bytesToGeometry(entry.data, true);\n                if (undefined === geom || Array.isArray(geom))\n                    return false;\n                return (\"solid\" === geom.geometryCategory && !geom.isClosedVolume);\n            }\n            case ElementGeometryOpcode.Polyface: {\n                const geom = BentleyGeometryFlatBuffer.bytesToGeometry(entry.data, true);\n                if (undefined === geom || Array.isArray(geom))\n                    return false;\n                if (\"polyface\" !== geom.geometryCategory)\n                    return false;\n                const polyface = geom;\n                switch (polyface.expectedClosure) {\n                    case 0:\n                        return !PolyfaceQuery.isPolyfaceClosedByEdgePairing(polyface);\n                    case 1:\n                        return true;\n                    case 2:\n                    default:\n                        return false;\n                }\n            }\n            case ElementGeometryOpcode.BsplineSurface: {\n                // never treated as a solid even if closed/periodic in u/v...\n                return true;\n            }\n            case ElementGeometryOpcode.BRep: {\n                const buffer = new flatbuffers.ByteBuffer(entry.data);\n                const ppfb = EGFBAccessors.BRepData.getRootAsBRepData(buffer);\n                return (EGFBAccessors.BRepType.Sheet === ppfb.brepType());\n            }\n            default:\n                return false;\n        }\n    }\n    ElementGeometry.isSurface = isSurface;\n    /** Return whether the supplied entry represents a capped solid, closed polyface, or solid body */\n    function isSolid(entry) {\n        switch (entry.opcode) {\n            case ElementGeometryOpcode.SolidPrimitive: {\n                const geom = BentleyGeometryFlatBuffer.bytesToGeometry(entry.data, true);\n                if (undefined === geom || Array.isArray(geom))\n                    return false;\n                return (\"solid\" === geom.geometryCategory && geom.isClosedVolume);\n            }\n            case ElementGeometryOpcode.Polyface: {\n                const geom = BentleyGeometryFlatBuffer.bytesToGeometry(entry.data, true);\n                if (undefined === geom || Array.isArray(geom))\n                    return false;\n                if (\"polyface\" !== geom.geometryCategory)\n                    return false;\n                const polyface = geom;\n                switch (polyface.expectedClosure) {\n                    case 0:\n                        return PolyfaceQuery.isPolyfaceClosedByEdgePairing(polyface);\n                    case 2:\n                        return true;\n                    case 1:\n                    default:\n                        return false;\n                }\n            }\n            case ElementGeometryOpcode.BRep: {\n                const buffer = new flatbuffers.ByteBuffer(entry.data);\n                const ppfb = EGFBAccessors.BRepData.getRootAsBRepData(buffer);\n                return (EGFBAccessors.BRepType.Solid === ppfb.brepType());\n            }\n            default:\n                return false;\n        }\n    }\n    ElementGeometry.isSolid = isSolid;\n    /** Return the body type that would be used to represent the supplied entry */\n    function getBRepEntityType(entry) {\n        switch (entry.opcode) {\n            case ElementGeometryOpcode.PointPrimitive: {\n                const buffer = new flatbuffers.ByteBuffer(entry.data);\n                const ppfb = EGFBAccessors.PointPrimitive.getRootAsPointPrimitive(buffer);\n                if (EGFBAccessors.BoundaryType.None === ppfb.boundary())\n                    return undefined;\n                return (EGFBAccessors.BoundaryType.Closed === ppfb.boundary() ? BRepEntity.Type.Sheet : BRepEntity.Type.Wire);\n            }\n            case ElementGeometryOpcode.PointPrimitive2d: {\n                const buffer = new flatbuffers.ByteBuffer(entry.data);\n                const ppfb = EGFBAccessors.PointPrimitive2d.getRootAsPointPrimitive2d(buffer);\n                if (EGFBAccessors.BoundaryType.None === ppfb.boundary())\n                    return undefined;\n                return (EGFBAccessors.BoundaryType.Closed === ppfb.boundary() ? BRepEntity.Type.Sheet : BRepEntity.Type.Wire);\n            }\n            case ElementGeometryOpcode.ArcPrimitive: {\n                const buffer = new flatbuffers.ByteBuffer(entry.data);\n                const ppfb = EGFBAccessors.ArcPrimitive.getRootAsArcPrimitive(buffer);\n                return (EGFBAccessors.BoundaryType.Closed === ppfb.boundary() ? BRepEntity.Type.Sheet : BRepEntity.Type.Wire);\n            }\n            case ElementGeometryOpcode.CurvePrimitive: {\n                // should never be a point string or closed bcurve...\n                return BRepEntity.Type.Wire;\n            }\n            case ElementGeometryOpcode.CurveCollection: {\n                const geom = BentleyGeometryFlatBuffer.bytesToGeometry(entry.data, true);\n                if (undefined === geom || Array.isArray(geom))\n                    return undefined;\n                if (\"curveCollection\" !== geom.geometryCategory)\n                    return undefined;\n                const curves = geom;\n                return (curves.isAnyRegionType ? BRepEntity.Type.Sheet : BRepEntity.Type.Wire);\n            }\n            case ElementGeometryOpcode.SolidPrimitive: {\n                const geom = BentleyGeometryFlatBuffer.bytesToGeometry(entry.data, true);\n                if (undefined === geom || Array.isArray(geom))\n                    return undefined;\n                if (\"solid\" !== geom.geometryCategory)\n                    return undefined;\n                const solid = geom;\n                return (solid.isClosedVolume ? BRepEntity.Type.Solid : BRepEntity.Type.Sheet);\n            }\n            case ElementGeometryOpcode.BsplineSurface: {\n                // always a surface...\n                return BRepEntity.Type.Sheet;\n            }\n            case ElementGeometryOpcode.Polyface: {\n                const geom = BentleyGeometryFlatBuffer.bytesToGeometry(entry.data, true);\n                if (undefined === geom || Array.isArray(geom))\n                    return undefined;\n                if (\"polyface\" !== geom.geometryCategory)\n                    return undefined;\n                const polyface = geom;\n                switch (polyface.expectedClosure) {\n                    case 0:\n                        return PolyfaceQuery.isPolyfaceClosedByEdgePairing(polyface) ? BRepEntity.Type.Solid : BRepEntity.Type.Sheet;\n                    case 1:\n                        return BRepEntity.Type.Sheet;\n                    case 2:\n                        return BRepEntity.Type.Solid;\n                    default:\n                        return undefined;\n                }\n            }\n            case ElementGeometryOpcode.BRep: {\n                const buffer = new flatbuffers.ByteBuffer(entry.data);\n                const ppfb = EGFBAccessors.BRepData.getRootAsBRepData(buffer);\n                switch (ppfb.brepType()) {\n                    case EGFBAccessors.BRepType.Wire:\n                        return BRepEntity.Type.Wire; // always be persisted as a curve type...\n                    case EGFBAccessors.BRepType.Sheet:\n                        return BRepEntity.Type.Sheet;\n                    case EGFBAccessors.BRepType.Solid:\n                        return BRepEntity.Type.Solid;\n                    default:\n                        return undefined;\n                }\n            }\n            default:\n                return undefined;\n        }\n    }\n    ElementGeometry.getBRepEntityType = getBRepEntityType;\n    /** Return entry as a [[GeometryQuery]] */\n    function toGeometryQuery(entry, localToWorld) {\n        if (!isGeometryQueryEntry(entry))\n            return undefined;\n        switch (entry.opcode) {\n            case ElementGeometryOpcode.PointPrimitive: {\n                const buffer = new flatbuffers.ByteBuffer(entry.data);\n                const ppfb = EGFBAccessors.PointPrimitive.getRootAsPointPrimitive(buffer);\n                const pts = [];\n                for (let i = 0; i < ppfb.coordsLength(); i++)\n                    pts.push(Point3d.create(ppfb.coords(i).x(), ppfb.coords(i).y(), ppfb.coords(i).z()));\n                if (0 === pts.length)\n                    return undefined;\n                if (undefined !== localToWorld)\n                    localToWorld.multiplyPoint3dArrayInPlace(pts);\n                switch (ppfb.boundary()) {\n                    case EGFBAccessors.BoundaryType.Open:\n                        return LineString3d.createPoints(pts);\n                    case EGFBAccessors.BoundaryType.Closed:\n                        return Loop.createPolygon(pts);\n                    default:\n                        return PointString3d.createPoints(pts);\n                }\n            }\n            case ElementGeometryOpcode.PointPrimitive2d: {\n                const buffer = new flatbuffers.ByteBuffer(entry.data);\n                const ppfb = EGFBAccessors.PointPrimitive2d.getRootAsPointPrimitive2d(buffer);\n                const pts = [];\n                for (let i = 0; i < ppfb.coordsLength(); i++)\n                    pts.push(Point3d.create(ppfb.coords(i).x(), ppfb.coords(i).y()));\n                if (0 === pts.length)\n                    return undefined;\n                if (undefined !== localToWorld)\n                    localToWorld.multiplyPoint3dArrayInPlace(pts);\n                switch (ppfb.boundary()) {\n                    case EGFBAccessors.BoundaryType.Open:\n                        return LineString3d.createPoints(pts);\n                    case EGFBAccessors.BoundaryType.Closed:\n                        return Loop.createPolygon(pts);\n                    default:\n                        return PointString3d.createPoints(pts);\n                }\n            }\n            case ElementGeometryOpcode.ArcPrimitive: {\n                const buffer = new flatbuffers.ByteBuffer(entry.data);\n                const ppfb = EGFBAccessors.ArcPrimitive.getRootAsArcPrimitive(buffer);\n                const center = Point3d.create(ppfb.center().x(), ppfb.center().y(), ppfb.center().z());\n                const vector0 = Vector3d.create(ppfb.vector0().x(), ppfb.vector0().y(), ppfb.vector0().z());\n                const vector90 = Vector3d.create(ppfb.vector90().x(), ppfb.vector90().y(), ppfb.vector90().z());\n                const arc = Arc3d.create(center, vector0, vector90, AngleSweep.createStartSweepRadians(ppfb.start(), ppfb.sweep()));\n                if (undefined !== localToWorld && !arc.tryTransformInPlace(localToWorld))\n                    return undefined;\n                return (EGFBAccessors.BoundaryType.Closed === ppfb.boundary() ? Loop.create(arc) : arc);\n            }\n            case ElementGeometryOpcode.CurvePrimitive:\n            case ElementGeometryOpcode.CurveCollection:\n            case ElementGeometryOpcode.SolidPrimitive:\n            case ElementGeometryOpcode.BsplineSurface:\n            case ElementGeometryOpcode.Polyface:\n                const geom = BentleyGeometryFlatBuffer.bytesToGeometry(entry.data, true);\n                if (undefined === geom || Array.isArray(geom))\n                    return undefined; // Should always be a single entry not an array...\n                if (undefined !== localToWorld && !geom.tryTransformInPlace(localToWorld))\n                    return undefined;\n                return geom;\n            default:\n                return undefined; // Not a GeometryQuery, need to be handled explicitly...\n        }\n    }\n    ElementGeometry.toGeometryQuery = toGeometryQuery;\n    /** Create entry from a [[GeometryQuery]] */\n    function fromGeometryQuery(geom, worldToLocal) {\n        let opcode;\n        switch (geom.geometryCategory) {\n            case \"bsurf\":\n                opcode = ElementGeometryOpcode.BsplineSurface;\n                break;\n            case \"curveCollection\":\n                opcode = ElementGeometryOpcode.CurveCollection;\n                break;\n            case \"curvePrimitive\":\n            case \"pointCollection\":\n                opcode = ElementGeometryOpcode.CurvePrimitive;\n                break;\n            case \"polyface\":\n                opcode = ElementGeometryOpcode.Polyface;\n                break;\n            case \"solid\":\n                opcode = ElementGeometryOpcode.SolidPrimitive;\n                break;\n            default:\n                return undefined;\n        }\n        if (undefined !== worldToLocal) {\n            const localGeom = geom.cloneTransformed(worldToLocal);\n            if (undefined === localGeom)\n                return undefined;\n            geom = localGeom;\n        }\n        const data = BentleyGeometryFlatBuffer.geometryToBytes(geom, true);\n        if (undefined === data)\n            return undefined;\n        return { opcode, data };\n    }\n    ElementGeometry.fromGeometryQuery = fromGeometryQuery;\n    /** Return entry as a [[TextString]] */\n    function toTextString(entry, localToWorld) {\n        if (ElementGeometryOpcode.TextString !== entry.opcode)\n            return undefined;\n        const buffer = new flatbuffers.ByteBuffer(entry.data);\n        const ppfb = EGFBAccessors.TextString.getRootAsTextString(buffer);\n        const style = ppfb.style();\n        if (null === style)\n            return undefined;\n        const text = ppfb.text();\n        const props = { text: (null !== text ? text : \"\"), font: style.fontId(), height: style.height() };\n        props.widthFactor = style.widthFactor();\n        props.bold = style.isBold();\n        props.italic = style.isItalic();\n        props.underline = style.isUnderlined();\n        const transform = ppfb.transform();\n        if (null !== transform) {\n            props.origin = Point3d.create(transform.form3d03(), transform.form3d13(), transform.form3d23());\n            props.rotation = YawPitchRollAngles.createFromMatrix3d(Matrix3d.createRowValues(transform.form3d00(), transform.form3d01(), transform.form3d02(), transform.form3d10(), transform.form3d11(), transform.form3d12(), transform.form3d20(), transform.form3d21(), transform.form3d22()));\n        }\n        if (undefined === localToWorld)\n            return props;\n        const textString = new TextString(props);\n        if (!textString.transformInPlace(localToWorld))\n            return undefined;\n        return textString.toJSON();\n    }\n    ElementGeometry.toTextString = toTextString;\n    /** Create entry from a [[TextString]] */\n    function fromTextString(text, worldToLocal) {\n        if (undefined !== worldToLocal) {\n            const localText = new TextString(text);\n            if (!localText.transformInPlace(worldToLocal))\n                return undefined;\n            text = localText.toJSON();\n        }\n        const fbb = new flatbuffers.Builder();\n        const builder = EGFBAccessors.TextString;\n        const textOffset = fbb.createString(text.text);\n        const styleOffset = EGFBAccessors.TextStringStyle.createTextStringStyle(fbb, 1, 0, text.font, undefined === text.bold ? false : text.bold, undefined === text.italic ? false : text.italic, undefined === text.underline ? false : text.underline, text.height, undefined === text.widthFactor ? 1.0 : text.widthFactor);\n        builder.startTextString(fbb);\n        builder.addMajorVersion(fbb, 1);\n        builder.addMinorVersion(fbb, 0);\n        builder.addText(fbb, textOffset);\n        builder.addStyle(fbb, styleOffset);\n        if (undefined !== text.origin || undefined !== text.rotation) {\n            const origin = Point3d.fromJSON(text.origin);\n            const angles = YawPitchRollAngles.fromJSON(text.rotation);\n            const matrix = angles.toMatrix3d();\n            const coffs = matrix.coffs;\n            const transformOffset = EGFBAccessors.TextStringTransform.createTextStringTransform(fbb, coffs[0], coffs[1], coffs[2], origin.x, coffs[3], coffs[4], coffs[5], origin.y, coffs[6], coffs[7], coffs[8], origin.z);\n            builder.addTransform(fbb, transformOffset);\n        }\n        const mLoc = builder.endTextString(fbb);\n        fbb.finish(mLoc);\n        const data = fbb.asUint8Array();\n        return { opcode: ElementGeometryOpcode.TextString, data };\n    }\n    ElementGeometry.fromTextString = fromTextString;\n    /** Return entry as a [[ImageGraphic]] */\n    function toImageGraphic(entry, localToWorld) {\n        if (ElementGeometryOpcode.Image !== entry.opcode)\n            return undefined;\n        const buffer = new flatbuffers.ByteBuffer(entry.data);\n        const ppfb = EGFBAccessors.Image.getRootAsImage(buffer);\n        const textureLong = ppfb.textureId();\n        const textureId = Id64.fromUint32Pair(textureLong.low, textureLong.high);\n        const hasBorder = (1 === ppfb.drawBorder());\n        const corners = new ImageGraphicCorners(Point3d.createZero(), Point3d.createZero(), Point3d.createZero(), Point3d.createZero());\n        const corner0 = ppfb.tileCorner0();\n        const corner1 = ppfb.tileCorner1();\n        const corner2 = ppfb.tileCorner2();\n        const corner3 = ppfb.tileCorner3();\n        if (null !== corner0)\n            corners[0].setFrom(Point3d.create(corner0.x(), corner0.y(), corner0.z()));\n        if (null !== corner1)\n            corners[1].setFrom(Point3d.create(corner1.x(), corner1.y(), corner1.z()));\n        if (null !== corner2)\n            corners[2].setFrom(Point3d.create(corner2.x(), corner2.y(), corner2.z()));\n        if (null !== corner3)\n            corners[3].setFrom(Point3d.create(corner3.x(), corner3.y(), corner3.z()));\n        if (undefined !== localToWorld) {\n            localToWorld.multiplyXYAndZInPlace(corners[0]);\n            localToWorld.multiplyXYAndZInPlace(corners[1]);\n            localToWorld.multiplyXYAndZInPlace(corners[2]);\n            localToWorld.multiplyXYAndZInPlace(corners[3]);\n        }\n        return { corners: corners.toJSON(), textureId, hasBorder };\n    }\n    ElementGeometry.toImageGraphic = toImageGraphic;\n    /** Create entry from a [[ImageGraphic]] */\n    function fromImageGraphic(image, worldToLocal) {\n        if (undefined !== worldToLocal) {\n            const localImage = ImageGraphic.fromJSON(image).cloneTransformed(worldToLocal);\n            image = localImage.toJSON();\n        }\n        const fbb = new flatbuffers.Builder();\n        const builder = EGFBAccessors.Image;\n        builder.startImage(fbb);\n        const textudeIdPair = Id64.getUint32Pair(image.textureId);\n        builder.addTextureId(fbb, flatbuffers.Long.create(textudeIdPair.lower, textudeIdPair.upper));\n        builder.addDrawBorder(fbb, image.hasBorder ? 1 : 0);\n        const corners = ImageGraphicCorners.fromJSON(image.corners);\n        const cornerOffset0 = EGFBAccessors.DPoint3d.createDPoint3d(fbb, corners[0].x, corners[0].y, corners[0].z);\n        builder.addTileCorner0(fbb, cornerOffset0);\n        const cornerOffset1 = EGFBAccessors.DPoint3d.createDPoint3d(fbb, corners[1].x, corners[1].y, corners[1].z);\n        builder.addTileCorner1(fbb, cornerOffset1);\n        const cornerOffset2 = EGFBAccessors.DPoint3d.createDPoint3d(fbb, corners[2].x, corners[2].y, corners[2].z);\n        builder.addTileCorner2(fbb, cornerOffset2);\n        const cornerOffset3 = EGFBAccessors.DPoint3d.createDPoint3d(fbb, corners[3].x, corners[3].y, corners[3].z);\n        builder.addTileCorner3(fbb, cornerOffset3);\n        const mLoc = builder.endImage(fbb);\n        fbb.finish(mLoc);\n        const data = fbb.asUint8Array();\n        return { opcode: ElementGeometryOpcode.Image, data };\n    }\n    ElementGeometry.fromImageGraphic = fromImageGraphic;\n    /** Return entry as a [[BRepEntity.DataProps]] for checking brep type and face attachments. */\n    function toBRep(entry, wantBRepData = false, localToWorld) {\n        if (ElementGeometryOpcode.BRep !== entry.opcode)\n            return undefined;\n        const buffer = new flatbuffers.ByteBuffer(entry.data);\n        const ppfb = EGFBAccessors.BRepData.getRootAsBRepData(buffer);\n        const toBRepType = (typeFb) => {\n            switch (typeFb) {\n                case EGFBAccessors.BRepType.Wire:\n                    return BRepEntity.Type.Wire;\n                case EGFBAccessors.BRepType.Sheet:\n                    return BRepEntity.Type.Sheet;\n                default:\n                    return BRepEntity.Type.Solid;\n            }\n        };\n        const type = toBRepType(ppfb.brepType());\n        let transform;\n        const entityTransform = ppfb.entityTransform();\n        if (null !== entityTransform)\n            transform = Transform.createRowValues(entityTransform.x00(), entityTransform.x01(), entityTransform.x02(), entityTransform.tx(), entityTransform.x10(), entityTransform.x11(), entityTransform.x12(), entityTransform.ty(), entityTransform.x20(), entityTransform.x21(), entityTransform.x22(), entityTransform.tz());\n        if (undefined !== localToWorld) {\n            if (undefined !== transform)\n                transform.multiplyTransformTransform(localToWorld, transform);\n            else\n                transform = localToWorld;\n        }\n        const faceSymbLen = ppfb.symbologyLength();\n        let faceSymbology;\n        if (0 !== faceSymbLen) {\n            const faceSymbPropsArray = [];\n            for (let index = 0; index < faceSymbLen; ++index) {\n                const faceSymbFb = ppfb.symbology(index);\n                const faceSymbProps = {};\n                if (null !== faceSymbFb) {\n                    if (1 === faceSymbFb.useColor())\n                        faceSymbProps.color = faceSymbFb.color();\n                    if (1 === faceSymbFb.useMaterial())\n                        faceSymbProps.materialId = Id64.fromUint32Pair(faceSymbFb.materialId().low, faceSymbFb.materialId().high);\n                    faceSymbProps.transparency = faceSymbFb.transparency();\n                }\n                faceSymbPropsArray.push(faceSymbProps);\n            }\n            faceSymbology = faceSymbPropsArray;\n        }\n        let data;\n        const entityData = ppfb.entityDataArray();\n        if (wantBRepData && null !== entityData)\n            data = Base64EncodedString.fromUint8Array(entityData);\n        return { data, type, transform: transform?.toJSON(), faceSymbology };\n    }\n    ElementGeometry.toBRep = toBRep;\n    /** Create entry from a [[BRepEntity.DataProps]]. Provided for compatibility with GeometryStreamBuilder only. */\n    function fromBRep(brep, worldToLocal) {\n        if (undefined !== worldToLocal) {\n            const entityTrans = Transform.fromJSON(brep.transform);\n            const localTrans = entityTrans.multiplyTransformTransform(worldToLocal);\n            brep = {\n                data: brep.data,\n                type: brep.type,\n                transform: localTrans.isIdentity ? undefined : localTrans.toJSON(),\n                faceSymbology: brep.faceSymbology,\n            };\n        }\n        const fbb = new flatbuffers.Builder();\n        const builder = EGFBAccessors.BRepData;\n        let dataOffset;\n        let faceSymbOffset;\n        if (undefined !== brep.data) {\n            const entityData = Base64EncodedString.toUint8Array(brep.data);\n            if (entityData.length === 0)\n                return undefined;\n            dataOffset = builder.createEntityDataVector(fbb, entityData);\n        }\n        if (undefined !== brep.faceSymbology) {\n            builder.startSymbologyVector(fbb, brep.faceSymbology.length);\n            for (let i = brep.faceSymbology.length - 1; i >= 0; i--) {\n                const symb = brep.faceSymbology[i];\n                const materialIdPair = Id64.getUint32Pair(symb.materialId ? symb.materialId : Id64.invalid);\n                const matLong = flatbuffers.Long.create(materialIdPair.lower, materialIdPair.upper);\n                EGFBAccessors.FaceSymbology.createFaceSymbology(fbb, symb.color ? 1 : 0, symb.materialId ? 1 : 0, symb.color ? symb.color : 0, matLong, symb.transparency ? symb.transparency : 0, 0, 0);\n            }\n            faceSymbOffset = fbb.endVector();\n        }\n        builder.startBRepData(fbb);\n        const toEGFBBRepType = (type) => {\n            switch (type) {\n                case BRepEntity.Type.Wire:\n                    return EGFBAccessors.BRepType.Wire;\n                case BRepEntity.Type.Sheet:\n                    return EGFBAccessors.BRepType.Sheet;\n                default:\n                    return EGFBAccessors.BRepType.Solid;\n            }\n        };\n        if (undefined !== brep.type)\n            builder.addBrepType(fbb, toEGFBBRepType(brep.type));\n        if (undefined !== brep.transform) {\n            const transform = Transform.fromJSON(brep.transform);\n            const transformOffset = EGFBAccessors.Transform.createTransform(fbb, transform.matrix.coffs[0], transform.matrix.coffs[1], transform.matrix.coffs[2], transform.origin.x, transform.matrix.coffs[3], transform.matrix.coffs[4], transform.matrix.coffs[5], transform.origin.y, transform.matrix.coffs[6], transform.matrix.coffs[7], transform.matrix.coffs[8], transform.origin.z);\n            builder.addEntityTransform(fbb, transformOffset);\n        }\n        if (undefined !== dataOffset)\n            builder.addEntityData(fbb, dataOffset);\n        if (undefined !== faceSymbOffset)\n            builder.addSymbology(fbb, faceSymbOffset);\n        const mLoc = builder.endBRepData(fbb);\n        fbb.finish(mLoc);\n        const data = fbb.asUint8Array();\n        return { opcode: ElementGeometryOpcode.BRep, data };\n    }\n    ElementGeometry.fromBRep = fromBRep;\n    /** Apply transform directly to ElementGeometryDataEntry for a BRep */\n    function transformBRep(entry, inputTransform) {\n        if (ElementGeometryOpcode.BRep !== entry.opcode)\n            return false;\n        const buffer = new flatbuffers.ByteBuffer(entry.data);\n        const ppfb = EGFBAccessors.BRepData.getRootAsBRepData(buffer);\n        const fbb = new flatbuffers.Builder();\n        const builder = EGFBAccessors.BRepData;\n        const entityData = ppfb.entityDataArray();\n        const dataOffset = (null !== entityData ? builder.createEntityDataVector(fbb, entityData) : undefined);\n        let faceSymbOffset;\n        const faceSymbLen = ppfb.symbologyLength();\n        if (0 !== faceSymbLen) {\n            builder.startSymbologyVector(fbb, faceSymbLen);\n            for (let i = faceSymbLen - 1; i >= 0; i--) {\n                const faceSymbFb = ppfb.symbology(i);\n                if (null === faceSymbFb)\n                    continue;\n                EGFBAccessors.FaceSymbology.createFaceSymbology(fbb, faceSymbFb.useColor(), faceSymbFb.useMaterial(), faceSymbFb.color(), faceSymbFb.materialId(), faceSymbFb.transparency(), 0, 0);\n            }\n            faceSymbOffset = fbb.endVector();\n        }\n        builder.startBRepData(fbb);\n        builder.addBrepType(fbb, ppfb.brepType());\n        let transform;\n        const entityTransform = ppfb.entityTransform();\n        if (null !== entityTransform)\n            transform = Transform.createRowValues(entityTransform.x00(), entityTransform.x01(), entityTransform.x02(), entityTransform.tx(), entityTransform.x10(), entityTransform.x11(), entityTransform.x12(), entityTransform.ty(), entityTransform.x20(), entityTransform.x21(), entityTransform.x22(), entityTransform.tz());\n        if (undefined !== transform)\n            transform.multiplyTransformTransform(inputTransform, transform);\n        else\n            transform = inputTransform;\n        const transformOffset = EGFBAccessors.Transform.createTransform(fbb, transform.matrix.coffs[0], transform.matrix.coffs[1], transform.matrix.coffs[2], transform.origin.x, transform.matrix.coffs[3], transform.matrix.coffs[4], transform.matrix.coffs[5], transform.origin.y, transform.matrix.coffs[6], transform.matrix.coffs[7], transform.matrix.coffs[8], transform.origin.z);\n        builder.addEntityTransform(fbb, transformOffset);\n        if (undefined !== dataOffset)\n            builder.addEntityData(fbb, dataOffset);\n        if (undefined !== faceSymbOffset)\n            builder.addSymbology(fbb, faceSymbOffset);\n        const mLoc = builder.endBRepData(fbb);\n        fbb.finish(mLoc);\n        entry.data = fbb.asUint8Array();\n        return true;\n    }\n    ElementGeometry.transformBRep = transformBRep;\n    /** @internal */\n    let StyleMod;\n    (function (StyleMod) {\n        StyleMod[StyleMod[\"Scale\"] = 1] = \"Scale\";\n        StyleMod[StyleMod[\"DashScale\"] = 2] = \"DashScale\";\n        StyleMod[StyleMod[\"GapScale\"] = 4] = \"GapScale\";\n        StyleMod[StyleMod[\"StartWidth\"] = 8] = \"StartWidth\";\n        StyleMod[StyleMod[\"EndWidth\"] = 16] = \"EndWidth\";\n        StyleMod[StyleMod[\"DistPhase\"] = 32] = \"DistPhase\";\n        StyleMod[StyleMod[\"FractPhase\"] = 64] = \"FractPhase\";\n        StyleMod[StyleMod[\"CenterPhase\"] = 128] = \"CenterPhase\";\n        StyleMod[StyleMod[\"Normal\"] = 256] = \"Normal\";\n        StyleMod[StyleMod[\"Rotation\"] = 512] = \"Rotation\";\n        StyleMod[StyleMod[\"PhysicalWidth\"] = 8192] = \"PhysicalWidth\";\n        StyleMod[StyleMod[\"SegMode\"] = 1073741824] = \"SegMode\";\n        StyleMod[StyleMod[\"NoSegMode\"] = 2147483648] = \"NoSegMode\";\n    })(StyleMod || (StyleMod = {}));\n    /** Update the supplied [[GeometryParams]] from an entry with appearance information */\n    function updateGeometryParams(entry, geomParams, localToWorld) {\n        if (!isAppearanceEntry(entry))\n            return false;\n        let changed = false;\n        switch (entry.opcode) {\n            case ElementGeometryOpcode.BasicSymbology: {\n                const buffer = new flatbuffers.ByteBuffer(entry.data);\n                const ppfb = EGFBAccessors.BasicSymbology.getRootAsBasicSymbology(buffer);\n                const subcatLong = ppfb.subCategoryId();\n                let subcatId = Id64.fromUint32Pair(subcatLong.low, subcatLong.high);\n                if (Id64.isInvalid(subcatId))\n                    subcatId = geomParams.subCategoryId; // Preserve current sub-category if not explicitly stored...\n                if (Id64.isValid(subcatId)) {\n                    geomParams.setSubCategoryId(subcatId); // Reset to sub-category appearance...\n                    changed = true;\n                }\n                if (ppfb.useColor()) {\n                    const lineColor = ColorDef.fromTbgr(ppfb.color());\n                    if (undefined === geomParams.lineColor || !lineColor.equals(geomParams.lineColor)) {\n                        geomParams.lineColor = lineColor;\n                        changed = true;\n                    }\n                }\n                if (ppfb.useWeight()) {\n                    const weight = ppfb.weight();\n                    if (undefined === geomParams.weight || weight !== geomParams.weight) {\n                        geomParams.weight = weight;\n                        changed = true;\n                    }\n                }\n                if (ppfb.useStyle()) {\n                    const styleLong = ppfb.lineStyleId();\n                    const styleId = Id64.fromUint32Pair(styleLong.low, styleLong.high);\n                    if (undefined === geomParams.styleInfo || styleId !== geomParams.styleInfo.styleId) {\n                        geomParams.styleInfo = new LineStyle.Info(styleId);\n                        changed = true;\n                    }\n                }\n                const transparency = ppfb.transparency();\n                if (transparency !== (undefined !== geomParams.elmTransparency ? geomParams.elmTransparency : 0)) {\n                    geomParams.elmTransparency = transparency;\n                    changed = true;\n                }\n                const displayPriority = ppfb.displayPriority();\n                if (displayPriority !== (undefined !== geomParams.elmPriority ? geomParams.elmPriority : 0)) {\n                    geomParams.elmPriority = displayPriority;\n                    changed = true;\n                }\n                const geometryClass = ppfb.geomClass();\n                if (geometryClass !== (undefined !== geomParams.geometryClass ? geomParams.geometryClass : GeometryClass.Primary)) {\n                    geomParams.geometryClass = geometryClass;\n                    changed = true;\n                }\n                return changed;\n            }\n            case ElementGeometryOpcode.LineStyleModifiers: {\n                const buffer = new flatbuffers.ByteBuffer(entry.data);\n                const ppfb = EGFBAccessors.LineStyleModifiers.getRootAsLineStyleModifiers(buffer);\n                const props = {};\n                if (0 !== (ppfb.modifiers() & StyleMod.Scale))\n                    props.scale = ppfb.scale();\n                if (0 !== (ppfb.modifiers() & StyleMod.GapScale))\n                    props.gapScale = ppfb.gapScale();\n                if (0 !== (ppfb.modifiers() & StyleMod.DashScale))\n                    props.dashScale = ppfb.dashScale();\n                if (0 !== (ppfb.modifiers() & StyleMod.StartWidth))\n                    props.startWidth = ppfb.startWidth();\n                if (0 !== (ppfb.modifiers() & StyleMod.EndWidth))\n                    props.endWidth = ppfb.endWidth();\n                if (0 !== (ppfb.modifiers() & StyleMod.DistPhase))\n                    props.distPhase = ppfb.distPhase();\n                if (0 !== (ppfb.modifiers() & StyleMod.FractPhase))\n                    props.fractPhase = ppfb.fractPhase();\n                if (0 !== (ppfb.modifiers() & StyleMod.CenterPhase))\n                    props.centerPhase = true;\n                if (0 !== (ppfb.modifiers() & StyleMod.SegMode))\n                    props.segmentMode = true;\n                else if (0 !== (ppfb.modifiers() & StyleMod.NoSegMode))\n                    props.segmentMode = false;\n                if (0 !== (ppfb.modifiers() & StyleMod.PhysicalWidth))\n                    props.physicalWidth = true;\n                if (0 !== (ppfb.modifiers() & StyleMod.Normal)) {\n                    const normal = ppfb.normal();\n                    if (null !== normal)\n                        props.normal = Vector3d.create(normal.x(), normal.y(), normal.z());\n                }\n                if (0 !== (ppfb.modifiers() & StyleMod.Rotation))\n                    props.rotation = YawPitchRollAngles.createDegrees(ppfb.yaw(), ppfb.pitch(), ppfb.roll());\n                const styleMod = new LineStyle.Modifier(props);\n                if (undefined !== localToWorld)\n                    styleMod.applyTransform(localToWorld);\n                if (undefined === geomParams.styleInfo) {\n                    geomParams.styleInfo = new LineStyle.Info(Id64.invalid, styleMod);\n                    changed = true;\n                }\n                else if (undefined === geomParams.styleInfo.styleMod || !styleMod.equals(geomParams.styleInfo.styleMod)) {\n                    geomParams.styleInfo.styleMod = styleMod;\n                    changed = true;\n                }\n                return changed;\n            }\n            case ElementGeometryOpcode.Fill: {\n                const buffer = new flatbuffers.ByteBuffer(entry.data);\n                const ppfb = EGFBAccessors.AreaFill.getRootAsAreaFill(buffer);\n                const toFillDisplay = (fill) => {\n                    switch (fill) {\n                        case EGFBAccessors.FillDisplay.ByView:\n                            return FillDisplay.ByView;\n                        case EGFBAccessors.FillDisplay.Always:\n                            return FillDisplay.Always;\n                        case EGFBAccessors.FillDisplay.Blanking:\n                            return FillDisplay.Blanking;\n                        default:\n                            return FillDisplay.Never;\n                    }\n                };\n                const fillDisplay = toFillDisplay(ppfb.fill());\n                if (fillDisplay !== (undefined !== geomParams.fillDisplay ? geomParams.fillDisplay : FillDisplay.Never)) {\n                    geomParams.fillDisplay = fillDisplay;\n                    changed = true;\n                }\n                if (FillDisplay.Never === fillDisplay)\n                    return changed;\n                const transparency = ppfb.transparency();\n                if (transparency !== (undefined !== geomParams.fillTransparency ? geomParams.fillTransparency : 0)) {\n                    geomParams.fillTransparency = transparency;\n                    changed = true;\n                }\n                if (EGFBAccessors.GradientMode.None !== ppfb.mode()) {\n                    const toGradientMode = (mode) => {\n                        switch (mode) {\n                            case EGFBAccessors.GradientMode.Linear:\n                                return Gradient.Mode.Linear;\n                            case EGFBAccessors.GradientMode.Curved:\n                                return Gradient.Mode.Curved;\n                            case EGFBAccessors.GradientMode.Cylindrical:\n                                return Gradient.Mode.Cylindrical;\n                            case EGFBAccessors.GradientMode.Spherical:\n                                return Gradient.Mode.Spherical;\n                            case EGFBAccessors.GradientMode.Hemispherical:\n                                return Gradient.Mode.Hemispherical;\n                            case EGFBAccessors.GradientMode.Thematic:\n                                return Gradient.Mode.Thematic;\n                            default:\n                                return Gradient.Mode.None;\n                        }\n                    };\n                    const keys = [];\n                    const colors = ppfb.colorsArray();\n                    const values = ppfb.valuesArray();\n                    if (null !== colors && null !== values && colors.length === values.length) {\n                        for (let iKey = 0; iKey < colors.length; ++iKey)\n                            keys.push({ value: values[iKey], color: colors[iKey] });\n                    }\n                    const props = { mode: toGradientMode(ppfb.mode()), keys };\n                    const flags = ppfb.flags();\n                    const angle = ppfb.angle();\n                    const tint = ppfb.tint();\n                    const shift = ppfb.shift();\n                    props.flags = (0 !== flags ? flags : undefined);\n                    props.angle = (0 !== angle ? { radians: angle } : undefined);\n                    props.tint = (0 !== tint ? tint : undefined);\n                    props.shift = (0 !== shift ? shift : undefined);\n                    if (Gradient.Mode.Thematic === props.mode) {\n                        const thematic = ppfb.thematicSettings();\n                        if (null !== thematic) {\n                            const tprops = {};\n                            const mode = thematic.mode();\n                            const stepCount = thematic.stepCount();\n                            const marginColor = thematic.marginColor();\n                            const colorScheme = thematic.colorScheme();\n                            tprops.mode = (0 !== mode ? mode : undefined);\n                            tprops.stepCount = (0 !== stepCount ? stepCount : undefined);\n                            tprops.marginColor = (0 !== marginColor ? marginColor : undefined);\n                            tprops.colorScheme = (0 !== colorScheme ? colorScheme : undefined);\n                            props.thematicSettings = tprops;\n                        }\n                    }\n                    const gradient = Gradient.Symb.fromJSON(props);\n                    if (undefined === geomParams.gradient || !gradient.equals(geomParams.gradient)) {\n                        geomParams.gradient = gradient;\n                        changed = true;\n                    }\n                }\n                else if (0 !== ppfb.backgroundFill()) {\n                    const backgroundFill = (2 === ppfb.backgroundFill() ? BackgroundFill.Outline : BackgroundFill.Solid);\n                    if (backgroundFill !== geomParams.backgroundFill) {\n                        geomParams.backgroundFill = backgroundFill;\n                        changed = true;\n                    }\n                }\n                else if (ppfb.useColor()) {\n                    const fillColor = ColorDef.fromTbgr(ppfb.color());\n                    if (undefined === geomParams.fillColor || !fillColor.equals(geomParams.fillColor)) {\n                        geomParams.fillColor = fillColor;\n                        changed = true;\n                    }\n                }\n                return changed;\n            }\n            case ElementGeometryOpcode.Pattern: {\n                const buffer = new flatbuffers.ByteBuffer(entry.data);\n                const ppfb = EGFBAccessors.AreaPattern.getRootAsAreaPattern(buffer);\n                const props = {};\n                const origin = ppfb.origin();\n                if (null !== origin) {\n                    const point = Point3d.create(origin.x(), origin.y(), origin.z());\n                    if (!point.isAlmostZero)\n                        props.origin = point;\n                }\n                const rotation = ppfb.rotation();\n                if (null !== rotation) {\n                    const angles = YawPitchRollAngles.createFromMatrix3d(Matrix3d.createRowValues(rotation.x00(), rotation.x01(), rotation.x02(), rotation.x10(), rotation.x11(), rotation.x12(), rotation.x20(), rotation.x21(), rotation.x22()));\n                    if (undefined !== angles && !angles.isIdentity())\n                        props.rotation = angles;\n                }\n                const space1 = ppfb.space1();\n                const space2 = ppfb.space2();\n                const angle1 = ppfb.angle1();\n                const angle2 = ppfb.angle2();\n                const scale = ppfb.scale();\n                props.space1 = (0 !== space1 ? space1 : undefined);\n                props.space2 = (0 !== space2 ? space2 : undefined);\n                props.angle1 = (0 !== angle1 ? { radians: angle1 } : undefined);\n                props.angle2 = (0 !== angle2 ? { radians: angle2 } : undefined);\n                props.scale = (0 !== scale ? scale : undefined);\n                if (ppfb.useColor())\n                    props.color = ppfb.color();\n                if (ppfb.useWeight())\n                    props.weight = ppfb.weight();\n                props.invisibleBoundary = (1 === ppfb.invisibleBoundary() ? true : undefined);\n                props.snappable = (1 === ppfb.snappable() ? true : undefined);\n                const symbolId = Id64.fromUint32Pair(ppfb.symbolId().low, ppfb.symbolId().high);\n                props.symbolId = (Id64.isValid(symbolId) ? symbolId : undefined);\n                const nDefLines = ppfb.defLineLength();\n                if (0 !== nDefLines) {\n                    const defLines = [];\n                    for (let iLine = 0; iLine < nDefLines; ++iLine) {\n                        const defLine = ppfb.defLine(iLine);\n                        if (!defLine)\n                            continue;\n                        const line = {};\n                        const angle = defLine.angle();\n                        line.angle = (0 !== angle ? { radians: defLine.angle() } : undefined);\n                        const through = defLine.through();\n                        if (through) {\n                            const thr = Point2d.create(through.x(), through.y());\n                            if (!thr.isAlmostZero)\n                                line.through = thr;\n                        }\n                        const offset = defLine.offset();\n                        if (offset) {\n                            const off = Point2d.create(offset.x(), offset.y());\n                            if (!off.isAlmostZero)\n                                line.offset = off;\n                        }\n                        const dashArray = defLine.dashesArray();\n                        if (0 !== defLine.dashesLength() && null !== dashArray) {\n                            const dashes = [];\n                            for (const value of dashArray) {\n                                dashes.push(value);\n                            }\n                            line.dashes = dashes;\n                        }\n                        defLines.push(line);\n                    }\n                    props.defLines = defLines;\n                }\n                const pattern = AreaPattern.Params.fromJSON(props);\n                if (undefined !== localToWorld)\n                    pattern.applyTransform(localToWorld);\n                if (undefined === geomParams.pattern || !pattern.equals(geomParams.pattern)) {\n                    geomParams.pattern = pattern;\n                    changed = true;\n                }\n                return changed;\n            }\n            case ElementGeometryOpcode.Material: {\n                const buffer = new flatbuffers.ByteBuffer(entry.data);\n                const ppfb = EGFBAccessors.Material.getRootAsMaterial(buffer);\n                if (ppfb.useMaterial()) {\n                    const matLong = ppfb.materialId();\n                    const materialId = Id64.fromUint32Pair(matLong.low, matLong.high);\n                    if (undefined === geomParams.materialId || materialId !== geomParams.materialId) {\n                        geomParams.materialId = materialId;\n                        changed = true;\n                    }\n                }\n                return changed;\n            }\n            default:\n                return changed;\n        }\n    }\n    ElementGeometry.updateGeometryParams = updateGeometryParams;\n    /** Append entries to represent a [[GeometryParams]] */\n    function appendGeometryParams(geomParams, entries, worldToLocal) {\n        const fbbBas = new flatbuffers.Builder();\n        const builder = EGFBAccessors.BasicSymbology;\n        builder.startBasicSymbology(fbbBas);\n        const subcatIdPair = Id64.getUint32Pair(geomParams.subCategoryId);\n        builder.addSubCategoryId(fbbBas, flatbuffers.Long.create(subcatIdPair.lower, subcatIdPair.upper));\n        if (undefined !== geomParams.lineColor) {\n            builder.addColor(fbbBas, geomParams.lineColor.tbgr);\n            builder.addUseColor(fbbBas, 1);\n        }\n        if (undefined !== geomParams.weight) {\n            builder.addWeight(fbbBas, geomParams.weight);\n            builder.addUseWeight(fbbBas, 1);\n        }\n        if (undefined !== geomParams.styleInfo) {\n            const styleIdPair = Id64.getUint32Pair(geomParams.styleInfo.styleId);\n            builder.addLineStyleId(fbbBas, flatbuffers.Long.create(styleIdPair.lower, styleIdPair.upper));\n            builder.addUseStyle(fbbBas, 1);\n        }\n        if (undefined !== geomParams.elmTransparency && 0 !== geomParams.elmTransparency) {\n            builder.addTransparency(fbbBas, geomParams.elmTransparency);\n        }\n        if (undefined !== geomParams.elmPriority && 0 !== geomParams.elmPriority) {\n            builder.addDisplayPriority(fbbBas, geomParams.elmPriority);\n        }\n        if (undefined !== geomParams.geometryClass && GeometryClass.Primary !== geomParams.geometryClass) {\n            builder.addGeomClass(fbbBas, geomParams.geometryClass);\n        }\n        const mLoc = builder.endBasicSymbology(fbbBas);\n        fbbBas.finish(mLoc);\n        const data = fbbBas.asUint8Array();\n        entries.push({ opcode: ElementGeometryOpcode.BasicSymbology, data });\n        if (undefined !== geomParams.styleInfo && undefined !== geomParams.styleInfo.styleMod) {\n            const fbbLS = new flatbuffers.Builder();\n            const builderLS = EGFBAccessors.LineStyleModifiers;\n            builderLS.startLineStyleModifiers(fbbLS);\n            let lsMods = geomParams.styleInfo.styleMod;\n            if (undefined !== worldToLocal) {\n                lsMods = new LineStyle.Modifier(lsMods);\n                if (!lsMods.applyTransform(worldToLocal))\n                    return false;\n            }\n            let modifiers = 0;\n            if (undefined !== lsMods.scale) {\n                builderLS.addScale(fbbLS, lsMods.scale);\n                modifiers |= StyleMod.Scale;\n            }\n            if (undefined !== lsMods.dashScale) {\n                builderLS.addDashScale(fbbLS, lsMods.dashScale);\n                modifiers |= StyleMod.DashScale;\n            }\n            if (undefined !== lsMods.gapScale) {\n                builderLS.addGapScale(fbbLS, lsMods.gapScale);\n                modifiers |= StyleMod.GapScale;\n            }\n            if (undefined !== lsMods.startWidth) {\n                builderLS.addStartWidth(fbbLS, lsMods.startWidth);\n                modifiers |= StyleMod.StartWidth;\n            }\n            if (undefined !== lsMods.endWidth) {\n                builderLS.addEndWidth(fbbLS, lsMods.endWidth);\n                modifiers |= StyleMod.EndWidth;\n            }\n            if (undefined !== lsMods.distPhase) {\n                builderLS.addDistPhase(fbbLS, lsMods.distPhase);\n                modifiers |= StyleMod.DistPhase;\n            }\n            if (undefined !== lsMods.fractPhase) {\n                builderLS.addFractPhase(fbbLS, lsMods.fractPhase);\n                modifiers |= StyleMod.FractPhase;\n            }\n            if (lsMods.centerPhase) {\n                modifiers |= StyleMod.CenterPhase;\n            }\n            if (undefined !== lsMods.segmentMode) {\n                modifiers |= (lsMods.segmentMode ? StyleMod.SegMode : StyleMod.NoSegMode);\n            }\n            if (lsMods.physicalWidth) {\n                modifiers |= StyleMod.PhysicalWidth;\n            }\n            if (undefined !== lsMods.normal) {\n                const normalOffset = EGFBAccessors.DVec3d.createDVec3d(fbbLS, lsMods.normal.x, lsMods.normal.y, lsMods.normal.z);\n                builderLS.addNormal(fbbLS, normalOffset);\n                modifiers |= StyleMod.Normal;\n            }\n            if (undefined !== lsMods.rotation) {\n                builderLS.addYaw(fbbLS, lsMods.rotation.yaw.degrees);\n                builderLS.addPitch(fbbLS, lsMods.rotation.pitch.degrees);\n                builderLS.addRoll(fbbLS, lsMods.rotation.roll.degrees);\n                modifiers |= StyleMod.Rotation;\n            }\n            builderLS.addModifiers(fbbLS, modifiers);\n            const mLocLS = builderLS.endLineStyleModifiers(fbbLS);\n            fbbLS.finish(mLocLS);\n            const dataLS = fbbLS.asUint8Array();\n            if (0 !== modifiers)\n                entries.push({ opcode: ElementGeometryOpcode.LineStyleModifiers, data: dataLS });\n        }\n        if (undefined !== geomParams.fillDisplay && FillDisplay.Never !== geomParams.fillDisplay) {\n            const fbbFill = new flatbuffers.Builder();\n            const builderFill = EGFBAccessors.AreaFill;\n            let keyValuesOff;\n            let keyColorsOff;\n            let thematicOffset;\n            if (undefined !== geomParams.gradient) {\n                const keyColors = [];\n                const keyValues = [];\n                for (const key of geomParams.gradient.keys) {\n                    keyColors.push(key.color.tbgr);\n                    keyValues.push(key.value);\n                }\n                keyValuesOff = builderFill.createValuesVector(fbbFill, keyValues);\n                keyColorsOff = builderFill.createColorsVector(fbbFill, keyColors);\n                if (Gradient.Mode.Thematic === geomParams.gradient.mode && undefined !== geomParams.gradient.thematicSettings) {\n                    const thematic = geomParams.gradient.thematicSettings;\n                    const builderThematic = EGFBAccessors.ThematicSettings;\n                    builderThematic.startThematicSettings(fbbFill);\n                    builderThematic.addMode(fbbFill, thematic.mode);\n                    builderThematic.addStepCount(fbbFill, thematic.stepCount);\n                    builderThematic.addMarginColor(fbbFill, thematic.marginColor.tbgr);\n                    builderThematic.addColorScheme(fbbFill, thematic.colorScheme);\n                    const rangeOffset = EGFBAccessors.DRange1d.createDRange1d(fbbFill, ThematicGradientSettings.contentRange, ThematicGradientSettings.contentMax);\n                    builderThematic.addRange(fbbFill, rangeOffset);\n                    thematicOffset = builderThematic.endThematicSettings(fbbFill);\n                }\n            }\n            builderFill.startAreaFill(fbbFill);\n            const toEGFBFillDisplay = (fill) => {\n                switch (fill) {\n                    case FillDisplay.ByView:\n                        return EGFBAccessors.FillDisplay.ByView;\n                    case FillDisplay.Always:\n                        return EGFBAccessors.FillDisplay.Always;\n                    case FillDisplay.Blanking:\n                        return EGFBAccessors.FillDisplay.Blanking;\n                    default:\n                        return EGFBAccessors.FillDisplay.None;\n                }\n            };\n            builderFill.addFill(fbbFill, toEGFBFillDisplay(geomParams.fillDisplay));\n            if (undefined !== geomParams.fillTransparency)\n                builderFill.addTransparency(fbbFill, geomParams.fillTransparency);\n            if (undefined !== geomParams.gradient) {\n                const toEGFBGradientMode = (mode) => {\n                    switch (mode) {\n                        case Gradient.Mode.Linear:\n                            return EGFBAccessors.GradientMode.Linear;\n                        case Gradient.Mode.Curved:\n                            return EGFBAccessors.GradientMode.Curved;\n                        case Gradient.Mode.Cylindrical:\n                            return EGFBAccessors.GradientMode.Cylindrical;\n                        case Gradient.Mode.Spherical:\n                            return EGFBAccessors.GradientMode.Spherical;\n                        case Gradient.Mode.Hemispherical:\n                            return EGFBAccessors.GradientMode.Hemispherical;\n                        case Gradient.Mode.Thematic:\n                            return EGFBAccessors.GradientMode.Thematic;\n                        default:\n                            return EGFBAccessors.GradientMode.None;\n                    }\n                };\n                builderFill.addMode(fbbFill, toEGFBGradientMode(geomParams.gradient.mode));\n                builderFill.addFlags(fbbFill, geomParams.gradient.flags);\n                builderFill.addShift(fbbFill, geomParams.gradient.shift);\n                if (undefined !== geomParams.gradient.tint)\n                    builderFill.addTint(fbbFill, geomParams.gradient.tint);\n                if (undefined !== geomParams.gradient.angle)\n                    builderFill.addAngle(fbbFill, geomParams.gradient.angle.radians);\n                if (undefined !== keyValuesOff)\n                    builderFill.addValues(fbbFill, keyValuesOff);\n                if (undefined !== keyColorsOff)\n                    builderFill.addColors(fbbFill, keyColorsOff);\n                if (undefined !== thematicOffset)\n                    builderFill.addThematicSettings(fbbFill, thematicOffset);\n            }\n            else if (undefined !== geomParams.backgroundFill && BackgroundFill.None !== geomParams.backgroundFill) {\n                builderFill.addBackgroundFill(fbbFill, BackgroundFill.Outline === geomParams.backgroundFill ? 2 : 1);\n            }\n            else if (undefined !== geomParams.fillColor) {\n                builderFill.addColor(fbbFill, geomParams.fillColor.tbgr);\n                builderFill.addUseColor(fbbFill, 1);\n            }\n            const mLocFill = builderFill.endAreaFill(fbbFill);\n            fbbFill.finish(mLocFill);\n            const dataFill = fbbFill.asUint8Array();\n            entries.push({ opcode: ElementGeometryOpcode.Fill, data: dataFill });\n        }\n        if (undefined !== geomParams.pattern) {\n            const fbbPat = new flatbuffers.Builder();\n            const builderPat = EGFBAccessors.AreaPattern;\n            let pattern = geomParams.pattern;\n            if (undefined !== worldToLocal) {\n                pattern = pattern.clone();\n                if (!pattern.applyTransform(worldToLocal))\n                    return false;\n            }\n            let defLineVecOffset;\n            if (undefined !== pattern.defLines) {\n                const defLines = pattern.defLines;\n                const builderDefLines = EGFBAccessors.DwgHatchDefLine;\n                const defLineOffsets = [];\n                for (const line of defLines) {\n                    let dashOffset;\n                    if (undefined !== line.dashes)\n                        dashOffset = builderDefLines.createDashesVector(fbbPat, line.dashes);\n                    builderDefLines.startDwgHatchDefLine(fbbPat);\n                    if (undefined !== line.angle)\n                        builderDefLines.addAngle(fbbPat, line.angle.radians);\n                    // NOTE: Backend requires through and offset to be present...\n                    const throughOffset = EGFBAccessors.DPoint2d.createDPoint2d(fbbPat, undefined !== line.through ? line.through.x : 0, undefined !== line.through ? line.through.y : 0);\n                    builderDefLines.addThrough(fbbPat, throughOffset);\n                    const offsetOffset = EGFBAccessors.DPoint2d.createDPoint2d(fbbPat, undefined !== line.offset ? line.offset.x : 0, undefined !== line.offset ? line.offset.y : 0);\n                    builderDefLines.addOffset(fbbPat, offsetOffset);\n                    if (undefined !== dashOffset)\n                        builderDefLines.addDashes(fbbPat, dashOffset);\n                    defLineOffsets.push(builderDefLines.endDwgHatchDefLine(fbbPat));\n                }\n                if (0 !== defLineOffsets.length)\n                    defLineVecOffset = builderPat.createDefLineVector(fbbPat, defLineOffsets);\n            }\n            builderPat.startAreaPattern(fbbPat);\n            if (undefined !== pattern.origin) {\n                const originOffset = EGFBAccessors.DPoint3d.createDPoint3d(fbbPat, pattern.origin.x, pattern.origin.y, pattern.origin.z);\n                builderPat.addOrigin(fbbPat, originOffset);\n            }\n            if (undefined !== pattern.rotation) {\n                const matrix = pattern.rotation.toMatrix3d();\n                const coffs = matrix.coffs;\n                const rotationOffset = EGFBAccessors.RotMatrix.createRotMatrix(fbbPat, coffs[0], coffs[1], coffs[2], coffs[3], coffs[4], coffs[5], coffs[6], coffs[7], coffs[8]);\n                builderPat.addRotation(fbbPat, rotationOffset);\n            }\n            if (undefined !== pattern.space1)\n                builderPat.addSpace1(fbbPat, pattern.space1);\n            if (undefined !== pattern.space2)\n                builderPat.addSpace2(fbbPat, pattern.space2);\n            if (undefined !== pattern.angle1)\n                builderPat.addAngle1(fbbPat, pattern.angle1.radians);\n            if (undefined !== pattern.angle2)\n                builderPat.addAngle2(fbbPat, pattern.angle2.radians);\n            if (undefined !== pattern.scale)\n                builderPat.addScale(fbbPat, pattern.scale);\n            if (undefined !== pattern.color) {\n                builderPat.addColor(fbbPat, pattern.color.tbgr);\n                builderPat.addUseColor(fbbPat, 1);\n            }\n            if (undefined !== pattern.weight) {\n                builderPat.addWeight(fbbPat, pattern.weight);\n                builderPat.addUseWeight(fbbPat, 1);\n            }\n            if (undefined !== pattern.invisibleBoundary && pattern.invisibleBoundary)\n                builderPat.addInvisibleBoundary(fbbPat, 1);\n            if (undefined !== pattern.snappable && pattern.snappable)\n                builderPat.addSnappable(fbbPat, 1);\n            if (undefined !== pattern.symbolId) {\n                const symbolIdPair = Id64.getUint32Pair(pattern.symbolId);\n                builderPat.addSymbolId(fbbPat, flatbuffers.Long.create(symbolIdPair.lower, symbolIdPair.upper));\n            }\n            if (undefined !== defLineVecOffset)\n                builderPat.addDefLine(fbbPat, defLineVecOffset);\n            const mLocPat = builderPat.endAreaPattern(fbbPat);\n            fbbPat.finish(mLocPat);\n            const dataPat = fbbPat.asUint8Array();\n            entries.push({ opcode: ElementGeometryOpcode.Pattern, data: dataPat });\n        }\n        if (undefined !== geomParams.materialId) {\n            const fbbMat = new flatbuffers.Builder();\n            const builderMat = EGFBAccessors.Material;\n            builderMat.startMaterial(fbbMat);\n            const matIdPair = Id64.getUint32Pair(geomParams.materialId);\n            builderMat.addMaterialId(fbbMat, flatbuffers.Long.create(matIdPair.lower, matIdPair.upper));\n            builderMat.addUseMaterial(fbbMat, 1);\n            const mLocMat = builderMat.endMaterial(fbbMat);\n            fbbMat.finish(mLocMat);\n            const dataMat = fbbMat.asUint8Array();\n            entries.push({ opcode: ElementGeometryOpcode.Material, data: dataMat });\n        }\n        return true;\n    }\n    ElementGeometry.appendGeometryParams = appendGeometryParams;\n    /** Return entry as [[GeometryPart]] id and instance transform */\n    function toGeometryPart(entry, partToElement) {\n        if (ElementGeometryOpcode.PartReference !== entry.opcode)\n            return undefined;\n        const buffer = new flatbuffers.ByteBuffer(entry.data);\n        const ppfb = EGFBAccessors.GeometryPart.getRootAsGeometryPart(buffer);\n        const partLong = ppfb.geomPartId();\n        const partId = Id64.fromUint32Pair(partLong.low, partLong.high);\n        if (undefined !== partToElement) {\n            let origin;\n            const originfb = ppfb.origin();\n            if (null !== originfb)\n                origin = Point3d.create(originfb.x(), originfb.y(), originfb.z());\n            else\n                origin = Point3d.createZero();\n            const angles = YawPitchRollAngles.createDegrees(ppfb.yaw(), ppfb.pitch(), ppfb.roll());\n            const matrix = angles.toMatrix3d();\n            if (1.0 !== ppfb.scale())\n                matrix.scaleColumnsInPlace(ppfb.scale(), ppfb.scale(), ppfb.scale());\n            Transform.createOriginAndMatrix(origin, matrix, partToElement);\n        }\n        return partId;\n    }\n    ElementGeometry.toGeometryPart = toGeometryPart;\n    /** Create entry from a [[GeometryPart]] id and instance transform */\n    function fromGeometryPart(partId, partTransform, worldToLocal) {\n        let partToElement = partTransform;\n        if (undefined !== worldToLocal)\n            partToElement = worldToLocal.multiplyTransformTransform(undefined !== partTransform ? partTransform : Transform.createIdentity());\n        const fbb = new flatbuffers.Builder();\n        const builder = EGFBAccessors.GeometryPart;\n        builder.startGeometryPart(fbb);\n        const idPair = Id64.getUint32Pair(partId);\n        builder.addGeomPartId(fbb, flatbuffers.Long.create(idPair.lower, idPair.upper));\n        if (undefined !== partToElement && !partToElement.isIdentity) {\n            const originOffset = EGFBAccessors.DPoint3d.createDPoint3d(fbb, partToElement.origin.x, partToElement.origin.y, partToElement.origin.z);\n            builder.addOrigin(fbb, originOffset);\n            const angles = YawPitchRollAngles.createFromMatrix3d(partToElement.matrix);\n            if (undefined !== angles) {\n                builder.addYaw(fbb, angles.yaw.degrees);\n                builder.addPitch(fbb, angles.pitch.degrees);\n                builder.addRoll(fbb, angles.roll.degrees);\n            }\n            const result = partToElement.matrix.factorRigidWithSignedScale();\n            if (undefined !== result && result.scale > 0.0)\n                builder.addScale(fbb, result.scale);\n        }\n        const mLoc = builder.endGeometryPart(fbb);\n        fbb.finish(mLoc);\n        const data = fbb.asUint8Array();\n        return { opcode: ElementGeometryOpcode.PartReference, data };\n    }\n    ElementGeometry.fromGeometryPart = fromGeometryPart;\n    /** Return entry as a [[ElementAlignedBox3d]] representing the local range of a geometric entry */\n    function toSubGraphicRange(entry) {\n        if (ElementGeometryOpcode.SubGraphicRange !== entry.opcode)\n            return undefined;\n        const buffer = new flatbuffers.ByteBuffer(entry.data);\n        const ppfb = EGFBAccessors.PointPrimitive.getRootAsPointPrimitive(buffer);\n        if (2 !== ppfb.coordsLength())\n            return undefined;\n        const low = Point3d.create(ppfb.coords(0).x(), ppfb.coords(0).y(), ppfb.coords(0).z());\n        const high = Point3d.create(ppfb.coords(1).x(), ppfb.coords(1).y(), ppfb.coords(1).z());\n        return Range3d.create(low, high);\n    }\n    ElementGeometry.toSubGraphicRange = toSubGraphicRange;\n    /** Create entry from a [[ElementAlignedBox3d]] to compute and store local ranges for subsequent geometric entries */\n    function fromSubGraphicRange(bbox) {\n        const fbb = new flatbuffers.Builder();\n        const builder = EGFBAccessors.PointPrimitive;\n        builder.startCoordsVector(fbb, 2);\n        fbb.addFloat64(bbox.high.z);\n        fbb.addFloat64(bbox.high.y);\n        fbb.addFloat64(bbox.high.x);\n        fbb.addFloat64(bbox.low.z);\n        fbb.addFloat64(bbox.low.y);\n        fbb.addFloat64(bbox.low.x);\n        const offset = fbb.endVector();\n        builder.startPointPrimitive(fbb);\n        builder.addCoords(fbb, offset);\n        const mLoc = builder.endPointPrimitive(fbb);\n        fbb.finish(mLoc);\n        const data = fbb.asUint8Array();\n        return { opcode: ElementGeometryOpcode.SubGraphicRange, data };\n    }\n    ElementGeometry.fromSubGraphicRange = fromSubGraphicRange;\n    /** Create [[Transform]] from row-major storage 4x3 Float64Array */\n    function toTransform(sourceToWorld) {\n        if (12 !== sourceToWorld.length)\n            return undefined;\n        return Transform.createRowValues(sourceToWorld[0], sourceToWorld[1], sourceToWorld[2], sourceToWorld[3], sourceToWorld[4], sourceToWorld[5], sourceToWorld[6], sourceToWorld[7], sourceToWorld[8], sourceToWorld[9], sourceToWorld[10], sourceToWorld[11]);\n    }\n    ElementGeometry.toTransform = toTransform;\n    /** Create [[ElementAlignedBox3d]] from lowX, lowY, lowZ, highX, highY, highZ Float64Array */\n    function toElementAlignedBox3d(bbox) {\n        if (6 !== bbox.length)\n            return undefined;\n        return Range3d.fromFloat64Array(bbox);\n    }\n    ElementGeometry.toElementAlignedBox3d = toElementAlignedBox3d;\n})(ElementGeometry || (ElementGeometry = {}));\n//# sourceMappingURL=ElementGeometry.js.map",
      "start": 1693508120570,
      "end": 1693508120633,
      "sourcemaps": null
    }
  ]
}
