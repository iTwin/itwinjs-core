{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/common/lib/esm/rpc/core/RpcPendingQueue.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module RpcInterface\n */\nimport { RpcRequestEvent, RpcRequestStatus } from \"./RpcConstants\";\nimport { RpcRequest } from \"./RpcRequest\";\n/* eslint-disable deprecation/deprecation */\n/** Manages pending RPC requests and responses.\n * @internal\n */\nexport class RpcPendingQueue {\n    static initialize() {\n        if (!RpcPendingQueue.instance) {\n            RpcPendingQueue.instance = new RpcPendingQueue();\n        }\n    }\n    constructor() {\n        this._pendingInterval = undefined;\n        this._pending = [];\n        this._pendingLock = 0;\n        this._pendingIntervalHandler = function () {\n            const now = new Date().getTime();\n            ++this._pendingLock;\n            for (const request of this._pending) {\n                const retry = request.retryAfter ?? request.retryInterval;\n                if (request.connecting || (request.lastSubmitted + retry) > now) {\n                    continue;\n                }\n                request.submit(); // eslint-disable-line @typescript-eslint/no-floating-promises\n            }\n            --this._pendingLock;\n            this.cleanupPendingQueue();\n        }.bind(this);\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        RpcRequest.events.addListener(this.requestEventHandler, this);\n    }\n    requestEventHandler(type, request) {\n        if (type !== RpcRequestEvent.StatusChanged)\n            return;\n        switch (request.status) {\n            case RpcRequestStatus.Submitted: {\n                this.enqueuePending(request);\n                break;\n            }\n            case RpcRequestStatus.Resolved:\n            case RpcRequestStatus.Rejected:\n            case RpcRequestStatus.NotFound:\n            case RpcRequestStatus.Cancelled: {\n                this.dequeuePending(request);\n                break;\n            }\n        }\n    }\n    enqueuePending(request) {\n        this._pending.push(request);\n        this.setPendingInterval();\n    }\n    dequeuePending(request) {\n        if (this._pendingLock)\n            return;\n        const i = this._pending.indexOf(request);\n        this._pending.splice(i, 1);\n        this.clearPendingInterval();\n    }\n    cleanupPendingQueue() {\n        if (this._pendingLock)\n            return;\n        let i = this._pending.length;\n        while (i--) {\n            if (!this._pending[i].pending && !RpcRequestStatus.isTransientError(this._pending[i].status)) {\n                this._pending.splice(i, 1);\n            }\n        }\n        this.clearPendingInterval();\n    }\n    setPendingInterval() {\n        if (this._pendingInterval)\n            return;\n        this._pendingInterval = setInterval(this._pendingIntervalHandler, 0);\n    }\n    clearPendingInterval() {\n        if (!this._pending.length) {\n            clearInterval(this._pendingInterval);\n            this._pendingInterval = undefined;\n        }\n    }\n}\n//# sourceMappingURL=RpcPendingQueue.js.map",
      "start": 1693508120819,
      "end": 1693508120891,
      "sourcemaps": null
    }
  ]
}
