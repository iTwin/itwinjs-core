{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/BatchState.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { assert, Id64, lowerBound } from \"@itwin/core-bentley\";\n/**\n * Assigns a transient, unique 32-bit integer ID to each Batch in a RenderCommands.\n * A batch ID of 0 means \"no batch\".\n * The first batch gets batch ID of 1.\n * The next batch gets the previous batch's ID plus the number of features in the previous batch's feature table\n * (or 1, if empty feature table).\n * The IDs are set temporarily as members on the Batch objects and reset to 0 immediately after rendering.\n * The currentBatch member identifies the batch containing primitives currently being drawn.\n * The combination of the current batch's ID (passed as uniform to shader) and the index of a given Feature within\n * its batch's FeatureTable (stored in vertex table) produce a unique ID for every feature rendered during a frame.\n * During rendering, the feature IDs are written to the \"feature ID\" color attachment.\n * The batch IDs remain valid during a call to Target.readPixels() so that they can be used to extract\n * Features from the Batch's FeatureTables.\n * @internal\n */\nclass BatchState {\n    constructor(stack) {\n        this._batches = []; // NB: this list is ordered - but *not* indexed - by batch ID.\n        this._stack = stack;\n    }\n    get currentBatch() { return this._curBatch; }\n    get currentBatchId() { return undefined !== this._curBatch ? this._curBatch.batchId : 0; }\n    get currentBatchIModel() { return undefined !== this._curBatch ? this._curBatch.batchIModel : undefined; }\n    get isEmpty() { return 0 === this._batches.length; }\n    push(batch, allowAdd) {\n        assert(undefined === this.currentBatch, \"batches cannot nest\");\n        this.getBatchId(batch, allowAdd);\n        this._curBatch = batch;\n    }\n    pop() {\n        assert(undefined !== this.currentBatch);\n        this._curBatch = undefined;\n    }\n    reset() {\n        assert(undefined === this.currentBatch);\n        for (const batch of this._batches)\n            batch.resetContext();\n        this._batches.length = 0;\n        this._curBatch = undefined;\n    }\n    getElementId(featureId) {\n        const batch = this.find(featureId);\n        if (undefined === batch)\n            return Id64.invalid;\n        const featureIndex = featureId - batch.batchId;\n        assert(featureIndex >= 0);\n        const parts = batch.featureTable.getElementIdPair(featureIndex, BatchState._scratchElementIdPair);\n        return Id64.fromUint32Pair(parts.lower, parts.upper);\n    }\n    getFeature(featureId, result) {\n        const batch = this.find(featureId);\n        if (undefined === batch)\n            return undefined;\n        const featureIndex = featureId - batch.batchId;\n        assert(featureIndex >= 0);\n        return batch.featureTable.findFeature(featureIndex, result);\n    }\n    get numFeatureIds() { return this.nextBatchId; }\n    get numBatches() { return this._batches.length; }\n    findBatchId(featureId) {\n        const batch = this.find(featureId);\n        return undefined !== batch ? batch.batchId : 0;\n    }\n    get nextBatchId() {\n        if (this.isEmpty)\n            return 1;\n        const prev = this._batches[this._batches.length - 1];\n        assert(0 !== prev.batchId);\n        let prevNumFeatures = prev.featureTable.numFeatures;\n        if (0 === prevNumFeatures)\n            prevNumFeatures = 1;\n        return prev.batchId + prevNumFeatures;\n    }\n    getBatchId(batch, allowAdd) {\n        if (allowAdd && 0 === batch.batchId) {\n            batch.setContext(this.nextBatchId, this._stack.top);\n            this._batches.push(batch);\n        }\n        return batch.batchId;\n    }\n    indexOf(featureId) {\n        if (featureId <= 0)\n            return -1;\n        const found = lowerBound(featureId, this._batches, (lhs, rhs) => {\n            // Determine if the requested feature ID is within the range of this batch.\n            if (lhs < rhs.batchId)\n                return -1;\n            const numFeatures = rhs.featureTable.numFeatures;\n            const nextBatchId = rhs.batchId + (numFeatures > 0 ? numFeatures : 1);\n            return lhs < nextBatchId ? 0 : 1;\n        });\n        return found.index < this._batches.length ? found.index : -1;\n    }\n    find(featureId) {\n        const index = this.indexOf(featureId);\n        return -1 !== index ? this._batches[index] : undefined;\n    }\n}\nBatchState._scratchElementIdPair = { lower: 0, upper: 0 };\nexport { BatchState };\n//# sourceMappingURL=BatchState.js.map",
      "start": 1693508123702,
      "end": 1693508123855,
      "sourcemaps": null
    }
  ]
}
