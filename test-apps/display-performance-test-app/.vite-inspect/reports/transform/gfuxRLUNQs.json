{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/glsl/Surface.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { assert } from \"@itwin/core-bentley\";\nimport { AttributeMap } from \"../AttributeMap\";\nimport { Material } from \"../Material\";\nimport { Pass, TextureUnit } from \"../RenderFlags\";\nimport { ProgramBuilder, } from \"../ShaderBuilder\";\nimport { System } from \"../System\";\nimport { addAnimation } from \"./Animation\";\nimport { unpackFloat } from \"./Clipping\";\nimport { addColor } from \"./Color\";\nimport { addChooseVec2WithBitFlagsFunction, addChooseVec3WithBitFlagFunction, addExtractNthBit, addFrustum, addShaderFlags } from \"./Common\";\nimport { addUnpackAndNormalize2Bytes, decodeDepthRgb, unquantize2d } from \"./Decode\";\nimport { addFeatureSymbology, addMaxAlpha, addRenderOrder, addRenderOrderConstants, addSurfaceDiscard, addSurfaceHiliter, } from \"./FeatureSymbology\";\nimport { addAltPickBufferOutputs, addFragColorWithPreMultipliedAlpha, addPickBufferOutputs, addWhiteOnWhiteReversal, assignFragColor, } from \"./Fragment\";\nimport { addLighting } from \"./Lighting\";\nimport { addSurfaceMonochrome } from \"./Monochrome\";\nimport { addColorPlanarClassifier, addFeaturePlanarClassifier, addHilitePlanarClassifier, addOverrideClassifierColor } from \"./PlanarClassification\";\nimport { addRenderPass } from \"./RenderPass\";\nimport { addSolarShadowMap } from \"./SolarShadowMapping\";\nimport { addThematicDisplay, getComputeThematicIndex } from \"./Thematic\";\nimport { addTranslucency } from \"./Translucency\";\nimport { addModelViewMatrix, addNormalMatrix, addProjectionMatrix } from \"./Vertex\";\nimport { wantMaterials } from \"../SurfaceGeometry\";\nimport { addWiremesh } from \"./Wiremesh\";\nimport { Npc } from \"@itwin/core-common\";\nconst constantLodTextureLookup = `\r\nvec4 constantLodTextureLookup(sampler2D textureSampler) {\r\n  float logDepth = log2(v_uvCustom.z);\r\n  float f = fract(logDepth);\r\n  float p = floor(logDepth);\r\n  // When p changes, both tc1 and tc2 jumped by a power of 2 at that transition (and f goes from ~1 to 0).\r\n  // This caused a line to show up with incorrect tex coords, we believe due to a problem with the derivative\r\n  // that is auto calculated on the tex coords for the mip-map.  The below approach attempts to \"smooth\"\r\n  // the transition of the coord in use at the transition by only changing the coord that is not in use\r\n  // (but by 2 powers of 2) and switching the mix selector to account for it.  It does this by using whether\r\n  // p is odd or even to select which way it is going, so it alternates at the boundaries.  This fixes the\r\n  // line problem.\r\n  float p1, p2;\r\n  if (0u == (uint(p) & 1u)) { // p is even\r\n    p1 = p;\r\n    p2 = p + 1.0;\r\n  } else { // p is odd\r\n    p1 = p + 1.0;\r\n    p2 = p;\r\n    f = 1.0 - f;\r\n  }\r\n\r\n  vec2 tc1 = v_uvCustom.xy / clamp(pow(2.0, p1), float(u_constantLodFParams.x), float(u_constantLodFParams.y)) * u_constantLodFParams.z;\r\n  vec2 tc2 = v_uvCustom.xy / clamp(pow(2.0, p2), float(u_constantLodFParams.x), float(u_constantLodFParams.y)) * u_constantLodFParams.z;\r\n  return mix(TEXTURE(textureSampler, tc1), TEXTURE(textureSampler, tc2), f);\r\n}\r\n`;\n// NB: Textures do not contain pre-multiplied alpha.\nconst sampleSurfaceTexture = `\r\nvec4 sampleSurfaceTexture() {\r\n  vec4 clr;\r\n  if (!isSurfaceBitSet(kSurfaceBit_HasTexture))\r\n    clr = vec4(1.0, 1.0, 1.0, 1.0);\r\n  else if (u_surfaceFlags[kSurfaceBitIndex_UseConstantLodTextureMapping])\r\n    clr = constantLodTextureLookup(s_texture);\r\n  else\r\n    clr =  TEXTURE(s_texture, v_texCoord);\r\n  return clr;\r\n}\r\n`;\nconst applyMaterialColor = `\r\n  float useMatColor = float(use_material);\r\n  vec3 rgb = mix(baseColor.rgb, mat_rgb.rgb, useMatColor * mat_rgb.a);\r\n  float a = mix(baseColor.a, mat_alpha.x, useMatColor * mat_alpha.y);\r\n  return vec4(rgb, a);\r\n`;\n// if this is a raster glyph, the sampled color has already been modified - do not modify further.\n// Mix diffuse color with texel based on texture weight.\n// Replace with diffuse RGB if RGB overridden.\n// Replace with diffuse alpha if alpha overridden.\n// Multiply texel alpha with diffuse alpha if specified.\nconst applyTextureWeight = `\r\n  bool applyTexture = !u_applyGlyphTex && isSurfaceBitSet(kSurfaceBit_HasTexture);\r\n  float textureWeight = applyTexture ? mat_texture_weight : 0.0;\r\n  vec3 rgb = mix(baseColor.rgb, g_surfaceTexel.rgb, textureWeight);\r\n  rgb = chooseVec3WithBitFlag(rgb, baseColor.rgb, surfaceFlags, kSurfaceBit_OverrideRgb);\r\n\r\n  float a = applyTexture ? baseColor.a * g_surfaceTexel.a : baseColor.a;\r\n\r\n  return vec4(rgb, a);\r\n`;\nconst decodeFragMaterialParams = `\r\nvoid decodeMaterialParams(vec4 params) {\r\n  mat_weights = unpackAndNormalize2Bytes(params.x);\r\n\r\n  vec2 texAndSpecR = unpackAndNormalize2Bytes(params.y);\r\n  mat_texture_weight = texAndSpecR.x;\r\n\r\n  vec2 specGB = unpackAndNormalize2Bytes(params.z);\r\n  mat_specular = vec4(texAndSpecR.y, specGB, params.w);\r\n}\r\n`;\nconst decodeMaterialColor = `\r\nvoid decodeMaterialColor(vec4 rgba) {\r\n  mat_rgb = vec4(rgba.rgb, float(rgba.r >= 0.0));\r\n  mat_alpha = vec2(rgba.a, float(rgba.a >= 0.0));\r\n}\r\n`;\n// defaults: (0x6699, 0xffff, 0xffff, 13.5)\nconst computeMaterialParams = `\r\n  const vec4 defaults = vec4(26265.0, 65535.0, 65535.0, 13.5);\r\n  return use_material ? g_materialParams : defaults;\r\n`;\n// The 8-bit material index is stored with the 24-bit feature index, in the high byte.\nconst readMaterialAtlas = `\r\nvoid readMaterialAtlas() {\r\n  float materialAtlasStart = u_vertParams.z * u_vertParams.w + u_numColors;\r\n  float materialIndex = g_featureAndMaterialIndex.w * 4.0 + materialAtlasStart;\r\n\r\n  vec2 tc = computeLUTCoords(materialIndex, u_vertParams.xy, g_vert_center, 1.0);\r\n  vec4 rgba = TEXTURE(u_vertLUT, tc);\r\n\r\n  tc = computeLUTCoords(materialIndex + 1.0, u_vertParams.xy, g_vert_center, 1.0);\r\n  vec4 weightsAndFlags = floor(TEXTURE(u_vertLUT, tc) * 255.0 + 0.5);\r\n\r\n  tc = computeLUTCoords(materialIndex + 2.0, u_vertParams.xy, g_vert_center, 1.0);\r\n  vec3 specularRgb = floor(TEXTURE(u_vertLUT, tc) * 255.0 + 0.5).rgb;\r\n\r\n  tc = computeLUTCoords(materialIndex + 3.0, u_vertParams.xy, g_vert_center, 1.0);\r\n  vec4 packedSpecularExponent = TEXTURE(u_vertLUT, tc);\r\n\r\n  float flags = weightsAndFlags.w;\r\n  mat_rgb = vec4(rgba.rgb, float(flags == 1.0 || flags == 3.0));\r\n  mat_alpha = vec2(rgba.a, float(flags == 2.0 || flags == 3.0));\r\n\r\n  float specularExponent = unpackFloat(packedSpecularExponent);\r\n  g_materialParams.x = weightsAndFlags.y + weightsAndFlags.z * 256.0;\r\n  g_materialParams.y = 255.0 + specularRgb.r * 256.0;\r\n  g_materialParams.z = specularRgb.g + specularRgb.b * 256.0;\r\n  g_materialParams.w = specularExponent;\r\n}\r\n`;\nconst computeMaterial = `\r\n  if (u_surfaceFlags[kSurfaceBitIndex_HasMaterialAtlas]) {\r\n    readMaterialAtlas();\r\n  } else {\r\n    decodeMaterialColor(u_materialColor);\r\n    g_materialParams = u_materialParams;\r\n  }\r\n`;\nconst computeMaterialInstanced = `\r\n  decodeMaterialColor(u_materialColor);\r\n  g_materialParams = u_materialParams;\r\n`;\nfunction addMaterial(builder, instanced) {\n    const frag = builder.frag;\n    assert(undefined !== frag.find(\"v_surfaceFlags\"));\n    frag.addGlobal(\"mat_texture_weight\", 2 /* VariableType.Float */);\n    frag.addGlobal(\"mat_weights\", 3 /* VariableType.Vec2 */); // diffuse, specular\n    frag.addGlobal(\"mat_specular\", 5 /* VariableType.Vec4 */); // rgb, exponent\n    addUnpackAndNormalize2Bytes(frag);\n    frag.addFunction(decodeFragMaterialParams);\n    frag.addInitializer(\"decodeMaterialParams(v_materialParams);\");\n    addChooseVec3WithBitFlagFunction(frag);\n    frag.set(2 /* FragmentShaderComponent.ApplyMaterialOverrides */, applyTextureWeight);\n    const vert = builder.vert;\n    vert.addGlobal(\"mat_rgb\", 5 /* VariableType.Vec4 */); // a = 0 if not overridden, else 1\n    vert.addGlobal(\"mat_alpha\", 3 /* VariableType.Vec2 */); // a = 0 if not overridden, else 1\n    vert.addGlobal(\"use_material\", 0 /* VariableType.Boolean */);\n    vert.addInitializer(\"use_material = (0u == (surfaceFlags & kSurfaceBit_IgnoreMaterial));\");\n    // Uniform material\n    vert.addFunction(decodeMaterialColor);\n    vert.addUniform(\"u_materialColor\", 5 /* VariableType.Vec4 */, (prog) => {\n        prog.addGraphicUniform(\"u_materialColor\", (uniform, params) => {\n            const info = wantMaterials(params.target.currentViewFlags) ? params.geometry.materialInfo : undefined;\n            const mat = undefined !== info && !info.isAtlas ? info : Material.default;\n            uniform.setUniform4fv(mat.rgba);\n        });\n    });\n    vert.addUniform(\"u_materialParams\", 5 /* VariableType.Vec4 */, (prog) => {\n        prog.addGraphicUniform(\"u_materialParams\", (uniform, params) => {\n            const info = wantMaterials(params.target.currentViewFlags) ? params.geometry.materialInfo : undefined;\n            const mat = undefined !== info && !info.isAtlas ? info : Material.default;\n            uniform.setUniform4fv(mat.fragUniforms);\n        });\n    });\n    if (!instanced) {\n        // Material atlas\n        vert.addFunction(unpackFloat);\n        vert.addFunction(readMaterialAtlas);\n        vert.addUniform(\"u_numColors\", 2 /* VariableType.Float */, (prog) => {\n            prog.addGraphicUniform(\"u_numColors\", (uniform, params) => {\n                const info = params.geometry.materialInfo;\n                const numColors = undefined !== info && info.isAtlas ? info.vertexTableOffset : 0;\n                uniform.setUniform1f(numColors);\n            });\n        });\n    }\n    vert.addGlobal(\"g_materialParams\", 5 /* VariableType.Vec4 */);\n    vert.set(4 /* VertexShaderComponent.ComputeMaterial */, instanced ? computeMaterialInstanced : computeMaterial);\n    vert.set(6 /* VertexShaderComponent.ApplyMaterialColor */, applyMaterialColor);\n    builder.addFunctionComputedVarying(\"v_materialParams\", 5 /* VariableType.Vec4 */, \"computeMaterialParams\", computeMaterialParams);\n}\nconst computePositionPrelude = `\r\n  vec4 pos = MAT_MV * rawPos;\r\n`;\n// We used to use gl.polygonOffset() for blanking regions, but that doesn't work with logarithmic depth buffer which overwrites the\n// computed Z. Instead we must manually offset in vertex shader. We do this even if log depth is not enabled/supported.\n// NOTE: If log depth is *not* supported, then the hilite surface vertex shaders previously would still include this logic, but the\n// fragment shaders would not use v_eyeSpace. Some Ubuntu 20.04 graphics drivers cleverly and correctly optimized out the varying and the uniform,\n// causing an exception when gl.getProgramLocation() failed. So, omit this bit in that case.\nconst adjustEyeSpace = `\r\n  v_eyeSpace = pos.xyz;\r\n  const float blankingRegionOffset = 2.0 / 65536.0;\r\n  if (kRenderOrder_BlankingRegion == u_renderOrder)\r\n    v_eyeSpace.z -= blankingRegionOffset * (u_frustum.y - u_frustum.x);\r\n`;\nconst computeConstantLodUvCustom = `\r\n  vec2 worldpos = (u_modelToWorld * vec4(rawPos.xyz, 0.0)).xy;\r\n  v_uvCustom = vec3((u_constantLodVParams.xy + worldpos) * vec2(1.0, -1.0), kFrustumType_Perspective == u_frustum.z ? -v_eyeSpace.z : u_constantLodVParams.z);\r\n`;\nconst computePositionPostlude = `\r\n  return u_proj * pos;\r\n`;\nfunction createCommon(isInstanced, animated, shadowable, isHiliter, positionType) {\n    const instanced = 1 /* IsInstanced.Yes */ === isInstanced;\n    const attrMap = AttributeMap.findAttributeMap(0 /* TechniqueId.Surface */, instanced);\n    const builder = new ProgramBuilder(attrMap, { positionType, instanced });\n    const vert = builder.vert;\n    if (animated)\n        addAnimation(vert, true);\n    if (shadowable)\n        addSolarShadowMap(builder);\n    addProjectionMatrix(vert);\n    addModelViewMatrix(vert);\n    let computePosition = computePositionPrelude;\n    if (!isHiliter || System.instance.supportsLogZBuffer) {\n        addFrustum(builder);\n        addRenderOrder(builder.vert);\n        addRenderOrderConstants(builder.vert);\n        builder.addVarying(\"v_eyeSpace\", 4 /* VariableType.Vec3 */);\n        computePosition += adjustEyeSpace;\n    }\n    if (!isHiliter)\n        computePosition += computeConstantLodUvCustom;\n    computePosition += computePositionPostlude;\n    vert.set(10 /* VertexShaderComponent.ComputePosition */, computePosition);\n    return builder;\n}\n/** @internal */\nexport function createSurfaceHiliter(instanced, classified, posType) {\n    const builder = createCommon(instanced, 0 /* IsAnimated.No */, 0 /* IsShadowable.No */, true, posType);\n    addSurfaceFlags(builder, true, false);\n    addTexture(builder, 0 /* IsAnimated.No */, 0 /* IsThematic.No */, false, true);\n    if (classified) {\n        addHilitePlanarClassifier(builder);\n        builder.vert.addGlobal(\"feature_ignore_material\", 0 /* VariableType.Boolean */, \"false\");\n        builder.frag.set(16 /* FragmentShaderComponent.AssignFragData */, assignFragColor);\n    }\n    else {\n        addSurfaceHiliter(builder);\n    }\n    return builder;\n}\nconst isSurfaceBitSet = `\r\nbool isSurfaceBitSet(uint flag) { return 0u != (surfaceFlags & flag); }\r\n`;\n/** @internal */\nfunction addSurfaceFlagsLookup(builder) {\n    builder.addConstant(\"kSurfaceBitIndex_HasTexture\", 1 /* VariableType.Int */, 0 /* SurfaceBitIndex.HasTexture */.toString());\n    builder.addConstant(\"kSurfaceBitIndex_ApplyLighting\", 1 /* VariableType.Int */, 1 /* SurfaceBitIndex.ApplyLighting */.toString());\n    builder.addConstant(\"kSurfaceBitIndex_HasNormals\", 1 /* VariableType.Int */, 2 /* SurfaceBitIndex.HasNormals */.toString());\n    builder.addConstant(\"kSurfaceBitIndex_IgnoreMaterial\", 1 /* VariableType.Int */, 3 /* SurfaceBitIndex.IgnoreMaterial */.toString());\n    builder.addConstant(\"kSurfaceBitIndex_TransparencyThreshold\", 1 /* VariableType.Int */, 4 /* SurfaceBitIndex.TransparencyThreshold */.toString());\n    builder.addConstant(\"kSurfaceBitIndex_BackgroundFill\", 1 /* VariableType.Int */, 5 /* SurfaceBitIndex.BackgroundFill */.toString());\n    builder.addConstant(\"kSurfaceBitIndex_HasColorAndNormal\", 1 /* VariableType.Int */, 6 /* SurfaceBitIndex.HasColorAndNormal */.toString());\n    builder.addConstant(\"kSurfaceBitIndex_OverrideRgb\", 1 /* VariableType.Int */, 7 /* SurfaceBitIndex.OverrideRgb */.toString());\n    builder.addConstant(\"kSurfaceBitIndex_HasNormalMap\", 1 /* VariableType.Int */, 8 /* SurfaceBitIndex.HasNormalMap */.toString());\n    builder.addConstant(\"kSurfaceBitIndex_HasMaterialAtlas\", 1 /* VariableType.Int */, 9 /* SurfaceBitIndex.HasMaterialAtlas */.toString());\n    builder.addConstant(\"kSurfaceBitIndex_UseConstantLodTextureMapping\", 1 /* VariableType.Int */, 10 /* SurfaceBitIndex.UseConstantLodTextureMapping */.toString());\n    builder.addConstant(\"kSurfaceBitIndex_UseConstantLodNormalMapMapping\", 1 /* VariableType.Int */, 11 /* SurfaceBitIndex.UseConstantLodNormalMapMapping */.toString());\n    // Surface flags which get modified in vertex shader are still passed to fragment shader as a single float & are thus\n    // used differently there & so require different constants.  Unused constants are commented out.\n    builder.addBitFlagConstant(\"kSurfaceBit_HasTexture\", 0 /* SurfaceBitIndex.HasTexture */);\n    builder.addBitFlagConstant(\"kSurfaceBit_IgnoreMaterial\", 3 /* SurfaceBitIndex.IgnoreMaterial */);\n    builder.addBitFlagConstant(\"kSurfaceBit_OverrideRgb\", 7 /* SurfaceBitIndex.OverrideRgb */);\n    builder.addBitFlagConstant(\"kSurfaceBit_HasNormalMap\", 8 /* SurfaceBitIndex.HasNormalMap */);\n    // Only need masks for flags modified in vertex shader\n    const suffix = \"u\";\n    const type = 10 /* VariableType.Uint */;\n    builder.addConstant(\"kSurfaceMask_HasTexture\", type, 1 /* SurfaceFlags.HasTexture */.toString() + suffix);\n    builder.addConstant(\"kSurfaceMask_IgnoreMaterial\", type, 8 /* SurfaceFlags.IgnoreMaterial */.toString() + suffix);\n    builder.addConstant(\"kSurfaceMask_OverrideRgb\", type, 128 /* SurfaceFlags.OverrideRgb */.toString() + suffix);\n    builder.addConstant(\"kSurfaceMask_HasNormalMap\", type, 256 /* SurfaceFlags.HasNormalMap */.toString() + suffix);\n    addExtractNthBit(builder);\n    builder.addFunction(isSurfaceBitSet);\n    builder.addGlobal(\"surfaceFlags\", 10 /* VariableType.Uint */);\n}\nconst initSurfaceFlags = `\r\n  surfaceFlags = u_surfaceFlags[kSurfaceBitIndex_HasTexture] ? kSurfaceMask_HasTexture : 0u;\r\n  surfaceFlags += u_surfaceFlags[kSurfaceBitIndex_IgnoreMaterial] ? kSurfaceMask_IgnoreMaterial : 0u;\r\n  surfaceFlags += u_surfaceFlags[kSurfaceBitIndex_OverrideRgb] ? kSurfaceMask_OverrideRgb : 0u;\r\n  surfaceFlags += u_surfaceFlags[kSurfaceBitIndex_HasNormalMap] ? kSurfaceMask_HasNormalMap : 0u;\r\n`;\nconst computeBaseSurfaceFlags = `\r\n  if (feature_ignore_material) {\r\n    if (u_surfaceFlags[kSurfaceBitIndex_HasTexture])\r\n      surfaceFlags -= kSurfaceMask_HasTexture;\r\n    if (u_surfaceFlags[kSurfaceBitIndex_HasNormalMap])\r\n      surfaceFlags -= kSurfaceMask_HasNormalMap;\r\n\r\n    surfaceFlags += kSurfaceMask_IgnoreMaterial;\r\n  }\r\n`;\n// Textured surfaces (including raster glyphs) always *multiply* the sampled alpha by the alpha override.\nconst computeColorSurfaceFlags = `\r\n  if (feature_rgb.r >= 0.0)\r\n    surfaceFlags += kSurfaceMask_OverrideRgb;\r\n`;\nconst returnSurfaceFlags = \"  return float(surfaceFlags);\\n\";\nconst computeSurfaceFlags = computeBaseSurfaceFlags;\nconst computeSurfaceFlagsWithColor = computeBaseSurfaceFlags + computeColorSurfaceFlags;\n/** @internal */\nexport const octDecodeNormal = `\r\nvec3 octDecodeNormal(vec2 e) {\r\n  e = e / 255.0 * 2.0 - 1.0;\r\n  vec3 n = vec3(e.x, e.y, 1.0 - abs(e.x) - abs(e.y));\r\n  if (n.z < 0.0) {\r\n    vec2 signNotZero = vec2(n.x >= 0.0 ? 1.0 : -1.0, n.y >= 0.0 ? 1.0 : -1.0);\r\n    n.xy = (1.0 - abs(n.yx)) * signNotZero;\r\n  }\r\n\r\n  return normalize(n);\r\n}\r\n`;\nfunction getComputeNormal(quantized) {\n    const a = quantized ? \"g_vertLutData3.xy\" : \"g_vertLutData4.zw\";\n    const b = quantized ? \"g_vertLutData1.zw\" : \"g_vertLutData5.xy\";\n    return `\r\n  if (!u_surfaceFlags[kSurfaceBitIndex_HasNormals])\r\n    return vec3(0.0);\r\n\r\n  vec2 normal = (u_surfaceFlags[kSurfaceBitIndex_HasColorAndNormal]) ? ${a} : ${b};\r\n  return normalize(MAT_NORM * octDecodeNormal(normal));\r\n`;\n}\nconst finalizeNormalPrelude = `\r\n  vec3 normal = normalize(v_n) * (2.0 * float(gl_FrontFacing) - 1.0);\r\n`;\nconst finalizeNormalNormalMap = `\r\n  if (isSurfaceBitSet(kSurfaceBit_HasNormalMap)) {\r\n    // Modify the normal with the normal map texture.\r\n    // First calculate the tangent.\r\n    vec3 dp1 = dFdx(v_eyeSpace);\r\n    vec3 dp2 = dFdy(v_eyeSpace);\r\n    vec2 duv1 = dFdx(v_texCoord);\r\n    vec2 duv2 = dFdy(v_texCoord);\r\n    vec3 tangent = normalize(duv2.y * dp1 - duv1.y * dp2);\r\n    tangent = normalize (tangent - normal * dot (normal, tangent));  // re-orthogonalize with normal\r\n    bool flip = (duv1.x * duv2.y - duv2.x * duv1.y) < 0.0;\r\n    if (flip)\r\n      tangent = -tangent;\r\n    vec3 biTangent = cross (normal, tangent);\r\n    if (flip)\r\n      biTangent = -biTangent;\r\n    vec3 normM;\r\n    if (u_surfaceFlags[kSurfaceBitIndex_UseConstantLodNormalMapMapping])\r\n      normM = constantLodTextureLookup(s_normalMap).xyz;\r\n    else\r\n      normM = TEXTURE(s_normalMap, v_texCoord).xyz;\r\n    if (length (normM) > 0.0001) { // check for empty normal texture\r\n      normM = (normM - 0.5) * 2.0;\r\n      normM = normalize (normM);\r\n      normM.x *= abs(u_normalMapScale);\r\n      normM.y *= u_normalMapScale;\r\n      normM = normalize (normM);\r\n      normal = normalize (normM.x * tangent + normM.y * biTangent + normM.z * normal);\r\n    }\r\n  }\r\n`;\nconst finalizeNormalPostlude = `\r\n  return normal;\r\n`;\nfunction getComputeAnimatedNormal(quantized) {\n    return `\r\n  if (u_animNormalParams.x >= 0.0)\r\n    return normalize(MAT_NORM * computeAnimationNormal(u_animNormalParams.x, u_animNormalParams.y, u_animNormalParams.z));\r\n\r\n  ${getComputeNormal(quantized)}`;\n}\nconst applyBackgroundColor = `\r\n  return u_surfaceFlags[kSurfaceBitIndex_BackgroundFill] ? vec4(u_bgColor.rgb, baseColor.a) : baseColor;\r\n`;\nfunction getComputeTexCoord(quantized) {\n    const vertData = quantized ? \"g_vertLutData3\" : \"g_vertLutData4\";\n    return `\r\n  vec4 rgba = ${vertData};\r\n  vec2 qcoords = vec2(decodeUInt16(rgba.xy), decodeUInt16(rgba.zw));\r\n  return chooseVec2With2BitFlags(vec2(0.0), unquantize2d(qcoords, u_qTexCoordParams), surfaceFlags, kSurfaceBit_HasTexture, kSurfaceBit_HasNormalMap);\r\n`;\n}\nfunction getComputeAnimatedTexCoord(quantized) {\n    return `\r\n  if (u_animScalarQParams.x >= 0.0)\r\n    return computeAnimationParam(u_animScalarParams.x, u_animScalarParams.y, u_animScalarParams.z, u_animScalarQParams.x, u_animScalarQParams.y);\r\n\r\n  ${getComputeTexCoord(quantized)}\r\n`;\n}\nconst getSurfaceColor = `\r\nvec4 getSurfaceColor() { return v_color; }\r\n`;\n// If we have texture weight < 1.0 we must compute the element/material color first then mix with texture color\n// in ApplyMaterialOverrides(). Do the sample once, here, and store in a global variable for possible later use.\n// If a glyph texture, must mix getSurfaceColor() with texture color so texture color alpha is applied 100% and\n// surface color rgb is scaled by texture color rgb (latter is full white originally but stretched via mipmapping).\nconst computeBaseColor = `\r\n  g_surfaceTexel = sampleSurfaceTexture();\r\n  vec4 surfaceColor = getSurfaceColor();\r\n\r\n  if (!u_applyGlyphTex)\r\n    return surfaceColor;\r\n\r\n  // Compute color for raster glyph.\r\n  const vec3 white = vec3(1.0);\r\n  const vec3 epsilon = vec3(0.0001);\r\n  const vec3 almostWhite = white - epsilon;\r\n\r\n  // set to black if almost white and reverse white-on-white is on\r\n  bvec3 isAlmostWhite = greaterThan(surfaceColor.rgb, almostWhite);\r\n  surfaceColor.rgb = (u_reverseWhiteOnWhite && isAlmostWhite.r && isAlmostWhite.g && isAlmostWhite.b ? vec3(0.0, 0.0, 0.0) : surfaceColor.rgb);\r\n  return vec4(surfaceColor.rgb * g_surfaceTexel.rgb, g_surfaceTexel.a);\r\n`;\nconst surfaceFlagArray = new Int32Array(12 /* SurfaceBitIndex.Count */);\n/** @internal */\nexport function addSurfaceFlags(builder, withFeatureOverrides, withFeatureColor) {\n    addSurfaceFlagsLookup(builder.vert);\n    addSurfaceFlagsLookup(builder.frag);\n    let compute = initSurfaceFlags;\n    if (withFeatureOverrides)\n        compute += `${withFeatureColor ? computeSurfaceFlagsWithColor : computeSurfaceFlags}\\n`;\n    compute += returnSurfaceFlags;\n    builder.addFunctionComputedVarying(\"v_surfaceFlags\", 2 /* VariableType.Float */, \"computeSurfaceFlags\", compute);\n    builder.frag.addInitializer(\"surfaceFlags = uint(floor(v_surfaceFlags + 0.5));\");\n    builder.addUniformArray(\"u_surfaceFlags\", 0 /* VariableType.Boolean */, 12 /* SurfaceBitIndex.Count */, (prog) => {\n        prog.addGraphicUniform(\"u_surfaceFlags\", (uniform, params) => {\n            assert(undefined !== params.geometry.asSurface);\n            const mesh = params.geometry.asSurface;\n            mesh.computeSurfaceFlags(params.programParams, surfaceFlagArray);\n            uniform.setUniform1iv(surfaceFlagArray);\n        });\n    });\n}\nfunction addNormal(builder, animated) {\n    addNormalMatrix(builder.vert);\n    const quantized = \"quantized\" === builder.vert.positionType;\n    builder.vert.addFunction(octDecodeNormal);\n    builder.vert.addFunction(\"vec3 computeSurfaceNormal()\", getComputeNormal(quantized));\n    builder.addFunctionComputedVarying(\"v_n\", 4 /* VariableType.Vec3 */, \"computeLightingNormal\", animated ? getComputeAnimatedNormal(quantized) : \"return computeSurfaceNormal();\");\n    builder.frag.addGlobal(\"g_normal\", 4 /* VariableType.Vec3 */);\n    let finalizeNormal = finalizeNormalPrelude;\n    finalizeNormal += finalizeNormalNormalMap;\n    builder.frag.addFunction(constantLodTextureLookup);\n    builder.frag.addUniform(\"u_normalMapScale\", 2 /* VariableType.Float */, (prog) => {\n        prog.addGraphicUniform(\"u_normalMapScale\", (uniform, params) => {\n            if (undefined !== params.geometry.materialInfo && !params.geometry.materialInfo.isAtlas) {\n                const normalMapParams = params.geometry.materialInfo.textureMapping?.normalMapParams;\n                if (undefined !== normalMapParams) {\n                    let normalMapScale = 1.0;\n                    normalMapScale = normalMapParams.scale ?? 1.0;\n                    if (normalMapParams.greenUp)\n                        normalMapScale = -normalMapScale;\n                    uniform.setUniform1f(normalMapScale);\n                }\n            }\n        });\n    });\n    finalizeNormal += finalizeNormalPostlude;\n    builder.frag.set(22 /* FragmentShaderComponent.FinalizeNormal */, finalizeNormal);\n    // Set to true to colorize surfaces based on normals (in world space).\n    // You must also set checkMaxVarying to false in ProgramBuilder.buildProgram to avoid assertions, if using a non-optimized build.\n    const debugNormals = false;\n    if (debugNormals) {\n        builder.frag.set(15 /* FragmentShaderComponent.ApplyDebugColor */, \"return vec4(vec3(v_normal / 2.0 + 0.5), baseColor.a);\");\n        builder.addInlineComputedVarying(\"v_normal\", 4 /* VariableType.Vec3 */, \"v_normal = computeSurfaceNormal();\");\n    }\n}\n/** @internal */\nexport function addTexture(builder, animated, isThematic, isPointCloud, isHilite) {\n    if (isThematic) {\n        builder.addInlineComputedVarying(\"v_thematicIndex\", 2 /* VariableType.Float */, getComputeThematicIndex(builder.vert.usesInstancedGeometry, isPointCloud, true));\n    }\n    // Point clouds do not need to compute texture coordinates since the only texture they use is the thematic gradient.\n    // Surfaces now need texture coordinates even for thematic in case they have a normal map.\n    if (!isPointCloud) {\n        builder.vert.addFunction(unquantize2d);\n        addChooseVec2WithBitFlagsFunction(builder.vert);\n        const quantized = \"quantized\" === builder.vert.positionType;\n        builder.addFunctionComputedVarying(\"v_texCoord\", 3 /* VariableType.Vec2 */, \"computeTexCoord\", animated ? getComputeAnimatedTexCoord(quantized) : getComputeTexCoord(quantized));\n        builder.vert.addUniform(\"u_qTexCoordParams\", 5 /* VariableType.Vec4 */, (prog) => {\n            prog.addGraphicUniform(\"u_qTexCoordParams\", (uniform, params) => {\n                const surfGeom = params.geometry.asSurface;\n                if (surfGeom.useTexture(params.programParams) || (surfGeom.useNormalMap(params.programParams) && !isPointCloud)) {\n                    const uvQParams = surfGeom.lut.uvQParams;\n                    if (undefined !== uvQParams) {\n                        uniform.setUniform4fv(uvQParams);\n                    }\n                }\n            });\n        });\n    }\n    builder.frag.addUniform(\"s_texture\", 8 /* VariableType.Sampler2D */, (prog) => {\n        prog.addGraphicUniform(\"s_texture\", (uniform, params) => {\n            const surfGeom = params.geometry.asSurface;\n            if (params.geometry.supportsThematicDisplay && params.target.wantThematicDisplay) { // NB: if thematic display is enabled, bind the thematic texture and ignore any applied surface textures\n                params.target.uniforms.thematic.bindTexture(uniform, TextureUnit.SurfaceTexture);\n            }\n            else if (surfGeom.useTexture(params.programParams)) {\n                const texture = (params.geometry.hasAnimation && params.target.analysisTexture) ? params.target.analysisTexture : surfGeom.texture;\n                assert(undefined !== texture);\n                texture.texture.bindSampler(uniform, TextureUnit.SurfaceTexture);\n            }\n            else {\n                System.instance.ensureSamplerBound(uniform, TextureUnit.SurfaceTexture);\n            }\n        });\n    });\n    if (!isHilite && !isPointCloud) {\n        builder.frag.addUniform(\"s_normalMap\", 8 /* VariableType.Sampler2D */, (prog) => {\n            prog.addGraphicUniform(\"s_normalMap\", (uniform, params) => {\n                const surfGeom = params.geometry.asSurface;\n                if (surfGeom.useNormalMap(params.programParams)) {\n                    const normalMap = surfGeom.normalMap;\n                    assert(undefined !== normalMap);\n                    normalMap.texture.bindSampler(uniform, TextureUnit.NormalMap);\n                }\n                else {\n                    System.instance.ensureSamplerBound(uniform, TextureUnit.NormalMap);\n                }\n            });\n        });\n    }\n}\nexport const discardClassifiedByAlpha = `\r\n  if (u_no_classifier_discard)\r\n    return false;\r\n\r\n  bool hasAlpha = alpha <= s_maxAlpha;\r\n  bool isOpaquePass = (kRenderPass_OpaqueLinear <= u_renderPass && kRenderPass_OpaqueGeneral >= u_renderPass);\r\n  bool isTranslucentPass = kRenderPass_Translucent == u_renderPass;\r\n  return (isOpaquePass && hasAlpha) || (isTranslucentPass && !hasAlpha);\r\n`;\nconst discardByTextureAlpha = `\r\n  if (isSurfaceBitSet(kSurfaceBit_HasTexture)) {\r\n    float cutoff = abs(u_alphaCutoff);\r\n    if (kRenderPass_Translucent == u_renderPass)\r\n      return u_alphaCutoff > 0.0 && alpha >= cutoff;\r\n    else\r\n      return alpha < cutoff;\r\n  }\r\n\r\n  return false;\r\n`;\nfunction addTransparencyDiscard(frag) {\n    addRenderPass(frag);\n    frag.addUniform(\"u_alphaCutoff\", 2 /* VariableType.Float */, (prog) => {\n        prog.addGraphicUniform(\"u_alphaCutoff\", (uniform, params) => {\n            // This cutoff is used to discard pixels based on the alpha value sampled from the surface texture.\n            // During readPixels, or when transparency is disabled, only discard 100% opaque pixels.\n            // Otherwise, if the geometry draws in both opaque and translucent passes, use DisplayParams.minTransparency to filter pixels into appropriate pass to produce appropriate blending.\n            // Negative cutoff applies only during opaque pass; positive cutoff applies during opaque and translucent passes.\n            const pass = params.geometry.getPass(params.target);\n            const cutoff = (!Pass.rendersOpaqueAndTranslucent(pass) || params.target.isReadPixelsInProgress || !params.target.currentViewFlags.transparency) ? -1 / 255 : 241 / 255;\n            uniform.setUniform1f(cutoff);\n        });\n    });\n    frag.set(5 /* FragmentShaderComponent.DiscardByAlpha */, discardByTextureAlpha);\n}\n/** @internal */\nexport function createSurfaceBuilder(flags) {\n    const builder = createCommon(flags.isInstanced, flags.isAnimated, flags.isShadowable, false, flags.positionType);\n    addShaderFlags(builder);\n    const feat = flags.featureMode;\n    let opts = 2 /* FeatureMode.Overrides */ === feat ? 28 /* FeatureSymbologyOptions.Surface */ : 0 /* FeatureSymbologyOptions.None */;\n    if (flags.isClassified) {\n        opts &= ~16 /* FeatureSymbologyOptions.Alpha */;\n        addColorPlanarClassifier(builder, flags.isTranslucent, flags.isThematic);\n    }\n    if (flags.isThematic) {\n        addThematicDisplay(builder);\n    }\n    else {\n        builder.vert.addUniform(\"u_modelToWorld\", 7 /* VariableType.Mat4 */, (prog) => {\n            prog.addGraphicUniform(\"u_modelToWorld\", (uniform, params) => {\n                if (undefined !== params.geometry.asSurface?.mesh.constantLodVParams)\n                    params.target.uniforms.branch.bindModelToWorldTransform(uniform, params.geometry, false);\n            });\n        });\n    }\n    addFeatureSymbology(builder, feat, opts);\n    addSurfaceFlags(builder, 2 /* FeatureMode.Overrides */ === feat, true);\n    addSurfaceDiscard(builder, flags);\n    addNormal(builder, flags.isAnimated);\n    // In HiddenLine mode, we must compute the base color (plus feature overrides etc) in order to get the alpha, then replace with background color (preserving alpha for the transparency threshold test).\n    builder.frag.set(3 /* FragmentShaderComponent.FinalizeBaseColor */, applyBackgroundColor);\n    builder.frag.addUniform(\"u_bgColor\", 4 /* VariableType.Vec3 */, (prog) => {\n        prog.addProgramUniform(\"u_bgColor\", (uniform, params) => {\n            params.target.uniforms.style.bindBackgroundRgb(uniform);\n        });\n    });\n    addTexture(builder, flags.isAnimated, flags.isThematic, false, false);\n    builder.frag.addUniform(\"u_applyGlyphTex\", 0 /* VariableType.Boolean */, (prog) => {\n        prog.addGraphicUniform(\"u_applyGlyphTex\", (uniform, params) => {\n            const surfGeom = params.geometry.asSurface;\n            uniform.setUniform1i(surfGeom.useTexture(params.programParams) && surfGeom.isGlyph ? 1 : 0);\n        });\n    });\n    // Fragment and Vertex\n    addColor(builder);\n    // Fragment\n    builder.frag.addFunction(getSurfaceColor);\n    addLighting(builder);\n    addWhiteOnWhiteReversal(builder.frag);\n    if (flags.isTranslucent) {\n        addTranslucency(builder);\n    }\n    else {\n        if (0 /* FeatureMode.None */ === feat) {\n            addFragColorWithPreMultipliedAlpha(builder.frag);\n        }\n        else {\n            if (!flags.isClassified)\n                addOverrideClassifierColor(builder, flags.isThematic);\n            else\n                addFeaturePlanarClassifier(builder);\n            builder.frag.addFunction(decodeDepthRgb);\n            if (flags.isEdgeTestNeeded || flags.isClassified)\n                addPickBufferOutputs(builder.frag);\n            else\n                addAltPickBufferOutputs(builder.frag);\n        }\n    }\n    builder.addVarying(\"v_uvCustom\", 4 /* VariableType.Vec3 */);\n    builder.vert.addUniform(\"u_constantLodVParams\", 4 /* VariableType.Vec3 */, (prog) => {\n        prog.addGraphicUniform(\"u_constantLodVParams\", (uniform, params) => {\n            const vParams = params.geometry.asSurface?.mesh.constantLodVParams;\n            if (undefined !== vParams) {\n                vParams[2] = params.target.planFrustum.points[Npc.LeftTopRear].distance(params.target.planFrustum.points[Npc.RightTopRear]);\n                uniform.setUniform3fv(vParams);\n            }\n        });\n    });\n    builder.frag.addUniform(\"u_constantLodFParams\", 4 /* VariableType.Vec3 */, (prog) => {\n        prog.addGraphicUniform(\"u_constantLodFParams\", (uniform, params) => {\n            const fParams = params.geometry.asSurface?.mesh.constantLodFParams;\n            if (undefined !== fParams)\n                uniform.setUniform3fv(fParams);\n        });\n    });\n    builder.frag.addFunction(constantLodTextureLookup);\n    builder.frag.addFunction(sampleSurfaceTexture);\n    builder.frag.addGlobal(\"g_surfaceTexel\", 5 /* VariableType.Vec4 */);\n    builder.frag.set(1 /* FragmentShaderComponent.ComputeBaseColor */, (flags.isThematic === 0 /* IsThematic.No */) ? computeBaseColor : \"return getSurfaceColor();\");\n    if (flags.isClassified)\n        addClassificationTranslucencyDiscard(builder);\n    else\n        addTransparencyDiscard(builder.frag);\n    addSurfaceMonochrome(builder.frag);\n    addMaterial(builder, flags.isInstanced === 1 /* IsInstanced.Yes */);\n    if (flags.isWiremesh)\n        addWiremesh(builder);\n    return builder;\n}\nexport function addClassificationTranslucencyDiscard(builder) {\n    // For unclassified geometry, we need to render in both the translucent and opaque passes if any feature transparency overrides are applied that would change the default render pass used.\n    // Those shaders compute the transparency in the vertex shader and discard the vertex in one pass or the other.\n    // For classified geometry, the transparency comes from the classifier geometry (when using Display.ElementColor), so even if there are no feature overrides, we may need to draw in both passes.\n    // Since the transparency is not known until the fragment shader, we must perform the discard there instead.\n    addMaxAlpha(builder.frag);\n    addRenderPass(builder.frag);\n    // Do not discard transparent classified geometry if we're trying to do a pick...\n    builder.frag.addUniform(\"u_no_classifier_discard\", 0 /* VariableType.Boolean */, (prog) => {\n        prog.addProgramUniform(\"u_no_classifier_discard\", (uniform, params) => {\n            uniform.setUniform1i(params.target.isReadPixelsInProgress ? 1 : 0);\n        });\n    });\n    builder.frag.set(5 /* FragmentShaderComponent.DiscardByAlpha */, discardClassifiedByAlpha);\n}\n//# sourceMappingURL=Surface.js.map",
      "start": 1693508124723,
      "end": 1693508124851,
      "sourcemaps": null
    }
  ]
}
