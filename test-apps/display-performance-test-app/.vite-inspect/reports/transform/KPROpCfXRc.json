{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/orbitgt/lib/esm/pointcloud/render/ViewTree.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module OrbitGT\n */\nimport { AList } from \"../../system/collection/AList\";\nimport { Message } from \"../../system/runtime/Message\";\nimport { GridIndex } from \"../model/GridIndex\";\nimport { Block } from \"./Block\";\n/**\n * Class TileSpatialIndex manages a spatial index of levels, blocks and tiles in pointcloud. The index does not store data, only block and tile indexes.\n *\n * @version 1.0 November 2015\n */\n/** @internal */\nclass ViewTree {\n    /**\n     * Create a new tree.\n     * @param levels the levels.\n     * @param dataBounds the data bounds.\n     */\n    constructor(dataManager, levels, dataBounds) {\n        /* Store the parameters */\n        this._dataManager = dataManager;\n        this._levels = levels;\n        this._dataBounds = dataBounds;\n        /* Find the root blocks */\n        this._rootBlocks = this.findRootBlocks();\n    }\n    /**\n     * Find all root blocks (dropping of single-point tiles during pyramid creation can lead to missing branches).\n     * @return all root blocks.\n     */\n    findRootBlocks() {\n        /* Check some levels below the top */\n        let startLevel = (this._levels.length - 6);\n        if (startLevel < 0)\n            startLevel = 0;\n        Message.print(ViewTree.MODULE, \"Finding root blocks starting at level index \" + startLevel + \" of \" + this._levels.length);\n        /* Check the levels */\n        let rootBlocks = new AList();\n        let nextLevelIndex = new GridIndex(0, 0, 0);\n        for (let i = startLevel; i < this._levels.length - 1; i++) {\n            /* Check all blocks in the level */\n            let level = this._levels[i];\n            for (let block of level.getBlocks()) {\n                /* Non-top level? */\n                let isRoot = true;\n                if (i < this._levels.length - 2) {\n                    /* Do we have a parent block in the next level? */\n                    block.getBlockIndex().gridIndex.getNextLevelIndex(nextLevelIndex);\n                    isRoot = (this._levels[i + 1].findBlockGridIndex(nextLevelIndex) == null);\n                    if (isRoot)\n                        Message.print(ViewTree.MODULE, \"Block L\" + i + \" \" + block.getBlockIndex().gridIndex + \" is non-top root\");\n                }\n                /* Add to the list? */\n                if (isRoot)\n                    rootBlocks.add(block);\n            }\n        }\n        /* Return the roots */\n        Message.print(ViewTree.MODULE, \"Found \" + rootBlocks.size() + \" root blocks\");\n        return rootBlocks;\n    }\n    /**\n     * Get the number of levels.\n     * @return the number of levels.\n     */\n    getLevelCount() {\n        return this._levels.length;\n    }\n    /**\n     * Get a level.\n     * @param index the index of the level.\n     * @return the level.\n     */\n    getLevel(index) {\n        return this._levels[index];\n    }\n    /**\n     * Get the data bounds.\n     * @return the data bounds.\n     */\n    getDataBounds() {\n        return this._dataBounds;\n    }\n    /**\n     * Set the blocks for a level (after a data load operation).\n     * @param level the level.\n     * @param blockIndexes the indexes of the blocks in the level.\n     */\n    setLevelBlocks(level, blockIndexes) {\n        if (blockIndexes == null)\n            return;\n        let blockList = new Array(blockIndexes.length);\n        for (let i = 0; i < blockIndexes.length; i++)\n            blockList[i] = new Block(blockIndexes[i]);\n        level.setBlockList(blockList);\n        Message.print(ViewTree.MODULE, \"Loaded \" + blockIndexes.length + \" blocks for level \" + level.getIndex());\n    }\n    /**\n     * Set the tiles for a block (after a data load operation).\n     * @param blockIndex the index of the block.\n     * @param tileIndexes the indexes of the tiles in the block.\n     */\n    setBlockTiles(blockIndex, tileIndexes) {\n        let level = this._levels[blockIndex.level];\n        let block = level.findBlock(blockIndex);\n        block.setTiles(tileIndexes);\n    }\n    /**\n     * Split a tile into lower-level tiles.\n     * @param level the level of the tile to split.\n     * @param tile the tile to split.\n     * @param childLevel the lower level of the tile.\n     * @param children the list of children to split into.\n     * @param levelsToLoad the list of levels to load.\n     * @param blocksToLoad the list of blocks to load.\n     * @return true if the list of children is complete.\n     */\n    splitTile(level, tile, childLevel, children, levelsToLoad, blocksToLoad) {\n        /* Clear the result */\n        children.clear();\n        /* Already calculated? */\n        let childList = tile.children;\n        if (childList != null) {\n            /* Return */\n            for (let child of childList)\n                children.add(child);\n            return true;\n        }\n        /* Assume we have a complete list of children */\n        let complete = true;\n        /* Unloaded level? */\n        if (childLevel.getBlockCount() == 0) {\n            /* No need to continue, we need the level block list */\n            if (levelsToLoad.contains(childLevel) == false)\n                levelsToLoad.add(childLevel);\n            return false;\n        }\n        /* Check the 8 possible child tiles */\n        let index = tile.gridIndex;\n        let childIndex = new GridIndex(0, 0, 0);\n        for (let z = 0; z < 2; z++)\n            for (let y = 0; y < 2; y++)\n                for (let x = 0; x < 2; x++) {\n                    /* Get the index of the child */\n                    childIndex.x = (2 * index.x + x);\n                    childIndex.y = (2 * index.y + y);\n                    childIndex.z = (2 * index.z + z);\n                    /* Find the block */\n                    let block = childLevel.findBlockForTile(childIndex);\n                    if (block == null) {\n                        /* This should not happen */\n                        Message.printWarning(ViewTree.MODULE, \"Unable to find tile block \" + childIndex + \" in child level \" + childLevel.getIndex() + \" (\" + childLevel.getBlockCount() + \" blocks)\");\n                        complete = false;\n                        continue;\n                    }\n                    /* No tile info in the block? */\n                    if (block.hasTiles() == false) {\n                        /* Load the block data */\n                        if (blocksToLoad.contains(block.getBlockIndex()) == false)\n                            blocksToLoad.add(block.getBlockIndex());\n                        complete = false;\n                    }\n                    else {\n                        /* Find the child */\n                        let child = block.findTile(childIndex);\n                        if (child != null)\n                            children.add(child);\n                    }\n                }\n        /* Store the result if complete */\n        if (complete) {\n            /* Store */\n            let tileChildren = new Array(children.size());\n            for (let i = 0; i < tileChildren.length; i++)\n                tileChildren[i] = children.get(i);\n            tile.children = tileChildren;\n        }\n        /* Do we have all children? */\n        return complete;\n    }\n    /**\n     * Is all tile data available for rendering?\n     * @param viewRequest the view request.\n     * @param tiles a list of tiles to check.\n     * @param missingTiles the list of tiles whose data is missing.\n     */\n    checkDataAvailable(viewRequest, tiles, missingTiles) {\n        /* Check all tiles */\n        missingTiles.clear();\n        for (let i = 0; i < tiles.size(); i++) {\n            /* Get the next tile */\n            let tile = tiles.get(i);\n            /* Not available? */\n            if (this._dataManager.isTileLoaded(tile) == null) {\n                /* Request to load the block */\n                missingTiles.add(tile);\n            }\n            else {\n                /* Touch the block */\n                tile.accessTime = viewRequest.getFrameTime();\n            }\n        }\n    }\n    /**\n     * Is all tile data available for rendering?\n     * @param viewRequest the view request.\n     * @param tiles a list of tiles to check.\n     * @return true if the tile data is available.\n     */\n    isDataAvailable(viewRequest, tiles) {\n        /* Check all tiles */\n        for (let i = 0; i < tiles.length; i++) {\n            /* Get the next tile */\n            let tile = tiles[i];\n            /* Not available? */\n            if (this._dataManager.isTileLoaded(tile) == null)\n                return false;\n        }\n        /* Available */\n        return true;\n    }\n    /**\n     * Add visible tiles to the view.\n     * @param viewRequest the view request.\n     * @param level the level of the tiles.\n     * @param tiles the tiles to check.\n     * @param visibleTiles the list of visible tiles to add to.\n     */\n    addTilesToView(viewRequest, level, tiles, levelsToLoad, blocksToLoad, tilesToLoad, tilesToRender) {\n        /* No tiles? */\n        if (tiles == null)\n            return;\n        /* Make the lists */\n        let childTiles = new AList();\n        let missingChildTiles = new AList();\n        /* Check all tiles */\n        for (let i = 0; i < tiles.length; i++) {\n            /* Get the next tile */\n            let tile = tiles[i];\n            if (ViewTree.DEBUG)\n                Message.print(ViewTree.MODULE, \"Checking tile L\" + tile.level + \" (\" + tile.gridIndex.x + \",\" + tile.gridIndex.y + \",\" + tile.gridIndex.z + \")\");\n            /* Visible? */\n            let tileBounds = level.getTileGrid().getCellBounds(tile.gridIndex).getIntersection(this._dataBounds);\n            if (ViewTree.DEBUG)\n                Message.print(ViewTree.MODULE, \"> level \" + tile.level);\n            if (viewRequest.isVisibleBox(tileBounds)) {\n                /* Has the tile been loaded? */\n                let tileData = this._dataManager.isTileLoaded(tile);\n                let tileAvailable = (tileData != null);\n                tile.accessTime = viewRequest.getFrameTime();\n                if (ViewTree.DEBUG)\n                    Message.print(ViewTree.MODULE, \" > available? \" + tileAvailable);\n                /* We load all intermediate tiles to avoid holes in the coverage */\n                if (tileAvailable == false)\n                    tilesToLoad.add(tile);\n                /* Split the tile? */\n                let shouldSplit = (level.getIndex() > 0) && viewRequest.shouldSplit(level, tile);\n                if (shouldSplit) {\n                    if (ViewTree.DEBUG)\n                        Message.print(ViewTree.MODULE, \" > visible, but needs splitting\");\n                    /* Find the children at the lower level */\n                    let childLevel = this._levels[level.getIndex() - 1];\n                    let completeChildList = this.splitTile(level, tile, childLevel, childTiles, levelsToLoad, blocksToLoad);\n                    if (completeChildList == false) {\n                        if (ViewTree.DEBUG)\n                            Message.print(ViewTree.MODULE, \" > loading child indexes\");\n                        /* Display the tile while we wait for the block-tiles to load */\n                        if (tileAvailable)\n                            tilesToRender.add(tileData);\n                    }\n                    else {\n                        /* Are all children available with their data? */\n                        this.checkDataAvailable(viewRequest, childTiles, missingChildTiles);\n                        if (missingChildTiles.size() == 0) {\n                            if (ViewTree.DEBUG)\n                                Message.print(ViewTree.MODULE, \" > rendering children\");\n                            /* Add the children */\n                            let childTiles2 = new Array(childTiles.size());\n                            for (let j = 0; j < childTiles2.length; j++)\n                                childTiles2[j] = childTiles.get(j);\n                            this.addTilesToView(viewRequest, childLevel, childTiles2, levelsToLoad, blocksToLoad, tilesToLoad, tilesToRender);\n                        }\n                        else {\n                            if (ViewTree.DEBUG)\n                                Message.print(ViewTree.MODULE, \" > loading children\");\n                            /* Request for the missing children to be loaded */\n                            for (let j = 0; j < missingChildTiles.size(); j++)\n                                tilesToLoad.add(missingChildTiles.get(j));\n                            /* Display the tile while we wait for the child tiles to load */\n                            if (tileAvailable)\n                                tilesToRender.add(tileData);\n                        }\n                    }\n                }\n                else {\n                    /* Display the tile */\n                    if (ViewTree.DEBUG)\n                        Message.print(ViewTree.MODULE, \" > visible\");\n                    if (tileAvailable)\n                        tilesToRender.add(tileData);\n                }\n            }\n            else {\n                /* Log */\n                if (ViewTree.DEBUG)\n                    Message.print(ViewTree.MODULE, \" > not visible\");\n            }\n        }\n    }\n    /**\n     * Find tile indexes for a 3D view.\n     * @param viewRequest the request parameters.\n     * @param visibleTiles the list of visible tiles to add to.\n     * @param availableTiles the set of available tiles.\n     * @param visibleAvailableTiles the list if visible and available tiles to add to.\n     */\n    renderView3D(viewRequest, levelsToLoad, blocksToLoad, tilesToLoad, tilesToRender) {\n        /* Log? */\n        if (ViewTree.DEBUG)\n            Message.print(ViewTree.MODULE, \"Finding pointcloud tiles to render\");\n        if (ViewTree.DEBUG)\n            Message.print(ViewTree.MODULE, \" > dataBounds: \" + this._dataBounds);\n        //if (DEBUG) Message.print(MODULE,\" > view: \"+viewRequest.getViewProjection());\n        //if (DEBUG) Message.print(MODULE,\" > distance: \"+viewRequest.getDistanceRange());\n        //if (DEBUG) Message.print(MODULE,\" > model-transform: \"+viewRequest.getModelTransform());\n        /* Check all blocks */\n        tilesToRender.clear();\n        if (ViewTree.DEBUG)\n            Message.print(ViewTree.MODULE, \"Checking \" + this._rootBlocks.size() + \" root blocks\");\n        for (let i = 0; i < this._rootBlocks.size(); i++) // start from the root tiles\n         {\n            /* Visible? */\n            let block = this._rootBlocks.get(i);\n            let blockIndex = block.getBlockIndex();\n            let level = this._levels[blockIndex.level];\n            /* Visible? */\n            if (ViewTree.DEBUG)\n                Message.print(ViewTree.MODULE, \"Checking top-level block L\" + blockIndex.level + \" (\" + blockIndex.gridIndex.x + \",\" + blockIndex.gridIndex.y + \",\" + blockIndex.gridIndex.z + \")\");\n            let blockBounds = block.getBlockBounds(level).getIntersection(this._dataBounds);\n            if (ViewTree.DEBUG)\n                Message.print(ViewTree.MODULE, \" > blockBounds: \" + blockBounds);\n            if (viewRequest.isVisibleBox(blockBounds)) {\n                /* Add the tiles */\n                if (ViewTree.DEBUG)\n                    Message.print(ViewTree.MODULE, \" > visible\");\n                this.addTilesToView(viewRequest, level, block.getTiles(blocksToLoad), levelsToLoad, blocksToLoad, tilesToLoad, tilesToRender);\n            }\n        }\n    }\n}\n/** The name of this module */\nViewTree.MODULE = \"ViewTree\";\n/** Debug mode? */\nViewTree.DEBUG = false;\nexport { ViewTree };\n//# sourceMappingURL=ViewTree.js.map",
      "start": 1693508124795,
      "end": 1693508124920,
      "sourcemaps": null
    }
  ]
}
