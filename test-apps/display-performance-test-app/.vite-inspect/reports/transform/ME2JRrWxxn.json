{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/common/lib/esm/DisplayStyleSettings.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module DisplayStyles\n */\n// cspell:ignore greyscale ovrs\nimport { assert, BeEvent, CompressedId64Set, Id64, JsonUtils, MutableCompressedId64Set, OrderedId64Iterable, } from \"@itwin/core-bentley\";\nimport { AmbientOcclusion } from \"./AmbientOcclusion\";\nimport { AnalysisStyle } from \"./AnalysisStyle\";\nimport { BackgroundMapSettings } from \"./BackgroundMapSettings\";\nimport { ClipStyle } from \"./ClipStyle\";\nimport { ColorDef } from \"./ColorDef\";\nimport { HiddenLine } from \"./HiddenLine\";\nimport { FeatureAppearance } from \"./FeatureSymbology\";\nimport { PlanarClipMaskSettings } from \"./PlanarClipMask\";\nimport { SubCategoryOverride } from \"./SubCategoryOverride\";\nimport { LightSettings } from \"./LightSettings\";\nimport { MapImagerySettings } from \"./MapImagerySettings\";\nimport { PlanProjectionSettings } from \"./PlanProjectionSettings\";\nimport { Environment } from \"./Environment\";\nimport { SolarShadowSettings } from \"./SolarShadows\";\nimport { ThematicDisplay, ThematicDisplayMode } from \"./ThematicDisplay\";\nimport { ViewFlags } from \"./ViewFlags\";\nimport { Cartographic } from \"./geometry/Cartographic\";\nimport { IModel } from \"./IModel\";\nimport { calculateSolarDirection } from \"./SolarCalculate\";\nimport { ContextRealityModels } from \"./ContextRealityModel\";\nimport { RealityModelDisplaySettings } from \"./RealityModelDisplaySettings\";\nimport { WhiteOnWhiteReversalSettings } from \"./WhiteOnWhiteReversalSettings\";\n/** Describes the style in which monochrome color is applied by a [[DisplayStyleSettings]].\n * @public\n * @extensions\n */\nexport var MonochromeMode;\n(function (MonochromeMode) {\n    /** The color of the geometry is replaced with the monochrome color. e.g., if monochrome color is white, the geometry will be white. */\n    MonochromeMode[MonochromeMode[\"Flat\"] = 0] = \"Flat\";\n    /** The color of surfaces is computed as normal, then scaled to a shade of the monochrome color based on the surface color's intensity.\n     * For example, if the monochrome color is white, this results in a greyscale effect.\n     * Geometry other than surfaces is treated the same as [[MonochromeMode.Flat]].\n     */\n    MonochromeMode[MonochromeMode[\"Scaled\"] = 1] = \"Scaled\";\n})(MonochromeMode || (MonochromeMode = {}));\n/** DisplayStyleSettings initially persisted its excluded elements as an array of Id64Strings in JSON, and exposed them as a Set<string>.\n * This becomes problematic when these arrays become very large, in terms of the amount of data and the time required to convert them to a Set.\n * The Ids are now persisted to JSON as a [[CompressedId64Set]], significantly reducing their size. However, for backwards API compatibility we must\n * continue to expose [[DisplayStyleSettings.excludedElements]] as a Set<string>. The [[ExcludedElements]] class tries to minimize the impact of that requirement by\n * maintaining the Ids primarily as a [[MutableCompressedId64Set]], only allocating the Set<string> if a caller actually requests it.\n * The only operation Set provides more efficiently than MutableCompressedId64Set is checking for the presence of an Id (the `has()` method).\n * @internal\n */\nclass ExcludedElements {\n    constructor(json) {\n        this._synchronizing = false;\n        this._json = json;\n        if (Array.isArray(json.excludedElements))\n            this._ids = new MutableCompressedId64Set(CompressedId64Set.compressIds(OrderedId64Iterable.sortArray(json.excludedElements)));\n        else\n            this._ids = new MutableCompressedId64Set(json.excludedElements);\n    }\n    reset(ids) {\n        this.synchronize(() => {\n            this._ids.reset((ids && \"string\" !== typeof ids) ? CompressedId64Set.compressIds(ids) : ids);\n        });\n    }\n    get ids() {\n        return this._ids.ids;\n    }\n    add(ids) {\n        this.synchronize(() => {\n            for (const id of ids)\n                this._ids.add(id);\n        });\n    }\n    delete(ids) {\n        this.synchronize(() => {\n            for (const id of ids)\n                this._ids.delete(id);\n        });\n    }\n    [Symbol.iterator]() {\n        return this._ids[Symbol.iterator]();\n    }\n    /** The JSON must be kept up-to-date at all times. */\n    synchronize(func) {\n        if (this._synchronizing)\n            return;\n        this._synchronizing = true;\n        try {\n            func();\n        }\n        finally {\n            this._synchronizing = false;\n            const ids = this._ids.ids;\n            if (0 === ids.length)\n                delete this._json.excludedElements;\n            else\n                this._json.excludedElements = ids;\n        }\n    }\n}\n/** An implementation of Map that is based on a JSON array, used for a display styles subcategory overrides, model appearance overrides,\n * and planar clip masks. Ensures:\n *  - JSON representation kept in sync with changes to map; and\n *  - Events dispatched when map contents change.\n */\nclass OverridesMap extends Map {\n    // This is required for mock framework used by ui libraries, which otherwise try to clone this as a standard Map.\n    get [Symbol.toStringTag]() { return \"OverridesMap\"; }\n    constructor(_json, _arrayKey, _event, _idFromProps, _overrideToProps, _overrideFromProps) {\n        super();\n        this._json = _json;\n        this._arrayKey = _arrayKey;\n        this._event = _event;\n        this._idFromProps = _idFromProps;\n        this._overrideToProps = _overrideToProps;\n        this._overrideFromProps = _overrideFromProps;\n        this.populate();\n    }\n    set(id, override) {\n        this._event.raiseEvent(id, override);\n        super.set(id, override);\n        const index = this.findOrAllocateIndex(id);\n        const array = this._array;\n        assert(undefined !== array);\n        array[index] = this._overrideToProps(override, id);\n        return this;\n    }\n    delete(id) {\n        this._event.raiseEvent(id, undefined);\n        if (!super.delete(id))\n            return false;\n        const index = this.findExistingIndex(id);\n        if (undefined !== index) {\n            assert(undefined !== this._array);\n            this._array.splice(index, 1);\n        }\n        return true;\n    }\n    clear() {\n        for (const id of this.keys())\n            this.delete(id);\n        this._json[this._arrayKey] = undefined;\n    }\n    populate() {\n        super.clear();\n        const ovrs = this._array;\n        if (!ovrs)\n            return;\n        for (const props of ovrs) {\n            const id = this._idFromProps(props);\n            if (undefined !== id && Id64.isValidId64(id)) {\n                const ovr = this._overrideFromProps(props);\n                if (ovr)\n                    super.set(id, ovr);\n            }\n        }\n    }\n    get _array() {\n        return JsonUtils.asArray(this._json[this._arrayKey]);\n    }\n    findOrAllocateIndex(id) {\n        const index = this.findExistingIndex(id);\n        if (undefined !== index)\n            return index;\n        let ovrs = this._array;\n        if (!ovrs)\n            ovrs = this._json[this._arrayKey] = [];\n        return ovrs.length;\n    }\n    findExistingIndex(id) {\n        const ovrs = this._array;\n        if (!ovrs)\n            return undefined;\n        for (let i = 0; i < ovrs.length; i++)\n            if (this._idFromProps(ovrs[i]) === id)\n                return i;\n        return undefined;\n    }\n}\n/** Provides access to the settings defined by a [[DisplayStyle]] or [[DisplayStyleState]], and ensures that\n * the style's JSON properties are kept in sync.\n * @see [[DisplayStyleSettingsProps]] for the JSON representation of these settings.\n * @public\n */\nexport class DisplayStyleSettings {\n    /** Returns true if this is a [[DisplayStyle3dSettings]]. */\n    is3d() {\n        return false;\n    }\n    /** Planar clip masks to be applied to persistent reality models (@see [SpatialModelState.isRealityModel]($frontend).\n     * The key for each entry is the Id of the model to which the mask settings apply.\n     */\n    get planarClipMasks() {\n        return this._planarClipMasks;\n    }\n    /** Reality models to be displayed in the view. */\n    get contextRealityModels() {\n        return this._contextRealityModels;\n    }\n    /** Construct a new DisplayStyleSettings from an [[ElementProps.jsonProperties]].\n     * @param jsonProperties An object with an optional `styles` property containing a display style's settings.\n     * @param options Options for customizing the display style settings.\n     * @note When the `DisplayStyleSetting`'s properties are modified by public setters, the `jsonProperties`'s `styles` object will be updated to reflect the change.\n     * @note If `jsonProperties` contains no `styles` member, one will be added as an empty object.\n     * @note Generally there is no reason to create an object of this type directly; a [[DisplayStyle]] or [[DisplayStyleState]] constructs one as part of its own construction.\n     */\n    constructor(jsonProperties, options) {\n        /** Event raised by [[applyOverrides]] just before the overrides are applied. */\n        this.onApplyOverrides = new BeEvent();\n        /** Event raised by [[applyOverrides]] after the overrides are applied. */\n        this.onOverridesApplied = new BeEvent();\n        /** Event raised just prior to assignment to the [[viewFlags]] property. */\n        this.onViewFlagsChanged = new BeEvent();\n        /** Event raised just prior to assignment to the [[backgroundColor]] property. */\n        this.onBackgroundColorChanged = new BeEvent();\n        /** Event raised just prior to assignment to the [[monochromeColor]] property. */\n        this.onMonochromeColorChanged = new BeEvent();\n        /** Event raised just prior to assignment to the [[monochromeMode]] property. */\n        this.onMonochromeModeChanged = new BeEvent();\n        /** Event raised just prior to assignment to the [[backgroundMap]] property. */\n        this.onBackgroundMapChanged = new BeEvent();\n        /** Event raised just prior to assignment to the [[mapImagery]] property.\n         * @beta\n         */\n        this.onMapImageryChanged = new BeEvent();\n        /** Event raised just prior to assignment to the `scheduleScriptProps` property.\n         * @see [[onRenderTimelineChanged]] to be notified when the [[renderTimeline]] property from which a script can be obtained is changed.\n         */\n        this.onScheduleScriptPropsChanged = new BeEvent();\n        /** Event raised just prior to assignment to the [[renderTimeline]] property. */\n        this.onRenderTimelineChanged = new BeEvent();\n        /** Event raised just prior to assignment to the [[timePoint]] property. */\n        this.onTimePointChanged = new BeEvent();\n        /** Event raised just prior to assignment to the [[analysisStyle]] property. */\n        this.onAnalysisStyleChanged = new BeEvent();\n        /** Event raised just prior to assignment to the [[analysisFraction]] property. */\n        this.onAnalysisFractionChanged = new BeEvent();\n        /** Event raised when the contents of [[excludedElementIds]] changes. */\n        this.onExcludedElementsChanged = new BeEvent();\n        /** Event raised just prior to assignment to the [[clipStyle]] property. */\n        this.onClipStyleChanged = new BeEvent();\n        /** Event raised when the [[SubCategoryOverride]]s change. */\n        this.onSubCategoryOverridesChanged = new BeEvent();\n        /** Event raised just before changing the appearance override for a model. */\n        this.onModelAppearanceOverrideChanged = new BeEvent();\n        /** Event raised just before [[setRealityModelDisplaySettings]] changes the display settings for a reality model.\n         * @beta\n         */\n        this.onRealityModelDisplaySettingsChanged = new BeEvent();\n        /** Event raised just prior to assignment to the [[DisplayStyle3dSettings.thematic]] property. */\n        this.onThematicChanged = new BeEvent();\n        /** Event raised just prior to assignment to the [[DisplayStyle3dSettings.hiddenLineSettings]] property. */\n        this.onHiddenLineSettingsChanged = new BeEvent();\n        /** Event raised just prior to assignment to the [[DisplayStyle3dSettings.ambientOcclusionSettings]] property. */\n        this.onAmbientOcclusionSettingsChanged = new BeEvent();\n        /** Event raised just prior to assignment to the [[DisplayStyle3dSettings.solarShadows]] property. */\n        this.onSolarShadowsChanged = new BeEvent();\n        /** Event raised just prior to assignment to the [[DisplayStyle3dSettings.environment]] property. */\n        this.onEnvironmentChanged = new BeEvent();\n        /** Event raised just prior to assignment to the [[DisplayStyle3dSettings.lights]] property. */\n        this.onLightsChanged = new BeEvent();\n        /** Event raised just before changing the plan projection settings for a model. */\n        this.onPlanProjectionSettingsChanged = new BeEvent();\n        /** Event raised just before adding or removing an entry from [[planarClipMasks]]. */\n        this.onPlanarClipMaskChanged = new BeEvent();\n        /** Event raised just prior to assignment to the [[whiteOnWhiteReversal]] property. */\n        this.onWhiteOnWhiteReversalChanged = new BeEvent();\n        if (undefined === jsonProperties.styles)\n            jsonProperties.styles = {};\n        this._json = jsonProperties.styles;\n        this._viewFlags = ViewFlags.fromJSON(this._json.viewflags);\n        this._background = ColorDef.fromJSON(this._json.backgroundColor);\n        this._monochrome = undefined !== this._json.monochromeColor ? ColorDef.fromJSON(this._json.monochromeColor) : ColorDef.white;\n        this._monochromeMode = MonochromeMode.Flat === this._json.monochromeMode ? MonochromeMode.Flat : MonochromeMode.Scaled;\n        this._backgroundMap = BackgroundMapSettings.fromPersistentJSON(this._json.backgroundMap);\n        this._mapImagery = MapImagerySettings.createFromJSON(this._json.mapImagery, this._json.backgroundMap);\n        // Ensure that if we used the deprecated imagery properties from this._backgroundMap to set up the base layer of this._mapImagery,\n        // we update our JSON to include that base layer.\n        this._json.mapImagery = this._mapImagery.toJSON();\n        this._excludedElements = new ExcludedElements(this._json);\n        if (this._json.analysisStyle)\n            this._analysisStyle = AnalysisStyle.fromJSON(this._json.analysisStyle);\n        this._whiteOnWhiteReversal = WhiteOnWhiteReversalSettings.fromJSON(this._json.whiteOnWhiteReversal);\n        this._clipStyle = ClipStyle.fromJSON(this._json.clipStyle);\n        this._subCategoryOverrides = new OverridesMap(this._json, \"subCategoryOvr\", this.onSubCategoryOverridesChanged, (props) => props.subCategory, (ovr, subCategory) => { return { ...ovr.toJSON(), subCategory }; }, (props) => {\n            const ovr = SubCategoryOverride.fromJSON(props);\n            return ovr.anyOverridden ? ovr : undefined;\n        });\n        this._modelAppearanceOverrides = new OverridesMap(this._json, \"modelOvr\", this.onModelAppearanceOverrideChanged, (props) => props.modelId, (ovr, modelId) => { return { ...ovr.toJSON(), modelId }; }, (props) => {\n            const app = FeatureAppearance.fromJSON(props);\n            return app.anyOverridden ? app : undefined;\n        });\n        this._realityModelDisplaySettings = new OverridesMap(this._json, \"realityModelDisplay\", this.onRealityModelDisplaySettingsChanged, (props) => props.modelId, (settings, modelId) => { return { ...settings.toJSON(), modelId }; }, (props) => RealityModelDisplaySettings.fromJSON(props));\n        this._planarClipMasks = new OverridesMap(this._json, \"planarClipOvr\", this.onPlanarClipMaskChanged, (props) => props.modelId, (ovr, modelId) => { return { ...ovr.toJSON(), modelId }; }, (props) => {\n            const settings = PlanarClipMaskSettings.fromJSON(props);\n            return settings.isValid ? settings : undefined;\n        });\n        this._contextRealityModels = new ContextRealityModels({\n            container: this._json,\n            createContextRealityModel: options?.createContextRealityModel,\n            deferPopulating: options?.deferContextRealityModels,\n        });\n    }\n    /** Flags controlling various aspects of the display style. */\n    get viewFlags() { return this._viewFlags; }\n    set viewFlags(flags) {\n        if (this.viewFlags.equals(flags))\n            return;\n        this.onViewFlagsChanged.raiseEvent(flags);\n        this._viewFlags = flags;\n        this._json.viewflags = flags.toJSON();\n    }\n    /** The color displayed in the view background - by default, [[ColorDef.black]]. */\n    get backgroundColor() { return this._background; }\n    set backgroundColor(color) {\n        if (this.backgroundColor.equals(color))\n            return;\n        this.onBackgroundColorChanged.raiseEvent(color);\n        this._background = color;\n        this._json.backgroundColor = color.toJSON();\n    }\n    /** The color used to draw geometry when [[ViewFlags.monochrome]] is enabled - by default, [[ColorDef.white]].\n     * The monochrome color is applied to all surfaces and linear geometry, but only applied to the **edges** of surfaces in [[RenderMode.Wireframe]].\n     * @see [[monochromeMode]] to control how the color is applied.\n     */\n    get monochromeColor() { return this._monochrome; }\n    set monochromeColor(color) {\n        if (this.monochromeColor.equals(color))\n            return;\n        this.onMonochromeColorChanged.raiseEvent(color);\n        this._monochrome = color;\n        this._json.monochromeColor = color.toJSON();\n    }\n    /** The style in which [[monochromeColor]] is applied when [[ViewFlags.monochrome]] is enabled - by default, [[MonochromeMode.Scaled]]. */\n    get monochromeMode() { return this._monochromeMode; }\n    set monochromeMode(mode) {\n        if (this.monochromeMode === mode)\n            return;\n        this.onMonochromeModeChanged.raiseEvent(mode);\n        this._monochromeMode = mode;\n        this._json.monochromeMode = mode;\n    }\n    /** Settings controlling display of the background map within views of geolocated models. */\n    get backgroundMap() { return this._backgroundMap; }\n    set backgroundMap(map) {\n        if (!this.backgroundMap.equals(map)) {\n            this.onBackgroundMapChanged.raiseEvent(map);\n            this._backgroundMap = map; // it's an immutable type.\n            this._json.backgroundMap = map.toPersistentJSON();\n        }\n    }\n    /** Settings defining the map imagery layers to be displayed within the view.\n     * @beta\n     */\n    get mapImagery() { return this._mapImagery; }\n    set mapImagery(mapImagery) {\n        this.onMapImageryChanged.raiseEvent(mapImagery);\n        this._mapImagery = mapImagery;\n        this._json.mapImagery = this._mapImagery.toJSON();\n    }\n    /** @internal\n     * Handles keeping the map imagery layers in synch after changes have been made (used internally only by front end)\n     */\n    synchMapImagery() {\n        this.onMapImageryChanged.raiseEvent(this._mapImagery);\n        this._json.mapImagery = this._mapImagery.toJSON();\n    }\n    /** The Id of a [RenderTimeline]($backend) element containing a [[RenderSchedule.Script]] used to animate the view.\n     * If [[scheduleScriptProps]] is defined, it takes precedence over the script supplied by the RenderTimeline.\n     * @note If this [[DisplayStyleSettings]] is associated with a [DisplayStyleState]($frontend), assigning to [[renderTimeline]] will enqueue asynchronous loading of\n     * the script from the [RenderTimeline]($backend) element; for more readable code, prefer instead to `await` [DisplayStyleState.changeRenderTimeline]($frontend).\n     * @see [[onRenderTimelineChanged]] to be notified of changes to this property.\n     */\n    get renderTimeline() {\n        return this._json.renderTimeline;\n    }\n    set renderTimeline(id) {\n        if (id !== this.renderTimeline) {\n            this.onRenderTimelineChanged.raiseEvent(id);\n            this._json.renderTimeline = id;\n        }\n    }\n    /** JSON representation of a [[RenderSchedule.Script]] embedded in the display style describing how to animate the contents of the view over time.\n     * This script, if present, takes precedence over a script supplied by [[renderTimeline]].\n     * @see [[onScheduleScriptPropsChanged]] to be notified when this property changes.\n     * @see [DisplayStyleState.scheduleScript]($frontend) to change the [[RenderSchedule.Script]] object directly rather than via JSON.\n     */\n    get scheduleScriptProps() {\n        return this._json.scheduleScript;\n    }\n    set scheduleScriptProps(props) {\n        this.onScheduleScriptPropsChanged.raiseEvent(props);\n        this._json.scheduleScript = props;\n    }\n    /** The point in time currently reflected by the view, expressed in seconds in the [Unix epoch](https://en.wikipedia.org/wiki/Unix_time).\n     * This identifies a point on the timeline of the style's [[RenderSchedule.Script]], if any; it may also affect display of four-dimensional reality models.\n     * @see [[onTimePointChanged]] to be notified of changes to this property.\n     */\n    get timePoint() {\n        return this._json.timePoint;\n    }\n    set timePoint(timePoint) {\n        if (timePoint !== this.timePoint) {\n            this.onTimePointChanged.raiseEvent(timePoint);\n            this._json.timePoint = timePoint;\n        }\n    }\n    /** Settings controlling the display of analytical models.\n     * @see [[analysisFraction]] to control playback of the animation.\n     */\n    get analysisStyle() { return this._analysisStyle; }\n    set analysisStyle(style) {\n        if (style === this.analysisStyle)\n            return;\n        this.onAnalysisStyleChanged.raiseEvent(style);\n        this._analysisStyle = style;\n        if (style)\n            this._json.analysisStyle = style.toJSON();\n        else\n            delete this._json.analysisStyle;\n    }\n    /** A floating point value in [0..1] indicating the current point in animation of the [[analysisStyle]], where 0 corresponds to the beginning of\n     * the animation and 1 to the end. Default: 0.0.\n     */\n    get analysisFraction() {\n        const fraction = this._json.analysisFraction ?? 0;\n        return Math.max(0, Math.min(1, fraction));\n    }\n    set analysisFraction(fraction) {\n        if (this.analysisFraction === fraction)\n            return;\n        this.onAnalysisFractionChanged.raiseEvent(fraction);\n        this._json.analysisFraction = Math.max(0, Math.min(1, fraction));\n    }\n    /** Settings controlling how white-on-white reversal is applied when [[ViewFlags.whiteOnWhiteReversal]] is enabled. */\n    get whiteOnWhiteReversal() { return this._whiteOnWhiteReversal; }\n    set whiteOnWhiteReversal(settings) {\n        if (settings.equals(this.whiteOnWhiteReversal))\n            return;\n        this.onWhiteOnWhiteReversalChanged.raiseEvent(settings);\n        this._whiteOnWhiteReversal = settings;\n        const json = settings.toJSON();\n        if (json)\n            this._json.whiteOnWhiteReversal = json;\n        else\n            delete this._json.whiteOnWhiteReversal;\n    }\n    /** Customize the way geometry belonging to a [[SubCategory]] is drawn by this display style.\n     * @param id The Id of the SubCategory whose appearance is to be overridden.\n     * @param ovr The overrides to apply to the [[SubCategoryAppearance]].\n     * @see [[dropSubCategoryOverride]]\n     */\n    overrideSubCategory(id, ovr) {\n        this.subCategoryOverrides.set(id, ovr);\n    }\n    /** Remove any [[SubCategoryOverride]] applied to a [[SubCategoryAppearance]] by this style.\n     * @param id The Id of the [[SubCategory]].\n     * @see [[overrideSubCategory]]\n     */\n    dropSubCategoryOverride(id) {\n        this.subCategoryOverrides.delete(id);\n    }\n    /** The overrides applied by this style. */\n    get subCategoryOverrides() {\n        return this._subCategoryOverrides;\n    }\n    /** Obtain the override applied to a [[SubCategoryAppearance]] by this style.\n     * @param id The Id of the [[SubCategory]].\n     * @returns The corresponding SubCategoryOverride, or undefined if the SubCategory's appearance is not overridden.\n     * @see [[overrideSubCategory]]\n     */\n    getSubCategoryOverride(id) {\n        return this.subCategoryOverrides.get(id);\n    }\n    /** Returns true if an [[SubCategoryOverride]]s are defined by this style. */\n    get hasSubCategoryOverride() {\n        return this.subCategoryOverrides.size > 0;\n    }\n    /** Customize the way a [Model]($backend)   is drawn by this display style.\n     * @param modelId The Id of the [Model]($backend)  whose appearance is to be overridden.\n     * @param ovr The overrides to apply to the [Model]($backend) .\n     * @see [[dropModelAppearanceOverride]]\n     */\n    overrideModelAppearance(modelId, ovr) {\n        this.modelAppearanceOverrides.set(modelId, ovr);\n    }\n    /** Remove any appearance overrides applied to a [Model]($backend)  by this style.\n     * @param modelId The Id of the [Model]($backend) .\n     * @param ovr The overrides to apply to the [Model]($backend) .\n     * @see [[overrideModelAppearance]]\n     */\n    dropModelAppearanceOverride(id) {\n        this.modelAppearanceOverrides.delete(id);\n    }\n    /** The overrides applied by this style. */\n    get modelAppearanceOverrides() {\n        return this._modelAppearanceOverrides;\n    }\n    /** Obtain the override applied to a [Model]($backend)  by this style.\n     * @param id The Id of the [Model]($backend).\n     * @returns The corresponding FeatureAppearance, or undefined if the Model's appearance is not overridden.\n     * @see [[overrideModelAppearance]]\n     */\n    getModelAppearanceOverride(id) {\n        return this.modelAppearanceOverrides.get(id);\n    }\n    /** Returns true if model appearance overrides are defined by this style. */\n    get hasModelAppearanceOverride() {\n        return this.modelAppearanceOverrides.size > 0;\n    }\n    /** Get any settings that override how the reality model with the specified Id is displayed.\n     * @param modelId The Id of the [Model]($backend).\n     * @returns the display settings, or `undefined` if no settings have been associated with `modelId`.\n     * @see [[setRealityModelDisplaySettings]] to change the settings.\n     * @beta\n     */\n    getRealityModelDisplaySettings(modelId) {\n        return this._realityModelDisplaySettings.get(modelId);\n    }\n    /** Change the settings that control how the reality model with the specified Id is displayed.\n     * @param modelId The Id of the [Model]($backend) to which the settings apply.\n     * @param settings The settings to apply to the model, or `undefined` to clear any previous settings for that model.\n     * @beta\n     */\n    setRealityModelDisplaySettings(modelId, settings) {\n        if (settings)\n            this._realityModelDisplaySettings.set(modelId, settings);\n        else\n            this._realityModelDisplaySettings.delete(modelId);\n    }\n    /** The set of elements that will not be drawn by this display style.\n     * @returns An iterable over the elements' Ids.\n     */\n    get excludedElementIds() {\n        return this._excludedElements;\n    }\n    /** @internal */\n    get compressedExcludedElementIds() {\n        return this._excludedElements.ids;\n    }\n    /** Add one or more elements to the set of elements not to be displayed.\n     * @param id The Ids of the element(s) to be excluded.\n     */\n    addExcludedElements(id) {\n        this._excludedElements.add(\"string\" === typeof id ? [id] : id);\n        this.onExcludedElementsChanged.raiseEvent();\n    }\n    /** Remove an element from the set of elements not to be displayed. */\n    dropExcludedElement(id) {\n        this._excludedElements.delete([id]);\n        this.onExcludedElementsChanged.raiseEvent();\n    }\n    /** Remove one or more elements from the set of elements not to be displayed.\n     * @param id The Ids of the element(s) to be removed from the set of excluded elements.\n     */\n    dropExcludedElements(id) {\n        this._excludedElements.delete(\"string\" === typeof id ? [id] : id);\n        this.onExcludedElementsChanged.raiseEvent();\n    }\n    /** Remove all elements from the set of elements not to be displayed. */\n    clearExcludedElements() {\n        this._excludedElements.reset(undefined);\n        this.onExcludedElementsChanged.raiseEvent();\n    }\n    /** The style applied to the view's [ClipVector]($core-geometry). */\n    get clipStyle() {\n        return this._clipStyle;\n    }\n    set clipStyle(style) {\n        this.onClipStyleChanged.raiseEvent(style);\n        this._clipStyle = style;\n        if (style.matchesDefaults)\n            delete this._json.clipStyle;\n        else\n            this._json.clipStyle = style.toJSON();\n    }\n    /** Convert these settings to their JSON representation. */\n    toJSON() {\n        return this._json;\n    }\n    /** Serialize a subset of these settings to JSON, such that they can be applied to another DisplayStyleSettings to selectively override those settings.\n     * @param options Specifies which settings should be serialized. By default, settings that are specific to an iModel (e.g., subcategory overrides) or iTwin (e.g., context reality models)\n     * are omitted, as are drawing aids (e.g., ACS triad and grid).\n     * @returns a JSON representation of the selected settings suitable for passing to [[applyOverrides]].\n     * @see [[applyOverrides]] to apply the overrides to another DisplayStyleSettings..\n     */\n    toOverrides(options) {\n        if (options?.includeAll) {\n            return {\n                ...this.toJSON(),\n                viewflags: this.viewFlags.toFullyDefinedJSON(),\n            };\n        }\n        const viewflags = this.viewFlags.toFullyDefinedJSON();\n        const props = {\n            viewflags,\n            backgroundColor: this.backgroundColor.toJSON(),\n            monochromeColor: this.monochromeColor.toJSON(),\n            monochromeMode: this.monochromeMode,\n            whiteOnWhiteReversal: this.whiteOnWhiteReversal.toJSON() ?? { ignoreBackgroundColor: false },\n        };\n        if (options?.includeBackgroundMap) {\n            props.backgroundMap = this.backgroundMap.toPersistentJSON();\n            props.mapImagery = this.mapImagery.toJSON();\n        }\n        else {\n            delete viewflags.backgroundMap;\n        }\n        if (!options?.includeDrawingAids) {\n            delete viewflags.acs;\n            delete viewflags.grid;\n        }\n        if (options?.includeITwinSpecific || options?.includeIModelSpecific) {\n            props.timePoint = this.timePoint;\n            if (this._json.contextRealityModels) {\n                props.contextRealityModels = this._json.contextRealityModels;\n                if (!options?.includeIModelSpecific)\n                    for (const model of this._json.contextRealityModels)\n                        delete model.classifiers;\n            }\n        }\n        if (options?.includeIModelSpecific) {\n            if (this.analysisStyle) {\n                props.analysisStyle = this.analysisStyle.toJSON();\n                props.analysisFraction = this.analysisFraction;\n            }\n            if (this.scheduleScriptProps)\n                props.scheduleScript = [...this.scheduleScriptProps];\n            if (this.renderTimeline)\n                props.renderTimeline = this.renderTimeline;\n            props.subCategoryOvr = this._json.subCategoryOvr ? [...this._json.subCategoryOvr] : [];\n            props.modelOvr = this._json.modelOvr ? [...this._json.modelOvr] : [];\n            props.excludedElements = this._excludedElements.ids;\n        }\n        return props;\n    }\n    /** Selectively override some of these settings. Any field that is explicitly defined by the input will be overridden in these settings; any fields left undefined in the input\n     * will retain their current values in these settings. The input's [[ViewFlags]] are applied individually - only those flags that are explicitly defined will be overridden.\n     * For example, the following overrides will set the render mode to \"smooth\", change the background color to white, turn shadows off, and leave all other settings intact:\n     * ```ts\n     *  {\n     *    viewflags: {\n     *      renderMode: RenderMode.SmoothShade,\n     *      shadows: false,\n     *    },\n     *    backgroundColor: ColorByName.white,\n     *  }\n     * ```\n     * @see [[toOverrides]] to produce overrides from an existing DisplayStyleSettings.\n     */\n    applyOverrides(overrides) {\n        this._applyOverrides(overrides);\n        this.onOverridesApplied.raiseEvent(overrides);\n    }\n    /** @internal */\n    _applyOverrides(overrides) {\n        this.onApplyOverrides.raiseEvent(overrides);\n        if (overrides.viewflags) {\n            this.viewFlags = ViewFlags.fromJSON({\n                ...this.viewFlags.toJSON(),\n                ...overrides.viewflags,\n            });\n        }\n        if (undefined !== overrides.backgroundColor)\n            this.backgroundColor = ColorDef.fromJSON(overrides.backgroundColor);\n        if (undefined !== overrides.monochromeColor)\n            this.monochromeColor = ColorDef.fromJSON(overrides.monochromeColor);\n        if (undefined !== overrides.monochromeMode)\n            this.monochromeMode = overrides.monochromeMode;\n        if (overrides.backgroundMap)\n            this.backgroundMap = BackgroundMapSettings.fromPersistentJSON(overrides.backgroundMap);\n        if (overrides.mapImagery)\n            this.mapImagery = MapImagerySettings.createFromJSON(overrides.mapImagery, this.backgroundMap.toPersistentJSON());\n        if (undefined !== overrides.timePoint)\n            this.timePoint = overrides.timePoint;\n        if (overrides.contextRealityModels) {\n            this.contextRealityModels.clear();\n            for (const props of overrides.contextRealityModels)\n                this.contextRealityModels.add(props);\n        }\n        if (overrides.analysisStyle)\n            this.analysisStyle = AnalysisStyle.fromJSON(overrides.analysisStyle);\n        if (overrides.whiteOnWhiteReversal)\n            this.whiteOnWhiteReversal = WhiteOnWhiteReversalSettings.fromJSON(overrides.whiteOnWhiteReversal);\n        if (undefined !== overrides.analysisFraction)\n            this.analysisFraction = overrides.analysisFraction;\n        if (overrides.scheduleScript)\n            this.scheduleScriptProps = [...overrides.scheduleScript];\n        if (overrides.renderTimeline)\n            this.renderTimeline = overrides.renderTimeline;\n        if (overrides.subCategoryOvr) {\n            this._json.subCategoryOvr = [...overrides.subCategoryOvr];\n            this._subCategoryOverrides.populate();\n        }\n        if (overrides.modelOvr) {\n            this._json.modelOvr = [...overrides.modelOvr];\n            this._modelAppearanceOverrides.populate();\n        }\n        if (overrides.realityModelDisplay) {\n            this._json.realityModelDisplay = [...overrides.realityModelDisplay];\n            this._realityModelDisplaySettings.populate();\n        }\n        if (overrides.excludedElements)\n            this._excludedElements.reset(\"string\" === typeof overrides.excludedElements ? overrides.excludedElements : [...overrides.excludedElements]);\n        this.onOverridesApplied.raiseEvent(overrides);\n    }\n}\n/** Provides access to the settings defined by a [[DisplayStyle3d]] or [[DisplayStyle3dState]], and ensures that\n * the style's JSON properties are kept in sync.\n * @public\n */\nexport class DisplayStyle3dSettings extends DisplayStyleSettings {\n    get _json3d() { return this._json; }\n    is3d() {\n        return true;\n    }\n    constructor(jsonProperties, options) {\n        super(jsonProperties, options);\n        this._thematic = ThematicDisplay.fromJSON(this._json3d.thematic);\n        this._hline = HiddenLine.Settings.fromJSON(this._json3d.hline);\n        this._ao = AmbientOcclusion.Settings.fromJSON(this._json3d.ao);\n        this._solarShadows = SolarShadowSettings.fromJSON(this._json3d.solarShadows);\n        this._environment = Environment.fromJSON(this._json3d.environment);\n        // Very long ago we used to stick MicroStation's light settings into json.sceneLights. Later we started adding the sunDir.\n        // We don't want any of MicroStation's settings. We do want to preserve the sunDir if present.\n        if (this._json3d.lights) {\n            this._lights = LightSettings.fromJSON(this._json3d.lights);\n        }\n        else {\n            const sunDir = this._json3d.sceneLights?.sunDir;\n            this._lights = LightSettings.fromJSON(sunDir ? { solar: { direction: sunDir } } : undefined);\n        }\n        this.populatePlanProjectionsFromJSON();\n    }\n    populatePlanProjectionsFromJSON() {\n        this._planProjections = undefined;\n        const projections = this._json3d.planProjections;\n        if (undefined !== projections) {\n            for (const key of Object.keys(projections)) {\n                const id = Id64.fromJSON(key);\n                if (!Id64.isValidId64(id)) {\n                    delete projections[key];\n                    continue;\n                }\n                const settings = PlanProjectionSettings.fromJSON(projections[key]);\n                if (undefined === settings) {\n                    delete projections[key];\n                    continue;\n                }\n                if (undefined === this._planProjections)\n                    this._planProjections = new Map();\n                this._planProjections.set(id, settings);\n            }\n        }\n    }\n    /** Convert these settings to their JSON representation. */\n    toJSON() {\n        return this._json3d;\n    }\n    /** See [[DisplayStyleSettings.toOverrides]]. */\n    toOverrides(options) {\n        const props = super.toOverrides(options);\n        if (options?.includeAll)\n            return props;\n        assert(undefined !== props.viewflags);\n        props.environment = this.environment.toJSON();\n        props.hline = this.hiddenLineSettings.toJSON();\n        props.ao = this.ambientOcclusionSettings.toJSON();\n        props.solarShadows = this.solarShadows.toJSON();\n        props.lights = this.lights.toJSON();\n        if (options?.includeIModelSpecific) {\n            props.thematic = this.thematic.toJSON();\n            if (this._json3d.planProjections)\n                props.planProjections = { ...this._json3d.planProjections };\n        }\n        else if (ThematicDisplayMode.InverseDistanceWeightedSensors !== this.thematic.displayMode) {\n            props.thematic = {\n                ...this.thematic.toJSON(),\n                sensorSettings: undefined,\n            };\n            if (ThematicDisplayMode.Height === props.thematic.displayMode) {\n                // DisplayStyle3dState will compute range based on project extents.\n                props.thematic.range = undefined;\n            }\n        }\n        return props;\n    }\n    /** See [[DisplayStyleSettings.applyOverrides]]. */\n    applyOverrides(overrides) {\n        super._applyOverrides(overrides);\n        if (overrides.environment)\n            this.environment = Environment.fromJSON(overrides.environment);\n        if (overrides.hline)\n            this.hiddenLineSettings = HiddenLine.Settings.fromJSON(overrides.hline);\n        if (overrides.ao)\n            this.ambientOcclusionSettings = AmbientOcclusion.Settings.fromJSON(overrides.ao);\n        if (overrides.solarShadows)\n            this.solarShadows = SolarShadowSettings.fromJSON(overrides.solarShadows);\n        if (overrides.lights)\n            this.lights = LightSettings.fromJSON(overrides.lights);\n        if (overrides.planProjections) {\n            this._json3d.planProjections = { ...overrides.planProjections };\n            this.populatePlanProjectionsFromJSON();\n        }\n        if (overrides.thematic)\n            this.thematic = ThematicDisplay.fromJSON(overrides.thematic);\n        this.onOverridesApplied.raiseEvent(overrides);\n    }\n    /** The settings that control thematic display. */\n    get thematic() { return this._thematic; }\n    set thematic(thematic) {\n        if (thematic.equals(this.thematic))\n            return;\n        this.onThematicChanged.raiseEvent(thematic);\n        this._thematic = thematic;\n        this._json3d.thematic = thematic.toJSON();\n    }\n    /** The settings that control how visible and hidden edges are displayed.  */\n    get hiddenLineSettings() { return this._hline; }\n    set hiddenLineSettings(hline) {\n        if (hline.equals(this.hiddenLineSettings))\n            return;\n        this.onHiddenLineSettingsChanged.raiseEvent(hline);\n        this._hline = hline;\n        this._json3d.hline = hline.toJSON();\n    }\n    /** The settings that control how ambient occlusion is displayed. */\n    get ambientOcclusionSettings() { return this._ao; }\n    set ambientOcclusionSettings(ao) {\n        this.onAmbientOcclusionSettingsChanged.raiseEvent(ao);\n        this._ao = ao;\n        this._json3d.ao = ao.toJSON();\n    }\n    /** The settings that control how solar shadows are displayed. */\n    get solarShadows() {\n        return this._solarShadows;\n    }\n    set solarShadows(solarShadows) {\n        if (solarShadows.equals(this.solarShadows))\n            return;\n        this.onSolarShadowsChanged.raiseEvent(solarShadows);\n        this._solarShadows = solarShadows;\n        const json = solarShadows.toJSON();\n        if (!json)\n            delete this._json3d.solarShadows;\n        else\n            this._json3d.solarShadows = json;\n    }\n    /** Controls the display of a [[SkyBox]], [[GroundPlane]], and [[Atmosphere]].\n     * @public\n     */\n    get environment() {\n        return this._environment;\n    }\n    set environment(environment) {\n        if (environment !== this.environment) {\n            this.onEnvironmentChanged.raiseEvent(environment);\n            this._environment = environment;\n            this._json3d.environment = environment.toJSON();\n        }\n    }\n    /** Toggle display of the [[environment]]'s [[SkyBox]].\n     * @param display Whether to display the skybox, or `undefined` to toggle the current display.\n     */\n    toggleSkyBox(display) {\n        display = display ?? this.environment.displaySky;\n        if (display !== this.environment.displaySky)\n            this.environment = this.environment.withDisplay({ sky: display });\n    }\n    /** Toggle display of the [[environment]]'s [[GroundPlane]].\n     * @param display Whether to display the ground plane, or `undefined` to toggle the current display.\n     */\n    toggleGroundPlane(display) {\n        display = display ?? this.environment.displayGround;\n        if (display !== this.environment.displayGround)\n            this.environment = this.environment.withDisplay({ ground: display });\n    }\n    /** Toggle display of the [[environment]]'s [[Atmosphere]].\n     * @beta\n     * @param display Whether to display the atmosphere, or `undefined` to toggle the current display.\n     */\n    toggleAtmosphere(display) {\n        display = display ?? this.environment.displayAtmosphere;\n        if (display !== this.environment.displayAtmosphere)\n            this.environment = this.environment.withDisplay({ atmosphere: display });\n    }\n    get lights() {\n        return this._lights;\n    }\n    set lights(lights) {\n        if (this.lights.equals(lights))\n            return;\n        this.onLightsChanged.raiseEvent(lights);\n        this._lights = lights;\n        this._json3d.lights = lights.toJSON();\n    }\n    /** Adjust the solar light direction based on a date and time at a geographic location.\n     * This replaces `this.lights` with a copy that records the time point and the computed direction.\n     * @param timePoint The time in UNIX milliseconds.\n     * @param location The geographic location; or an iModel, in which case the iModel's [[EcefLocation]] is used.\n     * @see [[sunTime]] to get the current sun time.\n     * @see [[clearSunTime]] to clear the time point.\n     * @note If `location` is an iModel lacking an EcefLocation, a location in Exton, Pennsylvania will be used to compute the light direction instead.\n     */\n    setSunTime(timePoint, location) {\n        let cartoCenter;\n        if (location instanceof IModel) {\n            if (location.ecefLocation)\n                cartoCenter = Cartographic.fromEcef(location.ecefLocation.origin);\n            if (!cartoCenter)\n                cartoCenter = Cartographic.fromDegrees({ longitude: -75.17035, latitude: 39.954927, height: 0.0 });\n        }\n        else {\n            cartoCenter = location;\n        }\n        const direction = calculateSolarDirection(new Date(timePoint), cartoCenter);\n        this.lights = this.lights.clone({ solar: { direction, timePoint } });\n    }\n    /** Clear the solar time point stored in `this.lights.solarLight`.\n     * @note This does not affect the solar light direction.\n     * @see [[sunTime]] to get the current sun time.\n     * @see [[setSunTime]] to set the time point and the solar light direction derived from it.\n     */\n    clearSunTime() {\n        if (this.lights.solar.timePoint === undefined)\n            return;\n        const solar = this.lights.solar.toJSON() ?? {};\n        solar.timePoint = undefined;\n        this.lights = this.lights.clone({ solar });\n    }\n    /** The time point from which the solar light direction was derived, in UNIX milliseconds.\n     * @see [[setSunTime]] to change the time point and solar direction.\n     * @see [[clearSunTime]] to reset the time point to `undefined`.\n     */\n    get sunTime() {\n        return this.lights.solar.timePoint;\n    }\n    /** Get the plan projection settings associated with the specified model, if defined. */\n    getPlanProjectionSettings(modelId) {\n        return undefined !== this._planProjections ? this._planProjections.get(modelId) : undefined;\n    }\n    /** Set or clear the plan projection settings associated with the specified model. */\n    setPlanProjectionSettings(modelId, settings) {\n        this.onPlanProjectionSettingsChanged.raiseEvent(modelId, settings);\n        if (undefined === settings) {\n            if (undefined !== this._planProjections) {\n                assert(undefined !== this._json3d.planProjections);\n                this._planProjections.delete(modelId);\n                delete this._json3d.planProjections[modelId];\n                if (0 === this._planProjections.size) {\n                    this._planProjections = undefined;\n                    delete this._json3d.planProjections;\n                }\n            }\n            return;\n        }\n        if (undefined === this._planProjections) {\n            this._planProjections = new Map();\n            this._json3d.planProjections = {};\n        }\n        this._planProjections.set(modelId, settings);\n        this._json3d.planProjections[modelId] = settings.toJSON();\n    }\n    /** An iterator over all of the defined plan projection settings. The iterator includes the Id of the model associated with each settings object. */\n    get planProjectionSettings() {\n        return undefined !== this._planProjections ? this._planProjections.entries() : undefined;\n    }\n}\n//# sourceMappingURL=DisplayStyleSettings.js.map",
      "start": 1693508120499,
      "end": 1693508120546,
      "sourcemaps": null
    }
  ]
}
