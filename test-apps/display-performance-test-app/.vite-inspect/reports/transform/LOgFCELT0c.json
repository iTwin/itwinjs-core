{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/geometry3d/Angle.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module CartesianGeometry\n */\nimport { Geometry } from \"../Geometry\";\n/**\n * An `Angle` carries the numeric value of an angle, with methods to allow (require!) callers to\n * be clear about whether their angle is degrees or radians.\n * * After the Angle object is created, the callers should not know or care whether it is stored in\n * `degrees` or `radians` because both are available if requested by caller.\n * * The various access method are named so that callers can specify whether untyped numbers passed in or\n * out are degrees or radians.\n * * Visualization can be found at https://www.itwinjs.org/sandbox/SaeedTorabi/AngleSweep\n * @public\n */\nclass Angle {\n    constructor(radians = 0, degrees) {\n        this._radians = radians;\n        this._degrees = degrees;\n    }\n    /** Return a new angle with the same content. */\n    clone() {\n        return new Angle(this._radians, this._degrees);\n    }\n    /** Freeze this instance so it is read-only */\n    freeze() {\n        return Object.freeze(this);\n    }\n    /**\n     * Return a new Angle object for angle given in degrees.\n     * @param degrees angle in degrees\n     */\n    static createDegrees(degrees) {\n        return new Angle(Angle.degreesToRadians(degrees), degrees);\n    }\n    /**\n     * Return a (new) Angle object for a value given in radians.\n     * @param radians angle in radians\n     */\n    static createRadians(radians) {\n        return new Angle(radians);\n    }\n    /**\n     * Return a new `Angle` object with the default \"small\" angle measurement specified by [[Geometry.smallAngleRadians]].\n     */\n    static createSmallAngle() {\n        return new Angle(Geometry.smallAngleRadians);\n    }\n    /**\n     * Return a (new) Angle object that is interpolated between two inputs (based on a fraction)\n     * @param angle0 first angle in radians\n     * @param fraction the interpolation fraction\n     * @param angle1 second angle in radians\n     */\n    static createInterpolate(angle0, fraction, angle1) {\n        return new Angle(Geometry.interpolate(angle0.radians, fraction, angle1.radians));\n    }\n    /**\n     * Return a (new) Angle object, with angle scaled from existing angle.\n     * @param scale scale factor to apply to angle.\n     */\n    cloneScaled(scale) {\n        return new Angle(this.radians * scale);\n    }\n    /**\n     * Set this angle to a value given in radians.\n     * @param radians angle given in radians\n     */\n    setRadians(radians) {\n        this._radians = radians;\n        this._degrees = undefined;\n    }\n    /**\n     * Set this angle to a value given in degrees.\n     * @param degrees angle given in degrees.\n     */\n    setDegrees(degrees) {\n        this._radians = Angle.degreesToRadians(degrees);\n        this._degrees = degrees;\n    }\n    /** Create an angle for a full circle. */\n    static create360() {\n        return new Angle(Math.PI * 2.0, 360.0);\n    }\n    /**\n     * Create a (strongly typed) Angle whose tangent is `numerator/denominator`, using the signs of both in\n     * determining the (otherwise ambiguous) quadrant.\n     * @param numerator numerator for tangent\n     * @param denominator denominator for tangent\n     */\n    static createAtan2(numerator, denominator) {\n        return new Angle(Math.atan2(numerator, denominator));\n    }\n    /**\n     * Copy all contents of `other` to this Angle.\n     * @param other source data\n     */\n    setFrom(other) {\n        this._radians = other._radians;\n        this._degrees = other._degrees;\n    }\n    /**\n     * Set an Angle from a JSON object\n     * * A simple number is considered as degrees.\n     * * specified `json.degrees` or `json._degrees` is degree value.\n     * * specified `son.radians` or `json._radians` is radians value.\n     * @param json object from JSON.parse. If a number, value is in *DEGREES*\n     * @param defaultValRadians if json is undefined, default value in radians.\n     */\n    setFromJSON(json, defaultValRadians) {\n        this._radians = defaultValRadians ? defaultValRadians : 0;\n        if (!json)\n            return;\n        if (typeof json === \"number\") {\n            this.setDegrees(json);\n        }\n        else if (typeof json.degrees === \"number\") {\n            this.setDegrees(json.degrees);\n        }\n        else if (typeof json._degrees === \"number\") {\n            this.setDegrees(json._degrees);\n        }\n        else if (typeof json.radians === \"number\") {\n            this.setRadians(json.radians);\n        }\n        else if (typeof json._radians === \"number\") {\n            this.setRadians(json._radians);\n        }\n    }\n    /**\n     * Create an Angle from a JSON object\n     * @param json object from JSON.parse. If a number, value is in *DEGREES*\n     * @param defaultValRadians if json is undefined, default value in radians.\n     * @return a new Angle\n     */\n    static fromJSON(json, defaultValRadians) {\n        const val = new Angle();\n        val.setFromJSON(json, defaultValRadians);\n        return val;\n    }\n    /** Convert an Angle to a JSON object as a number in degrees */\n    toJSON() {\n        return this.degrees;\n    }\n    /** Return a json object with radians keyword, e.g. `{ radians: 0.10}` */\n    toJSONRadians() {\n        return { radians: this.radians };\n    }\n    /** Return the angle measured in radians. */\n    get radians() {\n        return this._radians;\n    }\n    /** Return the angle measured in degrees. */\n    get degrees() {\n        return this._degrees !== undefined ? this._degrees : Angle.radiansToDegrees(this._radians);\n    }\n    /**\n     * Convert an angle in degrees to radians.\n     * @param degrees angle in degrees\n     */\n    static degreesToRadians(degrees) {\n        return degrees * Math.PI / 180;\n    }\n    /**\n     * Convert an angle in radians to degrees.\n     * @param degrees angle in radians\n     */\n    static radiansToDegrees(radians) {\n        if (radians < 0)\n            return -Angle.radiansToDegrees(-radians);\n        // Now radians is positive ...\n        const pi = Math.PI;\n        const factor = 180.0 / pi;\n        /* the following if statements are for round-off reasons. The problem is that no IEEE number is\n          * an exact hit for any primary multiple of pi (90, 180, etc). The following is supposed to have\n          * a better chance that if the input was computed by direct assignment from 90, 180, etc degrees\n          * it will return exactly 90,180 etc.\n          */\n        if (radians <= 0.25 * pi)\n            return factor * radians;\n        if (radians < 0.75 * pi)\n            return 90.0 + 180 * ((radians - 0.5 * pi) / pi);\n        if (radians <= 1.25 * pi)\n            return 180.0 + 180 * ((radians - pi) / pi);\n        if (radians <= 1.75 * pi)\n            return 270.0 + 180 * ((radians - 1.5 * pi) / pi);\n        // all larger radians reference from 360 degrees (2PI)\n        return 360.0 + 180 * ((radians - 2.0 * pi) / pi);\n    }\n    /** Return the cosine of this Angle object's angle */\n    cos() {\n        return Math.cos(this._radians);\n    }\n    /** Return the sine of this Angle object's angle */\n    sin() {\n        return Math.sin(this._radians);\n    }\n    /** Return the tangent of this Angle object's angle */\n    tan() {\n        return Math.tan(this._radians);\n    }\n    /** Test if a radians (absolute) value is nearly 2PI or larger! */\n    static isFullCircleRadians(radians) {\n        return Math.abs(radians) >= Geometry.fullCircleRadiansMinusSmallAngle;\n    }\n    /** Test if the radians value is a half circle */\n    static isHalfCircleRadians(radians) {\n        return Math.abs(Math.abs(radians) - Math.PI) <= Geometry.smallAngleRadians;\n    }\n    /** Test if the angle is a full circle */\n    get isFullCircle() {\n        return Angle.isFullCircleRadians(this._radians);\n    }\n    /** Test if the angle is a half circle (in either direction) */\n    get isHalfCircle() {\n        return Angle.isHalfCircleRadians(this._radians);\n    }\n    /** Adjust a radians value so it is positive in 0..360 */\n    static adjustDegrees0To360(degrees) {\n        if (degrees >= 0) {\n            const period = 360.0;\n            if (degrees < period)\n                return degrees;\n            const numPeriods = Math.floor(degrees / period);\n            return degrees - numPeriods * period;\n        }\n        else if (degrees < 0) {\n            // negative angle ...\n            const radians = Angle.adjustDegrees0To360(-degrees);\n            return 360.0 - radians;\n        }\n        // fall through for Nan (disaster) !!!\n        return 0;\n    }\n    /** Adjust a radians value so it is in -180..180 */\n    static adjustDegreesSigned180(degrees) {\n        if (Math.abs(degrees) <= 180.0)\n            return degrees;\n        if (degrees >= 0) {\n            const period = 360.0;\n            const numPeriods = 1 + Math.floor((degrees - 180.0) / period);\n            return degrees - numPeriods * period;\n        }\n        else if (degrees < 0) {\n            // negative angle ...\n            return -Angle.adjustDegreesSigned180(-degrees);\n        }\n        // fall through for NaN disaster.\n        return 0;\n    }\n    /** Adjust a radians value so it is positive in 0..2Pi */\n    static adjustRadians0To2Pi(radians) {\n        if (radians >= 0) {\n            const period = Math.PI * 2.0;\n            if (radians < period)\n                return radians;\n            const numPeriods = Math.floor(radians / period);\n            return radians - numPeriods * period;\n        }\n        else if (radians < 0) {\n            // negative angle ...\n            return Math.PI * 2.0 - Angle.adjustRadians0To2Pi(-radians);\n        }\n        // fall through for NaN disaster.\n        return 0;\n    }\n    /** Adjust a radians value so it is positive in -PI..PI */\n    static adjustRadiansMinusPiPlusPi(radians) {\n        if (Math.abs(radians) <= Math.PI)\n            return radians;\n        if (radians >= 0) {\n            const period = Math.PI * 2.0;\n            const numPeriods = 1 + Math.floor((radians - Math.PI) / period);\n            return radians - numPeriods * period;\n        }\n        else if (radians < 0) {\n            // negative angle ...\n            return -Angle.adjustRadiansMinusPiPlusPi(-radians);\n        }\n        // fall through for NaN disaster.\n        return 0;\n    }\n    /** Return a (newly allocated) Angle object with value 0 radians */\n    static zero() {\n        return new Angle(0);\n    }\n    /** Test if the angle is exactly zero. */\n    get isExactZero() {\n        return this.radians === 0;\n    }\n    /** Test if the angle is almost zero (within tolerance `Geometry.smallAngleRadians`) */\n    get isAlmostZero() {\n        return Math.abs(this.radians) < Geometry.smallAngleRadians;\n    }\n    /** Test if the angle is almost a north or south pole (within tolerance `Geometry.smallAngleRadians`) */\n    get isAlmostNorthOrSouthPole() {\n        return Angle.isHalfCircleRadians(this.radians * 2.0);\n    }\n    /** Create an angle object with degrees adjusted into 0..360. */\n    static createDegreesAdjustPositive(degrees) {\n        return Angle.createDegrees(Angle.adjustDegrees0To360(degrees));\n    }\n    /** Create an angle object with degrees adjusted into -180..180. */\n    static createDegreesAdjustSigned180(degrees) {\n        return Angle.createDegrees(Angle.adjustDegreesSigned180(degrees));\n    }\n    /**\n     * Test if two radians values are equivalent, allowing shift by full circle (i.e. by a multiple of `2*PI`)\n     * @param radiansA first radians value\n     * @param radiansB second radians value\n     * @param radianTol radian tolerance with default value of Geometry.smallAngleRadians\n     */\n    static isAlmostEqualRadiansAllowPeriodShift(radiansA, radiansB, radianTol = Geometry.smallAngleRadians) {\n        const delta = Math.abs(radiansA - radiansB);\n        if (delta <= radianTol)\n            return true;\n        const period = Math.PI * 2.0;\n        if (Math.abs(delta - period) <= radianTol)\n            return true;\n        const numPeriod = Math.round(delta / period);\n        const delta1 = delta - numPeriod * period;\n        return Math.abs(delta1) <= radianTol;\n    }\n    /**\n   * Test if this angle has magnitude no greater than that of `other`.\n   * @param other the other angle\n   */\n    isMagnitudeLessThanOrEqual(other) {\n        return Math.abs(this.radians) <= Math.abs(other.radians);\n    }\n    /**\n     * Test if this angle and other are equivalent, allowing shift by full circle (i.e., multiples of `2 * PI`).\n     * @param other the other angle\n     * @param radianTol radian tolerance with default value of Geometry.smallAngleRadians\n     */\n    isAlmostEqualAllowPeriodShift(other, radianTol = Geometry.smallAngleRadians) {\n        return Angle.isAlmostEqualRadiansAllowPeriodShift(this._radians, other._radians, radianTol);\n    }\n    /**\n     * Test if two angle (in radians)  almost equal, NOT allowing shift by full circle (i.e., multiples of `2 * PI`).\n     * @param radiansA first radians value\n     * @param radiansB second radians value\n     * @param radianTol radian tolerance with default value of Geometry.smallAngleRadians\n     */\n    static isAlmostEqualRadiansNoPeriodShift(radiansA, radiansB, radianTol = Geometry.smallAngleRadians) {\n        return Math.abs(radiansA - radiansB) < radianTol;\n    }\n    /**\n     * Test if two this angle and other are almost equal, NOT allowing shift by full circle (i.e., multiples of `2 * PI`).\n     * @param other the other angle\n     * @param radianTol radian tolerance with default value of Geometry.smallAngleRadians\n     */\n    isAlmostEqualNoPeriodShift(other, radianTol = Geometry.smallAngleRadians) {\n        return Angle.isAlmostEqualRadiansNoPeriodShift(this._radians, other._radians, radianTol);\n    }\n    /**\n     * Test if two this angle and other are almost equal, NOT allowing shift by full circle (i.e., multiples of `2 * PI`).\n     * * This function is same as isAlmostEqualRadiansNoPeriodShift. Please use isAlmostEqualRadiansNoPeriodShift.\n     * @param other the other angle\n     * @param radianTol radian tolerance with default value of Geometry.smallAngleRadians\n     */\n    isAlmostEqual(other, radianTol = Geometry.smallAngleRadians) {\n        return this.isAlmostEqualNoPeriodShift(other, radianTol);\n    }\n    /**\n     * Test if dot product values indicate non-zero length perpendicular vectors.\n     * @param dotUU dot product of vectorU with itself\n     * @param dotVV dot product of vectorV with itself\n     * @param dotUV dot product of vectorU with vectorV\n     */\n    static isPerpendicularDotSet(dotUU, dotVV, dotUV) {\n        return dotUU > Geometry.smallMetricDistanceSquared\n            && dotVV > Geometry.smallMetricDistanceSquared\n            && dotUV * dotUV <= Geometry.smallAngleRadiansSquared * dotUU * dotVV;\n    }\n    /**\n     * Return cosine, sine, and radians for the half angle of a \"cosine,sine\" pair.\n     * * This function assumes the input arguments are related to an angle between -PI and PI\n     * * This function returns an angle between -PI and PI\n     * @param rCos2A cosine value (scaled by radius) for initial angle.\n     * @param rSin2A sine value (scaled by radius) for final angle.\n     */\n    static trigValuesToHalfAngleTrigValues(rCos2A, rSin2A) {\n        const r = Geometry.hypotenuseXY(rCos2A, rSin2A);\n        if (r < Geometry.smallMetricDistance) {\n            return { c: 1.0, s: 0.0, radians: 0.0 }; // angle = 0\n        }\n        else {\n            /* If the caller really gave you sine and cosine values, r should be 1.  However,\n             * to allow scaled values -- e.g. the x and y components of any vector -- we normalize\n             * right here. This adds an extra sqrt and 2 divides to the whole process, but improves\n             * both the usefulness and robustness of the computation.\n             */\n            let cosA;\n            let sinA = 0.0;\n            const cos2A = rCos2A / r;\n            const sin2A = rSin2A / r;\n            // Original angle in NE and SE quadrants. Half angle in same quadrant\n            if (cos2A >= 0.0) {\n                /*\n                 * We know cos2A = (cosA)^2 - (sinA)^2 and 1 = (cosA)^2 + (sinA)^2\n                 * so 1 + cos2A = 2(cosA)^2 and therefore, cosA = sqrt((1+cos2A)/2)\n                 * cosine is positive in NE and SE quadrants so we use +sqrt\n                 */\n                cosA = Math.sqrt(0.5 * (1.0 + cos2A));\n                // We know sin2A = 2 sinA cosA so sinA = sin2A/(2*cosA)\n                sinA = sin2A / (2.0 * cosA);\n            }\n            else {\n                // Original angle in NW quadrant. Half angle in NE quadrant\n                if (sin2A > 0.0) {\n                    /*\n                     * We know cos2A = (cosA)^2 - (sinA)^2 and 1 = (cosA)^2 + (sinA)^2\n                     * so 1 - cos2A = 2(sinA)^2 and therefore, sinA = sqrt((1-cos2A)/2)\n                     * sine is positive in NE quadrant so we use +sqrt\n                     */\n                    sinA = Math.sqrt(0.5 * (1.0 - cos2A));\n                    // Original angle in SW quadrant. Half angle in SE quadrant\n                }\n                else {\n                    // sine is negative in SE quadrant so we use -sqrt\n                    sinA = -Math.sqrt(0.5 * (1.0 - cos2A));\n                }\n                // We know sin2A = 2 sinA cosA so cosA = sin2A/(2*sinA)\n                cosA = sin2A / (2.0 * sinA); // always positive\n            }\n            return { c: cosA, s: sinA, radians: Math.atan2(sinA, cosA) };\n        }\n    }\n    /** If value is close to -1, -0.5, 0, 0.5, 1, adjust it to the exact value. */\n    static cleanupTrigValue(value, tolerance = Geometry.smallFloatingPoint) {\n        const absValue = Math.abs(value);\n        if (absValue <= tolerance)\n            return 0;\n        let a = Math.abs(absValue - 0.5);\n        if (a <= tolerance)\n            return value < 0.0 ? -0.5 : 0.5;\n        a = Math.abs(absValue - 1.0);\n        if (a <= tolerance)\n            return value < 0.0 ? -1.0 : 1.0;\n        return value;\n    }\n    /**\n     * Return the half angle cosine, sine, and radians for given dot products between vectors. The vectors define\n     * an ellipse using x(t) = c + U cos(t) + V sin(t) so U and V are at angle t=0 degree and t=90 degree. The\n     * half angle t0 is an angle such that x(t0) is one of the ellipse semi-axis.\n     * * This construction arises e.g. in `Arc3d.toScaledMatrix3d`.\n     * * Given ellipse x(t) = c + U cos(t) + V sin(t), find t0 such that radial vector W(t0) = x(t0) - c is\n     * perpendicular to the ellipse.\n     * * Then 0 = W(t0).x'(t0) = (U cos(t0) + V sin(t0)).(V cos(t0) - U sin(t0)) = U.V cos(2t0) + 0.5 (V.V - U.U) sin(2t0)\n     * implies sin(2t0) / cos(2t0) = 2 U.V / (U.U - V.V), i.e., t0 can be computed given the three dot products on the RHS.\n     * math details can be found at docs/learning/geometry/Angle.md\n     * @param dotUU dot product of vectorU with itself\n     * @param dotVV dot product of vectorV with itself\n     * @param dotUV dot product of vectorU with vectorV\n     */\n    static dotProductsToHalfAngleTrigValues(dotUU, dotVV, dotUV, favorZero = true) {\n        const cos2t0 = dotUU - dotVV;\n        const sin2t0 = 2.0 * dotUV;\n        if (favorZero && Math.abs(sin2t0) < Geometry.smallAngleRadians * (Math.abs(dotUU) + Math.abs(dotVV)))\n            return { c: 1.0, s: 0.0, radians: 0.0 };\n        return Angle.trigValuesToHalfAngleTrigValues(cos2t0, sin2t0);\n    }\n    /**\n     * Returns the angle between two vectors, with the vectors given as xyz components\n     * * The returned angle is between 0 and PI\n     * @param ux x component of vector u\n     * @param uy y component of vector u\n     * @param uz z component of vector u\n     * @param vx x component of vector v\n     * @param vy y component of vector v\n     * @param vz z component of vector v\n     */\n    static radiansBetweenVectorsXYZ(ux, uy, uz, vx, vy, vz) {\n        const uDotV = ux * vx + uy * vy + uz * vz;\n        return Math.atan2(Geometry.crossProductMagnitude(ux, uy, uz, vx, vy, vz), uDotV);\n    }\n    /**\n     * Returns the angle between two vectors, with the vectors given as xyz components, and an up vector to resolve\n     * angle to a full 2PI range.\n     * * The returned angle is (-PI < radians <= PI) or (0 <= radians < 2 * PI)\n     * * The angle is in the plane of the U and V vectors.\n     * * The upVector determines a positive side of the plane but need not be strictly perpendicular to the plane.\n     *\n     * @param ux x component of vector u\n     * @param uy y component of vector u\n     * @param uz z component of vector u\n     * @param vx x component of vector v\n     * @param vy y component of vector v\n     * @param vz z component of vector v\n     * @param upVectorX x component of vector to positive side of plane.\n     * @param upVectorY y component of vector to positive side of plane.\n     * @param upVectorZ z component of vector to positive side of plane.\n     * @param adjustToAllPositive if true, return strictly non-negative sweep (0 <= radians < 2*PI). If false, return\n     * signed (-PI < radians <= PI)\n     */\n    static orientedRadiansBetweenVectorsXYZ(ux, uy, uz, vx, vy, vz, upVectorX, upVectorY, upVectorZ, adjustToPositive = false) {\n        const uDotV = ux * vx + uy * vy + uz * vz;\n        const wx = uy * vz - uz * vy;\n        const wy = uz * vx - ux * vz;\n        const wz = ux * vy - uy * vx;\n        const upDotW = upVectorX * wx + upVectorY * wy + upVectorZ * wz;\n        const crossMagnitude = Geometry.hypotenuseXYZ(wx, wy, wz);\n        if (upDotW < 0.0) {\n            if (adjustToPositive) {\n                // The turn is greater than 180 degrees.  Take a peculiarly oriented atan2 to get the excess-180 part as\n                // addition to PI. This gives the smoothest numerical transition passing PI.\n                return Math.PI + Math.atan2(crossMagnitude, -uDotV);\n            }\n            else {\n                return -Math.atan2(crossMagnitude, uDotV);\n            }\n        }\n        else {\n            return Math.atan2(crossMagnitude, uDotV);\n        }\n    }\n    /**\n     * Add a multiple of a full circle angle (360 degrees, 2PI) in place.\n     * @param multiple multiplier factor\n     */\n    addMultipleOf2PiInPlace(multiple) {\n        if (this._degrees !== undefined) {\n            this._degrees += multiple * 360.0;\n            this._radians = Angle.degreesToRadians(this._degrees);\n        }\n        else {\n            this._radians += multiple * Angle.pi2Radians;\n        }\n    }\n}\n/** maximal accuracy value of pi/12 (15 degrees), in radians */\nAngle.piOver12Radians = 0.26179938779914946;\n/** maximal accuracy value of pi/4 (45 degrees), in radians */\nAngle.piOver4Radians = 7.853981633974483e-001;\n/** maximal accuracy value of pi/2 (90 degrees), in radians */\nAngle.piOver2Radians = 1.5707963267948966e+000;\n/** maximal accuracy value of pi (180 degrees), in radians */\nAngle.piRadians = 3.141592653589793e+000;\n/** maximal accuracy value of 2*pi (360 degrees), in radians */\nAngle.pi2Radians = 6.283185307179586e+000;\n/** scale factor for converting radians to degrees */\nAngle.degreesPerRadian = (45.0 / Angle.piOver4Radians);\n/** scale factor for converting degrees to radians */\nAngle.radiansPerDegree = (Angle.piOver4Radians / 45.0);\nexport { Angle };\n//# sourceMappingURL=Angle.js.map",
      "start": 1693508122293,
      "end": 1693508122337,
      "sourcemaps": null
    }
  ]
}
