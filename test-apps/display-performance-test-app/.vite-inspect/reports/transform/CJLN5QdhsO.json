{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tile/map/ImageryProviders/WmtsMapLayerImageryProvider.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tiles\n */\nimport { assert } from \"@itwin/core-bentley\";\nimport { IModelStatus, ServerError } from \"@itwin/core-common\";\nimport { MapLayerImageryProvider, MapLayerImageryProviderStatus, WmsUtilities, WmtsCapabilities, WmtsConstants, } from \"../../internal\";\n/** @internal */\nexport class WmtsMapLayerImageryProvider extends MapLayerImageryProvider {\n    get mutualExclusiveSubLayer() { return true; }\n    constructor(settings) {\n        super(settings, true);\n        this._preferredLayerTileMatrixSet = new Map();\n        this._preferredLayerStyle = new Map();\n        this.displayedLayerName = \"\";\n        this._baseUrl = WmsUtilities.getBaseUrl(this._settings.url);\n    }\n    async initialize() {\n        try {\n            this._capabilities = await WmtsCapabilities.create(this._baseUrl);\n            this.initPreferredTileMatrixSet();\n            this.initPreferredStyle();\n            this.initCartoRange();\n            this.initDisplayedLayer();\n            if (this._preferredLayerTileMatrixSet.size === 0 || this._preferredLayerStyle.size === 0)\n                throw new ServerError(IModelStatus.ValidationFailed, \"\");\n        }\n        catch (error) {\n            // Don't throw error if unauthorized status:\n            // We want the tile tree to be created, so that end-user can get feedback on which layer is missing credentials.\n            // When credentials will be provided, a new provider will be created, and initialization should be fine.\n            if (error?.status === 401) {\n                this.setStatus(MapLayerImageryProviderStatus.RequireAuth);\n            }\n            else {\n                throw new ServerError(IModelStatus.ValidationFailed, \"\");\n            }\n        }\n    }\n    initDisplayedLayer() {\n        if (0 === this._settings.subLayers.length) {\n            assert(false);\n            return;\n        }\n        const firstDisplayedLayer = this._settings.subLayers.find((subLayer) => subLayer.visible);\n        this.displayedLayerName = firstDisplayedLayer ? firstDisplayedLayer.name : this._settings.subLayers[0].name;\n    }\n    // Each layer can be served in multiple tile matrix set (i.e. TileTree).\n    // We have to pick one for each layer: for now we look for a Google Maps compatible tile tree.\n    initPreferredTileMatrixSet() {\n        const googleMapsTms = this._capabilities?.contents?.getGoogleMapsCompatibleTileMatrixSet();\n        const wellGoogleKnownTms = googleMapsTms?.find((tms) => tms.wellKnownScaleSet?.toLowerCase().includes(WmtsConstants.GOOGLEMAPS_COMPATIBLE_WELLKNOWNNAME));\n        this._capabilities?.contents?.layers.forEach((layer) => {\n            let preferredTms;\n            if (wellGoogleKnownTms && layer.tileMatrixSetLinks.some((tmsl) => tmsl.tileMatrixSet === wellGoogleKnownTms.identifier)) {\n                // Favor tile matrix set that was explicitly marked as GoogleMaps compatible\n                preferredTms = wellGoogleKnownTms;\n            }\n            else {\n                // Search all compatible tile set matrix if previous attempt didn't work.\n                // If more than one candidate is found, pick the tile set with the most LODs.\n                let tileMatrixSets = googleMapsTms?.filter((tms) => {\n                    return layer.tileMatrixSetLinks.some((tmsl) => tmsl.tileMatrixSet === tms.identifier);\n                });\n                if (!tileMatrixSets || tileMatrixSets.length === 0) {\n                    const eps4326CompatibleTms = this._capabilities?.contents?.getEpsg4326CompatibleTileMatrixSet();\n                    tileMatrixSets = eps4326CompatibleTms?.filter((tms) => {\n                        return layer.tileMatrixSetLinks.some((tmsl) => tmsl.tileMatrixSet === tms.identifier);\n                    });\n                }\n                if (tileMatrixSets && tileMatrixSets.length === 1)\n                    preferredTms = tileMatrixSets[0];\n                else if (tileMatrixSets && tileMatrixSets?.length > 1)\n                    preferredTms = tileMatrixSets.reduce((prev, current) => (prev.tileMatrix.length > current.tileMatrix.length) ? prev : current);\n            }\n            if (preferredTms !== undefined) {\n                const tmsLink = layer.tileMatrixSetLinks.find((tmsl) => tmsl.tileMatrixSet === preferredTms.identifier);\n                this._preferredLayerTileMatrixSet.set(layer.identifier, { tileMatrixSet: preferredTms, limits: tmsLink?.tileMatrixSetLimits });\n            }\n        });\n    }\n    // Each layer can be published different style.  We look for a style flagged as 'Default'.\n    initPreferredStyle() {\n        this._capabilities?.contents?.layers.forEach((layer) => {\n            let preferredStyle;\n            if (layer.styles.length === 1)\n                preferredStyle = layer.styles[0];\n            else if (layer.styles.length > 1) {\n                // If more than style is available, takes the default one, otherwise the first one.\n                const defaultStyle = layer.styles.find((style) => style.isDefault);\n                if (defaultStyle)\n                    preferredStyle = defaultStyle;\n                else\n                    preferredStyle = layer.styles[0];\n            }\n            if (preferredStyle)\n                this._preferredLayerStyle.set(layer.identifier, preferredStyle);\n        });\n    }\n    initCartoRange() {\n        this._capabilities?.contents?.layers.forEach((layer) => {\n            if (layer.wsg84BoundingBox) {\n                if (this.cartoRange)\n                    this.cartoRange.extendRange(layer.wsg84BoundingBox);\n                else\n                    this.cartoRange = layer.wsg84BoundingBox.clone();\n            }\n        });\n    }\n    getDisplayedTileMatrixSetAndLimits() {\n        return this._preferredLayerTileMatrixSet.get(this.displayedLayerName);\n    }\n    _generateChildIds(tile, resolveChildren) {\n        const childIds = this.getPotentialChildIds(tile);\n        const matrixSetAndLimits = this.getDisplayedTileMatrixSetAndLimits();\n        if (!matrixSetAndLimits) {\n            assert(false); // Must always hava a matrix set.\n            return;\n        }\n        const limits = matrixSetAndLimits.limits?.[tile.quadId.level + 1]?.limits;\n        if (!limits) {\n            resolveChildren(childIds);\n            return;\n        }\n        const availableChildIds = [];\n        for (const childId of childIds)\n            if (limits.containsXY(childId.column, childId.row))\n                availableChildIds.push(childId);\n        resolveChildren(availableChildIds);\n    }\n    get useGeographicTilingScheme() {\n        const matrixSetAndLimits = this.getDisplayedTileMatrixSetAndLimits();\n        return matrixSetAndLimits ? (matrixSetAndLimits?.tileMatrixSet.identifier?.includes(\"4326\") || matrixSetAndLimits?.tileMatrixSet.supportedCrs?.includes(\"4326\")) : false;\n    }\n    async constructUrl(row, column, zoomLevel) {\n        const matrixSetAndLimits = this.getDisplayedTileMatrixSetAndLimits();\n        const style = this._preferredLayerStyle.get(this.displayedLayerName);\n        // Matrix identifier might be something other than standard 0..n zoom level,\n        // so lookup the matrix identifier just in case.\n        let tileMatrix;\n        if (matrixSetAndLimits && matrixSetAndLimits.tileMatrixSet.tileMatrix.length > zoomLevel)\n            tileMatrix = matrixSetAndLimits.tileMatrixSet.tileMatrix[zoomLevel].identifier;\n        const styleParam = (style?.identifier === undefined ? \"\" : `&style=${style.identifier}`);\n        if (tileMatrix !== undefined && matrixSetAndLimits !== undefined)\n            return `${this._baseUrl}?Service=WMTS&Version=1.0.0&Request=GetTile&Format=image%2Fpng&layer=${this.displayedLayerName}${styleParam}&TileMatrixSet=${matrixSetAndLimits.tileMatrixSet.identifier}&TileMatrix=${tileMatrix}&TileCol=${column}&TileRow=${row} `;\n        else\n            return \"\";\n    }\n}\n//# sourceMappingURL=WmtsMapLayerImageryProvider.js.map",
      "start": 1693508121821,
      "end": 1693508121915,
      "sourcemaps": null
    }
  ]
}
