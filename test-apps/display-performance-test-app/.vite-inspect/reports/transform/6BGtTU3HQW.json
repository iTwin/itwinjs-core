{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/glsl/Vertex.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { assert } from \"@itwin/core-bentley\";\nimport { Matrix4 } from \"../Matrix\";\nimport { Pass, TextureUnit } from \"../RenderFlags\";\nimport { decodeUint16, decodeUint24 } from \"./Decode\";\nimport { addInstanceOverrides } from \"./Instancing\";\nimport { addLookupTable } from \"./LookupTable\";\nconst initializeVertLUTCoords = `\r\n  g_vertexLUTIndex = decodeUInt24(qpos);\r\n  g_vertexBaseCoords = compute_vert_coords(g_vertexLUTIndex);\r\n`;\n/** @internal */\nexport const unquantizePosition = `\r\nvec4 unquantizePosition(vec3 pos, vec3 origin, vec3 scale) { return vec4(origin + scale * pos, 1.0); }\r\n`;\nconst computeQuantizedPosition = `\r\nvec4 computeVertexPosition(vec3 pos) { return unquantizePosition(pos, u_qOrigin, u_qScale); }\r\n`;\n// Need to read 2 rgba values to obtain 6 16-bit integers for position\nconst computeVertexPositionFromLUT = `\r\nvec4 computeVertexPosition(vec3 encodedIndex) {\r\n  vec3 qpos = vec3(decodeUInt16(g_vertLutData0.xy), decodeUInt16(g_vertLutData0.zw), decodeUInt16(g_vertLutData1.xy));\r\n  g_featureAndMaterialIndex = g_vertLutData2;\r\n  return unquantizePosition(qpos, u_qOrigin, u_qScale);\r\n}\r\n`;\nconst computeUnquantizedPosition = `\r\nvec4 computeVertexPosition(vec3 encodedIndex) {\r\n  uvec3 vux = uvec3(g_vertLutData0.xyz);\r\n  g_featureAndMaterialIndex.x = g_vertLutData0.w;\r\n  uvec3 vuy = uvec3(g_vertLutData1.xyz);\r\n  g_featureAndMaterialIndex.y = g_vertLutData1.w;\r\n  uvec3 vuz = uvec3(g_vertLutData2.xyz);\r\n  g_featureAndMaterialIndex.z = g_vertLutData2.w;\r\n  uvec3 vuw = uvec3(g_vertLutData3.xyz);\r\n  g_featureAndMaterialIndex.w = g_vertLutData3.w;\r\n  uvec3 u = (vuw << 24) | (vuz << 16) | (vuy << 8) | vux;\r\n  return vec4(uintBitsToFloat(u), 1.0);\r\n}\r\n`;\nconst computeLineWeight = \"\\nfloat computeLineWeight() { return g_lineWeight; }\\n\";\nconst computeLineCode = \"\\nfloat computeLineCode() { return g_lineCode; }\\n\";\nexport function addSamplePosition(vert) {\n    vert.addFunction(getSamplePosition(vert.positionType));\n}\nconst getSamplePositionPrelude = `\r\nvec4 samplePosition(float index) {\r\n  vec2 tc = compute_vert_coords(index);`;\nconst getSamplePositionQuantizedPostlude = `\r\n  vec4 e0 = floor(TEXTURE(u_vertLUT, tc) * 255.0 + 0.5);\r\n  tc.x += g_vert_stepX;\r\n  vec4 e1 = floor(TEXTURE(u_vertLUT, tc) * 255.0 + 0.5);\r\n  vec3 qpos = vec3(decodeUInt16(e0.xy), decodeUInt16(e0.zw), decodeUInt16(e1.xy));\r\n  return unquantizePosition(qpos, u_qOrigin, u_qScale);\r\n}\r\n`;\nconst getSamplePositionUnquantizedPostlude = `\r\n  uvec3 vux = uvec3(floor(TEXTURE(u_vertLUT, tc).xyz * 255.0 + 0.5));\r\n  tc.x += g_vert_stepX;\r\n  uvec3 vuy = uvec3(floor(TEXTURE(u_vertLUT, tc).xyz * 255.0 + 0.5));\r\n  tc.x += g_vert_stepX;\r\n  uvec3 vuz = uvec3(floor(TEXTURE(u_vertLUT, tc).xyz * 255.0 + 0.5));\r\n  tc.x += g_vert_stepX;\r\n  uvec3 vuw = uvec3(floor(TEXTURE(u_vertLUT, tc).xyz * 255.0 + 0.5));\r\n  uvec3 u = (vuw << 24) | (vuz << 16) | (vuy << 8) | vux;\r\n  return vec4(uintBitsToFloat(u), 1.0);\r\n}\r\n`;\nfunction getSamplePosition(type) {\n    return `${getSamplePositionPrelude}${\"quantized\" === type ? getSamplePositionQuantizedPostlude : getSamplePositionUnquantizedPostlude}`;\n}\n/** @internal */\nexport function addModelViewProjectionMatrix(vert) {\n    if (vert.usesInstancedGeometry) {\n        addModelViewMatrix(vert);\n        addProjectionMatrix(vert);\n        vert.addGlobal(\"g_mvp\", 7 /* VariableType.Mat4 */);\n        vert.addInitializer(\"g_mvp = u_proj * g_mv;\");\n    }\n    else {\n        vert.addUniform(\"u_mvp\", 7 /* VariableType.Mat4 */, (prog) => {\n            prog.addGraphicUniform(\"u_mvp\", (uniform, params) => {\n                params.target.uniforms.branch.bindModelViewProjectionMatrix(uniform, params.geometry, params.isViewCoords);\n            });\n        });\n    }\n}\n/** @internal */\nexport function addProjectionMatrix(vert) {\n    vert.addUniform(\"u_proj\", 7 /* VariableType.Mat4 */, (prog) => {\n        prog.addProgramUniform(\"u_proj\", (uniform, params) => {\n            params.bindProjectionMatrix(uniform);\n        });\n    });\n}\nconst computeInstancedRtcMatrix = `\r\n  g_instancedRtcMatrix = u_instanced_rtc * g_modelMatrixRTC;\r\n`;\n/** @internal */\nexport function addInstancedRtcMatrix(vert) {\n    if (!vert.usesInstancedGeometry)\n        return;\n    assert(undefined !== vert.find(\"g_modelMatrixRTC\")); // set up in VertexShaderBuilder constructor...\n    vert.addUniform(\"u_instanced_rtc\", 7 /* VariableType.Mat4 */, (prog) => {\n        prog.addGraphicUniform(\"u_instanced_rtc\", (uniform, params) => {\n            const modelt = params.geometry.asInstanced.getRtcOnlyTransform();\n            uniform.setMatrix4(Matrix4.fromTransform(modelt));\n        });\n    });\n    vert.addGlobal(\"g_instancedRtcMatrix\", 7 /* VariableType.Mat4 */);\n    vert.addInitializer(computeInstancedRtcMatrix);\n}\n/** @internal */\nexport function addModelViewMatrix(vert) {\n    const bind = (uniform, params) => {\n        params.target.uniforms.branch.bindModelViewMatrix(uniform, params.geometry, params.isViewCoords);\n    };\n    if (vert.usesInstancedGeometry) {\n        vert.addUniform(\"u_instanced_modelView\", 7 /* VariableType.Mat4 */, (prog) => {\n            prog.addGraphicUniform(\"u_instanced_modelView\", bind);\n        });\n        vert.addGlobal(\"g_mv\", 7 /* VariableType.Mat4 */);\n        vert.addInitializer(\"g_mv = u_instanced_modelView * g_modelMatrixRTC;\");\n    }\n    else {\n        vert.addUniform(\"u_mv\", 7 /* VariableType.Mat4 */, (prog) => {\n            // ###TODO: We only need 3 rows, not 4...\n            prog.addGraphicUniform(\"u_mv\", bind);\n        });\n    }\n}\nconst computeNormalMatrix = `\r\n  g_nmx = transpose(inverse(mat3(MAT_MV)));\r\n  g_nmx[0][0] *= u_frustumScale.x;\r\n  g_nmx[1][1] *= u_frustumScale.y;\r\n`;\n/** @internal */\nexport function addNormalMatrix(vert) {\n    vert.addGlobal(\"g_nmx\", 6 /* VariableType.Mat3 */);\n    vert.addUniform(\"u_frustumScale\", 3 /* VariableType.Vec2 */, (prog) => {\n        prog.addGraphicUniform(\"u_frustumScale\", (uniform, params) => {\n            const scale = params.target.uniforms.branch.top.frustumScale;\n            uniform.setUniform2fv([scale.x, scale.y]);\n        });\n    });\n    vert.addInitializer(computeNormalMatrix);\n}\nfunction readVertexData(index) {\n    return `g_vertLutData${index} = floor(TEXTURE(u_vertLUT, tc) * 255.0 + 0.5);`;\n}\nconst nextVertexData = \"tc.x += g_vert_stepX;\";\nfunction readNextVertexData(index) {\n    return `\r\n  ${nextVertexData}\r\n  ${readVertexData(index)}`;\n}\nconst prereadVertexDataPrelude = `\r\n  vec2 tc = g_vertexBaseCoords;\r\n  ${readVertexData(0)}\r\n  ${readNextVertexData(1)}\r\n  ${readNextVertexData(2)}\r\n`;\nconst prereadQuantizedVertexData = `${prereadVertexDataPrelude}\r\n  if (3.0 < u_vertParams.z) {\r\n    ${readNextVertexData(3)}\r\n  }\r\n`;\nconst prereadUnquantizedVertexData = `${prereadVertexDataPrelude}\r\n  ${readNextVertexData(3)}\r\n  ${readNextVertexData(4)}\r\n  if (5.0 < u_vertParams.z) {\r\n    ${readNextVertexData(5)}\r\n  }\r\n`;\nconst scratchLutParams = new Float32Array(4);\nfunction addPositionFromLUT(vert) {\n    vert.addGlobal(\"g_vertexLUTIndex\", 2 /* VariableType.Float */);\n    vert.addGlobal(\"g_vertexBaseCoords\", 3 /* VariableType.Vec2 */);\n    const unquantized = \"unquantized\" === vert.positionType;\n    const maxRgbaPerVert = unquantized ? 6 : 4;\n    for (let i = 0; i < maxRgbaPerVert; i++)\n        vert.addGlobal(`g_vertLutData${i}`, 5 /* VariableType.Vec4 */);\n    vert.addFunction(decodeUint24);\n    vert.addFunction(decodeUint16);\n    vert.addFunction(unquantized ? computeUnquantizedPosition : computeVertexPositionFromLUT);\n    vert.addUniform(\"u_vertLUT\", 8 /* VariableType.Sampler2D */, (prog) => {\n        prog.addGraphicUniform(\"u_vertLUT\", (uniform, params) => {\n            (params.geometry.asLUT).lut.texture.bindSampler(uniform, TextureUnit.VertexLUT);\n        });\n    });\n    vert.addUniform(\"u_vertParams\", 5 /* VariableType.Vec4 */, (prog) => {\n        prog.addGraphicUniform(\"u_vertParams\", (uniform, params) => {\n            assert(undefined !== params.geometry.asLUT);\n            const lut = params.geometry.asLUT.lut;\n            const lutParams = scratchLutParams;\n            lutParams[0] = lut.texture.width;\n            lutParams[1] = lut.texture.height;\n            lutParams[2] = lut.numRgbaPerVertex;\n            lutParams[3] = lut.numVertices;\n            uniform.setUniform4fv(lutParams);\n        });\n    });\n    addLookupTable(vert, \"vert\", \"u_vertParams.z\");\n    vert.addInitializer(initializeVertLUTCoords);\n    vert.addGlobal(\"g_featureAndMaterialIndex\", 5 /* VariableType.Vec4 */);\n    // Read the vertex data from the vertex table up front.  Yields a consistent (if unexplainable) small performance boost.\n    vert.addInitializer(unquantized ? prereadUnquantizedVertexData : prereadQuantizedVertexData);\n}\n/** @internal */\nexport function addPosition(vert, fromLUT) {\n    if (!fromLUT || \"quantized\" === vert.positionType) {\n        vert.addFunction(unquantizePosition);\n        vert.addUniform(\"u_qScale\", 4 /* VariableType.Vec3 */, (prog) => {\n            prog.addGraphicUniform(\"u_qScale\", (uniform, params) => {\n                assert(params.geometry.usesQuantizedPositions);\n                uniform.setUniform3fv(params.geometry.qScale);\n            });\n        });\n        vert.addUniform(\"u_qOrigin\", 4 /* VariableType.Vec3 */, (prog) => {\n            prog.addGraphicUniform(\"u_qOrigin\", (uniform, params) => {\n                assert(params.geometry.usesQuantizedPositions);\n                uniform.setUniform3fv(params.geometry.qOrigin);\n            });\n        });\n    }\n    if (!fromLUT) {\n        vert.addFunction(computeQuantizedPosition);\n    }\n    else {\n        addPositionFromLUT(vert);\n    }\n}\n/** @internal */\nexport function addAlpha(vert) {\n    vert.addUniform(\"u_hasAlpha\", 2 /* VariableType.Float */, (prog) => {\n        prog.addGraphicUniform(\"u_hasAlpha\", (uniform, params) => {\n            uniform.setUniform1f(Pass.rendersTranslucent(params.geometry.getPass(params.target)) ? 1 : 0);\n        });\n    });\n}\n/** @internal */\nexport function addLineWeight(vert) {\n    vert.addUniform(\"u_lineWeight\", 2 /* VariableType.Float */, (prog) => {\n        prog.addGraphicUniform(\"u_lineWeight\", (attr, params) => {\n            attr.setUniform1f(params.geometry.getLineWeight(params.programParams));\n        });\n    });\n    vert.addGlobal(\"g_lineWeight\", 2 /* VariableType.Float */);\n    if (vert.usesInstancedGeometry) {\n        addInstanceOverrides(vert);\n        vert.addInitializer(\"g_lineWeight = mix(u_lineWeight, a_instanceOverrides.g, extractInstanceBit(kOvrBit_Weight));\");\n    }\n    else {\n        vert.addInitializer(\"g_lineWeight = u_lineWeight;\");\n    }\n    vert.addFunction(computeLineWeight);\n}\n/** @internal */\nexport function replaceLineWeight(vert, func) {\n    vert.replaceFunction(computeLineWeight, func);\n}\n/** @internal */\nexport function addLineCode(vert) {\n    vert.addUniform(\"u_lineCode\", 2 /* VariableType.Float */, (prog) => {\n        prog.addGraphicUniform(\"u_lineCode\", (attr, params) => {\n            attr.setUniform1f(params.geometry.getLineCode(params.programParams));\n        });\n    });\n    vert.addGlobal(\"g_lineCode\", 2 /* VariableType.Float */);\n    if (vert.usesInstancedGeometry) {\n        addInstanceOverrides(vert);\n        vert.addInitializer(\"g_lineCode = mix(u_lineCode, a_instanceOverrides.b, extractInstanceBit(kOvrBit_LineCode));\");\n    }\n    else {\n        vert.addInitializer(\"g_lineCode = u_lineCode;\");\n    }\n    vert.addFunction(computeLineCode);\n}\n/** @internal */\nexport function replaceLineCode(vert, func) {\n    vert.replaceFunction(computeLineCode, func);\n}\n// This vertex belongs to a triangle which should not be rendered. Produce a degenerate triangle.\n// Also place it outside NDC range (for GL_POINTS)\nconst discardVertex = ` {\r\n    gl_Position = vec4(2.0, 2.0, 2.0, 1.0);\r\n    return;\r\n  }\r\n`;\n/** @internal */\nexport const earlyVertexDiscard = `  if (checkForEarlyDiscard(rawPosition))${discardVertex}`;\n/** @internal */\nexport const vertexDiscard = `  if (checkForDiscard())${discardVertex}`;\n/** @internal */\nexport const lateVertexDiscard = `  if (checkForLateDiscard())${discardVertex}`;\n//# sourceMappingURL=Vertex.js.map",
      "start": 1693508124728,
      "end": 1693508124875,
      "sourcemaps": null
    }
  ]
}
