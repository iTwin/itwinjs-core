{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/bentley/lib/esm/OneAtATimeAction.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Utils\n */\nimport { BentleyError } from \"./BentleyError\";\n/** @beta */\nexport class AbandonedError extends Error {\n}\n/**\n * An object that returns a Promise when you call [[init]], but supplies a way to abandon the promise if it is no longer relevant.\n * When you call abandon, the promise will be rejected. You must supply a [[run]] method to the constructor that\n * creates the real Promise for the underlying action. Notice that to use this class there are really two\n * Promises involved that are chained together. That makes this class less efficient than just using a Promise directly.\n */\nclass PromiseWithAbandon {\n    /** Create a PromiseWithAbandon. After this call you must call [[init]] to create the underlying Promise.\n     * @param _run The method that creates the underlying Promise.\n     * @param _args An array of args to be passed to run when [[start]] is called.\n     */\n    constructor(_run, _args) {\n        this._run = _run;\n        this._args = _args;\n    }\n    /** Create a Promise that is chained to the underlying Promise, but is connected to the abandon method. */\n    async init(msg) {\n        return new Promise((resolve, reject) => {\n            this.abandon = (message) => reject(new AbandonedError(message ?? msg));\n            this._resolve = resolve;\n        });\n    }\n    /** Call the [[run]] method supplied to the ctor to start the underlying Promise. */\n    async start() {\n        try {\n            this._resolve(await this._run(...this._args));\n        }\n        catch (err) {\n            this.abandon(BentleyError.getErrorMessage(err)); // turn all errors from execution into abandoned errors, but keep the message\n        }\n    }\n}\n/**\n * Orchestrator of a one-at-a-time activity. This concept is useful only for *replaceable* operations (that is, operations where subsequent requests replace and obviate\n * the need for previous requests. E.g. over slow HTTP connections, without this class, the stream of requests can overwhelm the connection, and cause the HTTP\n * request queue to grow such that the delay to service new requests is unbounded.\n *\n * With this class, we issue the initial request immediately. When the second request arrives before the first one completes, it becomes *pending*. If subsequent\n * requests arrive with a pending request, the current pending request is *abandoned* (its Promise is rejected) and the new request becomes pending.\n * When the active request completes, the pending request (if present) is started. In this manner there will only ever be one outstanding HTTP request for this type\n * of operation, but the first and last request will always eventually complete.\n * @beta\n */\nexport class OneAtATimeAction {\n    /** Ctor for OneAtATimePromise.\n     * @param run The method that performs an action that creates the Promise.\n     */\n    constructor(run, msg = \"abandoned\") {\n        this._run = run;\n        this.msg = msg;\n    }\n    /** Add a new request to this OneAtATimePromise. The request will only run when no other outstanding requests are active.\n     * @note Callers of this method *must* handle AbandonedError rejections.\n     */\n    async request(...args) {\n        const entry = new PromiseWithAbandon(this._run, args); // create an \"abandon-able promise\" object\n        const promise = entry.init(this.msg); // create the Promise from PromiseWithAbandon. Note: this must be called before we call start.\n        if (this._active !== undefined) { // is there an active request?\n            if (this._pending) // yes. If there is also a pending request, this one replaces it and previous one is abandoned\n                this._pending.abandon(); // rejects previous call to this method, throwing AbandonedError.\n            this._pending = entry;\n        }\n        else {\n            this._active = entry; // this is the first request, start it.\n            entry.start(); // eslint-disable-line @typescript-eslint/no-floating-promises\n        }\n        try {\n            return await promise;\n        }\n        finally {\n            // do all of this whether promise was fulfilled or rejected\n            this._active = this._pending; // see if there's a pending request waiting\n            this._pending = undefined; // clear pending\n            if (this._active)\n                this._active.start(); // eslint-disable-line @typescript-eslint/no-floating-promises\n        }\n    }\n}\n//# sourceMappingURL=OneAtATimeAction.js.map",
      "start": 1693508120373,
      "end": 1693508120471,
      "sourcemaps": null
    }
  ]
}
