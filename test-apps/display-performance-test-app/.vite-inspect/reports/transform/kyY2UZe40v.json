{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tile/map/ImageryProviders/ArcGisGraphicsRenderer.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\nimport { Logger } from \"@itwin/core-bentley\";\nimport { Cartographic } from \"@itwin/core-common\";\nimport { GrowableXYZArray, LineString3d, Loop, Point3dArray, RegionOps } from \"@itwin/core-geometry\";\nimport { ArcGisGeometryBaseRenderer, WebMercator } from \"../../internal\";\nconst loggerCategory = \"MapLayerImageryProvider.ArcGisGraphicsRenderer\";\n/** ArcGIS geometry renderer implementation that will \"render\" a list of [GraphicPrimitive]($frontend)\n * This renderer initial objective is to read geometries when a call to [[MapLayerImageryProvider.getFeatureInfo]] is performed.\n * @internal\n */\nexport class ArcGisGraphicsRenderer extends ArcGisGeometryBaseRenderer {\n    get attributeSymbology() { return undefined; } // No symbology is applied in this renderer\n    constructor(iModel) {\n        super();\n        this._scratchPointsArray = new GrowableXYZArray();\n        this._scratchPaths = [];\n        this._graphics = [];\n        this._iModel = iModel;\n    }\n    moveGraphics() {\n        const graphics = this._graphics;\n        this._graphics = [];\n        return graphics;\n    }\n    beginPath() {\n        this._scratchPointsArray.clear();\n        this._scratchPaths = [];\n    }\n    closePath() {\n        if (this._scratchPointsArray.length > 0) {\n            this._scratchPaths.push(this._scratchPointsArray.getArray());\n            this._scratchPointsArray.clear();\n        }\n    }\n    async lineTo(x, y) {\n        this._scratchPointsArray.push({ x, y, z: 0 });\n    }\n    async moveTo(x, y) {\n        if (this._scratchPointsArray.length > 0) {\n            this._scratchPaths.push(this._scratchPointsArray.getArray());\n            this._scratchPointsArray.clear();\n        }\n        this._scratchPointsArray.push({ x, y, z: 0 });\n    }\n    async fill() {\n        if (this._scratchPaths.length > 0) {\n            const loops = [];\n            if (this._iModel.noGcsDefined) {\n                for (const points of this._scratchPaths) {\n                    loops.push(Loop.create(LineString3d.create(this.toSpatialFromEcf(points))));\n                }\n            }\n            else {\n                const pathPromises = [];\n                for (const points of this._scratchPaths) {\n                    pathPromises.push(this.toSpatialFromGcs(points));\n                }\n                const pathsArray = await Promise.all(pathPromises);\n                for (const pointsArray of pathsArray) {\n                    loops.push(Loop.create(LineString3d.create(pointsArray)));\n                }\n            }\n            const mergedLoops = RegionOps.constructAllXYRegionLoops(loops);\n            for (const loop of mergedLoops) {\n                for (const negativeLoop of loop.negativeAreaLoops) {\n                    this._graphics.push({ type: \"loop\", loop: negativeLoop });\n                }\n            }\n            this._scratchPaths = [];\n        }\n    }\n    async stroke() {\n        if (this._scratchPointsArray.length > 0) {\n            this._scratchPaths.push(this._scratchPointsArray.getArray());\n            this._scratchPointsArray.clear();\n        }\n        if (this._iModel.noGcsDefined) {\n            for (const linestring of this._scratchPaths) {\n                this._graphics.push({ type: \"linestring\", points: this.toSpatialFromEcf(linestring) });\n            }\n        }\n        else {\n            const pathPromises = [];\n            for (const noGcsDefined of this._scratchPaths) {\n                pathPromises.push(this.toSpatialFromGcs(noGcsDefined));\n            }\n            const reprojectedPaths = await Promise.all(pathPromises);\n            for (const path of reprojectedPaths) {\n                this._graphics.push({ type: \"linestring\", points: Point3dArray.clonePoint3dArray(path) });\n            }\n        }\n        this._scratchPaths = [];\n    }\n    drawPoint(x, y) {\n        this._scratchPointsArray.push({ x, y, z: 0 });\n    }\n    async finishPoints() {\n        if (this._scratchPointsArray.length > 0) {\n            if (this._iModel.noGcsDefined) {\n                this._graphics.push({ type: \"pointstring\", points: this.toSpatialFromEcf(this._scratchPointsArray.getArray()) });\n            }\n            else {\n                // Backend reprojection\n                const pointsArray = this._scratchPointsArray.getArray();\n                try {\n                    const spatialPoints = await this.toSpatialFromGcs(pointsArray);\n                    this._graphics.push({ type: \"pointstring\", points: spatialPoints });\n                }\n                catch (error) {\n                    Logger.logError(loggerCategory, \"ArcGisFeatureGraphicsRenderer: Could not reproject points\");\n                }\n            }\n            this._scratchPointsArray.clear();\n        }\n    }\n    async toSpatialFromGcs(geoPoints) {\n        return this._iModel.toSpatialFromGcs(geoPoints, { horizontalCRS: { epsg: 3857 }, verticalCRS: { id: \"ELLIPSOID\" } });\n    }\n    toSpatialFromEcf(geoPoints) {\n        const spatials = [];\n        for (const pt of geoPoints) {\n            const carto = { longitude: WebMercator.getEPSG4326Lon(pt.x), latitude: WebMercator.getEPSG4326Lat(pt.y), height: pt.z };\n            spatials.push(this._iModel.cartographicToSpatialFromEcef(Cartographic.fromDegrees(carto)));\n        }\n        return spatials;\n    }\n}\n//# sourceMappingURL=ArcGisGraphicsRenderer.js.map",
      "start": 1693508121754,
      "end": 1693508121875,
      "sourcemaps": null
    }
  ]
}
