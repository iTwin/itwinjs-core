{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/DecorationsCache.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Views\n */\nimport { assert } from \"@itwin/core-bentley\";\nfunction disposeCachedDecorations(decorations) {\n    for (const dec of decorations)\n        if (\"graphic\" === dec.type)\n            dec.graphicOwner.disposeGraphic();\n}\n/** A cache of decorations previously produced by a [[ViewportDecorator]] for which `useCachedDecorations` is `true`.\n * The decorations are preserved until either:\n *  - The associated [[Viewport]]'s scene is invalidated; or\n *  - The decorator explicitly requests them to be discarded.\n * The primary benefit is that cached decorations do not get recreated on every mouse motion.\n * @internal\n */\nexport class DecorationsCache {\n    constructor() {\n        this._cache = new Map();\n        /** If true, attempts to remove entries from the cache will silently fail. This is set while a [[ScreenViewport]] is producing decorations\n         * to prevent poorly-written decorators from invalidating the cache while it is being populated by, e.g., calling [[Viewport.invalidateScene]].\n         */\n        this.prohibitRemoval = false;\n    }\n    /** The number of decorators that have entries in the cache. */\n    get size() {\n        return this._cache.size;\n    }\n    /** Get the list of cached decorations for the decorator. */\n    get(decorator) {\n        return this._cache.get(decorator);\n    }\n    /** Add a decoration to the list of cached decorations for the decorator. */\n    add(decorator, decoration) {\n        assert(true === decorator.useCachedDecorations);\n        if (!decorator.useCachedDecorations)\n            return;\n        let decorations = this.get(decorator);\n        if (!decorations)\n            this._cache.set(decorator, decorations = []);\n        decorations.push(decoration);\n    }\n    /** Delete the decorator and all of its decorations, disposing of the decorations' graphics. */\n    delete(decorator) {\n        if (this.prohibitRemoval)\n            return;\n        assert(true === decorator.useCachedDecorations);\n        const decs = this._cache.get(decorator);\n        if (decs) {\n            disposeCachedDecorations(decs);\n            this._cache.delete(decorator);\n        }\n    }\n    /** Remove all decorators and their decorations from the cache, disposing of the decorations' graphics. */\n    clear() {\n        if (this.prohibitRemoval)\n            return;\n        for (const decorations of this._cache.values())\n            disposeCachedDecorations(decorations);\n        this._cache.clear();\n    }\n}\n//# sourceMappingURL=DecorationsCache.js.map",
      "start": 1693508118783,
      "end": 1693508118999,
      "sourcemaps": null
    }
  ]
}
