{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/orbitgt/lib/esm/system/runtime/Strings.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module OrbitGT\n */\nimport { AList } from \"../collection/AList\";\n/**\n * Class Strings defines the common string tools.\n */\n/** @internal */\nclass Strings {\n    constructor() {\n    }\n    static getLength(value) {\n        return value.length;\n    }\n    static getCharAt(value, index) {\n        return value.charCodeAt(index);\n    }\n    static appendChar(value, charCode) {\n        return value + String.fromCharCode(charCode);\n    }\n    static prependChar(value, charCode) {\n        return String.fromCharCode(charCode) + value;\n    }\n    static equals(value1, value2) {\n        if (value1 == null)\n            return (value2 == null);\n        if (value2 == null)\n            return false;\n        return (value1 === value2);\n    }\n    static equalsIgnoreCase(value1, value2) {\n        if (value1 == null)\n            return (value2 == null);\n        if (value2 == null)\n            return false;\n        return (value1.toLowerCase() === value2.toLowerCase());\n    }\n    static startsWith(value, prefix) {\n        return value.startsWith(prefix);\n    }\n    static endsWith(value, suffix) {\n        return value.endsWith(suffix);\n    }\n    static substring(value, index0, index1) {\n        return value.substring(index0, index1);\n    }\n    static substringFrom(value, index) {\n        return value.substring(index);\n    }\n    static charCodeAt(value, index) {\n        return value.charCodeAt(index);\n    }\n    static charCodeToString(code) {\n        return String.fromCharCode(code);\n    }\n    static indexOf(value, part) {\n        return value.indexOf(part);\n    }\n    static lastIndexOf(value, part) {\n        return value.lastIndexOf(part);\n    }\n    static indexOfFrom(value, part, index) {\n        return value.indexOf(part, index);\n    }\n    static compareTo(value1, value2) {\n        if (value1 === value2)\n            return 0;\n        return (value1 < value2) ? -1 : 1;\n    }\n    static compareToIgnoreCase(value1, value2) {\n        return Strings.compareTo(value1.toLowerCase(), value2.toLowerCase());\n    }\n    static splitAsList(value, separators) {\n        /* Null? */\n        if (value == null)\n            return null;\n        /* Make a list of parts */\n        let parts = new AList();\n        /* Fast-out */\n        if (value.length == 0)\n            return parts;\n        /* Make a list of parts */\n        while (true) {\n            /* Get the index of the next separator */\n            let index = value.length;\n            for (let i = 0; i < separators.length; i++) {\n                let nextIndex = value.indexOf(separators.charAt(i));\n                if ((nextIndex >= 0) && (nextIndex < index))\n                    index = nextIndex;\n            }\n            /* None remaining ? */\n            if (index == value.length) {\n                /* Done */\n                parts.add(value);\n                break;\n            }\n            else {\n                /* Add a substring */\n                parts.add(value.substring(0, index));\n                value = value.substring(index + 1);\n            }\n        }\n        /* Return the parts */\n        return parts;\n    }\n    static splitAdvanced(value, separators, opens, closes, literals) {\n        /* Check the value */\n        if (value == null)\n            return null;\n        /* Check the parameters */\n        if (separators == null)\n            separators = \"\";\n        if (opens == null)\n            opens = \"\";\n        if (closes == null)\n            closes = \"\";\n        if (literals == null)\n            literals = \"\";\n        /* Make a list of parts */\n        let parts = new AList();\n        /* Check all characters in the value */\n        let level = 0;\n        let start = 0;\n        let literal = null;\n        for (let i = 0; i < value.length; i++) {\n            /* Get the next character */\n            let c = value.substring(i, i + 1);\n            /* Escaped character ? */\n            if ((i > 0) && (value.substring(i - 1, i) === \"\\\\\"))\n                continue;\n            /* Quote bound ? */\n            if (literal != null ? literal === c : ((literals.length > 0) && (literals.indexOf(c) >= 0))) {\n                /* Toggle */\n                literal = literal == null ? c : null;\n                continue;\n            }\n            /* Ignore this character ? */\n            if (literal != null)\n                continue;\n            /* Separator ? */\n            if ((separators.indexOf(c) >= 0) && (level == 0)) {\n                /* Get the part */\n                parts.add(value.substring(start, i));\n                start = i + 1;\n            }\n            /* Open ? */\n            else if (opens.indexOf(c) >= 0) {\n                level += 1;\n            }\n            /* Close ? */\n            else if (closes.indexOf(c) >= 0) {\n                level -= 1;\n            }\n        }\n        /* Add the last part */\n        parts.add(value.substring(start));\n        /* Return the parts */\n        return parts;\n    }\n    static trim(value) {\n        return value.trim();\n    }\n    static replace(line, key, value) {\n        return line.replace(key, value);\n    }\n}\n/** The 'infinity' character */\nStrings.INFINITY = \"\\u221E\";\n/** The 'double-quote' character */\nStrings.DQUOTE = \"\\\"\";\n/** The 'single-quote' character */\nStrings.SQUOTE = \"'\";\n/** The 'tab' character */\nStrings.TAB = String.fromCharCode(9);\n/** The 'carriage return' character */\nStrings.CR = String.fromCharCode(13);\n/** The 'newline' (linux line terminator) character */\nStrings.NL = String.fromCharCode(10);\n/** The 'carriage return+newline' (dos line terminator) character sequence */\nStrings.CR_NL = String.fromCharCode(13) + String.fromCharCode(10);\nexport { Strings };\n//# sourceMappingURL=Strings.js.map",
      "start": 1693508125329,
      "end": 1693508125382,
      "sourcemaps": null
    }
  ]
}
