{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/serialization/IModelJsonSchema.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Serialization\n */\nimport { AkimaCurve3d } from \"../bspline/AkimaCurve3d\";\nimport { BSplineCurve3d } from \"../bspline/BSplineCurve\";\nimport { BSplineCurve3dH } from \"../bspline/BSplineCurve3dH\";\nimport { BSplineCurveOps } from \"../bspline/BSplineCurveOps\";\nimport { BSplineSurface3d, BSplineSurface3dH, WeightStyle } from \"../bspline/BSplineSurface\";\nimport { InterpolationCurve3d as InterpolationCurve3d } from \"../bspline/InterpolationCurve3d\";\nimport { BSplineWrapMode } from \"../bspline/KnotVector\";\nimport { Arc3d } from \"../curve/Arc3d\";\nimport { CoordinateXYZ } from \"../curve/CoordinateXYZ\";\nimport { BagOfCurves, CurveCollection } from \"../curve/CurveCollection\";\nimport { GeometryQuery } from \"../curve/GeometryQuery\";\nimport { LineSegment3d } from \"../curve/LineSegment3d\";\nimport { LineString3d } from \"../curve/LineString3d\";\nimport { Loop } from \"../curve/Loop\";\nimport { ParityRegion } from \"../curve/ParityRegion\";\nimport { Path } from \"../curve/Path\";\nimport { PointString3d } from \"../curve/PointString3d\";\nimport { DirectSpiral3d } from \"../curve/spiral/DirectSpiral3d\";\nimport { IntegratedSpiral3d } from \"../curve/spiral/IntegratedSpiral3d\";\nimport { UnionRegion } from \"../curve/UnionRegion\";\nimport { AxisOrder, Geometry } from \"../Geometry\";\nimport { Angle } from \"../geometry3d/Angle\";\nimport { AngleSweep } from \"../geometry3d/AngleSweep\";\nimport { GeometryHandler } from \"../geometry3d/GeometryHandler\";\nimport { Matrix3d } from \"../geometry3d/Matrix3d\";\nimport { Point2d } from \"../geometry3d/Point2dVector2d\";\nimport { Point3d, Vector3d, XYZ } from \"../geometry3d/Point3dVector3d\";\nimport { Ray3d } from \"../geometry3d/Ray3d\";\nimport { Segment1d } from \"../geometry3d/Segment1d\";\nimport { Transform } from \"../geometry3d/Transform\";\nimport { YawPitchRollAngles } from \"../geometry3d/YawPitchRollAngles\";\nimport { Point4d } from \"../geometry4d/Point4d\";\nimport { AuxChannel, AuxChannelData, PolyfaceAuxData } from \"../polyface/AuxData\";\nimport { IndexedPolyface } from \"../polyface/Polyface\";\nimport { TaggedNumericData } from \"../polyface/TaggedNumericData\";\nimport { Box } from \"../solid/Box\";\nimport { Cone } from \"../solid/Cone\";\nimport { LinearSweep } from \"../solid/LinearSweep\";\nimport { RotationalSweep } from \"../solid/RotationalSweep\";\nimport { RuledSweep } from \"../solid/RuledSweep\";\nimport { Sphere } from \"../solid/Sphere\";\nimport { TorusPipe } from \"../solid/TorusPipe\";\n// cspell:word bagof\n/**\n * `ImodelJson` namespace has classes for serializing and deserialization json objects\n * @public\n */\nexport var IModelJson;\n(function (IModelJson) {\n    /** parser services for \"iModelJson\" schema\n     * * 1: create a reader with `new ImodelJsonReader`\n     * * 2: parse json fragment to strongly typed geometry: `const g = reader.parse (fragment)`\n     * @public\n     */\n    class Reader {\n        constructor() {\n        }\n        static parseVector3dProperty(json, propertyName, defaultValue) {\n            if (json.hasOwnProperty(propertyName)) {\n                const value = json[propertyName];\n                if (Geometry.isNumberArray(value, 3))\n                    return Vector3d.create(value[0], value[1], value[2]);\n                if (Geometry.isNumberArray(value, 2))\n                    return Vector3d.create(value[0], value[1]);\n                if (XYZ.isXAndY(value))\n                    return Vector3d.fromJSON(value);\n            }\n            return defaultValue;\n        }\n        static parsePoint3dProperty(json, propertyName, defaultValue) {\n            if (json.hasOwnProperty(propertyName)) {\n                const value = json[propertyName];\n                if (Geometry.isNumberArray(value, 3))\n                    return Point3d.create(value[0], value[1], value[2]);\n                if (Geometry.isNumberArray(value, 2))\n                    return Point3d.create(value[0], value[1]);\n                if (XYZ.isXAndY(value))\n                    return Point3d.fromJSON(value);\n            }\n            return defaultValue;\n        }\n        static parseSegment1dProperty(json, propertyName, defaultValue) {\n            if (json.hasOwnProperty(propertyName)) {\n                const value = json[propertyName];\n                if (Geometry.isNumberArray(value, 2))\n                    return Segment1d.create(value[0], value[1]);\n            }\n            return defaultValue;\n        }\n        static parseNumberProperty(json, propertyName, defaultValue) {\n            if (json.hasOwnProperty(propertyName)) {\n                const value = json[propertyName];\n                if (Number.isFinite(value))\n                    return value;\n            }\n            return defaultValue;\n        }\n        /**\n         * @internal\n         */\n        static parseTaggedNumericProps(json) {\n            const tagA = this.parseNumberProperty(json, \"tagA\");\n            const tagB = this.parseNumberProperty(json, \"tagB\", 0);\n            if (tagA !== undefined) {\n                const result = new TaggedNumericData(tagA, tagB);\n                if (json.hasOwnProperty(\"intData\"))\n                    result.intData = this.parseNumberArrayProperty(json, \"intData\", 0, undefined);\n                if (json.hasOwnProperty(\"doubleData\"))\n                    result.doubleData = this.parseNumberArrayProperty(json, \"doubleData\", 0, undefined);\n                return result;\n            }\n            return undefined;\n        }\n        static parseNumberArrayProperty(json, propertyName, minValues, maxValues, defaultValue) {\n            if (json.hasOwnProperty(propertyName)) {\n                const value = json[propertyName];\n                if (Array.isArray(value)\n                    && value.length >= minValues && (undefined === maxValues || value.length <= maxValues)) {\n                    const result = [];\n                    for (const a of value) {\n                        result.push(a);\n                    }\n                    return result;\n                }\n            }\n            return defaultValue;\n        }\n        static parseAngleProperty(json, propertyName, defaultValue) {\n            if (json.hasOwnProperty(propertyName)) {\n                const value = json[propertyName];\n                return Angle.fromJSON(value);\n            }\n            return defaultValue;\n        }\n        /**\n         * @param defaultFunction function to call if needed to produce a default value\n         */\n        static parseAngleSweepProps(json, propertyName, defaultFunction) {\n            if (json.hasOwnProperty(propertyName)) {\n                const value = json[propertyName];\n                return AngleSweep.fromJSON(value);\n            }\n            if (defaultFunction === undefined)\n                return undefined;\n            return defaultFunction();\n        }\n        static parseBooleanProperty(json, propertyName, defaultValue) {\n            if (json.hasOwnProperty(propertyName)) {\n                const value = json[propertyName];\n                if (value === true)\n                    return true;\n                if (value === false)\n                    return false;\n            }\n            return defaultValue;\n        }\n        static loadContourArray(json, propertyName) {\n            if (json.hasOwnProperty(propertyName)) {\n                const value = json[propertyName];\n                if (Array.isArray(value)) {\n                    const result = [];\n                    for (const contourData of value) {\n                        const contour = Reader.parse(contourData);\n                        if (contour instanceof CurveCollection) {\n                            result.push(contour);\n                        }\n                    }\n                    if (result.length > 0)\n                        return result;\n                }\n            }\n            return undefined;\n        }\n        static parseYawPitchRollAnglesToMatrix3d(json) {\n            const ypr = YawPitchRollAngles.fromJSON(json);\n            return ypr.toMatrix3d();\n        }\n        static parseStringProperty(json, propertyName, defaultValue) {\n            if (json.hasOwnProperty(propertyName)) {\n                const value = json[propertyName];\n                // if (value instanceof string)\n                return value;\n            }\n            return defaultValue;\n        }\n        static parseAxesFromVectors(json, axisOrder, createDefaultIdentity) {\n            if (Array.isArray(json) && json.length === 2) {\n                const xVector = Vector3d.fromJSON(json[0]);\n                const yVector = Vector3d.fromJSON(json[1]);\n                const matrix = Matrix3d.createRigidFromColumns(xVector, yVector, axisOrder);\n                if (matrix)\n                    return matrix;\n            }\n            if (createDefaultIdentity)\n                return Matrix3d.createIdentity();\n            return undefined;\n        }\n        /**\n         * Look for orientation data and convert to Matrix3d.\n         * * Search order is:\n         * * * yawPitchRollAngles\n         * * * xyVectors\n         * * * zxVectors\n         * @param json [in] json source data\n         * @param createDefaultIdentity [in] If true and no orientation is present, return an identity matrix.  If false and no orientation is present, return undefined.\n         */\n        static parseOrientation(json, createDefaultIdentity) {\n            if (json.yawPitchRollAngles) {\n                return Reader.parseYawPitchRollAnglesToMatrix3d(json.yawPitchRollAngles);\n            }\n            else if (json.xyVectors) {\n                return Reader.parseAxesFromVectors(json.xyVectors, AxisOrder.XYZ, createDefaultIdentity);\n            }\n            else if (json.zxVectors) {\n                return Reader.parseAxesFromVectors(json.zxVectors, AxisOrder.ZXY, createDefaultIdentity);\n            }\n            if (createDefaultIdentity)\n                return Matrix3d.createIdentity();\n            return undefined;\n        }\n        static parseArcByVectorProps(data) {\n            if (data\n                && data.center !== undefined\n                && data.vectorX !== undefined\n                && data.vectorY !== undefined\n                && data.sweepStartEnd !== undefined) {\n                return Arc3d.create(Point3d.fromJSON(data.center), Vector3d.fromJSON(data.vectorX), Vector3d.fromJSON(data.vectorY), AngleSweep.fromJSON(data.sweepStartEnd));\n            }\n            return undefined;\n        }\n        // remark: Returns LineString3d as last default when give points are colinear.\n        static parseArcBy3Points(data) {\n            if (Array.isArray(data) && data.length > 2) {\n                const pointA = Point3d.fromJSON(data[0]);\n                const pointB = Point3d.fromJSON(data[1]);\n                const pointC = Point3d.fromJSON(data[2]);\n                return Arc3d.createCircularStartMiddleEnd(pointA, pointB, pointC);\n            }\n            return undefined;\n        }\n        static parseArcObject(data) {\n            let arc = Reader.parseArcByVectorProps(data);\n            if (arc)\n                return arc;\n            arc = Reader.parseArcBy3Points(data);\n            return arc; // possibly undefined.\n        }\n        /** Parse point content (right side) `[1,2,3]` to a CoordinateXYZ object. */\n        static parseCoordinate(data) {\n            const point = Point3d.fromJSON(data);\n            if (point)\n                return CoordinateXYZ.create(point);\n            return undefined;\n        }\n        /** Parse TransitionSpiral content (right side) to TransitionSpiral3d. */\n        static parseTransitionSpiral(data) {\n            const axes = Reader.parseOrientation(data, true);\n            const origin = Reader.parsePoint3dProperty(data, \"origin\");\n            // the create method will juggle any 4 out of these 5 inputs to define the other ..\n            const startBearing = Reader.parseAngleProperty(data, \"startBearing\");\n            const endBearing = Reader.parseAngleProperty(data, \"endBearing\");\n            const startRadius = Reader.parseNumberProperty(data, \"startRadius\");\n            const endRadius = Reader.parseNumberProperty(data, \"endRadius\");\n            let length = Reader.parseNumberProperty(data, \"length\", undefined);\n            if (length === undefined)\n                length = Reader.parseNumberProperty(data, \"curveLength\", undefined);\n            let interval = Reader.parseSegment1dProperty(data, \"activeFractionInterval\", undefined);\n            if (!interval)\n                interval = Reader.parseSegment1dProperty(data, \"fractionInterval\", undefined);\n            if (!interval)\n                interval = Reader.parseSegment1dProperty(data, \"activeInterval\", undefined);\n            const spiralType = Reader.parseStringProperty(data, \"type\", \"clothoid\");\n            // REMARK:  Our job is to parse and pass data along -- inscrutable validation happens in the implementation classes . . .\n            if (origin) {\n                let candidate;\n                candidate = IntegratedSpiral3d.createFrom4OutOf5(spiralType, startRadius, endRadius, startBearing, endBearing, length, interval, Transform.createOriginAndMatrix(origin, axes));\n                if (candidate)\n                    return candidate;\n                candidate = DirectSpiral3d.createFromLengthAndRadius(spiralType, startRadius, endRadius, startBearing, endBearing, length, interval, Transform.createOriginAndMatrix(origin, axes));\n                if (candidate)\n                    return candidate;\n            }\n            return undefined;\n        }\n        /**\n         * Special closed case if the input was forced to bezier . . . (e.g. arc)\n         *       (b-1) 0 0 0  a . . . b 111 (a+1)\n         *       with {order} clamp-like values .. no pole duplication needed, but throw out 2 knots at each end . ..\n         * @param numPoles number of poles\n         * @param knots knot vector\n         * @param order curve order\n         * @param newKnots array to receive new knots.\n         * @returns true if this is a closed-but-clamped case and corrected knots are filled in.\n         */\n        static getCorrectedKnotsForClosedClamped(numPoles, knots, order, newKnots) {\n            const numKnots = knots.length;\n            if (numPoles + 2 * order - 1 === numKnots\n                && knots[0] < knots[1]\n                && knots[numKnots - 2] < knots[numKnots - 1]) {\n                const a0 = knots[1];\n                const a1 = knots[numKnots - 2];\n                for (let i = 2; i <= order; i++) {\n                    if (knots[i] !== a0)\n                        return false;\n                    if (knots[numKnots - 1 - i] !== a1)\n                        return false;\n                }\n                // copy only the \"minimal\" set - without the typical extra knots from microstation and psd.\n                for (let i = 2; i + 2 < numKnots; i++)\n                    newKnots.push(knots[i]);\n                return true;\n            }\n            return false;\n        }\n        /** Parse `bcurve` content (right side)to  BSplineCurve3d or BSplineCurve3dH object. */\n        static parseBcurve(data) {\n            if (data === undefined)\n                return undefined;\n            if (Array.isArray(data.points) && Array.isArray(data.knots) && Number.isFinite(data.order) && data.closed !== undefined) {\n                if (data.points[0].length === 4) {\n                    const hPoles = [];\n                    for (const p of data.points)\n                        hPoles.push(Point4d.fromJSON(p));\n                    const knots = [];\n                    let wrapMode = BSplineWrapMode.None;\n                    if (data.closed && this.getCorrectedKnotsForClosedClamped(data.points.length, data.knots, data.order, knots)) {\n                        // leave the poles alone -- knots are fixed.\n                        wrapMode = BSplineWrapMode.OpenByRemovingKnots;\n                    }\n                    else if (data.closed) {\n                        for (const knot of data.knots)\n                            knots.push(knot);\n                        for (let i = 0; i + 1 < data.order; i++) {\n                            hPoles.push(hPoles[i].clone());\n                        }\n                        wrapMode = BSplineWrapMode.OpenByAddingControlPoints;\n                    }\n                    else {\n                        // simple case .. just copy\n                        for (const knot of data.knots)\n                            knots.push(knot);\n                    }\n                    const newCurve = BSplineCurve3dH.create(hPoles, knots, data.order);\n                    if (newCurve) {\n                        if (data.closed === true)\n                            newCurve.setWrappable(wrapMode);\n                        return newCurve;\n                    }\n                }\n                else if (data.points[0].length === 3 || data.points[0].length === 2) {\n                    const poles = [];\n                    for (const p of data.points)\n                        poles.push(Point3d.fromJSON(p));\n                    const knots = [];\n                    let wrapMode = BSplineWrapMode.None;\n                    if (data.closed && this.getCorrectedKnotsForClosedClamped(data.points.length, data.knots, data.order, knots)) {\n                        wrapMode = BSplineWrapMode.OpenByRemovingKnots;\n                        // leave the poles alone -- knots are fixed.\n                    }\n                    else if (data.closed) {\n                        for (const knot of data.knots)\n                            knots.push(knot);\n                        for (let i = 0; i + 1 < data.order; i++) {\n                            poles.push(poles[i].clone());\n                        }\n                        wrapMode = BSplineWrapMode.OpenByAddingControlPoints;\n                    }\n                    else {\n                        // simple case .. just copy\n                        for (const knot of data.knots)\n                            knots.push(knot);\n                    }\n                    const newCurve = BSplineCurve3d.create(poles, knots, data.order);\n                    if (newCurve) {\n                        if (data.closed === true)\n                            newCurve.setWrappable(wrapMode);\n                        return newCurve;\n                    }\n                }\n            }\n            return undefined;\n        }\n        /** Parse `bcurve` content (right side)to  BSplineCurve3d or BSplineCurve3dH object. */\n        static parseInterpolationCurve(data) {\n            if (data === undefined)\n                return undefined;\n            return InterpolationCurve3d.create(data);\n        }\n        /** Parse `bcurve` content (right side)to an Akima curve object. */\n        static parseAkimaCurve3d(data) {\n            if (data === undefined)\n                return undefined;\n            return AkimaCurve3d.create(data);\n        }\n        /** Parse array of json objects to array of instances. */\n        static parseArray(data) {\n            if (Array.isArray(data)) {\n                const myArray = [];\n                let c;\n                for (c of data) {\n                    const g = Reader.parse(c);\n                    if (g !== undefined)\n                        myArray.push(g);\n                }\n                return myArray;\n            }\n            return undefined;\n        }\n        // For each nonzero index, Announce Math.abs (value) -1\n        static addZeroBasedIndicesFromSignedOneBased(data, numPerFace, f) {\n            if (data && Geometry.isNumberArray(data)) {\n                if (numPerFace > 1) {\n                    // all indices are used ...\n                    for (const value of data) {\n                        f(Math.abs(value) - 1);\n                    }\n                }\n                else {\n                    // ignore separator zeros ...\n                    for (const value of data) {\n                        if (value !== 0)\n                            f(Math.abs(value) - 1);\n                    }\n                }\n            }\n        }\n        /** parse polyface aux data content to PolyfaceAuxData instance */\n        static parsePolyfaceAuxData(data = undefined, numPerFace = 0) {\n            if (!Array.isArray(data.channels) || !Array.isArray(data.indices))\n                return undefined;\n            const outChannels = [];\n            for (const inChannel of data.channels) {\n                if (Array.isArray(inChannel.data) && inChannel.hasOwnProperty(\"dataType\")) {\n                    const outChannelData = [];\n                    for (const inChannelData of inChannel.data) {\n                        if (inChannelData.hasOwnProperty(\"input\") && Array.isArray(inChannelData.values))\n                            outChannelData.push(new AuxChannelData(inChannelData.input, inChannelData.values));\n                    }\n                    outChannels.push(new AuxChannel(outChannelData, inChannel.dataType, inChannel.name, inChannel.inputName));\n                }\n            }\n            const auxData = new PolyfaceAuxData(outChannels, []);\n            Reader.addZeroBasedIndicesFromSignedOneBased(data.indices, numPerFace, (x) => { auxData.indices.push(x); });\n            return auxData;\n        }\n        /** parse indexed mesh content to an IndexedPolyface instance */\n        static parseIndexedMesh(data) {\n            // {Coord:[[x,y,z],. . . ],   -- simple xyz for each point\n            // CoordIndex[1,2,3,0]    -- zero-terminated, one based !!!\n            if (data.hasOwnProperty(\"point\") && Array.isArray(data.point)\n                && data.hasOwnProperty(\"pointIndex\") && Array.isArray(data.pointIndex)) {\n                const polyface = IndexedPolyface.create();\n                if (data.hasOwnProperty(\"normal\") && Array.isArray(data.normal)) {\n                    // for normals, addNormal() is overeager to detect the (common) case of duplicate normals in sequence.\n                    // use addNormalXYZ which always creates a new one.\n                    // likewise for params\n                    for (const uvw of data.normal) {\n                        if (Geometry.isNumberArray(uvw, 3))\n                            polyface.addNormalXYZ(uvw[0], uvw[1], uvw[2]);\n                    }\n                }\n                if (data.hasOwnProperty(\"twoSided\")) {\n                    const q = data.twoSided;\n                    if (q === true || q === false) {\n                        polyface.twoSided = q;\n                    }\n                }\n                const numPerFace = data.hasOwnProperty(\"numPerFace\") ? data.numPerFace : 0;\n                if (data.hasOwnProperty(\"expectedClosure\")) {\n                    const q = data.expectedClosure;\n                    if (Number.isFinite(q)) {\n                        polyface.expectedClosure = q;\n                    }\n                }\n                if (data.hasOwnProperty(\"param\") && Array.isArray(data.param)) {\n                    for (const uv of data.param) {\n                        if (Geometry.isNumberArray(uv, 2))\n                            polyface.addParamUV(uv[0], uv[1]);\n                    }\n                }\n                if (data.hasOwnProperty(\"color\") && Array.isArray(data.color)) {\n                    for (const c of data.color) {\n                        polyface.addColor(c);\n                    }\n                }\n                for (const p of data.point)\n                    polyface.addPointXYZ(p[0], p[1], p[2]);\n                if (numPerFace > 1) {\n                    for (let i = 0; i < data.pointIndex.length; i++) {\n                        const p = data.pointIndex[i];\n                        const p0 = Math.abs(p) - 1;\n                        polyface.addPointIndex(p0, p > 0);\n                        if ((i + 1) % numPerFace === 0)\n                            polyface.terminateFacet(false);\n                    }\n                }\n                else {\n                    for (const p of data.pointIndex) {\n                        if (p === 0)\n                            polyface.terminateFacet(false); // we are responsible for index checking !!!\n                        else {\n                            const p0 = Math.abs(p) - 1;\n                            polyface.addPointIndex(p0, p > 0);\n                        }\n                    }\n                }\n                if (data.hasOwnProperty(\"normalIndex\")) {\n                    Reader.addZeroBasedIndicesFromSignedOneBased(data.normalIndex, numPerFace, (x) => { polyface.addNormalIndex(x); });\n                }\n                if (data.hasOwnProperty(\"paramIndex\")) {\n                    Reader.addZeroBasedIndicesFromSignedOneBased(data.paramIndex, numPerFace, (x) => { polyface.addParamIndex(x); });\n                }\n                if (data.hasOwnProperty(\"colorIndex\")) {\n                    Reader.addZeroBasedIndicesFromSignedOneBased(data.colorIndex, numPerFace, (x) => { polyface.addColorIndex(x); });\n                }\n                if (data.hasOwnProperty(\"auxData\"))\n                    polyface.data.auxData = Reader.parsePolyfaceAuxData(data.auxData, numPerFace);\n                if (data.hasOwnProperty(\"tags\")) {\n                    polyface.data.taggedNumericData = Reader.parseTaggedNumericProps(data.tags);\n                }\n                return polyface;\n            }\n            return undefined;\n        }\n        /** parse contents of a curve collection to a CurveCollection instance */\n        static parseCurveCollectionMembers(result, data) {\n            if (data && Array.isArray(data)) {\n                for (const c of data) {\n                    const g = Reader.parse(c);\n                    if (g instanceof GeometryQuery && (\"curveCollection\" === g.geometryCategory || \"curvePrimitive\" === g.geometryCategory))\n                        result.tryAddChild(g);\n                }\n                return result;\n            }\n            return undefined;\n        }\n        /** Parse content of `bsurf` to BSplineSurface3d or BSplineSurface3dH */\n        static parseBsurf(data) {\n            if (data.hasOwnProperty(\"uKnots\") && Array.isArray(data.uKnots)\n                && data.hasOwnProperty(\"vKnots\") && Array.isArray(data.vKnots)\n                && data.hasOwnProperty(\"orderU\") && Number.isFinite(data.orderU)\n                && data.hasOwnProperty(\"orderV\") && Number.isFinite(data.orderV)\n                && data.hasOwnProperty(\"points\") && Array.isArray(data.points)) {\n                const orderU = data.orderU;\n                const orderV = data.orderV;\n                if (Array.isArray(data.points[0]) && Array.isArray(data.points[0][0])) {\n                    const d = data.points[0][0].length;\n                    /** xyz surface (no weights) */\n                    if (d === 3) {\n                        return BSplineSurface3d.createGrid(data.points, orderU, data.uKnots, orderV, data.vKnots);\n                    }\n                    /** xyzw surface (weights already applied) */\n                    if (d === 4) {\n                        return BSplineSurface3dH.createGrid(data.points, WeightStyle.WeightsAlreadyAppliedToCoordinates, orderU, data.uKnots, orderV, data.vKnots);\n                    }\n                }\n            }\n            return undefined;\n        }\n        /** Parse `cone` contents to `Cone` instance  */\n        static parseConeProps(json) {\n            const axes = Reader.parseOrientation(json, false);\n            const start = Reader.parsePoint3dProperty(json, \"start\");\n            const end = Reader.parsePoint3dProperty(json, \"end\");\n            const radius = Reader.parseNumberProperty(json, \"radius\");\n            const startRadius = Reader.parseNumberProperty(json, \"startRadius\", radius);\n            const endRadius = Reader.parseNumberProperty(json, \"endRadius\", startRadius);\n            const capped = Reader.parseBooleanProperty(json, \"capped\", false);\n            if (start\n                && end\n                && startRadius !== undefined\n                && endRadius !== undefined) {\n                if (axes === undefined) {\n                    const axisVector = Vector3d.createStartEnd(start, end);\n                    const frame = Matrix3d.createRigidHeadsUp(axisVector, AxisOrder.ZXY);\n                    const vectorX = frame.columnX();\n                    const vectorY = frame.columnY();\n                    return Cone.createBaseAndTarget(start, end, vectorX, vectorY, startRadius, endRadius, capped);\n                }\n                else {\n                    return Cone.createBaseAndTarget(start, end, axes.columnX(), axes.columnY(), startRadius, endRadius, capped);\n                }\n            }\n            return undefined;\n        }\n        /** Parse `cylinder` content to `Cone` instance */\n        static parseCylinderProps(json) {\n            const start = Reader.parsePoint3dProperty(json, \"start\");\n            const end = Reader.parsePoint3dProperty(json, \"end\");\n            const radius = Reader.parseNumberProperty(json, \"radius\");\n            const capped = Reader.parseBooleanProperty(json, \"capped\", false);\n            if (start\n                && end\n                && radius !== undefined) {\n                return Cone.createAxisPoints(start, end, radius, radius, capped);\n            }\n            return undefined;\n        }\n        /** Parse line segment (array of 2 points) properties to `LineSegment3d` instance */\n        static parseLineSegmentProps(value) {\n            if (Array.isArray(value) && value.length > 1)\n                return LineSegment3d.create(Point3d.fromJSON(value[0]), Point3d.fromJSON(value[1]));\n            else\n                return undefined;\n        }\n        /** Parse linear sweep content to `LinearSweep` instance. */\n        static parseLinearSweep(json) {\n            const contour = Reader.parse(json.contour);\n            const capped = Reader.parseBooleanProperty(json, \"capped\");\n            const extrusionVector = Reader.parseVector3dProperty(json, \"vector\");\n            if (contour instanceof GeometryQuery\n                && \"curveCollection\" === contour.geometryCategory\n                && capped !== undefined\n                && extrusionVector) {\n                return LinearSweep.create(contour, extrusionVector, capped);\n            }\n            return undefined;\n        }\n        /** Parse rotational sweep contents to `RotationalSweep` instance */\n        static parseRotationalSweep(json) {\n            if (json === undefined)\n                return undefined;\n            const contour = Reader.parse(json.contour);\n            const capped = Reader.parseBooleanProperty(json, \"capped\");\n            const axisVector = Reader.parseVector3dProperty(json, \"axis\");\n            const center = Reader.parsePoint3dProperty(json, \"center\");\n            const sweepDegrees = Reader.parseNumberProperty(json, \"sweepAngle\");\n            if (contour instanceof GeometryQuery\n                && \"curveCollection\" === contour.geometryCategory\n                && sweepDegrees !== undefined\n                && capped !== undefined\n                && axisVector\n                && center) {\n                return RotationalSweep.create(contour, Ray3d.createCapture(center, axisVector), Angle.createDegrees(sweepDegrees), capped);\n            }\n            return undefined;\n        }\n        /** Parse box contents to `Box` instance */\n        static parseBox(json) {\n            const capped = Reader.parseBooleanProperty(json, \"capped\", false);\n            // A mismatch between native and TypeScript code: TypeScript used \"origin\" where native used \"baseOrigin\".\n            // Native now outputs and accepts either, preferring \"origin\"; TypeScript continues to expose only \"origin\".\n            const origin = Reader.parsePoint3dProperty(json, \"origin\") ?? Reader.parsePoint3dProperty(json, \"baseOrigin\");\n            const baseX = Reader.parseNumberProperty(json, \"baseX\");\n            const baseY = Reader.parseNumberProperty(json, \"baseY\", baseX);\n            let topOrigin = Reader.parsePoint3dProperty(json, \"topOrigin\");\n            const topX = Reader.parseNumberProperty(json, \"topX\", baseX);\n            const topY = Reader.parseNumberProperty(json, \"topY\", baseY);\n            const height = Reader.parseNumberProperty(json, \"height\", baseX);\n            const axes = Reader.parseOrientation(json, true);\n            if (origin && !topOrigin && height)\n                topOrigin = Matrix3d.xyzPlusMatrixTimesXYZ(origin, axes, Vector3d.create(0, 0, height));\n            if (capped !== undefined\n                && baseX !== undefined\n                && baseY !== undefined\n                && topY !== undefined\n                && topX !== undefined\n                && axes\n                && origin\n                && topOrigin) {\n                return Box.createDgnBoxWithAxes(origin, axes, topOrigin, baseX, baseY, topX, topY, capped);\n            }\n            return undefined;\n        }\n        /** Parse `SphereProps` to `Sphere` instance. */\n        static parseSphere(json) {\n            const center = Reader.parsePoint3dProperty(json, \"center\");\n            // optional unqualified radius . . .\n            const radius = Reader.parseNumberProperty(json, \"radius\");\n            // optional specific X\n            const radiusX = Reader.parseNumberProperty(json, \"radiusX\", radius);\n            // missing Y and Z both pick up radiusX  (which may have already been defaulted from unqualified radius)\n            const radiusY = Reader.parseNumberProperty(json, \"radiusY\", radiusX);\n            const radiusZ = Reader.parseNumberProperty(json, \"radiusZ\", radiusX);\n            const latitudeStartEnd = Reader.parseAngleSweepProps(json, \"latitudeStartEnd\"); // this may be undefined!!\n            const axes = Reader.parseOrientation(json, true);\n            const capped = Reader.parseBooleanProperty(json, \"capped\", false);\n            if (center !== undefined\n                && radiusX !== undefined\n                && radiusY !== undefined\n                && radiusZ !== undefined\n                && capped !== undefined) {\n                return Sphere.createFromAxesAndScales(center, axes, radiusX, radiusY, radiusZ, latitudeStartEnd, capped);\n            }\n            return undefined;\n        }\n        /** Parse RuledSweepProps to RuledSweep instance. */\n        static parseRuledSweep(json) {\n            const capped = Reader.parseBooleanProperty(json, \"capped\", false);\n            const contours = this.loadContourArray(json, \"contour\");\n            if (contours !== undefined\n                && capped !== undefined) {\n                return RuledSweep.create(contours, capped);\n            }\n            return undefined;\n        }\n        /** Parse TorusPipe props to TorusPipe instance. */\n        static parseTorusPipe(json) {\n            const axes = Reader.parseOrientation(json, true); // force frame to be pure rotation (no scale or mirror)!\n            const center = Reader.parsePoint3dProperty(json, \"center\");\n            const radiusA = Reader.parseNumberProperty(json, \"majorRadius\");\n            const radiusB = Reader.parseNumberProperty(json, \"minorRadius\");\n            const sweepAngle = Reader.parseAngleProperty(json, \"sweepAngle\", undefined);\n            const capped = Reader.parseBooleanProperty(json, \"capped\", false);\n            if (center\n                && radiusA !== undefined\n                && radiusB !== undefined) {\n                return TorusPipe.createDgnTorusPipe(center, axes.columnX(), axes.columnY(), radiusA, radiusB, sweepAngle ? sweepAngle : Angle.createDegrees(360), capped);\n            }\n            return undefined;\n        }\n        /** Parse an array object to array of Point3d instances. */\n        static parsePointArray(json) {\n            const points = [];\n            if (json && Array.isArray(json)) {\n                for (const member of json) {\n                    if (XYZ.isXAndY(member)) {\n                        points.push(Point3d.fromJSON(member));\n                    }\n                    else if (Geometry.isNumberArray(member, 2)) {\n                        points.push(Point3d.fromJSON(member));\n                    }\n                }\n            }\n            return points;\n        }\n        /** Deserialize `json` to `GeometryQuery` instances. */\n        static parse(json) {\n            if (json !== undefined && json) {\n                if (json.lineSegment !== undefined) {\n                    return Reader.parseLineSegmentProps(json.lineSegment);\n                }\n                else if (json.lineString !== undefined) {\n                    return LineString3d.create(Reader.parsePointArray(json.lineString));\n                }\n                else if (json.arc !== undefined) {\n                    return Reader.parseArcObject(json.arc);\n                }\n                else if (json.hasOwnProperty(\"point\")) {\n                    return Reader.parseCoordinate(json.point);\n                }\n                else if (json.hasOwnProperty(\"bcurve\")) {\n                    return Reader.parseBcurve(json.bcurve);\n                }\n                else if (json.hasOwnProperty(\"interpolationCurve\")) {\n                    return Reader.parseInterpolationCurve(json.interpolationCurve);\n                }\n                else if (json.hasOwnProperty(\"akimaCurve\")) {\n                    return Reader.parseAkimaCurve3d(json.akimaCurve);\n                }\n                else if (json.hasOwnProperty(\"path\")) {\n                    return Reader.parseCurveCollectionMembers(new Path(), json.path);\n                }\n                else if (json.hasOwnProperty(\"loop\")) {\n                    return Reader.parseCurveCollectionMembers(new Loop(), json.loop);\n                }\n                else if (json.hasOwnProperty(\"parityRegion\")) {\n                    return Reader.parseCurveCollectionMembers(new ParityRegion(), json.parityRegion);\n                }\n                else if (json.hasOwnProperty(\"unionRegion\")) {\n                    return Reader.parseCurveCollectionMembers(new UnionRegion(), json.unionRegion);\n                }\n                else if (json.hasOwnProperty(\"bagOfCurves\")) {\n                    return Reader.parseCurveCollectionMembers(new BagOfCurves(), json.bagOfCurves);\n                }\n                else if (json.hasOwnProperty(\"indexedMesh\")) {\n                    return Reader.parseIndexedMesh(json.indexedMesh);\n                }\n                else if (json.hasOwnProperty(\"bsurf\")) {\n                    return Reader.parseBsurf(json.bsurf);\n                }\n                else if (json.hasOwnProperty(\"cone\")) {\n                    return Reader.parseConeProps(json.cone);\n                }\n                else if (json.hasOwnProperty(\"cylinder\")) {\n                    return Reader.parseCylinderProps(json.cylinder);\n                }\n                else if (json.hasOwnProperty(\"sphere\")) {\n                    return Reader.parseSphere(json.sphere);\n                }\n                else if (json.hasOwnProperty(\"linearSweep\")) {\n                    return Reader.parseLinearSweep(json.linearSweep);\n                }\n                else if (json.hasOwnProperty(\"box\")) {\n                    return Reader.parseBox(json.box);\n                }\n                else if (json.hasOwnProperty(\"rotationalSweep\")) {\n                    return Reader.parseRotationalSweep(json.rotationalSweep);\n                }\n                else if (json.hasOwnProperty(\"ruledSweep\")) {\n                    return Reader.parseRuledSweep(json.ruledSweep);\n                }\n                else if (json.hasOwnProperty(\"torusPipe\")) {\n                    return Reader.parseTorusPipe(json.torusPipe);\n                }\n                else if (json.hasOwnProperty(\"pointString\")) {\n                    return PointString3d.create(Reader.parsePointArray(json.pointString));\n                }\n                else if (json.hasOwnProperty(\"transitionSpiral\")) {\n                    return Reader.parseTransitionSpiral(json.transitionSpiral);\n                }\n                else if (Array.isArray(json))\n                    return Reader.parseArray(json);\n            }\n            return undefined;\n        }\n    }\n    IModelJson.Reader = Reader;\n    // ISSUE: include 3d in names?\n    // ISSUE: would like shorter term than lineSegment\n    // ISSUE: is arc clear?\n    // ISSUE: label center, vectorX, vector90 on arc?\n    // ISSUE: sweep data on arc -- serialize as AngleSweep?\n    /**\n     * Class to deserialize json objects into GeometryQuery objects\n     * @public\n     */\n    class Writer extends GeometryHandler {\n        handleTaggedNumericData(data) {\n            const result = { tagA: data.tagA, tagB: data.tagB };\n            if (data.intData !== undefined && data.intData.length > 0)\n                result.intData = data.intData.slice();\n            if (data.doubleData !== undefined && data.doubleData.length > 0)\n                result.doubleData = data.doubleData.slice();\n            return result;\n        }\n        /** Convert strongly typed instance to tagged json */\n        handleLineSegment3d(data) {\n            return { lineSegment: [data.point0Ref.toJSON(), data.point1Ref.toJSON()] };\n        }\n        /** Convert strongly typed instance to tagged json */\n        handleCoordinateXYZ(data) {\n            return { point: data.point.toJSON() };\n        }\n        /** Convert strongly typed instance to tagged json */\n        handleArc3d(data) {\n            return {\n                arc: {\n                    center: data.center.toJSON(),\n                    vectorX: data.vector0.toJSON(),\n                    vectorY: data.vector90.toJSON(),\n                    sweepStartEnd: [data.sweep.startDegrees, data.sweep.endDegrees],\n                },\n            };\n        }\n        /**\n         * Insert orientation description to a data object.\n         * @param matrix matrix with orientation\n         * @param omitIfIdentity omit the axis data if the matrix is an identity.\n         * @param data AxesProps object to be annotated.\n         */\n        static insertOrientationFromMatrix(data, matrix, omitIfIdentity) {\n            if (omitIfIdentity) {\n                if (matrix === undefined)\n                    return;\n                if (matrix.isIdentity)\n                    return;\n            }\n            if (matrix)\n                data.xyVectors = [matrix.columnX().toJSON(), matrix.columnY().toJSON()];\n            else\n                data.xyVectors = [[1, 0, 0], [0, 1, 0]];\n        }\n        static isIdentityXY(xVector, yVector) {\n            return xVector.isAlmostEqualXYZ(1, 0, 0) && yVector.isAlmostEqualXYZ(0, 1, 0);\n        }\n        /**\n         * Insert orientation description to a data object.\n         * @param matrix matrix with orientation\n         * @param omitIfIdentity omit the axis data if the matrix is an identity.\n         * @param data AxesProps object to be annotated.\n         */\n        static insertOrientationFromXYVectors(data, vectorX, vectorY, omitIfIdentity) {\n            if (omitIfIdentity && Writer.isIdentityXY(vectorX, vectorY))\n                return;\n            data.xyVectors = [vectorX.toJSON(), vectorY.toJSON()];\n        }\n        /**\n         * Insert orientation description to a data object, with orientation defined by u and v direction\n         * vectors.\n         * @param vectorX u direction\n         * @param vectorV v direction\n         * @param omitIfIdentity omit the axis data if the vectorU and vectorV are global x and y vectors.\n         * @param data AxesProps object to be annotated.\n         */\n        static insertXYOrientation(data, vectorU, vectorV, omitIfIdentity) {\n            if (omitIfIdentity) {\n                if (vectorU.isAlmostEqualXYZ(1, 0, 0) && vectorV.isAlmostEqualXYZ(0, 1, 0))\n                    return;\n            }\n            data.xyVectors = [vectorU.toJSON(), vectorV.toJSON()];\n        }\n        /** Parse properties of a TransitionSpiral. */\n        handleTransitionSpiral(data) {\n            // TODO: HANDLE NONRIGID TRANSFORM !!\n            // the spiral may have indication of how it was defined.  If so, use defined/undefined state of the original data\n            // as indication of what current data to use.  (Current data may have changed due to transforms.)\n            if (data instanceof DirectSpiral3d) {\n                const value = {\n                    origin: data.localToWorld.origin.toJSON(),\n                    type: data.spiralType,\n                };\n                Writer.insertOrientationFromMatrix(value, data.localToWorld.matrix, true);\n                if (!data.activeFractionInterval.isExact01)\n                    value.activeFractionInterval = [data.activeFractionInterval.x0, data.activeFractionInterval.x1];\n                // Object.defineProperty(value, \"fractionInterval\", { value: [data.activeFractionInterval.x0, data.activeFractionInterval.x1] });\n                value.startRadius = 0;\n                value.endRadius = data.nominalR1;\n                value.length = data.nominalL1;\n                return { transitionSpiral: value };\n            }\n            else if (data instanceof IntegratedSpiral3d) {\n                // TODO: HANDLE NONRIGID TRANSFORM !!\n                // the spiral may have indication of how it was defined.  If so, use defined/undefined state of the original data\n                // as indication of what current data to use.  (Current data may have changed due to transforms.)\n                const originalProperties = data.designProperties;\n                const value = {\n                    origin: data.localToWorld.origin.toJSON(),\n                    type: data.spiralType,\n                };\n                Writer.insertOrientationFromMatrix(value, data.localToWorld.matrix, true);\n                if (!data.activeFractionInterval.isExact01)\n                    value.activeFractionInterval = [data.activeFractionInterval.x0, data.activeFractionInterval.x1];\n                // Object.defineProperty(value, \"fractionInterval\", { value: [data.activeFractionInterval.x0, data.activeFractionInterval.x1] });\n                // if possible, do selective output of defining data (omit exactly one out of the 5, matching original definition)\n                // EXCEPT do not omit final radius .. readers want it?\n                if (originalProperties !== undefined && originalProperties.numDefinedProperties() === 4) {\n                    if (originalProperties.radius0 !== undefined)\n                        value.startRadius = data.radius01.x0;\n                    if (originalProperties.radius1 !== undefined)\n                        value.endRadius = data.radius01.x1;\n                    if (originalProperties.bearing0 !== undefined)\n                        value.startBearing = data.bearing01.startAngle.toJSON();\n                    if (originalProperties.bearing1 !== undefined)\n                        value.endBearing = data.bearing01.endAngle.toJSON();\n                    if (originalProperties.curveLength !== undefined)\n                        value.length = data.curveLength();\n                    if (value.endRadius === undefined)\n                        value.endRadius = data.radius01.x1;\n                }\n                else {\n                    // uh oh ... no original data, but the spiral itself knows all 5 values.  We don't know which to consider primary.\n                    // DECISION -- put everything out, let readers make sense if they can. (It should be consistent ?)\n                    value.startRadius = data.radius01.x0;\n                    value.endRadius = data.radius01.x1;\n                    value.startBearing = data.bearing01.startAngle.toJSON();\n                    value.endBearing = data.bearing01.endAngle.toJSON();\n                    value.length = data.curveLength();\n                }\n                return { transitionSpiral: value };\n            }\n            return undefined;\n        }\n        /** Convert strongly typed instance to tagged json */\n        handleCone(data) {\n            const radiusA = data.getRadiusA();\n            const radiusB = data.getRadiusB();\n            const centerA = data.getCenterA();\n            const centerB = data.getCenterB();\n            const vectorX = data.getVectorX();\n            const vectorY = data.getVectorY();\n            const axisVector = Vector3d.createStartEnd(centerA, centerB);\n            if (Geometry.isSameCoordinate(radiusA, radiusB)\n                && vectorX.isPerpendicularTo(axisVector)\n                && vectorY.isPerpendicularTo(axisVector)\n                && Geometry.isSameCoordinate(vectorX.magnitude(), 1.0)\n                && Geometry.isSameCoordinate(vectorY.magnitude(), 1.0)) {\n                return {\n                    cylinder: {\n                        capped: data.capped,\n                        start: data.getCenterA().toJSON(),\n                        end: data.getCenterB().toJSON(),\n                        radius: radiusA,\n                    },\n                };\n            }\n            else {\n                const coneProps = {\n                    capped: data.capped,\n                    start: data.getCenterA().toJSON(),\n                    end: data.getCenterB().toJSON(),\n                    startRadius: data.getRadiusA(),\n                    endRadius: data.getRadiusB(),\n                };\n                Writer.insertOrientationFromXYVectors(coneProps, vectorX, vectorY, false);\n                return { cone: coneProps };\n            }\n        }\n        /** Convert strongly typed instance to tagged json */\n        handleSphere(data) {\n            const xData = data.cloneVectorX().normalizeWithLength();\n            const yData = data.cloneVectorY().normalizeWithLength();\n            const zData = data.cloneVectorZ().normalizeWithLength();\n            const latitudeSweep = data.cloneLatitudeSweep();\n            const rX = xData.mag;\n            const rY = yData.mag;\n            const rZ = zData.mag;\n            if (xData.v && zData.v) {\n                const value = {\n                    center: data.cloneCenter().toJSON(),\n                };\n                if (!(data.getConstructiveFrame()).matrix.isIdentity)\n                    value.zxVectors = [zData.v.toJSON(), xData.v.toJSON()];\n                const fullSweep = latitudeSweep.isFullLatitudeSweep;\n                if (data.capped && !fullSweep)\n                    value.capped = data.capped;\n                if (Geometry.isSameCoordinate(rX, rY) && Geometry.isSameCoordinate(rX, rZ))\n                    value.radius = rX;\n                else {\n                    value.radiusX = rX;\n                    value.radiusY = rY;\n                    value.radiusZ = rZ;\n                }\n                if (!fullSweep)\n                    value.latitudeStartEnd = latitudeSweep.toJSON();\n                return { sphere: value };\n            }\n            return undefined;\n        }\n        /** Convert strongly typed instance to tagged json */\n        handleTorusPipe(data) {\n            const vectorX = data.cloneVectorX();\n            const vectorY = data.cloneVectorY();\n            const radiusA = data.getMajorRadius();\n            const radiusB = data.getMinorRadius();\n            const sweep = data.getSweepAngle();\n            if (data.getIsReversed()) {\n                // the TorusPipe was created with negative sweep that was forced positive; restore original values\n                vectorY.scaleInPlace(-1.0);\n                sweep.setRadians(-sweep.radians);\n            }\n            const value = {\n                center: data.cloneCenter().toJSON(),\n                majorRadius: radiusA,\n                minorRadius: radiusB,\n                xyVectors: [vectorX.toJSON(), vectorY.toJSON()],\n            };\n            if (!sweep.isFullCircle) {\n                value.sweepAngle = sweep.degrees;\n                value.capped = data.capped;\n            }\n            return { torusPipe: value };\n        }\n        /** Convert strongly typed instance to tagged json */\n        handleLineString3d(data) {\n            const pointsA = data.points;\n            const pointsB = [];\n            if (pointsA)\n                for (const p of pointsA)\n                    pointsB.push(p.toJSON());\n            return { lineString: pointsB };\n        }\n        /** Convert strongly typed instance to tagged json */\n        handlePointString3d(data) {\n            const pointsA = data.points;\n            const pointsB = [];\n            if (pointsA)\n                for (const p of pointsA)\n                    pointsB.push(p.toJSON());\n            return { pointString: pointsB };\n        }\n        /** Convert strongly typed instance to tagged json */\n        handlePath(data) {\n            return { path: this.collectChildren(data) };\n        }\n        /** Convert strongly typed instance to tagged json */\n        handleLoop(data) {\n            return { loop: this.collectChildren(data) };\n        }\n        /** Convert strongly typed instance to tagged json */\n        handleParityRegion(data) {\n            return { parityRegion: this.collectChildren(data) };\n        }\n        /** Convert strongly typed instance to tagged json */\n        handleUnionRegion(data) {\n            return { unionRegion: this.collectChildren(data) };\n        }\n        /** Convert strongly typed instance to tagged json */\n        handleBagOfCurves(data) {\n            return { bagOfCurves: this.collectChildren(data) };\n        }\n        collectChildren(data) {\n            const children = [];\n            if (data.children && Array.isArray(data.children)) {\n                for (const child of data.children) {\n                    const cdata = child.dispatchToGeometryHandler(this);\n                    if (cdata)\n                        children.push(cdata);\n                }\n            }\n            return children;\n        }\n        /** Convert strongly typed instance to tagged json */\n        handleLinearSweep(data) {\n            const extrusionVector = data.cloneSweepVector();\n            const curves = data.getCurvesRef();\n            const capped = data.capped;\n            if (extrusionVector\n                && curves\n                && capped !== undefined) {\n                return {\n                    linearSweep: {\n                        contour: curves.dispatchToGeometryHandler(this),\n                        capped,\n                        vector: extrusionVector.toJSON(),\n                    },\n                };\n            }\n            return undefined;\n        }\n        /** Convert strongly typed instance to tagged json */\n        handleRuledSweep(data) {\n            const contours = data.cloneContours();\n            const capped = data.capped;\n            if (contours\n                && contours.length > 1\n                && capped !== undefined) {\n                const jsonContours = [];\n                for (const c of contours) {\n                    jsonContours.push(this.emit(c));\n                }\n                return {\n                    ruledSweep: {\n                        contour: jsonContours,\n                        capped,\n                    },\n                };\n            }\n            return undefined;\n        }\n        /** Convert strongly typed instance to tagged json */\n        handleRotationalSweep(data) {\n            const axisRay = data.cloneAxisRay();\n            const curves = data.getCurves();\n            const capped = data.capped;\n            const sweepAngle = data.getSweep();\n            return {\n                rotationalSweep: {\n                    axis: axisRay.direction.toJSON(),\n                    contour: curves.dispatchToGeometryHandler(this),\n                    capped,\n                    center: axisRay.origin.toJSON(),\n                    sweepAngle: sweepAngle.degrees,\n                },\n            };\n        }\n        /** Convert strongly typed instance to tagged json */\n        handleBox(box) {\n            const out = {\n                box: {\n                    origin: box.getBaseOrigin().toJSON(),\n                    baseOrigin: box.getBaseOrigin().toJSON(),\n                    baseX: box.getBaseX(),\n                    baseY: box.getBaseY(),\n                    capped: box.capped,\n                    topOrigin: box.getTopOrigin().toJSON(),\n                },\n            };\n            const outBox = out.box;\n            Writer.insertXYOrientation(outBox, box.getVectorX(), box.getVectorY(), true);\n            if (!Geometry.isSameCoordinate(box.getTopX(), box.getBaseX()))\n                outBox.topX = box.getTopX();\n            if (!Geometry.isSameCoordinate(box.getTopY(), box.getBaseY()))\n                outBox.topY = box.getTopY();\n            return out;\n        }\n        handlePolyfaceAuxData(auxData, pf) {\n            const contents = {};\n            contents.indices = [];\n            const visitor = pf.createVisitor(0);\n            if (!visitor.auxData)\n                return;\n            while (visitor.moveToNextFacet()) {\n                for (let i = 0; i < visitor.indexCount; i++) {\n                    contents.indices.push(visitor.auxData.indices[i] + 1);\n                }\n                contents.indices.push(0); // facet terminator.\n            }\n            contents.channels = [];\n            for (const inChannel of auxData.channels) {\n                const outChannel = {};\n                outChannel.dataType = inChannel.dataType;\n                outChannel.name = inChannel.name;\n                outChannel.inputName = inChannel.inputName;\n                outChannel.data = [];\n                for (const inData of inChannel.data) {\n                    const outData = {};\n                    outData.input = inData.input;\n                    outData.values = inData.values.slice(0);\n                    outChannel.data.push(outData);\n                }\n                contents.channels.push(outChannel);\n            }\n            return contents;\n        }\n        /** Convert strongly typed instance to tagged json */\n        handleIndexedPolyface(pf) {\n            const points = [];\n            const pointIndex = [];\n            const normals = [];\n            const params = [];\n            const colors = [];\n            {\n                const p = Point3d.create();\n                for (let i = 0; pf.data.point.getPoint3dAtCheckedPointIndex(i, p); i++)\n                    points.push(p.toJSON());\n            }\n            if (pf.data.normal) {\n                const numNormal = pf.data.normal.length;\n                const normal = Vector3d.create();\n                for (let i = 0; i < numNormal; i++) {\n                    pf.data.normal.getVector3dAtCheckedVectorIndex(i, normal);\n                    normals.push(normal.toJSON());\n                }\n            }\n            if (pf.data.param) {\n                const uv = Point2d.create();\n                for (let i = 0; pf.data.param.getPoint2dAtCheckedPointIndex(i, uv); i++)\n                    params.push(uv.toJSON());\n            }\n            if (pf.data.color) {\n                for (const value of pf.data.color)\n                    colors.push(value);\n            }\n            const visitor = pf.createVisitor(0);\n            let indexCounter = 0;\n            const normalIndex = [];\n            const paramIndex = [];\n            const colorIndex = [];\n            let n;\n            while (visitor.moveToNextFacet()) {\n                n = visitor.indexCount;\n                // All meshes have point and point index ...\n                for (let i = 0; i < n; i++) {\n                    // Change sign of value to be pushed based on whether or not the edge was originally visible or not\n                    const toPush = pf.data.edgeVisible[indexCounter + i] ? visitor.pointIndex[i] + 1 : -(visitor.clientPointIndex(i) + 1);\n                    pointIndex.push(toPush);\n                }\n                pointIndex.push(0); // facet terminator.\n                indexCounter += visitor.indexCount;\n                if (visitor.normalIndex) {\n                    for (let i = 0; i < n; i++)\n                        normalIndex.push(1 + visitor.clientNormalIndex(i));\n                    normalIndex.push(0);\n                }\n                if (visitor.paramIndex) {\n                    for (let i = 0; i < n; i++)\n                        paramIndex.push(1 + visitor.clientParamIndex(i));\n                    paramIndex.push(0);\n                }\n                if (visitor.colorIndex) {\n                    for (let i = 0; i < n; i++)\n                        colorIndex.push(1 + visitor.clientColorIndex(i));\n                    colorIndex.push(0);\n                }\n            }\n            let taggedNumericData;\n            if (pf.data.taggedNumericData) {\n                taggedNumericData = this.handleTaggedNumericData(pf.data.taggedNumericData);\n            }\n            // assemble the contents in alphabetical order.\n            const contents = {};\n            if (pf.expectedClosure !== 0)\n                contents.expectedClosure = pf.expectedClosure;\n            if (pf.twoSided)\n                contents.twoSided = true;\n            if (pf.data.auxData)\n                contents.auxData = this.handlePolyfaceAuxData(pf.data.auxData, pf);\n            if (pf.data.color)\n                contents.color = colors;\n            if (pf.data.colorIndex)\n                contents.colorIndex = colorIndex;\n            if (pf.data.normal)\n                contents.normal = normals;\n            if (pf.data.normalIndex)\n                contents.normalIndex = normalIndex;\n            if (pf.data.param)\n                contents.param = params;\n            if (pf.data.paramIndex)\n                contents.paramIndex = paramIndex;\n            contents.point = points;\n            contents.pointIndex = pointIndex;\n            if (taggedNumericData)\n                contents.tags = taggedNumericData;\n            return { indexedMesh: contents };\n        }\n        /** Convert strongly typed instance to tagged json */\n        handleBSplineCurve3d(curve) {\n            // ASSUME -- if the curve originated \"closed\" the knot and pole replication are unchanged,\n            // so first and last knots can be re-assigned, and last (degree - 1) poles can be deleted.\n            const wrapMode = curve.isClosable;\n            if (wrapMode === BSplineWrapMode.OpenByAddingControlPoints) {\n                const knots = curve.copyKnots(true);\n                const poles = curve.copyPoints();\n                const degree = curve.degree;\n                for (let i = 0; i < degree; i++)\n                    poles.pop();\n                // knots have replicated first and last.  Change the values to be periodic.\n                const leftIndex = degree;\n                const rightIndex = knots.length - degree - 1;\n                const knotPeriod = knots[rightIndex] - knots[leftIndex];\n                knots[0] = knots[rightIndex - degree] - knotPeriod;\n                knots[knots.length - 1] = knots[leftIndex + degree] + knotPeriod;\n                return {\n                    bcurve: {\n                        points: poles,\n                        knots,\n                        closed: true,\n                        order: curve.order,\n                    },\n                };\n            }\n            else if (curve.isClosable === BSplineWrapMode.OpenByRemovingKnots) {\n                // special case to re-close the case that originated as :    a a0 a0 .. a0 knot0 knot1 knot2 ... b1 b1 .. b1 b\n                // with (order) copies of a0 and b1 (usually 0 and 1)\n                // and a,b are related to the interior knots\n                // (This is the \"bezier saturated arc\")\n                const rawKnots = curve.copyKnots(false); // unchanged knots . . .\n                const poles = curve.copyPoints();\n                const degree = curve.degree;\n                const leftIndex = degree - 1;\n                const rightIndex = rawKnots.length - degree;\n                const leftKnot = rawKnots[leftIndex];\n                const rightKnot = rawKnots[rightIndex];\n                const knotPeriod = rightKnot - leftKnot;\n                const knots = [];\n                knots.push(rawKnots[rightIndex - 1] - knotPeriod);\n                knots.push(leftKnot);\n                for (const k of rawKnots)\n                    knots.push(k);\n                knots.push(rightKnot);\n                knots.push(rawKnots[leftIndex + 1] + knotPeriod);\n                return {\n                    bcurve: {\n                        points: poles,\n                        knots,\n                        closed: true,\n                        order: curve.order,\n                    },\n                };\n            }\n            else {\n                return {\n                    bcurve: {\n                        points: curve.copyPoints(),\n                        knots: curve.copyKnots(true),\n                        closed: false,\n                        order: curve.order,\n                    },\n                };\n            }\n        }\n        /** Convert strongly typed instance to tagged json */\n        handleInterpolationCurve3d(curve) {\n            const props = curve.cloneProps();\n            BSplineCurveOps.C2CubicFit.convertToJsonKnots(props);\n            return { interpolationCurve: props };\n        }\n        /** Convert strongly typed instance to tagged json */\n        handleAkimaCurve3d(curve) {\n            return { akimaCurve: curve.cloneProps() };\n        }\n        /** Convert strongly typed instance to tagged json */\n        handleBezierCurve3d(curve) {\n            const knots = [];\n            const order = curve.order;\n            for (let i = 0; i < order; i++)\n                knots.push(0.0);\n            for (let i = 0; i < order; i++)\n                knots.push(1.0);\n            return {\n                bcurve: {\n                    points: curve.copyPolesAsJsonArray(),\n                    knots,\n                    closed: false,\n                    order: curve.order,\n                },\n            };\n        }\n        /** Convert strongly typed instance to tagged json */\n        handleBSplineCurve3dH(curve) {\n            // ASSUME -- if the curve originated \"closed\" the knot and pole replication are unchanged,\n            // so first and last knots can be re-assigned, and last (degree - 1) poles can be deleted.\n            if (curve.isClosable) {\n                const knots = curve.copyKnots(true);\n                const poles = curve.copyPoints();\n                const degree = curve.degree;\n                for (let i = 0; i < degree; i++)\n                    poles.pop();\n                // knots have replicated first and last.  Change the values to be periodic.\n                const leftIndex = degree;\n                const rightIndex = knots.length - degree - 1;\n                const knotPeriod = knots[rightIndex] - knots[leftIndex];\n                knots[0] = knots[rightIndex - degree] - knotPeriod;\n                knots[knots.length - 1] = knots[leftIndex + degree] + knotPeriod;\n                return {\n                    bcurve: {\n                        points: poles,\n                        knots,\n                        closed: true,\n                        order: curve.order,\n                    },\n                };\n            }\n            else {\n                return {\n                    bcurve: {\n                        points: curve.copyPoints(),\n                        knots: curve.copyKnots(true),\n                        closed: false,\n                        order: curve.order,\n                    },\n                };\n            }\n        }\n        /** Convert strongly typed instance to tagged json */\n        handleBSplineSurface3d(surface) {\n            // ASSUME -- if the curve originated \"closed\" the knot and pole replication are unchanged,\n            // so first and last knots can be re-assigned, and last (degree - 1) poles can be deleted.\n            const periodicU = surface.isClosable(0);\n            const periodicV = surface.isClosable(1);\n            if (periodicU || periodicV) {\n                let numUPoles = surface.numPolesUV(0);\n                let numVPoles = surface.numPolesUV(1);\n                if (periodicU)\n                    numUPoles -= surface.degreeUV(0);\n                if (periodicV)\n                    numVPoles -= surface.degreeUV(1);\n                const xyz = Point3d.create();\n                const grid = [];\n                for (let j = 0; j < numVPoles; j++) {\n                    const stringer = [];\n                    for (let i = 0; i < numUPoles; i++) {\n                        surface.getPoint3dPole(i, j, xyz);\n                        stringer.push([xyz.x, xyz.y, xyz.z]);\n                    }\n                    grid.push(stringer);\n                }\n                return {\n                    bsurf: {\n                        points: grid,\n                        uKnots: surface.copyKnots(0, true),\n                        vKnots: surface.copyKnots(1, true),\n                        orderU: surface.orderUV(0),\n                        orderV: surface.orderUV(1),\n                        closedU: periodicU,\n                        closedV: periodicV,\n                    },\n                };\n            }\n            else {\n                return {\n                    bsurf: {\n                        points: surface.getPointArray(false),\n                        uKnots: surface.copyKnots(0, true),\n                        vKnots: surface.copyKnots(1, true),\n                        orderU: surface.orderUV(0),\n                        orderV: surface.orderUV(1),\n                    },\n                };\n            }\n        }\n        /** Convert strongly typed instance to tagged json */\n        handleBezierCurve3dH(curve) {\n            const knots = [];\n            const order = curve.order;\n            for (let i = 0; i < order; i++)\n                knots.push(0.0);\n            for (let i = 0; i < order; i++)\n                knots.push(1.0);\n            return {\n                bcurve: {\n                    points: curve.copyPolesAsJsonArray(),\n                    knots,\n                    closed: false,\n                    order: curve.order,\n                },\n            };\n        }\n        /** Convert strongly typed instance to tagged json */\n        handleBSplineSurface3dH(surface) {\n            const data = surface.getPointGridJSON();\n            return {\n                bsurf: {\n                    points: data.points,\n                    uKnots: surface.copyKnots(0, true),\n                    vKnots: surface.copyKnots(1, true),\n                    orderU: surface.orderUV(0),\n                    orderV: surface.orderUV(1),\n                },\n            };\n        }\n        /** Convert an array of strongly typed instances to an array of tagged json */\n        emitArray(data) {\n            const members = [];\n            for (const c of data) {\n                const toPush = this.emit(c);\n                members.push(toPush);\n            }\n            return members;\n        }\n        /** Convert GeometryQuery data (array or single instance) to instance to tagged json */\n        emit(data) {\n            if (Array.isArray(data))\n                return this.emitArray(data);\n            if (data instanceof GeometryQuery) {\n                return data.dispatchToGeometryHandler(this);\n            }\n            else if (data instanceof TaggedNumericData) {\n                return this.handleTaggedNumericData(data);\n            }\n            return undefined;\n        }\n        /** One-step static method to create a writer and emit a json object */\n        static toIModelJson(data) {\n            const writer = new Writer();\n            return writer.emit(data);\n        }\n    }\n    IModelJson.Writer = Writer;\n})(IModelJson || (IModelJson = {}));\n//# sourceMappingURL=IModelJsonSchema.js.map",
      "start": 1693508123164,
      "end": 1693508123370,
      "sourcemaps": null
    }
  ]
}
