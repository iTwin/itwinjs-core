{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tile/TileRequest.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tiles\n */\nimport { assert, base64StringToUint8Array, IModelStatus } from \"@itwin/core-bentley\";\nimport { ImageSource } from \"@itwin/core-common\";\nimport { IModelApp } from \"../IModelApp\";\nimport { TileUser } from \"./internal\";\n/** Represents a pending or active request to load the contents of a [[Tile]]. The request coordinates with the [[Tile.requestContent]] to obtain the raw content and\n * [[Tile.readContent]] to convert the result into a [[RenderGraphic]]. TileRequests are created internally as needed; it is never necessary or useful for external code to create them.\n * @public\n * @extensions\n */\nexport class TileRequest {\n    /** Constructor */\n    constructor(tile, user) {\n        /** Determines the order in which pending requests are pulled off the queue to become active. A tile with a lower priority value takes precedence over one with a higher value. */\n        this.priority = 0;\n        this._state = TileRequest.State.Queued;\n        this.tile = tile;\n        this.channel = tile.channel;\n        this.users = IModelApp.tileAdmin.getTileUserSetForRequest(user);\n    }\n    /** The set of [[Viewport]]s that are awaiting the result of this request. When this becomes empty, the request is canceled because no user cares about it. */\n    get viewports() {\n        return TileUser.viewportsFromUsers(this.users);\n    }\n    /** The request's current state. */\n    get state() { return this._state; }\n    /** True if the request has been enqueued but not yet dispatched. */\n    get isQueued() { return TileRequest.State.Queued === this._state; }\n    /** True if the request has been canceled. */\n    get isCanceled() {\n        // If iModel was closed, cancel immediately\n        if (this.tile.iModel.tiles.isDisposed)\n            return true;\n        // After we've received the raw tile data, always finish processing it - otherwise tile may end up in limbo (and producing tile content should be faster than re-requesting raw data).\n        if (TileRequest.State.Loading === this._state)\n            return false;\n        // If no user cares about this tile any more, we're canceled.\n        return this.users.isEmpty;\n    }\n    /** The tile tree to which the requested [[Tile]] belongs. */\n    get tree() { return this.tile.tree; }\n    /** Indicate that the specified user is awaiting the result of this request.\n     * @internal\n     */\n    addUser(user) {\n        this.users = IModelApp.tileAdmin.getTileUserSetForRequest(user, this.users);\n    }\n    /** Transition the request from \"queued\" to \"active\", kicking off a series of asynchronous operations usually beginning with an http request, and -\n     * if the request is not subsequently canceled - resulting in either a successfully-loaded Tile, or a failed (\"not found\") Tile.\n     * @internal\n     */\n    async dispatch(onHttpResponse) {\n        if (this.isCanceled)\n            return;\n        assert(this._state === TileRequest.State.Queued);\n        this._state = TileRequest.State.Dispatched;\n        let response;\n        let gotResponse = false;\n        try {\n            response = await this.channel.requestContent(this.tile, () => this.isCanceled);\n            gotResponse = true;\n            // Set this now, so our `isCanceled` check can see it.\n            this._state = TileRequest.State.Loading;\n        }\n        catch (err) {\n            if (err.errorNumber && err.errorNumber === IModelStatus.ServerTimeout) {\n                // Invalidate scene - if tile is re-selected, it will be re-requested.\n                this.notifyAndClear();\n                this._state = TileRequest.State.Failed;\n                this.channel.recordTimeout();\n            }\n            else {\n                // Unknown error - not retryable\n                this.setFailed();\n            }\n        }\n        // Notify caller that we have finished http activity.\n        onHttpResponse();\n        if (!gotResponse || this.isCanceled)\n            return;\n        if (undefined === response && this.channel.onNoContent(this)) {\n            // Invalidate scene - if tile is re-selected, it will be re-requested - presumably via a different channel.\n            this.notifyAndClear();\n            this._state = TileRequest.State.Failed;\n            return;\n        }\n        return this.handleResponse(response);\n    }\n    /** Cancels this request. This leaves the associated Tile's state untouched.\n     * @internal\n     */\n    cancel() {\n        this.notifyAndClear();\n        if (TileRequest.State.Dispatched === this._state)\n            this.channel.onActiveRequestCanceled(this);\n        this._state = TileRequest.State.Failed;\n    }\n    /** Invalidates the scene of each [[TileUser]] interested in this request - typically because the request succeeded, failed, or was canceled. */\n    notify() {\n        this.users.forEach((user) => {\n            if (user.onRequestStateChanged)\n                user.onRequestStateChanged(this);\n        });\n    }\n    /** Invalidates the scene of each [[TileUser]] interested in this request and clears the set of interested users. */\n    notifyAndClear() {\n        this.notify();\n        this.users = IModelApp.tileAdmin.emptyTileUserSet;\n        this.tile.request = undefined;\n    }\n    setFailed() {\n        this.notifyAndClear();\n        this._state = TileRequest.State.Failed;\n        this.tile.setNotFound();\n        this.channel.recordFailure();\n    }\n    /** Invoked when the raw tile content becomes available, to convert it into a tile graphic. */\n    async handleResponse(response) {\n        let content;\n        let data;\n        if (undefined !== response) {\n            if (typeof response === \"string\")\n                data = base64StringToUint8Array(response);\n            else if (response instanceof Uint8Array || response instanceof ImageSource)\n                data = response;\n            else if (response instanceof ArrayBuffer)\n                data = new Uint8Array(response);\n            else if (typeof response === \"object\") {\n                if (\"content\" in response)\n                    content = response.content;\n                else if (\"data\" in response)\n                    data = response;\n            }\n        }\n        if (!content && !data) {\n            this.setFailed();\n            return;\n        }\n        try {\n            const start = Date.now();\n            if (!content) {\n                assert(undefined !== data);\n                content = await this.tile.readContent(data, IModelApp.renderSystem, () => this.isCanceled);\n                if (this.isCanceled)\n                    return;\n            }\n            this._state = TileRequest.State.Completed;\n            this.tile.setContent(content);\n            this.notifyAndClear();\n            this.channel.recordCompletion(this.tile, content, Date.now() - start);\n        }\n        catch (_err) {\n            this.setFailed();\n        }\n    }\n}\n/** @public */\n(function (TileRequest) {\n    /** The states through which a [[TileRequest]] proceeds. During the first 3 states, the [[Tile]]'s `request` member is defined,\n     * and its [[Tile.LoadStatus]] is computed based on the state of its request.\n     *@ public\n     */\n    let State;\n    (function (State) {\n        /** Initial state. Request is pending but not yet dispatched. */\n        State[State[\"Queued\"] = 0] = \"Queued\";\n        /** Follows `Queued` when request begins to be actively processed. */\n        State[State[\"Dispatched\"] = 1] = \"Dispatched\";\n        /** Follows `Dispatched` when the response to the request is being converted into tile graphics. */\n        State[State[\"Loading\"] = 2] = \"Loading\";\n        /** Follows `Loading` when tile graphic has successfully been produced. */\n        State[State[\"Completed\"] = 3] = \"Completed\";\n        /** Follows any state in which an error prevents progression, or during which the request was canceled. */\n        State[State[\"Failed\"] = 4] = \"Failed\";\n    })(State = TileRequest.State || (TileRequest.State = {}));\n})(TileRequest || (TileRequest = {}));\n//# sourceMappingURL=TileRequest.js.map",
      "start": 1693508121572,
      "end": 1693508121713,
      "sourcemaps": null
    }
  ]
}
