{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/primitives/Primitives.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Rendering\n */\nimport { assert, SortedArray } from \"@itwin/core-bentley\";\n/** @internal */\nexport var ToleranceRatio;\n(function (ToleranceRatio) {\n    ToleranceRatio.vertex = 0.1;\n    ToleranceRatio.facetArea = 0.1;\n})(ToleranceRatio || (ToleranceRatio = {}));\n/** Specifies under what circumstances a GeometryAccumulator should generate normals.\n * @internal\n */\nexport var NormalMode;\n(function (NormalMode) {\n    NormalMode[NormalMode[\"Never\"] = 0] = \"Never\";\n    NormalMode[NormalMode[\"Always\"] = 1] = \"Always\";\n    NormalMode[NormalMode[\"CurvedSurfacesOnly\"] = 2] = \"CurvedSurfacesOnly\";\n})(NormalMode || (NormalMode = {}));\n/** @internal */\nexport var SurfacesOnly;\n(function (SurfacesOnly) {\n    SurfacesOnly[SurfacesOnly[\"Yes\"] = 1] = \"Yes\";\n    SurfacesOnly[SurfacesOnly[\"No\"] = 0] = \"No\";\n})(SurfacesOnly || (SurfacesOnly = {})); // Yes indicates polylines will not be generated, only meshes.\n/** @internal */\nexport var PreserveOrder;\n(function (PreserveOrder) {\n    PreserveOrder[PreserveOrder[\"Yes\"] = 1] = \"Yes\";\n    PreserveOrder[PreserveOrder[\"No\"] = 0] = \"No\";\n})(PreserveOrder || (PreserveOrder = {})); // Yes indicates primitives will not be merged, and the order in which they were added to the GraphicBuilder will be preserved.\n/** @internal */\nexport var GenerateEdges;\n(function (GenerateEdges) {\n    GenerateEdges[GenerateEdges[\"Yes\"] = 1] = \"Yes\";\n    GenerateEdges[GenerateEdges[\"No\"] = 0] = \"No\";\n})(GenerateEdges || (GenerateEdges = {})); // Yes indicates edges will be generated for surfaces\n/** @internal */\nexport class GeometryOptions {\n    constructor(edges, normals = NormalMode.Always, surfaces = SurfacesOnly.No, preserveOrder = PreserveOrder.No) {\n        this.normals = normals;\n        this.surfaces = surfaces;\n        this.preserveOrder = preserveOrder;\n        this.edges = edges;\n    }\n    get wantSurfacesOnly() { return this.surfaces === SurfacesOnly.Yes; }\n    get wantPreserveOrder() { return this.preserveOrder === PreserveOrder.Yes; }\n    get wantEdges() { return this.edges === GenerateEdges.Yes; }\n    static createForGraphicBuilder(params, normals = NormalMode.Always, surfaces = SurfacesOnly.No) {\n        return new GeometryOptions(params.wantEdges ? GenerateEdges.Yes : GenerateEdges.No, normals, surfaces, params.preserveOrder ? PreserveOrder.Yes : PreserveOrder.No);\n    }\n}\n/** @internal */\nexport class Triangle {\n    constructor(singleSided = true) {\n        this.indices = new Uint32Array(3);\n        this.visible = [true, true, true];\n        this.singleSided = singleSided;\n    }\n    setIndices(a, b, c) {\n        this.indices[0] = a;\n        this.indices[1] = b;\n        this.indices[2] = c;\n    }\n    setEdgeVisibility(a, b, c) {\n        this.visible[0] = a;\n        this.visible[1] = b;\n        this.visible[2] = c;\n    }\n    isEdgeVisible(index) {\n        assert(index < 3 && index >= 0);\n        return this.visible[index];\n    }\n    get isDegenerate() { return this.indices[0] === this.indices[1] || this.indices[0] === this.indices[2] || this.indices[1] === this.indices[2]; }\n}\n/** @internal */\nexport class TriangleList {\n    constructor() {\n        this._flags = [];\n        this.indices = [];\n    }\n    get length() { return this._flags.length; }\n    get isEmpty() { return 0 === this.length; }\n    addTriangle(triangle) {\n        let flags = triangle.singleSided ? 1 : 0;\n        for (let i = 0; i < 3; i++) {\n            if (triangle.isEdgeVisible(i))\n                flags |= (0x0002 << i);\n            this.indices.push(triangle.indices[i]);\n        }\n        this._flags.push(flags);\n    }\n    addFromTypedArray(indices, flags = 0) {\n        for (let i = 0; i < indices.length;) {\n            this.indices.push(indices[i++]);\n            this.indices.push(indices[i++]);\n            this.indices.push(indices[i++]);\n            this._flags.push(flags);\n        }\n    }\n    getTriangle(index, out) {\n        const triangle = undefined !== out ? out : new Triangle();\n        if (index > this.length) {\n            assert(false);\n            return new Triangle();\n        }\n        const flags = this._flags[index];\n        triangle.singleSided = 0 !== (flags & 0x0001);\n        const baseIndex = index * 3;\n        for (let i = 0; i < 3; i++) {\n            triangle.indices[i] = this.indices[baseIndex + i];\n            triangle.visible[i] = 0 !== (flags & 0x0002 << i);\n        }\n        return triangle;\n    }\n}\n/** @internal */\nexport class TriangleKey {\n    constructor(triangle) {\n        this._sortedIndices = new Uint32Array(3);\n        const index = triangle.indices;\n        const sorted = this._sortedIndices;\n        if (index[0] < index[1]) {\n            if (index[0] < index[2]) {\n                sorted[0] = index[0];\n                if (index[1] < index[2]) {\n                    sorted[1] = index[1];\n                    sorted[2] = index[2];\n                }\n                else {\n                    sorted[1] = index[2];\n                    sorted[2] = index[1];\n                }\n            }\n            else {\n                sorted[0] = index[2];\n                sorted[1] = index[0];\n                sorted[2] = index[1];\n            }\n        }\n        else {\n            if (index[1] < index[2]) {\n                sorted[0] = index[1];\n                if (index[0] < index[2]) {\n                    sorted[1] = index[0];\n                    sorted[2] = index[2];\n                }\n                else {\n                    sorted[1] = index[2];\n                    sorted[2] = index[0];\n                }\n            }\n            else {\n                sorted[0] = index[2];\n                sorted[1] = index[1];\n                sorted[2] = index[0];\n            }\n        }\n        assert(sorted[0] < sorted[1]);\n        assert(sorted[1] < sorted[2]);\n    }\n    compare(rhs) {\n        let diff = 0;\n        for (let i = 0; i < 3; i++) {\n            diff = this._sortedIndices[i] - rhs._sortedIndices[i];\n            if (0 !== diff)\n                break;\n        }\n        return diff;\n    }\n}\n/** @internal */\nexport class TriangleSet extends SortedArray {\n    constructor() {\n        super((lhs, rhs) => lhs.compare(rhs));\n    }\n    insertKey(triangle, onInsert) {\n        return this.insert(new TriangleKey(triangle), onInsert);\n    }\n}\n//# sourceMappingURL=Primitives.js.map",
      "start": 1693508119651,
      "end": 1693508119725,
      "sourcemaps": null
    }
  ]
}
