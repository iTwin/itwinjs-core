{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tile/I3dmReader.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tiles\n */\nimport { JsonUtils, utf8ToString } from \"@itwin/core-bentley\";\nimport { AxisOrder, Matrix3d, Point3d, Vector3d } from \"@itwin/core-geometry\";\nimport { Feature, FeatureTable, I3dmHeader, TileReadStatus } from \"@itwin/core-common\";\nimport { GltfReader, GltfReaderProps } from \"./internal\";\nfunction setTransform(transforms, index, rotation, origin) {\n    const i = index * 12;\n    let rot = rotation.coffs;\n    const ignoreRotation = false;\n    if (ignoreRotation)\n        rot = new Float64Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);\n    const ignoreOrigin = false;\n    if (ignoreOrigin)\n        origin.x = origin.y = origin.z = 0;\n    transforms[i + 0] = rot[0];\n    transforms[i + 1] = rot[1];\n    transforms[i + 2] = rot[2];\n    transforms[i + 3] = origin.x;\n    transforms[i + 4] = rot[3];\n    transforms[i + 5] = rot[4];\n    transforms[i + 6] = rot[5];\n    transforms[i + 7] = origin.y;\n    transforms[i + 8] = rot[6];\n    transforms[i + 9] = rot[7];\n    transforms[i + 10] = rot[8];\n    transforms[i + 11] = origin.z;\n}\n/**\n * Deserializes a tile in [i3dm](https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/specification/TileFormats/Instanced3DModel) format.\n * @internal\n */\nexport class I3dmReader extends GltfReader {\n    static create(stream, iModel, modelId, is3d, range, system, yAxisUp, isLeaf, isCanceled, idMap, deduplicateVertices = false) {\n        const header = new I3dmHeader(stream);\n        if (!header.isValid)\n            return undefined;\n        const props = GltfReaderProps.create(stream.nextBytes(header.length - stream.curPos), yAxisUp);\n        if (undefined === props)\n            return undefined;\n        stream.curPos = header.featureTableJsonPosition;\n        const featureStr = utf8ToString(stream.nextBytes(header.featureTableJsonLength));\n        if (undefined === featureStr)\n            return undefined;\n        const featureBinary = new Uint8Array(stream.arrayBuffer, header.featureTableJsonPosition + header.featureTableJsonLength, header.featureTableBinaryLength);\n        return new I3dmReader(featureBinary, JSON.parse(featureStr), header.batchTableJson, props, iModel, modelId, is3d, system, range, isLeaf, isCanceled, idMap, deduplicateVertices);\n    }\n    constructor(_featureBinary, _featureJson, _batchTableJson, props, iModel, modelId, is3d, system, _range, _isLeaf, shouldAbort, _idMap, deduplicateVertices = false) {\n        super({\n            props, iModel, system, shouldAbort, deduplicateVertices,\n            is2d: !is3d,\n        });\n        this._featureBinary = _featureBinary;\n        this._featureJson = _featureJson;\n        this._batchTableJson = _batchTableJson;\n        this._range = _range;\n        this._isLeaf = _isLeaf;\n        this._idMap = _idMap;\n        this._instanceCount = 0;\n        this._modelId = modelId;\n    }\n    async read() {\n        this._instanceCount = JsonUtils.asInt(this._featureJson.INSTANCES_LENGTH, 0);\n        // NB: For reality models with no batch table, we want the model ID in the feature table\n        this._featureTable = new FeatureTable(undefined === this._batchTableJson ? this._instanceCount : 1, this._modelId, this._type);\n        if (this._idMap !== undefined && this._batchTableJson !== undefined) {\n            for (let i = 0; i < this._instanceCount; i++) {\n                const feature = {};\n                for (const key in this._batchTableJson) // eslint-disable-line guard-for-in\n                    feature[key] = this._batchTableJson[key][i];\n                this._featureTable.insert(new Feature(this._idMap.getBatchId(feature)));\n            }\n        }\n        else {\n            // NB: For reality models with no batch table, we want the model ID in the feature table\n            const feature = new Feature(this._modelId);\n            this._featureTable.insert(feature);\n        }\n        await this.resolveResources();\n        if (this._isCanceled)\n            return { readStatus: TileReadStatus.Canceled, isLeaf: this._isLeaf };\n        const instances = this.readInstances();\n        if (undefined === instances)\n            return { readStatus: TileReadStatus.InvalidTileData, isLeaf: this._isLeaf };\n        return this.readGltfAndCreateGraphics(this._isLeaf, this._featureTable, this._range, undefined, undefined, instances);\n    }\n    readFeatures(_features, _json) {\n        return false;\n    }\n    readInstances() {\n        const count = JsonUtils.asInt(this._featureJson.INSTANCES_LENGTH, 0);\n        if (count <= 0)\n            return undefined;\n        const json = this._featureJson;\n        const binary = this._featureBinary;\n        const batchIds = json.BATCH_ID ? new Int32Array(binary.buffer, binary.byteOffset + json.BATCH_ID.byteOffset, count) : undefined;\n        const positions = json.POSITION ? new Float32Array(binary.buffer, binary.byteOffset + json.POSITION.byteOffset, count * 3) : undefined;\n        const upNormals = json.NORMAL_UP ? new Float32Array(binary.buffer, binary.byteOffset + json.NORMAL_UP.byteOffset, count * 3) : undefined;\n        const rightNormals = json.NORMAL_RIGHT ? new Float32Array(binary.buffer, binary.byteOffset + json.NORMAL_RIGHT.byteOffset, count * 3) : undefined;\n        const scales = json.SCALE ? new Float32Array(binary.buffer, binary.byteOffset + json.SCALE.byteOffset, count) : undefined;\n        const nonUniformScales = json.SCALE_NON_UNIFORM ? new Float32Array(binary.buffer, binary.byteOffset + json.SCALE_NON_UNIFORM.byteOffset, count * 3) : undefined;\n        const matrix = Matrix3d.createIdentity();\n        const position = Point3d.createZero();\n        const upNormal = Vector3d.create(0, 0, 1);\n        const rightNormal = Vector3d.create(1, 0, 0);\n        const scale = Vector3d.create(1, 1, 1);\n        const transformCenter = this._range.center;\n        const transforms = new Float32Array(12 * count);\n        for (let i = 0; i < count; i++) {\n            const index = i * 3;\n            if (positions)\n                position.set(positions[index] - transformCenter.x, positions[index + 1] - transformCenter.y, positions[index + 2] - transformCenter.z);\n            if (upNormals || rightNormals) {\n                if (upNormals)\n                    upNormal.set(upNormals[index], upNormals[index + 1], upNormals[index + 2]);\n                if (rightNormals)\n                    rightNormal.set(rightNormals[index], rightNormals[index + 1], rightNormals[index + 2]);\n                if (scales)\n                    scale.x = scale.y = scale.z = scales[i];\n                if (nonUniformScales) {\n                    scale.x *= nonUniformScales[index + 0];\n                    scale.y *= nonUniformScales[index + 1];\n                    scale.z *= nonUniformScales[index + 2];\n                }\n                Matrix3d.createRigidFromColumns(rightNormal, upNormal, AxisOrder.XYZ, matrix);\n                if (scales || nonUniformScales)\n                    matrix.scaleColumnsInPlace(scale.x, scale.y, scale.z);\n                setTransform(transforms, i, matrix, position);\n            }\n        }\n        let featureIds;\n        if (undefined !== batchIds) {\n            featureIds = new Uint8Array(3 * batchIds.length);\n            for (let i = 0, j = 0; i < batchIds.length; i++) {\n                const batchId = batchIds[i];\n                featureIds[j++] = batchId & 0x000000ff;\n                featureIds[j++] = (batchId & 0x0000ff00) >> 8;\n                featureIds[j++] = (batchId & 0x00ff0000) >> 16;\n            }\n        }\n        const symbologyOverrides = undefined;\n        return { count, transforms, symbologyOverrides, featureIds, transformCenter };\n    }\n}\n//# sourceMappingURL=I3dmReader.js.map",
      "start": 1693508121616,
      "end": 1693508121781,
      "sourcemaps": null
    }
  ]
}
