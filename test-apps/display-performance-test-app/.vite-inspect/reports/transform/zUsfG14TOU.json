{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/common/lib/esm/ThematicDisplay.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Symbology\n */\nimport { compareNumbers } from \"@itwin/core-bentley\";\nimport { Point3d, Range1d, Vector3d } from \"@itwin/core-geometry\";\nimport { ColorDef } from \"./ColorDef\";\nimport { Gradient } from \"./Gradient\";\n/** A thematic gradient mode used to generate and apply a thematic effect to a scene.\n * @see [[ThematicGradientSettings.mode]]\n * @public\n * @extensions\n */\nexport var ThematicGradientMode;\n(function (ThematicGradientMode) {\n    /** Apply a smooth color gradient to the scene. */\n    ThematicGradientMode[ThematicGradientMode[\"Smooth\"] = 0] = \"Smooth\";\n    /** Apply a stepped color gradient to the scene. */\n    ThematicGradientMode[ThematicGradientMode[\"Stepped\"] = 1] = \"Stepped\";\n    /** Apply a stepped color gradient to the scene with delimiters (lines between the color steps). Can only be used with [[ThematicDisplayMode.Height]]. */\n    ThematicGradientMode[ThematicGradientMode[\"SteppedWithDelimiter\"] = 2] = \"SteppedWithDelimiter\";\n    /** Apply isolines to the scene to achieve an effect similar to a contour map. Can only be used with [[ThematicDisplayMode.Height]]. */\n    ThematicGradientMode[ThematicGradientMode[\"IsoLines\"] = 3] = \"IsoLines\";\n})(ThematicGradientMode || (ThematicGradientMode = {}));\n/** A color scheme used to generate the colors of a thematic gradient within an applied range.\n * @see [[ThematicGradientSettings.colorScheme]]\n * @see [[ThematicDisplay.range]]\n * @public\n * @extensions\n */\nexport var ThematicGradientColorScheme;\n(function (ThematicGradientColorScheme) {\n    /** A color gradient scheme that represents a blue-to-red gradation. */\n    ThematicGradientColorScheme[ThematicGradientColorScheme[\"BlueRed\"] = 0] = \"BlueRed\";\n    /** A color gradient scheme that represents a red-to-blue gradation. */\n    ThematicGradientColorScheme[ThematicGradientColorScheme[\"RedBlue\"] = 1] = \"RedBlue\";\n    /** A color gradient scheme that represents a monochrome (black-to-white) gradation. */\n    ThematicGradientColorScheme[ThematicGradientColorScheme[\"Monochrome\"] = 2] = \"Monochrome\";\n    /** A color gradient scheme that suits a topographic gradation. */\n    ThematicGradientColorScheme[ThematicGradientColorScheme[\"Topographic\"] = 3] = \"Topographic\";\n    /** A color gradient scheme that suits a sea-mountain gradation. */\n    ThematicGradientColorScheme[ThematicGradientColorScheme[\"SeaMountain\"] = 4] = \"SeaMountain\";\n    /** A custom color gradient scheme configured by the user.\n     * @see [[ThematicGradientSettings.customKeys]]\n     */\n    ThematicGradientColorScheme[ThematicGradientColorScheme[\"Custom\"] = 5] = \"Custom\";\n})(ThematicGradientColorScheme || (ThematicGradientColorScheme = {}));\n/** Thematic settings specific to creating a color gradient used by [[ThematicDisplay]].\n * @public\n */\nclass ThematicGradientSettings {\n    static get margin() { return .001; } // A fixed portion of the gradient for out of range values.\n    static get contentRange() { return 1.0 - 2.0 * ThematicGradientSettings.margin; }\n    static get contentMax() { return 1.0 - ThematicGradientSettings.margin; }\n    equals(other) {\n        if (this.mode !== other.mode)\n            return false;\n        if (this.stepCount !== other.stepCount)\n            return false;\n        if (!this.marginColor.equals(other.marginColor))\n            return false;\n        if (this.colorScheme !== other.colorScheme)\n            return false;\n        if (this.customKeys.length !== other.customKeys.length)\n            return false;\n        if (this.colorMix !== other.colorMix)\n            return false;\n        for (let i = 0; i < this.customKeys.length; i++) {\n            if (!Gradient.keyColorEquals(this.customKeys[i], other.customKeys[i]))\n                return false;\n        }\n        return true;\n    }\n    /** Compares two sets of thematic gradient settings.\n     * @param lhs First set of thematic gradient settings to compare\n     * @param rhs Second set of thematic gradient settings to compare\n     * @returns 0 if lhs is equivalent to rhs, a negative number if lhs compares less than rhs, or a positive number if lhs compares greater than rhs.\n     */\n    static compare(lhs, rhs) {\n        let diff = 0;\n        if ((diff = compareNumbers(lhs.mode, rhs.mode)) !== 0)\n            return diff;\n        if ((diff = compareNumbers(lhs.stepCount, rhs.stepCount)) !== 0)\n            return diff;\n        if ((diff = compareNumbers(lhs.marginColor.tbgr, rhs.marginColor.tbgr)) !== 0)\n            return diff;\n        if ((diff = compareNumbers(lhs.colorScheme, rhs.colorScheme)) !== 0)\n            return diff;\n        if ((diff = compareNumbers(lhs.colorMix, rhs.colorMix)) !== 0)\n            return diff;\n        if ((diff = compareNumbers(lhs.customKeys.length, rhs.customKeys.length)) !== 0)\n            return diff;\n        for (let i = 0; i < lhs.customKeys.length; i++) {\n            if ((diff = compareNumbers(lhs.customKeys[i].color.tbgr, rhs.customKeys[i].color.tbgr)) !== 0)\n                return diff;\n        }\n        return diff;\n    }\n    constructor(json) {\n        this.customKeys = [];\n        if (undefined === json) {\n            this.mode = ThematicGradientMode.Smooth;\n            this.stepCount = 10;\n            this.marginColor = ColorDef.fromJSON();\n            this.colorScheme = ThematicGradientColorScheme.BlueRed;\n            this.colorMix = 0.0;\n        }\n        else {\n            this.mode = (json.mode !== undefined && json.mode !== null) ? json.mode : ThematicGradientMode.Smooth;\n            if (this.mode < ThematicGradientMode.Smooth || this.mode > ThematicGradientMode.IsoLines)\n                this.mode = ThematicGradientMode.Smooth;\n            this.stepCount = (typeof json.stepCount === \"number\") ? json.stepCount : 10;\n            if (this.stepCount < 2)\n                this.stepCount = 2;\n            this.marginColor = ColorDef.fromJSON(json.marginColor);\n            this.colorScheme = (json.colorScheme !== undefined && json.colorScheme !== null) ? json.colorScheme : ThematicGradientColorScheme.BlueRed;\n            if (this.colorScheme < ThematicGradientColorScheme.BlueRed || this.colorScheme > ThematicGradientColorScheme.Custom)\n                this.colorScheme = ThematicGradientColorScheme.BlueRed;\n            if (json.customKeys !== undefined && json.customKeys !== null)\n                json.customKeys.forEach((key) => this.customKeys.push(new Gradient.KeyColor(key)));\n            // Enforce 2 entries in custom color keys if violated\n            if (this.colorScheme === ThematicGradientColorScheme.Custom && this.customKeys.length < 2) {\n                this.customKeys = [];\n                for (const keyValue of ThematicGradientSettings._defaultCustomKeys)\n                    this.customKeys.push(new Gradient.KeyColor({ value: keyValue[0], color: ColorDef.computeTbgrFromComponents(keyValue[1], keyValue[3], keyValue[2]) }));\n            }\n            this.colorMix = json.colorMix ?? 0.0;\n        }\n    }\n    static fromJSON(json) {\n        return json ? new ThematicGradientSettings(json) : this.defaults;\n    }\n    toJSON() {\n        const props = {};\n        if (ThematicGradientMode.Smooth !== this.mode)\n            props.mode = this.mode;\n        if (10 !== this.stepCount)\n            props.stepCount = this.stepCount;\n        const marginColor = this.marginColor.toJSON();\n        if (0 !== marginColor)\n            props.marginColor = marginColor;\n        if (ThematicGradientColorScheme.BlueRed !== this.colorScheme)\n            props.colorScheme = this.colorScheme;\n        if (0 !== this.colorMix)\n            props.colorMix = this.colorMix;\n        if (this.customKeys.length > 0)\n            props.customKeys = this.customKeys.map((key) => { return { value: key.value, color: key.color.toJSON() }; });\n        return props;\n    }\n    /** Create a copy of this ThematicGradientSettings, optionally modifying some of its properties.\n     * @param changedProps JSON representation of the properties to change.\n     * @returns A ThematicGradientSettings with all of its properties set to match those of `this`, except those explicitly defined in `changedProps`.\n     */\n    clone(changedProps) {\n        if (undefined === changedProps)\n            return ThematicGradientSettings.fromJSON(this.toJSON());\n        const props = {\n            mode: undefined !== changedProps.mode ? changedProps.mode : this.mode,\n            stepCount: undefined !== changedProps.stepCount ? changedProps.stepCount : this.stepCount,\n            marginColor: undefined !== changedProps.marginColor ? changedProps.marginColor : this.marginColor.tbgr,\n            colorScheme: undefined !== changedProps.colorScheme ? changedProps.colorScheme : this.colorScheme,\n            customKeys: undefined !== changedProps.customKeys ? changedProps.customKeys : this.customKeys.map((key) => ({ value: key.value, color: key.color.tbgr })),\n            colorMix: undefined !== changedProps.colorMix ? changedProps.colorMix : this.colorMix,\n        };\n        return ThematicGradientSettings.fromJSON(props);\n    }\n}\nThematicGradientSettings.defaults = new ThematicGradientSettings({});\nThematicGradientSettings._defaultCustomKeys = [[0.0, 255, 255, 255], [1.0, 0, 0, 0]];\nexport { ThematicGradientSettings };\n/** A sensor in world space, used for [[ThematicDisplayMode.InverseDistanceWeightedSensors]].\n * @public\n */\nexport class ThematicDisplaySensor {\n    constructor(json) {\n        if (undefined === json) {\n            this.position = Point3d.fromJSON();\n            this.value = 0;\n        }\n        else {\n            this.position = Point3d.fromJSON(json.position);\n            this.value = (typeof json.value !== \"number\") ? 0 : json.value;\n            if (this.value < 0)\n                this.value = 0;\n            else if (this.value > 1)\n                this.value = 1;\n        }\n    }\n    equals(other) {\n        return (this.value === other.value) && this.position.isAlmostEqual(other.position);\n    }\n    static fromJSON(json) {\n        return new ThematicDisplaySensor(json);\n    }\n    toJSON() {\n        return {\n            position: this.position.toJSON(),\n            value: this.value,\n        };\n    }\n}\n/** Settings for sensor-based thematic display for [[ThematicDisplayMode.InverseDistanceWeightedSensors]].\n * @public\n */\nexport class ThematicDisplaySensorSettings {\n    constructor(json) {\n        this.sensors = [];\n        if (undefined !== json) {\n            if (json.sensors !== undefined && json.sensors !== null) {\n                json.sensors.forEach((sensorJSON) => this.sensors.push(ThematicDisplaySensor.fromJSON(sensorJSON)));\n            }\n            this.distanceCutoff = (typeof json.distanceCutoff === \"number\") ? json.distanceCutoff : 0;\n        }\n        else {\n            this.distanceCutoff = 0;\n        }\n    }\n    equals(other) {\n        if (this.distanceCutoff !== other.distanceCutoff)\n            return false;\n        const thisSensors = this.sensors;\n        const otherSensors = other.sensors;\n        if (thisSensors.length !== otherSensors.length)\n            return false;\n        for (let i = 0; i < thisSensors.length; i++) {\n            if (!thisSensors[i].equals(otherSensors[i]))\n                return false;\n        }\n        return true;\n    }\n    static fromJSON(json) {\n        return new ThematicDisplaySensorSettings(json);\n    }\n    toJSON() {\n        const json = {};\n        json.sensors = [];\n        this.sensors.forEach((sensor) => json.sensors.push(sensor.toJSON()));\n        json.distanceCutoff = this.distanceCutoff;\n        return json;\n    }\n}\n/** The thematic display mode. This determines how to apply the thematic color gradient to the geometry.\n * @public\n * @extensions\n */\nexport var ThematicDisplayMode;\n(function (ThematicDisplayMode) {\n    /** The color gradient will be mapped to surface geometry and point clouds based on world height in meters. */\n    ThematicDisplayMode[ThematicDisplayMode[\"Height\"] = 0] = \"Height\";\n    /** The color gradient will be mapped to surface geometry and point clouds using inverse distance weighting based on world positions and corresponding values from a list of sensors.\n     * @note Performance will decrease as more sensors are added.\n     */\n    ThematicDisplayMode[ThematicDisplayMode[\"InverseDistanceWeightedSensors\"] = 1] = \"InverseDistanceWeightedSensors\";\n    /** The color gradient will be mapped to surface geometry based on the slope of the surface. The slope value is calculated based on the angle between the surface and the axis specified in the associated [[ThematicDisplay]] object.\n     * @note This display mode does not affect point clouds.\n     */\n    ThematicDisplayMode[ThematicDisplayMode[\"Slope\"] = 2] = \"Slope\";\n    /** The color gradient will be mapped to surface geometry based on the direction of a sun shining on the surface.\n     * @note This display mode does not affect point clouds.\n     */\n    ThematicDisplayMode[ThematicDisplayMode[\"HillShade\"] = 3] = \"HillShade\";\n})(ThematicDisplayMode || (ThematicDisplayMode = {}));\n/** The thematic display setup of a [[DisplayStyle3d]].\n * Thematic display allows a user to colorize a scene using a color gradient in a way that provides a visual cue about certain attributes of the rendered geometry. This scene colorization will be done based on certain geometric attributes like height, surface slope, position of surfaces relative to a sun position, or geometric position relative to a list of sensors.\n * The documentation for [[ThematicDisplayMode]] describes how each mode colorizes the scene.\n * @note Applying thematic display to geometry prevents shadows from applying to the same geometry.\n * @public\n */\nexport class ThematicDisplay {\n    equals(other) {\n        if (this.displayMode !== other.displayMode)\n            return false;\n        if (!this.gradientSettings.equals(other.gradientSettings))\n            return false;\n        if (!this.range.isAlmostEqual(other.range))\n            return false;\n        if (!this.axis.isAlmostEqual(other.axis))\n            return false;\n        if (!this.sunDirection.isAlmostEqual(other.sunDirection))\n            return false;\n        if (!this.sensorSettings.equals(other.sensorSettings))\n            return false;\n        return true;\n    }\n    constructor(json) {\n        if (undefined === json) {\n            this.displayMode = ThematicDisplayMode.Height;\n            this.gradientSettings = ThematicGradientSettings.fromJSON();\n            this.axis = Vector3d.fromJSON();\n            this.range = Range1d.fromJSON();\n            this.sunDirection = Vector3d.fromJSON();\n            this.sensorSettings = ThematicDisplaySensorSettings.fromJSON();\n        }\n        else {\n            this.displayMode = (json.displayMode !== undefined && json.displayMode !== null) ? json.displayMode : ThematicDisplayMode.Height;\n            if (this.displayMode < ThematicDisplayMode.Height || this.displayMode > ThematicDisplayMode.HillShade)\n                this.displayMode = ThematicDisplayMode.Height;\n            this.gradientSettings = ThematicGradientSettings.fromJSON(json.gradientSettings);\n            this.axis = Vector3d.fromJSON(json.axis);\n            this.range = Range1d.fromJSON(json.range);\n            this.sunDirection = Vector3d.fromJSON(json.sunDirection);\n            this.sensorSettings = ThematicDisplaySensorSettings.fromJSON(json.sensorSettings);\n        }\n        if (ThematicDisplayMode.Height !== this.displayMode) {\n            // Disallow isoline and stepped-with-delimiter gradient modes in any mode other than height.\n            if (ThematicGradientMode.IsoLines === this.gradientSettings.mode || ThematicGradientMode.SteppedWithDelimiter === this.gradientSettings.mode) {\n                const gradientSettingsJSON = this.gradientSettings.toJSON();\n                gradientSettingsJSON.mode = ThematicGradientMode.Smooth;\n                this.gradientSettings = ThematicGradientSettings.fromJSON(gradientSettingsJSON);\n            }\n            if (ThematicDisplayMode.Slope === this.displayMode) {\n                if (this.range.low < 0.0)\n                    this.range.low = 0.0;\n                if (this.range.high > 90.0)\n                    this.range.high = 90.0;\n            }\n        }\n    }\n    static fromJSON(json) {\n        return new ThematicDisplay(json);\n    }\n    toJSON() {\n        const json = {\n            displayMode: this.displayMode,\n            gradientSettings: this.gradientSettings.toJSON(),\n            axis: this.axis.toJSON(),\n            sunDirection: this.sunDirection.toJSON(),\n            range: this.range.toJSON(),\n        };\n        if (this.sensorSettings.sensors.length > 0)\n            json.sensorSettings = this.sensorSettings.toJSON();\n        return json;\n    }\n}\n//# sourceMappingURL=ThematicDisplay.js.map",
      "start": 1693508120772,
      "end": 1693508120830,
      "sourcemaps": null
    }
  ]
}
