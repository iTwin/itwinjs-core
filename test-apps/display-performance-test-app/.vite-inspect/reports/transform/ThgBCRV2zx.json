{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/ParticleCollectionBuilder.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Rendering\n */\nimport { Point2d, Point3d, Range3d, Transform, Vector2d } from \"@itwin/core-geometry\";\nimport { ColorDef, ColorIndex, Feature, FeatureIndex, FeatureTable, FillFlags, PackedFeatureTable, QParams3d, QPoint3dList, } from \"@itwin/core-common\";\nimport { GraphicBranch } from \"./GraphicBranch\";\nimport { DisplayParams } from \"../common/render/primitives/DisplayParams\";\nimport { createMeshParams } from \"./primitives/VertexTableBuilder\";\n/** @public */\nexport var ParticleCollectionBuilder;\n(function (ParticleCollectionBuilder) {\n    /** Creates a new ParticleCollectionBuilder.\n     * @throws Error if size is not greater than zero.\n     */\n    function create(params) {\n        return new Builder(params);\n    }\n    ParticleCollectionBuilder.create = create;\n})(ParticleCollectionBuilder || (ParticleCollectionBuilder = {}));\nclass Particle {\n    constructor(centroid, width, height, transparency, rotationMatrix) {\n        this.centroid = Point3d.fromJSON(centroid);\n        this.transparency = transparency;\n        this.width = width;\n        this.height = height;\n        this.rotationMatrix = rotationMatrix;\n    }\n}\nclass Builder {\n    constructor(params) {\n        this._hasVaryingTransparency = false;\n        this._range = Range3d.createNull();\n        this._particlesOpaque = [];\n        this._particlesTranslucent = [];\n        this._viewport = params.viewport;\n        this._isViewCoords = true === params.isViewCoords;\n        this._pickableId = params.pickableId;\n        this._texture = params.texture;\n        this._transparency = undefined !== params.transparency ? clampTransparency(params.transparency) : 0;\n        this._localToWorldTransform = params.origin ? Transform.createTranslationXYZ(params.origin.x, params.origin.y, params.origin.z) : Transform.createIdentity();\n        if (\"number\" === typeof params.size)\n            this._size = new Vector2d(params.size, params.size);\n        else\n            this._size = Vector2d.fromJSON(params.size);\n        if (this._size.x <= 0 || this._size.y <= 0)\n            throw new Error(\"Particle size must be greater than zero\");\n    }\n    get size() {\n        return this._size;\n    }\n    get transparency() {\n        return this._transparency;\n    }\n    set transparency(transparency) {\n        transparency = clampTransparency(transparency);\n        if (transparency !== this._transparency) {\n            this._transparency = transparency;\n            this._hasVaryingTransparency = this._particlesTranslucent.length > 0;\n        }\n    }\n    addParticle(props) {\n        const size = props.size ?? this._size;\n        let width, height;\n        if (\"number\" === typeof size) {\n            width = height = size;\n        }\n        else {\n            width = size.x;\n            height = size.y;\n        }\n        if (width <= 0 || height <= 0)\n            throw new Error(\"A particle must have a size greater than zero\");\n        const transparency = undefined !== props.transparency ? clampTransparency(props.transparency) : this.transparency;\n        if (transparency !== this.transparency && this._particlesTranslucent.length > 0)\n            this._hasVaryingTransparency = true;\n        const particle = new Particle(props, width, height, transparency, props.rotationMatrix);\n        if (transparency > 0)\n            this._particlesTranslucent.push(particle);\n        else\n            this._particlesOpaque.push(particle);\n        this._range.extendPoint(particle.centroid);\n    }\n    finish() {\n        if (0 === this._particlesTranslucent.length + this._particlesOpaque.length)\n            return undefined;\n        // Order-independent transparency doesn't work well with opaque geometry - it will look semi-transparent.\n        // If we have a mix of opaque and transparent particles, put them in separate graphics to be rendered in separate passes.\n        const opaque = this.createGraphic(this._particlesOpaque, 0);\n        const transparent = this.createGraphic(this._particlesTranslucent, this._hasVaryingTransparency ? undefined : this._transparency);\n        // Empty the collection before any return statements.\n        const range = this._range.clone();\n        this._range.setNull();\n        this._particlesOpaque.length = 0;\n        this._particlesTranslucent.length = 0;\n        this._hasVaryingTransparency = false;\n        if (!transparent && !opaque)\n            return undefined;\n        // Transform from origin to collection, then to world.\n        const toCollection = Transform.createTranslation(range.center);\n        const toWorld = toCollection.multiplyTransformTransform(this._localToWorldTransform);\n        const branch = new GraphicBranch(true);\n        if (opaque)\n            branch.add(opaque);\n        if (transparent)\n            branch.add(transparent);\n        let graphic = this._viewport.target.renderSystem.createGraphicBranch(branch, toWorld);\n        // If we have a pickable Id, produce a batch.\n        // NB: We pass this._pickableId as the FeatureTable's modelId so that it will be treated like a reality model or a map -\n        // specifically, it can be located and display a tooltip, but can't be selected.\n        const featureTable = this._pickableId ? new FeatureTable(1, this._pickableId) : undefined;\n        if (featureTable) {\n            this._localToWorldTransform.multiplyRange(range, range);\n            featureTable.insert(new Feature(this._pickableId));\n            graphic = this._viewport.target.renderSystem.createBatch(graphic, PackedFeatureTable.pack(featureTable), range);\n        }\n        return graphic;\n    }\n    createGraphic(particles, uniformTransparency) {\n        const numParticles = particles.length;\n        if (numParticles <= 0)\n            return undefined;\n        // To keep scale values close to 1, compute mean size to use as size of quad.\n        const meanSize = new Vector2d();\n        let maxSize = 0;\n        for (const particle of particles) {\n            meanSize.x += particle.width;\n            meanSize.y += particle.height;\n            if (particle.width > maxSize)\n                maxSize = particle.width;\n            if (particle.height > maxSize)\n                maxSize = particle.height;\n        }\n        meanSize.x /= numParticles;\n        meanSize.y /= numParticles;\n        // Define InstancedGraphicParams for particles.\n        const rangeCenter = this._range.center;\n        const floatsPerTransform = 12;\n        const transforms = new Float32Array(floatsPerTransform * numParticles);\n        const bytesPerOverride = 8;\n        const symbologyOverrides = undefined === uniformTransparency ? new Uint8Array(bytesPerOverride * numParticles) : undefined;\n        const viewToWorld = this._viewport.view.getRotation().transpose();\n        let tfIndex = 0;\n        let ovrIndex = 0;\n        for (const particle of particles) {\n            const scaleX = particle.width / meanSize.x;\n            const scaleY = particle.height / meanSize.y;\n            if (this._isViewCoords) {\n                // Particles already face the camera in view coords - just apply the scale.\n                transforms[tfIndex + 0] = scaleX;\n                transforms[tfIndex + 5] = scaleY;\n                transforms[tfIndex + 10] = 1;\n            }\n            else if (undefined !== particle.rotationMatrix) {\n                // Scale rotation matrix relative to size of quad.\n                transforms[tfIndex + 0] = particle.rotationMatrix.coffs[0] * scaleX;\n                transforms[tfIndex + 1] = particle.rotationMatrix.coffs[1] * scaleY;\n                transforms[tfIndex + 2] = particle.rotationMatrix.coffs[2];\n                transforms[tfIndex + 4] = particle.rotationMatrix.coffs[3] * scaleX;\n                transforms[tfIndex + 5] = particle.rotationMatrix.coffs[4] * scaleY;\n                transforms[tfIndex + 6] = particle.rotationMatrix.coffs[5];\n                transforms[tfIndex + 8] = particle.rotationMatrix.coffs[6] * scaleX;\n                transforms[tfIndex + 9] = particle.rotationMatrix.coffs[7] * scaleY;\n                transforms[tfIndex + 10] = particle.rotationMatrix.coffs[8];\n            }\n            else {\n                // Rotate about origin by inverse view matrix so quads always face the camera and scale relative to size of quad.\n                transforms[tfIndex + 0] = viewToWorld.coffs[0] * scaleX;\n                transforms[tfIndex + 1] = viewToWorld.coffs[1] * scaleY;\n                transforms[tfIndex + 2] = viewToWorld.coffs[2];\n                transforms[tfIndex + 4] = viewToWorld.coffs[3] * scaleX;\n                transforms[tfIndex + 5] = viewToWorld.coffs[4] * scaleY;\n                transforms[tfIndex + 6] = viewToWorld.coffs[5];\n                transforms[tfIndex + 8] = viewToWorld.coffs[6] * scaleX;\n                transforms[tfIndex + 9] = viewToWorld.coffs[7] * scaleY;\n                transforms[tfIndex + 10] = viewToWorld.coffs[8];\n            }\n            // Translate relative to center of particles range.\n            transforms[tfIndex + 3] = particle.centroid.x - rangeCenter.x;\n            transforms[tfIndex + 7] = particle.centroid.y - rangeCenter.y;\n            transforms[tfIndex + 11] = particle.centroid.z - rangeCenter.z;\n            tfIndex += floatsPerTransform;\n            if (symbologyOverrides) {\n                // See FeatureOverrides.buildLookupTable() for layout.\n                symbologyOverrides[ovrIndex + 0] = 1 << 2; // OvrFlags.Alpha\n                symbologyOverrides[ovrIndex + 7] = 0xff - particle.transparency;\n                ovrIndex += bytesPerOverride;\n            }\n        }\n        // Produce instanced quads.\n        // Note: We do not need to allocate an array of featureIds. If we have a pickableId, all particles refer to the same Feature, with index 0.\n        // So we leave the vertex attribute disabled causing the shader to receive the default (0, 0, 0) which happens to correspond to our feature index.\n        const quad = createQuad(meanSize, this._texture, uniformTransparency ?? 0x7f, this._viewport);\n        const transformCenter = new Point3d(0, 0, 0);\n        const range = computeRange(this._range, rangeCenter, maxSize);\n        const instances = { count: numParticles, transforms, transformCenter, symbologyOverrides, range };\n        return this._viewport.target.renderSystem.createMesh(quad, instances);\n    }\n}\nfunction createQuad(size, texture, transparency, viewport) {\n    const halfWidth = size.x / 2;\n    const halfHeight = size.y / 2;\n    const corners = [\n        new Point3d(-halfWidth, -halfHeight, 0), new Point3d(halfWidth, -halfHeight, 0),\n        new Point3d(-halfWidth, halfHeight, 0), new Point3d(halfWidth, halfHeight, 0),\n    ];\n    const range = new Range3d();\n    range.low = corners[0];\n    range.high = corners[3];\n    const points = new QPoint3dList(QParams3d.fromRange(range));\n    for (const corner of corners)\n        points.add(corner);\n    const colors = new ColorIndex();\n    colors.initUniform(ColorDef.white.withTransparency(transparency));\n    const quadArgs = {\n        points,\n        vertIndices: [0, 1, 2, 2, 1, 3],\n        fillFlags: FillFlags.None,\n        isPlanar: true,\n        colors,\n        features: new FeatureIndex(),\n        textureMapping: {\n            texture,\n            uvParams: [new Point2d(0, 1), new Point2d(1, 1), new Point2d(0, 0), new Point2d(1, 0)],\n        },\n    };\n    return createMeshParams(quadArgs, viewport.target.renderSystem.maxTextureSize);\n}\nfunction clampTransparency(transparency) {\n    transparency = Math.min(255, transparency, Math.max(0, transparency));\n    transparency = Math.floor(transparency);\n    if (transparency < DisplayParams.minTransparency)\n        transparency = 0;\n    return transparency;\n}\nfunction computeRange(centroidRange, center, maxSize) {\n    const range2 = centroidRange.clone();\n    range2.low.subtractInPlace(center);\n    range2.high.subtractInPlace(center);\n    const halfSize = maxSize * 0.5;\n    range2.low.x -= halfSize;\n    range2.low.y -= halfSize;\n    range2.low.z -= halfSize;\n    range2.high.x += halfSize;\n    range2.high.y += halfSize;\n    range2.high.z += halfSize;\n    return range2;\n}\n//# sourceMappingURL=ParticleCollectionBuilder.js.map",
      "start": 1693508119528,
      "end": 1693508119648,
      "sourcemaps": null
    }
  ]
}
