{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/curve/CurveWireMomentsXYZ.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Curve\n */\n// import { Geometry, Angle, AngleSweep } from \"../Geometry\";\nimport { Geometry } from \"../Geometry\";\nimport { MomentData } from \"../geometry4d/MomentData\";\nimport { GaussMapper } from \"../numerics/Quadrature\";\nimport { CurveCollection } from \"./CurveCollection\";\nimport { CurvePrimitive } from \"./CurvePrimitive\";\n/**\n * Class to visit curve primitives and accumulate wire moment integrations.\n * @internal\n */\nexport class CurveWireMomentsXYZ {\n    constructor(numGaussPoints = 5) {\n        this._activeMomentData = MomentData.create();\n        this._activeMomentData.needOrigin = true;\n        this._gaussMapper = new GaussMapper(numGaussPoints);\n    }\n    get momentData() { return this._activeMomentData; }\n    startParentCurvePrimitive(_cp) { }\n    startCurvePrimitive(_cp) { }\n    endCurvePrimitive(_cp) { }\n    endParentCurvePrimitive(_cp) { }\n    announceIntervalForUniformStepStrokes(cp, numStrokes, fraction0, fraction1) {\n        this.startCurvePrimitive(cp);\n        if (numStrokes < 1)\n            numStrokes = 1;\n        const df = 1.0 / numStrokes;\n        let scaleFactor, fraction;\n        for (let i = 1; i <= numStrokes; i++) {\n            const fractionA = Geometry.interpolate(fraction0, (i - 1) * df, fraction1);\n            const fractionB = i === numStrokes ? fraction1 : Geometry.interpolate(fraction0, (i) * df, fraction1);\n            const numGauss = this._gaussMapper.mapXAndW(fractionA, fractionB);\n            for (let k = 0; k < numGauss; k++) {\n                fraction = this._gaussMapper.gaussX[k];\n                const ray = cp.fractionToPointAndDerivative(fraction);\n                scaleFactor = this._gaussMapper.gaussW[k] * ray.direction.magnitude();\n                this._activeMomentData.accumulateScaledOuterProduct(ray.origin, scaleFactor);\n            }\n        }\n    }\n    announceSegmentInterval(_cp, point0, point1, _numStrokes, _fraction0, _fraction1) {\n        this._activeMomentData.accumulateLineMomentsXYZ(point0, point1);\n    }\n    announcePointTangent(_xyz, _fraction, _tangent) {\n        // umm ... this should not happen.  We need to know intervals. The other functions should have prevented this.\n    }\n    /** Recurse to leaf-level primitives */\n    visitLeaves(root) {\n        if (root instanceof CurvePrimitive)\n            root.emitStrokableParts(this);\n        else if (root instanceof CurveCollection) {\n            if (root.children !== undefined)\n                for (const child of root.children) {\n                    this.visitLeaves(child);\n                }\n        }\n    }\n}\n//# sourceMappingURL=CurveWireMomentsXYZ.js.map",
      "start": 1693508124168,
      "end": 1693508124313,
      "sourcemaps": null
    }
  ]
}
