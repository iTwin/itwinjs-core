{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/common/render/primitives/AuxChannelTable.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Rendering\n */\nimport { assert } from \"@itwin/core-bentley\";\nimport { AuxChannelDataType, Point3d, Range1d, Range3d, Vector3d, } from \"@itwin/core-geometry\";\nimport { OctEncodedNormal, QParams3d, QPoint3d, Quantization } from \"@itwin/core-common\";\nimport { computeDimensions } from \"./VertexTable\";\n/** @alpha */\nexport class AuxChannel {\n    constructor(props) {\n        this.name = props.name;\n        this.inputs = props.inputs;\n        this.indices = props.indices;\n    }\n    toJSON() {\n        return {\n            name: this.name,\n            inputs: this.inputs,\n            indices: this.indices,\n        };\n    }\n}\n/** @alpha */\nexport class AuxDisplacementChannel extends AuxChannel {\n    constructor(props) {\n        super(props);\n        this.qOrigin = Float32Array.from(props.qOrigin);\n        this.qScale = Float32Array.from(props.qScale);\n    }\n    toJSON() {\n        return {\n            ...super.toJSON(),\n            qOrigin: Array.from(this.qOrigin),\n            qScale: Array.from(this.qScale),\n        };\n    }\n}\n/** @alpha */\nexport class AuxParamChannel extends AuxChannel {\n    constructor(props) {\n        super(props);\n        this.qOrigin = props.qOrigin[0];\n        this.qScale = props.qScale[0];\n    }\n    toJSON() {\n        return {\n            ...super.toJSON(),\n            qOrigin: [this.qOrigin],\n            qScale: [this.qScale],\n        };\n    }\n}\n/**\n * Represents one or more channels of auxiliary per-vertex data which can be used to animate and resymbolize a mesh in various ways.\n * Each channel holds a fixed number of bytes for each vertex (typically 2 bytes for normals and params, 6 bytes for displacements).\n * The channels are interleaved in a rectangular array such that the data for each vertex is stored contiguously; that is, if a displacement and\n * a normal channel exist, then the first vertex's displacement is followed by the first vertex's normal, which is followed by the second\n * vertex's displacement and normal; and so on.\n * @alpha\n */\nexport class AuxChannelTable {\n    constructor(props, displacements, normals, params) {\n        this.data = props.data;\n        this.width = props.width;\n        this.height = props.height;\n        this.numVertices = props.count;\n        this.numBytesPerVertex = props.numBytesPerVertex;\n        this.displacements = displacements;\n        this.normals = normals;\n        this.params = params;\n    }\n    static fromJSON(props) {\n        let displacements;\n        let normals;\n        let params;\n        if (undefined !== props.displacements && 0 < props.displacements.length) {\n            displacements = [];\n            for (const displacement of props.displacements)\n                displacements.push(new AuxDisplacementChannel(displacement));\n        }\n        if (undefined !== props.normals && 0 < props.normals.length) {\n            normals = [];\n            for (const normal of props.normals)\n                normals.push(new AuxChannel(normal));\n        }\n        if (undefined !== props.params && 0 < props.params.length) {\n            params = [];\n            for (const param of props.params)\n                params.push(new AuxParamChannel(param));\n        }\n        return undefined !== displacements || undefined !== normals || undefined !== params ? new AuxChannelTable(props, displacements, normals, params) : undefined;\n    }\n    toJSON() {\n        return {\n            data: this.data,\n            width: this.width,\n            height: this.height,\n            count: this.numVertices,\n            numBytesPerVertex: this.numBytesPerVertex,\n            displacements: this.displacements?.map((x) => x.toJSON()),\n            normals: this.normals?.map((x) => x.toJSON()),\n            params: this.params?.map((x) => x.toJSON()),\n        };\n    }\n    static fromChannels(channels, numVertices, maxDimension) {\n        return AuxChannelTableBuilder.buildAuxChannelTable(channels, numVertices, maxDimension);\n    }\n}\nfunction invert(num) {\n    if (0 !== num)\n        num = 1 / num;\n    return num;\n}\nclass AuxChannelTableBuilder {\n    constructor(props, numBytesPerVertex) {\n        this._props = props;\n        this._numBytesPerVertex = numBytesPerVertex;\n        this._view = new DataView(props.data.buffer);\n    }\n    static buildAuxChannelTable(channels, numVertices, maxDimension) {\n        const numBytesPerVertex = channels.reduce((accum, channel) => accum + computeNumBytesPerVertex(channel), 0);\n        if (!numBytesPerVertex)\n            return undefined;\n        const nRgbaPerVertex = Math.floor((numBytesPerVertex + 3) / 4);\n        const nUnusedBytesPerVertex = nRgbaPerVertex * 4 - numBytesPerVertex;\n        assert(0 === nUnusedBytesPerVertex || 2 === nUnusedBytesPerVertex);\n        // We don't want any unused bytes. If we've got 2 extra, make every other vertex's channel start in the middle of the first texel.\n        let dimensions;\n        if (0 !== nUnusedBytesPerVertex)\n            dimensions = computeDimensions(Math.floor((numVertices + 1) / 2), numBytesPerVertex / 2, 0, maxDimension); // twice as many RGBA for half as many vertices.\n        else\n            dimensions = computeDimensions(numVertices, nRgbaPerVertex, 0, maxDimension);\n        const data = new Uint8Array(dimensions.width * dimensions.height * 4);\n        const props = {\n            data,\n            width: dimensions.width,\n            height: dimensions.height,\n            count: numVertices,\n            numBytesPerVertex,\n        };\n        const builder = new AuxChannelTableBuilder(props, numBytesPerVertex);\n        builder.build(channels);\n        return AuxChannelTable.fromJSON(props);\n    }\n    build(channels) {\n        let byteOffset = 0;\n        for (const channel of channels) {\n            if (AuxChannelDataType.Normal === channel.dataType)\n                this.addNormals(channel, byteOffset);\n            else if (AuxChannelDataType.Vector === channel.dataType)\n                this.addDisplacements(channel, byteOffset);\n            else\n                this.addParams(channel, byteOffset);\n            byteOffset += computeNumBytesPerVertex(channel);\n        }\n    }\n    addNormals(channel, byteOffset) {\n        const inputs = [];\n        const indices = [];\n        const normal = new Vector3d();\n        for (let i = 0; i < channel.data.length; i++) {\n            let byteIndex = byteOffset + i * 2; // 2 bytes per normal\n            indices.push(byteIndex / 2); // indices aligned to 2-byte intervals\n            const data = channel.data[i];\n            inputs.push(data.input);\n            for (let j = 0; j < data.values.length; j += 3) {\n                normal.x = data.values[j];\n                normal.y = data.values[j + 1];\n                normal.z = data.values[j + 2];\n                normal.normalizeInPlace();\n                const encodedNormal = OctEncodedNormal.encode(normal);\n                this._view.setUint16(byteIndex, encodedNormal, true);\n                byteIndex += this._numBytesPerVertex;\n            }\n        }\n        const normals = this._props.normals ?? (this._props.normals = []);\n        normals.push({\n            name: channel.name ?? \"\",\n            inputs,\n            indices,\n        });\n    }\n    addParams(channel, byteOffset) {\n        const inputs = [];\n        const indices = [];\n        const range = Range1d.createNull();\n        for (const data of channel.data) {\n            inputs.push(data.input);\n            range.extendArray(data.values);\n        }\n        const qScale = Quantization.computeScale(range.high - range.low);\n        for (let i = 0; i < channel.data.length; i++) {\n            let byteIndex = byteOffset + i * 2; // 2 bytes per double\n            indices.push(byteIndex / 2); // indices aligned to 2-byte intervals\n            for (const value of channel.data[i].values) {\n                const quantized = Quantization.quantize(value, range.low, qScale);\n                this._view.setUint16(byteIndex, quantized, true);\n                byteIndex += this._numBytesPerVertex;\n            }\n        }\n        const params = this._props.params ?? (this._props.params = []);\n        params.push({\n            inputs,\n            indices,\n            name: channel.name ?? \"\",\n            qOrigin: [range.low],\n            qScale: [invert(qScale)],\n        });\n    }\n    addDisplacements(channel, byteOffset) {\n        const inputs = [];\n        const indices = [];\n        const point = new Point3d();\n        const range = Range3d.createNull();\n        for (const data of channel.data) {\n            inputs.push(data.input);\n            for (let i = 0; i < data.values.length; i += 3) {\n                point.set(data.values[i], data.values[i + 1], data.values[i + 2]);\n                range.extend(point);\n            }\n        }\n        const qParams = QParams3d.fromRange(range);\n        const qPoint = new QPoint3d();\n        for (let i = 0; i < channel.data.length; i++) {\n            let byteIndex = byteOffset + i * 6; // 2 bytes per coordinate\n            indices.push(byteIndex / 2); // indices aligned to 2-byte intervals\n            const data = channel.data[i];\n            for (let j = 0; j < data.values.length; j += 3) {\n                point.set(data.values[j], data.values[j + 1], data.values[j + 2]);\n                qPoint.init(point, qParams);\n                this._view.setUint16(byteIndex + 0, qPoint.x, true);\n                this._view.setUint16(byteIndex + 2, qPoint.y, true);\n                this._view.setUint16(byteIndex + 4, qPoint.z, true);\n                byteIndex += this._numBytesPerVertex;\n            }\n        }\n        const displacements = this._props.displacements ?? (this._props.displacements = []);\n        displacements.push({\n            inputs,\n            indices,\n            name: channel.name ?? \"\",\n            qOrigin: qParams.origin.toArray(),\n            qScale: qParams.scale.toArray().map((x) => invert(x)),\n        });\n    }\n}\nfunction computeNumBytesPerVertex(channel) {\n    const nEntries = channel.data.length;\n    switch (channel.dataType) {\n        case AuxChannelDataType.Vector:\n            return 6 * nEntries; // 3 16-bit quantized coordinate values per entry.\n        case AuxChannelDataType.Normal:\n        case AuxChannelDataType.Distance:\n        case AuxChannelDataType.Scalar:\n            return 2 * nEntries; // 1 16-bit quantized value per entry.\n    }\n}\n//# sourceMappingURL=AuxChannelTable.js.map",
      "start": 1693508118474,
      "end": 1693508118905,
      "sourcemaps": null
    }
  ]
}
