{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/polyface/PolyfaceBuilder.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\nimport { ConstructCurveBetweenCurves } from \"../curve/ConstructCurveBetweenCurves\";\nimport { CurveChain, CurveCollection } from \"../curve/CurveCollection\";\nimport { CurveFactory } from \"../curve/CurveFactory\";\nimport { CurvePrimitive } from \"../curve/CurvePrimitive\";\nimport { GeometryQuery } from \"../curve/GeometryQuery\";\nimport { LineString3d } from \"../curve/LineString3d\";\nimport { ParityRegion } from \"../curve/ParityRegion\";\nimport { CylindricalRangeQuery } from \"../curve/Query/CylindricalRange\";\nimport { StrokeCountSection } from \"../curve/Query/StrokeCountChain\";\nimport { StrokeOptions } from \"../curve/StrokeOptions\";\nimport { UnionRegion } from \"../curve/UnionRegion\";\nimport { AxisOrder, Geometry } from \"../Geometry\";\nimport { Angle } from \"../geometry3d/Angle\";\nimport { BilinearPatch } from \"../geometry3d/BilinearPatch\";\nimport { FrameBuilder } from \"../geometry3d/FrameBuilder\";\nimport { NullGeometryHandler } from \"../geometry3d/GeometryHandler\";\nimport { GrowableFloat64Array } from \"../geometry3d/GrowableFloat64Array\";\nimport { GrowableXYZArray } from \"../geometry3d/GrowableXYZArray\";\nimport { IndexedXYZCollection } from \"../geometry3d/IndexedXYZCollection\";\nimport { Matrix3d } from \"../geometry3d/Matrix3d\";\nimport { Plane3dByOriginAndVectors } from \"../geometry3d/Plane3dByOriginAndVectors\";\nimport { Point2d } from \"../geometry3d/Point2dVector2d\";\nimport { Point3dArrayCarrier } from \"../geometry3d/Point3dArrayCarrier\";\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\nimport { PolygonOps } from \"../geometry3d/PolygonOps\";\nimport { Range1d, Range3d } from \"../geometry3d/Range\";\nimport { Segment1d } from \"../geometry3d/Segment1d\";\nimport { Transform } from \"../geometry3d/Transform\";\nimport { UVSurfaceOps } from \"../geometry3d/UVSurfaceOps\";\nimport { SweepContour } from \"../solid/SweepContour\";\nimport { HalfEdge } from \"../topology/Graph\";\nimport { Triangulator } from \"../topology/Triangulation\";\nimport { BoxTopology } from \"./BoxTopology\";\nimport { GreedyTriangulationBetweenLineStrings } from \"./GreedyTriangulationBetweenLineStrings\";\nimport { SortableEdge } from \"./IndexedEdgeMatcher\";\nimport { IndexedPolyfaceSubsetVisitor } from \"./IndexedPolyfaceVisitor\";\nimport { IndexedPolyface } from \"./Polyface\";\nimport { PolyfaceQuery } from \"./PolyfaceQuery\";\n/* eslint-disable @typescript-eslint/naming-convention, @typescript-eslint/prefer-for-of */\n/**\n * A FacetSector\n * * initially holds coordinate data for a place where xyz and sectionDerivative are known\n * * normal is computed as a deferred step using an edge to adjacent place on ruled surface\n * * indices are set up even later.\n */\nclass FacetSector {\n    constructor(needNormal = false, needUV = false, needSectionDerivative = false) {\n        this.xyz = Point3d.create();\n        this.normalIndex = -1;\n        this.uvIndex = -1;\n        this.xyzIndex = -1;\n        if (needNormal) {\n            this.normal = Vector3d.create();\n        }\n        if (needUV) {\n            this.uv = Point2d.create();\n            this.uvIndex = -1;\n        }\n        if (needSectionDerivative) {\n            this.sectionDerivative = Vector3d.create();\n        }\n    }\n    /** copy contents (not pointers) from source\n     * * ASSUME all fields defined in this are defined int the source (undefined check only needed on this)\n     */\n    copyContentsFrom(other) {\n        this.xyz.setFromPoint3d(other.xyz);\n        this.xyzIndex = other.xyzIndex;\n        if (this.normal)\n            this.normal.setFromVector3d(other.normal);\n        this.normalIndex = other.normalIndex;\n        if (this.uv)\n            this.uv.setFrom(other.uv);\n        this.uvIndex = other.uvIndex;\n        if (this.sectionDerivative)\n            this.sectionDerivative.setFrom(other.sectionDerivative);\n    }\n    /** access xyz, derivative from given arrays.\n     * * ASSUME corresponding defined conditions\n     * * xyz and derivative are set.\n     * * index fields for updated data are cleared to -1.\n     */\n    loadIndexedPointAndDerivativeCoordinatesFromPackedArrays(i, packedXYZ, packedDerivatives, fractions, v) {\n        packedXYZ.getPoint3dAtCheckedPointIndex(i, this.xyz);\n        if (fractions && v !== undefined)\n            this.uv = Point2d.create(fractions.atUncheckedIndex(i), v);\n        this.xyzIndex = -1;\n        this.normalIndex = -1;\n        this.uvIndex = -1;\n        if (this.sectionDerivative !== undefined && packedDerivatives !== undefined)\n            packedDerivatives.getVector3dAtCheckedVectorIndex(i, this.sectionDerivative);\n    }\n    static suppressSmallUnitVectorComponents(uvw) {\n        const tol = Geometry.smallFloatingPoint;\n        if (Math.abs(uvw.x) < tol)\n            uvw.x = 0.0;\n        if (Math.abs(uvw.y) < tol)\n            uvw.y = 0.0;\n        if (Math.abs(uvw.z) < tol)\n            uvw.z = 0.0;\n    }\n    /**\n     * given two sectors with xyz and sectionDerivative (u derivative)\n     * use the edge from A to B as v direction in-surface derivative.\n     * compute cross products (and normalize)\n     * @param sectorA \"lower\" sector\n     * @param sectorB \"upper\" sector\n     *\n     */\n    static computeNormalsAlongRuleLine(sectorA, sectorB) {\n        // We expect that if sectionDerivative is defined so is normal.\n        // (If not, the cross product calls will generate normals that are never used ..  not good, garbage collector will clean up.)\n        if (sectorA.sectionDerivative && sectorB.sectionDerivative) {\n            const vectorAB = FacetSector._edgeVector;\n            Vector3d.createStartEnd(sectorA.xyz, sectorB.xyz, vectorAB);\n            sectorA.sectionDerivative.crossProduct(vectorAB, sectorA.normal);\n            sectorB.sectionDerivative.crossProduct(vectorAB, sectorB.normal);\n            sectorA.normal.normalizeInPlace();\n            sectorB.normal.normalizeInPlace();\n            FacetSector.suppressSmallUnitVectorComponents(sectorA.normal);\n            FacetSector.suppressSmallUnitVectorComponents(sectorB.normal);\n        }\n    }\n}\nFacetSector._edgeVector = Vector3d.create();\n/**\n *\n * * Simple construction for strongly typed GeometryQuery objects:\n *\n *  * Create a builder with `builder = PolyfaceBuilder.create()`\n *  * Add GeometryQuery objects:\n *\n *    * `builder.addGeometryQuery(g: GeometryQuery)`\n *    * `builder.addCone(cone: Cone)`\n *    * `builder.addTorusPipe(surface: TorusPipe)`\n *    * `builder.addLinearSweepLineStringsXYZOnly(surface: LinearSweep)`\n *    * `builder.addRotationalSweep(surface: RotationalSweep)`\n *    * `builder.addLinearSweep(surface: LinearSweep)`\n *    * `builder.addRuledSweep(surface: RuledSweep)`\n *    * `builder.addSphere(sphere: Sphere)`\n *    * `builder.addBox(box: Box)`\n *    * `builder.addIndexedPolyface(polyface)`\n *  *  Extract with `builder.claimPolyface(true)`\n *\n * * Simple construction for ephemeral constructive data:\n *\n *  * Create a builder with `builder = PolyfaceBuilder.create()`\n *  * Add from fragmentary data:\n *    * `builder.addBetweenLineStringsWithStoredIndices(linestringA  linestringB)`\n *    * `builder.addBetweenLineStringsWithRuleEdgeNormals(linestringA, vA, linestringB, vB, addClosure)`\n *    * `builder.addBetweenTransformedLineStrings(curves, transformA, transformB, addClosure)`\n *    * `builder.addLinearSweepLineStringsXYZOnly(contour, vector)`\n *    * `builder.addPolygon(points, numPointsToUse)`\n *    * `builder.addTransformedUnitBox(transform)`\n *    * `builder.addTriangleFan(conePoint, linestring, toggleOrientation)`\n *    * `builder.addTrianglesInUncheckedConvexPolygon(linestring, toggle)`\n *    * `builder.addUVGridBody(surface,numU, numV, createFanInCaps)`\n *    * `builder.addGraph(Graph, acceptFaceFunction)`\n *  *  Extract with `builder.claimPolyface(true)`\n *\n * * Low-level detail construction -- direct use of indices\n *  * Create a builder with `builder = PolyfaceBuilder.create()`\n *  * Add GeometryQuery objects\n *    * `builder.addPoint(point)`\n *    * `builder.findOrAddPointInLineString(linestring, index)`\n *    * `builder.addPointXYZ(x,y,z)`\n *    * `builder.addTriangleFacet(points)`\n *    * `builder.addQuadFacet(points)`\n  * @public\n */\nclass PolyfaceBuilder extends NullGeometryHandler {\n    /** return (pointer to) the `StrokeOptions` in use by the builder. */\n    get options() { return this._options; }\n    /** Ask if this builder is reversing vertex order as loops are received. */\n    get reversedFlag() { return this._reversed; }\n    /** extract the polyface. */\n    claimPolyface(compress = true) {\n        if (compress)\n            this._polyface.data.compress();\n        return this._polyface;\n    }\n    /** Toggle (reverse) the flag controlling orientation flips for newly added facets. */\n    toggleReversedFacetFlag() { this._reversed = !this._reversed; }\n    constructor(options) {\n        super();\n        this._options = options ? options : StrokeOptions.createForFacets();\n        this._polyface = IndexedPolyface.create(this._options.needNormals, this._options.needParams, this._options.needColors, this._options.needTwoSided);\n        this._reversed = false;\n    }\n    /**\n     * Create a builder with given StrokeOptions\n     * @param options StrokeOptions (captured)\n     */\n    static create(options) {\n        return new PolyfaceBuilder(options);\n    }\n    /** add facets for a transformed unit box. */\n    addTransformedUnitBox(transform) {\n        this.addTransformedRangeMesh(transform, Range3d.createXYZXYZ(0, 0, 0, 1, 1, 1));\n    }\n    /** Add facets for a transformed range box.\n     * @param transform applied to the range points before adding to the polyface\n     * @param range sides become 6 quad polyface facets\n     * @param faceSelector for each face in the order of BoxTopology.cornerIndexCCW, faceSelector[i]===false skips that facet.\n    */\n    addTransformedRangeMesh(transform, range, faceSelector) {\n        const pointIndex0 = this._polyface.data.pointCount;\n        // these will have sequential indices starting at pointIndex0 . . .\n        const points = range.corners();\n        for (const p of points)\n            this._polyface.addPoint(transform.multiplyPoint3d(p));\n        let faceCounter = 0;\n        for (const facet of BoxTopology.cornerIndexCCW) {\n            if (!faceSelector || (faceCounter < faceSelector.length && faceSelector[faceCounter])) {\n                const myFacet = facet.map((pointIndex) => pointIndex + pointIndex0);\n                if (this._reversed)\n                    myFacet.reverse();\n                if (this._options.shouldTriangulate) {\n                    this.addIndexedTrianglePointIndexes(myFacet[0], myFacet[1], myFacet[2], false);\n                    this.addIndexedTrianglePointIndexes(myFacet[0], myFacet[2], myFacet[3], false);\n                }\n                else {\n                    this.addIndexedQuadPointIndexes(myFacet[0], myFacet[1], myFacet[3], myFacet[2], false);\n                }\n                this._polyface.terminateFacet();\n            }\n            faceCounter++;\n        }\n    }\n    /** Add triangles from points[0] to each far edge.\n     * @param ls linestring with point coordinates\n     * @param toggle if true, wrap the triangle creation in toggleReversedFacetFlag.\n     */\n    addTriangleFan(conePoint, ls, toggle) {\n        const n = ls.numPoints();\n        if (n > 2) {\n            if (toggle)\n                this.toggleReversedFacetFlag();\n            const index0 = this.addPoint(conePoint);\n            let index1 = this.findOrAddPointInLineString(ls, 0);\n            let index2 = 0;\n            for (let i = 1; i < n; i++) {\n                index2 = this.findOrAddPointInLineString(ls, i);\n                this.addIndexedTrianglePointIndexes(index0, index1, index2);\n                index1 = index2;\n            }\n            if (toggle)\n                this.toggleReversedFacetFlag();\n        }\n    }\n    /** Add triangles from points[0] to each far edge\n     * * Assume the polygon is convex.\n     * * i.e. simple triangulation from point0\n     * * i.e. simple cross products give a good normal.\n     * @param ls linestring with point coordinates\n     * @param reverse if true, wrap the triangle creation in toggleReversedFacetFlag.\n     */\n    addTrianglesInUncheckedConvexPolygon(ls, toggle) {\n        const n = ls.numPoints();\n        if (n > 2) {\n            if (toggle)\n                this.toggleReversedFacetFlag();\n            let normal;\n            let normalIndex;\n            if (this._options.needNormals) {\n                normal = ls.quickUnitNormal(PolyfaceBuilder._workVectorFindOrAdd);\n                if (toggle)\n                    normal.scaleInPlace(-1.0);\n                normalIndex = this._polyface.addNormal(normal);\n            }\n            const needParams = this._options.needParams;\n            const packedUV = needParams ? ls.packedUVParams : undefined;\n            let paramIndex0 = -1;\n            let paramIndex1 = -1;\n            let paramIndex2 = -1;\n            if (packedUV) {\n                paramIndex0 = this.addParamInGrowableXYArray(packedUV, 0);\n                paramIndex1 = this.addParamInGrowableXYArray(packedUV, 1);\n            }\n            const pointIndex0 = this.findOrAddPointInLineString(ls, 0);\n            let pointIndex1 = this.findOrAddPointInLineString(ls, 1);\n            let pointIndex2 = 0;\n            let numEdge = n;\n            if (ls.isPhysicallyClosed)\n                numEdge--;\n            for (let i = 2; i < numEdge; i++, pointIndex1 = pointIndex2, paramIndex1 = paramIndex2) {\n                pointIndex2 = this.findOrAddPointInLineString(ls, i);\n                this.addIndexedTrianglePointIndexes(pointIndex0, pointIndex1, pointIndex2, false);\n                if (normalIndex !== undefined)\n                    this.addIndexedTriangleNormalIndexes(normalIndex, normalIndex, normalIndex);\n                if (packedUV) {\n                    paramIndex2 = this.addParamInGrowableXYArray(packedUV, i);\n                    this.addIndexedTriangleParamIndexes(paramIndex0, paramIndex1, paramIndex2);\n                }\n                this._polyface.terminateFacet();\n            }\n            if (toggle)\n                this.toggleReversedFacetFlag();\n        }\n    }\n    /**\n     * Announce point coordinates.\n     */\n    addPoint(xyz) {\n        return this._polyface.addPoint(xyz);\n    }\n    /**\n     * Announce point coordinates.\n     * @deprecated in 3.x. Use addPoint instead.\n     */\n    findOrAddPoint(xyz) {\n        return this.addPoint(xyz);\n    }\n    /**\n     * Announce uv parameter coordinates.\n     */\n    addParamXY(x, y) {\n        return this._polyface.addParamUV(x, y);\n    }\n    /**\n     * Announce uv parameter coordinates.\n     * @deprecated in 3.x. Use addParamXY instead.\n     */\n    findOrAddParamXY(x, y) {\n        return this.addParamXY(x, y);\n    }\n    /**\n     * Announce point coordinates.  The implementation is free to either create a new point or (if known) return index of a prior point with the same coordinates.\n     * @returns Returns the point index in the Polyface.\n     * @param index Index of the point in the linestring.\n     */\n    findOrAddPointInLineString(ls, index, transform, priorIndex) {\n        const q = ls.pointAt(index, PolyfaceBuilder._workPointFindOrAddA);\n        if (q) {\n            if (transform)\n                transform.multiplyPoint3d(q, q);\n            return this._polyface.addPoint(q, priorIndex);\n        }\n        return undefined;\n    }\n    /**\n     * Announce point coordinates.  The implementation is free to either create a new point or (if known) return index of a prior point with the same coordinates.\n     * @returns Returns the point index in the Polyface.\n     * @param index Index of the point in the linestring.\n     */\n    findOrAddPointInGrowableXYZArray(xyz, index, transform, priorIndex) {\n        const q = xyz.getPoint3dAtCheckedPointIndex(index, PolyfaceBuilder._workPointFindOrAddA);\n        if (q) {\n            if (transform)\n                transform.multiplyPoint3d(q, q);\n            return this._polyface.addPoint(q, priorIndex);\n        }\n        return undefined;\n    }\n    /**\n     * Announce point coordinates.  The implementation is free to either create a new point or (if known) return index of a prior point with the same coordinates.\n     * @returns Returns the point index in the Polyface.\n     * @param index Index of the point in the linestring.\n     */\n    findOrAddNormalInGrowableXYZArray(xyz, index, transform, priorIndex) {\n        const q = xyz.getVector3dAtCheckedVectorIndex(index, PolyfaceBuilder._workVectorFindOrAdd);\n        if (q) {\n            if (transform)\n                transform.multiplyVector(q, q);\n            return this._polyface.addNormal(q, priorIndex);\n        }\n        return undefined;\n    }\n    /**\n     * Announce uv parameter coordinates.\n     * @returns Returns the uv parameter index in the Polyface.\n     * @param index Index of the param in the linestring.\n     */\n    addParamInGrowableXYArray(data, index) {\n        if (!data)\n            return undefined;\n        const q = data.getPoint2dAtCheckedPointIndex(index, PolyfaceBuilder._workUVFindOrAdd);\n        if (q) {\n            return this._polyface.addParam(q);\n        }\n        return undefined;\n    }\n    /**\n     * Announce uv parameter coordinates.\n     * @deprecated in 3.x. Use addParamInGrowableXYArray instead.\n     */\n    findOrAddParamInGrowableXYArray(data, index) {\n        return this.addParamInGrowableXYArray(data, index);\n    }\n    /**\n     * Announce param coordinates, taking u from ls.fractions and v from parameter.  The implementation is free to either create a new param or (if known) return index of a prior point with the same coordinates.\n     * @returns Returns the point index in the Polyface.\n     * @param index Index of the point in the linestring.\n     */\n    findOrAddParamInLineString(ls, index, v, priorIndexA, priorIndexB) {\n        const u = (ls.fractions && index < ls.fractions.length) ? ls.fractions.atUncheckedIndex(index) : index / ls.points.length;\n        return this._polyface.addParamUV(u, v, priorIndexA, priorIndexB);\n    }\n    /**\n     * Announce normal coordinates found at index in the surfaceNormal array stored on the linestring\n     * @returns Returns the point index in the Polyface.\n     * @param index Index of the point in the linestring.\n     * @param priorIndex possible prior normal index to reuse\n     */\n    findOrAddNormalInLineString(ls, index, transform, priorIndexA, priorIndexB) {\n        const linestringNormals = ls.packedSurfaceNormals;\n        if (linestringNormals) {\n            const q = linestringNormals.getVector3dAtCheckedVectorIndex(index, PolyfaceBuilder._workVectorFindOrAdd);\n            if (q) {\n                if (transform)\n                    transform.multiplyVector(q, q);\n                return this._polyface.addNormal(q, priorIndexA, priorIndexB);\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Announce point coordinates.\n     */\n    addPointXYZ(x, y, z) {\n        return this._polyface.addPointXYZ(x, y, z);\n    }\n    /**\n     * Announce point coordinates.\n     * @deprecated in 3.x. Use addPointXYZ instead.\n     */\n    findOrAddPointXYZ(x, y, z) {\n        return this.addPointXYZ(x, y, z);\n    }\n    /** Returns a transform who can be applied to points on a triangular facet in order to obtain UV parameters. */\n    getUVTransformForTriangleFacet(pointA, pointB, pointC) {\n        const vectorAB = pointA.vectorTo(pointB);\n        const vectorAC = pointA.vectorTo(pointC);\n        const unitAxes = Matrix3d.createRigidFromColumns(vectorAB, vectorAC, AxisOrder.XYZ);\n        const localToWorld = Transform.createOriginAndMatrix(pointA, unitAxes);\n        return localToWorld.inverse();\n    }\n    /** Returns the normal to a triangular facet. */\n    getNormalForTriangularFacet(pointA, pointB, pointC) {\n        const vectorAB = pointA.vectorTo(pointB);\n        const vectorAC = pointA.vectorTo(pointC);\n        let normal = vectorAB.crossProduct(vectorAC).normalize();\n        normal = normal ? normal : Vector3d.create();\n        return normal;\n    }\n    // ###: Consider case where normals will be reversed and point through the other end of the facet\n    /**\n     * Add a quad to the polyface given its points in order around the edges.\n     * @param points array of at least three vertices\n     * @param params optional array of at least four uv parameters (if undefined, params are calculated without reference data)\n     * @param normals optional array of at least four vectors (if undefined, the quad is assumed to be planar and its normal is calculated)\n     * @param colors optional array of at least four colors\n     */\n    addQuadFacet(points, params, normals, colors) {\n        if (points instanceof GrowableXYZArray)\n            points = points.getPoint3dArray();\n        // If params and/or normals are needed, calculate them first\n        const needParams = this.options.needParams;\n        const needNormals = this.options.needNormals;\n        const needColors = this.options.needColors;\n        let param0, param1, param2, param3;\n        let normal0, normal1, normal2, normal3;\n        let color0, color1, color2, color3;\n        if (needParams) {\n            if (params !== undefined && params.length > 3) {\n                param0 = params[0];\n                param1 = params[1];\n                param2 = params[2];\n                param3 = params[3];\n            }\n            else {\n                const paramTransform = this.getUVTransformForTriangleFacet(points[0], points[1], points[2]);\n                if (paramTransform === undefined) {\n                    param0 = param1 = param2 = param3 = Point2d.createZero();\n                }\n                else {\n                    param0 = Point2d.createFrom(paramTransform.multiplyPoint3d(points[0]));\n                    param1 = Point2d.createFrom(paramTransform.multiplyPoint3d(points[1]));\n                    param2 = Point2d.createFrom(paramTransform.multiplyPoint3d(points[2]));\n                    param3 = Point2d.createFrom(paramTransform.multiplyPoint3d(points[3]));\n                }\n            }\n        }\n        if (needNormals) {\n            if (normals !== undefined && normals.length > 3) {\n                normal0 = normals[0];\n                normal1 = normals[1];\n                normal2 = normals[2];\n                normal3 = normals[3];\n            }\n            else {\n                normal0 = this.getNormalForTriangularFacet(points[0], points[1], points[2]);\n                normal1 = this.getNormalForTriangularFacet(points[0], points[1], points[2]);\n                normal2 = this.getNormalForTriangularFacet(points[0], points[1], points[2]);\n                normal3 = this.getNormalForTriangularFacet(points[0], points[1], points[2]);\n            }\n        }\n        if (needColors) {\n            if (colors !== undefined && colors.length > 3) {\n                color0 = colors[0];\n                color1 = colors[1];\n                color2 = colors[2];\n                color3 = colors[3];\n            }\n        }\n        if (this._options.shouldTriangulate) {\n            // Add as two triangles, with a diagonal along the shortest distance\n            const vectorAC = points[0].vectorTo(points[2]);\n            const vectorBD = points[1].vectorTo(points[3]);\n            // Note: We pass along any values for normals or params that we calculated\n            if (vectorAC.magnitude() >= vectorBD.magnitude()) {\n                this.addTriangleFacet([points[0], points[1], points[2]], needParams ? [param0, param1, param2] : undefined, needNormals ? [normal0, normal1, normal2] : undefined, needColors ? [color0, color1, color2] : undefined);\n                this.addTriangleFacet([points[0], points[2], points[3]], needParams ? [param0, param2, param3] : undefined, needNormals ? [normal0, normal2, normal3] : undefined, needColors ? [color0, color2, color3] : undefined);\n            }\n            else {\n                this.addTriangleFacet([points[0], points[1], points[3]], needParams ? [param0, param1, param3] : undefined, needNormals ? [normal0, normal1, normal3] : undefined, needColors ? [color0, color1, color3] : undefined);\n                this.addTriangleFacet([points[1], points[2], points[3]], needParams ? [param1, param2, param3] : undefined, needNormals ? [normal1, normal2, normal3] : undefined, needColors ? [color1, color2, color3] : undefined);\n            }\n            return;\n        }\n        let idx0, idx1, idx2, idx3;\n        // Add params if needed\n        if (needParams) {\n            idx0 = this._polyface.addParam(param0);\n            idx1 = this._polyface.addParam(param1);\n            idx2 = this._polyface.addParam(param2);\n            idx3 = this._polyface.addParam(param3);\n            this.addIndexedQuadParamIndexes(idx0, idx1, idx3, idx2);\n        }\n        // Add normals if needed\n        if (needNormals) {\n            idx0 = this._polyface.addNormal(normal0);\n            idx1 = this._polyface.addNormal(normal1);\n            idx2 = this._polyface.addNormal(normal2);\n            idx3 = this._polyface.addNormal(normal3);\n            this.addIndexedQuadNormalIndexes(idx0, idx1, idx3, idx2);\n        }\n        // Add colors if needed\n        if (needColors) {\n            idx0 = this._polyface.addColor(color0);\n            idx1 = this._polyface.addColor(color1);\n            idx2 = this._polyface.addColor(color2);\n            idx3 = this._polyface.addColor(color3);\n            this.addIndexedQuadColorIndexes(idx0, idx1, idx3, idx2);\n        }\n        // Add point and point indexes last (terminates the facet)\n        idx0 = this.addPoint(points[0]);\n        idx1 = this.addPoint(points[1]);\n        idx2 = this.addPoint(points[2]);\n        idx3 = this.addPoint(points[3]);\n        this.addIndexedQuadPointIndexes(idx0, idx1, idx3, idx2);\n    }\n    /** Announce a single quad facet's point indexes.\n     * * The actual quad may be reversed or triangulated based on builder setup.\n     * * indexA0 and indexA1 are in the forward order at the \"A\" end of the quad\n     * * indexB0 and indexB1 are in the forward order at the \"B\" end of the quad.\n     * * This means ccw/cw ordered vertices v[i] should be passed into this function as i=[0,1,3,2]\n     */\n    addIndexedQuadPointIndexes(indexA0, indexA1, indexB0, indexB1, terminate = true) {\n        if (this._reversed) {\n            this._polyface.addPointIndex(indexA0);\n            this._polyface.addPointIndex(indexB0);\n            this._polyface.addPointIndex(indexB1);\n            this._polyface.addPointIndex(indexA1);\n        }\n        else {\n            this._polyface.addPointIndex(indexA0);\n            this._polyface.addPointIndex(indexA1);\n            this._polyface.addPointIndex(indexB1);\n            this._polyface.addPointIndex(indexB0);\n        }\n        if (terminate)\n            this._polyface.terminateFacet();\n    }\n    /** For a single quad facet, add the indexes of the corresponding param points. */\n    addIndexedQuadParamIndexes(indexA0, indexA1, indexB0, indexB1) {\n        if (this._reversed) {\n            this._polyface.addParamIndex(indexA0);\n            this._polyface.addParamIndex(indexB0);\n            this._polyface.addParamIndex(indexB1);\n            this._polyface.addParamIndex(indexA1);\n        }\n        else {\n            this._polyface.addParamIndex(indexA0);\n            this._polyface.addParamIndex(indexA1);\n            this._polyface.addParamIndex(indexB1);\n            this._polyface.addParamIndex(indexB0);\n        }\n    }\n    /** For a single quad facet, add the indexes of the corresponding normal vectors. */\n    addIndexedQuadNormalIndexes(indexA0, indexA1, indexB0, indexB1) {\n        if (this._reversed) {\n            this._polyface.addNormalIndex(indexA0);\n            this._polyface.addNormalIndex(indexB0);\n            this._polyface.addNormalIndex(indexB1);\n            this._polyface.addNormalIndex(indexA1);\n        }\n        else {\n            this._polyface.addNormalIndex(indexA0);\n            this._polyface.addNormalIndex(indexA1);\n            this._polyface.addNormalIndex(indexB1);\n            this._polyface.addNormalIndex(indexB0);\n        }\n    }\n    /** For a single quad facet, add the indexes of the corresponding colors. */\n    addIndexedQuadColorIndexes(indexA0, indexA1, indexB0, indexB1) {\n        if (this._reversed) {\n            this._polyface.addColorIndex(indexA0);\n            this._polyface.addColorIndex(indexB0);\n            this._polyface.addColorIndex(indexB1);\n            this._polyface.addColorIndex(indexA1);\n        }\n        else {\n            this._polyface.addColorIndex(indexA0);\n            this._polyface.addColorIndex(indexA1);\n            this._polyface.addColorIndex(indexB1);\n            this._polyface.addColorIndex(indexB0);\n        }\n    }\n    // ### TODO: Consider case where normals will be reversed and point through the other end of the facet\n    /**\n     * Add a triangle to the polyface given its points in order around the edges.\n     * @param points array of at least three vertices\n     * @param params optional array of at least three uv parameters (if undefined, params are calculated without reference data)\n     * @param normals optional array of at least three vectors (if undefined, the normal is calculated)\n     * @param colors optional array of at least three colors\n     */\n    addTriangleFacet(points, params, normals, colors) {\n        if (points.length < 3)\n            return;\n        let idx0;\n        let idx1;\n        let idx2;\n        let point0, point1, point2;\n        if (points instanceof GrowableXYZArray) {\n            point0 = points.getPoint3dAtCheckedPointIndex(0);\n            point1 = points.getPoint3dAtCheckedPointIndex(1);\n            point2 = points.getPoint3dAtCheckedPointIndex(2);\n        }\n        else {\n            point0 = points[0];\n            point1 = points[1];\n            point2 = points[2];\n        }\n        // Add params if needed\n        if (this._options.needParams) {\n            if (params && params.length >= 3) { // Params were given\n                idx0 = this._polyface.addParam(params[0]);\n                idx1 = this._polyface.addParam(params[1]);\n                idx2 = this._polyface.addParam(params[2]);\n            }\n            else { // Compute params\n                const paramTransform = this.getUVTransformForTriangleFacet(point0, point1, point2);\n                idx0 = this._polyface.addParam(Point2d.createFrom(paramTransform ? paramTransform.multiplyPoint3d(point0) : undefined));\n                idx1 = this._polyface.addParam(Point2d.createFrom(paramTransform ? paramTransform.multiplyPoint3d(point1) : undefined));\n                idx2 = this._polyface.addParam(Point2d.createFrom(paramTransform ? paramTransform.multiplyPoint3d(point1) : undefined));\n            }\n            this.addIndexedTriangleParamIndexes(idx0, idx1, idx2);\n        }\n        // Add normals if needed\n        if (this._options.needNormals) {\n            if (normals !== undefined && normals.length > 2) { // Normals were given\n                idx0 = this._polyface.addNormal(normals[0]);\n                idx1 = this._polyface.addNormal(normals[1]);\n                idx2 = this._polyface.addNormal(normals[2]);\n            }\n            else { // Compute normals\n                const normal = this.getNormalForTriangularFacet(point0, point1, point2);\n                idx0 = this._polyface.addNormal(normal);\n                idx1 = this._polyface.addNormal(normal);\n                idx2 = this._polyface.addNormal(normal);\n            }\n            this.addIndexedTriangleNormalIndexes(idx0, idx1, idx2);\n        }\n        // Add colors if needed and provided\n        if (this._options.needColors) {\n            if (colors !== undefined && colors.length > 2) {\n                idx0 = this._polyface.addColor(colors[0]);\n                idx1 = this._polyface.addColor(colors[1]);\n                idx2 = this._polyface.addColor(colors[2]);\n                this.addIndexedTriangleColorIndexes(idx0, idx1, idx2);\n            }\n        }\n        // Add point and point indexes last (terminates the facet)\n        idx0 = this.addPoint(point0);\n        idx1 = this.addPoint(point1);\n        idx2 = this.addPoint(point2);\n        this.addIndexedTrianglePointIndexes(idx0, idx1, idx2);\n    }\n    /** Announce a single triangle facet's point indexes.\n     *\n     * * The actual quad may be reversed or triangulated based on builder setup.\n     */\n    addIndexedTrianglePointIndexes(indexA, indexB, indexC, terminateFacet = true) {\n        if (!this._reversed) {\n            this._polyface.addPointIndex(indexA);\n            this._polyface.addPointIndex(indexB);\n            this._polyface.addPointIndex(indexC);\n        }\n        else {\n            this._polyface.addPointIndex(indexA);\n            this._polyface.addPointIndex(indexC);\n            this._polyface.addPointIndex(indexB);\n        }\n        if (terminateFacet)\n            this._polyface.terminateFacet();\n    }\n    /** For a single triangle facet, add the indexes of the corresponding params. */\n    addIndexedTriangleParamIndexes(indexA, indexB, indexC) {\n        if (!this._reversed) {\n            this._polyface.addParamIndex(indexA);\n            this._polyface.addParamIndex(indexB);\n            this._polyface.addParamIndex(indexC);\n        }\n        else {\n            this._polyface.addParamIndex(indexA);\n            this._polyface.addParamIndex(indexC);\n            this._polyface.addParamIndex(indexB);\n        }\n    }\n    /** For a single triangle facet, add the indexes of the corresponding params. */\n    addIndexedTriangleNormalIndexes(indexA, indexB, indexC) {\n        if (!this._reversed) {\n            this._polyface.addNormalIndex(indexA);\n            this._polyface.addNormalIndex(indexB);\n            this._polyface.addNormalIndex(indexC);\n        }\n        else {\n            this._polyface.addNormalIndex(indexA);\n            this._polyface.addNormalIndex(indexC);\n            this._polyface.addNormalIndex(indexB);\n        }\n    }\n    /** For a single triangle facet, add the indexes of the corresponding colors. */\n    addIndexedTriangleColorIndexes(indexA, indexB, indexC) {\n        if (!this._reversed) {\n            this._polyface.addColorIndex(indexA);\n            this._polyface.addColorIndex(indexB);\n            this._polyface.addColorIndex(indexC);\n        }\n        else {\n            this._polyface.addColorIndex(indexA);\n            this._polyface.addColorIndex(indexC);\n            this._polyface.addColorIndex(indexB);\n        }\n    }\n    /** Find or add xyzIndex and normalIndex for coordinates in the sector. */\n    setSectorIndices(sector) {\n        sector.xyzIndex = this.addPoint(sector.xyz);\n        if (sector.normal)\n            sector.normalIndex = this._polyface.addNormal(sector.normal);\n        if (sector.uv)\n            sector.uvIndex = this._polyface.addParam(sector.uv);\n    }\n    addSectorTriangle(sectorA0, sectorA1, sectorA2) {\n        if (sectorA0.xyz.isAlmostEqual(sectorA1.xyz)\n            || sectorA1.xyz.isAlmostEqual(sectorA2.xyz)\n            || sectorA2.xyz.isAlmostEqual(sectorA0.xyz)) {\n            // trivially degenerate triangle !!! skip !!!\n        }\n        else {\n            if (this._options.needNormals)\n                this.addIndexedTriangleNormalIndexes(sectorA0.normalIndex, sectorA1.normalIndex, sectorA2.normalIndex);\n            if (this._options.needParams)\n                this.addIndexedTriangleParamIndexes(sectorA0.uvIndex, sectorA1.uvIndex, sectorA2.uvIndex);\n            this.addIndexedTrianglePointIndexes(sectorA0.xyzIndex, sectorA1.xyzIndex, sectorA2.xyzIndex);\n            this._polyface.terminateFacet();\n        }\n    }\n    addSectorQuadA01B01(sectorA0, sectorA1, sectorB0, sectorB1) {\n        if (sectorA0.xyz.isAlmostEqual(sectorA1.xyz) && sectorB0.xyz.isAlmostEqual(sectorB1.xyz)) {\n            // ignore null quad !!\n        }\n        else if (this._options.shouldTriangulate) {\n            this.addSectorTriangle(sectorA0, sectorA1, sectorB1);\n            this.addSectorTriangle(sectorB1, sectorB0, sectorA0);\n        }\n        else {\n            if (this._options.needNormals)\n                this.addIndexedQuadNormalIndexes(sectorA0.normalIndex, sectorA1.normalIndex, sectorB0.normalIndex, sectorB1.normalIndex);\n            if (this._options.needParams)\n                this.addIndexedQuadParamIndexes(sectorA0.uvIndex, sectorA1.uvIndex, sectorB0.uvIndex, sectorB1.uvIndex);\n            this.addIndexedQuadPointIndexes(sectorA0.xyzIndex, sectorA1.xyzIndex, sectorB0.xyzIndex, sectorB1.xyzIndex);\n            this._polyface.terminateFacet();\n        }\n    }\n    /** Add facets between lineStrings with matched point counts.\n     * * surface normals are computed from (a) curve tangents in the linestrings and (b)rule line between linestrings.\n     * * Facets are announced to addIndexedQuad.\n     * * addIndexedQuad is free to apply reversal or triangulation options.\n     */\n    addBetweenLineStringsWithRuleEdgeNormals(lineStringA, vA, lineStringB, vB, addClosure = false) {\n        const pointA = lineStringA.packedPoints;\n        const pointB = lineStringB.packedPoints;\n        const derivativeA = lineStringA.packedDerivatives;\n        const derivativeB = lineStringB.packedDerivatives;\n        const fractionA = lineStringA.fractions;\n        const fractionB = lineStringB.fractions;\n        const needNormals = this._options.needNormals;\n        const needParams = this._options.needParams;\n        const sectorA0 = new FacetSector(needNormals, needParams, needNormals);\n        const sectorA1 = new FacetSector(needNormals, needParams, needNormals);\n        const sectorB0 = new FacetSector(needNormals, needParams, needNormals);\n        const sectorB1 = new FacetSector(needNormals, needParams, needNormals);\n        const sectorA00 = new FacetSector(needNormals, needParams, needNormals);\n        const sectorB00 = new FacetSector(needNormals, needParams, needNormals);\n        const numPoints = pointA.length;\n        if (numPoints < 2 || numPoints !== pointB.length)\n            return;\n        sectorA0.loadIndexedPointAndDerivativeCoordinatesFromPackedArrays(0, pointA, derivativeA, fractionA, vA);\n        sectorB0.loadIndexedPointAndDerivativeCoordinatesFromPackedArrays(0, pointB, derivativeB, fractionB, vB);\n        if (needNormals)\n            FacetSector.computeNormalsAlongRuleLine(sectorA0, sectorB0);\n        this.setSectorIndices(sectorA0);\n        this.setSectorIndices(sectorB0);\n        sectorA00.copyContentsFrom(sectorA0);\n        sectorB00.copyContentsFrom(sectorB0);\n        for (let i = 1; i < numPoints; i++) {\n            sectorA1.loadIndexedPointAndDerivativeCoordinatesFromPackedArrays(i, pointA, derivativeA, fractionA, vA);\n            sectorB1.loadIndexedPointAndDerivativeCoordinatesFromPackedArrays(i, pointB, derivativeA, fractionB, vB);\n            FacetSector.computeNormalsAlongRuleLine(sectorA1, sectorB1);\n            this.setSectorIndices(sectorA1);\n            this.setSectorIndices(sectorB1);\n            // create the facet ...\n            this.addSectorQuadA01B01(sectorA0, sectorA1, sectorB0, sectorB1);\n            sectorA0.copyContentsFrom(sectorA1);\n            sectorB0.copyContentsFrom(sectorB1);\n        }\n        if (addClosure)\n            this.addSectorQuadA01B01(sectorA0, sectorA00, sectorB0, sectorB00);\n    }\n    /** Add facets between lineStrings with matched point counts.\n     * * point indices pre-stored\n     * * normal indices pre-stored\n     * * uv indices pre-stored\n     */\n    addBetweenLineStringsWithStoredIndices(lineStringA, lineStringB) {\n        const pointA = lineStringA.pointIndices;\n        const pointB = lineStringB.pointIndices;\n        let normalA = lineStringA.normalIndices;\n        let normalB = lineStringB.normalIndices;\n        if (!this._options.needNormals) {\n            normalA = undefined;\n            normalB = undefined;\n        }\n        let paramA = lineStringA.paramIndices;\n        let paramB = lineStringB.paramIndices;\n        if (!this._options.needParams) {\n            paramA = undefined;\n            paramB = undefined;\n        }\n        const numPoints = pointA.length;\n        for (let i = 1; i < numPoints; i++) {\n            if (this.options.shouldTriangulate) {\n                if (distinctIndices(pointA.atUncheckedIndex(i - 1), pointA.atUncheckedIndex(i), pointB.atUncheckedIndex(i))) {\n                    this.addIndexedTrianglePointIndexes(pointA.atUncheckedIndex(i - 1), pointA.atUncheckedIndex(i), pointB.atUncheckedIndex(i));\n                    if (normalA && normalB)\n                        this.addIndexedTriangleNormalIndexes(normalA.atUncheckedIndex(i - 1), normalA.atUncheckedIndex(i), normalB.atUncheckedIndex(i - 1));\n                    if (paramA && paramB)\n                        this.addIndexedTriangleParamIndexes(paramA.atUncheckedIndex(i - 1), paramA.atUncheckedIndex(i), paramB.atUncheckedIndex(i - 1));\n                }\n                if (distinctIndices(pointB.atUncheckedIndex(i), pointB.atUncheckedIndex(i - 1), pointA.atUncheckedIndex(i - 1))) {\n                    this.addIndexedTrianglePointIndexes(pointA.atUncheckedIndex(i - 1), pointB.atUncheckedIndex(i), pointB.atUncheckedIndex(i - 1));\n                    if (normalA && normalB)\n                        this.addIndexedTriangleNormalIndexes(normalA.atUncheckedIndex(i - 1), normalB.atUncheckedIndex(i), normalB.atUncheckedIndex(i - 1));\n                    if (paramA && paramB)\n                        this.addIndexedTriangleParamIndexes(paramA.atUncheckedIndex(i - 1), paramB.atUncheckedIndex(i), paramB.atUncheckedIndex(i - 1));\n                }\n            }\n            else {\n                if (pointA.atUncheckedIndex(i - 1) !== pointA.atUncheckedIndex(i) || pointB.atUncheckedIndex(i - 1) !== pointB.atUncheckedIndex(i)) {\n                    this.addIndexedQuadPointIndexes(pointA.atUncheckedIndex(i - 1), pointA.atUncheckedIndex(i), pointB.atUncheckedIndex(i - 1), pointB.atUncheckedIndex(i));\n                    if (normalA && normalB)\n                        this.addIndexedQuadNormalIndexes(normalA.atUncheckedIndex(i - 1), normalA.atUncheckedIndex(i), normalB.atUncheckedIndex(i - 1), normalB.atUncheckedIndex(i));\n                    if (paramA && paramB)\n                        this.addIndexedQuadParamIndexes(paramA.atUncheckedIndex(i - 1), paramA.atUncheckedIndex(i), paramB.atUncheckedIndex(i - 1), paramB.atUncheckedIndex(i));\n                }\n                this._polyface.terminateFacet();\n            }\n        }\n    }\n    /** Add facets between lineStrings with matched point counts.\n     *\n     * * Facets are announced to addIndexedQuad.\n     * * addIndexedQuad is free to apply reversal or triangulation options.\n     */\n    addBetweenTransformedLineStrings(curves, transformA, transformB, addClosure = false) {\n        if (curves instanceof LineString3d) {\n            const pointA = curves.points;\n            const numPoints = pointA.length;\n            let indexA0 = this.findOrAddPointInLineString(curves, 0, transformA);\n            let indexB0 = this.findOrAddPointInLineString(curves, 0, transformB);\n            const indexA00 = indexA0;\n            const indexB00 = indexB0;\n            let indexA1 = 0;\n            let indexB1 = 0;\n            for (let i = 1; i < numPoints; i++) {\n                indexA1 = this.findOrAddPointInLineString(curves, i, transformA);\n                indexB1 = this.findOrAddPointInLineString(curves, i, transformB);\n                this.addIndexedQuadPointIndexes(indexA0, indexA1, indexB0, indexB1);\n                indexA0 = indexA1;\n                indexB0 = indexB1;\n            }\n            if (addClosure)\n                this.addIndexedQuadPointIndexes(indexA0, indexA00, indexB0, indexB00);\n        }\n        else {\n            const children = curves.children;\n            // just send the children individually -- final s will fix things??\n            if (children)\n                for (const c of children) {\n                    this.addBetweenTransformedLineStrings(c, transformA, transformB);\n                }\n        }\n    }\n    addBetweenStrokeSetPair(dataA, vA, dataB, vB) {\n        if (dataA instanceof LineString3d && dataB instanceof LineString3d) {\n            this.addBetweenLineStringsWithRuleEdgeNormals(dataA, vA, dataB, vB, false);\n        }\n        else if (dataA instanceof ParityRegion && dataB instanceof ParityRegion) {\n            if (dataA.children.length === dataB.children.length) {\n                for (let i = 0; i < dataA.children.length; i++) {\n                    this.addBetweenStrokeSetPair(dataA.children[i], vA, dataB.children[i], vB);\n                }\n            }\n        }\n        else if (dataA instanceof CurveChain && dataB instanceof CurveChain) {\n            const chainA = dataA.children;\n            const chainB = dataB.children;\n            if (chainA.length === chainB.length) {\n                for (let i = 0; i < chainA.length; i++) {\n                    const cpA = chainA[i];\n                    const cpB = chainB[i];\n                    if (cpA instanceof LineString3d && cpB instanceof LineString3d) {\n                        this.addBetweenLineStringsWithRuleEdgeNormals(cpA, vA, cpB, vB);\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Add facets from a Cone\n     */\n    addCone(cone) {\n        // ensure identical stroke counts at each end . . .\n        let strokeCount = 16;\n        if (this._options)\n            strokeCount = this._options.applyTolerancesToArc(cone.getMaxRadius());\n        let axisStrokeCount = 1;\n        const lineStringA = cone.strokeConstantVSection(0.0, strokeCount, this._options);\n        const lineStringB = cone.strokeConstantVSection(1.0, strokeCount, this._options);\n        if (this._options) {\n            const vDistanceRange = GrowableXYZArray.distanceRangeBetweenCorrespondingPoints(lineStringA.packedPoints, lineStringB.packedPoints);\n            axisStrokeCount = this._options.applyMaxEdgeLength(1, vDistanceRange.low);\n        }\n        const sizes = cone.maxIsoParametricDistance();\n        this.addUVGridBody(cone, strokeCount, axisStrokeCount, Segment1d.create(0, sizes.x), Segment1d.create(0, sizes.y));\n        this.endFace();\n        if (cone.capped) {\n            if (!Geometry.isSmallMetricDistance(cone.getRadiusA())) {\n                this.addTrianglesInUncheckedConvexPolygon(lineStringA, true); // lower triangles flip\n                this.endFace();\n            }\n            if (!Geometry.isSmallMetricDistance(cone.getRadiusB())) {\n                this.addTrianglesInUncheckedConvexPolygon(lineStringB, false); // upper triangles to not flip.\n                this.endFace();\n            }\n        }\n    }\n    /**\n     * Add facets for a TorusPipe.\n     */\n    addTorusPipe(surface, phiStrokeCount, thetaStrokeCount) {\n        const thetaFraction = surface.getThetaFraction();\n        const numU = Geometry.clamp(Geometry.resolveNumber(phiStrokeCount, 8), 4, 64);\n        const numV = Geometry.clamp(Geometry.resolveNumber(thetaStrokeCount, Math.ceil(16 * thetaFraction)), 2, 64);\n        this.toggleReversedFacetFlag();\n        const sizes = surface.maxIsoParametricDistance();\n        this.addUVGridBody(surface, numU, numV, Segment1d.create(0, sizes.x), Segment1d.create(0, sizes.y));\n        this.toggleReversedFacetFlag();\n        if (surface.capped && thetaFraction < 1.0) {\n            const centerFrame = surface.getConstructiveFrame();\n            const minorRadius = surface.getMinorRadius();\n            const majorRadius = surface.getMajorRadius();\n            const a = 2 * minorRadius;\n            const r0 = majorRadius - minorRadius;\n            const r1 = majorRadius + minorRadius;\n            const z0 = -minorRadius;\n            const cap0ToLocal = Transform.createRowValues(a, 0, 0, r0, 0, 0, -1, 0, 0, a, 0, z0);\n            const cap0ToWorld = centerFrame.multiplyTransformTransform(cap0ToLocal);\n            const worldToCap0 = cap0ToWorld.inverse();\n            if (worldToCap0) {\n                const ls0 = UVSurfaceOps.createLinestringOnUVLine(surface, 0, 0, 1, 0, numU, false, true);\n                ls0.computeUVFromXYZTransform(worldToCap0);\n                this.addTrianglesInUncheckedConvexPolygon(ls0, false);\n            }\n            const thetaRadians = surface.getSweepAngle().radians;\n            const cc = Math.cos(thetaRadians);\n            const ss = Math.sin(thetaRadians);\n            const cap1ToLocal = Transform.createRowValues(-cc * a, 0, -ss, r1 * cc, -ss * a, 0, cc, r1 * ss, 0, a, 0, z0);\n            const cap1ToWorld = centerFrame.multiplyTransformTransform(cap1ToLocal);\n            const worldToCap1 = cap1ToWorld.inverse();\n            if (worldToCap1) {\n                const ls1 = UVSurfaceOps.createLinestringOnUVLine(surface, 1, 1, 0, 1, numU, false, true);\n                ls1.computeUVFromXYZTransform(worldToCap1);\n                this.addTrianglesInUncheckedConvexPolygon(ls1, false);\n            }\n        }\n    }\n    /**\n     * Add point data (no params, normals) for linestrings.\n     * * This recurses through curve chains (loops and paths)\n     * * linestrings are swept\n     * * All other curve types are ignored.\n     * @param vector sweep vector\n     * @param contour contour which contains only linestrings\n     */\n    addLinearSweepLineStringsXYZOnly(contour, vector) {\n        if (contour instanceof LineString3d) {\n            let pointA = Point3d.create();\n            let pointB = Point3d.create();\n            let indexA0 = 0;\n            let indexA1 = 0;\n            let indexB0 = 0;\n            let indexB1 = 0;\n            const n = contour.numPoints();\n            for (let i = 0; i < n; i++) {\n                pointA = contour.pointAt(i, pointA);\n                pointB = pointA.plus(vector, pointB);\n                indexA1 = this.addPoint(pointA);\n                indexB1 = this.addPoint(pointB);\n                if (i > 0) {\n                    this.addIndexedQuadPointIndexes(indexA0, indexA1, indexB0, indexB1);\n                }\n                indexA0 = indexA1;\n                indexB0 = indexB1;\n            }\n        }\n        else if (contour instanceof CurveChain) {\n            for (const ls of contour.children) {\n                this.addLinearSweepLineStringsXYZOnly(ls, vector);\n            }\n        }\n    }\n    /**\n     * Construct facets for a rotational sweep.\n     */\n    addRotationalSweep(surface) {\n        const contour = surface.getCurves();\n        const section0 = StrokeCountSection.createForParityRegionOrChain(contour, this._options);\n        const baseStrokes = section0.getStrokes();\n        const axis = surface.cloneAxisRay();\n        const perpendicularVector = CylindricalRangeQuery.computeMaxVectorFromRay(axis, baseStrokes);\n        const swingVector = axis.direction.crossProduct(perpendicularVector);\n        if (this._options.needNormals)\n            CylindricalRangeQuery.buildRotationalNormalsInLineStrings(baseStrokes, axis, swingVector);\n        const maxDistance = perpendicularVector.magnitude();\n        const maxPath = Math.abs(maxDistance * surface.getSweep().radians);\n        let numStep = StrokeOptions.applyAngleTol(this._options, 1, surface.getSweep().radians, undefined);\n        numStep = StrokeOptions.applyMaxEdgeLength(this._options, numStep, maxPath);\n        for (let i = 1; i <= numStep; i++) {\n            const transformA = surface.getFractionalRotationTransform((i - 1) / numStep);\n            const transformB = surface.getFractionalRotationTransform(i / numStep);\n            this.addBetweenRotatedStrokeSets(baseStrokes, transformA, i - 1, transformB, i);\n        }\n        if (surface.capped) {\n            const capContour = surface.getSweepContourRef();\n            capContour.purgeFacets();\n            capContour.emitFacets(this, true, undefined);\n            // final loop pass left transformA at end ..\n            capContour.emitFacets(this, false, surface.getFractionalRotationTransform(1.0));\n        }\n    }\n    /**\n     * Construct facets for any planar region\n     */\n    addTriangulatedRegion(region) {\n        if (region instanceof UnionRegion) {\n            for (const child of region.children)\n                this.addTriangulatedRegion(child);\n        }\n        const contour = SweepContour.createForLinearSweep(region);\n        if (contour)\n            contour.emitFacets(this, this.reversedFlag, undefined);\n    }\n    /**\n     * * Recursively visit all children of data.\n     * * At each primitive, invoke the computeStrokeCountForOptions method, with options from the builder.\n     * @param data\n     */\n    applyStrokeCountsToCurvePrimitives(data) {\n        const options = this._options;\n        if (data instanceof CurvePrimitive) {\n            data.computeStrokeCountForOptions(options);\n        }\n        else if (data instanceof CurveCollection) {\n            const children = data.children;\n            if (children)\n                for (const child of children) {\n                    this.applyStrokeCountsToCurvePrimitives(child);\n                }\n        }\n    }\n    addBetweenStrokeSetsWithRuledNormals(stroke0, stroke1, numVEdge) {\n        const strokeSets = [stroke0];\n        const fractions = [0.0];\n        for (let vIndex = 1; vIndex < numVEdge; vIndex++) {\n            const vFraction = vIndex / numVEdge;\n            const strokeA = ConstructCurveBetweenCurves.interpolateBetween(stroke0, vIndex / numVEdge, stroke1);\n            strokeSets.push(strokeA);\n            fractions.push(vFraction);\n        }\n        strokeSets.push(stroke1);\n        fractions.push(1.0);\n        for (let vIndex = 0; vIndex < numVEdge; vIndex++) {\n            this.addBetweenStrokeSetPair(strokeSets[vIndex], fractions[vIndex], strokeSets[vIndex + 1], fractions[vIndex + 1]);\n        }\n    }\n    createIndicesInLineString(ls, vParam, transform) {\n        const n = ls.numPoints();\n        {\n            const pointIndices = ls.ensureEmptyPointIndices();\n            const index0 = this.findOrAddPointInLineString(ls, 0, transform);\n            pointIndices.push(index0);\n            if (n > 1) {\n                let indexA = index0;\n                let indexB;\n                for (let i = 1; i + 1 < n; i++) {\n                    indexB = this.findOrAddPointInLineString(ls, i, transform, indexA);\n                    pointIndices.push(indexB);\n                    indexA = indexB;\n                }\n                // assume last point can only repeat back to zero ...\n                indexB = this.findOrAddPointInLineString(ls, n - 1, transform, index0);\n                pointIndices.push(indexB);\n            }\n        }\n        if (this._options.needNormals && ls.packedSurfaceNormals !== undefined) {\n            const normalIndices = ls.ensureEmptyNormalIndices();\n            const normalIndex0 = this.findOrAddNormalInLineString(ls, 0, transform);\n            normalIndices.push(normalIndex0);\n            let normalIndexA = normalIndex0;\n            let normalIndexB;\n            if (n > 1) {\n                for (let i = 1; i + 1 < n; i++) {\n                    normalIndexB = this.findOrAddNormalInLineString(ls, i, transform, normalIndexA);\n                    normalIndices.push(normalIndexB);\n                    normalIndexA = normalIndexB;\n                }\n                // assume last point can only repeat back to zero ...\n                normalIndexB = this.findOrAddNormalInLineString(ls, n - 1, transform, normalIndex0, normalIndexA);\n                normalIndices.push(normalIndexB);\n            }\n        }\n        if (this._options.needParams && ls.packedUVParams !== undefined) {\n            const uvIndices = ls.ensureEmptyUVIndices();\n            const uvIndex0 = this.findOrAddParamInLineString(ls, 0, vParam);\n            uvIndices.push(uvIndex0);\n            let uvIndexA = uvIndex0;\n            let uvIndexB;\n            if (n > 1) {\n                for (let i = 1; i + 1 < n; i++) {\n                    uvIndexB = this.findOrAddParamInLineString(ls, i, vParam, uvIndexA);\n                    uvIndices.push(uvIndexB);\n                    uvIndexA = uvIndexB;\n                }\n                // assume last point can only repeat back to zero ...\n                uvIndexB = this.findOrAddParamInLineString(ls, n - 1, vParam, uvIndexA, uvIndex0);\n                uvIndices.push(uvIndexB);\n            }\n        }\n    }\n    addBetweenRotatedStrokeSets(stroke0, transformA, vA, transformB, vB) {\n        if (stroke0 instanceof LineString3d) {\n            const strokeA = stroke0.cloneTransformed(transformA);\n            this.createIndicesInLineString(strokeA, vA);\n            const strokeB = stroke0.cloneTransformed(transformB);\n            this.createIndicesInLineString(strokeB, vB);\n            this.addBetweenLineStringsWithStoredIndices(strokeA, strokeB);\n        }\n        else if (stroke0 instanceof ParityRegion) {\n            for (let i = 0; i < stroke0.children.length; i++) { // eslint-disable-line @typescript-eslint/prefer-for-of\n                this.addBetweenRotatedStrokeSets(stroke0.children[i], transformA, vA, transformB, vB);\n            }\n        }\n        else if (stroke0 instanceof CurveChain) {\n            const chainA = stroke0.children;\n            for (let i = 0; i < chainA.length; i++) { // eslint-disable-line @typescript-eslint/prefer-for-of\n                const cpA = chainA[i];\n                if (cpA instanceof LineString3d) {\n                    this.addBetweenRotatedStrokeSets(cpA, transformA, vA, transformB, vB);\n                }\n            }\n        }\n    }\n    /**\n     *\n     * Add facets from\n     * * The swept contour\n     * * each cap.\n     */\n    addLinearSweep(surface) {\n        const contour = surface.getCurvesRef();\n        const section0 = StrokeCountSection.createForParityRegionOrChain(contour, this._options);\n        const stroke0 = section0.getStrokes();\n        const sweepVector = surface.cloneSweepVector();\n        const sweepTransform = Transform.createTranslation(sweepVector);\n        const stroke1 = stroke0.cloneTransformed(sweepTransform);\n        const numVEdge = this._options.applyMaxEdgeLength(1, sweepVector.magnitude());\n        this.addBetweenStrokeSetsWithRuledNormals(stroke0, stroke1, numVEdge);\n        if (surface.capped && contour.isAnyRegionType) {\n            const contourA = surface.getSweepContourRef();\n            contourA.purgeFacets();\n            contourA.emitFacets(this, true, undefined);\n            contourA.emitFacets(this, false, sweepTransform);\n        }\n    }\n    /**\n     * Add facets from a ruled sweep.\n     */\n    addRuledSweep(surface) {\n        const contours = surface.sweepContoursRef();\n        let stroke0;\n        let stroke1;\n        const sectionMaps = [];\n        for (let i = 0; i < contours.length; i++) { // eslint-disable-line @typescript-eslint/prefer-for-of\n            sectionMaps.push(StrokeCountSection.createForParityRegionOrChain(contours[i].curves, this._options));\n        }\n        if (StrokeCountSection.enforceStrokeCountCompatibility(sectionMaps)) {\n            StrokeCountSection.enforceCompatibleDistanceSums(sectionMaps);\n            for (let i = 0; i < contours.length; i++) {\n                stroke1 = sectionMaps[i].getStrokes();\n                if (!stroke1)\n                    stroke1 = contours[i].curves.cloneStroked();\n                if (i > 0 && stroke0 && stroke1) {\n                    const distanceRange = Range1d.createNull();\n                    if (StrokeCountSection.extendDistanceRangeBetweenStrokes(stroke0, stroke1, distanceRange)\n                        && !distanceRange.isNull) {\n                        const numVEdge = this._options.applyMaxEdgeLength(1, distanceRange.high);\n                        this.addBetweenStrokeSetsWithRuledNormals(stroke0, stroke1, numVEdge);\n                    }\n                }\n                stroke0 = stroke1;\n            }\n        }\n        if (surface.capped && contours[0].curves.isAnyRegionType) {\n            contours[0].purgeFacets();\n            contours[0].emitFacets(this, true, undefined);\n            contours[contours.length - 1].purgeFacets();\n            contours[contours.length - 1].emitFacets(this, false, undefined);\n        }\n        return true;\n    }\n    /**\n     * Add facets from a Sphere\n     */\n    addSphere(sphere, strokeCount) {\n        let numStrokeTheta = strokeCount ? strokeCount : this.options.applyTolerancesToArc(sphere.maxAxisRadius());\n        if (Geometry.isOdd(numStrokeTheta))\n            numStrokeTheta += 1;\n        const numStrokePhi = Geometry.clampToStartEnd(Math.abs(numStrokeTheta * sphere.latitudeSweepFraction), 1, Math.ceil(numStrokeTheta * 0.5));\n        const lineStringA = sphere.strokeConstantVSection(0.0, numStrokeTheta, this._options);\n        if (sphere.capped && !Geometry.isSmallMetricDistance(lineStringA.quickLength())) {\n            this.addTrianglesInUncheckedConvexPolygon(lineStringA, true); // lower triangles flip\n            this.endFace();\n        }\n        const sizes = sphere.maxIsoParametricDistance();\n        this.addUVGridBody(sphere, numStrokeTheta, numStrokePhi, Segment1d.create(0, sizes.x), Segment1d.create(0, sizes.y));\n        this.endFace();\n        const lineStringB = sphere.strokeConstantVSection(1.0, numStrokeTheta, this._options);\n        if (sphere.capped && !Geometry.isSmallMetricDistance(lineStringB.quickLength())) {\n            this.addTrianglesInUncheckedConvexPolygon(lineStringB, false); // upper triangles do not flip\n            this.endFace();\n        }\n    }\n    /**\n     * Add facets from a Box\n     */\n    addBox(box) {\n        const corners = box.getCorners();\n        const xLength = Geometry.maxXY(box.getBaseX(), box.getBaseX());\n        const yLength = Geometry.maxXY(box.getBaseY(), box.getTopY());\n        let zLength = 0.0;\n        for (let i = 0; i < 4; i++) {\n            zLength = Geometry.maxXY(zLength, corners[i].distance(corners[i + 4]));\n        }\n        const numX = this._options.applyMaxEdgeLength(1, xLength);\n        const numY = this._options.applyMaxEdgeLength(1, yLength);\n        const numZ = this._options.applyMaxEdgeLength(1, zLength);\n        // Wrap the 4 out-of-plane faces as a single parameters space with \"distance\" advancing in x then y then negative x then negative y ...\n        const uParamRange = Segment1d.create(0, xLength);\n        const vParamRange = Segment1d.create(0, zLength);\n        this.addUVGridBody(BilinearPatch.create(corners[0], corners[1], corners[4], corners[5]), numX, numZ, uParamRange, vParamRange);\n        uParamRange.shift(xLength);\n        this.addUVGridBody(BilinearPatch.create(corners[1], corners[3], corners[5], corners[7]), numY, numZ, uParamRange, vParamRange);\n        uParamRange.shift(yLength);\n        this.addUVGridBody(BilinearPatch.create(corners[3], corners[2], corners[7], corners[6]), numX, numZ, uParamRange, vParamRange);\n        uParamRange.shift(xLength);\n        this.addUVGridBody(BilinearPatch.create(corners[2], corners[0], corners[6], corners[4]), numY, numZ, uParamRange, vParamRange);\n        // finally end that wraparound face !!\n        this.endFace();\n        if (box.capped) {\n            uParamRange.set(0.0, xLength);\n            vParamRange.set(0.0, yLength);\n            this.addUVGridBody(BilinearPatch.create(corners[4], corners[5], corners[6], corners[7]), numX, numY, uParamRange, vParamRange);\n            this.endFace();\n            uParamRange.set(0.0, xLength);\n            vParamRange.set(0.0, yLength);\n            this.addUVGridBody(BilinearPatch.create(corners[2], corners[3], corners[0], corners[1]), numX, numY, uParamRange, vParamRange);\n            this.endFace();\n        }\n    }\n    /** Add a polygon to the evolving facets.\n     *\n     * * Add points to the polyface\n     * * indices are added (in reverse order if indicated by the builder state)\n     * @param points array of points.  This may contain extra points not to be used in the polygon\n     * @param numPointsToUse number of points to use.\n     */\n    addPolygon(points, numPointsToUse) {\n        // don't use trailing points that match start point.\n        if (numPointsToUse === undefined)\n            numPointsToUse = points.length;\n        while (numPointsToUse > 1 && points[numPointsToUse - 1].isAlmostEqual(points[0]))\n            numPointsToUse--;\n        let index = 0;\n        if (!this._reversed) {\n            for (let i = 0; i < numPointsToUse; i++) {\n                index = this.addPoint(points[i]);\n                this._polyface.addPointIndex(index);\n            }\n        }\n        else {\n            for (let i = numPointsToUse; --i >= 0;) {\n                index = this.addPoint(points[i]);\n                this._polyface.addPointIndex(index);\n            }\n        }\n        this._polyface.terminateFacet();\n    }\n    /** Add a polygon to the evolving facets.\n     *\n     * * Add points to the polyface\n     * * indices are added (in reverse order if indicated by the builder state)\n     * * Arrays with 2 or fewer points are ignored.\n     * @param points array of points. Trailing closure points are ignored.\n     */\n    addPolygonGrowableXYZArray(points) {\n        // don't use trailing points that match start point.\n        let numPointsToUse = points.length;\n        while (numPointsToUse > 2 && Geometry.isSmallMetricDistance(points.distanceIndexIndex(0, numPointsToUse - 1)))\n            numPointsToUse--;\n        // strip trailing duplicates\n        while (numPointsToUse > 2 && Geometry.isSmallMetricDistance(points.distanceIndexIndex(numPointsToUse - 2, numPointsToUse - 1)))\n            numPointsToUse--;\n        // ignore triangles for which the height is less than smallMetricDistance times length\n        // sum of edge lengths is twice the perimeter.   If it is flat that's twice the largest base dimension.\n        // cross product magnitude is twice the area.\n        if (numPointsToUse === 3) {\n            const cross = points.crossProductIndexIndexIndex(0, 1, 2);\n            const q = cross.magnitude();\n            const p = points.distanceIndexIndex(0, 1) + points.distanceIndexIndex(0, 2) + points.distanceIndexIndex(1, 2);\n            if (q < Geometry.smallMetricDistance * p)\n                numPointsToUse = 0;\n        }\n        if (numPointsToUse > 2) {\n            let index = 0;\n            if (!this._reversed) {\n                for (let i = 0; i < numPointsToUse; i++) {\n                    index = this.findOrAddPointInGrowableXYZArray(points, i);\n                    this._polyface.addPointIndex(index);\n                }\n            }\n            else {\n                for (let i = numPointsToUse; --i >= 0;) {\n                    index = this.findOrAddPointInGrowableXYZArray(points, i);\n                    this._polyface.addPointIndex(index);\n                }\n            }\n            this._polyface.terminateFacet();\n        }\n    }\n    /** Add a polygon to the evolving facets.\n     * * add points to the polyface\n     * * compute each point index as the point is added\n     * * all data arrays are parallel to the point array\n     * * point indices are added in reverse order if indicated by the builder state\n     * @param points array of vertices in order around the facet\n     * @param normals optional array of normals, one per vertex\n     * @param params optional array of uv-parameters, one per vertex\n     * @param colors optional array of colors, one per vertex\n     * @param edgeVisible optional array of flags, one per vertex, true iff edge starting at corresponding vertex is visible\n     */\n    addFacetFromGrowableArrays(points, normals, params, colors, edgeVisible) {\n        // don't use trailing points that match start point.\n        let numPointsToUse = points.length;\n        while (numPointsToUse > 1 && Geometry.isSmallMetricDistance(points.distanceIndexIndex(0, numPointsToUse - 1)))\n            numPointsToUse--;\n        let index = 0;\n        if (normals && normals.length < numPointsToUse)\n            normals = undefined;\n        if (params && params.length < numPointsToUse)\n            params = undefined;\n        if (colors && colors.length < numPointsToUse)\n            colors = undefined;\n        if (edgeVisible && edgeVisible.length < numPointsToUse)\n            edgeVisible = undefined;\n        if (!this._reversed) {\n            for (let i = 0; i < numPointsToUse; i++) {\n                index = this.findOrAddPointInGrowableXYZArray(points, i);\n                this._polyface.addPointIndex(index, edgeVisible ? edgeVisible[i] : true);\n                if (normals) {\n                    index = this.findOrAddNormalInGrowableXYZArray(normals, i);\n                    this._polyface.addNormalIndex(index);\n                }\n                if (params) {\n                    index = this.addParamInGrowableXYArray(params, i);\n                    this._polyface.addParamIndex(index);\n                }\n                if (colors) {\n                    index = this._polyface.addColor(colors[i]);\n                    this._polyface.addColorIndex(index);\n                }\n            }\n        }\n        else {\n            for (let i = numPointsToUse; --i >= 0;) {\n                index = this.findOrAddPointInGrowableXYZArray(points, i);\n                this._polyface.addPointIndex(index);\n                if (normals) {\n                    index = this.findOrAddNormalInGrowableXYZArray(normals, i);\n                    this._polyface.addNormalIndex(index);\n                }\n                if (params) {\n                    index = this.addParamInGrowableXYArray(params, i);\n                    this._polyface.addParamIndex(index);\n                }\n                if (colors) {\n                    index = this._polyface.addColor(colors[i]);\n                    this._polyface.addColorIndex(index);\n                }\n            }\n        }\n        this._polyface.terminateFacet();\n    }\n    /** Add the current visitor facet to the evolving polyface.\n     * * indices are added (in reverse order if indicated by the builder state)\n     */\n    addFacetFromVisitor(visitor) {\n        this.addFacetFromGrowableArrays(visitor.point, visitor.normal, visitor.param, visitor.color, visitor.edgeVisible);\n    }\n    /** Add a polyface, with optional reverse and transform. */\n    addIndexedPolyface(source, reversed, transform) {\n        this._polyface.addIndexedPolyface(source, reversed, transform);\n    }\n    /**\n     * Produce a new FacetFaceData for all terminated facets since construction of the previous face.\n     * Each facet number/index is mapped to the FacetFaceData through the faceToFaceData array.\n     * Returns true if successful, and false otherwise.\n     */\n    endFace() {\n        return this._polyface.setNewFaceData();\n    }\n    /** Double dispatch handler for Cone */\n    handleCone(g) { return this.addCone(g); }\n    /** Double dispatch handler for TorusPipe */\n    handleTorusPipe(g) { return this.addTorusPipe(g); }\n    /** Double dispatch handler for Sphere */\n    handleSphere(g) { return this.addSphere(g); }\n    /** Double dispatch handler for Box */\n    handleBox(g) { return this.addBox(g); }\n    /** Double dispatch handler for LinearSweep */\n    handleLinearSweep(g) { return this.addLinearSweep(g); }\n    /** Double dispatch handler for RotationalSweep */\n    handleRotationalSweep(g) { return this.addRotationalSweep(g); }\n    /** Double dispatch handler for RuledSweep */\n    handleRuledSweep(g) { return this.addRuledSweep(g); }\n    /** Double dispatch handler for Loop */\n    handleLoop(g) { return this.addTriangulatedRegion(g); }\n    /** Double dispatch handler for ParityRegion */\n    handleParityRegion(g) { return this.addTriangulatedRegion(g); }\n    /** Double dispatch handler for UnionRegion */\n    handleUnionRegion(g) { return this.addTriangulatedRegion(g); }\n    /** add facets for a GeometryQuery object.   This is double dispatch through `dispatchToGeometryHandler(this)` */\n    addGeometryQuery(g) { g.dispatchToGeometryHandler(this); }\n    /**\n     *\n     * * Visit all faces\n     * * Test each face with f(node) for any node on the face.\n     * * For each face that passes, pass its coordinates to the builder.\n     * * Rely on the builder's compress step to find common vertex coordinates\n     * @internal\n     */\n    addGraph(graph, needParams, acceptFaceFunction = (node) => HalfEdge.testNodeMaskNotExterior(node), isEdgeVisibleFunction = (node) => HalfEdge.testMateMaskExterior(node)) {\n        let index = 0;\n        const needNormals = this._options.needNormals;\n        let normalIndex = 0;\n        if (needNormals)\n            normalIndex = this._polyface.addNormalXYZ(0, 0, 1); // big assumption !!!!  someday check if that's where the facets actually are!!\n        graph.announceFaceLoops((_graph, seed) => {\n            if (acceptFaceFunction(seed) && seed.countEdgesAroundFace() > 2) {\n                let node = seed;\n                do {\n                    index = this.addPointXYZ(node.x, node.y, node.z);\n                    this._polyface.addPointIndex(index, isEdgeVisibleFunction === undefined ? true : isEdgeVisibleFunction(node));\n                    if (needParams) {\n                        index = this.addParamXY(node.x, node.y);\n                        this._polyface.addParamIndex(index);\n                    }\n                    if (needNormals) {\n                        this._polyface.addNormalIndex(normalIndex);\n                    }\n                    node = node.faceSuccessor;\n                } while (node !== seed);\n                this._polyface.terminateFacet();\n            }\n            return true;\n        });\n    }\n    /**\n     *\n     * * For each node in `faces`\n     *  * add all of its vertices to the polyface\n     *  * add point indices to form a new facet.\n     *    * (Note: no normal or param indices are added)\n     *  * terminate the facet\n     * @internal\n     */\n    addGraphFaces(_graph, faces) {\n        let index = 0;\n        for (const seed of faces) {\n            let node = seed;\n            do {\n                index = this.addPointXYZ(node.x, node.y, node.z);\n                this._polyface.addPointIndex(index);\n                node = node.faceSuccessor;\n            } while (node !== seed);\n            this._polyface.terminateFacet();\n        }\n    }\n    /** Create a polyface containing the faces of a HalfEdgeGraph, with test function to filter faces.\n     * @internal\n     */\n    static graphToPolyface(graph, options, acceptFaceFunction = (node) => HalfEdge.testNodeMaskNotExterior(node)) {\n        const builder = PolyfaceBuilder.create(options);\n        builder.addGraph(graph, builder.options.needParams, acceptFaceFunction);\n        builder.endFace();\n        return builder.claimPolyface();\n    }\n    /** Create a polyface containing the faces of a HalfEdgeGraph that are specified by the HalfEdge array.\n     * @internal\n     */\n    static graphFacesToPolyface(graph, faces) {\n        const builder = PolyfaceBuilder.create();\n        builder.addGraphFaces(graph, faces);\n        builder.endFace();\n        return builder.claimPolyface();\n    }\n    /** Create a polyface containing triangles in a (space) polygon.\n     * * The polyface contains only coordinate data (no params or normals).\n     */\n    static polygonToTriangulatedPolyface(points, localToWorld) {\n        if (!localToWorld)\n            localToWorld = FrameBuilder.createFrameWithCCWPolygon(points);\n        if (localToWorld) {\n            const localPoints = localToWorld.multiplyInversePoint3dArray(points);\n            const areaXY = PolygonOps.areaXY(localPoints);\n            if (areaXY < 0.0)\n                localPoints.reverse();\n            const graph = Triangulator.createTriangulatedGraphFromSingleLoop(localPoints);\n            if (graph) {\n                const polyface = this.graphToPolyface(graph);\n                polyface.tryTransformInPlace(localToWorld);\n                return polyface;\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Given arrays of coordinates for multiple facets.\n     * * pointArray[i] is an array of 3 or 4 points\n     * * paramArray[i] is an array of matching number of params\n     * * normalArray[i] is an array of matching number of normals.\n     * @param pointArray array of arrays of point coordinates\n     * @param paramArray array of arrays of uv parameters\n     * @param normalArray array of arrays of normals\n     * @param endFace if true, call this.endFace after adding all the facets.\n     */\n    addCoordinateFacets(pointArray, paramArray, normalArray, endFace = false) {\n        for (let i = 0; i < pointArray.length; i++) {\n            const params = paramArray ? paramArray[i] : undefined;\n            const normals = normalArray ? normalArray[i] : undefined;\n            if (pointArray[i].length === 3)\n                this.addTriangleFacet(pointArray[i], params, normals);\n            else if (pointArray[i].length === 4)\n                this.addQuadFacet(pointArray[i], params, normals);\n        }\n        if (endFace)\n            this.endFace();\n    }\n    /**\n     * * Evaluate `(numU + 1) * (numV + 1)` grid points (in 0..1 in both u and v) on a surface.\n     * * Add the facets for `numU * numV` quads.\n     * * uv params are the 0..1 fractions.\n     * * normals are cross products of u and v direction partial derivatives.\n     * @param surface\n     * @param numU number of intervals (edges) in the u direction.  (Number of points is `numU + 1`)\n     * @param numV number of intervals (edges) in the v direction.  (Number of points is `numV + 1`)\n     * @param uMap optional mapping from u fraction to parameter space (such as texture)\n     * @param vMap optional mapping from v fraction to parameter space (such as texture)\n     */\n    addUVGridBody(surface, numU, numV, uMap, vMap) {\n        let xyzIndex0 = new GrowableFloat64Array(numU);\n        let xyzIndex1 = new GrowableFloat64Array(numU);\n        let paramIndex0;\n        let paramIndex1;\n        let normalIndex0;\n        let normalIndex1;\n        const reverse = this._reversed;\n        const needNormals = this.options.needNormals;\n        if (needNormals) {\n            normalIndex0 = new GrowableFloat64Array(numU);\n            normalIndex1 = new GrowableFloat64Array(numU);\n        }\n        const needParams = this.options.needParams;\n        if (needParams) {\n            paramIndex0 = new GrowableFloat64Array(numU);\n            paramIndex1 = new GrowableFloat64Array(numU);\n        }\n        let indexSwap;\n        xyzIndex0.ensureCapacity(numU);\n        xyzIndex1.ensureCapacity(numU);\n        const uv = Point2d.create();\n        const normal = Vector3d.create();\n        const du = 1.0 / numU;\n        const dv = 1.0 / numV;\n        const plane = Plane3dByOriginAndVectors.createXYPlane();\n        for (let v = 0; v <= numV; v++) {\n            // evaluate new points ....\n            xyzIndex1.clear();\n            if (needNormals)\n                normalIndex1.clear();\n            if (needParams)\n                paramIndex1.clear();\n            for (let u = 0; u <= numU; u++) {\n                const uFrac = u * du;\n                const vFrac = v * dv;\n                surface.uvFractionToPointAndTangents(uFrac, vFrac, plane);\n                xyzIndex1.push(this._polyface.addPoint(plane.origin));\n                if (needNormals) {\n                    plane.vectorU.crossProduct(plane.vectorV, normal);\n                    normal.normalizeInPlace();\n                    if (reverse)\n                        normal.scaleInPlace(-1.0);\n                    normalIndex1.push(this._polyface.addNormal(normal));\n                }\n                if (needParams)\n                    paramIndex1.push(this._polyface.addParam(Point2d.create(uMap ? uMap.fractionToPoint(uFrac) : uFrac, vMap ? vMap.fractionToPoint(vFrac) : vFrac, uv)));\n            }\n            if (v > 0) {\n                for (let u = 0; u < numU; u++) {\n                    if (!this._options.shouldTriangulate) {\n                        this.addIndexedQuadPointIndexes(xyzIndex0.atUncheckedIndex(u), xyzIndex0.atUncheckedIndex(u + 1), xyzIndex1.atUncheckedIndex(u), xyzIndex1.atUncheckedIndex(u + 1), false);\n                        if (needNormals)\n                            this.addIndexedQuadNormalIndexes(normalIndex0.atUncheckedIndex(u), normalIndex0.atUncheckedIndex(u + 1), normalIndex1.atUncheckedIndex(u), normalIndex1.atUncheckedIndex(u + 1));\n                        if (needParams)\n                            this.addIndexedQuadParamIndexes(paramIndex0.atUncheckedIndex(u), paramIndex0.atUncheckedIndex(u + 1), paramIndex1.atUncheckedIndex(u), paramIndex1.atUncheckedIndex(u + 1));\n                        this._polyface.terminateFacet();\n                    }\n                    else {\n                        this.addIndexedTrianglePointIndexes(xyzIndex0.atUncheckedIndex(u), xyzIndex0.atUncheckedIndex(u + 1), xyzIndex1.atUncheckedIndex(u), false);\n                        if (needNormals)\n                            this.addIndexedTriangleNormalIndexes(normalIndex0.atUncheckedIndex(u), normalIndex0.atUncheckedIndex(u + 1), normalIndex1.atUncheckedIndex(u));\n                        if (needParams)\n                            this.addIndexedTriangleParamIndexes(paramIndex0.atUncheckedIndex(u), paramIndex0.atUncheckedIndex(u + 1), paramIndex1.atUncheckedIndex(u));\n                        this._polyface.terminateFacet();\n                        this.addIndexedTrianglePointIndexes(xyzIndex1.atUncheckedIndex(u), xyzIndex0.atUncheckedIndex(u + 1), xyzIndex1.atUncheckedIndex(u + 1), false);\n                        if (needNormals)\n                            this.addIndexedTriangleNormalIndexes(normalIndex1.atUncheckedIndex(u), normalIndex0.atUncheckedIndex(u + 1), normalIndex1.atUncheckedIndex(u + 1));\n                        if (needParams)\n                            this.addIndexedTriangleParamIndexes(paramIndex1.atUncheckedIndex(u), paramIndex0.atUncheckedIndex(u + 1), paramIndex1.atUncheckedIndex(u + 1));\n                        this._polyface.terminateFacet();\n                    }\n                }\n            }\n            indexSwap = xyzIndex1;\n            xyzIndex1 = xyzIndex0;\n            xyzIndex0 = indexSwap;\n            if (needParams) {\n                indexSwap = paramIndex1;\n                paramIndex1 = paramIndex0;\n                paramIndex0 = indexSwap;\n            }\n            if (needNormals) {\n                indexSwap = normalIndex1;\n                normalIndex1 = normalIndex0;\n                normalIndex0 = indexSwap;\n            }\n        }\n        xyzIndex0.clear();\n        xyzIndex1.clear();\n    }\n    /**\n     * Triangulate the points as viewed in xy.\n     * @param points\n     */\n    static pointsToTriangulatedPolyface(points) {\n        const graph = Triangulator.createTriangulatedGraphFromPoints(points);\n        if (graph)\n            return PolyfaceBuilder.graphToPolyface(graph);\n        return undefined;\n    }\n    /** Create (and add to the builder) triangles that bridge the gap between two linestrings.\n     * * Each triangle will have 1 vertex on one of the linestrings and 2 on the other\n     * * Choice of triangles is heuristic, hence does not have a unique solution.\n     * * Logic to choice among the various possible triangle orders prefers\n     *    * Make near-coplanar facets\n     *    * make facets with good aspect ratio.\n     *    * This is exercised with a limited number of lookahead points, i.e. greedy to make first-available decision.\n     * @param pointsA points of first linestring.\n     * @param pointsB points of second linestring.\n     */\n    addGreedyTriangulationBetweenLineStrings(pointsA, pointsB) {\n        const context = GreedyTriangulationBetweenLineStrings.createContext();\n        context.emitTriangles(resolveToIndexedXYZCollectionOrCarrier(pointsA), resolveToIndexedXYZCollectionOrCarrier(pointsB), (triangle) => {\n            this.addTriangleFacet(triangle.points);\n        });\n    }\n    addMiteredPipesFromPoints(centerline, sectionData, numFacetAround = 12) {\n        const sections = CurveFactory.createMiteredPipeSections(centerline, sectionData);\n        const pointA0 = Point3d.create();\n        const pointA1 = Point3d.create();\n        const pointB0 = Point3d.create();\n        const pointB1 = Point3d.create();\n        if (numFacetAround < 3)\n            numFacetAround = 3;\n        const df = 1.0 / numFacetAround;\n        for (let i = 1; i < sections.length; i++) {\n            const arcA = sections[i - 1];\n            const arcB = sections[i];\n            arcA.fractionToPoint(0.0, pointA0);\n            arcB.fractionToPoint(0.0, pointB0);\n            for (let k = 1; k <= numFacetAround; k++, pointA0.setFromPoint3d(pointA1), pointB0.setFromPoint3d(pointB1)) {\n                const f = k * df;\n                arcA.fractionToPoint(f, pointA1);\n                arcB.fractionToPoint(f, pointB1);\n                this.addQuadFacet([pointA0, pointB0, pointB1, pointA1]);\n            }\n        }\n    }\n    /**\n     * * Create (and add to the builder) quad facets for a mitered pipe that follows a centerline curve.\n     * * Circular or elliptical pipe cross sections can be specified by supplying either a radius, a pair of semi-axis lengths, or a full Arc3d.\n     *    * For semi-axis length input, x corresponds to an ellipse local axis nominally situated parallel to the xy-plane.\n     *    * The center of Arc3d input is translated to the centerline start point to act as initial cross section.\n     * @param centerline centerline of pipe. If curved, it will be stroked using the builder's StrokeOptions.\n     * @param sectionData circle radius, ellipse semi-axis lengths, or full Arc3d\n     * @param numFacetAround how many equal parameter-space chords around each section\n     */\n    addMiteredPipes(centerline, sectionData, numFacetAround = 12) {\n        if (Array.isArray(centerline)) {\n            this.addMiteredPipesFromPoints(new Point3dArrayCarrier(centerline), sectionData, numFacetAround);\n        }\n        else if (centerline instanceof GrowableXYZArray) {\n            this.addMiteredPipesFromPoints(centerline, sectionData, numFacetAround);\n        }\n        else if (centerline instanceof IndexedXYZCollection) {\n            this.addMiteredPipesFromPoints(centerline, sectionData, numFacetAround);\n        }\n        else if (centerline instanceof LineString3d) {\n            this.addMiteredPipesFromPoints(centerline.packedPoints, sectionData, numFacetAround);\n        }\n        else if (centerline instanceof GeometryQuery) {\n            const linestring = LineString3d.create();\n            centerline.emitStrokes(linestring, this._options);\n            this.addMiteredPipesFromPoints(linestring.packedPoints, sectionData, numFacetAround);\n        }\n    }\n    /** Return the polyface index array indices corresponding to the given edge, or undefined if error. */\n    getEdgeIndices(edge) {\n        let indexA = -1;\n        let indexB = -1;\n        for (let i = this._polyface.facetIndex0(edge.facetIndex); i < this._polyface.facetIndex1(edge.facetIndex); ++i) {\n            if (edge.vertexIndexA === this._polyface.data.pointIndex[i])\n                indexA = i;\n            else if (edge.vertexIndexB === this._polyface.data.pointIndex[i])\n                indexB = i;\n        }\n        return (indexA < 0 || indexB < 0) ? undefined : { edgeIndexA: indexA, edgeIndexB: indexB };\n    }\n    /** Create a side face between base and swept facets along a base boundary edge.\n     * * Assumes numBaseFacets base facets were added to this builder, immediately followed by the same number of swept facets with opposite orientation (first index not preserved).\n    */\n    addSweptFace(baseBoundaryEdge, numBaseFacets) {\n        const edge = this.getEdgeIndices(baseBoundaryEdge);\n        if (undefined === edge)\n            return false;\n        const sweptFacetIndex = numBaseFacets + baseBoundaryEdge.facetIndex;\n        if (!this._polyface.isValidFacetIndex(sweptFacetIndex))\n            return false;\n        const numBaseFacetEdges = this._polyface.numEdgeInFacet(baseBoundaryEdge.facetIndex);\n        if (numBaseFacetEdges !== this._polyface.numEdgeInFacet(sweptFacetIndex))\n            return false;\n        // generate indices into the polyface index arrays\n        const baseFacetIndexStart = this._polyface.facetIndex0(baseBoundaryEdge.facetIndex);\n        const sweptFacetIndexStart = this._polyface.facetIndex0(sweptFacetIndex);\n        const edgeIndexOffsetInFaceLoopA = edge.edgeIndexA - baseFacetIndexStart;\n        const edgeIndexOffsetInFaceLoopB = edge.edgeIndexB - baseFacetIndexStart;\n        const sweptEdgeIndexOffsetInFaceLoopA = (numBaseFacetEdges - 1) - edgeIndexOffsetInFaceLoopA;\n        const sweptEdgeIndexOffsetInFaceLoopB = (numBaseFacetEdges - 1) - edgeIndexOffsetInFaceLoopB;\n        const indices = [edge.edgeIndexB, edge.edgeIndexA, sweptFacetIndexStart + sweptEdgeIndexOffsetInFaceLoopA, sweptFacetIndexStart + sweptEdgeIndexOffsetInFaceLoopB];\n        const vertices = [];\n        let colors; // try to re-use colors; missing normals and params will be computed if needed\n        if (undefined !== this.options.needColors && undefined !== this._polyface.data.color && undefined !== this._polyface.data.colorIndex)\n            colors = [];\n        for (let i = 0; i < 4; ++i) {\n            const xyz = this._polyface.data.getPoint(this._polyface.data.pointIndex[indices[i]]);\n            if (undefined === xyz)\n                return false;\n            vertices.push(xyz);\n            if (undefined !== colors) {\n                const color = this._polyface.data.getColor(this._polyface.data.colorIndex[indices[i]]);\n                if (undefined === color)\n                    return false;\n                colors.push(color);\n            }\n        }\n        this.addQuadFacet(vertices, undefined, undefined, colors);\n        return true;\n    }\n    /**\n     * Add facets from the source polyface, from its translation along the vector, and from its swept boundary edges, to form a polyface that encloses a volume.\n     * @param source the surface mesh to sweep\n     * @param sweepVector the direction and length to sweep the surface mesh\n     * @param triangulateSides whether to triangulate side facets, or leave as quads\n     * @returns whether the added facets comprise a simple sweep. If false, the resulting mesh may have self-intersections, be non-manifold, have inconsistently oriented facets, etc.\n     */\n    addSweptIndexedPolyface(source, sweepVector, triangulateSides = false) {\n        let isSimpleSweep = true;\n        const totalProjectedArea = PolyfaceQuery.sumFacetAreas(source, sweepVector);\n        if (Geometry.isAlmostEqualNumber(0.0, totalProjectedArea))\n            isSimpleSweep = false;\n        const partitionedIndices = PolyfaceQuery.partitionFacetIndicesByVisibilityVector(source, sweepVector, Angle.createDegrees(1.0e-3));\n        const numForwardFacets = partitionedIndices[0].length;\n        const numBackwardFacets = partitionedIndices[1].length;\n        const numSideFacets = partitionedIndices[2].length;\n        if (numSideFacets > 0)\n            isSimpleSweep = false;\n        if (numForwardFacets > 0 && numBackwardFacets > 0)\n            isSimpleSweep = false;\n        // add base and swept facets with opposite orientations\n        const reverseBase = numForwardFacets > 0;\n        const firstBaseFacet = this._polyface.facetCount;\n        this.addIndexedPolyface(source, reverseBase);\n        const firstSweptFacet = this._polyface.facetCount;\n        this.addIndexedPolyface(source, !reverseBase, Transform.createTranslation(sweepVector));\n        // collect base edges added to the builder, and extract boundary\n        const numBaseFacets = firstSweptFacet - firstBaseFacet;\n        const baseFacetIndices = Array.from({ length: numBaseFacets }, (_, i) => firstBaseFacet + i);\n        const baseFacetVisitor = IndexedPolyfaceSubsetVisitor.createSubsetVisitor(this._polyface, baseFacetIndices, 1);\n        const baseEdges = PolyfaceQuery.createIndexedEdges(baseFacetVisitor);\n        const baseBoundaryEdges = [];\n        baseEdges.sortAndCollectClusters(undefined, baseBoundaryEdges, undefined, undefined);\n        // add a side face per boundary edge\n        const oldShouldTriangulate = this._options.shouldTriangulate;\n        this._options.shouldTriangulate = triangulateSides;\n        for (const edgeOrCluster of baseBoundaryEdges) {\n            if (edgeOrCluster instanceof SortableEdge)\n                this.addSweptFace(edgeOrCluster, numBaseFacets);\n            else if (Array.isArray(edgeOrCluster))\n                for (const edge of edgeOrCluster)\n                    this.addSweptFace(edge, numBaseFacets);\n        }\n        this._options.shouldTriangulate = oldShouldTriangulate;\n        return isSimpleSweep;\n    }\n}\nPolyfaceBuilder._workPointFindOrAddA = Point3d.create();\nPolyfaceBuilder._workVectorFindOrAdd = Vector3d.create();\nPolyfaceBuilder._workUVFindOrAdd = Point2d.create();\nexport { PolyfaceBuilder };\nfunction resolveToIndexedXYZCollectionOrCarrier(points) {\n    if (Array.isArray(points))\n        return new Point3dArrayCarrier(points);\n    if (points instanceof LineString3d)\n        return points.packedPoints;\n    return points;\n}\nfunction distinctIndices(i0, i1, i2) {\n    return i0 !== i1 && i1 !== i2 && i2 !== i0;\n}\n//# sourceMappingURL=PolyfaceBuilder.js.map",
      "start": 1693508123095,
      "end": 1693508123249,
      "sourcemaps": null
    }
  ]
}
