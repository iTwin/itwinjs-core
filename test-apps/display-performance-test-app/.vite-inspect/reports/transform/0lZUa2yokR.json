{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/common/lib/esm/rpc/IModelTileRpcInterface.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module RpcInterface\n */\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { RpcResponseCacheControl } from \"./core/RpcConstants\";\nimport { RpcOperation } from \"./core/RpcOperation\";\nimport { RpcInterface } from \"../RpcInterface\";\nimport { RpcManager } from \"../RpcManager\";\n/** @public */\nclass IModelTileRpcInterface extends RpcInterface {\n    static getClient() { return RpcManager.getClientForInterface(IModelTileRpcInterface); }\n    /*===========================================================================================\n      NOTE: Any add/remove/change to the methods below requires an update of the interface version.\n      NOTE: Please consult the README in this folder for the semantic versioning rules.\n    ===========================================================================================*/\n    /** Get storage config required to download tiles from the tile cache.\n     * @returns undefined if the backend does not support caching. In that case, tiles must be requested using [[generateTileContent]].\n     * @beta\n     */\n    async getTileCacheConfig(_tokenProps) {\n        const response = await this.forward(arguments);\n        return response && { ...response, expiration: new Date(response.expiration) };\n    }\n    /** @internal */\n    async requestTileTreeProps(_tokenProps, _id) { return this.forward(arguments); }\n    /** Ask the backend to generate content for the specified tile. This function, unlike the deprecated `requestTileContent`, does not check the cloud storage tile cache -\n     * Use `CloudStorageTileCache.retrieve` for that.\n     * @returns TileContentSource - if Backend, use retrieveTileContent. If ExternalCache, use TileAdmin.requestCachedTileContent\n     * @internal\n     */\n    async generateTileContent(_rpcProps, _treeId, _contentId, _guid) {\n        return this.forward(arguments);\n    }\n    /** Retrieves tile content from the backend once it's generated by generateTileContent.\n     *  @internal\n     */\n    async retrieveTileContent(_rpcProps, _key) {\n        return this.forward(arguments);\n    }\n    /** @internal */\n    async queryVersionInfo() {\n        return this.forward(arguments);\n    }\n    /** This is a temporary workaround for folks developing authoring applications, to be removed when proper support for such applications is introduced.\n     * Given a set of model Ids, it purges any associated tile tree state on the back-end so that the next request for the tile tree or content will recreate that state.\n     * Invoked after a modification is made to the model(s).\n     * If no array of model Ids is supplied, it purges *all* tile trees, which can be quite inefficient.\n     * @internal\n     */\n    async purgeTileTrees(_tokenProps, _modelIds) { return this.forward(arguments); }\n    /** Requests graphics for a single element in \"iMdl\" format.\n     * @returns graphics in iMdl format, or `undefined` if the element's geometry produced no graphics or the request was canceled before completion.\n     * @throws IModelError on bad request (nonexistent element, duplicate request Id, etc).\n     * @internal\n     */\n    async requestElementGraphics(_rpcProps, _request) {\n        return this.forward(arguments);\n    }\n}\n/** The immutable name of the interface. */\nIModelTileRpcInterface.interfaceName = \"IModelTileRpcInterface\";\n/** The semantic version of the interface. */\nIModelTileRpcInterface.interfaceVersion = \"3.2.0\";\n__decorate([\n    RpcOperation.allowResponseCaching(RpcResponseCacheControl.Immutable) // eslint-disable-line deprecation/deprecation\n], IModelTileRpcInterface.prototype, \"requestTileTreeProps\", null);\nexport { IModelTileRpcInterface };\n//# sourceMappingURL=IModelTileRpcInterface.js.map",
      "start": 1693508120850,
      "end": 1693508120919,
      "sourcemaps": null
    }
  ]
}
