{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/curve/spiral/AustralianRailCorpXYEvaluator.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Curve\n */\nimport { Geometry } from \"../../Geometry\";\nimport { Angle } from \"../../geometry3d/Angle\";\nimport { CubicEvaluator } from \"./CubicEvaluator\";\n/**\n * AustralianRailCorp spiral (also known as New South Wales spiral)\n * * The ultimate curve is a cubic `y = m * x^3`.\n * * `m` is a constant throughout the curve.\n * * Computation of m from the R and L is an complicated sequence, but is only done at construction time.\n * @internal\n */\nexport class AustralianRailCorpXYEvaluator extends CubicEvaluator {\n    constructor(nominalLength1, nominalRadius1, axisLength, cubicM) {\n        super(axisLength, cubicM);\n        this._nominalLength1 = nominalLength1;\n        this._nominalRadius1 = nominalRadius1;\n    }\n    get nominalLength1() { return this._nominalLength1; }\n    get nominalRadius1() { return this._nominalRadius1; }\n    clone() { return new AustralianRailCorpXYEvaluator(this._nominalLength1, this._nominalRadius1, this._axisLength, this._cubicM); }\n    static create(nominalLength1, nominalRadius1) {\n        const axisLength = AustralianRailCorpXYEvaluator.radiusAndNominalLengthToAxisLength(nominalRadius1, nominalLength1);\n        const phi = this.radiusAndAxisLengthToPhi(nominalRadius1, axisLength);\n        const xc2 = axisLength * axisLength;\n        const cubicM = Math.tan(phi) / (3.0 * xc2);\n        return new AustralianRailCorpXYEvaluator(nominalLength1, nominalRadius1, axisLength, cubicM);\n    }\n    /**\n     * Compute the phi constant for AustralianRail spiral with given end radius and length along axis.\n     * @param nominalRadius1\n     * @param axisLength\n     */\n    static radiusAndAxisLengthToPhi(nominalRadius1, axisLength) {\n        const xc = axisLength;\n        const expr1 = (2. / Math.sqrt(3.));\n        let expr2 = (-(3. / 4.) * Math.sqrt(3.) * xc / nominalRadius1);\n        if (expr2 < -1.0)\n            expr2 = -1.0;\n        if (expr2 > 1.0)\n            expr2 = 1.0;\n        const expr3 = Angle.degreesToRadians(240);\n        return Math.asin(expr1 * Math.cos(Math.acos(expr2) / 3. + expr3));\n    }\n    scaleInPlace(scaleFactor) {\n        // apply the scale factor to all contents.\n        // all distances scale directly . . .\n        this._nominalLength1 *= scaleFactor;\n        this._nominalRadius1 *= scaleFactor;\n        super.scaleInPlace(scaleFactor);\n    }\n    /** Compute length along axis for AustralianRail spiral nominal radius and length.\n     *\n     */\n    static radiusAndNominalLengthToAxisLength(nominalRadius1, nominalLength1, tolerance = 1.0e-5, requiredConvergenceCount = 2) {\n        const R = nominalRadius1;\n        let idx = 0;\n        let m, phi, xc2;\n        let xc = .7 * nominalLength1;\n        let convergenceCount = 0;\n        // remark: This converges quickly --\n        // for L=100, R=400\n        //   ** full precision at 7th iteration.\n        //   ** classic tolerance 1.0e-5 (7 digits from L) with requiredConvergenceCount = 1 gives 11 digits after 3 iterations\n        //   ** each iteration adds about 2 digits.   This is quite good for a successive replacement without derivative !!!\n        //   ** Unanswerable question: If this is only done once and reused over all evaluations, do you want:\n        //       * run the 7 iterations to get full precision\n        //       * stop with the classic tolerance to get compatibility?\n        for (idx = 0; idx < 100; ++idx) {\n            phi = this.radiusAndAxisLengthToPhi(R, xc);\n            xc2 = xc * xc;\n            m = Math.tan(phi) / (3.0 * xc2);\n            const m2x4 = m * m * xc2 * xc2;\n            const correction = xc * m2x4 * ((9. / 10) + m2x4 * (-(9. / 8.) + m2x4 * (+(729. / 208.) + m2x4 *\n                -(32805. / 2176.))));\n            const correctedLength = xc + correction;\n            xc = (nominalLength1 / correctedLength) * xc;\n            if (Math.abs(nominalLength1 - correctedLength) < tolerance) {\n                convergenceCount++;\n                if (convergenceCount >= requiredConvergenceCount)\n                    break;\n            }\n            else {\n                convergenceCount = 0;\n            }\n        }\n        return xc;\n    }\n    isAlmostEqual(other) {\n        if (other instanceof AustralianRailCorpXYEvaluator) {\n            return Geometry.isAlmostEqualNumber(this._cubicM, other._cubicM)\n                && Geometry.isAlmostEqualNumber(this._axisLength, other._axisLength)\n                && Geometry.isAlmostEqualNumber(this._nominalLength1, other._nominalLength1)\n                && Geometry.isAlmostEqualNumber(this._nominalRadius1, other._nominalRadius1);\n        }\n        return false;\n    }\n    /**\n     * Return a (quite good approximation) of fraction along x axis for given distance along spiral.\n     * * The AustralianRailSpiral has a supporting power series to approximately map distance along the spiral to an x coordinate.\n     * * The `xToFraction(x)` method quickly (with a single divide) converts this x to fraction used fro this.fractionToX (fraction), this.fractionToY(fraction) etc to get coordinates and derivatives.\n     * * The x-to-distance relation is not as precise as the CurvePrimitive method moveSignedDistanceFromFraction.\n     * * It is supported here for users interested in replicating the AustralianRail distance mapping rather than the more accurate CurvePrimitive measurements.\n     * * Round tripping distance through (a) distanceAlongSpiralToAustralianApproximateX, (b) xToFraction, and (c) curveLengthBetweenFractions has\n     *   * 10 digit accuracy for L/R = 4, 12 digit accuracy for L/R = 10\n     * @param s distance along the axis.\n     */\n    distanceAlongSpiralToAustralianApproximateX(s) {\n        const a1 = 0.9000;\n        const a2 = 5.1750;\n        const a3 = 43.1948;\n        const a4 = 426.0564;\n        const m = this._cubicM;\n        const m2s4 = m * m * s * s * s * s;\n        const x = s * (1.0 - m2s4 * (a1 - m2s4 * (a2 - m2s4 * (a3 - m2s4 * a4))));\n        return x;\n    }\n}\n//# sourceMappingURL=AustralianRailCorpXYEvaluator.js.map",
      "start": 1693508124209,
      "end": 1693508124368,
      "sourcemaps": null
    }
  ]
}
