{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tile/map/MapTiledGraphicsProvider.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tiles\n */\nimport { BaseMapLayerSettings } from \"@itwin/core-common\";\nimport { MapTileTreeReference } from \"../internal\";\n/** @internal */\nexport class MapTiledGraphicsProvider {\n    forEachTileTreeRef(viewport, func) {\n        if (viewport.viewFlags.backgroundMap) {\n            func(this.backgroundMap);\n            func(this.overlayMap);\n        }\n    }\n    constructor(viewportId, displayStyle) {\n        this._detachFromDisplayStyle = [];\n        const mapSettings = displayStyle.backgroundMapSettings;\n        const mapImagery = displayStyle.settings.mapImagery;\n        this.backgroundMap = new MapTileTreeReference(mapSettings, mapImagery.backgroundBase, mapImagery.backgroundLayers, displayStyle.iModel, viewportId, false, false, () => displayStyle.overrideTerrainDisplay());\n        this.overlayMap = new MapTileTreeReference(mapSettings, undefined, mapImagery.overlayLayers, displayStyle.iModel, viewportId, true, false);\n        this.backgroundDrapeMap = new MapTileTreeReference(mapSettings, mapImagery.backgroundBase, mapImagery.backgroundLayers, displayStyle.iModel, viewportId, false, true);\n        const removals = this._detachFromDisplayStyle;\n        removals.push(displayStyle.settings.onBackgroundMapChanged.addListener((settings) => {\n            this.backgroundMap.settings = settings;\n            this.overlayMap.settings = settings;\n            this.backgroundDrapeMap.settings = settings;\n        }));\n        removals.push(displayStyle.settings.onMapImageryChanged.addListener((imagery) => {\n            this.backgroundMap.setBaseLayerSettings(imagery.backgroundBase);\n            this.backgroundMap.setLayerSettings(imagery.backgroundLayers);\n            this.backgroundDrapeMap.setBaseLayerSettings(mapImagery.backgroundBase);\n            this.backgroundDrapeMap.setLayerSettings(mapImagery.backgroundLayers);\n            this.overlayMap.setLayerSettings(imagery.overlayLayers);\n        }));\n    }\n    // This is used in inital view setup and when views are synchronized.  If view is being synchronized\n    // we need to clear the layers which purges tile graphics if the settings or layers are changed.\n    setView(newView) {\n        const layersMatch = ((layers1, layers2) => {\n            if (layers1.length !== layers2.length)\n                return false;\n            for (let i = 0; i < layers1.length; i++)\n                if (!layers1[i].displayMatches(layers2[i]))\n                    return false;\n            return true;\n        });\n        const mapImagery = newView.displayStyle.settings.mapImagery;\n        if (!newView.displayStyle.backgroundMapSettings.equals(this.backgroundMap.settings)\n            || !layersMatch(mapImagery.backgroundLayers, this.backgroundMap.layerSettings)\n            || (mapImagery.backgroundBase instanceof BaseMapLayerSettings && !layersMatch([mapImagery.backgroundBase], this.backgroundDrapeMap.layerSettings))) {\n            this.backgroundMap.clearLayers();\n            this.backgroundDrapeMap.clearLayers();\n        }\n        if (!layersMatch(mapImagery.overlayLayers, this.overlayMap.layerSettings))\n            this.overlayMap.clearLayers();\n    }\n    detachFromDisplayStyle() {\n        this._detachFromDisplayStyle.forEach((f) => f());\n        this._detachFromDisplayStyle.length = 0;\n    }\n    /** @internal */\n    getMapLayerImageryProvider(mapLayerIndex) {\n        const imageryTreeRef = mapLayerIndex.isOverlay ? this.overlayMap.getLayerImageryTreeRef(mapLayerIndex.index) : this.backgroundMap.getLayerImageryTreeRef(mapLayerIndex.index);\n        return imageryTreeRef?.imageryProvider;\n    }\n    resetMapLayer(mapLayerIndex) {\n        const imageryTreeRef = mapLayerIndex.isOverlay ? this.overlayMap.getLayerImageryTreeRef(mapLayerIndex.index) : this.backgroundMap.getLayerImageryTreeRef(mapLayerIndex.index);\n        imageryTreeRef?.resetTreeOwner();\n    }\n    /** Return a list of map-layers indexes matching a given MapTile tree Id and a layer imagery tree id.\n     * @internal\n     */\n    getMapLayerIndexesFromIds(mapTreeId, layerTreeId) {\n        const layers = new Array();\n        if (mapTreeId === this.backgroundMap.treeOwner.tileTree?.id) {\n            for (let i = 0; i < this.backgroundMap.layerSettings.length; i++) {\n                if (this.backgroundMap.getLayerImageryTreeRef(i)?.treeOwner.tileTree?.id === layerTreeId) {\n                    layers.push({ index: i, isOverlay: false });\n                }\n            }\n        }\n        else if (mapTreeId === this.overlayMap.treeOwner.tileTree?.id) {\n            for (let i = 0; i < this.overlayMap.layerSettings.length; i++) {\n                if (this.overlayMap.getLayerImageryTreeRef(i)?.treeOwner.tileTree?.id === layerTreeId) {\n                    layers.push({ index: i, isOverlay: true });\n                }\n            }\n        }\n        return layers;\n    }\n    /** @internal */\n    mapLayerFromIds(mapTreeId, layerTreeId) {\n        const bgMapLayers = this.backgroundMap.layerFromTreeModelIds(mapTreeId, layerTreeId);\n        const ovlMapLayers = this.overlayMap.layerFromTreeModelIds(mapTreeId, layerTreeId);\n        return [...bgMapLayers, ...ovlMapLayers];\n    }\n}\n//# sourceMappingURL=MapTiledGraphicsProvider.js.map",
      "start": 1693508121959,
      "end": 1693508122108,
      "sourcemaps": null
    }
  ]
}
