{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/System.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { assert, BentleyStatus, Dictionary, dispose, Id64 } from \"@itwin/core-bentley\";\nimport { ColorDef, Gradient, ImageBuffer, ImageBufferFormat, ImageSourceFormat, IModelError, RenderMaterial, RenderTexture, TextureMapping, TextureTransparency } from \"@itwin/core-common\";\nimport { Capabilities } from \"@itwin/webgl-compatibility\";\nimport { IModelApp } from \"../../IModelApp\";\nimport { IModelConnection } from \"../../IModelConnection\";\nimport { imageElementFromImageSource } from \"../../common/ImageUtil\";\nimport { PrimitiveBuilder } from \"../primitives/geometry/GeometryListBuilder\";\nimport { RenderDiagnostics, RenderSystem, } from \"../RenderSystem\";\nimport { BackgroundMapDrape } from \"./BackgroundMapDrape\";\nimport { SkyBoxQuadsGeometry, SkySphereViewportQuadGeometry } from \"./CachedGeometry\";\nimport { ClipVolume } from \"./ClipVolume\";\nimport { Debug } from \"./Diagnostics\";\nimport { FrameBufferStack } from \"./FrameBuffer\";\nimport { GL } from \"./GL\";\nimport { GLTimer } from \"./GLTimer\";\nimport { AnimationTransformBranch, Batch, Branch, GraphicOwner, GraphicsArray } from \"./Graphic\";\nimport { isInstancedGraphicParams, PatternBuffers } from \"./InstancedGeometry\";\nimport { Layer, LayerContainer } from \"./Layer\";\nimport { LineCode } from \"./LineCode\";\nimport { Material } from \"./Material\";\nimport { MeshGraphic, MeshRenderGeometry } from \"./Mesh\";\nimport { PlanarGridGeometry } from \"./PlanarGrid\";\nimport { PointCloudGeometry } from \"./PointCloud\";\nimport { PointStringGeometry } from \"./PointString\";\nimport { PolylineGeometry } from \"./Polyline\";\nimport { Primitive, SkyCubePrimitive, SkySpherePrimitive } from \"./Primitive\";\nimport { RealityMeshGeometry } from \"./RealityMesh\";\nimport { RenderBufferMultiSample } from \"./RenderBuffer\";\nimport { TextureUnit } from \"./RenderFlags\";\nimport { RenderState } from \"./RenderState\";\nimport { createScreenSpaceEffectBuilder, ScreenSpaceEffects } from \"./ScreenSpaceEffect\";\nimport { OffScreenTarget, OnScreenTarget } from \"./Target\";\nimport { Techniques } from \"./Technique\";\nimport { ExternalTextureLoader, Texture, TextureHandle } from \"./Texture\";\n/** Id map holds key value pairs for both materials and textures, useful for caching such objects.\n * @internal\n */\nexport class IdMap {\n    constructor(iModel) {\n        /** Mapping of materials by their key values. */\n        this.materials = new Map();\n        /** Mapping of textures by their key values. */\n        this.textures = new Map();\n        /** Mapping of textures using gradient symbology. */\n        this.gradients = new Dictionary((lhs, rhs) => Gradient.Symb.compareSymb(lhs, rhs));\n        /** Pending promises to create a texture from an ImageSource. This prevents us from decoding the same ImageSource multiple times */\n        this.texturesFromImageSources = new Map();\n        this._iModel = iModel;\n    }\n    get isDisposed() {\n        return 0 === this.textures.size && 0 === this.gradients.size;\n    }\n    dispose() {\n        const textureArr = Array.from(this.textures.values());\n        const gradientArr = this.gradients.extractArrays().values;\n        for (const texture of textureArr)\n            dispose(texture);\n        for (const gradient of gradientArr)\n            dispose(gradient);\n        this.textures.clear();\n        this.gradients.clear();\n        this.materials.clear();\n    }\n    /** Add a material to this IdMap, given that it has a valid key. */\n    addMaterial(material) {\n        if (material.key)\n            this.materials.set(material.key, material);\n    }\n    /** Add a texture to this IdMap, given that it has a valid string key. If specified, it will instead use the key parameter, which could also be a gradient symb. */\n    addTexture(texture, key) {\n        assert(texture instanceof Texture);\n        if (undefined !== key) {\n            if (\"string\" === typeof key)\n                this.textures.set(key, texture);\n            else\n                this.addGradient(key, texture);\n        }\n        else if (texture.key)\n            this.textures.set(texture.key, texture);\n    }\n    /** Add a texture to this IdMap using gradient symbology. */\n    addGradient(gradientSymb, texture) {\n        this.gradients.set(gradientSymb, texture);\n    }\n    /** Find a cached material using its key. If not found, returns undefined. */\n    findMaterial(key) {\n        return this.materials.get(key);\n    }\n    /** Find a cached gradient using the gradient symbology. If not found, returns undefined. */\n    findGradient(symb) {\n        return this.gradients.get(symb);\n    }\n    /** Find or create a new material given material parameters. This will cache the material if its key is valid. */\n    // eslint-disable-next-line deprecation/deprecation\n    getMaterial(params) {\n        if (!params.key || !Id64.isValidId64(params.key)) // Only cache persistent materials.\n            return new Material(params);\n        let material = this.materials.get(params.key);\n        if (!material) {\n            material = new Material(params);\n            this.materials.set(params.key, material);\n        }\n        return material;\n    }\n    findTexture(key) {\n        if (undefined === key)\n            return undefined;\n        else if (typeof key === \"string\")\n            return this.textures.get(key);\n        else\n            return this.findGradient(key);\n    }\n    // eslint-disable-next-line deprecation/deprecation\n    getTextureFromElement(key, iModel, params, format) {\n        let tex = this.findTexture(params.key);\n        if (tex)\n            return tex;\n        const handle = TextureHandle.createForElement(key, iModel, params.type, format, (_, data) => {\n            if (tex) {\n                assert(tex instanceof Texture);\n                tex.transparency = data.transparency ?? TextureTransparency.Mixed;\n            }\n        });\n        if (!handle)\n            return undefined;\n        tex = new Texture({ handle, type: params.type, ownership: { key, iModel }, transparency: TextureTransparency.Opaque });\n        this.addTexture(tex);\n        return tex;\n    }\n    async getTextureFromImageSource(args, key) {\n        const texture = this.findTexture(key);\n        if (texture)\n            return texture;\n        // Are we already in the process of decoding this image?\n        let promise = this.texturesFromImageSources.get(key);\n        if (promise)\n            return promise;\n        promise = this.createTextureFromImageSource(args, key);\n        this.texturesFromImageSources.set(key, promise);\n        return promise;\n    }\n    async createTextureFromImageSource(args, key) {\n        // JPEGs don't support transparency.\n        const transparency = ImageSourceFormat.Jpeg === args.source.format ? TextureTransparency.Opaque : (args.transparency ?? TextureTransparency.Mixed);\n        try {\n            const image = await imageElementFromImageSource(args.source);\n            if (!IModelApp.hasRenderSystem)\n                return undefined;\n            return IModelApp.renderSystem.createTexture({\n                type: args.type,\n                ownership: args.ownership,\n                image: {\n                    source: image,\n                    transparency,\n                },\n            });\n        }\n        catch {\n            return undefined;\n        }\n        finally {\n            this.texturesFromImageSources.delete(key);\n        }\n    }\n    // eslint-disable-next-line deprecation/deprecation\n    getTextureFromCubeImages(posX, negX, posY, negY, posZ, negZ, params) {\n        let tex = this.findTexture(params.key);\n        if (tex)\n            return tex;\n        const handle = TextureHandle.createForCubeImages(posX, negX, posY, negY, posZ, negZ);\n        if (!handle)\n            return undefined;\n        const ownership = params.key ? { key: params.key, iModel: this._iModel } : (params.isOwned ? \"external\" : undefined);\n        tex = new Texture({ handle, ownership, type: params.type, transparency: TextureTransparency.Opaque });\n        this.addTexture(tex);\n        return tex;\n    }\n    collectStatistics(stats) {\n        for (const texture of this.textures.values())\n            if (texture instanceof Texture)\n                stats.addTexture(texture.bytesUsed);\n        for (const gradient of this.gradients)\n            if (gradient instanceof Texture)\n                stats.addTexture(gradient.bytesUsed);\n    }\n}\nfunction getMaterialColor(color) {\n    if (color instanceof ColorDef)\n        return color;\n    return color ? ColorDef.from(color.r, color.g, color.b) : undefined;\n}\n/** @internal */\nexport class System extends RenderSystem {\n    static get instance() { return IModelApp.renderSystem; }\n    get isValid() { return this.canvas !== undefined; }\n    get lineCodeTexture() { return this._lineCodeTexture; }\n    get noiseTexture() { return this._noiseTexture; }\n    get techniques() {\n        assert(undefined !== this._techniques);\n        return this._techniques;\n    }\n    get screenSpaceEffects() {\n        assert(undefined !== this._screenSpaceEffects);\n        return this._screenSpaceEffects;\n    }\n    get maxTextureSize() { return this._capabilities.maxTextureSize; }\n    get supportsCreateImageBitmap() { return this._capabilities.supportsCreateImageBitmap; }\n    get maxRenderType() { return this._capabilities.maxRenderType; }\n    get fragDepthDoesNotDisableEarlyZ() { return this._capabilities.driverBugs.fragDepthDoesNotDisableEarlyZ; }\n    get maxAntialiasSamples() { return this._capabilities.maxAntialiasSamples; }\n    get supportsNonPowerOf2Textures() { return this._capabilities.supportsNonPowerOf2Textures; }\n    get maxTexSizeAllow() { return this._capabilities.maxTexSizeAllow; }\n    get disjointTimerQuery() {\n        const ext = this._capabilities.queryExtensionObject(\"EXT_disjoint_timer_query_webgl2\");\n        return ext ?? this._capabilities.queryExtensionObject(\"EXT_disjoint_timer_query\");\n    }\n    get isMobile() { return this._capabilities.isMobile; }\n    setDrawBuffers(attachments) {\n        this.context.drawBuffers(attachments);\n    }\n    doIdleWork() {\n        return this.techniques.idleCompileNextShader();\n    }\n    /** Return a Promise which when resolved indicates that all pending external textures have finished loading from the backend. */\n    async waitForAllExternalTextures() {\n        const extTexLoader = ExternalTextureLoader.instance;\n        if (extTexLoader.numActiveRequests < 1 && extTexLoader.numPendingRequests < 1)\n            return Promise.resolve();\n        const promise = new Promise((resolve) => {\n            extTexLoader.onTexturesLoaded.addOnce(() => {\n                resolve();\n            });\n        });\n        return promise;\n    }\n    get hasExternalTextureRequests() {\n        const loader = ExternalTextureLoader.instance;\n        return loader.numActiveRequests > 0 || loader.numPendingRequests > 0;\n    }\n    /** Attempt to create a WebGLRenderingContext, returning undefined if unsuccessful. */\n    static createContext(canvas, useWebGL2, inputContextAttributes) {\n        if (!useWebGL2)\n            return undefined; // WebGL 2 is required.\n        let contextAttributes = { powerPreference: \"high-performance\" };\n        if (undefined !== inputContextAttributes) {\n            // NOTE: Order matters with spread operator - if caller wants to override powerPreference, he should be able to.\n            contextAttributes = { ...contextAttributes, ...inputContextAttributes };\n        }\n        const context = canvas.getContext(\"webgl2\", contextAttributes);\n        return context ?? undefined;\n    }\n    static create(optionsIn) {\n        const options = undefined !== optionsIn ? optionsIn : {};\n        const canvas = document.createElement(\"canvas\");\n        if (null === canvas)\n            throw new IModelError(BentleyStatus.ERROR, \"Failed to obtain HTMLCanvasElement\");\n        const context = this.createContext(canvas, true, optionsIn?.contextAttributes);\n        if (undefined === context)\n            throw new IModelError(BentleyStatus.ERROR, \"Failed to obtain WebGL context\");\n        if (!(context instanceof WebGL2RenderingContext))\n            throw new IModelError(BentleyStatus.ERROR, \"WebGL 2 support is required\");\n        const capabilities = Capabilities.create(context, options.disabledExtensions);\n        if (undefined === capabilities)\n            throw new IModelError(BentleyStatus.ERROR, \"Failed to initialize rendering capabilities\");\n        // set actual gl state to match desired state defaults\n        context.depthFunc(GL.DepthFunc.Default); // LessOrEqual\n        return new this(canvas, context, capabilities, options);\n    }\n    get isDisposed() {\n        return undefined === this._techniques\n            && undefined === this._lineCodeTexture\n            && undefined === this._noiseTexture\n            && undefined === this._screenSpaceEffects;\n    }\n    // Note: FrameBuffers inside of the FrameBufferStack are not owned by the System, and are only used as a central storage device\n    dispose() {\n        this._techniques = dispose(this._techniques);\n        this._screenSpaceEffects = dispose(this._screenSpaceEffects);\n        this._lineCodeTexture = dispose(this._lineCodeTexture);\n        this._noiseTexture = dispose(this._noiseTexture);\n        // We must attempt to dispose of each idmap in the resourceCache (if idmap is already disposed, has no effect)\n        this.resourceCache.forEach((idMap) => {\n            dispose(idMap);\n        });\n        this.resourceCache.clear();\n        if (undefined !== this._removeEventListener) {\n            this._removeEventListener();\n            this._removeEventListener = undefined;\n        }\n    }\n    onInitialized() {\n        this._techniques = Techniques.create(this.context);\n        const noiseDim = 4;\n        const noiseArr = new Uint8Array([152, 235, 94, 173, 219, 215, 115, 176, 73, 205, 43, 201, 10, 81, 205, 198]);\n        this._noiseTexture = TextureHandle.createForData(noiseDim, noiseDim, noiseArr, false, GL.Texture.WrapMode.Repeat, GL.Texture.Format.Luminance);\n        assert(undefined !== this._noiseTexture, \"System.noiseTexture not created.\");\n        this._lineCodeTexture = TextureHandle.createForData(LineCode.size, LineCode.count, new Uint8Array(LineCode.lineCodeData), false, GL.Texture.WrapMode.Repeat, GL.Texture.Format.Luminance);\n        assert(undefined !== this._lineCodeTexture, \"System.lineCodeTexture not created.\");\n        this._screenSpaceEffects = new ScreenSpaceEffects();\n    }\n    createTarget(canvas) {\n        return new OnScreenTarget(canvas);\n    }\n    createOffscreenTarget(rect) {\n        return new OffScreenTarget(rect);\n    }\n    createGraphic(options) {\n        return new PrimitiveBuilder(this, options);\n    }\n    createPlanarGrid(frustum, grid) {\n        return PlanarGridGeometry.create(frustum, grid, this);\n    }\n    createTerrainMesh(params, transform, disableTextureDisposal = false) {\n        return RealityMeshGeometry.createForTerrain(params, transform, disableTextureDisposal);\n    }\n    createRealityMeshGraphic(params, disableTextureDisposal = false) {\n        return RealityMeshGeometry.createGraphic(this, params, disableTextureDisposal);\n    }\n    createRealityMesh(realityMesh, disableTextureDisposal = false) {\n        const geom = RealityMeshGeometry.createFromRealityMesh(realityMesh, disableTextureDisposal);\n        return geom ? Primitive.create(geom) : undefined;\n    }\n    createMeshGeometry(params, viOrigin) {\n        return MeshRenderGeometry.create(params, viOrigin);\n    }\n    createPolylineGeometry(params, viOrigin) {\n        return PolylineGeometry.create(params, viOrigin);\n    }\n    createPointStringGeometry(params, viOrigin) {\n        return PointStringGeometry.create(params, viOrigin);\n    }\n    createAreaPattern(params) {\n        return PatternBuffers.create(params);\n    }\n    createRenderGraphic(geometry, instances) {\n        if (!(geometry instanceof MeshRenderGeometry)) {\n            if (geometry instanceof PolylineGeometry || geometry instanceof PointStringGeometry)\n                return Primitive.create(geometry, instances);\n            assert(false, \"Invalid RenderGeometry for System.createRenderGraphic\");\n            return undefined;\n        }\n        assert(!instances || instances instanceof PatternBuffers || isInstancedGraphicParams(instances));\n        return MeshGraphic.create(geometry, instances);\n    }\n    createPointCloud(args) {\n        return Primitive.create(new PointCloudGeometry(args));\n    }\n    createGraphicList(primitives) {\n        return new GraphicsArray(primitives);\n    }\n    createGraphicBranch(branch, transform, options) {\n        return new Branch(branch, transform, undefined, options);\n    }\n    createAnimationTransformNode(graphic, nodeId) {\n        return new AnimationTransformBranch(graphic, nodeId);\n    }\n    createBatch(graphic, features, range, options) {\n        return new Batch(graphic, features, range, options);\n    }\n    createGraphicOwner(owned) {\n        return new GraphicOwner(owned);\n    }\n    createGraphicLayer(graphic, layerId) {\n        return new Layer(graphic, layerId);\n    }\n    createGraphicLayerContainer(graphic, drawAsOverlay, transparency, elevation) {\n        return new LayerContainer(graphic, drawAsOverlay, transparency, elevation);\n    }\n    createSkyBox(params) {\n        if (\"cube\" === params.type)\n            return SkyCubePrimitive.create(SkyBoxQuadsGeometry.create(params.texture));\n        return SkySpherePrimitive.create(SkySphereViewportQuadGeometry.createGeometry(params));\n    }\n    createScreenSpaceEffectBuilder(params) {\n        return createScreenSpaceEffectBuilder(params);\n    }\n    applyRenderState(newState) {\n        newState.apply(this.currentRenderState);\n        this.currentRenderState.copyFrom(newState);\n    }\n    createDepthBuffer(width, height, numSamples = 1) {\n        // Note: The buffer/texture created here have ownership passed to the caller (system will not dispose of these)\n        if (numSamples > 1)\n            return RenderBufferMultiSample.create(width, height, WebGL2RenderingContext.DEPTH24_STENCIL8, numSamples);\n        else\n            return TextureHandle.createForAttachment(width, height, GL.Texture.Format.DepthStencil, this.context.UNSIGNED_INT_24_8);\n    }\n    /** Returns the corresponding IdMap for an IModelConnection. Creates a new one if it doesn't exist. */\n    createIModelMap(imodel) {\n        let idMap = this.resourceCache.get(imodel);\n        if (!idMap) {\n            idMap = new IdMap(imodel);\n            this.resourceCache.set(imodel, idMap);\n        }\n        return idMap;\n    }\n    /** Removes an IModelConnection-IdMap pairing from the system's resource cache. */\n    removeIModelMap(imodel) {\n        const idMap = this.resourceCache.get(imodel);\n        if (idMap === undefined)\n            return;\n        dispose(idMap);\n        this.resourceCache.delete(imodel);\n    }\n    /** Attempt to create a material for the given iModel using a set of material parameters. */\n    // eslint-disable-next-line deprecation/deprecation\n    createMaterial(params, imodel) {\n        const idMap = this.getIdMap(imodel);\n        const material = idMap.getMaterial(params);\n        return material;\n    }\n    createRenderMaterial(args) {\n        if (args.source) {\n            const cached = this.findMaterial(args.source.id, args.source.iModel);\n            if (cached)\n                return cached;\n        }\n        // eslint-disable-next-line deprecation/deprecation\n        const params = new RenderMaterial.Params();\n        params.alpha = args.alpha;\n        if (undefined !== args.diffuse?.weight)\n            params.diffuse = args.diffuse.weight;\n        params.diffuseColor = getMaterialColor(args.diffuse?.color);\n        if (args.specular) {\n            params.specularColor = getMaterialColor(args.specular?.color);\n            if (undefined !== args.specular.weight)\n                params.specular = args.specular.weight;\n            if (undefined !== args.specular.exponent)\n                params.specularExponent = args.specular.exponent;\n        }\n        if (args.textureMapping) {\n            params.textureMapping = new TextureMapping(args.textureMapping.texture, new TextureMapping.Params({\n                textureMat2x3: args.textureMapping.transform,\n                mapMode: args.textureMapping.mode,\n                textureWeight: args.textureMapping.weight,\n                worldMapping: args.textureMapping.worldMapping,\n                useConstantLod: args.textureMapping.useConstantLod,\n                constantLodProps: args.textureMapping.constantLodProps,\n            }));\n            params.textureMapping.normalMapParams = args.textureMapping.normalMapParams;\n        }\n        if (args.source) {\n            params.key = args.source.id;\n            return this.getIdMap(args.source.iModel).getMaterial(params);\n        }\n        else {\n            return new Material(params);\n        }\n    }\n    /** Using its key, search for an existing material of an open iModel. */\n    findMaterial(key, imodel) {\n        const idMap = this.resourceCache.get(imodel);\n        if (!idMap)\n            return undefined;\n        return idMap.findMaterial(key);\n    }\n    getTextureCacheInfo(args) {\n        const owner = undefined !== args.ownership && args.ownership !== \"external\" ? args.ownership : undefined;\n        return owner ? { idMap: this.getIdMap(owner.iModel), key: owner.key } : undefined;\n    }\n    createTexture(args) {\n        const info = this.getTextureCacheInfo(args);\n        const existing = info?.idMap.findTexture(info?.key);\n        if (existing)\n            return existing;\n        const type = args.type ?? RenderTexture.Type.Normal;\n        const source = args.image.source;\n        let handle;\n        if (source instanceof ImageBuffer)\n            handle = TextureHandle.createForImageBuffer(source, type);\n        else if (source instanceof ImageBitmap)\n            handle = TextureHandle.createForImageBitmap(source, type);\n        else if (source instanceof HTMLImageElement)\n            handle = TextureHandle.createForImage(source, type);\n        else\n            assert(false);\n        if (!handle)\n            return undefined;\n        const texture = new Texture({ handle, type, ownership: args.ownership, transparency: args.image.transparency ?? TextureTransparency.Mixed });\n        if (texture && info)\n            info.idMap.addTexture(texture, info.key);\n        return texture;\n    }\n    async createTextureFromSource(args) {\n        if (typeof args.ownership !== \"object\")\n            return super.createTextureFromSource(args);\n        return this.getIdMap(args.ownership.iModel).getTextureFromImageSource(args, args.ownership.key);\n    }\n    // eslint-disable-next-line deprecation/deprecation\n    createTextureFromElement(id, imodel, params, format) {\n        return this.getIdMap(imodel).getTextureFromElement(id, imodel, params, format);\n    }\n    // eslint-disable-next-line deprecation/deprecation\n    createTextureFromCubeImages(posX, negX, posY, negY, posZ, negZ, imodel, params) {\n        return this.getIdMap(imodel).getTextureFromCubeImages(posX, negX, posY, negY, posZ, negZ, params);\n    }\n    /** Attempt to create a texture using gradient symbology. */\n    getGradientTexture(symb, iModel) {\n        let width = 0x100;\n        let height = 0x100;\n        if (symb.mode === Gradient.Mode.Thematic) {\n            // Pixels in each row are identical, no point in having width > 1.\n            width = 1;\n            // We want maximum height to minimize bleeding of margin color.\n            height = this.maxTextureSize;\n        }\n        const source = symb.produceImage({ width, height, includeThematicMargin: true });\n        return this.createTexture({\n            image: {\n                source,\n                transparency: ImageBufferFormat.Rgba === source.format ? TextureTransparency.Mixed : TextureTransparency.Opaque,\n            },\n            ownership: iModel ? { iModel, key: symb } : undefined,\n            type: RenderTexture.Type.Normal,\n        });\n    }\n    /** Using its key, search for an existing texture of an open iModel. */\n    findTexture(key, imodel) {\n        const idMap = this.resourceCache.get(imodel);\n        if (!idMap)\n            return undefined;\n        return idMap.findTexture(key);\n    }\n    createClipVolume(clipVector) {\n        return ClipVolume.create(clipVector);\n    }\n    createBackgroundMapDrape(drapedTree, mapTree) {\n        return BackgroundMapDrape.create(drapedTree, mapTree);\n    }\n    constructor(canvas, context, capabilities, options) {\n        super(options);\n        this.currentRenderState = new RenderState();\n        this.frameBufferStack = new FrameBufferStack(); // frame buffers are not owned by the system\n        this._textureBindings = [];\n        // NB: Increase the size of these arrays when the maximum number of attributes used by any one shader increases.\n        this._curVertexAttribStates = [\n            0 /* VertexAttribState.Disabled */, 0 /* VertexAttribState.Disabled */, 0 /* VertexAttribState.Disabled */, 0 /* VertexAttribState.Disabled */,\n            0 /* VertexAttribState.Disabled */, 0 /* VertexAttribState.Disabled */, 0 /* VertexAttribState.Disabled */, 0 /* VertexAttribState.Disabled */,\n            0 /* VertexAttribState.Disabled */, 0 /* VertexAttribState.Disabled */, 0 /* VertexAttribState.Disabled */, 0 /* VertexAttribState.Disabled */,\n        ];\n        this._nextVertexAttribStates = [\n            0 /* VertexAttribState.Disabled */, 0 /* VertexAttribState.Disabled */, 0 /* VertexAttribState.Disabled */, 0 /* VertexAttribState.Disabled */,\n            0 /* VertexAttribState.Disabled */, 0 /* VertexAttribState.Disabled */, 0 /* VertexAttribState.Disabled */, 0 /* VertexAttribState.Disabled */,\n            0 /* VertexAttribState.Disabled */, 0 /* VertexAttribState.Disabled */, 0 /* VertexAttribState.Disabled */, 0 /* VertexAttribState.Disabled */,\n        ];\n        this.debugShaderFiles = [];\n        this.canvas = canvas;\n        this.context = context;\n        this._capabilities = capabilities;\n        this.resourceCache = new Map();\n        this.glTimer = GLTimer.create(this);\n        // Make this System a subscriber to the the IModelConnection onClose event\n        this._removeEventListener = IModelConnection.onClose.addListener((imodel) => this.removeIModelMap(imodel));\n        canvas.addEventListener(\"webglcontextlost\", async () => RenderSystem.contextLossHandler(), false);\n    }\n    /** Exposed strictly for tests. */\n    getIdMap(imodel) {\n        const map = this.resourceCache.get(imodel);\n        return undefined !== map ? map : this.createIModelMap(imodel);\n    }\n    bindTexture(unit, target, texture, makeActive) {\n        const index = unit - TextureUnit.Zero;\n        if (this._textureBindings[index] === texture) {\n            if (makeActive)\n                this.context.activeTexture(unit);\n            return;\n        }\n        this._textureBindings[index] = texture;\n        this.context.activeTexture(unit);\n        this.context.bindTexture(target, undefined !== texture ? texture : null);\n    }\n    /** Bind the specified texture to the specified unit. This may *or may not* make the texture *active* */\n    bindTexture2d(unit, texture) { this.bindTexture(unit, GL.Texture.Target.TwoDee, texture, false); }\n    /** Bind the specified texture to the specified unit. This may *or may not* make the texture *active* */\n    bindTextureCubeMap(unit, texture) { this.bindTexture(unit, GL.Texture.Target.CubeMap, texture, false); }\n    /** Bind the specified texture to the specified unit. This *always* makes the texture *active* */\n    activateTexture2d(unit, texture) { this.bindTexture(unit, GL.Texture.Target.TwoDee, texture, true); }\n    /** Bind the specified texture to the specified unit. This *always* makes the texture *active* */\n    activateTextureCubeMap(unit, texture) { this.bindTexture(unit, GL.Texture.Target.CubeMap, texture, true); }\n    // Ensure *something* is bound to suppress 'no texture assigned to unit x' warnings.\n    ensureSamplerBound(uniform, unit) {\n        this.lineCodeTexture.bindSampler(uniform, unit);\n    }\n    get maxRealityImageryLayers() {\n        return 6;\n    }\n    disposeTexture(texture) {\n        System.instance.context.deleteTexture(texture);\n        for (let i = 0; i < this._textureBindings.length; i++) {\n            if (this._textureBindings[i] === texture) {\n                this._textureBindings[i] = undefined;\n                break;\n            }\n        }\n    }\n    // System keeps track of current enabled state of vertex attribute arrays.\n    // This prevents errors caused by leaving a vertex attrib array enabled after disposing of the buffer bound to it;\n    // also prevents unnecessarily 'updating' the enabled state of a vertex attrib array when it hasn't actually changed.\n    enableVertexAttribArray(id, instanced) {\n        assert(id < this._nextVertexAttribStates.length, \"if you add new vertex attributes you must update array length\");\n        assert(id < this._curVertexAttribStates.length, \"if you add new vertex attributes you must update array length\");\n        this._nextVertexAttribStates[id] = instanced ? 5 /* VertexAttribState.InstancedEnabled */ : 1 /* VertexAttribState.Enabled */;\n    }\n    updateVertexAttribArrays() {\n        const cur = this._curVertexAttribStates;\n        const next = this._nextVertexAttribStates;\n        const context = this.context;\n        for (let i = 0; i < next.length; i++) {\n            const oldState = cur[i];\n            const newState = next[i];\n            if (oldState !== newState) {\n                // Update the enabled state if it changed.\n                const wasEnabled = 0 !== (1 /* VertexAttribState.Enabled */ & oldState);\n                const nowEnabled = 0 !== (1 /* VertexAttribState.Enabled */ & newState);\n                if (wasEnabled !== nowEnabled) {\n                    if (nowEnabled) {\n                        context.enableVertexAttribArray(i);\n                    }\n                    else {\n                        context.disableVertexAttribArray(i);\n                    }\n                }\n                // Only update the divisor if the attribute is enabled.\n                if (nowEnabled) {\n                    const wasInstanced = 0 !== (4 /* VertexAttribState.Instanced */ & oldState);\n                    const nowInstanced = 0 !== (4 /* VertexAttribState.Instanced */ & newState);\n                    if (wasInstanced !== nowInstanced) {\n                        this.vertexAttribDivisor(i, nowInstanced ? 1 : 0);\n                    }\n                }\n                cur[i] = newState;\n            }\n            // Set the attribute back to disabled, but preserve the divisor.\n            next[i] &= ~1 /* VertexAttribState.Enabled */;\n        }\n    }\n    vertexAttribDivisor(index, divisor) {\n        this.context.vertexAttribDivisor(index, divisor);\n    }\n    drawArrays(type, first, count, numInstances) {\n        if (0 !== numInstances) {\n            this.context.drawArraysInstanced(type, first, count, numInstances);\n        }\n        else {\n            this.context.drawArrays(type, first, count);\n        }\n    }\n    invalidateFrameBuffer(attachments) {\n        this.context.invalidateFramebuffer(this.context.FRAMEBUFFER, attachments);\n    }\n    enableDiagnostics(enable) {\n        Debug.printEnabled = RenderDiagnostics.None !== (enable & RenderDiagnostics.DebugOutput);\n        Debug.evaluateEnabled = RenderDiagnostics.None !== (enable & RenderDiagnostics.WebGL);\n    }\n    // RenderSystemDebugControl\n    get debugControl() { return this; }\n    get dpiAwareLOD() { return this._dpiAwareLOD ?? super.dpiAwareLOD; }\n    set dpiAwareLOD(dpiAware) { this._dpiAwareLOD = dpiAware; }\n    loseContext() {\n        const ext = this._capabilities.queryExtensionObject(\"WEBGL_lose_context\");\n        if (undefined === ext)\n            return false;\n        ext.loseContext();\n        return true;\n    }\n    compileAllShaders() {\n        return this.techniques.compileShaders();\n    }\n    get isGLTimerSupported() { return this.glTimer.isSupported; }\n    set resultsCallback(callback) {\n        this.glTimer.resultsCallback = callback;\n    }\n    collectStatistics(stats) {\n        if (undefined !== this._lineCodeTexture)\n            stats.addTexture(this._lineCodeTexture.bytesUsed);\n        if (undefined !== this._noiseTexture)\n            stats.addTexture(this._noiseTexture.bytesUsed);\n        for (const idMap of this.resourceCache.values())\n            idMap.collectStatistics(stats);\n    }\n    setMaxAnisotropy(max) {\n        this._capabilities.setMaxAnisotropy(max, this.context);\n    }\n}\n//# sourceMappingURL=System.js.map",
      "start": 1693508121055,
      "end": 1693508121299,
      "sourcemaps": null
    }
  ]
}
