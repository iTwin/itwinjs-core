{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/primitives/geometry/GeometryAccumulator.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Rendering\n */\nimport { assert } from \"@itwin/core-bentley\";\nimport { Point3d, Range3d, Transform } from \"@itwin/core-geometry\";\nimport { QPoint3dList } from \"@itwin/core-common\";\nimport { GraphicBranch } from \"../../GraphicBranch\";\nimport { MeshBuilderMap } from \"../mesh/MeshBuilderMap\";\nimport { MeshList } from \"../mesh/MeshPrimitives\";\nimport { GeometryList } from \"./GeometryList\";\nimport { Geometry } from \"./GeometryPrimitives\";\nimport { IModelApp } from \"../../../IModelApp\";\n/** @internal */\nexport class GeometryAccumulator {\n    get surfacesOnly() { return this._surfacesOnly; }\n    get transform() { return this._transform; }\n    get isEmpty() { return this.geometries.isEmpty; }\n    get haveTransform() { return !this._transform.isIdentity; }\n    constructor(options) {\n        this.geometries = new GeometryList();\n        this.system = options?.system ?? IModelApp.renderSystem;\n        this.tileRange = options?.tileRange ?? Range3d.createNull();\n        this._surfacesOnly = true === options?.surfacesOnly;\n        this._transform = options?.transform ?? Transform.createIdentity();\n        this._analysisDisplacement = options?.analysisStyleDisplacement;\n        this._viewIndependentOrigin = options?.viewIndependentOrigin;\n        this.currentFeature = options?.feature;\n    }\n    getPrimitiveRange(geom) {\n        const range = new Range3d();\n        geom.range(undefined, range);\n        return range.isNull ? undefined : range;\n    }\n    calculateTransform(transform, range) {\n        if (this.haveTransform)\n            transform = this._transform.multiplyTransformTransform(transform);\n        transform.multiplyRange(range, range);\n        return transform;\n    }\n    addLoop(loop, displayParams, transform, disjoint) {\n        const range = this.getPrimitiveRange(loop);\n        if (!range)\n            return false;\n        const xform = this.calculateTransform(transform, range);\n        return this.addGeometry(Geometry.createFromLoop(loop, xform, range, displayParams, disjoint, this.currentFeature));\n    }\n    addLineString(pts, displayParams, transform) {\n        // Do this.getPrimitiveRange() manually, so there is no need to create a PointString3d object just to find the range\n        const range = Range3d.createNull();\n        range.extendArray(pts, undefined);\n        if (range.isNull)\n            return false;\n        const xform = this.calculateTransform(transform, range);\n        return this.addGeometry(Geometry.createFromLineString(pts, xform, range, displayParams, this.currentFeature));\n    }\n    addPointString(pts, displayParams, transform) {\n        // Do this.getPrimitiveRange() manually, so there is no need to create a PointString3d object just to find the range\n        const range = Range3d.createNull();\n        range.extendArray(pts, undefined);\n        if (range.isNull)\n            return false;\n        const xform = this.calculateTransform(transform, range);\n        return this.addGeometry(Geometry.createFromPointString(pts, xform, range, displayParams, this.currentFeature));\n    }\n    addPath(path, displayParams, transform, disjoint) {\n        const range = this.getPrimitiveRange(path);\n        if (!range)\n            return false;\n        const xform = this.calculateTransform(transform, range);\n        return this.addGeometry(Geometry.createFromPath(path, xform, range, displayParams, disjoint, this.currentFeature));\n    }\n    addPolyface(pf, displayParams, transform) {\n        // Adjust the mesh range based on displacements applied to vertices by analysis style, if applicable.\n        let range;\n        if (this._analysisDisplacement) {\n            const channel = pf.data.auxData?.channels.find((x) => x.name === this._analysisDisplacement.channelName);\n            const displacementRange = channel?.computeDisplacementRange(this._analysisDisplacement.scale);\n            if (displacementRange && !displacementRange.isNull) {\n                range = Range3d.createNull();\n                const pt = new Point3d();\n                for (let i = 0; i < pf.data.point.length; i++) {\n                    pf.data.point.getPoint3dAtUncheckedPointIndex(i, pt);\n                    range.extendXYZ(pt.x + displacementRange.low.x, pt.y + displacementRange.low.y, pt.z + displacementRange.low.z);\n                    range.extendXYZ(pt.x + displacementRange.high.x, pt.y + displacementRange.high.y, pt.z + displacementRange.high.z);\n                }\n            }\n        }\n        if (!range && !(range = this.getPrimitiveRange(pf)))\n            return false;\n        const xform = this.calculateTransform(transform, range);\n        return this.addGeometry(Geometry.createFromPolyface(pf, xform, range, displayParams, this.currentFeature));\n    }\n    addSolidPrimitive(primitive, displayParams, transform) {\n        const range = this.getPrimitiveRange(primitive);\n        if (!range)\n            return false;\n        const xform = this.calculateTransform(transform, range);\n        return this.addGeometry(Geometry.createFromSolidPrimitive(primitive, xform, range, displayParams, this.currentFeature));\n    }\n    addGeometry(geom) {\n        this.geometries.push(geom);\n        return true;\n    }\n    clear() { this.geometries.clear(); }\n    /**\n     * Generates a MeshBuilderMap\n     * native: GeometryAccumulator::ToMeshBuilderMap(GeometryOptionsCR options, double tolerance, FeatureTableP featureTable, ViewContextR context) const\n     * note  : removed featureTable, ViewContext\n     * @param tolerance should derive from Viewport.getPixelSizeAtPoint\n     */\n    toMeshBuilderMap(options, tolerance, pickable) {\n        const { geometries } = this; // declare internal dependencies\n        const range = geometries.computeRange();\n        const is2d = !range.isNull && range.isAlmostZeroZ;\n        return MeshBuilderMap.createFromGeometries(geometries, tolerance, range, is2d, options, pickable);\n    }\n    toMeshes(options, tolerance, pickable) {\n        if (this.geometries.isEmpty)\n            return new MeshList();\n        const builderMap = this.toMeshBuilderMap(options, tolerance, pickable);\n        return builderMap.toMeshes();\n    }\n    /**\n     * Populate a list of Graphic objects from the accumulated Geometry objects.\n     * removed ViewContext\n     */\n    saveToGraphicList(graphics, options, tolerance, pickable) {\n        const meshes = this.toMeshes(options, tolerance, pickable);\n        if (0 === meshes.length)\n            return undefined;\n        // If the meshes contain quantized positions, they are all quantized to the same range. If that range is small relative to the distance\n        // from the origin, quantization errors can produce display artifacts. Remove the translation from the quantization parameters and apply\n        // it in the transform instead.\n        //\n        // If the positions are not quantized, they have already been transformed to be relative to the center of the meshes' range.\n        // Apply the inverse translation to put them back into model space.\n        const branch = new GraphicBranch(true);\n        let transformOrigin;\n        let meshesRangeOffset = false;\n        for (const mesh of meshes) {\n            const verts = mesh.points;\n            if (branch.isEmpty) {\n                if (verts instanceof QPoint3dList) {\n                    transformOrigin = verts.params.origin.clone();\n                    verts.params.origin.setZero();\n                }\n                else {\n                    transformOrigin = verts.range.center;\n                    // In this case we need to modify the qOrigin of the graphic that will get created later since we have translated the origin.\n                    // We can't modify it directly, but if we temporarily modify the range of the mesh used to create it the qOrigin will get created properly.\n                    // Range is shared (not cloned) by all meshes and the mesh list itself, so modifying the range of the meshlist will modify it for all meshes.\n                    // We will then later add this offset back to the range once all of the graphics have been created because it is needed unmodified for locate.\n                    if (!meshesRangeOffset) {\n                        meshes.range?.low.subtractInPlace(transformOrigin);\n                        meshes.range?.high.subtractInPlace(transformOrigin);\n                        meshesRangeOffset = true;\n                    }\n                }\n            }\n            else {\n                assert(undefined !== transformOrigin);\n                if (verts instanceof QPoint3dList) {\n                    assert(transformOrigin.isAlmostEqual(verts.params.origin));\n                    verts.params.origin.setZero();\n                }\n                else {\n                    assert(verts.range.center.isAlmostZero);\n                }\n            }\n            const graphic = mesh.getGraphics(this.system, this._viewIndependentOrigin);\n            if (undefined !== graphic)\n                branch.add(graphic);\n        }\n        if (!branch.isEmpty) {\n            assert(undefined !== transformOrigin);\n            const transform = Transform.createTranslation(transformOrigin);\n            graphics.push(this.system.createBranch(branch, transform));\n            if (meshesRangeOffset) { // restore the meshes range that we modified earlier.\n                meshes.range?.low.addInPlace(transformOrigin);\n                meshes.range?.high.addInPlace(transformOrigin);\n            }\n        }\n        return meshes;\n    }\n}\n//# sourceMappingURL=GeometryAccumulator.js.map",
      "start": 1693508119672,
      "end": 1693508119760,
      "sourcemaps": null
    }
  ]
}
