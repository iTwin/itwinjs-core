{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/polyface/multiclip/XYPointBuckets.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module RangeSearch\n */\nimport { Geometry } from \"../../Geometry\";\nimport { Point3d } from \"../../geometry3d/Point3dVector3d\";\nimport { Range2d } from \"../../geometry3d/Range\";\n/**\n * Arrays of type T values distributed by xy position when entered.\n * @internal\n */\nexport class XYIndexGrid {\n    constructor(range, numX, numY) {\n        this._range = range;\n        this._numXEdge = Math.max(numX, 1);\n        this._numYEdge = Math.max(numY, 1);\n        this._data = [];\n        for (let j = 0; j < numY; j++) {\n            const thisRow = [];\n            for (let i = 0; i < numX; i++) {\n                thisRow.push(undefined);\n            }\n            this._data.push(thisRow);\n        }\n    }\n    /** Return the number of x edges in the grid */\n    get numXEdge() { return this._numXEdge; }\n    /** Return the number of y edges in the grid */\n    get numYEdge() { return this._numYEdge; }\n    /** Return the `i` index of cells containing x coordinate */\n    xIndex(x) {\n        const fraction = (x - this._range.low.x) / (this._range.high.x - this._range.low.x);\n        const q = Math.floor(fraction * this._numXEdge);\n        if (q < 0)\n            return 0;\n        if (q > this._numXEdge - 1)\n            return this._numXEdge - 1;\n        return q;\n    }\n    /** Return the `j` index of cells containing x coordinate */\n    yIndex(y) {\n        const fraction = (y - this._range.low.y) / (this._range.high.y - this._range.low.y);\n        const q = Math.floor(fraction * this._numYEdge);\n        if (q < 0)\n            return 0;\n        if (q > this._numYEdge - 1)\n            return this._numYEdge - 1;\n        return q;\n    }\n    /**\n     * Construct an array with cells mapped to a range, with counts determined by estimated total count and target number of entries per cell.\n     * @param range\n     * @param totalEntries\n     * @param targetEntriesPerCell\n     */\n    static createWithEstimatedCounts(range, totalEntries, targetEntriesPerCell) {\n        if (range.low.x >= range.high.x || range.low.y >= range.high.y)\n            return undefined;\n        const range2d = Range2d.createXYXY(range.low.x, range.low.y, range.high.x, range.high.y);\n        const dx = range2d.xLength();\n        const dy = range2d.yLength();\n        // numX / numY = dX / dY  (numX,numY will be integers  . . .)\n        // numX = dX * numY / dY\n        let numX;\n        let numY;\n        if (dy > dx) {\n            numY = Math.ceil(Math.sqrt(dy * totalEntries / (targetEntriesPerCell * dx)));\n            numX = Math.ceil(totalEntries / numY);\n        }\n        else {\n            numX = Math.ceil(Math.sqrt(dx * totalEntries / (targetEntriesPerCell * dy)));\n            numY = Math.ceil(totalEntries / (numX * targetEntriesPerCell));\n        }\n        return new XYIndexGrid(range2d, numX, numY);\n    }\n    /**\n     * Add (save) a new data value to the grid cell containing x,y\n     * @param x\n     * @param y\n     * @param value\n     */\n    addDataAtXY(x, y, value) {\n        const i = this.xIndex(x);\n        const j = this.yIndex(y);\n        let dataJI = this._data[j][i];\n        if (!dataJI) {\n            dataJI = [];\n            this._data[j][i] = dataJI;\n        }\n        dataJI.push(value);\n        return;\n    }\n    /**\n     * Get the (reference to the possibly null array of) data values for the cell indicated by xy.\n     * @param x\n     * @param y\n     */\n    getDataAtXY(x, y) {\n        const i = this.xIndex(x);\n        const j = this.yIndex(y);\n        return this._data[j][i];\n    }\n    /**\n     * Get the (reference to the possibly null array of) data values for the cell indicated by indices in the x and y direction\n     * @param xIndex\n     * @param yIndex\n     */\n    getDataAtIndex(xIndex, yIndex) {\n        if (xIndex < 0)\n            return undefined;\n        if (xIndex >= this._numXEdge)\n            return undefined;\n        if (yIndex < 0)\n            return undefined;\n        if (yIndex >= this._numYEdge)\n            return undefined;\n        return this._data[yIndex][xIndex];\n    }\n    /** Return true if (xIndex, yIndex) is a valid cell index. */\n    isValidIndex(xIndex, yIndex) {\n        if (xIndex < 0)\n            return false;\n        if (xIndex >= this._numXEdge)\n            return false;\n        if (yIndex < 0)\n            return false;\n        if (yIndex >= this._numYEdge)\n            return false;\n        return true;\n    }\n}\n/** Manage buckets of points for fast search.\n * @internal\n */\nexport class XYPointBuckets {\n    /** Return the underlying grid with indices recorded by block */\n    get indexGrid() { return this._buckets; }\n    constructor(points, buckets) {\n        this._points = points;\n        this._buckets = buckets;\n    }\n    /** Create an XYIndex grid with all indices of all `points` entered */\n    static create(points, targetPointsPerCell) {\n        const n = points.length;\n        if (points.length < 1)\n            return undefined;\n        const range = points.getRange();\n        range.expandInPlace(Geometry.smallMetricDistance * 1000.0);\n        const buckets = XYIndexGrid.createWithEstimatedCounts(range, points.length, targetPointsPerCell);\n        if (buckets === undefined)\n            return undefined;\n        const result = new XYPointBuckets(points, buckets);\n        const point = Point3d.create();\n        for (let i = 0; i < n; i++) {\n            points.getPoint3dAtUncheckedPointIndex(i, point);\n            buckets.addDataAtXY(point.x, point.y, i);\n        }\n        return result;\n    }\n    /** call the `announce` function with the index and coordinates of all points in given range.\n     * * continue the search if `announce` returns true.\n     * * terminate the search if `announce` returns false;\n     */\n    announcePointsInRange(range, announce) {\n        const i0 = this._buckets.xIndex(range.low.x);\n        const i1 = this._buckets.xIndex(range.high.x);\n        const j0 = this._buckets.yIndex(range.low.y);\n        const j1 = this._buckets.yIndex(range.high.y);\n        const n = this._points.length;\n        for (let i = i0; i <= i1; i++) {\n            for (let j = j0; j <= j1; j++) {\n                const candidates = this._buckets.getDataAtIndex(i, j);\n                if (candidates !== undefined) {\n                    for (const k of candidates) {\n                        if (k < n) {\n                            const x = this._points.getXAtUncheckedPointIndex(k);\n                            const y = this._points.getYAtUncheckedPointIndex(k);\n                            const z = this._points.getZAtUncheckedPointIndex(k);\n                            if (range.containsXY(x, y))\n                                if (!announce(k, x, y, z))\n                                    return;\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n//# sourceMappingURL=XYPointBuckets.js.map",
      "start": 1693508124368,
      "end": 1693508124476,
      "sourcemaps": null
    }
  ]
}
