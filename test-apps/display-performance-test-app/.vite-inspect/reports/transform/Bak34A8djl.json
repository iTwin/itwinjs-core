{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/geometry3d/Segment1d.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module CartesianGeometry\n */\nimport { Geometry } from \"../Geometry\";\n/**\n * * A Segment1d is an interval of an axis named x.\n * * The interval is defined by two values x0 and x1.\n * * The x0 and x1 values can be in either order.\n *   * if `x0 < x1` fractional coordinates within the segment move from left to right.\n *   * if `x0 > x1` fractional coordinates within the segment move from right to left.\n * * This differs from a Range1d in that:\n * * For a Range1d the reversed ordering of its limit values means \"empty interval\".\n * * For a Segment1d the reversed ordering is a real interval but fractional positions move backwards.\n * * The segment is parameterized with a fraction\n * * * Fraction 0 is the start (`x0`)\n * * * Fraction 1 is the end (`x1`)\n * * * The fraction equation is `x = x0 + fraction * (x1-x0)` or (equivalently) `x = (1-fraction) * x0 + fraction * x1`\n * @public\n */\nexport class Segment1d {\n    constructor(x0, x1) {\n        this.x0 = x0;\n        this.x1 = x1;\n    }\n    /**\n     * replace both end values.\n     * @param x0 new x0 value\n     * @param x1 new y0 value\n     */\n    set(x0, x1) { this.x0 = x0, this.x1 = x1; }\n    /**\n     * shift (translate) the segment along its axis by adding `dx` to both `x0` and `x1`.\n     * @param dx value to add to both x0 and x1\n     */\n    shift(dx) { this.x0 += dx, this.x1 += dx; }\n    /**\n     * create segment1d with given end values\n     * @param x0 start value\n     * @param x1 end value\n     * @param result optional pre-existing result to be reinitialized.\n     */\n    static create(x0 = 0, x1 = 1, result) {\n        if (!result)\n            return new Segment1d(x0, x1);\n        result.set(x0, x1);\n        return result;\n    }\n    /**\n     * Copy both end values from other Segment1d\n     * @param other source Segment1d\n     */\n    setFrom(other) { this.x0 = other.x0; this.x1 = other.x1; }\n    /**\n     * clone this Segment1d, return as a separate object.\n     */\n    clone() { return new Segment1d(this.x0, this.x1); }\n    /**\n     * Returns true if both coordinates (`x0` and `x1`) are in the 0..1 range.\n     */\n    get isIn01() {\n        return Geometry.isIn01(this.x0) && Geometry.isIn01(this.x1);\n    }\n    /**\n     * Evaluate the segment at fractional position\n     * @returns position within the segment\n     * @param fraction fractional position within this segment\n     */\n    fractionToPoint(fraction) { return Geometry.interpolate(this.x0, fraction, this.x1); }\n    /**\n     * Return the signed start-to-end shift (aka signed distance)\n     */\n    signedDelta() { return this.x1 - this.x0; }\n    /**\n     * Return the absolute start-to-end shift (aka distance)\n     */\n    absoluteDelta() { return Math.abs(this.x1 - this.x0); }\n    /**\n     * * swap the x0 and x1 member values.\n     * * This makes the fractionToPoint evaluates reverse direction.\n     */\n    reverseInPlace() { const x = this.x0; this.x0 = this.x1; this.x1 = x; }\n    /**\n     * * if `x1-x0` multiplied by the scale factor is (strictly) negative, swap the x0 and x1 member values.\n     * * This makes the fractionToPoint evaluates reverse direction.\n     */\n    reverseIfNeededForDeltaSign(sign = 1) {\n        if (sign * (this.x1 - this.x0) < 0)\n            this.reverseInPlace();\n    }\n    /**\n     * Near equality test, using Geometry.isSameCoordinate for tolerances.\n     */\n    isAlmostEqual(other) {\n        return Geometry.isSameCoordinate(this.x0, other.x0) && Geometry.isSameCoordinate(this.x1, other.x1);\n    }\n    /**\n     * Return true if the segment limits are (exactly) 0 and 1\n     */\n    get isExact01() { return this.x0 === 0.0 && this.x1 === 1.0; }\n    /**\n     * Return true if the segment limits are (exactly) 1 and 0\n     */\n    get isExact01Reversed() { return this.x0 === 1.0 && this.x1 === 0.0; }\n    /** On input, `this` is an interval of a line.  On output, the interval has been clipped to positive parts of a linear function\n     * * f0 and f1 are values at parameter values 0 and 1 (which are in general NOT x0 and x1)\n     * * From that determine where the segment crosses function value 0.\n     * * The segment contains some interval in the same parameter space.\n     * * Clip the segment to the positive part of the space.\n     * * Return true (and modify the segment) if any of the segment remains.\n     * * Return false (but without modifying the segment) if the active part is entirely out.\n     */\n    clipBy01FunctionValuesPositive(f0, f1) {\n        const df01 = f1 - f0;\n        const fA = f0 + this.x0 * df01;\n        const fB = f0 + this.x1 * df01;\n        const dfAB = fB - fA;\n        if (fA > 0) {\n            if (fB >= 0)\n                return true; // inside at both ends\n            /** There is an inside to outside crossing. The division is safe ... (and value between 0 and 1) */\n            const u = -fA / dfAB;\n            this.x1 = this.x0 + u * (this.x1 - this.x0);\n            return true;\n        }\n        else if (fA < 0) {\n            if (fB < 0)\n                return false; // outside at both ends.\n            /** There is an outside to inside crossing crossing. The division is safe ... (and value between 0 and 1) */\n            const u = -fA / dfAB;\n            this.x0 = this.x0 + u * (this.x1 - this.x0);\n            return true;\n        }\n        /** fA is on the cut.   fB determines the entire segment. */\n        return fB > 0;\n    }\n    /**\n     * * On input, (f0,f1) is a (directed) segment.\n     * * On output, it is restricted to (0,1) while maintaining direction\n     * * If the clip leaves nothing, leave this segment alone and return false.\n     * * If the clip leaves something, update this segment and return true.\n     */\n    clampDirectedTo01() {\n        let x0 = this.x0;\n        let x1 = this.x1;\n        if (x1 > x0) {\n            if (x0 < 0)\n                x0 = 0;\n            if (x1 > 1)\n                x1 = 1;\n            if (x0 >= x1)\n                return false;\n        }\n        else {\n            if (x0 > 1)\n                x0 = 1;\n            if (x1 < 0)\n                x1 = 0;\n            if (x0 <= x1)\n                return false;\n        }\n        this.set(x0, x1);\n        return true;\n    }\n}\n//# sourceMappingURL=Segment1d.js.map",
      "start": 1693508122410,
      "end": 1693508122592,
      "sourcemaps": null
    }
  ]
}
