{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/curve/internalContexts/CurveLengthContext.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Curve\n */\nimport { Range1d } from \"../../geometry3d/Range\";\nimport { Ray3d } from \"../../geometry3d/Ray3d\";\nimport { GaussMapper } from \"../../numerics/Quadrature\";\n/**\n * Context for computing the length of a CurvePrimitive.\n * @internal\n */\nexport class CurveLengthContext {\n    tangentMagnitude(fraction) {\n        this._ray = this._curve.fractionToPointAndDerivative(fraction, this._ray);\n        return this._ray.direction.magnitude();\n    }\n    /** Return the fraction0 installed at construction time. */\n    get getFraction0() {\n        return this._fraction0;\n    }\n    /** Return the fraction1 installed at construction time. */\n    get getFraction1() {\n        return this._fraction1;\n    }\n    getSum() {\n        return this._summedLength;\n    }\n    constructor(fraction0 = 0.0, fraction1 = 1.0, numGaussPoints = 5) {\n        this.startCurvePrimitive(undefined);\n        this._summedLength = 0.0;\n        this._ray = Ray3d.createZero();\n        if (fraction0 < fraction1) {\n            this._fraction0 = fraction0;\n            this._fraction1 = fraction1;\n        }\n        else {\n            this._fraction0 = fraction1;\n            this._fraction1 = fraction0;\n        }\n        this._gaussMapper = new GaussMapper(numGaussPoints);\n    }\n    startCurvePrimitive(curve) {\n        this._curve = curve;\n    }\n    startParentCurvePrimitive(_curve) {\n    }\n    endParentCurvePrimitive(_curve) {\n    }\n    endCurvePrimitive() {\n    }\n    announceIntervalForUniformStepStrokes(cp, numStrokes, fraction0, fraction1) {\n        const range = Range1d.createXX(fraction0, fraction1);\n        range.intersectRangeXXInPlace(this._fraction0, this._fraction1);\n        if (!range.isNull) {\n            this.startCurvePrimitive(cp);\n            if (numStrokes < 1)\n                numStrokes = 1;\n            const df = 1.0 / numStrokes;\n            for (let i = 1; i <= numStrokes; i++) {\n                const fractionA = range.fractionToPoint((i - 1) * df);\n                const fractionB = i === numStrokes ? range.high : range.fractionToPoint(i * df);\n                const numGauss = this._gaussMapper.mapXAndW(fractionA, fractionB);\n                for (let k = 0; k < numGauss; k++) {\n                    this._summedLength += this._gaussMapper.gaussW[k] * this.tangentMagnitude(this._gaussMapper.gaussX[k]);\n                }\n            }\n        }\n    }\n    announceSegmentInterval(_cp, point0, point1, _numStrokes, fraction0, fraction1) {\n        const segmentLength = point0.distance(point1);\n        if (this._fraction0 <= fraction0 && fraction1 <= this._fraction1)\n            this._summedLength += segmentLength;\n        else {\n            const range = Range1d.createXX(fraction0, fraction1);\n            range.intersectRangeXXInPlace(this._fraction0, this._fraction1);\n            if (!range.isNull)\n                this._summedLength += segmentLength * range.length() / (fraction1 - fraction0);\n        }\n    }\n    announcePointTangent(_xyz, _fraction, _tangent) {\n        // uh oh -- need to retain point for next interval\n    }\n}\n//# sourceMappingURL=CurveLengthContext.js.map",
      "start": 1693508124146,
      "end": 1693508124263,
      "sourcemaps": null
    }
  ]
}
