{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/ShadowUniforms.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { Matrix4d } from \"@itwin/core-geometry\";\nimport { ColorDef, RgbColor } from \"@itwin/core-common\";\nimport { FloatRgba } from \"./FloatRGBA\";\nimport { Matrix4 } from \"./Matrix\";\nimport { desync, sync } from \"./Sync\";\n/** Maintains state of uniforms used for applying shadows.\n * @internal\n */\nexport class ShadowUniforms {\n    constructor(target) {\n        this.syncKey = 0;\n        this._enabled = false;\n        this._projectionMatrix = Matrix4d.createIdentity();\n        this._color = RgbColor.fromJSON(undefined);\n        this._bias = 0;\n        // GPU state\n        this._projection32 = new Matrix4();\n        this._colorAndBias = new FloatRgba();\n        // Working variables\n        this._scratchModel = Matrix4d.createIdentity();\n        this._scratchModelProjection = Matrix4d.createIdentity();\n        this._target = target;\n    }\n    update() {\n        const map = this._target.solarShadowMap;\n        if (this._enabled !== map.isEnabled) {\n            desync(this);\n            this._enabled = map.isEnabled;\n        }\n        if (!map.isEnabled)\n            return;\n        const settings = map.settings;\n        if (this._bias !== settings.bias) {\n            desync(this);\n            this._bias = this._colorAndBias.alpha = settings.bias;\n        }\n        if (!this._color.equals(settings.color)) {\n            desync(this);\n            this._color = settings.color;\n            this._colorAndBias.setTbgr(ColorDef.computeTbgrFromComponents(settings.color.r, settings.color.g, settings.color.b));\n            this._colorAndBias.alpha = this._bias;\n        }\n        // NB: The projection matrix must be computed later when it is bound because it uses the model matrix.\n        const proj = map.projectionMatrix;\n        if (!proj.isExactEqual(this._projectionMatrix)) {\n            desync(this);\n            proj.clone(this._projectionMatrix);\n        }\n    }\n    computeProjection() {\n        const branch = this._target.uniforms.branch;\n        if (sync(branch, this))\n            return;\n        // NB: We could decouple from the other uniforms so they don't get invalidated when frustum changes but meh.\n        desync(this);\n        const proj = this._target.solarShadowMap.projectionMatrix;\n        const model = Matrix4d.createTransform(this._target.currentTransform, this._scratchModel);\n        const modelProj = proj.multiplyMatrixMatrix(model, this._scratchModelProjection);\n        this._projection32.initFromMatrix4d(modelProj);\n    }\n    bindColorAndBias(uniform) {\n        if (!sync(this, uniform))\n            this._colorAndBias.bind(uniform);\n    }\n    bindProjectionMatrix(uniform) {\n        this.computeProjection();\n        if (!sync(this, uniform))\n            uniform.setMatrix4(this._projection32);\n    }\n}\n//# sourceMappingURL=ShadowUniforms.js.map",
      "start": 1693508123820,
      "end": 1693508124045,
      "sourcemaps": null
    }
  ]
}
