{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/RealityMesh.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { assert, dispose, disposeArray } from \"@itwin/core-bentley\";\nimport { Quantization } from \"@itwin/core-common\";\nimport { Range2d, Range3d, Transform, Vector2d } from \"@itwin/core-geometry\";\nimport { GraphicBranch } from \"../GraphicBranch\";\nimport { TerrainTexture } from \"../RenderSystem\";\nimport { BufferHandle, BufferParameters, QBufferHandle2d, QBufferHandle3d } from \"./AttributeBuffers\";\nimport { AttributeMap } from \"./AttributeMap\";\nimport { IndexedGeometry, IndexedGeometryParams } from \"./CachedGeometry\";\nimport { GL } from \"./GL\";\nimport { Matrix4 } from \"./Matrix\";\nimport { Primitive } from \"./Primitive\";\nimport { System } from \"./System\";\nconst scratchOverlapRange = Range2d.createNull();\nconst scratchBytes = new Uint8Array(4);\nconst scratchBatchBaseId = new Uint32Array(scratchBytes.buffer);\nconst scratchRange2d = Range2d.createNull();\nclass ProjectedTexture {\n    constructor(classifier, meshParams, targetRectangle) {\n        this.meshParams = meshParams;\n        this.targetRectangle = targetRectangle;\n        this.classifier = classifier;\n    }\n    clone(targetRectangle) {\n        return new ProjectedTexture(this.classifier, this.meshParams, targetRectangle.clone());\n    }\n}\nclass RealityTextureParam {\n    constructor(texture, _projectedTextureOrMatrix) {\n        this.texture = texture;\n        this._projectedTextureOrMatrix = _projectedTextureOrMatrix;\n    }\n    get isProjected() { return this._projectedTextureOrMatrix instanceof ProjectedTexture; }\n    dispose() {\n        this.texture = dispose(this.texture);\n    }\n    /* There are two methods of applying a texture to a reality mesh.  the first member of \"params\" denotes which\n    method is to be used.  A value of zero indicates a standard texture and one represents a classified texture.\n  \n    A standard (nonprojected) texture is generated by multiplying v_textCoord by the scaling and translation packed into the first row\n    of \"matrix\". A clip rectangle is packed into second row of \"matrix\".\n  \n    A \"classified\" reality mesh texture is used for map layers.  It does not uses v_texCoord, the texture coordinates\n    are instead generated by a projection of the model position onto the X-Y plane. We only have eye position, not model position\n    so the matrix in this case is a real transform matrix that contains a mapping from eye to model position\n    followed by the model to texture projection.\n  */\n    getProjectionMatrix() {\n        return this._projectedTextureOrMatrix instanceof ProjectedTexture ? this._projectedTextureOrMatrix.classifier.projectionMatrix : undefined;\n    }\n    getTerrainMatrix() {\n        return this._projectedTextureOrMatrix instanceof Matrix4 ? this._projectedTextureOrMatrix : undefined;\n    }\n    getParams(result) {\n        /** Entry 0 is 0 for  */\n        if (this._projectedTextureOrMatrix instanceof ProjectedTexture) {\n            const projectedTexture = this._projectedTextureOrMatrix;\n            result.data[0] = 1;\n            result.data[1] = projectedTexture.classifier.textureImageCount;\n            result.data[2] = projectedTexture.classifier.sourceTransparency === undefined ? 1.0 : (1.0 - projectedTexture.classifier.sourceTransparency);\n            scratchBatchBaseId[0] = projectedTexture.classifier.baseBatchId;\n            result.data[4] = scratchBytes[0];\n            result.data[5] = scratchBytes[1];\n            result.data[6] = scratchBytes[2];\n            result.data[7] = scratchBytes[3];\n            const points = [];\n            const meshParams = projectedTexture.meshParams;\n            // Calculate range in the tiles local coordinates.\n            const low = meshParams.tileRectangle.worldToLocal(projectedTexture.targetRectangle.low, scratchRange2d.low);\n            const high = meshParams.tileRectangle.worldToLocal(projectedTexture.targetRectangle.high, scratchRange2d.high);\n            points.push(meshParams.projection.getGlobalPoint(low.x, low.y, 0));\n            points.push(meshParams.projection.getGlobalPoint(high.x, low.y, 0));\n            points.push(meshParams.projection.getGlobalPoint(high.x, high.y, 0));\n            points.push(meshParams.projection.getGlobalPoint(low.x, high.y, 0));\n            for (let i = 0, j = 8; i < 4; i++) {\n                const projectedPoint = projectedTexture.classifier.projectionMatrix.multiplyPoint3dQuietNormalize(points[i]);\n                result.data[j++] = projectedPoint.x;\n                result.data[j++] = projectedPoint.y;\n            }\n            const x0 = result.data[10] - result.data[8], y0 = result.data[11] - result.data[9];\n            const x1 = result.data[12] - result.data[8], y1 = result.data[13] - result.data[9];\n            if (x0 * y1 - x1 * y0 < 0) {\n                const swap = ((i, j) => {\n                    const temp = result.data[i];\n                    result.data[i] = result.data[j];\n                    result.data[j] = temp;\n                });\n                for (let i = 8, j = 14; i <= 10; i += 2, j -= 2) {\n                    swap(i, j);\n                    swap(i + 1, j + 1);\n                }\n            }\n        }\n        else {\n            result.data[0] = 0;\n        }\n        return result;\n    }\n}\n/** @internal */\nexport class RealityTextureParams {\n    constructor(params) {\n        this.params = params;\n    }\n    static create(textures) {\n        const maxTexturesPerMesh = System.instance.maxRealityImageryLayers;\n        assert(textures.length <= maxTexturesPerMesh);\n        const textureParams = new Array();\n        for (const texture of textures) {\n            if (texture instanceof TerrainTexture) {\n                const terrainTexture = texture;\n                const matrix = new Matrix4(); // Published as Mat4.\n                assert(terrainTexture.texture !== undefined, \"Texture not defined in TerrainTextureParams constructor\");\n                matrix.data[0] = terrainTexture.translate.x;\n                matrix.data[1] = terrainTexture.translate.y;\n                matrix.data[2] = terrainTexture.scale.x;\n                matrix.data[3] = terrainTexture.scale.y;\n                if (terrainTexture.clipRectangle) {\n                    matrix.data[4] = terrainTexture.clipRectangle.low.x;\n                    matrix.data[5] = terrainTexture.clipRectangle.low.y;\n                    matrix.data[6] = terrainTexture.clipRectangle.high.x;\n                    matrix.data[7] = terrainTexture.clipRectangle.high.y;\n                }\n                else {\n                    matrix.data[4] = matrix.data[5] = 0;\n                    matrix.data[6] = matrix.data[7] = 1;\n                }\n                matrix.data[8] = (1.0 - terrainTexture.transparency);\n                matrix.data[9] = terrainTexture.featureId;\n                textureParams.push(new RealityTextureParam(terrainTexture.texture, matrix));\n            }\n            else {\n                const classifier = texture.classifier;\n                textureParams.push(new RealityTextureParam(classifier.getOrCreateClassifierTexture(), texture));\n            }\n        }\n        for (let i = textures.length; i < maxTexturesPerMesh; i++) {\n            const matrix = new Matrix4();\n            matrix.data[0] = matrix.data[1] = 0.0;\n            matrix.data[2] = matrix.data[3] = 1.0;\n            matrix.data[4] = matrix.data[5] = 1;\n            matrix.data[6] = matrix.data[7] = -1;\n            matrix.data[15] = 0; // Denotes a terrain texture.\n            textureParams.push(new RealityTextureParam(undefined, matrix));\n        }\n        return new RealityTextureParams(textureParams);\n    }\n    dispose() {\n        disposeArray(this.params);\n    }\n}\n/** @internal */\nexport class RealityMeshGeometryParams extends IndexedGeometryParams {\n    constructor(positions, normals, uvParams, indices, numIndices, numBytesPerIndex, featureID) {\n        super(positions, indices, numIndices);\n        this.numBytesPerIndex = numBytesPerIndex;\n        let attrParams = AttributeMap.findAttribute(\"a_uvParam\", 7 /* TechniqueId.RealityMesh */, false);\n        assert(attrParams !== undefined);\n        this.buffers.addBuffer(uvParams, [BufferParameters.create(attrParams.location, 2, GL.DataType.UnsignedShort, false, 0, 0, false)]);\n        this.uvParams = uvParams;\n        if (undefined !== normals) {\n            attrParams = AttributeMap.findAttribute(\"a_norm\", 7 /* TechniqueId.RealityMesh */, false);\n            assert(attrParams !== undefined);\n            if (normals.bytesUsed > 0)\n                this.buffers.addBuffer(normals, [BufferParameters.create(attrParams.location, 2, GL.DataType.UnsignedByte, false, 0, 0, false)]);\n            this.normals = normals;\n        }\n        this.featureID = featureID;\n    }\n    static createFromBuffers(posBuf, uvParamBuf, indices, normBuf, featureID) {\n        const indBuf = BufferHandle.createBuffer(GL.Buffer.Target.ElementArrayBuffer, indices);\n        if (undefined === indBuf)\n            return undefined;\n        const bytesPerIndex = indices.BYTES_PER_ELEMENT;\n        assert(1 === bytesPerIndex || 2 === bytesPerIndex || 4 === bytesPerIndex);\n        return new RealityMeshGeometryParams(posBuf, normBuf, uvParamBuf, indBuf, indices.length, bytesPerIndex, featureID);\n    }\n    static fromRealityMesh(params) {\n        const posBuf = QBufferHandle3d.create(params.positions.params, params.positions.points);\n        const uvParamBuf = QBufferHandle2d.create(params.uvs.params, params.uvs.points);\n        const normalBuf = params.normals ? BufferHandle.createArrayBuffer(params.normals) : undefined;\n        return (undefined === posBuf || undefined === uvParamBuf) ? undefined : this.createFromBuffers(posBuf, uvParamBuf, params.indices, normalBuf, params.featureID ?? 0);\n    }\n    get isDisposed() {\n        return super.isDisposed && this.uvParams.isDisposed;\n    }\n    get bytesUsed() { return this.positions.bytesUsed + (undefined === this.normals ? 0 : this.normals.bytesUsed) + this.uvParams.bytesUsed + this.indices.bytesUsed; }\n    dispose() {\n        super.dispose();\n        dispose(this.uvParams);\n    }\n}\n/** @internal */\nexport class RealityMeshGeometry extends IndexedGeometry {\n    get asRealityMesh() { return this; }\n    get isDisposed() { return this._realityMeshParams.isDisposed; }\n    get uvQParams() { return this._realityMeshParams.uvParams.params; }\n    get hasFeatures() { return this._realityMeshParams.featureID !== undefined; }\n    get supportsThematicDisplay() { return true; }\n    get overrideColorMix() { return .5; } // This could be a setting from either the mesh or the override if required.\n    get transform() { return this._transform; }\n    constructor(props) {\n        super(props.realityMeshParams);\n        this._realityMeshParams = props.realityMeshParams;\n        this.textureParams = props.textureParams;\n        this._transform = props.transform;\n        this.baseColor = props.baseColor;\n        this._baseIsTransparent = props.baseIsTransparent;\n        this._isTerrain = props.isTerrain;\n        this._disableTextureDisposal = props.disableTextureDisposal;\n        this.hasTextures = undefined !== this.textureParams && this.textureParams.params.some((x) => undefined !== x.texture);\n        const bytesPerIndex = props.realityMeshParams.numBytesPerIndex;\n        this._indexType = 1 === bytesPerIndex ? GL.DataType.UnsignedByte : (2 === bytesPerIndex ? GL.DataType.UnsignedShort : GL.DataType.UnsignedInt);\n    }\n    dispose() {\n        super.dispose();\n        dispose(this._realityMeshParams);\n        if (true !== this._disableTextureDisposal)\n            dispose(this.textureParams);\n    }\n    static createForTerrain(mesh, transform, disableTextureDisposal = false) {\n        const params = RealityMeshGeometryParams.fromRealityMesh(mesh);\n        if (!params)\n            return undefined;\n        return new RealityMeshGeometry({\n            realityMeshParams: params,\n            transform,\n            baseIsTransparent: false,\n            isTerrain: true,\n            disableTextureDisposal,\n        });\n    }\n    static createFromRealityMesh(realityMesh, disableTextureDisposal = false) {\n        const params = RealityMeshGeometryParams.fromRealityMesh(realityMesh);\n        if (!params)\n            return undefined;\n        const texture = realityMesh.texture ? new TerrainTexture(realityMesh.texture, realityMesh.featureID ?? 0, Vector2d.create(1.0, -1.0), Vector2d.create(0.0, 1.0), Range2d.createXYXY(0, 0, 1, 1), 0, 0) : undefined;\n        return new RealityMeshGeometry({ realityMeshParams: params, textureParams: texture ? RealityTextureParams.create([texture]) : undefined, baseIsTransparent: false, isTerrain: false, disableTextureDisposal });\n    }\n    getRange() {\n        return Range3d.createXYZXYZ(this.qOrigin[0], this.qOrigin[1], this.qOrigin[2], this.qOrigin[0] + Quantization.rangeScale16 * this.qScale[0], this.qOrigin[1] + Quantization.rangeScale16 * this.qScale[1], this.qOrigin[2] + Quantization.rangeScale16 * this.qScale[2]);\n    }\n    static createGraphic(system, params, disableTextureDisposal = false) {\n        const meshes = [];\n        const textures = params.textures ?? [];\n        const realityMesh = params.realityMesh;\n        const { baseColor, baseTransparent, featureTable, tileId, layerClassifiers } = params;\n        const texturesPerMesh = System.instance.maxRealityImageryLayers;\n        const layers = new Array();\n        // Collate the textures and classifiers layers into a single array.\n        for (const texture of textures) {\n            const layer = layers[texture.layerIndex];\n            if (layer) {\n                layer.push(texture);\n            }\n            else {\n                layers[texture.layerIndex] = [texture];\n            }\n        }\n        params.layerClassifiers?.forEach((layerClassifier, layerIndex) => layers[layerIndex] = [new ProjectedTexture(layerClassifier, params, params.tileRectangle)]);\n        if (layers.length < 2 && !layerClassifiers?.size && textures.length < texturesPerMesh) {\n            // If only there is not more than one layer then we can group all of the textures into a single draw call.\n            meshes.push(new RealityMeshGeometry({ realityMeshParams: realityMesh._realityMeshParams, textureParams: RealityTextureParams.create(textures), transform: realityMesh._transform, baseColor, baseIsTransparent: baseTransparent, isTerrain: realityMesh._isTerrain, disableTextureDisposal }));\n        }\n        else {\n            let primaryLayer;\n            while (primaryLayer === undefined)\n                primaryLayer = layers.shift();\n            if (!primaryLayer)\n                return undefined;\n            for (const primaryTexture of primaryLayer) {\n                const targetRectangle = primaryTexture.targetRectangle;\n                const overlapMinimum = 1.0E-5 * (targetRectangle.high.x - targetRectangle.low.x) * (targetRectangle.high.y - targetRectangle.low.y);\n                let layerTextures = [primaryTexture];\n                for (const secondaryLayer of layers) {\n                    if (!secondaryLayer)\n                        continue;\n                    for (const secondaryTexture of secondaryLayer) {\n                        if (secondaryTexture instanceof ProjectedTexture) {\n                            layerTextures.push(secondaryTexture.clone(targetRectangle));\n                        }\n                        else {\n                            const secondaryRectangle = secondaryTexture.targetRectangle;\n                            const overlap = targetRectangle.intersect(secondaryRectangle, scratchOverlapRange);\n                            if (!overlap.isNull && (overlap.high.x - overlap.low.x) * (overlap.high.y - overlap.low.y) > overlapMinimum) {\n                                const textureRange = Range2d.createXYXY(overlap.low.x, overlap.low.y, overlap.high.x, overlap.high.y);\n                                secondaryRectangle.worldToLocal(textureRange.low, textureRange.low);\n                                secondaryRectangle.worldToLocal(textureRange.high, textureRange.high);\n                                if (secondaryTexture.clipRectangle)\n                                    textureRange.intersect(secondaryTexture.clipRectangle, textureRange);\n                                if (!textureRange.isNull && textureRange) {\n                                    layerTextures.push(secondaryTexture.cloneWithClip(textureRange));\n                                }\n                            }\n                        }\n                    }\n                }\n                while (layerTextures.length > texturesPerMesh) {\n                    meshes.push(new RealityMeshGeometry({ realityMeshParams: realityMesh._realityMeshParams, textureParams: RealityTextureParams.create(layerTextures.slice(0, texturesPerMesh)), transform: realityMesh._transform, baseColor, baseIsTransparent: baseTransparent, isTerrain: realityMesh._isTerrain, disableTextureDisposal }));\n                    layerTextures = layerTextures.slice(texturesPerMesh);\n                }\n                meshes.push(new RealityMeshGeometry({ realityMeshParams: realityMesh._realityMeshParams, textureParams: RealityTextureParams.create(layerTextures), transform: realityMesh._transform, baseColor, baseIsTransparent: baseTransparent, isTerrain: realityMesh._isTerrain, disableTextureDisposal }));\n            }\n        }\n        if (meshes.length === 0)\n            return undefined;\n        const branch = new GraphicBranch(true);\n        for (const mesh of meshes) {\n            const primitive = Primitive.create(mesh);\n            branch.add(system.createBatch(primitive, featureTable, mesh.getRange(), { tileId }));\n        }\n        return system.createBranch(branch, realityMesh._transform ? realityMesh._transform : Transform.createIdentity());\n    }\n    collectStatistics(stats) {\n        this._isTerrain ? stats.addTerrain(this._realityMeshParams.bytesUsed) : stats.addRealityMesh(this._realityMeshParams.bytesUsed);\n    }\n    get techniqueId() { return 7 /* TechniqueId.RealityMesh */; }\n    getPass(target) {\n        if (this._baseIsTransparent || (target.wantThematicDisplay && target.uniforms.thematic.wantIsoLines))\n            return \"translucent\";\n        return \"opaque\";\n    }\n    get renderOrder() { return 3 /* RenderOrder.UnlitSurface */; }\n    draw() {\n        this._params.buffers.bind();\n        System.instance.context.drawElements(GL.PrimitiveType.Triangles, this._params.numIndices, this._indexType, 0);\n        this._params.buffers.unbind();\n    }\n}\n//# sourceMappingURL=RealityMesh.js.map",
      "start": 1693508123648,
      "end": 1693508123742,
      "sourcemaps": null
    }
  ]
}
