{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/common/lib/esm/rpc/core/RpcRegistry.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module RpcInterface\n */\nimport { BentleyStatus } from \"@itwin/core-bentley\";\nimport { IModelError } from \"../../IModelError\";\nimport { RpcConfiguration } from \"./RpcConfiguration\";\nimport { RpcPendingQueue } from \"./RpcPendingQueue\";\nimport { initializeRpcRequest } from \"./RpcRequest\";\nimport { RpcRoutingToken } from \"./RpcRoutingToken\";\nimport { RpcInterface } from \"../../RpcInterface\";\nimport { RpcControlChannel } from \"./RpcControl\";\nimport { RpcOperation, RpcOperationPolicy } from \"./RpcOperation\";\n/* eslint-disable deprecation/deprecation */\n/** @internal */\nexport const REGISTRY = Symbol.for(\"@itwin/core-common/RpcRegistry\");\n/** @internal */\nexport const OPERATION = Symbol.for(\"@itwin/core-common/RpcOperation\");\n/** @internal */\nexport const POLICY = Symbol.for(\"@itwin/core-common/RpcOperationPolicy\");\n/** @internal */\nexport const INSTANCE = Symbol.for(\"@itwin/core-common/RpcInterface/__instance__\");\n/** @internal */\nexport const CURRENT_REQUEST = Symbol.for(\"@itwin/core-common/RpcRequest/__current__\");\n/** @internal */\nexport const CURRENT_INVOCATION = Symbol.for(\"@itwin/core-common/RpcInvocation/__current__\");\n/** @internal */\nexport class RpcRegistry {\n    constructor() {\n        this.definitionClasses = new Map();\n        this.proxies = new Map();\n        this.implementations = new Map();\n        this.suppliedImplementations = new Map();\n        this.implementationClasses = new Map();\n        this.id = (() => {\n            let i = 0;\n            return () => ++i;\n        })();\n    }\n    static get instance() {\n        if (!RpcRegistry._instance) {\n            const globalObj = typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {};\n            if (!globalObj[REGISTRY])\n                globalObj[REGISTRY] = new RpcRegistry();\n            RpcRegistry._instance = globalObj[REGISTRY];\n        }\n        return RpcRegistry._instance;\n    }\n    lookupInterfaceDefinition(name) {\n        if (!this.definitionClasses.has(name))\n            throw new IModelError(BentleyStatus.ERROR, `RPC interface \"${name}\" is not initialized.`);\n        return this.definitionClasses.get(name);\n    }\n    async describeAvailableEndpoints() {\n        const requests = [];\n        for (const channel of RpcControlChannel.channels) {\n            requests.push(channel.describeEndpoints());\n        }\n        const responses = await Promise.all(requests);\n        const endpoints = responses.reduce((a, b) => a.concat(b), []);\n        for (const endpoint of endpoints) {\n            const definition = this.definitionClasses.get(endpoint.interfaceName);\n            endpoint.compatible = (definition && RpcInterface.isVersionCompatible(endpoint.interfaceVersion, definition.interfaceVersion)) ? true : false;\n        }\n        return endpoints;\n    }\n    getClientForInterface(definition, routing = RpcRoutingToken.default) {\n        let instance;\n        const proxies = this.proxies.get(definition.interfaceName);\n        if (proxies) {\n            instance = proxies.get(routing.id);\n        }\n        if (!instance)\n            instance = this.instantiateClient(definition, routing);\n        return instance;\n    }\n    getImplForInterface(definition) {\n        let instance = this.implementations.get(definition.interfaceName);\n        if (!instance)\n            instance = this.instantiateImpl(definition);\n        return instance;\n    }\n    lookupImpl(interfaceName) {\n        const definition = this.lookupInterfaceDefinition(interfaceName);\n        return this.getImplForInterface(definition);\n    }\n    registerImpl(definition, implementation) {\n        this.unregisterImpl(definition);\n        this.implementationClasses.set(definition.interfaceName, implementation);\n    }\n    unregisterImpl(definition) {\n        this.implementationClasses.delete(definition.interfaceName);\n        const impl = this.implementations.get(definition.interfaceName);\n        if (impl) {\n            impl.configuration.onRpcImplTerminated(definition, impl);\n            this.implementations.delete(definition.interfaceName);\n        }\n    }\n    supplyImplInstance(definition, instance) {\n        this.suppliedImplementations.set(definition.interfaceName, instance);\n    }\n    isRpcInterfaceInitialized(definition) {\n        return this.definitionClasses.has(definition.interfaceName);\n    }\n    initializeRpcInterface(definition) {\n        if (this.definitionClasses.has(definition.interfaceName)) {\n            const existing = this.definitionClasses.get(definition.interfaceName);\n            if (existing && definition.interfaceVersion === \"CONTROL\" && existing !== definition) {\n                this.configureOperations(definition); // configs that differ only by routing still need the control ops initialized\n            }\n            return;\n        }\n        this.notifyInitialize();\n        this.definitionClasses.set(definition.interfaceName, definition);\n        this.configureOperations(definition);\n    }\n    terminateRpcInterface(definition) {\n        this.unregisterImpl(definition);\n        this.purgeClient(definition);\n        this.definitionClasses.delete(definition.interfaceName);\n    }\n    instantiateImpl(definition) {\n        this.checkInitialized(definition);\n        const registeredImplementation = this.implementationClasses.get(definition.interfaceName);\n        if (!registeredImplementation)\n            throw new IModelError(BentleyStatus.ERROR, `An RPC interface implementation class for \"${definition.interfaceName}\" is not registered.`);\n        if (definition.prototype.configurationSupplier)\n            registeredImplementation.prototype.configurationSupplier = definition.prototype.configurationSupplier;\n        const supplied = this.suppliedImplementations.get(definition.interfaceName);\n        const implementation = supplied || new registeredImplementation();\n        if (!(implementation instanceof registeredImplementation))\n            throw new IModelError(BentleyStatus.ERROR, `Invalid RPC interface implementation.`);\n        if (supplied) {\n            supplied.configuration = RpcConfiguration.supply(supplied);\n        }\n        this.implementations.set(definition.interfaceName, implementation);\n        implementation.configuration.onRpcImplInitialized(definition, implementation);\n        return implementation;\n    }\n    instantiateClient(definition, routing = RpcRoutingToken.default) {\n        this.checkInitialized(definition);\n        const proxy = new definition(routing);\n        if (!this.proxies.has(definition.interfaceName)) {\n            this.proxies.set(definition.interfaceName, new Map());\n        }\n        this.proxies.get(definition.interfaceName)?.set(routing.id, proxy);\n        Object.getOwnPropertyNames(definition.prototype).forEach((operationName) => {\n            if (operationName === \"constructor\" || operationName === \"configurationSupplier\")\n                return;\n            this.interceptOperation(proxy, operationName);\n        });\n        proxy.configuration.onRpcClientInitialized(definition, proxy);\n        return proxy;\n    }\n    interceptOperation(proxy, operation) {\n        const clientFunction = proxy[operation];\n        // eslint-disable-next-line prefer-arrow/prefer-arrow-functions\n        proxy[operation] = function () {\n            const args = Array.from(arguments);\n            args.push(operation);\n            return clientFunction.apply(proxy, args);\n        };\n    }\n    checkInitialized(definition) {\n        if (!this.definitionClasses.has(definition.interfaceName))\n            throw new IModelError(BentleyStatus.ERROR, `RPC interface \"${definition.interfaceName}\" is not initialized.`);\n    }\n    configureOperations(definition) {\n        const proto = definition.prototype;\n        Object.getOwnPropertyNames(proto).forEach((operationName) => {\n            if (operationName === \"constructor\" || operationName === \"configurationSupplier\")\n                return;\n            const propertyName = RpcOperation.computeOperationName(operationName);\n            if (!proto[propertyName][OPERATION]) {\n                const policy = definition[POLICY] || new RpcOperationPolicy();\n                proto[propertyName][OPERATION] = new RpcOperation(definition, propertyName, policy);\n            }\n        });\n    }\n    purgeClient(definition) {\n        const proxies = this.proxies.get(definition.interfaceName);\n        if (proxies) {\n            proxies.forEach((proxy) => proxy.configuration.onRpcClientTerminated(definition, proxy));\n            this.proxies.delete(definition.interfaceName);\n        }\n    }\n    notifyInitialize() {\n        initializeRpcRequest();\n        RpcPendingQueue.initialize();\n    }\n}\n//# sourceMappingURL=RpcRegistry.js.map",
      "start": 1693508120824,
      "end": 1693508120883,
      "sourcemaps": null
    }
  ]
}
