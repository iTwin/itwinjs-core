{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/GLTimer.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\nimport { BentleyStatus } from \"@itwin/core-bentley\";\nimport { IModelError } from \"@itwin/core-common\";\nclass DisjointTimerExtension {\n    constructor(system) {\n        this._e = system.disjointTimerQuery;\n        this._context = system.context;\n    }\n    get isSupported() { return this._e !== undefined; }\n    didDisjointEventHappen() {\n        return this._context.getParameter(this._e.GPU_DISJOINT_EXT);\n    }\n    createQuery() { return this._context.createQuery(); }\n    deleteQuery(q) { this._context.deleteQuery(q); }\n    beginQuery(q) { this._context.beginQuery(this._e.TIME_ELAPSED_EXT, q); }\n    endQuery() { this._context.endQuery(this._e.TIME_ELAPSED_EXT); }\n    isResultAvailable(q) {\n        return this._context.getQueryParameter(q, this._context.QUERY_RESULT_AVAILABLE);\n    }\n    getResult(q) {\n        return this._context.getQueryParameter(q, this._context.QUERY_RESULT);\n    }\n}\n/** Record GPU hardware queries to profile independent of CPU.\n *\n * This is a wrapper around EXT_disjoint_timer_query. The extension should be available in the following browsers:\n *  * Chrome 67 and later\n *  * Chromium-based Edge\n *  * Firefox (with webgl.enable-privileged-extensions set to true in about:config)\n *\n * EXT_disjoint_timer_query only supports one active query per context without nesting. This wrapper keeps an internal stack to make\n * nesting work.\n *\n * The extension API makes timestamps look like a better solution than disjoint timers, but they are not actually supported.\n * See https://bugs.chromium.org/p/chromium/issues/detail?id=595172\n * @internal\n */\nexport class GLTimer {\n    constructor(system) {\n        this._extension = new DisjointTimerExtension(system);\n        this._queryStack = [];\n        this._resultsCallback = undefined;\n    }\n    // This class is necessarily a singleton per context because of the underlying extension it wraps.\n    // System is expected to call create in its constructor.\n    static create(system) {\n        return new GLTimer(system);\n    }\n    get isSupported() { return this._extension.isSupported; }\n    set resultsCallback(callback) {\n        if (this._queryStack.length !== 0)\n            throw new IModelError(BentleyStatus.ERROR, \"Do not set resultsCallback when a frame is already being drawn\");\n        this._resultsCallback = callback;\n    }\n    beginOperation(label) {\n        if (!this._resultsCallback)\n            return;\n        this.pushQuery(label);\n    }\n    endOperation() {\n        if (!this._resultsCallback)\n            return;\n        if (this._queryStack.length === 0)\n            throw new IModelError(BentleyStatus.ERROR, \"Mismatched calls to beginOperation/endOperation\");\n        this.popQuery();\n    }\n    beginFrame() {\n        if (!this._resultsCallback)\n            return;\n        if (this._queryStack.length !== 0)\n            throw new IModelError(BentleyStatus.ERROR, \"Already recording timing for a frame\");\n        const query = this._extension.createQuery();\n        this._extension.beginQuery(query);\n        this._queryStack.push({ label: \"Total\", query, children: [] });\n    }\n    endFrame() {\n        if (!this._resultsCallback)\n            return;\n        if (this._queryStack.length !== 1)\n            throw new IModelError(BentleyStatus.ERROR, \"Missing at least one endOperation call\");\n        this._extension.endQuery();\n        const root = this._queryStack.pop();\n        const userCallback = this._resultsCallback;\n        const queryCallback = () => {\n            if (this._extension.didDisjointEventHappen()) {\n                // Have to throw away results for this frame after disjoint event occurs.\n                this.cleanupAfterDisjointEvent(root);\n                return;\n            }\n            // It takes more one or more frames for results to become available.\n            // Only checking time for root since it will always be the last query completed.\n            if (!this._extension.isResultAvailable(root.query)) {\n                setTimeout(queryCallback, 0);\n                return;\n            }\n            const processQueryEntry = (queryEntry) => {\n                const time = this._extension.getResult(queryEntry.query);\n                this._extension.deleteQuery(queryEntry.query);\n                const result = { label: queryEntry.label, nanoseconds: time };\n                if (queryEntry.children === undefined)\n                    return result;\n                result.children = [];\n                for (const child of queryEntry.children) {\n                    const childResult = processQueryEntry(child);\n                    result.children.push(childResult);\n                    result.nanoseconds += childResult.nanoseconds;\n                }\n                return result;\n            };\n            userCallback(processQueryEntry(root));\n        };\n        setTimeout(queryCallback, 0);\n    }\n    cleanupAfterDisjointEvent(queryEntry) {\n        this._extension.deleteQuery(queryEntry.query);\n        if (!queryEntry.children)\n            return;\n        for (const child of queryEntry.children)\n            this.cleanupAfterDisjointEvent(child);\n    }\n    pushQuery(label) {\n        this._extension.endQuery();\n        const query = this._extension.createQuery();\n        this._extension.beginQuery(query);\n        const activeQuery = this._queryStack[this._queryStack.length - 1];\n        const queryEntry = { label, query };\n        this._queryStack.push(queryEntry);\n        if (activeQuery.children === undefined)\n            activeQuery.children = [queryEntry];\n        else\n            activeQuery.children.push(queryEntry);\n    }\n    popQuery() {\n        this._extension.endQuery();\n        this._queryStack.pop();\n        const activeQuery = this._queryStack[this._queryStack.length - 1];\n        this._extension.beginQuery(activeQuery.query);\n    }\n}\n//# sourceMappingURL=GLTimer.js.map",
      "start": 1693508123633,
      "end": 1693508123676,
      "sourcemaps": null
    }
  ]
}
