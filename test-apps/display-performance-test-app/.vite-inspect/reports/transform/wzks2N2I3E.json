{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tile/OrbitGtTileTree.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module TileTreeSupplier\n */\nimport { assert, BeTimePoint, compareStringsOrUndefined, Id64 } from \"@itwin/core-bentley\";\nimport { BatchType, Cartographic, ColorDef, Feature, FeatureTable, Frustum, FrustumPlanes, GeoCoordStatus, PackedFeatureTable, QParams3d, Quantization, RealityDataFormat, RealityDataProvider, } from \"@itwin/core-common\";\nimport { Point3d, Range3d, Transform, Vector3d } from \"@itwin/core-geometry\";\nimport { CRSManager, Downloader, DownloaderXhr, OnlineEngine, OPCReader, OrbitGtAList, OrbitGtBounds, OrbitGtCoordinate, OrbitGtDataManager, OrbitGtFrameData, OrbitGtIViewRequest, OrbitGtTileLoadSorter, PageCachedFile, PointDataRaw, UrlFS, } from \"@itwin/core-orbitgt\";\nimport { calculateEcefToDbTransformAtLocation } from \"../BackgroundMapGeometry\";\nimport { DisplayStyleState } from \"../DisplayStyleState\";\nimport { IModelApp } from \"../IModelApp\";\nimport { RealityDataSource } from \"../RealityDataSource\";\nimport { Mesh } from \"../render/primitives/mesh/MeshPrimitives\";\nimport { RealityModelTileTree, Tile, TileLoadPriority, TileTree, TileUsageMarker, } from \"./internal\";\nconst scratchRange = Range3d.create();\nconst scratchWorldFrustum = new Frustum();\nfunction compareSourceKeys(lhs, rhs) {\n    return compareStringsOrUndefined(lhs.id, rhs.id) || compareStringsOrUndefined(lhs.format, rhs.format) || compareStringsOrUndefined(lhs.iTwinId, rhs.iTwinId);\n}\nclass OrbitGtTreeSupplier {\n    getOwner(treeId, iModel) {\n        return iModel.tiles.getTileTreeOwner(treeId, this);\n    }\n    async createTileTree(treeId, iModel) {\n        return OrbitGtTileTree.createOrbitGtTileTree(treeId.rdSourceKey, iModel, treeId.modelId);\n    }\n    compareTileTreeIds(lhs, rhs) {\n        return compareStringsOrUndefined(lhs.modelId, rhs.modelId) || compareSourceKeys(lhs.rdSourceKey, rhs.rdSourceKey);\n    }\n    findCompatibleContextRealityModelId(sourceKey, style) {\n        const owners = style.iModel.tiles.getTreeOwnersForSupplier(this);\n        for (const owner of owners) {\n            // Find an existing tree with the same reality data source key.\n            if (0 === compareSourceKeys(sourceKey, owner.id.rdSourceKey)) {\n                const modelId = owner.id.modelId;\n                assert(undefined !== modelId);\n                // If the model Id is unused by any other context reality model in the view and does not identify a persistent reality model, use it.\n                if (Id64.isTransientId64(modelId) && !style.contextRealityModelStates.some((model) => model.modelId === modelId))\n                    return modelId;\n            }\n        }\n        return undefined;\n    }\n}\nconst orbitGtTreeSupplier = new OrbitGtTreeSupplier();\nfunction transformFromOrbitGt(ogtTransform, result) {\n    if (undefined === result)\n        result = Transform.createIdentity();\n    result.matrix.setRowValues(ogtTransform.getElement(0, 0), ogtTransform.getElement(0, 1), ogtTransform.getElement(0, 2), ogtTransform.getElement(1, 0), ogtTransform.getElement(1, 1), ogtTransform.getElement(1, 2), ogtTransform.getElement(2, 0), ogtTransform.getElement(2, 1), ogtTransform.getElement(2, 2));\n    result.origin.x = ogtTransform.getElement(0, 3);\n    result.origin.y = ogtTransform.getElement(1, 3);\n    result.origin.z = ogtTransform.getElement(2, 3);\n    return result;\n}\nfunction pointFromOrbitGt(ogtCoordinate, result) {\n    if (undefined === result)\n        result = Point3d.create();\n    result.x = ogtCoordinate.x;\n    result.y = ogtCoordinate.y;\n    result.z = ogtCoordinate.z;\n    return result;\n}\nfunction rangeFromOrbitGt(ogtBounds, result) {\n    if (undefined === result)\n        result = Range3d.create();\n    pointFromOrbitGt(ogtBounds.min, result.low);\n    pointFromOrbitGt(ogtBounds.max, result.high);\n    return result;\n}\n/** @internal */\nexport function createOrbitGtTileTreeReference(props) {\n    return new OrbitGtTreeReference(props);\n}\nclass OrbitGtTileTreeParams {\n    get priority() { return TileLoadPriority.Context; }\n    constructor(rdSourceKey, iModel, modelId, location) {\n        this.location = location;\n        const key = rdSourceKey;\n        this.id = `${key.provider}:${key.format}:${key.id}:${key.iTwinId}`;\n        this.modelId = modelId;\n        this.iModel = iModel;\n    }\n}\nclass OrbitGtRootTile extends Tile {\n    _loadChildren(_resolve, _reject) { }\n    async requestContent(_isCanceled) { return undefined; }\n    get channel() { return IModelApp.tileAdmin.channels.getForHttp(\"itwinjs-orbitgit\"); }\n    async readContent(_data, _system, _isCanceled) { return {}; }\n    freeMemory() { }\n    constructor(params, tree) { super(params, tree); }\n}\nclass OrbitGtViewRequest extends OrbitGtIViewRequest {\n    constructor(_tileDrawArgs, _centerOffset) {\n        super();\n        this._tileDrawArgs = _tileDrawArgs;\n        this._centerOffset = _centerOffset;\n        this._tileToIModelTransform = _tileDrawArgs.location.multiplyTransformTransform(Transform.createTranslation(_centerOffset));\n    }\n    isVisibleBox(bounds) {\n        const box = Frustum.fromRange(rangeFromOrbitGt(bounds, scratchRange));\n        const worldBox = box.transformBy(this._tileToIModelTransform, scratchWorldFrustum);\n        return FrustumPlanes.Containment.Outside !== this._tileDrawArgs.frustumPlanes.computeFrustumContainment(worldBox, undefined);\n    }\n    getFrameTime() {\n        return this._tileDrawArgs.now.milliseconds;\n    }\n    shouldSplit(level, tile) {\n        // get the world size of the tile voxels\n        const tileCenter = level.getTileGrid().getCellCenter(tile.gridIndex);\n        tileCenter.x += this._centerOffset.x;\n        tileCenter.y += this._centerOffset.y;\n        tileCenter.z += this._centerOffset.z;\n        const worldCenter = this._tileDrawArgs.location.multiplyXYZ(tileCenter.x, tileCenter.y, tileCenter.z);\n        const worldCenter2 = this._tileDrawArgs.location.multiplyXYZ(tileCenter.x, tileCenter.y, tileCenter.z + level.getTileGrid().size.z);\n        const voxelSize = worldCenter2.distance(worldCenter) / 64;\n        // get the world size of a screen pixel at the tile center\n        const viewPt = this._tileDrawArgs.worldToViewMap.transform0.multiplyPoint3dQuietNormalize(worldCenter);\n        const viewPt2 = new Point3d(viewPt.x + 1.0, viewPt.y, viewPt.z);\n        const pixelSizeAtCenter = this._tileDrawArgs.worldToViewMap.transform1.multiplyPoint3dQuietNormalize(viewPt).distance(this._tileDrawArgs.worldToViewMap.transform1.multiplyPoint3dQuietNormalize(viewPt2));\n        // stop splitting if the voxel size of the children becomes too small to improve quality\n        const split = (0.5 * voxelSize > 2.0 * pixelSizeAtCenter);\n        return split;\n    }\n}\nclass TileSortProjector {\n    constructor(iModelTransform, viewingSpace, centerOffset) {\n        const rotation = viewingSpace.rotation;\n        let origin;\n        if (undefined === viewingSpace.eyePoint) {\n            origin = Vector3d.createFrom(viewingSpace.viewOrigin);\n            const viewDelta = viewingSpace.viewDelta;\n            const eyeDelta = Vector3d.createFrom({ x: viewDelta.x / 2, y: viewDelta.y / 2, z: viewDelta.z * 10 });\n            rotation.multiplyVector(eyeDelta, eyeDelta);\n            origin.addInPlace(eyeDelta);\n        }\n        else {\n            origin = Vector3d.createFrom(viewingSpace.eyePoint);\n        }\n        rotation.multiplyVector(origin);\n        origin.scaleInPlace(-1);\n        const toViewTransform = Transform.createOriginAndMatrix(origin, rotation);\n        const tileToIModelTransform = iModelTransform.multiplyTransformTransform(Transform.createTranslation(centerOffset));\n        this._sortTransform = toViewTransform.multiplyTransformTransform(tileToIModelTransform);\n    }\n    projectToViewForSort(coordinate) {\n        const point = pointFromOrbitGt(coordinate);\n        this._sortTransform.multiplyPoint3d(point, point);\n        coordinate.x = point.x;\n        coordinate.y = point.y;\n        coordinate.z = point.z;\n    }\n}\nclass OrbitGtTileGraphic extends TileUsageMarker {\n    constructor(graphic, viewport, time) {\n        super();\n        this.graphic = graphic;\n        this.mark(viewport, time);\n    }\n    dispose() {\n        this.graphic.dispose();\n    }\n}\n/** @internal */\nexport class OrbitGtTileTree extends TileTree {\n    constructor(treeParams, _dataManager, cloudRange, _centerOffset, _ecefTransform) {\n        super(treeParams);\n        this._dataManager = _dataManager;\n        this._centerOffset = _centerOffset;\n        this._ecefTransform = _ecefTransform;\n        this.viewFlagOverrides = {};\n        this._tileGraphics = new Map();\n        const worldContentRange = this.iModelTransform.multiplyRange(cloudRange);\n        /* eslint-disable-next-line deprecation/deprecation */\n        this.iModel.expandDisplayedExtents(worldContentRange);\n        this._tileParams = { contentId: \"0\", range: cloudRange, maximumSize: 256 };\n        this.rootTile = new OrbitGtRootTile(this._tileParams, this);\n    }\n    async getEcefTransform() {\n        return this._ecefTransform;\n    }\n    dispose() {\n        if (this.isDisposed)\n            return;\n        for (const graphic of this._tileGraphics.values())\n            graphic.dispose();\n        this._tileGraphics.clear();\n        super.dispose();\n    }\n    _selectTiles(_args) { return []; }\n    get is3d() { return true; }\n    get isContentUnbounded() { return false; }\n    get maxDepth() { return undefined; }\n    _doPrune(olderThan) {\n        for (const [key, graphic] of this._tileGraphics)\n            if (graphic.isExpired(olderThan)) {\n                graphic.dispose();\n                this._tileGraphics.delete(key);\n            }\n    }\n    prune() {\n        const olderThan = BeTimePoint.now().minus(this.expirationTime);\n        this._doPrune(olderThan);\n    }\n    collectStatistics(stats) {\n        for (const tileGraphic of this._tileGraphics)\n            tileGraphic[1].graphic.collectStatistics(stats);\n    }\n    draw(args) {\n        const debugControl = args.context.target.debugControl;\n        const debugBuilder = (debugControl && debugControl.displayRealityTileRanges) ? args.context.createSceneGraphicBuilder() : undefined;\n        const doLogging = (debugControl && debugControl.logRealityTiles);\n        const viewRequest = new OrbitGtViewRequest(args, this._centerOffset);\n        const levelsInView = new OrbitGtAList();\n        const blocksInView = new OrbitGtAList();\n        const tilesInView = new OrbitGtAList();\n        const frameData = new OrbitGtFrameData();\n        this._dataManager.getViewTree().renderView3D(viewRequest, levelsInView, blocksInView, tilesInView, frameData.tilesToRender);\n        this._dataManager.filterLoadList(levelsInView, blocksInView, tilesInView, frameData.levelsToLoad, frameData.blocksToLoad, frameData.tilesToLoad);\n        tilesInView.sort(new OrbitGtTileLoadSorter(this._dataManager.getViewTree(), new TileSortProjector(this.iModelTransform, args.context.viewingSpace, this._centerOffset)));\n        let totalPointCount = 0;\n        const tileCount = frameData.tilesToRender.size();\n        // Inform TileAdmin about tiles we are handling ourselves...\n        IModelApp.tileAdmin.addExternalTilesForUser(args.context.viewport, { requested: frameData.tilesToLoad.size() + (frameData.hasMissingData() ? 1 : 0), selected: tileCount, ready: tileCount });\n        if (debugBuilder)\n            debugBuilder.setSymbology(ColorDef.red, ColorDef.red, 1);\n        let minLevel = 100, maxLevel = -100;\n        for (let t = 0; t < tileCount; t++) {\n            const tile = frameData.tilesToRender.get(t);\n            minLevel = Math.min(minLevel, tile.tileIndex.level);\n            maxLevel = Math.max(maxLevel, tile.tileIndex.level);\n            totalPointCount += tile.tileIndex.pointCount;\n            const key = tile.tileIndex.key;\n            const cachedGraphic = this._tileGraphics.get(key);\n            if (undefined !== cachedGraphic) {\n                cachedGraphic.mark(args.context.viewport, args.now);\n                args.graphics.add(cachedGraphic.graphic);\n            }\n            else {\n                const range = rangeFromOrbitGt(tile.bounds);\n                range.low.addInPlace(this._centerOffset);\n                range.high.addInPlace(this._centerOffset);\n                const qParams = QParams3d.fromRange(range, undefined, (tile.points8 != null) ? Quantization.rangeScale8 : Quantization.rangeScale16);\n                const featureTable = new FeatureTable(1, this.modelId, BatchType.Primary);\n                const features = new Mesh.Features(featureTable);\n                const system = IModelApp.renderSystem;\n                const voxelSize = (range.high.x - range.low.x) / 64;\n                features.add(new Feature(this.modelId), 1);\n                const tilePoints = (tile.points8 != null) ? tile.points8.toNativeBuffer() : tile.points16.toNativeBuffer();\n                let renderGraphic = system.createPointCloud({\n                    positions: tilePoints,\n                    qparams: qParams,\n                    colors: tile.colors.toNativeBuffer(),\n                    features: features.toFeatureIndex(),\n                    voxelSize,\n                    colorFormat: \"bgr\",\n                }, this.iModel);\n                renderGraphic = system.createBatch(renderGraphic, PackedFeatureTable.pack(featureTable), range);\n                args.graphics.add(renderGraphic);\n                this._tileGraphics.set(key, new OrbitGtTileGraphic(renderGraphic, args.context.viewport, args.now));\n            }\n            if (debugBuilder)\n                debugBuilder.addRangeBox(rangeFromOrbitGt(tile.bounds));\n        }\n        if (debugBuilder)\n            args.graphics.add(debugBuilder.finish());\n        if (doLogging) {\n            // eslint-disable-next-line no-console\n            console.log(`Total OrbitGtTiles: ${tileCount} MinLevel: ${minLevel} MaxLevel: ${maxLevel} Total Points: ${totalPointCount}`);\n        }\n        args.drawGraphics();\n        if (frameData.hasMissingData()) {\n            this._dataManager.loadData(frameData).then(() => IModelApp.tileAdmin.onTileLoad.raiseEvent(this.rootTile)).catch((_err) => undefined);\n        }\n    }\n}\n/** @internal */\n// eslint-disable-next-line no-redeclare\n(function (OrbitGtTileTree) {\n    function isValidSASToken(downloadUrl) {\n        // Create fake URL for and parameter parsing and SAS token URI parsing\n        if (!downloadUrl.startsWith(\"http\"))\n            downloadUrl = `http://x.com/x?${downloadUrl}`;\n        const sasUrl = new URL(downloadUrl);\n        const se = sasUrl.searchParams.get(\"se\");\n        if (se) {\n            const expiryUTC = new Date(se);\n            const now = new Date();\n            const currentUTC = new Date(now?.toUTCString());\n            return expiryUTC >= currentUTC;\n        }\n        return false;\n    }\n    function isValidOrbitGtBlobProps(props) {\n        // Check main OrbitGtBlobProps fields are defined\n        if (!props.accountName || !props.containerName || !props.blobFileName || !props.sasToken)\n            return false;\n        // Check SAS token is valid\n        return isValidSASToken(props.sasToken);\n    }\n    async function createOrbitGtTileTree(rdSourceKey, iModel, modelId) {\n        const rdSource = await RealityDataSource.fromKey(rdSourceKey, iModel.iTwinId);\n        const isContextShare = rdSourceKey.provider === RealityDataProvider.ContextShare;\n        const isTilestUrl = rdSourceKey.provider === RealityDataProvider.TilesetUrl;\n        let blobStringUrl;\n        if (isContextShare) {\n            const realityData = rdSource ? rdSource.realityData : undefined;\n            if (rdSource === undefined || realityData === undefined)\n                return undefined;\n            const docRootName = realityData.rootDocument;\n            if (!docRootName)\n                return undefined;\n            const token = await IModelApp.getAccessToken();\n            const blobUrl = await realityData.getBlobUrl(token, docRootName);\n            blobStringUrl = blobUrl.toString();\n        }\n        else if (isTilestUrl) {\n            blobStringUrl = rdSourceKey.id;\n        }\n        else {\n            const orbitGtBlobProps = RealityDataSource.createOrbitGtBlobPropsFromKey(rdSourceKey);\n            if (orbitGtBlobProps === undefined)\n                return undefined;\n            if (!isValidOrbitGtBlobProps(orbitGtBlobProps))\n                return undefined;\n            const { accountName, containerName, blobFileName, sasToken } = orbitGtBlobProps;\n            blobStringUrl = blobFileName;\n            if (accountName.length > 0)\n                blobStringUrl = UrlFS.getAzureBlobSasUrl(accountName, containerName, blobFileName, sasToken);\n        }\n        if (Downloader.INSTANCE == null)\n            Downloader.INSTANCE = new DownloaderXhr();\n        if (CRSManager.ENGINE == null)\n            CRSManager.ENGINE = await OnlineEngine.create();\n        // wrap a caching layer (16 MB) around the blob file\n        const urlFS = new UrlFS();\n        const blobFileSize = await urlFS.getFileLength(blobStringUrl);\n        const cacheKilobytes = 128;\n        const cachedBlobFile = new PageCachedFile(urlFS, blobStringUrl, blobFileSize, cacheKilobytes * 1024 /* pageSize*/, 128 /* maxPageCount*/);\n        const pointCloudReader = await OPCReader.openFile(cachedBlobFile, blobStringUrl, true /* lazyLoading*/);\n        let pointCloudCRS = pointCloudReader.getFileCRS();\n        if (pointCloudCRS == null)\n            pointCloudCRS = \"\";\n        const dataManager = new OrbitGtDataManager(pointCloudReader, pointCloudCRS, PointDataRaw.TYPE);\n        const pointCloudBounds = dataManager.getPointCloudBounds();\n        const pointCloudRange = rangeFromOrbitGt(pointCloudBounds);\n        const pointCloudCenter = pointCloudRange.localXYZToWorld(.5, .5, .5);\n        const addCloudCenter = Transform.createTranslation(pointCloudCenter);\n        const ecefTransform = Transform.createIdentity();\n        let pointCloudCenterToDb = addCloudCenter;\n        if (pointCloudCRS.length > 0) {\n            await CRSManager.ENGINE.prepareForArea(pointCloudCRS, pointCloudBounds);\n            const wgs84CRS = \"4978\";\n            await CRSManager.ENGINE.prepareForArea(wgs84CRS, new OrbitGtBounds());\n            const pointCloudToEcef = transformFromOrbitGt(CRSManager.createTransform(pointCloudCRS, new OrbitGtCoordinate(pointCloudCenter.x, pointCloudCenter.y, pointCloudCenter.z), wgs84CRS));\n            const pointCloudCenterToEcef = pointCloudToEcef.multiplyTransformTransform(addCloudCenter);\n            ecefTransform.setFrom(pointCloudCenterToEcef);\n            let ecefToDb = iModel.getMapEcefToDb(0);\n            // In initial publishing version the iModel ecef Transform was used to locate the reality model.\n            // This would work well only for tilesets published from that iModel but for iModels the ecef transform is calculated\n            // at the center of the project extents and the reality model location may differ greatly, and the curvature of the earth\n            // could introduce significant errors.\n            // The publishing was modified to calculate the ecef transform at the reality model range center and at the same time the \"iModelPublishVersion\"\n            // member was added to the root object.\n            const ecefOrigin = pointCloudCenterToEcef.getOrigin();\n            const dbOrigin = ecefToDb.multiplyPoint3d(ecefOrigin);\n            const realityOriginToProjectDistance = iModel.projectExtents.distanceToPoint(dbOrigin);\n            const maxProjectDistance = 1E5; // Only use the project GCS projection if within 100KM of the project.   Don't attempt to use GCS if global reality model or in another locale - Results will be unreliable.\n            if (realityOriginToProjectDistance < maxProjectDistance) {\n                const cartographicOrigin = Cartographic.fromEcef(ecefOrigin);\n                const geoConverter = iModel.noGcsDefined ? undefined : iModel.geoServices.getConverter(\"WGS84\");\n                if (cartographicOrigin !== undefined && geoConverter !== undefined) {\n                    const geoOrigin = Point3d.create(cartographicOrigin.longitudeDegrees, cartographicOrigin.latitudeDegrees, cartographicOrigin.height);\n                    const response = await geoConverter.getIModelCoordinatesFromGeoCoordinates([geoOrigin]);\n                    if (response.iModelCoords[0].s === GeoCoordStatus.Success) {\n                        const ecefToDbOrigin = await calculateEcefToDbTransformAtLocation(Point3d.fromJSON(response.iModelCoords[0].p), iModel);\n                        if (ecefToDbOrigin)\n                            ecefToDb = ecefToDbOrigin;\n                    }\n                }\n            }\n            pointCloudCenterToDb = ecefToDb.multiplyTransformTransform(pointCloudCenterToEcef);\n        }\n        const params = new OrbitGtTileTreeParams(rdSourceKey, iModel, modelId, pointCloudCenterToDb);\n        // We use a RTC transform to avoid jitter from large cloud coordinates.\n        const centerOffset = Vector3d.create(-pointCloudCenter.x, -pointCloudCenter.y, -pointCloudCenter.z);\n        pointCloudRange.low.addInPlace(centerOffset);\n        pointCloudRange.high.addInPlace(centerOffset);\n        return new OrbitGtTileTree(params, dataManager, pointCloudRange, centerOffset, ecefTransform);\n    }\n    OrbitGtTileTree.createOrbitGtTileTree = createOrbitGtTileTree;\n})(OrbitGtTileTree || (OrbitGtTileTree = {}));\n/** Supplies a reality data [[TileTree]] from a URL. May be associated with a persistent [[GeometricModelState]], or attached at run-time via a [[ContextOrbitGtState]].\n * @internal exported strictly for tests.\n */\nexport class OrbitGtTreeReference extends RealityModelTileTree.Reference {\n    get castsShadows() { return false; }\n    get modelId() { return this._modelId; }\n    constructor(props) {\n        super(props);\n        // Create rdSourceKey if not provided\n        if (props.rdSourceKey) {\n            this._rdSourceKey = props.rdSourceKey;\n        }\n        else if (props.orbitGtBlob) {\n            this._rdSourceKey = RealityDataSource.createKeyFromOrbitGtBlobProps(props.orbitGtBlob);\n        }\n        else {\n            // TODO: Maybe we should throw an exception\n            this._rdSourceKey = RealityDataSource.createKeyFromBlobUrl(\"\", RealityDataProvider.OrbitGtBlob, RealityDataFormat.OPC);\n        }\n        // ###TODO find compatible model Id\n        let modelId = props.modelId;\n        if (undefined === modelId && this._source instanceof DisplayStyleState)\n            modelId = orbitGtTreeSupplier.findCompatibleContextRealityModelId(this._rdSourceKey, this._source);\n        this._modelId = modelId ?? props.iModel.transientIds.getNext();\n        const ogtTreeId = { rdSourceKey: this._rdSourceKey, modelId: this.modelId };\n        this.treeOwner = orbitGtTreeSupplier.getOwner(ogtTreeId, props.iModel);\n    }\n    async getToolTip(hit) {\n        const tree = this.treeOwner.tileTree;\n        if (undefined === tree || hit.iModel !== tree.iModel)\n            return undefined;\n        const strings = [];\n        strings.push(IModelApp.localization.getLocalizedString(\"iModelJs:RealityModelTypes.OrbitGTPointCloud\"));\n        if (this._name)\n            strings.push(`${IModelApp.localization.getLocalizedString(\"iModelJs:TooltipInfo.Name\")} ${this._name}`);\n        const div = document.createElement(\"div\");\n        div.innerHTML = strings.join(\"<br>\");\n        return div;\n    }\n}\n//# sourceMappingURL=OrbitGtTileTree.js.map",
      "start": 1693508121917,
      "end": 1693508122111,
      "sourcemaps": null
    }
  ]
}
