{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/MeshData.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { dispose } from \"@itwin/core-bentley\";\nimport { FeatureIndexType, LinePixels } from \"@itwin/core-common\";\nimport { LineCode } from \"./LineCode\";\nimport { createMaterialInfo } from \"./Material\";\nimport { VertexLUT } from \"./VertexLUT\";\n/** @internal */\nexport class MeshData {\n    constructor(lut, params, viOrigin) {\n        this.lut = lut;\n        this.viewIndependentOrigin = viOrigin;\n        this.hasFeatures = FeatureIndexType.Empty !== params.vertices.featureIndexType;\n        if (FeatureIndexType.Uniform === params.vertices.featureIndexType)\n            this.uniformFeatureId = params.vertices.uniformFeatureID;\n        this.textureUsesConstantLod = false;\n        this.normalMapUsesConstantLod = false;\n        if (undefined !== params.surface.textureMapping) {\n            this.texture = params.surface.textureMapping.texture;\n            this._textureAlwaysDisplayed = params.surface.textureMapping.alwaysDisplayed;\n            if (undefined !== params.surface.material && !params.surface.material.isAtlas) {\n                const matTM = params.surface.material.material.textureMapping;\n                if (undefined !== matTM) {\n                    this.textureUsesConstantLod = this.texture && matTM.params.useConstantLod;\n                    if (undefined !== matTM.normalMapParams) {\n                        this.normalMapUsesConstantLod = matTM.normalMapParams.useConstantLod;\n                        if (undefined !== matTM.normalMapParams.normalMap) {\n                            this.normalMap = matTM.normalMapParams.normalMap;\n                        }\n                        else {\n                            // If there are normal map params but the normal map is not present, use the texture as a normal map instead of a pattern map.\n                            this.normalMap = this.texture;\n                            this.texture = undefined;\n                        }\n                    }\n                    if (this.normalMapUsesConstantLod || this.textureUsesConstantLod) {\n                        this.constantLodVParams = new Float32Array(3);\n                        this.constantLodVParams[0] = matTM.params.constantLodParams.offset.x; // x offset\n                        this.constantLodVParams[1] = matTM.params.constantLodParams.offset.y; // y offset\n                        this.constantLodVParams[3] = 0.0; // placeholder for orto view distance\n                        this.constantLodFParams = new Float32Array(3);\n                        this.constantLodFParams[0] = matTM.params.constantLodParams.minDistClamp; // Minimum texture size\n                        this.constantLodFParams[1] = matTM.params.constantLodParams.maxDistClamp; // Maximum texture size\n                        this.constantLodFParams[2] = matTM.params.constantLodParams.repetitions; // # repetitions of pattern (to scale it)\n                    }\n                }\n            }\n        }\n        else {\n            this.texture = undefined;\n            this._textureAlwaysDisplayed = false;\n        }\n        this.materialInfo = createMaterialInfo(params.surface.material);\n        this.type = params.surface.type;\n        this.fillFlags = params.surface.fillFlags;\n        this.isPlanar = params.isPlanar;\n        this.hasBakedLighting = params.surface.hasBakedLighting;\n        const edges = params.edges;\n        this.edgeWidth = undefined !== edges ? edges.weight : 1;\n        this.edgeLineCode = LineCode.valueFromLinePixels(undefined !== edges ? edges.linePixels : LinePixels.Solid);\n    }\n    static create(params, viOrigin) {\n        const lut = VertexLUT.createFromVertexTable(params.vertices, params.auxChannels);\n        return undefined !== lut ? new MeshData(lut, params, viOrigin) : undefined;\n    }\n    get isDisposed() { return undefined === this.texture && this.lut.isDisposed; }\n    dispose() {\n        dispose(this.lut);\n        if (this._ownsTexture)\n            this.texture.dispose();\n    }\n    get isGlyph() { return undefined !== this.texture && this.texture.isGlyph; }\n    get isTextureAlwaysDisplayed() { return this.isGlyph || this._textureAlwaysDisplayed; }\n    // Returns true if no one else owns this texture. Implies that the texture should be disposed when this object is disposed, and the texture's memory should be tracked as belonging to this object.\n    get _ownsTexture() {\n        return undefined !== this.texture && !this.texture?.hasOwner;\n    }\n    collectStatistics(stats) {\n        stats.addVertexTable(this.lut.bytesUsed);\n        if (this._ownsTexture)\n            stats.addTexture(this.texture.bytesUsed);\n    }\n}\n//# sourceMappingURL=MeshData.js.map",
      "start": 1693508124587,
      "end": 1693508124673,
      "sourcemaps": null
    }
  ]
}
