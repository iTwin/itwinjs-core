{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/RenderSystem.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Rendering\n */\nimport { base64StringToUint8Array } from \"@itwin/core-bentley\";\nimport { ColorIndex, FeatureIndex, FeatureIndexType, FillFlags, ImageBufferFormat, ImageSource, ImageSourceFormat, isValidImageSourceFormat, QParams3d, QPoint3dList, RenderTexture, TextureTransparency, } from \"@itwin/core-common\";\nimport { Point2d, Point3d, Range3d, Transform } from \"@itwin/core-geometry\";\nimport { IModelApp } from \"../IModelApp\";\nimport { ToolAdmin } from \"../tools/ToolAdmin\";\nimport { imageElementFromImageSource } from \"../common/ImageUtil\";\nimport { GraphicBranch } from \"./GraphicBranch\";\nimport { RenderGraphicOwner } from \"./RenderGraphic\";\nimport { createMeshParams } from \"./primitives/VertexTableBuilder\";\nimport { createPointStringParams } from \"./primitives/PointStringParams\";\nimport { createPolylineParams } from \"./primitives/PolylineParams\";\n/* eslint-disable no-restricted-syntax */\n// cSpell:ignore deserializing subcat uninstanced wiremesh qorigin trimesh\n/** An opaque representation of a texture draped on geometry within a [[Viewport]].\n * @internal\n */\nexport class RenderTextureDrape {\n}\n/** @internal */\nexport var RenderDiagnostics;\n(function (RenderDiagnostics) {\n    /** No diagnostics enabled. */\n    RenderDiagnostics[RenderDiagnostics[\"None\"] = 0] = \"None\";\n    /** Debugging output to browser console enabled. */\n    RenderDiagnostics[RenderDiagnostics[\"DebugOutput\"] = 2] = \"DebugOutput\";\n    /** Potentially expensive checks of WebGL state enabled. */\n    RenderDiagnostics[RenderDiagnostics[\"WebGL\"] = 4] = \"WebGL\";\n    /** All diagnostics enabled. */\n    RenderDiagnostics[RenderDiagnostics[\"All\"] = 6] = \"All\";\n})(RenderDiagnostics || (RenderDiagnostics = {}));\n/** Default implementation of RenderGraphicOwner. */\nclass GraphicOwner extends RenderGraphicOwner {\n    constructor(_graphic) {\n        super();\n        this._graphic = _graphic;\n    }\n    get graphic() { return this._graphic; }\n}\n/** @internal */\nexport class RenderTerrainGeometry {\n}\n/** @internal */\nexport class TerrainTexture {\n    constructor(texture, featureId, scale, translate, targetRectangle, layerIndex, transparency, clipRectangle) {\n        this.texture = texture;\n        this.featureId = featureId;\n        this.scale = scale;\n        this.translate = translate;\n        this.targetRectangle = targetRectangle;\n        this.layerIndex = layerIndex;\n        this.transparency = transparency;\n        this.clipRectangle = clipRectangle;\n    }\n    cloneWithClip(clipRectangle) {\n        return new TerrainTexture(this.texture, this.featureId, this.scale, this.translate, this.targetRectangle, this.layerIndex, this.transparency, clipRectangle);\n    }\n}\n/** @internal */\nexport class DebugShaderFile {\n    constructor(filename, src, isVS, isGL, isUsed) {\n        this.filename = filename;\n        this.src = src;\n        this.isVS = isVS;\n        this.isGL = isGL;\n        this.isUsed = isUsed;\n    }\n}\n/** Transparency settings for planar grid display.\n * @alpha\n */\nexport class PlanarGridTransparency {\n    constructor() {\n        /** Transparency for the grid plane.   This should generally be fairly high to avoid obscuring other geometry */\n        this.planeTransparency = .9;\n        /** Transparency of the grid lines.  This should be higher than the plane, but less than reference line transparency */\n        this.lineTransparency = .75;\n        /** Transparency of the reference lines.   This should be less than plane or line transparency so that reference lines are more prominent */\n        this.refTransparency = .5;\n    }\n}\n/** A RenderSystem provides access to resources used by the internal WebGL-based rendering system.\n * An application rarely interacts directly with the RenderSystem; instead it interacts with types like [[Viewport]] which\n * coordinate with the RenderSystem on the application's behalf.\n * @see [Display system overview]($docs/learning/display/index.md)\n * @see [[IModelApp.renderSystem]].\n * @public\n * @extensions\n */\nexport class RenderSystem {\n    /** Initialize the RenderSystem with the specified options.\n     * @note The RenderSystem takes ownership of the supplied Options and freezes it.\n     * @internal\n     */\n    constructor(options) {\n        this.options = undefined !== options ? options : {};\n        Object.freeze(this.options);\n        if (undefined !== this.options.disabledExtensions)\n            Object.freeze(this.options.disabledExtensions);\n    }\n    /** The maximum permitted width or height of a texture supported by this render system. */\n    get maxTextureSize() { return 0; }\n    /** @internal */\n    get supportsCreateImageBitmap() { return false; }\n    /** @internal */\n    get dpiAwareLOD() { return true === this.options.dpiAwareLOD; }\n    /** @internal */\n    get isMobile() { return false; }\n    /** Find a previously-created [RenderMaterial]($common) by its ID.\n     * @param _key The unique ID of the material within the context of the IModelConnection. Typically an element ID.\n     * @param _imodel The IModelConnection with which the material is associated.\n     * @returns A previously-created material matching the specified ID, or undefined if no such material exists.\n     */\n    findMaterial(_key, _imodel) { return undefined; }\n    /** Create a [RenderMaterial]($common) from parameters\n     * If the parameters include a non-empty key, and no previously-created material already exists with that key, the newly-created material will be cached on the IModelConnection such\n     * that it can later be retrieved by the same key using [[RenderSystem.findMaterial]].\n     * @param _params A description of the material's properties.\n     * @param _imodel The IModelConnection associated with the material.\n     * @returns the newly-created material, or undefined if the material could not be created or if a material with the same key as that specified in the params already exists.\n     * @deprecated in 3.x. Use [[createRenderMaterial]].\n     */\n    // eslint-disable-next-line deprecation/deprecation\n    createMaterial(_params, _imodel) { return undefined; }\n    /** Create a [RenderMaterial]($common).\n     * @see [[CreateRenderMaterialArgs]] for a description of the material parameters.\n     */\n    createRenderMaterial(_args) {\n        return undefined;\n    }\n    /** Creates a [[GraphicBuilder]] for creating a [[RenderGraphic]].\n     * @param placement The local-to-world transform in which the builder's geometry is to be defined.\n     * @param type The type of builder to create.\n     * @param viewport The viewport in which the resultant [[RenderGraphic]] will be rendered.\n     * @param pickableId If the decoration is to be pickable, a unique identifier to associate with the resultant [[RenderGraphic]].\n     * @returns A builder for creating a [[RenderGraphic]] of the specified type appropriate for rendering within the specified viewport.\n     * @see [[IModelConnection.transientIds]] for obtaining an ID for a pickable decoration.\n     * @see [[RenderContext.createGraphicBuilder]].\n     * @see [[Decorator]]\n     */\n    createGraphicBuilder(placement, type, viewport, pickableId) {\n        const pickable = undefined !== pickableId ? { id: pickableId } : undefined;\n        return this.createGraphic({ type, viewport, placement, pickable });\n    }\n    /** Obtain an object capable of producing a custom screen-space effect to be applied to the image rendered by a [[Viewport]].\n     * @returns undefined if screen-space effects are not supported by this RenderSystem.\n     */\n    createScreenSpaceEffectBuilder(_params) {\n        return undefined;\n    }\n    /** @internal */\n    createTriMesh(args, instances) {\n        const params = createMeshParams(args, this.maxTextureSize);\n        return this.createMesh(params, instances);\n    }\n    /** @internal */\n    createIndexedPolylines(args, instances) {\n        if (args.flags.isDisjoint) {\n            const pointStringParams = createPointStringParams(args);\n            return undefined !== pointStringParams ? this.createPointString(pointStringParams, instances) : undefined;\n        }\n        else {\n            const polylineParams = createPolylineParams(args);\n            return undefined !== polylineParams ? this.createPolyline(polylineParams, instances) : undefined;\n        }\n    }\n    /** @internal */\n    createMeshGeometry(_params, _viewIndependentOrigin) { return undefined; }\n    /** @internal */\n    createPolylineGeometry(_params, _viewIndependentOrigin) { return undefined; }\n    /** @internal */\n    createPointStringGeometry(_params, _viewIndependentOrigin) { return undefined; }\n    /** @internal */\n    createAreaPattern(_params) { return undefined; }\n    createGraphicFromGeometry(createGeometry, instancesOrOrigin) {\n        let viOrigin;\n        let instances;\n        if (instancesOrOrigin instanceof Point3d)\n            viOrigin = instancesOrOrigin;\n        else\n            instances = instancesOrOrigin;\n        const geom = createGeometry(viOrigin);\n        return geom ? this.createRenderGraphic(geom, instances) : undefined;\n    }\n    /** @internal */\n    createMesh(params, instances) {\n        return this.createGraphicFromGeometry((viOrigin) => this.createMeshGeometry(params, viOrigin), instances);\n    }\n    /** @internal */\n    createPolyline(params, instances) {\n        return this.createGraphicFromGeometry((origin) => this.createPolylineGeometry(params, origin), instances);\n    }\n    /** @internal */\n    createPointString(params, instances) {\n        return this.createGraphicFromGeometry((origin) => this.createPointStringGeometry(params, origin), instances);\n    }\n    /** @internal */\n    createTerrainMesh(_params, _transform, _disableTextureDisposal = false) {\n        return undefined;\n    }\n    /** @internal */\n    createRealityMeshGraphic(_params, _disableTextureDisposal = false) { return undefined; }\n    /** @internal */\n    createRealityMesh(_realityMesh, _disableTextureDisposal = false) { return undefined; }\n    /** @internal */\n    get maxRealityImageryLayers() { return 0; }\n    /** @internal */\n    createPointCloud(_args, _imodel) { return undefined; }\n    /** Create a clip volume to clip geometry.\n     * @note The clip volume takes ownership of the ClipVector, which must not be subsequently mutated.\n     * @param _clipVector Defines how the volume clips geometry.\n     * @returns A clip volume, or undefined if, e.g., the clip vector does not clip anything.\n     */\n    createClipVolume(_clipVector) { return undefined; }\n    /** @internal */\n    createPlanarGrid(_frustum, _grid) { return undefined; }\n    /** @internal */\n    createBackgroundMapDrape(_drapedTree, _mapTree) { return undefined; }\n    /** @internal */\n    createTile(tileTexture, corners, featureIndex) {\n        // corners\n        // [0] [1]\n        // [2] [3]\n        // Quantize the points according to their range\n        const points = new QPoint3dList(QParams3d.fromRange(Range3d.create(...corners)));\n        for (let i = 0; i < 4; i++)\n            points.add(corners[i]);\n        // Now remove the translation from the quantized points and put it into a transform instead.\n        // This prevents graphical artifacts when quantization origin is large relative to quantization scale.\n        // ###TODO: Would be better not to create a branch for every tile.\n        const qorigin = points.params.origin;\n        const transform = Transform.createTranslationXYZ(qorigin.x, qorigin.y, qorigin.z);\n        qorigin.setZero();\n        const features = new FeatureIndex();\n        if (undefined !== featureIndex) {\n            features.featureID = featureIndex;\n            features.type = FeatureIndexType.Uniform;\n        }\n        const rasterTile = {\n            points,\n            vertIndices: [0, 1, 2, 2, 1, 3],\n            isPlanar: true,\n            features,\n            colors: new ColorIndex(),\n            fillFlags: FillFlags.None,\n            textureMapping: {\n                uvParams: [new Point2d(0, 0), new Point2d(1, 0), new Point2d(0, 1), new Point2d(1, 1)],\n                texture: tileTexture,\n            },\n        };\n        const trimesh = this.createTriMesh(rasterTile);\n        if (undefined === trimesh)\n            return undefined;\n        const branch = new GraphicBranch(true);\n        branch.add(trimesh);\n        return this.createBranch(branch, transform);\n    }\n    /** Create a Graphic for a [[SkyBox]] which encompasses the entire scene, rotating with the camera.\n     * @internal\n     */\n    createSkyBox(_params) { return undefined; }\n    /** Create a RenderGraphic consisting of a list of Graphics, with optional transform and symbology overrides applied to the list */\n    createBranch(branch, transform) {\n        return this.createGraphicBranch(branch, transform);\n    }\n    /** Create a node in the scene graph corresponding to a transform node in the scene's schedule script.\n     * Nodes under this branch will only be drawn if they belong to the specified transform node.\n     * This allows the graphics in a single Tile to be efficiently drawn with different transforms applied by different nodes.\n     * The node Id is either the Id of a single transform node in the script, of 0xffffffff to indicate all nodes that have no transform applied to them.\n     * @internal\n     */\n    createAnimationTransformNode(graphic, _nodeId) {\n        return graphic;\n    }\n    /** Return a Promise which when resolved indicates that all pending external textures have finished loading from the backend. */\n    async waitForAllExternalTextures() { return Promise.resolve(); }\n    /** @internal */\n    get hasExternalTextureRequests() { return false; }\n    /** Create a graphic that assumes ownership of another graphic.\n     * @param ownedGraphic The RenderGraphic to be owned.\n     * @returns The owning graphic that exposes a `disposeGraphic` method for explicitly disposing of the owned graphic.\n     * @see [[RenderGraphicOwner]] for details regarding ownership semantics.\n     * @public\n     */\n    createGraphicOwner(ownedGraphic) { return new GraphicOwner(ownedGraphic); }\n    /** Create a \"layer\" containing the graphics belonging to it. A layer has a unique identifier and all of its geometry lies in an XY plane.\n     * Different layers can be drawn coincident with one another; their draw order can be controlled by a per-layer priority value so that one layer draws\n     * on top of another. Layers cannot nest inside other layers. Multiple GraphicLayers can exist with the same ID; they are treated as belonging to the same layer.\n     * A GraphicLayer must be contained (perhaps indirectly) inside a GraphicLayerContainer.\n     * @see [[createGraphicLayerContainer]]\n     * @internal\n     */\n    createGraphicLayer(graphic, _layerId) { return graphic; }\n    /** Create a graphic that can contain [[GraphicLayer]]s.\n     * @internal\n     */\n    createGraphicLayerContainer(graphic, _drawAsOverlay, _transparency, _elevation) { return graphic; }\n    /** Find a previously-created [[RenderTexture]] by its key.\n     * @param _key The unique key of the texture within the context of the IModelConnection. Typically an element Id.\n     * @param _imodel The IModelConnection with which the texture is associated.\n     * @returns A previously-created texture matching the specified key, or undefined if no such texture exists.\n     */\n    findTexture(_key, _imodel) {\n        return undefined;\n    }\n    /** Find or create a [[RenderTexture]] from a persistent texture element.\n     * @param id The ID of the texture element.\n     * @param iModel The IModel containing the texture element.\n     * @returns A Promise resolving to the created RenderTexture or to undefined if the texture could not be created.\n     * @note If the texture is successfully created, it will be cached on the IModelConnection such that it can later be retrieved by its ID using [[RenderSystem.findTexture]].\n     * @see [[RenderSystem.loadTextureImage]].\n     */\n    async loadTexture(id, iModel) {\n        let texture = this.findTexture(id.toString(), iModel);\n        if (undefined === texture) {\n            const image = await this.loadTextureImage(id, iModel);\n            if (undefined !== image) {\n                // This will return a pre-existing RenderTexture if somebody else loaded it while we were awaiting the image.\n                texture = this.createTexture({\n                    type: RenderTexture.Type.Normal,\n                    ownership: { key: id, iModel },\n                    image: {\n                        source: image.image,\n                        transparency: ImageSourceFormat.Png === image.format ? TextureTransparency.Mixed : TextureTransparency.Opaque,\n                    },\n                });\n            }\n        }\n        return texture;\n    }\n    /**\n     * Load a texture image given the ID of a texture element.\n     * @param id The ID of the texture element.\n     * @param iModel The IModel containing the texture element.\n     * @returns A Promise resolving to a TextureImage created from the texture element's data, or to undefined if the TextureImage could not be created.\n     * @see [[RenderSystem.loadTexture]]\n     * @internal\n     */\n    async loadTextureImage(id, iModel) {\n        const elemProps = await iModel.elements.getProps(id);\n        if (1 !== elemProps.length)\n            return undefined;\n        const textureProps = elemProps[0];\n        if (undefined === textureProps.data || \"string\" !== typeof (textureProps.data) || undefined === textureProps.format || \"number\" !== typeof (textureProps.format))\n            return undefined;\n        const format = textureProps.format;\n        if (!isValidImageSourceFormat(format))\n            return undefined;\n        const imageSource = new ImageSource(base64StringToUint8Array(textureProps.data), format);\n        const image = await imageElementFromImageSource(imageSource);\n        return { image, format };\n    }\n    /** Obtain a texture created from a gradient.\n     * @param _symb The description of the gradient.\n     * @param _imodel The IModelConnection with which the texture is associated.\n     * @returns A texture created from the gradient image, or undefined if the texture could not be created.\n     * @note If a texture matching the specified gradient is already cached on the iModel, it will be returned.\n     * Otherwise, if an iModel is supplied, the newly-created texture will be cached on the iModel such that subsequent calls with an equivalent gradient and the\n     * same iModel will return the cached texture instead of creating a new one.\n     */\n    getGradientTexture(_symb, _imodel) {\n        return undefined;\n    }\n    /** Create a new texture from an [[ImageBuffer]].\n     * @deprecated in 3.x. Use [[createTexture]].\n     */\n    // eslint-disable-next-line deprecation/deprecation\n    createTextureFromImageBuffer(image, iModel, params) {\n        const ownership = params.key ? { key: params.key, iModel } : (params.isOwned ? \"external\" : undefined);\n        return this.createTexture({\n            type: params.type,\n            ownership,\n            image: {\n                source: image,\n                transparency: ImageBufferFormat.Rgba === image.format ? TextureTransparency.Mixed : TextureTransparency.Opaque,\n            },\n        });\n    }\n    /** Create a new texture from an HTML image. Typically the image was extracted from a binary representation of a jpeg or png via [[imageElementFromImageSource]].\n     * @deprecated in 3.x. Use [[createTexture]].\n     */\n    // eslint-disable-next-line deprecation/deprecation\n    createTextureFromImage(image, hasAlpha, iModel, params) {\n        const ownership = params.key && iModel ? { key: params.key, iModel } : (params.isOwned ? \"external\" : undefined);\n        return this.createTexture({\n            type: params.type,\n            ownership,\n            image: {\n                source: image,\n                transparency: hasAlpha ? TextureTransparency.Mixed : TextureTransparency.Opaque,\n            },\n        });\n    }\n    /** Create a new texture from an ImageSource.\n     * @deprecated in 3.x. Use RenderSystem.createTextureFromSource.\n     */\n    // eslint-disable-next-line deprecation/deprecation\n    async createTextureFromImageSource(source, iModel, params) {\n        const ownership = iModel && params.key ? { iModel, key: params.key } : (params.isOwned ? \"external\" : undefined);\n        return this.createTextureFromSource({\n            type: params.type,\n            source,\n            ownership,\n            transparency: source.format === ImageSourceFormat.Jpeg ? TextureTransparency.Opaque : TextureTransparency.Mixed,\n        });\n    }\n    /** Create a texture from an ImageSource. */\n    async createTextureFromSource(args) {\n        try {\n            // JPEGs don't support transparency.\n            const transparency = ImageSourceFormat.Jpeg === args.source.format ? TextureTransparency.Opaque : (args.transparency ?? TextureTransparency.Mixed);\n            const image = await imageElementFromImageSource(args.source);\n            if (!IModelApp.hasRenderSystem)\n                return undefined;\n            return this.createTexture({\n                type: args.type,\n                ownership: args.ownership,\n                image: {\n                    source: image,\n                    transparency,\n                },\n            });\n        }\n        catch {\n            return undefined;\n        }\n    }\n    /** Create a new texture by its element ID. This texture will be retrieved asynchronously from the backend. A placeholder image will be associated with the texture until the requested image data loads. */\n    // eslint-disable-next-line deprecation/deprecation\n    createTextureFromElement(_id, _imodel, _params, _format) {\n        return undefined;\n    }\n    createTexture(_args) {\n        return undefined;\n    }\n    /** Create a new texture from a cube of HTML images.\n     * @internal\n     */\n    // eslint-disable-next-line deprecation/deprecation\n    createTextureFromCubeImages(_posX, _negX, _posY, _negY, _posZ, _negZ, _imodel, _params) {\n        return undefined;\n    }\n    /** @internal */\n    onInitialized() { }\n    /** @internal */\n    enableDiagnostics(_enable) { }\n    /** @internal */\n    get supportsLogZBuffer() { return false !== this.options.logarithmicDepthBuffer; }\n    /** Obtain an object that can be used to control various debugging features. Returns `undefined` if debugging features are unavailable for this `RenderSystem`.\n     * @beta\n     */\n    get debugControl() { return undefined; }\n    /** @internal */\n    collectStatistics(_stats) { }\n    /** A function that is invoked after the WebGL context is lost. Context loss is almost always caused by excessive consumption of GPU memory.\n     * After context loss occurs, the RenderSystem will be unable to interact with WebGL by rendering viewports, creating graphics and textures, etc.\n     * By default, this function invokes [[ToolAdmin.exceptionHandler]] with a brief message describing what occurred.\n     * An application can override this behavior as follows:\n     * ```ts\n     * RenderSystem.contextLossHandler = (): Promise<any> => {\n     *  // your implementation here.\n     * }\n     * ```\n     * @note Context loss is reported by the browser some short time *after* it has occurred. It is not possible to determine the specific cause.\n     * @see [[TileAdmin.gpuMemoryLimit]] to limit the amount of GPU memory consumed thereby reducing the likelihood of context loss.\n     * @see [[TileAdmin.totalTileContentBytes]] for the amount of GPU memory allocated for tile graphics.\n     */\n    static async contextLossHandler() {\n        const msg = IModelApp.localization.getLocalizedString(\"iModelJs:Errors.WebGLContextLost\");\n        return ToolAdmin.exceptionHandler(msg);\n    }\n}\n//# sourceMappingURL=RenderSystem.js.map",
      "start": 1693508119622,
      "end": 1693508119689,
      "sourcemaps": null
    }
  ]
}
