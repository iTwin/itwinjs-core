{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/bspline/BSplineCurveOps.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Bspline\n */\nimport { Geometry } from \"../Geometry\";\nimport { GrowableXYZArray } from \"../geometry3d/GrowableXYZArray\";\nimport { IndexedXYZCollection } from \"../geometry3d/IndexedXYZCollection\";\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\nimport { Point3dArray } from \"../geometry3d/PointHelpers\";\nimport { BandedSystem } from \"../numerics/BandedSystem\";\nimport { BSplineCurve3d } from \"./BSplineCurve\";\nimport { BSplineWrapMode, KnotVector } from \"./KnotVector\";\n/**\n * A class with static methods for creating B-spline curves.\n * @public\n */\nexport class BSplineCurveOps {\n    /**\n     * Greville knot algorithm: alternative to traditional c2 cubic algorithm allowing for any order, but no end conditions or periodicity.\n     * @param points pass-through points.\n     * @param order bspline order (1 more than degree)\n     */\n    static createThroughPoints(points, order) {\n        const numPoints = points.length;\n        if (order > numPoints || order < 2)\n            return undefined;\n        const degree = order - 1;\n        const bw = 1 + 2 * degree; // probably less than that . . just zeros at fringe.\n        const matrix = new Float64Array(bw * numPoints);\n        const basisFunctions = new Float64Array(order);\n        const rhs = new GrowableXYZArray();\n        const knots = KnotVector.createUniformClamped(numPoints, order - 1, 0.0, 1.0);\n        const xyz = Point3d.create();\n        for (let basePointIndex = 0; basePointIndex < numPoints; basePointIndex++) {\n            const u = knots.grevilleKnot(basePointIndex);\n            const spanIndex = knots.knotToLeftKnotIndex(u);\n            knots.evaluateBasisFunctions(spanIndex, u, basisFunctions);\n            // puzzlement .. how do the max points shift within the order spots?\n            let maxIndex = 0;\n            for (let i = 1; i < order; i++)\n                if (basisFunctions[i] > basisFunctions[maxIndex])\n                    maxIndex = i;\n            const basisFunctionStartWithinRow = degree - maxIndex;\n            const rowStart = basePointIndex * bw;\n            for (let i = 0; i < order; i++) {\n                const realColumn = basePointIndex - degree + basisFunctionStartWithinRow + i;\n                if (rowStart + realColumn >= 0 && realColumn < numPoints)\n                    matrix[rowStart + basisFunctionStartWithinRow + i] = basisFunctions[i];\n            }\n            if (points instanceof IndexedXYZCollection) {\n                rhs.push(points.getPoint3dAtUncheckedPointIndex(basePointIndex, xyz));\n            }\n            else {\n                rhs.push(points[basePointIndex].clone());\n            }\n        }\n        const poles = BandedSystem.solveBandedSystemMultipleRHS(numPoints, bw, matrix, 3, rhs.float64Data());\n        if (poles) {\n            return BSplineCurve3d.create(poles, knots.knots, order);\n        }\n        return undefined;\n    }\n    /**\n     * Construct BSplineCurve3d that fit points using the C2 cubic algorithm.\n     * @param options curve definition, unmodified\n     */\n    static createThroughPointsC2Cubic(options) {\n        // Work on a copy rather than installing computed knots/tangents that could become stale when fit points change\n        // Knots/tangents that come in, however, are used without recomputation.\n        const validatedOptions = options.clone();\n        if (!this.C2CubicFit.validateOptions(validatedOptions))\n            return undefined;\n        const poles = this.C2CubicFit.constructPoles(validatedOptions);\n        if (undefined === poles)\n            return undefined;\n        const fullKnots = this.C2CubicFit.convertFitParamsToCubicKnotVector(validatedOptions.knots, validatedOptions.closed);\n        if (undefined === fullKnots)\n            return undefined;\n        const interpolant = BSplineCurve3d.create(poles, fullKnots, validatedOptions.order);\n        if (validatedOptions.closed)\n            interpolant?.setWrappable(BSplineWrapMode.OpenByAddingControlPoints);\n        return interpolant;\n    }\n}\n/**\n * Namespace for collecting curve fit API\n * @public\n */\n(function (BSplineCurveOps) {\n    /**\n     * A helper class for creating C2 cubic fit curves.\n     * Knots herein are understood to be *interior* knots (including the start/end knot),\n     * so that there is one knot per fit point. In other words, the knots are fit parameters.\n     * @private\n     */\n    class C2CubicFit {\n        /** Transform fit parameters to span [0,1]\n         * @param knots fit parameters, normalized in place\n         */\n        static normalizeKnots(knots) {\n            if (undefined === knots || knots.length < 2) {\n                knots = undefined;\n                return false;\n            }\n            const myKnots = KnotVector.create(knots, 1, false); // no extra knots at start/end\n            if (!myKnots.normalize()) {\n                knots = undefined;\n                return false;\n            }\n            for (let i = 0; i < knots.length; ++i)\n                knots[i] = myKnots.knots[i];\n            return true;\n        }\n        /** Compute chord-length fit parameters for C2 cubic fit algorithm */\n        static constructChordLengthParameters(fitPoints) {\n            if (fitPoints.length < 2)\n                return undefined;\n            const params = [0.0];\n            for (let i = 1; i < fitPoints.length; ++i)\n                params[i] = params[i - 1] + fitPoints[i].distance(fitPoints[i - 1]);\n            if (!this.normalizeKnots(params))\n                return undefined;\n            return params;\n        }\n        /** Compute uniform fit parameters for C2 cubic fit algorithm */\n        static constructUniformParameters(numParams) {\n            if (numParams < 2)\n                return undefined;\n            const knots = KnotVector.createUniformClamped(numParams + 2, 3, 0.0, 1.0);\n            const params = [];\n            for (let i = knots.leftKnotIndex; i <= knots.rightKnotIndex; ++i)\n                params.push(knots.knots[i]);\n            return params;\n        }\n        /** Remove duplicate fit points, and their given knots in parallel */\n        static removeDuplicateFitPoints(options) {\n            if (undefined !== options.knots && options.knots.length !== options.fitPoints.length)\n                options.knots = undefined;\n            // get indices of duplicate points to be removed\n            const newPts = GrowableXYZArray.create(options.fitPoints);\n            const indices = newPts.findOrderedDuplicates();\n            newPts.clear();\n            // remove duplicate fit points\n            for (let iRead = 0, iIndex = 0; iRead < options.fitPoints.length; ++iRead) {\n                if (iRead === indices[iIndex])\n                    ++iIndex; // skip the duplicate\n                else\n                    newPts.push(options.fitPoints[iRead].clone());\n            }\n            options.fitPoints = newPts.getPoint3dArray();\n            // remove params corresponding to removed fit points\n            if (undefined !== options.knots) {\n                const newKnots = [];\n                for (let iRead = 0, iIndex = 0; iRead < options.knots.length; ++iRead) {\n                    if (iRead === indices[iIndex])\n                        ++iIndex; // skip\n                    else\n                        newKnots.push(options.knots[iRead]);\n                }\n                options.knots = newKnots.slice();\n            }\n            return true;\n        }\n        /** Construct fit parameters for the c2 cubic fit algorithm.\n         * @param fitPoints validated fit points (should not contain duplicates)\n         * @param isChordLength whether knots are computed using distances between successive fit points\n         * @param closed whether curve is periodically defined\n         * @return fit parameters, one per fit point\n        */\n        static constructFitParametersFromPoints(fitPoints, isChordLength, closed) {\n            let params;\n            if (isChordLength || !closed)\n                params = this.constructChordLengthParameters(fitPoints);\n            if (undefined === params)\n                params = this.constructUniformParameters(fitPoints.length);\n            return params;\n        }\n        /** Construct fit parameters for the c2 cubic fit algorithm, if they are missing.\n         * @param options validated as per validateOptions, possibly modified\n         * @return whether fit parameters are valid\n         */\n        static constructFitParameters(options) {\n            if (undefined === options.knots)\n                options.knots = this.constructFitParametersFromPoints(options.fitPoints, options.isChordLenKnots, options.closed);\n            return options.knots?.length === options.fitPoints.length;\n        }\n        /** Compute a row of the tridiagonal system matrix from Farin.\n         * @param alpha sub-diagonal, length = # fit points\n         * @param beta diagonal, length = # fit points\n         * @param gamma super-diagonal, length = # fit points\n         * @param index 0-based row index to set\n         */\n        static computeAlphaBetaGamma(alpha, beta, gamma, index, deltaIPlus1, deltaI, deltaIMinus1, deltaIMinus2) {\n            let denomReciprocal = 1.0 / (deltaIMinus2 + deltaIMinus1 + deltaI);\n            alpha[index] = deltaI * deltaI * denomReciprocal;\n            beta[index] = deltaI * (deltaIMinus2 + deltaIMinus1) * denomReciprocal;\n            denomReciprocal = 1.0 / (deltaIMinus1 + deltaI + deltaIPlus1);\n            beta[index] += deltaIMinus1 * (deltaI + deltaIPlus1) * denomReciprocal;\n            gamma[index] = deltaIMinus1 * deltaIMinus1 * denomReciprocal;\n            denomReciprocal = 1.0 / (deltaIMinus1 + deltaI);\n            alpha[index] *= denomReciprocal;\n            beta[index] *= denomReciprocal;\n            gamma[index] *= denomReciprocal;\n        }\n        /** Setup tridiagonal system for 2 fit points\n         * @param alpha sub-diagonal, length = 2\n         * @param beta diagonal, length = 2\n         * @param gamma super-diagonal, length = 2\n         */\n        static setUpSystem2Points(alpha, beta, gamma) {\n            if (alpha.length !== 2 || beta.length !== 2 || gamma.length !== 2)\n                return false;\n            // identity matrix\n            alpha[0] = alpha[1] = gamma[0] = gamma[1] = 0.0;\n            beta[0] = beta[1] = 1.0;\n            return true;\n        }\n        /** Setup tridiagonal system for 3 fit points\n         * @param alpha sub-diagonal, length = 3\n         * @param beta diagonal, length = 3\n         * @param gamma super-diagonal, length = 3\n         * @param options validated as per validateOptions, unmodified\n         * @param useNaturalStartTangent whether to bake the natural end condition into the first row\n         * @param useNaturalEndTangent whether to bake the natural end condition into the last row\n         */\n        static setUpSystem3Points(alpha, beta, gamma, options, useNaturalStartTangent, useNaturalEndTangent) {\n            if (undefined === options.knots)\n                return false;\n            if (alpha.length !== 3 || beta.length !== 3 || gamma.length !== 3)\n                return false;\n            if (options.knots.length !== 3 || options.fitPoints.length !== 3)\n                return false;\n            let deltaIPlus1 = 0, deltaI = 0, deltaIMinus1 = 0, deltaIMinus2 = 0, sum = 0, sumReciprocal = 0;\n            // first row\n            if (useNaturalStartTangent) {\n                alpha[0] = 0.0;\n                deltaI = options.knots[1] - options.knots[0];\n                deltaIPlus1 = options.knots[2] - options.knots[1];\n                sum = deltaI + deltaIPlus1;\n                sumReciprocal = 1.0 / sum;\n                beta[0] = (deltaI + sum) * sumReciprocal;\n                gamma[0] = -deltaI * sumReciprocal;\n            }\n            else {\n                alpha[0] = gamma[0] = 0.0;\n                beta[0] = 1.0;\n            }\n            // middle row\n            deltaIMinus1 = options.knots[1] - options.knots[0];\n            deltaI = options.knots[2] - options.knots[1];\n            sumReciprocal = 1.0 / (deltaIMinus1 + deltaI);\n            sumReciprocal *= sumReciprocal;\n            alpha[1] = deltaI * deltaI * sumReciprocal;\n            beta[1] = 2.0 * (deltaI * deltaIMinus1) * sumReciprocal;\n            gamma[1] = deltaIMinus1 * deltaIMinus1 * sumReciprocal;\n            // last row\n            if (useNaturalEndTangent) {\n                deltaIMinus1 = options.knots[2] - options.knots[1];\n                deltaIMinus2 = options.knots[1] - options.knots[0];\n                sum = deltaIMinus2 + deltaIMinus1;\n                sumReciprocal = 1.0 / sum;\n                alpha[2] = -deltaIMinus1 * sumReciprocal;\n                beta[2] = (deltaIMinus1 + sum) * sumReciprocal;\n                gamma[2] = 0.0;\n            }\n            else {\n                alpha[2] = gamma[2] = 0.0;\n                beta[2] = 1.0;\n            }\n            return true;\n        }\n        /** Setup tridiagonal system for 4 fit points or more\n         * @param alpha sub-diagonal, length = # fit points\n         * @param beta diagonal, length = # fit points\n         * @param gamma super-diagonal, length = # fit points\n         * @param options validated as per validateOptions, unmodified\n         * @param useNaturalStartTangent whether to bake the natural end condition into the first row\n         * @param useNaturalEndTangent whether to bake the natural end condition into the last row\n         */\n        static setUpSystem4PointsOrMore(alpha, beta, gamma, options, useNaturalStartTangent, useNaturalEndTangent) {\n            if (undefined === options.knots)\n                return false;\n            if (alpha.length !== beta.length || alpha.length !== gamma.length || alpha.length !== options.knots.length)\n                return false;\n            if (options.knots.length !== options.fitPoints.length)\n                return false;\n            const numIntervals = options.fitPoints.length - 1;\n            const numIntervalsMinus1 = numIntervals - 1;\n            let deltaIPlus1 = 0, deltaI = 0, deltaIMinus1 = 0, deltaIMinus2 = 0, sum = 0, sumReciprocal = 0;\n            if (options.closed) {\n                // first row\n                deltaI = options.knots[1] - options.knots[0];\n                deltaIMinus2 = options.knots[numIntervalsMinus1] - options.knots[numIntervalsMinus1 - 1];\n                deltaIMinus1 = options.knots[numIntervalsMinus1 + 1] - options.knots[numIntervalsMinus1];\n                deltaIPlus1 = options.knots[2] - options.knots[1];\n                this.computeAlphaBetaGamma(alpha, beta, gamma, 0, deltaIPlus1, deltaI, deltaIMinus1, deltaIMinus2);\n                // second row\n                deltaIMinus2 = deltaIMinus1;\n                deltaIMinus1 = deltaI;\n                deltaI = options.knots[2] - options.knots[1];\n                deltaIPlus1 = options.knots[3] - options.knots[2];\n                this.computeAlphaBetaGamma(alpha, beta, gamma, 1, deltaIPlus1, deltaI, deltaIMinus1, deltaIMinus2);\n                // last row; there's one less equation than open case\n                deltaIPlus1 = deltaIMinus1;\n                deltaI = options.knots[numIntervalsMinus1 + 1] - options.knots[numIntervalsMinus1];\n                deltaIMinus2 = options.knots[numIntervalsMinus1 - 1] - options.knots[numIntervalsMinus1 - 2];\n                deltaIMinus1 = options.knots[numIntervalsMinus1] - options.knots[numIntervalsMinus1 - 1];\n                this.computeAlphaBetaGamma(alpha, beta, gamma, numIntervalsMinus1, deltaIPlus1, deltaI, deltaIMinus1, deltaIMinus2);\n            }\n            else { // open\n                // first row\n                if (useNaturalStartTangent) {\n                    alpha[0] = 0.0;\n                    deltaI = options.knots[1] - options.knots[0];\n                    deltaIPlus1 = options.knots[2] - options.knots[1];\n                    sum = deltaI + deltaIPlus1;\n                    sumReciprocal = 1.0 / sum;\n                    beta[0] = (deltaI + sum) * sumReciprocal;\n                    gamma[0] = -deltaI * sumReciprocal;\n                }\n                else {\n                    alpha[0] = gamma[0] = 0.0;\n                    beta[0] = 1.0;\n                }\n                // second row\n                deltaI = options.knots[2] - options.knots[1];\n                deltaIMinus1 = options.knots[1] - options.knots[0];\n                deltaIMinus2 = 0.0;\n                deltaIPlus1 = options.knots[3] - options.knots[2];\n                this.computeAlphaBetaGamma(alpha, beta, gamma, 1, deltaIPlus1, deltaI, deltaIMinus1, deltaIMinus2);\n                // penultimate row\n                deltaI = options.knots[numIntervalsMinus1 + 1] - options.knots[numIntervalsMinus1];\n                deltaIMinus1 = options.knots[numIntervalsMinus1] - options.knots[numIntervalsMinus1 - 1];\n                deltaIMinus2 = options.knots[numIntervalsMinus1 - 1] - options.knots[numIntervalsMinus1 - 2];\n                deltaIPlus1 = 0.0;\n                this.computeAlphaBetaGamma(alpha, beta, gamma, numIntervalsMinus1, deltaIPlus1, deltaI, deltaIMinus1, deltaIMinus2);\n                // last row\n                if (useNaturalEndTangent) {\n                    deltaIMinus1 = options.knots[numIntervals] - options.knots[numIntervals - 1];\n                    deltaIMinus2 = options.knots[numIntervals - 1] - options.knots[numIntervals - 2];\n                    sum = deltaIMinus2 + deltaIMinus1;\n                    sumReciprocal = 1.0 / sum;\n                    alpha[numIntervals] = -deltaIMinus1 * sumReciprocal;\n                    beta[numIntervals] = (deltaIMinus1 + sum) * sumReciprocal;\n                    gamma[numIntervals] = 0.0;\n                }\n                else {\n                    alpha[numIntervals] = gamma[numIntervals] = 0.0;\n                    beta[numIntervals] = 1.0;\n                }\n            }\n            // middle rows\n            for (let i = 2; i < numIntervalsMinus1; ++i) {\n                deltaI = options.knots[i + 1] - options.knots[i];\n                deltaIMinus2 = options.knots[i - 1] - options.knots[i - 2];\n                deltaIMinus1 = options.knots[i] - options.knots[i - 1];\n                deltaIPlus1 = options.knots[i + 2] - options.knots[i + 1];\n                this.computeAlphaBetaGamma(alpha, beta, gamma, i, deltaIPlus1, deltaI, deltaIMinus1, deltaIMinus2);\n            }\n            return true;\n        }\n        /** Setup tridiagonal system\n         * @param alpha sub-diagonal, length = # fitPoints\n         * @param beta diagonal, length = # fitPoints\n         * @param gamma super-diagonal, length = # fitPoints\n         * @param options validated as per validateOptions, unmodified\n         */\n        static setUpSystem(alpha, beta, gamma, options) {\n            let useNaturalStartTangent = false;\n            let useNaturalEndTangent = false;\n            if (options.isNaturalTangents && !options.closed) {\n                useNaturalStartTangent = (undefined === options.startTangent);\n                useNaturalEndTangent = (undefined === options.endTangent);\n            }\n            let succeeded = false;\n            if (2 === options.fitPoints.length)\n                succeeded = this.setUpSystem2Points(alpha, beta, gamma);\n            else if (3 === options.fitPoints.length)\n                succeeded = this.setUpSystem3Points(alpha, beta, gamma, options, useNaturalStartTangent, useNaturalEndTangent);\n            else if (4 <= options.fitPoints.length)\n                succeeded = this.setUpSystem4PointsOrMore(alpha, beta, gamma, options, useNaturalStartTangent, useNaturalEndTangent);\n            return succeeded;\n        }\n        /** Set the Bessel end condition for the linear system.\n         * @param dataPts array whose middle is the system rhs (augmented with first/last fitPoint at beginning/end);\n         *                2nd or penultimate point is set by this function.\n         * @param options validated as per validateOptions, unmodified\n         * @param atStart whether end condition is for start of curve (false: end of curve)\n         */\n        static setBesselEndCondition(dataPts, options, atStart) {\n            if (dataPts.length !== options.fitPoints.length + 2)\n                return false;\n            if (undefined === options.knots)\n                return false;\n            const scale = 1.0 / 3.0;\n            const numIntervals = options.fitPoints.length - 1;\n            if (1 === numIntervals) { // linear Bezier\n                if (atStart)\n                    dataPts[0].interpolate(scale, dataPts[3], dataPts[1]);\n                else\n                    dataPts[3].interpolate(scale, dataPts[0], dataPts[2]);\n                return true;\n            }\n            if (2 === numIntervals) {\n                const alpha = (options.knots[2] - options.knots[1]) / (options.knots[2] - options.knots[0]);\n                const beta = 1.0 - alpha;\n                const temp = dataPts[2].plus2Scaled(dataPts[0], -alpha * alpha, dataPts[4], -beta * beta);\n                if (atStart)\n                    Point3d.createAdd2Scaled(temp, 1.0 / (2.0 * alpha), dataPts[0], alpha).interpolate(scale, dataPts[0], dataPts[1]);\n                else\n                    Point3d.createAdd2Scaled(temp, 1.0 / (2.0 * beta), dataPts[4], beta).interpolate(scale, dataPts[4], dataPts[3]);\n                return true;\n            }\n            // numIntervals > 2\n            if (atStart) {\n                const alpha = (options.knots[2] - options.knots[1]) / (options.knots[2] - options.knots[0]);\n                const beta = 1.0 - alpha;\n                const temp = dataPts[2].plus2Scaled(dataPts[0], -alpha * alpha, dataPts[3], -beta * beta);\n                Point3d.createAdd2Scaled(temp, 1.0 / (2.0 * alpha), dataPts[0], alpha).interpolate(scale, dataPts[0], dataPts[1]);\n            }\n            else {\n                const alpha = (options.knots[numIntervals] - options.knots[numIntervals - 1]) / (options.knots[numIntervals] - options.knots[numIntervals - 2]);\n                const beta = 1.0 - alpha;\n                const temp = dataPts[numIntervals].plus2Scaled(dataPts[numIntervals - 1], -alpha * alpha, dataPts[numIntervals + 2], -beta * beta);\n                Point3d.createAdd2Scaled(temp, 1.0 / (2.0 * beta), dataPts[numIntervals + 2], beta).interpolate(scale, dataPts[numIntervals + 2], dataPts[numIntervals + 1]);\n            }\n            return true;\n        }\n        /** Set the natural end condition for the linear system.\n         *  This is the end condition used by ADSK for fit-splines with a given zero tangent.\n         * @param dataPts array whose middle is the system rhs (augmented with first/last fitPoint at beginning/end);\n         *                2nd or penultimate point is set by this function.\n         * @param options validated as per validateOptions, unmodified\n         * @param atStart whether end condition is for start of curve (false: end of curve)\n         */\n        static setNaturalEndCondition(dataPts, options, atStart) {\n            if (dataPts.length !== options.fitPoints.length + 2)\n                return false;\n            const numIntervals = options.fitPoints.length - 1;\n            if (1 === numIntervals)\n                return this.setBesselEndCondition(dataPts, options, atStart);\n            if (atStart)\n                dataPts[1] = dataPts[0];\n            else\n                dataPts[dataPts.length - 2] = dataPts[dataPts.length - 1];\n            return true;\n        }\n        /** Set the end condition for the linear system to the given tangent, scaled by chord length.\n         *  This is the end condition used by ADSK for fit-splines with a given nonzero tangent.\n         * @param dataPts array whose middle is the system rhs (augmented with first/last fitPoint at beginning/end);\n         *                2nd or penultimate point is set by this function.\n         * @param options validated as per validateOptions, unmodified\n         * @param atStart whether end condition is for start of curve (false: end of curve)\n         */\n        static setChordLengthScaledEndCondition(dataPts, options, atStart) {\n            if (dataPts.length !== options.fitPoints.length + 2)\n                return false;\n            const tangent = atStart ? options.startTangent : options.endTangent;\n            if (undefined === tangent)\n                return false;\n            let iExt = 0; // index of first/last fitPoint\n            let iSet = 0; // index of 2nd/penultimate Bezier point to set (determines start/end tangent of the curve)\n            let iInt = 0; // index of 2nd/penultimate fitPoint\n            const numIntervals = options.fitPoints.length - 1;\n            if (1 === numIntervals) { // no interior fit points\n                if (atStart) {\n                    iExt = 0;\n                    iSet = 1;\n                    iInt = 3;\n                }\n                else {\n                    iExt = 3;\n                    iSet = 2;\n                    iInt = 0;\n                }\n            }\n            else {\n                if (atStart) {\n                    iExt = 0;\n                    iSet = 1;\n                    iInt = 2;\n                }\n                else {\n                    iExt = numIntervals + 2;\n                    iSet = numIntervals + 1;\n                    iInt = numIntervals;\n                }\n            }\n            // NOTE: tangent points INTO curve\n            const chordLength = dataPts[iInt].distance(dataPts[iExt]);\n            dataPts[iExt].plusScaled(tangent, chordLength / 3.0, dataPts[iSet]);\n            return true;\n        }\n        /** Set the end condition for the linear system to the given tangent, scaled by bessel length.\n         * @param dataPts array whose middle is the system rhs (augmented with first/last fitPoint at beginning/end);\n         *                2nd or penultimate point is set by this function.\n         * @param options validated as per validateOptions, unmodified\n         * @param atStart whether end condition is for start of curve (false: end of curve)\n         */\n        static setBesselLengthScaledEndCondition(dataPts, options, atStart) {\n            if (dataPts.length !== options.fitPoints.length + 2)\n                return false;\n            const tangent = atStart ? options.startTangent : options.endTangent;\n            if (undefined === tangent)\n                return false;\n            // temporarily set bessel end condition\n            if (!this.setBesselEndCondition(dataPts, options, atStart))\n                return false;\n            const numIntervals = options.fitPoints.length - 1;\n            const iExt = atStart ? 0 : numIntervals + 2; // index of first/last fitPoint\n            const iSet = atStart ? 1 : numIntervals + 1; // index of 2nd/penultimate Bezier point to set (determines start/end tangent of the curve)\n            // reset end condition with our tangent, but scaled to the bessel tangent's length\n            dataPts[iExt].plusScaled(tangent, dataPts[iExt].distance(dataPts[iSet]), dataPts[iSet]);\n            return true;\n        }\n        /** Set the end condition for a physically closed (non-periodic) interpolant.\n         * @param dataPts array whose middle is the system rhs (augmented with first/last fitPoint at beginning/end);\n         *                2nd or penultimate point is set by this function.\n         * @param options validated as per validateOptions, unmodified\n         */\n        static setPhysicallyClosedEndCondition(dataPts, options) {\n            const numIntervals = options.fitPoints.length - 1;\n            if (!options.isColinearTangents\n                || numIntervals <= 2\n                || (undefined !== options.startTangent && undefined !== options.endTangent)\n                || options.isNaturalTangents\n                || !dataPts[0].isAlmostEqual(dataPts[numIntervals + 2])) {\n                return true;\n            }\n            // force parallel start/end tangents, using chord length scale for undefined tangents\n            if (undefined !== options.startTangent) { // start tangent is supplied; compute a parallel end tangent\n                const outwardStartTangent = Vector3d.createStartEnd(dataPts[1], dataPts[0]).normalize();\n                if (undefined !== outwardStartTangent) {\n                    const endTangentMag = dataPts[numIntervals + 2].distance(dataPts[numIntervals + 1]);\n                    dataPts[numIntervals + 2].plusScaled(outwardStartTangent, endTangentMag, dataPts[numIntervals + 1]);\n                }\n            }\n            else if (undefined !== options.endTangent) { // end tangent is supplied; compute a parallel start tangent\n                const outwardEndTangent = Vector3d.createStartEnd(dataPts[numIntervals + 1], dataPts[numIntervals + 2]).normalize();\n                if (undefined !== outwardEndTangent) {\n                    const startTangentMag = dataPts[0].distance(dataPts[1]);\n                    dataPts[0].plusScaled(outwardEndTangent, startTangentMag, dataPts[1]);\n                }\n            }\n            else { // neither tangent is supplied, compute both along same vector\n                const commonTangent = Vector3d.createStartEnd(dataPts[numIntervals + 1], dataPts[1]).normalize();\n                if (undefined !== commonTangent) {\n                    const startTangentMag = dataPts[0].distance(dataPts[1]);\n                    dataPts[0].plusScaled(commonTangent, startTangentMag, dataPts[1]);\n                    const endTangentMag = dataPts[numIntervals + 2].distance(dataPts[numIntervals + 1]);\n                    dataPts[numIntervals + 2].plusScaled(commonTangent, -endTangentMag, dataPts[numIntervals + 1]);\n                }\n            }\n            return true;\n        }\n        /** Set end conditions for the linear system to solve for the poles of the open interpolant, as per Farin 3e/4e.\n         * @param dataPts array whose interior is the system rhs and whose first/last entries are the first/last fitPoints;\n         *                points are inserted to become the 2nd and penultimate dataPts, the first/last rows of the system rhs.\n         * @param options validated as per validateOptions, unmodified\n         */\n        static setEndConditions(dataPts, options) {\n            if (dataPts.length !== options.fitPoints.length)\n                return false;\n            // insert dummy points to be computed below\n            const dummy0 = Point3d.createZero();\n            const dummy1 = Point3d.createZero();\n            dataPts.splice(1, 0, dummy0);\n            dataPts.splice(dataPts.length - 1, 0, dummy1);\n            let succeeded = false;\n            if (undefined === options.startTangent) {\n                if (options.isNaturalTangents)\n                    succeeded = this.setNaturalEndCondition(dataPts, options, true);\n                else\n                    succeeded = this.setBesselEndCondition(dataPts, options, true);\n            }\n            else { // scale startTangent\n                if (options.isChordLenTangents)\n                    succeeded = this.setChordLengthScaledEndCondition(dataPts, options, true);\n                else\n                    succeeded = this.setBesselLengthScaledEndCondition(dataPts, options, true);\n            }\n            if (undefined === options.endTangent) {\n                if (options.isNaturalTangents)\n                    succeeded = this.setNaturalEndCondition(dataPts, options, false);\n                else\n                    succeeded = this.setBesselEndCondition(dataPts, options, false);\n            }\n            else { // scale endTangent\n                if (options.isChordLenTangents)\n                    succeeded = this.setChordLengthScaledEndCondition(dataPts, options, false);\n                else\n                    succeeded = this.setBesselLengthScaledEndCondition(dataPts, options, false);\n            }\n            if (succeeded)\n                succeeded = this.setPhysicallyClosedEndCondition(dataPts, options);\n            return succeeded;\n        }\n        /** Solve the near tridiagonal system for a periodic C2 cubic interpolant.\n         * Alpha, beta, gamma are computed by setUpSystem, have same length as fitPts, and are overwritten.\n         */\n        static solveNearTridiagonal(fitPts, alpha, beta, gamma) {\n            if (alpha.length !== beta.length || alpha.length !== gamma.length || alpha.length !== fitPts.length)\n                return undefined;\n            const poles = [];\n            const numIntervals = fitPts.length - 1;\n            const leftPts = fitPts.slice(0, -1); // last fitPt is ignored\n            let tmp = 0.0;\n            // first forward substitution\n            for (let i = 1; i < numIntervals; ++i) {\n                if (undefined === (tmp = Geometry.conditionalDivideFraction(-alpha[i], beta[i - 1])))\n                    return undefined;\n                beta[i] += tmp * gamma[i - 1];\n                alpha[i] = tmp * alpha[i - 1];\n                leftPts[i].addScaledInPlace(leftPts[i - 1], tmp);\n            }\n            // first backward substitution\n            if (undefined === (tmp = Geometry.conditionalDivideFraction(1.0, beta[numIntervals - 1] + alpha[numIntervals - 1])))\n                return undefined;\n            gamma[numIntervals - 1] *= tmp;\n            leftPts[numIntervals - 1].scaleInPlace(tmp);\n            for (let i = numIntervals - 2; i >= 0; --i) {\n                if (undefined === (tmp = Geometry.conditionalDivideFraction(1.0, beta[i])))\n                    return undefined;\n                Point3d.createScale(leftPts[i].plus2Scaled(leftPts[i + 1], -gamma[i], leftPts[numIntervals - 1], -alpha[i]), tmp, leftPts[i]);\n                gamma[i] = -(gamma[i] * gamma[i + 1] + alpha[i] * gamma[numIntervals - 1]) * tmp;\n            }\n            // second forward substitution\n            if (undefined === (tmp = Geometry.conditionalDivideFraction(1.0, 1.0 + gamma[0])))\n                return undefined;\n            poles.push(Point3d.createScale(leftPts[0], tmp));\n            for (let i = 1; i < numIntervals; ++i) {\n                poles.push(leftPts[i].plusScaled(poles[0], -gamma[i]));\n            }\n            return poles;\n        }\n        /** Adjust options by correcting invalid combinations\n         * @param options curve definition, possibly modified\n         */\n        static validateOptions(options) {\n            options.order = 4;\n            // remove relevant exterior knots so knots and fit points align *before* we start compressing fit points.\n            options.knots = this.convertCubicKnotVectorToFitParams(options.knots, options.fitPoints.length, true);\n            // compress out duplicate fit points (and their corresponding knots)\n            if (!this.removeDuplicateFitPoints(options))\n                return false;\n            // if only 2 unique points, then must create open curve\n            let hasClosurePoint = options.fitPoints[0].isAlmostEqual(options.fitPoints[options.fitPoints.length - 1]);\n            if (3 === options.fitPoints.length && hasClosurePoint) {\n                options.fitPoints.pop();\n                if (undefined !== options.knots)\n                    options.knots.pop();\n                hasClosurePoint = options.fitPoints[0].isAlmostEqual(options.fitPoints[options.fitPoints.length - 1]);\n            }\n            if (options.fitPoints.length <= 2) {\n                if (hasClosurePoint)\n                    return false;\n                options.closed = false;\n            }\n            // append closure point if missing\n            if (options.closed) {\n                if (!hasClosurePoint) {\n                    options.fitPoints.push(options.fitPoints[0].clone());\n                    if (undefined !== options.knots) { // best guess: uniform knots\n                        options.knots.push(options.knots[options.knots.length - 1] + (options.knots[options.knots.length - 1] - options.knots[0]) / (options.knots.length - 1));\n                    }\n                }\n                if (options.fitPoints.length <= 4)\n                    options.closed = false; // can't fit cubic closed curve to 3 unique points\n            }\n            if (options.fitPoints.length < 2)\n                return false;\n            // ASSUME: tangents point INTO curve\n            if (undefined !== options.startTangent) {\n                if (options.startTangent.isAlmostZero)\n                    options.startTangent = undefined;\n                else\n                    options.startTangent.normalizeInPlace();\n            }\n            if (undefined !== options.endTangent) {\n                if (options.endTangent.isAlmostZero)\n                    options.endTangent = undefined;\n                else\n                    options.endTangent.normalizeInPlace();\n            }\n            return true;\n        }\n        /** Converts a full cubic knot vector of expected length into fit parameters, by removing extraneous exterior knots.\n         * @param knots cubic knot vector, unmodified\n         * @param numFitPoints number of fit points\n         * @return fit parameters, or undefined if unexpected input\n         **/\n        static convertCubicKnotVectorToFitParams(knots, numFitPoints, normalize) {\n            let params = knots?.slice();\n            if (undefined !== params) {\n                const numExtraKnots = params.length - numFitPoints;\n                switch (numExtraKnots) {\n                    case 0: { // ASSUME caller passed in interior knots\n                        break;\n                    }\n                    case 4: // modern full cubic knots\n                    case 6: { // legacy full cubic knots\n                        for (let i = 0; i < numExtraKnots / 2; ++i) {\n                            params.pop();\n                            params.shift();\n                        }\n                        break;\n                    }\n                    default: { // other knot configurations are unusable\n                        params = undefined;\n                        break;\n                    }\n                }\n                if (normalize && !this.normalizeKnots(params))\n                    params = undefined;\n            }\n            return params;\n        }\n        /** Return fit parameters augmented to a full cubic knot vector.\n         * @param params fit parameters, unmodified\n         * @param legacy whether to create a legacy (DGN) full knot vector, or modern vector with two less knots\n         **/\n        static convertFitParamsToCubicKnotVector(params, closed, legacy) {\n            const knots = params?.slice();\n            if (undefined !== knots) {\n                const numExtraKnots = legacy ? 6 : 4;\n                if (closed) {\n                    const iTail = knots.length - 2;\n                    for (let iHead = 2; iHead <= numExtraKnots; iHead += 2) {\n                        knots.unshift(knots[iTail] - 1.0); // index is constant\n                        knots.push(1.0 + knots[iHead]); // index increments by two\n                    }\n                }\n                else {\n                    for (let i = 0; i < numExtraKnots / 2; ++i) {\n                        knots.unshift(0.0);\n                        knots.push(1.0);\n                    }\n                }\n            }\n            return knots;\n        }\n        /** Ensure full legacy knot vector for JSON export **/\n        static convertToJsonKnots(props) {\n            if (undefined !== props.knots) {\n                props.knots = this.convertCubicKnotVectorToFitParams(props.knots, props.fitPoints.length, false);\n                props.knots = this.convertFitParamsToCubicKnotVector(props.knots, props.closed, true);\n            }\n            else {\n                props.knots = this.constructFitParametersFromPoints(Point3dArray.clonePoint3dArray(props.fitPoints), props.isChordLenKnots, props.closed);\n                props.knots = this.convertFitParamsToCubicKnotVector(props.knots, props.closed, true);\n            }\n        }\n        /** Construct the control points for the c2 cubic fit algorithm\n         * @param options validated as per validateOptions, possibly modified\n         */\n        static constructPoles(options) {\n            if (!this.constructFitParameters(options) || (undefined === options.knots))\n                return undefined;\n            const numRow = options.fitPoints.length;\n            const alpha = Array(numRow);\n            const beta = Array(numRow);\n            const gamma = Array(numRow);\n            if (!this.setUpSystem(alpha, beta, gamma, options))\n                return undefined;\n            let poles = [];\n            if (!options.closed) {\n                const dataPts = options.fitPoints.slice();\n                if (!this.setEndConditions(dataPts, options))\n                    return undefined;\n                if (dataPts.length !== numRow + 2)\n                    return undefined; // sanity check: we added 2nd/penultimate points, rhs is middle numRow entries.\n                // construct tridiagonal banded system components\n                const matrix = new Float64Array(numRow * 3);\n                const rhs = new Float64Array(numRow * 3);\n                for (let iRow = 0, iMatrixRead = 0, iRhsRead = 0; iRow < numRow; ++iRow) {\n                    matrix[iMatrixRead++] = alpha[iRow];\n                    matrix[iMatrixRead++] = beta[iRow];\n                    matrix[iMatrixRead++] = gamma[iRow];\n                    rhs[iRhsRead++] = dataPts[iRow + 1].x;\n                    rhs[iRhsRead++] = dataPts[iRow + 1].y;\n                    rhs[iRhsRead++] = dataPts[iRow + 1].z;\n                }\n                const solution = BandedSystem.solveBandedSystemMultipleRHS(numRow, 3, matrix, 3, rhs);\n                if (undefined === solution)\n                    return undefined;\n                // pre/append first/last poles/fitPoints\n                poles = new Float64Array(3 + solution.length + 3);\n                let iWrite = 0;\n                poles[iWrite++] = options.fitPoints[0].x;\n                poles[iWrite++] = options.fitPoints[0].y;\n                poles[iWrite++] = options.fitPoints[0].z;\n                for (let iRead = 0; iRead < solution.length;) {\n                    poles[iWrite++] = solution[iRead++];\n                }\n                poles[iWrite++] = options.fitPoints[options.fitPoints.length - 1].x;\n                poles[iWrite++] = options.fitPoints[options.fitPoints.length - 1].y;\n                poles[iWrite++] = options.fitPoints[options.fitPoints.length - 1].z;\n            }\n            else { // closed\n                if (undefined !== (poles = this.solveNearTridiagonal(options.fitPoints, alpha, beta, gamma))) {\n                    if (poles.length > 2) {\n                        poles.unshift(poles.pop()); // shift poles right to line up with the knots\n                        for (let i = 0; i < options.order - 1; ++i)\n                            poles.push(poles[i].clone()); // periodically extend (the modern way)\n                    }\n                }\n            }\n            return poles;\n        }\n    }\n    BSplineCurveOps.C2CubicFit = C2CubicFit;\n})(BSplineCurveOps || (BSplineCurveOps = {}));\n//# sourceMappingURL=BSplineCurveOps.js.map",
      "start": 1693508122994,
      "end": 1693508123148,
      "sourcemaps": null
    }
  ]
}
