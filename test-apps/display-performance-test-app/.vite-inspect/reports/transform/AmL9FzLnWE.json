{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/clipping/BooleanClipFactory.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module CartesianGeometry\n */\nimport { BooleanClipNodeIntersection, BooleanClipNodeParity, BooleanClipNodeUnion } from \"./BooleanClipNode\";\nimport { ClipPlane } from \"./ClipPlane\";\nimport { ClipUtilities } from \"./ClipUtils\";\nimport { ConvexClipPlaneSet } from \"./ConvexClipPlaneSet\";\nimport { UnionOfConvexClipPlaneSets } from \"./UnionOfConvexClipPlaneSets\";\n/**\n * A BooleanClipFactory is a factory to create objects that implement interior nodes of a tree of boolean clip operations.\n * * These methods create specific clip tree types:\n *   * Union\n *   * Intersection\n *   * Parity\n *   * Difference\n * * Each construction has a `keepInside` flag that optionally negates the initial result of the parity, intersection,\n * parity, or difference:\n *   * if `keepInside === true`, accept the \"inside\" of the initial result.\n *   * if `keepInside === false`, accept the \"outside\"  of the initial result.\n * * These methods create various other specialized clippers.\n * @public\n */\nexport class BooleanClipFactory {\n    /**\n     * Create a boolean clipper which performs a union over its children.\n     * * if `keepInside === true`, accept the \"inside\" of the union result.\n     * * if `keepInside === false`, accept the \"outside\" of the union result.\n     * @param clippers clip objects to capture.\n     * @param keepInside flag to select results inside or outside the clippers.\n     */\n    static createCaptureUnion(clippers, keepInside) {\n        const result = new BooleanClipNodeUnion(keepInside);\n        result.captureChild(clippers);\n        return result;\n    }\n    /**\n     * Create a boolean clipper which performs an intersection over its children.\n     * * if `keepInside === true`, accept the \"inside\" of the intersection result.\n     * * if `keepInside === false`, accept the \"outside\" of the intersection result.\n     * @param clippers clip objects to capture.\n     * @param keepInside flag to select results inside or outside the clippers.\n     */\n    static createCaptureIntersection(clippers, keepInside) {\n        const result = new BooleanClipNodeIntersection(keepInside);\n        result.captureChild(clippers);\n        return result;\n    }\n    /**\n     * Create a boolean clipper which performs a parity over its children.\n     * * if `keepInside === true`, accept the \"inside\" of the parity result.\n     * * if `keepInside === false`, accept the \"outside\" of the parity result.\n     * @param clippers clip objects to capture.\n     * @param keepInside flag to select results inside or outside the clippers.\n     */\n    static createCaptureParity(clippers, keepInside) {\n        const result = new BooleanClipNodeParity(keepInside);\n        result.captureChild(clippers);\n        return result;\n    }\n    /**\n     * Create a boolean clipper which performs a difference operation for points \"inside `primaryClipper`\" and\n     * \"outside `excludedClipper`\".\n     * * if `keepInside === true`, accept the \"inside\" of the difference.\n     * * if `keepInside === false`, accept the \"outside\" of the difference.\n     * @param primaryClipper any clip object whose output is treated as positive.\n     * @param excludeClip any clipper whose output is treated as negative.\n     * @param keepInside flag to select results inside or outside the initial `primary minus excludeClipper` clippers.\n     */\n    static createCaptureDifference(primaryClipper, excludedClipper, keepInside) {\n        const mask = this.createCaptureUnion(excludedClipper, false);\n        return this.createCaptureIntersection([primaryClipper, mask], keepInside);\n    }\n    /**\n     * Create a boolean clipper which performs the reverse of that of `primaryClipper`.\n     * @param primaryClipper clip objects to capture.\n     * @param keepInside flag to select results inside or outside the clippers.\n     */\n    static createCaptureClipOutside(primaryClipper) {\n        return this.createCaptureUnion([primaryClipper], false);\n    }\n    /**\n     * Convert `source` to an array of clipper objects.\n     * * ANY TYPE OF Clipper is accepted.\n     * * REMARK: This is normally called only from the primary public method `parseToClipper`.\n     */\n    static parseToClipperArray(source) {\n        if (Array.isArray(source)) {\n            const clippers = [];\n            for (const c of source) {\n                const c1 = this.parseToClipper(c);\n                if (!c1)\n                    return undefined;\n                clippers.push(c1);\n            }\n            if (clippers.length === 0)\n                return undefined;\n            return clippers;\n        }\n        else {\n            // accept singleton to singleton array\n            const c = this.parseToClipper(source);\n            if (c)\n                return [c];\n        }\n        return undefined;\n    }\n    /**\n     * Look for content that represents a clipper.\n     * * Possible outputs are\n     *   * `ClipPlane`\n     *   * `ConvexClipPlaneSet`\n     *   * `UnionOfConvexClipPlaneSets`\n     *   * One of the `ClipBoolean` derived classes\n     *     * `ClipBooleanXOR`\n     *     * `ClipBooleanOR`\n     *     * `ClipBooleanAND`\n     * @param source json object\n     * @public\n     */\n    static parseToClipper(source) {\n        if (!source)\n            return undefined;\n        if (source.hasOwnProperty(\"normal\") && source.hasOwnProperty(\"dist\")) {\n            return ClipPlane.fromJSON(source);\n        }\n        else if (Array.isArray(source)) {\n            const clippers = [];\n            let numPlanes = 0;\n            let numConvexSets = 0;\n            for (const c of source) {\n                const c1 = this.parseToClipper(c);\n                if (!c1)\n                    return undefined;\n                clippers.push(c1);\n                if (c1 instanceof ClipPlane)\n                    numPlanes++;\n                else if (c1 instanceof ConvexClipPlaneSet)\n                    numConvexSets++;\n                else\n                    return undefined;\n            }\n            if (clippers.length === 0)\n                return undefined;\n            if (numPlanes === source.length) {\n                // array of planes is a convex clip plane set.\n                return ConvexClipPlaneSet.createPlanes(clippers);\n            }\n            else if (numConvexSets === source.length) {\n                return UnionOfConvexClipPlaneSets.createConvexSets(clippers);\n            }\n            // array of mixed types should not occur.  fall out to undefined.\n        }\n        else if (source.hasOwnProperty(\"OR\")) {\n            const clippers = this.parseToClipperArray(source.OR);\n            if (clippers)\n                return this.createCaptureUnion(clippers, true);\n        }\n        else if (source.hasOwnProperty(\"NOR\")) {\n            const clippers = this.parseToClipperArray(source.NOR);\n            if (clippers)\n                return this.createCaptureUnion(clippers, false);\n        }\n        else if (source.hasOwnProperty(\"AND\")) {\n            const clippers = this.parseToClipperArray(source.AND);\n            if (clippers)\n                return this.createCaptureIntersection(clippers, true);\n        }\n        else if (source.hasOwnProperty(\"NAND\")) {\n            const clippers = this.parseToClipperArray(source.NAND);\n            if (clippers)\n                return this.createCaptureIntersection(clippers, true);\n        }\n        else if (source.hasOwnProperty(\"XOR\")) {\n            const clippers = this.parseToClipperArray(source.XOR);\n            if (clippers)\n                return this.createCaptureParity(clippers, true);\n        }\n        else if (source.hasOwnProperty(\"NXOR\")) {\n            const clippers = this.parseToClipperArray(source.NXOR);\n            if (clippers)\n                return this.createCaptureParity(clippers, true);\n        }\n        return undefined;\n    }\n    /** Choose a `toJSON` method appropriate to the clipper */\n    static anyClipperToJSON(clipper) {\n        if (ClipUtilities.isClipper(clipper)) {\n            if (clipper.toJSON)\n                return clipper.toJSON();\n        }\n        return undefined;\n    }\n}\n//# sourceMappingURL=BooleanClipFactory.js.map",
      "start": 1693508122477,
      "end": 1693508122624,
      "sourcemaps": null
    }
  ]
}
