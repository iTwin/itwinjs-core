{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/orbitgt/lib/esm/pointcloud/format/opc/DirectoryReader.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module OrbitGT\n */\nimport { AList } from \"../../../system/collection/AList\";\nimport { ABufferInStream } from \"../../../system/io/ABufferInStream\";\nimport { ALong } from \"../../../system/runtime/ALong\";\nimport { ASystem } from \"../../../system/runtime/ASystem\";\nimport { GridIndex } from \"../../model/GridIndex\";\nimport { TileIndex } from \"../../model/TileIndex\";\nimport { BlockRecord } from \"./BlockRecord\";\nimport { DirectoryRecord } from \"./DirectoryRecord\";\nimport { TileRecord } from \"./TileRecord\";\n/**\n * Class DirectoryReader reads the tile and block directory.\n *\n * @version 1.0 January 2014\n */\n/** @internal */\nexport class DirectoryReader {\n    /**\n     * Create a new reader.\n     * @param fileReader the file reader.\n     * @param level the level.\n     */\n    constructor(fileReader, level) {\n        /* Store the parameters */\n        this._fileReader = fileReader;\n        this._level = level;\n        /* Get the tile directory */\n        this._tileDirPart = fileReader.getContainer().getPart(\"\" + level + \".tile.directory\");\n        /* Get the block directory */\n        this._blockDirPart = fileReader.getContainer().getPart(\"\" + level + \".block.directory\");\n        /* Clear */\n        this._directoryRecord = null;\n        this._blocks = new Array(0);\n    }\n    /**\n     * Get the directory record.\n     * @return the directory record.\n     */\n    getDirectoryRecord() {\n        return this._directoryRecord;\n    }\n    /**\n     * Get the blocks.\n     * @return the blocks.\n     */\n    getBlocks() {\n        return this._blocks;\n    }\n    /**\n     * Load the data.\n     * @param readBlockList should the list of blocks be read?\n     * @param fileContents the file content read helper.\n     * @return the reader.\n     */\n    loadData(readBlockList, fileContents) {\n        /* Read the record */\n        let directoryPart = this._fileReader.getContainer().getPart(\"\" + this._level + \".directory\");\n        this._directoryRecord = DirectoryRecord.readNew(directoryPart.getOffset(), directoryPart.getSize(), fileContents);\n        /* Read the blocks? */\n        if (readBlockList)\n            this.readBlocks(this._fileReader.getFileRecord(), fileContents);\n        /* Return the reader */\n        return this;\n    }\n    /**\n     * Read the blocks.\n     * @param fileRecord the file record.\n     * @param fileContents the file content read helper.\n     * @return the blocks.\n     */\n    readBlocks(fileRecord, fileContents) {\n        /* Request the data? */\n        let fileAccess = this._blockDirPart.getFileAccess();\n        if (fileContents.isAvailable() == false) {\n            /* Add the range */\n            fileContents.requestFilePart(this._blockDirPart.getOffset(), this._blockDirPart.getSize().toInt());\n            return null;\n        }\n        /* Get the data */\n        let data = fileContents.getFilePart(this._blockDirPart.getOffset(), this._blockDirPart.getSize().toInt());\n        /* Allocate the blocks */\n        this._blocks = new Array(this._directoryRecord.getBlockCount());\n        /* Read all blocks */\n        let input = new ABufferInStream(data, 0, data.size());\n        let pointIndex = ALong.ZERO;\n        let tileIndex = 0;\n        for (let i = 0; i < this._blocks.length; i++) {\n            /* Read the next block */\n            let blockIndex = BlockRecord.readNew(this._level, input, i, tileIndex, pointIndex);\n            this._blocks[i] = blockIndex;\n            /* Advance */\n            tileIndex += blockIndex.tileCount;\n            pointIndex = pointIndex.add(blockIndex.pointCount);\n        }\n        input.close();\n        /* We have to match the counts */\n        ASystem.assert0(this._directoryRecord.getTileCount() == tileIndex, \"Expected \" + this._directoryRecord.getTileCount() + \" tiles, not \" + tileIndex);\n        ASystem.assert0(pointIndex.same(this._directoryRecord.getPointCount()), \"Expected \" + this._directoryRecord.getPointCount().toDouble() + \" points, not \" + pointIndex.toDouble());\n        /* Return the blocks */\n        return this._blocks;\n    }\n    /**\n     * Read the tiles of a block.\n     * @param block the block record.\n     * @return the tile records.\n     */\n    readTiles2(block, fileContents) {\n        /* Get the tile range */\n        let tileIndex = block.tileIndex;\n        let tileCount = block.tileCount;\n        /* Get the file extent */\n        let fileName = this._tileDirPart.getFileAccess().getFileName();\n        let fileSize = this._fileReader.getContainer().getFileLength();\n        let dataOffset = ALong.fromInt(TileRecord.RECORD_SIZE).mulInt(tileIndex).add(this._tileDirPart.getOffset());\n        let dataSize = tileCount * TileRecord.RECORD_SIZE;\n        /* Request the data? */\n        if (fileContents.isAvailable() == false) {\n            /* Add the range */\n            fileContents.requestFilePart(dataOffset, dataSize);\n            return null;\n        }\n        /* Get the data */\n        let data = fileContents.getFilePart(dataOffset, dataSize);\n        /* Read the tiles */\n        let tiles = new Array(tileCount);\n        let input = new ABufferInStream(data, 0, data.size());\n        let pointIndex = block.pointIndex;\n        for (let i = 0; i < tileCount; i++) {\n            /* Read the next tile */\n            let tile = new TileIndex(this._level, tileIndex, new GridIndex(0, 0, 0), ALong.ZERO, 0);\n            TileRecord.read(tile, this._level, block.index, input, tileIndex, pointIndex);\n            tiles[i] = tile;\n            tileIndex += 1;\n            pointIndex = pointIndex.addInt(tile.pointCount);\n        }\n        input.close();\n        /* Return the tiles */\n        return tiles;\n    }\n    /**\n     * Get all tile indexes at this level.\n     * @param tileFilter the optional tile filter.\n     * @param selectionType the type of selection in the pointcloud.\n     * @return the list of tiles.\n     */\n    getAllTileIndexes2(fileContents) {\n        /* Process all blocks */\n        let tileList = new AList();\n        for (let block of this._blocks) {\n            /* Read the tiles */\n            let tiles = this.readTiles2(block, fileContents);\n            /* Add all tiles */\n            for (let tile of tiles)\n                tileList.add(tile);\n        }\n        /* Return the list of tiles */\n        return tileList;\n    }\n}\n//# sourceMappingURL=DirectoryReader.js.map",
      "start": 1693508125487,
      "end": 1693508125532,
      "sourcemaps": null
    }
  ]
}
