{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/orbitgt/lib/esm/pointcloud/format/opc/GeometryReader.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module OrbitGT\n */\nimport { LittleEndian } from \"../../../system/buffer/LittleEndian\";\nimport { Uint16Buffer } from \"../../../system/buffer/Uint16Buffer\";\nimport { Uint8Buffer } from \"../../../system/buffer/Uint8Buffer\";\nimport { ALong } from \"../../../system/runtime/ALong\";\nimport { GeometryRecord } from \"./GeometryRecord\";\n/**\n * Class GeometryReader reads geometry data.\n *\n * @version 1.0 January 2014\n */\n/** @internal */\nclass GeometryReader {\n    /**\n     * Create a new reader.\n     * @param opcReader the file reader.\n     * @param level the level.\n     */\n    constructor(fileReader, level) {\n        /* Store the parameters */\n        this._fileReader = fileReader;\n        this._level = level;\n        /* Get the geometry data */\n        this._geometryRecord = null;\n        this._geometryDataPart = fileReader.getContainer().getPart(\"\" + level + \".geometry.data\");\n    }\n    /**\n     * Load the data.\n     * @return the reader.\n     */\n    loadData(fileContents) {\n        /* Read the record */\n        let geometryPart = this._fileReader.getContainer().getPart(\"\" + this._level + \".geometry.definition\");\n        this._geometryRecord = GeometryRecord.readNew(geometryPart.getOffset(), geometryPart.getSize(), fileContents);\n        /* Return the reader */\n        return this;\n    }\n    /**\n     * Get the geometry record.\n     * @return the geometry record.\n     */\n    getGeometryRecord() {\n        return this._geometryRecord;\n    }\n    /**\n     * Read the raw data for a tile.\n     * @param tile the tile.\n     * @param tileBuffer the buffer to read into.\n     * @param readRequest the read parameters (contains the result read statistics).\n     */\n    readTileData2(tile, pointOffset, pointCount, tileBuffer, readRequest, fileContents) {\n        /* What resolution do we have? */\n        let lowResolution = (this._level > 0);\n        let recordSize = (lowResolution) ? GeometryReader.RECORD_SIZE_LR : GeometryReader.RECORD_SIZE_HR;\n        /* Get the file extent */\n        let fileSize = this._fileReader.getContainer().getFileLength();\n        let offset = tile.pointIndex.addInt(pointOffset).mulInt(recordSize).add(this._geometryDataPart.getOffset());\n        let size = pointCount * recordSize;\n        this._geometryDataPart.rangeCheck(offset, ALong.fromInt(size));\n        /* Request the data? */\n        if (fileContents.isAvailable() == false) {\n            /* Add the range */\n            fileContents.requestFilePart(offset, size);\n            return;\n        }\n        /* Update the statistics */\n        readRequest.addDataSize(size);\n        /* Read the content */\n        let data = fileContents.getFilePart(offset, size);\n        tileBuffer.setGeometryBuffer(data);\n    }\n    /**\n     * Convert a low-resolution coordinate to a high-resolution one.\n     * @param local the low-resolution coordinate.\n     * @return the high-resolution coordinate.\n     */\n    static lowToHighResolution(local) {\n        return (local << 8) + (128);\n    }\n    /**\n     * Get geometry data.\n     * @param tile the tile.\n     * @param tileBuffer the buffer that has been read.\n     * @param pointIndex the index of the point to read.\n     * @param cloudPoint the point to read the geometry of.\n     */\n    getPointData(tile, tileBuffer, pointIndex, cloudPoint) {\n        /* What resolution do we have? */\n        let lowResolution = (this._level > 0);\n        let recordSize = (lowResolution) ? GeometryReader.RECORD_SIZE_LR : GeometryReader.RECORD_SIZE_HR;\n        /* Get the buffer */\n        let buffer = tileBuffer.getGeometryBuffer();\n        let offset = (pointIndex * recordSize);\n        /* Read the local position */\n        let lx;\n        let ly;\n        let lz;\n        if (lowResolution) {\n            /* Read the 8-bit local position */\n            lx = GeometryReader.lowToHighResolution(LittleEndian.readBufferByte(buffer, offset));\n            offset++;\n            ly = GeometryReader.lowToHighResolution(LittleEndian.readBufferByte(buffer, offset));\n            offset++;\n            lz = GeometryReader.lowToHighResolution(LittleEndian.readBufferByte(buffer, offset));\n        }\n        else {\n            /* Read the 16-bit local position */\n            lx = LittleEndian.readBufferShort(buffer, offset);\n            offset += 2;\n            ly = LittleEndian.readBufferShort(buffer, offset);\n            offset += 2;\n            lz = LittleEndian.readBufferShort(buffer, offset);\n        }\n        /* Get the grid */\n        let grid = this._geometryRecord.getTileGrid();\n        /* Get the tile position */\n        let tileX0 = grid.p0.x + (tile.gridIndex.x * grid.size.x);\n        let tileY0 = grid.p0.y + (tile.gridIndex.y * grid.size.y);\n        let tileZ0 = grid.p0.z + (tile.gridIndex.z * grid.size.z);\n        /* Get the coordinate scale factors */\n        let scaleX = grid.size.x / 65536.0;\n        let scaleY = grid.size.y / 65536.0;\n        let scaleZ = grid.size.z / 65536.0;\n        /* Set the position */\n        cloudPoint.setX(tileX0 + scaleX * lx);\n        cloudPoint.setY(tileY0 + scaleY * ly);\n        cloudPoint.setZ(tileZ0 + scaleZ * lz);\n    }\n    /**\n     * Get geometry data.\n     * @param tile the tile.\n     * @param tileBuffer the buffer that has been read.\n     * @param pointData the point data.\n     */\n    getPointDataRaw(tile, tileBuffer, pointData) {\n        /* What resolution do we have? */\n        let lowResolution = (this._level > 0);\n        if (lowResolution) {\n            /* Straight copy of the raw buffer */\n            pointData.points8 = new Uint8Buffer(tileBuffer.getGeometryBuffer(), 0, 3 * tile.pointCount);\n        }\n        else {\n            /* Straight copy of the raw buffer */\n            pointData.points16 = new Uint16Buffer(tileBuffer.getGeometryBuffer(), 0, 3 * tile.pointCount);\n        }\n    }\n}\n/** The size of the high-resolution record in the file */\nGeometryReader.RECORD_SIZE_HR = 6;\n/** The size of the low-resolution record in the file */\nGeometryReader.RECORD_SIZE_LR = 3;\n/** The number of bins (subdivisions) in a multi-resolution tile */\nGeometryReader.MR_BIN_COUNT = 64;\nexport { GeometryReader };\n//# sourceMappingURL=GeometryReader.js.map",
      "start": 1693508125494,
      "end": 1693508125547,
      "sourcemaps": null
    }
  ]
}
