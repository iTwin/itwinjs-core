{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/geometry4d/MomentData.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Numerics\n */\n// import { Point2d } from \"./Geometry2d\";\n/* eslint-disable @typescript-eslint/naming-convention */\nimport { Geometry } from \"../Geometry\";\nimport { Matrix3d } from \"../geometry3d/Matrix3d\";\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\nimport { Transform } from \"../geometry3d/Transform\";\nimport { Matrix4d } from \"./Matrix4d\";\nimport { Point4d } from \"./Point4d\";\n/**\n * A MomentData structure exists in several levels:\n * * First level: as a carrier of sums of inertial products that determine moments.\n *   * origin = local origin used as moments are summed.\n *   * sums = array of summed moments.\n *     * The [i,j] entry of the sums is a summed or integrated moment for product of axis i and j.\n *       * axes 0,1,2 are x,y,z\n *         * e.g. entry [0,1] is summed product xy\n *       * axis 3 is \"w\", which is 1 in sums.\n *         * e.g. entry 03 is summed x\n *    * In this level,\n *        * the `absoluteQuantity` member is undefined.\n *        * the `localToWorldMap` and `radiiOfGyration` are created by have undefined contents.\n *  * Second level: after a call to inertiaProductsToPrincipalAxes, the `localToWorldMap`, `absoluteQuantity` and `radiiOfGyration` are filled in.\n * @public\n */\nexport class MomentData {\n    /** Return the lower-right (3,3) entry in the sums.\n     * * This is the quantity (i.e. length, area, or volume) summed\n     */\n    get quantitySum() { return this.sums.atIJ(3, 3); }\n    /** Return a scale factor to make these sums match the target orientation sign.\n     * * 1.0 if `this.quantitySum` has the same sign as `targetSign`.\n     * * -1.0 if `this.quantitySum` has the opposite sign from `targetSign`\n     */\n    signFactor(targetSign) {\n        return targetSign * this.quantitySum > 0 ? 1.0 : -1.0;\n    }\n    /**\n     *  If `this.needOrigin` flag is set, copy `origin` to `this.origin` and clear the flag.\n     *\n     */\n    setOriginIfNeeded(origin) {\n        if (this.needOrigin) {\n            this.origin.setFromPoint3d(origin);\n            this.needOrigin = false;\n        }\n    }\n    /**\n     *  If `this.needOrigin` flag is set, copy `origin` to `this.origin` and clear the flag.\n     *\n     */\n    setOriginFromGrowableXYZArrayIfNeeded(points) {\n        if (this.needOrigin && points.length > 0) {\n            points.getPoint3dAtCheckedPointIndex(0, this.origin);\n            this.needOrigin = false;\n        }\n    }\n    /**\n     *  If `this.needOrigin` flag is set, copy `origin` to `this.origin` and clear the flag.\n     *\n     */\n    setOriginXYZIfNeeded(x, y, z) {\n        if (this.needOrigin) {\n            this.origin.set(x, y, z);\n            this.needOrigin = false;\n        }\n    }\n    constructor() {\n        this._point0 = Point3d.create();\n        this._point1 = Point3d.create();\n        this.origin = Point3d.createZero();\n        this.sums = Matrix4d.createZero();\n        this.localToWorldMap = Transform.createIdentity();\n        this.radiusOfGyration = Vector3d.create();\n        this.needOrigin = false;\n        this.absoluteQuantity = 0.1; // so optimizer sees its type\n        this.absoluteQuantity = undefined;\n    }\n    /** Create moments with optional origin.\n     * * origin and needOrigin are quirky.\n     *   * (undefined, true) sets up to use first incoming point as origin.\n     *   * (origin) sets up to use that durable origin, set needsOrigin flag false\n     *   * (origin, true) the \"true\" is meaningless\n     *   * (undefined, false) makes 000 the durable origin\n    */\n    static create(origin, needOrigin = false) {\n        const data = new MomentData();\n        data.needOrigin = needOrigin;\n        if (origin) {\n            data.origin.setFromPoint3d(origin);\n            data.needOrigin = false;\n        }\n        return data;\n    }\n    /**\n     * Return the formal tensor of integrated values `[yy+zz,xy,xz][yx,xx+zz,yz][zx,xy,xx+yy]`\n     * @param products matrix of (integrated) `[xx,xy,xz][yx,yy,yz][zx,xy,zz]`\n     */\n    static momentTensorFromInertiaProducts(products) {\n        const rr = products.sumDiagonal();\n        const result = Matrix3d.createScale(rr, rr, rr);\n        result.addScaledInPlace(products, -1.0);\n        return result;\n    }\n    /** Sort the columns of the matrix for increasing moments. */\n    static sortColumnsForIncreasingMoments(axes, moments) {\n        const points = [\n            axes.indexedColumnWithWeight(0, moments.x),\n            axes.indexedColumnWithWeight(1, moments.y),\n            axes.indexedColumnWithWeight(2, moments.z),\n        ].sort((dataA, dataB) => {\n            if (dataA.w < dataB.w)\n                return -1;\n            if (dataA.w > dataB.w)\n                return 1;\n            return 0;\n        });\n        axes.setColumnsPoint4dXYZ(points[0], points[1], points[2]);\n        if (axes.determinant() < 0)\n            axes.scaleColumnsInPlace(-1.0, -1.0, -1.0);\n        // prefer x and z positive -- y falls wherever . ..\n        if (axes.at(0, 0) < 0.0)\n            axes.scaleColumnsInPlace(-1.0, -1.0, 1.0);\n        if (axes.at(2, 2) < 0.0)\n            axes.scaleColumnsInPlace(1.0, -1.0, -1.0);\n        moments.set(points[0].w, points[1].w, points[2].w);\n    }\n    /**\n     * Return the principal moment data for an array of points.\n     * @param points array of points\n     */\n    static pointsToPrincipalAxes(points) {\n        const moments = new MomentData();\n        if (points.length === 0)\n            return moments;\n        moments.clearSums(points[0]);\n        moments.accumulatePointMomentsFromOrigin(points);\n        return this.inertiaProductsToPrincipalAxes(moments.origin, moments.sums);\n    }\n    /**\n     * Compute principal axes from inertial products\n     * * The radii of gyration are sorted smallest to largest\n     * * Hence x axis is long direction\n     * * Hence planar data generates large moment as Z\n     * @param origin The origin used for the inertia products.\n     * @param inertiaProducts The inertia products -- sums or integrals of [xx,xy,xz,xw; yx,yy, yz,yw; zx,zy,zz,zw; wx,wy,wz,w]\n     */\n    static inertiaProductsToPrincipalAxes(origin, inertiaProducts) {\n        const moments = new MomentData();\n        moments.sums.setFrom(inertiaProducts);\n        moments.origin.setFrom(origin);\n        if (!moments.shiftOriginAndSumsToCentroidOfSums())\n            return undefined;\n        const products = moments.sums.matrixPart();\n        const w = moments.sums.weight();\n        if (w < 0.0)\n            products.scaleColumnsInPlace(-1, -1, -1);\n        const tensor = MomentData.momentTensorFromInertiaProducts(products);\n        const moment2 = Vector3d.create();\n        const axisVectors = Matrix3d.createZero();\n        tensor.fastSymmetricEigenvalues(axisVectors, moment2);\n        if (moment2.x < 0.0)\n            return undefined;\n        MomentData.sortColumnsForIncreasingMoments(axisVectors, moment2);\n        if (w < 0.0)\n            axisVectors.scaleColumnsInPlace(1, -1, -1);\n        moments.localToWorldMap = Transform.createOriginAndMatrix(moments.origin, axisVectors);\n        moments.radiusOfGyration.set(Math.sqrt(Math.abs(moment2.x)), Math.sqrt(Math.abs(moment2.y)), Math.sqrt(Math.abs(moment2.z)));\n        moments.radiusOfGyration.scaleInPlace(1.0 / Math.sqrt(Math.abs(w)));\n        moments.absoluteQuantity = Math.abs(w);\n        return moments;\n    }\n    /**\n     * Test for match among selected members as they exist after `inertiaProductsToPrincipalAxes`\n     * * The members considered are\n     *   * origin of local to world map (i.e. centroid)\n     *   * radius of gyration\n     *   * axes of localToWorldMap.\n     * * Axis direction tests allow these quirks:\n     *   * opposite orientation is considered matched.\n     * * Full xyz symmetry: If x,y,z radii are matched, axes are not tested.\n     * * Symmetry in xy plane: If x and y radii are matched, the x and y axes area allowed to spin freely.  Only Z direction is tested.\n     * * If either or both are undefined, returns false.\n     * @param dataA first set of moments\n     * @param dataB second set of moments\n     */\n    static areEquivalentPrincipalAxes(dataA, dataB) {\n        if (dataA && dataB\n            && Geometry.isSameCoordinate(dataA.quantitySum, dataB.quantitySum)) { // um.. need different tolerance for area, volume?)\n            if (dataA.localToWorldMap.getOrigin().isAlmostEqual(dataB.localToWorldMap.getOrigin())\n                && dataA.radiusOfGyration.isAlmostEqual(dataB.radiusOfGyration)) {\n                if (Geometry.isSameCoordinate(dataA.radiusOfGyration.x, dataA.radiusOfGyration.y)) {\n                    // We have at least xy symmetry ....\n                    if (Geometry.isSameCoordinate(dataA.radiusOfGyration.x, dataA.radiusOfGyration.z))\n                        return true;\n                    // just xy.\n                    // allow opposite z directions.\n                    // If the z's are aligned, x an dy can spin freely.\n                    const zA = dataA.localToWorldMap.matrix.columnZ();\n                    const zB = dataB.localToWorldMap.matrix.columnZ();\n                    if (zA.isParallelTo(zB, true))\n                        return true;\n                    return false;\n                }\n                // no symmetry.  Test all three axes.\n                const vectorA = Vector3d.create();\n                const vectorB = Vector3d.create();\n                for (let i = 0; i < 3; i++) {\n                    dataA.localToWorldMap.matrix.getColumn(i, vectorA);\n                    dataB.localToWorldMap.matrix.getColumn(i, vectorB);\n                    if (!vectorA.isParallelTo(vectorB, true))\n                        return false;\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    /** Clear the MomentData sums to zero, and establish a new origin. */\n    clearSums(origin) {\n        this.sums.setZero();\n        if (origin)\n            this.origin.setFrom(origin);\n        else\n            this.origin.setZero();\n    }\n    /** Accumulate products-of-components for given points. */\n    accumulatePointMomentsFromOrigin(points) {\n        for (const p of points) {\n            this.sums.addMomentsInPlace(p.x - this.origin.x, p.y - this.origin.y, p.z - this.origin.z, 1.0);\n        }\n    }\n    /** revise the accumulated sums to be \"around the centroid\" */\n    shiftOriginAndSumsToCentroidOfSums() {\n        const xyz = this.sums.columnW().realPoint();\n        if (xyz) {\n            this.shiftOriginAndSumsByXYZ(xyz.x, xyz.y, xyz.z);\n            return true;\n        }\n        return false;\n    }\n    /** revise the accumulated sums\n     * * add ax,ay,ax to the origin coordinates.\n     * * apply the negative translation to the sums.\n    */\n    shiftOriginAndSumsByXYZ(ax, ay, az) {\n        this.origin.addXYZInPlace(ax, ay, az);\n        this.sums.multiplyTranslationSandwichInPlace(-ax, -ay, -az);\n    }\n    /** revise the accumulated sums so they are based at a specified origin. */\n    shiftOriginAndSumsToNewOrigin(newOrigin) {\n        this.shiftOriginAndSumsByXYZ(newOrigin.x - this.origin.x, newOrigin.y - this.origin.y, newOrigin.z - this.origin.z);\n    }\n    /** compute moments of a triangle from the origin to the given line.\n     * Accumulate them to this.sums.\n     * * If `pointA` is undefined, use `this.origin` as pointA.\n     * * If `this.needOrigin` is set, pointB is used\n    */\n    accumulateTriangleMomentsXY(pointA, pointB, pointC) {\n        this.setOriginXYZIfNeeded(pointB.x, pointB.y, 0.0);\n        const x0 = this.origin.x;\n        const y0 = this.origin.y;\n        const vectorA = MomentData._vectorA =\n            pointA !== undefined ? Point4d.create(pointA.x - x0, pointA.y - y0, 0.0, 1.0, MomentData._vectorA)\n                : Point4d.create(this.origin.x, this.origin.y, 0.0, 1.0, MomentData._vectorA);\n        const vectorB = MomentData._vectorB = Point4d.create(pointB.x - x0, pointB.y - y0, 0.0, 1.0, MomentData._vectorB);\n        const vectorC = MomentData._vectorC = Point4d.create(pointC.x - x0, pointC.y - y0, 0.0, 1.0, MomentData._vectorC);\n        // accumulate Return product integrals I(0<=u<=1) I (0<=v<= u)  (w*W + u *U + v * V)(w*W + u *U + v * V)^  du dv\n        //  where w = 1-u-v\n        //  W = column vector (point00.x, point00.y, point00.z, 1.0) etc.\n        const detJ = Geometry.crossProductXYXY(vectorB.x - vectorA.x, vectorB.y - vectorA.y, vectorC.x - vectorA.x, vectorC.y - vectorA.y);\n        if (detJ !== 0.0) {\n            const r1_12 = detJ / 12.0;\n            const r1_24 = detJ / 24.0;\n            this.sums.addScaledOuterProductInPlace(vectorA, vectorA, r1_12);\n            this.sums.addScaledOuterProductInPlace(vectorA, vectorB, r1_24);\n            this.sums.addScaledOuterProductInPlace(vectorA, vectorC, r1_24);\n            this.sums.addScaledOuterProductInPlace(vectorB, vectorA, r1_24);\n            this.sums.addScaledOuterProductInPlace(vectorB, vectorB, r1_12);\n            this.sums.addScaledOuterProductInPlace(vectorB, vectorC, r1_24);\n            this.sums.addScaledOuterProductInPlace(vectorC, vectorA, r1_24);\n            this.sums.addScaledOuterProductInPlace(vectorC, vectorB, r1_24);\n            this.sums.addScaledOuterProductInPlace(vectorC, vectorC, r1_12);\n        }\n    }\n    /** add scaled outer product of (4d, unit weight) point to this.sums */\n    accumulateScaledOuterProduct(point, scaleFactor) {\n        this.setOriginXYZIfNeeded(point.x, point.y, 0.0);\n        const vectorA = MomentData._vectorA = Point4d.create(point.x - this.origin.x, point.y - this.origin.y, point.z - this.origin.z, 1.0, MomentData._vectorA);\n        this.sums.addScaledOuterProductInPlace(vectorA, vectorA, scaleFactor);\n    }\n    /** Accumulate wire moment integral from pointA to pointB */\n    accumulateLineMomentsXYZ(pointA, pointB) {\n        this.setOriginXYZIfNeeded(pointA.x, pointA.y, pointA.z);\n        const x0 = this.origin.x;\n        const y0 = this.origin.y;\n        const z0 = this.origin.z;\n        const vectorA = MomentData._vectorA = Point4d.create(pointA.x - x0, pointA.y - y0, pointA.z - z0, 1.0, MomentData._vectorA);\n        const vectorB = MomentData._vectorB = Point4d.create(pointB.x - x0, pointB.y - y0, pointB.z - z0, 1.0, MomentData._vectorB);\n        const detJ = pointA.distance(pointB);\n        const r1_3 = detJ / 3.0;\n        const r1_6 = detJ / 6.0;\n        this.sums.addScaledOuterProductInPlace(vectorA, vectorA, r1_3);\n        this.sums.addScaledOuterProductInPlace(vectorA, vectorB, r1_6);\n        this.sums.addScaledOuterProductInPlace(vectorB, vectorA, r1_6);\n        this.sums.addScaledOuterProductInPlace(vectorB, vectorB, r1_3);\n    }\n    /** compute moments of triangles from a base point to the given linestring.\n     * Accumulate them to this.sums.\n     * * If `pointA` is undefined, use `this.origin` as pointA.\n     * * If `this.needOrigin` is set, the first point of the array is captured as local origin for subsequent sums.\n     *\n     */\n    accumulateTriangleToLineStringMomentsXY(sweepBase, points) {\n        const n = points.length;\n        if (n > 1) {\n            points.getPoint3dAtUncheckedPointIndex(0, this._point0);\n            for (let i = 1; i < n; i++) {\n                points.getPoint3dAtUncheckedPointIndex(i, this._point1);\n                this.accumulateTriangleMomentsXY(sweepBase, this._point0, this._point1);\n                this._point0.setFromPoint3d(this._point1);\n            }\n        }\n    }\n    // cspell:word ABAT\n    /**\n     * * Assemble XX, YY, XY products into a full matrix form [xx,xy,0,0; xy,yy,0,0;0,0,0,0;0,0,0,1].\n     * * Sandwich this between transforms with columns [vectorU, vectorV, 0000, origin].  (Column weights 0001) (only xy parts of vectors)\n     * * scale by detJ for the xy-only determinant of the vectors.\n     * @param productXX\n     * @param productXY\n     * @param productYY\n     * @param area Area in caller's system\n     * @param origin Caller's origin\n     * @param vectorU Caller's U axis (not necessarily unit)\n     * @param vectorV Caller's V axis (not necessarily unit)\n     */\n    accumulateXYProductsInCentroidalFrame(productXX, productXY, productYY, area, origin, vectorU, vectorV) {\n        const centroidalProducts = Matrix4d.createRowValues(productXX, productXY, 0, 0, productXY, productYY, 0, 0, 0, 0, 0, 0, 0, 0, 0, area);\n        const detJ = Geometry.crossProductXYXY(vectorU.x, vectorV.x, vectorU.y, vectorV.y);\n        const placement = Matrix4d.createRowValues(vectorU.x, vectorV.x, 0, origin.x - this.origin.x, vectorU.y, vectorV.y, 0, origin.y - this.origin.y, 0, 0, 0, 0, 0, 0, 0, 1);\n        const AB = placement.multiplyMatrixMatrix(centroidalProducts);\n        const ABAT = AB.multiplyMatrixMatrixTranspose(placement);\n        this.sums.addScaledInPlace(ABAT, detJ);\n    }\n    /**\n     * Accumulate sums from other moments.\n     * * scale by given scaleFactor (e.g. sign to correct orientation)\n     * * pull the origin from `other` if `this` needs an origin.\n     * *\n     */\n    accumulateProducts(other, scale) {\n        this.setOriginIfNeeded(other.origin);\n        this.sums.addTranslationSandwichInPlace(other.sums, this.origin.x - other.origin.x, this.origin.y - other.origin.y, this.origin.z - other.origin.z, scale);\n    }\n    /**\n   * Accumulate sums from Matrix4d and origin.\n   * * scale by given scaleFactor (e.g. sign to correct orientation)\n   * * trap the origin if `this` needs an origin.\n   * *\n   */\n    accumulateProductsFromOrigin(origin, products, scale) {\n        this.setOriginIfNeeded(origin);\n        this.sums.addTranslationSandwichInPlace(products, this.origin.x - origin.x, this.origin.y - origin.y, this.origin.z - origin.z, scale);\n    }\n    /**\n     * Convert to a json data object with:\n     */\n    toJSON() {\n        return {\n            origin: this.origin,\n            sums: this.sums.toJSON(),\n            radiusOfGyration: this.radiusOfGyration.toJSON(),\n            localToWorld: this.localToWorldMap.toJSON(),\n        };\n    }\n}\n//# sourceMappingURL=MomentData.js.map",
      "start": 1693508122585,
      "end": 1693508122732,
      "sourcemaps": null
    }
  ]
}
