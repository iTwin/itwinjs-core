{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/geometry3d/IndexedXYZCollection.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module ArraysAndInterfaces\n */\nimport { Geometry } from \"../Geometry\";\nimport { Point3d, Vector3d } from \"./Point3dVector3d\";\nimport { Range3d } from \"./Range\";\nclass PointsIterator {\n    constructor(collection) {\n        this._curIndex = -1;\n        this._collection = collection;\n    }\n    next() {\n        if (++this._curIndex >= this._collection.length) {\n            // The ECMAScript spec states that value=undefined is valid if done=true. The TypeScript interface violates the spec hence the cast to any and back below.\n            return { done: true };\n        }\n        return {\n            value: this._collection.getPoint3dAtUncheckedPointIndex(this._curIndex),\n            done: false,\n        };\n    }\n    [Symbol.iterator]() { return this; }\n}\n/**\n * abstract base class for read-only access to XYZ data with indexed reference.\n * * This allows algorithms to work with Point3d[] or GrowableXYZ.\n *   * GrowableXYZArray implements these for its data.\n *   * Point3dArrayCarrier carries a (reference to) a Point3d[] and implements the methods with calls on that array reference.\n * * In addition to \"point by point\" accessors, other abstract members compute commonly useful vector data \"between points\".\n * * Methods that create vectors among multiple indices allow callers to avoid creating temporaries.\n * @public\n */\nexport class IndexedXYZCollection {\n    /**\n     * Return a vector from the point at `indexA` to `target`\n     * @param indexA index of point within the array\n     * @param target target for vector\n     * @param result caller-allocated vector.\n     * @returns undefined if index is out of bounds\n     */\n    vectorIndexXYAndZ(indexA, target, result) {\n        const reversed = this.vectorXYAndZIndex(target, indexA, result);\n        return reversed?.negate(reversed);\n    }\n    /**\n     * Return the dot product of the vectors from the point at `origin` to the points at `indexA` and `indexB`.\n     * @param origin index of point within the array; origin of both vectors\n     * @param indexA index of point within the array; target of the first vector\n     * @param indexA index of point within the array; target of the second vector\n     * @returns undefined if index is out of bounds\n     */\n    dotProductIndexIndexIndex(origin, indexA, indexB) {\n        if (origin < 0 || origin >= this.length || indexA < 0 || indexA >= this.length || indexB < 0 || indexB >= this.length)\n            return undefined;\n        const x0 = this.getXAtUncheckedPointIndex(origin);\n        const y0 = this.getYAtUncheckedPointIndex(origin);\n        const z0 = this.getZAtUncheckedPointIndex(origin);\n        return (this.getXAtUncheckedPointIndex(indexA) - x0) * (this.getXAtUncheckedPointIndex(indexB) - x0) +\n            (this.getYAtUncheckedPointIndex(indexA) - y0) * (this.getYAtUncheckedPointIndex(indexB) - y0) +\n            (this.getZAtUncheckedPointIndex(indexA) - z0) * (this.getZAtUncheckedPointIndex(indexB) - z0);\n    }\n    /**\n     * Return the dot product of the vectors from the point at `origin` to the point at `indexA` and to `targetB`.\n     * @param origin index of point within the array; origin of both vectors\n     * @param indexA index of point within the array; target of the first vector\n     * @param targetB target for second vector\n     * @returns undefined if index is out of bounds\n     */\n    dotProductIndexIndexXYAndZ(origin, indexA, targetB) {\n        if (origin < 0 || origin >= this.length || indexA < 0 || indexA >= this.length)\n            return undefined;\n        const x0 = this.getXAtUncheckedPointIndex(origin);\n        const y0 = this.getYAtUncheckedPointIndex(origin);\n        const z0 = this.getZAtUncheckedPointIndex(origin);\n        return (this.getXAtUncheckedPointIndex(indexA) - x0) * (targetB.x - x0) +\n            (this.getYAtUncheckedPointIndex(indexA) - y0) * (targetB.y - y0) +\n            (this.getZAtUncheckedPointIndex(indexA) - z0) * (targetB.z - z0);\n    }\n    /**\n     * Return the cross product of the vectors from `origin` to the point at `indexA` and to `targetB`\n     * @param origin index of point within the array; origin of both vectors\n     * @param indexA index of point within the array; target of the first vector\n     * @param targetB target of second vector\n     * @param result optional caller-allocated result to fill and return\n     * @returns undefined if an index is out of bounds\n     */\n    crossProductIndexIndexXYAndZ(origin, indexA, targetB, result) {\n        if (origin < 0 || origin >= this.length || indexA < 0 || indexA >= this.length)\n            return undefined;\n        const x0 = this.getXAtUncheckedPointIndex(origin);\n        const y0 = this.getYAtUncheckedPointIndex(origin);\n        const z0 = this.getZAtUncheckedPointIndex(origin);\n        return Vector3d.createCrossProduct(this.getXAtUncheckedPointIndex(indexA) - x0, this.getYAtUncheckedPointIndex(indexA) - y0, this.getZAtUncheckedPointIndex(indexA) - z0, targetB.x - x0, targetB.y - y0, targetB.z - z0, result);\n    }\n    /**\n     * Return distance squared between the point at index0 and target.\n     * @param index0 first point index\n     * @param target second point\n     */\n    distanceSquaredIndexXYAndZ(index0, target) {\n        if (index0 < 0 || index0 >= this.length)\n            return undefined;\n        return Geometry.hypotenuseSquaredXYZ(target.x - this.getXAtUncheckedPointIndex(index0), target.y - this.getYAtUncheckedPointIndex(index0), target.z - this.getZAtUncheckedPointIndex(index0));\n    }\n    /** Adjust index into range by modulo with the length. */\n    cyclicIndex(i) {\n        return (i % this.length);\n    }\n    /** Return the range of the points. */\n    getRange() {\n        const range = Range3d.createNull();\n        const n = this.length;\n        const point = Point3d.create();\n        for (let i = 0; i < n; i++) {\n            this.getPoint3dAtUncheckedPointIndex(i, point);\n            range.extendPoint(point);\n        }\n        return range;\n    }\n    /**\n     * For each run of points with indices i+1 to i+n within distance tolerance of points[i], return the indices i+1, ..., i+n.\n     * @return ordered array of 0-based indices of duplicate points\n     */\n    findOrderedDuplicates(tolerance = Geometry.smallMetricDistance) {\n        const tol2 = tolerance * tolerance;\n        const indices = [];\n        if (this.length > 1) {\n            for (let i = 0; i < this.length - 1;) {\n                let j = i + 1;\n                for (; j < this.length; ++j) {\n                    const dist2 = this.distanceSquaredIndexIndex(i, j);\n                    if (dist2 !== undefined && dist2 < tol2)\n                        indices.push(j);\n                    else\n                        break;\n                }\n                i = j; // found next unique point\n            }\n        }\n        return indices;\n    }\n    /** Compute the linear combination s of the indexed p_i and given scales s_i.\n     * @param scales array of scales. For best results, scales should have same length as the instance.\n     * @param result optional pre-allocated object to fill and return\n     * @return s = sum(p_i * s_i), where i ranges from 0 to min(this.length, scales.length).\n    */\n    linearCombination(scales, result) {\n        const n = Math.min(this.length, scales.length);\n        const sum = (result instanceof Vector3d) ? Vector3d.createZero(result) : Point3d.createZero(result);\n        for (let i = 0; i < n; ++i) {\n            sum.x += scales[i] * this.getXAtUncheckedPointIndex(i);\n            sum.y += scales[i] * this.getYAtUncheckedPointIndex(i);\n            sum.z += scales[i] * this.getZAtUncheckedPointIndex(i);\n        }\n        return sum;\n    }\n    /**\n     * Interpolate the points at the given indices.\n     * @param index0 index of point p0 within the array\n     * @param fraction fraction f such that returned point is p0 + f * (p1 - p0)\n     * @param index1 index of point p1 within the array\n     * @param result optional caller-allocated result to fill and return\n     * @returns undefined if an index is out of bounds\n     */\n    interpolateIndexIndex(index0, fraction, index1, result) {\n        if (index0 < 0 || index0 >= this.length || index1 < 0 || index1 >= this.length)\n            return undefined;\n        return Point3d.create(Geometry.interpolate(this.getXAtUncheckedPointIndex(index0), fraction, this.getXAtUncheckedPointIndex(index1)), Geometry.interpolate(this.getYAtUncheckedPointIndex(index0), fraction, this.getYAtUncheckedPointIndex(index1)), Geometry.interpolate(this.getZAtUncheckedPointIndex(index0), fraction, this.getZAtUncheckedPointIndex(index1)), result);\n    }\n    /** Return iterator over the points in this collection. Usage:\n     * ```ts\n     *  for (const point: Point3d of collection.points) { ... }\n     * ```\n     */\n    get points() {\n        return new PointsIterator(this);\n    }\n    /** convert to Point3d[] */\n    getArray() {\n        const result = [];\n        for (const p of this.points)\n            result.push(p);\n        return result;\n    }\n    /** Return the first point, or undefined if the array is empty. */\n    front(result) {\n        if (this.length === 0)\n            return undefined;\n        return this.getPoint3dAtUncheckedPointIndex(0, result);\n    }\n    /** Return the last point, or undefined if the array is empty. */\n    back(result) {\n        if (this.length === 0)\n            return undefined;\n        return this.getPoint3dAtUncheckedPointIndex(this.length - 1, result);\n    }\n}\n/**\n * abstract base class extends IndexedXYZCollection, adding methods to push, peek, and pop, and rewrite.\n * @public\n */\nexport class IndexedReadWriteXYZCollection extends IndexedXYZCollection {\n}\n//# sourceMappingURL=IndexedXYZCollection.js.map",
      "start": 1693508122321,
      "end": 1693508122440,
      "sourcemaps": null
    }
  ]
}
