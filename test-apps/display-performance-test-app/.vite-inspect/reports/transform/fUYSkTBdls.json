{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/SurfaceGeometry.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { assert, dispose } from \"@itwin/core-bentley\";\nimport { FillFlags, RenderMode, TextureTransparency } from \"@itwin/core-common\";\nimport { SurfaceType } from \"../../common/render/primitives/SurfaceParams\";\nimport { AttributeMap } from \"./AttributeMap\";\nimport { GL } from \"./GL\";\nimport { BufferHandle, BufferParameters, BuffersContainer } from \"./AttributeBuffers\";\nimport { System } from \"./System\";\nimport { MeshGeometry } from \"./MeshGeometry\";\n/** @internal */\nexport function wantMaterials(vf) {\n    return vf.materials && RenderMode.SmoothShade === vf.renderMode;\n}\nfunction wantLighting(vf) {\n    return RenderMode.SmoothShade === vf.renderMode && vf.lighting;\n}\n/** @internal */\nexport class SurfaceGeometry extends MeshGeometry {\n    get lutBuffers() { return this._buffers; }\n    static create(mesh, indices) {\n        const indexBuffer = BufferHandle.createArrayBuffer(indices.data);\n        return undefined !== indexBuffer ? new SurfaceGeometry(indexBuffer, indices.length, mesh) : undefined;\n    }\n    get isDisposed() {\n        return this._buffers.isDisposed\n            && this._indices.isDisposed;\n    }\n    dispose() {\n        dispose(this._buffers);\n        dispose(this._indices);\n    }\n    collectStatistics(stats) {\n        stats.addSurface(this._indices.bytesUsed);\n    }\n    get isLit() { return SurfaceType.Lit === this.surfaceType || SurfaceType.TexturedLit === this.surfaceType; }\n    get isTexturedType() { return SurfaceType.Textured === this.surfaceType || SurfaceType.TexturedLit === this.surfaceType; }\n    get hasTexture() { return this.isTexturedType && undefined !== this.texture; }\n    get hasNormalMap() { return this.isLit && this.isTexturedType && undefined !== this.normalMap; }\n    get isGlyph() { return this.mesh.isGlyph; }\n    get alwaysRenderTranslucent() { return this.isGlyph; }\n    get isTileSection() { return undefined !== this.texture && this.texture.isTileSection; }\n    get isClassifier() { return SurfaceType.VolumeClassifier === this.surfaceType; }\n    get supportsThematicDisplay() {\n        return !this.isGlyph;\n    }\n    get allowColorOverride() {\n        // Text background color should not be overridden by feature symbology overrides - otherwise it becomes unreadable...\n        // We don't actually know if we have text.\n        // We do know that text background color uses blanking fill. So do ImageGraphics, so they're also going to forbid overriding their color.\n        return FillFlags.Blanking !== (this.fillFlags & FillFlags.Blanking);\n    }\n    get asSurface() { return this; }\n    get asEdge() { return undefined; }\n    get asSilhouette() { return undefined; }\n    _draw(numInstances, instanceBuffersContainer) {\n        const system = System.instance;\n        // If we can't write depth in the fragment shader, use polygonOffset to force blanking regions to draw behind.\n        const offset = 2 /* RenderOrder.BlankingRegion */ === this.renderOrder && !system.supportsLogZBuffer;\n        if (offset) {\n            system.context.enable(GL.POLYGON_OFFSET_FILL);\n            system.context.polygonOffset(1.0, 1.0);\n        }\n        const bufs = instanceBuffersContainer !== undefined ? instanceBuffersContainer : this._buffers;\n        bufs.bind();\n        system.drawArrays(GL.PrimitiveType.Triangles, 0, this._numIndices, numInstances);\n        bufs.unbind();\n        if (offset)\n            system.context.disable(GL.POLYGON_OFFSET_FILL);\n    }\n    wantMixMonochromeColor(target) {\n        // Text relies on white-on-white reversal.\n        return !this.isGlyph && (this.isLitSurface || this.wantTextures(target, this.hasTexture));\n    }\n    get techniqueId() { return 0 /* TechniqueId.Surface */; }\n    get isLitSurface() { return this.isLit; }\n    get hasBakedLighting() { return this.mesh.hasBakedLighting; }\n    get renderOrder() {\n        if (FillFlags.Behind === (this.fillFlags & FillFlags.Behind))\n            return 2 /* RenderOrder.BlankingRegion */;\n        let order = this.isLit ? 4 /* RenderOrder.LitSurface */ : 3 /* RenderOrder.UnlitSurface */;\n        if (this.isPlanar)\n            order = order | 8 /* RenderOrder.PlanarBit */;\n        return order;\n    }\n    getColor(target) {\n        if (FillFlags.Background === (this.fillFlags & FillFlags.Background))\n            return target.uniforms.style.backgroundColorInfo;\n        else\n            return this.colorInfo;\n    }\n    getPass(target) {\n        // Classifiers have a dedicated pass\n        if (this.isClassifier)\n            return \"classification\";\n        let opaquePass = this.isPlanar ? \"opaque-planar\" : \"opaque\";\n        // When reading pixels, glyphs are always opaque. Otherwise always transparent (for anti-aliasing).\n        if (this.isGlyph)\n            return target.isReadPixelsInProgress ? opaquePass : \"translucent\";\n        const vf = target.currentViewFlags;\n        // When rendering thematic isolines, we need translucency because they have anti-aliasing.\n        if (target.wantThematicDisplay && this.supportsThematicDisplay && target.uniforms.thematic.wantIsoLines)\n            return \"translucent\";\n        // In wireframe, unless fill is explicitly enabled for planar region, surface does not draw\n        if (RenderMode.Wireframe === vf.renderMode && !this.mesh.isTextureAlwaysDisplayed) {\n            const fillFlags = this.fillFlags;\n            const showFill = FillFlags.Always === (fillFlags & FillFlags.Always) || (vf.fill && FillFlags.ByView === (fillFlags & FillFlags.ByView));\n            if (!showFill)\n                return \"none\";\n        }\n        // If transparency disabled by render mode or view flag, always draw opaque.\n        if (!vf.transparency || RenderMode.SolidFill === vf.renderMode || RenderMode.HiddenLine === vf.renderMode)\n            return opaquePass;\n        // We have 3 sources of alpha: the material, the texture, and the color.\n        // Base alpha comes from the material if it overrides it; otherwise from the color.\n        // The texture's alpha is multiplied by the base alpha.\n        // So we must draw in the translucent pass if the texture has transparency OR the base alpha is less than 1.\n        let hasAlpha = false;\n        const mat = wantMaterials(vf) ? this.mesh.materialInfo : undefined;\n        if (undefined !== mat && mat.overridesAlpha)\n            hasAlpha = mat.hasTranslucency;\n        else\n            hasAlpha = this.getColor(target).hasTranslucency;\n        if (!hasAlpha) {\n            // ###TODO handle TextureTransparency.Mixed; remove Texture.hasTranslucency.\n            const tex = this.wantTextures(target, true) ? this.texture : undefined;\n            switch (tex?.transparency) {\n                case TextureTransparency.Translucent:\n                    hasAlpha = true;\n                    break;\n                case TextureTransparency.Mixed:\n                    opaquePass = `${opaquePass}-translucent`;\n                    break;\n            }\n        }\n        return hasAlpha ? \"translucent\" : opaquePass;\n    }\n    _wantWoWReversal(target) {\n        const fillFlags = this.fillFlags;\n        if (FillFlags.None !== (fillFlags & FillFlags.Background))\n            return false; // fill color explicitly from background\n        if (FillFlags.None !== (fillFlags & FillFlags.Always))\n            return true; // fill displayed even in wireframe\n        const vf = target.currentViewFlags;\n        if (RenderMode.Wireframe === vf.renderMode || vf.visibleEdges)\n            return false; // never invert surfaces when edges are displayed\n        if (this.isLit && wantLighting(vf))\n            return false;\n        // Don't invert white pixels of textures...\n        return !this.wantTextures(target, this.hasTexture);\n    }\n    get materialInfo() { return this.mesh.materialInfo; }\n    useTexture(params) {\n        return this.wantTextures(params.target, this.hasTexture);\n    }\n    useNormalMap(params) {\n        return this.wantNormalMaps(params.target, this.hasNormalMap);\n    }\n    computeSurfaceFlags(params, flags) {\n        const target = params.target;\n        const vf = target.currentViewFlags;\n        const useMaterial = wantMaterials(vf);\n        flags[3 /* SurfaceBitIndex.IgnoreMaterial */] = useMaterial ? 0 : 1;\n        flags[9 /* SurfaceBitIndex.HasMaterialAtlas */] = useMaterial && this.hasMaterialAtlas ? 1 : 0;\n        flags[1 /* SurfaceBitIndex.ApplyLighting */] = 0;\n        flags[6 /* SurfaceBitIndex.HasColorAndNormal */] = 0;\n        if (this.isLit) {\n            flags[2 /* SurfaceBitIndex.HasNormals */] = 1;\n            if (wantLighting(vf))\n                flags[1 /* SurfaceBitIndex.ApplyLighting */] = 1;\n            // Textured meshes store normal in place of color index.\n            // Untextured lit meshes store normal where textured meshes would store UV coords.\n            // Tell shader where to find normal.\n            if (!this.isTexturedType) {\n                flags[6 /* SurfaceBitIndex.HasColorAndNormal */] = 1;\n            }\n        }\n        else {\n            flags[2 /* SurfaceBitIndex.HasNormals */] = 0;\n        }\n        flags[0 /* SurfaceBitIndex.HasTexture */] = this.useTexture(params) ? 1 : 0;\n        flags[8 /* SurfaceBitIndex.HasNormalMap */] = this.useNormalMap(params) ? 1 : 0;\n        flags[10 /* SurfaceBitIndex.UseConstantLodTextureMapping */] = this.mesh.textureUsesConstantLod ? 1 : 0;\n        flags[11 /* SurfaceBitIndex.UseConstantLodNormalMapMapping */] = this.mesh.normalMapUsesConstantLod ? 1 : 0;\n        // The transparency threshold controls how transparent a surface must be to allow light to pass through; more opaque surfaces cast shadows.\n        flags[4 /* SurfaceBitIndex.TransparencyThreshold */] = params.target.isDrawingShadowMap ? 1 : 0;\n        flags[5 /* SurfaceBitIndex.BackgroundFill */] = 0;\n        switch (params.renderPass) {\n            // NB: We need this for opaque pass due to SolidFill (must compute transparency, discard below threshold, render opaque at or above threshold)\n            case 2 /* RenderPass.OpaqueLinear */:\n            case 3 /* RenderPass.OpaquePlanar */:\n            case 5 /* RenderPass.OpaqueGeneral */:\n            case 8 /* RenderPass.Translucent */:\n            case 12 /* RenderPass.WorldOverlay */:\n            case 1 /* RenderPass.OpaqueLayers */:\n            case 7 /* RenderPass.TranslucentLayers */:\n            case 11 /* RenderPass.OverlayLayers */: {\n                const mode = vf.renderMode;\n                if (!this.isGlyph && (RenderMode.HiddenLine === mode || RenderMode.SolidFill === mode)) {\n                    flags[4 /* SurfaceBitIndex.TransparencyThreshold */] = 1;\n                    if (RenderMode.HiddenLine === mode && FillFlags.Always !== (this.fillFlags & FillFlags.Always)) {\n                        // fill flags test for text - doesn't render with bg fill in hidden line mode.\n                        flags[5 /* SurfaceBitIndex.BackgroundFill */] = 1;\n                    }\n                    break;\n                }\n            }\n        }\n    }\n    constructor(indices, numIndices, mesh) {\n        super(mesh, numIndices);\n        this._buffers = BuffersContainer.create();\n        const attrPos = AttributeMap.findAttribute(\"a_pos\", 0 /* TechniqueId.Surface */, false);\n        assert(undefined !== attrPos);\n        this._buffers.addBuffer(indices, [BufferParameters.create(attrPos.location, 3, GL.DataType.UnsignedByte, false, 0, 0, false)]);\n        this._indices = indices;\n    }\n    wantTextures(target, surfaceTextureExists) {\n        if (this.hasScalarAnimation && undefined !== target.analysisTexture)\n            return true;\n        if (!surfaceTextureExists)\n            return false;\n        if (this.mesh.isTextureAlwaysDisplayed)\n            return true;\n        if (this.supportsThematicDisplay && target.wantThematicDisplay)\n            return false;\n        const fill = this.fillFlags;\n        const flags = target.currentViewFlags;\n        // ###TODO need to distinguish between gradient fill and actual textures...\n        switch (flags.renderMode) {\n            case RenderMode.SmoothShade:\n                return flags.textures;\n            case RenderMode.Wireframe:\n                return FillFlags.Always === (fill & FillFlags.Always) || (flags.fill && FillFlags.ByView === (fill & FillFlags.ByView));\n            default:\n                return FillFlags.Always === (fill & FillFlags.Always);\n        }\n    }\n    wantNormalMaps(target, normalMapExists) {\n        if (!normalMapExists || !target.displayNormalMaps)\n            return false;\n        const flags = target.currentViewFlags;\n        switch (flags.renderMode) {\n            case RenderMode.SmoothShade:\n                return flags.textures;\n            default:\n                return false;\n        }\n    }\n}\n//# sourceMappingURL=SurfaceGeometry.js.map",
      "start": 1693508124585,
      "end": 1693508124678,
      "sourcemaps": null
    }
  ]
}
