{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/polyface/multiclip/LinearSearchRange2dArray.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module RangeSearch\n */\nimport { Range2d } from \"../../geometry3d/Range\";\n/**\n * An array of decorated Range2d.\n * * User data is attached to each range via `(myRange as any).tag = myTag`.\n * * Search operations are simple linear.\n * * This class can be used directly for \"smallish\" range sets, or as the leaf level of hierarchical structures for larger range sets.\n * @internal\n */\nexport class LinearSearchRange2dArray {\n    constructor() {\n        this._rangeArray = [];\n        this._isDirty = false;\n        this._compositeRange = Range2d.createNull();\n    }\n    // TODO: build search structure\n    updateForSearch() {\n        this._isDirty = false;\n    }\n    /** Return the overall range of all members. */\n    totalRange(result) {\n        return this._compositeRange.clone(result);\n    }\n    /** Add a range to the search set. */\n    addRange(range, tag) {\n        this._isDirty = true;\n        const myRange = Range2d.createNull();\n        myRange.tag = tag;\n        myRange.extendXY(range.low.x, range.low.y);\n        myRange.extendXY(range.high.x, range.high.y);\n        this._compositeRange.extendRange(myRange);\n        this._rangeArray.push(myRange);\n    }\n    /**\n     * * Search for ranges containing testRange\n     * * Pass each range and tag to handler\n     * * terminate search if handler returns false.\n     * @param testRange search range.\n     * @param handler function to receive range and tag hits.\n     * @return false if search terminated by handler.  Return true if no handler returned false.\n     */\n    searchXY(x, y, handler) {\n        if (this._isDirty)\n            this.updateForSearch();\n        // NEEDS WORK: Linear search here -- do better!\n        for (const candidate of this._rangeArray) {\n            if (candidate.containsXY(x, y))\n                if (!handler(candidate, candidate.tag))\n                    return false;\n        }\n        return true;\n    }\n    /**\n     * * Search for ranges overlapping testRange\n     * * Pass each range and tag to handler\n     * * terminate search if handler returns false.\n     * @param testRange search range.\n     * @param handler function to receive range and tag hits.\n     * @return false if search terminated by handler.  Return true if no handler returned false.\n     */\n    searchRange2d(testRange, handler) {\n        if (this._isDirty)\n            this.updateForSearch();\n        for (const candidate of this._rangeArray) {\n            if (candidate.intersectsRange(testRange))\n                if (!handler(candidate, candidate.tag))\n                    return false;\n        }\n        return true;\n    }\n}\n//# sourceMappingURL=LinearSearchRange2dArray.js.map",
      "start": 1693508124267,
      "end": 1693508124384,
      "sourcemaps": null
    }
  ]
}
