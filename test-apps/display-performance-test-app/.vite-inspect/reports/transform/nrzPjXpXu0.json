{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/UpsampleRealityMeshParams.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Rendering\n */\nimport { Range1d, Range2d, Vector3d, } from \"@itwin/core-geometry\";\nimport { OctEncodedNormal, QParams2d, QPoint2d, QPoint3d, Quantization, } from \"@itwin/core-common\";\nimport { RealityMeshParamsBuilder } from \"./RealityMeshParams\";\nclass UpsampleIndexMap extends Map {\n    constructor() {\n        super(...arguments);\n        this._next = 0;\n        this.indices = new Array();\n    }\n    addTriangle(indices) {\n        for (const index of indices) {\n            let mapIndex = this.get(index);\n            if (undefined === mapIndex)\n                this.set(index, mapIndex = this._next++);\n            this.indices.push(mapIndex);\n        }\n    }\n}\nclass ClipAxis {\n    constructor(vertical, lessThan, value) {\n        this.vertical = vertical;\n        this.lessThan = lessThan;\n        this.value = value;\n    }\n}\nexport function upsampleRealityMeshParams(params, uvSampleRange) {\n    const indexMap = new UpsampleIndexMap();\n    const uvParams = QParams2d.fromZeroToOne();\n    const uvLow = QPoint2d.create(uvSampleRange.low, uvParams);\n    const uvHigh = QPoint2d.create(uvSampleRange.high, uvParams);\n    const uvRange = Range2d.createXYXY(uvLow.x, uvLow.y, uvHigh.x, uvHigh.y);\n    const clipAxes = new Array();\n    const addedPoints = new Array(), addedParams = new Array(), addedNormals = new Array();\n    if (uvLow.x > 0)\n        clipAxes.push(new ClipAxis(true, false, uvLow.x));\n    if (uvHigh.x < Quantization.rangeScale16)\n        clipAxes.push(new ClipAxis(true, true, uvHigh.x));\n    if (uvLow.y > 0)\n        clipAxes.push(new ClipAxis(false, false, uvLow.y));\n    if (uvHigh.y < Quantization.rangeScale16)\n        clipAxes.push(new ClipAxis(false, true, uvHigh.y));\n    const triangleRange = Range2d.createNull();\n    for (let i = 0; i < params.indices.length;) {\n        const triangleIndices = [params.indices[i++], params.indices[i++], params.indices[i++]];\n        Range2d.createNull(triangleRange);\n        for (const index of triangleIndices) {\n            const paramIndex = 2 * index;\n            triangleRange.extendXY(params.uvs.points[paramIndex], params.uvs.points[paramIndex + 1]);\n        }\n        if (uvRange.intersectsRange(triangleRange)) {\n            if (uvRange.containsRange(triangleRange)) {\n                indexMap.addTriangle(triangleIndices);\n            }\n            else {\n                addClipped(params, triangleIndices, indexMap, clipAxes, 0, addedPoints, addedParams, addedNormals);\n            }\n        }\n    }\n    const parentPoints = params.positions;\n    const parentParams = params.uvs;\n    const parentNormals = params.normals;\n    const parentPointCount = parentPoints.points.length / 3;\n    const zRange = Range1d.createNull();\n    const builder = new RealityMeshParamsBuilder({\n        positionRange: parentPoints.params.computeRange(),\n        initialVertexCapacity: indexMap.size,\n        initialIndexCapacity: indexMap.indices.length,\n        wantNormals: parentNormals !== undefined,\n    });\n    const pos = new QPoint3d();\n    const uv = new QPoint2d();\n    for (const entry of indexMap.entries()) {\n        const parentIndex = entry[0];\n        let normal;\n        if (parentIndex < parentPointCount) {\n            const pointIndex = 3 * parentIndex;\n            pos.setFromScalars(parentPoints.points[pointIndex], parentPoints.points[pointIndex + 1], parentPoints.points[pointIndex + 2]);\n            const paramIndex = 2 * parentIndex;\n            uv.setFromScalars(parentParams.points[paramIndex], parentParams.points[paramIndex + 1]);\n            if (parentNormals)\n                normal = parentNormals[parentIndex];\n        }\n        else {\n            const addedIndex = parentIndex - parentPointCount;\n            addedPoints[addedIndex].clone(pos);\n            addedParams[addedIndex].clone(uv);\n            if (addedNormals.length > 0)\n                normal = addedNormals[addedIndex];\n        }\n        builder.addQuantizedVertex(pos, uv, normal);\n        zRange.extendX(pos.z);\n    }\n    builder.addIndices(indexMap.indices);\n    const mesh = builder.finish();\n    const qParams = mesh.positions.params;\n    return {\n        mesh: builder.finish(),\n        heightRange: Range1d.createXX(Quantization.unquantize(zRange.low, qParams.origin.z, qParams.scale.z), Quantization.unquantize(zRange.high, qParams.origin.z, qParams.scale.z)),\n    };\n}\nfunction interpolate(value0, value1, fraction) {\n    return value0 + (value1 - value0) * fraction;\n}\nfunction interpolateInt(value0, value1, fraction) {\n    return Math.floor(.5 + interpolate(value0, value1, fraction));\n}\nfunction interpolateQPoint3d(qPoint, qNext, fraction) {\n    return QPoint3d.fromScalars(interpolateInt(qPoint.x, qNext.x, fraction), interpolateInt(qPoint.y, qNext.y, fraction), interpolateInt(qPoint.z, qNext.z, fraction));\n}\nfunction interpolateQPoint2d(qPoint, qNext, fraction) {\n    return QPoint2d.fromScalars(interpolateInt(qPoint.x, qNext.x, fraction), interpolateInt(qPoint.y, qNext.y, fraction));\n}\nfunction interpolateOctEncodedNormal(normal0, normal1, fraction) {\n    const n0 = OctEncodedNormal.decodeValue(normal0);\n    const n1 = OctEncodedNormal.decodeValue(normal1);\n    if (undefined !== n0 && undefined !== n1) {\n        const n = Vector3d.create(interpolate(n0.x, n1.x, fraction), interpolate(n0.y, n1.y, fraction), interpolate(n0.z, n1.z, fraction));\n        n.normalizeInPlace();\n        return OctEncodedNormal.encode(n);\n    }\n    else {\n        return OctEncodedNormal.encode(Vector3d.create(0, 0, 1));\n    }\n}\nfunction addClipped(params, triangleIndices, indexMap, clipAxes, clipIndex, addedPoints, addedParams, addedNormals) {\n    if (clipIndex === clipAxes.length) {\n        indexMap.addTriangle(triangleIndices);\n        return;\n    }\n    const inside = [false, false, false];\n    const values = [0, 0, 0];\n    const clipOutput = [];\n    const parentPoints = params.positions.points;\n    const parentParams = params.uvs.points;\n    const parentNormals = params.normals;\n    const clipAxis = clipAxes[clipIndex++];\n    const clipValue = clipAxis.value;\n    const parentPointCount = parentPoints.length / 3;\n    const scratchQPoint3d = new QPoint3d(), scratchQPoint3d1 = new QPoint3d();\n    const scratchQPoint2d = new QPoint2d(), scratchQPoint2d1 = new QPoint2d();\n    const getPoint = (index, result) => {\n        if (index < parentPointCount) {\n            const pointIndex = index * 3;\n            result.setFromScalars(parentPoints[pointIndex], parentPoints[pointIndex + 1], parentPoints[pointIndex + 2]);\n        }\n        else {\n            addedPoints[index - parentPointCount].clone(result);\n        }\n        return result;\n    };\n    const getParam = (index, result) => {\n        if (index < parentPointCount) {\n            const pointIndex = index * 2;\n            result.setFromScalars(parentParams[pointIndex], parentParams[pointIndex + 1]);\n        }\n        else {\n            addedParams[index - parentPointCount].clone(result);\n        }\n        return result;\n    };\n    const getNormal = (index) => {\n        if (!parentNormals)\n            return undefined;\n        return (index < parentPointCount) ? parentNormals[index] : addedNormals[index - parentPointCount];\n    };\n    for (let i = 0; i < 3; i++) {\n        const index = triangleIndices[i];\n        const thisParam = getParam(index, scratchQPoint2d);\n        const thisValue = clipAxis.vertical ? thisParam.x : thisParam.y;\n        values[i] = thisValue;\n        inside[i] = clipAxis.lessThan ? (thisValue < clipValue) : (thisValue > clipValue);\n    }\n    for (let i = 0; i < 3; i++) {\n        const index = triangleIndices[i];\n        const next = (i + 1) % 3;\n        if (inside[i])\n            clipOutput.push(index);\n        if (inside[i] !== inside[next]) {\n            const nextIndex = triangleIndices[next];\n            const fraction = (clipValue - values[i]) / (values[next] - values[i]);\n            clipOutput.push(parentPointCount + addedPoints.length);\n            addedPoints.push(interpolateQPoint3d(getPoint(index, scratchQPoint3d), getPoint(nextIndex, scratchQPoint3d1), fraction));\n            addedParams.push(interpolateQPoint2d(getParam(index, scratchQPoint2d), getParam(nextIndex, scratchQPoint2d1), fraction));\n            if (parentNormals)\n                addedNormals.push(interpolateOctEncodedNormal(getNormal(index), getNormal(nextIndex), fraction));\n        }\n    }\n    if (clipOutput.length > 2) {\n        addClipped(params, clipOutput.slice(0, 3), indexMap, clipAxes, clipIndex, addedPoints, addedParams, addedNormals);\n        if (clipOutput.length > 3)\n            addClipped(params, [clipOutput[0], clipOutput[2], clipOutput[3]], indexMap, clipAxes, clipIndex, addedPoints, addedParams, addedNormals);\n    }\n}\n//# sourceMappingURL=UpsampleRealityMeshParams.js.map",
      "start": 1693508123857,
      "end": 1693508124060,
      "sourcemaps": null
    }
  ]
}
