{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/quantity-formatting/QuantityFormatter.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module QuantityFormatting\n */\nimport { BentleyError, BeUiEvent, Logger } from \"@itwin/core-bentley\";\nimport { Format, FormatterSpec, ParseError, ParserSpec, } from \"@itwin/core-quantity\";\nimport { FrontendLoggerCategory } from \"../common/FrontendLoggerCategory\";\nimport { IModelApp } from \"../IModelApp\";\nimport { BasicUnitsProvider, getDefaultAlternateUnitLabels } from \"./BasicUnitsProvider\";\n// cSpell:ignore FORMATPROPS FORMATKEY ussurvey uscustomary USCUSTOM\n/**\n * Defines standard format types for tools that need to display measurements to user.\n * @public\n */\nexport var QuantityType;\n(function (QuantityType) {\n    /** Length which is stored in meters. Typically formatted to display in meters or feet-inches based on active unit system. */\n    QuantityType[QuantityType[\"Length\"] = 1] = \"Length\";\n    /** Angular value which is stored in radians. Typically formatted to display degrees or Degrees-Minute-Seconds based on active unit system. */\n    QuantityType[QuantityType[\"Angle\"] = 2] = \"Angle\";\n    /** Area value store in meters squared. Typically formatted to display in meters squared or feet squared based on active unit system. */\n    QuantityType[QuantityType[\"Area\"] = 3] = \"Area\";\n    /** Volume value which is stored in meters cubed. Typically formatted to display in meters cubed or feet cubed based on active unit system. */\n    QuantityType[QuantityType[\"Volume\"] = 4] = \"Volume\";\n    /** LatLong is an angular value which is stored in radians. Typically formatted to display degrees or Degrees-Minute-Seconds based on active unit system. */\n    QuantityType[QuantityType[\"LatLong\"] = 5] = \"LatLong\";\n    /** Coordinate/Location value which is stored in meters. Typically formatted to display in meters or feet based on active unit system. */\n    QuantityType[QuantityType[\"Coordinate\"] = 6] = \"Coordinate\";\n    /** Stationing is a distance value stored in meters. Typically formatted to display `xxx+xx` or `xx+xxx` based on active unit system. */\n    QuantityType[QuantityType[\"Stationing\"] = 7] = \"Stationing\";\n    /** LengthSurvey is a distance value stored in meters. Typically formatted to display in meters or US Survey Feet based on active unit system.. */\n    QuantityType[QuantityType[\"LengthSurvey\"] = 8] = \"LengthSurvey\";\n    /** LengthEngineering is a distance value stored in meters. Typically formatted to display either meters or feet based on active unit system. */\n    QuantityType[QuantityType[\"LengthEngineering\"] = 9] = \"LengthEngineering\";\n})(QuantityType || (QuantityType = {}));\n/**\n * Class that contains alternate Unit Labels. These labels are used when parsing strings to quantities.\n * One use case is to allow a \"^\", which is easily input, to be used to specify \"°\".\n * @internal\n */\nexport class AlternateUnitLabelsRegistry {\n    addAlternateLabels(key, ...labels) {\n        [...labels].forEach((value) => this._alternateLabelRegistry.get(key)?.add(value));\n    }\n    constructor(defaultAlternates) {\n        this._alternateLabelRegistry = new Map();\n        if (defaultAlternates) {\n            this._alternateLabelRegistry = defaultAlternates;\n        }\n    }\n    getAlternateUnitLabels(unit) {\n        const key = unit.name;\n        const labels = this._alternateLabelRegistry.get(key);\n        if (labels)\n            return [...labels.values()];\n        return undefined;\n    }\n}\n/**\n * Function to return a QuantityTypeKey given either a QuantityType enum value or a string. This allows caching and\n * retrieving standard and custom quantity types.\n * @public\n */\nexport function getQuantityTypeKey(type) {\n    // For QuantityType enum values, build a string that shouldn't collide with anything a user may come up with\n    if (typeof type === \"number\")\n        return `QuantityTypeEnumValue-${type.toString()}`;\n    return type;\n}\n/** CustomQuantityTypeDefinition type guard.\n * @public\n*/\nexport function isCustomQuantityTypeDefinition(item) {\n    return !!item.isCompatibleFormatProps;\n}\n/** private class to hold standard quantity definitions as defined by QuantityType enum and implement QuantityTypeDefinition interface */\nclass StandardQuantityTypeDefinition {\n    constructor(type, persistenceUnit, _labelKey, _descriptionKey) {\n        this.type = type;\n        this.persistenceUnit = persistenceUnit;\n        this._labelKey = _labelKey;\n        this._descriptionKey = _descriptionKey;\n        this._key = getQuantityTypeKey(type);\n    }\n    get key() { return this._key; }\n    get label() {\n        if (!this._label) {\n            this._label = IModelApp.localization.getLocalizedString(this._labelKey);\n        }\n        return this._label ?? \"\";\n    }\n    get description() {\n        if (!this._description) {\n            this._description = IModelApp.localization.getLocalizedString(this._descriptionKey);\n        }\n        return this._description ?? this.label;\n    }\n    /** Get a default format to show quantity in persistence unit with precision or 6 decimal places.  */\n    getDefaultFormatPropsBySystem(requestedSystem) {\n        // Fallback same as Format \"DefaultRealU\" in Formats ecschema\n        const fallbackProps = {\n            formatTraits: [\"keepSingleZero\", \"keepDecimalPoint\", \"showUnitLabel\"],\n            precision: 6,\n            type: \"Decimal\",\n            uomSeparator: \" \",\n            decimalSeparator: \".\",\n        };\n        const defaultUnitSystemData = DEFAULT_FORMATKEY_BY_UNIT_SYSTEM.find((value) => value.system === requestedSystem);\n        if (defaultUnitSystemData) {\n            const defaultFormatEntry = defaultUnitSystemData.entries.find((value) => value.type === this.key);\n            if (defaultFormatEntry) {\n                const defaultFormatPropsEntry = DEFAULT_FORMATPROPS.find((props) => props.key === defaultFormatEntry.formatKey);\n                if (defaultFormatPropsEntry)\n                    return defaultFormatPropsEntry.format;\n            }\n        }\n        return fallbackProps;\n    }\n    async generateFormatterSpec(formatProps, unitsProvider) {\n        const format = await Format.createFromJSON(this.key, unitsProvider, formatProps);\n        return FormatterSpec.create(format.name, format, unitsProvider, this.persistenceUnit);\n    }\n    async generateParserSpec(formatProps, unitsProvider, alternateUnitLabelsProvider) {\n        const format = await Format.createFromJSON(this.key, unitsProvider, formatProps);\n        return ParserSpec.create(format, unitsProvider, this.persistenceUnit, alternateUnitLabelsProvider);\n    }\n}\n/** Class that supports formatting quantity values into strings and parsing strings into quantity values. This class also maintains\n * the \"active\" unit system and caches FormatterSpecs and ParserSpecs for the \"active\" unit system to allow synchronous access to\n * parsing and formatting values. The support unit systems are defined by [[UnitSystemKey]] and is kept in synch with the unit systems\n * provided by the Presentation Manager on the backend. The QuantityFormatter contains a registry of quantity type definitions. These definitions implement\n * the [[QuantityTypeDefinition]] interface, which among other things, provide default [FormatProps]$(core-quantity), and provide methods\n * to generate both a [FormatterSpec]$(core-quantity) and a [ParserSpec]$(core-quantity). There are built-in quantity types that are\n * identified by the [[QuantityType]] enum. [[CustomQuantityTypeDefinition]] can be registered to extend the available quantity types available\n * by frontend tools. The QuantityFormatter also allows the default formats to be overriden.\n *\n * @public\n */\nexport class QuantityFormatter {\n    /** Set the settings provider and if not iModel specific initialize setting for user. */\n    async setUnitFormattingSettingsProvider(provider) {\n        this._unitFormattingSettingsProvider = provider;\n        if (!provider.maintainOverridesPerIModel)\n            await provider.loadOverrides(undefined);\n    }\n    /**\n     * constructor\n     * @param showMetricOrUnitSystem - Pass in `true` to show Metric formatted quantity values. Defaults to Imperial. To explicitly\n     * set it to a specific unit system pass a UnitSystemKey.\n     */\n    constructor(showMetricOrUnitSystem) {\n        this._unitsProvider = new BasicUnitsProvider();\n        this._alternateUnitLabelsRegistry = new AlternateUnitLabelsRegistry(getDefaultAlternateUnitLabels());\n        /** Registry containing available quantity type definitions. */\n        this._quantityTypeRegistry = new Map();\n        /** Active UnitSystem key - must be one of \"imperial\", \"metric\", \"usCustomary\", or \"usSurvey\". */\n        this._activeUnitSystem = \"imperial\";\n        /** Map of FormatSpecs for all available QuantityTypes and the active Unit System */\n        this._activeFormatSpecsByType = new Map();\n        /** Map of ParserSpecs for all available QuantityTypes and the active Unit System */\n        this._activeParserSpecsByType = new Map();\n        /** Map of FormatSpecs that have been overriden from the default. */\n        this._overrideFormatPropsByUnitSystem = new Map();\n        /** Called after the active unit system is changed.\n        * The system will report the UnitSystemKey/name of the the system that was activated.\n        */\n        this.onActiveFormattingUnitSystemChanged = new BeUiEvent();\n        /** Called when the format of a QuantityType is overriden or the override is cleared. The string returned will\n         * be a QuantityTypeKey generated by method `getQuantityTypeKey`.\n         */\n        this.onQuantityFormatsChanged = new BeUiEvent();\n        /** Fired when the active UnitsProvider is updated. This will allow cached Formatter and Parser specs to be updated if necessary. */\n        this.onUnitsProviderChanged = new BeUiEvent();\n        if (undefined !== showMetricOrUnitSystem) {\n            if (typeof showMetricOrUnitSystem === \"boolean\")\n                this._activeUnitSystem = showMetricOrUnitSystem ? \"metric\" : \"imperial\";\n            else\n                this._activeUnitSystem = showMetricOrUnitSystem;\n        }\n    }\n    getOverrideFormatPropsByQuantityType(quantityTypeKey, unitSystem) {\n        const requestedUnitSystem = unitSystem ?? this.activeUnitSystem;\n        const overrideMap = this._overrideFormatPropsByUnitSystem.get(requestedUnitSystem);\n        if (!overrideMap)\n            return undefined;\n        return overrideMap.get(quantityTypeKey);\n    }\n    /** Method used to register all QuantityTypes defined in QuantityType enum. */\n    async initializeQuantityTypesRegistry() {\n        // QuantityType.Length\n        const lengthUnit = await this.findUnitByName(\"Units.M\");\n        const lengthDefinition = new StandardQuantityTypeDefinition(QuantityType.Length, lengthUnit, \"iModelJs:QuantityType.Length.label\", \"iModelJs:QuantityType.Length.description\");\n        this._quantityTypeRegistry.set(lengthDefinition.key, lengthDefinition);\n        // QuantityType.LengthEngineering\n        const lengthEngineeringDefinition = new StandardQuantityTypeDefinition(QuantityType.LengthEngineering, lengthUnit, \"iModelJs:QuantityType.LengthEngineering.label\", \"iModelJs:QuantityType.LengthEngineering.description\");\n        this._quantityTypeRegistry.set(lengthEngineeringDefinition.key, lengthEngineeringDefinition);\n        // QuantityType.Coordinate\n        const coordinateDefinition = new StandardQuantityTypeDefinition(QuantityType.Coordinate, lengthUnit, \"iModelJs:QuantityType.Coordinate.label\", \"iModelJs:QuantityType.Coordinate.description\");\n        this._quantityTypeRegistry.set(coordinateDefinition.key, coordinateDefinition);\n        // QuantityType.Stationing\n        const stationingDefinition = new StandardQuantityTypeDefinition(QuantityType.Stationing, lengthUnit, \"iModelJs:QuantityType.Stationing.label\", \"iModelJs:QuantityType.Stationing.description\");\n        this._quantityTypeRegistry.set(stationingDefinition.key, stationingDefinition);\n        // QuantityType.LengthSurvey\n        const lengthSurveyDefinition = new StandardQuantityTypeDefinition(QuantityType.LengthSurvey, lengthUnit, \"iModelJs:QuantityType.LengthSurvey.label\", \"iModelJs:QuantityType.LengthSurvey.description\");\n        this._quantityTypeRegistry.set(lengthSurveyDefinition.key, lengthSurveyDefinition);\n        // QuantityType.Angle\n        const radUnit = await this.findUnitByName(\"Units.RAD\");\n        const angleDefinition = new StandardQuantityTypeDefinition(QuantityType.Angle, radUnit, \"iModelJs:QuantityType.Angle.label\", \"iModelJs:QuantityType.Angle.description\");\n        this._quantityTypeRegistry.set(angleDefinition.key, angleDefinition);\n        // QuantityType.LatLong\n        const latLongDefinition = new StandardQuantityTypeDefinition(QuantityType.LatLong, radUnit, \"iModelJs:QuantityType.LatLong.label\", \"iModelJs:QuantityType.LatLong.description\");\n        this._quantityTypeRegistry.set(latLongDefinition.key, latLongDefinition);\n        // QuantityType.Area\n        const sqMetersUnit = await this.findUnitByName(\"Units.SQ_M\");\n        const areaDefinition = new StandardQuantityTypeDefinition(QuantityType.Area, sqMetersUnit, \"iModelJs:QuantityType.Area.label\", \"iModelJs:QuantityType.Area.description\");\n        this._quantityTypeRegistry.set(areaDefinition.key, areaDefinition);\n        // QuantityType.Volume\n        const cubicMetersUnit = await this.findUnitByName(\"Units.CUB_M\");\n        const volumeDefinition = new StandardQuantityTypeDefinition(QuantityType.Volume, cubicMetersUnit, \"iModelJs:QuantityType.Volume.label\", \"iModelJs:QuantityType.Volume.description\");\n        this._quantityTypeRegistry.set(volumeDefinition.key, volumeDefinition);\n    }\n    /** Asynchronous call to load Formatting and ParsingSpecs for a unit system. This method ends up caching FormatterSpecs and ParserSpecs\n     *  so they can be quickly accessed.\n     * @internal public for unit test usage\n     */\n    async loadFormatAndParsingMapsForSystem(systemType) {\n        const systemKey = (undefined !== systemType) ? systemType : this._activeUnitSystem;\n        const formatPropsByType = new Map();\n        // load cache for every registered QuantityType\n        [...this.quantityTypesRegistry.keys()].forEach((key) => {\n            const entry = this.quantityTypesRegistry.get(key);\n            formatPropsByType.set(entry, this.getFormatPropsByQuantityTypeEntryAndSystem(entry, systemKey));\n        });\n        for (const [entry, formatProps] of formatPropsByType) {\n            await this.loadFormatAndParserSpec(entry, formatProps);\n        }\n    }\n    getFormatPropsByQuantityTypeEntryAndSystem(quantityEntry, requestedSystem, ignoreOverrides) {\n        if (!ignoreOverrides) {\n            const overrideProps = this.getOverrideFormatPropsByQuantityType(quantityEntry.key, requestedSystem);\n            if (overrideProps)\n                return overrideProps;\n        }\n        return quantityEntry.getDefaultFormatPropsBySystem(requestedSystem);\n    }\n    async loadFormatAndParserSpec(quantityTypeDefinition, formatProps) {\n        const formatterSpec = await quantityTypeDefinition.generateFormatterSpec(formatProps, this.unitsProvider);\n        const parserSpec = await quantityTypeDefinition.generateParserSpec(formatProps, this.unitsProvider, this.alternateUnitLabelsProvider);\n        this._activeFormatSpecsByType.set(quantityTypeDefinition.key, formatterSpec);\n        this._activeParserSpecsByType.set(quantityTypeDefinition.key, parserSpec);\n    }\n    // repopulate formatSpec and parserSpec entries using only default format\n    async loadDefaultFormatAndParserSpecForQuantity(typeKey) {\n        const quantityTypeDefinition = this.quantityTypesRegistry.get(typeKey);\n        if (!quantityTypeDefinition)\n            throw new Error(`Unable to locate QuantityType by key ${typeKey}`);\n        const defaultFormat = quantityTypeDefinition.getDefaultFormatPropsBySystem(this.activeUnitSystem);\n        await this.loadFormatAndParserSpec(quantityTypeDefinition, defaultFormat);\n    }\n    async setOverrideFormatsByQuantityTypeKey(typeKey, overrideEntry) {\n        // extract overrides and insert into appropriate override map entry\n        Object.keys(overrideEntry).forEach((systemKey) => {\n            const unitSystemKey = systemKey;\n            const props = overrideEntry[unitSystemKey];\n            if (props) {\n                if (this._overrideFormatPropsByUnitSystem.has(unitSystemKey)) {\n                    this._overrideFormatPropsByUnitSystem.get(unitSystemKey).set(typeKey, props);\n                }\n                else {\n                    const newMap = new Map();\n                    newMap.set(typeKey, props);\n                    this._overrideFormatPropsByUnitSystem.set(unitSystemKey, newMap);\n                }\n            }\n        });\n        await this._unitFormattingSettingsProvider?.storeFormatOverrides({ typeKey, overrideEntry });\n        const formatProps = this.getOverrideFormatPropsByQuantityType(typeKey, this.activeUnitSystem);\n        if (formatProps) {\n            const typeEntry = this.quantityTypesRegistry.get(typeKey);\n            if (typeEntry) {\n                await this.loadFormatAndParserSpec(typeEntry, formatProps);\n                // trigger a message to let callers know the format has changed.\n                this.onQuantityFormatsChanged.emit({ quantityType: typeKey });\n            }\n        }\n    }\n    /** Method called to clear override and restore defaults formatter and parser spec */\n    async clearOverrideFormatsByQuantityTypeKey(type) {\n        const unitSystem = this.activeUnitSystem;\n        if (this.getOverrideFormatPropsByQuantityType(type, unitSystem)) {\n            const overrideMap = this._overrideFormatPropsByUnitSystem.get(unitSystem);\n            if (overrideMap && overrideMap.has(type)) {\n                overrideMap.delete(type);\n                await this._unitFormattingSettingsProvider?.storeFormatOverrides({ typeKey: type, unitSystem });\n                await this.loadDefaultFormatAndParserSpecForQuantity(type);\n                // trigger a message to let callers know the format has changed.\n                this.onQuantityFormatsChanged.emit({ quantityType: type });\n            }\n        }\n    }\n    /** This method is called during IModelApp initialization to load the standard quantity types into the registry and to initialize the cache.\n     * @internal\n     */\n    async onInitialized() {\n        await this.initializeQuantityTypesRegistry();\n        // initialize default format and parsing specs\n        await this.loadFormatAndParsingMapsForSystem();\n    }\n    /** Return a map that serves as a registry of all standard and custom quantity types. */\n    get quantityTypesRegistry() {\n        return this._quantityTypeRegistry;\n    }\n    /** Return the class the contain map of all alternate labels for units. These alternate labels are used when parsing strings in quantity values. */\n    get alternateUnitLabelsProvider() {\n        return this._alternateUnitLabelsRegistry;\n    }\n    /**\n     * Add one or more alternate labels for a unit - these labels are used during string parsing.\n     * @param key UnitNameKey which comes from `UnitProps.name`\n     * @param labels one or more unit labels\n     */\n    addAlternateLabels(key, ...labels) {\n        this._alternateUnitLabelsRegistry.addAlternateLabels(key, ...labels);\n        this.onUnitsProviderChanged.emit();\n    }\n    /** Get/Set the active UnitsProvider class. */\n    get unitsProvider() {\n        return this._unitsProvider;\n    }\n    set unitsProvider(unitsProvider) {\n        this.setUnitsProvider(unitsProvider); // eslint-disable-line @typescript-eslint/no-floating-promises\n    }\n    /** async method to set a units provider and reload caches */\n    async setUnitsProvider(unitsProvider) {\n        this._unitsProvider = unitsProvider;\n        try {\n            // force all cached data to be reinitialized\n            await IModelApp.quantityFormatter.onInitialized();\n        }\n        catch (err) {\n            Logger.logWarning(`${FrontendLoggerCategory.Package}.quantityFormatter`, BentleyError.getErrorMessage(err), BentleyError.getErrorMetadata(err));\n            Logger.logWarning(`${FrontendLoggerCategory.Package}.quantityFormatter`, \"An exception occurred initializing the iModelApp.quantityFormatter with the given UnitsProvider. Defaulting back to the internal units provider.\");\n            // If there is a problem initializing with the given provider, default back to the internal provider\n            await IModelApp.quantityFormatter.resetToUseInternalUnitsProvider();\n            return;\n        }\n        // force default tool to start so any tool that may be using cached data will not be using bad data.\n        if (IModelApp.toolAdmin)\n            await IModelApp.toolAdmin.startDefaultTool();\n        this.onUnitsProviderChanged.emit();\n    }\n    /** Async call typically used after IModel is closed to reset UnitsProvider to default one that does not require an Units schema. */\n    async resetToUseInternalUnitsProvider() {\n        if (this._unitsProvider instanceof BasicUnitsProvider)\n            return;\n        await this.setUnitsProvider(new BasicUnitsProvider());\n    }\n    /** Async call to register a CustomQuantityType and load the FormatSpec and ParserSpec for the new type. */\n    async registerQuantityType(entry, replace) {\n        if (!replace && this._quantityTypeRegistry.has(entry.key))\n            return false;\n        this._quantityTypeRegistry.set(entry.key, entry);\n        // load any overrides so any saved overrides for the type being registered are applied\n        if (this._unitFormattingSettingsProvider)\n            await this._unitFormattingSettingsProvider.loadOverrides(undefined);\n        if (entry.getDefaultFormatPropsBySystem) {\n            const formatProps = entry.getDefaultFormatPropsBySystem(this.activeUnitSystem);\n            await this.loadFormatAndParserSpec(entry, formatProps);\n            return true;\n        }\n        return false;\n    }\n    /** Reinitialize caches. Typically called by active UnitFormattingSettingsProvider.\n     * startDefaultTool - set to true to start the Default to instead of leaving any active tool pointing to cached unit data that is no longer valid\n     * @public\n     */\n    async reinitializeFormatAndParsingsMaps(overrideFormatPropsByUnitSystem, unitSystemKey, fireUnitSystemChanged, startDefaultTool) {\n        this._overrideFormatPropsByUnitSystem.clear();\n        if (overrideFormatPropsByUnitSystem.size) {\n            this._overrideFormatPropsByUnitSystem = overrideFormatPropsByUnitSystem;\n        }\n        unitSystemKey && (this._activeUnitSystem = unitSystemKey);\n        await this.loadFormatAndParsingMapsForSystem(this._activeUnitSystem);\n        fireUnitSystemChanged && this.onActiveFormattingUnitSystemChanged.emit({ system: this._activeUnitSystem });\n        IModelApp.toolAdmin && startDefaultTool && await IModelApp.toolAdmin.startDefaultTool();\n    }\n    /** Set the Active unit system to one of the supported types. This will asynchronously load the formatter and parser specs for the activated system. */\n    async setActiveUnitSystem(isImperialOrUnitSystem, restartActiveTool) {\n        let systemType;\n        if (typeof isImperialOrUnitSystem === \"boolean\")\n            systemType = isImperialOrUnitSystem ? \"imperial\" : \"metric\";\n        else\n            systemType = isImperialOrUnitSystem;\n        if (this._activeUnitSystem === systemType)\n            return;\n        this._activeUnitSystem = systemType;\n        await this.loadFormatAndParsingMapsForSystem(systemType);\n        // allow settings provider to store the change\n        await this._unitFormattingSettingsProvider?.storeUnitSystemSetting({ system: systemType });\n        // fire current event\n        this.onActiveFormattingUnitSystemChanged.emit({ system: systemType });\n        if (IModelApp.toolAdmin && restartActiveTool)\n            return IModelApp.toolAdmin.startDefaultTool();\n    }\n    /** Retrieve the active [[UnitSystemKey]] which is used to determine what formats are to be used to display quantities */\n    get activeUnitSystem() { return this._activeUnitSystem; }\n    /** Clear any formatting override for specified quantity type, but only for the \"active\" Unit System. */\n    async clearOverrideFormats(type) {\n        await this.clearOverrideFormatsByQuantityTypeKey(this.getQuantityTypeKey(type));\n    }\n    /** Set formatting override for specified quantity type, but only for the \"active\" Unit System. */\n    async setOverrideFormats(type, overrideEntry) {\n        await this.setOverrideFormatsByQuantityTypeKey(this.getQuantityTypeKey(type), overrideEntry);\n    }\n    /** Set Override Format for a quantity type, but only in the \"active\" Unit System. */\n    async setOverrideFormat(type, overrideFormat) {\n        const typeKey = this.getQuantityTypeKey(type);\n        let overrideEntry = {};\n        if (this.activeUnitSystem === \"imperial\")\n            overrideEntry = { imperial: overrideFormat };\n        else if (this.activeUnitSystem === \"metric\")\n            overrideEntry = { metric: overrideFormat };\n        else if (this.activeUnitSystem === \"usCustomary\")\n            overrideEntry = { usCustomary: overrideFormat };\n        else\n            overrideEntry = { usSurvey: overrideFormat };\n        await this.setOverrideFormatsByQuantityTypeKey(typeKey, overrideEntry);\n    }\n    /** Clear formatting override for all quantity types, but only for the \"active\" Unit System. */\n    async clearAllOverrideFormats() {\n        if (0 === this._overrideFormatPropsByUnitSystem.size)\n            return;\n        if (this._overrideFormatPropsByUnitSystem.has(this.activeUnitSystem)) {\n            const overrides = this._overrideFormatPropsByUnitSystem.get(this.activeUnitSystem);\n            const typesRemoved = [];\n            if (overrides && overrides.size) {\n                const promises = new Array();\n                overrides.forEach((_props, typeKey) => {\n                    typesRemoved.push(typeKey);\n                    promises.push(this._unitFormattingSettingsProvider?.storeFormatOverrides({ typeKey, unitSystem: this.activeUnitSystem }));\n                });\n                await Promise.all(promises);\n            }\n            if (typesRemoved.length) {\n                const promises = new Array();\n                typesRemoved.forEach((typeRemoved) => promises.push(this.loadDefaultFormatAndParserSpecForQuantity(typeRemoved)));\n                await Promise.all(promises);\n                // trigger a message to let callers know the format has changed.\n                this.onQuantityFormatsChanged.emit({ quantityType: typesRemoved.join(\"|\") });\n            }\n        }\n    }\n    /** Converts a QuantityTypeArg into a QuantityTypeKey/string value that can be used to lookup custom and standard quantity types. */\n    getQuantityTypeKey(type) {\n        return getQuantityTypeKey(type);\n    }\n    /** Return [[QuantityTypeDefinition]] if type has been registered. Standard QuantityTypes are automatically registered. */\n    getQuantityDefinition(type) {\n        return this.quantityTypesRegistry.get(this.getQuantityTypeKey(type));\n    }\n    /** Synchronous call to get a FormatterSpec of a QuantityType. If the FormatterSpec is not yet cached an undefined object is returned. The\n     * cache is populated by the async call loadFormatAndParsingMapsForSystem.\n     */\n    findFormatterSpecByQuantityType(type, _unused) {\n        return this._activeFormatSpecsByType.get(this.getQuantityTypeKey(type));\n    }\n    /** Asynchronous Call to get a FormatterSpec for a QuantityType. This formatter spec can be used to synchronously format quantities. */\n    async generateFormatterSpecByType(type, formatProps) {\n        const quantityTypeDefinition = this.quantityTypesRegistry.get(this.getQuantityTypeKey(type));\n        if (quantityTypeDefinition)\n            return quantityTypeDefinition.generateFormatterSpec(formatProps, this.unitsProvider);\n        throw new Error(`Unable to generate FormatSpec for QuantityType ${type}`);\n    }\n    /** Asynchronous Call to get a FormatterSpec for a QuantityType and a Unit System. This formatter spec can be used to synchronously format quantities.\n     * @param type        One of the built-in quantity types supported.\n     * @param system      Requested unit system key. Note it is more efficient to use setActiveUnitSystem to set up formatters for all\n     * quantity types of a unit system.\n     * @return A FormatterSpec Promise.\n     */\n    async getFormatterSpecByQuantityTypeAndSystem(type, system) {\n        const quantityKey = this.getQuantityTypeKey(type);\n        const requestedSystem = system ?? this.activeUnitSystem;\n        if (requestedSystem === this.activeUnitSystem) {\n            const formatterSpec = this._activeFormatSpecsByType.get(quantityKey);\n            if (formatterSpec)\n                return formatterSpec;\n        }\n        const entry = this.quantityTypesRegistry.get(quantityKey);\n        if (!entry)\n            throw new Error(`Unable to find registered quantity type with key ${quantityKey}`);\n        return entry.generateFormatterSpec(this.getFormatPropsByQuantityTypeEntryAndSystem(entry, requestedSystem), this.unitsProvider);\n    }\n    /** Asynchronous Call to get a FormatterSpec for a QuantityType.\n     * @param type        One of the built-in quantity types supported.\n     * @param isImperial  Argument to specify use of imperial or metric unit system. If left undefined the active unit system is used.\n     * @return A FormatterSpec Promise.\n     */\n    async getFormatterSpecByQuantityType(type, isImperial) {\n        let requestedSystem = this.activeUnitSystem;\n        if (undefined !== isImperial)\n            requestedSystem = isImperial ? \"imperial\" : \"metric\";\n        return this.getFormatterSpecByQuantityTypeAndSystem(type, requestedSystem);\n    }\n    /** Synchronous call to get a ParserSpec for a QuantityType. If the ParserSpec is not yet cached an undefined object is returned. The\n     * cache is populated when the active units system is set.\n     */\n    findParserSpecByQuantityType(type) {\n        return this._activeParserSpecsByType.get(this.getQuantityTypeKey(type));\n    }\n    /** Asynchronous Call to get a ParserSpec for a QuantityType. If the UnitSystemKey is not specified the active Unit System is used. **/\n    async getParserSpecByQuantityTypeAndSystem(type, system) {\n        const quantityKey = this.getQuantityTypeKey(type);\n        const requestedSystem = system ?? this.activeUnitSystem;\n        if (requestedSystem === this.activeUnitSystem) {\n            const parserSpec = this._activeParserSpecsByType.get(quantityKey);\n            if (parserSpec)\n                return parserSpec;\n        }\n        const entry = this.quantityTypesRegistry.get(quantityKey);\n        if (!entry)\n            throw new Error(`Unable to find registered quantity type with key ${quantityKey}`);\n        return entry.generateParserSpec(this.getFormatPropsByQuantityTypeEntryAndSystem(entry, requestedSystem), this.unitsProvider);\n    }\n    /** Asynchronous Call to get a ParserSpec for a QuantityType.\n     * @param type        One of the built-in quantity types supported.\n     * @param isImperial  Argument to specify use of imperial or metric unit system. If left undefined the active unit system is used.\n     * @return A FormatterSpec Promise.\n     */\n    async getParserSpecByQuantityType(type, isImperial) {\n        let requestedSystem = this.activeUnitSystem;\n        if (undefined !== isImperial)\n            requestedSystem = isImperial ? \"imperial\" : \"metric\";\n        return this.getParserSpecByQuantityTypeAndSystem(type, requestedSystem);\n    }\n    /** Generates a formatted string for a quantity given its format spec.\n     * @param magnitude       The magnitude of the quantity.\n     * @param formatSpec      The format specification. See methods getFormatterSpecByQuantityType and findFormatterSpecByQuantityType.\n     * @return the formatted string.\n     */\n    formatQuantity(magnitude, formatSpec) {\n        /** Format a quantity value. Default FormatterSpec implementation uses Formatter.formatQuantity. */\n        if (formatSpec)\n            return formatSpec.applyFormatting(magnitude);\n        return magnitude.toString();\n    }\n    /** Parse input string into quantity given the ParserSpec\n     * @param inString       The magnitude of the quantity.\n     * @param parserSpec     The parse specification the defines the expected format of the string and the conversion to the output unit.\n     * @return QuantityParseResult object containing either the parsed value or an error value if unsuccessful.\n     */\n    parseToQuantityValue(inString, parserSpec) {\n        if (parserSpec)\n            return parserSpec.parseToQuantityValue(inString);\n        return { ok: false, error: ParseError.InvalidParserSpec };\n    }\n    /**\n     * Get a UnitSystemKey from a string that may have been entered via a key-in. Supports different variation of\n     * unit system names that have been used in the past.\n     */\n    getUnitSystemFromString(inputSystem, fallback) {\n        switch (inputSystem.toLowerCase()) {\n            case \"metric\":\n            case \"si\":\n                return \"metric\";\n            case \"imperial\":\n            case \"british-imperial\":\n                return \"imperial\";\n            case \"uscustomary\":\n            case \"us-customary\":\n            case \"us\":\n                return \"usCustomary\";\n            case \"ussurvey\":\n            case \"us-survey\":\n            case \"survey\":\n                return \"usSurvey\";\n            default:\n                if (undefined !== fallback)\n                    return fallback;\n                break;\n        }\n        return \"imperial\";\n    }\n    /** Return true if the QuantityType is using an override format. */\n    hasActiveOverride(type, checkOnlyActiveUnitSystem) {\n        const quantityTypeKey = this.getQuantityTypeKey(type);\n        if (checkOnlyActiveUnitSystem) {\n            const overrides = this._overrideFormatPropsByUnitSystem.get(this.activeUnitSystem);\n            if (overrides && overrides.has(quantityTypeKey))\n                return true;\n            return false;\n        }\n        for (const [_key, overrideMap] of this._overrideFormatPropsByUnitSystem) {\n            if (overrideMap.has(quantityTypeKey))\n                return true;\n        }\n        return false;\n    }\n    /** Get the cached FormatProps give a quantity type. If ignoreOverrides is false then if the format has been overridden\n     * the overridden format is returned, else the standard format is returned.\n     */\n    getFormatPropsByQuantityType(quantityType, requestedSystem, ignoreOverrides) {\n        const quantityEntry = this.quantityTypesRegistry.get(this.getQuantityTypeKey(quantityType));\n        if (quantityEntry)\n            return this.getFormatPropsByQuantityTypeEntryAndSystem(quantityEntry, requestedSystem ?? this.activeUnitSystem, ignoreOverrides);\n        return undefined;\n    }\n    // keep following to maintain existing API of implementing UnitsProvider\n    /** Find [UnitProp] for a specific unit label. */\n    async findUnit(unitLabel, schemaName, phenomenon, unitSystem) {\n        return this._unitsProvider.findUnit(unitLabel, schemaName, phenomenon, unitSystem);\n    }\n    /** Returns all defined units for the specified Unit Family/Phenomenon. */\n    async getUnitsByFamily(phenomenon) {\n        return this._unitsProvider.getUnitsByFamily(phenomenon);\n    }\n    /** Find [UnitProp] for a specific unit name. */\n    async findUnitByName(unitName) {\n        return this._unitsProvider.findUnitByName(unitName);\n    }\n    /** Returns data needed to convert from one Unit to another in the same Unit Family/Phenomenon. */\n    async getConversion(fromUnit, toUnit) {\n        return this._unitsProvider.getConversion(fromUnit, toUnit);\n    }\n}\n// ========================================================================================================================================\n// Default Data\n// ========================================================================================================================================\nconst DEFAULT_FORMATKEY_BY_UNIT_SYSTEM = [\n    {\n        system: \"metric\",\n        entries: [\n            { type: getQuantityTypeKey(QuantityType.Length), formatKey: \"[units:length]meter4\" },\n            { type: getQuantityTypeKey(QuantityType.Angle), formatKey: \"[units:angle]degree2\" },\n            { type: getQuantityTypeKey(QuantityType.Area), formatKey: \"[units:area]mSquared4\" },\n            { type: getQuantityTypeKey(QuantityType.Volume), formatKey: \"[units:volume]mCubed4\" },\n            { type: getQuantityTypeKey(QuantityType.LatLong), formatKey: \"[units:angle]dms\" },\n            { type: getQuantityTypeKey(QuantityType.Coordinate), formatKey: \"[units:length]meter2\" },\n            { type: getQuantityTypeKey(QuantityType.Stationing), formatKey: \"[units:length]m-sta2\" },\n            { type: getQuantityTypeKey(QuantityType.LengthSurvey), formatKey: \"[units:length]meter4\" },\n            { type: getQuantityTypeKey(QuantityType.LengthEngineering), formatKey: \"[units:length]meter4\" },\n        ],\n    },\n    {\n        system: \"imperial\",\n        entries: [\n            { type: getQuantityTypeKey(QuantityType.Length), formatKey: \"[units:length]fi8\" },\n            { type: getQuantityTypeKey(QuantityType.Angle), formatKey: \"[units:angle]dms2\" },\n            { type: getQuantityTypeKey(QuantityType.Area), formatKey: \"[units:area]fSquared4\" },\n            { type: getQuantityTypeKey(QuantityType.Volume), formatKey: \"[units:volume]fCubed4\" },\n            { type: getQuantityTypeKey(QuantityType.LatLong), formatKey: \"[units:angle]dms\" },\n            { type: getQuantityTypeKey(QuantityType.Coordinate), formatKey: \"[units:length]feet2\" },\n            { type: getQuantityTypeKey(QuantityType.Stationing), formatKey: \"[units:length]f-sta2\" },\n            { type: getQuantityTypeKey(QuantityType.LengthSurvey), formatKey: \"[units:length]f-survey-4-labeled\" },\n            { type: getQuantityTypeKey(QuantityType.LengthEngineering), formatKey: \"[units:length]feet4\" },\n        ],\n    },\n    {\n        system: \"usCustomary\",\n        entries: [\n            { type: getQuantityTypeKey(QuantityType.Length), formatKey: \"[units:length]fi8\" },\n            { type: getQuantityTypeKey(QuantityType.Angle), formatKey: \"[units:angle]dms2\" },\n            { type: getQuantityTypeKey(QuantityType.Area), formatKey: \"[units:area]fSquared4\" },\n            { type: getQuantityTypeKey(QuantityType.Volume), formatKey: \"[units:volume]fCubed4\" },\n            { type: getQuantityTypeKey(QuantityType.LatLong), formatKey: \"[units:angle]dms\" },\n            { type: getQuantityTypeKey(QuantityType.Coordinate), formatKey: \"[units:length]feet2\" },\n            { type: getQuantityTypeKey(QuantityType.Stationing), formatKey: \"[units:length]f-sta2\" },\n            { type: getQuantityTypeKey(QuantityType.LengthSurvey), formatKey: \"[units:length]f-survey-4\" },\n            { type: getQuantityTypeKey(QuantityType.LengthEngineering), formatKey: \"[units:length]feet4\" },\n        ],\n    },\n    {\n        system: \"usSurvey\",\n        entries: [\n            { type: getQuantityTypeKey(QuantityType.Length), formatKey: \"[units:length]f-survey-4\" },\n            { type: getQuantityTypeKey(QuantityType.Angle), formatKey: \"[units:angle]dms2\" },\n            { type: getQuantityTypeKey(QuantityType.Area), formatKey: \"[units:area]usSurveyFtSquared4\" },\n            { type: getQuantityTypeKey(QuantityType.Volume), formatKey: \"[units:volume]usSurveyFtCubed4\" },\n            { type: getQuantityTypeKey(QuantityType.LatLong), formatKey: \"[units:angle]dms\" },\n            { type: getQuantityTypeKey(QuantityType.Coordinate), formatKey: \"[units:length]f-survey-2\" },\n            { type: getQuantityTypeKey(QuantityType.Stationing), formatKey: \"[units:length]f-survey-sta2\" },\n            { type: getQuantityTypeKey(QuantityType.LengthSurvey), formatKey: \"[units:length]f-survey-4\" },\n            { type: getQuantityTypeKey(QuantityType.LengthEngineering), formatKey: \"[units:length]f-survey-4\" },\n        ],\n    },\n];\n/** List of default format definitions used by the Standard QuantityTypes. */\nconst DEFAULT_FORMATPROPS = [\n    {\n        key: \"[units:length]meter4\",\n        description: \"meters (labeled) 4 decimal places\",\n        format: {\n            composite: {\n                includeZero: true,\n                spacer: \"\",\n                units: [{ label: \"m\", name: \"Units.M\" }],\n            },\n            formatTraits: [\"keepSingleZero\", \"showUnitLabel\"],\n            precision: 4,\n            type: \"Decimal\",\n        },\n    },\n    {\n        key: \"[units:length]meter2\",\n        description: \"meters (labeled) 2 decimal places\",\n        format: {\n            composite: {\n                includeZero: true,\n                spacer: \"\",\n                units: [{ label: \"m\", name: \"Units.M\" }],\n            },\n            formatTraits: [\"keepSingleZero\", \"showUnitLabel\"],\n            precision: 2,\n            type: \"Decimal\",\n        },\n    },\n    {\n        key: \"[units:length]feet4\",\n        description: \"feet (labeled) 4 decimal places\",\n        format: {\n            composite: {\n                includeZero: true,\n                spacer: \"\",\n                units: [{ label: \"ft\", name: \"Units.FT\" }],\n            },\n            formatTraits: [\"keepSingleZero\", \"showUnitLabel\"],\n            precision: 4,\n            type: \"Decimal\",\n        },\n    },\n    {\n        key: \"[units:length]feet2\",\n        description: \"feet (labeled) 2 decimal places\",\n        format: {\n            composite: {\n                includeZero: true,\n                spacer: \"\",\n                units: [{ label: \"ft\", name: \"Units.FT\" }],\n            },\n            formatTraits: [\"keepSingleZero\", \"showUnitLabel\"],\n            precision: 2,\n            type: \"Decimal\",\n        },\n    },\n    {\n        key: \"[units:length]fi8\",\n        description: \"feet-inch 1/8 (labeled)\",\n        format: {\n            composite: {\n                includeZero: true,\n                spacer: \"-\",\n                units: [{ label: \"'\", name: \"Units.FT\" }, { label: \"\\\"\", name: \"Units.IN\" }],\n            },\n            formatTraits: [\"keepSingleZero\", \"showUnitLabel\"],\n            precision: 8,\n            type: \"Fractional\",\n            uomSeparator: \"\",\n        },\n    },\n    {\n        key: \"[units:length]f-sta2\",\n        description: \"stationing feet-2 decimal places \",\n        format: {\n            composite: {\n                includeZero: true,\n                spacer: \"\",\n                units: [{ label: \"ft\", name: \"Units.FT\" }],\n            },\n            formatTraits: [\"trailZeroes\", \"keepSingleZero\"],\n            stationOffsetSize: 2,\n            precision: 2,\n            type: \"Station\",\n        },\n    },\n    {\n        key: \"[units:length]f-survey-sta2\",\n        description: \"stationing feet-2 decimal places \",\n        format: {\n            composite: {\n                includeZero: true,\n                spacer: \"\",\n                units: [{ label: \"ft\", name: \"Units.US_SURVEY_FT\" }],\n            },\n            formatTraits: [\"trailZeroes\", \"keepSingleZero\"],\n            stationOffsetSize: 2,\n            precision: 2,\n            type: \"Station\",\n        },\n    },\n    {\n        key: \"[units:length]m-sta2\",\n        description: \"stationing meters-2 decimal places \",\n        format: {\n            composite: {\n                includeZero: true,\n                spacer: \"\",\n                units: [{ label: \"m\", name: \"Units.M\" }],\n            },\n            formatTraits: [\"trailZeroes\", \"keepSingleZero\"],\n            stationOffsetSize: 3,\n            precision: 2,\n            type: \"Station\",\n        },\n    },\n    {\n        key: \"[units:length]f-survey-2\",\n        description: \"survey feet (labeled)-2 decimal places \",\n        format: {\n            composite: {\n                includeZero: true,\n                spacer: \"\",\n                units: [{ label: \"ft\", name: \"Units.US_SURVEY_FT\" }],\n            },\n            formatTraits: [\"keepSingleZero\", \"showUnitLabel\"],\n            precision: 2,\n            type: \"Decimal\",\n        },\n    },\n    {\n        key: \"[units:length]f-survey-4-labeled\",\n        description: \"survey feet (labeled)-4 decimal places \",\n        format: {\n            composite: {\n                includeZero: true,\n                spacer: \"\",\n                units: [{ label: \"ft (US Survey)\", name: \"Units.US_SURVEY_FT\" }],\n            },\n            formatTraits: [\"keepSingleZero\", \"showUnitLabel\"],\n            precision: 4,\n            type: \"Decimal\",\n        },\n    },\n    {\n        key: \"[units:length]f-survey-4\",\n        description: \"survey feet (labeled)-4 decimal places \",\n        format: {\n            composite: {\n                includeZero: true,\n                spacer: \"\",\n                units: [{ label: \"ft\", name: \"Units.US_SURVEY_FT\" }],\n            },\n            formatTraits: [\"keepSingleZero\", \"showUnitLabel\"],\n            precision: 4,\n            type: \"Decimal\",\n        },\n    },\n    {\n        key: \"[units:angle]degree2\",\n        description: \"degrees (labeled) 2 decimal places\",\n        format: {\n            composite: {\n                includeZero: true,\n                spacer: \"\",\n                units: [{ label: \"°\", name: \"Units.ARC_DEG\" }],\n            },\n            formatTraits: [\"keepSingleZero\", \"showUnitLabel\"],\n            precision: 2,\n            type: \"Decimal\",\n            uomSeparator: \"\",\n        },\n    },\n    {\n        key: \"[units:angle]dms\",\n        description: \"degrees minutes seconds (labeled) 0 decimal places\",\n        format: {\n            composite: {\n                includeZero: true,\n                spacer: \"\",\n                units: [{ label: \"°\", name: \"Units.ARC_DEG\" }, { label: \"'\", name: \"Units.ARC_MINUTE\" }, { label: \"\\\"\", name: \"Units.ARC_SECOND\" }],\n            },\n            formatTraits: [\"keepSingleZero\", \"showUnitLabel\"],\n            precision: 4,\n            type: \"Decimal\",\n            uomSeparator: \"\",\n        },\n    },\n    {\n        key: \"[units:angle]dms2\",\n        description: \"degrees minutes seconds (labeled) 2 decimal places\",\n        format: {\n            composite: {\n                includeZero: true,\n                spacer: \"\",\n                units: [{ label: \"°\", name: \"Units.ARC_DEG\" }, { label: \"'\", name: \"Units.ARC_MINUTE\" }, { label: \"\\\"\", name: \"Units.ARC_SECOND\" }],\n            },\n            formatTraits: [\"keepSingleZero\", \"showUnitLabel\"],\n            precision: 2,\n            type: \"Decimal\",\n            uomSeparator: \"\",\n        },\n    },\n    {\n        key: \"[units:area]mSquared4\",\n        description: \"square meters (labeled) 4 decimal places\",\n        format: {\n            composite: {\n                includeZero: true,\n                spacer: \"\",\n                units: [{ label: \"m²\", name: \"Units.SQ_M\" }],\n            },\n            formatTraits: [\"keepSingleZero\", \"showUnitLabel\"],\n            precision: 4,\n            type: \"Decimal\",\n        },\n    },\n    {\n        key: \"[units:area]fSquared4\",\n        description: \"square feet (labeled) 4 decimal places\",\n        format: {\n            composite: {\n                includeZero: true,\n                spacer: \"\",\n                units: [{ label: \"ft²\", name: \"Units.SQ_FT\" }],\n            },\n            formatTraits: [\"keepSingleZero\", \"showUnitLabel\"],\n            precision: 4,\n            type: \"Decimal\",\n        },\n    },\n    {\n        key: \"[units:area]usSurveyFtSquared4\",\n        description: \"square survey feet (labeled) 4 decimal places\",\n        format: {\n            composite: {\n                includeZero: true,\n                spacer: \"\",\n                units: [{ label: \"ft²\", name: \"Units.SQ_US_SURVEY_FT\" }],\n            },\n            formatTraits: [\"keepSingleZero\", \"showUnitLabel\"],\n            precision: 4,\n            type: \"Decimal\",\n        },\n    },\n    {\n        key: \"[units:volume]mCubed4\",\n        description: \"cubic meters (labeled) 4 decimal places\",\n        format: {\n            composite: {\n                includeZero: true,\n                spacer: \"\",\n                units: [{ label: \"m³\", name: \"Units.CUB_M\" }],\n            },\n            formatTraits: [\"keepSingleZero\", \"showUnitLabel\"],\n            precision: 4,\n            type: \"Decimal\",\n        },\n    },\n    {\n        key: \"[units:volume]fCubed4\",\n        description: \"cubic feet (labeled) 4 decimal places\",\n        format: {\n            composite: {\n                includeZero: true,\n                spacer: \"\",\n                units: [{ label: \"ft³\", name: \"Units.CUB_FT\" }],\n            },\n            formatTraits: [\"keepSingleZero\", \"showUnitLabel\"],\n            precision: 4,\n            type: \"Decimal\",\n        },\n    },\n    {\n        key: \"[units:volume]usSurveyFtCubed4\",\n        description: \"cubic survey feet (labeled) 4 decimal places\",\n        format: {\n            composite: {\n                includeZero: true,\n                spacer: \"\",\n                units: [{ label: \"ft³\", name: \"Units.CUB_US_SURVEY_FT\" }],\n            },\n            formatTraits: [\"keepSingleZero\", \"showUnitLabel\"],\n            precision: 4,\n            type: \"Decimal\",\n        },\n    },\n];\n//# sourceMappingURL=QuantityFormatter.js.map",
      "start": 1693508119388,
      "end": 1693508119592,
      "sourcemaps": null
    }
  ]
}
