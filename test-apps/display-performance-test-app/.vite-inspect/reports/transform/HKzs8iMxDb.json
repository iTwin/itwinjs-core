{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/Primitive.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { assert, dispose } from \"@itwin/core-bentley\";\nimport { PrimitiveVisibility } from \"../RenderTarget\";\nimport { LUTGeometry, SkySphereViewportQuadGeometry } from \"./CachedGeometry\";\nimport { DrawParams, PrimitiveCommand } from \"./DrawCommand\";\nimport { Graphic } from \"./Graphic\";\nimport { InstanceBuffers, InstancedGeometry, isInstancedGraphicParams, PatternBuffers } from \"./InstancedGeometry\";\nimport { System } from \"./System\";\n/** @internal */\nexport class Primitive extends Graphic {\n    constructor(cachedGeom) {\n        super();\n        this.isPixelMode = false;\n        this.cachedGeometry = cachedGeom;\n    }\n    static create(geom, instances) {\n        if (!geom)\n            return undefined;\n        if (instances) {\n            assert(geom instanceof LUTGeometry, \"Invalid geometry type for instancing\");\n            if (instances instanceof PatternBuffers) {\n                geom = InstancedGeometry.createPattern(geom, true, instances);\n            }\n            else {\n                assert(isInstancedGraphicParams(instances));\n                const range = InstanceBuffers.computeRange(geom.computeRange(), instances.transforms, instances.transformCenter);\n                const instanceBuffers = InstanceBuffers.create(instances, range);\n                if (!instanceBuffers)\n                    return undefined;\n                geom = InstancedGeometry.create(geom, true, instanceBuffers);\n            }\n        }\n        return new this(geom);\n    }\n    static createShared(geom, instances) {\n        if (!geom)\n            return undefined;\n        if (instances) {\n            assert(geom instanceof LUTGeometry, \"Invalid geometry type for instancing\");\n            if (instances instanceof InstanceBuffers)\n                geom = InstancedGeometry.create(geom, false, instances);\n            else\n                geom = InstancedGeometry.createPattern(geom, false, instances);\n        }\n        return new this(geom);\n    }\n    get isDisposed() { return this.cachedGeometry.isDisposed; }\n    get isPickable() { return false; }\n    dispose() {\n        dispose(this.cachedGeometry);\n    }\n    collectStatistics(stats) {\n        this.cachedGeometry.collectStatistics(stats);\n    }\n    getPass(target) {\n        if (this.isPixelMode)\n            return \"view-overlay\";\n        switch (target.primitiveVisibility) {\n            case PrimitiveVisibility.Uninstanced:\n                if (this.cachedGeometry.isInstanced)\n                    return \"none\";\n                break;\n            case PrimitiveVisibility.Instanced:\n                if (!this.cachedGeometry.isInstanced)\n                    return \"none\";\n                break;\n        }\n        return this.cachedGeometry.getPass(target);\n    }\n    get hasFeatures() { return this.cachedGeometry.hasFeatures; }\n    addCommands(commands) { commands.addPrimitive(this); }\n    addHiliteCommands(commands, pass) {\n        // Edges do not contribute to hilite pass.\n        // Note that IsEdge() does not imply geom->ToEdge() => true...polylines can be edges too...\n        if (!this.isEdge)\n            commands.getCommands(pass).push(new PrimitiveCommand(this));\n    }\n    get hasAnimation() { return this.cachedGeometry.hasAnimation; }\n    get isInstanced() { return this.cachedGeometry.isInstanced; }\n    get isLit() { return this.cachedGeometry.isLitSurface; }\n    get isEdge() { return this.cachedGeometry.isEdge; }\n    get renderOrder() { return this.cachedGeometry.renderOrder; }\n    get hasMaterialAtlas() { return this.cachedGeometry.hasMaterialAtlas; }\n    toPrimitive() { return this; }\n    static freeParams() { Primitive._drawParams = undefined; }\n    draw(shader) {\n        // ###TODO: local to world should be pushed before we're invoked...we shouldn't need to pass (or copy) it\n        if (undefined === Primitive._drawParams)\n            Primitive._drawParams = new DrawParams();\n        const drawParams = Primitive._drawParams;\n        drawParams.init(shader.params, this.cachedGeometry);\n        shader.draw(drawParams);\n    }\n    get techniqueId() { return this.cachedGeometry.techniqueId; }\n}\n/** @internal */\nexport class SkyCubePrimitive extends Primitive {\n    constructor(cachedGeom) { super(cachedGeom); }\n    draw(shader) {\n        // Alter viewport to maintain square aspect ratio of skybox images even as viewRect resizes\n        const vh = shader.target.viewRect.height;\n        const vw = shader.target.viewRect.width;\n        if (vw > vh)\n            System.instance.context.viewport(0, -(vw - vh) / 2, vw, vw);\n        else\n            System.instance.context.viewport(-(vh - vw) / 2, 0, vh, vh);\n        super.draw(shader); // Draw the skybox cubemap\n        System.instance.context.viewport(0, 0, vw, vh); // Restore viewport\n    }\n}\n/** @internal */\nexport class SkySpherePrimitive extends Primitive {\n    constructor(cachedGeom) {\n        super(cachedGeom);\n        assert(cachedGeom instanceof SkySphereViewportQuadGeometry);\n    }\n    draw(shader) {\n        this.cachedGeometry.initWorldPos(shader.target);\n        super.draw(shader); // Draw the skybox sphere\n    }\n}\n//# sourceMappingURL=Primitive.js.map",
      "start": 1693508121160,
      "end": 1693508121413,
      "sourcemaps": null
    }
  ]
}
