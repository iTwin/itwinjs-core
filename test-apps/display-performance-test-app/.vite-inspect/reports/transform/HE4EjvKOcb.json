{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/HitDetail.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module LocatingElements\n */\nimport { assert, Id64 } from \"@itwin/core-bentley\";\nimport { Arc3d, LineSegment3d, LineString3d, Path, Point3d } from \"@itwin/core-geometry\";\nimport { LinePixels } from \"@itwin/core-common\";\nimport { IModelApp } from \"./IModelApp\";\nimport { GraphicType } from \"./render/GraphicBuilder\";\nimport { IconSprites } from \"./Sprites\";\n/**\n * @public\n * @extensions\n */\nexport var SnapMode;\n(function (SnapMode) {\n    SnapMode[SnapMode[\"Nearest\"] = 1] = \"Nearest\";\n    SnapMode[SnapMode[\"NearestKeypoint\"] = 2] = \"NearestKeypoint\";\n    SnapMode[SnapMode[\"MidPoint\"] = 4] = \"MidPoint\";\n    SnapMode[SnapMode[\"Center\"] = 8] = \"Center\";\n    SnapMode[SnapMode[\"Origin\"] = 16] = \"Origin\";\n    SnapMode[SnapMode[\"Bisector\"] = 32] = \"Bisector\";\n    SnapMode[SnapMode[\"Intersection\"] = 64] = \"Intersection\";\n})(SnapMode || (SnapMode = {}));\n/**\n * @public\n * @extensions\n */\nexport var SnapHeat;\n(function (SnapHeat) {\n    SnapHeat[SnapHeat[\"None\"] = 0] = \"None\";\n    SnapHeat[SnapHeat[\"NotInRange\"] = 1] = \"NotInRange\";\n    SnapHeat[SnapHeat[\"InRange\"] = 2] = \"InRange\";\n})(SnapHeat || (SnapHeat = {}));\n/** The procedure that generated this Hit.\n * @public\n * @extensions\n */\nexport var HitSource;\n(function (HitSource) {\n    HitSource[HitSource[\"None\"] = 0] = \"None\";\n    HitSource[HitSource[\"FromUser\"] = 1] = \"FromUser\";\n    HitSource[HitSource[\"MotionLocate\"] = 2] = \"MotionLocate\";\n    HitSource[HitSource[\"AccuSnap\"] = 3] = \"AccuSnap\";\n    HitSource[HitSource[\"TentativeSnap\"] = 4] = \"TentativeSnap\";\n    HitSource[HitSource[\"DataPoint\"] = 5] = \"DataPoint\";\n    HitSource[HitSource[\"Application\"] = 6] = \"Application\";\n    HitSource[HitSource[\"EditAction\"] = 7] = \"EditAction\";\n    HitSource[HitSource[\"EditActionSS\"] = 8] = \"EditActionSS\";\n})(HitSource || (HitSource = {}));\n/** What was being tested to generate this hit. This is not the element or\n * GeometricPrimitive that generated the Hit, it is an indication of whether it is an edge or interior hit.\n * @public\n * @extensions\n */\nexport var HitGeomType;\n(function (HitGeomType) {\n    HitGeomType[HitGeomType[\"None\"] = 0] = \"None\";\n    HitGeomType[HitGeomType[\"Point\"] = 1] = \"Point\";\n    HitGeomType[HitGeomType[\"Segment\"] = 2] = \"Segment\";\n    HitGeomType[HitGeomType[\"Curve\"] = 3] = \"Curve\";\n    HitGeomType[HitGeomType[\"Arc\"] = 4] = \"Arc\";\n    HitGeomType[HitGeomType[\"Surface\"] = 5] = \"Surface\";\n})(HitGeomType || (HitGeomType = {}));\n/** Classification of GeometricPrimitive that generated the Hit.\n * @public\n * @extensions\n */\nexport var HitParentGeomType;\n(function (HitParentGeomType) {\n    HitParentGeomType[HitParentGeomType[\"None\"] = 0] = \"None\";\n    HitParentGeomType[HitParentGeomType[\"Wire\"] = 1] = \"Wire\";\n    HitParentGeomType[HitParentGeomType[\"Sheet\"] = 2] = \"Sheet\";\n    HitParentGeomType[HitParentGeomType[\"Solid\"] = 3] = \"Solid\";\n    HitParentGeomType[HitParentGeomType[\"Mesh\"] = 4] = \"Mesh\";\n    HitParentGeomType[HitParentGeomType[\"Text\"] = 5] = \"Text\";\n})(HitParentGeomType || (HitParentGeomType = {}));\n/**\n * @public\n * @extensions\n */\nexport var HitPriority;\n(function (HitPriority) {\n    HitPriority[HitPriority[\"WireEdge\"] = 0] = \"WireEdge\";\n    HitPriority[HitPriority[\"PlanarEdge\"] = 1] = \"PlanarEdge\";\n    HitPriority[HitPriority[\"NonPlanarEdge\"] = 2] = \"NonPlanarEdge\";\n    HitPriority[HitPriority[\"SilhouetteEdge\"] = 3] = \"SilhouetteEdge\";\n    HitPriority[HitPriority[\"PlanarSurface\"] = 4] = \"PlanarSurface\";\n    HitPriority[HitPriority[\"NonPlanarSurface\"] = 5] = \"NonPlanarSurface\";\n    HitPriority[HitPriority[\"Unknown\"] = 6] = \"Unknown\";\n})(HitPriority || (HitPriority = {}));\n/**\n * @public\n * @extensions\n */\nexport var HitDetailType;\n(function (HitDetailType) {\n    HitDetailType[HitDetailType[\"Hit\"] = 1] = \"Hit\";\n    HitDetailType[HitDetailType[\"Snap\"] = 2] = \"Snap\";\n    HitDetailType[HitDetailType[\"Intersection\"] = 3] = \"Intersection\";\n})(HitDetailType || (HitDetailType = {}));\n/** A HitDetail stores the result when locating geometry displayed in a view.\n * It holds an approximate location on an element (or decoration) from a *pick*.\n * @public\n * @extensions\n */\nexport class HitDetail {\n    /** The point in world coordinates that was used as the initial locate point. */\n    get testPoint() { return this._props.testPoint; }\n    /** The viewport in which the locate operation was performed. */\n    get viewport() { return this._props.viewport; }\n    /** The procedure that requested the locate operation. */\n    get hitSource() { return this._props.hitSource; }\n    /** The approximate location in world coordinates on the geometry identified by this HitDetail. */\n    get hitPoint() { return this._props.hitPoint; }\n    /** The source of the geometry. This may be a persistent element Id, or a transient Id used for, e.g., pickable decorations. */\n    get sourceId() { return this._props.sourceId; }\n    /** The hit geometry priority/classification. */\n    get priority() { return this._props.priority; }\n    /** The xy distance to the hit in view coordinates. */\n    get distXY() { return this._props.distXY; }\n    /** The distance in view coordinates between the hit and the near plane. */\n    get distFraction() { return this._props.distFraction; }\n    /** The [SubCategory]($backend) to which the hit geometry belongs. */\n    get subCategoryId() { return this._props.subCategoryId; }\n    /** The class of the hit geometry. */\n    get geometryClass() { return this._props.geometryClass; }\n    /** The Id of the [[ModelState]] from which the hit originated. */\n    get modelId() { return this._props.modelId; }\n    /** The IModelConnection from which the hit originated.\n     * This should almost always be left undefined, unless the hit is known to have originated from an iModel\n     * other than the one associated with the viewport.\n     * @internal\n     */\n    get sourceIModel() { return this._props.sourceIModel; }\n    /** @internal chiefly for debugging */\n    get tileId() { return this._props.tileId; }\n    /** True if the hit originated from a reality model classifier.\n     * @alpha\n     */\n    get isClassifier() { return this._props.isClassifier; }\n    /** Information about the [ViewAttachment]($backend) within which the hit geometry resides, if any.\n     * @note Only [[SheetViewState]]s can have view attachments.\n     * @beta\n     */\n    get viewAttachment() { return this._props.viewAttachment; }\n    /** @internal */\n    constructor(arg0, viewport, hitSource, hitPoint, sourceId, priority, distXY, distFraction, subCategoryId, geometryClass, modelId, sourceIModel, tileId, isClassifier) {\n        if (arg0 instanceof Point3d) {\n            assert(undefined !== viewport && undefined !== hitSource && undefined !== hitPoint && undefined !== sourceId);\n            assert(undefined !== priority && undefined !== distXY && undefined !== distFraction);\n            this._props = {\n                testPoint: arg0,\n                viewport,\n                hitSource,\n                hitPoint,\n                sourceId,\n                priority,\n                distXY,\n                distFraction,\n                subCategoryId,\n                geometryClass,\n                modelId,\n                sourceIModel,\n                tileId,\n                isClassifier,\n            };\n        }\n        else {\n            // Tempting to use { ...arg0 } but spread operator omits getters so, e.g., if input is a HitDetail we would lose all the properties.\n            this._props = {\n                testPoint: arg0.testPoint,\n                viewport: arg0.viewport,\n                hitSource: arg0.hitSource,\n                hitPoint: arg0.hitPoint,\n                sourceId: arg0.sourceId,\n                priority: arg0.priority,\n                distXY: arg0.distXY,\n                distFraction: arg0.distFraction,\n                subCategoryId: arg0.subCategoryId,\n                geometryClass: arg0.geometryClass,\n                modelId: arg0.modelId,\n                sourceIModel: arg0.sourceIModel,\n                tileId: arg0.tileId,\n                isClassifier: arg0.isClassifier,\n                viewAttachment: arg0.viewAttachment,\n            };\n        }\n    }\n    /** Get the type of HitDetail.\n     * @returns HitDetailType.Hit if this is a HitDetail, HitDetailType.Snap if it is a SnapDetail\n     */\n    getHitType() { return HitDetailType.Hit; }\n    /** Get the *hit point* for this HitDetail. Returns the approximate point on the element that caused the hit when not a SnapDetail or IntersectDetail.\n     * For a snap that is *hot*, the *exact* point on the Element for the snap mode is returned, otherwise the close point on the hit geometry is returned.\n     */\n    getPoint() { return this.hitPoint; }\n    /** Determine if this HitPoint is from the same source as another HitDetail. */\n    isSameHit(otherHit) { return (undefined !== otherHit && this.sourceId === otherHit.sourceId && this.iModel === otherHit.iModel); }\n    /** Return whether sourceId is for a persistent element and not a pickable decoration. */\n    get isElementHit() { return !Id64.isInvalid(this.sourceId) && !Id64.isTransient(this.sourceId); }\n    // return whether the sourceId is for a model (reality models etc.)\n    get isModelHit() {\n        return this.modelId === this.sourceId;\n    }\n    // return whether the hit point is from map.\n    get isMapHit() { return 0 !== this.viewport.mapLayerFromHit(this).length; }\n    /** Create a deep copy of this HitDetail */\n    clone() {\n        return new HitDetail(this);\n    }\n    /** Draw this HitDetail as a Decoration. Causes the picked element to *flash* */\n    draw(_context) {\n        this.viewport.flashedId = this.sourceId;\n    }\n    /** Get the tooltip content for this HitDetail. */\n    async getToolTip() {\n        let toolTipPromise = this.isElementHit ? IModelApp.viewManager.overrideElementToolTip(this) : IModelApp.viewManager.getDecorationToolTip(this);\n        for (const toolTipProvider of IModelApp.viewManager.toolTipProviders)\n            toolTipPromise = toolTipProvider.augmentToolTip(this, toolTipPromise);\n        return toolTipPromise;\n    }\n    /** The IModelConnection from which the hit originated. In some cases this may not be the same as the iModel associated with the Viewport -\n     * for example, if a [[TiledGraphicsProvider]] is used to display graphics from a different iModel in the viewport.\n     * This HitDetail's element, subcategory, and model Ids are defined in the context of this IModelConnection.\n     */\n    get iModel() {\n        return this.sourceIModel ?? this.viewport.iModel;\n    }\n    /** Returns true if this hit originated from an [[IModelConnection]] other than the one associated with the [[Viewport]].\n     * @see [[iModel]].\n     */\n    get isExternalIModelHit() {\n        return this.iModel !== this.viewport.iModel;\n    }\n}\n/** A SnapDetail is generated from the result of a snap request. In addition to the HitDetail about the reason the element was *picked*,\n * it holds the *exact* point on the element from the snapping logic, plus additional information that varies with the type of element and snap mode.\n * @public\n * @extensions\n */\nexport class SnapDetail extends HitDetail {\n    /** Constructor for SnapDetail.\n     * @param from The HitDetail that created this snap\n     * @param snapMode The SnapMode used to create this SnapDetail\n     * @param heat The SnapHeat of this SnapDetail\n     * @param snapPoint The snapped point in the element\n     */\n    constructor(from, snapMode = SnapMode.Nearest, heat = SnapHeat.None, snapPoint) {\n        super(from);\n        this.snapMode = snapMode;\n        this.heat = heat;\n        this.snapPoint = Point3d.fromJSON(snapPoint ? snapPoint : from.hitPoint);\n        this.adjustedPoint = this.snapPoint.clone();\n        this.sprite = IconSprites.getSpriteFromUrl(SnapDetail.getSnapSpriteUrl(snapMode));\n    }\n    /** Returns `HitDetailType.Snap` */\n    getHitType() { return HitDetailType.Snap; }\n    /** Get the snap point if this SnapDetail is *hot*, the pick point otherwise. */\n    getPoint() { return this.isHot ? this.snapPoint : super.getPoint(); }\n    /** Return true if the pick point was closer than the snap aperture from the generated snap point. */\n    get isHot() { return this.heat !== SnapHeat.None; }\n    /** Determine whether the [[adjustedPoint]] is different than the [[snapPoint]]. This happens, for example, when points are adjusted for grids, acs plane snap, and AccuDraw. */\n    get isPointAdjusted() { return !this.adjustedPoint.isExactEqual(this.snapPoint); }\n    /** Change the snap point. */\n    setSnapPoint(point, heat) {\n        this.snapPoint.setFrom(point);\n        this.adjustedPoint.setFrom(point);\n        this.heat = heat;\n    }\n    /** Set curve primitive and HitGeometryType for this SnapDetail. */\n    setCurvePrimitive(primitive, localToWorld, geomType) {\n        this.primitive = primitive;\n        this.geomType = undefined;\n        // Only HitGeomType.Point and HitGeomType.Surface are valid without a curve primitive.\n        if (undefined === this.primitive) {\n            if (HitGeomType.Point === geomType || HitGeomType.Surface === geomType)\n                this.geomType = geomType;\n            return;\n        }\n        if (undefined !== localToWorld)\n            this.primitive.tryTransformInPlace(localToWorld);\n        if (this.primitive instanceof Arc3d)\n            this.geomType = HitGeomType.Arc;\n        else if (this.primitive instanceof LineSegment3d)\n            this.geomType = HitGeomType.Segment;\n        else if (this.primitive instanceof LineString3d)\n            this.geomType = HitGeomType.Segment;\n        else\n            this.geomType = HitGeomType.Curve;\n        // Set curve primitive geometry type override...\n        //  - HitGeomType.Point with arc/ellipse denotes center.\n        //  - HitGeomType.Surface with any curve primitive denotes an interior hit.\n        if (undefined !== geomType && HitGeomType.None !== geomType)\n            this.geomType = geomType;\n    }\n    /** Make a copy of this SnapDetail. */\n    clone() {\n        const val = new SnapDetail(this, this.snapMode, this.heat, this.snapPoint);\n        val.sprite = this.sprite;\n        val.geomType = this.geomType;\n        val.parentGeomType = this.parentGeomType;\n        val.adjustedPoint.setFrom(this.adjustedPoint);\n        if (undefined !== this.primitive)\n            val.primitive = this.primitive.clone();\n        if (undefined !== this.normal)\n            val.normal = this.normal.clone();\n        return val;\n    }\n    getCurvePrimitive(singleSegment = true) {\n        if (!singleSegment || undefined === this.primitive)\n            return this.primitive;\n        if (this.primitive instanceof LineString3d) {\n            const ls = this.primitive;\n            if (ls.points.length > 2) {\n                const loc = ls.closestPoint(this.snapPoint, false);\n                const nSegments = ls.points.length - 1;\n                const uSegRange = (1.0 / nSegments);\n                let segmentNo = Math.floor(loc.fraction / uSegRange);\n                if (segmentNo >= nSegments)\n                    segmentNo = nSegments - 1;\n                return LineSegment3d.create(ls.points[segmentNo], ls.points[segmentNo + 1]);\n            }\n        }\n        return this.primitive;\n    }\n    draw(context) {\n        if (undefined !== this.primitive) {\n            let singleSegment = false;\n            switch (this.snapMode) {\n                case SnapMode.Center:\n                case SnapMode.Origin:\n                case SnapMode.Bisector:\n                    break; // Snap point for these is computed using entire linestring, not just the hit segment...\n                default: {\n                    singleSegment = true;\n                    break;\n                }\n            }\n            const builder = context.createGraphicBuilder(GraphicType.WorldOverlay);\n            const outline = context.viewport.hilite.color.adjustedForContrast(context.viewport.view.backgroundColor, 50);\n            const centerLine = context.viewport.hilite.color.adjustedForContrast(outline, 175);\n            const path = Path.create(this.getCurvePrimitive(singleSegment));\n            builder.setSymbology(outline, outline, 6);\n            builder.addPath(path);\n            builder.setSymbology(centerLine, centerLine, 2);\n            builder.addPath(path);\n            context.addDecorationFromBuilder(builder);\n            return;\n        }\n        super.draw(context);\n    }\n    static getSnapSpriteUrl(snapType) {\n        switch (snapType) {\n            case SnapMode.Nearest: return `${IModelApp.publicPath}sprites/SnapPointOn.png`;\n            case SnapMode.NearestKeypoint: return `${IModelApp.publicPath}sprites/SnapKeypoint.png`;\n            case SnapMode.MidPoint: return `${IModelApp.publicPath}sprites/SnapMidpoint.png`;\n            case SnapMode.Center: return `${IModelApp.publicPath}sprites/SnapCenter.png`;\n            case SnapMode.Origin: return `${IModelApp.publicPath}sprites/SnapOrigin.png`;\n            case SnapMode.Bisector: return `${IModelApp.publicPath}sprites/SnapBisector.png`;\n            case SnapMode.Intersection: return `${IModelApp.publicPath}sprites/SnapIntersection.png`;\n        }\n        return \"\";\n    }\n}\n/**\n * @public\n * @extensions\n */\nexport class IntersectDetail extends SnapDetail {\n    constructor(from, heat = SnapHeat.None, snapPoint, otherPrimitive, otherId) {\n        super(from, SnapMode.Intersection, heat, snapPoint);\n        this.otherPrimitive = otherPrimitive;\n        this.otherId = otherId;\n        this.primitive = from.primitive;\n        this.normal = from.normal; // Preserve normal from primary snap location for AccuDraw smart rotation...\n    }\n    draw(context) {\n        if (undefined !== this.primitive && undefined !== this.otherPrimitive) {\n            const builder = context.createGraphicBuilder(GraphicType.WorldOverlay);\n            const outline = context.viewport.hilite.color.adjustedForContrast(context.viewport.view.backgroundColor, 50);\n            const centerLine = context.viewport.hilite.color.adjustedForContrast(outline, 175);\n            const path1 = Path.create(this.primitive);\n            const path2 = Path.create(this.otherPrimitive);\n            builder.setSymbology(outline, outline, 6);\n            builder.addPath(path1);\n            builder.addPath(path2);\n            builder.setSymbology(centerLine, centerLine, 2);\n            builder.addPath(path1);\n            builder.setSymbology(centerLine, centerLine, 2, LinePixels.Code2);\n            builder.addPath(path2);\n            context.addDecorationFromBuilder(builder);\n            return;\n        }\n        super.draw(context);\n    }\n}\n/** The result of a \"locate\" is a sorted list of objects that satisfied the search criteria (a HitList). Earlier hits in the list\n * are somehow *better* than those later on.\n * @public\n * @extensions\n */\nexport class HitList {\n    constructor() {\n        this.hits = [];\n        this.currHit = -1;\n    }\n    get length() { return this.hits.length; }\n    empty() {\n        this.hits.length = 0;\n        this.currHit = -1;\n    }\n    resetCurrentHit() { this.currHit = -1; }\n    /** Get a hit from a particular index into a HitList\n     * return the requested hit from the HitList or undefined\n     */\n    getHit(hitNum) {\n        if (hitNum < 0)\n            hitNum = this.length - 1;\n        return (hitNum >= this.length) ? undefined : this.hits[hitNum];\n    }\n    /** When setting one or more indices to undefined you must call dropNulls afterwards */\n    setHit(i, p) {\n        if (i < 0 || i >= this.length)\n            return;\n        this.hits[i] = p;\n    }\n    dropNulls() {\n        const hits = this.hits;\n        this.hits = [];\n        for (const hit of hits)\n            this.hits.push(hit);\n    }\n    getNextHit() {\n        this.currHit++;\n        return this.getCurrentHit();\n    }\n    getCurrentHit() { return -1 === this.currHit ? undefined : this.getHit(this.currHit); }\n    setCurrentHit(hit) {\n        this.resetCurrentHit();\n        for (let thisHit; undefined !== (thisHit = this.getNextHit());) {\n            if (thisHit === hit)\n                return;\n        }\n    }\n    /** remove the current hit from the list. */\n    removeCurrentHit() { this.removeHit(this.currHit); }\n    /** remove a hit in the list. */\n    removeHit(hitNum) {\n        if (hitNum < 0) // Support -1 == END\n            hitNum = this.length - 1;\n        if (hitNum <= this.currHit)\n            this.currHit = -1;\n        if (hitNum >= this.length) // Locate calls GetNextHit, which increments currHit, until it goes beyond the end of size of the array.\n            return; // Then Reset call RemoteCurrentHit, which passes in currHit. When it is out of range, we do nothing.\n        this.hits.splice(hitNum, 1);\n    }\n    /** search through list and remove any hits that contain a specified element id. */\n    removeHitsFrom(sourceId) {\n        let removedOne = false;\n        // walk backwards through list so we don't have to worry about what happens on remove\n        for (let i = this.length - 1; i >= 0; i--) {\n            const thisHit = this.hits[i];\n            if (thisHit && sourceId === thisHit.sourceId) {\n                removedOne = true;\n                this.removeHit(i);\n            }\n        }\n        return removedOne;\n    }\n    getPriorityZOverride(priority) {\n        switch (priority) {\n            case HitPriority.WireEdge:\n            case HitPriority.PlanarEdge:\n            case HitPriority.NonPlanarEdge:\n                return 0;\n            case HitPriority.SilhouetteEdge:\n                return 1;\n            case HitPriority.PlanarSurface:\n            case HitPriority.NonPlanarSurface:\n                return 2;\n            default:\n                return 3;\n        }\n    }\n    /** compare two hits for insertion into list. */\n    compare(hit1, hit2) {\n        if (!hit1 || !hit2)\n            return 0;\n        const zOverride1 = this.getPriorityZOverride(hit1.priority);\n        const zOverride2 = this.getPriorityZOverride(hit2.priority);\n        // Prefer edges over surfaces, this is more important than z because we know the edge isn't obscured...\n        if (zOverride1 < zOverride2)\n            return -1;\n        if (zOverride1 > zOverride2)\n            return 1;\n        // Compare xy distance from pick point, prefer hits closer to center...\n        if (hit1.distXY < hit2.distXY)\n            return -1;\n        if (hit1.distXY > hit2.distXY)\n            return 1;\n        // Compare distance fraction, prefer hits closer to eye...\n        if (hit1.distFraction > hit2.distFraction)\n            return -1;\n        if (hit1.distFraction < hit2.distFraction)\n            return 1;\n        // Compare geometry class, prefer path/region hits over surface hits when all else is equal...\n        if (hit1.priority < hit2.priority)\n            return -1;\n        if (hit1.priority > hit2.priority)\n            return 1;\n        return 0;\n    }\n    /** Add a new hit to the list. Hits are sorted according to their priority and distance. */\n    addHit(newHit) {\n        if (0 === this.hits.length) {\n            this.hits.push(newHit);\n            return 0;\n        }\n        let index = 0;\n        for (; index < this.hits.length; ++index) {\n            const oldHit = this.hits[index];\n            const comparison = this.compare(newHit, oldHit);\n            if (comparison < 0)\n                break;\n        }\n        this.hits.splice(index, 0, newHit);\n        return index;\n    }\n    /** Insert a new hit into the list at the supplied index. */\n    insertHit(i, hit) {\n        if (i < 0 || i >= this.length)\n            this.hits.push(hit);\n        else\n            this.hits.splice(i, 0, hit);\n    }\n}\n//# sourceMappingURL=HitDetail.js.map",
      "start": 1693508118990,
      "end": 1693508119172,
      "sourcemaps": null
    }
  ]
}
