{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/glsl/Viewport.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { addRenderPass } from \"./RenderPass\";\nimport { addModelViewMatrix, addProjectionMatrix } from \"./Vertex\";\n/** @internal */\nexport function addViewport(shader) {\n    shader.addUniform(\"u_viewport\", 3 /* VariableType.Vec2 */, (prog) => {\n        prog.addProgramUniform(\"u_viewport\", (uniform, params) => {\n            params.target.uniforms.viewRect.bindDimensions(uniform);\n        });\n    });\n}\n/** @internal */\nexport function addViewportTransformation(shader) {\n    shader.addUniform(\"u_viewportTransformation\", 7 /* VariableType.Mat4 */, (prog) => {\n        prog.addProgramUniform(\"u_viewportTransformation\", (uniform, params) => {\n            params.target.uniforms.viewRect.bindViewportMatrix(uniform);\n        });\n    });\n}\nconst modelToWindowCoordinates = `\r\nvec4 modelToWindowCoordinates(vec4 position, vec4 next, out vec4 clippedMvpPos, out vec3 clippedMvPos) {\r\n  if (kRenderPass_ViewOverlay == u_renderPass || kRenderPass_Background == u_renderPass) {\r\n    vec4 q = MAT_MV * position;\r\n    clippedMvPos = q.xyz;\r\n    q = u_proj * q;\r\n    clippedMvpPos = q;\r\n    q.xyz /= q.w;\r\n    q.xyz = (u_viewportTransformation * vec4(q.xyz, 1.0)).xyz;\r\n    return q;\r\n  }\r\n\r\n  // Negative values are in front of the camera (visible).\r\n  float s_maxZ = -u_frustum.x;            // use -near (front) plane for segment drop test since u_frustum's near & far are pos.\r\n  vec4  q = MAT_MV * position;            // eye coordinates.\r\n  vec4  n = MAT_MV * next;\r\n\r\n  if (q.z > s_maxZ) {\r\n    if (n.z > s_maxZ) {\r\n      clippedMvPos = vec3(0.0, 0.0, 1.0);\r\n      clippedMvpPos = vec4(0.0, 0.0, 1.0, 0.0);\r\n      return vec4(0.0, 0.0, 1.0, 0.0);    // Entire segment behind front clip plane.\r\n    }\r\n\r\n    float t = (s_maxZ - q.z) / (n.z - q.z);\r\n\r\n    q.x += t * (n.x - q.x);\r\n    q.y += t * (n.y - q.y);\r\n    q.z = s_maxZ;                         // q.z + (s_maxZ - q.z) / (n.z - q.z) * (n.z - q.z) = s_maxZ\r\n  }\r\n\r\n  clippedMvPos = q.xyz;\r\n  q = u_proj * q;\r\n  clippedMvpPos = q;\r\n  q.xyz /= q.w;                           // normalized device coords\r\n  q.xyz = (u_viewportTransformation * vec4(q.xyz, 1.0)).xyz; // window coords\r\n  return q;\r\n}\r\n`;\n/** @internal */\nexport function addModelToWindowCoordinates(vert) {\n    addModelViewMatrix(vert);\n    addProjectionMatrix(vert);\n    addViewportTransformation(vert);\n    addRenderPass(vert);\n    vert.addFunction(modelToWindowCoordinates);\n}\n//# sourceMappingURL=Viewport.js.map",
      "start": 1693508125140,
      "end": 1693508125319,
      "sourcemaps": null
    }
  ]
}
