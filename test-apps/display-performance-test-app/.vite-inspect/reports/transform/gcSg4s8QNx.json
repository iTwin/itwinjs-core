{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/DrawingViewState.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Views\n */\nimport { assert, dispose, Id64 } from \"@itwin/core-bentley\";\nimport { Frustum, QueryRowFormat, } from \"@itwin/core-common\";\nimport { Constant, Range3d, Transform } from \"@itwin/core-geometry\";\nimport { CategorySelectorState } from \"./CategorySelectorState\";\nimport { CoordSystem } from \"./CoordSystem\";\nimport { DisplayStyle2dState } from \"./DisplayStyleState\";\nimport { Frustum2d } from \"./Frustum2d\";\nimport { IModelApp } from \"./IModelApp\";\nimport { FeatureSymbology } from \"./render/FeatureSymbology\";\nimport { GraphicBranch } from \"./render/GraphicBranch\";\nimport { MockRender } from \"./render/MockRender\";\nimport { TileGraphicType } from \"./tile/internal\";\nimport { OffScreenViewport } from \"./Viewport\";\nimport { ViewRect } from \"./common/ViewRect\";\nimport { ViewState2d, ViewState3d } from \"./ViewState\";\n/** The information required to instantiate a [[SectionAttachment]]. This information is supplied to DrawingViewState constructor via ViewStateProps.\n * The spatial view is obtained asynchronously in DrawingViewState.load(). The SectionAttachment is created in DrawingViewState.attachToViewport and\n * disposed of in DrawingViewState.detachFromViewport.\n */\nclass SectionAttachmentInfo {\n    get spatialView() { return this._spatialView; }\n    get wantDisplayed() {\n        return this._displaySpatialView || DrawingViewState.alwaysDisplaySpatialView;\n    }\n    constructor(spatialView, drawingToSpatialTransform, displaySpatialView) {\n        this._spatialView = spatialView;\n        this._drawingToSpatialTransform = drawingToSpatialTransform;\n        this._displaySpatialView = displaySpatialView;\n    }\n    static fromJSON(props) {\n        if (!props)\n            return new SectionAttachmentInfo(Id64.invalid, Transform.createIdentity(), false);\n        return new SectionAttachmentInfo(props.spatialView, Transform.fromJSON(props.drawingToSpatialTransform), true === props.displaySpatialView);\n    }\n    toJSON() {\n        if (\"string\" === typeof this._spatialView && !Id64.isValidId64(this._spatialView))\n            return undefined;\n        return {\n            spatialView: (this._spatialView instanceof ViewState3d) ? this._spatialView.id : this._spatialView,\n            drawingToSpatialTransform: this._drawingToSpatialTransform.isIdentity ? undefined : this._drawingToSpatialTransform.toJSON(),\n            displaySpatialView: this._displaySpatialView,\n        };\n    }\n    clone() {\n        return new SectionAttachmentInfo(this._spatialView, this._drawingToSpatialTransform, this._displaySpatialView);\n    }\n    preload(options) {\n        if (!this.wantDisplayed)\n            return;\n        if (this._spatialView instanceof ViewState3d)\n            return;\n        if (!Id64.isValidId64(this._spatialView))\n            return;\n        options.spatialViewId = this._spatialView;\n        options.viewStateLoadProps = {\n            displayStyle: {\n                omitScheduleScriptElementIds: !IModelApp.tileAdmin.enableFrontendScheduleScripts,\n                compressExcludedElementIds: true,\n            },\n        };\n    }\n    async load(iModel) {\n        if (!this.wantDisplayed)\n            return;\n        if (this._spatialView instanceof ViewState3d)\n            return;\n        if (!Id64.isValidId64(this._spatialView))\n            return;\n        const spatialView = await iModel.views.load(this._spatialView);\n        if (spatialView instanceof ViewState3d)\n            this._spatialView = spatialView;\n    }\n    async postload(options, iModel) {\n        let spatialView;\n        if (options.spatialViewProps) {\n            spatialView = await iModel.views.convertViewStatePropsToViewState(options.spatialViewProps);\n        }\n        if (spatialView instanceof ViewState3d)\n            this._spatialView = spatialView;\n    }\n    createAttachment(toSheet) {\n        if (!this.wantDisplayed || !(this._spatialView instanceof ViewState3d))\n            return undefined;\n        const spatialToDrawing = this._drawingToSpatialTransform.inverse();\n        return spatialToDrawing ? new SectionAttachment(this._spatialView, spatialToDrawing, this._drawingToSpatialTransform, toSheet) : undefined;\n    }\n    get sectionDrawingInfo() {\n        return {\n            drawingToSpatialTransform: this._drawingToSpatialTransform,\n            spatialView: this._spatialView instanceof ViewState3d ? this._spatialView.id : this._spatialView,\n        };\n    }\n}\n/** A mostly no-op [[RenderTarget]] for a [[SectionAttachment]]. It allocates no webgl resources. */\nclass SectionTarget extends MockRender.OffScreenTarget {\n    constructor(attachment) {\n        super(IModelApp.renderSystem, new ViewRect(0, 0, 1, 1));\n        this._attachment = attachment;\n    }\n    changeScene(scene) {\n        this._attachment.scene = scene;\n    }\n    overrideFeatureSymbology(ovrs) {\n        this._attachment.symbologyOverrides = ovrs;\n    }\n}\n/** Draws the contents of an orthographic [[ViewState3d]] directly into a [[DrawingViewState]], if the associated [SectionDrawing]($backend)\n * specifies it should be. We select tiles for the view in the context of a lightweight offscreen viewport with a no-op [[RenderTarget]], then\n * add the resultant graphics to the drawing view's scene. The attachment is created in DrawingViewState.attachToViewport and disposed of in\n * DrawingViewState.detachFromViewport.\n */\nclass SectionAttachment {\n    get view() {\n        assert(this.viewport.view instanceof ViewState3d);\n        return this.viewport.view;\n    }\n    get zDepth() {\n        return this._drawingExtents.z;\n    }\n    constructor(view, toDrawing, fromDrawing, toSheet) {\n        this._viewRect = new ViewRect(0, 0, 1, 1);\n        this._originalFrustum = new Frustum();\n        // Save the input for clone(). Attach a copy to the viewport.\n        this._toDrawing = toDrawing;\n        this._fromDrawing = fromDrawing;\n        this.viewport = OffScreenViewport.createViewport(view, new SectionTarget(this), true);\n        this.symbologyOverrides = new FeatureSymbology.Overrides(view);\n        let clipVolume;\n        let clip = this.view.getViewClip();\n        if (clip) {\n            clip = clip.clone();\n            const clipTransform = toSheet ? toSheet.multiplyTransformTransform(this._toDrawing) : this._toDrawing;\n            clip.transformInPlace(clipTransform);\n            clipVolume = IModelApp.renderSystem.createClipVolume(clip);\n        }\n        this._branchOptions = {\n            clipVolume,\n            hline: view.getDisplayStyle3d().settings.hiddenLineSettings,\n            frustum: {\n                is3d: true,\n                scale: { x: 1, y: 1 },\n            },\n        };\n        this._viewFlagOverrides = { ...view.viewFlags, lighting: false, shadows: false };\n        this._drawingExtents = this.viewport.viewingSpace.viewDelta.clone();\n        this._toDrawing.multiplyVector(this._drawingExtents, this._drawingExtents);\n        this._drawingExtents.z = Math.abs(this._drawingExtents.z);\n        // Save off the original frustum (potentially adjusted by viewport).\n        this.viewport.setupFromView();\n        this.viewport.viewingSpace.getFrustum(CoordSystem.World, true, this._originalFrustum);\n    }\n    dispose() {\n        this.viewport.dispose();\n    }\n    addToScene(context) {\n        if (context.viewport.freezeScene)\n            return;\n        const pixelSize = context.viewport.getPixelSizeAtPoint();\n        if (0 === pixelSize)\n            return;\n        // Adjust offscreen viewport's frustum based on intersection with drawing view frustum.\n        const frustum3d = this._originalFrustum.transformBy(this._toDrawing);\n        const frustumRange3d = frustum3d.toRange();\n        const frustum2d = context.viewport.getWorldFrustum();\n        const frustumRange2d = frustum2d.toRange();\n        const intersect = frustumRange3d.intersect(frustumRange2d);\n        if (intersect.isNull)\n            return;\n        frustum3d.initFromRange(intersect);\n        frustum3d.transformBy(this._fromDrawing, frustum3d);\n        this.viewport.setupViewFromFrustum(frustum3d);\n        // Adjust view rect based on size of attachment on screen so tiles of appropriate LOD are selected.\n        const width = this._drawingExtents.x * intersect.xLength() / frustumRange3d.xLength();\n        const height = this._drawingExtents.y * intersect.yLength() / frustumRange3d.yLength();\n        this._viewRect.width = Math.max(1, Math.round(width / pixelSize));\n        this._viewRect.height = Math.max(1, Math.round(height / pixelSize));\n        this.viewport.setRect(this._viewRect);\n        // Propagate settings from drawing viewport.\n        this.viewport.debugBoundingBoxes = context.viewport.debugBoundingBoxes;\n        this.viewport.setTileSizeModifier(context.viewport.tileSizeModifier);\n        // Create the scene.\n        this.viewport.renderFrame();\n        const scene = this.scene;\n        if (!scene)\n            return;\n        // Extract graphics and insert into drawing's scene context.\n        const outputGraphics = (source) => {\n            if (0 === source.length)\n                return;\n            const graphics = new GraphicBranch();\n            graphics.setViewFlagOverrides(this._viewFlagOverrides);\n            graphics.symbologyOverrides = this.symbologyOverrides;\n            for (const graphic of source)\n                graphics.entries.push(graphic);\n            const branch = context.createGraphicBranch(graphics, this._toDrawing, this._branchOptions);\n            context.outputGraphic(branch);\n        };\n        outputGraphics(scene.foreground);\n        context.withGraphicType(TileGraphicType.BackgroundMap, () => outputGraphics(scene.background));\n        context.withGraphicType(TileGraphicType.Overlay, () => outputGraphics(scene.overlay));\n        // Report tile statistics to drawing viewport.\n        const tileAdmin = IModelApp.tileAdmin;\n        const selectedAndReady = tileAdmin.getTilesForUser(this.viewport);\n        const requested = tileAdmin.getRequestsForUser(this.viewport);\n        tileAdmin.addExternalTilesForUser(context.viewport, {\n            requested: requested?.size ?? 0,\n            selected: selectedAndReady?.selected.size ?? 0,\n            ready: selectedAndReady?.ready.size ?? 0,\n        });\n    }\n}\n/** A view of a [DrawingModel]($backend)\n * @public\n * @extensions\n */\nclass DrawingViewState extends ViewState2d {\n    static get className() { return \"DrawingViewDefinition\"; }\n    /** Strictly for testing. @internal */\n    get sectionDrawingProps() {\n        return this._attachmentInfo.toJSON();\n    }\n    /** Strictly for testing. @internal */\n    get sectionDrawingInfo() {\n        return this._attachmentInfo.sectionDrawingInfo;\n    }\n    /** Strictly for testing. @internal */\n    get attachment() {\n        return this._attachment;\n    }\n    /** Strictly for testing. @internal */\n    get attachmentInfo() {\n        return this._attachmentInfo;\n    }\n    constructor(props, iModel, categories, displayStyle, extents, sectionDrawing) {\n        super(props, iModel, categories, displayStyle);\n        if (categories instanceof DrawingViewState) {\n            this._viewedExtents = categories._viewedExtents.clone();\n            this._modelLimits = { ...categories._modelLimits };\n            this._attachmentInfo = categories._attachmentInfo.clone();\n        }\n        else {\n            this._viewedExtents = extents;\n            this._modelLimits = { min: Constant.oneMillimeter, max: 10 * extents.maxLength() };\n            this._attachmentInfo = SectionAttachmentInfo.fromJSON(sectionDrawing);\n        }\n    }\n    /** See [[ViewState.attachToViewport]]. */\n    attachToViewport(args) {\n        super.attachToViewport(args);\n        assert(undefined === this._attachment);\n        this._attachment = this._attachmentInfo.createAttachment(args.drawingToSheetTransform);\n    }\n    /** See [[ViewState.detachFromViewport]]. */\n    detachFromViewport() {\n        super.detachFromViewport();\n        this._attachment = dispose(this._attachment);\n    }\n    /** @internal */\n    async changeViewedModel(modelId) {\n        await super.changeViewedModel(modelId);\n        const props = await this.querySectionDrawingProps();\n        this._attachmentInfo = SectionAttachmentInfo.fromJSON(props);\n        // super.changeViewedModel() throws if attached to viewport, and attachment only allocated while attached to viewport\n        assert(undefined === this._attachment);\n    }\n    async querySectionDrawingProps() {\n        let spatialView = Id64.invalid;\n        let drawingToSpatialTransform;\n        let displaySpatialView = false;\n        try {\n            const ecsql = `\r\n        SELECT spatialView,\r\n          json_extract(jsonProperties, '$.drawingToSpatialTransform') as drawingToSpatialTransform,\r\n          CAST(json_extract(jsonProperties, '$.displaySpatialView') as BOOLEAN) as displaySpatialView\r\n        FROM bis.SectionDrawing\r\n        WHERE ECInstanceId=${this.baseModelId}`;\n            for await (const row of this.iModel.createQueryReader(ecsql, undefined, { rowFormat: QueryRowFormat.UseJsPropertyNames })) {\n                spatialView = Id64.fromJSON(row.spatialView?.id);\n                displaySpatialView = !!row.displaySpatialView;\n                try {\n                    drawingToSpatialTransform = JSON.parse(row.drawingToSpatialTransform);\n                }\n                catch {\n                    // We'll use identity transform.\n                }\n                break;\n            }\n        }\n        catch (_ex) {\n            // The version of BisCore ECSchema in the iModel is probably too old to contain the SectionDrawing ECClass.\n        }\n        return { spatialView, displaySpatialView, drawingToSpatialTransform };\n    }\n    /** @internal */\n    preload(hydrateRequest) {\n        assert(!this.isAttachedToViewport);\n        super.preload(hydrateRequest);\n        this._attachmentInfo.preload(hydrateRequest);\n    }\n    /** @internal */\n    async postload(hydrateResponse) {\n        const promises = [];\n        promises.push(super.postload(hydrateResponse));\n        promises.push(this._attachmentInfo.postload(hydrateResponse, this.iModel));\n        await Promise.all(promises);\n    }\n    static createFromProps(props, iModel) {\n        const cat = new CategorySelectorState(props.categorySelectorProps, iModel);\n        const displayStyleState = new DisplayStyle2dState(props.displayStyleProps, iModel);\n        const extents = props.modelExtents ? Range3d.fromJSON(props.modelExtents) : new Range3d();\n        // use \"new this\" so subclasses are correct\n        return new this(props.viewDefinitionProps, iModel, cat, displayStyleState, extents, props.sectionDrawing);\n    }\n    toProps() {\n        const props = super.toProps();\n        props.modelExtents = this._viewedExtents.toJSON();\n        props.sectionDrawing = this._attachmentInfo.toJSON();\n        return props;\n    }\n    getViewedExtents() {\n        return this._viewedExtents;\n    }\n    get defaultExtentLimits() {\n        return this._modelLimits;\n    }\n    /** @internal */\n    isDrawingView() { return true; }\n    /** See [[ViewState.getOrigin]]. */\n    getOrigin() {\n        const origin = super.getOrigin();\n        if (this._attachment)\n            origin.z = -this._attachment.zDepth;\n        return origin;\n    }\n    /** See [[ViewState.getExtents]]. */\n    getExtents() {\n        const extents = super.getExtents();\n        if (this._attachment)\n            extents.z = this._attachment.zDepth + Frustum2d.minimumZDistance;\n        return extents;\n    }\n    /** @internal */\n    discloseTileTrees(trees) {\n        super.discloseTileTrees(trees);\n        if (this._attachment)\n            trees.disclose(this._attachment.viewport);\n    }\n    /** @internal */\n    createScene(context) {\n        if (!DrawingViewState.hideDrawingGraphics)\n            super.createScene(context);\n        if (this._attachment)\n            this._attachment.addToScene(context);\n    }\n    /** @internal */\n    get areAllTileTreesLoaded() {\n        return super.areAllTileTreesLoaded && (!this._attachment || this._attachment.view.areAllTileTreesLoaded);\n    }\n    /** @internal */\n    get secondaryViewports() {\n        return this._attachment ? [this._attachment.viewport] : super.secondaryViewports;\n    }\n}\n/** Exposed strictly for testing and debugging. Indicates that when loading the view, the spatial view should be displayed even\n * if `SectionDrawing.displaySpatialView` is not `true`.\n * @internal\n */\nDrawingViewState.alwaysDisplaySpatialView = false;\n/** Exposed strictly for testing and debugging. Indicates that the 2d graphics should not be displayed.\n * @internal\n */\nDrawingViewState.hideDrawingGraphics = false;\nexport { DrawingViewState };\n//# sourceMappingURL=DrawingViewState.js.map",
      "start": 1693508118901,
      "end": 1693508119040,
      "sourcemaps": null
    }
  ]
}
