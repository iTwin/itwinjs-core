{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/common/lib/esm/Gradient.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Symbology\n */\nimport { assert } from \"@itwin/core-bentley\";\nimport { Angle } from \"@itwin/core-geometry\";\nimport { ColorDef } from \"./ColorDef\";\nimport { ImageBuffer, ImageBufferFormat } from \"./Image\";\nimport { ThematicGradientColorScheme, ThematicGradientMode, ThematicGradientSettings } from \"./ThematicDisplay\";\n/** Namespace containing types for defining a color gradient, often used for filled planar regions.\n * @see [[GeometryParams]]\n * @see [[GraphicParams]]\n * @public\n */\nexport var Gradient;\n(function (Gradient) {\n    /** Flags applied to a [[Gradient.Symb]]. */\n    let Flags;\n    (function (Flags) {\n        /** No flags. */\n        Flags[Flags[\"None\"] = 0] = \"None\";\n        /** Reverse the order of the gradient keys. */\n        Flags[Flags[\"Invert\"] = 1] = \"Invert\";\n        /** Draw an outline around the surface to which the gradient is applied. */\n        Flags[Flags[\"Outline\"] = 2] = \"Outline\";\n    })(Flags = Gradient.Flags || (Gradient.Flags = {}));\n    /** Enumerates the modes by which a [[Gradient.Symb]]'s keys are applied to create an image. */\n    let Mode;\n    (function (Mode) {\n        Mode[Mode[\"None\"] = 0] = \"None\";\n        Mode[Mode[\"Linear\"] = 1] = \"Linear\";\n        Mode[Mode[\"Curved\"] = 2] = \"Curved\";\n        Mode[Mode[\"Cylindrical\"] = 3] = \"Cylindrical\";\n        Mode[Mode[\"Spherical\"] = 4] = \"Spherical\";\n        Mode[Mode[\"Hemispherical\"] = 5] = \"Hemispherical\";\n        /** For a gradient created based for [[ThematicDisplay]]. */\n        Mode[Mode[\"Thematic\"] = 6] = \"Thematic\";\n    })(Mode = Gradient.Mode || (Gradient.Mode = {}));\n    /** Gradient fraction value to [[ColorDef]] pair\n     * @see [[Gradient.KeyColorProps]]\n     */\n    class KeyColor {\n        constructor(json) {\n            this.value = json.value;\n            this.color = ColorDef.fromJSON(json.color);\n        }\n    }\n    Gradient.KeyColor = KeyColor;\n    /** Compare two KeyColor objects for equality. Returns true if equal. */\n    function keyColorEquals(a, b) {\n        return (a.value === b.value) && a.color.equals(b.color);\n    }\n    Gradient.keyColorEquals = keyColorEquals;\n    /** Multi-color area fill defined by a range of colors that vary by position.\n     * Gradient fill can be applied to planar regions.\n     * @see [[Gradient.SymbProps]]\n     */\n    class Symb {\n        constructor() {\n            this.mode = Mode.None;\n            this.flags = Flags.None;\n            this.shift = 0;\n            this.keys = [];\n        }\n        /** create a GradientSymb from a json object. */\n        static fromJSON(json) {\n            const result = new Symb();\n            if (!json)\n                return result;\n            result.mode = json.mode;\n            result.flags = (json.flags === undefined) ? Flags.None : json.flags;\n            result.angle = json.angle ? Angle.fromJSON(json.angle) : undefined;\n            result.tint = json.tint;\n            result.shift = json.shift ? json.shift : 0;\n            json.keys.forEach((key) => result.keys.push(new KeyColor(key)));\n            result.thematicSettings = (json.thematicSettings === undefined) ? undefined : ThematicGradientSettings.fromJSON(json.thematicSettings);\n            return result;\n        }\n        /** Create for [[ThematicDisplay]]. */\n        static createThematic(settings) {\n            const result = new Symb();\n            result.mode = Mode.Thematic;\n            result.thematicSettings = settings;\n            if (settings.colorScheme < ThematicGradientColorScheme.Custom) {\n                for (const keyValue of Gradient.Symb._fixedSchemeKeys[settings.colorScheme])\n                    result.keys.push(new KeyColor({ value: keyValue[0], color: ColorDef.computeTbgrFromComponents(keyValue[1], keyValue[3], keyValue[2]) }));\n            }\n            else { // custom color scheme; must use custom keys\n                assert(settings.customKeys.length > 1, \"Custom thematic mode requires at least two keys to be defined\");\n                if (settings.customKeys.length > 1) {\n                    settings.customKeys.forEach((keyColor) => result.keys.push(keyColor));\n                }\n                else { // if custom color keys are not specified properly, revert to some basic key scheme and assert\n                    for (const keyValue of Gradient.Symb._fixedCustomKeys)\n                        result.keys.push(new KeyColor({ value: keyValue[0], color: ColorDef.from(keyValue[1], keyValue[3], keyValue[2]).toJSON() }));\n                }\n            }\n            return result;\n        }\n        toJSON() {\n            return {\n                ...this,\n                thematicSettings: this.thematicSettings?.toJSON(),\n                keys: this.keys.map((key) => ({ value: key.value, color: key.color.toJSON() })),\n            };\n        }\n        clone() {\n            return Symb.fromJSON(this.toJSON());\n        }\n        /** Returns true if this symbology is equal to another, false otherwise. */\n        equals(other) {\n            return Symb.compareSymb(this, other) === 0;\n        }\n        /** Compares two gradient symbologies. Used for ordering Gradient.Symb objects.\n         * @param lhs First gradient to compare\n         * @param rhs Second gradient to compare\n         * @returns 0 if lhs is equivalent to rhs, a negative number if lhs compares less than rhs, or a positive number if lhs compares greater than rhs.\n         */\n        static compareSymb(lhs, rhs) {\n            if (lhs === rhs)\n                return 0; // Same pointer\n            if (lhs.mode !== rhs.mode)\n                return lhs.mode - rhs.mode;\n            if (lhs.flags !== rhs.flags)\n                if (lhs.flags === undefined)\n                    return -1;\n                else if (rhs.flags === undefined)\n                    return 1;\n                else\n                    return lhs.flags - rhs.flags;\n            if (lhs.tint !== rhs.tint)\n                if (lhs.tint === undefined)\n                    return -1;\n                else if (rhs.tint === undefined)\n                    return 1;\n                else\n                    return lhs.tint - rhs.tint;\n            if (lhs.shift !== rhs.shift)\n                if (lhs.shift === undefined)\n                    return -1;\n                else if (rhs.shift === undefined)\n                    return 1;\n                else\n                    return lhs.shift - rhs.shift;\n            if ((lhs.angle === undefined) !== (rhs.angle === undefined))\n                if (lhs.angle === undefined)\n                    return -1;\n                else\n                    return 1;\n            if (lhs.angle && !lhs.angle.isAlmostEqualNoPeriodShift(rhs.angle))\n                return lhs.angle.radians - rhs.angle.radians;\n            if (lhs.keys.length !== rhs.keys.length)\n                return lhs.keys.length - rhs.keys.length;\n            for (let i = 0; i < lhs.keys.length; i++) {\n                if (lhs.keys[i].value !== rhs.keys[i].value)\n                    return lhs.keys[i].value - rhs.keys[i].value;\n                if (!lhs.keys[i].color.equals(rhs.keys[i].color))\n                    return lhs.keys[i].color.tbgr - rhs.keys[i].color.tbgr;\n            }\n            if (lhs.thematicSettings !== rhs.thematicSettings)\n                if (undefined === lhs.thematicSettings)\n                    return -1;\n                else if (undefined === rhs.thematicSettings)\n                    return 1;\n                else {\n                    const thematicCompareResult = ThematicGradientSettings.compare(lhs.thematicSettings, rhs.thematicSettings);\n                    if (0 !== thematicCompareResult)\n                        return thematicCompareResult;\n                }\n            return 0;\n        }\n        /** Compare this symbology to another.\n         * @see [[Gradient.Symb.compareSymb]]\n         */\n        compare(other) {\n            return Gradient.Symb.compareSymb(this, other);\n        }\n        /**\n         * Ensure the value given is within the range of 0 to 255,\n         * and truncate the value to only the 8 least significant bits.\n         */\n        roundToByte(num) {\n            return Math.min(num + .5, 255.0) & 0xFF;\n        }\n        /** Maps a value to an RGBA value adjusted from a color present in this symbology's array. */\n        mapColor(value) {\n            if (value < 0)\n                value = 0;\n            else if (value > 1)\n                value = 1;\n            if ((this.flags & Flags.Invert) !== 0)\n                value = 1 - value;\n            let idx = 0;\n            let d;\n            let w0;\n            let w1;\n            if (this.keys.length <= 2) {\n                w0 = 1.0 - value;\n                w1 = value;\n            }\n            else { // locate value in map, blend corresponding colors\n                while (idx < (this.keys.length - 2) && value > this.keys[idx + 1].value)\n                    idx++;\n                d = this.keys[idx + 1].value - this.keys[idx].value;\n                w1 = d < 0.0001 ? 0.0 : (value - this.keys[idx].value) / d;\n                w0 = 1.0 - w1;\n            }\n            const color0 = this.keys[idx].color;\n            const color1 = this.keys[idx + 1].color;\n            const colors0 = color0.colors;\n            const colors1 = color1.colors;\n            const red = w0 * colors0.r + w1 * colors1.r;\n            const green = w0 * colors0.g + w1 * colors1.g;\n            const blue = w0 * colors0.b + w1 * colors1.b;\n            const transparency = w0 * colors0.t + w1 * colors1.t;\n            return ColorDef.from(this.roundToByte(red), this.roundToByte(green), this.roundToByte(blue), this.roundToByte(transparency));\n        }\n        get hasTranslucency() {\n            for (const key of this.keys) {\n                if (!key.color.isOpaque)\n                    return true;\n            }\n            return false;\n        }\n        /** Returns true if the [[Gradient.Flags.Outline]] flag is set. */\n        get isOutlined() { return 0 !== (this.flags & Flags.Outline); }\n        /** This function (for internal use only) provides the WebGL renderer with a thematic image that its shaders\n         * can use properly with various thematic rendering techniques.\n         * If you want a regular gradient image, use the method [[Gradient.Symb.getImage]].\n         * @internal\n         */\n        getThematicImageForRenderer(maxDimension) {\n            assert(Mode.Thematic === this.mode, \"getThematicImageForRenderer only is used for thematic display.\");\n            let settings = this.thematicSettings;\n            if (settings === undefined) {\n                settings = ThematicGradientSettings.defaults;\n            }\n            const stepCount = Math.min(settings.stepCount, maxDimension);\n            const dimension = (ThematicGradientMode.Smooth === settings.mode) ? maxDimension : stepCount;\n            const image = new Uint8Array(1 * dimension * 4);\n            let currentIdx = image.length - 1;\n            function addColor(color) {\n                image[currentIdx--] = color.getAlpha();\n                image[currentIdx--] = color.colors.b;\n                image[currentIdx--] = color.colors.g;\n                image[currentIdx--] = color.colors.r;\n            }\n            switch (settings.mode) {\n                case ThematicGradientMode.Smooth: {\n                    for (let j = 0; j < dimension; j++) {\n                        const f = (1 - j / (dimension));\n                        addColor(this.mapColor(f));\n                    }\n                    break;\n                }\n                case ThematicGradientMode.SteppedWithDelimiter:\n                case ThematicGradientMode.IsoLines:\n                // The work to generate the delimiter lines and isolines is done completely in the shader.\n                // Therefore, we just fall through here and use a regular stepped gradient.\n                case ThematicGradientMode.Stepped: {\n                    assert(settings.stepCount > 1, \"Step count must be at least two to generate renderer gradient for thematic display\");\n                    for (let j = 0; j < dimension; j++) {\n                        // If we use Smooth's approach to generate the gradient...\n                        // We would get these values for stepCount five: 0   .2   .4   .6   .8\n                        //                  We really want these values: 0   .25  .5   .75   1\n                        // This preserves an exact color mapping of a n-step gradient when stepCount also equals n.\n                        // stepCount must be at least two for this.  The thematic API enforces stepCount of at least 2.\n                        const f = (1 - j / (dimension - 1));\n                        addColor(this.mapColor(f));\n                    }\n                    break;\n                }\n            }\n            assert(-1 === currentIdx);\n            const imageBuffer = ImageBuffer.create(image, ImageBufferFormat.Rgba, 1);\n            assert(undefined !== imageBuffer);\n            return imageBuffer;\n        }\n        /** Produces a bitmap image from this gradient.\n         * @param width Width of the image\n         * @param height Height of the image\n         * @note If this gradient uses [[Gradient.Mode.Thematic]], then the width of the image will be 1 and the margin color will be included in the top and bottom rows.\n         * @see [[produceImage]] for more customization.\n         */\n        getImage(width, height) {\n            if (this.mode === Mode.Thematic)\n                width = 1;\n            return this.produceImage({ width, height, includeThematicMargin: true });\n        }\n        /** Produces a bitmap image from this gradient. */\n        produceImage(args) {\n            const { width, height, includeThematicMargin } = { ...args };\n            const thisAngle = (this.angle === undefined) ? 0 : this.angle.radians;\n            const cosA = Math.cos(thisAngle);\n            const sinA = Math.sin(thisAngle);\n            const image = new Uint8Array(width * height * 4);\n            let currentIdx = image.length - 1;\n            const shift = Math.min(1.0, Math.abs(this.shift));\n            switch (this.mode) {\n                case Mode.Linear:\n                case Mode.Cylindrical: {\n                    const xs = 0.5 - 0.25 * shift * cosA;\n                    const ys = 0.5 - 0.25 * shift * sinA;\n                    let dMax;\n                    let dMin = dMax = 0.0;\n                    let d;\n                    for (let j = 0; j < 2; j++) {\n                        for (let i = 0; i < 2; i++) {\n                            d = (i - xs) * cosA + (j - ys) * sinA;\n                            if (d < dMin)\n                                dMin = d;\n                            if (d > dMax)\n                                dMax = d;\n                        }\n                    }\n                    for (let j = 0; j < height; j++) {\n                        const y = j / height - ys;\n                        for (let i = 0; i < width; i++) {\n                            const x = i / width - xs;\n                            d = x * cosA + y * sinA;\n                            let f;\n                            if (this.mode === Mode.Linear) {\n                                if (d > 0)\n                                    f = 0.5 + 0.5 * d / dMax;\n                                else\n                                    f = 0.5 - 0.5 * d / dMin;\n                            }\n                            else {\n                                if (d > 0)\n                                    f = Math.sin(Math.PI / 2 * (1.0 - d / dMax));\n                                else\n                                    f = Math.sin(Math.PI / 2 * (1.0 - d / dMin));\n                            }\n                            const color = this.mapColor(f);\n                            image[currentIdx--] = color.getAlpha();\n                            image[currentIdx--] = color.colors.b;\n                            image[currentIdx--] = color.colors.g;\n                            image[currentIdx--] = color.colors.r;\n                        }\n                    }\n                    break;\n                }\n                case Mode.Curved: {\n                    const xs = 0.5 + 0.5 * sinA - 0.25 * shift * cosA;\n                    const ys = 0.5 - 0.5 * cosA - 0.25 * shift * sinA;\n                    for (let j = 0; j < height; j++) {\n                        const y = j / height - ys;\n                        for (let i = 0; i < width; i++) {\n                            const x = i / width - xs;\n                            const xr = 0.8 * (x * cosA + y * sinA);\n                            const yr = y * cosA - x * sinA;\n                            const f = Math.sin(Math.PI / 2 * (1 - Math.sqrt(xr * xr + yr * yr)));\n                            const color = this.mapColor(f);\n                            image[currentIdx--] = color.getAlpha();\n                            image[currentIdx--] = color.colors.b;\n                            image[currentIdx--] = color.colors.g;\n                            image[currentIdx--] = color.colors.r;\n                        }\n                    }\n                    break;\n                }\n                case Mode.Spherical: {\n                    const r = 0.5 + 0.125 * Math.sin(2.0 * thisAngle);\n                    const xs = 0.5 * shift * (cosA + sinA) * r;\n                    const ys = 0.5 * shift * (sinA - cosA) * r;\n                    for (let j = 0; j < height; j++) {\n                        const y = ys + j / height - 0.5;\n                        for (let i = 0; i < width; i++) {\n                            const x = xs + i / width - 0.5;\n                            const f = Math.sin(Math.PI / 2 * (1.0 - Math.sqrt(x * x + y * y) / r));\n                            const color = this.mapColor(f);\n                            image[currentIdx--] = color.getAlpha();\n                            image[currentIdx--] = color.colors.b;\n                            image[currentIdx--] = color.colors.g;\n                            image[currentIdx--] = color.colors.r;\n                        }\n                    }\n                    break;\n                }\n                case Mode.Hemispherical: {\n                    const xs = 0.5 + 0.5 * sinA - 0.5 * shift * cosA;\n                    const ys = 0.5 - 0.5 * cosA - 0.5 * shift * sinA;\n                    for (let j = 0; j < height; j++) {\n                        const y = j / height - ys;\n                        for (let i = 0; i < width; i++) {\n                            const x = i / width - xs;\n                            const f = Math.sin(Math.PI / 2 * (1.0 - Math.sqrt(x * x + y * y)));\n                            const color = this.mapColor(f);\n                            image[currentIdx--] = color.getAlpha();\n                            image[currentIdx--] = color.colors.b;\n                            image[currentIdx--] = color.colors.g;\n                            image[currentIdx--] = color.colors.r;\n                        }\n                    }\n                    break;\n                }\n                case Mode.Thematic: {\n                    const settings = this.thematicSettings ?? ThematicGradientSettings.defaults;\n                    for (let j = 0; j < height; j++) {\n                        let f = 1 - j / height;\n                        let color;\n                        if (includeThematicMargin && (f < ThematicGradientSettings.margin || f > ThematicGradientSettings.contentMax)) {\n                            color = settings.marginColor;\n                        }\n                        else {\n                            f = (f - ThematicGradientSettings.margin) / (ThematicGradientSettings.contentRange);\n                            switch (settings.mode) {\n                                case ThematicGradientMode.SteppedWithDelimiter:\n                                case ThematicGradientMode.IsoLines:\n                                case ThematicGradientMode.Stepped: {\n                                    if (settings.stepCount > 1) {\n                                        const fStep = Math.floor(f * settings.stepCount - 0.00001) / (settings.stepCount - 1);\n                                        color = this.mapColor(fStep);\n                                    }\n                                    break;\n                                }\n                                case ThematicGradientMode.Smooth:\n                                    color = this.mapColor(f);\n                                    break;\n                            }\n                        }\n                        for (let i = 0; i < width; i++) {\n                            image[currentIdx--] = color.getAlpha();\n                            image[currentIdx--] = color.colors.b;\n                            image[currentIdx--] = color.colors.g;\n                            image[currentIdx--] = color.colors.r;\n                        }\n                    }\n                }\n            }\n            assert(-1 === currentIdx);\n            const imageBuffer = ImageBuffer.create(image, ImageBufferFormat.Rgba, width);\n            assert(undefined !== imageBuffer);\n            return imageBuffer;\n        }\n    }\n    Symb._fixedSchemeKeys = [\n        // NB: these color values are ordered as rbg.  Note how the components are applied below.\n        [[0.0, 0, 255, 0], [0.25, 0, 255, 255], [0.5, 0, 0, 255], [0.75, 255, 0, 255], [1.0, 255, 0, 0]],\n        [[0.0, 255, 0, 0], [0.25, 255, 0, 255], [0.5, 0, 0, 255], [0.75, 0, 255, 255], [1.0, 0, 255, 0]],\n        [[0.0, 0, 0, 0], [1.0, 255, 255, 255]],\n        [[0.0, 152, 148, 188], [0.5, 204, 160, 204], [1.0, 152, 72, 128]],\n        [[0.0, 0, 255, 0], [0.2, 72, 96, 160], [0.4, 152, 96, 160], [0.6, 128, 32, 104], [0.7, 148, 180, 128], [1.0, 240, 240, 240]], // Based off of the sea-mountain gradient in Point Clouds.\n    ];\n    Symb._fixedCustomKeys = [[0.0, 255, 0, 0], [1.0, 0, 255, 0]];\n    Gradient.Symb = Symb;\n})(Gradient || (Gradient = {}));\n//# sourceMappingURL=Gradient.js.map",
      "start": 1693508120607,
      "end": 1693508120684,
      "sourcemaps": null
    }
  ]
}
