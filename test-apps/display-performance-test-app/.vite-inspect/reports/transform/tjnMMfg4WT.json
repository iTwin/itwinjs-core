{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/curve/internalContexts/PolygonOffsetContext.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Curve\n */\nimport { Geometry } from \"../../Geometry\";\nimport { AngleSweep } from \"../../geometry3d/AngleSweep\";\nimport { Point3d, Vector3d } from \"../../geometry3d/Point3dVector3d\";\nimport { Ray3d } from \"../../geometry3d/Ray3d\";\nimport { Arc3d } from \"../Arc3d\";\nimport { CurveCurve } from \"../CurveCurve\";\nimport { CurveCurveApproachType } from \"../CurveLocationDetail\";\nimport { CurvePrimitive } from \"../CurvePrimitive\";\nimport { LineSegment3d } from \"../LineSegment3d\";\nimport { LineString3d } from \"../LineString3d\";\nimport { Loop } from \"../Loop\";\nimport { JointOptions, OffsetOptions } from \"../OffsetOptions\";\nimport { Path } from \"../Path\";\nimport { RegionOps } from \"../RegionOps\";\n// cspell:word CCWXY\n/**\n * Classification of how the joint is constructed.\n * @internal\n */\nvar JointMode;\n(function (JointMode) {\n    JointMode[JointMode[\"Unknown\"] = 0] = \"Unknown\";\n    JointMode[JointMode[\"Cap\"] = 1] = \"Cap\";\n    JointMode[JointMode[\"Extend\"] = 2] = \"Extend\";\n    JointMode[JointMode[\"Trim\"] = -1] = \"Trim\";\n    JointMode[JointMode[\"JustGeometry\"] = 3] = \"JustGeometry\";\n    JointMode[JointMode[\"Gap\"] = 4] = \"Gap\";\n})(JointMode || (JointMode = {}));\n/**\n * Description of geometry around a joint.\n * @internal\n */\nclass Joint {\n    // capture references to all data . . .\n    constructor(curve0, curve1, swingPoint) {\n        this.curve0 = curve0;\n        this.curve1 = curve1;\n        this.swingPoint = swingPoint;\n        this.flexure = JointMode.Unknown;\n    }\n    /**\n     * Try to construct an arc transition from ray0 to ray1 with given center.\n     */\n    static constructArc(ray0, center, ray1) {\n        if (center !== undefined && Geometry.isSameCoordinate(ray0.origin.distance(center), ray1.origin.distance(center))) {\n            const angle = ray0.direction.angleToXY(ray1.direction);\n            const vector0 = Vector3d.createStartEnd(center, ray0.origin);\n            const vector90 = vector0.rotate90CCWXY();\n            return Arc3d.create(center, vector0, vector90, AngleSweep.createStartEndRadians(0.0, angle.radians));\n        }\n        return undefined;\n    }\n    /** Extract a json object of {curve0:data, fraction0:data, curve1:data, fraction1:data} */\n    shallowExtract() {\n        return { curve0: this.curve0, curve1: this.curve1, fraction0: this.fraction0, fraction1: this.fraction1 };\n    }\n    /** Establish the nextJoint and previousJoint links from joint0 to joint1. */\n    static link(joint0, joint1) {\n        joint0.nextJoint = joint1;\n        if (joint1)\n            joint1.previousJoint = joint0;\n        if (joint0.curve1 && joint1 && !joint1.curve0)\n            joint1.curve0 = joint0.curve1;\n        else if (!joint0.curve1 && joint1 && joint1.curve0)\n            joint0.curve1 = joint1.curve0;\n    }\n    /**\n     * * If nextJoint and nextJoint.fraction0 are defined, return them.\n     * * Otherwise return defaultValue\n     */\n    nextJointFraction0(defaultValue) {\n        if (this.nextJoint && this.nextJoint.fraction0 !== undefined)\n            return this.nextJoint.fraction0;\n        return defaultValue;\n    }\n    static addStrokes(destination, curve) {\n        if (curve) {\n            curve.emitStrokes(destination);\n        }\n    }\n    static addPoint(destination, point) {\n        if (destination.packedPoints.length > 0) {\n            const pointA = destination.endPoint();\n            if (!pointA.isAlmostEqual(point))\n                destination.packedPoints.push(point);\n        }\n    }\n    /** Append stroke points along the offset curve defined by the Joint chain to the destination line string. */\n    static collectStrokesFromChain(start, destination, maxTest = 100) {\n        let numOut = -2 * maxTest; // allow extra things to happen\n        Joint.visitJointsOnChain(start, (joint) => {\n            this.addStrokes(destination, joint.jointCurve);\n            if (joint.curve1 && joint.fraction1 !== undefined) {\n                const fA = joint.fraction1;\n                const fB = joint.nextJointFraction0(1.0);\n                let curve1;\n                if (fA === 0.0 && fB === 1.0)\n                    curve1 = joint.curve1.clone();\n                else if (fA < fB)\n                    curve1 = joint.curve1.clonePartialCurve(fA, fB); // trimming is done by clonePartialCurve\n                if (curve1) {\n                    if (!joint.jointCurve) {\n                        this.addPoint(destination, curve1.startPoint());\n                    }\n                }\n                this.addStrokes(destination, curve1);\n            }\n            return numOut++ < maxTest;\n        }, maxTest);\n    }\n    static collectPrimitive(destination, primitive) {\n        if (primitive) {\n            if (destination.length > 0) {\n                const pointA = destination[destination.length - 1].endPoint();\n                const pointB = primitive.startPoint();\n                if (!pointA.isAlmostEqual(pointB)) {\n                    destination.push(LineSegment3d.create(pointA, pointB));\n                }\n            }\n            destination.push(primitive);\n        }\n    }\n    static adjustJointToPrimitives(joint) {\n        const ls = joint.jointCurve;\n        if (ls instanceof LineString3d) {\n            if (joint.curve0) {\n                const curvePoint = joint.curve0.endPoint();\n                const jointPoint0 = ls.startPoint();\n                if (!curvePoint.isAlmostEqual(jointPoint0))\n                    ls.packedPoints.setAtCheckedPointIndex(0, curvePoint);\n            }\n            if (joint.curve1) {\n                const curvePoint = joint.curve1.startPoint();\n                const jointPoint1 = ls.endPoint();\n                if (!curvePoint.isAlmostEqual(jointPoint1))\n                    ls.packedPoints.setAtCheckedPointIndex(ls.packedPoints.length - 1, curvePoint);\n            }\n        }\n    }\n    /** Append CurvePrimitives along the offset curve defined by the Joint chain to the destination array. */\n    static collectCurvesFromChain(start, destination, maxTest = 100) {\n        if (start === undefined)\n            return;\n        let numOut = -2 * maxTest; // allow extra things to happen\n        Joint.visitJointsOnChain(start, (joint) => {\n            this.adjustJointToPrimitives(joint);\n            this.collectPrimitive(destination, joint.jointCurve);\n            if (joint.curve1 && joint.fraction1 !== undefined) {\n                const fA = joint.fraction1;\n                const fB = joint.nextJointFraction0(1.0);\n                let curve1;\n                if (fA === 0.0 && fB === 1.0)\n                    curve1 = joint.curve1.clone();\n                else if (fA < fB)\n                    curve1 = joint.curve1.clonePartialCurve(fA, fB); // trimming is done by clonePartialCurve\n                this.collectPrimitive(destination, curve1);\n            }\n            return numOut++ < maxTest;\n        }, maxTest);\n    }\n    /** Execute `joint.annotateJointMode()` at all joints on the chain to set some of the joints attributes. */\n    static annotateChain(start, options, maxTest = 100) {\n        if (start)\n            Joint.visitJointsOnChain(start, (joint) => { joint.annotateJointMode(options); return true; }, maxTest);\n    }\n    /**\n     * Visit joints on a chain.\n     * * terminate on `false` return from `callback`\n     * @param start first (and, for cyclic chain, final) joint\n     * @param callback function to call with each Joint as a single parameter.\n     */\n    static visitJointsOnChain(start, callback, maxTest = 100) {\n        let joint = start;\n        if (joint) {\n            let numTest = 0;\n            while (joint !== undefined) {\n                if (numTest++ >= maxTest + 5) // allow extra things to happen\n                    return true;\n                if (!callback(joint))\n                    return false;\n                joint = joint.nextJoint;\n                if (joint === start)\n                    break;\n            }\n        }\n        return true;\n    }\n    /** NOTE: no assumption on type of curve0, curve1 */\n    annotateExtension(options) {\n        if (this.curve0 && this.curve1) {\n            const ray0 = this.curve0.fractionToPointAndDerivative(1.0);\n            const ray1 = this.curve1.fractionToPointAndDerivative(0.0);\n            const intersection = Ray3d.closestApproachRay3dRay3d(ray0, ray1); // intersection of the 2 ray lines\n            if (intersection.approachType === CurveCurveApproachType.Intersection) {\n                if (intersection.detailA.fraction >= 0.0 && intersection.detailB.fraction <= 0.0) {\n                    this.fraction0 = 1.0;\n                    this.fraction1 = 0.0;\n                    this.flexure = JointMode.Extend;\n                    const theta = ray0.getDirectionRef().angleToXY(ray1.getDirectionRef()); // angle between the 2 ray lines\n                    if (options.needArc(theta)) {\n                        const arc = Joint.constructArc(ray0, this.curve0.baseCurveEnd, ray1);\n                        if (arc) {\n                            this.jointCurve = arc;\n                            return;\n                        }\n                    }\n                    const numChamferPoints = options.numChamferPoints(theta); // how many interior points in the linestring\n                    if (numChamferPoints <= 1) { // create sharp corner\n                        this.jointCurve = LineString3d.create(ray0.origin, intersection.detailA.point, ray1.origin);\n                        return;\n                    }\n                    if (numChamferPoints > 1) { // create chamfer corner (a line string)\n                        const radians0 = theta.radians;\n                        const numHalfStep = 2.0 * numChamferPoints;\n                        const halfStepRadians = radians0 / numHalfStep;\n                        const arc = Joint.constructArc(ray0, this.curve0.baseCurveEnd, ray1);\n                        if (arc !== undefined) {\n                            const radialFraction = 1 / Math.cos(halfStepRadians);\n                            const jointCurve = LineString3d.create();\n                            this.jointCurve = jointCurve;\n                            jointCurve.addPoint(ray0.origin); // possibly extend segment or line string\n                            for (let i = 0; i < numChamferPoints; i++) {\n                                const arcFraction = (1 + 2 * i) / numHalfStep;\n                                jointCurve.addPoint(arc.fractionAndRadialFractionToPoint(arcFraction, radialFraction));\n                            }\n                            jointCurve.addPoint(ray1.origin); // possibly extend segment or line string.\n                            return;\n                        }\n                    }\n                }\n            }\n            // if there is no intersection between the 2 ray lines, fill the gap by a line segment\n            this.flexure = JointMode.Gap;\n            this.jointCurve = LineSegment3d.create(this.curve0.fractionToPoint(1.0), this.curve1.fractionToPoint(0.0));\n            this.fraction0 = 1.0;\n            this.fraction1 = 0.0;\n        }\n    }\n    /** Select the index at which summed fraction difference is smallest */\n    selectIntersectionIndexByFraction(fractionA, fractionB, intersections) {\n        let index = -1;\n        let aMin = Number.MAX_VALUE;\n        for (let i = 0; i < intersections.length; i++) {\n            const a = Math.abs(intersections[i].detailA.fraction - fractionA)\n                + Math.abs(intersections[i].detailB.fraction - fractionB);\n            if (a < aMin) {\n                aMin = a;\n                index = i;\n            }\n        }\n        return index;\n    }\n    /**\n     * Examine the adjacent geometry to set some of joint attributes:\n     * * set JointMode: one of Cap, Extend, or Trim\n     * * set fraction0 and fraction1 of intersection of curve0 and curve1\n     * * set joint curve\n     * * this REFERENCES curve0, curve1, fraction0, fraction1\n     * * this does not reference nextJoint and previousJoint\n     */\n    annotateJointMode(options) {\n        if (!this.curve0 && this.curve1) { // joint at the start of the chain\n            this.flexure = JointMode.Cap;\n            this.fraction1 = 0.0;\n        }\n        else if (this.curve0 && !this.curve1) { // joint at the end of the chain\n            this.flexure = JointMode.Cap;\n            this.fraction0 = 1.0;\n        }\n        else if (this.curve0 && this.curve1) { // joints at the middle of the chain\n            if (this.curve0.endPoint().isAlmostEqual(this.curve1.startPoint())) { // joint between colinear segments\n                this.fraction0 = 1.0;\n                this.fraction1 = 0.0;\n                this.flexure = JointMode.Trim;\n            }\n            else if (this.curve0 instanceof LineSegment3d && this.curve1 instanceof LineSegment3d) { // pair of lines\n                const ray0 = this.curve0.fractionToPointAndDerivative(0.0);\n                const ray1 = this.curve1.fractionToPointAndDerivative(0.0);\n                const intersection = Ray3d.closestApproachRay3dRay3d(ray0, ray1); // intersection of the 2 ray lines\n                if (intersection.approachType === CurveCurveApproachType.Intersection) {\n                    this.fraction0 = intersection.detailA.fraction;\n                    this.fraction1 = intersection.detailB.fraction;\n                    if (this.fraction0 >= 1.0 && this.fraction1 <= 0.0) { // need to extend\n                        this.annotateExtension(options);\n                    }\n                    else if (this.fraction0 < 1.0 && this.fraction1 > 0.0) { // need to trim\n                        this.flexure = JointMode.Trim;\n                    }\n                    else if (this.fraction0 > 1.0 && this.fraction1 > 1.0) { // need to fill gap with a single line segment\n                        this.flexure = JointMode.Gap;\n                        this.jointCurve = LineSegment3d.create(this.curve0.fractionToPoint(1.0), this.curve1.fractionToPoint(0.0));\n                        this.fraction0 = 1.0;\n                        this.fraction1 = 0.0;\n                    }\n                }\n            }\n            else { // generic pair of curves\n                const intersections = CurveCurve.intersectionXYPairs(this.curve0, false, this.curve1, false);\n                const intersectionIndex = this.selectIntersectionIndexByFraction(1.0, 0.0, intersections);\n                if (intersectionIndex >= 0) { // need to trim\n                    this.flexure = JointMode.Trim;\n                    this.fraction0 = intersections[intersectionIndex].detailA.fraction;\n                    this.fraction1 = intersections[intersectionIndex].detailB.fraction;\n                }\n                else { // need to extend\n                    this.annotateExtension(options);\n                }\n            }\n        }\n    }\n    /**\n     * * Examine the primitive trim fractions between each pair of joints.\n     * * If trim fractions indicate the primitive must disappear, replace the joint pair by a new joint pointing at\n     * surrounding primitives\n     * @param start\n     */\n    static removeDegeneratePrimitives(start, options, maxTest) {\n        /*\n        if (Checker.noisy.PolygonOffset)\n          GeometryCoreTestIO.consoleLog(\"\\nENTER removeDegenerates\");\n        */\n        let jointA = start;\n        let numRemoved = 0;\n        const maxRemove = 1;\n        let numTest = 0;\n        if (jointA) {\n            while (jointA !== undefined && numTest++ < maxTest) {\n                const jointB = jointA.nextJoint;\n                if (jointA\n                    && jointB\n                    && jointA.previousJoint\n                    && jointB.nextJoint\n                    && jointA.fraction1 !== undefined\n                    && jointB.fraction0 !== undefined) {\n                    const f0 = jointA.fraction1;\n                    const f1 = jointB.fraction0;\n                    const g0 = jointB.fraction1;\n                    const g1 = jointB.nextJoint.fraction0;\n                    // f0 and f1 are fractions on the single primitive between these joints.\n                    /*\n                      if (Checker.noisy.PolygonOffset) {\n                        GeometryCoreTestIO.consoleLog(\"joint candidate\");\n                        GeometryCoreTestIO.consoleLog(prettyPrint(jointA.shallowExtract()));\n                        GeometryCoreTestIO.consoleLog(prettyPrint(jointB.shallowExtract()));\n                        GeometryCoreTestIO.consoleLog(\"FRACTIONS \", { fA1: f0, fB0: f1 });\n                      }\n                    */\n                    const eliminateF = f0 >= f1 || f0 > 1.0;\n                    const eliminateG = (g0 !== undefined && g0 > 1.0) || (g0 !== undefined && g1 !== undefined && g0 >= g1);\n                    if (eliminateF && eliminateG) {\n                        const jointC = jointB.nextJoint;\n                        const newJoint = new Joint(jointA.curve0, jointC.curve1, undefined);\n                        Joint.link(jointA.previousJoint, newJoint);\n                        Joint.link(newJoint, jointC.nextJoint);\n                        newJoint.annotateJointMode(options);\n                        newJoint.previousJoint.annotateJointMode(options);\n                        if (newJoint.nextJoint)\n                            newJoint.nextJoint.annotateJointMode(options);\n                        /*\n                        if (Checker.noisy.PolygonOffset) {\n                          GeometryCoreTestIO.consoleLog(\" NEW DOUBLE CUT\");\n                          GeometryCoreTestIO.consoleLog(prettyPrint(newJoint.shallowExtract()));\n                        }\n                        */\n                    }\n                    else if (eliminateF) {\n                        const newJoint = new Joint(jointA.curve0, jointB.curve1, undefined);\n                        Joint.link(jointA.previousJoint, newJoint);\n                        Joint.link(newJoint, jointB.nextJoint);\n                        newJoint.annotateJointMode(options);\n                        newJoint.previousJoint.annotateJointMode(options);\n                        newJoint.nextJoint.annotateJointMode(options);\n                        /*\n                        if (Checker.noisy.PolygonOffset) {\n                          GeometryCoreTestIO.consoleLog(\" NEW JOINT\");\n                          GeometryCoreTestIO.consoleLog(prettyPrint(newJoint.shallowExtract()));\n                        }\n                      */\n                        numRemoved++;\n                        if (jointA === start)\n                            start = newJoint;\n                        jointA = newJoint;\n                        if (numRemoved >= maxRemove) {\n                            /*\n                            if (Checker.noisy.PolygonOffset)\n                              GeometryCoreTestIO.consoleLog(\" EXIT removeDegenerates at maxRemove\\n\");\n                            */\n                            return { newStart: start, numJointRemoved: numRemoved };\n                        }\n                    }\n                }\n                jointA = jointA.nextJoint;\n                if (jointA === start)\n                    break;\n            }\n        }\n        return { newStart: start, numJointRemoved: numRemoved };\n    }\n}\n/**\n * Context for building a wire offset.\n * @internal\n */\nclass PolygonWireOffsetContext {\n    /** Construct a context. */\n    constructor() { }\n    // Construct a single offset from base points\n    static createOffsetSegment(basePointA, basePointB, distance) {\n        Vector3d.createStartEnd(basePointA, basePointB, this._unitAlong);\n        if (this._unitAlong.normalizeInPlace()) {\n            this._unitAlong.rotate90CCWXY(this._unitPerp);\n            const segment = LineSegment3d.create(basePointA.plusScaled(this._unitPerp, distance, this._offsetA), basePointB.plusScaled(this._unitPerp, distance, this._offsetB));\n            CurveChainWireOffsetContext.applyBasePoints(segment, basePointA.clone(), basePointB.clone());\n            return segment;\n        }\n        return undefined;\n    }\n    /**\n     * Construct a wire (not area) that is offset from given polyline or polygon (which must be in xy-plane or in\n     *  a plane parallel to xy-plane).\n     * * This is a simple wire offset (in the form of a line string), not an area.\n     * * If offsetDistance is given as a number, default OffsetOptions are applied.\n     * * See [[JointOptions]] class doc for offset construction rules.\n     * @param points a single loop or path\n     * @param wrap true to offset the wraparound joint. Assumes first = last point.\n     * @param offsetDistanceOrOptions offset distance (positive to left of curve, negative to right) or JointOptions\n     * object.\n     */\n    constructPolygonWireXYOffset(points, wrap, leftOffsetDistanceOrOptions) {\n        /**\n         * if \"wrap = true\", then first and last point in the points array must be close; otherwise\n         * generated offset will be invalid.\n         */\n        if (wrap && !points[0].isAlmostEqual(points[points.length - 1])) {\n            wrap = false;\n        }\n        /** create raw offsets as a linked list (joint0) */\n        const options = JointOptions.create(leftOffsetDistanceOrOptions);\n        const numPoints = points.length;\n        let fragment0 = PolygonWireOffsetContext.createOffsetSegment(points[0], points[1], options.leftOffsetDistance);\n        let joint0 = new Joint(undefined, fragment0, points[0]);\n        let newJoint;\n        let previousJoint = joint0;\n        for (let i = 1; i + 1 < numPoints; i++) {\n            const fragment1 = PolygonWireOffsetContext.createOffsetSegment(points[i], points[i + 1], options.leftOffsetDistance);\n            newJoint = new Joint(fragment0, fragment1, points[i]);\n            Joint.link(previousJoint, newJoint);\n            previousJoint = newJoint;\n            fragment0 = fragment1;\n        }\n        if (wrap)\n            Joint.link(previousJoint, joint0);\n        else {\n            newJoint = new Joint(fragment0, undefined, points[numPoints - 1]);\n            Joint.link(previousJoint, newJoint);\n        }\n        /** annotateChain sets some of the joints attributes (including how to extend curves or fill the gap between curves) */\n        Joint.annotateChain(joint0, options, numPoints);\n        /** make limited passes through the Joint chain until no self-intersections are removed */\n        for (let pass = 0; pass++ < 5;) {\n            const state = Joint.removeDegeneratePrimitives(joint0, options, numPoints);\n            joint0 = state.newStart;\n            if (state.numJointRemoved === 0)\n                break;\n            /*\n            if (Checker.noisy.PolygonOffset) {\n              GeometryCoreTestIO.consoleLog(\"  POST REMOVE DEGENERATES  \" + state.numJointRemoved);\n              Joint.visitJointsOnChain(joint0, (joint: Joint) => { GeometryCoreTestIO.consoleLog(prettyPrint(joint.shallowExtract())); return true; });\n            }\n            */\n        }\n        // Joint.collectPrimitivesFromChain(joint0, result, numPoints);\n        /** turn the Joint linked list into a CurveCollection (Loop or Path). trimming is done in collectStrokesFromChain */\n        const chain = LineString3d.create();\n        Joint.collectStrokesFromChain(joint0, chain, numPoints);\n        const n = chain.packedPoints.length;\n        if (n > 1) {\n            if (chain.packedPoints.front().isAlmostEqual(chain.packedPoints.back()))\n                return Loop.create(chain);\n            else\n                return Path.create(chain);\n        }\n        return undefined;\n    }\n}\nPolygonWireOffsetContext._unitAlong = Vector3d.create();\nPolygonWireOffsetContext._unitPerp = Vector3d.create();\nPolygonWireOffsetContext._offsetA = Point3d.create();\nPolygonWireOffsetContext._offsetB = Point3d.create();\nexport { PolygonWireOffsetContext };\n/**\n * Context for building a wire offset from a Path or Loop of CurvePrimitives\n * @internal\n */\nexport class CurveChainWireOffsetContext {\n    /** construct a context. */\n    constructor() { }\n    /**\n     * Annotate a CurvePrimitive with properties `baseCurveStart` and `baseCurveEnd`.\n     * @param cp curve primitive to annotate\n     * @param startPoint optional start point\n     * @param endPoint optional end point\n     * @return the input CurvePrimitive with annotations\n     */\n    static applyBasePoints(cp, startPoint, endPoint) {\n        if (cp !== undefined) {\n            if (startPoint !== undefined)\n                cp.baseCurveStart = startPoint;\n            if (endPoint !== undefined)\n                cp.baseCurveEnd = endPoint;\n        }\n        return cp;\n    }\n    /**\n     * Create the offset of a single curve primitive as viewed in the xy-plane (ignoring z).\n     * * Each primitive may be labeled (as an `any` object) with start or end point of base curve:\n     *   * `(primitive as any).baseCurveStart: Point3d`\n     *   * `(primitive as any).baseCurveEnd: Point3d`\n     * @param curve primitive to offset\n     * @param offsetDistanceOrOptions offset distance (positive to left of curve, negative to right) or options object\n     */\n    static createSingleOffsetPrimitiveXY(curve, offsetDistanceOrOptions) {\n        const offset = curve.constructOffsetXY(offsetDistanceOrOptions);\n        if (offset === undefined)\n            return undefined;\n        // decorate each offset with its base curve's endpoints\n        if (Array.isArray(offset)) {\n            const basePrims = curve.collectCurvePrimitives(undefined, true, true);\n            if (basePrims.length !== offset.length)\n                return undefined; // unexpected aggregate curve type!\n            for (let i = 0; i < basePrims.length; ++i)\n                this.applyBasePoints(offset[i], basePrims[i].startPoint(), basePrims[i].endPoint());\n            return offset;\n        }\n        return this.applyBasePoints(offset, curve.startPoint(), curve.endPoint());\n    }\n    /**\n     * Construct curves that are offset from a Path or Loop as viewed in xy-plane (ignoring z).\n     * * The construction will remove \"some\" local effects of features smaller than the offset distance, but will\n     * not detect self intersection among widely separated edges.\n     * * Visualization can be found at https://www.itwinjs.org/sandbox/SaeedTorabi/Offset\n     * @param curves base curves.\n     * @param offsetDistanceOrOptions offset distance (positive to left of curve, negative to right) or options object.\n     */\n    static constructCurveXYOffset(curves, offsetDistanceOrOptions) {\n        const wrap = curves instanceof Loop;\n        const offsetOptions = OffsetOptions.create(offsetDistanceOrOptions);\n        const simpleOffsets = [];\n        /** traverse primitives (children of curves) and create simple offsets of each primitive as an array */\n        for (const c of curves.children) {\n            const c1 = CurveChainWireOffsetContext.createSingleOffsetPrimitiveXY(c, offsetOptions);\n            if (c1 === undefined) {\n                // bad .. maybe arc to inside?\n            }\n            else if (c1 instanceof CurvePrimitive) {\n                simpleOffsets.push(c1);\n            }\n            else if (Array.isArray(c1)) {\n                for (const c2 of c1) {\n                    if (c2 instanceof CurvePrimitive)\n                        simpleOffsets.push(c2);\n                }\n            }\n        }\n        /** create joints between array elements to make offsets as a linked list (joint0) */\n        let fragment0;\n        let newJoint;\n        let previousJoint;\n        let joint0;\n        for (const fragment1 of simpleOffsets) {\n            if (fragment1) {\n                newJoint = new Joint(fragment0, fragment1, fragment1.fractionToPoint(0.0));\n                if (newJoint !== undefined)\n                    if (joint0 === undefined)\n                        joint0 = newJoint;\n                if (previousJoint)\n                    Joint.link(previousJoint, newJoint);\n                previousJoint = newJoint;\n                fragment0 = fragment1;\n            }\n        }\n        if (joint0 && previousJoint && curves instanceof Loop)\n            Joint.link(previousJoint, joint0);\n        /** annotateChain sets some of the joints attributes (including how to extend curves or fill the gap between curves) */\n        const numOffset = simpleOffsets.length;\n        Joint.annotateChain(joint0, offsetOptions.jointOptions, numOffset);\n        /** turn the Joint linked list into a CurveCollection. trimming is done in collectCurvesFromChain */\n        const outputCurves = [];\n        Joint.collectCurvesFromChain(joint0, outputCurves, numOffset);\n        return RegionOps.createLoopPathOrBagOfCurves(outputCurves, wrap, true);\n    }\n}\n//# sourceMappingURL=PolygonOffsetContext.js.map",
      "start": 1693508124159,
      "end": 1693508124283,
      "sourcemaps": null
    }
  ]
}
