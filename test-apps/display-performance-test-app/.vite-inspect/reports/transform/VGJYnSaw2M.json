{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/geometry3d/UVSurfaceOps.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module CartesianGeometry\n */\nimport { LineString3d } from \"../curve/LineString3d\";\nimport { StrokeOptions } from \"../curve/StrokeOptions\";\nimport { Geometry } from \"../Geometry\";\nimport { Angle } from \"./Angle\";\nimport { Plane3dByOriginAndVectors } from \"./Plane3dByOriginAndVectors\";\nimport { Point3d } from \"./Point3dVector3d\";\nimport { Range3d } from \"./Range\";\n/**\n * Support methods to act on surfaces with 0..1 uv fractional parameterization\n * @public\n */\nexport class UVSurfaceOps {\n    /** Return the range of sampled points at specified offset from the surface.\n     * * point counts in each direction may be set in the optional `options` structure.\n     * * numU and numV are clamped at (2,500).\n     */\n    static sampledRangeOfOffsetPatch(patch, offsetDistance, numU, numV) {\n        const range = Range3d.createNull();\n        numU = Math.ceil(Geometry.clamp(numU, 2, 500));\n        numV = Math.ceil(Geometry.clamp(numV, 2, 500));\n        const du = 1.0 / numU;\n        const dv = 1.0 / numV;\n        const xyz = Point3d.create();\n        const plane = Plane3dByOriginAndVectors.createXYPlane();\n        let u, v;\n        for (let j = 0; j <= numV; j++) {\n            v = j * dv;\n            for (let i = 0; i <= numU; i++) {\n                u = i * du;\n                if (offsetDistance !== undefined) {\n                    patch.uvFractionToPointAndTangents(u, v, plane);\n                    const unitNormal = plane.unitNormal();\n                    if (unitNormal !== undefined) {\n                        plane.origin.addScaledInPlace(unitNormal, offsetDistance);\n                        range.extend(plane.origin);\n                    }\n                }\n                else {\n                    patch.uvFractionToPoint(u, v, xyz);\n                    range.extendXYZ(xyz.x, xyz.y, xyz.z);\n                }\n            }\n        }\n        return range;\n    }\n    /** Return the range of sampled points at specified offset from the surface.\n   * * point counts in each direction may be set in the optional `options` structure, with angle ranges from the ellipsoid.\n   * * Default evaluation is at 5 degree intervals.\n   */\n    static sampledRangeOfOffsetEllipsoidPatch(patch, offsetDistance, options) {\n        const numU = StrokeOptions.applyAngleTol(options, 2, patch.latitudeSweep.sweepRadians, Angle.degreesToRadians(5.0));\n        const numV = StrokeOptions.applyAngleTol(options, 2, patch.longitudeSweep.sweepRadians, Angle.degreesToRadians(5.0));\n        return this.sampledRangeOfOffsetPatch(patch, offsetDistance, numU, numV);\n    }\n    constructor() { } // private constructor -- no instances.\n    /**\n     * * evaluate `numEdge+1` points at surface uv parameters interpolated between (u0,v0) and (u1,v1)\n     * * accumulate the xyz in a linestring.\n     * * If xyzToUV is given, also accumulate transformed values as surfaceUV\n     * * use xyzToUserUV transform to convert xyz to uv stored in the linestring (this uv is typically different from surface uv -- e.g. torus cap plane coordinates)\n     * @param surface\n     * @param u0 u coordinate at start of parameter space line\n     * @param v0 v coordinate at end of parameter space line\n     * @param u1 u coordinate at start of parameter space line\n     * @param v1 v coordinate at end of parameter space line\n     * @param numEdge number of edges.   (`numEdge+1` points are evaluated)\n     * @param saveUV if true, save each surface uv fractions with `linestring.addUVParamsAsUV (u,v)`\n     * @param saveFraction if true, save each fractional coordinate (along the u,v line) with `linestring.addFraction (fraction)`\n     *\n     * @param xyzToUV\n     */\n    static createLinestringOnUVLine(surface, u0, v0, u1, v1, numEdge, saveUV = false, saveFraction = false) {\n        const ls = LineString3d.create();\n        const xyz = Point3d.create();\n        let fraction, u, v;\n        const numEvaluate = numEdge + 1;\n        for (let i = 0; i < numEvaluate; i++) {\n            fraction = i / numEdge;\n            u = Geometry.interpolate(u0, fraction, u1);\n            v = Geometry.interpolate(v0, fraction, v1);\n            surface.uvFractionToPoint(u, v, xyz);\n            ls.addPoint(xyz);\n            if (saveUV)\n                ls.addUVParamAsUV(u, v);\n            if (saveFraction)\n                ls.addFraction(fraction);\n        }\n        return ls;\n    }\n}\n//# sourceMappingURL=UVSurfaceOps.js.map",
      "start": 1693508122419,
      "end": 1693508122606,
      "sourcemaps": null
    }
  ]
}
