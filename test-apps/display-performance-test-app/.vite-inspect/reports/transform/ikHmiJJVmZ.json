{
  "resolvedId": "D:/hub2023A/itwinjs-core/extensions/frontend-tiles/lib/esm/BatchedSpatialTileTreeRefs.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\nimport { assert } from \"@itwin/core-bentley\";\nimport { TileTreeLoadStatus, TileTreeReference, } from \"@itwin/core-frontend\";\nimport { AnimatedBatchedTileTreeReference, PrimaryBatchedTileTreeReference } from \"./BatchedTileTreeReference\";\nimport { getBatchedTileTreeOwner } from \"./BatchedTileTreeSupplier\";\nimport { BatchedModels } from \"./BatchedModels\";\nimport { createFallbackSpatialTileTreeReferences } from \"./FrontendTiles\";\n// Obtains tiles pre-published by mesh export service.\nclass BatchedSpatialTileTreeReferences {\n    constructor(baseUrl, view) {\n        this._animatedRefs = [];\n        this._view = view;\n        this._models = new BatchedModels(view);\n        const script = view.displayStyle.scheduleScript;\n        this._currentScript = script?.requiresBatching ? script : undefined;\n        this.load(baseUrl, view.iModel);\n        assert(undefined !== this._primaryRef);\n    }\n    load(baseUrl, iModel) {\n        const treeOwner = getBatchedTileTreeOwner(iModel, { baseUrl, script: this._currentScript });\n        this._primaryRef = new PrimaryBatchedTileTreeReference(treeOwner, this._models);\n        this.populateAnimatedReferences(treeOwner);\n        const onScriptChanged = (newScript) => {\n            if (!newScript?.requiresBatching)\n                newScript = undefined;\n            const currentScript = this._currentScript;\n            this._currentScript = newScript;\n            if (newScript !== currentScript)\n                if (!newScript || !currentScript || !newScript.equals(currentScript))\n                    this.load(baseUrl, iModel);\n        };\n        let removeScriptChangedListener = this._view.displayStyle.onScheduleScriptChanged.addListener((newScript) => onScriptChanged(newScript));\n        this._view.onDisplayStyleChanged.addListener((newStyle) => {\n            removeScriptChangedListener();\n            onScriptChanged(newStyle.scheduleScript);\n            removeScriptChangedListener = this._view.displayStyle.onScheduleScriptChanged.addListener((newScript) => onScriptChanged(newScript));\n        });\n    }\n    *[Symbol.iterator]() {\n        yield this._primaryRef;\n        for (const animatedRef of this._animatedRefs)\n            yield animatedRef;\n    }\n    populateAnimatedReferences(treeOwner) {\n        this._animatedRefs.length = 0;\n        const script = this._currentScript;\n        if (!script)\n            return;\n        const getCurrentTimePoint = () => this._view.displayStyle.settings.timePoint ?? script.duration.low;\n        for (const timeline of script.modelTimelines) {\n            const nodeIds = timeline.transformBatchIds;\n            for (const nodeId of nodeIds) {\n                this._animatedRefs.push(new AnimatedBatchedTileTreeReference(treeOwner, {\n                    timeline,\n                    nodeId,\n                    getCurrentTimePoint,\n                }));\n            }\n        }\n    }\n    update() {\n        this._models.setViewedModels(this._view.modelSelector.models);\n        if (this._onModelSelectorChanged)\n            this._onModelSelectorChanged();\n    }\n    attachToViewport(args) {\n        this._onModelSelectorChanged = () => args.invalidateSymbologyOverrides();\n    }\n    detachFromViewport() {\n        this._onModelSelectorChanged = undefined;\n    }\n    setDeactivated() {\n        // Used for debugging. Unimplemented here.\n    }\n}\n// A placeholder used by [[ProxySpatialTileTreeReferences]] until asynchronous loading completes.\n// It provides a TileTreeOwner that never loads a tile tree.\n// This ensures that [ViewState.areAllTileTreesLoaded]($frontend) will not return `true` while we are loading.\nclass ProxyTileTreeReference extends TileTreeReference {\n    constructor(iModel) {\n        super();\n        this._treeOwner = {\n            iModel,\n            tileTree: undefined,\n            loadStatus: TileTreeLoadStatus.NotLoaded,\n            load: () => undefined,\n            dispose: () => { },\n            loadTree: async () => Promise.resolve(undefined),\n        };\n    }\n    get treeOwner() {\n        return this._treeOwner;\n    }\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    get _isLoadingComplete() {\n        return false;\n    }\n}\n// Serves as a placeholder while we asynchronously obtain the base URL for a pre-published tileset (or asynchronously determine\n// that no such tileset exists).\nclass ProxySpatialTileTreeReferences {\n    constructor(view, getBaseUrl) {\n        this._proxyRef = new ProxyTileTreeReference(view.iModel);\n        getBaseUrl.then((url) => {\n            if (url) {\n                this.setTreeRefs(new BatchedSpatialTileTreeReferences(url, view));\n            }\n            else {\n                this.setTreeRefs(createFallbackSpatialTileTreeReferences(view));\n            }\n        }).catch(() => {\n            this.setTreeRefs(createFallbackSpatialTileTreeReferences(view));\n        });\n    }\n    setTreeRefs(refs) {\n        this._impl = refs;\n        if (this._attachArgs) {\n            this._impl.attachToViewport(this._attachArgs);\n            this._attachArgs.invalidateSymbologyOverrides();\n            this._attachArgs = undefined;\n        }\n    }\n    update() {\n        this._impl?.update();\n    }\n    attachToViewport(args) {\n        if (this._impl)\n            this._impl.attachToViewport(args);\n        else\n            this._attachArgs = args;\n    }\n    detachFromViewport() {\n        if (this._impl)\n            this._impl.detachFromViewport();\n        else\n            this._attachArgs = undefined;\n    }\n    setDeactivated() { }\n    *[Symbol.iterator]() {\n        if (this._impl) {\n            for (const ref of this._impl)\n                yield ref;\n        }\n        else {\n            yield this._proxyRef;\n        }\n    }\n}\nconst iModelToBaseUrl = new Map();\n/** @internal */\nexport function createBatchedSpatialTileTreeReferences(view, computeBaseUrl) {\n    const iModel = view.iModel;\n    let entry = iModelToBaseUrl.get(iModel);\n    if (undefined === entry) {\n        const promise = computeBaseUrl(iModel);\n        iModelToBaseUrl.set(iModel, entry = promise);\n        iModel.onClose.addOnce(() => iModelToBaseUrl.delete(iModel));\n        promise.then((url) => {\n            if (iModelToBaseUrl.has(iModel))\n                iModelToBaseUrl.set(iModel, url ?? null);\n        }).catch(() => {\n            if (iModelToBaseUrl.has(iModel))\n                iModelToBaseUrl.set(iModel, null);\n        });\n    }\n    if (null === entry) {\n        // No tileset exists for this iModel - use default tile generation instead.\n        return createFallbackSpatialTileTreeReferences(view);\n    }\n    if (entry instanceof Promise)\n        return new ProxySpatialTileTreeReferences(view, entry);\n    return new BatchedSpatialTileTreeReferences(entry, view);\n}\n//# sourceMappingURL=BatchedSpatialTileTreeRefs.js.map",
      "start": 1693508122289,
      "end": 1693508122327,
      "sourcemaps": null
    }
  ]
}
