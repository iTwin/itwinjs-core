{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tools/MeasureTool.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Measure\n */\nimport { Id64 } from \"@itwin/core-bentley\";\nimport { AxisOrder, IModelJson, Matrix3d, Plane3dByOriginAndUnitNormal, Point2d, Point3d, PointString3d, PolygonOps, Vector3d, } from \"@itwin/core-geometry\";\nimport { BentleyStatus, ColorDef, LinePixels, MassPropertiesOperation, } from \"@itwin/core-common\";\nimport { AccuDrawHintBuilder, ContextRotationId } from \"../AccuDraw\";\nimport { LocateFilterStatus, LocateResponse } from \"../ElementLocateManager\";\nimport { HitGeomType } from \"../HitDetail\";\nimport { IModelApp } from \"../IModelApp\";\nimport { Marker } from \"../Marker\";\nimport { NotifyMessageDetails, OutputMessagePriority, OutputMessageType } from \"../NotificationManager\";\nimport { QuantityType } from \"../quantity-formatting/QuantityFormatter\";\nimport { GraphicType } from \"../render/GraphicBuilder\";\nimport { PrimitiveTool } from \"./PrimitiveTool\";\nimport { BeModifierKeys, CoreTools, EventHandled, InputSource } from \"./Tool\";\nimport { ToolAssistance, ToolAssistanceImage, ToolAssistanceInputMethod } from \"./ToolAssistance\";\nfunction translateBold(key) {\n    return `<b>${CoreTools.translate(`Measure.Labels.${key}`)}:</b> `;\n}\n/** @internal */\nclass MeasureLabel {\n    constructor(worldLocation, label) {\n        this.worldLocation = new Point3d();\n        this.position = new Point3d();\n        this.worldLocation.setFrom(worldLocation);\n        this.label = label;\n    }\n    drawDecoration(ctx) {\n        ctx.font = \"16px sans-serif\";\n        const labelHeight = ctx.measureText(\"M\").width; // Close enough for border padding...\n        const labelWidth = ctx.measureText(this.label).width + labelHeight;\n        ctx.lineWidth = 1;\n        ctx.strokeStyle = \"white\";\n        ctx.fillStyle = \"rgba(0,0,0,.4)\";\n        ctx.shadowColor = \"black\";\n        ctx.shadowBlur = 10;\n        ctx.fillRect(-(labelWidth / 2), -labelHeight, labelWidth, labelHeight * 2);\n        ctx.strokeRect(-(labelWidth / 2), -labelHeight, labelWidth, labelHeight * 2);\n        ctx.fillStyle = \"white\";\n        ctx.shadowBlur = 0;\n        ctx.textAlign = \"center\";\n        ctx.textBaseline = \"middle\";\n        ctx.fillText(this.label, 0, 0);\n    }\n    setPosition(vp) {\n        vp.worldToView(this.worldLocation, this.position);\n        this.position.y -= Math.floor(vp.pixelsFromInches(0.44)) + 0.5; // Offset from snap location...\n        return vp.viewRect.containsPoint(this.position);\n    }\n    addDecoration(context) {\n        if (this.setPosition(context.viewport))\n            context.addCanvasDecoration(this);\n    }\n}\n/** @internal */\nclass MeasureMarker extends Marker {\n    constructor(label, title, worldLocation, size) {\n        super(worldLocation, size);\n        this.isSelected = false;\n        const markerDrawFunc = (ctx) => {\n            ctx.beginPath();\n            ctx.arc(0, 0, this.size.x * 0.5, 0, 2 * Math.PI);\n            ctx.lineWidth = 2;\n            ctx.strokeStyle = \"black\";\n            const hilite = this.isSelected && this._hiliteColor ? this._hiliteColor.colors : undefined;\n            ctx.fillStyle = undefined !== hilite ? `rgba(${hilite.r | 0},${hilite.g | 0},${hilite.b | 0}, 0.5)` : \"rgba(255,255,255,.5)\";\n            ctx.fill();\n            ctx.stroke();\n        };\n        this.drawFunc = markerDrawFunc; // eslint-disable-line @typescript-eslint/unbound-method\n        this.title = title;\n        this.label = label;\n        this.labelFont = \"16px sans-serif\";\n        this.labelColor = \"black\";\n        this.labelMaxWidth = this.size.x * 0.75;\n        this.labelOffset = { x: 0, y: -1 };\n    }\n    onMouseButton(_ev) { return true; } // Never forward event to active tool...\n    onMouseEnter(ev) {\n        super.onMouseEnter(ev);\n        if (this.title && InputSource.Touch === ev.inputSource && ev.viewport)\n            ev.viewport.openToolTip(this.title, ev.viewPoint, this.tooltipOptions);\n    }\n    onMouseLeave() {\n        super.onMouseLeave();\n        if (this.title)\n            IModelApp.notifications.clearToolTip(); // Clear tool tip from tap since we won't get a motion event...\n    }\n}\n/** @internal */\nfunction adjustPoint(ev, segments, locations) {\n    // If the point was from a hit we must transform it by the display transform of what got hit.\n    const hit = IModelApp.accuSnap.currHit;\n    if (!hit || !ev.viewport || !hit.modelId)\n        return ev.point;\n    if (\"0\" !== hit.modelId) {\n        const transform = ev.viewport.view.computeDisplayTransform({ modelId: hit.modelId, elementId: hit.sourceId });\n        return transform?.multiplyInversePoint3d(ev.point) ?? ev.point;\n    }\n    // Must have snapped to a decoration, so look through previous any segments & locations for a match to get an adjusted point.\n    if (segments) {\n        for (const seg of segments) {\n            if (seg.start.isExactEqual(ev.point))\n                return seg.adjustedStart.clone();\n            if (seg.end.isExactEqual(ev.point))\n                return seg.adjustedEnd.clone();\n        }\n    }\n    if (locations)\n        for (const loc of locations)\n            if (loc.point.isExactEqual(ev.point))\n                return loc.adjustedPoint.clone();\n    return ev.point;\n}\n/** Report distance between 2 points using current quantity formatter for length.\n * @public\n */\nclass MeasureDistanceTool extends PrimitiveTool {\n    constructor() {\n        super(...arguments);\n        /** @internal */\n        this._locationData = new Array();\n        /** @internal */\n        this._acceptedSegments = new Array();\n        /** @internal */\n        this._totalDistance = 0.0;\n    }\n    /** @internal */\n    allowView(vp) { return vp.view.isSpatialView() || vp.view.isDrawingView(); }\n    /** @internal */\n    isCompatibleViewport(vp, isSelectedViewChange) { return (super.isCompatibleViewport(vp, isSelectedViewChange) && undefined !== vp && this.allowView(vp)); }\n    /** @internal */\n    isValidLocation(_ev, _isButtonEvent) { return true; }\n    /** @internal */\n    requireWriteableTarget() { return false; }\n    /** @internal */\n    async onPostInstall() {\n        await super.onPostInstall();\n        this.setupAndPromptForNextAction();\n    }\n    /** @internal */\n    async onUnsuspend() { this.showPrompt(); }\n    /** @internal */\n    showPrompt() {\n        const mainInstruction = ToolAssistance.createInstruction(this.iconSpec, CoreTools.translate(0 === this._locationData.length ? \"Measure.Distance.Prompts.FirstPoint\" : \"Measure.Distance.Prompts.NextPoint\"));\n        const mouseInstructions = [];\n        const touchInstructions = [];\n        if (!ToolAssistance.createTouchCursorInstructions(touchInstructions))\n            touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.OneTouchTap, CoreTools.translate(\"ElementSet.Inputs.AcceptPoint\"), false, ToolAssistanceInputMethod.Touch));\n        mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.LeftClick, CoreTools.translate(\"ElementSet.Inputs.AcceptPoint\"), false, ToolAssistanceInputMethod.Mouse));\n        if (0 === this._locationData.length) {\n            if (this._acceptedSegments.length > 0) {\n                touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.TwoTouchTap, CoreTools.translate(\"ElementSet.Inputs.Restart\"), false, ToolAssistanceInputMethod.Touch));\n                mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.RightClick, CoreTools.translate(\"ElementSet.Inputs.Restart\"), false, ToolAssistanceInputMethod.Mouse));\n            }\n        }\n        else {\n            touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.TwoTouchTap, CoreTools.translate(\"ElementSet.Inputs.Cancel\"), false, ToolAssistanceInputMethod.Touch));\n            mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.RightClick, CoreTools.translate(\"ElementSet.Inputs.Cancel\"), false, ToolAssistanceInputMethod.Mouse));\n            mouseInstructions.push(ToolAssistance.createModifierKeyInstruction(ToolAssistance.ctrlKey, ToolAssistanceImage.LeftClick, CoreTools.translate(\"ElementSet.Inputs.AdditionalPoint\"), false, ToolAssistanceInputMethod.Mouse));\n            mouseInstructions.push(ToolAssistance.createKeyboardInstruction(ToolAssistance.createKeyboardInfo([ToolAssistance.ctrlKey, \"Z\"]), CoreTools.translate(\"ElementSet.Inputs.UndoLastPoint\"), false, ToolAssistanceInputMethod.Mouse));\n        }\n        const sections = [];\n        sections.push(ToolAssistance.createSection(mouseInstructions, ToolAssistance.inputsLabel));\n        sections.push(ToolAssistance.createSection(touchInstructions, ToolAssistance.inputsLabel));\n        const instructions = ToolAssistance.createInstructions(mainInstruction, sections);\n        IModelApp.notifications.setToolAssistance(instructions);\n    }\n    /** @internal */\n    setupAndPromptForNextAction() {\n        IModelApp.accuSnap.enableSnap(true);\n        const hints = new AccuDrawHintBuilder();\n        hints.enableSmartRotation = true;\n        hints.setModeRectangular();\n        hints.sendHints(false);\n        IModelApp.toolAdmin.setCursor(0 === this._locationData.length ? IModelApp.viewManager.crossHairCursor : IModelApp.viewManager.dynamicsCursor);\n        this.showPrompt();\n    }\n    /** @internal */\n    testDecorationHit(id) { return id === this._snapGeomId; }\n    /** @internal */\n    getSnapPoints() {\n        if (this._acceptedSegments.length < 1 && this._locationData.length < 2)\n            return undefined;\n        const snapPoints = [];\n        for (const seg of this._acceptedSegments) {\n            if (0 === snapPoints.length || !seg.start.isAlmostEqual(snapPoints[snapPoints.length - 1]))\n                snapPoints.push(seg.start);\n            if (!seg.end.isAlmostEqual(snapPoints[0]))\n                snapPoints.push(seg.end);\n        }\n        if (this._locationData.length > 1)\n            for (const loc of this._locationData)\n                snapPoints.push(loc.point);\n        return snapPoints;\n    }\n    /** @internal */\n    getDecorationGeometry(_hit) {\n        const snapPoints = this.getSnapPoints();\n        if (undefined === snapPoints)\n            return undefined;\n        const geomData = IModelJson.Writer.toIModelJson(PointString3d.create(snapPoints));\n        return (undefined === geomData ? undefined : [geomData]);\n    }\n    /** @internal */\n    displayDynamicDistance(context, points, adjustedPoints) {\n        let totalDistance = 0.0;\n        for (let i = 0; i < adjustedPoints.length - 1; i++)\n            totalDistance += adjustedPoints[i].distance(adjustedPoints[i + 1]);\n        if (0.0 === totalDistance)\n            return;\n        const formatterSpec = IModelApp.quantityFormatter.findFormatterSpecByQuantityType(QuantityType.Length);\n        if (undefined === formatterSpec)\n            return;\n        const formattedTotalDistance = IModelApp.quantityFormatter.formatQuantity(totalDistance, formatterSpec);\n        const distDyn = new MeasureLabel(points[points.length - 1], formattedTotalDistance);\n        distDyn.addDecoration(context);\n    }\n    /** @internal */\n    displayDelta(context, seg) {\n        const xVec = new Vector3d(seg.delta.x, 0.0, 0.0);\n        const yVec = new Vector3d(0.0, seg.delta.y, 0.0);\n        const zVec = new Vector3d(0.0, 0.0, seg.delta.z);\n        seg.refAxes.multiplyVectorInPlace(xVec);\n        seg.refAxes.multiplyVectorInPlace(yVec);\n        seg.refAxes.multiplyVectorInPlace(zVec);\n        const builderAxes = context.createGraphicBuilder(GraphicType.WorldOverlay);\n        let basePt = seg.start.clone();\n        if (xVec.magnitude() > 1.0e-5) {\n            const segPoints = [];\n            segPoints.push(basePt);\n            basePt = basePt.plus(xVec);\n            segPoints.push(basePt);\n            const colorX = ColorDef.red.adjustedForContrast(context.viewport.view.backgroundColor);\n            builderAxes.setSymbology(colorX, ColorDef.black, 5);\n            builderAxes.addLineString(segPoints);\n        }\n        if (yVec.magnitude() > 1.0e-5) {\n            const segPoints = [];\n            segPoints.push(basePt);\n            basePt = basePt.plus(yVec);\n            segPoints.push(basePt);\n            const colorY = ColorDef.green.adjustedForContrast(context.viewport.view.backgroundColor);\n            builderAxes.setSymbology(colorY, ColorDef.black, 5);\n            builderAxes.addLineString(segPoints);\n        }\n        if (zVec.magnitude() > 1.0e-5) {\n            const segPoints = [];\n            segPoints.push(basePt);\n            basePt = basePt.plus(zVec);\n            segPoints.push(basePt);\n            const colorZ = ColorDef.blue.adjustedForContrast(context.viewport.view.backgroundColor);\n            builderAxes.setSymbology(colorZ, ColorDef.black, 5);\n            builderAxes.addLineString(segPoints);\n        }\n        const segGlow = context.viewport.hilite.color.withAlpha(50);\n        builderAxes.setSymbology(segGlow, ColorDef.black, 8);\n        builderAxes.addLineString([seg.start, seg.end]);\n        context.addDecorationFromBuilder(builderAxes);\n    }\n    /** @internal */\n    createDecorations(context, isSuspended) {\n        if (!this.isCompatibleViewport(context.viewport, false))\n            return;\n        if (!isSuspended && this._locationData.length > 0 && undefined !== this._lastMotionPt && undefined !== this._lastMotionAdjustedPt) {\n            const tmpPoints = [];\n            const tmpAdjustedPoints = [];\n            for (const loc of this._locationData) {\n                tmpPoints.push(loc.point); // Deep copy not necessary...\n                tmpAdjustedPoints.push(loc.adjustedPoint);\n            }\n            tmpPoints.push(this._lastMotionPt);\n            tmpAdjustedPoints.push(this._lastMotionAdjustedPt);\n            const builderDynVis = context.createGraphicBuilder(GraphicType.WorldDecoration);\n            const colorDynVis = context.viewport.hilite.color;\n            builderDynVis.setSymbology(colorDynVis, ColorDef.black, 3);\n            builderDynVis.addLineString(tmpPoints);\n            context.addDecorationFromBuilder(builderDynVis);\n            const builderDynHid = context.createGraphicBuilder(GraphicType.WorldOverlay);\n            const colorDynHid = colorDynVis.withAlpha(100);\n            builderDynHid.setSymbology(colorDynHid, ColorDef.black, 1, LinePixels.Code2);\n            builderDynHid.addLineString(tmpPoints);\n            context.addDecorationFromBuilder(builderDynHid);\n            this.displayDynamicDistance(context, tmpPoints, tmpAdjustedPoints);\n        }\n        if (this._acceptedSegments.length > 0) {\n            const builderAccVis = context.createGraphicBuilder(GraphicType.WorldDecoration);\n            const builderAccHid = context.createGraphicBuilder(GraphicType.WorldOverlay);\n            const colorAccVis = ColorDef.white.adjustedForContrast(context.viewport.view.backgroundColor);\n            const colorAccHid = colorAccVis.withAlpha(100);\n            builderAccVis.setSymbology(colorAccVis, ColorDef.black, 3);\n            builderAccHid.setSymbology(colorAccHid, ColorDef.black, 1, LinePixels.Code2);\n            for (const seg of this._acceptedSegments) {\n                builderAccVis.addLineString([seg.start, seg.end]);\n                builderAccHid.addLineString([seg.start, seg.end]);\n                seg.marker.addDecoration(context);\n                if (seg.marker.isSelected)\n                    this.displayDelta(context, seg);\n            }\n            context.addDecorationFromBuilder(builderAccVis);\n            context.addDecorationFromBuilder(builderAccHid);\n        }\n        if (undefined !== this._totalDistanceMarker)\n            this._totalDistanceMarker.addDecoration(context);\n        const snapPoints = this.getSnapPoints();\n        if (undefined === snapPoints)\n            return;\n        if (undefined === this._snapGeomId)\n            this._snapGeomId = this.iModel.transientIds.getNext();\n        const builderSnapPts = context.createGraphicBuilder(GraphicType.WorldOverlay, undefined, this._snapGeomId);\n        const colorAccPts = ColorDef.white.adjustedForContrast(context.viewport.view.backgroundColor);\n        builderSnapPts.setSymbology(colorAccPts, ColorDef.black, 7);\n        builderSnapPts.addPointString(snapPoints);\n        context.addDecorationFromBuilder(builderSnapPts);\n    }\n    /** @internal */\n    decorate(context) { this.createDecorations(context, false); }\n    /** @internal */\n    decorateSuspended(context) { this.createDecorations(context, true); }\n    /** @internal */\n    async onMouseMotion(ev) {\n        if (this._locationData.length > 0 && undefined !== ev.viewport) {\n            const point = ev.point;\n            const adjustedPoint = adjustPoint(ev, this._acceptedSegments, this._locationData);\n            if (undefined !== this._lastMotionPt) {\n                this._lastMotionPt.setFrom(point);\n                this._lastMotionAdjustedPt?.setFrom(adjustedPoint);\n            }\n            else {\n                this._lastMotionPt = point.clone();\n                this._lastMotionAdjustedPt = adjustedPoint;\n            }\n            ev.viewport.invalidateDecorations();\n        }\n    }\n    reportMeasurements() {\n        if (undefined === this._totalDistanceMarker)\n            return;\n        const briefMsg = `${CoreTools.translate(this._acceptedSegments.length > 1 ? \"Measure.Labels.CumulativeDistance\" : \"Measure.Labels.Distance\")}: ${this._totalDistanceMarker.label}`;\n        const msgDetail = new NotifyMessageDetails(OutputMessagePriority.Info, briefMsg, undefined, OutputMessageType.Sticky);\n        IModelApp.notifications.outputMessage(msgDetail);\n    }\n    async updateTotals() {\n        this._totalDistance = 0.0;\n        this._totalDistanceMarker = undefined;\n        for (const seg of this._acceptedSegments)\n            this._totalDistance += seg.distance;\n        if (0.0 === this._totalDistance)\n            return;\n        const formatterSpec = await IModelApp.quantityFormatter.getFormatterSpecByQuantityType(QuantityType.Length);\n        if (undefined === formatterSpec)\n            return;\n        const formattedTotalDistance = IModelApp.quantityFormatter.formatQuantity(this._totalDistance, formatterSpec);\n        this._totalDistanceMarker = new MeasureLabel(this._acceptedSegments[this._acceptedSegments.length - 1].end, formattedTotalDistance);\n        this.reportMeasurements();\n    }\n    async getMarkerToolTip(distance, slope, start, end, delta) {\n        const is3d = (undefined === this.targetView || this.targetView.view.is3d());\n        const isSpatial = (undefined !== this.targetView && this.targetView.view.isSpatialView());\n        const toolTip = document.createElement(\"div\");\n        const distanceFormatterSpec = await IModelApp.quantityFormatter.getFormatterSpecByQuantityType(QuantityType.Length);\n        if (undefined === distanceFormatterSpec)\n            return toolTip;\n        let toolTipHtml = \"\";\n        const formattedDistance = IModelApp.quantityFormatter.formatQuantity(distance, distanceFormatterSpec);\n        toolTipHtml += `${translateBold(\"Distance\") + formattedDistance}<br>`;\n        if (is3d) {\n            const angleFormatterSpec = await IModelApp.quantityFormatter.getFormatterSpecByQuantityType(QuantityType.Angle);\n            if (undefined !== angleFormatterSpec) {\n                const formattedSlope = IModelApp.quantityFormatter.formatQuantity(slope, angleFormatterSpec);\n                toolTipHtml += `${translateBold(\"Slope\") + formattedSlope}<br>`;\n            }\n        }\n        const coordFormatterSpec = await IModelApp.quantityFormatter.getFormatterSpecByQuantityType(QuantityType.Coordinate);\n        if (undefined !== coordFormatterSpec) {\n            let startAdjusted = start;\n            let endAdjusted = end;\n            if (isSpatial) {\n                const globalOrigin = this.iModel.globalOrigin;\n                startAdjusted = startAdjusted.minus(globalOrigin);\n                endAdjusted = endAdjusted.minus(globalOrigin);\n            }\n            {\n                const formattedStartX = IModelApp.quantityFormatter.formatQuantity(startAdjusted.x, coordFormatterSpec);\n                const formattedStartY = IModelApp.quantityFormatter.formatQuantity(startAdjusted.y, coordFormatterSpec);\n                const formattedStartZ = IModelApp.quantityFormatter.formatQuantity(startAdjusted.z, coordFormatterSpec);\n                toolTipHtml += `${translateBold(\"StartCoord\") + formattedStartX}, ${formattedStartY}`;\n                if (is3d)\n                    toolTipHtml += `, ${formattedStartZ}`;\n                toolTipHtml += \"<br>\";\n            }\n            const formattedEndX = IModelApp.quantityFormatter.formatQuantity(endAdjusted.x, coordFormatterSpec);\n            const formattedEndY = IModelApp.quantityFormatter.formatQuantity(endAdjusted.y, coordFormatterSpec);\n            const formattedEndZ = IModelApp.quantityFormatter.formatQuantity(endAdjusted.z, coordFormatterSpec);\n            toolTipHtml += `${translateBold(\"EndCoord\") + formattedEndX}, ${formattedEndY}`;\n            if (is3d)\n                toolTipHtml += `, ${formattedEndZ}`;\n            toolTipHtml += \"<br>\";\n        }\n        if (undefined !== delta) {\n            const formattedDeltaX = IModelApp.quantityFormatter.formatQuantity(Math.abs(delta.x), distanceFormatterSpec);\n            const formattedDeltaY = IModelApp.quantityFormatter.formatQuantity(Math.abs(delta.y), distanceFormatterSpec);\n            const formattedDeltaZ = IModelApp.quantityFormatter.formatQuantity(Math.abs(delta.z), distanceFormatterSpec);\n            toolTipHtml += `${translateBold(\"Delta\") + formattedDeltaX}, ${formattedDeltaY}`;\n            if (is3d)\n                toolTipHtml += `, ${formattedDeltaZ}`;\n            toolTipHtml += \"<br>\";\n        }\n        toolTip.innerHTML = toolTipHtml;\n        return toolTip;\n    }\n    /** @internal */\n    async updateSelectedMarkerToolTip(seg, ev, reopenToolTip) {\n        seg.marker.title = await this.getMarkerToolTip(seg.distance, seg.slope, seg.adjustedStart, seg.adjustedEnd, seg.marker.isSelected ? seg.adjustedDelta : undefined);\n        if (!reopenToolTip || undefined === ev.viewport || !IModelApp.notifications.isToolTipOpen)\n            return;\n        IModelApp.notifications.clearToolTip();\n        ev.viewport.openToolTip(seg.marker.title, ev.viewPoint);\n    }\n    /** @internal */\n    async acceptNewSegments() {\n        if (this._locationData.length > 1) {\n            for (let i = 0; i <= this._locationData.length - 2; i++) {\n                const adjustedStart = this._locationData[i].adjustedPoint;\n                const adjustedEnd = this._locationData[i + 1].adjustedPoint;\n                const distance = adjustedStart.distance(adjustedEnd);\n                const xyDist = adjustedStart.distanceXY(adjustedEnd);\n                const zDist = adjustedEnd.z - adjustedStart.z;\n                const slope = (0.0 === xyDist ? Math.PI : Math.atan(zDist / xyDist));\n                const adjustedDelta = Vector3d.createStartEnd(adjustedStart, adjustedEnd);\n                const refAxes = this._locationData[i].refAxes;\n                refAxes.multiplyTransposeVectorInPlace(adjustedDelta);\n                const start = this._locationData[i].point;\n                const end = this._locationData[i + 1].point;\n                const delta = Vector3d.createStartEnd(start, end);\n                refAxes.multiplyTransposeVectorInPlace(delta);\n                const toolTip = await this.getMarkerToolTip(distance, slope, adjustedStart, adjustedEnd);\n                const marker = new MeasureMarker((this._acceptedSegments.length + 1).toString(), toolTip, start.interpolate(0.5, end), Point2d.create(25, 25));\n                const segMarkerButtonFunc = (ev) => {\n                    if (ev.isDown)\n                        return true;\n                    let selectedMarker;\n                    let pickedMarker;\n                    for (const seg of this._acceptedSegments) {\n                        if (!seg.marker.pick(ev.viewPoint))\n                            continue;\n                        selectedMarker = (seg.marker.isSelected ? undefined : seg.marker);\n                        pickedMarker = seg.marker;\n                        break;\n                    }\n                    for (const seg of this._acceptedSegments) {\n                        const wasSelected = seg.marker.isSelected;\n                        seg.marker.isSelected = (seg.marker === selectedMarker);\n                        if (wasSelected !== seg.marker.isSelected)\n                            this.updateSelectedMarkerToolTip(seg, ev, (seg.marker === pickedMarker)); // eslint-disable-line @typescript-eslint/no-floating-promises\n                    }\n                    if (undefined !== ev.viewport)\n                        ev.viewport.invalidateDecorations();\n                    return true;\n                };\n                marker.onMouseButton = segMarkerButtonFunc; // eslint-disable-line @typescript-eslint/unbound-method\n                this._acceptedSegments.push({ distance, slope, start, end, delta, adjustedStart, adjustedEnd, adjustedDelta, refAxes, marker });\n            }\n        }\n        this._locationData.length = 0;\n        await this.updateTotals();\n    }\n    /** @internal */\n    getReferenceAxes(vp) {\n        const refAxes = Matrix3d.createIdentity();\n        if (undefined !== vp && vp.isContextRotationRequired)\n            vp.getAuxCoordRotation(refAxes);\n        return refAxes;\n    }\n    /** @internal */\n    async onDataButtonDown(ev) {\n        const point = ev.point.clone();\n        const adjustedPoint = adjustPoint(ev, this._acceptedSegments, this._locationData);\n        const refAxes = this.getReferenceAxes(ev.viewport);\n        const zDir = refAxes.columnZ();\n        const normal = refAxes.columnZ();\n        const tangent = refAxes.columnX();\n        const snap = IModelApp.accuSnap.getCurrSnapDetail();\n        // Report xyz delta relative to world up. The surface normal and edge tangent help determine the rotation about z...\n        if (undefined !== snap) {\n            if (undefined !== snap.primitive) {\n                const locDetail = snap.primitive.closestPoint(point, false);\n                if (undefined !== locDetail && (HitGeomType.Segment === snap.geomType || snap.primitive.isInPlane(Plane3dByOriginAndUnitNormal.create(point, undefined !== snap.normal ? snap.normal : normal)))) {\n                    const locRay = snap.primitive.fractionToPointAndUnitTangent(locDetail.fraction);\n                    tangent.setFrom(locRay.direction);\n                    if (undefined !== snap.normal)\n                        normal.setFrom(snap.normal);\n                }\n            }\n            else if (undefined !== snap.normal) {\n                normal.setFrom(snap.normal);\n            }\n        }\n        if (!normal.isParallelTo(zDir, true)) {\n            const yDir = zDir.unitCrossProduct(normal);\n            if (undefined !== yDir) {\n                yDir.unitCrossProduct(zDir, normal);\n                Matrix3d.createColumnsInAxisOrder(AxisOrder.ZXY, normal, yDir, zDir, refAxes);\n            }\n        }\n        else if (!tangent.isParallelTo(zDir, true)) {\n            const yDir = zDir.unitCrossProduct(tangent);\n            if (undefined !== yDir) {\n                yDir.unitCrossProduct(zDir, tangent);\n                Matrix3d.createColumnsInAxisOrder(AxisOrder.XYZ, tangent, yDir, zDir, refAxes);\n            }\n        }\n        this._locationData.push({ point, adjustedPoint, refAxes });\n        if (this._locationData.length > 1 && !ev.isControlKey)\n            await this.acceptNewSegments();\n        this.setupAndPromptForNextAction();\n        if (undefined !== ev.viewport)\n            ev.viewport.invalidateDecorations();\n        return EventHandled.No;\n    }\n    /** @internal */\n    async onResetButtonUp(ev) {\n        if (0 === this._locationData.length) {\n            await this.onReinitialize();\n            return EventHandled.No;\n        }\n        await this.acceptNewSegments();\n        this.setupAndPromptForNextAction();\n        if (undefined !== ev.viewport)\n            ev.viewport.invalidateDecorations();\n        return EventHandled.No;\n    }\n    /** @internal */\n    async onUndoPreviousStep() {\n        if (0 === this._locationData.length && 0 === this._acceptedSegments.length)\n            return false;\n        if (0 !== this._locationData.length) {\n            this._locationData.pop();\n        }\n        else if (0 !== this._acceptedSegments.length) {\n            this._acceptedSegments.pop();\n        }\n        if (0 === this._locationData.length && 0 === this._acceptedSegments.length) {\n            await this.onReinitialize();\n        }\n        else {\n            await this.updateTotals();\n            this.setupAndPromptForNextAction();\n        }\n        return true;\n    }\n    /** @internal */\n    async onRestartTool() {\n        const tool = new MeasureDistanceTool();\n        if (!await tool.run())\n            return this.exitTool();\n    }\n}\nMeasureDistanceTool.toolId = \"Measure.Distance\";\nMeasureDistanceTool.iconSpec = \"icon-measure-distance\";\nexport { MeasureDistanceTool };\n/** Report spatial coordinate at a point as well as cartographic location for geolocated models using current quantity formatters.\n * @public\n */\nclass MeasureLocationTool extends PrimitiveTool {\n    constructor() {\n        super(...arguments);\n        /** @internal */\n        this._acceptedLocations = [];\n    }\n    /** @internal */\n    allowView(vp) { return vp.view.isSpatialView() || vp.view.isDrawingView(); }\n    /** @internal */\n    isCompatibleViewport(vp, isSelectedViewChange) { return (super.isCompatibleViewport(vp, isSelectedViewChange) && undefined !== vp && this.allowView(vp)); }\n    /** @internal */\n    isValidLocation(_ev, _isButtonEvent) { return true; }\n    /** @internal */\n    requireWriteableTarget() { return false; }\n    /** @internal */\n    async onPostInstall() {\n        await super.onPostInstall();\n        this.setupAndPromptForNextAction();\n    }\n    /** @internal */\n    async onUnsuspend() { this.showPrompt(); }\n    /** @internal */\n    showPrompt() {\n        const mainInstruction = ToolAssistance.createInstruction(this.iconSpec, CoreTools.translate(\"Measure.Location.Prompts.EnterPoint\"));\n        const mouseInstructions = [];\n        const touchInstructions = [];\n        if (!ToolAssistance.createTouchCursorInstructions(touchInstructions))\n            touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.OneTouchTap, CoreTools.translate(\"ElementSet.Inputs.AcceptPoint\"), false, ToolAssistanceInputMethod.Touch));\n        mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.LeftClick, CoreTools.translate(\"ElementSet.Inputs.AcceptPoint\"), false, ToolAssistanceInputMethod.Mouse));\n        if (0 !== this._acceptedLocations.length) {\n            touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.TwoTouchTap, CoreTools.translate(\"ElementSet.Inputs.Restart\"), false, ToolAssistanceInputMethod.Touch));\n            mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.RightClick, CoreTools.translate(\"ElementSet.Inputs.Restart\"), false, ToolAssistanceInputMethod.Mouse));\n        }\n        const sections = [];\n        sections.push(ToolAssistance.createSection(mouseInstructions, ToolAssistance.inputsLabel));\n        sections.push(ToolAssistance.createSection(touchInstructions, ToolAssistance.inputsLabel));\n        const instructions = ToolAssistance.createInstructions(mainInstruction, sections);\n        IModelApp.notifications.setToolAssistance(instructions);\n    }\n    /** @internal */\n    setupAndPromptForNextAction() {\n        IModelApp.accuSnap.enableSnap(true);\n        this.showPrompt();\n    }\n    async getMarkerToolTip(point) {\n        const is3d = (undefined === this.targetView || this.targetView.view.is3d());\n        const isSpatial = (undefined !== this.targetView && this.targetView.view.isSpatialView());\n        const toolTip = document.createElement(\"div\");\n        let toolTipHtml = \"\";\n        const coordFormatterSpec = await IModelApp.quantityFormatter.getFormatterSpecByQuantityType(QuantityType.Coordinate);\n        if (undefined !== coordFormatterSpec) {\n            let pointAdjusted = point;\n            if (isSpatial) {\n                const globalOrigin = this.iModel.globalOrigin;\n                pointAdjusted = pointAdjusted.minus(globalOrigin);\n            }\n            const formattedPointX = IModelApp.quantityFormatter.formatQuantity(pointAdjusted.x, coordFormatterSpec);\n            const formattedPointY = IModelApp.quantityFormatter.formatQuantity(pointAdjusted.y, coordFormatterSpec);\n            const formattedPointZ = IModelApp.quantityFormatter.formatQuantity(pointAdjusted.z, coordFormatterSpec);\n            toolTipHtml += `${translateBold(\"Coordinate\") + formattedPointX}, ${formattedPointY}`;\n            if (is3d)\n                toolTipHtml += `, ${formattedPointZ}`;\n            toolTipHtml += \"<br>\";\n        }\n        if (isSpatial) {\n            const latLongFormatterSpec = await IModelApp.quantityFormatter.getFormatterSpecByQuantityType(QuantityType.LatLong);\n            if (undefined !== latLongFormatterSpec && undefined !== coordFormatterSpec) {\n                try {\n                    const cartographic = await this.iModel.spatialToCartographic(point);\n                    const formattedLat = IModelApp.quantityFormatter.formatQuantity(Math.abs(cartographic.latitude), latLongFormatterSpec);\n                    const formattedLong = IModelApp.quantityFormatter.formatQuantity(Math.abs(cartographic.longitude), latLongFormatterSpec);\n                    const formattedHeight = IModelApp.quantityFormatter.formatQuantity(cartographic.height, coordFormatterSpec);\n                    const latDir = CoreTools.translate(cartographic.latitude < 0 ? \"Measure.Labels.S\" : \"Measure.Labels.N\");\n                    const longDir = CoreTools.translate(cartographic.longitude < 0 ? \"Measure.Labels.W\" : \"Measure.Labels.E\");\n                    toolTipHtml += `${translateBold(\"LatLong\") + formattedLat + latDir}, ${formattedLong}${longDir}<br>`;\n                    toolTipHtml += `${translateBold(\"Altitude\") + formattedHeight}<br>`;\n                }\n                catch { }\n            }\n        }\n        toolTip.innerHTML = toolTipHtml;\n        return toolTip;\n    }\n    /** @internal */\n    decorate(context) {\n        if (!this.isCompatibleViewport(context.viewport, false))\n            return;\n        this._acceptedLocations.forEach((marker) => marker.addDecoration(context));\n    }\n    /** @internal */\n    decorateSuspended(context) { this.decorate(context); }\n    reportMeasurements() {\n        if (0 === this._acceptedLocations.length)\n            return;\n        const briefMsg = this._acceptedLocations[this._acceptedLocations.length - 1].title;\n        if (undefined === briefMsg)\n            return;\n        const msgDetail = new NotifyMessageDetails(OutputMessagePriority.Info, briefMsg, undefined, OutputMessageType.Sticky);\n        IModelApp.notifications.outputMessage(msgDetail);\n    }\n    /** @internal */\n    async onDataButtonDown(ev) {\n        const point = ev.point.clone();\n        const adjustedPoint = adjustPoint(ev);\n        const toolTip = await this.getMarkerToolTip(adjustedPoint);\n        const marker = new MeasureMarker((this._acceptedLocations.length + 1).toString(), toolTip, point, Point2d.create(25, 25));\n        this._acceptedLocations.push(marker);\n        this.reportMeasurements();\n        this.setupAndPromptForNextAction();\n        if (undefined !== ev.viewport)\n            ev.viewport.invalidateDecorations();\n        return EventHandled.No;\n    }\n    /** @internal */\n    async onResetButtonUp(_ev) {\n        await this.onReinitialize();\n        return EventHandled.No;\n    }\n    /** @internal */\n    async onUndoPreviousStep() {\n        if (0 === this._acceptedLocations.length)\n            return false;\n        this._acceptedLocations.pop();\n        if (0 === this._acceptedLocations.length) {\n            await this.onReinitialize();\n        }\n        else {\n            this.reportMeasurements();\n            this.setupAndPromptForNextAction();\n        }\n        return true;\n    }\n    /** @internal */\n    async onRestartTool() {\n        const tool = new MeasureLocationTool();\n        if (!await tool.run())\n            return this.exitTool();\n    }\n}\nMeasureLocationTool.toolId = \"Measure.Location\";\nMeasureLocationTool.iconSpec = \"icon-measure-location\";\nexport { MeasureLocationTool };\n/** Report area defined by points using current quantity formatter for area.\n * @public\n */\nclass MeasureAreaByPointsTool extends PrimitiveTool {\n    constructor() {\n        super(...arguments);\n        /** @internal */\n        this._orientationValue = { value: ContextRotationId.Top };\n        /** @internal */\n        this._points = [];\n        /** @internal */\n        this._isComplete = false;\n        /** @internal */\n        this._area = 0.0;\n        /** @internal */\n        this._perimeter = 0.0;\n        /** @internal */\n        this._centroid = Point3d.createZero();\n    }\n    /** @internal */\n    get orientation() { return this._orientationValue.value; }\n    set orientation(option) { this._orientationValue.value = option; }\n    /** @internal */\n    static enumAsOrientationMessage(str) { return CoreTools.translate(`Settings.Orientation.${str}`); }\n    /** @internal */\n    supplyToolSettingsProperties() {\n        const initialValue = IModelApp.toolAdmin.toolSettingsState.getInitialToolSettingValue(this.toolId, MeasureAreaByPointsTool._orientationName);\n        initialValue && (this._orientationValue = initialValue);\n        const toolSettings = new Array();\n        toolSettings.push({ value: this._orientationValue, property: MeasureAreaByPointsTool._getEnumAsOrientationDescription(), editorPosition: { rowPriority: 0, columnIndex: 2 } });\n        return toolSettings;\n    }\n    /** @internal */\n    async applyToolSettingPropertyChange(updatedValue) {\n        if (updatedValue.propertyName === MeasureAreaByPointsTool._orientationName) {\n            this._orientationValue = updatedValue.value;\n            if (!this._orientationValue)\n                return false;\n            IModelApp.toolAdmin.toolSettingsState.saveToolSettingProperty(this.toolId, { propertyName: MeasureAreaByPointsTool._orientationName, value: this._orientationValue });\n            await this.onReinitialize();\n            return true;\n        }\n        return false;\n    }\n    /** @internal */\n    allowView(vp) { return vp.view.isSpatialView() || vp.view.isDrawingView(); }\n    /** @internal */\n    isCompatibleViewport(vp, isSelectedViewChange) { return (super.isCompatibleViewport(vp, isSelectedViewChange) && undefined !== vp && this.allowView(vp)); }\n    /** @internal */\n    isValidLocation(_ev, _isButtonEvent) { return true; }\n    /** @internal */\n    requireWriteableTarget() { return false; }\n    /** @internal */\n    async onPostInstall() {\n        await super.onPostInstall();\n        this.setupAndPromptForNextAction();\n    }\n    /** @internal */\n    async onUnsuspend() { this.showPrompt(); }\n    /** @internal */\n    showPrompt() {\n        let mainMsg = \"Measure.AreaByPoints.Prompts.\";\n        switch (this._points.length) {\n            case 0:\n                mainMsg += \"FirstPoint\";\n                break;\n            case 1:\n                mainMsg += \"SecondPoint\";\n                break;\n            case 2:\n                mainMsg += \"ThirdPoint\";\n                break;\n            default:\n                mainMsg += this._isComplete ? \"FirstPoint\" : \"NextPoint\";\n                break;\n        }\n        const mainInstruction = ToolAssistance.createInstruction(this.iconSpec, CoreTools.translate(mainMsg));\n        const mouseInstructions = [];\n        const touchInstructions = [];\n        const acceptMsg = CoreTools.translate(this._isComplete ? \"ElementSet.Inputs.Restart\" : \"ElementSet.Inputs.AcceptPoint\");\n        if (!ToolAssistance.createTouchCursorInstructions(touchInstructions))\n            touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.OneTouchTap, acceptMsg, false, ToolAssistanceInputMethod.Touch));\n        mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.LeftClick, acceptMsg, false, ToolAssistanceInputMethod.Mouse));\n        const resetMsg = CoreTools.translate(\"ElementSet.Inputs.Restart\");\n        touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.TwoTouchTap, resetMsg, false, ToolAssistanceInputMethod.Touch));\n        mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.RightClick, resetMsg, false, ToolAssistanceInputMethod.Mouse));\n        if (this._points.length > 1)\n            mouseInstructions.push(ToolAssistance.createModifierKeyInstruction(ToolAssistance.ctrlKey, ToolAssistanceImage.LeftClick, CoreTools.translate(\"ElementSet.Inputs.AdditionalPoint\"), false, ToolAssistanceInputMethod.Mouse));\n        if (0 !== this._points.length)\n            mouseInstructions.push(ToolAssistance.createKeyboardInstruction(ToolAssistance.createKeyboardInfo([ToolAssistance.ctrlKey, \"Z\"]), CoreTools.translate(\"ElementSet.Inputs.UndoLastPoint\"), false, ToolAssistanceInputMethod.Mouse));\n        const sections = [];\n        sections.push(ToolAssistance.createSection(mouseInstructions, ToolAssistance.inputsLabel));\n        sections.push(ToolAssistance.createSection(touchInstructions, ToolAssistance.inputsLabel));\n        const instructions = ToolAssistance.createInstructions(mainInstruction, sections);\n        IModelApp.notifications.setToolAssistance(instructions);\n    }\n    /** @internal */\n    setupAndPromptForNextAction() {\n        IModelApp.accuSnap.enableSnap(true);\n        this.showPrompt();\n        if (this._isComplete) {\n            AccuDrawHintBuilder.deactivate();\n            return;\n        }\n        if (0 === this._points.length)\n            return;\n        const hints = new AccuDrawHintBuilder();\n        hints.setOrigin(this._points[this._points.length - 1]);\n        if (this._matrix) {\n            if (1 === this._points.length) {\n                hints.setMatrix(this._matrix);\n                hints.setModeRectangular();\n            }\n            else if (this._points.length > 1 && !(this._points[this._points.length - 1].isAlmostEqual(this._points[this._points.length - 2]))) {\n                const xVec = Vector3d.createStartEnd(this._points[this._points.length - 2], this._points[this._points.length - 1]);\n                const zVec = this._matrix.getColumn(2);\n                const matrix = Matrix3d.createRigidFromColumns(xVec, zVec, AxisOrder.XZY);\n                if (undefined !== matrix)\n                    hints.setMatrix(matrix); // Rotate AccuDraw x axis to last segment preserving current up vector...\n            }\n        }\n        hints.setLockZ = true;\n        hints.sendHints();\n    }\n    /** @internal */\n    getShapePoints(cursorPt) {\n        const points = [];\n        if (undefined === this.targetView || this._points.length < 1)\n            return points;\n        for (const pt of this._points)\n            points.push(pt.clone());\n        if (this._isComplete || !this._matrix)\n            return points;\n        const normal = this._matrix.getColumn(2);\n        let currentPt = AccuDrawHintBuilder.projectPointToPlaneInView(cursorPt, points[0], normal, this.targetView, true);\n        if (undefined === currentPt)\n            currentPt = cursorPt.clone();\n        if (2 === points.length && 0 === (IModelApp.toolAdmin.currentInputState.qualifiers & BeModifierKeys.Control)) {\n            const xDir = Vector3d.createStartEnd(points[0], points[1]);\n            const xLen = xDir.magnitude();\n            xDir.normalizeInPlace();\n            const yDir = xDir.crossProduct(normal);\n            yDir.normalizeInPlace();\n            const cornerPt = AccuDrawHintBuilder.projectPointToLineInView(currentPt, points[1], yDir, this.targetView, true);\n            if (undefined !== cornerPt) {\n                points.push(cornerPt);\n                cornerPt.plusScaled(xDir, -xLen, currentPt);\n            }\n        }\n        points.push(currentPt);\n        if (points.length > 2)\n            points.push(points[0].clone());\n        return points;\n    }\n    /** @internal */\n    decorate(context) {\n        if (context.viewport !== this.targetView)\n            return;\n        if (undefined === this._lastMotionPt)\n            return;\n        const points = this.getShapePoints(this._lastMotionPt);\n        if (points.length < 2)\n            return;\n        const builderAccVis = context.createGraphicBuilder(GraphicType.WorldDecoration);\n        const builderAccHid = context.createGraphicBuilder(GraphicType.WorldOverlay);\n        const colorAccVis = ColorDef.white.adjustedForContrast(context.viewport.view.backgroundColor);\n        const colorAccHid = colorAccVis.withAlpha(100);\n        const fillAccVis = context.viewport.hilite.color.withAlpha(50);\n        builderAccVis.setSymbology(colorAccVis, fillAccVis, 3);\n        builderAccHid.setSymbology(colorAccHid, fillAccVis, 1, LinePixels.Code2);\n        if (points.length > 2)\n            builderAccHid.addShape(points);\n        builderAccVis.addLineString(points);\n        builderAccHid.addLineString(points);\n        context.addDecorationFromBuilder(builderAccVis);\n        context.addDecorationFromBuilder(builderAccHid);\n        if (undefined !== this._acceptedMeasurement)\n            this._acceptedMeasurement.addDecoration(context);\n        if (undefined !== this._marker)\n            this._marker.addDecoration(context);\n    }\n    /** @internal */\n    decorateSuspended(context) {\n        if (this._isComplete)\n            this.decorate(context);\n    }\n    /** @internal */\n    async onMouseMotion(ev) {\n        if (this._points.length > 0 && undefined !== ev.viewport && !this._isComplete) {\n            if (undefined !== this._lastMotionPt)\n                this._lastMotionPt.setFrom(ev.point);\n            else\n                this._lastMotionPt = ev.point.clone();\n            ev.viewport.invalidateDecorations();\n        }\n    }\n    async getMarkerToolTip() {\n        const is3d = (undefined === this.targetView || this.targetView.view.is3d());\n        const isSpatial = (undefined !== this.targetView && this.targetView.view.isSpatialView());\n        const toolTip = document.createElement(\"div\");\n        let toolTipHtml = \"\";\n        const areaFormatterSpec = await IModelApp.quantityFormatter.getFormatterSpecByQuantityType(QuantityType.Area);\n        if (undefined !== areaFormatterSpec) {\n            const formattedArea = IModelApp.quantityFormatter.formatQuantity(this._area, areaFormatterSpec);\n            toolTipHtml += `${translateBold(\"Area\") + formattedArea}<br>`;\n        }\n        const perimeterFormatterSpec = await IModelApp.quantityFormatter.getFormatterSpecByQuantityType(QuantityType.Length);\n        if (undefined !== perimeterFormatterSpec) {\n            const formattedPerimeter = IModelApp.quantityFormatter.formatQuantity(this._perimeter, perimeterFormatterSpec);\n            toolTipHtml += `${translateBold(\"Perimeter\") + formattedPerimeter}<br>`;\n        }\n        const coordFormatterSpec = await IModelApp.quantityFormatter.getFormatterSpecByQuantityType(QuantityType.Coordinate);\n        if (undefined !== coordFormatterSpec) {\n            let pointAdjusted = this._centroid.clone();\n            if (isSpatial) {\n                const globalOrigin = this.iModel.globalOrigin;\n                pointAdjusted = pointAdjusted.minus(globalOrigin);\n            }\n            const formattedPointX = IModelApp.quantityFormatter.formatQuantity(pointAdjusted.x, coordFormatterSpec);\n            const formattedPointY = IModelApp.quantityFormatter.formatQuantity(pointAdjusted.y, coordFormatterSpec);\n            const formattedPointZ = IModelApp.quantityFormatter.formatQuantity(pointAdjusted.z, coordFormatterSpec);\n            toolTipHtml += `${translateBold(\"Centroid\") + formattedPointX}, ${formattedPointY}`;\n            if (is3d)\n                toolTipHtml += `, ${formattedPointZ}`;\n            toolTipHtml += \"<br>\";\n        }\n        toolTip.innerHTML = toolTipHtml;\n        return toolTip;\n    }\n    reportMeasurements() {\n        if (undefined === this._marker)\n            return;\n        const briefMsg = `${CoreTools.translate(\"Measure.Labels.Area\")}: ${this._marker.label}`;\n        const msgDetail = new NotifyMessageDetails(OutputMessagePriority.Info, briefMsg, undefined, OutputMessageType.Sticky);\n        IModelApp.notifications.outputMessage(msgDetail);\n    }\n    async updateTotals() {\n        if (this._points.length < 3)\n            return;\n        const result = PolygonOps.centroidAreaNormal(this._points);\n        if (undefined === result)\n            return;\n        this._area = result.a ? result.a : 0.0;\n        this._centroid.setFrom(result.origin);\n        this._perimeter = 0.0;\n        for (let i = 1; i < this._points.length; i++)\n            this._perimeter += (this._points[i - 1].distance(this._points[i]));\n        const toolTip = await this.getMarkerToolTip();\n        this._acceptedMeasurement = new MeasureMarker(\"1\", toolTip, this._centroid, Point2d.create(25, 25));\n        this._marker = undefined;\n        const areaFormatterSpec = await IModelApp.quantityFormatter.getFormatterSpecByQuantityType(QuantityType.Area);\n        if (undefined === areaFormatterSpec)\n            return;\n        const formattedTotalArea = IModelApp.quantityFormatter.formatQuantity(this._area, areaFormatterSpec);\n        this._marker = new MeasureLabel(this._centroid, formattedTotalArea);\n        this.reportMeasurements();\n    }\n    /** @internal */\n    async onDataButtonDown(ev) {\n        if (undefined === this.targetView)\n            return EventHandled.No;\n        if (this._isComplete)\n            await this.onReinitialize();\n        if (this._points.length > 1 && !ev.isControlKey) {\n            const points = this.getShapePoints(ev.point);\n            if (points.length < 3)\n                return EventHandled.No;\n            this._isComplete = true;\n            this._points.length = 0;\n            for (const pt of points)\n                this._points.push(pt);\n            await this.updateTotals();\n            this.setupAndPromptForNextAction();\n            return EventHandled.No;\n        }\n        if (undefined === this._matrix && undefined === (this._matrix = AccuDrawHintBuilder.getContextRotation(this.orientation, this.targetView)))\n            return EventHandled.No;\n        const currPt = ev.point.clone();\n        if (this._points.length > 0) {\n            const planePt = AccuDrawHintBuilder.projectPointToPlaneInView(currPt, this._points[0], this._matrix.getColumn(2), ev.viewport, true);\n            if (undefined !== planePt)\n                currPt.setFrom(planePt);\n        }\n        this._points.push(currPt);\n        this.setupAndPromptForNextAction();\n        return EventHandled.No;\n    }\n    /** @internal */\n    async onResetButtonUp(ev) {\n        if (undefined !== ev.viewport)\n            ev.viewport.invalidateDecorations();\n        await this.onReinitialize();\n        return EventHandled.No;\n    }\n    /** @internal */\n    async onReinitialize() {\n        this._acceptedMeasurement = undefined;\n        this._marker = undefined;\n        this._isComplete = false;\n        this._points.length = 0;\n        this._matrix = undefined;\n        AccuDrawHintBuilder.deactivate();\n        this.setupAndPromptForNextAction();\n    }\n    /** @internal */\n    async onUndoPreviousStep() {\n        if (0 === this._points.length || this._isComplete)\n            return false;\n        this._points.pop();\n        this.setupAndPromptForNextAction();\n        return true;\n    }\n    /** @internal */\n    async onRestartTool() {\n        const tool = new MeasureAreaByPointsTool();\n        if (!await tool.run())\n            return this.exitTool();\n    }\n}\nMeasureAreaByPointsTool.toolId = \"Measure.AreaByPoints\";\nMeasureAreaByPointsTool.iconSpec = \"icon-measure-2d\";\n/** @internal */\nMeasureAreaByPointsTool._orientationName = \"enumAsOrientation\";\n/** @internal */\nMeasureAreaByPointsTool._getEnumAsOrientationDescription = () => {\n    return {\n        name: MeasureAreaByPointsTool._orientationName,\n        displayLabel: CoreTools.translate(\"Settings.Orientation.Label\"),\n        typename: \"enum\",\n        enum: {\n            choices: [\n                { label: MeasureAreaByPointsTool.enumAsOrientationMessage(\"Top\"), value: ContextRotationId.Top },\n                { label: MeasureAreaByPointsTool.enumAsOrientationMessage(\"Front\"), value: ContextRotationId.Front },\n                { label: MeasureAreaByPointsTool.enumAsOrientationMessage(\"Left\"), value: ContextRotationId.Left },\n                { label: MeasureAreaByPointsTool.enumAsOrientationMessage(\"Bottom\"), value: ContextRotationId.Bottom },\n                { label: MeasureAreaByPointsTool.enumAsOrientationMessage(\"Back\"), value: ContextRotationId.Back },\n                { label: MeasureAreaByPointsTool.enumAsOrientationMessage(\"Right\"), value: ContextRotationId.Right },\n                { label: MeasureAreaByPointsTool.enumAsOrientationMessage(\"View\"), value: ContextRotationId.View },\n                { label: MeasureAreaByPointsTool.enumAsOrientationMessage(\"Face\"), value: ContextRotationId.Face },\n            ],\n        },\n    };\n};\nexport { MeasureAreaByPointsTool };\n/** Base class for mass properties tools.\n * @public\n */\nexport class MeasureElementTool extends PrimitiveTool {\n    constructor() {\n        super(...arguments);\n        /** @internal */\n        this._checkedIds = new Map();\n        /** @internal */\n        this._acceptedIds = [];\n        /** @internal */\n        this._acceptedMeasurements = [];\n        /** @internal */\n        this._totalValue = 0.0;\n        /** @internal */\n        this._useSelection = false;\n    }\n    /** @internal */\n    allowView(vp) {\n        return (MassPropertiesOperation.AccumulateVolumes === this.getOperation() ? vp.view.isSpatialView() : (vp.view.isSpatialView() || vp.view.isDrawingView()));\n    }\n    /** @internal */\n    isCompatibleViewport(vp, isSelectedViewChange) { return (super.isCompatibleViewport(vp, isSelectedViewChange) && undefined !== vp && this.allowView(vp)); }\n    /** @internal */\n    requireWriteableTarget() { return false; }\n    /** @internal */\n    async onPostInstall() {\n        await super.onPostInstall();\n        this.setupAndPromptForNextAction();\n    }\n    /** @internal */\n    async onCleanup() {\n        if (0 !== this._acceptedIds.length)\n            this.iModel.hilited.setHilite(this._acceptedIds, false);\n    }\n    /** @internal */\n    async onUnsuspend() { this.showPrompt(); }\n    /** @internal */\n    showPrompt() {\n        const mainMsg = (this._useSelection ? (0 === this._acceptedMeasurements.length ? \"ElementSet.Prompts.ConfirmSelection\" : \"ElementSet.Prompts.InspectResult\") : \"ElementSet.Prompts.IdentifyElement\");\n        const mainInstruction = ToolAssistance.createInstruction(this.iconSpec, CoreTools.translate(mainMsg));\n        const mouseInstructions = [];\n        const touchInstructions = [];\n        if (this._useSelection) {\n            if (0 === this._acceptedMeasurements.length) {\n                touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.OneTouchTap, CoreTools.translate(\"ElementSet.Inputs.AcceptSelection\"), false, ToolAssistanceInputMethod.Touch));\n                mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.LeftClick, CoreTools.translate(\"ElementSet.Inputs.AcceptSelection\"), false, ToolAssistanceInputMethod.Mouse));\n                touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.TwoTouchTap, CoreTools.translate(\"ElementSet.Inputs.RejectSelection\"), false, ToolAssistanceInputMethod.Touch));\n                mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.RightClick, CoreTools.translate(\"ElementSet.Inputs.RejectSelection\"), false, ToolAssistanceInputMethod.Mouse));\n            }\n            else {\n                touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.TwoTouchTap, CoreTools.translate(\"ElementSet.Inputs.Exit\"), false, ToolAssistanceInputMethod.Touch));\n                mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.RightClick, CoreTools.translate(\"ElementSet.Inputs.Exit\"), false, ToolAssistanceInputMethod.Mouse));\n            }\n        }\n        else {\n            touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.OneTouchTap, CoreTools.translate(\"ElementSet.Inputs.AcceptElement\"), false, ToolAssistanceInputMethod.Touch));\n            mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.LeftClick, CoreTools.translate(\"ElementSet.Inputs.AcceptElement\"), false, ToolAssistanceInputMethod.Mouse));\n            if (0 !== this._acceptedMeasurements.length) {\n                touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.TwoTouchTap, CoreTools.translate(\"ElementSet.Inputs.Restart\"), false, ToolAssistanceInputMethod.Touch));\n                mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.RightClick, CoreTools.translate(\"ElementSet.Inputs.Restart\"), false, ToolAssistanceInputMethod.Mouse));\n            }\n        }\n        const sections = [];\n        sections.push(ToolAssistance.createSection(mouseInstructions, ToolAssistance.inputsLabel));\n        sections.push(ToolAssistance.createSection(touchInstructions, ToolAssistance.inputsLabel));\n        const instructions = ToolAssistance.createInstructions(mainInstruction, sections);\n        IModelApp.notifications.setToolAssistance(instructions);\n    }\n    /** @internal */\n    setupAndPromptForNextAction() {\n        this._useSelection = (undefined !== this.targetView && this.targetView.iModel.selectionSet.isActive);\n        if (!this._useSelection)\n            this.initLocateElements();\n        this.showPrompt();\n    }\n    /** @internal */\n    decorate(context) {\n        if (!this.isCompatibleViewport(context.viewport, false))\n            return;\n        this._acceptedMeasurements.forEach((marker) => marker.addDecoration(context));\n        if (undefined !== this._totalMarker)\n            this._totalMarker.addDecoration(context);\n    }\n    /** @internal */\n    decorateSuspended(context) { this.decorate(context); }\n    reportMeasurements() {\n        if (undefined === this._totalMarker)\n            return;\n        let label = \"Measure.Labels.\";\n        switch (this.getOperation()) {\n            case MassPropertiesOperation.AccumulateLengths:\n                label += \"Length\";\n                break;\n            case MassPropertiesOperation.AccumulateAreas:\n                label += \"Area\";\n                break;\n            case MassPropertiesOperation.AccumulateVolumes:\n                label += \"Volume\";\n                break;\n            default:\n                return;\n        }\n        const briefMsg = `${CoreTools.translate(label)}: ${this._totalMarker.label}`;\n        const msgDetail = new NotifyMessageDetails(OutputMessagePriority.Info, briefMsg, undefined, OutputMessageType.Sticky);\n        IModelApp.notifications.outputMessage(msgDetail);\n    }\n    async getMarkerToolTip(responseProps) {\n        const is3d = (undefined === this.targetView || this.targetView.view.is3d());\n        const isSpatial = (undefined !== this.targetView && this.targetView.view.isSpatialView());\n        const toolTip = document.createElement(\"div\");\n        let toolTipHtml = \"\";\n        switch (this.getOperation()) {\n            case MassPropertiesOperation.AccumulateLengths: {\n                const distanceFormatterSpec = await IModelApp.quantityFormatter.getFormatterSpecByQuantityType(QuantityType.Length);\n                if (undefined !== distanceFormatterSpec) {\n                    const formattedLength = IModelApp.quantityFormatter.formatQuantity(responseProps.length ? responseProps.length : 0, distanceFormatterSpec);\n                    toolTipHtml += `${translateBold(\"Length\") + formattedLength}<br>`;\n                }\n                break;\n            }\n            case MassPropertiesOperation.AccumulateAreas: {\n                const areaFormatterSpec = await IModelApp.quantityFormatter.getFormatterSpecByQuantityType(QuantityType.Area);\n                if (undefined !== areaFormatterSpec) {\n                    const formattedArea = IModelApp.quantityFormatter.formatQuantity(responseProps.area ? responseProps.area : 0, areaFormatterSpec);\n                    toolTipHtml += `${translateBold(\"Area\") + formattedArea}<br>`;\n                }\n                if (responseProps.perimeter) {\n                    const perimeterFormatterSpec = await IModelApp.quantityFormatter.getFormatterSpecByQuantityType(QuantityType.Length);\n                    if (undefined !== perimeterFormatterSpec) {\n                        const formattedPerimeter = IModelApp.quantityFormatter.formatQuantity(responseProps.perimeter, perimeterFormatterSpec);\n                        toolTipHtml += `${translateBold(\"Perimeter\") + formattedPerimeter}<br>`;\n                    }\n                }\n                break;\n            }\n            case MassPropertiesOperation.AccumulateVolumes: {\n                const volumeFormatterSpec = await IModelApp.quantityFormatter.getFormatterSpecByQuantityType(QuantityType.Volume);\n                if (undefined !== volumeFormatterSpec) {\n                    const formattedVolume = IModelApp.quantityFormatter.formatQuantity(responseProps.volume ? responseProps.volume : 0, volumeFormatterSpec);\n                    toolTipHtml += `${translateBold(\"Volume\") + formattedVolume}<br>`;\n                }\n                if (responseProps.area) {\n                    const areaFormatterSpec = await IModelApp.quantityFormatter.getFormatterSpecByQuantityType(QuantityType.Area);\n                    if (undefined !== areaFormatterSpec) {\n                        const formattedArea = IModelApp.quantityFormatter.formatQuantity(responseProps.area, areaFormatterSpec);\n                        toolTipHtml += `${translateBold(\"Area\") + formattedArea}<br>`;\n                    }\n                }\n                break;\n            }\n        }\n        if (responseProps.centroid) {\n            const coordFormatterSpec = await IModelApp.quantityFormatter.getFormatterSpecByQuantityType(QuantityType.Coordinate);\n            if (undefined !== coordFormatterSpec) {\n                let pointAdjusted = Point3d.fromJSON(responseProps.centroid);\n                if (isSpatial) {\n                    const globalOrigin = this.iModel.globalOrigin;\n                    pointAdjusted = pointAdjusted.minus(globalOrigin);\n                }\n                const formattedPointX = IModelApp.quantityFormatter.formatQuantity(pointAdjusted.x, coordFormatterSpec);\n                const formattedPointY = IModelApp.quantityFormatter.formatQuantity(pointAdjusted.y, coordFormatterSpec);\n                const formattedPointZ = IModelApp.quantityFormatter.formatQuantity(pointAdjusted.z, coordFormatterSpec);\n                toolTipHtml += `${translateBold(\"Centroid\") + formattedPointX}, ${formattedPointY}`;\n                if (is3d)\n                    toolTipHtml += `, ${formattedPointZ}`;\n                toolTipHtml += \"<br>\";\n            }\n        }\n        toolTip.innerHTML = toolTipHtml;\n        return toolTip;\n    }\n    getResultValue(operation, result) {\n        switch (operation) {\n            case MassPropertiesOperation.AccumulateLengths:\n                return (result.length ? result.length : 0.0);\n            case MassPropertiesOperation.AccumulateAreas:\n                return (result.area ? result.area : 0.0);\n            case MassPropertiesOperation.AccumulateVolumes:\n                return (result.volume ? result.volume : 0.0);\n        }\n    }\n    async updateTotals(selectionSetResult) {\n        this._totalValue = 0.0;\n        this._totalMarker = undefined;\n        let labelPt;\n        const operation = this.getOperation();\n        if (undefined !== selectionSetResult) {\n            labelPt = Point3d.fromJSON(selectionSetResult.centroid);\n            this._totalValue += this.getResultValue(operation, selectionSetResult);\n        }\n        else if (0 !== this._acceptedIds.length) {\n            for (const id of this._acceptedIds) {\n                const result = this._checkedIds.get(id);\n                if (undefined === result)\n                    continue;\n                labelPt = Point3d.fromJSON(result.centroid);\n                this._totalValue += this.getResultValue(operation, result);\n            }\n        }\n        if (0.0 === this._totalValue || undefined === labelPt)\n            return;\n        switch (operation) {\n            case MassPropertiesOperation.AccumulateLengths:\n                const distanceFormatterSpec = await IModelApp.quantityFormatter.getFormatterSpecByQuantityType(QuantityType.Length);\n                if (undefined === distanceFormatterSpec)\n                    return;\n                const formattedTotalDistance = IModelApp.quantityFormatter.formatQuantity(this._totalValue, distanceFormatterSpec);\n                this._totalMarker = new MeasureLabel(labelPt, formattedTotalDistance);\n                break;\n            case MassPropertiesOperation.AccumulateAreas:\n                const areaFormatterSpec = await IModelApp.quantityFormatter.getFormatterSpecByQuantityType(QuantityType.Area);\n                if (undefined === areaFormatterSpec)\n                    return;\n                const formattedTotalArea = IModelApp.quantityFormatter.formatQuantity(this._totalValue, areaFormatterSpec);\n                this._totalMarker = new MeasureLabel(labelPt, formattedTotalArea);\n                break;\n            case MassPropertiesOperation.AccumulateVolumes:\n                const volumeFormatterSpec = await IModelApp.quantityFormatter.getFormatterSpecByQuantityType(QuantityType.Volume);\n                if (undefined === volumeFormatterSpec)\n                    return;\n                const formattedTotalVolume = IModelApp.quantityFormatter.formatQuantity(this._totalValue, volumeFormatterSpec);\n                this._totalMarker = new MeasureLabel(labelPt, formattedTotalVolume);\n                break;\n        }\n        this.reportMeasurements();\n    }\n    /** @internal */\n    async doMeasureSelectedElements(viewport) {\n        const candidates = [];\n        viewport.iModel.selectionSet.elements.forEach((val) => {\n            if (!Id64.isInvalid(val) && !Id64.isTransient(val))\n                candidates.push(val);\n        });\n        if (0 === candidates.length)\n            return;\n        const requestProps = {\n            operation: this.getOperation(),\n            candidates,\n        };\n        const result = await this.iModel.getMassProperties(requestProps);\n        if (BentleyStatus.SUCCESS !== result.status)\n            return;\n        const toolTip = await this.getMarkerToolTip(result);\n        const point = Point3d.fromJSON(result.centroid);\n        const marker = new MeasureMarker((this._acceptedMeasurements.length + 1).toString(), toolTip, point, Point2d.create(25, 25));\n        this._acceptedMeasurements.push(marker);\n        await this.updateTotals(result);\n        this.setupAndPromptForNextAction();\n        if (undefined !== viewport)\n            viewport.invalidateDecorations();\n    }\n    /** @internal */\n    async filterHit(hit, _out) {\n        if (!hit.isElementHit)\n            return LocateFilterStatus.Reject;\n        let result = this._checkedIds.get(hit.sourceId);\n        if (undefined === result) {\n            const requestProps = {\n                operation: this.getOperation(),\n                candidates: [hit.sourceId],\n            };\n            result = await this.iModel.getMassProperties(requestProps);\n            this._checkedIds.set(hit.sourceId, result);\n        }\n        return (BentleyStatus.SUCCESS === result.status ? LocateFilterStatus.Accept : LocateFilterStatus.Reject);\n    }\n    /** @internal */\n    async onReinitialize() {\n        if (this._useSelection)\n            return this.exitTool();\n        return this.onRestartTool();\n    }\n    /** @internal */\n    async onResetButtonUp(_ev) {\n        await this.onReinitialize();\n        return EventHandled.No;\n    }\n    /** @internal */\n    async onDataButtonDown(ev) {\n        if (this._useSelection) {\n            if (0 === this._acceptedMeasurements.length && undefined !== ev.viewport) {\n                await this.doMeasureSelectedElements(ev.viewport);\n                if (0 !== this._acceptedMeasurements.length)\n                    return EventHandled.Yes;\n                IModelApp.notifications.outputMessage(new NotifyMessageDetails(OutputMessagePriority.Error, CoreTools.translate(\"ElementSet.Error.NotSupportedElmType\")));\n                await this.onReinitialize();\n            }\n            return EventHandled.Yes;\n        }\n        const hit = await IModelApp.locateManager.doLocate(new LocateResponse(), true, ev.point, ev.viewport, ev.inputSource);\n        if (undefined === hit || !hit.isElementHit)\n            return EventHandled.No;\n        const result = this._checkedIds.get(hit.sourceId);\n        if (undefined === result)\n            return EventHandled.No;\n        if (-1 !== this._acceptedIds.indexOf(hit.sourceId))\n            return EventHandled.Yes; // Already accepted, not rejected in filterHit to avoid showing \"not\" cursor...\n        const toolTip = await this.getMarkerToolTip(result);\n        const point = result.centroid ? Point3d.fromJSON(result.centroid) : ev.point.clone();\n        const marker = new MeasureMarker((this._acceptedMeasurements.length + 1).toString(), toolTip, point, Point2d.create(25, 25));\n        this._acceptedMeasurements.push(marker);\n        this._acceptedIds.push(hit.sourceId);\n        this.iModel.hilited.setHilite(hit.sourceId, true);\n        await this.updateTotals();\n        this.setupAndPromptForNextAction();\n        if (undefined !== ev.viewport)\n            ev.viewport.invalidateDecorations();\n        return EventHandled.No;\n    }\n    /** @internal */\n    async onUndoPreviousStep() {\n        if (0 === this._acceptedMeasurements.length)\n            return false;\n        this._acceptedMeasurements.pop();\n        if (0 === this._acceptedMeasurements.length) {\n            await this.onReinitialize();\n        }\n        else {\n            if (0 !== this._acceptedIds.length) {\n                this.iModel.hilited.setHilite(this._acceptedIds[this._acceptedIds.length - 1], false);\n                this._acceptedIds.pop();\n            }\n            await this.updateTotals();\n            this.setupAndPromptForNextAction();\n        }\n        return true;\n    }\n}\n/** Report accumulated lengths of selected elements using the current quantity formatter for length.\n * @public\n */\nclass MeasureLengthTool extends MeasureElementTool {\n    getOperation() { return MassPropertiesOperation.AccumulateLengths; }\n    /** @internal */\n    async onRestartTool() {\n        const tool = new MeasureLengthTool();\n        if (!await tool.run())\n            return this.exitTool();\n    }\n}\nMeasureLengthTool.toolId = \"Measure.Length\";\nMeasureLengthTool.iconSpec = \"icon-measure\";\nexport { MeasureLengthTool };\n/** Report accumulated areas of selected elements using the current quantity formatter for area.\n * @public\n */\nclass MeasureAreaTool extends MeasureElementTool {\n    getOperation() { return MassPropertiesOperation.AccumulateAreas; }\n    /** @internal */\n    async onRestartTool() {\n        const tool = new MeasureAreaTool();\n        if (!await tool.run())\n            return this.exitTool();\n    }\n}\nMeasureAreaTool.toolId = \"Measure.Area\";\nMeasureAreaTool.iconSpec = \"icon-measure-area\";\nexport { MeasureAreaTool };\n/** Report accumulated volumes of selected elements using the current quantity formatter for volume.\n * @public\n */\nclass MeasureVolumeTool extends MeasureElementTool {\n    getOperation() { return MassPropertiesOperation.AccumulateVolumes; }\n    /** @internal */\n    async onRestartTool() {\n        const tool = new MeasureVolumeTool();\n        if (!await tool.run())\n            return this.exitTool();\n    }\n}\nMeasureVolumeTool.toolId = \"Measure.Volume\";\nMeasureVolumeTool.iconSpec = \"icon-measure-3d\";\nexport { MeasureVolumeTool };\n//# sourceMappingURL=MeasureTool.js.map",
      "start": 1693508119742,
      "end": 1693508120017,
      "sourcemaps": null
    }
  ]
}
