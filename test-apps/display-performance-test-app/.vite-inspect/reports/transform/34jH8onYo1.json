{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/Geometry.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\nimport { Vector2d } from \"./geometry3d/Point2dVector2d\";\nimport { Vector3d } from \"./geometry3d/Point3dVector3d\";\n/* eslint-disable @typescript-eslint/naming-convention, no-empty */\n/**\n * Enumeration of the 6 possible orderings of XYZ axis order\n * * **Note:** There are 3 axis order with right hand system (XYZ = 0, YZX = 1, ZXY = 2) and 3 axis order with\n * left hand system (XZY = 4, YXZ = 5, ZYX = 6). Note that `AxisOrder` is encoding the handedness as well. Cross\n * product of the i_th axis in an ordering (i=0,1,2), with the i+1_th in that ordering, will produce the i+2_th\n * axis in that ordering.\n * @public\n */\nexport var AxisOrder;\n(function (AxisOrder) {\n    /** Right handed system, X then Y then Z */\n    AxisOrder[AxisOrder[\"XYZ\"] = 0] = \"XYZ\";\n    /** Right handed system, Y then Z then X */\n    AxisOrder[AxisOrder[\"YZX\"] = 1] = \"YZX\";\n    /** Right handed system, Z then X then Y */\n    AxisOrder[AxisOrder[\"ZXY\"] = 2] = \"ZXY\";\n    /** Left handed system, X then Z then Y */\n    AxisOrder[AxisOrder[\"XZY\"] = 4] = \"XZY\";\n    /** Left handed system, Y then X then Z */\n    AxisOrder[AxisOrder[\"YXZ\"] = 5] = \"YXZ\";\n    /** Left handed system, Z then Y then X */\n    AxisOrder[AxisOrder[\"ZYX\"] = 6] = \"ZYX\";\n})(AxisOrder || (AxisOrder = {}));\n/**\n * Enumeration of numeric indices of 3 axes AxisIndex.X, AxisIndex.Y, AxisIndex.Z\n * @public\n */\nexport var AxisIndex;\n(function (AxisIndex) {\n    /** x axis is index 0 */\n    AxisIndex[AxisIndex[\"X\"] = 0] = \"X\";\n    /** y axis is index 1 */\n    AxisIndex[AxisIndex[\"Y\"] = 1] = \"Y\";\n    /** 2 axis is index 2 */\n    AxisIndex[AxisIndex[\"Z\"] = 2] = \"Z\";\n})(AxisIndex || (AxisIndex = {}));\n/**\n * Standard views. Used in `Matrix3d.createStandardViewAxes(index: StandardViewIndex, invert: boolean)`\n * @public\n */\nexport var StandardViewIndex;\n(function (StandardViewIndex) {\n    /** X to right, Y up */\n    StandardViewIndex[StandardViewIndex[\"Top\"] = 1] = \"Top\";\n    /** X to right, negative Y up */\n    StandardViewIndex[StandardViewIndex[\"Bottom\"] = 2] = \"Bottom\";\n    /** Negative Y to right, Z up */\n    StandardViewIndex[StandardViewIndex[\"Left\"] = 3] = \"Left\";\n    /** Y to right, Z up */\n    StandardViewIndex[StandardViewIndex[\"Right\"] = 4] = \"Right\";\n    /** X to right, Z up */\n    StandardViewIndex[StandardViewIndex[\"Front\"] = 5] = \"Front\";\n    /** Negative X to right, Z up */\n    StandardViewIndex[StandardViewIndex[\"Back\"] = 6] = \"Back\";\n    /** Isometric: view towards origin from (-1,-1,1) */\n    StandardViewIndex[StandardViewIndex[\"Iso\"] = 7] = \"Iso\";\n    /** Right isometric: view towards origin from (1,-1,1) */\n    StandardViewIndex[StandardViewIndex[\"RightIso\"] = 8] = \"RightIso\";\n})(StandardViewIndex || (StandardViewIndex = {}));\n/**\n * Enumeration among choice for how a coordinate transformation should incorporate scaling.\n * @public\n */\nexport var AxisScaleSelect;\n(function (AxisScaleSelect) {\n    /** All axes of unit length. */\n    AxisScaleSelect[AxisScaleSelect[\"Unit\"] = 0] = \"Unit\";\n    /** On each axis, the vector length matches the longest side of the range of the data. */\n    AxisScaleSelect[AxisScaleSelect[\"LongestRangeDirection\"] = 1] = \"LongestRangeDirection\";\n    /** On each axis, the vector length matches he length of the corresponding edge of the range. */\n    AxisScaleSelect[AxisScaleSelect[\"NonUniformRangeContainment\"] = 2] = \"NonUniformRangeContainment\";\n})(AxisScaleSelect || (AxisScaleSelect = {}));\n/**\n * Enumeration of possible locations of a point in the plane of a polygon.\n * @public\n */\nexport var PolygonLocation;\n(function (PolygonLocation) {\n    /** No location specified. */\n    PolygonLocation[PolygonLocation[\"Unknown\"] = 0] = \"Unknown\";\n    /** Point is at a vertex. */\n    PolygonLocation[PolygonLocation[\"OnPolygonVertex\"] = 1] = \"OnPolygonVertex\";\n    /** Point is on an edge (but not a vertex). */\n    PolygonLocation[PolygonLocation[\"OnPolygonEdgeInterior\"] = 2] = \"OnPolygonEdgeInterior\";\n    /** Point is strictly inside the polygon with unknown projection. */\n    PolygonLocation[PolygonLocation[\"InsidePolygon\"] = 3] = \"InsidePolygon\";\n    /** Point is strictly inside the polygon and projects to a vertex. */\n    PolygonLocation[PolygonLocation[\"InsidePolygonProjectsToVertex\"] = 4] = \"InsidePolygonProjectsToVertex\";\n    /** Point is strictly inside the polygon and projects to an edge (but not a vertex). */\n    PolygonLocation[PolygonLocation[\"InsidePolygonProjectsToEdgeInterior\"] = 5] = \"InsidePolygonProjectsToEdgeInterior\";\n    /** Point is strictly outside the polygon with unknown projection. */\n    PolygonLocation[PolygonLocation[\"OutsidePolygon\"] = 6] = \"OutsidePolygon\";\n    /** Point is strictly outside the polygon and projects to a vertex. */\n    PolygonLocation[PolygonLocation[\"OutsidePolygonProjectsToVertex\"] = 7] = \"OutsidePolygonProjectsToVertex\";\n    /** Point is strictly outside the polygon and projects to an edge (but not a vertex). */\n    PolygonLocation[PolygonLocation[\"OutsidePolygonProjectsToEdgeInterior\"] = 8] = \"OutsidePolygonProjectsToEdgeInterior\";\n})(PolygonLocation || (PolygonLocation = {}));\n/**\n * Class containing static methods for typical numeric operations.\n * * Experimentally, methods like Geometry.hypotenuse are observed to be faster than the system intrinsics.\n * * This is probably due to\n *    * Fixed length arg lists\n *    * strongly typed parameters\n * @public\n */\nclass Geometry {\n    /** Test if absolute value of x is large (larger than `Geometry.largeCoordinateResult`) */\n    static isLargeCoordinateResult(x) {\n        return x > this.largeCoordinateResult || x < -this.largeCoordinateResult;\n    }\n    /**\n     * Test if absolute value of x is large (larger than `Geometry.largeCoordinateResult`).\n     * @deprecated in 4.x. Use `isLargeCoordinateResult`.\n     */\n    static isHugeCoordinate(x) {\n        return Geometry.isLargeCoordinateResult(x);\n    }\n    /** Test if a number is odd */\n    static isOdd(x) {\n        return (x & (0x01)) === 1; // bitwise operation\n    }\n    /**\n     * Correct distance to zero.\n     * * If `distance` magnitude is `undefined` or smaller than `smallMetricDistance`, then return `replacement`\n     * (or 0 if replacement is not passed). Otherwise return `distance`.\n     */\n    static correctSmallMetricDistance(distance, replacement = 0.0) {\n        if (distance === undefined || Math.abs(distance) < Geometry.smallMetricDistance) {\n            return replacement;\n        }\n        return distance;\n    }\n    /**\n     * Correct `fraction` to `replacement` if `fraction` is undefined or too small.\n     * @param fraction number to test\n     * @param replacement value to return if `fraction` is too small\n     * @returns `fraction` if its absolute value is at least `Geometry.smallFraction`; otherwise returns `replacement`\n     */\n    static correctSmallFraction(fraction, replacement = 0.0) {\n        if (fraction === undefined || Math.abs(fraction) < Geometry.smallFraction) {\n            return replacement;\n        }\n        return fraction;\n    }\n    /**\n     * Return the inverse of `distance`.\n     * * If `distance` magnitude is smaller than `smallMetricDistance` (i.e. distance is large enough for safe division),\n     * then return `1/distance`. Otherwise return `undefined`.\n     */\n    static inverseMetricDistance(distance) {\n        return (Math.abs(distance) <= Geometry.smallMetricDistance) ? undefined : 1.0 / distance;\n    }\n    /**\n     * Return the inverse of `distanceSquared`.\n     * * If `distanceSquared ` magnitude is smaller than `smallMetricDistanceSquared` (i.e. distanceSquared  is large\n     * enough for safe division), then return `1/distanceSquared `. Otherwise return `undefined`.\n     */\n    static inverseMetricDistanceSquared(distanceSquared) {\n        return (Math.abs(distanceSquared) <= Geometry.smallMetricDistanceSquared) ? undefined : 1.0 / distanceSquared;\n    }\n    /**\n     * Boolean test for metric coordinate near-equality (i.e., if `x` and `y` are almost equal) using `tolerance`.\n     * * `Geometry.smallMetricDistance` is used if tolerance is `undefined`.\n     */\n    static isSameCoordinate(x, y, tolerance = Geometry.smallMetricDistance) {\n        let d = x - y;\n        if (d < 0)\n            d = -d;\n        return d <= tolerance;\n    }\n    /**\n     * Boolean test for metric coordinate near-equality (i.e., if `x` and `y` are almost equal) using\n     * `tolerance = toleranceFactor * smallMetricDistance`\n     * */\n    static isSameCoordinateWithToleranceFactor(x, y, toleranceFactor) {\n        return Geometry.isSameCoordinate(x, y, toleranceFactor * Geometry.smallMetricDistance);\n    }\n    /**\n     * Boolean test for metric coordinate pair near-equality (i.e., if `x0` and `x1` are almost equal\n     * and `y0` and `y1` are almost equal) using `tolerance`.\n     * * `Geometry.smallMetricDistance` is used if tolerance is `undefined`.\n     */\n    static isSameCoordinateXY(x0, y0, x1, y1, tolerance = Geometry.smallMetricDistance) {\n        let d = x1 - x0;\n        if (d < 0)\n            d = -d;\n        if (d > tolerance)\n            return false;\n        d = y1 - y0;\n        if (d < 0)\n            d = -d;\n        return d <= tolerance;\n    }\n    /**\n     * Boolean test for squared metric coordinate near-equality (i.e., if `sqrt(x)` and `sqrt(y)` are\n     * almost equal) using `tolerance`.\n     * * `Geometry.smallMetricDistance` is used if tolerance is `undefined`.\n     */\n    static isSameCoordinateSquared(x, y, tolerance = Geometry.smallMetricDistance) {\n        return Math.abs(Math.sqrt(x) - Math.sqrt(y)) <= tolerance;\n    }\n    /**\n     * Boolean test for small `dataA.distance(dataB)` within `tolerance`.\n     * * `Geometry.smallMetricDistance` is used if tolerance is `undefined`.\n     */\n    static isSamePoint3d(dataA, dataB, tolerance = Geometry.smallMetricDistance) {\n        return dataA.distance(dataB) <= tolerance;\n    }\n    /**\n     * Boolean test for small xyz-distance within `tolerance`.\n     * * `Geometry.smallMetricDistance` is used if tolerance is `undefined`.\n     * * Note that Point3d and Vector3d are both derived from XYZ, so this method tolerates mixed types.\n     */\n    static isSameXYZ(dataA, dataB, tolerance = Geometry.smallMetricDistance) {\n        return dataA.distance(dataB) <= tolerance;\n    }\n    /**\n     * Boolean test for small xy-distance (ignoring z) within `tolerance`.\n     * * `Geometry.smallMetricDistance` is used if tolerance is `undefined`.\n     */\n    static isSamePoint3dXY(dataA, dataB, tolerance = Geometry.smallMetricDistance) {\n        return dataA.distanceXY(dataB) <= tolerance;\n    }\n    /**\n     * Boolean test for small xyz-distance within `tolerance`.\n     * * `Geometry.smallMetricDistance` is used if tolerance is `undefined`.\n     */\n    static isSameVector3d(dataA, dataB, tolerance = Geometry.smallMetricDistance) {\n        return dataA.distance(dataB) <= tolerance;\n    }\n    /**\n     * Boolean test for small xy-distance within `tolerance`.\n     * * `Geometry.smallMetricDistance` is used if tolerance is `undefined`.\n     */\n    static isSamePoint2d(dataA, dataB, tolerance = Geometry.smallMetricDistance) {\n        return dataA.distance(dataB) <= tolerance;\n    }\n    /**\n     * Boolean test for small xy-distance within `tolerance`.\n     * * `Geometry.smallMetricDistance` is used if tolerance is `undefined`.\n     */\n    static isSameVector2d(dataA, dataB, tolerance = Geometry.smallMetricDistance) {\n        return dataA.distance(dataB) <= tolerance;\n    }\n    /**\n     * Lexical comparison of (a.x, a.y) and (b.x, b.y) with x as first test and y as second (z is ignored).\n     * * This is appropriate for a horizontal sweep in the plane.\n     */\n    static lexicalXYLessThan(a, b) {\n        if (a.x < b.x)\n            return -1;\n        else if (a.x > b.x)\n            return 1;\n        if (a.y < b.y)\n            return -1;\n        else if (a.y > b.y)\n            return 1;\n        return 0;\n    }\n    /**\n     * Lexical comparison of (a.x, a.y) and (b.x, b.y) with y as first test and x as second (z is ignored).\n     * * This is appropriate for a vertical sweep in the plane.\n     */\n    static lexicalYXLessThan(a, b) {\n        if (a.y < b.y)\n            return -1;\n        else if (a.y > b.y)\n            return 1;\n        if (a.x < b.x)\n            return -1;\n        else if (a.x > b.x)\n            return 1;\n        return 0;\n    }\n    /** Lexical comparison of (a.x, a.y, a.z) and (b.x, b.y, b.z) with x as first test, y as second, and z as third. */\n    static lexicalXYZLessThan(a, b) {\n        if (a.x < b.x)\n            return -1;\n        else if (a.x > b.x)\n            return 1;\n        if (a.y < b.y)\n            return -1;\n        else if (a.y > b.y)\n            return 1;\n        if (a.z < b.z)\n            return -1;\n        else if (a.z > b.z)\n            return 1;\n        return 0;\n    }\n    /**\n     * Test if `value` is small compared to `smallFraction`.\n     * * This is appropriate if `value` is know to be a typical 0..1 fraction.\n     */\n    static isSmallRelative(value) {\n        return Math.abs(value) < Geometry.smallFraction;\n    }\n    /** Test if `value` is small compared to `smallAngleRadians` */\n    static isSmallAngleRadians(value) {\n        return Math.abs(value) < Geometry.smallAngleRadians;\n    }\n    /**\n     * Returns `true` if both values are `undefined` or if both are defined and almost equal within tolerance.\n     * If one is `undefined` and the other is not, then `false` is returned.\n     */\n    static isAlmostEqualOptional(a, b, tolerance) {\n        if (a !== undefined && b !== undefined) {\n            if (Math.abs(a - b) > tolerance)\n                return false;\n        }\n        else {\n            if (a !== undefined || b !== undefined)\n                return false;\n        }\n        return true;\n    }\n    /**\n     * Toleranced equality test using tolerance `tolerance * ( 1 + abs(a) + abs(b) )`.\n     * * `Geometry.smallAngleRadians` is used if tolerance is `undefined`.\n     */\n    static isAlmostEqualNumber(a, b, tolerance = Geometry.smallAngleRadians) {\n        const sumAbs = 1.0 + Math.abs(a) + Math.abs(b);\n        return Math.abs(a - b) <= tolerance * sumAbs;\n    }\n    /**\n     * Toleranced equality test using tolerance `tolerance * ( 1 + abs(a.x) + abs(a.y) + abs(b.x) + abs(b.y) )`.\n     * * `Geometry.smallAngleRadians` is used if tolerance is `undefined`.\n     */\n    static isAlmostEqualXAndY(a, b, tolerance = Geometry.smallAngleRadians) {\n        const tol = tolerance * (1.0 + Math.abs(a.x) + Math.abs(b.x) + Math.abs(a.y) + Math.abs(b.y));\n        return (Math.abs(a.x - b.x) <= tol) && (Math.abs(a.y - b.y) <= tol);\n    }\n    /**\n     * Toleranced equality test using caller-supplied `tolerance`.\n     * * `Geometry.smallMetricDistance` is used if tolerance is `undefined`.\n     */\n    static isDistanceWithinTol(distance, tolerance = Geometry.smallMetricDistance) {\n        return Math.abs(distance) <= tolerance;\n    }\n    /** Toleranced equality test using `smallMetricDistance` tolerance. */\n    static isSmallMetricDistance(distance) {\n        return Math.abs(distance) <= Geometry.smallMetricDistance;\n    }\n    /** Toleranced equality test using `smallMetricDistanceSquared` tolerance. */\n    static isSmallMetricDistanceSquared(distanceSquared) {\n        return Math.abs(distanceSquared) <= Geometry.smallMetricDistanceSquared;\n    }\n    /**\n     * Return `axis modulo 3` with proper handling of negative indices\n     * ..., -3:x, -2:y, -1:z, 0:x, 1:y, 2:z, 3:x, 4:y, 5:z, 6:x, 7:y, 8:z, ...\n     */\n    static cyclic3dAxis(axis) {\n        /* Direct test for the most common cases to avoid more expensive modulo operation */\n        if (axis >= 0) {\n            if (axis < 3)\n                return axis;\n            if (axis < 6)\n                return axis - 3;\n            return axis % 3;\n        }\n        const j = axis + 3;\n        if (j >= 0)\n            return j;\n        return 2 - ((-axis - 1) % 3);\n    }\n    /**\n     * Return the `AxisOrder` for which `axisIndex` is the first named axis.\n     * * `axisIndex === 0` returns `AxisOrder.XYZ`\n     * * `axisIndex === 1` returns `AxisOrder.YZX`\n     * * `axisIndex === 2` returns `AxisOrder.ZXY`\n     */\n    static axisIndexToRightHandedAxisOrder(axisIndex) {\n        if (axisIndex === 0)\n            return AxisOrder.XYZ;\n        if (axisIndex === 1)\n            return AxisOrder.YZX;\n        if (axisIndex === 2)\n            return AxisOrder.ZXY;\n        return Geometry.axisIndexToRightHandedAxisOrder(Geometry.cyclic3dAxis(axisIndex));\n    }\n    /** Return the largest signed value among `a`, `b`, and `c` */\n    static maxXYZ(a, b, c) {\n        let max = a;\n        if (b > max)\n            max = b;\n        if (c > max)\n            max = c;\n        return max;\n    }\n    /** Return the smallest signed value among `a`, `b`, and `c` */\n    static minXYZ(a, b, c) {\n        let min = a;\n        if (b < min)\n            min = b;\n        if (c < min)\n            min = c;\n        return min;\n    }\n    /** Return the largest signed value among `a` and `b` */\n    static maxXY(a, b) {\n        let max = a;\n        if (b > max)\n            max = b;\n        return max;\n    }\n    /** Return the smallest signed value among `a` and `b` */\n    static minXY(a, b) {\n        let min = a;\n        if (b < min)\n            min = b;\n        return min;\n    }\n    /** Return the largest absolute value among `x`, `y`, and `z` */\n    static maxAbsXYZ(x, y, z) {\n        return Geometry.maxXYZ(Math.abs(x), Math.abs(y), Math.abs(z));\n    }\n    /** Return the largest absolute value among `x` and `y` */\n    static maxAbsXY(x, y) {\n        return Geometry.maxXY(Math.abs(x), Math.abs(y));\n    }\n    /** Return the largest absolute distance from `a` to either of `b0` or `b1` */\n    static maxAbsDiff(a, b0, b1) {\n        return Math.max(Math.abs(a - b0), Math.abs(a - b1));\n    }\n    /**\n     * Examine the sign of `x`.\n     * * If `x` is negative, return `outNegative`\n     * * If `x` is true zero, return `outZero`\n     * * If `x` is positive, return `outPositive`\n     */\n    static split3WaySign(x, outNegative, outZero, outPositive) {\n        if (x < 0)\n            return outNegative;\n        if (x > 0.0)\n            return outPositive;\n        return outZero;\n    }\n    /**\n     * Examine the value (particularly sign) of x.\n     * * If x is negative, return -1\n     * * If x is true zero, return 0\n     * * If x is positive, return 1\n     */\n    static split3Way01(x, tolerance = Geometry.smallMetricDistance) {\n        if (x > tolerance)\n            return 1;\n        if (x < -tolerance)\n            return -1;\n        return 0;\n    }\n    /** Return the square of x */\n    static square(x) {\n        return x * x;\n    }\n    /**\n     * Return the hypotenuse (i.e., `sqrt(x*x + y*y)`).\n     * * This is much faster than `Math.hypot(x,y)`.\n     */\n    static hypotenuseXY(x, y) {\n        return Math.sqrt(x * x + y * y);\n    }\n    /** Return the squared hypotenuse (i.e., `x*x + y*y`). */\n    static hypotenuseSquaredXY(x, y) {\n        return x * x + y * y;\n    }\n    /**\n     * Return the hypotenuse (i.e., `sqrt(x*x + y*y + z*z)`).\n     * * This is much faster than `Math.hypot(x,y,z)`.\n     */\n    static hypotenuseXYZ(x, y, z) {\n        return Math.sqrt(x * x + y * y + z * z);\n    }\n    /** Return the squared hypotenuse (i.e., `x*x + y*y + z*z`). */\n    static hypotenuseSquaredXYZ(x, y, z) {\n        return x * x + y * y + z * z;\n    }\n    /**\n     * Return the full 4d hypotenuse (i.e., `sqrt(x*x + y*y + z*z + w*w)`).\n     * * This is much faster than `Math.hypot(x,y,z,w)`.\n     */\n    static hypotenuseXYZW(x, y, z, w) {\n        return Math.sqrt(x * x + y * y + z * z + w * w);\n    }\n    /** Return the squared hypotenuse (i.e., `x*x + y*y + z*z + w*w`). */\n    static hypotenuseSquaredXYZW(x, y, z, w) {\n        return x * x + y * y + z * z + w * w;\n    }\n    /**\n     * Return the distance between xy points given as numbers.\n     * @param x0 x coordinate of point 0\n     * @param y0 y coordinate of point 0\n     * @param x1 x coordinate of point 1\n     * @param y1 y coordinate of point 1\n     */\n    static distanceXYXY(x0, y0, x1, y1) {\n        return Geometry.hypotenuseXY(x1 - x0, y1 - y0);\n    }\n    /**\n     * Return the distance between xyz points given as numbers.\n     * @param x0 x coordinate of point 0\n     * @param y0 y coordinate of point 0\n     * @param z0 z coordinate of point 0\n     * @param x1 x coordinate of point 1\n     * @param y1 y coordinate of point 1\n     * @param z1 z coordinate of point 1\n     */\n    static distanceXYZXYZ(x0, y0, z0, x1, y1, z1) {\n        return Geometry.hypotenuseXYZ(x1 - x0, y1 - y0, z1 - z0);\n    }\n    /**\n     * Returns the triple product of 3 vectors provided as x,y,z number sequences.\n     * * The triple product is the determinant of the 3x3 matrix with the 9 numbers (3 vectors placed in 3 rows).\n     * * The triple product is positive if the 3 vectors form a right handed coordinate system.\n     * * The triple product is negative if the 3 vectors form a left handed coordinate system.\n     * * Treating the 9 numbers as 3 vectors U, V, W, any of these formulas gives the same result:\n     *     * U dot (V cross W)\n     *     * V dot (W cross U)\n     *     * W dot (U cross V)\n     *     * -U dot (W cross V)\n     *     * -V dot (U cross W)\n     *     * -W dot (V cross U)\n     * * Note the negative in the last 3 formulas. Reversing cross product order changes the sign.\n     * * The triple product is 6 times the (signed) volume of the tetrahedron with the three vectors as edges from a\n     * common vertex.\n     */\n    static tripleProduct(ux, uy, uz, vx, vy, vz, wx, wy, wz) {\n        return ux * (vy * wz - vz * wy)\n            + uy * (vz * wx - vx * wz)\n            + uz * (vx * wy - vy * wx);\n    }\n    /** Returns the determinant of the 4x4 matrix unrolled as the 16 parameters */\n    static determinant4x4(xx, xy, xz, xw, yx, yy, yz, yw, zx, zy, zz, zw, wx, wy, wz, ww) {\n        return xx * this.tripleProduct(yy, yz, yw, zy, zz, zw, wy, wz, ww)\n            - yx * this.tripleProduct(xy, xz, xw, zy, zz, zw, wy, wz, ww)\n            + zx * this.tripleProduct(xy, xz, xw, yy, yz, yw, wy, wz, ww)\n            - wx * this.tripleProduct(xy, xz, xw, yy, yz, yw, zy, zz, zw);\n    }\n    /**\n     * Returns the determinant of 3x3 matrix with first and second rows created from the 3 xy points and the third\n     * row created from the 3 numbers:\n     *      [columnA.x   columnB.x   columnC.x]\n     *      [columnA.y   columnB.y   columnC.y]\n     *      [ weightA     weightB     weightC ]\n     */\n    static tripleProductXYW(columnA, weightA, columnB, weightB, columnC, weightC) {\n        return Geometry.tripleProduct(columnA.x, columnB.x, columnC.x, columnA.y, columnB.y, columnC.y, weightA, weightB, weightC);\n    }\n    /**\n     * Returns the determinant of 3x3 matrix columns created by the given `Point4d` ignoring the z part:\n     *      [columnA.x   columnB.x   columnC.x]\n     *      [columnA.y   columnB.y   columnC.y]\n     *      [columnA.w   columnB.w   columnC.w]\n     */\n    static tripleProductPoint4dXYW(columnA, columnB, columnC) {\n        return Geometry.tripleProduct(columnA.x, columnB.x, columnC.x, columnA.y, columnB.y, columnC.y, columnA.w, columnB.w, columnC.w);\n    }\n    /** 2D cross product of vectors with the vectors presented as numbers. */\n    static crossProductXYXY(ux, uy, vx, vy) {\n        return ux * vy - uy * vx;\n    }\n    /** 3D cross product of vectors with the vectors presented as numbers. */\n    static crossProductXYZXYZ(ux, uy, uz, vx, vy, vz, result) {\n        return Vector3d.create(uy * vz - uz * vy, uz * vx - ux * vz, ux * vy - uy * vx, result);\n    }\n    /** Magnitude of 3D cross product of vectors with the vectors presented as numbers. */\n    static crossProductMagnitude(ux, uy, uz, vx, vy, vz) {\n        return Geometry.hypotenuseXYZ(uy * vz - uz * vy, uz * vx - ux * vz, ux * vy - uy * vx);\n    }\n    /** 2D dot product of vectors with the vectors presented as numbers. */\n    static dotProductXYXY(ux, uy, vx, vy) {\n        return ux * vx + uy * vy;\n    }\n    /** 3D dot product of vectors with the vectors presented as numbers. */\n    static dotProductXYZXYZ(ux, uy, uz, vx, vy, vz) {\n        return ux * vx + uy * vy + uz * vz;\n    }\n    /**\n     * Return the mean curvature for two radii.\n     * * Curvature is the reciprocal of radius.\n     * * 0 radius implies 0 curvature.\n     * @param r0 first radius\n     * @param r1 second radius\n     */\n    static meanCurvatureOfRadii(r0, r1) {\n        return 0.5 * (this.safeDivideFraction(1, r0, 0) + this.safeDivideFraction(1, r1, 0));\n    }\n    /**\n     * Returns curvature from the first and second derivative vectors.\n     * * If U is the first derivative and V is the second derivative, the curvature is defined as:\n     *     * `|| U x V || / || U ||^3`.\n     * * Math details can be found at https://en.wikipedia.org/wiki/Curvature#General_expressions\n     * @param ux first derivative x component\n     * @param uy first derivative y component\n     * @param uz first derivative z component\n     * @param vx second derivative x component\n     * @param vy second derivative y component\n     * @param vz second derivative z component\n     */\n    static curvatureMagnitude(ux, uy, uz, vx, vy, vz) {\n        let q = uy * vz - uz * vy;\n        let sum = q * q;\n        q = uz * vx - ux * vz;\n        sum += q * q;\n        q = ux * vy - uy * vx;\n        sum += q * q;\n        const magUxV = Math.sqrt(sum);\n        const magU = Math.sqrt(ux * ux + uy * uy + uz * uz);\n        const magUCubed = magU * magU * magU;\n        if (magUCubed > Geometry.smallAngleRadians * magUxV)\n            return magUxV / magUCubed;\n        return 0;\n    }\n    /**\n     * Clamp to (min(a,b), max(a,b)).\n     * * Always returns a number between `a` and `b`.\n     * @param value value to clamp\n     * @param a smallest allowed output if `a < b` or largest allowed output if `a > b`\n     * @param b largest allowed output if `a < b` or smallest allowed output if `a > b`\n     */\n    static clampToStartEnd(value, a, b) {\n        if (a > b)\n            return Geometry.clampToStartEnd(value, b, a);\n        if (value < a)\n            return a;\n        if (b < value)\n            return b;\n        return value;\n    }\n    /**\n     * Clamp value to (min, max) with no test for order of (min, max).\n     * * Always returns a number between `min` and `max`.\n     * @param value value to clamp\n     * @param min smallest allowed output\n     * @param max largest allowed output\n     */\n    static clamp(value, min, max) {\n        return Math.max(min, Math.min(max, value));\n    }\n    /** If given a `value`, return it. If given `undefined`, return `defaultValue`. */\n    static resolveNumber(value, defaultValue = 0) {\n        return value !== undefined ? value : defaultValue;\n    }\n    /** If given a `value`, return it. If given `undefined`, return `defaultValue`. */\n    static resolveValue(value, defaultValue) {\n        return value !== undefined ? value : defaultValue;\n    }\n    /** If given `value` matches the `targetValue`, return `undefined`. Otherwise return the `value`. */\n    static resolveToUndefined(value, targetValue) {\n        return value === targetValue ? undefined : value;\n    }\n    /**\n     * Simple interpolation between values `a` and `b` with fraction `f`.\n     * * If `f = 0`, then `a` is returned and if `f = 1`, then `b` is returned.\n     * * For maximum accuracy, we choose `a` or `b` as starting point based on fraction `f`.\n     */\n    static interpolate(a, f, b) {\n        return f <= 0.5 ? a + f * (b - a) : b - (1.0 - f) * (b - a);\n    }\n    /**\n     * Given an `axisOrder` (e.g. XYZ, YZX, etc) and an `index`, return the `axis` at the given index.\n     * * For example, if `axisOrder = XYZ`, then for index 0 return `X` (or axis 0), for index 1 return\n     * `Y` (or axis 1), and for index 2 return `Z` (or axis 2).\n     * * Another example: if `axisOrder = ZXY`, then for index 0 return `Z` (or axis 2), for index 1 return\n     * `X` (or axis 0), and for index 2 return `Y` (or axis 1).\n     * * For indexes greater than 2 or smaller than 0, it return cyclic axis. See [[Geometry.cyclic3dAxis]]\n     * for more info.\n     */\n    static axisOrderToAxis(order, index) {\n        const axis = order <= AxisOrder.ZXY ? order + index : (order - AxisOrder.XZY) - index;\n        return Geometry.cyclic3dAxis(axis);\n    }\n    /**\n     * Return `a` modulo `period`.\n     * * Both `a` and `period` can be negative.\n     * * This function can be faster than the `%` operator for the common case when `p > 0` and `-p < a < 2p`.\n     */\n    static modulo(a, period) {\n        // period is negative\n        if (period <= 0) {\n            if (period === 0)\n                return a;\n            return -Geometry.modulo(-a, -period);\n        }\n        // period is positive\n        if (a >= 0) {\n            if (a < period) // \"0 < a < period\"\n                return a;\n            if (a < 2 * period) // \"0 < period < a < 2*period\"\n                return a - period;\n        }\n        else { // \"-period < a < 0\"\n            a += period;\n            if (a > 0)\n                return a;\n        }\n        // \"0 < 2*period < a\" or \"a < -period < 0\"\n        const m = Math.floor(a / period);\n        return a - m * period;\n    }\n    /** Return 0 if the value is `undefined` and 1 if the value is defined. */\n    static defined01(value) {\n        return value === undefined ? 0 : 1;\n    }\n    /**\n     * Return `numerator` divided by `denominator`.\n     * @param numerator the numerator\n     * @param denominator the denominator\n     * @returns return `numerator/denominator` but if the ratio exceeds `Geometry.largeFractionResult`,\n     * return `undefined`.\n     */\n    static conditionalDivideFraction(numerator, denominator) {\n        if (Math.abs(denominator) * Geometry.largeFractionResult > Math.abs(numerator))\n            return numerator / denominator;\n        return undefined;\n    }\n    /**\n     * Return `numerator` divided by `denominator`.\n     * @param numerator the numerator\n     * @param denominator the denominator\n     * @returns return `numerator/denominator` but if the ratio exceeds `Geometry.largeFractionResult`,\n     * return `defaultResult`.\n     */\n    static safeDivideFraction(numerator, denominator, defaultResult) {\n        const ratio = Geometry.conditionalDivideFraction(numerator, denominator);\n        if (ratio !== undefined)\n            return ratio;\n        return defaultResult;\n    }\n    /**\n     * Return `numerator` divided by `denominator` (with a given `largestResult`).\n     * @param numerator the numerator\n     * @param denominator the denominator\n     * @param largestResult the ratio threshold\n     * @returns return `numerator/denominator` but if the ratio exceeds `largestResult`, return `undefined`.\n     */\n    static conditionalDivideCoordinate(numerator, denominator, largestResult = Geometry.largeCoordinateResult) {\n        if (Math.abs(denominator * largestResult) > Math.abs(numerator))\n            return numerator / denominator;\n        return undefined;\n    }\n    /**\n     * Return solution(s) of equation `constCoff + cosCoff*c + sinCoff*s = 0` for `c` and `s` with the\n     * constraint `c*c + s*s = 1`.\n     * * There could be 0, 1, or 2 solutions. Return `undefined` if there is no solution.\n     */\n    static solveTrigForm(constCoff, cosCoff, sinCoff) {\n        /**\n         * Solutions can be found by finding the intersection of line \"ax + by + d = 0\" and unit circle \"x^2 + y^2 = 1\".\n         * From the line equation we have \"y = (-ax - d) / b\". By replacing this into the circle equation we get\n         * \"x^2 + (ax+d)^2/b^2 = 1\". If we solve this by quadratic formula we get\n         *      x = (-ad +- b*sqrt(a^2+b^2-d^2)) / (a^2+b^2)\n         *      y = (-ad -+ a*sqrt(a^2+b^2-d^2)) / (a^2+b^2)\n         *\n         * If \"a^2+b^2-d^2 > 0\" then there are two solutions (above).\n         * If \"a^2+b^2-d^2 = 0\" then there is one solution which is (-ad/(a^2+b^2), -bd/(a^2+b^2)).\n         * If \"a^2+b^2-d^2 < 0\" then there is no solution.\n         *\n         * Below in the code we have \"a = cosCoff\", \"b = sinCoff\", and \"d = constCoff\". Also equivalent criterion\n         * is used in the code. For example, \"a^2+b^2-d^2 > 0\" is equivalent of \"1 - d^2/(a^2+b^2) > 0\".\n         */\n        const a2b2 = cosCoff * cosCoff + sinCoff * sinCoff; // a^2+b^2\n        const d2 = constCoff * constCoff; // d^2\n        let result;\n        if (a2b2 > 0.0) {\n            const a2b2r = 1.0 / a2b2; // 1/(a^2+b^2)\n            const d2a2b2 = d2 * a2b2r; // d^2/(a^2+b^2)\n            const criterion = 1.0 - d2a2b2; // 1 - d^2/(a^2+b^2);\n            if (criterion < -Geometry.smallMetricDistanceSquared) // nSolution = 0\n                return result;\n            const da2b2 = -constCoff * a2b2r; // -d/(a^2+b^2)\n            // (c0,s0) is the closest approach of the line to the circle center (origin)\n            const c0 = da2b2 * cosCoff; // -ad/(a^2+b^2)\n            const s0 = da2b2 * sinCoff; // -bd/(a^2+b^2)\n            if (criterion <= 0.0) { // nSolution = 1\n                // We observed criterion = -2.22e-16 in a rotated tangent system, therefore for negative criteria near\n                // zero, return the near-tangency; for tiny positive criteria, fall through to return both solutions.\n                result = [Vector2d.create(c0, s0)];\n            }\n            else { // nSolution = 2\n                const s = Math.sqrt(criterion * a2b2r); // sqrt(a^2+b^2-d^2)) / (a^2+b^2)\n                result = [\n                    Vector2d.create(c0 - s * sinCoff, s0 + s * cosCoff),\n                    Vector2d.create(c0 + s * sinCoff, s0 - s * cosCoff),\n                ];\n            }\n        }\n        return result;\n    }\n    /**\n     * For a line `f(x)` where `f(x0) = f0` and `f(x1) = f1`, return the `x` value at which `f(x) = fTarget`\n     * Return `defaultResult` if `(fTarget - f0) / (f1 - f0)` exceeds `Geometry.largeFractionResult`\n     */\n    static inverseInterpolate(x0, f0, x1, f1, fTarget = 0, defaultResult) {\n        /**\n         * Line equation is \"fTarget-f0 = (f1-f0)/(x1-x0) * (x-x0)\" or \"(fTarget-f0)/(f1-f0) = (x-x0)/(x1-x0)\".\n         * The left hand side is known so if we call it \"fr\" (short for \"fraction\") we get \"fr = (x-x0)/(x1-x0)\".\n         * Therefore, \"x = x0*(1-fr) + x1*fr\". This is same as interpolation between \"x0\" and \"x1\" with fraction \"fr\".\n         */\n        const fr = Geometry.conditionalDivideFraction(fTarget - f0, f1 - f0); // (fTarget-f0)/(f1-f0)\n        if (fr !== undefined)\n            return Geometry.interpolate(x0, fr, x1); // x = x0*(1-fr) + x1*fr\n        return defaultResult;\n    }\n    /**\n     * For a line `f(x)` where `f(0) = f0` and `f(1) = f1`, return the `x` value at which `f(x) = fTarget`\n     * Return `undefined` if `(fTarget - f0) / (f1 - f0)` exceeds `Geometry.largeFractionResult`\n     */\n    static inverseInterpolate01(f0, f1, fTarget = 0) {\n        /**\n         * Line equation is \"fTarget-f0 = (f1-f0)*x\" so \"x = (fTarget-f0)/(f1-f0)\"\n         */\n        return Geometry.conditionalDivideFraction(fTarget - f0, f1 - f0); // x = (fTarget-f0)/(f1-f0)\n    }\n    /**\n     * Return `true` if `json` is an array with at least `minEntries` entries and all entries are numbers (including\n     * those beyond minEntries).\n     */\n    static isNumberArray(json, minEntries = 0) {\n        if (Array.isArray(json) && json.length >= minEntries) {\n            let entry;\n            for (entry of json) {\n                if (!Number.isFinite(entry))\n                    return false;\n            }\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Return `true` if `json` is an array of at least `minArrays` arrays with at least `minEntries` entries in\n     * each array and all entries are numbers (including those beyond minEntries).\n     */\n    static isArrayOfNumberArray(json, minArrays, minEntries = 0) {\n        if (Array.isArray(json) && json.length >= minArrays) {\n            let entry;\n            for (entry of json)\n                if (!Geometry.isNumberArray(entry, minEntries))\n                    return false;\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Return the number of steps to take so that `numSteps * stepSize >= total`.\n     * * `minCount` is returned in the following 3 cases:\n     *   * (a) `stepSize <= 0`\n     *   * (b) `stepSize >= total`\n     *   * (b) `numSteps < minCount`\n     * * `maxCount` is returned if `numSteps > maxCount`.\n     */\n    static stepCount(stepSize, total, minCount = 1, maxCount = 101) {\n        if (stepSize <= 0)\n            return minCount;\n        total = Math.abs(total);\n        if (stepSize >= total)\n            return minCount;\n        /**\n         * 0.999999 is multiplied so we return the same \"numSteps\" if\n         * stepSize*(numSteps-1) < total <= stepSize*numSteps.\n         * For example, if \"stepSize = 2\" then we return \"numSteps = 5\" if 8 < total <= 10.\n         */\n        const numSteps = Math.floor((total + 0.999999 * stepSize) / stepSize);\n        if (numSteps < minCount)\n            return minCount;\n        if (numSteps > maxCount)\n            return maxCount;\n        return numSteps;\n    }\n    /**\n     * Test if `x` is in the interval [0,1] (but skip the test if `apply01 = false`).\n     * * This odd behavior is very convenient for code that sometimes does not do the filtering.\n     * @param x value to test.\n     * @param apply01 if false, return `true` for all values of `x`.\n     */\n    static isIn01(x, apply01 = true) {\n        return apply01 ? x >= 0.0 && x <= 1.0 : true;\n    }\n    /**\n     * Test if `x` is in the interval [0,1] for a given positive `tolerance`.\n     * * Make sure to pass a positive `tolerance` because there is no check for that in the code.\n     * @param x value to test.\n     * @param tolerance the tolerance.\n     */\n    static isIn01WithTolerance(x, tolerance) {\n        return x + tolerance >= 0.0 && x - tolerance <= 1.0;\n    }\n    /**\n     * Restrict x so it is in the interval `[a,b]` (allowing `a` and `b` to be in either order).\n     * @param x value to restrict\n     * @param a (usually the lower) interval limit\n     * @param b (usually the upper) interval limit\n     */\n    static restrictToInterval(x, a, b) {\n        if (a <= b) {\n            if (x < a)\n                return a;\n            if (x > b)\n                return b;\n            return x;\n        }\n        // reversed interval\n        if (x < b)\n            return b;\n        if (x > a)\n            return a;\n        return x;\n    }\n    /**\n     * Case-insensitive string comparison.\n     * * Return `true` if the `toUpperCase` values of `string1` and `string2` match.\n     */\n    static equalStringNoCase(string1, string2) {\n        return string1.toUpperCase() === string2.toUpperCase();\n    }\n    /**\n     * Test for exact match of two number arrays.\n     * Returns `true` if both arrays have the same length and entries, or if both arrays are empty or `undefined`.\n     */\n    static exactEqualNumberArrays(a, b) {\n        if (Array.isArray(a) && a.length === 0)\n            a = undefined;\n        if (Array.isArray(b) && b.length === 0)\n            b = undefined;\n        if (a === undefined && b === undefined)\n            return true;\n        if (Array.isArray(a) && Array.isArray(b)) {\n            if (a.length !== b.length)\n                return false;\n            for (let i = 0; i < a.length; i++)\n                if (a[i] !== b[i])\n                    return false;\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Test for match of two arrays of type `T`.\n     * Returns `true` if both arrays have the same length and have the same entries (or both are empty arrays).\n     */\n    static almostEqualArrays(a, b, testFunction) {\n        if (Array.isArray(a) && a.length === 0)\n            a = undefined;\n        if (Array.isArray(b) && b.length === 0)\n            b = undefined;\n        if (a === undefined && b === undefined)\n            return true;\n        if (Array.isArray(a) && Array.isArray(b)) {\n            if (a.length !== b.length)\n                return false;\n            for (let i = 0; i < a.length; i++) {\n                if (!testFunction(a[i], b[i]))\n                    return false;\n            }\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Test for match of two arrays of type number or Float64Array.\n     * Returns `true` if both arrays have the same length and have the same entries (or both are empty arrays).\n     */\n    static almostEqualNumberArrays(a, b, testFunction) {\n        if (Array.isArray(a) && a.length === 0)\n            a = undefined;\n        if (Array.isArray(b) && b.length === 0)\n            b = undefined;\n        if (a === undefined && b === undefined)\n            return true;\n        if (Array.isArray(a) && Array.isArray(b)) {\n            if (a.length !== b.length)\n                return false;\n            for (let i = 0; i < a.length; i++) {\n                if (!testFunction(a[i], b[i]))\n                    return false;\n            }\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Test for match of two values of type `T`.\n     * @param a first value\n     * @param b second value\n     * @param resultIfBothUndefined returned value when both are `undefined`\n     * @returns `true` if both values are defined and equal (with ===) and `false` if both values are defined\n     * but not equal or if one is defined and the other undefined.\n     */\n    static areEqualAllowUndefined(a, b, resultIfBothUndefined = true) {\n        if (a === undefined && b === undefined)\n            return resultIfBothUndefined;\n        if (a !== undefined && b !== undefined)\n            return a === b;\n        return false;\n    }\n    /**\n     * Clone an array whose members have type `T`, which implements the clone method.\n     * * If the clone method returns `undefined`, then `undefined` is forced into the cloned array.\n     */\n    static cloneMembers(array) {\n        if (array === undefined)\n            return undefined;\n        const clonedArray = [];\n        for (const element of array) {\n            clonedArray.push(element.clone());\n        }\n        return clonedArray;\n    }\n}\n/** Tolerance for small distances in metric coordinates. */\nGeometry.smallMetricDistance = 1.0e-6;\n/** Square of `smallMetricDistance`. */\nGeometry.smallMetricDistanceSquared = 1.0e-12;\n/** Tolerance for small angle measured in radians. */\nGeometry.smallAngleRadians = 1.0e-12;\n/** Square of `smallAngleRadians`. */\nGeometry.smallAngleRadiansSquared = 1.0e-24;\n/** Tolerance for small angle measured in degrees. */\nGeometry.smallAngleDegrees = 5.7e-11;\n/** Tolerance for small angle measured in arc-seconds. */\nGeometry.smallAngleSeconds = 2e-7;\n/** Numeric value that may be considered zero for fractions between 0 and 1. */\nGeometry.smallFraction = 1.0e-10;\n/** Tight tolerance near machine precision (unitless). Useful for snapping values, e.g., to 0 or 1. */\nGeometry.smallFloatingPoint = 1.0e-15;\n/** Radians value for full circle 2PI radians minus `smallAngleRadians`. */\nGeometry.fullCircleRadiansMinusSmallAngle = 2.0 * Math.PI - Geometry.smallAngleRadians;\n/**\n * Numeric value that may be considered large for a ratio of numbers.\n * * Note that the allowed result value is vastly larger than 1.\n */\nGeometry.largeFractionResult = 1.0e10;\n/**\n * Numeric value that may considered large for numbers expected to be coordinates.\n * * This allows larger results than `largeFractionResult`.\n */\nGeometry.largeCoordinateResult = 1.0e13;\n/**\n * Numeric value that may considered infinite for metric coordinates.\n * @deprecated in 4.x. Use `largeCoordinateResult`.\n * * This coordinate should be used only as a placeholder indicating \"at infinity\" -- computing actual\n * points at this coordinate invites numerical problems.\n */\nGeometry.hugeCoordinate = 1.0e12;\nexport { Geometry };\n//# sourceMappingURL=Geometry.js.map",
      "start": 1693508122445,
      "end": 1693508122616,
      "sourcemaps": null
    }
  ]
}
