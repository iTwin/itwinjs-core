{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/topology/Triangulation.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Topology\n */\nimport { ClipUtilities } from \"../clipping/ClipUtils\";\nimport { Geometry } from \"../Geometry\";\nimport { IndexedXYZCollection } from \"../geometry3d/IndexedXYZCollection\";\nimport { Plane3dByOriginAndUnitNormal } from \"../geometry3d/Plane3dByOriginAndUnitNormal\";\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\nimport { Point3dArray } from \"../geometry3d/PointHelpers\";\nimport { PointStreamXYZXYZHandlerBase, VariantPointDataStream } from \"../geometry3d/PointStreaming\";\nimport { Range1d, Range2d } from \"../geometry3d/Range\";\nimport { HalfEdge, HalfEdgeGraph, HalfEdgeMask } from \"./Graph\";\nimport { MarkedEdgeSet } from \"./HalfEdgeMarkSet\";\nimport { InsertAndRetriangulateContext } from \"./InsertAndRetriangulateContext\";\n/**\n * (static) methods for triangulating polygons\n * * @internal\n */\nclass Triangulator {\n    /** Given the six nodes that make up two bordering triangles, \"pinch\" and relocate the nodes to flip them\n     * * The shared edge mates are c and e.\n     * * (abc) are a triangle in CCW order\n     * * (dfe) are a triangle in CCW order. (!! node dfe instead of def.)\n     */\n    static flipEdgeBetweenTriangles(a, b, c, d, e, f) {\n        // Reassign all of the pointers\n        HalfEdge.pinch(a, e);\n        HalfEdge.pinch(c, d);\n        HalfEdge.pinch(f, c);\n        HalfEdge.pinch(e, b);\n        // Move alpha and beta into the xy coordinates of their predecessors\n        e.x = b.x;\n        e.y = b.y;\n        e.z = b.z;\n        e.i = b.i;\n        c.i = f.i;\n        c.x = f.x;\n        c.y = f.y;\n        c.z = f.z;\n    }\n    /**\n     * * nodeA is a given node\n     * * nodeA1 is its nodeA.faceSuccessor\n     * * nodeA2 is nodeA1.faceSuccessor, i.e. 3rd node of triangle A\n     * * nodeB  is nodeA.edgeMate, i.e. a node in the \"other\" triangle at nodeA's edge\n     * * nodeB1 is nodeB.faceSuccessor\n     * * nodeB2 is nodeB1.faceSuccessor, i.e the 3rd node of triangle B\n     * Construct (as simple doubles, to avoid object creation) xy vectors from:\n     * * (ux,uy): nodeA to nodeA1, i.e. the shared edge\n     * * (vx,vy): nodeA to nodeA2,\n     * * (wx,wy): nodeA to nodeB2\n     * * this determinant is positive if nodeA is \"in the circle\" of nodeB2, nodeA1, nodeA2\n     * * Return true if clearly positive\n     * * Return false if clearly negative or almost zero.\n     * @param nodeA node on the diagonal edge of candidate for edge flip.\n     */\n    static computeInCircleDeterminantIsStrongPositive(nodeA) {\n        // Assume triangle A1,A2,B2 is ccw.\n        // Shift the triangle to the origin (by negated A coords).\n        // The Delaunay condition is computed by projecting the origin and the shifted triangle\n        // points up to the paraboloid z = x*x + y*y. Due to the radially symmetric convexity of\n        // this surface and the ccw orientation of this triangle, \"A is inside triangle A1,A2,B2\"\n        // is equivalent to \"the volume of the parallelepiped formed by the projected points is\n        // negative, as computed by the triple product.\"\n        const nodeA1 = nodeA.faceSuccessor;\n        const nodeA2 = nodeA1.faceSuccessor;\n        if (nodeA2.faceSuccessor !== nodeA)\n            return false;\n        const nodeB = nodeA.edgeMate;\n        const nodeB1 = nodeB.faceSuccessor;\n        const nodeB2 = nodeB1.faceSuccessor;\n        if (nodeB2.faceSuccessor !== nodeB)\n            return false;\n        const ux = nodeA1.x - nodeA.x;\n        const uy = nodeA1.y - nodeA.y;\n        const vx = nodeA2.x - nodeA.x;\n        const vy = nodeA2.y - nodeA.y;\n        if (Geometry.crossProductXYXY(ux, uy, vx, vy) < 0)\n            return false;\n        // we assume identical coordinates in pairs (nodeA, nodeB1)  and (nodeA1, nodeB)\n        const wx = nodeB2.x - nodeA.x;\n        const wy = nodeB2.y - nodeA.y;\n        const tx = wx * wx + wy * wy;\n        const ty = vx * vx + vy * vy;\n        const tz = ux * ux + uy * uy;\n        const q = Geometry.tripleProduct(wx, wy, tx, vx, vy, ty, ux, uy, tz);\n        if (q < 0)\n            return false;\n        const denom = Math.abs(wx * vy * tz) + Math.abs(wy * ty * ux) + Math.abs(tx * vx * uy)\n            + Math.abs(wx * ty * uy) + Math.abs(wy * vx * tz) + Math.abs(tx * vy * ux);\n        return q > 1.0e-12 * denom;\n    }\n    /**\n     *  *  Visit each node of the graph array\n     *  *  If a flip would be possible, test the results of flipping using incircle condition\n     *  *  If revealed to be an improvement, conduct the flip, mark involved nodes as unvisited, and repeat until all nodes are visited\n     */\n    static flipTriangles(graph) {\n        const edgeSet = MarkedEdgeSet.create(graph);\n        for (const node of graph.allHalfEdges)\n            edgeSet.addToSet(node);\n        const numFlip = this.flipTrianglesInEdgeSet(graph, edgeSet);\n        edgeSet.teardown();\n        return numFlip;\n    }\n    /**\n     *  *  Visit each node of the graph array\n     *  *  If a flip would be possible, test the results of flipping using incircle condition\n     *  *  If revealed to be an improvement, conduct the flip, mark involved nodes as unvisited, and repeat until all nodes are visited\n     */\n    static flipTrianglesInEdgeSet(graph, edgeSet) {\n        const barrierMasks = HalfEdgeMask.EXTERIOR | HalfEdgeMask.PRIMARY_EDGE | HalfEdgeMask.BOUNDARY_EDGE;\n        const nodeArray = graph.allHalfEdges;\n        const maxTest = 10.0 * nodeArray.length;\n        let numFlip = 0;\n        let numOK = 0;\n        let node;\n        while (undefined !== (node = edgeSet.chooseAndRemoveAny())) {\n            if (node.isMaskSet(barrierMasks)) // Flip not allowed\n                continue;\n            if (Triangulator.computeInCircleDeterminantIsStrongPositive(node)) {\n                // Flip the triangles\n                Triangulator.flipEdgeBetweenTriangles(node.edgeMate.faceSuccessor, node.edgeMate.facePredecessor, node.edgeMate, node.faceSuccessor, node, node.facePredecessor);\n                // keep looking at the 2 faces\n                edgeSet.addAroundFace(node);\n                edgeSet.addAroundFace(node.edgeMate);\n                numFlip++;\n            }\n            else {\n                numOK++;\n            }\n            if (numFlip + numOK > maxTest)\n                break;\n        }\n        return numFlip;\n    }\n    /** Create a graph with a triangulation points.\n     * * The outer limit of the graph is the convex hull of the points.\n     * * The outside loop is marked `HalfEdgeMask.EXTERIOR`\n     */\n    static createTriangulatedGraphFromPoints(points) {\n        if (points.length < 3)\n            return undefined;\n        const hull = [];\n        const interior = [];\n        Point3dArray.computeConvexHullXY(points, hull, interior, true);\n        const graph = new HalfEdgeGraph();\n        const context = InsertAndRetriangulateContext.create(graph);\n        Triangulator.createFaceLoopFromCoordinates(graph, hull, true, true);\n        // HalfEdgeGraphMerge.clusterAndMergeXYTheta(graph);\n        let numInsert = 0;\n        for (const p of interior) {\n            context.insertAndRetriangulate(p, true);\n            numInsert++;\n            if (numInsert > 16) {\n                /*\n                context.reset();\n                Triangulator.flipTriangles(context.graph);\n                // console.log (\" intermediate flips \" + numFlip);\n                */\n                numInsert = 0;\n            }\n        }\n        /*\n            // final touchup for aspect ratio flip\n            for (let i = 0; i < 15; i++) {\n              const numFlip = Triangulator.flipTriangles(graph);\n              if (numFlip === 0)\n                break;\n            }\n            */\n        return graph;\n    }\n    /**\n     * * Only one outer loop permitted.\n     * * Largest area loop is assumed outer.\n     * @param loops an array of loops as GrowableXYZArray or XAndY[]\n     * @returns triangulated graph, or undefined if bad data.\n     */\n    static createTriangulatedGraphFromLoops(loops) {\n        if (loops.length < 1)\n            return undefined;\n        const mask = HalfEdgeMask.BOUNDARY_EDGE | HalfEdgeMask.PRIMARY_EDGE;\n        const graph = new HalfEdgeGraph();\n        const holeSeeds = [];\n        let maxArea = -10000.0;\n        let maxAreaIndex = -1;\n        // collect all the loops with pointers to the positive (inside)\n        // remember which one has largest area.\n        for (let i = 0; i < loops.length; i++) {\n            let seed = Triangulator.directCreateFaceLoopFromCoordinates(graph, loops[i]);\n            if (seed) {\n                seed = seed.faceSuccessor; // directCreate returns tail\n                const mate = seed.vertexSuccessor;\n                seed.setMaskAroundFace(mask);\n                mate.setMaskAroundFace(mask);\n                const signedFaceArea = seed.signedFaceArea();\n                const area = Math.abs(signedFaceArea);\n                holeSeeds.push(signedFaceArea >= 0 ? seed : mate);\n                if (i === 0 || area > maxArea) {\n                    maxArea = area;\n                    maxAreaIndex = i;\n                }\n            }\n        }\n        if (holeSeeds.length === 0)\n            return undefined;\n        // extract the max area seed ...\n        const maxAreaFace = holeSeeds[maxAreaIndex];\n        holeSeeds[maxAreaIndex] = holeSeeds[holeSeeds.length - 1];\n        holeSeeds.pop();\n        maxAreaFace.vertexSuccessor.setMaskAroundFace(HalfEdgeMask.EXTERIOR);\n        // The hole seeds all have inside nodes.  Set mask there and jump to outside.\n        for (let i = 0; i < holeSeeds.length; i++) {\n            const seed = holeSeeds[i];\n            seed.setMaskAroundFace(HalfEdgeMask.EXTERIOR);\n            holeSeeds[i] = this.getLeftmost(seed.vertexSuccessor);\n        }\n        const startingNode = Triangulator.spliceLeftMostNodesOfHoles(graph, maxAreaFace, holeSeeds);\n        if (startingNode) {\n            if (Triangulator.triangulateSingleFace(graph, startingNode))\n                return graph;\n        }\n        return undefined;\n    }\n    /**\n     * Triangulate all positive area faces of a graph.\n     */\n    static triangulateAllPositiveAreaFaces(graph) {\n        const seeds = graph.collectFaceLoops();\n        let numFail = 0;\n        for (const face of seeds) {\n            if (face.countEdgesAroundFace() > 3) {\n                const area = face.signedFaceArea();\n                if (area > 0.0)\n                    if (!Triangulator.triangulateSingleFace(graph, face))\n                        numFail++;\n            }\n        }\n        return numFail === 0;\n    }\n    /**\n     * Triangulate the polygon made up of by a series of points.\n     * * The loop may be either CCW or CW -- CCW order will be used for triangles.\n     * * To triangulate a polygon with holes, use createTriangulatedGraphFromLoops\n     */\n    static createTriangulatedGraphFromSingleLoop(data) {\n        const graph = new HalfEdgeGraph();\n        const startingNode = Triangulator.createFaceLoopFromCoordinates(graph, data, true, true);\n        if (!startingNode || graph.countNodes() < 6)\n            return graph;\n        if (Triangulator.triangulateSingleFace(graph, startingNode)) {\n            Triangulator.flipTriangles(graph);\n            return graph;\n        }\n        return undefined;\n    }\n    /**\n     * cautiously split the edge starting at baseNode.\n     * * If baseNode is null, create a trivial loop with the single vertex at xy\n     * * if xy is distinct from the coordinates at both baseNode and its successor, insert xy as a new node within that edge.\n     * * also include z coordinate if present.\n     */\n    static interiorEdgeSplit(graph, baseNode, xy) {\n        let x = 0, y = 0, z = 0;\n        if (Array.isArray(xy)) {\n            x = xy[0];\n            y = xy[1];\n            z = xy.length > 2 ? xy[3] : 0.0;\n        }\n        else {\n            const q = xy;\n            if (q.hasOwnProperty(\"x\"))\n                x = q.x;\n            if (q.hasOwnProperty(\"y\"))\n                y = q.y;\n            if (q.hasOwnProperty(\"z\"))\n                z = q.z;\n        }\n        if (!baseNode)\n            return graph.splitEdge(baseNode, x, y, z);\n        if (Triangulator.isAlmostEqualXAndYXY(baseNode, x, y))\n            return baseNode;\n        if (Triangulator.isAlmostEqualXAndYXY(baseNode.faceSuccessor, x, y))\n            return baseNode;\n        return graph.splitEdge(baseNode, x, y, z);\n    }\n    /** Create a loop from coordinates.\n     * * Return a pointer to any node on the loop.\n     * * no masking or other markup is applied.\n     */\n    static directCreateFaceLoopFromCoordinates(graph, data) {\n        // Add the starting nodes as the boundary, and apply initial masks to the primary edge and exteriors\n        let baseNode;\n        if (data instanceof IndexedXYZCollection) {\n            const xyz = Point3d.create();\n            for (let i = 0; i < data.length; i++) {\n                data.getPoint3dAtCheckedPointIndex(i, xyz);\n                baseNode = Triangulator.interiorEdgeSplit(graph, baseNode, xyz);\n            }\n        }\n        else {\n            for (const xy of data) {\n                baseNode = Triangulator.interiorEdgeSplit(graph, baseNode, xy);\n            }\n        }\n        return baseNode;\n    }\n    /** Create chains from coordinates.\n     * * Return array of pointers to base node of the chains.\n     * * no masking or other markup is applied.\n     * @param graph New edges are built in this graph\n     * @param data coordinate data\n     * @param id id to attach to (both side of all) edges\n     */\n    static directCreateChainsFromCoordinates(graph, data, id = 0) {\n        // Add the starting nodes as the boundary, and apply initial masks to the primary edge and exteriors\n        const assembler = new AssembleXYZXYZChains(graph, id);\n        VariantPointDataStream.streamXYZ(data, assembler);\n        return assembler.claimSeeds();\n    }\n    /**\n     * @param graph the containing graph\n     * @param base The last node of a newly created loop.  (i.e. its `faceSuccessor` has the start xy)\n     * @param returnPositiveAreaLoop if true, return the start node on the side with positive area.  otherwise return the left side as given.\n     * @param maskForBothSides mask to apply on both sides.\n     * @param maskForOtherSide mask to apply to the \"other\" side of the loop.\n     * @return the loop's start node or its vertex successor, chosen to be the positive or negative loop per request.\n     */\n    static maskAndOrientNewFaceLoop(_graph, base, returnPositiveAreaLoop, maskForBothSides, maskForOtherSide) {\n        // base is the final coordinates\n        if (base) {\n            base = base.faceSuccessor; // because typical construction process leaves the \"live\" edge at the end of the loop.\n            const area = base.signedFaceArea();\n            const mate = base.edgeMate;\n            if (maskForBothSides !== HalfEdgeMask.NULL_MASK) {\n                base.setMaskAroundFace(maskForBothSides);\n                mate.setMaskAroundFace(maskForBothSides);\n            }\n            let preferredNode = base;\n            if (returnPositiveAreaLoop && (area < 0))\n                preferredNode = mate;\n            const otherNode = preferredNode.vertexSuccessor;\n            if (maskForOtherSide !== HalfEdgeMask.NULL_MASK)\n                otherNode.setMaskAroundFace(maskForOtherSide);\n            return preferredNode;\n        }\n        return undefined;\n    }\n    /**\n     * create a circular doubly linked list of internal and external nodes from polygon points in the specified winding order\n     * * This applies the masks used by typical applications:\n     *   * HalfEdgeMask.BOUNDARY on both sides\n     *   * HalfEdgeMask.PRIMARY_EDGE on both sides.\n     * * Use `createFaceLoopFromCoordinatesAndMasks` for detail control of masks.\n     */\n    static createFaceLoopFromCoordinates(graph, data, returnPositiveAreaLoop, markExterior) {\n        const base = Triangulator.directCreateFaceLoopFromCoordinates(graph, data);\n        return Triangulator.maskAndOrientNewFaceLoop(graph, base, returnPositiveAreaLoop, HalfEdgeMask.BOUNDARY_EDGE | HalfEdgeMask.PRIMARY_EDGE, markExterior ? HalfEdgeMask.EXTERIOR : HalfEdgeMask.NULL_MASK);\n    }\n    /**\n     * create a circular doubly linked list of internal and external nodes from polygon points.\n     * * Optionally jump to the \"other\" side so the returned loop has positive area\n     * @param graph graph to receive the new edges\n     * @param data array with x,y coordinates\n     * @param returnPositiveAreaLoop if false, return an edge proceeding around the loop in the order given.  If true, compute the loop area and flip return the side with positive area.\n     * @param maskForBothSides mask to apply on both sides.\n     * @param maskForOtherSide mask to apply on the \"other\" side from the returned loop.\n     */\n    static createFaceLoopFromCoordinatesAndMasks(graph, data, returnPositiveAreaLoop, maskForBothSides, maskForOtherSide) {\n        const base = Triangulator.directCreateFaceLoopFromCoordinates(graph, data);\n        return Triangulator.maskAndOrientNewFaceLoop(graph, base, returnPositiveAreaLoop, maskForBothSides, maskForOtherSide);\n    }\n    /** Cut off an ear, forming a new face loop of nodes\n     * @param ear the vertex being cut off.\n     * *  Form two new nodes, alpha and beta, which have the coordinates one step away from the ear vertex.\n     * *  Reassigns the pointers such that beta is left behind with the new face created\n     * *  Reassigns the pointers such that alpha becomes the resulting missing node from the remaining polygon\n     * * Reassigns prevZ and nextZ pointers\n     */\n    static joinNeighborsOfEar(graph, ear) {\n        const alpha = graph.createEdgeXYZXYZ(ear.facePredecessor.x, ear.facePredecessor.y, ear.facePredecessor.z, ear.facePredecessor.i, ear.faceSuccessor.x, ear.faceSuccessor.y, ear.faceSuccessor.z, ear.faceSuccessor.i);\n        const beta = alpha.edgeMate;\n        // Add two nodes alpha and beta and reassign pointers (also mark triangle nodes as part of triangle)\n        HalfEdge.pinch(ear.faceSuccessor, beta);\n        HalfEdge.pinch(ear.facePredecessor, alpha);\n        ear.setMaskAroundFace(HalfEdgeMask.TRIANGULATED_FACE);\n    }\n    static isInteriorTriangle(a) {\n        if (!a.isMaskSet(HalfEdgeMask.TRIANGULATED_FACE) || a.isMaskSet(HalfEdgeMask.EXTERIOR))\n            return false;\n        const b = a.faceSuccessor;\n        if (!b.isMaskSet(HalfEdgeMask.TRIANGULATED_FACE) || b.isMaskSet(HalfEdgeMask.EXTERIOR))\n            return false;\n        const c = b.faceSuccessor;\n        if (!c.isMaskSet(HalfEdgeMask.TRIANGULATED_FACE) || c.isMaskSet(HalfEdgeMask.EXTERIOR))\n            return false;\n        return c.faceSuccessor === a;\n    }\n    /**\n     * Perform 0, 1, or more edge flips to improve aspect ratio just behind an ear that was just cut.\n     * @param ear the triangle corner which just served as the ear node.\n     * @returns the node at the back corner after flipping.\"appropriately positioned\" node for the usual advance to ear.faceSuccessor.edgeMate.faceSuccessor.\n     */\n    static doPostCutFlips(ear) {\n        //    B is the ear -- inside a (probably newly created) triangle ABC\n        //    CA is the recently added cut edge.\n        //    AB is the candidate to be flipped.\n        //    triangle B1 A1 D is on the other side of AB\n        //    The condition for flipping is:\n        //           ! both triangles must be TRIANGULATED_NODE_MASK\n        //           ! incircle condition flags D as in the circle of ABC\n        //     after flip, node A moves to the vertex of D, and is the effective \"ear\",  with the cap edge C A1\n        //      after flip, consider the A1 D (whose nodes are A1 and flipped A!!!)\n        //\n        //                           *                                 *\n        //                       . C0|                             . / |\n        //                  .        |                        .  C0 /B1|\n        //               .           |                     .       /v  |\n        //           .              ^|                 .          /    |\n        //       .  A0 ---->       B0|             .            /     ^|\n        //   *=======================*   -->   * A1            /     B0*\n        //     \\ A1     <----   B1/              \\            /     /\n        //       \\             /                   \\        /    /\n        //         \\         /                       \\    ^/ D1/\n        //           \\  D1 /                           \\A0/  /\n        //              *                                 *\n        let b0 = ear;\n        let a0 = b0.facePredecessor;\n        let b1 = a0.edgeMate;\n        while (Triangulator.isInteriorTriangle(a0) && Triangulator.isInteriorTriangle(b1)) {\n            const detA = Triangulator.computeInCircleDeterminantIsStrongPositive(a0);\n            if (!detA)\n                break;\n            // Flip the triangles\n            const a1 = b1.faceSuccessor;\n            Triangulator.flipEdgeBetweenTriangles(a1, a1.faceSuccessor, a1.facePredecessor, b0, b0.facePredecessor, b0.faceSuccessor);\n            b0 = a0;\n            a0 = b0.facePredecessor;\n            b1 = a0.edgeMate;\n        }\n        return b0;\n    }\n    /**\n     * main ear slicing loop which triangulates a polygon (given as a linked list)\n     * While there still exists ear nodes that have not yet been triangulated...\n     *\n     * *  Check if the ear is hashed, and can easily be split off. If so, \"join\" that ear.\n     * *  If not hashed, move on to a separate ear.\n     * *  If no ears are currently hashed, attempt to cure self intersections or split the polygon into two before continuing\n     */\n    static triangulateSingleFace(graph, ear) {\n        if (!ear) {\n            Triangulator.setDebugGraph(graph);\n            return false;\n        }\n        let next;\n        let next2;\n        let pred;\n        let maxCandidate = ear.countEdgesAroundFace();\n        let numCandidate = 0;\n        ear.clearMaskAroundFace(HalfEdgeMask.TRIANGULATED_FACE);\n        // iterate through ears, slicing them one by one\n        while (!ear.isMaskSet(HalfEdgeMask.TRIANGULATED_FACE)) {\n            pred = ear?.facePredecessor;\n            next = ear.faceSuccessor;\n            next2 = next.faceSuccessor;\n            if (next === ear || next2 === ear)\n                return true;\n            if (next2.faceSuccessor === ear) {\n                // if triangle, mask it so that its edges can potentially be flipped by doPostCutFlips()\n                ear.setMaskAroundFace(HalfEdgeMask.TRIANGULATED_FACE);\n                return true;\n            }\n            // earcut does not support self intersections.\n            // BUT  .. maybe if we watch from the simplest case of next2 returning to pred it will catch some . . .\n            // (no need to do flips -- we know it's already a triangle)\n            // EDL Sept 2021 NO... coordinate test is fooled into early exit when large outer triangle has\n            // edges going in from pred.\n            // Hence add the around vertex test.  But this is possibly vulnerable to a variant false positive ..\n            if (Geometry.isAlmostEqualXAndY(next2, pred) && !next2.findAroundVertex(pred)) {\n                HalfEdge.pinch(pred, next2);\n                ear.setMaskAroundFace(HalfEdgeMask.TRIANGULATED_FACE);\n                ear = next2;\n                continue;\n            }\n            if (++numCandidate > maxCandidate) {\n                Triangulator.setDebugGraph(graph);\n                return false;\n            }\n            if (Triangulator.isEar(ear)) {\n                maxCandidate--;\n                numCandidate = 0;\n                // skipping the next vertices leads to less sliver triangles\n                // If we already have a separated triangle, do not join\n                if (ear.faceSuccessor.faceSuccessor !== ear.facePredecessor) {\n                    Triangulator.joinNeighborsOfEar(graph, ear);\n                    ear = Triangulator.doPostCutFlips(ear);\n                    ear = ear.faceSuccessor.edgeMate.faceSuccessor;\n                    // another step?   Nate's 2017 code went one more.\n                }\n                else {\n                    ear.setMaskAroundFace(HalfEdgeMask.TRIANGULATED_FACE);\n                    ear = next.faceSuccessor;\n                }\n                continue;\n            }\n            ear = next;\n        }\n        return true; // um .. I'm not sure what this state is.\n    }\n    /**\n     * * returns the (possibly undefined) debug graph.\n     * * sets the debug graph to undefined.\n     * * disables subsequent saving.\n     * @internal */\n    static claimDebugGraph() {\n        const g = Triangulator.sDebugGraph;\n        Triangulator.sDebugGraph = undefined;\n        Triangulator.sEnableDebugGraphCapture = false;\n        return g;\n    }\n    /** Call (from within the triangulator) to announce a graph to be saved for debug.\n     * * If debug graph capture is not enabled, do nothing.\n     * * If debug graph capture is enabled, save this graph.\n     * * This is called by internal steps at point of failure to preserve the failing graph for unit test examination.\n     * @internal */\n    static setDebugGraph(graph) { if (Triangulator.sEnableDebugGraphCapture)\n        Triangulator.sDebugGraph = graph; }\n    /**\n     * * Clear the debug graph\n     * * Set capture enabled to indicated value.\n     * * Intended use:\n     *   * By default \"enabled\" is false so there is no activity in the debug graph.\n     *   * A unit test which needs to see graph after failure calls clearAndEnableDebugGraphCapture (true)\n     *   * run the triangulation step\n     *   * call claimDebugGraph.\n     *   * claimDebugGraph reverts everything to default no-capture state.\n     * @internal */\n    static clearAndEnableDebugGraphCapture(value) {\n        Triangulator.sEnableDebugGraphCapture = value;\n        Triangulator.sDebugGraph = undefined;\n    }\n    /** Check whether a polygon node forms a valid ear with adjacent nodes */\n    static isEar(ear) {\n        const a = ear.facePredecessor;\n        const b = ear;\n        const c = ear.faceSuccessor;\n        const area = Triangulator.signedTolerancedCCWTriangleArea(a, b, c);\n        if (area <= 0)\n            return false; // reflex, can't be an ear\n        const planes = this._planes;\n        if (!Plane3dByOriginAndUnitNormal.createOriginAndTargetXY(a, b, planes[0])\n            || !Plane3dByOriginAndUnitNormal.createOriginAndTargetXY(b, c, planes[1])\n            || !Plane3dByOriginAndUnitNormal.createOriginAndTargetXY(c, a, planes[2]))\n            return false;\n        // now make sure we don't have other points inside the potential ear, or edges crossing.\n        const earRange = this._earRange;\n        const edgeRange = this._edgeRange;\n        const edgeInterval = this._edgeInterval;\n        Range2d.createXYXYXY(a.x, a.y, b.x, b.y, c.x, c.y, earRange);\n        earRange.expandInPlace(Geometry.smallMetricDistance);\n        let p = c;\n        const zeroPlus = 1.0e-8;\n        const zeroMinus = -zeroPlus;\n        const onePlus = 1.0 + zeroPlus;\n        const oneMinus = 1.0 - zeroPlus;\n        const clipTolerance = 1.0e-10 * area;\n        while (p !== a) {\n            const q = p.faceSuccessor;\n            Range2d.createXYXY(p.x, p.y, q.x, q.y, edgeRange);\n            if (earRange.intersectsRange(edgeRange)) {\n                // Does pq impinge on the triangle?\n                Range1d.createXX(zeroMinus, onePlus, edgeInterval);\n                ClipUtilities.clipSegmentBelowPlanesXY(planes, p, q, edgeInterval, clipTolerance);\n                if (!edgeInterval.isNull) {\n                    const mate = p.edgeMate;\n                    if (mate === a || mate === b) {\n                        // this is the back side of a bridge edge\n                    }\n                    else if (edgeInterval.low > oneMinus) {\n                        // the endpoint (q) just touches ... if it is at one of the vertex loops it's ok ...\n                        if (!a.findAroundVertex(q)\n                            && !b.findAroundVertex(q)\n                            && !c.findAroundVertex(q))\n                            return false;\n                    }\n                    else if (edgeInterval.high < zeroPlus) {\n                        // the start (p) just touches ... if it is at one of the vertex loops it's ok ...\n                        if (!a.findAroundVertex(p)\n                            && !b.findAroundVertex(p)\n                            && !c.findAroundVertex(p))\n                            return false;\n                    }\n                    else {\n                        // significant internal intersection -- this edge really intrudes on the  into the triangle\n                        return false;\n                    }\n                }\n            }\n            p = p.faceSuccessor;\n        }\n        return true;\n    }\n    /** link holeLoopNodes[1], holeLoopNodes[2] etc into the outer loop, producing a single-ring polygon without holes\n     *\n     */\n    static spliceLeftMostNodesOfHoles(graph, outerNode, leftMostHoleLoopNode) {\n        leftMostHoleLoopNode.sort((a, b) => Triangulator.compareX(a, b));\n        let numFail = 0;\n        // process holes from left to right\n        for (const holeStart of leftMostHoleLoopNode) {\n            if (!Triangulator.eliminateHole(graph, holeStart, outerNode))\n                numFail++;\n        }\n        return numFail === 0 ? outerNode : undefined;\n    }\n    /** For use in sorting -- return (signed) difference (a.x - b.x) */\n    static compareX(a, b) {\n        return a.x - b.x;\n    }\n    /** find a bridge between vertices that connects hole with an outer ring and and link it */\n    static eliminateHole(graph, hole, outerNode) {\n        const outerNodeA = Triangulator.findHoleBridge(hole, outerNode);\n        if (outerNodeA) {\n            return Triangulator.splitFace(graph, outerNodeA, hole) !== undefined;\n        }\n        return false;\n    }\n    // cspell:word Eberly\n    /**\n     *  David Eberly algorithm for finding a bridge between hole and outer polygon:\n     *  https://www.geometrictools.com/Documentation/TriangulationByEarClipping.pdf\n     */\n    static findHoleBridge(hole, outerNode) {\n        let p = outerNode;\n        if (!p)\n            return undefined;\n        const hx = hole.x;\n        const hy = hole.y;\n        let qx = -Infinity;\n        let m;\n        // find a segment intersected by a ray from the hole's leftmost point to the left;\n        // segment's endpoint with lesser x will be potential connection point\n        do {\n            if (hy <= p.y && hy >= p.faceSuccessor.y && p.faceSuccessor.y !== p.y) {\n                const x = p.x + (hy - p.y) * (p.faceSuccessor.x - p.x) / (p.faceSuccessor.y - p.y);\n                if (x <= hx && x > qx) {\n                    qx = x;\n                    if (x === hx) {\n                        if (hy === p.y)\n                            return p;\n                        if (hy === p.faceSuccessor.y)\n                            return p.faceSuccessor;\n                    }\n                    m = p.x < p.faceSuccessor.x ? p : p.faceSuccessor;\n                }\n            }\n            p = p.faceSuccessor;\n        } while (p !== outerNode);\n        if (!m)\n            return undefined;\n        if (hx === qx)\n            return m.facePredecessor; // hole touches outer segment; pick lower endpoint\n        // look for points inside the triangle of hole point, segment intersection and endpoint;\n        // if there are no points found, we have a valid connection;\n        // otherwise choose the point of the minimum angle with the ray as connection point\n        const stop = m;\n        const mx = m.x;\n        const my = m.y;\n        let tanMin = Infinity;\n        let tan;\n        p = m.faceSuccessor;\n        while (p !== stop) {\n            if (hx >= p.x && p.x >= mx && hx !== p.x &&\n                Triangulator.pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n                tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n                if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && Triangulator.locallyInside(p, hole)) {\n                    m = p;\n                    tanMin = tan;\n                }\n            }\n            p = p.faceSuccessor;\n        }\n        return m;\n    }\n    // find the leftmost node of a polygon ring\n    static getLeftmost(start) {\n        let p = start;\n        let leftmost = start;\n        do {\n            if (p.x < leftmost.x)\n                leftmost = p;\n            p = p.faceSuccessor;\n        } while (p !== start);\n        return leftmost;\n    }\n    /** check if a point lies within a convex triangle.\n     * i.e. areas of 3 triangles with an edge of abc and p all have zero or positive area.  (abp, bcp, cap)\n     */\n    static pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n        return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&\n            (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&\n            (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;\n    }\n    static nodeInTriangle(a, b, c, p) {\n        return Triangulator.signedTolerancedCCWTriangleArea(a, b, p) > 0\n            && Triangulator.signedTolerancedCCWTriangleArea(b, c, p) > 0.0\n            && Triangulator.signedTolerancedCCWTriangleArea(c, a, p) > 0.0;\n    }\n    /** signed area of a triangle\n     * EDL 2/21 This is negative of usual CCW area.  Beware in callers !!!\n     * (This originates in classic earcut code.)\n    */\n    static signedCWTriangleArea(p, q, r) {\n        return 0.5 * ((q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y));\n    }\n    /** signed area of a triangle, with small positive corrected to zero by relTol\n    */\n    static signedTolerancedCCWTriangleArea(p, q, r, relTol = 1.0e-12) {\n        const ux = q.x - p.x;\n        const uy = q.y - p.y;\n        const vx = r.x - p.x;\n        const vy = r.y - p.y;\n        const area = 0.5 * (ux * vy - uy * vx);\n        if (area < 0.0)\n            return area;\n        const uu = ux * ux + uy * uy;\n        const vv = vx * vx + vy * vy;\n        if (area < relTol * (uu + vv))\n            return 0.0;\n        return area;\n    }\n    /** check if two points are equal */\n    static isAlmostEqualXAndYXY(p1, x, y) {\n        return Geometry.isAlmostEqualNumber(p1.x, x) && Geometry.isAlmostEqualNumber(p1.y, y);\n    }\n    /** check if a b is inside the sector around a */\n    static locallyInside(a, b) {\n        return Triangulator.signedCWTriangleArea(a.facePredecessor, a, a.faceSuccessor) < 0 ?\n            Triangulator.signedCWTriangleArea(a, b, a.faceSuccessor) >= 0 && Triangulator.signedCWTriangleArea(a, a.facePredecessor, b) >= 0 :\n            Triangulator.signedCWTriangleArea(a, b, a.facePredecessor) < 0 || Triangulator.signedCWTriangleArea(a, a.faceSuccessor, b) < 0;\n    }\n    /**\n     * link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n     * if one belongs to the outer ring and another to a hole, it merges it into a single ring\n     * * Returns the base of the new edge at the \"a\" end.\n     * * \"a\" and \"b\" still represent the same physical pieces of edges\n     * @returns Returns the (base of) the new half edge, at the \"a\" end.\n     */\n    static splitFace(graph, a, b) {\n        if (HalfEdge.isNodeVisibleInSector(a, b) && HalfEdge.isNodeVisibleInSector(b, a)) {\n            const a2 = graph.createEdgeXYZXYZ(a.x, a.y, a.z, a.i, b.x, b.y, b.z, b.i);\n            const b2 = a2.faceSuccessor;\n            HalfEdge.pinch(a, a2);\n            HalfEdge.pinch(b, b2);\n            return a2;\n        }\n        return undefined;\n    }\n    /**\n     * Triangulate a single face with (linear time) logic applicable only if the lowNode is the lowest node.\n     * @returns false if any monotonicity condition is violated.\n     */\n    static triangulateSingleMonotoneFace(graph, start) {\n        let left = start.facePredecessor;\n        let right = start.faceSuccessor;\n        // P0, P1, P2 are successive edges along evolving chain\n        let upperSideOfNewEdge;\n        while (left !== right\n            && right !== start\n            && right.faceSuccessor !== left) {\n            /** These should not happen if face is monotone . .. */\n            if (HalfEdge.crossProductXYAlongChain(left, start, right) <= 0)\n                return false;\n            if (!start.belowYX(left))\n                return false;\n            if (!start.belowYX(right))\n                return false;\n            if (left.belowYX(right)) {\n                /*      Triangulate to all left side edges that\n                   are below right */\n                /*      Phase 1: move upward, adding back edges\n                   when prior nodes are visible. */\n                let P0 = left;\n                let P1 = start;\n                let P2 = right;\n                /*      Invariant: the path from P0 back to P1 is concave.\n                   Each loop pass moves P0 up the left side, filling in\n                   edges as needed.  The right side edge\n                   (following start) is never altered.\n                 */\n                while (P0 !== P2 && P0.belowYX(right)) {\n                    while (P2 !== right\n                        && P2 !== P0\n                        && P2 !== P1\n                        && HalfEdge.crossProductXYAlongChain(P0, P1, P2) > 0) {\n                        upperSideOfNewEdge = Triangulator.splitFace(graph, P0, P2);\n                        if (upperSideOfNewEdge === undefined)\n                            return false;\n                        P0 = upperSideOfNewEdge;\n                        P1 = P0.faceSuccessor;\n                        P2 = P1.faceSuccessor;\n                    }\n                    P2 = P1;\n                    P1 = P0;\n                    P0 = P0.facePredecessor;\n                }\n                /*      Phase 2: Fan out edges from right to the\n                   left side. P0.P1.P2 describes a pair of\n                   adjacent edges at the bottom. */\n                left = P1;\n                P2 = right;\n                P1 = P2.facePredecessor;\n                P0 = P1.facePredecessor;\n                while (P2.faceSuccessor !== P0 && P0 !== left) {\n                    upperSideOfNewEdge = Triangulator.splitFace(graph, P0, P2);\n                    if (upperSideOfNewEdge === undefined)\n                        return false;\n                    P1 = upperSideOfNewEdge;\n                    P0 = P1.facePredecessor;\n                }\n                /*      Finish off with the last stroke from the\n                   left node to the right, except when already\n                   topped out */\n                if (P2.faceSuccessor !== P0) {\n                    upperSideOfNewEdge = Triangulator.splitFace(graph, P0, P2);\n                    if (upperSideOfNewEdge === undefined)\n                        return false;\n                    P0 = upperSideOfNewEdge;\n                }\n                start = P0;\n                right = start.faceSuccessor;\n                left = start.facePredecessor;\n            }\n            else {\n                /*      Triangulate to all right side edges that\n                   are below left */\n                /*      Phase 1: move upward, adding back edges\n                   when prior nodes are visible. */\n                let P0 = left;\n                let P1 = start;\n                let P2 = right;\n                /*      Invariant: the path up to P1 is concave.\n                   Each loop pass advances P1, filling in\n                   edges as needed. Note that the\n                   start edge may get hidden, so the\n                   bottom node must be referenced as\n                   left.faceSuccessor rather than as start.\n                 */\n                while (P0 !== P2 && P2.belowYX(left)) {\n                    while (P0 !== left\n                        && P2 !== P0\n                        && P2 !== P1\n                        && HalfEdge.crossProductXYAlongChain(P0, P1, P2) > 0) {\n                        upperSideOfNewEdge = Triangulator.splitFace(graph, P0, P2);\n                        if (upperSideOfNewEdge === undefined)\n                            return false;\n                        P0 = upperSideOfNewEdge.facePredecessor;\n                        P1 = upperSideOfNewEdge;\n                    }\n                    P0 = P1;\n                    P1 = P2;\n                    P2 = P2.faceSuccessor;\n                }\n                /*      Phase 2: Fan out edges from left to the\n                   right side. P0.P1.P2 describes a pair of\n                   adjacent edges at the bottom. */\n                right = P1;\n                P0 = left;\n                P1 = P0.faceSuccessor;\n                P2 = P1.faceSuccessor;\n                while (P2.faceSuccessor !== P0 && P2 !== right) {\n                    upperSideOfNewEdge = Triangulator.splitFace(graph, P0, P2);\n                    if (upperSideOfNewEdge === undefined)\n                        return false;\n                    P0 = upperSideOfNewEdge;\n                    // P1 = P2;   // original code (ported from native) carefully maintained P1..P2 relationship.  But code analyzer says P1 is not used again.  So skip it.\n                    P2 = P2.faceSuccessor;\n                }\n                /*      Finish off with the last stroke from the\n                   left node to the right, except when already\n                   topped out */\n                if (P2.faceSuccessor !== P0) {\n                    const newEdge = Triangulator.splitFace(graph, P0, P2);\n                    if (newEdge === undefined)\n                        return false;\n                }\n                start = right;\n                right = start.faceSuccessor;\n                left = start.facePredecessor;\n            }\n        }\n        return true;\n    }\n}\n/** @internal */\nTriangulator.sEnableDebugGraphCapture = false;\n// for reuse over all calls to isEar ....\nTriangulator._edgeInterval = Range1d.createNull();\nTriangulator._earRange = Range2d.createNull();\nTriangulator._edgeRange = Range2d.createNull();\nTriangulator._planes = [\n    Plane3dByOriginAndUnitNormal.createXYPlane(),\n    Plane3dByOriginAndUnitNormal.createXYPlane(),\n    Plane3dByOriginAndUnitNormal.createXYPlane(),\n];\nexport { Triangulator };\n/**\n * Internal class for assembling chains\n * @internal\n */\nclass AssembleXYZXYZChains extends PointStreamXYZXYZHandlerBase {\n    constructor(graph, id) {\n        super();\n        this._graph = graph;\n        this._id = id;\n    }\n    startChain(chainData, isLeaf) {\n        super.startChain(chainData, isLeaf);\n        this._baseNode = undefined;\n        this._nodeB = undefined;\n    }\n    handleXYZXYZ(x0, y0, z0, x1, y1, z1) {\n        this._nodeC = this._graph.createEdgeXYZXYZ(x0, y0, z0, this._id, x1, y1, z1, this._id);\n        if (this._baseNode === undefined) {\n            this._baseNode = this._nodeC;\n            this._nodeB = this._baseNode.faceSuccessor;\n        }\n        else {\n            HalfEdge.pinch(this._nodeB, this._nodeC);\n            this._nodeB = this._nodeC.faceSuccessor;\n        }\n    }\n    endChain(chainData, isLeaf) {\n        super.endChain(chainData, isLeaf);\n        if (this._baseNode !== undefined) {\n            if (this._seeds === undefined)\n                this._seeds = [];\n            this._seeds.push(this._baseNode);\n        }\n        this._baseNode = undefined;\n        this._nodeB = undefined;\n        this._nodeC = undefined;\n    }\n    claimSeeds() {\n        if (this._seeds === undefined)\n            return [];\n        return this._seeds;\n    }\n}\n//# sourceMappingURL=Triangulation.js.map",
      "start": 1693508123145,
      "end": 1693508123358,
      "sourcemaps": null
    }
  ]
}
