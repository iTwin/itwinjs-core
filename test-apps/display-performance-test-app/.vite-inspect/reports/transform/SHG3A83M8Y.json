{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/bentley/lib/esm/Id.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Ids\n */\nfunction toHex(str) {\n    const v = parseInt(str, 16);\n    return Number.isNaN(v) ? 0 : v;\n}\nfunction isLowerCaseNonZeroHexDigit(str, index) {\n    return isLowerCaseHexDigit(str, index, false);\n}\nfunction isLowerCaseHexDigit(str, index, allowZero = true) {\n    const charCode = str.charCodeAt(index);\n    const minDecimalDigit = allowZero ? 0x30 : 0x31; // '0' or '1'...\n    return (charCode >= minDecimalDigit && charCode <= 0x39) || (charCode >= 0x61 && charCode <= 0x66); //  '0'-'9, 'a' -'f'\n}\nfunction isValidHexString(id, startIndex, len) {\n    if (len === 0)\n        return false;\n    // No leading zeroes...\n    if (!isLowerCaseNonZeroHexDigit(id, startIndex))\n        return false;\n    // ...followed by len-1 lowercase hexadecimal digits.\n    for (let i = 1; i < len; i++)\n        if (!isLowerCaseHexDigit(id, startIndex + i))\n            return false;\n    return true;\n}\n/**\n * The Id64 namespace provides facilities for working with 64-bit identifiers. These Ids are stored as 64-bit integers inside an [[IModelDb]], but must be represented\n * as strings in JavaScript because JavaScript does not intrinsically support 64-bit integers.\n *\n * The [[Id64String]] type alias is used to indicate function arguments, return types, and variables which are known to contain a well-formed representation of a 64-bit Id.\n *\n * See [Working with Ids]($docs/learning/common/Id64.md) for a detailed description and code examples.\n * @public\n */\nexport var Id64;\n(function (Id64) {\n    /** Extract the \"local\" Id portion of an Id64String, contained in the lower 40 bits of the 64-bit value. */\n    function getLocalId(id) {\n        if (isInvalid(id))\n            return 0;\n        const len = id.length;\n        const start = (len > 12) ? (len - 10) : 2;\n        return toHex(id.slice(start));\n    }\n    Id64.getLocalId = getLocalId;\n    /** Extract the briefcase Id portion of an Id64String, contained in the upper 24 bits of the 64-bit value. */\n    function getBriefcaseId(id) {\n        if (isInvalid(id))\n            return 0;\n        const len = id.length;\n        return (len <= 12) ? 0 : toHex(id.slice(2, len - 10));\n    }\n    Id64.getBriefcaseId = getBriefcaseId;\n    /** Create an Id64String from its JSON representation.\n     * @param prop The JSON representation of an Id.\n     * @returns A well-formed Id string.\n     * @note if the input is undefined, the result is \"0\", indicating an invalid Id.\n     * @note if the input is not undefined, the result is the same as that of [[Id64.fromString]].\n     */\n    function fromJSON(prop) {\n        return typeof prop === \"string\" ? Id64.fromString(prop) : Id64.invalid;\n    }\n    Id64.fromJSON = fromJSON;\n    /** Given a string value, attempt to normalize it into a well-formed Id string.\n     * If the input is already a well-formed Id string, it is returned unmodified.\n     * Otherwise, the input is trimmed of leading and trailing whitespace, converted to lowercase, and an attempt is made to parse it as a 64-bit hexadecimal integer.\n     * If parsing succeeds the normalized result is returned; otherwise the result is \"0\", indicating an invalid Id.\n     *\n     * For a description of \"well-formed\", see [Working with Ids]($docs/learning/common/Id64.md).\n     */\n    function fromString(val) {\n        // NB: in case this is called from JavaScript, we must check the run-time type...\n        if (typeof val !== \"string\")\n            return Id64.invalid;\n        // Skip the common case in which the input is already a well-formed Id string\n        if (Id64.isId64(val))\n            return val;\n        // Attempt to normalize the input into a well-formed Id string\n        val = val.toLowerCase().trim();\n        const len = val.length;\n        if (len < 2 || val[0] !== \"0\" || val[1] !== \"x\")\n            return Id64.invalid;\n        let low = 0;\n        let high = 0;\n        let start = 2;\n        if (len > 12) {\n            start = (len - 10);\n            high = toHex(val.slice(2, start));\n        }\n        low = toHex(val.slice(start));\n        return fromLocalAndBriefcaseIds(low, high);\n    }\n    Id64.fromString = fromString;\n    // Used when constructing local ID portion of Id64String. Performance optimization.\n    const _localIdPrefixByLocalIdLength = [\n        \"0000000000\",\n        \"000000000\",\n        \"00000000\",\n        \"0000000\",\n        \"000000\",\n        \"00000\",\n        \"0000\",\n        \"000\",\n        \"00\",\n        \"0\",\n        \"\",\n    ];\n    /** Produce an Id string from a local and briefcase Id.\n     * @param localId The non-zero local Id as an unsigned 40-bit integer.\n     * @param briefcaseId The briefcase Id as an unsigned 24-bit integer.\n     * @returns an Id64String containing the hexadecimal string representation of the unsigned 64-bit integer which would result from the\n     * operation `localId | (briefcaseId << 40)`, or an invalid Id \"0\" if the inputs are invalid.\n     */\n    function fromLocalAndBriefcaseIds(localId, briefcaseId) {\n        // NB: Yes, we must check the run-time type...\n        if (typeof localId !== \"number\" || typeof briefcaseId !== \"number\")\n            return Id64.invalid;\n        localId = Math.floor(localId);\n        if (0 === localId)\n            return Id64.invalid;\n        briefcaseId = Math.floor(briefcaseId);\n        const lowStr = localId.toString(16);\n        return `0x${(briefcaseId === 0) ? lowStr : (briefcaseId.toString(16) + (_localIdPrefixByLocalIdLength[lowStr.length] + lowStr))}`;\n    }\n    Id64.fromLocalAndBriefcaseIds = fromLocalAndBriefcaseIds;\n    // Used as a buffer when converting a pair of 32-bit integers to an Id64String. Significant performance optimization.\n    const scratchCharCodes = [\n        0x30,\n        0x78,\n        0x30,\n        0x30,\n        0x30,\n        0x30,\n        0x30,\n        0x30,\n        0x30,\n        0x30,\n        0x30,\n        0x30,\n        0x30,\n        0x30,\n        0x30,\n        0x30,\n        0x30,\n        0x30,\n    ];\n    // Convert 4-bit unsigned integer to char code representing lower-case hexadecimal digit.\n    function uint4ToCharCode(uint4) {\n        return uint4 + (uint4 < 10 ? 0x30 : 0x57);\n    }\n    // Convert char code representing lower-case hexadecimal digit to 4-bit unsigned integer.\n    function charCodeToUint4(char) {\n        return char - (char >= 0x57 ? 0x57 : 0x30);\n    }\n    // Convert a substring to a uint32. This is twice as fast as using Number.parseInt().\n    function substringToUint32(id, start, end) {\n        let uint32 = 0;\n        for (let i = start; i < end; i++) {\n            const uint4 = charCodeToUint4(id.charCodeAt(i));\n            const shift = (end - i - 1) << 2;\n            const mask = uint4 << shift;\n            uint32 = (uint32 | mask) >>> 0; // >>> 0 to force unsigned because javascript\n        }\n        return uint32;\n    }\n    /** Create an Id64String from a pair of unsigned 32-bit integers.\n     * @param lowBytes The lower 4 bytes of the Id\n     * @param highBytes The upper 4 bytes of the Id\n     * @returns an Id64String containing the hexadecimal string representation of the unsigned 64-bit integer which would result from the\n     * operation `lowBytes | (highBytes << 32)`.\n     * @see [[Id64.fromUint32PairObject]] if you have a [[Id64.Uint32Pair]] object.\n     */\n    function fromUint32Pair(lowBytes, highBytes) {\n        const localIdLow = lowBytes >>> 0;\n        const localIdHigh = (highBytes & 0x000000ff) * (0xffffffff + 1); // aka (highBytes & 0xff) << 32\n        const localId = localIdLow + localIdHigh; // aka localIdLow | localIdHigh\n        if (0 === localId)\n            return Id64.invalid;\n        // Need to omit or preserve leading zeroes...\n        const buffer = scratchCharCodes;\n        let index = 2;\n        for (let i = 7; i >= 0; i--) {\n            const shift = i << 2;\n            const mask = 0xf << shift;\n            const uint4 = (highBytes & mask) >>> shift;\n            if (index > 2 || 0 !== uint4)\n                buffer[index++] = uint4ToCharCode(uint4);\n        }\n        for (let i = 7; i >= 0; i--) {\n            const shift = i << 2;\n            const mask = 0xf << shift;\n            const uint4 = (lowBytes & mask) >>> shift;\n            if (index > 2 || 0 !== uint4)\n                buffer[index++] = uint4ToCharCode(uint4);\n        }\n        if (buffer.length !== index)\n            buffer.length = index;\n        return String.fromCharCode(...scratchCharCodes);\n    }\n    Id64.fromUint32Pair = fromUint32Pair;\n    /** Create an Id64String from a [[Id64.Uint32Pair]].\n     * @see [[Id64.fromUint32Pair]].\n     */\n    function fromUint32PairObject(pair) {\n        return fromUint32Pair(pair.lower, pair.upper);\n    }\n    Id64.fromUint32PairObject = fromUint32PairObject;\n    /** Returns true if the inputs represent two halves of a valid 64-bit Id.\n     * @see [[Id64.Uint32Pair]].\n     */\n    function isValidUint32Pair(lowBytes, highBytes) {\n        // Detect local ID of zero\n        return 0 !== lowBytes || 0 !== (highBytes & 0x000000ff);\n    }\n    Id64.isValidUint32Pair = isValidUint32Pair;\n    /** Convert an Id64String to a 64-bit unsigned integer represented as a pair of unsigned 32-bit integers.\n     * @param id The well-formed string representation of a 64-bit Id.\n     * @param out Used as the return value if supplied; otherwise a new object is returned.\n     * @returns An object containing the parsed lower and upper 32-bit integers comprising the 64-bit Id.\n     */\n    function getUint32Pair(id, out) {\n        if (!out)\n            out = { lower: 0, upper: 0 };\n        out.lower = getLowerUint32(id);\n        out.upper = getUpperUint32(id);\n        return out;\n    }\n    Id64.getUint32Pair = getUint32Pair;\n    /** Extract an unsigned 32-bit integer from the lower 4 bytes of an Id64String. */\n    function getLowerUint32(id) {\n        if (isInvalid(id))\n            return 0;\n        const end = id.length;\n        const start = end > 10 ? end - 8 : 2;\n        return substringToUint32(id, start, end);\n    }\n    Id64.getLowerUint32 = getLowerUint32;\n    /** Extract an unsigned 32-bit integer from the upper 4 bytes of an Id64String. */\n    function getUpperUint32(id) {\n        const len = id.length;\n        if (len <= 10 || isInvalid(id))\n            return 0;\n        return substringToUint32(id, 2, len - 8);\n    }\n    Id64.getUpperUint32 = getUpperUint32;\n    /** Convert an [[Id64Arg]] into an [[Id64Set]].\n     *\n     * This method can be used by functions that accept an Id64Arg to conveniently process the value(s). For example:\n     * ```ts\n     *   public addCategories(arg: Id64Arg) { Id64.toIdSet(arg).forEach((id) => this.categories.add(id)); }\n     * ```\n     *\n     * Alternatively, to avoid allocating a new Id64Set, use [[Id64.iterable]].\n     *\n     * @param arg The Ids to convert to an Id64Set.\n     * @param makeCopy If true, and the input is already an Id64Set, returns a deep copy of the input.\n     * @returns An Id64Set containing the set of [[Id64String]]s represented by the Id64Arg.\n     */\n    function toIdSet(arg, makeCopy = false) {\n        if (arg instanceof Set)\n            return makeCopy ? new Set(arg) : arg;\n        const ids = new Set();\n        if (typeof arg === \"string\")\n            ids.add(arg);\n        else if (Array.isArray(arg)) {\n            arg.forEach((id) => {\n                if (typeof id === \"string\")\n                    ids.add(id);\n            });\n        }\n        return ids;\n    }\n    Id64.toIdSet = toIdSet;\n    /** Obtain iterator over the specified Ids.\n     * @see [[Id64.iterable]].\n     */\n    function* iterator(ids) {\n        if (typeof ids === \"string\") {\n            yield ids;\n        }\n        else {\n            for (const id of ids)\n                yield id;\n        }\n    }\n    Id64.iterator = iterator;\n    /** Obtain an iterable over the specified Ids. Example usage:\n     * ```ts\n     *  const ids = [\"0x123\", \"0xfed\"];\n     *  for (const id of Id64.iterable(ids))\n     *    console.log(id);\n     * ```\n     */\n    function iterable(ids) {\n        return {\n            [Symbol.iterator]: () => iterator(ids),\n        };\n    }\n    Id64.iterable = iterable;\n    /** Return the first [[Id64String]] of an [[Id64Arg]]. */\n    function getFirst(arg) {\n        return typeof arg === \"string\" ? arg : (Array.isArray(arg) ? arg[0] : arg.values().next().value);\n    }\n    Id64.getFirst = getFirst;\n    /** Return the number of [[Id64String]]s represented by an [[Id64Arg]]. */\n    function sizeOf(arg) {\n        return typeof arg === \"string\" ? 1 : (Array.isArray(arg) ? arg.length : arg.size);\n    }\n    Id64.sizeOf = sizeOf;\n    /** Returns true if the [[Id64Arg]] contains the specified Id. */\n    function has(arg, id) {\n        if (typeof arg === \"string\")\n            return arg === id;\n        if (Array.isArray(arg))\n            return -1 !== arg.indexOf(id);\n        return arg.has(id);\n    }\n    Id64.has = has;\n    /** The string representation of an invalid Id. */\n    Id64.invalid = \"0\";\n    /** Determine if the supplied id string represents a transient Id.\n     * @param id A well-formed Id string.\n     * @returns true if the Id represents a transient Id.\n     * @note This method assumes the input is a well-formed Id string.\n     * @see [[Id64.isTransientId64]]\n     * @see [[TransientIdSequence]]\n     */\n    function isTransient(id) {\n        // A transient Id is of the format \"0xffffffxxxxxxxxxx\" where the leading 6 digits indicate an invalid briefcase Id.\n        return 18 === id.length && id.startsWith(\"0xffffff\");\n    }\n    Id64.isTransient = isTransient;\n    /** Determine if the input is a well-formed [[Id64String]] and represents a transient Id.\n     * @see [[Id64.isTransient]]\n     * @see [[Id64.isId64]]\n     * @see [[TransientIdSequence]]\n     */\n    function isTransientId64(id) {\n        return isValidId64(id) && isTransient(id);\n    }\n    Id64.isTransientId64 = isTransientId64;\n    /** Determine if the input is a well-formed [[Id64String]].\n     *\n     * For a description of \"well-formed\", see [Working with Ids]($docs/learning/common/Id64.md).\n     * @see [[Id64.isValidId64]]\n     */\n    function isId64(id) {\n        const len = id.length;\n        if (0 === len || 18 < len)\n            return false;\n        if (\"0\" !== id[0])\n            return false;\n        // Well-formed invalid Id: \"0\"\n        if (1 === len)\n            return true;\n        // Valid Ids begin with \"0x\" followed by at least one lower-case hexadecimal digit.\n        if (2 === len || \"x\" !== id[1])\n            return false;\n        // If briefcase Id is present, it occupies at least one digit, followed by 10 digits for local Id\n        let localIdStart = 2;\n        if (len > 12) {\n            localIdStart = len - 10;\n            // Verify briefcase Id\n            if (!isValidHexString(id, 2, localIdStart - 2))\n                return false;\n            // Skip leading zeroes in local Id\n            for (let i = localIdStart; i < len; i++) {\n                if (0x30 !== id.charCodeAt(i)) // '0'\n                    break;\n                else\n                    localIdStart++;\n            }\n            if (localIdStart >= len)\n                return false;\n        }\n        return isValidHexString(id, localIdStart, len - localIdStart);\n    }\n    Id64.isId64 = isId64;\n    /** Returns true if the input is not equal to the representation of an invalid Id.\n     * @note This method assumes the input is a well-formed Id string.\n     * @see [[Id64.isInvalid]]\n     * @see [[Id64.isValidId64]]\n     */\n    function isValid(id) {\n        return Id64.invalid !== id;\n    }\n    Id64.isValid = isValid;\n    /** Returns true if the input is a well-formed [[Id64String]] representing a valid Id.\n     * @see [[Id64.isValid]]\n     * @see [[Id64.isId64]]\n     */\n    function isValidId64(id) {\n        return Id64.invalid !== id && Id64.isId64(id);\n    }\n    Id64.isValidId64 = isValidId64;\n    /** Returns true if the input is a well-formed [[Id64String]] representing an invalid Id.\n     * @see [[Id64.isValid]]\n     */\n    function isInvalid(id) {\n        return Id64.invalid === id;\n    }\n    Id64.isInvalid = isInvalid;\n    /** A specialized replacement for Set<Id64String> optimized for performance-critical code which represents large sets of [[Id64]]s as pairs of\n     * 32-bit integers.\n     * The internal representation is a Map<number, Set<number>> where the Map key is the upper 4 bytes of the IDs and the Set elements are the lower 4 bytes of the IDs.\n     * Because the upper 4 bytes store the 24-bit briefcase ID plus the upper 8 bits of the local ID, there will be a very small distribution of unique Map keys.\n     * To further optimize this data type, the following assumptions are made regarding the { lower, upper } inputs, and no validation is performed to confirm them:\n     *  - The inputs are unsigned 32-bit integers;\n     *  - The inputs represent a valid Id64String (e.g., local ID is not zero).\n     * @see [[Id64.Uint32Map]] for a similarly-optimized replacement for Map<Id64String, T>\n     * @public\n     */\n    class Uint32Set {\n        /** Construct a new Uint32Set.\n         * @param ids If supplied, all of the specified Ids will be added to the new set.\n         */\n        constructor(ids) {\n            this._map = new Map();\n            if (undefined !== ids)\n                this.addIds(ids);\n        }\n        /** Remove all contents of this set. */\n        clear() {\n            this._map.clear();\n        }\n        /** Add an Id to the set. */\n        addId(id) {\n            this.add(Id64.getLowerUint32(id), Id64.getUpperUint32(id));\n        }\n        /** Add any number of Ids to the set. */\n        addIds(ids) {\n            for (const id of Id64.iterable(ids))\n                this.addId(id);\n        }\n        /** Returns true if the set contains the specified Id. */\n        hasId(id) { return this.has(Id64.getLowerUint32(id), Id64.getUpperUint32(id)); }\n        /** Add an Id to the set. */\n        add(low, high) {\n            let set = this._map.get(high);\n            if (undefined === set) {\n                set = new Set();\n                this._map.set(high, set);\n            }\n            set.add(low);\n        }\n        /** Remove an Id from the set. */\n        deleteId(id) {\n            this.delete(Id64.getLowerUint32(id), Id64.getUpperUint32(id));\n        }\n        /** Remove any number of Ids from the set. */\n        deleteIds(ids) {\n            for (const id of Id64.iterable(ids))\n                this.deleteId(id);\n        }\n        /** Remove an Id from the set. */\n        delete(low, high) {\n            const set = this._map.get(high);\n            if (undefined !== set)\n                set.delete(low);\n        }\n        /** Returns true if the set contains the specified Id. */\n        has(low, high) {\n            const set = this._map.get(high);\n            return undefined !== set && set.has(low);\n        }\n        /** Returns true if the set contains the Id specified by `pair`. */\n        hasPair(pair) {\n            return this.has(pair.lower, pair.upper);\n        }\n        /** Returns true if the set contains no Ids. */\n        get isEmpty() { return 0 === this._map.size; }\n        /** Returns the number of Ids contained in the set. */\n        get size() {\n            let size = 0;\n            for (const entry of this._map)\n                size += entry[1].size;\n            return size;\n        }\n        /** Populates and returns an array of all Ids contained in the set. */\n        toId64Array() {\n            const ids = [];\n            for (const entry of this._map)\n                for (const low of entry[1])\n                    ids.push(Id64.fromUint32Pair(low, entry[0]));\n            return ids;\n        }\n        /** Populates and returns a set of all Ids contained in the set. */\n        toId64Set() {\n            const ids = new Set();\n            for (const entry of this._map)\n                for (const low of entry[1])\n                    ids.add(Id64.fromUint32Pair(low, entry[0]));\n            return ids;\n        }\n        /** Execute a function against each Id in this set. */\n        forEach(func) {\n            for (const entry of this._map)\n                for (const lo of entry[1])\n                    func(lo, entry[0]);\n        }\n    }\n    Id64.Uint32Set = Uint32Set;\n    /** A specialized replacement for Map<Id64String, T> optimized for performance-critical code.\n     * @see [[Id64.Uint32Set]] for implementation details.\n     * @public\n     */\n    class Uint32Map {\n        constructor() {\n            this._map = new Map();\n        }\n        /** Remove all entries from the map. */\n        clear() { this._map.clear(); }\n        /** Find an entry in the map by Id. */\n        getById(id) { return this.get(Id64.getLowerUint32(id), Id64.getUpperUint32(id)); }\n        /** Set an entry in the map by Id. */\n        setById(id, value) { this.set(Id64.getLowerUint32(id), Id64.getUpperUint32(id), value); }\n        /** Set an entry in the map by Id components. */\n        set(low, high, value) {\n            let map = this._map.get(high);\n            if (undefined === map) {\n                map = new Map();\n                this._map.set(high, map);\n            }\n            map.set(low, value);\n        }\n        /** Get an entry from the map by Id components. */\n        get(low, high) {\n            const map = this._map.get(high);\n            return undefined !== map ? map.get(low) : undefined;\n        }\n        /** Returns true if the map contains no entries. */\n        get isEmpty() { return 0 === this._map.size; }\n        /** Returns the number of entries in the map. */\n        get size() {\n            let size = 0;\n            for (const entry of this._map)\n                size += entry[1].size;\n            return size;\n        }\n        /** Execute a function against each entry in this map. */\n        forEach(func) {\n            for (const outerEntry of this._map)\n                for (const innerEntry of outerEntry[1])\n                    func(innerEntry[0], outerEntry[0], innerEntry[1]);\n        }\n    }\n    Id64.Uint32Map = Uint32Map;\n})(Id64 || (Id64 = {}));\n/**\n * Generates unique [[Id64String]] values in sequence, which are guaranteed not to conflict with Ids associated with persistent elements or models.\n * This is useful for associating stable, non-persistent identifiers with things like [Decorator]($frontend)s.\n * A TransientIdSequence can generate a maximum of (2^40)-2 unique Ids.\n * @public\n */\nexport class TransientIdSequence {\n    constructor() {\n        this._localId = 0;\n    }\n    /** Generate and return the next transient Id64String in the sequence.\n     * @deprecated in 3.x. Use [[getNext]].\n     */\n    get next() {\n        return this.getNext();\n    }\n    /** Generate and return the next transient Id64String in the sequence. */\n    getNext() {\n        return Id64.fromLocalAndBriefcaseIds(++this._localId, 0xffffff);\n    }\n    /** Preview the transient Id64String that will be returned by the next call to [[getNext]].\n     * This is primarily useful for tests.\n     */\n    peekNext() {\n        return Id64.fromLocalAndBriefcaseIds(this._localId + 1, 0xffffff);\n    }\n}\n/**\n * The Guid namespace provides facilities for working with GUID strings using the \"8-4-4-4-12\" pattern.\n *\n * The [[GuidString]] type alias is used to indicate function arguments, return types, and variables which are known to\n * be in the GUID format.\n * @public\n */\nexport var Guid;\n(function (Guid) {\n    const uuidPattern = new RegExp(\"^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$\");\n    /** Represents the empty Guid 00000000-0000-0000-0000-000000000000 */\n    Guid.empty = \"00000000-0000-0000-0000-000000000000\";\n    /** Determine whether the input string is \"guid-like\". That is, it follows the 8-4-4-4-12 pattern. This does not enforce\n     *  that the string is actually in valid UUID format.\n     */\n    function isGuid(value) {\n        return uuidPattern.test(value);\n    }\n    Guid.isGuid = isGuid;\n    /** Determine whether the input string is a valid V4 Guid string */\n    function isV4Guid(value) {\n        return /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-4[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$/.test(value);\n    }\n    Guid.isV4Guid = isV4Guid;\n    /** Create a new V4 Guid value */\n    function createValue() {\n        // https://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript\n        return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c) => {\n            const r = Math.random() * 16 | 0;\n            const v = c === \"x\" ? r : (r & 0x3 | 0x8);\n            return v.toString(16);\n        });\n    }\n    Guid.createValue = createValue;\n    /**\n     * Normalize a Guid string if possible. Normalization consists of:\n     * - Convert all characters to lower case\n     * - Trim any leading or trailing whitespace\n     * - Convert to the standard Guid format \"8-4-4-4-12\", repositioning the '-' characters as necessary, presuming there are exactly 32 hexadecimal digits.\n     * @param value Input value that represents a Guid\n     * @returns Normalized representation of the Guid string. If the normalization fails, return the *original* value unmodified (Note: it is *not* a valid Guid)\n     */\n    function normalize(value) {\n        const lowerValue = value.toLowerCase().trim();\n        // Return if it's already formatted to be a Guid\n        if (isGuid(lowerValue))\n            return lowerValue;\n        // Remove any existing \"-\" characters and position them properly, if there remains exactly 32 hexadecimal digits\n        const noDashValue = lowerValue.replace(/-/g, \"\");\n        const noDashPattern = /^([0-9a-f]{8})([0-9a-f]{4})([0-9a-f]{4})([0-9a-f]{4})([0-9a-f]{12})$/;\n        if (noDashPattern.test(noDashValue)) {\n            return noDashValue.replace(noDashPattern, (_match, p1, p2, p3, p4, p5) => `${p1}-${p2}-${p3}-${p4}-${p5}`);\n        }\n        // Return unmodified string - (note: it is *not* a valid Guid)\n        return value;\n    }\n    Guid.normalize = normalize;\n})(Guid || (Guid = {}));\n//# sourceMappingURL=Id.js.map",
      "start": 1693508120296,
      "end": 1693508120453,
      "sourcemaps": null
    }
  ]
}
