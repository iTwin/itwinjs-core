{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/SheetViewState.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Views\n */\nimport { assert, CompressedId64Set, dispose } from \"@itwin/core-bentley\";\nimport { Angle, ClipShape, ClipVector, Constant, Matrix3d, Point2d, Point3d, PolyfaceBuilder, Range2d, Range3d, StrokeOptions, Transform } from \"@itwin/core-geometry\";\nimport { ColorDef, Feature, FeatureTable, Frustum, Gradient, GraphicParams, PackedFeatureTable, Placement2d, TextureTransparency, } from \"@itwin/core-common\";\nimport { CategorySelectorState } from \"./CategorySelectorState\";\nimport { DisplayStyle2dState } from \"./DisplayStyleState\";\nimport { GraphicType } from \"./render/GraphicBuilder\";\nimport { GraphicBranch } from \"./render/GraphicBranch\";\nimport { Frustum2d } from \"./Frustum2d\";\nimport { MockRender } from \"./render/MockRender\";\nimport { FeatureSymbology } from \"./render/FeatureSymbology\";\nimport { IModelApp } from \"./IModelApp\";\nimport { CoordSystem } from \"./CoordSystem\";\nimport { OffScreenViewport } from \"./Viewport\";\nimport { ViewState2d } from \"./ViewState\";\nimport { createDefaultViewFlagOverrides, TileGraphicType } from \"./tile/internal\";\nimport { imageBufferToPngDataUrl, openImageDataUrlInNewWindow } from \"./common/ImageUtil\";\nimport { ViewRect } from \"./common/ViewRect\";\n// cSpell:ignore ovrs\n/** Describes the geometry and styling of a sheet border decoration.\n * The sheet border decoration mimics a sheet of paper with a drop shadow.\n */\nclass SheetBorder {\n    constructor(rect, shadow, gradient) {\n        this._rect = rect;\n        this._shadow = shadow;\n        this._gradient = gradient;\n    }\n    /** Create a new sheet border. If a context is supplied, points are transformed to view coordinates. */\n    static create(width, height, context) {\n        // Rect\n        const rect = [\n            Point3d.create(0, height),\n            Point3d.create(0, 0),\n            Point3d.create(width, 0),\n            Point3d.create(width, height),\n            Point3d.create(0, height)\n        ];\n        if (context) {\n            context.viewport.worldToViewArray(rect);\n        }\n        // Shadow\n        const shadowWidth = .01 * Math.sqrt(width * width + height * height);\n        const shadow = [\n            Point3d.create(shadowWidth, 0),\n            Point3d.create(shadowWidth, -shadowWidth),\n            Point3d.create(width + shadowWidth, -shadowWidth),\n            Point3d.create(width + shadowWidth, height - shadowWidth),\n            Point3d.create(width, height - shadowWidth),\n            Point3d.create(width, 0),\n            Point3d.create(shadowWidth, 0),\n        ];\n        if (context) {\n            context.viewport.worldToViewArray(shadow);\n        }\n        // Gradient\n        const gradient = new Gradient.Symb();\n        gradient.mode = Gradient.Mode.Linear;\n        gradient.angle = Angle.createDegrees(-45);\n        gradient.keys = [{ value: 0, color: ColorDef.from(25, 25, 25) }, { value: 0.5, color: ColorDef.from(150, 150, 150) }];\n        // Copy over points\n        const rect2d = [];\n        for (const point of rect)\n            rect2d.push(Point2d.createFrom(point));\n        const shadow2d = [];\n        for (const point of shadow)\n            shadow2d.push(Point2d.createFrom(point));\n        return new SheetBorder(rect2d, shadow2d, gradient);\n    }\n    getRange() {\n        const range = Range2d.createArray(this._rect);\n        const shadowRange = Range2d.createArray(this._shadow);\n        range.extendRange(shadowRange);\n        return range;\n    }\n    /** Add this border to the given GraphicBuilder. */\n    addToBuilder(builder) {\n        const lineColor = ColorDef.black;\n        const fillColor = ColorDef.black;\n        const params = new GraphicParams();\n        params.fillColor = fillColor;\n        params.gradient = this._gradient;\n        builder.activateGraphicParams(params);\n        builder.addShape2d(this._shadow, Frustum2d.minimumZDistance);\n        builder.setSymbology(lineColor, fillColor, 2);\n        builder.addLineString2d(this._rect, 0);\n    }\n}\n/** The information required to instantiate an ViewAttachments object to draw ViewAttachments into a sheet. The list of view attachment Ids is\n * supplied to SheetViewState via the constructor. The corresponding ViewAttachmentProps for each attachment are obtained asynchronously in\n * SheetViewState.load(). The Attachments object is created in SheetViewState.attachToViewport and disposed of in SheetViewState.detachFromViewport.\n */\nclass ViewAttachmentsInfo {\n    constructor(attachments) {\n        this._attachments = attachments;\n    }\n    get isLoaded() {\n        return 0 === this._attachments.length || \"string\" !== typeof this._attachments[0];\n    }\n    get viewAttachmentProps() {\n        return this.isLoaded ? this._props : [];\n    }\n    get _props() {\n        assert(this.isLoaded);\n        return this._attachments;\n    }\n    get _ids() {\n        assert(!this.isLoaded);\n        return this._attachments;\n    }\n    static fromJSON(ids = []) {\n        return new ViewAttachmentsInfo(ids);\n    }\n    toJSON() {\n        return this.isLoaded ? this._props.map((x) => x.id) : [...this._ids];\n    }\n    clone() {\n        // No reason to clone the array.\n        return new ViewAttachmentsInfo(this._attachments);\n    }\n    preload(options) {\n        if (this.isLoaded)\n            return;\n        options.sheetViewAttachmentIds = CompressedId64Set.sortAndCompress(this._ids);\n        options.viewStateLoadProps = {\n            displayStyle: {\n                omitScheduleScriptElementIds: !IModelApp.tileAdmin.enableFrontendScheduleScripts,\n                compressExcludedElementIds: true,\n            },\n        };\n    }\n    async postload(options, iModel) {\n        if (options.sheetViewViews === undefined)\n            return;\n        if (options.sheetViewAttachmentProps === undefined)\n            return;\n        const viewStateProps = options.sheetViewViews; // This is viewstateProps, need to turn this into ViewState\n        const promises = [];\n        for (const viewProps of viewStateProps) {\n            const loadView = async () => {\n                try {\n                    if (viewProps === undefined)\n                        return undefined;\n                    const view = await iModel.views.convertViewStatePropsToViewState(viewProps);\n                    return view;\n                }\n                catch {\n                    return undefined;\n                }\n            };\n            promises.push(loadView());\n        }\n        const views = await Promise.all(promises);\n        const attachmentProps = options.sheetViewAttachmentProps;\n        assert(views.length === attachmentProps.length);\n        const attachments = [];\n        for (let i = 0; i < views.length; i++) {\n            const view = views[i];\n            if (view && !(view instanceof SheetViewState)) {\n                const props = attachmentProps[i];\n                props.attachedView = view;\n                attachments.push(props);\n            }\n        }\n        this._attachments = attachments;\n    }\n    async load(iModel) {\n        if (this.isLoaded)\n            return;\n        const attachmentProps = await iModel.elements.getProps(this._ids);\n        const promises = [];\n        for (const attachment of attachmentProps) {\n            const loadView = async () => {\n                try {\n                    const view = await iModel.views.load(attachment.view.id);\n                    return view;\n                }\n                catch {\n                    return undefined;\n                }\n            };\n            promises.push(loadView());\n        }\n        const views = await Promise.all(promises);\n        assert(views.length === attachmentProps.length);\n        const attachments = [];\n        for (let i = 0; i < views.length; i++) {\n            const view = views[i];\n            if (view && !(view instanceof SheetViewState)) {\n                const props = attachmentProps[i];\n                props.attachedView = view;\n                attachments.push(props);\n            }\n        }\n        this._attachments = attachments;\n    }\n    createAttachments(sheetView) {\n        return this.isLoaded ? new ViewAttachments(this._props, sheetView) : undefined;\n    }\n}\n/** The set of view attachments to be displayed in a Viewport via a SheetViewState. Allocated when the view becomes attached to a Viewport;\n * disposed of when it becomes detached from the viewport.\n */\nclass ViewAttachments {\n    constructor(infos, sheetView) {\n        this._attachments = [];\n        this.maxDepth = Frustum2d.minimumZDistance;\n        for (const info of infos) {\n            const drawAsRaster = info.jsonProperties?.displayOptions?.drawAsRaster || (info.attachedView.is3d() && info.attachedView.isCameraOn);\n            const ctor = drawAsRaster ? RasterAttachment : OrthographicAttachment;\n            const attachment = new ctor(info.attachedView, info, sheetView);\n            this._attachments.push(attachment);\n            this.maxDepth = Math.max(this.maxDepth, attachment.zDepth);\n        }\n    }\n    dispose() {\n        for (const attachment of this._attachments)\n            attachment.dispose();\n        this._attachments.length = 0;\n    }\n    [Symbol.iterator]() {\n        return this._attachments[Symbol.iterator]();\n    }\n    /** For tests. */\n    get attachments() {\n        return this._attachments;\n    }\n    get isEmpty() {\n        return 0 === this._attachments.length;\n    }\n    get areAllTileTreesLoaded() {\n        return this._attachments.every((x) => x.areAllTileTreesLoaded);\n    }\n    discloseTileTrees(trees) {\n        for (const attachment of this._attachments)\n            trees.disclose(attachment);\n    }\n    collectStatistics(stats) {\n        for (const attachment of this._attachments)\n            attachment.collectStatistics(stats);\n    }\n    addToScene(context) {\n        for (const attachment of this._attachments)\n            attachment.addToScene(context);\n    }\n    findById(attachmentId) {\n        return this._attachments.find((attachment) => attachment.viewAttachmentProps.id === attachmentId);\n    }\n}\n/** A view of a [SheetModel]($backend).\n * @public\n * @extensions\n */\nexport class SheetViewState extends ViewState2d {\n    get attachmentIds() {\n        return this._attachmentsInfo.toJSON();\n    }\n    static get className() { return \"SheetViewDefinition\"; }\n    static createFromProps(viewStateData, iModel) {\n        const cat = new CategorySelectorState(viewStateData.categorySelectorProps, iModel);\n        const displayStyleState = new DisplayStyle2dState(viewStateData.displayStyleProps, iModel);\n        // use \"new this\" so subclasses are correct\n        return new this(viewStateData.viewDefinitionProps, iModel, cat, displayStyleState, viewStateData.sheetProps, viewStateData.sheetAttachments);\n    }\n    toProps() {\n        const props = super.toProps();\n        props.sheetAttachments = this._attachmentsInfo.toJSON();\n        // For sheetProps all that is actually used is the size, so just null out everything else.\n        const codeProps = { spec: \"\", scope: \"\", value: \"\" };\n        props.sheetProps = {\n            model: \"\",\n            code: codeProps,\n            classFullName: \"\",\n            width: this.sheetSize.x,\n            height: this.sheetSize.y,\n            scale: 1,\n        };\n        return props;\n    }\n    /** Strictly for testing. @internal */\n    get viewAttachmentProps() {\n        return this._attachmentsInfo.viewAttachmentProps;\n    }\n    /** Strictly for testing. @internal */\n    get attachments() {\n        return this._attachments?.attachments;\n    }\n    /** @internal */\n    isDrawingView() { return false; }\n    /** @internal */\n    isSheetView() { return true; }\n    constructor(props, iModel, categories, displayStyle, sheetProps, attachments) {\n        super(props, iModel, categories, displayStyle);\n        if (categories instanceof SheetViewState) {\n            // we are coming from clone...\n            this.sheetSize = categories.sheetSize.clone();\n            this._attachmentsInfo = categories._attachmentsInfo.clone();\n            this._viewedExtents = categories._viewedExtents.clone();\n        }\n        else {\n            this.sheetSize = Point2d.create(sheetProps.width, sheetProps.height);\n            this._attachmentsInfo = ViewAttachmentsInfo.fromJSON(attachments);\n            const extents = new Range3d(0, 0, 0, this.sheetSize.x, this.sheetSize.y, 0);\n            const margin = 1.1;\n            extents.scaleAboutCenterInPlace(margin);\n            this._viewedExtents = extents;\n        }\n    }\n    getOrigin() {\n        const origin = super.getOrigin();\n        if (this._attachments)\n            origin.z = -this._attachments.maxDepth;\n        return origin;\n    }\n    getExtents() {\n        const extents = super.getExtents();\n        if (this._attachments)\n            extents.z = this._attachments.maxDepth + Frustum2d.minimumZDistance;\n        return extents;\n    }\n    /** Overrides [[ViewState.discloseTileTrees]] to include tile trees associated with [ViewAttachment]($backend)s displayed on this sheet. */\n    discloseTileTrees(trees) {\n        super.discloseTileTrees(trees);\n        if (this._attachments)\n            trees.disclose(this._attachments);\n    }\n    /** @internal */\n    collectNonTileTreeStatistics(stats) {\n        super.collectNonTileTreeStatistics(stats);\n        if (this._attachments)\n            this._attachments.collectStatistics(stats);\n    }\n    /** @internal */\n    get defaultExtentLimits() {\n        return { min: Constant.oneMillimeter, max: this.sheetSize.magnitude() * 10 };\n    }\n    /** @internal */\n    getViewedExtents() {\n        return this._viewedExtents;\n    }\n    /** @internal */\n    preload(hydrateRequest) {\n        super.preload(hydrateRequest);\n        this._attachmentsInfo.preload(hydrateRequest);\n    }\n    /** @internal */\n    async postload(hydrateResponse) {\n        const promises = [];\n        promises.push(super.postload(hydrateResponse));\n        promises.push(this._attachmentsInfo.postload(hydrateResponse, this.iModel));\n        await Promise.all(promises);\n    }\n    /** @internal */\n    createScene(context) {\n        super.createScene(context);\n        if (this._attachments)\n            this._attachments.addToScene(context);\n    }\n    /** @internal */\n    get secondaryViewports() {\n        const attachments = this._attachments;\n        if (!attachments)\n            return super.secondaryViewports;\n        function* iterator() {\n            for (const attachment of attachments) {\n                const vp = attachment.viewport;\n                if (vp)\n                    yield vp;\n            }\n        }\n        return {\n            [Symbol.iterator]: () => iterator(),\n        };\n    }\n    /** @internal */\n    async queryAttachmentIds() {\n        const ecsql = `SELECT ECInstanceId as attachmentId FROM bis.ViewAttachment WHERE model.Id=${this.baseModelId}`;\n        const ids = [];\n        for await (const row of this.iModel.createQueryReader(ecsql))\n            ids.push(row[0]);\n        return ids;\n    }\n    /** @internal */\n    async changeViewedModel(modelId) {\n        await super.changeViewedModel(modelId);\n        const attachmentIds = await this.queryAttachmentIds();\n        this._attachmentsInfo = ViewAttachmentsInfo.fromJSON(attachmentIds);\n        assert(undefined === this._attachments);\n    }\n    /** See [[ViewState.attachToViewport]]. */\n    attachToViewport(args) {\n        super.attachToViewport(args);\n        assert(undefined === this._attachments);\n        this._attachments = this._attachmentsInfo.createAttachments(this);\n    }\n    /** See [[ViewState.detachFromViewport]]. */\n    detachFromViewport() {\n        super.detachFromViewport();\n        this._attachments = dispose(this._attachments);\n    }\n    /** @internal */\n    get areAllTileTreesLoaded() {\n        return super.areAllTileTreesLoaded && (!this._attachments || this._attachments.areAllTileTreesLoaded);\n    }\n    /** Create a sheet border decoration graphic. */\n    createBorder(width, height, context) {\n        const border = SheetBorder.create(width, height, context);\n        const builder = context.createGraphicBuilder(GraphicType.ViewBackground);\n        border.addToBuilder(builder);\n        return builder.finish();\n    }\n    /** @internal */\n    decorate(context) {\n        super.decorate(context);\n        if (this.sheetSize !== undefined) {\n            const border = this.createBorder(this.sheetSize.x, this.sheetSize.y, context);\n            context.setViewBackground(border);\n        }\n    }\n    /** @internal */\n    computeFitRange() {\n        const size = this.sheetSize;\n        if (0 >= size.x || 0 >= size.y)\n            return super.computeFitRange();\n        return new Range3d(0, 0, -1, size.x, size.y, 1);\n    }\n    /** @internal */\n    getAttachmentViewport(id) {\n        return this._attachments?.findById(id)?.viewport;\n    }\n    /** @internal */\n    computeDisplayTransform(args) {\n        // ###TODO check if the attached view has a display transform...\n        const attachment = undefined !== args.viewAttachmentId ? this._attachments?.findById(args.viewAttachmentId) : undefined;\n        return attachment && attachment instanceof OrthographicAttachment ? attachment.toSheet.clone() : undefined;\n    }\n}\n/** A mostly no-op RenderTarget for an Attachment.\n * its Scene and symbology overrides.\n */\nclass AttachmentTarget extends MockRender.OffScreenTarget {\n    constructor(attachment) {\n        // The dimensions don't matter - we're not drawing anything.\n        const rect = new ViewRect(1, 1);\n        super(IModelApp.renderSystem, rect);\n        this._attachment = attachment;\n    }\n    changeScene(scene) {\n        this._attachment.scene = scene;\n    }\n    overrideFeatureSymbology(ovrs) {\n        this._attachment.symbologyOverrides = ovrs;\n    }\n}\n/** Draws the contents a 2d or orthographic 3d view directly into a sheet view.\n * We select tiles for the view in the context of a light-weight offscreen viewport with a no-op RenderTarget, then\n * collect the resultant graphics and add them to the sheet view's scene.\n */\nclass OrthographicAttachment {\n    get view() {\n        return this._viewport.view;\n    }\n    get viewAttachmentProps() {\n        return this._props;\n    }\n    get viewport() {\n        return this._viewport;\n    }\n    constructor(view, props, sheetView) {\n        this._viewRect = new ViewRect(0, 0, 1, 1);\n        this._originalFrustum = new Frustum();\n        this.symbologyOverrides = new FeatureSymbology.Overrides(view);\n        const target = new AttachmentTarget(this);\n        this._viewport = OffScreenViewport.createViewport(view, target, true);\n        this._props = props;\n        this._sheetModelId = sheetView.baseModelId;\n        const applyClip = true; // set to false for debugging\n        this._viewFlagOverrides = {\n            ...view.viewFlags,\n            clipVolume: applyClip,\n            lighting: false,\n            shadows: false,\n        };\n        const placement = Placement2d.fromJSON(props.placement);\n        const range = placement.calculateRange();\n        this._range = range;\n        this._sizeInMeters = new Point2d(range.xLength(), range.yLength());\n        // Compute transform from attached view's world coordinates to sheet's world coordinates.\n        // NB: We obtain the extents and origin from the *viewport* not the *view* - they may have been adjusted by the viewport.\n        const applySkew = true; // set to false for debugging\n        const skew = applySkew ? view.getAspectRatioSkew() : 1;\n        const extents = this._viewport.viewingSpace.viewDelta.clone();\n        const zDepth = Math.abs(extents.z);\n        const scaleX = this._sizeInMeters.x / Math.abs(extents.x);\n        const scaleY = skew * this._sizeInMeters.y / Math.abs(extents.y);\n        this._scale = { x: 1 / scaleX, y: 1 / scaleY };\n        const zBias = Frustum2d.depthFromDisplayPriority(props.jsonProperties?.displayPriority ?? 0);\n        this.zDepth = 1.01 * (zDepth - zBias); // give a little padding so that geometry right up against far plane doesn't get clipped.\n        // View origin is at the *back* of the view. Align *front* of view based on display priority.\n        const viewRot = view.getRotation();\n        const viewOrg = viewRot.multiplyVector(this._viewport.viewingSpace.viewOrigin);\n        viewOrg.z += zDepth;\n        viewRot.multiplyTransposeVectorInPlace(viewOrg);\n        const matrix = Matrix3d.createScale(scaleX, scaleY, 1);\n        matrix.multiplyMatrixMatrix(viewRot, matrix);\n        const origin = Matrix3d.xyzMinusMatrixTimesXYZ(viewOrg, matrix, viewOrg);\n        const attachmentOrigin = Point3d.createFrom(placement.origin);\n        attachmentOrigin.z = zBias;\n        const viewOrgToAttachment = attachmentOrigin.minus(viewOrg);\n        origin.addInPlace(viewOrgToAttachment);\n        this._toSheet = Transform.createRefs(origin, matrix);\n        this._fromSheet = this._toSheet.inverse();\n        // If the attached view is a section drawing, it may itself have an attached spatial view with a clip.\n        // The clip needs to be transformed into sheet space.\n        if (view.isDrawingView())\n            this._viewport.drawingToSheetTransform = this._toSheet;\n        // ###TODO? If we also apply the attachment's clip to the attached view, we may get additional culling during tile selection.\n        // However the attached view's frustum is already clipped by intersection with sheet view's frustum, and additional clipping planes\n        // introduce additional computation, so possibly not worth it.\n        // Transform the view's clip (if any) to sheet space\n        let viewClip = view.viewFlags.clipVolume ? view.getViewClip()?.clone() : undefined;\n        if (viewClip)\n            viewClip.transformInPlace(this._toSheet);\n        else\n            viewClip = ClipVector.createEmpty();\n        let sheetClip;\n        if (undefined !== props.jsonProperties?.clip)\n            sheetClip = ClipVector.fromJSON(props.jsonProperties?.clip);\n        if (sheetClip && sheetClip.isValid) {\n            // Clip to view attachment's clip. NB: clip is in sheet coordinate space.\n            for (const clip of sheetClip.clips)\n                viewClip.clips.push(clip);\n        }\n        else {\n            // Clip to view attachment's bounding box\n            viewClip.appendShape([\n                Point3d.create(this._range.low.x, this._range.low.y),\n                Point3d.create(this._range.high.x, this._range.low.y),\n                Point3d.create(this._range.high.x, this._range.high.y),\n                Point3d.create(this._range.low.x, this._range.high.y),\n            ]);\n        }\n        this._clipVolume = IModelApp.renderSystem.createClipVolume(viewClip);\n        // Save off the original frustum (potentially adjusted by viewport).\n        this._viewport.setupFromView();\n        this._viewport.viewingSpace.getFrustum(CoordSystem.World, true, this._originalFrustum);\n        const applyHiddenLineSettings = true; // for debugging edge display, set to false...\n        const style = view.displayStyle;\n        if (style.is3d() && applyHiddenLineSettings)\n            this._hiddenLineSettings = style.settings.hiddenLineSettings;\n    }\n    dispose() {\n        this._viewport.dispose();\n    }\n    discloseTileTrees(trees) {\n        trees.disclose(this._viewport);\n    }\n    addToScene(context) {\n        if (context.viewport.freezeScene)\n            return;\n        if (!context.viewport.view.viewsCategory(this._props.category))\n            return;\n        const wantBounds = context.viewport.wantViewAttachmentBoundaries;\n        const wantClipShapes = context.viewport.wantViewAttachmentClipShapes;\n        if (wantBounds || wantClipShapes) {\n            const builder = context.createSceneGraphicBuilder();\n            if (wantBounds) {\n                builder.setSymbology(ColorDef.red, ColorDef.red, 2);\n                builder.addRangeBox(this._range);\n            }\n            if (wantClipShapes && this._clipVolume) {\n                builder.setSymbology(ColorDef.blue, ColorDef.blue, 2);\n                for (const prim of this._clipVolume.clipVector.clips) {\n                    if (!(prim instanceof ClipShape))\n                        continue; // ###TODO handle non-shape primitives, if any such ever encountered\n                    const pts = [];\n                    const tf = prim.transformFromClip;\n                    for (const pt of prim.polygon) {\n                        const tfPt = tf ? tf.multiplyPoint3d(pt) : pt;\n                        pts.push(new Point2d(tfPt.x, tfPt.y));\n                    }\n                    builder.addLineString2d(pts, 0);\n                }\n            }\n            // Put into a Batch so that we can see tooltip with attachment Id on mouseover.\n            const batch = context.target.renderSystem.createBatch(builder.finish(), this.getDebugFeatureTable(), this._range);\n            context.outputGraphic(batch);\n        }\n        if (!context.viewport.wantViewAttachments)\n            return;\n        // Pixel size used to compute size of ViewRect so that tiles of appropriate LOD are selected.\n        const pixelSize = context.viewport.getPixelSizeAtPoint();\n        if (0 === pixelSize)\n            return;\n        // Adjust attached view frustum based on intersection with sheet view frustum.\n        const attachFrustum = this._originalFrustum.transformBy(this._toSheet);\n        const attachFrustumRange = attachFrustum.toRange();\n        const sheetFrustum = context.viewport.getWorldFrustum();\n        const sheetFrustumRange = sheetFrustum.toRange();\n        const intersect = attachFrustumRange.intersect(sheetFrustumRange);\n        if (intersect.isNull)\n            return;\n        attachFrustum.initFromRange(intersect);\n        attachFrustum.transformBy(this._fromSheet, attachFrustum);\n        this._viewport.setupViewFromFrustum(attachFrustum);\n        // Adjust view rect based on size of attachment on screen so that tiles of appropriate LOD are selected.\n        const width = this._sizeInMeters.x * intersect.xLength() / attachFrustumRange.xLength();\n        const height = this._sizeInMeters.y * intersect.yLength() / attachFrustumRange.yLength();\n        this._viewRect.width = Math.max(1, Math.round(width / pixelSize));\n        this._viewRect.height = Math.max(1, Math.round(height / pixelSize));\n        this._viewport.setRect(this._viewRect);\n        // Propagate settings from on-screen viewport.\n        this._viewport.debugBoundingBoxes = context.viewport.debugBoundingBoxes;\n        this._viewport.setTileSizeModifier(context.viewport.tileSizeModifier);\n        // Create the scene.\n        this._viewport.renderFrame();\n        const scene = this.scene;\n        if (!scene)\n            return;\n        // Extract scene graphics and insert into on-screen scene context.\n        const options = {\n            viewAttachmentId: this._props.id,\n            clipVolume: this._clipVolume,\n            hline: this._hiddenLineSettings,\n            frustum: {\n                is3d: this.view.is3d(),\n                scale: this._scale,\n            },\n        };\n        const outputGraphics = (source) => {\n            if (0 === source.length)\n                return;\n            const graphics = new GraphicBranch();\n            graphics.setViewFlagOverrides(this._viewFlagOverrides);\n            graphics.symbologyOverrides = this.symbologyOverrides;\n            for (const graphic of source)\n                graphics.entries.push(graphic);\n            const branch = context.createGraphicBranch(graphics, this._toSheet, options);\n            context.outputGraphic(branch);\n        };\n        outputGraphics(scene.foreground);\n        context.withGraphicType(TileGraphicType.BackgroundMap, () => outputGraphics(scene.background));\n        context.withGraphicType(TileGraphicType.Overlay, () => outputGraphics(scene.overlay));\n        // Report tile statistics to sheet view's viewport.\n        const tileAdmin = IModelApp.tileAdmin;\n        const selectedAndReady = tileAdmin.getTilesForUser(this._viewport);\n        const requested = tileAdmin.getRequestsForUser(this._viewport);\n        tileAdmin.addExternalTilesForUser(context.viewport, {\n            requested: requested?.size ?? 0,\n            selected: selectedAndReady?.selected.size ?? 0,\n            ready: selectedAndReady?.ready.size ?? 0,\n        });\n    }\n    getDebugFeatureTable() {\n        if (this._debugFeatureTable)\n            return this._debugFeatureTable;\n        const featureTable = new FeatureTable(1, this._sheetModelId);\n        featureTable.insert(new Feature(this._props.id));\n        this._debugFeatureTable = PackedFeatureTable.pack(featureTable);\n        return this._debugFeatureTable;\n    }\n    get areAllTileTreesLoaded() {\n        return this.view.areAllTileTreesLoaded;\n    }\n    collectStatistics(_stats) {\n        // Handled by discloseTileTrees()\n    }\n    get toSheet() {\n        return this._toSheet;\n    }\n}\nfunction createRasterAttachmentViewport(_view, _rect, _attachment) {\n    class RasterAttachmentViewport extends OffScreenViewport {\n        constructor(view, rect, attachment) {\n            super(IModelApp.renderSystem.createOffscreenTarget(rect));\n            this._isSceneReady = false;\n            this._attachment = attachment;\n            this._isAspectRatioLocked = true;\n            this.changeView(view);\n        }\n        createSceneContext() {\n            assert(!this._isSceneReady);\n            this._sceneContext = super.createSceneContext();\n            return this._sceneContext;\n        }\n        renderFrame() {\n            assert(!this._isSceneReady);\n            this.clearSceneContext();\n            super.renderFrame();\n            if (undefined !== this._sceneContext) {\n                this._isSceneReady = !this._sceneContext.hasMissingTiles && this.view.areAllTileTreesLoaded;\n                if (this._isSceneReady)\n                    this._attachment.produceGraphics(this._sceneContext);\n                this._sceneContext = undefined;\n            }\n        }\n        clearSceneContext() {\n            this._sceneContext = undefined;\n        }\n        addDecorations(_decorations) {\n            // ###TODO: skybox, ground plane, possibly grid. DecorateContext requires a ScreenViewport...\n        }\n    }\n    return new RasterAttachmentViewport(_view, _rect, _attachment);\n}\n/** Draws a 3d view with camera enabled into a sheet view by producing an image of the view's contents offscreen. */\nclass RasterAttachment {\n    constructor(view, props, sheetView) {\n        // Render to a 2048x2048 view rect. Scale in Y to preserve aspect ratio.\n        const maxSize = 2048;\n        const rect = new ViewRect(0, 0, maxSize, maxSize);\n        const height = maxSize * view.getAspectRatio() * view.getAspectRatioSkew();\n        const skew = maxSize / height;\n        view.setAspectRatioSkew(skew);\n        if (true !== props.jsonProperties?.displayOptions?.preserveBackground) {\n            // Make background color 100% transparent so that Viewport.readImageBuffer() will discard transparent pixels.\n            const bgColor = sheetView.displayStyle.backgroundColor.withAlpha(0);\n            view.displayStyle.backgroundColor = bgColor;\n        }\n        this._viewport = createRasterAttachmentViewport(view, rect, this);\n        this._props = props;\n        this._placement = Placement2d.fromJSON(props.placement);\n        this._transform = this._placement.transform;\n        this.zDepth = Frustum2d.depthFromDisplayPriority(props.jsonProperties?.displayPriority ?? 0);\n    }\n    dispose() {\n        this._viewport?.dispose();\n    }\n    get viewAttachmentProps() {\n        return this._props;\n    }\n    get viewport() {\n        return this._viewport;\n    }\n    get areAllTileTreesLoaded() {\n        return this._viewport?.areAllTileTreesLoaded ?? true;\n    }\n    addToScene(context) {\n        // ###TODO: check viewport.wantViewAttachmentClipShapes\n        if (!context.viewport.view.viewsCategory(this._props.category))\n            return;\n        if (context.viewport.wantViewAttachmentBoundaries) {\n            const builder = context.createSceneGraphicBuilder(this._transform);\n            builder.setSymbology(ColorDef.red, ColorDef.red, 2);\n            builder.addRangeBox(Range3d.createRange2d(this._placement.bbox));\n            context.outputGraphic(builder.finish());\n        }\n        if (!context.viewport.wantViewAttachments)\n            return;\n        if (this._graphics) {\n            context.outputGraphic(this._graphics);\n            return;\n        }\n        if (undefined === this._viewport)\n            return;\n        this._viewport.debugBoundingBoxes = context.viewport.debugBoundingBoxes;\n        this._viewport.setTileSizeModifier(context.viewport.tileSizeModifier);\n        this._viewport.renderFrame();\n        if (this._graphics)\n            context.outputGraphic(this._graphics);\n    }\n    discloseTileTrees(trees) {\n        if (this._viewport)\n            trees.disclose(this._viewport);\n    }\n    produceGraphics(context) {\n        assert(context.viewport === this._viewport);\n        this._graphics = this.createGraphics(this._viewport);\n        this._viewport = dispose(this._viewport);\n        if (undefined !== this._graphics)\n            context.outputGraphic(this._graphics);\n    }\n    createGraphics(vp) {\n        // Create a texture from the contents of the view.\n        const image = vp.readImageBuffer({ upsideDown: true });\n        if (undefined === image)\n            return undefined;\n        const debugImage = false; // set to true to open a window displaying the captured image.\n        if (debugImage) {\n            const url = imageBufferToPngDataUrl(image, false);\n            if (url)\n                openImageDataUrlInNewWindow(url, \"Attachment\");\n        }\n        const texture = IModelApp.renderSystem.createTexture({\n            image: { source: image, transparency: TextureTransparency.Opaque },\n        });\n        if (!texture)\n            return undefined;\n        // Create a material for the texture\n        const graphicParams = new GraphicParams();\n        graphicParams.material = IModelApp.renderSystem.createRenderMaterial({ textureMapping: { texture } });\n        // Apply the texture to a rectangular polyface.\n        const depth = this.zDepth;\n        const east = this._placement.bbox.low.x;\n        const west = this._placement.bbox.high.x;\n        const north = this._placement.bbox.low.y;\n        const south = this._placement.bbox.high.y;\n        const corners = [\n            Point3d.create(east, north, depth),\n            Point3d.create(west, north, depth),\n            Point3d.create(west, south, depth),\n            Point3d.create(east, south, depth),\n        ];\n        const params = [\n            Point2d.create(0, 0),\n            Point2d.create(1, 0),\n            Point2d.create(1, 1),\n            Point2d.create(0, 1),\n        ];\n        const strokeOptions = new StrokeOptions();\n        strokeOptions.needParams = strokeOptions.shouldTriangulate = true;\n        const polyfaceBuilder = PolyfaceBuilder.create(strokeOptions);\n        polyfaceBuilder.addQuadFacet(corners, params);\n        const polyface = polyfaceBuilder.claimPolyface();\n        const graphicBuilder = IModelApp.renderSystem.createGraphicBuilder(Transform.createIdentity(), GraphicType.Scene, vp, this._props.id);\n        graphicBuilder.activateGraphicParams(graphicParams);\n        graphicBuilder.addPolyface(polyface, false);\n        const graphic = graphicBuilder.finish();\n        // Wrap the polyface in a GraphicBranch.\n        const branch = new GraphicBranch(true);\n        const vfOvrs = createDefaultViewFlagOverrides({ clipVolume: true, shadows: false, lighting: false, thematic: false });\n        // Disable transparency - background pixels are 100% transparent so they will be discarded anyway. Other pixels are 100% opaque.\n        vfOvrs.transparency = false;\n        branch.setViewFlagOverrides(vfOvrs);\n        branch.symbologyOverrides = new FeatureSymbology.Overrides();\n        branch.entries.push(graphic);\n        // Apply the attachment's clip, if any.\n        let clipVolume;\n        if (this._props.jsonProperties?.clip) {\n            const clipVector = ClipVector.fromJSON(this._props.jsonProperties?.clip);\n            if (clipVector.isValid)\n                clipVolume = IModelApp.renderSystem.createClipVolume(clipVector);\n        }\n        return IModelApp.renderSystem.createGraphicBranch(branch, this._transform, { clipVolume });\n    }\n    collectStatistics(stats) {\n        if (this._graphics)\n            this._graphics.collectStatistics(stats);\n    }\n}\n//# sourceMappingURL=SheetViewState.js.map",
      "start": 1693508119139,
      "end": 1693508119349,
      "sourcemaps": null
    }
  ]
}
