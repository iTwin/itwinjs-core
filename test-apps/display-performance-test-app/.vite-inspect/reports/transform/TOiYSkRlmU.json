{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/clipping/ClipUtils.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module CartesianGeometry\n */\nimport { BagOfCurves } from \"../curve/CurveCollection\";\nimport { CurveFactory } from \"../curve/CurveFactory\";\nimport { CurvePrimitive } from \"../curve/CurvePrimitive\";\nimport { LineString3d } from \"../curve/LineString3d\";\nimport { Loop } from \"../curve/Loop\";\nimport { Path } from \"../curve/Path\";\nimport { RegionBinaryOpType, RegionOps } from \"../curve/RegionOps\";\nimport { UnionRegion } from \"../curve/UnionRegion\";\nimport { Geometry } from \"../Geometry\";\nimport { FrameBuilder } from \"../geometry3d/FrameBuilder\";\nimport { GrowableXYZArray } from \"../geometry3d/GrowableXYZArray\";\nimport { Point3dArrayCarrier } from \"../geometry3d/Point3dArrayCarrier\";\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\nimport { Range1d, Range3d } from \"../geometry3d/Range\";\nimport { GrowableXYZArrayCache } from \"../geometry3d/ReusableObjectCache\";\nimport { PolyfaceBuilder } from \"../polyface/PolyfaceBuilder\";\nimport { ClipPlane } from \"./ClipPlane\";\nimport { ClipPrimitive } from \"./ClipPrimitive\";\nimport { ClipVector } from \"./ClipVector\";\nimport { ConvexClipPlaneSet } from \"./ConvexClipPlaneSet\";\nimport { LineStringOffsetClipperContext } from \"./internalContexts/LineStringOffsetClipperContext\";\nimport { UnionOfConvexClipPlaneSets } from \"./UnionOfConvexClipPlaneSets\";\n/**\n * Enumerated type for describing where geometry lies with respect to clipping planes.\n * @public\n */\nexport var ClipPlaneContainment;\n(function (ClipPlaneContainment) {\n    /** All points inside. */\n    ClipPlaneContainment[ClipPlaneContainment[\"StronglyInside\"] = 1] = \"StronglyInside\";\n    /** Inside/outside state unknown. */\n    ClipPlaneContainment[ClipPlaneContainment[\"Ambiguous\"] = 2] = \"Ambiguous\";\n    /** All points outside. */\n    ClipPlaneContainment[ClipPlaneContainment[\"StronglyOutside\"] = 3] = \"StronglyOutside\";\n})(ClipPlaneContainment || (ClipPlaneContainment = {}));\n/**\n * Enumeration of ways to handle an intermediate fragment from a clipping step.\n * @public\n */\nexport var ClipStepAction;\n(function (ClipStepAction) {\n    /** Pass fragments directly to final accepted \"in\" state. */\n    ClipStepAction[ClipStepAction[\"acceptIn\"] = 1] = \"acceptIn\";\n    /** Pass fragments directly to final accepted \"out\" state. */\n    ClipStepAction[ClipStepAction[\"acceptOut\"] = -1] = \"acceptOut\";\n    /** Forward fragments to subsequent steps. */\n    ClipStepAction[ClipStepAction[\"passToNextStep\"] = 0] = \"passToNextStep\";\n})(ClipStepAction || (ClipStepAction = {}));\n/**\n * Enumerated type for describing what must yet be done to clip a piece of geometry.\n * @public\n */\nexport var ClipStatus;\n(function (ClipStatus) {\n    /** Some geometry may cross the clip boundaries */\n    ClipStatus[ClipStatus[\"ClipRequired\"] = 0] = \"ClipRequired\";\n    /** Geometry is clearly outside */\n    ClipStatus[ClipStatus[\"TrivialReject\"] = 1] = \"TrivialReject\";\n    /** Geometry is clearly inside */\n    ClipStatus[ClipStatus[\"TrivialAccept\"] = 2] = \"TrivialAccept\";\n})(ClipStatus || (ClipStatus = {}));\n/**\n * Class whose various static methods are functions for clipping geometry\n * @public\n */\nclass ClipUtilities {\n    /**\n     * Augment the unsortedFractionsArray with 0 and 1\n     * * sort\n     * * test the midpoint of each interval with `clipper.isPointOnOrInside`\n     * * pass accepted intervals to `announce(f0,f1,curve)`\n     */\n    static selectIntervals01(curve, unsortedFractions, clipper, announce) {\n        unsortedFractions.push(0);\n        unsortedFractions.push(1);\n        unsortedFractions.sort();\n        let f0 = unsortedFractions.atUncheckedIndex(0);\n        let f1;\n        let fMid;\n        const testPoint = ClipUtilities._selectIntervals01TestPoint;\n        const n = unsortedFractions.length;\n        for (let i = 1; i < n; i++) {\n            f1 = unsortedFractions.atUncheckedIndex(i);\n            if (f1 > f0 + Geometry.smallFraction) {\n                fMid = 0.5 * (f0 + f1);\n                if (fMid >= 0.0 && fMid <= 1.0) {\n                    curve.fractionToPoint(fMid, testPoint);\n                    if (clipper.isPointOnOrInside(testPoint)) {\n                        if (announce)\n                            announce(f0, f1, curve);\n                        else\n                            return true;\n                    }\n                }\n                f0 = f1;\n            }\n        }\n        return false;\n    }\n    /**\n     * Announce triples of (low, high, cp) for each entry in intervals.\n     * @param intervals source array\n     * @param cp CurvePrimitive for announcement\n     * @param announce function to receive data\n     */\n    static announceNNC(intervals, cp, announce) {\n        if (announce) {\n            for (const ab of intervals) {\n                announce(ab.low, ab.high, cp);\n            }\n        }\n        return intervals.length > 0;\n    }\n    /**\n     * Find portions of the curve primitive that are within the clipper.\n     * Collect them into an array of curve primitives.\n     */\n    static collectClippedCurves(curve, clipper) {\n        const result = [];\n        curve.announceClipIntervals(clipper, (fraction0, fraction1, curveA) => {\n            if (fraction1 !== fraction0) {\n                const partialCurve = curveA.clonePartialCurve(fraction0, fraction1);\n                if (partialCurve)\n                    result.push(partialCurve);\n            }\n        });\n        return result;\n    }\n    /**\n     * Find portions of the planar region that are within the clipper.\n     * Collect them into a single region to return.\n     */\n    static clipAnyRegion(region, clipper) {\n        let result;\n        // Create \"local region\" which is the result of rotating region to make\n        // it parallel to the xy-plane and then translating it to the xy-plane.\n        const localToWorld = ClipUtilities._workTransform = FrameBuilder.createRightHandedFrame(undefined, region, ClipUtilities._workTransform);\n        if (!localToWorld)\n            return result;\n        const worldToLocal = localToWorld?.inverse();\n        if (!worldToLocal)\n            return result;\n        const localRegion = region.cloneTransformed(worldToLocal);\n        if (!localRegion)\n            return result;\n        // We can only clip convex polygons with our clipper machinery, but the input region doesn't have to be\n        // convex or even a polygon. We get around this limitation by using a Boolean operation, which admits\n        // *any* planar regions, albeit in local coordinates. First, we clip a rectangle that covers the input region\n        // (in world coordinates), then we intersect the resulting fragments with the input region in local coordinates.\n        // Finally, we assemble the results into a UnionRegion back in world coordinates.\n        const localRegionRange = ClipUtilities._workRange = localRegion.range();\n        const xLength = localRegionRange.xLength();\n        const yLength = localRegionRange.yLength();\n        const rectangle = LineString3d.createRectangleXY(localRegionRange.low, xLength, yLength, true);\n        rectangle.tryTransformInPlace(localToWorld);\n        // Clip the rectangle to produce fragment(s) which we can Boolean intersect with the input region.\n        const insideFragments = [];\n        const outsideFragments = [];\n        const cache = new GrowableXYZArrayCache();\n        clipper.appendPolygonClip?.(rectangle.packedPoints, insideFragments, outsideFragments, cache);\n        if (insideFragments.length === 0)\n            return result;\n        // Create the \"clipped region\".\n        for (const fragment of insideFragments) {\n            const loop = Loop.createPolygon(fragment);\n            loop.tryTransformInPlace(worldToLocal);\n            const clippedLocalRegion = RegionOps.regionBooleanXY(localRegion, loop, RegionBinaryOpType.Intersection);\n            if (clippedLocalRegion) {\n                clippedLocalRegion.tryTransformInPlace(localToWorld);\n                if (!result)\n                    result = (clippedLocalRegion instanceof UnionRegion) ? clippedLocalRegion : UnionRegion.create(clippedLocalRegion);\n                else if (!result.tryAddChild(clippedLocalRegion))\n                    result.children.push(...clippedLocalRegion.children);\n            }\n        }\n        return result;\n    }\n    /**\n     * Find portions of any curve that are within the clipper.\n     * Collect them into an array of any curves.\n     */\n    static clipAnyCurve(curve, clipper) {\n        if (curve instanceof CurvePrimitive)\n            return ClipUtilities.collectClippedCurves(curve, clipper);\n        if (curve.isAnyRegionType) {\n            const ret = ClipUtilities.clipAnyRegion(curve, clipper);\n            return ret ? [ret] : [];\n        }\n        const result = [];\n        if (curve instanceof Path || curve instanceof BagOfCurves) {\n            for (const child of curve.children) {\n                const partialClip = ClipUtilities.clipAnyCurve(child, clipper);\n                result.push(...partialClip);\n            }\n        }\n        return result;\n    }\n    /**\n     * Clip a polygon down to regions defined by each shape of a ClipShape.\n     * @return An multidimensional array of points, where each array is the boundary of part of the remaining polygon.\n     */\n    static clipPolygonToClipShape(polygon, clipShape) {\n        const outputA = this.clipPolygonToClipShapeReturnGrowableXYZArrays(polygon, clipShape);\n        const output = [];\n        for (const g of outputA)\n            output.push(g.getPoint3dArray());\n        return output;\n    }\n    /**\n     * Clip a polygon down to regions defined by each shape of a ClipShape.\n     * @return An multidimensional array of points, where each array is the boundary of part of the remaining polygon.\n     */\n    static clipPolygonToClipShapeReturnGrowableXYZArrays(polygon, clipShape) {\n        const output = [];\n        const clipper = clipShape.fetchClipPlanesRef();\n        // NEEDS WORK -- what if it is a mask !!!!\n        if (clipper) {\n            clipper.polygonClip(polygon, output);\n        }\n        return output;\n    }\n    /**\n     * Given an array of points, test for trivial containment conditions.\n     * * ClipStatus.TrivialAccept if all points are in any one of the convexSet's.\n     * * ClipStatus.ClipRequired if (in any single convexSet) there were points on both sides of any single plane.\n     * * ClipStatus.TrivialReject if neither of those occurred.\n     */\n    static pointSetSingleClipStatus(points, planeSet, tolerance) {\n        if (planeSet.convexSets.length === 0)\n            return ClipStatus.TrivialAccept;\n        for (const convexSet of planeSet.convexSets) {\n            let allOutsideSinglePlane = false, anyOutside = false;\n            for (const plane of convexSet.planes) {\n                let numInside = 0, numOutside = 0;\n                const planeDistance = plane.distance - tolerance;\n                const currPt = Point3d.create();\n                const currVec = Vector3d.create();\n                for (let i = 0; i < points.length; i++) {\n                    points.getPoint3dAtUncheckedPointIndex(i, currPt);\n                    currVec.setFrom(currPt);\n                    currVec.dotProduct(plane.inwardNormalRef) > planeDistance ? numInside++ : numOutside++;\n                }\n                anyOutside = (numOutside !== 0) ? true : anyOutside;\n                if (numInside === 0) {\n                    allOutsideSinglePlane = true;\n                    break;\n                }\n            }\n            if (!anyOutside) // totally inside this set - no clip required\n                return ClipStatus.TrivialAccept;\n            if (!allOutsideSinglePlane)\n                return ClipStatus.ClipRequired;\n        }\n        return ClipStatus.TrivialReject;\n    }\n    /**\n     * Emit point loops for intersection of a convex set with a range.\n     * * return zero length array for (a) null range or (b) no intersections\n     * @param range range to intersect\n     * @param includeConvexSetFaces if false, do not compute facets originating as convex set planes.\n     * @param includeRangeFaces if false, do not compute facets originating as range faces\n     * @param ignoreInvisiblePlanes if true, do NOT compute a facet for convex set faces marked invisible.\n     */\n    static announceLoopsOfConvexClipPlaneSetIntersectRange(convexSet, range, loopFunction, includeConvexSetFaces = true, includeRangeFaces = true, ignoreInvisiblePlanes = false) {\n        const work = new GrowableXYZArray();\n        if (includeConvexSetFaces) {\n            // Clip convexSet planes to the range and to the rest of the convexSet . .\n            if (convexSet instanceof ConvexClipPlaneSet) {\n                for (const plane of convexSet.planes) {\n                    if (ignoreInvisiblePlanes && plane.invisible)\n                        continue;\n                    const pointsClippedToRange = plane.intersectRange(range, true);\n                    const finalPoints = new GrowableXYZArray();\n                    if (pointsClippedToRange) {\n                        convexSet.polygonClip(pointsClippedToRange, finalPoints, work, plane);\n                        if (finalPoints.length > 0)\n                            loopFunction(finalPoints);\n                    }\n                }\n            }\n            else { // `convexSet` is just one plane ...\n                if (ignoreInvisiblePlanes && convexSet.invisible) {\n                    // skip it !\n                }\n                else {\n                    const pointsClippedToRange = convexSet.intersectRange(range, true);\n                    if (pointsClippedToRange)\n                        loopFunction(pointsClippedToRange);\n                }\n            }\n        }\n        if (includeRangeFaces) {\n            // clip range faces to the convex set . . .\n            const corners = range.corners();\n            for (let i = 0; i < 6; i++) {\n                const indices = Range3d.faceCornerIndices(i);\n                const finalPoints = new GrowableXYZArray();\n                const lineString = LineString3d.createIndexedPoints(corners, indices);\n                if (convexSet instanceof ConvexClipPlaneSet) {\n                    convexSet.polygonClip(lineString.packedPoints, finalPoints, work);\n                    if (finalPoints.length > 0)\n                        loopFunction(finalPoints);\n                }\n                else {\n                    convexSet.clipConvexPolygonInPlace(lineString.packedPoints, work);\n                    if (lineString.packedPoints.length > 0)\n                        loopFunction(lineString.packedPoints);\n                }\n            }\n        }\n    }\n    /**\n     * Return a (possibly empty) array of geometry (Loops !!) which are facets of the intersection of the convex set\n     * intersecting a range.\n     * * Return zero length array for (a) null range or (b) no intersections\n     * @param allClippers convex or union clipper\n     * @param range range to intersect\n     * @param includeConvexSetFaces if false, do not compute facets originating as convex set planes.\n     * @param includeRangeFaces if false, do not compute facets originating as range faces\n     * @param ignoreInvisiblePlanes if true, do NOT compute a facet for convex set faces marked invisible.\n     */\n    static loopsOfConvexClipPlaneIntersectionWithRange(allClippers, range, includeConvexSetFaces = true, includeRangeFaces = true, ignoreInvisiblePlanes = false) {\n        const result = [];\n        if (allClippers instanceof UnionOfConvexClipPlaneSets) {\n            for (const clipper of allClippers.convexSets) {\n                this.announceLoopsOfConvexClipPlaneSetIntersectRange(clipper, range, (points) => {\n                    if (points.length > 0)\n                        result.push(Loop.createPolygon(points));\n                }, includeConvexSetFaces, includeRangeFaces, ignoreInvisiblePlanes);\n            }\n        }\n        else if (allClippers instanceof ConvexClipPlaneSet || allClippers instanceof ClipPlane) {\n            this.announceLoopsOfConvexClipPlaneSetIntersectRange(allClippers, range, (points) => {\n                if (points.length > 0)\n                    result.push(Loop.createPolygon(points));\n            }, includeConvexSetFaces, includeRangeFaces, ignoreInvisiblePlanes);\n        }\n        return result;\n    }\n    /**\n     * Return the (possibly null) range of the intersection of the convex set with a range.\n     * * The convex set is permitted to be unbounded (e.g. a single plane).  The range parameter provides bounds.\n     * @param convexSet convex set for intersection.\n     * @param range range to intersect\n     */\n    static rangeOfConvexClipPlaneSetIntersectionWithRange(convexSet, range) {\n        const result = Range3d.createNull();\n        this.announceLoopsOfConvexClipPlaneSetIntersectRange(convexSet, range, (points) => {\n            if (points.length > 0)\n                result.extendArray(points);\n        }, true, true, false);\n        return result;\n    }\n    /**\n     * Return the range of various types of clippers\n     * * `ConvexClipPlaneSet` -- dispatch to `rangeOfConvexClipPlaneSetIntersectionWithRange`\n     * * `UnionOfConvexClipPlaneSet` -- union of ranges of member `ConvexClipPlaneSet`\n     * * `ClipPrimitive` -- access its `UnionOfConvexClipPlaneSet`.\n     * * `ClipVector` -- intersection of the ranges of its `ClipPrimitive`.\n     * * `undefined` -- entire input range.\n     * * If `observeInvisibleFlag` is false, the \"invisible\" properties are ignored, and this effectively returns the range of the edge work of the members\n     * * If `observeInvisibleFlag` is true, the \"invisible\" properties are observed, and \"invisible\" parts do not restrict the range.\n     * @param clipper\n     * @param range non-null range.\n     * @param observeInvisibleFlag indicates how \"invisible\" bit is applied for ClipPrimitive.\n     */\n    static rangeOfClipperIntersectionWithRange(clipper, range, observeInvisibleFlag = true) {\n        if (clipper === undefined)\n            return range.clone();\n        if (clipper instanceof ConvexClipPlaneSet)\n            return this.rangeOfConvexClipPlaneSetIntersectionWithRange(clipper, range);\n        if (clipper instanceof UnionOfConvexClipPlaneSets) {\n            const rangeUnion = Range3d.createNull();\n            for (const c of clipper.convexSets) {\n                const rangeC = this.rangeOfConvexClipPlaneSetIntersectionWithRange(c, range);\n                rangeUnion.extendRange(rangeC);\n            }\n            return rangeUnion;\n        }\n        if (clipper instanceof ClipPrimitive) {\n            if (observeInvisibleFlag && clipper.invisible)\n                return range.clone();\n            return this.rangeOfClipperIntersectionWithRange(clipper.fetchClipPlanesRef(), range);\n        }\n        if (clipper instanceof ClipVector) {\n            const rangeIntersection = range.clone();\n            for (const c of clipper.clips) {\n                if (observeInvisibleFlag && c.invisible) {\n                    // trivial range tests do not expose the effects.   Assume the hole allows everything.\n                }\n                else {\n                    const rangeC = this.rangeOfClipperIntersectionWithRange(c, range, observeInvisibleFlag);\n                    rangeIntersection.intersect(rangeC, rangeIntersection);\n                }\n            }\n            return rangeIntersection;\n        }\n        return range.clone();\n    }\n    /**\n     * Test if various types of clippers have any intersection with a range.\n     * * This follows the same logic as `rangeOfClipperIntersectionWithRange` but attempts to exit at earliest point of confirmed intersection\n     * * `ConvexClipPlaneSet` -- dispatch to `doesConvexClipPlaneSetIntersectRange`\n     * * `UnionOfConvexClipPlaneSet` -- union of ranges of member `ConvexClipPlaneSet`\n     * * `ClipPrimitive` -- access its `UnionOfConvexClipPlaneSet`.\n     * * `ClipVector` -- intersection of the ranges of its `ClipPrimitive`.\n     * * `undefined` -- entire input range.\n     * * If `observeInvisibleFlag` is false, the \"invisible\" properties are ignored, and holes do not affect the result.\n     * * If `observeInvisibleFlag` is true, the \"invisible\" properties are observed, and may affect the result.\n     * @param clipper\n     * @param range non-null range.\n     * @param observeInvisibleFlag indicates how \"invisible\" bit is applied for ClipPrimitive.\n     */\n    static doesClipperIntersectRange(clipper, range, observeInvisibleFlag = true) {\n        if (clipper === undefined)\n            return true;\n        if (clipper instanceof ConvexClipPlaneSet)\n            return this.doesConvexClipPlaneSetIntersectRange(clipper, range);\n        if (clipper instanceof UnionOfConvexClipPlaneSets) {\n            for (const c of clipper.convexSets) {\n                if (this.doesConvexClipPlaneSetIntersectRange(c, range))\n                    return true;\n            }\n            return false;\n        }\n        if (clipper instanceof ClipPrimitive) {\n            if (observeInvisibleFlag && clipper.invisible) // um is there an easy way to detect range-completely-inside?\n                return true;\n            return this.doesClipperIntersectRange(clipper.fetchClipPlanesRef(), range);\n        }\n        if (clipper instanceof ClipVector) {\n            const rangeIntersection = range.clone();\n            for (const c of clipper.clips) {\n                if (observeInvisibleFlag && c.invisible) {\n                    // trivial range tests do not expose the effects.   Assume the hole allows everything.\n                }\n                else {\n                    const rangeC = this.rangeOfClipperIntersectionWithRange(c, range, observeInvisibleFlag);\n                    rangeIntersection.intersect(rangeC, rangeIntersection);\n                }\n            }\n            return !rangeIntersection.isNull;\n        }\n        /** If the case statement above is complete for the variant inputs, this is unreachable .. */\n        return false;\n    }\n    /**\n     * Emit point loops for intersection of a convex set with a range.\n     * * return zero length array for (a) null range or (b) no intersections\n     * @param range range to intersect\n     * @param includeConvexSetFaces if false, do not compute facets originating as convex set planes.\n     * @param includeRangeFaces if false, do not compute facets originating as range faces\n     * @param ignoreInvisiblePlanes if true, do NOT compute a facet for convex set faces marked invisible.\n     */\n    static doesConvexClipPlaneSetIntersectRange(convexSet, range, includeConvexSetFaces = true, includeRangeFaces = true, ignoreInvisiblePlanes = false) {\n        const work = new GrowableXYZArray();\n        if (includeConvexSetFaces) {\n            // Clip convexSet planes to the range and to the rest of the convexSet . .\n            for (const plane of convexSet.planes) {\n                if (ignoreInvisiblePlanes && plane.invisible)\n                    continue;\n                const pointsClippedToRange = plane.intersectRange(range, true);\n                if (pointsClippedToRange) {\n                    const finalPoints = new GrowableXYZArray();\n                    convexSet.polygonClip(pointsClippedToRange, finalPoints, work, plane);\n                    if (finalPoints.length > 0)\n                        return true;\n                }\n            }\n        }\n        if (includeRangeFaces) {\n            // clip range faces to the convex set . . .\n            const corners = range.corners();\n            for (let i = 0; i < 6; i++) {\n                const indices = Range3d.faceCornerIndices(i);\n                const finalPoints = new GrowableXYZArray();\n                const lineString = LineString3d.createIndexedPoints(corners, indices);\n                convexSet.polygonClip(lineString.packedPoints, finalPoints, work);\n                if (finalPoints.length > 0)\n                    return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Test for intersection of two ranges in different local coordinates.\n     * * Useful for clash detection of elements in iModels, using their stored (tight) local ranges and placement transforms.\n     * @param range0 range in local coordinates of first geometry\n     * @param local0ToWorld placement transform for first geometry\n     * @param range1 range in local coordinates of second geometry\n     * @param local1ToWorld placement transform for second geometry. Assumed to be invertible.\n     * @param range1Margin optional signed local distance to expand/contract the second range before intersection. Positive expands.\n     * @return whether the local ranges are adjacent or intersect. Also returns false if local1ToWorld is singular.\n     */\n    static doLocalRangesIntersect(range0, local0ToWorld, range1, local1ToWorld, range1Margin) {\n        const worldToLocal1 = ClipUtilities._workTransform = local1ToWorld.inverse(ClipUtilities._workTransform);\n        if (!worldToLocal1)\n            return false;\n        let myRange1 = range1;\n        if (range1Margin) {\n            myRange1 = ClipUtilities._workRange = range1.clone(ClipUtilities._workRange);\n            myRange1.expandInPlace(range1Margin);\n        }\n        // convert range0 into a clipper in local1 coordinates, then intersect with range1\n        const local0ToLocal1 = worldToLocal1.multiplyTransformTransform(local0ToWorld, worldToLocal1);\n        const builder = PolyfaceBuilder.create();\n        builder.addTransformedRangeMesh(local0ToLocal1, range0);\n        const mesh0 = builder.claimPolyface();\n        const clipper = ClipUtilities._workClipper = ConvexClipPlaneSet.createConvexPolyface(mesh0, ClipUtilities._workClipper).clipper;\n        return ClipUtilities.doesClipperIntersectRange(clipper, myRange1);\n    }\n    /**\n     * Test if `obj` is a `Clipper` object.\n     * * This is implemented by testing for each of the methods in the `Clipper` interface.\n     */\n    static isClipper(obj) {\n        if (obj) {\n            if (obj.isPointOnOrInside\n                && obj.announceClippedSegmentIntervals\n                && obj.announceClippedArcIntervals)\n                return true;\n        }\n        return false;\n    }\n    /**\n     * Specialized logic for replacing clip fragments by an equivalent singleton.\n     * * If there are baseCount + 1 or fewer fragments, do nothing.\n     * * If there are more than baseCount+1 fragments:\n     *   * drop them all to the cache\n     *   * push a copy of the singleton.\n     * * The use case for this is that a multi-step clipper (e.g. UnionOfConvexClipPlaneSets) may produce many fragments,\n     * and then be able to determine that they really are the original pre-clip polygon unchanged.\n     * * The baseCount+1 case is the case where the entire original singleton is still a singleton and can be left alone.\n     * * Calling this replacer shuffles the original back into the fragment array, and drops the fragments.\n     * * This determination is solely within the logic of the caller.\n     * @param shards array of fragments\n     * @param baseCount original count\n     * @param singleton single array which may be a replacement for multiple fragments\n     * @param cache cache for array management\n     */\n    static restoreSingletonInPlaceOfMultipleShards(fragments, baseCount, singleton, arrayCache) {\n        if (fragments && fragments.length > baseCount + 1) {\n            while (fragments.length > baseCount) {\n                const f = fragments.pop();\n                arrayCache.dropToCache(f);\n            }\n            fragments.push(arrayCache.grabAndFill(singleton));\n        }\n    }\n    /**\n     * Create a UnionOfConvexClipPlaneSets for a volume defined by a path and offsets.\n     * @param points points along the path.\n     * @param positiveOffsetLeft offset to left.  0 is clip on the path.\n     * @param positiveOffsetRight offset to the right.  0 is clip on the path.\n     * @param z0 z for lower clipping plane.  If undefined, unbounded in positive z\n     * @param z1 z for upper clipping plane.  If undefined, unbounded in negative z.\n     * @alpha\n     */\n    static createXYOffsetClipFromLineString(points, leftOffset, rightOffset, z0, z1) {\n        if (Array.isArray(points)) {\n            return LineStringOffsetClipperContext.createClipBetweenOffsets(new Point3dArrayCarrier(points), leftOffset, rightOffset, z0, z1);\n        }\n        return LineStringOffsetClipperContext.createClipBetweenOffsets(points, leftOffset, rightOffset, z0, z1);\n    }\n    /** If data.length >= minLength threshold, push it to destination; if smaller drop it back to the cache. */\n    static captureOrDrop(data, minLength, destination, cache) {\n        if (data.length >= minLength)\n            destination.push(data);\n        else\n            cache.dropToCache(data);\n    }\n    /**\n     * Find the portion of a line within a half-plane clip.\n     * * The half-plane clip is to the left of the line from clipA to clipB.\n     * * The original clipped segment has fractions 0 and 1 at respective segment points.\n     * * Caller initializes the interval\n     * * This method reduces the interval size.\n     * * See clipSegmentToCCWTriangleXY for typical use.\n     * @param linePointA First point of clip line\n     * @param linePointB Second point of clip line\n     * @param segmentPoint0 First point of clipped segment\n     * @param segmentPoint1 Second point of clipped segment\n     * @param interval Live interval.\n       * @param absoluteTolerance absolute tolerance for both cross product values to indicate \"on\" the line\n     */\n    static clipSegmentToLLeftOfLineXY(linePointA, linePointB, segmentPoint0, segmentPoint1, interval, absoluteTolerance = 1.0e-14) {\n        const ux = linePointB.x - linePointA.x;\n        const uy = linePointB.y - linePointA.y;\n        // negative is in positive is out ...\n        const h0 = -(ux * (segmentPoint0.y - linePointA.y) - uy * (segmentPoint0.x - linePointA.x));\n        const h1 = -(ux * (segmentPoint1.y - linePointA.y) - uy * (segmentPoint1.x - linePointA.x));\n        if (h0 < absoluteTolerance && h1 < absoluteTolerance) {\n            // The entire segment is in .....\n            return;\n        }\n        if (h0 * h1 > 0.0) {\n            if (h0 > 0.0)\n                interval.setNull();\n        }\n        else if (h0 * h1 < 0.0) {\n            // strict crossing with safe fraction . . .\n            const fraction = -h0 / (h1 - h0);\n            if (h0 < 0.0) {\n                return interval.intersectRangeXXInPlace(0.0, fraction);\n            }\n            else {\n                return interval.intersectRangeXXInPlace(fraction, 1.0);\n            }\n        }\n        else {\n            // There is an exact hit at one end, possibly non-zero at the other ... the sign of either determines which side is in play\n            // A zero and a zero or negative is entirely in, which does not alter the prior clip.\n            if (h0 > 0.0) {\n                interval.intersectRangeXXInPlace(1.0, 1.0);\n            }\n            else if (h1 > 0.0) {\n                interval.intersectRangeXXInPlace(0.0, 0.0);\n            }\n        }\n    }\n    /**\n     * Clip an interval of a line segment to a triangle.\n     * * Triangle is assumed CCW\n     * @param pointA point of triangle.\n     * @param pointB point of triangle.\n     * @param pointC point of triangle.\n     * @param segment0 start of segment\n     * @param segment1 end of segment\n     * @param interval Pre-initialized interval of live part of segment\n     * @param absoluteTolerance absolute tolerance for begin \"on a line\"\n     */\n    static clipSegmentToCCWTriangleXY(pointA, pointB, pointC, segment0, segment1, interval, absoluteTolerance = 1.0e-14) {\n        if (!interval.isNull) {\n            this.clipSegmentToLLeftOfLineXY(pointA, pointB, segment0, segment1, interval, absoluteTolerance);\n            if (!interval.isNull) {\n                this.clipSegmentToLLeftOfLineXY(pointB, pointC, segment0, segment1, interval, absoluteTolerance);\n                if (!interval.isNull) {\n                    this.clipSegmentToLLeftOfLineXY(pointC, pointA, segment0, segment1, interval, absoluteTolerance);\n                }\n            }\n        }\n    }\n    /**\n     * Find the portion of a line within a half-plane clip.\n     * * The half-plane clip is to the left of the line from clipA to clipB.\n     * * The original clipped segment has fractions 0 and 1 at respective segment points.\n     * * Caller initializes the interval\n     * * This method reduces the interval size.\n     * * See clipSegmentToCCWTriangleXY for typical use.\n     * @param linePointA First point of clip line\n     * @param linePointB Second point of clip line\n     * @param segmentPoint0 First point of clipped segment\n     * @param segmentPoint1 Second point of clipped segment\n     * @param interval Live interval.\n       * @param absoluteTolerance absolute tolerance for both cross product values to indicate \"on\" the line\n     */\n    static clipSegmentBelowPlaneXY(plane, segmentPoint0, segmentPoint1, interval, absoluteTolerance = 1.0e-14) {\n        // negative is in positive is out ...\n        const h0 = plane.altitudeXY(segmentPoint0.x, segmentPoint0.y);\n        const h1 = plane.altitudeXY(segmentPoint1.x, segmentPoint1.y);\n        if (h0 < absoluteTolerance && h1 < absoluteTolerance) {\n            // The entire segment is in ..... the interval is unaffected.\n            return;\n        }\n        if (h0 * h1 > 0.0) {\n            if (h0 > 0.0)\n                interval.setNull();\n        }\n        else if (h0 * h1 < 0.0) {\n            // strict crossing with safe fraction . . .\n            const fraction = -h0 / (h1 - h0);\n            if (h0 < 0.0) {\n                return interval.intersectRangeXXInPlace(0.0, fraction);\n            }\n            else {\n                return interval.intersectRangeXXInPlace(fraction, 1.0);\n            }\n        }\n        else {\n            // There is an exact hit at one end, possibly non-zero at the other ... the sign of either determines which side is in play\n            // A zero and a zero or negative is entirely in, which does not alter the prior clip.\n            if (h0 > 0.0) {\n                interval.intersectRangeXXInPlace(1.0, 1.0);\n            }\n            else if (h1 > 0.0) {\n                interval.intersectRangeXXInPlace(0.0, 0.0);\n            }\n        }\n    }\n    /**\n     * Clip an interval of a line segment to an array of planes\n     * * plane normals assumed OUTWARD\n     * * planeAltitude is typically a tolerance a tolerance distance.\n     *   * positive altitude makes tha plane move in the direction of the unit normal.\n     * @param planes array of planes\n     * @param segment0 start of segment\n     * @param segment1 end of segment\n     * @param interval Pre-initialized interval of live part of segment\n     * @param absoluteTolerance absolute tolerance for begin \"on a line\"\n     */\n    static clipSegmentBelowPlanesXY(planes, segment0, segment1, interval, signedAltitude = 1.0e-14) {\n        const numPlanes = planes.length;\n        for (let i = 0; (!interval.isNull) && i < numPlanes; i++) {\n            this.clipSegmentBelowPlaneXY(planes[i], segment0, segment1, interval, signedAltitude);\n        }\n    }\n    /**\n     * Pass line segments from a polyline to the clipper.  Resolve the fractional clips to simple points for announcement.\n     * @param clipper clipper to call\n     * @param points polyline whose segments are passed to the clipper\n     * @param announce caller's handler for simple point pairs.\n     */\n    static announcePolylineClip(clipper, points, announce) {\n        for (let i = 0; i + 1 < points.length; i++) {\n            clipper.announceClippedSegmentIntervals(0, 1, points[i], points[i + 1], (f0, f1) => {\n                announce(points[i].interpolate(f0, points[i + 1]), points[i].interpolate(f1, points[i + 1]));\n            });\n        }\n    }\n    /**\n     * Pass line segments from a polyline to the clipper.  Sum the lengths of the clipped pieces.  Return the sum.\n     * @param clipper clipper to call\n     * @param points polyline whose segments are passed to the clipper\n     */\n    static sumPolylineClipLength(clipper, points) {\n        let s = 0;\n        for (let i = 0; i + 1 < points.length; i++) {\n            const a = points[i].distance(points[i + 1]);\n            clipper.announceClippedSegmentIntervals(0, 1, points[i], points[i + 1], (f0, f1) => { s += Math.abs(f1 - f0) * a; });\n        }\n        return s;\n    }\n    /**\n     * Pass polygon `xyz` through a sequence of PolygonClip steps.\n     * * At the outset, `xyz` is the (only) entry in a set of candidates.\n     * * For each clipper, each candidate is presented for appendPolygon to inside and outside parts.\n     * * Each (in,out) result is distributed among (acceptedIn, acceptedOut, candidates) according to\n     *      (inAction, outAction)\n     * * At the end, all remaining candidates are distributed among (acceptedIn, acceptedOut, finalUnknown)\n     *     according to finalAction\n     * * Any clipper that does not have an appendPolygonClip method is skipped.\n     * @param xyz\n     * @param clippers\n     * @param acceptedIn\n     * @param acceptedOut\n     * @param finalCandidates\n     * @param inAction\n     * @param outAction\n     * @param finalCandidateAction\n     */\n    static doPolygonClipSequence(xyz, clippers, acceptedIn, acceptedOut, finalCandidates, inAction, outAction, finalFragmentAction, arrayCache) {\n        if (arrayCache === undefined)\n            arrayCache = new GrowableXYZArrayCache();\n        let candidates = [arrayCache.grabAndFill(xyz)];\n        let nextCandidates = [];\n        const intermediateIn = [];\n        const intermediateOut = [];\n        const oldInsideCount = acceptedIn ? acceptedIn.length : 0;\n        const oldOutsideCount = acceptedOut ? acceptedOut.length : 0;\n        let shard;\n        // At each convex set, carryForwardA is all the fragments that have been outside all previous convex sets.\n        // Clip each such fragment to the current set, sending the outside parts to carryForwardB, which will got to\n        // the next clipper. The final surviving carryForward really is out.\n        for (const c of clippers) {\n            if (c.appendPolygonClip) {\n                while (undefined !== (shard = candidates.pop())) {\n                    c.appendPolygonClip(shard, intermediateIn, intermediateOut, arrayCache);\n                    distributeFragments(inAction, intermediateIn, acceptedIn, acceptedOut, nextCandidates, arrayCache);\n                    distributeFragments(outAction, intermediateOut, acceptedIn, acceptedOut, nextCandidates, arrayCache);\n                    arrayCache.dropToCache(shard);\n                }\n                // candidates is empty !!\n                const temp = candidates;\n                candidates = nextCandidates;\n                nextCandidates = temp;\n            }\n        }\n        distributeFragments(finalFragmentAction, candidates, acceptedIn, acceptedOut, finalCandidates, arrayCache);\n        // Note: The following assumes that there were no residual candidates ... need to track if that happened?\n        // If nothing was out, the inside fragments can be replaced by the original.\n        if (acceptedOut?.length === oldOutsideCount)\n            ClipUtilities.restoreSingletonInPlaceOfMultipleShards(acceptedIn, oldInsideCount, xyz, arrayCache);\n        // If nothing was in, the outside fragments can be replaced by the original.\n        if (acceptedIn?.length === oldInsideCount)\n            ClipUtilities.restoreSingletonInPlaceOfMultipleShards(acceptedOut, oldOutsideCount, xyz, arrayCache);\n    }\n    /** Pass polygon `xyz` through a sequence of PolygonClip steps with \"parity\" rules */\n    static doPolygonClipParitySequence(xyz, clippers, acceptedIn, acceptedOut, arrayCache) {\n        if (arrayCache === undefined)\n            arrayCache = new GrowableXYZArrayCache();\n        let candidatesOut = [arrayCache.grabAndFill(xyz)];\n        let candidatesIn = [];\n        let nextCandidatesIn = [];\n        let nextCandidatesOut = [];\n        const intermediateIn = [];\n        const intermediateOut = [];\n        let shard;\n        // at each step ..\n        // candidatesIn and candidatesOut are evolved in and out\n        // nextCandidatesIn and nextCandidatesOut are EMPTY\n        for (const c of clippers) {\n            if (c.appendPolygonClip) {\n                // (IN,OUT) parts of IN parts distribute to (OUT,IN)\n                while (undefined !== (shard = candidatesIn.pop())) {\n                    c.appendPolygonClip(shard, intermediateIn, intermediateOut, arrayCache);\n                    distributeFragments(ClipStepAction.acceptOut, intermediateIn, nextCandidatesIn, nextCandidatesOut, undefined, arrayCache);\n                    distributeFragments(ClipStepAction.acceptIn, intermediateOut, nextCandidatesIn, nextCandidatesOut, undefined, arrayCache);\n                    arrayCache.dropToCache(shard);\n                }\n                // (IN,OUT) parts of IN parts distribute to (OUT,IN)\n                while (undefined !== (shard = candidatesOut.pop())) {\n                    c.appendPolygonClip(shard, intermediateIn, intermediateOut, arrayCache);\n                    distributeFragments(ClipStepAction.acceptIn, intermediateIn, nextCandidatesIn, nextCandidatesOut, undefined, arrayCache);\n                    distributeFragments(ClipStepAction.acceptOut, intermediateOut, nextCandidatesIn, nextCandidatesOut, undefined, arrayCache);\n                    arrayCache.dropToCache(shard);\n                }\n                // reload each candidate step\n                const tempA = candidatesIn;\n                candidatesIn = nextCandidatesIn;\n                nextCandidatesIn = tempA;\n                const tempB = candidatesOut;\n                candidatesOut = nextCandidatesOut;\n                nextCandidatesOut = tempB;\n            }\n        }\n        // candidatesIn and candidatesOut are final ....\n        if (candidatesOut.length === 0)\n            acceptedIn?.push(arrayCache.grabAndFill(xyz));\n        else if (candidatesOut.length === 0)\n            acceptedOut?.push(arrayCache.grabAndFill(xyz));\n        else {\n            moveFragments(candidatesIn, acceptedIn, arrayCache);\n            moveFragments(candidatesOut, acceptedOut, arrayCache);\n        }\n    }\n    /**\n     * For each plane of clipper, construct a UnionOfConvexClipPlaneSets for an outer (infinite) convex volume that\n     * abuts the outer volume of the neighbor faces.\n     */\n    static createComplementaryClips(clipper) {\n        const planes = clipper.planes;\n        const interval = Range1d.createNull();\n        const n = planes.length;\n        const newClippers = [];\n        for (const p of planes) {\n            const outerSet = ConvexClipPlaneSet.createEmpty();\n            outerSet.addPlaneToConvexSet(p.cloneNegated());\n            newClippers.push(outerSet);\n        }\n        for (let i = 0; i < n; i++) {\n            for (let j = i + 1; j < n; j++) {\n                const ray = CurveFactory.planePlaneIntersectionRay(planes[i], planes[j]);\n                if (ray) {\n                    if (clipper.hasIntersectionWithRay(ray, interval)) {\n                        // the normal-to-normal vector is bisector (or close to bisector?)\n                        const newNormal = planes[j].inwardNormalRef.minus(planes[i].inwardNormalRef);\n                        const plane1 = ClipPlane.createNormalAndPoint(newNormal, ray.origin);\n                        if (plane1) {\n                            const plane2 = plane1.cloneNegated();\n                            newClippers[i].addPlaneToConvexSet(plane1);\n                            newClippers[j].addPlaneToConvexSet(plane2);\n                        }\n                    }\n                }\n            }\n        }\n        return UnionOfConvexClipPlaneSets.createConvexSets(newClippers);\n    }\n}\nClipUtilities._selectIntervals01TestPoint = Point3d.create();\nexport { ClipUtilities };\nfunction moveFragments(fragments, destination, arrayCache) {\n    if (destination === undefined)\n        arrayCache.dropAllToCache(fragments);\n    else {\n        for (const f of fragments)\n            destination.push(f);\n    }\n    fragments.length = 0;\n}\n/**\n * Distribute fragments among acceptedIn, acceptedOut, and passToNextStep as directed by action.\n * * If the indicated destination is unknown, drop the fragments to the arrayCache.\n * @param action destination selector\n * @param fragments fragments to be distributed\n * @param acceptedIn destination for \"in\"\n * @param acceptedOut destination for \"out\"\n * @param passToNextStep destination for fragments to be passed to a later step\n * @param arrayCache destination for un-distributed fragments.\n */\nfunction distributeFragments(action, fragments, acceptedIn, acceptedOut, passToNextStep, arrayCache) {\n    let destination;\n    if (action === ClipStepAction.acceptIn)\n        destination = acceptedIn;\n    else if (action === ClipStepAction.acceptOut)\n        destination = acceptedOut;\n    else if (action === ClipStepAction.passToNextStep)\n        destination = passToNextStep;\n    // remark: if action is other than the enum values, destination is undefined\n    if (destination === undefined)\n        arrayCache.dropAllToCache(fragments);\n    else {\n        for (const f of fragments)\n            destination.push(f);\n    }\n    fragments.length = 0;\n}\n//# sourceMappingURL=ClipUtils.js.map",
      "start": 1693508122517,
      "end": 1693508122684,
      "sourcemaps": null
    }
  ]
}
