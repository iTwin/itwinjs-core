{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/geometry3d/Point3dArrayCarrier.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module ArraysAndInterfaces\n */\nimport { IndexedReadWriteXYZCollection } from \"./IndexedXYZCollection\";\nimport { Point3d, Vector3d } from \"./Point3dVector3d\";\n/**\n * Helper object to access members of a Point3d[] in geometric calculations.\n * * The collection holds only a reference to the actual array.\n * * The actual array may be replaced by the user as needed.\n * * When replaced, there is no cached data to be updated.\n * @public\n */\nexport class Point3dArrayCarrier extends IndexedReadWriteXYZCollection {\n    /** CAPTURE caller supplied array ... */\n    constructor(data) {\n        super();\n        this.data = data;\n    }\n    /** Test if `index` is a valid index into the array. */\n    isValidIndex(index) {\n        return index >= 0 && index < this.data.length;\n    }\n    /**\n     * Access by index, returning strongly typed Point3d\n     * * This returns the xyz value but NOT reference to the point in the \"carried\" array.\n     * @param index index of point within the array\n     * @param result caller-allocated destination\n     * @returns undefined if the index is out of bounds\n     */\n    getPoint3dAtCheckedPointIndex(index, result) {\n        if (this.isValidIndex(index)) {\n            const source = this.data[index];\n            return Point3d.create(source.x, source.y, source.z, result);\n        }\n        return undefined;\n    }\n    /**\n     * Access by index, returning strongly typed Point3d\n     * * This returns the xyz value but NOT reference to the point in the \"carried\" array.\n     * @param index index of point within the array\n     * @param result caller-allocated destination\n     */\n    getPoint3dAtUncheckedPointIndex(index, result) {\n        const source = this.data[index];\n        return Point3d.create(source.x, source.y, source.z, result);\n    }\n    /**\n     * Access by index, returning strongly typed Vector3d\n     * @param index index of point within the array\n     * @param result caller-allocated destination\n     * @returns undefined if the index is out of bounds\n     */\n    getVector3dAtCheckedVectorIndex(index, result) {\n        if (this.isValidIndex(index)) {\n            const source = this.data[index];\n            return Vector3d.create(source.x, source.y, source.z, result);\n        }\n        return undefined;\n    }\n    /**\n     * Access x of indexed point\n     * * WARNING: make sure `pointIndex` is a valid index, otherwise, you get random results\n     */\n    getXAtUncheckedPointIndex(pointIndex) {\n        return this.data[pointIndex].x;\n    }\n    /**\n     * Access y of indexed point\n     * * WARNING: make sure `pointIndex` is a valid index, otherwise, you get random results\n     */\n    getYAtUncheckedPointIndex(pointIndex) {\n        return this.data[pointIndex].y;\n    }\n    /**\n     * Access z of indexed point\n     * * WARNING: make sure `pointIndex` is a valid index, otherwise, you get random results\n     */\n    getZAtUncheckedPointIndex(pointIndex) {\n        return this.data[pointIndex].z;\n    }\n    /**\n     * Return a vector from the point at indexA to the point at indexB\n     * @param indexA index of point within the array\n     * @param indexB index of point within the array\n     * @param result caller-allocated vector.\n     * @returns undefined if either index is out of bounds\n     */\n    vectorIndexIndex(indexA, indexB, result) {\n        if (this.isValidIndex(indexA) && this.isValidIndex(indexB))\n            return Vector3d.createStartEnd(this.data[indexA], this.data[indexB], result);\n        return undefined;\n    }\n    /**\n     * Return a vector from given origin to point at indexB\n     * @param origin origin for vector\n     * @param indexB index of point within the array\n     * @param result caller-allocated vector.\n     * @returns undefined if index is out of bounds\n     */\n    vectorXYAndZIndex(origin, indexB, result) {\n        if (this.isValidIndex(indexB))\n            return Vector3d.createStartEnd(origin, this.data[indexB], result);\n        return undefined;\n    }\n    /**\n     * Return the cross product of vectors from origin to points at indexA and indexB\n     * @param origin origin for vector\n     * @param indexA index of first target within the array\n     * @param indexB index of second target within the array\n     * @param result caller-allocated vector.\n     * @returns undefined if either index is out of bounds\n     */\n    crossProductXYAndZIndexIndex(origin, indexA, indexB, result) {\n        if (this.isValidIndex(indexA) && this.isValidIndex(indexB))\n            return Vector3d.createCrossProductToPoints(origin, this.data[indexA], this.data[indexB], result);\n        return undefined;\n    }\n    /**\n     * Return the cross product of vectors from point at originIndex to points at indexA and indexB\n     * @param originIndex index of origin\n     * @param indexA index of first target within the array\n     * @param indexB index of second target within the array\n     * @param result caller-allocated vector.\n     * @returns return true if indexA, indexB both valid\n     */\n    crossProductIndexIndexIndex(originIndex, indexA, indexB, result) {\n        if (this.isValidIndex(originIndex) && this.isValidIndex(indexA) && this.isValidIndex(indexB))\n            return Vector3d.createCrossProductToPoints(this.data[originIndex], this.data[indexA], this.data[indexB], result);\n        return undefined;\n    }\n    /**\n     * Compute the cross product of vectors from point at originIndex to points at indexA and indexB, and accumulate it to the result.\n     * @param origin index of origin\n     * @param indexA index of first target within the array\n     * @param indexB index of second target within the array\n     * @param result caller-allocated vector.\n     * @returns return true if indexA, indexB both valid\n     */\n    accumulateCrossProductIndexIndexIndex(originIndex, indexA, indexB, result) {\n        const data = this.data;\n        if (this.isValidIndex(originIndex) && this.isValidIndex(indexA) && this.isValidIndex(indexB))\n            result.addCrossProductToTargetsInPlace(data[originIndex].x, data[originIndex].y, data[originIndex].z, data[indexA].x, data[indexA].y, data[indexA].z, data[indexB].x, data[indexB].y, data[indexB].z);\n    }\n    /** Accumulate scale times the x,y,z values at index to the sum. No action if index is out of bounds */\n    accumulateScaledXYZ(index, scale, sum) {\n        if (this.isValidIndex(index)) {\n            const point = this.data[index];\n            sum.x += scale * point.x;\n            sum.y += scale * point.y;\n            sum.z += scale * point.z;\n        }\n    }\n    /** Read-only property for number of XYZ in the collection */\n    get length() {\n        return this.data.length;\n    }\n    /**\n     * Push a (clone of) point onto the collection\n     * * point itself is not pushed -- xyz data is extracted into the native form of the collection.\n     */\n    push(data) {\n        this.data.push(data.clone());\n    }\n    /**\n     * Push a new point (given by coordinates) onto the collection\n     * @param x x coordinate\n     * @param y y coordinate\n     * @param z z coordinate\n     */\n    pushXYZ(x, y, z) {\n        this.data.push(Point3d.create(x === undefined ? 0.0 : x, y === undefined ? 0.0 : y, z === undefined ? 0.0 : z));\n    }\n    /** Extract (copy) the final point */\n    back(result) {\n        if (this.data.length > 0) {\n            return this.data[this.data.length - 1].clone(result);\n        }\n        return undefined;\n    }\n    /** Extract (copy) the first point */\n    front(result) {\n        if (this.data.length > 0) {\n            return this.data[0].clone(result);\n        }\n        return undefined;\n    }\n    /** Remove the final point. */\n    pop() {\n        if (this.data.length > 0)\n            this.data.pop();\n    }\n    /** Remove all points. */\n    clear() {\n        this.data.length = 0;\n    }\n    /** Reverse the points in place */\n    reverseInPlace() {\n        this.data.reverse();\n    }\n    /**\n     * Return distance squared between indicated points.\n     * @param index0 first point index\n     * @param index1 second point index\n     */\n    distanceSquaredIndexIndex(index0, index1) {\n        const n = this.data.length;\n        if (index0 >= 0 && index0 < n && index1 >= 0 && index1 < n) {\n            return this.data[index0].distanceSquared(this.data[index1]);\n        }\n        return undefined;\n    }\n    /**\n     * Return distance between indicated points.\n     * @param index0 first point index\n     * @param index1 second point index\n     */\n    distanceIndexIndex(index0, index1) {\n        const n = this.data.length;\n        if (index0 >= 0 && index0 < n && index1 >= 0 && index1 < n) {\n            return this.data[index0].distance(this.data[index1]);\n        }\n        return undefined;\n    }\n    /** Adjust index into range by modulo with the length. */\n    cyclicIndex(i) {\n        return (i % this.data.length);\n    }\n}\n//# sourceMappingURL=Point3dArrayCarrier.js.map",
      "start": 1693508122366,
      "end": 1693508122543,
      "sourcemaps": null
    }
  ]
}
