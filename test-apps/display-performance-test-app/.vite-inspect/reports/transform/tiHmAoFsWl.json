{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/Target.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { assert, dispose, Id64 } from \"@itwin/core-bentley\";\nimport { Point2d, Point3d, Range3d, Transform } from \"@itwin/core-geometry\";\nimport { AmbientOcclusion, Frustum, ImageBuffer, ImageBufferFormat, Npc, RenderMode, ThematicDisplayMode, ViewFlags, } from \"@itwin/core-common\";\nimport { AnimationNodeId } from \"../../common/render/AnimationNodeId\";\nimport { ViewRect } from \"../../common/ViewRect\";\nimport { canvasToImageBuffer, canvasToResizedCanvasWithBars, imageBufferToCanvas } from \"../../common/ImageUtil\";\nimport { Pixel } from \"../Pixel\";\nimport { createEmptyRenderPlan } from \"../RenderPlan\";\nimport { PrimitiveVisibility, RenderTarget } from \"../RenderTarget\";\nimport { BranchState } from \"./BranchState\";\nimport { SingleTexturedViewportQuadGeometry } from \"./CachedGeometry\";\nimport { ColorInfo } from \"./ColorInfo\";\nimport { DrawParams, ShaderProgramParams } from \"./DrawCommand\";\nimport { FrameBuffer } from \"./FrameBuffer\";\nimport { GL } from \"./GL\";\nimport { WorldDecorations } from \"./Graphic\";\nimport { IModelFrameLifecycle } from \"./IModelFrameLifecycle\";\nimport { PlanarClassifier } from \"./PlanarClassifier\";\nimport { Primitive } from \"./Primitive\";\nimport { RenderState } from \"./RenderState\";\nimport { SceneCompositor } from \"./SceneCompositor\";\nimport { freeDrawParams } from \"./ScratchDrawParams\";\nimport { ShaderProgramExecutor } from \"./ShaderProgram\";\nimport { desync } from \"./Sync\";\nimport { System } from \"./System\";\nimport { TargetUniforms } from \"./TargetUniforms\";\nimport { TextureHandle } from \"./Texture\";\nimport { TargetGraphics } from \"./TargetGraphics\";\nimport { VisibleTileFeatures } from \"./VisibleTileFeatures\";\nimport { FrameStatsCollector } from \"../FrameStats\";\nfunction swapImageByte(image, i0, i1) {\n    const tmp = image.data[i0];\n    image.data[i0] = image.data[i1];\n    image.data[i1] = tmp;\n}\nclass EmptyHiliteSet {\n    constructor() {\n        this.isEmpty = true;\n        this.modelSubCategoryMode = \"union\";\n        this.elements = this.subcategories = this.models = new Id64.Uint32Set();\n    }\n}\n/** @internal */\nexport class Target extends RenderTarget {\n    get shadowFrustum() {\n        const map = this.solarShadowMap;\n        return map.isEnabled && map.isReady ? map.frustum : undefined;\n    }\n    get debugControl() { return this; }\n    get viewRect() {\n        return this.renderRect;\n    }\n    constructor(rect) {\n        super();\n        this.graphics = new TargetGraphics();\n        this._hilites = new EmptyHiliteSet();\n        this._hiliteSyncTarget = { syncKey: Number.MIN_SAFE_INTEGER };\n        this._flashed = { lower: 0, upper: 0 };\n        this._flashedId = Id64.invalid;\n        this._flashIntensity = 0;\n        this._dcAssigned = false;\n        this.decorationsState = BranchState.createForDecorations(); // Used when rendering view background and view/world overlays.\n        this.uniforms = new TargetUniforms(this);\n        this.renderRect = new ViewRect();\n        this.ambientOcclusionSettings = AmbientOcclusion.Settings.defaults;\n        this._wantAmbientOcclusion = false;\n        this._batches = [];\n        this.plan = createEmptyRenderPlan();\n        this._isReadPixelsInProgress = false;\n        this._readPixelsSelector = Pixel.Selector.None;\n        this._drawNonLocatable = true;\n        this._analysisFraction = 0;\n        this._antialiasSamples = 1;\n        this._screenSpaceEffects = [];\n        this.isFadeOutActive = false;\n        // RenderTargetDebugControl\n        this.vcSupportIntersectingVolumes = false;\n        this.drawForReadPixels = false;\n        this.drawingBackgroundForReadPixels = false;\n        this.primitiveVisibility = PrimitiveVisibility.All;\n        this.displayDrapeFrustum = false;\n        this.displayRealityTilePreload = false;\n        this.displayRealityTileRanges = false;\n        this.logRealityTiles = false;\n        this.displayNormalMaps = true;\n        this.freezeRealityTiles = false;\n        this._isDisposed = false;\n        this._scratchRange = new Range3d();\n        this._frameStatsCollector = new FrameStatsCollector();\n        this._scratchTmpFrustum = new Frustum();\n        this._scratchRectFrustum = new Frustum();\n        this._renderCommands = this.uniforms.branch.createRenderCommands(this.uniforms.batch.state);\n        this._overlayRenderState = new RenderState();\n        this._overlayRenderState.flags.depthMask = false;\n        this._overlayRenderState.flags.blend = true;\n        this._overlayRenderState.blend.setBlendFunc(GL.BlendFactor.One, GL.BlendFactor.OneMinusSrcAlpha);\n        this._compositor = SceneCompositor.create(this); // compositor is created but not yet initialized... we are still undisposed\n        this.renderRect = rect ? rect : new ViewRect(); // if the rect is undefined, expect that it will be updated dynamically in an OnScreenTarget\n        if (undefined !== System.instance.antialiasSamples)\n            this._antialiasSamples = System.instance.antialiasSamples;\n        else\n            this._antialiasSamples = (undefined !== System.instance.options.antialiasSamples ? System.instance.options.antialiasSamples : 1);\n    }\n    get compositor() { return this._compositor; }\n    get isReadPixelsInProgress() { return this._isReadPixelsInProgress; }\n    get readPixelsSelector() { return this._readPixelsSelector; }\n    get drawNonLocatable() { return this._drawNonLocatable; }\n    get techniques() { return this.renderSystem.techniques; }\n    get hilites() { return this._hilites; }\n    get hiliteSyncTarget() { return this._hiliteSyncTarget; }\n    get flashed() { return Id64.isValid(this._flashedId) ? this._flashed : undefined; }\n    get flashedId() { return this._flashedId; }\n    get flashIntensity() { return this._flashIntensity; }\n    get analysisFraction() { return this._analysisFraction; }\n    set analysisFraction(fraction) { this._analysisFraction = fraction; }\n    get animationBranches() {\n        return this._animationBranches;\n    }\n    set animationBranches(branches) {\n        this.disposeAnimationBranches();\n        this._animationBranches = branches;\n    }\n    disposeAnimationBranches() {\n        this._animationBranches = undefined;\n    }\n    get antialiasSamples() { return this._antialiasSamples; }\n    set antialiasSamples(numSamples) { this._antialiasSamples = numSamples; }\n    get solarShadowMap() { return this.compositor.solarShadowMap; }\n    get isDrawingShadowMap() { return this.solarShadowMap.isEnabled && this.solarShadowMap.isDrawing; }\n    getPlanarClassifier(id) {\n        return undefined !== this._planarClassifiers ? this._planarClassifiers.get(id) : undefined;\n    }\n    createPlanarClassifier(properties) {\n        return PlanarClassifier.create(properties, this);\n    }\n    getTextureDrape(id) {\n        return undefined !== this._textureDrapes ? this._textureDrapes.get(id) : undefined;\n    }\n    getWorldDecorations(decs) {\n        if (undefined === this._worldDecorations) {\n            // Don't allow flags like monochrome etc to affect world decorations. Allow lighting in 3d only.\n            const vf = new ViewFlags({\n                renderMode: RenderMode.SmoothShade,\n                clipVolume: false,\n                whiteOnWhiteReversal: false,\n                lighting: !this.is2d,\n                shadows: false,\n            });\n            this._worldDecorations = new WorldDecorations(vf);\n        }\n        this._worldDecorations.init(decs);\n        return this._worldDecorations;\n    }\n    get currentBranch() { return this.uniforms.branch.top; }\n    get currentViewFlags() { return this.currentBranch.viewFlags; }\n    get currentTransform() { return this.currentBranch.transform; }\n    get currentTransparencyThreshold() { return this.currentEdgeSettings.transparencyThreshold; }\n    get currentEdgeSettings() { return this.currentBranch.edgeSettings; }\n    get currentFeatureSymbologyOverrides() { return this.currentBranch.symbologyOverrides; }\n    get currentPlanarClassifier() { return this.currentBranch.planarClassifier; }\n    get currentlyDrawingClassifier() { return this._currentlyDrawingClassifier; }\n    get currentTextureDrape() {\n        const drape = this.currentBranch.textureDrape;\n        return undefined !== drape && drape.isReady ? drape : undefined;\n    }\n    get currentPlanarClassifierOrDrape() {\n        const drape = this.currentTextureDrape;\n        return undefined === drape ? this.currentPlanarClassifier : drape;\n    }\n    modelToView(modelPt, result) {\n        return this.uniforms.branch.modelViewMatrix.multiplyPoint3dQuietNormalize(modelPt, result);\n    }\n    get is2d() { return this.uniforms.frustum.is2d; }\n    get is3d() { return !this.is2d; }\n    get isDisposed() {\n        return this.graphics.isDisposed\n            && undefined === this._fbo\n            && undefined === this._worldDecorations\n            && undefined === this._planarClassifiers\n            && undefined === this._textureDrapes\n            && this._renderCommands.isEmpty\n            && 0 === this._batches.length\n            && this.uniforms.thematic.isDisposed\n            && this._isDisposed;\n    }\n    allocateFbo() {\n        if (this._fbo)\n            return this._fbo;\n        const rect = this.viewRect;\n        const color = TextureHandle.createForAttachment(rect.width, rect.height, GL.Texture.Format.Rgba, GL.Texture.DataType.UnsignedByte);\n        if (undefined === color)\n            return undefined;\n        const depth = System.instance.createDepthBuffer(rect.width, rect.height, 1);\n        if (undefined === depth) {\n            color.dispose();\n            return undefined;\n        }\n        this._fbo = FrameBuffer.create([color], depth);\n        if (undefined === this._fbo) {\n            color.dispose();\n            depth.dispose();\n            return undefined;\n        }\n        return this._fbo;\n    }\n    disposeFbo() {\n        if (!this._fbo)\n            return;\n        const tx = this._fbo.getColor(0);\n        const db = this._fbo.depthBuffer;\n        this._fbo = dispose(this._fbo);\n        this._dcAssigned = false;\n        // We allocated our framebuffer's color attachment, so must dispose of it too.\n        assert(undefined !== tx);\n        dispose(tx);\n        // We allocated our framebuffer's depth attachment, so must dispose of it too.\n        assert(undefined !== db);\n        dispose(db);\n    }\n    dispose() {\n        this.reset();\n        this.disposeFbo();\n        dispose(this._compositor);\n        this._viewport = undefined;\n        this._isDisposed = true;\n    }\n    pushBranch(branch) {\n        this.uniforms.branch.pushBranch(branch);\n    }\n    pushState(state) {\n        this.uniforms.branch.pushState(state);\n    }\n    popBranch() {\n        this.uniforms.branch.pop();\n    }\n    pushViewClip() {\n        this.uniforms.branch.pushViewClip();\n    }\n    popViewClip() {\n        this.uniforms.branch.popViewClip();\n    }\n    /** @internal */\n    isRangeOutsideActiveVolume(range) {\n        return this.uniforms.branch.clipStack.isRangeClipped(range, this.currentTransform);\n    }\n    /** @internal */\n    isGeometryOutsideActiveVolume(geom) {\n        if (!this.uniforms.branch.clipStack.hasClip || this.uniforms.branch.clipStack.hasOutsideColor)\n            return false;\n        const range = geom.computeRange(this._scratchRange);\n        return this.isRangeOutsideActiveVolume(range);\n    }\n    pushBatch(batch) {\n        this.uniforms.batch.setCurrentBatch(batch);\n    }\n    popBatch() {\n        this.uniforms.batch.setCurrentBatch(undefined);\n    }\n    addBatch(batch) {\n        assert(this._batches.indexOf(batch) < 0);\n        this._batches.push(batch);\n    }\n    onBatchDisposed(batch) {\n        const index = this._batches.indexOf(batch);\n        assert(index > -1);\n        this._batches.splice(index, 1);\n    }\n    get wantAmbientOcclusion() {\n        return this._wantAmbientOcclusion;\n    }\n    get wantThematicDisplay() {\n        return this.currentViewFlags.thematicDisplay && this.is3d && undefined !== this.uniforms.thematic.thematicDisplay;\n    }\n    get wantAtmosphere() {\n        return undefined !== this.plan.atmosphere;\n    }\n    get wantThematicSensors() {\n        const thematic = this.plan.thematic;\n        return this.wantThematicDisplay && undefined !== thematic && ThematicDisplayMode.InverseDistanceWeightedSensors === thematic.displayMode && thematic.sensorSettings.sensors.length > 0;\n    }\n    updateSolarShadows(context) {\n        this.compositor.updateSolarShadows(context);\n    }\n    // ---- Implementation of RenderTarget interface ---- //\n    get renderSystem() { return System.instance; }\n    get planFraction() { return this.uniforms.frustum.planFraction; }\n    get planFrustum() { return this.uniforms.frustum.planFrustum; }\n    changeDecorations(decs) {\n        this.graphics.decorations = decs;\n    }\n    changeScene(scene) {\n        this.graphics.changeScene(scene);\n        this.changeTextureDrapes(scene.textureDrapes);\n        this.changePlanarClassifiers(scene.planarClassifiers);\n        this.changeDrapesOrClassifiers(this._planarClassifiers, scene.planarClassifiers);\n        this._planarClassifiers = scene.planarClassifiers;\n        this.activeVolumeClassifierProps = scene.volumeClassifier?.classifier;\n        this.activeVolumeClassifierModelId = scene.volumeClassifier?.modelId;\n    }\n    onBeforeRender(viewport, setSceneNeedRedraw) {\n        this._viewport = viewport;\n        IModelFrameLifecycle.onBeforeRender.raiseEvent({\n            renderSystem: this.renderSystem,\n            viewport,\n            setSceneNeedRedraw,\n        });\n    }\n    changeDrapesOrClassifiers(oldMap, newMap) {\n        if (undefined === newMap) {\n            if (undefined !== oldMap)\n                for (const value of oldMap.values())\n                    value.dispose();\n            return;\n        }\n        if (undefined !== oldMap) {\n            for (const entry of oldMap)\n                if (newMap.get(entry[0]) !== entry[1])\n                    entry[1].dispose();\n        }\n    }\n    changeTextureDrapes(textureDrapes) {\n        this.changeDrapesOrClassifiers(this._textureDrapes, textureDrapes);\n        this._textureDrapes = textureDrapes;\n    }\n    changePlanarClassifiers(planarClassifiers) {\n        this.changeDrapesOrClassifiers(this._planarClassifiers, planarClassifiers);\n        this._planarClassifiers = planarClassifiers;\n    }\n    changeDynamics(dynamics) {\n        this.graphics.dynamics = dynamics;\n    }\n    overrideFeatureSymbology(ovr) {\n        this.uniforms.branch.overrideFeatureSymbology(ovr);\n    }\n    setHiliteSet(hilite) {\n        this._hilites = hilite;\n        desync(this._hiliteSyncTarget);\n    }\n    setFlashed(id, intensity) {\n        if (id !== this._flashedId) {\n            this._flashedId = id;\n            this._flashed = Id64.getUint32Pair(id);\n        }\n        this._flashIntensity = intensity;\n    }\n    changeFrustum(newFrustum, newFraction, is3d) {\n        this.uniforms.frustum.changeFrustum(newFrustum, newFraction, is3d);\n    }\n    changeRenderPlan(plan) {\n        this.plan = plan;\n        if (this._dcAssigned && plan.is3d !== this.is3d) {\n            // changed the dimensionality of the Target. World decorations no longer valid.\n            // (lighting is enabled or disabled based on 2d vs 3d).\n            this._worldDecorations = dispose(this._worldDecorations);\n            // Turn off shadows if switching from 3d to 2d\n            if (!plan.is3d)\n                this.updateSolarShadows(undefined);\n        }\n        if (plan.is3d !== this.decorationsState.is3d)\n            this.decorationsState.changeRenderPlan(this.decorationsState.viewFlags, plan.is3d, undefined);\n        if (!this.assignDC())\n            return;\n        this.isFadeOutActive = plan.isFadeOutActive;\n        this.analysisStyle = plan.analysisStyle;\n        this.analysisTexture = plan.analysisTexture;\n        this.uniforms.branch.updateViewClip(plan.clip, plan.clipStyle);\n        let vf = plan.viewFlags;\n        if (!plan.is3d)\n            vf = vf.withRenderMode(RenderMode.Wireframe);\n        if (RenderMode.SmoothShade === vf.renderMode && plan.is3d && undefined !== plan.ao && vf.ambientOcclusion) {\n            this._wantAmbientOcclusion = true;\n            this.ambientOcclusionSettings = plan.ao;\n        }\n        else {\n            this._wantAmbientOcclusion = false;\n            vf = vf.with(\"ambientOcclusion\", false);\n        }\n        this.uniforms.branch.changeRenderPlan(vf, plan.is3d, plan.hline);\n        this.changeFrustum(plan.frustum, plan.fraction, plan.is3d);\n        this.uniforms.thematic.update(this);\n        this.uniforms.atmosphere.update(this);\n        // NB: This must be done after changeFrustum() as some of the uniforms depend on the frustum.\n        this.uniforms.updateRenderPlan(plan);\n    }\n    drawFrame(sceneMilSecElapsed) {\n        assert(this.renderSystem.frameBufferStack.isEmpty);\n        if (!this.assignDC())\n            return;\n        this.paintScene(sceneMilSecElapsed);\n        this.drawOverlayDecorations();\n        assert(this.renderSystem.frameBufferStack.isEmpty);\n    }\n    drawOverlayDecorations() { }\n    /**\n     * Invoked via Viewport.changeView() when the owning Viewport is changed to look at a different view.\n     * Invoked via dispose() when the target is being destroyed.\n     * The primary difference is that in the former case we retain the SceneCompositor.\n     */\n    reset() {\n        this.graphics.dispose();\n        this._worldDecorations = dispose(this._worldDecorations);\n        dispose(this.uniforms.thematic);\n        this.changePlanarClassifiers(undefined);\n        this.changeTextureDrapes(undefined);\n        this._renderCommands.clear();\n        // Clear FeatureOverrides for this Target.\n        // This may not be strictly necessary as the Target may still be viewing some of these batches, but better to clean up and recreate\n        // than to leave unused in memory.\n        for (const batch of this._batches)\n            batch.onTargetDisposed(this);\n        this._batches = [];\n        this.disposeAnimationBranches();\n        freeDrawParams();\n        ShaderProgramExecutor.freeParams();\n        Primitive.freeParams();\n    }\n    get wantInvertBlackBackground() { return false; }\n    computeEdgeWeight(pass, baseWeight) {\n        return this.currentEdgeSettings.getWeight(pass, this.currentViewFlags) ?? baseWeight;\n    }\n    computeEdgeLineCode(pass, baseCode) {\n        return this.currentEdgeSettings.getLineCode(pass, this.currentViewFlags) ?? baseCode;\n    }\n    computeEdgeColor(baseColor) {\n        const color = this.currentEdgeSettings.getColor(this.currentViewFlags);\n        return undefined !== color ? ColorInfo.createUniform(color) : baseColor;\n    }\n    beginPerfMetricFrame(sceneMilSecElapsed, readPixels = false) {\n        if (!readPixels || (this.performanceMetrics && !this.performanceMetrics.gatherCurPerformanceMetrics)) { // only capture readPixel data if in disp-perf-test-app\n            if (this.renderSystem.isGLTimerSupported)\n                this.renderSystem.glTimer.beginFrame();\n            if (this.performanceMetrics)\n                this.performanceMetrics.beginFrame(sceneMilSecElapsed);\n        }\n    }\n    endPerfMetricFrame(readPixels = false) {\n        if (!readPixels || (this.performanceMetrics && !this.performanceMetrics.gatherCurPerformanceMetrics)) { // only capture readPixel data if in disp-perf-test-app\n            if (this.renderSystem.isGLTimerSupported)\n                this.renderSystem.glTimer.endFrame();\n            if (undefined === this.performanceMetrics)\n                return;\n            this.performanceMetrics.endOperation(); // End the 'CPU Total Time' operation\n            this.performanceMetrics.completeFrameTimings(this._fbo);\n        }\n    }\n    beginPerfMetricRecord(operation, readPixels = false) {\n        if (!readPixels || (this.performanceMetrics && !this.performanceMetrics.gatherCurPerformanceMetrics)) { // only capture readPixel data if in disp-perf-test-app\n            if (this.renderSystem.isGLTimerSupported)\n                this.renderSystem.glTimer.beginOperation(operation);\n            if (this.performanceMetrics)\n                this.performanceMetrics.beginOperation(operation);\n        }\n    }\n    endPerfMetricRecord(readPixels = false) {\n        if (!readPixels || (this.performanceMetrics && !this.performanceMetrics.gatherCurPerformanceMetrics)) { // only capture readPixel data if in disp-perf-test-app\n            if (this.renderSystem.isGLTimerSupported)\n                this.renderSystem.glTimer.endOperation();\n            if (this.performanceMetrics)\n                this.performanceMetrics.endOperation();\n        }\n    }\n    get frameStatsCollector() { return this._frameStatsCollector; }\n    assignFrameStatsCollector(collector) { this._frameStatsCollector = collector; }\n    paintScene(sceneMilSecElapsed) {\n        if (!this._dcAssigned)\n            return;\n        this._frameStatsCollector.beginTime(\"totalFrameTime\");\n        this.beginPerfMetricFrame(sceneMilSecElapsed, this.drawForReadPixels);\n        this.beginPerfMetricRecord(\"Begin Paint\", this.drawForReadPixels);\n        assert(undefined !== this._fbo);\n        this._beginPaint(this._fbo);\n        this.endPerfMetricRecord(this.drawForReadPixels);\n        const gl = this.renderSystem.context;\n        const rect = this.viewRect;\n        gl.viewport(0, 0, rect.width, rect.height);\n        // Set this to true to visualize the output of readPixels()...useful for debugging pick.\n        if (this.drawForReadPixels) {\n            this.beginReadPixels(Pixel.Selector.Feature);\n            this.compositor.drawForReadPixels(this._renderCommands, this.graphics.overlays, this.graphics.decorations?.worldOverlay, this.graphics.decorations?.viewOverlay);\n            this.endReadPixels();\n        }\n        else {\n            // After the Target is first created or any time its dimensions change, SceneCompositor.preDraw() must update\n            // the compositor's textures, framebuffers, etc. This *must* occur before any drawing occurs.\n            // SceneCompositor.draw() checks this, but solar shadow maps, planar classifiers, and texture drapes try to draw\n            // before then. So do it now.\n            this.compositor.preDraw();\n            this._frameStatsCollector.beginTime(\"classifiersTime\");\n            this.beginPerfMetricRecord(\"Planar Classifiers\");\n            this.drawPlanarClassifiers();\n            this.endPerfMetricRecord();\n            this._frameStatsCollector.endTime(\"classifiersTime\");\n            this._frameStatsCollector.beginTime(\"shadowsTime\");\n            this.beginPerfMetricRecord(\"Shadow Maps\");\n            this.drawSolarShadowMap();\n            this.endPerfMetricRecord();\n            this._frameStatsCollector.endTime(\"shadowsTime\");\n            this.beginPerfMetricRecord(\"Texture Drapes\");\n            this.drawTextureDrapes();\n            this.endPerfMetricRecord();\n            this.beginPerfMetricRecord(\"Init Commands\");\n            this._renderCommands.initForRender(this.graphics);\n            this.endPerfMetricRecord();\n            this.compositor.draw(this._renderCommands); // scene compositor gets disposed and then re-initialized... target remains undisposed\n            this._frameStatsCollector.beginTime(\"overlaysTime\");\n            this.beginPerfMetricRecord(\"Overlay Draws\");\n            this.beginPerfMetricRecord(\"World Overlays\");\n            this.drawPass(12 /* RenderPass.WorldOverlay */);\n            this.endPerfMetricRecord();\n            this.beginPerfMetricRecord(\"View Overlays\");\n            this.drawPass(13 /* RenderPass.ViewOverlay */);\n            this.endPerfMetricRecord();\n            this.endPerfMetricRecord(); // End \"Overlay Draws\"\n            this._frameStatsCollector.endTime(\"overlaysTime\");\n        }\n        // Apply screen-space effects. Note we do not reset this._isReadPixelsInProgress until *after* doing so, as screen-space effects only apply\n        // during readPixels() if the effect shifts pixels from their original locations.\n        this._frameStatsCollector.beginTime(\"screenspaceEffectsTime\");\n        this.beginPerfMetricRecord(\"Screenspace Effects\", this.drawForReadPixels);\n        this.renderSystem.screenSpaceEffects.apply(this);\n        this.endPerfMetricRecord(this.drawForReadPixels);\n        this._frameStatsCollector.endTime(\"screenspaceEffectsTime\");\n        // Reset the batch IDs in all batches drawn for this call.\n        this.uniforms.batch.resetBatchState();\n        this.beginPerfMetricRecord(\"End Paint\", this.drawForReadPixels);\n        this._endPaint();\n        this.endPerfMetricRecord(this.drawForReadPixels);\n        this.endPerfMetricFrame(this.drawForReadPixels);\n        this._frameStatsCollector.endTime(\"totalFrameTime\");\n    }\n    drawPass(pass) {\n        this.renderSystem.applyRenderState(this.getRenderState(pass));\n        this.techniques.execute(this, this._renderCommands.getCommands(pass), pass);\n    }\n    getRenderState(pass) {\n        // the other passes are handled by SceneCompositor\n        assert(13 /* RenderPass.ViewOverlay */ === pass || 12 /* RenderPass.WorldOverlay */ === pass);\n        return this._overlayRenderState;\n    }\n    assignDC() {\n        if (this._dcAssigned)\n            return true;\n        if (!this._assignDC())\n            return false;\n        const rect = this.viewRect;\n        if (rect.width < 1 || rect.height < 1)\n            return false;\n        this.uniforms.viewRect.update(rect.width, rect.height);\n        this._dcAssigned = true;\n        return true;\n    }\n    readPixels(rect, selector, receiver, excludeNonLocatable) {\n        if (!this.assignDC())\n            return;\n        // if (this.performanceMetrics && !this.performanceMetrics.gatherCurPerformanceMetrics)\n        this.beginPerfMetricFrame(undefined, true);\n        rect = this.cssViewRectToDeviceViewRect(rect);\n        const gl = this.renderSystem.context;\n        const viewRect = this.viewRect;\n        gl.viewport(0, 0, viewRect.width, viewRect.height);\n        // We can't reuse the previous frame's data for a variety of reasons, chief among them that some types of geometry (surfaces, translucent stuff) don't write\n        // to the pick buffers and others we don't want - such as non-pickable decorations - do.\n        // Render to an offscreen buffer so that we don't destroy the current color buffer.\n        const resources = this.createOrReuseReadPixelResources(rect);\n        if (resources === undefined) {\n            receiver(undefined);\n            return;\n        }\n        let result;\n        this.renderSystem.frameBufferStack.execute(resources.fbo, true, false, () => {\n            this._drawNonLocatable = !excludeNonLocatable;\n            result = this.readPixelsFromFbo(rect, selector);\n            this._drawNonLocatable = true;\n        });\n        this.disposeOrReuseReadPixelResources(resources);\n        receiver(result);\n        // Reset the batch IDs in all batches drawn for this call.\n        this.uniforms.batch.resetBatchState();\n    }\n    createOrReuseReadPixelResources(rect) {\n        if (this._readPixelReusableResources !== undefined) {\n            // To reuse a texture, we need it to be the same size or bigger than what we need\n            if (this._readPixelReusableResources.texture.width >= rect.width && this._readPixelReusableResources.texture.height >= rect.height) {\n                const resources = this._readPixelReusableResources;\n                this._readPixelReusableResources = undefined;\n                return resources;\n            }\n        }\n        // Create a new texture/fbo\n        const texture = TextureHandle.createForAttachment(rect.width, rect.height, GL.Texture.Format.Rgba, GL.Texture.DataType.UnsignedByte);\n        if (texture === undefined)\n            return undefined;\n        const fbo = FrameBuffer.create([texture]);\n        if (fbo === undefined) {\n            dispose(texture);\n            return undefined;\n        }\n        return { texture, fbo };\n    }\n    disposeOrReuseReadPixelResources({ texture, fbo }) {\n        const maxReusableTextureSize = 256;\n        const isTooBigToReuse = texture.width > maxReusableTextureSize || texture.height > maxReusableTextureSize;\n        let reuseResources = !isTooBigToReuse;\n        if (reuseResources && this._readPixelReusableResources !== undefined) {\n            // Keep the biggest texture\n            if (this._readPixelReusableResources.texture.width > texture.width && this._readPixelReusableResources.texture.height > texture.height) {\n                reuseResources = false; // The current resources being reused are better\n            }\n            else {\n                // Free memory of the current reusable resources before replacing them\n                dispose(this._readPixelReusableResources.fbo);\n                dispose(this._readPixelReusableResources.texture);\n            }\n        }\n        if (reuseResources) {\n            this._readPixelReusableResources = { texture, fbo };\n        }\n        else {\n            dispose(fbo);\n            dispose(texture);\n        }\n    }\n    beginReadPixels(selector, cullingFrustum) {\n        this.beginPerfMetricRecord(\"Init Commands\", true);\n        this._isReadPixelsInProgress = true;\n        this._readPixelsSelector = selector;\n        // Temporarily turn off lighting to speed things up.\n        // ###TODO: Disable textures *unless* they contain transparency. If we turn them off unconditionally then readPixels() will locate fully-transparent pixels, which we don't want.\n        const vf = this.currentViewFlags.copy({\n            transparency: false,\n            lighting: false,\n            shadows: false,\n            acsTriad: false,\n            grid: false,\n            monochrome: false,\n            materials: false,\n            ambientOcclusion: false,\n            thematicDisplay: this.currentViewFlags.thematicDisplay && this.uniforms.thematic.wantIsoLines,\n        });\n        const top = this.currentBranch;\n        const state = new BranchState({\n            viewFlags: vf,\n            symbologyOverrides: top.symbologyOverrides,\n            is3d: top.is3d,\n            edgeSettings: top.edgeSettings,\n            transform: Transform.createIdentity(),\n            clipVolume: top.clipVolume,\n        });\n        this.pushState(state);\n        // Repopulate the command list, omitting non-pickable decorations and putting transparent stuff into the opaque passes.\n        if (cullingFrustum)\n            this._renderCommands.setCheckRange(cullingFrustum);\n        this._renderCommands.initForReadPixels(this.graphics);\n        this._renderCommands.clearCheckRange();\n        this.endPerfMetricRecord(true);\n    }\n    endReadPixels(preserveBatchState = false) {\n        // Pop the BranchState pushed by beginReadPixels.\n        this.uniforms.branch.pop();\n        if (!preserveBatchState)\n            this.uniforms.batch.resetBatchState();\n        this._isReadPixelsInProgress = false;\n    }\n    readPixelsFromFbo(rect, selector) {\n        // Create a culling frustum based on the input rect. We can't do this if a screen-space effect is going to move pixels around.\n        let rectFrust;\n        if (!this.renderSystem.screenSpaceEffects.shouldApply(this)) {\n            const viewRect = this.viewRect;\n            const leftScale = (rect.left - viewRect.left) / (viewRect.right - viewRect.left);\n            const rightScale = (viewRect.right - rect.right) / (viewRect.right - viewRect.left);\n            const topScale = (rect.top - viewRect.top) / (viewRect.bottom - viewRect.top);\n            const bottomScale = (viewRect.bottom - rect.bottom) / (viewRect.bottom - viewRect.top);\n            const tmpFrust = this._scratchTmpFrustum;\n            const planFrust = this.planFrustum;\n            interpolateFrustumPoint(tmpFrust, planFrust, Npc._000, leftScale, Npc._100);\n            interpolateFrustumPoint(tmpFrust, planFrust, Npc._100, rightScale, Npc._000);\n            interpolateFrustumPoint(tmpFrust, planFrust, Npc._010, leftScale, Npc._110);\n            interpolateFrustumPoint(tmpFrust, planFrust, Npc._110, rightScale, Npc._010);\n            interpolateFrustumPoint(tmpFrust, planFrust, Npc._001, leftScale, Npc._101);\n            interpolateFrustumPoint(tmpFrust, planFrust, Npc._101, rightScale, Npc._001);\n            interpolateFrustumPoint(tmpFrust, planFrust, Npc._011, leftScale, Npc._111);\n            interpolateFrustumPoint(tmpFrust, planFrust, Npc._111, rightScale, Npc._011);\n            rectFrust = this._scratchRectFrustum;\n            interpolateFrustumPoint(rectFrust, tmpFrust, Npc._000, bottomScale, Npc._010);\n            interpolateFrustumPoint(rectFrust, tmpFrust, Npc._100, bottomScale, Npc._110);\n            interpolateFrustumPoint(rectFrust, tmpFrust, Npc._010, topScale, Npc._000);\n            interpolateFrustumPoint(rectFrust, tmpFrust, Npc._110, topScale, Npc._100);\n            interpolateFrustumPoint(rectFrust, tmpFrust, Npc._001, bottomScale, Npc._011);\n            interpolateFrustumPoint(rectFrust, tmpFrust, Npc._101, bottomScale, Npc._111);\n            interpolateFrustumPoint(rectFrust, tmpFrust, Npc._011, topScale, Npc._001);\n            interpolateFrustumPoint(rectFrust, tmpFrust, Npc._111, topScale, Npc._101);\n        }\n        this.beginReadPixels(selector, rectFrust);\n        // Draw the scene\n        this.compositor.drawForReadPixels(this._renderCommands, this.graphics.overlays, this.graphics.decorations?.worldOverlay, this.graphics.decorations?.viewOverlay);\n        if (this.performanceMetrics && !this.performanceMetrics.gatherCurPerformanceMetrics) { // Only collect readPixels data if in disp-perf-test-app\n            this.performanceMetrics.endOperation(); // End the 'CPU Total Time' operation\n            if (this.performanceMetrics.gatherGlFinish && !this.renderSystem.isGLTimerSupported) {\n                // Ensure all previously queued webgl commands are finished by reading back one pixel since gl.Finish didn't work\n                this.performanceMetrics.beginOperation(\"Finish GPU Queue\");\n                const gl = this.renderSystem.context;\n                const bytes = new Uint8Array(4);\n                this.renderSystem.frameBufferStack.execute(this._fbo, true, false, () => {\n                    gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, bytes);\n                });\n                this.performanceMetrics.endOperation();\n            }\n        }\n        // Apply any screen-space effects that shift pixels from their original locations.\n        this.beginPerfMetricRecord(\"Screenspace Effects\", true);\n        this.renderSystem.screenSpaceEffects.apply(this);\n        this.endPerfMetricRecord(true); // End \"Screenspace Effects\"\n        this.endReadPixels(true);\n        this.beginPerfMetricRecord(\"Read Pixels\", true);\n        const result = this.compositor.readPixels(rect, selector);\n        this.endPerfMetricRecord(true);\n        if (this.performanceMetrics && !this.performanceMetrics.gatherCurPerformanceMetrics) { // Only collect readPixels data if in disp-perf-test-app\n            if (this.renderSystem.isGLTimerSupported)\n                this.renderSystem.glTimer.endFrame();\n            if (this.performanceMetrics)\n                this.performanceMetrics.endFrame();\n        }\n        return result;\n    }\n    queryVisibleTileFeatures(options, iModel, callback) {\n        this.beginReadPixels(Pixel.Selector.Feature);\n        callback(new VisibleTileFeatures(this._renderCommands, options, this, iModel));\n        this.endReadPixels();\n    }\n    readImagePixels(out, x, y, w, h) {\n        assert(this._fbo !== undefined);\n        if (this._fbo === undefined)\n            return false;\n        const context = this.renderSystem.context;\n        let didSucceed = true;\n        this.renderSystem.frameBufferStack.execute(this._fbo, true, false, () => {\n            try {\n                context.readPixels(x, y, w, h, context.RGBA, context.UNSIGNED_BYTE, out);\n            }\n            catch (e) {\n                didSucceed = false;\n            }\n        });\n        return didSucceed;\n    }\n    /** Returns a new size scaled up to a maximum size while maintaining proper aspect ratio.  The new size will be\n     * curSize adjusted so that it fits fully within maxSize in one dimension, maintaining its original aspect ratio.\n     */\n    static _applyAspectRatioCorrection(curSize, maxSize) {\n        const widthRatio = maxSize.x / curSize.x;\n        const heightRatio = maxSize.y / curSize.y;\n        const bestRatio = Math.min(widthRatio, heightRatio);\n        return new Point2d(curSize.x * bestRatio, curSize.y * bestRatio);\n    }\n    /** wantRectIn is in CSS pixels. Output ImageBuffer will be in device pixels.\n     * If wantRect is null, that means \"read the entire image\".\n     */\n    readImage(wantRectIn, targetSizeIn, flipVertically) {\n        if (!this.assignDC())\n            return undefined;\n        // Determine capture rect and validate\n        const actualViewRect = this.renderRect; // already has device pixel ratio applied\n        const wantRect = wantRectIn.isNull ? actualViewRect : this.cssViewRectToDeviceViewRect(wantRectIn);\n        const lowerRight = Point2d.create(wantRect.right - 1, wantRect.bottom - 1);\n        if (!actualViewRect.containsPoint(Point2d.create(wantRect.left, wantRect.top)) || !actualViewRect.containsPoint(lowerRight))\n            return undefined;\n        // Read pixels. Note ViewRect thinks (0,0) = top-left. gl.readPixels expects (0,0) = bottom-left.\n        const bytesPerPixel = 4;\n        const imageData = new Uint8Array(bytesPerPixel * wantRect.width * wantRect.height);\n        const isValidImageData = this.readImagePixels(imageData, wantRect.left, wantRect.top, wantRect.width, wantRect.height);\n        if (!isValidImageData)\n            return undefined;\n        let image = ImageBuffer.create(imageData, ImageBufferFormat.Rgba, wantRect.width);\n        if (!image)\n            return undefined;\n        const targetSize = targetSizeIn.clone();\n        if (targetSize.x === 0 || targetSize.y === 0) { // Indicates image should have same dimensions as rect (no scaling)\n            targetSize.x = wantRect.width;\n            targetSize.y = wantRect.height;\n        }\n        if (targetSize.x === wantRect.width && targetSize.y === wantRect.height) {\n            // No need to scale image.\n            // Some callers want background pixels to be treated as fully-transparent\n            // They indicate this by supplying a background color with full transparency\n            // Any other pixels are treated as fully-opaque as alpha has already been blended\n            // ###TODO: This introduces a defect in that we are not preserving alpha of translucent pixels, and therefore the returned image cannot be blended\n            const preserveBGAlpha = 0.0 === this.uniforms.style.backgroundAlpha;\n            // Optimization for view attachments: if image consists entirely of background pixels, return an undefined\n            let isEmptyImage = true;\n            for (let i = 3; i < image.data.length; i += 4) {\n                const a = image.data[i];\n                if (!preserveBGAlpha || 0 < a) {\n                    image.data[i] = 0xff;\n                    isEmptyImage = false;\n                }\n            }\n            if (isEmptyImage)\n                return undefined;\n        }\n        else {\n            // Need to scale image.\n            const canvas = imageBufferToCanvas(image, false); // retrieve a canvas of the image we read, throwing away alpha channel.\n            if (undefined === canvas)\n                return undefined;\n            const adjustedTargetSize = Target._applyAspectRatioCorrection(new Point2d(wantRect.width, wantRect.height), targetSize);\n            const resizedCanvas = canvasToResizedCanvasWithBars(canvas, adjustedTargetSize, new Point2d(targetSize.x - adjustedTargetSize.x, targetSize.y - adjustedTargetSize.y), this.uniforms.style.backgroundHexString);\n            const resizedImage = canvasToImageBuffer(resizedCanvas);\n            if (undefined !== resizedImage)\n                image = resizedImage;\n        }\n        if (flipVertically) {\n            const halfHeight = Math.floor(image.height / 2);\n            const numBytesPerRow = image.width * 4;\n            for (let loY = 0; loY < halfHeight; loY++) {\n                for (let x = 0; x < image.width; x++) {\n                    const hiY = (image.height - 1) - loY;\n                    const loIdx = loY * numBytesPerRow + x * 4;\n                    const hiIdx = hiY * numBytesPerRow + x * 4;\n                    swapImageByte(image, loIdx, hiIdx);\n                    swapImageByte(image, loIdx + 1, hiIdx + 1);\n                    swapImageByte(image, loIdx + 2, hiIdx + 2);\n                    swapImageByte(image, loIdx + 3, hiIdx + 3);\n                }\n            }\n        }\n        return image;\n    }\n    readImageBuffer(args) {\n        if (!this.assignDC())\n            return undefined;\n        // Determine and validate capture rect.\n        const viewRect = this.renderRect; // already has device pixel ratio applied\n        const captureRect = args?.rect ? this.cssViewRectToDeviceViewRect(args.rect) : viewRect;\n        if (captureRect.isNull)\n            return undefined;\n        const topLeft = Point3d.create(captureRect.left, captureRect.top);\n        const bottomRight = Point2d.create(captureRect.right - 1, captureRect.bottom - 1);\n        if (!viewRect.containsPoint(topLeft) || !viewRect.containsPoint(bottomRight))\n            return undefined;\n        // ViewRect origin is at top-left. GL origin is at bottom-left.\n        const bottom = viewRect.height - captureRect.bottom;\n        const imageData = new Uint8Array(4 * captureRect.width * captureRect.height);\n        if (!this.readImagePixels(imageData, captureRect.left, bottom, captureRect.width, captureRect.height))\n            return undefined;\n        // Alpha has already been blended. Make all pixels opaque, *except* for background pixels if background color is fully transparent.\n        const preserveBGAlpha = 0 === this.uniforms.style.backgroundAlpha;\n        let isEmptyImage = true;\n        for (let i = 3; i < imageData.length; i += 4) {\n            const a = imageData[i];\n            if (!preserveBGAlpha || a > 0) {\n                imageData[i] = 0xff;\n                isEmptyImage = false;\n            }\n        }\n        // Optimization for view attachments: if image consists entirely of transparent background pixels, don't bother producing an image.\n        let image = !isEmptyImage ? ImageBuffer.create(imageData, ImageBufferFormat.Rgba, captureRect.width) : undefined;\n        if (!image)\n            return undefined;\n        // Scale image.\n        if (args?.size && (args.size.x !== captureRect.width || args.size.y !== captureRect.height)) {\n            if (args.size.x <= 0 || args.size.y <= 0)\n                return undefined;\n            let canvas = imageBufferToCanvas(image, true);\n            if (!canvas)\n                return undefined;\n            const adjustedSize = Target._applyAspectRatioCorrection({ x: captureRect.width, y: captureRect.height }, args.size);\n            canvas = canvasToResizedCanvasWithBars(canvas, adjustedSize, new Point2d(args.size.x - adjustedSize.x, args.size.y - adjustedSize.y), this.uniforms.style.backgroundHexString);\n            image = canvasToImageBuffer(canvas);\n            if (!image)\n                return undefined;\n        }\n        // Our image is upside-down by default. Flip it unless otherwise specified.\n        if (!args?.upsideDown) {\n            const halfHeight = Math.floor(image.height / 2);\n            const numBytesPerRow = image.width * 4;\n            for (let loY = 0; loY < halfHeight; loY++) {\n                for (let x = 0; x < image.width; x++) {\n                    const hiY = (image.height - 1) - loY;\n                    const loIdx = loY * numBytesPerRow + x * 4;\n                    const hiIdx = hiY * numBytesPerRow + x * 4;\n                    swapImageByte(image, loIdx, hiIdx);\n                    swapImageByte(image, loIdx + 1, hiIdx + 1);\n                    swapImageByte(image, loIdx + 2, hiIdx + 2);\n                    swapImageByte(image, loIdx + 3, hiIdx + 3);\n                }\n            }\n        }\n        return image;\n    }\n    copyImageToCanvas() {\n        const image = this.readImageBuffer();\n        const canvas = undefined !== image ? imageBufferToCanvas(image, false) : undefined;\n        const retCanvas = undefined !== canvas ? canvas : document.createElement(\"canvas\");\n        const pixelRatio = this.devicePixelRatio;\n        retCanvas.getContext(\"2d\").scale(pixelRatio, pixelRatio);\n        return retCanvas;\n    }\n    drawPlanarClassifiers() {\n        if (this._planarClassifiers) {\n            this._planarClassifiers.forEach((classifier) => {\n                this._currentlyDrawingClassifier = classifier;\n                this._currentlyDrawingClassifier.draw(this);\n                this._currentlyDrawingClassifier = undefined;\n            });\n        }\n    }\n    drawSolarShadowMap() {\n        if (this.solarShadowMap.isEnabled)\n            this.solarShadowMap.draw(this);\n    }\n    drawTextureDrapes() {\n        if (this._textureDrapes)\n            this._textureDrapes.forEach((drape) => drape.draw(this));\n    }\n    get screenSpaceEffects() {\n        return this._screenSpaceEffects;\n    }\n    set screenSpaceEffects(effects) {\n        this._screenSpaceEffects = [...effects];\n    }\n    get screenSpaceEffectContext() {\n        assert(undefined !== this._viewport);\n        return { viewport: this._viewport };\n    }\n    get currentAnimationTransformNodeId() {\n        return this._currentAnimationTransformNodeId;\n    }\n    set currentAnimationTransformNodeId(id) {\n        assert(undefined === this._currentAnimationTransformNodeId || undefined === id);\n        this._currentAnimationTransformNodeId = id;\n    }\n    /** Given GraphicBranch.animationId identifying *any* node in the scene's schedule script, return the transform node Id\n     * that should be used to filter the branch's graphics for display, or undefined if no filtering should be applied.\n     */\n    getAnimationTransformNodeId(animationNodeId) {\n        if (undefined === this.animationBranches || undefined === this.currentAnimationTransformNodeId || undefined === animationNodeId)\n            return undefined;\n        return this.animationBranches.transformNodeIds.has(animationNodeId) ? animationNodeId : AnimationNodeId.Untransformed;\n    }\n    collectStatistics(stats) {\n        this._compositor.collectStatistics(stats);\n        const thematicBytes = this.uniforms.thematic.bytesUsed;\n        if (0 < thematicBytes)\n            stats.addThematicTexture(thematicBytes);\n        const clipBytes = this.uniforms.branch.clipStack.bytesUsed;\n        if (clipBytes)\n            stats.addClipVolume(clipBytes);\n    }\n    cssViewRectToDeviceViewRect(rect) {\n        // NB: ViewRect constructor *floors* inputs.\n        const ratio = this.devicePixelRatio;\n        return new ViewRect(Math.floor(rect.left * ratio), Math.floor(rect.top * ratio), Math.floor(rect.right * ratio), Math.floor(rect.bottom * ratio));\n    }\n    getRenderCommands() {\n        return this._renderCommands.dump();\n    }\n}\nclass CanvasState {\n    constructor(canvas) {\n        this.needsClear = false;\n        this.canvas = canvas;\n        this._isWebGLCanvas = this.canvas === System.instance.canvas;\n    }\n    // Returns true if the rect actually changed.\n    updateDimensions(pixelRatio) {\n        const w = Math.floor(this.canvas.clientWidth * pixelRatio);\n        const h = Math.floor(this.canvas.clientHeight * pixelRatio);\n        // Do not update the dimensions if not needed, or if new width or height is 0, which is invalid.\n        // NB: the 0-dimension check indirectly resolves an issue when a viewport is dropped and immediately re-added\n        // to the view manager. See ViewManager.test.ts for more details.  0 is also the case when vpDiv.removeChild\n        // is done on webGLCanvas, due to client sizes being 0 afterward.\n        if (w === this.canvas.width && h === this.canvas.height || (0 === w || 0 === h))\n            return false;\n        // Must ensure internal bitmap grid dimensions of on-screen canvas match its own on-screen appearance.\n        this.canvas.width = w;\n        this.canvas.height = h;\n        if (!this._isWebGLCanvas) {\n            const ctx = this.canvas.getContext(\"2d\");\n            ctx.scale(pixelRatio, pixelRatio); // apply the pixelRatio as a scale on the 2d context for drawing of decorations, etc.\n            ctx.save();\n        }\n        return true;\n    }\n    get width() { return this.canvas.width; }\n    get height() { return this.canvas.height; }\n}\n/** A Target that renders to a canvas on the screen\n * @internal\n */\nexport class OnScreenTarget extends Target {\n    get _curCanvas() { return this._usingWebGLCanvas ? this._webglCanvas : this._2dCanvas; }\n    constructor(canvas) {\n        super();\n        this._usingWebGLCanvas = false;\n        this._2dCanvas = new CanvasState(canvas);\n        this._webglCanvas = new CanvasState(this.renderSystem.canvas);\n    }\n    get isDisposed() {\n        return undefined === this._blitGeom\n            && undefined === this._scratchProgParams\n            && undefined === this._scratchDrawParams\n            && super.isDisposed;\n    }\n    dispose() {\n        this._blitGeom = dispose(this._blitGeom);\n        this._scratchProgParams = undefined;\n        this._scratchDrawParams = undefined;\n        super.dispose();\n    }\n    collectStatistics(stats) {\n        super.collectStatistics(stats);\n        if (undefined !== this._blitGeom)\n            this._blitGeom.collectStatistics(stats);\n    }\n    get devicePixelRatioOverride() { return this._devicePixelRatioOverride; }\n    set devicePixelRatioOverride(ovr) { this._devicePixelRatioOverride = ovr; }\n    get devicePixelRatio() {\n        if (undefined !== this.devicePixelRatioOverride)\n            return this.devicePixelRatioOverride;\n        if (false === this.renderSystem.options.dpiAwareViewports)\n            return 1.0;\n        if (undefined !== this.renderSystem.options.devicePixelRatioOverride)\n            return this.renderSystem.options.devicePixelRatioOverride;\n        return window.devicePixelRatio || 1.0;\n    }\n    setViewRect(_rect, _temporary) {\n        assert(false);\n    }\n    /** Internal-only function for testing. Returns true if the FBO dimensions match the canvas dimensions */\n    checkFboDimensions() {\n        if (undefined !== this._fbo) {\n            const tx = this._fbo.getColor(0);\n            if (tx.width !== this._curCanvas.width || tx.height !== this._curCanvas.height)\n                return false;\n        }\n        return true;\n    }\n    _assignDC() {\n        this.disposeFbo();\n        const fbo = this.allocateFbo();\n        if (!fbo)\n            return false;\n        const tx = fbo.getColor(0);\n        assert(undefined !== tx.getHandle());\n        this._blitGeom = SingleTexturedViewportQuadGeometry.createGeometry(tx.getHandle(), 19 /* TechniqueId.CopyColorNoAlpha */);\n        if (undefined === this._blitGeom)\n            this.disposeFbo();\n        return undefined !== this._blitGeom;\n    }\n    updateViewRect() {\n        const pixelRatio = this.devicePixelRatio;\n        const changed2d = this._2dCanvas.updateDimensions(pixelRatio);\n        const changedWebGL = this._webglCanvas.updateDimensions(pixelRatio);\n        this.renderRect.init(0, 0, this._curCanvas.width, this._curCanvas.height);\n        return this._usingWebGLCanvas ? changedWebGL : changed2d;\n    }\n    _beginPaint(fbo) {\n        // Render to our framebuffer\n        const system = this.renderSystem;\n        system.frameBufferStack.push(fbo, true, false);\n        const viewRect = this.viewRect;\n        // Ensure off-screen canvas is sufficiently large for on-screen canvas.\n        // Using a portion of a larger canvas lets us avoid thrashing canvas resizes with multiple viewports.\n        if (system.canvas.width < viewRect.width)\n            system.canvas.width = viewRect.width;\n        if (system.canvas.height < viewRect.height)\n            system.canvas.height = viewRect.height;\n        assert(system.context.drawingBufferWidth >= viewRect.width, \"offscreen context dimensions don't match onscreen\");\n        assert(system.context.drawingBufferHeight >= viewRect.height, \"offscreen context dimensions don't match onscreen\");\n    }\n    getDrawParams(target, geom) {\n        if (undefined === this._scratchProgParams) {\n            this._scratchProgParams = new ShaderProgramParams();\n            this._scratchDrawParams = new DrawParams();\n        }\n        this._scratchProgParams.init(target);\n        this._scratchDrawParams.init(this._scratchProgParams, geom);\n        return this._scratchDrawParams;\n    }\n    _endPaint() {\n        if (undefined === this._blitGeom)\n            return;\n        // Blit the final image to the canvas.\n        const drawParams = this.getDrawParams(this, this._blitGeom);\n        const system = this.renderSystem;\n        system.frameBufferStack.pop();\n        system.applyRenderState(RenderState.defaults);\n        system.techniques.draw(drawParams);\n        if (this._usingWebGLCanvas)\n            return; // We already drew (using WebGL) the framebuffer contents directly to the on-screen WebGL canvas.\n        // Copy off-screen canvas contents to on-screen canvas\n        const onscreenContext = this._2dCanvas.canvas.getContext(\"2d\", { alpha: true });\n        assert(null !== onscreenContext);\n        if (null !== onscreenContext) {\n            const w = this.viewRect.width, h = this.viewRect.height;\n            const yOffset = system.canvas.height - h; // drawImage has top as Y=0, GL has bottom as Y=0\n            onscreenContext.save();\n            if (this.uniforms.style.backgroundAlpha < 1) {\n                // If background is transparent, we aren't guaranteed that every pixel will be overwritten - clear it.\n                onscreenContext.clearRect(0, 0, w, h);\n            }\n            onscreenContext.setTransform(1, 0, 0, 1, 0, 0); // revert any previous devicePixelRatio scale for drawImage() call below.\n            onscreenContext.drawImage(system.canvas, 0, yOffset, w, h, 0, 0, w, h);\n            onscreenContext.restore();\n        }\n    }\n    drawOverlayDecorations() {\n        const ctx = this._2dCanvas.canvas.getContext(\"2d\", { alpha: true });\n        if (this._usingWebGLCanvas && this._2dCanvas.needsClear) {\n            ctx.save();\n            ctx.setTransform(1, 0, 0, 1, 0, 0); // revert any previous devicePixelRatio scale for clearRect() call below.\n            ctx.clearRect(0, 0, this._2dCanvas.width, this._2dCanvas.height);\n            ctx.restore();\n            this._2dCanvas.needsClear = false;\n        }\n        const canvasDecs = this.graphics.canvasDecorations;\n        if (canvasDecs) {\n            for (const overlay of canvasDecs) {\n                ctx.save();\n                if (overlay.position)\n                    ctx.translate(overlay.position.x, overlay.position.y);\n                overlay.drawDecoration(ctx);\n                this._2dCanvas.needsClear = true;\n                ctx.restore();\n            }\n        }\n    }\n    pickOverlayDecoration(pt) {\n        const overlays = this.graphics.canvasDecorations;\n        if (undefined === overlays)\n            return undefined;\n        // loop over array backwards, because later entries are drawn on top.\n        for (let i = overlays.length - 1; i >= 0; --i) {\n            const overlay = overlays[i];\n            if (undefined !== overlay.pick && overlay.pick(pt))\n                return overlay;\n        }\n        return undefined;\n    }\n    onResized() {\n        this.disposeFbo();\n    }\n    setRenderToScreen(toScreen) {\n        if (toScreen === this._usingWebGLCanvas)\n            return;\n        // NB: need to force a buffer change in this case because nothing is changing sizes except the webglCanvas\n        if (toScreen)\n            this.compositor.forceBufferChange();\n        this._usingWebGLCanvas = toScreen;\n        return toScreen ? this._webglCanvas.canvas : undefined;\n    }\n    readImageToCanvas() {\n        return this._usingWebGLCanvas ? this.copyImageToCanvas() : this._2dCanvas.canvas;\n    }\n}\n/** @internal */\nexport class OffScreenTarget extends Target {\n    constructor(rect) {\n        super(rect);\n    }\n    onResized() {\n        assert(false); // offscreen viewport's dimensions are set once, in constructor.\n    }\n    updateViewRect() { return false; } // offscreen target does not dynamically resize the view rect\n    setViewRect(rect, temporary) {\n        if (this.renderRect.equals(rect))\n            return;\n        this.renderRect.setFrom(rect);\n        if (temporary) {\n            // Temporarily adjust view rect to create scene for a view attachment.\n            // Will be reset before attachment is rendered - so don't blow away our framebuffers + textures\n            return;\n        }\n        this.disposeFbo();\n        dispose(this._compositor);\n    }\n    _assignDC() {\n        return undefined !== this.allocateFbo();\n    }\n    _beginPaint(fbo) {\n        this.renderSystem.frameBufferStack.push(fbo, true, false);\n    }\n    _endPaint() {\n        this.renderSystem.frameBufferStack.pop();\n    }\n    readImageToCanvas() {\n        return this.copyImageToCanvas();\n    }\n}\nfunction interpolatePoint(p0, fraction, p1, out) {\n    let x;\n    let y;\n    let z;\n    if (fraction <= 0.5) {\n        x = p0.x + fraction * (p1.x - p0.x);\n        y = p0.y + fraction * (p1.y - p0.y);\n        z = p0.z + fraction * (p1.z - p0.z);\n    }\n    else {\n        const t = fraction - 1.0;\n        x = p1.x + t * (p1.x - p0.x);\n        y = p1.y + t * (p1.y - p0.y);\n        z = p1.z + t * (p1.z - p0.z);\n    }\n    return Point3d.create(x, y, z, out);\n}\nfunction interpolateFrustumPoint(destFrust, srcFrust, destPoint, scale, srcPoint) {\n    interpolatePoint(srcFrust.getCorner(destPoint), scale, srcFrust.getCorner(srcPoint), destFrust.points[destPoint]);\n}\n//# sourceMappingURL=Target.js.map",
      "start": 1693508119711,
      "end": 1693508119819,
      "sourcemaps": null
    }
  ]
}
