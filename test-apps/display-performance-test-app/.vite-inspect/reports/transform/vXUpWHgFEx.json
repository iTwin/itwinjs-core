{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/numerics/ClusterableArray.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Numerics\n */\nimport { Geometry } from \"../Geometry\";\nimport { GrowableBlockedArray } from \"../geometry3d/GrowableBlockedArray\";\nimport { GrowableXYArray } from \"../geometry3d/GrowableXYArray\";\nimport { GrowableXYZArray } from \"../geometry3d/GrowableXYZArray\";\nimport { Point2d } from \"../geometry3d/Point2dVector2d\";\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\n/**\n * Blocked array with operations to sort and cluster with a tolerance.\n * * Primary sorting is along an \"arbitrary\" sort vector.\n * @internal\n */\nclass ClusterableArray extends GrowableBlockedArray {\n    /** Return a component of the sort vector. */\n    static sortVectorComponent(index) {\n        let c = 1.0;\n        for (let i = 1; i < index; i++)\n            c *= ClusterableArray._vectorFactor;\n        return c;\n    }\n    /**\n     * @param numCoordinatePerPoint number of coordinates per point\n     * @param  numExtraDataPerPoint of extra data values per point.\n     * @param initialBlockCapacity predicted number of points.  (This does not have to be accurate)\n     */\n    constructor(numCoordinatePerPoint, numExtraDataPerPoint, initialBlockCapacity) {\n        super(1 + numCoordinatePerPoint + numExtraDataPerPoint, initialBlockCapacity);\n        this._numExtraDataPerPoint = numExtraDataPerPoint;\n        this._numCoordinatePerPoint = numCoordinatePerPoint;\n    }\n    /** load a block, placing data[i] at block[i+1] to allow sort coordinate first.\n     * @param data array of numDataPerBlock values.\n     */\n    addBlock(data) {\n        const i0 = this.newBlockIndex() + 1;\n        const n = Math.min(this.numPerBlock - 1, data.length);\n        for (let i = 0; i < n; i++)\n            this._data[i0 + i] = data[i];\n    }\n    /** add a block directly with 1 to 5 listed content parameters.\n     * This assumes numDataPerPoint is sufficient for the parameters provided.\n     */\n    addDirect(x0, x1, x2, x3, x4) {\n        const i0 = this.newBlockIndex();\n        this._data[i0 + 1] = x0;\n        if (x1 !== undefined)\n            this._data[i0 + 2] = x1;\n        if (x2 !== undefined)\n            this._data[i0 + 3] = x2;\n        if (x3 !== undefined)\n            this._data[i0 + 4] = x3;\n        if (x4 !== undefined)\n            this._data[i0 + 5] = x4;\n    }\n    /** add a block directly from a Point2d with 0 to 3 extras\n     * This assumes numDataPerPoint is sufficient for the parameters provided.\n     */\n    addPoint2d(xy, a, b, c) {\n        const i0 = this.newBlockIndex();\n        this._data[i0 + 1] = xy.x;\n        this._data[i0 + 2] = xy.y;\n        if (a !== undefined)\n            this._data[i0 + 3] = a;\n        if (b !== undefined)\n            this._data[i0 + 4] = b;\n        if (c !== undefined)\n            this._data[i0 + 5] = c;\n    }\n    /** add a block with directly from a Point2d with 0 to 3 extras\n     * This assumes numDataPerPoint is sufficient for the parameters provided.\n     */\n    addPoint3d(xyz, a, b, c) {\n        const i0 = this.newBlockIndex();\n        this._data[i0 + 1] = xyz.x;\n        this._data[i0 + 2] = xyz.y;\n        this._data[i0 + 3] = xyz.z;\n        if (a !== undefined)\n            this._data[i0 + 4] = a;\n        if (b !== undefined)\n            this._data[i0 + 5] = b;\n        if (c !== undefined)\n            this._data[i0 + 6] = c;\n    }\n    /** Get the xy coordinates by point index. */\n    getPoint2d(blockIndex, result) {\n        const i0 = this.blockIndexToDoubleIndex(blockIndex);\n        return Point2d.create(this._data[i0 + 1], this._data[i0 + 2], result);\n    }\n    /** Get the xyZ coordinates by point index. */\n    getPoint3d(blockIndex, result) {\n        const i0 = this.blockIndexToDoubleIndex(blockIndex);\n        return Point3d.create(this._data[i0 + 1], this._data[i0 + 2], this._data[i0 + 3], result);\n    }\n    /** Return a single extra data value */\n    getExtraData(blockIndex, i) {\n        const i0 = this.blockIndexToDoubleIndex(blockIndex);\n        return this._data[i0 + 1 + this._numCoordinatePerPoint + i];\n    }\n    /** Return a single data value */\n    getData(blockIndex, i) {\n        const i0 = this.blockIndexToDoubleIndex(blockIndex);\n        return this._data[i0 + i];\n    }\n    /** Set a single extra data value */\n    setExtraData(blockIndex, i, value) {\n        const i0 = this.blockIndexToDoubleIndex(blockIndex);\n        this._data[i0 + 1 + this._numCoordinatePerPoint + i] = value;\n    }\n    /** Test if `x` is the cluster terminator value. */\n    static isClusterTerminator(x) { return x === ClusterableArray.clusterTerminator; }\n    /** Return an array giving clusters of blocks with similar coordinates.\n     *\n     * * The contents of each block is assumed to be set up so the primary sort coordinate is first.\n     *\n     * ** simple coordinate blocks (x,y) or (x,y,z) would work fine but have occasional performance problems because points with same x would generate big blocks of\n     * candidates for clusters.\n     * ** The usual solution is to sort by u value, which is a dot product along some skew direction, and have the blocks contain (u,x,y) or (u,x,y,z) for 2d versus 3d.\n     * ** apply setupPrimaryClusterSort to prepare that!!!\n     * * After a simple lexical sort, consecutive blocks that are within tolerance in the 0 component\n     * are inspected.  Within that candidate set, all blocks that are within tolerance for ALL components are clustered.\n     * * In the output cluster array, clusters are terminated a invalid index. Test for the invalid index with GrowableBlockArray.isClusterTerminator (x)\n     */\n    clusterIndicesLexical(clusterTolerance = Geometry.smallMetricDistance) {\n        // install primary sort key\n        this.setupPrimaryClusterSort();\n        // presort by all coordinates ....\n        const firstSort = this.sortIndicesLexical();\n        const clusterIndices = new Uint32Array(2 * firstSort.length); // worst case: no duplicates, each index goes in followed by terminator.\n        let m = 0; // number of cluster indices\n        const n = this.numBlocks; // and this must match firstSort.length !!\n        let clusterStartBlockIndex = 0;\n        let candidateBlockIndex = 0;\n        let barrierU = 0.0;\n        let i = 0;\n        let j = 0;\n        const k0 = 1; // beginning of active column for distance\n        const k1 = 1 + this._numCoordinatePerPoint;\n        for (i = 0; i < n; i++) {\n            clusterStartBlockIndex = firstSort[i];\n            if (!ClusterableArray.isClusterTerminator(clusterStartBlockIndex)) {\n                // unused block, so it becomes a cluster...\n                clusterIndices[m++] = clusterStartBlockIndex;\n                barrierU = this.component(clusterStartBlockIndex, 0) + clusterTolerance;\n                firstSort[i] = ClusterableArray.clusterTerminator;\n                for (j = i + 1; j < n; j++) {\n                    candidateBlockIndex = firstSort[j];\n                    if (candidateBlockIndex === ClusterableArray.clusterTerminator)\n                        continue; // nearby in sort direction but already in a cluster.\n                    if (this.component(candidateBlockIndex, 0) >= barrierU)\n                        break;\n                    if (this.distanceBetweenSubBlocks(clusterStartBlockIndex, candidateBlockIndex, k0, k1) < clusterTolerance) {\n                        clusterIndices[m++] = candidateBlockIndex; // The candidate is in the block\n                        firstSort[j] = ClusterableArray.clusterTerminator; // and it will not be reused as future block base\n                    }\n                }\n                clusterIndices[m++] = ClusterableArray.clusterTerminator;\n            }\n        }\n        // Alas, the clusterIndices array has fluff at the end.  So it has to be copied.\n        return clusterIndices.slice(0, m);\n    }\n    /** setup (overwrite!!) the \"0\" component with the dot product of numClusterCoordinate later components with a non-axis aligned vector.\n     * This is normally called before clusterIndicesLexical.\n     */\n    setupPrimaryClusterSort() {\n        const nb = this.numBlocks;\n        const nc = this._numCoordinatePerPoint;\n        const vector = new Float64Array(nc);\n        vector[0] = 1.0;\n        for (let c = 1; c < nc; c++)\n            vector[c] = vector[c - 1] * ClusterableArray._vectorFactor;\n        let k = 0;\n        let dot = 0.0;\n        const data = this._data;\n        for (let b = 0; b < nb; b++) {\n            k = this.blockIndexToDoubleIndex(b);\n            dot = 0.0;\n            for (let c = 0; c < nc; c++) {\n                dot += vector[c] * data[k + 1 + c];\n            }\n            data[k] = dot;\n        }\n    }\n    /** Convert the cluster data to an array of tuples with point i in the form\n     * `[i, primarySortCoordinate, [x,y,..], [extraData0, extraData1, ...]]`\n     */\n    toJSON() {\n        const result = [];\n        for (let b = 0; b < this.numBlocks; b++) {\n            let i = this.blockIndexToDoubleIndex(b);\n            const chunk = [b, this._data[i++]];\n            const coordinates = [];\n            for (let c = 0; c < this._numCoordinatePerPoint; c++)\n                coordinates.push(this._data[i++]);\n            chunk.push(coordinates);\n            for (let c = 0; c < this._numExtraDataPerPoint; c++)\n                chunk.push(this._data[i++]);\n            result.push(chunk);\n        }\n        return result;\n    }\n    /**\n     * Return an array of indices from block index to cluster index.\n     * @param clusteredBlocks clusters of block indices followed by separators.\n     */\n    createIndexBlockToClusterIndex(clusteredBlocks) {\n        const numBlocks = this.numBlocks;\n        const blockToCluster = new Uint32Array(numBlocks);\n        blockToCluster.fill(ClusterableArray.clusterTerminator);\n        let numCluster = 0;\n        for (const b of clusteredBlocks) {\n            if (b >= numBlocks) {\n                numCluster++;\n            }\n            else {\n                blockToCluster[b] = numCluster;\n            }\n        }\n        return blockToCluster;\n    }\n    /**\n     * Return an array of indices from block index to index of its cluster's start in the cluster index array.\n     * @param clusteredBlocks clusters of block indices followed by separators.\n     */\n    createIndexBlockToClusterStart(clusteredBlocks) {\n        const n = clusteredBlocks.length;\n        const numBlocks = this.numBlocks;\n        const blockToClusterStart = new Uint32Array(numBlocks);\n        const terminator = ClusterableArray.clusterTerminator;\n        blockToClusterStart.fill(terminator);\n        let clusterStart = 0;\n        for (let i = 0; i < n; i++) {\n            const k = clusteredBlocks[i];\n            if (k > numBlocks) {\n                clusterStart = i + 1;\n            }\n            else {\n                blockToClusterStart[k] = clusterStart;\n            }\n        }\n        return blockToClusterStart;\n    }\n    /** count the clusters in the clusteredBlocks array. */\n    countClusters(clusteredBlocks) {\n        let numClusters = 0;\n        const terminator = ClusterableArray.clusterTerminator;\n        for (const b of clusteredBlocks) {\n            if (b === terminator)\n                numClusters++;\n        }\n        return numClusters;\n    }\n    /** create a reverse index: given a cluster index k, clusterToClusterStart[k] is the place\n     * the cluster's block indices appear in clusterBlocks\n     */\n    createIndexClusterToClusterStart(clusteredBlocks) {\n        let numCluster = this.countClusters(clusteredBlocks);\n        const clusterToClusterStart = new Uint32Array(numCluster);\n        const terminator = ClusterableArray.clusterTerminator;\n        clusterToClusterStart.fill(terminator);\n        const n = clusteredBlocks.length;\n        let clusterStart = 0;\n        for (let i = 0; i < n; i++) {\n            const k = clusteredBlocks[i];\n            if (k === terminator) {\n                clusterStart = i + 1;\n            }\n            else if (i === clusterStart) {\n                clusterToClusterStart[numCluster++] = clusterStart;\n            }\n        }\n        return clusterToClusterStart;\n    }\n    /**\n     * Sort terminator-delimited subsets of an array of indices into the table, using a single data value as sort key.\n     * @param blockedIndices indices, organized as blocks of good indices terminated by the clusterTerminator. Each block is individually sorted on return.\n     * @param dataIndex index of the data key, e.g., if the sort key is the first extraData (angle) after x and y coordinate data, pass dataIndex = 2.\n     */\n    sortSubsetsBySingleKey(blockedIndices, dataIndex) {\n        const dataOffset = 1 + dataIndex;\n        let kBegin = 0;\n        let swap;\n        let key0, key1;\n        const numK = blockedIndices.length;\n        for (let kEnd = 0; kEnd < numK; kEnd++) {\n            if (blockedIndices[kEnd] === ClusterableArray.clusterTerminator) {\n                // bubble sort blockedIndices[kBegin <= k < kEnd].\n                //  (search for minimum remaining, swap  . . )\n                for (let k0 = kBegin; k0 + 1 < kEnd; k0++) {\n                    key0 = this.getWithinBlock(blockedIndices[k0], dataOffset);\n                    for (let k1 = k0 + 1; k1 < kEnd; k1++) {\n                        key1 = this.getWithinBlock(blockedIndices[k1], dataOffset);\n                        if (key1 < key0) {\n                            swap = blockedIndices[k0];\n                            blockedIndices[k0] = blockedIndices[k1];\n                            blockedIndices[k1] = swap;\n                            key0 = key1;\n                        }\n                    }\n                }\n                kBegin = kEnd + 1;\n            }\n        }\n    }\n    /**\n     * Returns packed points with indices mapping old to new.\n     * @param data points to cluster.\n     */\n    static clusterPoint3dArray(data, tolerance = Geometry.smallMetricDistance) {\n        const clusterArray = new ClusterableArray(3, 0, data.length);\n        data.forEach((p) => {\n            clusterArray.addDirect(p.x, p.y, p.z);\n        });\n        const order = clusterArray.clusterIndicesLexical(tolerance);\n        const result = new PackedPointsWithIndex(data.length);\n        let currentClusterIndex = 0;\n        let numThisCluster = 0;\n        order.forEach((k) => {\n            if (ClusterableArray.isClusterTerminator(k)) {\n                currentClusterIndex++;\n                numThisCluster = 0;\n            }\n            else {\n                if (numThisCluster === 0)\n                    result.packedPoints.push(data[k].clone());\n                result.oldToNew[k] = currentClusterIndex;\n                numThisCluster++;\n            }\n        });\n        return result;\n    }\n    /**\n     * Returns number array with indices mapping old to new.\n     * @param data numbers to cluster.\n     */\n    static clusterNumberArray(data, tolerance = Geometry.smallMetricDistance) {\n        const clusterArray = new ClusterableArray(1, 0, data.length);\n        data.forEach((x) => { clusterArray.addDirect(x); });\n        const order = clusterArray.clusterIndicesLexical(tolerance);\n        const result = new PackedNumbersWithIndex(data.length);\n        let currentClusterIndex = 0;\n        let numThisCluster = 0;\n        order.forEach((k) => {\n            if (ClusterableArray.isClusterTerminator(k)) {\n                currentClusterIndex++;\n                numThisCluster = 0;\n            }\n            else {\n                if (numThisCluster === 0)\n                    result.packedNumbers.push(data[k]);\n                result.oldToNew[k] = currentClusterIndex;\n                numThisCluster++;\n            }\n        });\n        return result;\n    }\n    /**\n     * Returns packed points with indices mapping old to new.\n     * @param data points to cluster.\n     */\n    static clusterGrowablePoint2dArray(source, tolerance = Geometry.smallMetricDistance) {\n        const clusterArray = new ClusterableArray(2, 0, source.length);\n        const p = Point2d.create();\n        const numSourcePoint = source.length;\n        for (let i = 0; i < numSourcePoint; i++) {\n            source.getPoint2dAtUncheckedPointIndex(i, p);\n            clusterArray.addDirect(p.x, p.y);\n        }\n        const order = clusterArray.clusterIndicesLexical(tolerance);\n        const numPackedPoints = clusterArray.countClusters(order);\n        const result = new PackedPoint2dsWithIndex(source.length, numPackedPoints);\n        let currentClusterIndex = 0;\n        let numThisCluster = 0;\n        order.forEach((k) => {\n            if (ClusterableArray.isClusterTerminator(k)) {\n                currentClusterIndex++;\n                numThisCluster = 0;\n            }\n            else {\n                if (numThisCluster === 0) // This is the first encounter with a new cluster\n                    result.growablePackedPoints.pushFromGrowableXYArray(source, k);\n                result.oldToNew[k] = currentClusterIndex;\n                numThisCluster++;\n            }\n        });\n        return result;\n    }\n    /**\n     * Returns packed points with indices mapping old to new.\n     * @param data points to cluster.\n     */\n    static clusterGrowablePoint3dArray(source, tolerance = Geometry.smallMetricDistance) {\n        const clusterArray = new ClusterableArray(3, 0, source.length);\n        const p = Point3d.create();\n        const numSourcePoint = source.length;\n        for (let i = 0; i < numSourcePoint; i++) {\n            source.getPoint3dAtUncheckedPointIndex(i, p);\n            clusterArray.addDirect(p.x, p.y, p.z);\n        }\n        const order = clusterArray.clusterIndicesLexical(tolerance);\n        const result = new PackedPointsWithIndex(source.length);\n        const numPackedPoints = clusterArray.countClusters(order);\n        result.growablePackedPoints = new GrowableXYZArray(numPackedPoints);\n        let currentClusterIndex = 0;\n        let numThisCluster = 0;\n        order.forEach((k) => {\n            if (ClusterableArray.isClusterTerminator(k)) {\n                currentClusterIndex++;\n                numThisCluster = 0;\n            }\n            else {\n                if (numThisCluster === 0) // This is the first encounter with a new cluster\n                    result.growablePackedPoints.pushFromGrowableXYZArray(source, k);\n                result.oldToNew[k] = currentClusterIndex;\n                numThisCluster++;\n            }\n        });\n        return result;\n    }\n}\n//  (This is pretty strange)\n// The sort vector is (1,c, c*c, ...)\n// Setting c = 1 makes it 1,1,1 which may be useful for visual scans during debug.\n// c with some non-obvious digits makes it unlikely that there will be multiple points on a perpendicular to the sort vector.\nClusterableArray._vectorFactor = 0.8732; // use 1.0 to rig easy tests.\n/** this value is used as cluster terminator in the Uint232Array of indices. */\nClusterableArray.clusterTerminator = 0xFFffFFff;\nexport { ClusterableArray };\n/**\n * @internal\n */\nfunction updateIndices(indices, oldToNew) {\n    let numErrors = 0;\n    indices.forEach((value, i, data) => {\n        if (value < oldToNew.length) {\n            data[i] = oldToNew[value];\n        }\n        else\n            numErrors++;\n    });\n    return numErrors === 0;\n}\n/**\n * Data carrier class for\n * * packedPoints = an array of Point3d\n * * oldToNew = array of indices from some prior Point3d[] to the packed points.\n * @internal\n */\nclass PackedPointsWithIndex {\n    /** construct a PackedPoints object with\n     * * empty packedPoints array\n     * * oldToNew indices all initialized to PackedPoints.invalidIndex\n     */\n    constructor(numOldIndexEntry) {\n        this.packedPoints = [];\n        this.oldToNew = new Uint32Array(numOldIndexEntry);\n        for (let i = 0; i < numOldIndexEntry; i++) {\n            this.oldToNew[i] = PackedPointsWithIndex.invalidIndex;\n        }\n    }\n    /**\n     * Use the oldToNew array to update an array of \"old\" indices.\n     * @param indices array of indices into prepacked array.\n     * @returns true if all input indices were valid for the oldToNew array.\n     */\n    updateIndices(indices) {\n        return updateIndices(indices, this.oldToNew);\n    }\n}\n/** integer value for unknown index. */\nPackedPointsWithIndex.invalidIndex = 0xFFFFffff;\n/**\n * @internal\n */\nclass PackedPoint2dsWithIndex {\n    /** construct a PackedPoints object with\n     * * empty packedPoints array\n     * * oldToNew indices all initialized to PackedPoints.invalidIndex\n     */\n    constructor(numOldIndexEntry, numPackedPoints) {\n        this.growablePackedPoints = new GrowableXYArray(numPackedPoints);\n        this.oldToNew = new Uint32Array(numOldIndexEntry);\n        for (let i = 0; i < numOldIndexEntry; i++) {\n            this.oldToNew[i] = PackedPoint2dsWithIndex.invalidIndex;\n        }\n    }\n    /**\n     * Use the oldToNew array to update an array of \"old\" indices.\n     * @param indices array of indices into prepacked array.\n     * @returns true if all input indices were valid for the oldToNew array.\n     */\n    updateIndices(indices) {\n        return updateIndices(indices, this.oldToNew);\n    }\n}\n/** integer value for unknown index. */\nPackedPoint2dsWithIndex.invalidIndex = 0xFFFFffff;\n/**\n * @internal\n */\nclass PackedNumbersWithIndex {\n    /** construct a PackedNumbers object with\n     * * empty packedNumbers array\n     * * oldToNew indices all initialized to PackedNumbers.invalidIndex\n     */\n    constructor(numOldIndexEntry) {\n        this.packedNumbers = [];\n        this.oldToNew = new Uint32Array(numOldIndexEntry);\n        for (let i = 0; i < numOldIndexEntry; i++) {\n            this.oldToNew[i] = PackedPointsWithIndex.invalidIndex;\n        }\n    }\n    /**\n     * Use the oldToNew array to update an array of \"old\" indices.\n     * @param indices array of indices into prepacked array.\n     * @returns true if all input indices were valid for the oldToNew array.\n     */\n    updateIndices(indices) {\n        return updateIndices(indices, this.oldToNew);\n    }\n}\n/** integer value for unknown index. */\nPackedNumbersWithIndex.invalidIndex = 0xFFFFffff;\n//# sourceMappingURL=ClusterableArray.js.map",
      "start": 1693508122594,
      "end": 1693508122738,
      "sourcemaps": null
    }
  ]
}
