{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/curve/CurveProcessor.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import { CurvePrimitive } from \"./CurvePrimitive\";\n/* eslint-disable @typescript-eslint/naming-convention, no-empty */\n/** base class for detailed traversal of curve artifacts.\n * * This recurses to children in the quickest way (no records of path)\n * * Use the RecursiveCurveProcessorWithStack to record the path along the visit.\n * @public\n */\nexport class RecursiveCurveProcessor {\n    constructor() {\n    }\n    /** process error content */\n    announceUnexpected(_data, _indexInParent) { }\n    /** process a leaf primitive. */\n    announceCurvePrimitive(_data, _indexInParent = -1) { }\n    /** announce a path (recurse to children) */\n    announcePath(data, _indexInParent = -1) {\n        let i = 0;\n        for (const curve of data.children)\n            this.announceCurvePrimitive(curve, i++);\n    }\n    /** announce a loop (recurse to children) */\n    announceLoop(data, _indexInParent = -1) {\n        let i = 0;\n        for (const curve of data.children)\n            this.announceCurvePrimitive(curve, i++);\n    }\n    /** announce beginning or end of loops in a parity region */\n    announceParityRegion(data, _indexInParent = -1) {\n        let i = 0;\n        for (const loop of data.children)\n            this.announceLoop(loop, i++);\n    }\n    /** announce beginning or end of a parity region */\n    announceUnionRegion(data, _indexInParent = -1) {\n        let i = 0;\n        for (const child of data.children) {\n            child.announceToCurveProcessor(this, i++);\n        }\n    }\n    /** announce a bag of curves.\n     * * The default implementation visits each child and calls the appropriate dispatch to\n     * * `this.announceCurvePrimitive(child)`\n     * * `child.announceToCurveProcessor(this)`\n     */\n    announceBagOfCurves(data, _indexInParent = -1) {\n        for (const child of data.children) {\n            if (child instanceof CurvePrimitive)\n                this.announceCurvePrimitive(child);\n            else\n                child.announceToCurveProcessor(this);\n        }\n    }\n}\n/** base class for detailed traversal of curve artifacts\n * * During recursion,  maintains a stack that shows complete path to each artifact.\n * * Use the QuickRecursiveCurveProcessor to visit without recording the path.\n * @public\n */\nexport class RecursiveCurveProcessorWithStack extends RecursiveCurveProcessor {\n    constructor() {\n        super();\n        this._stack = [];\n    }\n    /** Push `data` onto the stack so its status is available during processing of children.\n     * * Called when `data` is coming into scope.\n     */\n    enter(data) { this._stack.push(data); }\n    /** Pop the stack\n     * * called when the top of the stack goes out of scope\n     */\n    leave() { return this._stack.pop(); }\n    /** process error content */\n    announceUnexpected(_data, _indexInParent) { }\n    /** process a leaf primitive. */\n    announceCurvePrimitive(_data, _indexInParent = -1) { }\n    /** announce a path (recurse to children) */\n    announcePath(data, indexInParent = -1) {\n        this.enter(data);\n        super.announcePath(data, indexInParent);\n        this.leave();\n    }\n    /** announce a loop (recurse to children) */\n    announceLoop(data, indexInParent = -1) {\n        this.enter(data);\n        super.announceLoop(data, indexInParent);\n        this.leave();\n    }\n    /** announce beginning or end of loops in a parity region */\n    announceParityRegion(data, _indexInParent = -1) {\n        this.enter(data);\n        let i = 0;\n        for (const loop of data.children)\n            this.announceLoop(loop, i++);\n        this.leave();\n    }\n    /** announce beginning or end of a parity region */\n    announceUnionRegion(data, indexInParent = -1) {\n        this.enter(data);\n        super.announceUnionRegion(data, indexInParent);\n        this.leave();\n    }\n    /**\n     * Announce members of an unstructured collection.\n     * * push the collection reference on the stack\n     * * announce children\n     * * pop the stack\n     * @param data the collection\n     * @param _indexInParent index where the collection appears in its parent.\n     */\n    announceBagOfCurves(data, _indexInParent = -1) {\n        this.enter(data);\n        let i = 0;\n        for (const child of data.children) {\n            if (child instanceof CurvePrimitive)\n                this.announceCurvePrimitive(child, i++);\n            else\n                child.announceToCurveProcessor(this);\n        }\n        this.leave();\n    }\n}\n//# sourceMappingURL=CurveProcessor.js.map",
      "start": 1693508122746,
      "end": 1693508122902,
      "sourcemaps": null
    }
  ]
}
