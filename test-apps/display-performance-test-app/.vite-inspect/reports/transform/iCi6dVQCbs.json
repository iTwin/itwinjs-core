{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/clipping/ConvexClipPlaneSet.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\nimport { Geometry } from \"../Geometry\";\nimport { GrowableFloat64Array } from \"../geometry3d/GrowableFloat64Array\";\nimport { GrowableXYZArray } from \"../geometry3d/GrowableXYZArray\";\nimport { Matrix3d } from \"../geometry3d/Matrix3d\";\nimport { Plane3dByOriginAndUnitNormal } from \"../geometry3d/Plane3dByOriginAndUnitNormal\";\nimport { Vector3d } from \"../geometry3d/Point3dVector3d\";\nimport { IndexedXYZCollectionPolygonOps, PolygonOps } from \"../geometry3d/PolygonOps\";\nimport { Range1d } from \"../geometry3d/Range\";\nimport { Polyface } from \"../polyface/Polyface\";\nimport { PolyfaceQuery } from \"../polyface/PolyfaceQuery\";\nimport { ClipPlane } from \"./ClipPlane\";\nimport { ClipPlaneContainment, ClipUtilities } from \"./ClipUtils\";\n/**\n * A ConvexClipPlaneSet is a collection of ClipPlanes, often used for bounding regions of space.\n * @public\n */\nclass ConvexClipPlaneSet {\n    // private _parity: number;   <--- Not yet used\n    // public get parity() { return this._parity; }\n    // public set parity(value: number) { this._parity = value; }\n    constructor(planes) {\n        // this._parity = 1;\n        this._planes = planes ? planes : [];\n    }\n    /**\n     * Return an array containing all the planes of the convex set.\n     * * Note that this has no leading keyword identifying it as a ConvexClipPlaneSet.\n     */\n    toJSON() {\n        const val = [];\n        for (const plane of this._planes)\n            val.push(plane.toJSON());\n        return val;\n    }\n    /**\n     * Extract clip planes from a json array `[ clipPlane, clipPlane ]`.\n     * * Non-clipPlane members are ignored.\n     */\n    static fromJSON(json, result) {\n        result = result ? result : new ConvexClipPlaneSet();\n        result._planes.length = 0;\n        if (!Array.isArray(json))\n            return result;\n        for (const thisJson of json) {\n            const plane = ClipPlane.fromJSON(thisJson);\n            if (plane)\n                result._planes.push(plane);\n        }\n        return result;\n    }\n    /**\n     * Return true if all members are almostEqual to corresponding members of other. This includes identical order in array.\n     * @param other clip plane to compare\n     */\n    isAlmostEqual(other) {\n        if (this._planes.length !== other._planes.length)\n            return false;\n        for (let i = 0; i < this._planes.length; i++)\n            if (!this._planes[i].isAlmostEqual(other._planes[i]))\n                return false;\n        return true;\n    }\n    /**\n     * Create ConvexClipPlaneSet from an array of planes.\n     * * Each plane reference in the `planes` array is taken into the result.\n     * * The input array itself is NOT taken into the result.\n     */\n    static createPlanes(planes, result) {\n        result = result ? result : new ConvexClipPlaneSet();\n        for (const plane of planes) {\n            if (plane instanceof ClipPlane) {\n                result._planes.push(plane);\n            }\n            else if (plane instanceof Plane3dByOriginAndUnitNormal) {\n                const clipPlane = ClipPlane.createPlane(plane);\n                result._planes.push(clipPlane);\n            }\n        }\n        return result;\n    }\n    /**\n     * Create new convex set using selected planes of a Range3d.\n     * @param range range with coordinates\n     * @param lowX true to clip at the low x plane\n     * @param highX true to clip at the high x plane\n     * @param lowY true to clip at the low y plane\n     * @param highY true to clip at the high z plane\n     * @param lowZ true to clip at the low z plane\n     * @param highZ true to clip at the high z plane\n     */\n    static createRange3dPlanes(range, lowX = true, highX = true, lowY = true, highY = true, lowZ = true, highZ = true) {\n        const result = ConvexClipPlaneSet.createEmpty();\n        if (lowX)\n            result.planes.push(ClipPlane.createNormalAndPointXYZXYZ(1, 0, 0, range.low.x, 0, 0));\n        if (highX)\n            result.planes.push(ClipPlane.createNormalAndPointXYZXYZ(-1, 0, 0, range.high.x, 0, 0));\n        if (lowY)\n            result.planes.push(ClipPlane.createNormalAndPointXYZXYZ(0, 1, 0, 0, range.low.y, 0));\n        if (highY)\n            result.planes.push(ClipPlane.createNormalAndPointXYZXYZ(0, -1, 0, 0, range.high.y, 0));\n        if (lowZ)\n            result.planes.push(ClipPlane.createNormalAndPointXYZXYZ(0, 0, 1, 0, 0, range.low.z));\n        if (highZ)\n            result.planes.push(ClipPlane.createNormalAndPointXYZXYZ(0, 0, -1, 0, 0, range.high.z));\n        return result;\n    }\n    /** Create an empty `ConvexClipPlaneSet` */\n    static createEmpty(result) {\n        if (result) {\n            result._planes.length = 0;\n            return result;\n        }\n        return new ConvexClipPlaneSet();\n    }\n    /** Negate all planes of the set. */\n    negateAllPlanes() {\n        for (const plane of this._planes)\n            plane.negateInPlace();\n    }\n    /**\n     * Create a convex clip plane set that clips to `x0 <= x <= x1` and `y0 <= y <= y1`.\n     * * Note that there is no test for the usual ordering `x0 <= x1` or `y0 <= y1`.\n     * * if the usual ordering is violated, the convex set is an empty set.\n     * * More details can be found at docs/learning/geometry/Clipping.md\n     */\n    static createXYBox(x0, y0, x1, y1, result) {\n        result = result ? result : new ConvexClipPlaneSet();\n        result._planes.length = 0;\n        const clip0 = ClipPlane.createNormalAndDistance(Vector3d.create(-1, 0, 0), -x1, false, true);\n        const clip1 = ClipPlane.createNormalAndDistance(Vector3d.create(1, 0, 0), x0, false, true);\n        const clip2 = ClipPlane.createNormalAndDistance(Vector3d.create(0, -1, 0), -y1, false, true);\n        const clip3 = ClipPlane.createNormalAndDistance(Vector3d.create(0, 1, 0), y0, false, true);\n        if (clip0 && clip1 && clip2 && clip3) {\n            result._planes.push(clip0, clip1, clip2, clip3);\n        }\n        return result;\n    }\n    /**\n     * Create a convex set containing a half space for each edge between points of a polyline.\n     * * Caller is responsible for assuring the polyline is convex.\n     * @param points array of points. Only xy parts are considered.\n     * @param interior array whose boolean value is used as both the `interior` and `invisible` bits of the plane for the\n     * succeeding segment. If this array is not provided, both are false.\n     * @param leftIsInside if true, the interior is \"to the left\" of the segments. If false, interior is \"to the right\".\n     */\n    static createXYPolyLine(points, interior, leftIsInside, result) {\n        result = result ? result : new ConvexClipPlaneSet();\n        result._planes.length = 0;\n        for (let i0 = 0; (i0 + 1) < points.length; i0++) {\n            const edgeVector = Vector3d.createStartEnd(points[i0], points[i0 + 1]);\n            const perp = edgeVector.unitPerpendicularXY();\n            perp.z = 0.0;\n            if (!leftIsInside)\n                perp.scaleInPlace(-1.0);\n            const perpNormalized = perp.normalize();\n            if (perpNormalized) {\n                const flag = interior !== undefined ? interior[i0] : false;\n                const clip = ClipPlane.createNormalAndPoint(perp, points[i0], flag, flag);\n                if (clip) {\n                    result._planes.push(clip);\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Create a convexClipPlaneSet with planes whose \"inside\" normal is to the left of each segment.\n     * @param points array of points.\n     */\n    static createXYPolyLineInsideLeft(points, result) {\n        result = result ? result : new ConvexClipPlaneSet();\n        result._planes.length = 0;\n        for (let i0 = 0; (i0 + 1) < points.length; i0++) {\n            const edgeVector = Vector3d.createStartEnd(points[i0], points[i0 + 1]);\n            const perp = edgeVector.unitPerpendicularXY();\n            perp.z = 0.0;\n            const perpNormalized = perp.normalize();\n            if (perpNormalized) {\n                const clip = ClipPlane.createNormalAndPoint(perp, points[i0], false, false);\n                if (clip) {\n                    result._planes.push(clip);\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Set (or reset) a plane and ConvexClipPlaneSet for a convex array, such as a convex facet used for xy clip.\n     * * The planeOfPolygon is (re)initialized with the normal from 3 points, but not otherwise referenced.\n     * * The ConvexClipPlaneSet is filled with outward normals of the facet edges as viewed to xy plane.\n     * @param points\n     * @param result\n     */\n    static setPlaneAndXYLoopCCW(points, planeOfPolygon, frustum) {\n        const i0 = points.length - 1;\n        const n = points.length;\n        let x0 = points.getXAtUncheckedPointIndex(i0);\n        let y0 = points.getYAtUncheckedPointIndex(i0);\n        let x1, y1, nx, ny;\n        frustum._planes.length = 0;\n        const z0 = points.getZAtUncheckedPointIndex(i0); // z for planes can stay fixed\n        const planeNormal = points.crossProductIndexIndexIndex(0, 2, 1);\n        ClipPlane.createNormalAndPointXYZXYZ(planeNormal.x, planeNormal.y, planeNormal.z, x0, y0, z0, false, false, planeOfPolygon);\n        if (planeNormal.normalizeInPlace()) {\n            for (let i1 = 0; i1 < n; i1++, x0 = x1, y0 = y1) {\n                x1 = points.getXAtUncheckedPointIndex(i1);\n                y1 = points.getYAtUncheckedPointIndex(i1);\n                nx = -(y1 - y0);\n                ny = x1 - x0;\n                const clipper = ClipPlane.createNormalAndPointXYZXYZ(nx, ny, 0, x1, y1, z0);\n                if (clipper)\n                    frustum._planes.push(clipper);\n            }\n        }\n    }\n    /** Deep clone of all planes. */\n    clone(result) {\n        result = result ? result : new ConvexClipPlaneSet();\n        result._planes.length = 0;\n        for (const plane of this._planes)\n            result._planes.push(plane.clone());\n        return result;\n    }\n    /** Return the (reference to the) array of `ClipPlane` */\n    get planes() {\n        return this._planes;\n    }\n    /**\n     * Test if there is any intersection with a ray defined by origin and direction.\n     * * Optionally record the range (null or otherwise) in caller-allocated result.\n     * * If the ray is unbounded inside the clip, result can contain positive or negative\n     *  \"Geometry.largeCoordinateResult\" values.\n     * * If no result is provide, there are no object allocations.\n     * @param result optional Range1d to receive parameters along the ray.\n     */\n    hasIntersectionWithRay(ray, result, tolerance = Geometry.smallMetricDistance) {\n        // form low and high values in locals that do not require allocation.\n        // transfer to caller-supplied result at end\n        let t0 = -Geometry.largeCoordinateResult;\n        let t1 = Geometry.largeCoordinateResult;\n        if (result)\n            result.setNull();\n        const velocityTolerance = 1.0e-13;\n        for (const plane of this._planes) {\n            const vD = plane.velocity(ray.direction);\n            const vN = plane.altitude(ray.origin);\n            if (Math.abs(vD) <= velocityTolerance) {\n                // Ray is parallel... No need to continue testing if outside halfspace.\n                if (vN < -tolerance)\n                    return false; // and result is a null range.\n            }\n            else {\n                const rayFraction = -vN / vD;\n                if (vD < 0.0) {\n                    if (rayFraction < t1)\n                        t1 = rayFraction;\n                }\n                else {\n                    if (rayFraction > t0)\n                        t0 = rayFraction;\n                }\n            }\n        }\n        if (t1 < t0)\n            return false; // and result is a null range.\n        if (result) {\n            result.extendX(t0);\n            result.extendX(t1);\n        }\n        return true;\n    }\n    /**\n     * Multiply all the ClipPlanes DPoint4d by matrix.\n     * @param matrix matrix to apply.\n     * @param invert if true, use in verse of the matrix.\n     * @param transpose if true, use the transpose of the matrix (or inverse, per invert parameter)\n     * * Note that if matrixA is applied to all of space, the matrix to send to this method to get a corresponding effect\n     * on the plane is the inverse transpose of matrixA.\n     * * Callers that will apply the same matrix to many planes should pre-invert the matrix for efficiency.\n     * * Both params default to true to get the full effect of transforming space.\n     * @param matrix matrix to apply\n     */\n    multiplyPlanesByMatrix4d(matrix, invert = true, transpose = true) {\n        if (invert) { // form inverse once here, reuse for all planes\n            const inverse = matrix.createInverse();\n            if (!inverse)\n                return false;\n            return this.multiplyPlanesByMatrix4d(inverse, false, transpose);\n        }\n        for (const plane of this._planes) {\n            plane.multiplyPlaneByMatrix4d(matrix, false, transpose);\n        }\n        return true;\n    }\n    /** Return true if `point` satisfies `point.isPointInside` for all planes */\n    isPointInside(point) {\n        for (const plane of this._planes) {\n            // Defaults to strict inside check. Other clipping classes may use \"on or inside\" check for the \"on\" case\n            if (!plane.isPointInside(point))\n                return false;\n        }\n        return true;\n    }\n    /** Return true if `point` satisfies `point.isPointOnOrInside` for all planes */\n    isPointOnOrInside(point, tolerance = Geometry.smallMetricDistance) {\n        const interiorTolerance = Math.abs(tolerance); // Interior tolerance should always be positive. (TFS# 246598).\n        for (const plane of this._planes) {\n            if (!plane.isPointOnOrInside(point, (plane.interior ? interiorTolerance : tolerance)))\n                return false;\n        }\n        return true;\n    }\n    /**\n     * Test if a sphere is completely inside the convex set.\n     * @param centerPoint center of sphere\n     * @param radius radius of sphere.\n     */\n    isSphereInside(centerPoint, radius) {\n        const r1 = Math.abs(radius) + Geometry.smallMetricDistance;\n        for (const plane of this._planes) {\n            if (!plane.isPointOnOrInside(centerPoint, r1)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Find the parts of the line segment (if any) that is within the convex clip volume.\n     * * The line segment is defined by `pointA` and `pointB`.\n     * * The input fractional interval from `fraction0` to `fraction1` (increasing) is the active part to consider.\n     * * To clip to the usual bounded line segment, start with fractions (0,1).\n     * If the clip volume is unbounded, the line interval may also be unbounded.\n     * * An unbounded line portion will have fraction coordinates positive or negative `Number.MAX_VALUE`.\n     * @param f0 fraction that is the initial lower fraction of the active interval (e.g., 0.0 for bounded segment).\n     * @param f1 fraction that is the initial upper fraction of the active interval (e.g., 1.0 for bounded segment).\n     * @param pointA segment start (fraction 0)\n     * @param pointB segment end (fraction 1)\n     * @param announce function to be called to announce a fraction interval that is within the convex clip volume.\n     * @returns true if a segment was announced, false if entirely outside.\n     */\n    announceClippedSegmentIntervals(f0, f1, pointA, pointB, announce) {\n        let fraction;\n        if (f1 < f0)\n            return false;\n        for (const plane of this._planes) {\n            const hA = -plane.altitude(pointA);\n            const hB = -plane.altitude(pointB);\n            fraction = Geometry.conditionalDivideFraction(-hA, (hB - hA));\n            if (fraction === undefined) {\n                // Line parallel to the plane. If positive, it is all OUT\n                if (hA > 0.0)\n                    return false;\n            }\n            else if (hB > hA) { // STRICTLY moving outward\n                if (fraction < f0)\n                    return false;\n                if (fraction < f1)\n                    f1 = fraction;\n            }\n            else if (hA > hB) { // STRICTLY moving inward\n                if (fraction > f1)\n                    return false;\n                if (fraction > f0)\n                    f0 = fraction;\n            }\n            else {\n                // Strictly equal evaluations\n                if (hA > 0.0)\n                    return false;\n            }\n        }\n        if (f1 >= f0) {\n            if (announce)\n                announce(f0, f1);\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Find fractional parts of the arc that are within this ClipPlaneSet, and announce each as\n     * * `announce(fraction, fraction, curve)`\n     */\n    announceClippedArcIntervals(arc, announce) {\n        const breaks = ConvexClipPlaneSet._clipArcFractionArray;\n        breaks.clear();\n        for (const clipPlane of this.planes) {\n            clipPlane.appendIntersectionRadians(arc, breaks);\n        }\n        arc.sweep.radiansArrayToPositivePeriodicFractions(breaks);\n        return ClipUtilities.selectIntervals01(arc, breaks, this, announce);\n    }\n    /**\n     * Find the parts of the (unbounded) line segment (if any) that is within the convex clip volume.\n     * @param pointA segment start (fraction 0)\n     * @param pointB segment end (fraction 1)\n     * @param announce function to be called to announce a fraction interval that is within the convex clip volume.\n     * @returns true if a segment was announced, false if entirely outside.\n     */\n    clipUnboundedSegment(pointA, pointB, announce) {\n        return this.announceClippedSegmentIntervals(-Number.MAX_VALUE, Number.MAX_VALUE, pointA, pointB, announce);\n    }\n    /** transform each plane in place. */\n    transformInPlace(transform) {\n        for (const plane of this._planes) {\n            plane.transformInPlace(transform);\n        }\n    }\n    /**\n     * Clip a polygon to the inside of the convex set.\n     * * Results with 2 or fewer points are ignored.\n     * * Other than ensuring capacity in the arrays, there are no object allocations during execution of this function.\n     * @param xyz input points.\n     * @param work work buffer\n     * @param tolerance tolerance for \"on plane\" decision.\n     */\n    clipConvexPolygonInPlace(xyz, work, tolerance = Geometry.smallMetricDistance) {\n        for (const plane of this._planes) {\n            plane.clipConvexPolygonInPlace(xyz, work, true, tolerance);\n            if (xyz.length < 3)\n                return;\n        }\n    }\n    /**\n     * Clip a convex polygon to (a single) inside part and (possibly many) outside parts.\n     * @param xyz input polygon.\n     * @param outsideFragments an array to receive (via push, with no preliminary clear) outside fragments\n     * @param arrayCache cache for work arrays.\n     * @return the surviving inside part (if any)\n     */\n    clipInsidePushOutside(xyz, outsideFragments, arrayCache) {\n        const perpendicularRange = Range1d.createNull();\n        let newInside = arrayCache.grabFromCache();\n        let newOutside = arrayCache.grabFromCache();\n        let insidePart = arrayCache.grabFromCache(); // this is empty ...\n        insidePart.pushFrom(xyz);\n        // While looping through planes . .\n        // the outside part for the current plane is definitely outside and can be stashed to the final outside\n        // the inside part for the current plane passes forward to be further split by the remaining planes.\n        for (const plane of this._planes) {\n            IndexedXYZCollectionPolygonOps.splitConvexPolygonInsideOutsidePlane(plane, insidePart, newInside, newOutside, perpendicularRange);\n            if (newOutside.length > 0) {\n                // the newOutside fragment is definitely outside the ConvexClipPlaneSet\n                if (outsideFragments) // save the definitely outside part as return data.\n                    ClipUtilities.captureOrDrop(newOutside, 3, outsideFragments, arrayCache);\n                newOutside = arrayCache.grabFromCache();\n                if (newInside.length === 0) {\n                    insidePart.length = 0;\n                    break;\n                }\n                // insideWork is changed ... swap it with insidePart\n                arrayCache.dropToCache(insidePart);\n                insidePart = newInside;\n                newInside = arrayCache.grabFromCache();\n            }\n            // outside clip was empty .. insideWork is identical to insidePart .. let insidePart feed through to the next clipper.\n        }\n        // at break or fall out ...\n        // ALWAYS drop `newInside` and `newOutside` to the cache\n        arrayCache.dropToCache(newInside);\n        arrayCache.dropToCache(newOutside);\n        // if `insidePart` is alive, return it to caller.  Otherwise drop it to cache and return undefined.\n        if (insidePart.length > 0)\n            return insidePart;\n        arrayCache.dropToCache(insidePart);\n        return undefined;\n    }\n    /**\n     * Returns 1, 2, or 3 based on whether point array is strongly inside, ambiguous, or strongly outside respectively.\n     * * This has a peculiar expected use case as a very fast pre-filter for more precise clipping.\n     * * The expected point set is for a polygon.\n     * * Hence any clipping will eventually have to consider the lines between the points.\n     * * This method looks for the special case of a single clip plane that has all the points outside.\n     * * In this case the whole polygon must be outside.\n     * * Note that this does not detect a polygon that is outside but \"crosses a corner\" -- it is mixed with respect to\n     * multiple planes.\n     */\n    classifyPointContainment(points, onIsOutside) {\n        let allInside = true;\n        const onTolerance = onIsOutside ? 1.0e-8 : -1.0e-8;\n        const interiorTolerance = 1.0e-8; // Interior tolerance should always be positive\n        for (const plane of this._planes) {\n            let nOutside = 0;\n            for (const point of points) {\n                if (plane.altitude(point) < (plane.interior ? interiorTolerance : onTolerance)) {\n                    nOutside++;\n                    allInside = false;\n                }\n            }\n            if (nOutside === points.length)\n                return ClipPlaneContainment.StronglyOutside;\n        }\n        return allInside ? ClipPlaneContainment.StronglyInside : ClipPlaneContainment.Ambiguous;\n    }\n    /**\n     * * Create a convex clip set for a polygon swept with possible tilt angle.\n     * * planes are constructed by ClipPlane.createEdgeAndUpVector, using successive points from the array.\n     * * If the first and last points match, the polygon area is checked.  If the area is negative, points are used in\n     * reverse order.\n     * * If first and last points do not match, points are used in order given\n     * @param points polygon points. (Closure point optional)\n     * @param upVector primary sweep direction, as applied by ClipPlane.createEdgeAndUpVector\n     * @param tiltAngle angle to tilt sweep planes away from the sweep direction.\n     */\n    static createSweptPolyline(points, upVector, tiltAngle) {\n        const result = ConvexClipPlaneSet.createEmpty();\n        let reverse = false;\n        if (points.length > 3 && points[0].isAlmostEqual(points[points.length - 1])) {\n            const polygonNormal = PolygonOps.areaNormal(points);\n            const normalDot = polygonNormal.dotProduct(upVector);\n            if (normalDot > 0.0)\n                reverse = true;\n        }\n        for (let i = 0; (i + 1) < points.length; i++) {\n            if (reverse) {\n                const toAdd = ClipPlane.createEdgeAndUpVector(points[i + 1], points[i], upVector, tiltAngle);\n                if (toAdd) { // clipPlane creation could result in undefined\n                    result.addPlaneToConvexSet(toAdd);\n                }\n                else {\n                    return undefined;\n                }\n            }\n            else {\n                const toAdd = ClipPlane.createEdgeAndUpVector(points[i], points[i + 1], upVector, tiltAngle);\n                if (toAdd) { // clipPlane creation could result in undefined\n                    result.addPlaneToConvexSet(toAdd);\n                }\n                else {\n                    return undefined;\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Add a plane to the convex set.\n     * @param plane plane to add\n     */\n    addPlaneToConvexSet(plane) {\n        if (plane instanceof ClipPlane)\n            this._planes.push(plane);\n        else if (plane instanceof Plane3dByOriginAndUnitNormal)\n            this._planes.push(ClipPlane.createPlane(plane));\n    }\n    /**\n     * Test many points. Distribute them to arrays depending on in/out result.\n     * @param points points to test\n     * @param inOrOn points that are in or on the set\n     * @param out points that are out.\n     */\n    clipPointsOnOrInside(points, inOrOn, out) {\n        inOrOn.length = 0;\n        out.length = 0;\n        for (const xyz of points) {\n            if (this.isPointOnOrInside(xyz, 0.0)) {\n                inOrOn.push(xyz);\n            }\n            else {\n                out.push(xyz);\n            }\n        }\n    }\n    /**\n     * Clip a polygon to the planes of the clip plane set.\n     * * For a convex input polygon, the output is another convex polygon.\n     * * For a non-convex input, the output may have double-back edges along plane intersections. This is still a\n     * valid clip in a parity sense.\n     * * The containingPlane parameter allows callers within ConvexClipPlane set to bypass planes known to contain\n     * the polygon.\n     * @param input polygon, usually convex.\n     * @param output output polygon\n     * @param work work array.\n     * @param containingPlane if this plane is found in the convex set, it is NOT applied.\n     */\n    polygonClip(input, output, work, planeToSkip) {\n        if (input instanceof GrowableXYZArray)\n            input.clone(output);\n        else\n            GrowableXYZArray.create(input, output);\n        for (const plane of this._planes) {\n            if (planeToSkip === plane)\n                continue;\n            if (output.length === 0)\n                break;\n            plane.clipConvexPolygonInPlace(output, work);\n        }\n    }\n    /**\n     * * Define new planes in this ConvexClipPlaneSet so it clips to the inside of a polygon.\n     * * always create planes for the swept edges of the polygon\n     * * optionally (with nonzero sideSelect) create a cap plane using the polygon normal.\n     * @param points Points of a bounding polygon\n     * @param sweepDirection direction to sweep.\n     * @param sideSelect 0 to have no cap polygon, 1 if the sweep vector side is in, -1 if sweep vector side is out.\n     */\n    reloadSweptPolygon(points, sweepDirection, sideSelect) {\n        this._planes.length = 0;\n        const n = points.length;\n        if (n <= 2)\n            return 0;\n        const planeNormal = PolygonOps.areaNormal(points);\n        const isCCW = sweepDirection.dotProduct(planeNormal) > 0.0;\n        const delta = isCCW ? 1 : n - 1;\n        for (let i = 0; i < n; i++) {\n            const i1 = (i + delta) % n;\n            const xyz0 = points[i];\n            const xyz1 = points[i1];\n            if (xyz0.isAlmostEqual(xyz1))\n                continue;\n            const edgeVector = Vector3d.createStartEnd(xyz0, xyz1);\n            const inwardNormal = Vector3d.createCrossProduct(sweepDirection.x, sweepDirection.y, sweepDirection.z, edgeVector.x, edgeVector.y, edgeVector.z);\n            const inwardNormalNormalized = inwardNormal.normalize();\n            let distance;\n            if (inwardNormalNormalized) { // should never fail... simply a check due to the format of the normalize function return\n                distance = inwardNormalNormalized.dotProduct(xyz0);\n                const clipToAdd = ClipPlane.createNormalAndDistance(inwardNormalNormalized, distance, false, false);\n                if (clipToAdd) {\n                    this._planes.push(clipToAdd);\n                } // clipPlane creation could result in undefined\n            }\n        }\n        if (sideSelect !== 0.0) {\n            let planeNormalNormalized = planeNormal.normalize();\n            if (planeNormalNormalized) { // Again.. should never fail\n                const a = sweepDirection.dotProduct(planeNormalNormalized) * sideSelect;\n                if (a < 0.0)\n                    planeNormalNormalized = planeNormalNormalized.negate();\n                const xyz0 = points[0];\n                const distance = planeNormalNormalized.dotProduct(xyz0);\n                const clipToAdd = ClipPlane.createNormalAndDistance(planeNormalNormalized, distance, false, false);\n                if (clipToAdd) {\n                    this._planes.push(clipToAdd);\n                } // clipPlane creation could result in undefined\n            }\n        }\n        return isCCW ? 1 : -1;\n    }\n    /**\n     * Compute intersections among all combinations of 3 planes in the convex set.\n     * * optionally throw out points that are not in the set.\n     * * optionally push the points in the caller-supplied point array.\n     * * optionally extend a caller supplied range.\n     * * In the common case where the convex set is (a) a slab or (b) a view frustum, there will be 8 points and the\n     * range is the range of the convex set.\n     * * If the convex set is unbounded, the range only contains the range of the accepted (corner) points, and the\n     * range is not a representative of the \"range of all points in the set\".\n     * @param transform (optional) transform to apply to the points.\n     * @param points (optional) array to which computed points are to be added.\n     * @param range (optional) range to be extended by the computed points\n     * @param transform (optional) transform to apply to the accepted points.\n     * @param testContainment if true, test each point to see if it is within the convex set. (send false if confident\n     * that the convex set is rectilinear set such as a slab. Send true if chiseled corners are possible).\n     * @returns number of points.\n     */\n    computePlanePlanePlaneIntersections(points, rangeToExtend, transform, testContainment = true) {\n        const normalRows = Matrix3d.createIdentity();\n        const allPlanes = this._planes;\n        const n = allPlanes.length;\n        let numPoints = 0; // explicitly count points -- can't wait to end for points.length because it may be an optional output.\n        for (let i = 0; i < n; i++) {\n            for (let j = i + 1; j < n; j++)\n                for (let k = j + 1; k < n; k++) {\n                    Matrix3d.createRowValues(allPlanes[i].inwardNormalRef.x, allPlanes[i].inwardNormalRef.y, allPlanes[i].inwardNormalRef.z, allPlanes[j].inwardNormalRef.x, allPlanes[j].inwardNormalRef.y, allPlanes[j].inwardNormalRef.z, allPlanes[k].inwardNormalRef.x, allPlanes[k].inwardNormalRef.y, allPlanes[k].inwardNormalRef.z, normalRows);\n                    if (normalRows.computeCachedInverse(false)) {\n                        const xyz = normalRows.multiplyInverseXYZAsPoint3d(allPlanes[i].distance, allPlanes[j].distance, allPlanes[k].distance);\n                        if (!testContainment || this.isPointOnOrInside(xyz, Geometry.smallMetricDistance)) {\n                            numPoints++;\n                            if (transform)\n                                transform.multiplyPoint3d(xyz, xyz);\n                            if (points)\n                                points.push(xyz);\n                            if (rangeToExtend)\n                                rangeToExtend.extendPoint(xyz);\n                        }\n                    }\n                }\n        }\n        return numPoints;\n    }\n    /**\n     * Set the `invisible` property on each plane of the convex set.\n     * @param invisible value to store\n     */\n    setInvisible(invisible) {\n        for (const plane of this._planes) {\n            plane.setInvisible(invisible);\n        }\n    }\n    /**\n     * Add planes for z-direction clip between low and high z levels.\n     * @param invisible value to apply to the `invisible` bit for the new planes\n     * @param zLow low z value.  The plane clips out points with z below this.\n     * @param zHigh high z value.  The plane clips out points with z above this.\n     */\n    addZClipPlanes(invisible, zLow, zHigh) {\n        if (zLow !== undefined)\n            this._planes.push(ClipPlane.createNormalAndDistance(Vector3d.create(0, 0, 1), zLow, invisible));\n        if (zHigh !== undefined)\n            this._planes.push(ClipPlane.createNormalAndDistance(Vector3d.create(0, 0, -1), -zHigh, invisible));\n    }\n    /**\n     * Implement appendPolygonClip, as defined in interface PolygonClipper.\n     * @param xyz convex polygon.  This is not changed.\n     * @param insideFragments Array to receive \"inside\" fragments. Each fragment is a GrowableXYZArray grabbed from\n     * the cache. This is NOT cleared.\n     * @param outsideFragments Array to receive \"outside\" fragments. Each fragment is a GrowableXYZArray grabbed from\n     * the cache. This is NOT cleared.\n     * @param arrayCache cache for reusable GrowableXYZArray.\n     */\n    appendPolygonClip(xyz, insideFragments, outsideFragments, arrayCache) {\n        const newInside = this.clipInsidePushOutside(xyz, outsideFragments, arrayCache);\n        if (newInside)\n            insideFragments.push(newInside);\n    }\n    /**\n     * Create a convex clip set from a convex mesh.\n     * * Create a plane for each facet.\n     * * Assemble the planes as a single clip plane set.\n     * * If the facets are closed by edge pairing, use the sign of the computed volume to point the plane normals inward.\n     * * If the facets are not closed, the facet orientation determines plane orientation.\n     * * The implication of this is that if the facets are a convex volume, the returned clip plane set is convex.\n     * @param convexMesh input mesh. For best results, the mesh should be closed and convex.\n     * @param result optional preallocated result to reuse and return\n     * @return clipper and volume (zero if mesh is not closed)\n    */\n    static createConvexPolyface(convexMesh, result) {\n        result = this.createEmpty(result);\n        let vol = 0;\n        let myMesh;\n        let myVisitor;\n        if (convexMesh instanceof Polyface) {\n            myMesh = convexMesh;\n            myVisitor = convexMesh.createVisitor(0);\n        }\n        else {\n            myMesh = convexMesh.clientPolyface();\n            myVisitor = convexMesh;\n        }\n        if (myMesh && myVisitor) {\n            if (PolyfaceQuery.isPolyfaceClosedByEdgePairing(myMesh))\n                vol = PolyfaceQuery.sumTetrahedralVolumes(myVisitor);\n            const scale = vol > 0.0 ? -1.0 : 1.0; // point clipper normals inward if mesh normals point outward\n            const normal = Vector3d.create();\n            const plane = Plane3dByOriginAndUnitNormal.createXYPlane();\n            myVisitor.reset();\n            while (myVisitor.moveToNextFacet()) {\n                if (undefined !== PolygonOps.areaNormalGo(myVisitor.point, normal)) {\n                    normal.scaleInPlace(scale);\n                    if (undefined !== Plane3dByOriginAndUnitNormal.create(myVisitor.point.front(), normal, plane))\n                        result.addPlaneToConvexSet(plane);\n                }\n            }\n        }\n        return { clipper: result, volume: vol };\n    }\n}\n/** Value acting as \"at infinity\" for coordinates along a ray. */\nConvexClipPlaneSet.hugeVal = 1e37;\nConvexClipPlaneSet._clipArcFractionArray = new GrowableFloat64Array();\nexport { ConvexClipPlaneSet };\n//# sourceMappingURL=ConvexClipPlaneSet.js.map",
      "start": 1693508122484,
      "end": 1693508122647,
      "sourcemaps": null
    }
  ]
}
