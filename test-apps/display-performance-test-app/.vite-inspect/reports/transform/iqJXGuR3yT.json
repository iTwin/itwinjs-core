{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/polyface/PolyfaceClip.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Polyface\n */\n// import { Point2d } from \"./Geometry2d\";\n/* eslint-disable @typescript-eslint/naming-convention, no-empty */\nimport { ClipPlane } from \"../clipping/ClipPlane\";\nimport { ConvexClipPlaneSet } from \"../clipping/ConvexClipPlaneSet\";\nimport { UnionOfConvexClipPlaneSets } from \"../clipping/UnionOfConvexClipPlaneSets\";\nimport { LineString3d } from \"../curve/LineString3d\";\nimport { Loop } from \"../curve/Loop\";\nimport { RegionBinaryOpType, RegionOps } from \"../curve/RegionOps\";\nimport { UnionRegion } from \"../curve/UnionRegion\";\nimport { FrameBuilder } from \"../geometry3d/FrameBuilder\";\nimport { GrowableXYZArray } from \"../geometry3d/GrowableXYZArray\";\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\nimport { IndexedXYZCollectionPolygonOps, PolygonOps } from \"../geometry3d/PolygonOps\";\nimport { Range1d, Range3d } from \"../geometry3d/Range\";\nimport { GrowableXYZArrayCache } from \"../geometry3d/ReusableObjectCache\";\nimport { SweepContour } from \"../solid/SweepContour\";\nimport { ChainMergeContext } from \"../topology/ChainMerge\";\nimport { RangeSearch } from \"./multiclip/RangeSearch\";\nimport { PolyfaceBuilder } from \"./PolyfaceBuilder\";\nimport { PolyfaceQuery } from \"./PolyfaceQuery\";\n/**\n * carrier for a point array with an index into UnionOfConvexClipPlaneSets\n * @private\n */\nclass ClipCandidate {\n    constructor(points, nextConvexSetIndex) {\n        this.nextConvexSetIndex = nextConvexSetIndex;\n        this.points = points;\n    }\n}\n/**\n * A pair of PolyfaceBuilder objects, for use by clippers that emit inside and outside parts.\n * * There are nominally 4 builders:\n *   * builderA collects simple \"inside\" clip.\n *   * builderB collects simple \"outside\" clip.\n *   * builderA1 collects \"side\" clip for inside.\n *   * builderB1 collets \"side\" clip for outside.\n * * `static ClippedPolyfaceBuilders.create(keepInside, keepOutside)` initializes `builderA` and `builderB` (each optionally to undefined), with undefined `builderA1` and `builderB1`\n * * `builders.enableSideBuilders()` makes `builderA1` and `builderB1` match `builderA` and `builderB`.\n * * construction methods aim their facets at appropriate builders if defined.\n * * @public\n */\nexport class ClippedPolyfaceBuilders {\n    constructor(builderA, builderB, buildClosureFaces = false) {\n        this.builderA = builderA;\n        this.builderB = builderB;\n        this.buildClosureFaces = buildClosureFaces;\n    }\n    /** Simple create with default options on builder. */\n    static create(keepInside = true, keepOutside = false, buildSideFaces = false) {\n        return new ClippedPolyfaceBuilders(keepInside ? PolyfaceBuilder.create() : undefined, keepOutside ? PolyfaceBuilder.create() : undefined, buildSideFaces);\n    }\n    claimPolyface(selector, fixup) {\n        const builder = selector === 0 ? this.builderA : this.builderB;\n        if (builder) {\n            let polyface = builder.claimPolyface();\n            if (fixup) {\n                polyface = PolyfaceQuery.cloneWithTVertexFixup(polyface);\n            }\n            return polyface;\n        }\n        return undefined;\n    }\n}\n/** PolyfaceClip is a static class gathering operations using Polyfaces and clippers.\n * @public\n */\nexport class PolyfaceClip {\n    /** Clip each facet of polyface to the ClipPlane.\n     * * Return all surviving clip as a new mesh.\n     * * WARNING: The new mesh is \"points only\" -- parameters, normals, etc are not interpolated\n     */\n    static clipPolyfaceClipPlaneWithClosureFace(polyface, clipper, insideClip = true, buildClosureFaces = true) {\n        return this.clipPolyfaceClipPlane(polyface, clipper, insideClip, buildClosureFaces);\n    }\n    /** Clip each facet of polyface to the ClipPlane.\n     * * Return all surviving clip as a new mesh.\n     * * WARNING: The new mesh is \"points only\" -- parameters, normals, etc are not interpolated\n     */\n    static clipPolyfaceClipPlane(polyface, clipper, insideClip = true, buildClosureFaces = false) {\n        const builders = ClippedPolyfaceBuilders.create(insideClip, !insideClip, buildClosureFaces);\n        this.clipPolyfaceInsideOutside(polyface, clipper, builders);\n        return builders.claimPolyface(insideClip ? 0 : 1, true);\n    }\n    /** Clip each facet of polyface to the ClipPlane.\n     * * Return surviving clip as a new mesh.\n     * * WARNING: The new mesh is \"points only\".\n     */\n    static clipPolyfaceConvexClipPlaneSet(polyface, clipper) {\n        const visitor = polyface.createVisitor(0);\n        const builder = PolyfaceBuilder.create();\n        const work = new GrowableXYZArray(10);\n        for (visitor.reset(); visitor.moveToNextFacet();) {\n            clipper.clipConvexPolygonInPlace(visitor.point, work);\n            if (visitor.point.length > 2)\n                builder.addPolygonGrowableXYZArray(visitor.point);\n        }\n        return builder.claimPolyface(true);\n    }\n    /** Clip each facet of polyface to the the clippers.\n     * * Add inside, outside fragments to builderA, builderB\n     * * This does not consider params, normals, colors.  Just points.\n     * * outputSelect determines how the clip output is structured\n     *   * 0 outputs all shards -- this may have many interior edges.\n     *   * 1 stitches shards together to get cleaner facets.\n     * @internal\n     */\n    static clipPolyfaceUnionOfConvexClipPlaneSetsToBuilders(polyface, allClippers, destination, outputSelector = 1) {\n        const builderA = destination.builderA;\n        const builderB = destination.builderB;\n        const visitor = polyface.createVisitor(0);\n        const cache = new GrowableXYZArrayCache();\n        const insideShards = [];\n        const outsideShards = [];\n        const residualPolygons = [];\n        let candidate;\n        const outsideParts = [];\n        const numConvexSet = allClippers.convexSets.length;\n        for (visitor.reset(); visitor.moveToNextFacet();) {\n            residualPolygons.push(new ClipCandidate(cache.grabAndFill(visitor.point), 0));\n            while ((candidate = residualPolygons.pop()) !== undefined) {\n                const convexSetIndex = candidate.nextConvexSetIndex;\n                if (convexSetIndex >= numConvexSet) {\n                    // ths remnant polygon is OUT ...\n                    if (candidate.points.length > 2)\n                        outsideShards.push(candidate.points);\n                }\n                else {\n                    const clipper = allClippers.convexSets[convexSetIndex];\n                    outsideParts.length = 0; //  NO NO -- why isn't it empty from prior step cleanup?\n                    const insidePart = clipper.clipInsidePushOutside(candidate.points, outsideParts, cache);\n                    if (insidePart) {\n                        if (insidePart.length > 2)\n                            insideShards.push(insidePart);\n                        // Keep outside parts active for clip by later facets . . .\n                        for (const outsidePolygon of outsideParts) {\n                            residualPolygons.push(new ClipCandidate(outsidePolygon, convexSetIndex + 1));\n                        }\n                    }\n                    else {\n                        // Nothing was insidePart.  The outside parts might be split by intermediate steps -- but all the pieces are there.\n                        candidate.nextConvexSetIndex++;\n                        residualPolygons.push(candidate);\n                    }\n                    outsideParts.length = 0;\n                }\n            }\n            if (outsideShards.length === 0) {\n                builderA?.addPolygonGrowableXYZArray(visitor.point);\n            }\n            else if (insideShards.length === 0) {\n                // the facet spanned clippers but is intact outside\n                builderB?.addPolygonGrowableXYZArray(visitor.point);\n            }\n            else {\n                const localToWorld = FrameBuilder.createRightHandedFrame(undefined, visitor.point);\n                let worldToLocal;\n                if (outputSelector === 1 && localToWorld !== undefined\n                    && undefined !== (worldToLocal = localToWorld.inverse())) {\n                    this.cleanupAndAddRegion(builderA, insideShards, worldToLocal, localToWorld);\n                    this.cleanupAndAddRegion(builderB, outsideShards, worldToLocal, localToWorld);\n                }\n                else {\n                    for (const shard of insideShards)\n                        this.addPolygonToBuilderAndDropToCache(shard, builderA, cache);\n                    for (const shard of outsideShards)\n                        this.addPolygonToBuilderAndDropToCache(shard, builderB, cache);\n                }\n            }\n            outsideShards.length = 0;\n            insideShards.length = 0;\n        }\n        cache.dropAllToCache(outsideParts);\n        if (destination.buildClosureFaces) {\n            for (const clipper of allClippers.convexSets) {\n                this.buildClosureFacesForConvexSet(visitor, clipper, destination, cache);\n            }\n        }\n    }\n    static addRegion(builder, region) {\n        if (builder !== undefined && region !== undefined) {\n            if (region instanceof Loop && region.children.length === 1 && region.children[0] instanceof LineString3d) {\n                builder.addPolygonGrowableXYZArray(region.children[0].packedPoints);\n            }\n            else if (region instanceof UnionRegion) {\n                for (const child of region.children)\n                    this.addRegion(builder, child);\n            }\n        }\n    }\n    // WARNING: shards are transformed into local system, not reverted!!!\n    static cleanupAndAddRegion(builder, shards, worldToLocal, localToWorld) {\n        if (builder !== undefined && shards.length > 0) {\n            if (worldToLocal)\n                GrowableXYZArray.multiplyTransformInPlace(worldToLocal, shards);\n            const outsidePieces = RegionOps.polygonBooleanXYToLoops(shards, RegionBinaryOpType.Union, []);\n            if (outsidePieces && outsidePieces.children.length > 0) {\n                if (localToWorld)\n                    outsidePieces.tryTransformInPlace(localToWorld);\n                RegionOps.consolidateAdjacentPrimitives(outsidePieces);\n                this.addRegion(builder, outsidePieces);\n            }\n        }\n    }\n    static addPolygonToBuilderAndDropToCache(polygon, builder, cache) {\n        if (polygon) {\n            if (builder)\n                builder.addPolygonGrowableXYZArray(polygon);\n            cache.dropToCache(polygon);\n        }\n    }\n    static addPolygonArrayToBuilderAndDropToCache(polygonArray, builder, cache) {\n        let polygon;\n        while ((polygon = polygonArray.pop()) !== undefined) {\n            this.addPolygonToBuilderAndDropToCache(polygon, builder, cache);\n        }\n    }\n    static createChainContextsForConvexClipPlaneSet(clipper) {\n        const chainContexts = [];\n        for (const plane of clipper.planes) {\n            if (!plane.interior) {\n                const c = ChainMergeContext.create();\n                c.plane = plane;\n                c.convexClipper = clipper;\n                chainContexts.push(c);\n            }\n        }\n        return chainContexts;\n    }\n    /** Clip each facet of polyface to the the clippers.\n   * * Add inside, outside fragments to builderA, builderB\n   * * This does not consider params, normals, colors.  Just points.\n   * @internal\n   */\n    static clipPolyfaceConvexClipPlaneSetToBuilders(polyface, clipper, destination) {\n        const builderA = destination.builderA;\n        const builderB = destination.builderB;\n        const visitor = polyface.createVisitor(0);\n        const cache = new GrowableXYZArrayCache();\n        const outsideParts = [];\n        for (visitor.reset(); visitor.moveToNextFacet();) {\n            // !!! currentCandidates and next candidates are empty at this point !!!\n            const insidePart = clipper.clipInsidePushOutside(visitor.point, outsideParts, cache);\n            if (insidePart === undefined) {\n                // everything is out ... outsideParts might be fragmented.  Save only the original polygon\n                builderB?.addPolygonGrowableXYZArray(visitor.point);\n                cache.dropToCache(insidePart);\n                cache.dropAllToCache(outsideParts);\n            }\n            this.addPolygonToBuilderAndDropToCache(insidePart, builderA, cache);\n            this.addPolygonArrayToBuilderAndDropToCache(outsideParts, builderB, cache);\n        }\n        this.buildClosureFacesForConvexSet(visitor, clipper, destination, cache);\n    }\n    /**\n     *\n     * @param visitor visitor for all facets of interest (entire polyface)\n     * @param clipper ConvexClipPlaneSet to apply\n     * @param destination builders to receive inside, outside parts\n     * @param cache GrowableArray cache.\n     */\n    static buildClosureFacesForConvexSet(visitor, clipper, destination, cache) {\n        if (destination.buildClosureFaces) {\n            const chainContexts = this.createChainContextsForConvexClipPlaneSet(clipper);\n            const workPoints = cache.grabFromCache();\n            const facetPoints = cache.grabFromCache();\n            for (visitor.reset(); visitor.moveToNextFacet();) {\n                for (const chainContext of chainContexts) {\n                    const plane = chainContext.plane;\n                    facetPoints.clear();\n                    facetPoints.pushFrom(visitor.point);\n                    IndexedXYZCollectionPolygonOps.clipConvexPolygonInPlace(plane, facetPoints, workPoints);\n                    chainContext.addSegmentsOnPlane(facetPoints, true);\n                }\n            }\n            cache.dropToCache(facetPoints);\n            cache.dropToCache(workPoints);\n            for (const chainContext of chainContexts) {\n                this.addClosureFacets(chainContext, destination, cache);\n            }\n        }\n    }\n    /**\n     *\n     * @param visitor visitor for all facets of interest (entire polyface)\n     * @param clipper ConvexClipPlaneSet to apply\n     * @param destination builders to receive inside, outside parts\n     * @param cache GrowableArray cache.\n     */\n    static buildClosureFacesForPlane(visitor, plane, destination, cache) {\n        if (destination.buildClosureFaces) {\n            const chainContext = ChainMergeContext.create();\n            chainContext.plane = plane;\n            const workPoints = cache.grabFromCache();\n            const facetPoints = cache.grabFromCache();\n            for (visitor.reset(); visitor.moveToNextFacet();) {\n                facetPoints.clear();\n                facetPoints.pushFrom(visitor.point);\n                IndexedXYZCollectionPolygonOps.clipConvexPolygonInPlace(plane, facetPoints, workPoints);\n                chainContext.addSegmentsOnPlane(facetPoints, true);\n            }\n            cache.dropToCache(facetPoints);\n            cache.dropToCache(workPoints);\n            this.addClosureFacets(chainContext, destination, cache);\n        }\n    }\n    static evaluateInwardPlaneNormal(plane, scale) {\n        return Vector3d.create(plane.velocityXYZ(scale, 0, 0), plane.velocityXYZ(0, scale, 0), plane.velocityXYZ(0, 0, scale));\n    }\n    /**\n     * * Triangulate the contour.\n     * * Add all the triangles to both builders\n     * * reversed in builderB.\n     */\n    static addClippedContour(contour, clipper, destination, cache) {\n        const polygonA = cache.grabFromCache();\n        const polygonB = cache.grabFromCache();\n        if (destination.builderB)\n            destination.builderB.toggleReversedFacetFlag();\n        contour.announceFacets((facets) => {\n            const visitor = facets.createVisitor();\n            // The contour facets are convex .. easy clip ..\n            for (visitor.reset(); visitor.moveToNextFacet();) {\n                polygonA.clear();\n                polygonA.pushFromGrowableXYZArray(visitor.point);\n                clipper?.clipConvexPolygonInPlace(polygonA, polygonB);\n                if (polygonA.length > 2) {\n                    destination.builderA?.addPolygonGrowableXYZArray(polygonA);\n                    destination.builderB?.addPolygonGrowableXYZArray(polygonA);\n                }\n            }\n        }, undefined);\n        if (destination.builderB)\n            destination.builderB.toggleReversedFacetFlag();\n        cache.dropToCache(polygonA);\n        cache.dropToCache(polygonB);\n    }\n    /**\n     * Gather loops out of the ChainMergeContext.  Add to destination arrays.\n     * @param chainContext ASSUMED TO HAVE A PLANE\n     * @param destination\n     */\n    static addClosureFacets(chainContext, destination, cache) {\n        const clipper = chainContext.convexClipper;\n        const plane = chainContext.plane;\n        const outwardNormal = this.evaluateInwardPlaneNormal(plane, -1.0);\n        chainContext.clusterAndMergeVerticesXYZ();\n        const loops = chainContext.collectMaximalGrowableXYZArrays();\n        if (loops.length > 1) {\n            const loopSets = PolygonOps.sortOuterAndHoleLoops(loops, outwardNormal);\n            for (const loopSet of loopSets) {\n                PolygonOps.orientLoopsCCWForOutwardNormalInPlace(loopSet, outwardNormal);\n                const contour = SweepContour.createForPolygon(loopSet, outwardNormal);\n                if (contour !== undefined) {\n                    if (clipper) {\n                        this.addClippedContour(contour, clipper, destination, cache);\n                    }\n                    else {\n                        if (destination.builderA)\n                            contour.emitFacets(destination.builderA, true, clipper);\n                        if (destination.builderB)\n                            contour.emitFacets(destination.builderB, false, clipper);\n                    }\n                }\n            }\n        }\n        else {\n            PolygonOps.orientLoopsCCWForOutwardNormalInPlace(loops, outwardNormal);\n            const contour = SweepContour.createForPolygon(loops, outwardNormal);\n            if (contour !== undefined) {\n                if (clipper) {\n                    this.addClippedContour(contour, clipper, destination, cache);\n                }\n                else {\n                    if (destination.builderA)\n                        contour.emitFacets(destination.builderA, true, clipper);\n                    if (destination.builderB)\n                        contour.emitFacets(destination.builderB, false, clipper);\n                }\n            }\n        }\n    }\n    /** Clip each facet of polyface to the the clippers.\n     * * Add inside, outside fragments to builderA, builderB\n     * * This does not consider params, normals, colors.  Just points.\n     * @internal\n     */\n    static clipPolyfaceClipPlaneToBuilders(polyface, clipper, destination) {\n        const builderA = destination.builderA;\n        const builderB = destination.builderB;\n        const visitor = polyface.createVisitor(0);\n        const cache = new GrowableXYZArrayCache();\n        const inside = cache.grabFromCache();\n        const outside = cache.grabFromCache();\n        const range = Range1d.createNull();\n        for (visitor.reset(); visitor.moveToNextFacet();) {\n            // !!! currentCandidates and next candidates are empty at this point !!!\n            IndexedXYZCollectionPolygonOps.splitConvexPolygonInsideOutsidePlane(clipper, visitor.point, inside, outside, range);\n            if (builderA)\n                builderA.addPolygonGrowableXYZArray(inside);\n            if (builderB)\n                builderB.addPolygonGrowableXYZArray(outside);\n        }\n        this.buildClosureFacesForPlane(visitor, clipper, destination, cache);\n        cache.dropToCache(inside);\n        cache.dropToCache(outside);\n    }\n    /** Clip each facet of polyface to the ClipPlane or ConvexClipPlaneSet\n     * * accumulate inside and outside facets -- to destination.builderA and destination.builderB\n     * * if `destination.buildClosureFaces` is set, and also build closure facets\n     * * This method parses  the variant input types and calls a more specific method.\n     * * WARNING: The new mesh is \"points only\".\n     * * outputSelect applies only for UnionOfConvexClipPlaneSets -- see [[PolyfaceClip.clipPolyfaceUnionOfConvexClipPlaneSetsToBuilders]]\n     */\n    static clipPolyfaceInsideOutside(polyface, clipper, destination, outputSelect = 0) {\n        if (clipper instanceof ClipPlane) {\n            this.clipPolyfaceClipPlaneToBuilders(polyface, clipper, destination);\n        }\n        else if (clipper instanceof ConvexClipPlaneSet) {\n            this.clipPolyfaceConvexClipPlaneSetToBuilders(polyface, clipper, destination);\n        }\n        else if (clipper instanceof UnionOfConvexClipPlaneSets) {\n            this.clipPolyfaceUnionOfConvexClipPlaneSetsToBuilders(polyface, clipper, destination, outputSelect);\n        }\n    }\n    /** Clip each facet of polyface to the ClipPlane or ConvexClipPlaneSet\n      * * This method parses  the variant input types and calls a more specific method.\n      * * To get both inside and outside parts, use clipPolyfaceInsideOutside\n      * * WARNING: The new mesh is \"points only\".\n      */\n    static clipPolyface(polyface, clipper) {\n        if (clipper instanceof ClipPlane)\n            return this.clipPolyfaceClipPlane(polyface, clipper);\n        if (clipper instanceof ConvexClipPlaneSet)\n            return this.clipPolyfaceConvexClipPlaneSet(polyface, clipper);\n        // (The if tests exhaust the type space -- this line is unreachable.)\n        return undefined;\n    }\n    /** Find consecutive points around a polygon (with implied closure edge) that are ON a plane\n     * @param points array of points around polygon.  Closure edge is implied.\n     * @param chainContext context receiving edges\n     * @param point0 work point\n     * @param point1 work point\n    */\n    static collectEdgesOnPlane(points, clipper, chainContext, point0, point1) {\n        const n = points.length;\n        if (n > 1) {\n            points.getPoint3dAtUncheckedPointIndex(n - 1, point0);\n            for (let i = 0; i < n; i++) {\n                points.getPoint3dAtUncheckedPointIndex(i, point1);\n                if (clipper.isPointOn(point0) && clipper.isPointOn(point1))\n                    chainContext.addSegment(point0, point1);\n                point0.setFromPoint3d(point1);\n            }\n        }\n    }\n    /** Intersect each facet with the clip plane. (Producing intersection edges.)\n     * * Return all edges  chained as array of LineString3d.\n     */\n    static sectionPolyfaceClipPlane(polyface, clipper) {\n        const chainContext = ChainMergeContext.create();\n        const visitor = polyface.createVisitor(0);\n        const work = new GrowableXYZArray(10);\n        const point0 = Point3d.create();\n        const point1 = Point3d.create();\n        for (visitor.reset(); visitor.moveToNextFacet();) {\n            clipper.clipConvexPolygonInPlace(visitor.point, work, true);\n            this.collectEdgesOnPlane(visitor.point, clipper, chainContext, point0, point1);\n        }\n        chainContext.clusterAndMergeVerticesXYZ();\n        return chainContext.collectMaximalChains();\n    }\n    /**\n     * * Split facets of mesh \"A\" into parts that are\n     *     * under mesh \"B\"\n     *     * over mesh \"B\"\n     * * both meshes are represented by visitors rather than the meshes themselves\n     *     * If the data in-hand is a mesh, call with `mesh.createVisitor`\n     * * The respective clip parts are fed to caller-supplied builders.\n     *    * Caller may set either or both builders to toggle facet order (e.g. toggle the lower facets to make them \"point down\" in cut-fill application)\n     *    * This step is commonly one-half of \"cut fill\".\n     *       * A \"cut fill\" wrapper will call this twice with the visitor and builder roles reversed.\n     * * Both polyfaces are assumed convex with CCW orientation viewed from above.\n     * @param visitorA iterator over polyface to be split.\n     * @param visitorB iterator over polyface that acts as a splitter\n     * @param orientUnderMeshDownward if true, the \"meshAUnderB\" output is oriented with its normals reversed so it can act as the bottom side of a cut-fill pair.\n     */\n    static clipPolyfaceUnderOverConvexPolyfaceIntoBuilders(visitorA, visitorB, builderAUnderB, builderAOverB) {\n        const rangeDataA = PolyfaceQuery.collectRangeLengthData(visitorA);\n        const searchA = RangeSearch.create2dSearcherForRangeLengthData(rangeDataA);\n        if (!searchA)\n            return;\n        const range = Range3d.create();\n        for (visitorA.reset(); visitorA.moveToNextFacet();) {\n            visitorA.point.setRange(range);\n            searchA.addRange(range, visitorA.currentReadIndex());\n        }\n        const xyClip = new GrowableXYZArray(10);\n        const workArray = new GrowableXYZArray(10);\n        const xyFrustum = ConvexClipPlaneSet.createEmpty();\n        const below = new GrowableXYZArray(10);\n        const above = new GrowableXYZArray(10);\n        const planeOfFacet = ClipPlane.createNormalAndPointXYZXYZ(0, 0, 1, 0, 0, 0);\n        const altitudeRange = Range1d.createNull();\n        for (visitorB.reset(); visitorB.moveToNextFacet();) {\n            visitorB.point.setRange(range);\n            ConvexClipPlaneSet.setPlaneAndXYLoopCCW(visitorB.point, planeOfFacet, xyFrustum);\n            searchA.searchRange2d(range, (_rangeA, readIndexA) => {\n                visitorA.moveToReadIndex(readIndexA);\n                xyFrustum.polygonClip(visitorA.point, xyClip, workArray);\n                // builderAOverB.addPolygonGrowableXYZArray(xyClip);\n                if (xyClip.length > 0) {\n                    // planeOfFacet.convexPolygonSplitInsideOutsideGrowableArrays(xyClip, below, above, altitudeRange);\n                    IndexedXYZCollectionPolygonOps.splitConvexPolygonInsideOutsidePlane(planeOfFacet, xyClip, below, above, altitudeRange);\n                    if (below.length > 0 && builderAUnderB)\n                        builderAUnderB.addPolygonGrowableXYZArray(below);\n                    if (above.length > 0 && builderAOverB)\n                        builderAOverB.addPolygonGrowableXYZArray(above);\n                }\n                return true;\n            });\n        }\n    }\n    /**\n     * * Split facets into vertically overlapping sections\n     * * both meshes are represented by visitors rather than the meshes themselves\n     *     * If the data in-hand is a mesh, call with `mesh.createVisitor`\n     * * The respective clip parts are returned as separate meshes.\n     *    * Caller may set either or both builders to toggle facet order (e.g. toggle the lower facets to make them \"point down\" in cut-fill application)\n     * * Both polyfaces are assumed convex with CCW orientation viewed from above.\n     * * Each output contains some facets from meshA and some from meshB:\n     *    * meshAUnderB -- areas where meshA is underneath mesh B.\n     *        * If A is \"design surface\" and B is existing DTM, this is \"cut\" volume\n     *    * meshAOverB  -- areas where meshB is over meshB.\n     *        * If A is \"design surface\" and B is existing DTM, this is \"fill\" volume\n     *\n     * @param visitorA iterator over polyface to be split.\n     * @param visitorB iterator over polyface that acts as a splitter\n     * @param orientUnderMeshDownward if true, the \"meshAUnderB\" output is oriented with its normals reversed so it can act as the bottom side of a cut-fill pair.\n     */\n    static computeCutFill(meshA, meshB) {\n        const visitorA = meshA.createVisitor();\n        const visitorB = meshB.createVisitor();\n        const builderAUnderB = PolyfaceBuilder.create();\n        const builderAOverB = PolyfaceBuilder.create();\n        builderAUnderB.toggleReversedFacetFlag();\n        this.clipPolyfaceUnderOverConvexPolyfaceIntoBuilders(visitorA, visitorB, builderAUnderB, builderAOverB);\n        builderAUnderB.toggleReversedFacetFlag();\n        builderAOverB.toggleReversedFacetFlag();\n        this.clipPolyfaceUnderOverConvexPolyfaceIntoBuilders(visitorB, visitorA, builderAOverB, builderAUnderB);\n        return {\n            meshAUnderB: builderAUnderB.claimPolyface(),\n            meshAOverB: builderAOverB.claimPolyface(),\n        };\n    }\n}\n//# sourceMappingURL=PolyfaceClip.js.map",
      "start": 1693508123112,
      "end": 1693508123286,
      "sourcemaps": null
    }
  ]
}
