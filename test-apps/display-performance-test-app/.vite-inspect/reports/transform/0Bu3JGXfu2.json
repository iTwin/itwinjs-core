{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/quantity/lib/esm/Formatter/Format.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Quantity\n */\nimport { QuantityConstants } from \"../Constants\";\nimport { QuantityError, QuantityStatus } from \"../Exception\";\nimport { DecimalPrecision, FormatTraits, formatTraitsToArray, FormatType, formatTypeToString, getTraitString, parseFormatTrait, parseFormatType, parsePrecision, parseScientificType, parseShowSignOption, scientificTypeToString, ShowSignOption, showSignOptionToString } from \"./FormatEnums\";\nimport { isCustomFormatProps } from \"./Interfaces\";\n// cSpell:ignore ZERONORMALIZED, nosign, onlynegative, signalways, negativeparentheses\n// cSpell:ignore trailzeroes, keepsinglezero, zeroempty, keepdecimalpoint, applyrounding, fractiondash, showunitlabel, prependunitlabel, exponentonlynegative\n/** A base Format class with shared properties and functionality between quantity and ecschema-metadata Format classes\n * @beta\n */\nexport class BaseFormat {\n    constructor(name) {\n        this._name = \"\";\n        this._roundFactor = 0.0;\n        this._type = FormatType.Decimal; // required; options are decimal, fractional, scientific, station\n        this._precision = DecimalPrecision.Six; // required\n        this._showSignOption = ShowSignOption.OnlyNegative; // options: noSign, onlyNegative, signAlways, negativeParentheses\n        this._decimalSeparator = QuantityConstants.LocaleSpecificDecimalSeparator;\n        this._thousandSeparator = QuantityConstants.LocaleSpecificThousandSeparator;\n        this._uomSeparator = \" \"; // optional; default is \" \"; defined separator between magnitude and the unit\n        this._stationSeparator = \"+\"; // optional; default is \"+\"\n        this._formatTraits = FormatTraits.Uninitialized;\n        this._spacer = \" \"; // optional; default is \" \"\n        this._includeZero = true; // optional; default is true\n        this._name = name;\n    }\n    get name() { return this._name; }\n    get roundFactor() { return this._roundFactor; }\n    set roundFactor(roundFactor) { this._roundFactor = roundFactor; }\n    get type() { return this._type; }\n    set type(formatType) { this._type = formatType; }\n    get precision() { return this._precision; }\n    set precision(precision) { this._precision = precision; }\n    get minWidth() { return this._minWidth; }\n    set minWidth(minWidth) { this._minWidth = minWidth; }\n    get scientificType() { return this._scientificType; }\n    set scientificType(scientificType) { this._scientificType = scientificType; }\n    get showSignOption() { return this._showSignOption; }\n    set showSignOption(showSignOption) { this._showSignOption = showSignOption; }\n    get decimalSeparator() { return this._decimalSeparator; }\n    set decimalSeparator(decimalSeparator) { this._decimalSeparator = decimalSeparator; }\n    get thousandSeparator() { return this._thousandSeparator; }\n    set thousandSeparator(thousandSeparator) { this._thousandSeparator = thousandSeparator; }\n    get uomSeparator() { return this._uomSeparator; }\n    set uomSeparator(uomSeparator) { this._uomSeparator = uomSeparator; }\n    get stationSeparator() { return this._stationSeparator; }\n    set stationSeparator(stationSeparator) { this._stationSeparator = stationSeparator; }\n    get stationOffsetSize() { return this._stationOffsetSize; }\n    set stationOffsetSize(stationOffsetSize) { stationOffsetSize = this._stationOffsetSize = stationOffsetSize; }\n    get formatTraits() { return this._formatTraits; }\n    set formatTraits(formatTraits) { this._formatTraits = formatTraits; }\n    get spacer() { return this._spacer; }\n    set spacer(spacer) { this._spacer = spacer ?? this._spacer; }\n    get includeZero() { return this._includeZero; }\n    set includeZero(includeZero) { this._includeZero = includeZero ?? this._includeZero; }\n    /** This method parses input string that is typically extracted for persisted JSON data and validates that the string is a valid FormatType. Throws exception if not valid. */\n    parseFormatTraits(formatTraitsFromJson) {\n        const formatTraits = (Array.isArray(formatTraitsFromJson)) ? formatTraitsFromJson : formatTraitsFromJson.split(/,|;|\\|/);\n        formatTraits.forEach((formatTraitsString) => {\n            const formatTrait = parseFormatTrait(formatTraitsString, this.name);\n            this._formatTraits = this.formatTraits | formatTrait;\n        });\n    }\n    /** This method returns true if the formatTrait is set in this Format object. */\n    hasFormatTraitSet(formatTrait) {\n        return (this._formatTraits & formatTrait) === formatTrait;\n    }\n    loadFormatProperties(formatProps) {\n        this._type = parseFormatType(formatProps.type, this.name);\n        if (formatProps.precision !== undefined) {\n            if (!Number.isInteger(formatProps.precision)) // mut be an integer\n                throw new QuantityError(QuantityStatus.InvalidJson, `The Format ${this.name} has an invalid 'precision' attribute. It should be an integer.`);\n            this._precision = parsePrecision(formatProps.precision, this._type, this.name);\n        }\n        if (this.type === FormatType.Scientific) {\n            if (undefined === formatProps.scientificType) // if format type is scientific and scientific type is undefined, throw\n                throw new QuantityError(QuantityStatus.InvalidJson, `The Format ${this.name} is 'Scientific' type therefore the attribute 'scientificType' is required.`);\n            this._scientificType = parseScientificType(formatProps.scientificType, this.name);\n        }\n        if (undefined !== formatProps.roundFactor) { // optional; default is 0.0\n            if (typeof (formatProps.roundFactor) !== \"number\")\n                throw new QuantityError(QuantityStatus.InvalidJson, `The Format ${this.name} has an invalid 'roundFactor' attribute. It should be of type 'number'.`);\n            if (formatProps.roundFactor !== this.roundFactor) // if roundFactor isn't default value of 0.0, reassign roundFactor variable\n                this._roundFactor = formatProps.roundFactor;\n        }\n        if (undefined !== formatProps.minWidth) { // optional\n            if (!Number.isInteger(formatProps.minWidth) || formatProps.minWidth < 0) // must be a positive int\n                throw new QuantityError(QuantityStatus.InvalidJson, `The Format ${this.name} has an invalid 'minWidth' attribute. It should be a positive integer.`);\n            this._minWidth = formatProps.minWidth;\n        }\n        if (FormatType.Station === this.type) {\n            if (undefined === formatProps.stationOffsetSize)\n                throw new QuantityError(QuantityStatus.InvalidJson, `The Format ${this.name} is 'Station' type therefore the attribute 'stationOffsetSize' is required.`);\n            if (!Number.isInteger(formatProps.stationOffsetSize) || formatProps.stationOffsetSize < 0) // must be a positive int > 0\n                throw new QuantityError(QuantityStatus.InvalidJson, `The Format ${this.name} has an invalid 'stationOffsetSize' attribute. It should be a positive integer.`);\n            this._stationOffsetSize = formatProps.stationOffsetSize;\n        }\n        if (undefined !== formatProps.showSignOption) { // optional; default is \"onlyNegative\"\n            this._showSignOption = parseShowSignOption(formatProps.showSignOption, this.name);\n        }\n        if (undefined !== formatProps.formatTraits && formatProps.formatTraits.length !== 0) { // FormatTraits is optional\n            if (!Array.isArray(formatProps.formatTraits) && typeof (formatProps.formatTraits) !== \"string\") // must be either an array of strings or a string\n                throw new QuantityError(QuantityStatus.InvalidJson, `The Format ${this.name} has an invalid 'formatTraits' attribute. It should be of type 'string' or 'string[]'.`);\n            this.parseFormatTraits(formatProps.formatTraits); // check that all of the options for formatTraits are valid. If now, throw\n        }\n        if (undefined !== formatProps.decimalSeparator) { // optional\n            if (typeof (formatProps.decimalSeparator) !== \"string\") // not a string or not a one character string\n                throw new QuantityError(QuantityStatus.InvalidJson, `The Format ${this.name} has an invalid 'decimalSeparator' attribute. It should be of type 'string'.`);\n            if (formatProps.decimalSeparator.length > 1)\n                throw new QuantityError(QuantityStatus.InvalidJson, `The Format ${this.name} has an invalid 'decimalSeparator' attribute. It should be an empty or one character string.`);\n            this._decimalSeparator = formatProps.decimalSeparator;\n        }\n        if (undefined !== formatProps.thousandSeparator) { // optional\n            if (typeof (formatProps.thousandSeparator) !== \"string\")\n                throw new QuantityError(QuantityStatus.InvalidJson, `The Format ${this.name} has an invalid 'thousandSeparator' attribute. It should be of type 'string'.`);\n            if (formatProps.thousandSeparator.length > 1)\n                throw new QuantityError(QuantityStatus.InvalidJson, `The Format ${this.name} has an invalid 'thousandSeparator' attribute. It should be an empty or one character string.`);\n            this._thousandSeparator = formatProps.thousandSeparator;\n        }\n        if (undefined !== formatProps.uomSeparator) { // optional; default is \" \"\n            if (typeof (formatProps.uomSeparator) !== \"string\")\n                throw new QuantityError(QuantityStatus.InvalidJson, `The Format ${this.name} has an invalid 'uomSeparator' attribute. It should be of type 'string'.`);\n            if (formatProps.uomSeparator.length < 0 || formatProps.uomSeparator.length > 1)\n                throw new QuantityError(QuantityStatus.InvalidJson, `The Format ${this.name} has an invalid 'uomSeparator' attribute. It should be an empty or one character string.`);\n            this._uomSeparator = formatProps.uomSeparator;\n        }\n        if (undefined !== formatProps.stationSeparator) { // optional; default is \"+\"\n            if (typeof (formatProps.stationSeparator) !== \"string\")\n                throw new QuantityError(QuantityStatus.InvalidJson, `The Format ${this.name} has an invalid 'stationSeparator' attribute. It should be of type 'string'.`);\n            if (formatProps.stationSeparator.length > 1)\n                throw new QuantityError(QuantityStatus.InvalidJson, `The Format ${this.name} has an invalid 'stationSeparator' attribute. It should be an empty or one character string.`);\n            this._stationSeparator = formatProps.stationSeparator;\n        }\n    }\n}\n/** A class used to define the specifications for formatting quantity values. This class is typically loaded by reading [[FormatProps]].\n * @beta\n */\nexport class Format extends BaseFormat {\n    /** Constructor\n     *  @param name     The name of a format specification. TODO: make optional or remove\n     */\n    constructor(name) {\n        super(name);\n    }\n    get units() { return this._units; }\n    get hasUnits() { return this._units !== undefined && this._units.length > 0; }\n    get customProps() { return this._customProps; }\n    static isFormatTraitSetInProps(formatProps, trait) {\n        if (!formatProps.formatTraits)\n            return false;\n        const formatTraits = Array.isArray(formatProps.formatTraits) ? formatProps.formatTraits : formatProps.formatTraits.split(/,|;|\\|/);\n        const traitStr = getTraitString(trait);\n        return formatTraits.find((traitEntry) => traitStr === traitEntry) ? true : false;\n    }\n    async createUnit(unitsProvider, name, label) {\n        if (name === undefined || typeof (name) !== \"string\" || (label !== undefined && typeof (label) !== \"string\")) // throws if name is undefined or name isn't a string or if label is defined and isn't a string\n            throw new QuantityError(QuantityStatus.InvalidJson, `This Composite has a unit with an invalid 'name' or 'label' attribute.`);\n        for (const unit of this.units) {\n            const unitObj = unit[0].name;\n            if (unitObj.toLowerCase() === name.toLowerCase()) // duplicate names are not allowed\n                throw new QuantityError(QuantityStatus.InvalidJson, `The unit ${unitObj} has a duplicate name.`);\n        }\n        const newUnit = await unitsProvider.findUnitByName(name);\n        if (!newUnit || !newUnit.isValid)\n            throw new QuantityError(QuantityStatus.InvalidJson, `Invalid unit name '${name}'.`);\n        this.units.push([newUnit, label]);\n    }\n    /**\n     *  Clone Format\n     */\n    clone(options) {\n        const newFormat = new Format(this.name);\n        newFormat._roundFactor = this._roundFactor;\n        newFormat._type = this._type;\n        newFormat._precision = this._precision;\n        newFormat._minWidth = this._minWidth;\n        newFormat._scientificType = this._scientificType;\n        newFormat._showSignOption = this._showSignOption;\n        newFormat._decimalSeparator = this._decimalSeparator;\n        newFormat._thousandSeparator = this._thousandSeparator;\n        newFormat._uomSeparator = this._uomSeparator;\n        newFormat._stationSeparator = this._stationSeparator;\n        newFormat._stationOffsetSize = this._stationOffsetSize;\n        newFormat._formatTraits = this._formatTraits;\n        newFormat._spacer = this._spacer;\n        newFormat._includeZero = this._includeZero;\n        newFormat._customProps = this._customProps;\n        this._units && (newFormat._units = [...this._units]);\n        if (newFormat._units) {\n            if (options?.showOnlyPrimaryUnit) {\n                if (newFormat._units.length > 1)\n                    newFormat._units.length = 1;\n            }\n        }\n        if (undefined !== options?.traits)\n            newFormat._formatTraits = options?.traits;\n        if (undefined !== options?.type)\n            newFormat._type = options.type;\n        if (undefined !== options?.precision) {\n            // ensure specified precision is valid\n            const precision = parsePrecision(options?.precision, newFormat._type, newFormat.name);\n            newFormat._precision = precision;\n        }\n        if (undefined !== options?.primaryUnit) {\n            if (options.primaryUnit.unit) {\n                const newUnits = new Array();\n                newUnits.push([options.primaryUnit.unit, options.primaryUnit.label]);\n                newFormat._units = newUnits;\n            }\n            else if (options.primaryUnit.label && newFormat._units?.length) {\n                // update label only\n                newFormat._units[0][1] = options.primaryUnit.label;\n            }\n        }\n        return newFormat;\n    }\n    /**\n     * Populates this Format with the values from the provided.\n     */\n    async fromJSON(unitsProvider, jsonObj) {\n        this.loadFormatProperties(jsonObj);\n        if (isCustomFormatProps(jsonObj))\n            this._customProps = jsonObj.custom;\n        if (undefined !== jsonObj.composite) { // optional\n            this._units = new Array();\n            if (jsonObj.composite.includeZero !== undefined) {\n                if (typeof (jsonObj.composite.includeZero) !== \"boolean\") // includeZero must be a boolean IF it is defined\n                    throw new QuantityError(QuantityStatus.InvalidJson, `The Format ${this.name} has a Composite with an invalid 'includeZero' attribute. It should be of type 'boolean'.`);\n                this._includeZero = jsonObj.composite.includeZero;\n            }\n            if (jsonObj.composite.spacer !== undefined) { // spacer must be a string IF it is defined\n                if (typeof (jsonObj.composite.spacer) !== \"string\")\n                    throw new QuantityError(QuantityStatus.InvalidJson, `The Format ${this.name} has a Composite with an invalid 'spacer' attribute. It must be of type 'string'.`);\n                if (jsonObj.composite.spacer.length > 1)\n                    throw new QuantityError(QuantityStatus.InvalidJson, `The Format ${this.name} has a Composite with an invalid 'spacer' attribute. It should be an empty or one character string.`);\n                this._spacer = jsonObj.composite.spacer;\n            }\n            if (jsonObj.composite.units !== undefined) { // if composite is defined, it must be an array with 1-4 units\n                if (!Array.isArray(jsonObj.composite.units)) { // must be an array\n                    throw new QuantityError(QuantityStatus.InvalidJson, `The Format ${this.name} has a Composite with an invalid 'units' attribute. It must be of type 'array'`);\n                }\n                if (jsonObj.composite.units.length > 0 && jsonObj.composite.units.length <= 4) { // Composite requires 1-4 units\n                    try {\n                        const createUnitPromises = [];\n                        for (const unit of jsonObj.composite.units) {\n                            createUnitPromises.push(this.createUnit(unitsProvider, unit.name, unit.label));\n                        }\n                        await Promise.all(createUnitPromises);\n                    }\n                    catch (e) {\n                        throw e;\n                    }\n                }\n            }\n            if (undefined === this.units || this.units.length === 0)\n                throw new QuantityError(QuantityStatus.InvalidJson, `The Format ${this.name} has a Composite with no valid 'units'`);\n        }\n    }\n    /** Create a Format from FormatProps */\n    static async createFromJSON(name, unitsProvider, formatProps) {\n        const actualFormat = new Format(name);\n        await actualFormat.fromJSON(unitsProvider, formatProps);\n        return actualFormat;\n    }\n    /**\n     * Returns a JSON object that contain the specification for this Format.\n     */\n    toJSON() {\n        let composite;\n        if (this.units) {\n            const units = this.units.map((value) => {\n                if (undefined !== value[1])\n                    return { name: value[0].name, label: value[1] };\n                else\n                    return { name: value[0].name };\n            });\n            composite = {\n                spacer: this.spacer,\n                includeZero: this.includeZero,\n                units,\n            };\n        }\n        if (this.customProps)\n            return {\n                type: formatTypeToString(this.type),\n                precision: this.precision,\n                roundFactor: this.roundFactor,\n                minWidth: this.minWidth,\n                showSignOption: showSignOptionToString(this.showSignOption),\n                formatTraits: formatTraitsToArray(this.formatTraits),\n                decimalSeparator: this.decimalSeparator,\n                thousandSeparator: this.thousandSeparator,\n                uomSeparator: this.uomSeparator,\n                scientificType: this.scientificType ? scientificTypeToString(this.scientificType) : undefined,\n                stationOffsetSize: this.stationOffsetSize,\n                stationSeparator: this.stationSeparator,\n                composite,\n                custom: this.customProps,\n            };\n        return {\n            type: formatTypeToString(this.type),\n            precision: this.precision,\n            roundFactor: this.roundFactor,\n            minWidth: this.minWidth,\n            showSignOption: showSignOptionToString(this.showSignOption),\n            formatTraits: formatTraitsToArray(this.formatTraits),\n            decimalSeparator: this.decimalSeparator,\n            thousandSeparator: this.thousandSeparator,\n            uomSeparator: this.uomSeparator,\n            scientificType: this.scientificType ? scientificTypeToString(this.scientificType) : undefined,\n            stationOffsetSize: this.stationOffsetSize,\n            stationSeparator: this.stationSeparator,\n            composite,\n        };\n    }\n}\n//# sourceMappingURL=Format.js.map",
      "start": 1693508123238,
      "end": 1693508123482,
      "sourcemaps": null
    }
  ]
}
