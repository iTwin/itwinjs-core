{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/primitives/mesh/MeshPrimitives.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Rendering\n */\nimport { assert } from \"@itwin/core-bentley\";\nimport { AuxChannel, AuxChannelData } from \"@itwin/core-geometry\";\nimport { ColorIndex, EdgeArgs, FeatureIndex, FeatureIndexType, LinePixels, MeshPolylineList, PolylineEdgeArgs, PolylineTypeFlags, QParams3d, QPoint3dList, SilhouetteEdgeArgs, } from \"@itwin/core-common\";\nimport { ColorMap } from \"../ColorMap\";\nimport { DisplayParams } from \"../../../common/render/primitives/DisplayParams\";\nimport { MeshPrimitiveType } from \"../../../common/render/primitives/MeshPrimitive\";\nimport { TriangleList } from \"../Primitives\";\n/** @public */\nexport var PolylineArgs;\n(function (PolylineArgs) {\n    /** @internal */\n    function fromMesh(mesh) {\n        if (!mesh.polylines || mesh.polylines.length === 0)\n            return undefined;\n        const polylines = [];\n        for (const polyline of mesh.polylines)\n            if (polyline.indices.length > 0)\n                polylines.push(polyline.indices);\n        if (polylines.length === 0)\n            return undefined;\n        const flags = {\n            is2d: mesh.is2d,\n            isPlanar: mesh.isPlanar,\n            isDisjoint: mesh.type === MeshPrimitiveType.Point,\n        };\n        if (mesh.displayParams.regionEdgeType === DisplayParams.RegionEdgeType.Outline) {\n            // This polyline is behaving as the edges of a region surface.\n            if (!mesh.displayParams.gradient || mesh.displayParams.gradient.isOutlined)\n                flags.type = PolylineTypeFlags.Edge;\n            else\n                flags.type = PolylineTypeFlags.Outline; // edges only displayed if fill undisplayed\n        }\n        const colors = new ColorIndex();\n        mesh.colorMap.toColorIndex(colors, mesh.colors);\n        const features = new FeatureIndex();\n        mesh.toFeatureIndex(features);\n        return {\n            width: mesh.displayParams.width,\n            linePixels: mesh.displayParams.linePixels,\n            flags,\n            polylines,\n            points: mesh.points,\n            colors,\n            features,\n        };\n    }\n    PolylineArgs.fromMesh = fromMesh;\n})(PolylineArgs || (PolylineArgs = {}));\n/** The vertices of the edges are shared with those of the surface\n * @internal\n */\nexport class MeshArgsEdges {\n    constructor() {\n        this.edges = new EdgeArgs();\n        this.silhouettes = new SilhouetteEdgeArgs();\n        this.polylines = new PolylineEdgeArgs();\n        this.width = 0;\n        this.linePixels = LinePixels.Solid;\n    }\n    clear() {\n        this.edges.clear();\n        this.silhouettes.clear();\n        this.polylines.clear();\n        this.width = 0;\n        this.linePixels = LinePixels.Solid;\n    }\n    get isValid() { return this.edges.isValid || this.silhouettes.isValid || this.polylines.isValid; }\n}\n/** @public */\nexport var MeshArgs;\n(function (MeshArgs) {\n    /** @internal */\n    function fromMesh(mesh) {\n        if (!mesh.triangles || mesh.triangles.isEmpty || mesh.points.length === 0)\n            return undefined;\n        const texture = mesh.displayParams.textureMapping?.texture;\n        const textureMapping = texture && mesh.uvParams.length > 0 ? { texture, uvParams: mesh.uvParams } : undefined;\n        const colors = new ColorIndex();\n        mesh.colorMap.toColorIndex(colors, mesh.colors);\n        const features = new FeatureIndex();\n        mesh.toFeatureIndex(features);\n        let edges;\n        if (mesh.edges) {\n            edges = new MeshArgsEdges();\n            edges.width = mesh.displayParams.width;\n            edges.linePixels = mesh.displayParams.linePixels;\n            edges.edges.init(mesh.edges);\n            edges.silhouettes.init(mesh.edges);\n            const polylines = [];\n            for (const meshPolyline of mesh.edges.polylines)\n                if (meshPolyline.indices.length > 0)\n                    polylines.push(meshPolyline.indices);\n            edges.polylines.init(polylines);\n        }\n        return {\n            vertIndices: mesh.triangles.indices,\n            points: mesh.points,\n            normals: !mesh.displayParams.ignoreLighting && mesh.normals.length > 0 ? mesh.normals : undefined,\n            textureMapping,\n            colors,\n            features,\n            material: mesh.displayParams.material,\n            fillFlags: mesh.displayParams.fillFlags,\n            isPlanar: mesh.isPlanar,\n            is2d: mesh.is2d,\n            hasBakedLighting: true === mesh.hasBakedLighting,\n            isVolumeClassifier: true === mesh.isVolumeClassifier,\n            edges,\n            auxChannels: mesh.auxChannels,\n        };\n    }\n    MeshArgs.fromMesh = fromMesh;\n})(MeshArgs || (MeshArgs = {}));\n/** @internal */\nexport class Mesh {\n    constructor(props) {\n        this.normals = [];\n        this.uvParams = [];\n        this.colorMap = new ColorMap(); // used to be called ColorTable\n        this.colors = [];\n        const { displayParams, features, type, range, is2d, isPlanar } = props;\n        this._data = MeshPrimitiveType.Mesh === type ? new TriangleList() : new MeshPolylineList();\n        this.displayParams = displayParams;\n        this.features = features ? new Mesh.Features(features) : undefined;\n        this.type = type;\n        this.is2d = is2d;\n        this.isPlanar = isPlanar;\n        this.hasBakedLighting = (true === props.hasBakedLighting);\n        this.isVolumeClassifier = (true === props.isVolumeClassifier);\n        if (props.quantizePositions) {\n            this.points = new QPoint3dList(QParams3d.fromRange(range));\n        }\n        else {\n            const points = [];\n            points.range = range;\n            const center = range.center;\n            points.add = (pt) => {\n                // assert(range.containsPoint(pt)); rounding error triggers this sometimes...\n                points.push(pt.minus(center));\n            };\n            this.points = points;\n        }\n    }\n    static create(props) { return new Mesh(props); }\n    get triangles() {\n        return MeshPrimitiveType.Mesh === this.type ? this._data : undefined;\n    }\n    get polylines() {\n        return MeshPrimitiveType.Mesh !== this.type ? this._data : undefined;\n    }\n    get auxChannels() {\n        return this._auxChannels;\n    }\n    addAuxChannels(channels, srcIndex) {\n        // The native version of this function appears to assume that all polyfaces added to the Mesh will have\n        // the same number + type of aux channels.\n        // ###TODO We should really produce a separate Mesh for each unique combination. For now just bail on mismatch.\n        if (this._auxChannels) {\n            if (this._auxChannels.length !== channels.length)\n                return;\n            for (let i = 0; i < channels.length; i++) {\n                const src = channels[i];\n                const dst = this._auxChannels[i];\n                if (src.dataType !== dst.dataType || src.name !== dst.name || src.inputName !== dst.inputName)\n                    return;\n            }\n        }\n        if (!this._auxChannels) {\n            // Copy the channels, leaving each AuxData's values array empty.\n            this._auxChannels = channels.map((x) => new AuxChannel(x.data.map((y) => new AuxChannelData(y.input, [])), x.dataType, x.name, x.inputName));\n        }\n        // Append the value at srcIndex from each source channel's data to our channels.\n        for (let channelIndex = 0; channelIndex < channels.length; channelIndex++) {\n            const srcChannel = channels[channelIndex];\n            const dstChannel = this._auxChannels[channelIndex];\n            const dstIndex = dstChannel.valueCount;\n            for (let dataIndex = 0; dataIndex < srcChannel.data.length; dataIndex++) {\n                const dstData = dstChannel.data[dataIndex];\n                dstData.copyValues(srcChannel.data[dataIndex], dstIndex, srcIndex, dstChannel.entriesPerValue);\n            }\n        }\n    }\n    toFeatureIndex(index) {\n        if (undefined !== this.features)\n            this.features.toFeatureIndex(index);\n    }\n    toMeshArgs() {\n        return MeshArgs.fromMesh(this);\n    }\n    toPolylineArgs() {\n        return PolylineArgs.fromMesh(this);\n    }\n    getGraphics(system, instancesOrViewIndependentOrigin) {\n        const meshArgs = this.toMeshArgs();\n        if (meshArgs)\n            return system.createTriMesh(meshArgs, instancesOrViewIndependentOrigin);\n        const plArgs = this.toPolylineArgs();\n        return plArgs ? system.createIndexedPolylines(plArgs, instancesOrViewIndependentOrigin) : undefined;\n    }\n    addPolyline(poly) {\n        const { type, polylines } = this;\n        assert(MeshPrimitiveType.Polyline === type || MeshPrimitiveType.Point === type);\n        assert(undefined !== polylines);\n        if (MeshPrimitiveType.Polyline === type && poly.indices.length < 2)\n            return;\n        if (undefined !== polylines)\n            polylines.push(poly);\n    }\n    addTriangle(triangle) {\n        const { triangles, type } = this;\n        assert(MeshPrimitiveType.Mesh === type);\n        assert(undefined !== triangles);\n        if (undefined !== triangles)\n            triangles.addTriangle(triangle);\n    }\n    addVertex(props) {\n        const { feature, position, normal, uvParam, fillColor } = props;\n        this.points.add(position);\n        if (undefined !== normal)\n            this.normals.push(normal);\n        if (undefined !== uvParam)\n            this.uvParams.push(uvParam);\n        if (feature) {\n            assert(undefined !== this.features);\n            this.features.add(feature, this.points.length);\n        }\n        // Don't allocate color indices until we have non-uniform colors\n        if (0 === this.colorMap.length) {\n            this.colorMap.insert(fillColor);\n            assert(this.colorMap.isUniform);\n            assert(0 === this.colorMap.indexOf(fillColor));\n        }\n        else if (!this.colorMap.isUniform || !this.colorMap.hasColor(fillColor)) {\n            // Back-fill uniform value (index=0) for existing vertices if previously uniform\n            if (0 === this.colors.length)\n                this.colors.length = this.points.length - 1;\n            this.colors.push(this.colorMap.insert(fillColor));\n            assert(!this.colorMap.isUniform);\n        }\n        return this.points.length - 1;\n    }\n}\n/** @internal */\n(function (Mesh) {\n    class Features {\n        constructor(table) {\n            this.indices = [];\n            this.uniform = 0;\n            this.initialized = false;\n            this.table = table;\n        }\n        add(feat, numVerts) {\n            const index = this.table.insert(feat);\n            if (!this.initialized) {\n                // First feature - uniform.\n                this.uniform = index;\n                this.initialized = true;\n            }\n            else if (0 < this.indices.length) {\n                // Already non-uniform\n                this.indices.push(index);\n            }\n            else {\n                // Second feature - back-fill uniform for existing verts\n                while (this.indices.length < numVerts - 1)\n                    this.indices.push(this.uniform);\n                this.indices.push(index);\n            }\n        }\n        setIndices(indices) {\n            this.indices.length = 0;\n            this.uniform = 0;\n            this.initialized = 0 < indices.length;\n            assert(0 < indices.length);\n            if (1 === indices.length)\n                this.uniform = indices[0];\n            else if (1 < indices.length)\n                this.indices = indices;\n        }\n        toFeatureIndex(output) {\n            const index = output ?? new FeatureIndex();\n            if (!this.initialized) {\n                index.type = FeatureIndexType.Empty;\n            }\n            else if (this.indices.length === 0) {\n                index.type = FeatureIndexType.Uniform;\n                index.featureID = this.uniform;\n            }\n            else {\n                index.type = FeatureIndexType.NonUniform;\n                index.featureIDs = new Uint32Array(this.indices);\n            }\n            return index;\n        }\n    }\n    Mesh.Features = Features;\n})(Mesh || (Mesh = {}));\n/** @internal */\nexport class MeshList extends Array {\n    constructor(features, range) {\n        super();\n        this.features = features;\n        this.range = range;\n    }\n}\n//# sourceMappingURL=MeshPrimitives.js.map",
      "start": 1693508119704,
      "end": 1693508119802,
      "sourcemaps": null
    }
  ]
}
