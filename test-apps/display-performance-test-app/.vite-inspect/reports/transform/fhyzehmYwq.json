{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tile/TileTree.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tiles\n */\nimport { BeTimePoint, dispose } from \"@itwin/core-bentley\";\nimport { calculateEcefToDbTransformAtLocation } from \"../BackgroundMapGeometry\";\nimport { IModelApp } from \"../IModelApp\";\n/** Describes the current state of a [[TileTree]]. TileTrees are loaded asynchronously and may be unloaded after a period of disuse.\n * @see [[TileTreeOwner]].\n * @public\n * @extensions\n */\nexport var TileTreeLoadStatus;\n(function (TileTreeLoadStatus) {\n    /** No attempt to load the tile tree has yet been made. */\n    TileTreeLoadStatus[TileTreeLoadStatus[\"NotLoaded\"] = 0] = \"NotLoaded\";\n    /** The tile tree is in the process of being loaded. */\n    TileTreeLoadStatus[TileTreeLoadStatus[\"Loading\"] = 1] = \"Loading\";\n    /** The tile tree has been successfully loaded. */\n    TileTreeLoadStatus[TileTreeLoadStatus[\"Loaded\"] = 2] = \"Loaded\";\n    /** An attempt to load the tile tree failed. */\n    TileTreeLoadStatus[TileTreeLoadStatus[\"NotFound\"] = 3] = \"NotFound\";\n})(TileTreeLoadStatus || (TileTreeLoadStatus = {}));\n/** A hierarchical level-of-detail tree of [3d Tiles](https://github.com/CesiumGS/3d-tiles) to be rendered in a [[Viewport]].\n * Tile trees originate from a variety of sources:\n *  - Each [[GeometricModelState]] can supply its graphics as a tile tree;\n *  - A [[DisplayStyleState]]'s map settings or reality models;\n *  - [ViewAttachment]($backend)s in a [[SheetModelState]];\n *  - [[TiledGraphicsProvider]]s associated with a viewport.\n *\n * The same TileTree can be displayed in any number of viewports using multiple [[TileTreeReference]]s.\n * A TileTree's lifetime is managed by a [[TileTreeOwner]].\n *\n * @note Some methods carry a warning that they should **not** be overridden by subclasses; typically a protected method exists that can be\n * overridden instead to customize the behavior. For example, [[selectTiles]] should not be overridden; instead, override the[[_selectTiles]] method\n * that it calls.\n * @public\n * @extensions\n */\nexport class TileTree {\n    /** @internal */\n    get loadPriority() { return this._loadPriority; }\n    /** True if this tile tree has no bounds - e.g., a tile tree representing a globe is unbounded. */\n    get isContentUnbounded() {\n        return false;\n    }\n    /** True if this tile tree contains 2d graphics. */\n    get is2d() { return !this.is3d; }\n    /** @internal */\n    get isPointCloud() { return false; }\n    /** @internal */\n    get clipVolume() { return this._clipVolume; }\n    /** The volume of space occupied by this tile tree. */\n    get range() { return this.rootTile.range; }\n    /** The most recent time at which tiles [[selectTiles]] was called. */\n    get lastSelectedTime() { return this._lastSelected; }\n    /** True if a tile and its child tiles should not be drawn simultaneously.\n     * Default: true.\n     */\n    get parentsAndChildrenExclusive() { return true; }\n    /** Constructor */\n    constructor(params) {\n        this._isDisposed = false;\n        /** @internal */\n        this._lastSelected = BeTimePoint.now();\n        this._lastSelected = BeTimePoint.now();\n        this.iModel = params.iModel;\n        this.iModelTransform = params.location;\n        this._clipVolume = params.clipVolume;\n        this.modelId = params.modelId;\n        this.id = params.id;\n        this.contentRange = params.contentRange;\n        const admin = IModelApp.tileAdmin;\n        this._loadPriority = params.priority;\n        this.expirationTime = params.expirationTime ?? admin.tileExpirationTime;\n    }\n    /** Selects tiles of appropriate resolution for some purpose like drawing to the screen, producing a shadow map, etc.\n     * @note Do **not** override this method. Implement [[_selectTiles]].\n     */\n    selectTiles(args) {\n        this._lastSelected = BeTimePoint.now();\n        const tiles = this._selectTiles(args);\n        IModelApp.tileAdmin.addTilesForUser(args.context.viewport, tiles, args.readyTiles, args.touchedTiles);\n        args.processSelectedTiles(tiles);\n        return tiles;\n    }\n    /** True if [[dispose]] has been called on this tile tree. */\n    get isDisposed() { return this._isDisposed; }\n    /** Dispose of this tree and any resources owned by it. This is typically invoked by a [[TileTreeOwner]]. */\n    dispose() {\n        if (this.isDisposed)\n            return;\n        this._isDisposed = true;\n        dispose(this.rootTile);\n    }\n    /** @internal */\n    collectStatistics(stats) {\n        this.rootTile.collectStatistics(stats);\n    }\n    /** Returns the number of [[Tile]]s currently in memory belonging to this tree, primarily for debugging. */\n    countTiles() {\n        return 1 + this.rootTile.countDescendants();\n    }\n    /** @internal */\n    accumulateTransformedRange(range, matrix, location, frustumPlanes) {\n        this.rootTile.extendRangeForContent(range, matrix, location, frustumPlanes);\n    }\n    /**\n     * Return the transform from the tile tree's coordinate space to [ECEF](https://en.wikipedia.org/wiki/ECEF) (Earth Centered Earth Fixed) coordinates.\n     * If a geographic coordinate system is present then this transform will be calculated at the tile tree center.\n     * @beta\n     */\n    async getEcefTransform() {\n        if (!this.iModel.ecefLocation)\n            return undefined;\n        let dbToEcef;\n        const range = this.contentRange ? this.contentRange : this.range;\n        const center = range.localXYZToWorld(.5, .5, .5);\n        if (center) {\n            this.iModelTransform.multiplyPoint3d(center, center);\n            const ecefToDb = await calculateEcefToDbTransformAtLocation(center, this.iModel);\n            dbToEcef = ecefToDb?.inverse();\n        }\n        if (!dbToEcef)\n            dbToEcef = this.iModel.ecefLocation.getTransform();\n        return dbToEcef.multiplyTransformTransform(this.iModelTransform);\n    }\n    /** Populate [[TileGeometryCollector.polyfaces]] with geometry obtained from this tile tree's tiles satisfying the collector's criteria.\n     * The base implementation does nothing.\n     * @see [[TileTreeReference.createGeometryTreeReference]] to attempt to create a TileTree that can collect geometry.\n     * @beta\n     */\n    collectTileGeometry(_collector) {\n    }\n}\n//# sourceMappingURL=TileTree.js.map",
      "start": 1693508121506,
      "end": 1693508121645,
      "sourcemaps": null
    }
  ]
}
