{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/UniformHandle.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { assert, Logger } from \"@itwin/core-bentley\";\nimport { FrontendLoggerCategory } from \"../../common/FrontendLoggerCategory\";\nimport { System } from \"./System\";\n/** A handle to the location of a uniform within a shader program\n * @internal\n */\nexport class UniformHandle {\n    constructor(location) {\n        this._type = 0 /* DataType.Undefined */;\n        this._data = [];\n        this._location = location;\n    }\n    static create(program, name) {\n        let location = null;\n        if (undefined !== program.glProgram) {\n            location = System.instance.context.getUniformLocation(program.glProgram, name);\n        }\n        if (null === location) {\n            const errMsg = `uniform ${name} not found in ${program.description}.`;\n            if (System.instance.options.errorOnMissingUniform) {\n                throw new Error(errMsg);\n            }\n            else {\n                Logger.logError(FrontendLoggerCategory.Render, errMsg);\n            }\n        }\n        return new UniformHandle(location);\n    }\n    updateData(type, data) {\n        assert(0 /* DataType.Undefined */ !== type && 8 /* DataType.Int */ !== type && 3 /* DataType.Float */ !== type && 10 /* DataType.Uint */ !== type);\n        let updated = this._type !== type;\n        if (updated) {\n            this._type = type;\n            if (this._data.length !== data.length)\n                this._data.length = data.length;\n        }\n        for (let i = 0; i < data.length; i++) {\n            const datum = data[i];\n            updated = updated || this._data[i] !== datum;\n            this._data[i] = datum;\n        }\n        return updated;\n    }\n    updateDatum(type, datum) {\n        assert(8 /* DataType.Int */ === type || 10 /* DataType.Uint */ === type || 3 /* DataType.Float */ === type);\n        // NB: Yes, calling data.length without actually changing the length shows up as a significant performance bottleneck...\n        if (this._data.length !== 1)\n            this._data.length = 1;\n        const updated = this._type !== type || this._data[0] !== datum;\n        this._type = type;\n        this._data[0] = datum;\n        return updated;\n    }\n    setMatrix3(mat) {\n        if (this.updateData(1 /* DataType.Mat3 */, mat.data))\n            System.instance.context.uniformMatrix3fv(this._location, false, mat.data);\n    }\n    setMatrix4(mat) {\n        if (this.updateData(2 /* DataType.Mat4 */, mat.data))\n            System.instance.context.uniformMatrix4fv(this._location, false, mat.data);\n    }\n    setUniform1iv(data) {\n        if (this.updateData(9 /* DataType.IntArray */, data))\n            System.instance.context.uniform1iv(this._location, data);\n    }\n    setUniform1fv(data) {\n        if (this.updateData(4 /* DataType.FloatArray */, data))\n            System.instance.context.uniform1fv(this._location, data);\n    }\n    setUniform2fv(data) {\n        if (this.updateData(5 /* DataType.Vec2 */, data))\n            System.instance.context.uniform2fv(this._location, data);\n    }\n    setUniform3fv(data) {\n        if (this.updateData(6 /* DataType.Vec3 */, data))\n            System.instance.context.uniform3fv(this._location, data);\n    }\n    setUniform4fv(data) {\n        if (this.updateData(7 /* DataType.Vec4 */, data))\n            System.instance.context.uniform4fv(this._location, data);\n    }\n    setUniform1i(data) {\n        if (this.updateDatum(8 /* DataType.Int */, data))\n            System.instance.context.uniform1i(this._location, data);\n    }\n    setUniform1f(data) {\n        if (this.updateDatum(3 /* DataType.Float */, data))\n            System.instance.context.uniform1f(this._location, data);\n    }\n    setUniform1ui(data) {\n        if (this.updateDatum(10 /* DataType.Uint */, data))\n            System.instance.context.uniform1ui(this._location, data);\n    }\n    setUniformBitflags(data) {\n        this.setUniform1ui(data);\n    }\n}\n//# sourceMappingURL=UniformHandle.js.map",
      "start": 1693508123771,
      "end": 1693508124017,
      "sourcemaps": null
    }
  ]
}
