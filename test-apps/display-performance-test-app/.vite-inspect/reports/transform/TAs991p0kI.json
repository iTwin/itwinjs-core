{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/polyface/AuxData.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\nimport { NumberArray } from \"../geometry3d/PointHelpers\";\n// import { Geometry } from \"./Geometry\";\nimport { Range1d, Range3d } from \"../geometry3d/Range\";\n/** The types of data that can be represented by an [[AuxChannelData]]. Each type of data contributes differently to the\n * animation applied by an [AnalysisStyle]($common) and responds differently when the host [[PolyfaceAuxData]] is transformed.\n * @public\n */\nexport var AuxChannelDataType;\n(function (AuxChannelDataType) {\n    /** General-purpose scalar values like stress, temperature, etc., used to recolor the [[Polyface]]'s vertices.\n     * When the host Polyface is transformed, scalar values remain unmodified.\n     */\n    AuxChannelDataType[AuxChannelDataType[\"Scalar\"] = 0] = \"Scalar\";\n    /** Distances in meters used to recolor the [[Polyface]]'s vertices.\n     * When the host [[Polyface]] is transformed the [[Transform]]'s scale is applied to the distances.\n     */\n    AuxChannelDataType[AuxChannelDataType[\"Distance\"] = 1] = \"Distance\";\n    /** (X, Y, Z) displacement vectors added to the [[Polyface]]'s vertex positions resulting in deformation of the mesh.\n     * When the host Polyface is transformed the displacements are rotated and scaled accordingly.\n     */\n    AuxChannelDataType[AuxChannelDataType[\"Vector\"] = 2] = \"Vector\";\n    /** (X, Y, Z) normal vectors that replace the host [[Polyface]]'s own normals.\n     * When the Polyface is transformed the normals are rotated accordingly.\n     */\n    AuxChannelDataType[AuxChannelDataType[\"Normal\"] = 3] = \"Normal\";\n})(AuxChannelDataType || (AuxChannelDataType = {}));\n/**  Represents the [[AuxChannel]] data at a single input value.\n * @public\n*/\nexport class AuxChannelData {\n    /** Construct a new [[AuxChannelData]] from input value and vertex values. */\n    constructor(input, values) {\n        this.input = input;\n        if (values instanceof Float64Array) {\n            this.values = [];\n            for (const v of values)\n                this.values.push(v);\n        }\n        else\n            this.values = values;\n    }\n    /** Copy blocks of size `blockSize` from (blocked index) `thisIndex` in this AuxChannelData to (blockIndex) `otherIndex` of `other` */\n    copyValues(other, thisIndex, otherIndex, blockSize) {\n        for (let i = 0; i < blockSize; i++)\n            this.values[thisIndex * blockSize + i] = other.values[otherIndex * blockSize + i];\n    }\n    /** return a deep copy */\n    clone() {\n        return new AuxChannelData(this.input, this.values.slice());\n    }\n    /** toleranced comparison of the `input` and `value` fields.\n     * * Default tolerance is 1.0e-8\n     */\n    isAlmostEqual(other, tol) {\n        const tolerance = tol ? tol : 1.0E-8;\n        return Math.abs(this.input - other.input) < tolerance && NumberArray.isAlmostEqual(this.values, other.values, tolerance);\n    }\n}\n/**  Represents a single [[PolyfaceAuxData]] channel.\n * @public\n*/\nexport class AuxChannel {\n    /** Create a [[AuxChannel]] */\n    constructor(data, dataType, name, inputName) {\n        this.data = data;\n        this.dataType = dataType;\n        this.name = name;\n        this.inputName = inputName;\n    }\n    /** Return a deep copy. */\n    clone() {\n        const clonedData = [];\n        for (const data of this.data)\n            clonedData.push(data.clone());\n        return new AuxChannel(clonedData, this.dataType, this.name, this.inputName);\n    }\n    /** Toleranced comparison of contents. */\n    isAlmostEqual(other, tol) {\n        if (this.dataType !== other.dataType ||\n            this.name !== other.name ||\n            this.inputName !== other.inputName ||\n            this.data.length !== other.data.length)\n            return false;\n        for (let i = 0; i < this.data.length; i++)\n            if (!this.data[i].isAlmostEqual(other.data[i], tol))\n                return false;\n        return true;\n    }\n    /** True if [[entriesPerValue]] is `1`. */\n    get isScalar() {\n        return this.dataType === AuxChannelDataType.Distance || this.dataType === AuxChannelDataType.Scalar;\n    }\n    /** The number of values in `data.values` per entry - 1 for scalar and distance types, 3 for normal and vector types. */\n    get entriesPerValue() {\n        return this.isScalar ? 1 : 3;\n    }\n    /** The number of entries in `data.values`. */\n    get valueCount() {\n        return 0 === this.data.length ? 0 : this.data[0].values.length / this.entriesPerValue;\n    }\n    /** The minimum and maximum values in `data.values`, or `undefined` if [[isScalar]] is false. */\n    get scalarRange() {\n        if (!this.isScalar)\n            return undefined;\n        const range = Range1d.createNull();\n        for (const data of this.data)\n            range.extendArray(data.values);\n        return range;\n    }\n    /** Compute the range of this channel's displacement values, if [[dataType]] is [[AuxChannelDataType.Vector]].\n     * @param scale Scale by which to multiply each displacement.\n     * @param result Preallocated object in which to store result.\n     * @returns The range encompassing all this channel's displacements scaled by `scale`; or a null range if this channel does not contain displacements.\n     */\n    computeDisplacementRange(scale = 1, result) {\n        result = Range3d.createNull(result);\n        if (AuxChannelDataType.Vector === this.dataType) {\n            for (const data of this.data) {\n                const v = data.values;\n                for (let i = 0; i < v.length; i += 3)\n                    result.extendXYZ(v[i] * scale, v[i + 1] * scale, v[i + 2] * scale);\n            }\n        }\n        return result;\n    }\n}\n/**  The `PolyfaceAuxData` structure contains one or more analytical data channels for each vertex of a [[Polyface]], allowing the polyface to be styled\n * using an [AnalysisStyle]($common).\n * Typically a polyface will contain only vertex data required for its basic display: the vertex position, normal\n * and possibly texture parameter. `PolyfaceAuxData` provides supplemental data that is generally computed\n * in an analysis program or other external data source. This can be scalar data used to either override the vertex colors through, or\n * XYZ data used to deform the mesh by adjusting the vertex positions and/or normals.\n * @see [[PolyfaceData.auxData]] to associate auxiliary data with a polyface.\n * @public\n */\nexport class PolyfaceAuxData {\n    constructor(channels, indices) {\n        this.channels = channels;\n        this.indices = indices;\n    }\n    /** Return a deep copy. */\n    clone() {\n        const clonedChannels = this.channels.map((x) => x.clone());\n        return new PolyfaceAuxData(clonedChannels, this.indices.slice());\n    }\n    /** Returns true if `this` is equivalent to `other` within `tolerance`.\n     * The indices are compared for exact equality. The data in the channels are compared using `tolerance`, which defaults to 1.0e-8.\n     */\n    isAlmostEqual(other, tolerance) {\n        if (!NumberArray.isExactEqual(this.indices, other.indices) || this.channels.length !== other.channels.length)\n            return false;\n        for (let i = 0; i < this.channels.length; i++)\n            if (!this.channels[i].isAlmostEqual(other.channels[i], tolerance))\n                return false;\n        return true;\n    }\n    /** Returns true if both `left` and `right` are undefined, or both are defined and equivalent within `tolerance` (default: 1.0e-8). */\n    static isAlmostEqual(left, right, tol) {\n        if (left === right) // This catches double undefined !!!\n            return true;\n        if (left && right)\n            return left.isAlmostEqual(right, tol);\n        return false;\n    }\n    /** Create a PolyfaceAuxData for use by a [[PolyfaceVisitor]].  */\n    createForVisitor() {\n        const visitorChannels = [];\n        for (const parentChannel of this.channels) {\n            const visitorChannelData = [];\n            for (const parentChannelData of parentChannel.data)\n                visitorChannelData.push(new AuxChannelData(parentChannelData.input, []));\n            visitorChannels.push(new AuxChannel(visitorChannelData, parentChannel.dataType, parentChannel.name, parentChannel.inputName));\n        }\n        return new PolyfaceAuxData(visitorChannels, []);\n    }\n    /** Apply `transform` to the data in each channel.\n     * @see [[AuxChannelDataType]] for details regarding how each data type is affected by the transform.\n     * @note This method may fail if a channel of [[AuxChannelDataType.Normal]] exists and `transform.matrix` is non-invertible.\n     * @returns true if the channels were all successfully transformed.\n     */\n    tryTransformInPlace(transform) {\n        let inverseRot;\n        const rot = transform.matrix;\n        const det = rot.determinant();\n        const scale = Math.pow(Math.abs(det), 1 / 3) * (det >= 0 ? 1 : -1);\n        for (const channel of this.channels) {\n            for (const data of channel.data) {\n                switch (channel.dataType) {\n                    case AuxChannelDataType.Scalar:\n                        continue;\n                    case AuxChannelDataType.Distance: {\n                        for (let i = 0; i < data.values.length; i++)\n                            data.values[i] *= scale;\n                        break;\n                    }\n                    case AuxChannelDataType.Normal: {\n                        inverseRot = inverseRot ?? rot.inverse();\n                        if (!inverseRot)\n                            return false;\n                        transformPoints(data.values, (point) => inverseRot.multiplyTransposeVectorInPlace(point));\n                        break;\n                    }\n                    case AuxChannelDataType.Vector: {\n                        transformPoints(data.values, (point) => rot.multiplyVectorInPlace(point));\n                        break;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n}\nfunction transformPoints(coords, transform) {\n    const point = new Point3d();\n    for (let i = 0; i < coords.length; i += 3) {\n        point.set(coords[i], coords[i + 1], coords[i + 2]);\n        transform(point);\n        coords[i] = point.x;\n        coords[i + 1] = point.y;\n        coords[i + 2] = point.z;\n    }\n}\n//# sourceMappingURL=AuxData.js.map",
      "start": 1693508123039,
      "end": 1693508123201,
      "sourcemaps": null
    }
  ]
}
