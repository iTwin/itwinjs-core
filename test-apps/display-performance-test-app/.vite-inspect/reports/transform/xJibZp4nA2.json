{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/serialization/BGFBWriter.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Serialization\n */\nimport { flatbuffers } from \"flatbuffers\";\nimport { BGFBAccessors } from \"./BGFBAccessors\";\nimport { CurvePrimitive } from \"../curve/CurvePrimitive\";\nimport { LineSegment3d } from \"../curve/LineSegment3d\";\nimport { Arc3d } from \"../curve/Arc3d\";\nimport { LineString3d } from \"../curve/LineString3d\";\nimport { GrowableXYZArray } from \"../geometry3d/GrowableXYZArray\";\nimport { IndexedPolyface } from \"../polyface/Polyface\";\nimport { CurveCollection } from \"../curve/CurveCollection\";\nimport { ParityRegion } from \"../curve/ParityRegion\";\nimport { Loop } from \"../curve/Loop\";\nimport { UnionRegion } from \"../curve/UnionRegion\";\nimport { Path } from \"../curve/Path\";\nimport { BSplineCurve3d } from \"../bspline/BSplineCurve\";\nimport { BSplineCurve3dH } from \"../bspline/BSplineCurve3dH\";\nimport { SolidPrimitive } from \"../solid/SolidPrimitive\";\nimport { Box } from \"../solid/Box\";\nimport { Sphere } from \"../solid/Sphere\";\nimport { LinearSweep } from \"../solid/LinearSweep\";\nimport { RotationalSweep } from \"../solid/RotationalSweep\";\nimport { RuledSweep } from \"../solid/RuledSweep\";\nimport { TorusPipe } from \"../solid/TorusPipe\";\nimport { Cone } from \"../solid/Cone\";\nimport { GeometryQuery } from \"../curve/GeometryQuery\";\nimport { BSplineSurface3d, BSplineSurface3dH, UVSelect } from \"../bspline/BSplineSurface\";\nimport { PointString3d } from \"../curve/PointString3d\";\nimport { XYZ } from \"../geometry3d/Point3dVector3d\";\nimport { AuxChannel, AuxChannelData, PolyfaceAuxData } from \"../polyface/AuxData\";\nimport { TransitionSpiral3d } from \"../curve/spiral/TransitionSpiral3d\";\nimport { IntegratedSpiral3d } from \"../curve/spiral/IntegratedSpiral3d\";\nimport { DgnSpiralTypeQueries } from \"./BGFBReader\";\nimport { DirectSpiral3d } from \"../curve/spiral/DirectSpiral3d\";\nimport { InterpolationCurve3d } from \"../bspline/InterpolationCurve3d\";\nimport { AkimaCurve3d } from \"../bspline/AkimaCurve3d\";\n/**\n * Context to write to a flatbuffer blob.\n *  * This class is internal.\n *  * Public access is through BentleyGeometryFlatBuffer.geometryToBytes()\n * @internal\n */\nexport class BGFBWriter {\n    constructor(defaultSize = 1024) {\n        this.builder = new flatbuffers.Builder(defaultSize);\n    }\n    /**\n     *\n     * @param data data source, as Float64Array or number[].\n     * @param count optional count, used only if less than .length numbers are to be written.\n     */\n    writeDoubleArray(data, count) {\n        if (data === undefined)\n            return 0;\n        let numFloats = data.length;\n        if (numFloats === 0)\n            return 0;\n        if (count !== undefined && count < numFloats)\n            numFloats = count;\n        this.builder.startVector(8, numFloats, 8);\n        for (let i = numFloats - 1; i >= 0; i--) {\n            this.builder.addFloat64(data[i]);\n        }\n        return this.builder.endVector();\n    }\n    /**\n     *\n     * @param data data source, as Float64Array or number[].\n     * @param count optional count, used only if less than .length numbers are to be written.\n     */\n    writeIntArray(data) {\n        if (data === undefined)\n            return 0;\n        const numInt = data.length;\n        if (numInt === 0)\n            return 0;\n        this.builder.startVector(4, numInt, 4);\n        for (let i = numInt - 1; i >= 0; i--) {\n            this.builder.addInt32(data[i]);\n        }\n        return this.builder.endVector();\n    }\n    /**\n     *\n     * @param data data source, as array derived from XYZ.\n     * The data is output as a flat array of 3*data.length numbers.\n     */\n    writePackedYZArray(data) {\n        if (data === undefined)\n            return 0;\n        const numFloats = data.length * 3;\n        if (numFloats === 0)\n            return 0;\n        this.builder.startVector(8, numFloats, 8);\n        // write in reverse index order, and zyx within each XYZ\n        for (let i = data.length - 1; i >= 0; i--) {\n            this.builder.addFloat64(data[i].z);\n            this.builder.addFloat64(data[i].y);\n            this.builder.addFloat64(data[i].x);\n        }\n        return this.builder.endVector();\n    }\n    writeCurveCollectionAsFBCurveVector(cv) {\n        const childrenOffsets = [];\n        for (const child of cv.children) {\n            if (child instanceof CurvePrimitive) {\n                const childOffset = this.writeCurvePrimitiveAsFBVariantGeometry(child);\n                if (childOffset)\n                    childrenOffsets.push(childOffset);\n            }\n            else if (child instanceof CurveCollection) {\n                const childOffset = this.writeCurveCollectionAsFBVariantGeometry(child);\n                if (childOffset)\n                    childrenOffsets.push(childOffset);\n            }\n        }\n        const childrenVectorOffset = BGFBAccessors.CurveVector.createCurvesVector(this.builder, childrenOffsets);\n        let cvType = 0;\n        if (cv instanceof Path)\n            cvType = 1;\n        else if (cv instanceof Loop) {\n            cvType = cv.isInner ? 3 : 2;\n        }\n        else if (cv instanceof ParityRegion)\n            cvType = 4;\n        else if (cv instanceof UnionRegion)\n            cvType = 5;\n        const curveVectorOffset = BGFBAccessors.CurveVector.createCurveVector(this.builder, cvType, childrenVectorOffset);\n        return curveVectorOffset;\n    }\n    writeCurveCollectionAsFBVariantGeometry(cv) {\n        const curveVectorOffset = this.writeCurveCollectionAsFBCurveVector(cv);\n        if (curveVectorOffset === undefined)\n            return undefined;\n        return BGFBAccessors.VariantGeometry.createVariantGeometry(this.builder, BGFBAccessors.VariantGeometryUnion.tagCurveVector, curveVectorOffset, 0);\n    }\n    writeInterpolationCurve3dAsFBVariantGeometry(curve) {\n        const props = curve.cloneProps();\n        const fitPointsOffset = this.writeDoubleArray(curve.copyFitPointsFloat64Array());\n        const knotOffset = props.knots ? this.writeDoubleArray(props.knots) : 0;\n        // REMARK: some native or flatbuffer quirk made startTangent a point and endTangent a vector.\n        BGFBAccessors.InterpolationCurve.startInterpolationCurve(this.builder);\n        BGFBAccessors.InterpolationCurve.addFitPoints(this.builder, fitPointsOffset);\n        if (props.order)\n            BGFBAccessors.InterpolationCurve.addOrder(this.builder, props.order);\n        if (props.closed)\n            BGFBAccessors.InterpolationCurve.addClosed(this.builder, props.closed);\n        if (props.isChordLenKnots)\n            BGFBAccessors.InterpolationCurve.addIsChordLenKnots(this.builder, props.isChordLenKnots);\n        if (props.isColinearTangents)\n            BGFBAccessors.InterpolationCurve.addIsColinearTangents(this.builder, props.isColinearTangents);\n        if (props.isChordLenKnots)\n            BGFBAccessors.InterpolationCurve.addIsChordLenKnots(this.builder, props.isChordLenKnots);\n        if (props.isNaturalTangents)\n            BGFBAccessors.InterpolationCurve.addIsNaturalTangents(this.builder, props.isNaturalTangents);\n        if (props.startTangent !== undefined) {\n            const startTangentOffset = BGFBAccessors.DPoint3d.createDPoint3d(this.builder, XYZ.x(props.startTangent), XYZ.y(props.startTangent), XYZ.z(props.startTangent));\n            BGFBAccessors.InterpolationCurve.addStartTangent(this.builder, startTangentOffset);\n        }\n        if (props.endTangent !== undefined) {\n            const endTangentOffset = BGFBAccessors.DPoint3d.createDPoint3d(this.builder, XYZ.x(props.endTangent), XYZ.y(props.endTangent), XYZ.z(props.endTangent));\n            BGFBAccessors.InterpolationCurve.addEndTangent(this.builder, endTangentOffset);\n        }\n        if (knotOffset !== 0)\n            BGFBAccessors.InterpolationCurve.addKnots(this.builder, knotOffset);\n        const headerOffset = BGFBAccessors.InterpolationCurve.endInterpolationCurve(this.builder);\n        return BGFBAccessors.VariantGeometry.createVariantGeometry(this.builder, BGFBAccessors.VariantGeometryUnion.tagInterpolationCurve, headerOffset, 0);\n    }\n    writeAkimaCurve3dAsFBVariantGeometry(curve) {\n        const fitPointsOffset = this.writeDoubleArray(curve.copyFitPointsFloat64Array());\n        BGFBAccessors.AkimaCurve.startAkimaCurve(this.builder);\n        BGFBAccessors.AkimaCurve.addPoints(this.builder, fitPointsOffset);\n        const headerOffset = BGFBAccessors.AkimaCurve.endAkimaCurve(this.builder);\n        return BGFBAccessors.VariantGeometry.createVariantGeometry(this.builder, BGFBAccessors.VariantGeometryUnion.tagAkimaCurve, headerOffset, 0);\n    }\n    writeBsplineCurve3dAsFBVariantGeometry(bcurve) {\n        const order = bcurve.order;\n        const closed = false; // typescript bcurves are not closed.  There is API to impose wrapping . . .\n        const weightsOffset = 0;\n        const polesOffset = this.writeDoubleArray(bcurve.copyPointsFloat64Array());\n        if (polesOffset === undefined)\n            return undefined;\n        const knotsOffset = this.writeDoubleArray(bcurve.copyKnots(true));\n        const headerOffset = BGFBAccessors.BsplineCurve.createBsplineCurve(this.builder, order, closed, polesOffset, weightsOffset, knotsOffset);\n        return BGFBAccessors.VariantGeometry.createVariantGeometry(this.builder, BGFBAccessors.VariantGeometryUnion.tagBsplineCurve, headerOffset, 0);\n    }\n    writeBSplineSurfaceAsFBVariantGeometry(bsurf) {\n        const orderU = bsurf.orderUV(UVSelect.uDirection);\n        const orderV = bsurf.orderUV(UVSelect.VDirection);\n        const numPolesU = bsurf.numPolesUV(UVSelect.uDirection);\n        const numPolesV = bsurf.numPolesUV(UVSelect.VDirection);\n        const closedU = false;\n        const closedV = false;\n        const holeOrigin = 0;\n        const boundariesOffset = 0;\n        let polesOffset = 0;\n        let weightsOffset = 0;\n        if (bsurf instanceof BSplineSurface3d) {\n            polesOffset = this.writeDoubleArray(bsurf.copyPointsFloat64Array());\n        }\n        else if (bsurf instanceof BSplineSurface3dH) {\n            polesOffset = this.writeDoubleArray(bsurf.copyXYZToFloat64Array(false));\n            weightsOffset = this.writeDoubleArray(bsurf.copyWeightsToFloat64Array());\n        }\n        const uKnotsOffset = this.writeDoubleArray(bsurf.knots[0].copyKnots(true));\n        const vKnotsOffset = this.writeDoubleArray(bsurf.knots[1].copyKnots(true));\n        const headerOffset = BGFBAccessors.BsplineSurface.createBsplineSurface(this.builder, polesOffset, weightsOffset, uKnotsOffset, vKnotsOffset, numPolesU, numPolesV, orderU, orderV, 0, 0, holeOrigin, boundariesOffset, closedU, closedV);\n        return BGFBAccessors.VariantGeometry.createVariantGeometry(this.builder, BGFBAccessors.VariantGeometryUnion.tagBsplineSurface, headerOffset, 0);\n    }\n    writeBsplineCurve3dAHsFBVariantGeometry(bcurve) {\n        const order = bcurve.order;\n        const closed = false; // typescript bcurves are not closed.  There is API to impose wrapping . . .\n        const polesOffset = this.writeDoubleArray(bcurve.copyXYZFloat64Array(false));\n        const weightsOffset = this.writeDoubleArray(bcurve.copyWeightsFloat64Array());\n        const knotsOffset = this.writeDoubleArray(bcurve.copyKnots(true));\n        const headerOffset = BGFBAccessors.BsplineCurve.createBsplineCurve(this.builder, order, closed, polesOffset, weightsOffset, knotsOffset);\n        return BGFBAccessors.VariantGeometry.createVariantGeometry(this.builder, BGFBAccessors.VariantGeometryUnion.tagBsplineCurve, headerOffset, 0);\n    }\n    writeCurvePrimitiveAsFBVariantGeometry(curvePrimitive) {\n        if (curvePrimitive instanceof LineSegment3d) {\n            const segmentDataOffset = BGFBAccessors.DSegment3d.createDSegment3d(this.builder, curvePrimitive.point0Ref.x, curvePrimitive.point0Ref.y, curvePrimitive.point0Ref.z, curvePrimitive.point1Ref.x, curvePrimitive.point1Ref.y, curvePrimitive.point1Ref.z);\n            const lineSegmentOffset = BGFBAccessors.LineSegment.createLineSegment(this.builder, segmentDataOffset);\n            return BGFBAccessors.VariantGeometry.createVariantGeometry(this.builder, BGFBAccessors.VariantGeometryUnion.tagLineSegment, lineSegmentOffset, 0);\n        }\n        else if (curvePrimitive instanceof Arc3d) {\n            const data = curvePrimitive.toVectors();\n            const arcDataOffset = BGFBAccessors.DEllipse3d.createDEllipse3d(this.builder, data.center.x, data.center.y, data.center.z, data.vector0.x, data.vector0.y, data.vector0.z, data.vector90.x, data.vector90.y, data.vector90.z, data.sweep.startRadians, data.sweep.sweepRadians);\n            const arcOffset = BGFBAccessors.EllipticArc.createEllipticArc(this.builder, arcDataOffset);\n            return BGFBAccessors.VariantGeometry.createVariantGeometry(this.builder, BGFBAccessors.VariantGeometryUnion.tagEllipticArc, arcOffset, 0);\n        }\n        else if (curvePrimitive instanceof LineString3d) {\n            const coordinates = extractNumberArray(curvePrimitive.packedPoints);\n            const lineStringOffset = BGFBAccessors.LineString.createLineString(this.builder, BGFBAccessors.LineString.createPointsVector(this.builder, coordinates));\n            return BGFBAccessors.VariantGeometry.createVariantGeometry(this.builder, BGFBAccessors.VariantGeometryUnion.tagLineString, lineStringOffset, 0);\n        }\n        else if (curvePrimitive instanceof BSplineCurve3d) {\n            return this.writeBsplineCurve3dAsFBVariantGeometry(curvePrimitive);\n        }\n        else if (curvePrimitive instanceof BSplineCurve3dH) {\n            return this.writeBsplineCurve3dAHsFBVariantGeometry(curvePrimitive);\n        }\n        else if (curvePrimitive instanceof InterpolationCurve3d) {\n            return this.writeInterpolationCurve3dAsFBVariantGeometry(curvePrimitive);\n        }\n        else if (curvePrimitive instanceof AkimaCurve3d) {\n            return this.writeAkimaCurve3dAsFBVariantGeometry(curvePrimitive);\n        }\n        else if (curvePrimitive instanceof IntegratedSpiral3d) {\n            const placement = curvePrimitive.localToWorld;\n            const typeCode = DgnSpiralTypeQueries.stringToTypeCode(curvePrimitive.spiralType, true);\n            const spiralDetailOffset = BGFBAccessors.TransitionSpiralDetail.createTransitionSpiralDetail(this.builder, placement.matrix.coffs[0], placement.matrix.coffs[1], placement.matrix.coffs[2], placement.origin.x, placement.matrix.coffs[3], placement.matrix.coffs[4], placement.matrix.coffs[5], placement.origin.y, placement.matrix.coffs[6], placement.matrix.coffs[5], placement.matrix.coffs[8], placement.origin.z, curvePrimitive.activeFractionInterval.x0, curvePrimitive.activeFractionInterval.x1, curvePrimitive.bearing01.startRadians, curvePrimitive.bearing01.endRadians, TransitionSpiral3d.radiusToCurvature(curvePrimitive.radius01.x0), TransitionSpiral3d.radiusToCurvature(curvePrimitive.radius01.x1), typeCode, 0);\n            const transitionTableOffset = BGFBAccessors.TransitionSpiral.createTransitionSpiral(this.builder, spiralDetailOffset, 0, 0);\n            return BGFBAccessors.VariantGeometry.createVariantGeometry(this.builder, BGFBAccessors.VariantGeometryUnion.tagTransitionSpiral, transitionTableOffset, 0);\n        }\n        else if (curvePrimitive instanceof DirectSpiral3d) {\n            const placement = curvePrimitive.localToWorld;\n            // direct spirals always inflect at the origin of the local frame ..\n            // spiral\n            const curvature0 = 0.0;\n            const curvature1 = curvePrimitive.nominalCurvature1;\n            const radius0 = 0.0;\n            const radius1 = curvePrimitive.nominalR1; // which is 1/curvature1\n            const nominalLength = curvePrimitive.nominalL1;\n            const bearing0Radians = 0.0;\n            const bearing1Radians = TransitionSpiral3d.radiusRadiusLengthToSweepRadians(radius0, radius1, nominalLength);\n            const typeCode = DgnSpiralTypeQueries.stringToTypeCode(curvePrimitive.spiralType, true);\n            const spiralDetailOffset = BGFBAccessors.TransitionSpiralDetail.createTransitionSpiralDetail(this.builder, placement.matrix.coffs[0], placement.matrix.coffs[1], placement.matrix.coffs[2], placement.origin.x, placement.matrix.coffs[3], placement.matrix.coffs[4], placement.matrix.coffs[5], placement.origin.y, placement.matrix.coffs[6], placement.matrix.coffs[5], placement.matrix.coffs[8], placement.origin.z, curvePrimitive.activeFractionInterval.x0, curvePrimitive.activeFractionInterval.x1, bearing0Radians, bearing1Radians, curvature0, curvature1, typeCode, 0);\n            const transitionTableOffset = BGFBAccessors.TransitionSpiral.createTransitionSpiral(this.builder, spiralDetailOffset, 0, 0);\n            return BGFBAccessors.VariantGeometry.createVariantGeometry(this.builder, BGFBAccessors.VariantGeometryUnion.tagTransitionSpiral, transitionTableOffset, 0);\n        }\n        return undefined;\n    }\n    writePointString3dAsFBVariantGeometry(pointString) {\n        if (pointString instanceof PointString3d) {\n            const coordinates = extractNumberArray(pointString.points);\n            const headerOffset = BGFBAccessors.PointString.createPointString(this.builder, BGFBAccessors.PointString.createPointsVector(this.builder, coordinates));\n            return BGFBAccessors.VariantGeometry.createVariantGeometry(this.builder, BGFBAccessors.VariantGeometryUnion.tagPointString, headerOffset, 0);\n        }\n        return undefined;\n    }\n    writeSolidPrimitiveAsFBVariantGeometry(solid) {\n        // NOTE: Box, Sphere, Cone, and TorusPipe have \"detail\" within a \"table\"\n        // BUT:  linear, rotational, and ruled sweeps have their contour and numerics directly within their table.\n        if (solid instanceof Box) {\n            const originA = solid.getBaseOrigin();\n            const originB = solid.getTopOrigin();\n            const vectorX = solid.getVectorX();\n            const vectorY = solid.getVectorY();\n            const baseX = solid.getBaseX();\n            const baseY = solid.getBaseY();\n            const topX = solid.getTopX();\n            const topY = solid.getTopY();\n            const detailOffset = BGFBAccessors.DgnBoxDetail.createDgnBoxDetail(this.builder, originA.x, originA.y, originA.z, originB.x, originB.y, originB.z, vectorX.x, vectorX.y, vectorX.z, vectorY.x, vectorY.y, vectorY.z, baseX, baseY, topX, topY, solid.capped);\n            const carrierOffset = BGFBAccessors.DgnBox.createDgnBox(this.builder, detailOffset);\n            return BGFBAccessors.VariantGeometry.createVariantGeometry(this.builder, BGFBAccessors.VariantGeometryUnion.tagDgnBox, carrierOffset, 0);\n        }\n        else if (solid instanceof Sphere) {\n            const localToWorld = solid.cloneLocalToWorld();\n            const sweep = solid.cloneLatitudeSweep();\n            const detailOffset = BGFBAccessors.DgnSphereDetail.createDgnSphereDetail(this.builder, localToWorld.matrix.coffs[0], localToWorld.matrix.coffs[1], localToWorld.matrix.coffs[2], localToWorld.origin.x, localToWorld.matrix.coffs[3], localToWorld.matrix.coffs[4], localToWorld.matrix.coffs[5], localToWorld.origin.y, localToWorld.matrix.coffs[6], localToWorld.matrix.coffs[7], localToWorld.matrix.coffs[8], localToWorld.origin.z, sweep.startRadians, sweep.sweepRadians, solid.capped);\n            const carrierOffset = BGFBAccessors.DgnSphere.createDgnSphere(this.builder, detailOffset);\n            return BGFBAccessors.VariantGeometry.createVariantGeometry(this.builder, BGFBAccessors.VariantGeometryUnion.tagDgnSphere, carrierOffset, 0);\n        }\n        else if (solid instanceof Cone) {\n            const centerA = solid.getCenterA();\n            const centerB = solid.getCenterB();\n            const vectorX = solid.getVectorX();\n            const vectorY = solid.getVectorY();\n            const radiusA = solid.getRadiusA();\n            const radiusB = solid.getRadiusB();\n            const detailOffset = BGFBAccessors.DgnConeDetail.createDgnConeDetail(this.builder, centerA.x, centerA.y, centerA.z, centerB.x, centerB.y, centerB.z, vectorX.x, vectorX.y, vectorX.z, vectorY.x, vectorY.y, vectorY.z, radiusA, radiusB, solid.capped);\n            const carrierOffset = BGFBAccessors.DgnCone.createDgnCone(this.builder, detailOffset);\n            return BGFBAccessors.VariantGeometry.createVariantGeometry(this.builder, BGFBAccessors.VariantGeometryUnion.tagDgnCone, carrierOffset, 0);\n        }\n        else if (solid instanceof TorusPipe) {\n            const center = solid.cloneCenter();\n            const vectorX = solid.cloneVectorX();\n            const vectorY = solid.cloneVectorY();\n            const minorRadius = solid.getMinorRadius();\n            const majorRadius = solid.getMajorRadius();\n            const sweepRadians = solid.getSweepAngle().radians;\n            const detailOffset = BGFBAccessors.DgnTorusPipeDetail.createDgnTorusPipeDetail(this.builder, center.x, center.y, center.z, vectorX.x, vectorX.y, vectorX.z, vectorY.x, vectorY.y, vectorY.z, majorRadius, minorRadius, sweepRadians, solid.capped);\n            const carrierOffset = BGFBAccessors.DgnTorusPipe.createDgnTorusPipe(this.builder, detailOffset);\n            return BGFBAccessors.VariantGeometry.createVariantGeometry(this.builder, BGFBAccessors.VariantGeometryUnion.tagDgnTorusPipe, carrierOffset, 0);\n        }\n        else if (solid instanceof LinearSweep) {\n            const baseCurveOffset = this.writeCurveCollectionAsFBCurveVector(solid.getSweepContourRef().getCurves());\n            const sweepVector = solid.cloneSweepVector();\n            // const sweepVectorOffset = BGFBAccessors.DVector3d.createDVector3d(this.builder, sweepVector.x, sweepVector.y, sweepVector.z);\n            // const carrierOffset = BGFBAccessors.DgnExtrusion.createDgnExtrusion(this.builder, contourOffset, sweepVectorOffset, solid.capped);\n            // WOW -- the machine generated createDgnExtrusion expects an offset for the sweepVector, but then\n            //  chokes trying to add it.\n            BGFBAccessors.DgnExtrusion.startDgnExtrusion(this.builder);\n            BGFBAccessors.DgnExtrusion.addBaseCurve(this.builder, baseCurveOffset);\n            const extrusionVectorOffset = BGFBAccessors.DVector3d.createDVector3d(this.builder, sweepVector.x, sweepVector.y, sweepVector.z);\n            BGFBAccessors.DgnExtrusion.addExtrusionVector(this.builder, extrusionVectorOffset);\n            BGFBAccessors.DgnExtrusion.addCapped(this.builder, solid.capped);\n            const dgnExtrusionOffset = BGFBAccessors.DgnExtrusion.endDgnExtrusion(this.builder);\n            return BGFBAccessors.VariantGeometry.createVariantGeometry(this.builder, BGFBAccessors.VariantGeometryUnion.tagDgnExtrusion, dgnExtrusionOffset, 0);\n        }\n        else if (solid instanceof RotationalSweep) {\n            const baseCurveOffset = this.writeCurveCollectionAsFBCurveVector(solid.getSweepContourRef().getCurves());\n            const axis = solid.cloneAxisRay();\n            const sweepAngle = solid.getSweep();\n            // const sweepVectorOffset = BGFBAccessors.DVector3d.createDVector3d(this.builder, sweepVector.x, sweepVector.y, sweepVector.z);\n            // const carrierOffset = BGFBAccessors.DgnExtrusion.createDgnExtrusion(this.builder, contourOffset, sweepVectorOffset, solid.capped);\n            // WOW -- the machine generated createDgnExtrusion expects an offset for the sweepVector, but then\n            //  chokes trying to add it.\n            BGFBAccessors.DgnRotationalSweep.startDgnRotationalSweep(this.builder);\n            BGFBAccessors.DgnRotationalSweep.addBaseCurve(this.builder, baseCurveOffset);\n            const axisRayOffset = BGFBAccessors.DRay3d.createDRay3d(this.builder, axis.origin.x, axis.origin.y, axis.origin.z, axis.direction.x, axis.direction.y, axis.direction.z);\n            BGFBAccessors.DgnRotationalSweep.addAxis(this.builder, axisRayOffset);\n            BGFBAccessors.DgnRotationalSweep.addSweepRadians(this.builder, sweepAngle.radians);\n            BGFBAccessors.DgnRotationalSweep.addCapped(this.builder, solid.capped);\n            const dgnRotationalSweepOffset = BGFBAccessors.DgnRotationalSweep.endDgnRotationalSweep(this.builder);\n            return BGFBAccessors.VariantGeometry.createVariantGeometry(this.builder, BGFBAccessors.VariantGeometryUnion.tagDgnRotationalSweep, dgnRotationalSweepOffset, 0);\n        }\n        else if (solid instanceof RuledSweep) {\n            const contours = solid.sweepContoursRef();\n            const contourOffsets = [];\n            for (const contour of contours) {\n                const contourOffset = this.writeCurveCollectionAsFBCurveVector(contour.getCurves());\n                if (contourOffset !== undefined)\n                    contourOffsets.push(contourOffset);\n            }\n            const contoursVectorOffset = BGFBAccessors.DgnRuledSweep.createCurvesVector(this.builder, contourOffsets);\n            const ruledSweepTable = BGFBAccessors.DgnRuledSweep.createDgnRuledSweep(this.builder, contoursVectorOffset, solid.capped);\n            return BGFBAccessors.VariantGeometry.createVariantGeometry(this.builder, BGFBAccessors.VariantGeometryUnion.tagDgnRuledSweep, ruledSweepTable, 0);\n        }\n        return undefined;\n    }\n    writePolyfaceAuxChannelDataAsFBVariantGeometry(channelData) {\n        if (channelData instanceof AuxChannelData) {\n            const valuesOffset = BGFBAccessors.PolyfaceAuxChannelData.createValuesVector(this.builder, channelData.values);\n            return BGFBAccessors.PolyfaceAuxChannelData.createPolyfaceAuxChannelData(this.builder, channelData.input, valuesOffset);\n        }\n        return undefined;\n    }\n    writePolyfaceAuxChannelAsFBVariantGeometry(channel) {\n        if (channel instanceof AuxChannel) {\n            const channelDataOffsets = [];\n            for (const channelData of channel.data) {\n                channelDataOffsets.push(this.writePolyfaceAuxChannelDataAsFBVariantGeometry(channelData));\n            }\n            const valuesOffset = BGFBAccessors.PolyfaceAuxChannel.createDataVector(this.builder, channelDataOffsets);\n            const nameOffset = channel.name ? this.builder.createString(channel.name) : 0;\n            const inputNameOffset = channel.inputName ? this.builder.createString(channel.inputName) : 0;\n            return BGFBAccessors.PolyfaceAuxChannel.createPolyfaceAuxChannel(this.builder, channel.dataType, nameOffset, inputNameOffset, valuesOffset);\n        }\n        return undefined;\n    }\n    writePolyfaceAuxDataAsFBVariantGeometry(data) {\n        if (data instanceof PolyfaceAuxData) {\n            const channelOffsets = [];\n            for (const channel of data.channels) {\n                channelOffsets.push(this.writePolyfaceAuxChannelAsFBVariantGeometry(channel));\n            }\n            const channelOffsetsOffset = BGFBAccessors.PolyfaceAuxChannel.createDataVector(this.builder, channelOffsets);\n            const indicesOffset = BGFBAccessors.PolyfaceAuxData.createIndicesVector(this.builder, data.indices);\n            return BGFBAccessors.PolyfaceAuxData.createPolyfaceAuxData(this.builder, indicesOffset, channelOffsetsOffset);\n        }\n        return undefined;\n    }\n    writeTaggedNumericDataArray(data) {\n        if (data) {\n            const intDataOffset = this.writeIntArray(data.intData);\n            const doubleDataOffset = this.writeDoubleArray(data.doubleData);\n            return BGFBAccessors.TaggedNumericData.createTaggedNumericData(this.builder, data.tagA, data.tagB, intDataOffset, doubleDataOffset);\n        }\n        return 0;\n    }\n    writePolyfaceAsFBVariantGeometry(mesh) {\n        if (mesh instanceof IndexedPolyface) {\n            // WE KNOW . . . . the polyface has blocks of zero-based indices.\n            const indexArray = []; // and this will really be integers.\n            const numberArray = []; // and this will really be doubles.\n            copyToPackedNumberArray(numberArray, mesh.data.point.float64Data(), mesh.data.point.float64Length);\n            const pointOffset = BGFBAccessors.Polyface.createPointVector(this.builder, numberArray);\n            let paramIndexOffset = 0;\n            let normalIndexOffset = 0;\n            let colorIndexOffset = 0;\n            let intColorOffset = 0;\n            let normalOffset = 0;\n            let paramOffset = 0;\n            let auxDataOffset = 0;\n            let taggedNumericDataOffset = 0;\n            const meshStyle = 1; // That is  . . . MESH_ELM_STYLE_INDEXED_FACE_LOOPS (and specifically, variable size with with 0 terminators)\n            const numPerFace = 0;\n            this.fillOneBasedIndexArray(mesh, mesh.data.pointIndex, mesh.data.edgeVisible, 0, indexArray);\n            const twoSided = mesh.twoSided;\n            const pointIndexOffset = BGFBAccessors.Polyface.createPointIndexVector(this.builder, indexArray);\n            if (mesh.data.paramIndex !== undefined && mesh.data.paramIndex.length > 0) {\n                this.fillOneBasedIndexArray(mesh, mesh.data.paramIndex, undefined, 0, indexArray);\n                paramIndexOffset = BGFBAccessors.Polyface.createParamIndexVector(this.builder, indexArray);\n            }\n            if (mesh.data.normalIndex !== undefined && mesh.data.normalIndex.length > 0) {\n                this.fillOneBasedIndexArray(mesh, mesh.data.normalIndex, undefined, 0, indexArray);\n                normalIndexOffset = BGFBAccessors.Polyface.createNormalIndexVector(this.builder, indexArray);\n            }\n            if (mesh.data.colorIndex !== undefined && mesh.data.colorIndex.length > 0) {\n                this.fillOneBasedIndexArray(mesh, mesh.data.colorIndex, undefined, 0, indexArray);\n                colorIndexOffset = BGFBAccessors.Polyface.createColorIndexVector(this.builder, indexArray);\n            }\n            if (mesh.data.color !== undefined && mesh.data.color.length > 0) {\n                intColorOffset = BGFBAccessors.Polyface.createIntColorVector(this.builder, mesh.data.color);\n            }\n            /*\n                  if (mesh.data.face !== undefined && mesh.data.face.length > 0) {\n                    this.writeOneBasedIndexArray(mesh, mesh.data.face, undefined, 0, indexArray);\n                    BGFBAccessors.Polyface.createFaceDataVector(this.builder, indexArray);\n                  }\n              */\n            if (mesh.data.normal) {\n                copyToPackedNumberArray(numberArray, mesh.data.normal.float64Data(), mesh.data.normal.float64Length);\n                normalOffset = BGFBAccessors.Polyface.createNormalVector(this.builder, numberArray);\n            }\n            if (mesh.data.param) {\n                copyToPackedNumberArray(numberArray, mesh.data.param.float64Data(), mesh.data.param.float64Length);\n                paramOffset = BGFBAccessors.Polyface.createPointVector(this.builder, numberArray);\n            }\n            if (mesh.data.auxData) {\n                auxDataOffset = this.writePolyfaceAuxDataAsFBVariantGeometry(mesh.data.auxData);\n            }\n            if (mesh.data.taggedNumericData)\n                taggedNumericDataOffset = this.writeTaggedNumericDataArray(mesh.data.taggedNumericData);\n            const expectedClosure = mesh.expectedClosure;\n            const polyfaceOffset = BGFBAccessors.Polyface.createPolyface(this.builder, pointOffset, paramOffset, normalOffset, 0, intColorOffset, pointIndexOffset, paramIndexOffset, normalIndexOffset, colorIndexOffset, 0, 0, 0, meshStyle, twoSided, numPerFace, 0, auxDataOffset, expectedClosure, taggedNumericDataOffset);\n            return BGFBAccessors.VariantGeometry.createVariantGeometry(this.builder, BGFBAccessors.VariantGeometryUnion.tagPolyface, polyfaceOffset, 0);\n        }\n        return undefined;\n    }\n    fillOneBasedIndexArray(mesh, sourceIndex, visible, facetTerminator, destIndex) {\n        destIndex.length = 0;\n        const numFacet = mesh.facetCount;\n        for (let facetIndex = 0; facetIndex < numFacet; facetIndex++) {\n            const k0 = mesh.facetIndex0(facetIndex);\n            const k1 = mesh.facetIndex1(facetIndex);\n            for (let k = k0; k < k1; k++) {\n                let q = sourceIndex[k] + 1;\n                if (visible !== undefined && !visible[k])\n                    q = -q;\n                destIndex.push(q);\n            }\n            if (facetTerminator !== undefined)\n                destIndex.push(facetTerminator);\n        }\n    }\n    writeGeometryQueryAsFBVariantGeometry(g) {\n        let offset;\n        if (g instanceof CurvePrimitive && (offset = this.writeCurvePrimitiveAsFBVariantGeometry(g)) !== undefined)\n            return offset;\n        if (g instanceof CurveCollection && (offset = this.writeCurveCollectionAsFBVariantGeometry(g)) !== undefined)\n            return offset;\n        if (g instanceof IndexedPolyface && (offset = this.writePolyfaceAsFBVariantGeometry(g)) !== undefined)\n            return offset;\n        if (g instanceof SolidPrimitive && (offset = this.writeSolidPrimitiveAsFBVariantGeometry(g)) !== undefined)\n            return offset;\n        if (g instanceof BSplineSurface3d && (offset = this.writeBSplineSurfaceAsFBVariantGeometry(g)) !== undefined)\n            return offset;\n        if (g instanceof BSplineSurface3dH && (offset = this.writeBSplineSurfaceAsFBVariantGeometry(g)) !== undefined)\n            return offset;\n        if (g instanceof PointString3d && (offset = this.writePointString3dAsFBVariantGeometry(g)) !== undefined)\n            return offset;\n        // if (g instanceof CoordinateXYZ) // TODO\n        return undefined;\n    }\n    writeGeometryQueryArrayAsFBVariantGeometry(allGeometry) {\n        if (Array.isArray(allGeometry)) {\n            const allOffsets = [];\n            for (const g of allGeometry) {\n                const offset = this.writeGeometryQueryAsFBVariantGeometry(g);\n                if (offset !== undefined)\n                    allOffsets.push(offset);\n            }\n            if (allOffsets.length > 0) {\n                const membersOffset = BGFBAccessors.VectorOfVariantGeometry.createMembersVector(this.builder, allOffsets);\n                const vectorOffset = BGFBAccessors.VectorOfVariantGeometry.createVectorOfVariantGeometry(this.builder, membersOffset);\n                return BGFBAccessors.VariantGeometry.createVariantGeometry(this.builder, BGFBAccessors.VariantGeometryUnion.tagVectorOfVariantGeometry, vectorOffset, 0);\n            }\n        }\n        else if (allGeometry instanceof GeometryQuery)\n            return this.writeGeometryQueryAsFBVariantGeometry(allGeometry);\n        return undefined;\n    }\n    /**\n     * Serialize bytes to a flatbuffer.\n     */\n    static geometryToBytes(data, signatureBytes) {\n        const writer = new BGFBWriter();\n        const rootOffset = writer.writeGeometryQueryArrayAsFBVariantGeometry(data);\n        if (rootOffset !== undefined) {\n            const builder = writer.builder;\n            builder.finish(rootOffset);\n            const buffer = builder.dataBuffer();\n            if (!signatureBytes) {\n                return buffer.bytes().slice(buffer.position());\n            }\n            else if (buffer.position() >= signatureBytes.length) {\n                // The buffer has space for the signature ahead of its position . . .\n                const i0 = buffer.position() - signatureBytes.length;\n                let i = i0;\n                for (const k of signatureBytes)\n                    buffer.bytes()[i++] = k;\n                return buffer.bytes().slice(i0);\n            }\n            else {\n                // There is no space ahead of the position () . . .\n                // coverage remark: I have never seen this happen for real.\n                //  It has been exercised by adding 1024 to the signatureBytes.length test to force this branch.\n                const num1 = buffer.bytes().length - buffer.position();\n                const num0 = signatureBytes.length;\n                const newBytes = new Uint8Array(num0 + num1);\n                newBytes.set(signatureBytes, 0);\n                newBytes.set(buffer.bytes().slice(buffer.position()), num0);\n                return newBytes;\n            }\n        }\n        return undefined;\n    }\n}\nfunction extractNumberArray(data) {\n    const result = [];\n    if (data instanceof GrowableXYZArray) {\n        // ugh -- accessors only deal with number[] ..\n        const numCoordinate = 3 * data.length;\n        const source = data.float64Data();\n        for (let i = 0; i < numCoordinate; i++)\n            result.push(source[i]);\n        return result;\n    }\n    else if (Array.isArray(data)) {\n        for (const xyz of data)\n            result.push(xyz.x, xyz.y, xyz.z);\n    }\n    return result;\n}\n/** Copy the active data to a simple number array. */\nfunction copyToPackedNumberArray(dest, source, count) {\n    dest.length = 0;\n    for (let i = 0; i < count; i++)\n        dest.push(source[i]);\n}\n//# sourceMappingURL=BGFBWriter.js.map",
      "start": 1693508124381,
      "end": 1693508124510,
      "sourcemaps": null
    }
  ]
}
