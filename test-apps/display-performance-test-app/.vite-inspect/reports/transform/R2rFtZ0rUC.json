{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/common/lib/esm/ipc/IpcWebSocketTransport.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module IpcSocket\n */\nimport { IpcWebSocketMessage } from \"./IpcWebSocket\";\nfunction isBuffer(val) {\n    return val && typeof (val.constructor) !== \"undefined\" && typeof (val.constructor.isBuffer) === \"function\" && val.constructor.isBuffer(val);\n}\nlet parts = [];\n/** @internal */\nexport class IpcWebSocketTransport {\n    constructor() {\n        this._received = [];\n        this._outstanding = 0;\n    }\n    unwrap(data) {\n        return (typeof (Blob) !== \"undefined\" && data instanceof Blob) ? data.arrayBuffer() : data;\n    }\n    async notifyIncoming(data, connection) {\n        if (this._partial) {\n            this._received.push(data);\n            --this._outstanding;\n            if (this._outstanding === 0) {\n                const partial = this._partial;\n                const received = this._received;\n                this._partial = undefined;\n                this._received = [];\n                await Promise.all(received.map(async (v, i, a) => a[i] = await this.unwrap(v)));\n                parts = received;\n                const message = JSON.parse(partial, reviver);\n                parts.length = 0;\n                return InSentOrder.deliver(message, connection);\n            }\n            else {\n                return IpcWebSocketMessage.internal();\n            }\n        }\n        else {\n            const [serialized, followers] = JSON.parse(data);\n            if (followers) {\n                this._partial = serialized;\n                this._outstanding = followers;\n                return IpcWebSocketMessage.internal();\n            }\n            else {\n                const message = JSON.parse(serialized, reviver);\n                return InSentOrder.deliver(message, connection);\n            }\n        }\n    }\n    serialize(data) {\n        parts.length = 0;\n        const objects = JSON.stringify(data, replacer);\n        const value = [JSON.stringify([objects, parts.length]), ...parts];\n        parts.length = 0;\n        return value;\n    }\n    notifyClose(connection) {\n        InSentOrder.close(connection);\n    }\n}\nconst types = [Uint8Array, Int8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array, DataView];\nfunction identify(value) {\n    return isBuffer(value) ? 0 : types.indexOf(value.constructor);\n}\nfunction lookup(value) {\n    return types[value.type];\n}\nfunction replacer(_key, value) {\n    const asBinary = replaceBinary(value);\n    if (asBinary) {\n        return asBinary;\n    }\n    return value;\n}\nfunction reviver(_key, value) {\n    if (typeof (value) === \"object\" && value !== null && value.hasOwnProperty(\"ipc\") && value.ipc === \"binary\") {\n        return reviveBinary(value);\n    }\n    return value;\n}\nfunction replaceBinary(value) {\n    if (ArrayBuffer.isView(value) || isBuffer(value)) {\n        const index = parts.push(value) - 1;\n        const type = identify(value);\n        return { ipc: \"binary\", type, index };\n    }\n    else {\n        return undefined;\n    }\n}\nfunction reviveBinary(value) {\n    const constructor = lookup(value);\n    const part = parts[value.index];\n    return new constructor(part);\n}\nfunction makePromise() {\n    let resolve = () => { };\n    let reject = () => { };\n    const promise = new Promise((res, rej) => {\n        resolve = res;\n        reject = rej;\n    });\n    return { promise, resolve, reject };\n}\n/* Reconstructing the sequence in which messages were sent is necessary since\n   the binary data for a message has to be awaited in IpcWebSocketTransport.unwrap. */\nclass InSentOrder {\n    static async deliver(message, connection) {\n        let context = this._connections.get(connection);\n        if (!context) {\n            context = { queue: [], last: -1 };\n            this._connections.set(connection, context);\n        }\n        const entry = new InSentOrder(message);\n        context.queue.push(entry);\n        context.queue.sort((a, b) => a.sequence - b.sequence);\n        while (context.queue.length !== 0) {\n            const next = context.queue[0];\n            const duplicate = next.sequence <= context.last;\n            const match = next.sequence === (context.last + 1);\n            if (duplicate) {\n                next.duplicate = true;\n            }\n            else if (match) {\n                ++context.last;\n            }\n            if (duplicate || match) {\n                context.queue.shift();\n                next.release();\n            }\n            else {\n                break;\n            }\n        }\n        return entry.message;\n    }\n    static close(connection) {\n        this._connections.delete(connection);\n    }\n    constructor(message) {\n        this.release = () => { };\n        this.duplicate = false;\n        this.sequence = message.sequence;\n        const { promise, resolve } = makePromise();\n        this.message = promise;\n        this.release = () => {\n            const value = this.duplicate ? IpcWebSocketMessage.duplicate() : message;\n            resolve(value);\n        };\n    }\n}\nInSentOrder._connections = new Map();\n//# sourceMappingURL=IpcWebSocketTransport.js.map",
      "start": 1693508120676,
      "end": 1693508120729,
      "sourcemaps": null
    }
  ]
}
