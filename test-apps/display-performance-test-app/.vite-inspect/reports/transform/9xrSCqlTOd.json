{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/orbitgt/lib/esm/spatial/ecrs/WellKnownTextNode.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module OrbitGT\n */\nimport { AList } from \"../../system/collection/AList\";\nimport { ASystem } from \"../../system/runtime/ASystem\";\nimport { Strings } from \"../../system/runtime/Strings\";\n/**\n * Class WellKnownTextNode defines a node in a well-known-text expression.\n *\n * @version 1.0 December 2010\n */\n/** @internal */\nexport class WellKnownTextNode {\n    /**\n     * Create a new node.\n     * @param name the name.\n     * @param argumentList the arguments.\n     */\n    constructor(name, argumentList) {\n        if (argumentList == null)\n            argumentList = new AList();\n        this._name = name;\n        this._argumentList = argumentList;\n    }\n    /**\n     * Get the name.\n     * @return the name.\n     */\n    getName() {\n        return this._name;\n    }\n    /**\n     * Get the arguments.\n     * @return the arguments.\n     */\n    getArguments() {\n        return this._argumentList;\n    }\n    /**\n     * Add an argument.\n     * @param argument the argument to add.\n     */\n    addArgument(argument) {\n        this._argumentList.add(argument);\n    }\n    /**\n     * Get an argument.\n     * @param index the index of the argument.\n     * @return the argument.\n     */\n    getArgument(index) {\n        return this._argumentList.get(index);\n    }\n    /**\n     * Get an optional argument.\n     * @param index the index of the argument.\n     * @return the argument.\n     */\n    getOptionalArgument(index) {\n        if (index < this._argumentList.size())\n            return this.getArgument(index);\n        return null;\n    }\n    /**\n     * Get arguments by name.\n     * @param name the name of the arguments.\n     * @return the arguments.\n     */\n    getArgumentsByName(name) {\n        let list = new AList();\n        for (let argument of this._argumentList)\n            if (Strings.equalsIgnoreCase(argument.getName(), name))\n                list.add(argument);\n        return list;\n    }\n    /**\n     * Get an argument by name.\n     * @param name the name of the argument.\n     * @return the argument (null if not found).\n     */\n    getArgumentByName(name) {\n        let list = this.getArgumentsByName(name);\n        return (list.size() == 0) ? null : list.get(0);\n    }\n    /**\n     * Parse an expression.\n     * @param expression the expression.\n     * @return the parsed expression.\n     */\n    static parse(expression) {\n        /* Literal ? */\n        if ((Strings.getLength(expression) >= 2) && Strings.startsWith(expression, \"\\\"\") && Strings.endsWith(expression, \"\\\"\"))\n            return new WellKnownTextNode(expression, null);\n        /* Get the start of the argument list */\n        let index1 = Strings.indexOf(expression, \"[\");\n        if (index1 < 0)\n            index1 = Strings.indexOf(expression, \"(\");\n        /* No arguments ? */\n        if (index1 < 0)\n            return new WellKnownTextNode(expression, null);\n        /* Get the end of the argument list */\n        let index2 = Strings.lastIndexOf(expression, \"]\");\n        if (index2 < 0)\n            index2 = Strings.lastIndexOf(expression, \")\");\n        /* Check */\n        ASystem.assertNot(index2 < 0, \"Invalid well-known-text '\" + expression + \"' (missing closing bracket)\");\n        ASystem.assertNot(index2 < index1, \"Invalid well-known-text '\" + expression + \"' (wrong bracket sequence)\");\n        /* Get the argument list */\n        let argumentList = Strings.substring(expression, index1 + 1, index2);\n        let arguments1 = Strings.splitAdvanced(argumentList, \",\" /*separators*/, \"[(\" /*opens*/, \"])\" /*closes*/, \"\\\"\" /*literals*/);\n        /* Parse the arguments */\n        let arguments2 = new AList();\n        for (let i = 0; i < arguments1.size(); i++)\n            arguments2.add(WellKnownTextNode.parse(Strings.trim(arguments1.get(i))));\n        /* Get the node name */\n        let name = Strings.trim(Strings.substring(expression, 0, index1));\n        /* Return the node */\n        return new WellKnownTextNode(name, arguments2);\n    }\n}\n//# sourceMappingURL=WellKnownTextNode.js.map",
      "start": 1693508125643,
      "end": 1693508125687,
      "sourcemaps": null
    }
  ]
}
