{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/topology/InsertAndRetriangulateContext.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Topology\n */\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\nimport { Ray3d } from \"../geometry3d/Ray3d\";\nimport { SmallSystem } from \"../numerics/Polynomials\";\nimport { HalfEdgeMask } from \"./Graph\";\nimport { MarkedEdgeSet } from \"./HalfEdgeMarkSet\";\nimport { PointSearchContext, RayClassification } from \"./HalfEdgePointInGraphSearch\";\nimport { HalfEdgePositionDetail } from \"./HalfEdgePositionDetail\";\nimport { Triangulator } from \"./Triangulation\";\n/**\n * Context for repeated insertion of new points in a graph.\n * * Initial graph should have clean outer boundary. (e.g. as typically marked with HalfEdgeMask.EXTERIOR)\n * * After each insertion, the current \"position\" within the graph is remembered so that each subsequent insertion\n *     can reuse that position as start for walking to the new point.\n */\nexport class InsertAndRetriangulateContext {\n    // Temporaries used in reAimFromFace\n    // private _lastBefore: HalfEdgePositionDetail;\n    // private _firstAfter: HalfEdgePositionDetail;\n    constructor(graph) {\n        this._graph = graph;\n        this._edgeSet = MarkedEdgeSet.create(graph);\n        this._searcher = HalfEdgePositionDetail.create();\n        // this._lastBefore = HalfEdgePositionDetail.create();\n        // this._firstAfter = HalfEdgePositionDetail.create();\n    }\n    /** Create a new context referencing the graph. */\n    static create(graph) {\n        return new InsertAndRetriangulateContext(graph);\n    }\n    /** Query the (pointer to) the graph in the context. */\n    get graph() { return this._graph; }\n    // Walk face from edgeNode;  insert new edges back to start node from all except\n    //   immediate successor and predecessor.\n    // insert all new nodes, and nodes of the existing face, in edgeSet.\n    retriangulateFromBaseVertex(centralNode) {\n        const numNode = centralNode.countEdgesAroundFace();\n        this._edgeSet.addAroundFace(centralNode);\n        if (numNode < 4 || centralNode.signedFaceArea() <= 0.0)\n            return;\n        const numEdge = numNode - 3;\n        let farNode = centralNode.faceSuccessor;\n        let nearNode = centralNode;\n        for (let i = 0; i < numEdge; i++) {\n            farNode = farNode.faceSuccessor;\n            nearNode = this._graph.createEdgeHalfEdgeHalfEdge(nearNode, 0, farNode, 0);\n            farNode = nearNode.faceSuccessor;\n            this._edgeSet.addToSet(nearNode);\n        }\n    }\n    /** Reset the \"current\" position to unknown state. */\n    reset() {\n        this._searcher = HalfEdgePositionDetail.create();\n    }\n    /** Return a (reference to!) the current position in the graph */\n    get currentPosition() { return this._searcher; }\n    /**\n     * Linear search through the graph\n     * * Returns a HalfEdgePositionDetail for the nearest edge or vertex.\n     * @param xyz\n     */\n    searchForNearestEdgeOrVertex(xyz) {\n        const position = HalfEdgePositionDetail.create();\n        position.setDTag(Number.MAX_VALUE);\n        const xyzC = Point3d.create();\n        let fractionC;\n        let distanceC;\n        for (const nodeA of this._graph.allHalfEdges) {\n            const nodeB = nodeA.faceSuccessor;\n            fractionC = SmallSystem.lineSegment3dXYClosestPointUnbounded(nodeA, nodeB, xyz);\n            if (fractionC !== undefined) {\n                if (fractionC > 1.0) {\n                    distanceC = xyz.distanceXY(nodeB);\n                    if (distanceC < position.getDTag()) {\n                        position.resetAsVertex(nodeB);\n                        position.setDTag(distanceC);\n                    }\n                }\n                else if (fractionC < 0.0) {\n                    distanceC = xyz.distanceXY(nodeA);\n                    if (distanceC < position.getDTag()) {\n                        position.resetAsVertex(nodeA);\n                        position.setDTag(distanceC);\n                    }\n                }\n                else {\n                    nodeA.fractionToPoint3d(fractionC, xyzC);\n                    distanceC = xyz.distanceXY(xyzC);\n                    if (distanceC < position.getDTag()) {\n                        position.resetAtEdgeAndFraction(nodeA, fractionC);\n                    }\n                }\n            }\n        }\n        return position;\n    }\n    searchForNearestVertex(xyz) {\n        const position = HalfEdgePositionDetail.create();\n        position.setDTag(Number.MAX_VALUE);\n        let distanceA;\n        for (const nodeA of this._graph.allHalfEdges) {\n            distanceA = xyz.distanceXY(nodeA);\n            if (distanceA < position.getDTag()) {\n                position.resetAsVertex(nodeA);\n                position.setDTag(distanceA);\n            }\n        }\n        return position;\n    }\n    resetSearch(xyz, maxDim) {\n        if (maxDim > 0)\n            this._searcher = this.searchForNearestEdgeOrVertex(xyz);\n        else\n            this._searcher = this.searchForNearestVertex(xyz);\n    }\n    insertAndRetriangulate(xyz, newZWins) {\n        this.moveToPoint(this._searcher, xyz);\n        const seedNode = this._searcher.node;\n        let stat = false;\n        if (seedNode === undefined) {\n        }\n        else if (this._searcher.isFace) {\n            if (!seedNode.isMaskSet(HalfEdgeMask.EXTERIOR)) {\n                const newInteriorNode = this._graph.createEdgeXYZHalfEdge(xyz.x, xyz.y, xyz.z, 0, seedNode, 0);\n                this.retriangulateFromBaseVertex(newInteriorNode);\n                Triangulator.flipTrianglesInEdgeSet(this._graph, this._edgeSet);\n                this._searcher.resetAsVertex(newInteriorNode);\n            }\n            stat = true;\n        }\n        else if (this._searcher.isEdge) {\n            const newA = this._graph.splitEdgeAtFraction(seedNode, this._searcher.edgeFraction);\n            const newB = newA.vertexPredecessor;\n            this.retriangulateFromBaseVertex(newA);\n            this.retriangulateFromBaseVertex(newB);\n            Triangulator.flipTrianglesInEdgeSet(this._graph, this._edgeSet);\n            this._searcher.resetAsVertex(newA);\n            stat = true;\n        }\n        else if (this._searcher.isVertex) {\n            // There's already a vertex there.  Maybe the z is different.\n            if (newZWins)\n                seedNode.setXYZAroundVertex(xyz.x, xyz.y, xyz.z);\n            stat = true;\n        }\n        else {\n            stat = false;\n        }\n        return stat;\n    }\n    // Advance movingPosition to a face, edge, or vertex position detail that contains xyz.\n    // Prior content in movingPosition is used as seed.\n    // Return true if successful.\n    moveToPoint(movingPosition, xyz, announcer) {\n        const psc = PointSearchContext.create();\n        movingPosition.setITag(0);\n        if (movingPosition.isUnclassified) {\n            moveToAnyUnmaskedEdge(this.graph, movingPosition, 0.5, 0);\n            if (movingPosition.isUnclassified)\n                return false;\n        }\n        let trap = 0;\n        // double tol = vu_getMergeTol (pGraph);\n        const ray = Ray3d.createXAxis();\n        for (; movingPosition.getITag() === 0 && trap < 2;) {\n            if (announcer !== undefined) {\n                const continueSearch = announcer(movingPosition);\n                if (!continueSearch)\n                    break;\n            }\n            if (!psc.setSearchRay(movingPosition, xyz, ray)) {\n                return false;\n            }\n            else if (movingPosition.isFace) {\n                const lastBefore = HalfEdgePositionDetail.create();\n                const firstAfter = HalfEdgePositionDetail.create();\n                const rc = psc.reAimAroundFace(movingPosition.node, ray, ray.a, lastBefore, firstAfter);\n                // reAimAroundFace returns lots of cases in `lastBefore` !!\n                switch (rc) {\n                    case RayClassification.RC_NoHits: {\n                        movingPosition.resetAsUnknown();\n                        break;\n                    }\n                    case RayClassification.RC_TargetOnVertex: {\n                        movingPosition.setFrom(lastBefore);\n                        movingPosition.setITag(1);\n                        break;\n                    }\n                    case RayClassification.RC_TargetOnEdge: {\n                        movingPosition.setFrom(lastBefore);\n                        movingPosition.setITag(1);\n                        break;\n                    }\n                    case RayClassification.RC_Bracket: {\n                        movingPosition.resetAsFace(lastBefore.node, xyz);\n                        movingPosition.setITag(1);\n                        break;\n                    }\n                    case RayClassification.RC_TargetBefore: {\n                        movingPosition.resetAsFace(movingPosition.node, xyz);\n                        movingPosition.setITag(1);\n                        break;\n                    }\n                    case RayClassification.RC_TargetAfter: {\n                        if (movingPosition.node === lastBefore.node\n                            && movingPosition.isFace\n                            && (lastBefore.isEdge || lastBefore.isVertex)) {\n                            trap++;\n                        }\n                        else {\n                            trap = 0;\n                        }\n                        movingPosition.setFrom(lastBefore);\n                        break;\n                    }\n                }\n            }\n            else if (movingPosition.isEdge) {\n                psc.reAimFromEdge(movingPosition, ray, ray.a);\n                if (movingPosition.isUnclassified)\n                    break;\n            }\n            else if (movingPosition.isVertex) {\n                psc.reAimFromVertex(movingPosition, ray, ray.a);\n                if (movingPosition.isUnclassified)\n                    break;\n            }\n        }\n        if (movingPosition.isAtXY(xyz.x, xyz.y))\n            return true;\n        if (trap > 1) {\n            // Ugh.  We exited the loop by repeatedly hitting the same node\n            // with edge or vertex type in lastBefore.\n            // This happens only when the target point is exterior.\n            // (Heavy triangulation use cases start with a convex hull and only do interior intersections,\n            //     so case only happens in contrived unit tests.... so far ...)\n            // What to mark?\n            // Leave it as is, but mark as exterior target\n            //\n            if (movingPosition.node !== undefined) {\n                movingPosition.setIsExteriorTarget(true);\n            }\n            return false;\n        }\n        // Murky here ...  should never be hit.  Has never been hit in unit tests.\n        return false;\n    }\n}\n// Create a VuPositionDetail for specified fraction along any unmasked edge.\nfunction moveToAnyUnmaskedEdge(graph, position, edgeFraction, skipMask) {\n    for (const candidate of graph.allHalfEdges) {\n        if (!candidate.isMaskSet(skipMask)) {\n            position.resetAtEdgeAndFraction(candidate, edgeFraction);\n            return true;\n        }\n    }\n    return false;\n}\n//# sourceMappingURL=InsertAndRetriangulateContext.js.map",
      "start": 1693508124386,
      "end": 1693508124546,
      "sourcemaps": null
    }
  ]
}
