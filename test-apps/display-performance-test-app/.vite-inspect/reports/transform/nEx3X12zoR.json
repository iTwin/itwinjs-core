{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/FeatureSymbology.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Rendering\n */\nimport { Id64 } from \"@itwin/core-bentley\";\nimport { FeatureAppearance, FeatureOverrides } from \"@itwin/core-common\";\nimport { Viewport } from \"../Viewport\";\n// cspell:ignore subcat subcats\n/** Contains types that enable an application to customize how [Feature]($common)s are drawn within a [[Viewport]].\n * @public\n * @extensions\n */\nexport var FeatureSymbology;\n(function (FeatureSymbology) {\n    /** Allows a [[Viewport]] to customize the appearance of individual [Feature]($common)s within it.\n     *\n     * The Viewport computes its base Overrides based on the following:\n     *  - The set of categories enabled for display in its [[CategorySelectorState]]. Every [[SubCategory]] belonging to an enabled [[Category]] is added to the set of visible subcategories - all other subcategories are assumed to be invisible.\n     *  - For the set of visible subcategories, any [[SubCategoryOverride]]s defined by the view's [[DisplayStyleState]] are applied. This may render some subcategories invisible, and change the symbology of others.\n     *  - The visibility of each [GeometryClass]($common) is set based on the view's [ViewFlags]($common).\n     *  - The line weight is overridden to 1 pixel for all Features if line weight has been disabled by the view's [ViewFlags]($common).\n     *  - The sets of elements which are always drawn and never drawn are initialized from the [[Viewport]]'s sets.\n     * An application can further customize the symbology of any Features by registering a [[FeatureOverrideProvider]] with a [[Viewport]]. That provider's addFeatureOverrides function will be invoked\n     * whenever the Overrides need to be regenerated.\n     *\n     * To override the symbology of *most* Features within a view, specify a `defaultOverrides` to be applied to any Feature not explicitly overridden.\n     * If default overrides are defined and some Features should draw normally without being affected by the default overrides, override that Feature with\n     * an Appearance which defines no overrides.\n     *\n     * It is possible to override multiple aspects of a Feature. For example, you might specify that all elements belonging to subcategory \"A\" should be drawn in red, and\n     * that the element with Id \"0x123\" should be drawn with 0.25 transparency. In this case, when drawing a Feature with subcategory \"A\" and element Id \"0x123\", the two overrides will\n     * be merged, causing the Feature's geometry to draw 25% transparent red. On the other hand, if subcategory \"A\" is specified to draw in red and element \"0x123\" to draw in green,\n     * the color specified by the element override will take precedence over that specified for the subcategory, resulting in a green Feature.\n     *\n     * @see [[Viewport.alwaysDrawn]]\n     * @see [[Viewport.neverDrawn]]\n     */\n    class Overrides extends FeatureOverrides {\n        /** @alpha */\n        get source() {\n            return this._source;\n        }\n        /** Construct a new Overrides. The result is an empty set of overrides if no view or viewport is supplied.\n         * @param view If supplied, the overrides will be initialized based on the current state of the view or viewport.\n         */\n        constructor(view) {\n            super();\n            if (undefined !== view) {\n                if (view instanceof Viewport)\n                    this.initFromViewport(view);\n                else\n                    this.initFromView(view);\n            }\n        }\n        /** Create symbology overrides associated with a [[FeatureSymbology.Source]].\n         * @alpha\n         */\n        static withSource(source, view) {\n            const ovrs = new Overrides(view);\n            ovrs._source = source;\n            return ovrs;\n        }\n        /** Initialize these Overrides based on a specific view.\n         * @internal\n         */\n        initFromView(view) {\n            this._initFromView(view);\n            this._initSubCategoryOverrides(view);\n        }\n        /** Initialize these Overrides based on a specific viewport.\n         * @internal\n         */\n        initFromViewport(viewport) {\n            const view = viewport.view;\n            this._initFromView(view);\n            if (undefined !== viewport.neverDrawn)\n                this.setNeverDrawnSet(viewport.neverDrawn);\n            if (undefined !== viewport.alwaysDrawn)\n                this.setAlwaysDrawnSet(viewport.alwaysDrawn, viewport.isAlwaysDrawnExclusive);\n            viewport.addFeatureOverrides(this);\n            viewport.addModelSubCategoryVisibilityOverrides(this, this._modelSubCategoryOverrides);\n            // This will include any per-model subcategory visibility overrides added above.\n            this._initSubCategoryOverrides(view);\n        }\n        _initFromView(view) {\n            const { viewFlags } = view;\n            const { constructions, dimensions, patterns } = viewFlags;\n            this.neverDrawnAnimationNodes.clear();\n            this.animationNodeOverrides.clear();\n            for (const excluded of view.displayStyle.settings.excludedElementIds)\n                this.setNeverDrawn(excluded);\n            this._constructions = constructions;\n            this._dimensions = dimensions;\n            this._patterns = patterns;\n            this._lineWeights = viewFlags.weights;\n            for (const categoryId of view.categorySelector.categories) {\n                const subCategoryIds = view.iModel.subcategories.getSubCategories(categoryId);\n                if (undefined === subCategoryIds)\n                    continue;\n                for (const subCategoryId of subCategoryIds) {\n                    if (view.isSubCategoryVisible(subCategoryId)) {\n                        const idLo = Id64.getLowerUint32(subCategoryId);\n                        const idHi = Id64.getUpperUint32(subCategoryId);\n                        this._visibleSubCategories.add(idLo, idHi);\n                        const app = view.iModel.subcategories.getSubCategoryAppearance(subCategoryId);\n                        if (undefined !== app)\n                            this._subCategoryPriorities.set(idLo, idHi, app.priority);\n                    }\n                }\n            }\n            const style = view.displayStyle;\n            style.settings.modelAppearanceOverrides.forEach((appearance, modelId) => this.override({ modelId, appearance, onConflict: \"skip\" }));\n            style.forEachRealityModel((realityModel) => {\n                if (realityModel.appearanceOverrides && realityModel.modelId)\n                    this.override({ modelId: realityModel.modelId, appearance: realityModel.appearanceOverrides });\n            });\n            const script = style.scheduleScript;\n            if (script)\n                script.addSymbologyOverrides(this, style.settings.timePoint ?? 0);\n            if (!view.is3d())\n                return;\n            const planProjectionSettings = view.getDisplayStyle3d().settings.planProjectionSettings;\n            if (undefined === planProjectionSettings)\n                return;\n            for (const [modelId, projSettings] of planProjectionSettings) {\n                if (undefined !== projSettings.transparency)\n                    this.override({ modelId, appearance: FeatureAppearance.fromJSON({ transparency: projSettings.transparency }) });\n            }\n        }\n        _initSubCategoryOverrides(view) {\n            const addOverride = (idLo, idHi) => {\n                const subCategoryId = Id64.fromUint32Pair(idLo, idHi);\n                const ovr = view.getSubCategoryOverride(subCategoryId);\n                if (undefined !== ovr) {\n                    const app = FeatureAppearance.fromSubCategoryOverride(ovr);\n                    if (app.overridesSymbology)\n                        this._subCategoryOverrides.set(idLo, idHi, app);\n                    if (undefined !== ovr.priority)\n                        this._subCategoryPriorities.set(idLo, idHi, ovr.priority);\n                }\n            };\n            // Add overrides for all subcategories visible in the view\n            this._visibleSubCategories.forEach((idLo, idHi) => {\n                addOverride(idLo, idHi);\n            });\n            // Add overrides for all subcategories overridden to be visible in specific models\n            this._modelSubCategoryOverrides.forEach((_modelIdLo, _modelIdHi, subcats) => {\n                subcats.forEach((idLo, idHi) => {\n                    if (!this.isSubCategoryVisible(idLo, idHi)) {\n                        // Overridden to be visible in one or more models - will need the appearance overrides\n                        addOverride(idLo, idHi);\n                    }\n                });\n            });\n        }\n    }\n    FeatureSymbology.Overrides = Overrides;\n})(FeatureSymbology || (FeatureSymbology = {}));\n//# sourceMappingURL=FeatureSymbology.js.map",
      "start": 1693508119436,
      "end": 1693508119628,
      "sourcemaps": null
    }
  ]
}
