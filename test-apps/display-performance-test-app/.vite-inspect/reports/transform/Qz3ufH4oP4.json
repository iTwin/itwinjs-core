{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tools/IdleTool.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tools\n */\nimport { IModelApp } from \"../IModelApp\";\nimport { BeButton, EventHandled, InteractiveTool } from \"./Tool\";\nimport { DefaultViewTouchTool, FitViewTool, ViewHandleType, ViewManip } from \"./ViewTool\";\n/**\n * The default \"idle\" tool. If no tool is active, or the active tool does not respond to a given\n * event, input events are forwarded to the idle tool. The default idle tool converts middle mouse button events\n * and touch gestures into view navigation operations like pan, zoom, rotate, and fit.\n *\n * Controls are as follows:\n * - Mouse/keyboard:\n *   - mmb: pan\n *   - shift-mmb: rotate\n *   - wheel: zoom in/out\n *   - double-mmb: fit view\n * - Touch:\n *   - single-finger drag: rotate\n *   - two-finger drag: pan\n *   - pinch: zoom in/out\n *   - double-tap: fit view\n *\n * Touch inputs can be combined e.g. drag two fingers while moving them closer together => pan + zoom in\n * @public\n */\nclass IdleTool extends InteractiveTool {\n    async onMouseStartDrag(ev) {\n        if (!ev.viewport)\n            return EventHandled.No;\n        let toolId;\n        let handleId;\n        switch (ev.button) {\n            case BeButton.Middle:\n                if (ev.isControlKey) {\n                    toolId = ev.viewport.view.allow3dManipulations() ? \"View.Look\" : \"View.Scroll\";\n                    handleId = ev.viewport.view.allow3dManipulations() ? ViewHandleType.Look : ViewHandleType.Scroll;\n                }\n                else if (ev.isShiftKey) {\n                    toolId = \"View.Rotate\";\n                    handleId = ViewHandleType.Rotate;\n                }\n                else {\n                    toolId = \"View.Pan\";\n                    handleId = ViewHandleType.Pan;\n                }\n                break;\n            case BeButton.Data:\n                // When no active tool is present install rotate view tool on drag of data button\n                if (undefined !== IModelApp.toolAdmin.activeTool)\n                    return EventHandled.No;\n                toolId = \"View.Rotate\";\n                handleId = ViewHandleType.Rotate;\n                break;\n            default:\n                // When no active tool is present install pan view tool on drag of reset button\n                if (undefined !== IModelApp.toolAdmin.activeTool)\n                    return EventHandled.No;\n                toolId = \"View.Pan\";\n                handleId = ViewHandleType.Pan;\n                break;\n        }\n        const currTool = IModelApp.toolAdmin.viewTool;\n        if (currTool) {\n            if (currTool instanceof ViewManip)\n                return currTool.startHandleDrag(ev, handleId); // See if current view tool can drag using this handle, leave it active regardless...\n            return EventHandled.No;\n        }\n        const viewTool = IModelApp.tools.create(toolId, ev.viewport, true, true);\n        if (viewTool && await viewTool.run())\n            return viewTool.startHandleDrag(ev);\n        return EventHandled.Yes;\n    }\n    async onMiddleButtonUp(ev) {\n        if (!ev.viewport)\n            return EventHandled.No;\n        if (ev.isDoubleClick) {\n            const viewTool = new FitViewTool(ev.viewport, true);\n            return await viewTool.run() ? EventHandled.Yes : EventHandled.No;\n        }\n        if (ev.isControlKey || ev.isShiftKey)\n            return EventHandled.No;\n        IModelApp.tentativePoint.process(ev);\n        return EventHandled.Yes;\n    }\n    async onMouseWheel(ev) { return IModelApp.toolAdmin.processWheelEvent(ev, true); }\n    async onTouchMoveStart(ev, startEv) {\n        const tool = new DefaultViewTouchTool(startEv, ev);\n        return await tool.run() ? EventHandled.Yes : EventHandled.No;\n    }\n    async onTouchTap(ev) {\n        if (ev.isSingleTap) {\n            // Send data down/up for single finger tap.\n            await IModelApp.toolAdmin.convertTouchTapToButtonDownAndUp(ev, BeButton.Data);\n            return EventHandled.Yes;\n        }\n        else if (ev.isTwoFingerTap) {\n            // Send reset down/up for two finger tap.\n            await IModelApp.toolAdmin.convertTouchTapToButtonDownAndUp(ev, BeButton.Reset);\n            return EventHandled.Yes;\n        }\n        else if (ev.isDoubleTap) {\n            // Fit view on single finger double tap.\n            const tool = new FitViewTool(ev.viewport, true);\n            return await tool.run() ? EventHandled.Yes : EventHandled.No;\n        }\n        return EventHandled.No;\n    }\n    async exitTool() { }\n    async run() { return true; }\n}\nIdleTool.toolId = \"Idle\";\nIdleTool.hidden = true;\nexport { IdleTool };\n//# sourceMappingURL=IdleTool.js.map",
      "start": 1693508119736,
      "end": 1693508120009,
      "sourcemaps": null
    }
  ]
}
