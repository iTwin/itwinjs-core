{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/common/lib/esm/rpc/core/RpcInvocation.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module RpcInterface\n */\nvar _a;\nimport { BentleyError, BentleyStatus, IModelStatus, Logger, RpcInterfaceStatus, StatusCategory, Tracing } from \"@itwin/core-bentley\";\nimport { CommonLoggerCategory } from \"../../CommonLoggerCategory\";\nimport { IModelError } from \"../../IModelError\";\nimport { RpcInterface } from \"../../RpcInterface\";\nimport { RpcConfiguration } from \"./RpcConfiguration\";\nimport { RpcProtocolEvent, RpcRequestStatus } from \"./RpcConstants\";\nimport { RpcControlChannel, RpcNotFoundResponse, RpcPendingResponse } from \"./RpcControl\";\nimport { RpcMarshaling } from \"./RpcMarshaling\";\nimport { RpcOperation } from \"./RpcOperation\";\nimport { RpcProtocol, RpcProtocolVersion } from \"./RpcProtocol\";\nimport { CURRENT_INVOCATION, RpcRegistry } from \"./RpcRegistry\";\n/** An RPC operation invocation in response to a request.\n * @internal\n */\nclass RpcInvocation {\n    /** The status for this request. */\n    get status() {\n        return this._threw ? RpcRequestStatus.Rejected :\n            this._pending ? RpcRequestStatus.Pending :\n                this._notFound ? RpcRequestStatus.NotFound :\n                    this._noContent ? RpcRequestStatus.NoContent :\n                        RpcRequestStatus.Resolved;\n    }\n    /** The elapsed time for this invocation. */\n    get elapsed() {\n        return this._timeOut - this._timeIn;\n    }\n    /**\n     * The invocation for the current RPC operation.\n     * @note The return value of this function is only reliable in an RPC impl class member function where program control was received from the RpcInvocation constructor function.\n     */\n    static current(rpcImpl) {\n        return rpcImpl[CURRENT_INVOCATION];\n    }\n    /** Constructs an invocation. */\n    constructor(protocol, request) {\n        this._threw = false;\n        this._pending = false;\n        this._notFound = false;\n        this._noContent = false;\n        this._timeIn = 0;\n        this._timeOut = 0;\n        /** The operation of the request. */\n        this.operation = undefined;\n        this._timeIn = new Date().getTime();\n        this.protocol = protocol;\n        this.request = request;\n        try {\n            try {\n                this.operation = RpcOperation.lookup(this.request.operation.interfaceDefinition, this.request.operation.operationName);\n                const backend = this.operation.interfaceVersion;\n                const frontend = this.request.operation.interfaceVersion;\n                if (!RpcInterface.isVersionCompatible(backend, frontend)) {\n                    throw new IModelError(RpcInterfaceStatus.IncompatibleVersion, `Backend version ${backend} does not match frontend version ${frontend} for RPC interface ${this.operation.operationName}.`);\n                }\n            }\n            catch (error) {\n                if (this.handleUnknownOperation(error)) {\n                    this.operation = RpcOperation.lookup(this.request.operation.interfaceDefinition, this.request.operation.operationName);\n                }\n                else {\n                    throw error;\n                }\n            }\n            this.result = this.resolve();\n        }\n        catch (error) {\n            this.result = this.reject(error);\n        }\n        this.fulfillment = this.result.then(async (value) => this._threw ? this.fulfillRejected(value) : this.fulfillResolved(value), async (reason) => this.fulfillRejected(reason));\n    }\n    handleUnknownOperation(error) {\n        RpcControlChannel.ensureInitialized();\n        return this.protocol.configuration.controlChannel.handleUnknownOperation(this, error);\n    }\n    static sanitizeForLog(activity) {\n        /* eslint-disable @typescript-eslint/naming-convention */\n        return activity ? {\n            ActivityId: activity.activityId, SessionId: activity.sessionId, ApplicationId: activity.applicationId, ApplicationVersion: activity.applicationVersion, rpcMethod: activity.rpcMethod,\n        } : undefined;\n        /* eslint-enable @typescript-eslint/naming-convention */\n    }\n    async resolve() {\n        const request = this.request;\n        const activity = {\n            activityId: request.id,\n            applicationId: request.applicationId,\n            applicationVersion: request.applicationVersion,\n            sessionId: request.sessionId,\n            user: request.user,\n            accessToken: request.authorization,\n            rpcMethod: request.operation.operationName,\n        };\n        try {\n            this.protocol.events.raiseEvent(RpcProtocolEvent.RequestReceived, this);\n            const parameters = request.parametersOverride || RpcMarshaling.deserialize(this.protocol, request.parameters);\n            this.applyPolicies(parameters);\n            const impl = RpcRegistry.instance.getImplForInterface(this.operation.interfaceDefinition);\n            impl[CURRENT_INVOCATION] = this;\n            const op = this.lookupOperationFunction(impl);\n            return await RpcInvocation.runActivity(activity, async () => op.call(impl, ...parameters)\n                .catch(async (error) => {\n                // this catch block is intentionally placed inside `runActivity` to attach the right logging metadata and use the correct openTelemetry span.\n                if (!(error instanceof RpcPendingResponse)) {\n                    Logger.logError(CommonLoggerCategory.RpcInterfaceBackend, \"Error in RPC operation\", { error: BentleyError.getErrorProps(error) });\n                    Tracing.setAttributes({ error: true });\n                }\n                throw error;\n            }));\n        }\n        catch (error) {\n            return this.reject(error);\n        }\n    }\n    applyPolicies(parameters) {\n        if (!parameters || !Array.isArray(parameters))\n            return;\n        for (let i = 0; i !== parameters.length; ++i) {\n            const parameter = parameters[i];\n            const isToken = typeof (parameter) === \"object\" && parameter !== null && parameter.hasOwnProperty(\"iModelId\") && parameter.hasOwnProperty(\"iTwinId\");\n            if (isToken && this.protocol.checkToken && !this.operation.policy.allowTokenMismatch) {\n                const inflated = this.protocol.inflateToken(parameter, this.request);\n                parameters[i] = inflated;\n                if (!RpcInvocation.compareTokens(parameter, inflated)) {\n                    if (RpcConfiguration.throwOnTokenMismatch) {\n                        throw new IModelError(BentleyStatus.ERROR, \"IModelRpcProps mismatch detected for this request.\");\n                    }\n                    else {\n                        Logger.logWarning(CommonLoggerCategory.RpcInterfaceBackend, \"IModelRpcProps mismatch detected for this request.\");\n                    }\n                }\n            }\n        }\n    }\n    static compareTokens(a, b) {\n        return a.key === b.key &&\n            a.iTwinId === b.iTwinId &&\n            a.iModelId === b.iModelId &&\n            (undefined === a.changeset || (a.changeset.id === b.changeset?.id));\n    }\n    async reject(error) {\n        this._threw = true;\n        return error;\n    }\n    async fulfillResolved(value) {\n        this._timeOut = new Date().getTime();\n        this.protocol.events.raiseEvent(RpcProtocolEvent.BackendResponseCreated, this);\n        const result = await RpcMarshaling.serialize(this.protocol, value);\n        return this.fulfill(result, value);\n    }\n    async fulfillRejected(reason) {\n        this._timeOut = new Date().getTime();\n        if (!RpcConfiguration.developmentMode)\n            reason.stack = undefined;\n        const result = await RpcMarshaling.serialize(this.protocol, reason);\n        if (reason instanceof RpcPendingResponse) {\n            this._pending = true;\n            this._threw = false;\n            result.objects = reason.message;\n            this.protocol.events.raiseEvent(RpcProtocolEvent.BackendReportedPending, this);\n        }\n        else if (this.supportsNoContent() && reason?.errorNumber === IModelStatus.NoContent) {\n            this._noContent = true;\n            this._threw = false;\n            this.protocol.events.raiseEvent(RpcProtocolEvent.BackendReportedNoContent, this);\n        }\n        else if (reason instanceof RpcNotFoundResponse) {\n            this._notFound = true;\n            this._threw = false;\n            this.protocol.events.raiseEvent(RpcProtocolEvent.BackendReportedNotFound, this);\n        }\n        else {\n            this._threw = true;\n            this.protocol.events.raiseEvent(RpcProtocolEvent.BackendErrorOccurred, this);\n        }\n        return this.fulfill(result, reason);\n    }\n    supportsNoContent() {\n        if (!this.request.protocolVersion) {\n            return false;\n        }\n        return RpcProtocol.protocolVersion >= RpcProtocolVersion.IntroducedNoContent && this.request.protocolVersion >= RpcProtocolVersion.IntroducedNoContent;\n    }\n    supportsStatusCategory() {\n        if (!this.request.protocolVersion) {\n            return false;\n        }\n        if (!this.protocol.supportsStatusCategory) {\n            return false;\n        }\n        return RpcProtocol.protocolVersion >= RpcProtocolVersion.IntroducedStatusCategory && this.request.protocolVersion >= RpcProtocolVersion.IntroducedStatusCategory;\n    }\n    fulfill(result, rawResult) {\n        const fulfillment = {\n            result,\n            rawResult,\n            status: this.protocol.getCode(this.status),\n            id: this.request.id,\n            interfaceName: (typeof (this.operation) === \"undefined\") ? \"\" : this.operation.interfaceDefinition.interfaceName,\n            allowCompression: this.operation?.policy.allowResponseCompression || false,\n        };\n        this.transformResponseStatus(fulfillment, rawResult);\n        try {\n            const impl = RpcRegistry.instance.getImplForInterface(this.operation.interfaceDefinition);\n            if (impl[CURRENT_INVOCATION] === this) {\n                impl[CURRENT_INVOCATION] = undefined;\n            }\n        }\n        catch (_err) { }\n        return fulfillment;\n    }\n    lookupOperationFunction(implementation) {\n        const func = implementation[this.operation.operationName];\n        if (!func || typeof (func) !== \"function\")\n            throw new IModelError(BentleyStatus.ERROR, `RPC interface class \"${implementation.constructor.name}\" does not implement operation \"${this.operation.operationName}\".`);\n        return func;\n    }\n    transformResponseStatus(fulfillment, rawResult) {\n        if (!this.supportsStatusCategory()) {\n            return;\n        }\n        let managedStatus;\n        if (this._pending) {\n            managedStatus = \"pending\";\n        }\n        else if (this._notFound) {\n            managedStatus = \"notFound\";\n        }\n        else if (this._noContent) {\n            managedStatus = \"noContent\";\n        }\n        if (managedStatus) {\n            const responseValue = fulfillment.result.objects;\n            const status = { iTwinRpcCoreResponse: true, managedStatus, responseValue };\n            fulfillment.result.objects = JSON.stringify(status);\n            status.responseValue = rawResult; // for ipc case\n            fulfillment.rawResult = status;\n        }\n        if (rawResult instanceof BentleyError) {\n            fulfillment.status = StatusCategory.for(rawResult).code;\n        }\n    }\n}\n_a = RpcInvocation;\nRpcInvocation.runActivity = async (_activity, fn) => fn();\nexport { RpcInvocation };\n//# sourceMappingURL=RpcInvocation.js.map",
      "start": 1693508120809,
      "end": 1693508120863,
      "sourcemaps": null
    }
  ]
}
