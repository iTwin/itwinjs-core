{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/topology/HalfEdgeNodeXYZUV.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\nimport { Geometry } from \"../Geometry\";\nimport { Point2d } from \"../geometry3d/Point2dVector2d\";\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\n/** @packageDocumentation\n * @module Topology\n */\n/**\n * Reference to a HalfEdge node with extra XYZ and UV data.\n * @internal\n */\nexport class NodeXYZUV {\n    constructor(node, x, y, z, u, v) {\n        this._x = x;\n        this._y = y;\n        this._z = z;\n        this._u = u;\n        this._v = v;\n        this._node = node;\n    }\n    /** Set all content directly from args.\n     * @returns `this` reference\n     */\n    set(node, x, y, z, u, v) {\n        this._x = x;\n        this._y = y;\n        this._z = z;\n        this._u = u;\n        this._v = v;\n        this._node = node;\n        return this;\n    }\n    setFrom(other) {\n        this._x = other.x;\n        this._y = other.y;\n        this._z = other.z;\n        this._u = other.u;\n        this._v = other.v;\n        this._node = other.node;\n    }\n    /** Create a `NodeXYZUV` with\n     * * x,y,z at ray origin\n     * * u,v as dotXY and crossXY for the ray direction with x,y distances from the ray origin.\n     */\n    static createNodeAndRayOrigin(node, ray, result) {\n        const x = node.x;\n        const y = node.y;\n        const z = node.z;\n        const dx = x - ray.origin.x;\n        const dy = y - ray.origin.y;\n        const u = Geometry.dotProductXYXY(dx, dy, ray.direction.x, ray.direction.y);\n        const v = Geometry.crossProductXYXY(ray.direction.x, ray.direction.y, dx, dy);\n        if (result)\n            return result.set(node, x, y, z, u, v);\n        return new NodeXYZUV(node, x, y, z, u, v);\n    }\n    /** Create a `NodeXYZUV` with explicit node, xyz, uv */\n    static create(node, x = 0, y = 0, z = 0, u = 0, v = 0) {\n        return new NodeXYZUV(node, x, y, z, u, v);\n    }\n    /** Access the node. */\n    get node() { return this._node; }\n    /** Access the x coordinate */\n    get x() { return this._x; }\n    /** Access the y coordinate */\n    get y() { return this._y; }\n    /** Access the z coordinate */\n    get z() { return this._z; }\n    /** Access the u coordinate */\n    get u() { return this._u; }\n    /** Access the v coordinate */\n    get v() { return this._v; }\n    /** Access the x,y,z coordinates as Point3d with optional caller-supplied result. */\n    getXYZAsPoint3d(result) {\n        return Point3d.create(this._x, this._y, this._z, result);\n    }\n    /** Access the uv coordinates as Point2d with optional caller-supplied result. */\n    getUVAsPoint2d(result) { return Point2d.create(this._u, this._v, result); }\n    /** Toleranced comparison function for u coordinate */\n    classifyU(target, tol) {\n        const delta = this.u - target;\n        if (Math.abs(delta) <= tol)\n            return 0;\n        return delta >= 0 ? 1 : -1;\n    }\n    /** Toleranced comparison function for v coordinate */\n    classifyV(target, tol) {\n        const delta = target - this._v;\n        if (Math.abs(delta) <= tol)\n            return 0;\n        return delta >= 0 ? 1 : -1;\n    }\n}\n//# sourceMappingURL=HalfEdgeNodeXYZUV.js.map",
      "start": 1693508125383,
      "end": 1693508125437,
      "sourcemaps": null
    }
  ]
}
