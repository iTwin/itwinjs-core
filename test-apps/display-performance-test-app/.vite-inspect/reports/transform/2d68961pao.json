{
  "resolvedId": "D:/hub2023A/itwinjs-core/common/temp/node_modules/.pnpm/@itwin+browser-authorization@1.0.1_67wltvhdskk2oee2c3z2o4tfly/node_modules/@itwin/browser-authorization/lib/cjs/Client.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\r\n* See LICENSE.md in the project root for license terms and full copyright notice.\r\n*--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.BrowserAuthorizationClient = exports.isBrowserAuthorizationClient = void 0;\r\nconst oidc_client_ts_1 = require(\"oidc-client-ts\");\r\nconst core_bentley_1 = require(\"@itwin/core-bentley\");\r\nconst Logger_1 = require(\"./Logger\");\r\nconst LoggerCategory_1 = require(\"./LoggerCategory\");\r\nconst utils_1 = require(\"./utils\");\r\n/** BrowserAuthorization type guard.\r\n * @beta\r\n */\r\nconst isBrowserAuthorizationClient = (client) => {\r\n    return client !== undefined && client.signIn !== undefined && client.signOut !== undefined;\r\n};\r\nexports.isBrowserAuthorizationClient = isBrowserAuthorizationClient;\r\n/**\r\n * @beta\r\n */\r\nclass BrowserAuthorizationClient {\r\n    constructor(configuration) {\r\n        this.onAccessTokenChanged = new core_bentley_1.BeEvent();\r\n        this._accessToken = \"\";\r\n        this._onUserStateChanged = (user) => {\r\n            this.initAccessToken(user);\r\n            try {\r\n                this.onAccessTokenChanged.raiseEvent(this._accessToken);\r\n            }\r\n            catch (err) {\r\n                core_bentley_1.Logger.logError(LoggerCategory_1.BrowserAuthorizationLoggerCategory.Authorization, \"Error thrown when handing BrowserAuthorizationClient.onUserStateChanged event\", () => ({ message: err.message }));\r\n            }\r\n        };\r\n        /**\r\n         * Raised when a user session has been established (or re-established).\r\n         * This can happen on startup, after token refresh or token callback.\r\n         */\r\n        this._onUserLoaded = (user) => {\r\n            this._onUserStateChanged(user);\r\n        };\r\n        /**\r\n         * Raised when a user session has been terminated.\r\n         */\r\n        this._onUserUnloaded = () => {\r\n            this._onUserStateChanged(undefined);\r\n        };\r\n        /**\r\n         * Raised prior to the access token expiring\r\n         */\r\n        this._onAccessTokenExpiring = async () => {\r\n        };\r\n        /**\r\n         * Raised after the access token has expired.\r\n         */\r\n        this._onAccessTokenExpired = () => {\r\n            this._onUserStateChanged(undefined);\r\n        };\r\n        /**\r\n         * Raised when the automatic silent renew has failed.\r\n         */\r\n        this._onSilentRenewError = () => {\r\n        };\r\n        /**\r\n         * Raised when the user's sign-in status at the OP has changed.\r\n         */\r\n        this._onUserSignedOut = () => {\r\n            this._onUserStateChanged(undefined);\r\n        };\r\n        Logger_1.BrowserAuthorizationLogger.initializeLogger();\r\n        this._basicSettings = {\r\n            ...configuration,\r\n            authority: configuration.authority ?? utils_1.getImsAuthority(),\r\n        };\r\n    }\r\n    get isAuthorized() {\r\n        return this.hasSignedIn;\r\n    }\r\n    get hasExpired() {\r\n        if (this._expiresAt)\r\n            return this._expiresAt.getTime() - Date.now() <= 1 * 60 * 1000; // Consider 1 minute before expiry as expired;\r\n        return !this._accessToken;\r\n    }\r\n    get hasSignedIn() {\r\n        return !!this._accessToken;\r\n    }\r\n    get authorityUrl() {\r\n        return this._advancedSettings?.authority ?? this._basicSettings.authority;\r\n    }\r\n    async getUserManager() {\r\n        if (this._userManager) {\r\n            return this._userManager;\r\n        }\r\n        const settings = await this.getUserManagerSettings(this._basicSettings, this._advancedSettings);\r\n        this._userManager = this.createUserManager(settings);\r\n        return this._userManager;\r\n    }\r\n    /**\r\n     * Merges the basic and advanced settings into a single configuration object consumable by the internal userManager.\r\n     * @param basicSettings\r\n     * @param advancedSettings\r\n     * @returns a promise resolving to UserManagerSettings\r\n     */\r\n    async getUserManagerSettings(basicSettings, advancedSettings) {\r\n        let userManagerSettings = {\r\n            authority: this.authorityUrl,\r\n            redirect_uri: basicSettings.redirectUri,\r\n            client_id: basicSettings.clientId,\r\n            scope: basicSettings.scope,\r\n            post_logout_redirect_uri: basicSettings.postSignoutRedirectUri,\r\n            response_type: basicSettings.responseType,\r\n            automaticSilentRenew: true,\r\n            silent_redirect_uri: basicSettings.silentRedirectUri,\r\n            userStore: new oidc_client_ts_1.WebStorageStateStore({ store: window.localStorage }),\r\n            prompt: basicSettings.prompt,\r\n            response_mode: basicSettings.responseMode, // eslint-disable-line @typescript-eslint/naming-convention\r\n        };\r\n        if (advancedSettings) {\r\n            userManagerSettings = { ...userManagerSettings, ...advancedSettings };\r\n        }\r\n        return userManagerSettings;\r\n    }\r\n    /**\r\n     * Creates the internal user manager and binds all relevant events to their respective callback function.\r\n     * @param settings\r\n     */\r\n    createUserManager(settings) {\r\n        const userManager = new oidc_client_ts_1.UserManager(settings);\r\n        userManager.events.addUserLoaded(this._onUserLoaded);\r\n        userManager.events.addUserUnloaded(this._onUserUnloaded);\r\n        userManager.events.addAccessTokenExpiring(this._onAccessTokenExpiring);\r\n        userManager.events.addAccessTokenExpired(this._onAccessTokenExpired);\r\n        userManager.events.addSilentRenewError(this._onSilentRenewError);\r\n        userManager.events.addUserSignedOut(this._onUserSignedOut);\r\n        return userManager;\r\n    }\r\n    /**\r\n     * Alias for signInRedirect\r\n     */\r\n    async signIn() {\r\n        return this.signInRedirect();\r\n    }\r\n    /**\r\n     * Attempts a sign-in via redirection with the authorization provider.\r\n     * If possible, a non-interactive signin will be attempted first.\r\n     * If successful, the returned promise will be resolved.\r\n     * Otherwise, an attempt to redirect the browser will proceed.\r\n     * If an error prevents the redirection from occurring, the returned promise will be rejected with the responsible error.\r\n     * Otherwise, the browser's window will be redirected away from the current page, effectively ending execution here.\r\n     * @param successRedirectUrl - (optional) path to redirect to after a successful authorization\r\n     * @param args (optional) additional BrowserAuthorizationClientRequestOptions passed to signIn methods\r\n     */\r\n    async signInRedirect(successRedirectUrl, args) {\r\n        const user = await this.nonInteractiveSignIn(args);\r\n        if (user) {\r\n            return;\r\n        }\r\n        const userManager = await this.getUserManager();\r\n        const state = {\r\n            successRedirectUrl: successRedirectUrl || window.location.href,\r\n        };\r\n        const redirectArgs = { state, ...args };\r\n        await userManager.signinRedirect(redirectArgs); // This call changes the window's URL, which effectively ends execution here unless an exception is thrown.\r\n    }\r\n    /**\r\n     * Attempts a sign-in via popup with the authorization provider\r\n     * @param args - @see BrowserAuthorizationClientRequestOptions\r\n     */\r\n    async signInPopup(args) {\r\n        let user = await this.nonInteractiveSignIn(args);\r\n        if (user) {\r\n            return;\r\n        }\r\n        const userManager = await this.getUserManager();\r\n        user = await userManager.signinPopup(args);\r\n        if (!user || user.expired)\r\n            throw new Error(\"Expected userManager.signinPopup to always resolve to an authorized user\");\r\n        return;\r\n    }\r\n    /**\r\n     * Attempts a silent sign in with the authorization provider\r\n     * @throws [Error] If the silent sign in fails\r\n     */\r\n    async signInSilent() {\r\n        const user = await this.nonInteractiveSignIn();\r\n        if (user === undefined || user.expired)\r\n            throw new Error(\"Authorization error: Silent sign-in failed\");\r\n    }\r\n    /**\r\n     * Attempts a non-interactive signIn\r\n     * - tries to load the user from storage\r\n     * - tries to silently sign-in the user\r\n     */\r\n    async nonInteractiveSignIn(args) {\r\n        const userManager = await this.getUserManager();\r\n        const settingsPromptRequired = userManager.settings.prompt !== undefined && userManager.settings.prompt !== \"none\";\r\n        const argsPromptRequired = args?.prompt !== undefined && args.prompt !== \"none\";\r\n        if (settingsPromptRequired || argsPromptRequired) { // No need to even try a silent sign in if we know the prompt will force its failure.\r\n            return undefined;\r\n        }\r\n        let user = await this.loadUser();\r\n        if (user) {\r\n            return user;\r\n        }\r\n        // Attempt a silent sign-in\r\n        try {\r\n            user = await userManager.signinSilent() ?? undefined; // calls events\r\n            return user;\r\n        }\r\n        catch (err) {\r\n            return undefined;\r\n        }\r\n    }\r\n    /**\r\n     * Gets the user from storage\r\n     * @return User found in storage.\r\n     * - Resolves to undefined if no user was found.\r\n     * - Returned user may have expired - so it's up to the caller to check the expired state\r\n     */\r\n    async loadUser() {\r\n        const userManager = await this.getUserManager();\r\n        const user = await userManager.getUser();\r\n        if (user && !user.expired) {\r\n            this._onUserLoaded(user); // Call only because getUser() doesn't call any events\r\n            return user;\r\n        }\r\n        return undefined;\r\n    }\r\n    initAccessToken(user) {\r\n        if (!user) {\r\n            this._accessToken = \"\";\r\n            return;\r\n        }\r\n        this._accessToken = `Bearer ${user.access_token}`;\r\n        this._expiresAt = user.expires_at ? new Date(user.expires_at * 1000) : undefined;\r\n    }\r\n    /**\r\n     * Alias for signOutRedirect\r\n     */\r\n    async signOut() {\r\n        await this.signOutRedirect();\r\n    }\r\n    async signOutRedirect() {\r\n        const userManager = await this.getUserManager();\r\n        await userManager.signoutRedirect();\r\n    }\r\n    async signOutPopup() {\r\n        const userManager = await this.getUserManager();\r\n        await userManager.signoutPopup();\r\n    }\r\n    /**\r\n     * Returns a promise that resolves to the AccessToken of the currently authorized user.\r\n     * The token is refreshed as necessary.\r\n     * @throws [Error] If signIn() was not called, or there was an authorization error.\r\n     * @returns an AccessToken\r\n     */\r\n    async getAccessToken() {\r\n        if (this._accessToken)\r\n            return this._accessToken;\r\n        throw new Error(\"Authorization error: Not signed in.\");\r\n    }\r\n    /**\r\n     * Checks the current local user session against that of the identity provider.\r\n     * If the session is no longer valid, the local user is removed from storage.\r\n     * @returns true if the local session is still active with the provider, false otherwise.\r\n     */\r\n    async checkSessionStatus() {\r\n        const userManager = await this.getUserManager();\r\n        try {\r\n            await userManager.querySessionStatus();\r\n        }\r\n        catch (err) { // Access token is no longer valid in this session\r\n            await userManager.removeUser();\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    /** Disposes the resources held by this client */\r\n    dispose() {\r\n        if (this._userManager) {\r\n            this._userManager.events.removeUserLoaded(this._onUserLoaded);\r\n            this._userManager.events.removeAccessTokenExpiring(this._onAccessTokenExpiring);\r\n            this._userManager.events.removeAccessTokenExpired(this._onAccessTokenExpired);\r\n            this._userManager.events.removeUserUnloaded(this._onUserUnloaded);\r\n            this._userManager.events.removeSilentRenewError(this._onSilentRenewError);\r\n            this._userManager.events.removeUserSignedOut(this._onUserSignedOut);\r\n        }\r\n    }\r\n    /**\r\n     * @internal\r\n     * Allows for advanced options to be supplied to the underlying UserManager.\r\n     * This function should be called directly after object construction.\r\n     * Any settings supplied via this method will override the corresponding settings supplied via the constructor.\r\n     * @throws if called after the internal UserManager has already been created.\r\n     */\r\n    setAdvancedSettings(settings) {\r\n        if (this._userManager) {\r\n            throw new Error(\"Cannot supply advanced settings to BrowserAuthorizationClient after the underlying UserManager has already been created.\");\r\n        }\r\n        this._advancedSettings = settings;\r\n    }\r\n    /**\r\n     * Attempts to process a callback response in the current URL.\r\n     * When called successfully within an iframe or popup, the host frame will automatically be destroyed.\r\n     * @param responseMode - Defines how OIDC auth reponse parameters are encoded.\r\n     * @throws [[Error]] when this attempt fails for any reason.\r\n     */\r\n    async handleSigninCallbackInternal(responseMode) {\r\n        const userManager = await this.getUserManager();\r\n        // oidc-client-js uses an over-eager regex to parse the url, which may match values from the hash string when targeting the query string (and vice-versa)\r\n        // To ensure that this mismatching doesn't occur, we strip the unnecessary portion away here first.\r\n        const urlSuffix = responseMode === \"query\"\r\n            ? window.location.search\r\n            : window.location.hash;\r\n        const url = `${window.location.origin}${window.location.pathname}${urlSuffix}`;\r\n        const user = await userManager.signinCallback(url); // For silent or popup callbacks, execution effectively ends here, since the context will be destroyed.\r\n        if (!user || user.expired)\r\n            throw new Error(\"Authorization error: userManager.signinRedirectCallback does not resolve to authorized user\");\r\n        if (user.state) {\r\n            const state = user.state;\r\n            if (state.successRedirectUrl) { // Special case for signin via redirect used to return to the original location\r\n                window.location.replace(state.successRedirectUrl);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Attempts to parse an OIDC token from the current window URL\r\n     * When called within an iframe or popup, the host frame will automatically be destroyed before the promise resolves.\r\n     */\r\n    async handleSigninCallback() {\r\n        const url = new URL(this._basicSettings.redirectUri);\r\n        if (url.pathname !== window.location.pathname)\r\n            return;\r\n        let errorMessage = \"\";\r\n        try {\r\n            await this.handleSigninCallbackInternal(\"fragment\");\r\n            return;\r\n        }\r\n        catch (err) {\r\n            errorMessage += `${err.message}\\n`;\r\n        }\r\n        try {\r\n            await this.handleSigninCallbackInternal(\"query\");\r\n            return;\r\n        }\r\n        catch (err) {\r\n            errorMessage += `${err.message}\\n`;\r\n        }\r\n        if (window.self !== window.top) { // simply destroy the window if a failure is detected in an iframe.\r\n            window.close();\r\n            return;\r\n        }\r\n        errorMessage = `SigninCallback error - failed to process signin request in callback using all known modes of token delivery: ${errorMessage}`;\r\n        core_bentley_1.UnexpectedErrors.handle(new Error(errorMessage));\r\n    }\r\n    /**\r\n     * Configuration-less sign in callback. Useful for when a client instance with configuration is not present\r\n     * on the page or route where the callback is needed to finish the authentication process. Pulls configuration\r\n     * from localStorage.\r\n     *\r\n     * @param store - A Storage object such as sessionStorage which stores configuration. Defaults to localStorage\r\n     * which is also the default stateStore for this library. These stores should match.\r\n     */\r\n    static async handleSignInCallback(store = window.localStorage) {\r\n        const staticClient = new BrowserAuthorizationClient({});\r\n        this.loadSettingsFromStorage(staticClient, store);\r\n        await staticClient.handleSigninCallback();\r\n    }\r\n    static loadSettingsFromStorage(client, store) {\r\n        const url = new URL(window.location.href);\r\n        const nonce = url.searchParams.get(\"state\");\r\n        const storageEntry = store.getItem(`oidc.${nonce}`);\r\n        if (!storageEntry)\r\n            throw new Error(\"Could not load oidc settings from local storage. Ensure the client is configured properly\");\r\n        const storageObject = JSON.parse(storageEntry);\r\n        const transformed = {\r\n            ...storageObject,\r\n            clientId: storageObject.client_id,\r\n            redirectUri: storageObject.redirect_uri,\r\n            authority: storageObject.authority,\r\n        };\r\n        client._basicSettings = transformed;\r\n    }\r\n}\r\nexports.BrowserAuthorizationClient = BrowserAuthorizationClient;\r\n//# sourceMappingURL=Client.js.map",
      "start": 1693508118232,
      "end": 1693508118341,
      "sourcemaps": null
    },
    {
      "name": "commonjs",
      "result": "import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __exports as Client } from \"\\u0000D:/hub2023A/itwinjs-core/common/temp/node_modules/.pnpm/@itwin+browser-authorization@1.0.1_67wltvhdskk2oee2c3z2o4tfly/node_modules/@itwin/browser-authorization/lib/cjs/Client.js?commonjs-exports\";\nimport require$$0 from \"\\u0000D:/hub2023A/itwinjs-core/common/temp/node_modules/.pnpm/oidc-client-ts@2.2.4/node_modules/oidc-client-ts/dist/umd/oidc-client-ts.js?commonjs-proxy\";\nimport require$$1 from \"\\u0000D:/hub2023A/itwinjs-core/core/bentley/lib/esm/core-bentley.js?commonjs-proxy\";\nimport require$$2 from \"\\u0000D:/hub2023A/itwinjs-core/common/temp/node_modules/.pnpm/@itwin+browser-authorization@1.0.1_67wltvhdskk2oee2c3z2o4tfly/node_modules/@itwin/browser-authorization/lib/cjs/Logger.js?commonjs-proxy\";\nimport require$$3 from \"\\u0000D:/hub2023A/itwinjs-core/common/temp/node_modules/.pnpm/@itwin+browser-authorization@1.0.1_67wltvhdskk2oee2c3z2o4tfly/node_modules/@itwin/browser-authorization/lib/cjs/LoggerCategory.js?commonjs-proxy\";\nimport require$$4 from \"\\u0000D:/hub2023A/itwinjs-core/common/temp/node_modules/.pnpm/@itwin+browser-authorization@1.0.1_67wltvhdskk2oee2c3z2o4tfly/node_modules/@itwin/browser-authorization/lib/cjs/utils.js?commonjs-proxy\";\n\n\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\r\n* See LICENSE.md in the project root for license terms and full copyright notice.\r\n*--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(Client, \"__esModule\", { value: true });\r\nvar BrowserAuthorizationClient_1 = Client.BrowserAuthorizationClient = isBrowserAuthorizationClient_1 = Client.isBrowserAuthorizationClient = void 0;\r\nconst oidc_client_ts_1 = require$$0;\r\nconst core_bentley_1 = require$$1;\r\nconst Logger_1 = require$$2;\r\nconst LoggerCategory_1 = require$$3;\r\nconst utils_1 = require$$4;\r\n/** BrowserAuthorization type guard.\r\n * @beta\r\n */\r\nconst isBrowserAuthorizationClient = (client) => {\r\n    return client !== undefined && client.signIn !== undefined && client.signOut !== undefined;\r\n};\r\nvar isBrowserAuthorizationClient_1 = Client.isBrowserAuthorizationClient = isBrowserAuthorizationClient;\r\n/**\r\n * @beta\r\n */\r\nclass BrowserAuthorizationClient {\r\n    constructor(configuration) {\r\n        this.onAccessTokenChanged = new core_bentley_1.BeEvent();\r\n        this._accessToken = \"\";\r\n        this._onUserStateChanged = (user) => {\r\n            this.initAccessToken(user);\r\n            try {\r\n                this.onAccessTokenChanged.raiseEvent(this._accessToken);\r\n            }\r\n            catch (err) {\r\n                core_bentley_1.Logger.logError(LoggerCategory_1.BrowserAuthorizationLoggerCategory.Authorization, \"Error thrown when handing BrowserAuthorizationClient.onUserStateChanged event\", () => ({ message: err.message }));\r\n            }\r\n        };\r\n        /**\r\n         * Raised when a user session has been established (or re-established).\r\n         * This can happen on startup, after token refresh or token callback.\r\n         */\r\n        this._onUserLoaded = (user) => {\r\n            this._onUserStateChanged(user);\r\n        };\r\n        /**\r\n         * Raised when a user session has been terminated.\r\n         */\r\n        this._onUserUnloaded = () => {\r\n            this._onUserStateChanged(undefined);\r\n        };\r\n        /**\r\n         * Raised prior to the access token expiring\r\n         */\r\n        this._onAccessTokenExpiring = async () => {\r\n        };\r\n        /**\r\n         * Raised after the access token has expired.\r\n         */\r\n        this._onAccessTokenExpired = () => {\r\n            this._onUserStateChanged(undefined);\r\n        };\r\n        /**\r\n         * Raised when the automatic silent renew has failed.\r\n         */\r\n        this._onSilentRenewError = () => {\r\n        };\r\n        /**\r\n         * Raised when the user's sign-in status at the OP has changed.\r\n         */\r\n        this._onUserSignedOut = () => {\r\n            this._onUserStateChanged(undefined);\r\n        };\r\n        Logger_1.BrowserAuthorizationLogger.initializeLogger();\r\n        this._basicSettings = {\r\n            ...configuration,\r\n            authority: configuration.authority ?? utils_1.getImsAuthority(),\r\n        };\r\n    }\r\n    get isAuthorized() {\r\n        return this.hasSignedIn;\r\n    }\r\n    get hasExpired() {\r\n        if (this._expiresAt)\r\n            return this._expiresAt.getTime() - Date.now() <= 1 * 60 * 1000; // Consider 1 minute before expiry as expired;\r\n        return !this._accessToken;\r\n    }\r\n    get hasSignedIn() {\r\n        return !!this._accessToken;\r\n    }\r\n    get authorityUrl() {\r\n        return this._advancedSettings?.authority ?? this._basicSettings.authority;\r\n    }\r\n    async getUserManager() {\r\n        if (this._userManager) {\r\n            return this._userManager;\r\n        }\r\n        const settings = await this.getUserManagerSettings(this._basicSettings, this._advancedSettings);\r\n        this._userManager = this.createUserManager(settings);\r\n        return this._userManager;\r\n    }\r\n    /**\r\n     * Merges the basic and advanced settings into a single configuration object consumable by the internal userManager.\r\n     * @param basicSettings\r\n     * @param advancedSettings\r\n     * @returns a promise resolving to UserManagerSettings\r\n     */\r\n    async getUserManagerSettings(basicSettings, advancedSettings) {\r\n        let userManagerSettings = {\r\n            authority: this.authorityUrl,\r\n            redirect_uri: basicSettings.redirectUri,\r\n            client_id: basicSettings.clientId,\r\n            scope: basicSettings.scope,\r\n            post_logout_redirect_uri: basicSettings.postSignoutRedirectUri,\r\n            response_type: basicSettings.responseType,\r\n            automaticSilentRenew: true,\r\n            silent_redirect_uri: basicSettings.silentRedirectUri,\r\n            userStore: new oidc_client_ts_1.WebStorageStateStore({ store: window.localStorage }),\r\n            prompt: basicSettings.prompt,\r\n            response_mode: basicSettings.responseMode, // eslint-disable-line @typescript-eslint/naming-convention\r\n        };\r\n        if (advancedSettings) {\r\n            userManagerSettings = { ...userManagerSettings, ...advancedSettings };\r\n        }\r\n        return userManagerSettings;\r\n    }\r\n    /**\r\n     * Creates the internal user manager and binds all relevant events to their respective callback function.\r\n     * @param settings\r\n     */\r\n    createUserManager(settings) {\r\n        const userManager = new oidc_client_ts_1.UserManager(settings);\r\n        userManager.events.addUserLoaded(this._onUserLoaded);\r\n        userManager.events.addUserUnloaded(this._onUserUnloaded);\r\n        userManager.events.addAccessTokenExpiring(this._onAccessTokenExpiring);\r\n        userManager.events.addAccessTokenExpired(this._onAccessTokenExpired);\r\n        userManager.events.addSilentRenewError(this._onSilentRenewError);\r\n        userManager.events.addUserSignedOut(this._onUserSignedOut);\r\n        return userManager;\r\n    }\r\n    /**\r\n     * Alias for signInRedirect\r\n     */\r\n    async signIn() {\r\n        return this.signInRedirect();\r\n    }\r\n    /**\r\n     * Attempts a sign-in via redirection with the authorization provider.\r\n     * If possible, a non-interactive signin will be attempted first.\r\n     * If successful, the returned promise will be resolved.\r\n     * Otherwise, an attempt to redirect the browser will proceed.\r\n     * If an error prevents the redirection from occurring, the returned promise will be rejected with the responsible error.\r\n     * Otherwise, the browser's window will be redirected away from the current page, effectively ending execution here.\r\n     * @param successRedirectUrl - (optional) path to redirect to after a successful authorization\r\n     * @param args (optional) additional BrowserAuthorizationClientRequestOptions passed to signIn methods\r\n     */\r\n    async signInRedirect(successRedirectUrl, args) {\r\n        const user = await this.nonInteractiveSignIn(args);\r\n        if (user) {\r\n            return;\r\n        }\r\n        const userManager = await this.getUserManager();\r\n        const state = {\r\n            successRedirectUrl: successRedirectUrl || window.location.href,\r\n        };\r\n        const redirectArgs = { state, ...args };\r\n        await userManager.signinRedirect(redirectArgs); // This call changes the window's URL, which effectively ends execution here unless an exception is thrown.\r\n    }\r\n    /**\r\n     * Attempts a sign-in via popup with the authorization provider\r\n     * @param args - @see BrowserAuthorizationClientRequestOptions\r\n     */\r\n    async signInPopup(args) {\r\n        let user = await this.nonInteractiveSignIn(args);\r\n        if (user) {\r\n            return;\r\n        }\r\n        const userManager = await this.getUserManager();\r\n        user = await userManager.signinPopup(args);\r\n        if (!user || user.expired)\r\n            throw new Error(\"Expected userManager.signinPopup to always resolve to an authorized user\");\r\n        return;\r\n    }\r\n    /**\r\n     * Attempts a silent sign in with the authorization provider\r\n     * @throws [Error] If the silent sign in fails\r\n     */\r\n    async signInSilent() {\r\n        const user = await this.nonInteractiveSignIn();\r\n        if (user === undefined || user.expired)\r\n            throw new Error(\"Authorization error: Silent sign-in failed\");\r\n    }\r\n    /**\r\n     * Attempts a non-interactive signIn\r\n     * - tries to load the user from storage\r\n     * - tries to silently sign-in the user\r\n     */\r\n    async nonInteractiveSignIn(args) {\r\n        const userManager = await this.getUserManager();\r\n        const settingsPromptRequired = userManager.settings.prompt !== undefined && userManager.settings.prompt !== \"none\";\r\n        const argsPromptRequired = args?.prompt !== undefined && args.prompt !== \"none\";\r\n        if (settingsPromptRequired || argsPromptRequired) { // No need to even try a silent sign in if we know the prompt will force its failure.\r\n            return undefined;\r\n        }\r\n        let user = await this.loadUser();\r\n        if (user) {\r\n            return user;\r\n        }\r\n        // Attempt a silent sign-in\r\n        try {\r\n            user = await userManager.signinSilent() ?? undefined; // calls events\r\n            return user;\r\n        }\r\n        catch (err) {\r\n            return undefined;\r\n        }\r\n    }\r\n    /**\r\n     * Gets the user from storage\r\n     * @return User found in storage.\r\n     * - Resolves to undefined if no user was found.\r\n     * - Returned user may have expired - so it's up to the caller to check the expired state\r\n     */\r\n    async loadUser() {\r\n        const userManager = await this.getUserManager();\r\n        const user = await userManager.getUser();\r\n        if (user && !user.expired) {\r\n            this._onUserLoaded(user); // Call only because getUser() doesn't call any events\r\n            return user;\r\n        }\r\n        return undefined;\r\n    }\r\n    initAccessToken(user) {\r\n        if (!user) {\r\n            this._accessToken = \"\";\r\n            return;\r\n        }\r\n        this._accessToken = `Bearer ${user.access_token}`;\r\n        this._expiresAt = user.expires_at ? new Date(user.expires_at * 1000) : undefined;\r\n    }\r\n    /**\r\n     * Alias for signOutRedirect\r\n     */\r\n    async signOut() {\r\n        await this.signOutRedirect();\r\n    }\r\n    async signOutRedirect() {\r\n        const userManager = await this.getUserManager();\r\n        await userManager.signoutRedirect();\r\n    }\r\n    async signOutPopup() {\r\n        const userManager = await this.getUserManager();\r\n        await userManager.signoutPopup();\r\n    }\r\n    /**\r\n     * Returns a promise that resolves to the AccessToken of the currently authorized user.\r\n     * The token is refreshed as necessary.\r\n     * @throws [Error] If signIn() was not called, or there was an authorization error.\r\n     * @returns an AccessToken\r\n     */\r\n    async getAccessToken() {\r\n        if (this._accessToken)\r\n            return this._accessToken;\r\n        throw new Error(\"Authorization error: Not signed in.\");\r\n    }\r\n    /**\r\n     * Checks the current local user session against that of the identity provider.\r\n     * If the session is no longer valid, the local user is removed from storage.\r\n     * @returns true if the local session is still active with the provider, false otherwise.\r\n     */\r\n    async checkSessionStatus() {\r\n        const userManager = await this.getUserManager();\r\n        try {\r\n            await userManager.querySessionStatus();\r\n        }\r\n        catch (err) { // Access token is no longer valid in this session\r\n            await userManager.removeUser();\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    /** Disposes the resources held by this client */\r\n    dispose() {\r\n        if (this._userManager) {\r\n            this._userManager.events.removeUserLoaded(this._onUserLoaded);\r\n            this._userManager.events.removeAccessTokenExpiring(this._onAccessTokenExpiring);\r\n            this._userManager.events.removeAccessTokenExpired(this._onAccessTokenExpired);\r\n            this._userManager.events.removeUserUnloaded(this._onUserUnloaded);\r\n            this._userManager.events.removeSilentRenewError(this._onSilentRenewError);\r\n            this._userManager.events.removeUserSignedOut(this._onUserSignedOut);\r\n        }\r\n    }\r\n    /**\r\n     * @internal\r\n     * Allows for advanced options to be supplied to the underlying UserManager.\r\n     * This function should be called directly after object construction.\r\n     * Any settings supplied via this method will override the corresponding settings supplied via the constructor.\r\n     * @throws if called after the internal UserManager has already been created.\r\n     */\r\n    setAdvancedSettings(settings) {\r\n        if (this._userManager) {\r\n            throw new Error(\"Cannot supply advanced settings to BrowserAuthorizationClient after the underlying UserManager has already been created.\");\r\n        }\r\n        this._advancedSettings = settings;\r\n    }\r\n    /**\r\n     * Attempts to process a callback response in the current URL.\r\n     * When called successfully within an iframe or popup, the host frame will automatically be destroyed.\r\n     * @param responseMode - Defines how OIDC auth reponse parameters are encoded.\r\n     * @throws [[Error]] when this attempt fails for any reason.\r\n     */\r\n    async handleSigninCallbackInternal(responseMode) {\r\n        const userManager = await this.getUserManager();\r\n        // oidc-client-js uses an over-eager regex to parse the url, which may match values from the hash string when targeting the query string (and vice-versa)\r\n        // To ensure that this mismatching doesn't occur, we strip the unnecessary portion away here first.\r\n        const urlSuffix = responseMode === \"query\"\r\n            ? window.location.search\r\n            : window.location.hash;\r\n        const url = `${window.location.origin}${window.location.pathname}${urlSuffix}`;\r\n        const user = await userManager.signinCallback(url); // For silent or popup callbacks, execution effectively ends here, since the context will be destroyed.\r\n        if (!user || user.expired)\r\n            throw new Error(\"Authorization error: userManager.signinRedirectCallback does not resolve to authorized user\");\r\n        if (user.state) {\r\n            const state = user.state;\r\n            if (state.successRedirectUrl) { // Special case for signin via redirect used to return to the original location\r\n                window.location.replace(state.successRedirectUrl);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Attempts to parse an OIDC token from the current window URL\r\n     * When called within an iframe or popup, the host frame will automatically be destroyed before the promise resolves.\r\n     */\r\n    async handleSigninCallback() {\r\n        const url = new URL(this._basicSettings.redirectUri);\r\n        if (url.pathname !== window.location.pathname)\r\n            return;\r\n        let errorMessage = \"\";\r\n        try {\r\n            await this.handleSigninCallbackInternal(\"fragment\");\r\n            return;\r\n        }\r\n        catch (err) {\r\n            errorMessage += `${err.message}\\n`;\r\n        }\r\n        try {\r\n            await this.handleSigninCallbackInternal(\"query\");\r\n            return;\r\n        }\r\n        catch (err) {\r\n            errorMessage += `${err.message}\\n`;\r\n        }\r\n        if (window.self !== window.top) { // simply destroy the window if a failure is detected in an iframe.\r\n            window.close();\r\n            return;\r\n        }\r\n        errorMessage = `SigninCallback error - failed to process signin request in callback using all known modes of token delivery: ${errorMessage}`;\r\n        core_bentley_1.UnexpectedErrors.handle(new Error(errorMessage));\r\n    }\r\n    /**\r\n     * Configuration-less sign in callback. Useful for when a client instance with configuration is not present\r\n     * on the page or route where the callback is needed to finish the authentication process. Pulls configuration\r\n     * from localStorage.\r\n     *\r\n     * @param store - A Storage object such as sessionStorage which stores configuration. Defaults to localStorage\r\n     * which is also the default stateStore for this library. These stores should match.\r\n     */\r\n    static async handleSignInCallback(store = window.localStorage) {\r\n        const staticClient = new BrowserAuthorizationClient({});\r\n        this.loadSettingsFromStorage(staticClient, store);\r\n        await staticClient.handleSigninCallback();\r\n    }\r\n    static loadSettingsFromStorage(client, store) {\r\n        const url = new URL(window.location.href);\r\n        const nonce = url.searchParams.get(\"state\");\r\n        const storageEntry = store.getItem(`oidc.${nonce}`);\r\n        if (!storageEntry)\r\n            throw new Error(\"Could not load oidc settings from local storage. Ensure the client is configured properly\");\r\n        const storageObject = JSON.parse(storageEntry);\r\n        const transformed = {\r\n            ...storageObject,\r\n            clientId: storageObject.client_id,\r\n            redirectUri: storageObject.redirect_uri,\r\n            authority: storageObject.authority,\r\n        };\r\n        client._basicSettings = transformed;\r\n    }\r\n}\r\nBrowserAuthorizationClient_1 = Client.BrowserAuthorizationClient = BrowserAuthorizationClient;\r\n//# sourceMappingURL=Client.js.map\n\nexport { Client as __moduleExports, BrowserAuthorizationClient_1 as BrowserAuthorizationClient, isBrowserAuthorizationClient_1 as isBrowserAuthorizationClient, Client as default };",
      "start": 1693508118342,
      "end": 1693508123964,
      "order": "normal",
      "sourcemaps": {
        "version": 3,
        "file": null,
        "sources": [
          null
        ],
        "sourcesContent": [
          null
        ],
        "names": [],
        "mappings": "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"
      }
    }
  ]
}
