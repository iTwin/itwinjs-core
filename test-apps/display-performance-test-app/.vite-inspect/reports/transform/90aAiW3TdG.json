{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/common/lib/esm/TextureMapping.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Rendering\n */\nimport { Matrix3d, Point2d, Point3d, Transform, Vector3d } from \"@itwin/core-geometry\";\n/** Describes how to map a [[RenderTexture]]'s image onto a surface as part of a [[RenderMaterial]].\n * @public\n */\nexport class TextureMapping {\n    constructor(tx, params) {\n        this.texture = tx;\n        this.params = params;\n    }\n    /** @internal */\n    computeUVParams(visitor, transformToImodel) {\n        return this.params.computeUVParams(visitor, transformToImodel);\n    }\n}\n/** @public */\n(function (TextureMapping) {\n    /** Enumerates the possible texture mapping modes. */\n    let Mode;\n    (function (Mode) {\n        Mode[Mode[\"None\"] = -1] = \"None\";\n        Mode[Mode[\"Parametric\"] = 0] = \"Parametric\";\n        Mode[Mode[\"ElevationDrape\"] = 1] = \"ElevationDrape\";\n        Mode[Mode[\"Planar\"] = 2] = \"Planar\";\n        /** @internal */\n        Mode[Mode[\"DirectionalDrape\"] = 3] = \"DirectionalDrape\";\n        /** @internal */\n        Mode[Mode[\"Cubic\"] = 4] = \"Cubic\";\n        /** @internal */\n        Mode[Mode[\"Spherical\"] = 5] = \"Spherical\";\n        /** @internal */\n        Mode[Mode[\"Cylindrical\"] = 6] = \"Cylindrical\";\n        /** @internal */\n        Mode[Mode[\"Solid\"] = 7] = \"Solid\";\n        /** @internal Only valid for lights */\n        Mode[Mode[\"FrontProject\"] = 8] = \"FrontProject\";\n    })(Mode = TextureMapping.Mode || (TextureMapping.Mode = {}));\n    /** A 2x3 matrix for mapping a texture image to a surface. */\n    class Trans2x3 {\n        /** Construct from the two rows of the matrix:\n         * ```\n         *  | m00 m01 originX |\n         *  | m10 m11 originY |\n         * ```\n         * Producing the [Transform]($core-geometry):\n         * ```\n         *  | m00 m01 0 originX |\n         *  | m10 m11 0 originY |\n         *  | 0   0   1 0       |\n         * ```\n         */\n        constructor(m00 = 1, m01 = 0, originX = 0, m10 = 0, m11 = 1, originY = 0) {\n            const origin = new Point3d(originX, originY, 0);\n            const matrix = Matrix3d.createRowValues(m00, m01, 0, m10, m11, 0, 0, 0, 1);\n            this.transform = Transform.createRefs(origin, matrix);\n        }\n    }\n    /** An immutable 2x3 identity matrix. */\n    Trans2x3.identity = new Trans2x3();\n    TextureMapping.Trans2x3 = Trans2x3;\n    /** Parameters describing how a [[RenderTexture]]'s image is mapped to a surface. */\n    class Params {\n        constructor(props) {\n            this.textureMatrix = props?.textureMat2x3 ?? Trans2x3.identity;\n            this.weight = props?.textureWeight ?? 1;\n            this.mode = props?.mapMode ?? Mode.Parametric;\n            this.worldMapping = props?.worldMapping ?? false;\n            this.useConstantLod = props?.useConstantLod ?? false;\n            this.constantLodParams = {\n                repetitions: props?.constantLodProps?.repetitions ?? 1,\n                offset: props?.constantLodProps?.offset ?? { x: 0, y: 0 },\n                minDistClamp: props?.constantLodProps?.minDistClamp ?? 1,\n                maxDistClamp: props?.constantLodProps?.maxDistClamp ?? 4096 * 1024 * 1024,\n            };\n        }\n        /**\n         * Generates UV parameters for textured surfaces. Returns undefined on failure.\n         * @internal\n         */\n        computeUVParams(visitor, transformToImodel) {\n            switch (this.mode) {\n                default: // Fall through to parametric in default case\n                case TextureMapping.Mode.Parametric: {\n                    return this.computeParametricUVParams(visitor, this.textureMatrix.transform, !this.worldMapping);\n                }\n                case TextureMapping.Mode.Planar: {\n                    const normalIndices = visitor.normalIndex;\n                    if (!normalIndices)\n                        return undefined;\n                    // Ignore planar mode unless master or sub units for scaleMode and facet is planar\n                    if (!this.worldMapping || (visitor.normalIndex !== undefined && (normalIndices[0] !== normalIndices[1] || normalIndices[0] !== normalIndices[2]))) {\n                        return this.computeParametricUVParams(visitor, this.textureMatrix.transform, !this.worldMapping);\n                    }\n                    else {\n                        return this.computePlanarUVParams(visitor, this.textureMatrix.transform);\n                    }\n                }\n                case TextureMapping.Mode.ElevationDrape: {\n                    return this.computeElevationDrapeUVParams(visitor, this.textureMatrix.transform, transformToImodel);\n                }\n            }\n        }\n        /** Computes UV parameters given a texture mapping mode of parametric. */\n        computeParametricUVParams(visitor, uvTransform, isRelativeUnits) {\n            const params = [];\n            for (let i = 0; i < visitor.numEdgesThisFacet; i++) {\n                let param = Point2d.create();\n                if (isRelativeUnits || !visitor.tryGetDistanceParameter(i, param)) {\n                    if (!visitor.tryGetNormalizedParameter(i, param)) {\n                        // If mesh does not have facetFaceData, we still want to use the texture coordinates if they are present\n                        param = visitor.getParam(i);\n                    }\n                }\n                params.push(uvTransform.multiplyPoint2d(param));\n            }\n            return params;\n        }\n        /** Computes UV parameters given a texture mapping mode of planar. The result is stored in the Point2d array given. */\n        computePlanarUVParams(visitor, uvTransform) {\n            const params = [];\n            const points = visitor.point;\n            let normal;\n            if (visitor.normal === undefined)\n                normal = points.getPoint3dAtUncheckedPointIndex(0).crossProductToPoints(points.getPoint3dAtUncheckedPointIndex(1), points.getPoint3dAtUncheckedPointIndex(2));\n            else\n                normal = visitor.normal.getVector3dAtCheckedVectorIndex(0);\n            if (!normal.normalize(normal))\n                return undefined;\n            // adjust U texture coordinate to be a continuous length starting at the\n            // origin. V coordinate stays the same. This mode assumes Z is up vector\n            // Flipping normal puts us in a planar coordinate system consistent with MicroStation's display system\n            normal.scale(-1.0, normal);\n            // pick the first vertex normal\n            const sideVector = Vector3d.create(normal.y, -normal.x, 0.0);\n            // if the magnitude of the normal is near zero, the real normal points\n            // almost straighten up.. In this case, use Y as the up vector to match QV\n            const magnitude = sideVector.magnitude();\n            sideVector.normalize(sideVector); // won't remain undefined if failed due to following check..\n            if (magnitude < 1e-3) {\n                normal.set(0, 0, -1);\n                sideVector.set(1, 0, 0);\n            }\n            const upVector = sideVector.crossProduct(normal).normalize();\n            if (!upVector)\n                return undefined;\n            const numEdges = visitor.numEdgesThisFacet;\n            for (let i = 0; i < numEdges; i++) {\n                const vector = Vector3d.createFrom(points.getPoint3dAtUncheckedPointIndex(i));\n                params.push(Point2d.create(vector.dotProduct(sideVector), vector.dotProduct(upVector)));\n                uvTransform.multiplyPoint2d(params[i], params[i]);\n            }\n            return params;\n        }\n        /** Computes UV parameters given a texture mapping mode of elevation drape. The result is stored in the Point2d array given. */\n        computeElevationDrapeUVParams(visitor, uvTransform, transformToIModel) {\n            const params = [];\n            const numEdges = visitor.numEdgesThisFacet;\n            for (let i = 0; i < numEdges; i++) {\n                const point = visitor.point.getPoint3dAtUncheckedPointIndex(i);\n                if (transformToIModel !== undefined)\n                    transformToIModel.multiplyPoint3d(point, point);\n                params.push(Point2d.createFrom(point));\n                uvTransform.multiplyPoint2d(params[i], params[i]);\n            }\n            return params;\n        }\n    }\n    TextureMapping.Params = Params;\n})(TextureMapping || (TextureMapping = {}));\nObject.freeze(TextureMapping.Trans2x3.identity);\n//# sourceMappingURL=TextureMapping.js.map",
      "start": 1693508120769,
      "end": 1693508120828,
      "sourcemaps": null
    }
  ]
}
