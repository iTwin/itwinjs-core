{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/orbitgt/lib/esm/spatial/geom/Bounds.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module OrbitGT\n */\nimport { Coordinate } from \"./Coordinate\";\n/**\n * Class Bounds defines a 3D XYZ bounding box that can be empty.\n */\n/** @internal */\nexport class Bounds {\n    constructor() {\n        this.valid = false;\n        this.min = Coordinate.create();\n        this.max = Coordinate.create();\n    }\n    clear() {\n        this.valid = false;\n        this.min.clear();\n        this.max.clear();\n    }\n    isValid() {\n        return this.valid;\n    }\n    getMinX() {\n        return this.min.x;\n    }\n    getMinY() {\n        return this.min.y;\n    }\n    getMinZ() {\n        return this.min.z;\n    }\n    getMaxX() {\n        return this.max.x;\n    }\n    getMaxY() {\n        return this.max.y;\n    }\n    getMaxZ() {\n        return this.max.z;\n    }\n    addXYZ(x, y, z) {\n        if (this.valid == false) {\n            this.min.x = x;\n            this.min.y = y;\n            this.min.z = z;\n            this.max.x = x;\n            this.max.y = y;\n            this.max.z = z;\n            this.valid = true;\n        }\n        else {\n            if (x < this.min.x)\n                this.min.x = x;\n            if (y < this.min.y)\n                this.min.y = y;\n            if (z < this.min.z)\n                this.min.z = z;\n            if (x > this.max.x)\n                this.max.x = x;\n            if (y > this.max.y)\n                this.max.y = y;\n            if (z > this.max.z)\n                this.max.z = z;\n        }\n        return this;\n    }\n    add(c) {\n        return this.addXYZ(c.x, c.y, c.z);\n    }\n    containsXYZ(x, y, z) {\n        if (this.valid == false)\n            return false;\n        if (x < this.min.x)\n            return false;\n        if (y < this.min.y)\n            return false;\n        if (z < this.min.z)\n            return false;\n        if (x > this.max.x)\n            return false;\n        if (y > this.max.y)\n            return false;\n        if (z > this.max.z)\n            return false;\n        return true;\n    }\n    contains(c) {\n        return this.containsXYZ(c.x, c.y, c.z);\n    }\n    hasOverlapXYZ(x1, y1, z1, x2, y2, z2) {\n        if (this.valid == false)\n            return false;\n        let minX = Math.min(x1, x2);\n        let minY = Math.min(y1, y2);\n        let minZ = Math.min(z1, z2);\n        let maxX = Math.max(x1, x2);\n        let maxY = Math.max(y1, y2);\n        let maxZ = Math.max(z1, z2);\n        return ((maxX >= this.min.x) && (minX <= this.max.x) && (maxY >= this.min.y) && (minY <= this.max.y) && (maxZ >= this.min.z) && (minZ <= this.max.z));\n    }\n    getCorner(index, point) {\n        point.setX(((index & 1) == 0) ? this.min.x : this.max.x);\n        point.setY(((index & 2) == 0) ? this.min.y : this.max.y);\n        point.setZ(((index & 4) == 0) ? this.min.z : this.max.z);\n    }\n    getIntersection(other) {\n        /* Define the intersection */\n        let intersection = new Bounds();\n        /* Both boxes should be valid */\n        if (this.valid == false)\n            return intersection;\n        if (other.valid == false)\n            return intersection;\n        /* Intersect X */\n        let minX = Math.max(this.min.x, other.min.x);\n        let maxX = Math.min(this.max.x, other.max.x);\n        if (minX > maxX)\n            return intersection;\n        /* Intersect Y */\n        let minY = Math.max(this.min.y, other.min.y);\n        let maxY = Math.min(this.max.y, other.max.y);\n        if (minY > maxY)\n            return intersection;\n        /* Intersect Z */\n        let minZ = Math.max(this.min.z, other.min.z);\n        let maxZ = Math.min(this.max.z, other.max.z);\n        if (minZ > maxZ)\n            return intersection;\n        /* Empty? */\n        if ((minX == maxX) && (minY == maxY) && (minZ == maxZ))\n            return intersection;\n        /* Return the intersection */\n        intersection.valid = true;\n        intersection.min.x = minX;\n        intersection.max.x = maxX;\n        intersection.min.y = minY;\n        intersection.max.y = maxY;\n        intersection.min.z = minZ;\n        intersection.max.z = maxZ;\n        return intersection;\n    }\n    toString() {\n        if (this.valid)\n            return \"(min:\" + this.min.x + \",\" + this.min.y + \",\" + this.min.z + \",max:\" + this.max.x + \",\" + this.max.y + \",\" + this.max.z + \")\";\n        else\n            return \"(invalid)\";\n    }\n}\n//# sourceMappingURL=Bounds.js.map",
      "start": 1693508124803,
      "end": 1693508124927,
      "sourcemaps": null
    }
  ]
}
