{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/GraphicBranch.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Rendering\n */\nimport { disposeArray } from \"@itwin/core-bentley\";\nimport { IModelApp } from \"../IModelApp\";\n/**\n * A node in a scene graph. The branch itself is not renderable. Instead it contains a list of RenderGraphics,\n * and a transform, symbology overrides, and clip volume which are to be applied when rendering them.\n * Branches can be nested to build an arbitrarily-complex scene graph.\n * @see [[RenderSystem.createBranch]]\n * @public\n * @extensions\n */\nexport class GraphicBranch {\n    /** Constructor\n     * @param ownsEntries If true, when this branch is [[dispose]]d, all of the [[RenderGraphic]]s it contains will also be disposed.\n     */\n    constructor(ownsEntries = false) {\n        /** The child nodes of this branch */\n        this.entries = [];\n        /** Selectively overrides the view's [ViewFlags]($common) while drawing graphics within this branch. The default overrides nothing.\n         * @see [[setViewFlagOverrides]].\n         */\n        this.viewFlagOverrides = {};\n        this.ownsEntries = ownsEntries;\n    }\n    /** Add a graphic to this branch. */\n    add(graphic) {\n        this.entries.push(graphic);\n    }\n    /** Compute the view flags that result from applying this branch's [[viewFlagOverrides]] to the input flags.\n     * @param flags The input view flags, e.g., from the view's [[DisplayStyleState]].\n     * @returns The result of applying [[viewFlagOverrides]] to `flags`.\n     */\n    getViewFlags(flags) {\n        return flags.override(this.viewFlagOverrides);\n    }\n    /** Set [[viewFlagOverrides]] to override **all** ViewFlags as specified by `flags`. */\n    setViewFlags(flags) {\n        this.viewFlagOverrides = { ...flags };\n    }\n    /** Change [[viewFlagOverrides]]. */\n    setViewFlagOverrides(ovr) {\n        this.viewFlagOverrides = { ...ovr };\n    }\n    /** Disposes of all graphics in this branch, if and only if [[ownsEntries]] is true. */\n    dispose() {\n        this.clear();\n    }\n    /** Returns true if this branch contains no graphics. */\n    get isEmpty() {\n        return 0 === this.entries.length;\n    }\n    /** Empties the list of [[RenderGraphic]]s contained in this branch, and if the [[ownsEntries]] flag is set, also disposes of them. */\n    clear() {\n        if (this.ownsEntries)\n            disposeArray(this.entries);\n        else\n            this.entries.length = 0;\n    }\n    /** @internal */\n    collectStatistics(stats) {\n        for (const entry of this.entries)\n            entry.collectStatistics(stats);\n    }\n}\n/** @internal */\nexport function formatAnimationBranchId(modelId, branchId) {\n    if (branchId < 0)\n        return modelId;\n    return `${modelId}_Node_${branchId.toString()}`;\n}\nfunction addAnimationBranch(modelId, timeline, branchId, branches, time) {\n    const clipVector = timeline.getClipVector(time);\n    const clip = clipVector ? IModelApp.renderSystem.createClipVolume(clipVector) : undefined;\n    if (clip)\n        branches.set(formatAnimationBranchId(modelId, branchId), { clip });\n}\n/** @internal */\nexport var AnimationBranchStates;\n(function (AnimationBranchStates) {\n    function fromScript(script, time) {\n        if (!script.containsModelClipping && !script.requiresBatching)\n            return undefined;\n        const branches = new Map();\n        for (const model of script.modelTimelines) {\n            addAnimationBranch(model.modelId, model, -1, branches, time);\n            for (const elem of model.elementTimelines) {\n                if (elem.getVisibility(time) <= 0)\n                    branches.set(formatAnimationBranchId(model.modelId, elem.batchId), { omit: true });\n                else\n                    addAnimationBranch(model.modelId, elem, elem.batchId, branches, time);\n            }\n        }\n        return {\n            branchStates: branches,\n            transformNodeIds: script.transformBatchIds,\n        };\n    }\n    AnimationBranchStates.fromScript = fromScript;\n})(AnimationBranchStates || (AnimationBranchStates = {}));\n//# sourceMappingURL=GraphicBranch.js.map",
      "start": 1693508119446,
      "end": 1693508119632,
      "sourcemaps": null
    }
  ]
}
