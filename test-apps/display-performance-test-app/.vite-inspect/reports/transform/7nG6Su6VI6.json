{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/bentley/lib/esm/Tracing.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Logging\n */\nimport { Logger } from \"./Logger\";\n// re-export so that consumers can construct full SpanOptions object without external dependencies\n/**\n * Mirrors the SpanKind enum from [@opentelemetry/api](https://open-telemetry.github.io/opentelemetry-js/enums/_opentelemetry_api.SpanKind.html)\n * @public\n */\nexport var SpanKind;\n(function (SpanKind) {\n    SpanKind[SpanKind[\"INTERNAL\"] = 0] = \"INTERNAL\";\n    SpanKind[SpanKind[\"SERVER\"] = 1] = \"SERVER\";\n    SpanKind[SpanKind[\"CLIENT\"] = 2] = \"CLIENT\";\n    SpanKind[SpanKind[\"PRODUCER\"] = 3] = \"PRODUCER\";\n    SpanKind[SpanKind[\"CONSUMER\"] = 4] = \"CONSUMER\";\n})(SpanKind || (SpanKind = {}));\nfunction isValidPrimitive(val) {\n    return typeof val === \"string\" || typeof val === \"number\" || typeof val === \"boolean\";\n}\n// Only _homogenous_ arrays of strings, numbers, or booleans are supported as OpenTelemetry Attribute values.\n// Per the spec (https://opentelemetry.io/docs/reference/specification/common/common/#attribute), empty arrays and null values are supported too.\nfunction isValidPrimitiveArray(val) {\n    if (!Array.isArray(val))\n        return false;\n    let itemType;\n    for (const x of val) {\n        if (x === undefined || x === null)\n            continue;\n        if (!itemType) {\n            itemType = typeof x;\n            if (!isValidPrimitive(x))\n                return false;\n        }\n        if (typeof x !== itemType)\n            return false;\n    }\n    return true;\n}\nfunction isPlainObject(obj) {\n    return typeof obj === \"object\" && obj !== null && Object.getPrototypeOf(obj) === Object.prototype;\n}\nfunction* getFlatEntries(obj, path = \"\") {\n    if (isValidPrimitiveArray(obj)) {\n        yield [path, obj];\n        return;\n    }\n    // Prefer JSON serialization over flattening for any non-POJO types.\n    // There's just too many ways trying to flatten those can go wrong (Dates, Buffers, TypedArrays, etc.)\n    if (!isPlainObject(obj) && !Array.isArray(obj)) {\n        yield [path, isValidPrimitive(obj) ? obj : JSON.stringify(obj)];\n        return;\n    }\n    // Always serialize empty objects/arrays as empty array values\n    const entries = Object.entries(obj);\n    if (entries.length === 0)\n        yield [path, []];\n    for (const [key, val] of entries)\n        yield* getFlatEntries(val, (path === \"\") ? key : `${path}.${key}`);\n}\nfunction flattenObject(obj) {\n    return Object.fromEntries(getFlatEntries(obj));\n}\n/**\n * Enables OpenTelemetry tracing in addition to traditional logging.\n * @public\n */\nexport class Tracing {\n    /**\n     * If OpenTelemetry tracing is enabled, creates a new span and runs the provided function in it.\n     * If OpenTelemetry tracing is _not_ enabled, runs the provided function.\n     * @param name name of the new span\n     * @param fn function to run inside the new span\n     * @param options span options\n     * @param parentContext optional context used to retrieve parent span id\n     */\n    static async withSpan(name, fn, options, parentContext) {\n        if (Tracing._tracer === undefined || Tracing._openTelemetry === undefined)\n            return fn();\n        // this case is for context propagation - parentContext is typically constructed from HTTP headers\n        const parent = parentContext === undefined\n            ? Tracing._openTelemetry.context.active()\n            : Tracing._openTelemetry.trace.setSpanContext(Tracing._openTelemetry.context.active(), parentContext);\n        return Tracing._openTelemetry.context.with(Tracing._openTelemetry.trace.setSpan(parent, Tracing._tracer.startSpan(name, options, Tracing._openTelemetry.context.active())), async () => {\n            try {\n                return await fn();\n            }\n            catch (err) {\n                if (err instanceof Error) // ignore non-Error throws, such as RpcControlResponse\n                    Tracing._openTelemetry?.trace.getSpan(Tracing._openTelemetry.context.active())?.setAttribute(\"error\", true);\n                throw err;\n            }\n            finally {\n                Tracing._openTelemetry?.trace.getSpan(Tracing._openTelemetry.context.active())?.end();\n            }\n        });\n    }\n    /**\n     * Enable logging to OpenTelemetry. [[Tracing.withSpan]] will be enabled, all log entries will be attached to active span as span events.\n     * [IModelHost.startup]($backend) will call this automatically if the `enableOpenTelemetry` option is enabled and it succeeds in requiring `@opentelemetry/api`.\n     * @note Node.js OpenTelemetry SDK should be initialized by the user.\n     */\n    static enableOpenTelemetry(tracer, api) {\n        Tracing._tracer = tracer;\n        Tracing._openTelemetry = api;\n        Logger.logTrace = Tracing.withOpenTelemetry(Logger.logTrace.bind(Logger)).bind(Logger);\n        Logger.logInfo = Tracing.withOpenTelemetry(Logger.logInfo.bind(Logger)).bind(Logger);\n        Logger.logWarning = Tracing.withOpenTelemetry(Logger.logWarning.bind(Logger)).bind(Logger);\n        Logger.logError = Tracing.withOpenTelemetry(Logger.logError.bind(Logger)).bind(Logger);\n    }\n    static withOpenTelemetry(base, isError = false) {\n        return (category, message, metaData) => {\n            try {\n                Tracing._openTelemetry?.trace.getSpan(Tracing._openTelemetry.context.active())?.addEvent(message, { ...flattenObject(Logger.getMetaData(metaData)), error: isError });\n            }\n            catch (_e) { } // avoid throwing random errors (with stack trace mangled by async hooks) when openTelemetry collector doesn't work\n            base(category, message, metaData);\n        };\n    }\n    /** Set attributes on currently active openTelemetry span. Doesn't do anything if openTelemetry logging is not initialized.\n     * @param attributes The attributes to set\n     */\n    static setAttributes(attributes) {\n        Tracing._openTelemetry?.trace.getSpan(Tracing._openTelemetry.context.active())?.setAttributes(attributes);\n    }\n}\n//# sourceMappingURL=Tracing.js.map",
      "start": 1693508120433,
      "end": 1693508120487,
      "sourcemaps": null
    }
  ]
}
