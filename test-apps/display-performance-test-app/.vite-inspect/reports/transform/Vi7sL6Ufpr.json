{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/bspline/BSplineCurve.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Bspline\n */\nimport { CurveIntervalRole, CurveLocationDetail } from \"../curve/CurveLocationDetail\";\nimport { CurvePrimitive } from \"../curve/CurvePrimitive\";\nimport { CurveOffsetXYHandler } from \"../curve/internalContexts/CurveOffsetXYHandler\";\nimport { PlaneAltitudeRangeContext } from \"../curve/internalContexts/PlaneAltitudeRangeContext\";\nimport { OffsetOptions } from \"../curve/OffsetOptions\";\nimport { StrokeCountMap } from \"../curve/Query/StrokeCountMap\";\nimport { Geometry } from \"../Geometry\";\nimport { GrowableXYZArray } from \"../geometry3d/GrowableXYZArray\";\nimport { Plane3dByOriginAndVectors } from \"../geometry3d/Plane3dByOriginAndVectors\";\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\nimport { Point3dArray } from \"../geometry3d/PointHelpers\";\nimport { Range1d } from \"../geometry3d/Range\";\nimport { Ray3d } from \"../geometry3d/Ray3d\";\nimport { Point4d } from \"../geometry4d/Point4d\";\nimport { UnivariateBezier } from \"../numerics/BezierPolynomials\";\nimport { Bezier1dNd } from \"./Bezier1dNd\";\nimport { BezierCurve3d } from \"./BezierCurve3d\";\nimport { BezierCurve3dH } from \"./BezierCurve3dH\";\nimport { BSpline1dNd } from \"./BSpline1dNd\";\nimport { BSplineCurveOps } from \"./BSplineCurveOps\";\nimport { BSplineWrapMode, KnotVector } from \"./KnotVector\";\n/**\n * Base class for BSplineCurve3d and BSplineCurve3dH.\n * * A bspline curve consists of a set of knots and a set of poles.\n * * The bspline curve is a function of the independent \"knot axis\" variable\n * * The curve \"follows\" the poles loosely.\n * * The is a set of polynomial spans.\n * * The polynomial spans all have same `degree`.\n * * Within each span, the polynomial of that `degree` is controlled by `order = degree + 1` contiguous points called poles.\n * * The is a strict relationship between knot and poles counts:  `numPoles + order = numKnots + 2'\n * * The number of spans is `numSpan = numPoles - degree`\n * * For a given `spanIndex`:\n *   * The `order` poles begin at index `spanIndex`.\n *   * The `2*order` knots begin as span index\n *   * The knot interval for this span is from `knot[degree+span-1] to knot[degree+span]`\n * * The active part of the knot axis is `knot[degree-1] < knot < knot[degree-1 + numSpan]` i.e. `knot[degree-1] < knot < knot[numPoles]\n *\n * Nearly all bsplines are \"clamped \".\n * * Clamping make the curve pass through its first and last poles, with tangents directed along the first and last edges of the control polygon.\n * * The knots for a clamped bspline have `degree` copies of the lowest knot value and `degree` copies of the highest knot value.\n * * For instance, the knot vector `[0,0,0,1,2,3,3,3]\n *   * can be evaluated from `0<=knot<=3`\n *   * has 3 spans: 0 to 1, 1 to 2, 2 to 3\n *   * has 6 poles\n *   * passes through its first and last poles.\n * * `create` methods may allow classic convention that has an extra knot at the beginning and end of the knot vector.\n *   * The extra knots (first and last) were never referenced by the bspline recurrence relations.\n *   * When the `create` methods recognize the classic setup (`numPoles + order = numKnots`), the extra knot is not saved with the BSplineCurve3dBase knots.\n *\n * * The weighted variant has the problem that CurvePrimitive 3d typing does not allow undefined result where Point4d has zero weight.\n * * The convention for these is to return 000 in such places.\n *\n * * Note the class relationships:\n *   * BSpline1dNd knows the bspline recurrence relations for control points (poles) with no physical meaning.\n *   * BsplineCurve3dBase owns a protected BSpline1dNd\n *   * BsplineCurve3dBase is derived from CurvePrimitive, which creates obligation to act as a 3D curve, such as\n *     * evaluate fraction to point and derivatives wrt fraction\n *     * compute intersection with plane\n *   * BSplineCurve3d and BSplineCurve3dH have variant logic driven by whether or not there are \"weights\" on the poles.\n *     * For `BSplineCurve3d`, the xyz value of pole calculations are \"final\" values for 3d evaluation\n *     * For `BSplineCurve3dH`, various `BSpline1dNd` results with xyzw have to be normalized back to xyz.\n *\n * * These classes do not support \"periodic\" variants.\n *   * Periodic curves need to have certain leading knots and poles replicated at the end\n * @public\n */\nexport class BSplineCurve3dBase extends CurvePrimitive {\n    set definitionData(data) { this._definitionData = data; }\n    get definitionData() { return this._definitionData; }\n    constructor(poleDimension, numPoles, order, knots) {\n        super();\n        /** String name for schema properties */\n        this.curvePrimitiveType = \"bsplineCurve\";\n        this._bcurve = BSpline1dNd.create(numPoles, poleDimension, order, knots);\n    }\n    /** Return the degree (one less than the order) of the curve */\n    get degree() { return this._bcurve.degree; }\n    /** Return the order (one more than degree) of the curve */\n    get order() { return this._bcurve.order; }\n    /** Return the number of bezier spans in the curve.  Note that this number includes the number of null spans at repeated knows */\n    get numSpan() { return this._bcurve.numSpan; }\n    /** Return the number of poles */\n    get numPoles() { return this._bcurve.numPoles; }\n    /**\n   * return a simple array form of the knots.  optionally replicate the first and last\n   * in classic over-clamped manner\n   */\n    copyKnots(includeExtraEndKnot) { return this._bcurve.knots.copyKnots(includeExtraEndKnot); }\n    /**\n   * Set the flag indicating the bspline might be suitable for having wrapped \"closed\" interpretation.\n   */\n    setWrappable(value) {\n        this._bcurve.knots.wrappable = value;\n    }\n    /** Evaluate the curve point at `fraction` */\n    fractionToPoint(fraction, result) {\n        return this.knotToPoint(this._bcurve.knots.fractionToKnot(fraction), result);\n    }\n    /** Construct a ray with\n     * * origin at the fractional position along the arc\n     * * direction is the first derivative, i.e. tangent along the curve\n     */\n    fractionToPointAndDerivative(fraction, result) {\n        const knot = this._bcurve.knots.fractionToKnot(fraction);\n        result = this.knotToPointAndDerivative(knot, result);\n        result.direction.scaleInPlace(this._bcurve.knots.knotLength01);\n        return result;\n    }\n    /** Construct a plane with\n     * * origin at the fractional position along the arc\n     * * x axis is the first derivative, i.e. tangent along the curve\n     * * y axis is the second derivative\n     */\n    fractionToPointAnd2Derivatives(fraction, result) {\n        const knot = this._bcurve.knots.fractionToKnot(fraction);\n        result = this.knotToPointAnd2Derivatives(knot, result);\n        const a = this._bcurve.knots.knotLength01;\n        result.vectorU.scaleInPlace(a);\n        result.vectorV.scaleInPlace(a * a);\n        return result;\n    }\n    /**\n     * Return the start point of the curve.\n     */\n    startPoint() { return this.evaluatePointInSpan(0, 0.0); }\n    /**\n     * Return the end point of the curve\n     */\n    endPoint() { return this.evaluatePointInSpan(this.numSpan - 1, 1.0); }\n    /** Reverse the curve in place.\n     * * Poles are reversed\n     * * knot values are mirrored around the middle of the\n     */\n    reverseInPlace() { this._bcurve.reverseInPlace(); }\n    /**\n     * Return an array with this curve's bezier fragments.\n     */\n    collectBezierSpans(prefer3dH) {\n        const result = [];\n        const numSpans = this.numSpan;\n        for (let i = 0; i < numSpans; i++) {\n            if (this._bcurve.knots.isIndexOfRealSpan(i)) {\n                const span = this.getSaturatedBezierSpan3dOr3dH(i, prefer3dH);\n                if (span)\n                    result.push(span);\n            }\n        }\n        return result;\n    }\n    /** Given a pole index, return the starting index for the contiguous array. */\n    poleIndexToDataIndex(poleIndex) {\n        if (poleIndex >= 0 && poleIndex < this.numPoles)\n            return poleIndex * this._bcurve.poleLength;\n        return undefined;\n    }\n    /** Search for the curve point that is closest to the spacePoint.\n     *\n     * * If the space point is exactly on the curve, this is the reverse of fractionToPoint.\n     * * Since CurvePrimitive should always have start and end available as candidate points, this method should always succeed\n     * @param spacePoint point in space\n     * @param _extend ignored. A BSplineCurve3dBase cannot be extended.\n     * @returns Returns a CurveLocationDetail structure that holds the details of the close point.\n     */\n    closestPoint(spacePoint, _extend) {\n        // seed at start point -- final point comes with final bezier perpendicular step.\n        const point = this.fractionToPoint(0);\n        const result = CurveLocationDetail.createCurveFractionPointDistance(this, 0.0, point, point.distance(spacePoint));\n        let span;\n        const numSpans = this.numSpan;\n        for (let i = 0; i < numSpans; i++) {\n            if (this._bcurve.knots.isIndexOfRealSpan(i)) {\n                span = this.getSaturatedBezierSpan3dOr3dH(i, true, span);\n                if (span) {\n                    // umm ... if the bspline is discontinuous, both ends should be tested.  Ignore that possibility ...\n                    if (span.updateClosestPointByTruePerpendicular(spacePoint, result, false, true)) {\n                        // the detail records the span bezier -- promote it to the parent curve . ..\n                        result.curve = this;\n                        result.fraction = span.fractionToParentFraction(result.fraction);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n    /** Return a transformed deep clone. */\n    cloneTransformed(transform) {\n        const curve1 = this.clone();\n        curve1.tryTransformInPlace(transform);\n        return curve1;\n    }\n    /** Return a curve primitive which is a portion of this curve.\n     * @param fractionA [in] start fraction\n     * @param fractionB [in] end fraction\n     */\n    clonePartialCurve(fractionA, fractionB) {\n        const clone = this.clone();\n        const origNumKnots = clone._bcurve.knots.knots.length;\n        let knotA = clone._bcurve.knots.fractionToKnot(fractionA);\n        let knotB = clone._bcurve.knots.fractionToKnot(fractionB);\n        clone._bcurve.addKnot(knotA, clone.degree);\n        clone._bcurve.addKnot(knotB, clone.degree);\n        if (origNumKnots === clone._bcurve.knots.knots.length)\n            return clone; // full curve\n        if (knotA > knotB) {\n            const tmp = knotA;\n            knotA = knotB;\n            knotB = tmp;\n        }\n        // choose first/last knot and pole such that knotA/knotB has degree multiplicity in the new knot sequence\n        const iStartKnot = clone._bcurve.knots.knotToLeftKnotIndex(knotA) - clone.degree + 1;\n        const iStartPole = iStartKnot * clone._bcurve.poleLength;\n        const iLastKnot = clone._bcurve.knots.knotToLeftKnotIndex(knotB);\n        let iLastKnotLeftMultiple = iLastKnot - clone._bcurve.knots.getKnotMultiplicityAtIndex(iLastKnot) + 1;\n        if (clone._bcurve.knots.knots[iLastKnot] < knotB)\n            iLastKnotLeftMultiple = iLastKnot + 1;\n        const iEndPole = (iLastKnotLeftMultiple + 1) * clone._bcurve.poleLength; // one past last pole\n        const iEndKnot = iLastKnotLeftMultiple + clone.degree; // one past last knot\n        // trim the arrays (leave knots unnormalized!)\n        clone._bcurve.knots.setKnotsCapture(clone._bcurve.knots.knots.slice(iStartKnot, iEndKnot));\n        clone._bcurve.packedData = clone._bcurve.packedData.slice(iStartPole, iEndPole);\n        clone.setWrappable(BSplineWrapMode.None); // always open\n        return clone;\n    }\n    /** Implement `CurvePrimitive.appendPlaneIntersections`\n     * @param plane A plane (e.g. specific type Plane3dByOriginAndUnitNormal or Point4d)\n     * @param result growing array of plane intersections\n     * @return number of intersections appended to the array.\n    */\n    appendPlaneIntersectionPoints(plane, result) {\n        const numPole = this.numPoles;\n        const order = this.order;\n        const allCoffs = new Float64Array(numPole);\n        const numSpan = this.numSpan;\n        const point4d = Point4d.create();\n        // compute all pole altitudes from the plane\n        const minMax = Range1d.createNull();\n        // Put the altitudes of all the bspline poles in one array.\n        for (let i = 0; i < numPole; i++) {\n            allCoffs[i] = plane.weightedAltitude(this.getPolePoint4d(i, point4d));\n            minMax.extendX(allCoffs[i]);\n        }\n        // A univariate bspline through the altitude poles gives altitude as function of the bspline knot.\n        // The (bspline) altitude function for each span is `order` consecutive altitudes.\n        // If those altitudes bracket zero, the span may potentially have a crossing.\n        // When that occurs,\n        let univariateBezier;\n        let numFound = 0;\n        let previousFraction = -1000.0;\n        if (minMax.containsX(0.0)) {\n            for (let spanIndex = 0; spanIndex < numSpan; spanIndex++) {\n                if (this._bcurve.knots.isIndexOfRealSpan(spanIndex)) { // ignore trivial knot intervals.\n                    // outer range test ...\n                    minMax.setNull();\n                    minMax.extendArraySubset(allCoffs, spanIndex, order);\n                    if (minMax.containsX(0.0)) {\n                        // pack the bspline support into a univariate bezier ...\n                        univariateBezier = UnivariateBezier.createArraySubset(allCoffs, spanIndex, order, univariateBezier);\n                        // saturate and solve the bezier\n                        Bezier1dNd.saturate1dInPlace(univariateBezier.coffs, this._bcurve.knots, spanIndex);\n                        const roots = univariateBezier.roots(0.0, true);\n                        if (roots) {\n                            for (const spanFraction of roots) {\n                                // promote each local bezier fraction to global fraction.\n                                // save the curve evaluation at that fraction.\n                                numFound++;\n                                const fraction = this._bcurve.knots.spanFractionToFraction(spanIndex, spanFraction);\n                                if (!Geometry.isAlmostEqualNumber(fraction, previousFraction)) {\n                                    const detail = CurveLocationDetail.createCurveEvaluatedFraction(this, fraction);\n                                    detail.intervalRole = CurveIntervalRole.isolated;\n                                    result.push(detail);\n                                    previousFraction = fraction;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return numFound;\n    }\n    /**\n     * Construct an offset of the instance curve as viewed in the xy-plane (ignoring z).\n     * * No attempt is made to join the offsets of smaller constituent primitives. To construct a fully joined offset\n     *   for an aggregate instance (e.g., LineString3d, CurveChainWithDistanceIndex), use RegionOps.constructCurveXYOffset() instead.\n     * @param offsetDistanceOrOptions offset distance (positive to left of the instance curve), or options object\n     */\n    constructOffsetXY(offsetDistanceOrOptions) {\n        const options = OffsetOptions.create(offsetDistanceOrOptions);\n        const handler = new CurveOffsetXYHandler(this, options.leftOffsetDistance);\n        this.emitStrokableParts(handler, options.strokeOptions);\n        return handler.claimResult();\n    }\n    /** Project instance geometry (via dispatch) onto the given ray, and return the extreme fractional parameters of projection.\n     * @param ray ray onto which the instance is projected. A `Vector3d` is treated as a `Ray3d` with zero origin.\n     * @param lowHigh optional receiver for output\n     * @returns range of fractional projection parameters onto the ray, where 0.0 is start of the ray and 1.0 is the end of the ray.\n     */\n    projectedParameterRange(ray, lowHigh) {\n        return PlaneAltitudeRangeContext.findExtremeFractionsAlongDirection(this, ray, lowHigh);\n    }\n}\n/**\n * A BSplineCurve3d is a bspline curve whose poles are Point3d.\n * See BSplineCurve3dBase for description of knots, order, degree.\n * @public\n */\nexport class BSplineCurve3d extends BSplineCurve3dBase {\n    initializeWorkBezier() {\n        if (this._workBezier === undefined)\n            this._workBezier = BezierCurve3d.createOrder(this.order);\n        return this._workBezier;\n    }\n    /** test of `other` is an instance of BSplineCurve3d */\n    isSameGeometryClass(other) { return other instanceof BSplineCurve3d; }\n    /** Apply `transform` to the poles. */\n    tryTransformInPlace(transform) { Point3dArray.multiplyInPlace(transform, this._bcurve.packedData); return true; }\n    /** Get a pole as simple Point3d. */\n    getPolePoint3d(poleIndex, result) {\n        const k = this.poleIndexToDataIndex(poleIndex);\n        if (k !== undefined) {\n            const data = this._bcurve.packedData;\n            return Point3d.create(data[k], data[k + 1], data[k + 2], result);\n        }\n        return undefined;\n    }\n    /** Get a pole as Point4d with weight 1 */\n    getPolePoint4d(poleIndex, result) {\n        const k = this.poleIndexToDataIndex(poleIndex);\n        if (k !== undefined) {\n            const data = this._bcurve.packedData;\n            return Point4d.create(data[k], data[k + 1], data[k + 2], 1.0, result);\n        }\n        return undefined;\n    }\n    /** Convert  `spanIndex` and `localFraction` to a knot. */\n    spanFractionToKnot(span, localFraction) {\n        return this._bcurve.spanFractionToKnot(span, localFraction);\n    }\n    constructor(numPoles, order, knots) {\n        super(3, numPoles, order, knots);\n    }\n    /** Return a simple array of arrays with the control points as `[[x,y,z],[x,y,z],..]` */\n    copyPoints() { return Point3dArray.unpackNumbersToNestedArrays(this._bcurve.packedData, 3); }\n    /** Return a simple array of the control points coordinates */\n    copyPointsFloat64Array() { return this._bcurve.packedData.slice(); }\n    /**\n     * return a simple array form of the knots.  optionally replicate the first and last\n     * in classic over-clamped manner\n     */\n    copyKnots(includeExtraEndKnot) { return this._bcurve.knots.copyKnots(includeExtraEndKnot); }\n    /** Create a bspline with uniform knots. */\n    static createUniformKnots(poles, order) {\n        const numPoles = poles instanceof Float64Array ? poles.length / 3 : poles.length;\n        if (order < 2 || numPoles < order)\n            return undefined;\n        const knots = KnotVector.createUniformClamped(numPoles, order - 1, 0.0, 1.0);\n        const curve = new BSplineCurve3d(numPoles, order, knots);\n        if (poles instanceof Float64Array) {\n            for (let i = 0; i < 3 * numPoles; i++)\n                curve._bcurve.packedData[i] = poles[i];\n        }\n        else if (poles instanceof GrowableXYZArray) {\n            curve._bcurve.packedData = poles.float64Data().slice(0, 3 * numPoles);\n        }\n        else {\n            let i = 0;\n            for (const p of poles) {\n                curve._bcurve.packedData[i++] = p.x;\n                curve._bcurve.packedData[i++] = p.y;\n                curve._bcurve.packedData[i++] = p.z;\n            }\n        }\n        return curve;\n    }\n    /** Create a smoothly closed B-spline curve with uniform knots.\n     *  Note that the curve does not start at the first pole!\n    */\n    static createPeriodicUniformKnots(poles, order) {\n        if (order < 2)\n            return undefined;\n        let numPoles = poles instanceof Float64Array ? poles.length / 3 : poles.length;\n        const startPoint = Point3d.createZero();\n        const endPoint = Point3d.createZero();\n        let hasClosurePoint = false;\n        do {\n            if (poles instanceof Float64Array) {\n                startPoint.set(poles[0], poles[1], poles[2]);\n                endPoint.set(poles[3 * numPoles - 3], poles[3 * numPoles - 2], poles[3 * numPoles - 1]);\n            }\n            else if (poles instanceof GrowableXYZArray) {\n                startPoint.set(poles.float64Data()[0], poles.float64Data()[1], poles.float64Data()[2]);\n                endPoint.set(poles.float64Data()[3 * numPoles - 3], poles.float64Data()[3 * numPoles - 2], poles.float64Data()[3 * numPoles - 1]);\n            }\n            else {\n                startPoint.setFromPoint3d(poles[0]);\n                endPoint.setFromPoint3d(poles[numPoles - 1]);\n            }\n            if (hasClosurePoint = startPoint.isAlmostEqual(endPoint))\n                --numPoles; // remove wraparound pole if found\n        } while (hasClosurePoint && numPoles > 1);\n        if (numPoles < order)\n            return undefined;\n        const degree = order - 1;\n        const numIntervals = numPoles;\n        const knots = KnotVector.createUniformWrapped(numIntervals, degree, 0.0, 1.0);\n        knots.wrappable = BSplineWrapMode.OpenByAddingControlPoints;\n        // append degree wraparound poles\n        const curve = new BSplineCurve3d(numPoles + degree, order, knots);\n        if (poles instanceof Float64Array) {\n            for (let i = 0; i < 3 * numPoles; i++)\n                curve._bcurve.packedData[i] = poles[i];\n            for (let i = 0; i < 3 * degree; i++)\n                curve._bcurve.packedData[3 * numPoles + i] = poles[i];\n        }\n        else if (poles instanceof GrowableXYZArray) {\n            curve._bcurve.packedData = poles.float64Data().slice(0, 3 * numPoles);\n            for (let i = 0; i < 3 * degree; i++)\n                curve._bcurve.packedData[3 * numPoles + i] = poles.float64Data()[i];\n        }\n        else {\n            let i = 0;\n            for (let j = 0; j < numPoles; j++) {\n                curve._bcurve.packedData[i++] = poles[j].x;\n                curve._bcurve.packedData[i++] = poles[j].y;\n                curve._bcurve.packedData[i++] = poles[j].z;\n            }\n            for (let j = 0; j < degree; j++) {\n                curve._bcurve.packedData[i++] = poles[j].x;\n                curve._bcurve.packedData[i++] = poles[j].y;\n                curve._bcurve.packedData[i++] = poles[j].z;\n            }\n        }\n        return curve;\n    }\n    /**\n     * Create a C2 cubic B-spline curve that interpolates the given points and optional end tangents.\n     * @param options collection of points and end conditions.\n     */\n    static createFromInterpolationCurve3dOptions(options) {\n        return BSplineCurveOps.createThroughPointsC2Cubic(options);\n    }\n    /**\n     *\n     * @param options collection of points and end conditions.\n     */\n    static createFromAkimaCurve3dOptions(options) {\n        return BSplineCurveOps.createThroughPoints(options.fitPoints, 4); // temporary\n    }\n    /** Create a bspline with given knots.\n     * * Only two knot count conditions are recognized; all others return undefined:\n     *    * If poleArray.length + order === knotArray.length, the first and last are assumed to be the extraneous knots of classic clamping.\n     *    * If poleArray.length + order === knotArray.length + 2, the knots are in modern form.\n     */\n    static create(poleArray, knotArray, order) {\n        if (order < 2)\n            return undefined;\n        let numPoles = poleArray.length;\n        if (poleArray instanceof Float64Array) {\n            numPoles /= 3; // blocked as xyz\n        }\n        if (numPoles < order)\n            return undefined;\n        const numKnots = knotArray.length;\n        let skipFirstAndLast;\n        if (numPoles + order === numKnots)\n            skipFirstAndLast = true; // classic (first/last knots extraneous)\n        else if (numPoles + order === numKnots + 2)\n            skipFirstAndLast = false; // modern\n        else\n            return undefined;\n        const knots = KnotVector.create(knotArray, order - 1, skipFirstAndLast);\n        const curve = new BSplineCurve3d(numPoles, order, knots);\n        let i = 0;\n        if (poleArray instanceof Float64Array) {\n            for (const coordinate of poleArray)\n                curve._bcurve.packedData[i++] = coordinate;\n        }\n        else {\n            for (const p of poleArray) {\n                curve._bcurve.packedData[i++] = p.x;\n                curve._bcurve.packedData[i++] = p.y;\n                curve._bcurve.packedData[i++] = p.z;\n            }\n        }\n        return curve;\n    }\n    /** Return a deep clone */\n    clone() {\n        const knotVector1 = this._bcurve.knots.clone();\n        const curve1 = new BSplineCurve3d(this.numPoles, this.order, knotVector1);\n        curve1._bcurve.packedData = this._bcurve.packedData.slice();\n        return curve1;\n    }\n    /** Evaluate at a position given by fractional position within a span. */\n    evaluatePointInSpan(spanIndex, spanFraction) {\n        this._bcurve.evaluateBuffersInSpan(spanIndex, spanFraction);\n        return Point3d.createFrom(this._bcurve.poleBuffer);\n    }\n    /** Evaluate point and derivative vector at a position given by fractional position within a span.\n     * * The derivative is with respect to the span fraction (NOT scaled to either global fraction or knot)\n     */\n    evaluatePointAndDerivativeInSpan(spanIndex, spanFraction) {\n        this._bcurve.evaluateBuffersInSpan1(spanIndex, spanFraction);\n        return Ray3d.createCapture(Point3d.createFrom(this._bcurve.poleBuffer), Vector3d.createFrom(this._bcurve.poleBuffer1));\n    }\n    /** Evaluate at a position given by a knot value.  */\n    knotToPoint(u, result) {\n        this._bcurve.evaluateBuffersAtKnot(u);\n        return Point3d.createFrom(this._bcurve.poleBuffer, result);\n    }\n    /** Evaluate at a position given by a knot value.  */\n    knotToPointAndDerivative(u, result) {\n        this._bcurve.evaluateBuffersAtKnot(u, 1);\n        if (!result)\n            return Ray3d.createCapture(Point3d.createFrom(this._bcurve.poleBuffer), Vector3d.createFrom(this._bcurve.poleBuffer1));\n        result.origin.setFrom(this._bcurve.poleBuffer);\n        result.direction.setFrom(this._bcurve.poleBuffer1);\n        return result;\n    }\n    /** Evaluate at a position given by a knot value.  Return point with 2 derivatives. */\n    knotToPointAnd2Derivatives(u, result) {\n        this._bcurve.evaluateBuffersAtKnot(u, 2);\n        return Plane3dByOriginAndVectors.createOriginAndVectorsXYZ(this._bcurve.poleBuffer[0], this._bcurve.poleBuffer[1], this._bcurve.poleBuffer[2], this._bcurve.poleBuffer1[0], this._bcurve.poleBuffer1[1], this._bcurve.poleBuffer1[2], this._bcurve.poleBuffer2[0], this._bcurve.poleBuffer2[1], this._bcurve.poleBuffer2[2], result);\n    }\n    /** test if almost the same curve as `other` */\n    isAlmostEqual(other) {\n        if (other instanceof BSplineCurve3d) {\n            return this._bcurve.knots.isAlmostEqual(other._bcurve.knots)\n                && Point3dArray.isAlmostEqual(this._bcurve.packedData, other._bcurve.packedData);\n        }\n        return false;\n    }\n    /** test if this curve is entirely within plane. */\n    isInPlane(plane) {\n        return Point3dArray.isCloseToPlane(this._bcurve.packedData, plane);\n    }\n    /** Return the control polygon length as approximation (always overestimate) of the curve length. */\n    quickLength() { return Point3dArray.sumEdgeLengths(this._bcurve.packedData); }\n    /** Emit beziers or strokes (selected by the stroke options) to the handler. */\n    emitStrokableParts(handler, options) {\n        const needBeziers = handler.announceBezierCurve !== undefined;\n        const workBezier = this.initializeWorkBezier();\n        const numSpan = this.numSpan;\n        let numStrokes;\n        for (let spanIndex = 0; spanIndex < numSpan; spanIndex++) {\n            const bezier = this.getSaturatedBezierSpan3dOr3dH(spanIndex, false, workBezier);\n            if (bezier) {\n                numStrokes = bezier.computeStrokeCountForOptions(options);\n                if (needBeziers) {\n                    handler.announceBezierCurve(bezier, numStrokes, this, spanIndex, this._bcurve.knots.spanFractionToFraction(spanIndex, 0.0), this._bcurve.knots.spanFractionToFraction(spanIndex, 1.0));\n                }\n                else {\n                    handler.announceIntervalForUniformStepStrokes(this, numStrokes, this._bcurve.knots.spanFractionToFraction(spanIndex, 0.0), this._bcurve.knots.spanFractionToFraction(spanIndex, 1.0));\n                }\n            }\n        }\n    }\n    /**\n     * Assess length and turn to determine a stroke count.\n     * @param options stroke options structure.\n     */\n    computeStrokeCountForOptions(options) {\n        const workBezier = this.initializeWorkBezier();\n        const numSpan = this.numSpan;\n        let numStroke = 0;\n        for (let spanIndex = 0; spanIndex < numSpan; spanIndex++) {\n            const bezier = this.getSaturatedBezierSpan3d(spanIndex, workBezier);\n            if (bezier)\n                numStroke += bezier.computeStrokeCountForOptions(options);\n        }\n        return numStroke;\n    }\n    /**\n     * Compute individual segment stroke counts.  Attach in a StrokeCountMap.\n     * @param options StrokeOptions that determine count\n     * @param parentStrokeMap evolving parent map.\n     * @alpha\n     */\n    computeAndAttachRecursiveStrokeCounts(options, parentStrokeMap) {\n        const workBezier = this.initializeWorkBezier();\n        const numSpan = this.numSpan;\n        const myData = StrokeCountMap.createWithCurvePrimitiveAndOptionalParent(this, parentStrokeMap, []);\n        for (let spanIndex = 0; spanIndex < numSpan; spanIndex++) {\n            const bezier = this.getSaturatedBezierSpan3d(spanIndex, workBezier);\n            if (bezier) {\n                const segmentLength = workBezier.curveLength();\n                const numStrokeOnSegment = workBezier.computeStrokeCountForOptions(options);\n                myData.addToCountAndLength(numStrokeOnSegment, segmentLength);\n            }\n        }\n        CurvePrimitive.installStrokeCountMap(this, myData, parentStrokeMap);\n    }\n    /** Append strokes to a linestring. */\n    emitStrokes(dest, options) {\n        const workBezier = this.initializeWorkBezier();\n        const numSpan = this.numSpan;\n        for (let spanIndex = 0; spanIndex < numSpan; spanIndex++) {\n            const bezier = this.getSaturatedBezierSpan3d(spanIndex, workBezier);\n            if (bezier)\n                bezier.emitStrokes(dest, options);\n        }\n    }\n    /**\n     * Test knots, control points, and wrappable flag to see if all agree for a possible wrapping.\n     * @returns the manner of closing.   Se BSplineWrapMode for particulars of each mode.\n     *\n     */\n    get isClosable() {\n        const mode = this._bcurve.knots.wrappable;\n        if (mode === BSplineWrapMode.None)\n            return BSplineWrapMode.None;\n        if (!this._bcurve.knots.testClosable(mode))\n            return BSplineWrapMode.None;\n        if (!this._bcurve.testCloseablePolygon(mode))\n            return BSplineWrapMode.None;\n        return mode;\n    }\n    /**\n     * Return a BezierCurveBase for this curve.  The concrete return type may be BezierCurve3d or BezierCurve3dH according to this type.\n     * @param spanIndex\n     * @param result optional reusable curve.  This will only be reused if it is a BezierCurve3d with matching order.\n     */\n    getSaturatedBezierSpan3dOr3dH(spanIndex, prefer3dH, result) {\n        if (prefer3dH)\n            return this.getSaturatedBezierSpan3dH(spanIndex, result);\n        return this.getSaturatedBezierSpan3d(spanIndex, result);\n    }\n    /**\n     * Return a CurvePrimitive (which is a BezierCurve3d) for a specified span of this curve.\n     * @param spanIndex\n     * @param result optional reusable curve.  This will only be reused if it is a BezierCurve3d with matching order.\n     */\n    getSaturatedBezierSpan3d(spanIndex, result) {\n        if (spanIndex < 0 || spanIndex >= this.numSpan)\n            return undefined;\n        const order = this.order;\n        if (result === undefined || !(result instanceof BezierCurve3d) || result.order !== order)\n            result = BezierCurve3d.createOrder(order);\n        const bezier = result;\n        bezier.loadSpanPoles(this._bcurve.packedData, spanIndex);\n        if (bezier.saturateInPlace(this._bcurve.knots, spanIndex))\n            return result;\n        return undefined;\n    }\n    /**\n     * Return a CurvePrimitive (which is a BezierCurve3dH) for a specified span of this curve.\n     * @param spanIndex\n     * @param result optional reusable curve.  This will only be reused if it is a BezierCurve3d with matching order.\n     */\n    getSaturatedBezierSpan3dH(spanIndex, result) {\n        if (spanIndex < 0 || spanIndex >= this.numSpan)\n            return undefined;\n        const order = this.order;\n        if (result === undefined || !(result instanceof BezierCurve3dH) || result.order !== order)\n            result = BezierCurve3dH.createOrder(order);\n        const bezier = result;\n        bezier.loadSpan3dPolesWithWeight(this._bcurve.packedData, spanIndex, 1.0);\n        if (bezier.saturateInPlace(this._bcurve.knots, spanIndex))\n            return bezier;\n        return undefined;\n    }\n    /**\n     * Set the flag indicating the bspline might be suitable for having wrapped \"closed\" interpretation.\n     */\n    setWrappable(value) {\n        this._bcurve.knots.wrappable = value;\n    }\n    /** Second step of double dispatch:  call `handler.handleBSplineCurve3d(this)` */\n    dispatchToGeometryHandler(handler) {\n        return handler.handleBSplineCurve3d(this);\n    }\n    /**\n     * Extend a range so in includes the range of this curve\n     * * REMARK: this is based on the poles, not the exact curve.  This is generally larger than the true curve range.\n     * @param rangeToExtend\n     * @param transform transform to apply to points as they are entered into the range.\n     */\n    extendRange(rangeToExtend, transform) {\n        const buffer = this._bcurve.packedData;\n        const n = buffer.length - 2;\n        if (transform) {\n            for (let i0 = 0; i0 < n; i0 += 3)\n                rangeToExtend.extendTransformedXYZ(transform, buffer[i0], buffer[i0 + 1], buffer[i0 + 2]);\n        }\n        else {\n            for (let i0 = 0; i0 < n; i0 += 3)\n                rangeToExtend.extendXYZ(buffer[i0], buffer[i0 + 1], buffer[i0 + 2]);\n        }\n    }\n}\n//# sourceMappingURL=BSplineCurve.js.map",
      "start": 1693508122989,
      "end": 1693508123124,
      "sourcemaps": null
    }
  ]
}
