{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/common/lib/esm/rpc/core/RpcProtocol.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module RpcInterface\n */\nimport { BeEvent } from \"@itwin/core-bentley\";\nimport { RpcConfiguration } from \"./RpcConfiguration\";\nimport { RpcRequestStatus, RpcResponseCacheControl } from \"./RpcConstants\";\nimport { RpcInvocation } from \"./RpcInvocation\";\nimport { RpcMarshaling } from \"./RpcMarshaling\";\n/** @internal */\nexport var RpcRequestFulfillment;\n(function (RpcRequestFulfillment) {\n    async function forUnknownError(request, error) {\n        const result = await RpcMarshaling.serialize(undefined, error);\n        return {\n            interfaceName: request.operation.interfaceDefinition,\n            id: request.id,\n            result,\n            rawResult: error,\n            status: RpcRequestStatus.Rejected,\n        };\n    }\n    RpcRequestFulfillment.forUnknownError = forUnknownError;\n})(RpcRequestFulfillment || (RpcRequestFulfillment = {}));\n/** Documents changes to the RPC protocol version.\n * @internal\n */\nexport var RpcProtocolVersion;\n(function (RpcProtocolVersion) {\n    RpcProtocolVersion[RpcProtocolVersion[\"None\"] = 0] = \"None\";\n    RpcProtocolVersion[RpcProtocolVersion[\"IntroducedNoContent\"] = 1] = \"IntroducedNoContent\";\n    RpcProtocolVersion[RpcProtocolVersion[\"IntroducedStatusCategory\"] = 2] = \"IntroducedStatusCategory\";\n})(RpcProtocolVersion || (RpcProtocolVersion = {}));\n/** An application protocol for an RPC interface.\n * @internal\n */\nclass RpcProtocol {\n    /** If checkToken is true, will be called on the backend to inflate the IModelRpcProps for each request. */\n    inflateToken(tokenFromBody, _request) { return tokenFromBody; }\n    /** Override to supply the status corresponding to a protocol-specific code value. */\n    getStatus(code) {\n        return code;\n    }\n    /** Override to supply the protocol-specific code corresponding to a status value. */\n    getCode(status) {\n        return status;\n    }\n    /** Override to supply the protocol-specific path value for an RPC operation. */\n    supplyPathForOperation(operation, _request) {\n        return JSON.stringify(operation);\n    }\n    /** Override to supply the operation for a protocol-specific path value. */\n    getOperationFromPath(path) {\n        return JSON.parse(path);\n    }\n    /** Obtains the implementation result on the backend for an RPC operation request. */\n    async fulfill(request) {\n        return new (this.invocationType)(this, request).fulfillment;\n    }\n    /** Serializes a request. */\n    async serialize(request) {\n        const serializedContext = await RpcConfiguration.requestContext.serialize(request);\n        return {\n            ...serializedContext,\n            operation: {\n                interfaceDefinition: request.operation.interfaceDefinition.interfaceName,\n                operationName: request.operation.operationName,\n                interfaceVersion: request.operation.interfaceVersion,\n            },\n            method: request.method,\n            path: request.path,\n            parameters: await RpcMarshaling.serialize(request.protocol, request.parameters),\n            caching: RpcResponseCacheControl.None,\n            protocolVersion: RpcProtocol.protocolVersion,\n        };\n    }\n    /** Constructs a protocol. */\n    constructor(configuration) {\n        /** The name of the RPC protocol version header. */\n        this.protocolVersionHeaderName = \"\";\n        /** Events raised by the protocol. See [[RpcProtocolEvent]] */\n        this.events = new BeEvent();\n        /** The RPC invocation class for this protocol. */\n        this.invocationType = RpcInvocation;\n        this.serializedClientRequestContextHeaderNames = {\n            /** The name of the request id header. */\n            id: \"\",\n            /** The name of the application id header  */\n            applicationId: \"\",\n            /** The name of the version header. */\n            applicationVersion: \"\",\n            /** The name of the session id header  */\n            sessionId: \"\",\n            /** The name of the authorization header. */\n            authorization: \"\",\n        };\n        /** If greater than zero, specifies where to break large binary request payloads. */\n        this.transferChunkThreshold = 0;\n        /** Used by protocols that can transmit stream values natively. */\n        this.preserveStreams = false;\n        /** Used by protocols that can transmit IModelRpcProps values natively. */\n        this.checkToken = false;\n        /** Used by protocols that support user-defined status codes. */\n        this.supportsStatusCategory = false;\n        this.configuration = configuration;\n        this.events.addListener((type, object) => RpcProtocol.events.raiseEvent(type, object));\n    }\n    /** @internal */\n    onRpcClientInitialized(_definition, _client) { }\n    /** @internal */\n    onRpcImplInitialized(_definition, _impl) { }\n    /** @internal */\n    onRpcClientTerminated(_definition, _client) { }\n    /** @internal */\n    onRpcImplTerminated(_definition, _impl) { }\n}\n/** Events raised by all protocols. See [[RpcProtocolEvent]] */\nRpcProtocol.events = new BeEvent();\n/** A version code that identifies the RPC protocol capabilties of this endpoint. */\nRpcProtocol.protocolVersion = RpcProtocolVersion.IntroducedStatusCategory;\nexport { RpcProtocol };\n//# sourceMappingURL=RpcProtocol.js.map",
      "start": 1693508120821,
      "end": 1693508120876,
      "sourcemaps": null
    }
  ]
}
