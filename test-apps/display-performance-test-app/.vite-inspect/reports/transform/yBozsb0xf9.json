{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/geometry4d/Point4d.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Numerics\n */\nimport { Geometry } from \"../Geometry\";\nimport { Plane3d } from \"../geometry3d/Plane3d\";\nimport { Plane3dByOriginAndUnitNormal } from \"../geometry3d/Plane3dByOriginAndUnitNormal\";\nimport { Plane3dByOriginAndVectors } from \"../geometry3d/Plane3dByOriginAndVectors\";\nimport { Point2d } from \"../geometry3d/Point2dVector2d\";\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\nimport { Ray3d } from \"../geometry3d/Ray3d\";\n/**\n *\n * @param ddg numerator second derivative\n * @param dh denominator derivative\n * @param ddh denominator second derivative\n * @param f primary function (g/h)\n * @param df derivative of (g/h)\n * @param divH = (1/h)\n * @internal\n */\nfunction quotientDerivative2(ddg, dh, ddh, f, df, divH) {\n    return divH * (ddg - 2.0 * df * dh - f * ddh);\n}\n/** 4 Dimensional point (x,y,z,w) used in perspective calculations.\n * * the coordinates are stored in a Float64Array of length 4.\n * * properties `x`, `y`, `z`, `w` access array members.\n * *\n * * The coordinates are physically stored as a single Float64Array with 4 entries. (w last)\n * *\n * @public\n */\nexport class Point4d extends Plane3d {\n    /** Set x,y,z,w of this point.  */\n    set(x = 0, y = 0, z = 0, w = 0) {\n        this.xyzw[0] = x;\n        this.xyzw[1] = y;\n        this.xyzw[2] = z;\n        this.xyzw[3] = w;\n        return this;\n    }\n    /** Set a component by index.\n     * * No change if index is out of range.\n     */\n    setComponent(index, value) {\n        if (index >= 0 && index < 4) {\n            this.xyzw[index] = value;\n        }\n    }\n    /** The x component. */\n    get x() { return this.xyzw[0]; }\n    set x(val) { this.xyzw[0] = val; }\n    /** The y component. */\n    get y() { return this.xyzw[1]; }\n    set y(val) { this.xyzw[1] = val; }\n    /** The z component. */\n    get z() { return this.xyzw[2]; }\n    set z(val) { this.xyzw[2] = val; }\n    /** The w component of this point. */\n    get w() { return this.xyzw[3]; }\n    set w(val) { this.xyzw[3] = val; }\n    /** Construct from coordinates. */\n    constructor(x = 0, y = 0, z = 0, w = 0) {\n        super();\n        this.xyzw = new Float64Array(4);\n        this.xyzw[0] = x;\n        this.xyzw[1] = y;\n        this.xyzw[2] = z;\n        this.xyzw[3] = w;\n    }\n    /** Return a Point4d with specified x,y,z,w */\n    static create(x = 0, y = 0, z = 0, w = 0, result) {\n        return result ? result.set(x, y, z, w) : new Point4d(x, y, z, w);\n    }\n    /**\n     * Create a \"Point4d as a plane\" from \"any\" other [[PlaneAltitudeEvaluator]] type.\n     * @param source\n     * @returns\n     */\n    static createPlaneFrom(source) {\n        return new Point4d(source.normalX(), source.normalY(), source.normalZ(), source.altitudeXYZ(0, 0, 0));\n    }\n    /** Copy coordinates from `other`. */\n    setFrom(other) {\n        this.xyzw[0] = other.xyzw[0];\n        this.xyzw[1] = other.xyzw[1];\n        this.xyzw[2] = other.xyzw[2];\n        this.xyzw[3] = other.xyzw[3];\n        return this;\n    }\n    /** Clone this point */\n    clone(result) {\n        return result ? result.setFrom(this) : new Point4d(this.xyzw[0], this.xyzw[1], this.xyzw[2], this.xyzw[3]);\n    }\n    /** Set this point's xyzw from a json array `[x,y,z,w]` */\n    setFromJSON(json) {\n        if (Geometry.isNumberArray(json, 4))\n            this.set(json[0], json[1], json[2], json[3]);\n        else\n            this.set(0, 0, 0, 0);\n    }\n    /** Create a new point with coordinates from a json array `[x,y,z,w]` */\n    static fromJSON(json) {\n        const result = new Point4d();\n        result.setFromJSON(json);\n        return result;\n    }\n    /** Near-equality test, using `Geometry.isSameCoordinate` on all 4 x,y,z,w */\n    isAlmostEqual(other) {\n        return Geometry.isSameCoordinate(this.x, other.x)\n            && Geometry.isSameCoordinate(this.y, other.y)\n            && Geometry.isSameCoordinate(this.z, other.z)\n            && Geometry.isSameCoordinate(this.w, other.w);\n    }\n    /**\n     * Test for same coordinate by direct x,y,z,w args\n     * @param x x to test\n     * @param y y to test\n     * @param z z to test\n     * @param w w to test\n     */\n    isAlmostEqualXYZW(x, y, z, w) {\n        return Geometry.isSameCoordinate(this.x, x)\n            && Geometry.isSameCoordinate(this.y, y)\n            && Geometry.isSameCoordinate(this.z, z)\n            && Geometry.isSameCoordinate(this.w, w);\n    }\n    /**\n     * Convert an Angle to a JSON object.\n     * @return {*} [x,y,z,w]\n     */\n    toJSON() {\n        return [this.xyzw[0], this.xyzw[1], this.xyzw[2], this.xyzw[3]];\n    }\n    /** Return the 4d distance from this point to other, with all 4 components squared into the hypotenuse.\n     * * x,y,z,w all participate without normalization.\n     */\n    distanceXYZW(other) {\n        return Geometry.hypotenuseXYZW(other.xyzw[0] - this.xyzw[0], other.xyzw[1] - this.xyzw[1], other.xyzw[2] - this.xyzw[2], other.xyzw[3] - this.xyzw[3]);\n    }\n    /** Return the squared 4d distance from this point to other, with all 4 components squared into the hypotenuse.\n     * * x,y,z,w all participate without normalization.\n     */\n    distanceSquaredXYZW(other) {\n        return Geometry.hypotenuseSquaredXYZW(other.xyzw[0] - this.xyzw[0], other.xyzw[1] - this.xyzw[1], other.xyzw[2] - this.xyzw[2], other.xyzw[3] - this.xyzw[3]);\n    }\n    /** Return the distance between the instance and other after normalizing by weights\n     */\n    realDistanceXY(other) {\n        const wA = this.w;\n        const wB = other.w;\n        if (Geometry.isSmallMetricDistance(wA) || Geometry.isSmallMetricDistance(wB))\n            return undefined;\n        return Geometry.hypotenuseXY(other.xyzw[0] / wB - this.xyzw[0] / wA, other.xyzw[1] / wB - this.xyzw[1] / wA);\n    }\n    /** Return the largest absolute distance between corresponding components\n     * * x,y,z,w all participate without normalization.\n     */\n    maxDiff(other) {\n        return Math.max(Math.abs(other.xyzw[0] - this.xyzw[0]), Math.abs(other.xyzw[1] - this.xyzw[1]), Math.abs(other.xyzw[2] - this.xyzw[2]), Math.abs(other.xyzw[3] - this.xyzw[3]));\n    }\n    /** Return the largest absolute entry of all 4 components x,y,z,w */\n    maxAbs() {\n        return Math.max(Math.abs(this.xyzw[0]), Math.abs(this.xyzw[1]), Math.abs(this.xyzw[2]), Math.abs(this.xyzw[3]));\n    }\n    /** Returns the magnitude including all 4 components x,y,z,w */\n    magnitudeXYZW() {\n        return Geometry.hypotenuseXYZW(this.xyzw[0], this.xyzw[1], this.xyzw[2], this.xyzw[3]);\n    }\n    /** Returns the magnitude of the leading xyz components.  w is ignored.  (i.e. the leading xyz are NOT divided by w.) */\n    magnitudeSquaredXYZ() {\n        return Geometry.hypotenuseSquaredXYZ(this.xyzw[0], this.xyzw[1], this.xyzw[2]);\n    }\n    /** Return the difference (this-other) using all 4 components x,y,z,w */\n    minus(other, result) {\n        return Point4d.create(this.xyzw[0] - other.xyzw[0], this.xyzw[1] - other.xyzw[1], this.xyzw[2] - other.xyzw[2], this.xyzw[3] - other.xyzw[3], result);\n    }\n    /** Return `((other.w * this) -  (this.w * other))` */\n    crossWeightedMinus(other, result) {\n        const wa = this.xyzw[3];\n        const wb = other.xyzw[3];\n        return Vector3d.create(wb * this.xyzw[0] - wa * other.xyzw[0], wb * this.xyzw[1] - wa * other.xyzw[1], wb * this.xyzw[2] - wa * other.xyzw[2], result);\n    }\n    /** Return `((other.w * this) -  (this.w * other))`, with other.w known to be 1 */\n    crossWeightedMinusPoint3d(other, result) {\n        const wa = this.xyzw[3];\n        return Vector3d.create(this.xyzw[0] - wa * other.x, this.xyzw[1] - wa * other.y, this.xyzw[2] - wa * other.z, result);\n    }\n    /** Return the sum of this and other, using all 4 components x,y,z,w */\n    plus(other, result) {\n        return Point4d.create(this.xyzw[0] + other.xyzw[0], this.xyzw[1] + other.xyzw[1], this.xyzw[2] + other.xyzw[2], this.xyzw[3] + other.xyzw[3], result);\n    }\n    /** Test if all components are nearly zero. */\n    get isAlmostZero() {\n        return Geometry.isSmallMetricDistance(this.maxAbs());\n    }\n    /** Create a point with zero in all coordinates. */\n    static createZero() { return new Point4d(0, 0, 0, 0); }\n    /**\n     * Create plane coefficients for the plane containing pointA, pointB, and 0010.\n     * @param pointA first point\n     * @param pointB second point\n     */\n    static createPlanePointPointZ(pointA, pointB, result) {\n        return Point4d.create(pointA.y * pointB.w - pointA.w * pointB.y, pointA.w * pointB.x - pointA.x * pointB.w, 0.0, pointA.x * pointB.y - pointA.y * pointB.x, result);\n    }\n    /**\n     * extract 4 consecutive numbers from a Float64Array into a Point4d.\n     * @param data buffer of numbers\n     * @param xIndex first index for x,y,z,w sequence\n     */\n    static createFromPackedXYZW(data, xIndex = 0, result) {\n        return Point4d.create(data[xIndex], data[xIndex + 1], data[xIndex + 2], data[xIndex + 3], result);\n    }\n    /** Create a `Point4d` with x,y,z from an `XYAndZ` input, and w from a separate number. */\n    static createFromPointAndWeight(xyz, w) {\n        return new Point4d(xyz.x, xyz.y, xyz.z, w);\n    }\n    /** Create a `Point4d` from\n     * * Point2d, Point3d, or Point4d\n     * * other structure with members x,y and optional z,w\n     * * array of numbers\n     * * default z is 0.0\n     * * default w is 1.0  (array[3] can replace)\n     */\n    static createFromPoint(point) {\n        if (point instanceof Point2d)\n            return new Point4d(point.x, point.y, 0, 1);\n        if (point instanceof Point3d)\n            return new Point4d(point.x, point.y, point.z, 1);\n        if (point instanceof Point4d)\n            return point.clone();\n        // hm ... some flavor of x,y,z subset ...\n        if (Array.isArray(point)) {\n            const x1 = point.length > 0 ? point[0] : 0.0;\n            const y1 = point.length > 1 ? point[1] : 0.0;\n            const z1 = point.length > 2 ? point[2] : 0.0;\n            const w1 = point.length > 3 ? point[3] : 1.0;\n            return new Point4d(x1, y1, z1, w1);\n        }\n        const x = point.x;\n        const y = point.y;\n        const z = point.hasOwnProperty(\"z\") ? point.z : 0.0;\n        const w = point.hasOwnProperty(\"w\") ? point.w : 1.0;\n        return new Point4d(x, y, z, w);\n    }\n    /** Return `point + vector * scalar` */\n    plusScaled(vector, scaleFactor, result) {\n        return Point4d.create(this.xyzw[0] + vector.xyzw[0] * scaleFactor, this.xyzw[1] + vector.xyzw[1] * scaleFactor, this.xyzw[2] + vector.xyzw[2] * scaleFactor, this.xyzw[3] + vector.xyzw[3] * scaleFactor, result);\n    }\n    /** Return interpolation between instance and pointB at fraction\n     */\n    interpolate(fraction, pointB, result) {\n        const v = 1.0 - fraction;\n        return Point4d.create(this.xyzw[0] * v + pointB.xyzw[0] * fraction, this.xyzw[1] * v + pointB.xyzw[1] * fraction, this.xyzw[2] * v + pointB.xyzw[2] * fraction, this.xyzw[3] * v + pointB.xyzw[3] * fraction, result);\n    }\n    /** Return `point + vectorA * scalarA + vectorB * scalarB` */\n    plus2Scaled(vectorA, scalarA, vectorB, scalarB, result) {\n        return Point4d.create(this.xyzw[0] + vectorA.xyzw[0] * scalarA + vectorB.xyzw[0] * scalarB, this.xyzw[1] + vectorA.xyzw[1] * scalarA + vectorB.xyzw[1] * scalarB, this.xyzw[2] + vectorA.xyzw[2] * scalarA + vectorB.xyzw[2] * scalarB, this.xyzw[3] + vectorA.xyzw[3] * scalarA + vectorB.xyzw[3] * scalarB, result);\n    }\n    /** Return `point + vectorA * scalarA + vectorB * scalarB + vectorC * scalarC` */\n    plus3Scaled(vectorA, scalarA, vectorB, scalarB, vectorC, scalarC, result) {\n        return Point4d.create(this.xyzw[0] + vectorA.xyzw[0] * scalarA + vectorB.xyzw[0] * scalarB + vectorC.xyzw[0] * scalarC, this.xyzw[1] + vectorA.xyzw[1] * scalarA + vectorB.xyzw[1] * scalarB + vectorC.xyzw[1] * scalarC, this.xyzw[2] + vectorA.xyzw[2] * scalarA + vectorB.xyzw[2] * scalarB + vectorC.xyzw[2] * scalarC, this.xyzw[3] + vectorA.xyzw[3] * scalarA + vectorB.xyzw[3] * scalarB + vectorC.xyzw[3] * scalarC, result);\n    }\n    /** Return `point + vectorA * scalarA + vectorB * scalarB` */\n    static createAdd2Scaled(vectorA, scalarA, vectorB, scalarB, result) {\n        return Point4d.create(vectorA.xyzw[0] * scalarA + vectorB.xyzw[0] * scalarB, vectorA.xyzw[1] * scalarA + vectorB.xyzw[1] * scalarB, vectorA.xyzw[2] * scalarA + vectorB.xyzw[2] * scalarB, vectorA.xyzw[3] * scalarA + vectorB.xyzw[3] * scalarB, result);\n    }\n    /** Return `point + vectorA \\ scalarA + vectorB * scalarB + vectorC * scalarC` */\n    static createAdd3Scaled(vectorA, scalarA, vectorB, scalarB, vectorC, scalarC, result) {\n        return Point4d.create(vectorA.xyzw[0] * scalarA + vectorB.xyzw[0] * scalarB + vectorC.xyzw[0] * scalarC, vectorA.xyzw[1] * scalarA + vectorB.xyzw[1] * scalarB + vectorC.xyzw[1] * scalarC, vectorA.xyzw[2] * scalarA + vectorB.xyzw[2] * scalarB + vectorC.xyzw[2] * scalarC, vectorA.xyzw[3] * scalarA + vectorB.xyzw[3] * scalarB + vectorC.xyzw[3] * scalarC, result);\n    }\n    /** Return dot product of (4d) vectors from the instance to targetA and targetB */\n    dotVectorsToTargets(targetA, targetB) {\n        return (targetA.xyzw[0] - this.xyzw[0]) * (targetB.xyzw[0] - this.xyzw[0]) +\n            (targetA.xyzw[1] - this.xyzw[1]) * (targetB.xyzw[1] - this.xyzw[1]) +\n            (targetA.xyzw[2] - this.xyzw[2]) * (targetB.xyzw[2] - this.xyzw[2]) +\n            (targetA.xyzw[3] - this.xyzw[3]) * (targetB.xyzw[3] - this.xyzw[3]);\n    }\n    /** return (4d) dot product of the instance and other point. */\n    dotProduct(other) {\n        return this.xyzw[0] * other.xyzw[0] + this.xyzw[1] * other.xyzw[1] + this.xyzw[2] * other.xyzw[2] + this.xyzw[3] * other.xyzw[3];\n    }\n    /** return (4d) dot product of the instance with xyzw */\n    dotProductXYZW(x, y, z, w) {\n        return this.xyzw[0] * x + this.xyzw[1] * y + this.xyzw[2] * z + this.xyzw[3] * w;\n    }\n    /** dotProduct with (point.x, point.y, point.z, 1) Used in PlaneAltitudeEvaluator interface */\n    altitude(point) {\n        return this.xyzw[0] * point.x + this.xyzw[1] * point.y + this.xyzw[2] * point.z + this.xyzw[3];\n    }\n    /** dotProduct with (x, y, z, 1) Used in PlaneAltitudeEvaluator interface */\n    altitudeXYZ(x, y, z) {\n        return this.xyzw[0] * x + this.xyzw[1] * y + this.xyzw[2] * z + this.xyzw[3];\n    }\n    /** dotProduct with (point.x, point.y, point.z, point.w) Used in PlaneAltitudeEvaluator interface */\n    weightedAltitude(point) {\n        return this.xyzw[0] * point.x + this.xyzw[1] * point.y + this.xyzw[2] * point.z + this.xyzw[3] * point.w;\n    }\n    /** dotProduct with (vector.x, vector.y, vector.z, 0).  Used in PlaneAltitudeEvaluator interface */\n    velocity(vector) {\n        return this.xyzw[0] * vector.x + this.xyzw[1] * vector.y + this.xyzw[2] * vector.z;\n    }\n    /** dotProduct with (x,y,z, 0).  Used in PlaneAltitudeEvaluator interface */\n    velocityXYZ(x, y, z) {\n        return this.xyzw[0] * x + this.xyzw[1] * y + this.xyzw[2] * z;\n    }\n    /**\n     * Return the x component of the normal used to evaluate altitude.\n     */\n    normalX() { return this.x; }\n    /**\n    * Return the x component of the normal used to evaluate altitude.\n    */\n    normalY() { return this.y; }\n    /**\n    * Return the z component of the normal used to evaluate altitude.\n    */\n    normalZ() { return this.z; }\n    /** unit X vector */\n    static unitX() { return new Point4d(1, 0, 0, 0); }\n    /** unit Y vector */\n    static unitY() { return new Point4d(0, 1, 0, 0); }\n    /** unit Z vector */\n    static unitZ() { return new Point4d(0, 0, 1, 0); }\n    /** unit W vector */\n    static unitW() { return new Point4d(0, 0, 0, 1); }\n    /** Divide by denominator, but return undefined if denominator is zero. */\n    safeDivideOrNull(denominator, result) {\n        if (denominator !== 0.0) {\n            return this.scale(1.0 / denominator, result);\n        }\n        return undefined;\n    }\n    /**\n     * * Return xyz projection of spacePoint to the plane of the DPoint4d (understood as coefficients, not point coordinates)\n     * * If the xyz part of `this` are all zero, (a clone of) `spacePoint` is returned.\n     */\n    projectPointToPlane(spacePoint, result) {\n        const h = this.altitude(spacePoint);\n        const nn = this.magnitudeSquaredXYZ();\n        const alpha = Geometry.conditionalDivideCoordinate(-h, nn);\n        if (alpha === undefined)\n            return spacePoint.clone(result);\n        return spacePoint.plusXYZ(alpha * this.x, alpha * this.y, alpha * this.z, result);\n    }\n    /** scale all components (including w!!) */\n    scale(scale, result) {\n        result = result ? result : new Point4d();\n        result.xyzw[0] = this.xyzw[0] * scale;\n        result.xyzw[1] = this.xyzw[1] * scale;\n        result.xyzw[2] = this.xyzw[2] * scale;\n        result.xyzw[3] = this.xyzw[3] * scale;\n        return result;\n    }\n    /** Negate components (including w!!) */\n    negate(result) {\n        result = result ? result : new Point4d();\n        result.xyzw[0] = -this.xyzw[0];\n        result.xyzw[1] = -this.xyzw[1];\n        result.xyzw[2] = -this.xyzw[2];\n        result.xyzw[3] = -this.xyzw[3];\n        return result;\n    }\n    /**\n     * If `this.w` is nonzero, return a 4d point `(x/w,y/w,z/w, 1)`\n     * If `this.w` is zero, return undefined.\n     * @param result optional result\n     */\n    normalizeWeight(result) {\n        const mag = Geometry.correctSmallFraction(this.xyzw[3]);\n        result = result ? result : new Point4d();\n        return this.safeDivideOrNull(mag, result);\n    }\n    /**\n     * If `this.w` is nonzero, return a 3d point `(x/w,y/w,z/w)`\n     * If `this.w` is zero, return undefined.\n     * @param result optional result\n     */\n    realPoint(result) {\n        const mag = Geometry.correctSmallFraction(this.xyzw[3]);\n        if (mag === 0.0)\n            return undefined;\n        const a = 1.0 / mag; // in zero case everything multiplies right back to true zero.\n        return Point3d.create(this.xyzw[0] * a, this.xyzw[1] * a, this.xyzw[2] * a, result);\n    }\n    /** Convert the homogeneous point to a (strongly typed) point or vector.\n     * * If `this.w` is nonzero, return a Point3d `(x/w,y/w,z/w)`\n     * * If `this.w` is zero, return a Vector3d `(x,y,z)`\n     */\n    realPointOrVector() {\n        const mag = Geometry.correctSmallFraction(this.xyzw[3]);\n        if (mag === 0.0)\n            return Vector3d.create(this.x, this.y, this.z);\n        const a = 1.0 / mag; // in zero case everything multiplies right back to true zero.\n        return Point3d.create(this.x * a, this.y * a, this.z * a);\n    }\n    /**\n     * * If w is nonzero, return Point3d with x/w,y/w,z/w.\n     * * If w is zero, return 000\n     * @param x x coordinate\n     * @param y y coordinate\n     * @param z z coordinate\n     * @param w w coordinate\n     * @param result optional result\n     */\n    static createRealPoint3dDefault000(x, y, z, w, result) {\n        const mag = Geometry.correctSmallFraction(w);\n        const a = mag === 0 ? 0.0 : (1.0 / mag); // in zero case everything multiplies right back to true zero.\n        return Point3d.create(x * a, y * a, z * a, result);\n    }\n    /**\n     * * If w is nonzero, return Vector3d which is the derivative of the projected xyz with given w and 4d derivatives.\n     * * If w is zero, return 000\n     * @param x x coordinate\n     * @param y y coordinate\n     * @param z z coordinate\n     * @param w w coordinate\n     * @param dx x coordinate of derivative\n     * @param dy y coordinate of derivative\n     * @param dz z coordinate of derivative\n     * @param dw w coordinate of derivative\n     * @param result optional result\n     */\n    static createRealDerivativeRay3dDefault000(x, y, z, w, dx, dy, dz, dw, result) {\n        const mag = Geometry.correctSmallFraction(w);\n        // real point is X/w.\n        // real derivative is (X' * w - X *w) / ww, and weight is always 0 by cross products.\n        const a = mag === 0 ? 0.0 : (1.0 / mag); // in zero case everything multiplies right back to true zero.\n        const aa = a * a;\n        return Ray3d.createXYZUVW(x * a, y * a, z * a, (dx * w - dw * x) * aa, (dy * w - dw * y) * aa, (dz * w - dw * z) * aa, result);\n    }\n    /**\n     * * If w is nonzero, return Vector3d which is the derivative of the projected xyz with given w and 4d derivatives.\n     * * If w is zero, return 000\n     * @param x x coordinate\n     * @param y y coordinate\n     * @param z z coordinate\n     * @param w w coordinate\n     * @param dx x coordinate of derivative\n     * @param dy y coordinate of derivative\n     * @param dz z coordinate of derivative\n     * @param dw w coordinate of derivative\n     * @param result optional result\n     */\n    static createRealDerivativePlane3dByOriginAndVectorsDefault000(x, y, z, w, dx, dy, dz, dw, ddx, ddy, ddz, ddw, result) {\n        const mag = Geometry.correctSmallFraction(w);\n        // real point is X/w.\n        // real derivative is (X' * w - X *w) / ww, and weight is always 0 by cross products.\n        const a = mag === 0 ? 0.0 : (1.0 / mag); // in zero case everything multiplies right back to true zero.\n        const aa = a * a;\n        const fx = x * a;\n        const fy = y * a;\n        const fz = z * a;\n        const dfx = (dx * w - dw * x) * aa;\n        const dfy = (dy * w - dw * y) * aa;\n        const dfz = (dz * w - dw * z) * aa;\n        return Plane3dByOriginAndVectors.createOriginAndVectorsXYZ(fx, fy, fz, dfx, dfy, dfz, quotientDerivative2(ddx, dw, ddw, fx, dfx, a), quotientDerivative2(ddy, dw, ddw, fy, dfy, a), quotientDerivative2(ddz, dw, ddw, fz, dfz, a), result);\n    }\n    /**\n     * * If this.w is nonzero, return Point3d with x/w,y/w,z/w.\n     * * If this.w is zero, return 000\n     */\n    realPointDefault000(result) {\n        const mag = Geometry.correctSmallFraction(this.xyzw[3]);\n        if (mag === 0.0)\n            return Point3d.create(0, 0, 0, result);\n        result = result ? result : new Point3d();\n        const a = 1.0 / mag;\n        return Point3d.create(this.xyzw[0] * a, this.xyzw[1] * a, this.xyzw[2] * a, result);\n    }\n    /** divide all components (x,y,z,w) by the 4d magnitude.\n     *\n     * * This is appropriate for normalizing a quaternion\n     * * Use normalizeWeight to divide by the w component.\n     */\n    normalizeXYZW(result) {\n        const mag = Geometry.correctSmallFraction(this.magnitudeXYZW());\n        result = result ? result : new Point4d();\n        return this.safeDivideOrNull(mag, result);\n    }\n    /**\n     * Return the determinant of the 3x3 matrix using components i,j,k of the 3 inputs.\n     */\n    static determinantIndexed3X3(pointA, pointB, pointC, i, j, k) {\n        return Geometry.tripleProduct(pointA.xyzw[i], pointA.xyzw[j], pointA.xyzw[k], pointB.xyzw[i], pointB.xyzw[j], pointB.xyzw[k], pointC.xyzw[i], pointC.xyzw[j], pointC.xyzw[k]);\n    }\n    /**\n     * Return a Point4d perpendicular to all 3 inputs. (A higher level cross product concept)\n     * @param pointA first point\n     * @param pointB second point\n     * @param pointC third point\n     */\n    static perpendicularPoint4dPlane(pointA, pointB, pointC) {\n        return Point4d.create(Point4d.determinantIndexed3X3(pointA, pointB, pointC, 1, 2, 3), -Point4d.determinantIndexed3X3(pointA, pointB, pointC, 2, 3, 0), Point4d.determinantIndexed3X3(pointA, pointB, pointC, 3, 0, 1), -Point4d.determinantIndexed3X3(pointA, pointB, pointC, 0, 1, 2));\n    }\n    /** Treating this Point4d as plane coefficients, convert to origin and normal form. */\n    toPlane3dByOriginAndUnitNormal(result) {\n        return Plane3dByOriginAndUnitNormal.createFrom(this, result);\n    }\n    /** Normalize so sum of squares of all 4 coordinates is 1. */\n    normalizeQuaternion() {\n        const magnitude = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\n        if (magnitude > 0.0) {\n            const f = 1.0 / magnitude;\n            this.x *= f;\n            this.y *= f;\n            this.z *= f;\n            this.w *= f;\n        }\n        return magnitude;\n    }\n    /** Return a (normalized) quaternion interpolated between two quaternions. */\n    static interpolateQuaternions(quaternion0, fractionParameter, quaternion1, result) {\n        if (!result)\n            result = new Point4d();\n        const maxSafeCosine = 0.9995;\n        // return exact quaternions for special values\n        if (0.0 === fractionParameter) {\n            result = quaternion0;\n            return result;\n        }\n        if (1.0 === fractionParameter) {\n            result = quaternion1;\n            return result;\n        }\n        if (0.5 === fractionParameter) {\n            quaternion0.plus(quaternion1, result);\n            result.normalizeQuaternion();\n            return result;\n        }\n        const q0 = quaternion0.clone();\n        const q1 = quaternion1.clone();\n        let dot = quaternion0.dotProduct(quaternion1);\n        // prevent interpolation through the longer great arc\n        if (dot < 0.0) {\n            q1.negate(q1);\n            dot = -dot;\n        }\n        // if nearly parallel, use interpolate and renormalize .\n        if (dot > maxSafeCosine) {\n            q0.interpolate(fractionParameter, q1, result);\n            result.normalizeQuaternion();\n            return result;\n        }\n        // safety check\n        if (dot < -1.0)\n            dot = -1.0;\n        else if (dot > 1.0)\n            dot = 1.0;\n        // create orthonormal basis {q0, q2}\n        const q2 = new Point4d();\n        q1.plusScaled(q0, -dot, q2); //  bsiDPoint4d_addScaledDPoint4d(& q2, & q1, & q0, -dot);\n        q2.normalizeQuaternion();\n        const angle = Math.acos(dot);\n        const angleOfInterpolation = angle * fractionParameter;\n        result = Point4d.createAdd2Scaled(q0, Math.cos(angleOfInterpolation), q2, Math.sin(angleOfInterpolation));\n        return result;\n    }\n    /** Measure the \"angle\" between two points, using all 4 components in the dot product that\n     * gives the cosine of the angle.\n     */\n    radiansToPoint4dXYZW(other) {\n        const magA = this.magnitudeXYZW();\n        const magB = other.magnitudeXYZW();\n        const dot = this.dotProduct(other); // == cos (theta) * magA * magB\n        const cos = Geometry.conditionalDivideFraction(dot, magA * magB);\n        if (cos === undefined)\n            return undefined;\n        return Math.acos(cos);\n    }\n}\n//# sourceMappingURL=Point4d.js.map",
      "start": 1693508122546,
      "end": 1693508122704,
      "sourcemaps": null
    }
  ]
}
