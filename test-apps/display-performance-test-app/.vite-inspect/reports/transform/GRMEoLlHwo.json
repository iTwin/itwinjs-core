{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/glsl/Color.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Rendering\n */\nimport { addInstanceColor } from \"./Instancing\";\n// Vertex\n// Color table is appended to vertex data. Compute the index of the vertex one-past-the-end of the vertex data\n// NB: Color in color table has pre-multiplied alpha - revert it.\nfunction getComputeElementColor(quantized) {\n    const vertData = quantized ? \"g_vertLutData1.zw\" : \"g_vertLutData4.xy\";\n    return `\r\n  float colorTableStart = u_vertParams.z * u_vertParams.w; // num rgba per-vertex times num vertices\r\n  float colorIndex = decodeUInt16(${vertData});\r\n  vec2 tc = computeLUTCoords(colorTableStart+colorIndex, u_vertParams.xy, g_vert_center, 1.0);\r\n  vec4 lutColor = TEXTURE(u_vertLUT, tc);\r\n  lutColor.rgb /= max(0.0001, lutColor.a);\r\n  vec4 color = (u_shaderFlags[kShaderBit_NonUniformColor] ? lutColor : u_color);\r\n`;\n}\nconst returnColor = `\r\n  return color;\r\n`;\nconst applyInstanceColor = `\r\n  color.rgb = mix(color.rgb, a_instanceRgba.rgb / 255.0, u_applyInstanceColor * extractInstanceBit(kOvrBit_Rgb));\r\n  color.a = mix(color.a, a_instanceRgba.a / 255.0, u_applyInstanceColor * extractInstanceBit(kOvrBit_Alpha));\r\n`;\nfunction getComputeColor(vert) {\n    const quantized = \"quantized\" === vert.positionType;\n    if (vert.usesInstancedGeometry) {\n        addInstanceColor(vert);\n        return `${getComputeElementColor(quantized)}${applyInstanceColor}${returnColor}`;\n    }\n    else {\n        return `${getComputeElementColor(quantized)}${returnColor}`;\n    }\n}\n// Fragment\nconst computeBaseColor = \"return v_color;\";\n/** @internal */\nexport function addColor(builder) {\n    builder.vert.addUniform(\"u_color\", 5 /* VariableType.Vec4 */, (prog) => {\n        prog.addGraphicUniform(\"u_color\", (uniform, params) => {\n            const lutGeom = params.geometry.asLUT;\n            const color = lutGeom.getColor(params.target);\n            if (color.isUniform) {\n                color.uniform.bind(uniform);\n            }\n        });\n    });\n    addVaryingColor(builder, getComputeColor(builder.vert));\n}\n/** @internal */\nexport function addVaryingColor(builder, computeVertexBase) {\n    builder.addVarying(\"v_color\", 5 /* VariableType.Vec4 */);\n    builder.vert.set(5 /* VertexShaderComponent.ComputeBaseColor */, computeVertexBase);\n    builder.frag.set(1 /* FragmentShaderComponent.ComputeBaseColor */, computeBaseColor);\n}\n//# sourceMappingURL=Color.js.map",
      "start": 1693508125152,
      "end": 1693508125333,
      "sourcemaps": null
    }
  ]
}
