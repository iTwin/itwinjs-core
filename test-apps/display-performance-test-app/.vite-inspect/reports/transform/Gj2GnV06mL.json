{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/common/lib/esm/IModel.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module iModels\n */\nimport { assert, BeEvent, GeoServiceStatus, Id64, IModelStatus, OpenMode } from \"@itwin/core-bentley\";\nimport { AxisIndex, AxisOrder, Constant, Geometry, Matrix3d, Point3d, Range3d, Transform, Vector3d, YawPitchRollAngles, } from \"@itwin/core-geometry\";\nimport { Cartographic } from \"./geometry/Cartographic\";\nimport { GeographicCRS } from \"./geometry/CoordinateReferenceSystem\";\nimport { IModelError } from \"./IModelError\";\n/** The position and orientation of an iModel on the earth in [ECEF](https://en.wikipedia.org/wiki/ECEF) (Earth Centered Earth Fixed) coordinates\n * @note This is an immutable type - all of its properties are frozen.\n * @see [GeoLocation of iModels]($docs/learning/GeoLocation.md)\n * @public\n */\nexport class EcefLocation {\n    /** Get the transform from iModel Spatial coordinates to ECEF from this EcefLocation */\n    getTransform() { return this._transform; }\n    /** Construct a new EcefLocation. Once constructed, it is frozen and cannot be modified. */\n    constructor(props) {\n        this.origin = Point3d.fromJSON(props.origin).freeze();\n        this.orientation = YawPitchRollAngles.fromJSON(props.orientation).freeze();\n        if (props.cartographicOrigin)\n            this.cartographicOrigin = Cartographic.fromRadians({ longitude: props.cartographicOrigin.longitude, latitude: props.cartographicOrigin.latitude, height: props.cartographicOrigin.height }).freeze();\n        if (props.xVector && props.yVector) {\n            this.xVector = Vector3d.fromJSON(props.xVector).freeze();\n            this.yVector = Vector3d.fromJSON(props.yVector).freeze();\n        }\n        let matrix;\n        if (this.xVector && this.yVector) {\n            const zVector = this.xVector.crossProduct(this.yVector);\n            if (zVector.normalizeInPlace())\n                matrix = Matrix3d.createColumns(this.xVector, this.yVector, zVector);\n        }\n        if (!matrix)\n            matrix = this.orientation.toMatrix3d();\n        this._transform = Transform.createOriginAndMatrix(this.origin, matrix);\n        this._transform.freeze();\n    }\n    /** Returns true if this EcefLocation is not located at the center of the Earth.\n     * @alpha are locations very close to the center considered valid? What are the specific criteria?\n     */\n    get isValid() {\n        return !this.origin.isZero;\n    }\n    /** Construct ECEF Location from cartographic origin with optional known point and angle.   */\n    static createFromCartographicOrigin(origin, point, angle) {\n        const ecefOrigin = origin.toEcef();\n        const deltaRadians = 10 / Constant.earthRadiusWGS84.polar;\n        const northCarto = Cartographic.fromRadians({ longitude: origin.longitude, latitude: origin.latitude + deltaRadians, height: origin.height });\n        const eastCarto = Cartographic.fromRadians({ longitude: origin.longitude + deltaRadians, latitude: origin.latitude, height: origin.height });\n        const ecefNorth = northCarto.toEcef();\n        const ecefEast = eastCarto.toEcef();\n        const xVector = Vector3d.createStartEnd(ecefOrigin, ecefEast).normalize();\n        const yVector = Vector3d.createStartEnd(ecefOrigin, ecefNorth).normalize();\n        const matrix = Matrix3d.createRigidFromColumns(xVector, yVector, AxisOrder.XYZ);\n        if (angle !== undefined) {\n            const north = Matrix3d.createRotationAroundAxisIndex(AxisIndex.Z, angle);\n            matrix.multiplyMatrixMatrix(north, matrix);\n        }\n        if (point !== undefined) {\n            const delta = matrix.multiplyVector(Vector3d.create(-point.x, -point.y, -point.z));\n            ecefOrigin.addInPlace(delta);\n        }\n        return new EcefLocation({ origin: ecefOrigin, orientation: YawPitchRollAngles.createFromMatrix3d(matrix), cartographicOrigin: origin });\n    }\n    /** Get the location center of the earth in the iModel coordinate system. */\n    get earthCenter() {\n        const matrix = this.orientation.toMatrix3d();\n        return Point3d.createFrom(matrix.multiplyTransposeXYZ(-this.origin.x, -this.origin.y, -this.origin.z));\n    }\n    /** Return true if this location is equivalent to another location within a small tolerance. */\n    isAlmostEqual(other) {\n        if (!this.origin.isAlmostEqual(other.origin) || !this.orientation.isAlmostEqual(other.orientation))\n            return false;\n        if ((this.xVector === undefined) !== (other.xVector === undefined) || (this.yVector === undefined) !== (other.yVector === undefined))\n            return false;\n        if (this.xVector !== undefined && other.xVector !== undefined && !this.xVector.isAlmostEqual(other.xVector))\n            return false;\n        if (this.yVector !== undefined && other.yVector !== undefined && !this.yVector.isAlmostEqual(other.yVector))\n            return false;\n        const thisCarto = this.cartographicOrigin;\n        const otherCarto = other.cartographicOrigin;\n        if (undefined === thisCarto || undefined === otherCarto)\n            return undefined === thisCarto && undefined === otherCarto;\n        return thisCarto.equalsEpsilon(otherCarto, Geometry.smallMetricDistance);\n    }\n    toJSON() {\n        const props = {\n            origin: this.origin.toJSON(),\n            orientation: this.orientation.toJSON(),\n        };\n        if (this.cartographicOrigin)\n            props.cartographicOrigin = this.cartographicOrigin.toJSON();\n        if (this.xVector)\n            props.xVector = this.xVector.toJSON();\n        if (this.yVector)\n            props.yVector = this.yVector.toJSON();\n        return props;\n    }\n}\n/** Represents an iModel in JavaScript.\n * @see [GeoLocation of iModels]($docs/learning/GeoLocation.md)\n * @public\n */\nclass IModel {\n    /** Name of the iModel */\n    get name() {\n        assert(this._name !== undefined);\n        return this._name;\n    }\n    set name(name) {\n        if (name !== this._name) {\n            const old = this._name;\n            this._name = name;\n            if (undefined !== old)\n                this.onNameChanged.raiseEvent(old);\n        }\n    }\n    /** The name and description of the root subject of this iModel */\n    get rootSubject() {\n        assert(this._rootSubject !== undefined);\n        return this._rootSubject;\n    }\n    set rootSubject(subject) {\n        if (undefined === this._rootSubject || this._rootSubject.name !== subject.name || this._rootSubject.description !== subject.description) {\n            const old = this._rootSubject;\n            this._rootSubject = subject;\n            if (old)\n                this.onRootSubjectChanged.raiseEvent(old);\n        }\n    }\n    /**\n     * The volume, in spatial coordinates, inside which the entire project is contained.\n     * @note The object returned from this method is frozen. You *must* make a copy before you do anything that might attempt to modify it.\n     */\n    get projectExtents() {\n        assert(undefined !== this._projectExtents);\n        return this._projectExtents;\n    }\n    set projectExtents(extents) {\n        // Don't allow any axis of the project extents to be less than 1 meter.\n        const projectExtents = extents.clone();\n        projectExtents.ensureMinLengths(1.0);\n        if (!this._projectExtents || !this._projectExtents.isAlmostEqual(projectExtents)) {\n            const old = this._projectExtents;\n            projectExtents.freeze();\n            this._projectExtents = projectExtents;\n            if (old)\n                this.onProjectExtentsChanged.raiseEvent(old);\n        }\n    }\n    /** An offset to be applied to all spatial coordinates. */\n    get globalOrigin() {\n        assert(this._globalOrigin !== undefined);\n        return this._globalOrigin;\n    }\n    set globalOrigin(org) {\n        if (!this._globalOrigin || !this._globalOrigin.isAlmostEqual(org)) {\n            const old = this._globalOrigin;\n            org.freeze();\n            this._globalOrigin = org;\n            if (old)\n                this.onGlobalOriginChanged.raiseEvent(old);\n        }\n    }\n    /** The [EcefLocation]($docs/learning/glossary#ecefLocation) of the iModel in Earth Centered Earth Fixed coordinates.\n     * If the iModel property geographicCoordinateSystem is not defined then the ecefLocation provides a geolocation by defining a\n     * 3D coordinate system relative to the Earth model WGS84. Refer to additional documentation for details. If the geographicCoordinateSystem\n     * property is defined then the ecefLocation must be used with care. When the geographicCoordinateSystem is defined it indicates the\n     * iModel cartesian space is the result of a cartographic projection. This implies a flattening of the Earth surface process that\n     * results in scale, angular or area distortion. The ecefLocation is then an approximation calculated at the center of the project extent.\n     * If the project is more than 2 kilometer in size, the ecefLocation may represent a poor approximation of the effective\n     * cartographic projection used and a linear transformation should then be calculated at the exact origin of the data\n     * it must position.\n     * @see [GeoLocation of iModels]($docs/learning/GeoLocation.md)\n    */\n    get ecefLocation() {\n        return this._ecefLocation;\n    }\n    set ecefLocation(ecefLocation) {\n        const old = this._ecefLocation;\n        if (!old && !ecefLocation)\n            return;\n        else if (old && ecefLocation && old.isAlmostEqual(ecefLocation))\n            return;\n        this._ecefLocation = ecefLocation;\n        this.onEcefLocationChanged.raiseEvent(old);\n    }\n    /** Set the [EcefLocation]($docs/learning/glossary#ecefLocation) for this iModel. */\n    setEcefLocation(ecef) {\n        this.ecefLocation = new EcefLocation(ecef);\n    }\n    /** The geographic coordinate reference system of the iModel. */\n    get geographicCoordinateSystem() {\n        return this._geographicCoordinateSystem;\n    }\n    set geographicCoordinateSystem(geoCRS) {\n        const old = this._geographicCoordinateSystem;\n        if (!old && !geoCRS)\n            return;\n        else if (old && geoCRS && old.equals(geoCRS))\n            return;\n        this._geographicCoordinateSystem = geoCRS;\n        this.onGeographicCoordinateSystemChanged.raiseEvent(old);\n    }\n    /** Sets the geographic coordinate reference system from GeographicCRSProps. */\n    setGeographicCoordinateSystem(geoCRS) {\n        this.geographicCoordinateSystem = new GeographicCRS(geoCRS);\n    }\n    /** @internal */\n    getConnectionProps() {\n        return {\n            name: this.name,\n            rootSubject: this.rootSubject,\n            projectExtents: this.projectExtents.toJSON(),\n            globalOrigin: this.globalOrigin.toJSON(),\n            ecefLocation: this.ecefLocation,\n            geographicCoordinateSystem: this.geographicCoordinateSystem,\n            ...this._getRpcProps(),\n        };\n    }\n    /** Convert this iModel to a JSON representation. */\n    toJSON() {\n        return this.getConnectionProps();\n    }\n    /** Get the key that was used to open this iModel. This is the value used for Rpc and Ipc communications. */\n    get key() { return this._fileKey; }\n    /** The Guid that identifies the iTwin that owns this iModel. */\n    get iTwinId() { return this._iTwinId; }\n    /** The Guid that identifies this iModel. */\n    get iModelId() { return this._iModelId; }\n    /** The [[OpenMode]] used for this IModel. */\n    get openMode() { return this._openMode; }\n    /** Return a token for RPC operations.\n     * @throws IModelError if the iModel is not open.\n     */\n    getRpcProps() {\n        if (!this.isOpen)\n            throw new IModelError(IModelStatus.BadRequest, \"IModel is not open for rpc\");\n        return this._getRpcProps();\n    }\n    /** Returns the iModel's RPC properties.\n     * @note It is an error to attempt to use these properties as a token for RPC operations if the iModel is not open.\n     * @internal\n     */\n    _getRpcProps() {\n        return {\n            key: this._fileKey,\n            iTwinId: this.iTwinId,\n            iModelId: this.iModelId,\n            changeset: this.changeset,\n        };\n    }\n    /** @internal */\n    constructor(tokenProps) {\n        /** Event raised after [[name]] changes. */\n        this.onNameChanged = new BeEvent();\n        /** Event raised after [[rootSubject]] changes. */\n        this.onRootSubjectChanged = new BeEvent();\n        /** Event raised after [[projectExtents]] changes. */\n        this.onProjectExtentsChanged = new BeEvent();\n        /** Event raised after [[globalOrigin]] changes. */\n        this.onGlobalOriginChanged = new BeEvent();\n        /** Event raised after [[ecefLocation]] changes. */\n        this.onEcefLocationChanged = new BeEvent();\n        /** Event raised after [[geographicCoordinateSystem]] changes. */\n        this.onGeographicCoordinateSystemChanged = new BeEvent();\n        this._openMode = OpenMode.Readonly;\n        this.changeset = { id: \"\", index: 0 };\n        this._fileKey = \"\";\n        if (tokenProps) {\n            this._fileKey = tokenProps.key;\n            this._iTwinId = tokenProps.iTwinId;\n            this._iModelId = tokenProps.iModelId;\n            if (tokenProps.changeset)\n                this.changeset = tokenProps.changeset;\n        }\n    }\n    /** @internal */\n    initialize(name, props) {\n        this.name = name;\n        this.rootSubject = props.rootSubject;\n        this.projectExtents = Range3d.fromJSON(props.projectExtents);\n        this.globalOrigin = Point3d.fromJSON(props.globalOrigin);\n        const ecefLocation = props.ecefLocation ? new EcefLocation(props.ecefLocation) : undefined;\n        this.ecefLocation = ecefLocation?.isValid ? ecefLocation : undefined;\n        this.geographicCoordinateSystem = props.geographicCoordinateSystem ? new GeographicCRS(props.geographicCoordinateSystem) : undefined;\n    }\n    /** Get the default subCategoryId for the supplied categoryId */\n    static getDefaultSubCategoryId(categoryId) {\n        return Id64.isValid(categoryId) ? Id64.fromLocalAndBriefcaseIds(Id64.getLocalId(categoryId) + 1, Id64.getBriefcaseId(categoryId)) : Id64.invalid;\n    }\n    /** True if this iModel has an [EcefLocation]($docs/learning/glossary#ecefLocation). */\n    get isGeoLocated() { return undefined !== this._ecefLocation; }\n    /** Get the Transform from this iModel's Spatial coordinates to ECEF coordinates using its [[IModel.ecefLocation]].\n     * @throws IModelError if [[isGeoLocated]] is false.\n     */\n    getEcefTransform() {\n        if (undefined === this._ecefLocation)\n            throw new IModelError(GeoServiceStatus.NoGeoLocation, \"iModel is not GeoLocated\");\n        return this._ecefLocation.getTransform();\n    }\n    /** Convert a point in this iModel's Spatial coordinates to an ECEF point using its [[IModel.ecefLocation]].\n     * @param spatial A point in the iModel's spatial coordinates\n     * @param result If defined, use this for output\n     * @returns A Point3d in ECEF coordinates\n     * @throws IModelError if [[isGeoLocated]] is false.\n     */\n    spatialToEcef(spatial, result) { return this.getEcefTransform().multiplyPoint3d(spatial, result); }\n    /** Convert a point in ECEF coordinates to a point in this iModel's Spatial coordinates using its [[ecefLocation]].\n     * @param ecef A point in ECEF coordinates\n     * @param result If defined, use this for output\n     * @returns A Point3d in this iModel's spatial coordinates\n     * @throws IModelError if [[isGeoLocated]] is false.\n     * @note The resultant point will only be meaningful if the ECEF coordinate is close on the earth to the iModel.\n     */\n    ecefToSpatial(ecef, result) { return this.getEcefTransform().multiplyInversePoint3d(ecef, result); }\n    /** Convert a point in this iModel's Spatial coordinates to a [[Cartographic]] using its [[IModel.ecefLocation]].\n     * @param spatial A point in the iModel's spatial coordinates\n     * @param result If defined, use this for output\n     * @returns A Cartographic location\n     * @throws IModelError if [[isGeoLocated]] is false.\n     */\n    spatialToCartographicFromEcef(spatial, result) { return Cartographic.fromEcef(this.spatialToEcef(spatial), result); }\n    /** Convert a [[Cartographic]] to a point in this iModel's Spatial coordinates using its [[IModel.ecefLocation]].\n     * @param cartographic A cartographic location\n     * @param result If defined, use this for output\n     * @returns A point in this iModel's spatial coordinates\n     * @throws IModelError if [[isGeoLocated]] is false.\n     * @note The resultant point will only be meaningful if the ECEF coordinate is close on the earth to the iModel.\n     */\n    cartographicToSpatialFromEcef(cartographic, result) { return this.ecefToSpatial(cartographic.toEcef(result), result); }\n}\n/** The Id of the repository model. */\nIModel.repositoryModelId = \"0x1\";\n/** The Id of the root subject element. */\nIModel.rootSubjectId = \"0x1\";\n/** The Id of the dictionary model. */\nIModel.dictionaryId = \"0x10\";\nexport { IModel };\n//# sourceMappingURL=IModel.js.map",
      "start": 1693508120634,
      "end": 1693508120714,
      "sourcemaps": null
    }
  ]
}
