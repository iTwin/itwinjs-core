{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/DrawCommand.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { assert, Id64 } from \"@itwin/core-bentley\";\nimport { PackedFeature } from \"@itwin/core-common\";\nimport { isFeatureHilited } from \"./FeatureOverrides\";\nimport { System } from \"./System\";\nimport { TechniqueFlags } from \"./TechniqueFlags\";\n/* eslint-disable no-restricted-syntax */\n/** @internal */\nexport class ShaderProgramParams {\n    constructor() {\n        this._renderPass = 255 /* RenderPass.None */;\n    }\n    get target() {\n        assert(undefined !== this._target);\n        return this._target;\n    }\n    get renderPass() { return this._renderPass; }\n    get projectionMatrix() { return this.target.uniforms.getProjectionMatrix32(this.isViewCoords); }\n    bindProjectionMatrix(uniform) { this.target.uniforms.bindProjectionMatrix(uniform, this.isViewCoords); }\n    get isViewCoords() { return 13 /* RenderPass.ViewOverlay */ === this.renderPass || 0 /* RenderPass.Background */ === this.renderPass; }\n    get isOverlayPass() { return 12 /* RenderPass.WorldOverlay */ === this.renderPass || 13 /* RenderPass.ViewOverlay */ === this.renderPass; }\n    get context() { return System.instance.context; }\n    init(target, pass = 5 /* RenderPass.OpaqueGeneral */) {\n        this._renderPass = pass;\n        this._target = target;\n    }\n}\n/** @internal */\nexport class DrawParams {\n    get geometry() {\n        assert(undefined !== this._geometry);\n        return this._geometry;\n    }\n    get programParams() {\n        assert(undefined !== this._programParams);\n        return this._programParams;\n    }\n    get target() { return this.programParams.target; }\n    get renderPass() { return this.programParams.renderPass; }\n    get projectionMatrix() { return this.programParams.projectionMatrix; }\n    get isViewCoords() {\n        return this.programParams.isViewCoords || this.target.currentBranch.forceViewCoords;\n    }\n    get isOverlayPass() { return this.programParams.isOverlayPass; }\n    get context() { return this.programParams.context; }\n    init(programParams, geometry) {\n        this._programParams = programParams;\n        this._geometry = geometry;\n    }\n}\n/** Represents a command to be executed within a RenderPass. The most common command is\n * to draw a primitive; others involve state changes such as pushing/popping transforms\n * and symbology overrides, which require that commands be executed in order.\n * @internal\n */\nexport var DrawOpCode;\n(function (DrawOpCode) {\n    DrawOpCode[\"Primitive\"] = \"drawPrimitive\";\n    DrawOpCode[\"PushBranch\"] = \"pushBranch\";\n    DrawOpCode[\"PopBranch\"] = \"popBranch\";\n    DrawOpCode[\"PushBatch\"] = \"pushBatch\";\n    DrawOpCode[\"PopBatch\"] = \"popBatch\";\n    DrawOpCode[\"PushState\"] = \"pushState\";\n    DrawOpCode[\"PushClip\"] = \"pushClip\";\n    DrawOpCode[\"PopClip\"] = \"popClip\";\n})(DrawOpCode || (DrawOpCode = {}));\n/** @internal */\nclass PopBatchCommand {\n    constructor() {\n        this.opcode = \"popBatch\";\n    }\n    execute(exec) {\n        exec.target.popBatch();\n    }\n}\nPopBatchCommand.instance = new PopBatchCommand();\nexport { PopBatchCommand };\n/** @internal */\nexport class PushBatchCommand {\n    constructor(batch) {\n        this.batch = batch;\n        this.opcode = \"pushBatch\";\n    }\n    execute(exec) {\n        exec.target.pushBatch(this.batch);\n    }\n}\n/** @internal */\nexport class PushStateCommand {\n    constructor(state) {\n        this.state = state;\n        this.opcode = \"pushState\";\n    }\n    execute(exec) {\n        exec.target.pushState(this.state);\n    }\n}\n/** @internal */\nexport class PushBranchCommand {\n    constructor(branch) {\n        this.branch = branch;\n        this.opcode = \"pushBranch\";\n    }\n    execute(exec) {\n        exec.pushBranch(this.branch);\n    }\n}\n/** @internal */\nclass PopBranchCommand {\n    constructor() {\n        this.opcode = \"popBranch\";\n    }\n    execute(exec) {\n        exec.popBranch();\n    }\n}\nPopBranchCommand.instance = new PopBranchCommand();\nexport { PopBranchCommand };\n/** @internal */\nexport class PushClipCommand {\n    constructor(clip) {\n        this.clip = clip;\n        this.opcode = \"pushClip\";\n    }\n    execute(exec) {\n        exec.target.uniforms.branch.clipStack.push(this.clip);\n    }\n}\n/** @internal */\nclass PopClipCommand {\n    constructor() {\n        this.opcode = \"popClip\";\n    }\n    execute(exec) {\n        exec.target.uniforms.branch.clipStack.pop();\n    }\n}\nPopClipCommand.instance = new PopClipCommand();\nexport { PopClipCommand };\n/** @internal */\nclass PrimitiveCommand {\n    constructor(primitive) {\n        this.primitive = primitive;\n        this.opcode = \"drawPrimitive\";\n    }\n    execute(exec) {\n        if (exec.target.isGeometryOutsideActiveVolume(this.primitive.cachedGeometry))\n            return;\n        const techniqueId = this.primitive.techniqueId;\n        if (-1 /* TechniqueId.Invalid */ === techniqueId)\n            return;\n        const target = exec.target;\n        const thematic = this.primitive.cachedGeometry.supportsThematicDisplay && target.wantThematicDisplay;\n        const shadowable = (techniqueId === 0 /* TechniqueId.Surface */ || techniqueId === 7 /* TechniqueId.RealityMesh */) && target.solarShadowMap.isReady && target.currentViewFlags.shadows && !thematic;\n        const isShadowable = shadowable ? 1 /* IsShadowable.Yes */ : 0 /* IsShadowable.No */;\n        let isThematic = thematic ? 1 /* IsThematic.Yes */ : 0 /* IsThematic.No */;\n        const isClassified = (undefined !== target.currentPlanarClassifierOrDrape || undefined !== target.activeVolumeClassifierTexture) ? 1 /* IsClassified.Yes */ : 0 /* IsClassified.No */;\n        const isInstanced = this.primitive.isInstanced ? 1 /* IsInstanced.Yes */ : 0 /* IsInstanced.No */;\n        const isAnimated = this.primitive.hasAnimation ? 1 /* IsAnimated.Yes */ : 0 /* IsAnimated.No */;\n        // Point clouds do not support hillshade or slope mode for thematic display.\n        if (isThematic && (undefined !== this.primitive.cachedGeometry.asPointCloud) && (target.uniforms.thematic.wantSlopeMode || target.uniforms.thematic.wantHillShadeMode))\n            isThematic = 0 /* IsThematic.No */;\n        const wiremesh = target.currentViewFlags.wiremesh && (techniqueId === 0 /* TechniqueId.Surface */ || techniqueId === 7 /* TechniqueId.RealityMesh */);\n        const isWiremesh = wiremesh ? 1 /* IsWiremesh.Yes */ : 0 /* IsWiremesh.No */;\n        const flags = PrimitiveCommand._scratchTechniqueFlags;\n        const posType = this.primitive.cachedGeometry.usesQuantizedPositions ? \"quantized\" : \"unquantized\";\n        const enableAtmosphere = target.wantAtmosphere ? 1 /* EnableAtmosphere.Yes */ : 0 /* EnableAtmosphere.No */;\n        flags.init(target, exec.renderPass, isInstanced, isAnimated, isClassified, isShadowable, isThematic, isWiremesh, posType, enableAtmosphere);\n        const technique = target.techniques.getTechnique(techniqueId);\n        const program = technique.getShader(flags);\n        if (exec.setProgram(program))\n            exec.target.compositor.drawPrimitive(this.primitive, exec, program.outputsToPick);\n    }\n    get hasFeatures() { return this.primitive.hasFeatures; }\n    get renderOrder() { return this.primitive.renderOrder; }\n    getPass(target) {\n        return this.primitive.getPass(target);\n    }\n}\nPrimitiveCommand._scratchTechniqueFlags = new TechniqueFlags();\nexport { PrimitiveCommand };\n/** Extracts the commands for rendering the flashed classifier (if any) from the by-index set of volume classifier commands.\n * NB: Cmds will be sets of some pushes, a primitive, and then some pops (equal to number of pushes).\n * The primitive should be right in the middle of a set.  We need to find the set which matches the flashID.\n * @internal\n */\nexport function extractFlashedVolumeClassifierCommands(flashedId, cmds, numCmdsPerClassifier) {\n    if (!Id64.isValid(flashedId) || 0 === numCmdsPerClassifier)\n        return undefined;\n    const firstPrim = (numCmdsPerClassifier - 1) / 2;\n    for (let i = firstPrim; i < cmds.length; i += numCmdsPerClassifier) {\n        assert(\"drawPrimitive\" === cmds[i].opcode, \"Command list not configured as expected.\");\n        const pc = cmds[i];\n        const surface = pc.primitive.cachedGeometry.asSurface;\n        if (undefined !== surface && undefined !== surface.mesh.uniformFeatureId) {\n            let j = i - 1;\n            while (j >= 0 && \"pushBatch\" !== cmds[j].opcode) // Find batch for this primitive\n                j--;\n            if (j < 0)\n                continue;\n            const pushBatch = cmds[j];\n            const elemId = pushBatch.batch.featureTable.findElementId(surface.mesh.uniformFeatureId);\n            if (undefined !== elemId && elemId === flashedId) {\n                return cmds.slice(i - firstPrim, i + firstPrim + 1);\n            }\n        }\n    }\n    return undefined;\n}\nconst scratchFeature = PackedFeature.create();\n/** @internal */\nexport function extractHilitedVolumeClassifierCommands(hilites, cmds) {\n    // TODO: This could really be done at the time the HiliteClassification render pass commands are being generated\n    //       by just not putting the ones which are not hilited into the ClassificationHilite command list.\n    const result = [];\n    let batch;\n    for (const cmd of cmds) {\n        switch (cmd.opcode) {\n            case \"popBranch\":\n                if (result.length > 0 && \"pushBranch\" === result[result.length - 1].opcode) {\n                    result.pop(); // remove empty push/pop pairs\n                    continue;\n                }\n                break;\n            case \"popBatch\":\n                batch = undefined;\n                if (result.length > 0 && \"pushBatch\" === result[result.length - 1].opcode) {\n                    result.pop(); // remove empty push/pop pairs\n                    continue;\n                }\n                break;\n            case \"pushBatch\":\n                batch = cmd.batch;\n                break;\n            case \"drawPrimitive\":\n                if (undefined !== batch) {\n                    // Skip any primitives that are not hilited.\n                    const surface = cmd.primitive.cachedGeometry.asSurface;\n                    if (undefined === surface || undefined === surface.mesh.uniformFeatureId)\n                        continue;\n                    const feature = batch.featureTable.getPackedFeature(surface.mesh.uniformFeatureId, scratchFeature);\n                    if (undefined === feature || !isFeatureHilited(feature, hilites, hilites.models.hasId(Id64.fromUint32PairObject(feature.modelId))))\n                        continue;\n                    break;\n                }\n        }\n        result.push(cmd);\n    }\n    return result;\n}\n//# sourceMappingURL=DrawCommand.js.map",
      "start": 1693508121079,
      "end": 1693508121360,
      "sourcemaps": null
    }
  ]
}
