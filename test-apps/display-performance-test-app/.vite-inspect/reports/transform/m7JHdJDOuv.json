{
  "resolvedId": "D:/hub2023A/itwinjs-core/test-apps/display-performance-test-app/src/frontend/TestRunner.ts",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\r\n* See LICENSE.md in the project root for license terms and full copyright notice.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\nimport { RealityDataAccessClient, RealityDataClientOptions } from \"@itwin/reality-data-client\";\r\nimport {\r\n  assert, Dictionary, Id64, Id64Array, Id64String, ProcessDetector, SortedArray, StopWatch,\r\n} from \"@itwin/core-bentley\";\r\nimport {\r\n  BackgroundMapType, BaseMapLayerSettings, DisplayStyleProps, FeatureAppearance, Hilite, RenderMode, ViewStateProps,\r\n} from \"@itwin/core-common\";\r\nimport {\r\n  CheckpointConnection,\r\n  DisplayStyle3dState, DisplayStyleState, EntityState, FeatureSymbology, GLTimerResult, GLTimerResultCallback, IModelApp, IModelConnection,\r\n  PerformanceMetrics, Pixel, RenderMemory, RenderSystem, ScreenViewport, SnapshotConnection, Target, TileAdmin, ToolAdmin, ViewRect, ViewState,\r\n} from \"@itwin/core-frontend\";\r\nimport { System } from \"@itwin/core-frontend/lib/cjs/webgl\";\r\nimport { HyperModeling } from \"@itwin/hypermodeling-frontend\";\r\nimport { TestFrontendAuthorizationClient } from \"@itwin/oidc-signin-tool/lib/cjs/TestFrontendAuthorizationClient\";\r\nimport DisplayPerfRpcInterface from \"../common/DisplayPerfRpcInterface\";\r\nimport { DisplayPerfTestApp } from \"./DisplayPerformanceTestApp\";\r\nimport {\r\n  defaultEmphasis, defaultHilite, ElementOverrideProps, HyperModelingProps, separator, TestConfig, TestConfigProps, TestConfigStack, ViewStateSpec, ViewStateSpecProps,\r\n} from \"./TestConfig\";\r\nimport { SavedViewsFetcher } from \"./SavedViewsFetcher\";\r\n\r\n/** JSON representation of a set of tests. Each test in the set inherits the test set's configuration. */\r\nexport interface TestSetProps extends TestConfigProps {\r\n  tests: TestConfigProps[];\r\n}\r\n\r\n/** JSON representation of TestRunner. The tests inherit the base configuration options. */\r\nexport interface TestSetsProps extends TestConfigProps {\r\n  signIn?: boolean;\r\n  minimize?: boolean;\r\n  testSet: TestSetProps[];\r\n}\r\n\r\n/** Context for any number of TestCases to be run against an iModel. */\r\ninterface TestContext {\r\n  readonly iModel: IModelConnection;\r\n  readonly externalSavedViews: ViewStateSpec[];\r\n}\r\n\r\n/** The view against which a specific TestCase is to be run. */\r\ninterface TestViewState {\r\n  readonly view: ViewState;\r\n  readonly elementOverrides?: ElementOverrideProps[];\r\n  readonly selectedElements?: Id64String | Id64Array;\r\n}\r\n\r\n/** The result of TestRunner.runTest. */\r\ninterface TestResult {\r\n  /** An ordered listing of all the tiles selected for display. */\r\n  selectedTileIds: string;\r\n  /** The number of tiles selected for display. */\r\n  numSelectedTiles: number;\r\n  /** Approximate time in milliseconds before all tiles were ready for display. */\r\n  tileLoadingTime: number;\r\n  /** Amount of memory requested from the GPU for the graphics of the tiles selected for display. */\r\n  selectedTileGpuBytes: number;\r\n  /** Amount of memory requested from the GPU for the graphics of all tiles in the tile trees viewed by this test.\r\n   * This is always at least as large as selectedTileGpuBytes and may be much larger as recently-used tiles are kept in memory\r\n   * for a period of time, and parent tiles' graphics are typically kept in memory for as long as their child tiles are.\r\n   * Therefore this may be expected to grow over time as successive tests exercise different views of the same tile trees.\r\n   */\r\n  viewedTileTreeGpuBytes: number;\r\n  /** Total amount of memory requested (and not yet relinquished) from the GPU by the render system, including frame buffers,\r\n   * textures, graphics, etc.\r\n   */\r\n  totalGpuBytes: number;\r\n}\r\n\r\n/** A test being executed in a viewport. */\r\ninterface TestCase extends TestResult {\r\n  readonly viewport: ScreenViewport;\r\n  view: TestViewState;\r\n}\r\n\r\n/** Timings collected during TestRunner.runTest. */\r\nclass Timings {\r\n  public readonly cpu = new Array<Map<string, number>>();\r\n  public readonly gpu = new Map<string, number[]>();\r\n  public readonly actualFps = new Array<Map<string, number>>();\r\n  public gpuFramesCollected = 0;\r\n  public readonly callback: GLTimerResultCallback;\r\n\r\n  public constructor(numFramesToCollect: number) {\r\n    this.callback = (result: GLTimerResult) => {\r\n      if (this.gpuFramesCollected >= numFramesToCollect)\r\n        return;\r\n\r\n      const label = result.label;\r\n      const timings = this.gpu.get(label);\r\n      this.gpu.set(label, timings ? timings.concat(result.nanoseconds / 1e6) : [result.nanoseconds / 1e6]); // save as milliseconds\r\n      if (result.children)\r\n        for (const child of result.children)\r\n          this.callback(child);\r\n\r\n      if (\"Total\" === label)\r\n        ++this.gpuFramesCollected;\r\n    };\r\n  }\r\n\r\n  public set callbackEnabled(enabled: boolean) {\r\n    IModelApp.renderSystem.debugControl!.resultsCallback = enabled ? this.callback : undefined;\r\n  }\r\n}\r\n\r\n/** Applies ELementOverrideProps to elements in a viewport for a TestCase. */\r\nclass OverrideProvider {\r\n  private readonly _elementOvrs = new Map<Id64String, FeatureAppearance>();\r\n  private readonly _defaultOvrs?: FeatureAppearance;\r\n\r\n  private constructor(ovrs: ElementOverrideProps[]) {\r\n    for (const ovr of ovrs) {\r\n      const app = FeatureAppearance.fromJSON(JSON.parse(ovr.fsa));\r\n      if (ovr.id === \"-default-\")\r\n        this._defaultOvrs = app;\r\n      else\r\n        this._elementOvrs.set(ovr.id, app);\r\n    }\r\n  }\r\n\r\n  public static override(vp: ScreenViewport, ovrs: ElementOverrideProps[]): void {\r\n    const provider = new OverrideProvider(ovrs);\r\n    vp.addFeatureOverrideProvider(provider);\r\n  }\r\n\r\n  public addFeatureOverrides(ovrs: FeatureSymbology.Overrides): void {\r\n    if (this._defaultOvrs)\r\n      ovrs.setDefaultOverrides(this._defaultOvrs);\r\n\r\n    for (const [elementId, appearance] of this._elementOvrs)\r\n      ovrs.override({ elementId, appearance });\r\n  }\r\n}\r\n\r\n/** Given the JSON representation of a set of tests, executes them and records output (CSV timing info, images, logs, etc). */\r\nexport class TestRunner {\r\n  private readonly _config: TestConfigStack;\r\n  private readonly _minimizeOutput: boolean;\r\n  private readonly _testSets: TestSetProps[];\r\n  private readonly _logFileName: string;\r\n  private readonly _testNamesImages = new Map<string, number>();\r\n  private readonly _testNamesTimings = new Map<string, number>();\r\n  private readonly _savedViewsFetcher: SavedViewsFetcher;\r\n  private _lastRestartConfig: TestConfig;\r\n\r\n  public get curConfig(): TestConfig {\r\n    return this._config.top;\r\n  }\r\n\r\n  public get lastRestartConfig(): TestConfig { return this._lastRestartConfig; }\r\n  public set lastRestartConfig(config: TestConfig) {\r\n    this._lastRestartConfig = config;\r\n  }\r\n\r\n  public constructor(\r\n    props: TestSetsProps,\r\n    savedViewsFetcher: SavedViewsFetcher = new SavedViewsFetcher(),\r\n  ) {\r\n    // NB: The default minimum spatial chord tolerance was changed from \"no minimum\" to 1mm. To preserve prior behavior,\r\n    // override it to zero.\r\n    // Subsequently pushed configs can override this if desired.\r\n    const defaultTileProps: TileAdmin.Props = { minimumSpatialTolerance: 0 };\r\n    props.tileProps = props.tileProps ? { ...defaultTileProps, ...props.tileProps } : defaultTileProps;\r\n\r\n    this._config = new TestConfigStack(new TestConfig(props));\r\n    this._lastRestartConfig = this.curConfig;\r\n    this._testSets = props.testSet;\r\n    this._minimizeOutput = true === props.minimize;\r\n    this._logFileName = \"_DispPerfTestAppViewLog.txt\";\r\n    this._savedViewsFetcher = savedViewsFetcher;\r\n\r\n    ToolAdmin.exceptionHandler = async (ex) => this.onException(ex);\r\n  }\r\n\r\n  /** Run all the tests. */\r\n  public async run(): Promise<void> {\r\n    const msg = `View Log,  Model Base Location: ${this.curConfig.iModelLocation}\\n  format: Time_started  ModelName  [ViewName]`;\r\n    await this.logToConsole(msg);\r\n    await this.logToFile(msg, { noAppend: true });\r\n\r\n    let needRestart = this.curConfig.requiresRestart(new TestConfig({})); // If current config differs from default, restart\r\n    const renderOptions: RenderSystem.Options = this.curConfig.renderOptions ?? {};\r\n    if (!this.curConfig.useDisjointTimer) {\r\n      const ext = this.curConfig.renderOptions?.disabledExtensions;\r\n      renderOptions.disabledExtensions = Array.isArray(ext) ? ext.concat([\"EXT_disjoint_timer_query\", \"EXT_disjoint_timer_query_webgl2\"]) : [\"EXT_disjoint_timer_query\", \"EXT_disjoint_timer_query_webgl2\"];\r\n      needRestart = true;\r\n    }\r\n    if (IModelApp.initialized && needRestart) {\r\n      await IModelApp.shutdown();\r\n    }\r\n    if (!IModelApp.initialized) {\r\n      const realityDataClientOptions: RealityDataClientOptions = {\r\n        /** API Version. v1 by default */\r\n        // version?: ApiVersion;\r\n        /** API Url. Used to select environment. Defaults to \"https://api.bentley.com/realitydata\" */\r\n        baseUrl: `https://${process.env.IMJS_URL_PREFIX}api.bentley.com/realitydata`,\r\n      };\r\n      await DisplayPerfTestApp.startup({\r\n        renderSys: renderOptions,\r\n        tileAdmin: this.curConfig.tileProps,\r\n        realityDataAccess: new RealityDataAccessClient(realityDataClientOptions),\r\n      });\r\n    }\r\n    // save current state as reference, whether or not we restarted\r\n    this.lastRestartConfig = this.curConfig;\r\n\r\n    // Run all the tests\r\n    for (const set of this._testSets)\r\n      await this.runTestSet(set);\r\n\r\n    // Update UI to signal we're finished.\r\n    const topdiv = document.getElementById(\"topdiv\")!;\r\n    topdiv.style.display = \"block\";\r\n    topdiv.innerText = \"Tests Completed.\";\r\n    document.getElementById(\"imodel-viewport\")!.style.display = \"hidden\";\r\n\r\n    // Write WebGL compatibility info to CSV.\r\n    await this.finish();\r\n  }\r\n\r\n  private async runTestSet(set: TestSetProps): Promise<void> {\r\n    this._config.push(set);\r\n    const realityDataClientOptions: RealityDataClientOptions = {\r\n      /** API Version. v1 by default */\r\n      // version?: ApiVersion;\r\n      /** API Url. Used to select environment. Defaults to \"https://api.bentley.com/realitydata\" */\r\n      baseUrl: `https://${process.env.IMJS_URL_PREFIX}api.bentley.com/realitydata`,\r\n    };\r\n    // Perform all the tests for this iModel. If the iModel name contains an asterisk,\r\n    // treat it as a wildcard and run tests for each iModel that matches the given wildcard.\r\n    for (const testProps of set.tests) {\r\n      this._config.push(testProps);\r\n\r\n      // Ensure IModelApp is initialized with options required by this test.\r\n      if (IModelApp.initialized && this.curConfig.requiresRestart(this.lastRestartConfig)) {\r\n        await IModelApp.shutdown();\r\n      }\r\n      if (!IModelApp.initialized) {\r\n        const renderOptions: RenderSystem.Options = this.curConfig.renderOptions ?? {};\r\n        if (!this.curConfig.useDisjointTimer) {\r\n          const ext = this.curConfig.renderOptions?.disabledExtensions;\r\n          renderOptions.disabledExtensions = Array.isArray(ext) ? ext.concat([\"EXT_disjoint_timer_query\", \"EXT_disjoint_timer_query_webgl2\"]) : [\"EXT_disjoint_timer_query\", \"EXT_disjoint_timer_query_webgl2\"];\r\n        }\r\n        await DisplayPerfTestApp.startup({\r\n          renderSys: renderOptions,\r\n          tileAdmin: this.curConfig.tileProps,\r\n          realityDataAccess: new RealityDataAccessClient(realityDataClientOptions),\r\n        });\r\n        this.lastRestartConfig = this.curConfig;\r\n      }\r\n\r\n      // Run test against all iModels matching the test config.\r\n      const iModelNames = await this.getIModelNames();\r\n      const originalViewName = this.curConfig.viewName;\r\n      for (const iModelName of iModelNames) {\r\n        this.curConfig.iModelName = iModelName;\r\n        this.curConfig.viewName = originalViewName;\r\n\r\n        let context: TestContext;\r\n        try {\r\n          context = await this.openIModel();\r\n        } catch (e: any) {\r\n          await this.logError(`Failed to open iModel ${iModelName}: ${(e as Error).message}`);\r\n          continue;\r\n        }\r\n\r\n        try {\r\n          await this.runTests(context);\r\n        } catch {\r\n          await this.logError(`Failed to run tests on iModel ${iModelName}`);\r\n        } finally {\r\n          await context.iModel.close();\r\n        }\r\n      }\r\n      this._config.pop();\r\n    }\r\n\r\n    this._config.pop();\r\n  }\r\n\r\n  private async runTests(context: TestContext): Promise<void> {\r\n    const viewNames = await this.getViewNames(context);\r\n    for (const viewName of viewNames) {\r\n      this.curConfig.viewName = viewName;\r\n\r\n      await this.logTest();\r\n\r\n      try {\r\n        this.curConfig.urlStr = undefined;\r\n        const result = await this.runTest(context);\r\n        if (this.curConfig.urlStr)\r\n          await this.logURL();\r\n        if (result)\r\n          await this.logToFile(result.selectedTileIds, { noNewLine: true });\r\n      } catch (ex) {\r\n        await this.onException(ex);\r\n      }\r\n    }\r\n  }\r\n\r\n  private async runTest(context: TestContext): Promise<TestResult | undefined> {\r\n    // Reset the title bar to include the current model and view name\r\n    const testConfig = this.curConfig;\r\n    document.title = \"Display Performance Test App:  \".concat(testConfig.iModelName ?? \"\", \"  [\", testConfig.viewName ?? \"\", \"]\");\r\n\r\n    const test = await this.setupTest(context);\r\n    if (!test)\r\n      return undefined;\r\n\r\n    const vp = test.viewport;\r\n    if (testConfig.testType === \"image\" || testConfig.testType === \"both\") {\r\n      this.updateTestNames(test, undefined, true);\r\n\r\n      const canvas = vp.readImageToCanvas();\r\n      await savePng(this.getImageName(test), canvas);\r\n\r\n      if (testConfig.testType === \"image\") {\r\n        vp.dispose();\r\n        return test;\r\n      }\r\n    }\r\n\r\n    // Throw away the first N frames until the timings become more consistent.\r\n    for (let i = 0; i < this.curConfig.numRendersToSkip; i++) {\r\n      vp.requestRedraw();\r\n      vp.renderFrame();\r\n    }\r\n\r\n    this.updateTestNames(test);\r\n    await (testConfig.testType === \"readPixels\" ? this.recordReadPixels(test) : this.recordRender(test));\r\n\r\n    vp.dispose();\r\n    return test;\r\n  }\r\n\r\n  private async recordReadPixels(test: TestCase): Promise<void> {\r\n    const vp = test.viewport;\r\n    const viewRect = new ViewRect(0, 0, this.curConfig.view.width, this.curConfig.view.height);\r\n    const timings = new Timings(this.curConfig.numRendersToTime);\r\n\r\n    const testReadPix = async (pixSelect: Pixel.Selector, pixSelectStr: string) => {\r\n      // Collect CPU timings.\r\n      setPerformanceMetrics(vp, new PerformanceMetrics(true, false, undefined));\r\n      for (let i = 0; i < this.curConfig.numRendersToTime; ++i) {\r\n        vp.readPixels(viewRect, pixSelect, () => { });\r\n        timings.cpu[i] = (vp.target as Target).performanceMetrics!.frameTimings;\r\n        timings.cpu[i].delete(\"Scene Time\");\r\n      }\r\n\r\n      // Collect GPU timings.\r\n      timings.gpuFramesCollected = 0;\r\n      timings.callbackEnabled = true;\r\n      setPerformanceMetrics(vp, new PerformanceMetrics(true, false, timings.callback));\r\n      await this.renderAsync(vp, this.curConfig.numRendersToTime, timings);\r\n      timings.callbackEnabled = false;\r\n\r\n      this.updateTestNames(test, pixSelectStr, true);\r\n      this.updateTestNames(test, pixSelectStr, false);\r\n\r\n      const row = this.getRowData(timings, test, pixSelectStr);\r\n      await this.saveCsv(row);\r\n      await this.createReadPixelsImages(test, pixSelect, pixSelectStr);\r\n    };\r\n\r\n    // Test each combo of pixel selectors.\r\n    await testReadPix(Pixel.Selector.Feature, \"+feature\");\r\n    await testReadPix(Pixel.Selector.GeometryAndDistance, \"+geom+dist\");\r\n    await testReadPix(Pixel.Selector.All, \"+feature+geom+dist\");\r\n  }\r\n\r\n  private async recordRender(test: TestCase): Promise<void> {\r\n    const timings = new Timings(this.curConfig.numRendersToTime);\r\n    setPerformanceMetrics(test.viewport, new PerformanceMetrics(true, false, timings.callback));\r\n    await this.renderAsync(test.viewport, this.curConfig.numRendersToTime, timings);\r\n\r\n    const row = this.getRowData(timings, test);\r\n    await this.saveCsv(row);\r\n  }\r\n\r\n  private async renderAsync(vp: ScreenViewport, numFrames: number, timings: Timings): Promise<void> {\r\n    IModelApp.viewManager.addViewport(vp);\r\n\r\n    const target = vp.target as Target;\r\n    const metrics = target.performanceMetrics;\r\n    assert(undefined !== metrics);\r\n\r\n    target.performanceMetrics = undefined;\r\n    timings.callbackEnabled = false;\r\n\r\n    const numFramesToIgnore = 120;\r\n    let ignoreFrameCount = 0;\r\n    let frameCount = 0;\r\n    vp.continuousRendering = true;\r\n    return new Promise((resolve: () => void, _reject) => {\r\n      const timer = new StopWatch();\r\n      const removeListener = vp.onRender.addListener(() => {\r\n        // Ignore the first N frames - they seem to have more variable frame rate.\r\n        if (++ignoreFrameCount <= numFramesToIgnore) {\r\n          if (ignoreFrameCount === numFramesToIgnore) {\r\n            // Time to start recording.\r\n            target.performanceMetrics = metrics;\r\n            timings.callbackEnabled = true;\r\n            timer.start();\r\n          }\r\n\r\n          return;\r\n        }\r\n\r\n        timer.stop();\r\n        timings.actualFps[frameCount] = metrics.frameTimings;\r\n        timings.actualFps[frameCount].set(\"Total Time\", timer.current.milliseconds);\r\n\r\n        if (++frameCount === numFrames)\r\n          target.performanceMetrics = undefined;\r\n\r\n        if (timings.gpuFramesCollected >= numFrames || (frameCount >= numFrames && !(IModelApp.renderSystem as System).isGLTimerSupported)) {\r\n          removeListener();\r\n          IModelApp.viewManager.dropViewport(vp, false);\r\n          vp.continuousRendering = false;\r\n          timings.callbackEnabled = false;\r\n          resolve();\r\n        } else {\r\n          vp.requestRedraw();\r\n          timer.start();\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  private async setupTest(context: TestContext): Promise<TestCase | undefined> {\r\n    const imodel = context.iModel;\r\n    // Open the view.\r\n    const view = await this.loadView(context);\r\n    if (!view)\r\n      return undefined;\r\n\r\n    const viewport = this.openViewport(view.view);\r\n\r\n    // Apply hypermodeling\r\n    const hyperModeling = this.curConfig.hyperModeling;\r\n    if (hyperModeling) {\r\n      try {\r\n        const decorator = await HyperModeling.start(viewport);\r\n        const marker = decorator?.markers.findMarkerById(hyperModeling.sectionDrawingLocationId);\r\n        if (!decorator) {\r\n          await this.logError(\"Failed to start hypermodeling.\");\r\n        } else if (!marker) {\r\n          await this.logError(`SectionDrawingLocation ${hyperModeling.sectionDrawingLocationId} not found.`);\r\n        } else {\r\n          if (hyperModeling.applySpatialView) {\r\n            await decorator.toggleSection(marker, true);\r\n          } else {\r\n            decorator.toggleClipVolume(marker, true);\r\n            await decorator.toggleAttachment(marker, true);\r\n          }\r\n        }\r\n      } catch (err: any) {\r\n        await DisplayPerfTestApp.logException(err, { dir: this.curConfig.outputPath, name: this._logFileName });\r\n      }\r\n    }\r\n\r\n    // Apply emphasis and hilite settings.\r\n    const config = this.curConfig;\r\n    if (config.hilite)\r\n      viewport.hilite = config.hilite;\r\n\r\n    if (config.emphasis)\r\n      viewport.emphasisSettings = config.emphasis;\r\n\r\n    // Apply display style.\r\n    if (config.displayStyle) {\r\n      const styleProps = await imodel.elements.queryProps({ from: DisplayStyleState.classFullName, where: `CodeValue='${config.displayStyle}'` });\r\n      if (styleProps.length >= 1) {\r\n        const style = new DisplayStyle3dState(styleProps[0] as DisplayStyleProps, imodel);\r\n        await style.load();\r\n        viewport.view.setDisplayStyle(style);\r\n      }\r\n    }\r\n\r\n    // Apply the view flags.\r\n    if (config.viewFlags) {\r\n      const vf = viewport.viewFlags as { [key: string]: any };\r\n      const configVf = config.viewFlags as { [key: string]: any };\r\n      for (const key of Object.keys(vf)) {\r\n        const flag = configVf[key];\r\n        if (undefined !== flag) {\r\n          if (key === \"renderMode\" && typeof flag === \"string\") {\r\n            switch (flag.toLowerCase()) {\r\n              case \"solidfill\":\r\n                vf.renderMode = RenderMode.SolidFill;\r\n                break;\r\n              case \"hiddenline\":\r\n                vf.renderMode = RenderMode.HiddenLine;\r\n                break;\r\n              case \"wireframe\":\r\n                vf.renderMode = RenderMode.Wireframe;\r\n                break;\r\n              case \"smoothshade\":\r\n                vf.renderMode = RenderMode.SmoothShade;\r\n                break;\r\n            }\r\n          } else {\r\n            vf[key] = flag;\r\n          }\r\n        } else {\r\n          configVf[key] = vf[key];\r\n        }\r\n      }\r\n    }\r\n\r\n    if (config.backgroundMap)\r\n      viewport.changeBackgroundMapProps(viewport.displayStyle.settings.backgroundMap.clone(config.backgroundMap).toJSON());\r\n\r\n    // Apply symbology overrides\r\n    if (view.elementOverrides)\r\n      OverrideProvider.override(viewport, view.elementOverrides);\r\n\r\n    // Ensure all tiles required for the view are loaded.\r\n    const result = await this.waitForTilesToLoad(viewport);\r\n\r\n    // Set selected elements after all tiles have loaded.\r\n    if (view.selectedElements) {\r\n      imodel.selectionSet.add(view.selectedElements);\r\n      viewport.markSelectionSetDirty();\r\n      viewport.renderFrame();\r\n    }\r\n\r\n    return { ...result, viewport, view };\r\n  }\r\n\r\n  private async waitForTilesToLoad(viewport: ScreenViewport): Promise<TestResult> {\r\n    const timer = new StopWatch(undefined, true);\r\n    await viewport.waitForSceneCompletion();\r\n    timer.stop();\r\n\r\n    const selectedTiles = getSelectedTileStats(viewport);\r\n    return {\r\n      tileLoadingTime: timer.current.milliseconds,\r\n      selectedTileIds: selectedTiles.ids,\r\n      numSelectedTiles: selectedTiles.count,\r\n      selectedTileGpuBytes: selectedTiles.gpuBytes,\r\n      viewedTileTreeGpuBytes: calcGpuBytes((stats) => viewport.collectStatistics(stats)),\r\n      totalGpuBytes: calcGpuBytes((stats) => {\r\n        viewport.target.renderSystem.collectStatistics(stats);\r\n        viewport.target.collectStatistics(stats);\r\n        viewport.iModel.tiles.forEachTreeOwner((owner) => owner.tileTree?.collectStatistics(stats));\r\n      }),\r\n    };\r\n  }\r\n\r\n  private openViewport(view: ViewState): ScreenViewport {\r\n    // Ensure the exact same number of pixels regardless of device pixel ratio.\r\n    const div = document.getElementById(\"imodel-viewport\") as HTMLDivElement;\r\n    const ratio = false === IModelApp.renderSystem.options.dpiAwareViewports ? 1 : (window.devicePixelRatio || 1);\r\n    const width = `${String(this.curConfig.view.width / ratio)}px`;\r\n    const height = `${String(this.curConfig.view.height / ratio)}px`;\r\n\r\n    div.style.width = width;\r\n    div.style.height = height;\r\n\r\n    const vp = ScreenViewport.create(div, view);\r\n    vp.rendersToScreen = true;\r\n\r\n    vp.canvas.style.width = width;\r\n    vp.canvas.style.height = height;\r\n\r\n    return vp;\r\n  }\r\n\r\n  private async loadViewFromSpec(spec: ViewStateSpec, context: TestContext): Promise<TestViewState | undefined> {\r\n    const className = spec.viewProps.viewDefinitionProps.classFullName;\r\n    const ctor = await context.iModel.findClassFor<typeof EntityState>(className, undefined) as typeof ViewState | undefined;\r\n    const view = ctor?.createFromProps(spec.viewProps, context.iModel);\r\n    if (!view) {\r\n      await this.logError(\"Failed to create view from spec\");\r\n      return undefined;\r\n    }\r\n\r\n    await view.load();\r\n    return {\r\n      view,\r\n      elementOverrides: spec.elementOverrides,\r\n      selectedElements: spec.selectedElements,\r\n    };\r\n  }\r\n\r\n  private async loadView(context: TestContext): Promise<TestViewState | undefined> {\r\n    // If viewStateSpec is defined, use it. If we fail to instantiate it, fail.\r\n    const config = this.curConfig;\r\n    if (config.viewStateSpec)\r\n      return this.loadViewFromSpec(config.viewStateSpec, context);\r\n\r\n    // If extViewName defined, find the matching external view. If none found, fail.\r\n    if (config.extViewName) {\r\n      const spec = context.externalSavedViews.find((x) => x.name === config.extViewName);\r\n      if (spec)\r\n        return this.loadViewFromSpec(spec, context);\r\n\r\n      await this.logError(`Failed to find external saved view ${config.extViewName}`);\r\n      return undefined;\r\n    }\r\n\r\n    // If viewName is defined, find a persistent view with that name.\r\n    const ids = await context.iModel.elements.queryIds({ from: ViewState.classFullName, where: `CodeValue='${config.viewName}'` });\r\n    for (const id of ids)\r\n      return { view: await context.iModel.views.load(id) };\r\n\r\n    // Try to find an external view matching viewName.\r\n    const extSpec = context.externalSavedViews.find((x) => x.name === config.viewName);\r\n    if (extSpec)\r\n      return this.loadViewFromSpec(extSpec, context);\r\n\r\n    await this.logError(`Failed to find persistent view ${config.viewName}`);\r\n    return undefined;\r\n  }\r\n\r\n  private updateTestNames(test: TestCase, prefix?: string, isImage = false): void {\r\n    const testNames = isImage ? this._testNamesImages : this._testNamesTimings;\r\n    const testName = this.getTestName(test, prefix, false, true);\r\n    const testNameDupes = testNames.get(testName) ?? 0;\r\n    testNames.set(testName, testNameDupes + 1);\r\n  }\r\n\r\n  private async logTest(): Promise<void> {\r\n    const testConfig = this.curConfig;\r\n    const today = new Date();\r\n    const month = (`0${(today.getMonth() + 1)}`).slice(-2);\r\n    const day = (`0${today.getDate()}`).slice(-2);\r\n    const year = today.getFullYear();\r\n    const hours = (`0${today.getHours()}`).slice(-2);\r\n    const minutes = (`0${today.getMinutes()}`).slice(-2);\r\n    const seconds = (`0${today.getSeconds()}`).slice(-2);\r\n    const outStr = `${year}-${month}-${day} ${hours}:${minutes}:${seconds}  ${testConfig.iModelName}  [${testConfig.viewName}]`;\r\n\r\n    await this.logToConsole(outStr);\r\n    return this.logToFile(outStr);\r\n  }\r\n\r\n  // Log url path for cases it is used\r\n  private async logURL(): Promise<void> {\r\n    const outStr = `  [url: ${this.curConfig.urlStr}]`;\r\n    await this.logToConsole(outStr);\r\n    return this.logToFile(outStr);\r\n  }\r\n\r\n  private async openIModel(): Promise<TestContext> {\r\n    if (this.curConfig.iModelId) {\r\n      if (process.env.IMJS_OIDC_HEADLESS) {\r\n        const token = await DisplayPerfRpcInterface.getClient().getAccessToken();\r\n        IModelApp.authorizationClient = new TestFrontendAuthorizationClient(token);\r\n      }\r\n      // Download remote iModel and its saved views\r\n      const { iModelId, iTwinId } = this.curConfig;\r\n      if (iTwinId === undefined)\r\n        throw new Error(\"Missing iTwinId for remote iModel\");\r\n      const iModel = await CheckpointConnection.openRemote(iTwinId, iModelId);\r\n      const externalSavedViews = await this._savedViewsFetcher.getSavedViews(iTwinId, iModelId, await IModelApp.getAccessToken());\r\n      return { iModel, externalSavedViews };\r\n    } else {\r\n      // Load local iModel and its saved views\r\n      const filepath = `${this.curConfig.iModelLocation}${separator}${this.curConfig.iModelName}`;\r\n      const iModel = await SnapshotConnection.openFile(filepath);\r\n\r\n      const esv = await DisplayPerfRpcInterface.getClient().readExternalSavedViews(filepath);\r\n      let externalSavedViews: ViewStateSpec[] = [];\r\n      if (esv) {\r\n        const json = JSON.parse(esv) as ViewStateSpecProps[];\r\n        externalSavedViews = json.map((x) => {\r\n          return {\r\n            name: x._name,\r\n            viewProps: JSON.parse(x._viewStatePropsString) as ViewStateProps,\r\n            elementOverrides: x._overrideElements ? JSON.parse(x._overrideElements) as ElementOverrideProps[] : undefined,\r\n            selectedElements: x._selectedElements ? JSON.parse(x._selectedElements) as Id64String | Id64Array : undefined,\r\n          };\r\n        });\r\n      }\r\n      return { iModel, externalSavedViews };\r\n    }\r\n  }\r\n\r\n  private async getIModelNames(): Promise<string[]> {\r\n    const config = this.curConfig;\r\n    if (!config.iModelName.includes(\"*\"))\r\n      return [config.iModelName];\r\n\r\n    const json = await DisplayPerfRpcInterface.getClient().getMatchingFiles(config.iModelLocation, config.iModelName);\r\n    const files = JSON.parse(json);\r\n    const iModels = [];\r\n    for (const file of files) {\r\n      if (file.endsWith(\".bim\") || file.endsWith(\".ibim\")) {\r\n        const split = file.split(/[^\\/\\\\]+/g);\r\n        const iModel = split[split.length - 1];\r\n        if (iModel)\r\n          iModels.push(iModel);\r\n      }\r\n    }\r\n\r\n    return iModels;\r\n  }\r\n\r\n  private async getViewNames(context: TestContext): Promise<string[]> {\r\n    if (!this.curConfig.viewName.includes(\"*\"))\r\n      return [this.curConfig.viewName];\r\n\r\n    let viewNames: string[] = [];\r\n    if (this.curConfig.savedViewType !== \"external\") {\r\n      const specs = await context.iModel.views.getViewList({ wantPrivate: true });\r\n      viewNames = specs.map((spec) => spec.name);\r\n    }\r\n\r\n    if (this.curConfig.savedViewType !== \"internal\" && this.curConfig.savedViewType !== \"local\")\r\n      viewNames = viewNames.concat(context.externalSavedViews.map((x) => x.name));\r\n\r\n    return viewNames.filter((view) => matchRule(view, this.curConfig.viewName ?? \"*\")).sort();\r\n  }\r\n\r\n  private async finish(): Promise<void> {\r\n    let renderData = \"\\\"End of Tests-----------\\r\\n\";\r\n    const renderComp = IModelApp.queryRenderCompatibility();\r\n    if (renderComp.userAgent) {\r\n      renderData += `Browser: ${getBrowserName(renderComp.userAgent)}\\r\\n`;\r\n      renderData += `User Agent: ${renderComp.userAgent}\\r\\n`;\r\n    }\r\n    if (renderComp.unmaskedRenderer)\r\n      renderData += `Unmasked Renderer: ${renderComp.unmaskedRenderer}\\r\\n`;\r\n\r\n    if (renderComp.unmaskedVendor)\r\n      renderData += `Unmasked Vendor: ${renderComp.unmaskedVendor}\\r\\n`;\r\n\r\n    if (renderComp.missingRequiredFeatures)\r\n      renderData += `Missing Required Features: ${renderComp.missingRequiredFeatures}\\r\\n`;\r\n\r\n    if (renderComp.missingOptionalFeatures)\r\n      renderData += `Missing Optional Features: ${renderComp.missingOptionalFeatures}\"\\r\\n`;\r\n\r\n    await DisplayPerfRpcInterface.getClient().finishCsv(renderData, this.curConfig.outputPath, this.curConfig.outputName, this.curConfig.csvFormat);\r\n    await this.logToConsole(\"Tests complete. Press Ctrl-C to exit.\");\r\n  }\r\n\r\n  private async saveCsv(row: Map<string, number | string>): Promise<void> {\r\n    const outputPath = this.curConfig.outputPath;\r\n    const outputName = this.curConfig.outputName;\r\n    const msg = JSON.stringify([...row]);\r\n    return DisplayPerfRpcInterface.getClient().saveCsv(outputPath, outputName, msg, this.curConfig.csvFormat);\r\n  }\r\n\r\n  private async logToFile(message: string, opts?: { noAppend?: boolean, noNewLine?: boolean }): Promise<void> {\r\n    if (!opts?.noNewLine)\r\n      message = `${message}\\n`;\r\n\r\n    const append = !opts?.noAppend;\r\n    return DisplayPerfRpcInterface.getClient().writeExternalFile(this.curConfig.outputPath, this._logFileName, append, message);\r\n  }\r\n\r\n  private async logToConsole(message: string): Promise<void> {\r\n    return DisplayPerfRpcInterface.getClient().consoleLog(message);\r\n  }\r\n\r\n  private async logError(message: string): Promise<void> {\r\n    const msg = `ERROR: ${message}`;\r\n    await this.logToConsole(msg);\r\n    return this.logToFile(msg);\r\n  }\r\n\r\n  private getTestName(test: TestCase, prefix?: string, isImage = false, ignoreDupes = false): string {\r\n    let testName = prefix ?? \"\";\r\n    const configs = this.curConfig;\r\n\r\n    testName += configs.iModelName.replace(/\\.[^/.]+$/, \"\");\r\n    testName += `_${configs.viewName}`;\r\n    testName += configs.displayStyle ? `_${configs.displayStyle.trim()}` : \"\";\r\n    testName = testName.replace(/[/\\\\?%*:|\"<>]/g, \"-\");\r\n\r\n    const renderMode = getRenderMode(test.viewport);\r\n    if (renderMode)\r\n      testName += `_${renderMode}`;\r\n\r\n    const vf = getViewFlagsString(test);\r\n    if (vf)\r\n      testName += `_${vf}`;\r\n\r\n    const renderOpts = getRenderOpts(configs.renderOptions);\r\n    if (renderOpts)\r\n      testName += `_${renderOpts}`;\r\n\r\n    const tileProps = configs.tileProps ? getTileProps(configs.tileProps) : undefined;\r\n    if (tileProps)\r\n      testName += `_${tileProps}`;\r\n\r\n    const map = getBackgroundMapProps(test.viewport);\r\n    if (map)\r\n      testName += `_${map}`;\r\n\r\n    const hyper = getHyperModelingProps(configs.hyperModeling);\r\n    if (hyper)\r\n      testName += `_${hyper}`;\r\n\r\n    const other = getOtherProps(test.viewport);\r\n    if (other)\r\n      testName += `_${other}`;\r\n\r\n    testName = removeOptsFromString(testName, configs.filenameOptsToIgnore);\r\n    if (!ignoreDupes) {\r\n      let testNum = isImage ? this._testNamesImages.get(testName) : this._testNamesTimings.get(testName);\r\n      if (testNum === undefined)\r\n        testNum = 0;\r\n\r\n      testName += (testNum > 1) ? (`---${testNum}`) : \"\";\r\n    }\r\n\r\n    return testName;\r\n  }\r\n\r\n  private getImageName(test: TestCase, prefix?: string): string {\r\n    const filename = `${this.getTestName(test, prefix, true)}.png`;\r\n    if (ProcessDetector.isMobileAppFrontend)\r\n      return filename; // on mobile we use device's Documents path as determined by mobile backend\r\n    return `${this.curConfig.outputPath}${separator}${filename}`;\r\n  }\r\n\r\n  private getRowData(timings: Timings, test: TestCase, pixSelectStr?: string): Map<string, number | string> {\r\n    const fixed = 4;\r\n    const configs = this.curConfig;\r\n    const rowData = new Map<string, number | string>();\r\n\r\n    rowData.set(\"iModel\", configs.iModelName);\r\n    rowData.set(\"View\", configs.viewName);\r\n\r\n    const w = test.viewport.cssPixelsToDevicePixels(configs.view.width);\r\n    const h = test.viewport.cssPixelsToDevicePixels(configs.view.height);\r\n    rowData.set(\"Screen Size\", `${w}X${h}`);\r\n\r\n    rowData.set(\"Skip & Time Renders\", `${configs.numRendersToSkip} & ${configs.numRendersToTime}`);\r\n    rowData.set(\"Display Style\", test.viewport.displayStyle.name);\r\n    rowData.set(\"Render Mode\", getRenderMode(test.viewport));\r\n    rowData.set(\"View Flags\", getViewFlagsString(test) !== \"\" ? ` ${getViewFlagsString(test)}` : \"\");\r\n    rowData.set(\"Render Options\", getRenderOpts(configs.renderOptions) !== \"\" ? ` ${getRenderOpts(configs.renderOptions)}` : \"\");\r\n\r\n    const tileProps = configs.tileProps ? getTileProps(configs.tileProps) : \"\";\r\n    rowData.set(\"Tile Props\", \"\" !== tileProps ? ` ${tileProps}` : \"\");\r\n    rowData.set(\"Bkg Map Props\", getBackgroundMapProps(test.viewport) !== \"\" ? ` ${getBackgroundMapProps(test.viewport)}` : \"\");\r\n    rowData.set(\"HyperModeling\", getHyperModelingProps(configs.hyperModeling) ?? \"\");\r\n\r\n    const other = getOtherProps(test.viewport);\r\n    if (\"\" !== other)\r\n      rowData.set(\"Other Props\", ` ${other}`);\r\n\r\n    if (pixSelectStr)\r\n      rowData.set(\"ReadPixels Selector\", ` ${pixSelectStr}`);\r\n\r\n    rowData.set(\"Test Name\", this.getTestName(test));\r\n    rowData.set(\"Browser\", getBrowserName(IModelApp.queryRenderCompatibility().userAgent));\r\n    if (!this._minimizeOutput) {\r\n      rowData.set(\"Tile Loading Time\", test.tileLoadingTime);\r\n      rowData.set(\"Num Selected Tiles\", test.numSelectedTiles);\r\n      rowData.set(\"Selected Tile GPU MB\", test.selectedTileGpuBytes / (1024 * 1024));\r\n      rowData.set(\"Tile Tree GPU MB\", test.viewedTileTreeGpuBytes / (1024 * 1024));\r\n      rowData.set(\"Total GPU MB\", test.totalGpuBytes / (1024 * 1024));\r\n    }\r\n\r\n    const setGpuData = (name: string) => {\r\n      if (name === \"CPU Total Time\")\r\n        name = \"Total\";\r\n\r\n      const gpuDataArray = timings.gpu.get(name);\r\n      if (gpuDataArray) {\r\n        let gpuSum = 0;\r\n        for (const gpuData of gpuDataArray)\r\n          gpuSum += gpuData;\r\n\r\n        rowData.set(`GPU-${name}`, gpuDataArray.length ? (gpuSum / gpuDataArray.length).toFixed(fixed) : gpuSum.toFixed(fixed));\r\n      }\r\n    };\r\n\r\n    // Calculate average timings\r\n    if (pixSelectStr) { // timing read pixels\r\n      for (const colName of timings.cpu[0].keys()) {\r\n        let sum = 0;\r\n        timings.cpu.forEach((timing) => {\r\n          const data = timing.get(colName);\r\n          sum += data ? data : 0;\r\n        });\r\n\r\n        if (!this._minimizeOutput || colName === \"CPU Total Time\") {\r\n          rowData.set(colName, (sum / timings.cpu.length).toFixed(fixed));\r\n          setGpuData(colName);\r\n        }\r\n      }\r\n    } else { // timing render frame\r\n      for (const colName of timings.actualFps[0].keys()) {\r\n        let sum = 0;\r\n        timings.actualFps.forEach((timing) => {\r\n          const data = timing.get(colName);\r\n          sum += data ? data : 0;\r\n        });\r\n\r\n        if (!this._minimizeOutput || colName === \"CPU Total Time\") {\r\n          rowData.set(colName, sum / timings.actualFps.length);\r\n          setGpuData(colName);\r\n        }\r\n      }\r\n    }\r\n\r\n    let totalTime: number;\r\n    if (rowData.get(\"Finish GPU Queue\")) { // If we can't collect GPU data, get non-interactive total time with 'Finish GPU Queue' time\r\n      totalTime = Number(rowData.get(\"CPU Total Time\")) + Number(rowData.get(\"Finish GPU Queue\"));\r\n      rowData.set(\"GPU Total Time\", totalTime);\r\n    }\r\n\r\n    // Get these values from the timings.actualFps -- timings.actualFps === timings.cpu, unless in readPixels mode\r\n    let totalRenderTime = 0;\r\n    totalTime = 0;\r\n    for (const time of timings.actualFps) {\r\n      let timing = time.get(\"CPU Total Time\");\r\n      totalRenderTime += timing ? timing : 0;\r\n      timing = time.get(\"Total Time\");\r\n      totalTime += timing ? timing : 0;\r\n    }\r\n\r\n    rowData.delete(\"Total Time\");\r\n    totalRenderTime /= timings.actualFps.length; // ie the CPU Total Time\r\n    totalTime /= timings.actualFps.length;\r\n    const disjointTimerUsed = rowData.get(\"GPU-Total\") !== undefined;\r\n    const totalGpuTime = Number(disjointTimerUsed ? rowData.get(\"GPU-Total\") : rowData.get(\"GPU Total Time\"));\r\n    const gpuTolerance = disjointTimerUsed ? 2 : 3;\r\n    const gpuBound = (totalGpuTime - totalRenderTime) > gpuTolerance;\r\n    const cpuBound = disjointTimerUsed ? (((totalRenderTime - totalGpuTime) > gpuTolerance) && (totalRenderTime > 2)) : !gpuBound;\r\n    let boundBy = \"\";\r\n    if (totalRenderTime < 2 && !gpuBound) // ie total cpu time < 2ms && !gpuBound\r\n      boundBy = \"unmeasurable\";\r\n    else if (!gpuBound && !cpuBound)\r\n      boundBy = \"unknown\";\r\n    else if (gpuBound)\r\n      boundBy = \"gpu\";\r\n    else\r\n      boundBy = \"CPU\";\r\n    if ((1000.0 / totalTime) > 59) // ie actual fps > 60fps - 1fps tolerance\r\n      boundBy += \" (vsync)\";\r\n    const totalCpuTime = totalRenderTime > 2 ? totalRenderTime : 2; // add 2ms lower bound to cpu total time for tolerance\r\n    const effectiveFps = 1000.0 / (gpuBound ? totalGpuTime : totalCpuTime);\r\n    if (disjointTimerUsed) {\r\n      rowData.set(\"GPU Total Time\", totalGpuTime.toFixed(fixed));\r\n      rowData.delete(\"GPU-Total\");\r\n    }\r\n    rowData.set(\"Bound By\", boundBy);\r\n    rowData.set(\"Effective Total Time\", gpuBound ? totalGpuTime.toFixed(fixed) : totalCpuTime.toFixed(fixed)); // This is the total gpu time if gpu bound or the total cpu time if cpu bound; times gather with running continuously\r\n    rowData.set(\"Effective FPS\", effectiveFps.toFixed(fixed));\r\n    rowData.set(\"Actual Total Time\", totalTime.toFixed(fixed));\r\n    rowData.set(\"Actual FPS\", totalTime > 0.0 ? (1000.0 / totalTime).toFixed(fixed) : \"0\");\r\n\r\n    return rowData;\r\n  }\r\n\r\n  private async createReadPixelsImages(test: TestCase, pix: Pixel.Selector, pixStr: string): Promise<void> {\r\n    const vp = test.viewport;\r\n    const canvas = vp.readImageToCanvas();\r\n    const ctx = canvas.getContext(\"2d\");\r\n    if (!ctx)\r\n      return;\r\n\r\n    const cssRect = new ViewRect(0, 0, this.curConfig.view.width, this.curConfig.view.height);\r\n    const imgWidth = vp.cssPixelsToDevicePixels(cssRect.width);\r\n    const imgHeight = vp.cssPixelsToDevicePixels(cssRect.height);\r\n\r\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n    const elemIdImgData = (pix & Pixel.Selector.Feature) ? ctx.createImageData(imgWidth, imgHeight) : undefined;\r\n    const depthImgData = (pix & Pixel.Selector.GeometryAndDistance) ? ctx.createImageData(imgWidth, imgHeight) : undefined;\r\n    const typeImgData = (pix & Pixel.Selector.GeometryAndDistance) ? ctx.createImageData(imgWidth, imgHeight) : undefined;\r\n\r\n    vp.readPixels(cssRect, pix, (pixels) => {\r\n      if (!pixels)\r\n        return;\r\n\r\n      for (let y = 0; y < imgHeight; ++y) {\r\n        for (let x = 0; x < imgWidth; ++x) {\r\n          const index = (x * 4) + (y * 4 * imgWidth);\r\n          const pixel = pixels.getPixel(x, y);\r\n\r\n          // RGB for element ID\r\n          if (elemIdImgData !== undefined) {\r\n            const elemId = Id64.getLowerUint32(pixel.elementId ? pixel.elementId : \"\");\r\n            elemIdImgData.data[index + 0] = elemId % 256;\r\n            elemIdImgData.data[index + 1] = (Math.floor(elemId / 256)) % 256;\r\n            elemIdImgData.data[index + 2] = (Math.floor(elemId / (256 ^ 2))) % 256;\r\n            elemIdImgData.data[index + 3] = 255; // Set alpha to 100% opaque\r\n          }\r\n\r\n          // RGB for Depth\r\n          if (depthImgData !== undefined) {\r\n            const distColor = pixels.getPixel(x, y).distanceFraction * 255;\r\n            depthImgData.data[index + 0] = depthImgData.data[index + 1] = depthImgData.data[index + 2] = distColor;\r\n            depthImgData.data[index + 3] = 255; // Set alpha to 100% opaque\r\n          }\r\n\r\n          // RGB for type\r\n          if (typeImgData !== undefined) {\r\n            const type = pixels.getPixel(x, y).type;\r\n            switch (type) {\r\n              case Pixel.GeometryType.None: // White\r\n                typeImgData.data[index + 0] = 255;\r\n                typeImgData.data[index + 1] = 255;\r\n                typeImgData.data[index + 2] = 255;\r\n                break;\r\n              case Pixel.GeometryType.Surface: // Red\r\n                typeImgData.data[index + 0] = 255;\r\n                typeImgData.data[index + 1] = 0;\r\n                typeImgData.data[index + 2] = 0;\r\n                break;\r\n              case Pixel.GeometryType.Linear: // Green\r\n                typeImgData.data[index + 0] = 0;\r\n                typeImgData.data[index + 1] = 255;\r\n                typeImgData.data[index + 2] = 0;\r\n                break;\r\n              case Pixel.GeometryType.Edge: // Blue\r\n                typeImgData.data[index + 0] = 0;\r\n                typeImgData.data[index + 1] = 0;\r\n                typeImgData.data[index + 2] = 255;\r\n                break;\r\n              case Pixel.GeometryType.Silhouette: // Purple\r\n                typeImgData.data[index + 0] = 255;\r\n                typeImgData.data[index + 1] = 0;\r\n                typeImgData.data[index + 2] = 255;\r\n                break;\r\n              case Pixel.GeometryType.Unknown: // Black\r\n              default:\r\n                typeImgData.data[index + 0] = 0;\r\n                typeImgData.data[index + 1] = 0;\r\n                typeImgData.data[index + 2] = 0;\r\n                break;\r\n            }\r\n\r\n            typeImgData.data[index + 3] = 255; // Set alpha to 100% opaque\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    if (elemIdImgData !== undefined) {\r\n      ctx.putImageData(elemIdImgData, 0, 0);\r\n      await savePng(this.getImageName(test, `elemId_${pixStr}_`), canvas);\r\n    }\r\n\r\n    if (depthImgData !== undefined) {\r\n      ctx.putImageData(depthImgData, 0, 0);\r\n      await savePng(this.getImageName(test, `depth_${pixStr}_`), canvas);\r\n    }\r\n\r\n    if (typeImgData !== undefined) {\r\n      ctx.putImageData(typeImgData, 0, 0);\r\n      await savePng(this.getImageName(test, `type_${pixStr}_`), canvas);\r\n    }\r\n  }\r\n\r\n  private async onException(ex: any): Promise<void> {\r\n    // We need to log here so it gets written to the file.\r\n    await DisplayPerfTestApp.logException(ex, { dir: this.curConfig.outputPath, name: this._logFileName });\r\n    if (\"terminate\" === this.curConfig.onException)\r\n      await DisplayPerfRpcInterface.getClient().terminate();\r\n  }\r\n}\r\n\r\nfunction removeOptsFromString(input: string, ignore: string[] | string | undefined): string {\r\n  if (!ignore)\r\n    return input;\r\n\r\n  let output = input;\r\n  if (!(ignore instanceof Array))\r\n    ignore = ignore.split(\" \");\r\n\r\n  ignore.forEach((del: string) => {\r\n    output = output.replace(del, \"\");\r\n  });\r\n\r\n  output = output.replace(/__+/, \"_\");\r\n  if (output[output.length - 1] === \"_\")\r\n    output = output.slice(0, output.length - 1);\r\n\r\n  return output;\r\n}\r\n\r\nfunction getRenderMode(vp: ScreenViewport): string {\r\n  switch (vp.viewFlags.renderMode) {\r\n    case RenderMode.Wireframe: return \"Wireframe\";\r\n    case RenderMode.HiddenLine: return \"HiddenLine\";\r\n    case RenderMode.SolidFill: return \"SolidFill\";\r\n    case RenderMode.SmoothShade: return \"SmoothShade\";\r\n    default: return \"\";\r\n  }\r\n}\r\n\r\nfunction getRenderOpts(opts: RenderSystem.Options): string {\r\n  let optString = \"\";\r\n  for (const propName of Object.keys(opts)) {\r\n    const key = propName as keyof RenderSystem.Options;\r\n    switch (key) {\r\n      case \"disabledExtensions\": {\r\n        const extensions = opts[key];\r\n        if (extensions) {\r\n          for (const ext of extensions) {\r\n            switch (ext) {\r\n              case \"WEBGL_draw_buffers\":\r\n                optString += \"-drawBuf\";\r\n                break;\r\n              case \"OES_element_index_uint\":\r\n                optString += \"-unsignedInt\";\r\n                break;\r\n              case \"OES_texture_float\":\r\n                optString += \"-texFloat\";\r\n                break;\r\n              case \"OES_texture_half_float\":\r\n                optString += \"-texHalfFloat\";\r\n                break;\r\n              case \"WEBGL_depth_texture\":\r\n                optString += \"-depthTex\";\r\n                break;\r\n              case \"EXT_color_buffer_float\":\r\n                optString += \"-floats\";\r\n                break;\r\n              case \"EXT_shader_texture_lod\":\r\n                optString += \"-texLod\";\r\n                break;\r\n              case \"ANGLE_instanced_arrays\":\r\n                optString += \"-instArrays\";\r\n                break;\r\n              case \"EXT_frag_depth\":\r\n                optString += \"-fragDepth\";\r\n                break;\r\n            }\r\n          }\r\n        }\r\n        break;\r\n      }\r\n      case \"displaySolarShadows\":\r\n        if (!opts[key])\r\n          optString += \"-solShd\";\r\n\r\n        break;\r\n      case \"useWebGL2\":\r\n        if (opts[key])\r\n          optString += \"+webGL2\";\r\n\r\n        break;\r\n      case \"antialiasSamples\": {\r\n        const value = opts[key];\r\n        if (undefined !== value && value > 1)\r\n          optString += `+aa${value}`;\r\n\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  return optString;\r\n}\r\n\r\nfunction getTileProps(props: TileAdmin.Props): string {\r\n  let tilePropsStr = \"\";\r\n\r\n  for (const propName of Object.keys(props)) {\r\n    const key = propName as keyof TileAdmin.Props;\r\n    switch (key) {\r\n      case \"enableInstancing\":\r\n        if (props[key])\r\n          tilePropsStr += \"+inst\";\r\n\r\n        break;\r\n      case \"disableMagnification\":\r\n        if (props[key])\r\n          tilePropsStr += \"-mag\";\r\n\r\n        break;\r\n      case \"enableIndexedEdges\":\r\n        if (!props[key])\r\n          tilePropsStr += \"-idxEdg\";\r\n\r\n        break;\r\n      case \"generateAllPolyfaceEdges\":\r\n        if (!props[key])\r\n          tilePropsStr += \"-pfEdg\";\r\n\r\n        break;\r\n    }\r\n  }\r\n\r\n  return tilePropsStr;\r\n}\r\n\r\nfunction getBackgroundMapProps(vp: ScreenViewport): string {\r\n  let bmPropsStr = \"\";\r\n  const layer = vp.displayStyle.settings.mapImagery.backgroundBase;\r\n  if (layer instanceof BaseMapLayerSettings && layer.provider) {\r\n    switch (layer.provider.name) {\r\n      case \"BingProvider\":\r\n        break;\r\n      case \"MapBoxProvider\":\r\n        bmPropsStr += \"MapBox\";\r\n        break;\r\n    }\r\n\r\n    switch (layer.provider.type) {\r\n      case BackgroundMapType.Hybrid:\r\n        break;\r\n      case BackgroundMapType.Aerial:\r\n        bmPropsStr += \"+aer\";\r\n        break;\r\n      case BackgroundMapType.Street:\r\n        bmPropsStr += \"+st\";\r\n        break;\r\n    }\r\n  }\r\n\r\n  const bmProps = vp.displayStyle.settings.backgroundMap;\r\n  if (bmProps.groundBias !== 0)\r\n    bmPropsStr += `+bias${bmProps.groundBias}`;\r\n\r\n  if (bmProps.applyTerrain)\r\n    bmPropsStr += \"+terr\";\r\n\r\n  if (bmProps.useDepthBuffer)\r\n    bmPropsStr += \"+depth\";\r\n\r\n  if (typeof (bmProps.transparency) === \"number\")\r\n    bmPropsStr += `+trans${bmProps.transparency}`;\r\n\r\n  return bmPropsStr;\r\n}\r\n\r\nfunction hiliteSettingsStr(settings: Hilite.Settings): string {\r\n  let hsStr = (settings.color.colors.r * 256 * 256 + settings.color.colors.g * 256 + settings.color.colors.b).toString(36).padStart(5, \"0\");\r\n  hsStr += (settings.silhouette * 256 * 256 + Math.round(settings.visibleRatio * 255) * 256 + Math.round(settings.hiddenRatio * 255)).toString(36).padStart(4, \"0\");\r\n  return hsStr.toUpperCase();\r\n}\r\n\r\nfunction getHyperModelingProps(props: HyperModelingProps | undefined): string | undefined {\r\n  if (!props)\r\n    return undefined;\r\n\r\n  const hm = `+hm${props.sectionDrawingLocationId}`;\r\n  return props.applySpatialView ? `${hm}+a` : hm;\r\n}\r\n\r\nfunction getOtherProps(vp: ScreenViewport): string {\r\n  let propsStr = \"\";\r\n  if (!Hilite.equalSettings(vp.hilite, defaultHilite))\r\n    propsStr += `+h${hiliteSettingsStr(vp.hilite)}`;\r\n\r\n  if (!Hilite.equalSettings(vp.emphasisSettings, defaultEmphasis))\r\n    propsStr += `+e${hiliteSettingsStr(vp.emphasisSettings)}`;\r\n\r\n  return propsStr;\r\n}\r\n\r\nconst viewFlagsPropsStrings = {\r\n  dimensions: \"-dim\",\r\n  patterns: \"-pat\",\r\n  weights: \"-wt\",\r\n  styles: \"-sty\",\r\n  transparency: \"-trn\",\r\n  fill: \"-fll\",\r\n  textures: \"-txt\",\r\n  materials: \"-mat\",\r\n  visibleEdges: \"+vsE\",\r\n  hiddenEdges: \"+hdE\",\r\n  shadows: \"+shd\",\r\n  clipVolume: \"-clp\",\r\n  constructions: \"+con\",\r\n  monochrome: \"+mno\",\r\n  backgroundMap: \"+bkg\",\r\n  ambientOcclusion: \"+ao\",\r\n  forceSurfaceDiscard: \"+fsd\",\r\n  thematicDisplay: \"+thematicDisplay\",\r\n  grid: \"+grid\",\r\n  whiteOnWhiteReversal: \"+wow\",\r\n  acsTriad: \"+acsTriad\",\r\n  wiremesh: \"+wm\",\r\n};\r\n\r\nfunction getViewFlagsString(test: TestCase): string {\r\n  let vfString = \"\";\r\n\r\n  // Lighting flag always comes first.\r\n  const vf = test.viewport.viewFlags;\r\n  if (vf.lighting && RenderMode.SmoothShade === vf.renderMode)\r\n    vfString = \"+lit\";\r\n\r\n  for (const propName of Object.keys(vf)) {\r\n    const key = propName as keyof typeof viewFlagsPropsStrings;\r\n    const abbrev = viewFlagsPropsStrings[key];\r\n    if (!abbrev)\r\n      continue;\r\n\r\n    assert(\"-\" === abbrev[0] || \"+\" === abbrev[0]);\r\n    const includeIf = \"+\" === abbrev[0];\r\n    if (vf[key] === includeIf)\r\n      vfString += abbrev;\r\n  }\r\n\r\n  if (undefined !== test.view.elementOverrides)\r\n    vfString += \"+ovrEl\";\r\n\r\n  if (undefined !== test.view.selectedElements)\r\n    vfString += \"+selEl\";\r\n\r\n  return vfString;\r\n}\r\n\r\nfunction getBrowserName(userAgent: string): string {\r\n  const lowUserAgent = userAgent.toLowerCase();\r\n  if (lowUserAgent.includes(\"electron\"))\r\n    return \"Electron\";\r\n  if (lowUserAgent.includes(\"firefox\"))\r\n    return \"FireFox\";\r\n  if (lowUserAgent.includes(\"edge\"))\r\n    return \"Edge\";\r\n  if (lowUserAgent.includes(\"chrome\") && !userAgent.includes(\"chromium\"))\r\n    return \"Chrome\";\r\n  if (lowUserAgent.includes(\"safari\") && !userAgent.includes(\"chrome\") && !userAgent.includes(\"chromium\"))\r\n    return \"Safari\";\r\n  return \"Unknown\";\r\n}\r\n\r\n/** See https://stackoverflow.com/questions/26246601/wildcard-string-comparison-in-javascript\r\n * Compare strToTest with a given rule containing a wildcard, and will return true if strToTest matches the given wildcard\r\n * Make sure it is case-insensitive\r\n */\r\nfunction matchRule(strToTest: string, rule: string) {\r\n  strToTest = strToTest.toLowerCase();\r\n  rule = rule.toLowerCase();\r\n  const escapeRegex = (str: string) => str.replace(/([.*+?^=!:${}()|\\[\\]\\/\\\\])/g, \"\\\\$1\");\r\n  return new RegExp(`^${rule.split(\"*\").map(escapeRegex).join(\".*\")}$`).test(strToTest);\r\n}\r\n\r\ninterface SelectedTileStats {\r\n  /* A formatted string containing the Ids of all the tiles that were selected for display by the last call to waitForTilesToLoad(), of the format:\r\n   *  Selected Tiles:\r\n   *    TreeId1: tileId1,tileId2,...\r\n   *    TreeId2: tileId1,tileId2,...\r\n   *    ...\r\n   * Sorted by tree Id and then by tile Id so that the output is consistent from run to run unless the set of selected tiles changed between runs.\r\n   */\r\n  ids: string;\r\n  /** The number of selected tiles. */\r\n  count: number;\r\n  /** The number of bytes of memory allocated to the GPU for the selected tiles' graphics. */\r\n  gpuBytes: number;\r\n}\r\n\r\nfunction getSelectedTileStats(vp: ScreenViewport): SelectedTileStats {\r\n  let formattedSelectedTileIds = \"Selected tiles:\\n\";\r\n  let count = 0;\r\n  const mem = new RenderMemory.Statistics();\r\n  const dict = new Dictionary<string, SortedArray<string>>((lhs, rhs) => lhs.localeCompare(rhs));\r\n  for (const viewport of [vp, ...vp.view.secondaryViewports]) {\r\n    const selected = IModelApp.tileAdmin.getTilesForUser(viewport)?.selected;\r\n    if (!selected)\r\n      continue;\r\n\r\n    count += selected.size;\r\n    for (const tile of selected) {\r\n      const treeId = tile.tree.id;\r\n      let tileIds = dict.get(treeId);\r\n      if (!tileIds)\r\n        dict.set(treeId, tileIds = new SortedArray<string>((lhs, rhs) => lhs.localeCompare(rhs)));\r\n\r\n      tileIds.insert(tile.contentId);\r\n      tile.collectStatistics(mem);\r\n    }\r\n  }\r\n\r\n  for (const kvp of dict) {\r\n    const contentIds = kvp.value.extractArray().join(\",\");\r\n    const line = `  ${kvp.key}: ${contentIds}`;\r\n    formattedSelectedTileIds = `${formattedSelectedTileIds}${line}\\n`;\r\n  }\r\n\r\n  return {\r\n    ids: formattedSelectedTileIds,\r\n    count,\r\n    gpuBytes: mem.totalBytes,\r\n  };\r\n}\r\n\r\nfunction calcGpuBytes(func: (stats: RenderMemory.Statistics) => void): number {\r\n  const stats = new RenderMemory.Statistics();\r\n  func(stats);\r\n  return stats.totalBytes;\r\n}\r\n\r\nasync function savePng(fileName: string, canvas: HTMLCanvasElement): Promise<void> {\r\n  const img = canvas.toDataURL(\"image/png\");\r\n  const data = img.replace(/^data:image\\/\\w+;base64,/, \"\"); // strip off the data: url prefix to get just the base64-encoded bytes\r\n  return DisplayPerfRpcInterface.getClient().savePng(fileName, data);\r\n}\r\n\r\nfunction setPerformanceMetrics(vp: ScreenViewport, metrics: PerformanceMetrics | undefined): void {\r\n  (vp.target as Target).performanceMetrics = metrics;\r\n}\r\n",
      "start": 1693508118232,
      "end": 1693508118470,
      "sourcemaps": null
    },
    {
      "name": "vite:esbuild",
      "result": "\"use strict\";\nimport { RealityDataAccessClient } from \"@itwin/reality-data-client\";\nimport {\n  assert,\n  Dictionary,\n  Id64,\n  ProcessDetector,\n  SortedArray,\n  StopWatch\n} from \"@itwin/core-bentley\";\nimport {\n  BackgroundMapType,\n  BaseMapLayerSettings,\n  FeatureAppearance,\n  Hilite,\n  RenderMode\n} from \"@itwin/core-common\";\nimport {\n  CheckpointConnection,\n  DisplayStyle3dState,\n  DisplayStyleState,\n  IModelApp,\n  PerformanceMetrics,\n  Pixel,\n  RenderMemory,\n  ScreenViewport,\n  SnapshotConnection,\n  ToolAdmin,\n  ViewRect,\n  ViewState\n} from \"@itwin/core-frontend\";\nimport { HyperModeling } from \"@itwin/hypermodeling-frontend\";\nimport { TestFrontendAuthorizationClient } from \"@itwin/oidc-signin-tool/lib/cjs/TestFrontendAuthorizationClient\";\nimport DisplayPerfRpcInterface from \"../common/DisplayPerfRpcInterface\";\nimport { DisplayPerfTestApp } from \"./DisplayPerformanceTestApp\";\nimport {\n  defaultEmphasis,\n  defaultHilite,\n  separator,\n  TestConfig,\n  TestConfigStack\n} from \"./TestConfig\";\nimport { SavedViewsFetcher } from \"./SavedViewsFetcher\";\nclass Timings {\n  constructor(numFramesToCollect) {\n    this.cpu = new Array();\n    this.gpu = /* @__PURE__ */ new Map();\n    this.actualFps = new Array();\n    this.gpuFramesCollected = 0;\n    this.callback = (result) => {\n      if (this.gpuFramesCollected >= numFramesToCollect)\n        return;\n      const label = result.label;\n      const timings = this.gpu.get(label);\n      this.gpu.set(label, timings ? timings.concat(result.nanoseconds / 1e6) : [result.nanoseconds / 1e6]);\n      if (result.children)\n        for (const child of result.children)\n          this.callback(child);\n      if (\"Total\" === label)\n        ++this.gpuFramesCollected;\n    };\n  }\n  set callbackEnabled(enabled) {\n    IModelApp.renderSystem.debugControl.resultsCallback = enabled ? this.callback : void 0;\n  }\n}\nclass OverrideProvider {\n  constructor(ovrs) {\n    this._elementOvrs = /* @__PURE__ */ new Map();\n    for (const ovr of ovrs) {\n      const app = FeatureAppearance.fromJSON(JSON.parse(ovr.fsa));\n      if (ovr.id === \"-default-\")\n        this._defaultOvrs = app;\n      else\n        this._elementOvrs.set(ovr.id, app);\n    }\n  }\n  static override(vp, ovrs) {\n    const provider = new OverrideProvider(ovrs);\n    vp.addFeatureOverrideProvider(provider);\n  }\n  addFeatureOverrides(ovrs) {\n    if (this._defaultOvrs)\n      ovrs.setDefaultOverrides(this._defaultOvrs);\n    for (const [elementId, appearance] of this._elementOvrs)\n      ovrs.override({ elementId, appearance });\n  }\n}\nexport class TestRunner {\n  constructor(props, savedViewsFetcher = new SavedViewsFetcher()) {\n    this._testNamesImages = /* @__PURE__ */ new Map();\n    this._testNamesTimings = /* @__PURE__ */ new Map();\n    const defaultTileProps = { minimumSpatialTolerance: 0 };\n    props.tileProps = props.tileProps ? { ...defaultTileProps, ...props.tileProps } : defaultTileProps;\n    this._config = new TestConfigStack(new TestConfig(props));\n    this._lastRestartConfig = this.curConfig;\n    this._testSets = props.testSet;\n    this._minimizeOutput = true === props.minimize;\n    this._logFileName = \"_DispPerfTestAppViewLog.txt\";\n    this._savedViewsFetcher = savedViewsFetcher;\n    ToolAdmin.exceptionHandler = async (ex) => this.onException(ex);\n  }\n  get curConfig() {\n    return this._config.top;\n  }\n  get lastRestartConfig() {\n    return this._lastRestartConfig;\n  }\n  set lastRestartConfig(config) {\n    this._lastRestartConfig = config;\n  }\n  /** Run all the tests. */\n  async run() {\n    const msg = `View Log,  Model Base Location: ${this.curConfig.iModelLocation}\n  format: Time_started  ModelName  [ViewName]`;\n    await this.logToConsole(msg);\n    await this.logToFile(msg, { noAppend: true });\n    let needRestart = this.curConfig.requiresRestart(new TestConfig({}));\n    const renderOptions = this.curConfig.renderOptions ?? {};\n    if (!this.curConfig.useDisjointTimer) {\n      const ext = this.curConfig.renderOptions?.disabledExtensions;\n      renderOptions.disabledExtensions = Array.isArray(ext) ? ext.concat([\"EXT_disjoint_timer_query\", \"EXT_disjoint_timer_query_webgl2\"]) : [\"EXT_disjoint_timer_query\", \"EXT_disjoint_timer_query_webgl2\"];\n      needRestart = true;\n    }\n    if (IModelApp.initialized && needRestart) {\n      await IModelApp.shutdown();\n    }\n    if (!IModelApp.initialized) {\n      const realityDataClientOptions = {\n        /** API Version. v1 by default */\n        // version?: ApiVersion;\n        /** API Url. Used to select environment. Defaults to \"https://api.bentley.com/realitydata\" */\n        baseUrl: `https://${process.env.IMJS_URL_PREFIX}api.bentley.com/realitydata`\n      };\n      await DisplayPerfTestApp.startup({\n        renderSys: renderOptions,\n        tileAdmin: this.curConfig.tileProps,\n        realityDataAccess: new RealityDataAccessClient(realityDataClientOptions)\n      });\n    }\n    this.lastRestartConfig = this.curConfig;\n    for (const set of this._testSets)\n      await this.runTestSet(set);\n    const topdiv = document.getElementById(\"topdiv\");\n    topdiv.style.display = \"block\";\n    topdiv.innerText = \"Tests Completed.\";\n    document.getElementById(\"imodel-viewport\").style.display = \"hidden\";\n    await this.finish();\n  }\n  async runTestSet(set) {\n    this._config.push(set);\n    const realityDataClientOptions = {\n      /** API Version. v1 by default */\n      // version?: ApiVersion;\n      /** API Url. Used to select environment. Defaults to \"https://api.bentley.com/realitydata\" */\n      baseUrl: `https://${process.env.IMJS_URL_PREFIX}api.bentley.com/realitydata`\n    };\n    for (const testProps of set.tests) {\n      this._config.push(testProps);\n      if (IModelApp.initialized && this.curConfig.requiresRestart(this.lastRestartConfig)) {\n        await IModelApp.shutdown();\n      }\n      if (!IModelApp.initialized) {\n        const renderOptions = this.curConfig.renderOptions ?? {};\n        if (!this.curConfig.useDisjointTimer) {\n          const ext = this.curConfig.renderOptions?.disabledExtensions;\n          renderOptions.disabledExtensions = Array.isArray(ext) ? ext.concat([\"EXT_disjoint_timer_query\", \"EXT_disjoint_timer_query_webgl2\"]) : [\"EXT_disjoint_timer_query\", \"EXT_disjoint_timer_query_webgl2\"];\n        }\n        await DisplayPerfTestApp.startup({\n          renderSys: renderOptions,\n          tileAdmin: this.curConfig.tileProps,\n          realityDataAccess: new RealityDataAccessClient(realityDataClientOptions)\n        });\n        this.lastRestartConfig = this.curConfig;\n      }\n      const iModelNames = await this.getIModelNames();\n      const originalViewName = this.curConfig.viewName;\n      for (const iModelName of iModelNames) {\n        this.curConfig.iModelName = iModelName;\n        this.curConfig.viewName = originalViewName;\n        let context;\n        try {\n          context = await this.openIModel();\n        } catch (e) {\n          await this.logError(`Failed to open iModel ${iModelName}: ${e.message}`);\n          continue;\n        }\n        try {\n          await this.runTests(context);\n        } catch {\n          await this.logError(`Failed to run tests on iModel ${iModelName}`);\n        } finally {\n          await context.iModel.close();\n        }\n      }\n      this._config.pop();\n    }\n    this._config.pop();\n  }\n  async runTests(context) {\n    const viewNames = await this.getViewNames(context);\n    for (const viewName of viewNames) {\n      this.curConfig.viewName = viewName;\n      await this.logTest();\n      try {\n        this.curConfig.urlStr = void 0;\n        const result = await this.runTest(context);\n        if (this.curConfig.urlStr)\n          await this.logURL();\n        if (result)\n          await this.logToFile(result.selectedTileIds, { noNewLine: true });\n      } catch (ex) {\n        await this.onException(ex);\n      }\n    }\n  }\n  async runTest(context) {\n    const testConfig = this.curConfig;\n    document.title = \"Display Performance Test App:  \".concat(testConfig.iModelName ?? \"\", \"  [\", testConfig.viewName ?? \"\", \"]\");\n    const test = await this.setupTest(context);\n    if (!test)\n      return void 0;\n    const vp = test.viewport;\n    if (testConfig.testType === \"image\" || testConfig.testType === \"both\") {\n      this.updateTestNames(test, void 0, true);\n      const canvas = vp.readImageToCanvas();\n      await savePng(this.getImageName(test), canvas);\n      if (testConfig.testType === \"image\") {\n        vp.dispose();\n        return test;\n      }\n    }\n    for (let i = 0; i < this.curConfig.numRendersToSkip; i++) {\n      vp.requestRedraw();\n      vp.renderFrame();\n    }\n    this.updateTestNames(test);\n    await (testConfig.testType === \"readPixels\" ? this.recordReadPixels(test) : this.recordRender(test));\n    vp.dispose();\n    return test;\n  }\n  async recordReadPixels(test) {\n    const vp = test.viewport;\n    const viewRect = new ViewRect(0, 0, this.curConfig.view.width, this.curConfig.view.height);\n    const timings = new Timings(this.curConfig.numRendersToTime);\n    const testReadPix = async (pixSelect, pixSelectStr) => {\n      setPerformanceMetrics(vp, new PerformanceMetrics(true, false, void 0));\n      for (let i = 0; i < this.curConfig.numRendersToTime; ++i) {\n        vp.readPixels(viewRect, pixSelect, () => {\n        });\n        timings.cpu[i] = vp.target.performanceMetrics.frameTimings;\n        timings.cpu[i].delete(\"Scene Time\");\n      }\n      timings.gpuFramesCollected = 0;\n      timings.callbackEnabled = true;\n      setPerformanceMetrics(vp, new PerformanceMetrics(true, false, timings.callback));\n      await this.renderAsync(vp, this.curConfig.numRendersToTime, timings);\n      timings.callbackEnabled = false;\n      this.updateTestNames(test, pixSelectStr, true);\n      this.updateTestNames(test, pixSelectStr, false);\n      const row = this.getRowData(timings, test, pixSelectStr);\n      await this.saveCsv(row);\n      await this.createReadPixelsImages(test, pixSelect, pixSelectStr);\n    };\n    await testReadPix(Pixel.Selector.Feature, \"+feature\");\n    await testReadPix(Pixel.Selector.GeometryAndDistance, \"+geom+dist\");\n    await testReadPix(Pixel.Selector.All, \"+feature+geom+dist\");\n  }\n  async recordRender(test) {\n    const timings = new Timings(this.curConfig.numRendersToTime);\n    setPerformanceMetrics(test.viewport, new PerformanceMetrics(true, false, timings.callback));\n    await this.renderAsync(test.viewport, this.curConfig.numRendersToTime, timings);\n    const row = this.getRowData(timings, test);\n    await this.saveCsv(row);\n  }\n  async renderAsync(vp, numFrames, timings) {\n    IModelApp.viewManager.addViewport(vp);\n    const target = vp.target;\n    const metrics = target.performanceMetrics;\n    assert(void 0 !== metrics);\n    target.performanceMetrics = void 0;\n    timings.callbackEnabled = false;\n    const numFramesToIgnore = 120;\n    let ignoreFrameCount = 0;\n    let frameCount = 0;\n    vp.continuousRendering = true;\n    return new Promise((resolve, _reject) => {\n      const timer = new StopWatch();\n      const removeListener = vp.onRender.addListener(() => {\n        if (++ignoreFrameCount <= numFramesToIgnore) {\n          if (ignoreFrameCount === numFramesToIgnore) {\n            target.performanceMetrics = metrics;\n            timings.callbackEnabled = true;\n            timer.start();\n          }\n          return;\n        }\n        timer.stop();\n        timings.actualFps[frameCount] = metrics.frameTimings;\n        timings.actualFps[frameCount].set(\"Total Time\", timer.current.milliseconds);\n        if (++frameCount === numFrames)\n          target.performanceMetrics = void 0;\n        if (timings.gpuFramesCollected >= numFrames || frameCount >= numFrames && !IModelApp.renderSystem.isGLTimerSupported) {\n          removeListener();\n          IModelApp.viewManager.dropViewport(vp, false);\n          vp.continuousRendering = false;\n          timings.callbackEnabled = false;\n          resolve();\n        } else {\n          vp.requestRedraw();\n          timer.start();\n        }\n      });\n    });\n  }\n  async setupTest(context) {\n    const imodel = context.iModel;\n    const view = await this.loadView(context);\n    if (!view)\n      return void 0;\n    const viewport = this.openViewport(view.view);\n    const hyperModeling = this.curConfig.hyperModeling;\n    if (hyperModeling) {\n      try {\n        const decorator = await HyperModeling.start(viewport);\n        const marker = decorator?.markers.findMarkerById(hyperModeling.sectionDrawingLocationId);\n        if (!decorator) {\n          await this.logError(\"Failed to start hypermodeling.\");\n        } else if (!marker) {\n          await this.logError(`SectionDrawingLocation ${hyperModeling.sectionDrawingLocationId} not found.`);\n        } else {\n          if (hyperModeling.applySpatialView) {\n            await decorator.toggleSection(marker, true);\n          } else {\n            decorator.toggleClipVolume(marker, true);\n            await decorator.toggleAttachment(marker, true);\n          }\n        }\n      } catch (err) {\n        await DisplayPerfTestApp.logException(err, { dir: this.curConfig.outputPath, name: this._logFileName });\n      }\n    }\n    const config = this.curConfig;\n    if (config.hilite)\n      viewport.hilite = config.hilite;\n    if (config.emphasis)\n      viewport.emphasisSettings = config.emphasis;\n    if (config.displayStyle) {\n      const styleProps = await imodel.elements.queryProps({ from: DisplayStyleState.classFullName, where: `CodeValue='${config.displayStyle}'` });\n      if (styleProps.length >= 1) {\n        const style = new DisplayStyle3dState(styleProps[0], imodel);\n        await style.load();\n        viewport.view.setDisplayStyle(style);\n      }\n    }\n    if (config.viewFlags) {\n      const vf = viewport.viewFlags;\n      const configVf = config.viewFlags;\n      for (const key of Object.keys(vf)) {\n        const flag = configVf[key];\n        if (void 0 !== flag) {\n          if (key === \"renderMode\" && typeof flag === \"string\") {\n            switch (flag.toLowerCase()) {\n              case \"solidfill\":\n                vf.renderMode = RenderMode.SolidFill;\n                break;\n              case \"hiddenline\":\n                vf.renderMode = RenderMode.HiddenLine;\n                break;\n              case \"wireframe\":\n                vf.renderMode = RenderMode.Wireframe;\n                break;\n              case \"smoothshade\":\n                vf.renderMode = RenderMode.SmoothShade;\n                break;\n            }\n          } else {\n            vf[key] = flag;\n          }\n        } else {\n          configVf[key] = vf[key];\n        }\n      }\n    }\n    if (config.backgroundMap)\n      viewport.changeBackgroundMapProps(viewport.displayStyle.settings.backgroundMap.clone(config.backgroundMap).toJSON());\n    if (view.elementOverrides)\n      OverrideProvider.override(viewport, view.elementOverrides);\n    const result = await this.waitForTilesToLoad(viewport);\n    if (view.selectedElements) {\n      imodel.selectionSet.add(view.selectedElements);\n      viewport.markSelectionSetDirty();\n      viewport.renderFrame();\n    }\n    return { ...result, viewport, view };\n  }\n  async waitForTilesToLoad(viewport) {\n    const timer = new StopWatch(void 0, true);\n    await viewport.waitForSceneCompletion();\n    timer.stop();\n    const selectedTiles = getSelectedTileStats(viewport);\n    return {\n      tileLoadingTime: timer.current.milliseconds,\n      selectedTileIds: selectedTiles.ids,\n      numSelectedTiles: selectedTiles.count,\n      selectedTileGpuBytes: selectedTiles.gpuBytes,\n      viewedTileTreeGpuBytes: calcGpuBytes((stats) => viewport.collectStatistics(stats)),\n      totalGpuBytes: calcGpuBytes((stats) => {\n        viewport.target.renderSystem.collectStatistics(stats);\n        viewport.target.collectStatistics(stats);\n        viewport.iModel.tiles.forEachTreeOwner((owner) => owner.tileTree?.collectStatistics(stats));\n      })\n    };\n  }\n  openViewport(view) {\n    const div = document.getElementById(\"imodel-viewport\");\n    const ratio = false === IModelApp.renderSystem.options.dpiAwareViewports ? 1 : window.devicePixelRatio || 1;\n    const width = `${String(this.curConfig.view.width / ratio)}px`;\n    const height = `${String(this.curConfig.view.height / ratio)}px`;\n    div.style.width = width;\n    div.style.height = height;\n    const vp = ScreenViewport.create(div, view);\n    vp.rendersToScreen = true;\n    vp.canvas.style.width = width;\n    vp.canvas.style.height = height;\n    return vp;\n  }\n  async loadViewFromSpec(spec, context) {\n    const className = spec.viewProps.viewDefinitionProps.classFullName;\n    const ctor = await context.iModel.findClassFor(className, void 0);\n    const view = ctor?.createFromProps(spec.viewProps, context.iModel);\n    if (!view) {\n      await this.logError(\"Failed to create view from spec\");\n      return void 0;\n    }\n    await view.load();\n    return {\n      view,\n      elementOverrides: spec.elementOverrides,\n      selectedElements: spec.selectedElements\n    };\n  }\n  async loadView(context) {\n    const config = this.curConfig;\n    if (config.viewStateSpec)\n      return this.loadViewFromSpec(config.viewStateSpec, context);\n    if (config.extViewName) {\n      const spec = context.externalSavedViews.find((x) => x.name === config.extViewName);\n      if (spec)\n        return this.loadViewFromSpec(spec, context);\n      await this.logError(`Failed to find external saved view ${config.extViewName}`);\n      return void 0;\n    }\n    const ids = await context.iModel.elements.queryIds({ from: ViewState.classFullName, where: `CodeValue='${config.viewName}'` });\n    for (const id of ids)\n      return { view: await context.iModel.views.load(id) };\n    const extSpec = context.externalSavedViews.find((x) => x.name === config.viewName);\n    if (extSpec)\n      return this.loadViewFromSpec(extSpec, context);\n    await this.logError(`Failed to find persistent view ${config.viewName}`);\n    return void 0;\n  }\n  updateTestNames(test, prefix, isImage = false) {\n    const testNames = isImage ? this._testNamesImages : this._testNamesTimings;\n    const testName = this.getTestName(test, prefix, false, true);\n    const testNameDupes = testNames.get(testName) ?? 0;\n    testNames.set(testName, testNameDupes + 1);\n  }\n  async logTest() {\n    const testConfig = this.curConfig;\n    const today = /* @__PURE__ */ new Date();\n    const month = `0${today.getMonth() + 1}`.slice(-2);\n    const day = `0${today.getDate()}`.slice(-2);\n    const year = today.getFullYear();\n    const hours = `0${today.getHours()}`.slice(-2);\n    const minutes = `0${today.getMinutes()}`.slice(-2);\n    const seconds = `0${today.getSeconds()}`.slice(-2);\n    const outStr = `${year}-${month}-${day} ${hours}:${minutes}:${seconds}  ${testConfig.iModelName}  [${testConfig.viewName}]`;\n    await this.logToConsole(outStr);\n    return this.logToFile(outStr);\n  }\n  // Log url path for cases it is used\n  async logURL() {\n    const outStr = `  [url: ${this.curConfig.urlStr}]`;\n    await this.logToConsole(outStr);\n    return this.logToFile(outStr);\n  }\n  async openIModel() {\n    if (this.curConfig.iModelId) {\n      if (process.env.IMJS_OIDC_HEADLESS) {\n        const token = await DisplayPerfRpcInterface.getClient().getAccessToken();\n        IModelApp.authorizationClient = new TestFrontendAuthorizationClient(token);\n      }\n      const { iModelId, iTwinId } = this.curConfig;\n      if (iTwinId === void 0)\n        throw new Error(\"Missing iTwinId for remote iModel\");\n      const iModel = await CheckpointConnection.openRemote(iTwinId, iModelId);\n      const externalSavedViews = await this._savedViewsFetcher.getSavedViews(iTwinId, iModelId, await IModelApp.getAccessToken());\n      return { iModel, externalSavedViews };\n    } else {\n      const filepath = `${this.curConfig.iModelLocation}${separator}${this.curConfig.iModelName}`;\n      const iModel = await SnapshotConnection.openFile(filepath);\n      const esv = await DisplayPerfRpcInterface.getClient().readExternalSavedViews(filepath);\n      let externalSavedViews = [];\n      if (esv) {\n        const json = JSON.parse(esv);\n        externalSavedViews = json.map((x) => {\n          return {\n            name: x._name,\n            viewProps: JSON.parse(x._viewStatePropsString),\n            elementOverrides: x._overrideElements ? JSON.parse(x._overrideElements) : void 0,\n            selectedElements: x._selectedElements ? JSON.parse(x._selectedElements) : void 0\n          };\n        });\n      }\n      return { iModel, externalSavedViews };\n    }\n  }\n  async getIModelNames() {\n    const config = this.curConfig;\n    if (!config.iModelName.includes(\"*\"))\n      return [config.iModelName];\n    const json = await DisplayPerfRpcInterface.getClient().getMatchingFiles(config.iModelLocation, config.iModelName);\n    const files = JSON.parse(json);\n    const iModels = [];\n    for (const file of files) {\n      if (file.endsWith(\".bim\") || file.endsWith(\".ibim\")) {\n        const split = file.split(/[^\\/\\\\]+/g);\n        const iModel = split[split.length - 1];\n        if (iModel)\n          iModels.push(iModel);\n      }\n    }\n    return iModels;\n  }\n  async getViewNames(context) {\n    if (!this.curConfig.viewName.includes(\"*\"))\n      return [this.curConfig.viewName];\n    let viewNames = [];\n    if (this.curConfig.savedViewType !== \"external\") {\n      const specs = await context.iModel.views.getViewList({ wantPrivate: true });\n      viewNames = specs.map((spec) => spec.name);\n    }\n    if (this.curConfig.savedViewType !== \"internal\" && this.curConfig.savedViewType !== \"local\")\n      viewNames = viewNames.concat(context.externalSavedViews.map((x) => x.name));\n    return viewNames.filter((view) => matchRule(view, this.curConfig.viewName ?? \"*\")).sort();\n  }\n  async finish() {\n    let renderData = '\"End of Tests-----------\\r\\n';\n    const renderComp = IModelApp.queryRenderCompatibility();\n    if (renderComp.userAgent) {\n      renderData += `Browser: ${getBrowserName(renderComp.userAgent)}\\r\n`;\n      renderData += `User Agent: ${renderComp.userAgent}\\r\n`;\n    }\n    if (renderComp.unmaskedRenderer)\n      renderData += `Unmasked Renderer: ${renderComp.unmaskedRenderer}\\r\n`;\n    if (renderComp.unmaskedVendor)\n      renderData += `Unmasked Vendor: ${renderComp.unmaskedVendor}\\r\n`;\n    if (renderComp.missingRequiredFeatures)\n      renderData += `Missing Required Features: ${renderComp.missingRequiredFeatures}\\r\n`;\n    if (renderComp.missingOptionalFeatures)\n      renderData += `Missing Optional Features: ${renderComp.missingOptionalFeatures}\"\\r\n`;\n    await DisplayPerfRpcInterface.getClient().finishCsv(renderData, this.curConfig.outputPath, this.curConfig.outputName, this.curConfig.csvFormat);\n    await this.logToConsole(\"Tests complete. Press Ctrl-C to exit.\");\n  }\n  async saveCsv(row) {\n    const outputPath = this.curConfig.outputPath;\n    const outputName = this.curConfig.outputName;\n    const msg = JSON.stringify([...row]);\n    return DisplayPerfRpcInterface.getClient().saveCsv(outputPath, outputName, msg, this.curConfig.csvFormat);\n  }\n  async logToFile(message, opts) {\n    if (!opts?.noNewLine)\n      message = `${message}\n`;\n    const append = !opts?.noAppend;\n    return DisplayPerfRpcInterface.getClient().writeExternalFile(this.curConfig.outputPath, this._logFileName, append, message);\n  }\n  async logToConsole(message) {\n    return DisplayPerfRpcInterface.getClient().consoleLog(message);\n  }\n  async logError(message) {\n    const msg = `ERROR: ${message}`;\n    await this.logToConsole(msg);\n    return this.logToFile(msg);\n  }\n  getTestName(test, prefix, isImage = false, ignoreDupes = false) {\n    let testName = prefix ?? \"\";\n    const configs = this.curConfig;\n    testName += configs.iModelName.replace(/\\.[^/.]+$/, \"\");\n    testName += `_${configs.viewName}`;\n    testName += configs.displayStyle ? `_${configs.displayStyle.trim()}` : \"\";\n    testName = testName.replace(/[/\\\\?%*:|\"<>]/g, \"-\");\n    const renderMode = getRenderMode(test.viewport);\n    if (renderMode)\n      testName += `_${renderMode}`;\n    const vf = getViewFlagsString(test);\n    if (vf)\n      testName += `_${vf}`;\n    const renderOpts = getRenderOpts(configs.renderOptions);\n    if (renderOpts)\n      testName += `_${renderOpts}`;\n    const tileProps = configs.tileProps ? getTileProps(configs.tileProps) : void 0;\n    if (tileProps)\n      testName += `_${tileProps}`;\n    const map = getBackgroundMapProps(test.viewport);\n    if (map)\n      testName += `_${map}`;\n    const hyper = getHyperModelingProps(configs.hyperModeling);\n    if (hyper)\n      testName += `_${hyper}`;\n    const other = getOtherProps(test.viewport);\n    if (other)\n      testName += `_${other}`;\n    testName = removeOptsFromString(testName, configs.filenameOptsToIgnore);\n    if (!ignoreDupes) {\n      let testNum = isImage ? this._testNamesImages.get(testName) : this._testNamesTimings.get(testName);\n      if (testNum === void 0)\n        testNum = 0;\n      testName += testNum > 1 ? `---${testNum}` : \"\";\n    }\n    return testName;\n  }\n  getImageName(test, prefix) {\n    const filename = `${this.getTestName(test, prefix, true)}.png`;\n    if (ProcessDetector.isMobileAppFrontend)\n      return filename;\n    return `${this.curConfig.outputPath}${separator}${filename}`;\n  }\n  getRowData(timings, test, pixSelectStr) {\n    const fixed = 4;\n    const configs = this.curConfig;\n    const rowData = /* @__PURE__ */ new Map();\n    rowData.set(\"iModel\", configs.iModelName);\n    rowData.set(\"View\", configs.viewName);\n    const w = test.viewport.cssPixelsToDevicePixels(configs.view.width);\n    const h = test.viewport.cssPixelsToDevicePixels(configs.view.height);\n    rowData.set(\"Screen Size\", `${w}X${h}`);\n    rowData.set(\"Skip & Time Renders\", `${configs.numRendersToSkip} & ${configs.numRendersToTime}`);\n    rowData.set(\"Display Style\", test.viewport.displayStyle.name);\n    rowData.set(\"Render Mode\", getRenderMode(test.viewport));\n    rowData.set(\"View Flags\", getViewFlagsString(test) !== \"\" ? ` ${getViewFlagsString(test)}` : \"\");\n    rowData.set(\"Render Options\", getRenderOpts(configs.renderOptions) !== \"\" ? ` ${getRenderOpts(configs.renderOptions)}` : \"\");\n    const tileProps = configs.tileProps ? getTileProps(configs.tileProps) : \"\";\n    rowData.set(\"Tile Props\", \"\" !== tileProps ? ` ${tileProps}` : \"\");\n    rowData.set(\"Bkg Map Props\", getBackgroundMapProps(test.viewport) !== \"\" ? ` ${getBackgroundMapProps(test.viewport)}` : \"\");\n    rowData.set(\"HyperModeling\", getHyperModelingProps(configs.hyperModeling) ?? \"\");\n    const other = getOtherProps(test.viewport);\n    if (\"\" !== other)\n      rowData.set(\"Other Props\", ` ${other}`);\n    if (pixSelectStr)\n      rowData.set(\"ReadPixels Selector\", ` ${pixSelectStr}`);\n    rowData.set(\"Test Name\", this.getTestName(test));\n    rowData.set(\"Browser\", getBrowserName(IModelApp.queryRenderCompatibility().userAgent));\n    if (!this._minimizeOutput) {\n      rowData.set(\"Tile Loading Time\", test.tileLoadingTime);\n      rowData.set(\"Num Selected Tiles\", test.numSelectedTiles);\n      rowData.set(\"Selected Tile GPU MB\", test.selectedTileGpuBytes / (1024 * 1024));\n      rowData.set(\"Tile Tree GPU MB\", test.viewedTileTreeGpuBytes / (1024 * 1024));\n      rowData.set(\"Total GPU MB\", test.totalGpuBytes / (1024 * 1024));\n    }\n    const setGpuData = (name) => {\n      if (name === \"CPU Total Time\")\n        name = \"Total\";\n      const gpuDataArray = timings.gpu.get(name);\n      if (gpuDataArray) {\n        let gpuSum = 0;\n        for (const gpuData of gpuDataArray)\n          gpuSum += gpuData;\n        rowData.set(`GPU-${name}`, gpuDataArray.length ? (gpuSum / gpuDataArray.length).toFixed(fixed) : gpuSum.toFixed(fixed));\n      }\n    };\n    if (pixSelectStr) {\n      for (const colName of timings.cpu[0].keys()) {\n        let sum = 0;\n        timings.cpu.forEach((timing) => {\n          const data = timing.get(colName);\n          sum += data ? data : 0;\n        });\n        if (!this._minimizeOutput || colName === \"CPU Total Time\") {\n          rowData.set(colName, (sum / timings.cpu.length).toFixed(fixed));\n          setGpuData(colName);\n        }\n      }\n    } else {\n      for (const colName of timings.actualFps[0].keys()) {\n        let sum = 0;\n        timings.actualFps.forEach((timing) => {\n          const data = timing.get(colName);\n          sum += data ? data : 0;\n        });\n        if (!this._minimizeOutput || colName === \"CPU Total Time\") {\n          rowData.set(colName, sum / timings.actualFps.length);\n          setGpuData(colName);\n        }\n      }\n    }\n    let totalTime;\n    if (rowData.get(\"Finish GPU Queue\")) {\n      totalTime = Number(rowData.get(\"CPU Total Time\")) + Number(rowData.get(\"Finish GPU Queue\"));\n      rowData.set(\"GPU Total Time\", totalTime);\n    }\n    let totalRenderTime = 0;\n    totalTime = 0;\n    for (const time of timings.actualFps) {\n      let timing = time.get(\"CPU Total Time\");\n      totalRenderTime += timing ? timing : 0;\n      timing = time.get(\"Total Time\");\n      totalTime += timing ? timing : 0;\n    }\n    rowData.delete(\"Total Time\");\n    totalRenderTime /= timings.actualFps.length;\n    totalTime /= timings.actualFps.length;\n    const disjointTimerUsed = rowData.get(\"GPU-Total\") !== void 0;\n    const totalGpuTime = Number(disjointTimerUsed ? rowData.get(\"GPU-Total\") : rowData.get(\"GPU Total Time\"));\n    const gpuTolerance = disjointTimerUsed ? 2 : 3;\n    const gpuBound = totalGpuTime - totalRenderTime > gpuTolerance;\n    const cpuBound = disjointTimerUsed ? totalRenderTime - totalGpuTime > gpuTolerance && totalRenderTime > 2 : !gpuBound;\n    let boundBy = \"\";\n    if (totalRenderTime < 2 && !gpuBound)\n      boundBy = \"unmeasurable\";\n    else if (!gpuBound && !cpuBound)\n      boundBy = \"unknown\";\n    else if (gpuBound)\n      boundBy = \"gpu\";\n    else\n      boundBy = \"CPU\";\n    if (1e3 / totalTime > 59)\n      boundBy += \" (vsync)\";\n    const totalCpuTime = totalRenderTime > 2 ? totalRenderTime : 2;\n    const effectiveFps = 1e3 / (gpuBound ? totalGpuTime : totalCpuTime);\n    if (disjointTimerUsed) {\n      rowData.set(\"GPU Total Time\", totalGpuTime.toFixed(fixed));\n      rowData.delete(\"GPU-Total\");\n    }\n    rowData.set(\"Bound By\", boundBy);\n    rowData.set(\"Effective Total Time\", gpuBound ? totalGpuTime.toFixed(fixed) : totalCpuTime.toFixed(fixed));\n    rowData.set(\"Effective FPS\", effectiveFps.toFixed(fixed));\n    rowData.set(\"Actual Total Time\", totalTime.toFixed(fixed));\n    rowData.set(\"Actual FPS\", totalTime > 0 ? (1e3 / totalTime).toFixed(fixed) : \"0\");\n    return rowData;\n  }\n  async createReadPixelsImages(test, pix, pixStr) {\n    const vp = test.viewport;\n    const canvas = vp.readImageToCanvas();\n    const ctx = canvas.getContext(\"2d\");\n    if (!ctx)\n      return;\n    const cssRect = new ViewRect(0, 0, this.curConfig.view.width, this.curConfig.view.height);\n    const imgWidth = vp.cssPixelsToDevicePixels(cssRect.width);\n    const imgHeight = vp.cssPixelsToDevicePixels(cssRect.height);\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    const elemIdImgData = pix & Pixel.Selector.Feature ? ctx.createImageData(imgWidth, imgHeight) : void 0;\n    const depthImgData = pix & Pixel.Selector.GeometryAndDistance ? ctx.createImageData(imgWidth, imgHeight) : void 0;\n    const typeImgData = pix & Pixel.Selector.GeometryAndDistance ? ctx.createImageData(imgWidth, imgHeight) : void 0;\n    vp.readPixels(cssRect, pix, (pixels) => {\n      if (!pixels)\n        return;\n      for (let y = 0; y < imgHeight; ++y) {\n        for (let x = 0; x < imgWidth; ++x) {\n          const index = x * 4 + y * 4 * imgWidth;\n          const pixel = pixels.getPixel(x, y);\n          if (elemIdImgData !== void 0) {\n            const elemId = Id64.getLowerUint32(pixel.elementId ? pixel.elementId : \"\");\n            elemIdImgData.data[index + 0] = elemId % 256;\n            elemIdImgData.data[index + 1] = Math.floor(elemId / 256) % 256;\n            elemIdImgData.data[index + 2] = Math.floor(elemId / (256 ^ 2)) % 256;\n            elemIdImgData.data[index + 3] = 255;\n          }\n          if (depthImgData !== void 0) {\n            const distColor = pixels.getPixel(x, y).distanceFraction * 255;\n            depthImgData.data[index + 0] = depthImgData.data[index + 1] = depthImgData.data[index + 2] = distColor;\n            depthImgData.data[index + 3] = 255;\n          }\n          if (typeImgData !== void 0) {\n            const type = pixels.getPixel(x, y).type;\n            switch (type) {\n              case Pixel.GeometryType.None:\n                typeImgData.data[index + 0] = 255;\n                typeImgData.data[index + 1] = 255;\n                typeImgData.data[index + 2] = 255;\n                break;\n              case Pixel.GeometryType.Surface:\n                typeImgData.data[index + 0] = 255;\n                typeImgData.data[index + 1] = 0;\n                typeImgData.data[index + 2] = 0;\n                break;\n              case Pixel.GeometryType.Linear:\n                typeImgData.data[index + 0] = 0;\n                typeImgData.data[index + 1] = 255;\n                typeImgData.data[index + 2] = 0;\n                break;\n              case Pixel.GeometryType.Edge:\n                typeImgData.data[index + 0] = 0;\n                typeImgData.data[index + 1] = 0;\n                typeImgData.data[index + 2] = 255;\n                break;\n              case Pixel.GeometryType.Silhouette:\n                typeImgData.data[index + 0] = 255;\n                typeImgData.data[index + 1] = 0;\n                typeImgData.data[index + 2] = 255;\n                break;\n              case Pixel.GeometryType.Unknown:\n              default:\n                typeImgData.data[index + 0] = 0;\n                typeImgData.data[index + 1] = 0;\n                typeImgData.data[index + 2] = 0;\n                break;\n            }\n            typeImgData.data[index + 3] = 255;\n          }\n        }\n      }\n    });\n    if (elemIdImgData !== void 0) {\n      ctx.putImageData(elemIdImgData, 0, 0);\n      await savePng(this.getImageName(test, `elemId_${pixStr}_`), canvas);\n    }\n    if (depthImgData !== void 0) {\n      ctx.putImageData(depthImgData, 0, 0);\n      await savePng(this.getImageName(test, `depth_${pixStr}_`), canvas);\n    }\n    if (typeImgData !== void 0) {\n      ctx.putImageData(typeImgData, 0, 0);\n      await savePng(this.getImageName(test, `type_${pixStr}_`), canvas);\n    }\n  }\n  async onException(ex) {\n    await DisplayPerfTestApp.logException(ex, { dir: this.curConfig.outputPath, name: this._logFileName });\n    if (\"terminate\" === this.curConfig.onException)\n      await DisplayPerfRpcInterface.getClient().terminate();\n  }\n}\nfunction removeOptsFromString(input, ignore) {\n  if (!ignore)\n    return input;\n  let output = input;\n  if (!(ignore instanceof Array))\n    ignore = ignore.split(\" \");\n  ignore.forEach((del) => {\n    output = output.replace(del, \"\");\n  });\n  output = output.replace(/__+/, \"_\");\n  if (output[output.length - 1] === \"_\")\n    output = output.slice(0, output.length - 1);\n  return output;\n}\nfunction getRenderMode(vp) {\n  switch (vp.viewFlags.renderMode) {\n    case RenderMode.Wireframe:\n      return \"Wireframe\";\n    case RenderMode.HiddenLine:\n      return \"HiddenLine\";\n    case RenderMode.SolidFill:\n      return \"SolidFill\";\n    case RenderMode.SmoothShade:\n      return \"SmoothShade\";\n    default:\n      return \"\";\n  }\n}\nfunction getRenderOpts(opts) {\n  let optString = \"\";\n  for (const propName of Object.keys(opts)) {\n    const key = propName;\n    switch (key) {\n      case \"disabledExtensions\": {\n        const extensions = opts[key];\n        if (extensions) {\n          for (const ext of extensions) {\n            switch (ext) {\n              case \"WEBGL_draw_buffers\":\n                optString += \"-drawBuf\";\n                break;\n              case \"OES_element_index_uint\":\n                optString += \"-unsignedInt\";\n                break;\n              case \"OES_texture_float\":\n                optString += \"-texFloat\";\n                break;\n              case \"OES_texture_half_float\":\n                optString += \"-texHalfFloat\";\n                break;\n              case \"WEBGL_depth_texture\":\n                optString += \"-depthTex\";\n                break;\n              case \"EXT_color_buffer_float\":\n                optString += \"-floats\";\n                break;\n              case \"EXT_shader_texture_lod\":\n                optString += \"-texLod\";\n                break;\n              case \"ANGLE_instanced_arrays\":\n                optString += \"-instArrays\";\n                break;\n              case \"EXT_frag_depth\":\n                optString += \"-fragDepth\";\n                break;\n            }\n          }\n        }\n        break;\n      }\n      case \"displaySolarShadows\":\n        if (!opts[key])\n          optString += \"-solShd\";\n        break;\n      case \"useWebGL2\":\n        if (opts[key])\n          optString += \"+webGL2\";\n        break;\n      case \"antialiasSamples\": {\n        const value = opts[key];\n        if (void 0 !== value && value > 1)\n          optString += `+aa${value}`;\n        break;\n      }\n    }\n  }\n  return optString;\n}\nfunction getTileProps(props) {\n  let tilePropsStr = \"\";\n  for (const propName of Object.keys(props)) {\n    const key = propName;\n    switch (key) {\n      case \"enableInstancing\":\n        if (props[key])\n          tilePropsStr += \"+inst\";\n        break;\n      case \"disableMagnification\":\n        if (props[key])\n          tilePropsStr += \"-mag\";\n        break;\n      case \"enableIndexedEdges\":\n        if (!props[key])\n          tilePropsStr += \"-idxEdg\";\n        break;\n      case \"generateAllPolyfaceEdges\":\n        if (!props[key])\n          tilePropsStr += \"-pfEdg\";\n        break;\n    }\n  }\n  return tilePropsStr;\n}\nfunction getBackgroundMapProps(vp) {\n  let bmPropsStr = \"\";\n  const layer = vp.displayStyle.settings.mapImagery.backgroundBase;\n  if (layer instanceof BaseMapLayerSettings && layer.provider) {\n    switch (layer.provider.name) {\n      case \"BingProvider\":\n        break;\n      case \"MapBoxProvider\":\n        bmPropsStr += \"MapBox\";\n        break;\n    }\n    switch (layer.provider.type) {\n      case BackgroundMapType.Hybrid:\n        break;\n      case BackgroundMapType.Aerial:\n        bmPropsStr += \"+aer\";\n        break;\n      case BackgroundMapType.Street:\n        bmPropsStr += \"+st\";\n        break;\n    }\n  }\n  const bmProps = vp.displayStyle.settings.backgroundMap;\n  if (bmProps.groundBias !== 0)\n    bmPropsStr += `+bias${bmProps.groundBias}`;\n  if (bmProps.applyTerrain)\n    bmPropsStr += \"+terr\";\n  if (bmProps.useDepthBuffer)\n    bmPropsStr += \"+depth\";\n  if (typeof bmProps.transparency === \"number\")\n    bmPropsStr += `+trans${bmProps.transparency}`;\n  return bmPropsStr;\n}\nfunction hiliteSettingsStr(settings) {\n  let hsStr = (settings.color.colors.r * 256 * 256 + settings.color.colors.g * 256 + settings.color.colors.b).toString(36).padStart(5, \"0\");\n  hsStr += (settings.silhouette * 256 * 256 + Math.round(settings.visibleRatio * 255) * 256 + Math.round(settings.hiddenRatio * 255)).toString(36).padStart(4, \"0\");\n  return hsStr.toUpperCase();\n}\nfunction getHyperModelingProps(props) {\n  if (!props)\n    return void 0;\n  const hm = `+hm${props.sectionDrawingLocationId}`;\n  return props.applySpatialView ? `${hm}+a` : hm;\n}\nfunction getOtherProps(vp) {\n  let propsStr = \"\";\n  if (!Hilite.equalSettings(vp.hilite, defaultHilite))\n    propsStr += `+h${hiliteSettingsStr(vp.hilite)}`;\n  if (!Hilite.equalSettings(vp.emphasisSettings, defaultEmphasis))\n    propsStr += `+e${hiliteSettingsStr(vp.emphasisSettings)}`;\n  return propsStr;\n}\nconst viewFlagsPropsStrings = {\n  dimensions: \"-dim\",\n  patterns: \"-pat\",\n  weights: \"-wt\",\n  styles: \"-sty\",\n  transparency: \"-trn\",\n  fill: \"-fll\",\n  textures: \"-txt\",\n  materials: \"-mat\",\n  visibleEdges: \"+vsE\",\n  hiddenEdges: \"+hdE\",\n  shadows: \"+shd\",\n  clipVolume: \"-clp\",\n  constructions: \"+con\",\n  monochrome: \"+mno\",\n  backgroundMap: \"+bkg\",\n  ambientOcclusion: \"+ao\",\n  forceSurfaceDiscard: \"+fsd\",\n  thematicDisplay: \"+thematicDisplay\",\n  grid: \"+grid\",\n  whiteOnWhiteReversal: \"+wow\",\n  acsTriad: \"+acsTriad\",\n  wiremesh: \"+wm\"\n};\nfunction getViewFlagsString(test) {\n  let vfString = \"\";\n  const vf = test.viewport.viewFlags;\n  if (vf.lighting && RenderMode.SmoothShade === vf.renderMode)\n    vfString = \"+lit\";\n  for (const propName of Object.keys(vf)) {\n    const key = propName;\n    const abbrev = viewFlagsPropsStrings[key];\n    if (!abbrev)\n      continue;\n    assert(\"-\" === abbrev[0] || \"+\" === abbrev[0]);\n    const includeIf = \"+\" === abbrev[0];\n    if (vf[key] === includeIf)\n      vfString += abbrev;\n  }\n  if (void 0 !== test.view.elementOverrides)\n    vfString += \"+ovrEl\";\n  if (void 0 !== test.view.selectedElements)\n    vfString += \"+selEl\";\n  return vfString;\n}\nfunction getBrowserName(userAgent) {\n  const lowUserAgent = userAgent.toLowerCase();\n  if (lowUserAgent.includes(\"electron\"))\n    return \"Electron\";\n  if (lowUserAgent.includes(\"firefox\"))\n    return \"FireFox\";\n  if (lowUserAgent.includes(\"edge\"))\n    return \"Edge\";\n  if (lowUserAgent.includes(\"chrome\") && !userAgent.includes(\"chromium\"))\n    return \"Chrome\";\n  if (lowUserAgent.includes(\"safari\") && !userAgent.includes(\"chrome\") && !userAgent.includes(\"chromium\"))\n    return \"Safari\";\n  return \"Unknown\";\n}\nfunction matchRule(strToTest, rule) {\n  strToTest = strToTest.toLowerCase();\n  rule = rule.toLowerCase();\n  const escapeRegex = (str) => str.replace(/([.*+?^=!:${}()|\\[\\]\\/\\\\])/g, \"\\\\$1\");\n  return new RegExp(`^${rule.split(\"*\").map(escapeRegex).join(\".*\")}$`).test(strToTest);\n}\nfunction getSelectedTileStats(vp) {\n  let formattedSelectedTileIds = \"Selected tiles:\\n\";\n  let count = 0;\n  const mem = new RenderMemory.Statistics();\n  const dict = new Dictionary((lhs, rhs) => lhs.localeCompare(rhs));\n  for (const viewport of [vp, ...vp.view.secondaryViewports]) {\n    const selected = IModelApp.tileAdmin.getTilesForUser(viewport)?.selected;\n    if (!selected)\n      continue;\n    count += selected.size;\n    for (const tile of selected) {\n      const treeId = tile.tree.id;\n      let tileIds = dict.get(treeId);\n      if (!tileIds)\n        dict.set(treeId, tileIds = new SortedArray((lhs, rhs) => lhs.localeCompare(rhs)));\n      tileIds.insert(tile.contentId);\n      tile.collectStatistics(mem);\n    }\n  }\n  for (const kvp of dict) {\n    const contentIds = kvp.value.extractArray().join(\",\");\n    const line = `  ${kvp.key}: ${contentIds}`;\n    formattedSelectedTileIds = `${formattedSelectedTileIds}${line}\n`;\n  }\n  return {\n    ids: formattedSelectedTileIds,\n    count,\n    gpuBytes: mem.totalBytes\n  };\n}\nfunction calcGpuBytes(func) {\n  const stats = new RenderMemory.Statistics();\n  func(stats);\n  return stats.totalBytes;\n}\nasync function savePng(fileName, canvas) {\n  const img = canvas.toDataURL(\"image/png\");\n  const data = img.replace(/^data:image\\/\\w+;base64,/, \"\");\n  return DisplayPerfRpcInterface.getClient().savePng(fileName, data);\n}\nfunction setPerformanceMetrics(vp, metrics) {\n  vp.target.performanceMetrics = metrics;\n}\n",
      "start": 1693508118470,
      "end": 1693508118826,
      "order": "normal",
      "sourcemaps": {
        "version": 3,
        "sources": [
          "D:/hub2023A/itwinjs-core/test-apps/display-performance-test-app/src/frontend/TestRunner.ts"
        ],
        "sourcesContent": [
          "/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\r\n* See LICENSE.md in the project root for license terms and full copyright notice.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\nimport { RealityDataAccessClient, RealityDataClientOptions } from \"@itwin/reality-data-client\";\r\nimport {\r\n  assert, Dictionary, Id64, Id64Array, Id64String, ProcessDetector, SortedArray, StopWatch,\r\n} from \"@itwin/core-bentley\";\r\nimport {\r\n  BackgroundMapType, BaseMapLayerSettings, DisplayStyleProps, FeatureAppearance, Hilite, RenderMode, ViewStateProps,\r\n} from \"@itwin/core-common\";\r\nimport {\r\n  CheckpointConnection,\r\n  DisplayStyle3dState, DisplayStyleState, EntityState, FeatureSymbology, GLTimerResult, GLTimerResultCallback, IModelApp, IModelConnection,\r\n  PerformanceMetrics, Pixel, RenderMemory, RenderSystem, ScreenViewport, SnapshotConnection, Target, TileAdmin, ToolAdmin, ViewRect, ViewState,\r\n} from \"@itwin/core-frontend\";\r\nimport { System } from \"@itwin/core-frontend/lib/cjs/webgl\";\r\nimport { HyperModeling } from \"@itwin/hypermodeling-frontend\";\r\nimport { TestFrontendAuthorizationClient } from \"@itwin/oidc-signin-tool/lib/cjs/TestFrontendAuthorizationClient\";\r\nimport DisplayPerfRpcInterface from \"../common/DisplayPerfRpcInterface\";\r\nimport { DisplayPerfTestApp } from \"./DisplayPerformanceTestApp\";\r\nimport {\r\n  defaultEmphasis, defaultHilite, ElementOverrideProps, HyperModelingProps, separator, TestConfig, TestConfigProps, TestConfigStack, ViewStateSpec, ViewStateSpecProps,\r\n} from \"./TestConfig\";\r\nimport { SavedViewsFetcher } from \"./SavedViewsFetcher\";\r\n\r\n/** JSON representation of a set of tests. Each test in the set inherits the test set's configuration. */\r\nexport interface TestSetProps extends TestConfigProps {\r\n  tests: TestConfigProps[];\r\n}\r\n\r\n/** JSON representation of TestRunner. The tests inherit the base configuration options. */\r\nexport interface TestSetsProps extends TestConfigProps {\r\n  signIn?: boolean;\r\n  minimize?: boolean;\r\n  testSet: TestSetProps[];\r\n}\r\n\r\n/** Context for any number of TestCases to be run against an iModel. */\r\ninterface TestContext {\r\n  readonly iModel: IModelConnection;\r\n  readonly externalSavedViews: ViewStateSpec[];\r\n}\r\n\r\n/** The view against which a specific TestCase is to be run. */\r\ninterface TestViewState {\r\n  readonly view: ViewState;\r\n  readonly elementOverrides?: ElementOverrideProps[];\r\n  readonly selectedElements?: Id64String | Id64Array;\r\n}\r\n\r\n/** The result of TestRunner.runTest. */\r\ninterface TestResult {\r\n  /** An ordered listing of all the tiles selected for display. */\r\n  selectedTileIds: string;\r\n  /** The number of tiles selected for display. */\r\n  numSelectedTiles: number;\r\n  /** Approximate time in milliseconds before all tiles were ready for display. */\r\n  tileLoadingTime: number;\r\n  /** Amount of memory requested from the GPU for the graphics of the tiles selected for display. */\r\n  selectedTileGpuBytes: number;\r\n  /** Amount of memory requested from the GPU for the graphics of all tiles in the tile trees viewed by this test.\r\n   * This is always at least as large as selectedTileGpuBytes and may be much larger as recently-used tiles are kept in memory\r\n   * for a period of time, and parent tiles' graphics are typically kept in memory for as long as their child tiles are.\r\n   * Therefore this may be expected to grow over time as successive tests exercise different views of the same tile trees.\r\n   */\r\n  viewedTileTreeGpuBytes: number;\r\n  /** Total amount of memory requested (and not yet relinquished) from the GPU by the render system, including frame buffers,\r\n   * textures, graphics, etc.\r\n   */\r\n  totalGpuBytes: number;\r\n}\r\n\r\n/** A test being executed in a viewport. */\r\ninterface TestCase extends TestResult {\r\n  readonly viewport: ScreenViewport;\r\n  view: TestViewState;\r\n}\r\n\r\n/** Timings collected during TestRunner.runTest. */\r\nclass Timings {\r\n  public readonly cpu = new Array<Map<string, number>>();\r\n  public readonly gpu = new Map<string, number[]>();\r\n  public readonly actualFps = new Array<Map<string, number>>();\r\n  public gpuFramesCollected = 0;\r\n  public readonly callback: GLTimerResultCallback;\r\n\r\n  public constructor(numFramesToCollect: number) {\r\n    this.callback = (result: GLTimerResult) => {\r\n      if (this.gpuFramesCollected >= numFramesToCollect)\r\n        return;\r\n\r\n      const label = result.label;\r\n      const timings = this.gpu.get(label);\r\n      this.gpu.set(label, timings ? timings.concat(result.nanoseconds / 1e6) : [result.nanoseconds / 1e6]); // save as milliseconds\r\n      if (result.children)\r\n        for (const child of result.children)\r\n          this.callback(child);\r\n\r\n      if (\"Total\" === label)\r\n        ++this.gpuFramesCollected;\r\n    };\r\n  }\r\n\r\n  public set callbackEnabled(enabled: boolean) {\r\n    IModelApp.renderSystem.debugControl!.resultsCallback = enabled ? this.callback : undefined;\r\n  }\r\n}\r\n\r\n/** Applies ELementOverrideProps to elements in a viewport for a TestCase. */\r\nclass OverrideProvider {\r\n  private readonly _elementOvrs = new Map<Id64String, FeatureAppearance>();\r\n  private readonly _defaultOvrs?: FeatureAppearance;\r\n\r\n  private constructor(ovrs: ElementOverrideProps[]) {\r\n    for (const ovr of ovrs) {\r\n      const app = FeatureAppearance.fromJSON(JSON.parse(ovr.fsa));\r\n      if (ovr.id === \"-default-\")\r\n        this._defaultOvrs = app;\r\n      else\r\n        this._elementOvrs.set(ovr.id, app);\r\n    }\r\n  }\r\n\r\n  public static override(vp: ScreenViewport, ovrs: ElementOverrideProps[]): void {\r\n    const provider = new OverrideProvider(ovrs);\r\n    vp.addFeatureOverrideProvider(provider);\r\n  }\r\n\r\n  public addFeatureOverrides(ovrs: FeatureSymbology.Overrides): void {\r\n    if (this._defaultOvrs)\r\n      ovrs.setDefaultOverrides(this._defaultOvrs);\r\n\r\n    for (const [elementId, appearance] of this._elementOvrs)\r\n      ovrs.override({ elementId, appearance });\r\n  }\r\n}\r\n\r\n/** Given the JSON representation of a set of tests, executes them and records output (CSV timing info, images, logs, etc). */\r\nexport class TestRunner {\r\n  private readonly _config: TestConfigStack;\r\n  private readonly _minimizeOutput: boolean;\r\n  private readonly _testSets: TestSetProps[];\r\n  private readonly _logFileName: string;\r\n  private readonly _testNamesImages = new Map<string, number>();\r\n  private readonly _testNamesTimings = new Map<string, number>();\r\n  private readonly _savedViewsFetcher: SavedViewsFetcher;\r\n  private _lastRestartConfig: TestConfig;\r\n\r\n  public get curConfig(): TestConfig {\r\n    return this._config.top;\r\n  }\r\n\r\n  public get lastRestartConfig(): TestConfig { return this._lastRestartConfig; }\r\n  public set lastRestartConfig(config: TestConfig) {\r\n    this._lastRestartConfig = config;\r\n  }\r\n\r\n  public constructor(\r\n    props: TestSetsProps,\r\n    savedViewsFetcher: SavedViewsFetcher = new SavedViewsFetcher(),\r\n  ) {\r\n    // NB: The default minimum spatial chord tolerance was changed from \"no minimum\" to 1mm. To preserve prior behavior,\r\n    // override it to zero.\r\n    // Subsequently pushed configs can override this if desired.\r\n    const defaultTileProps: TileAdmin.Props = { minimumSpatialTolerance: 0 };\r\n    props.tileProps = props.tileProps ? { ...defaultTileProps, ...props.tileProps } : defaultTileProps;\r\n\r\n    this._config = new TestConfigStack(new TestConfig(props));\r\n    this._lastRestartConfig = this.curConfig;\r\n    this._testSets = props.testSet;\r\n    this._minimizeOutput = true === props.minimize;\r\n    this._logFileName = \"_DispPerfTestAppViewLog.txt\";\r\n    this._savedViewsFetcher = savedViewsFetcher;\r\n\r\n    ToolAdmin.exceptionHandler = async (ex) => this.onException(ex);\r\n  }\r\n\r\n  /** Run all the tests. */\r\n  public async run(): Promise<void> {\r\n    const msg = `View Log,  Model Base Location: ${this.curConfig.iModelLocation}\\n  format: Time_started  ModelName  [ViewName]`;\r\n    await this.logToConsole(msg);\r\n    await this.logToFile(msg, { noAppend: true });\r\n\r\n    let needRestart = this.curConfig.requiresRestart(new TestConfig({})); // If current config differs from default, restart\r\n    const renderOptions: RenderSystem.Options = this.curConfig.renderOptions ?? {};\r\n    if (!this.curConfig.useDisjointTimer) {\r\n      const ext = this.curConfig.renderOptions?.disabledExtensions;\r\n      renderOptions.disabledExtensions = Array.isArray(ext) ? ext.concat([\"EXT_disjoint_timer_query\", \"EXT_disjoint_timer_query_webgl2\"]) : [\"EXT_disjoint_timer_query\", \"EXT_disjoint_timer_query_webgl2\"];\r\n      needRestart = true;\r\n    }\r\n    if (IModelApp.initialized && needRestart) {\r\n      await IModelApp.shutdown();\r\n    }\r\n    if (!IModelApp.initialized) {\r\n      const realityDataClientOptions: RealityDataClientOptions = {\r\n        /** API Version. v1 by default */\r\n        // version?: ApiVersion;\r\n        /** API Url. Used to select environment. Defaults to \"https://api.bentley.com/realitydata\" */\r\n        baseUrl: `https://${process.env.IMJS_URL_PREFIX}api.bentley.com/realitydata`,\r\n      };\r\n      await DisplayPerfTestApp.startup({\r\n        renderSys: renderOptions,\r\n        tileAdmin: this.curConfig.tileProps,\r\n        realityDataAccess: new RealityDataAccessClient(realityDataClientOptions),\r\n      });\r\n    }\r\n    // save current state as reference, whether or not we restarted\r\n    this.lastRestartConfig = this.curConfig;\r\n\r\n    // Run all the tests\r\n    for (const set of this._testSets)\r\n      await this.runTestSet(set);\r\n\r\n    // Update UI to signal we're finished.\r\n    const topdiv = document.getElementById(\"topdiv\")!;\r\n    topdiv.style.display = \"block\";\r\n    topdiv.innerText = \"Tests Completed.\";\r\n    document.getElementById(\"imodel-viewport\")!.style.display = \"hidden\";\r\n\r\n    // Write WebGL compatibility info to CSV.\r\n    await this.finish();\r\n  }\r\n\r\n  private async runTestSet(set: TestSetProps): Promise<void> {\r\n    this._config.push(set);\r\n    const realityDataClientOptions: RealityDataClientOptions = {\r\n      /** API Version. v1 by default */\r\n      // version?: ApiVersion;\r\n      /** API Url. Used to select environment. Defaults to \"https://api.bentley.com/realitydata\" */\r\n      baseUrl: `https://${process.env.IMJS_URL_PREFIX}api.bentley.com/realitydata`,\r\n    };\r\n    // Perform all the tests for this iModel. If the iModel name contains an asterisk,\r\n    // treat it as a wildcard and run tests for each iModel that matches the given wildcard.\r\n    for (const testProps of set.tests) {\r\n      this._config.push(testProps);\r\n\r\n      // Ensure IModelApp is initialized with options required by this test.\r\n      if (IModelApp.initialized && this.curConfig.requiresRestart(this.lastRestartConfig)) {\r\n        await IModelApp.shutdown();\r\n      }\r\n      if (!IModelApp.initialized) {\r\n        const renderOptions: RenderSystem.Options = this.curConfig.renderOptions ?? {};\r\n        if (!this.curConfig.useDisjointTimer) {\r\n          const ext = this.curConfig.renderOptions?.disabledExtensions;\r\n          renderOptions.disabledExtensions = Array.isArray(ext) ? ext.concat([\"EXT_disjoint_timer_query\", \"EXT_disjoint_timer_query_webgl2\"]) : [\"EXT_disjoint_timer_query\", \"EXT_disjoint_timer_query_webgl2\"];\r\n        }\r\n        await DisplayPerfTestApp.startup({\r\n          renderSys: renderOptions,\r\n          tileAdmin: this.curConfig.tileProps,\r\n          realityDataAccess: new RealityDataAccessClient(realityDataClientOptions),\r\n        });\r\n        this.lastRestartConfig = this.curConfig;\r\n      }\r\n\r\n      // Run test against all iModels matching the test config.\r\n      const iModelNames = await this.getIModelNames();\r\n      const originalViewName = this.curConfig.viewName;\r\n      for (const iModelName of iModelNames) {\r\n        this.curConfig.iModelName = iModelName;\r\n        this.curConfig.viewName = originalViewName;\r\n\r\n        let context: TestContext;\r\n        try {\r\n          context = await this.openIModel();\r\n        } catch (e: any) {\r\n          await this.logError(`Failed to open iModel ${iModelName}: ${(e as Error).message}`);\r\n          continue;\r\n        }\r\n\r\n        try {\r\n          await this.runTests(context);\r\n        } catch {\r\n          await this.logError(`Failed to run tests on iModel ${iModelName}`);\r\n        } finally {\r\n          await context.iModel.close();\r\n        }\r\n      }\r\n      this._config.pop();\r\n    }\r\n\r\n    this._config.pop();\r\n  }\r\n\r\n  private async runTests(context: TestContext): Promise<void> {\r\n    const viewNames = await this.getViewNames(context);\r\n    for (const viewName of viewNames) {\r\n      this.curConfig.viewName = viewName;\r\n\r\n      await this.logTest();\r\n\r\n      try {\r\n        this.curConfig.urlStr = undefined;\r\n        const result = await this.runTest(context);\r\n        if (this.curConfig.urlStr)\r\n          await this.logURL();\r\n        if (result)\r\n          await this.logToFile(result.selectedTileIds, { noNewLine: true });\r\n      } catch (ex) {\r\n        await this.onException(ex);\r\n      }\r\n    }\r\n  }\r\n\r\n  private async runTest(context: TestContext): Promise<TestResult | undefined> {\r\n    // Reset the title bar to include the current model and view name\r\n    const testConfig = this.curConfig;\r\n    document.title = \"Display Performance Test App:  \".concat(testConfig.iModelName ?? \"\", \"  [\", testConfig.viewName ?? \"\", \"]\");\r\n\r\n    const test = await this.setupTest(context);\r\n    if (!test)\r\n      return undefined;\r\n\r\n    const vp = test.viewport;\r\n    if (testConfig.testType === \"image\" || testConfig.testType === \"both\") {\r\n      this.updateTestNames(test, undefined, true);\r\n\r\n      const canvas = vp.readImageToCanvas();\r\n      await savePng(this.getImageName(test), canvas);\r\n\r\n      if (testConfig.testType === \"image\") {\r\n        vp.dispose();\r\n        return test;\r\n      }\r\n    }\r\n\r\n    // Throw away the first N frames until the timings become more consistent.\r\n    for (let i = 0; i < this.curConfig.numRendersToSkip; i++) {\r\n      vp.requestRedraw();\r\n      vp.renderFrame();\r\n    }\r\n\r\n    this.updateTestNames(test);\r\n    await (testConfig.testType === \"readPixels\" ? this.recordReadPixels(test) : this.recordRender(test));\r\n\r\n    vp.dispose();\r\n    return test;\r\n  }\r\n\r\n  private async recordReadPixels(test: TestCase): Promise<void> {\r\n    const vp = test.viewport;\r\n    const viewRect = new ViewRect(0, 0, this.curConfig.view.width, this.curConfig.view.height);\r\n    const timings = new Timings(this.curConfig.numRendersToTime);\r\n\r\n    const testReadPix = async (pixSelect: Pixel.Selector, pixSelectStr: string) => {\r\n      // Collect CPU timings.\r\n      setPerformanceMetrics(vp, new PerformanceMetrics(true, false, undefined));\r\n      for (let i = 0; i < this.curConfig.numRendersToTime; ++i) {\r\n        vp.readPixels(viewRect, pixSelect, () => { });\r\n        timings.cpu[i] = (vp.target as Target).performanceMetrics!.frameTimings;\r\n        timings.cpu[i].delete(\"Scene Time\");\r\n      }\r\n\r\n      // Collect GPU timings.\r\n      timings.gpuFramesCollected = 0;\r\n      timings.callbackEnabled = true;\r\n      setPerformanceMetrics(vp, new PerformanceMetrics(true, false, timings.callback));\r\n      await this.renderAsync(vp, this.curConfig.numRendersToTime, timings);\r\n      timings.callbackEnabled = false;\r\n\r\n      this.updateTestNames(test, pixSelectStr, true);\r\n      this.updateTestNames(test, pixSelectStr, false);\r\n\r\n      const row = this.getRowData(timings, test, pixSelectStr);\r\n      await this.saveCsv(row);\r\n      await this.createReadPixelsImages(test, pixSelect, pixSelectStr);\r\n    };\r\n\r\n    // Test each combo of pixel selectors.\r\n    await testReadPix(Pixel.Selector.Feature, \"+feature\");\r\n    await testReadPix(Pixel.Selector.GeometryAndDistance, \"+geom+dist\");\r\n    await testReadPix(Pixel.Selector.All, \"+feature+geom+dist\");\r\n  }\r\n\r\n  private async recordRender(test: TestCase): Promise<void> {\r\n    const timings = new Timings(this.curConfig.numRendersToTime);\r\n    setPerformanceMetrics(test.viewport, new PerformanceMetrics(true, false, timings.callback));\r\n    await this.renderAsync(test.viewport, this.curConfig.numRendersToTime, timings);\r\n\r\n    const row = this.getRowData(timings, test);\r\n    await this.saveCsv(row);\r\n  }\r\n\r\n  private async renderAsync(vp: ScreenViewport, numFrames: number, timings: Timings): Promise<void> {\r\n    IModelApp.viewManager.addViewport(vp);\r\n\r\n    const target = vp.target as Target;\r\n    const metrics = target.performanceMetrics;\r\n    assert(undefined !== metrics);\r\n\r\n    target.performanceMetrics = undefined;\r\n    timings.callbackEnabled = false;\r\n\r\n    const numFramesToIgnore = 120;\r\n    let ignoreFrameCount = 0;\r\n    let frameCount = 0;\r\n    vp.continuousRendering = true;\r\n    return new Promise((resolve: () => void, _reject) => {\r\n      const timer = new StopWatch();\r\n      const removeListener = vp.onRender.addListener(() => {\r\n        // Ignore the first N frames - they seem to have more variable frame rate.\r\n        if (++ignoreFrameCount <= numFramesToIgnore) {\r\n          if (ignoreFrameCount === numFramesToIgnore) {\r\n            // Time to start recording.\r\n            target.performanceMetrics = metrics;\r\n            timings.callbackEnabled = true;\r\n            timer.start();\r\n          }\r\n\r\n          return;\r\n        }\r\n\r\n        timer.stop();\r\n        timings.actualFps[frameCount] = metrics.frameTimings;\r\n        timings.actualFps[frameCount].set(\"Total Time\", timer.current.milliseconds);\r\n\r\n        if (++frameCount === numFrames)\r\n          target.performanceMetrics = undefined;\r\n\r\n        if (timings.gpuFramesCollected >= numFrames || (frameCount >= numFrames && !(IModelApp.renderSystem as System).isGLTimerSupported)) {\r\n          removeListener();\r\n          IModelApp.viewManager.dropViewport(vp, false);\r\n          vp.continuousRendering = false;\r\n          timings.callbackEnabled = false;\r\n          resolve();\r\n        } else {\r\n          vp.requestRedraw();\r\n          timer.start();\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  private async setupTest(context: TestContext): Promise<TestCase | undefined> {\r\n    const imodel = context.iModel;\r\n    // Open the view.\r\n    const view = await this.loadView(context);\r\n    if (!view)\r\n      return undefined;\r\n\r\n    const viewport = this.openViewport(view.view);\r\n\r\n    // Apply hypermodeling\r\n    const hyperModeling = this.curConfig.hyperModeling;\r\n    if (hyperModeling) {\r\n      try {\r\n        const decorator = await HyperModeling.start(viewport);\r\n        const marker = decorator?.markers.findMarkerById(hyperModeling.sectionDrawingLocationId);\r\n        if (!decorator) {\r\n          await this.logError(\"Failed to start hypermodeling.\");\r\n        } else if (!marker) {\r\n          await this.logError(`SectionDrawingLocation ${hyperModeling.sectionDrawingLocationId} not found.`);\r\n        } else {\r\n          if (hyperModeling.applySpatialView) {\r\n            await decorator.toggleSection(marker, true);\r\n          } else {\r\n            decorator.toggleClipVolume(marker, true);\r\n            await decorator.toggleAttachment(marker, true);\r\n          }\r\n        }\r\n      } catch (err: any) {\r\n        await DisplayPerfTestApp.logException(err, { dir: this.curConfig.outputPath, name: this._logFileName });\r\n      }\r\n    }\r\n\r\n    // Apply emphasis and hilite settings.\r\n    const config = this.curConfig;\r\n    if (config.hilite)\r\n      viewport.hilite = config.hilite;\r\n\r\n    if (config.emphasis)\r\n      viewport.emphasisSettings = config.emphasis;\r\n\r\n    // Apply display style.\r\n    if (config.displayStyle) {\r\n      const styleProps = await imodel.elements.queryProps({ from: DisplayStyleState.classFullName, where: `CodeValue='${config.displayStyle}'` });\r\n      if (styleProps.length >= 1) {\r\n        const style = new DisplayStyle3dState(styleProps[0] as DisplayStyleProps, imodel);\r\n        await style.load();\r\n        viewport.view.setDisplayStyle(style);\r\n      }\r\n    }\r\n\r\n    // Apply the view flags.\r\n    if (config.viewFlags) {\r\n      const vf = viewport.viewFlags as { [key: string]: any };\r\n      const configVf = config.viewFlags as { [key: string]: any };\r\n      for (const key of Object.keys(vf)) {\r\n        const flag = configVf[key];\r\n        if (undefined !== flag) {\r\n          if (key === \"renderMode\" && typeof flag === \"string\") {\r\n            switch (flag.toLowerCase()) {\r\n              case \"solidfill\":\r\n                vf.renderMode = RenderMode.SolidFill;\r\n                break;\r\n              case \"hiddenline\":\r\n                vf.renderMode = RenderMode.HiddenLine;\r\n                break;\r\n              case \"wireframe\":\r\n                vf.renderMode = RenderMode.Wireframe;\r\n                break;\r\n              case \"smoothshade\":\r\n                vf.renderMode = RenderMode.SmoothShade;\r\n                break;\r\n            }\r\n          } else {\r\n            vf[key] = flag;\r\n          }\r\n        } else {\r\n          configVf[key] = vf[key];\r\n        }\r\n      }\r\n    }\r\n\r\n    if (config.backgroundMap)\r\n      viewport.changeBackgroundMapProps(viewport.displayStyle.settings.backgroundMap.clone(config.backgroundMap).toJSON());\r\n\r\n    // Apply symbology overrides\r\n    if (view.elementOverrides)\r\n      OverrideProvider.override(viewport, view.elementOverrides);\r\n\r\n    // Ensure all tiles required for the view are loaded.\r\n    const result = await this.waitForTilesToLoad(viewport);\r\n\r\n    // Set selected elements after all tiles have loaded.\r\n    if (view.selectedElements) {\r\n      imodel.selectionSet.add(view.selectedElements);\r\n      viewport.markSelectionSetDirty();\r\n      viewport.renderFrame();\r\n    }\r\n\r\n    return { ...result, viewport, view };\r\n  }\r\n\r\n  private async waitForTilesToLoad(viewport: ScreenViewport): Promise<TestResult> {\r\n    const timer = new StopWatch(undefined, true);\r\n    await viewport.waitForSceneCompletion();\r\n    timer.stop();\r\n\r\n    const selectedTiles = getSelectedTileStats(viewport);\r\n    return {\r\n      tileLoadingTime: timer.current.milliseconds,\r\n      selectedTileIds: selectedTiles.ids,\r\n      numSelectedTiles: selectedTiles.count,\r\n      selectedTileGpuBytes: selectedTiles.gpuBytes,\r\n      viewedTileTreeGpuBytes: calcGpuBytes((stats) => viewport.collectStatistics(stats)),\r\n      totalGpuBytes: calcGpuBytes((stats) => {\r\n        viewport.target.renderSystem.collectStatistics(stats);\r\n        viewport.target.collectStatistics(stats);\r\n        viewport.iModel.tiles.forEachTreeOwner((owner) => owner.tileTree?.collectStatistics(stats));\r\n      }),\r\n    };\r\n  }\r\n\r\n  private openViewport(view: ViewState): ScreenViewport {\r\n    // Ensure the exact same number of pixels regardless of device pixel ratio.\r\n    const div = document.getElementById(\"imodel-viewport\") as HTMLDivElement;\r\n    const ratio = false === IModelApp.renderSystem.options.dpiAwareViewports ? 1 : (window.devicePixelRatio || 1);\r\n    const width = `${String(this.curConfig.view.width / ratio)}px`;\r\n    const height = `${String(this.curConfig.view.height / ratio)}px`;\r\n\r\n    div.style.width = width;\r\n    div.style.height = height;\r\n\r\n    const vp = ScreenViewport.create(div, view);\r\n    vp.rendersToScreen = true;\r\n\r\n    vp.canvas.style.width = width;\r\n    vp.canvas.style.height = height;\r\n\r\n    return vp;\r\n  }\r\n\r\n  private async loadViewFromSpec(spec: ViewStateSpec, context: TestContext): Promise<TestViewState | undefined> {\r\n    const className = spec.viewProps.viewDefinitionProps.classFullName;\r\n    const ctor = await context.iModel.findClassFor<typeof EntityState>(className, undefined) as typeof ViewState | undefined;\r\n    const view = ctor?.createFromProps(spec.viewProps, context.iModel);\r\n    if (!view) {\r\n      await this.logError(\"Failed to create view from spec\");\r\n      return undefined;\r\n    }\r\n\r\n    await view.load();\r\n    return {\r\n      view,\r\n      elementOverrides: spec.elementOverrides,\r\n      selectedElements: spec.selectedElements,\r\n    };\r\n  }\r\n\r\n  private async loadView(context: TestContext): Promise<TestViewState | undefined> {\r\n    // If viewStateSpec is defined, use it. If we fail to instantiate it, fail.\r\n    const config = this.curConfig;\r\n    if (config.viewStateSpec)\r\n      return this.loadViewFromSpec(config.viewStateSpec, context);\r\n\r\n    // If extViewName defined, find the matching external view. If none found, fail.\r\n    if (config.extViewName) {\r\n      const spec = context.externalSavedViews.find((x) => x.name === config.extViewName);\r\n      if (spec)\r\n        return this.loadViewFromSpec(spec, context);\r\n\r\n      await this.logError(`Failed to find external saved view ${config.extViewName}`);\r\n      return undefined;\r\n    }\r\n\r\n    // If viewName is defined, find a persistent view with that name.\r\n    const ids = await context.iModel.elements.queryIds({ from: ViewState.classFullName, where: `CodeValue='${config.viewName}'` });\r\n    for (const id of ids)\r\n      return { view: await context.iModel.views.load(id) };\r\n\r\n    // Try to find an external view matching viewName.\r\n    const extSpec = context.externalSavedViews.find((x) => x.name === config.viewName);\r\n    if (extSpec)\r\n      return this.loadViewFromSpec(extSpec, context);\r\n\r\n    await this.logError(`Failed to find persistent view ${config.viewName}`);\r\n    return undefined;\r\n  }\r\n\r\n  private updateTestNames(test: TestCase, prefix?: string, isImage = false): void {\r\n    const testNames = isImage ? this._testNamesImages : this._testNamesTimings;\r\n    const testName = this.getTestName(test, prefix, false, true);\r\n    const testNameDupes = testNames.get(testName) ?? 0;\r\n    testNames.set(testName, testNameDupes + 1);\r\n  }\r\n\r\n  private async logTest(): Promise<void> {\r\n    const testConfig = this.curConfig;\r\n    const today = new Date();\r\n    const month = (`0${(today.getMonth() + 1)}`).slice(-2);\r\n    const day = (`0${today.getDate()}`).slice(-2);\r\n    const year = today.getFullYear();\r\n    const hours = (`0${today.getHours()}`).slice(-2);\r\n    const minutes = (`0${today.getMinutes()}`).slice(-2);\r\n    const seconds = (`0${today.getSeconds()}`).slice(-2);\r\n    const outStr = `${year}-${month}-${day} ${hours}:${minutes}:${seconds}  ${testConfig.iModelName}  [${testConfig.viewName}]`;\r\n\r\n    await this.logToConsole(outStr);\r\n    return this.logToFile(outStr);\r\n  }\r\n\r\n  // Log url path for cases it is used\r\n  private async logURL(): Promise<void> {\r\n    const outStr = `  [url: ${this.curConfig.urlStr}]`;\r\n    await this.logToConsole(outStr);\r\n    return this.logToFile(outStr);\r\n  }\r\n\r\n  private async openIModel(): Promise<TestContext> {\r\n    if (this.curConfig.iModelId) {\r\n      if (process.env.IMJS_OIDC_HEADLESS) {\r\n        const token = await DisplayPerfRpcInterface.getClient().getAccessToken();\r\n        IModelApp.authorizationClient = new TestFrontendAuthorizationClient(token);\r\n      }\r\n      // Download remote iModel and its saved views\r\n      const { iModelId, iTwinId } = this.curConfig;\r\n      if (iTwinId === undefined)\r\n        throw new Error(\"Missing iTwinId for remote iModel\");\r\n      const iModel = await CheckpointConnection.openRemote(iTwinId, iModelId);\r\n      const externalSavedViews = await this._savedViewsFetcher.getSavedViews(iTwinId, iModelId, await IModelApp.getAccessToken());\r\n      return { iModel, externalSavedViews };\r\n    } else {\r\n      // Load local iModel and its saved views\r\n      const filepath = `${this.curConfig.iModelLocation}${separator}${this.curConfig.iModelName}`;\r\n      const iModel = await SnapshotConnection.openFile(filepath);\r\n\r\n      const esv = await DisplayPerfRpcInterface.getClient().readExternalSavedViews(filepath);\r\n      let externalSavedViews: ViewStateSpec[] = [];\r\n      if (esv) {\r\n        const json = JSON.parse(esv) as ViewStateSpecProps[];\r\n        externalSavedViews = json.map((x) => {\r\n          return {\r\n            name: x._name,\r\n            viewProps: JSON.parse(x._viewStatePropsString) as ViewStateProps,\r\n            elementOverrides: x._overrideElements ? JSON.parse(x._overrideElements) as ElementOverrideProps[] : undefined,\r\n            selectedElements: x._selectedElements ? JSON.parse(x._selectedElements) as Id64String | Id64Array : undefined,\r\n          };\r\n        });\r\n      }\r\n      return { iModel, externalSavedViews };\r\n    }\r\n  }\r\n\r\n  private async getIModelNames(): Promise<string[]> {\r\n    const config = this.curConfig;\r\n    if (!config.iModelName.includes(\"*\"))\r\n      return [config.iModelName];\r\n\r\n    const json = await DisplayPerfRpcInterface.getClient().getMatchingFiles(config.iModelLocation, config.iModelName);\r\n    const files = JSON.parse(json);\r\n    const iModels = [];\r\n    for (const file of files) {\r\n      if (file.endsWith(\".bim\") || file.endsWith(\".ibim\")) {\r\n        const split = file.split(/[^\\/\\\\]+/g);\r\n        const iModel = split[split.length - 1];\r\n        if (iModel)\r\n          iModels.push(iModel);\r\n      }\r\n    }\r\n\r\n    return iModels;\r\n  }\r\n\r\n  private async getViewNames(context: TestContext): Promise<string[]> {\r\n    if (!this.curConfig.viewName.includes(\"*\"))\r\n      return [this.curConfig.viewName];\r\n\r\n    let viewNames: string[] = [];\r\n    if (this.curConfig.savedViewType !== \"external\") {\r\n      const specs = await context.iModel.views.getViewList({ wantPrivate: true });\r\n      viewNames = specs.map((spec) => spec.name);\r\n    }\r\n\r\n    if (this.curConfig.savedViewType !== \"internal\" && this.curConfig.savedViewType !== \"local\")\r\n      viewNames = viewNames.concat(context.externalSavedViews.map((x) => x.name));\r\n\r\n    return viewNames.filter((view) => matchRule(view, this.curConfig.viewName ?? \"*\")).sort();\r\n  }\r\n\r\n  private async finish(): Promise<void> {\r\n    let renderData = \"\\\"End of Tests-----------\\r\\n\";\r\n    const renderComp = IModelApp.queryRenderCompatibility();\r\n    if (renderComp.userAgent) {\r\n      renderData += `Browser: ${getBrowserName(renderComp.userAgent)}\\r\\n`;\r\n      renderData += `User Agent: ${renderComp.userAgent}\\r\\n`;\r\n    }\r\n    if (renderComp.unmaskedRenderer)\r\n      renderData += `Unmasked Renderer: ${renderComp.unmaskedRenderer}\\r\\n`;\r\n\r\n    if (renderComp.unmaskedVendor)\r\n      renderData += `Unmasked Vendor: ${renderComp.unmaskedVendor}\\r\\n`;\r\n\r\n    if (renderComp.missingRequiredFeatures)\r\n      renderData += `Missing Required Features: ${renderComp.missingRequiredFeatures}\\r\\n`;\r\n\r\n    if (renderComp.missingOptionalFeatures)\r\n      renderData += `Missing Optional Features: ${renderComp.missingOptionalFeatures}\"\\r\\n`;\r\n\r\n    await DisplayPerfRpcInterface.getClient().finishCsv(renderData, this.curConfig.outputPath, this.curConfig.outputName, this.curConfig.csvFormat);\r\n    await this.logToConsole(\"Tests complete. Press Ctrl-C to exit.\");\r\n  }\r\n\r\n  private async saveCsv(row: Map<string, number | string>): Promise<void> {\r\n    const outputPath = this.curConfig.outputPath;\r\n    const outputName = this.curConfig.outputName;\r\n    const msg = JSON.stringify([...row]);\r\n    return DisplayPerfRpcInterface.getClient().saveCsv(outputPath, outputName, msg, this.curConfig.csvFormat);\r\n  }\r\n\r\n  private async logToFile(message: string, opts?: { noAppend?: boolean, noNewLine?: boolean }): Promise<void> {\r\n    if (!opts?.noNewLine)\r\n      message = `${message}\\n`;\r\n\r\n    const append = !opts?.noAppend;\r\n    return DisplayPerfRpcInterface.getClient().writeExternalFile(this.curConfig.outputPath, this._logFileName, append, message);\r\n  }\r\n\r\n  private async logToConsole(message: string): Promise<void> {\r\n    return DisplayPerfRpcInterface.getClient().consoleLog(message);\r\n  }\r\n\r\n  private async logError(message: string): Promise<void> {\r\n    const msg = `ERROR: ${message}`;\r\n    await this.logToConsole(msg);\r\n    return this.logToFile(msg);\r\n  }\r\n\r\n  private getTestName(test: TestCase, prefix?: string, isImage = false, ignoreDupes = false): string {\r\n    let testName = prefix ?? \"\";\r\n    const configs = this.curConfig;\r\n\r\n    testName += configs.iModelName.replace(/\\.[^/.]+$/, \"\");\r\n    testName += `_${configs.viewName}`;\r\n    testName += configs.displayStyle ? `_${configs.displayStyle.trim()}` : \"\";\r\n    testName = testName.replace(/[/\\\\?%*:|\"<>]/g, \"-\");\r\n\r\n    const renderMode = getRenderMode(test.viewport);\r\n    if (renderMode)\r\n      testName += `_${renderMode}`;\r\n\r\n    const vf = getViewFlagsString(test);\r\n    if (vf)\r\n      testName += `_${vf}`;\r\n\r\n    const renderOpts = getRenderOpts(configs.renderOptions);\r\n    if (renderOpts)\r\n      testName += `_${renderOpts}`;\r\n\r\n    const tileProps = configs.tileProps ? getTileProps(configs.tileProps) : undefined;\r\n    if (tileProps)\r\n      testName += `_${tileProps}`;\r\n\r\n    const map = getBackgroundMapProps(test.viewport);\r\n    if (map)\r\n      testName += `_${map}`;\r\n\r\n    const hyper = getHyperModelingProps(configs.hyperModeling);\r\n    if (hyper)\r\n      testName += `_${hyper}`;\r\n\r\n    const other = getOtherProps(test.viewport);\r\n    if (other)\r\n      testName += `_${other}`;\r\n\r\n    testName = removeOptsFromString(testName, configs.filenameOptsToIgnore);\r\n    if (!ignoreDupes) {\r\n      let testNum = isImage ? this._testNamesImages.get(testName) : this._testNamesTimings.get(testName);\r\n      if (testNum === undefined)\r\n        testNum = 0;\r\n\r\n      testName += (testNum > 1) ? (`---${testNum}`) : \"\";\r\n    }\r\n\r\n    return testName;\r\n  }\r\n\r\n  private getImageName(test: TestCase, prefix?: string): string {\r\n    const filename = `${this.getTestName(test, prefix, true)}.png`;\r\n    if (ProcessDetector.isMobileAppFrontend)\r\n      return filename; // on mobile we use device's Documents path as determined by mobile backend\r\n    return `${this.curConfig.outputPath}${separator}${filename}`;\r\n  }\r\n\r\n  private getRowData(timings: Timings, test: TestCase, pixSelectStr?: string): Map<string, number | string> {\r\n    const fixed = 4;\r\n    const configs = this.curConfig;\r\n    const rowData = new Map<string, number | string>();\r\n\r\n    rowData.set(\"iModel\", configs.iModelName);\r\n    rowData.set(\"View\", configs.viewName);\r\n\r\n    const w = test.viewport.cssPixelsToDevicePixels(configs.view.width);\r\n    const h = test.viewport.cssPixelsToDevicePixels(configs.view.height);\r\n    rowData.set(\"Screen Size\", `${w}X${h}`);\r\n\r\n    rowData.set(\"Skip & Time Renders\", `${configs.numRendersToSkip} & ${configs.numRendersToTime}`);\r\n    rowData.set(\"Display Style\", test.viewport.displayStyle.name);\r\n    rowData.set(\"Render Mode\", getRenderMode(test.viewport));\r\n    rowData.set(\"View Flags\", getViewFlagsString(test) !== \"\" ? ` ${getViewFlagsString(test)}` : \"\");\r\n    rowData.set(\"Render Options\", getRenderOpts(configs.renderOptions) !== \"\" ? ` ${getRenderOpts(configs.renderOptions)}` : \"\");\r\n\r\n    const tileProps = configs.tileProps ? getTileProps(configs.tileProps) : \"\";\r\n    rowData.set(\"Tile Props\", \"\" !== tileProps ? ` ${tileProps}` : \"\");\r\n    rowData.set(\"Bkg Map Props\", getBackgroundMapProps(test.viewport) !== \"\" ? ` ${getBackgroundMapProps(test.viewport)}` : \"\");\r\n    rowData.set(\"HyperModeling\", getHyperModelingProps(configs.hyperModeling) ?? \"\");\r\n\r\n    const other = getOtherProps(test.viewport);\r\n    if (\"\" !== other)\r\n      rowData.set(\"Other Props\", ` ${other}`);\r\n\r\n    if (pixSelectStr)\r\n      rowData.set(\"ReadPixels Selector\", ` ${pixSelectStr}`);\r\n\r\n    rowData.set(\"Test Name\", this.getTestName(test));\r\n    rowData.set(\"Browser\", getBrowserName(IModelApp.queryRenderCompatibility().userAgent));\r\n    if (!this._minimizeOutput) {\r\n      rowData.set(\"Tile Loading Time\", test.tileLoadingTime);\r\n      rowData.set(\"Num Selected Tiles\", test.numSelectedTiles);\r\n      rowData.set(\"Selected Tile GPU MB\", test.selectedTileGpuBytes / (1024 * 1024));\r\n      rowData.set(\"Tile Tree GPU MB\", test.viewedTileTreeGpuBytes / (1024 * 1024));\r\n      rowData.set(\"Total GPU MB\", test.totalGpuBytes / (1024 * 1024));\r\n    }\r\n\r\n    const setGpuData = (name: string) => {\r\n      if (name === \"CPU Total Time\")\r\n        name = \"Total\";\r\n\r\n      const gpuDataArray = timings.gpu.get(name);\r\n      if (gpuDataArray) {\r\n        let gpuSum = 0;\r\n        for (const gpuData of gpuDataArray)\r\n          gpuSum += gpuData;\r\n\r\n        rowData.set(`GPU-${name}`, gpuDataArray.length ? (gpuSum / gpuDataArray.length).toFixed(fixed) : gpuSum.toFixed(fixed));\r\n      }\r\n    };\r\n\r\n    // Calculate average timings\r\n    if (pixSelectStr) { // timing read pixels\r\n      for (const colName of timings.cpu[0].keys()) {\r\n        let sum = 0;\r\n        timings.cpu.forEach((timing) => {\r\n          const data = timing.get(colName);\r\n          sum += data ? data : 0;\r\n        });\r\n\r\n        if (!this._minimizeOutput || colName === \"CPU Total Time\") {\r\n          rowData.set(colName, (sum / timings.cpu.length).toFixed(fixed));\r\n          setGpuData(colName);\r\n        }\r\n      }\r\n    } else { // timing render frame\r\n      for (const colName of timings.actualFps[0].keys()) {\r\n        let sum = 0;\r\n        timings.actualFps.forEach((timing) => {\r\n          const data = timing.get(colName);\r\n          sum += data ? data : 0;\r\n        });\r\n\r\n        if (!this._minimizeOutput || colName === \"CPU Total Time\") {\r\n          rowData.set(colName, sum / timings.actualFps.length);\r\n          setGpuData(colName);\r\n        }\r\n      }\r\n    }\r\n\r\n    let totalTime: number;\r\n    if (rowData.get(\"Finish GPU Queue\")) { // If we can't collect GPU data, get non-interactive total time with 'Finish GPU Queue' time\r\n      totalTime = Number(rowData.get(\"CPU Total Time\")) + Number(rowData.get(\"Finish GPU Queue\"));\r\n      rowData.set(\"GPU Total Time\", totalTime);\r\n    }\r\n\r\n    // Get these values from the timings.actualFps -- timings.actualFps === timings.cpu, unless in readPixels mode\r\n    let totalRenderTime = 0;\r\n    totalTime = 0;\r\n    for (const time of timings.actualFps) {\r\n      let timing = time.get(\"CPU Total Time\");\r\n      totalRenderTime += timing ? timing : 0;\r\n      timing = time.get(\"Total Time\");\r\n      totalTime += timing ? timing : 0;\r\n    }\r\n\r\n    rowData.delete(\"Total Time\");\r\n    totalRenderTime /= timings.actualFps.length; // ie the CPU Total Time\r\n    totalTime /= timings.actualFps.length;\r\n    const disjointTimerUsed = rowData.get(\"GPU-Total\") !== undefined;\r\n    const totalGpuTime = Number(disjointTimerUsed ? rowData.get(\"GPU-Total\") : rowData.get(\"GPU Total Time\"));\r\n    const gpuTolerance = disjointTimerUsed ? 2 : 3;\r\n    const gpuBound = (totalGpuTime - totalRenderTime) > gpuTolerance;\r\n    const cpuBound = disjointTimerUsed ? (((totalRenderTime - totalGpuTime) > gpuTolerance) && (totalRenderTime > 2)) : !gpuBound;\r\n    let boundBy = \"\";\r\n    if (totalRenderTime < 2 && !gpuBound) // ie total cpu time < 2ms && !gpuBound\r\n      boundBy = \"unmeasurable\";\r\n    else if (!gpuBound && !cpuBound)\r\n      boundBy = \"unknown\";\r\n    else if (gpuBound)\r\n      boundBy = \"gpu\";\r\n    else\r\n      boundBy = \"CPU\";\r\n    if ((1000.0 / totalTime) > 59) // ie actual fps > 60fps - 1fps tolerance\r\n      boundBy += \" (vsync)\";\r\n    const totalCpuTime = totalRenderTime > 2 ? totalRenderTime : 2; // add 2ms lower bound to cpu total time for tolerance\r\n    const effectiveFps = 1000.0 / (gpuBound ? totalGpuTime : totalCpuTime);\r\n    if (disjointTimerUsed) {\r\n      rowData.set(\"GPU Total Time\", totalGpuTime.toFixed(fixed));\r\n      rowData.delete(\"GPU-Total\");\r\n    }\r\n    rowData.set(\"Bound By\", boundBy);\r\n    rowData.set(\"Effective Total Time\", gpuBound ? totalGpuTime.toFixed(fixed) : totalCpuTime.toFixed(fixed)); // This is the total gpu time if gpu bound or the total cpu time if cpu bound; times gather with running continuously\r\n    rowData.set(\"Effective FPS\", effectiveFps.toFixed(fixed));\r\n    rowData.set(\"Actual Total Time\", totalTime.toFixed(fixed));\r\n    rowData.set(\"Actual FPS\", totalTime > 0.0 ? (1000.0 / totalTime).toFixed(fixed) : \"0\");\r\n\r\n    return rowData;\r\n  }\r\n\r\n  private async createReadPixelsImages(test: TestCase, pix: Pixel.Selector, pixStr: string): Promise<void> {\r\n    const vp = test.viewport;\r\n    const canvas = vp.readImageToCanvas();\r\n    const ctx = canvas.getContext(\"2d\");\r\n    if (!ctx)\r\n      return;\r\n\r\n    const cssRect = new ViewRect(0, 0, this.curConfig.view.width, this.curConfig.view.height);\r\n    const imgWidth = vp.cssPixelsToDevicePixels(cssRect.width);\r\n    const imgHeight = vp.cssPixelsToDevicePixels(cssRect.height);\r\n\r\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n    const elemIdImgData = (pix & Pixel.Selector.Feature) ? ctx.createImageData(imgWidth, imgHeight) : undefined;\r\n    const depthImgData = (pix & Pixel.Selector.GeometryAndDistance) ? ctx.createImageData(imgWidth, imgHeight) : undefined;\r\n    const typeImgData = (pix & Pixel.Selector.GeometryAndDistance) ? ctx.createImageData(imgWidth, imgHeight) : undefined;\r\n\r\n    vp.readPixels(cssRect, pix, (pixels) => {\r\n      if (!pixels)\r\n        return;\r\n\r\n      for (let y = 0; y < imgHeight; ++y) {\r\n        for (let x = 0; x < imgWidth; ++x) {\r\n          const index = (x * 4) + (y * 4 * imgWidth);\r\n          const pixel = pixels.getPixel(x, y);\r\n\r\n          // RGB for element ID\r\n          if (elemIdImgData !== undefined) {\r\n            const elemId = Id64.getLowerUint32(pixel.elementId ? pixel.elementId : \"\");\r\n            elemIdImgData.data[index + 0] = elemId % 256;\r\n            elemIdImgData.data[index + 1] = (Math.floor(elemId / 256)) % 256;\r\n            elemIdImgData.data[index + 2] = (Math.floor(elemId / (256 ^ 2))) % 256;\r\n            elemIdImgData.data[index + 3] = 255; // Set alpha to 100% opaque\r\n          }\r\n\r\n          // RGB for Depth\r\n          if (depthImgData !== undefined) {\r\n            const distColor = pixels.getPixel(x, y).distanceFraction * 255;\r\n            depthImgData.data[index + 0] = depthImgData.data[index + 1] = depthImgData.data[index + 2] = distColor;\r\n            depthImgData.data[index + 3] = 255; // Set alpha to 100% opaque\r\n          }\r\n\r\n          // RGB for type\r\n          if (typeImgData !== undefined) {\r\n            const type = pixels.getPixel(x, y).type;\r\n            switch (type) {\r\n              case Pixel.GeometryType.None: // White\r\n                typeImgData.data[index + 0] = 255;\r\n                typeImgData.data[index + 1] = 255;\r\n                typeImgData.data[index + 2] = 255;\r\n                break;\r\n              case Pixel.GeometryType.Surface: // Red\r\n                typeImgData.data[index + 0] = 255;\r\n                typeImgData.data[index + 1] = 0;\r\n                typeImgData.data[index + 2] = 0;\r\n                break;\r\n              case Pixel.GeometryType.Linear: // Green\r\n                typeImgData.data[index + 0] = 0;\r\n                typeImgData.data[index + 1] = 255;\r\n                typeImgData.data[index + 2] = 0;\r\n                break;\r\n              case Pixel.GeometryType.Edge: // Blue\r\n                typeImgData.data[index + 0] = 0;\r\n                typeImgData.data[index + 1] = 0;\r\n                typeImgData.data[index + 2] = 255;\r\n                break;\r\n              case Pixel.GeometryType.Silhouette: // Purple\r\n                typeImgData.data[index + 0] = 255;\r\n                typeImgData.data[index + 1] = 0;\r\n                typeImgData.data[index + 2] = 255;\r\n                break;\r\n              case Pixel.GeometryType.Unknown: // Black\r\n              default:\r\n                typeImgData.data[index + 0] = 0;\r\n                typeImgData.data[index + 1] = 0;\r\n                typeImgData.data[index + 2] = 0;\r\n                break;\r\n            }\r\n\r\n            typeImgData.data[index + 3] = 255; // Set alpha to 100% opaque\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    if (elemIdImgData !== undefined) {\r\n      ctx.putImageData(elemIdImgData, 0, 0);\r\n      await savePng(this.getImageName(test, `elemId_${pixStr}_`), canvas);\r\n    }\r\n\r\n    if (depthImgData !== undefined) {\r\n      ctx.putImageData(depthImgData, 0, 0);\r\n      await savePng(this.getImageName(test, `depth_${pixStr}_`), canvas);\r\n    }\r\n\r\n    if (typeImgData !== undefined) {\r\n      ctx.putImageData(typeImgData, 0, 0);\r\n      await savePng(this.getImageName(test, `type_${pixStr}_`), canvas);\r\n    }\r\n  }\r\n\r\n  private async onException(ex: any): Promise<void> {\r\n    // We need to log here so it gets written to the file.\r\n    await DisplayPerfTestApp.logException(ex, { dir: this.curConfig.outputPath, name: this._logFileName });\r\n    if (\"terminate\" === this.curConfig.onException)\r\n      await DisplayPerfRpcInterface.getClient().terminate();\r\n  }\r\n}\r\n\r\nfunction removeOptsFromString(input: string, ignore: string[] | string | undefined): string {\r\n  if (!ignore)\r\n    return input;\r\n\r\n  let output = input;\r\n  if (!(ignore instanceof Array))\r\n    ignore = ignore.split(\" \");\r\n\r\n  ignore.forEach((del: string) => {\r\n    output = output.replace(del, \"\");\r\n  });\r\n\r\n  output = output.replace(/__+/, \"_\");\r\n  if (output[output.length - 1] === \"_\")\r\n    output = output.slice(0, output.length - 1);\r\n\r\n  return output;\r\n}\r\n\r\nfunction getRenderMode(vp: ScreenViewport): string {\r\n  switch (vp.viewFlags.renderMode) {\r\n    case RenderMode.Wireframe: return \"Wireframe\";\r\n    case RenderMode.HiddenLine: return \"HiddenLine\";\r\n    case RenderMode.SolidFill: return \"SolidFill\";\r\n    case RenderMode.SmoothShade: return \"SmoothShade\";\r\n    default: return \"\";\r\n  }\r\n}\r\n\r\nfunction getRenderOpts(opts: RenderSystem.Options): string {\r\n  let optString = \"\";\r\n  for (const propName of Object.keys(opts)) {\r\n    const key = propName as keyof RenderSystem.Options;\r\n    switch (key) {\r\n      case \"disabledExtensions\": {\r\n        const extensions = opts[key];\r\n        if (extensions) {\r\n          for (const ext of extensions) {\r\n            switch (ext) {\r\n              case \"WEBGL_draw_buffers\":\r\n                optString += \"-drawBuf\";\r\n                break;\r\n              case \"OES_element_index_uint\":\r\n                optString += \"-unsignedInt\";\r\n                break;\r\n              case \"OES_texture_float\":\r\n                optString += \"-texFloat\";\r\n                break;\r\n              case \"OES_texture_half_float\":\r\n                optString += \"-texHalfFloat\";\r\n                break;\r\n              case \"WEBGL_depth_texture\":\r\n                optString += \"-depthTex\";\r\n                break;\r\n              case \"EXT_color_buffer_float\":\r\n                optString += \"-floats\";\r\n                break;\r\n              case \"EXT_shader_texture_lod\":\r\n                optString += \"-texLod\";\r\n                break;\r\n              case \"ANGLE_instanced_arrays\":\r\n                optString += \"-instArrays\";\r\n                break;\r\n              case \"EXT_frag_depth\":\r\n                optString += \"-fragDepth\";\r\n                break;\r\n            }\r\n          }\r\n        }\r\n        break;\r\n      }\r\n      case \"displaySolarShadows\":\r\n        if (!opts[key])\r\n          optString += \"-solShd\";\r\n\r\n        break;\r\n      case \"useWebGL2\":\r\n        if (opts[key])\r\n          optString += \"+webGL2\";\r\n\r\n        break;\r\n      case \"antialiasSamples\": {\r\n        const value = opts[key];\r\n        if (undefined !== value && value > 1)\r\n          optString += `+aa${value}`;\r\n\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  return optString;\r\n}\r\n\r\nfunction getTileProps(props: TileAdmin.Props): string {\r\n  let tilePropsStr = \"\";\r\n\r\n  for (const propName of Object.keys(props)) {\r\n    const key = propName as keyof TileAdmin.Props;\r\n    switch (key) {\r\n      case \"enableInstancing\":\r\n        if (props[key])\r\n          tilePropsStr += \"+inst\";\r\n\r\n        break;\r\n      case \"disableMagnification\":\r\n        if (props[key])\r\n          tilePropsStr += \"-mag\";\r\n\r\n        break;\r\n      case \"enableIndexedEdges\":\r\n        if (!props[key])\r\n          tilePropsStr += \"-idxEdg\";\r\n\r\n        break;\r\n      case \"generateAllPolyfaceEdges\":\r\n        if (!props[key])\r\n          tilePropsStr += \"-pfEdg\";\r\n\r\n        break;\r\n    }\r\n  }\r\n\r\n  return tilePropsStr;\r\n}\r\n\r\nfunction getBackgroundMapProps(vp: ScreenViewport): string {\r\n  let bmPropsStr = \"\";\r\n  const layer = vp.displayStyle.settings.mapImagery.backgroundBase;\r\n  if (layer instanceof BaseMapLayerSettings && layer.provider) {\r\n    switch (layer.provider.name) {\r\n      case \"BingProvider\":\r\n        break;\r\n      case \"MapBoxProvider\":\r\n        bmPropsStr += \"MapBox\";\r\n        break;\r\n    }\r\n\r\n    switch (layer.provider.type) {\r\n      case BackgroundMapType.Hybrid:\r\n        break;\r\n      case BackgroundMapType.Aerial:\r\n        bmPropsStr += \"+aer\";\r\n        break;\r\n      case BackgroundMapType.Street:\r\n        bmPropsStr += \"+st\";\r\n        break;\r\n    }\r\n  }\r\n\r\n  const bmProps = vp.displayStyle.settings.backgroundMap;\r\n  if (bmProps.groundBias !== 0)\r\n    bmPropsStr += `+bias${bmProps.groundBias}`;\r\n\r\n  if (bmProps.applyTerrain)\r\n    bmPropsStr += \"+terr\";\r\n\r\n  if (bmProps.useDepthBuffer)\r\n    bmPropsStr += \"+depth\";\r\n\r\n  if (typeof (bmProps.transparency) === \"number\")\r\n    bmPropsStr += `+trans${bmProps.transparency}`;\r\n\r\n  return bmPropsStr;\r\n}\r\n\r\nfunction hiliteSettingsStr(settings: Hilite.Settings): string {\r\n  let hsStr = (settings.color.colors.r * 256 * 256 + settings.color.colors.g * 256 + settings.color.colors.b).toString(36).padStart(5, \"0\");\r\n  hsStr += (settings.silhouette * 256 * 256 + Math.round(settings.visibleRatio * 255) * 256 + Math.round(settings.hiddenRatio * 255)).toString(36).padStart(4, \"0\");\r\n  return hsStr.toUpperCase();\r\n}\r\n\r\nfunction getHyperModelingProps(props: HyperModelingProps | undefined): string | undefined {\r\n  if (!props)\r\n    return undefined;\r\n\r\n  const hm = `+hm${props.sectionDrawingLocationId}`;\r\n  return props.applySpatialView ? `${hm}+a` : hm;\r\n}\r\n\r\nfunction getOtherProps(vp: ScreenViewport): string {\r\n  let propsStr = \"\";\r\n  if (!Hilite.equalSettings(vp.hilite, defaultHilite))\r\n    propsStr += `+h${hiliteSettingsStr(vp.hilite)}`;\r\n\r\n  if (!Hilite.equalSettings(vp.emphasisSettings, defaultEmphasis))\r\n    propsStr += `+e${hiliteSettingsStr(vp.emphasisSettings)}`;\r\n\r\n  return propsStr;\r\n}\r\n\r\nconst viewFlagsPropsStrings = {\r\n  dimensions: \"-dim\",\r\n  patterns: \"-pat\",\r\n  weights: \"-wt\",\r\n  styles: \"-sty\",\r\n  transparency: \"-trn\",\r\n  fill: \"-fll\",\r\n  textures: \"-txt\",\r\n  materials: \"-mat\",\r\n  visibleEdges: \"+vsE\",\r\n  hiddenEdges: \"+hdE\",\r\n  shadows: \"+shd\",\r\n  clipVolume: \"-clp\",\r\n  constructions: \"+con\",\r\n  monochrome: \"+mno\",\r\n  backgroundMap: \"+bkg\",\r\n  ambientOcclusion: \"+ao\",\r\n  forceSurfaceDiscard: \"+fsd\",\r\n  thematicDisplay: \"+thematicDisplay\",\r\n  grid: \"+grid\",\r\n  whiteOnWhiteReversal: \"+wow\",\r\n  acsTriad: \"+acsTriad\",\r\n  wiremesh: \"+wm\",\r\n};\r\n\r\nfunction getViewFlagsString(test: TestCase): string {\r\n  let vfString = \"\";\r\n\r\n  // Lighting flag always comes first.\r\n  const vf = test.viewport.viewFlags;\r\n  if (vf.lighting && RenderMode.SmoothShade === vf.renderMode)\r\n    vfString = \"+lit\";\r\n\r\n  for (const propName of Object.keys(vf)) {\r\n    const key = propName as keyof typeof viewFlagsPropsStrings;\r\n    const abbrev = viewFlagsPropsStrings[key];\r\n    if (!abbrev)\r\n      continue;\r\n\r\n    assert(\"-\" === abbrev[0] || \"+\" === abbrev[0]);\r\n    const includeIf = \"+\" === abbrev[0];\r\n    if (vf[key] === includeIf)\r\n      vfString += abbrev;\r\n  }\r\n\r\n  if (undefined !== test.view.elementOverrides)\r\n    vfString += \"+ovrEl\";\r\n\r\n  if (undefined !== test.view.selectedElements)\r\n    vfString += \"+selEl\";\r\n\r\n  return vfString;\r\n}\r\n\r\nfunction getBrowserName(userAgent: string): string {\r\n  const lowUserAgent = userAgent.toLowerCase();\r\n  if (lowUserAgent.includes(\"electron\"))\r\n    return \"Electron\";\r\n  if (lowUserAgent.includes(\"firefox\"))\r\n    return \"FireFox\";\r\n  if (lowUserAgent.includes(\"edge\"))\r\n    return \"Edge\";\r\n  if (lowUserAgent.includes(\"chrome\") && !userAgent.includes(\"chromium\"))\r\n    return \"Chrome\";\r\n  if (lowUserAgent.includes(\"safari\") && !userAgent.includes(\"chrome\") && !userAgent.includes(\"chromium\"))\r\n    return \"Safari\";\r\n  return \"Unknown\";\r\n}\r\n\r\n/** See https://stackoverflow.com/questions/26246601/wildcard-string-comparison-in-javascript\r\n * Compare strToTest with a given rule containing a wildcard, and will return true if strToTest matches the given wildcard\r\n * Make sure it is case-insensitive\r\n */\r\nfunction matchRule(strToTest: string, rule: string) {\r\n  strToTest = strToTest.toLowerCase();\r\n  rule = rule.toLowerCase();\r\n  const escapeRegex = (str: string) => str.replace(/([.*+?^=!:${}()|\\[\\]\\/\\\\])/g, \"\\\\$1\");\r\n  return new RegExp(`^${rule.split(\"*\").map(escapeRegex).join(\".*\")}$`).test(strToTest);\r\n}\r\n\r\ninterface SelectedTileStats {\r\n  /* A formatted string containing the Ids of all the tiles that were selected for display by the last call to waitForTilesToLoad(), of the format:\r\n   *  Selected Tiles:\r\n   *    TreeId1: tileId1,tileId2,...\r\n   *    TreeId2: tileId1,tileId2,...\r\n   *    ...\r\n   * Sorted by tree Id and then by tile Id so that the output is consistent from run to run unless the set of selected tiles changed between runs.\r\n   */\r\n  ids: string;\r\n  /** The number of selected tiles. */\r\n  count: number;\r\n  /** The number of bytes of memory allocated to the GPU for the selected tiles' graphics. */\r\n  gpuBytes: number;\r\n}\r\n\r\nfunction getSelectedTileStats(vp: ScreenViewport): SelectedTileStats {\r\n  let formattedSelectedTileIds = \"Selected tiles:\\n\";\r\n  let count = 0;\r\n  const mem = new RenderMemory.Statistics();\r\n  const dict = new Dictionary<string, SortedArray<string>>((lhs, rhs) => lhs.localeCompare(rhs));\r\n  for (const viewport of [vp, ...vp.view.secondaryViewports]) {\r\n    const selected = IModelApp.tileAdmin.getTilesForUser(viewport)?.selected;\r\n    if (!selected)\r\n      continue;\r\n\r\n    count += selected.size;\r\n    for (const tile of selected) {\r\n      const treeId = tile.tree.id;\r\n      let tileIds = dict.get(treeId);\r\n      if (!tileIds)\r\n        dict.set(treeId, tileIds = new SortedArray<string>((lhs, rhs) => lhs.localeCompare(rhs)));\r\n\r\n      tileIds.insert(tile.contentId);\r\n      tile.collectStatistics(mem);\r\n    }\r\n  }\r\n\r\n  for (const kvp of dict) {\r\n    const contentIds = kvp.value.extractArray().join(\",\");\r\n    const line = `  ${kvp.key}: ${contentIds}`;\r\n    formattedSelectedTileIds = `${formattedSelectedTileIds}${line}\\n`;\r\n  }\r\n\r\n  return {\r\n    ids: formattedSelectedTileIds,\r\n    count,\r\n    gpuBytes: mem.totalBytes,\r\n  };\r\n}\r\n\r\nfunction calcGpuBytes(func: (stats: RenderMemory.Statistics) => void): number {\r\n  const stats = new RenderMemory.Statistics();\r\n  func(stats);\r\n  return stats.totalBytes;\r\n}\r\n\r\nasync function savePng(fileName: string, canvas: HTMLCanvasElement): Promise<void> {\r\n  const img = canvas.toDataURL(\"image/png\");\r\n  const data = img.replace(/^data:image\\/\\w+;base64,/, \"\"); // strip off the data: url prefix to get just the base64-encoded bytes\r\n  return DisplayPerfRpcInterface.getClient().savePng(fileName, data);\r\n}\r\n\r\nfunction setPerformanceMetrics(vp: ScreenViewport, metrics: PerformanceMetrics | undefined): void {\r\n  (vp.target as Target).performanceMetrics = metrics;\r\n}\r\n"
        ],
        "mappings": "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",
        "names": []
      }
    },
    {
      "name": "vite:define",
      "result": "\"use strict\";\nimport { RealityDataAccessClient } from \"@itwin/reality-data-client\";\nimport {\n  assert,\n  Dictionary,\n  Id64,\n  ProcessDetector,\n  SortedArray,\n  StopWatch\n} from \"@itwin/core-bentley\";\nimport {\n  BackgroundMapType,\n  BaseMapLayerSettings,\n  FeatureAppearance,\n  Hilite,\n  RenderMode\n} from \"@itwin/core-common\";\nimport {\n  CheckpointConnection,\n  DisplayStyle3dState,\n  DisplayStyleState,\n  IModelApp,\n  PerformanceMetrics,\n  Pixel,\n  RenderMemory,\n  ScreenViewport,\n  SnapshotConnection,\n  ToolAdmin,\n  ViewRect,\n  ViewState\n} from \"@itwin/core-frontend\";\nimport { HyperModeling } from \"@itwin/hypermodeling-frontend\";\nimport { TestFrontendAuthorizationClient } from \"@itwin/oidc-signin-tool/lib/cjs/TestFrontendAuthorizationClient\";\nimport DisplayPerfRpcInterface from \"../common/DisplayPerfRpcInterface\";\nimport { DisplayPerfTestApp } from \"./DisplayPerformanceTestApp\";\nimport {\n  defaultEmphasis,\n  defaultHilite,\n  separator,\n  TestConfig,\n  TestConfigStack\n} from \"./TestConfig\";\nimport { SavedViewsFetcher } from \"./SavedViewsFetcher\";\nclass Timings {\n  constructor(numFramesToCollect) {\n    this.cpu = new Array();\n    this.gpu = /* @__PURE__ */ new Map();\n    this.actualFps = new Array();\n    this.gpuFramesCollected = 0;\n    this.callback = (result) => {\n      if (this.gpuFramesCollected >= numFramesToCollect)\n        return;\n      const label = result.label;\n      const timings = this.gpu.get(label);\n      this.gpu.set(label, timings ? timings.concat(result.nanoseconds / 1e6) : [result.nanoseconds / 1e6]);\n      if (result.children)\n        for (const child of result.children)\n          this.callback(child);\n      if (\"Total\" === label)\n        ++this.gpuFramesCollected;\n    };\n  }\n  set callbackEnabled(enabled) {\n    IModelApp.renderSystem.debugControl.resultsCallback = enabled ? this.callback : void 0;\n  }\n}\nclass OverrideProvider {\n  constructor(ovrs) {\n    this._elementOvrs = /* @__PURE__ */ new Map();\n    for (const ovr of ovrs) {\n      const app = FeatureAppearance.fromJSON(JSON.parse(ovr.fsa));\n      if (ovr.id === \"-default-\")\n        this._defaultOvrs = app;\n      else\n        this._elementOvrs.set(ovr.id, app);\n    }\n  }\n  static override(vp, ovrs) {\n    const provider = new OverrideProvider(ovrs);\n    vp.addFeatureOverrideProvider(provider);\n  }\n  addFeatureOverrides(ovrs) {\n    if (this._defaultOvrs)\n      ovrs.setDefaultOverrides(this._defaultOvrs);\n    for (const [elementId, appearance] of this._elementOvrs)\n      ovrs.override({ elementId, appearance });\n  }\n}\nexport class TestRunner {\n  constructor(props, savedViewsFetcher = new SavedViewsFetcher()) {\n    this._testNamesImages = /* @__PURE__ */ new Map();\n    this._testNamesTimings = /* @__PURE__ */ new Map();\n    const defaultTileProps = { minimumSpatialTolerance: 0 };\n    props.tileProps = props.tileProps ? { ...defaultTileProps, ...props.tileProps } : defaultTileProps;\n    this._config = new TestConfigStack(new TestConfig(props));\n    this._lastRestartConfig = this.curConfig;\n    this._testSets = props.testSet;\n    this._minimizeOutput = true === props.minimize;\n    this._logFileName = \"_DispPerfTestAppViewLog.txt\";\n    this._savedViewsFetcher = savedViewsFetcher;\n    ToolAdmin.exceptionHandler = async (ex) => this.onException(ex);\n  }\n  get curConfig() {\n    return this._config.top;\n  }\n  get lastRestartConfig() {\n    return this._lastRestartConfig;\n  }\n  set lastRestartConfig(config) {\n    this._lastRestartConfig = config;\n  }\n  /** Run all the tests. */\n  async run() {\n    const msg = `View Log,  Model Base Location: ${this.curConfig.iModelLocation}\n  format: Time_started  ModelName  [ViewName]`;\n    await this.logToConsole(msg);\n    await this.logToFile(msg, { noAppend: true });\n    let needRestart = this.curConfig.requiresRestart(new TestConfig({}));\n    const renderOptions = this.curConfig.renderOptions ?? {};\n    if (!this.curConfig.useDisjointTimer) {\n      const ext = this.curConfig.renderOptions?.disabledExtensions;\n      renderOptions.disabledExtensions = Array.isArray(ext) ? ext.concat([\"EXT_disjoint_timer_query\", \"EXT_disjoint_timer_query_webgl2\"]) : [\"EXT_disjoint_timer_query\", \"EXT_disjoint_timer_query_webgl2\"];\n      needRestart = true;\n    }\n    if (IModelApp.initialized && needRestart) {\n      await IModelApp.shutdown();\n    }\n    if (!IModelApp.initialized) {\n      const realityDataClientOptions = {\n        /** API Version. v1 by default */\n        // version?: ApiVersion;\n        /** API Url. Used to select environment. Defaults to \"https://api.bentley.com/realitydata\" */\n        baseUrl: `https://${{\"ALLUSERSPROFILE\":\"C:\\\\ProgramData\",\"ANDROID_NDK_ROOT\":\"d:\\\\android-ndk-r12b-windows-x86_64\\\\android-ndk-r12b\\\\\",\"APPDATA\":\"C:\\\\Users\\\\Earlin.Lutz\\\\AppData\\\\Roaming\",\"BBNODOC\":\"--buildDocDeferralRule=never\",\"BEGTEST_LOGGING_CONFIG\":\"d:\\\\hub2023A\\\\itwinjs-core\\\\BeGTest\\\\gtest\\\\logging.config.xml\",\"BUILDARCHITECTURE\":\"x64\",\"BUILDIMODEL_SYMLINKS\":\"1\",\"BUILDSTRATEGY\":\"TYPESCRIPT\",\"CD1\":\"d:\\\\hub2023A\\\\itwinjs-core\\\\core\\\\geometry\\\\\",\"CLANG_ENFORCE_OVERRIDE\":\"1\",\"COLOR\":\"0\",\"COMMONPROGRAMFILES\":\"C:\\\\Program Files\\\\Common Files\",\"COMMONPROGRAMFILES(X86)\":\"C:\\\\Program Files (x86)\\\\Common Files\",\"COMMONPROGRAMW6432\":\"C:\\\\Program Files\\\\Common Files\",\"COMPILEBGNETSTRUCTSBSPLINESUPPORT\":\"1\",\"COMPILEMTGBASE1\":\"1\",\"COMPILE_BVRANGETREE\":\"1\",\"COMPUTERNAME\":\"NAOU22376A\",\"COMSPEC\":\"C:\\\\Windows\\\\system32\\\\cmd.exe\",\"CONSOLECOLOR\":\"74\",\"CORESRC\":\"backend\\\\src clients\\\\src common\\\\src frontend\\\\src geometry\\\\src\",\"CUBESRC\":\"d:\\\\hub2023A\\\\itwinjs-core\\\\\\\\ui\\\\framework\\\\src\\\\configurableui\\\\navigationaids\\\\\",\"CUBETEST\":\"d:\\\\hub2023A\\\\itwinjs-core\\\\test-apps\\\\ui-test-app\\\\\",\"DEBUG\":\"1\",\"DRIVERDATA\":\"C:\\\\Windows\\\\System32\\\\Drivers\\\\DriverData\",\"EDITOR\":\"notepad.exe\",\"EXPAND_GEOMETRY_GENSRC\":\"1\",\"FPS_BROWSER_APP_PROFILE_STRING\":\"Internet Explorer\",\"FPS_BROWSER_USER_PROFILE_STRING\":\"Default\",\"GEMADIR\":\"d:\\\\source\\\\bsitools\\\\winnt\\\\gemascripts\\\\\",\"GEOMETRYCORE\":\"d:\\\\hub2023A\\\\itwinjs-core\\\\core\\\\geometry\\\\\",\"GEOMETRYROOT\":\"d:\\\\hub2023A\\\\itwinjs-core\\\\\\\\core\\\\geometry\",\"GEOMTESTOUTPUTDIR\":\"d:\\\\tmp\\\\geomtest\\\\\",\"GITBASEBRANCH\":\"master\",\"GITROOT\":\"hub2023A\",\"HGRCPATH\":\"C:\\\\DevTools\\\\Mercurial-BSI\\\\Mercurial\\\\mercurial.ini;%APPDATA%\\\\Mercurial-BSI\\\\mercurial.user.ini\",\"HOME\":\"C:\\\\Users\\\\Earlin.Lutz\",\"HOMEDRIVE\":\"C:\",\"HOMEPATH\":\"\\\\Users\\\\Earlin.Lutz\",\"INIT_CWD\":\"D:\\\\hub2023A\\\\itwinjs-core\\\\test-apps\\\\display-performance-test-app\",\"LOCALAPPDATA\":\"C:\\\\Users\\\\Earlin.Lutz\\\\AppData\\\\Local\",\"LOGONSERVER\":\"\\\\\\\\BENTLEYDC5\",\"METASRCPATH\":\"d:\\\\hub2023A\\\\itwinjs-core\\\\BentleyGeometryNet\\\\src\\\\Structs\\\\metasrc\\\\\",\"MS_ALLOW_EDIT_IMODEL\":\"1\",\"MS_FEATUREASPECTSBETA\":\"FeatureAspects_Interchange_RFA;FeatureAspects_Interchange_RFA_Import;FeatureAspects_Printing_Printing3D;FeatureAspects_Mesh_NewModify\",\"MS_IGNORE_ASSERTS\":\"1\",\"NODE\":\"C:\\\\Program Files\\\\nodejs\\\\node.exe\",\"NODE_ENV\":\"development\",\"NODE_EXE\":\"C:\\\\Program Files\\\\nodejs\\\\\\\\node.exe\",\"NODE_OPTIONS\":\"--max_old_space_size=8192\",\"NODE_PATH\":\"D:\\\\hub2023A\\\\itwinjs-core\\\\common\\\\temp\\\\node_modules\\\\.pnpm\\\\vite@4.4.9_@types+node@18.16.1\\\\node_modules\\\\vite\\\\bin\\\\node_modules;D:\\\\hub2023A\\\\itwinjs-core\\\\common\\\\temp\\\\node_modules\\\\.pnpm\\\\vite@4.4.9_@types+node@18.16.1\\\\node_modules\\\\vite\\\\node_modules;D:\\\\hub2023A\\\\itwinjs-core\\\\common\\\\temp\\\\node_modules\\\\.pnpm\\\\vite@4.4.9_@types+node@18.16.1\\\\node_modules;D:\\\\hub2023A\\\\itwinjs-core\\\\common\\\\temp\\\\node_modules\\\\.pnpm\\\\node_modules;D:\\\\hub2023A\\\\itwinjs-core\\\\common\\\\temp\\\\node_modules\\\\.pnpm\\\\cross-env@5.2.1\\\\node_modules\\\\cross-env\\\\dist\\\\bin\\\\node_modules;D:\\\\hub2023A\\\\itwinjs-core\\\\common\\\\temp\\\\node_modules\\\\.pnpm\\\\cross-env@5.2.1\\\\node_modules\\\\cross-env\\\\dist\\\\node_modules;D:\\\\hub2023A\\\\itwinjs-core\\\\common\\\\temp\\\\node_modules\\\\.pnpm\\\\cross-env@5.2.1\\\\node_modules\\\\cross-env\\\\node_modules;D:\\\\hub2023A\\\\itwinjs-core\\\\common\\\\temp\\\\node_modules\\\\.pnpm\\\\cross-env@5.2.1\\\\node_modules;D:\\\\hub2023A\\\\itwinjs-core\\\\common\\\\temp\\\\node_modules\\\\.pnpm\\\\node_modules\",\"NPM_CLI_JS\":\"C:\\\\Users\\\\Earlin.Lutz\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\npm\\\\bin\\\\npm-cli.js\",\"npm_command\":\"run-script\",\"npm_config_always_auth\":\"true\",\"npm_config_cache\":\"C:\\\\Users\\\\Earlin.Lutz\\\\AppData\\\\Local\\\\npm-cache\",\"npm_config_globalconfig\":\"C:\\\\Users\\\\Earlin.Lutz\\\\AppData\\\\Roaming\\\\npm\\\\etc\\\\npmrc\",\"npm_config_global_prefix\":\"C:\\\\Users\\\\Earlin.Lutz\\\\AppData\\\\Roaming\\\\npm\",\"npm_config_init_module\":\"C:\\\\Users\\\\Earlin.Lutz\\\\.npm-init.js\",\"npm_config_local_prefix\":\"D:\\\\hub2023A\\\\itwinjs-core\\\\test-apps\\\\display-performance-test-app\",\"npm_config_loglevel\":\"silent\",\"npm_config_metrics_registry\":\"https://registry.npmjs.org/\",\"npm_config_node_gyp\":\"C:\\\\Users\\\\Earlin.Lutz\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\npm\\\\node_modules\\\\node-gyp\\\\bin\\\\node-gyp.js\",\"npm_config_noproxy\":\"\",\"npm_config_prefix\":\"C:\\\\Users\\\\Earlin.Lutz\\\\AppData\\\\Roaming\\\\npm\",\"npm_config_userconfig\":\"C:\\\\Users\\\\Earlin.Lutz\\\\.npmrc\",\"npm_config_user_agent\":\"npm/8.12.2 node/v18.14.1 win32 x64 workspaces/false\",\"npm_execpath\":\"C:\\\\Users\\\\Earlin.Lutz\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\npm\\\\bin\\\\npm-cli.js\",\"npm_lifecycle_event\":\"build:frontend-vite\",\"npm_lifecycle_script\":\"cross-env NODE_OPTIONS=--max_old_space_size=8192 vite build\",\"npm_node_execpath\":\"C:\\\\Program Files\\\\nodejs\\\\node.exe\",\"npm_package_engines_node\":\"^18.0.0\",\"npm_package_json\":\"D:\\\\hub2023A\\\\itwinjs-core\\\\test-apps\\\\display-performance-test-app\\\\package.json\",\"npm_package_name\":\"display-performance-test-app\",\"npm_package_version\":\"0.0.0\",\"NPM_PREFIX_NPM_CLI_JS\":\"C:\\\\Users\\\\Earlin.Lutz\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\npm\\\\bin\\\\npm-cli.js\",\"NUMBER_OF_PROCESSORS\":\"24\",\"ONEDRIVE\":\"C:\\\\Users\\\\Earlin.Lutz\\\\OneDrive - Bentley Systems, Inc\",\"ONEDRIVECOMMERCIAL\":\"C:\\\\Users\\\\Earlin.Lutz\\\\OneDrive - Bentley Systems, Inc\",\"OS\":\"Windows_NT\",\"OUTBASE\":\"d:\\\\hub2023A\\\\itwinjs-core\\\\\\\\core\\\\geometry\\\\lib\\\\\",\"OUTROOT\":\"d:\\\\hub2023A\\\\itwinjs-core\\\\\\\\core\\\\geometry\\\\lib\\\\\",\"PATH\":\"D:\\\\hub2023A\\\\itwinjs-core\\\\test-apps\\\\display-performance-test-app\\\\node_modules\\\\.bin;D:\\\\hub2023A\\\\itwinjs-core\\\\test-apps\\\\node_modules\\\\.bin;D:\\\\hub2023A\\\\itwinjs-core\\\\node_modules\\\\.bin;D:\\\\hub2023A\\\\node_modules\\\\.bin;D:\\\\node_modules\\\\.bin;C:\\\\Users\\\\Earlin.Lutz\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\npm\\\\node_modules\\\\@npmcli\\\\run-script\\\\lib\\\\node-gyp-bin;D:\\\\hub2023A\\\\itwinjs-core\\\\test-apps\\\\display-performance-test-app\\\\node_modules\\\\.bin;D:\\\\hub2023A\\\\itwinjs-core\\\\common\\\\temp\\\\node_modules\\\\.bin;C:\\\\Program Files (x86)\\\\Microsoft SDKs\\\\Azure\\\\CLI2\\\\wbin;C:\\\\DevTools\\\\python38\\\\Scripts\\\\;C:\\\\DevTools\\\\python38\\\\;C:\\\\Windows\\\\system32;C:\\\\Windows;C:\\\\Windows\\\\System32\\\\Wbem;C:\\\\Windows\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\;C:\\\\Windows\\\\System32\\\\OpenSSH\\\\;C:\\\\DevTools\\\\Mercurial-BSI\\\\Mercurial\\\\;C:\\\\DevTools\\\\Mercurial-BSI\\\\KDiff3\\\\;C:\\\\Program Files\\\\TortoiseHg\\\\;C:\\\\Program Files\\\\Microsoft SQL Server\\\\130\\\\Tools\\\\Binn\\\\;C:\\\\Program Files\\\\dotnet\\\\;C:\\\\Program Files\\\\Microsoft SQL Server\\\\Client SDK\\\\ODBC\\\\170\\\\Tools\\\\Binn\\\\;C:\\\\Program Files\\\\nodejs\\\\;c:\\\\DevTools\\\\Git\\\\cmd;C:\\\\Users\\\\Earlin.Lutz\\\\AppData\\\\Local\\\\Microsoft\\\\WindowsApps;C:\\\\devtools\\\\cvsnt\\\\;C:\\\\Users\\\\Earlin.Lutz\\\\AppData\\\\Local\\\\Programs\\\\Microsoft VS Code\\\\bin;C:\\\\Users\\\\Earlin.Lutz\\\\.dotnet\\\\tools;C:\\\\Users\\\\Earlin.Lutz\\\\AppData\\\\Roaming\\\\npm;c:\\\\bin\\\\;c:\\\\bin\\\\build\\\\;d:\\\\hub2023A\\\\itwinjs-core\\\\bsitools\\\\anycpu;\",\"PATHEXT\":\".COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JSE;.WSF;.WSH;.MSC;.PY;.PYW\",\"PROCESSOR_ARCHITECTURE\":\"AMD64\",\"PROCESSOR_IDENTIFIER\":\"Intel64 Family 6 Model 85 Stepping 4, GenuineIntel\",\"PROCESSOR_LEVEL\":\"6\",\"PROCESSOR_REVISION\":\"5504\",\"PROGRAMDATA\":\"C:\\\\ProgramData\",\"PROGRAMFILES\":\"C:\\\\Program Files\",\"PROGRAMFILES(X86)\":\"C:\\\\Program Files (x86)\",\"PROGRAMW6432\":\"C:\\\\Program Files\",\"PROMPT\":\"$P$G\",\"PSMODULEPATH\":\"C:\\\\Program Files\\\\WindowsPowerShell\\\\Modules;C:\\\\Windows\\\\system32\\\\WindowsPowerShell\\\\v1.0\\\\Modules\",\"PUBLIC\":\"C:\\\\Users\\\\Public\",\"RUSHSTACK_FILE_ERROR_BASE_FOLDER\":\"D:\\\\hub2023A\\\\itwinjs-core\",\"RUSH_INVOKED_FOLDER\":\"d:\\\\hub2023A\\\\itwinjs-core\\\\core\\\\geometry\",\"SESSIONNAME\":\"Console\",\"SRCROOT\":\"d:\\\\hub2023A\\\\itwinjs-core\\\\\",\"SYSTEMDRIVE\":\"C:\",\"SYSTEMROOT\":\"C:\\\\Windows\",\"TEMP\":\"C:\\\\Users\\\\EARLIN~1.LUT\\\\AppData\\\\Local\\\\Temp\",\"TESTAPPS\":\"d:\\\\hub2023A\\\\itwinjs-core\\\\test-apps\\\\\",\"TMP\":\"C:\\\\Users\\\\EARLIN~1.LUT\\\\AppData\\\\Local\\\\Temp\",\"TOOLCACHE\":\"d:\\\\toolcache\\\\\",\"UATDATA\":\"C:\\\\Windows\\\\CCM\\\\UATData\\\\D9F8C395-CAB8-491d-B8AC-179A1FE1BE77\",\"UIFRAMEWORK\":\"d:\\\\hub2023A\\\\itwinjs-core\\\\ui\\\\framework\\\\\",\"USERDNSDOMAIN\":\"BENTLEY.COM\",\"USERDOMAIN\":\"BENTLEY\",\"USERDOMAIN_ROAMINGPROFILE\":\"BENTLEY\",\"USERNAME\":\"Earlin.Lutz\",\"USERPROFILE\":\"C:\\\\Users\\\\Earlin.Lutz\",\"USE_NEW_BB\":\"1\",\"UTILROOT\":\"d:\\\\hub2023A\\\\itwinjs-core\\\\util\\\\\",\"WINDIR\":\"C:\\\\Windows\",\"WIPPARTENABLE_ANDROIDTOOLCACHE\":\"1\",\"_RUSH_LIB_PATH\":\"C:\\\\Users\\\\Earlin.Lutz\\\\.rush\\\\node-v18.14.1\\\\rush-5.99.0\\\\node_modules\\\\@microsoft\\\\rush-lib\\\\lib\\\\index.js\",\"_USTN_CONVERTASSERTSTOPRINTF\":\"1\",\"__PSLOCKDOWNPOLICY\":\"0\",\"__TAIL0__\":\"g\",\"__TAIL__\":\"d:\\\\hub2023A\\\\itwinjs-core\\\\core\\\\geometry\\\\\"}.IMJS_URL_PREFIX}api.bentley.com/realitydata`\n      };\n      await DisplayPerfTestApp.startup({\n        renderSys: renderOptions,\n        tileAdmin: this.curConfig.tileProps,\n        realityDataAccess: new RealityDataAccessClient(realityDataClientOptions)\n      });\n    }\n    this.lastRestartConfig = this.curConfig;\n    for (const set of this._testSets)\n      await this.runTestSet(set);\n    const topdiv = document.getElementById(\"topdiv\");\n    topdiv.style.display = \"block\";\n    topdiv.innerText = \"Tests Completed.\";\n    document.getElementById(\"imodel-viewport\").style.display = \"hidden\";\n    await this.finish();\n  }\n  async runTestSet(set) {\n    this._config.push(set);\n    const realityDataClientOptions = {\n      /** API Version. v1 by default */\n      // version?: ApiVersion;\n      /** API Url. Used to select environment. Defaults to \"https://api.bentley.com/realitydata\" */\n      baseUrl: `https://${{\"ALLUSERSPROFILE\":\"C:\\\\ProgramData\",\"ANDROID_NDK_ROOT\":\"d:\\\\android-ndk-r12b-windows-x86_64\\\\android-ndk-r12b\\\\\",\"APPDATA\":\"C:\\\\Users\\\\Earlin.Lutz\\\\AppData\\\\Roaming\",\"BBNODOC\":\"--buildDocDeferralRule=never\",\"BEGTEST_LOGGING_CONFIG\":\"d:\\\\hub2023A\\\\itwinjs-core\\\\BeGTest\\\\gtest\\\\logging.config.xml\",\"BUILDARCHITECTURE\":\"x64\",\"BUILDIMODEL_SYMLINKS\":\"1\",\"BUILDSTRATEGY\":\"TYPESCRIPT\",\"CD1\":\"d:\\\\hub2023A\\\\itwinjs-core\\\\core\\\\geometry\\\\\",\"CLANG_ENFORCE_OVERRIDE\":\"1\",\"COLOR\":\"0\",\"COMMONPROGRAMFILES\":\"C:\\\\Program Files\\\\Common Files\",\"COMMONPROGRAMFILES(X86)\":\"C:\\\\Program Files (x86)\\\\Common Files\",\"COMMONPROGRAMW6432\":\"C:\\\\Program Files\\\\Common Files\",\"COMPILEBGNETSTRUCTSBSPLINESUPPORT\":\"1\",\"COMPILEMTGBASE1\":\"1\",\"COMPILE_BVRANGETREE\":\"1\",\"COMPUTERNAME\":\"NAOU22376A\",\"COMSPEC\":\"C:\\\\Windows\\\\system32\\\\cmd.exe\",\"CONSOLECOLOR\":\"74\",\"CORESRC\":\"backend\\\\src clients\\\\src common\\\\src frontend\\\\src geometry\\\\src\",\"CUBESRC\":\"d:\\\\hub2023A\\\\itwinjs-core\\\\\\\\ui\\\\framework\\\\src\\\\configurableui\\\\navigationaids\\\\\",\"CUBETEST\":\"d:\\\\hub2023A\\\\itwinjs-core\\\\test-apps\\\\ui-test-app\\\\\",\"DEBUG\":\"1\",\"DRIVERDATA\":\"C:\\\\Windows\\\\System32\\\\Drivers\\\\DriverData\",\"EDITOR\":\"notepad.exe\",\"EXPAND_GEOMETRY_GENSRC\":\"1\",\"FPS_BROWSER_APP_PROFILE_STRING\":\"Internet Explorer\",\"FPS_BROWSER_USER_PROFILE_STRING\":\"Default\",\"GEMADIR\":\"d:\\\\source\\\\bsitools\\\\winnt\\\\gemascripts\\\\\",\"GEOMETRYCORE\":\"d:\\\\hub2023A\\\\itwinjs-core\\\\core\\\\geometry\\\\\",\"GEOMETRYROOT\":\"d:\\\\hub2023A\\\\itwinjs-core\\\\\\\\core\\\\geometry\",\"GEOMTESTOUTPUTDIR\":\"d:\\\\tmp\\\\geomtest\\\\\",\"GITBASEBRANCH\":\"master\",\"GITROOT\":\"hub2023A\",\"HGRCPATH\":\"C:\\\\DevTools\\\\Mercurial-BSI\\\\Mercurial\\\\mercurial.ini;%APPDATA%\\\\Mercurial-BSI\\\\mercurial.user.ini\",\"HOME\":\"C:\\\\Users\\\\Earlin.Lutz\",\"HOMEDRIVE\":\"C:\",\"HOMEPATH\":\"\\\\Users\\\\Earlin.Lutz\",\"INIT_CWD\":\"D:\\\\hub2023A\\\\itwinjs-core\\\\test-apps\\\\display-performance-test-app\",\"LOCALAPPDATA\":\"C:\\\\Users\\\\Earlin.Lutz\\\\AppData\\\\Local\",\"LOGONSERVER\":\"\\\\\\\\BENTLEYDC5\",\"METASRCPATH\":\"d:\\\\hub2023A\\\\itwinjs-core\\\\BentleyGeometryNet\\\\src\\\\Structs\\\\metasrc\\\\\",\"MS_ALLOW_EDIT_IMODEL\":\"1\",\"MS_FEATUREASPECTSBETA\":\"FeatureAspects_Interchange_RFA;FeatureAspects_Interchange_RFA_Import;FeatureAspects_Printing_Printing3D;FeatureAspects_Mesh_NewModify\",\"MS_IGNORE_ASSERTS\":\"1\",\"NODE\":\"C:\\\\Program Files\\\\nodejs\\\\node.exe\",\"NODE_ENV\":\"development\",\"NODE_EXE\":\"C:\\\\Program Files\\\\nodejs\\\\\\\\node.exe\",\"NODE_OPTIONS\":\"--max_old_space_size=8192\",\"NODE_PATH\":\"D:\\\\hub2023A\\\\itwinjs-core\\\\common\\\\temp\\\\node_modules\\\\.pnpm\\\\vite@4.4.9_@types+node@18.16.1\\\\node_modules\\\\vite\\\\bin\\\\node_modules;D:\\\\hub2023A\\\\itwinjs-core\\\\common\\\\temp\\\\node_modules\\\\.pnpm\\\\vite@4.4.9_@types+node@18.16.1\\\\node_modules\\\\vite\\\\node_modules;D:\\\\hub2023A\\\\itwinjs-core\\\\common\\\\temp\\\\node_modules\\\\.pnpm\\\\vite@4.4.9_@types+node@18.16.1\\\\node_modules;D:\\\\hub2023A\\\\itwinjs-core\\\\common\\\\temp\\\\node_modules\\\\.pnpm\\\\node_modules;D:\\\\hub2023A\\\\itwinjs-core\\\\common\\\\temp\\\\node_modules\\\\.pnpm\\\\cross-env@5.2.1\\\\node_modules\\\\cross-env\\\\dist\\\\bin\\\\node_modules;D:\\\\hub2023A\\\\itwinjs-core\\\\common\\\\temp\\\\node_modules\\\\.pnpm\\\\cross-env@5.2.1\\\\node_modules\\\\cross-env\\\\dist\\\\node_modules;D:\\\\hub2023A\\\\itwinjs-core\\\\common\\\\temp\\\\node_modules\\\\.pnpm\\\\cross-env@5.2.1\\\\node_modules\\\\cross-env\\\\node_modules;D:\\\\hub2023A\\\\itwinjs-core\\\\common\\\\temp\\\\node_modules\\\\.pnpm\\\\cross-env@5.2.1\\\\node_modules;D:\\\\hub2023A\\\\itwinjs-core\\\\common\\\\temp\\\\node_modules\\\\.pnpm\\\\node_modules\",\"NPM_CLI_JS\":\"C:\\\\Users\\\\Earlin.Lutz\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\npm\\\\bin\\\\npm-cli.js\",\"npm_command\":\"run-script\",\"npm_config_always_auth\":\"true\",\"npm_config_cache\":\"C:\\\\Users\\\\Earlin.Lutz\\\\AppData\\\\Local\\\\npm-cache\",\"npm_config_globalconfig\":\"C:\\\\Users\\\\Earlin.Lutz\\\\AppData\\\\Roaming\\\\npm\\\\etc\\\\npmrc\",\"npm_config_global_prefix\":\"C:\\\\Users\\\\Earlin.Lutz\\\\AppData\\\\Roaming\\\\npm\",\"npm_config_init_module\":\"C:\\\\Users\\\\Earlin.Lutz\\\\.npm-init.js\",\"npm_config_local_prefix\":\"D:\\\\hub2023A\\\\itwinjs-core\\\\test-apps\\\\display-performance-test-app\",\"npm_config_loglevel\":\"silent\",\"npm_config_metrics_registry\":\"https://registry.npmjs.org/\",\"npm_config_node_gyp\":\"C:\\\\Users\\\\Earlin.Lutz\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\npm\\\\node_modules\\\\node-gyp\\\\bin\\\\node-gyp.js\",\"npm_config_noproxy\":\"\",\"npm_config_prefix\":\"C:\\\\Users\\\\Earlin.Lutz\\\\AppData\\\\Roaming\\\\npm\",\"npm_config_userconfig\":\"C:\\\\Users\\\\Earlin.Lutz\\\\.npmrc\",\"npm_config_user_agent\":\"npm/8.12.2 node/v18.14.1 win32 x64 workspaces/false\",\"npm_execpath\":\"C:\\\\Users\\\\Earlin.Lutz\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\npm\\\\bin\\\\npm-cli.js\",\"npm_lifecycle_event\":\"build:frontend-vite\",\"npm_lifecycle_script\":\"cross-env NODE_OPTIONS=--max_old_space_size=8192 vite build\",\"npm_node_execpath\":\"C:\\\\Program Files\\\\nodejs\\\\node.exe\",\"npm_package_engines_node\":\"^18.0.0\",\"npm_package_json\":\"D:\\\\hub2023A\\\\itwinjs-core\\\\test-apps\\\\display-performance-test-app\\\\package.json\",\"npm_package_name\":\"display-performance-test-app\",\"npm_package_version\":\"0.0.0\",\"NPM_PREFIX_NPM_CLI_JS\":\"C:\\\\Users\\\\Earlin.Lutz\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\npm\\\\bin\\\\npm-cli.js\",\"NUMBER_OF_PROCESSORS\":\"24\",\"ONEDRIVE\":\"C:\\\\Users\\\\Earlin.Lutz\\\\OneDrive - Bentley Systems, Inc\",\"ONEDRIVECOMMERCIAL\":\"C:\\\\Users\\\\Earlin.Lutz\\\\OneDrive - Bentley Systems, Inc\",\"OS\":\"Windows_NT\",\"OUTBASE\":\"d:\\\\hub2023A\\\\itwinjs-core\\\\\\\\core\\\\geometry\\\\lib\\\\\",\"OUTROOT\":\"d:\\\\hub2023A\\\\itwinjs-core\\\\\\\\core\\\\geometry\\\\lib\\\\\",\"PATH\":\"D:\\\\hub2023A\\\\itwinjs-core\\\\test-apps\\\\display-performance-test-app\\\\node_modules\\\\.bin;D:\\\\hub2023A\\\\itwinjs-core\\\\test-apps\\\\node_modules\\\\.bin;D:\\\\hub2023A\\\\itwinjs-core\\\\node_modules\\\\.bin;D:\\\\hub2023A\\\\node_modules\\\\.bin;D:\\\\node_modules\\\\.bin;C:\\\\Users\\\\Earlin.Lutz\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\npm\\\\node_modules\\\\@npmcli\\\\run-script\\\\lib\\\\node-gyp-bin;D:\\\\hub2023A\\\\itwinjs-core\\\\test-apps\\\\display-performance-test-app\\\\node_modules\\\\.bin;D:\\\\hub2023A\\\\itwinjs-core\\\\common\\\\temp\\\\node_modules\\\\.bin;C:\\\\Program Files (x86)\\\\Microsoft SDKs\\\\Azure\\\\CLI2\\\\wbin;C:\\\\DevTools\\\\python38\\\\Scripts\\\\;C:\\\\DevTools\\\\python38\\\\;C:\\\\Windows\\\\system32;C:\\\\Windows;C:\\\\Windows\\\\System32\\\\Wbem;C:\\\\Windows\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\;C:\\\\Windows\\\\System32\\\\OpenSSH\\\\;C:\\\\DevTools\\\\Mercurial-BSI\\\\Mercurial\\\\;C:\\\\DevTools\\\\Mercurial-BSI\\\\KDiff3\\\\;C:\\\\Program Files\\\\TortoiseHg\\\\;C:\\\\Program Files\\\\Microsoft SQL Server\\\\130\\\\Tools\\\\Binn\\\\;C:\\\\Program Files\\\\dotnet\\\\;C:\\\\Program Files\\\\Microsoft SQL Server\\\\Client SDK\\\\ODBC\\\\170\\\\Tools\\\\Binn\\\\;C:\\\\Program Files\\\\nodejs\\\\;c:\\\\DevTools\\\\Git\\\\cmd;C:\\\\Users\\\\Earlin.Lutz\\\\AppData\\\\Local\\\\Microsoft\\\\WindowsApps;C:\\\\devtools\\\\cvsnt\\\\;C:\\\\Users\\\\Earlin.Lutz\\\\AppData\\\\Local\\\\Programs\\\\Microsoft VS Code\\\\bin;C:\\\\Users\\\\Earlin.Lutz\\\\.dotnet\\\\tools;C:\\\\Users\\\\Earlin.Lutz\\\\AppData\\\\Roaming\\\\npm;c:\\\\bin\\\\;c:\\\\bin\\\\build\\\\;d:\\\\hub2023A\\\\itwinjs-core\\\\bsitools\\\\anycpu;\",\"PATHEXT\":\".COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JSE;.WSF;.WSH;.MSC;.PY;.PYW\",\"PROCESSOR_ARCHITECTURE\":\"AMD64\",\"PROCESSOR_IDENTIFIER\":\"Intel64 Family 6 Model 85 Stepping 4, GenuineIntel\",\"PROCESSOR_LEVEL\":\"6\",\"PROCESSOR_REVISION\":\"5504\",\"PROGRAMDATA\":\"C:\\\\ProgramData\",\"PROGRAMFILES\":\"C:\\\\Program Files\",\"PROGRAMFILES(X86)\":\"C:\\\\Program Files (x86)\",\"PROGRAMW6432\":\"C:\\\\Program Files\",\"PROMPT\":\"$P$G\",\"PSMODULEPATH\":\"C:\\\\Program Files\\\\WindowsPowerShell\\\\Modules;C:\\\\Windows\\\\system32\\\\WindowsPowerShell\\\\v1.0\\\\Modules\",\"PUBLIC\":\"C:\\\\Users\\\\Public\",\"RUSHSTACK_FILE_ERROR_BASE_FOLDER\":\"D:\\\\hub2023A\\\\itwinjs-core\",\"RUSH_INVOKED_FOLDER\":\"d:\\\\hub2023A\\\\itwinjs-core\\\\core\\\\geometry\",\"SESSIONNAME\":\"Console\",\"SRCROOT\":\"d:\\\\hub2023A\\\\itwinjs-core\\\\\",\"SYSTEMDRIVE\":\"C:\",\"SYSTEMROOT\":\"C:\\\\Windows\",\"TEMP\":\"C:\\\\Users\\\\EARLIN~1.LUT\\\\AppData\\\\Local\\\\Temp\",\"TESTAPPS\":\"d:\\\\hub2023A\\\\itwinjs-core\\\\test-apps\\\\\",\"TMP\":\"C:\\\\Users\\\\EARLIN~1.LUT\\\\AppData\\\\Local\\\\Temp\",\"TOOLCACHE\":\"d:\\\\toolcache\\\\\",\"UATDATA\":\"C:\\\\Windows\\\\CCM\\\\UATData\\\\D9F8C395-CAB8-491d-B8AC-179A1FE1BE77\",\"UIFRAMEWORK\":\"d:\\\\hub2023A\\\\itwinjs-core\\\\ui\\\\framework\\\\\",\"USERDNSDOMAIN\":\"BENTLEY.COM\",\"USERDOMAIN\":\"BENTLEY\",\"USERDOMAIN_ROAMINGPROFILE\":\"BENTLEY\",\"USERNAME\":\"Earlin.Lutz\",\"USERPROFILE\":\"C:\\\\Users\\\\Earlin.Lutz\",\"USE_NEW_BB\":\"1\",\"UTILROOT\":\"d:\\\\hub2023A\\\\itwinjs-core\\\\util\\\\\",\"WINDIR\":\"C:\\\\Windows\",\"WIPPARTENABLE_ANDROIDTOOLCACHE\":\"1\",\"_RUSH_LIB_PATH\":\"C:\\\\Users\\\\Earlin.Lutz\\\\.rush\\\\node-v18.14.1\\\\rush-5.99.0\\\\node_modules\\\\@microsoft\\\\rush-lib\\\\lib\\\\index.js\",\"_USTN_CONVERTASSERTSTOPRINTF\":\"1\",\"__PSLOCKDOWNPOLICY\":\"0\",\"__TAIL0__\":\"g\",\"__TAIL__\":\"d:\\\\hub2023A\\\\itwinjs-core\\\\core\\\\geometry\\\\\"}.IMJS_URL_PREFIX}api.bentley.com/realitydata`\n    };\n    for (const testProps of set.tests) {\n      this._config.push(testProps);\n      if (IModelApp.initialized && this.curConfig.requiresRestart(this.lastRestartConfig)) {\n        await IModelApp.shutdown();\n      }\n      if (!IModelApp.initialized) {\n        const renderOptions = this.curConfig.renderOptions ?? {};\n        if (!this.curConfig.useDisjointTimer) {\n          const ext = this.curConfig.renderOptions?.disabledExtensions;\n          renderOptions.disabledExtensions = Array.isArray(ext) ? ext.concat([\"EXT_disjoint_timer_query\", \"EXT_disjoint_timer_query_webgl2\"]) : [\"EXT_disjoint_timer_query\", \"EXT_disjoint_timer_query_webgl2\"];\n        }\n        await DisplayPerfTestApp.startup({\n          renderSys: renderOptions,\n          tileAdmin: this.curConfig.tileProps,\n          realityDataAccess: new RealityDataAccessClient(realityDataClientOptions)\n        });\n        this.lastRestartConfig = this.curConfig;\n      }\n      const iModelNames = await this.getIModelNames();\n      const originalViewName = this.curConfig.viewName;\n      for (const iModelName of iModelNames) {\n        this.curConfig.iModelName = iModelName;\n        this.curConfig.viewName = originalViewName;\n        let context;\n        try {\n          context = await this.openIModel();\n        } catch (e) {\n          await this.logError(`Failed to open iModel ${iModelName}: ${e.message}`);\n          continue;\n        }\n        try {\n          await this.runTests(context);\n        } catch {\n          await this.logError(`Failed to run tests on iModel ${iModelName}`);\n        } finally {\n          await context.iModel.close();\n        }\n      }\n      this._config.pop();\n    }\n    this._config.pop();\n  }\n  async runTests(context) {\n    const viewNames = await this.getViewNames(context);\n    for (const viewName of viewNames) {\n      this.curConfig.viewName = viewName;\n      await this.logTest();\n      try {\n        this.curConfig.urlStr = void 0;\n        const result = await this.runTest(context);\n        if (this.curConfig.urlStr)\n          await this.logURL();\n        if (result)\n          await this.logToFile(result.selectedTileIds, { noNewLine: true });\n      } catch (ex) {\n        await this.onException(ex);\n      }\n    }\n  }\n  async runTest(context) {\n    const testConfig = this.curConfig;\n    document.title = \"Display Performance Test App:  \".concat(testConfig.iModelName ?? \"\", \"  [\", testConfig.viewName ?? \"\", \"]\");\n    const test = await this.setupTest(context);\n    if (!test)\n      return void 0;\n    const vp = test.viewport;\n    if (testConfig.testType === \"image\" || testConfig.testType === \"both\") {\n      this.updateTestNames(test, void 0, true);\n      const canvas = vp.readImageToCanvas();\n      await savePng(this.getImageName(test), canvas);\n      if (testConfig.testType === \"image\") {\n        vp.dispose();\n        return test;\n      }\n    }\n    for (let i = 0; i < this.curConfig.numRendersToSkip; i++) {\n      vp.requestRedraw();\n      vp.renderFrame();\n    }\n    this.updateTestNames(test);\n    await (testConfig.testType === \"readPixels\" ? this.recordReadPixels(test) : this.recordRender(test));\n    vp.dispose();\n    return test;\n  }\n  async recordReadPixels(test) {\n    const vp = test.viewport;\n    const viewRect = new ViewRect(0, 0, this.curConfig.view.width, this.curConfig.view.height);\n    const timings = new Timings(this.curConfig.numRendersToTime);\n    const testReadPix = async (pixSelect, pixSelectStr) => {\n      setPerformanceMetrics(vp, new PerformanceMetrics(true, false, void 0));\n      for (let i = 0; i < this.curConfig.numRendersToTime; ++i) {\n        vp.readPixels(viewRect, pixSelect, () => {\n        });\n        timings.cpu[i] = vp.target.performanceMetrics.frameTimings;\n        timings.cpu[i].delete(\"Scene Time\");\n      }\n      timings.gpuFramesCollected = 0;\n      timings.callbackEnabled = true;\n      setPerformanceMetrics(vp, new PerformanceMetrics(true, false, timings.callback));\n      await this.renderAsync(vp, this.curConfig.numRendersToTime, timings);\n      timings.callbackEnabled = false;\n      this.updateTestNames(test, pixSelectStr, true);\n      this.updateTestNames(test, pixSelectStr, false);\n      const row = this.getRowData(timings, test, pixSelectStr);\n      await this.saveCsv(row);\n      await this.createReadPixelsImages(test, pixSelect, pixSelectStr);\n    };\n    await testReadPix(Pixel.Selector.Feature, \"+feature\");\n    await testReadPix(Pixel.Selector.GeometryAndDistance, \"+geom+dist\");\n    await testReadPix(Pixel.Selector.All, \"+feature+geom+dist\");\n  }\n  async recordRender(test) {\n    const timings = new Timings(this.curConfig.numRendersToTime);\n    setPerformanceMetrics(test.viewport, new PerformanceMetrics(true, false, timings.callback));\n    await this.renderAsync(test.viewport, this.curConfig.numRendersToTime, timings);\n    const row = this.getRowData(timings, test);\n    await this.saveCsv(row);\n  }\n  async renderAsync(vp, numFrames, timings) {\n    IModelApp.viewManager.addViewport(vp);\n    const target = vp.target;\n    const metrics = target.performanceMetrics;\n    assert(void 0 !== metrics);\n    target.performanceMetrics = void 0;\n    timings.callbackEnabled = false;\n    const numFramesToIgnore = 120;\n    let ignoreFrameCount = 0;\n    let frameCount = 0;\n    vp.continuousRendering = true;\n    return new Promise((resolve, _reject) => {\n      const timer = new StopWatch();\n      const removeListener = vp.onRender.addListener(() => {\n        if (++ignoreFrameCount <= numFramesToIgnore) {\n          if (ignoreFrameCount === numFramesToIgnore) {\n            target.performanceMetrics = metrics;\n            timings.callbackEnabled = true;\n            timer.start();\n          }\n          return;\n        }\n        timer.stop();\n        timings.actualFps[frameCount] = metrics.frameTimings;\n        timings.actualFps[frameCount].set(\"Total Time\", timer.current.milliseconds);\n        if (++frameCount === numFrames)\n          target.performanceMetrics = void 0;\n        if (timings.gpuFramesCollected >= numFrames || frameCount >= numFrames && !IModelApp.renderSystem.isGLTimerSupported) {\n          removeListener();\n          IModelApp.viewManager.dropViewport(vp, false);\n          vp.continuousRendering = false;\n          timings.callbackEnabled = false;\n          resolve();\n        } else {\n          vp.requestRedraw();\n          timer.start();\n        }\n      });\n    });\n  }\n  async setupTest(context) {\n    const imodel = context.iModel;\n    const view = await this.loadView(context);\n    if (!view)\n      return void 0;\n    const viewport = this.openViewport(view.view);\n    const hyperModeling = this.curConfig.hyperModeling;\n    if (hyperModeling) {\n      try {\n        const decorator = await HyperModeling.start(viewport);\n        const marker = decorator?.markers.findMarkerById(hyperModeling.sectionDrawingLocationId);\n        if (!decorator) {\n          await this.logError(\"Failed to start hypermodeling.\");\n        } else if (!marker) {\n          await this.logError(`SectionDrawingLocation ${hyperModeling.sectionDrawingLocationId} not found.`);\n        } else {\n          if (hyperModeling.applySpatialView) {\n            await decorator.toggleSection(marker, true);\n          } else {\n            decorator.toggleClipVolume(marker, true);\n            await decorator.toggleAttachment(marker, true);\n          }\n        }\n      } catch (err) {\n        await DisplayPerfTestApp.logException(err, { dir: this.curConfig.outputPath, name: this._logFileName });\n      }\n    }\n    const config = this.curConfig;\n    if (config.hilite)\n      viewport.hilite = config.hilite;\n    if (config.emphasis)\n      viewport.emphasisSettings = config.emphasis;\n    if (config.displayStyle) {\n      const styleProps = await imodel.elements.queryProps({ from: DisplayStyleState.classFullName, where: `CodeValue='${config.displayStyle}'` });\n      if (styleProps.length >= 1) {\n        const style = new DisplayStyle3dState(styleProps[0], imodel);\n        await style.load();\n        viewport.view.setDisplayStyle(style);\n      }\n    }\n    if (config.viewFlags) {\n      const vf = viewport.viewFlags;\n      const configVf = config.viewFlags;\n      for (const key of Object.keys(vf)) {\n        const flag = configVf[key];\n        if (void 0 !== flag) {\n          if (key === \"renderMode\" && typeof flag === \"string\") {\n            switch (flag.toLowerCase()) {\n              case \"solidfill\":\n                vf.renderMode = RenderMode.SolidFill;\n                break;\n              case \"hiddenline\":\n                vf.renderMode = RenderMode.HiddenLine;\n                break;\n              case \"wireframe\":\n                vf.renderMode = RenderMode.Wireframe;\n                break;\n              case \"smoothshade\":\n                vf.renderMode = RenderMode.SmoothShade;\n                break;\n            }\n          } else {\n            vf[key] = flag;\n          }\n        } else {\n          configVf[key] = vf[key];\n        }\n      }\n    }\n    if (config.backgroundMap)\n      viewport.changeBackgroundMapProps(viewport.displayStyle.settings.backgroundMap.clone(config.backgroundMap).toJSON());\n    if (view.elementOverrides)\n      OverrideProvider.override(viewport, view.elementOverrides);\n    const result = await this.waitForTilesToLoad(viewport);\n    if (view.selectedElements) {\n      imodel.selectionSet.add(view.selectedElements);\n      viewport.markSelectionSetDirty();\n      viewport.renderFrame();\n    }\n    return { ...result, viewport, view };\n  }\n  async waitForTilesToLoad(viewport) {\n    const timer = new StopWatch(void 0, true);\n    await viewport.waitForSceneCompletion();\n    timer.stop();\n    const selectedTiles = getSelectedTileStats(viewport);\n    return {\n      tileLoadingTime: timer.current.milliseconds,\n      selectedTileIds: selectedTiles.ids,\n      numSelectedTiles: selectedTiles.count,\n      selectedTileGpuBytes: selectedTiles.gpuBytes,\n      viewedTileTreeGpuBytes: calcGpuBytes((stats) => viewport.collectStatistics(stats)),\n      totalGpuBytes: calcGpuBytes((stats) => {\n        viewport.target.renderSystem.collectStatistics(stats);\n        viewport.target.collectStatistics(stats);\n        viewport.iModel.tiles.forEachTreeOwner((owner) => owner.tileTree?.collectStatistics(stats));\n      })\n    };\n  }\n  openViewport(view) {\n    const div = document.getElementById(\"imodel-viewport\");\n    const ratio = false === IModelApp.renderSystem.options.dpiAwareViewports ? 1 : window.devicePixelRatio || 1;\n    const width = `${String(this.curConfig.view.width / ratio)}px`;\n    const height = `${String(this.curConfig.view.height / ratio)}px`;\n    div.style.width = width;\n    div.style.height = height;\n    const vp = ScreenViewport.create(div, view);\n    vp.rendersToScreen = true;\n    vp.canvas.style.width = width;\n    vp.canvas.style.height = height;\n    return vp;\n  }\n  async loadViewFromSpec(spec, context) {\n    const className = spec.viewProps.viewDefinitionProps.classFullName;\n    const ctor = await context.iModel.findClassFor(className, void 0);\n    const view = ctor?.createFromProps(spec.viewProps, context.iModel);\n    if (!view) {\n      await this.logError(\"Failed to create view from spec\");\n      return void 0;\n    }\n    await view.load();\n    return {\n      view,\n      elementOverrides: spec.elementOverrides,\n      selectedElements: spec.selectedElements\n    };\n  }\n  async loadView(context) {\n    const config = this.curConfig;\n    if (config.viewStateSpec)\n      return this.loadViewFromSpec(config.viewStateSpec, context);\n    if (config.extViewName) {\n      const spec = context.externalSavedViews.find((x) => x.name === config.extViewName);\n      if (spec)\n        return this.loadViewFromSpec(spec, context);\n      await this.logError(`Failed to find external saved view ${config.extViewName}`);\n      return void 0;\n    }\n    const ids = await context.iModel.elements.queryIds({ from: ViewState.classFullName, where: `CodeValue='${config.viewName}'` });\n    for (const id of ids)\n      return { view: await context.iModel.views.load(id) };\n    const extSpec = context.externalSavedViews.find((x) => x.name === config.viewName);\n    if (extSpec)\n      return this.loadViewFromSpec(extSpec, context);\n    await this.logError(`Failed to find persistent view ${config.viewName}`);\n    return void 0;\n  }\n  updateTestNames(test, prefix, isImage = false) {\n    const testNames = isImage ? this._testNamesImages : this._testNamesTimings;\n    const testName = this.getTestName(test, prefix, false, true);\n    const testNameDupes = testNames.get(testName) ?? 0;\n    testNames.set(testName, testNameDupes + 1);\n  }\n  async logTest() {\n    const testConfig = this.curConfig;\n    const today = /* @__PURE__ */ new Date();\n    const month = `0${today.getMonth() + 1}`.slice(-2);\n    const day = `0${today.getDate()}`.slice(-2);\n    const year = today.getFullYear();\n    const hours = `0${today.getHours()}`.slice(-2);\n    const minutes = `0${today.getMinutes()}`.slice(-2);\n    const seconds = `0${today.getSeconds()}`.slice(-2);\n    const outStr = `${year}-${month}-${day} ${hours}:${minutes}:${seconds}  ${testConfig.iModelName}  [${testConfig.viewName}]`;\n    await this.logToConsole(outStr);\n    return this.logToFile(outStr);\n  }\n  // Log url path for cases it is used\n  async logURL() {\n    const outStr = `  [url: ${this.curConfig.urlStr}]`;\n    await this.logToConsole(outStr);\n    return this.logToFile(outStr);\n  }\n  async openIModel() {\n    if (this.curConfig.iModelId) {\n      if ({\"ALLUSERSPROFILE\":\"C:\\\\ProgramData\",\"ANDROID_NDK_ROOT\":\"d:\\\\android-ndk-r12b-windows-x86_64\\\\android-ndk-r12b\\\\\",\"APPDATA\":\"C:\\\\Users\\\\Earlin.Lutz\\\\AppData\\\\Roaming\",\"BBNODOC\":\"--buildDocDeferralRule=never\",\"BEGTEST_LOGGING_CONFIG\":\"d:\\\\hub2023A\\\\itwinjs-core\\\\BeGTest\\\\gtest\\\\logging.config.xml\",\"BUILDARCHITECTURE\":\"x64\",\"BUILDIMODEL_SYMLINKS\":\"1\",\"BUILDSTRATEGY\":\"TYPESCRIPT\",\"CD1\":\"d:\\\\hub2023A\\\\itwinjs-core\\\\core\\\\geometry\\\\\",\"CLANG_ENFORCE_OVERRIDE\":\"1\",\"COLOR\":\"0\",\"COMMONPROGRAMFILES\":\"C:\\\\Program Files\\\\Common Files\",\"COMMONPROGRAMFILES(X86)\":\"C:\\\\Program Files (x86)\\\\Common Files\",\"COMMONPROGRAMW6432\":\"C:\\\\Program Files\\\\Common Files\",\"COMPILEBGNETSTRUCTSBSPLINESUPPORT\":\"1\",\"COMPILEMTGBASE1\":\"1\",\"COMPILE_BVRANGETREE\":\"1\",\"COMPUTERNAME\":\"NAOU22376A\",\"COMSPEC\":\"C:\\\\Windows\\\\system32\\\\cmd.exe\",\"CONSOLECOLOR\":\"74\",\"CORESRC\":\"backend\\\\src clients\\\\src common\\\\src frontend\\\\src geometry\\\\src\",\"CUBESRC\":\"d:\\\\hub2023A\\\\itwinjs-core\\\\\\\\ui\\\\framework\\\\src\\\\configurableui\\\\navigationaids\\\\\",\"CUBETEST\":\"d:\\\\hub2023A\\\\itwinjs-core\\\\test-apps\\\\ui-test-app\\\\\",\"DEBUG\":\"1\",\"DRIVERDATA\":\"C:\\\\Windows\\\\System32\\\\Drivers\\\\DriverData\",\"EDITOR\":\"notepad.exe\",\"EXPAND_GEOMETRY_GENSRC\":\"1\",\"FPS_BROWSER_APP_PROFILE_STRING\":\"Internet Explorer\",\"FPS_BROWSER_USER_PROFILE_STRING\":\"Default\",\"GEMADIR\":\"d:\\\\source\\\\bsitools\\\\winnt\\\\gemascripts\\\\\",\"GEOMETRYCORE\":\"d:\\\\hub2023A\\\\itwinjs-core\\\\core\\\\geometry\\\\\",\"GEOMETRYROOT\":\"d:\\\\hub2023A\\\\itwinjs-core\\\\\\\\core\\\\geometry\",\"GEOMTESTOUTPUTDIR\":\"d:\\\\tmp\\\\geomtest\\\\\",\"GITBASEBRANCH\":\"master\",\"GITROOT\":\"hub2023A\",\"HGRCPATH\":\"C:\\\\DevTools\\\\Mercurial-BSI\\\\Mercurial\\\\mercurial.ini;%APPDATA%\\\\Mercurial-BSI\\\\mercurial.user.ini\",\"HOME\":\"C:\\\\Users\\\\Earlin.Lutz\",\"HOMEDRIVE\":\"C:\",\"HOMEPATH\":\"\\\\Users\\\\Earlin.Lutz\",\"INIT_CWD\":\"D:\\\\hub2023A\\\\itwinjs-core\\\\test-apps\\\\display-performance-test-app\",\"LOCALAPPDATA\":\"C:\\\\Users\\\\Earlin.Lutz\\\\AppData\\\\Local\",\"LOGONSERVER\":\"\\\\\\\\BENTLEYDC5\",\"METASRCPATH\":\"d:\\\\hub2023A\\\\itwinjs-core\\\\BentleyGeometryNet\\\\src\\\\Structs\\\\metasrc\\\\\",\"MS_ALLOW_EDIT_IMODEL\":\"1\",\"MS_FEATUREASPECTSBETA\":\"FeatureAspects_Interchange_RFA;FeatureAspects_Interchange_RFA_Import;FeatureAspects_Printing_Printing3D;FeatureAspects_Mesh_NewModify\",\"MS_IGNORE_ASSERTS\":\"1\",\"NODE\":\"C:\\\\Program Files\\\\nodejs\\\\node.exe\",\"NODE_ENV\":\"development\",\"NODE_EXE\":\"C:\\\\Program Files\\\\nodejs\\\\\\\\node.exe\",\"NODE_OPTIONS\":\"--max_old_space_size=8192\",\"NODE_PATH\":\"D:\\\\hub2023A\\\\itwinjs-core\\\\common\\\\temp\\\\node_modules\\\\.pnpm\\\\vite@4.4.9_@types+node@18.16.1\\\\node_modules\\\\vite\\\\bin\\\\node_modules;D:\\\\hub2023A\\\\itwinjs-core\\\\common\\\\temp\\\\node_modules\\\\.pnpm\\\\vite@4.4.9_@types+node@18.16.1\\\\node_modules\\\\vite\\\\node_modules;D:\\\\hub2023A\\\\itwinjs-core\\\\common\\\\temp\\\\node_modules\\\\.pnpm\\\\vite@4.4.9_@types+node@18.16.1\\\\node_modules;D:\\\\hub2023A\\\\itwinjs-core\\\\common\\\\temp\\\\node_modules\\\\.pnpm\\\\node_modules;D:\\\\hub2023A\\\\itwinjs-core\\\\common\\\\temp\\\\node_modules\\\\.pnpm\\\\cross-env@5.2.1\\\\node_modules\\\\cross-env\\\\dist\\\\bin\\\\node_modules;D:\\\\hub2023A\\\\itwinjs-core\\\\common\\\\temp\\\\node_modules\\\\.pnpm\\\\cross-env@5.2.1\\\\node_modules\\\\cross-env\\\\dist\\\\node_modules;D:\\\\hub2023A\\\\itwinjs-core\\\\common\\\\temp\\\\node_modules\\\\.pnpm\\\\cross-env@5.2.1\\\\node_modules\\\\cross-env\\\\node_modules;D:\\\\hub2023A\\\\itwinjs-core\\\\common\\\\temp\\\\node_modules\\\\.pnpm\\\\cross-env@5.2.1\\\\node_modules;D:\\\\hub2023A\\\\itwinjs-core\\\\common\\\\temp\\\\node_modules\\\\.pnpm\\\\node_modules\",\"NPM_CLI_JS\":\"C:\\\\Users\\\\Earlin.Lutz\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\npm\\\\bin\\\\npm-cli.js\",\"npm_command\":\"run-script\",\"npm_config_always_auth\":\"true\",\"npm_config_cache\":\"C:\\\\Users\\\\Earlin.Lutz\\\\AppData\\\\Local\\\\npm-cache\",\"npm_config_globalconfig\":\"C:\\\\Users\\\\Earlin.Lutz\\\\AppData\\\\Roaming\\\\npm\\\\etc\\\\npmrc\",\"npm_config_global_prefix\":\"C:\\\\Users\\\\Earlin.Lutz\\\\AppData\\\\Roaming\\\\npm\",\"npm_config_init_module\":\"C:\\\\Users\\\\Earlin.Lutz\\\\.npm-init.js\",\"npm_config_local_prefix\":\"D:\\\\hub2023A\\\\itwinjs-core\\\\test-apps\\\\display-performance-test-app\",\"npm_config_loglevel\":\"silent\",\"npm_config_metrics_registry\":\"https://registry.npmjs.org/\",\"npm_config_node_gyp\":\"C:\\\\Users\\\\Earlin.Lutz\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\npm\\\\node_modules\\\\node-gyp\\\\bin\\\\node-gyp.js\",\"npm_config_noproxy\":\"\",\"npm_config_prefix\":\"C:\\\\Users\\\\Earlin.Lutz\\\\AppData\\\\Roaming\\\\npm\",\"npm_config_userconfig\":\"C:\\\\Users\\\\Earlin.Lutz\\\\.npmrc\",\"npm_config_user_agent\":\"npm/8.12.2 node/v18.14.1 win32 x64 workspaces/false\",\"npm_execpath\":\"C:\\\\Users\\\\Earlin.Lutz\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\npm\\\\bin\\\\npm-cli.js\",\"npm_lifecycle_event\":\"build:frontend-vite\",\"npm_lifecycle_script\":\"cross-env NODE_OPTIONS=--max_old_space_size=8192 vite build\",\"npm_node_execpath\":\"C:\\\\Program Files\\\\nodejs\\\\node.exe\",\"npm_package_engines_node\":\"^18.0.0\",\"npm_package_json\":\"D:\\\\hub2023A\\\\itwinjs-core\\\\test-apps\\\\display-performance-test-app\\\\package.json\",\"npm_package_name\":\"display-performance-test-app\",\"npm_package_version\":\"0.0.0\",\"NPM_PREFIX_NPM_CLI_JS\":\"C:\\\\Users\\\\Earlin.Lutz\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\npm\\\\bin\\\\npm-cli.js\",\"NUMBER_OF_PROCESSORS\":\"24\",\"ONEDRIVE\":\"C:\\\\Users\\\\Earlin.Lutz\\\\OneDrive - Bentley Systems, Inc\",\"ONEDRIVECOMMERCIAL\":\"C:\\\\Users\\\\Earlin.Lutz\\\\OneDrive - Bentley Systems, Inc\",\"OS\":\"Windows_NT\",\"OUTBASE\":\"d:\\\\hub2023A\\\\itwinjs-core\\\\\\\\core\\\\geometry\\\\lib\\\\\",\"OUTROOT\":\"d:\\\\hub2023A\\\\itwinjs-core\\\\\\\\core\\\\geometry\\\\lib\\\\\",\"PATH\":\"D:\\\\hub2023A\\\\itwinjs-core\\\\test-apps\\\\display-performance-test-app\\\\node_modules\\\\.bin;D:\\\\hub2023A\\\\itwinjs-core\\\\test-apps\\\\node_modules\\\\.bin;D:\\\\hub2023A\\\\itwinjs-core\\\\node_modules\\\\.bin;D:\\\\hub2023A\\\\node_modules\\\\.bin;D:\\\\node_modules\\\\.bin;C:\\\\Users\\\\Earlin.Lutz\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\npm\\\\node_modules\\\\@npmcli\\\\run-script\\\\lib\\\\node-gyp-bin;D:\\\\hub2023A\\\\itwinjs-core\\\\test-apps\\\\display-performance-test-app\\\\node_modules\\\\.bin;D:\\\\hub2023A\\\\itwinjs-core\\\\common\\\\temp\\\\node_modules\\\\.bin;C:\\\\Program Files (x86)\\\\Microsoft SDKs\\\\Azure\\\\CLI2\\\\wbin;C:\\\\DevTools\\\\python38\\\\Scripts\\\\;C:\\\\DevTools\\\\python38\\\\;C:\\\\Windows\\\\system32;C:\\\\Windows;C:\\\\Windows\\\\System32\\\\Wbem;C:\\\\Windows\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\;C:\\\\Windows\\\\System32\\\\OpenSSH\\\\;C:\\\\DevTools\\\\Mercurial-BSI\\\\Mercurial\\\\;C:\\\\DevTools\\\\Mercurial-BSI\\\\KDiff3\\\\;C:\\\\Program Files\\\\TortoiseHg\\\\;C:\\\\Program Files\\\\Microsoft SQL Server\\\\130\\\\Tools\\\\Binn\\\\;C:\\\\Program Files\\\\dotnet\\\\;C:\\\\Program Files\\\\Microsoft SQL Server\\\\Client SDK\\\\ODBC\\\\170\\\\Tools\\\\Binn\\\\;C:\\\\Program Files\\\\nodejs\\\\;c:\\\\DevTools\\\\Git\\\\cmd;C:\\\\Users\\\\Earlin.Lutz\\\\AppData\\\\Local\\\\Microsoft\\\\WindowsApps;C:\\\\devtools\\\\cvsnt\\\\;C:\\\\Users\\\\Earlin.Lutz\\\\AppData\\\\Local\\\\Programs\\\\Microsoft VS Code\\\\bin;C:\\\\Users\\\\Earlin.Lutz\\\\.dotnet\\\\tools;C:\\\\Users\\\\Earlin.Lutz\\\\AppData\\\\Roaming\\\\npm;c:\\\\bin\\\\;c:\\\\bin\\\\build\\\\;d:\\\\hub2023A\\\\itwinjs-core\\\\bsitools\\\\anycpu;\",\"PATHEXT\":\".COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JSE;.WSF;.WSH;.MSC;.PY;.PYW\",\"PROCESSOR_ARCHITECTURE\":\"AMD64\",\"PROCESSOR_IDENTIFIER\":\"Intel64 Family 6 Model 85 Stepping 4, GenuineIntel\",\"PROCESSOR_LEVEL\":\"6\",\"PROCESSOR_REVISION\":\"5504\",\"PROGRAMDATA\":\"C:\\\\ProgramData\",\"PROGRAMFILES\":\"C:\\\\Program Files\",\"PROGRAMFILES(X86)\":\"C:\\\\Program Files (x86)\",\"PROGRAMW6432\":\"C:\\\\Program Files\",\"PROMPT\":\"$P$G\",\"PSMODULEPATH\":\"C:\\\\Program Files\\\\WindowsPowerShell\\\\Modules;C:\\\\Windows\\\\system32\\\\WindowsPowerShell\\\\v1.0\\\\Modules\",\"PUBLIC\":\"C:\\\\Users\\\\Public\",\"RUSHSTACK_FILE_ERROR_BASE_FOLDER\":\"D:\\\\hub2023A\\\\itwinjs-core\",\"RUSH_INVOKED_FOLDER\":\"d:\\\\hub2023A\\\\itwinjs-core\\\\core\\\\geometry\",\"SESSIONNAME\":\"Console\",\"SRCROOT\":\"d:\\\\hub2023A\\\\itwinjs-core\\\\\",\"SYSTEMDRIVE\":\"C:\",\"SYSTEMROOT\":\"C:\\\\Windows\",\"TEMP\":\"C:\\\\Users\\\\EARLIN~1.LUT\\\\AppData\\\\Local\\\\Temp\",\"TESTAPPS\":\"d:\\\\hub2023A\\\\itwinjs-core\\\\test-apps\\\\\",\"TMP\":\"C:\\\\Users\\\\EARLIN~1.LUT\\\\AppData\\\\Local\\\\Temp\",\"TOOLCACHE\":\"d:\\\\toolcache\\\\\",\"UATDATA\":\"C:\\\\Windows\\\\CCM\\\\UATData\\\\D9F8C395-CAB8-491d-B8AC-179A1FE1BE77\",\"UIFRAMEWORK\":\"d:\\\\hub2023A\\\\itwinjs-core\\\\ui\\\\framework\\\\\",\"USERDNSDOMAIN\":\"BENTLEY.COM\",\"USERDOMAIN\":\"BENTLEY\",\"USERDOMAIN_ROAMINGPROFILE\":\"BENTLEY\",\"USERNAME\":\"Earlin.Lutz\",\"USERPROFILE\":\"C:\\\\Users\\\\Earlin.Lutz\",\"USE_NEW_BB\":\"1\",\"UTILROOT\":\"d:\\\\hub2023A\\\\itwinjs-core\\\\util\\\\\",\"WINDIR\":\"C:\\\\Windows\",\"WIPPARTENABLE_ANDROIDTOOLCACHE\":\"1\",\"_RUSH_LIB_PATH\":\"C:\\\\Users\\\\Earlin.Lutz\\\\.rush\\\\node-v18.14.1\\\\rush-5.99.0\\\\node_modules\\\\@microsoft\\\\rush-lib\\\\lib\\\\index.js\",\"_USTN_CONVERTASSERTSTOPRINTF\":\"1\",\"__PSLOCKDOWNPOLICY\":\"0\",\"__TAIL0__\":\"g\",\"__TAIL__\":\"d:\\\\hub2023A\\\\itwinjs-core\\\\core\\\\geometry\\\\\"}.IMJS_OIDC_HEADLESS) {\n        const token = await DisplayPerfRpcInterface.getClient().getAccessToken();\n        IModelApp.authorizationClient = new TestFrontendAuthorizationClient(token);\n      }\n      const { iModelId, iTwinId } = this.curConfig;\n      if (iTwinId === void 0)\n        throw new Error(\"Missing iTwinId for remote iModel\");\n      const iModel = await CheckpointConnection.openRemote(iTwinId, iModelId);\n      const externalSavedViews = await this._savedViewsFetcher.getSavedViews(iTwinId, iModelId, await IModelApp.getAccessToken());\n      return { iModel, externalSavedViews };\n    } else {\n      const filepath = `${this.curConfig.iModelLocation}${separator}${this.curConfig.iModelName}`;\n      const iModel = await SnapshotConnection.openFile(filepath);\n      const esv = await DisplayPerfRpcInterface.getClient().readExternalSavedViews(filepath);\n      let externalSavedViews = [];\n      if (esv) {\n        const json = JSON.parse(esv);\n        externalSavedViews = json.map((x) => {\n          return {\n            name: x._name,\n            viewProps: JSON.parse(x._viewStatePropsString),\n            elementOverrides: x._overrideElements ? JSON.parse(x._overrideElements) : void 0,\n            selectedElements: x._selectedElements ? JSON.parse(x._selectedElements) : void 0\n          };\n        });\n      }\n      return { iModel, externalSavedViews };\n    }\n  }\n  async getIModelNames() {\n    const config = this.curConfig;\n    if (!config.iModelName.includes(\"*\"))\n      return [config.iModelName];\n    const json = await DisplayPerfRpcInterface.getClient().getMatchingFiles(config.iModelLocation, config.iModelName);\n    const files = JSON.parse(json);\n    const iModels = [];\n    for (const file of files) {\n      if (file.endsWith(\".bim\") || file.endsWith(\".ibim\")) {\n        const split = file.split(/[^\\/\\\\]+/g);\n        const iModel = split[split.length - 1];\n        if (iModel)\n          iModels.push(iModel);\n      }\n    }\n    return iModels;\n  }\n  async getViewNames(context) {\n    if (!this.curConfig.viewName.includes(\"*\"))\n      return [this.curConfig.viewName];\n    let viewNames = [];\n    if (this.curConfig.savedViewType !== \"external\") {\n      const specs = await context.iModel.views.getViewList({ wantPrivate: true });\n      viewNames = specs.map((spec) => spec.name);\n    }\n    if (this.curConfig.savedViewType !== \"internal\" && this.curConfig.savedViewType !== \"local\")\n      viewNames = viewNames.concat(context.externalSavedViews.map((x) => x.name));\n    return viewNames.filter((view) => matchRule(view, this.curConfig.viewName ?? \"*\")).sort();\n  }\n  async finish() {\n    let renderData = '\"End of Tests-----------\\r\\n';\n    const renderComp = IModelApp.queryRenderCompatibility();\n    if (renderComp.userAgent) {\n      renderData += `Browser: ${getBrowserName(renderComp.userAgent)}\\r\n`;\n      renderData += `User Agent: ${renderComp.userAgent}\\r\n`;\n    }\n    if (renderComp.unmaskedRenderer)\n      renderData += `Unmasked Renderer: ${renderComp.unmaskedRenderer}\\r\n`;\n    if (renderComp.unmaskedVendor)\n      renderData += `Unmasked Vendor: ${renderComp.unmaskedVendor}\\r\n`;\n    if (renderComp.missingRequiredFeatures)\n      renderData += `Missing Required Features: ${renderComp.missingRequiredFeatures}\\r\n`;\n    if (renderComp.missingOptionalFeatures)\n      renderData += `Missing Optional Features: ${renderComp.missingOptionalFeatures}\"\\r\n`;\n    await DisplayPerfRpcInterface.getClient().finishCsv(renderData, this.curConfig.outputPath, this.curConfig.outputName, this.curConfig.csvFormat);\n    await this.logToConsole(\"Tests complete. Press Ctrl-C to exit.\");\n  }\n  async saveCsv(row) {\n    const outputPath = this.curConfig.outputPath;\n    const outputName = this.curConfig.outputName;\n    const msg = JSON.stringify([...row]);\n    return DisplayPerfRpcInterface.getClient().saveCsv(outputPath, outputName, msg, this.curConfig.csvFormat);\n  }\n  async logToFile(message, opts) {\n    if (!opts?.noNewLine)\n      message = `${message}\n`;\n    const append = !opts?.noAppend;\n    return DisplayPerfRpcInterface.getClient().writeExternalFile(this.curConfig.outputPath, this._logFileName, append, message);\n  }\n  async logToConsole(message) {\n    return DisplayPerfRpcInterface.getClient().consoleLog(message);\n  }\n  async logError(message) {\n    const msg = `ERROR: ${message}`;\n    await this.logToConsole(msg);\n    return this.logToFile(msg);\n  }\n  getTestName(test, prefix, isImage = false, ignoreDupes = false) {\n    let testName = prefix ?? \"\";\n    const configs = this.curConfig;\n    testName += configs.iModelName.replace(/\\.[^/.]+$/, \"\");\n    testName += `_${configs.viewName}`;\n    testName += configs.displayStyle ? `_${configs.displayStyle.trim()}` : \"\";\n    testName = testName.replace(/[/\\\\?%*:|\"<>]/g, \"-\");\n    const renderMode = getRenderMode(test.viewport);\n    if (renderMode)\n      testName += `_${renderMode}`;\n    const vf = getViewFlagsString(test);\n    if (vf)\n      testName += `_${vf}`;\n    const renderOpts = getRenderOpts(configs.renderOptions);\n    if (renderOpts)\n      testName += `_${renderOpts}`;\n    const tileProps = configs.tileProps ? getTileProps(configs.tileProps) : void 0;\n    if (tileProps)\n      testName += `_${tileProps}`;\n    const map = getBackgroundMapProps(test.viewport);\n    if (map)\n      testName += `_${map}`;\n    const hyper = getHyperModelingProps(configs.hyperModeling);\n    if (hyper)\n      testName += `_${hyper}`;\n    const other = getOtherProps(test.viewport);\n    if (other)\n      testName += `_${other}`;\n    testName = removeOptsFromString(testName, configs.filenameOptsToIgnore);\n    if (!ignoreDupes) {\n      let testNum = isImage ? this._testNamesImages.get(testName) : this._testNamesTimings.get(testName);\n      if (testNum === void 0)\n        testNum = 0;\n      testName += testNum > 1 ? `---${testNum}` : \"\";\n    }\n    return testName;\n  }\n  getImageName(test, prefix) {\n    const filename = `${this.getTestName(test, prefix, true)}.png`;\n    if (ProcessDetector.isMobileAppFrontend)\n      return filename;\n    return `${this.curConfig.outputPath}${separator}${filename}`;\n  }\n  getRowData(timings, test, pixSelectStr) {\n    const fixed = 4;\n    const configs = this.curConfig;\n    const rowData = /* @__PURE__ */ new Map();\n    rowData.set(\"iModel\", configs.iModelName);\n    rowData.set(\"View\", configs.viewName);\n    const w = test.viewport.cssPixelsToDevicePixels(configs.view.width);\n    const h = test.viewport.cssPixelsToDevicePixels(configs.view.height);\n    rowData.set(\"Screen Size\", `${w}X${h}`);\n    rowData.set(\"Skip & Time Renders\", `${configs.numRendersToSkip} & ${configs.numRendersToTime}`);\n    rowData.set(\"Display Style\", test.viewport.displayStyle.name);\n    rowData.set(\"Render Mode\", getRenderMode(test.viewport));\n    rowData.set(\"View Flags\", getViewFlagsString(test) !== \"\" ? ` ${getViewFlagsString(test)}` : \"\");\n    rowData.set(\"Render Options\", getRenderOpts(configs.renderOptions) !== \"\" ? ` ${getRenderOpts(configs.renderOptions)}` : \"\");\n    const tileProps = configs.tileProps ? getTileProps(configs.tileProps) : \"\";\n    rowData.set(\"Tile Props\", \"\" !== tileProps ? ` ${tileProps}` : \"\");\n    rowData.set(\"Bkg Map Props\", getBackgroundMapProps(test.viewport) !== \"\" ? ` ${getBackgroundMapProps(test.viewport)}` : \"\");\n    rowData.set(\"HyperModeling\", getHyperModelingProps(configs.hyperModeling) ?? \"\");\n    const other = getOtherProps(test.viewport);\n    if (\"\" !== other)\n      rowData.set(\"Other Props\", ` ${other}`);\n    if (pixSelectStr)\n      rowData.set(\"ReadPixels Selector\", ` ${pixSelectStr}`);\n    rowData.set(\"Test Name\", this.getTestName(test));\n    rowData.set(\"Browser\", getBrowserName(IModelApp.queryRenderCompatibility().userAgent));\n    if (!this._minimizeOutput) {\n      rowData.set(\"Tile Loading Time\", test.tileLoadingTime);\n      rowData.set(\"Num Selected Tiles\", test.numSelectedTiles);\n      rowData.set(\"Selected Tile GPU MB\", test.selectedTileGpuBytes / (1024 * 1024));\n      rowData.set(\"Tile Tree GPU MB\", test.viewedTileTreeGpuBytes / (1024 * 1024));\n      rowData.set(\"Total GPU MB\", test.totalGpuBytes / (1024 * 1024));\n    }\n    const setGpuData = (name) => {\n      if (name === \"CPU Total Time\")\n        name = \"Total\";\n      const gpuDataArray = timings.gpu.get(name);\n      if (gpuDataArray) {\n        let gpuSum = 0;\n        for (const gpuData of gpuDataArray)\n          gpuSum += gpuData;\n        rowData.set(`GPU-${name}`, gpuDataArray.length ? (gpuSum / gpuDataArray.length).toFixed(fixed) : gpuSum.toFixed(fixed));\n      }\n    };\n    if (pixSelectStr) {\n      for (const colName of timings.cpu[0].keys()) {\n        let sum = 0;\n        timings.cpu.forEach((timing) => {\n          const data = timing.get(colName);\n          sum += data ? data : 0;\n        });\n        if (!this._minimizeOutput || colName === \"CPU Total Time\") {\n          rowData.set(colName, (sum / timings.cpu.length).toFixed(fixed));\n          setGpuData(colName);\n        }\n      }\n    } else {\n      for (const colName of timings.actualFps[0].keys()) {\n        let sum = 0;\n        timings.actualFps.forEach((timing) => {\n          const data = timing.get(colName);\n          sum += data ? data : 0;\n        });\n        if (!this._minimizeOutput || colName === \"CPU Total Time\") {\n          rowData.set(colName, sum / timings.actualFps.length);\n          setGpuData(colName);\n        }\n      }\n    }\n    let totalTime;\n    if (rowData.get(\"Finish GPU Queue\")) {\n      totalTime = Number(rowData.get(\"CPU Total Time\")) + Number(rowData.get(\"Finish GPU Queue\"));\n      rowData.set(\"GPU Total Time\", totalTime);\n    }\n    let totalRenderTime = 0;\n    totalTime = 0;\n    for (const time of timings.actualFps) {\n      let timing = time.get(\"CPU Total Time\");\n      totalRenderTime += timing ? timing : 0;\n      timing = time.get(\"Total Time\");\n      totalTime += timing ? timing : 0;\n    }\n    rowData.delete(\"Total Time\");\n    totalRenderTime /= timings.actualFps.length;\n    totalTime /= timings.actualFps.length;\n    const disjointTimerUsed = rowData.get(\"GPU-Total\") !== void 0;\n    const totalGpuTime = Number(disjointTimerUsed ? rowData.get(\"GPU-Total\") : rowData.get(\"GPU Total Time\"));\n    const gpuTolerance = disjointTimerUsed ? 2 : 3;\n    const gpuBound = totalGpuTime - totalRenderTime > gpuTolerance;\n    const cpuBound = disjointTimerUsed ? totalRenderTime - totalGpuTime > gpuTolerance && totalRenderTime > 2 : !gpuBound;\n    let boundBy = \"\";\n    if (totalRenderTime < 2 && !gpuBound)\n      boundBy = \"unmeasurable\";\n    else if (!gpuBound && !cpuBound)\n      boundBy = \"unknown\";\n    else if (gpuBound)\n      boundBy = \"gpu\";\n    else\n      boundBy = \"CPU\";\n    if (1e3 / totalTime > 59)\n      boundBy += \" (vsync)\";\n    const totalCpuTime = totalRenderTime > 2 ? totalRenderTime : 2;\n    const effectiveFps = 1e3 / (gpuBound ? totalGpuTime : totalCpuTime);\n    if (disjointTimerUsed) {\n      rowData.set(\"GPU Total Time\", totalGpuTime.toFixed(fixed));\n      rowData.delete(\"GPU-Total\");\n    }\n    rowData.set(\"Bound By\", boundBy);\n    rowData.set(\"Effective Total Time\", gpuBound ? totalGpuTime.toFixed(fixed) : totalCpuTime.toFixed(fixed));\n    rowData.set(\"Effective FPS\", effectiveFps.toFixed(fixed));\n    rowData.set(\"Actual Total Time\", totalTime.toFixed(fixed));\n    rowData.set(\"Actual FPS\", totalTime > 0 ? (1e3 / totalTime).toFixed(fixed) : \"0\");\n    return rowData;\n  }\n  async createReadPixelsImages(test, pix, pixStr) {\n    const vp = test.viewport;\n    const canvas = vp.readImageToCanvas();\n    const ctx = canvas.getContext(\"2d\");\n    if (!ctx)\n      return;\n    const cssRect = new ViewRect(0, 0, this.curConfig.view.width, this.curConfig.view.height);\n    const imgWidth = vp.cssPixelsToDevicePixels(cssRect.width);\n    const imgHeight = vp.cssPixelsToDevicePixels(cssRect.height);\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    const elemIdImgData = pix & Pixel.Selector.Feature ? ctx.createImageData(imgWidth, imgHeight) : void 0;\n    const depthImgData = pix & Pixel.Selector.GeometryAndDistance ? ctx.createImageData(imgWidth, imgHeight) : void 0;\n    const typeImgData = pix & Pixel.Selector.GeometryAndDistance ? ctx.createImageData(imgWidth, imgHeight) : void 0;\n    vp.readPixels(cssRect, pix, (pixels) => {\n      if (!pixels)\n        return;\n      for (let y = 0; y < imgHeight; ++y) {\n        for (let x = 0; x < imgWidth; ++x) {\n          const index = x * 4 + y * 4 * imgWidth;\n          const pixel = pixels.getPixel(x, y);\n          if (elemIdImgData !== void 0) {\n            const elemId = Id64.getLowerUint32(pixel.elementId ? pixel.elementId : \"\");\n            elemIdImgData.data[index + 0] = elemId % 256;\n            elemIdImgData.data[index + 1] = Math.floor(elemId / 256) % 256;\n            elemIdImgData.data[index + 2] = Math.floor(elemId / (256 ^ 2)) % 256;\n            elemIdImgData.data[index + 3] = 255;\n          }\n          if (depthImgData !== void 0) {\n            const distColor = pixels.getPixel(x, y).distanceFraction * 255;\n            depthImgData.data[index + 0] = depthImgData.data[index + 1] = depthImgData.data[index + 2] = distColor;\n            depthImgData.data[index + 3] = 255;\n          }\n          if (typeImgData !== void 0) {\n            const type = pixels.getPixel(x, y).type;\n            switch (type) {\n              case Pixel.GeometryType.None:\n                typeImgData.data[index + 0] = 255;\n                typeImgData.data[index + 1] = 255;\n                typeImgData.data[index + 2] = 255;\n                break;\n              case Pixel.GeometryType.Surface:\n                typeImgData.data[index + 0] = 255;\n                typeImgData.data[index + 1] = 0;\n                typeImgData.data[index + 2] = 0;\n                break;\n              case Pixel.GeometryType.Linear:\n                typeImgData.data[index + 0] = 0;\n                typeImgData.data[index + 1] = 255;\n                typeImgData.data[index + 2] = 0;\n                break;\n              case Pixel.GeometryType.Edge:\n                typeImgData.data[index + 0] = 0;\n                typeImgData.data[index + 1] = 0;\n                typeImgData.data[index + 2] = 255;\n                break;\n              case Pixel.GeometryType.Silhouette:\n                typeImgData.data[index + 0] = 255;\n                typeImgData.data[index + 1] = 0;\n                typeImgData.data[index + 2] = 255;\n                break;\n              case Pixel.GeometryType.Unknown:\n              default:\n                typeImgData.data[index + 0] = 0;\n                typeImgData.data[index + 1] = 0;\n                typeImgData.data[index + 2] = 0;\n                break;\n            }\n            typeImgData.data[index + 3] = 255;\n          }\n        }\n      }\n    });\n    if (elemIdImgData !== void 0) {\n      ctx.putImageData(elemIdImgData, 0, 0);\n      await savePng(this.getImageName(test, `elemId_${pixStr}_`), canvas);\n    }\n    if (depthImgData !== void 0) {\n      ctx.putImageData(depthImgData, 0, 0);\n      await savePng(this.getImageName(test, `depth_${pixStr}_`), canvas);\n    }\n    if (typeImgData !== void 0) {\n      ctx.putImageData(typeImgData, 0, 0);\n      await savePng(this.getImageName(test, `type_${pixStr}_`), canvas);\n    }\n  }\n  async onException(ex) {\n    await DisplayPerfTestApp.logException(ex, { dir: this.curConfig.outputPath, name: this._logFileName });\n    if (\"terminate\" === this.curConfig.onException)\n      await DisplayPerfRpcInterface.getClient().terminate();\n  }\n}\nfunction removeOptsFromString(input, ignore) {\n  if (!ignore)\n    return input;\n  let output = input;\n  if (!(ignore instanceof Array))\n    ignore = ignore.split(\" \");\n  ignore.forEach((del) => {\n    output = output.replace(del, \"\");\n  });\n  output = output.replace(/__+/, \"_\");\n  if (output[output.length - 1] === \"_\")\n    output = output.slice(0, output.length - 1);\n  return output;\n}\nfunction getRenderMode(vp) {\n  switch (vp.viewFlags.renderMode) {\n    case RenderMode.Wireframe:\n      return \"Wireframe\";\n    case RenderMode.HiddenLine:\n      return \"HiddenLine\";\n    case RenderMode.SolidFill:\n      return \"SolidFill\";\n    case RenderMode.SmoothShade:\n      return \"SmoothShade\";\n    default:\n      return \"\";\n  }\n}\nfunction getRenderOpts(opts) {\n  let optString = \"\";\n  for (const propName of Object.keys(opts)) {\n    const key = propName;\n    switch (key) {\n      case \"disabledExtensions\": {\n        const extensions = opts[key];\n        if (extensions) {\n          for (const ext of extensions) {\n            switch (ext) {\n              case \"WEBGL_draw_buffers\":\n                optString += \"-drawBuf\";\n                break;\n              case \"OES_element_index_uint\":\n                optString += \"-unsignedInt\";\n                break;\n              case \"OES_texture_float\":\n                optString += \"-texFloat\";\n                break;\n              case \"OES_texture_half_float\":\n                optString += \"-texHalfFloat\";\n                break;\n              case \"WEBGL_depth_texture\":\n                optString += \"-depthTex\";\n                break;\n              case \"EXT_color_buffer_float\":\n                optString += \"-floats\";\n                break;\n              case \"EXT_shader_texture_lod\":\n                optString += \"-texLod\";\n                break;\n              case \"ANGLE_instanced_arrays\":\n                optString += \"-instArrays\";\n                break;\n              case \"EXT_frag_depth\":\n                optString += \"-fragDepth\";\n                break;\n            }\n          }\n        }\n        break;\n      }\n      case \"displaySolarShadows\":\n        if (!opts[key])\n          optString += \"-solShd\";\n        break;\n      case \"useWebGL2\":\n        if (opts[key])\n          optString += \"+webGL2\";\n        break;\n      case \"antialiasSamples\": {\n        const value = opts[key];\n        if (void 0 !== value && value > 1)\n          optString += `+aa${value}`;\n        break;\n      }\n    }\n  }\n  return optString;\n}\nfunction getTileProps(props) {\n  let tilePropsStr = \"\";\n  for (const propName of Object.keys(props)) {\n    const key = propName;\n    switch (key) {\n      case \"enableInstancing\":\n        if (props[key])\n          tilePropsStr += \"+inst\";\n        break;\n      case \"disableMagnification\":\n        if (props[key])\n          tilePropsStr += \"-mag\";\n        break;\n      case \"enableIndexedEdges\":\n        if (!props[key])\n          tilePropsStr += \"-idxEdg\";\n        break;\n      case \"generateAllPolyfaceEdges\":\n        if (!props[key])\n          tilePropsStr += \"-pfEdg\";\n        break;\n    }\n  }\n  return tilePropsStr;\n}\nfunction getBackgroundMapProps(vp) {\n  let bmPropsStr = \"\";\n  const layer = vp.displayStyle.settings.mapImagery.backgroundBase;\n  if (layer instanceof BaseMapLayerSettings && layer.provider) {\n    switch (layer.provider.name) {\n      case \"BingProvider\":\n        break;\n      case \"MapBoxProvider\":\n        bmPropsStr += \"MapBox\";\n        break;\n    }\n    switch (layer.provider.type) {\n      case BackgroundMapType.Hybrid:\n        break;\n      case BackgroundMapType.Aerial:\n        bmPropsStr += \"+aer\";\n        break;\n      case BackgroundMapType.Street:\n        bmPropsStr += \"+st\";\n        break;\n    }\n  }\n  const bmProps = vp.displayStyle.settings.backgroundMap;\n  if (bmProps.groundBias !== 0)\n    bmPropsStr += `+bias${bmProps.groundBias}`;\n  if (bmProps.applyTerrain)\n    bmPropsStr += \"+terr\";\n  if (bmProps.useDepthBuffer)\n    bmPropsStr += \"+depth\";\n  if (typeof bmProps.transparency === \"number\")\n    bmPropsStr += `+trans${bmProps.transparency}`;\n  return bmPropsStr;\n}\nfunction hiliteSettingsStr(settings) {\n  let hsStr = (settings.color.colors.r * 256 * 256 + settings.color.colors.g * 256 + settings.color.colors.b).toString(36).padStart(5, \"0\");\n  hsStr += (settings.silhouette * 256 * 256 + Math.round(settings.visibleRatio * 255) * 256 + Math.round(settings.hiddenRatio * 255)).toString(36).padStart(4, \"0\");\n  return hsStr.toUpperCase();\n}\nfunction getHyperModelingProps(props) {\n  if (!props)\n    return void 0;\n  const hm = `+hm${props.sectionDrawingLocationId}`;\n  return props.applySpatialView ? `${hm}+a` : hm;\n}\nfunction getOtherProps(vp) {\n  let propsStr = \"\";\n  if (!Hilite.equalSettings(vp.hilite, defaultHilite))\n    propsStr += `+h${hiliteSettingsStr(vp.hilite)}`;\n  if (!Hilite.equalSettings(vp.emphasisSettings, defaultEmphasis))\n    propsStr += `+e${hiliteSettingsStr(vp.emphasisSettings)}`;\n  return propsStr;\n}\nconst viewFlagsPropsStrings = {\n  dimensions: \"-dim\",\n  patterns: \"-pat\",\n  weights: \"-wt\",\n  styles: \"-sty\",\n  transparency: \"-trn\",\n  fill: \"-fll\",\n  textures: \"-txt\",\n  materials: \"-mat\",\n  visibleEdges: \"+vsE\",\n  hiddenEdges: \"+hdE\",\n  shadows: \"+shd\",\n  clipVolume: \"-clp\",\n  constructions: \"+con\",\n  monochrome: \"+mno\",\n  backgroundMap: \"+bkg\",\n  ambientOcclusion: \"+ao\",\n  forceSurfaceDiscard: \"+fsd\",\n  thematicDisplay: \"+thematicDisplay\",\n  grid: \"+grid\",\n  whiteOnWhiteReversal: \"+wow\",\n  acsTriad: \"+acsTriad\",\n  wiremesh: \"+wm\"\n};\nfunction getViewFlagsString(test) {\n  let vfString = \"\";\n  const vf = test.viewport.viewFlags;\n  if (vf.lighting && RenderMode.SmoothShade === vf.renderMode)\n    vfString = \"+lit\";\n  for (const propName of Object.keys(vf)) {\n    const key = propName;\n    const abbrev = viewFlagsPropsStrings[key];\n    if (!abbrev)\n      continue;\n    assert(\"-\" === abbrev[0] || \"+\" === abbrev[0]);\n    const includeIf = \"+\" === abbrev[0];\n    if (vf[key] === includeIf)\n      vfString += abbrev;\n  }\n  if (void 0 !== test.view.elementOverrides)\n    vfString += \"+ovrEl\";\n  if (void 0 !== test.view.selectedElements)\n    vfString += \"+selEl\";\n  return vfString;\n}\nfunction getBrowserName(userAgent) {\n  const lowUserAgent = userAgent.toLowerCase();\n  if (lowUserAgent.includes(\"electron\"))\n    return \"Electron\";\n  if (lowUserAgent.includes(\"firefox\"))\n    return \"FireFox\";\n  if (lowUserAgent.includes(\"edge\"))\n    return \"Edge\";\n  if (lowUserAgent.includes(\"chrome\") && !userAgent.includes(\"chromium\"))\n    return \"Chrome\";\n  if (lowUserAgent.includes(\"safari\") && !userAgent.includes(\"chrome\") && !userAgent.includes(\"chromium\"))\n    return \"Safari\";\n  return \"Unknown\";\n}\nfunction matchRule(strToTest, rule) {\n  strToTest = strToTest.toLowerCase();\n  rule = rule.toLowerCase();\n  const escapeRegex = (str) => str.replace(/([.*+?^=!:${}()|\\[\\]\\/\\\\])/g, \"\\\\$1\");\n  return new RegExp(`^${rule.split(\"*\").map(escapeRegex).join(\".*\")}$`).test(strToTest);\n}\nfunction getSelectedTileStats(vp) {\n  let formattedSelectedTileIds = \"Selected tiles:\\n\";\n  let count = 0;\n  const mem = new RenderMemory.Statistics();\n  const dict = new Dictionary((lhs, rhs) => lhs.localeCompare(rhs));\n  for (const viewport of [vp, ...vp.view.secondaryViewports]) {\n    const selected = IModelApp.tileAdmin.getTilesForUser(viewport)?.selected;\n    if (!selected)\n      continue;\n    count += selected.size;\n    for (const tile of selected) {\n      const treeId = tile.tree.id;\n      let tileIds = dict.get(treeId);\n      if (!tileIds)\n        dict.set(treeId, tileIds = new SortedArray((lhs, rhs) => lhs.localeCompare(rhs)));\n      tileIds.insert(tile.contentId);\n      tile.collectStatistics(mem);\n    }\n  }\n  for (const kvp of dict) {\n    const contentIds = kvp.value.extractArray().join(\",\");\n    const line = `  ${kvp.key}: ${contentIds}`;\n    formattedSelectedTileIds = `${formattedSelectedTileIds}${line}\n`;\n  }\n  return {\n    ids: formattedSelectedTileIds,\n    count,\n    gpuBytes: mem.totalBytes\n  };\n}\nfunction calcGpuBytes(func) {\n  const stats = new RenderMemory.Statistics();\n  func(stats);\n  return stats.totalBytes;\n}\nasync function savePng(fileName, canvas) {\n  const img = canvas.toDataURL(\"image/png\");\n  const data = img.replace(/^data:image\\/\\w+;base64,/, \"\");\n  return DisplayPerfRpcInterface.getClient().savePng(fileName, data);\n}\nfunction setPerformanceMetrics(vp, metrics) {\n  vp.target.performanceMetrics = metrics;\n}\n",
      "start": 1693508118826,
      "end": 1693508118827,
      "order": "normal",
      "sourcemaps": null
    }
  ]
}
