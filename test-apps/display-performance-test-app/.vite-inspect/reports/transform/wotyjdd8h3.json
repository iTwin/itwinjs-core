{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/ShaderProgram.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { assert } from \"@itwin/core-bentley\";\nimport { DebugShaderFile } from \"../RenderSystem\";\nimport { ShaderProgramParams } from \"./DrawCommand\";\nimport { GL } from \"./GL\";\nimport { UniformHandle } from \"./UniformHandle\";\nimport { System } from \"./System\";\nimport { TechniqueFlags } from \"./TechniqueFlags\";\n/** Describes the location of a uniform variable within a shader program.\n * @internal\n */\nexport class Uniform {\n    constructor(name) { this._name = name; }\n    compile(prog) {\n        assert(!this.isValid);\n        if (undefined !== prog.glProgram) {\n            this._handle = UniformHandle.create(prog, this._name);\n        }\n        return this.isValid;\n    }\n    get isValid() { return undefined !== this._handle; }\n}\n/**\n * Describes the location of a uniform variable within a shader program, the value of which does not change while the program is active.\n * The supplied binding function will be invoked once each time the shader becomes active to set the value of the uniform.\n * @internal\n */\nexport class ProgramUniform extends Uniform {\n    constructor(name, bind) {\n        super(name);\n        this._bind = bind;\n    }\n    bind(params) {\n        if (undefined !== this._handle) {\n            this._bind(this._handle, params);\n        }\n    }\n}\n/**\n * Describes the location of a uniform variable within a shader program, the value of which is dependent upon the graphic primitive\n * currently being rendered by the program. The supplied binding function will be invoked once for each graphic primitive submitted\n * to the program to set the value of the uniform.\n * @internal\n */\nexport class GraphicUniform extends Uniform {\n    constructor(name, bind) {\n        super(name);\n        this._bind = bind;\n    }\n    bind(params) {\n        if (undefined !== this._handle) {\n            this._bind(this._handle, params);\n        }\n    }\n}\n/** @internal */\nexport class ShaderProgram {\n    constructor(gl, vertSource, fragSource, attrMap, description, fragDescription) {\n        this._inUse = false;\n        this._status = 2 /* CompileStatus.Uncompiled */;\n        this._programUniforms = new Array();\n        this._graphicUniforms = new Array();\n        this._vertGNdx = -1;\n        this._fragGNdx = -1;\n        this._vertHNdx = -1;\n        this._fragHNdx = -1;\n        this.description = description;\n        this.outputsToPick = description.includes(\"Overrides\") || description.includes(\"Pick\");\n        this._fragDescription = fragDescription;\n        this.vertSource = vertSource;\n        this.fragSource = fragSource;\n        this._attrMap = attrMap;\n        const glProgram = gl.createProgram();\n        this._glProgram = (null === glProgram) ? undefined : glProgram;\n    }\n    get isDisposed() { return this._glProgram === undefined; }\n    dispose() {\n        if (!this.isDisposed) {\n            assert(!this._inUse);\n            System.instance.context.deleteProgram(this._glProgram);\n            this._glProgram = undefined;\n            this._status = 2 /* CompileStatus.Uncompiled */;\n        }\n    }\n    get glProgram() { return this._glProgram; }\n    get isUncompiled() { return 2 /* CompileStatus.Uncompiled */ === this._status; }\n    get isCompiled() { return 0 /* CompileStatus.Success */ === this._status; }\n    compileShader(type) {\n        const gl = System.instance.context;\n        const shader = gl.createShader(type);\n        if (null === shader)\n            return undefined;\n        const src = GL.ShaderType.Vertex === type ? this.vertSource : this.fragSource;\n        gl.shaderSource(shader, src);\n        gl.compileShader(shader);\n        const succeeded = gl.getShaderParameter(shader, GL.ShaderParameter.CompileStatus);\n        if (!succeeded) {\n            const compileLog = `${GL.ShaderType.Vertex === type ? \"Vertex\" : \"Fragment\"} shader failed to compile. Errors: ${gl.getShaderInfoLog(shader)} Program description: ${this.description}`;\n            throw new Error(compileLog);\n        }\n        if (System.instance.options.debugShaders) {\n            const isVS = GL.ShaderType.Vertex === type;\n            const desc = isVS ? this.description : this._fragDescription;\n            this.saveShaderCode(isVS, desc, src, shader);\n        }\n        return shader;\n    }\n    linkProgram(vert, frag) {\n        assert(undefined !== this.glProgram);\n        if (undefined === this._glProgram || null === this._glProgram) // because WebGL APIs used Thing|null, not Thing|undefined...\n            return false;\n        const gl = System.instance.context;\n        gl.attachShader(this._glProgram, vert);\n        gl.attachShader(this._glProgram, frag);\n        // bind attribute locations before final linking\n        if (this._attrMap !== undefined) {\n            this._attrMap.forEach((attr, key) => {\n                gl.bindAttribLocation(this._glProgram, attr.location, key);\n            });\n        }\n        gl.linkProgram(this._glProgram);\n        const linkLog = gl.getProgramInfoLog(this._glProgram);\n        gl.validateProgram(this._glProgram);\n        const succeeded = gl.getProgramParameter(this._glProgram, GL.ProgramParameter.LinkStatus);\n        if (!succeeded) {\n            const validateLog = gl.getProgramInfoLog(this._glProgram);\n            const msg = `Shader program failed to link. Link errors: ${linkLog} Validation errors: ${validateLog} Program description: ${this.description}`;\n            throw new Error(msg);\n        }\n        return true;\n    }\n    compile(forUse = false) {\n        if (System.instance.options.debugShaders && forUse && this._status === 0 /* CompileStatus.Success */)\n            this.setDebugShaderUsage();\n        switch (this._status) {\n            case 1 /* CompileStatus.Failure */: return 1 /* CompileStatus.Failure */;\n            case 0 /* CompileStatus.Success */: return 0 /* CompileStatus.Success */;\n            default: {\n                if (this.isDisposed) {\n                    this._status = 1 /* CompileStatus.Failure */;\n                    return 1 /* CompileStatus.Failure */;\n                }\n                break;\n            }\n        }\n        this._status = 1 /* CompileStatus.Failure */;\n        const vert = this.compileShader(GL.ShaderType.Vertex);\n        const frag = this.compileShader(GL.ShaderType.Fragment);\n        if (undefined !== vert && undefined !== frag)\n            if (this.linkProgram(vert, frag) && this.compileUniforms(this._programUniforms) && this.compileUniforms(this._graphicUniforms))\n                this._status = 0 /* CompileStatus.Success */;\n        if (System.instance.options.debugShaders && forUse && this._status === 0 /* CompileStatus.Success */)\n            this.setDebugShaderUsage();\n        if (true !== System.instance.options.preserveShaderSourceCode)\n            this.vertSource = this.fragSource = \"\";\n        return this._status;\n    }\n    use(params) {\n        if (this.compile(true) !== 0 /* CompileStatus.Success */)\n            return false;\n        assert(undefined !== this._glProgram);\n        if (null === this._glProgram || undefined === this._glProgram)\n            return false;\n        assert(!this._inUse);\n        this._inUse = true;\n        params.context.useProgram(this._glProgram);\n        for (const uniform of this._programUniforms)\n            uniform.bind(params);\n        return true;\n    }\n    endUse() {\n        this._inUse = false;\n        System.instance.context.useProgram(null);\n    }\n    draw(params) {\n        assert(this._inUse);\n        for (const uniform of this._graphicUniforms)\n            uniform.bind(params);\n        params.geometry.draw();\n    }\n    addProgramUniform(name, binding) {\n        assert(this.isUncompiled);\n        this._programUniforms.push(new ProgramUniform(name, binding));\n    }\n    addGraphicUniform(name, binding) {\n        assert(this.isUncompiled);\n        this._graphicUniforms.push(new GraphicUniform(name, binding));\n    }\n    compileUniforms(uniforms) {\n        for (const uniform of uniforms) {\n            if (!uniform.compile(this))\n                return false;\n        }\n        return true;\n    }\n    setDebugShaderUsage() {\n        if (!System.instance.options.debugShaders)\n            return;\n        const shaderFiles = System.instance.debugShaderFiles;\n        if (this._vertGNdx >= 0)\n            shaderFiles[this._vertGNdx].isUsed = true;\n        if (this._fragGNdx >= 0)\n            shaderFiles[this._fragGNdx].isUsed = true;\n        if (this._vertHNdx >= 0)\n            shaderFiles[this._vertHNdx].isUsed = true;\n        if (this._fragHNdx >= 0)\n            shaderFiles[this._fragHNdx].isUsed = true;\n    }\n    saveShaderCode(isVS, desc, src, shader) {\n        // save glsl and hlsl (from Angle and fixed up) in DebugShaderFile\n        if (!System.instance.options.debugShaders)\n            return;\n        const shaderFiles = System.instance.debugShaderFiles;\n        let sname;\n        if (desc) {\n            sname = desc.split(isVS ? \"//!V! \" : \"//!F! \").join(\"\");\n            sname = sname.split(\": \").join(\"-\");\n            sname = sname.split(\"; \").join(\"-\");\n        }\n        else {\n            // need to investigate shaders with no comments to derive names, for now come up with unique name\n            sname = `noname-${shaderFiles.length}`;\n        }\n        sname += isVS ? \"_VS\" : \"_FS\";\n        const fname = `${sname}.glsl`;\n        let dsfNdx = shaderFiles.push(new DebugShaderFile(fname, src, isVS, true, false));\n        if (isVS)\n            this._vertGNdx = dsfNdx - 1;\n        else\n            this._fragGNdx = dsfNdx - 1;\n        const ext2 = System.instance.context.getExtension(\"WEBGL_debug_shaders\");\n        if (!ext2)\n            return;\n        const srcH = ext2.getTranslatedShaderSource(shader);\n        if (!srcH)\n            return;\n        // TODO: implement WebGL2 specific inputs for gl_VertexID and gl_InstanceID if ever used\n        // parse and edit srcH to make it compilable\n        const fnameH = `${sname}.hlsl`;\n        let numTargets = 0; // for gl_Color cases\n        let haveGLpos = false;\n        let haveGLpntsz = false;\n        let haveGLDepth = false;\n        let haveGLFrontFacing = false;\n        let haveGLPointCoord = false;\n        let haveGLFragCoord = false;\n        let haveGLFragColorOnly = false; // for only 1 output\n        const haveGLFragColor = [false, false, false, false, false, false, false, false];\n        const attrs = new Array();\n        const varyings = new Array();\n        const lines = srcH.split(\"\\n\");\n        let toss = true;\n        for (let ndx = 0; ndx < lines.length;) {\n            let line = lines[ndx];\n            if (line.indexOf(\"// INITIAL HLSL END\") >= 0)\n                toss = true;\n            if (toss)\n                lines.splice(ndx, 1);\n            if (line.indexOf(\"// INITIAL HLSL BEGIN\") >= 0) {\n                toss = false;\n            }\n            else if (!toss) { // look for lines that need editing\n                if (line.indexOf(\"Varyings\") >= 0) { // save off varyings in either case\n                    while (ndx + 1 < lines.length && lines[ndx + 1].indexOf(\"static\") >= 0) {\n                        ++ndx;\n                        line = lines[ndx].substring(6).trimStart();\n                        varyings.push(line.substring(0, line.indexOf(\"=\")));\n                    }\n                }\n                if (isVS) {\n                    if (line.indexOf(\"Attributes\") >= 0) { // save off attributes\n                        while (ndx + 1 < lines.length && lines[ndx + 1].indexOf(\"static\") >= 0) {\n                            ++ndx;\n                            line = lines[ndx].substring(6).trimStart();\n                            attrs.push(line.substring(0, line.indexOf(\"=\")));\n                        }\n                    }\n                    else if (line.indexOf(\"static float4 gl_Position\") >= 0) {\n                        haveGLpos = true;\n                    }\n                    else if (line.indexOf(\"static float gl_PointSize\") >= 0) {\n                        haveGLpntsz = true;\n                    }\n                    else if (line.indexOf(\"@@ VERTEX ATTRIBUTES @@\") >= 0) {\n                        lines[ndx] = \"// @@ VERTEX ATTRIBUTES @@\";\n                    }\n                    else if (line.indexOf(\"@@ MAIN PROLOGUE @@\") >= 0) {\n                        lines[ndx] = \"// @@ MAIN PROLOGUE @@\\ngetInput(input);\";\n                    }\n                    else if (line.indexOf(\"@@ VERTEX OUTPUT @@\") >= 0) {\n                        // have to create a VS_OUTPUT struct and a generateOutput function from varyings\n                        lines[ndx] = \"// @@ VERTEX OUTPUT @@\\nstruct VS_INPUT\\n  {\";\n                        let aNdx = 0;\n                        for (const tstr of attrs) {\n                            ++ndx;\n                            lines.splice(ndx, 0, `  ${tstr}: TEXCOORD${aNdx};`);\n                            ++aNdx;\n                        }\n                        ++ndx;\n                        lines.splice(ndx, 0, \"  };\\nvoid getInput(VS_INPUT input) {\");\n                        for (const tstr of attrs) {\n                            let t = tstr.indexOf(\"_a\");\n                            let vName = tstr.substring(t);\n                            t = vName.indexOf(\" \");\n                            vName = vName.substring(0, t);\n                            ++ndx;\n                            lines.splice(ndx, 0, `  ${vName} = input.${vName};`);\n                        }\n                        ++ndx;\n                        lines.splice(ndx, 0, \"}\\nstruct VS_OUTPUT\\n  {\");\n                        if (haveGLpos) {\n                            ++ndx;\n                            lines.splice(ndx, 0, \"  float4 _v_position : SV_Position;\");\n                        }\n                        if (haveGLpntsz) {\n                            ++ndx;\n                            lines.splice(ndx, 0, \"  float gl_PointSize : PointSize;\");\n                        }\n                        let vNdx = 0;\n                        for (const tstr of varyings) {\n                            ++ndx;\n                            lines.splice(ndx, 0, `  ${tstr}: TEXCOORD${vNdx};`);\n                            ++vNdx;\n                        }\n                        ++ndx;\n                        lines.splice(ndx, 0, \"  };\\nVS_OUTPUT generateOutput(VS_INPUT input) {\\n  VS_OUTPUT output;\");\n                        if (haveGLpos) {\n                            ++ndx;\n                            lines.splice(ndx, 0, \"  output._v_position = gl_Position;\");\n                        }\n                        if (haveGLpntsz) {\n                            ++ndx;\n                            lines.splice(ndx, 0, \"  output.gl_PointSize = gl_PointSize;\");\n                        }\n                        for (const tstr of varyings) {\n                            let t = tstr.indexOf(\"_v\");\n                            let vName = tstr.substring(t);\n                            t = vName.indexOf(\" \");\n                            vName = vName.substring(0, t);\n                            ++ndx;\n                            lines.splice(ndx, 0, `  output.${vName} = ${vName};`);\n                        }\n                        ++ndx;\n                        lines.splice(ndx, 0, \"  return output;\\n}\");\n                    }\n                }\n                else { // fragment shader\n                    let tNdx = 0;\n                    if (line.indexOf(\"static float4 gl_Color[\") >= 0) {\n                        //\n                    }\n                    else if (line.indexOf(\"gl_Color[0] =\") >= 0) {\n                        if (numTargets < 1)\n                            numTargets = 1;\n                    }\n                    else if (line.indexOf(\"gl_Color[1] =\") >= 0) {\n                        if (numTargets < 2)\n                            numTargets = 2;\n                    }\n                    else if (line.indexOf(\"gl_Color[2] =\") >= 0) {\n                        if (numTargets < 3)\n                            numTargets = 3;\n                    }\n                    else if (line.indexOf(\"gl_Color[3] =\") >= 0) {\n                        numTargets = 4;\n                    }\n                    else if (line.indexOf(\"gl_Depth\") >= 0) {\n                        haveGLDepth = true;\n                    }\n                    else if (line.indexOf(\"gl_FrontFacing\") >= 0) {\n                        haveGLFrontFacing = true;\n                    }\n                    else if (line.indexOf(\"gl_PointCoord\") >= 0) {\n                        haveGLPointCoord = true;\n                    }\n                    else if (line.indexOf(\"gl_FragCoord\") >= 0) {\n                        haveGLFragCoord = true;\n                    }\n                    else if ((tNdx = line.indexOf(\"out_FragColor\")) >= 0) {\n                        const c = line.substring(tNdx + 13, tNdx + 13 + 1);\n                        if (c === \" \" || c === \"=\")\n                            haveGLFragColorOnly = true;\n                        else {\n                            tNdx = +c;\n                            haveGLFragColor[tNdx] = true;\n                        }\n                    }\n                    else if (line.indexOf(\"@@ PIXEL OUTPUT @@\") >= 0) {\n                        // have to create a VS_OUTPUT struct, a getInputs function (both from varyings),\n                        // a PS_OUTPUT struct, and a generateOutput function (both based on numTargets or haveGLFragColor)\n                        lines[ndx] = \"// @@ PIXEL OUTPUT @@\\nstruct VS_OUTPUT\\n  {\";\n                        if (haveGLFragCoord) {\n                            ++ndx;\n                            lines.splice(ndx, 0, \"  float4 gl_FragCoord : SV_POSITION;\");\n                        }\n                        let vNdx = 0;\n                        for (const tstr of varyings) {\n                            ++ndx;\n                            lines.splice(ndx, 0, `  ${tstr}: TEXCOORD${vNdx};`);\n                            ++vNdx;\n                        }\n                        if (haveGLFrontFacing) {\n                            ++ndx;\n                            lines.splice(ndx, 0, \"  bool gl_FrontFacing : SV_IsFrontFace;\");\n                        }\n                        if (haveGLPointCoord) {\n                            ++ndx;\n                            lines.splice(ndx, 0, \"  float2 gl_PointCoord : PointCoord;\");\n                        }\n                        ++ndx;\n                        lines.splice(ndx, 0, \"  };\\nvoid getInputs(VS_OUTPUT input) {\");\n                        if (haveGLFragCoord) {\n                            ++ndx;\n                            lines.splice(ndx, 0, \"  gl_FragCoord = input.gl_FragCoord;\");\n                        }\n                        for (const tstr of varyings) {\n                            let t = tstr.indexOf(\"_v\");\n                            let vName = tstr.substring(t);\n                            t = vName.indexOf(\" \");\n                            vName = vName.substring(0, t);\n                            ++ndx;\n                            lines.splice(ndx, 0, `  ${vName} = input.${vName};`);\n                        }\n                        if (haveGLFrontFacing) {\n                            ++ndx;\n                            lines.splice(ndx, 0, \"  gl_FrontFacing = input.gl_FrontFacing;\");\n                        }\n                        if (haveGLPointCoord) {\n                            ++ndx;\n                            lines.splice(ndx, 0, \"  gl_PointCoord = input.gl_PointCoord;\");\n                        }\n                        ++ndx;\n                        lines.splice(ndx, 0, \"}\\nstruct PS_OUTPUT\\n  {\");\n                        let cNdx = 0;\n                        while (cNdx < numTargets) {\n                            ++ndx;\n                            lines.splice(ndx, 0, `  float4 col${cNdx} : SV_TARGET${cNdx};`);\n                            ++cNdx;\n                        }\n                        if (haveGLFragColorOnly) {\n                            ++ndx;\n                            lines.splice(ndx, 0, \"  float4 out_FragColor : SV_TARGET;\");\n                        }\n                        else {\n                            for (cNdx = 0; cNdx < haveGLFragColor.length; ++cNdx) {\n                                if (haveGLFragColor[cNdx]) {\n                                    ++ndx;\n                                    lines.splice(ndx, 0, `  float4 out_FragColor${cNdx} : SV_TARGET${cNdx};`);\n                                }\n                            }\n                        }\n                        if (haveGLDepth) {\n                            ++ndx;\n                            lines.splice(ndx, 0, \"  float gl_Depth : SV_Depth;\");\n                        }\n                        ++ndx;\n                        lines.splice(ndx, 0, \"  };\\nPS_OUTPUT generateOutput () {\\n  PS_OUTPUT output;\");\n                        cNdx = 0;\n                        while (cNdx < numTargets) {\n                            ++ndx;\n                            lines.splice(ndx, 0, `  output.col${cNdx} = gl_Color[${cNdx}];`);\n                            ++cNdx;\n                        }\n                        if (haveGLFragColorOnly) {\n                            ++ndx;\n                            lines.splice(ndx, 0, \"  output.out_FragColor = out_FragColor;\");\n                        }\n                        else {\n                            for (cNdx = 0; cNdx < haveGLFragColor.length; ++cNdx) {\n                                if (haveGLFragColor[cNdx]) {\n                                    ++ndx;\n                                    lines.splice(ndx, 0, `  output.out_FragColor${cNdx} = out_FragColor${cNdx};`);\n                                }\n                            }\n                        }\n                        if (haveGLDepth) {\n                            ++ndx;\n                            lines.splice(ndx, 0, \"  output.gl_Depth = gl_Depth;\");\n                        }\n                        ++ndx;\n                        lines.splice(ndx, 0, \"  return output;\\n}\");\n                    }\n                    else if (line.indexOf(\"PS_OUTPUT main\") >= 0) {\n                        lines[ndx] = `// ${line}\\nPS_OUTPUT main(VS_OUTPUT input){`;\n                    }\n                    else if (line.indexOf(\"@@ MAIN PROLOGUE @@\") >= 0) {\n                        lines[ndx] = `// ${line}\\ngetInputs(input);`;\n                    }\n                }\n                ++ndx;\n            }\n        }\n        const srcH2 = lines.join(\"\\n\");\n        dsfNdx = shaderFiles.push(new DebugShaderFile(fnameH, srcH2, isVS, false, false));\n        if (isVS)\n            this._vertHNdx = dsfNdx - 1;\n        else\n            this._fragHNdx = dsfNdx - 1;\n    }\n}\n/** Context in which ShaderPrograms are executed. Avoids switching shaders unnecessarily.\n * Ensures shader programs are compiled before use and un-bound when scope is disposed.\n * This class must *only* be used inside a using() function!\n * @internal\n */\nexport class ShaderProgramExecutor {\n    constructor(target, pass, program) {\n        this._isDisposed = false;\n        this.params.init(target, pass);\n        this.changeProgram(program);\n    }\n    static freeParams() {\n        this._params = undefined;\n    }\n    get isDisposed() { return this._isDisposed; }\n    /** Clears the current program to be executed. This does not free WebGL resources, since those are owned by Techniques. */\n    dispose() {\n        this.changeProgram(undefined);\n        ShaderProgramExecutor.freeParams();\n        this._isDisposed = true;\n    }\n    setProgram(program) { return this.changeProgram(program); }\n    get isValid() { return undefined !== this._program; }\n    get target() { return this.params.target; }\n    get renderPass() { return this.params.renderPass; }\n    get params() {\n        if (undefined === ShaderProgramExecutor._params)\n            ShaderProgramExecutor._params = new ShaderProgramParams();\n        return ShaderProgramExecutor._params;\n    }\n    draw(params) {\n        assert(this.isValid);\n        if (undefined !== this._program) {\n            this._program.draw(params);\n        }\n    }\n    drawInterrupt(params) {\n        assert(params.target === this.params.target);\n        const tech = params.target.techniques.getTechnique(params.geometry.techniqueId);\n        const program = tech.getShader(TechniqueFlags.defaults);\n        if (this.setProgram(program)) {\n            this.draw(params);\n        }\n    }\n    pushBranch(branch) { this.target.pushBranch(branch); }\n    popBranch() { this.target.popBranch(); }\n    pushBatch(batch) { this.target.pushBatch(batch); }\n    popBatch() { this.target.popBatch(); }\n    changeProgram(program) {\n        if (this._program === program) {\n            return true;\n        }\n        else if (undefined !== this._program) {\n            this._program.endUse();\n        }\n        this._program = program;\n        if (undefined !== program && !program.use(this.params)) {\n            this._program = undefined;\n            return false;\n        }\n        return true;\n    }\n}\n//# sourceMappingURL=ShaderProgram.js.map",
      "start": 1693508121182,
      "end": 1693508121502,
      "sourcemaps": null
    }
  ]
}
