{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/FuzzySearch.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tools\n */\nimport Fuse from \"fuse.js\";\n/** @public */\nexport class FuzzySearch {\n    /** Override to provide non-standard FuseOptions for searches where the a single word pattern is used */\n    onGetSingleWordSearchOptions() {\n        return {\n            shouldSort: true,\n            threshold: 0.40,\n            location: 0,\n            distance: 100,\n            maxPatternLength: 32,\n            minMatchCharLength: 2,\n            includeMatches: true,\n            includeScore: true,\n        };\n    }\n    /** Override to provide non-standard FuseOptions for searches where the a multiple word pattern is used */\n    onGetMultiWordSearchOptions() {\n        return {\n            shouldSort: true,\n            threshold: 0.40,\n            tokenize: true,\n            matchAllTokens: true,\n            maxPatternLength: 32,\n            minMatchCharLength: 2,\n            includeMatches: true,\n            includeScore: true,\n        };\n    }\n    /** Call to conduct a fuzzy search of searchedObjects, looking at the 'key' member of each such object\n     * @param searchedObjects An array of objects to search.\n     * @param keys The name of the members to search in the searchedObjects.\n     * @param pattern The pattern for which each searchedObject is searched.\n     * @return FuzzySearchResults.\n     */\n    search(searchedObjects, keys, pattern) {\n        if (!pattern || pattern.length < 2)\n            return new FuzzySearchResults(undefined);\n        // it is a multi-word pattern if there's a space other than at the end of the pattern.\n        const spaceIndex = pattern.indexOf(\" \");\n        const multiWord = (-1 !== spaceIndex) && (spaceIndex !== (pattern.length - 1));\n        const options = multiWord ? this.onGetMultiWordSearchOptions() : this.onGetSingleWordSearchOptions();\n        options.keys = keys;\n        const fuse = new Fuse(searchedObjects, options);\n        let results = fuse.search(pattern);\n        // We need to set the threshold fairly high to get results when the user misspells words (otherwise they are not returned),\n        // but doing that results in matches that don't make sense when there are \"good\" matches. So we discard matches where the match\n        // score increases by a large amount between results.\n        let checkScoreDelta = false;\n        let averageScoreDeltaThreshold = 1;\n        if (results.length > 30) {\n            averageScoreDeltaThreshold = ((results[results.length - 1].score - results[0].score) / results.length) * 10;\n            if (averageScoreDeltaThreshold > 0.01)\n                checkScoreDelta = true;\n        }\n        // Sometimes fuse returns results in the array where the matches array is empty. That seems like a bug to me, but it happens when\n        // the input  is something like \"fjt\" and the string it matches is \"fit\". If we have more than three actual matches, we just truncate the set when we see one.\n        // The other use for this loop is to truncate when we see a dramatic increase in the score. The ones after are unlikely\n        // to be useful, so we truncate the results when we hit that point also.\n        for (let resultIndex = 0; resultIndex < results.length; resultIndex++) {\n            const thisResult = results[resultIndex];\n            if (0 === thisResult.matches.length) {\n                // here we have a result with no matches. If we have other matches, just discard this and the rest.\n                if (resultIndex > 2) {\n                    results = results.slice(0, resultIndex);\n                    break;\n                }\n                // otherwise we want to keep this result, but we have to add the matched value to the object because we can't get it from the matches array.\n                // we assume it came from the first key (usually there's only one anyway).\n                thisResult.matchedValue = thisResult.item[keys[0]];\n                thisResult.matchedKey = keys[0];\n            }\n            if (checkScoreDelta && (resultIndex > 0)) {\n                const resultScore = results[resultIndex].score;\n                if (resultScore < 0.101)\n                    continue;\n                if ((resultScore - results[resultIndex - 1].score) > averageScoreDeltaThreshold) {\n                    results = results.slice(0, resultIndex);\n                    break;\n                }\n            }\n        }\n        // put the functions on each result so it fulfils the FuzzySearchResult interface.\n        for (const thisResult of results) {\n            thisResult.getResult = getResult.bind(thisResult);\n            thisResult.getBoldMask = getBoldMask.bind(thisResult);\n            thisResult.getMatchedKey = getMatchedKey.bind(thisResult);\n            thisResult.getMatchedValue = getMatchedValue.bind(thisResult);\n        }\n        return new FuzzySearchResults(results);\n    }\n}\n/** Added to each result to support the FuzzySearchResult interface. */\nfunction getResult() {\n    return this.item;\n}\n/** Added to each result to support the FuzzySearchResult interface. */\nfunction getMatchedKey() {\n    return (this.matches.length > 0) ? this.matches[0].key : this.matchedKey;\n}\n/** Added to each result to support the FuzzySearchResult interface. */\nfunction getMatchedValue() {\n    return (this.matches.length > 0) ? this.matches[0].value : this.matchedValue;\n}\n/** this function is added to each result to support the FuzzySearchResult interface. */\nfunction getBoldMask() {\n    if (this.boldMask)\n        return this.boldMask;\n    // if we had no matches, we return a bold mask with all false.\n    if (0 === this.matches.length) {\n        const noBoldMask = new Array(this.matchedValue.length);\n        noBoldMask.fill(false);\n        return this.boldMask = noBoldMask;\n    }\n    // we have some matched portions.\n    const thisMatchedString = this.matches[0].value;\n    const valueLength = thisMatchedString.length;\n    const boldMask = new Array(valueLength);\n    boldMask.fill(false);\n    const indicesArray = this.matches[0].indices;\n    indicesArray.forEach((set) => {\n        for (let start = set[0], end = set[1]; start <= end; start++) {\n            boldMask[start] = true;\n        }\n    });\n    // cache it so if someone asks again we don't have to recalculate it.\n    return this.boldMask = boldMask;\n}\n/**\n * This class is used to return the results of FuzzySearch.search. It is iterable, with each iteration\n * returning an object implementing the FuzzySearchResult interface.\n * @public\n */\nexport class FuzzySearchResults {\n    constructor(results) {\n        this.results = [];\n        if (results)\n            this.results = results;\n    }\n    [Symbol.iterator]() { return new FuzzySearchResultsIterator(this); }\n    get length() { return this.results.length; }\n    getResult(resultIndex) {\n        if ((resultIndex < 0) || (resultIndex > this.results.length))\n            return undefined;\n        return this.results[resultIndex];\n    }\n}\nclass FuzzySearchResultsIterator {\n    constructor(fsr) {\n        this.next = () => {\n            return {\n                done: this.counter === this.fsr.results.length,\n                value: this.fsr.results[this.counter++],\n            };\n        };\n        this.fsr = fsr;\n        this.counter = 0;\n    }\n}\n//# sourceMappingURL=FuzzySearch.js.map",
      "start": 1693508118954,
      "end": 1693508119118,
      "sourcemaps": null
    }
  ]
}
