{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tile/map/ImageryProviders/WmsMapLayerImageryProvider.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tiles\n */\nimport { IModelStatus } from \"@itwin/core-bentley\";\nimport { ServerError } from \"@itwin/core-common\";\nimport { Point2d } from \"@itwin/core-geometry\";\nimport { MapLayerImageryProvider, MapLayerImageryProviderStatus, WmsCapabilities, WmsUtilities, } from \"../../internal\";\n// eslint-disable-next-line prefer-const\nlet doToolTips = true;\nconst scratchPoint2d = Point2d.createZero();\n/** @internal */\nexport class WmsMapLayerImageryProvider extends MapLayerImageryProvider {\n    constructor(settings) {\n        super(settings, false);\n        this._subLayerRanges = new Map();\n        this._baseUrl = WmsUtilities.getBaseUrl(this._settings.url);\n    }\n    async initialize() {\n        try {\n            const credentials = (this._settings.userName && this._settings.password ? { user: this._settings.userName, password: this._settings.password } : undefined);\n            this._capabilities = await WmsCapabilities.create(this._baseUrl, credentials);\n            if (undefined !== this._capabilities) {\n                this._allLayersRange = this._capabilities.cartoRange;\n                if (this._capabilities.layer && Array.isArray(this._capabilities.layer.subLayers)) {\n                    const mapCartoRanges = ((subLayer) => {\n                        if (Array.isArray(subLayer.children))\n                            subLayer.children.forEach((child) => mapCartoRanges(child));\n                        else if (subLayer.cartoRange)\n                            this._subLayerRanges.set(subLayer.name, subLayer.cartoRange);\n                    });\n                    this._capabilities.layer.subLayers.forEach((subLayer) => mapCartoRanges(subLayer));\n                    this._settings.subLayers.forEach((subLayer) => {\n                        if (subLayer.isNamed && this._settings.isSubLayerVisible(subLayer)) {\n                            const subLayerRange = this._subLayerRanges.get(subLayer.name);\n                            if (subLayerRange)\n                                if (this.cartoRange)\n                                    this.cartoRange.extendRange(subLayerRange);\n                                else\n                                    this.cartoRange = subLayerRange.clone();\n                        }\n                    });\n                }\n                if (!this.cartoRange)\n                    this.cartoRange = this._allLayersRange;\n                this._crsSupport = this.getCrsSupport();\n            }\n        }\n        catch (error) {\n            // Don't throw error if unauthorized status:\n            // We want the tile tree to be created, so that end-user can get feedback on which layer is missing credentials.\n            // When credentials will be provided, a new provider will be created, and initialization should be fine.\n            if (error?.status === 401) {\n                this.setStatus(MapLayerImageryProviderStatus.RequireAuth);\n            }\n            else {\n                throw new ServerError(IModelStatus.ValidationFailed, \"\");\n            }\n        }\n    }\n    getVisibleLayerString() {\n        const layerNames = this.getVisibleLayers().map((layer) => layer.name);\n        return layerNames.join(\"%2C\");\n    }\n    getVisibleLayers() {\n        return this._settings.subLayers.filter((subLayer) => this._settings.isSubLayerVisible(subLayer) && subLayer.isNamed);\n    }\n    getVisibleLayersSrs() {\n        const visibleLayers = this.getVisibleLayers();\n        const visibleLayerNames = visibleLayers.map((layer) => layer.name);\n        return this._capabilities?.getSubLayersCrs(visibleLayerNames);\n    }\n    getQueryableLayers() {\n        const layerNames = new Array();\n        const getQueryableSubLayers = ((subLayer) => {\n            if (!subLayer)\n                return;\n            if (subLayer.queryable)\n                layerNames.push(subLayer.name);\n            subLayer.children?.forEach((childSubLayer) => getQueryableSubLayers(childSubLayer));\n        });\n        this._capabilities?.layer?.subLayers?.forEach((subLayer) => getQueryableSubLayers(subLayer));\n        return layerNames;\n    }\n    getVisibleQueryableLayersString() {\n        const layers = new Array();\n        const queryable = this.getQueryableLayers();\n        const visibleLayerNames = this.getVisibleLayers().map((layer) => layer.name);\n        queryable.forEach((layer) => {\n            if (visibleLayerNames.includes(layer))\n                layers.push(layer);\n        });\n        return layers.join(\"%2C\");\n    }\n    getCrsSupport() {\n        const layersCrs = this.getVisibleLayersSrs();\n        let support3857;\n        let support4326;\n        if (layersCrs) {\n            for (const [_layerName, crs] of layersCrs) {\n                if (crs.find((layerCrs) => layerCrs.includes(\"3857\")) === undefined) {\n                    support3857 = false;\n                }\n                else if (support3857 === undefined) {\n                    support3857 = true;\n                }\n                if (crs.find((layerCrs) => layerCrs.includes(\"4326\")) === undefined) {\n                    support4326 = false;\n                }\n                else if (support4326 === undefined) {\n                    support4326 = true;\n                }\n            }\n        }\n        return { support3857: support3857 ?? false, support4326: support4326 ?? false };\n    }\n    // WMS standard requires 'TRUE' or 'FALSE' (case sensitive) values.\n    get transparentBackgroundString() { return this._settings.transparentBackground ? \"TRUE\" : \"FALSE\"; }\n    // construct the Url from the desired Tile\n    async constructUrl(row, column, zoomLevel) {\n        let bboxString = \"\";\n        let crsString = \"\";\n        // We support 2 SRS: EPSG:3857 and EPSG:4326, we prefer EPSG:3857.\n        if (this._crsSupport?.support3857) {\n            bboxString = this.getEPSG3857ExtentString(row, column, zoomLevel);\n            crsString = \"EPSG%3A3857\";\n        }\n        else if (this._crsSupport?.support4326) {\n            // The WMS 1.3.0 specification mandates using the axis ordering as defined in the EPSG database.\n            // For instance, for EPSG:4326 the axis ordering is latitude/longitude, or north/east.\n            // WMS 1.1.0 always requires the axis ordering to be longitude/latitude. *sigh*\n            if (this._capabilities !== undefined) {\n                bboxString = this.getEPSG4326ExtentString(row, column, zoomLevel, this._capabilities?.isVersion13); // lat/long ordering\n                crsString = \"EPSG%3A4326\";\n            }\n        }\n        const layerString = this.getVisibleLayerString();\n        if (bboxString.length === 0 || crsString.length === 0 || layerString.length === 0)\n            return \"\";\n        const crsParamName = this._capabilities?.isVersion13 ? \"CRS\" : \"SRS\";\n        return `${this._baseUrl}?SERVICE=WMS&VERSION=${this._capabilities?.version}&REQUEST=GetMap&FORMAT=image%2Fpng&TRANSPARENT=${this.transparentBackgroundString}&LAYERS=${layerString}&WIDTH=${this.tileSize}&HEIGHT=${this.tileSize}&${crsParamName}=${crsString}&STYLES=&BBOX=${bboxString}`;\n    }\n    async getToolTip(strings, quadId, carto, tree) {\n        await super.getToolTip(strings, quadId, carto, tree);\n        const infoFormats = this._capabilities?.featureInfoFormats;\n        if (!doToolTips || undefined === infoFormats)\n            return;\n        let formatString = infoFormats.find((format) => format === \"text/html\");\n        if (!formatString)\n            formatString = infoFormats[0];\n        const bboxString = this.getEPSG3857ExtentString(quadId.row, quadId.column, quadId.level);\n        const layerString = this.getVisibleQueryableLayersString();\n        if (layerString.length === 0)\n            return;\n        const rectangle = tree.getTileRectangle(quadId);\n        const fraction = rectangle.worldToLocal(Point2d.create(carto.longitude, carto.latitude, scratchPoint2d));\n        const x = Math.floor(.5 + fraction.x * this.tileSize);\n        const y = Math.floor(.5 + (1.0 - fraction.y) * this.tileSize);\n        const coordinateString = this._capabilities?.isVersion13 ? `&i=${x}&j=${y}` : `&x=${x}&y=${y}`;\n        const crsParamName = this._capabilities?.isVersion13 ? \"CRS\" : \"SRS\";\n        const getFeatureUrl = `${this._baseUrl}?SERVICE=WMS&VERSION=${this._capabilities?.version}&REQUEST=GetFeatureInfo&LAYERS=${layerString}&WIDTH=${this.tileSize}&HEIGHT=${this.tileSize}&${crsParamName}=EPSG%3A3857&BBOX=${bboxString}&QUERY_LAYERS=${layerString}${coordinateString}&info_format=${formatString}`;\n        return this.toolTipFromUrl(strings, getFeatureUrl);\n    }\n}\n//# sourceMappingURL=WmsMapLayerImageryProvider.js.map",
      "start": 1693508121814,
      "end": 1693508121907,
      "sourcemaps": null
    }
  ]
}
