{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/numerics/PascalCoefficients.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/**\n * PascalCoeffients class has static methods which return rows of the PascalTriangle.\n * @internal\n */\nclass PascalCoefficients {\n    /**\n     * * return a row of the pascal table.\n     * * The contents must not be altered by the user !!!\n     * * Hypothetically the request row can be any integer.\n     * * BUT in practice, values 60 create integer entries that are too big for IEEE double.\n     */\n    static getRow(row) {\n        const allRows = PascalCoefficients._allRows;\n        if (allRows.length === 0) {\n            // seed the table . . .\n            allRows.push(new Float64Array([1]));\n            allRows.push(new Float64Array([1, 1]));\n            allRows.push(new Float64Array([1, 2, 1]));\n            allRows.push(new Float64Array([1, 3, 3, 1]));\n            allRows.push(new Float64Array([1, 4, 6, 4, 1]));\n            allRows.push(new Float64Array([1, 5, 10, 10, 5, 1]));\n            allRows.push(new Float64Array([1, 6, 15, 20, 15, 6, 1]));\n            allRows.push(new Float64Array([1, 7, 21, 35, 35, 21, 7, 1]));\n        }\n        while (allRows.length <= row) {\n            const k = allRows.length;\n            const oldRow = allRows[k - 1];\n            const newRow = new Float64Array(k + 1);\n            newRow[0] = 1.0;\n            for (let i = 1; i < k; i++)\n                newRow[i] = oldRow[i - 1] + oldRow[i];\n            newRow[k] = 1.0;\n            allRows.push(newRow);\n        }\n        return allRows[row];\n    }\n    /** Return an array with Bezier weighted pascal coefficients\n     * @param row row index in the pascal triangle.  (`row+1` entries)\n     * @param u parameter value\n     * @param result optional destination array.\n     * @note if the destination array is undefined or too small, a new Float64Array is allocated.\n     * @note if the destination array is larger than needed, its leading `row+1` values are filled,\n     *     and the array is returned.\n     */\n    static getBezierBasisValues(order, u, result) {\n        const row = order - 1;\n        const pascalRow = PascalCoefficients.getRow(row);\n        if (result === undefined || result.length < order)\n            result = new Float64Array(order);\n        for (let i = 0; i < order; i++)\n            result[i] = pascalRow[i];\n        // multiply by increasing powers of u ...\n        let p = u;\n        for (let i = 1; i < order; i++, p *= u) {\n            result[i] *= p;\n        }\n        // multiply by powers of (1-u), working from right\n        const v = 1.0 - u;\n        p = v;\n        for (let i = order - 2; i >= 0; i--, p *= v) {\n            result[i] *= p;\n        }\n        return result;\n    }\n    /** Return an array with derivatives of Bezier weighted pascal coefficients\n     * @param row row index in the pascal triangle.  (`row+1` entries)\n     * @param u parameter value\n     * @param result optional destination array.\n     * @note if the destination array is undefined or too small, a new Float64Array is allocated.\n     * @note if the destination array is larger than needed, its leading `row+1` values are filled,\n     *     and the array is returned.\n     */\n    static getBezierBasisDerivatives(order, u, result) {\n        result = this.getBezierBasisValues(order - 1, u, result);\n        // derivative is df/du = (order-1 ) * sum ( q[i+1] - q[i])   summed on 0 <= i < order - 1.\\\n        // evaluate lower order basis, overwrite in place from right to left\n        const f = order - 1;\n        result[order - 1] = f * result[order - 2];\n        for (let k = order - 2; k > 0; k--) {\n            result[k] = f * (result[k - 1] - result[k]);\n        }\n        result[0] = -f * result[0];\n        return result;\n    }\n}\nPascalCoefficients._allRows = [];\nexport { PascalCoefficients };\n//# sourceMappingURL=PascalCoefficients.js.map",
      "start": 1693508122612,
      "end": 1693508122767,
      "sourcemaps": null
    }
  ]
}
