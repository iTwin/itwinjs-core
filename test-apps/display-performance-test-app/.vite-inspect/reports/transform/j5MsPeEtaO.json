{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/curve/Query/ConsolidateAdjacentPrimitivesContext.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Curve\n */\nimport { NullGeometryHandler } from \"../../geometry3d/GeometryHandler\";\nimport { PolylineCompressionContext } from \"../../geometry3d/PolylineCompressionByEdgeOffset\";\nimport { PolylineOps } from \"../../geometry3d/PolylineOps\";\nimport { Arc3d } from \"../Arc3d\";\nimport { ConsolidateAdjacentCurvePrimitivesOptions } from \"../CurveCollection\";\nimport { CurveFactory } from \"../CurveFactory\";\nimport { LineSegment3d } from \"../LineSegment3d\";\nimport { LineString3d } from \"../LineString3d\";\n/**\n * * Implementation class for ConsolidateAdjacentCurvePrimitives.\n *\n * @internal\n */\nexport class ConsolidateAdjacentCurvePrimitivesContext extends NullGeometryHandler {\n    constructor(options) {\n        super();\n        this._options = options ? options : new ConsolidateAdjacentCurvePrimitivesOptions();\n    }\n    /** look for adjacent compatible primitives in a path or loop. */\n    handleCurveChain(g) {\n        const children = g.children;\n        const numOriginal = children.length;\n        const points = [];\n        let numAccept = 0;\n        // i0 <=i < i1 is a range of child indices.\n        // numAccept is the number of children accepted (contiguously at front of children)\n        for (let i0 = 0; i0 < numOriginal;) {\n            const basePrimitive = g.children[i0];\n            if (this._options.consolidateLinearGeometry && (basePrimitive instanceof LineSegment3d || basePrimitive instanceof LineString3d)) {\n                points.length = 0;\n                let i1 = i0;\n                // on exit, i1 is beyond the block of linear primitives  . ..\n                for (; i1 < g.children.length; i1++) {\n                    const nextPrimitive = g.children[i1];\n                    if (nextPrimitive instanceof LineSegment3d) {\n                        points.push(nextPrimitive.startPoint());\n                        points.push(nextPrimitive.endPoint());\n                    }\n                    else if (nextPrimitive instanceof LineString3d) {\n                        const source = nextPrimitive.packedPoints;\n                        for (let k = 0; k < source.length; k++) {\n                            points.push(source.getPoint3dAtUncheckedPointIndex(k));\n                        }\n                    }\n                    else {\n                        break;\n                    }\n                }\n                if (points.length > 1) {\n                    const tolerance = this._options.colinearPointTolerance;\n                    const compressedPointsA = PolylineOps.compressShortEdges(points, tolerance);\n                    const compressedPointsB = PolylineOps.compressByPerpendicularDistance(compressedPointsA, tolerance);\n                    if (i0 === 0 && i1 === numOriginal) {\n                        // points is the entire curve, and the curve is closed.   Maybe the first and last segments are colinear.\n                        PolylineCompressionContext.compressColinearWrapInPlace(compressedPointsB, tolerance);\n                    }\n                    if (compressedPointsB.length < 2) {\n                        // Collapsed to a point?  Make a single point linestring\n                        g.children[numAccept++] = LineString3d.create(compressedPointsB[0]);\n                    }\n                    else if (compressedPointsB.length === 2) {\n                        g.children[numAccept++] = LineSegment3d.create(compressedPointsB[0], compressedPointsB[1]);\n                    }\n                    else {\n                        g.children[numAccept++] = LineString3d.createPoints(compressedPointsB);\n                    }\n                }\n                else {\n                    g.children[numAccept++] = basePrimitive;\n                }\n                i0 = i1;\n            }\n            else if (this._options.consolidateCompatibleArcs && basePrimitive instanceof Arc3d) {\n                // subsume subsequent arcs into basePrimitive.\n                // always accept base primitive.\n                for (; ++i0 < g.children.length;) {\n                    const nextPrimitive = g.children[i0];\n                    if (!(nextPrimitive instanceof Arc3d))\n                        break;\n                    if (!CurveFactory.appendToArcInPlace(basePrimitive, nextPrimitive))\n                        break;\n                }\n                // i0 has already advanced\n                g.children[numAccept++] = basePrimitive; // which has been extended 0 or more times.\n            }\n            else {\n                g.children[numAccept++] = basePrimitive;\n                i0++;\n            }\n        }\n        g.children.length = numAccept;\n    }\n    handlePath(g) { return this.handleCurveChain(g); }\n    handleLoop(g) { return this.handleCurveChain(g); }\n    handleParityRegion(g) {\n        for (const child of g.children)\n            child.dispatchToGeometryHandler(this);\n    }\n    handleUnionRegion(g) {\n        for (const child of g.children)\n            child.dispatchToGeometryHandler(this);\n    }\n}\n//# sourceMappingURL=ConsolidateAdjacentPrimitivesContext.js.map",
      "start": 1693508124183,
      "end": 1693508124318,
      "sourcemaps": null
    }
  ]
}
