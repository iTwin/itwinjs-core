{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/bentley/lib/esm/LRUMap.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Collections\n */\nimport { Dictionary } from \"./Dictionary\";\n/**\n * Derived from:\n * Licensed under MIT. Copyright (c) 2010 Rasmus Andersson <http://hunch.se/>\n * See README.md at https://github.com/rsms/js-lru for details.\n */\n/** An entry holds the key and value, and pointers to any older and newer entries.\n * @public\n */\nexport class Entry {\n    constructor(key, value) {\n        this.key = key;\n        this.value = value;\n    }\n}\nclass EntryIterator {\n    constructor(oldestEntry) {\n        this._entry = oldestEntry;\n    }\n    next() {\n        const ent = this._entry;\n        if (!ent)\n            return { done: true, value: undefined };\n        this._entry = ent.newer;\n        const val = [ent.key, ent.value];\n        return { done: false, value: val };\n    }\n}\nclass KeyIterator {\n    constructor(oldestEntry) {\n        this._entry = oldestEntry;\n    }\n    next() {\n        const ent = this._entry;\n        if (!ent)\n            return { done: true, value: undefined };\n        this._entry = ent.newer;\n        return { done: false, value: ent.key };\n    }\n}\nclass ValueIterator {\n    constructor(oldestEntry) {\n        this._entry = oldestEntry;\n    }\n    next() {\n        const ent = this._entry;\n        if (!ent)\n            return { done: true, value: undefined };\n        this._entry = ent.newer;\n        return { done: false, value: ent.value };\n    }\n}\n/**\n * A mapping of a key/value pairs, where the size of the cache can be limited.\n *\n * When entries are inserted, if the cache is \"full\", the\n * least-recently-used (LRU) value is dropped. When entries are retrieved, they are moved to the front of the LRU list.\n *\n * Illustration of the design:\n *\n * ```\n *\n *       entry             entry             entry             entry\n *       ______            ______            ______            ______\n *      | head |.newer => |      |.newer => |      |.newer => | tail |\n *      |  A   |          |  B   |          |  C   |          |  D   |\n *      |______| <= older.|______| <= older.|______| <= older.|______|\n *\n *  removed  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  added\n * ```\n * @public\n */\nexport class LRUCache {\n    /**\n     * Construct a new LRUCache to hold up to `limit` entries.\n     */\n    constructor(limit, container) {\n        this.size = 0;\n        this.limit = limit;\n        this.oldest = this.newest = undefined;\n        this._container = container;\n    }\n    markEntryAsUsed(entry) {\n        if (entry === this.newest)\n            return; // Already the most recently used entry, so no need to update the list\n        // HEAD--------------TAIL\n        //   <.older   .newer>\n        //  <--- add direction --\n        //   A  B  C  <D>  E\n        if (entry.newer) {\n            if (entry === this.oldest) {\n                this.oldest = entry.newer;\n            }\n            entry.newer.older = entry.older; // C <-- E.\n        }\n        if (entry.older) {\n            entry.older.newer = entry.newer; // C. --> E\n        }\n        entry.newer = undefined; // D --x\n        entry.older = this.newest; // D. --> E\n        if (this.newest) {\n            this.newest.newer = entry; // E. <-- D\n        }\n        this.newest = entry;\n    }\n    /**  Replace all values in this cache with key-value pairs (2-element Arrays) from provided iterable. */\n    assign(entries) {\n        let entry;\n        let limit = this.limit || Number.MAX_VALUE;\n        this._container.clear();\n        const it = entries[Symbol.iterator]();\n        for (let itv = it.next(); !itv.done; itv = it.next()) {\n            const e = new Entry(itv.value[0], itv.value[1]);\n            this._container.set(e.key, e);\n            if (!entry) {\n                this.oldest = e;\n            }\n            else {\n                entry.newer = e;\n                e.older = entry;\n            }\n            entry = e;\n            if (limit-- === 0) {\n                throw new Error(\"overflow\");\n            }\n        }\n        this.newest = entry;\n        this.size = this._container.size;\n    }\n    /** Get and register recent use of <key>.\n     *  Returns the value associated with <key> or undefined if not in cache.\n     */\n    get(key) {\n        // First, find our cache entry\n        const entry = this._container.get(key);\n        if (!entry)\n            return; // Not cached. Sorry.\n        // As <key> was found in the cache, register it as being requested recently\n        this.markEntryAsUsed(entry);\n        return entry.value;\n    }\n    /** Put <value> into the cache associated with <key>. Replaces any existing entry with the same key.\n     *  @returns `this`.\n     */\n    set(key, value) {\n        let entry = this._container.get(key);\n        if (entry) {\n            // update existing\n            entry.value = value;\n            this.markEntryAsUsed(entry);\n            return this;\n        }\n        // new entry\n        this._container.set(key, (entry = new Entry(key, value)));\n        if (this.newest) {\n            // link previous tail to the new tail (entry)\n            this.newest.newer = entry;\n            entry.older = this.newest;\n        }\n        else {\n            // we're first in\n            this.oldest = entry;\n        }\n        // add new entry to the end of the linked list -- it is now the freshest entry.\n        this.newest = entry;\n        ++this.size;\n        if (this.size > this.limit) {\n            // we hit the limit -- remove the head\n            this.shift();\n        }\n        return this;\n    }\n    /**  Purge the least recently used (oldest) entry from the cache.\n     *  @returns The removed entry or undefined if the cache was empty.\n     */\n    shift() {\n        const entry = this.oldest;\n        if (entry) {\n            if (entry.newer) {\n                // advance the list\n                this.oldest = entry.newer;\n                this.oldest.older = undefined;\n            }\n            else {\n                // the cache is exhausted\n                this.oldest = undefined;\n                this.newest = undefined;\n            }\n            // Remove last strong reference to <entry> and remove links from the purged\n            // entry being returned:\n            entry.newer = entry.older = undefined;\n            this._container.delete(entry.key);\n            --this.size;\n            return [entry.key, entry.value];\n        }\n        return undefined;\n    }\n    /** Access value for `key` without registering recent use. Useful if you do not\n     *  want to change the state of the cache, but only \"peek\" at it.\n     *  @returns The value associated with `key` if found, or undefined if not found.\n     */\n    find(key) {\n        const e = this._container.get(key);\n        return e ? e.value : undefined;\n    }\n    /** Check if there's a value for key in the cache without registering recent use. */\n    has(key) {\n        return this._container.has(key);\n    }\n    /**  Remove entry `key` from cache and return its value.\n     *  @returns The removed value, or undefined if not found.\n     */\n    delete(key) {\n        const entry = this._container.get(key);\n        if (!entry)\n            return;\n        this._container.delete(entry.key);\n        if (entry.newer && entry.older) {\n            // re-link the older entry with the newer entry\n            entry.older.newer = entry.newer;\n            entry.newer.older = entry.older;\n        }\n        else if (entry.newer) {\n            // remove the link to us\n            entry.newer.older = undefined;\n            // link the newer entry to head\n            this.oldest = entry.newer;\n        }\n        else if (entry.older) {\n            // remove the link to us\n            entry.older.newer = undefined;\n            // link the newer entry to head\n            this.newest = entry.older;\n        }\n        else { // if(entry.older === undefined && entry.newer === undefined) {\n            this.oldest = this.newest = undefined;\n        }\n        this.size--;\n        return entry.value;\n    }\n    /**  Removes all entries */\n    clear() {\n        // Note: clearing links should be safe, as we don't expose live links to user\n        this.oldest = this.newest = undefined;\n        this.size = 0;\n        this._container.clear();\n    }\n    /** Returns an iterator over all keys, starting with the oldest. */\n    keys() {\n        return this.oldest ? new KeyIterator(this.oldest) : undefined;\n    }\n    /** Returns an iterator over all values, starting with the oldest. */\n    values() {\n        return this.oldest ? new ValueIterator(this.oldest) : undefined;\n    }\n    /** Returns an iterator over all entries, starting with the oldest. */\n    entries() {\n        return this.oldest ? new EntryIterator(this.oldest) : undefined;\n    }\n    /**  Call `fun` for each entry, starting with the oldest entry. */\n    forEach(fun, thisObj) {\n        if (typeof thisObj !== \"object\") {\n            thisObj = this; // eslint-disable-line @typescript-eslint/no-this-alias\n        }\n        let entry = this.oldest;\n        while (entry) {\n            fun.call(thisObj, entry.value, entry.key, this);\n            entry = entry.newer;\n        }\n    }\n    /** Returns a JSON (array) representation */\n    toJSON() {\n        const s = new Array(this.size);\n        let i = 0;\n        let entry = this.oldest;\n        while (entry) {\n            s[i++] = { key: entry.key, value: entry.value };\n            entry = entry.newer;\n        }\n        return s;\n    }\n    /** Returns a String representation */\n    toString() {\n        let s = \"\";\n        let entry = this.oldest;\n        while (entry) {\n            s += `${String(entry.key)}:${entry.value}`;\n            entry = entry.newer;\n            if (entry) {\n                s += \" < \";\n            }\n        }\n        return s;\n    }\n}\n/** A [[LRUCache]] using a standard Map as its internal storage.\n * @public\n */\nexport class LRUMap extends LRUCache {\n    /**\n     * Construct a new LRUMap to hold up to `limit` entries.\n     */\n    constructor(limit) {\n        super(limit, new Map());\n    }\n}\n/** A [[LRUCache]] using a [[Dictionary]] as its internal storage, permitting custom key comparison logic.\n * @public\n */\nexport class LRUDictionary extends LRUCache {\n    /**\n     * Construct a new LRUDictionary to hold up to `limit` entries.\n     * @param limit The maximum number of entries permitted in the dictionary.\n     * @param compareKeys The function used to compare keys within the dictionary.\n     */\n    constructor(limit, compareKeys) {\n        super(limit, new Dictionary(compareKeys));\n    }\n}\n//# sourceMappingURL=LRUMap.js.map",
      "start": 1693508120321,
      "end": 1693508120465,
      "sourcemaps": null
    }
  ]
}
