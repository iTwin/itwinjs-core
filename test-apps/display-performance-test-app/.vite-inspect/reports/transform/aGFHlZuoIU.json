{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/quantity/lib/esm/Formatter/Formatter.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Quantity\n */\nimport { QuantityConstants } from \"../Constants\";\nimport { QuantityError, QuantityStatus } from \"../Exception\";\nimport { DecimalPrecision, FormatTraits, FormatType, ScientificType, ShowSignOption } from \"./FormatEnums\";\n/**  rounding additive\n * @internal\n */\nconst FPV_ROUNDFACTOR = 0.50000000001;\n/** A private helper class used to format fraction part of value into a numerator and denominator.\n * @internal\n */\nclass FractionalNumeric {\n    constructor(value, precision, reduce) {\n        this._integral = 0;\n        this._numerator = 0;\n        this._denominator = 1;\n        this._greatestCommonFactor = 1;\n        this._textParts = [];\n        this.calculate(value, precision);\n        this.formTextParts(reduce);\n    }\n    calculate(value, denominator) {\n        const positiveValue = Math.abs(value);\n        this._denominator = denominator;\n        this._integral = Math.floor(positiveValue);\n        const fractionPart = positiveValue - this._integral;\n        this._numerator = Math.floor(fractionPart * this._denominator + FPV_ROUNDFACTOR);\n        if (0 !== denominator && (this._numerator / this._denominator) === 1) {\n            this._numerator = 0;\n            this._integral += 1;\n        }\n        else {\n            this._greatestCommonFactor = this.getGreatestCommonFactor(this._numerator, this._denominator);\n        }\n    }\n    /** Determine the GCD given two values. This value can be used to reduce a fraction.\n     * See algorithm description http://en.wikipedia.org/wiki/Euclidean_algorithm\n     */\n    getGreatestCommonFactor(numerator, denominator) {\n        let r;\n        while (denominator !== 0) {\n            r = numerator % denominator;\n            numerator = denominator;\n            denominator = r;\n        }\n        return (numerator < 0) ? -numerator : numerator;\n    }\n    get greatestCommonFactor() { return this._greatestCommonFactor; }\n    get hasFractionPart() { return this._textParts.length > 0; }\n    get isZero() { return 0 === this._numerator; }\n    getIntegralString() {\n        if (this._textParts.length > 0)\n            return this._textParts[0];\n        return \"\";\n    }\n    getNumeratorString() {\n        if (this._textParts.length >= 3)\n            return this._textParts[1];\n        return \"\";\n    }\n    getDenominatorString() {\n        if (this._textParts.length >= 3)\n            return this._textParts[2];\n        return \"\";\n    }\n    formTextParts(reduce) {\n        let numerator = this._numerator;\n        let denominator = this._denominator;\n        if (reduce && this._greatestCommonFactor > 1) {\n            numerator /= this.greatestCommonFactor;\n            denominator /= this.greatestCommonFactor;\n        }\n        this._textParts.push(this._integral.toFixed(0));\n        if (numerator > 0) {\n            this._textParts.push(numerator.toFixed(0));\n            this._textParts.push(denominator.toFixed(0));\n        }\n    }\n}\n/** A helper class that contains methods used to format quantity values based on a format that are defined via the Format class.\n * @beta\n */\nclass Formatter {\n    static isNegligible(value) { return (Math.abs(value) < Formatter.FPV_MINTHRESHOLD); }\n    /** Return floating point value rounded by specific rounding factor.\n     *  @param value    Value to be rounded.\n     *  @param roundTo  Rounding factor.\n     */\n    static roundDouble(value, roundTo) {\n        if (Formatter.isNegligible(roundTo))\n            return value;\n        roundTo = Math.abs(roundTo);\n        let rnd = FPV_ROUNDFACTOR + (value / roundTo);\n        const iVal = Math.floor(rnd);\n        rnd = iVal * roundTo;\n        return (value < 0.0) ? -rnd : rnd;\n    }\n    /** Generate a formatted text string integer value insert 1000 separators if appropriate.\n     *  @param wholePart    Integer value to be formatted.\n     */\n    static integerPartToText(wholePart, spec) {\n        // build invariant string represent wholePart\n        let formattedValue = wholePart.toFixed(0);\n        if ((formattedValue.length > 3) && (spec.format.hasFormatTraitSet(FormatTraits.Use1000Separator) && (spec.format.thousandSeparator.length > 0))) {\n            let numSeparators = Math.floor(formattedValue.length / 3);\n            let groupLength = formattedValue.length % 3;\n            if (groupLength === 0) {\n                numSeparators = numSeparators - 1;\n                groupLength = groupLength + 3;\n            }\n            let outString = formattedValue.substring(0, groupLength);\n            for (let i = 1; i <= numSeparators; i += 1) {\n                outString = outString + spec.format.thousandSeparator + formattedValue.substring(groupLength, groupLength + 3);\n                groupLength = groupLength + 3;\n            }\n            formattedValue = outString;\n        }\n        return formattedValue;\n    }\n    /** Trim trailing \"0\" from the text that represent the fractional part of a floating point value.\n     *  @param strVal   The value string.\n     */\n    static trimTrailingZeroes(strVal) {\n        let lastNonZeroCharIndex = -1;\n        for (let i = strVal.length - 1; i >= 0; i--) {\n            if (strVal.charCodeAt(i) !== QuantityConstants.CHAR_DIGIT_ZERO) {\n                lastNonZeroCharIndex = i;\n                break;\n            }\n        }\n        if (lastNonZeroCharIndex >= 0)\n            return strVal.substring(0, lastNonZeroCharIndex + 1);\n        return \"\";\n    }\n    /** Format a quantity value into a composite format such as ft-in or deg-min-sec.\n     *  @param compositeValue   The value for this part of the composite\n     *  @param isLastPart       If false the composite value should be a whole value, if true then the value should be formatted as a floating point value.\n     *  @param label            Label for this part of the composite. This will be either the default unit label or a custom label specified the format specification.\n     */\n    static formatCompositePart(compositeValue, isLastPart, label, spec) {\n        let componentText = \"\";\n        if (!isLastPart) {\n            componentText = Formatter.integerPartToText(compositeValue, spec);\n        }\n        else {\n            componentText = Formatter.formatMagnitude(compositeValue, spec);\n        }\n        if (spec.format.hasFormatTraitSet(FormatTraits.ShowUnitLabel)) {\n            componentText = componentText + spec.format.uomSeparator + label;\n        }\n        else {\n            if (!isLastPart)\n                componentText = `${componentText}:`;\n        }\n        return componentText;\n    }\n    /** Format a quantity value into a composite format such as ft-in or deg-min-sec.\n     *  @param magnitude   quantity value\n     *  @param fromUnit    quantity unit\n     */\n    static formatComposite(magnitude, spec) {\n        const compositeStrings = [];\n        // Caller will deal with appending +||-||() value sign as specified by formatting options so just format positive value\n        let posMagnitude = Math.abs(magnitude);\n        // eslint-disable-next-line @typescript-eslint/prefer-for-of\n        for (let i = 0; i < spec.unitConversions.length; i++) {\n            const currentLabel = spec.unitConversions[i].label;\n            const unitConversion = spec.unitConversions[i].conversion;\n            if (i > 0 && unitConversion.factor < 1.0)\n                throw new QuantityError(QuantityStatus.InvalidCompositeFormat, `The Format ${spec.format.name} has a invalid unit specification..`);\n            if (i > 0 && unitConversion.offset !== 0)\n                throw new QuantityError(QuantityStatus.InvalidCompositeFormat, `The Format ${spec.format.name} has a invalid unit specification..`);\n            let unitValue = (posMagnitude * unitConversion.factor) + unitConversion.offset + Formatter.FPV_MINTHRESHOLD; // offset should only ever be defined for major unit\n            if (0 === i) {\n                const precisionScale = Math.pow(10, 8); // use a fixed round off precision of 8 to avoid loss of precision in actual magnitude\n                unitValue = Math.floor(unitValue * precisionScale + FPV_ROUNDFACTOR) / precisionScale;\n                if ((Math.abs(unitValue) < 0.0001) && spec.format.hasFormatTraitSet(FormatTraits.ZeroEmpty))\n                    return \"\";\n            }\n            if (i < spec.format.units.length - 1) {\n                const wholePart = Math.floor(unitValue);\n                const componentText = Formatter.formatCompositePart(wholePart, false, currentLabel, spec);\n                posMagnitude = unitValue - wholePart;\n                compositeStrings.push(componentText);\n            }\n            else {\n                const componentText = Formatter.formatCompositePart(unitValue, true, currentLabel, spec);\n                compositeStrings.push(componentText);\n            }\n        }\n        return compositeStrings.join(spec.format.spacer ? spec.format.spacer : \"\");\n    }\n    /** Format a quantity value into a single text string. Imitate how formatting done by server method NumericFormatSpec::FormatDouble.\n     *  @param magnitude   quantity value\n     */\n    static formatMagnitude(magnitude, spec) {\n        let posMagnitude = Math.abs(magnitude);\n        if ((Math.abs(posMagnitude) < 0.0001) && spec.format.hasFormatTraitSet(FormatTraits.ZeroEmpty))\n            return \"\";\n        if (spec.format.hasFormatTraitSet(FormatTraits.ApplyRounding))\n            posMagnitude = Math.abs(Formatter.roundDouble(magnitude, spec.format.roundFactor));\n        const isSci = ((posMagnitude > 1.0e12) || spec.format.type === FormatType.Scientific);\n        const isDecimal = (isSci || spec.format.type === FormatType.Decimal);\n        const isFractional = (!isDecimal && spec.format.type === FormatType.Fractional);\n        /* const usesStops = spec.format.type === FormatType.Station; */\n        const isPrecisionZero = spec.format.precision === DecimalPrecision.Zero;\n        const isKeepSingleZero = spec.format.hasFormatTraitSet(FormatTraits.KeepSingleZero);\n        const precisionScale = Math.pow(10.0, spec.format.precision);\n        const isKeepTrailingZeroes = spec.format.hasFormatTraitSet(FormatTraits.TrailZeroes);\n        let expInt = 0.0;\n        if (isSci && (posMagnitude !== 0.0)) {\n            let exp = Math.log10(posMagnitude);\n            let negativeExp = false;\n            if (exp < 0.0) {\n                exp = -exp;\n                negativeExp = true;\n            }\n            expInt = Math.floor(exp);\n            if (spec.format.type === FormatType.Scientific) {\n                if (spec.format.scientificType === ScientificType.ZeroNormalized && posMagnitude > 1.0)\n                    expInt += 1.0;\n                else if (spec.format.scientificType === ScientificType.Normalized && posMagnitude < 1.0)\n                    expInt += 1.0;\n                if (negativeExp)\n                    expInt = -expInt;\n            }\n            const factor = Math.pow(10.0, -expInt);\n            posMagnitude *= factor;\n        }\n        let formattedValue = \"\";\n        if (isDecimal) {\n            const actualVal = isPrecisionZero ? posMagnitude + FPV_ROUNDFACTOR : posMagnitude + Formatter.FPV_MINTHRESHOLD;\n            let wholePart = Math.floor(actualVal);\n            let fractionPart = actualVal - wholePart;\n            if (!isPrecisionZero) {\n                fractionPart = Math.abs(fractionPart) * precisionScale + FPV_ROUNDFACTOR;\n                if (fractionPart >= precisionScale) {\n                    wholePart += 1;\n                    fractionPart -= precisionScale;\n                }\n            }\n            formattedValue = Formatter.integerPartToText(wholePart, spec);\n            if (isPrecisionZero) {\n                if (spec.format.hasFormatTraitSet(FormatTraits.KeepDecimalPoint) && !isKeepSingleZero)\n                    formattedValue = formattedValue + spec.format.decimalSeparator;\n                else if (isKeepSingleZero)\n                    formattedValue = `${formattedValue + spec.format.decimalSeparator}0`;\n            }\n            else {\n                fractionPart = Math.floor(fractionPart) / precisionScale;\n                let fractionString = fractionPart.toFixed(spec.format.precision);\n                // remove leading \"0.\"\n                fractionString = fractionString.substring(2).padEnd(spec.format.precision, \"0\");\n                if (!isKeepTrailingZeroes)\n                    fractionString = Formatter.trimTrailingZeroes(fractionString);\n                if (fractionString.length > 0)\n                    formattedValue = formattedValue + spec.format.decimalSeparator + fractionString;\n                else {\n                    if (spec.format.hasFormatTraitSet(FormatTraits.KeepDecimalPoint))\n                        formattedValue = formattedValue + spec.format.decimalSeparator + (isKeepSingleZero ? \"0\" : \"\");\n                }\n            }\n            if (isSci) {\n                const expString = `e${expInt.toFixed(0)}`;\n                formattedValue = formattedValue + expString;\n            }\n        }\n        else if (isFractional) {\n            const fn = new FractionalNumeric(posMagnitude, spec.format.precision, true);\n            formattedValue = fn.getIntegralString();\n            if (!fn.isZero && fn.hasFractionPart) {\n                const wholeFractionSeparator = spec.format.hasFormatTraitSet(FormatTraits.FractionDash) ? \"-\" : \" \";\n                const fractionString = `${fn.getNumeratorString()}/${fn.getDenominatorString()}`;\n                formattedValue = formattedValue + wholeFractionSeparator + fractionString;\n            }\n        }\n        else /* if (usesStops)*/ {\n            // we assume that stopping value is always positive\n            posMagnitude = Math.floor(posMagnitude * precisionScale + FPV_ROUNDFACTOR) / precisionScale;\n            const denominator = (Math.pow(10, spec.format.stationOffsetSize));\n            const tVal = Math.floor(posMagnitude); // this is the integer part only\n            const hiPart = Math.floor(tVal / denominator);\n            const lowPart = tVal - hiPart * denominator;\n            const fract = posMagnitude - tVal;\n            const fractionPart = Math.floor(fract * precisionScale + FPV_ROUNDFACTOR);\n            const stationString = hiPart.toFixed(0) + spec.format.stationSeparator + lowPart.toFixed(0).padStart(spec.format.stationOffsetSize, \"0\");\n            let fractionString = \"\";\n            if (fractionPart > 0) {\n                fractionString = (fractionPart / precisionScale).toFixed(spec.format.precision);\n                // remove leading \"0.\"\n                fractionString = fractionString.substring(2).padEnd(spec.format.precision, \"0\");\n                if (!isKeepTrailingZeroes)\n                    fractionString = Formatter.trimTrailingZeroes(fractionString);\n                formattedValue = stationString + spec.format.decimalSeparator + fractionString;\n            }\n            else {\n                if (isKeepTrailingZeroes)\n                    fractionString = spec.format.decimalSeparator + \"\".padEnd(spec.format.precision, \"0\");\n                else if (spec.format.hasFormatTraitSet(FormatTraits.KeepDecimalPoint))\n                    fractionString = spec.format.decimalSeparator;\n                formattedValue = stationString + fractionString;\n            }\n        }\n        return formattedValue;\n    }\n    /** Format a quantity value into a single text string based on the current format specification of this class.\n     *  @param magnitude   defines the value to spec.format.\n     *  @param spec      A FormatterSpec object the defines specification for the magnitude and unit conversions for the formatter.\n     */\n    static formatQuantity(magnitude, spec) {\n        const valueIsNegative = magnitude < 0.0;\n        let prefix = \"\";\n        let suffix = \"\";\n        let formattedValue = \"\";\n        switch (spec.format.showSignOption) {\n            case ShowSignOption.NegativeParentheses:\n                if (valueIsNegative) {\n                    prefix = \"(\";\n                    suffix = \")\";\n                }\n                break;\n            case ShowSignOption.OnlyNegative:\n                if (valueIsNegative)\n                    prefix = \"-\";\n                break;\n            case ShowSignOption.SignAlways:\n                if (valueIsNegative)\n                    prefix = \"-\";\n                else\n                    prefix = \"+\";\n                break;\n            case ShowSignOption.NoSign:\n            default:\n                break;\n        }\n        let formattedMagnitude = \"\";\n        if (spec.format.hasUnits) {\n            formattedMagnitude = Formatter.formatComposite(magnitude, spec);\n        }\n        else {\n            // unitless quantity\n            formattedMagnitude = Formatter.formatMagnitude(magnitude, spec);\n            if (formattedMagnitude.length > 0 && spec.unitConversions.length > 0 && spec.format.hasFormatTraitSet(FormatTraits.ShowUnitLabel)) {\n                if (spec.format.hasFormatTraitSet(FormatTraits.PrependUnitLabel))\n                    formattedMagnitude = spec.unitConversions[0].label + spec.format.uomSeparator + formattedMagnitude;\n                else\n                    formattedMagnitude = formattedMagnitude + spec.format.uomSeparator + spec.unitConversions[0].label;\n            }\n        }\n        // add Sign prefix and suffix as necessary\n        if ((prefix.length > 0 || suffix.length > 0) && formattedMagnitude.length > 0)\n            formattedValue = prefix + formattedMagnitude + suffix;\n        else\n            formattedValue = formattedMagnitude;\n        if (spec.format.minWidth && spec.format.minWidth < formattedValue.length)\n            formattedValue.padStart(spec.format.minWidth, \" \");\n        return formattedValue;\n    }\n}\n// eslint-disable-next-line @typescript-eslint/naming-convention\nFormatter.FPV_MINTHRESHOLD = 1.0e-14;\nexport { Formatter };\n//# sourceMappingURL=Formatter.js.map",
      "start": 1693508123287,
      "end": 1693508123510,
      "sourcemaps": null
    }
  ]
}
