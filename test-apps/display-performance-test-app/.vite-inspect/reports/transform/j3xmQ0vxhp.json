{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/geometry3d/Point2dVector2d.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module CartesianGeometry\n */\n// cspell:word JSONXY\n// cspell:word CWXY CCWXY\nimport { Geometry } from \"../Geometry\";\nimport { Angle } from \"./Angle\";\n/**\n * Minimal object containing x,y and operations that are meaningful without change in both point and vector.\n *  * `XY` is not instantiable.\n *  * The derived (instantiable) classes are\n *    * `Point2d`\n *    * `Vector2d`\n * @public\n */\nexport class XY {\n    /** Set both x and y. */\n    set(x = 0, y = 0) {\n        this.x = x;\n        this.y = y;\n    }\n    /** Set both x and y to zero */\n    setZero() {\n        this.x = 0;\n        this.y = 0;\n    }\n    constructor(x = 0, y = 0) {\n        this.x = x;\n        this.y = y;\n    }\n    /** Set both x and y from other. */\n    setFrom(other) {\n        if (other) {\n            this.x = other.x;\n            this.y = other.y;\n        }\n        else {\n            this.x = 0;\n            this.y = 0;\n        }\n    }\n    /** Freeze this instance so it is read-only */\n    freeze() {\n        return Object.freeze(this);\n    }\n    /** Returns true if this and other have equal x,y parts within Geometry.smallMetricDistance. */\n    isAlmostEqual(other, tol) {\n        return Geometry.isSameCoordinate(this.x, other.x, tol) && Geometry.isSameCoordinate(this.y, other.y, tol);\n    }\n    /** Returns true if this and other have equal x,y parts within Geometry.smallMetricDistance. */\n    isAlmostEqualXY(x, y, tol) {\n        return Geometry.isSameCoordinate(this.x, x, tol) && Geometry.isSameCoordinate(this.y, y, tol);\n    }\n    /** Return a json array  `[x,y]`   */\n    toJSON() {\n        return [this.x, this.y];\n    }\n    /** Return a json object `{x: 1, y:2}`  */\n    toJSONXY() {\n        return { x: this.x, y: this.y };\n    }\n    /**\n     * Set x and y from a JSON input such as `[1,2]` or `{x:1, y:2}`\n     * * If no JSON input is provided, 0 would be used as default values for x and y.\n     * @param json the JSON input\n     */\n    setFromJSON(json) {\n        if (Array.isArray(json)) {\n            this.set(json[0] || 0, json[1] || 0);\n            return;\n        }\n        if (json) {\n            this.set(json.x || 0, json.y || 0);\n            return;\n        }\n        this.set(0, 0);\n    }\n    /** Return the distance from this point to other */\n    distance(other) {\n        const xDist = other.x - this.x;\n        const yDist = other.y - this.y;\n        return Math.sqrt(xDist * xDist + yDist * yDist);\n    }\n    /** Return squared distance from this point to other */\n    distanceSquared(other) {\n        const xDist = other.x - this.x;\n        const yDist = other.y - this.y;\n        return xDist * xDist + yDist * yDist;\n    }\n    /** Return the largest absolute distance between corresponding components */\n    maxDiff(other) {\n        return Math.max(Math.abs(this.x - other.x), Math.abs(this.y - other.y));\n    }\n    /** Return the x,y component corresponding to 0,1 */\n    at(index) {\n        if (index < 0.5)\n            return this.x;\n        return this.y;\n    }\n    /** Set value at index 0 or 1 */\n    setAt(index, value) {\n        if (index < 0.5)\n            this.x = value;\n        else\n            this.y = value;\n    }\n    /** Return the index (0,1) of the x,y component with largest absolute value */\n    indexOfMaxAbs() {\n        let index = 0;\n        const a = Math.abs(this.x);\n        const b = Math.abs(this.y);\n        if (b > a) {\n            index = 1;\n        }\n        return index;\n    }\n    /** Returns true if the x,y components are both small by metric metric tolerance */\n    get isAlmostZero() {\n        return Geometry.isSmallMetricDistance(this.x) && Geometry.isSmallMetricDistance(this.y);\n    }\n    /** Return the largest absolute value of any component */\n    maxAbs() {\n        return Math.max(Math.abs(this.x), Math.abs(this.y));\n    }\n    /** Return the magnitude of the vector */\n    magnitude() {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    }\n    /** Return the squared magnitude of the vector.  */\n    magnitudeSquared() {\n        return this.x * this.x + this.y * this.y;\n    }\n    /** Returns true if the x,y components are exactly equal. */\n    isExactEqual(other) {\n        return this.x === other.x && this.y === other.y;\n    }\n    /** Returns true if x,y match `other` within metric tolerance */\n    isAlmostEqualMetric(other, distanceTol = Geometry.smallMetricDistance) {\n        return this.maxDiff(other) <= distanceTol;\n    }\n    /** Return a (full length) vector from this point to other */\n    vectorTo(other, result) {\n        return Vector2d.create(other.x - this.x, other.y - this.y, result);\n    }\n    /** Return a unit vector from this point to other */\n    unitVectorTo(other, result) {\n        return this.vectorTo(other, result).normalize(result);\n    }\n    /** Cross product of vectors from origin to targets */\n    static crossProductToPoints(origin, targetA, targetB) {\n        return Geometry.crossProductXYXY(targetA.x - origin.x, targetA.y - origin.y, targetB.x - origin.x, targetB.y - origin.y);\n    }\n}\n/** 2D point with `x`,`y` as properties\n * @public\n */\nexport class Point2d extends XY {\n    /** Constructor for Point2d */\n    constructor(x = 0, y = 0) {\n        super(x, y);\n    }\n    /** Return a new Point2d with x,y coordinates from this. */\n    clone(result) {\n        return Point2d.create(this.x, this.y, result);\n    }\n    /**\n     * Return a point (newly created unless result provided) with given x,y coordinates\n     * @param x x coordinate\n     * @param y y coordinate\n     * @param result optional result\n     */\n    static create(x = 0, y = 0, result) {\n        if (result) {\n            result.x = x;\n            result.y = y;\n            return result;\n        }\n        return new Point2d(x, y);\n    }\n    /**\n     * Set x and y from a JSON input such as `[1,2]` or `{x:1, y:2}`\n     * * If no JSON input is provided, 0 would be used as default values for x and y.\n     * @param json the JSON input\n     */\n    static fromJSON(json) {\n        const val = new Point2d();\n        val.setFromJSON(json);\n        return val;\n    }\n    /** Create (or optionally reuse) a Point2d from another object with fields x and y */\n    static createFrom(xy, result) {\n        if (xy)\n            return Point2d.create(xy.x, xy.y, result);\n        return Point2d.create(0, 0, result);\n    }\n    /** Create a Point2d with both coordinates zero. */\n    static createZero(result) {\n        return Point2d.create(0, 0, result);\n    }\n    /**\n     * Starting at this point, move along `vector` by `tangentFraction` of its length, and then\n     * by `leftFraction` of its length along the left perpendicular.\n     * @param tangentFraction distance to move along `vector`, as a fraction of its length\n     * @param leftFraction distance to move perpendicular to `vector`, as a fraction of its length\n     * @param vector the other vector\n     */\n    addForwardLeft(tangentFraction, leftFraction, vector, result) {\n        const dx = vector.x;\n        const dy = vector.y;\n        return Point2d.create(this.x + tangentFraction * dx - leftFraction * dy, this.y + tangentFraction * dy + leftFraction * dx, result);\n    }\n    /**\n     * Interpolate at tangentFraction between this instance and point, and then Move by leftFraction\n     * along the xy perpendicular of the vector between the points.\n     */\n    forwardLeftInterpolate(tangentFraction, leftFraction, point) {\n        const dx = point.x - this.x;\n        const dy = point.y - this.y;\n        return Point2d.create(this.x + tangentFraction * dx - leftFraction * dy, this.y + tangentFraction * dy + leftFraction * dx);\n    }\n    /** Return a point interpolated between this point and the right param. */\n    interpolate(fraction, other, result) {\n        if (fraction <= 0.5)\n            return Point2d.create(this.x + fraction * (other.x - this.x), this.y + fraction * (other.y - this.y), result);\n        const t = fraction - 1.0;\n        return Point2d.create(other.x + t * (other.x - this.x), other.y + t * (other.y - this.y), result);\n    }\n    /** Return a point with independent x,y fractional interpolation. */\n    interpolateXY(fractionX, fractionY, other, result) {\n        return Point2d.create(Geometry.interpolate(this.x, fractionX, other.x), Geometry.interpolate(this.y, fractionY, other.y), result);\n    }\n    /** Return this point minus vector */\n    minus(vector, result) {\n        return Point2d.create(this.x - vector.x, this.y - vector.y, result);\n    }\n    /** Return point plus vector */\n    plus(vector, result) {\n        return Point2d.create(this.x + vector.x, this.y + vector.y, result);\n    }\n    /** Return point plus vector */\n    plusXY(dx = 0, dy = 0, result) {\n        return Point2d.create(this.x + dx, this.y + dy, result);\n    }\n    /** Return point + vector * scalar */\n    plusScaled(vector, scaleFactor, result) {\n        return Point2d.create(this.x + vector.x * scaleFactor, this.y + vector.y * scaleFactor, result);\n    }\n    /** Return point + vectorA * scalarA + vectorB * scalarB */\n    plus2Scaled(vectorA, scalarA, vectorB, scalarB, result) {\n        return Point2d.create(this.x + vectorA.x * scalarA + vectorB.x * scalarB, this.y + vectorA.y * scalarA + vectorB.y * scalarB, result);\n    }\n    /** Return point + vectorA * scalarA + vectorB * scalarB + vectorC * scalarC */\n    plus3Scaled(vectorA, scalarA, vectorB, scalarB, vectorC, scalarC, result) {\n        return Point2d.create(this.x + vectorA.x * scalarA + vectorB.x * scalarB + vectorC.x * scalarC, this.y + vectorA.y * scalarA + vectorB.y * scalarB + vectorC.y * scalarC, result);\n    }\n    /**\n     * Return the dot product of vector from this to targetA and vector from this to targetB\n     * @param targetA target of first vector\n     * @param targetB target of second vector\n     */\n    dotVectorsToTargets(targetA, targetB) {\n        return (targetA.x - this.x) * (targetB.x - this.x) + (targetA.y - this.y) * (targetB.y - this.y);\n    }\n    /**\n     * Returns the (scalar) cross product of vector from this to targetA and vector from this to targetB\n     * @param target1 target of first vector\n     * @param target2 target of second vector\n     */\n    crossProductToPoints(target1, target2) {\n        const x1 = target1.x - this.x;\n        const y1 = target1.y - this.y;\n        const x2 = target2.x - this.x;\n        const y2 = target2.y - this.y;\n        return x1 * y2 - y1 * x2;\n    }\n    /**\n     * Return the fractional coordinate of the projection of this instance x,y onto the\n     * line from startPoint to endPoint.\n     * @param startPoint start point of line\n     * @param endPoint end point of line\n     * @param defaultFraction fraction to return if startPoint and endPoint are equal.\n     */\n    fractionOfProjectionToLine(startPoint, endPoint, defaultFraction = 0) {\n        const denominator = startPoint.distanceSquared(endPoint);\n        if (denominator < Geometry.smallMetricDistanceSquared)\n            return defaultFraction;\n        const numerator = startPoint.dotVectorsToTargets(endPoint, this);\n        return numerator / denominator;\n    }\n}\n/**\n * 2D vector with `x`,`y` as properties\n * @public\n */\nexport class Vector2d extends XY {\n    constructor(x = 0, y = 0) {\n        super(x, y);\n    }\n    /** Return a new Vector2d with the same x,y */\n    clone(result) {\n        return Vector2d.create(this.x, this.y, result);\n    }\n    /** Return a new Vector2d with given x and y */\n    static create(x = 0, y = 0, result) {\n        if (result) {\n            result.x = x;\n            result.y = y;\n            return result;\n        }\n        return new Vector2d(x, y);\n    }\n    /**\n     * Return a (new) Vector2d with components scale,0\n     * If scale is not given default value 1 is used.\n     */\n    static unitX(scale = 1) {\n        return new Vector2d(scale, 0);\n    }\n    /**\n     * Return a (new) Vector2d with components 0,scale\n     * If scale is not given default value 1 is used.\n     */\n    static unitY(scale = 1) {\n        return new Vector2d(0, scale);\n    }\n    /** Return a Vector2d with components 0,0 */\n    static createZero(result) {\n        return Vector2d.create(0, 0, result);\n    }\n    /** Copy contents from another Point3d, Point2d, Vector2d, or Vector3d, or leading entries of Float64Array */\n    static createFrom(data, result) {\n        if (data instanceof Float64Array) {\n            if (data.length >= 2)\n                return Vector2d.create(data[0], data[1]);\n            if (data.length >= 1)\n                return Vector2d.create(data[0], 0);\n            return Vector2d.create(0, 0);\n        }\n        return Vector2d.create(data.x, data.y, result);\n    }\n    /**\n     * Set x and y from a JSON input such as `[1,2]` or `{x:1, y:2}`\n     * * If no JSON input is provided, 0 would be used as default values for x and y.\n     * @param json the JSON input\n     */\n    static fromJSON(json) {\n        const val = new Vector2d();\n        val.setFromJSON(json);\n        return val;\n    }\n    /** Return a new Vector2d from polar coordinates for radius and Angle from x axis */\n    static createPolar(r, theta) {\n        return Vector2d.create(r * theta.cos(), r * theta.sin());\n    }\n    /** Return a new Vector2d extending from point0 to point1 */\n    static createStartEnd(point0, point1, result) {\n        return Vector2d.create(point1.x - point0.x, point1.y - point0.y, result);\n    }\n    /**\n     * Return a vector that bisects the angle between two normals and extends to the intersection of two offset lines\n     * * returns `undefined` if `unitPerpA = -unitPerpB` (i.e., are opposite)\n     * * math details can be found at docs/learning/geometry/PointVector.md\n     * @param unitPerpA unit perpendicular to incoming direction\n     * @param unitPerpB  unit perpendicular to outgoing direction\n     * @param offset offset distance\n     */\n    static createOffsetBisector(unitPerpA, unitPerpB, offset) {\n        let bisector = unitPerpA.plus(unitPerpB);\n        bisector = bisector.normalize();\n        if (bisector) {\n            const c = bisector.dotProduct(unitPerpA);\n            bisector.scale(offset, bisector);\n            return bisector.safeDivideOrNull(c);\n        }\n        return undefined;\n    }\n    /**\n     * Return a (new or optionally reused) vector which is `this` divided by `denominator`\n     * * return undefined if denominator is zero.\n     */\n    safeDivideOrNull(denominator, result) {\n        if (denominator !== 0.0) {\n            return this.scale(1.0 / denominator, result);\n        }\n        return undefined;\n    }\n    /** Return a unit vector in direction of this instance (undefined if this instance has near zero length) */\n    normalize(result) {\n        const mag = Geometry.correctSmallFraction(this.magnitude());\n        result = result ? result : new Vector2d();\n        return this.safeDivideOrNull(mag, result);\n    }\n    /**\n     * Return fractional length of the projection of the instance onto the target vector.\n     * @param target the target vector\n     * @param defaultFraction the returned value in case the magnitude of `target` is too small\n     * @returns the signed length of the projection divided by the length of `target`\n     */\n    fractionOfProjectionToVector(target, defaultFraction) {\n        /*\n         * projection length is (this.target)/||target||\n         * but here we return (this.target)/||target||^2\n         */\n        const denominator = target.magnitudeSquared();\n        if (denominator < Geometry.smallMetricDistanceSquared)\n            return defaultFraction ? defaultFraction : 0;\n        const numerator = this.dotProduct(target);\n        return numerator / denominator;\n    }\n    /** Return a new vector with components negated from this instance. */\n    negate(result) {\n        result = result ? result : new Vector2d();\n        result.x = -this.x;\n        result.y = -this.y;\n        return result;\n    }\n    /** Return a vector same length as this but rotated 90 degrees counter clockwise */\n    rotate90CCWXY(result) {\n        result = result ? result : new Vector2d();\n        // save x,y to allow aliasing (\"this\" can be passed to the function as \"result\")\n        const xx = this.x;\n        const yy = this.y;\n        result.x = -yy;\n        result.y = xx;\n        return result;\n    }\n    /** Return a vector same length as this but rotated 90 degrees clockwise */\n    rotate90CWXY(result) {\n        result = result ? result : new Vector2d();\n        // save x,y to allow aliasing (\"this\" can be passed to the function as \"result\")\n        const xx = this.x;\n        const yy = this.y;\n        result.x = yy;\n        result.y = -xx;\n        return result;\n    }\n    /** Return a unit vector perpendicular to this instance. */\n    unitPerpendicularXY(result) {\n        result = result ? result : new Vector2d();\n        const xx = this.x;\n        const yy = this.y;\n        // save x,y to allow aliasing (\"this\" can be passed to the function as \"result\")\n        result.x = -yy;\n        result.y = xx;\n        const d2 = xx * xx + yy * yy;\n        if (d2 !== 0.0) {\n            const a = 1.0 / Math.sqrt(d2);\n            result.x *= a;\n            result.y *= a;\n        }\n        return result;\n    }\n    /** Return a new Vector2d rotated CCW by given angle */\n    rotateXY(angle, result) {\n        const s = angle.sin();\n        const c = angle.cos();\n        // save x,y to allow aliasing (\"this\" can be passed to the function as \"result\")\n        const xx = this.x;\n        const yy = this.y;\n        result = result ? result : new Vector2d();\n        result.x = xx * c - yy * s;\n        result.y = xx * s + yy * c;\n        return result;\n    }\n    /**\n     * Return a vector computed at fractional position between this vector and vectorB\n    * @param fraction fractional position.  0 is at `this`.  1 is at `vectorB`.\n    *                 True fractions are \"between\", negatives are \"before this\", beyond 1 is \"beyond vectorB\".\n    * @param vectorB second vector\n    * @param result optional preallocated result.\n    */\n    interpolate(fraction, vectorB, result) {\n        result = result ? result : new Vector2d();\n        /*\n         * For best last-bit behavior, if fraction is below 0.5, use this as base point.\n         * If above 0.5, use vectorB as base point.\n         */\n        if (fraction <= 0.5) {\n            result.x = this.x + fraction * (vectorB.x - this.x);\n            result.y = this.y + fraction * (vectorB.y - this.y);\n        }\n        else {\n            const t = fraction - 1.0;\n            result.x = vectorB.x + t * (vectorB.x - this.x);\n            result.y = vectorB.y + t * (vectorB.y - this.y);\n        }\n        return result;\n    }\n    /** Return {this + vector}. */\n    plus(vector, result) {\n        result = result ? result : new Vector2d();\n        result.x = this.x + vector.x;\n        result.y = this.y + vector.y;\n        return result;\n    }\n    /** Return {this - vector}. */\n    minus(vector, result) {\n        result = result ? result : new Vector2d();\n        result.x = this.x - vector.x;\n        result.y = this.y - vector.y;\n        return result;\n    }\n    /** Return {point + vector \\* scalar} */\n    plusScaled(vector, scaleFactor, result) {\n        result = result ? result : new Vector2d();\n        result.x = this.x + vector.x * scaleFactor;\n        result.y = this.y + vector.y * scaleFactor;\n        return result;\n    }\n    /** Return {point + vectorA \\* scalarA + vectorB \\* scalarB} */\n    plus2Scaled(vectorA, scalarA, vectorB, scalarB, result) {\n        result = result ? result : new Vector2d();\n        result.x = this.x + vectorA.x * scalarA + vectorB.x * scalarB;\n        result.y = this.y + vectorA.y * scalarA + vectorB.y * scalarB;\n        return result;\n    }\n    /** Return {this + vectorA \\* scalarA + vectorB \\* scalarB + vectorC \\* scalarC} */\n    plus3Scaled(vectorA, scalarA, vectorB, scalarB, vectorC, scalarC, result) {\n        result = result ? result : new Vector2d();\n        result.x = this.x + vectorA.x * scalarA + vectorB.x * scalarB + vectorC.x * scalarC;\n        result.y = this.y + vectorA.y * scalarA + vectorB.y * scalarB + vectorC.y * scalarC;\n        return result;\n    }\n    /** Return {this * scale} */\n    scale(scale, result) {\n        result = result ? result : new Vector2d();\n        result.x = this.x * scale;\n        result.y = this.y * scale;\n        return result;\n    }\n    /** Return a vector parallel to this but with specified length */\n    scaleToLength(length, result) {\n        const mag = Geometry.correctSmallFraction(this.magnitude());\n        if (mag === 0)\n            return undefined;\n        return this.scale(length / mag, result);\n    }\n    /** Return the dot product of this with vectorB */\n    dotProduct(vectorB) {\n        return this.x * vectorB.x + this.y * vectorB.y;\n    }\n    /** Dot product with vector from pointA to pointB */\n    dotProductStartEnd(pointA, pointB) {\n        return this.x * (pointB.x - pointA.x) + this.y * (pointB.y - pointA.y);\n    }\n    /** Vector cross product {this CROSS vectorB} */\n    crossProduct(vectorB) {\n        return this.x * vectorB.y - this.y * vectorB.x;\n    }\n    /**\n     * Return the radians (as a simple number, not strongly typed Angle) signed angle from this to vectorB.\n     * This is positive if the shortest turn is counterclockwise, negative if clockwise.\n     */\n    radiansTo(vectorB) {\n        return Math.atan2(this.crossProduct(vectorB), this.dotProduct(vectorB));\n    }\n    /**\n     * Return the (strongly typed) signed angle from this to vectorB.\n     * This is positive if the shortest turn is counterclockwise, negative if clockwise.\n     */\n    angleTo(vectorB) {\n        return Angle.createRadians(this.radiansTo(vectorB));\n    }\n    /**\n     * Test if this vector is parallel to other.\n     * * The input tolerances in `options`, if given, are considered to be squared for efficiency's sake,\n     * so if you have a distance or angle tolerance t, you should pass in t * t.\n     * @param other second vector for comparison.\n     * @param oppositeIsParallel whether to consider diametrically opposed vectors as parallel.\n     * @param options optional radian and distance tolerances.\n     */\n    isParallelTo(other, oppositeIsParallel = false, returnValueIfAnInputIsZeroLength = false, options) {\n        const radianSquaredTol = options?.radianSquaredTol ?? Geometry.smallAngleRadiansSquared;\n        const distanceSquaredTol = options?.distanceSquaredTol ?? Geometry.smallMetricDistanceSquared;\n        const a2 = this.magnitudeSquared();\n        const b2 = other.magnitudeSquared();\n        if (a2 < distanceSquaredTol || b2 < distanceSquaredTol)\n            return returnValueIfAnInputIsZeroLength;\n        const dot = this.dotProduct(other);\n        if (dot < 0.0 && !oppositeIsParallel)\n            return false;\n        const cross = this.crossProduct(other);\n        /* a2,b2,cross2 are squared lengths of respective vectors */\n        /* cross2 = sin^2(theta) * a2 * b2 */\n        /* For small theta, sin^2(theta)~~theta^2 */\n        return cross * cross <= radianSquaredTol * a2 * b2;\n    }\n    /**\n     * Test if this vector is perpendicular to other.\n     * * The input tolerances in `options`, if given, are considered to be squared for efficiency's sake,\n     * so if you have a distance or angle tolerance t, you should pass in t * t.\n     * @param other second vector in comparison.\n     * @param returnValueIfAnInputIsZeroLength if either vector is near zero length, return this value.\n     * @param options optional radian and distance tolerances.\n     */\n    isPerpendicularTo(other, returnValueIfAnInputIsZeroLength = false, options) {\n        const radianSquaredTol = options?.radianSquaredTol ?? Geometry.smallAngleRadiansSquared;\n        const distanceSquaredTol = options?.distanceSquaredTol ?? Geometry.smallMetricDistanceSquared;\n        const aa = this.magnitudeSquared();\n        const bb = other.magnitudeSquared();\n        if (aa < distanceSquaredTol || bb < distanceSquaredTol)\n            return returnValueIfAnInputIsZeroLength;\n        const ab = this.dotProduct(other);\n        return ab * ab <= radianSquaredTol * aa * bb;\n    }\n}\n//# sourceMappingURL=Point2dVector2d.js.map",
      "start": 1693508122344,
      "end": 1693508122486,
      "sourcemaps": null
    }
  ]
}
