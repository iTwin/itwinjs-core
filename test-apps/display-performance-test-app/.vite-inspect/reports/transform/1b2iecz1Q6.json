{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/geometry3d/BarycentricTriangle.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module CartesianGeometry\n */\nimport { assert } from \"@itwin/core-bentley\";\nimport { Geometry, PolygonLocation } from \"../Geometry\";\nimport { Matrix3d } from \"./Matrix3d\";\nimport { Point3d, Vector3d } from \"./Point3dVector3d\";\nimport { Ray3d } from \"./Ray3d\";\n/**\n * Carries data about a location in the plane of a triangle.\n * * Each instance carries both world and barycentric coordinates for the point, and provides query\n * services on the latter.\n * * No tolerance is used when querying barycentric coordinates (e.g., `isInsideOrOn`, `classify`). Use\n * [[BarycentricTriangle.snapLocationToEdge]] to adjust the barycentric coordinates to a triangle edge\n * if they lie within a distance or parametric tolerance.\n *\n * Properties of the barycentric coordinates `(b0, b1, b2)` of a point `p` in the plane of a triangle\n * `T` with vertices `v0, v1, v2`:\n * * `1 = b0 + b1 + b2`\n * * `p = b0 * v0 + b1 * v1 + b2 * v2`\n * * If T is spanned by the vectors `U = v1 - v0` and `V = v2 - v0`, then the vector `P = p - v0` can\n * be written `P = b1 * U + b2 * V`.\n * * The coordinates are all nonnegative if and only if `p` is inside or on `T`.\n * * Exactly one coordinate is zero if and only if `p` lies on an (infinitely extended) edge of `T`.\n * * Exactly two coordinates are zero if and only if `p` coincides with a vertex of `T`.\n * * Note that if `p` can be written as a linear combination of the vertices of `T` using scales that do\n * NOT sum to 1, then `p` is not coplanar with `T`\n * @public\n */\nexport class TriangleLocationDetail {\n    constructor() {\n        this.world = new Point3d();\n        this.local = new Point3d();\n        this.a = 0.0;\n        this.closestEdgeIndex = 0;\n        this.closestEdgeParam = 0.0;\n    }\n    /** Invalidate this detail (set all attributes to zero) . */\n    invalidate() {\n        this.world.setZero();\n        this.local.setZero();\n        this.a = 0.0;\n        this.closestEdgeIndex = 0;\n        this.closestEdgeParam = 0.0;\n    }\n    /**\n     * Create an invalid detail.\n     * @param result optional pre-allocated object to fill and return\n     */\n    static create(result) {\n        if (undefined === result)\n            result = new TriangleLocationDetail();\n        else\n            result.invalidate();\n        return result;\n    }\n    /**\n     * Set the instance contents from the `other` detail.\n     * @param other detail to clone\n     */\n    copyContentsFrom(other) {\n        this.world.setFrom(other.world);\n        this.local.setFrom(other.local);\n        this.a = other.a;\n        this.closestEdgeIndex = other.closestEdgeIndex;\n        this.closestEdgeParam = other.closestEdgeParam;\n    }\n    /** Whether this detail is invalid. */\n    get isValid() {\n        return !this.local.isZero;\n    }\n    /**\n     * Queries the barycentric coordinates to determine whether this instance specifies a location inside or\n     * on the triangle.\n     * @see classify\n     */\n    get isInsideOrOn() {\n        return this.isValid && this.local.x >= 0.0 && this.local.y >= 0.0 && this.local.z >= 0.0;\n    }\n    /**\n     * Queries this detail to classify the location of this instance with respect to the triangle.\n     * @returns location code\n     * @see isInsideOrOn\n     */\n    get classify() {\n        if (!this.isValid)\n            return PolygonLocation.Unknown;\n        if (this.isInsideOrOn) {\n            let numZero = 0;\n            if (Math.abs(this.local.x) === 0.0)\n                ++numZero;\n            if (Math.abs(this.local.y) === 0.0)\n                ++numZero;\n            if (Math.abs(this.local.z) === 0.0)\n                ++numZero;\n            if (2 === numZero)\n                return PolygonLocation.OnPolygonVertex;\n            if (1 === numZero)\n                return PolygonLocation.OnPolygonEdgeInterior;\n            return PolygonLocation.InsidePolygonProjectsToEdgeInterior;\n        }\n        return (this.closestEdgeParam === 0.0) ?\n            PolygonLocation.OutsidePolygonProjectsToVertex :\n            PolygonLocation.OutsidePolygonProjectsToEdgeInterior;\n    }\n}\n/**\n * 3 points defining a triangle to be evaluated with barycentric coordinates.\n * @public\n */\nexport class BarycentricTriangle {\n    /**\n     * Constructor.\n     * * Point references are CAPTURED\n     */\n    constructor(point0, point1, point2) {\n        this.points = [];\n        this.points.push(point0);\n        this.points.push(point1);\n        this.points.push(point2);\n        this.edgeLength2 = [];\n        this.edgeLength2.push(point1.distanceSquared(point2));\n        this.edgeLength2.push(point0.distanceSquared(point2));\n        this.edgeLength2.push(point0.distanceSquared(point1));\n    }\n    /**\n     * Copy contents of (not pointers to) the given points. A vertex is zeroed if its corresponding input point\n     * is undefined.\n     */\n    set(point0, point1, point2) {\n        this.points[0].setFromPoint3d(point0);\n        this.points[1].setFromPoint3d(point1);\n        this.points[2].setFromPoint3d(point2);\n        this.edgeLength2[0] = this.points[1].distanceSquared(this.points[2]);\n        this.edgeLength2[1] = this.points[0].distanceSquared(this.points[2]);\n        this.edgeLength2[2] = this.points[0].distanceSquared(this.points[1]);\n    }\n    /** Copy all values from `other` */\n    setFrom(other) {\n        for (let i = 0; i < 3; ++i) {\n            this.points[i].setFromPoint3d(other.points[i]);\n            this.edgeLength2[i] = other.edgeLength2[i];\n        }\n    }\n    /**\n     * Create a `BarycentricTriangle` with coordinates given by enumerated x,y,z of the 3 points.\n     * @param result optional pre-allocated triangle.\n     */\n    static createXYZXYZXYZ(x0, y0, z0, x1, y1, z1, x2, y2, z2, result) {\n        if (!result)\n            return new this(Point3d.create(x0, y0, z0), Point3d.create(x1, y1, z1), Point3d.create(x2, y2, z2));\n        result.points[0].set(x0, y0, z0);\n        result.points[1].set(x1, y1, z1);\n        result.points[2].set(x2, y2, z2);\n        return result;\n    }\n    /** Create a triangle with coordinates cloned from given points. */\n    static create(point0, point1, point2, result) {\n        if (!result)\n            return new this(point0.clone(), point1.clone(), point2.clone());\n        result.set(point0, point1, point2);\n        return result;\n    }\n    /** Return a new `BarycentricTriangle` with the same coordinates. */\n    clone(result) {\n        return BarycentricTriangle.create(this.points[0], this.points[1], this.points[2], result);\n    }\n    /** Return a clone of the transformed instance */\n    cloneTransformed(transform, result) {\n        return BarycentricTriangle.create(transform.multiplyPoint3d(this.points[0], result?.points[0]), transform.multiplyPoint3d(this.points[1], result?.points[1]), transform.multiplyPoint3d(this.points[2], result?.points[2]), result);\n    }\n    /** Return the area of the triangle. */\n    get area() {\n        // The magnitude of the cross product A Ã— B is the area of the parallelogram spanned by A and B.\n        return 0.5 * this.points[0].crossProductToPointsMagnitude(this.points[1], this.points[2]);\n    }\n    /**\n     * Compute squared length of the triangle edge opposite the vertex with the given index.\n     * @see [[edgeStartVertexIndexToOppositeVertexIndex]]\n     */\n    edgeLengthSquared(oppositeVertexIndex) {\n        return this.edgeLength2[Geometry.cyclic3dAxis(oppositeVertexIndex)];\n    }\n    /**\n     * Compute length of the triangle edge opposite the vertex with the given index.\n     * @see [[edgeStartVertexIndexToOppositeVertexIndex]]\n     */\n    edgeLength(oppositeVertexIndex) {\n        return Math.sqrt(this.edgeLengthSquared(oppositeVertexIndex));\n    }\n    /** Return area divided by sum of squared lengths. */\n    get aspectRatio() {\n        return Geometry.safeDivideFraction(this.area, this.edgeLengthSquared(0) + this.edgeLengthSquared(1) + this.edgeLengthSquared(2), 0);\n    }\n    /** Return the perimeter of the triangle. */\n    get perimeter() {\n        return this.edgeLength(0) + this.edgeLength(1) + this.edgeLength(2);\n    }\n    /**\n     * Return the unit normal of the triangle.\n     * @param result optional pre-allocated vector to fill and return.\n     * @returns unit normal, or undefined if cross product length is too small.\n     */\n    normal(result) {\n        const cross = this.points[0].crossProductToPoints(this.points[1], this.points[2], result);\n        if (cross.tryNormalizeInPlace())\n            return cross;\n        return undefined;\n    }\n    /**\n     * Sum the triangle points with given scales.\n     * * If the scales sum to 1, they are barycentric coordinates, and hence the result point is in the plane of\n     * the triangle. If all coordinates are non-negative then the result point is inside the triangle.\n     * * If the scales do not sum to 1, the point is inside the triangle scaled (by the scale sum) from the origin.\n     * @param b0 scale to apply to vertex 0\n     * @param b1 scale to apply to vertex 1\n     * @param b2 scale to apply to vertex 2\n     * @param result optional pre-allocated point to fill and return\n     * @return linear combination of the vertices of this triangle\n     * @see [[pointToFraction]]\n     */\n    fractionToPoint(b0, b1, b2, result) {\n        // p = b0 * v0 + b1 * v1 + b2 * v2\n        return Point3d.createAdd3Scaled(this.points[0], b0, this.points[1], b1, this.points[2], b2, result);\n    }\n    /**\n     * Compute the projection of the given `point` onto the plane of this triangle.\n     * @param point point p to project\n     * @param result optional pre-allocated object to fill and return\n     * @returns details d of the projection point `P = d.world`:\n     * * `d.isValid` returns true if and only if `this.normal()` is defined.\n     * * `d.classify` can be used to determine where P lies with respect to the triangle.\n     * * `d.a` is the signed projection distance: `P = p + a * this.normal()`.\n     * * Visualization can be found at https://www.itwinjs.org/sandbox/SaeedTorabi/BarycentricTriangle\n     * @see [[fractionToPoint]]\n     */\n    pointToFraction(point, result) {\n        const normal = BarycentricTriangle._workVector0 = this.normal(BarycentricTriangle._workVector0);\n        if (undefined === normal)\n            return TriangleLocationDetail.create(result);\n        const ray = BarycentricTriangle._workRay = Ray3d.create(point, normal, BarycentricTriangle._workRay);\n        return this.intersectRay3d(ray, result); // intersectRay3d is free to use workVector0\n    }\n    /** Convert from opposite-vertex to start-vertex edge indexing. */\n    static edgeOppositeVertexIndexToStartVertexIndex(edgeIndex) {\n        return Geometry.cyclic3dAxis(edgeIndex + 1);\n    }\n    /** Convert from start-vertex to opposite-vertex edge indexing. */\n    static edgeStartVertexIndexToOppositeVertexIndex(startVertexIndex) {\n        return Geometry.cyclic3dAxis(startVertexIndex - 1);\n    }\n    /**\n     * Examine a point's barycentric coordinates to determine if it lies inside the triangle but not on an edge/vertex.\n     * * No parametric tolerance is used.\n     * * It is assumed b0 + b1 + b2 = 1.\n     * @returns whether the point with barycentric coordinates is strictly inside the triangle.\n     */\n    static isInsideTriangle(b0, b1, b2) {\n        return b0 > 0 && b1 > 0 && b2 > 0;\n    }\n    /**\n     * Examine a point's barycentric coordinates to determine if it lies inside the triangle or on an edge/vertex.\n     * * No parametric tolerance is used.\n     * * It is assumed b0 + b1 + b2 = 1.\n     * @returns whether the point with barycentric coordinates is inside or on the triangle.\n     */\n    static isInsideOrOnTriangle(b0, b1, b2) {\n        return b0 >= 0 && b1 >= 0 && b2 >= 0;\n    }\n    /**\n     * Examine a point's barycentric coordinates to determine if it lies outside an edge of the triangle.\n     * * No parametric tolerance is used.\n     * * It is assumed b0 + b1 + b2 = 1.\n     * @returns edge index i (opposite vertex i) for which b_i < 0 and b_j >= 0, and b_k >= 0. Otherwise, returns -1.\n     */\n    static isInRegionBeyondEdge(b0, b1, b2) {\n        // Note: the 3 regions (specified by the following if statements) are defined by extending the triangle\n        // edges to infinity and not by perpendicular lines to the edges (which gives smaller regions)\n        if (b0 < 0 && b1 >= 0 && b2 >= 0)\n            return 0;\n        if (b0 >= 0 && b1 < 0 && b2 >= 0)\n            return 1;\n        if (b0 >= 0 && b1 >= 0 && b2 < 0)\n            return 2;\n        return -1;\n    }\n    /**\n     * Examine a point's barycentric coordinates to determine if it lies outside a vertex of the triangle.\n     * * No parametric tolerance is used.\n     * * It is assumed b0 + b1 + b2 = 1.\n     * @returns index of vertex i for which b_j < 0 and b_k < 0. Otherwise, returns -1.\n     */\n    static isInRegionBeyondVertex(b0, b1, b2) {\n        // Note: the 3 regions (specified by the following if statements) are defined by extending the triangle\n        // edges to infinity and not by perpendicular lines to the edges (which gives larger regions)\n        if (b1 < 0 && b2 < 0)\n            return 0;\n        if (b0 < 0 && b2 < 0)\n            return 1;\n        if (b0 < 0 && b1 < 0)\n            return 2;\n        return -1;\n    }\n    /**\n     * Examine a point's barycentric coordinates to determine if it lies on a vertex of the triangle.\n     * * No parametric tolerance is used.\n     * * It is assumed b0 + b1 + b2 = 1.\n     * @returns index of vertex i for which b_i = 1 and b_j = b_k = 0. Otherwise, returns -1.\n     */\n    static isOnVertex(b0, b1, b2) {\n        if (b0 === 1 && b1 === 0 && b2 === 0)\n            return 0;\n        if (b0 === 0 && b1 === 1 && b2 === 0)\n            return 1;\n        if (b0 === 0 && b1 === 0 && b2 === 1)\n            return 2;\n        return -1;\n    }\n    /**\n     * Examine a point's barycentric coordinates to determine if it lies on a bounded edge of the triangle.\n     * * No parametric tolerance is used.\n     * * It is assumed b0 + b1 + b2 = 1.\n     * @returns edge index i (opposite vertex i) for which b_i = 0, b_j > 0, and b_k > 0. Otherwise, returns -1.\n     */\n    static isOnBoundedEdge(b0, b1, b2) {\n        if (b0 === 0 && b1 > 0 && b2 > 0)\n            return 0;\n        if (b0 > 0 && b1 === 0 && b2 > 0)\n            return 1;\n        if (b0 > 0 && b1 > 0 && b2 === 0)\n            return 2;\n        return -1;\n    }\n    /** @returns edge/vertex index (0,1,2) for which the function has a minimum value */\n    static indexOfMinimum(fn) {\n        let i = 0;\n        let min = fn(0);\n        const val = fn(1);\n        if (min > val) {\n            i = 1;\n            min = val;\n        }\n        if (min > fn(2))\n            i = 2;\n        return i;\n    }\n    /**\n     * Compute the squared distance between two points given by their barycentric coordinates.\n     * * It is assumed that a0 + a1 + a2 = b0 + b1 + b2 = 1.\n     */\n    distanceSquared(a0, a1, a2, b0, b1, b2) {\n        // The barycentric displacement vector distance formula\n        // More details can be found at https://web.evanchen.cc/handouts/bary/bary-full.pdf\n        return -this.edgeLengthSquared(0) * (b1 - a1) * (b2 - a2)\n            - this.edgeLengthSquared(1) * (b2 - a2) * (b0 - a0)\n            - this.edgeLengthSquared(2) * (b0 - a0) * (b1 - a1);\n    }\n    /** Return the index of the closest triangle vertex to the point given by its barycentric coordinates. */\n    closestVertexIndex(b0, b1, b2) {\n        return BarycentricTriangle.indexOfMinimum((i) => {\n            const a = BarycentricTriangle._workPoint = Point3d.createZero(BarycentricTriangle._workPoint);\n            a.setAt(i, 1.0); // \"a\" is (1,0,0) or (0,1,0) or (0,0,1) so \"a\" represents vertex i\n            return this.distanceSquared(a.x, a.y, a.z, b0, b1, b2); // distance between the point and vertex i\n        });\n    }\n    /** Compute dot product of the edge vectors based at the vertex with the given index. */\n    dotProductOfEdgeVectorsAtVertex(baseVertexIndex) {\n        const i = Geometry.cyclic3dAxis(baseVertexIndex);\n        const j = Geometry.cyclic3dAxis(i + 1);\n        const k = Geometry.cyclic3dAxis(j + 1);\n        return Geometry.dotProductXYZXYZ(this.points[j].x - this.points[i].x, this.points[j].y - this.points[i].y, this.points[j].z - this.points[i].z, this.points[k].x - this.points[i].x, this.points[k].y - this.points[i].y, this.points[k].z - this.points[i].z);\n    }\n    /**\n     * Compute the projection of barycentric point p onto the (unbounded) edge e_k(v_i,v_j) of the triangle T(v_i,v_j,v_k).\n     * @param k vertex v_k is opposite the edge e_k\n     * @param b barycentric coordinates of point to project\n     * @returns parameter f along e_k, such that:\n     * * the projection point is q = v_i + f * (v_j - v_i)\n     * * the barycentric coords of the projection are q_ijk = (1 - f, f, 0)\n     */\n    computeProjectionToEdge(k, b) {\n        /**\n         * We know p = (b_i*v_i) + (b_j*v_j) + (b_k*v_k) and 1 = b_i + b_j + b_k.\n         * Let U = v_j - v_i and V = v_k - v_i and P = p - v_i.\n         * First we prove P = b_jU + b_kV.\n         *       P = (b_i * v_i) + (b_j * v_j) + (b_k * v_k) - v_i\n         *         = (b_i * v_i) + (b_j * (v_j-v_i)) + (b_j * v_i) + (b_k * (v_k-v_i)) + (b_k * v_i) - v_i\n         *         = (b_i * v_i) + (b_j * U) + (b_j * v_i) + (b_k * V) + (b_k * v_i) - v_i\n         *         = (b_j * U) + (b_k * V) + ((b_i + b_j + b_k) * v_i) - v_i\n         *         = (b_j * U) + (b_k * V) + v_i - v_i\n         *         = (b_j * U) + (b_k * V)\n         * So we know p - v_i = b_jU + b_kV and q - v_i = fU\n         * Therefore, 0 = (p - q).(v_j - v_i)\n         *              = ((p-v_i) - (q-v_i)).(v_j - v_i)\n         *              = (b_jU + b_kV - fU).U\n         *              = b_jU.U + b_kU.V - fU.U\n         * Thus f = b_j + b_k(U.V/U.U)\n         */\n        k = Geometry.cyclic3dAxis(k);\n        const i = Geometry.cyclic3dAxis(k + 1);\n        const j = Geometry.cyclic3dAxis(i + 1);\n        return b[j] + b[k] * this.dotProductOfEdgeVectorsAtVertex(i) / this.edgeLengthSquared(k);\n    }\n    /**\n     * Compute the projection of a barycentric point p to the triangle T(v_0,v_1,v_2).\n     * @param b0 barycentric coordinate of p corresponding to v_0\n     * @param b1 barycentric coordinate of p corresponding to v_1\n     * @param b2 barycentric coordinate of p corresponding to v_2\n     * @returns closest edge start vertex index i and projection parameter f such that the projection\n     * q = v_i + f * (v_j - v_i).\n     */\n    closestPoint(b0, b1, b2) {\n        const b = [b0, b1, b2];\n        let edgeIndex = -1; // opposite-vertex index\n        let edgeParam = 0.0;\n        if (BarycentricTriangle.isInsideTriangle(b0, b1, b2)) { // projects to any edge\n            edgeIndex = BarycentricTriangle.indexOfMinimum((i) => {\n                // We want smallest projection distance d_i of p to e_i.\n                // Since b_i=d_i|e_i|/2A we can compare quantities b_i/|e_i|.\n                return b[i] * b[i] / this.edgeLengthSquared(i); // avoid sqrt\n            });\n            edgeParam = this.computeProjectionToEdge(edgeIndex, b);\n        }\n        else if ((edgeIndex = BarycentricTriangle.isInRegionBeyondVertex(b0, b1, b2)) >= 0) { // projects to other edges, or any vertex\n            edgeIndex = Geometry.cyclic3dAxis(edgeIndex + 1);\n            edgeParam = this.computeProjectionToEdge(edgeIndex, b);\n            if (edgeParam < 0 || edgeParam > 1) {\n                edgeIndex = Geometry.cyclic3dAxis(edgeIndex + 1);\n                edgeParam = this.computeProjectionToEdge(edgeIndex, b);\n                if (edgeParam < 0 || edgeParam > 1) {\n                    edgeParam = 0.0;\n                    edgeIndex = BarycentricTriangle.edgeStartVertexIndexToOppositeVertexIndex(this.closestVertexIndex(b0, b1, b2));\n                }\n            }\n        }\n        else if ((edgeIndex = BarycentricTriangle.isInRegionBeyondEdge(b0, b1, b2)) >= 0) { // projects to the edge or its vertices\n            edgeParam = this.computeProjectionToEdge(edgeIndex, b);\n            if (edgeParam < 0) {\n                edgeParam = 0.0; // start of this edge\n            }\n            else if (edgeParam > 1) {\n                edgeParam = 0.0;\n                edgeIndex = Geometry.cyclic3dAxis(edgeIndex + 1); // end of this edge = start of next edge\n            }\n        }\n        else if ((edgeIndex = BarycentricTriangle.isOnBoundedEdge(b0, b1, b2)) >= 0) {\n            edgeParam = 1 - b[BarycentricTriangle.edgeOppositeVertexIndexToStartVertexIndex(edgeIndex)];\n        }\n        else if ((edgeIndex = BarycentricTriangle.isOnVertex(b0, b1, b2)) >= 0) {\n            edgeParam = 0.0;\n            edgeIndex = BarycentricTriangle.edgeStartVertexIndexToOppositeVertexIndex(edgeIndex);\n        }\n        // invalid edgeIndex shouldn't happen, but propagate it anyway\n        assert(edgeIndex === 0 || edgeIndex === 1 || edgeIndex === 2);\n        return {\n            closestEdgeIndex: (edgeIndex < 0) ? -1 : BarycentricTriangle.edgeOppositeVertexIndexToStartVertexIndex(edgeIndex),\n            closestEdgeParam: edgeParam,\n        };\n    }\n    /**\n     * Compute the intersection of a line (parameterized as a ray) with the plane of this triangle.\n     * * This method is slower than `Ray3d.intersectionWithTriangle`.\n     * @param ray infinite line to intersect, as a ray\n     * @param result optional pre-allocated object to fill and return\n     * @returns details d of the line-plane intersection point `d.world`:\n     * * `d.a` is the intersection parameter along the ray.\n     * * The line intersects the plane of the triangle if and only if `d.isValid` returns true.\n     * * The ray intersects the plane of the triangle if and only if `d.isValid` returns true and `d.a` >= 0.\n     * * The ray intersects the triangle if and only if `d.isValid` returns true, `d.a` >= 0, and `d.isInsideOrOn`\n     * returns true.\n     * * `d.classify` can be used to determine where the intersection lies with respect to the triangle.\n     * * Visualization can be found at https://www.itwinjs.org/sandbox/SaeedTorabi/RayTriangleIntersection\n     * @see [[pointToFraction]]\n    */\n    intersectRay3d(ray, result) {\n        result = TriangleLocationDetail.create(result);\n        /**\n         * Let r0 = ray.origin and d = ray.direction. Write intersection point p two ways for unknown scalars s,b0,b1,b2:\n         *         r0 + s*d = p = b0*v0 + b1*v1 + b2*v2\n         * Subtract v0 from both ends, let u=v1-v0, v=v2-v0, c=r0-v0, and enforce b0+b1+b2=1:\n         *              b1*u + b2*v - s*d = c\n         * This is a linear system Mx = c where M has columns u,v,d and solution x=(b1,b2,-s).\n         */\n        const r0 = ray.origin;\n        const d = ray.direction;\n        const u = BarycentricTriangle._workVector0 = Vector3d.createStartEnd(this.points[0], this.points[1], BarycentricTriangle._workVector0);\n        const v = BarycentricTriangle._workVector1 = Vector3d.createStartEnd(this.points[0], this.points[2], BarycentricTriangle._workVector1);\n        const M = BarycentricTriangle._workMatrix = Matrix3d.createColumns(u, v, d, BarycentricTriangle._workMatrix);\n        const c = Vector3d.createStartEnd(this.points[0], r0, BarycentricTriangle._workVector0); // reuse workVector0\n        const solution = BarycentricTriangle._workVector1; // reuse workVector1\n        if (undefined === M.multiplyInverse(c, solution))\n            return result; // invalid\n        result.a = -solution.z; // = -(-s) = s\n        ray.fractionToPoint(result.a, result.world);\n        result.local.set(1.0 - solution.x - solution.y, solution.x, solution.y); // = (1 - b1 - b2, b1, b2) = (b0 , b1, b2)\n        const proj = this.closestPoint(result.local.x, result.local.y, result.local.z);\n        result.closestEdgeIndex = proj.closestEdgeIndex;\n        result.closestEdgeParam = proj.closestEdgeParam;\n        return result;\n    }\n    /**\n     * Compute the intersection of a line (parameterized as a line segment) with the plane of this triangle.\n     * @param point0 start point of segment on line to intersect\n     * @param point1 end point of segment on line to intersect\n     * @param result optional pre-allocated object to fill and return\n     * @returns details d of the line-plane intersection point `d.world`:\n     * * `d.isValid` returns true if and only if the line intersects the plane.\n     * * `d.classify` can be used to determine where the intersection lies with respect to the triangle.\n     * * `d.a` is the intersection parameter. If `d.a` is in [0,1], the segment intersects the plane of the triangle.\n     * @see [[intersectRay3d]]\n    */\n    intersectSegment(point0, point1, result) {\n        BarycentricTriangle._workRay = Ray3d.createStartEnd(point0, point1, BarycentricTriangle._workRay);\n        return this.intersectRay3d(BarycentricTriangle._workRay, result);\n    }\n    /**\n     * Adjust the location to the closest edge of the triangle if within either given tolerance.\n     * @param location details of a point in the plane of the triangle (note that `location.local` and\n     * `location.world` possibly updated to lie on the triangle closest edge)\n     * @param distanceTolerance absolute distance tolerance (or zero to ignore)\n     * @param parameterTolerance barycentric coordinate fractional tolerance (or zero to ignore)\n     * @return whether the location was adjusted\n     */\n    snapLocationToEdge(location, distanceTolerance = Geometry.smallMetricDistance, parameterTolerance = Geometry.smallFloatingPoint) {\n        if (!location.isValid)\n            return false;\n        // first try parametric tol to zero barycentric coordinate (no vertices or world distances used!)\n        if (parameterTolerance > 0.0) {\n            let numSnapped = 0;\n            let newSum = 0.0;\n            for (let i = 0; i < 3; i++) {\n                const barycentricDist = Math.abs(location.local.at(i));\n                if (barycentricDist > 0.0 && barycentricDist < parameterTolerance) {\n                    location.local.setAt(i, 0.0);\n                    numSnapped++;\n                }\n                newSum += location.local.at(i);\n            }\n            if (numSnapped > 0 && newSum > 0.0) {\n                location.local.scaleInPlace(1.0 / newSum);\n                if (1 === numSnapped) {\n                    location.closestEdgeIndex = BarycentricTriangle.edgeOppositeVertexIndexToStartVertexIndex(BarycentricTriangle.isOnBoundedEdge(location.local.x, location.local.y, location.local.z));\n                    location.closestEdgeParam = 1.0 - location.local.at(location.closestEdgeIndex);\n                }\n                else { // 2 snapped, at vertex\n                    location.closestEdgeIndex = BarycentricTriangle.isOnVertex(location.local.x, location.local.y, location.local.z);\n                    location.closestEdgeParam = 0.0;\n                }\n                this.fractionToPoint(location.local.x, location.local.y, location.local.z, location.world);\n                return true;\n            }\n        }\n        // failing that, try distance tol to closest edge projection\n        if (distanceTolerance > 0.0) {\n            const i = location.closestEdgeIndex;\n            const j = (i + 1) % 3;\n            const k = (j + 1) % 3;\n            const edgeProjection = BarycentricTriangle._workPoint = this.points[i].interpolate(location.closestEdgeParam, this.points[j], BarycentricTriangle._workPoint);\n            const dist = location.world.distance(edgeProjection);\n            if (dist > 0.0 && dist < distanceTolerance) {\n                location.local.setAt(i, 1.0 - location.closestEdgeParam);\n                location.local.setAt(j, location.closestEdgeParam);\n                location.local.setAt(k, 0.0);\n                location.world.setFrom(edgeProjection);\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Return the dot product of the scaled normals of the two triangles.\n     * * The sign of the return value is useful for determining the triangles' relative orientation:\n     * positive (negative) means the normals point into the same (opposite) half-space determined by\n     * one of the triangles' planes; zero means the triangles are perpendicular.\n     */\n    dotProductOfCrossProductsFromOrigin(other) {\n        BarycentricTriangle._workVector0 = this.points[0].crossProductToPoints(this.points[1], this.points[2], BarycentricTriangle._workVector0);\n        BarycentricTriangle._workVector1 = other.points[0].crossProductToPoints(other.points[1], other.points[2], BarycentricTriangle._workVector1);\n        return BarycentricTriangle._workVector0.dotProduct(BarycentricTriangle._workVector1);\n    }\n    /** Return the centroid of the 3 points. */\n    centroid(result) {\n        // Do the scale as true division (rather than multiply by precomputed 1/3). This might protect one bit of result.\n        return Point3d.create((this.points[0].x + this.points[1].x + this.points[2].x) / 3.0, (this.points[0].y + this.points[1].y + this.points[2].y) / 3.0, (this.points[0].z + this.points[1].z + this.points[2].z) / 3.0, result);\n    }\n    /** Return the incenter of the triangle. */\n    incenter(result) {\n        const a = this.edgeLength(0);\n        const b = this.edgeLength(1);\n        const c = this.edgeLength(2);\n        const scale = Geometry.safeDivideFraction(1.0, a + b + c, 0.0);\n        return this.fractionToPoint(scale * a, scale * b, scale * c, result);\n    }\n    /** Return the circumcenter of the triangle. */\n    circumcenter(result) {\n        const a2 = this.edgeLengthSquared(0);\n        const b2 = this.edgeLengthSquared(1);\n        const c2 = this.edgeLengthSquared(2);\n        const x = a2 * (b2 + c2 - a2);\n        const y = b2 * (c2 + a2 - b2);\n        const z = c2 * (a2 + b2 - c2);\n        const scale = Geometry.safeDivideFraction(1.0, x + y + z, 0.0);\n        return this.fractionToPoint(scale * x, scale * y, scale * z, result);\n    }\n    /** Test for point-by-point `isAlmostEqual` relationship. */\n    isAlmostEqual(other, tol) {\n        return this.points[0].isAlmostEqual(other.points[0], tol)\n            && this.points[1].isAlmostEqual(other.points[1], tol)\n            && this.points[2].isAlmostEqual(other.points[2], tol);\n    }\n}\n//# sourceMappingURL=BarycentricTriangle.js.map",
      "start": 1693508122301,
      "end": 1693508122356,
      "sourcemaps": null
    }
  ]
}
