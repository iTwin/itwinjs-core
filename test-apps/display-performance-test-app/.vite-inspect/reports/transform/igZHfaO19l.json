{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/geometry3d/FrameBuilder.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module CartesianGeometry\n */\n// import { Point2d } from \"./Geometry2d\";\nimport { BSplineCurve3d } from \"../bspline/BSplineCurve\";\nimport { InterpolationCurve3d } from \"../bspline/InterpolationCurve3d\";\nimport { Arc3d } from \"../curve/Arc3d\";\nimport { CurveCollection } from \"../curve/CurveCollection\";\nimport { CurvePrimitive } from \"../curve/CurvePrimitive\";\nimport { LineSegment3d } from \"../curve/LineSegment3d\";\nimport { LineString3d } from \"../curve/LineString3d\";\nimport { AxisOrder, AxisScaleSelect, Geometry } from \"../Geometry\";\nimport { GrowableXYZArray } from \"./GrowableXYZArray\";\nimport { Matrix3d } from \"./Matrix3d\";\nimport { Point3d, Vector3d } from \"./Point3dVector3d\";\nimport { Point3dArray } from \"./PointHelpers\";\nimport { PolygonOps } from \"./PolygonOps\";\nimport { Transform } from \"./Transform\";\n/* eslint-disable @typescript-eslint/naming-convention, no-empty */\n/**\n * Helper class to accumulate points and vectors until there is enough data to define a coordinate system.\n *\n * * For the common case of building a right handed frame:\n *   * create the FrameBuilder and make calls to announcePoint and announceVector.\n *   * the frame will be fully determined by an origin and two vectors.\n *   * the first call to announcePoint will set the origin.\n *   * additional calls to announcePoint will produce announceVector call with the vector from the origin.\n *   * after each announcement, call getValidatedFrame(false)\n *   * getValidatedFrame will succeed when it has two independent vectors.\n * *  To build a left handed frame,\n *   *  an origin and 3 independent vectors are required.\n *   *  announce as above, but query with getValidatedFrame (true).\n *   *  this will use the third vector to select right or left handed frame.\n * @public\n */\nexport class FrameBuilder {\n    // test if both vectors are defined and have significant angle between.\n    areStronglyIndependentVectors(vector0, vector1, radiansTolerance = Geometry.smallAngleRadians) {\n        if (vector0 !== undefined && vector1 !== undefined) {\n            const q = vector0.smallerUnorientedRadiansTo(vector1);\n            return q > radiansTolerance;\n        }\n        return false;\n    }\n    /** Clear all accumulated point and vector data */\n    clear() {\n        this._origin = undefined;\n        this._vector0 = undefined;\n        this._vector1 = undefined;\n        this._vector2 = undefined;\n    }\n    constructor() {\n        this.clear();\n    }\n    /**\n     * Try to assemble the data into a non-singular transform.\n     * * If allowLeftHanded is false, vector0 and vector1 determine a right handed coordinate system.\n     * * if allowLeftHanded is true, the z vector of the right handed system can be flipped to agree with vector2 direction.\n     */\n    getValidatedFrame(allowLeftHanded = false, result) {\n        if (this._origin && this._vector0 && this._vector1) {\n            const createRigidMatrix = (v0, v1) => {\n                return FrameBuilder._workMatrix = Matrix3d.createRigidFromColumns(v0, v1, AxisOrder.XYZ, FrameBuilder._workMatrix);\n            };\n            if (!allowLeftHanded) {\n                const matrix = createRigidMatrix(this._vector0, this._vector1);\n                if (matrix)\n                    return Transform.createOriginAndMatrix(this._origin, matrix, result);\n                // uh oh -- vector1 was not really independent.  clear everything after vector0.\n                this._vector1 = this._vector2 = undefined;\n            }\n            else if (this._vector2) {\n                const matrix = createRigidMatrix(this._vector0, this._vector1);\n                if (matrix) {\n                    if (this._vector0.tripleProduct(this._vector1, this._vector2) < 0)\n                        matrix.scaleColumns(1.0, 1.0, -1.0);\n                    return Transform.createOriginAndMatrix(this._origin, matrix, result);\n                }\n                // uh oh again -- clear vector1 and vector2, re-announce vector2 as possible vector1??\n                const vector2 = this._vector2;\n                this._vector1 = this._vector2 = undefined;\n                this.announceVector(vector2);\n            }\n        }\n        return undefined;\n    }\n    /** If vector0 is known but vector1 is not, make vector1 the cross of the up-vector and vector0 */\n    applyDefaultUpVector(vector) {\n        if (vector && this._vector0 && !this._vector1 && !vector.isParallelTo(this._vector0)) {\n            this._vector1 = vector.crossProduct(this._vector0);\n        }\n    }\n    /** Ask if there is a defined origin for the evolving frame */\n    get hasOrigin() {\n        return this._origin !== undefined;\n    }\n    /**\n     * Return the number of vectors saved. Because the save process checks numerics, this should be the rank of the system.\n     */\n    savedVectorCount() {\n        if (!this._vector0)\n            return 0;\n        if (!this._vector1)\n            return 1;\n        if (!this._vector2)\n            return 2;\n        return 3;\n    }\n    /**\n     * Announce a new point. If this point is different from the origin, also compute and announce the vector from the origin.\n     */\n    announcePoint(point) {\n        if (!this._origin) {\n            this._origin = point.clone();\n            return this.savedVectorCount();\n        }\n        // the new point may provide an additional vector\n        if (this._origin.isAlmostEqual(point))\n            return this.savedVectorCount();\n        return this.announceVector(this._origin.vectorTo(point));\n    }\n    /** Announce a new vector. */\n    announceVector(vector) {\n        if (vector.isAlmostZero)\n            return this.savedVectorCount();\n        if (!this._vector0) {\n            this._vector0 = vector.clone(this._vector0);\n            return 1;\n        }\n        if (!this._vector1) {\n            if (this.areStronglyIndependentVectors(vector, this._vector0, 1.0e-5)) {\n                this._vector1 = vector.clone(this._vector1);\n                return 2;\n            }\n            return 1;\n        }\n        // vector0 and vector1 are independent.\n        if (!this._vector2) {\n            const unitPerpendicular = this._vector0.unitCrossProduct(this._vector1);\n            if (unitPerpendicular && !Geometry.isSameCoordinate(0, unitPerpendicular.dotProduct(vector))) {\n                this._vector2 = vector.clone(this._vector2);\n                return 3;\n            }\n            return 2;\n        }\n        // fall through if prior vectors are all there -- no need for the new one.\n        return 3;\n    }\n    /**\n     * Inspect the content of the data.  Announce points and vectors. Return when savedVectorCount becomes sufficient\n     * for a coordinate system.\n     */\n    announce(data) {\n        if (this.savedVectorCount() > 1)\n            return;\n        if (data === undefined)\n            return;\n        if (data instanceof Point3d)\n            this.announcePoint(data);\n        else if (data instanceof Vector3d)\n            this.announceVector(data);\n        else if (Array.isArray(data)) {\n            for (const child of data) {\n                if (this.savedVectorCount() > 1)\n                    break;\n                this.announce(child);\n            }\n        }\n        else if (data instanceof CurvePrimitive) {\n            if (data instanceof LineSegment3d) {\n                this.announcePoint(data.startPoint());\n                this.announcePoint(data.endPoint());\n            }\n            else if (data instanceof Arc3d) {\n                const ray = data.fractionToPointAndDerivative(0.0);\n                this.announcePoint(ray.origin);\n                this.announceVector(ray.direction);\n                this.announceVector(data.matrixRef.columnZCrossVector(ray.direction));\n            }\n            else if (data instanceof LineString3d) {\n                for (const point of data.points) {\n                    this.announcePoint(point);\n                    if (this.savedVectorCount() > 1)\n                        break;\n                }\n            }\n            else if (data instanceof BSplineCurve3d) {\n                const point = Point3d.create();\n                for (let i = 0; this.savedVectorCount() < 2; i++) {\n                    if (data.getPolePoint3d(i, point) instanceof Point3d)\n                        this.announcePoint(point);\n                    else\n                        break;\n                }\n            }\n            else if (data instanceof InterpolationCurve3d) {\n                const point = Point3d.create();\n                for (let i = 0; this.savedVectorCount() < 2; i++) {\n                    if (i < data.options.fitPoints.length) {\n                        point.setFrom(data.options.fitPoints[i]);\n                        this.announcePoint(point);\n                    }\n                    else\n                        break;\n                }\n            }\n            else { // unimplemented CurvePrimitive type\n                const frame = data.fractionToFrenetFrame(0.0);\n                if (undefined !== frame) {\n                    this.announcePoint(frame.getOrigin());\n                    this.announceVector(frame.matrix.getColumn(0));\n                    this.announceVector(frame.matrix.getColumn(1));\n                }\n            }\n        }\n        else if (data instanceof CurveCollection) {\n            if (data.children)\n                for (const child of data.children) {\n                    this.announce(child);\n                    if (this.savedVectorCount() > 1)\n                        break;\n                }\n        }\n        else if (data instanceof GrowableXYZArray) {\n            const point = Point3d.create();\n            for (let i = 0; this.savedVectorCount() < 2; i++) {\n                if (data.getPoint3dAtCheckedPointIndex(i, point) instanceof Point3d)\n                    this.announcePoint(point);\n                else\n                    break;\n            }\n        }\n    }\n    /**\n     * Create a localToWorld frame for the given data.\n     * * origin is at first point.\n     * * x axis in direction of first nonzero vector present or implied by the input.\n     * * y axis is perpendicular to x and contains (in positive side) the next vector present or implied by the input.\n     * * The calculation favors the first points found. It does not try to get a \"best\" plane.\n     * @param defaultUpVector optional vector to cross with vector0 to create vector1 when it is unknown\n     * @param params any number of geometric objects to examine in [[announce]] for point/vector data sufficient to construct a frame.\n     * If the last argument is a `Transform`, it is populated with the computed frame and returned.\n     * @returns computed localToWorld frame, or undefined if insufficient data.\n     */\n    static createRightHandedFrame(defaultUpVector, ...params) {\n        // if last arg is a Transform, remove it from the array and use for the return value\n        let frame = (params.length > 0 && params[params.length - 1] instanceof Transform) ? params.pop() : undefined;\n        const builder = new FrameBuilder();\n        for (const data of params) {\n            builder.announce(data);\n            builder.applyDefaultUpVector(defaultUpVector);\n            if (frame = builder.getValidatedFrame(false, frame)) {\n                if (defaultUpVector) {\n                    if (frame.matrix.dotColumnZ(defaultUpVector) < 0.0)\n                        frame.matrix.scaleColumnsInPlace(1, -1, -1);\n                }\n                return frame;\n            }\n        }\n        const evaluatePrimitiveFrame = (curve, result) => {\n            return curve.fractionToFrenetFrame(0.0, result);\n        };\n        // try direct evaluation of curve primitives using the above lambda\n        for (const data of params) {\n            if (data instanceof CurvePrimitive) {\n                return evaluatePrimitiveFrame(data, frame);\n            }\n            else if (data instanceof CurveCollection) {\n                const children = data.collectCurvePrimitives();\n                for (const curve of children) {\n                    if (frame = evaluatePrimitiveFrame(curve, frame))\n                        return frame;\n                }\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Create a transform containing points or vectors in the given data.\n     * * The xy columns of the transform contain the first points or vectors of the data.\n     * * The z column is perpendicular to that xy plane.\n     * * The calculation favors the first points found. It does not try to get a \"best\" plane.\n     * @param params any number of geometric objects to examine in [[announce]] for point/vector data sufficient to construct a frame.\n     * If the last argument is a `Transform`, it is populated with the computed frame and returned.\n     * @returns computed localToWorld frame, or undefined if insufficient data.\n     */\n    static createRightHandedLocalToWorld(...params) {\n        return this.createRightHandedFrame(undefined, params);\n    }\n    /**\n     * Try to create a frame whose xy plane is through points.\n     * * If 3 or more distinct points are present, the x axis is from the first point to the most distant, and y\n     * direction is toward the point most distant from that line.\n     * @param points array of points\n     * @param result optional pre-allocated Transform to populate and return\n     * @returns localToWorld frame for the points, or undefined if insufficient data\n     */\n    static createFrameToDistantPoints(points, result) {\n        if (points.length > 2) {\n            const origin = points[0];\n            const vector01 = FrameBuilder._workVector0 ?? Vector3d.create();\n            Point3dArray.indexOfMostDistantPoint(points, points[0], vector01);\n            const vector02 = FrameBuilder._workVector1 ?? Vector3d.create();\n            Point3dArray.indexOfPointWithMaxCrossProductMagnitude(points, origin, vector01, vector02);\n            const matrix = FrameBuilder._workMatrix = Matrix3d.createRigidFromColumns(vector01, vector02, AxisOrder.XYZ, FrameBuilder._workMatrix);\n            if (matrix)\n                return Transform.createOriginAndMatrix(origin, matrix, result);\n        }\n        return undefined;\n    }\n    /**\n     * Try to create a frame whose xy plane is through points, with the points appearing CCW in the local frame.\n     * * If 3 or more distinct points are present, the x axis is from the first point to the most distant, and y\n     * direction is toward the point most distant from that line.\n     * @param points array of points\n     * @param result optional pre-allocated Transform to populate and return\n     * @returns localToWorld frame for the points, or undefined if insufficient data\n     */\n    static createFrameWithCCWPolygon(points, result) {\n        if (points.length > 2) {\n            const ray = PolygonOps.centroidAreaNormal(points); // can't pass pre-allocated ray...\n            if (ray)\n                return ray.toRigidZFrame(result);\n        }\n        return undefined;\n    }\n    /**\n     * Create the localToWorld transform from a range to axes of its parent coordinate system.\n     * @param range range to inspect\n     * @param scaleSelect selects size of localToWorld axes.\n     * @param fractionX fractional coordinate of frame origin x\n     * @param fractionY fractional coordinate of frame origin y\n     * @param fractionZ fractional coordinate of frame origin z\n     * @param defaultAxisLength if true and any axis length is 0, that axis vector takes this physical length.\n     * @param result optional pre-allocated Transform to populate and return\n     * @returns localToWorld frame for the range\n     */\n    static createLocalToWorldTransformInRange(range, scaleSelect = AxisScaleSelect.NonUniformRangeContainment, fractionX = 0, fractionY = 0, fractionZ = 0, defaultAxisLength = 1.0, result) {\n        if (range.isNull)\n            return Transform.createIdentity(result);\n        let a = 1.0;\n        let b = 1.0;\n        let c = 1.0;\n        if (scaleSelect === AxisScaleSelect.LongestRangeDirection) {\n            a = b = c = Geometry.correctSmallMetricDistance(range.maxLength(), defaultAxisLength);\n        }\n        else if (scaleSelect === AxisScaleSelect.NonUniformRangeContainment) {\n            a = Geometry.correctSmallMetricDistance(range.xLength(), defaultAxisLength) * Geometry.maxAbsDiff(fractionX, 0, 1);\n            b = Geometry.correctSmallMetricDistance(range.yLength(), defaultAxisLength) * Geometry.maxAbsDiff(fractionY, 0, 1);\n            c = Geometry.correctSmallMetricDistance(range.zLength(), defaultAxisLength) * Geometry.maxAbsDiff(fractionZ, 0, 1);\n        }\n        const origin = FrameBuilder._workPoint = range.fractionToPoint(fractionX, fractionY, fractionZ, FrameBuilder._workPoint);\n        const matrix = FrameBuilder._workMatrix = Matrix3d.createScale(a, b, c, FrameBuilder._workMatrix);\n        return Transform.createOriginAndMatrix(origin, matrix, result);\n    }\n}\n//# sourceMappingURL=FrameBuilder.js.map",
      "start": 1693508122303,
      "end": 1693508122391,
      "sourcemaps": null
    }
  ]
}
