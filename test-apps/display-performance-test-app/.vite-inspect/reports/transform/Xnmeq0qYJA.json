{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/orbitgt/lib/esm/spatial/geom/Line.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module OrbitGT\n */\nimport { ASystem } from \"../../system/runtime/ASystem\";\nimport { Coordinate } from \"./Coordinate\";\n/**\n * Class Line defines a line between two 3D XYZ points.\n *\n * @version 1.0 March 2010\n */\n/** @internal */\nexport class Line {\n    /**\n     * Create a new line.\n     * @param p0 the start point.\n     * @param p1 the end point.\n     */\n    constructor(p0, p1) {\n        /* Store the points */\n        this.p0 = p0;\n        this.p1 = p1;\n    }\n    /**\n     * Create a new line.\n     * @return a new line.\n     */\n    static create() {\n        return new Line(Coordinate.create(), Coordinate.create());\n    }\n    /**\n     * Create a new line.\n     * @param p0 the start point.\n     * @param p1 the end point.\n     */\n    static fromPoints(p0, p1) {\n        return new Line(p0, p1);\n    }\n    /**\n     * Create a new line.\n     * @param x0 the x of the start point.\n     * @param y0 the y of the start point.\n     * @param z0 the z of the start point.\n     * @param x1 the x of the end point.\n     * @param y1 the y of the end point.\n     * @param z1 the z of the end point.\n     */\n    static fromXYZ(x0, y0, z0, x1, y1, z1) {\n        return new Line(new Coordinate(x0, y0, z0), new Coordinate(x1, y1, z1));\n    }\n    /**\n     * Get the start point.\n     * @return the start point.\n     */\n    getPoint0() {\n        return this.p0;\n    }\n    /**\n     * Get the end point.\n     * @return the end point.\n     */\n    getPoint1() {\n        return this.p1;\n    }\n    /**\n     * Get a point along the line.\n     * @param t the position of the point (0.0 at start and 1.0 at end).\n     * @return a point.\n     */\n    getPoint(t) {\n        /* Avoid rounding errors */\n        if (t == 0.0)\n            return this.p0;\n        if (t == 1.0)\n            return this.p1;\n        /* Calculate a new point */\n        let x = this.p0.getX() + t * (this.p1.getX() - this.p0.getX());\n        let y = this.p0.getY() + t * (this.p1.getY() - this.p0.getY());\n        let z = this.p0.getZ() + t * (this.p1.getZ() - this.p0.getZ());\n        return new Coordinate(x, y, z);\n    }\n    /**\n     * Get a point along the line.\n     * @param t the position of the point (0.0 at start and 1.0 at end).\n     * @param point the result point (must be mutable).\n     */\n    getPointTo(t, point) {\n        /* Start point? */\n        if (t == 0.0) {\n            /* Copy */\n            point.setXYZ(this.p0.getX(), this.p0.getY(), this.p0.getZ());\n        }\n        /* End point? */\n        else if (t == 1.0) {\n            /* Copy */\n            point.setXYZ(this.p1.getX(), this.p1.getY(), this.p1.getZ());\n        }\n        /* Intermediate point */\n        else {\n            /* Calculate a new point */\n            let x = this.p0.getX() + t * (this.p1.getX() - this.p0.getX());\n            let y = this.p0.getY() + t * (this.p1.getY() - this.p0.getY());\n            let z = this.p0.getZ() + t * (this.p1.getZ() - this.p0.getZ());\n            point.setXYZ(x, y, z);\n        }\n    }\n    /**\n     * Get the X coordinate of a point along the line.\n     * @param t the position of the point (0.0 at start and 1.0 at end).\n     * @return the coordinate.\n     */\n    getPointX(t) {\n        /* Start point? */\n        if (t == 0.0) {\n            /* Copy */\n            return this.p0.getX();\n        }\n        /* End point? */\n        else if (t == 1.0) {\n            /* Copy */\n            return this.p1.getX();\n        }\n        /* Intermediate point */\n        else {\n            /* Calculate a new point */\n            return this.p0.getX() + t * (this.p1.getX() - this.p0.getX());\n        }\n    }\n    /**\n     * Get the Y coordinate of a point along the line.\n     * @param t the position of the point (0.0 at start and 1.0 at end).\n     * @return the coordinate.\n     */\n    getPointY(t) {\n        /* Start point? */\n        if (t == 0.0) {\n            /* Copy */\n            return this.p0.getY();\n        }\n        /* End point? */\n        else if (t == 1.0) {\n            /* Copy */\n            return this.p1.getY();\n        }\n        /* Intermediate point */\n        else {\n            /* Calculate a new point */\n            return this.p0.getY() + t * (this.p1.getY() - this.p0.getY());\n        }\n    }\n    /**\n     * Get the Z coordinate of a point along the line.\n     * @param t the position of the point (0.0 at start and 1.0 at end).\n     * @return the coordinate.\n     */\n    getPointZ(t) {\n        /* Start point? */\n        if (t == 0.0) {\n            /* Copy */\n            return this.p0.getZ();\n        }\n        /* End point? */\n        else if (t == 1.0) {\n            /* Copy */\n            return this.p1.getZ();\n        }\n        /* Intermediate point */\n        else {\n            /* Calculate a new point */\n            return this.p0.getZ() + t * (this.p1.getZ() - this.p0.getZ());\n        }\n    }\n    /**\n     * Get a point along the line.\n     * @param d the distance of the point (0.0 at start).\n     * @return a point.\n     */\n    getPointAtDistance(d) {\n        return this.getPoint(d / this.getLength());\n    }\n    /**\n     * Get a point along the line.\n     * @param d the distance of the point (0.0 at start).\n     * @param point the result point (must be mutable).\n     */\n    getPointAtDistanceTo(d, point) {\n        this.getPointTo(d / this.getLength(), point);\n    }\n    /**\n     * Get the position for a fixed x value.\n     * @param x the x value.\n     * @return the position on the line.\n     */\n    getPointAtX(x) {\n        return (x - this.p0.getX()) / (this.p1.getX() - this.p0.getX());\n    }\n    /**\n     * Get a point along the line.\n     * @param x the x value.\n     * @param point the result point (must be mutable).\n     */\n    getPointAtXTo(x, point) {\n        this.getPointTo(this.getPointAtX(x), point);\n        point.setX(x);\n    }\n    /**\n     * Get the position for a fixed y value.\n     * @param y the y value.\n     * @return the position on the line.\n     */\n    getPointAtY(y) {\n        return (y - this.p0.getY()) / (this.p1.getY() - this.p0.getY());\n    }\n    /**\n     * Get a point along the line.\n     * @param y the y value.\n     * @param point the result point (must be mutable).\n     */\n    getPointAtYTo(y, point) {\n        this.getPointTo(this.getPointAtY(y), point);\n        point.setY(y);\n    }\n    /**\n     * Get the position for a fixed z value.\n     * @param z the z value.\n     * @return the position on the line.\n     */\n    getPointAtZ(z) {\n        return (z - this.p0.getZ()) / (this.p1.getZ() - this.p0.getZ());\n    }\n    /**\n     * Get a point along the line.\n     * @param z the z value.\n     * @param point the result point (must be mutable).\n     */\n    getPointAtZTo(z, point) {\n        this.getPointTo(this.getPointAtZ(z), point);\n        point.setZ(z);\n    }\n    /**\n     * Get the direction vector (P1-P0).\n     * @return the direction vector.\n     */\n    getDirection() {\n        /* Return the direction */\n        return this.p1.subtract(this.p0);\n    }\n    /**\n     * Get the direction vector (P1-P0).\n     * @param direction the result direction vector.\n     */\n    getDirectionTo(direction) {\n        /* Return the direction */\n        direction.set(this.p1);\n        direction.subtract0(this.p0);\n    }\n    /**\n     * Get the direction vector (P1-P0).\n     * @return the direction vector.\n     */\n    getDifference() {\n        return this.getDirection();\n    }\n    /**\n     * Swap the orientation of the line (create a line from point1 to point0).\n     * @return a new line.\n     */\n    swapDirection() {\n        return new Line(this.p1, this.p0);\n    }\n    /**\n     * Get the squared length of the segment.\n     * @return the squared length of the segment.\n     */\n    getSquaredLength() {\n        /* Get the direction */\n        let dx = (this.p1.getX() - this.p0.getX());\n        let dy = (this.p1.getY() - this.p0.getY());\n        let dz = (this.p1.getZ() - this.p0.getZ());\n        /* Return the length */\n        return (dx * dx + dy * dy + dz * dz);\n    }\n    /**\n     * Get the length of the segment.\n     * @return the length of the segment.\n     */\n    getLength() {\n        return Math.sqrt(this.getSquaredLength());\n    }\n    /**\n     * Project a point on the segment.\n     * @param point the point to project.\n     * @return the position of the projected point.\n     */\n    getProjection(point) {\n        /* Get the direction of the point */\n        let pdx = (point.getX() - this.p0.getX());\n        let pdy = (point.getY() - this.p0.getY());\n        let pdz = (point.getZ() - this.p0.getZ());\n        /* Get the direction */\n        let dx = (this.p1.getX() - this.p0.getX());\n        let dy = (this.p1.getY() - this.p0.getY());\n        let dz = (this.p1.getZ() - this.p0.getZ());\n        /* Return the value */\n        return (pdx * dx + pdy * dy + pdz * dz) / this.getSquaredLength();\n    }\n    /**\n     * Project a point on the segment.\n     * @param point the point to project.\n     * @return the projected point.\n     */\n    getProjectionPoint(point) {\n        return this.getPoint(this.getProjection(point));\n    }\n    /**\n     * Get the distance from a point to the line.\n     * @param point the point.\n     * @return the distance.\n     */\n    getDistance(point) {\n        /* Project the point */\n        let projected = this.getPoint(this.getProjection(point));\n        /* Return the square distance */\n        return projected.distance3D(point);\n    }\n    /**\n     * Get the distance from a point to the segment between point 0 and point 1.\n     * @param point the point.\n     * @return the distance.\n     */\n    getSegmentDistance(point) {\n        /* Clip the projection */\n        let t = this.getProjection(point);\n        if (t < 0.0)\n            t = 0.0;\n        else if (t > 1.0)\n            t = 1.0;\n        /* Return the distance */\n        let closest = this.getPoint(t);\n        return closest.distance3D(point);\n    }\n    /**\n     * Check if the denominator of an intersection is zero (parallel lines).\n     * @param value the denominator value.\n     * @return true if zero (like -7.105427357601002E-15, -3.8944125702045085E-10 or -3.808708481679941E-9 for perfectly parallel lines).\n     */\n    static isZero(value) {\n        if (value == 0.0)\n            return true;\n        return (Math.abs(value) < 1.0e-6);\n    }\n    /**\n     * Check if the lines is parallel with another line.\n     * @param line the other line.\n     * @return true if the lines are parallel.\n     */\n    isParallel(line) {\n        /* Get the direction vectors */\n        let u = this.getDifference();\n        let v = line.getDifference();\n        /* Get the parameters for the equation */\n        let a = u.dotProduct(u);\n        let b = u.dotProduct(v);\n        let c = v.dotProduct(v);\n        /* Solve the equation */\n        return (Line.isZero(a * c - b * b));\n    }\n    /**\n     * Intersect with another line.\n     * The two lines should not be parallel, check with 'isParallel' first !\n     * @param line the line the intersect with.\n     * @return the position of the intersection point.\n     */\n    getIntersection(line) {\n        // Algorithm copied from:\n        // http://softsurfer.com/Archive/algorithm_0106/algorithm_0106.htm\n        //\n        /* Get the direction vectors */\n        let u = this.getDifference();\n        let v = line.getDifference();\n        /* Get the translation vector */\n        let w0 = this.p0.subtract(line.p0);\n        /* Get the parameters for the equation */\n        let a = u.dotProduct(u);\n        let b = u.dotProduct(v);\n        let c = v.dotProduct(v);\n        let d = u.dotProduct(w0);\n        let e = v.dotProduct(w0);\n        /* Parallel */\n        let denominator = (a * c - b * b);\n        ASystem.assert0(Line.isZero(denominator) == false, \"Lines \" + this + \" and \" + line + \" are parallel when intersecting\");\n        /* Solve the equation */\n        return (b * e - c * d) / denominator;\n    }\n    /**\n     * Intersect with another line.\n     * @param line the line the intersect with.\n     * @return the intersection point (null if the lines are parallell).\n     */\n    getIntersectionPoint(line) {\n        if (this.isParallel(line))\n            return null;\n        return this.getPoint(this.getIntersection(line));\n    }\n    /**\n     * Interpolate a point.\n     * @param point1 the first point on the line.\n     * @param point2 the second point on the line.\n     * @param t the point parameter.\n     * @param point the target point.\n     */\n    static interpolate(point1, point2, t, point) {\n        let x = point1.getX() + t * (point2.getX() - point1.getX());\n        let y = point1.getY() + t * (point2.getY() - point1.getY());\n        let z = point1.getZ() + t * (point2.getZ() - point1.getZ());\n        point.setXYZ(x, y, z);\n    }\n    /**\n     * The standard toString method.\n     * @see Object#toString\n     */\n    toString() {\n        return \"[Line:p0=\" + this.p0 + \",p1=\" + this.p1 + \"]\";\n    }\n}\n//# sourceMappingURL=Line.js.map",
      "start": 1693508124817,
      "end": 1693508124932,
      "sourcemaps": null
    }
  ]
}
