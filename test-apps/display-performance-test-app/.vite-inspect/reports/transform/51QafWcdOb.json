{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tile/map/ArcGisUtilities.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\nimport { Angle, Constant } from \"@itwin/core-geometry\";\nimport { MapCartoRectangle, MapLayerSource, MapLayerSourceStatus } from \"../internal\";\nimport { IModelApp } from \"../../IModelApp\";\n/** @packageDocumentation\n * @module Tiles\n */\n/** @internal */\nexport var ArcGisErrorCode;\n(function (ArcGisErrorCode) {\n    ArcGisErrorCode[ArcGisErrorCode[\"InvalidCredentials\"] = 401] = \"InvalidCredentials\";\n    ArcGisErrorCode[ArcGisErrorCode[\"InvalidToken\"] = 498] = \"InvalidToken\";\n    ArcGisErrorCode[ArcGisErrorCode[\"TokenRequired\"] = 499] = \"TokenRequired\";\n    ArcGisErrorCode[ArcGisErrorCode[\"UnknownError\"] = 1000] = \"UnknownError\";\n    ArcGisErrorCode[ArcGisErrorCode[\"NoTokenService\"] = 1001] = \"NoTokenService\";\n})(ArcGisErrorCode || (ArcGisErrorCode = {}));\n/** @internal */\nclass ArcGisUtilities {\n    static getBBoxString(range) {\n        if (!range)\n            range = MapCartoRectangle.createMaximum();\n        return `${range.low.x * Angle.degreesPerRadian},${range.low.y * Angle.degreesPerRadian},${range.high.x * Angle.degreesPerRadian},${range.high.y * Angle.degreesPerRadian}`;\n    }\n    static async getNationalMapSources() {\n        const sources = new Array();\n        const response = await fetch(\"https://viewer.nationalmap.gov/tnmaccess/api/getMapServiceList\", { method: \"GET\" });\n        const services = await response.json();\n        if (!Array.isArray(services))\n            return sources;\n        for (const service of services) {\n            if (service.wmsUrl.length === 0) // Exclude Wfs..\n                continue;\n            switch (service.serviceType) {\n                case \"ArcGIS\":\n                    sources.push(MapLayerSource.fromJSON({ name: service.displayName, url: service.serviceLink, formatId: \"ArcGIS\" }));\n                    break;\n                default: {\n                    const wmsIndex = service.wmsUrl.lastIndexOf(\"/wms\");\n                    if (wmsIndex > 0) {\n                        const url = service.wmsUrl.slice(0, wmsIndex + 4);\n                        sources.push(MapLayerSource.fromJSON({ name: service.displayName, url, formatId: \"WMS\" }));\n                    }\n                    break;\n                }\n            }\n        }\n        return sources;\n    }\n    static async getServiceDirectorySources(url, baseUrl) {\n        if (undefined === baseUrl)\n            baseUrl = url;\n        let sources = new Array();\n        const response = await fetch(`${url}?f=json`, { method: \"GET\" });\n        const json = await response.json();\n        if (json !== undefined) {\n            if (Array.isArray(json.folders)) {\n                for (const folder of json.folders) {\n                    sources = sources.concat(await ArcGisUtilities.getServiceDirectorySources(`${url}/${folder}`, url));\n                }\n            }\n            if (Array.isArray(json.services)) {\n                for (const service of json.services) {\n                    let source;\n                    if (service.type === \"MapServer\")\n                        source = MapLayerSource.fromJSON({ name: service.name, url: `${baseUrl}/${service.name}/MapServer`, formatId: \"ArcGIS\" });\n                    else if (service.type === \"ImageServer\")\n                        source = MapLayerSource.fromJSON({ name: service.name, url: `${baseUrl}/${service.name}/ImageServer`, formatId: \"ArcGIS\" });\n                    if (source)\n                        sources.push(source);\n                }\n            }\n        }\n        return sources;\n    }\n    static async getSourcesFromQuery(range, url = \"https://usgs.maps.arcgis.com/sharing/rest/search\") {\n        const sources = new Array();\n        for (let start = 1; start > 0;) {\n            const response = await fetch(`${url}?f=json&q=(group:9d1199a521334e77a7d15abbc29f8144) AND (type:\"Map Service\")&bbox=${ArcGisUtilities.getBBoxString(range)}&sortOrder=desc&start=${start}&num=100`, { method: \"GET\" });\n            const json = await response.json();\n            if (!json)\n                break;\n            start = json.nextStart ? json.nextStart : -1;\n            if (json !== undefined && Array.isArray(json.results)) {\n                for (const result of json.results) {\n                    const source = MapLayerSource.fromJSON({ name: result.name ? result.name : result.title, url: result.url, formatId: \"ArcGIS\" });\n                    if (source)\n                        sources.push(source);\n                }\n            }\n        }\n        return sources;\n    }\n    /**\n     * Parse the URL to check if it represent a valid ArcGIS service\n     * @param url URL to validate.\n     * @param serviceType Service type to validate (i.e FeatureServer, MapServer)\n     * @return Validation Status.\n    */\n    static validateUrl(url, serviceType) {\n        const urlObj = new URL(url.toLowerCase());\n        if (urlObj.pathname.includes(\"/rest/services/\")) {\n            // This seem to be an ArcGIS URL, lets check the service type\n            if (urlObj.pathname.endsWith(`${serviceType.toLowerCase()}`)) {\n                return MapLayerSourceStatus.Valid;\n            }\n            else {\n                return MapLayerSourceStatus.IncompatibleFormat;\n            }\n        }\n        else {\n            return MapLayerSourceStatus.InvalidUrl;\n        }\n    }\n    /**\n     * Attempt to access an ArcGIS service, and validate its service metadata.\n     * @param url URL of the source to validate.\n     * @param formatId Format Id of the source.\n     * @param capabilitiesFilter List of capabilities 'keyword' that needs to be advertised in the service's metadata\n     * in order to be valid.  For example: 'Map', 'Query', etc\n     * @param userName Username to use for legacy token based security.\n     * @param password Username to use for legacy token based security.\n     * @param ignoreCache Flag to skip cache lookup (i.e. force a new server request)\n     * @return Validation Status. If successful, a list of available sub-layers will also be returned.\n    */\n    static async validateSource(url, formatId, capabilitiesFilter, userName, password, ignoreCache) {\n        const metadata = await this.getServiceJson(url, formatId, userName, password, ignoreCache);\n        const json = metadata?.content;\n        if (json === undefined) {\n            return { status: MapLayerSourceStatus.InvalidUrl };\n        }\n        else if (json.error !== undefined) {\n            // If we got a 'Token Required' error, lets check what authentification methods this ESRI service offers\n            // and return information needed to initiate the authentification process... the end-user\n            // will have to provide his credentials before we can fully validate this source.\n            if (json.error.code === ArcGisErrorCode.TokenRequired) {\n                return { status: MapLayerSourceStatus.RequireAuth };\n            }\n            else if (json.error.code === ArcGisErrorCode.InvalidCredentials)\n                return { status: MapLayerSourceStatus.InvalidCredentials };\n        }\n        // Check this service support the expected queries\n        let hasCapabilities = false;\n        let capsArray = [];\n        if (json.capabilities && typeof json.capabilities === \"string\") {\n            const capabilities = json.capabilities;\n            capsArray = capabilities.split(\",\").map((entry) => entry.toLowerCase());\n            const filtered = capsArray.filter((element, _index, _array) => capabilitiesFilter.includes(element));\n            hasCapabilities = (filtered.length === capabilitiesFilter.length);\n        }\n        if (!hasCapabilities) {\n            return { status: MapLayerSourceStatus.InvalidFormat };\n        }\n        // Only EPSG:3857 is supported with pre-rendered tiles.\n        if (json.tileInfo && capsArray.includes(\"tilesonly\") && !ArcGisUtilities.isEpsg3857Compatible(json.tileInfo)) {\n            return { status: MapLayerSourceStatus.InvalidCoordinateSystem };\n        }\n        let subLayers;\n        if (json.layers) {\n            subLayers = new Array();\n            for (const layer of json.layers) {\n                const parent = layer.parentLayerId < 0 ? undefined : layer.parentLayerId;\n                const children = Array.isArray(layer.subLayerIds) ? layer.subLayerIds : undefined;\n                subLayers.push({ name: layer.name, visible: layer.defaultVisibility !== false, id: layer.id, parent, children });\n            }\n        }\n        return { status: MapLayerSourceStatus.Valid, subLayers };\n    }\n    /**\n     * Validate MapService tiling metadata and checks if the tile tree is 'Google Maps' compatible.\n    */\n    static isEpsg3857Compatible(tileInfo) {\n        if (tileInfo.spatialReference?.latestWkid !== 3857 || !Array.isArray(tileInfo.lods))\n            return false;\n        const zeroLod = tileInfo.lods[0];\n        return zeroLod.level === 0 && Math.abs(zeroLod.resolution - 156543.03392800014) < .001;\n    }\n    /**\n     * Fetch an ArcGIS service metadata, and returns its JSON representation.\n     * If an access client has been configured for the specified formatId,\n     * it will be used to apply required security token.\n     * By default, response for each URL are cached.\n    */\n    static async getServiceJson(url, formatId, userName, password, ignoreCache, requireToken) {\n        if (!ignoreCache) {\n            const cached = ArcGisUtilities._serviceCache.get(url);\n            if (cached !== undefined)\n                return cached;\n        }\n        let accessTokenRequired = false;\n        try {\n            let tmpUrl = new URL(url);\n            tmpUrl.searchParams.append(\"f\", \"json\");\n            // In some cases, caller might already know token is required, so append it immediately\n            if (requireToken) {\n                const accessClient = IModelApp.mapLayerFormatRegistry.getAccessClient(formatId);\n                if (accessClient) {\n                    accessTokenRequired = true;\n                    await ArcGisUtilities.appendSecurityToken(tmpUrl, accessClient, { mapLayerUrl: new URL(url), userName, password });\n                }\n            }\n            let response = await fetch(tmpUrl.toString(), { method: \"GET\" });\n            // Append security token when corresponding error code is returned by ArcGIS service\n            let errorCode = await ArcGisUtilities.checkForResponseErrorCode(response);\n            if (!accessTokenRequired\n                && errorCode !== undefined\n                && errorCode === ArcGisErrorCode.TokenRequired) {\n                accessTokenRequired = true;\n                // If token required\n                const accessClient = IModelApp.mapLayerFormatRegistry.getAccessClient(formatId);\n                if (accessClient) {\n                    tmpUrl = new URL(url);\n                    tmpUrl.searchParams.append(\"f\", \"json\");\n                    await ArcGisUtilities.appendSecurityToken(tmpUrl, accessClient, { mapLayerUrl: new URL(url), userName, password });\n                    response = await fetch(tmpUrl.toString(), { method: \"GET\" });\n                    errorCode = await ArcGisUtilities.checkForResponseErrorCode(response);\n                }\n            }\n            const json = await response.json();\n            const info = { content: json, accessTokenRequired };\n            // Cache the response only if it doesn't contain any error.\n            ArcGisUtilities._serviceCache.set(url, (errorCode === undefined ? info : undefined));\n            return info; // Always return json, even though it contains an error code.\n        }\n        catch (_error) {\n            ArcGisUtilities._serviceCache.set(url, undefined);\n            return undefined;\n        }\n    }\n    /** Read a response from ArcGIS server and check for error code in the response.\n    */\n    static async checkForResponseErrorCode(response) {\n        const tmpResponse = response;\n        if (response.headers && tmpResponse.headers.get(\"content-type\")?.toLowerCase().includes(\"json\")) {\n            try {\n                // Note:\n                // Since response stream can only be read once (i.e. calls to .json() method)\n                // we have to clone the response object in order to check for potential error code,\n                // but still keep the response stream as unread.\n                const clonedResponse = tmpResponse.clone();\n                const json = await clonedResponse.json();\n                if (json?.error?.code !== undefined)\n                    return json?.error?.code;\n            }\n            catch { }\n        }\n        return undefined;\n    }\n    // return the appended access token if available.\n    static async appendSecurityToken(url, accessClient, accessTokenParams) {\n        // Append security token if available\n        let accessToken;\n        try {\n            accessToken = await accessClient.getAccessToken(accessTokenParams);\n        }\n        catch { }\n        if (accessToken?.token) {\n            url.searchParams.append(\"token\", accessToken.token);\n            return accessToken;\n        }\n        return undefined;\n    }\n    /**\n     * Compute scale, resolution values for requested zoom levels (WSG 84)\n     * Use a scale of 96 dpi for Google Maps scales\n     * Based on this article: https://wiki.openstreetmap.org/wiki/Slippy_map_tilenames#Resolution_and_Scale\n     * @param startZoom Zoom level where scales begins to be computed\n     * @param endZoom Zoom level where scales ends to be computed\n     * @param latitude Latitude in degrees to use to compute scales (i.e 0 for Equator)\n     * @param tileSize Size of a tile in pixels (i.e 256)\n     * @param screenDpi Monitor resolution in dots per inch (i.e. typically 96dpi is used by Google Maps)\n     *\n    * @returns An array containing resolution and scale values for each requested zoom level\n     */\n    static computeZoomLevelsScales(startZoom = 0, endZoom = 20, latitude = 0, tileSize = 256, screenDpi = 96) {\n        // Note: There is probably a more direct way to compute this, but I prefer to go for a simple and well documented approach.\n        if (startZoom < 0 || endZoom < startZoom || tileSize < 0 || screenDpi < 1 || latitude < -90 || latitude > 90)\n            return [];\n        const inchPerMeter = 1 / 0.0254;\n        const results = [];\n        const equatorLength = Constant.earthRadiusWGS84.equator * 2 * Math.PI;\n        const zoom0Resolution = equatorLength / tileSize; // in meters per pixel\n        const cosLatitude = Math.cos(latitude);\n        for (let zoom = startZoom; zoom <= endZoom; zoom++) {\n            const resolution = zoom0Resolution * cosLatitude / Math.pow(2, zoom);\n            const scale = screenDpi * inchPerMeter * resolution;\n            results.push({ zoom, resolution, scale });\n        }\n        return results;\n    }\n    /**\n     * Match the provided minScale,maxScale values to corresponding wgs84 zoom levels\n     * @param defaultMaxLod Value of the last LOD (i.e 22)\n     * @param tileSize Size of a tile in pixels (i.e 256)\n     * @param minScale Minimum scale value that needs to be matched to a LOD level\n     * @param maxScale Maximum  scale value that needs to be matched to a LOD level\n    * @returns minLod: LOD value matching minScale,  maxLod: LOD value matching maxScale\n     */\n    static getZoomLevelsScales(defaultMaxLod, tileSize, minScale, maxScale, tolerance = 0) {\n        let minLod, maxLod;\n        const zoomScales = ArcGisUtilities.computeZoomLevelsScales(0, defaultMaxLod, 0 /* latitude 0 = Equator*/, tileSize);\n        if (zoomScales.length > 0) {\n            if (minScale) {\n                minLod = 0;\n                // We are looking for the largest scale value with a scale value smaller than minScale\n                for (; minLod < zoomScales.length && (zoomScales[minLod].scale > minScale && Math.abs(zoomScales[minLod].scale - minScale) > tolerance); minLod++)\n                    ;\n            }\n            if (maxScale) {\n                maxLod = defaultMaxLod;\n                // We are looking for the smallest scale value with a value greater than maxScale\n                for (; maxLod >= 0 && zoomScales[maxLod].scale < maxScale && Math.abs(zoomScales[maxLod].scale - maxScale) > tolerance; maxLod--)\n                    ;\n            }\n        }\n        return { minLod, maxLod };\n    }\n}\nArcGisUtilities._serviceCache = new Map();\nexport { ArcGisUtilities };\n//# sourceMappingURL=ArcGisUtilities.js.map",
      "start": 1693508121676,
      "end": 1693508121827,
      "sourcemaps": null
    }
  ]
}
