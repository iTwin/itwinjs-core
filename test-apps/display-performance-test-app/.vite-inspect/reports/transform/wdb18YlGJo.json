{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tile/map/EllipsoidTerrainProvider.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tiles\n */\nimport { assert } from \"@itwin/core-bentley\";\nimport { Angle, Ellipsoid, EllipsoidPatch, Point2d, Point3d, Range1d, Range3d, Transform } from \"@itwin/core-geometry\";\nimport { RealityMeshParamsBuilder } from \"../../render/RealityMeshParams\";\nimport { TerrainMeshProvider, WebMercatorTilingScheme, } from \"../internal\";\nconst scratchPoint2d = Point2d.createZero();\nconst scratchPoint = Point3d.createZero();\nconst scratchEllipsoid = Ellipsoid.create(Transform.createIdentity());\nconst scratchZeroRange = Range1d.createXX(0, 0);\n/** A terrain mesh provider that produces geometry that represents a smooth ellipsoid without any height perturbations.\n * The area within the project extents are represented as planar tiles and other tiles are facetted approximations\n * of the WGS84 ellipsoid.\n * This is the terrain provider used when the background map is enabled but 3d terrain is disabled.\n * @public\n */\nexport class EllipsoidTerrainProvider extends TerrainMeshProvider {\n    /** Construct a new terrain provider.\n     * @note [[TerrainMeshProviderOptions.wantNormals]] is ignored - no normals are produced.\n     */\n    constructor(opts) {\n        super();\n        this._tilingScheme = new WebMercatorTilingScheme();\n        this._wantSkirts = opts.wantSkirts;\n    }\n    /** Implements [[TerrainMeshProvider.maxDepth]] to return a fixed maximum depth of 22. */\n    get maxDepth() { return 22; }\n    /** Implements [[TerrainMeshProvider.getChildHeightRange]] to return an empty range, because the ellipsoid is smooth. */\n    getChildHeightRange(_quadId, _rectangle, _parent) {\n        return scratchZeroRange;\n    }\n    /** Implements [[TerrainMeshProvider.tilingScheme]]. */\n    get tilingScheme() {\n        return this._tilingScheme;\n    }\n    createSkirtlessPlanarMesh(tile) {\n        const projection = tile.getProjection();\n        const builder = new RealityMeshParamsBuilder({\n            positionRange: projection.localRange,\n            initialVertexCapacity: 4,\n            initialIndexCapacity: 6,\n        });\n        const uv = new Point2d();\n        const pos = new Point3d();\n        for (let v = 0; v < 2; v++) {\n            for (let u = 0; u < 2; u++) {\n                Point2d.create(u, 1 - v, uv);\n                builder.addUnquantizedVertex(projection.getPoint(u, v, 0, pos), uv);\n            }\n        }\n        builder.addQuad(0, 1, 2, 3);\n        return builder.finish();\n    }\n    createSkirtedPlanarMesh(tile) {\n        const projection = tile.getProjection();\n        const positions = [];\n        const uvs = [];\n        const skirtHeight = tile.range.xLength() / 20;\n        for (let v = 0, i = 0; v < 2; v++) {\n            for (let u = 0; u < 2; u++) {\n                for (let h = 0; h < 2; h++) {\n                    positions.push(projection.getPoint(u, v, h * skirtHeight));\n                    uvs[i] = new Point2d(u, 1 - v);\n                    i++;\n                }\n            }\n        }\n        const builder = new RealityMeshParamsBuilder({\n            initialVertexCapacity: 8,\n            initialIndexCapacity: 30,\n            positionRange: Range3d.createArray(positions),\n        });\n        for (let i = 0; i < 8; i++)\n            builder.addUnquantizedVertex(positions[i], uvs[i]);\n        builder.addQuad(0, 2, 4, 6);\n        const reorder = [0, 2, 6, 4, 0];\n        for (let i = 0; i < 4; i++) {\n            const iThis = reorder[i], iNext = reorder[i + 1];\n            builder.addQuad(iThis, iNext, iThis + 1, iNext + 1);\n        }\n        return builder.finish();\n    }\n    /** @internal override */\n    async readMesh(args) {\n        const tile = args.tile;\n        if (tile.isPlanar)\n            return this._wantSkirts ? this.createSkirtedPlanarMesh(tile) : this.createSkirtlessPlanarMesh(tile);\n        return this.createGlobeMesh(tile);\n    }\n    createGlobeMesh(tile) {\n        const globeMeshDimension = 10;\n        const projection = tile.getProjection();\n        const ellipsoidPatch = projection.ellipsoidPatch;\n        assert(undefined !== ellipsoidPatch);\n        if (!ellipsoidPatch)\n            return undefined;\n        const bordersSouthPole = tile.quadId.bordersSouthPole(this._tilingScheme);\n        const bordersNorthPole = tile.quadId.bordersNorthPole(this._tilingScheme);\n        const range = projection.localRange.clone();\n        const delta = 1 / (globeMeshDimension - 3);\n        const skirtFraction = delta / 2;\n        const dimensionM1 = globeMeshDimension - 1;\n        const dimensionM2 = globeMeshDimension - 2;\n        ellipsoidPatch.ellipsoid.transformRef.clone(scratchEllipsoid.transformRef);\n        const skirtPatch = EllipsoidPatch.createCapture(scratchEllipsoid, ellipsoidPatch.longitudeSweep, ellipsoidPatch.latitudeSweep);\n        const scaleFactor = Math.max(0.99, 1 - Math.sin(ellipsoidPatch.longitudeSweep.sweepRadians * delta));\n        skirtPatch.ellipsoid.transformRef.matrix.scaleColumnsInPlace(scaleFactor, scaleFactor, scaleFactor);\n        const pointCount = globeMeshDimension * globeMeshDimension;\n        const rowMin = (bordersNorthPole || this._wantSkirts) ? 0 : 1;\n        const rowMax = (bordersSouthPole || this._wantSkirts) ? dimensionM1 : dimensionM2;\n        const colMin = this._wantSkirts ? 0 : 1;\n        const colMax = this._wantSkirts ? dimensionM1 : dimensionM2;\n        const indexCount = 6 * (rowMax - rowMin) * (colMax - colMin);\n        const builder = new RealityMeshParamsBuilder({\n            positionRange: range,\n            initialVertexCapacity: pointCount,\n            initialIndexCapacity: indexCount,\n        });\n        for (let iRow = 0, index = 0; iRow < globeMeshDimension; iRow++) {\n            for (let iColumn = 0; iColumn < globeMeshDimension; iColumn++, index++) {\n                let u = (iColumn ? (Math.min(dimensionM2, iColumn) - 1) : 0) * delta;\n                let v = (iRow ? (Math.min(dimensionM2, iRow) - 1) : 0) * delta;\n                scratchPoint2d.set(u, 1 - v);\n                if (iRow === 0 || iRow === dimensionM1 || iColumn === 0 || iColumn === dimensionM1) {\n                    if (bordersSouthPole && iRow === dimensionM1)\n                        skirtPatch.ellipsoid.radiansToPoint(0, -Angle.piOver2Radians, scratchPoint);\n                    else if (bordersNorthPole && iRow === 0)\n                        skirtPatch.ellipsoid.radiansToPoint(0, Angle.piOver2Radians, scratchPoint);\n                    else {\n                        u += (iColumn === 0) ? -skirtFraction : (iColumn === dimensionM1 ? skirtFraction : 0);\n                        v += (iRow === 0) ? -skirtFraction : (iRow === dimensionM1 ? skirtFraction : 0);\n                        skirtPatch.uvFractionToPoint(u, v, scratchPoint);\n                    }\n                }\n                else {\n                    projection.getPoint(u, v, 0, scratchPoint);\n                }\n                builder.addUnquantizedVertex(scratchPoint, scratchPoint2d);\n            }\n        }\n        for (let iRow = rowMin; iRow < rowMax; iRow++) {\n            for (let iColumn = colMin; iColumn < colMax; iColumn++) {\n                const base = iRow * globeMeshDimension + iColumn;\n                const top = base + globeMeshDimension;\n                builder.addTriangle(base, base + 1, top);\n                builder.addTriangle(top, base + 1, top + 1);\n            }\n        }\n        return builder.finish();\n    }\n    /** Implements [[TerrainMeshProvider.requestMeshData]] to return an empty string because the mesh can be generated\n     * purely from information provided by the [[MapTile]].\n     */\n    async requestMeshData() {\n        return \"\";\n    }\n}\n//# sourceMappingURL=EllipsoidTerrainProvider.js.map",
      "start": 1693508121853,
      "end": 1693508121962,
      "sourcemaps": null
    }
  ]
}
