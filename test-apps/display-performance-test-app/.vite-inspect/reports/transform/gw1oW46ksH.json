{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/common/lib/esm/OctEncodedNormal.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Rendering\n */\nimport { Vector3d } from \"@itwin/core-geometry\";\nconst scratchUInt16 = new Uint16Array(1);\nfunction clamp(val, minVal, maxVal) {\n    return val < minVal ? minVal : (val > maxVal ? maxVal : val);\n}\nfunction clampUint8(val) {\n    return roundUint16(0.5 + (clamp(val, -1, 1) * 0.5 + 0.5) * 255);\n}\nfunction roundUint16(val) {\n    scratchUInt16[0] = val;\n    return scratchUInt16[0];\n}\nfunction signNotZero(val) {\n    return val < 0.0 ? -1.0 : 1.0;\n}\n/** Represents a 3d normal vector compressed into a single 16-bit integer using [oct-encoding](http://jcgt.org/published/0003/02/01/paper.pdf).\n * These are chiefly used to reduce the space required to store normal vectors for [RenderGraphic]($frontend)s.\n * @public\n */\nexport class OctEncodedNormal {\n    /** Construct directly from a 16-bit encoded value.\n     * @see [[encode]] to compute the encoded value.\n     * @see [[fromVector]] to construct from a vector.\n     */\n    constructor(val) {\n        this.value = roundUint16(val);\n    }\n    /** Compute the encoded 16-bit value of the supplied normalized vector. */\n    static encode(vec) {\n        return this.encodeXYZ(vec.x, vec.y, vec.z);\n    }\n    /** Compute the encoded 16-bit value of the supplied normalized vector components. */\n    static encodeXYZ(nx, ny, nz) {\n        const denom = Math.abs(nx) + Math.abs(ny) + Math.abs(nz);\n        let rx = nx / denom;\n        let ry = ny / denom;\n        if (nz < 0) {\n            const x = rx;\n            const y = ry;\n            rx = (1 - Math.abs(y)) * signNotZero(x);\n            ry = (1 - Math.abs(x)) * signNotZero(y);\n        }\n        return clampUint8(ry) << 8 | clampUint8(rx);\n    }\n    /** Create an OctEncodedNormal from a normalized vector. */\n    static fromVector(val) {\n        return new OctEncodedNormal(this.encode(val));\n    }\n    /** Decode this oct-encoded normal into a normalized vector. */\n    decode() {\n        return OctEncodedNormal.decodeValue(this.value);\n    }\n    /** Decode a 16-bit encoded value into a normalized vector. */\n    static decodeValue(val, result) {\n        let ex = val & 0xff;\n        let ey = val >> 8;\n        ex = ex / 255.0 * 2.0 - 1.0;\n        ey = ey / 255.0 * 2.0 - 1.0;\n        const ez = 1 - (Math.abs(ex) + Math.abs(ey));\n        let n;\n        if (result === undefined) {\n            n = new Vector3d(ex, ey, ez);\n        }\n        else {\n            n = result;\n            n.x = ex;\n            n.y = ey;\n            n.z = ez;\n        }\n        if (n.z < 0) {\n            const x = n.x;\n            const y = n.y;\n            n.x = (1 - Math.abs(y)) * signNotZero(x);\n            n.y = (1 - Math.abs(x)) * signNotZero(y);\n        }\n        n.normalizeInPlace();\n        return n;\n    }\n}\n/** @internal */\nexport class OctEncodedNormalPair {\n    constructor(first, second) {\n        this.first = first;\n        this.second = second;\n    }\n}\n//# sourceMappingURL=OctEncodedNormal.js.map",
      "start": 1693508120712,
      "end": 1693508120761,
      "sourcemaps": null
    }
  ]
}
