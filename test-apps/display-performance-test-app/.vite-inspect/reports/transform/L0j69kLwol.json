{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/Polyline.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { dispose } from \"@itwin/core-bentley\";\nimport { FeatureIndexType, PolylineTypeFlags, RenderMode } from \"@itwin/core-common\";\nimport { RenderMemory } from \"../RenderMemory\";\nimport { LUTGeometry, PolylineBuffers } from \"./CachedGeometry\";\nimport { LineCode } from \"./LineCode\";\nimport { GL } from \"./GL\";\nimport { System } from \"./System\";\nimport { VertexLUT } from \"./VertexLUT\";\n/** @internal */\nexport class PolylineGeometry extends LUTGeometry {\n    get lutBuffers() { return this._buffers.buffers; }\n    constructor(lut, buffers, params, viOrigin) {\n        super(viOrigin);\n        this.vertexParams = params.vertices.qparams;\n        this._hasFeatures = FeatureIndexType.Empty !== params.vertices.featureIndexType;\n        this.lineWeight = params.weight;\n        this.lineCode = LineCode.valueFromLinePixels(params.linePixels);\n        this.type = params.type;\n        this._isPlanar = params.isPlanar;\n        this.lut = lut;\n        this.numIndices = params.polyline.indices.length;\n        this._buffers = buffers;\n    }\n    get isDisposed() { return this._buffers.isDisposed && this.lut.isDisposed; }\n    dispose() {\n        dispose(this.lut);\n        dispose(this._buffers);\n    }\n    collectStatistics(stats) {\n        this._buffers.collectStatistics(stats, RenderMemory.BufferType.Polylines);\n        stats.addVertexTable(this.lut.bytesUsed);\n    }\n    get isAnyEdge() { return PolylineTypeFlags.Normal !== this.type; }\n    get isNormalEdge() { return PolylineTypeFlags.Edge === this.type; }\n    get isOutlineEdge() { return PolylineTypeFlags.Outline === this.type; }\n    get renderOrder() {\n        if (this.isAnyEdge)\n            return this.isPlanar ? 14 /* RenderOrder.PlanarEdge */ : 6 /* RenderOrder.Edge */;\n        else\n            return this.isPlanar ? 13 /* RenderOrder.PlanarLinear */ : 5 /* RenderOrder.Linear */;\n    }\n    _wantWoWReversal(_target) { return true; }\n    get polylineBuffers() { return this._buffers; }\n    _computeEdgePass(target, colorInfo) {\n        const vf = target.currentViewFlags;\n        if (RenderMode.SmoothShade === vf.renderMode && !vf.visibleEdges)\n            return \"none\";\n        // Only want to return Translucent for edges if rendering in Wireframe mode ###TODO: what about overrides?\n        const isTranslucent = RenderMode.Wireframe === vf.renderMode && vf.transparency && colorInfo.hasTranslucency;\n        return isTranslucent ? \"translucent\" : \"opaque-linear\";\n    }\n    getPass(target) {\n        const vf = target.currentViewFlags;\n        if (this.isEdge) {\n            let pass = this._computeEdgePass(target, this.lut.colorInfo);\n            // Only display the outline in wireframe if Fill is off...\n            if (\"none\" !== pass && this.isOutlineEdge && RenderMode.Wireframe === vf.renderMode && vf.fill)\n                pass = \"none\";\n            return pass;\n        }\n        const isTranslucent = vf.transparency && this.lut.colorInfo.hasTranslucency;\n        return isTranslucent ? \"translucent\" : \"opaque-linear\";\n    }\n    get techniqueId() { return 1 /* TechniqueId.Polyline */; }\n    get isPlanar() { return this._isPlanar; }\n    get isEdge() { return this.isAnyEdge; }\n    get qOrigin() { return this.lut.qOrigin; }\n    get qScale() { return this.lut.qScale; }\n    get numRgbaPerVertex() { return this.lut.numRgbaPerVertex; }\n    get hasFeatures() { return this._hasFeatures; }\n    _getLineWeight(params) {\n        return this.isEdge ? params.target.computeEdgeWeight(params.renderPass, this.lineWeight) : this.lineWeight;\n    }\n    _getLineCode(params) {\n        return this.isEdge ? params.target.computeEdgeLineCode(params.renderPass, this.lineCode) : this.lineCode;\n    }\n    getColor(target) {\n        return this.isEdge ? target.computeEdgeColor(this.lut.colorInfo) : this.lut.colorInfo;\n    }\n    _draw(numInstances, instanceBuffersContainer) {\n        const gl = System.instance;\n        const bufs = instanceBuffersContainer !== undefined ? instanceBuffersContainer : this._buffers.buffers;\n        bufs.bind();\n        gl.drawArrays(GL.PrimitiveType.Triangles, 0, this.numIndices, numInstances);\n        bufs.unbind();\n    }\n    static create(params, viewIndependentOrigin) {\n        const lut = VertexLUT.createFromVertexTable(params.vertices);\n        if (undefined === lut)\n            return undefined;\n        const buffers = PolylineBuffers.create(params.polyline);\n        if (undefined === buffers)\n            return undefined;\n        return new PolylineGeometry(lut, buffers, params, viewIndependentOrigin);\n    }\n}\n//# sourceMappingURL=Polyline.js.map",
      "start": 1693508123646,
      "end": 1693508123732,
      "sourcemaps": null
    }
  ]
}
