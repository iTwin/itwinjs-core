{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/orbitgt/lib/esm/spatial/ecrs/Operation.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module OrbitGT\n */\nimport { AList } from \"../../system/collection/AList\";\nimport { Numbers } from \"../../system/runtime/Numbers\";\nimport { Strings } from \"../../system/runtime/Strings\";\nimport { Registry } from \"./Registry\";\n/**\n * Class Operation defines an coordinate operation. The operation defines a specific method,\n * together with specific values for the parameters of the method, and a specific source and\n * destination coordinate reference system.\n *\n * 'Conversions' are operations that convert from projected systems to and from geographic systems (same datum).\n * 'Transformations' are Operations that convert from one geocentric system to another (different datum).\n *\n * @version 1.0 July 2005\n */\n/** @internal */\nclass Operation {\n    /**\n     * Create a new coordinate operation.\n     * @param code the code.\n     * @param name the name.\n     * @param type the type (CONCATENATED, CONVERSION or TRANSFORMATION).\n     * @param sourceCRScode the code of the source CRS.\n     * @param targetCRScode the code of the target CRS.\n     * @param areaOfUse the area on which the operation has been defined (0 if unknown).\n     * @param method the method (null for concatenated operations).\n     */\n    constructor(code, name, type, sourceCRScode, targetCRScode, areaOfUse, method) {\n        /* Store the parameters */\n        this._code = code;\n        this._name = name;\n        this._type = type;\n        this._sourceCRScode = sourceCRScode;\n        this._targetCRScode = targetCRScode;\n        this._areaOfUse = areaOfUse;\n        this._method = method;\n        /* Clear */\n        this._initialised = false;\n        this._sourceCRS = null;\n        this._targetCRS = null;\n        this._concatenatedOperations = null;\n    }\n    /**\n     * Get the code.\n     * @return the code.\n     */\n    getCode() {\n        return this._code;\n    }\n    /**\n     * Get the name.\n     * @return the name.\n     */\n    getName() {\n        return this._name;\n    }\n    /**\n     * Get the type (CONCATENATED, CONVERSION or TRANSFORMATION).\n     * @return the type.\n     */\n    getType() {\n        return this._type;\n    }\n    /**\n     * Get the code of the source CRS.\n     * @return the code of the source CRS.\n     */\n    getSourceCRScode() {\n        return this._sourceCRScode;\n    }\n    /**\n     * Get the code of the target CRS.\n     * @return the code of the target CRS.\n     */\n    getTargetCRScode() {\n        return this._targetCRScode;\n    }\n    /**\n     * Get the area on which the operation has been defined.\n     * @return the area on which the operation has been defined (0 if unknown).\n     */\n    getAreaOfUse() {\n        return this._areaOfUse;\n    }\n    /**\n     * Get the method (null for concatenated operations).\n     * @return the method.\n     */\n    getMethod() {\n        return this._method;\n    }\n    /**\n     * Set the method.\n     * @param method the new method (null for concatenated operations).\n     */\n    setMethod(method) {\n        this._method = method;\n    }\n    /**\n     * Get the concatenated operations.\n     * @return the concatenated operations (null for a method).\n     */\n    getConcatenatedOperations() {\n        return this._concatenatedOperations;\n    }\n    /**\n     * Set the concatenated operations.\n     * @param concatenatedOperations the concatenated operations (null for a method).\n     */\n    setConcatenatedOperations(concatenatedOperations) {\n        this._concatenatedOperations = concatenatedOperations;\n    }\n    /**\n     * Initialise the operation.\n     */\n    initialise() {\n        /* Initialize the systems */\n        if (this._sourceCRS == null)\n            this._sourceCRS = Registry.getCRS(this._sourceCRScode);\n        if (this._targetCRS == null)\n            this._targetCRS = Registry.getCRS(this._targetCRScode);\n        /* Already done ? */\n        if (this._initialised)\n            return;\n        this._initialised = true;\n        /* Concatenated operations ? */\n        if (this._type == Operation.CONCATENATED) {\n            /* Create the list of operations */\n            this._concatenatedOperations = new AList(); //Registry.readConcatenatedOperations(this.code);\n        }\n        else {\n            /* Initialise the method ? */\n            this._method.initialize(this);\n        }\n    }\n    /**\n     * Get the source CRS.\n     * @return the source CRS.\n     */\n    getSourceCRS() {\n        if (this._sourceCRS == null)\n            this.initialise();\n        return this._sourceCRS;\n    }\n    /**\n     * Set the source CRS.\n     * @param sourceCRS the source CRS.\n     */\n    setSourceCRS(sourceCRS) {\n        this._sourceCRS = sourceCRS;\n    }\n    /**\n     * Get the target CRS.\n     * @return the target CRS.\n     */\n    getTargetCRS() {\n        if (this._targetCRS == null)\n            this.initialise();\n        return this._targetCRS;\n    }\n    /**\n     * Set the target CRS.\n     * @param targetCRS the target CRS.\n     */\n    setTargetCRS(targetCRS) {\n        this._targetCRS = targetCRS;\n    }\n    /**\n     * Convert a source coordinate to a target coordinate.\n     * @param source the coordinates in the source CRS.\n     * @param target the coordinates in the target CRS (this is the result object).\n     */\n    forward(source, target) {\n        this.initialise();\n        /* Concatenated operations ? */\n        if (this._type == Operation.CONCATENATED) {\n            /* Run all operations */\n            for (let i = 0; i < this._concatenatedOperations.size(); i++) {\n                this._concatenatedOperations.get(i).forward(source, target);\n                source = target;\n            }\n        }\n        else {\n            /* Let the method do it */\n            this._method.forward(this._sourceCRS, source, this._targetCRS, target);\n        }\n    }\n    /**\n     * Convert a target coordinate to a source coordinate.\n     * @param source the coordinates in the source CRS (this is the result object).\n     * @param target the coordinates in the target CRS.\n     */\n    reverse(source, target) {\n        this.initialise();\n        /* Concatenated operations ? */\n        if (this._type == Operation.CONCATENATED) {\n            /* Run all operations */\n            for (let i = 0; i < this._concatenatedOperations.size(); i++) {\n                this._concatenatedOperations.get(this._concatenatedOperations.size() - 1 - i).reverse(source, target);\n                target = source;\n            }\n        }\n        else {\n            /* Let the method do it */\n            this._method.reverse(this._sourceCRS, source, this._targetCRS, target);\n        }\n    }\n    /**\n     * Check if another operation is compatible with this one.\n     * @param other the other operation.\n     * @return true if compatible.\n     */\n    isCompatible(other) {\n        if (other._code == this._code)\n            return true; // all operations should have unique identifiers\n        if (other._type != this._type)\n            return false;\n        if (other._sourceCRScode != this._sourceCRScode)\n            return false;\n        if (other._targetCRScode != this._targetCRScode)\n            return false;\n        if (other._method.isCompatible(this._method) == false)\n            return false;\n        if (Operation.areCompatibleOperations(other._concatenatedOperations, this._concatenatedOperations) == false)\n            return false;\n        return true;\n    }\n    /**\n     * Check if two operations are compatible.\n     * @param operation1 the first operation.\n     * @param operation2 the second operation.\n     * @return true if compatible.\n     */\n    static isCompatibleOperation(operation1, operation2) {\n        if (operation1 == null)\n            return (operation2 == null);\n        if (operation2 == null)\n            return false;\n        return (operation1.isCompatible(operation2));\n    }\n    /**\n     * Check if a list of operations is compatible with another one.\n     * @param list1 the first list.\n     * @param list2 the second list.\n     * @return true if compatible.\n     */\n    static areCompatibleOperations(list1, list2) {\n        if (list1 == null)\n            return (list2 == null);\n        if (list2 == null)\n            return false;\n        if (list2.size() != list1.size())\n            return false;\n        for (let i = 0; i < list2.size(); i++)\n            if (list2.get(i).isCompatible(list1.get(i)) == false)\n                return false;\n        return true;\n    }\n    /**\n     * The standard toString method.\n     * @see Object#toString\n     */\n    toString() {\n        return \"[Operation:code=\" + this._code + \",name='\" + this._name + \"',type=\" + this._type + \",sourceCRS=\" + this._sourceCRScode + \",targetCRS=\" + this._targetCRScode + \",area=\" + this._areaOfUse + \",method=\" + this._method + \"]\";\n    }\n    /**\n     * Find an operation by name.\n     * @param operations the list of operations.\n     * @param name the name of the operation.\n     * @return the index of the operation.\n     */\n    static findByName(operations, name) {\n        /* No list ? */\n        if (operations == null)\n            return -1;\n        /* Check */\n        for (let i = 0; i < operations.length; i++)\n            if (Strings.equalsIgnoreCase(operations[i].getName(), name))\n                return i;\n        /* Not found */\n        return -1;\n    }\n    /**\n     * Get the version of a transformation.\n     * @param transformationName the name of the transformation.\n     * @return the version (0 if not found).\n     */\n    static getTransformationVersion(transformationName) {\n        /* Find the (...) sequence */\n        let index0 = Strings.lastIndexOf(transformationName, \"(\");\n        if (index0 < 0)\n            return 0;\n        let index1 = Strings.lastIndexOf(transformationName, \")\");\n        if ((index1 < 0) || (index1 < index0))\n            return 0;\n        /* Parse the version */\n        let version = Strings.substring(transformationName, index0 + 1, index1);\n        return Numbers.getInteger(version, 0);\n    }\n    /**\n     * Get the latest transform from a set of transformations.\n     * @param transformations the set of transformations.\n     * @return the latest transform.\n     */\n    static getLatestTransformation(transformations) {\n        /* We need at least two transforms */\n        if (transformations == null)\n            return null;\n        if (transformations.size() == 0)\n            return null;\n        if (transformations.size() == 1)\n            return transformations.get(0);\n        /* Start with the first transform */\n        let bestIndex = 0;\n        let bestVersion = Operation.getTransformationVersion(transformations.get(bestIndex).getName());\n        /* Check for better versions */\n        for (let i = 1; i < transformations.size(); i++) {\n            /* Check */\n            let version = Operation.getTransformationVersion(transformations.get(i).getName());\n            if (version > bestVersion) {\n                /* This one is later */\n                bestIndex = i;\n                bestVersion = version;\n            }\n        }\n        /* Return the best transform */\n        return transformations.get(bestIndex);\n    }\n}\n/** The type of a concatenated operation */\nOperation.CONCATENATED = 1;\n/** The type of a conversion operation (projected to geographic) */\nOperation.CONVERSION = 2;\n/** The type of a transformation operation (geocentric to geocentric) */\nOperation.TRANSFORMATION = 3;\nexport { Operation };\n//# sourceMappingURL=Operation.js.map",
      "start": 1693508125616,
      "end": 1693508125654,
      "sourcemaps": null
    }
  ]
}
