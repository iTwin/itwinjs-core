{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/curve/Query/InOutTests.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Curve\n */\nimport { Geometry } from \"../../Geometry\";\nimport { Angle } from \"../../geometry3d/Angle\";\nimport { Plane3dByOriginAndUnitNormal } from \"../../geometry3d/Plane3dByOriginAndUnitNormal\";\nimport { Point3d } from \"../../geometry3d/Point3dVector3d\";\nimport { CurveIntervalRole } from \"../CurveLocationDetail\";\nimport { CurvePrimitive } from \"../CurvePrimitive\";\nimport { Loop } from \"../Loop\";\nimport { ParityRegion } from \"../ParityRegion\";\nimport { UnionRegion } from \"../UnionRegion\";\n/**\n * Context for testing containment in Loop, ParityRegion and UnionRegion.\n * @internal\n */\nexport class PointInOnOutContext {\n    /**\n     * In-out test for a single loop.\n     * * Test by finding intersections with an xy line (xyz plane) in \"some\" direction.\n     * * Test logic gets complicated if the plane has a vertex hit.\n     * * If that happens, don't try to figure out the cases.   Just move on to another plane.\n     * * Any \"on\" point triggers immediate 0 return.\n     *   * (Hence if there are overlapping lines their self-canceling effect might be wrong.)\n     * @param loop\n     * @param x tested x coordinate\n     * @param y tested y coordinate\n     */\n    static testPointInOnOutLoopXY(loop, x, y) {\n        let plane;\n        const xy = Point3d.create(x, y);\n        for (let radians = 0.0; Math.abs(radians) < 6.0; radians = -1.2313 * (radians + 0.3212897)) {\n            plane = Plane3dByOriginAndUnitNormal.createXYAngle(x, y, Angle.createRadians(radians));\n            const normal = plane.getNormalRef();\n            const intersections = [];\n            for (const cp of loop.children) {\n                if (cp instanceof CurvePrimitive)\n                    cp.appendPlaneIntersectionPoints(plane, intersections);\n            }\n            CurvePrimitive.snapAndRestrictDetails(intersections, false, true);\n            let numLeft = 0;\n            let numRight = 0;\n            let numTricky = 0;\n            let wx, wy;\n            // Count simple crossings to left and right.\n            // Also count tricky crossings (vertex hits, onEdge)\n            // If there are any tricky ones, go around with a different plane.\n            // A intently devious tester could make every plane hit tricky things.\n            for (const intersection of intersections) {\n                if (intersection.intervalRole !== CurveIntervalRole.isolated\n                    && intersection.intervalRole !== undefined) {\n                    numTricky++;\n                }\n                wx = intersection.point.x - x;\n                wy = intersection.point.y - y;\n                if (Geometry.isSameCoordinateXY(wx, wy, 0, 0))\n                    return 0;\n                const cross = Geometry.crossProductXYXY(normal.x, normal.y, wx, wy);\n                if (xy.isAlmostEqualXY(intersection.point))\n                    return 0;\n                if (cross < 0.0)\n                    numLeft++;\n                else if (cross > 0.0)\n                    numRight++;\n            }\n            if (numTricky !== 0) // try another angle !!\n                continue;\n            const leftParity = numLeft & (0x01);\n            const rightParity = numRight & (0x01);\n            if (leftParity === rightParity)\n                return leftParity === 1 ? 1 : -1;\n        }\n        return -1;\n    }\n    /**\n     * strongly-typed parity region handling: XOR of all loops. (But any ON is returned as edge hit.)\n     * @param parent\n     * @param x\n     * @param y\n     */\n    static testPointInOnOutParityRegionXY(parent, x, y) {\n        let result = -1;\n        for (const loop of parent.children) {\n            if (loop instanceof Loop) {\n                const q = this.testPointInOnOutLoopXY(loop, x, y);\n                if (q === 0)\n                    return 0;\n                if (q > 0)\n                    result = -result;\n            }\n        }\n        return result;\n    }\n    static testPointInOnOutUnionRegionXY(parent, x, y) {\n        for (const loop of parent.children) {\n            const classify = this.testPointInOnOutRegionXY(loop, x, y);\n            if (classify >= 0)\n                return classify;\n        }\n        return -1;\n    }\n    static testPointInOnOutRegionXY(parent, x, y) {\n        if (parent instanceof Loop)\n            return this.testPointInOnOutLoopXY(parent, x, y);\n        else if (parent instanceof ParityRegion)\n            return this.testPointInOnOutParityRegionXY(parent, x, y);\n        else if (parent instanceof UnionRegion)\n            return this.testPointInOnOutUnionRegionXY(parent, x, y);\n        return -1;\n    }\n}\n//# sourceMappingURL=InOutTests.js.map",
      "start": 1693508124193,
      "end": 1693508124331,
      "sourcemaps": null
    }
  ]
}
