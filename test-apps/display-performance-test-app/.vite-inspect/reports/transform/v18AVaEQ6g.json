{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/bspline/BSplineCurve3dH.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Serialization\n */\nimport { CurvePrimitive } from \"../curve/CurvePrimitive\";\nimport { StrokeCountMap } from \"../curve/Query/StrokeCountMap\";\nimport { Geometry } from \"../Geometry\";\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\nimport { Point3dArray, Point4dArray } from \"../geometry3d/PointHelpers\";\nimport { Point4d } from \"../geometry4d/Point4d\";\nimport { BezierCurve3dH } from \"./BezierCurve3dH\";\nimport { BSplineCurve3dBase } from \"./BSplineCurve\";\nimport { KnotVector } from \"./KnotVector\";\n/**\n * Weighted (Homogeneous) BSplineCurve in 3d\n * @public\n */\nexport class BSplineCurve3dH extends BSplineCurve3dBase {\n    initializeWorkBezier() {\n        if (this._workBezier === undefined)\n            this._workBezier = BezierCurve3dH.createOrder(this.order);\n        return this._workBezier;\n    }\n    /** Test if `other` is an instance of `BSplineCurve3dH` */\n    isSameGeometryClass(other) { return other instanceof BSplineCurve3dH; }\n    /** Apply `transform` to the curve */\n    tryTransformInPlace(transform) { Point4dArray.multiplyInPlace(transform, this._bcurve.packedData); return true; }\n    /** Get a pole, normalized to Point3d. */\n    getPolePoint3d(poleIndex, result) {\n        const k = this.poleIndexToDataIndex(poleIndex);\n        if (k !== undefined) {\n            const data = this._bcurve.packedData;\n            const divW = Geometry.conditionalDivideFraction(1.0, data[k + 3]);\n            if (divW !== undefined)\n                return Point3d.create(data[k] * divW, data[k + 1] * divW, data[k + 2] * divW, result);\n        }\n        return undefined;\n    }\n    /** Get a pole as Point4d */\n    getPolePoint4d(poleIndex, result) {\n        const k = this.poleIndexToDataIndex(poleIndex);\n        if (k !== undefined) {\n            const data = this._bcurve.packedData;\n            return Point4d.create(data[k], data[k + 1], data[k + 2], data[k + 3], result);\n        }\n        return undefined;\n    }\n    /** map a spanIndex and fraction to a knot value. */\n    spanFractionToKnot(span, localFraction) {\n        return this._bcurve.spanFractionToKnot(span, localFraction);\n    }\n    constructor(numPoles, order, knots) {\n        super(4, numPoles, order, knots);\n    }\n    /** Return a simple array of arrays with the control points as `[[x,y,z,w],[x,y,z,w],..]` */\n    copyPoints() { return Point3dArray.unpackNumbersToNestedArrays(this._bcurve.packedData, 4); }\n    /** Return a simple array of the control points coordinates */\n    copyPointsFloat64Array() { return this._bcurve.packedData.slice(); }\n    /** Return a simple array of the control points xyz coordinates.  */\n    copyXYZFloat64Array(deweighted) {\n        const numValue = this.numPoles * 3;\n        const result = new Float64Array(numValue);\n        let k = 0;\n        for (let poleIndex = 0; poleIndex < this.numPoles; poleIndex++) {\n            let i = poleIndex * 4;\n            if (deweighted) {\n                const w = this._bcurve.packedData[i + 3];\n                const dw = w === 0.0 ? 1.0 : 1.0 / w;\n                result[k++] = this._bcurve.packedData[i++] * dw;\n                result[k++] = this._bcurve.packedData[i++] * dw;\n                result[k++] = this._bcurve.packedData[i++] * dw;\n            }\n            else {\n                result[k++] = this._bcurve.packedData[i++];\n                result[k++] = this._bcurve.packedData[i++];\n                result[k++] = this._bcurve.packedData[i++];\n            }\n        }\n        return result;\n    }\n    copyWeightsFloat64Array() {\n        const result = new Float64Array(this.numPoles);\n        for (let poleIndex = 0; poleIndex < this.numPoles; poleIndex++) {\n            result[poleIndex] = this._bcurve.packedData[4 * poleIndex + 3];\n        }\n        return result;\n    }\n    /** Create a bspline with uniform knots.\n     * * Control points may be supplied as:\n     *   * array of Point4d, with weight already multiplied into the `[wx,wy,wz,w]`\n     *   * array of Point3d, with implied weight 1.\n     *   * Float64Array, blocked as xyzw, i.e. 4 doubles per control point.\n     * @param controlPoints pole data in array form as noted above.\n     * @param order  curve order (1 more than degree)\n     */\n    static createUniformKnots(controlPoints, order) {\n        const numPoles = (controlPoints instanceof Float64Array) ? controlPoints.length / 4 : controlPoints.length;\n        if (order < 1 || numPoles < order)\n            return undefined;\n        const knots = KnotVector.createUniformClamped(controlPoints.length, order - 1, 0.0, 1.0);\n        const curve = new BSplineCurve3dH(numPoles, order, knots);\n        let i = 0;\n        if (controlPoints[0] instanceof Point3d) {\n            for (const p of controlPoints) {\n                curve._bcurve.packedData[i++] = p.x;\n                curve._bcurve.packedData[i++] = p.y;\n                curve._bcurve.packedData[i++] = p.z;\n                curve._bcurve.packedData[i++] = 1.0;\n            }\n        }\n        else if (controlPoints[0] instanceof Point4d) {\n            for (const p of controlPoints) {\n                curve._bcurve.packedData[i++] = p.x;\n                curve._bcurve.packedData[i++] = p.y;\n                curve._bcurve.packedData[i++] = p.z;\n                curve._bcurve.packedData[i++] = p.w;\n            }\n        }\n        else if (controlPoints instanceof Float64Array) {\n            const numQ = controlPoints.length;\n            for (let k = 0; k < numQ; k++) {\n                curve._bcurve.packedData[k] = controlPoints[k];\n            }\n        }\n        else {\n            return undefined;\n        }\n        return curve;\n    }\n    /**\n     * Assemble a variously structured control points into packed array of [xyzw].\n     * @param controlPoints\n     */\n    static assemblePackedXYZW(controlPoints) {\n        if (controlPoints instanceof Float64Array) {\n            return controlPoints.slice();\n        }\n        else if (Array.isArray(controlPoints)) {\n            const cpArray = controlPoints; // This should not be necessary -- but the predicate controlPoints[0] is not recognized even though Array.isArray(controlPoints) was just passed.\n            if (cpArray[0] instanceof Point4d) {\n                const numPoints = cpArray.length;\n                const packedPoints = new Float64Array(4 * numPoints);\n                let i = 0;\n                for (const p of controlPoints) {\n                    packedPoints[i++] = p.x;\n                    packedPoints[i++] = p.y;\n                    packedPoints[i++] = p.z;\n                    packedPoints[i++] = p.w;\n                }\n                return packedPoints;\n            }\n            else if (cpArray[0] instanceof Point3d) {\n                const numPoints = cpArray.length;\n                const packedPoints = new Float64Array(4 * numPoints);\n                let i = 0;\n                for (const p of controlPoints) {\n                    packedPoints[i++] = p.x;\n                    packedPoints[i++] = p.y;\n                    packedPoints[i++] = p.z;\n                    packedPoints[i++] = 1.0;\n                }\n                return packedPoints;\n            }\n        }\n        else {\n            const obj = controlPoints;\n            if (obj.xyz instanceof Float64Array && obj.weights instanceof Float64Array && obj.xyz.length === 3 * obj.weights.length) {\n                const numPoints = obj.weights.length;\n                const packedPoints = new Float64Array(4 * numPoints);\n                let m = 0;\n                for (let i = 0; i < obj.weights.length; i++) {\n                    const k = 3 * i;\n                    packedPoints[m++] = obj.xyz[k];\n                    packedPoints[m++] = obj.xyz[k + 1];\n                    packedPoints[m++] = obj.xyz[k + 2];\n                    packedPoints[m++] = obj.weights[i];\n                }\n                return packedPoints;\n            }\n        }\n        return undefined;\n    }\n    /** Create a bspline with given knots.\n     * * The poles have several variants:\n     *   * Float64Array(4 * numPoles) in blocks of [wx,xy,wz,w]\n     *   * Point4d[numPoles]\n     *   * Point3d[], with implied unit weight to be added.\n     *   * {xyz: Float64Array(3 * numPoles), weights: Float64Array (numPoles)}\n     *\n     * *  Two count conditions are recognized:\n     *\n     * ** If poleArray.length + order == knotArray.length, the first and last are assumed to be the\n     *      extraneous knots of classic clamping.\n     * ** If poleArray.length + order == knotArray.length + 2, the knots are in modern form.\n     *\n     */\n    static create(controlPointData, knotArray, order) {\n        if (order < 2)\n            return undefined;\n        const controlPoints = this.assemblePackedXYZW(controlPointData);\n        if (controlPoints instanceof Float64Array) {\n            const numPoles = Math.floor(controlPoints.length / 4);\n            const numKnots = knotArray.length;\n            // shift knots-of-interest limits for overclamped case ...\n            const skipFirstAndLast = (numPoles + order === numKnots);\n            const knots = KnotVector.create(knotArray, order - 1, skipFirstAndLast);\n            if (numPoles < order)\n                return undefined;\n            const curve = new BSplineCurve3dH(numPoles, order, knots);\n            let i = 0;\n            for (const coordinate of controlPoints) {\n                curve._bcurve.packedData[i++] = coordinate;\n            }\n            return curve;\n        }\n        return undefined;\n    }\n    /** Return a deep clone of this curve. */\n    clone() {\n        const knotVector1 = this._bcurve.knots.clone();\n        const curve1 = new BSplineCurve3dH(this.numPoles, this.order, knotVector1);\n        curve1._bcurve.packedData = this._bcurve.packedData.slice();\n        return curve1;\n    }\n    /** Evaluate at a position given by fractional position within a span. */\n    evaluatePointInSpan(spanIndex, spanFraction, result) {\n        this._bcurve.evaluateBuffersInSpan(spanIndex, spanFraction);\n        const xyzw = this._bcurve.poleBuffer;\n        return Point4d.createRealPoint3dDefault000(xyzw[0], xyzw[1], xyzw[2], xyzw[3], result);\n    }\n    /** Evaluate at a position given by fractional position within a span. */\n    evaluatePointAndDerivativeInSpan(spanIndex, spanFraction, result) {\n        this._bcurve.evaluateBuffersInSpan1(spanIndex, spanFraction);\n        const xyzw = this._bcurve.poleBuffer;\n        const dXYZW = this._bcurve.poleBuffer1;\n        return Point4d.createRealDerivativeRay3dDefault000(xyzw[0], xyzw[1], xyzw[2], xyzw[3], dXYZW[0], dXYZW[1], dXYZW[2], dXYZW[3], result);\n    }\n    /** Evaluate at a position given by a knot value. */\n    knotToPoint(u, result) {\n        this._bcurve.evaluateBuffersAtKnot(u);\n        const xyzw = this._bcurve.poleBuffer;\n        return Point4d.createRealPoint3dDefault000(xyzw[0], xyzw[1], xyzw[2], xyzw[3], result);\n    }\n    /** Evaluate at a position given by a knot value.  */\n    knotToPointAndDerivative(u, result) {\n        this._bcurve.evaluateBuffersAtKnot(u, 1);\n        const xyzw = this._bcurve.poleBuffer;\n        const dXYZW = this._bcurve.poleBuffer1;\n        return Point4d.createRealDerivativeRay3dDefault000(xyzw[0], xyzw[1], xyzw[2], xyzw[3], dXYZW[0], dXYZW[1], dXYZW[2], dXYZW[3], result);\n    }\n    /** Evaluate at a position given by a knot value.  Return point with 2 derivatives. */\n    knotToPointAnd2Derivatives(u, result) {\n        this._bcurve.evaluateBuffersAtKnot(u, 2);\n        const xyzw = this._bcurve.poleBuffer;\n        const dXYZW = this._bcurve.poleBuffer1;\n        const ddXYZW = this._bcurve.poleBuffer2;\n        return Point4d.createRealDerivativePlane3dByOriginAndVectorsDefault000(xyzw[0], xyzw[1], xyzw[2], xyzw[3], dXYZW[0], dXYZW[1], dXYZW[2], dXYZW[3], ddXYZW[0], ddXYZW[1], ddXYZW[2], ddXYZW[3], result);\n    }\n    /** test if the curve is almost equal to `other` */\n    isAlmostEqual(other) {\n        if (other instanceof BSplineCurve3dH) {\n            return this._bcurve.knots.isAlmostEqual(other._bcurve.knots)\n                && Point4dArray.isAlmostEqual(this._bcurve.packedData, other._bcurve.packedData);\n        }\n        return false;\n    }\n    /** Test if the curve is entirely within a plane. */\n    isInPlane(plane) {\n        return Point4dArray.isCloseToPlane(this._bcurve.packedData, plane);\n    }\n    /** Return the control polygon length as quick approximation to the curve length. */\n    quickLength() { return Point3dArray.sumEdgeLengths(this._bcurve.packedData); }\n    /** call a handler with interval data for stroking. */\n    emitStrokableParts(handler, options) {\n        const needBeziers = handler.announceBezierCurve;\n        const workBezier = this.initializeWorkBezier();\n        const numSpan = this.numSpan;\n        let numStrokes;\n        for (let spanIndex = 0; spanIndex < numSpan; spanIndex++) {\n            const bezier = this.getSaturatedBezierSpan3dOr3dH(spanIndex, false, workBezier);\n            if (bezier) {\n                numStrokes = bezier.computeStrokeCountForOptions(options);\n                if (needBeziers) {\n                    handler.announceBezierCurve(bezier, numStrokes, this, spanIndex, this._bcurve.knots.spanFractionToFraction(spanIndex, 0.0), this._bcurve.knots.spanFractionToFraction(spanIndex, 1.0));\n                }\n                else {\n                    handler.announceIntervalForUniformStepStrokes(this, numStrokes, this._bcurve.knots.spanFractionToFraction(spanIndex, 0.0), this._bcurve.knots.spanFractionToFraction(spanIndex, 1.0));\n                }\n            }\n        }\n    }\n    /**  Append stroked approximation of this curve to the linestring. */\n    emitStrokes(dest, options) {\n        const workBezier = this.initializeWorkBezier();\n        const numSpan = this.numSpan;\n        for (let spanIndex = 0; spanIndex < numSpan; spanIndex++) {\n            const bezier = this.getSaturatedBezierSpan3dH(spanIndex, workBezier);\n            if (bezier)\n                bezier.emitStrokes(dest, options);\n        }\n    }\n    /**\n     * Assess length and turn to determine a stroke count.\n     * @param options stroke options structure.\n     */\n    computeStrokeCountForOptions(options) {\n        const workBezier = this.initializeWorkBezier();\n        const numSpan = this.numSpan;\n        let numStroke = 0;\n        for (let spanIndex = 0; spanIndex < numSpan; spanIndex++) {\n            const bezier = this.getSaturatedBezierSpan3dH(spanIndex, workBezier);\n            if (bezier)\n                numStroke += bezier.computeStrokeCountForOptions(options);\n        }\n        return numStroke;\n    }\n    /**\n     * Compute individual segment stroke counts.  Attach in a StrokeCountMap.\n     * @param options StrokeOptions that determine count\n     * @param parentStrokeMap evolving parent map.\n     */\n    computeAndAttachRecursiveStrokeCounts(options, parentStrokeMap) {\n        const workBezier = this.initializeWorkBezier();\n        const numSpan = this.numSpan;\n        const myData = StrokeCountMap.createWithCurvePrimitiveAndOptionalParent(this, parentStrokeMap, []);\n        for (let spanIndex = 0; spanIndex < numSpan; spanIndex++) {\n            const bezier = this.getSaturatedBezierSpan3dH(spanIndex, workBezier);\n            if (bezier) {\n                const segmentLength = workBezier.curveLength();\n                const numStrokeOnSegment = workBezier.computeStrokeCountForOptions(options);\n                myData.addToCountAndLength(numStrokeOnSegment, segmentLength);\n            }\n        }\n        CurvePrimitive.installStrokeCountMap(this, myData, parentStrokeMap);\n    }\n    /**\n     * return true if the spline is (a) unclamped with (degree-1) matching knot intervals,\n     * (b) (degree-1) wrapped points,\n     * (c) marked wrappable from construction time.\n     */\n    get isClosable() {\n        if (!this._bcurve.knots.wrappable)\n            return false;\n        const degree = this.degree;\n        const leftKnotIndex = this._bcurve.knots.leftKnotIndex;\n        const rightKnotIndex = this._bcurve.knots.rightKnotIndex;\n        const period = this._bcurve.knots.rightKnot - this._bcurve.knots.leftKnot;\n        const indexDelta = rightKnotIndex - leftKnotIndex;\n        for (let k0 = leftKnotIndex - degree + 1; k0 < leftKnotIndex + degree - 1; k0++) {\n            const k1 = k0 + indexDelta;\n            if (!Geometry.isSameCoordinate(this._bcurve.knots.knots[k0] + period, this._bcurve.knots.knots[k1]))\n                return false;\n        }\n        const poleIndexDelta = this.numPoles - this.degree;\n        for (let p0 = 0; p0 < degree; p0++) {\n            const p1 = p0 + poleIndexDelta;\n            if (!Geometry.isSamePoint3d(this.getPolePoint3d(p0), this.getPolePoint3d(p1)))\n                return false;\n        }\n        return true;\n    }\n    /**\n     * Return a CurvePrimitive (which is a BezierCurve3dH) for a specified span of this curve.\n     * @param spanIndex\n     * @param result optional reusable curve.  This will only be reused if it is a BezierCurve3d with matching order.\n     */\n    getSaturatedBezierSpan3dH(spanIndex, result) {\n        if (spanIndex < 0 || spanIndex >= this.numSpan)\n            return undefined;\n        const order = this.order;\n        if (result === undefined || !(result instanceof BezierCurve3dH) || result.order !== order)\n            result = BezierCurve3dH.createOrder(order);\n        const bezier = result;\n        bezier.loadSpan4dPoles(this._bcurve.packedData, spanIndex);\n        if (bezier.saturateInPlace(this._bcurve.knots, spanIndex))\n            return result;\n        return undefined;\n    }\n    /**\n     * Return a BezierCurveBase for this curve.  Because BSplineCurve3dH is homogeneous, the returned BezierCurveBase is always homogeneous.\n     * @param spanIndex\n     * @param result optional reusable curve.  This will only be reused if it is a BezierCurve3dH with matching order.\n     */\n    getSaturatedBezierSpan3dOr3dH(spanIndex, _prefer3dH, result) {\n        return this.getSaturatedBezierSpan3dH(spanIndex, result);\n    }\n    /** Second step of double dispatch:  call `handler.handleBSplineCurve3dH(this)` */\n    dispatchToGeometryHandler(handler) {\n        return handler.handleBSplineCurve3dH(this);\n    }\n    /**\n     * Extend a range so in includes the range of this curve\n     * * REMARK: this is based on the poles, not the exact curve.  This is generally larger than the true curve range.\n     * @param rangeToExtend\n     * @param transform transform to apply to points as they are entered into the range.\n     */\n    extendRange(rangeToExtend, transform) {\n        const buffer = this._bcurve.packedData;\n        const n = buffer.length - 3;\n        if (transform) {\n            for (let i0 = 0; i0 < n; i0 += 4)\n                rangeToExtend.extendTransformedXYZW(transform, buffer[i0], buffer[i0 + 1], buffer[i0 + 2], buffer[i0 + 3]);\n        }\n        else {\n            for (let i0 = 0; i0 < n; i0 += 4)\n                rangeToExtend.extendXYZW(buffer[i0], buffer[i0 + 1], buffer[i0 + 2], buffer[i0 + 3]);\n        }\n    }\n}\n//# sourceMappingURL=BSplineCurve3dH.js.map",
      "start": 1693508123006,
      "end": 1693508123164,
      "sourcemaps": null
    }
  ]
}
