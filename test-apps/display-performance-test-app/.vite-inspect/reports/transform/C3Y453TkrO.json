{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tile/map/CesiumTerrainProvider.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tiles\n */\nimport { assert, BeDuration, BeTimePoint, ByteStream, JsonUtils, utf8ToString } from \"@itwin/core-bentley\";\nimport { Point2d, Point3d, Range1d, Vector3d } from \"@itwin/core-geometry\";\nimport { nextPoint3d64FromByteStream, OctEncodedNormal, QPoint2d } from \"@itwin/core-common\";\nimport { MessageSeverity } from \"@itwin/appui-abstract\";\nimport { request } from \"../../request/Request\";\nimport { ApproximateTerrainHeights } from \"../../ApproximateTerrainHeights\";\nimport { IModelApp } from \"../../IModelApp\";\nimport { RealityMeshParamsBuilder } from \"../../render/RealityMeshParams\";\nimport { GeographicTilingScheme, MapTile, QuadId, TerrainMeshProvider, TileAvailability, } from \"../internal\";\n/** @internal */\nvar QuantizedMeshExtensionIds;\n(function (QuantizedMeshExtensionIds) {\n    QuantizedMeshExtensionIds[QuantizedMeshExtensionIds[\"OctEncodedNormals\"] = 1] = \"OctEncodedNormals\";\n    QuantizedMeshExtensionIds[QuantizedMeshExtensionIds[\"WaterMask\"] = 2] = \"WaterMask\";\n    QuantizedMeshExtensionIds[QuantizedMeshExtensionIds[\"Metadata\"] = 4] = \"Metadata\";\n})(QuantizedMeshExtensionIds || (QuantizedMeshExtensionIds = {}));\n/** Return the URL for a Cesium ION asset from its asset ID and request Key.\n * @public\n */\nexport function getCesiumAssetUrl(osmAssetId, requestKey) {\n    return `$CesiumIonAsset=${osmAssetId}:${requestKey}`;\n}\n/** @internal */\nexport function getCesiumOSMBuildingsUrl() {\n    const key = IModelApp.tileAdmin.cesiumIonKey;\n    if (undefined === key)\n        return undefined;\n    const osmBuildingAssetId = 96188;\n    return getCesiumAssetUrl(osmBuildingAssetId, key);\n}\n/** @internal */\nexport async function getCesiumAccessTokenAndEndpointUrl(assetId = 1, requestKey) {\n    if (undefined === requestKey) {\n        requestKey = IModelApp.tileAdmin.cesiumIonKey;\n        if (undefined === requestKey)\n            return {};\n    }\n    const requestTemplate = `https://api.cesium.com/v1/assets/${assetId}/endpoint?access_token={CesiumRequestToken}`;\n    const apiUrl = requestTemplate.replace(\"{CesiumRequestToken}\", requestKey);\n    try {\n        const apiResponse = await request(apiUrl, \"json\");\n        if (undefined === apiResponse || undefined === apiResponse.url) {\n            assert(false);\n            return {};\n        }\n        return { token: apiResponse.accessToken, url: apiResponse.url };\n    }\n    catch (error) {\n        assert(false);\n        return {};\n    }\n}\nlet notifiedTerrainError = false;\n// Notify - once per session - of failure to obtain Cesium terrain provider.\nfunction notifyTerrainError(detailedDescription) {\n    if (notifiedTerrainError)\n        return;\n    notifiedTerrainError = true;\n    IModelApp.notifications.displayMessage(MessageSeverity.Information, IModelApp.localization.getLocalizedString(`iModelJs:BackgroundMap.CannotObtainTerrain`), detailedDescription);\n}\n/** @internal */\nexport async function getCesiumTerrainProvider(opts) {\n    const accessTokenAndEndpointUrl = await getCesiumAccessTokenAndEndpointUrl();\n    if (!accessTokenAndEndpointUrl.token || !accessTokenAndEndpointUrl.url) {\n        notifyTerrainError(IModelApp.localization.getLocalizedString(`iModelJs:BackgroundMap.MissingCesiumToken`));\n        return undefined;\n    }\n    let layers;\n    try {\n        const layerRequestOptions = { headers: { authorization: `Bearer ${accessTokenAndEndpointUrl.token}` } };\n        const layerUrl = `${accessTokenAndEndpointUrl.url}layer.json`;\n        layers = await request(layerUrl, \"json\", layerRequestOptions);\n    }\n    catch (error) {\n        notifyTerrainError();\n        return undefined;\n    }\n    if (undefined === layers || undefined === layers.tiles || undefined === layers.version) {\n        notifyTerrainError();\n        return undefined;\n    }\n    const tilingScheme = new GeographicTilingScheme();\n    let tileAvailability;\n    if (undefined !== layers.available) {\n        const availableTiles = layers.available;\n        tileAvailability = new TileAvailability(tilingScheme, availableTiles.length);\n        for (let level = 0; level < layers.available.length; level++) {\n            const rangesAtLevel = availableTiles[level];\n            for (const range of rangesAtLevel) {\n                tileAvailability.addAvailableTileRange(level, range.startX, range.startY, range.endX, range.endY);\n            }\n        }\n    }\n    let tileUrlTemplate = accessTokenAndEndpointUrl.url + layers.tiles[0].replace(\"{version}\", layers.version);\n    if (opts.wantNormals)\n        tileUrlTemplate = tileUrlTemplate.replace(\"?\", \"?extensions=octvertexnormals-watermask-metadata&\");\n    const maxDepth = JsonUtils.asInt(layers.maxzoom, 19);\n    // TBD -- When we have  an API extract the heights for the project from the terrain tiles - for use temporary Bing elevation.\n    return new CesiumTerrainProvider(opts, accessTokenAndEndpointUrl.token, tileUrlTemplate, maxDepth, tilingScheme, tileAvailability, layers.metadataAvailability);\n}\nfunction zigZagDecode(value) {\n    return (value >> 1) ^ (-(value & 1));\n}\n/**\n * Decodes delta and ZigZag encoded vertices. This modifies the buffers in place.\n *\n * @see {@link https://github.com/AnalyticalGraphicsInc/quantized-mesh|quantized-mesh-1.0 terrain format}\n */\nfunction zigZagDeltaDecode(uBuffer, vBuffer, heightBuffer) {\n    const count = uBuffer.length;\n    let u = 0;\n    let v = 0;\n    let height = 0;\n    for (let i = 0; i < count; ++i) {\n        u += zigZagDecode(uBuffer[i]);\n        v += zigZagDecode(vBuffer[i]);\n        uBuffer[i] = u;\n        vBuffer[i] = v;\n        height += zigZagDecode(heightBuffer[i]);\n        heightBuffer[i] = height;\n    }\n}\n/** @internal */\nclass CesiumTerrainProvider extends TerrainMeshProvider {\n    forceTileLoad(tile) {\n        // Force loading of the metadata availability tiles as these are required for determining the availability of descendants.\n        const mapTile = tile;\n        return undefined !== this._metaDataAvailableLevel && mapTile.quadId.level === this._metaDataAvailableLevel && !mapTile.everLoaded;\n    }\n    constructor(opts, accessToken, tileUrlTemplate, maxDepth, tilingScheme, tileAvailability, metaDataAvailableLevel) {\n        super();\n        /**\n         * Specifies the quality of terrain created from heightmaps.  A value of 1.0 will\n         * ensure that adjacent heightmap vertices are separated by no more than\n         * screen pixels and will probably go very slowly.\n         * A value of 0.5 will cut the estimated level zero geometric error in half, allowing twice the\n         * screen pixels between adjacent heightmap vertices and thus rendering more quickly.\n         * @type {Number}\n         */\n        this.heightmapTerrainQuality = 0.25;\n        this._wantSkirts = opts.wantSkirts;\n        this._exaggeration = opts.exaggeration;\n        this._accessToken = accessToken;\n        this._tileUrlTemplate = tileUrlTemplate;\n        this._maxDepth = maxDepth;\n        this._tilingScheme = tilingScheme;\n        this._tileAvailability = tileAvailability;\n        this._metaDataAvailableLevel = metaDataAvailableLevel;\n        this._tokenTimeOut = BeTimePoint.now().plus(CesiumTerrainProvider._tokenTimeoutInterval);\n    }\n    addLogoCards(cards) {\n        if (cards.dataset.cesiumIonLogoCard)\n            return;\n        cards.dataset.cesiumIonLogoCard = \"true\";\n        const card = IModelApp.makeLogoCard({ iconSrc: `${IModelApp.publicPath}images/cesium-ion.svg`, heading: \"Cesium Ion\", notice: IModelApp.localization.getLocalizedString(\"iModelJs:BackgroundMap.CesiumWorldTerrainAttribution\") });\n        cards.appendChild(card);\n    }\n    get maxDepth() { return this._maxDepth; }\n    get tilingScheme() { return this._tilingScheme; }\n    isTileAvailable(quadId) {\n        if (quadId.level > this.maxDepth)\n            return false;\n        return this._tileAvailability ? this._tileAvailability.isTileAvailable(quadId.level, quadId.column, quadId.row) : true;\n    }\n    async requestMeshData(args) {\n        const tile = args.tile;\n        const quadId = tile.quadId;\n        const tileUrl = this.constructUrl(quadId.row, quadId.column, quadId.level);\n        const requestOptions = {\n            headers: {\n                authorization: `Bearer ${this._accessToken}`,\n                accept: \"application/vnd.quantized-mesh;\" /* extensions=octvertexnormals, */ + \"application/octet-stream;q=0.9,*/*;q=0.01\",\n            },\n        };\n        try {\n            const response = await request(tileUrl, \"arraybuffer\", requestOptions);\n            return new Uint8Array(response);\n        }\n        catch (_) {\n            return undefined;\n        }\n    }\n    async readMesh(args) {\n        // ###TODO why does he update the access token when reading the mesh instead of when requesting it?\n        // This function only returns undefined if it fails to acquire token - but it doesn't need the token...\n        if (BeTimePoint.now().milliseconds > this._tokenTimeOut.milliseconds) {\n            const accessTokenAndEndpointUrl = await getCesiumAccessTokenAndEndpointUrl();\n            if (!accessTokenAndEndpointUrl.token || args.isCanceled())\n                return undefined;\n            this._accessToken = accessTokenAndEndpointUrl.token;\n            this._tokenTimeOut = BeTimePoint.now().plus(CesiumTerrainProvider._tokenTimeoutInterval);\n        }\n        const { data, tile } = args;\n        assert(data instanceof Uint8Array);\n        assert(tile instanceof MapTile);\n        const blob = data;\n        const streamBuffer = ByteStream.fromUint8Array(blob);\n        const center = nextPoint3d64FromByteStream(streamBuffer);\n        const quadId = QuadId.createFromContentId(tile.contentId);\n        const skirtHeight = this.getLevelMaximumGeometricError(quadId.level + 1) * 10.0; // Add 1 to level to restore height calculation to before the quadId level was from root. (4326 unification)\n        const minHeight = this._exaggeration * streamBuffer.readFloat32();\n        const maxHeight = this._exaggeration * streamBuffer.readFloat32();\n        const boundCenter = nextPoint3d64FromByteStream(streamBuffer);\n        const boundRadius = streamBuffer.readFloat64();\n        const horizonOcclusion = nextPoint3d64FromByteStream(streamBuffer);\n        const terrainTile = tile;\n        terrainTile.adjustHeights(minHeight, maxHeight);\n        if (undefined === center || undefined === boundCenter || undefined === boundRadius || undefined === horizonOcclusion) { }\n        const pointCount = streamBuffer.readUint32();\n        const encodedVertexBuffer = new Uint16Array(blob.buffer, streamBuffer.curPos, pointCount * 3);\n        streamBuffer.advance(pointCount * 6);\n        const uBuffer = encodedVertexBuffer.subarray(0, pointCount);\n        const vBuffer = encodedVertexBuffer.subarray(pointCount, 2 * pointCount);\n        const heightBuffer = encodedVertexBuffer.subarray(pointCount * 2, 3 * pointCount);\n        zigZagDeltaDecode(uBuffer, vBuffer, heightBuffer);\n        // ###TODO: This alleges to handle 32-bit indices, but RealityMeshParams uses a Uint16Array to store indices...\n        const typedArray = pointCount > 0xffff ? Uint32Array : Uint16Array;\n        const bytesPerIndex = typedArray.BYTES_PER_ELEMENT;\n        const triangleElements = 3;\n        // skip over any additional padding that was added for 2/4 byte alignment\n        if (streamBuffer.curPos % bytesPerIndex !== 0)\n            streamBuffer.advance(bytesPerIndex - (streamBuffer.curPos % bytesPerIndex));\n        const triangleCount = streamBuffer.readUint32();\n        const indexCount = triangleCount * triangleElements;\n        const getIndexArray = (numIndices) => {\n            const indexArray = new typedArray(streamBuffer.arrayBuffer, streamBuffer.curPos, numIndices);\n            streamBuffer.advance(numIndices * bytesPerIndex);\n            return indexArray;\n        };\n        const indices = getIndexArray(indexCount);\n        // High water mark decoding based on decompressIndices_ in webgl-loader's loader.js.\n        // https://code.google.com/p/webgl-loader/source/browse/trunk/samples/loader.js?r=99#55\n        // Copyright 2012 Google Inc., Apache 2.0 license.\n        let highest = 0;\n        const length = indices.length;\n        for (let i = 0; i < length; ++i) {\n            const code = indices[i];\n            indices[i] = highest - code;\n            if (code === 0) {\n                ++highest;\n            }\n        }\n        CesiumTerrainProvider._scratchHeightRange.low = minHeight - skirtHeight;\n        CesiumTerrainProvider._scratchHeightRange.high = maxHeight;\n        const projection = terrainTile.getProjection(CesiumTerrainProvider._scratchHeightRange);\n        const uvScale = 1.0 / 32767.0;\n        const heightScale = uvScale * (maxHeight - minHeight);\n        const westCount = streamBuffer.readUint32(), westIndices = getIndexArray(westCount), southCount = streamBuffer.readUint32(), southIndices = getIndexArray(southCount), eastCount = streamBuffer.readUint32(), eastIndices = getIndexArray(eastCount), northCount = streamBuffer.readUint32(), northIndices = getIndexArray(northCount);\n        // Extensions...\n        let encodedNormalsBuffer;\n        while (streamBuffer.curPos < streamBuffer.length) {\n            const extensionId = streamBuffer.readUint8();\n            const extensionLength = streamBuffer.readUint32();\n            switch (extensionId) {\n                case QuantizedMeshExtensionIds.OctEncodedNormals:\n                    assert(pointCount * 2 === extensionLength);\n                    encodedNormalsBuffer = new Uint8Array(streamBuffer.arrayBuffer, streamBuffer.curPos, extensionLength);\n                    streamBuffer.advance(extensionLength);\n                    break;\n                case QuantizedMeshExtensionIds.Metadata:\n                    const stringLength = streamBuffer.readUint32();\n                    if (stringLength > 0) {\n                        const strData = streamBuffer.nextBytes(stringLength);\n                        const str = utf8ToString(strData);\n                        if (undefined !== str) {\n                            const metaData = JSON.parse(str);\n                            if (undefined !== metaData.available && undefined !== this._tileAvailability) {\n                                const availableTiles = metaData.available;\n                                for (let offset = 0; offset < availableTiles.length; ++offset) {\n                                    const availableLevel = tile.depth + offset; // Our depth is includes root (1 + cesium Depth)\n                                    const rangesAtLevel = availableTiles[offset];\n                                    for (const range of rangesAtLevel)\n                                        this._tileAvailability.addAvailableTileRange(availableLevel, range.startX, range.startY, range.endX, range.endY);\n                                }\n                            }\n                        }\n                    }\n                    break;\n                default:\n                    streamBuffer.advance(extensionLength);\n                    break;\n            }\n        }\n        let initialIndexCapacity = indexCount;\n        let initialVertexCapacity = pointCount;\n        if (this._wantSkirts) {\n            initialIndexCapacity += 6 * (Math.max(0, northCount - 1) + Math.max(0, southCount - 1) + Math.max(0, eastCount - 1) + Math.max(0, westCount - 1));\n            initialVertexCapacity += (northCount + southCount + eastCount + westCount);\n        }\n        const wantNormals = undefined !== encodedNormalsBuffer;\n        const builder = new RealityMeshParamsBuilder({\n            positionRange: projection.localRange,\n            initialIndexCapacity,\n            initialVertexCapacity,\n            wantNormals,\n        });\n        for (let i = 0; i < indexCount; i += 3)\n            builder.addTriangle(indices[i], indices[i + 1], indices[i + 2]);\n        const position = new Point3d();\n        const uv = new QPoint2d();\n        const normal = new Vector3d();\n        const worldToEcef = tile.iModel.getEcefTransform().matrix;\n        for (let i = 0; i < pointCount; i++) {\n            const u = uBuffer[i];\n            const v = vBuffer[i];\n            projection.getPoint(uvScale * u, uvScale * v, minHeight + heightBuffer[i] * heightScale, position);\n            uv.setFromScalars(u * 2, v * 2);\n            let oen;\n            if (encodedNormalsBuffer) {\n                const normalIndex = i * 2;\n                OctEncodedNormal.decodeValue(encodedNormalsBuffer[normalIndex + 1] << 8 | encodedNormalsBuffer[normalIndex], normal);\n                worldToEcef.multiplyTransposeVector(normal, normal);\n                oen = OctEncodedNormal.encode(normal);\n            }\n            builder.addVertex(position, uv, oen);\n        }\n        if (!this._wantSkirts)\n            return builder.finish();\n        westIndices.sort((a, b) => vBuffer[a] - vBuffer[b]);\n        eastIndices.sort((a, b) => vBuffer[a] - vBuffer[b]);\n        northIndices.sort((a, b) => uBuffer[a] - uBuffer[b]);\n        southIndices.sort((a, b) => uBuffer[a] - uBuffer[b]);\n        const generateSkirts = (indexes) => {\n            const quv = new QPoint2d();\n            const param = new Point2d();\n            for (let i = 0; i < indexes.length; i++) {\n                const index = indexes[i];\n                const uvIndex = index * 2;\n                const height = minHeight + heightBuffer[index] * heightScale;\n                quv.setFromScalars(builder.uvs.buffer.at(uvIndex), builder.uvs.buffer.at(uvIndex + 1));\n                builder.uvs.params.unquantize(quv.x, quv.y, param);\n                const oen = wantNormals && builder.normals ? builder.normals.at(index) : undefined;\n                builder.addVertex(projection.getPoint(param.x, param.y, height - skirtHeight), quv, oen);\n                if (i !== 0) {\n                    const nextPointIndex = builder.positions.length;\n                    builder.addTriangle(index, indexes[i - 1], nextPointIndex - 2);\n                    builder.addTriangle(index, nextPointIndex - 2, nextPointIndex - 1);\n                }\n            }\n        };\n        generateSkirts(westIndices);\n        generateSkirts(eastIndices);\n        generateSkirts(southIndices);\n        generateSkirts(northIndices);\n        return builder.finish();\n    }\n    constructUrl(row, column, zoomLevel) {\n        return this._tileUrlTemplate.replace(\"{z}\", zoomLevel.toString()).replace(\"{x}\", column.toString()).replace(\"{y}\", row.toString());\n    }\n    /**\n     * Determines an appropriate geometric error estimate when the geometry comes from a heightmap.\n     *\n     * @param {Ellipsoid} ellipsoid The ellipsoid to which the terrain is attached.\n     * @param {Number} tileImageWidth The width, in pixels, of the heightmap associated with a single tile.\n     * @param {Number} numberOfTilesAtLevelZero The number of tiles in the horizontal direction at tile level zero.\n     * @returns {Number} An estimated geometric error.\n     */\n    getEstimatedLevelZeroGeometricErrorForAHeightmap(ellipsoidMaximumRadius = 6378137, tileImageWidth = 65, numberOfTilesAtLevelZero = 2) {\n        return ellipsoidMaximumRadius * 2 * Math.PI * this.heightmapTerrainQuality / (tileImageWidth * numberOfTilesAtLevelZero);\n    }\n    getLevelMaximumGeometricError(level) {\n        return this.getEstimatedLevelZeroGeometricErrorForAHeightmap() / (1 << level);\n    }\n    getHeightRange(parentRange, quadId) {\n        const heightRange = quadId.level <= 6 ? ApproximateTerrainHeights.instance.getTileHeightRange(quadId) : undefined;\n        return undefined === heightRange ? parentRange : heightRange;\n    }\n}\nCesiumTerrainProvider._scratchQPoint2d = QPoint2d.fromScalars(0, 0);\nCesiumTerrainProvider._scratchPoint2d = Point2d.createZero();\nCesiumTerrainProvider._scratchPoint = Point3d.createZero();\nCesiumTerrainProvider._scratchNormal = Vector3d.createZero();\nCesiumTerrainProvider._scratchHeightRange = Range1d.createNull();\nCesiumTerrainProvider._tokenTimeoutInterval = BeDuration.fromSeconds(60 * 30); // Request a new access token every 30 minutes...\n//# sourceMappingURL=CesiumTerrainProvider.js.map",
      "start": 1693508121845,
      "end": 1693508121968,
      "sourcemaps": null
    }
  ]
}
