{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/bspline/BezierCurveBase.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Bspline\n */\nimport { CurvePrimitive } from \"../curve/CurvePrimitive\";\nimport { CurveOffsetXYHandler } from \"../curve/internalContexts/CurveOffsetXYHandler\";\nimport { PlaneAltitudeRangeContext } from \"../curve/internalContexts/PlaneAltitudeRangeContext\";\nimport { OffsetOptions } from \"../curve/OffsetOptions\";\nimport { StrokeOptions } from \"../curve/StrokeOptions\";\nimport { Geometry } from \"../Geometry\";\nimport { Angle } from \"../geometry3d/Angle\";\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\nimport { UnivariateBezier } from \"../numerics/BezierPolynomials\";\nimport { Bezier1dNd } from \"./Bezier1dNd\";\n/**\n * Base class for CurvePrimitive (necessarily 3D) with _polygon.\n * * This has a Bezier1dNd polygon as a member, and implements dimension-independent methods\n * * This exists to support\n *    * BezierCurve3d -- 3 coordinates x,y,z per block in the Bezier1dNd poles\n *    * BezierCurve3dH -- 4 coordinates x,y,z,w per block in the Bezier1dNd poles\n * * The implementations of \"pure 3d\" queries is based on calling `getPolePoint3d`.\n * * This has the subtle failure difference that `getPolePoint3d` call with a valid index on on a 3d curve always succeeds, but on 3dH curve fails when weight is zero.\n * @public\n */\nexport class BezierCurveBase extends CurvePrimitive {\n    constructor(blockSize, data) {\n        super();\n        /** String name for schema properties */\n        this.curvePrimitiveType = \"bezierCurve\";\n        this._polygon = new Bezier1dNd(blockSize, data);\n        this._workPoint0 = Point3d.create();\n        this._workPoint1 = Point3d.create();\n        this._workData0 = new Float64Array(blockSize);\n        this._workData1 = new Float64Array(blockSize);\n    }\n    /** reverse the poles in place */\n    reverseInPlace() { this._polygon.reverseInPlace(); }\n    /** saturate the pole in place, using knot intervals from `spanIndex` of the `knotVector` */\n    saturateInPlace(knotVector, spanIndex) {\n        const boolStat = this._polygon.saturateInPlace(knotVector, spanIndex);\n        if (boolStat) {\n            this.setInterval(knotVector.spanFractionToFraction(spanIndex, 0.0), knotVector.spanFractionToFraction(spanIndex, 1.0));\n        }\n        return boolStat;\n    }\n    /** (property accessor) Return the polynomial degree (one less than order) */\n    get degree() {\n        return this._polygon.order - 1;\n    }\n    /** (property accessor) Return the polynomial order */\n    get order() { return this._polygon.order; }\n    /** (property accessor) Return the number of poles (aka control points) */\n    get numPoles() { return this._polygon.order; }\n    /** Set mapping to parent curve (e.g. if this bezier is a span extracted from a bspline, this is the knot interval of the span) */\n    setInterval(a, b) { this._polygon.setInterval(a, b); }\n    /** map `fraction` from this Bezier curves inherent 0..1 range to the (a,b) range of parent\n     * * ( The parent range should have been previously defined with `setInterval`)\n     */\n    fractionToParentFraction(fraction) { return this._polygon.fractionToParentFraction(fraction); }\n    /** append stroke points to a linestring, based on `strokeCount` and `fractionToPoint` from derived class*/\n    emitStrokes(dest, options) {\n        const numPerSpan = this.computeStrokeCountForOptions(options);\n        const fractionStep = 1.0 / numPerSpan;\n        for (let i = 0; i <= numPerSpan; i++) {\n            const fraction = i * fractionStep;\n            this.fractionToPoint(fraction, this._workPoint0);\n            dest.appendStrokePoint(this._workPoint0);\n        }\n    }\n    /** announce intervals with stroke counts */\n    emitStrokableParts(handler, _options) {\n        const numPerSpan = this.computeStrokeCountForOptions(_options);\n        handler.announceIntervalForUniformStepStrokes(this, numPerSpan, 0.0, 1.0);\n    }\n    /** Return a simple array of arrays with the control points as `[[x,y,z],[x,y,z],..]` */\n    copyPolesAsJsonArray() { return this._polygon.unpackToJsonArrays(); }\n    /** return true if all poles are on a plane. */\n    isInPlane(plane) {\n        let point = this._workPoint0;\n        for (let i = 0;; i++) {\n            point = this.getPolePoint3d(i, point);\n            if (!point)\n                return true;\n            if (!plane.isPointInPlane(point))\n                break; // which gets to return false, which is otherwise unreachable . . .\n        }\n        return false;\n    }\n    /** Return the length of the control polygon. */\n    polygonLength() {\n        if (!this.getPolePoint3d(0, this._workPoint0))\n            return 0.0;\n        let i = 0;\n        let sum = 0.0;\n        while (this.getPolePoint3d(++i, this._workPoint1)) {\n            sum += this._workPoint0.distance(this._workPoint1);\n            this._workPoint0.setFrom(this._workPoint1);\n        }\n        return sum;\n    }\n    /** Return the start point.  (first control point) */\n    startPoint() {\n        const result = this.getPolePoint3d(0); // ASSUME non-trivial pole set -- if null comes back, it bubbles out\n        return result;\n    }\n    /** Return the end point.  (last control point) */\n    endPoint() {\n        const result = this.getPolePoint3d(this.order - 1); // ASSUME non-trivial pole set\n        return result;\n    }\n    /** Return the control polygon length as a quick length estimate. */\n    quickLength() { return this.polygonLength(); }\n    /**\n     * set up the _workBezier members with specific order.\n     * * Try to reuse existing members if their sizes match.\n     * * Ignore members corresponding to args that are 0 or negative.\n     * @param primaryBezierOrder order of expected bezier\n     * @param orderA length of _workCoffsA (simple array)\n     * @param orderB length of _workCoffsB (simple array)\n     */\n    allocateAndZeroBezierWorkData(primaryBezierOrder, orderA, orderB) {\n        if (primaryBezierOrder > 0) {\n            if (this._workBezier !== undefined && this._workBezier.order === primaryBezierOrder) {\n                this._workBezier.zero();\n            }\n            else\n                this._workBezier = new UnivariateBezier(primaryBezierOrder);\n        }\n        if (orderA > 0) {\n            if (this._workCoffsA !== undefined && this._workCoffsA.length === orderA)\n                this._workCoffsA.fill(0);\n            else\n                this._workCoffsA = new Float64Array(orderA);\n        }\n        if (orderB > 0) {\n            if (this._workCoffsB !== undefined && this._workCoffsB.length === orderB)\n                this._workCoffsB.fill(0);\n            else\n                this._workCoffsB = new Float64Array(orderB);\n        }\n    }\n    /**\n     * Assess length and turn to determine a stroke count.\n     * * this method is used by both BSplineCurve3d and BSplineCurve3dH.\n     * * points are accessed via getPolePoint3d.\n     *   * Hence a zero-weight pole will be a problem\n     * @param options stroke options structure.\n     */\n    computeStrokeCountForOptions(options) {\n        this.getPolePoint3d(0, this._workPoint0);\n        this.getPolePoint3d(1, this._workPoint1);\n        let numStrokes = 1;\n        if (this._workPoint0 && this._workPoint1) {\n            let dx0 = this._workPoint1.x - this._workPoint0.x;\n            let dy0 = this._workPoint1.y - this._workPoint0.y;\n            let dz0 = this._workPoint1.z - this._workPoint0.z;\n            let dx1, dy1, dz1; // first differences of leading edge\n            let sumRadians = 0.0;\n            let thisLength = Geometry.hypotenuseXYZ(dx0, dy0, dz0);\n            this._workPoint1.setFromPoint3d(this._workPoint0);\n            let sumLength = thisLength;\n            let maxLength = thisLength;\n            let maxRadians = 0.0;\n            let thisRadians;\n            for (let i = 2; this.getPolePoint3d(i, this._workPoint1); i++) {\n                dx1 = this._workPoint1.x - this._workPoint0.x;\n                dy1 = this._workPoint1.y - this._workPoint0.y;\n                dz1 = this._workPoint1.z - this._workPoint0.z;\n                thisRadians = Angle.radiansBetweenVectorsXYZ(dx0, dy0, dz0, dx1, dy1, dz1);\n                sumRadians += thisRadians;\n                maxRadians = Geometry.maxAbsXY(thisRadians, maxRadians);\n                thisLength = Geometry.hypotenuseXYZ(dx1, dy1, dz1);\n                sumLength += thisLength;\n                maxLength = Geometry.maxXY(maxLength, thisLength);\n                dx0 = dx1;\n                dy0 = dy1;\n                dz0 = dz1;\n                this._workPoint0.setFrom(this._workPoint1);\n            }\n            const length1 = maxLength * this.degree; // This may be larger than sumLength\n            const length2 = Math.sqrt(length1 * sumLength); // This is in between\n            let radians1 = maxRadians * (this.degree - 1); // As if worst case keeps happening.\n            if (this.degree < 3)\n                radians1 *= 3; // so quadratics aren't under-stroked\n            const radians2 = Math.sqrt(radians1 * sumRadians);\n            const minCount = this.degree; // NOTE: this means 1) a small, nontrivial, straight Bezier is over-stroked, and 2) options.minStrokesPerPrimitive is ignored\n            numStrokes = StrokeOptions.applyAngleTol(options, StrokeOptions.applyMaxEdgeLength(options, minCount, length2), radians2, 0.1);\n            if (options) {\n                numStrokes = options.applyChordTolToLengthAndRadians(numStrokes, sumLength, radians1);\n            }\n        }\n        return numStrokes;\n    }\n    /** Return a transformed deep clone. */\n    cloneTransformed(transform) {\n        const curve1 = this.clone();\n        curve1.tryTransformInPlace(transform);\n        return curve1;\n    }\n    /**\n     * Construct an offset of the instance curve as viewed in the xy-plane (ignoring z).\n     * * No attempt is made to join the offsets of smaller constituent primitives. To construct a fully joined offset\n     *   for an aggregate instance (e.g., LineString3d, CurveChainWithDistanceIndex), use RegionOps.constructCurveXYOffset() instead.\n     * @param offsetDistanceOrOptions offset distance (positive to left of the instance curve), or options object\n     */\n    constructOffsetXY(offsetDistanceOrOptions) {\n        const options = OffsetOptions.create(offsetDistanceOrOptions);\n        const handler = new CurveOffsetXYHandler(this, options.leftOffsetDistance);\n        this.emitStrokableParts(handler, options.strokeOptions);\n        return handler.claimResult();\n    }\n    /** Return a curve primitive which is a portion of this curve.\n     * @param fractionA [in] start fraction\n     * @param fractionB [in] end fraction\n     */\n    clonePartialCurve(fractionA, fractionB) {\n        const partialCurve = this.clone();\n        partialCurve._polygon.subdivideToIntervalInPlace(fractionA, fractionB);\n        return partialCurve;\n    }\n    /** Project instance geometry (via dispatch) onto the given ray, and return the extreme fractional parameters of projection.\n     * @param ray ray onto which the instance is projected. A `Vector3d` is treated as a `Ray3d` with zero origin.\n     * @param lowHigh optional receiver for output\n     * @returns range of fractional projection parameters onto the ray, where 0.0 is start of the ray and 1.0 is the end of the ray.\n     */\n    projectedParameterRange(ray, lowHigh) {\n        return PlaneAltitudeRangeContext.findExtremeFractionsAlongDirection(this, ray, lowHigh);\n    }\n}\n//# sourceMappingURL=BezierCurveBase.js.map",
      "start": 1693508122965,
      "end": 1693508123098,
      "sourcemaps": null
    }
  ]
}
