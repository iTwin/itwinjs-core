{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/curve/internalContexts/AppendPlaneIntersectionStrokeHandler.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Curve\n */\nimport { Geometry } from \"../../Geometry\";\nimport { Ray3d } from \"../../geometry3d/Ray3d\";\nimport { Order2Bezier } from \"../../numerics/BezierPolynomials\";\nimport { Newton1dUnboundedApproximateDerivative } from \"../../numerics/Newton\";\nimport { CurveLocationDetail } from \"../CurveLocationDetail\";\nimport { NewtonRtoRStrokeHandler } from \"./NewtonRtoRStrokeHandler\";\n/**\n * Context for computing intersections of a CurvePrimitive with a plane.\n * @internal\n */\nexport class AppendPlaneIntersectionStrokeHandler extends NewtonRtoRStrokeHandler {\n    // Return the first defined curve among: this.parentCurvePrimitive, this.curve;\n    effectiveCurve() {\n        if (this._parentCurvePrimitive)\n            return this._parentCurvePrimitive;\n        return this._curve;\n    }\n    get getDerivativeB() {\n        return this._derivativeB; // <--- _derivativeB is not currently used anywhere. Provided getter to suppress lint error\n    }\n    constructor(plane, intersections) {\n        super();\n        this._fractionA = 0;\n        this._functionA = 0;\n        // private derivativeA: number;   <---- Not currently used\n        this._functionB = 0;\n        this._fractionB = 0;\n        this._derivativeB = 0;\n        this._numThisCurve = 0;\n        this._plane = plane;\n        this._intersections = intersections;\n        this.startCurvePrimitive(undefined);\n        this._ray = Ray3d.createZero();\n        this._newtonSolver = new Newton1dUnboundedApproximateDerivative(this);\n    }\n    startCurvePrimitive(curve) {\n        this._curve = curve;\n        this._fractionA = 0.0;\n        this._numThisCurve = 0;\n        this._functionA = 0.0;\n        // this.derivativeA = 0.0;\n    }\n    endCurvePrimitive() {\n    }\n    announceIntervalForUniformStepStrokes(cp, numStrokes, fraction0, fraction1) {\n        this.startCurvePrimitive(cp);\n        if (numStrokes < 1)\n            numStrokes = 1;\n        const df = 1.0 / numStrokes;\n        for (let i = 0; i <= numStrokes; i++) {\n            const fraction = Geometry.interpolate(fraction0, i * df, fraction1);\n            cp.fractionToPointAndDerivative(fraction, this._ray);\n            this.announcePointTangent(this._ray.origin, fraction, this._ray.direction);\n        }\n    }\n    announceSegmentInterval(_cp, point0, point1, _numStrokes, fraction0, fraction1) {\n        const h0 = this._plane.altitude(point0);\n        const h1 = this._plane.altitude(point1);\n        if (h0 * h1 > 0.0)\n            return;\n        const fraction01 = Order2Bezier.solveCoffs(h0, h1);\n        // let numIntersection = 0;\n        if (fraction01 !== undefined) {\n            // numIntersection++;\n            const fraction = Geometry.interpolate(fraction0, fraction01, fraction1);\n            this._newtonSolver.setX(fraction);\n            if (this._newtonSolver.runIterations()) {\n                this.announceSolutionFraction(this._newtonSolver.getX());\n            }\n            // this.intersections.push(CurveLocationDetail.createCurveFractionPoint(cp, fraction, cp.fractionToPoint(fraction)));\n        }\n    }\n    announceSolutionFraction(fraction) {\n        const curve = this.effectiveCurve();\n        if (curve) {\n            this._ray = curve.fractionToPointAndDerivative(fraction, this._ray);\n            this._intersections.push(CurveLocationDetail.createCurveFractionPoint(curve, fraction, this._ray.origin));\n        }\n    }\n    evaluate(fraction) {\n        const curve = this.effectiveCurve();\n        if (!curve)\n            return false;\n        this.currentF = this._plane.altitude(curve.fractionToPoint(fraction));\n        return true;\n    }\n    /**\n     * * ASSUME both the \"A\" and \"B\"  evaluations (fraction, function, and derivative) are known.\n     * * If function value changed sign between, interpolate an approximate root and improve it with\n     *     the newton solver.\n     */\n    searchInterval() {\n        if (this._functionA * this._functionB > 0)\n            return;\n        if (this._functionA === 0)\n            this.announceSolutionFraction(this._fractionA);\n        if (this._functionB === 0)\n            this.announceSolutionFraction(this._fractionB);\n        if (this._functionA * this._functionB < 0) {\n            const fraction = Geometry.inverseInterpolate(this._fractionA, this._functionA, this._fractionB, this._functionB);\n            if (fraction) {\n                this._newtonSolver.setX(fraction);\n                if (this._newtonSolver.runIterations())\n                    this.announceSolutionFraction(this._newtonSolver.getX());\n            }\n        }\n    }\n    /** Evaluate and save _functionB, _derivativeB, and _fractionB. */\n    evaluateB(xyz, fraction, tangent) {\n        this._functionB = this._plane.altitude(xyz);\n        this._derivativeB = this._plane.velocity(tangent);\n        this._fractionB = fraction;\n    }\n    /**\n     * Announce point and tangent for evaluations.\n     * * The function evaluation is saved as the \"B\" function point.\n     * * The function point count is incremented\n     * * If function point count is greater than 1, the current interval is searched.\n     * * The just-evaluated point (\"B\") is saved as the \"old\" (\"A\") evaluation point.\n     * @param xyz\n     * @param fraction\n     * @param tangent\n     */\n    announcePointTangent(xyz, fraction, tangent) {\n        this.evaluateB(xyz, fraction, tangent);\n        if (this._numThisCurve++ > 0)\n            this.searchInterval();\n        this._functionA = this._functionB;\n        this._fractionA = this._fractionB;\n    }\n}\n//# sourceMappingURL=AppendPlaneIntersectionStrokeHandler.js.map",
      "start": 1693508124141,
      "end": 1693508124215,
      "sourcemaps": null
    }
  ]
}
