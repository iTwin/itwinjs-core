{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/common/lib/esm/SolarCalculate.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Utils\n */\nimport { Angle, Vector3d } from \"@itwin/core-geometry\";\n// cspell:ignore mrad sinm sint aarg\n// Code below loosely translated from  https://www.esrl.noaa.gov/gmd/grad/solcalc/\nfunction calcTimeJulianCent(jd) {\n    const T = (jd - 2451545.0) / 36525.0;\n    return T;\n}\nfunction radToDeg(angleRad) {\n    return (180.0 * angleRad / Math.PI);\n}\nfunction degToRad(angleDeg) {\n    return (Math.PI * angleDeg / 180.0);\n}\nfunction calcGeomMeanLongSun(t) {\n    let L0 = 280.46646 + t * (36000.76983 + t * (0.0003032));\n    while (L0 > 360.0) {\n        L0 -= 360.0;\n    }\n    while (L0 < 0.0) {\n        L0 += 360.0;\n    }\n    return L0; // in degrees\n}\nfunction calcGeomMeanAnomalySun(t) {\n    const M = 357.52911 + t * (35999.05029 - 0.0001537 * t);\n    return M; // in degrees\n}\nfunction calcEccentricityEarthOrbit(t) {\n    const e = 0.016708634 - t * (0.000042037 + 0.0000001267 * t);\n    return e; // unitless\n}\nfunction calcSunEqOfCenter(t) {\n    const m = calcGeomMeanAnomalySun(t);\n    const mrad = degToRad(m);\n    const sinm = Math.sin(mrad);\n    const sin2m = Math.sin(mrad + mrad);\n    const sin3m = Math.sin(mrad + mrad + mrad);\n    const C = sinm * (1.914602 - t * (0.004817 + 0.000014 * t)) + sin2m * (0.019993 - 0.000101 * t) + sin3m * 0.000289;\n    return C; // in degrees\n}\nfunction calcSunTrueLong(t) {\n    const l0 = calcGeomMeanLongSun(t);\n    const c = calcSunEqOfCenter(t);\n    const O = l0 + c;\n    return O; // in degrees\n}\nfunction calcSunApparentLong(t) {\n    const o = calcSunTrueLong(t);\n    const omega = 125.04 - 1934.136 * t;\n    const lambda = o - 0.00569 - 0.00478 * Math.sin(degToRad(omega));\n    return lambda; // in degrees\n}\nfunction calcMeanObliquityOfEcliptic(t) {\n    const seconds = 21.448 - t * (46.8150 + t * (0.00059 - t * (0.001813)));\n    const e0 = 23.0 + (26.0 + (seconds / 60.0)) / 60.0;\n    return e0; // in degrees\n}\nfunction calcObliquityCorrection(t) {\n    const e0 = calcMeanObliquityOfEcliptic(t);\n    const omega = 125.04 - 1934.136 * t;\n    const e = e0 + 0.00256 * Math.cos(degToRad(omega));\n    return e; // in degrees\n}\nfunction calcSunDeclination(t) {\n    const e = calcObliquityCorrection(t);\n    const lambda = calcSunApparentLong(t);\n    const sint = Math.sin(degToRad(e)) * Math.sin(degToRad(lambda));\n    const theta = radToDeg(Math.asin(sint));\n    return theta; // in degrees\n}\nfunction calcEquationOfTime(t) {\n    const epsilon = calcObliquityCorrection(t);\n    const l0 = calcGeomMeanLongSun(t);\n    const e = calcEccentricityEarthOrbit(t);\n    const m = calcGeomMeanAnomalySun(t);\n    let y = Math.tan(degToRad(epsilon) / 2.0);\n    y *= y;\n    const sin2l0 = Math.sin(2.0 * degToRad(l0));\n    const sinm = Math.sin(degToRad(m));\n    const cos2l0 = Math.cos(2.0 * degToRad(l0));\n    const sin4l0 = Math.sin(4.0 * degToRad(l0));\n    const sin2m = Math.sin(2.0 * degToRad(m));\n    const eTime = y * sin2l0 - 2.0 * e * sinm + 4.0 * e * y * sinm * cos2l0 - 0.5 * y * y * sin4l0 - 1.25 * e * e * sin2m;\n    return radToDeg(eTime) * 4.0; // in minutes of time\n}\nfunction calcAzEl(t, localTime, latitude, longitude, zone) {\n    const eqTime = calcEquationOfTime(t);\n    const theta = calcSunDeclination(t);\n    const solarTimeFix = eqTime + 4.0 * longitude - 60.0 * zone;\n    let trueSolarTime = localTime + solarTimeFix;\n    while (trueSolarTime > 1440)\n        trueSolarTime -= 1440;\n    let hourAngle = trueSolarTime / 4.0 - 180.0;\n    if (hourAngle < -180) {\n        hourAngle += 360.0;\n    }\n    const haRad = degToRad(hourAngle);\n    let csz = Math.sin(degToRad(latitude)) * Math.sin(degToRad(theta)) + Math.cos(degToRad(latitude)) * Math.cos(degToRad(theta)) * Math.cos(haRad);\n    if (csz > 1.0) {\n        csz = 1.0;\n    }\n    else if (csz < -1.0) {\n        csz = -1.0;\n    }\n    const zenith = radToDeg(Math.acos(csz));\n    const azDenom = (Math.cos(degToRad(latitude)) * Math.sin(degToRad(zenith)));\n    let azimuth;\n    if (Math.abs(azDenom) > 0.001) {\n        let azRad = ((Math.sin(degToRad(latitude)) * Math.cos(degToRad(zenith))) - Math.sin(degToRad(theta))) / azDenom;\n        if (Math.abs(azRad) > 1.0) {\n            if (azRad < 0) {\n                azRad = -1.0;\n            }\n            else {\n                azRad = 1.0;\n            }\n        }\n        azimuth = 180.0 - radToDeg(Math.acos(azRad));\n        if (hourAngle > 0.0) {\n            azimuth = -azimuth;\n        }\n    }\n    else {\n        if (latitude > 0.0) {\n            azimuth = 180.0;\n        }\n        else {\n            azimuth = 0.0;\n        }\n    }\n    if (azimuth < 0.0) {\n        azimuth += 360.0;\n    }\n    return { azimuth, elevation: 90 - zenith };\n}\nfunction calculateJulianDay(date) {\n    return Math.floor(date.getTime() / 86400000) + 2440587.5; // https://stackoverflow.com/questions/11759992/calculating-jdayjulian-day-in-javascript\n}\n/** @public\n * calculate solar angles (in radians) based at a given date/time and cartographic location.\n */\nexport function calculateSolarAngles(date, location) {\n    const jDay = calculateJulianDay(date);\n    const latitude = location.latitudeDegrees;\n    const longitude = location.longitudeDegrees;\n    const utcMinutes = date.getUTCHours() * 60 + date.getUTCMinutes() + date.getUTCSeconds() / 60;\n    const zone = Math.floor(.5 + longitude / 15.0); // date.getTimeZoneOffset mixes in DST.\n    const localMinutes = utcMinutes + zone * 60;\n    const jTotal = jDay + utcMinutes / 1440.0;\n    const T = calcTimeJulianCent(jTotal);\n    return calcAzEl(T, localMinutes, latitude, longitude, zone);\n}\n/** @public\n * calculate solar direction based at a given date/time and cartpgrphic location.\n */\nexport function calculateSolarDirection(date, location) {\n    return calculateSolarDirectionFromAngles(calculateSolarAngles(date, location));\n}\n/** @public\n * calculate solar direction corresponding to the given azimuth and elevation (altitude) angles in degrees.\n */\nexport function calculateSolarDirectionFromAngles(azimuthElevation) {\n    const azimuth = Angle.degreesToRadians(azimuthElevation.azimuth);\n    const elevation = Angle.degreesToRadians(azimuthElevation.elevation);\n    const cosElevation = Math.cos(elevation);\n    const sinElevation = Math.sin(elevation);\n    return Vector3d.create(-Math.sin(azimuth) * cosElevation, -Math.cos(azimuth) * cosElevation, -sinElevation);\n}\nfunction dateFromUtcMinutes(date, utcMinutes) {\n    const utcHours = Math.floor(utcMinutes / 60.0);\n    const output = new Date(date);\n    output.setUTCHours(utcHours);\n    output.setUTCMinutes(Math.floor(.5 + utcMinutes - 60.0 * utcHours));\n    output.setUTCSeconds(0);\n    return output;\n}\nfunction calcSunriseUtcMinutes(rise, lat, longitude, jDay) {\n    const t = calcTimeJulianCent(jDay);\n    const eqTime = calcEquationOfTime(t);\n    const solarDec = calcSunDeclination(t);\n    const latRad = degToRad(lat);\n    const sdRad = degToRad(solarDec);\n    const hAarg = (Math.cos(degToRad(90.833)) / (Math.cos(latRad) * Math.cos(sdRad)) - Math.tan(latRad) * Math.tan(sdRad));\n    const hourAngle = Math.acos(hAarg);\n    const delta = longitude + radToDeg(rise ? hourAngle : -hourAngle);\n    return 720 - (4.0 * delta) - eqTime; // in UTC minutes\n}\n/** @public\n * calculate solar sunrise or sunset for a given day and cartographic location.\n */\nexport function calculateSunriseOrSunset(date, location, sunrise) {\n    const jDay = calculateJulianDay(date);\n    const longitude = location.longitudeDegrees;\n    const latitude = location.latitudeDegrees;\n    const utcMinutes = calcSunriseUtcMinutes(sunrise, latitude, longitude, jDay);\n    return sunrise ? dateFromUtcMinutes(date, utcMinutes) : dateFromUtcMinutes(date, calcSunriseUtcMinutes(sunrise, latitude, longitude, jDay + utcMinutes / 1440));\n}\n//# sourceMappingURL=SolarCalculate.js.map",
      "start": 1693508120756,
      "end": 1693508120815,
      "sourcemaps": null
    }
  ]
}
