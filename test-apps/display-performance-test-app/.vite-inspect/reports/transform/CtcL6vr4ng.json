{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/topology/ChainMerge.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\nimport { LineString3d } from \"../curve/LineString3d\";\nimport { Geometry } from \"../Geometry\";\nimport { GrowableXYZArray } from \"../geometry3d/GrowableXYZArray\";\nimport { Vector3d } from \"../geometry3d/Point3dVector3d\";\nimport { HalfEdge, HalfEdgeGraph, HalfEdgeMask } from \"./Graph\";\nimport { HalfEdgeGraphOps } from \"./Merging\";\n/** Internal form of ChainMergeContextOptions -- same field names, but required to have contents. */\nclass ChainMergeContextValidatedOptions {\n    /** return a unit vector aligned with optional direction.\n     * * Default return is into the first quadrant at a quirky angle so any perpendicular plane is unlikely to hit many points\n     */\n    static createPrimarySortVector(vector) {\n        if (vector === undefined) {\n            vector = this._defaultPrimarySortDirection.clone();\n        }\n        return vector.normalizeWithDefault(ChainMergeContextValidatedOptions._defaultPrimarySortDirection.x, ChainMergeContextValidatedOptions._defaultPrimarySortDirection.y, ChainMergeContextValidatedOptions._defaultPrimarySortDirection.z);\n    }\n    /**\n     * PRIVATE constructor -- assumes all inputs are validated in public create method !!!!\n     * @param tolerance\n     * @param unitVectorForPrimarySort\n     */\n    constructor(tolerance, unitVectorForPrimarySort) {\n        this.tolerance = tolerance;\n        this.primarySortDirection = unitVectorForPrimarySort;\n    }\n    /** return the default option set. */\n    static createFromUnValidated(options) {\n        const result = new ChainMergeContextValidatedOptions(Geometry.smallMetricDistance, ChainMergeContextValidatedOptions.createPrimarySortVector());\n        if (options !== undefined) {\n            if (options.tolerance !== undefined)\n                result.tolerance = options.tolerance;\n            if (options.primarySortDirection !== undefined)\n                result.primarySortDirection = ChainMergeContextValidatedOptions.createPrimarySortVector();\n        }\n        return result;\n    }\n    /** Clone this context. */\n    clone() {\n        return new ChainMergeContextValidatedOptions(this.tolerance, this.primarySortDirection);\n    }\n}\n/** UNNORMALIZED base vector for sorting.\n * * Actual vector hoisted into an instance is normalized.\n */\nChainMergeContextValidatedOptions._defaultPrimarySortDirection = Vector3d.create(0.294234298, 0.72391399, 0.45234328798);\n/**\n * * Context for assembling line segments into chains.\n * * Use the context in phases:\n *   * Create the context:   `context = ChainMergeContext.create ()`\n *   * Add line with any combination of:\n *      * `context.addSegment(pointA, pointB)`\n *      * `context.addLineSegment3dArray (segments)`\n *   * Scan all coordinate data for common coordinates.  Twist nodes together to form chains:\n *      * `context.clusterAndMergeVerticesXYZ ()`\n *   * Collect the chains:\n *      * myLinestringArray = context.collectMaximalChains();\n * * The context carries an optional plane which is used by addSegmentsOnPlane\n *\n * @internal\n */\nexport class ChainMergeContext {\n    constructor(options) {\n        this._graph = new HalfEdgeGraph();\n        this._options = options;\n    }\n    /** Save a reference plane for later use, e.g. in addSegmentsOnPlane */\n    set plane(value) { this._plane = value; }\n    /** Property access for the reference plane. */\n    get plane() { return this._plane; }\n    /** Save a reference plane for later use, e.g. in addSegmentsOnPlane */\n    set convexClipper(value) { this._convexClipper = value; }\n    /** Property access for the reference plane. */\n    get convexClipper() { return this._convexClipper; }\n    /**\n     * * Construct an empty chain merge graph.\n     * * The options parameter may contain any combination of the options values.\n     *   * tolerance = absolute tolerance for declaring points equal.\n     *     * Default is `Geometry.smallMetricDistance`\n     *   * primarySortDirection = direction for first sort.\n     *     * To minimize clash among points on primary sort, this should NOT be perpendicular to any principal plane.\n     *     * The default points into the first octant with non-obvious components.\n     */\n    static create(options) {\n        const validatedOptions = ChainMergeContextValidatedOptions.createFromUnValidated(options);\n        return new ChainMergeContext(validatedOptions);\n    }\n    /** Add a segment to the evolving graph. */\n    addSegment(pointA, pointB) {\n        this._graph.createEdgeXYZXYZ(pointA.x, pointA.y, pointA.z, 0, pointB.x, pointB.y, pointB.z, 0);\n    }\n    /** Add all segments from an array to the graph. */\n    addLineSegment3dArray(data) {\n        for (const segment of data) {\n            this.addSegment(segment.point0Ref, segment.point1Ref);\n        }\n    }\n    /** Add edges for all segments that are \"on\" the plane.\n     * * No action if `this.plane` is undefined.\n     */\n    addSegmentsOnPlane(points, addClosure = false) {\n        if (!this._plane)\n            return;\n        const plane = this._plane;\n        let i0 = addClosure ? points.length - 1 : 0;\n        let a0 = points.evaluateUncheckedIndexPlaneAltitude(i0, plane);\n        let i1 = addClosure ? 0 : 1;\n        let a1;\n        for (; i1 < points.length; i0 = i1++, a0 = a1) {\n            a1 = points.evaluateUncheckedIndexPlaneAltitude(i1, plane);\n            if (Geometry.isSmallMetricDistance(a0) && Geometry.isSmallMetricDistance(a1))\n                this._graph.createEdgeXYZXYZ(points.getXAtUncheckedPointIndex(i0), points.getYAtUncheckedPointIndex(i0), points.getZAtUncheckedPointIndex(i0), 0, points.getXAtUncheckedPointIndex(i1), points.getYAtUncheckedPointIndex(i1), points.getZAtUncheckedPointIndex(i1), 0);\n        }\n    }\n    /**\n     * Return a numeric value to be used for sorting, with little chance widely separated nodes will have identical key.\n     * * Any single x,y,z component is a poor choice because horizontal and vertical alignment is common.\n     * * Hence take dot product of x,y,z with non-trivial fraction values.\n     * @param node node with x,y,z coordinates\n     */\n    primarySortKey(node) {\n        return this._options.primarySortDirection.dotProductXYZ(node.x, node.y, node.z);\n    }\n    /** Return difference of sortData members as sort comparison */\n    static nodeCompareSortData(nodeA, nodeB) {\n        return nodeA.sortData - nodeB.sortData;\n    }\n    /** test if nodeA is a dangling edge end (i.e. edges around vertex equal 1, but detect it without walking all the way around. */\n    static isIsolatedEnd(nodeA) {\n        return nodeA.vertexSuccessor === nodeA;\n    }\n    /** test if nodeA is at a vertex with exactly 2 edges (i.e. edges around vertex equal w, but detect it without walking all the way around. */\n    static isChainInteriorVertex(nodeA) {\n        const nodeB = nodeA.vertexSuccessor;\n        return nodeB !== nodeA && nodeB.vertexSuccessor === nodeA;\n    }\n    /**\n     * * isolate all edge ends.\n     * * perform cluster analysis to determine nearly coincident points.\n     * * pinch all edges together at each vertex.\n     */\n    clusterAndMergeVerticesXYZ() {\n        HalfEdgeGraphOps.isolateAllEdges(this._graph);\n        for (const p of this._graph.allHalfEdges) {\n            p.sortData = this.primarySortKey(p);\n        }\n        const sortArray = this._graph.allHalfEdges.slice();\n        sortArray.sort((nodeA, nodeB) => ChainMergeContext.nodeCompareSortData(nodeA, nodeB));\n        const xyzTolerance = this._options.tolerance;\n        // A node is unvisited if it is its own vertex successor !!!\n        // otherwise the node has already been twisted into a base vertex.\n        const n = sortArray.length;\n        for (let i0 = 0; i0 < n; i0++) {\n            const node0 = sortArray[i0];\n            const qMin = node0.sortData;\n            const qMax = qMin + xyzTolerance;\n            if (ChainMergeContext.isIsolatedEnd(node0)) {\n                for (let i1 = i0 + 1; i1 < n; i1++) {\n                    const node1 = sortArray[i1];\n                    if (ChainMergeContext.isIsolatedEnd(node1)) {\n                        if (node1.sortData > qMax)\n                            break;\n                        if (node0.distanceXYZ(node1) <= xyzTolerance) {\n                            HalfEdge.pinch(node0, node1);\n                            node1.setXYZFrom(node0); // force true equal coordinates.\n                        }\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * If node0 is not visited, creating a linestring with that starting edge and all successive edges along a chain.\n     * @param chains growing array of chains.\n     * @param node0 start node for search.\n     */\n    collectMaximalLineString3dFromStartNode(chains, node0, visitMask) {\n        if (!node0.isMaskSet(visitMask)) {\n            const ls = LineString3d.create();\n            ls.addPointXYZ(node0.x, node0.y, node0.z);\n            for (;;) {\n                node0.setMask(visitMask);\n                node0.edgeMate.setMask(visitMask);\n                node0 = node0.faceSuccessor;\n                ls.addPointXYZ(node0.x, node0.y, node0.z);\n                if (node0.isMaskSet(visitMask) || !ChainMergeContext.isChainInteriorVertex(node0))\n                    break;\n            }\n            chains.push(ls);\n        }\n    }\n    /**\n     * If node0 is not visited, creating a linestring with that starting edge and all successive edges along a chain.\n     * @param chains growing array of chains.\n     * @param node0 start node for search.\n     */\n    collectMaximalGrowableXYXArrayFromStartNode(result, node0, visitMask) {\n        if (!node0.isMaskSet(visitMask)) {\n            const points = new GrowableXYZArray();\n            points.pushXYZ(node0.x, node0.y, node0.z);\n            for (;;) {\n                node0.setMask(visitMask);\n                node0.edgeMate.setMask(visitMask);\n                node0 = node0.faceSuccessor;\n                points.pushXYZ(node0.x, node0.y, node0.z);\n                if (node0.isMaskSet(visitMask) || !ChainMergeContext.isChainInteriorVertex(node0))\n                    break;\n            }\n            if (points.length > 0)\n                result.push(points);\n        }\n    }\n    /**\n     * * find edges with start, end in same vertex loop.\n     * * pinch them away from the loop\n     * * set mask on both sides.\n     * * Return the number of excisions.\n     */\n    exciseAndMarkSlingEdges(mask) {\n        let n = 0;\n        for (const p of this._graph.allHalfEdges) {\n            if (p.distanceXYZ(p.edgeMate) < this._options.tolerance\n                && !p.isMaskSet(mask)) {\n                const q = p.edgeMate;\n                HalfEdge.pinch(p, p.vertexPredecessor);\n                HalfEdge.pinch(q, q.vertexPredecessor);\n                p.setMask(mask);\n                q.setMask(mask);\n                n++;\n            }\n        }\n        return n;\n    }\n    /** Collect chains which have maximum edge count, broken at an vertex with other than 2 edges.\n     * * This is assumed to be preceded by a call to a vertex-cluster step such as `clusterAndMergeVerticesYXZ`\n     */\n    collectMaximalChains() {\n        const result = [];\n        const visitMask = HalfEdgeMask.VISITED;\n        // Pass 0: excise and mark zero-length edges.\n        this.exciseAndMarkSlingEdges(visitMask);\n        this._graph.clearMask(visitMask);\n        // Pass 1: only start at non-interior edges -- vertices with one edge or more than 2 edges.\n        // (Note that collectMaximalChain checks the visit mask.)\n        for (const node0 of this._graph.allHalfEdges) {\n            if (!ChainMergeContext.isChainInteriorVertex(node0)) {\n                this.collectMaximalLineString3dFromStartNode(result, node0, visitMask);\n            }\n        }\n        // Pass 2: start anywhere in an unvisited loop.\n        for (const node0 of this._graph.allHalfEdges) {\n            this.collectMaximalLineString3dFromStartNode(result, node0, visitMask);\n        }\n        return result;\n    }\n    collectMaximalGrowableXYZArrays() {\n        const result = [];\n        const visitMask = HalfEdgeMask.VISITED;\n        // Pass 0: excise and mark zero-length edges.\n        this.exciseAndMarkSlingEdges(visitMask);\n        this._graph.clearMask(visitMask);\n        // Pass 1: only start at non-interior edges -- vertices with one edge or more than 2 edges.\n        // (Note that collectMaximalChain checks the visit mask.)\n        for (const node0 of this._graph.allHalfEdges) {\n            if (!ChainMergeContext.isChainInteriorVertex(node0)) {\n                this.collectMaximalGrowableXYXArrayFromStartNode(result, node0, visitMask);\n            }\n        }\n        // Pass 2: start anywhere in an unvisited loop.\n        for (const node0 of this._graph.allHalfEdges) {\n            this.collectMaximalGrowableXYXArrayFromStartNode(result, node0, visitMask);\n        }\n        return result;\n    }\n}\n//# sourceMappingURL=ChainMerge.js.map",
      "start": 1693508124319,
      "end": 1693508124411,
      "sourcemaps": null
    }
  ]
}
