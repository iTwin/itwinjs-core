{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/RenderState.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { GL } from \"./GL\";\nimport { System } from \"./System\";\n/** @internal */\nexport class RenderStateFlags {\n    constructor(src) {\n        this.cull = false;\n        this.depthTest = false;\n        this.blend = false;\n        this.stencilTest = false;\n        this.depthMask = true;\n        this.colorWrite = true;\n        if (src) {\n            this.copyFrom(src);\n        }\n    }\n    copyFrom(src) {\n        this.cull = src.cull;\n        this.depthTest = src.depthTest;\n        this.blend = src.blend;\n        this.stencilTest = src.stencilTest;\n        this.depthMask = src.depthMask;\n        this.colorWrite = src.colorWrite;\n    }\n    clone(result) {\n        if (!result) {\n            return new RenderStateFlags(this);\n        }\n        else {\n            result.copyFrom(this);\n            return result;\n        }\n    }\n    equals(rhs) {\n        return this.cull === rhs.cull\n            && this.depthTest === rhs.depthTest\n            && this.blend === rhs.blend\n            && this.stencilTest === rhs.stencilTest\n            && this.depthMask === rhs.depthMask\n            && this.colorWrite === rhs.colorWrite;\n    }\n    apply(previousFlags) {\n        RenderStateFlags.enableOrDisable(this.cull, GL.Capability.CullFace, previousFlags.cull);\n        RenderStateFlags.enableOrDisable(this.depthTest, GL.Capability.DepthTest, previousFlags.depthTest);\n        RenderStateFlags.enableOrDisable(this.blend, GL.Capability.Blend, previousFlags.blend);\n        RenderStateFlags.enableOrDisable(this.stencilTest, GL.Capability.StencilTest, previousFlags.stencilTest);\n        if (previousFlags.depthMask !== this.depthMask) {\n            System.instance.context.depthMask(this.depthMask);\n        }\n        if (previousFlags.colorWrite !== this.colorWrite) {\n            System.instance.context.colorMask(this.colorWrite, this.colorWrite, this.colorWrite, this.colorWrite);\n        }\n    }\n    static enableOrDisable(currentFlag, value, previousFlag) {\n        if (currentFlag !== previousFlag) {\n            const gl = System.instance.context;\n            if (currentFlag) {\n                gl.enable(value);\n            }\n            else {\n                gl.disable(value);\n            }\n        }\n    }\n}\n/** @internal */\nexport class RenderStateBlend {\n    constructor(src) {\n        this.color = [0.0, 0.0, 0.0, 0.0];\n        this.equationRgb = GL.BlendEquation.Default;\n        this.equationAlpha = GL.BlendEquation.Default;\n        this.functionSourceRgb = GL.BlendFactor.DefaultSrc;\n        this.functionSourceAlpha = GL.BlendFactor.DefaultSrc;\n        this.functionDestRgb = GL.BlendFactor.DefaultDst;\n        this.functionDestAlpha = GL.BlendFactor.DefaultDst;\n        if (src) {\n            this.copyFrom(src);\n        }\n    }\n    apply(previousBlend) {\n        const gl = System.instance.context;\n        if (previousBlend === undefined || !this.equalColors(previousBlend)) {\n            gl.blendColor(this.color[0], this.color[1], this.color[2], this.color[3]);\n        }\n        if (previousBlend === undefined || previousBlend.equationRgb !== this.equationRgb || previousBlend.equationAlpha !== this.equationAlpha) {\n            gl.blendEquationSeparate(this.equationRgb, this.equationAlpha);\n        }\n        if (previousBlend === undefined || previousBlend.functionSourceRgb !== this.functionSourceRgb || previousBlend.functionSourceAlpha !== this.functionSourceAlpha\n            || previousBlend.functionDestRgb !== this.functionDestRgb || previousBlend.functionDestAlpha !== this.functionDestAlpha) {\n            gl.blendFuncSeparate(this.functionSourceRgb, this.functionDestRgb, this.functionSourceAlpha, this.functionDestAlpha);\n        }\n    }\n    copyFrom(src) {\n        this.setColor(src.color);\n        this.equationRgb = src.equationRgb;\n        this.equationAlpha = src.equationAlpha;\n        this.functionSourceRgb = src.functionSourceRgb;\n        this.functionSourceAlpha = src.functionSourceAlpha;\n        this.functionDestRgb = src.functionDestRgb;\n        this.functionDestAlpha = src.functionDestAlpha;\n    }\n    clone(result) {\n        if (!result) {\n            return new RenderStateBlend(this);\n        }\n        else {\n            result.copyFrom(this);\n            return result;\n        }\n    }\n    equals(rhs) {\n        return this.equalColors(rhs)\n            && this.equationRgb === rhs.equationRgb\n            && this.equationAlpha === rhs.equationAlpha\n            && this.functionSourceRgb === rhs.functionSourceRgb\n            && this.functionSourceAlpha === rhs.functionSourceAlpha\n            && this.functionDestRgb === rhs.functionDestRgb\n            && this.functionDestAlpha === rhs.functionDestAlpha;\n    }\n    equalColors(rhs) {\n        return this.color[0] === rhs.color[0] &&\n            this.color[1] === rhs.color[1] &&\n            this.color[2] === rhs.color[2] &&\n            this.color[3] === rhs.color[3];\n    }\n    setColor(color) {\n        this.color[0] = color[0];\n        this.color[1] = color[1];\n        this.color[2] = color[2];\n        this.color[3] = color[3];\n    }\n    setBlendFunc(src, dst) {\n        this.setBlendFuncSeparate(src, src, dst, dst);\n    }\n    setBlendFuncSeparate(srcRgb, srcAlpha, dstRgb, dstAlpha) {\n        this.functionSourceRgb = srcRgb;\n        this.functionSourceAlpha = srcAlpha;\n        this.functionDestRgb = dstRgb;\n        this.functionDestAlpha = dstAlpha;\n    }\n}\n/** @internal */\nexport class RenderStateStencilOperation {\n    constructor(src) {\n        this.fail = GL.StencilOperation.Default;\n        this.zFail = GL.StencilOperation.Default;\n        this.zPass = GL.StencilOperation.Default;\n        if (src) {\n            this.copyFrom(src);\n        }\n    }\n    copyFrom(src) {\n        this.fail = src.fail;\n        this.zFail = src.zFail;\n        this.zPass = src.zPass;\n    }\n    clone(result) {\n        if (!result) {\n            return new RenderStateStencilOperation(this);\n        }\n        else {\n            result.copyFrom(this);\n            return result;\n        }\n    }\n    equals(rhs) {\n        return this.fail === rhs.fail\n            && this.zFail === rhs.zFail\n            && this.zPass === rhs.zPass;\n    }\n}\n/** @internal */\nexport class RenderStateStencilFunction {\n    constructor(src) {\n        this.function = GL.StencilFunction.Default;\n        this.ref = 0;\n        this.mask = 0xFFFFFFFF;\n        if (src) {\n            this.copyFrom(src);\n        }\n    }\n    copyFrom(src) {\n        this.function = src.function;\n        this.ref = src.ref;\n        this.mask = src.mask;\n    }\n    clone(result) {\n        if (!result) {\n            return new RenderStateStencilFunction(this);\n        }\n        else {\n            result.copyFrom(this);\n            return result;\n        }\n    }\n    equals(rhs) {\n        return this.function === rhs.function\n            && this.ref === rhs.ref\n            && this.mask === rhs.mask;\n    }\n}\n/** @internal */\nexport class RenderStateStencil {\n    constructor(src) {\n        this.frontFunction = new RenderStateStencilFunction();\n        this.backFunction = new RenderStateStencilFunction();\n        this.frontOperation = new RenderStateStencilOperation();\n        this.backOperation = new RenderStateStencilOperation();\n        if (src) {\n            this.copyFrom(src);\n        }\n    }\n    apply(previousStencil) {\n        const gl = System.instance.context;\n        if (previousStencil === undefined || !previousStencil.frontFunction.equals(this.frontFunction)) {\n            gl.stencilFuncSeparate(GL.CullFace.Front, this.frontFunction.function, this.frontFunction.ref, this.frontFunction.mask);\n        }\n        if (previousStencil === undefined || !previousStencil.backFunction.equals(this.backFunction)) {\n            gl.stencilFuncSeparate(GL.CullFace.Back, this.backFunction.function, this.backFunction.ref, this.backFunction.mask);\n        }\n        if (previousStencil === undefined || !previousStencil.frontOperation.equals(this.frontOperation)) {\n            gl.stencilOpSeparate(GL.CullFace.Front, this.frontOperation.fail, this.frontOperation.zFail, this.frontOperation.zPass);\n        }\n        if (previousStencil === undefined || !previousStencil.backOperation.equals(this.backOperation)) {\n            gl.stencilOpSeparate(GL.CullFace.Back, this.backOperation.fail, this.backOperation.zFail, this.backOperation.zPass);\n        }\n    }\n    copyFrom(src) {\n        this.frontFunction.copyFrom(src.frontFunction);\n        this.backFunction.copyFrom(src.backFunction);\n        this.frontOperation.copyFrom(src.frontOperation);\n        this.backOperation.copyFrom(src.backOperation);\n    }\n    clone(result) {\n        if (!result) {\n            return new RenderStateStencil(this);\n        }\n        else {\n            result.copyFrom(this);\n            return result;\n        }\n    }\n    equals(rhs) {\n        return this.frontFunction.equals(rhs.frontFunction)\n            && this.backFunction.equals(rhs.backFunction)\n            && this.frontOperation.equals(rhs.frontOperation)\n            && this.backOperation.equals(rhs.backOperation);\n    }\n}\n/** Encapsulates the state of an OpenGL context.\n * to modify the context for a rendering operation, do *not* directly call\n * functions like glDepthMask(), glBlendFunc(), etc - otherwise such calls may adversely\n * affect subsequent rendering operations.\n * Instead, set up a RenderState as desired and invoke System.instance.applyRenderState()\n * The context tracks the most-recently applied RenderState, allowing it to minimize\n * the number of GL state changes actually invoked, improving performance.\n * @internal\n */\nclass RenderState {\n    constructor(src) {\n        this.flags = new RenderStateFlags();\n        this.blend = new RenderStateBlend();\n        this.stencil = new RenderStateStencil();\n        this.frontFace = GL.FrontFace.Default;\n        this.cullFace = GL.CullFace.Default;\n        this.depthFunc = GL.DepthFunc.Default;\n        this.stencilMask = 0xFFFFFFFF;\n        if (src) {\n            this.copyFrom(src);\n        }\n    }\n    copyFrom(src) {\n        this.flags.copyFrom(src.flags);\n        this.blend.copyFrom(src.blend);\n        this.stencil.copyFrom(src.stencil);\n        this.frontFace = src.frontFace;\n        this.cullFace = src.cullFace;\n        this.depthFunc = src.depthFunc;\n        this.stencilMask = src.stencilMask;\n    }\n    clone(result) {\n        if (!result) {\n            return new RenderState(this);\n        }\n        else {\n            result.copyFrom(this);\n            return result;\n        }\n    }\n    set clockwiseFrontFace(clockwise) {\n        this.frontFace = clockwise ? GL.FrontFace.Clockwise : GL.FrontFace.CounterClockwise;\n    }\n    equals(rhs) {\n        return this.flags.equals(rhs.flags)\n            && this.blend.equals(rhs.blend)\n            && this.stencil.equals(rhs.stencil)\n            && this.frontFace === rhs.frontFace\n            && this.cullFace === rhs.cullFace\n            && this.depthFunc === rhs.depthFunc\n            && this.stencilMask === rhs.stencilMask;\n    }\n    apply(prevState) {\n        this.flags.apply(prevState.flags);\n        if (this.flags.blend) {\n            if (prevState.flags.blend)\n                this.blend.apply(prevState.blend);\n            else\n                this.blend.apply();\n        }\n        if (this.flags.cull) {\n            if (!prevState.flags.cull || prevState.cullFace !== this.cullFace) {\n                System.instance.context.cullFace(this.cullFace);\n            }\n        }\n        if (this.flags.depthTest) {\n            if (!prevState.flags.depthTest || prevState.depthFunc !== this.depthFunc) {\n                System.instance.context.depthFunc(this.depthFunc);\n            }\n        }\n        if (this.flags.stencilTest) {\n            if (prevState.flags.stencilTest)\n                this.stencil.apply(prevState.stencil);\n            else\n                this.stencil.apply();\n        }\n        if (this.frontFace !== prevState.frontFace) {\n            System.instance.context.frontFace(this.frontFace);\n        }\n        if (this.stencilMask !== prevState.stencilMask) {\n            System.instance.context.stencilMask(this.stencilMask);\n        }\n    }\n}\nRenderState.defaults = new RenderState();\nexport { RenderState };\nObject.freeze(RenderState.defaults);\n//# sourceMappingURL=RenderState.js.map",
      "start": 1693508121165,
      "end": 1693508121423,
      "sourcemaps": null
    }
  ]
}
