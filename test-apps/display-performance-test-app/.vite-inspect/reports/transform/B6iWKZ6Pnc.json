{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tile/map/MapLayerImageryFormats.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import { ArcGISMapLayerImageryProvider, ArcGisUtilities, AzureMapsLayerImageryProvider, BingMapsImageryLayerProvider, ImageryMapLayerTreeReference, MapBoxLayerImageryProvider, MapLayerFormat, MapLayerSourceStatus, TileUrlImageryProvider, WmsCapabilities, WmsMapLayerImageryProvider, WmtsCapabilities, WmtsMapLayerImageryProvider, } from \"../internal\";\n/** Base class imagery map layer formats.\n *  Subclasses should override formatId and [[MapLayerFormat.createImageryProvider]].\n * @see [[MapLayerFormat]]\n * @beta\n */\nexport class ImageryMapLayerFormat extends MapLayerFormat {\n    /** @internal */\n    static createMapLayerTree(layerSettings, layerIndex, iModel) {\n        return new ImageryMapLayerTreeReference(layerSettings, layerIndex, iModel);\n    }\n}\nclass WmsMapLayerFormat extends ImageryMapLayerFormat {\n    static createImageryProvider(settings) {\n        return new WmsMapLayerImageryProvider(settings);\n    }\n    static async validateSource(url, userName, password, ignoreCache) {\n        try {\n            let subLayers;\n            const maxVisibleSubLayers = 50;\n            const capabilities = await WmsCapabilities.create(url, (userName && password ? { user: userName, password } : undefined), ignoreCache);\n            if (capabilities !== undefined) {\n                subLayers = capabilities.getSubLayers(false);\n                const rootsSubLayer = subLayers?.find((sublayer) => sublayer.parent === undefined);\n                const hasTooManyLayers = subLayers && subLayers.length > maxVisibleSubLayers;\n                if (!Array.isArray(subLayers))\n                    return { status: MapLayerSourceStatus.Valid, subLayers };\n                for (const subLayer of subLayers) {\n                    // In general for WMS, we prefer to have the children of root node visible, but not the root itself.\n                    // Thats simply to give more flexibility in the UI.\n                    // Two exceptions to this rule: If there are too many layers or the root node is not named.\n                    if (subLayer.id && subLayer.id === rootsSubLayer?.id\n                        && (!(subLayer.name && subLayer.name.length > 0) || hasTooManyLayers)) {\n                        subLayer.visible = true;\n                        break; // if root node is visible, don't bother turning ON any other layers\n                    }\n                    // Make children of the root node visible.\n                    if (subLayer.parent && subLayer.parent === rootsSubLayer?.id && !hasTooManyLayers) {\n                        const isUnnamedGroup = (layer) => {\n                            return layer.children && layer.children.length > 0 && (!layer.name || layer.name.length === 0);\n                        };\n                        const makeChildrenVisible = (layers, layer) => {\n                            layer?.children?.forEach((childId) => {\n                                const childSubLayer = subLayers?.find((child) => child?.id === childId);\n                                if (childSubLayer) {\n                                    childSubLayer.visible = true;\n                                    if (isUnnamedGroup(childSubLayer))\n                                        makeChildrenVisible(layers, childSubLayer);\n                                }\n                            });\n                        };\n                        subLayer.visible = true;\n                        // If we got a unnamed group, make children visible recursively until we have a leaf or named group\n                        if (isUnnamedGroup(subLayer))\n                            makeChildrenVisible(subLayers, subLayer);\n                    }\n                }\n            }\n            return { status: MapLayerSourceStatus.Valid, subLayers };\n        }\n        catch (err) {\n            let status = MapLayerSourceStatus.InvalidUrl;\n            if (err?.status === 401) {\n                status = ((userName && password) ? MapLayerSourceStatus.InvalidCredentials : MapLayerSourceStatus.RequireAuth);\n            }\n            return { status };\n        }\n    }\n}\nWmsMapLayerFormat.formatId = \"WMS\";\nclass WmtsMapLayerFormat extends ImageryMapLayerFormat {\n    static createImageryProvider(settings) {\n        return new WmtsMapLayerImageryProvider(settings);\n    }\n    static async validateSource(url, userName, password, ignoreCache) {\n        try {\n            const subLayers = [];\n            const capabilities = await WmtsCapabilities.create(url, (userName && password ? { user: userName, password } : undefined), ignoreCache);\n            if (!capabilities)\n                return { status: MapLayerSourceStatus.InvalidUrl };\n            // Only returns layer that can be published in the Google maps or WGS84 aligned tile trees.\n            let supportedTms = [];\n            const googleMapsTms = capabilities?.contents?.getGoogleMapsCompatibleTileMatrixSet();\n            if (googleMapsTms) {\n                supportedTms = googleMapsTms;\n            }\n            const wsg84Tms = capabilities?.contents?.getEpsg4326CompatibleTileMatrixSet();\n            if (wsg84Tms) {\n                supportedTms = supportedTms.concat(wsg84Tms);\n            }\n            if (supportedTms.length === 0) {\n                // This WMTS server doesn't support either GoogleMaps or WSG84\n                return { status: MapLayerSourceStatus.InvalidCoordinateSystem };\n            }\n            let subLayerId = 0;\n            capabilities?.contents?.layers.forEach((layer) => {\n                const hasSupportedTms = supportedTms?.some((tms) => {\n                    return layer.tileMatrixSetLinks.some((tmls) => tmls.tileMatrixSet === tms.identifier);\n                });\n                if (hasSupportedTms) {\n                    subLayers.push({\n                        name: layer.identifier,\n                        title: layer.title ?? layer.identifier,\n                        visible: (subLayers.length === 0),\n                        parent: undefined,\n                        children: undefined,\n                        id: subLayerId++,\n                    });\n                }\n            });\n            // Return error if we could find a single compatible layer.\n            if (subLayers.length === 0)\n                return { status: MapLayerSourceStatus.InvalidTileTree };\n            return { status: MapLayerSourceStatus.Valid, subLayers };\n        }\n        catch (err) {\n            console.error(err); // eslint-disable-line no-console\n            return { status: MapLayerSourceStatus.InvalidUrl };\n        }\n    }\n}\nWmtsMapLayerFormat.formatId = \"WMTS\";\nclass ArcGISMapLayerFormat extends ImageryMapLayerFormat {\n    static async validateSource(url, userName, password, ignoreCache) {\n        const urlValidation = ArcGisUtilities.validateUrl(url, \"MapServer\");\n        if (urlValidation !== MapLayerSourceStatus.Valid)\n            return { status: urlValidation };\n        // Some Map service supporting only tiles don't include the 'Map' capabilities, thus we can't make it mandatory.\n        return ArcGisUtilities.validateSource(url, this.formatId, [], userName, password, ignoreCache);\n    }\n    static createImageryProvider(settings) {\n        return new ArcGISMapLayerImageryProvider(settings);\n    }\n}\nArcGISMapLayerFormat.formatId = \"ArcGIS\";\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nclass AzureMapsMapLayerFormat extends ImageryMapLayerFormat {\n    static createImageryProvider(settings) {\n        return new AzureMapsLayerImageryProvider(settings);\n    }\n}\nAzureMapsMapLayerFormat.formatId = \"AzureMaps\";\nclass BingMapsMapLayerFormat extends ImageryMapLayerFormat {\n    static createImageryProvider(settings) {\n        return new BingMapsImageryLayerProvider(settings);\n    }\n}\nBingMapsMapLayerFormat.formatId = \"BingMaps\";\nclass MapBoxImageryMapLayerFormat extends ImageryMapLayerFormat {\n    static createImageryProvider(settings) {\n        return new MapBoxLayerImageryProvider(settings);\n    }\n}\nMapBoxImageryMapLayerFormat.formatId = \"MapboxImagery\";\nclass TileUrlMapLayerFormat extends ImageryMapLayerFormat {\n    static createImageryProvider(settings) { return new TileUrlImageryProvider(settings); }\n}\nTileUrlMapLayerFormat.formatId = \"TileURL\";\n/** @internal */\nexport const internalMapLayerImageryFormats = [WmsMapLayerFormat, WmtsMapLayerFormat, ArcGISMapLayerFormat, /* AzureMapsMapLayerFormat, */ BingMapsMapLayerFormat, MapBoxImageryMapLayerFormat, TileUrlMapLayerFormat];\n//# sourceMappingURL=MapLayerImageryFormats.js.map",
      "start": 1693508121822,
      "end": 1693508121912,
      "sourcemaps": null
    }
  ]
}
