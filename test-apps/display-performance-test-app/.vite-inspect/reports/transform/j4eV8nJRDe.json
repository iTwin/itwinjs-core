{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/ViewingSpace.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Views\n */\nimport { AxisOrder, ClipPlaneContainment, Constant, Map4d, Matrix3d, Plane3dByOriginAndUnitNormal, Point3d, Range1d, Range2d, Range3d, Transform, Vector3d, } from \"@itwin/core-geometry\";\nimport { Frustum, GridOrientationType, Npc, NpcCorners } from \"@itwin/core-common\";\nimport { ApproximateTerrainHeights } from \"./ApproximateTerrainHeights\";\nimport { CoordSystem } from \"./CoordSystem\";\nimport { ViewRect } from \"./common/ViewRect\";\nimport { Frustum2d } from \"./Frustum2d\";\nimport { getFrustumPlaneIntersectionDepthRange } from \"./BackgroundMapGeometry\";\n/** Describes a [[Viewport]]'s viewing volume, plus its size on the screen. A new\n * instance of ViewingSpace is created every time the Viewport's frustum changes.\n * @see [[Viewport.viewingSpace]].\n * @public\n * @extensions\n */\nclass ViewingSpace {\n    /** The ViewState for this Viewport */\n    get view() { return this._view; }\n    set view(view) { this._view = view; }\n    /** Get the rectangle of this Viewport in ViewCoordinates. */\n    get _viewRect() {\n        this._viewRange.init(0, 0, this._clientWidth, this._clientHeight);\n        return this._viewRange;\n    }\n    static _copyOutput(from, to) {\n        let pt = from;\n        if (to) {\n            to.setFrom(from);\n            pt = to;\n        }\n        return pt;\n    }\n    /** @internal */\n    toViewOrientation(from, to) { this.rotation.multiplyVectorInPlace(ViewingSpace._copyOutput(from, to)); }\n    /** @internal */\n    fromViewOrientation(from, to) { this.rotation.multiplyTransposeVectorInPlace(ViewingSpace._copyOutput(from, to)); }\n    /** Ensure the rotation matrix for this view is aligns the root z with the view out (i.e. a \"2d view\"). */\n    alignWithRootZ() {\n        const zUp = Vector3d.unitZ();\n        if (zUp.isAlmostEqual(this.rotation.rowZ()))\n            return;\n        const r = this.rotation.transpose();\n        r.setColumn(2, zUp);\n        Matrix3d.createRigidFromMatrix3d(r, AxisOrder.ZXY, r);\n        r.transpose(this.rotation);\n        this.view.setRotation(this.rotation); // Don't let viewState and viewport rotation be different.\n    }\n    validateCamera() {\n        const view = this.view;\n        if (!view.is3d())\n            return;\n        const camera = view.camera;\n        camera.validateLens();\n        if (camera.isFocusValid)\n            return;\n        const vDelta = view.getExtents();\n        const maxDelta = vDelta.x > vDelta.y ? vDelta.x : vDelta.y;\n        let focusDistance = maxDelta / (2.0 * Math.tan(camera.getLensAngle().radians / 2.0));\n        if (focusDistance < vDelta.z / 2.0)\n            focusDistance = vDelta.z / 2.0;\n        const eyePoint = new Point3d(vDelta.x / 2.0, vDelta.y / 2.0, (vDelta.z / 2.0) + focusDistance);\n        this.fromViewOrientation(eyePoint);\n        eyePoint.plus(view.getOrigin(), eyePoint);\n        camera.setEyePoint(eyePoint);\n        camera.setFocusDistance(focusDistance);\n    }\n    /** @internal */\n    getTerrainHeightRange() {\n        const frustum = this.getFrustum();\n        const cartoRange = Range2d.createNull();\n        for (let i = 0; i < 8; i++) {\n            const corner = frustum.getCorner(i);\n            const carto = this.view.iModel.spatialToCartographicFromEcef(corner);\n            cartoRange.extendXY(carto.longitude, carto.latitude);\n        }\n        return ApproximateTerrainHeights.instance.getMinimumMaximumHeights(cartoRange);\n    }\n    /** Adjust the front and back planes to encompass the entire viewed volume */\n    adjustZPlanes(origin, delta) {\n        const view = this.view;\n        if (!view.is3d()) // only necessary for 3d views\n            return;\n        delta.z = Math.max(delta.z, ViewingSpace._minDepth);\n        const extents = view.getViewedExtents();\n        const frustum = new Frustum();\n        const worldToNpc = this.view.computeWorldToNpc(this.rotation, this.viewOrigin, this.viewDelta, false).map;\n        if (worldToNpc === undefined)\n            return;\n        worldToNpc.transform1.multiplyPoint3dArrayQuietNormalize(frustum.points);\n        const clipPlanes = frustum.getRangePlanes(false, false, 0);\n        const viewedExtentCorners = extents.corners();\n        // Only extend depth to include viewed geometry if it is within the frustum. (if viewing global locations).\n        if (clipPlanes.classifyPointContainment(viewedExtentCorners, false) === ClipPlaneContainment.StronglyOutside)\n            extents.setNull();\n        let depthRange;\n        let gridPlane;\n        if (this.view.viewFlags.grid) {\n            const gridOrigin = this.view.isSpatialView() ? this.view.iModel.globalOrigin : Point3d.create();\n            switch (this.view.getGridOrientation()) {\n                case GridOrientationType.WorldXY:\n                    gridPlane = Plane3dByOriginAndUnitNormal.create(gridOrigin, Vector3d.create(0, 0, 1));\n                    break;\n                case GridOrientationType.WorldYZ:\n                    gridPlane = Plane3dByOriginAndUnitNormal.create(gridOrigin, Vector3d.create(1, 0, 0));\n                    break;\n                case GridOrientationType.WorldXZ:\n                    gridPlane = Plane3dByOriginAndUnitNormal.create(gridOrigin, Vector3d.create(0, 1, 0));\n                    break;\n                case GridOrientationType.AuxCoord:\n                    if (this.view.auxiliaryCoordinateSystem)\n                        gridPlane = Plane3dByOriginAndUnitNormal.create(gridOrigin, this.view.auxiliaryCoordinateSystem.getRotation().rowZ());\n                    break;\n            }\n        }\n        const globalGeometry = this.view.displayStyle.getGlobalGeometryAndHeightRange();\n        if (undefined !== globalGeometry) {\n            const viewZ = this.rotation.getRow(2);\n            const eyeDepth = this.eyePoint ? viewZ.dotProduct(this.eyePoint) : undefined;\n            depthRange = globalGeometry.geometry.getFrustumIntersectionDepthRange(frustum, extents, globalGeometry.heightRange, gridPlane, this.view.maxGlobalScopeFactor > 1);\n            if (eyeDepth !== undefined) {\n                const maxBackgroundFrontBackRatio = 1.0E6;\n                const frontDist = Math.max(.1, eyeDepth - depthRange.high);\n                const backDist = eyeDepth - depthRange.low;\n                if (backDist / frontDist > maxBackgroundFrontBackRatio)\n                    depthRange.high = eyeDepth - backDist / maxBackgroundFrontBackRatio;\n            }\n        }\n        else\n            depthRange = gridPlane ? getFrustumPlaneIntersectionDepthRange(frustum, gridPlane) : Range1d.createNull();\n        if (!extents.isNull) {\n            const viewZ = this.rotation.getRow(2);\n            const corners = extents.corners();\n            for (const corner of corners)\n                depthRange.extendX(viewZ.dotProduct(corner));\n        }\n        if (depthRange.isNull)\n            return;\n        this.rotation.multiplyVectorInPlace(origin); // put origin in view coordinates\n        origin.z = depthRange.low; // set origin to back of viewed extents\n        delta.z = Math.max(depthRange.high - depthRange.low, ViewingSpace._minDepth); // and delta to front of viewed extents\n        this.rotation.multiplyTransposeVectorInPlace(origin);\n        if (!view.isCameraOn)\n            return;\n        // if the camera is on, we need to make sure that the viewed volume is not behind the eye\n        const eyeOrg = this.eyePoint.minus(origin);\n        this.rotation.multiplyVectorInPlace(eyeOrg);\n        // if the distance from the eye to origin in less than 1 meter, move the origin away from the eye. Usually, this means\n        // that the camera is outside the viewed extents and pointed away from it. There's nothing to see anyway.\n        if (eyeOrg.z < 1.0) {\n            this.rotation.multiplyVectorInPlace(origin);\n            origin.z -= (2.0 - eyeOrg.z);\n            this.rotation.multiplyTransposeVectorInPlace(origin);\n            delta.z = 1.0;\n            return;\n        }\n        // if part of the viewed extents are behind the eye, don't include that.\n        if (delta.z > eyeOrg.z)\n            delta.z = eyeOrg.z;\n    }\n    /* get the mapping from NPC to view\n     * @internal\n     */\n    calcNpcToView() {\n        const corners = this.getViewCorners();\n        const map = Map4d.createBoxMap(NpcCorners[Npc._000], NpcCorners[Npc._111], corners.low, corners.high);\n        // The map may be undefined if the view rect's width or height is zero.\n        return undefined === map ? Map4d.createIdentity() : map;\n    }\n    /* Get the extents of this view, in ViewCoordinates, as a Range3d */\n    getViewCorners() {\n        const corners = this._viewCorners;\n        const viewRect = this._viewRect;\n        corners.high.x = viewRect.right;\n        corners.low.y = viewRect.bottom; // y's are swapped on the screen!\n        corners.low.x = 0;\n        corners.high.y = 0;\n        corners.low.z = -32767;\n        corners.high.z = 32767;\n        return corners;\n    }\n    constructor(vp) {\n        this._viewRange = new ViewRect(); // scratch variable\n        this._viewCorners = new Range3d(); // scratch variable\n        /** @internal */\n        this.frustFraction = 1.0;\n        /** View origin, potentially expanded */\n        this.viewOrigin = new Point3d();\n        /** View delta, potentially expanded */\n        this.viewDelta = new Vector3d();\n        /** View origin (from ViewState, unexpanded) */\n        this.viewOriginUnexpanded = new Point3d();\n        /** View delta (from ViewState, unexpanded) */\n        this.viewDeltaUnexpanded = new Vector3d();\n        /** View rotation matrix (copied from ViewState) */\n        this.rotation = new Matrix3d();\n        /** Provides conversions between world and view coordinates. */\n        this.worldToViewMap = Map4d.createIdentity();\n        /** Providers conversions between world and Npc (non-dimensional perspective) coordinates. */\n        this.worldToNpcMap = Map4d.createIdentity();\n        /** @internal */\n        this.zClipAdjusted = false; // were the view z clip planes adjusted due to front/back clipping off?\n        const view = this._view = vp.view;\n        const viewRect = vp.viewRect;\n        this._clientWidth = viewRect.width;\n        this._clientHeight = viewRect.height;\n        const origin = view.getOrigin().clone();\n        const delta = view.getExtents().clone();\n        this.rotation.setFrom(view.getRotation());\n        // first, make sure none of the deltas are negative\n        delta.x = Math.abs(delta.x);\n        delta.y = Math.abs(delta.y);\n        delta.z = Math.abs(delta.z);\n        this.viewOriginUnexpanded.setFrom(origin);\n        this.viewDeltaUnexpanded.setFrom(delta);\n        this.viewOrigin.setFrom(origin);\n        this.viewDelta.setFrom(delta);\n        this.zClipAdjusted = false;\n        this.eyePoint = undefined;\n        if (view.is3d()) {\n            if (!view.allow3dManipulations()) {\n                // we're in a \"2d\" view of a physical model. That means that we must have our orientation with z out of the screen with z=0 at the center.\n                this.alignWithRootZ(); // make sure we're in a z Up view\n                const extents = view.getViewedExtents();\n                if (extents.isNull) {\n                    extents.low.z = Frustum2d.minimumZExtents.low;\n                    extents.high.z = Frustum2d.minimumZExtents.high;\n                }\n                let zMax = Math.max(Math.abs(extents.low.z), Math.abs(extents.high.z));\n                zMax = Math.max(zMax, 1.0); // make sure we have at least +-1m. Data may be purely planar\n                delta.z = 2.0 * zMax;\n                origin.z = -zMax;\n            }\n            else {\n                if (view.isCameraOn)\n                    this.validateCamera();\n                if (view.isCameraOn)\n                    this.eyePoint = view.camera.getEyePoint().clone();\n                this.adjustZPlanes(origin, delta); // make sure view volume includes entire volume of view\n                // if the camera is on, don't allow front plane behind camera\n                if (this.eyePoint) {\n                    const eyeOrg = this.eyePoint.minus(origin); // vector from eye to origin\n                    this.toViewOrientation(eyeOrg);\n                    const frontDist = eyeOrg.z - delta.z; // front distance is backDist - delta.z\n                    // allow ViewState to specify a minimum front dist, but in no case less than 6 inches\n                    const minFrontDist = Math.max(15.2 * Constant.oneCentimeter, view.forceMinFrontDist);\n                    if (frontDist < minFrontDist) {\n                        // camera is too close to front plane, move origin away from eye to maintain a minimum front distance.\n                        this.toViewOrientation(origin);\n                        origin.z -= (minFrontDist - frontDist);\n                        this.fromViewOrientation(origin);\n                    }\n                }\n                // if we moved the z planes, set the \"zClipAdjusted\" flag.\n                if (!origin.isExactEqual(this.viewOriginUnexpanded) || !delta.isExactEqual(this.viewDeltaUnexpanded))\n                    this.zClipAdjusted = true;\n            }\n        }\n        else { // 2d viewport\n            this.alignWithRootZ();\n        }\n        this.viewOrigin.setFrom(origin);\n        this.viewDelta.setFrom(delta);\n        const newRootToNpc = this.view.computeWorldToNpc(this.rotation, origin, delta, !this.view.displayStyle.getIsBackgroundMapVisible() /* if displaying background map, don't enforce front/back ratio as no Z-Buffer */);\n        if (newRootToNpc.map === undefined) {\n            this.frustFraction = 0; // invalid frustum\n            return;\n        }\n        this.worldToNpcMap.setFrom(newRootToNpc.map);\n        this.frustFraction = newRootToNpc.frustFraction;\n        this.worldToViewMap.setFrom(this.calcNpcToView().multiplyMapMap(this.worldToNpcMap));\n    }\n    /** Create from a Viewport. */\n    static createFromViewport(vp) {\n        return new ViewingSpace(vp);\n    }\n    /** Convert an array of points from CoordSystem.View to CoordSystem.Npc */\n    viewToNpcArray(pts) {\n        const corners = this.getViewCorners();\n        const scrToNpcTran = Transform.createIdentity();\n        Transform.initFromRange(corners.low, corners.high, undefined, scrToNpcTran);\n        scrToNpcTran.multiplyPoint3dArrayInPlace(pts);\n    }\n    /** Convert an array of points from CoordSystem.Npc to CoordSystem.View */\n    npcToViewArray(pts) {\n        const corners = this.getViewCorners();\n        for (const p of pts)\n            corners.fractionToPoint(p.x, p.y, p.z, p);\n    }\n    /** Convert a point from CoordSystem.View to CoordSystem.Npc\n     * @param pt the point to convert\n     * @param out optional location for result. If undefined, a new Point3d is created.\n     */\n    viewToNpc(pt, out) {\n        const corners = this.getViewCorners();\n        const scrToNpcTran = Transform.createIdentity();\n        Transform.initFromRange(corners.low, corners.high, undefined, scrToNpcTran);\n        return scrToNpcTran.multiplyPoint3d(pt, out);\n    }\n    /** Convert a point from CoordSystem.Npc to CoordSystem.View\n     * @param pt the point to convert\n     * @param out optional location for result. If undefined, a new Point3d is created.\n     */\n    npcToView(pt, out) {\n        const corners = this.getViewCorners();\n        return corners.fractionToPoint(pt.x, pt.y, pt.z, out);\n    }\n    /** Convert an array of points from CoordSystem.World to CoordSystem.Npc */\n    worldToNpcArray(pts) { this.worldToNpcMap.transform0.multiplyPoint3dArrayQuietNormalize(pts); }\n    /** Convert an array of points from CoordSystem.Npc to CoordSystem.World */\n    npcToWorldArray(pts) { this.worldToNpcMap.transform1.multiplyPoint3dArrayQuietNormalize(pts); }\n    /** Convert an array of points from CoordSystem.World to CoordSystem.View */\n    worldToViewArray(pts) { this.worldToViewMap.transform0.multiplyPoint3dArrayQuietNormalize(pts); }\n    /** Convert an array of points from CoordSystem.World to CoordSystem.View, as Point4ds */\n    worldToView4dArray(worldPts, viewPts) { this.worldToViewMap.transform0.multiplyPoint3dArray(worldPts, viewPts); }\n    /** Convert an array of points from CoordSystem.View to CoordSystem.World */\n    viewToWorldArray(pts) { this.worldToViewMap.transform1.multiplyPoint3dArrayQuietNormalize(pts); }\n    /** Convert an array of points from CoordSystem.View as Point4ds to CoordSystem.World */\n    view4dToWorldArray(viewPts, worldPts) { this.worldToViewMap.transform1.multiplyPoint4dArrayQuietRenormalize(viewPts, worldPts); }\n    /**\n     * Convert a point from CoordSystem.World to CoordSystem.Npc\n     * @param pt the point to convert\n     * @param out optional location for result. If undefined, a new Point3d is created.\n     */\n    worldToNpc(pt, out) { return this.worldToNpcMap.transform0.multiplyPoint3dQuietNormalize(pt, out); }\n    /**\n     * Convert a point from CoordSystem.Npc to CoordSystem.World\n     * @param pt the point to convert\n     * @param out optional location for result. If undefined, a new Point3d is created.\n     */\n    npcToWorld(pt, out) { return this.worldToNpcMap.transform1.multiplyPoint3dQuietNormalize(pt, out); }\n    /**\n     * Convert a point from CoordSystem.World to CoordSystem.View\n     * @param pt the point to convert\n     * @param out optional location for result. If undefined, a new Point3d is created.\n     */\n    worldToView(input, out) { return this.worldToViewMap.transform0.multiplyPoint3dQuietNormalize(input, out); }\n    /**\n     * Convert a point from CoordSystem.World to CoordSystem.View as Point4d\n     * @param input the point to convert\n     * @param out optional location for result. If undefined, a new Point4d is created.\n     */\n    worldToView4d(input, out) { return this.worldToViewMap.transform0.multiplyPoint3d(input, 1.0, out); }\n    /**\n     * Convert a point from CoordSystem.View to CoordSystem.World\n     * @param pt the point to convert\n     * @param out optional location for result. If undefined, a new Point3d is created.\n     */\n    viewToWorld(input, out) { return this.worldToViewMap.transform1.multiplyPoint3dQuietNormalize(input, out); }\n    /**\n     * Convert a point from CoordSystem.View as a Point4d to CoordSystem.View\n     * @param input the point to convert\n     * @param out optional location for result. If undefined, a new Point3d is created.\n     */\n    view4dToWorld(input, out) { return this.worldToViewMap.transform1.multiplyXYZWQuietRenormalize(input.x, input.y, input.z, input.w, out); }\n    /** Get an 8-point Frustum corresponding to the 8 corners of the Viewport in the specified coordinate system.\n     *\n     * There are two sets of corners that may be of interest.\n     * The \"adjusted\" box is the one that is computed by examining the \"viewed extents\" and moving\n     * the front and back planes to enclose everything in the view.\n     * The \"unadjusted\" box is the one that is stored in the ViewState.\n     * @param sys Coordinate system for points\n     * @param adjustedBox If true, retrieve the adjusted box. Otherwise retrieve the box that came from the view definition.\n     * @param box optional Frustum for return value\n     * @return the view frustum\n     * @note The \"adjusted\" box may be either larger or smaller than the \"unadjusted\" box.\n     */\n    getFrustum(sys = CoordSystem.World, adjustedBox = true, box) {\n        box = box ? box.initNpc() : new Frustum();\n        // if they are looking for the \"unexpanded\" (that is before f/b clipping expansion) box, we need to get the npc\n        // coordinates that correspond to the unexpanded box in the npc space of the Expanded view (that's the basis for all\n        // of the root-based maps.)\n        if (!adjustedBox && this.zClipAdjusted) {\n            // to get unexpanded box, we have to go recompute rootToNpc from original View.\n            const ueRootToNpc = this.view.computeWorldToNpc(this.rotation, this.viewOriginUnexpanded, this.viewDeltaUnexpanded);\n            if (undefined === ueRootToNpc.map)\n                return box; // invalid frustum\n            // get the root corners of the unexpanded box\n            const ueRootBox = new Frustum();\n            ueRootToNpc.map.transform1.multiplyPoint3dArrayQuietNormalize(ueRootBox.points);\n            // and convert them to npc coordinates of the expanded view\n            this.worldToNpcArray(ueRootBox.points);\n            box.setFrom(ueRootBox);\n        }\n        // now convert from NPC space to the specified coordinate system.\n        switch (sys) {\n            case CoordSystem.View:\n                this.npcToViewArray(box.points);\n                break;\n            case CoordSystem.World:\n                this.npcToWorldArray(box.points);\n                break;\n        }\n        return box;\n    }\n    /** @internal */\n    getPixelSizeAtPoint(inPoint) {\n        const viewPt = !!inPoint ? this.worldToView(inPoint) : this.npcToView(new Point3d(0.5, 0.5, 0.5));\n        const viewPt2 = new Point3d(viewPt.x + 1.0, viewPt.y, viewPt.z);\n        return this.viewToWorld(viewPt).distance(this.viewToWorld(viewPt2));\n    }\n    /** @internal */\n    getPreloadFrustum(transformOrScale, result) {\n        const viewFrustum = this.getFrustum(CoordSystem.World, true);\n        if (transformOrScale && transformOrScale instanceof Transform) {\n            return viewFrustum.transformBy(transformOrScale, result);\n        }\n        else {\n            const scale = transformOrScale === undefined ? 2 : transformOrScale;\n            const expandedFrustum = viewFrustum.clone(result);\n            expandedFrustum.scaleXYAboutCenter(scale);\n            return expandedFrustum;\n        }\n    }\n}\n/** Maximum ratio of frontplane to backplane distance for 24 bit non-logarithmic zbuffer\n * @internal\n */\nViewingSpace.nearScaleNonLog24 = 0.0003;\n/** Maximum fraction of frontplane to backplane distance for 24 bit logarithmic zbuffer\n * @internal\n */\nViewingSpace.nearScaleLog24 = 1.0E-8;\nViewingSpace._minDepth = 1; // Allowing very small depth will cause frustum calculations to fail.\nexport { ViewingSpace };\n//# sourceMappingURL=ViewingSpace.js.map",
      "start": 1693508119270,
      "end": 1693508119420,
      "sourcemaps": null
    }
  ]
}
