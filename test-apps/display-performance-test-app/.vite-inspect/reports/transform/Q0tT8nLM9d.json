{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/curve/RegionOpsClassificationSweeps.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Curve\n */\nimport { HalfEdgeGraph, HalfEdgeMask } from \"../topology/Graph\";\nimport { HalfEdgeGraphSearch } from \"../topology/HalfEdgeGraphSearch\";\nimport { HalfEdgeGraphMerge } from \"../topology/Merging\";\nimport { RegularizationContext } from \"../topology/RegularizeFace\";\nimport { RegionBinaryOpType, RegionOps } from \"./RegionOps\";\nimport { ParityRegion } from \"./ParityRegion\";\nimport { Loop } from \"./Loop\";\nimport { CurveCurve } from \"./CurveCurve\";\nimport { PlanarSubdivision } from \"./Query/PlanarSubdivision\";\nimport { Geometry } from \"../Geometry\";\nimport { UnionRegion } from \"./UnionRegion\";\nimport { CurveLocationDetail } from \"./CurveLocationDetail\";\nimport { LineSegment3d } from \"./LineSegment3d\";\nimport { Arc3d } from \"./Arc3d\";\nimport { Range2d, Range3d } from \"../geometry3d/Range\";\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\nimport { PlaneAltitudeRangeContext } from \"./internalContexts/PlaneAltitudeRangeContext\";\nimport { GeometryQuery } from \"./GeometryQuery\";\nimport { Ray3d } from \"../geometry3d/Ray3d\";\n/**\n * base class for callbacks during region sweeps.\n * * At start of a component, `startComponent(node)` is called announcing a representative node on the outermost face.\n *   * A Component in this usage is a component that is edge connected when ignoring \"exterior bridge edges\".\n * * As each face is entered, `enterFace(facePathStack, newFaceNode)` is called\n *   * facePathStack[0] is the outermost node of the path from the outer face.\n *   * facePathStack[1] is its inside mate.\n *   * facePathStack[2k] is the outside node at crossing to face at depth k.\n *   * facePathStack[2k+1] is the node where face at depth k was entered.\n *   * newFaceNode is the entry node (redundant of stack tip)\n *  * On retreat from a face, `leaveFace(facePathStack, faceNode)` is called.\n *  * At end of component, `finishComponent (node)` is called.\n * * The base class is fully implemented to do nothing during the sweep.\n * @internal\n */\nclass RegionOpsFaceToFaceSearchCallbacks {\n    /** Announce a representative node on the outer face of a component */\n    startComponent(_node) { return true; }\n    /** Announce return to outer face */\n    finishComponent(_node) { return true; }\n    /** Announce face entry */\n    enterFace(_facePathStack, _newFaceNode) { return true; }\n    /** Announce face exit */\n    leaveFace(_facePathStack, _newFaceNode) { return true; }\n}\n/**\n * Implementation of `RegionOpsFaceToFaceSearchCallbacks` for binary boolean sweep with polygonal regions.\n * * For this linear-boundary case the boundary geometry is carried entirely from the coordinates in the half edges.\n * * This assumes the each node in the graph has edgeTag set to:\n *   * `edgeTag === undefined` if the edge crossing does not change classification.\n *     * for example, an edge added by regularization\n *   * `edgeTag === 1` if this is a boundary for the first of the boolean input regions\n *   * `edgeTag === 2` if this is a boundary for the second of the boolean input regions\n * * constructor\n *    * takes caller-supplied function to decide whether to accept a face given its state relative to the two boolean terms.\n *    * sets the in/out status of both terms to false.\n * * `startComponent` marks the entire outer face as `EXTERIOR`\n * * `enterFace`\n *    * if this is a bounding edge (according to `node.faceTag`) toggle the in/out status if this boolean term.\n *    * ask the faceAcceptFunction if the current term states combine to in/out for the result\n *    * if out, set the `EXTERIOR` mask around the face.\n * * `leaveFace`\n *    * if this is a bounding edge (according to `node.faceTag`) toggle the in/out status if this boolean term.\n * * `finishComponent` is not reimplemented.\n * @internal\n */\nclass RegionOpsBinaryBooleanSweepCallbacks extends RegionOpsFaceToFaceSearchCallbacks {\n    constructor(acceptFaceFunction, exteriorMask) {\n        super();\n        this._inComponent = [false, false, false]; // entry 0 is never reused.\n        this._exteriorMask = exteriorMask;\n        this._faceSelectFunction = acceptFaceFunction;\n    }\n    /** Mark this face as exterior */\n    startComponent(node) { node.setMaskAroundFace(this._exteriorMask); return true; }\n    /**\n     * * If necessary, toggle a term state.\n     * * if indicated, mark this face exterior.\n     */\n    enterFace(_facePathStack, node) {\n        const thisFaceIndex = node.edgeTag;\n        if (node.edgeTag === 1 || node.edgeTag === 2)\n            this._inComponent[thisFaceIndex] = !this._inComponent[thisFaceIndex];\n        if (!this._faceSelectFunction(this._inComponent[1], this._inComponent[2]))\n            node.setMaskAroundFace(this._exteriorMask);\n        return true;\n    }\n    /**\n     * * If necessary, toggle a term state.\n     */\n    leaveFace(_facePathStack, node) {\n        const thisFaceIndex = node.edgeTag;\n        if (node.edgeTag === 1 || node.edgeTag === 2)\n            this._inComponent[thisFaceIndex] = !this._inComponent[thisFaceIndex];\n        return true;\n    }\n}\n/**\n * Low level graph search for face classification.\n * @internal\n */\nexport class RegionOpsFaceToFaceSearch {\n    /**\n     * run a DFS with face-to-face step announcements.\n     * * false return from any function terminates search immediately.\n     * * all reachable nodes assumed to have both visit masks clear.\n     * @param graph containing graph.\n     * @param seed first node to visit.\n     * @param faceHasBeenVisited mask marking faces that have been seen.\n     * @param nodeHasBeenVisited mask marking node-to-node step around face.\n     *\n     */\n    static faceToFaceSearchFromOuterLoop(_graph, seed, faceHasBeenVisited, nodeHasBeenVisited, callbacks) {\n        if (seed.isMaskSet(faceHasBeenVisited))\n            return;\n        if (!callbacks.startComponent(seed))\n            return;\n        const facePathStack = [];\n        seed.setMaskAroundFace(faceHasBeenVisited);\n        let faceWalker = seed;\n        do {\n            let entryNode = faceWalker;\n            let mate = faceWalker.edgeMate;\n            if (!mate.isMaskSet(faceHasBeenVisited)) {\n                // the faceWalker seed is always on the base of the stack.\n                // the stack then contains even-odd pairs of (entryNode, currentNode)\n                // * entryNode is the node where a face was entered.\n                // * faceNode is another node around that face.\n                facePathStack.push(faceWalker);\n                facePathStack.push(mate);\n                let faceNode = mate.faceSuccessor;\n                mate.setMaskAroundFace(faceHasBeenVisited);\n                entryNode = mate;\n                if (callbacks.enterFace(facePathStack, mate)) {\n                    for (;;) {\n                        mate = faceNode.edgeMate;\n                        if (!mate.isMaskSet(faceHasBeenVisited)) {\n                            mate.setMaskAroundFace(faceHasBeenVisited);\n                            if (!callbacks.enterFace(facePathStack, mate))\n                                return;\n                            facePathStack.push(faceNode);\n                            facePathStack.push(mate);\n                            faceNode = mate;\n                            entryNode = mate;\n                        }\n                        faceNode.setMask(nodeHasBeenVisited);\n                        faceNode = faceNode.faceSuccessor;\n                        if (faceNode === entryNode) {\n                            callbacks.leaveFace(facePathStack, faceNode);\n                            if (facePathStack.length <= 2) {\n                                break;\n                            }\n                            facePathStack.pop();\n                            faceNode = facePathStack[facePathStack.length - 1];\n                            facePathStack.pop();\n                            entryNode = facePathStack[facePathStack.length - 1];\n                        }\n                        if (faceNode.isMaskSet(nodeHasBeenVisited)) {\n                            // this is disaster !!!\n                            return;\n                        }\n                    }\n                }\n            }\n            // continue at outermost level .....\n            faceWalker = faceWalker.faceSuccessor;\n        } while (faceWalker !== seed);\n        callbacks.finishComponent(seed);\n    }\n    /** Complete multi-step process for polygon binary booleans starting with arrays of coordinates.\n     * * Each of the binary input terms is a collection of loops\n     *   * Within the binary term, in/out is determined by edge-crossing parity rules.\n     * * Processing steps are\n     *   * Build the loops for each set.\n     *      * Each edge labeled with 1 or 2 as binary term identifier.\n     *   * find crossings among the edges.\n     *      * Edges are split as needed, but split preserves the edgeTag\n     *   * sort edges around vertices\n     *   * add regularization edges so holes are connected to their parent.\n     */\n    static doPolygonBoolean(loopsA, loopsB, faceSelectFunction, graphCheckPoint) {\n        const graph = new HalfEdgeGraph();\n        const baseMask = HalfEdgeMask.BOUNDARY_EDGE | HalfEdgeMask.PRIMARY_EDGE;\n        const seedA = RegionOps.addLoopsWithEdgeTagToGraph(graph, loopsA, baseMask, 1);\n        const seedB = RegionOps.addLoopsWithEdgeTagToGraph(graph, loopsB, baseMask, 2);\n        if (graphCheckPoint)\n            graphCheckPoint(\"unmerged loops\", graph, \"U\");\n        if (seedA || seedB) {\n            // split edges where they cross . . .\n            HalfEdgeGraphMerge.splitIntersectingEdges(graph);\n            if (graphCheckPoint)\n                graphCheckPoint(\"After splitIntersectingEdges\", graph, \"S\");\n            // sort radially around vertices.\n            HalfEdgeGraphMerge.clusterAndMergeXYTheta(graph);\n            if (graphCheckPoint)\n                graphCheckPoint(\"After clusterAndMergeXYTheta\", graph, \"M\");\n            // add edges to connect various components  (e.g. holes!!!)\n            const context = new RegularizationContext(graph);\n            context.regularizeGraph(true, true);\n            if (graphCheckPoint)\n                graphCheckPoint(\"After regularize\", graph, \"MR\");\n            const exteriorHalfEdge = HalfEdgeGraphSearch.findMinimumAreaFace(graph);\n            if (exteriorHalfEdge === undefined)\n                return undefined;\n            const exteriorMask = HalfEdgeMask.EXTERIOR;\n            const faceVisitedMask = graph.grabMask();\n            const nodeVisitedMask = graph.grabMask();\n            const allMasksToClear = exteriorMask | faceVisitedMask | nodeVisitedMask;\n            graph.clearMask(allMasksToClear);\n            const callbacks = new RegionOpsBinaryBooleanSweepCallbacks(faceSelectFunction, exteriorMask);\n            this.faceToFaceSearchFromOuterLoop(graph, exteriorHalfEdge, faceVisitedMask, nodeVisitedMask, callbacks);\n            if (graphCheckPoint)\n                graphCheckPoint(\"After faceToFaceSearchFromOuterLoop\", graph, \"MRX\");\n            graph.dropMask(faceVisitedMask);\n            graph.dropMask(nodeVisitedMask);\n            return graph;\n        }\n        return undefined;\n    }\n    /** Complete multi-step process for polygon binary booleans starting with arrays of coordinates.\n     * * the manyLoopsAndParitySets input is an array.\n     * * Each entry is one or more loops.\n     * * An entry that is \"just points\" is a simple loop.\n     * * An entry that is itself an array of arrays of points is a set of loops with \"parity\" -- relation:\n     *    * typically the first is an outer loop an others are holes.\n     *    * but if there is self intersection or multiple outer loops, parity rules are applied to decide inner and outer.\n     * * Processing steps are\n     *   * Build the loops for each set.\n     *      * Each edge labeled with index to the outer array.\n     *   * find crossings among the edges.\n     *      * Edges are split as needed, but split preserves the edgeTag\n     *   * sort edges around vertices\n     *   * add regularization edges so holes are connected to their parent.\n     *   * assign inside/outside by parity within each set and overall union.\n     */\n    static doBinaryBooleanBetweenMultiLoopInputs(dataA, opA, binaryOp, dataB, opB, purgeSliverExteriorFaces) {\n        const graph = new HalfEdgeGraph();\n        const baseMask = HalfEdgeMask.BOUNDARY_EDGE | HalfEdgeMask.PRIMARY_EDGE;\n        const callbacks = RegionBooleanContext.create(opA, opB);\n        callbacks.graph = graph;\n        callbacks.faceAreaFunction = (node) => HalfEdgeGraphSearch.signedFaceArea(node);\n        // Add all the members in groupA ..\n        for (const data of dataA) {\n            if (data.length > 2) {\n                const member = new RegionGroupMember(data, callbacks.groupA);\n                RegionOps.addLoopsWithEdgeTagToGraph(graph, data, baseMask, member);\n            }\n        }\n        for (const data of dataB) {\n            if (data.length > 2) {\n                const member = new RegionGroupMember(data, callbacks.groupB);\n                RegionOps.addLoopsWithEdgeTagToGraph(graph, data, baseMask, member);\n            }\n        }\n        // split edges where they cross . . .\n        HalfEdgeGraphMerge.splitIntersectingEdges(graph);\n        // sort radially around vertices.\n        HalfEdgeGraphMerge.clusterAndMergeXYTheta(graph);\n        // add edges to connect various components  (e.g. holes!!!)\n        const context = new RegularizationContext(graph);\n        context.regularizeGraph(true, true);\n        callbacks.runClassificationSweep(binaryOp);\n        if (purgeSliverExteriorFaces)\n            callbacks.unmaskMaskedNullFaces(HalfEdgeMask.EXTERIOR);\n        return graph;\n    }\n}\n/**\n * Enumeration of operation types \"within a group operand\" for a `RegionBooleanContext`.\n * @internal\n */\nexport var RegionGroupOpType;\n(function (RegionGroupOpType) {\n    RegionGroupOpType[RegionGroupOpType[\"Union\"] = 0] = \"Union\";\n    RegionGroupOpType[RegionGroupOpType[\"Parity\"] = 1] = \"Parity\";\n    RegionGroupOpType[RegionGroupOpType[\"Intersection\"] = 2] = \"Intersection\";\n    RegionGroupOpType[RegionGroupOpType[\"NonBounding\"] = -1] = \"NonBounding\";\n})(RegionGroupOpType || (RegionGroupOpType = {}));\n/**\n * Each loop or parity region in a `RegionBooleanContext` is recorded as a `RegionGroupMember`, which carries\n * * the Loop or parityRegion object\n * * a numeric indication of the sweep state (parity) during the classification search.\n * * a reference to the parent group (which in turn leads back to the `RegionBooleanContext`)\n * @internal\n */\nclass RegionGroupMember {\n    constructor(region, parentGroup) {\n        this.region = region;\n        this.parentGroup = parentGroup;\n        this.sweepState = 0;\n    }\n    clearState() { this.sweepState = 0; }\n}\n/**\n * A `RegionGroup` is\n * * An array of `RegionGroupMembers`, carrying the regions of the Ai or Bi part of the boolean expression.\n * * The `RegionGroupOpType` to be applied among those members.\n * * Pointer to the containing context\n * * The count of number of regions known to be \"in\" as the search progresses.\n * @internal\n */\nexport class RegionGroup {\n    constructor(parent, groupOpType) {\n        this.members = [];\n        this.parent = parent;\n        this.groupOpType = groupOpType;\n        this._numIn = 0;\n    }\n    /** deep clear of state data -- group header plus all members */\n    clearState() {\n        for (const member of this.members)\n            member.clearState();\n        this._numIn = 0;\n    }\n    range() {\n        const range = Range3d.createNull();\n        for (const m of this.members) {\n            if (m.region instanceof GeometryQuery)\n                m.region.extendRange(range);\n            else {\n                const range1 = Range3d.createFromVariantData(m.region);\n                range.extendRange(range1);\n            }\n        }\n        return range;\n    }\n    /** Ask if the current _numIn count qualifies as an \"in\" for this operation type.\n     */\n    getInOut() {\n        // UNION is true if one or more members are IN\n        if (this.groupOpType === RegionGroupOpType.Union)\n            return this._numIn > 0;\n        // PARITY is true if an odd number of regions are IN\n        if (this.groupOpType === RegionGroupOpType.Parity)\n            return Geometry.isOdd(this._numIn);\n        // INTERSECTION is true if ALL the regions are IN\n        if (this.groupOpType === RegionGroupOpType.Intersection)\n            return this._numIn === this.members.length;\n        return false;\n    }\n    // push new members into the group.\n    addMember(data, allowLineSegment = false) {\n        if (data instanceof Loop || data instanceof ParityRegion) {\n            const cleanerData = data.clone();\n            RegionOps.consolidateAdjacentPrimitives(cleanerData);\n            this.members.push(new RegionGroupMember(cleanerData, this));\n        }\n        else if (data instanceof UnionRegion) {\n            for (const child of data.children) {\n                this.addMember(child);\n            }\n        }\n        else if (Array.isArray(data)) {\n            for (const item of data) {\n                this.addMember(item);\n            }\n        }\n        else if (allowLineSegment && data instanceof LineSegment3d) {\n            this.members.push(new RegionGroupMember(data, this));\n        }\n    }\n    // update the \"in\" count _numIn according to old and new states (parity counts) for some member region.\n    recordMemberStateChange(oldState, newState) {\n        const oldIn = Geometry.isOdd(oldState);\n        const newIn = Geometry.isOdd(newState);\n        if (!oldIn && newIn)\n            this._numIn++;\n        else if (oldIn && !newIn)\n            this._numIn--;\n    }\n}\n/**\n * A `RegionBooleanContext` carries structure and operations for binary operations between two sets of regions.\n * * In the binary operation OP (union, intersection, parity, difference), the left and right operands\n *     are each a composite union, difference, or parity among multiple inputs, i.e.\n *   * (operationA among Ai) OP (operationB among Bi)\n *   * where the Ai are one set of regions, being combined by operationA\n *   * and the Bi are the another set of regions, being combined by operationB\n * * Each group of Ai and Bi is a `RegionGroup`\n * * This is an extremely delicate structure.\n * * Members are public because of the unique variety of queries, but should only be used for queries.\n * * The graph and curves in the booleans are connected by an extended pointer chain:\n *    * (HalfEdge in Graph).edgeTag points to a CurveLocationDetail\n *    * (CurveLocationDetail).curve points to a curve\n *    * (Curve).parent points to RegionGroupMember\n *    * (RegionGroupMember) points to RegionGroup\n *    * (RegionGroup) points to RegionBooleanBinaryContext\n * * So..when a graph sweep crosses an edge,\n *    * the chain leads to a parity count in the RegionGroupMember\n *    * that can change the number of members active in the RegionGroup\n *    * which can change the state of the context.\n * @internal\n */\nclass RegionBooleanContext {\n    constructor(groupTypeA, groupTypeB) {\n        this.groupA = new RegionGroup(this, groupTypeA);\n        this.groupB = new RegionGroup(this, groupTypeB);\n        this.extraGeometry = new RegionGroup(this, RegionGroupOpType.NonBounding);\n        this.binaryOp = RegionBinaryOpType.Union; // it will be revised on can calls.\n    }\n    /**\n     * Create a context with both A and B groups empty.\n     * * Caller follows up by calls to `context.groupA.addMember (loopOrParityRegion)` or `context.groupB.addMember (loopOrParityRegion)`\n     * @param groupTypeA\n     * @param groupTypeB\n     */\n    static create(groupTypeA, groupTypeB) {\n        return new RegionBooleanContext(groupTypeA, groupTypeB);\n    }\n    addMembers(dataA, dataB) {\n        this.groupA.addMember(dataA);\n        this.groupB.addMember(dataB);\n        // const doConnectives = 1;\n        // if (doConnectives !== 0)\n        this.addConnectives();\n    }\n    /**\n     * The sweep operations require access to all geometry by edge crossings and face walk.\n     * If input loops are non-overlapping, there may be disconnected islands not reachable.\n     * This method:\n     * * finds the total range\n     * * creates parallel rays from the extreme point of each loop and extending beyond the overall range\n     * * places those lines in the extraGeometry group\n     */\n    addConnectives() {\n        const rangeA = this.groupA.range();\n        const rangeB = this.groupB.range();\n        const rangeAB = rangeA.union(rangeB);\n        const areaTol = RegionOps.computeXYAreaTolerance(rangeAB);\n        let margin = 0.1;\n        this._workSegment = PlaneAltitudeRangeContext.findExtremePointsInDirection(rangeAB.corners(), RegionBooleanContext._bridgeDirection, this._workSegment);\n        if (this._workSegment)\n            margin *= this._workSegment.point0Ref.distanceXY(this._workSegment.point1Ref); // how much further to extend each bridge ray\n        const maxPoints = [];\n        const findExtremePointsInLoop = (region) => {\n            const area = RegionOps.computeXYArea(region);\n            if (area === undefined || Math.abs(area) < areaTol)\n                return; // avoid bridging trivial faces\n            this._workSegment = PlaneAltitudeRangeContext.findExtremePointsInDirection(region, RegionBooleanContext._bridgeDirection, this._workSegment);\n            if (this._workSegment)\n                maxPoints.push(this._workSegment.point1Ref);\n        };\n        for (const groupMembers of [this.groupA.members, this.groupB.members]) {\n            for (const m of groupMembers) {\n                if (m.region instanceof Loop) {\n                    findExtremePointsInLoop(m.region);\n                }\n                else if (m.region instanceof ParityRegion) {\n                    for (const loop of m.region.children)\n                        findExtremePointsInLoop(loop);\n                }\n            }\n        }\n        const ray = Ray3d.createZero();\n        for (const p of maxPoints) {\n            // Make a line from...\n            //  1) exactly the max point of the loops to\n            //  2) a point clearly outside the big range\n            // If p came from some inner loop this will...\n            //  1) create a bridge from the inner loop through any containing loops (always)\n            //  2) avoid crossing any containing loop at a vertex. (with high probability, but not absolutely always)\n            const bridgeLength = margin + Ray3d.create(p, RegionBooleanContext._bridgeDirection, ray).intersectionWithRange3d(rangeAB).high;\n            const outside = Point3d.createAdd2Scaled(p, 1.0, RegionBooleanContext._bridgeDirection, bridgeLength);\n            const bridgeLine = LineSegment3d.createXYXY(p.x, p.y, outside.x, outside.y);\n            this.extraGeometry.addMember(bridgeLine, true);\n        }\n    }\n    /**\n     * Markup and assembly steps for geometry in the RegionGroups.\n     * * Annotate connection from group to curves.\n     *    * groups with point data but no curves get no further annotation.\n     * * compute intersections.\n     * * assemble and merge the HalfEdgeGraph.\n     * @param mergeTolerance absolute distance tolerance for merging loops\n     */\n    annotateAndMergeCurvesInGraph(mergeTolerance = Geometry.smallMetricDistance) {\n        const allPrimitives = [];\n        // ASSUME loops have fine-grained types -- no linestrings !!\n        for (const group of [this.groupA, this.groupB, this.extraGeometry]) {\n            for (const member of group.members) {\n                let k = allPrimitives.length;\n                if (member.region instanceof GeometryQuery) {\n                    RegionOps.collectCurvePrimitives(member.region, allPrimitives, true, true);\n                    for (; k < allPrimitives.length; k++)\n                        allPrimitives[k].parent = member;\n                }\n            }\n        }\n        //    const range = RegionOps.curveArrayRange(allPrimitives);\n        const intersections = CurveCurve.allIntersectionsAmongPrimitivesXY(allPrimitives, mergeTolerance);\n        const graph = PlanarSubdivision.assembleHalfEdgeGraph(allPrimitives, intersections, mergeTolerance);\n        this.graph = graph;\n        this.faceAreaFunction = faceAreaFromCurvedEdgeData;\n    }\n    /**\n     * Sweep through the graph to assign in/out classifications to all faces.\n     * * the classification is announced in two ways:\n     *   * the EXTERNAL mask is set on all half edges that are NOT interior faces.\n     *   * the announceFaceFunction is called once for each face.\n     * @param binaryOp\n     * @param announceFaceFunction\n     */\n    runClassificationSweep(binaryOp, announceFaceFunction) {\n        this._announceFaceFunction = announceFaceFunction;\n        this.binaryOp = binaryOp;\n        this.graph.clearMask(HalfEdgeMask.EXTERIOR);\n        for (const group of [this.groupA, this.groupB]) {\n            group.clearState();\n        }\n        const faceHasBeenVisitedMask = this.graph.grabMask();\n        const nodeHasBeenVisitedMask = this.graph.grabMask();\n        const componentArray = GraphComponentArray.create(this.graph);\n        for (const component of componentArray.components) {\n            const exteriorHalfEdge = HalfEdgeGraphSearch.findMinimumAreaFace(component.faces, this.faceAreaFunction);\n            if (exteriorHalfEdge) {\n                const exteriorMask = HalfEdgeMask.EXTERIOR;\n                const allMasksToClear = exteriorMask | faceHasBeenVisitedMask | nodeHasBeenVisitedMask;\n                this.graph.clearMask(allMasksToClear);\n                RegionOpsFaceToFaceSearch.faceToFaceSearchFromOuterLoop(this.graph, exteriorHalfEdge, faceHasBeenVisitedMask, nodeHasBeenVisitedMask, this);\n            }\n        }\n        this.graph.dropMask(faceHasBeenVisitedMask);\n        this.graph.dropMask(nodeHasBeenVisitedMask);\n    }\n    // search the graph for faces with\n    // .. exactly 2 edges\n    // .. both with given mask\n    // .. at least one mate is not exterior.\n    // .. clear that mark\n    unmaskMaskedNullFaces(mask) {\n        for (const nodeA of this.graph.allHalfEdges) {\n            const nodeB = nodeA.faceSuccessor;\n            if (nodeB.faceSuccessor === nodeA) {\n                if (nodeA.getMask(mask) && nodeB.getMask(mask)) {\n                    if (!nodeA.edgeMate.getMask(mask) || !nodeB.edgeMate.getMask(mask)) {\n                        nodeA.clearMask(mask);\n                        nodeB.clearMask(mask);\n                    }\n                }\n            }\n        }\n    }\n    getInOut() {\n        if (this.binaryOp === RegionBinaryOpType.Union)\n            return this.groupA.getInOut() || this.groupB.getInOut();\n        if (this.binaryOp === RegionBinaryOpType.Intersection)\n            return this.groupA.getInOut() && this.groupB.getInOut();\n        if (this.binaryOp === RegionBinaryOpType.AMinusB)\n            return this.groupA.getInOut() && !this.groupB.getInOut();\n        if (this.binaryOp === RegionBinaryOpType.BMinusA)\n            return !this.groupA.getInOut() && this.groupB.getInOut();\n        if (this.binaryOp === RegionBinaryOpType.Parity)\n            return this.groupA.getInOut() !== this.groupB.getInOut();\n        return false;\n    }\n    /**\n     * Record transition across an edge as entry or exit from a RegionGroup.\n     * * Work backward from the node to a RegionGroup.  This path can be:\n     *   * If the node points to a CurveLocationDetail of a (possibly partial) curve, the path is (take a deep breath)\n     *      * node points to CurveLocation Detail\n     *      * CurveLocationDetail points to curve\n     *      * curve points to RegionGroupMember\n     *  * If the node points directly to a RegionGroup, it's ready to go!!!\n     * @param node\n     * @param delta\n     */\n    recordTransitionAcrossEdge(node, delta) {\n        const updateRegionGroupMemberState = (member) => {\n            if (member.parentGroup.groupOpType === RegionGroupOpType.NonBounding)\n                return member; // no transition across a bridge edge\n            if (delta !== 0) {\n                const oldSweepState = member.sweepState;\n                member.sweepState += delta;\n                member.parentGroup.recordMemberStateChange(oldSweepState, member.sweepState);\n            }\n            return member;\n        };\n        const data = node.edgeTag;\n        if (data instanceof RegionGroupMember)\n            return updateRegionGroupMemberState(data);\n        if (data instanceof CurveLocationDetail) {\n            // We trust that the caller has linked from the graph node to a curve which has a RegionGroupMember as its parent.\n            const member = data.curve.parent;\n            if (member instanceof RegionGroupMember)\n                return updateRegionGroupMemberState(member);\n        }\n        return undefined;\n    }\n    // obligations to act as sweep callback ...\n    /** Announce a representative node on the outer face of a component */\n    startComponent(outerFaceNode) {\n        outerFaceNode.setMaskAroundFace(HalfEdgeMask.EXTERIOR);\n        if (this._announceFaceFunction)\n            this._announceFaceFunction(this.graph, outerFaceNode, -1, faceAreaFromCurvedEdgeData(outerFaceNode));\n        return true;\n    }\n    /** Announce return to outer face */\n    finishComponent(_node) {\n        return true;\n    }\n    /** Announce entry to a graph face.\n     * * Both both sides of a graph edge are from the same RegionGroupMember.\n     * * Hence \"crossing that edge\" changes the parity count for the RegionGroupMember that owns that edge by 1.\n     * * The parity count for other RegionGroupMembers are never affected by this crossing.\n     * * Crossing a bridge edge does not change the parity count.\n     */\n    enterFace(_facePathStack, newFaceNode) {\n        this.recordTransitionAcrossEdge(newFaceNode, 1);\n        const state = this.getInOut();\n        if (!state)\n            newFaceNode.setMaskAroundFace(HalfEdgeMask.EXTERIOR);\n        if (this._announceFaceFunction)\n            this._announceFaceFunction(this.graph, newFaceNode, state ? 1 : 0, faceAreaFromCurvedEdgeData(newFaceNode));\n        return true;\n    }\n    /** Announce face exit */\n    leaveFace(_facePathStack, oldFaceNode) {\n        this.recordTransitionAcrossEdge(oldFaceNode, -1);\n        return true;\n    }\n}\nRegionBooleanContext._bridgeDirection = Vector3d.createNormalized(1.0, -0.12328974132467); // magic unit direction to minimize vertex hits\nexport { RegionBooleanContext };\n/** return xy area between a (part of a) curve and the x axis through a reference point.\n * If detail is undefined or does not have both start and end fractions, just do trapezoid area\n */\nfunction areaUnderPartialCurveXY(detail, xyStart, xyEnd, referencePoint) {\n    // area between trapezoid and axis\n    let trapezoidArea;\n    if (detail && detail.point1) {\n        trapezoidArea = -(detail.point1.x - detail.point.x) * (0.5 * (detail.point.y + detail.point1.y) - referencePoint.y);\n    }\n    else {\n        trapezoidArea = -(xyEnd.x - xyStart.x) * (0.5 * (xyStart.y + xyEnd.y) - referencePoint.y);\n    }\n    let areaToChord = 0.0;\n    if (detail && detail.curve && detail.hasFraction1) {\n        if (detail.curve instanceof LineSegment3d) {\n            // ah .. nothing to do for a line segment\n        }\n        else if (detail.curve instanceof Arc3d) {\n            areaToChord = detail.curve.areaToChordXY(detail.fraction, detail.fraction1);\n        }\n    }\n    return trapezoidArea + areaToChord;\n}\n/** Compute face area for a face whose edges are decorated with CurveLocationDetail for their (partial) curves */\nfunction faceAreaFromCurvedEdgeData(faceSeed) {\n    let area = 0.0;\n    let edge = faceSeed;\n    do {\n        area += edge.sortData * areaUnderPartialCurveXY(edge.edgeTag, edge, edge.faceSuccessor, faceSeed);\n    } while ((edge = edge.faceSuccessor) !== faceSeed);\n    return area;\n}\n/**\n * Array of nodes representing faces in a subset of a graph.\n * @internal\n */\nexport class GraphComponent {\n    constructor(faces) {\n        this.faces = faces;\n        this.range = Range2d.createNull();\n        this.faceAreas = [];\n    }\n    /**\n     * visit all vertices and edges in the component to build face area array and composite range.\n     *\n     * @param extendRangeForEdge optional function to compute edge range.  If undefined, linear edge is assumed.\n     * @param faceAreaFunction optional function to compute face area.  If undefined, linear edges are assumed.\n     */\n    buildFaceData(extendRangeForEdge, faceAreaFunction) {\n        const vertexFunction = (node) => {\n            if (extendRangeForEdge)\n                extendRangeForEdge(node, this.range);\n            else\n                this.range.extendXY(node.x, node.y);\n            return 0;\n        };\n        this.range.setNull();\n        for (const f of this.faces) {\n            f.sumAroundFace(vertexFunction);\n        }\n        this.faceAreas.length = 0;\n        if (!faceAreaFunction)\n            faceAreaFunction = (node) => HalfEdgeGraphSearch.signedFaceArea(node);\n        for (const f of this.faces) {\n            this.faceAreas.push(faceAreaFunction(f));\n        }\n    }\n}\n/** build and hold an array of component data for a HalfEdgeGraph.\n * @internal\n */\nexport class GraphComponentArray {\n    constructor(graph) {\n        this.graph = graph;\n        this.components = [];\n    }\n    static create(graph, extendRangeForEdge) {\n        const result = new GraphComponentArray(graph);\n        const componentArrays = HalfEdgeGraphSearch.collectConnectedComponentsWithExteriorParityMasks(graph, undefined);\n        for (const componentFaces of componentArrays) {\n            const component = new GraphComponent(componentFaces);\n            component.buildFaceData(extendRangeForEdge, faceAreaFromCurvedEdgeData);\n            result.components.push(component);\n        }\n        return result;\n    }\n}\n//# sourceMappingURL=RegionOpsClassificationSweeps.js.map",
      "start": 1693508124207,
      "end": 1693508124348,
      "sourcemaps": null
    }
  ]
}
