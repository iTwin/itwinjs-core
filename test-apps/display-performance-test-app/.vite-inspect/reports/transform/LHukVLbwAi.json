{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/BackgroundMapGeometry.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Views\n */\nimport { assert } from \"@itwin/core-bentley\";\nimport { Angle, ClipPlane, ClipPlaneContainment, Constant, Ellipsoid, GrowableXYZArray, Matrix3d, Plane3dByOriginAndUnitNormal, Point2d, Point3d, Point4d, Range1d, Range3d, Ray3d, Transform, Vector3d } from \"@itwin/core-geometry\";\nimport { Cartographic, ColorByName, ColorDef, GeoCoordStatus, GlobeMode, LinePixels } from \"@itwin/core-common\";\nimport { WebMercatorTilingScheme } from \"./tile/internal\";\nconst scratchRange = Range3d.createNull();\nconst scratchZeroPoint = Point3d.createZero();\nconst scratchPoint = Point3d.create();\nconst scratchVector = Vector3d.create();\nconst scratchCenterPoint = Point3d.createZero();\nconst scratchIntersectRay = Ray3d.create(Point3d.create(), Vector3d.create());\nconst scratchEyePoint = Point3d.createZero();\nconst scratchViewRotation = Matrix3d.createIdentity();\nconst scratchSilhouetteNormal = Vector3d.create();\nconst scratchCartoRectangle = new GrowableXYZArray();\nconst scratchWorkArray = new GrowableXYZArray();\nfunction accumulateDepthRange(point, viewRotation, range) {\n    viewRotation.multiplyXYZtoXYZ(point, scratchPoint);\n    range.extend(scratchPoint);\n}\nfunction accumulateFrustumPlaneDepthRange(frustum, plane, viewRotation, range, eyePoint) {\n    let includeHorizon = false;\n    for (let i = 0; i < 4; i++) {\n        const frustumRay = Ray3d.createStartEnd(eyePoint ? eyePoint : frustum.points[i + 4], frustum.points[i]);\n        const thisFraction = frustumRay.intersectionWithPlane(plane, scratchPoint);\n        if (undefined !== thisFraction && (!eyePoint || thisFraction > 0))\n            accumulateDepthRange(scratchPoint, viewRotation, range);\n        else\n            includeHorizon = true;\n    }\n    if (includeHorizon) {\n        if (eyePoint !== undefined) {\n            const eyeHeight = plane.altitude(eyePoint);\n            if (eyeHeight < 0)\n                accumulateDepthRange(eyePoint, viewRotation, range);\n            else {\n                const viewZ = viewRotation.getRow(2);\n                const horizonDistance = Math.sqrt(eyeHeight * eyeHeight + 2 * eyeHeight * Constant.earthRadiusWGS84.equator);\n                accumulateDepthRange(eyePoint.plusScaled(viewZ, -horizonDistance, scratchPoint), viewRotation, range);\n            }\n        }\n    }\n}\n/** @internal */\nexport function getFrustumPlaneIntersectionDepthRange(frustum, plane) {\n    const eyePoint = frustum.getEyePoint(scratchEyePoint);\n    const viewRotation = frustum.getRotation(scratchViewRotation);\n    const intersectRange = Range3d.createNull();\n    accumulateFrustumPlaneDepthRange(frustum, plane, viewRotation, intersectRange, eyePoint);\n    return intersectRange.isNull ? Range1d.createNull() : Range1d.createXX(intersectRange.low.z, intersectRange.high.z);\n}\n/** Geometry of background map - either an ellipsoid or a plane as defined by GlobeMode.\n * @internal\n */\nclass BackgroundMapGeometry {\n    constructor(_bimElevationBias, globeMode, _iModel) {\n        this._bimElevationBias = _bimElevationBias;\n        this._iModel = _iModel;\n        this._ecefToDb = _iModel.getMapEcefToDb(_bimElevationBias);\n        this.globeMode = globeMode;\n        this.cartesianRange = BackgroundMapGeometry.getCartesianRange(_iModel);\n        this.cartesianTransitionRange = this.cartesianRange.clone();\n        this.cartesianTransitionRange.expandInPlace(BackgroundMapGeometry.getCartesianTransitionDistance(_iModel));\n        this.cartesianDiagonal = this.cartesianRange.diagonal().magnitudeXY();\n        const earthRadius = Constant.earthRadiusWGS84.equator;\n        this.globeOrigin = this._ecefToDb.origin.cloneAsPoint3d();\n        this.globeMatrix = this._ecefToDb.matrix.clone();\n        this.cartesianChordHeight = Math.sqrt(this.cartesianDiagonal * this.cartesianDiagonal + earthRadius * earthRadius) - earthRadius; // Maximum chord height deviation of the cartesian area.\n        const halfChordAngle = Angle.piOver2Radians / 10;\n        this.maxGeometryChordHeight = (1 - Math.cos(halfChordAngle)) * earthRadius;\n        this.cartesianPlane = this.getPlane();\n        this.geometry = (globeMode === GlobeMode.Ellipsoid) ? this.getEarthEllipsoid() : this.cartesianPlane;\n        this._mercatorTilingScheme = new WebMercatorTilingScheme();\n        this._mercatorFractionToDb = this._mercatorTilingScheme.computeMercatorFractionToDb(this._ecefToDb, _bimElevationBias, _iModel, false);\n    }\n    static getCartesianRange(iModel, result) {\n        const cartesianRange = Range3d.createFrom(iModel.projectExtents, result);\n        cartesianRange.expandInPlace(BackgroundMapGeometry.maxCartesianDistance);\n        return cartesianRange;\n    }\n    static getCartesianTransitionDistance(iModel) {\n        return BackgroundMapGeometry.getCartesianRange(iModel, scratchRange).diagonal().magnitudeXY() * BackgroundMapGeometry._transitionDistanceMultiplier;\n    }\n    async dbToCartographicFromGcs(db) {\n        const scratch = new Point3d();\n        const promises = db.map(async (p) => {\n            return this.cartesianRange.containsPoint(Point3d.createFrom(p, scratch)) ? this._iModel.spatialToCartographic(p) : this.dbToCartographic(p);\n        });\n        return Promise.all(promises);\n    }\n    async dbToWGS84CartographicFromGcs(db) {\n        if (db.length === 0)\n            return [];\n        const result = Array(db.length);\n        const reproject = [];\n        const reprojectIdx = [];\n        const scratch = new Point3d();\n        for (let i = 0; i < db.length; i++) {\n            Point3d.createFrom(db[i], scratch);\n            if (this.cartesianRange.containsPoint(scratch)) {\n                reprojectIdx.push(i);\n                reproject.push(db[i]);\n            }\n            else {\n                result[i] = this.dbToCartographic(db[i]);\n            }\n        }\n        if (reproject.length === 0)\n            return result;\n        const reprojectPromise = this._iModel.wgs84CartographicFromSpatial(reproject);\n        return reprojectPromise.then((reprojected) => {\n            if (reprojected.length === reprojectIdx.length) { // reprojected array size must match our index array, otherwise something is OFF\n                for (let i = 0; i < reprojected.length; i++) {\n                    result[reprojectIdx[i]] = reprojected[i]; // Insert the reprojected values at their original index\n                }\n            }\n            return result;\n        });\n    }\n    dbToCartographic(db, result) {\n        if (undefined === result)\n            result = Cartographic.createZero();\n        if (this.globeMode === GlobeMode.Plane) {\n            const mercatorFraction = this._mercatorFractionToDb.multiplyInversePoint3d(db);\n            return this._mercatorTilingScheme.fractionToCartographic(mercatorFraction.x, mercatorFraction.y, result, mercatorFraction.z);\n        }\n        else {\n            const ecef = this._ecefToDb.multiplyInversePoint3d(db);\n            return Cartographic.fromEcef(ecef, result);\n        }\n    }\n    async cartographicToDbFromGcs(cartographic) {\n        let db;\n        if (this.globeMode === GlobeMode.Plane) {\n            const fraction = Point2d.create(0, 0);\n            db = cartographic.map((p) => {\n                this._mercatorTilingScheme.cartographicToFraction(p.latitude, p.longitude, fraction);\n                return this._mercatorFractionToDb.multiplyXYZ(fraction.x, fraction.y, p.height);\n            });\n        }\n        else {\n            db = cartographic.map((p) => this._ecefToDb.multiplyPoint3d(p.toEcef()));\n        }\n        if (this._iModel.noGcsDefined)\n            return db;\n        const promises = db.map(async (p, i) => {\n            return this.cartesianRange.containsPoint(p) ? this._iModel.cartographicToSpatialFromGcs(cartographic[i]) : p;\n        });\n        return Promise.all(promises);\n    }\n    cartographicToDb(cartographic, result) {\n        if (this.globeMode === GlobeMode.Plane) {\n            const fraction = Point2d.create(0, 0);\n            this._mercatorTilingScheme.cartographicToFraction(cartographic.latitude, cartographic.longitude, fraction);\n            return this._mercatorFractionToDb.multiplyXYZ(fraction.x, fraction.y, cartographic.height, result);\n        }\n        else {\n            return this._ecefToDb.multiplyPoint3d(cartographic.toEcef());\n        }\n    }\n    getEarthEllipsoid(radiusOffset = 0) {\n        const equatorRadius = Constant.earthRadiusWGS84.equator + radiusOffset, polarRadius = Constant.earthRadiusWGS84.polar + radiusOffset;\n        return Ellipsoid.createCenterMatrixRadii(this.globeOrigin, this.globeMatrix, equatorRadius, equatorRadius, polarRadius);\n    }\n    getPlane(offset = 0) {\n        return Plane3dByOriginAndUnitNormal.create(Point3d.create(0, 0, this._bimElevationBias + offset), Vector3d.create(0, 0, 1));\n    }\n    getRayIntersection(ray, positiveOnly) {\n        let intersect;\n        if (this.globeMode === GlobeMode.Ellipsoid) {\n            const ellipsoid = this.geometry;\n            BackgroundMapGeometry._scratchRayAngles.length = 0;\n            BackgroundMapGeometry._scratchRayFractions.length = 0;\n            const count = ellipsoid.intersectRay(ray, BackgroundMapGeometry._scratchRayFractions, undefined, BackgroundMapGeometry._scratchRayAngles);\n            let intersectDistance;\n            for (let i = 0; i < count; i++) {\n                const thisFraction = BackgroundMapGeometry._scratchRayFractions[i];\n                if ((!positiveOnly || thisFraction > 0) && (undefined === intersectDistance || thisFraction < intersectDistance)) {\n                    intersectDistance = thisFraction;\n                    intersect = scratchIntersectRay;\n                    ellipsoid.radiansToUnitNormalRay(BackgroundMapGeometry._scratchRayAngles[i].longitudeRadians, BackgroundMapGeometry._scratchRayAngles[i].latitudeRadians, intersect);\n                    if (intersect.direction.dotProduct(ray.direction) < 0) {\n                        if (this.cartesianRange.containsPoint(intersect.origin)) { // If we're in the cartesian range, correct to planar intersection.\n                            const planeFraction = ray.intersectionWithPlane(this.cartesianPlane, scratchIntersectRay.origin);\n                            if (undefined !== planeFraction && (!positiveOnly || planeFraction > 0)) {\n                                intersect.direction.setFromVector3d(this.cartesianPlane.getNormalRef());\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        else {\n            const plane = this.geometry;\n            const thisFraction = ray.intersectionWithPlane(plane, scratchIntersectRay.origin);\n            if (undefined !== thisFraction && (!positiveOnly || thisFraction > 0)) {\n                intersect = scratchIntersectRay;\n                intersect.direction.setFromVector3d(plane.getNormalRef());\n            }\n        }\n        return intersect;\n    }\n    getPointHeight(point) {\n        if (this.globeMode === GlobeMode.Ellipsoid) {\n            const ellipsoid = this.geometry;\n            const projected = ellipsoid.projectPointToSurface(point);\n            if (undefined === projected)\n                return undefined;\n            const distance = ellipsoid.radiansToPoint(projected.longitudeRadians, projected.latitudeRadians).distance(point);\n            const ellipsePoint = ellipsoid.transformRef.multiplyInversePoint3d(point, BackgroundMapGeometry._scratchPoint);\n            return ellipsePoint.magnitude() < 1 ? -distance : distance;\n        }\n        else {\n            const plane = this.geometry;\n            return plane.altitude(point);\n        }\n    }\n    /** @internal */\n    getFrustumIntersectionDepthRange(frustum, bimRange, heightRange, gridPlane, doGlobalScope) {\n        const clipPlanes = frustum.getRangePlanes(false, false, 0);\n        const eyePoint = frustum.getEyePoint(scratchEyePoint);\n        const viewRotation = frustum.getRotation(scratchViewRotation);\n        if (undefined === viewRotation)\n            return Range1d.createNull(); // Degenerate frustum...\n        const viewZ = viewRotation.getRow(2);\n        const cartoRange = this.cartesianTransitionRange;\n        const intersectRange = Range3d.createNull();\n        const doAccumulate = ((point) => accumulateDepthRange(point, viewRotation, intersectRange));\n        if (gridPlane)\n            accumulateFrustumPlaneDepthRange(frustum, gridPlane, viewRotation, intersectRange, eyePoint);\n        if (this.geometry instanceof Plane3dByOriginAndUnitNormal) {\n            // Intersection with a planar background projection...\n            const heights = heightRange ? [heightRange.low, heightRange.high] : [0];\n            for (const height of heights) {\n                accumulateFrustumPlaneDepthRange(frustum, this.getPlane(height), viewRotation, intersectRange, eyePoint);\n            }\n        }\n        else {\n            const minOffset = heightRange ? heightRange.low : 0, maxOffset = (heightRange ? heightRange.high : 0) + this.cartesianChordHeight;\n            const radiusOffsets = [minOffset, maxOffset];\n            // If we are doing global scope then include minimum ellipsoid that represents the chordal approximation of the low level tiles.\n            // this substantially expands the frustum so don't do it for non-global views, but this clipping out the low level tiles.\n            if (doGlobalScope)\n                radiusOffsets.push(minOffset - this.maxGeometryChordHeight);\n            const toView = Transform.createRefs(Point3d.createZero(), viewRotation);\n            const eyePoint4d = eyePoint ? Point4d.createFromPointAndWeight(eyePoint, 1) : Point4d.createFromPointAndWeight(viewZ, 0);\n            for (const radiusOffset of radiusOffsets) {\n                const ellipsoid = this.getEarthEllipsoid(radiusOffset);\n                const isInside = eyePoint && ellipsoid.worldToLocal(eyePoint).magnitude() < 1.0;\n                const center = ellipsoid.localToWorld(scratchZeroPoint, scratchCenterPoint);\n                const clipPlaneCount = clipPlanes.planes.length;\n                // Extrema...\n                let angles, extremaPoint;\n                if (undefined !== (angles = ellipsoid.surfaceNormalToAngles(viewZ)) &&\n                    undefined !== (extremaPoint = ellipsoid.radiansToPoint(angles.longitudeRadians, angles.latitudeRadians)) &&\n                    (eyePoint === undefined || viewZ.dotProductStartEnd(extremaPoint, eyePoint) > 0) &&\n                    clipPlanes.classifyPointContainment([extremaPoint], false) !== ClipPlaneContainment.StronglyOutside)\n                    doAccumulate(extremaPoint);\n                if (isInside) {\n                    if (eyePoint)\n                        doAccumulate(eyePoint);\n                }\n                else {\n                    const silhouette = ellipsoid.silhouetteArc(eyePoint4d);\n                    if (silhouette !== undefined) {\n                        silhouette.perpendicularVector.clone(scratchSilhouetteNormal);\n                        // Push the silhouette plane as clip so that we do not include geometry at other side of ellipsoid.\n                        // First make sure that it is pointing in the right direction.\n                        if (eyePoint) {\n                            // Clip toward eye.\n                            if (scratchSilhouetteNormal.dotProduct(viewZ) < 0)\n                                scratchSilhouetteNormal.negate(scratchSilhouetteNormal);\n                        }\n                        else {\n                            /* If parallel projection - clip toward side of ellipsoid with BIM geometry */\n                            if (Vector3d.createStartEnd(silhouette.center, bimRange.center).dotProduct(scratchSilhouetteNormal) < 0)\n                                scratchSilhouetteNormal.negate(scratchSilhouetteNormal);\n                        }\n                        clipPlanes.planes.push(ClipPlane.createNormalAndDistance(scratchSilhouetteNormal, scratchSilhouetteNormal.dotProduct(silhouette.center)));\n                    }\n                    else {\n                        clipPlanes.planes.push(ClipPlane.createNormalAndPoint(viewZ, center));\n                    }\n                }\n                if (!isInside || radiusOffset === radiusOffsets[0]) {\n                    // Intersections of ellipsoid with frustum planes...\n                    const viewingInside = eyePoint !== undefined && viewZ.dotProduct(Vector3d.createStartEnd(center, eyePoint)) < 0;\n                    if (eyePoint === undefined || !isInside || viewingInside) {\n                        for (const clipPlane of clipPlanes.planes) {\n                            const plane = clipPlane.getPlane3d();\n                            const arc = ellipsoid.createPlaneSection(plane);\n                            if (undefined !== arc) {\n                                arc.announceClipIntervals(clipPlanes, (a0, a1, cp) => {\n                                    if (Math.abs(a1 - a0) < 1.0E-8) {\n                                        doAccumulate(cp.fractionToPoint(a0)); // Tiny sweep - avoid problem with rangeMethod (not worth doing anyway).\n                                    }\n                                    else {\n                                        const segment = cp.clonePartialCurve(a0, a1);\n                                        if (segment !== undefined)\n                                            segment.extendRange(intersectRange, toView);\n                                    }\n                                });\n                            }\n                        }\n                    }\n                    // Intersections of the cartesian region with frustum planes.\n                    scratchCartoRectangle.resize(0);\n                    scratchCartoRectangle.push({ x: cartoRange.low.x, y: cartoRange.low.y, z: radiusOffset });\n                    scratchCartoRectangle.push({ x: cartoRange.high.x, y: cartoRange.low.y, z: radiusOffset });\n                    scratchCartoRectangle.push({ x: cartoRange.high.x, y: cartoRange.high.y, z: radiusOffset });\n                    scratchCartoRectangle.push({ x: cartoRange.low.x, y: cartoRange.high.y, z: radiusOffset });\n                    scratchCartoRectangle.push({ x: cartoRange.low.x, y: cartoRange.low.y, z: radiusOffset });\n                    clipPlanes.clipConvexPolygonInPlace(scratchCartoRectangle, scratchWorkArray);\n                    for (let i = 0; i < scratchCartoRectangle.length; i++)\n                        doAccumulate(scratchCartoRectangle.getPoint3dAtUncheckedPointIndex(i));\n                    while (clipPlanes.planes.length > clipPlaneCount) // Remove pushed silhouette plane.\n                        clipPlanes.planes.pop();\n                }\n            }\n        }\n        if (intersectRange.zLength() < 5) {\n            // For the case where the fitted depth is small (less than 5 meters) we must be viewing planar projection or the\n            // planar portion of the iModel in plan view. In this case use a constant (arbitrarily 100 meters) depth so that the frustum\n            // Z is doesn't change and cause nearly planar geometry to jitter in Z buffer.\n            const zCenter = (intersectRange.low.z + intersectRange.high.z) / 2;\n            const zExpand = 50;\n            return Range1d.createXX(zCenter - zExpand, zCenter + zExpand);\n        }\n        else {\n            const diagonal = intersectRange.diagonal(scratchVector).magnitudeXY();\n            const expansion = diagonal * .01;\n            return Range1d.createXX(intersectRange.low.z - expansion, intersectRange.high.z + expansion);\n        }\n    }\n    addFrustumDecorations(builder, frustum) {\n        if (this.geometry instanceof Ellipsoid) {\n            const ellipsoid = this.geometry;\n            const clipPlanes = frustum.getRangePlanes(false, false, 0);\n            const viewRotation = frustum.getRotation();\n            const eyePoint = frustum.getEyePoint(scratchEyePoint);\n            const viewZ = viewRotation.getRow(2);\n            const eyePoint4d = eyePoint ? Point4d.createFromPointAndWeight(eyePoint, 1) : Point4d.createFromPointAndWeight(viewZ, 0);\n            const isInside = eyePoint && ellipsoid.worldToLocal(eyePoint).magnitude() < 1.0;\n            const center = ellipsoid.localToWorld(scratchZeroPoint, scratchCenterPoint);\n            const cartoRange = this.cartesianTransitionRange;\n            if (!isInside) {\n                const silhouette = ellipsoid.silhouetteArc(eyePoint4d);\n                if (silhouette !== undefined) {\n                    silhouette.perpendicularVector.clone(scratchSilhouetteNormal);\n                    if (scratchSilhouetteNormal.dotProduct(viewZ) < 0)\n                        scratchSilhouetteNormal.negate(scratchSilhouetteNormal);\n                    clipPlanes.planes.push(ClipPlane.createNormalAndDistance(scratchSilhouetteNormal, scratchSilhouetteNormal.dotProduct(silhouette.center)));\n                }\n                else {\n                    clipPlanes.planes.push(ClipPlane.createNormalAndPoint(viewZ, center));\n                }\n                const ellipsoidColor = ColorDef.create(ColorByName.yellow);\n                builder.setSymbology(ellipsoidColor, ellipsoidColor, 1, LinePixels.Code2);\n                for (const clipPlane of clipPlanes.planes) {\n                    const plane = clipPlane.getPlane3d();\n                    const arc = ellipsoid.createPlaneSection(plane);\n                    if (undefined !== arc) {\n                        arc.announceClipIntervals(clipPlanes, (a0, a1, cp) => {\n                            const segment = cp.clonePartialCurve(a0, a1);\n                            if (segment !== undefined)\n                                builder.addArc(segment, false, false);\n                        });\n                    }\n                    // Intersections of the cartesian region with frustum planes.\n                    scratchCartoRectangle.resize(0);\n                    scratchCartoRectangle.push({ x: cartoRange.low.x, y: cartoRange.low.y, z: 0 });\n                    scratchCartoRectangle.push({ x: cartoRange.high.x, y: cartoRange.low.y, z: 0 });\n                    scratchCartoRectangle.push({ x: cartoRange.high.x, y: cartoRange.high.y, z: 0 });\n                    scratchCartoRectangle.push({ x: cartoRange.low.x, y: cartoRange.high.y, z: 0 });\n                    scratchCartoRectangle.push({ x: cartoRange.low.x, y: cartoRange.low.y, z: 0 });\n                    clipPlanes.clipConvexPolygonInPlace(scratchCartoRectangle, scratchWorkArray);\n                    if (scratchCartoRectangle.length > 0) {\n                        builder.addLineString(scratchCartoRectangle.getPoint3dArray());\n                    }\n                }\n            }\n        }\n    }\n}\nBackgroundMapGeometry.maxCartesianDistance = 1E4; // If globe is 3D we still consider the map geometry flat within this distance of the project extents.\nBackgroundMapGeometry._transitionDistanceMultiplier = .25; // In the transition range which extends beyond the cartesian range we interpolate between cartesian and ellipsoid.\nBackgroundMapGeometry._scratchRayFractions = new Array();\nBackgroundMapGeometry._scratchRayAngles = new Array();\nBackgroundMapGeometry._scratchPoint = Point3d.createZero();\nexport { BackgroundMapGeometry };\n/** Calculate the ECEF to database (IModel) coordinate transform at a provided location, using the GCS of the iModel.\n *  The transform will exactly represent the GCS at the provided location.\n * @public\n */\nexport async function calculateEcefToDbTransformAtLocation(originIn, iModel) {\n    const geoConverter = iModel.noGcsDefined ? undefined : iModel.geoServices.getConverter(\"WGS84\");\n    if (geoConverter === undefined)\n        return undefined;\n    const origin = Point3d.create(originIn.x, originIn.y, 0); // Always Test at zero.\n    const eastPoint = origin.plusXYZ(1, 0, 0);\n    const northPoint = origin.plusXYZ(0, 1, 0);\n    const response = await geoConverter.getGeoCoordinatesFromIModelCoordinates([origin, northPoint, eastPoint]);\n    if (response.geoCoords[0].s !== GeoCoordStatus.Success || response.geoCoords[1].s !== GeoCoordStatus.Success || response.geoCoords[2].s !== GeoCoordStatus.Success)\n        return undefined;\n    const geoOrigin = Point3d.fromJSON(response.geoCoords[0].p);\n    const geoNorth = Point3d.fromJSON(response.geoCoords[1].p);\n    const geoEast = Point3d.fromJSON(response.geoCoords[2].p);\n    const ecefOrigin = Cartographic.fromDegrees({ longitude: geoOrigin.x, latitude: geoOrigin.y, height: geoOrigin.z }).toEcef();\n    const ecefNorth = Cartographic.fromDegrees({ longitude: geoNorth.x, latitude: geoNorth.y, height: geoNorth.z }).toEcef();\n    const ecefEast = Cartographic.fromDegrees({ longitude: geoEast.x, latitude: geoEast.y, height: geoEast.z }).toEcef();\n    const xVector = Vector3d.createStartEnd(ecefOrigin, ecefEast);\n    const yVector = Vector3d.createStartEnd(ecefOrigin, ecefNorth);\n    const zVector = xVector.unitCrossProduct(yVector);\n    if (undefined === zVector) {\n        assert(false); // Should never occur.\n        return undefined;\n    }\n    const matrix = Matrix3d.createColumns(xVector, yVector, zVector);\n    if (matrix === undefined)\n        return undefined;\n    const inverse = matrix.inverse();\n    if (inverse === undefined) {\n        assert(false); // Should never occur.\n        return undefined;\n    }\n    return Transform.createMatrixPickupPutdown(matrix, origin, ecefOrigin).inverse();\n}\n//# sourceMappingURL=BackgroundMapGeometry.js.map",
      "start": 1693508119798,
      "end": 1693508120274,
      "sourcemaps": null
    }
  ]
}
