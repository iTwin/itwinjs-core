{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/common/lib/esm/geometry/GeometryStream.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Geometry\n */\nimport { Id64, IModelStatus } from \"@itwin/core-bentley\";\nimport { Angle, GeometryQuery, IModelJson as GeomJson, Matrix3d, Point2d, Point3d, Range3d, Transform, Vector3d, YawPitchRollAngles, } from \"@itwin/core-geometry\";\nimport { ColorDef } from \"../ColorDef\";\nimport { isPlacement2dProps } from \"../ElementProps\";\nimport { BackgroundFill, FillDisplay, GeometryParams } from \"../GeometryParams\";\nimport { Gradient } from \"../Gradient\";\nimport { IModelError } from \"../IModelError\";\nimport { AreaPattern } from \"./AreaPattern\";\nimport { ImageGraphic } from \"./ImageGraphic\";\nimport { LineStyle } from \"./LineStyle\";\nimport { TextString } from \"./TextString\";\nimport { Placement2d, Placement3d } from \"./Placement\";\n/** JSON representation of a brep GeometryStream entry.\n * @public\n */\nexport var BRepEntity;\n(function (BRepEntity) {\n    /** Enum for type of solid kernel entity this represents */\n    let Type;\n    (function (Type) {\n        /** Body consisting of at least one solid region */\n        Type[Type[\"Solid\"] = 0] = \"Solid\";\n        /** Body consisting of connected sets of faces having edges that are shared by a maximum of two faces */\n        Type[Type[\"Sheet\"] = 1] = \"Sheet\";\n        /** Body consisting of connected sets of edges having vertices that are shared by a maximum of two edges */\n        Type[Type[\"Wire\"] = 2] = \"Wire\";\n    })(Type = BRepEntity.Type || (BRepEntity.Type = {}));\n})(BRepEntity || (BRepEntity = {}));\n/** Flags applied to the entire contents of a [[GeometryStreamProps]].\n * @see GeometryStreamHeaderProps\n * @public\n * @extensions\n */\nexport var GeometryStreamFlags;\n(function (GeometryStreamFlags) {\n    /** No flags. */\n    GeometryStreamFlags[GeometryStreamFlags[\"None\"] = 0] = \"None\";\n    /** When the geometry is displayed, it is always oriented to face the viewer. The placement origin of the element associated with the geometry is used as the rotation point.\n     * If the placement origin is outside of the view, the geometry will not necessarily be displayed, even if rotating it to face the viewer would cause its range to intersect the viewed volume.\n     */\n    GeometryStreamFlags[GeometryStreamFlags[\"ViewIndependent\"] = 1] = \"ViewIndependent\";\n})(GeometryStreamFlags || (GeometryStreamFlags = {}));\n/** GeometryStreamBuilder is a helper class for populating the [[GeometryStreamProps]] array needed to create a [[GeometricElement]] or [[GeometryPart]].\n * @public\n */\nexport class GeometryStreamBuilder {\n    constructor() {\n        /** GeometryStream entries */\n        this.geometryStream = [];\n    }\n    /** Supply optional local to world transform. Used to transform world coordinate input relative to element placement.\n     * For a [[GeometricElement]]'s placement to be meaningful, world coordinate geometry should never be appended to an element with an identity placement.\n     * Can be called with undefined or identity transform to start appending geometry supplied in local coordinates again.\n     */\n    setLocalToWorld(localToWorld) {\n        this._worldToLocal = (undefined === localToWorld || localToWorld.isIdentity ? undefined : localToWorld.inverse());\n    }\n    /** Supply local to world transform from a Point3d and optional YawPitchRollAngles.\n     * @see [[Placement3d]]\n     */\n    setLocalToWorld3d(origin, angles = YawPitchRollAngles.createDegrees(0.0, 0.0, 0.0)) {\n        this.setLocalToWorld(Transform.createOriginAndMatrix(origin, angles.toMatrix3d()));\n    }\n    /** Supply local to world transform from a Point2d and optional Angle.\n     * @see [[Placement2d]]\n     */\n    setLocalToWorld2d(origin, angle = Angle.createDegrees(0.0)) {\n        this.setLocalToWorld(Transform.createOriginAndMatrix(Point3d.createFrom(origin), Matrix3d.createRotationAroundVector(Vector3d.unitZ(), angle)));\n    }\n    /** Supply local to world transform from a PlacementProps2d or PlacementProps3d.\n     * @see [[PlacementProps]]\n     */\n    setLocalToWorldFromPlacement(props) {\n        const placement = isPlacement2dProps(props) ? Placement2d.fromJSON(props) : Placement3d.fromJSON(props);\n        this.setLocalToWorld(placement.transform);\n    }\n    /** Store local ranges in GeometryStream for all subsequent geometry appended. Can improve performance of range testing for elements with a GeometryStream\n     * containing more than one [[GeometryQuery]] differentiable by range. Not useful for a single [[GeometryQuery]] as its range and that of the [[GeometricElement]] are the same.\n     * Ignored when defining a [[GeometryPart]] and not needed when only appending [[GeometryPart]] instances to a [[GeometricElement]] as these store their own range.\n     */\n    appendGeometryRanges() {\n        this.geometryStream.push({ subRange: Range3d.createNull() });\n    }\n    /** Change [[SubCategory]] or reset to [[SubCategoryAppearance]] for subsequent geometry.\n     *  An invalid sub-category id can be supplied to force a reset to the current [[SubCategoryAppearance]].\n     *  It is not valid to change the sub-category when defining a [[GeometryPart]]. A [[GeometryPart]] inherit the symbology of their instance for anything not explicitly overridden.\n     */\n    appendSubCategoryChange(subCategoryId) {\n        this.geometryStream.push({ appearance: { subCategory: subCategoryId } });\n        return true;\n    }\n    /** Change [[GeometryParams]] for subsequent geometry.\n     *  It is not valid to change the sub-category when defining a [[GeometryPart]]. A [[GeometryPart]] inherits the symbology of their instance for anything not explicitly overridden.\n     */\n    appendGeometryParamsChange(geomParams) {\n        const appearance = {\n            subCategory: geomParams.subCategoryId,\n            color: geomParams.lineColor?.toJSON(),\n            weight: geomParams.weight,\n            style: geomParams.styleInfo?.styleId,\n            transparency: geomParams.elmTransparency,\n            displayPriority: geomParams.elmPriority,\n            geometryClass: geomParams.geometryClass,\n        };\n        this.geometryStream.push({ appearance });\n        if (undefined !== geomParams.materialId)\n            this.geometryStream.push({ material: { materialId: geomParams.materialId } });\n        if (undefined !== geomParams.fillDisplay && FillDisplay.Never !== geomParams.fillDisplay) {\n            const fill = {\n                display: geomParams.fillDisplay,\n                transparency: geomParams.fillTransparency,\n            };\n            if (undefined !== geomParams.gradient && Gradient.Mode.None !== geomParams.gradient.mode)\n                fill.gradient = geomParams.gradient?.toJSON();\n            else if (undefined !== geomParams.backgroundFill && BackgroundFill.None !== geomParams.backgroundFill)\n                fill.backgroundFill = geomParams.backgroundFill;\n            else if (undefined !== geomParams.fillColor)\n                fill.color = geomParams.fillColor.toJSON();\n            this.geometryStream.push({ fill });\n        }\n        if (undefined !== geomParams.pattern) {\n            const localPattern = this._worldToLocal ? geomParams.pattern.clone() : geomParams.pattern;\n            if (undefined !== this._worldToLocal && !localPattern.applyTransform(this._worldToLocal))\n                return false;\n            this.geometryStream.push({ pattern: localPattern.toJSON() });\n        }\n        if (undefined !== geomParams.styleInfo && undefined !== geomParams.styleInfo.styleMod) {\n            const localStyleMod = new LineStyle.Modifier(geomParams.styleInfo.styleMod);\n            if (undefined !== this._worldToLocal && !localStyleMod.applyTransform(this._worldToLocal))\n                return false;\n            this.geometryStream.push({ styleMod: localStyleMod });\n        }\n        return true;\n    }\n    /** Append a [[GeometryPart]] instance with relative position, orientation, and scale to a [[GeometryStreamProps]] array for creating a [[GeometricElement3d]].\n     *  Not valid when defining a [[GeometryPart]] as nesting of parts is not supported.\n     */\n    appendGeometryPart3d(partId, instanceOrigin, instanceRotation, instanceScale) {\n        if (undefined === this._worldToLocal) {\n            this.geometryStream.push({ geomPart: { part: partId, origin: instanceOrigin, rotation: instanceRotation, scale: instanceScale } });\n            return true;\n        }\n        const partTrans = Transform.createOriginAndMatrix(instanceOrigin, instanceRotation ? instanceRotation.toMatrix3d() : Matrix3d.createIdentity());\n        if (undefined !== instanceScale)\n            partTrans.matrix.scaleColumnsInPlace(instanceScale, instanceScale, instanceScale);\n        const resultTrans = this._worldToLocal.multiplyTransformTransform(partTrans);\n        const scales = new Vector3d();\n        if (!resultTrans.matrix.normalizeColumnsInPlace(scales))\n            return false;\n        const newRotation = YawPitchRollAngles.createFromMatrix3d(resultTrans.matrix);\n        if (undefined === newRotation)\n            return false;\n        this.geometryStream.push({ geomPart: { part: partId, origin: resultTrans.getOrigin(), rotation: newRotation, scale: scales.x } });\n        return true;\n    }\n    /** Append a [[GeometryPart]] instance with relative position, orientation, and scale to a [[GeometryStreamProps]] array for creating a [[GeometricElement2d]].\n     *  Not valid when defining a [[GeometryPart]] as nesting of parts is not supported.\n     */\n    appendGeometryPart2d(partId, instanceOrigin, instanceRotation, instanceScale) {\n        return this.appendGeometryPart3d(partId, instanceOrigin ? Point3d.createFrom(instanceOrigin) : undefined, instanceRotation ? new YawPitchRollAngles(instanceRotation) : undefined, instanceScale);\n    }\n    /** Append a [[TextString]] supplied in either local or world coordinates to the [[GeometryStreamProps]] array */\n    appendTextString(textString) {\n        if (undefined === this._worldToLocal) {\n            this.geometryStream.push({ textString });\n            return true;\n        }\n        const localTextString = new TextString(textString);\n        if (!localTextString.transformInPlace(this._worldToLocal))\n            return false;\n        this.geometryStream.push({ textString: localTextString });\n        return true;\n    }\n    /** Append an [[ImageGraphic]] supplied in either local or world coordinates. */\n    appendImage(image) {\n        if (undefined !== this._worldToLocal)\n            image = image.cloneTransformed(this._worldToLocal);\n        this.geometryStream.push({ image: image.toJSON() });\n        return true;\n    }\n    /** Append a [[GeometryQuery]] supplied in either local or world coordinates to the [[GeometryStreamProps]] array */\n    appendGeometry(geometry) {\n        if (undefined === this._worldToLocal) {\n            const geomData = GeomJson.Writer.toIModelJson(geometry);\n            if (undefined === geomData)\n                return false;\n            this.geometryStream.push(geomData);\n            return true;\n        }\n        const localGeometry = geometry.cloneTransformed(this._worldToLocal);\n        if (undefined === localGeometry)\n            return false;\n        const localGeomData = GeomJson.Writer.toIModelJson(localGeometry);\n        if (undefined === localGeomData)\n            return false;\n        this.geometryStream.push(localGeomData);\n        return true;\n    }\n    /** Append [[BRepEntity.DataProps]] supplied in either local or world coordinates to the [[GeometryStreamProps]] array\n     * @beta\n     */\n    appendBRepData(brep) {\n        if (undefined === this._worldToLocal) {\n            this.geometryStream.push({ brep });\n            return true;\n        }\n        const entityTrans = Transform.fromJSON(brep.transform);\n        const localTrans = entityTrans.multiplyTransformTransform(this._worldToLocal);\n        const localBrep = {\n            data: brep.data,\n            type: brep.type,\n            transform: localTrans.isIdentity ? undefined : localTrans.toJSON(),\n            faceSymbology: brep.faceSymbology,\n        };\n        this.geometryStream.push({ brep: localBrep });\n        return true;\n    }\n    /** @internal */\n    getHeader() {\n        return 0 < this.geometryStream.length ? this.geometryStream[0].header : undefined;\n    }\n    /** @internal */\n    obtainHeader() {\n        const hdr = this.getHeader();\n        if (undefined !== hdr)\n            return hdr;\n        const entry = { header: { flags: GeometryStreamFlags.None } };\n        this.geometryStream.unshift(entry);\n        return entry.header;\n    }\n    /** Controls whether or not the geometry in the stream should be displayed as view-independent.\n     * When view-independent geometry is displayed, it is always oriented to face the viewer, using the placement origin of the element as the rotation point.\n     * If the placement origin is outside of the view, the geometry will not necessarily be displayed, even if rotating it to face the viewer would cause its range to intersect the viewed volume\n     * @public\n     */\n    get isViewIndependent() {\n        const hdr = this.getHeader();\n        return undefined !== hdr && GeometryStreamFlags.None !== (hdr.flags & GeometryStreamFlags.ViewIndependent);\n    }\n    set isViewIndependent(viewIndependent) {\n        if (viewIndependent === this.isViewIndependent)\n            return;\n        const hdr = this.obtainHeader();\n        if (viewIndependent)\n            hdr.flags |= GeometryStreamFlags.ViewIndependent;\n        else\n            hdr.flags &= ~GeometryStreamFlags.ViewIndependent;\n    }\n}\nclass IteratorEntry {\n    constructor(appearance, localToWorld) {\n        this.geomParams = typeof appearance === \"string\" ? new GeometryParams(appearance) : appearance;\n        this.localToWorld = localToWorld;\n    }\n    get primitive() { return this._primitive; }\n    set primitive(primitive) { this._primitive = primitive; }\n    setGeometryQuery(geometry) { this._primitive = { type: \"geometryQuery\", geometry }; }\n    setTextString(textString) { this._primitive = { type: \"textString\", textString }; }\n    setBRep(brep) { this._primitive = { type: \"brep\", brep }; }\n    setImage(image) { this._primitive = { type: \"image\", image }; }\n    setPartReference(id, toLocal) {\n        this._primitive = {\n            type: \"partReference\",\n            part: { id, toLocal },\n        };\n    }\n}\n/** GeometryStreamIterator is a helper class for iterating a [[GeometryStreamProps]].\n * A [[GeometricElement]]'s GeometryStream must be specifically requested using [[ElementLoadProps.wantGeometry]].\n * Each [[GeometryStreamIteratorEntry]] returned by the iterator represents exactly one geometric primitive in the stream.\n * @public\n */\nexport class GeometryStreamIterator {\n    /** Construct a new GeometryStreamIterator given a [[GeometryStreamProps]] from either a [[GeometricElement3d]], [[GeometricElement2d]], or [[GeometryPart]].\n     * Supply the [[GeometricElement]]'s category to initialize the appearance information for each geometric entry.\n     */\n    constructor(geometryStream, categoryOrGeometryParams, localToWorld) {\n        /** Current entry position */\n        this._index = 0;\n        this.geometryStream = geometryStream;\n        this._appearance = categoryOrGeometryParams ?? Id64.invalid;\n        this._localToWorld = localToWorld;\n        if (0 < geometryStream.length && undefined !== geometryStream[0].header) {\n            this.flags = geometryStream[0].header.flags;\n            ++this._index;\n        }\n        else {\n            this.flags = GeometryStreamFlags.None;\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    get entry() {\n        if (undefined === this._entry)\n            this._entry = new IteratorEntry(this._appearance, this._localToWorld);\n        return this._entry;\n    }\n    /** Create a new GeometryStream iterator for a [[GeometricElement3d]].\n     * If [[GeometricElement3dProps.placement]] is not undefined, placement relative entries will be returned transformed to world coordinates.\n     * @throws [[IModelError]] if element.geom is undefined.\n     */\n    static fromGeometricElement3d(element) {\n        if (element.geom === undefined)\n            throw new IModelError(IModelStatus.NoGeometry, \"GeometricElement has no geometry or geometry wasn't requested\");\n        let transform;\n        if (element.placement !== undefined)\n            transform = Transform.createOriginAndMatrix(Point3d.fromJSON(element.placement.origin), YawPitchRollAngles.fromJSON(element.placement.angles).toMatrix3d());\n        return new GeometryStreamIterator(element.geom, element.category, transform);\n    }\n    /** Create a new GeometryStream iterator for a [[GeometricElement2d]].\n     * If [[GeometricElement2dProps.placement]] is not undefined, placement relative entries will be returned transformed to world coordinates.\n     * @throws [[IModelError]] if element.geom is undefined.\n     */\n    static fromGeometricElement2d(element) {\n        if (element.geom === undefined)\n            throw new IModelError(IModelStatus.NoGeometry, \"GeometricElement has no geometry or geometry wasn't requested\");\n        let transform;\n        if (element.placement !== undefined) {\n            const origin = Point3d.createFrom(Point2d.fromJSON(element.placement.origin));\n            const matrix = Matrix3d.createRotationAroundVector(Vector3d.unitZ(), Angle.fromJSON(element.placement.angle));\n            transform = Transform.createOriginAndMatrix(origin, matrix);\n        }\n        return new GeometryStreamIterator(element.geom, element.category, transform);\n    }\n    /** Create a new GeometryStream iterator for a [[GeometryPart]].\n     * To iterate a part's GeometryStream in the context of a part instance found for a [[GeometricElement]], provide the optional [[GeometryParams]] and Transform from the [[GeometricElement]]'s [[GeometryStreamIterator]].\n     * Supply the [[GeometryParams]] to return appearance information as inherited from the [[GeometricElement]].\n     * Supply the partToWorld transform to return the part geometry in world coordinates.\n     * Supply the partToLocal transform to return the part geometry relative to the [[GeometricElement]]'s placement.\n     * @throws [[IModelError]] if geomPart.geom is undefined.\n     */\n    static fromGeometryPart(geomPart, geomParams, partTransform) {\n        if (geomPart.geom === undefined)\n            throw new IModelError(IModelStatus.NoGeometry, \"GeometryPart has no geometry or geometry wasn't requested\");\n        return new GeometryStreamIterator(geomPart.geom, geomParams?.clone(), partTransform);\n    }\n    /** Get the transform that if applied to a [[GeometryPart]]'s GeometryStream entries would return them in world coordinates. */\n    partToWorld() {\n        if (undefined === this._entry)\n            return this._localToWorld;\n        const partToLocal = \"partReference\" === this._entry.primitive.type ? this._entry.primitive.part.toLocal : undefined;\n        if (this._entry.localToWorld === undefined || partToLocal === undefined)\n            return this._entry.localToWorld;\n        return this._entry.localToWorld.multiplyTransformTransform(partToLocal);\n    }\n    /** Advance to next displayable geometric entry while updating the current [[GeometryParams]] from appearance related entries.\n     * Geometric entries are [[TextString]], [[GeometryQuery]], [[GeometryPart]], [[ImageGraphic]], and [[BRepEntity.DataProps]].\n     */\n    next() {\n        // NOTE: localRange remains valid until we encounter either a new subRange entry or a geometry part reference.\n        while (this._index < this.geometryStream.length) {\n            const entry = this.geometryStream[this._index++];\n            if (entry.appearance) {\n                this.entry.geomParams.resetAppearance();\n                if (entry.appearance.subCategory)\n                    this.entry.geomParams.subCategoryId = Id64.fromJSON(entry.appearance.subCategory);\n                if (undefined !== entry.appearance.color)\n                    this.entry.geomParams.lineColor = ColorDef.fromJSON(entry.appearance.color);\n                if (undefined !== entry.appearance.weight)\n                    this.entry.geomParams.weight = entry.appearance.weight;\n                if (undefined !== entry.appearance.style)\n                    this.entry.geomParams.styleInfo = new LineStyle.Info(Id64.fromJSON(entry.appearance.style));\n                if (undefined !== entry.appearance.transparency)\n                    this.entry.geomParams.elmTransparency = entry.appearance.transparency;\n                if (undefined !== entry.appearance.displayPriority)\n                    this.entry.geomParams.elmPriority = entry.appearance.displayPriority;\n                if (undefined !== entry.appearance.geometryClass)\n                    this.entry.geomParams.geometryClass = entry.appearance.geometryClass;\n            }\n            else if (entry.styleMod) {\n                if (this.entry.geomParams.styleInfo === undefined)\n                    continue;\n                const styleMod = new LineStyle.Modifier(entry.styleMod);\n                if (this.entry.localToWorld !== undefined)\n                    styleMod.applyTransform(this.entry.localToWorld);\n                this.entry.geomParams.styleInfo = new LineStyle.Info(this.entry.geomParams.styleInfo.styleId, styleMod);\n            }\n            else if (entry.fill) {\n                if (entry.fill.display)\n                    this.entry.geomParams.fillDisplay = entry.fill.display;\n                if (entry.fill.transparency)\n                    this.entry.geomParams.fillTransparency = entry.fill.transparency;\n                if (entry.fill.gradient)\n                    this.entry.geomParams.gradient = Gradient.Symb.fromJSON(entry.fill.gradient);\n                else if (entry.fill.backgroundFill)\n                    this.entry.geomParams.backgroundFill = entry.fill.backgroundFill;\n                else if (entry.fill.color)\n                    this.entry.geomParams.fillColor = ColorDef.fromJSON(entry.fill.color);\n            }\n            else if (entry.pattern) {\n                const params = AreaPattern.Params.fromJSON(entry.pattern);\n                if (this.entry.localToWorld !== undefined)\n                    params.applyTransform(this.entry.localToWorld);\n                this.entry.geomParams.pattern = params;\n            }\n            else if (entry.material) {\n                if (entry.material.materialId)\n                    this.entry.geomParams.materialId = Id64.fromJSON(entry.material.materialId);\n            }\n            else if (entry.subRange) {\n                this.entry.localRange = Range3d.fromJSON(entry.subRange);\n            }\n            else if (entry.geomPart) {\n                let transform;\n                if (entry.geomPart.origin !== undefined || entry.geomPart.rotation !== undefined || entry.geomPart.scale !== undefined) {\n                    const origin = entry.geomPart.origin ? Point3d.fromJSON(entry.geomPart.origin) : Point3d.createZero();\n                    const rotation = entry.geomPart.rotation ? YawPitchRollAngles.fromJSON(entry.geomPart.rotation).toMatrix3d() : Matrix3d.createIdentity();\n                    transform = Transform.createRefs(origin, rotation);\n                    if (entry.geomPart.scale)\n                        transform.multiplyTransformTransform(Transform.createRefs(Point3d.createZero(), Matrix3d.createUniformScale(entry.geomPart.scale)), transform);\n                }\n                // Subgraphic range doesn't apply to parts. A sane geometry stream (i.e., any that has been through the native layers or GeometryStreamBuilder)\n                // will have a new subgraphic range for any geometric primitive following the part.\n                this.entry.localRange = undefined;\n                this.entry.setPartReference(Id64.fromJSON(entry.geomPart.part), transform);\n                return { value: this.entry, done: false };\n            }\n            else if (entry.textString) {\n                const textString = new TextString(entry.textString);\n                if (this.entry.localToWorld !== undefined)\n                    textString.transformInPlace(this.entry.localToWorld);\n                this.entry.setTextString(textString);\n                return { value: this.entry, done: false };\n            }\n            else if (entry.image) {\n                const image = ImageGraphic.fromJSON(entry.image);\n                if (undefined !== this.entry.localToWorld)\n                    image.transformInPlace(this.entry.localToWorld);\n                this.entry.setImage(image);\n                return { value: this.entry, done: false };\n            }\n            else if (entry.brep) {\n                if (this.entry.localToWorld !== undefined) {\n                    const entityTrans = Transform.fromJSON(entry.brep.transform);\n                    entry.brep.transform = entityTrans.multiplyTransformTransform(this.entry.localToWorld).toJSON();\n                }\n                this.entry.setBRep(entry.brep);\n                return { value: this.entry, done: false };\n            }\n            else {\n                const geometryQuery = GeomJson.Reader.parse(entry);\n                if (!(geometryQuery instanceof GeometryQuery))\n                    continue;\n                if (this.entry.localToWorld !== undefined)\n                    geometryQuery.tryTransformInPlace(this.entry.localToWorld);\n                this.entry.setGeometryQuery(geometryQuery);\n                return { value: this.entry, done: false };\n            }\n        }\n        return { value: this.entry, done: true };\n    }\n    [Symbol.iterator]() {\n        return this;\n    }\n    /** @internal */\n    get isViewIndependent() { return GeometryStreamFlags.None !== (this.flags & GeometryStreamFlags.ViewIndependent); }\n}\n//# sourceMappingURL=GeometryStream.js.map",
      "start": 1693508120574,
      "end": 1693508120667,
      "sourcemaps": null
    }
  ]
}
