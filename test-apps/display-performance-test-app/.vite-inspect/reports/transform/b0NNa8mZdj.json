{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/bspline/InterpolationCurve3d.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Bspline\n */\nimport { Vector3d } from \"../geometry3d/Point3dVector3d\";\nimport { Geometry } from \"../Geometry\";\nimport { Point3dArray } from \"../geometry3d/PointHelpers\";\nimport { ProxyCurve } from \"../curve/ProxyCurve\";\nimport { BSplineCurveOps } from \"../bspline/BSplineCurveOps\";\nimport { BSplineCurve3d } from \"./BSplineCurve\";\n/**\n * fitPoints and end condition data for [[InterpolationCurve3d]]\n * * This is a \"typed object\" version of the serializer-friendly [[InterpolationCurve3dProps]]\n * * Typical use cases rarely require all parameters, so the constructor does not itemize them as parameters.\n * @public\n */\nexport class InterpolationCurve3dOptions {\n    /**\n     * Constructor.\n     * @param fitPoints points to CAPTURE\n     * @param knots array to CAPTURE\n     */\n    constructor(fitPoints, knots) {\n        this._fitPoints = fitPoints ? fitPoints : [];\n        this._knots = knots;\n    }\n    /** `order` as property */\n    get order() { return Geometry.resolveNumber(this._order, 4); }\n    set order(val) { this._order = val; }\n    /** `closed` as property */\n    get closed() { return Geometry.resolveValue(this._closed, false); }\n    set closed(val) { this._closed = val; }\n    /** `isChordLenKnots` as property */\n    get isChordLenKnots() { return Geometry.resolveNumber(this._isChordLenKnots, 0); }\n    set isChordLenKnots(val) { this._isChordLenKnots = val; }\n    /** `isColinearTangents` as property */\n    get isColinearTangents() { return Geometry.resolveNumber(this._isColinearTangents, 0); }\n    set isColinearTangents(val) { this._isColinearTangents = val; }\n    /** `isChordLenTangents` as property */\n    get isChordLenTangents() { return Geometry.resolveNumber(this._isChordLenTangents, 0); }\n    set isChordLenTangents(val) { this._isChordLenTangents = val; }\n    /** `isNaturalTangents` as property */\n    get isNaturalTangents() { return Geometry.resolveNumber(this._isNaturalTangents, 0); }\n    set isNaturalTangents(val) { this._isNaturalTangents = val; }\n    /** access POSSIBLY UNDEFINED start tangent. Setter CAPTURES. */\n    get startTangent() { return this._startTangent; }\n    set startTangent(val) { this._startTangent = val; }\n    /** access POSSIBLY UNDEFINED end tangent. Setter CAPTURES. */\n    get endTangent() { return this._endTangent; }\n    set endTangent(val) { this._endTangent = val; }\n    /** access POINTER TO fit points. Setter CAPTURES. */\n    get fitPoints() { return this._fitPoints; }\n    set fitPoints(val) { this._fitPoints = val; }\n    /** access POSSIBLY UNDEFINED knots array. Setter CAPTURES. */\n    get knots() { return this._knots; }\n    set knots(val) { this._knots = val; }\n    /** One step setup of properties not named in constructor.\n     * * CAPTURE pointers to tangents.\n     * * OPTIONALLY downgrade \"0\" values to undefined.\n     */\n    captureOptionalProps(order, closed, isChordLenKnots, isColinearTangents, isChordLenTangent, isNaturalTangents, startTangent, endTangent) {\n        this._order = Geometry.resolveToUndefined(order, 0);\n        this._closed = Geometry.resolveToUndefined(closed, false);\n        this._isChordLenKnots = Geometry.resolveToUndefined(isChordLenKnots, 0);\n        this._isColinearTangents = Geometry.resolveToUndefined(isColinearTangents, 0);\n        this._isChordLenTangents = Geometry.resolveToUndefined(isChordLenTangent, 0);\n        this._isNaturalTangents = Geometry.resolveToUndefined(isNaturalTangents, 0);\n        this._startTangent = startTangent;\n        this._endTangent = endTangent;\n    }\n    /** Clone with strongly typed members reduced to simple json, with \"undefined\" members omitted */\n    cloneAsInterpolationCurve3dProps() {\n        const props = {\n            fitPoints: Point3dArray.cloneDeepJSONNumberArrays(this.fitPoints),\n            knots: this._knots?.slice(),\n        };\n        if (this._order !== undefined)\n            props.order = this._order;\n        if (this._closed !== undefined)\n            props.closed = this._closed;\n        if (this._isChordLenKnots !== undefined)\n            props.isChordLenKnots = this._isChordLenKnots;\n        if (this._isColinearTangents !== undefined)\n            props.isColinearTangents = this._isColinearTangents;\n        if (this._isChordLenTangents !== undefined)\n            props.isChordLenTangents = this._isChordLenTangents;\n        if (this._isNaturalTangents !== undefined)\n            props.isNaturalTangents = this._isNaturalTangents;\n        if (this._startTangent !== undefined)\n            props.startTangent = this._startTangent?.toArray();\n        if (this._endTangent !== undefined)\n            props.endTangent = this._endTangent?.toArray();\n        return props;\n    }\n    /** Clone with strongly typed members reduced to simple json. */\n    clone() {\n        const clone = new InterpolationCurve3dOptions(Point3dArray.clonePoint3dArray(this.fitPoints), this.knots?.slice());\n        clone._order = this.order;\n        clone._closed = this.closed;\n        clone._isChordLenKnots = this.isChordLenKnots;\n        clone._isColinearTangents = this.isColinearTangents;\n        clone._isChordLenTangents = this.isChordLenTangents;\n        clone._isNaturalTangents = this.isNaturalTangents;\n        clone._startTangent = this._startTangent?.clone();\n        clone._endTangent = this._endTangent?.clone();\n        return clone;\n    }\n    /** Clone with strongly typed members reduced to simple json. */\n    static create(source) {\n        const result = new InterpolationCurve3dOptions(Point3dArray.clonePoint3dArray(source.fitPoints), source.knots?.slice());\n        result._order = source.order;\n        result._closed = source.closed;\n        result._isChordLenKnots = source.isChordLenKnots;\n        result._isColinearTangents = source.isColinearTangents;\n        result._isChordLenTangents = source.isChordLenTangents;\n        result._isNaturalTangents = source.isNaturalTangents;\n        result._startTangent = source.startTangent ? Vector3d.fromJSON(source.startTangent) : undefined;\n        result._endTangent = source.endTangent ? Vector3d.fromJSON(source.endTangent) : undefined;\n        return result;\n    }\n    // ugh.\n    // vector equality test with awkward rule that 000 matches undefined.\n    static areAlmostEqualAllow000AsUndefined(a, b) {\n        if (a !== undefined && a.maxAbs() === 0)\n            a = undefined;\n        if (b !== undefined && b.maxAbs() === 0)\n            b = undefined;\n        if (a !== undefined && b !== undefined)\n            return a.isAlmostEqual(b);\n        return a === undefined && b === undefined;\n    }\n    static areAlmostEqual(dataA, dataB) {\n        if (dataA === undefined && dataB === undefined)\n            return true;\n        if (dataA !== undefined && dataB !== undefined) {\n            if (Geometry.areEqualAllowUndefined(dataA.order, dataB.order)\n                && Geometry.areEqualAllowUndefined(dataA.closed, dataB.closed)\n                && Geometry.areEqualAllowUndefined(dataA.isChordLenKnots, dataB.isChordLenKnots)\n                && Geometry.areEqualAllowUndefined(dataA.isColinearTangents, dataB.isColinearTangents)\n                && Geometry.areEqualAllowUndefined(dataA.isNaturalTangents, dataB.isNaturalTangents)\n                && this.areAlmostEqualAllow000AsUndefined(dataA.startTangent, dataB.startTangent)\n                && this.areAlmostEqualAllow000AsUndefined(dataA.endTangent, dataB.endTangent)\n                && Geometry.almostEqualArrays(dataA.fitPoints, dataB.fitPoints, (a, b) => a.isAlmostEqual(b))) {\n                if (Geometry.almostEqualNumberArrays(dataA.knots, dataB.knots, (a, b) => a === b))\n                    return true;\n                if (dataA.knots === undefined && dataB.knots === undefined)\n                    return true;\n                /* alas .. need to allow tricky mismatch of end replication */\n                let knotsA = dataA.knots, knotsB = dataB.knots;\n                if (dataA.knots === undefined) // construct undefined knots to compare against defined knots\n                    knotsA = BSplineCurveOps.C2CubicFit.constructFitParametersFromPoints(dataA.fitPoints, dataA.isChordLenKnots, dataA.closed);\n                else if (dataB.knots === undefined)\n                    knotsB = BSplineCurveOps.C2CubicFit.constructFitParametersFromPoints(dataB.fitPoints, dataB.isChordLenKnots, dataB.closed);\n                knotsA = BSplineCurveOps.C2CubicFit.convertCubicKnotVectorToFitParams(knotsA, dataA.fitPoints.length, false);\n                knotsB = BSplineCurveOps.C2CubicFit.convertCubicKnotVectorToFitParams(knotsB, dataB.fitPoints.length, false);\n                return Geometry.almostEqualNumberArrays(knotsA, knotsB, (a, b) => Geometry.isAlmostEqualNumber(a, b));\n            }\n        }\n        return false;\n    }\n    /** reverse the order or sense of all start-to-end related properties. */\n    reverseInPlace() {\n        this.fitPoints.reverse();\n        if (this.knots)\n            this.knots.reverse();\n        // Swap pointers to tangents. They don't need to be negated because they point into the curve.\n        const oldStart = this._startTangent;\n        this._startTangent = this.endTangent;\n        this._endTangent = oldStart;\n    }\n}\n/**\n * Interpolating curve.\n * * Derive from [[ProxyCurve]]\n * * Use a [[BSplineCurve3d]] as the proxy\n * *\n * @public\n */\nexport class InterpolationCurve3d extends ProxyCurve {\n    /**\n     * CAPTURE properties and proxy curve.\n     */\n    constructor(properties, proxyCurve) {\n        super(proxyCurve);\n        this.curvePrimitiveType = \"interpolationCurve\";\n        this._options = properties;\n    }\n    dispatchToGeometryHandler(handler) {\n        let result = handler.handleInterpolationCurve3d(this);\n        if (undefined === result) // if handler doesn't specialize on interpolation curves, default to proxy\n            result = this._proxyCurve.dispatchToGeometryHandler(handler);\n        return result;\n    }\n    /**\n     * Create an [[InterpolationCurve3d]] based on points, knots, and other properties in the [[InterpolationCurve3dProps]] or [[InterpolationCurve3dOptions]].\n     * * This saves a COPY OF the options or props.\n     * * Use createCapture () if the options or props can be used without copy\n     */\n    static create(options) {\n        let optionsCopy;\n        if (options instanceof InterpolationCurve3dOptions) {\n            optionsCopy = options.clone();\n        }\n        else {\n            optionsCopy = InterpolationCurve3dOptions.create(options);\n        }\n        return InterpolationCurve3d.createCapture(optionsCopy);\n    }\n    /** Create an [[InterpolationCurve3d]]\n     * * The options object is captured into the new curve object (not copied)\n     */\n    static createCapture(options) {\n        const proxyCurve = BSplineCurve3d.createFromInterpolationCurve3dOptions(options);\n        if (proxyCurve)\n            return new InterpolationCurve3d(options, proxyCurve);\n        return undefined;\n    }\n    /** Return a (copy of) the defining points, packed as a Float64Array */\n    copyFitPointsFloat64Array() {\n        return Point3dArray.cloneXYZPropsAsFloat64Array(this._options.fitPoints);\n    }\n    /**\n     * Return json key-value pairs for for this [[InterpolationCurve3d]].\n     * @returns\n     */\n    toJSON() {\n        return this._options.cloneAsInterpolationCurve3dProps();\n    }\n    /** Clone the [[InterpolationCurve3dProps]] object in this [[InterpolationCurve3d]] */\n    cloneProps() {\n        return this._options.cloneAsInterpolationCurve3dProps();\n    }\n    /** return the options pointer */\n    get options() { return this._options; }\n    /**\n     * Reverse the curve direction.\n     * * This updates both the defining properties and the proxy bspline.\n     */\n    reverseInPlace() {\n        this._proxyCurve.reverseInPlace();\n        this._options.reverseInPlace();\n    }\n    /**\n     * Transform this [[InterpolationCurve3d]] and its defining data in place\n     */\n    tryTransformInPlace(transform) {\n        const proxyOk = this._proxyCurve.tryTransformInPlace(transform);\n        if (proxyOk) {\n            transform.multiplyPoint3dArrayInPlace(this._options.fitPoints);\n            if (this._options.startTangent)\n                transform.multiplyVectorInPlace(this._options.startTangent);\n            if (this._options.endTangent)\n                transform.multiplyVectorInPlace(this._options.endTangent);\n        }\n        return proxyOk;\n    }\n    /** Return a deep clone */\n    clone() {\n        return new InterpolationCurve3d(this._options.clone(), this._proxyCurve.clone());\n    }\n    isAlmostEqual(other) {\n        if (other instanceof InterpolationCurve3d) {\n            return InterpolationCurve3dOptions.areAlmostEqual(this._options, other._options);\n        }\n        return false;\n    }\n    /** Test if `other` is also an [[InterpolationCurve3d]] */\n    isSameGeometryClass(other) { return other instanceof InterpolationCurve3d; }\n}\n//# sourceMappingURL=InterpolationCurve3d.js.map",
      "start": 1693508123030,
      "end": 1693508123189,
      "sourcemaps": null
    }
  ]
}
