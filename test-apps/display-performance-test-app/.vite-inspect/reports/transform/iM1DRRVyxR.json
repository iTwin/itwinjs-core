{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/topology/XYParitySearchContext.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Topology\n */\n/**\n * * XYParitySearchContext is an internal class for callers that can feed points (without extracting to array structures)\n * * Most will be via static methods which handle a specific data source.\n *   * PolygonOps.classifyPointInPolygon (x,y,points: XAndY[])\n *   * HalfEdgeGraphSearch.pointInOrOnFaceXY (halfEdgeOnFace, x, y)\n * Use pattern:\n * * Caller must be able walk around polygon producing x,y coordinates (possibly transformed from actual polygon)\n * * Caller announce edges to tryStartEdge until finding one acceptable to the search.\n * * Caller then passes additional points up to and including both x0,y0 and x1, y1 of the accepted start edge.\n * Call sequence is:\n *    `context = new XYParitySearchContext`\n *    `repeat {  acquire edge (x0,y0) (x1,y1)} until context.tryStartEdge (x0,y0,x1,y1);`\n *    `for each (x,y) beginning AFTER x1,y1 and ending with (x1,y1) context.advance (x,y)`\n *  `return context.classifyCounts ();`\n */\nexport class XYParitySearchContext {\n    /**\n     * Create a new searcher for specified test point.\n     * @param xTest x coordinate of test point\n     * @param yTest y coordinate of test point\n     */\n    constructor(xTest, yTest) {\n        this.xTest = xTest;\n        this.yTest = yTest;\n        this.u0 = this.v0 = this.u1 = this.v1 = 0; // Not valid for search -- caller must satisfy tryStartEdge !!!\n        this.numLeftCrossing = this.numRightCrossing = 0;\n        this.numHit = 0;\n    }\n    /**\n     * test if x,y is a safe first coordinate to start the search.\n     * * safe start must have non-zero y so that final point test (return to x0,y0) does not need look back for exact crossing logic.\n     * @param x\n     * @param y\n     */\n    tryStartEdge(x0, y0, x1, y1) {\n        if (y0 !== this.yTest) {\n            this.u0 = x0 - this.xTest;\n            this.v0 = y0 - this.yTest;\n            this.u1 = x1 - this.xTest;\n            this.v1 = y1 - this.yTest;\n            return true;\n        }\n        return false;\n    }\n    /** Return true if parity accumulation proceeded normally.\n     * Return false if interrupted for exact hit.\n     */\n    advance(x, y) {\n        const u = x - this.xTest;\n        const v = y - this.yTest;\n        const p = v * this.v1;\n        if (p > 0) {\n            // The common case -- skittering along above or below the x axis . . .\n            this.u0 = this.u1;\n            this.v0 = this.v1;\n            this.u1 = u;\n            this.v1 = v;\n            return true;\n        }\n        if (p < 0) {\n            // crossing within (u1,v1) to (u,v)\n            // both v values are nonzero and of opposite sign, so this division is safe . . .\n            const fraction = -this.v1 / (v - this.v1);\n            const uCross = this.u1 + fraction * (u - this.u1);\n            if (uCross === 0.0) {\n                this.numHit++;\n                return false;\n            }\n            if (uCross > 0)\n                this.numRightCrossing++;\n            else\n                this.numLeftCrossing++;\n            this.u0 = this.u1;\n            this.v0 = this.v1;\n            this.u1 = u;\n            this.v1 = v;\n            return true;\n        }\n        // hard stuff -- one or more exact hits . . .\n        if (v === 0.0) {\n            if (this.v1 === 0.0) {\n                // uh oh -- moving along x axis.  Does it pass through xTest:\n                if (u * this.u1 <= 0.0) {\n                    this.numHit++;\n                    return false;\n                }\n                // quietly moving along the scan line, both xy and x1y1 to same side of test point ...\n                // u0 and u1 remain unchanged !!!\n                this.u1 = u;\n                this.v1 = v;\n                return true;\n            }\n            // just moved onto the scan line ...\n            this.u0 = this.u1;\n            this.v0 = this.v1;\n            this.u1 = u;\n            this.v1 = v;\n            return true;\n        }\n        // fall out with v1 = 0\n        // both v0 and v are nonzero.\n        // any along-0 v values that have passed through are on the same side of xTest, so u1 determines crossing\n        const q = this.v0 * v;\n        if (this.u1 > 0) {\n            if (q < 0)\n                this.numRightCrossing++;\n        }\n        else {\n            if (q < 0)\n                this.numLeftCrossing++;\n        }\n        this.u0 = this.u1;\n        this.v0 = this.v1;\n        this.u1 = u;\n        this.v1 = v;\n        return true;\n    }\n    /**\n     * Return classification as ON, IN, or OUT according to hit and crossing counts.\n     * * Any nonzero hit count is ON\n     * * Otherwise IN if left crossing count is odd.\n     * @return 0 if ON, 1 if IN, -1 if OUT\n     */\n    classifyCounts() {\n        if (this.numHit > 0)\n            return 0;\n        const parity = this.numLeftCrossing & 0x01;\n        return (parity === 1) ? 1 : -1;\n    }\n}\n//# sourceMappingURL=XYParitySearchContext.js.map",
      "start": 1693508124086,
      "end": 1693508124159,
      "sourcemaps": null
    }
  ]
}
