{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tools/ElementSetTool.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tools\n */\nimport { CompressedId64Set, Id64, OrderedId64Array } from \"@itwin/core-bentley\";\nimport { ColorDef, QueryRowFormat } from \"@itwin/core-common\";\nimport { Point2d, Range2d } from \"@itwin/core-geometry\";\nimport { AccuDrawHintBuilder } from \"../AccuDraw\";\nimport { LocateFilterStatus, LocateResponse } from \"../ElementLocateManager\";\nimport { IModelApp } from \"../IModelApp\";\nimport { NotifyMessageDetails, OutputMessagePriority } from \"../NotificationManager\";\nimport { Pixel } from \"../render/Pixel\";\nimport { ViewRect } from \"../common/ViewRect\";\nimport { PrimitiveTool } from \"./PrimitiveTool\";\nimport { SelectionMethod } from \"./SelectTool\";\nimport { BeButton, BeButtonEvent, BeModifierKeys, CoreTools, EventHandled } from \"./Tool\";\nimport { ToolAssistance, ToolAssistanceImage, ToolAssistanceInputMethod } from \"./ToolAssistance\";\n/** @alpha */\nexport var ModifyElementSource;\n(function (ModifyElementSource) {\n    /** The source for the element is unknown - not caused by a modification command. */\n    ModifyElementSource[ModifyElementSource[\"Unknown\"] = 0] = \"Unknown\";\n    /** The element is selected by the user. */\n    ModifyElementSource[ModifyElementSource[\"Selected\"] = 1] = \"Selected\";\n    /** The element is processed because it is in the selection set. */\n    ModifyElementSource[ModifyElementSource[\"SelectionSet\"] = 2] = \"SelectionSet\";\n    /** The element is selected by the user using drag box or crossing line selection. */\n    ModifyElementSource[ModifyElementSource[\"DragSelect\"] = 3] = \"DragSelect\";\n})(ModifyElementSource || (ModifyElementSource = {}));\n/** The ElementAgenda class is used by [[ElementSetTool]] to hold the collection of elements it will operate on\n * and to manage their hilite state.\n * @see [[ElementSetTool]]\n * @alpha\n*/\nexport class ElementAgenda {\n    constructor(iModel) {\n        this.iModel = iModel;\n        /** The IDs of the elements in this agenda.\n         * @note Prefer methods like [[ElementAgenda.add]] instead of modifying directly.\n         */\n        this.elements = [];\n        /** The group source identifiers for the elements in this agenda.\n         * @note Prefer methods like [[ElementAgenda.add]] instead of modifying directly.\n         */\n        this.groupMarks = [];\n        this.manageHiliteState = true; // Whether entries are hilited/unhilited as they are added/removed...\n    }\n    /** Get the source for the last group added to this agenda, if applicable. The \"source\" is merely an indication of what the collection of elements represents. */\n    getSource() {\n        return this.groupMarks.length === 0 ? ModifyElementSource.Unknown : this.groupMarks[this.groupMarks.length - 1].source;\n    }\n    /** Set the source for the last group added to this agenda. */\n    setSource(val) {\n        if (this.groupMarks.length > 0)\n            this.groupMarks[this.groupMarks.length - 1].source = val;\n    }\n    get isEmpty() { return this.length === 0; }\n    get count() { return this.length; }\n    get length() { return this.elements.length; }\n    /** Create [[OrderedId64Array]] from agenda. */\n    orderIds() {\n        const ids = new OrderedId64Array();\n        this.elements.forEach((id) => ids.insert(id));\n        return ids;\n    }\n    /** Create [[CompressedId64Set]] from agenda. */\n    compressIds() {\n        const ids = this.orderIds();\n        return CompressedId64Set.compressIds(ids);\n    }\n    /** Empties the agenda and clears hilite state when manageHiliteState is true. */\n    clear() {\n        this.setEntriesHiliteState(false);\n        this.elements.length = 0;\n        this.groupMarks.length = 0;\n    }\n    setEntriesHiliteState(onOff, groupStart = 0, groupEnd = 0) {\n        if (!this.manageHiliteState)\n            return;\n        const ss = this.iModel.selectionSet.isActive ? this.iModel.selectionSet.elements : undefined;\n        if (undefined === ss && 0 === groupEnd) {\n            this.iModel.hilited.setHilite(this.elements, onOff);\n            return;\n        }\n        const shouldChangeHilite = (id, index) => {\n            if (undefined !== ss && ss.has(id))\n                return false; // Don't turn hilite on/off for elements in current selection set...\n            return (0 === groupEnd || (index >= groupStart && index < groupEnd));\n        };\n        const group = this.elements.filter((id, index) => shouldChangeHilite(id, index));\n        this.iModel.hilited.setHilite(group, onOff);\n    }\n    /** Removes the last group of elements added to this agenda. */\n    popGroup() {\n        if (this.groupMarks.length <= 1) {\n            this.clear();\n            return;\n        }\n        const group = this.groupMarks.pop();\n        this.setEntriesHiliteState(false, group.start, this.length); // make sure removed entries aren't left hilited...\n        this.elements.splice(group.start);\n    }\n    /** Return true if elementId is already in this agenda. */\n    has(id) { return this.elements.some((entry) => id === entry); }\n    /** Return true if elementId is already in this agenda. */\n    find(id) { return this.has(id); }\n    /** Add elements to this agenda. */\n    add(arg) {\n        const groupStart = this.length;\n        for (const id of Id64.iterable(arg))\n            if (!this.has(id))\n                this.elements.push(id);\n        if (groupStart === this.length)\n            return false;\n        this.groupMarks.push({ start: groupStart, source: ModifyElementSource.Unknown });\n        this.setEntriesHiliteState(true, groupStart, this.length);\n        return true;\n    }\n    removeOne(id) {\n        let pos = -1;\n        const elements = this.elements;\n        const groupMarks = this.groupMarks;\n        elements.some((entry, index) => {\n            if (id !== entry)\n                return false;\n            pos = index;\n            return true;\n        });\n        if (pos === -1)\n            return false;\n        if (1 === elements.length || (1 === groupMarks.length && ModifyElementSource.DragSelect !== groupMarks[groupMarks.length - 1].source)) {\n            this.clear();\n            return true;\n        }\n        const groupIndex = pos;\n        let groupStart = 0, groupEnd = 0;\n        let markToErase = 0;\n        let removeSingleEntry = false;\n        for (let iMark = 0; iMark < groupMarks.length; ++iMark) {\n            if (0 === groupEnd) {\n                if (iMark + 1 === groupMarks.length) {\n                    markToErase = iMark;\n                    removeSingleEntry = (ModifyElementSource.DragSelect === groupMarks[iMark].source);\n                    groupStart = groupMarks[iMark].start;\n                    groupEnd = elements.length;\n                }\n                else if (groupMarks[iMark].start <= groupIndex && groupMarks[iMark + 1].start > groupIndex) {\n                    markToErase = iMark;\n                    removeSingleEntry = (ModifyElementSource.DragSelect === groupMarks[iMark].source);\n                    groupStart = groupMarks[iMark].start;\n                    groupEnd = groupMarks[iMark + 1].start;\n                }\n                continue;\n            }\n            if (removeSingleEntry)\n                groupMarks[iMark].start -= 1; // Only removing single entry, not entire group...\n            else\n                groupMarks[iMark].start -= (groupEnd - groupStart); // Adjust indices...\n        }\n        if (removeSingleEntry) { // Only remove single entry...\n            this.setEntriesHiliteState(false, groupIndex, groupIndex + 1); // make sure removed entry isn't left hilited...\n            elements.splice(groupIndex, 1);\n            if (groupEnd === groupStart + 1)\n                groupMarks.splice(markToErase, 1);\n            return true;\n        }\n        this.setEntriesHiliteState(false, groupStart, groupEnd); // make sure removed entries aren't left hilited...\n        elements.splice(groupStart, groupEnd - groupStart);\n        groupMarks.splice(markToErase, 1);\n        return true;\n    }\n    remove(arg) {\n        if (0 === this.length)\n            return false;\n        if (0 === Id64.sizeOf(arg))\n            return false;\n        let changed = false;\n        for (const elId of Id64.iterable(arg))\n            if (this.removeOne(elId))\n                changed = true; // NOTE: Removes group associated with this element, not just a single entry...\n        return changed;\n    }\n    /** Add elements not currently in the agenda and remove elements currently in the agenda. */\n    invert(arg) {\n        if (0 === this.length)\n            return this.add(arg);\n        if (0 === Id64.sizeOf(arg))\n            return false;\n        const adds = [];\n        const removes = [];\n        for (const id of Id64.iterable(arg)) {\n            if (this.has(id))\n                removes.push(id);\n            else\n                adds.push(id);\n        }\n        if (adds.length === 0 && removes.length === 0)\n            return false;\n        removes.forEach((id) => this.removeOne(id));\n        if (adds.length > 0) {\n            const groupStart = this.length;\n            adds.forEach((id) => this.elements.push(id));\n            this.groupMarks.push({ start: groupStart, source: ModifyElementSource.Unknown });\n            this.setEntriesHiliteState(true, groupStart, this.length); // make sure added entries are hilited (when not also removing)...\n        }\n        return true;\n    }\n}\n/** The ElementSetTool class is a specialization of [[PrimitiveTool]] designed to unify operations on sets of elements.\n * Use to query or modify existing elements as well as to create new elements from existing elements.\n * Basic tool sequence:\n * - Populate [[ElementSetTool.agenda]] with the element ids to query or modify.\n * - Gather any additional input and if requested, enable dynamics to preview result.\n * - Call [[ElementSetTool.processAgenda]] to apply operation to [[ElementSetTool.agenda]].\n * - Call [[ElementSetTool.onProcessComplete]] to restart or exit.\n * Common element sources:\n * - Pre-selected elements from an active [[SelectionSet]].\n * - Clicking in a view to identify elements using [[ElementLocateManager]].\n * - Drag box and crossing line selection.\n * Default behavior:\n * - Identify a single element with left-click.\n * - Immediately apply operation.\n * - Restart.\n * Sub-classes are required to opt-in to additional element sources, dynamics, AccuSnap, additional input, etc.\n * @alpha\n */\nexport class ElementSetTool extends PrimitiveTool {\n    constructor() {\n        super(...arguments);\n        this._useSelectionSet = false;\n        this._processDataButtonUp = false;\n    }\n    /** Get the [[ElementAgenda]] the tool will operate on. */\n    get agenda() {\n        if (undefined === this._agenda)\n            this._agenda = new ElementAgenda(this.iModel);\n        return this._agenda;\n    }\n    /** Convenience method to get current count from [[ElementSetTool.agenda]]. */\n    get currentElementCount() { return undefined !== this._agenda ? this._agenda.count : 0; }\n    /** Minimum required number of elements for tool to be able to complete.\n     * @return number to compare with [[ElementSetTool.currentElementCount]] to determine if more elements remain to be identified.\n     * @note A tool to subtract elements is an example where returning 2 would be necessary.\n     */\n    get requiredElementCount() { return 1; }\n    /** Whether to allow element identification by drag box or crossing line selection.\n     * @return true to allow drag select as an element source when the ctrl key is down.\n     * @note Use ctrl+left drag for box selection. Inside/overlap is based on left/right direction (shift key inverts).\n     * @note Use ctrl+right drag for crossing line selection.\n     */\n    get allowDragSelect() { return false; }\n    /** Support operations on groups/assemblies independent of selection scope.\n     * @return true to add or remove all members of an assembly from [[ElementSetTool.agenda]] when any single member is identified.\n     * @note Applies to [[ElementSetTool.getLocateCandidates]] only.\n     */\n    get allowGroups() { return false; }\n    /** Whether [[ElementSetTool.agenda]] should be populated from an active selection set.\n     * @return true to allow selection sets as an element source.\n     * @note A selection set must have at least [[ElementSetTool.requiredElementCount]] elements to be considered.\n     */\n    get allowSelectionSet() { return false; }\n    /** Whether to clear the active selection set for tools that return false for [[ElementSetTool.allowSelectionSet]].\n     * @return true to clear unsupported selection sets (desired default behavior).\n     * @note It is expected that the selection set be cleared before using [[ElementLocateManager]] to identify elements.\n     * This allows the element hilite to be a visual representation of the [[ElementSetTool.agenda]] contents.\n     */\n    get clearSelectionSet() { return !this.allowSelectionSet; }\n    /** Whether a selection set should be processed immediately upon installation or require a data button to accept.\n     * @return false only for tools without settings or a need for confirmation.\n     * @note A tool to delete elements is an example where returning false could be desirable.\n     */\n    get requireAcceptForSelectionSetOperation() { return true; }\n    /** Whether to begin dynamics for a selection set immediately or wait for a data button.\n     * @return false for tools that can start showing dynamics without any additional input.\n     * @note A tool to rotate elements by an active angle setting is an example where returning false could be desirable.\n     */\n    get requireAcceptForSelectionSetDynamics() { return true; }\n    /** Whether original source of elements being modified was the active selection set.\n     * @return true when [[ElementSetTool.allowSelectionSet]] and active selection set count >= [[ElementSetTool.requiredElementCount]].\n     */\n    get isSelectionSetModify() { return this._useSelectionSet; }\n    /** Whether drag box or crossing line selection is currently active.\n     * @return true when [[ElementSetTool.allowDragSelect]] and corner points are currently being defined.\n     */\n    get isSelectByPoints() { return undefined !== this.dragStartPoint; }\n    /** Whether to continue selection of additional elements by holding the ctrl key down.\n     * @return true to continue the element identification phase beyond [[ElementSetTool.requiredElementCount]] by holding down the ctrl key.\n     */\n    get controlKeyContinuesSelection() { return false; }\n    /** Whether to invert selection of elements identified with the ctrl key held down.\n     * @return true to allow ctrl to deselect already selected elements.\n     */\n    get controlKeyInvertsSelection() { return this.controlKeyContinuesSelection; }\n    /** Whether [[ElementSetTool.setupAndPromptForNextAction]] should call [[AccuSnap.enableSnap]] for current tool phase.\n     * @return true to enable snapping to elements.\n     * @note A tool that just needs to identify elements and doesn't care about location should not enable snapping.\n     */\n    get wantAccuSnap() { return false; }\n    /** Whether to automatically start element dynamics after all required elements have been identified.\n     * @return true if tool will implement [[InteractiveTool.onDynamicFrame]] to show element dynamics.\n     */\n    get wantDynamics() { return false; }\n    /** Whether tool is done identifying elements and is ready to move to the next phase.\n     * @return true when [[ElementSetTool.requiredElementCount]] is not yet satisfied or ctrl key is being used to extend selection.\n     */\n    get wantAdditionalElements() {\n        if (this.isSelectionSetModify)\n            return false;\n        if (this.currentElementCount < this.requiredElementCount)\n            return true;\n        // A defined anchor indicates input collection phase has begun and ctrl should no longer extend selection...\n        return undefined === this.anchorPoint && this.controlKeyContinuesSelection && this.isControlDown;\n    }\n    /** Whether the tool has gathered enough input to call [[ElementSetTool.processAgenda]].\n     * Sub-classes should override to check for additional point input they collected in [[ElementSetTool.wantProcessAgenda]].\n     * @return true if tool does not yet have enough information to complete.\n     * @note When [[ElementSetTool.wantDynamics]] is true an additional point is automatically required to support the dynamic preview.\n     */\n    get wantAdditionalInput() { return (!this.isDynamicsStarted && this.wantDynamics); }\n    /** Whether the tool is ready for [[ElementSetTool.processAgenda]] to be called to complete the tool operation.\n     * Sub-classes should override to collect additional point input before calling super or [[ElementSetTool.wantAdditionalInput]].\n     * @return true if tool has enough information and is ready to complete.\n     */\n    wantProcessAgenda(_ev) { return !this.wantAdditionalInput; }\n    /** Whether tool should operate on an existing selection set or instead prompt user to identity elements.\n     * Unsupported selection sets will be cleared when [[ElementSetTool.clearSelectionSet]] is true.\n    */\n    setPreferredElementSource() {\n        this._useSelectionSet = false;\n        if (!this.iModel.selectionSet.isActive)\n            return;\n        if (this.allowSelectionSet && this.iModel.selectionSet.size >= this.requiredElementCount)\n            this._useSelectionSet = true;\n        else if (this.clearSelectionSet)\n            this.iModel.selectionSet.emptyAll();\n    }\n    /** Get element ids to process from the active selection set.\n     * Sub-classes may override to support selection scopes or apply tool specific filtering.\n     */\n    async getSelectionSetCandidates(ss) {\n        const ids = new Set();\n        ss.elements.forEach((val) => {\n            if (this.isElementIdValid(val, ModifyElementSource.SelectionSet))\n                ids.add(val);\n        });\n        return ids;\n    }\n    /** Populate [[ElementSetTool.agenda]] from a [[SelectionSet]].\n     * @see [[ElementSetTool.getSelectionSetCandidates]] to filter or augment the set of elements.\n     */\n    async buildSelectionSetAgenda(ss) {\n        const candidates = await this.getSelectionSetCandidates(ss);\n        if (Id64.sizeOf(candidates) < this.requiredElementCount || !this.agenda.add(candidates)) {\n            IModelApp.notifications.outputMessage(new NotifyMessageDetails(OutputMessagePriority.Info, CoreTools.translate(\"ElementSet.Error.NoSSElems\")));\n            return false;\n        }\n        this.agenda.setSource(ModifyElementSource.SelectionSet);\n        await this.onAgendaModified();\n        return true;\n    }\n    /** If the supplied element is a member of an assembly, return all member ids. */\n    async getGroupIds(id) {\n        const ids = new Set();\n        ids.add(id);\n        try {\n            const ecsql = `SELECT ECInstanceId as id, Parent.Id as parentId FROM BisCore.GeometricElement WHERE Parent.Id IN (SELECT Parent.Id as parentId FROM BisCore.GeometricElement WHERE parent.Id != 0 AND ECInstanceId IN (${id}))`;\n            for await (const row of this.iModel.createQueryReader(ecsql, undefined, { rowFormat: QueryRowFormat.UseJsPropertyNames })) {\n                ids.add(row.parentId);\n                ids.add(row.id);\n            }\n        }\n        catch { }\n        return ids;\n    }\n    /** Get element id(s) to process from a [[HitDetail]] already accepted by [[ElementSetTool.isElementValidForOperation]].\n     * Sub-classes may override to support selection scopes.\n     */\n    async getLocateCandidates(hit) {\n        if (!this.allowGroups)\n            return hit.sourceId;\n        return this.getGroupIds(hit.sourceId);\n    }\n    /** Populate [[ElementSetTool.agenda]] from a [[HitDetail]].\n     * @see [[ElementSetTool.getLocateCandidates]] to add additional elements.\n     */\n    async buildLocateAgenda(hit) {\n        if (this.agenda.find(hit.sourceId)) {\n            if (this.isControlDown && this.controlKeyInvertsSelection && this.agenda.remove(hit.sourceId)) {\n                await this.onAgendaModified();\n                return true;\n            }\n            return false;\n        }\n        const candidates = await this.getLocateCandidates(hit);\n        if (!this.agenda.add(candidates))\n            return false;\n        this.agenda.setSource(ModifyElementSource.Selected);\n        await this.onAgendaModified();\n        return true;\n    }\n    /** Get element ids to process from drag box or crossing line selection.\n     * Sub-classes may override to support selection scopes or apply tool specific filtering.\n     */\n    async getDragSelectCandidates(vp, origin, corner, method, overlap) {\n        let contents = new Set();\n        // TODO: Include option to use IModelConnection.getGeometryContainment instead of readPixels. No/Yes/2dOnly...\n        const pts = [];\n        pts[0] = new Point2d(Math.floor(origin.x + 0.5), Math.floor(origin.y + 0.5));\n        pts[1] = new Point2d(Math.floor(corner.x + 0.5), Math.floor(corner.y + 0.5));\n        const range = Range2d.createArray(pts);\n        const rect = new ViewRect();\n        rect.initFromRange(range);\n        vp.readPixels(rect, Pixel.Selector.Feature, (pixels) => {\n            if (undefined === pixels)\n                return;\n            const sRange = Range2d.createNull();\n            sRange.extendPoint(Point2d.create(vp.cssPixelsToDevicePixels(range.low.x), vp.cssPixelsToDevicePixels(range.low.y)));\n            sRange.extendPoint(Point2d.create(vp.cssPixelsToDevicePixels(range.high.x), vp.cssPixelsToDevicePixels(range.high.y)));\n            pts[0].x = vp.cssPixelsToDevicePixels(pts[0].x);\n            pts[0].y = vp.cssPixelsToDevicePixels(pts[0].y);\n            pts[1].x = vp.cssPixelsToDevicePixels(pts[1].x);\n            pts[1].y = vp.cssPixelsToDevicePixels(pts[1].y);\n            const testPoint = Point2d.createZero();\n            const getPixelElementId = (pixel) => {\n                if (undefined === pixel.elementId || Id64.isInvalid(pixel.elementId))\n                    return undefined; // no geometry at this location...\n                if (!vp.isPixelSelectable(pixel))\n                    return undefined; // reality model, terrain, etc - not selectable\n                if (!this.isElementIdValid(pixel.elementId, ModifyElementSource.DragSelect))\n                    return undefined;\n                return pixel.elementId;\n            };\n            if (SelectionMethod.Box === method) {\n                const outline = overlap ? undefined : new Set();\n                const offset = sRange.clone();\n                offset.expandInPlace(-2);\n                for (testPoint.x = sRange.low.x; testPoint.x <= sRange.high.x; ++testPoint.x) {\n                    for (testPoint.y = sRange.low.y; testPoint.y <= sRange.high.y; ++testPoint.y) {\n                        const pixel = pixels.getPixel(testPoint.x, testPoint.y);\n                        const elementId = getPixelElementId(pixel);\n                        if (undefined === elementId)\n                            continue;\n                        if (undefined !== outline && !offset.containsPoint(testPoint))\n                            outline.add(elementId.toString());\n                        else\n                            contents.add(elementId.toString());\n                    }\n                }\n                if (undefined !== outline && 0 !== outline.size) {\n                    const inside = new Set();\n                    contents.forEach((id) => {\n                        if (!outline.has(id))\n                            inside.add(id);\n                    });\n                    contents = inside;\n                }\n            }\n            else {\n                const closePoint = Point2d.createZero();\n                for (testPoint.x = sRange.low.x; testPoint.x <= sRange.high.x; ++testPoint.x) {\n                    for (testPoint.y = sRange.low.y; testPoint.y <= sRange.high.y; ++testPoint.y) {\n                        const pixel = pixels.getPixel(testPoint.x, testPoint.y);\n                        const elementId = getPixelElementId(pixel);\n                        if (undefined === elementId)\n                            continue;\n                        const fraction = testPoint.fractionOfProjectionToLine(pts[0], pts[1], 0.0);\n                        pts[0].interpolate(fraction, pts[1], closePoint);\n                        if (closePoint.distance(testPoint) < 1.5)\n                            contents.add(elementId.toString());\n                    }\n                }\n            }\n        }, true);\n        return contents;\n    }\n    /** Populate [[ElementSetTool.agenda]] by drag box or crossing line information.\n     * @see [[ElementSetTool.getDragSelectCandidates]] to filter or augment the set of elements.\n     */\n    async buildDragSelectAgenda(vp, origin, corner, method, overlap) {\n        const candidates = await this.getDragSelectCandidates(vp, origin, corner, method, overlap);\n        if (!this.isControlDown || !this.controlKeyInvertsSelection) {\n            if (!this.agenda.add(candidates))\n                return false;\n        }\n        else {\n            if (!this.agenda.invert(candidates))\n                return false;\n        }\n        if (ModifyElementSource.Unknown === this.agenda.getSource())\n            this.agenda.setSource(ModifyElementSource.DragSelect); // Don't set source if invert only removed entries...\n        await this.onAgendaModified();\n        return true;\n    }\n    /** Quick id validity check. Sub-classes that wish to allow pickable decorations from selection sets can override. */\n    isElementIdValid(id, source) {\n        switch (source) {\n            case ModifyElementSource.Selected:\n                return true; // Locate options already checked prior to calling isElementValidForOperation...\n            case ModifyElementSource.SelectionSet:\n                return (!Id64.isInvalid(id) && !Id64.isTransient(id)); // Locate options are invalid, locate isn't enabled when processing a selection set...\n            case ModifyElementSource.DragSelect:\n                return (!Id64.isInvalid(id) && (IModelApp.locateManager.options.allowDecorations || !Id64.isTransient(id))); // Locate options are valid but have not yet been checked...\n            default:\n                return false;\n        }\n    }\n    /** Sub-classes should override to apply tool specific filtering and to provide an explanation for rejection. */\n    async isElementValidForOperation(hit, _out) {\n        return this.isElementIdValid(hit.sourceId, ModifyElementSource.Selected);\n    }\n    /** Called from [[ElementSetTool.doLocate]] as well as auto-locate to accept or reject elements under the cursor. */\n    async filterHit(hit, out) {\n        // Support deselect using control key and don't show \"not\" cursor over an already selected element...\n        if (undefined !== this._agenda && this._agenda.find(hit.sourceId)) {\n            const status = (this.isControlDown || !this.controlKeyInvertsSelection) ? LocateFilterStatus.Accept : LocateFilterStatus.Reject;\n            if (out && LocateFilterStatus.Reject === status)\n                out.explanation = CoreTools.translate(`ElementSet.Error.AlreadySelected`);\n            return status;\n        }\n        return await this.isElementValidForOperation(hit, out) ? LocateFilterStatus.Accept : LocateFilterStatus.Reject;\n    }\n    /** Identify an element and update the element agenda.\n     * @param newSearch true to locate new elements, false to cycle between elements within locate tolerance from a previous locate.\n     * @return true if [[ElementSetTool.agenda]] was changed.\n     */\n    async doLocate(ev, newSearch) {\n        const hit = await IModelApp.locateManager.doLocate(new LocateResponse(), newSearch, ev.point, ev.viewport, ev.inputSource);\n        if (newSearch)\n            return (undefined !== hit && this.buildLocateAgenda(hit));\n        // If next element is already in agenda (part of a group, etc.) don't re-add group...\n        const addNext = (undefined !== hit && !this.agenda.has(hit.sourceId));\n        this.agenda.popGroup();\n        if (!addNext || !await this.buildLocateAgenda(hit))\n            await this.onAgendaModified(); // only change was popGroup...\n        return true;\n    }\n    /** Whether drag box selection only identifies elements that are wholly inside or also allows those that overlap\n     * the selection rectangle.\n     * @note Inside/overlap is based on left/right direction of corner points (shift key inverts check).\n     */\n    useOverlapSelection(ev) {\n        if (undefined === ev.viewport || undefined === this.dragStartPoint)\n            return false;\n        const pt1 = ev.viewport.worldToView(this.dragStartPoint);\n        const pt2 = ev.viewport.worldToView(ev.point);\n        const overlapMode = (pt1.x > pt2.x);\n        return (ev.isShiftKey ? !overlapMode : overlapMode); // Shift inverts inside/overlap selection...\n    }\n    /** Initiate tool state for start of drag selection. */\n    async selectByPointsStart(ev) {\n        if (BeButton.Data !== ev.button && BeButton.Reset !== ev.button)\n            return false;\n        if (!ev.isControlKey || !this.allowDragSelect || !this.wantAdditionalElements)\n            return false;\n        this.dragStartPoint = ev.point.clone();\n        this.setupAndPromptForNextAction();\n        return true;\n    }\n    /** Finish drag selection and update [[ElementSetTool.agenda]] with any elements that may have been identified. */\n    async selectByPointsEnd(ev) {\n        if (undefined === this.dragStartPoint)\n            return false;\n        const vp = ev.viewport;\n        if (vp === undefined) {\n            this.dragStartPoint = undefined;\n            this.setupAndPromptForNextAction();\n            return false;\n        }\n        const origin = vp.worldToView(this.dragStartPoint);\n        const corner = vp.worldToView(ev.point);\n        if (BeButton.Reset === ev.button)\n            await this.buildDragSelectAgenda(vp, origin, corner, SelectionMethod.Line, true);\n        else\n            await this.buildDragSelectAgenda(vp, origin, corner, SelectionMethod.Box, this.useOverlapSelection(ev));\n        this.dragStartPoint = undefined;\n        this.setupAndPromptForNextAction();\n        vp.invalidateDecorations();\n        return true;\n    }\n    /** Display drag box and crossing line selection graphics. */\n    selectByPointsDecorate(context) {\n        if (undefined === this.dragStartPoint)\n            return;\n        const ev = new BeButtonEvent();\n        IModelApp.toolAdmin.fillEventFromCursorLocation(ev);\n        if (undefined === ev.viewport)\n            return;\n        const vp = context.viewport;\n        const bestContrastIsBlack = (ColorDef.black === vp.getContrastToBackgroundColor());\n        const crossingLine = (BeButton.Reset === ev.button);\n        const overlapSelection = (crossingLine || this.useOverlapSelection(ev));\n        const position = vp.worldToView(this.dragStartPoint);\n        position.x = Math.floor(position.x) + 0.5;\n        position.y = Math.floor(position.y) + 0.5;\n        const position2 = vp.worldToView(ev.point);\n        position2.x = Math.floor(position2.x) + 0.5;\n        position2.y = Math.floor(position2.y) + 0.5;\n        const offset = position2.minus(position);\n        const drawDecoration = (ctx) => {\n            ctx.strokeStyle = bestContrastIsBlack ? \"black\" : \"white\";\n            ctx.lineWidth = 1;\n            if (overlapSelection)\n                ctx.setLineDash([5, 5]);\n            if (crossingLine) {\n                ctx.beginPath();\n                ctx.moveTo(0, 0);\n                ctx.lineTo(offset.x, offset.y);\n                ctx.stroke();\n            }\n            else {\n                ctx.strokeRect(0, 0, offset.x, offset.y);\n                ctx.fillStyle = bestContrastIsBlack ? \"rgba(0,0,0,.06)\" : \"rgba(255,255,255,.06)\";\n                ctx.fillRect(0, 0, offset.x, offset.y);\n            }\n        };\n        context.addCanvasDecoration({ position, drawDecoration });\n    }\n    /** Show graphics for when drag selection is active. */\n    decorate(context) { this.selectByPointsDecorate(context); }\n    /** Make sure drag selection graphics are updated when mouse moves. */\n    async onMouseMotion(ev) {\n        if (undefined !== ev.viewport && this.isSelectByPoints)\n            ev.viewport.invalidateDecorations();\n    }\n    /** Support initiating drag selection on mouse start drag event when [[ElementSetTool.allowDragSelect]] is true. */\n    async onMouseStartDrag(ev) {\n        if (await this.selectByPointsStart(ev))\n            return EventHandled.Yes;\n        return super.onMouseStartDrag(ev);\n    }\n    /** Support completing active drag selection on mouse end drag event and update [[ElementSetTool.agenda]]. */\n    async onMouseEndDrag(ev) {\n        if (await this.selectByPointsEnd(ev))\n            return EventHandled.Yes;\n        return super.onMouseEndDrag(ev);\n    }\n    /** Update prompts, cursor, graphics, etc. as appropriate on ctrl and shift key transitions. */\n    async onModifierKeyTransition(_wentDown, modifier, _event) {\n        if (this.isSelectionSetModify)\n            return EventHandled.No;\n        if (this.isSelectByPoints)\n            return (BeModifierKeys.Shift === modifier ? EventHandled.Yes : EventHandled.No);\n        if (BeModifierKeys.Control !== modifier || undefined !== this.anchorPoint || !this.controlKeyContinuesSelection)\n            return EventHandled.No;\n        if (this.currentElementCount < this.requiredElementCount && !this.wantAccuSnap)\n            return EventHandled.No; // Can only early return if AccuSnap doesn't need to be disabled for ctrl selection...\n        this.setupAndPromptForNextAction(); // Enable/disable auto-locate, AccuSnap, update prompts...\n        return EventHandled.Yes;\n    }\n    /** Allow reset to cycle between elements identified for overlapping the locate circle.\n     * Advances to next pre-located hit from [[AccuSnap.aSnapHits]] or changes last accepted hit to next hit from [[ElementLocateManger.hitList]].\n     * @returns EventHandled.Yes if onReinitialize was called to restart or exit tool.\n     */\n    async chooseNextHit(ev) {\n        if (this.isSelectionSetModify) {\n            await this.onReinitialize();\n            return EventHandled.Yes;\n        }\n        if (0 !== this.currentElementCount) {\n            let autoLocateChooseNext = false;\n            if (this.wantAdditionalElements) {\n                const lastHit = IModelApp.locateManager.currHit;\n                const autoHit = IModelApp.accuSnap.currHit;\n                // Choose next using auto-locate or normal locate?\n                if (undefined !== autoHit && (undefined === lastHit || !autoHit.isSameHit(lastHit)))\n                    autoLocateChooseNext = true;\n            }\n            if (!autoLocateChooseNext) {\n                await this.doLocate(ev, false);\n                if (this.agenda.isEmpty) {\n                    await this.onReinitialize();\n                    return EventHandled.Yes;\n                }\n                this.setupAndPromptForNextAction();\n                return EventHandled.No;\n            }\n        }\n        await IModelApp.accuSnap.resetButton();\n        return EventHandled.No;\n    }\n    /** Orchestrates updating the internal state of the tool on a reset button event.\n     * @returns EventHandled.Yes if onReinitialize was called to restart or exit tool.\n     */\n    async processResetButton(ev) {\n        if (ev.isDown)\n            return EventHandled.No;\n        return this.chooseNextHit(ev);\n    }\n    async onResetButtonUp(ev) {\n        return this.processResetButton(ev);\n    }\n    async onResetButtonDown(ev) {\n        return this.processResetButton(ev);\n    }\n    /** Collect element input until tool has a sufficient number to complete. */\n    async gatherElements(ev) {\n        if (this.isSelectionSetModify) {\n            if (this.agenda.isEmpty && !await this.buildSelectionSetAgenda(this.iModel.selectionSet)) {\n                await this.onReinitialize();\n                return EventHandled.Yes;\n            }\n        }\n        if (this.wantAdditionalElements) {\n            if (ev.isDown && ev.isControlKey && this.allowDragSelect) {\n                this._processDataButtonUp = true;\n                return EventHandled.No; // Defer locate to up event so that box select can be initiated while over an element...\n            }\n            if (!await this.doLocate(ev, true))\n                return EventHandled.No;\n            if (this.wantAdditionalElements) {\n                this.setupAndPromptForNextAction();\n                return EventHandled.No; // Continue identifying elements...\n            }\n        }\n        return undefined;\n    }\n    /** Collect point input until tool has a sufficient number to complete. */\n    async gatherInput(ev) {\n        if (undefined === this.anchorPoint) {\n            this.anchorPoint = ev.point.clone();\n            const hints = new AccuDrawHintBuilder();\n            hints.setOriginAlways = true;\n            hints.setOrigin(this.anchorPoint);\n            hints.sendHints(false); // Default activation on start of dynamics...\n        }\n        if (!this.wantProcessAgenda(ev)) {\n            if (this.wantDynamics)\n                await this.initAgendaDynamics();\n            this.setupAndPromptForNextAction();\n            return EventHandled.No;\n        }\n        return undefined;\n    }\n    /** Orchestrates advancing the internal state of the tool on a data button event.\n     * - Collect elements: Add to the element agenda until no additional elements are requested.\n     * - Gather input: Initiates element dynamics and accepts additional points as required.\n     * - Complete operation: Process agenda entries, restart or exit tool.\n     * @returns EventHandled.Yes if onReinitialize was called to restart or exit tool.\n     */\n    async processDataButton(ev) {\n        if (!ev.isDown && !this._processDataButtonUp)\n            return EventHandled.No;\n        this._processDataButtonUp = false;\n        const elementStatus = await this.gatherElements(ev);\n        if (undefined !== elementStatus)\n            return elementStatus;\n        const inputStatus = await this.gatherInput(ev);\n        if (undefined !== inputStatus)\n            return inputStatus;\n        await this.processAgenda(ev);\n        await this.onProcessComplete();\n        return EventHandled.Yes;\n    }\n    async onDataButtonUp(ev) {\n        return this.processDataButton(ev);\n    }\n    async onDataButtonDown(ev) {\n        return this.processDataButton(ev);\n    }\n    async initAgendaDynamics() {\n        if (this.isDynamicsStarted)\n            return false;\n        this.beginDynamics();\n        return true;\n    }\n    /** Sub-classes can override to be notified of [[ElementSetTool.agenda]] changes by other methods.\n     * @note Tools should not modify [[ElementSetTool.agenda]] in this method, it should merely serve as a convenient place\n     * to update information, such as element graphics once dynamics has started, ex. [[ElementSetTool.chooseNextHit]].\n    */\n    async onAgendaModified() { }\n    /** Sub-classes can override to continue with current [[ElementSetTool.agenda]] or restart after processing has completed. */\n    async onProcessComplete() { return this.onReinitialize(); }\n    /** Sub-classes that return false for [[ElementSetTool.requireAcceptForSelectionSetOperation]] should override to apply the tool operation to [[ElementSetTool.agenda]]. */\n    async processAgendaImmediate() { }\n    /** Sub-classes that require and use the accept point should override to apply the tool operation to [[ElementSetTool.agenda]].\n     * @note Not called for [[ElementSetTool.isSelectionSetModify]] when [[ElementSetTool.requireAcceptForSelectionSetOperation]] is false.\n     */\n    async processAgenda(_ev) { return this.processAgendaImmediate(); }\n    /** Support either [[ElementSetTool.requireAcceptForSelectionSetOperation]] or [[ElementSetTool.requireAcceptForSelectionSetDynamics]] returning false. */\n    async doProcessSelectionSetImmediate() {\n        const buildImmediate = (!this.requireAcceptForSelectionSetOperation || (this.wantDynamics && !this.requireAcceptForSelectionSetDynamics));\n        if (!buildImmediate)\n            return;\n        if (!await this.buildSelectionSetAgenda(this.iModel.selectionSet))\n            return this.onReinitialize();\n        if (!this.requireAcceptForSelectionSetOperation) {\n            await this.processAgendaImmediate();\n            await this.onProcessComplete();\n        }\n        else {\n            await this.initAgendaDynamics();\n        }\n    }\n    /** Setup initial element state, prompts, check [[SelectionSet]], etc. */\n    async onPostInstall() {\n        await super.onPostInstall();\n        this.setPreferredElementSource();\n        this.setupAndPromptForNextAction();\n        if (this.isSelectionSetModify)\n            await this.doProcessSelectionSetImmediate();\n    }\n    /** Make sure elements from [[ElementSetTool.agenda]] that aren't also from [[SelectionSet]] aren't left hilited. */\n    async onCleanup() {\n        await super.onCleanup();\n        if (undefined !== this._agenda)\n            this._agenda.clear();\n    }\n    /** Exit and start default tool when [[ElementSetTool.isSelectionSetModify]] is true to allow [[SelectionSet]] to be modified,\n     * or call [[PrimitiveTool.onRestartTool]] to install a new tool instance.\n     */\n    async onReinitialize() {\n        if (this.isSelectionSetModify)\n            return this.exitTool();\n        return this.onRestartTool();\n    }\n    /** Restore tool assistance after no longer being suspended by either a [[ViewTool]] or [[InputCollector]]. */\n    async onUnsuspend() {\n        this.provideToolAssistance();\n    }\n    get shouldEnableLocate() { return this.isSelectByPoints ? false : this.wantAdditionalElements; }\n    get shouldEnableSnap() { return this.isSelectByPoints ? false : (this.wantAccuSnap && (!this.isControlDown || !this.controlKeyContinuesSelection || !this.wantAdditionalElements)); }\n    /** Setup auto-locate, AccuSnap, AccuDraw, and supply tool assistance. */\n    setupAndPromptForNextAction() {\n        this.initLocateElements(this.shouldEnableLocate, this.shouldEnableSnap);\n        this.provideToolAssistance();\n    }\n    /** Sub-classes should override to provide tool specific instructions. */\n    provideToolAssistance(mainInstrText, additionalInstr) {\n        let mainMsg;\n        let leftMsg;\n        let rightMsg;\n        let addDragInstr = false;\n        if (this.isSelectionSetModify) {\n            if (this.wantAdditionalInput) {\n                mainMsg = \"ElementSet.Prompts.IdentifyPoint\";\n                leftMsg = \"ElementSet.Inputs.AcceptPoint\";\n                rightMsg = \"ElementSet.Inputs.Exit\";\n            }\n            else if (0 === this.currentElementCount) {\n                mainMsg = \"ElementSet.Prompts.ConfirmSelection\";\n                leftMsg = \"ElementSet.Inputs.AcceptSelection\";\n                rightMsg = \"ElementSet.Inputs.RejectSelection\";\n            }\n            else {\n                mainMsg = \"ElementSet.Inputs.Complete\";\n                leftMsg = \"ElementSet.Inputs.Accept\";\n                rightMsg = \"ElementSet.Inputs.Exit\";\n            }\n        }\n        else {\n            if (this.isSelectByPoints) {\n                mainMsg = \"ElementSet.Prompts.OppositeCorner\";\n                leftMsg = \"ElementSet.Inputs.BoxCorners\";\n                rightMsg = \"ElementSet.Inputs.CrossingLine\";\n            }\n            else if (this.wantAdditionalElements) {\n                mainMsg = \"ElementSet.Prompts.IdentifyElement\";\n                leftMsg = \"ElementSet.Inputs.AcceptElement\";\n                rightMsg = \"ElementSet.Inputs.Cancel\";\n                addDragInstr = this.allowDragSelect;\n            }\n            else if (this.wantAdditionalInput) {\n                mainMsg = \"ElementSet.Prompts.IdentifyPoint\";\n                leftMsg = \"ElementSet.Inputs.AcceptPoint\";\n                rightMsg = \"ElementSet.Inputs.Cancel\";\n            }\n            else {\n                mainMsg = \"ElementSet.Inputs.Complete\";\n                leftMsg = \"ElementSet.Inputs.Accept\";\n                rightMsg = \"ElementSet.Inputs.Restart\";\n            }\n        }\n        const mouseInstructions = [];\n        const touchInstructions = [];\n        if (!ToolAssistance.createTouchCursorInstructions(touchInstructions))\n            touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.OneTouchTap, CoreTools.translate(leftMsg), false, ToolAssistanceInputMethod.Touch));\n        mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.LeftClick, CoreTools.translate(leftMsg), false, ToolAssistanceInputMethod.Mouse));\n        touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.TwoTouchTap, CoreTools.translate(rightMsg), false, ToolAssistanceInputMethod.Touch));\n        mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.RightClick, CoreTools.translate(rightMsg), false, ToolAssistanceInputMethod.Mouse));\n        if (addDragInstr) {\n            mouseInstructions.push(ToolAssistance.createModifierKeyInstruction(ToolAssistance.ctrlKey, ToolAssistanceImage.LeftClickDrag, CoreTools.translate(\"ElementSet.Inputs.BoxCorners\"), false, ToolAssistanceInputMethod.Mouse));\n            mouseInstructions.push(ToolAssistance.createModifierKeyInstruction(ToolAssistance.ctrlKey, ToolAssistanceImage.RightClickDrag, CoreTools.translate(\"ElementSet.Inputs.CrossingLine\"), false, ToolAssistanceInputMethod.Mouse));\n            mouseInstructions.push(ToolAssistance.createModifierKeyInstruction(ToolAssistance.shiftKey, ToolAssistanceImage.LeftClickDrag, CoreTools.translate(\"ElementSet.Inputs.OverlapSelection\"), false, ToolAssistanceInputMethod.Mouse));\n        }\n        if (undefined !== additionalInstr) {\n            for (const instr of additionalInstr) {\n                if (ToolAssistanceInputMethod.Touch === instr.inputMethod)\n                    touchInstructions.push(instr);\n                else\n                    mouseInstructions.push(instr);\n            }\n        }\n        const sections = [];\n        sections.push(ToolAssistance.createSection(mouseInstructions, ToolAssistance.inputsLabel));\n        sections.push(ToolAssistance.createSection(touchInstructions, ToolAssistance.inputsLabel));\n        const mainInstruction = ToolAssistance.createInstruction(this.iconSpec, undefined !== mainInstrText ? mainInstrText : CoreTools.translate(mainMsg));\n        const instructions = ToolAssistance.createInstructions(mainInstruction, sections);\n        IModelApp.notifications.setToolAssistance(instructions);\n    }\n}\n//# sourceMappingURL=ElementSetTool.js.map",
      "start": 1693508119724,
      "end": 1693508119987,
      "sourcemaps": null
    }
  ]
}
