{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/solid/TorusPipe.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Solid\n */\nimport { Arc3d } from \"../curve/Arc3d\";\nimport { Loop } from \"../curve/Loop\";\nimport { Path } from \"../curve/Path\";\nimport { Geometry } from \"../Geometry\";\nimport { Angle } from \"../geometry3d/Angle\";\nimport { AngleSweep } from \"../geometry3d/AngleSweep\";\nimport { Plane3dByOriginAndVectors } from \"../geometry3d/Plane3dByOriginAndVectors\";\nimport { Vector2d } from \"../geometry3d/Point2dVector2d\";\nimport { Transform } from \"../geometry3d/Transform\";\nimport { SolidPrimitive } from \"./SolidPrimitive\";\n/**\n * A torus pipe is a partial torus (donut).  In a local coordinate system\n * * The z axis passes through the hole.\n * * The \"major hoop\" arc has\n *   * vectorTheta0 = (radiusA, 0, 0)\n *   * vectorTheta90 = (0, radiusA, 0)\n *   * The major arc point at angle theta is `C(theta) = vectorTheta0 * cos(theta) + vectorTheta90 * sin(theta)\n * * The minor hoop at theta various with phi \"around the minor hoop\"\n *    * (x,y,z) = C(theta) + (radiusB * cos(theta), radiusB * sin(theta), 0) * cos(phi) + (0, 0, radiusB) * sin(phi)\n * * The stored form of the torus pipe is oriented for positive volume:\n *   * Both radii are positive, with radiusA >= radiusB > 0\n *   * The sweep is positive\n *   * The coordinate system has positive determinant.\n * * For uv parameterization,\n *   * u is around the minor hoop, with (0..1) mapping to phi of (0 degrees ..360 degrees)\n *   * v is along the major hoop with (0..1) mapping to theta of (0 .. sweep)\n *   * a constant v section is a full circle\n *   * a constant u section is an arc with sweep angle matching the torusPipe sweep angle.\n * @public\n */\nexport class TorusPipe extends SolidPrimitive {\n    // constructor captures the pointers!\n    constructor(map, radiusA, radiusB, sweep, capped) {\n        super(capped);\n        /** String name for schema properties */\n        this.solidPrimitiveType = \"torusPipe\";\n        this._localToWorld = map;\n        this._radiusA = radiusA;\n        this._radiusB = radiusB;\n        this._sweep = sweep;\n        this._isReversed = false;\n    }\n    /** return a copy of the TorusPipe */\n    clone() {\n        const result = new TorusPipe(this._localToWorld.clone(), this._radiusA, this._radiusB, this._sweep.clone(), this.capped);\n        result._isReversed = this._isReversed;\n        return result;\n    }\n    /** Apply `transform` to the local coordinate system. */\n    tryTransformInPlace(transform) {\n        if (transform.matrix.isSingular())\n            return false;\n        transform.multiplyTransformTransform(this._localToWorld, this._localToWorld);\n        return true;\n    }\n    /** Clone this TorusPipe and transform the clone */\n    cloneTransformed(transform) {\n        const result = this.clone();\n        if (!result.tryTransformInPlace(transform))\n            return undefined;\n        return result;\n    }\n    /** Create a new `TorusPipe`\n     * @param frame local to world transformation. For best results, the matrix part should be a pure rotation.\n     * @param majorRadius major hoop radius\n     * @param minorRadius minor hoop radius\n     * @param sweep sweep angle for major circle, with positive sweep from x axis towards y axis.\n     * @param capped true for circular caps\n     */\n    static createInFrame(frame, majorRadius, minorRadius, sweep, capped) {\n        // force near-zero radii to true zero\n        majorRadius = Math.abs(Geometry.correctSmallMetricDistance(majorRadius));\n        minorRadius = Math.abs(Geometry.correctSmallMetricDistance(minorRadius));\n        if (majorRadius < minorRadius)\n            return undefined;\n        if (majorRadius === 0.0)\n            return undefined;\n        if (minorRadius === 0.0)\n            return undefined;\n        if (sweep.isAlmostZero)\n            return undefined;\n        // remove mirror and negative sweep\n        let yScale = 1.0;\n        let zScale = 1.0;\n        let isReversed = false;\n        if (frame.matrix.determinant() < 0.0)\n            zScale *= -1.0;\n        const sweep1 = sweep.clone();\n        if (sweep.radians < 0.0) {\n            sweep1.setRadians(-sweep.radians);\n            zScale *= -1.0;\n            yScale *= -1.0;\n            isReversed = true;\n        }\n        const frame1 = frame.clone();\n        frame1.matrix.scaleColumnsInPlace(1, yScale, zScale);\n        const result = new TorusPipe(frame1, majorRadius, minorRadius, sweep1, capped);\n        result._isReversed = isReversed;\n        return result;\n    }\n    /** Create a TorusPipe from the typical parameters of the Dgn file */\n    static createDgnTorusPipe(center, vectorX, vectorY, majorRadius, minorRadius, sweep, capped) {\n        const vectorZ = vectorX.unitCrossProductWithDefault(vectorY, 0, 0, 1);\n        const frame = Transform.createOriginAndMatrixColumns(center, vectorX, vectorY, vectorZ);\n        return TorusPipe.createInFrame(frame, majorRadius, minorRadius, sweep, capped);\n    }\n    /** Create a TorusPipe from its primary arc and minor radius */\n    static createAlongArc(arc, minorRadius, capped) {\n        if (!Angle.isAlmostEqualRadiansAllowPeriodShift(0.0, arc.sweep.startRadians))\n            arc = arc.cloneInRotatedBasis(arc.sweep.startAngle);\n        const sweepRadians = arc.sweep.sweepRadians;\n        const data = arc.toScaledMatrix3d();\n        const frame = Transform.createOriginAndMatrix(data.center, data.axes);\n        return TorusPipe.createInFrame(frame, data.r0, minorRadius, Angle.createRadians(sweepRadians), capped);\n    }\n    /** Return a coordinate frame (right handed, unit axes)\n     * * origin at center of major circle\n     * * major circle in plane of first two columns\n     * * last column perpendicular to first two\n     */\n    getConstructiveFrame() {\n        return this._localToWorld.cloneRigid();\n    }\n    /** Return the center of the torus pipe (inside the donut hole) */\n    cloneCenter() { return this._localToWorld.getOrigin(); }\n    /** return unit vector along the x axis (in the major hoop plane) */\n    cloneVectorX() {\n        const xAxis = this._localToWorld.matrix.columnX();\n        return xAxis.normalizeWithDefault(1, 0, 0, xAxis);\n    }\n    /** return unit vector along the y axis (in the major hoop plane) */\n    cloneVectorY() {\n        const yAxis = this._localToWorld.matrix.columnY();\n        return yAxis.normalizeWithDefault(0, 1, 0, yAxis);\n    }\n    /** return unit vector along the z axis */\n    cloneVectorZ() {\n        const zAxis = this._localToWorld.matrix.columnZ();\n        return zAxis.normalizeWithDefault(0, 0, 1, zAxis);\n    }\n    /** get the major hoop radius (`radiusA`) in world coordinates */\n    getMajorRadius() { return this._radiusA * this._localToWorld.matrix.columnXMagnitude(); }\n    /** get the minor hoop radius (`radiusB`) in world coordinates */\n    getMinorRadius() { return this._radiusB * this._localToWorld.matrix.columnZMagnitude(); }\n    /** get the sweep angle along the major circle. */\n    getSweepAngle() { return this._sweep.clone(); }\n    /** Ask if this TorusPipe is labeled as reversed */\n    getIsReversed() { return this._isReversed; }\n    /** Return the sweep angle as a fraction of full 360 degrees (2PI radians) */\n    getThetaFraction() { return this._sweep.radians / (Math.PI * 2.0); }\n    /** Return a (clone of) the TorusPipe's local to world transformation. */\n    cloneLocalToWorld() { return this._localToWorld.clone(); }\n    /** ask if `other` is an instance of `TorusPipe` */\n    isSameGeometryClass(other) { return other instanceof TorusPipe; }\n    /** test if `this` and `other` have nearly equal geometry */\n    isAlmostEqual(other) {\n        if (other instanceof TorusPipe) {\n            if ((!this._sweep.isFullCircle) && this.capped !== other.capped)\n                return false;\n            // Compare getter output so that we can equate TorusPipes created/transformed in equivalent ways.\n            // In particular, the column vectors contribute their scale to the radii, so we ignore their length.\n            if (!this.cloneCenter().isAlmostEqual(other.cloneCenter()))\n                return false;\n            if (!this.cloneVectorX().isAlmostEqual(other.cloneVectorX()))\n                return false;\n            if (!this.cloneVectorY().isAlmostEqual(other.cloneVectorY()))\n                return false;\n            if (!this.cloneVectorZ().isAlmostEqual(other.cloneVectorZ()))\n                return false;\n            if (!Geometry.isSameCoordinate(this.getMinorRadius(), other.getMinorRadius()))\n                return false;\n            if (!Geometry.isSameCoordinate(this.getMajorRadius(), other.getMajorRadius()))\n                return false;\n            if (!this.getSweepAngle().isAlmostEqualNoPeriodShift(other.getSweepAngle()))\n                return false;\n            // ignore _isReversed; it doesn't affect geometry\n            return true;\n        }\n        return false;\n    }\n    /** Return the angle (in radians) for given fractional position around the major hoop.\n     */\n    vFractionToRadians(v) { return this._sweep.radians * v; }\n    /** Second step of double dispatch:  call `handler.handleTorusPipe(this)` */\n    dispatchToGeometryHandler(handler) {\n        return handler.handleTorusPipe(this);\n    }\n    /**\n     * Return the Arc3d section at vFraction.  For the TorusPipe, this is a minor circle.\n     * @param vFraction fractional position along the sweep direction\n     */\n    constantVSection(v) {\n        const thetaRadians = this.vFractionToRadians(v);\n        const c0 = Math.cos(thetaRadians);\n        const s0 = Math.sin(thetaRadians);\n        const majorRadius = this._radiusA;\n        const minorRadius = this._radiusB;\n        const center = this._localToWorld.multiplyXYZ(majorRadius * c0, majorRadius * s0, 0);\n        const vector0 = this._localToWorld.multiplyVectorXYZ(minorRadius * c0, minorRadius * s0, 0);\n        const vector90 = this._localToWorld.multiplyVectorXYZ(0, 0, minorRadius);\n        return Loop.create(Arc3d.create(center, vector0, vector90));\n    }\n    /** Return an arc at constant u, and arc sweep matching this TorusPipe sweep. */\n    constantUSection(uFraction) {\n        const theta1Radians = this._sweep.radians;\n        const phiRadians = uFraction * 2 * Math.PI;\n        const majorRadius = this._radiusA;\n        const minorRadius = this._radiusB;\n        const transform = this._localToWorld;\n        const axes = transform.matrix;\n        const center = this._localToWorld.multiplyXYZ(0, 0, minorRadius * Math.sin(phiRadians));\n        const rxy = majorRadius + minorRadius * Math.cos(phiRadians);\n        const vector0 = axes.multiplyXYZ(rxy, 0, 0);\n        const vector90 = axes.multiplyXYZ(0, rxy, 0);\n        return Path.create(Arc3d.create(center, vector0, vector90, AngleSweep.createStartEndRadians(0.0, theta1Radians)));\n    }\n    /** extend `rangeToExtend` to include this `TorusPipe` */\n    extendRange(rangeToExtend, transform) {\n        const theta1Radians = this._sweep.radians;\n        const majorRadius = this._radiusA;\n        const minorRadius = this._radiusB;\n        const transform0 = this._localToWorld;\n        const numThetaSample = Math.ceil(theta1Radians / (Math.PI / 16.0));\n        const numHalfPhiSample = 16;\n        let phi0 = 0;\n        let dPhi = 0;\n        let numPhiSample = 0;\n        let theta = 0;\n        let cosTheta = 0;\n        let sinTheta = 0;\n        let rxy = 0;\n        let phi = 0;\n        let j = 0;\n        const dTheta = theta1Radians / numThetaSample;\n        for (let i = 0; i <= numThetaSample; i++) {\n            theta = i * dTheta;\n            cosTheta = Math.cos(theta);\n            sinTheta = Math.sin(theta);\n            // At the ends, do the entire phi circle.\n            // Otherwise only do the outer half\n            if (i === 0 || i === numThetaSample) {\n                phi0 = -Math.PI;\n                dPhi = 2.0 * Math.PI / numHalfPhiSample;\n                numPhiSample = numHalfPhiSample;\n            }\n            else {\n                phi0 = -0.5 * Math.PI;\n                dPhi = Math.PI / numHalfPhiSample;\n                numPhiSample = 2 * numHalfPhiSample - 1;\n            }\n            if (transform) {\n                for (j = 0; j <= numPhiSample; j++) {\n                    phi = phi0 + j * dPhi;\n                    rxy = majorRadius + minorRadius * Math.cos(phi);\n                    rangeToExtend.extendTransformTransformedXYZ(transform, transform0, cosTheta * rxy, sinTheta * rxy, Math.sin(phi) * minorRadius);\n                }\n            }\n            else {\n                for (j = 0; j <= numPhiSample; j++) {\n                    phi = phi0 + j * dPhi;\n                    rxy = majorRadius + minorRadius * Math.cos(phi);\n                    rangeToExtend.extendTransformedXYZ(transform0, cosTheta * rxy, sinTheta * rxy, Math.sin(phi) * minorRadius);\n                }\n            }\n        }\n    }\n    /** Evaluate as a uv surface\n     * @param u fractional position in minor (phi)\n     * @param v fractional position on major (theta) arc\n     */\n    uvFractionToPoint(u, v, result) {\n        const thetaRadians = v * this._sweep.radians;\n        const phiRadians = u * Math.PI * 2.0;\n        const cosTheta = Math.cos(thetaRadians);\n        const sinTheta = Math.sin(thetaRadians);\n        const majorRadius = this._radiusA;\n        const minorRadius = this._radiusB;\n        const rxy = majorRadius + Math.cos(phiRadians) * minorRadius;\n        return this._localToWorld.multiplyXYZ(rxy * cosTheta, rxy * sinTheta, minorRadius * Math.sin(phiRadians), result);\n    }\n    /** Evaluate as a uv surface, returning point and two vectors.\n     * @param u fractional position in minor (phi)\n     * @param v fractional position on major (theta) arc\n     */\n    uvFractionToPointAndTangents(u, v, result) {\n        const thetaRadians = v * this._sweep.radians;\n        const phiRadians = u * Math.PI * 2.0;\n        const fTheta = this._sweep.radians;\n        const fPhi = Math.PI * 2.0;\n        const cosTheta = Math.cos(thetaRadians);\n        const sinTheta = Math.sin(thetaRadians);\n        const sinPhi = Math.sin(phiRadians);\n        const cosPhi = Math.cos(phiRadians);\n        const majorRadius = this._radiusA;\n        const minorRadius = this._radiusB;\n        const rxy = majorRadius + Math.cos(phiRadians) * minorRadius;\n        const rSinPhi = minorRadius * sinPhi;\n        const rCosPhi = minorRadius * cosPhi; // appears only as derivative of rSinPhi.\n        return Plane3dByOriginAndVectors.createOriginAndVectors(this._localToWorld.multiplyXYZ(cosTheta * rxy, sinTheta * rxy, rSinPhi), this._localToWorld.multiplyVectorXYZ(-cosTheta * rSinPhi * fPhi, -sinTheta * rSinPhi * fPhi, rCosPhi * fPhi), this._localToWorld.multiplyVectorXYZ(-rxy * sinTheta * fTheta, rxy * cosTheta * fTheta, 0), result);\n    }\n    /**\n     * Directional distance query\n     * * u direction is around the (full) minor hoop\n     * * v direction is around the outer radius, sum of (absolute values of) major and minor radii.\n     */\n    maxIsoParametricDistance() {\n        const a = Math.abs(this.getMajorRadius());\n        const b = Math.abs(this.getMinorRadius());\n        return Vector2d.create(b * Math.PI * 2.0, (a + b) * this._sweep.radians);\n    }\n    /**\n     * @return true if this is a closed volume.\n     */\n    get isClosedVolume() {\n        return this.capped || this._sweep.isFullCircle;\n    }\n}\n//# sourceMappingURL=TorusPipe.js.map",
      "start": 1693508122955,
      "end": 1693508123087,
      "sourcemaps": null
    }
  ]
}
