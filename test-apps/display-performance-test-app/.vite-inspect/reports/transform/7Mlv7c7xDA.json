{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/orbitgt/lib/esm/spatial/ecrs/projection/ObliqueStereographic.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module OrbitGT\n */\nimport { OperationMethod } from \"../OperationMethod\";\n/**\n * Class ObliqueStereographic defines an Oblique Stereographic projection.\n *\n * The 'source' CRS is the geodetic CRS.\n * The 'target' CRS is the projected CRS.\n *\n * Based on the following document:\n *\n * Coordinate Conversions and Transformations including Formulas\n * Guidance Note Number 7, part 2\n * Revised August 2006\n * Available at: http://www.epsg.org/\n *\n * Formulas: see 1.4.7.1 'Oblique and Equatorial Stereographic cases'\n *\n * @version 1.0 December 2006\n */\n/** @internal */\nclass ObliqueStereographic extends OperationMethod {\n    /**\n       * Create a new projection.\n       * @param parameters the values of the parameters.\n       */\n    constructor(parameters) {\n        super(ObliqueStereographic.METHOD_CODE, \"Oblique Stereographic\", parameters);\n        /* Store the parameters */\n        this._lat0 = (parameters != null) ? parameters.getValue(8801) : 0.0;\n        this._lon0 = (parameters != null) ? parameters.getValue(8802) : 0.0;\n        this._k0 = (parameters != null) ? parameters.getValue(8805) : 0.0;\n        this._fe = (parameters != null) ? parameters.getValue(8806) : 0.0;\n        this._fn = (parameters != null) ? parameters.getValue(8807) : 0.0;\n    }\n    /**\n       * Create a new projection.\n       * @param lat0 latitude of natural origin (radians).\n       * @param lon0 longitude of natural origin (radians).\n       * @param k0 scale factor at natural origin.\n       * @param fe false easting.\n       * @param fn false northing.\n       */\n    static create(lat0, lon0, k0, fe, fn) {\n        const projection = new ObliqueStereographic(null);\n        projection._lat0 = lat0;\n        projection._lon0 = lon0;\n        projection._k0 = k0;\n        projection._fe = fe;\n        projection._fn = fn;\n        return projection;\n    }\n    /**\n       * Get the power of a number.\n       */\n    static pow(n, e) {\n        return Math.exp(e * Math.log(n));\n    }\n    /**\n       * Calculate sinus.\n       */\n    static sin(a) {\n        return Math.sin(a);\n    }\n    /**\n       * Calculate cosinus.\n       */\n    static cos(a) {\n        return Math.cos(a);\n    }\n    /**\n       * Calculate tangent.\n       */\n    static tan(a) {\n        return Math.tan(a);\n    }\n    /**\n       * Calculate arcsinus.\n       */\n    static asin(v) {\n        return Math.asin(v);\n    }\n    /**\n       * Calculate arctangent.\n       */\n    static atan(v) {\n        return Math.atan(v);\n    }\n    /**\n       * Calculate log.\n       */\n    static log(v) {\n        return Math.log(v);\n    }\n    /**\n       * Calculate exp.\n       */\n    static exp(v) {\n        return Math.exp(v);\n    }\n    /**\n       * Initialize the projection.\n       * @param ellipsoid the ellipsoid to use.\n       * @return this projection (for convenience).\n       */\n    initializeProjection(ellipsoid) {\n        /* Get the ellipsoid parameters */\n        const a = ellipsoid.getA();\n        this._e = ellipsoid.getE();\n        /* Calculate conformat latitude (chi0) and longitude (lambda0) */\n        this._e2 = this._e * this._e;\n        const sinLat0 = ObliqueStereographic.sin(this._lat0);\n        const t0 = 1.0 - this._e2 * sinLat0 * sinLat0;\n        const rho0 = a * (1 - this._e2) / ObliqueStereographic.pow(t0, 1.5);\n        const nu0 = a / ObliqueStereographic.pow(t0, 0.5);\n        this._R = ObliqueStereographic.pow(rho0 * nu0, 0.5);\n        this._n = ObliqueStereographic.pow(1.0 + (this._e2 * ObliqueStereographic.pow(ObliqueStereographic.cos(this._lat0), 4)) / (1.0 - this._e2), 0.5);\n        const S1 = (1.0 + sinLat0) / (1.0 - sinLat0);\n        const S2 = (1.0 - this._e * sinLat0) / (1.0 + this._e * sinLat0);\n        const w1 = ObliqueStereographic.pow(S1 * ObliqueStereographic.pow(S2, this._e), this._n);\n        const sinChi0 = (w1 - 1.0) / (w1 + 1.0);\n        this._c = (this._n + sinLat0) * (1.0 - sinChi0) / ((this._n - sinLat0) * (1.0 + sinChi0));\n        const w2 = this._c * w1;\n        this._chi0 = ObliqueStereographic.asin((w2 - 1.0) / (w2 + 1.0));\n        this._lambda0 = this._lon0;\n        /* For reverse calculation */\n        this._g = 2.0 * this._R * this._k0 * ObliqueStereographic.tan(ObliqueStereographic.PI / 4.0 - this._chi0 / 2.0);\n        this._h = 4.0 * this._R * this._k0 * ObliqueStereographic.tan(this._chi0) + this._g;\n        /* Return the projection */\n        return this;\n    }\n    /**\n       * OperationMethod method.\n       * @see OperationMethod#initialize\n       */\n    initialize(operation) {\n        this.initializeProjection(operation.getSourceCRS().getEllipsoid());\n    }\n    /**\n       * OperationMethod interface method.\n       * @see OperationMethod#forward\n       */\n    forward(sourceCRS, source, targetCRS, target) {\n        /* Get the parameters */\n        const lon = source.getX();\n        const lat = source.getY();\n        const sinLat = ObliqueStereographic.sin(lat);\n        /* Calculate conformal latitude and longitude */\n        const lambda = this._n * (lon - this._lambda0) + this._lambda0;\n        const Sa = (1.0 + sinLat) / (1.0 - sinLat);\n        const Sb = (1.0 - this._e * sinLat) / (1.0 + this._e * sinLat);\n        const w = this._c * ObliqueStereographic.pow(Sa * ObliqueStereographic.pow(Sb, this._e), this._n);\n        const chi = ObliqueStereographic.asin((w - 1.0) / (w + 1.0));\n        /* Calculate easting and northing */\n        const B = 1.0 + ObliqueStereographic.sin(chi) * ObliqueStereographic.sin(this._chi0) + ObliqueStereographic.cos(chi) * ObliqueStereographic.cos(this._chi0) * ObliqueStereographic.cos(lambda - this._lambda0);\n        const E = this._fe + 2.0 * this._R * this._k0 * ObliqueStereographic.cos(chi) * ObliqueStereographic.sin(lambda - this._lambda0) / B;\n        const N = this._fn + 2.0 * this._R * this._k0 * (ObliqueStereographic.sin(chi) * ObliqueStereographic.cos(this._chi0) - ObliqueStereographic.cos(chi) * ObliqueStereographic.sin(this._chi0) * ObliqueStereographic.cos(lambda - this._lambda0)) / B;\n        /* Save the position */\n        target.setX(E);\n        target.setY(N);\n        target.setZ(source.getZ()); // Keep the Z value\n    }\n    /**\n       * OperationMethod interface method.\n       * @see OperationMethod#reverse\n       */\n    reverse(sourceCRS, source, targetCRS, target) {\n        /* Get the parameters */\n        const E = target.getX() - this._fe;\n        const N = target.getY() - this._fn;\n        /* Calculate conformal latitude and longitude */\n        const i = ObliqueStereographic.atan(E / (this._h + N));\n        const j = ObliqueStereographic.atan(E / (this._g - N)) - i;\n        const chi = this._chi0 + 2.0 * ObliqueStereographic.atan((N - E * ObliqueStereographic.tan(j / 2.0)) / (2.0 * this._R * this._k0));\n        const lambda = j + 2.0 * i + this._lambda0;\n        const lon = (lambda - this._lambda0) / this._n + this._lambda0;\n        /* Iterate to get isometric (psi) and geodetic (phi) latitude */\n        const sinChi = ObliqueStereographic.sin(chi);\n        const psi = 0.5 * ObliqueStereographic.log((1.0 + sinChi) / (this._c * (1.0 - sinChi))) / this._n;\n        let phiK = 2.0 * ObliqueStereographic.atan(ObliqueStereographic.exp(psi)) - ObliqueStereographic.PI / 2.0;\n        for (let k = 1; k < 8; k++) {\n            const esinPhi = this._e * ObliqueStereographic.sin(phiK);\n            const psiK = ObliqueStereographic.log(ObliqueStereographic.tan(phiK / 2.0 + ObliqueStereographic.PI / 4.0) * ObliqueStereographic.pow((1.0 - esinPhi) / (1.0 + esinPhi), this._e / 2.0));\n            const phiNextK = phiK - (psiK - psi) * ObliqueStereographic.cos(phiK) * (1.0 - esinPhi * esinPhi) / (1.0 - this._e2);\n            const change = Math.abs(phiNextK - phiK);\n            phiK = phiNextK;\n            if (change < 1.0e-12)\n                break; // normally after 4 iterations\n        }\n        /* Save the position */\n        source.setX(lon);\n        source.setY(phiK);\n        source.setZ(target.getZ()); // Keep the Z value\n    }\n}\n/** The code of this method */\nObliqueStereographic.METHOD_CODE = 9809;\n/** The value of PI */\nObliqueStereographic.PI = Math.PI;\nexport { ObliqueStereographic };\n//# sourceMappingURL=ObliqueStereographic.js.map",
      "start": 1693508125633,
      "end": 1693508125672,
      "sourcemaps": null
    }
  ]
}
