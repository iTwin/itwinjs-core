{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/orbitgt/lib/esm/spatial/ecrs/WellKnownText.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module OrbitGT\n */\nimport { AList } from \"../../system/collection/AList\";\nimport { ASystem } from \"../../system/runtime/ASystem\";\nimport { Message } from \"../../system/runtime/Message\";\nimport { Numbers } from \"../../system/runtime/Numbers\";\nimport { Strings } from \"../../system/runtime/Strings\";\nimport { CRS } from \"./CRS\";\nimport { Datum } from \"./Datum\";\nimport { Ellipsoid } from \"./Ellipsoid\";\nimport { Operation } from \"./Operation\";\nimport { ParameterValue } from \"./ParameterValue\";\nimport { ParameterValueList } from \"./ParameterValueList\";\nimport { PrimeMeridian } from \"./PrimeMeridian\";\nimport { HotineObliqueMercator } from \"./projection/HotineObliqueMercator\";\nimport { KrovakObliqueConformalConic } from \"./projection/KrovakObliqueConformalConic\";\nimport { KrovakObliqueConformalConicEN } from \"./projection/KrovakObliqueConformalConicEN\";\nimport { LambertConical1SP } from \"./projection/LambertConical1SP\";\nimport { LambertConical2SP } from \"./projection/LambertConical2SP\";\nimport { Mercator1SP } from \"./projection/Mercator1SP\";\nimport { ObliqueMercator } from \"./projection/ObliqueMercator\";\nimport { ObliqueStereographic } from \"./projection/ObliqueStereographic\";\nimport { TransverseMercator } from \"./projection/TransverseMercator\";\nimport { Registry } from \"./Registry\";\nimport { PositionVector } from \"./transformation/PositionVector\";\nimport { Unit } from \"./Unit\";\nimport { WellKnownTextNode } from \"./WellKnownTextNode\";\n/**\n * Class WellKnownText parses Well-known Text Representations of Spatial Reference Systems.\n *\n * @version 1.0 December 2010\n */\n/** @internal */\nclass WellKnownText {\n    /**\n     * No instances.\n     */\n    constructor() { }\n    /**\n     * Unquote a name.\n     * @param name the name.\n     * @return the unquoted name.\n     */\n    static unquote(name) {\n        name = Strings.trim(name);\n        ASystem.assert0(Strings.startsWith(name, \"\\\"\"), \"Name '\" + name + \"' does not start with a quote\");\n        ASystem.assert0(Strings.endsWith(name, \"\\\"\"), \"Name '\" + name + \"' does not end with a quote\");\n        return Strings.substring(name, 1, Strings.getLength(name) - 1);\n    }\n    /**\n     * Get a number.\n     * @param value the string value.\n     * @return the number.\n     */\n    static getInteger(value) {\n        return Numbers.getInteger(value, 0);\n    }\n    /**\n     * Get a number.\n     * @param value the string value.\n     * @return the number.\n     */\n    static getDouble(value) {\n        return Numbers.getDouble(value, 0.0);\n    }\n    /**\n     * Get a number.\n     * @param value the node value.\n     * @return the number.\n     */\n    static getNodeDouble(value) {\n        if (value == null)\n            return 0.0;\n        return Numbers.getDouble(value.getName(), 0.0);\n    }\n    /**\n     * Get an EPSG code for an element.\n     * @param authority the authority for the element.\n     * @param dialect the dialect of WKT to parse.\n     * @return the EPSG code (zero if not found).\n     */\n    static getEPSGCode(authority, dialect) {\n        // example: AUTHORITY[\"EPSG\",\"2320\"]\n        if (authority == null)\n            return 0;\n        let name = WellKnownText.unquote(authority.getArgument(0).getName());\n        let code = WellKnownText.unquote(authority.getArgument(1).getName());\n        if (Strings.equalsIgnoreCase(name, \"EPSG\") == false)\n            return 0;\n        let epsgCode = Numbers.getInteger(code, 0);\n        return epsgCode; // Enabled on 06/06/2014\n    }\n    /**\n     * Parse a linear unit.\n     * @param node the well-known-text node.\n     * @param dialect the dialect of WKT to parse.\n     * @return the unit.\n     */\n    static parseLinearUnit(node, dialect) {\n        /* Get the parameters */\n        let name = WellKnownText.unquote(node.getArgument(0).getName());\n        let conversionFactor = WellKnownText.getDouble(node.getArgument(1).getName());\n        let authority = node.getArgumentByName(\"AUTHORITY\");\n        /* Do we have an EPGS code ? */\n        let epsgCode = WellKnownText.getEPSGCode(authority, dialect);\n        let code = (epsgCode == 0) ? WellKnownText._CODES++ : epsgCode;\n        /* Return the unit */\n        return new Unit(code, name, name /*abbreviation*/, \"length\", Unit.METER /*targetUnitCode*/, conversionFactor, 1.0);\n    }\n    /**\n     * Parse an angular unit.\n     * @param node the well-known-text node.\n     * @param dialect the dialect of WKT to parse.\n     * @return the unit.\n     */\n    static parseAngularUnit(node, dialect) {\n        /* Get the parameters */\n        let name = WellKnownText.unquote(node.getArgument(0).getName());\n        let conversionFactor = WellKnownText.getDouble(node.getArgument(1).getName());\n        let authority = node.getArgumentByName(\"AUTHORITY\");\n        /* Do we have an EPGS code ? */\n        let epsgCode = WellKnownText.getEPSGCode(authority, dialect);\n        let code = (epsgCode == 0) ? WellKnownText._CODES++ : epsgCode;\n        /* Return the unit */\n        return new Unit(code, name, name /*abbreviation*/, \"angle\", Unit.RADIAN /*targetUnitCode*/, conversionFactor, 1.0);\n    }\n    /**\n     * Parse a spheroid.\n     * @param crsCode the code of the CRS.\n     * @param node the well-known-text node.\n     * @param dialect the dialect of WKT to parse.\n     * @return the ellipsoid.\n     */\n    static parseSpheroid(crsCode, node, dialect) {\n        /* Get the parameters */\n        let name = WellKnownText.unquote(node.getArgument(0).getName());\n        let semiMajorAxis = WellKnownText.getDouble(node.getArgument(1).getName());\n        let invFlattening = WellKnownText.getDouble(node.getArgument(2).getName());\n        let authority = node.getArgumentByName(\"AUTHORITY\");\n        /* Do we have an EPGS code ? */\n        let epsgCode = WellKnownText.getEPSGCode(authority, dialect);\n        let code = (epsgCode == 0) ? WellKnownText._CODES++ : epsgCode;\n        /* Return the ellipsoid */\n        return new Ellipsoid(code, name, Unit.METER, semiMajorAxis, invFlattening, 0.0);\n    }\n    /**\n     * Parse a prime-meridian.\n     * @param crsCode the code of the CRS.\n     * @param node the well-known-text node.\n     * @param dialect the dialect of WKT to parse.\n     * @return the prime-meridian.\n     */\n    static parsePrimeMeridian(crsCode, node, dialect) {\n        /* Get the parameters */\n        let name = WellKnownText.unquote(node.getArgument(0).getName());\n        let longitude = WellKnownText.getDouble(node.getArgument(1).getName());\n        let authority = node.getArgumentByName(\"AUTHORITY\");\n        /* Do we have an EPGS code ? */\n        let epsgCode = WellKnownText.getEPSGCode(authority, dialect);\n        let code = (epsgCode == 0) ? WellKnownText._CODES++ : epsgCode;\n        /* Return the prime-meridian */\n        return new PrimeMeridian(code, name, longitude /*lonFromGreenwich*/, Unit.DEGREE /*?*/);\n    }\n    /**\n     * Parse a to-wgs84 transform.\n     * @param node the well-known-text node (method position vector).\n     * @param dialect the dialect of WKT to parse.\n     * @return the transform.\n     */\n    static parseToWGS84(node, dialect) {\n        /* No transform ? */\n        if (node == null)\n            return null;\n        /* Get the parameters */\n        let dx = WellKnownText.getNodeDouble(node.getArgument(0)); // meter\n        let dy = WellKnownText.getNodeDouble(node.getArgument(1));\n        let dz = WellKnownText.getNodeDouble(node.getArgument(2));\n        let rx = WellKnownText.getNodeDouble(node.getOptionalArgument(3)); // arc-second\n        let ry = WellKnownText.getNodeDouble(node.getOptionalArgument(4));\n        let rz = WellKnownText.getNodeDouble(node.getOptionalArgument(5));\n        let ppm = WellKnownText.getNodeDouble(node.getOptionalArgument(6)); // parts-per-million\n        /* Return the transform */\n        return PositionVector.create(dx, dy, dz, rx * WellKnownText._ARC_SEC_TO_RAD, ry * WellKnownText._ARC_SEC_TO_RAD, rz * WellKnownText._ARC_SEC_TO_RAD, ppm / 1.0e6);\n    }\n    /**\n     * Parse a datum.\n     * @param crsCode the code of the CRS.\n     * @param node the well-known-text node.\n     * @param primeMeridian the prime meridian.\n     * @param dialect the dialect of WKT to parse.\n     * @return the datum (with optional embedded datum transformation to WGS84).\n     */\n    static parseDatum(crsCode, node, primeMeridian, dialect) {\n        /* Get the parameters */\n        let name = WellKnownText.unquote(node.getArgument(0).getName());\n        let spheroid = WellKnownText.parseSpheroid(crsCode, node.getArgumentByName(\"SPHEROID\"), dialect);\n        let toWGS84 = WellKnownText.parseToWGS84(node.getArgumentByName(\"TOWGS84\"), dialect);\n        if (toWGS84 == null)\n            toWGS84 = PositionVector.create(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0); // default (identity) transform added on 19/06/2013 to allow ViewTransform creation.\n        let authority = node.getArgumentByName(\"AUTHORITY\");\n        /* Do we have an EPGS code ? */\n        let epsgCode = WellKnownText.getEPSGCode(authority, dialect);\n        let code = (epsgCode == 0) ? WellKnownText._CODES++ : epsgCode;\n        /* Return the datum */\n        let datum = new Datum(code, name, Datum.TYPE_GEODETIC, spheroid, primeMeridian);\n        datum.setToWGS84(toWGS84);\n        return datum;\n    }\n    /**\n     * Parse a projection method.\n     * @param projection the well-known-text projection node.\n     * @param parameters the well-known-text parameter nodes.\n     * @param dialect the dialect of WKT to parse.\n     * @return the projection method.\n     */\n    static parseProjectionMethod(projection, parameters, dialect) {\n        // See: http://www.remotesensing.org/geotiff/proj_list/\n        // for method names and parameter names and units\n        //\n        /* Get the projection name */\n        let projectionName = WellKnownText.unquote(projection.getArgument(0).getName());\n        /* Get the standard units */\n        let DEG = Registry.getUnit(Unit.DEGREE);\n        let METER = Registry.getUnit(Unit.METER);\n        let SCALE = Registry.getUnit(Unit.UNITY);\n        /* Convert to standard parameters */\n        let parameterList = new ParameterValueList();\n        for (let i = 0; i < parameters.size(); i++) {\n            /* Get the parameter name and value */\n            let parameter = parameters.get(i);\n            let parameterName = WellKnownText.unquote(parameter.getArgument(0).getName());\n            let parameterValue = WellKnownText.getDouble(parameter.getArgument(1).getName());\n            /* Hotine_Oblique_Mercator */\n            if (Strings.equalsIgnoreCase(projectionName, \"Hotine_Oblique_Mercator\")) {\n                if (Strings.equalsIgnoreCase(parameterName, \"latitude_of_center\"))\n                    parameterList.add(new ParameterValue(8811, parameterValue, DEG));\n                if (Strings.equalsIgnoreCase(parameterName, \"longitude_of_center\"))\n                    parameterList.add(new ParameterValue(8812, parameterValue, DEG));\n                if (Strings.equalsIgnoreCase(parameterName, \"azimuth\"))\n                    parameterList.add(new ParameterValue(8813, parameterValue, DEG));\n                if (Strings.equalsIgnoreCase(parameterName, \"rectified_grid_angle\"))\n                    parameterList.add(new ParameterValue(8814, parameterValue, DEG));\n                if (Strings.equalsIgnoreCase(parameterName, \"scale_factor\"))\n                    parameterList.add(new ParameterValue(8815, parameterValue, SCALE));\n                if (Strings.equalsIgnoreCase(parameterName, \"false_easting\"))\n                    parameterList.add(new ParameterValue(8806, parameterValue, METER));\n                if (Strings.equalsIgnoreCase(parameterName, \"false_northing\"))\n                    parameterList.add(new ParameterValue(8807, parameterValue, METER));\n            }\n            /* Krovak */\n            if (Strings.equalsIgnoreCase(projectionName, \"Krovak\") || Strings.equalsIgnoreCase(projectionName, \"KrovakEN\")) {\n                if (Strings.equalsIgnoreCase(parameterName, \"latitude_of_center\"))\n                    parameterList.add(new ParameterValue(8811, parameterValue, DEG));\n                if (Strings.equalsIgnoreCase(parameterName, \"longitude_of_center\"))\n                    parameterList.add(new ParameterValue(8833, parameterValue, DEG));\n                if (Strings.equalsIgnoreCase(parameterName, \"azimuth\"))\n                    parameterList.add(new ParameterValue(1036, parameterValue, DEG)); // changed from 8813 to 1036 on 31/08/2017\n                if (Strings.equalsIgnoreCase(parameterName, \"pseudo_standard_parallel_1\"))\n                    parameterList.add(new ParameterValue(8818, parameterValue, DEG));\n                if (Strings.equalsIgnoreCase(parameterName, \"scale_factor\"))\n                    parameterList.add(new ParameterValue(8819, parameterValue, SCALE));\n                if (Strings.equalsIgnoreCase(parameterName, \"false_easting\"))\n                    parameterList.add(new ParameterValue(8806, parameterValue, METER));\n                if (Strings.equalsIgnoreCase(parameterName, \"false_northing\"))\n                    parameterList.add(new ParameterValue(8807, parameterValue, METER));\n            }\n            /* Lambert_Conformal_Conic_1SP */\n            if (Strings.equalsIgnoreCase(projectionName, \"Lambert_Conformal_Conic_1SP\")) {\n                if (Strings.equalsIgnoreCase(parameterName, \"latitude_of_origin\"))\n                    parameterList.add(new ParameterValue(8801, parameterValue, DEG));\n                if (Strings.equalsIgnoreCase(parameterName, \"central_meridian\"))\n                    parameterList.add(new ParameterValue(8802, parameterValue, DEG));\n                if (Strings.equalsIgnoreCase(parameterName, \"scale_factor\"))\n                    parameterList.add(new ParameterValue(8805, parameterValue, SCALE));\n                if (Strings.equalsIgnoreCase(parameterName, \"false_easting\"))\n                    parameterList.add(new ParameterValue(8806, parameterValue, METER));\n                if (Strings.equalsIgnoreCase(parameterName, \"false_northing\"))\n                    parameterList.add(new ParameterValue(8807, parameterValue, METER));\n            }\n            /* Lambert_Conformal_Conic_2SP / Lambert_Conformal_Conic_2SP_Belgium / Lambert_Conformal_Conic  */\n            if (Strings.equalsIgnoreCase(projectionName, \"Lambert_Conformal_Conic_2SP\") || Strings.equalsIgnoreCase(projectionName, \"Lambert_Conformal_Conic_2SP_Belgium\") || Strings.equalsIgnoreCase(projectionName, \"Lambert_Conformal_Conic\")) {\n                if (Strings.equalsIgnoreCase(parameterName, \"latitude_of_origin\"))\n                    parameterList.add(new ParameterValue(8821, parameterValue, DEG));\n                if (Strings.equalsIgnoreCase(parameterName, \"central_meridian\"))\n                    parameterList.add(new ParameterValue(8822, parameterValue, DEG));\n                if (Strings.equalsIgnoreCase(parameterName, \"standard_parallel_1\"))\n                    parameterList.add(new ParameterValue(8823, parameterValue, DEG));\n                if (Strings.equalsIgnoreCase(parameterName, \"standard_parallel_2\"))\n                    parameterList.add(new ParameterValue(8824, parameterValue, DEG));\n                if (Strings.equalsIgnoreCase(parameterName, \"false_easting\"))\n                    parameterList.add(new ParameterValue(8826, parameterValue, METER));\n                if (Strings.equalsIgnoreCase(parameterName, \"false_northing\"))\n                    parameterList.add(new ParameterValue(8827, parameterValue, METER));\n                //                if (Strings.equalsIgnoreCase(parameterName,\"scale_factor\")) {if (parameterValue!=1.0) throw new IllegalArgumentException(MODULE+\" : Invalid parameter '\"+parameterName+\"' with value \"+parameterValue);}\n            }\n            /* Mercator_1SP */\n            if (Strings.equalsIgnoreCase(projectionName, \"Mercator_1SP\")) {\n                if (Strings.equalsIgnoreCase(parameterName, \"latitude_of_origin\"))\n                    parameterList.add(new ParameterValue(8801, parameterValue, DEG));\n                if (Strings.equalsIgnoreCase(parameterName, \"central_meridian\"))\n                    parameterList.add(new ParameterValue(8802, parameterValue, DEG));\n                if (Strings.equalsIgnoreCase(parameterName, \"scale_factor\"))\n                    parameterList.add(new ParameterValue(8805, parameterValue, SCALE));\n                if (Strings.equalsIgnoreCase(parameterName, \"false_easting\"))\n                    parameterList.add(new ParameterValue(8806, parameterValue, METER));\n                if (Strings.equalsIgnoreCase(parameterName, \"false_northing\"))\n                    parameterList.add(new ParameterValue(8807, parameterValue, METER));\n            }\n            /* Oblique_Mercator */\n            if (Strings.equalsIgnoreCase(projectionName, \"Oblique_Mercator\")) {\n                if (Strings.equalsIgnoreCase(parameterName, \"latitude_of_center\"))\n                    parameterList.add(new ParameterValue(8811, parameterValue, DEG));\n                if (Strings.equalsIgnoreCase(parameterName, \"longitude_of_center\"))\n                    parameterList.add(new ParameterValue(8812, parameterValue, DEG));\n                if (Strings.equalsIgnoreCase(parameterName, \"azimuth\"))\n                    parameterList.add(new ParameterValue(8813, parameterValue, DEG));\n                if (Strings.equalsIgnoreCase(parameterName, \"rectified_grid_angle\"))\n                    parameterList.add(new ParameterValue(8814, parameterValue, DEG));\n                if (Strings.equalsIgnoreCase(parameterName, \"scale_factor\"))\n                    parameterList.add(new ParameterValue(8815, parameterValue, SCALE));\n                if (Strings.equalsIgnoreCase(parameterName, \"false_easting\"))\n                    parameterList.add(new ParameterValue(8816, parameterValue, METER));\n                if (Strings.equalsIgnoreCase(parameterName, \"false_northing\"))\n                    parameterList.add(new ParameterValue(8817, parameterValue, METER));\n            }\n            /* Oblique_Stereographic /Transverse_Mercator */\n            if (Strings.equalsIgnoreCase(projectionName, \"Oblique_Stereographic\") || Strings.equalsIgnoreCase(projectionName, \"Transverse_Mercator\")) {\n                if (Strings.equalsIgnoreCase(parameterName, \"latitude_of_origin\"))\n                    parameterList.add(new ParameterValue(8801, parameterValue, DEG));\n                if (Strings.equalsIgnoreCase(parameterName, \"central_meridian\"))\n                    parameterList.add(new ParameterValue(8802, parameterValue, DEG));\n                if (Strings.equalsIgnoreCase(parameterName, \"scale_factor\"))\n                    parameterList.add(new ParameterValue(8805, parameterValue, SCALE));\n                if (Strings.equalsIgnoreCase(parameterName, \"false_easting\"))\n                    parameterList.add(new ParameterValue(8806, parameterValue, METER));\n                if (Strings.equalsIgnoreCase(parameterName, \"false_northing\"))\n                    parameterList.add(new ParameterValue(8807, parameterValue, METER));\n            }\n        }\n        /* Create the right method */\n        if (Strings.equalsIgnoreCase(projectionName, \"Hotine_Oblique_Mercator\"))\n            return new HotineObliqueMercator(parameterList);\n        if (Strings.equalsIgnoreCase(projectionName, \"Krovak\"))\n            return new KrovakObliqueConformalConic(parameterList);\n        if (Strings.equalsIgnoreCase(projectionName, \"KrovakEN\"))\n            return new KrovakObliqueConformalConicEN(parameterList);\n        if (Strings.equalsIgnoreCase(projectionName, \"Lambert_Conformal_Conic_1SP\"))\n            return new LambertConical1SP(parameterList);\n        if (Strings.equalsIgnoreCase(projectionName, \"Lambert_Conformal_Conic_2SP\"))\n            return new LambertConical2SP(parameterList);\n        if (Strings.equalsIgnoreCase(projectionName, \"Lambert_Conformal_Conic\"))\n            return new LambertConical2SP(parameterList);\n        if (Strings.equalsIgnoreCase(projectionName, \"Mercator_1SP\"))\n            return new Mercator1SP(parameterList);\n        if (Strings.equalsIgnoreCase(projectionName, \"Oblique_Mercator\"))\n            return new ObliqueMercator(parameterList);\n        if (Strings.equalsIgnoreCase(projectionName, \"Oblique_Stereographic\"))\n            return new ObliqueStereographic(parameterList);\n        if (Strings.equalsIgnoreCase(projectionName, \"Transverse_Mercator\"))\n            return new TransverseMercator(parameterList);\n        ASystem.assert0(false, \"Unknown projection type '\" + projectionName + \"'\");\n        return null;\n    }\n    /**\n     * Parse a geocentric CRS.\n     * @param crsCode the code of the CRS.\n     * @param node the well-known-text node.\n     * @param dialect the dialect of WKT to parse.\n     * @return the CRS.\n     */\n    static parseGeocentric(crsCode, node, dialect) {\n        /* Get the parameters */\n        let name = WellKnownText.unquote(node.getArgument(0).getName());\n        let primeMeridian = WellKnownText.parsePrimeMeridian(crsCode, node.getArgumentByName(\"PRIMEM\"), dialect);\n        let datum = WellKnownText.parseDatum(crsCode, node.getArgumentByName(\"DATUM\"), primeMeridian, dialect);\n        let toWGS84m = datum.getToWGS84();\n        let toWGS84s = new AList();\n        let linearUnit = WellKnownText.parseLinearUnit(node.getArgumentByName(\"UNIT\"), dialect);\n        let axis = node.getArgumentsByName(\"AXIS\");\n        let authority = node.getArgumentByName(\"AUTHORITY\");\n        /* Do we have an EPGS code ? */\n        let epsgCode = WellKnownText.getEPSGCode(authority, dialect);\n        let code = (epsgCode == 0) ? crsCode : epsgCode;\n        /* Return the CRS */\n        if (toWGS84m != null)\n            toWGS84s.add(new Operation(0 /*code*/, \"\" /*name*/, Operation.TRANSFORMATION, code, CRS.WGS84_2D_CRS_CODE, 0 /*area*/, toWGS84m));\n        return new CRS(code, name, 0 /*area*/, CRS.GEOCENTRIC, 0 /*csCode*/, datum, null /*baseCRS*/, null /*projection*/, toWGS84s);\n    }\n    /**\n     * Parse a geographic CRS.\n     * @param crsCode the code of the CRS.\n     * @param node the well-known-text node.\n     * @param dialect the dialect of WKT to parse.\n     * @return the CRS.\n     */\n    static parseGeographic(crsCode, node, dialect) {\n        /* Get the parameters */\n        let name = WellKnownText.unquote(node.getArgument(0).getName());\n        let primeMeridian = WellKnownText.parsePrimeMeridian(crsCode, node.getArgumentByName(\"PRIMEM\"), dialect);\n        let datum = WellKnownText.parseDatum(crsCode, node.getArgumentByName(\"DATUM\"), primeMeridian, dialect);\n        let toWGS84m = datum.getToWGS84();\n        let toWGS84s = new AList();\n        let angularUnit = WellKnownText.parseAngularUnit(node.getArgumentByName(\"UNIT\"), dialect);\n        let axis = node.getArgumentsByName(\"AXIS\");\n        let authority = node.getArgumentByName(\"AUTHORITY\");\n        /* Do we have an EPGS code ? */\n        let epsgCode = WellKnownText.getEPSGCode(authority, dialect);\n        let code = (epsgCode == 0) ? crsCode : epsgCode;\n        /* Return the CRS */\n        if (toWGS84m != null)\n            toWGS84s.add(new Operation(0 /*code*/, \"\" /*name*/, Operation.TRANSFORMATION, code, CRS.WGS84_2D_CRS_CODE, 0 /*area*/, toWGS84m));\n        return new CRS(code, name, 0 /*area*/, CRS.GEOGRAPHIC_2D, 0 /*csCode*/, datum, null /*baseCRS*/, null /*projection*/, toWGS84s);\n    }\n    /**\n     * Parse a projected CRS.\n     * @param crsCode the code of the CRS.\n     * @param node the well-known-text node.\n     * @param dialect the dialect of WKT to parse.\n     * @return the CRS.\n     */\n    static parseProjection(crsCode, node, dialect) {\n        /* Get the parameters */\n        let name = WellKnownText.unquote(node.getArgument(0).getName());\n        let baseCRS = WellKnownText.parseGeographic(-crsCode, node.getArgumentByName(\"GEOGCS\"), dialect);\n        let projection = node.getArgumentByName(\"PROJECTION\");\n        let parameters = node.getArgumentsByName(\"PARAMETER\");\n        let projectionMethod = WellKnownText.parseProjectionMethod(projection, parameters, dialect);\n        let linearUnit = WellKnownText.parseLinearUnit(node.getArgumentByName(\"UNIT\"), dialect);\n        let axis = node.getArgumentsByName(\"AXIS\");\n        let authority = node.getArgumentByName(\"AUTHORITY\");\n        /* Do we have an EPGS code ? */\n        let epsgCode = WellKnownText.getEPSGCode(authority, dialect);\n        let code = (epsgCode == 0) ? crsCode : epsgCode;\n        /* Return the CRS */\n        let projectionOperation = new Operation(0 /*code*/, \"\" /*name*/, Operation.CONVERSION, code, baseCRS.getCode(), 0 /*area*/, projectionMethod);\n        return new CRS(code, name, 0 /*area*/, CRS.PROJECTED, 0 /*csCode*/, null /*datum*/, baseCRS, projectionOperation, null /*toWGS84*/);\n    }\n    /**\n     * Parse a vertical CRS.\n     * @param crsCode the code of the CRS.\n     * @param node the well-known-text node.\n     * @param dialect the dialect of WKT to parse.\n     * @return the CRS.\n     */\n    static parseVertical(crsCode, node, dialect) {\n        /* Get the parameters */\n        let name = WellKnownText.unquote(node.getArgument(0).getName());\n        let authority = node.getArgumentByName(\"AUTHORITY\");\n        /* Do we have an EPGS code ? */\n        let epsgCode = WellKnownText.getEPSGCode(authority, dialect);\n        let code = (epsgCode == 0) ? crsCode : epsgCode;\n        /* Create the datum */\n        let datum = new Datum(code, name, Datum.TYPE_VERTICAL, null /*spheroid*/, null /*primeMeridian*/);\n        /* Return the CRS */\n        return new CRS(code, name, 0 /*area*/, CRS.VERTICAL, 6499 /*csCode*/, datum, null /*baseCRS*/, null /*projectionOperation*/, null /*toWGS84*/);\n    }\n    /**\n     * Parse a CRS well-known-text.\n     * @param crsCode the code of the CRS.\n     * @param text the well-known-text.\n     * @param dialect the dialect of WKT to parse.\n     * @return the CRS (null if unable to parse).\n     */\n    static parseSpatialReferenceSystem(crsCode, text, dialect) {\n        let node = WellKnownTextNode.parse(text);\n        if (Strings.equalsIgnoreCase(node.getName(), \"GEOCCS\"))\n            return WellKnownText.parseGeocentric(crsCode, node, dialect);\n        if (Strings.equalsIgnoreCase(node.getName(), \"GEOGCS\"))\n            return WellKnownText.parseGeographic(crsCode, node, dialect);\n        if (Strings.equalsIgnoreCase(node.getName(), \"PROJCS\"))\n            return WellKnownText.parseProjection(crsCode, node, dialect);\n        if (Strings.equalsIgnoreCase(node.getName(), \"VERTCS\"))\n            return WellKnownText.parseVertical(crsCode, node, dialect);\n        Message.printWarning(WellKnownText.MODULE, \"Invalid spatial reference system WKT '\" + text + \"'\");\n        return null;\n    }\n}\n/** The name of this module */\nWellKnownText.MODULE = \"WellKnownText\";\n/** The dialect type in case of generic WKT */\nWellKnownText.TYPE_GENERIC = \"generic\";\n/** The conversion ratio from \"arc-sec\" to \"radian\" */\nWellKnownText._ARC_SEC_TO_RAD = (1.0 / 3600.0 * Math.PI / 180.0);\n/** The counter for creating unique codes */\nWellKnownText._CODES = 100000;\nexport { WellKnownText };\n//# sourceMappingURL=WellKnownText.js.map",
      "start": 1693508125498,
      "end": 1693508125554,
      "sourcemaps": null
    }
  ]
}
