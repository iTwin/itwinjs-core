{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/geometry3d/PolylineCompressionByEdgeOffset.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\nimport { Geometry } from \"../Geometry\";\nimport { Point3dArrayCarrier } from \"./Point3dArrayCarrier\";\nimport { Vector3d } from \"./Point3dVector3d\";\n// cspell:word Puecker\n/** context class for Puecker-Douglas polyline compression, viz https://en.wikipedia.org/wiki/Ramer–Douglas–Peucker_algorithm\n * @internal\n */\nclass PolylineCompressionContext {\n    /** Caller provides source and tolerance.\n     * * pointer to source is retained, but contents of source are never modified.\n     */\n    constructor(source, dest, tolerance) {\n        this._toleranceSquared = tolerance * tolerance;\n        this._source = source;\n        this._dest = dest;\n    }\n    /** push (clone of) the point at index i from the source to the growing result.\n     * * index is adjusted cyclically to source index range by modulo.\n     */\n    acceptPointByIndex(i) {\n        const point = this._source.getPoint3dAtCheckedPointIndex(this._source.cyclicIndex(i));\n        if (point)\n            this._dest.push(point);\n    }\n    /**\n     * Return index of max magnitude of cross product of vectors (index to index+1) and (index to index+2)\n     * * Return undefined if unable to find a nonzero cross product.\n     * @param i0 first cross product central index.\n     * @param i1 last cross product central index.\n     */\n    indexOfMaxCrossProduct(index0, index1) {\n        let qMax = 0.0;\n        let q;\n        let indexMax;\n        for (let index = index0; index <= index1; index++) {\n            const iA = this._source.cyclicIndex(index);\n            const iB = this._source.cyclicIndex(index + 1);\n            const iC = this._source.cyclicIndex(index + 2);\n            this._source.crossProductIndexIndexIndex(iA, iB, iC, PolylineCompressionContext._vectorQ);\n            q = PolylineCompressionContext._vectorQ.magnitudeSquared();\n            if (q > qMax) {\n                qMax = q;\n                indexMax = index;\n            }\n        }\n        return indexMax;\n    }\n    /**\n     * Return interior index where max deviation in excess of tolerance occurs.\n     * @param i0 first index of interval\n     * @param i1 INCLUSIVE final index\n     */\n    indexOfMaxDeviation(index0, index1) {\n        const i0 = this._source.cyclicIndex(index0);\n        const i1 = this._source.cyclicIndex(index1);\n        let maxDeviation = this._toleranceSquared;\n        let maxDeviationIndex;\n        let numerator;\n        let distanceSquared;\n        let s;\n        let i;\n        this._source.vectorIndexIndex(i0, i1, PolylineCompressionContext._vector01);\n        const denominator = PolylineCompressionContext._vector01.magnitudeSquared();\n        for (let index = index0 + 1; index < index1; index++) {\n            i = this._source.cyclicIndex(index);\n            this._source.vectorIndexIndex(i0, i, PolylineCompressionContext._vectorQ);\n            numerator = PolylineCompressionContext._vector01.dotProduct(PolylineCompressionContext._vectorQ);\n            if (numerator <= 0) {\n                distanceSquared = PolylineCompressionContext._vectorQ.magnitudeSquared();\n            }\n            else if (numerator > denominator) {\n                this._source.vectorIndexIndex(i1, i, PolylineCompressionContext._vectorQ);\n                distanceSquared = PolylineCompressionContext._vectorQ.magnitudeSquared();\n            }\n            else {\n                s = numerator / denominator;\n                distanceSquared = PolylineCompressionContext._vectorQ.magnitudeSquared() - denominator * s * s;\n            }\n            if (distanceSquared > maxDeviation) {\n                maxDeviation = distanceSquared;\n                maxDeviationIndex = index;\n            }\n        }\n        return maxDeviationIndex;\n    }\n    /**\n     *\n     * @param i0 first active point index\n     * @param i1 last active point index (INCLUSIVE -- not \"one beyond\")\n     * @param chordTolerance\n     * @param result\n     */\n    // ASSUME index i0 is already saved.\n    // ASSUME point i\n    recursiveCompressByChordErrorGo(i0, i1) {\n        if (i1 === i0 + 1) {\n            this.acceptPointByIndex(i1);\n            return;\n        }\n        const distantPointIndex = this.indexOfMaxDeviation(i0, i1);\n        if (distantPointIndex === undefined) {\n            this.acceptPointByIndex(i1); // which compresses out some points.\n        }\n        else {\n            this.recursiveCompressByChordErrorGo(i0, distantPointIndex);\n            this.recursiveCompressByChordErrorGo(distantPointIndex, i1);\n        }\n    }\n    // cspell:word Peucker\n    /**\n     * Return a point array with a subset of the input points.\n     * * This is a global analysis (Douglas-Peucker)\n     * @param source input points.\n     * @param chordTolerance Points less than this distance from a retained edge may be ignored.\n     */\n    static compressPoint3dArrayByChordError(source, chordTolerance) {\n        const source1 = new Point3dArrayCarrier(source);\n        const dest1 = new Point3dArrayCarrier([]);\n        this.compressCollectionByChordError(source1, dest1, chordTolerance);\n        return dest1.data;\n    }\n    /**\n     * * Return a polyline with a subset of the input points.\n     * * This is a global analysis (Douglas-Peucker)\n     * * Global search for vertices that are close to edges between widely separated neighbors.\n     * * Recurses to smaller subsets.\n     * @param source input points\n     * @param dest output points.  Must be different from source.\n     * @param chordTolerance Points less than this distance from a retained edge may be ignored.\n     */\n    static compressCollectionByChordError(source, dest, chordTolerance) {\n        dest.clear();\n        const n = source.length;\n        if (n === 1) {\n            dest.push(source.getPoint3dAtCheckedPointIndex(0));\n            return;\n        }\n        const context = new PolylineCompressionContext(source, dest, chordTolerance);\n        // Do compression on inclusive interval from indexA to indexB, with indices interpreted cyclically if closed\n        let indexA = 0;\n        let indexB = n - 1;\n        if (n > 2 && source.distanceIndexIndex(0, n - 1) <= chordTolerance) {\n            // cyclic data. It is possible that the wrap point itself has to be seen as an internal point.\n            // do the search from point index where there is a large triangle . ..\n            const maxCrossProductIndex = context.indexOfMaxCrossProduct(0, n - 1);\n            if (maxCrossProductIndex !== undefined) {\n                indexA = maxCrossProductIndex + 1;\n                indexB = indexA + n;\n            }\n        }\n        context.acceptPointByIndex(indexA);\n        context.recursiveCompressByChordErrorGo(indexA, indexB);\n    }\n    /** Copy points from source to dest, omitting those too close to predecessor.\n     * * First and last points are always preserved.\n     */\n    static compressInPlaceByShortEdgeLength(data, edgeLength) {\n        const n = data.length;\n        if (n < 2)\n            return;\n        let lastAcceptedIndex = 0;\n        // back up from final point ..\n        let indexB = n - 1;\n        while (indexB > 0 && data.distanceIndexIndex(indexB - 1, n - 1) < edgeLength)\n            indexB--;\n        if (indexB === 0) {\n            // Theres only one point there.\n            data.length = 1;\n            return;\n        }\n        // we want the exact bits of the final point even if others were nearby ..\n        if (indexB < n - 1)\n            data.moveIndexToIndex(n - 1, indexB);\n        let candidateIndex = lastAcceptedIndex + 1;\n        while (candidateIndex <= indexB) {\n            const d = data.distanceIndexIndex(lastAcceptedIndex, candidateIndex);\n            if (d >= edgeLength) {\n                data.moveIndexToIndex(candidateIndex, lastAcceptedIndex + 1);\n                lastAcceptedIndex++;\n            }\n            candidateIndex++;\n        }\n        data.length = lastAcceptedIndex + 1;\n    }\n    /** Copy points from source to dest, omitting those too close to predecessor.\n     * * First and last points are always preserved.\n     */\n    static compressInPlaceBySmallTriangleArea(data, triangleArea) {\n        const n = data.length;\n        if (n < 3)\n            return;\n        let lastAcceptedIndex = 0;\n        const cross = Vector3d.create();\n        for (let i1 = 1; i1 + 1 < n; i1++) {\n            data.crossProductIndexIndexIndex(lastAcceptedIndex, i1, i1 + 1, cross);\n            if (0.5 * cross.magnitude() > triangleArea) {\n                data.moveIndexToIndex(i1, ++lastAcceptedIndex);\n            }\n        }\n        data.moveIndexToIndex(n - 1, ++lastAcceptedIndex);\n        data.length = lastAcceptedIndex + 1;\n    }\n    /** Copy points from source to dest, omitting those too close to edge between neighbors.\n     * * First and last points are always preserved.\n     */\n    static compressInPlaceByPerpendicularDistance(data, perpendicularDistance, maxExtensionFraction = 1.0001) {\n        const n = data.length;\n        if (n < 3)\n            return;\n        let lastAcceptedIndex = 0;\n        const vector01 = PolylineCompressionContext._vector01;\n        const vectorQ = PolylineCompressionContext._vectorQ;\n        let distanceSquared;\n        const perpendicularDistanceSquared = perpendicularDistance * perpendicularDistance;\n        let denominator;\n        let i1 = 1;\n        for (; i1 + 1 < n; i1++) {\n            data.vectorIndexIndex(lastAcceptedIndex, i1 + 1, vector01);\n            data.vectorIndexIndex(lastAcceptedIndex, i1, vectorQ);\n            denominator = vector01.magnitudeSquared();\n            const s = Geometry.conditionalDivideFraction(vectorQ.dotProduct(vector01), denominator);\n            if (s !== undefined) {\n                if (s >= 0.0 && s <= maxExtensionFraction) {\n                    distanceSquared = PolylineCompressionContext._vectorQ.magnitudeSquared() - denominator * s * s;\n                    if (distanceSquared <= perpendicularDistanceSquared) {\n                        // force accept of point i1+1 .\n                        data.moveIndexToIndex(i1 + 1, ++lastAcceptedIndex);\n                        i1 = i1 + 1;\n                        continue;\n                    }\n                }\n            }\n            data.moveIndexToIndex(i1, ++lastAcceptedIndex);\n        }\n        if (i1 < n)\n            data.moveIndexToIndex(i1, ++lastAcceptedIndex);\n        data.length = lastAcceptedIndex + 1;\n    }\n    /**\n     * IF the first and last points are close AND first and last segments are colinear, remove first and last points.  Prior second to last becomes replicated start and end.\n     * * Expected to be called \"last\" after other compressions, so points \"next to\" shared first and last are good to keep.\n     * @param points\n     * @param perpendicularDistance\n     */\n    static compressColinearWrapInPlace(points, tolerance) {\n        const lastIndex = points.length - 1;\n        if (lastIndex >= 3 && points[0].distance(points[lastIndex]) < tolerance) {\n            // indices of 3 points potentially colinear.\n            const indexA = lastIndex - 1;\n            const indexB = 0;\n            const indexC = 1;\n            const vectorU = Vector3d.createStartEnd(points[indexA], points[indexC]);\n            const vectorV = Vector3d.createStartEnd(points[indexA], points[indexB]);\n            const uDotU = vectorU.dotProduct(vectorU);\n            const uDotV = vectorU.dotProduct(vectorV);\n            const fraction = Geometry.conditionalDivideFraction(uDotV, uDotU);\n            if (fraction !== undefined && fraction > 0.0 && fraction < 1.0) {\n                const h2 = vectorV.magnitudeSquared() - fraction * fraction * uDotU;\n                if (Math.sqrt(Math.abs(h2)) < tolerance) {\n                    points[0] = points[indexA];\n                    points.pop();\n                }\n            }\n        }\n    }\n}\n/** work data used by find max deviation */\nPolylineCompressionContext._vector01 = Vector3d.create();\nPolylineCompressionContext._vectorQ = Vector3d.create();\nexport { PolylineCompressionContext };\n//# sourceMappingURL=PolylineCompressionByEdgeOffset.js.map",
      "start": 1693508124073,
      "end": 1693508124146,
      "sourcemaps": null
    }
  ]
}
