{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tile/RealityModelTileTree.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Utils\n */\nimport { assert, compareBooleans, compareBooleansOrUndefined, compareNumbers, comparePossiblyUndefined, compareStrings, compareStringsOrUndefined, CompressedId64Set, Id64, } from \"@itwin/core-bentley\";\nimport { Cartographic, DefaultSupportedTypes, GeoCoordStatus, PlanarClipMaskPriority, RealityDataProvider, RealityModelDisplaySettings, } from \"@itwin/core-common\";\nimport { Angle, Constant, Ellipsoid, Matrix3d, Point3d, Range3d, Ray3d, Transform, Vector3d } from \"@itwin/core-geometry\";\nimport { calculateEcefToDbTransformAtLocation } from \"../BackgroundMapGeometry\";\nimport { DisplayStyleState } from \"../DisplayStyleState\";\nimport { IModelApp } from \"../IModelApp\";\nimport { PlanarClipMaskState } from \"../PlanarClipMaskState\";\nimport { RealityDataSource } from \"../RealityDataSource\";\nimport { BatchedTileIdMap, CesiumIonAssetProvider, createClassifierTileTreeReference, createDefaultViewFlagOverrides, getGcsConverterAvailable, RealityTileLoader, RealityTileTree, TileLoadPriority, TileTreeReference, } from \"./internal\";\nfunction getUrl(content) {\n    return content ? (content.url ? content.url : content.uri) : undefined;\n}\nvar RealityTreeId;\n(function (RealityTreeId) {\n    function compareOrigins(lhs, rhs) {\n        return compareNumbers(lhs.x, rhs.x) || compareNumbers(lhs.y, rhs.y) || compareNumbers(lhs.z, rhs.z);\n    }\n    function compareMatrices(lhs, rhs) {\n        for (let i = 0; i < 9; i++) {\n            const cmp = compareNumbers(lhs.coffs[i], rhs.coffs[i]);\n            if (0 !== cmp)\n                return cmp;\n        }\n        return 0;\n    }\n    function compareTransforms(lhs, rhs) {\n        return compareOrigins(lhs.origin, rhs.origin) || compareMatrices(lhs.matrix, rhs.matrix);\n    }\n    function compareRealityDataSourceKeys(lhs, rhs) {\n        return compareStringsOrUndefined(lhs.id, rhs.id) || compareStringsOrUndefined(lhs.format, rhs.format) || compareStringsOrUndefined(lhs.iTwinId, rhs.iTwinId);\n    }\n    function compareWithoutModelId(lhs, rhs) {\n        return compareRealityDataSourceKeys(lhs.rdSourceKey, rhs.rdSourceKey)\n            || compareBooleans(lhs.deduplicateVertices, rhs.deduplicateVertices)\n            || compareBooleansOrUndefined(lhs.produceGeometry, rhs.produceGeometry)\n            || compareStringsOrUndefined(lhs.maskModelIds, rhs.maskModelIds)\n            || comparePossiblyUndefined((ltf, rtf) => compareTransforms(ltf, rtf), lhs.transform, rhs.transform);\n    }\n    RealityTreeId.compareWithoutModelId = compareWithoutModelId;\n    function compare(lhs, rhs) {\n        return compareStrings(lhs.modelId, rhs.modelId) || compareWithoutModelId(lhs, rhs);\n    }\n    RealityTreeId.compare = compare;\n})(RealityTreeId || (RealityTreeId = {}));\nclass RealityTreeSupplier {\n    constructor() {\n        this.isEcefDependent = true;\n    }\n    getOwner(treeId, iModel) {\n        return iModel.tiles.getTileTreeOwner(treeId, this);\n    }\n    async createTileTree(treeId, iModel) {\n        if (treeId.maskModelIds)\n            await iModel.models.load(CompressedId64Set.decompressSet(treeId.maskModelIds));\n        const opts = { deduplicateVertices: treeId.deduplicateVertices, produceGeometry: treeId.produceGeometry };\n        return RealityModelTileTree.createRealityModelTileTree(treeId.rdSourceKey, iModel, treeId.modelId, treeId.transform, opts);\n    }\n    compareTileTreeIds(lhs, rhs) {\n        return RealityTreeId.compare(lhs, rhs);\n    }\n    findCompatibleContextRealityModelId(id, style) {\n        const owners = style.iModel.tiles.getTreeOwnersForSupplier(this);\n        for (const owner of owners) {\n            // Find an existing tree with the same Id, ignoring its model Id.\n            if (0 === RealityTreeId.compareWithoutModelId(id, owner.id)) {\n                const modelId = owner.id.modelId;\n                assert(undefined !== modelId);\n                // If the model Id is unused by any other context reality model in the view and does not identify a persistent reality model, use it.\n                if (Id64.isTransientId64(modelId) && !style.contextRealityModelStates.some((model) => model.modelId === modelId))\n                    return modelId;\n            }\n        }\n        return undefined;\n    }\n}\nconst realityTreeSupplier = new RealityTreeSupplier();\n/** @internal */\nexport function createRealityTileTreeReference(props) {\n    return new RealityTreeReference(props);\n}\nconst zeroPoint = Point3d.createZero();\nconst earthEllipsoid = Ellipsoid.createCenterMatrixRadii(zeroPoint, undefined, Constant.earthRadiusWGS84.equator, Constant.earthRadiusWGS84.equator, Constant.earthRadiusWGS84.polar);\nconst scratchRay = Ray3d.createXAxis();\n/** @internal */\nexport class RealityTileRegion {\n    constructor(values) {\n        this.minLongitude = values.minLongitude;\n        this.minLatitude = values.minLatitude;\n        this.minHeight = values.minHeight;\n        this.maxLongitude = values.maxLongitude;\n        this.maxLatitude = values.maxLatitude;\n        this.maxHeight = values.maxHeight;\n    }\n    static create(region) {\n        const minHeight = region[4];\n        const maxHeight = region[5];\n        const minLongitude = region[0];\n        const maxLongitude = region[2];\n        const minLatitude = Cartographic.parametricLatitudeFromGeodeticLatitude(region[1]);\n        const maxLatitude = Cartographic.parametricLatitudeFromGeodeticLatitude(region[3]);\n        return new RealityTileRegion({ minLongitude, minLatitude, minHeight, maxLongitude, maxLatitude, maxHeight });\n    }\n    static isGlobal(boundingVolume) {\n        return Array.isArray(boundingVolume?.region) && (boundingVolume.region[2] - boundingVolume.region[0]) > Angle.piRadians && (boundingVolume.region[3] - boundingVolume.region[1]) > Angle.piOver2Radians;\n    }\n    getRange() {\n        const maxAngle = Math.max(Math.abs(this.maxLatitude - this.minLatitude), Math.abs(this.maxLongitude - this.minLongitude));\n        let corners;\n        let range;\n        if (maxAngle < Math.PI / 8) {\n            corners = new Array(8);\n            const chordTolerance = (1 - Math.cos(maxAngle / 2)) * Constant.earthRadiusWGS84.polar;\n            const addEllipsoidCorner = ((long, lat, index) => {\n                const ray = earthEllipsoid.radiansToUnitNormalRay(long, lat, scratchRay);\n                corners[index] = ray.fractionToPoint(this.minHeight - chordTolerance);\n                corners[index + 4] = ray.fractionToPoint(this.maxHeight + chordTolerance);\n            });\n            addEllipsoidCorner(this.minLongitude, this.minLatitude, 0);\n            addEllipsoidCorner(this.minLongitude, this.maxLatitude, 1);\n            addEllipsoidCorner(this.maxLongitude, this.minLatitude, 2);\n            addEllipsoidCorner(this.maxLongitude, this.maxLatitude, 3);\n            range = Range3d.createArray(corners);\n        }\n        else {\n            const minEq = Constant.earthRadiusWGS84.equator + this.minHeight, maxEq = Constant.earthRadiusWGS84.equator + this.maxHeight;\n            const minEllipsoid = Ellipsoid.createCenterMatrixRadii(zeroPoint, undefined, minEq, minEq, Constant.earthRadiusWGS84.polar + this.minHeight);\n            const maxEllipsoid = Ellipsoid.createCenterMatrixRadii(zeroPoint, undefined, maxEq, maxEq, Constant.earthRadiusWGS84.polar + this.maxHeight);\n            range = minEllipsoid.patchRangeStartEndRadians(this.minLongitude, this.maxLongitude, this.minLatitude, this.maxLatitude);\n            range.extendRange(maxEllipsoid.patchRangeStartEndRadians(this.minLongitude, this.maxLongitude, this.minLatitude, this.maxLatitude));\n        }\n        return { range, corners };\n    }\n}\n/** @internal */\nexport class RealityModelTileUtils {\n    static rangeFromBoundingVolume(boundingVolume) {\n        if (undefined === boundingVolume)\n            return undefined;\n        let corners;\n        let range;\n        if (undefined !== boundingVolume.box) {\n            const box = boundingVolume.box;\n            const center = Point3d.create(box[0], box[1], box[2]);\n            const ux = Vector3d.create(box[3], box[4], box[5]);\n            const uy = Vector3d.create(box[6], box[7], box[8]);\n            const uz = Vector3d.create(box[9], box[10], box[11]);\n            corners = new Array();\n            for (let j = 0; j < 2; j++) {\n                for (let k = 0; k < 2; k++) {\n                    for (let l = 0; l < 2; l++) {\n                        corners.push(center.plus3Scaled(ux, (j ? -1.0 : 1.0), uy, (k ? -1.0 : 1.0), uz, (l ? -1.0 : 1.0)));\n                    }\n                }\n            }\n            range = Range3d.createArray(corners);\n        }\n        else if (Array.isArray(boundingVolume.sphere)) {\n            const sphere = boundingVolume.sphere;\n            const center = Point3d.create(sphere[0], sphere[1], sphere[2]);\n            const radius = sphere[3];\n            range = Range3d.createXYZXYZ(center.x - radius, center.y - radius, center.z - radius, center.x + radius, center.y + radius, center.z + radius);\n        }\n        else if (Array.isArray(boundingVolume.region)) {\n            const region = RealityTileRegion.create(boundingVolume.region);\n            const regionRange = region.getRange();\n            return { range: regionRange.range, corners: regionRange.corners, region };\n        }\n        return range ? { range, corners } : undefined;\n    }\n    static maximumSizeFromGeometricTolerance(range, geometricError) {\n        const minToleranceRatio = true === IModelApp.renderSystem.isMobile ? IModelApp.tileAdmin.mobileRealityTileMinToleranceRatio : 1.0; // Nominally the error on screen size of a tile.  Increasing generally increases performance (fewer draw calls) at expense of higher load times.\n        // NB: We increase the above minToleranceRatio on mobile devices in order to help avoid pruning too often based on the memory threshold for\n        // pruning currently used by reality tile trees on mobile.\n        return minToleranceRatio * range.diagonal().magnitude() / geometricError;\n    }\n    static transformFromJson(jTrans) {\n        return (jTrans === undefined) ? Transform.createIdentity() : Transform.createOriginAndMatrix(Point3d.create(jTrans[12], jTrans[13], jTrans[14]), Matrix3d.createRowValues(jTrans[0], jTrans[4], jTrans[8], jTrans[1], jTrans[5], jTrans[9], jTrans[2], jTrans[6], jTrans[10]));\n    }\n}\n/** @internal */\nvar SMTextureType;\n(function (SMTextureType) {\n    SMTextureType[SMTextureType[\"None\"] = 0] = \"None\";\n    SMTextureType[SMTextureType[\"Embedded\"] = 1] = \"Embedded\";\n    SMTextureType[SMTextureType[\"Streaming\"] = 2] = \"Streaming\";\n})(SMTextureType || (SMTextureType = {}));\n/** @internal */\nclass RealityModelTileTreeProps {\n    constructor(json, root, rdSource, tilesetToDbTransform, tilesetToEcef) {\n        this.tilesetToEcef = tilesetToEcef;\n        this.doDrapeBackgroundMap = false;\n        this.yAxisUp = false;\n        this.tilesetJson = root;\n        this.rdSource = rdSource;\n        this.location = tilesetToDbTransform;\n        this.doDrapeBackgroundMap = (json.root && json.root.SMMasterHeader && SMTextureType.Streaming === json.root.SMMasterHeader.IsTextured);\n        if (json.asset.gltfUpAxis === undefined || json.asset.gltfUpAxis === \"y\" || json.asset.gltfUpAxis === \"Y\")\n            this.yAxisUp = true;\n    }\n}\nclass RealityModelTileTreeParams {\n    get location() { return this.loader.tree.location; }\n    get yAxisUp() { return this.loader.tree.yAxisUp; }\n    get priority() { return this.loader.priority; }\n    constructor(tileTreeId, iModel, modelId, loader, gcsConverterAvailable, rootToEcef) {\n        this.gcsConverterAvailable = gcsConverterAvailable;\n        this.rootToEcef = rootToEcef;\n        this.is3d = true;\n        this.loader = loader;\n        this.id = tileTreeId;\n        this.modelId = modelId;\n        this.iModel = iModel;\n        const refine = loader.tree.tilesetJson.refine;\n        this.rootTile = new RealityModelTileProps({\n            json: loader.tree.tilesetJson,\n            id: \"\",\n            // If not specified explicitly, additiveRefinement is inherited from parent tile.\n            additiveRefinement: undefined !== refine ? \"ADD\" === refine : undefined,\n            usesGeometricError: loader.tree.rdSource.usesGeometricError,\n        });\n    }\n}\n/** @internal */\nclass RealityModelTileProps {\n    constructor(args) {\n        this.contentId = args.id;\n        this.parent = args.parent;\n        this.transformToRoot = args.transformToRoot;\n        this.additiveRefinement = args.additiveRefinement;\n        const json = args.json;\n        const boundingVolume = RealityModelTileUtils.rangeFromBoundingVolume(json.boundingVolume);\n        if (boundingVolume) {\n            this.range = boundingVolume.range;\n            this.rangeCorners = boundingVolume.corners;\n            this.region = boundingVolume?.region;\n        }\n        else {\n            this.range = Range3d.createNull();\n            assert(false, \"Unbounded tile\");\n        }\n        this.isLeaf = !Array.isArray(json.children) || 0 === json.children.length;\n        const hasContents = undefined !== getUrl(json.content);\n        if (hasContents)\n            this.contentRange = RealityModelTileUtils.rangeFromBoundingVolume(json.content.boundingVolume)?.range;\n        else {\n            // A node without content should probably be selectable even if not additive refinement - But restrict it to that case here\n            // to avoid potential problems with existing reality models, but still avoid overselection in the OSM world building set.\n            if (this.additiveRefinement || args.parent?.additiveRefinement)\n                this.noContentButTerminateOnSelection = true;\n        }\n        this.maximumSize = (this.noContentButTerminateOnSelection || hasContents) ? RealityModelTileUtils.maximumSizeFromGeometricTolerance(Range3d.fromJSON(this.range), json.geometricError) : 0;\n        if (args.usesGeometricError)\n            this.geometricError = json.geometricError;\n    }\n}\n/** @internal */\nclass FindChildResult {\n    constructor(id, json, transformToRoot) {\n        this.id = id;\n        this.json = json;\n        this.transformToRoot = transformToRoot;\n    }\n}\n/** @internal */\nfunction assembleUrl(prefix, url) {\n    if (url.startsWith(\"/\")) {\n        // Relative to base origin, not to parent tile\n        return url.substring(1);\n    }\n    if (url.startsWith(\"./\")) {\n        // Relative to parent tile\n        url = url.substring(2);\n    }\n    else {\n        const prefixParts = prefix.split(\"/\");\n        prefixParts.pop();\n        while (url.startsWith(\"../\")) {\n            prefixParts.pop();\n            url = url.substring(3);\n        }\n        prefixParts.push(\"\");\n        prefix = prefixParts.join(\"/\");\n    }\n    return prefix + url;\n}\n/** @internal */\nfunction addUrlPrefix(subTree, prefix) {\n    if (undefined === subTree)\n        return;\n    if (undefined !== subTree.content) {\n        if (undefined !== subTree.content.url)\n            subTree.content.url = assembleUrl(prefix, subTree.content.url);\n        else if (undefined !== subTree.content.uri)\n            subTree.content.uri = assembleUrl(prefix, subTree.content.uri);\n    }\n    if (undefined !== subTree.children)\n        for (const child of subTree.children)\n            addUrlPrefix(child, prefix);\n}\n/** @internal */\nasync function expandSubTree(root, rdsource) {\n    const childUrl = getUrl(root.content);\n    if (undefined === childUrl || \"tileset\" !== rdsource.getTileContentType(childUrl))\n        return root;\n    const subTree = await rdsource.getTileJson(childUrl);\n    const prefixIndex = childUrl.lastIndexOf(\"/\");\n    if (prefixIndex > 0)\n        addUrlPrefix(subTree.root, childUrl.substring(0, prefixIndex + 1));\n    return subTree.root;\n}\n/** @internal */\nclass RealityModelTileLoader extends RealityTileLoader {\n    constructor(tree, batchedIdMap, opts) {\n        super(opts?.produceGeometry ?? false);\n        this.tree = tree;\n        this._batchedIdMap = batchedIdMap;\n        this._deduplicateVertices = opts?.deduplicateVertices ?? false;\n        let clipVolume;\n        if (RealityTileRegion.isGlobal(tree.tilesetJson.boundingVolume))\n            clipVolume = false;\n        this._viewFlagOverrides = createDefaultViewFlagOverrides({ lighting: true, clipVolume });\n        // Display edges if they are present (Cesium outline extension) and enabled for view.\n        this._viewFlagOverrides.visibleEdges = undefined;\n        this._viewFlagOverrides.hiddenEdges = undefined;\n        // Allow wiremesh display.\n        this._viewFlagOverrides.wiremesh = undefined;\n    }\n    get doDrapeBackgroundMap() { return this.tree.doDrapeBackgroundMap; }\n    get wantDeduplicatedVertices() { return this._deduplicateVertices; }\n    get maxDepth() { return 32; } // Can be removed when element tile selector is working.\n    get minDepth() { return 0; }\n    get priority() { return TileLoadPriority.Context; }\n    getBatchIdMap() { return this._batchedIdMap; }\n    get clipLowResolutionTiles() { return true; }\n    get viewFlagOverrides() { return this._viewFlagOverrides; }\n    get maximumScreenSpaceError() {\n        return this.tree.rdSource.maximumScreenSpaceError;\n    }\n    async loadChildren(tile) {\n        const props = await this.getChildrenProps(tile);\n        if (undefined === props)\n            return undefined;\n        const children = [];\n        for (const prop of props)\n            children.push(tile.realityRoot.createTile(prop));\n        return children;\n    }\n    async getChildrenProps(parent) {\n        const props = [];\n        const thisId = parent.contentId;\n        const prefix = thisId.length ? `${thisId}_` : \"\";\n        const findResult = await this.findTileInJson(this.tree.tilesetJson, thisId, \"\", undefined);\n        if (undefined !== findResult && Array.isArray(findResult.json.children)) {\n            for (let i = 0; i < findResult.json.children.length; i++) {\n                const childId = prefix + i;\n                const foundChild = await this.findTileInJson(this.tree.tilesetJson, childId, \"\", undefined);\n                if (undefined !== foundChild) {\n                    const refine = foundChild.json.refine;\n                    props.push(new RealityModelTileProps({\n                        json: foundChild.json,\n                        parent,\n                        id: foundChild.id,\n                        transformToRoot: foundChild.transformToRoot,\n                        // If not specified explicitly, additiveRefinement is inherited from parent tile.\n                        additiveRefinement: undefined !== refine ? refine === \"ADD\" : undefined,\n                        usesGeometricError: this.tree.rdSource.usesGeometricError,\n                    }));\n                }\n            }\n        }\n        return props;\n    }\n    getRequestChannel(_tile) {\n        // ###TODO: May want to extract the hostname from the URL.\n        return IModelApp.tileAdmin.channels.getForHttp(\"itwinjs-reality-model\");\n    }\n    async requestTileContent(tile, isCanceled) {\n        const foundChild = await this.findTileInJson(this.tree.tilesetJson, tile.contentId, \"\");\n        if (undefined === foundChild || undefined === foundChild.json.content || isCanceled())\n            return undefined;\n        return this.tree.rdSource.getTileContent(getUrl(foundChild.json.content));\n    }\n    async findTileInJson(tilesetJson, id, parentId, transformToRoot) {\n        if (id.length === 0)\n            return new FindChildResult(id, tilesetJson, transformToRoot); // Root.\n        const separatorIndex = id.indexOf(\"_\");\n        const childId = (separatorIndex < 0) ? id : id.substring(0, separatorIndex);\n        const childIndex = parseInt(childId, 10);\n        if (isNaN(childIndex) || tilesetJson === undefined || tilesetJson.children === undefined || childIndex >= tilesetJson.children.length) {\n            assert(false, \"scalable mesh child not found.\");\n            return undefined;\n        }\n        const foundChild = tilesetJson.children[childIndex];\n        const thisParentId = parentId.length ? (`${parentId}_${childId}`) : childId;\n        if (foundChild.transform) {\n            const thisTransform = RealityModelTileUtils.transformFromJson(foundChild.transform);\n            transformToRoot = transformToRoot ? transformToRoot.multiplyTransformTransform(thisTransform) : thisTransform;\n        }\n        if (separatorIndex >= 0) {\n            return this.findTileInJson(foundChild, id.substring(separatorIndex + 1), thisParentId, transformToRoot);\n        }\n        tilesetJson.children[childIndex] = await expandSubTree(foundChild, this.tree.rdSource);\n        return new FindChildResult(thisParentId, tilesetJson.children[childIndex], transformToRoot);\n    }\n}\n/** @internal */\nexport class RealityModelTileTree extends RealityTileTree {\n    constructor(params) {\n        super(params);\n        this._isContentUnbounded = this.rootTile.contentRange.diagonal().magnitude() > 2 * Constant.earthRadiusWGS84.equator;\n        if (!this.isContentUnbounded && !this.rootTile.contentRange.isNull) {\n            const worldContentRange = this.iModelTransform.multiplyRange(this.rootTile.contentRange);\n            /* eslint-disable-next-line deprecation/deprecation */\n            this.iModel.expandDisplayedExtents(worldContentRange);\n        }\n    }\n    get isContentUnbounded() { return this._isContentUnbounded; }\n}\n/** @internal */\n// eslint-disable-next-line no-redeclare\n(function (RealityModelTileTree) {\n    class Reference extends TileTreeReference {\n        // public get classifiers(): SpatialClassifiers | undefined { return undefined !== this._classifier ? this._classifier.classifiers : undefined; }\n        get planarClipMask() { return this._planarClipMask; }\n        set planarClipMask(planarClipMask) { this._planarClipMask = planarClipMask; }\n        get planarClipMaskPriority() {\n            if (this._planarClipMask?.settings.priority !== undefined)\n                return this._planarClipMask.settings.priority;\n            return this.isGlobal ? PlanarClipMaskPriority.GlobalRealityModel : PlanarClipMaskPriority.RealityModel;\n        }\n        get maskModelIds() {\n            return this._planarClipMask?.settings.compressedModelIds;\n        }\n        constructor(props) {\n            super();\n            this._name = undefined !== props.name ? props.name : \"\";\n            let transform;\n            if (undefined !== props.tilesetToDbTransform) {\n                const tf = Transform.fromJSON(props.tilesetToDbTransform);\n                if (!tf.isIdentity)\n                    transform = tf;\n                this._transform = transform;\n            }\n            this._iModel = props.iModel;\n            this._source = props.source;\n            this._getDisplaySettings = () => props.getDisplaySettings();\n            if (props.planarClipMask)\n                this._planarClipMask = PlanarClipMaskState.create(props.planarClipMask);\n            if (undefined !== props.classifiers)\n                this._classifier = createClassifierTileTreeReference(props.classifiers, this, props.iModel, props.source);\n        }\n        get planarClassifierTreeRef() { return this._classifier && this._classifier.activeClassifier && this._classifier.isPlanar ? this._classifier : undefined; }\n        unionFitRange(union) {\n            const contentRange = this.computeWorldContentRange();\n            if (!contentRange.isNull && contentRange.diagonal().magnitude() < Constant.earthRadiusWGS84.equator)\n                union.extendRange(contentRange);\n        }\n        get isGlobal() {\n            if (undefined === this._isGlobal) {\n                const range = this.computeWorldContentRange();\n                if (!range.isNull)\n                    this._isGlobal = range.diagonal().magnitude() > 2 * Constant.earthRadiusWGS84.equator;\n            }\n            return this._isGlobal === undefined ? false : this._isGlobal;\n        }\n        addToScene(context) {\n            // NB: The classifier must be added first, so we can find it when adding our own tiles.\n            if (this._classifier && this._classifier.activeClassifier)\n                this._classifier.addToScene(context);\n            this.addPlanarClassifierOrMaskToScene(context);\n            super.addToScene(context);\n        }\n        addPlanarClassifierOrMaskToScene(context) {\n            // A planarClassifier is required if there is a classification tree OR planar masking is required.\n            const classifierTree = this.planarClassifierTreeRef;\n            const planarClipMask = this._planarClipMask ?? context.viewport.displayStyle.getPlanarClipMaskState(this.modelId);\n            if (!classifierTree && !planarClipMask)\n                return;\n            if (classifierTree && !classifierTree.treeOwner.load())\n                return;\n            context.addPlanarClassifier(this.modelId, classifierTree, planarClipMask);\n        }\n        discloseTileTrees(trees) {\n            super.discloseTileTrees(trees);\n            if (undefined !== this._classifier)\n                this._classifier.discloseTileTrees(trees);\n            if (undefined !== this._mapDrapeTree)\n                this._mapDrapeTree.discloseTileTrees(trees);\n            if (undefined !== this._planarClipMask)\n                this._planarClipMask.discloseTileTrees(trees);\n        }\n        collectStatistics(stats) {\n            super.collectStatistics(stats);\n            const tree = undefined !== this._classifier ? this._classifier.treeOwner.tileTree : undefined;\n            if (undefined !== tree)\n                tree.collectStatistics(stats);\n        }\n        createDrawArgs(context) {\n            const args = super.createDrawArgs(context);\n            if (args) {\n                args.graphics.realityModelDisplaySettings = this._getDisplaySettings();\n                args.graphics.realityModelRange = args.tree.rootTile.contentRange;\n                if (args.tree instanceof RealityTileTree) {\n                    const maxSSE = args.tree.loader.maximumScreenSpaceError;\n                    if (undefined !== maxSSE)\n                        args.maximumScreenSpaceError = maxSSE;\n                }\n            }\n            return args;\n        }\n    }\n    RealityModelTileTree.Reference = Reference;\n    async function createRealityModelTileTree(rdSourceKey, iModel, modelId, tilesetToDb, opts) {\n        const rdSource = await RealityDataSource.fromKey(rdSourceKey, iModel.iTwinId);\n        // If we can get a valid connection from sourceKey, returns the tile tree\n        if (rdSource) {\n            // Serialize the reality data source key into a string to uniquely identify this tile tree\n            const tileTreeId = rdSource.key.toString();\n            if (tileTreeId === undefined)\n                return undefined;\n            const props = await getTileTreeProps(rdSource, tilesetToDb, iModel);\n            const loader = new RealityModelTileLoader(props, new BatchedTileIdMap(iModel), opts);\n            const gcsConverterAvailable = await getGcsConverterAvailable(iModel);\n            const params = new RealityModelTileTreeParams(tileTreeId, iModel, modelId, loader, gcsConverterAvailable, props.tilesetToEcef);\n            return new RealityModelTileTree(params);\n        }\n        return undefined;\n    }\n    RealityModelTileTree.createRealityModelTileTree = createRealityModelTileTree;\n    async function getTileTreeProps(rdSource, tilesetToDbJson, iModel) {\n        const json = await rdSource.getRootDocument(iModel.iTwinId);\n        let rootTransform = iModel.ecefLocation ? iModel.getMapEcefToDb(0) : Transform.createIdentity();\n        const geoConverter = iModel.noGcsDefined ? undefined : iModel.geoServices.getConverter(\"WGS84\");\n        if (geoConverter !== undefined) {\n            let realityTileRange = RealityModelTileUtils.rangeFromBoundingVolume(json.root.boundingVolume).range;\n            if (json.root.transform) {\n                const realityToEcef = RealityModelTileUtils.transformFromJson(json.root.transform);\n                realityTileRange = realityToEcef.multiplyRange(realityTileRange);\n            }\n            if (iModel.ecefLocation) {\n                // In initial publishing version the iModel ecef Transform was used to locate the reality model.\n                // This would work well only for tilesets published from that iModel but for iModels the ecef transform is calculated\n                // at the center of the project extents and the reality model location may differ greatly, and the curvature of the earth\n                // could introduce significant errors.\n                // The publishing was modified to calculate the ecef transform at the reality model range center and at the same time the \"iModelPublishVersion\"\n                // member was added to the root object.  In order to continue to locate reality models published from older versions at the\n                // project extents center we look for Tileset version 0.0 and no root.iModelVersion.\n                const ecefOrigin = realityTileRange.localXYZToWorld(.5, .5, .5);\n                const dbOrigin = rootTransform.multiplyPoint3d(ecefOrigin);\n                const realityOriginToProjectDistance = iModel.projectExtents.distanceToPoint(dbOrigin);\n                const maxProjectDistance = 1E5; // Only use the project GCS projection if within 100KM of the project.   Don't attempt to use GCS if global reality model or in another locale - Results will be unreliable.\n                if (realityOriginToProjectDistance < maxProjectDistance && json.asset?.version !== \"0.0\" || undefined !== json.root?.iModelPublishVersion) {\n                    const cartographicOrigin = Cartographic.fromEcef(ecefOrigin);\n                    if (cartographicOrigin !== undefined) {\n                        const geoOrigin = Point3d.create(cartographicOrigin.longitudeDegrees, cartographicOrigin.latitudeDegrees, cartographicOrigin.height);\n                        const response = await geoConverter.getIModelCoordinatesFromGeoCoordinates([geoOrigin]);\n                        if (response.iModelCoords[0].s === GeoCoordStatus.Success) {\n                            const ecefToDb = await calculateEcefToDbTransformAtLocation(Point3d.fromJSON(response.iModelCoords[0].p), iModel);\n                            if (ecefToDb)\n                                rootTransform = ecefToDb;\n                        }\n                    }\n                }\n            }\n        }\n        let tilesetToEcef = Transform.createIdentity();\n        if (json.root.transform) {\n            tilesetToEcef = RealityModelTileUtils.transformFromJson(json.root.transform);\n            rootTransform = rootTransform.multiplyTransformTransform(tilesetToEcef);\n        }\n        if (undefined !== tilesetToDbJson)\n            rootTransform = Transform.fromJSON(tilesetToDbJson).multiplyTransformTransform(rootTransform);\n        const root = await expandSubTree(json.root, rdSource);\n        return new RealityModelTileTreeProps(json, root, rdSource, rootTransform, tilesetToEcef);\n    }\n})(RealityModelTileTree || (RealityModelTileTree = {}));\n/** Supplies a reality data [[TileTree]] from a URL. May be associated with a persistent [[GeometricModelState]], or attached at run-time via a [[ContextRealityModelState]].\n * @internal\n */\nexport class RealityTreeReference extends RealityModelTileTree.Reference {\n    constructor(props) {\n        super(props);\n        this._produceGeometry = props.produceGeometry;\n        // Maybe we should throw if both props.rdSourceKey && props.url are undefined\n        if (props.rdSourceKey)\n            this._rdSourceKey = props.rdSourceKey;\n        else\n            this._rdSourceKey = RealityDataSource.createKeyFromUrl(props.url ?? \"\", RealityDataProvider.ContextShare);\n        if (this._produceGeometry)\n            this.collectTileGeometry = (collector) => this._collectTileGeometry(collector);\n        let modelId = props.modelId;\n        if (undefined === modelId && this._source instanceof DisplayStyleState) {\n            const treeId = this.createTreeId(Id64.invalid);\n            modelId = realityTreeSupplier.findCompatibleContextRealityModelId(treeId, this._source);\n        }\n        this._modelId = modelId ?? props.iModel.transientIds.getNext();\n    }\n    get modelId() { return this._modelId; }\n    createTreeId(modelId) {\n        return {\n            rdSourceKey: this._rdSourceKey,\n            transform: this._transform,\n            modelId,\n            maskModelIds: this.maskModelIds,\n            deduplicateVertices: this._wantWiremesh,\n            produceGeometry: this._produceGeometry,\n        };\n    }\n    get treeOwner() {\n        return realityTreeSupplier.getOwner(this.createTreeId(this.modelId), this._iModel);\n    }\n    _createGeometryTreeReference() {\n        const ref = new RealityTreeReference({\n            iModel: this._iModel,\n            modelId: this.modelId,\n            source: this._source,\n            rdSourceKey: this._rdSourceKey,\n            name: this._name,\n            produceGeometry: true,\n            getDisplaySettings: () => RealityModelDisplaySettings.defaults,\n        });\n        assert(undefined !== ref.collectTileGeometry);\n        return ref;\n    }\n    get _wantWiremesh() {\n        return this._source.viewFlags.wiremesh;\n    }\n    get castsShadows() {\n        return true;\n    }\n    get _isLoadingComplete() {\n        return !this._mapDrapeTree || this._mapDrapeTree.isLoadingComplete;\n    }\n    createDrawArgs(context) {\n        // For global reality models (OSM Building layer only) - offset the reality model by the BIM elevation bias.  This would not be necessary\n        // if iModels had their elevation set correctly but unfortunately many GCS erroneously report Sea (Geoid) elevation rather than\n        // Geodetic.\n        const tree = this.treeOwner.load();\n        if (undefined === tree)\n            return undefined;\n        const drawArgs = super.createDrawArgs(context);\n        if (drawArgs !== undefined && this._iModel.isGeoLocated && tree.isContentUnbounded) {\n            const elevationBias = context.viewport.view.displayStyle.backgroundMapElevationBias;\n            if (undefined !== elevationBias)\n                drawArgs.location.origin.z -= elevationBias;\n        }\n        return drawArgs;\n    }\n    addToScene(context) {\n        const tree = this.treeOwner.tileTree;\n        if (undefined !== tree && context.viewport.iModel.isGeoLocated && tree.loader.doDrapeBackgroundMap) {\n            // NB: We save this off strictly so that discloseTileTrees() can find it...better option?\n            this._mapDrapeTree = context.viewport.backgroundDrapeMap;\n            context.addBackgroundDrapedModel(this, undefined);\n        }\n        super.addToScene(context);\n    }\n    async getToolTip(hit) {\n        const tree = this.treeOwner.tileTree;\n        if (undefined === tree || hit.iModel !== tree.iModel)\n            return undefined;\n        const map = tree.loader.getBatchIdMap();\n        const batch = undefined !== map ? map.getBatchProperties(hit.sourceId) : undefined;\n        if (undefined === batch && tree.modelId !== hit.sourceId)\n            return undefined;\n        const strings = [];\n        const loader = tree.loader;\n        const type = loader.tree.rdSource.realityDataType;\n        // If a type is specified, display it\n        if (type !== undefined) {\n            // Case insensitive\n            switch (type.toUpperCase()) {\n                case DefaultSupportedTypes.RealityMesh3dTiles.toUpperCase():\n                    strings.push(IModelApp.localization.getLocalizedString(\"iModelJs:RealityModelTypes.RealityMesh3DTiles\"));\n                    break;\n                case DefaultSupportedTypes.Terrain3dTiles.toUpperCase():\n                    strings.push(IModelApp.localization.getLocalizedString(\"iModelJs:RealityModelTypes.Terrain3DTiles\"));\n                    break;\n                case DefaultSupportedTypes.Cesium3dTiles.toUpperCase():\n                    strings.push(IModelApp.localization.getLocalizedString(\"iModelJs:RealityModelTypes.Cesium3DTiles\"));\n                    break;\n            }\n        }\n        if (this._name) {\n            strings.push(`${IModelApp.localization.getLocalizedString(\"iModelJs:TooltipInfo.Name\")} ${this._name}`);\n        }\n        else {\n            const cesiumAsset = this._rdSourceKey.provider === RealityDataProvider.CesiumIonAsset ? CesiumIonAssetProvider.parseCesiumUrl(this._rdSourceKey.id) : undefined;\n            strings.push(cesiumAsset ? `Cesium Asset: ${cesiumAsset.id}` : this._rdSourceKey.id);\n        }\n        if (batch !== undefined)\n            for (const key of Object.keys(batch))\n                if (-1 === key.indexOf(\"#\")) // Avoid internal cesium\n                    strings.push(`${key}: ${batch[key]}`);\n        const div = document.createElement(\"div\");\n        div.innerHTML = strings.join(\"<br>\");\n        return div;\n    }\n    addLogoCards(cards) {\n        if (this._rdSourceKey.provider === RealityDataProvider.CesiumIonAsset && !cards.dataset.openStreetMapLogoCard) {\n            cards.dataset.openStreetMapLogoCard = \"true\";\n            cards.appendChild(IModelApp.makeLogoCard({ heading: \"OpenStreetMap\", notice: `&copy;<a href=\\\"https://www.openstreetmap.org/copyright\\\">OpenStreetMap</a> ${IModelApp.localization.getLocalizedString(\"iModelJs:BackgroundMap:OpenStreetMapContributors\")}` }));\n        }\n    }\n}\n//# sourceMappingURL=RealityModelTileTree.js.map",
      "start": 1693508121896,
      "end": 1693508122039,
      "sourcemaps": null
    }
  ]
}
