{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/i18n/lib/esm/ITwinLocalization.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Localization\n */\nimport i18next from \"i18next\";\nimport i18nextBrowserLanguageDetector from \"i18next-browser-languagedetector\";\nimport Backend from \"i18next-http-backend\";\nimport { Logger } from \"@itwin/core-bentley\";\nconst DEFAULT_MAX_RETRIES = 1; // a low number prevents wasted time and potential timeouts when requesting localization files throws an error\n/** Supplies localizations for iTwin.js\n * @note this class uses the [i18next](https://www.i18next.com/) package.\n * @public\n */\nexport class ITwinLocalization {\n    constructor(options) {\n        this._namespaces = new Map();\n        this.i18next = i18next.createInstance();\n        this._backendOptions = {\n            loadPath: options?.urlTemplate ?? \"locales/{{lng}}/{{ns}}.json\",\n            crossDomain: true,\n            ...options?.backendHttpOptions,\n        };\n        this._detectionOptions = {\n            order: [\"querystring\", \"navigator\", \"htmlTag\"],\n            lookupQuerystring: \"lng\",\n            caches: [],\n            ...options?.detectorOptions,\n        };\n        this._initOptions = {\n            interpolation: { escapeValue: true },\n            fallbackLng: \"en\",\n            maxRetries: DEFAULT_MAX_RETRIES,\n            backend: this._backendOptions,\n            detection: this._detectionOptions,\n            ...options?.initOptions,\n        };\n        this.i18next\n            .use(options?.detectorPlugin ?? i18nextBrowserLanguageDetector)\n            .use(options?.backendPlugin ?? Backend)\n            .use(TranslationLogger);\n    }\n    async initialize(namespaces) {\n        // Also consider namespaces passed into constructor\n        const initNamespaces = [this._initOptions.ns || []].flat();\n        const combinedNamespaces = new Set([...namespaces, ...initNamespaces]); // without duplicates\n        const defaultNamespace = this._initOptions.defaultNS ?? namespaces[0];\n        if (defaultNamespace)\n            combinedNamespaces.add(defaultNamespace); // Make sure default namespace is in namespaces list\n        const initOptions = {\n            ...this._initOptions,\n            defaultNS: defaultNamespace,\n            ns: [...combinedNamespaces],\n        };\n        // if in a development environment, set debugging\n        if (process.env.NODE_ENV === \"development\")\n            initOptions.debug = true;\n        const initPromise = this.i18next.init(initOptions);\n        for (const ns of namespaces)\n            this._namespaces.set(ns, initPromise);\n        return initPromise;\n    }\n    /** Replace all instances of `%{key}` within a string with the translations of those keys.\n     * For example:\n     * ``` ts\n     * \"MyKeys\": {\n     *   \"Key1\": \"First value\",\n     *   \"Key2\": \"Second value\"\n     *  }\n     * ```\n     *\n     * ``` ts\n     * i18.translateKeys(\"string with %{MyKeys.Key1} followed by %{MyKeys.Key2}!\"\") // returns \"string with First Value followed by Second Value!\"\n     * ```\n     * @param line The input line, potentially containing %{keys}.\n     * @returns The line with all %{keys} translated\n     * @public\n     */\n    getLocalizedKeys(line) {\n        return line.replace(/\\%\\{(.+?)\\}/g, (_match, tag) => this.getLocalizedString(tag));\n    }\n    /** Return the translated value of a key.\n     * @param key - the key that matches a property in the JSON localization file.\n     * @note The key includes the namespace, which identifies the particular localization file that contains the property,\n     * followed by a colon, followed by the property in the JSON file.\n     * For example:\n     * ``` ts\n     * const dataString: string = IModelApp.localization.getLocalizedString(\"iModelJs:BackgroundMap.BingDataAttribution\");\n     *  ```\n     * assigns to dataString the string with property BackgroundMap.BingDataAttribution from the iModelJs.json localization file.\n     * @returns The string corresponding to the first key that resolves.\n     * @throws Error if no keys resolve to a string.\n     * @public\n     */\n    getLocalizedString(key, options) {\n        if (options?.returnDetails || options?.returnObjects) {\n            throw new Error(\"Translation key must map to a string, but the given options will result in an object\");\n        }\n        const value = this.i18next.t(key, options);\n        if (typeof value !== \"string\") {\n            throw new Error(\"Translation key(s) string not found\");\n        }\n        return value;\n    }\n    /** Similar to `getLocalizedString` but the default namespace is a separate parameter and the key does not need\n     * to include a namespace. If a key includes a namespace, that namespace will be used for interpolating that key.\n     * @param namespace - the namespace that identifies the particular localization file that contains the property.\n     * @param key - the key that matches a property in the JSON localization file.\n     * @returns The string corresponding to the first key that resolves.\n     * @throws Error if no keys resolve to a string.\n     * @internal\n     */\n    getLocalizedStringWithNamespace(namespace, key, options) {\n        let fullKey = \"\";\n        if (typeof key === \"string\") {\n            fullKey = `${namespace}:${key}`;\n        }\n        else {\n            fullKey = key.map((subKey) => {\n                return `${namespace}:${subKey}`;\n            });\n        }\n        return this.getLocalizedString(fullKey, options);\n    }\n    /** Gets the English translation.\n     * @param namespace - the namespace that identifies the particular localization file that contains the property.\n     * @param key - the key that matches a property in the JSON localization file.\n     * @returns The string corresponding to the first key that resolves.\n     * @throws Error if no keys resolve to a string.\n     * @internal\n     */\n    getEnglishString(namespace, key, options) {\n        if (options?.returnDetails || options?.returnObjects) {\n            throw new Error(\"Translation key must map to a string, but the given options will result in an object\");\n        }\n        options = {\n            ...options,\n            ns: namespace, // ensure namespace argument is used\n        };\n        const en = this.i18next.getFixedT(\"en\", namespace);\n        const str = en(key, options);\n        if (typeof str !== \"string\")\n            throw new Error(\"Translation key(s) not found\");\n        return str;\n    }\n    /** Get the promise for an already registered Namespace.\n     * @param name - the name of the namespace\n     * @public\n     */\n    getNamespacePromise(name) {\n        return this._namespaces.get(name);\n    }\n    /** @internal */\n    getLanguageList() {\n        return this.i18next.languages;\n    }\n    /** override the language detected in the browser  */\n    async changeLanguage(language) {\n        return this.i18next.changeLanguage(language);\n    }\n    /** Register a new Namespace and return it. If the namespace is already registered, it will be returned.\n     * @param name - the name of the namespace, which is the base name of the JSON file that contains the localization properties.\n     * @note - The registerNamespace method starts fetching the appropriate version of the JSON localization file from the server,\n     * based on the current locale. To make sure that fetch is complete before performing translations from this namespace, await\n     * fulfillment of the readPromise Promise property of the returned LocalizationNamespace.\n     * @see [Localization in iTwin.js]($docs/learning/frontend/Localization.md)\n     * @public\n     */\n    async registerNamespace(name) {\n        const existing = this._namespaces.get(name);\n        if (existing !== undefined)\n            return existing;\n        const theReadPromise = new Promise((resolve) => {\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            this.i18next.loadNamespaces(name, (err) => {\n                if (!err)\n                    return resolve();\n                // Here we got a non-null err object.\n                // This method is called when the system has attempted to load the resources for the namespaces for each possible locale.\n                // For example 'fr-ca' might be the most specific locale, in which case 'fr' and 'en' are fallback locales.\n                // Using Backend from i18next-http-backend, err will be an array of strings of each namespace it tried to read and its locale.\n                // There might be errs for some other namespaces as well as this one. We resolve the promise unless there's an error for each possible locale.\n                let locales = this.getLanguageList().map((thisLocale) => `/${thisLocale}/`);\n                try {\n                    for (const thisError of err) {\n                        if (typeof thisError === \"string\")\n                            locales = locales.filter((thisLocale) => !thisError.includes(thisLocale));\n                    }\n                }\n                catch (e) {\n                    locales = [];\n                }\n                // if we removed every locale from the array, it wasn't loaded.\n                if (locales.length === 0)\n                    Logger.logError(\"i18n\", `No resources for namespace ${name} could be loaded`);\n                resolve();\n            });\n        });\n        this._namespaces.set(name, theReadPromise);\n        return theReadPromise;\n    }\n    /** @internal */\n    unregisterNamespace(name) {\n        this._namespaces.delete(name);\n    }\n}\nclass TranslationLogger {\n    log(args) { Logger.logInfo(\"i18n\", this.createLogMessage(args)); }\n    warn(args) { Logger.logWarning(\"i18n\", this.createLogMessage(args)); }\n    error(args) { Logger.logError(\"i18n\", this.createLogMessage(args)); }\n    createLogMessage(args) {\n        let message = args[0];\n        for (let i = 1; i < args.length; ++i) {\n            if (typeof args[i] === \"string\")\n                message += `\\n  ${args[i]}`;\n        }\n        return message;\n    }\n}\nTranslationLogger.type = \"logger\";\n//# sourceMappingURL=ITwinLocalization.js.map",
      "start": 1693508124559,
      "end": 1693508124618,
      "sourcemaps": null
    },
    {
      "name": "vite:define",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Localization\n */\nimport i18next from \"i18next\";\nimport i18nextBrowserLanguageDetector from \"i18next-browser-languagedetector\";\nimport Backend from \"i18next-http-backend\";\nimport { Logger } from \"@itwin/core-bentley\";\nconst DEFAULT_MAX_RETRIES = 1; // a low number prevents wasted time and potential timeouts when requesting localization files throws an error\n/** Supplies localizations for iTwin.js\n * @note this class uses the [i18next](https://www.i18next.com/) package.\n * @public\n */\nexport class ITwinLocalization {\n    constructor(options) {\n        this._namespaces = new Map();\n        this.i18next = i18next.createInstance();\n        this._backendOptions = {\n            loadPath: options?.urlTemplate ?? \"locales/{{lng}}/{{ns}}.json\",\n            crossDomain: true,\n            ...options?.backendHttpOptions,\n        };\n        this._detectionOptions = {\n            order: [\"querystring\", \"navigator\", \"htmlTag\"],\n            lookupQuerystring: \"lng\",\n            caches: [],\n            ...options?.detectorOptions,\n        };\n        this._initOptions = {\n            interpolation: { escapeValue: true },\n            fallbackLng: \"en\",\n            maxRetries: DEFAULT_MAX_RETRIES,\n            backend: this._backendOptions,\n            detection: this._detectionOptions,\n            ...options?.initOptions,\n        };\n        this.i18next\n            .use(options?.detectorPlugin ?? i18nextBrowserLanguageDetector)\n            .use(options?.backendPlugin ?? Backend)\n            .use(TranslationLogger);\n    }\n    async initialize(namespaces) {\n        // Also consider namespaces passed into constructor\n        const initNamespaces = [this._initOptions.ns || []].flat();\n        const combinedNamespaces = new Set([...namespaces, ...initNamespaces]); // without duplicates\n        const defaultNamespace = this._initOptions.defaultNS ?? namespaces[0];\n        if (defaultNamespace)\n            combinedNamespaces.add(defaultNamespace); // Make sure default namespace is in namespaces list\n        const initOptions = {\n            ...this._initOptions,\n            defaultNS: defaultNamespace,\n            ns: [...combinedNamespaces],\n        };\n        // if in a development environment, set debugging\n        if (\"development\" === \"development\")\n            initOptions.debug = true;\n        const initPromise = this.i18next.init(initOptions);\n        for (const ns of namespaces)\n            this._namespaces.set(ns, initPromise);\n        return initPromise;\n    }\n    /** Replace all instances of `%{key}` within a string with the translations of those keys.\n     * For example:\n     * ``` ts\n     * \"MyKeys\": {\n     *   \"Key1\": \"First value\",\n     *   \"Key2\": \"Second value\"\n     *  }\n     * ```\n     *\n     * ``` ts\n     * i18.translateKeys(\"string with %{MyKeys.Key1} followed by %{MyKeys.Key2}!\"\") // returns \"string with First Value followed by Second Value!\"\n     * ```\n     * @param line The input line, potentially containing %{keys}.\n     * @returns The line with all %{keys} translated\n     * @public\n     */\n    getLocalizedKeys(line) {\n        return line.replace(/\\%\\{(.+?)\\}/g, (_match, tag) => this.getLocalizedString(tag));\n    }\n    /** Return the translated value of a key.\n     * @param key - the key that matches a property in the JSON localization file.\n     * @note The key includes the namespace, which identifies the particular localization file that contains the property,\n     * followed by a colon, followed by the property in the JSON file.\n     * For example:\n     * ``` ts\n     * const dataString: string = IModelApp.localization.getLocalizedString(\"iModelJs:BackgroundMap.BingDataAttribution\");\n     *  ```\n     * assigns to dataString the string with property BackgroundMap.BingDataAttribution from the iModelJs.json localization file.\n     * @returns The string corresponding to the first key that resolves.\n     * @throws Error if no keys resolve to a string.\n     * @public\n     */\n    getLocalizedString(key, options) {\n        if (options?.returnDetails || options?.returnObjects) {\n            throw new Error(\"Translation key must map to a string, but the given options will result in an object\");\n        }\n        const value = this.i18next.t(key, options);\n        if (typeof value !== \"string\") {\n            throw new Error(\"Translation key(s) string not found\");\n        }\n        return value;\n    }\n    /** Similar to `getLocalizedString` but the default namespace is a separate parameter and the key does not need\n     * to include a namespace. If a key includes a namespace, that namespace will be used for interpolating that key.\n     * @param namespace - the namespace that identifies the particular localization file that contains the property.\n     * @param key - the key that matches a property in the JSON localization file.\n     * @returns The string corresponding to the first key that resolves.\n     * @throws Error if no keys resolve to a string.\n     * @internal\n     */\n    getLocalizedStringWithNamespace(namespace, key, options) {\n        let fullKey = \"\";\n        if (typeof key === \"string\") {\n            fullKey = `${namespace}:${key}`;\n        }\n        else {\n            fullKey = key.map((subKey) => {\n                return `${namespace}:${subKey}`;\n            });\n        }\n        return this.getLocalizedString(fullKey, options);\n    }\n    /** Gets the English translation.\n     * @param namespace - the namespace that identifies the particular localization file that contains the property.\n     * @param key - the key that matches a property in the JSON localization file.\n     * @returns The string corresponding to the first key that resolves.\n     * @throws Error if no keys resolve to a string.\n     * @internal\n     */\n    getEnglishString(namespace, key, options) {\n        if (options?.returnDetails || options?.returnObjects) {\n            throw new Error(\"Translation key must map to a string, but the given options will result in an object\");\n        }\n        options = {\n            ...options,\n            ns: namespace, // ensure namespace argument is used\n        };\n        const en = this.i18next.getFixedT(\"en\", namespace);\n        const str = en(key, options);\n        if (typeof str !== \"string\")\n            throw new Error(\"Translation key(s) not found\");\n        return str;\n    }\n    /** Get the promise for an already registered Namespace.\n     * @param name - the name of the namespace\n     * @public\n     */\n    getNamespacePromise(name) {\n        return this._namespaces.get(name);\n    }\n    /** @internal */\n    getLanguageList() {\n        return this.i18next.languages;\n    }\n    /** override the language detected in the browser  */\n    async changeLanguage(language) {\n        return this.i18next.changeLanguage(language);\n    }\n    /** Register a new Namespace and return it. If the namespace is already registered, it will be returned.\n     * @param name - the name of the namespace, which is the base name of the JSON file that contains the localization properties.\n     * @note - The registerNamespace method starts fetching the appropriate version of the JSON localization file from the server,\n     * based on the current locale. To make sure that fetch is complete before performing translations from this namespace, await\n     * fulfillment of the readPromise Promise property of the returned LocalizationNamespace.\n     * @see [Localization in iTwin.js]($docs/learning/frontend/Localization.md)\n     * @public\n     */\n    async registerNamespace(name) {\n        const existing = this._namespaces.get(name);\n        if (existing !== undefined)\n            return existing;\n        const theReadPromise = new Promise((resolve) => {\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            this.i18next.loadNamespaces(name, (err) => {\n                if (!err)\n                    return resolve();\n                // Here we got a non-null err object.\n                // This method is called when the system has attempted to load the resources for the namespaces for each possible locale.\n                // For example 'fr-ca' might be the most specific locale, in which case 'fr' and 'en' are fallback locales.\n                // Using Backend from i18next-http-backend, err will be an array of strings of each namespace it tried to read and its locale.\n                // There might be errs for some other namespaces as well as this one. We resolve the promise unless there's an error for each possible locale.\n                let locales = this.getLanguageList().map((thisLocale) => `/${thisLocale}/`);\n                try {\n                    for (const thisError of err) {\n                        if (typeof thisError === \"string\")\n                            locales = locales.filter((thisLocale) => !thisError.includes(thisLocale));\n                    }\n                }\n                catch (e) {\n                    locales = [];\n                }\n                // if we removed every locale from the array, it wasn't loaded.\n                if (locales.length === 0)\n                    Logger.logError(\"i18n\", `No resources for namespace ${name} could be loaded`);\n                resolve();\n            });\n        });\n        this._namespaces.set(name, theReadPromise);\n        return theReadPromise;\n    }\n    /** @internal */\n    unregisterNamespace(name) {\n        this._namespaces.delete(name);\n    }\n}\nclass TranslationLogger {\n    log(args) { Logger.logInfo(\"i18n\", this.createLogMessage(args)); }\n    warn(args) { Logger.logWarning(\"i18n\", this.createLogMessage(args)); }\n    error(args) { Logger.logError(\"i18n\", this.createLogMessage(args)); }\n    createLogMessage(args) {\n        let message = args[0];\n        for (let i = 1; i < args.length; ++i) {\n            if (typeof args[i] === \"string\")\n                message += `\\n  ${args[i]}`;\n        }\n        return message;\n    }\n}\nTranslationLogger.type = \"logger\";\n//# sourceMappingURL=ITwinLocalization.js.map",
      "start": 1693508124619,
      "end": 1693508124619,
      "order": "normal",
      "sourcemaps": null
    }
  ]
}
