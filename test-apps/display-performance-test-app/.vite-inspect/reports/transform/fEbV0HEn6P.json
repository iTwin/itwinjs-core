{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/geometry3d/BilinearPatch.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Solid\n */\nimport { CurveAndSurfaceLocationDetail, UVSurfaceLocationDetail } from \"../bspline/SurfaceLocationDetail\";\nimport { CurveLocationDetail } from \"../curve/CurveLocationDetail\";\nimport { Geometry } from \"../Geometry\";\nimport { SmallSystem } from \"../numerics/Polynomials\";\nimport { Plane3dByOriginAndVectors } from \"./Plane3dByOriginAndVectors\";\nimport { Point3d } from \"./Point3dVector3d\";\n// cspell:word uparrow, rightarrow\n/**\n * A bilinear patch is a surface defined by its 4 corner points.\n * * The corner points do not have to be coplanar, but if they are, the quadrilateral should be convex to avoid a self-intersecting surface.\n * ```\n * equation\n * \\begin{matrix}\n * v\\text{-direction}\\\\\n * \\uparrow\\\\\n * \\text{point01} &\\cdots &\\text{A1} &\\cdots &\\text{point11}\\\\\n * \\vdots &&\\vdots &&\\vdots\\\\\n * \\text{B0} &\\cdots &\\text{X} &\\cdots &\\text{B1}\\\\\n * \\vdots &&\\vdots &&\\vdots\\\\\n * \\text{point00} &\\cdots &\\text{A0} &\\cdots &\\text{point10} &\\rightarrow~u\\text{-direction}\n * \\end{matrix}\n * ```\n * * To evaluate the point at (u,v), the following are equivalent:\n *   * interpolate first with u then with v:\n *      * A0 = interpolate between point00 and point10 at fraction u\n *      * A1 = interpolate between point01 and point11 at fraction u\n *      * X = interpolate between A0 and A1 at fraction v\n *   * interpolate first with v then with u:\n *      * B0 = interpolate between point00 and point01 at fraction v\n *      * B1 = interpolate between point10 and point11 at fraction v\n *      * X = interpolate between B0 and B1 at fraction u\n *   * sum all at once:\n *      * X = (1-u)(1-v)point00 + (1-u)(v)point01 + (u)(1-v)point10 + (u)(v)point11\n * @public\n */\nexport class BilinearPatch {\n    /**\n     * Capture (not clone) corners to create a new BilinearPatch.\n     * @param point00 Point at uv=0,0\n     * @param point10 Point at uv=1,0\n     * @param point10 Point at uv=0,1\n     * @param point11 Point at uv=1,1\n     */\n    constructor(point00, point10, point01, point11) {\n        this.point00 = point00;\n        this.point10 = point10;\n        this.point01 = point01;\n        this.point11 = point11;\n    }\n    /**\n     * Clone (not capture) corners to create a new BilinearPatch.\n     * @param point00 Point at uv=0,0\n     * @param point10 Point at uv=1,0\n     * @param point10 Point at uv=0,1\n     * @param point11 Point at uv=1,1\n     */\n    static create(point00, point10, point01, point11) {\n        return new BilinearPatch(point00.clone(), point10.clone(), point01.clone(), point11.clone());\n    }\n    /** Create a patch from xyz values of the 4 corners. */\n    static createXYZ(x00, y00, z00, x10, y10, z10, x01, y01, z01, x11, y11, z11) {\n        return new BilinearPatch(Point3d.create(x00, y00, z00), Point3d.create(x10, y10, z10), Point3d.create(x01, y01, z01), Point3d.create(x11, y11, z11));\n    }\n    /** Return a cloned patch. */\n    clone() {\n        return new BilinearPatch(this.point00.clone(), this.point10.clone(), this.point01.clone(), this.point11.clone());\n    }\n    /** Test equality of the 4 points. */\n    isAlmostEqual(other) {\n        return this.point00.isAlmostEqual(other.point00)\n            && this.point10.isAlmostEqual(other.point10)\n            && this.point01.isAlmostEqual(other.point01)\n            && this.point11.isAlmostEqual(other.point11);\n    }\n    /** Apply the transform to each point. */\n    tryTransformInPlace(transform) {\n        transform.multiplyPoint3d(this.point00, this.point00);\n        transform.multiplyPoint3d(this.point10, this.point10);\n        transform.multiplyPoint3d(this.point01, this.point01);\n        transform.multiplyPoint3d(this.point11, this.point11);\n        return true;\n    }\n    /** Return a cloned and transformed patch. */\n    cloneTransformed(transform) {\n        const result = this.clone();\n        result.tryTransformInPlace(transform);\n        return result;\n    }\n    /** Extend a range by the range of the (optionally transformed) patch. */\n    extendRange(range, transform) {\n        if (transform) {\n            range.extendTransformedPoint(transform, this.point00);\n            range.extendTransformedPoint(transform, this.point10);\n            range.extendTransformedPoint(transform, this.point01);\n            range.extendTransformedPoint(transform, this.point11);\n        }\n        else {\n            range.extendPoint(this.point00);\n            range.extendPoint(this.point10);\n            range.extendPoint(this.point01);\n            range.extendPoint(this.point11);\n        }\n    }\n    /**\n     * Convert fractional u and v coordinates to surface point\n     * @param u fractional coordinate in u direction\n     * @param v fractional coordinate in v direction\n     * @param result optional pre-allocated point\n     */\n    uvFractionToPoint(u, v, result) {\n        const f00 = (1.0 - u) * (1.0 - v);\n        const f10 = u * (1.0 - v);\n        const f01 = (1.0 - u) * v;\n        const f11 = u * v;\n        return Point3d.create(f00 * this.point00.x + f10 * this.point10.x + f01 * this.point01.x + f11 * this.point11.x, f00 * this.point00.y + f10 * this.point10.y + f01 * this.point01.y + f11 * this.point11.y, f00 * this.point00.z + f10 * this.point10.z + f01 * this.point01.z + f11 * this.point11.z, result);\n    }\n    /** Evaluate as a uv surface, returning point and two derivative vectors.\n     * @param u fractional coordinate in u direction\n     * @param v fractional coordinate in v direction\n     * @param result optional pre-allocated carrier for point and vectors\n     */\n    uvFractionToPointAndTangents(u, v, result) {\n        const u0 = 1.0 - u;\n        const v0 = 1.0 - v;\n        const f00 = u0 * v0;\n        const f10 = u * v0;\n        const f01 = u0 * v;\n        const f11 = u * v;\n        return Plane3dByOriginAndVectors.createOriginAndVectorsXYZ(f00 * this.point00.x + f10 * this.point10.x + f01 * this.point01.x + f11 * this.point11.x, f00 * this.point00.y + f10 * this.point10.y + f01 * this.point01.y + f11 * this.point11.y, f00 * this.point00.z + f10 * this.point10.z + f01 * this.point01.z + f11 * this.point11.z, \n        // u derivative ..\n        v0 * (this.point10.x - this.point00.x) + v * (this.point11.x - this.point01.x), v0 * (this.point10.y - this.point00.y) + v * (this.point11.y - this.point01.y), v0 * (this.point10.z - this.point00.z) + v * (this.point11.z - this.point01.z), \n        // v derivative ..\n        u0 * (this.point01.x - this.point00.x) + u * (this.point11.x - this.point10.x), u0 * (this.point01.y - this.point00.y) + u * (this.point11.y - this.point10.y), u0 * (this.point01.z - this.point00.z) + u * (this.point11.z - this.point10.z), result);\n    }\n    /** If data[iB][pivotColumn] is larger in absolute value than data[iA][pivotColumn], then swap rows iA and iB. */\n    static conditionalPivot(pivotColumn, data, iA, iB) {\n        if (Math.abs(data[iB][pivotColumn]) > Math.abs(data[iA][pivotColumn])) {\n            const q = data[iA];\n            data[iA] = data[iB];\n            data[iB] = q;\n        }\n    }\n    /**\n     * Compute the points of intersection with a ray.\n     * @param ray ray in space\n     * @returns 1 or 2 points if there are intersections, undefined if no intersections\n     */\n    intersectRay(ray) {\n        const vectorU = this.point10.minus(this.point00);\n        const vectorV = this.point01.minus(this.point00);\n        const vectorW = this.point11.minus(this.point10);\n        vectorW.subtractInPlace(vectorV);\n        // We seek t, u, v such that:\n        //    `ray.origin + t*ray.direction = point00 + u*vectorU + v*vectorV + u*v*vectorW`\n        // For typical direction as x, the scalar equation with coefficient order for arrays is:\n        //    `0 = -t*ray.direction.x + (point00.x - ray.origin.x) + u*vectorU.x + v*vectorV.x + u*v*vectorW.x`\n        // and this particular equation is invoked to compute t when u and v are known.\n        const coffs = [\n            new Float64Array([-ray.direction.x, this.point00.x - ray.origin.x, vectorU.x, vectorV.x, vectorW.x]),\n            new Float64Array([-ray.direction.y, this.point00.y - ray.origin.y, vectorU.y, vectorV.y, vectorW.y]),\n            new Float64Array([-ray.direction.z, this.point00.z - ray.origin.z, vectorU.z, vectorV.z, vectorW.z]),\n        ];\n        // swap rows so that the equation with largest ray.direction coefficient is first.\n        BilinearPatch.conditionalPivot(0, coffs, 0, 1);\n        BilinearPatch.conditionalPivot(0, coffs, 0, 2);\n        SmallSystem.eliminateFromPivot(coffs[0], 0, coffs[1], -1.0);\n        SmallSystem.eliminateFromPivot(coffs[0], 0, coffs[2], -1.0);\n        const uvArray = SmallSystem.solveBilinearPair(coffs[1][1], coffs[1][2], coffs[1][3], coffs[1][4], coffs[2][1], coffs[2][2], coffs[2][3], coffs[2][4]);\n        if (uvArray) {\n            const result = [];\n            for (const uv of uvArray) {\n                const t = -(coffs[0][1] + coffs[0][2] * uv.x + (coffs[0][3] + coffs[0][4] * uv.x) * uv.y) / coffs[0][0];\n                const point = ray.fractionToPoint(t);\n                result.push(new CurveAndSurfaceLocationDetail(CurveLocationDetail.createRayFractionPoint(ray, t, point), UVSurfaceLocationDetail.createSurfaceUVPoint(this, uv, point)));\n            }\n            return result;\n        }\n        return undefined;\n    }\n    /** Returns the larger of the u-direction edge lengths at v=0 and v=1. */\n    maxUEdgeLength() {\n        return Geometry.maxXY(this.point00.distance(this.point10), this.point01.distance(this.point11));\n    }\n    /** Returns the larger of the v-direction edge lengths at u=0 and u=1. */\n    maxVEdgeLength() {\n        return Geometry.maxXY(this.point00.distance(this.point01), this.point10.distance(this.point11));\n    }\n}\n//# sourceMappingURL=BilinearPatch.js.map",
      "start": 1693508122302,
      "end": 1693508122348,
      "sourcemaps": null
    }
  ]
}
