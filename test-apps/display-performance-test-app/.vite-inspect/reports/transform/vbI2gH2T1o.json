{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/numerics/Complex.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Numerics\n */\nimport { Geometry } from \"../Geometry\";\nimport { Angle } from \"../geometry3d/Angle\";\n/**\n * OPerations on a \"complex number\" class with real part `x` and complex part `y`\n * @internal\n */\nexport class Complex {\n    /** Real part */\n    get x() { return this._x; }\n    set x(value) { this._x = value; }\n    /** Imaginary part */\n    get y() { return this._y; }\n    set y(value) { this._y = value; }\n    constructor(x = 0, y = 0) { this._x = x; this._y = y; }\n    /** set x and y parts from args. */\n    set(x = 0, y = 0) { this.x = x; this.y = y; }\n    /** set `this.x` and `this.y` from `other.x` and `other.y` */\n    setFrom(other) { this.x = other.x; this.y = other.y; }\n    /** clone the complex x,y */\n    clone() { return new Complex(this.x, this.y); }\n    /** test for near equality using coordinate tolerances */\n    isAlmostEqual(other) { return Geometry.isAlmostEqualNumber(this.x, other.x) && Geometry.isAlmostEqualNumber(this.x, other.x); }\n    /** Create a new Complex instance from given x and y. */\n    static create(x = 0, y = 0, result) {\n        if (result) {\n            result.x = x;\n            result.y = y;\n            return result;\n        }\n        return new Complex(x, y);\n    }\n    /** Return the complex sum `this+other` */\n    plus(other, result) { return Complex.create(this.x + other.x, this.y + other.y, result); }\n    /** Return the complex difference  `this-other` */\n    minus(other, result) { return Complex.create(this.x - other.x, this.y - other.y, result); }\n    /** Return the complex product  `this * other` */\n    times(other, result) {\n        return Complex.create(this.x * other.x - this.y * other.y, this.x * other.y + this.y * other.x, result);\n    }\n    /** Return the complex product `this * x+i*y`. That is, the second Complex value exists via the args without being formally created as an instance. */\n    timesXY(x, y, result) {\n        return Complex.create(this.x * x - this.y * y, this.x * y + this.y * x, result);\n    }\n    /** Return the mangitude of the complex number */\n    magnitude() { return Geometry.hypotenuseXY(this.x, this.y); }\n    /** Return the angle from x axis to the vector (x,y) */\n    angle() { return Angle.createAtan2(this.y, this.x); }\n    /** Return the xy plane distance between this and other */\n    distance(other) {\n        return Geometry.hypotenuseXY(this.x - other.x, this.y - other.y);\n    }\n    /** Return the squared xy plane distance between this and other. */\n    magnitudeSquared() { return this.x * this.x + this.y * this.y; }\n    /** Return the complex division `this / other` */\n    divide(other, result) {\n        const bb = other.magnitudeSquared();\n        if (bb === 0.0)\n            return undefined;\n        const divbb = 1.0 / bb;\n        return Complex.create((this.x * other.x + this.y * other.y) * divbb, (this.y * other.x - this.x * other.y) * divbb, result);\n    }\n    /** Return the complex square root of this. */\n    sqrt(result) {\n        if ((this.x === 0.0) && (this.y === 0.0))\n            return Complex.create(0, 0, result);\n        const x = Math.abs(this.x);\n        const y = Math.abs(this.y);\n        let r = 0;\n        let w = 0;\n        if (x >= y) {\n            r = y / x;\n            w = Math.sqrt(x) * Math.sqrt(0.5 * (1.0 + Math.sqrt(1.0 + r * r)));\n        }\n        else {\n            r = x / y;\n            w = Math.sqrt(y) * Math.sqrt(0.5 * (r + Math.sqrt(1.0 + r * r)));\n        }\n        if (this.x >= 0.0) {\n            return Complex.create(w, this.y / (2.0 * w), result);\n        }\n        else {\n            const y1 = (this.y >= 0) ? w : -w;\n            return Complex.create(this.y / (2.0 * y1), y1, result);\n        }\n    }\n    /** set the complex x,y from a json object of the form like\n     * * x,y key value pairs:   `{x:1,y:2}`\n     * * array of numbers:  `[1,2]`\n     */\n    setFromJSON(json) {\n        if (Array.isArray(json) && json.length > 1) {\n            this.set(json[0], json[1]);\n        }\n        else if (json && json.x && json.y) {\n            this.set(json.x, json.y);\n        }\n        else {\n            this.set(0, 0);\n        }\n    }\n    /** Create a `Complex` instance from a json object. */\n    static fromJSON(json) { const result = new Complex(); result.setFromJSON(json); return result; }\n    /**\n     * Convert an Complex to a JSON object.\n     * @return {*} [x,y]\n     */\n    toJSON() { return [this.x, this.y]; }\n}\n//# sourceMappingURL=Complex.js.map",
      "start": 1693508122607,
      "end": 1693508122760,
      "sourcemaps": null
    }
  ]
}
