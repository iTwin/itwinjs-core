{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/common/lib/esm/rpc/core/RpcPush.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/*---------------------------------------------------------------------------------------------\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module RpcInterface\n */\nimport { assert, BeEvent, BentleyStatus } from \"@itwin/core-bentley\";\nimport { IModelError } from \"../../IModelError\";\n/** Defines a transport for push messages.\n *  @internal\n */\nexport class RpcPushTransport {\n}\n/** Defines a source of push messages.\n *  @internal\n */\nclass RpcPushService {\n    constructor(name) {\n        this.name = name;\n    }\n}\n/** The push service for the dedicated backend (for example, an electron or mobile app). */\nRpcPushService.dedicated = new RpcPushService(\"dedicated\");\nexport { RpcPushService };\n/** Defines a named stream of push messages.\n *  @internal\n */\nclass RpcPushChannel {\n    static setup(transport) {\n        transport.onMessage = RpcPushChannel.notifySubscribers.bind(RpcPushChannel);\n        RpcPushChannel.enabled = true;\n    }\n    static notifySubscribers(channelId, messageData) {\n        const channel = this._channels.get(channelId);\n        if (!channel)\n            return;\n        for (const subscriber of channel._subscribers)\n            subscriber.onMessage.raiseEvent(messageData);\n    }\n    get id() { return RpcPushChannel.formatId(this.name, this.service); }\n    get enabled() { return RpcPushChannel.enabled; }\n    subscribe() {\n        const subscription = new RpcPushSubscription(this);\n        this._subscribers.push(subscription);\n        return subscription;\n    }\n    static formatId(name, service) {\n        return `${service.name}-${name}`;\n    }\n    constructor(name, service) {\n        this._subscribers = [];\n        this._refCount = 1;\n        this.name = name;\n        this.service = service;\n    }\n    /** Creates a new RpcPushChannel.\n     * @throws IModelError if a channel with the specified name and service already exist.\n     */\n    static create(name, service = RpcPushService.dedicated) {\n        return this.get(name, service, false);\n    }\n    /** Obtains an RpcPushChannel, creating it if one with the specified name and service does not already exists. */\n    static obtain(name, service = RpcPushService.dedicated) {\n        return this.get(name, service, true);\n    }\n    static get(name, service, reuseExisting) {\n        const id = this.formatId(name, service);\n        let channel = this._channels.get(id);\n        if (channel) {\n            if (!reuseExisting)\n                throw new IModelError(BentleyStatus.ERROR, `Channel \"${id}\" already exists.`);\n            ++channel._refCount;\n            return channel;\n        }\n        channel = new RpcPushChannel(name, service);\n        this._channels.set(id, channel);\n        return channel;\n    }\n    dispose() {\n        if (this.isDisposed)\n            return;\n        assert(this._refCount > 0);\n        if (--this._refCount === 0) {\n            RpcPushChannel._channels.delete(this.id);\n            this._subscribers.length = 0;\n        }\n    }\n    get isDisposed() {\n        return 0 === this._refCount;\n    }\n}\n/** @internal */\nRpcPushChannel.enabled = false;\nRpcPushChannel._channels = new Map();\nexport { RpcPushChannel };\n/** Receives push messages from the backend.\n *  @internal\n */\nexport class RpcPushSubscription {\n    /** @internal */\n    constructor(channel) {\n        this.onMessage = new BeEvent();\n        this.channel = channel;\n    }\n}\n/** Sends push messages to the frontend.\n *  @internal\n */\nexport class RpcPushConnection {\n    static for(_channel, _client = undefined) {\n        throw new IModelError(BentleyStatus.ERROR, \"Not implemented.\");\n    }\n    constructor(channel, client) {\n        this.channel = channel;\n        this.client = client;\n    }\n}\n//# sourceMappingURL=RpcPush.js.map",
      "start": 1693508120830,
      "end": 1693508120907,
      "sourcemaps": null
    }
  ]
}
