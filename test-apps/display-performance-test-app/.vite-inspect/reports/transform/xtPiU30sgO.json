{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/EmphasizeElements.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Rendering\n */\nimport { Id64 } from \"@itwin/core-bentley\";\nimport { ColorDef, FeatureAppearance, FeatureOverrideType, RgbColor } from \"@itwin/core-common\";\n/** An implementation of [[FeatureOverrideProvider]] for emphasizing selected elements through simple color/transparency appearance overrides.\n * @public\n * @extensions\n */\nexport class EmphasizeElements {\n    constructor() {\n        this._emphasizedAppearance = FeatureAppearance.fromJSON({ emphasized: true });\n        /** If true, all overridden and emphasized elements will also have the \"emphasis\" effect applied to them. This causes them to be hilited using the current [[Viewport.emphasisSettings]]. */\n        this.wantEmphasis = false;\n    }\n    /** Establish active feature overrides to emphasize elements and apply color/transparency overrides.\n     * @see [[Viewport.addFeatureOverrideProvider]]\n     */\n    addFeatureOverrides(overrides, vp) {\n        const emphasizedElements = this.getEmphasizedElements(vp);\n        if (undefined !== emphasizedElements) {\n            overrides.setDefaultOverrides(this._defaultAppearance);\n            const appearance = this.wantEmphasis ? this._emphasizedAppearance : FeatureAppearance.defaults;\n            // Avoid creating a new object per-element inside the loop\n            const args = { elementId: \"\", appearance };\n            for (const elementId of emphasizedElements) {\n                args.elementId = elementId;\n                overrides.override(args);\n            }\n            // Do not apply animation overrides to de-emphasized elements.\n            overrides.ignoreAnimationOverrides((args) => {\n                const id = Id64.fromUint32Pair(args.elementId.lower, args.elementId.upper);\n                return !emphasizedElements.has(id);\n            });\n        }\n        const overriddenElements = this.getOverriddenElements();\n        if (undefined !== overriddenElements) {\n            if (undefined !== this._defaultAppearance)\n                overrides.setDefaultOverrides(this._defaultAppearance);\n            // Avoid creating a new object per-element inside the loop\n            const args = { elementId: \"\", appearance: FeatureAppearance.defaults };\n            for (const [key, ids] of overriddenElements) {\n                args.appearance = this.createAppearanceFromKey(key);\n                for (const elementId of ids) {\n                    args.elementId = elementId;\n                    overrides.override(args);\n                }\n            }\n        }\n        if (this._unanimatedAppearance) {\n            if (this._unanimatedAppearance.isFullyTransparent)\n                overrides.neverDrawnAnimationNodes.add(0);\n            else\n                overrides.animationNodeOverrides.set(0, this._unanimatedAppearance);\n        }\n    }\n    /** @internal */\n    createAppearanceFromKey(key) {\n        let transparency;\n        let rgb;\n        if (key < 0) {\n            transparency = Math.abs(key);\n        }\n        else {\n            const color = ColorDef.fromJSON(key);\n            rgb = RgbColor.fromColorDef(color);\n            if (0 !== color.getAlpha()) // Fully transparent signifies to use color only...\n                transparency = color.getTransparency() / 255;\n        }\n        const emphasized = this.wantEmphasis ? true : undefined;\n        return FeatureAppearance.fromJSON({ rgb, transparency, emphasized });\n    }\n    /** Get override key from color and override type */\n    createOverrideKey(color, override) {\n        const colorValues = color.colors;\n        switch (override) {\n            case FeatureOverrideType.ColorAndAlpha:\n                return 255 === colorValues.t ? undefined : color.tbgr; // Hiding elements should be done using neverDrawn, not transparency...\n            case FeatureOverrideType.ColorOnly:\n                return ColorDef.from(colorValues.r, colorValues.g, colorValues.b, 255).tbgr;\n            case FeatureOverrideType.AlphaOnly:\n                return -(colorValues.t / 255);\n        }\n    }\n    /** Get color and override type for the given key. */\n    getOverrideFromKey(key) {\n        let overrideType;\n        let color;\n        if (key < 0) {\n            color = ColorDef.from(0, 0, 0, 255 * Math.abs(key));\n            overrideType = FeatureOverrideType.AlphaOnly;\n        }\n        else {\n            color = ColorDef.fromJSON(key);\n            if (0 === color.getAlpha()) {\n                color = color.withAlpha(255);\n                overrideType = FeatureOverrideType.ColorOnly;\n            }\n            else {\n                overrideType = FeatureOverrideType.ColorAndAlpha;\n            }\n        }\n        return { overrideType, color };\n    }\n    /** Establish a default appearance to apply to elements without overrides. If changing the default appearance\n     * without also calling overrideElements, an explicit refresh must be requested for the change to take effect.\n     * @see [[Viewport.setFeatureOverrideProviderChanged]]\n     */\n    get defaultAppearance() { return this._defaultAppearance; }\n    set defaultAppearance(appearance) { this._defaultAppearance = appearance; }\n    /** Establish a default appearance to apply to elements that are not animated by the view's [RenderSchedule.Script]($common).\n     * @note If this is the only change made to EmphasizeElements, you must call [[Viewport.setFeatureOverrideProviderChanged]] for\n     * the change to take immediate effect.\n     * @see [[createDefaultAppearance]] to create an appearance suitable for de-emphasizing the non-animated elements.\n     */\n    get unanimatedAppearance() {\n        return this._unanimatedAppearance;\n    }\n    set unanimatedAppearance(appearance) {\n        this._unanimatedAppearance = appearance;\n    }\n    /** Create default appearance to use for emphasizeElements when not supplied by caller. */\n    createDefaultAppearance() {\n        return FeatureAppearance.fromJSON({\n            rgb: new RgbColor(0xe4, 0xe4, 0xe4),\n            transparency: 0.8,\n            nonLocatable: true,\n        });\n    }\n    /** Get the IDs of the currently never drawn elements. */\n    getNeverDrawnElements(vp) {\n        return (undefined !== vp.neverDrawn && 0 !== vp.neverDrawn.size ? vp.neverDrawn : undefined);\n    }\n    /** Get the IDs of the currently always drawn elements. */\n    getAlwaysDrawnElements(vp) {\n        return (undefined !== vp.alwaysDrawn && 0 !== vp.alwaysDrawn.size ? vp.alwaysDrawn : undefined);\n    }\n    /** Get the IDs of the currently hidden elements. */\n    getHiddenElements(vp) {\n        return this.getNeverDrawnElements(vp);\n    }\n    /** Get the IDs of the currently isolated elements. */\n    getIsolatedElements(vp) {\n        return (vp.isAlwaysDrawnExclusive ? this.getAlwaysDrawnElements(vp) : undefined);\n    }\n    /** Get the IDs of the currently emphasized isolated elements. */\n    getEmphasizedIsolatedElements() {\n        return (undefined !== this._defaultAppearance && undefined !== this._emphasizeIsolated && 0 !== this._emphasizeIsolated.size ? this._emphasizeIsolated : undefined);\n    }\n    /** Get the IDs of the currently emphasized elements. */\n    getEmphasizedElements(vp) {\n        return (undefined !== this.getEmphasizedIsolatedElements() ? this._emphasizeIsolated : (undefined !== this._defaultAppearance && !vp.isAlwaysDrawnExclusive ? this.getAlwaysDrawnElements(vp) : undefined));\n    }\n    /** Get the map of current elements with color/transparency overrides. */\n    getOverriddenElements() {\n        return (undefined !== this._overrideAppearance && 0 !== this._overrideAppearance.size ? this._overrideAppearance : undefined);\n    }\n    /** Get the IDs of current elements with the specified color/transparency override. */\n    getOverriddenElementsByKey(key) {\n        return (undefined !== this._overrideAppearance ? this._overrideAppearance.get(key) : undefined);\n    }\n    /** Clear never drawn elements.\n     * @return false if nothing to clear.\n     */\n    clearNeverDrawnElements(vp) {\n        if (undefined === this.getNeverDrawnElements(vp))\n            return false;\n        vp.clearNeverDrawn();\n        return true;\n    }\n    /** Clear always drawn elements.\n     * @return false if nothing to clear.\n     */\n    clearAlwaysDrawnElements(vp) {\n        if (undefined === this.getAlwaysDrawnElements(vp))\n            return false;\n        vp.clearAlwaysDrawn();\n        return true;\n    }\n    /** Clear hidden elements.\n     * @return false if nothing to clear.\n     */\n    clearHiddenElements(vp) {\n        return this.clearNeverDrawnElements(vp);\n    }\n    /** Clear isolated elements.\n     * @return false if nothing to clear.\n     */\n    clearIsolatedElements(vp) {\n        if (undefined === this.getIsolatedElements(vp))\n            return false;\n        if (this.clearEmphasizedIsolatedElements(vp, true))\n            return true;\n        return this.clearAlwaysDrawnElements(vp);\n    }\n    /** Clear emphasized elements.\n     * @return false if nothing to clear.\n     */\n    clearEmphasizedElements(vp) {\n        if (undefined === this.getEmphasizedElements(vp))\n            return false;\n        if (this.clearEmphasizedIsolatedElements(vp, false))\n            return true;\n        if (!this.clearAlwaysDrawnElements(vp))\n            return false;\n        this._defaultAppearance = undefined;\n        return true;\n    }\n    /** Clear emphasized isolated elements.\n     * @return false if nothing to clear.\n     */\n    clearEmphasizedIsolatedElements(vp, setToAlwaysDrawn) {\n        const emphasizedIsolated = this.getEmphasizedIsolatedElements();\n        this._emphasizeIsolated = undefined; // Always clear in case default appearance was unset...\n        if (undefined === emphasizedIsolated)\n            return false;\n        if (setToAlwaysDrawn && this.setAlwaysDrawnElements(emphasizedIsolated, vp, false))\n            return true;\n        this._defaultAppearance = undefined;\n        vp.setFeatureOverrideProviderChanged();\n        return true;\n    }\n    /** Clear color/transparency overrides from elements. Removes all overrides when keyOrIds isn't supplied.\n     * @param keyOrIds Specify a key value from [[EmphasizeElements.getOverriddenElements]] or [[EmphasizeElements.createOverrideKey]]\n     * to remove a single color/transparency override for the corresponding elements or specify the IDs of elements to\n     * remove any color/transparency override from.\n     * @return false if nothing to clear.\n     */\n    clearOverriddenElements(vp, keyOrIds) {\n        if (undefined === this._overrideAppearance)\n            return false;\n        if (undefined !== keyOrIds) {\n            if (typeof keyOrIds === \"number\") {\n                if (!this._overrideAppearance.delete(keyOrIds))\n                    return false;\n            }\n            else {\n                let changed = false;\n                for (const [otherKey, otherIds] of this._overrideAppearance) {\n                    const oldSize = otherIds.size;\n                    for (const id of Id64.iterable(keyOrIds))\n                        otherIds.delete(id);\n                    if (oldSize !== otherIds.size)\n                        changed = true;\n                    if (0 === otherIds.size)\n                        this._overrideAppearance.delete(otherKey);\n                }\n                if (!changed)\n                    return false;\n            }\n        }\n        else {\n            this._overrideAppearance = undefined;\n        }\n        vp.setFeatureOverrideProviderChanged();\n        return true;\n    }\n    /** @internal */\n    updateIdSet(ids, replace, existingIds) {\n        const newIds = new Set();\n        for (const id of Id64.iterable(ids))\n            newIds.add(id);\n        if (0 === newIds.size)\n            return undefined;\n        const oldSize = (!replace && undefined !== existingIds ? existingIds.size : 0);\n        if (0 !== oldSize && undefined !== existingIds)\n            for (const id of existingIds)\n                newIds.add(id);\n        if (oldSize === newIds.size)\n            return undefined;\n        return newIds;\n    }\n    /** Set the element IDs to be never drawn.\n     * @param ids The IDs of the elements to never draw.\n     * @param vp The viewport.\n     * @param replace true to replace currently hidden elements (if any) or false to add to the existing set.\n     * @return true if overrides were changed.\n     * @see [[Viewport.neverDrawn]]\n     * @internal\n     */\n    setNeverDrawnElements(ids, vp, replace = true) {\n        const hiddenIds = this.updateIdSet(ids, replace, vp.neverDrawn);\n        if (undefined === hiddenIds)\n            return false;\n        vp.setNeverDrawn(hiddenIds);\n        return true;\n    }\n    /** Set the element IDs to be always drawn.\n     * @param ids The IDs of the elements to always draw.\n     * @param vp The viewport.\n     * @param exclusive If true, *only* the specified elements will be drawn.\n     * @param replace true to replace currently always drawn elements (if any) or false to add to the existing set.\n     * @return true if overrides were changed.\n     * @see [[Viewport.alwaysDrawn]]\n     * @see [[Viewport.isAlwaysDrawnExclusive]]\n     * @internal\n     */\n    setAlwaysDrawnElements(ids, vp, exclusive = true, replace = true) {\n        const visibleIds = this.updateIdSet(ids, replace, vp.alwaysDrawn);\n        if (undefined === visibleIds)\n            return false;\n        vp.setAlwaysDrawn(visibleIds, exclusive);\n        return true;\n    }\n    /** Set the element IDs to be never drawn.\n     * @param ids The IDs of the elements to never draw.\n     * @param vp The viewport.\n     * @param replace true to replace currently hidden elements (if any) or false to add to the existing set.\n     * @return true if overrides were changed.\n     * @see [[Viewport.neverDrawn]]\n     */\n    hideElements(ids, vp, replace = false) {\n        return this.setNeverDrawnElements(ids, vp, replace);\n    }\n    /** Set the currently selected elements to be never drawn.\n     * @param vp The viewport.\n     * @param replace true to replace currently hidden elements (if any) or false to add to the existing set.\n     * @param clearSelection true to clear current selection after setting appearance override, false to leave selected.\n     * @return true if overrides were changed.\n     * @see [[Viewport.neverDrawn]]\n     */\n    hideSelectedElements(vp, replace = false, clearSelection = true) {\n        const selection = vp.view.iModel.selectionSet;\n        if (!selection.isActive || !this.hideElements(selection.elements, vp, replace))\n            return false;\n        if (clearSelection)\n            selection.emptyAll();\n        return true;\n    }\n    /** Set the element IDs to be always drawn exclusively.\n     * @param ids The IDs of the elements to always draw.\n     * @param vp The viewport.\n     * @param replace true to replace currently isolated elements (if any) or false to add to the existing set.\n     * @return true if overrides were changed.\n     * @see [[Viewport.alwaysDrawn]]\n     * @see [[Viewport.isAlwaysDrawnExclusive]]\n     */\n    isolateElements(ids, vp, replace = true) {\n        const wasEmphasized = (undefined !== this.getEmphasizedElements(vp));\n        if (!this.setAlwaysDrawnElements(ids, vp, true, replace))\n            return false;\n        if (wasEmphasized)\n            this._defaultAppearance = this._emphasizeIsolated = undefined; // Don't clear defaultAppearance unless it was established by emphasize...\n        return true;\n    }\n    /** Set the currently selected elements to be always drawn exclusively.\n     * @param vp The viewport.\n     * @param replace true to replace currently isolated elements (if any) or false to add to the existing set.\n     * @param clearSelection true to clear current selection after setting appearance override, false to leave selected.\n     * @return true if overrides were changed.\n     * @see [[Viewport.alwaysDrawn]]\n     * @see [[Viewport.isAlwaysDrawnExclusive]]\n     */\n    isolateSelectedElements(vp, replace = true, clearSelection = true) {\n        const selection = vp.view.iModel.selectionSet;\n        if (!selection.isActive || !this.isolateElements(selection.elements, vp, replace))\n            return false;\n        if (clearSelection)\n            selection.emptyAll();\n        return true;\n    }\n    /** Set the element IDs to be always drawn normally with all other elements in the view overridden to draw using a default appearance.\n     * @param ids The IDs of the elements to always draw.\n     * @param vp The viewport.\n     * @param defaultAppearance Optional default appearance, uses non-locatable transparent grey if not specified.\n     * @param replace true to replace currently overridden elements (if any) or false to add to the existing set.\n     * @return true if overrides were changed.\n     * @see [[Viewport.alwaysDrawn]]\n     * @see [[Viewport.isAlwaysDrawnExclusive]]\n     */\n    emphasizeElements(ids, vp, defaultAppearance, replace = true) {\n        if (undefined !== this.getIsolatedElements(vp)) {\n            const emphasizeIds = this.updateIdSet(ids, replace, this._emphasizeIsolated);\n            if (undefined === emphasizeIds)\n                return false;\n            this._emphasizeIsolated = emphasizeIds;\n            vp.setFeatureOverrideProviderChanged();\n        }\n        else {\n            if (!this.setAlwaysDrawnElements(ids, vp, false, replace))\n                return false;\n            this._emphasizeIsolated = undefined;\n        }\n        this._defaultAppearance = (undefined === defaultAppearance ? this.createDefaultAppearance() : defaultAppearance);\n        return true;\n    }\n    /** Set the currently selected elements to be always drawn normally with all other elements in the view overridden to draw using a default appearance.\n     * @param vp The viewport.\n     * @param defaultAppearance Optional default appearance, uses transparent grey if not specified.\n     * @param replace true to replace currently overridden elements (if any) or false to add to the existing set.\n     * @param clearSelection true to clear current selection after setting appearance override, false to leave selected.\n     * @return true if overrides were changed.\n     * @see [[Viewport.alwaysDrawn]]\n     * @see [[Viewport.isAlwaysDrawnExclusive]]\n     */\n    emphasizeSelectedElements(vp, defaultAppearance, replace = true, clearSelection = true) {\n        const selection = vp.view.iModel.selectionSet;\n        if (!selection.isActive || !this.emphasizeElements(selection.elements, vp, defaultAppearance, replace))\n            return false;\n        if (clearSelection)\n            selection.emptyAll();\n        return true;\n    }\n    /** Set the element IDs to display with a color/transparency override.\n     * @param ids The IDs of the elements.\n     * @param vp The viewport.\n     * @param color ColorDef to specify override rgb and alpha.\n     * @param override Whether to use color and alpha, only color, or only alpha from the supplied ColorDef.\n     * @param replace true to replace currently overridden elements (if any) or false to add to the existing set.\n     * @return true if overrides were changed.\n     * @see [[Viewport.addFeatureOverrideProvider]]\n     */\n    overrideElements(ids, vp, color, override = FeatureOverrideType.ColorOnly, replace = false) {\n        const ovrKey = this.createOverrideKey(color, override);\n        if (undefined === ovrKey)\n            return false;\n        const overrideIds = new Set();\n        for (const id of Id64.iterable(ids))\n            overrideIds.add(id);\n        if (0 === overrideIds.size)\n            return false;\n        const existingIds = (!replace ? this.getOverriddenElementsByKey(ovrKey) : undefined);\n        const oldSize = (undefined !== existingIds ? existingIds.size : 0);\n        if (0 !== oldSize && undefined !== existingIds)\n            for (const id of existingIds)\n                overrideIds.add(id);\n        if (oldSize === overrideIds.size)\n            return false;\n        if (undefined === this._overrideAppearance) {\n            this._overrideAppearance = new Map();\n        }\n        else {\n            for (const [key, otherIds] of this._overrideAppearance) {\n                if (key === ovrKey) // Make sure these ids are unique to this color/transparency key...\n                    continue;\n                for (const id of Id64.iterable(ids))\n                    otherIds.delete(id);\n                if (0 !== otherIds.size)\n                    continue;\n                this._overrideAppearance.delete(key);\n            }\n        }\n        this._overrideAppearance.set(ovrKey, overrideIds);\n        vp.setFeatureOverrideProviderChanged();\n        return true;\n    }\n    /** Set the currently selected elements to display with a color/transparency override.\n     * @param vp The viewport.\n     * @param color ColorDef to specify override rgb and alpha.\n     * @param override Whether to use color and alpha, only color, or only alpha from the supplied ColorDef.\n     * @param replace true to replace currently overridden elements (if any) or false to add to the existing set.\n     * @param clearSelection true to clear current selection after setting appearance override, false to leave selected.\n     * @return true if overrides were changed.\n     * @see [[Viewport.addFeatureOverrideProvider]]\n     */\n    overrideSelectedElements(vp, color, override = FeatureOverrideType.ColorOnly, replace = false, clearSelection = true) {\n        const selection = vp.view.iModel.selectionSet;\n        if (!selection.isActive || !this.overrideElements(selection.elements, vp, color, override, replace))\n            return false;\n        if (clearSelection)\n            selection.emptyAll();\n        return true;\n    }\n    /** @return true if provider is currently overriding the display of any elements. */\n    isActive(vp) { return (undefined !== this.getNeverDrawnElements(vp) || undefined !== this.getAlwaysDrawnElements(vp) || undefined !== this.getOverriddenElements()); }\n    /** Serialize to JSON representation.\n     * @see [[EmphasizeElements.fromJSON]]\n     */\n    toJSON(vp) {\n        const props = {};\n        const neverDrawn = this.getNeverDrawnElements(vp);\n        if (undefined !== neverDrawn)\n            props.neverDrawn = [...neverDrawn];\n        const alwaysDrawn = this.getAlwaysDrawnElements(vp);\n        if (undefined !== alwaysDrawn)\n            props.alwaysDrawn = [...alwaysDrawn];\n        if (vp.isAlwaysDrawnExclusive)\n            props.isAlwaysDrawnExclusive = true; // isolate\n        const alwaysDrawnExclusiveEmphasized = this.getEmphasizedIsolatedElements();\n        if (undefined !== alwaysDrawnExclusiveEmphasized)\n            props.alwaysDrawnExclusiveEmphasized = [...alwaysDrawnExclusiveEmphasized];\n        if (undefined !== this.defaultAppearance)\n            props.defaultAppearance = this.defaultAppearance; // emphasize (or specifically set for override)\n        if (this.unanimatedAppearance)\n            props.unanimatedAppearance = this.unanimatedAppearance;\n        const overriddenElements = this.getOverriddenElements();\n        if (undefined !== overriddenElements) {\n            const appearanceOverride = [];\n            for (const [key, ovrIds] of overriddenElements) {\n                const { color, overrideType } = { ...this.getOverrideFromKey(key) };\n                const ids = [...ovrIds];\n                appearanceOverride.push({ overrideType, color: color.toJSON(), ids });\n            }\n            props.appearanceOverride = appearanceOverride;\n        }\n        if (this.wantEmphasis)\n            props.wantEmphasis = true;\n        return props;\n    }\n    /** Initialize from JSON representation.\n     * @see [[EmphasizeElements.toJSON]]\n     */\n    fromJSON(props, vp) {\n        let changed = false;\n        if (undefined !== props.neverDrawn && this.setNeverDrawnElements(new Set(props.neverDrawn), vp, true))\n            changed = true;\n        if (undefined !== props.alwaysDrawn && this.setAlwaysDrawnElements(new Set(props.alwaysDrawn), vp, undefined !== props.isAlwaysDrawnExclusive && props.isAlwaysDrawnExclusive))\n            changed = true;\n        if (undefined !== props.alwaysDrawnExclusiveEmphasized)\n            this._emphasizeIsolated = new Set(props.alwaysDrawnExclusiveEmphasized); // changed status determined by setAlwaysDrawnElements...\n        if (undefined !== props.defaultAppearance)\n            this.defaultAppearance = FeatureAppearance.fromJSON(props.defaultAppearance); // changed status determined by setAlwaysDrawnElements or overrideElements...\n        if (props.unanimatedAppearance)\n            this.unanimatedAppearance = FeatureAppearance.fromJSON(props.unanimatedAppearance);\n        if (undefined !== props.appearanceOverride) {\n            for (const ovrApp of props.appearanceOverride) {\n                if (undefined === ovrApp.ids)\n                    continue;\n                if (this.overrideElements(new Set(ovrApp.ids), vp, ColorDef.fromJSON(ovrApp.color), ovrApp.overrideType, true))\n                    changed = true;\n            }\n        }\n        const wantEmphasis = true === props.wantEmphasis;\n        if (wantEmphasis !== this.wantEmphasis) {\n            this.wantEmphasis = wantEmphasis;\n            changed = true;\n        }\n        return changed;\n    }\n    /** Return the EmphasizeElements provider currently registered with the specified Viewport, if one is already registered. */\n    static get(vp) {\n        return vp.findFeatureOverrideProviderOfType(EmphasizeElements);\n    }\n    /** Return the EmphasizeElements provider currently registered with the specified Viewport, or register a new one and return it. */\n    static getOrCreate(vp) {\n        let provider = this.get(vp);\n        if (!provider) {\n            provider = new EmphasizeElements();\n            vp.addFeatureOverrideProvider(provider);\n        }\n        return provider;\n    }\n    /** Drop the EmphasizeElements provider currently registered with the specified Viewport, if any is registered. */\n    static clear(vp, inactiveOnly = false) {\n        const provider = this.get(vp);\n        if (undefined === provider || (inactiveOnly && provider.isActive(vp)))\n            return;\n        vp.clearNeverDrawn();\n        vp.clearAlwaysDrawn();\n        vp.dropFeatureOverrideProvider(provider);\n    }\n}\n//# sourceMappingURL=EmphasizeElements.js.map",
      "start": 1693508118910,
      "end": 1693508119075,
      "sourcemaps": null
    }
  ]
}
