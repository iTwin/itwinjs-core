{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/common/lib/esm/MapLayerSettings.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module MapLayers\n */\nimport { assert } from \"@itwin/core-bentley\";\nimport { BackgroundMapProvider, BackgroundMapType } from \"./BackgroundMapProvider\";\n/** Normalized representation of a [[MapSubLayerProps]] for which values\n * have been validated and default values have been applied where explicit values not defined.\n * A map sub layer represents a set of objects within the layer that can be controlled separately.  These\n * are produced only from map servers that produce images on demand and are not supported by tiled (cached) servers.\n * This class can represent a hierarchy, in this case a sub layer is visible only if all its ancestors are also visible.\n * @see [[MapLayerSettings]]\n * @public\n */\nexport class MapSubLayerSettings {\n    constructor(name, title, visible, id, parent, children) {\n        this.name = name;\n        this.title = title;\n        this.visible = visible !== undefined && visible;\n        this.id = (id === undefined) ? this.name : id;\n        this.parent = parent;\n        this.children = children;\n    }\n    /** Construct from JSON, performing validation and applying default values for undefined fields. */\n    static fromJSON(json) {\n        return new MapSubLayerSettings(json.name, json.title, json.visible, (json.id === json.name) ? undefined : json.id, json.parent, json.children);\n    }\n    toJSON() {\n        const props = { name: this.name, visible: this.visible };\n        if (undefined !== this.id && this.id !== this.name)\n            props.id = this.id;\n        if (undefined !== this.title)\n            props.title = this.title;\n        if (this.children)\n            props.children = [...this.children];\n        if (undefined !== this.parent)\n            props.parent = this.parent;\n        return props;\n    }\n    /** Creating a copy of this MapSubLayer, optionally modifying some if its properties */\n    clone(changedProps) {\n        if (undefined === changedProps)\n            return this;\n        const props = {\n            name: undefined !== changedProps.name ? changedProps.name : this.name,\n            id: undefined !== changedProps.id ? changedProps.id : this.id,\n            visible: undefined !== changedProps.visible ? changedProps.visible : this.visible,\n            parent: undefined !== changedProps.parent ? changedProps.parent : this.parent,\n            children: undefined !== changedProps.children ? changedProps.children.slice() : this.children?.slice(),\n            title: undefined !== changedProps.title ? changedProps.title : this.title,\n        };\n        return MapSubLayerSettings.fromJSON(props);\n    }\n    /** @internal */\n    displayMatches(other) {\n        return this.name === other.name && this.visible === other.visible;\n    }\n    /** return true if this sublayer is named. */\n    get isNamed() { return this.name.length > 0; }\n    /** return true if this sublayer is a leaf (has no children) */\n    get isLeaf() { return this.children === undefined || this.children.length === 0; }\n    /** return true if this sublayer is an unnamed group */\n    get isUnnamedGroup() { return !this.isLeaf && !this.isNamed; }\n    /** return a string representing this sublayer id (converting to string if underlying id is number) */\n    get idString() { return (typeof this.id === \"number\") ? this.id.toString(10) : this.id; }\n}\n/** Abstract base class for normalized representation of a [[MapLayerProps]] for which values have been validated and default values have been applied where explicit values not defined.\n * This class is extended by [[ImageMapLayerSettings]] and [ModelMapLayerSettings]] to create the settings for image and model based layers.\n * One or more map layers may be included within [[MapImagerySettings]] object.\n * @see [[MapImagerySettings]]\n * @public\n */\nexport class MapLayerSettings {\n    /** @internal */\n    constructor(name, visible = true, transparency = 0, transparentBackground = true) {\n        this.name = name;\n        this.visible = visible;\n        this.transparentBackground = transparentBackground;\n        this.transparency = transparency;\n    }\n    /** Create a map layer settings from its JSON representation. */\n    static fromJSON(props) {\n        return undefined !== props.modelId ? ModelMapLayerSettings.fromJSON(props) : ImageMapLayerSettings.fromJSON(props);\n    }\n    /** @internal */\n    _toJSON() {\n        const props = {\n            name: this.name,\n            visible: this.visible,\n        };\n        if (0 !== this.transparency)\n            props.transparency = this.transparency;\n        if (this.transparentBackground === false)\n            props.transparentBackground = this.transparentBackground;\n        return props;\n    }\n    /** @internal */\n    cloneProps(changedProps) {\n        return {\n            name: undefined !== changedProps.name ? changedProps.name : this.name,\n            visible: undefined !== changedProps.visible ? changedProps.visible : this.visible,\n            transparency: undefined !== changedProps.transparency ? changedProps.transparency : this.transparency,\n            transparentBackground: undefined !== changedProps.transparentBackground ? changedProps.transparentBackground : this.transparentBackground,\n        };\n    }\n    /** @internal */\n    displayMatches(other) {\n        return this.name === other.name && this.visible === other.visible && this.transparency === other.transparency && this.transparentBackground === other.transparentBackground;\n    }\n    /** @internal */\n    matchesNameAndSource(name, source) {\n        return this.name === name && this.source === source;\n    }\n}\n/** Normalized representation of a [[ImageMapLayerProps]] for which values have been validated and default values have been applied where explicit values not defined.\n * Image map layers are created from servers that produce images that represent map tiles.  Map layers map also be represented by models.\n * One or more map layers may be included within [[MapImagerySettings]] object.\n * @see [[MapImagerySettings]]\n * @see [[ModelMapLayerSettings]] for model based map layer settings.\n * @public\n */\nexport class ImageMapLayerSettings extends MapLayerSettings {\n    get source() { return this.url; }\n    /** @internal */\n    constructor(props) {\n        const transparentBackground = props.transparentBackground ?? true;\n        super(props.name, props.visible, props.transparency, transparentBackground);\n        this.formatId = props.formatId;\n        this.url = props.url;\n        this.accessKey = props.accessKey;\n        this.subLayers = [];\n        if (!props.subLayers)\n            return;\n        for (const subLayerProps of props.subLayers) {\n            const subLayer = MapSubLayerSettings.fromJSON(subLayerProps);\n            if (subLayer)\n                this.subLayers.push(subLayer);\n        }\n    }\n    static fromJSON(props) {\n        return new this(props);\n    }\n    /** return JSON representation of this MapLayerSettings object */\n    toJSON() {\n        const props = super._toJSON();\n        props.url = this.url;\n        props.formatId = this.formatId;\n        if (this.subLayers.length > 0)\n            props.subLayers = this.subLayers.map((x) => x.toJSON());\n        return props;\n    }\n    /** Create a copy of this MapLayerSettings, optionally modifying some of its properties.\n     * @param changedProps JSON representation of the properties to change.\n     * @returns A MapLayerSettings with all of its properties set to match those of `this`, except those explicitly defined in `changedProps`.\n     */\n    clone(changedProps) {\n        const clone = ImageMapLayerSettings.fromJSON(this.cloneProps(changedProps));\n        // Clone members not part of MapLayerProps\n        clone.userName = this.userName;\n        clone.password = this.password;\n        clone.accessKey = this.accessKey;\n        return clone;\n    }\n    /** @internal */\n    cloneProps(changedProps) {\n        const props = super.cloneProps(changedProps);\n        props.formatId = changedProps.formatId ?? this.formatId;\n        props.url = changedProps.url ?? this.url;\n        props.accessKey = changedProps.accessKey ?? this.accessKey;\n        props.subLayers = changedProps.subLayers ?? this.subLayers;\n        return props;\n    }\n    /** @internal */\n    displayMatches(other) {\n        if (!(other instanceof ImageMapLayerSettings) || !super.displayMatches(other))\n            return false;\n        if (this.userName !== other.userName || this.password !== other.password || this.subLayers.length !== other.subLayers.length) {\n            return false;\n        }\n        for (let i = 0; i < this.subLayers.length; i++)\n            if (!this.subLayers[i].displayMatches(other.subLayers[i]))\n                return false;\n        return true;\n    }\n    /** Return a sublayer matching id -- or undefined if not found */\n    subLayerById(id) {\n        return id === undefined ? undefined : this.subLayers.find((subLayer) => subLayer.id === id);\n    }\n    hasInvisibleAncestors(subLayer) {\n        if (!subLayer || !subLayer.parent)\n            return false;\n        const parent = this.subLayerById(subLayer.parent);\n        if (!parent)\n            return false;\n        // Visibility of named group has no impact on the visibility of children (only unnamed group does)\n        // i.e For WMS, its should be possible to request a child layer when its parent is not visible (if the parent is also named)\n        return (!parent.visible && !parent.isNamed) || this.hasInvisibleAncestors(parent);\n    }\n    /** Return true if sublayer is visible -- testing ancestors for visibility if they exist. */\n    isSubLayerVisible(subLayer) {\n        if (!subLayer.visible)\n            return false;\n        return !this.hasInvisibleAncestors(subLayer);\n    }\n    /** Return true if all sublayers are invisible. */\n    get allSubLayersInvisible() {\n        if (this.subLayers.length === 0)\n            return false;\n        return this.subLayers.every((subLayer) => (subLayer.isUnnamedGroup || !this.isSubLayerVisible(subLayer)));\n    }\n    /** Return the children for a sublayer */\n    getSubLayerChildren(subLayer) {\n        if (!subLayer.children)\n            return undefined;\n        const children = new Array();\n        subLayer.children.forEach((childId) => {\n            const child = this.subLayerById(childId);\n            if (child !== undefined)\n                children.push(child);\n        });\n        return children;\n    }\n    /** @internal */\n    static mapTypeName(type) {\n        switch (type) {\n            case BackgroundMapType.Aerial:\n                return \"Aerial Imagery\";\n            default:\n            case BackgroundMapType.Hybrid:\n                return \"Aerial Imagery with labels\";\n            case BackgroundMapType.Street:\n                return \"Streets\";\n        }\n    }\n    setCredentials(userName, password) {\n        this.userName = userName;\n        this.password = password;\n    }\n}\n/** Normalized representation of a [[ModelMapLayerProps]] for which values have been validated and default values have been applied where explicit values not defined.\n * Model map layers are produced from models, typically from two dimensional geometry that may originate in a GIS system.\n * One or more map layers may be included within [[MapImagerySettings]] object.\n * @see [[MapImagerySettings]]\n * @see [[ImageMapLayerSettings]] for image based map layer settings.\n * @public\n */\nexport class ModelMapLayerSettings extends MapLayerSettings {\n    get source() { return this.modelId; }\n    /** @internal */\n    constructor(modelId, name, visible = true, transparency = 0, transparentBackground = true) {\n        super(name, visible, transparency, transparentBackground);\n        this.modelId = modelId;\n    }\n    /** Construct from JSON, performing validation and applying default values for undefined fields. */\n    static fromJSON(json) {\n        const transparentBackground = (json.transparentBackground === undefined) ? true : json.transparentBackground;\n        return new this(json.modelId, json.name, json.visible, json.transparency, transparentBackground);\n    }\n    /** return JSON representation of this MapLayerSettings object */\n    toJSON() {\n        const props = super._toJSON();\n        props.modelId = this.modelId;\n        return props;\n    }\n    /** Create a copy of this MapLayerSettings, optionally modifying some of its properties.\n     * @param changedProps JSON representation of the properties to change.\n     * @returns A MapLayerSettings with all of its properties set to match those of `this`, except those explicitly defined in `changedProps`.\n     */\n    clone(changedProps) {\n        return ModelMapLayerSettings.fromJSON(this.cloneProps(changedProps));\n    }\n    /** @internal */\n    cloneProps(changedProps) {\n        const props = super.cloneProps(changedProps);\n        props.modelId = changedProps.modelId ?? this.modelId;\n        return props;\n    }\n    /** @internal */\n    displayMatches(other) {\n        if (!(other instanceof ModelMapLayerSettings) || !super.displayMatches(other))\n            return false;\n        return this.modelId === other.modelId;\n    }\n    /** Return true if all sublayers are invisible (always false as model layers do not include sublayers). */\n    get allSubLayersInvisible() {\n        return false;\n    }\n}\n/** A [[ImageMapLayerSettings]] that can serve as the base layer for a [[MapImagerySettings]].\n * The base layer supports all of the same options as any other layer, but also allows for simplified configuration based\n * on a small set of known supported [[BackgroundMapProvider]]s like [Bing Maps](https://www.microsoft.com/en-us/maps).\n * If the base layer was configured from such a provider, that information will be preserved and can be queried; this allows\n * the imagery provider and/or type to be easily modified.\n * @see [[MapImagerySettings.backgroundBase]].\n * @public\n */\nexport class BaseMapLayerSettings extends ImageMapLayerSettings {\n    /** The provider from which this base layer was configured, if any. */\n    get provider() { return this._provider; }\n    /** Create a base layer from its JSON representation.\n     * TODO: This, MapLayerSettings.fromJSON, and MapSubLayerSettings.fromJSON should never return undefined.\n     * That means they should not accept undefined for props and should define props such that it fully describes the\n     * layer - e.g., url and name must be defined.\n     */\n    static fromJSON(props) {\n        const settings = super.fromJSON(props);\n        assert(settings instanceof BaseMapLayerSettings);\n        if (props.provider)\n            settings._provider = BackgroundMapProvider.fromJSON(props.provider);\n        return settings;\n    }\n    /** Convert this layer to its JSON representation. */\n    toJSON() {\n        const props = super.toJSON();\n        if (this.provider)\n            props.provider = this.provider.toJSON();\n        return props;\n    }\n    /** @internal */\n    cloneProps(changedProps) {\n        const props = super.cloneProps(changedProps);\n        if (changedProps.provider)\n            props.provider = changedProps.provider;\n        else if (this.provider)\n            props.provider = this.provider.toJSON();\n        return props;\n    }\n    /** Create a copy of this layer. */\n    clone(changedProps) {\n        const prevUrl = this.url;\n        const clone = BaseMapLayerSettings.fromJSON(this.cloneProps(changedProps));\n        if (this.provider && prevUrl !== this.url)\n            clone._provider = undefined;\n        return clone;\n    }\n    /** Create a base layer from a BackgroundMapProvider. */\n    static fromProvider(provider, options) {\n        let formatId, url, name;\n        switch (provider.name) {\n            case \"BingProvider\":\n            default:\n                formatId = \"BingMaps\";\n                let imagerySet;\n                switch (provider.type) {\n                    case BackgroundMapType.Street:\n                        imagerySet = \"Road\";\n                        break;\n                    case BackgroundMapType.Aerial:\n                        imagerySet = \"Aerial\";\n                        break;\n                    case BackgroundMapType.Hybrid:\n                    default:\n                        imagerySet = \"AerialWithLabels\";\n                        break;\n                }\n                name = `Bing Maps: ${ImageMapLayerSettings.mapTypeName(provider.type)}`;\n                url = `https://dev.virtualearth.net/REST/v1/Imagery/Metadata/${imagerySet}?o=json&incl=ImageryProviders&key={bingKey}`;\n                break;\n            case \"MapBoxProvider\":\n                formatId = \"MapboxImagery\";\n                name = `MapBox: ${ImageMapLayerSettings.mapTypeName(provider.type)}`;\n                switch (provider.type) {\n                    case BackgroundMapType.Street:\n                        url = \"https://api.mapbox.com/styles/v1/mapbox/streets-v11/tiles/\";\n                        break;\n                    case BackgroundMapType.Aerial:\n                        url = \"https://api.mapbox.com/styles/v1/mapbox/satellite-v9/tiles/\";\n                        break;\n                    case BackgroundMapType.Hybrid:\n                        url = \"https://api.mapbox.com/styles/v1/mapbox/satellite-streets-v11/tiles/\";\n                        break;\n                }\n                break;\n        }\n        const settings = super.fromJSON({\n            name,\n            formatId,\n            url,\n            transparentBackground: false,\n            visible: !options?.invisible,\n            transparency: options?.transparency,\n        });\n        assert(undefined !== settings);\n        assert(settings instanceof BaseMapLayerSettings);\n        settings._provider = provider;\n        return settings;\n    }\n    /** @internal */\n    static fromBackgroundMapProps(props) {\n        return this.fromProvider(BackgroundMapProvider.fromBackgroundMapProps(props));\n    }\n    /** @alpha */\n    cloneWithProvider(provider) {\n        return BaseMapLayerSettings.fromProvider(provider, { invisible: !this.visible, transparency: this.transparency });\n    }\n}\n//# sourceMappingURL=MapLayerSettings.js.map",
      "start": 1693508120701,
      "end": 1693508120747,
      "sourcemaps": null
    }
  ]
}
