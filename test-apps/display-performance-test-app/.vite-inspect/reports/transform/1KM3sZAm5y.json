{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/orbitgt/lib/esm/spatial/geom/Transform.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module OrbitGT\n */\nimport { Bounds } from \"./Bounds\";\nimport { Coordinate } from \"./Coordinate\";\n/**\n * Class Transform defines a generic 3D transformation.\n *\n * @version 1.0 November 2015\n */\n/** @internal */\nexport class Transform {\n    /**\n     * Create a new (identity) transform.\n     */\n    constructor() {\n        this._elements = new Float64Array(16);\n        this._elements[0] = 1.0; // m00\n        this._elements[1] = 0.0; // m01\n        this._elements[2] = 0.0; // m02\n        this._elements[3] = 0.0; // m03\n        this._elements[4] = 0.0; // m10\n        this._elements[5] = 1.0; // m11\n        this._elements[6] = 0.0; // m12\n        this._elements[7] = 0.0; // m13\n        this._elements[8] = 0.0; // m20\n        this._elements[9] = 0.0; // m21\n        this._elements[10] = 1.0; // m22\n        this._elements[11] = 0.0; // m23\n        this._elements[12] = 0.0; // m30\n        this._elements[13] = 0.0; // m31\n        this._elements[14] = 0.0; // m32\n        this._elements[15] = 1.0; // m33\n    }\n    /**\n     * Create a new (identity) transform.\n     */\n    static create() {\n        return new Transform();\n    }\n    /**\n     * Create a transformation from elements.\n     * @param elements the 16 matrix elements (row major order).\n     * @return the transformation.\n     */\n    static fromRowMajor(elements) {\n        if (elements == null)\n            return null;\n        if (elements.length == 0)\n            return null;\n        let transform = new Transform();\n        let index = 0;\n        for (let r = 0; r < 4; r++)\n            for (let c = 0; c < 4; c++)\n                transform.setElement(r, c, elements[index++]);\n        return transform;\n    }\n    /**\n     * Create a transformation from elements.\n     * @param elements the 16 matrix elements (column major order).\n     * @return the transformation.\n     */\n    static fromColumnMajor(elements) {\n        if (elements == null)\n            return null;\n        if (elements.length == 0)\n            return null;\n        let transform = new Transform();\n        let index = 0;\n        for (let c = 0; c < 4; c++)\n            for (let r = 0; r < 4; r++)\n                transform.setElement(r, c, elements[index++]);\n        return transform;\n    }\n    /**\n     * Create a transformation from elements.\n     * @param elements the 9 matrix elements (row major order).\n     * @return the transformation.\n     */\n    static fromRotationElements(m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n        let transform = new Transform();\n        transform.setElement(0, 0, m00);\n        transform.setElement(0, 1, m01);\n        transform.setElement(0, 2, m02);\n        transform.setElement(1, 0, m10);\n        transform.setElement(1, 1, m11);\n        transform.setElement(1, 2, m12);\n        transform.setElement(2, 0, m20);\n        transform.setElement(2, 1, m21);\n        transform.setElement(2, 2, m22);\n        return transform;\n    }\n    /**\n     * Create a transformation from elements.\n     * @param elements the 16 matrix elements (row major order).\n     * @return the transformation.\n     */\n    static fromElements(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23) {\n        let transform = Transform.fromRotationElements(m00, m01, m02, m10, m11, m12, m20, m21, m22);\n        transform.setElement(0, 3, m03);\n        transform.setElement(1, 3, m13);\n        transform.setElement(2, 3, m23);\n        return transform;\n    }\n    /**\n     * Get an element.\n     * @param index the index of the element.\n     * @return the element.\n     */\n    get(index) {\n        return this._elements[index];\n    }\n    /**\n     * Set an element.\n     * @param index the index of the element.\n     * @param value the value.\n     */\n    set(index, value) {\n        this._elements[index] = value;\n    }\n    /**\n     * Get an element.\n     * @param row the row index.\n     * @param col the column index.\n     * @return the element.\n     */\n    getElement(row, col) {\n        return this._elements[row * 4 + col];\n    }\n    /**\n     * Set an element.\n     * @param row the row index.\n     * @param col the column index.\n     * @param value the value.\n     */\n    setElement(row, col, value) {\n        this._elements[row * 4 + col] = value;\n    }\n    /**\n     * Get the elements.\n     * @return the elements (row major order).\n     */\n    getElements() {\n        return this._elements;\n    }\n    /**\n     * Set the elements.\n     * @param elements the elements (row major order).\n     */\n    setElements(elements) {\n        for (let i = 0; i < this._elements.length; i++)\n            this._elements[i] = elements[i];\n    }\n    /**\n     * Get the X column.\n     * @return the X column.\n     */\n    getColumnX() {\n        return new Coordinate(this.getElement(0, 0), this.getElement(1, 0), this.getElement(2, 0));\n    }\n    /**\n     * Get the Y column.\n     * @return the Y column.\n     */\n    getColumnY() {\n        return new Coordinate(this.getElement(0, 1), this.getElement(1, 1), this.getElement(2, 1));\n    }\n    /**\n     * Get the Z column.\n     * @return the Z column.\n     */\n    getColumnZ() {\n        return new Coordinate(this.getElement(0, 2), this.getElement(1, 2), this.getElement(2, 2));\n    }\n    /**\n     * Get the translation column.\n     * @return the translation column.\n     */\n    getTranslation() {\n        return new Coordinate(this.getElement(0, 3), this.getElement(1, 3), this.getElement(2, 3));\n    }\n    /**\n     * Set the translation.\n     * @param tx the x position of the translation.\n     * @param ty the y position of the translation.\n     * @param tz the z position of the translation.\n     * @return the tranformation.\n     */\n    setTranslation(tx, ty, tz) {\n        this.setElement(0, 3, tx);\n        this.setElement(1, 3, ty);\n        this.setElement(2, 3, tz);\n        return this;\n    }\n    /**\n     * Clear the translation.\n     * @return the tranformation.\n     */\n    clearTranslation() {\n        this.setElement(0, 3, 0.0);\n        this.setElement(1, 3, 0.0);\n        this.setElement(2, 3, 0.0);\n        return this;\n    }\n    /**\n     * Swap two rows.\n     * @param row1 the first row.\n     * @param row2 the second row.\n     */\n    swapRows(row1, row2) {\n        for (let i = 0; i < 4; i++) {\n            let e1 = this.getElement(row1, i);\n            let e2 = this.getElement(row2, i);\n            this.setElement(row1, i, e2);\n            this.setElement(row2, i, e1);\n        }\n    }\n    /**\n     * Swap two columns.\n     * @param col1 the first column.\n     * @param col2 the second column.\n     */\n    swapColumns(col1, col2) {\n        for (let i = 0; i < 4; i++) {\n            let e1 = this.getElement(i, col1);\n            let e2 = this.getElement(i, col2);\n            this.setElement(i, col1, e2);\n            this.setElement(i, col2, e1);\n        }\n    }\n    /**\n     * Swap the YZ coordinates.\n     */\n    swapYZ() {\n        let result = Transform.multiply2(this, Transform.createSwapYZ());\n        this.setElements(result.getElements());\n    }\n    /**\n     * Calculate the cosine of an angle.\n     * @param angle the angle (in degrees).\n     * @return the cosine.\n     */\n    static cos(angle) {\n        /* One? */\n        if (angle == 0.0)\n            return 1.0;\n        if (angle == 360.0)\n            return 1.0;\n        /* Minus one? */\n        if (angle == 180.0)\n            return -1.0;\n        if (angle == -180.0)\n            return -1.0;\n        /* Zero? */\n        if (angle == 90.0)\n            return 0.0;\n        if (angle == -90.0)\n            return 0.0;\n        if (angle == 270.0)\n            return 0.0;\n        /* Calculate */\n        return Math.cos(angle / 180.0 * Math.PI);\n    }\n    /**\n     * Calculate the sine of an angle.\n     * @param angle the angle (in degrees).\n     * @return the sine.\n     */\n    static sin(angle) {\n        /* One? */\n        if (angle == 90.0)\n            return 1.0;\n        /* Minus one? */\n        if (angle == -90.0)\n            return -1.0;\n        if (angle == 270.0)\n            return -1.0;\n        /* Zero? */\n        if (angle == 0.0)\n            return 0.0;\n        if (angle == 360.0)\n            return 0.0;\n        if (angle == 180.0)\n            return 0.0;\n        if (angle == -180.0)\n            return 0.0;\n        /* Calculate */\n        return Math.sin(angle / 180.0 * Math.PI);\n    }\n    /**\n     * Rotate around the X axis.\n * @param angle the rotation angle (degree).\n     */\n    rotateX(angle) {\n        if (angle == 0.0)\n            return;\n        let result = Transform.multiply2(this, Transform.createRotationX(angle));\n        this.setElements(result.getElements());\n    }\n    /**\n     * Apply a rotation around X axis.\n     * @param point the (mutable) point to rotate.\n     * @param rotation the (Y->Z,counterclockwise) rotation (degrees).\n     */\n    static rotatePointX(point, rotation) {\n        if (rotation == 0.0)\n            return;\n        let a = rotation;\n        let dcos = Transform.cos(a);\n        let dsin = Transform.sin(a);\n        let ny = dcos * point.getY() - dsin * point.getZ();\n        let nz = dsin * point.getY() + dcos * point.getZ();\n        point.setXYZ(point.getX(), ny, nz);\n    }\n    /**\n     * Rotate around the Y axis.\n * @param angle the rotation angle (degree).\n     */\n    rotateY(angle) {\n        if (angle == 0.0)\n            return;\n        let result = Transform.multiply2(this, Transform.createRotationY(angle));\n        this.setElements(result.getElements());\n    }\n    /**\n     * Apply a rotation around Y axis.\n     * @param point the (mutable) point to rotate.\n     * @param rotation the (Z->X,counterclockwise) rotation (degrees).\n     */\n    static rotatePointY(point, rotation) {\n        if (rotation == 0.0)\n            return;\n        let a = -rotation; // swapped orientation to CCW on 09/03/2012\n        let dcos = Transform.cos(a);\n        let dsin = Transform.sin(a);\n        let nx = dcos * point.getX() - dsin * point.getZ();\n        let nz = dsin * point.getX() + dcos * point.getZ();\n        point.setXYZ(nx, point.getY(), nz);\n    }\n    /**\n     * Rotate around the Z axis.\n * @param angle the rotation angle (degree).\n     */\n    rotateZ(angle) {\n        if (angle == 0.0)\n            return;\n        let result = Transform.multiply2(this, Transform.createRotationZ(angle));\n        this.setElements(result.getElements());\n    }\n    /**\n     * Apply a rotation around Z axis.\n     * @param point the (mutable) point to rotate.\n     * @param rotation the (X->Y,counterclockwise) rotation (degrees).\n     */\n    static rotatePointZ(point, rotation) {\n        if (rotation == 0.0)\n            return;\n        let a = rotation;\n        let dcos = Transform.cos(a);\n        let dsin = Transform.sin(a);\n        let nx = dcos * point.getX() - dsin * point.getY();\n        let ny = dsin * point.getX() + dcos * point.getY();\n        point.setXYZ(nx, ny, point.getZ());\n    }\n    /**\n     * Multiply two matrices.\n     * @param a the first transform.\n     * @param b the second transform.\n     * @return the result transform (a x b).\n     */\n    static multiply2(a, b) {\n        /* Allow nulls */\n        if (a == null)\n            a = new Transform();\n        if (b == null)\n            b = new Transform();\n        /* Fill the destination transform \"d\" */\n        let d = new Transform();\n        for (let i = 0; i < 4; i++) {\n            /* Get the next row from \"a\" */\n            let ai0 = a.getElement(i, 0);\n            let ai1 = a.getElement(i, 1);\n            let ai2 = a.getElement(i, 2);\n            let ai3 = a.getElement(i, 3);\n            /* Set the target row in \"d\" */\n            d.setElement(i, 0, ai0 * b.getElement(0, 0) + ai1 * b.getElement(1, 0) + ai2 * b.getElement(2, 0) + ai3 * b.getElement(3, 0)); // multiply by column(0) of \"b\"\n            d.setElement(i, 1, ai0 * b.getElement(0, 1) + ai1 * b.getElement(1, 1) + ai2 * b.getElement(2, 1) + ai3 * b.getElement(3, 1)); // multiply by column(1) of \"b\"\n            d.setElement(i, 2, ai0 * b.getElement(0, 2) + ai1 * b.getElement(1, 2) + ai2 * b.getElement(2, 2) + ai3 * b.getElement(3, 2)); // multiply by column(2) of \"b\"\n            d.setElement(i, 3, ai0 * b.getElement(0, 3) + ai1 * b.getElement(1, 3) + ai2 * b.getElement(2, 3) + ai3 * b.getElement(3, 3)); // multiply by column(3) of \"b\"\n        }\n        /* Return the transform */\n        return d;\n    }\n    /**\n     * Concatenate a transform.\n     * @param transform the transform to concatenate.\n     * @return the combined transformation.\n */\n    concat(transform) {\n        return Transform.multiply2(this, transform);\n    }\n    /**\n     * Multiply.\n     * @param transform the transform to multiply with.\n */\n    multiply(transform) {\n        let result = Transform.multiply2(this, transform);\n        this.setElements(result.getElements());\n    }\n    /**\n     * Translate.\n * @param tx the x translation.\n * @param ty the y translation.\n * @param tz the z translation.\n */\n    translate(tx, ty, tz) {\n        let result = Transform.multiply2(this, Transform.createTranslation(tx, ty, tz));\n        this.setElements(result.getElements());\n    }\n    /**\n     * Translate.\n * @param point the xyz translation.\n */\n    translatePoint(point) {\n        this.translate(point.getX(), point.getY(), point.getZ());\n    }\n    /**\n     * Scale.\n * @param sx the x scale.\n * @param sy the y scale.\n * @param sz the z scale.\n */\n    scale(sx, sy, sz) {\n        let result = Transform.multiply2(this, Transform.createScale(sx, sy, sz));\n        this.setElements(result.getElements());\n    }\n    /**\n     * Scale XYZ.\n * @param s the scale.\n */\n    scale3(s) {\n        this.scale(s, s, s);\n    }\n    /**\n     * Create the inverse transform.\n     * @return the inverse transform.\n     */\n    createInverse() {\n        /* Get the 3x3 elements */\n        let a = this.getElement(0, 0);\n        let b = this.getElement(0, 1);\n        let c = this.getElement(0, 2);\n        let d = this.getElement(1, 0);\n        let e = this.getElement(1, 1);\n        let f = this.getElement(1, 2);\n        let g = this.getElement(2, 0);\n        let h = this.getElement(2, 1);\n        let i = this.getElement(2, 2);\n        /* Invert the 3x3 matrix */\n        let idet = 1.0 / (a * (e * i - h * f) - b * (d * i - g * f) + c * (d * h - g * e));\n        let inverse = new Transform();\n        inverse.setElement(0, 0, (e * i - f * h) * idet);\n        inverse.setElement(0, 1, -(b * i - c * h) * idet);\n        inverse.setElement(0, 2, (b * f - c * e) * idet);\n        inverse.setElement(1, 0, -(d * i - f * g) * idet);\n        inverse.setElement(1, 1, (a * i - c * g) * idet);\n        inverse.setElement(1, 2, -(a * f - c * d) * idet);\n        inverse.setElement(2, 0, (d * h - e * g) * idet);\n        inverse.setElement(2, 1, -(a * h - b * g) * idet);\n        inverse.setElement(2, 2, (a * e - b * d) * idet);\n        /* Invert the translation */\n        let t = new Coordinate(this.getElement(0, 3), this.getElement(1, 3), this.getElement(2, 3));\n        inverse.transformTo(t, t);\n        inverse.setElement(0, 3, -t.getX());\n        inverse.setElement(1, 3, -t.getY());\n        inverse.setElement(2, 3, -t.getZ());\n        /* Done */\n        return inverse;\n    }\n    /**\n     * Invert.\n */\n    invert() {\n        let result = this.createInverse();\n        this.setElements(result.getElements());\n    }\n    /**\n     * Create a copy.\n     * @return a copy.\n     */\n    copy() {\n        let copy = new Transform();\n        for (let i = 0; i < 16; i++)\n            copy._elements[i] = this._elements[i];\n        return copy;\n    }\n    /**\n     * Create an identity transform.\n     * @return the transform.\n     */\n    static createIdentity() {\n        return new Transform();\n    }\n    /**\n     * Create a translation transform.\n     * @param tx the x translation.\n     * @param ty the y translation.\n     * @param tz the z translation.\n     * @return the transform.\n     */\n    static createTranslation(tx, ty, tz) {\n        let transform = Transform.createIdentity();\n        transform.setElement(0, 3, tx);\n        transform.setElement(1, 3, ty);\n        transform.setElement(2, 3, tz);\n        return transform;\n    }\n    /**\n     * Create a translation transform.\n     * @param position the translation.\n     * @return the transform.\n     */\n    static createTranslation2(position) {\n        return Transform.createTranslation(position.getX(), position.getY(), position.getZ());\n    }\n    /**\n     * Create a scale transform.\n     * @param sx the x translation.\n     * @param sy the y translation.\n     * @param sz the z translation.\n     * @return the transform.\n     */\n    static createScale(sx, sy, sz) {\n        let transform = Transform.createIdentity();\n        transform.setElement(0, 0, sx);\n        transform.setElement(1, 1, sy);\n        transform.setElement(2, 2, sz);\n        return transform;\n    }\n    /**\n     * Create a rotation-round-X transform.\n     * @param angle the rotation angle (degree).\n     * @return the transform.\n     */\n    static createRotationX(angle) {\n        let rad = (angle / 180.0 * Math.PI);\n        let sin = (angle == 90.0) ? 1.0 : Math.sin(rad);\n        let cos = (angle == 90.0) ? 0.0 : Math.cos(rad);\n        let transform = Transform.createIdentity();\n        transform.setElement(1, 1, cos);\n        transform.setElement(2, 1, sin);\n        transform.setElement(1, 2, -sin);\n        transform.setElement(2, 2, cos);\n        return transform;\n    }\n    /**\n     * Create a rotation-round-Y transform.\n     * @param angle the rotation angle (degree).\n     * @return the transform.\n     */\n    static createRotationY(angle) {\n        let rad = (angle / 180.0 * Math.PI);\n        let sin = Math.sin(rad);\n        let cos = Math.cos(rad);\n        let transform = Transform.createIdentity();\n        transform.setElement(0, 0, cos);\n        transform.setElement(2, 0, -sin);\n        transform.setElement(0, 2, sin);\n        transform.setElement(2, 2, cos);\n        return transform;\n    }\n    /**\n     * Create a rotation-round-Z transform.\n     * @param angle the rotation angle (degree).\n     * @return the transform.\n     */\n    static createRotationZ(angle) {\n        let rad = (angle / 180.0 * Math.PI);\n        let sin = Math.sin(rad);\n        let cos = Math.cos(rad);\n        let transform = Transform.createIdentity();\n        transform.setElement(0, 0, cos);\n        transform.setElement(1, 0, sin);\n        transform.setElement(0, 1, -sin);\n        transform.setElement(1, 1, cos);\n        return transform;\n    }\n    /**\n     * Create a swap YZ transform.\n     * @return the transform.\n     */\n    static createSwapYZ() {\n        let transform = Transform.createIdentity();\n        transform.setElement(1, 1, 0.0);\n        transform.setElement(1, 2, 1.0);\n        transform.setElement(2, 1, 1.0);\n        transform.setElement(2, 2, 0.0);\n        return transform;\n    }\n    /**\n     * Create a transformation from elements.\n     * @param elements the elements (row major order)\n     * @return the transformation.\n     */\n    static createWithElements(elements) {\n        let transform = Transform.createIdentity();\n        transform.setElements(elements);\n        return transform;\n    }\n    /**\n     * Create a transformation from columns.\n     * @param col0 the first column.\n     * @param col1 the second column.\n     * @param col2 the third column.\n     * @param col3 the fourth column (considered zero if null).\n     * @return the transformation.\n     */\n    static createWithColumns(col0, col1, col2, col3) {\n        let transform = Transform.createIdentity();\n        transform.setElement(0, 0, col0.getX());\n        transform.setElement(1, 0, col0.getY());\n        transform.setElement(2, 0, col0.getZ());\n        transform.setElement(0, 1, col1.getX());\n        transform.setElement(1, 1, col1.getY());\n        transform.setElement(2, 1, col1.getZ());\n        transform.setElement(0, 2, col2.getX());\n        transform.setElement(1, 2, col2.getY());\n        transform.setElement(2, 2, col2.getZ());\n        if (col3 != null) {\n            transform.setElement(0, 3, col3.getX());\n            transform.setElement(1, 3, col3.getY());\n            transform.setElement(2, 3, col3.getZ());\n        }\n        return transform;\n    }\n    /**\n     * Create an orthogonal rotation from a quaternion.\n     * @param a the first quaternion element (q1).\n     * @param b the second quaternion element (q2).\n     * @param c the third quaternion element (q3).\n     * @param d the fourth quaternion element (q4).\n     * @return the rotation matrix.\n     */\n    static fromQuaternion(a, b, c, d) {\n        // See \"Quaternions and spatial rotation\" section \"From a quaternion to an orthogonal matrix\"\n        // at https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation\n        //\n        /* We should have a unit quaternion */\n        let len = (a * a + b * b + c * c + d * d);\n        /* First row */\n        let m00 = a * a + b * b - c * c - d * d;\n        let m01 = 2.0 * b * c - 2.0 * a * d;\n        let m02 = 2.0 * b * d + 2.0 * a * c;\n        /* Second row */\n        let m10 = 2.0 * b * c + 2.0 * a * d;\n        let m11 = a * a - b * b + c * c - d * d;\n        let m12 = 2.0 * c * d - 2.0 * a * b;\n        /* Third row */\n        let m20 = 2.0 * b * d - 2.0 * a * c;\n        let m21 = 2.0 * c * d + 2.0 * a * b;\n        let m22 = a * a - b * b - c * c + d * d;\n        /* Return the rotation */\n        let transform = new Transform();\n        transform.setElement(0, 0, m00);\n        transform.setElement(0, 1, m01);\n        transform.setElement(0, 2, m02);\n        transform.setElement(1, 0, m10);\n        transform.setElement(1, 1, m11);\n        transform.setElement(1, 2, m12);\n        transform.setElement(2, 0, m20);\n        transform.setElement(2, 1, m21);\n        transform.setElement(2, 2, m22);\n        return transform;\n    }\n    /**\n     * Transform a point.\n     * @param source the source point.\n     * @param target the target point (can be same as source).\n     * @return the target point.\n     */\n    transformTo(source, target) {\n        let sx = source.getX();\n        let sy = source.getY();\n        let sz = source.getZ();\n        target.x = this._elements[0] * sx + this._elements[1] * sy + this._elements[2] * sz + this._elements[3];\n        target.y = this._elements[4] * sx + this._elements[5] * sy + this._elements[6] * sz + this._elements[7];\n        target.z = this._elements[8] * sx + this._elements[9] * sy + this._elements[10] * sz + this._elements[11];\n        return target;\n    }\n    /**\n     * Transform a point.\n     * @param source the source point.\n     * @return the target point.\n     */\n    transform(source) {\n        return this.transformTo(source, Coordinate.create());\n    }\n    /**\n     * Transform bounds.\n     * @param bounds the bounds.\n     * @return the transformed bounds.\n     */\n    transformBounds(bounds) {\n        /* Not valid? */\n        if (bounds.isValid() == false)\n            return bounds;\n        /* Transform all corners */\n        let nbounds = new Bounds();\n        let point = Coordinate.create();\n        for (let i = 0; i < 8; i++) {\n            /* Transform the next corner */\n            bounds.getCorner(i, point);\n            this.transformTo(point, point);\n            nbounds.add(point);\n        }\n        /* Return the new bounds */\n        return nbounds;\n    }\n    /**\n     * Check if the transform matches another transform.\n     * @param other the other transform.\n     * @return true if same.\n     */\n    same(other) {\n        for (let i = 0; i < 16; i++)\n            if (this._elements[i] != other._elements[i])\n                return false;\n        return true;\n    }\n    /**\n     * The standard toString method.\n     * @see Object#toString\n     */\n    toString() {\n        return \"[Transform:m00=\" + this._elements[0] + \",m10=\" + this._elements[4] + \",m20=\" + this._elements[8] +\n            \",m01=\" + this._elements[1] + \",m11=\" + this._elements[5] + \",m21=\" + this._elements[9] +\n            \",m02=\" + this._elements[2] + \",m12=\" + this._elements[6] + \",m22=\" + this._elements[10] +\n            \",m03=\" + this._elements[3] + \",m13=\" + this._elements[7] + \",m23=\" + this._elements[11] + \"]\";\n    }\n}\n//# sourceMappingURL=Transform.js.map",
      "start": 1693508124826,
      "end": 1693508124935,
      "sourcemaps": null
    }
  ]
}
