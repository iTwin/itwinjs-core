{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tile/TileDrawArgs.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tiles\n */\nimport { Geometry, Matrix4d, Point3d, Point4d, Range1d, Range3d, Vector3d } from \"@itwin/core-geometry\";\nimport { FeatureAppearanceProvider, FrustumPlanes } from \"@itwin/core-common\";\nimport { GraphicBranch } from \"../render/GraphicBranch\";\nimport { CoordSystem } from \"../CoordSystem\";\nconst scratchRange = new Range3d();\nconst scratchPoint = Point3d.create();\nconst scratchPoint4d = Point4d.create();\nconst scratchXRange = Range1d.createNull();\nconst scratchYRange = Range1d.createNull();\nconst scratchMatrix4d = Matrix4d.createIdentity();\n/**\n * Provides context used when selecting and drawing [[Tile]]s.\n * @see [[TileTree.selectTiles]]\n * @see [[TileTree.draw]]\n * @public\n * @extensions\n */\nexport class TileDrawArgs {\n    /** Overrides applied to the view's [ViewFlags]($common) when drawing the tiles. */\n    get viewFlagOverrides() { return this.graphics.viewFlagOverrides; }\n    /** If defined, replaces the view's own symbology overrides when drawing the tiles. */\n    get symbologyOverrides() { return this.graphics.symbologyOverrides; }\n    /** Compute the size in pixels of the specified tile at the point on its bounding sphere closest to the camera. */\n    getPixelSize(tile) {\n        const sizeFromProjection = this.getPixelSizeFromProjection(tile);\n        if (undefined !== sizeFromProjection)\n            return sizeFromProjection;\n        const radius = this.getTileRadius(tile); // use a sphere to test pixel size. We don't know the orientation of the image within the bounding box.\n        const center = this.getTileCenter(tile);\n        const pixelSizeAtPt = this.computePixelSizeInMetersAtClosestPoint(center, radius);\n        return 0 !== pixelSizeAtPt ? this.context.adjustPixelSizeForLOD(radius / pixelSizeAtPt) : 1.0e-3;\n    }\n    /** If the tile provides corners (from an OBB) then this produces most accurate representation of the tile size */\n    getPixelSizeFromProjection(tile) {\n        const sizeProjectionCorners = tile.getSizeProjectionCorners();\n        if (!sizeProjectionCorners)\n            return undefined;\n        /* For maps or global reality models we use the projected screen rectangle rather than sphere to calculate pixel size to avoid excessive tiles at horizon.  */\n        const tileToView = this.worldToViewMap.transform0.multiplyMatrixMatrix(Matrix4d.createTransform(this.location, scratchMatrix4d), scratchMatrix4d);\n        scratchXRange.setNull();\n        scratchYRange.setNull();\n        let behindEye = false;\n        for (const corner of sizeProjectionCorners) {\n            const viewCorner = tileToView.multiplyPoint3d(corner, 1, scratchPoint4d);\n            if (viewCorner.w < 0.0) {\n                behindEye = true;\n                break;\n            }\n            scratchXRange.extendX(viewCorner.x / viewCorner.w);\n            scratchYRange.extendX(viewCorner.y / viewCorner.w);\n        }\n        if (behindEye)\n            return undefined;\n        return scratchXRange.isNull ? 1.0E-3 : this.context.adjustPixelSizeForLOD(Math.sqrt(scratchXRange.length() * scratchYRange.length()));\n    }\n    /** Compute the size in meters of one pixel at the point on the tile's bounding sphere closest to the camera. */\n    getPixelSizeInMetersAtClosestPoint(tile) {\n        const radius = this.getTileRadius(tile); // use a sphere to test pixel size. We don't know the orientation of the image within the bounding box.\n        const center = this.getTileCenter(tile);\n        const pixelSizeAtPt = this.computePixelSizeInMetersAtClosestPoint(center, radius);\n        return 0 !== pixelSizeAtPt ? this.context.adjustPixelSizeForLOD(pixelSizeAtPt) : 1.0e-3;\n    }\n    /** Compute the size in meters of one pixel at the point on a sphere closest to the camera.\n     * Device scaling is not applied.\n     */\n    computePixelSizeInMetersAtClosestPoint(center, radius) {\n        if (this.context.viewport.view.is3d() && this.context.viewport.isCameraOn && this._nearFrontCenter) {\n            const toFront = Vector3d.createStartEnd(center, this._nearFrontCenter);\n            const viewZ = this.context.viewport.rotation.rowZ();\n            // If the sphere overlaps the near front plane just use near front point.  This also handles behind eye conditions.\n            if (viewZ.dotProduct(toFront) < radius) {\n                center = this._nearFrontCenter;\n            }\n            else {\n                // Find point on sphere closest to eye.\n                const toEye = center.unitVectorTo(this.context.viewport.view.camera.eye);\n                if (toEye) { // Only if tile is not already behind the eye.\n                    toEye.scaleInPlace(radius);\n                    center.addInPlace(toEye);\n                }\n            }\n        }\n        const viewPt = this.worldToViewMap.transform0.multiplyPoint3dQuietNormalize(center);\n        const viewPt2 = new Point3d(viewPt.x + 1.0, viewPt.y, viewPt.z);\n        return this.worldToViewMap.transform1.multiplyPoint3dQuietNormalize(viewPt).distance(this.worldToViewMap.transform1.multiplyPoint3dQuietNormalize(viewPt2));\n    }\n    /** Compute this size of a sphere on screen in pixels */\n    getRangePixelSize(range) {\n        const transformedRange = this.location.multiplyRange(range, scratchRange);\n        const center = transformedRange.localXYZToWorld(.5, .5, .5, scratchPoint);\n        const radius = transformedRange.diagonal().magnitude();\n        const viewPt = this.worldToViewMap.transform0.multiplyPoint3dQuietNormalize(center);\n        const viewPt2 = new Point3d(viewPt.x + 1.0, viewPt.y, viewPt.z);\n        const pixelSizeAtPt = this.worldToViewMap.transform1.multiplyPoint3dQuietNormalize(viewPt).distance(this.worldToViewMap.transform1.multiplyPoint3dQuietNormalize(viewPt2));\n        return 0 !== pixelSizeAtPt ? radius / pixelSizeAtPt : 1.0e-3;\n    }\n    /** @internal */\n    getTileGraphics(tile) {\n        return tile.produceGraphics();\n    }\n    /** The planes of the viewing frustum, used for frustum culling. */\n    get frustumPlanes() {\n        return this._frustumPlanes !== undefined ? this._frustumPlanes : this.context.frustumPlanes;\n    }\n    /** Provides conversions between [[CoordSystem.World]] and [[CoordSystem.View]]. */\n    get worldToViewMap() {\n        return this.viewingSpace.worldToViewMap;\n    }\n    computePixelSizeScaleFactor() {\n        // Check to see if a model display transform with non-uniform scaling is being used.\n        const mat = this.context.viewport.view.modelDisplayTransformProvider?.getModelDisplayTransform(this.tree.modelId)?.matrix;\n        if (!mat)\n            return 1;\n        const scale = [0, 1, 2].map((x) => mat.getColumn(x).magnitude());\n        if (Math.abs(scale[0] - scale[1]) <= Geometry.smallMetricDistance && Math.abs(scale[0] - scale[2]) <= Geometry.smallMetricDistance)\n            return 1;\n        // If the component with the largest scale is not the same as the component with the largest tile range use it to adjust the pixel size.\n        const rangeDiag = this.tree.range.diagonal();\n        let maxS = 0;\n        let maxR = 0;\n        if (scale[0] > scale[1])\n            maxS = (scale[0] > scale[2] ? 0 : 2);\n        else\n            maxS = (scale[1] > scale[2] ? 1 : 2);\n        if (rangeDiag.x > rangeDiag.y)\n            maxR = (rangeDiag.x > rangeDiag.z ? 0 : 2);\n        else\n            maxR = (rangeDiag.y > rangeDiag.z ? 1 : 2);\n        return maxS !== maxR ? scale[maxS] : 1;\n    }\n    /** Constructor */\n    constructor(params) {\n        /** Holds the tile graphics to be drawn. */\n        this.graphics = new GraphicBranch();\n        /** Tiles that we want to draw and that are ready to draw. May not actually be selected, e.g. if sibling tiles are not yet ready. */\n        this.readyTiles = new Set();\n        /** Tiles whose contents should be kept in memory regardless of whether or not they are selected for display.\n         * @internal\n         */\n        this.touchedTiles = new Set();\n        const { location, tree, context, now, viewFlagOverrides, clipVolume, parentsAndChildrenExclusive, symbologyOverrides } = params;\n        this.location = location;\n        this.tree = tree;\n        this.context = context;\n        this.now = now;\n        this._appearanceProvider = params.appearanceProvider;\n        this.hiddenLineSettings = params.hiddenLineSettings;\n        this.animationTransformNodeId = params.animationTransformNodeId;\n        this.boundingRange = params.boundingRange;\n        this.maximumScreenSpaceError = params.maximumScreenSpaceError ?? 16; // 16 is Cesium's default.\n        // Do not cull tiles based on clip volume if tiles outside clip are supposed to be drawn but in a different color.\n        if (undefined !== clipVolume && !context.viewport.view.displayStyle.settings.clipStyle.outsideColor)\n            this.clipVolume = clipVolume;\n        this.graphics.setViewFlagOverrides(viewFlagOverrides);\n        this.graphics.symbologyOverrides = symbologyOverrides;\n        this.graphics.animationId = tree.modelId;\n        this.viewingSpace = context.viewingSpace;\n        this._frustumPlanes = FrustumPlanes.fromFrustum(this.viewingSpace.getFrustum());\n        this.planarClassifier = context.getPlanarClassifierForModel(tree.modelId);\n        this.drape = context.getTextureDrapeForModel(tree.modelId);\n        // NB: If the tile tree has its own clip, do not also apply the view's clip.\n        if (context.viewFlags.clipVolume && false !== viewFlagOverrides.clipVolume && undefined === clipVolume) {\n            const outsideClipColor = context.viewport.displayStyle.settings.clipStyle.outsideColor;\n            this.viewClip = undefined === outsideClipColor ? context.viewport.view.getViewClip() : undefined;\n        }\n        this.parentsAndChildrenExclusive = parentsAndChildrenExclusive;\n        if (context.viewport.isCameraOn)\n            this._nearFrontCenter = context.viewport.getFrustum(CoordSystem.World).frontCenter;\n        this.pixelSizeScaleFactor = this.computePixelSizeScaleFactor();\n    }\n    /** A multiplier applied to a [[Tile]]'s `maximumSize` property to adjust level of detail.\n     * @see [[Viewport.tileSizeModifier]].\n     * @public\n     */\n    get tileSizeModifier() { return this.context.viewport.tileSizeModifier; }\n    /** @internal */\n    getTileCenter(tile) { return this.location.multiplyPoint3d(tile.center); }\n    /** @internal */\n    getTileRadius(tile) {\n        let range = tile.range.clone(scratchRange);\n        if (tile.tree.is2d) {\n            // 2d tiles have a fixed Z range of [-1, 1]. Sometimes (e.g., hypermodeling) we draw them within a 3d view. Prevent Z from artificially expanding the radius.\n            range.low.z = range.high.z = 0;\n        }\n        range = this.location.multiplyRange(range, range);\n        return 0.5 * range.low.distance(range.high);\n    }\n    /** @internal */\n    get clip() {\n        return undefined !== this.clipVolume ? this.clipVolume.clipVector : undefined;\n    }\n    /** Add a provider to supplement or override the symbology overrides for the view.\n     * @note If a provider already exists, the new provider will be chained such that it sees the base overrides\n     * after they have potentially been modified by the existing provider.\n     * @public\n     */\n    addAppearanceProvider(provider) {\n        this._appearanceProvider = this._appearanceProvider ? FeatureAppearanceProvider.chain(this._appearanceProvider, provider) : provider;\n    }\n    /** Optionally customizes aspects of the view's [[FeatureSymbology.Overrides]]. */\n    get appearanceProvider() {\n        return this._appearanceProvider;\n    }\n    /** @internal */\n    produceGraphics() {\n        return this._produceGraphicBranch(this.graphics);\n    }\n    /** @internal */\n    get secondaryClassifiers() {\n        return undefined;\n    }\n    /** @internal */\n    _produceGraphicBranch(graphics) {\n        if (graphics.isEmpty)\n            return undefined;\n        const opts = {\n            iModel: this.tree.iModel,\n            clipVolume: this.clipVolume,\n            classifierOrDrape: this.planarClassifier ?? this.drape,\n            appearanceProvider: this.appearanceProvider,\n            hline: this.hiddenLineSettings,\n            secondaryClassifiers: this.secondaryClassifiers,\n        };\n        let graphic = this.context.createGraphicBranch(graphics, this.location, opts);\n        if (undefined !== this.animationTransformNodeId)\n            graphic = this.context.renderSystem.createAnimationTransformNode(graphic, this.animationTransformNodeId);\n        return graphic;\n    }\n    /** Output graphics for all accumulated tiles. */\n    drawGraphics() {\n        const graphics = this.produceGraphics();\n        if (undefined !== graphics)\n            this.context.outputGraphic(graphics);\n    }\n    /** Output graphics of the specified type for all accumulated tiles. */\n    drawGraphicsWithType(graphicType, graphics) {\n        const branch = this._produceGraphicBranch(graphics);\n        if (undefined !== branch)\n            this.context.withGraphicType(graphicType, () => this.context.outputGraphic(branch));\n    }\n    /** Indicate that graphics for the specified tile are desired but not yet available. Subsequently a request will be enqueued to load the tile's graphics. */\n    insertMissing(tile) {\n        this.context.insertMissingTile(tile);\n    }\n    /** Indicate that some requested child tiles are not yet loaded. */\n    markChildrenLoading() {\n        this.context.markChildrenLoading();\n    }\n    /** Indicate that the specified tile is being used for some purpose by the [[SceneContext]]'s [[Viewport]]. Typically \"used\" means \"displayed\", but the exact meaning is up to the [[TileTree]] - for example, \"used\" might also mean that the tile's children are being used. A tile that is \"in use\" by any [[Viewport]] will not be discarded. */\n    markUsed(tile) {\n        tile.usageMarker.mark(this.context.viewport, this.now);\n    }\n    /** Indicate that the specified tile should be displayed and that its graphics are ready to be displayed. The number of \"ready\" tiles is used in conjunction with the number of \"missing\" tiles to convey to the user how complete the current view is.\n     * @see [[insertMissing]]\n     */\n    markReady(tile) {\n        this.readyTiles.add(tile);\n    }\n    /** Invoked by [[TileTree.selectTiles]]. This exists chiefly for [[SolarShadowMap]].\n     * @internal\n     */\n    processSelectedTiles(_tiles) { }\n    /* @internal */\n    get maxRealityTreeSelectionCount() { return undefined; }\n}\n//# sourceMappingURL=TileDrawArgs.js.map",
      "start": 1693508121404,
      "end": 1693508121602,
      "sourcemaps": null
    }
  ]
}
