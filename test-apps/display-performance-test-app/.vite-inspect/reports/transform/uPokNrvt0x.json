{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/curve/CoordinateXYZ.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import { Point3d } from \"../geometry3d/Point3dVector3d\";\nimport { Range3d } from \"../geometry3d/Range\";\nimport { GeometryQuery } from \"./GeometryQuery\";\n/**\n * A Coordinate is a Point3d with supporting methods from the GeometryQuery abstraction.\n * @public\n */\nexport class CoordinateXYZ extends GeometryQuery {\n    /** Return a (REFERENCE TO) the coordinate data. */\n    get point() { return this._xyz; }\n    /**\n     * @param xyz point to be CAPTURED.\n     */\n    constructor(xyz) {\n        super();\n        /** String name for interface properties */\n        this.geometryCategory = \"point\";\n        this._xyz = xyz;\n    }\n    /** Create a new CoordinateXYZ containing a CLONE of point */\n    static create(point) {\n        return new CoordinateXYZ(point.clone());\n    }\n    /** Create a new CoordinateXYZ */\n    static createXYZ(x = 0, y = 0, z = 0) {\n        return new CoordinateXYZ(Point3d.create(x, y, z));\n    }\n    /** Return the range of the point */\n    range() { return Range3d.create(this._xyz); }\n    /** Extend `rangeToExtend` to include this point (optionally transformed) */\n    extendRange(rangeToExtend, transform) {\n        if (transform)\n            rangeToExtend.extendTransformedXYZ(transform, this._xyz.x, this._xyz.y, this._xyz.z);\n        else\n            rangeToExtend.extend(this._xyz);\n    }\n    /** Apply transform to the Coordinate's point. */\n    tryTransformInPlace(transform) {\n        transform.multiplyPoint3d(this._xyz, this._xyz);\n        return true;\n    }\n    /** Return a transformed clone */\n    cloneTransformed(transform) {\n        const result = new CoordinateXYZ(this._xyz.clone());\n        result.tryTransformInPlace(transform);\n        return result;\n    }\n    /** Return a clone */\n    clone() {\n        return new CoordinateXYZ(this._xyz.clone());\n    }\n    /**\n     * Return GeometryQuery children for recursive queries.\n     * * Leaf classes do not need to implement.\n     */\n    /** Test if (other instanceof Coordinate).  */\n    isSameGeometryClass(other) {\n        return other instanceof CoordinateXYZ;\n    }\n    /**\n     * Test for exact structure and nearly identical geometry.\n     * *  Leaf classes must implement !!!\n     * *  Base class implementation recurses through children.\n     * *  Base implementation is complete for classes with children and no properties.\n     * *  Classes with both children and properties must implement for properties, call super for children.\n     */\n    isAlmostEqual(other) {\n        return (other instanceof CoordinateXYZ) && this._xyz.isAlmostEqual(other._xyz);\n    }\n    /** Second step of double dispatch:  call `handler.handleCoordinateXYZ(this)` */\n    dispatchToGeometryHandler(handler) {\n        return handler.handleCoordinateXYZ(this);\n    }\n}\n//# sourceMappingURL=CoordinateXYZ.js.map",
      "start": 1693508122658,
      "end": 1693508122802,
      "sourcemaps": null
    }
  ]
}
