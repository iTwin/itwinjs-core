{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tile/RealityTileTree.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tiles\n */\nimport { assert, BeTimePoint, ProcessDetector } from \"@itwin/core-bentley\";\nimport { Matrix3d, Point3d, Range3d, Transform, Vector3d, } from \"@itwin/core-geometry\";\nimport { Cartographic, ColorDef, GeoCoordStatus } from \"@itwin/core-common\";\nimport { BackgroundMapGeometry } from \"../BackgroundMapGeometry\";\nimport { IModelApp } from \"../IModelApp\";\nimport { GraphicBranch } from \"../render/GraphicBranch\";\nimport { GraphicsCollectorDrawArgs, MapTile, RealityTile, TileTree, } from \"./internal\";\n/** @internal */\nexport class TraversalDetails {\n    constructor() {\n        this.queuedChildren = new Array();\n        this.childrenSelected = false;\n        this.shouldSelectParent = false;\n    }\n    initialize() {\n        this.queuedChildren.length = 0;\n        this.childrenSelected = false;\n        this.shouldSelectParent = false;\n    }\n}\n/** @internal */\nexport class TraversalChildrenDetails {\n    constructor() {\n        this._childDetails = [];\n    }\n    initialize() {\n        for (const child of this._childDetails)\n            child.initialize();\n    }\n    getChildDetail(index) {\n        while (this._childDetails.length <= index)\n            this._childDetails.push(new TraversalDetails());\n        return this._childDetails[index];\n    }\n    combine(parentDetails) {\n        parentDetails.queuedChildren.length = 0;\n        parentDetails.childrenSelected = false;\n        parentDetails.shouldSelectParent = false;\n        for (const child of this._childDetails) {\n            parentDetails.childrenSelected = parentDetails.childrenSelected || child.childrenSelected;\n            parentDetails.shouldSelectParent = parentDetails.shouldSelectParent || child.shouldSelectParent;\n            for (const queuedChild of child.queuedChildren)\n                parentDetails.queuedChildren.push(queuedChild);\n        }\n    }\n}\n/** @internal */\nexport class TraversalSelectionContext {\n    get selectionCountExceeded() { return this._maxSelectionCount === undefined ? false : (this.missing.length + this.selected.length) > this._maxSelectionCount; } // Avoid selecting excessive number of tiles.\n    constructor(selected, displayedDescendants, preloadDebugBuilder, _maxSelectionCount) {\n        this.selected = selected;\n        this.displayedDescendants = displayedDescendants;\n        this.preloadDebugBuilder = preloadDebugBuilder;\n        this._maxSelectionCount = _maxSelectionCount;\n        this.preloaded = new Set();\n        this.missing = new Array();\n    }\n    selectOrQueue(tile, args, traversalDetails) {\n        tile.selectSecondaryTiles(args, this);\n        tile.markUsed(args);\n        traversalDetails.shouldSelectParent = true;\n        if (tile.isReady) {\n            args.markReady(tile);\n            this.selected.push(tile);\n            tile.markDisplayed();\n            this.displayedDescendants.push((traversalDetails.childrenSelected) ? traversalDetails.queuedChildren.slice() : []);\n            traversalDetails.queuedChildren.length = 0;\n            traversalDetails.childrenSelected = true;\n            traversalDetails.shouldSelectParent = false;\n        }\n        else if (!tile.isNotFound) {\n            traversalDetails.queuedChildren.push(tile);\n            if (!tile.isLoaded)\n                this.missing.push(tile);\n        }\n    }\n    preload(tile, args) {\n        if (!this.preloaded.has(tile)) {\n            if (this.preloadDebugBuilder)\n                tile.addBoundingGraphic(this.preloadDebugBuilder, ColorDef.red);\n            tile.markUsed(args);\n            tile.selectSecondaryTiles(args, this);\n            this.preloaded.add(tile);\n            if (!tile.isNotFound && !tile.isLoaded)\n                this.missing.push(tile);\n        }\n    }\n    select(tiles, args) {\n        for (const tile of tiles) {\n            tile.markUsed(args);\n            this.selected.push(tile);\n            this.displayedDescendants.push([]);\n        }\n    }\n}\nconst scratchCarto = Cartographic.createZero();\nconst scratchPoint = Point3d.createZero(), scratchOrigin = Point3d.createZero();\nconst scratchRange = Range3d.createNull();\nconst scratchX = Vector3d.createZero(), scratchY = Vector3d.createZero(), scratchZ = Vector3d.createZero();\nconst scratchMatrix = Matrix3d.createZero(), scratchTransform = Transform.createZero();\n/** Base class for a [[TileTree]] representing a reality model (e.g., a point cloud or photogrammetry mesh) or 3d terrain with map imagery.\n * The tiles within the tree are instances of [[RealityTile]]s.\n * @public\n */\nexport class RealityTileTree extends TileTree {\n    /** @internal */\n    constructor(params) {\n        super(params);\n        /** @internal */\n        this.traversalChildrenByDepth = [];\n        this.loader = params.loader;\n        this.yAxisUp = true === params.yAxisUp;\n        this._rootTile = this.createTile(params.rootTile);\n        this.cartesianRange = BackgroundMapGeometry.getCartesianRange(this.iModel);\n        this.cartesianTransitionDistance = this.cartesianRange.diagonal().magnitudeXY() * .25; // Transition distance from elliptical to cartesian.\n        this._gcsConverter = params.gcsConverterAvailable ? params.iModel.geoServices.getConverter(\"WGS84\") : undefined;\n        if (params.rootToEcef) {\n            this._rootToEcef = params.rootToEcef;\n            const dbToRoot = this.iModelTransform.inverse();\n            if (dbToRoot) {\n                const dbToEcef = this._rootToEcef.multiplyTransformTransform(dbToRoot);\n                this._ecefToDb = dbToEcef.inverse();\n            }\n        }\n    }\n    /** @internal */\n    get rootTile() { return this._rootTile; }\n    /** @internal */\n    get is3d() { return true; }\n    /** @internal */\n    get maxDepth() { return this.loader.maxDepth; }\n    /** @internal */\n    get minDepth() { return this.loader.minDepth; }\n    /** @internal */\n    get isContentUnbounded() { return this.loader.isContentUnbounded; }\n    /** @internal */\n    get isTransparent() { return false; }\n    /** @internal */\n    _selectTiles(args) { return this.selectRealityTiles(args, []); }\n    /** @internal */\n    get viewFlagOverrides() { return this.loader.viewFlagOverrides; }\n    /** @internal */\n    get parentsAndChildrenExclusive() { return this.loader.parentsAndChildrenExclusive; }\n    /** @internal */\n    createTile(props) { return new RealityTile(props, this); }\n    /** Collect tiles from this tile tree based on the criteria implemented by `collector`.\n     * @internal\n     */\n    collectTileGeometry(collector) {\n        this.rootTile.collectTileGeometry(collector);\n    }\n    /** @internal */\n    prune() {\n        const olderThan = BeTimePoint.now().minus(this.expirationTime);\n        this.rootTile.purgeContents(olderThan, !ProcessDetector.isMobileBrowser);\n    }\n    /** @internal */\n    draw(args) {\n        const displayedTileDescendants = new Array();\n        const debugControl = args.context.target.debugControl;\n        const selectBuilder = (debugControl && debugControl.displayRealityTileRanges) ? args.context.createSceneGraphicBuilder() : undefined;\n        const preloadDebugBuilder = (debugControl && debugControl.displayRealityTilePreload) ? args.context.createSceneGraphicBuilder() : undefined;\n        const graphicTypeBranches = new Map();\n        const selectedTiles = this.selectRealityTiles(args, displayedTileDescendants, preloadDebugBuilder);\n        args.processSelectedTiles(selectedTiles);\n        let sortIndices;\n        if (!this.parentsAndChildrenExclusive) {\n            sortIndices = selectedTiles.map((_x, i) => i);\n            sortIndices.sort((a, b) => selectedTiles[a].depth - selectedTiles[b].depth);\n        }\n        if (!(args instanceof GraphicsCollectorDrawArgs))\n            this.collectClassifierGraphics(args, selectedTiles);\n        assert(selectedTiles.length === displayedTileDescendants.length);\n        for (let i = 0; i < selectedTiles.length; i++) {\n            const index = sortIndices ? sortIndices[i] : i;\n            const selectedTile = selectedTiles[index];\n            const graphics = args.getTileGraphics(selectedTile);\n            const tileGraphicType = selectedTile.graphicType;\n            let targetBranch;\n            if (undefined !== tileGraphicType && tileGraphicType !== args.context.graphicType) {\n                if (!(targetBranch = graphicTypeBranches.get(tileGraphicType))) {\n                    graphicTypeBranches.set(tileGraphicType, targetBranch = new GraphicBranch(false));\n                    targetBranch.setViewFlagOverrides(args.graphics.viewFlagOverrides);\n                    targetBranch.symbologyOverrides = args.graphics.symbologyOverrides;\n                }\n            }\n            if (!targetBranch)\n                targetBranch = args.graphics;\n            if (undefined !== graphics) {\n                const displayedDescendants = displayedTileDescendants[index];\n                if (0 === displayedDescendants.length || !this.loader.parentsAndChildrenExclusive || selectedTile.allChildrenIncluded(displayedDescendants)) {\n                    targetBranch.add(graphics);\n                    if (selectBuilder)\n                        selectedTile.addBoundingGraphic(selectBuilder, ColorDef.green);\n                }\n                else {\n                    if (selectBuilder)\n                        selectedTile.addBoundingGraphic(selectBuilder, ColorDef.red);\n                    for (const displayedDescendant of displayedDescendants) {\n                        const clipVector = displayedDescendant.getContentClip();\n                        if (selectBuilder)\n                            displayedDescendant.addBoundingGraphic(selectBuilder, ColorDef.blue);\n                        if (undefined === clipVector) {\n                            targetBranch.add(graphics);\n                        }\n                        else {\n                            clipVector.transformInPlace(args.location);\n                            if (!this.isTransparent)\n                                for (const primitive of clipVector.clips)\n                                    for (const clipPlanes of primitive.fetchClipPlanesRef().convexSets)\n                                        for (const plane of clipPlanes.planes)\n                                            plane.offsetDistance(-displayedDescendant.radius * .05); // Overlap with existing (high resolution) tile slightly to avoid cracks.\n                            const branch = new GraphicBranch(false);\n                            branch.add(graphics);\n                            const clipVolume = args.context.target.renderSystem.createClipVolume(clipVector);\n                            targetBranch.add(args.context.createGraphicBranch(branch, Transform.createIdentity(), { clipVolume }));\n                        }\n                    }\n                }\n                if (preloadDebugBuilder)\n                    targetBranch.add(preloadDebugBuilder.finish());\n                if (selectBuilder)\n                    targetBranch.add(selectBuilder.finish());\n                const rangeGraphic = selectedTile.getRangeGraphic(args.context);\n                if (undefined !== rangeGraphic)\n                    targetBranch.add(rangeGraphic);\n            }\n        }\n        args.drawGraphics();\n        for (const graphicTypeBranch of graphicTypeBranches) {\n            args.drawGraphicsWithType(graphicTypeBranch[0], graphicTypeBranch[1]);\n        }\n    }\n    /** @internal */\n    collectClassifierGraphics(args, selectedTiles) {\n        const classifier = args.context.planarClassifiers.get(this.modelId);\n        if (classifier)\n            classifier.collectGraphics(args.context, { modelId: this.modelId, tiles: selectedTiles, location: args.location, isPointCloud: this.isPointCloud });\n    }\n    /** @internal */\n    getTraversalChildren(depth) {\n        while (this.traversalChildrenByDepth.length <= depth)\n            this.traversalChildrenByDepth.push(new TraversalChildrenDetails());\n        return this.traversalChildrenByDepth[depth];\n    }\n    /** @internal */\n    doReprojectChildren(tile) {\n        if (!(tile instanceof RealityTile) || this._gcsConverter === undefined || this._rootToEcef === undefined || undefined === this._ecefToDb)\n            return false;\n        const tileRange = this.iModelTransform.isIdentity ? tile.range : this.iModelTransform.multiplyRange(tile.range, scratchRange);\n        return this.cartesianRange.intersectsRange(tileRange);\n    }\n    /** @internal */\n    reprojectAndResolveChildren(parent, children, resolve) {\n        if (!this.doReprojectChildren(parent)) {\n            resolve(children);\n            return;\n        }\n        const ecefToDb = this._ecefToDb; // Tested for undefined in doReprojectChildren\n        const rootToDb = this.iModelTransform;\n        const dbToEcef = ecefToDb.inverse();\n        const reprojectChildren = new Array();\n        for (const child of children) {\n            const realityChild = child;\n            const childRange = rootToDb.multiplyRange(realityChild.contentRange, scratchRange);\n            const dbCenter = childRange.center;\n            const ecefCenter = dbToEcef.multiplyPoint3d(dbCenter);\n            const dbPoints = [dbCenter, dbCenter.plusXYZ(1), dbCenter.plusXYZ(0, 1), dbCenter.plusXYZ(0, 0, 1)];\n            reprojectChildren.push({ child: realityChild, ecefCenter, dbPoints });\n        }\n        if (reprojectChildren.length === 0)\n            resolve(children);\n        else {\n            const requestProps = new Array();\n            for (const reprojection of reprojectChildren) {\n                for (const dbPoint of reprojection.dbPoints) {\n                    const ecefPoint = dbToEcef.multiplyPoint3d(dbPoint);\n                    const carto = Cartographic.fromEcef(ecefPoint, scratchCarto);\n                    if (carto)\n                        requestProps.push({ x: carto.longitudeDegrees, y: carto.latitudeDegrees, z: carto.height });\n                }\n            }\n            if (requestProps.length !== 4 * reprojectChildren.length)\n                resolve(children);\n            else {\n                this._gcsConverter.getIModelCoordinatesFromGeoCoordinates(requestProps).then((response) => {\n                    const reprojectedCoords = response.iModelCoords;\n                    const dbToRoot = rootToDb.inverse();\n                    const getReprojectedPoint = (original, reprojectedXYZ) => {\n                        scratchPoint.setFromJSON(reprojectedXYZ);\n                        const cartesianDistance = this.cartesianRange.distanceToPoint(scratchPoint);\n                        if (cartesianDistance < this.cartesianTransitionDistance)\n                            return scratchPoint.interpolate(cartesianDistance / this.cartesianTransitionDistance, original, scratchPoint);\n                        else\n                            return original;\n                    };\n                    let responseIndex = 0;\n                    for (const reprojection of reprojectChildren) {\n                        if (reprojectedCoords.every((coord) => coord.s === GeoCoordStatus.Success)) {\n                            const reprojectedOrigin = getReprojectedPoint(reprojection.dbPoints[0], reprojectedCoords[responseIndex++].p).clone(scratchOrigin);\n                            const xVector = Vector3d.createStartEnd(reprojectedOrigin, getReprojectedPoint(reprojection.dbPoints[1], reprojectedCoords[responseIndex++].p), scratchX);\n                            const yVector = Vector3d.createStartEnd(reprojectedOrigin, getReprojectedPoint(reprojection.dbPoints[2], reprojectedCoords[responseIndex++].p), scratchY);\n                            const zVector = Vector3d.createStartEnd(reprojectedOrigin, getReprojectedPoint(reprojection.dbPoints[3], reprojectedCoords[responseIndex++].p), scratchZ);\n                            const matrix = Matrix3d.createColumns(xVector, yVector, zVector, scratchMatrix);\n                            if (matrix !== undefined) {\n                                const dbReprojection = Transform.createMatrixPickupPutdown(matrix, reprojection.dbPoints[0], reprojectedOrigin, scratchTransform);\n                                if (dbReprojection) {\n                                    const rootReprojection = dbToRoot.multiplyTransformTransform(dbReprojection).multiplyTransformTransform(rootToDb);\n                                    reprojection.child.reproject(rootReprojection);\n                                }\n                            }\n                        }\n                    }\n                    resolve(children);\n                }).catch(() => {\n                    resolve(children); // Error occured in reprojection - just resolve with unprojected corners.\n                });\n            }\n        }\n    }\n    /** @internal */\n    getBaseRealityDepth(_sceneContext) { return -1; }\n    /** Scan the list of currently selected reality tiles, and fire the viewport's 'onMapLayerScaleRangeVisibilityChanged ' event\n     * if any scale range visibility change is detected for one more map-layer definition.\n     * @internal\n     */\n    reportTileVisibility(_args, _selected) { }\n    /** @internal */\n    selectRealityTiles(args, displayedDescendants, preloadDebugBuilder) {\n        this._lastSelected = BeTimePoint.now();\n        const selected = [];\n        const context = new TraversalSelectionContext(selected, displayedDescendants, preloadDebugBuilder, args.maxRealityTreeSelectionCount);\n        const rootTile = this.rootTile;\n        const debugControl = args.context.target.debugControl;\n        const freezeTiles = debugControl && debugControl.freezeRealityTiles;\n        rootTile.selectRealityTiles(context, args, new TraversalDetails());\n        const baseDepth = this.getBaseRealityDepth(args.context);\n        if (!args.context.target.renderSystem.isMobile && 0 === context.missing.length) { // We skip preloading on mobile devices.\n            if (baseDepth > 0) // Maps may force loading of low level globe tiles.\n                rootTile.preloadRealityTilesAtDepth(baseDepth, context, args);\n            if (!freezeTiles)\n                rootTile.preloadProtectedTiles(args, context);\n        }\n        if (!freezeTiles)\n            for (const tile of context.missing) {\n                const loadableTile = tile.loadableTile;\n                loadableTile.markUsed(args);\n                args.insertMissing(loadableTile);\n            }\n        if (debugControl && debugControl.logRealityTiles) {\n            this.logTiles(\"Selected: \", selected.values());\n            const preloaded = [];\n            for (const tile of context.preloaded)\n                preloaded.push(tile);\n            this.logTiles(\"Preloaded: \", preloaded.values());\n            this.logTiles(\"Missing: \", context.missing.values());\n            const imageryTiles = [];\n            for (const selectedTile of selected) {\n                if (selectedTile instanceof MapTile) {\n                    const selectedImageryTiles = (selectedTile).imageryTiles;\n                    if (selectedImageryTiles)\n                        selectedImageryTiles.forEach((tile) => imageryTiles.push(tile));\n                }\n            }\n            if (imageryTiles.length)\n                this.logTiles(\"Imagery:\", imageryTiles.values());\n        }\n        this.reportTileVisibility(args, selected);\n        IModelApp.tileAdmin.addTilesForUser(args.context.viewport, selected, args.readyTiles, args.touchedTiles);\n        return selected;\n    }\n    /** @internal */\n    logTiles(label, tiles) {\n        let depthString = \"\";\n        let min = 10000, max = -10000;\n        let count = 0;\n        const depthMap = new Map();\n        for (const tile of tiles) {\n            count++;\n            const depth = tile.depth;\n            min = Math.min(min, tile.depth);\n            max = Math.max(max, tile.depth);\n            const found = depthMap.get(depth);\n            depthMap.set(depth, found === undefined ? 1 : found + 1);\n        }\n        depthMap.forEach((value, key) => depthString += `${key}(x${value}), `);\n        // eslint-disable-next-line no-console\n        console.log(`${label}: ${count} Min: ${min} Max: ${max} Depths: ${depthString}`);\n    }\n}\n//# sourceMappingURL=RealityTileTree.js.map",
      "start": 1693508121525,
      "end": 1693508121623,
      "sourcemaps": null
    }
  ]
}
