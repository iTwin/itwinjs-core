{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/common/lib/esm/FeatureSymbology.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Rendering\n */\nimport { assert, Id64 } from \"@itwin/core-bentley\";\nimport { BatchType } from \"./FeatureTable\";\nimport { GeometryClass } from \"./GeometryParams\";\nimport { RgbColor } from \"./RgbColor\";\nfunction copyIdSetToUint32Set(dst, src) {\n    dst.clear();\n    if (typeof src === \"string\") {\n        dst.addId(src);\n    }\n    else {\n        for (const id of src)\n            dst.addId(id);\n    }\n}\n/** Defines overrides for selected aspects of a [[Feature]]'s symbology.\n * Any member defined in the appearance overrides that aspect of symbology for all [[Feature]]s to which the appearance is applied.\n * @see [[FeatureOverrides]] to customize the appearance of multiple features.\n * @public\n */\nclass FeatureAppearance {\n    static fromJSON(props) {\n        if (undefined === props || (undefined === props.rgb && undefined === props.weight && undefined === props.transparency && undefined === props.linePixels && !props.ignoresMaterial && !props.nonLocatable && !props.emphasized))\n            return this.defaults;\n        else\n            return new FeatureAppearance(props);\n    }\n    /** Create a FeatureAppearance that overrides only the RGB color.\n     * @note The transparency component of the ColorDef is ignored.\n     */\n    static fromRgb(color) {\n        return this.fromJSON({ rgb: RgbColor.fromColorDef(color) });\n    }\n    /** Create a FeatureAppearance that overrides the RGB and transparency.\n     * The appearance's transparency is derived from the transparency component of the ColorDef.\n     */\n    static fromRgba(color, viewDependentTransparency = false) {\n        return this.fromJSON({\n            rgb: RgbColor.fromColorDef(color),\n            transparency: color.colors.t / 255,\n            viewDependentTransparency: viewDependentTransparency ? true : undefined,\n        });\n    }\n    /** Create a FeatureAppearance that overrides only the transparency */\n    static fromTransparency(transparencyValue, viewDependent = false) {\n        return this.fromJSON({\n            transparency: transparencyValue,\n            viewDependentTransparency: viewDependent ? true : undefined,\n        });\n    }\n    /** Create a FeatureAppearance with overrides corresponding to those defined by the supplied SubCategoryOverride.\n     * @note Subcategory overrides set [[viewDependentTransparency]] to `true`.\n     */\n    static fromSubCategoryOverride(ovr) {\n        const rgb = undefined !== ovr.color ? RgbColor.fromColorDef(ovr.color) : undefined;\n        const transparency = ovr.transparency;\n        const weight = ovr.weight;\n        const ignoresMaterial = undefined !== ovr.material && Id64.isValid(ovr.material) ? true : undefined;\n        return this.fromJSON({ rgb, transparency, weight, ignoresMaterial, viewDependentTransparency: true });\n    }\n    /** Returns true if this appearance does not override any aspects of symbology. */\n    get matchesDefaults() {\n        return this.equals(FeatureAppearance.defaults);\n    }\n    get overridesRgb() { return undefined !== this.rgb; }\n    get overridesTransparency() { return undefined !== this.transparency; }\n    get overridesLinePixels() { return undefined !== this.linePixels; }\n    get overridesWeight() { return undefined !== this.weight; }\n    get overridesSymbology() {\n        return this.overridesRgb || this.overridesTransparency || this.overridesWeight || this.overridesLinePixels || !!this.ignoresMaterial\n            || this.emphasized || this.overridesNonLocatable;\n    }\n    get overridesNonLocatable() { return undefined !== this.nonLocatable; }\n    get isFullyTransparent() { return undefined !== this.transparency && this.transparency >= 1.0; }\n    /** Returns true if any aspect of the appearance is overridden (i.e., if any member is not undefined). */\n    get anyOverridden() { return this.overridesSymbology || this.overridesNonLocatable; }\n    equals(other) {\n        if (this === other)\n            return true;\n        return this.rgbIsEqual(other.rgb)\n            && this.weight === other.weight\n            && this.transparencyIsEqual(other.transparency)\n            && this.linePixels === other.linePixels\n            && this.ignoresMaterial === other.ignoresMaterial\n            && this.nonLocatable === other.nonLocatable\n            && this.emphasized === other.emphasized\n            && this.viewDependentTransparency === other.viewDependentTransparency;\n    }\n    toJSON() {\n        const props = {};\n        if (this.rgb)\n            props.rgb = this.rgb.toJSON();\n        if (undefined !== this.weight)\n            props.weight = this.weight;\n        if (undefined !== this.transparency) {\n            props.transparency = this.transparency;\n            if (this.viewDependentTransparency)\n                props.viewDependentTransparency = true;\n        }\n        if (undefined !== this.linePixels)\n            props.linePixels = this.linePixels;\n        if (true === this.ignoresMaterial)\n            props.ignoresMaterial = true;\n        if (true === this.nonLocatable)\n            props.nonLocatable = true;\n        if (true === this.emphasized)\n            props.emphasized = true;\n        return props;\n    }\n    /** Convert this appearance to JSON, and override any properties explicitly specified by `changedProps` in the result.\n     * Example:\n     * ```ts\n     *  const base = FeatureAppearance.fromRgba(ColorDef.white); // transparency=0, rgb=white\n     *  const clone = base.cloneProps({ transparency: undefined, weight: 5 }); // transparency=undefined, rgb=white, weight=5\n     * ```\n     * @see [[FeatureAppearance.clone]].\n     */\n    cloneProps(changedProps) {\n        return {\n            ...this.toJSON(),\n            ...changedProps,\n        };\n    }\n    /** Create a copy of this appearance, overriding any properties explicitly specified by `changedProps`.\n     * Example:\n     * ```ts\n     *  const base = FeatureAppearance.fromRgba(ColorDef.white); // transparency=0, rgb=white\n     *  const clone = base.clone({ transparency: undefined, weight: 5 }); // transparency=undefined, rgb=white, weight=5\n     * ```\n     * @see [[FeatureAppearance.cloneProps]].\n     */\n    clone(changedProps) {\n        return FeatureAppearance.fromJSON(this.cloneProps(changedProps));\n    }\n    /** Produce a FeatureAppearance from the supplied appearance in which any aspect not defined by the base appearance is overridden by this appearance. */\n    extendAppearance(base) {\n        if (!this.overridesSymbology)\n            return base;\n        const props = base.toJSON();\n        if (undefined === props.rgb)\n            props.rgb = this.rgb;\n        if (undefined === props.transparency)\n            props.transparency = this.transparency;\n        if (undefined === props.linePixels)\n            props.linePixels = this.linePixels;\n        if (undefined === props.weight)\n            props.weight = this.weight;\n        if (undefined === props.ignoresMaterial && this.ignoresMaterial)\n            props.ignoresMaterial = true;\n        if (undefined === props.nonLocatable && this.nonLocatable)\n            props.nonLocatable = true;\n        if (undefined === props.emphasized && this.emphasized)\n            props.emphasized = true;\n        if (undefined !== props.transparency && this.viewDependentTransparency)\n            props.viewDependentTransparency = true;\n        return FeatureAppearance.fromJSON(props);\n    }\n    constructor(props) {\n        this.rgb = undefined !== props.rgb ? RgbColor.fromJSON(props.rgb) : undefined;\n        this.weight = props.weight;\n        this.transparency = props.transparency;\n        this.linePixels = props.linePixels;\n        this.ignoresMaterial = props.ignoresMaterial;\n        this.nonLocatable = props.nonLocatable;\n        this.emphasized = props.emphasized;\n        if (undefined !== this.weight)\n            this.weight = Math.max(1, Math.min(this.weight, 32));\n        if (undefined !== this.transparency) {\n            if (props.viewDependentTransparency)\n                this.viewDependentTransparency = true;\n            this.transparency = Math.max(0, Math.min(this.transparency, 1));\n            // Fix up rounding errors...\n            const smallDelta = 0.0001;\n            if (1.0 - this.transparency < smallDelta)\n                this.transparency = 1.0;\n            else if (this.transparency < smallDelta)\n                this.transparency = 0.0;\n        }\n    }\n    rgbIsEqual(rgb) {\n        if (undefined === this.rgb)\n            return undefined === rgb;\n        else if (undefined === rgb)\n            return false;\n        else\n            return this.rgb.equals(rgb);\n    }\n    transparencyIsEqual(transp) {\n        if (undefined === this.transparency)\n            return undefined === transp;\n        else if (undefined === transp)\n            return false;\n        else\n            return Math.floor(this.transparency * 0xff) === Math.floor(transp * 0xff);\n    }\n}\n/** An appearance that overrides nothing. */\nFeatureAppearance.defaults = new FeatureAppearance({});\nexport { FeatureAppearance };\nconst scratchIgnoreAnimationOverridesArgs = {\n    elementId: { lower: 0, upper: 0 },\n    animationNodeId: 0,\n};\n/** Specifies how to customize the appearance of individual [[Feature]]s, typically within the context of a [Viewport]($frontend).\n * Individual aspects of a feature's appearance - like visibility, color, and transparency - are overridden by supplying a [[FeatureAppearance]].\n * Those overrides can be specified on the basis of the feature's model, element, and/or subcategory. A default set of overrides can also be specified to\n * apply to the appearance of any feature not otherwise overridden.\n *\n * It is possible to override multiple aspects of a feature on different bases. For example, you might specify that all features belonging to subcategory \"A\" should be drawn in red,\n * and that all features belonging to model \"B\" should be drawn 50% transparent. In this case, a feature belonging to both subcategory \"A\" and model \"B\" will be drawn as 50% transparent red -\n * the separate overrides are combined to produce the feature's overall appearance.\n *\n * In the case of conflicts, there is an order of precedence:\n *  - Model overrides take highest precedence.\n *  - Element overrides are of higher precedence than subcategory and animation overrides.\n *  - Overrides applied by a [[RenderSchedule.Script]]'s [[RenderSchedule.ElementTimeline]] are of higher precedence than subcategory overrides, but can be suppressed on a per-element basis via [[ignoreAnimationOverrides]].\n *  - Subcategory overrides have lowest precedence.\n *\n * For example, you might specify that all features belonging to subcategory \"A\" should be drawn in red, and all those belonging to model \"B\" should be drawn in green.\n * Then a feature belonging to subcategory \"A\" and model \"B\" will be drawn in green, because the model overrides take precedence.\n *\n * Instances of this class are not typically instantiated by an application directly; instead, an application can implement a [FeatureOverrideProvider]($frontend)\n * that augments the overrides supplied by a viewport.\n *\n * @see [FeatureSymbology.Overrides]($frontend) to create overrides specific to a [Viewport]($frontend) or [ViewState]($frontend).\n * @see [FeatureOverrideProvider]($frontend) to customize the appearance of features within a [Viewport]($frontend).\n * @public\n */\nclass FeatureOverrides {\n    /** Accepts a criterion that determines whether color and transparency overrides originating from the view's [[RenderSchedule.Script]] should be ignored for a given element.\n     * The function receives a description of the element in question and returns `true` if the script's overrides should be ignored.\n     * Any number of such functions can be registered; if any one of them returns `true`, the script's overrides are not applied to the specified element.\n     *\n     * For example, applications commonly emphasize a set of elements by applying a [[FeatureAppearance.emphasized]] override to them, and specifying a highly-transparent\n     * default appearance to de-emphasize the rest of the elements in the view. If some of the de-emphasized elements' appearances are also being overridden by the schedule script, then\n     * they won't appear de-emphasized, making it difficult for the emphasized elements to stand out. In situations like this, [FeatureOverrideProvider]($frontend)s like [EmphasizeElements]($frontend) can register an [[IgnoreAnimationOverrides]] function that returns true if the element in question is not in the set of emphasized elements.\n     */\n    ignoreAnimationOverrides(ignore) {\n        this._ignoreAnimationOverrides.push(ignore);\n    }\n    /** Overrides applied to features for which no other overrides are defined */\n    get defaultOverrides() { return this._defaultOverrides; }\n    /** Whether or not line weights are applied. If false, all lines are drawn with a weight of 1. */\n    get lineWeights() { return this._lineWeights; }\n    /** A set of elements that are always invisible.\n     * @note If an element is present in both `alwaysDrawn` and [[neverDrawn]], it will not be displayed - `neverDrawn` takes precedence.\n     */\n    get neverDrawn() { return this._neverDrawn; }\n    /** A set of elements that are unconditionally displayed.\n     * @see [[isAlwaysDrawnExclusive]] to specify that *only* elements in this set will be displayed.\n     * @note If an element is present in both `alwaysDrawn` and [[neverDrawn]], it will not be displayed - `neverDrawn` takes precedence.\n     */\n    get alwaysDrawn() { return this._alwaysDrawn; }\n    /** @internal */\n    isNeverDrawn(elemIdLo, elemIdHi, animationNodeId) {\n        if (this._neverDrawn.has(elemIdLo, elemIdHi))\n            return true;\n        else\n            return this.neverDrawnAnimationNodes.has(animationNodeId);\n    }\n    /** @internal */\n    isAlwaysDrawn(idLo, idHi) { return this._alwaysDrawn.has(idLo, idHi); }\n    /** Returns true if the [SubCategory]($backend) specified by Id is in the set of visible subcategories. @internal */\n    isSubCategoryVisible(idLo, idHi) { return this._visibleSubCategories.has(idLo, idHi); }\n    /** @internal */\n    isSubCategoryVisibleInModel(subcatLo, subcatHi, modelLo, modelHi) {\n        if (this.ignoreSubCategory)\n            return true;\n        let vis = this.isSubCategoryVisible(subcatLo, subcatHi);\n        const modelOvr = this._modelSubCategoryOverrides.get(modelLo, modelHi);\n        if (undefined !== modelOvr && modelOvr.has(subcatLo, subcatHi))\n            vis = !vis;\n        return vis;\n    }\n    /** @internal */\n    getModelOverrides(idLo, idHi) {\n        return this._modelOverrides.get(idLo, idHi);\n    }\n    getElementAnimationOverrides(idLo, idHi, animationNodeId) {\n        if (this.animationNodeOverrides.size === 0)\n            return undefined;\n        // NB: An animation node Id of zero means \"not animated\". Some providers like EmphasizeElements may provide an appearance override for unanimated nodes.\n        // That should be preserved.\n        const app = this.animationNodeOverrides.get(animationNodeId);\n        if (!app || 0 === animationNodeId || this._ignoreAnimationOverrides.length === 0)\n            return app;\n        const args = scratchIgnoreAnimationOverridesArgs;\n        args.elementId.lower = idLo;\n        args.elementId.upper = idHi;\n        args.animationNodeId = animationNodeId;\n        return this._ignoreAnimationOverrides.some((ignore) => ignore(args)) ? undefined : app;\n    }\n    /** @internal */\n    getElementOverrides(idLo, idHi, animationNodeId) {\n        const elemApp = this._elementOverrides.get(idLo, idHi);\n        const nodeApp = this.getElementAnimationOverrides(idLo, idHi, animationNodeId);\n        if (elemApp)\n            return nodeApp ? nodeApp.extendAppearance(elemApp) : elemApp;\n        return nodeApp;\n    }\n    /** @internal */\n    getSubCategoryOverrides(idLo, idHi) { return this._subCategoryOverrides.get(idLo, idHi); }\n    /** Add a [SubCategory]($backend) to the set of visible subcategories. */\n    setVisibleSubCategory(id) { this._visibleSubCategories.addId(id); }\n    /** Specify the Id of an element that should never be drawn. */\n    setNeverDrawn(id) { this._neverDrawn.addId(id); }\n    /** Specify the Id of an element that should always be drawn. */\n    setAlwaysDrawn(id) { this._alwaysDrawn.addId(id); }\n    /** Specify the Id of a animation node that should never be drawn. */\n    setAnimationNodeNeverDrawn(id) { this.neverDrawnAnimationNodes.add(id); }\n    /** Specify the Ids of elements that should never be drawn. */\n    setNeverDrawnSet(ids) { copyIdSetToUint32Set(this._neverDrawn, ids); }\n    /** Specify the Ids of elements that should always be drawn. */\n    setAlwaysDrawnSet(ids, exclusive, ignoreSubCategory = true) {\n        copyIdSetToUint32Set(this._alwaysDrawn, ids);\n        this.isAlwaysDrawnExclusive = exclusive;\n        this.alwaysDrawnIgnoresSubCategory = ignoreSubCategory;\n    }\n    /** Returns the feature's appearance overrides, or undefined if the feature is not visible. */\n    getFeatureAppearance(feature, modelId, type = BatchType.Primary, animationNodeId = 0) {\n        return this.getAppearance(Id64.getLowerUint32(feature.elementId), Id64.getUpperUint32(feature.elementId), Id64.getLowerUint32(feature.subCategoryId), Id64.getUpperUint32(feature.subCategoryId), feature.geometryClass, Id64.getLowerUint32(modelId), Id64.getUpperUint32(modelId), type, animationNodeId);\n    }\n    /** Returns a feature's appearance overrides, or undefined if the feature is not visible.\n     * Takes Id64s as pairs of unsigned 32-bit integers for efficiency, because that is how they are stored by the PackedFeatureTable associated with each batch of graphics.\n     * @see [[getFeatureAppearance]] for an equivalent function that accepts [Id64String]($core-bentley)s instead of integer pairs.\n     */\n    getAppearance(elemLo, elemHi, subcatLo, subcatHi, geomClass, modelLo, modelHi, type, animationNodeId) {\n        if (BatchType.VolumeClassifier === type || BatchType.PlanarClassifier === type)\n            return this.getClassifierAppearance(elemLo, elemHi, subcatLo, subcatHi, modelLo, modelHi, animationNodeId);\n        let app = !this._lineWeights ? FeatureOverrides._weight1Appearance : FeatureAppearance.defaults;\n        const modelApp = this.getModelOverrides(modelLo, modelHi);\n        if (undefined !== modelApp)\n            app = modelApp.extendAppearance(app);\n        // Is the element visible?\n        let elemApp, alwaysDrawn = false;\n        if (Id64.isValidUint32Pair(elemLo, elemHi)) {\n            if (this.isNeverDrawn(elemLo, elemHi, animationNodeId))\n                return undefined;\n            alwaysDrawn = this.isAlwaysDrawn(elemLo, elemHi);\n            if (!alwaysDrawn && this.isAlwaysDrawnExclusive)\n                return undefined;\n            // Element overrides take precedence\n            elemApp = this.getElementOverrides(elemLo, elemHi, animationNodeId);\n            if (undefined !== elemApp)\n                app = undefined !== modelApp ? elemApp.extendAppearance(app) : elemApp;\n        }\n        let subCatApp;\n        if (!this.ignoreSubCategory && Id64.isValidUint32Pair(subcatLo, subcatHi)) {\n            if ((!alwaysDrawn || !this.alwaysDrawnIgnoresSubCategory) && !this.isSubCategoryVisibleInModel(subcatLo, subcatHi, modelLo, modelHi))\n                return undefined;\n            subCatApp = this.getSubCategoryOverrides(subcatLo, subcatHi);\n            if (undefined !== subCatApp)\n                app = subCatApp.extendAppearance(app);\n        }\n        // Only apply default if *no* appearance was explicitly registered (doesn't matter if registered appearance does not actually override anything)\n        if (undefined === elemApp && undefined === modelApp && undefined === subCatApp)\n            app = this._defaultOverrides.extendAppearance(app);\n        let visible = alwaysDrawn || this.isClassVisible(geomClass);\n        if (visible && app.isFullyTransparent)\n            visible = false; // don't bother rendering something with full transparency...\n        return visible ? app : undefined;\n    }\n    /** Classifiers behave totally differently...in particular they are never invisible unless fully-transparent.\n     * @internal\n     */\n    getClassifierAppearance(elemLo, elemHi, subcatLo, subcatHi, modelLo, modelHi, animationNodeId) {\n        let app = FeatureAppearance.defaults;\n        const modelApp = this.getModelOverrides(modelLo, modelHi);\n        if (undefined !== modelApp)\n            app = modelApp.extendAppearance(app);\n        const elemApp = this.getElementOverrides(elemLo, elemHi, animationNodeId);\n        if (undefined !== elemApp)\n            app = undefined !== modelApp ? elemApp.extendAppearance(app) : elemApp;\n        if (!this.ignoreSubCategory && Id64.isValidUint32Pair(subcatLo, subcatHi)) {\n            const subCat = this.getSubCategoryOverrides(subcatLo, subcatHi);\n            if (undefined !== subCat)\n                app = subCat.extendAppearance(app);\n        }\n        if (undefined === elemApp && undefined === modelApp)\n            app = this._defaultOverrides.extendAppearance(app);\n        // NB: A fully-transparent classifier means the classifier is a clip mask - classified pixels will be discarded.\n        return app;\n    }\n    /** Return whether geometry of the specified class should be drawn.\n     * @see [[ViewFlags.constructions]], [[ViewFlags.dimensions]], and [[ViewFlags.patterns]].\n     */\n    isClassVisible(geomClass) {\n        switch (geomClass) {\n            case GeometryClass.Construction: return this._constructions;\n            case GeometryClass.Dimension: return this._dimensions;\n            case GeometryClass.Pattern: return this._patterns;\n            default: return true;\n        }\n    }\n    /** Specify overrides for all elements belonging to a specified [GeometricModel]($backend), or all geometry belonging to a specified [GeometricElement]($backend) or [SubCategory]($backend). */\n    override(args) {\n        let id;\n        let map;\n        if (undefined !== args.elementId) {\n            id = args.elementId;\n            map = this._elementOverrides;\n        }\n        else if (undefined !== args.modelId) {\n            id = args.modelId;\n            map = this._modelOverrides;\n        }\n        else {\n            id = args.subCategoryId;\n            map = this._subCategoryOverrides;\n        }\n        let app = args.appearance;\n        const idLo = Id64.getLowerUint32(id);\n        const idHi = Id64.getUpperUint32(id);\n        if (undefined !== args.elementId && this.isNeverDrawn(idLo, idHi, 0))\n            return;\n        const replace = \"replace\" === args.onConflict;\n        const existing = replace ? undefined : map.get(idLo, idHi);\n        if (existing) {\n            assert(\"replace\" !== args.onConflict);\n            switch (args.onConflict) {\n                case \"skip\":\n                    return;\n                case \"extend\":\n                    app = app.extendAppearance(existing);\n                    break;\n                default:\n                    app = existing.extendAppearance(app);\n                    break;\n            }\n        }\n        map.set(idLo, idHi, app);\n    }\n    /** Specify overrides for all elements within the specified model.\n     * @param id The Id of the model.\n     * @param app The symbology overrides.\n     * @param replaceExisting Specifies whether to replace a pre-existing override for the same model.\n     * @note These overrides take priority over all other overrides.\n     * @note If [[defaultOverrides]] are defined, they will not apply to any element within this model, even if the supplied appearance overrides nothing.\n     * @deprecated in 3.x. Use [[FeatureOverrides.override]].\n     */\n    overrideModel(id, app, replaceExisting = true) {\n        this.override({ modelId: id, appearance: app, onConflict: replaceExisting ? \"replace\" : \"skip\" });\n    }\n    /** Specify overrides for all geometry belonging to the specified [SubCategory]($backend).\n     * @param id The Id of the subcategory.\n     * @param app The symbology overrides.\n     * @param replaceExisting Specifies whether to replace a pre-existing override for the same subcategory.\n     * @note These overrides have lower priority than element and model overrides.\n     * @note If [[defaultOverrides]] are defined, they will not apply to any geometry within this subcategory, even if the supplied appearance overrides nothing.\n     * @deprecated in 3.x. Use [[FeatureOverrides.override]].\n     */\n    overrideSubCategory(id, app, replaceExisting = true) {\n        this.override({ subCategoryId: id, appearance: app, onConflict: replaceExisting ? \"replace\" : \"skip\" });\n    }\n    /** Specify overrides for all geometry originating from the specified element.\n     * @param id The Id of the element.\n     * @param app The symbology overrides.\n     * @param replaceExisting Specifies whether to replace a pre-existing override for the same element.\n     * @note These overrides take precedence over subcategory overrides, but not over model overrides.\n     * @note If [[defaultOverrides]] are defined, they will not apply to this element, even if the supplied appearance overrides nothing.\n     * @deprecated in 3.x. Use [[FeatureOverrides.override]].\n     */\n    overrideElement(id, app, replaceExisting = true) {\n        this.override({ elementId: id, appearance: app, onConflict: replaceExisting ? \"replace\" : \"skip\" });\n    }\n    /** Specify overrides for all geometry originating from the specified animation node.\n     * @param id The Id of the animation node.\n     * @param app The symbology overrides.\n     * @note These overrides do not take precedence over element overrides.\n     */\n    overrideAnimationNode(id, app) {\n        this.animationNodeOverrides.set(id, app);\n    }\n    /** Defines a default appearance to be applied to any [[Feature]] *not* explicitly overridden.\n     * @param appearance The symbology overrides.\n     * @param replaceExisting Specifies whether to replace the current default overrides if they are already defined.\n     */\n    setDefaultOverrides(appearance, replaceExisting = true) {\n        if (replaceExisting || !appearance.overridesSymbology)\n            this._defaultOverrides = appearance;\n    }\n    /** Get the display priority of a subcategory. This is only relevant when using [[PlanProjectionSettings]].\n     * @internal\n     */\n    getSubCategoryPriority(idLo, idHi) {\n        return this._subCategoryPriorities.get(idLo, idHi) ?? 0;\n    }\n    /** Construct a new Overrides that overrides nothing.\n     * @see [FeatureSymbology.Overrides]($frontend) to construct overrides based on a [ViewState]($frontend) or [Viewport]($frontend).\n     */\n    constructor() {\n        /** @internal */\n        this._ignoreAnimationOverrides = [];\n        /** Ids of elements that should never be drawn. This takes precedence over [[alwaysDrawn]]. @internal */\n        this._neverDrawn = new Id64.Uint32Set();\n        /** Ids of elements that should always be drawn. [[neverDrawn]] takes precedence over this set. @internal */\n        this._alwaysDrawn = new Id64.Uint32Set();\n        /** If true, no elements *except* those defined in the \"always drawn\" set will be drawn.\n         * @see [[setAlwaysDrawn]]\n         */\n        this.isAlwaysDrawnExclusive = false;\n        /** If true, the always-drawn elements are drawn even if their subcategories are not visible.\n         * @see [[setAlwaysDrawn]]\n         */\n        this.alwaysDrawnIgnoresSubCategory = true;\n        /** If true, all subcategories are considered visible. This is used for drawing sheets via section callouts in the absence of an actual sheet view.\n         * @internal\n         */\n        this.ignoreSubCategory = false;\n        /** Overrides applied to any feature not explicitly overridden. @internal */\n        this._defaultOverrides = FeatureAppearance.defaults;\n        /** Whether construction geometry should be drawn. @internal */\n        this._constructions = false;\n        /** Whether dimensions should be drawn. @internal */\n        this._dimensions = false;\n        /** Whether area patterns should be drawn. @internal */\n        this._patterns = false;\n        /** Whether line weights should be applied. If false, all lines are rendered 1-pixel wide. @internal */\n        this._lineWeights = true;\n        /** Overrides applied to all elements belonging to each model. @internal */\n        this._modelOverrides = new Id64.Uint32Map();\n        /** Overrides applied to specific elements. @internal */\n        this._elementOverrides = new Id64.Uint32Map();\n        /** Overrides applied to geometry belonging to each subcategory. @internal */\n        this._subCategoryOverrides = new Id64.Uint32Map();\n        /** The set of displayed subcategories. Geometry belonging to subcategories not included in this set will not be drawn. @internal */\n        this._visibleSubCategories = new Id64.Uint32Set();\n        /** Display priorities assigned to subcategories, possibly overridden by display style. Only applicable for plan projection models. @internal */\n        this._subCategoryPriorities = new Id64.Uint32Map();\n        /** Per-model, a set of subcategories whose visibility should be inverted for elements within that model.\n         * Populated by Viewport.\n         * @internal\n         */\n        this._modelSubCategoryOverrides = new Id64.Uint32Map();\n        /** Ids of animation nodes that should never be drawn.\n         * @internal\n         */\n        this.neverDrawnAnimationNodes = new Set();\n        /** Mapping of animation node Ids to overrides applied to the corresponding animation nodes.\n         * @internal\n         */\n        this.animationNodeOverrides = new Map();\n        //\n    }\n    /** Returns true if geometry belonging to the specified subcategory will be drawn. */\n    isSubCategoryIdVisible(id) { return this.isSubCategoryVisible(Id64.getLowerUint32(id), Id64.getUpperUint32(id)); }\n    /** Returns the overrides applied to geometry belonging to the specified model, if any such are defined. */\n    getModelOverridesById(id) { return this.getModelOverrides(Id64.getLowerUint32(id), Id64.getUpperUint32(id)); }\n    /** Returns the overrides applied to geometry belonging to the specified element, if any such are defined. */\n    getElementOverridesById(id) { return this.getElementOverrides(Id64.getLowerUint32(id), Id64.getUpperUint32(id), 0); }\n    /** Returns the overrides applied to geometry belonging to the specified subcategory, if any such are defined. */\n    getSubCategoryOverridesById(id) { return this.getSubCategoryOverrides(Id64.getLowerUint32(id), Id64.getUpperUint32(id)); }\n    /** Returns true if the specified Feature will be drawn. */\n    isFeatureVisible(feature) {\n        const { elementId, subCategoryId, geometryClass } = feature;\n        const isValidElemId = !Id64.isInvalid(elementId);\n        const elemIdParts = isValidElemId ? Id64.getUint32Pair(elementId) : undefined;\n        if (undefined !== elemIdParts && this.isNeverDrawn(elemIdParts.lower, elemIdParts.upper, 0))\n            return false;\n        const alwaysDrawn = undefined !== elemIdParts && this.isAlwaysDrawn(elemIdParts.lower, elemIdParts.upper);\n        if (alwaysDrawn || this.isAlwaysDrawnExclusive)\n            return alwaysDrawn;\n        // NB: This ignores per-model subcategory visibility overrides, because caller did not specify a model.\n        if (!this.isSubCategoryIdVisible(subCategoryId))\n            return false;\n        return this.isClassVisible(geometryClass);\n    }\n}\nFeatureOverrides._weight1Appearance = FeatureAppearance.fromJSON({ weight: 1 });\nexport { FeatureOverrides };\n/** @public */\nexport var FeatureAppearanceProvider;\n(function (FeatureAppearanceProvider) {\n    /** Produce a FeatureAppearanceSource for which `getAppearance()` returns the appearance specified in `source`, potentially modified by `provider`. */\n    function wrap(source, provider) {\n        return {\n            getAppearance: (elemLo, elemHi, subcatLo, subcatHi, geomClass, modelLo, modelHi, type, animationNodeId) => {\n                return provider.getFeatureAppearance(source, elemLo, elemHi, subcatLo, subcatHi, geomClass, modelLo, modelHi, type, animationNodeId);\n            },\n        };\n    }\n    /** Create a provider that obtains each feature's appearance from the source, and if the feature is visible, modifies the appearance.\n     * @param supplementAppearance A function accepting the feature's base appearance and returning a supplemental appearance.\n     * @public\n     */\n    function supplement(supplementAppearance) {\n        return {\n            getFeatureAppearance: (source, elemLo, elemHi, subcatLo, subcatHi, geomClass, modelLo, modelHi, type, animationNodeId) => {\n                const app = source.getAppearance(elemLo, elemHi, subcatLo, subcatHi, geomClass, modelLo, modelHi, type, animationNodeId);\n                return app ? supplementAppearance(app) : app;\n            },\n        };\n    }\n    FeatureAppearanceProvider.supplement = supplement;\n    /** Chain two FeatureAppearanceProviders together such that `first`'s `getFeatureAppearance` function is applied before `second`'s.\n     * If `second` invokes `source.getAppearance()`, the returned appearance will include any modifications applied by `first`.\n     * @public\n     */\n    function chain(first, second) {\n        if (first === second)\n            return first;\n        return {\n            getFeatureAppearance: (source, elemLo, elemHi, subcatLo, subcatHi, geomClass, modelLo, modelHi, type, animationNodeId) => {\n                return second.getFeatureAppearance(wrap(source, first), elemLo, elemHi, subcatLo, subcatHi, geomClass, modelLo, modelHi, type, animationNodeId);\n            },\n        };\n    }\n    FeatureAppearanceProvider.chain = chain;\n})(FeatureAppearanceProvider || (FeatureAppearanceProvider = {}));\n//# sourceMappingURL=FeatureSymbology.js.map",
      "start": 1693508120520,
      "end": 1693508120591,
      "sourcemaps": null
    }
  ]
}
