{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/ShaderBuilder.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { assert } from \"@itwin/core-bentley\";\nimport { addInstancedModelMatrixRTC } from \"./glsl/Instancing\";\nimport { volClassOpaqueColor } from \"./glsl/PlanarClassification\";\nimport { addPosition, earlyVertexDiscard, lateVertexDiscard, vertexDiscard } from \"./glsl/Vertex\";\nimport { ShaderProgram } from \"./ShaderProgram\";\n/** @internal */\nvar Convert;\n(function (Convert) {\n    function typeToString(type) {\n        switch (type) {\n            case 0 /* VariableType.Boolean */: return \"bool\";\n            case 1 /* VariableType.Int */: return \"int\";\n            case 2 /* VariableType.Float */: return \"float\";\n            case 3 /* VariableType.Vec2 */: return \"vec2\";\n            case 4 /* VariableType.Vec3 */: return \"vec3\";\n            case 5 /* VariableType.Vec4 */: return \"vec4\";\n            case 6 /* VariableType.Mat3 */: return \"mat3\";\n            case 7 /* VariableType.Mat4 */: return \"mat4\";\n            case 8 /* VariableType.Sampler2D */: return \"sampler2D\";\n            case 9 /* VariableType.SamplerCube */: return \"samplerCube\";\n            case 10 /* VariableType.Uint */: return \"uint\";\n            default:\n                assert(false);\n                return \"undefined\";\n        }\n    }\n    Convert.typeToString = typeToString;\n    function scopeToString(scope, isVertexShader) {\n        switch (scope) {\n            case 0 /* VariableScope.Global */: return \"\";\n            case 1 /* VariableScope.Varying */: return (isVertexShader ? \"out\" : \"in\");\n            case 2 /* VariableScope.Uniform */: return \"uniform\";\n            default:\n                assert(false);\n                return \"undefined\";\n        }\n    }\n    Convert.scopeToString = scopeToString;\n    function precisionToString(precision) {\n        switch (precision) {\n            case 0 /* VariablePrecision.Default */: return \"\";\n            case 1 /* VariablePrecision.Low */: return \"lowp\";\n            case 2 /* VariablePrecision.Medium */: return \"mediump\";\n            case 3 /* VariablePrecision.High */: return \"highp\";\n            default:\n                assert(false);\n                return \"undefined\";\n        }\n    }\n    Convert.precisionToString = precisionToString;\n})(Convert || (Convert = {}));\n/** Represents a variable within a fragment or vertex shader.\n * @internal\n */\nexport class ShaderVariable {\n    constructor(name, type, scope, precision, isConst, addBinding, value, length = 0) {\n        this.isConst = false; // for global variables only\n        this._addBinding = addBinding;\n        this.name = name;\n        this.value = value;\n        this.type = type;\n        this.scope = scope;\n        this.precision = precision;\n        this.isConst = isConst;\n        this.length = length;\n    }\n    static create(name, type, scope, addBinding, precision = 0 /* VariablePrecision.Default */) {\n        return new ShaderVariable(name, type, scope, precision, false, addBinding, undefined);\n    }\n    static createArray(name, type, length, scope, addBinding, precision = 0 /* VariablePrecision.Default */) {\n        return new ShaderVariable(name, type, scope, precision, false, addBinding, undefined, length);\n    }\n    static createGlobal(name, type, value, isConst = false) {\n        return new ShaderVariable(name, type, 0 /* VariableScope.Global */, 0 /* VariablePrecision.Default */, isConst, undefined, value);\n    }\n    get hasBinding() { return undefined !== this._addBinding; }\n    addBinding(prog) {\n        if (undefined !== this._addBinding)\n            this._addBinding(prog);\n    }\n    get typeName() { return Convert.typeToString(this.type); }\n    getScopeName(isVertexShader) { return Convert.scopeToString(this.scope, isVertexShader); }\n    get precisionName() { return Convert.precisionToString(this.precision); }\n    /** Constructs the single-line declaration of this variable */\n    buildDeclaration(isVertexShader) {\n        const parts = new Array();\n        if (this.isConst)\n            parts.push(\"const\");\n        const scopeName = this.getScopeName(isVertexShader);\n        if (0 < scopeName.length)\n            parts.push(scopeName);\n        const precisionName = this.precisionName;\n        if (0 < precisionName.length)\n            parts.push(precisionName);\n        parts.push(this.typeName);\n        if (this.length > 0)\n            parts.push(`${this.name}[${this.length.toFixed(0)}]`);\n        else\n            parts.push(this.name);\n        if (undefined !== this.value && 0 < this.value.length) {\n            parts.push(\"=\");\n            parts.push(this.value);\n        }\n        return `${parts.join(\" \")};`;\n    }\n}\n/**\n * Represents the set of variables defined and used within a fragment or vertex shader.\n * If the same variable is used in both the fragment and vertex shader (e.g., a varying variable), it should be defined in both ShaderBuilders' ShaderVariables object.\n * @internal\n */\nexport class ShaderVariables {\n    constructor() {\n        this._list = new Array();\n    }\n    /** Find an existing variable with the specified name */\n    find(name) { return this._list.find((v) => v.name === name); }\n    /** Add a new variable, if a variable with the same name does not already exist.  return true if added */\n    addVariable(v) {\n        const found = this.find(v.name);\n        if (undefined !== found) {\n            assert(found.type === v.type);\n            // assume same binding etc...\n            return false;\n        }\n        else {\n            this._list.push(v);\n            return true;\n        }\n    }\n    addUniform(name, type, binding, precision = 0 /* VariablePrecision.Default */) {\n        this.addVariable(ShaderVariable.create(name, type, 2 /* VariableScope.Uniform */, binding, precision));\n    }\n    addVarying(name, type) {\n        return this.addVariable(ShaderVariable.create(name, type, 1 /* VariableScope.Varying */));\n    }\n    addGlobal(name, type, value, isConst = false) {\n        this.addVariable(ShaderVariable.createGlobal(name, type, value, isConst));\n    }\n    addConstant(name, type, value) {\n        this.addGlobal(name, type, value, true);\n    }\n    addBitFlagConstant(name, value) {\n        this.addGlobal(name, 10 /* VariableType.Uint */, `${(2 ** value).toFixed(0)}u`, true);\n    }\n    /** Constructs the lines of glsl code declaring the variables of a certain scope. */\n    buildScopeDeclarations(isVertexShader, scope, constants) {\n        let decls = \"\";\n        for (const v of this._list) {\n            if (scope === v.scope && (undefined === constants ? true : v.isConst === constants))\n                decls += `${v.buildDeclaration(isVertexShader)}\\n`;\n        }\n        return decls;\n    }\n    /** Constructs the lines of glsl code declaring all of the variables. */\n    buildDeclarations(isVertexShader) {\n        let decls = \"\";\n        if (isVertexShader) {\n            decls += this.buildScopeDeclarations(isVertexShader, 2 /* VariableScope.Uniform */);\n            decls += this.buildScopeDeclarations(isVertexShader, 0 /* VariableScope.Global */, true);\n            decls += this.buildScopeDeclarations(isVertexShader, 0 /* VariableScope.Global */, false);\n            decls += this.buildScopeDeclarations(isVertexShader, 1 /* VariableScope.Varying */);\n        }\n        else {\n            decls += this.buildScopeDeclarations(isVertexShader, 1 /* VariableScope.Varying */);\n            decls += this.buildScopeDeclarations(isVertexShader, 2 /* VariableScope.Uniform */);\n            decls += this.buildScopeDeclarations(isVertexShader, 0 /* VariableScope.Global */, true);\n            decls += this.buildScopeDeclarations(isVertexShader, 0 /* VariableScope.Global */, false);\n        }\n        return decls;\n    }\n    /**\n     * For every uniform and attribute variable not contained in the optional 'predefined' list, invokes the associated binding function\n     * to add the corresponding Uniform or Attribute object to the ShaderProgram.\n     */\n    addBindings(prog, predefined) {\n        for (const v of this._list) {\n            // Some variables exist in both frag and vert shaders - only add them to the program once.\n            if (v.hasBinding && (undefined === predefined || undefined === predefined.find(v.name))) {\n                v.addBinding(prog);\n            }\n        }\n    }\n    get length() { return this._list.length; }\n    findSlot(variableSize, loopSize, registers) {\n        // Find the first available slot into which to insert this variable\n        for (let i = 0; i < loopSize; i++) {\n            const newSize = registers[i] + variableSize;\n            if (newSize <= 4) {\n                registers[i] = newSize;\n                return i;\n            }\n        }\n        return -1;\n    }\n    // Return string of varying types with their theoretical slot numbers\n    checkMaxVaryingVectors(fragSource) {\n        // Varyings go into a matrix of 4 columns and GL_MAX_VARYING_VECTORS rows of floats.\n        // The packing rules are defined by the standard. Specifically each row can contain one of:\n        //  vec4\n        //  vec3 (+ float)\n        //  vec2 (+ vec2)\n        //  vec2 (+ float (+ float))\n        //  float (+ float (+ float (+ float)))\n        // Varyings are packed in order of size from largest to smallest\n        const loopSize = 64;\n        const registers = Array(loopSize + 1).fill(0);\n        let outStr = \"\";\n        let slot = 0;\n        const varyings = this._list.filter((variable) => 1 /* VariableScope.Varying */ === variable.scope);\n        // Add in any built in vars that count as varyings if they are used\n        if (fragSource.includes(\"gl_FragCoord\")) {\n            varyings.push(ShaderVariable.create(\"gl_FragCoord\", 5 /* VariableType.Vec4 */, 1 /* VariableScope.Varying */));\n        }\n        if (fragSource.includes(\"gl_PointCoord\")) {\n            varyings.push(ShaderVariable.create(\"gl_PointCoord\", 3 /* VariableType.Vec2 */, 1 /* VariableScope.Varying */));\n        }\n        if (fragSource.includes(\"gl_FrontFacing\")) {\n            varyings.push(ShaderVariable.create(\"gl_FrontFacing\", 0 /* VariableType.Boolean */, 1 /* VariableScope.Varying */));\n        }\n        // Need to process in size order (largest first)\n        varyings.sort((a, b) => b.type - a.type); // this is good enough to sort by\n        for (const variable of varyings) {\n            let variableSize = 0;\n            switch (variable.type) {\n                case 0 /* VariableType.Boolean */:\n                case 1 /* VariableType.Int */:\n                case 2 /* VariableType.Float */:\n                    variableSize = 1;\n                    break;\n                case 3 /* VariableType.Vec2 */:\n                    variableSize = 2;\n                    break;\n                case 4 /* VariableType.Vec3 */:\n                    variableSize = 3;\n                    break;\n                case 5 /* VariableType.Vec4 */:\n                    variableSize = 4;\n                    break;\n                default:\n                    assert(false, \"Invalid varying variable type\");\n                    continue;\n            }\n            slot = this.findSlot(variableSize, loopSize, registers);\n            outStr += `// varying slot ${slot} ${Convert.typeToString(variable.type)} ${variable.name}\\n`;\n        }\n        const slotsUsed = registers.indexOf(0);\n        registers.length = slotsUsed;\n        outStr += `// Slots used: ${slotsUsed}  [${registers.toString()}]\\n`;\n        // debug output modes\n        const outputAll = true; // false just outputs varyings that use more than 8\n        if (outputAll) {\n            return outStr;\n        }\n        else {\n            if (slotsUsed > 8)\n                return outStr;\n            else\n                return \"\";\n        }\n    }\n    // Return the number of varying vectors used by the shader.\n    // Varyings go into a matrix of 4 columns and GL_MAX_VARYING_VECTORS rows of floats.\n    // The packing rules are defined by the standard. Specifically each row can contain one of:\n    //  vec4\n    //  vec3 (+ float)\n    //  vec2 (+ vec2)\n    //  vec2 (+ float (+ float))\n    //  float (+ float (+ float (+ float)))\n    // Varyings are packed in order of size from largest to smallest\n    computeNumVaryingVectors(fragSource) {\n        const loopSize = 64;\n        const registers = Array(loopSize + 1).fill(0);\n        const varyings = this._list.filter((variable) => 1 /* VariableScope.Varying */ === variable.scope);\n        // Add in any built in vars that count as varyings if they are used\n        if (fragSource.includes(\"gl_FragCoord\")) {\n            varyings.push(ShaderVariable.create(\"gl_FragCoord\", 5 /* VariableType.Vec4 */, 1 /* VariableScope.Varying */));\n        }\n        if (fragSource.includes(\"gl_PointCoord\")) {\n            varyings.push(ShaderVariable.create(\"gl_PointCoord\", 3 /* VariableType.Vec2 */, 1 /* VariableScope.Varying */));\n        }\n        if (fragSource.includes(\"gl_FrontFacing\")) {\n            varyings.push(ShaderVariable.create(\"gl_FrontFacing\", 0 /* VariableType.Boolean */, 1 /* VariableScope.Varying */));\n        }\n        // Need to process in size order (largest first)\n        varyings.sort((a, b) => b.type - a.type); // this is good enough to sort by\n        for (const variable of varyings) {\n            if (1 /* VariableScope.Varying */ !== variable.scope)\n                continue;\n            let variableSize = 0;\n            switch (variable.type) {\n                case 0 /* VariableType.Boolean */:\n                case 1 /* VariableType.Int */:\n                case 2 /* VariableType.Float */:\n                    variableSize = 1;\n                    break;\n                case 3 /* VariableType.Vec2 */:\n                    variableSize = 2;\n                    break;\n                case 4 /* VariableType.Vec3 */:\n                    variableSize = 3;\n                    break;\n                case 5 /* VariableType.Vec4 */:\n                    variableSize = 4;\n                    break;\n                default:\n                    assert(false, \"Invalid varying variable type\");\n                    continue;\n            }\n            this.findSlot(variableSize, loopSize, registers);\n        }\n        const slotsUsed = registers.indexOf(0);\n        return slotsUsed;\n    }\n}\n/** Convenience API for assembling glsl source code.\n * @internal\n */\nexport class SourceBuilder {\n    constructor() {\n        this.source = \"\";\n    }\n    /* Append the specified string to the glsl source */\n    add(what) { this.source += what; }\n    /* Append a new-line to the glsl source */\n    newline() { this.add(\"\\n\"); }\n    /* Append the specified string to the glsl source, followed by a new-line */\n    addline(what) {\n        this.add(what);\n        this.newline();\n    }\n    /**\n     * Construct a function definition given the function signature and body. For example:\n     * buildFunctionDefinition(\"float average(float a, float b)\", \"\\n  return (a + b) / 2.0;\\n\");\n     * will produce:\n     *  \"float average(float a, float b) {\n     *     return (a + b) / 2.0;\n     *   }\"\n     * For an inline function:\n     * buildFunctionDefinition(\"float average(float a, float b)\", \"return (a + b) / 2.0;\");\n     * will produce:\n     *  \"float average(float a, float b) { return (a + b) / 2.0; }\"\n     */\n    static buildFunctionDefinition(declaration, implementation) {\n        // If implementation does not start with a newline then assume it is an inline function & add spaces between braces.\n        if (\"\\n\" === implementation.charAt(0))\n            return `${declaration} {${implementation}}\\n\\n`;\n        else\n            return `${declaration} { ${implementation} }\\n\\n`;\n    }\n    /** Constructs a function definition as described by buildFunctionDefinition() and appends it to the glsl source. */\n    addFunction(declaration, implementation) { this.add(SourceBuilder.buildFunctionDefinition(declaration, implementation)); }\n    /** Constructs the definition of the main() function using the supplied function body and appends it to the glsl source. */\n    addMain(implementation) { this.addFunction(\"void main()\", implementation); }\n}\n/**\n * Represents a fragment or vertex shader under construction. The shader consists of a set of defined variables,\n * plus a set of code snippets which can be concatenated together to form the shader source.\n * @internal\n */\nexport class ShaderBuilder extends ShaderVariables {\n    get usesInstancedGeometry() {\n        return !!this._flags.instanced;\n    }\n    addInitializer(initializer) {\n        if (-1 === this._initializers.indexOf(initializer))\n            this._initializers.push(initializer);\n    }\n    constructor(maxComponents, flags) {\n        super();\n        this._components = new Array();\n        this._functions = [];\n        this._extensions = [];\n        this._macros = [];\n        this._fragOutputs = [];\n        this._version = \"\";\n        this.headerComment = \"\";\n        this._initializers = new Array();\n        this._components.length = maxComponents;\n        this._flags = flags;\n        this._version = \"#version 300 es\";\n        this.addDefine(\"TEXTURE\", \"texture\");\n        this.addDefine(\"TEXTURE_CUBE\", \"texture\");\n        this.addDefine(\"TEXTURE_PROJ\", \"textureProj\");\n    }\n    addComponent(index, component) {\n        assert(index < this._components.length);\n        // assume if caller is replacing an existing component, they know what they're doing...\n        this._components[index] = component;\n    }\n    removeComponent(index) {\n        assert(index < this._components.length);\n        this._components[index] = undefined;\n    }\n    getComponent(index) {\n        assert(index < this._components.length);\n        return this._components[index];\n    }\n    addFunction(declarationOrFull, implementation) {\n        let def = declarationOrFull;\n        if (undefined !== implementation)\n            def = SourceBuilder.buildFunctionDefinition(`\\n${declarationOrFull}`, implementation);\n        if (undefined === this.findFunction(def))\n            this._functions.push(def);\n    }\n    replaceFunction(existing, replacement) {\n        const index = this._functions.indexOf(existing);\n        if (-1 !== index) {\n            this._functions[index] = replacement;\n        }\n        assert(-1 !== index);\n        return -1 !== index;\n    }\n    findFunction(func) {\n        return this._functions.find((f) => f === func);\n    }\n    addExtension(extName) {\n        if (-1 === this._extensions.indexOf(extName))\n            this._extensions.push(extName);\n    }\n    addMacro(macro) {\n        if (-1 === this._macros.indexOf(macro))\n            this._macros.push(macro);\n    }\n    addDefine(name, value) {\n        const defineName = `#define ${name} `;\n        const macro = defineName + value;\n        const index = this._macros.findIndex((x) => x.startsWith(defineName));\n        if (-1 !== index)\n            this._macros[index] = macro;\n        else\n            this._macros.push(defineName + value);\n    }\n    clearFragOutput() {\n        while (this._fragOutputs.length > 0)\n            this._fragOutputs.pop();\n    }\n    addFragOutput(name, value) {\n        if (-1 === value) {\n            this._fragOutputs.push(\"out vec4 FragColor;\");\n            return;\n        }\n        this._fragOutputs.push(`layout(location = ${value}) out vec4 ${name};`);\n    }\n    buildPreludeCommon(attrMap, isVertexShader) {\n        const src = new SourceBuilder();\n        // Version number (must be first thing for GLSL 300)\n        src.addline(this._version);\n        // Header comment\n        src.newline();\n        if (\"\" !== this.headerComment) {\n            src.addline(this.headerComment);\n            src.newline();\n        }\n        // Macros\n        for (const macro of this._macros)\n            src.addline(macro);\n        // Extensions\n        for (const ext of this._extensions)\n            src.addline(`#extension ${ext} : enable`);\n        // Default precisions\n        src.addline(\"precision highp float;\");\n        src.addline(\"precision highp int;\");\n        src.newline();\n        // Attribute declarations\n        if (attrMap !== undefined) {\n            attrMap.forEach((attr, key) => {\n                src.addline(`in ${Convert.typeToString(attr.type)} ${key};`);\n            });\n        }\n        // Variable declarations\n        src.add(this.buildDeclarations(isVertexShader));\n        // Layouts\n        for (const layout of this._fragOutputs)\n            src.addline(layout);\n        // Functions\n        for (const func of this._functions) {\n            src.add(func);\n        }\n        if (!src.source.endsWith(\"\\n\\n\"))\n            src.newline();\n        return src;\n    }\n    copyCommon(src) {\n        this._version = src._version;\n        this.headerComment = src.headerComment;\n        this._initializers = [...src._initializers];\n        this._components = [...src._components];\n        this._functions = [...src._functions];\n        this._extensions = [...src._extensions];\n        this._list = [...src._list];\n        this._macros = [...src._macros];\n        this._fragOutputs = [...src._fragOutputs];\n    }\n}\n/** Assembles the source code for a vertex shader from a set of modular components.\n * @internal\n */\nexport class VertexShaderBuilder extends ShaderBuilder {\n    buildPrelude(attrMap) { return this.buildPreludeCommon(attrMap, true); }\n    constructor(flags = {}) {\n        super(14 /* VertexShaderComponent.COUNT */, flags);\n        this._computedVarying = new Array();\n        this.addDefine(\"MAT_NORM\", \"g_nmx\");\n        if (this.usesInstancedGeometry) {\n            addInstancedModelMatrixRTC(this);\n            this.addDefine(\"MAT_MV\", \"g_mv\");\n            this.addDefine(\"MAT_MVP\", \"g_mvp\");\n        }\n        else {\n            this.addDefine(\"MAT_MV\", \"u_mv\");\n            this.addDefine(\"MAT_MVP\", \"u_mvp\");\n        }\n        addPosition(this, this.usesVertexTable);\n    }\n    get usesVertexTable() {\n        return undefined !== this._flags.positionType;\n    }\n    get positionType() {\n        assert(undefined !== this._flags.positionType);\n        return this._flags.positionType;\n    }\n    get(id) { return this.getComponent(id); }\n    set(id, component) { this.addComponent(id, component); }\n    unset(id) { this.removeComponent(id); }\n    addComputedVarying(name, type, computation) {\n        this.addVarying(name, type);\n        this._computedVarying.push(computation);\n    }\n    buildSource(attrMap) {\n        const prelude = this.buildPrelude(attrMap);\n        const main = new SourceBuilder();\n        main.newline();\n        const computePosition = this.get(10 /* VertexShaderComponent.ComputePosition */);\n        assert(undefined !== computePosition);\n        if (undefined !== computePosition) {\n            prelude.addFunction(\"vec4 computePosition(vec4 rawPos)\", computePosition);\n        }\n        const computeQPos = this.get(0 /* VertexShaderComponent.ComputeQuantizedPosition */) ?? \"return a_pos;\";\n        prelude.addFunction(\"vec3 computeQuantizedPosition()\", computeQPos);\n        main.addline(\"  vec3 qpos = computeQuantizedPosition();\");\n        // Initialization logic that should occur at start of main() - primarily global variables whose values\n        // are too complex to compute inline or which depend on uniforms and/or other globals.\n        for (const init of this._initializers) {\n            if (\"\\n\" === init.charAt(0))\n                main.addline(`  {${init}  }\\n`);\n            else\n                main.addline(`  { ${init} }\\n`);\n        }\n        main.addline(\"  vec4 rawPosition = computeVertexPosition(qpos);\");\n        const adjustRawPosition = this.get(1 /* VertexShaderComponent.AdjustRawPosition */);\n        if (undefined !== adjustRawPosition) {\n            prelude.addFunction(\"vec4 adjustRawPosition(vec4 rawPos)\", adjustRawPosition);\n            main.addline(\"  rawPosition = adjustRawPosition(rawPosition);\");\n        }\n        const checkForEarlyDiscard = this.get(2 /* VertexShaderComponent.CheckForEarlyDiscard */);\n        if (undefined !== checkForEarlyDiscard) {\n            prelude.addFunction(\"bool checkForEarlyDiscard(vec4 rawPos)\", checkForEarlyDiscard);\n            main.add(earlyVertexDiscard);\n        }\n        const computeFeatureOverrides = this.get(3 /* VertexShaderComponent.ComputeFeatureOverrides */);\n        if (undefined !== computeFeatureOverrides) {\n            prelude.addFunction(\"void computeFeatureOverrides()\", computeFeatureOverrides);\n            main.addline(\"  computeFeatureOverrides();\");\n        }\n        const computeMaterial = this.get(4 /* VertexShaderComponent.ComputeMaterial */);\n        if (undefined !== computeMaterial) {\n            prelude.addFunction(\"void computeMaterial()\", computeMaterial);\n            main.addline(\"  computeMaterial();\");\n        }\n        const computeBaseColor = this.get(5 /* VertexShaderComponent.ComputeBaseColor */);\n        if (undefined !== computeBaseColor) {\n            assert(undefined !== this.find(\"v_color\"));\n            prelude.addFunction(\"vec4 computeBaseColor()\", computeBaseColor);\n            main.addline(\"  vec4 baseColor = computeBaseColor();\");\n            const applyMaterialColor = this.get(6 /* VertexShaderComponent.ApplyMaterialColor */);\n            if (undefined !== applyMaterialColor) {\n                prelude.addFunction(\"vec4 applyMaterialColor(vec4 baseColor)\", applyMaterialColor);\n                main.addline(\"  baseColor = applyMaterialColor(baseColor);\");\n            }\n            const applyFeatureColor = this.get(7 /* VertexShaderComponent.ApplyFeatureColor */);\n            if (undefined !== applyFeatureColor) {\n                prelude.addFunction(\"vec4 applyFeatureColor(vec4 baseColor)\", applyFeatureColor);\n                main.addline(\"  baseColor = applyFeatureColor(baseColor);\");\n            }\n            const adjustContrast = this.get(8 /* VertexShaderComponent.AdjustContrast */);\n            if (adjustContrast) {\n                prelude.addFunction(\"vec4 adjustContrast(vec4 baseColor)\", adjustContrast);\n                main.addline(\"  baseColor = adjustContrast(baseColor);\");\n            }\n            main.addline(\"  v_color = baseColor;\");\n        }\n        const checkForDiscard = this.get(9 /* VertexShaderComponent.CheckForDiscard */);\n        if (undefined !== checkForDiscard) {\n            prelude.addFunction(\"bool checkForDiscard()\", checkForDiscard);\n            main.add(vertexDiscard);\n        }\n        main.addline(\"  gl_Position = computePosition(rawPosition);\");\n        const finalizePos = this.get(13 /* VertexShaderComponent.FinalizePosition */);\n        if (undefined !== finalizePos) {\n            prelude.addFunction(\"vec4 finalizePosition(vec4 pos)\", finalizePos);\n            main.addline(\"  gl_Position = finalizePosition(gl_Position);\");\n        }\n        for (const comp of this._computedVarying) {\n            main.addline(`  ${comp}`);\n        }\n        const computeAtmosphericScatteringVaryings = this.get(11 /* VertexShaderComponent.ComputeAtmosphericScatteringVaryings */);\n        if (undefined !== computeAtmosphericScatteringVaryings) {\n            prelude.addFunction(\"void computeAtmosphericScatteringVaryings()\", computeAtmosphericScatteringVaryings);\n            main.addline(\"  computeAtmosphericScatteringVaryings();\");\n        }\n        const checkForLateDiscard = this.get(12 /* VertexShaderComponent.CheckForLateDiscard */);\n        if (undefined !== checkForLateDiscard) {\n            prelude.addFunction(\"bool checkForLateDiscard()\", checkForLateDiscard);\n            main.addline(lateVertexDiscard);\n        }\n        prelude.addMain(main.source);\n        return prelude.source;\n    }\n    copyFrom(src) {\n        this.copyCommon(src);\n        this._computedVarying = [...src._computedVarying];\n    }\n}\n/** Assembles the source code for a fragment shader from a set of modular components.\n * @internal\n */\nexport class FragmentShaderBuilder extends ShaderBuilder {\n    constructor(flags = {}) {\n        super(23 /* FragmentShaderComponent.COUNT */, flags);\n        this.requiresEarlyZWorkaround = false;\n        this.addFragOutput(\"FragColor\", -1);\n    }\n    get(id) { return this.getComponent(id); }\n    set(id, component) { this.addComponent(id, component); }\n    unset(id) { this.removeComponent(id); }\n    addDrawBuffersExtension(n) {\n        this.clearFragOutput();\n        for (let i = 0; i < n; i++)\n            this.addFragOutput(`FragColor${i}`, i);\n    }\n    buildSource() {\n        const applyLighting = this.get(8 /* FragmentShaderComponent.ApplyLighting */);\n        const prelude = this.buildPrelude(undefined);\n        const computeBaseColor = this.get(1 /* FragmentShaderComponent.ComputeBaseColor */);\n        assert(undefined !== computeBaseColor);\n        if (undefined !== computeBaseColor) {\n            prelude.addFunction(\"vec4 computeBaseColor()\", computeBaseColor);\n        }\n        const main = new SourceBuilder();\n        main.newline();\n        // Initialization logic that should occur at start of main() - primarily global variables whose values\n        // are too complex to compute inline or which depend on uniforms and/or other globals.\n        for (const init of this._initializers) {\n            if (\"\\n\" === init.charAt(0))\n                main.addline(`  {${init}  }\\n`);\n            else\n                main.addline(`  { ${init} }\\n`);\n        }\n        const checkForEarlyDiscard = this.get(0 /* FragmentShaderComponent.CheckForEarlyDiscard */);\n        if (undefined !== checkForEarlyDiscard) {\n            prelude.addFunction(\"bool checkForEarlyDiscard()\", checkForEarlyDiscard);\n            main.addline(\"  if (checkForEarlyDiscard()) { discard; return; }\");\n        }\n        const finalizeNormal = this.get(22 /* FragmentShaderComponent.FinalizeNormal */);\n        if (undefined !== finalizeNormal) {\n            prelude.addFunction(\"vec3 finalizeNormal()\", finalizeNormal);\n            main.addline(\"  g_normal = finalizeNormal();\");\n        }\n        main.addline(\"  vec4 baseColor = computeBaseColor();\");\n        const finalizeDepth = this.get(18 /* FragmentShaderComponent.FinalizeDepth */);\n        if (undefined !== finalizeDepth) {\n            prelude.addFunction(\"float finalizeDepth()\", finalizeDepth);\n            main.addline(\"  float finalDepth = finalizeDepth();\");\n            main.addline(\"  gl_FragDepth = finalDepth;\");\n        }\n        let clipIndent = \"\";\n        const applyClipping = this.get(10 /* FragmentShaderComponent.ApplyClipping */);\n        if (undefined !== applyClipping) {\n            prelude.addline(\"vec3 g_clipColor;\\n\");\n            prelude.addFunction(\"bool applyClipping(vec4 baseColor)\", applyClipping);\n            main.addline(\"  bool hasClipColor = applyClipping(baseColor);\");\n            main.addline(\"  if (hasClipColor) { baseColor.rgb = g_clipColor; } else {\");\n            clipIndent = \"  \";\n        }\n        const applyMaterialOverrides = this.get(2 /* FragmentShaderComponent.ApplyMaterialOverrides */);\n        if (undefined !== applyMaterialOverrides) {\n            prelude.addFunction(\"vec4 applyMaterialOverrides(vec4 baseColor)\", applyMaterialOverrides);\n            main.addline(`${clipIndent}  baseColor = applyMaterialOverrides(baseColor);`);\n        }\n        const applyThematicDisplay = this.get(7 /* FragmentShaderComponent.ApplyThematicDisplay */);\n        if (undefined !== applyThematicDisplay) {\n            prelude.addFunction(\"vec4 applyThematicDisplay(vec4 baseColor)\", applyThematicDisplay);\n            main.addline(`${clipIndent}  if (u_renderPass != kRenderPass_PlanarClassification)`);\n            main.addline(`${clipIndent}    baseColor = applyThematicDisplay(baseColor);`);\n        }\n        const applyPlanarClassifier = this.get(12 /* FragmentShaderComponent.ApplyPlanarClassifier */);\n        if (undefined !== applyPlanarClassifier) {\n            if (undefined === finalizeDepth) {\n                if (this.findFunction(volClassOpaqueColor))\n                    main.addline(`${clipIndent}  float finalDepth = gl_FragCoord.z;`);\n                else\n                    main.addline(`${clipIndent}  float finalDepth = 1.0;`);\n            }\n            prelude.addFunction(\"vec4 applyPlanarClassifications(vec4 baseColor, float depth)\", applyPlanarClassifier);\n            main.addline(`${clipIndent}  baseColor = applyPlanarClassifications(baseColor, finalDepth);`);\n        }\n        const applySolarShadowMap = this.get(13 /* FragmentShaderComponent.ApplySolarShadowMap */);\n        if (undefined !== applySolarShadowMap) {\n            prelude.addFunction(\"vec4 applySolarShadowMap(vec4 baseColor)\", applySolarShadowMap);\n            main.addline(`${clipIndent}  baseColor = applySolarShadowMap(baseColor);`);\n        }\n        const finalize = this.get(3 /* FragmentShaderComponent.FinalizeBaseColor */);\n        if (undefined !== finalize) {\n            prelude.addFunction(\"vec4 finalizeBaseColor(vec4 baseColor)\", finalize);\n            main.addline(`${clipIndent}  baseColor = finalizeBaseColor(baseColor);`);\n        }\n        const checkForDiscard = this.get(4 /* FragmentShaderComponent.CheckForDiscard */);\n        if (undefined !== checkForDiscard) {\n            prelude.addFunction(\"bool checkForDiscard(vec4 baseColor)\", checkForDiscard);\n            main.addline(`${clipIndent}  if (checkForDiscard(baseColor)) { discard; return; }`);\n        }\n        const discardByAlpha = this.get(5 /* FragmentShaderComponent.DiscardByAlpha */);\n        if (undefined !== discardByAlpha) {\n            prelude.addFunction(\"bool discardByAlpha(float alpha)\", discardByAlpha);\n            main.addline(`${clipIndent}  if (discardByAlpha(baseColor.a)) { discard; return; }`);\n        }\n        if (undefined !== applyClipping)\n            main.addline(\"  }\");\n        const applyMonochrome = this.get(6 /* FragmentShaderComponent.ApplyMonochrome */);\n        if (undefined !== applyMonochrome) {\n            prelude.addFunction(\"vec4 applyMonochrome(vec4 baseColor)\", applyMonochrome);\n            main.addline(\"  baseColor = applyMonochrome(baseColor);\");\n        }\n        if (undefined !== applyLighting) {\n            prelude.addFunction(\"vec4 applyLighting(vec4 baseColor)\", applyLighting);\n            main.addline(\"  baseColor = applyLighting(baseColor);\");\n        }\n        const reverseWoW = this.get(9 /* FragmentShaderComponent.ReverseWhiteOnWhite */);\n        if (undefined !== reverseWoW) {\n            prelude.addFunction(\"vec4 reverseWhiteOnWhite(vec4 baseColor)\", reverseWoW);\n            main.addline(\"  baseColor = reverseWhiteOnWhite(baseColor);\");\n        }\n        const applyFlash = this.get(11 /* FragmentShaderComponent.ApplyFlash */);\n        if (undefined !== applyFlash) {\n            prelude.addFunction(\"vec4 applyFlash(vec4 baseColor)\", applyFlash);\n            main.addline(\"  baseColor = applyFlash(baseColor);\");\n        }\n        const applyWiremesh = this.get(14 /* FragmentShaderComponent.ApplyWiremesh */);\n        if (applyWiremesh) {\n            prelude.addFunction(\"vec4 applyWiremesh(vec4 baseColor)\", applyWiremesh);\n            main.addline(\"  baseColor = applyWiremesh(baseColor);\");\n        }\n        const applyAtmosphericScattering = this.get(21 /* FragmentShaderComponent.ApplyAtmosphericScattering */);\n        if (applyAtmosphericScattering) {\n            prelude.addFunction(\"vec4 applyAtmosphericScattering(vec4 baseColor)\", applyAtmosphericScattering);\n            main.addline(\"  baseColor = applyAtmosphericScattering(baseColor);\");\n        }\n        const applyDebug = this.get(15 /* FragmentShaderComponent.ApplyDebugColor */);\n        if (undefined !== applyDebug) {\n            prelude.addFunction(\"vec4 applyDebugColor(vec4 baseColor)\", applyDebug);\n            main.addline(\"  baseColor = applyDebugColor(baseColor);\");\n        }\n        const assignFragData = this.get(16 /* FragmentShaderComponent.AssignFragData */);\n        assert(undefined !== assignFragData);\n        if (undefined !== assignFragData) {\n            prelude.addFunction(\"void assignFragData(vec4 baseColor)\", assignFragData);\n            main.addline(\"  assignFragData(baseColor);\");\n        }\n        if (this.requiresEarlyZWorkaround) {\n            // Add a conditional discard that never executes to force buggy Intel driver to skip early Z despite our fragment shader writing depth.\n            main.addline(\"if (v_eyeSpace.z == 9999999.0) discard;\");\n        }\n        prelude.addMain(main.source);\n        return prelude.source;\n    }\n    buildPrelude(attrMap) {\n        return this.buildPreludeCommon(attrMap, false);\n    }\n    copyFrom(src) {\n        this.copyCommon(src);\n        this.requiresEarlyZWorkaround = src.requiresEarlyZWorkaround;\n    }\n}\n/**\n * Assembles vertex and fragment shaders from a set of modular components to produce a compiled ShaderProgram.\n * Be very careful with components which use samplers to ensure that no conflicts exist with texture units used by other components (see TextureUnit enum).\n * @internal\n */\nexport class ProgramBuilder {\n    constructor(attrMap, flags = {}) {\n        this._attrMap = attrMap;\n        this.vert = new VertexShaderBuilder(flags);\n        this.frag = new FragmentShaderBuilder(flags);\n        this._flags = flags; // only needed for clone - though could look up from vert or frag shader.\n    }\n    addVariable(v, which) {\n        if (which & 1 /* ShaderType.Fragment */) {\n            this.frag.addVariable(v);\n        }\n        if (which & 2 /* ShaderType.Vertex */) {\n            this.vert.addVariable(v);\n        }\n    }\n    addUniform(name, type, binding, which = 3 /* ShaderType.Both */) {\n        this.addVariable(ShaderVariable.create(name, type, 2 /* VariableScope.Uniform */, binding), which);\n    }\n    addUniformArray(name, type, length, binding, which = 3 /* ShaderType.Both */) {\n        this.addVariable(ShaderVariable.createArray(name, type, length, 2 /* VariableScope.Uniform */, binding), which);\n    }\n    addVarying(name, type) {\n        this.addVariable(ShaderVariable.create(name, type, 1 /* VariableScope.Varying */), 3 /* ShaderType.Both */);\n    }\n    addGlobal(name, type, which = 3 /* ShaderType.Both */, value, isConst = false) {\n        this.addVariable(ShaderVariable.createGlobal(name, type, value, isConst), which);\n    }\n    addInlineComputedVarying(name, type, inlineComputation) {\n        if (this.frag.addVarying(name, type))\n            this.vert.addComputedVarying(name, type, inlineComputation);\n    }\n    addFunctionComputedVarying(name, type, funcName, funcBody) {\n        let funcDecl = `\\n${Convert.typeToString(type)} ${funcName}()`;\n        funcDecl = SourceBuilder.buildFunctionDefinition(funcDecl, funcBody);\n        const funcCall = `${funcName}()`;\n        this.addFunctionComputedVaryingWithArgs(name, type, funcCall, funcDecl);\n    }\n    addFunctionComputedVaryingWithArgs(name, type, funcCall, funcDef) {\n        this.vert.addFunction(funcDef);\n        const computation = `${name} = ${funcCall};`;\n        this.addInlineComputedVarying(name, type, computation);\n    }\n    /** Assembles the vertex and fragment shader code and returns a ready-to-compile shader program */\n    buildProgram(gl) {\n        const vertSource = this.vert.buildSource(this._attrMap);\n        const fragSource = this.frag.buildSource(); // NB: frag has no need to specify attributes, only vertex does.\n        // Debug output\n        const debugVaryings = false;\n        if (debugVaryings) {\n            const dbgLog = (x) => console.log(x); // eslint-disable-line no-console\n            const outSrc = false; // true for source out, false for just varying info\n            if (this.frag.headerComment) {\n                let tStr = \"\";\n                if (!outSrc) {\n                    tStr = `${this.frag.headerComment}\\n`;\n                }\n                const tStr2 = this.vert.checkMaxVaryingVectors(fragSource);\n                if (tStr2) {\n                    if (outSrc) {\n                        dbgLog(\"//===============================================================================================================\");\n                        dbgLog(vertSource);\n                        dbgLog(\"//========= Varying Info =========\");\n                        dbgLog(tStr2);\n                        dbgLog(fragSource);\n                    }\n                    else {\n                        dbgLog(tStr + tStr2);\n                    }\n                }\n            }\n        }\n        const prog = new ShaderProgram(gl, vertSource, fragSource, this._attrMap, this.vert.headerComment, this.frag.headerComment);\n        this.vert.addBindings(prog);\n        this.frag.addBindings(prog, this.vert);\n        return prog;\n    }\n    setDebugDescription(description) {\n        this.vert.headerComment = (`//!V! ${description}`);\n        this.frag.headerComment = (`//!F! ${description}`);\n    }\n    /** Returns a deep copy of this program builder. */\n    clone() {\n        const clone = new ProgramBuilder(this._attrMap, this._flags);\n        clone.vert.copyFrom(this.vert);\n        clone.frag.copyFrom(this.frag);\n        return clone;\n    }\n}\n//# sourceMappingURL=ShaderBuilder.js.map",
      "start": 1693508125126,
      "end": 1693508125298,
      "sourcemaps": null
    }
  ]
}
