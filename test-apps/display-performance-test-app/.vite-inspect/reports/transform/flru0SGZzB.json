{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/curve/Query/CylindricalRange.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Curve\n */\nimport { RecurseToCurvesGeometryHandler } from \"../../geometry3d/GeometryHandler\";\nimport { Point3d, Vector3d } from \"../../geometry3d/Point3dVector3d\";\nimport { LineString3d } from \"../LineString3d\";\nimport { StrokeOptions } from \"../StrokeOptions\";\n/**\n * Context for computing geometry range around an axis.\n * * The publicly called method is `computeZRRange (ray, geometry)\n */\nexport class CylindricalRangeQuery extends RecurseToCurvesGeometryHandler {\n    /** capture ray and initialize evolving ranges. */\n    constructor(ray) {\n        super();\n        this._localPoint = Point3d.create();\n        this._worldPoint = Point3d.create();\n        this._perpVector = Vector3d.createZero();\n        this._maxDistance = 0.0;\n        this._localToWorld = ray.toRigidZFrame();\n    }\n    announcePoint(xyz) {\n        this._localToWorld.multiplyInversePoint3d(xyz, this._localPoint);\n        const distance = this._localPoint.magnitudeXY();\n        if (distance >= this._maxDistance) {\n            this._maxDistance = distance;\n            this._perpVector.setFromPoint3d(this._localPoint);\n            this._perpVector.z = 0.0;\n            this._localToWorld.matrix.multiplyXY(this._localPoint.x, this._localPoint.y, this._perpVector);\n        }\n    }\n    handleLineSegment3d(segment0) {\n        this.announcePoint(segment0.startPoint(this._worldPoint));\n        this.announcePoint(segment0.endPoint(this._worldPoint));\n    }\n    handleLineString3d(ls0) {\n        for (let i = 0; i < ls0.numPoints(); i++) {\n            ls0.pointAt(i, this._worldPoint);\n            this.announcePoint(this._worldPoint);\n        }\n    }\n    handleArc3d(arc0) {\n        // humbug .. just stroke it ..\n        // exact solution is:\n        //   project the arc to the z=0 plane of the local system.\n        //   find max distance to origin.\n        const numStroke = StrokeOptions.applyAngleTol(undefined, 3, arc0.sweep.sweepRadians, 0.1);\n        const df = 1.0 / numStroke;\n        for (let i = 0; i <= numStroke; i++) {\n            arc0.fractionToPoint(i * df, this._worldPoint);\n            this.announcePoint(this._worldPoint);\n        }\n        return undefined;\n    }\n    /**\n     * Compute the largest vector perpendicular to a ray and ending on the geometry.\n     * @param geometry0 geometry to search\n     * @returns vector from ray to geometry.\n     */\n    static computeMaxVectorFromRay(ray, geometry) {\n        const accumulator = new CylindricalRangeQuery(ray);\n        geometry.dispatchToGeometryHandler(accumulator);\n        return accumulator._perpVector.clone();\n    }\n    /**\n     * Recurse through geometry.children to find linestrings.\n     * In each linestring, compute the surface normal annotation from\n     *  * the curve tangent stored in the linestring\n     *  * the axis of rotation\n     *  * a default V vector to be used when the linestring point is close to the axis.\n     * @param geometry\n     * @param axis\n     * @param defaultVectorV\n     */\n    static buildRotationalNormalsInLineStrings(geometry, axis, defaultVectorFromAxis) {\n        if (geometry instanceof LineString3d) {\n            const points = geometry.packedPoints;\n            const derivatives = geometry.packedDerivatives;\n            const normals = geometry.ensureEmptySurfaceNormals();\n            if (derivatives && normals) {\n                const vectorU = Vector3d.create();\n                const vectorV = Vector3d.create(); // v direction (forwward along sweep) for surface of rotation.\n                const xyz = Point3d.create();\n                const n = points.length;\n                for (let i = 0; i < n; i++) {\n                    points.getPoint3dAtUncheckedPointIndex(i, xyz);\n                    axis.perpendicularPartOfVectorToTarget(xyz, vectorU);\n                    if (vectorU.isAlmostZero)\n                        axis.direction.crossProduct(defaultVectorFromAxis, vectorV);\n                    else\n                        axis.direction.crossProduct(vectorU, vectorV);\n                    geometry.packedDerivatives.getVector3dAtCheckedVectorIndex(i, vectorU); // reuse vector U as curve derivative\n                    vectorU.crossProduct(vectorV, vectorV); // reuse vector V as normal!\n                    vectorV.normalizeInPlace();\n                    normals.push(vectorV);\n                }\n            }\n        }\n        else if (geometry.children) {\n            const children = geometry.children;\n            for (const child of children) {\n                this.buildRotationalNormalsInLineStrings(child, axis, defaultVectorFromAxis);\n            }\n        }\n    }\n}\n//# sourceMappingURL=CylindricalRange.js.map",
      "start": 1693508124273,
      "end": 1693508124386,
      "sourcemaps": null
    }
  ]
}
