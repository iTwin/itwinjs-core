{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/geometry3d/PointHelpers.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module CartesianGeometry\n */\n/* eslint-disable @typescript-eslint/naming-convention, no-empty */\nimport { Geometry } from \"../Geometry\";\nimport { Point4d } from \"../geometry4d/Point4d\";\nimport { IndexedXYZCollection } from \"./IndexedXYZCollection\";\nimport { Point2d } from \"./Point2dVector2d\";\nimport { Point3dArrayCarrier } from \"./Point3dArrayCarrier\";\nimport { Point3d, Vector3d } from \"./Point3dVector3d\";\nimport { PointStringDeepXYZArrayCollector, VariantPointDataStream } from \"./PointStreaming\";\nimport { Transform } from \"./Transform\";\n/**\n *\n * @param numA first candidate -- presumed 0 or positive\n * @param numB second candidate -- may be undefined, invalid if outside closed interval 0..numA\n * @param multiplyBy second candidate multiplier (applied only if candidate is defined)\n */\nfunction selectOptionalClampedMin(numA, numB, multiplyBy) {\n    if (numB !== undefined) {\n        const numC = numB * multiplyBy;\n        if (numC >= 0 && numC <= numA)\n            return numC;\n    }\n    return numA;\n}\n/**\n * The `NumberArray` class contains static methods that act on arrays of numbers.\n * @public\n */\nexport class NumberArray {\n    /** return the sum of values in an array,   The summation is done with correction terms which\n     * improves last-bit numeric accuracy.\n     */\n    static preciseSum(data) {\n        const n = data.length;\n        if (n === 0)\n            return 0.0;\n        let sum = data[0];\n        let c = 0.0;\n        let y;\n        let t;\n        for (let i = 1; i < n; i++) {\n            y = data[i] - c;\n            t = sum + y;\n            c = (t - sum) - y;\n            sum = t;\n        }\n        return sum;\n    }\n    /** Return true if arrays have identical counts and equal entries (using `!==` comparison) */\n    static isExactEqual(dataA, dataB) {\n        if (dataA && dataB) {\n            if (dataA.length !== dataB.length)\n                return false;\n            for (let i = 0; i < dataA.length; i++)\n                if (dataA[i] !== dataB[i])\n                    return false;\n            return true;\n        }\n        return (dataA === undefined && dataB === undefined);\n    }\n    /** Return true if arrays have identical counts and entries equal within tolerance */\n    static isAlmostEqual(dataA, dataB, tolerance) {\n        if (dataA && dataB) {\n            if (dataA.length !== dataB.length)\n                return false;\n            for (let i = 0; i < dataA.length; i++)\n                if (Math.abs(dataA[i] - dataB[i]) >= tolerance)\n                    return false;\n            return true;\n        }\n        return (dataA === undefined && dataB === undefined);\n    }\n    /** return the sum of numbers in an array.  Note that \"PreciseSum\" may be more accurate. */\n    static sum(data) {\n        let sum = 0;\n        for (const x of data) {\n            sum += x;\n        }\n        return sum;\n    }\n    /** test if coordinate x appears (to tolerance by `Geometry.isSameCoordinate`) in this array of numbers */\n    static isCoordinateInArray(x, data) {\n        if (data) {\n            for (const y of data) {\n                if (Geometry.isSameCoordinate(x, y))\n                    return true;\n            }\n        }\n        return false;\n    }\n    /** Return the max absolute value in a array of numbers. */\n    static maxAbsArray(values) {\n        const arrLen = values.length;\n        if (arrLen === 0) {\n            return 0.0;\n        }\n        let a = Math.abs(values[0]);\n        for (let i = 1; i < arrLen; i++) {\n            const b = Math.abs(values[i]);\n            if (a < b) {\n                a = b;\n            }\n        }\n        return a;\n    }\n    /** return the max absolute value of a pair of numbers */\n    static maxAbsTwo(a1, a2) {\n        a1 = Math.abs(a1);\n        a2 = Math.abs(a2);\n        return (a1 > a2) ? a1 : a2;\n    }\n    /** Return the max absolute difference between corresponding entries in two arrays of numbers\n     * * If sizes are mismatched, only the smaller length is tested.\n     */\n    static maxAbsDiff(dataA, dataB) {\n        let a = 0.0;\n        const n = Math.min(dataA.length, dataB.length);\n        for (let i = 0; i < n; i++) {\n            a = Math.max(a, Math.abs(dataA[i] - dataB[i]));\n        }\n        return a;\n    }\n    /** Return the max absolute difference between corresponding entries in two Float64Array\n     * * If sizes are mismatched, only the smaller length is tested.\n     */\n    static maxAbsDiffFloat64(dataA, dataB) {\n        let a = 0.0;\n        const n = Math.min(dataA.length, dataB.length);\n        for (let i = 0; i < n; i++) {\n            a = Math.max(a, Math.abs(dataA[i] - dataB[i]));\n        }\n        return a;\n    }\n    /**\n     * Return an array with indicated start and end points, maximum step size internally\n     * @param low low value\n     * @param high high value\n     * @param step max permitted step\n     */\n    static createArrayWithMaxStepSize(low, high, step) {\n        if (low === high)\n            return [low];\n        const delta = high - low;\n        const numInterval = Math.max(1, Math.floor(Math.abs(delta / step)));\n        const result = [];\n        result.push(low);\n        for (let i = 1; i < numInterval; i++) {\n            result.push(low + (i / numInterval) * delta);\n        }\n        result.push(high);\n        return result;\n    }\n    /** copy numbers from variant sources to number[]. */\n    static create(source) {\n        const result = [];\n        for (const q of source)\n            result.push(q);\n        return result;\n    }\n    /** Return a copy of the knots array, with multiplicity of first and last knots raised or lowered to expectedMultiplicity. */\n    static cloneWithStartAndEndMultiplicity(knots, target0, target1) {\n        const result = [];\n        if (knots === undefined || knots.length === 0)\n            return result;\n        let multiplicity0 = 1;\n        const knot0 = knots[0];\n        const knot1 = knots[knots.length - 1];\n        for (; multiplicity0 < knots.length && knots[multiplicity0] === knot0;) {\n            multiplicity0++;\n        }\n        let multiplicity1 = 1;\n        const k1 = knots.length - 1;\n        for (; k1 - multiplicity1 >= 0 && knots[k1 - multiplicity1] === knot1;) {\n            multiplicity1++;\n        }\n        for (let k = 0; k < target0; k++)\n            result.push(knot0);\n        for (let k = multiplicity0; k + multiplicity1 < knots.length; k++)\n            result.push(knots[k]);\n        for (let k = 0; k < target1; k++)\n            result.push(knot1);\n        return result;\n    }\n    /** Compute the linear combination s of the numbers and scales.\n     * @param data array of numbers d_i.\n     * @param scales array of scales s_i. For best results, `scales` should have the same length as `data`.\n     * @return s = sum(d_i * s_i), where i ranges from 0 to min(data.length, scales.length).\n     */\n    static linearCombination(data, scales) {\n        const numTerms = Math.min(data.length, scales.length);\n        let sum = 0;\n        for (let i = 0; i < numTerms; ++i)\n            sum += scales[i] * data[i];\n        return sum;\n    }\n    /** Compute the linear combination s of the colors and scales.\n     * * The result is another color if the scales are in [0,1] and sum to 1.\n     * @param colors array of colors c_i (rgba in first four bytes).\n     * @param scales array of scales s_i. For best results, `scales` should have the same length as `colors`.\n     * @return s = sum(c_i * s_i), where i ranges from 0 to min(colors.length, scales.length).\n     */\n    static linearCombinationOfColors(colors, scales) {\n        const numTerms = Math.min(colors.length, scales.length);\n        const bytes = [0, 0, 0, 0];\n        // compute a convex combination of each byte\n        for (let iByte = 0, shiftBits = 0; iByte < 4; ++iByte, shiftBits += 8) {\n            for (let iTerm = 0; iTerm < numTerms; ++iTerm) {\n                const fraction = Geometry.clamp(scales[iTerm], 0, 1); // chop slop\n                const colorComponent = (colors[iTerm] >>> shiftBits) & 0xFF;\n                bytes[iByte] += fraction * colorComponent;\n            }\n            bytes[iByte] = (Math.floor(bytes[iByte]) & 0xFF) << shiftBits;\n        }\n        return bytes[0] | bytes[1] | bytes[2] | bytes[3];\n    }\n}\n/**\n * The `Point2dArray` class contains static methods that act on arrays of 2d points.\n * @public\n */\nexport class Point2dArray {\n    /** Return true if arrays have same length and matching coordinates. */\n    static isAlmostEqual(dataA, dataB) {\n        if (dataA && dataB) {\n            if (dataA.length !== dataB.length)\n                return false;\n            for (let i = 0; i < dataA.length; i++) {\n                if (!dataA[i].isAlmostEqual(dataB[i]))\n                    return false;\n            }\n            return true;\n        }\n        return (dataA === undefined && dataB === undefined);\n    }\n    /**\n     * Return an array containing clones of the Point3d data[]\n     * @param data source data\n     */\n    static clonePoint2dArray(data) {\n        return data.map((p) => p.clone());\n    }\n    /**\n     * Return the number of points when trailing points that match point 0 are excluded.\n     * @param data array of XAndY points.\n     */\n    static pointCountExcludingTrailingWraparound(data) {\n        let n = data.length;\n        if (n < 2)\n            return n;\n        const x0 = data[0].x;\n        const y0 = data[0].y;\n        while (n > 1) {\n            if (!Geometry.isSameCoordinate(data[n - 1].x, x0) || !Geometry.isSameCoordinate(data[n - 1].y, y0))\n                return n;\n            n--;\n        }\n        return n;\n    }\n}\n/**\n * The `Vector3dArray` class contains static methods that act on arrays of 3d vectors.\n * @public\n */\nexport class Vector3dArray {\n    /** Return true if arrays have same length and matching coordinates. */\n    static isAlmostEqual(dataA, dataB) {\n        if (dataA && dataB) {\n            if (dataA.length !== dataB.length)\n                return false;\n            for (let i = 0; i < dataA.length; i++)\n                if (!dataA[i].isAlmostEqual(dataB[i]))\n                    return false;\n            return true;\n        }\n        return (dataA === undefined && dataB === undefined);\n    }\n    /**\n     * Return an array containing clones of the Vector3d data[]\n     * @param data source data\n     */\n    static cloneVector3dArray(data) {\n        return data.map((p) => Vector3d.create(p.x, p.y, p.z));\n    }\n}\n/**\n * The `Point4dArray` class contains static methods that act on arrays of 4d points.\n * @public\n */\nclass Point4dArray {\n    /** pack each point and its corresponding weight into a buffer of xyzw xyzw ... */\n    static packPointsAndWeightsToFloat64Array(data, weights, result) {\n        if (Array.isArray(data) && data[0] instanceof Point3d) {\n            const points = data;\n            if (points.length !== weights.length)\n                return undefined;\n            result = result ? result : new Float64Array(4 * points.length);\n            let i = 0;\n            let k = 0;\n            for (k = 0; k < points.length; k++) {\n                result[i++] = points[k].x;\n                result[i++] = points[k].y;\n                result[i++] = points[k].z;\n                result[i++] = weights[k];\n            }\n            return result;\n        }\n        else {\n            const points = data;\n            const numPoints = weights.length;\n            if (points.length !== 3 * numPoints)\n                return undefined;\n            let i = 0;\n            let k;\n            result = result ? result : new Float64Array(4 * numPoints);\n            for (k = 0; k < numPoints; k++) {\n                const k0 = 3 * k;\n                result[i++] = points[k0];\n                result[i++] = points[k0 + 1];\n                result[i++] = points[k0 + 2];\n                result[i++] = weights[k];\n            }\n            return result;\n        }\n        return undefined;\n    }\n    /** pack x,y,z,w in Float64Array. */\n    static packToFloat64Array(data, result) {\n        result = result ? result : new Float64Array(4 * data.length);\n        let i = 0;\n        for (const p of data) {\n            result[i++] = p.x;\n            result[i++] = p.y;\n            result[i++] = p.z;\n            result[i++] = p.w;\n        }\n        return result;\n    }\n    /** unpack from  ... to array of Point4d */\n    static unpackToPoint4dArray(data) {\n        const result = [];\n        for (let i = 0; i + 3 < data.length; i += 4) {\n            result.push(Point4d.create(data[i], data[i + 1], data[i + 2], data[i + 3]));\n        }\n        return result;\n    }\n    /** unpack from xyzw xyzw... array to array of Point3d and array of weight.\n     */\n    static unpackFloat64ArrayToPointsAndWeights(data, points, weights, pointFormatter = (x, y, z) => Point3d.create(x, y, z)) {\n        points.length = 0;\n        weights.length = 0;\n        for (let i = 0; i + 3 < data.length; i += 4) {\n            points.push(pointFormatter(data[i], data[i + 1], data[i + 2]));\n            weights.push(data[i + 3]);\n        }\n    }\n    /**\n     * Multiply (and replace) each block of 4 values as a Point4d.\n     * @param transform transform to apply\n     * @param xyzw array of x,y,z,w points.\n     */\n    static multiplyInPlace(transform, xyzw) {\n        const numXYZW = xyzw.length;\n        const xyzw1 = Point4dArray._workPoint4d;\n        for (let i = 0; i + 3 < numXYZW; i += 4) {\n            transform.multiplyXYZW(xyzw[i], xyzw[i + 1], xyzw[i + 2], xyzw[i + 3], xyzw1);\n            xyzw[i] = xyzw1.x;\n            xyzw[i + 1] = xyzw1.y;\n            xyzw[i + 2] = xyzw1.z;\n            xyzw[i + 3] = xyzw1.w;\n        }\n    }\n    /** test for near equality of all corresponding numeric values, treated as coordinates. */\n    static isAlmostEqual(dataA, dataB) {\n        if (dataA && dataB) {\n            if (dataA.length !== dataB.length)\n                return false;\n            if (dataA instanceof Float64Array && dataB instanceof Float64Array) {\n                for (let i = 0; i < dataA.length; i++)\n                    if (!Geometry.isSameCoordinate(dataA[i], dataB[i]))\n                        return false;\n            }\n            else if (Array.isArray(dataA) && Array.isArray(dataB)) {\n                for (let i = 0; i < dataA.length; i++)\n                    if (!dataA[i].isAlmostEqual(dataB[i]))\n                        return false;\n            }\n            return true;\n        }\n        // if both are null it is equal, otherwise unequal\n        return (dataA === undefined && dataB === undefined);\n    }\n    /** return true iff all xyzw points' altitudes are within tolerance of the plane.*/\n    static isCloseToPlane(data, plane, tolerance = Geometry.smallMetricDistance) {\n        if (Array.isArray(data)) {\n            for (const xyzw of data) {\n                if (Math.abs(plane.altitudeXYZW(xyzw.x, xyzw.y, xyzw.z, xyzw.w)) > tolerance)\n                    return false;\n            }\n        }\n        else if (data instanceof Float64Array) {\n            const numXYZ = data.length;\n            for (let i = 0; i + 2 < numXYZ; i += 4) {\n                if (Math.abs(plane.altitudeXYZW(data[i], data[i + 1], data[i + 2], data[i + 3])) > tolerance)\n                    return false;\n            }\n        }\n        return true;\n    }\n}\nPoint4dArray._workPoint4d = Point4d.create();\nexport { Point4dArray };\n/**\n * The `Point3dArray` class contains static methods that act on arrays of 3d points.\n * @public\n */\nclass Point3dArray {\n    /** pack x,y,z to `Float64Array` */\n    static packToFloat64Array(data) {\n        const result = new Float64Array(3 * data.length);\n        let i = 0;\n        for (const p of data) {\n            result[i++] = p.x;\n            result[i++] = p.y;\n            result[i++] = p.z;\n        }\n        return result;\n    }\n    /**\n     * Compute the 8 weights of trilinear mapping\n     * By appropriate choice of weights, this can be used for both point and derivative mappings.\n     * @param weights preallocated array to receive weights.\n     * @param u0 low u weight\n     * @param u1 high u weight\n     * @param v0 low v weight\n     * @param v1 high v weight\n     * @param w0 low w weight\n     * @param w1 high w weight\n     */\n    static evaluateTrilinearWeights(weights, u0, u1, v0, v1, w0, w1) {\n        weights[0] = u0 * v0 * w0;\n        weights[1] = u1 * v0 * w0;\n        weights[2] = u0 * v1 * w0;\n        weights[3] = u1 * v1 * w0;\n        weights[4] = u0 * v0 * w1;\n        weights[5] = u1 * v0 * w1;\n        weights[6] = u0 * v1 * w1;\n        weights[7] = u1 * v1 * w1;\n    }\n    /**\n     * sum the weighted x components from a point array.\n     * * weights.length is the number of summed terms\n     * * points must have at least that length\n     * @param weights\n     * @param points\n     */\n    static sumWeightedX(weights, points) {\n        let sum = 0.0;\n        const n = weights.length;\n        for (let i = 0; i < n; i++)\n            sum += weights[i] * points[i].x;\n        return sum;\n    }\n    /**\n     * sum the weighted x components from a point array.\n     * * weights.length is the number of summed terms\n     * * points must have at least that length\n     * @param weights\n     * @param points\n     */\n    static sumWeightedY(weights, points) {\n        let sum = 0.0;\n        const n = weights.length;\n        for (let i = 0; i < n; i++)\n            sum += weights[i] * points[i].y;\n        return sum;\n    }\n    /**\n     * sum the weighted x components from a point array.\n     * * weights.length is the number of summed terms\n     * * points must have at least that length\n     * @param weights\n     * @param points\n     */\n    static sumWeightedZ(weights, points) {\n        let sum = 0.0;\n        const n = weights.length;\n        for (let i = 0; i < n; i++)\n            sum += weights[i] * points[i].z;\n        return sum;\n    }\n    /**\n     * Compute a point by trilinear mapping.\n     * @param points array of 8 points at corners, with x index varying fastest.\n     * @param result optional result point\n     */\n    static evaluateTrilinearPoint(points, u, v, w, result) {\n        if (!result)\n            result = Point3d.create(0, 0, 0);\n        this.evaluateTrilinearWeights(this._weightUVW, 1 - u, u, 1 - v, v, 1 - w, w);\n        let a;\n        for (let i = 0; i < 8; i++) {\n            a = this._weightUVW[i];\n            result.x += a * points[i].x;\n            result.y += a * points[i].y;\n            result.z += a * points[i].z;\n        }\n        return result;\n    }\n    /**\n     * Compute a point and derivatives wrt uvw by trilinear mapping.\n     * * evaluated point is the point part of the transform\n     * * u,v,w derivatives are the respective columns of the matrix part of the transform.\n     * @param points array of 8 points at corners, with x index varying fastest.\n     * @param result optional result transform\n     */\n    static evaluateTrilinearDerivativeTransform(points, u, v, w, result) {\n        this.evaluateTrilinearWeights(this._weightUVW, 1 - u, u, 1 - v, v, 1 - w, w);\n        this.evaluateTrilinearWeights(this._weightDU, -1, 1, 1 - v, v, 1 - w, w);\n        this.evaluateTrilinearWeights(this._weightDV, 1 - u, u, -1, 1, 1 - w, w);\n        this.evaluateTrilinearWeights(this._weightDW, 1 - u, u, 1 - v, v, -1, 1);\n        return Transform.createRowValues(this.sumWeightedX(this._weightDU, points), this.sumWeightedX(this._weightDV, points), this.sumWeightedX(this._weightDW, points), this.sumWeightedX(this._weightUVW, points), this.sumWeightedY(this._weightDU, points), this.sumWeightedY(this._weightDV, points), this.sumWeightedY(this._weightDW, points), this.sumWeightedY(this._weightUVW, points), this.sumWeightedZ(this._weightDU, points), this.sumWeightedZ(this._weightDV, points), this.sumWeightedZ(this._weightDW, points), this.sumWeightedZ(this._weightUVW, points), result);\n    }\n    /** unpack from a number array or Float64Array to an array of `Point3d` */\n    static unpackNumbersToPoint3dArray(data) {\n        const result = [];\n        for (let i = 0; i + 2 < data.length; i += 3) {\n            result.push(Point3d.create(data[i], data[i + 1], data[i + 2]));\n        }\n        return result;\n    }\n    /**\n     * return an 2-dimensional array containing all the values of `data` in arrays of numPerBlock\n     * @param data simple array of numbers\n     * @param numPerBlock number of values in each block at first level down\n     */\n    static unpackNumbersToNestedArrays(data, numPerBlock) {\n        const result = [];\n        const n = data.length;\n        let i = 0;\n        let i1 = 0;\n        while (i < n) {\n            // there is at least one more value for a block\n            const row = [];\n            i1 = i + numPerBlock;\n            if (i1 > n)\n                i1 = n;\n            for (; i < i1; i++) {\n                row.push(data[i]);\n            }\n            result.push(row);\n        }\n        return result;\n    }\n    /**\n     * return an 3-dimensional array containing all the values of `data` in arrays numPerRow blocks of numPerBlock\n     * @param data simple array of numbers\n     * @param numPerBlock number of values in each block at first level down\n     */\n    static unpackNumbersToNestedArraysIJK(data, numPerBlock, numPerRow) {\n        const result = [];\n        const n = data.length;\n        let i = 0;\n        let i1 = 0;\n        let i2;\n        while (i < n) {\n            const row = [];\n            i2 = i + numPerBlock * numPerRow;\n            while (i < i2) {\n                const block = [];\n                i1 = i + numPerBlock;\n                if (i1 > n)\n                    i1 = n;\n                for (; i < i1; i++) {\n                    block.push(data[i]);\n                }\n                row.push(block);\n            }\n            result.push(row);\n        }\n        return result;\n    }\n    /**  multiply a transform times each x,y,z triple and replace the x,y,z in the packed array */\n    static multiplyInPlace(transform, xyz) {\n        const xyz1 = Point3d.create();\n        const numXYZ = xyz.length;\n        for (let i = 0; i + 2 < numXYZ; i += 3) {\n            transform.multiplyXYZ(xyz[i], xyz[i + 1], xyz[i + 2], xyz1);\n            xyz[i] = xyz1.x;\n            xyz[i + 1] = xyz1.y;\n            xyz[i + 2] = xyz1.z;\n        }\n    }\n    /** Apply Geometry.isAlmostEqual to corresponding coordinates */\n    static isAlmostEqual(dataA, dataB) {\n        if (dataA && dataB) {\n            if (dataA.length !== dataB.length)\n                return false;\n            if (dataA instanceof Float64Array && dataB instanceof Float64Array) {\n                for (let i = 0; i < dataA.length; i++)\n                    if (!Geometry.isSameCoordinate(dataA[i], dataB[i]))\n                        return false;\n            }\n            else if (Array.isArray(dataA) && Array.isArray(dataB)) {\n                for (let i = 0; i < dataA.length; i++)\n                    if (!dataA[i].isAlmostEqual(dataB[i]))\n                        return false;\n            }\n            return true;\n        }\n        // if both are null it is equal, otherwise unequal\n        return (dataA === undefined && dataB === undefined);\n    }\n    /** return simple average of all coordinates.   (000 if empty array) */\n    static centroid(points, result) {\n        if (points instanceof IndexedXYZCollection) {\n            result = Point3d.create(0, 0, 0, result);\n            const p = Point3d.create();\n            if (points.length > 0) {\n                for (let i = 0; i < points.length; i++) {\n                    points.getPoint3dAtCheckedPointIndex(i, p);\n                    result.x += p.x;\n                    result.y += p.y;\n                    result.z += p.z;\n                }\n                result.scaleInPlace(1.0 / points.length);\n            }\n            return result;\n        }\n        const carrier = new Point3dArrayCarrier(points);\n        return this.centroid(carrier);\n    }\n    /** Return the index of the point most distant from spacePoint */\n    static indexOfMostDistantPoint(points, spacePoint, farVector) {\n        if (points.length === 0)\n            return undefined;\n        let dMax = -1;\n        let d;\n        let result = -1;\n        for (let i = 0; i < points.length; i++) {\n            d = spacePoint.distance(points[i]);\n            if (d > dMax) {\n                spacePoint.vectorTo(points[i], farVector);\n                dMax = d;\n                result = i;\n            }\n        }\n        return result;\n    }\n    /** return the index of the point whose vector from space point has the largest magnitude of cross product with given vector. */\n    static indexOfPointWithMaxCrossProductMagnitude(points, spacePoint, vector, farVector) {\n        if (points.length === 0)\n            return undefined;\n        let dMax = -1;\n        let d;\n        let result = -1;\n        let vectorAB; // to be reused in loop !!!\n        for (let i = 0; i < points.length; i++) {\n            vectorAB = spacePoint.vectorTo(points[i], vectorAB);\n            d = vectorAB.crossProductMagnitude(vector);\n            if (d > dMax) {\n                farVector.setFrom(vectorAB);\n                dMax = d;\n                result = i;\n            }\n        }\n        return result;\n    }\n    /** Return the index of the closest point in the array (full xyz) */\n    static closestPointIndex(data, spacePoint) {\n        let index = -1;\n        let dMin = Number.MAX_VALUE;\n        let d;\n        const x0 = spacePoint.x;\n        const y0 = spacePoint.y;\n        const z0 = spacePoint.z;\n        for (let i = 0; i < data.length; i++) {\n            d = Geometry.distanceXYZXYZ(x0, y0, z0, data[i].x, data[i].y, data[i].z);\n            if (d < dMin) {\n                index = i;\n                dMin = d;\n            }\n        }\n        return index;\n    }\n    /** return true iff all points' altitudes are within tolerance of the plane.*/\n    static isCloseToPlane(data, plane, tolerance = Geometry.smallMetricDistance) {\n        if (Array.isArray(data)) {\n            let xyz;\n            for (xyz of data) {\n                if (Math.abs(plane.altitude(xyz)) > tolerance)\n                    return false;\n            }\n        }\n        else if (data instanceof Float64Array) {\n            const numXYZ = data.length;\n            for (let i = 0; i + 2 < numXYZ; i += 3) {\n                if (Math.abs(plane.altitudeXYZ(data[i], data[i + 1], data[i + 2])) > tolerance)\n                    return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Sum lengths of edges.\n     * @param data points.\n     */\n    static sumEdgeLengths(data, addClosureEdge = false, maxPointsToUse) {\n        let sum = 0.0;\n        if (Array.isArray(data)) {\n            const n = selectOptionalClampedMin(data.length, maxPointsToUse, 1) - 1;\n            for (let i = 0; i < n; i++)\n                sum += data[i].distance(data[i + 1]);\n            if (addClosureEdge && n > 0)\n                sum += data[0].distance(data[n]);\n        }\n        else if (data instanceof Float64Array) {\n            const numXYZ = selectOptionalClampedMin(data.length, maxPointsToUse, 3);\n            let i = 0;\n            for (; i + 5 < numXYZ; i += 3) { // final i points at final point x\n                sum += Geometry.hypotenuseXYZ(data[i + 3] - data[i], data[i + 4] - data[i + 1], data[i + 5] - data[i + 2]);\n            }\n            if (addClosureEdge && i >= 3) {\n                sum += Geometry.hypotenuseXYZ(data[0] - data[i], data[1] - data[i + 1], data[2] - data[i + 2]);\n            }\n        }\n        return sum;\n    }\n    /**\n     * Count the number of points, but ...\n     * * ignore trailing duplicates of point 0.\n     * * return 0 if there are any duplicates within the remaining points.\n     * @param points points to examine.\n     */\n    static countNonDuplicates(points, tolerance = Geometry.smallMetricDistance) {\n        let n = points.length;\n        // strip of (allow) trailing duplicates ...\n        while (n > 1) {\n            if (points[0].isAlmostEqual(points[n - 1], tolerance))\n                n--;\n            else\n                break;\n        }\n        for (let i = 0; i + 1 < n; i++)\n            if (points[i].isAlmostEqual(points[i + 1], tolerance))\n                return 0;\n        return n;\n    }\n    /**\n     * Return an array containing clones of the Point3d data[]\n     * @param data source data\n     */\n    static clonePoint3dArray(data) {\n        const result = [];\n        if (data.length === 0)\n            return result;\n        if (data instanceof Float64Array) {\n            for (let i = 0; i + 2 < data.length; i += 3)\n                result.push(Point3d.create(data[i], data[i + 1], data[i + 2]));\n            return result;\n        }\n        for (const p of data) {\n            if (Array.isArray(p))\n                result.push(Point3d.create(p[0], p[1], p[2]));\n            else\n                result.push(Point3d.create(p.x, p.y, p.z));\n        }\n        return result;\n    }\n    /**\n     * Return an array containing Point2d with xy parts of each Point3d\n     * @param data source data\n     */\n    static clonePoint2dArray(data) {\n        return data.map((p) => Point2d.create(p.x, p.y));\n    }\n    /**\n     * clone points in the input array, inserting points within each edge to limit edge length.\n     * @param points array of points\n     * @param maxEdgeLength max length of an edge\n     */\n    static cloneWithMaxEdgeLength(points, maxEdgeLength) {\n        if (points.length === 0)\n            return [];\n        const result = [points[0]];\n        for (let i = 1; i < points.length; i++) {\n            const a = points[i - 1].distance(points[i]);\n            const n = Geometry.stepCount(maxEdgeLength, a, 1);\n            for (let k = 1; k < n; k++)\n                result.push(points[i - 1].interpolate(k / n, points[i]));\n            result.push(points[i]);\n        }\n        return result;\n    }\n    /** Pack isolated x,y,z args as a json `[x,y,z]` */\n    static xyzToArray(x, y, z) { return [x, y, z]; }\n    /**\n     * return similarly-structured array, array of arrays, etc, with the lowest level point data specifically structured as arrays of 3 numbers `[1,2,3]`\n     * @param data point data with various leaf forms such as `[1,2,3]`, `{x:1,y:2,z:3}`, `Point3d`\n     */\n    static cloneDeepJSONNumberArrays(data) {\n        const collector = new PointStringDeepXYZArrayCollector((x, y, z) => this.xyzToArray(x, y, z));\n        VariantPointDataStream.streamXYZ(data, collector);\n        return collector.claimResult();\n    }\n    /**\n     * clone an array of [[XYZProps]] data, specifically as arrays of 3 numbers\n     */\n    static cloneXYZPropsAsNumberArray(data) {\n        // data is an array ... each member is either Point3d or [x,y,z]\n        const result = [];\n        for (const p of data) {\n            if (p instanceof Point3d) {\n                result.push([p.x, p.y, p.z]);\n            }\n            else if (Array.isArray(p)) {\n                result.push([p[0], p[1], p.length > 2 ? p[2] : 0.0]);\n            }\n        }\n        return result;\n    }\n    /**\n     * clone an array of [[XYZProps]] data, specifically as flattened array of number\n     */\n    static cloneXYZPropsAsFloat64Array(data) {\n        const result = new Float64Array(data.length * 3);\n        let i = 0;\n        for (const p of data) {\n            if (p instanceof Point3d) {\n                result[i++] = p.x;\n                result[i++] = p.y;\n                result[i++] = p.z;\n            }\n            else if (Array.isArray(p)) {\n                result[i++] = p[0];\n                result[i++] = p[1];\n                result[i++] = p.length > 2 ? p[2] : 0.0; // allow missing z\n            }\n        }\n        return result;\n    }\n    /**\n     * return similarly-structured array, array of arrays, etc, with the lowest level point data specifically structured as `Point3d`.\n     * @param data point data with various leaf forms such as `[1,2,3]`, `{x:1,y:2,z:3}`, `Point3d`\n     */\n    static cloneDeepXYZPoint3dArrays(data) {\n        const collector = new PointStringDeepXYZArrayCollector((x, y, z) => Point3d.create(x, y, z));\n        VariantPointDataStream.streamXYZ(data, collector);\n        return collector.claimResult();\n    }\n    /**\n     * return perpendicular distance from points[indexB] to the segment points[indexA] to points[indexC].\n     * * extrapolation option when projection is outside of fraction range 0..1 are:\n     *   * false ==> measure distance to closest endpoint\n     *   * true ==> measure distance to extended line segment.\n     * (no index checking!)\n     */\n    static distanceIndexedPointBToSegmentAC(points, indexA, indexB, indexC, extrapolate) {\n        const vectorU = Vector3d.createStartEnd(points[indexA], points[indexC]);\n        const vectorV = Vector3d.createStartEnd(points[indexA], points[indexB]);\n        const uDotU = vectorU.dotProduct(vectorU);\n        const uDotV = vectorU.dotProduct(vectorV);\n        let fraction = Geometry.conditionalDivideFraction(uDotV, uDotU);\n        if (fraction === undefined)\n            fraction = 0.0;\n        if (!extrapolate) {\n            if (fraction > 1.0)\n                fraction = 1.0;\n            if (fraction < 0.0)\n                fraction = 0.0;\n        }\n        let h2 = vectorV.magnitudeSquared() - fraction * fraction * uDotU;\n        // h2 should never be negative except for quirky tolerance ..\n        if (h2 < 0.0)\n            h2 = 0.0;\n        return Math.sqrt(h2);\n    }\n    /** Computes the hull of the XY projection of points.\n     * * Returns the hull as an array of Point3d\n     * * Optionally returns non-hull points in `insidePoints[]`\n     * * If both arrays empty if less than 3 points.\n     * *\n     */\n    static computeConvexHullXY(points, hullPoints, insidePoints, addClosurePoint = false) {\n        hullPoints.length = 0;\n        insidePoints.length = 0;\n        let n = points.length;\n        // Get deep copy\n        const xy1 = points.slice(0, n);\n        xy1.sort((a, b) => Geometry.lexicalXYLessThan(a, b));\n        if (n < 3) {\n            for (const p of xy1)\n                hullPoints.push(p);\n            if (addClosurePoint && xy1.length > 0)\n                hullPoints.push(xy1[0]);\n            return;\n        }\n        hullPoints.push(xy1[0]); // This is sure to stay\n        hullPoints.push(xy1[1]); // This one can be removed in loop.\n        let numInside = 0;\n        // First sweep creates upper hull\n        for (let i = 2; i < n; i++) {\n            const candidate = xy1[i];\n            let top = hullPoints.length - 1;\n            while (top >= 1 && hullPoints[top - 1].crossProductToPointsXY(hullPoints[top], candidate) <= 0.0) {\n                xy1[numInside++] = hullPoints[top];\n                top--;\n                hullPoints.pop();\n            }\n            hullPoints.push(candidate);\n        }\n        const i0 = hullPoints.length - 1;\n        xy1.length = numInside;\n        xy1.push(hullPoints[0]); // force first point to be reconsidered as final hull point.\n        xy1.sort((a, b) => Geometry.lexicalXYLessThan(a, b));\n        n = xy1.length;\n        // xy1.back () is already on stack.\n        hullPoints.push(xy1[n - 1]);\n        for (let i = n - 1; i-- > 0;) {\n            const candidate = xy1[i];\n            let top = hullPoints.length - 1;\n            while (top > i0 && hullPoints[top - 1].crossProductToPointsXY(hullPoints[top], candidate) <= 0.0) {\n                insidePoints.push(hullPoints[top]);\n                top--;\n                hullPoints.pop();\n            }\n            if (i > 0) // don't replicate start !!!\n                hullPoints.push(candidate);\n        }\n        if (addClosurePoint)\n            hullPoints.push(hullPoints[0]);\n    }\n    /**\n     * Return (clones of) points in data[] with min and max x and y parts.\n     * @param data array to examine.\n     */\n    static minMaxPoints(data) {\n        if (data.length === 0)\n            return undefined;\n        const result = { minXPoint: data[0].clone(), maxXPoint: data[0].clone(), minYPoint: data[0].clone(), maxYPoint: data[0].clone() };\n        let q;\n        for (let i = 1; i < data.length; i++) {\n            q = data[i];\n            if (q.x < result.minXPoint.x)\n                result.minXPoint.setFromPoint3d(q);\n            if (q.x > result.maxXPoint.x)\n                result.maxXPoint.setFromPoint3d(q);\n            if (q.y < result.minYPoint.y)\n                result.minYPoint.setFromPoint3d(q);\n            if (q.y > result.maxYPoint.y)\n                result.maxYPoint.setFromPoint3d(q);\n        }\n        return result;\n    }\n}\nPoint3dArray._weightUVW = new Float64Array(8);\nPoint3dArray._weightDU = new Float64Array(8);\nPoint3dArray._weightDV = new Float64Array(8);\nPoint3dArray._weightDW = new Float64Array(8);\nexport { Point3dArray };\n//# sourceMappingURL=PointHelpers.js.map",
      "start": 1693508122356,
      "end": 1693508122505,
      "sourcemaps": null
    }
  ]
}
