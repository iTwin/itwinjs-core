{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/ViewGlobalLocation.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Views\n */\nimport { GlobeMode } from \"@itwin/core-common\";\nimport { BingElevationProvider } from \"./tile/internal\";\nimport { ViewState3d } from \"./ViewState\";\n/** @internal */\nclass ViewGlobalLocationConstants {\n}\nViewGlobalLocationConstants.birdHeightAboveEarthInMeters = 713.0;\nViewGlobalLocationConstants.satelliteHeightAboveEarthInMeters = 402336.0 * 24;\nViewGlobalLocationConstants.largestEarthArc = 20037500.0; // distance from point on earth to opposite point in meters\nViewGlobalLocationConstants.birdPitchAngleRadians = 0.0; // Angle.piOver4Radians;\nViewGlobalLocationConstants.maximumDistanceToDrive = 96560.6; // The distance in meters that we will \"drive\" instead of fly to a destination (60 miles)\nexport { ViewGlobalLocationConstants };\n/** Converts a distance in meters to some range (smaller distances result in lower number; longer distances result in larger number)\n * Uses 500 for minimum output and 3000 for maximum output, unless either are specified.\n * Uses [[ViewGlobalLocationConstants.satelliteHeightAboveEarthInMeters]] as maximum input meters unless specified.\n * A good use of this is to convert meters to some transition duration.\n * @internal\n */\nexport function metersToRange(inputMeters, minimumOutput = 500, maximumOutput = 3000, maximumInputMeters = ViewGlobalLocationConstants.satelliteHeightAboveEarthInMeters) {\n    let output;\n    if (inputMeters <= 0)\n        output = minimumOutput;\n    else if (inputMeters >= maximumInputMeters)\n        output = maximumOutput;\n    else {\n        const quickLerp = (start, end, amt) => {\n            return (1 - amt) * start + amt * end;\n        };\n        output = quickLerp(minimumOutput, maximumOutput, inputMeters / maximumInputMeters);\n    }\n    return output;\n}\n/** Queries the actual elevation of a cartographic point on the globe (using Bing elevation services)\n * @public\n * @extensions\n */\nexport async function queryTerrainElevationOffset(viewport, carto) {\n    const bingElevationProvider = new BingElevationProvider();\n    if (viewport && viewport.view instanceof ViewState3d && viewport.iModel.isGeoLocated) {\n        const view3d = viewport.view;\n        if (view3d.displayStyle.displayTerrain) {\n            const elevationOffset = await bingElevationProvider.getHeight(carto, view3d.globeMode === GlobeMode.Ellipsoid);\n            if (elevationOffset !== undefined)\n                return elevationOffset;\n        }\n    }\n    return 0;\n}\nfunction _areaToEyeHeight(view3d, ne, sw, offset = 0) {\n    if (ne === undefined || sw === undefined)\n        return 0;\n    const diagonal = ne.distance(sw);\n    view3d.camera.validateLens();\n    const td = Math.tan(view3d.camera.getLensAngle().radians / 2.0);\n    return 0 !== td ? (diagonal / (2 * td) + offset) : offset;\n}\n/** Converts a cartographic area on the globe to an ideal eye height to view that area.\n * Offset in meters, which defaults to 0, is applied to final eye height.\n * @internal\n */\nexport function areaToEyeHeight(view3d, area, offset = 0) {\n    const ne = view3d.cartographicToRoot(area.northeast);\n    const sw = view3d.cartographicToRoot(area.southwest);\n    return _areaToEyeHeight(view3d, ne, sw, offset);\n}\n/** Converts a cartographic area on the globe to an ideal eye height to view that area using the GCS.\n * Offset in meters, which defaults to 0, is applied to final eye height.\n * @internal\n */\nexport async function areaToEyeHeightFromGcs(view3d, area, offset = 0) {\n    const corners = await view3d.cartographicToRootUsingGcs([area.northeast, area.southwest]);\n    if (!corners)\n        return 0;\n    return _areaToEyeHeight(view3d, corners[0], corners[1], offset);\n}\n/** Converts a root range (often project extents) to a cartographic area.\n * @internal\n */\nexport function rangeToCartographicArea(view3d, range) {\n    const low = view3d.rootToCartographic(range.low);\n    const high = view3d.rootToCartographic(range.high);\n    if (low === undefined || high === undefined)\n        return undefined;\n    return low.latitude < high.latitude ? { northeast: high, southwest: low } : { northeast: low, southwest: high };\n}\n/** Converts the eye of the camera to a cartographic location on the globe as if it was at height 0.\n * If preserveHeight is set to true, then height will remain untouched.\n * @internal\n */\nexport function eyeToCartographicOnGlobe(viewport, preserveHeight = false) {\n    if (!(viewport.view instanceof ViewState3d) || !viewport.iModel.isGeoLocated)\n        return undefined;\n    const view3d = viewport.view;\n    const eyePointCartographic = view3d.rootToCartographic(view3d.getEyeOrOrthographicViewPoint());\n    if (eyePointCartographic !== undefined) {\n        if (!preserveHeight)\n            eyePointCartographic.height = 0.0;\n        return eyePointCartographic;\n    }\n    return undefined;\n}\n/** Converts the eye of the camera to a cartographic location on the globe as if it was at height 0 using the GCS.\n * If preserveHeight is set to true, then height will remain untouched.\n * @internal\n */\nexport async function eyeToCartographicOnGlobeFromGcs(viewport, preserveHeight = false) {\n    if (!(viewport.view instanceof ViewState3d) || !viewport.iModel.isGeoLocated)\n        return undefined;\n    const view3d = viewport.view;\n    const eyePointCartographic = await view3d.rootToCartographicFromGcs(view3d.getEyeOrOrthographicViewPoint());\n    if (eyePointCartographic !== undefined) {\n        if (!preserveHeight)\n            eyePointCartographic.height = 0.0;\n        return eyePointCartographic;\n    }\n    return undefined;\n}\n/** @internal */\nexport function viewGlobalLocation(viewport, doAnimate, eyeHeight = ViewGlobalLocationConstants.birdHeightAboveEarthInMeters, pitchAngleRadians = 0, location) {\n    if (!(viewport.view instanceof ViewState3d))\n        return 0;\n    const before = viewport.getFrustum();\n    const view3d = viewport.view;\n    const transitionDistance = view3d.lookAtGlobalLocation(eyeHeight, pitchAngleRadians, location);\n    viewport.synchWithView();\n    if (doAnimate)\n        viewport.animateToCurrent(before, { animationTime: metersToRange(transitionDistance) });\n    return transitionDistance;\n}\n//# sourceMappingURL=ViewGlobalLocation.js.map",
      "start": 1693508119264,
      "end": 1693508119415,
      "sourcemaps": null
    }
  ]
}
