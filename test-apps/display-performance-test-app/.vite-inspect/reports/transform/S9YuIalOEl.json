{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/clipping/ClipVector.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module CartesianGeometry\n */\nimport { assert } from \"@itwin/core-bentley\";\nimport { LineSegment3d } from \"../curve/LineSegment3d\";\nimport { Geometry } from \"../Geometry\";\nimport { Range3d } from \"../geometry3d/Range\";\nimport { Transform } from \"../geometry3d/Transform\";\nimport { BooleanClipNodeIntersection } from \"./BooleanClipNode\";\nimport { ClipMaskXYZRangePlanes, ClipPrimitive, ClipShape } from \"./ClipPrimitive\";\nimport { ClipPlaneContainment } from \"./ClipUtils\";\n/**\n * Class holding an array structure of shapes defined by `ClipPrimitive`\n * * The `ClipVector` defines an intersection of the member `ClipPrimitive` regions.\n * * In the most common usage, one of the `ClipPrimitive` will be an outer region, and all others are holes with marker\n * flag indicating that the outside of each hole is live.\n * @public\n */\nclass ClipVector {\n    /** Returns a reference to the array of ClipShapes. */\n    get clips() { return this._clips; }\n    constructor(clips) {\n        /**\n         * Range acting as first filter.\n         * * This is understood as overall range limit, not as precise planes.\n         * * Applying any rotation to the whole ClipVector generally expands this range, rather than exactly transforming\n         * its planes.\n         */\n        this.boundingRange = Range3d.createNull();\n        this._clips = clips ? clips : [];\n    }\n    /** Returns true if this ClipVector contains a ClipPrimitive. */\n    get isValid() { return this._clips.length > 0; }\n    /** Create a ClipVector with an empty set of ClipShapes. */\n    static createEmpty(result) {\n        if (result) {\n            result._clips.length = 0;\n            return result;\n        }\n        return new ClipVector();\n    }\n    /** Create a ClipVector from an array of ClipPrimitives (or derived classes) (capture the pointers) */\n    static createCapture(clips, result) {\n        if (result) {\n            result._clips = clips;\n            return result;\n        }\n        return new ClipVector(clips);\n    }\n    /** Create a ClipVector from (clones of) an array of ClipPrimitives */\n    static create(clips, result) {\n        const clipClones = [];\n        for (const clip of clips)\n            clipClones.push(clip.clone());\n        return ClipVector.createCapture(clipClones, result);\n    }\n    /** Create a deep copy of another ClipVector */\n    clone(result) {\n        const retVal = result ? result : new ClipVector();\n        retVal._clips.length = 0;\n        for (const clip of this._clips) {\n            retVal._clips.push(clip.clone());\n        }\n        retVal.boundingRange.setFrom(this.boundingRange);\n        return retVal;\n    }\n    /** Parse this ClipVector into a JSON object. */\n    toJSON() {\n        if (!this.isValid)\n            return [];\n        return this.clips.map((clip) => clip.toJSON());\n    }\n    /** Parse a JSON object into a new ClipVector. */\n    static fromJSON(json, result) {\n        result = result ? result : new ClipVector();\n        result.clear();\n        if (!Array.isArray(json))\n            return result;\n        try {\n            for (const clip of json) {\n                const clipPrim = ClipPrimitive.fromJSON(clip);\n                if (clipPrim)\n                    result._clips.push(clipPrim);\n            }\n        }\n        catch (e) {\n            result.clear();\n        }\n        return result;\n    }\n    /** Empties out the array of ClipShapes. */\n    clear() {\n        this._clips.length = 0;\n    }\n    /** Append a deep copy of the given ClipPrimitive to this ClipVector. */\n    appendClone(clip) {\n        this._clips.push(clip.clone());\n    }\n    /** Append a reference of the given ClipPrimitive to this ClipVector. */\n    appendReference(clip) {\n        this._clips.push(clip);\n    }\n    /** Create and append a new ClipPrimitive to the array given a shape as an array of points. Returns true if successful. */\n    appendShape(shape, zLow, zHigh, transform, isMask = false, invisible = false) {\n        const clip = ClipShape.createShape(shape, zLow, zHigh, transform, isMask, invisible);\n        if (!clip)\n            return false;\n        this._clips.push(clip);\n        return true;\n    }\n    /** Returns true if the given point lies inside all of this ClipVector's ClipShapes (by rule of intersection).*/\n    pointInside(point, onTolerance = Geometry.smallMetricDistanceSquared) {\n        return this.isPointOnOrInside(point, onTolerance);\n    }\n    /**\n     * Method from [[Clipper]] interface.\n     * * Implement as dispatch to clipPlaneSets as supplied by derived class.\n     */\n    isPointOnOrInside(point, onTolerance = Geometry.smallMetricDistanceSquared) {\n        if (!this.boundingRange.isNull && !this.boundingRange.containsPoint(point))\n            return false;\n        for (const clip of this._clips) {\n            if (!clip.pointInside(point, onTolerance))\n                return false;\n        }\n        return true;\n    }\n    ensureProxyClipNode() {\n        if (this._clipNodeProxy)\n            return true;\n        this._clipNodeProxy = new BooleanClipNodeIntersection(true);\n        let numChildren = 0;\n        for (const child of this._clips) {\n            const q = child.fetchClipPlanesRef();\n            if (q) {\n                numChildren++;\n                this._clipNodeProxy.captureChild(q);\n            }\n        }\n        return numChildren > 0;\n    }\n    /**\n     * Method from [[Clipper]] interface.\n     * * Implement as dispatch to clipPlaneSets as supplied by derived class.\n     */\n    announceClippedSegmentIntervals(f0, f1, pointA, pointB, announce) {\n        this.ensureProxyClipNode();\n        if (this._clipNodeProxy)\n            return this._clipNodeProxy.announceClippedSegmentIntervals(f0, f1, pointA, pointB, announce);\n        return false;\n    }\n    /** Method from [[Clipper]] interface.\n     * * Implement as dispatch to clipPlaneSets as supplied by derived class.\n     */\n    announceClippedArcIntervals(arc, announce) {\n        this.ensureProxyClipNode();\n        if (this._clipNodeProxy)\n            return this._clipNodeProxy.announceClippedArcIntervals(arc, announce);\n        return false;\n    }\n    /** Execute polygon clip as intersection of the child primitives. */\n    appendPolygonClip(xyz, insideFragments, outsideFragments, arrayCache) {\n        this.ensureProxyClipNode();\n        if (this._clipNodeProxy)\n            this._clipNodeProxy.appendPolygonClip(xyz, insideFragments, outsideFragments, arrayCache);\n    }\n    /**\n     * Transforms this ClipVector to a new coordinate-system.\n     * Note that if the transform has rotate and scale the boundingRange member expands.\n     * Returns true if successful.\n     */\n    transformInPlace(transform) {\n        for (const clip of this._clips)\n            if (clip.transformInPlace(transform) === false)\n                return false;\n        if (!this.boundingRange.isNull)\n            transform.multiplyRange(this.boundingRange, this.boundingRange);\n        return true;\n    }\n    /**\n     * A simple way of packaging this ClipVector's ClipShape points into a multidimensional array, while also\n     * taking into account each ClipPrimitive's individual transforms.\n     * ClipPrimitives OTHER THAN ClipShape are ignored.\n     * Information out:\n     *  - All of the loop points are stored in the multidimensional Point3d array given (will return unchanged upon failure).\n     *  - If given a transform, will be set from the transformFromClip of the first ClipPrimitive.\n     *  - The ClipMask of the final ClipPrimitive is stored in the returned array at index 0.\n     *  - The last valid zLow found is stored in the returned array at index 1.\n     *  - The last valid zHigh found is stored in the returned array at index 2.\n     */\n    extractBoundaryLoops(loopPoints, transform) {\n        let clipM = ClipMaskXYZRangePlanes.None;\n        let zBack = -Number.MAX_VALUE;\n        let zFront = Number.MAX_VALUE;\n        const retVal = [];\n        let nLoops = 0;\n        if (this._clips.length === 0)\n            return retVal;\n        let firstClipShape;\n        const deltaTrans = Transform.createIdentity();\n        for (const clip of this._clips) {\n            if (clip instanceof ClipShape) {\n                if (firstClipShape !== undefined && clip !== firstClipShape) { // Is not the first iteration\n                    let fwdTrans = Transform.createIdentity();\n                    let invTrans = Transform.createIdentity();\n                    if (firstClipShape.transformValid && clip.transformValid) {\n                        fwdTrans = clip.transformFromClip.clone();\n                        invTrans = firstClipShape.transformToClip.clone();\n                    }\n                    deltaTrans.setFrom(invTrans.multiplyTransformTransform(fwdTrans));\n                }\n                if (!firstClipShape)\n                    firstClipShape = clip;\n                loopPoints[nLoops] = [];\n                if (clip.polygon !== undefined) {\n                    clipM = ClipMaskXYZRangePlanes.XAndY;\n                    if (clip.zHighValid) {\n                        clipM = clipM | ClipMaskXYZRangePlanes.ZHigh;\n                        zFront = clip.zHigh;\n                    }\n                    if (clip.zLowValid) {\n                        clipM = clipM | ClipMaskXYZRangePlanes.ZLow;\n                        zBack = clip.zLow;\n                    }\n                    for (const point of clip.polygon)\n                        loopPoints[nLoops].push(point.clone());\n                    deltaTrans.multiplyPoint3dArray(loopPoints[nLoops], loopPoints[nLoops]);\n                    nLoops++;\n                }\n            }\n        }\n        retVal.push(clipM);\n        retVal.push(zBack);\n        retVal.push(zFront);\n        if (transform && firstClipShape)\n            transform.setFrom(firstClipShape.transformFromClip);\n        return retVal;\n    }\n    /** Sets this ClipVector and all of its members to the visibility specified. */\n    setInvisible(invisible) {\n        for (const clip of this._clips)\n            clip.setInvisible(invisible);\n    }\n    /**\n     * For every clip, parse the member point array into the member clip plane object (only for clipPlanes member,\n     * not the mask)\n     */\n    parseClipPlanes() {\n        for (const clip of this._clips)\n            clip.fetchClipPlanesRef();\n    }\n    /**\n     * Multiply all ClipPlanes DPoint4d by matrix.\n     * @param matrix matrix to apply.\n     * @param invert if true, use in verse of the matrix.\n     * @param transpose if true, use the transpose of the matrix (or inverse, per invert parameter)\n     * * Note that if matrixA is applied to all of space, the matrix to send to this method to get a corresponding effect on the plane is the inverse transpose of matrixA\n     * * Callers that will apply the same matrix to many planes should pre-invert the matrix for efficiency.\n     * * Both params default to true to get the full effect of transforming space.\n     * @param matrix matrix to apply\n     * @returns false if matrix inversion fails.\n     */\n    multiplyPlanesByMatrix4d(matrix, invert = true, transpose = true) {\n        if (invert) { // form inverse once here, reuse for all planes\n            const inverse = matrix.createInverse();\n            if (!inverse)\n                return false;\n            return this.multiplyPlanesByMatrix4d(inverse, false, transpose);\n        }\n        // no inverse necessary -- lower level cannot fail.\n        for (const clip of this._clips)\n            clip.multiplyPlanesByMatrix4d(matrix, false, transpose);\n        return true;\n    }\n    /**\n     * Determines whether the given points fall inside or outside this set of ClipShapes. If any set is defined\n     * by masking planes, checks the mask planes only, provided that ignoreMasks is false. Otherwise, checks the\n     * _clipPlanes member.\n     */\n    classifyPointContainment(points, ignoreMasks = false) {\n        let currentContainment = ClipPlaneContainment.Ambiguous;\n        for (const primitive of this._clips) {\n            const thisContainment = primitive.classifyPointContainment(points, ignoreMasks);\n            if (ClipPlaneContainment.Ambiguous === thisContainment)\n                return ClipPlaneContainment.Ambiguous;\n            if (ClipPlaneContainment.Ambiguous === currentContainment)\n                currentContainment = thisContainment;\n            else if (currentContainment !== thisContainment)\n                return ClipPlaneContainment.Ambiguous;\n        }\n        return currentContainment;\n    }\n    /**\n     * Determines whether a 3D range lies inside or outside this set of ClipShapes. If any set is defined by masking planes,\n     * checks the mask planes only, provided that ignoreMasks is false. Otherwise, checks the clip planes member.\n     */\n    classifyRangeContainment(range, ignoreMasks) {\n        const corners = range.corners();\n        return this.classifyPointContainment(corners, ignoreMasks);\n    }\n    /**\n     * For an array of points (making up a LineString), tests whether the segment between each point lies inside the\n     * ClipVector.\n     * If true, returns true immediately.\n     */\n    isAnyLineStringPointInside(points) {\n        for (const clip of this._clips) {\n            const clipPlaneSet = clip.fetchClipPlanesRef();\n            if (clipPlaneSet !== undefined) {\n                for (let i = 0; i + 1 < points.length; i++) {\n                    const segment = LineSegment3d.create(points[i], points[i + 1]);\n                    if (clipPlaneSet.isAnyPointInOrOnFromSegment(segment))\n                        return true;\n                }\n            }\n        }\n        return false;\n    }\n    /** Note: Line segments are used to represent 1 dimensional intervals here, rather than segments. */\n    sumSizes(intervals, begin, end) {\n        let s = 0.0;\n        for (let i = begin; i < end; i++)\n            s += (intervals[i].x1 - intervals[i].x0);\n        return s;\n    }\n    /**\n     * For an array of points that make up a LineString, develops a line segment between each point pair,\n     * and returns true if all segments lie inside this ClipVector.\n     */\n    isLineStringCompletelyContained(points) {\n        const clipIntervals = [];\n        for (let i = 0; i + 1 < points.length; i++) {\n            const segment = LineSegment3d.create(points[i], points[i + 1]);\n            let fractionSum = 0.0;\n            let index0 = 0;\n            for (const clip of this._clips) {\n                const clipPlaneSet = clip.fetchClipPlanesRef();\n                if (clipPlaneSet !== undefined) {\n                    clipPlaneSet.appendIntervalsFromSegment(segment, clipIntervals);\n                    const index1 = clipIntervals.length;\n                    fractionSum += this.sumSizes(clipIntervals, index0, index1);\n                    index0 = index1;\n                    // ASSUME primitives are non-overlapping...\n                    if (fractionSum >= ClipVector._TARGET_FRACTION_SUM)\n                        break;\n                }\n            }\n            if (fractionSum < ClipVector._TARGET_FRACTION_SUM)\n                return false;\n        }\n        return true;\n    }\n    /**\n     * Serializes this ClipVector to a compact string representation appropriate for transmission as part of a URL.\n     * Chiefly used for requesting [Tile]($frontend)s with section cut facets.\n     * UnionOfConvexClipPlaneSets is obtained for each ClipPrimitive. The encoding is as follows:\n     *  ClipVector:\n     *    ClipPrimitive[]\n     *    _\n     *  ClipPrimitive:\n     *    invisible: 0|1\n     *    ConvexClipPlaneSet[]\n     *    _\n     *  ConvexClipPlaneSet:\n     *    ClipPlane[]\n     *    _\n     *  ClipPlane:\n     *    flags: 0|1|2|3, where 1=invisible and 2=interior\n     *    inwardNormal: Number[3]\n     *    distance: Number\n     *  Number:\n     *    number\n     *    _\n     */\n    toCompactString() {\n        function formatNumber(num) {\n            return `${num.toString()}_`;\n        }\n        function formatVector3d(vec) {\n            return `${formatNumber(vec.x)}${formatNumber(vec.y)}${formatNumber(vec.z)}`;\n        }\n        function formatFlags(flags) {\n            const f = flags.toString();\n            assert(1 === f.length);\n            return f;\n        }\n        function formatPlane(plane) {\n            let flags = plane.invisible ? 1 : 0;\n            flags |= (plane.interior ? 2 : 0);\n            return `${formatFlags(flags)}${formatVector3d(plane.inwardNormalRef)}${formatNumber(plane.distance)}`;\n        }\n        function formatPlaneSet(set) {\n            let planes = \"\";\n            for (const plane of set.planes)\n                planes = `${planes}${formatPlane(plane)}`;\n            return `${planes}_`;\n        }\n        function formatPrimitive(prim) {\n            const flags = prim.invisible ? 1 : 0;\n            let str = flags.toString();\n            assert(1 === str.length);\n            const union = prim.fetchClipPlanesRef();\n            if (union) {\n                for (const s of union.convexSets)\n                    str = `${str}${formatPlaneSet(s)}`;\n            }\n            return `${str}_`;\n        }\n        let result = \"\";\n        for (const primitive of this.clips)\n            result = `${result}${formatPrimitive(primitive)}`;\n        return `${result}_`;\n    }\n}\nClipVector._TARGET_FRACTION_SUM = 0.99999999;\nexport { ClipVector };\n/**\n * Bundles a ClipVector with its compact string representation.\n * @note The string representation is computed once; the ClipVector is assumed not to be subsequently modified.\n * @alpha\n */\nexport var StringifiedClipVector;\n(function (StringifiedClipVector) {\n    /** Create from a ClipVector.\n     * @param clip The ClipVector to stringify.\n     * @returns The input ClipVector with its compact string representation, or undefined if the input is undefined or empty.\n     * @note The string representation is computed once; the ClipVector is assumed not to be subsequently modified.\n     */\n    function fromClipVector(clip) {\n        if (!clip || !clip.isValid)\n            return undefined;\n        const ret = clip;\n        if (undefined === ret.clipString)\n            ret.clipString = clip.toCompactString();\n        const stringified = ret;\n        assert(undefined !== stringified.clipString);\n        return stringified;\n    }\n    StringifiedClipVector.fromClipVector = fromClipVector;\n})(StringifiedClipVector || (StringifiedClipVector = {}));\n//# sourceMappingURL=ClipVector.js.map",
      "start": 1693508122505,
      "end": 1693508122657,
      "sourcemaps": null
    }
  ]
}
