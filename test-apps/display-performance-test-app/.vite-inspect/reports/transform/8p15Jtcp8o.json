{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/curve/internalContexts/CurveCurveIntersectXYZ.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Curve\n */\nimport { BSplineCurve3d, BSplineCurve3dBase } from \"../../bspline/BSplineCurve\";\nimport { Geometry } from \"../../Geometry\";\nimport { NullGeometryHandler } from \"../../geometry3d/GeometryHandler\";\nimport { Plane3dByOriginAndUnitNormal } from \"../../geometry3d/Plane3dByOriginAndUnitNormal\";\nimport { Vector2d } from \"../../geometry3d/Point2dVector2d\";\nimport { Point3d, Vector3d } from \"../../geometry3d/Point3dVector3d\";\nimport { SmallSystem, TrigPolynomial } from \"../../numerics/Polynomials\";\nimport { Arc3d } from \"../Arc3d\";\nimport { CurveIntervalRole, CurveLocationDetail, CurveLocationDetailArrayPair } from \"../CurveLocationDetail\";\nimport { LineSegment3d } from \"../LineSegment3d\";\nimport { LineString3d } from \"../LineString3d\";\n// cspell:word XYRR\n/**\n * Handler class for XYZ intersections between _geometryB and another geometry.\n * * Instances are initialized and called from CurveCurve.\n * * geometryB is saved for later reference.\n * @internal\n */\nclass CurveCurveIntersectXYZ extends NullGeometryHandler {\n    reinitialize() {\n        this._results = new CurveLocationDetailArrayPair();\n    }\n    /**\n     * @param extendA flag to enable using extension of the other geometry.\n     * @param geometryB second curve for intersection.  Saved for reference by specific handler methods.\n     * @param extendB flag for extension of geometryB.\n     */\n    constructor(extendA, geometryB, extendB) {\n        super();\n        this._extendA = extendA;\n        this._geometryB = geometryB;\n        this._extendB = extendB;\n        this.reinitialize();\n    }\n    /**\n     * * Return the results structure for the intersection calculation.\n     * @param reinitialize if true, a new results structure is created for use by later calls.\n     */\n    grabResults(reinitialize = false) {\n        const result = this._results;\n        if (reinitialize)\n            this.reinitialize();\n        return result;\n    }\n    acceptFraction(extend0, fraction, extend1) {\n        if (!extend0 && fraction < 0.0)\n            return false;\n        if (!extend1 && fraction > 1.0)\n            return false;\n        return true;\n    }\n    /**\n     * Compute intersection of two line segments.\n     * Filter by extension rules.\n     * Reject if evaluated points do not match coordinates (e.g. close approach point).\n     * Record with fraction mapping.\n     */\n    recordPointWithLocalFractions(localFractionA, cpA, fractionA0, fractionA1, localFractionB, // Computed intersection fraction\n    cpB, fractionB0, fractionB1, reversed) {\n        const globalFractionA = Geometry.interpolate(fractionA0, localFractionA, fractionA1);\n        const globalFractionB = Geometry.interpolate(fractionB0, localFractionB, fractionB1);\n        // ignore duplicate of most recent point .  ..\n        const numPrevious = this._results.dataA.length;\n        if (numPrevious > 0) {\n            const topFractionA = this._results.dataA[numPrevious - 1].fraction;\n            const topFractionB = this._results.dataB[numPrevious - 1].fraction;\n            if (reversed) {\n                if (Geometry.isAlmostEqualNumber(topFractionA, globalFractionB) &&\n                    Geometry.isAlmostEqualNumber(topFractionB, globalFractionA))\n                    return;\n            }\n            else {\n                if (Geometry.isAlmostEqualNumber(topFractionA, globalFractionA) &&\n                    Geometry.isAlmostEqualNumber(topFractionB, globalFractionB))\n                    return;\n            }\n        }\n        const pointA = cpA.fractionToPoint(globalFractionA);\n        const pointB = cpB.fractionToPoint(globalFractionB);\n        if (!pointA.isAlmostEqualMetric(pointB))\n            return;\n        const detailA = CurveLocationDetail.createCurveFractionPoint(cpA, globalFractionA, pointA);\n        detailA.setIntervalRole(CurveIntervalRole.isolated);\n        const detailB = CurveLocationDetail.createCurveFractionPoint(cpB, globalFractionB, pointB);\n        detailB.setIntervalRole(CurveIntervalRole.isolated);\n        if (reversed) {\n            this._results.dataA.push(detailB);\n            this._results.dataB.push(detailA);\n        }\n        else {\n            this._results.dataA.push(detailA);\n            this._results.dataB.push(detailB);\n        }\n    }\n    /**\n     * Compute intersection of two line segments.\n     * Filter by extension rules.\n     * Record with fraction mapping.\n     */\n    computeSegmentSegment3D(cpA, extendA0, pointA0, fractionA0, pointA1, fractionA1, extendA1, cpB, extendB0, pointB0, fractionB0, pointB1, fractionB1, extendB1, reversed) {\n        const uv = CurveCurveIntersectXYZ._workVector2dA;\n        if (SmallSystem.lineSegment3dClosestApproachUnbounded(pointA0, pointA1, pointB0, pointB1, uv) &&\n            this.acceptFraction(extendA0, uv.x, extendA1) && this.acceptFraction(extendB0, uv.y, extendB1)) {\n            this.recordPointWithLocalFractions(uv.x, cpA, fractionA0, fractionA1, uv.y, cpB, fractionB0, fractionB1, reversed);\n        }\n    }\n    // Caller accesses data from a line segment and passes to here.\n    // (The line segment in question might be (a) a full line segment or (b) a fragment within a linestring.  The fraction and extend parameters\n    // allow all combinations to be passed in)\n    // This method applies transform.\n    dispatchSegmentSegment(cpA, extendA0, pointA0, fractionA0, pointA1, fractionA1, extendA1, cpB, extendB0, pointB0, fractionB0, pointB1, fractionB1, extendB1, reversed) {\n        this.computeSegmentSegment3D(cpA, extendA0, pointA0, fractionA0, pointA1, fractionA1, extendA1, cpB, extendB0, pointB0, fractionB0, pointB1, fractionB1, extendB1, reversed);\n    }\n    /**\n     * Create a plane whose normal is the \"better\" cross product: `vectorA.crossProduct(vectorB)` or\n     * `vectorA.crossProduct(vectorC)`\n     * * The heuristic for \"better\" is:\n     *   * first choice is cross product with `vectorB`, if `vectorA` and `vectorB` are sufficiently far from parallel\n     * (or anti-parallel).\n     *   * otherwise use vectorC\n     * @param origin plane origin\n     * @param vectorA vector which must be in the plane.\n     * @param cosineValue largest cosine of the angle theta between vectorA and vectorB to prefer their cross product, e.g.\n     *  passing 0.94 ~ cos(20deg) will switch to using vectorC in the cross product if theta < ~20deg or theta > ~160deg.\n     * @param vectorB first candidate for additional in-plane vector\n     * @param vectorC second candidate for additional in-plane vector\n     */\n    createPlaneWithPreferredPerpendicular(origin, vectorA, cosineValue, vectorB, vectorC) {\n        cosineValue = Geometry.restrictToInterval(Math.abs(cosineValue), 0.0, 1.0 - Geometry.smallFraction);\n        const dotAA = vectorA.magnitudeSquared();\n        const dotBB = vectorB.magnitudeSquared();\n        const dotAB = Math.abs(vectorA.dotProduct(vectorB));\n        const cross = vectorA.unitCrossProduct(dotAB * dotAB <= cosineValue * cosineValue * dotAA * dotBB ? vectorB : vectorC);\n        if (cross)\n            return Plane3dByOriginAndUnitNormal.create(origin, cross);\n        return undefined;\n    }\n    // Caller accesses data from a linestring or segment and passes it here.\n    // (The line segment in question might be (a) a full line segment or (b) a fragment within a linestring.  The fraction and extend parameters\n    // allow all combinations to be passed in)\n    dispatchSegmentArc(cpA, extendA0, pointA0, fractionA0, pointA1, fractionA1, extendA1, arc, extendB0, extendB1, reversed) {\n        const lineVector = Vector3d.createStartEnd(pointA0, pointA1);\n        const plane = this.createPlaneWithPreferredPerpendicular(pointA0, lineVector, 0.94, arc.perpendicularVector, arc.vector0);\n        if (plane !== undefined) {\n            const candidates = [];\n            arc.appendPlaneIntersectionPoints(plane, candidates);\n            let lineFraction;\n            let linePoint;\n            for (const c of candidates) {\n                if (this.acceptFraction(extendB0, c.fraction, extendB1)) {\n                    lineFraction = SmallSystem.lineSegment3dClosestPointUnbounded(pointA0, pointA1, c.point);\n                    if (lineFraction !== undefined) {\n                        linePoint = pointA0.interpolate(lineFraction, pointA1, linePoint);\n                        if (linePoint.isAlmostEqualMetric(c.point)\n                            && this.acceptFraction(extendA0, lineFraction, extendA1)) {\n                            this.recordPointWithLocalFractions(lineFraction, cpA, fractionA0, fractionA1, c.fraction, arc, 0, 1, reversed);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    // Caller promises arcs are coplanar.\n    // Passes \"other\" as {center, vector0, vector90} in local xy space of cpA\n    // Solves the arc-arc equations for that local ellipse with unit circle.\n    // Solution fractions map directly to original arcs.\n    dispatchArcArcInPlane(cpA, extendA, cpB, extendB, reversed) {\n        const otherVectors = cpA.otherArcAsLocalVectors(cpB);\n        if (otherVectors !== undefined) {\n            const ellipseRadians = [];\n            const circleRadians = [];\n            TrigPolynomial.solveUnitCircleHomogeneousEllipseIntersection(otherVectors.center.x, otherVectors.center.y, 1.0, otherVectors.vector0.x, otherVectors.vector0.y, 0.0, otherVectors.vector90.x, otherVectors.vector90.y, 0.0, ellipseRadians, circleRadians);\n            for (let i = 0; i < ellipseRadians.length; i++) {\n                const fractionA = cpA.sweep.radiansToSignedPeriodicFraction(circleRadians[i]);\n                const fractionB = cpA.sweep.radiansToSignedPeriodicFraction(ellipseRadians[i]);\n                // hm .. do we really need to check the fractions?  We know they are internal to the beziers\n                if (this.acceptFraction(extendA, fractionA, extendA) && this.acceptFraction(extendB, fractionB, extendB)) {\n                    this.recordPointWithLocalFractions(fractionA, cpA, 0, 1, fractionB, cpB, 0, 1, reversed);\n                }\n            }\n        }\n    }\n    // Caller accesses data from two arcs.\n    // Selects the best conditioned arc (in xy parts) as \"circle after inversion\"\n    // Solves the arc-arc equations\n    dispatchArcArc(cpA, extendA, cpB, extendB, reversed) {\n        // If arcs are in different planes:\n        // 1) Intersect each plane with the other arc (quadratic)\n        // 2) accept points that appear in both intersection sets.\n        // If arcs are in parallel planes -- no intersections\n        // If arcs are in the same plane -- xy intersection in that plane.\n        const planeA = Plane3dByOriginAndUnitNormal.create(cpA.center, cpA.perpendicularVector);\n        const planeB = Plane3dByOriginAndUnitNormal.create(cpB.center, cpB.perpendicularVector);\n        if (planeA === undefined || planeB === undefined)\n            return;\n        if (planeA.getNormalRef().isParallelTo(planeB.getNormalRef())) {\n            if (planeA.isPointInPlane(planeB.getOriginRef()) && planeB.isPointInPlane(planeA.getOriginRef())) {\n                // coplanar !!!\n                this.dispatchArcArcInPlane(cpA, extendA, cpB, extendB, reversed);\n            }\n        }\n        else {\n            const arcBPoints = [];\n            cpB.appendPlaneIntersectionPoints(planeA, arcBPoints);\n            const arcAPoints = [];\n            cpA.appendPlaneIntersectionPoints(planeB, arcAPoints);\n            for (const detailB of arcBPoints) {\n                for (const detailA of arcAPoints) {\n                    if (detailA.point.isAlmostEqual(detailB.point)) {\n                        if (this.acceptFraction(extendA, detailA.fraction, extendA)\n                            && this.acceptFraction(extendB, detailB.fraction, extendB)) {\n                            this.recordPointWithLocalFractions(detailA.fraction, cpA, 0, 1, detailB.fraction, cpB, 0, 1, reversed);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    // Caller accesses data from two arcs.\n    // Selects the best conditioned arc (in xy parts) as \"circle after inversion\"\n    // Solves the arc-arc equations\n    dispatchArcBsplineCurve3d(_arc, _extendA, _cpB, _extendB, _reversed) {\n        /*\n        // Arc: X = C + cU + sV\n        // implicitize the arc as viewed.  This \"3d\" matrix is homogeneous \"XYW\" not \"xyz\"\n        let matrixA: Matrix3d;\n        if (this._worldToLocalPerspective) {\n          const dataA = cpA.toTransformedPoint4d(this._worldToLocalPerspective);\n          matrixA = Matrix3d.createColumnsXYW(dataA.vector0, dataA.vector0.w, dataA.vector90, dataA.vector90.w, dataA.center, dataA.center.w);\n        } else {\n          const dataA = cpA.toTransformedVectors(this._worldToLocalAffine);\n          matrixA = Matrix3d.createColumnsXYW(dataA.vector0, 0, dataA.vector90, 0, dataA.center, 1);\n        }\n        // The worldToLocal has moved the arc vectors into local space.\n        // matrixA captures the xyw parts (ignoring z)\n        // for any point in world space,\n        // THIS CODE ONLY WORKS FOR\n        const matrixAInverse = matrixA.inverse();\n        if (matrixAInverse) {\n          const orderF = cpB.order; // order of the beziers for simple coordinates\n          const orderG = 2 * orderF - 1;  // order of the (single) bezier for squared coordinates.\n          const coffF = new Float64Array(orderF);\n          const univariateBezierG = new UnivariateBezier(orderG);\n          const axx = matrixAInverse.at(0, 0); const axy = matrixAInverse.at(0, 1); const axz = 0.0; const axw = matrixAInverse.at(0, 2);\n          const ayx = matrixAInverse.at(1, 0); const ayy = matrixAInverse.at(1, 1); const ayz = 0.0; const ayw = matrixAInverse.at(1, 2);\n          const awx = matrixAInverse.at(2, 0); const awy = matrixAInverse.at(2, 1); const awz = 0.0; const aww = matrixAInverse.at(2, 2);\n    \n          if (matrixAInverse) {\n            let bezier: BezierCurve3dH | undefined;\n            for (let spanIndex = 0; ; spanIndex++) {\n              bezier = cpB.getSaturatedBezierSpan3dH(spanIndex, bezier);\n              if (!bezier) break;\n              if (this._worldToLocalPerspective)\n                bezier.tryMultiplyMatrix4dInPlace(this._worldToLocalPerspective);\n              else if (this._worldToLocalAffine)\n                bezier.tryTransformInPlace(this._worldToLocalAffine);\n              univariateBezierG.zero();\n              bezier.poleProductsXYZW(coffF, axx, axy, axz, axw);\n              univariateBezierG.addSquaredSquaredBezier(coffF, 1.0);\n              bezier.poleProductsXYZW(coffF, ayx, ayy, ayz, ayw);\n              univariateBezierG.addSquaredSquaredBezier(coffF, 1.0);\n              bezier.poleProductsXYZW(coffF, awx, awy, awz, aww);\n              univariateBezierG.addSquaredSquaredBezier(coffF, -1.0);\n              const roots = univariateBezierG.roots(0.0, true);\n              if (roots) {\n                for (const root of roots) {\n                  const fractionB = bezier.fractionToParentFraction(root);\n                  // The univariate bezier (which has been transformed by the view transform) evaluates into xyw space\n                  const bcurvePoint4d = bezier.fractionToPoint4d(root);\n                  const c = bcurvePoint4d.dotProductXYZW(axx, axy, axz, axw);\n                  const s = bcurvePoint4d.dotProductXYZW(ayx, ayy, ayz, ayw);\n                  const arcFraction = cpA.sweep.radiansToSignedPeriodicFraction(Math.atan2(s, c));\n                  if (this.acceptFraction(extendA, arcFraction, extendA) && this.acceptFraction(extendB, fractionB, extendB)) {\n                    this.recordPointWithLocalFractions(arcFraction, cpA, 0, 1,\n                      fractionB, cpB, 0, 1, reversed);\n                  }\n                }\n              }\n            }\n          }\n        }\n        */\n    }\n    /*\n    // apply the transformation to bezier curves. optionally construct ranges.\n    private transformBeziers(beziers: BezierCurve3dH[]) {\n      if (this._worldToLocalAffine) {\n        for (const bezier of beziers) bezier.tryTransformInPlace(this._worldToLocalAffine);\n      } else if (this._worldToLocalPerspective) {\n        for (const bezier of beziers) bezier.tryMultiplyMatrix4dInPlace(this._worldToLocalPerspective);\n      }\n    }\n    */\n    /*\n    private getRanges(beziers: BezierCurveBase[]): Range3d[] {\n      const ranges: Range3d[] = [];\n      ranges.length = 0;\n      for (const b of beziers) {\n        ranges.push(b.range());\n      }\n      return ranges;\n    }\n    private _xyzwA0?: Point4d;\n    private _xyzwA1?: Point4d;\n    private _xyzwPlane?: Point4d;\n    private _xyzwB?: Point4d;\n  \n    private dispatchBezierBezierStrokeFirst(\n      bezierA: BezierCurve3dH,\n      bcurveA: BSplineCurve3dBase,\n      strokeCountA: number,\n      bezierB: BezierCurve3dH,\n      bcurveB: BSplineCurve3dBase,\n      _strokeCountB: number,\n      univariateBezierB: UnivariateBezier,  // caller-allocated for univariate coefficients.\n      reversed: boolean) {\n      if (!this._xyzwA0) this._xyzwA0 = Point4d.create();\n      if (!this._xyzwA1) this._xyzwA1 = Point4d.create();\n      if (!this._xyzwPlane) this._xyzwPlane = Point4d.create();\n      if (!this._xyzwB) this._xyzwB = Point4d.create();\n      const roots = univariateBezierG.roots(0.0, true);\n      if (roots) {\n        for (const root of roots) {\n          const fractionB = bezier.fractionToParentFraction(root);\n          // The univariate bezier (which has been transformed by the view transform) evaluates into xyw space\n          const bcurvePoint4d = bezier.fractionToPoint4d(root);\n          const c = bcurvePoint4d.dotProductXYZW(axx, axy, axz, axw);\n          const s = bcurvePoint4d.dotProductXYZW(ayx, ayy, ayz, ayw);\n          const arcFraction = cpA.sweep.radiansToSignedPeriodicFraction(Math.atan2(s, c));\n          if (this.acceptFraction(extendA, arcFraction, extendA) && this.acceptFraction(extendB, fractionB, extendB)) {\n            this.recordPointWithLocalFractions(arcFraction, cpA, 0, 1,\n              fractionB, cpB, 0, 1, reversed);\n          }\n        }\n      bezierA.fractionToPoint4d(0.0, this._xyzwA0);\n      let f0 = 0.0;\n      let f1 = 1.0;\n      const intervalTolerance = 1.0e-5;\n      const df = 1.0 / strokeCountA;\n      for (let i = 1; i <= strokeCountA; i++ , f0 = f1, this._xyzwA0.setFrom(this._xyzwA1)) {\n        f1 = i * df;\n        bezierA.fractionToPoint4d(f1, this._xyzwA1);\n        Point4d.createPlanePointPointZ(this._xyzwA0, this._xyzwA1, this._xyzwPlane);\n        bezierB.poleProductsXYZW(univariateBezierB.coffs, this._xyzwPlane.x, this._xyzwPlane.y, this._xyzwPlane.z, this._xyzwPlane.w);\n        let errors = 0;\n        const roots = univariateBezierB.roots(0.0, true);\n        if (roots)\n          for (const r of roots) {\n            const bezierBFraction = r;\n            bezierB.fractionToPoint4d(bezierBFraction, this._xyzwB);\n            const segmentAFraction = SmallSystem.lineSegment3dHXYClosestPointUnbounded(this._xyzwA0, this._xyzwA1, this._xyzwB);\n            if (segmentAFraction && Geometry.isIn01WithTolerance(segmentAFraction, intervalTolerance)) {\n              const bezierAFraction = Geometry.interpolate(f0, segmentAFraction, f1);\n              /*- TODO implement newton search\n              const xyMatchingFunction = new BezierBezierIntersectionXYRRToRRD(bezierA, bezierB);\n              const newtonSearcher = new Newton2dUnboundedWithDerivative(xyMatchingFunction);\n              newtonSearcher.setUV(bezierAFraction, bezierBFraction);\n              if (newtonSearcher.runIterations()) {\n                bezierAFraction = newtonSearcher.getU();\n                bezierBFraction = newtonSearcher.getV();\n              }\n              // We have a near intersection at fractions on the two beziers !!!\n              // Iterate on the curves for a true intersection ....\n              // NEEDS WORK -- just accept . . .\n              const bcurveAFraction = bezierA.fractionToParentFraction(bezierAFraction);\n              const bcurveBFraction = bezierB.fractionToParentFraction(bezierBFraction);\n              const xyzA0 = bezierA.fractionToPoint(bezierAFraction);\n              const xyzA1 = bcurveA.fractionToPoint(bcurveAFraction);\n              const xyzB0 = bezierB.fractionToPoint(bezierBFraction);\n              const xyzB1 = bcurveB.fractionToPoint(bcurveBFraction);\n              if (!xyzA0.isAlmostEqualXY(xyzA1))\n                errors++;\n              if (!xyzB0.isAlmostEqualXY(xyzB1))\n                errors++;\n              if (errors > 0 && !xyzA0.isAlmostEqual(xyzB0))\n                errors++;\n              if (errors > 0 && !xyzA1.isAlmostEqual(xyzB1))\n                errors++;\n              if (this.acceptFraction(false, bcurveAFraction, false) && this.acceptFraction(false, bcurveBFraction, false)) {\n                this.recordPointWithLocalFractions(bcurveAFraction, bcurveA, 0, 1,\n                  bcurveBFraction, bcurveB, 0, 1, reversed);\n              }\n            }\n          }\n      }\n    }\n    */\n    // Caller accesses data from two arcs.\n    // Selects the best conditioned arc (in xy parts) as \"circle after inversion\"\n    // Solves the arc-arc equations\n    dispatchBSplineCurve3dBSplineCurve3d(_bcurveA, _bcurveB, _reversed) {\n        /*\n        const bezierSpanA = bcurveA.collectBezierSpans(true) as BezierCurve3dH[];\n        const bezierSpanB = bcurveB.collectBezierSpans(true) as BezierCurve3dH[];\n        const numA = bezierSpanA.length;\n        const numB = bezierSpanB.length;\n        this.transformBeziers(bezierSpanA);\n        this.transformBeziers(bezierSpanB);\n        const rangeA = this.getRanges(bezierSpanA);\n        const rangeB = this.getRanges(bezierSpanB);\n        const orderA = bcurveA.order;\n        const orderB = bcurveB.order;\n        const univariateCoffsA = new UnivariateBezier(orderA);\n        const univariateCoffsB = new UnivariateBezier(orderB);\n        for (let a = 0; a < numA; a++) {\n          for (let b = 0; b < numB; b++) {\n            if (rangeA[a].intersectsRangeXY(rangeB[b])) {\n              const strokeCountA = bezierSpanA[a].computeStrokeCountForOptions();\n              const strokeCountB = bezierSpanB[b].computeStrokeCountForOptions();\n              if (strokeCountA < strokeCountB)\n                this.dispatchBezierBezierStrokeFirst(bezierSpanA[a], bcurveA, strokeCountA, bezierSpanB[b], bcurveB, strokeCountB, univariateCoffsB, !_reversed);\n              else\n                this.dispatchBezierBezierStrokeFirst(bezierSpanB[b], bcurveB, strokeCountB, bezierSpanA[a], bcurveA, strokeCountA, univariateCoffsA, _reversed);\n            }\n          }\n        }\n        */\n    }\n    /*\n    /**\n     * Apply the projection transform (if any) to (xyz, w)\n     * @param xyz xyz parts of input point.\n     * @param w   weight to use for homogeneous effects\n     */\n    /*\n    private projectPoint(xyz: XYAndZ, w: number = 1.0): Point4d {\n      if (this._worldToLocalPerspective)\n        return this._worldToLocalPerspective.multiplyPoint3d(xyz, w);\n      if (this._worldToLocalAffine)\n        return this._worldToLocalAffine.multiplyXYZW(xyz.x, xyz.y, xyz.z, w);\n      return Point4d.createFromPointAndWeight(xyz, w);\n    }\n    private mapNPCPlaneToWorld(npcPlane: Point4d, worldPlane: Point4d) {\n      // for NPC pointY, Y^ * H = 0 is \"on\" plane H.  (Hat is transpose)\n      // NPC Y is A*X for our transform A and worldPointX.\n      // hence (A X)^ * H = 0\n      // hence X^ * A^ * H = 0\n      // hence K = A^ * H\n      if (this._worldToLocalAffine) {\n        this._worldToLocalAffine.multiplyTransposeXYZW(npcPlane.x, npcPlane.y, npcPlane.z, npcPlane.w, worldPlane);\n      } else if (this._worldToLocalPerspective) {\n        this._worldToLocalPerspective.multiplyTransposePoint4d(npcPlane, worldPlane);\n      } else {\n        npcPlane.clone(worldPlane);\n      }\n    }\n    */\n    // Caller accesses data from segment and bsplineCurve\n    // Selects the best conditioned arc (in xy parts) as \"circle after inversion\"\n    // Solves the arc-arc equations\n    dispatchSegmentBsplineCurve(_cpA, _extendA0, _pointA0, _fractionA0, _pointA1, _fractionA1, _extendA1, _bcurve, _extendB, _reversed) {\n        /*\n        const pointA0H = this.projectPoint(pointA0);\n        const pointA1H = this.projectPoint(pointA1);\n        const planeCoffs = Point4d.createPlanePointPointZ(pointA0H, pointA1H);\n        this.mapNPCPlaneToWorld(planeCoffs, planeCoffs);\n          // NOW .. we have a plane in world space.  Intersect it with the bspline:\n        const intersections: CurveLocationDetail[] = [];\n        bcurve.appendPlaneIntersectionPoints(planeCoffs, intersections);\n          // intersections has WORLD points with bspline fractions.   (The bspline fractions are all good 0..1 fractions within the spline.)\n          // accept those that are within the segment range.\n        for (const detail of intersections) {\n          const fractionB = detail.fraction;\n          const curvePoint = detail.point;\n          const curvePointH = this.projectPoint(curvePoint);\n          const lineFraction = SmallSystem.lineSegment3dHXYClosestPointUnbounded(pointA0H, pointA1H, curvePointH);\n          if (lineFraction !== undefined && this.acceptFraction(extendA0, lineFraction, extendA1) && this.acceptFraction(extendB, fractionB, extendB)) {\n            this.recordPointWithLocalFractions(lineFraction, cpA, fractionA0, fractionA1,\n              fractionB, bcurve, 0, 1, reversed);\n          }\n        }\n        */\n    }\n    /** Low level dispatch of linestring with (beziers of) a bspline curve */\n    dispatchLineStringBSplineCurve(_lsA, _extendA, _curveB, _extendB, _reversed) {\n        /*\n        const numA = lsA.numPoints();\n        if (numA > 1) {\n          const dfA = 1.0 / (numA - 1);\n          let fA0;\n          let fA1;\n          fA0 = 0.0;\n          const pointA0 = CurveCurveIntersectXYZ._workPointA0;\n          const pointA1 = CurveCurveIntersectXYZ._workPointA1;\n          lsA.pointAt(0, pointA0);\n          for (let iA = 1; iA < numA; iA++ , pointA0.setFrom(pointA1), fA0 = fA1) {\n            lsA.pointAt(iA, pointA1);\n            fA1 = iA * dfA;\n            this.dispatchSegmentBsplineCurve(\n              lsA, iA === 1 && extendA, pointA0, fA0, pointA1, fA1, (iA + 1) === numA && extendA,\n              curveB, extendB, reversed);\n          }\n        }\n        return undefined;\n        */\n    }\n    /** Detail computation for segment intersecting linestring. */\n    computeSegmentLineString(lsA, extendA, lsB, extendB, reversed) {\n        const pointA0 = lsA.point0Ref;\n        const pointA1 = lsA.point1Ref;\n        const pointB0 = CurveCurveIntersectXYZ._workPointBB0;\n        const pointB1 = CurveCurveIntersectXYZ._workPointBB1;\n        const numB = lsB.numPoints();\n        if (numB > 1) {\n            const dfB = 1.0 / (numB - 1);\n            let fB0;\n            let fB1;\n            fB0 = 0.0;\n            lsB.pointAt(0, pointB0);\n            for (let ib = 1; ib < numB; ib++, pointB0.setFrom(pointB1), fB0 = fB1) {\n                lsB.pointAt(ib, pointB1);\n                fB1 = ib * dfB;\n                this.dispatchSegmentSegment(lsA, extendA, pointA0, 0.0, pointA1, 1.0, extendA, lsB, ib === 1 && extendB, pointB0, fB0, pointB1, fB1, (ib + 1) === numB && extendB, reversed);\n            }\n        }\n        return undefined;\n    }\n    /** Detail computation for arc intersecting linestring. */\n    computeArcLineString(arcA, extendA, lsB, extendB, reversed) {\n        const pointB0 = CurveCurveIntersectXYZ._workPointBB0;\n        const pointB1 = CurveCurveIntersectXYZ._workPointBB1;\n        const numB = lsB.numPoints();\n        if (numB > 1) {\n            const dfB = 1.0 / (numB - 1);\n            let fB0;\n            let fB1;\n            fB0 = 0.0;\n            lsB.pointAt(0, pointB0);\n            for (let ib = 1; ib < numB; ib++, pointB0.setFrom(pointB1), fB0 = fB1) {\n                lsB.pointAt(ib, pointB1);\n                fB1 = ib * dfB;\n                this.dispatchSegmentArc(lsB, ib === 1 && extendB, pointB0, fB0, pointB1, fB1, (ib + 1) === numB && extendB, arcA, extendA, extendA, !reversed);\n            }\n        }\n        return undefined;\n    }\n    /** Double dispatch handler for strongly typed segment. */\n    handleLineSegment3d(segmentA) {\n        if (this._geometryB instanceof LineSegment3d) {\n            const segmentB = this._geometryB;\n            this.dispatchSegmentSegment(segmentA, this._extendA, segmentA.point0Ref, 0.0, segmentA.point1Ref, 1.0, this._extendA, segmentB, this._extendB, segmentB.point0Ref, 0.0, segmentB.point1Ref, 1.0, this._extendB, false);\n        }\n        else if (this._geometryB instanceof LineString3d) {\n            this.computeSegmentLineString(segmentA, this._extendA, this._geometryB, this._extendB, false);\n        }\n        else if (this._geometryB instanceof Arc3d) {\n            this.dispatchSegmentArc(segmentA, this._extendA, segmentA.point0Ref, 0.0, segmentA.point1Ref, 1.0, this._extendA, this._geometryB, this._extendB, this._extendB, false);\n        }\n        else if (this._geometryB instanceof BSplineCurve3d) {\n            this.dispatchSegmentBsplineCurve(segmentA, this._extendA, segmentA.point0Ref, 0.0, segmentA.point1Ref, 1.0, this._extendA, this._geometryB, this._extendB, false);\n        }\n    }\n    /** double dispatch handler for strongly typed linestring .. */\n    handleLineString3d(lsA) {\n        if (this._geometryB instanceof LineString3d) {\n            const lsB = this._geometryB;\n            const pointA0 = CurveCurveIntersectXYZ._workPointAA0;\n            const pointA1 = CurveCurveIntersectXYZ._workPointAA1;\n            const pointB0 = CurveCurveIntersectXYZ._workPointBB0;\n            const pointB1 = CurveCurveIntersectXYZ._workPointBB1;\n            const numA = lsA.numPoints();\n            const numB = lsB.numPoints();\n            if (numA > 1 && numB > 1) {\n                lsA.pointAt(0, pointA0);\n                const dfA = 1.0 / (numA - 1);\n                const dfB = 1.0 / (numB - 1);\n                let fA0 = 0.0;\n                let fA1, fB0, fB1;\n                const extendA = this._extendA;\n                const extendB = this._extendB;\n                lsA.pointAt(0, pointA0);\n                for (let ia = 1; ia < numA; ia++, pointA0.setFrom(pointA1), fA0 = fA1) {\n                    fA1 = ia * dfA;\n                    fB0 = 0.0;\n                    lsA.pointAt(ia, pointA1);\n                    lsB.pointAt(0, pointB0);\n                    for (let ib = 1; ib < numB; ib++, pointB0.setFrom(pointB1), fB0 = fB1) {\n                        lsB.pointAt(ib, pointB1);\n                        fB1 = ib * dfB;\n                        this.dispatchSegmentSegment(lsA, ia === 1 && extendA, pointA0, fA0, pointA1, fA1, (ia + 1) === numA && extendA, lsB, ib === 1 && extendB, pointB0, fB0, pointB1, fB1, (ib + 1) === numB && extendB, false);\n                    }\n                }\n            }\n        }\n        else if (this._geometryB instanceof LineSegment3d) {\n            this.computeSegmentLineString(this._geometryB, this._extendB, lsA, this._extendA, true);\n        }\n        else if (this._geometryB instanceof Arc3d) {\n            this.computeArcLineString(this._geometryB, this._extendB, lsA, this._extendA, true);\n        }\n        else if (this._geometryB instanceof BSplineCurve3d) {\n            this.dispatchLineStringBSplineCurve(lsA, this._extendA, this._geometryB, this._extendB, false);\n        }\n        return undefined;\n    }\n    /** Double dispatch handler for strongly typed arc. */\n    handleArc3d(arc0) {\n        if (this._geometryB instanceof LineSegment3d) {\n            this.dispatchSegmentArc(this._geometryB, this._extendB, this._geometryB.point0Ref, 0.0, this._geometryB.point1Ref, 1.0, this._extendB, arc0, this._extendA, this._extendA, true);\n        }\n        else if (this._geometryB instanceof LineString3d) {\n            this.computeArcLineString(arc0, this._extendA, this._geometryB, this._extendB, false);\n        }\n        else if (this._geometryB instanceof Arc3d) {\n            this.dispatchArcArc(arc0, this._extendA, this._geometryB, this._extendB, false);\n        }\n        else if (this._geometryB instanceof BSplineCurve3d) {\n            this.dispatchArcBsplineCurve3d(arc0, this._extendA, this._geometryB, this._extendB, false);\n        }\n        return undefined;\n    }\n    /** Double dispatch handler for strongly typed bspline curve.. */\n    handleBSplineCurve3d(curve) {\n        if (this._geometryB instanceof LineSegment3d) {\n            this.dispatchSegmentBsplineCurve(this._geometryB, this._extendB, this._geometryB.point0Ref, 0.0, this._geometryB.point1Ref, 1.0, this._extendB, curve, this._extendA, true);\n        }\n        else if (this._geometryB instanceof LineString3d) {\n            this.dispatchLineStringBSplineCurve(this._geometryB, this._extendB, curve, this._extendA, true);\n        }\n        else if (this._geometryB instanceof Arc3d) {\n            this.dispatchArcBsplineCurve3d(this._geometryB, this._extendB, curve, this._extendA, true);\n        }\n        else if (this._geometryB instanceof BSplineCurve3dBase) {\n            this.dispatchBSplineCurve3dBSplineCurve3d(curve, this._geometryB, false);\n        }\n        return undefined;\n    }\n    /** Double dispatch handler for strongly typed homogeneous bspline curve. */\n    handleBSplineCurve3dH(_curve) {\n        /*\n        // NEEDS WORK -- make \"dispatch\" methods tolerant of both 3d and 3dH\n        // \"easy\" if both present BezierCurve3dH span loaders\n        if (this._geometryB instanceof LineSegment3d) {\n          this.dispatchSegmentBsplineCurve(\n            this._geometryB, this._extendB, this._geometryB.point0Ref, 0.0, this._geometryB.point1Ref, 1.0, this._extendB,\n            curve, this._extendA, true);\n        } else if (this._geometryB instanceof LineString3d) {\n          this.dispatchLineStringBSplineCurve(this._geometryB, this._extendB, curve, this._extendA, true);\n        } else if (this._geometryB instanceof Arc3d) {\n          this.dispatchArcBsplineCurve3d(this._geometryB, this._extendB, curve, this._extendA, true);\n        }\n        */\n        return undefined;\n    }\n}\nCurveCurveIntersectXYZ._workVector2dA = Vector2d.create();\nCurveCurveIntersectXYZ._workPointAA0 = Point3d.create();\nCurveCurveIntersectXYZ._workPointAA1 = Point3d.create();\nCurveCurveIntersectXYZ._workPointBB0 = Point3d.create();\nCurveCurveIntersectXYZ._workPointBB1 = Point3d.create();\nexport { CurveCurveIntersectXYZ };\n//# sourceMappingURL=CurveCurveIntersectXYZ.js.map",
      "start": 1693508124139,
      "end": 1693508124250,
      "sourcemaps": null
    }
  ]
}
