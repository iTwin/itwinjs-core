{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/polyface/TaggedNumericData.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Polyface\n */\nimport { Geometry } from \"../Geometry\";\n/**\n * `TaggedNumericConstants` defines enums with constant values for use in tags of [[TaggedNumericData]]\n * @public\n */\nexport var TaggedNumericConstants;\n(function (TaggedNumericConstants) {\n    /**  Reserved values for the \"tagA\" member of [[TaggedNumericData]]\n    * @public\n     *\n    */\n    let TaggedNumericTagType;\n    (function (TaggedNumericTagType) {\n        /** `tagA` value identifying a subdivision surface*/\n        TaggedNumericTagType[TaggedNumericTagType[\"SubdivisionSurface\"] = -1000] = \"SubdivisionSurface\";\n    })(TaggedNumericTagType = TaggedNumericConstants.TaggedNumericTagType || (TaggedNumericConstants.TaggedNumericTagType = {}));\n    /**\n     * `tagB` values for supported types of subdivision surfaces\n     * @public\n     */\n    let SubdivisionMethod;\n    (function (SubdivisionMethod) {\n        SubdivisionMethod[SubdivisionMethod[\"ChooseBasedOnFacets\"] = 0] = \"ChooseBasedOnFacets\";\n        SubdivisionMethod[SubdivisionMethod[\"CatmullClark\"] = 1] = \"CatmullClark\";\n        SubdivisionMethod[SubdivisionMethod[\"Loop\"] = 2] = \"Loop\";\n        SubdivisionMethod[SubdivisionMethod[\"DooSabin\"] = 3] = \"DooSabin\";\n    })(SubdivisionMethod = TaggedNumericConstants.SubdivisionMethod || (TaggedNumericConstants.SubdivisionMethod = {}));\n    /**\n     * numeric values for subdivision control.  These are entered in the intData array as first of a pair.\n     * @public\n     */\n    let SubdivisionControlCode;\n    (function (SubdivisionControlCode) {\n        /** pair (FixedDepth, d) indicates subdivision to depth d */\n        SubdivisionControlCode[SubdivisionControlCode[\"FixedDepth\"] = -100] = \"FixedDepth\";\n        /** pair (FixedDepth, index) indicates absolute tolerance with value in doubleData[index] */\n        SubdivisionControlCode[SubdivisionControlCode[\"AbsoluteTolerance\"] = -101] = \"AbsoluteTolerance\";\n        /** pair (FixedDepth, index) indicates tolerance as a fraction of base mesh range is found in doubleData[index] */\n        SubdivisionControlCode[SubdivisionControlCode[\"FractionOfRangeBoxTolerance\"] = -102] = \"FractionOfRangeBoxTolerance\";\n    })(SubdivisionControlCode = TaggedNumericConstants.SubdivisionControlCode || (TaggedNumericConstants.SubdivisionControlCode = {}));\n})(TaggedNumericConstants || (TaggedNumericConstants = {}));\n/**\n * Structure with 2 integer tags and optional arrays of integers, doubles, points, vectors, and geometry.\n * * In typescript/javascript, all integer numbers that can be non-integer.  Please do not insert non-integers in the integer array.\n * @public\n */\nexport class TaggedNumericData {\n    constructor(tagA = 0, tagB = 0, intData, doubleData) {\n        this.tagA = tagA;\n        this.tagB = tagB;\n        if (intData)\n            this.intData = intData;\n        if (doubleData)\n            this.doubleData = doubleData;\n    }\n    /**\n       * push a pair of int values on the intData array.\n       * @param intA\n       * @param intB\n       */\n    pushIntPair(intA, intB) {\n        if (!this.intData)\n            this.intData = [];\n        this.intData.push(intA);\n        this.intData.push(intB);\n    }\n    /**\n     * push a pair of int values on the intData array.\n     * @param intA int to push on the intData array, followed by index of valueB in the doubleData array.\n     * @param valueB value to push on the doubleData array.\n     */\n    pushIndexedDouble(intA, valueB) {\n        if (!this.intData)\n            this.intData = [];\n        if (!this.doubleData)\n            this.doubleData = [];\n        this.intData.push(intA);\n        this.intData.push(this.doubleData.length);\n        this.doubleData.push(valueB);\n    }\n    /**\n     * Search pairs in the intData array for a pair (targetTag, value).  Return the value, possibly restricted to (minValue,maxValue)\n     * @param targetTag\n     * @param minValue\n     * @param maxValue\n     * @param defaultValue\n     */\n    tagToInt(targetTag, minValue, maxValue, defaultValue) {\n        if (this.intData) {\n            for (let i = 0; i + 1 < this.intData.length; i += 2) {\n                if (this.intData[i] === targetTag)\n                    return Math.min(Math.max(this.intData[i + 1], minValue), maxValue);\n            }\n        }\n        return defaultValue;\n    }\n    /**\n     * Search pairs in the intData array for a pair (targetTag, index).  Return getDoubleData[index] value, possibly restricted to (minValue,maxValue)\n     * @param targetTag\n     * @param minValue\n     * @param maxValue\n     * @param defaultValue\n     */\n    tagToIndexedDouble(targetTag, minValue, maxValue, defaultValue) {\n        if (this.intData) {\n            for (let i = 0; i + 1 < this.intData.length; i += 2) {\n                if (this.intData[i] === targetTag) {\n                    return Geometry.clamp(this.getDoubleData(this.intData[i + 1], defaultValue), minValue, maxValue);\n                }\n            }\n        }\n        return defaultValue;\n    }\n    /**\n     * get doubleData[index], or indicated default if the index is out of range\n     * @param index\n     * @param defaultValue\n     */\n    getDoubleData(index, defaultValue) {\n        if (this.doubleData && 0 <= index && index < this.doubleData.length)\n            return this.doubleData[index];\n        return defaultValue;\n    }\n    /** Apply isAlmostEqual to all members. */\n    isAlmostEqual(other) {\n        if (other === undefined)\n            return false;\n        if (this.tagA !== other.tagA)\n            return false;\n        if (this.tagB !== other.tagB)\n            return false;\n        return Geometry.exactEqualNumberArrays(this.intData, other.intData)\n            && Geometry.almostEqualArrays(this.doubleData, other.doubleData, (a, b) => Geometry.isAlmostEqualNumber(a, b));\n    }\n    static areAlmostEqual(dataA, dataB) {\n        if (dataA === undefined && dataB === undefined)\n            return true;\n        if (dataA !== undefined && dataB !== undefined)\n            return dataA.isAlmostEqual(dataB);\n        return false;\n    }\n    /** Return a deep clone.  */\n    clone(result) {\n        if (!result)\n            result = new TaggedNumericData(this.tagA, this.tagB);\n        if (this.intData)\n            result.intData = this.intData.slice();\n        if (this.doubleData)\n            result.doubleData = this.doubleData.slice();\n        return result;\n    }\n}\n//# sourceMappingURL=TaggedNumericData.js.map",
      "start": 1693508123118,
      "end": 1693508123328,
      "sourcemaps": null
    }
  ]
}
