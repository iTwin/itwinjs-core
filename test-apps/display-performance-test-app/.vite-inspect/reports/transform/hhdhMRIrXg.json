{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/orbitgt/lib/esm/pointcloud/format/opc/ContainerFile.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module OrbitGT\n */\nimport { LittleEndian } from \"../../../system/buffer/LittleEndian\";\nimport { AList } from \"../../../system/collection/AList\";\nimport { ABufferInStream } from \"../../../system/io/ABufferInStream\";\nimport { ALong } from \"../../../system/runtime/ALong\";\nimport { ASystem } from \"../../../system/runtime/ASystem\";\nimport { Message } from \"../../../system/runtime/Message\";\nimport { Strings } from \"../../../system/runtime/Strings\";\nimport { ContainerFilePart } from \"./ContainerFilePart\";\nimport { FileAccess } from \"./FileAccess\";\n/**\n * Class ContainerFile defines a single file that contains multiple internal parts.\n *\n * @version 1.0 January 2014\n */\n/** @internal */\nclass ContainerFile {\n    /**\n     * Create a new container file.\n     * @param fileName the name of the file.\n     * @param fileLength the length of the file.\n     * @param format the format.\n     * @param parts the parts in the file.\n     */\n    constructor(fileName, fileLength, format, parts) {\n        this._fileName = fileName;\n        this._fileLength = fileLength;\n        this._format = format;\n        this._parts = parts;\n    }\n    /**\n     * Close the container file.\n     * @param closeFileAccess close all file access?\n     */\n    close(closeFileAccess) {\n        if (closeFileAccess)\n            for (let i = 0; i < this._parts.size(); i++)\n                this._parts.get(i).getFileAccess().close();\n        this._parts.clear();\n    }\n    /**\n     * Get the name of the file.\n     * @return the name of the file.\n     */\n    getFileName() {\n        return this._fileName;\n    }\n    /**\n     * Get the length of the file.\n     * @return the length of the file.\n     */\n    getFileLength() {\n        return this._fileLength;\n    }\n    /**\n     * Get the format.\n     * @return the format.\n     */\n    getFormat() {\n        return this._format;\n    }\n    /**\n     * Get the number of parts.\n     * @return the number of parts.\n     */\n    getPartCount() {\n        return this._parts.size();\n    }\n    /**\n     * Get the list of parts.\n     * @return the list of parts.\n     */\n    getParts() {\n        return this._parts;\n    }\n    /**\n     * Get a part.\n     * @param name the name of the part.\n     * @return the part (null if not found).\n     */\n    getPart(name) {\n        /* Check all parts */\n        for (let i = 0; i < this._parts.size(); i++) {\n            /* Check the next part */\n            let part = this._parts.get(i);\n            if (Strings.equals(part.getName(), name))\n                return part;\n        }\n        /* Not found */\n        return null;\n    }\n    /**\n     * Check if the magic marker is found.\n     * @param input the input stream.\n     * @param format the 4-character identifier of the format.\n     * @return true if found, false if not.\n     */\n    static checkMarker(input, format) {\n        let m0 = LittleEndian.readStreamByte(input);\n        let m1 = LittleEndian.readStreamByte(input);\n        let m2 = LittleEndian.readStreamByte(input);\n        let m3 = LittleEndian.readStreamByte(input);\n        if (m0 != Strings.getCharAt(format, 0))\n            return false;\n        if (m1 != Strings.getCharAt(format, 1))\n            return false;\n        if (m2 != Strings.getCharAt(format, 2))\n            return false;\n        if (m3 != Strings.getCharAt(format, 3))\n            return false;\n        return true;\n    }\n    /**\n     * Read the parts of a container file.\n     * @param containerFileName the name of the container file.\n     * @param format the 4-character identifier of the format.\n     * @return the container file.\n     */\n    static async read(fileStorage, containerFileName, format) {\n        /* Existing file? */\n        Message.print(ContainerFile.MODULE, \"Reading container file '\" + containerFileName + \"'\");\n        let fileLength = await fileStorage.getFileLength(containerFileName);\n        if (fileLength.isNegative()) {\n            /* Abort */\n            Message.printWarning(ContainerFile.MODULE, \"File not found\");\n            return null;\n        }\n        /* Too short? */\n        if (fileLength.subInt(16).isNegative()) {\n            /* Fail */\n            ASystem.assert0(false, \"Invalid container file '\" + containerFileName + \"' (too short)\");\n        }\n        /* Read the file header */\n        let headerSize = 60 * 1024;\n        if (fileLength.subInt(headerSize).isNegative())\n            headerSize = fileLength.toInt();\n        let header = await fileStorage.readFilePart(containerFileName, ALong.ZERO, headerSize);\n        let headerInput = new ABufferInStream(header, 0, header.size());\n        /* Check the marker */\n        if (ContainerFile.checkMarker(headerInput, format) == false) {\n            /* Fail */\n            headerInput.close();\n            ASystem.assert0(false, \"Invalid container file '\" + containerFileName + \"' (header marker)\");\n        }\n        /* Check the version */\n        let version = LittleEndian.readStreamByte(headerInput);\n        if (version != 2) {\n            /* Fail */\n            headerInput.close();\n            ASystem.assert0(false, \"Invalid container file '\" + containerFileName + \"' (version \" + version + \")\");\n        }\n        /* Reserved */\n        let r1 = LittleEndian.readStreamByte(headerInput);\n        let r2 = LittleEndian.readStreamByte(headerInput);\n        let r3 = LittleEndian.readStreamByte(headerInput);\n        /* Get the file count */\n        let fileCount = LittleEndian.readStreamInt(headerInput);\n        if (fileCount < 0) {\n            /* Fail */\n            headerInput.close();\n            ASystem.assert0(false, ContainerFile.MODULE + \" : Invalid container file '\" + containerFileName + \"' (file count \" + fileCount + \")\");\n        }\n        /* Define the file access */\n        let fileAccess = new FileAccess(fileStorage, containerFileName, fileLength);\n        /* Read the parts */\n        let maxExtent = ALong.ZERO;\n        let parts = new AList();\n        for (let i = 0; i < fileCount; i++) {\n            /* Read the next file */\n            let partOffset = LittleEndian.readStreamLong(headerInput);\n            let partLength = LittleEndian.readStreamLong(headerInput);\n            let partName = LittleEndian.readStreamString(headerInput);\n            /* Add the part */\n            parts.add(new ContainerFilePart(partName, fileAccess, partOffset, partLength));\n            Message.print(ContainerFile.MODULE, \"Found part '\" + partName + \"' offset \" + partOffset.toDouble() + \" size \" + partLength.toDouble());\n            /* Update the maximum extent */\n            let partExtent = partOffset.add(partLength);\n            maxExtent = ALong.max(maxExtent, partExtent);\n        }\n        /* Done */\n        headerInput.close();\n        /* Return the container */\n        Message.print(ContainerFile.MODULE, \"Found \" + parts.size() + \" parts, header size \" + headerInput.getPosition());\n        Message.print(ContainerFile.MODULE, \"File size is \" + fileLength.toDouble() + \", max part extent is \" + maxExtent.toDouble());\n        return new ContainerFile(containerFileName, fileLength, format, parts);\n    }\n}\n/** The name of this module */\nContainerFile.MODULE = \"ContainerFile\";\nexport { ContainerFile };\n//# sourceMappingURL=ContainerFile.js.map",
      "start": 1693508125485,
      "end": 1693508125526,
      "sourcemaps": null
    }
  ]
}
