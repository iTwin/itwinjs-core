{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/Tiles.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module IModelConnection\n */\nimport { Dictionary, dispose, IModelStatus } from \"@itwin/core-bentley\";\nimport { IModelApp } from \"./IModelApp\";\nimport { TileTreeLoadStatus } from \"./tile/internal\";\nclass TreeOwner {\n    get tileTree() { return this._tileTree; }\n    get loadStatus() { return this._loadStatus; }\n    get iModel() { return this._iModel; }\n    constructor(id, supplier, iModel) {\n        this._loadStatus = TileTreeLoadStatus.NotLoaded;\n        this.id = id;\n        this._supplier = supplier;\n        this._iModel = iModel;\n    }\n    load() {\n        this._load(); // eslint-disable-line @typescript-eslint/no-floating-promises\n        return this.tileTree;\n    }\n    async loadTree() {\n        await this._load();\n        return this.tileTree;\n    }\n    dispose() {\n        this._tileTree = dispose(this._tileTree);\n        this._loadStatus = TileTreeLoadStatus.NotLoaded;\n    }\n    async _load() {\n        if (TileTreeLoadStatus.NotLoaded !== this.loadStatus)\n            return;\n        this._loadStatus = TileTreeLoadStatus.Loading;\n        let tree;\n        let newStatus;\n        try {\n            tree = await this._supplier.createTileTree(this.id, this._iModel);\n            newStatus = undefined !== tree && !tree.rootTile.contentRange.isNull ? TileTreeLoadStatus.Loaded : TileTreeLoadStatus.NotFound;\n        }\n        catch (err) {\n            newStatus = (err.errorNumber && err.errorNumber === IModelStatus.ServerTimeout) ? TileTreeLoadStatus.NotLoaded : TileTreeLoadStatus.NotFound;\n        }\n        if (TileTreeLoadStatus.Loading === this._loadStatus) {\n            this._tileTree = tree;\n            this._loadStatus = newStatus;\n            IModelApp.tileAdmin.onTileTreeLoad.raiseEvent(this);\n        }\n    }\n}\n/** Provides access to [[TileTree]]s associated with an [[IModelConnection]].\n * The tile trees are accessed indirectly via their corresponding [[TileTreeOwner]]s.\n * Loaded tile trees will be discarded after the iModel is closed, after a period of disuse, or when the contents of a [[GeometricModelState]] they represent\n * change.\n * @see [[IModelConnection.tiles]].\n * @public\n * @extensions\n */\nexport class Tiles {\n    /** @internal */\n    get isDisposed() { return this._disposed; }\n    /** @internal */\n    constructor(iModel) {\n        this._treesBySupplier = new Map();\n        this._disposed = false;\n        this._iModel = iModel;\n        iModel.onEcefLocationChanged.addListener(() => {\n            for (const supplier of this._treesBySupplier.keys()) {\n                if (supplier.isEcefDependent)\n                    this.dropSupplier(supplier);\n            }\n        });\n        // When project extents change, purge tile trees for spatial models.\n        iModel.onProjectExtentsChanged.addListener(async () => {\n            if (!iModel.isBriefcaseConnection() || !iModel.editingScope)\n                await this.purgeModelTrees(this.getSpatialModels());\n        });\n    }\n    /** @internal */\n    dispose() {\n        this.reset();\n        this._disposed = true;\n    }\n    /** Intended strictly for tests.\n     * @internal\n     */\n    reset() {\n        for (const supplier of this._treesBySupplier)\n            supplier[1].forEach((_key, value) => value.dispose());\n        this._treesBySupplier.clear();\n    }\n    /** @internal */\n    async purgeTileTrees(modelIds) {\n        return IModelApp.tileAdmin.purgeTileTrees(this._iModel, modelIds);\n    }\n    getModelsAnimatedByScheduleScript(scriptSourceElementId) {\n        const modelIds = new Set();\n        for (const supplier of this._treesBySupplier.keys())\n            if (supplier.addModelsAnimatedByScript)\n                supplier.addModelsAnimatedByScript(modelIds, scriptSourceElementId, this.getTreeOwnersForSupplier(supplier));\n        return modelIds;\n    }\n    /** Update the [[Tile]]s for any [[TileTree]]s that use the [RenderSchedule.Script]($common) hosted by the specified\n     * [RenderTimeline]($backend) or [DisplayStyle]($backend) element. This method should be invoked after\n     * the host element is updated in the database with a new script, so that any [[Viewport]]s displaying tiles produced\n     * based on the previous version of the script are updated to use the new version of the script.\n     * @param scriptSourceElementId The Id of the RenderTimeline or DisplayStyle element that hosts the script.\n     * @public\n     */\n    async updateForScheduleScript(scriptSourceElementId) {\n        return this.purgeModelTrees(this.getModelsAnimatedByScheduleScript(scriptSourceElementId));\n    }\n    async purgeModelTrees(modelIds) {\n        if (0 === modelIds.size)\n            return;\n        const ids = Array.from(modelIds);\n        await this.purgeTileTrees(ids);\n        IModelApp.viewManager.refreshForModifiedModels(ids);\n    }\n    getSpatialModels() {\n        const modelIds = new Set();\n        for (const supplier of this._treesBySupplier.keys())\n            if (supplier.addSpatialModels)\n                supplier.addSpatialModels(modelIds, this.getTreeOwnersForSupplier(supplier));\n        return modelIds;\n    }\n    /** Obtain the owner of a TileTree.\n     * The `id` is unique within all tile trees associated with `supplier`; its specific structure is an implementation detail known only to the supplier.\n     * A [[TileTreeReference]] uses this method to obtain the tile tree to which it refers.\n     */\n    getTileTreeOwner(id, supplier) {\n        let trees = this._treesBySupplier.get(supplier);\n        if (undefined === trees) {\n            trees = new Dictionary((lhs, rhs) => supplier.compareTileTreeIds(lhs, rhs));\n            this._treesBySupplier.set(supplier, trees);\n        }\n        let tree = trees.get(id);\n        if (undefined === tree) {\n            tree = new TreeOwner(id, supplier, this._iModel);\n            trees.set(id, tree);\n        }\n        return tree;\n    }\n    /** Remove tile tree matching the provided tile tree supplier/id\n     * @internal\n     */\n    resetTileTreeOwner(id, supplier) {\n        const trees = this._treesBySupplier.get(supplier);\n        const tree = trees?.get(id);\n        if (tree) {\n            tree.dispose();\n            trees?.delete(id);\n        }\n    }\n    /** Disposes of all [[TileTree]]s belonging to `supplier` and removes `supplier` from the set of known tile tree suppliers. */\n    dropSupplier(supplier) {\n        const trees = this._treesBySupplier.get(supplier);\n        if (undefined === trees)\n            return;\n        trees.forEach((_key, value) => value.dispose());\n        this._treesBySupplier.delete(supplier);\n    }\n    /** Invokes a function on each extant TileTreeOwner. */\n    forEachTreeOwner(func) {\n        for (const dict of this._treesBySupplier.values())\n            dict.forEach((_key, value) => func(value));\n    }\n    /** Iterate over all of the TileTreeOwners. */\n    *[Symbol.iterator]() {\n        for (const [supplier, dict] of this._treesBySupplier) {\n            for (const entry of dict)\n                yield { supplier, id: entry.key, owner: entry.value };\n        }\n    }\n    /** Obtain the TileTreeOwners supplied by the specified supplier. */\n    getTreeOwnersForSupplier(supplier) {\n        function* iterator(trees) {\n            if (trees)\n                for (const entry of trees)\n                    yield { id: entry.key, owner: entry.value };\n        }\n        return {\n            [Symbol.iterator]: () => iterator(this._treesBySupplier.get(supplier)),\n        };\n    }\n    /** Unload any tile trees which have not been drawn since at least the specified time, excluding any of the specified TileTrees.\n     * @internal\n     */\n    purge(olderThan, exclude) {\n        // NB: It would be nice to be able to detect completely useless leftover Owners or Suppliers, but we can't know if any TileTreeReferences exist pointing to a given Owner.\n        for (const entry of this._treesBySupplier) {\n            const dict = entry[1];\n            dict.forEach((_treeId, owner) => {\n                const tree = owner.tileTree;\n                if (undefined !== tree && tree.lastSelectedTime.milliseconds < olderThan.milliseconds)\n                    if (undefined === exclude || !exclude.has(tree))\n                        owner.dispose();\n            });\n        }\n    }\n}\n//# sourceMappingURL=Tiles.js.map",
      "start": 1693508119230,
      "end": 1693508119398,
      "sourcemaps": null
    }
  ]
}
