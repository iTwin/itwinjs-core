{
  "resolvedId": "D:/hub2023A/itwinjs-core/common/temp/node_modules/.pnpm/@loaders.gl+worker-utils@3.4.7/node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/create-worker.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import AsyncQueue from '../async-queue/async-queue';\nimport WorkerBody from '../worker-farm/worker-body';\nlet requestId = 0;\nlet inputBatches;\nlet options;\nexport function createWorker(process, processInBatches) {\n  if (!WorkerBody.inWorkerThread()) {\n    return;\n  }\n  const context = {\n    process: processOnMainThread\n  };\n  WorkerBody.onmessage = async (type, payload) => {\n    try {\n      switch (type) {\n        case 'process':\n          if (!process) {\n            throw new Error('Worker does not support atomic processing');\n          }\n          const result = await process(payload.input, payload.options || {}, context);\n          WorkerBody.postMessage('done', {\n            result\n          });\n          break;\n        case 'process-in-batches':\n          if (!processInBatches) {\n            throw new Error('Worker does not support batched processing');\n          }\n          inputBatches = new AsyncQueue();\n          options = payload.options || {};\n          const resultIterator = processInBatches(inputBatches, options, context);\n          for await (const batch of resultIterator) {\n            WorkerBody.postMessage('output-batch', {\n              result: batch\n            });\n          }\n          WorkerBody.postMessage('done', {});\n          break;\n        case 'input-batch':\n          inputBatches.push(payload.input);\n          break;\n        case 'input-done':\n          inputBatches.close();\n          break;\n        default:\n      }\n    } catch (error) {\n      const message = error instanceof Error ? error.message : '';\n      WorkerBody.postMessage('error', {\n        error: message\n      });\n    }\n  };\n}\nfunction processOnMainThread(arrayBuffer) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return new Promise((resolve, reject) => {\n    const id = requestId++;\n    const onMessage = (type, payload) => {\n      if (payload.id !== id) {\n        return;\n      }\n      switch (type) {\n        case 'done':\n          WorkerBody.removeEventListener(onMessage);\n          resolve(payload.result);\n          break;\n        case 'error':\n          WorkerBody.removeEventListener(onMessage);\n          reject(payload.error);\n          break;\n        default:\n      }\n    };\n    WorkerBody.addEventListener(onMessage);\n    const payload = {\n      id,\n      input: arrayBuffer,\n      options\n    };\n    WorkerBody.postMessage('process', payload);\n  });\n}\n//# sourceMappingURL=create-worker.js.map",
      "start": 1693508124468,
      "end": 1693508124592,
      "sourcemaps": null
    }
  ]
}
