{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/glsl/Composite.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { assert } from \"@itwin/core-bentley\";\nimport { TextureUnit } from \"../RenderFlags\";\nimport { Texture2DHandle } from \"../Texture\";\nimport { addWindowToTexCoords, assignFragColor } from \"./Fragment\";\nimport { createViewportQuadBuilder } from \"./ViewportQuad\";\nfunction addHiliteSettings(frag) {\n    frag.addUniform(\"u_hilite_settings\", 6 /* VariableType.Mat3 */, (prog) => {\n        prog.addProgramUniform(\"u_hilite_settings\", (uniform, params) => {\n            params.target.uniforms.hilite.bindCompositeSettings(uniform);\n        });\n    });\n    frag.addUniform(\"u_hilite_width\", 3 /* VariableType.Vec2 */, (prog) => {\n        prog.addProgramUniform(\"u_hilite_width\", (uniform, params) => {\n            params.target.uniforms.hilite.bindCompositeWidths(uniform);\n        });\n    });\n}\nconst readEdgePixel = `\r\nvec2 readEdgePixel(float xOffset, float yOffset) {\r\n  vec2 t = windowCoordsToTexCoords(gl_FragCoord.xy + vec2(xOffset, yOffset));\r\n  return TEXTURE(u_hilite, t).xy;\r\n}\r\n`;\nconst computeNearbyHilites = `\r\nvec2 computeNearbyHilites() {\r\n  float hiliteWidth = u_hilite_width.x;\r\n  float emphWidth = u_hilite_width.y;\r\n  float maxWidth = max(hiliteWidth, emphWidth);\r\n  if (0.0 == maxWidth)\r\n    return vec2(0.0);\r\n\r\n  vec2 nearest = vec2(0.0, 0.0);\r\n  for (int x = -1; x <= 1; x++)\r\n    for (int y = -1; y <= 1; y++)\r\n      if (0 != x || 0 != y)\r\n        nearest = nearest + readEdgePixel(float(x), float(y));\r\n\r\n  nearest = nearest * vec2(float(hiliteWidth > 0.0), float(emphWidth > 0.0));\r\n\r\n  if ((0.0 == nearest.x && hiliteWidth > 1.0) || (0.0 == nearest.y && emphWidth > 1.0)) {\r\n    vec2 farthest = vec2(0.0, 0.0);\r\n    for (int i = -2; i <= 2; i++) {\r\n      float f = float(i);\r\n      farthest = farthest + readEdgePixel(f, -2.0) + readEdgePixel(-2.0, f) + readEdgePixel(f, 2.0) + readEdgePixel(2.0, f);\r\n    }\r\n\r\n    farthest = farthest * vec2(float(hiliteWidth > 1.0), float(emphWidth > 1.0));\r\n    nearest = nearest + farthest;\r\n  }\r\n\r\n  return nearest;\r\n}\r\n`;\nconst computeOpaqueColor = `\r\nvec4 computeOpaqueColor() {\r\n  vec4 opaque = TEXTURE(u_opaque, v_texCoord);\r\n  opaque.rgb *= computeAmbientOcclusion();\r\n  return opaque;\r\n}\r\n`;\nconst computeDefaultAmbientOcclusion = `\\nfloat computeAmbientOcclusion() { return 1.0; }\\n`;\nconst computeAmbientOcclusion = `\\nfloat computeAmbientOcclusion() { return TEXTURE(u_occlusion, v_texCoord).r; }\\n`;\nconst computeHiliteColor = \"\\nvec4 computeColor() { return computeOpaqueColor(); }\\n\";\nconst computeHiliteBaseColor = `\r\n  vec4 baseColor = computeColor();\r\n  vec2 flags = TEXTURE(u_hilite, v_texCoord).rg;\r\n  vec2 outline = computeNearbyHilites();\r\n  if (u_hilite_width.y < u_hilite_width.x) { // check for emphasis outline first if it is thinner\r\n    if (outline.y > 0.0 && flags.y == 0.0)\r\n      return vec4(u_hilite_settings[1], 1.0);\r\n    if (outline.x > 0.0 && flags.x == 0.0)\r\n      return vec4(u_hilite_settings[0], 1.0);\r\n  } else {\r\n    if (outline.x > 0.0 && flags.x == 0.0)\r\n      return vec4(u_hilite_settings[0], 1.0);\r\n    if (outline.y > 0.0 && flags.y == 0.0)\r\n      return vec4(u_hilite_settings[1], 1.0);\r\n  }\r\n  float hiliteMix = flags.x * u_hilite_settings[2][0];\r\n  float emphasisMix = flags.y * u_hilite_settings[2][1];\r\n  baseColor.rgb *= (1.0 - (hiliteMix + emphasisMix));\r\n  baseColor.rgb += u_hilite_settings[0] * hiliteMix;\r\n  baseColor.rgb += u_hilite_settings[1] * emphasisMix;\r\n  return baseColor;\r\n`;\nconst computeTranslucentColor = `\r\nvec4 computeColor() {\r\n  vec4 opaque = computeOpaqueColor();\r\n  vec4 accum = TEXTURE(u_accumulation, v_texCoord);\r\n  float r = TEXTURE(u_revealage, v_texCoord).r;\r\n\r\n  vec4 transparent = vec4(accum.rgb / clamp(r, 1e-4, 5e4), accum.a);\r\n  vec4 col = (1.0 - transparent.a) * transparent + transparent.a * opaque;\r\n  return col;\r\n}\r\n`;\nconst computeTranslucentBaseColor = \"return computeColor();\";\nconst computeAmbientOcclusionBaseColor = \"return computeOpaqueColor();\";\n/** @internal */\nexport function createCompositeProgram(flags, context) {\n    assert(0 /* CompositeFlags.None */ !== flags);\n    const wantHilite = 0 /* CompositeFlags.None */ !== (flags & 2 /* CompositeFlags.Hilite */);\n    const wantTranslucent = 0 /* CompositeFlags.None */ !== (flags & 1 /* CompositeFlags.Translucent */);\n    const wantOcclusion = 0 /* CompositeFlags.None */ !== (flags & 4 /* CompositeFlags.AmbientOcclusion */);\n    const builder = createViewportQuadBuilder(true);\n    const frag = builder.frag;\n    frag.addFunction(wantOcclusion ? computeAmbientOcclusion : computeDefaultAmbientOcclusion);\n    frag.addFunction(computeOpaqueColor);\n    frag.set(16 /* FragmentShaderComponent.AssignFragData */, assignFragColor);\n    frag.addUniform(\"u_opaque\", 8 /* VariableType.Sampler2D */, (prog) => {\n        prog.addGraphicUniform(\"u_opaque\", (uniform, params) => {\n            Texture2DHandle.bindSampler(uniform, params.geometry.opaque, TextureUnit.Zero);\n        });\n    });\n    if (wantHilite) {\n        addHiliteSettings(frag);\n        addWindowToTexCoords(frag);\n        frag.addFunction(readEdgePixel);\n        frag.addFunction(computeNearbyHilites);\n        frag.addUniform(\"u_hilite\", 8 /* VariableType.Sampler2D */, (prog) => {\n            prog.addGraphicUniform(\"u_hilite\", (uniform, params) => {\n                Texture2DHandle.bindSampler(uniform, params.geometry.hilite, TextureUnit.Three);\n            });\n        });\n        frag.set(1 /* FragmentShaderComponent.ComputeBaseColor */, computeHiliteBaseColor);\n        if (!wantTranslucent) {\n            frag.addFunction(computeHiliteColor);\n        }\n    }\n    if (wantTranslucent) {\n        frag.addUniform(\"u_accumulation\", 8 /* VariableType.Sampler2D */, (prog) => {\n            prog.addGraphicUniform(\"u_accumulation\", (uniform, params) => {\n                Texture2DHandle.bindSampler(uniform, params.geometry.accum, TextureUnit.One);\n            });\n        });\n        frag.addUniform(\"u_revealage\", 8 /* VariableType.Sampler2D */, (prog) => {\n            prog.addGraphicUniform(\"u_revealage\", (uniform, params) => {\n                Texture2DHandle.bindSampler(uniform, params.geometry.reveal, TextureUnit.Two);\n            });\n        });\n        frag.addFunction(computeTranslucentColor);\n        if (!wantHilite) {\n            frag.set(1 /* FragmentShaderComponent.ComputeBaseColor */, computeTranslucentBaseColor);\n        }\n    }\n    if (wantOcclusion) {\n        frag.addUniform(\"u_occlusion\", 8 /* VariableType.Sampler2D */, (prog) => {\n            prog.addGraphicUniform(\"u_occlusion\", (uniform, params) => {\n                Texture2DHandle.bindSampler(uniform, params.geometry.occlusion, TextureUnit.Four);\n            });\n        });\n        if (!wantHilite && !wantTranslucent)\n            frag.set(1 /* FragmentShaderComponent.ComputeBaseColor */, computeAmbientOcclusionBaseColor);\n    }\n    const flagString = (wantHilite ? \"-Hilite\" : \"\") + (wantTranslucent ? \"-Translucent\" : \"\") + (wantOcclusion ? \"-Occlusion\" : \"\");\n    builder.vert.headerComment = `//!V! CombineTextures${flagString}`;\n    builder.frag.headerComment = `//!F! CombineTextures${flagString}`;\n    return builder.buildProgram(context);\n}\n//# sourceMappingURL=Composite.js.map",
      "start": 1693508124633,
      "end": 1693508124731,
      "sourcemaps": null
    }
  ]
}
