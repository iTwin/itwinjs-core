{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/common/lib/esm/geometry/AreaPattern.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Symbology\n */\nimport { Id64 } from \"@itwin/core-bentley\";\nimport { Angle, Geometry, Matrix3d, Point2d, Point3d, YawPitchRollAngles, } from \"@itwin/core-geometry\";\nimport { ColorDef } from \"../ColorDef\";\n/** @public */\nexport var AreaPattern;\n(function (AreaPattern) {\n    class HatchDefLine {\n        constructor(json) {\n            this.angle = json.angle ? Angle.fromJSON(json.angle) : undefined;\n            this.through = json.through ? Point2d.fromJSON(json.through) : undefined;\n            this.offset = json.offset ? Point2d.fromJSON(json.offset) : undefined;\n            if (json.dashes) {\n                const dashes = [];\n                json.dashes.forEach((dash) => dashes.push(dash));\n                this.dashes = dashes;\n            }\n        }\n    }\n    AreaPattern.HatchDefLine = HatchDefLine;\n    /** Defines a hatch, cross hatch, or area pattern. */\n    class Params {\n        /** create an AreaPattern.Params from a json object. */\n        static fromJSON(json) {\n            const result = new Params();\n            if (!json)\n                return result;\n            result.origin = json.origin ? Point3d.fromJSON(json.origin) : undefined;\n            result.rotation = json.rotation ? YawPitchRollAngles.fromJSON(json.rotation) : undefined;\n            result.space1 = json.space1;\n            result.space2 = json.space2;\n            result.angle1 = json.angle1 ? Angle.fromJSON(json.angle1) : undefined;\n            result.angle2 = json.angle2 ? Angle.fromJSON(json.angle2) : undefined;\n            result.scale = json.scale;\n            result.color = json.color ? ColorDef.fromJSON(json.color) : undefined;\n            result.weight = json.weight;\n            result.invisibleBoundary = json.invisibleBoundary;\n            result.snappable = json.snappable;\n            result.symbolId = json.symbolId ? Id64.fromJSON(json.symbolId) : undefined;\n            if (!json.defLines)\n                return result;\n            const defLines = [];\n            json.defLines.forEach((defLine) => defLines.push(new HatchDefLine(defLine)));\n            result.defLines = defLines;\n            return result;\n        }\n        toJSON() {\n            return {\n                ...this,\n                color: this.color?.toJSON(),\n            };\n        }\n        clone() {\n            return Params.fromJSON(this.toJSON());\n        }\n        equals(other) {\n            if (this === other)\n                return true; // Same pointer\n            if (this.scale !== other.scale ||\n                this.space1 !== other.space1 ||\n                this.space2 !== other.space2 ||\n                this.weight !== other.weight ||\n                this.invisibleBoundary !== other.invisibleBoundary ||\n                this.snappable !== other.snappable)\n                return false;\n            if ((this.color === undefined) !== (other.color === undefined))\n                return false;\n            if (this.color && !this.color.equals(other.color))\n                return false;\n            if ((this.angle1 === undefined) !== (other.angle1 === undefined))\n                return false;\n            if (this.angle1 && !this.angle1.isAlmostEqualNoPeriodShift(other.angle1))\n                return false;\n            if ((this.angle2 === undefined) !== (other.angle2 === undefined))\n                return false;\n            if (this.angle2 && !this.angle2.isAlmostEqualNoPeriodShift(other.angle2))\n                return false;\n            if ((this.origin === undefined) !== (other.origin === undefined))\n                return false;\n            if (this.origin && !this.origin.isAlmostEqual(other.origin))\n                return false;\n            if ((this.rotation === undefined) !== (other.rotation === undefined))\n                return false;\n            if (this.rotation && !this.rotation.isAlmostEqual(other.rotation))\n                return false;\n            if ((this.symbolId === undefined) !== (other.symbolId === undefined))\n                return false;\n            if (this.symbolId && !(this.symbolId === other.symbolId))\n                return false;\n            if ((this.defLines === undefined) !== (other.defLines === undefined))\n                return false;\n            if (this.defLines) {\n                if (this.defLines.length !== other.defLines.length)\n                    return false;\n                for (let i = 0; i < this.defLines.length; ++i) {\n                    const otherLine = other.defLines[i];\n                    const thisLine = this.defLines[i];\n                    if ((thisLine.angle === undefined) !== (otherLine.angle === undefined))\n                        return false;\n                    if (thisLine.angle && !thisLine.angle.isAlmostEqualNoPeriodShift(otherLine.angle))\n                        return false;\n                    if ((thisLine.through === undefined) !== (otherLine.through === undefined))\n                        return false;\n                    if (thisLine.through && !thisLine.through.isAlmostEqual(otherLine.through))\n                        return false;\n                    if ((thisLine.offset === undefined) !== (otherLine.offset === undefined))\n                        return false;\n                    if (thisLine.offset && !thisLine.offset.isAlmostEqual(otherLine.offset))\n                        return false;\n                    if ((thisLine.dashes === undefined) !== (otherLine.dashes === undefined))\n                        return false;\n                    if (thisLine.dashes && thisLine.dashes.length !== otherLine.dashes.length)\n                        return false;\n                    if (thisLine.dashes) {\n                        for (let dash = 0; dash < thisLine.dashes.length; ++dash) {\n                            if (!Geometry.isSameCoordinate(thisLine.dashes[dash], otherLine.dashes[dash]))\n                                return false;\n                        }\n                    }\n                }\n            }\n            return true;\n        }\n        static transformPatternSpace(transform, oldSpace, patRot, angle) {\n            let tmpRot;\n            if (angle && !angle.isAlmostZero) {\n                const yprTriple = new YawPitchRollAngles(angle);\n                const angRot = yprTriple.toMatrix3d();\n                tmpRot = patRot.multiplyMatrixMatrix(angRot);\n            }\n            else {\n                tmpRot = patRot;\n            }\n            const yDir = tmpRot.getColumn(1);\n            yDir.scale(oldSpace, yDir);\n            transform.multiplyVector(yDir, yDir);\n            return yDir.magnitude();\n        }\n        static getTransformPatternScale(transform) {\n            const xDir = transform.matrix.getColumn(0);\n            const mag = xDir.magnitude();\n            return (mag > 1.0e-10) ? mag : 1.0;\n        }\n        applyTransform(transform) {\n            if (transform.isIdentity)\n                return true;\n            let origin = this.origin ? this.origin : Point3d.createZero();\n            const rMatrix = this.rotation ? this.rotation.toMatrix3d() : Matrix3d.createIdentity();\n            if (this.symbolId !== undefined) {\n                this.space1 = Params.transformPatternSpace(transform, this.space1 ? this.space1 : 0.0, rMatrix, this.angle1);\n                this.space2 = Params.transformPatternSpace(transform, this.space2 ? this.space2 : 0.0, rMatrix, this.angle2);\n                const scale = Params.getTransformPatternScale(transform);\n                this.scale = this.scale ? this.scale * scale : scale;\n            }\n            else if (this.defLines) {\n                const scale = Params.getTransformPatternScale(transform);\n                if (!Geometry.isSameCoordinate(scale, 1.0)) {\n                    this.scale = this.scale ? this.scale * scale : scale;\n                    for (const line of this.defLines) {\n                        if (line.through) {\n                            line.through.x *= scale;\n                            line.through.y *= scale;\n                        }\n                        if (line.offset) {\n                            line.offset.x *= scale;\n                            line.offset.y *= scale;\n                        }\n                        if (line.dashes) {\n                            for (let iDash = 0; iDash < line.dashes.length; iDash++)\n                                line.dashes[iDash] *= scale;\n                        }\n                    }\n                }\n            }\n            else {\n                this.space1 = Params.transformPatternSpace(transform, this.space1 ? this.space1 : 0.0, rMatrix, this.angle1);\n                if (this.space2 && 0 !== this.space2)\n                    this.space2 = Params.transformPatternSpace(transform, this.space2, rMatrix, this.angle2);\n            }\n            origin = transform.multiplyPoint3d(origin);\n            rMatrix.multiplyMatrixMatrix(transform.matrix, rMatrix);\n            const normalized = Matrix3d.createRigidFromMatrix3d(rMatrix);\n            if (!normalized)\n                return false;\n            const newRotation = YawPitchRollAngles.createFromMatrix3d(normalized);\n            if (undefined === newRotation)\n                return false;\n            this.origin = origin;\n            this.rotation = newRotation;\n            return true;\n        }\n    }\n    AreaPattern.Params = Params;\n})(AreaPattern || (AreaPattern = {}));\n//# sourceMappingURL=AreaPattern.js.map",
      "start": 1693508120540,
      "end": 1693508120614,
      "sourcemaps": null
    }
  ]
}
