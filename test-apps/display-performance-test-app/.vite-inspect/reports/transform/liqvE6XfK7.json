{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/common/lib/esm/GeometryParams.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Symbology\n */\nimport { Id64 } from \"@itwin/core-bentley\";\nimport { IModel } from \"./IModel\";\n/** Whether a closed region should be drawn for wireframe display with its internal area filled or not.\n * @public\n * @extensions\n */\nexport var FillDisplay;\n(function (FillDisplay) {\n    /** don't fill, even if fill attribute is on for the viewport */\n    FillDisplay[FillDisplay[\"Never\"] = 0] = \"Never\";\n    /** fill if the fill attribute is on for the viewport */\n    FillDisplay[FillDisplay[\"ByView\"] = 1] = \"ByView\";\n    /** always fill, even if the fill attribute is off for the viewport */\n    FillDisplay[FillDisplay[\"Always\"] = 2] = \"Always\";\n    /** always fill, fill will always be behind other geometry */\n    FillDisplay[FillDisplay[\"Blanking\"] = 3] = \"Blanking\";\n})(FillDisplay || (FillDisplay = {}));\n/** Describes how a view's background color affects the interior area of a closed region.\n * @public\n * @extensions\n */\nexport var BackgroundFill;\n(function (BackgroundFill) {\n    /** single color fill uses the fill color and line color to draw either a solid or outline fill */\n    BackgroundFill[BackgroundFill[\"None\"] = 0] = \"None\";\n    /** single color fill uses the view's background color to draw a solid fill */\n    BackgroundFill[BackgroundFill[\"Solid\"] = 1] = \"Solid\";\n    /** single color fill uses the view's background color and line color to draw an outline fill */\n    BackgroundFill[BackgroundFill[\"Outline\"] = 2] = \"Outline\";\n})(BackgroundFill || (BackgroundFill = {}));\n/** Categorizes a piece of geometry within a GeometryStream. Visibility of classes of geometry can be toggled\n * within a view using [[ViewFlags]].\n * @see [[GeometryStreamProps]].\n * @see [[Feature]].\n * @public\n * @extensions\n */\nexport var GeometryClass;\n(function (GeometryClass) {\n    /** Used to classify the \"real\" geometry within a model. Most geometry falls within this class. */\n    GeometryClass[GeometryClass[\"Primary\"] = 0] = \"Primary\";\n    /** Used to classify geometry used as a drawing aid in constructing the Primary geometry. For example, grid lines. */\n    GeometryClass[GeometryClass[\"Construction\"] = 1] = \"Construction\";\n    /** Used to classify annotations which dimension (measure) the Primary geometry. */\n    GeometryClass[GeometryClass[\"Dimension\"] = 2] = \"Dimension\";\n    /** Used to classify geometry used to fill planar regions with a 2d pattern (e.g., hatch lines). */\n    GeometryClass[GeometryClass[\"Pattern\"] = 3] = \"Pattern\";\n})(GeometryClass || (GeometryClass = {}));\n/** Describes the display properties of graphics in a persistent element's GeometryStream that aren't inherited from [[SubCategoryAppearance]].\n * @see [[GeometryStreamProps]].\n * @public\n */\nexport class GeometryParams {\n    /** Create a GeometryParams given a [[Category]] Id for a [[GeometricElement]] and optional [[SubCategory]] Id. The [[SubCategory.appearance]] establishes the non-overriden display properties of\n     * graphics in a GeometricElement's [[GeometryStreamProps]]. A GeometricElement refers to a single Category through [[GeometricElement.category]], while it's graphics can appear on multiple SubCategories\n     * by adding a [[GeometryAppearanceProps]] with a SubCategory change to the GeometryStream.\n     * @note If a valid SubCategory Id is not supplied, the default SubCategory for the parent Category is used. To be considered valid, [[SubCategory.getCategoryId]] must refer to the specified Category Id.\n     */\n    constructor(categoryId, subCategoryId = Id64.invalid) {\n        this.categoryId = categoryId;\n        this.subCategoryId = subCategoryId;\n        if (!Id64.isValid(subCategoryId))\n            this.subCategoryId = IModel.getDefaultSubCategoryId(categoryId);\n    }\n    clone() {\n        const retVal = new GeometryParams(this.categoryId, this.subCategoryId);\n        retVal.materialId = this.materialId;\n        retVal.elmPriority = this.elmPriority;\n        retVal.weight = this.weight;\n        retVal.lineColor = this.lineColor;\n        retVal.fillColor = this.fillColor;\n        retVal.backgroundFill = this.backgroundFill;\n        retVal.fillDisplay = this.fillDisplay;\n        retVal.elmTransparency = this.elmTransparency;\n        retVal.fillTransparency = this.fillTransparency;\n        retVal.geometryClass = this.geometryClass;\n        retVal.styleInfo = this.styleInfo ? this.styleInfo.clone() : undefined;\n        retVal.gradient = this.gradient ? this.gradient.clone() : undefined;\n        retVal.pattern = this.pattern ? this.pattern.clone() : undefined;\n        return retVal;\n    }\n    /** Clears [[SubCategoryAppearance]] overrides while preserving [[categoryId]] and [[subCategoryId]]. */\n    resetAppearance() {\n        this.materialId = undefined;\n        this.elmPriority = undefined;\n        this.weight = undefined;\n        this.lineColor = undefined;\n        this.fillColor = undefined;\n        this.backgroundFill = undefined;\n        this.fillDisplay = undefined;\n        this.elmTransparency = undefined;\n        this.fillTransparency = undefined;\n        this.geometryClass = undefined;\n        this.styleInfo = undefined;\n        this.gradient = undefined;\n        this.pattern = undefined;\n    }\n    /** Compare two [[GeometryParams]] for equivalence, i.e. both values are undefined and inherited from [[SubCategoryAppearance]] or have the same override. */\n    isEquivalent(other) {\n        if (this === other)\n            return true; // Same pointer\n        if (this.categoryId !== other.categoryId)\n            return false;\n        if (this.subCategoryId !== other.subCategoryId)\n            return false;\n        if (this.geometryClass !== other.geometryClass)\n            return false;\n        if (this.elmPriority !== other.elmPriority)\n            return false;\n        if (this.elmTransparency !== other.elmTransparency)\n            return false;\n        if (this.fillTransparency !== other.fillTransparency)\n            return false;\n        if ((this.lineColor === undefined) !== (other.lineColor === undefined))\n            return false;\n        if (this.lineColor && !this.lineColor.equals(other.lineColor))\n            return false;\n        if (this.weight !== other.weight)\n            return false;\n        if ((this.materialId === undefined) !== (other.materialId === undefined))\n            return false;\n        if (this.materialId && this.materialId !== other.materialId)\n            return false;\n        if ((this.styleInfo === undefined) !== (other.styleInfo === undefined))\n            return false;\n        if (this.styleInfo && !this.styleInfo.equals(other.styleInfo))\n            return false;\n        if (this.fillDisplay !== other.fillDisplay)\n            return false;\n        if (this.fillDisplay !== undefined && this.fillDisplay !== FillDisplay.Never) {\n            if ((this.gradient === undefined) !== (other.gradient === undefined))\n                return false;\n            if (this.gradient && !this.gradient.equals(other.gradient))\n                return false;\n            if (this.backgroundFill !== other.backgroundFill)\n                return false;\n            if (this.backgroundFill === undefined || this.backgroundFill === BackgroundFill.None) {\n                if ((this.fillColor === undefined) !== (other.fillColor === undefined))\n                    return false;\n                if (this.fillColor && !this.fillColor.equals(other.fillColor))\n                    return false;\n            }\n        }\n        if ((this.pattern === undefined) !== (other.pattern === undefined))\n            return false;\n        if (this.pattern && !this.pattern.equals(other.pattern))\n            return false;\n        return true;\n    }\n    /** Change [[categoryId]] to the supplied id, [[subCategoryId]] to the supplied category's the default subCategory, and optionally clear any [[SubCategoryAppearance]] overrides. */\n    setCategoryId(categoryId, clearAppearanceOverrides = true) {\n        this.categoryId = categoryId;\n        this.subCategoryId = IModel.getDefaultSubCategoryId(categoryId);\n        if (clearAppearanceOverrides)\n            this.resetAppearance();\n    }\n    /** Change [[subCategoryId]] to the supplied id and optionally clear any [[SubCategoryAppearance]] overrides. */\n    setSubCategoryId(subCategoryId, clearAppearanceOverrides = true) {\n        this.subCategoryId = subCategoryId;\n        if (clearAppearanceOverrides)\n            this.resetAppearance();\n    }\n}\n//# sourceMappingURL=GeometryParams.js.map",
      "start": 1693508120599,
      "end": 1693508120695,
      "sourcemaps": null
    }
  ]
}
