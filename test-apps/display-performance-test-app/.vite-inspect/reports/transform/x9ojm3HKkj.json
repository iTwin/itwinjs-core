{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/polyface/PolyfaceData.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Polyface\n */\nimport { Geometry } from \"../Geometry\";\nimport { GrowableXYArray } from \"../geometry3d/GrowableXYArray\";\nimport { GrowableXYZArray } from \"../geometry3d/GrowableXYZArray\";\nimport { Point2d } from \"../geometry3d/Point2dVector2d\";\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\nimport { NumberArray } from \"../geometry3d/PointHelpers\";\nimport { Range3d } from \"../geometry3d/Range\";\nimport { ClusterableArray } from \"../numerics/ClusterableArray\";\nimport { PolyfaceAuxData } from \"./AuxData\";\nimport { TaggedNumericData } from \"./TaggedNumericData\";\n/**\n * PolyfaceData carries data arrays for point, normal, param, color and their indices.\n *\n * * IndexedPolyface carries a PolyfaceData as a member. (NOT as a base class -- it already has GeometryQuery as base)\n * * IndexedPolyfaceVisitor uses PolyfaceData as a base class.  In this use there is only a single facet in the polyfaceData.\n * * PolyfaceData does not know (!!!) what indices range constitute a facet.  That is managed by derived class or carrier class.\n * @public\n */\nclass PolyfaceData {\n    /** boolean tag indicating if the facets are viewable from the back */\n    get twoSided() { return this._twoSided; }\n    set twoSided(value) { this._twoSided = value; }\n    /** set the `taggedNumericData` member */\n    setTaggedNumericData(data) {\n        this.taggedNumericData = data;\n    }\n    /** boolean tag indicating if the facets are viewable from the back */\n    get expectedClosure() { return this._expectedClosure; }\n    set expectedClosure(value) { this._expectedClosure = value; }\n    /** Constructor for facets.\n     *   * The various params control whether respective arrays are to be allocated.\n     *   * If arrayData is provided, all other params are IGNORED.\n     *   *\n     */\n    constructor(needNormals = false, needParams = false, needColors = false, twoSided = false) {\n        this.face = [];\n        this.point = new GrowableXYZArray();\n        this.pointIndex = [];\n        this.edgeVisible = [];\n        if (needNormals) {\n            this.normal = new GrowableXYZArray();\n            this.normalIndex = [];\n        }\n        if (needParams) {\n            this.param = new GrowableXYArray();\n            this.paramIndex = [];\n        }\n        if (needColors) {\n            this.color = [];\n            this.colorIndex = [];\n        }\n        this._twoSided = twoSided;\n        this._expectedClosure = 0;\n    }\n    /** Return a depp clone. */\n    clone() {\n        const result = new PolyfaceData();\n        result.point = this.point.clone();\n        result.pointIndex = this.pointIndex.slice();\n        result.edgeVisible = this.edgeVisible.slice();\n        result.face = this.face.slice();\n        result.twoSided = this.twoSided;\n        result.expectedClosure = this.expectedClosure;\n        if (this.normal)\n            result.normal = this.normal.clone();\n        if (this.param)\n            result.param = this.param.clone();\n        if (this.color)\n            result.color = this.color.slice();\n        if (this.normalIndex)\n            result.normalIndex = this.normalIndex.slice();\n        if (this.paramIndex)\n            result.paramIndex = this.paramIndex.slice();\n        if (this.colorIndex)\n            result.colorIndex = this.colorIndex.slice();\n        if (this.auxData)\n            result.auxData = this.auxData.clone();\n        if (this.taggedNumericData) {\n            result.taggedNumericData = this.taggedNumericData.clone();\n        }\n        return result;\n    }\n    /** Test for equal indices and nearly equal coordinates */\n    isAlmostEqual(other) {\n        if (!GrowableXYZArray.isAlmostEqual(this.point, other.point))\n            return false;\n        if (!NumberArray.isExactEqual(this.pointIndex, other.pointIndex))\n            return false;\n        if (!GrowableXYZArray.isAlmostEqual(this.normal, other.normal))\n            return false;\n        if (!NumberArray.isExactEqual(this.normalIndex, other.normalIndex))\n            return false;\n        if (!GrowableXYArray.isAlmostEqual(this.param, other.param))\n            return false;\n        if (!NumberArray.isExactEqual(this.paramIndex, other.paramIndex))\n            return false;\n        if (!NumberArray.isExactEqual(this.color, other.color))\n            return false;\n        if (!NumberArray.isExactEqual(this.colorIndex, other.colorIndex))\n            return false;\n        if (!NumberArray.isExactEqual(this.edgeVisible, other.edgeVisible))\n            return false;\n        if (!PolyfaceAuxData.isAlmostEqual(this.auxData, other.auxData))\n            return false;\n        if (this.twoSided !== other.twoSided)\n            return false;\n        if (this.expectedClosure !== other.expectedClosure)\n            return false;\n        if (!TaggedNumericData.areAlmostEqual(this.taggedNumericData, other.taggedNumericData))\n            return false;\n        return true;\n    }\n    /** Ask if normals are required in this mesh. */\n    get requireNormals() { return undefined !== this.normal; }\n    /** Get the point count */\n    get pointCount() { return this.point.length; }\n    /** Get the normal count */\n    get normalCount() { return this.normal ? this.normal.length : 0; }\n    /** Get the param count */\n    get paramCount() { return this.param ? this.param.length : 0; }\n    /** Get the color count */\n    get colorCount() { return this.color ? this.color.length : 0; }\n    /** Get the index count.  Note that there is one count, and all index arrays (point, normal, param, color) must match */\n    get indexCount() { return this.pointIndex.length; } // ALWAYS INDEXED ... all index vectors must have same length.\n    /** Get the number of faces.\n     * * Note that a \"face\" is not a facet.\n     * * A \"face\" is a subset of facets grouped for application purposes.\n     */\n    get faceCount() { return this.face.length; }\n    /** return indexed point. This is a copy of the coordinates, not a reference. */\n    getPoint(i, out) {\n        return this.point.getPoint3dAtCheckedPointIndex(i, out);\n    }\n    /** return indexed normal. This is the COPY to the normal, not a reference. */\n    getNormal(i) { return this.normal ? this.normal.getVector3dAtCheckedVectorIndex(i) : undefined; }\n    /** return indexed param. This is the COPY of the coordinates, not a reference. */\n    getParam(i) { return this.param ? this.param.getPoint2dAtCheckedPointIndex(i) : undefined; }\n    /** return indexed color */\n    getColor(i) { return this.color ? this.color[i] : 0; }\n    /** return indexed visibility */\n    getEdgeVisible(i) { return this.edgeVisible[i]; }\n    /** Copy the contents (not pointer) of point[i] into dest. */\n    copyPointTo(i, dest) { this.point.getPoint3dAtUncheckedPointIndex(i, dest); }\n    /** Copy the contents (not pointer) of normal[i] into dest. */\n    copyNormalTo(i, dest) { if (this.normal)\n        this.normal.getVector3dAtCheckedVectorIndex(i, dest); }\n    /** Copy the contents (not pointer) of param[i] into dest. */\n    copyParamTo(i, dest) { if (this.param)\n        this.param.getPoint2dAtCheckedPointIndex(i, dest); }\n    /** test if normal at a specified index matches uv */\n    isAlmostEqualParamIndexUV(index, u, v) {\n        if (this.param !== undefined && index >= 0 && index < this.param.length)\n            return Geometry.isSameCoordinate(u, this.param.getXAtUncheckedPointIndex(index))\n                && Geometry.isSameCoordinate(v, this.param.getYAtUncheckedPointIndex(index));\n        return false;\n    }\n    /**\n     * * Copy data from other to this.\n     * * This is the essence of transferring coordinates spread throughout a large polyface into a visitor's single facet.\n     * * \"other\" is the large polyface\n     * * \"this\" is the visitor\n     * * does NOT copy face data - visitors reference the FacetFaceData array for the whole polyface!!\n     * @param other polyface data being mined.\n     * @param index0 start index in other's index arrays\n     * @param index1 end index (one beyond last data accessed0 in other's index arrays\n     * @param numWrap number of points to replicate as wraparound.\n     */\n    gatherIndexedData(other, index0, index1, numWrap) {\n        const numEdge = index1 - index0;\n        const numTotal = numEdge + numWrap;\n        this.resizeAllDataArrays(numTotal);\n        // copy wrapped points\n        for (let i = 0; i < numEdge; i++)\n            this.point.transferFromGrowableXYZArray(i, other.point, other.pointIndex[index0 + i]);\n        for (let i = 0; i < numWrap; i++)\n            this.point.transferFromGrowableXYZArray(numEdge + i, this.point, i);\n        // copy wrapped pointIndex\n        for (let i = 0; i < numEdge; i++)\n            this.pointIndex[i] = other.pointIndex[index0 + i];\n        for (let i = 0; i < numWrap; i++)\n            this.pointIndex[numEdge + i] = this.pointIndex[i];\n        // copy wrapped edge visibility\n        for (let i = 0; i < numEdge; i++)\n            this.edgeVisible[i] = other.edgeVisible[index0 + i];\n        for (let i = 0; i < numWrap; i++)\n            this.edgeVisible[numEdge + i] = this.edgeVisible[i];\n        if (this.normal && this.normalIndex && other.normal && other.normalIndex) {\n            for (let i = 0; i < numEdge; i++)\n                this.normal.transferFromGrowableXYZArray(i, other.normal, other.normalIndex[index0 + i]);\n            for (let i = 0; i < numWrap; i++)\n                this.normal.transferFromGrowableXYZArray(numEdge + i, this.normal, i);\n            for (let i = 0; i < numEdge; i++)\n                this.normalIndex[i] = other.normalIndex[index0 + i];\n            for (let i = 0; i < numWrap; i++)\n                this.normalIndex[numEdge + i] = this.normalIndex[i];\n        }\n        if (this.param && this.paramIndex && other.param && other.paramIndex) {\n            for (let i = 0; i < numEdge; i++)\n                this.param.transferFromGrowableXYArray(i, other.param, other.paramIndex[index0 + i]);\n            for (let i = 0; i < numWrap; i++)\n                this.param.transferFromGrowableXYArray(numEdge + i, this.param, i);\n            for (let i = 0; i < numEdge; i++)\n                this.paramIndex[i] = other.paramIndex[index0 + i];\n            for (let i = 0; i < numWrap; i++)\n                this.paramIndex[numEdge + i] = this.paramIndex[i];\n        }\n        if (this.color && this.colorIndex && other.color && other.colorIndex) {\n            for (let i = 0; i < numEdge; i++)\n                this.color[i] = other.color[other.colorIndex[index0 + i]];\n            for (let i = 0; i < numWrap; i++)\n                this.color[numEdge + i] = this.color[i];\n            for (let i = 0; i < numEdge; i++)\n                this.colorIndex[i] = other.colorIndex[index0 + i];\n            for (let i = 0; i < numWrap; i++)\n                this.colorIndex[numEdge + i] = this.colorIndex[i];\n        }\n        if (this.auxData && other.auxData && this.auxData.channels.length === other.auxData.channels.length) {\n            for (let iChannel = 0; iChannel < this.auxData.channels.length; iChannel++) {\n                const thisChannel = this.auxData.channels[iChannel];\n                const otherChannel = other.auxData.channels[iChannel];\n                const blockSize = thisChannel.entriesPerValue;\n                if (thisChannel.data.length === otherChannel.data.length) {\n                    for (let iData = 0; iData < thisChannel.data.length; iData++) {\n                        const thisData = thisChannel.data[iData];\n                        const otherData = otherChannel.data[iData];\n                        for (let i = 0; i < numEdge; i++)\n                            thisData.copyValues(otherData, i, other.auxData.indices[index0 + i], blockSize);\n                        for (let i = 0; i < numWrap; i++)\n                            thisData.copyValues(thisData, other.auxData.indices[numEdge + i], i, blockSize);\n                    }\n                }\n            }\n            for (let i = 0; i < numEdge; i++)\n                this.auxData.indices[i] = other.auxData.indices[index0 + i];\n            for (let i = 0; i < numWrap; i++)\n                this.auxData.indices[numEdge + i] = this.auxData.indices[i];\n        }\n    }\n    static trimArray(data, length) { if (data && length < data.length)\n        data.length = length; }\n    /** Trim all index arrays to stated length.\n     * * This is called by PolyfaceBuilder to clean up after an aborted construction sequence.\n     */\n    trimAllIndexArrays(length) {\n        PolyfaceData.trimArray(this.pointIndex, length);\n        PolyfaceData.trimArray(this.paramIndex, length);\n        PolyfaceData.trimArray(this.normalIndex, length);\n        PolyfaceData.trimArray(this.colorIndex, length);\n        PolyfaceData.trimArray(this.edgeVisible, length);\n        if (this.auxData) {\n            PolyfaceData.trimArray(this.auxData.indices, length);\n            for (const channel of this.auxData.channels) {\n                for (const data of channel.data)\n                    PolyfaceData.trimArray(data.values, channel.entriesPerValue * length);\n            }\n        }\n    }\n    /** Resize all data arrays to specified length */\n    resizeAllDataArrays(length) {\n        if (length > this.point.length) {\n            while (this.point.length < length)\n                this.point.push(Point3d.create());\n            while (this.pointIndex.length < length)\n                this.pointIndex.push(-1);\n            while (this.edgeVisible.length < length)\n                this.edgeVisible.push(false);\n            if (this.normal)\n                while (this.normal.length < length)\n                    this.normal.push(Vector3d.create());\n            if (this.param)\n                while (this.param.length < length)\n                    this.param.push(Point2d.create());\n            if (this.color)\n                while (this.color.length < length)\n                    this.color.push(0);\n            if (this.auxData) {\n                for (const channel of this.auxData.channels) {\n                    for (const channelData of channel.data) {\n                        while (channelData.values.length < length * channel.entriesPerValue)\n                            channelData.values.push(0);\n                    }\n                }\n            }\n        }\n        else if (length < this.point.length) {\n            this.point.resize(length);\n            this.edgeVisible.length = length;\n            this.pointIndex.length = length;\n            if (this.normal)\n                this.normal.resize(length);\n            if (this.param)\n                this.param.resize(length);\n            if (this.color)\n                this.color.length = length;\n            if (this.auxData) {\n                for (const channel of this.auxData.channels) {\n                    for (const channelData of channel.data) {\n                        channelData.values.length = length * channel.entriesPerValue;\n                    }\n                }\n            }\n        }\n    }\n    /** Return the range of the point array (optionally transformed) */\n    range(result, transform) {\n        result = result ? result : Range3d.createNull();\n        result.extendArray(this.point, transform);\n        return result;\n    }\n    /** reverse indices facet-by-facet, with the given facetStartIndex array delimiting faces.\n     *\n     * * facetStartIndex[0] == 0 always -- start of facet zero.\n     * * facet k has indices from facetStartIndex[k] <= i < facetStartIndex[k+1]\n     * * hence for \"internal\" k, facetStartIndex[k] is both the upper limit of facet k-1 and the start of facet k.\n     * *\n     */\n    reverseIndices(facetStartIndex) {\n        if (facetStartIndex && PolyfaceData.isValidFacetStartIndexArray(facetStartIndex)) {\n            PolyfaceData.reverseIndices(facetStartIndex, this.pointIndex, true);\n            if (this.normalIndex !== this.pointIndex)\n                PolyfaceData.reverseIndices(facetStartIndex, this.normalIndex, true);\n            if (this.paramIndex !== this.pointIndex)\n                PolyfaceData.reverseIndices(facetStartIndex, this.paramIndex, true);\n            if (this.colorIndex !== this.pointIndex)\n                PolyfaceData.reverseIndices(facetStartIndex, this.colorIndex, true);\n            PolyfaceData.reverseIndices(facetStartIndex, this.edgeVisible, false);\n        }\n    }\n    /** reverse indices facet-by-facet, with the given facetStartIndex array delimiting faces.\n     *\n     * * facetStartIndex[0] == 0 always -- start of facet zero.\n     * * facet k has indices from facetStartIndex[k] <= i < facetStartIndex[k+1]\n     * * hence for \"internal\" k, facetStartIndex[k] is both the upper limit of facet k-1 and the start of facet k.\n     * *\n     */\n    reverseIndicesSingleFacet(facetId, facetStartIndex) {\n        PolyfaceData.reverseIndicesSingleFacet(facetId, facetStartIndex, this.pointIndex, true);\n        if (this.normalIndex !== this.pointIndex)\n            PolyfaceData.reverseIndicesSingleFacet(facetId, facetStartIndex, this.normalIndex, true);\n        if (this.paramIndex !== this.pointIndex)\n            PolyfaceData.reverseIndicesSingleFacet(facetId, facetStartIndex, this.paramIndex, true);\n        if (this.colorIndex !== this.pointIndex)\n            PolyfaceData.reverseIndicesSingleFacet(facetId, facetStartIndex, this.colorIndex, true);\n        PolyfaceData.reverseIndicesSingleFacet(facetId, facetStartIndex, this.edgeVisible, false);\n    }\n    /** Scale all the normals by -1 */\n    reverseNormals() {\n        if (this.normal)\n            this.normal.scaleInPlace(-1.0);\n    }\n    /** Apply `transform` to point and normal arrays and to auxData.\n     * * IMPORTANT This base class is just a data carrier.  It does not know if the index order and normal directions have special meaning.\n     * * i.e. caller must separately reverse index order and normal direction if needed.\n     */\n    tryTransformInPlace(transform) {\n        this.point.multiplyTransformInPlace(transform);\n        if (this.normal && !transform.matrix.isIdentity)\n            this.normal.multiplyAndRenormalizeMatrix3dInverseTransposeInPlace(transform.matrix);\n        return undefined === this.auxData || this.auxData.tryTransformInPlace(transform);\n    }\n    /**\n     * * Search for duplicates within points, normals, params, and colors.\n     * * compress the data arrays.\n     * * revise all indexing for the relocated data.\n     */\n    compress() {\n        const packedPoints = ClusterableArray.clusterGrowablePoint3dArray(this.point);\n        this.point = packedPoints.growablePackedPoints;\n        packedPoints.updateIndices(this.pointIndex);\n        //  compressUnusedGrowableXYZArray(this.point, this.pointIndex);\n        if (this.normalIndex && this.normal) {\n            const packedNormals = ClusterableArray.clusterGrowablePoint3dArray(this.normal);\n            this.normal = packedNormals.growablePackedPoints;\n            packedNormals.updateIndices(this.normalIndex);\n        }\n        if (this.paramIndex && this.param) {\n            const packedParams = ClusterableArray.clusterGrowablePoint2dArray(this.param);\n            this.param = packedParams.growablePackedPoints;\n            packedParams.updateIndices(this.paramIndex);\n        }\n        if (this.colorIndex && this.color) {\n            const packedColors = ClusterableArray.clusterNumberArray(this.color);\n            this.color = packedColors.packedNumbers;\n            packedColors.updateIndices(this.colorIndex);\n        }\n    }\n    /**\n     * Test if facetStartIndex is (minimally!) valid:\n     * * length must be nonzero (recall that for \"no facets\" the facetStartIndexArray still must contain a 0)\n     * * Each entry must be strictly smaller than the one that follows.\n     * @param facetStartIndex array of facetStart data.  facet `i` has indices at `facetsStartIndex[i]` to (one before) `facetStartIndex[i+1]`\n     */\n    static isValidFacetStartIndexArray(facetStartIndex) {\n        // facetStartIndex for empty facets has a single entry \"0\" -- empty array is not allowed\n        if (facetStartIndex.length === 0)\n            return false;\n        for (let i = 0; i + 1 < facetStartIndex.length; i++)\n            if (facetStartIndex[i] >= facetStartIndex[i + 1])\n                return false;\n        return true;\n    }\n    /** Reverse data in entire facet indexing arrays.\n     * * parameterized over type T so non-number data -- e.g. boolean visibility flags -- can be reversed.\n     */\n    static reverseIndices(facetStartIndex, indices, preserveStart) {\n        if (!indices || indices.length === 0)\n            return true; // empty case\n        if (indices.length > 0) {\n            if (facetStartIndex[facetStartIndex.length - 1] === indices.length) {\n                for (let i = 0; i + 1 < facetStartIndex.length; i++) {\n                    let index0 = facetStartIndex[i];\n                    let index1 = facetStartIndex[i + 1];\n                    if (preserveStart) {\n                        // leave [index0] as is so reversed facet starts at same vertex\n                        while (index1 > index0 + 2) {\n                            index1--;\n                            index0++;\n                            const a = indices[index0];\n                            indices[index0] = indices[index1];\n                            indices[index1] = a;\n                        }\n                    }\n                    else {\n                        // reverse all\n                        while (index1 > index0 + 1) {\n                            index1--;\n                            const a = indices[index0];\n                            indices[index0] = indices[index1];\n                            indices[index1] = a;\n                            index0++;\n                        }\n                    }\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    /** Reverse data in entire facet indexing arrays.\n     * * parameterized over type T so non-number data -- e.g. boolean visibility flags -- can be reversed.\n     */\n    static reverseIndicesSingleFacet(facetId, facetStartIndex, indices, preserveStart) {\n        if (!indices || indices.length === 0)\n            return true; // empty case\n        if (indices.length > 0) {\n            if (facetStartIndex[facetStartIndex.length - 1] === indices.length\n                && facetId >= 0 && facetId + 1 < facetStartIndex.length) {\n                let index0 = facetStartIndex[facetId];\n                let index1 = facetStartIndex[facetId + 1];\n                if (preserveStart) {\n                    // leave [index0] as is so reversed facet starts at same vertex\n                    while (index1 > index0 + 2) {\n                        index1--;\n                        index0++;\n                        const a = indices[index0];\n                        indices[index0] = indices[index1];\n                        indices[index1] = a;\n                    }\n                }\n                else {\n                    // reverse all\n                    while (index1 > index0 + 1) {\n                        index1--;\n                        const a = indices[index0];\n                        indices[index0] = indices[index1];\n                        indices[index1] = a;\n                        index0++;\n                    }\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n}\n// <ul\n// <li>optional arrays (normal, uv, color) must be indicated at constructor time.\n// <li>all arrays are (independently) indexed.\n// <li>with regret, the point, param, normal, and color arrays are exposed publicly.\n// <li>getX methods are \"trusting\" -- no bounds check\n// <li>getX methods return references to X.\n// <li> EXCEPT -- for optional arrays, the return 000.\n// <li>copyX methods move data to caller-supplied result..\n// </ul>\n/** Relative tolerance used in tests for planar facets\n * @internal\n */\nPolyfaceData.planarityLocalRelTol = 1.0e-13;\nexport { PolyfaceData };\n/**\n * pack out data entries that are unreferenced.\n * @param data data to pack\n * @param indices indices into the data.\n\nfunction compressUnusedGrowableXYZArray(data: GrowableXYZArray, indices: number[]): boolean {\n  // 1 entry per data[i]\n  // pass 0: number of references\n  // pass 1: post-compression index (or -1)\n  const n0 = data.length;\n  const work = new Int32Array(data.length);\n  for (const k of indices) {\n    if (k < 0 || k >= n0)\n      return false;\n    work[k]++;\n  }\n  let n1 = 0;\n  for (let i = 0; i < n0; i++) {\n    if (work[i] === 0)\n      work[i] = -1;\n    else\n      work[i] = n1++;\n  }\n  const numIndex = indices.length;\n  for (let i = 0; i < numIndex; i++) {\n    indices[i] = work[indices[i]];\n  }\n  for (let i = 0; i < n0; i++) {\n    const j = work[i];\n    if (j >= 0)\n      data.moveIndexToIndex(i, j);\n  }\n  data.length = n1;\n  return true;\n}\n*/\n//# sourceMappingURL=PolyfaceData.js.map",
      "start": 1693508123099,
      "end": 1693508123240,
      "sourcemaps": null
    }
  ]
}
