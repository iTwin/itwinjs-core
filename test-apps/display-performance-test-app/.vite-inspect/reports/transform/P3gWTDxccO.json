{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tile/PntsReader.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tiles\n */\nimport { Logger, utf8ToString } from \"@itwin/core-bentley\";\nimport { Point3d, Range3d } from \"@itwin/core-geometry\";\nimport { BatchType, Feature, FeatureTable, PackedFeatureTable, PntsHeader, QParams3d, QPoint3d, Quantization } from \"@itwin/core-common\";\nimport { FrontendLoggerCategory } from \"../common/FrontendLoggerCategory\";\nimport { Mesh } from \"../render/primitives/mesh/MeshPrimitives\";\nfunction readPntsColors(stream, dataOffset, pnts) {\n    const nPts = pnts.POINTS_LENGTH;\n    const nComponents = 3 * nPts;\n    if (pnts.RGB)\n        return new Uint8Array(stream.arrayBuffer, dataOffset + pnts.RGB.byteOffset, nComponents);\n    if (pnts.RGBA) {\n        // ###TODO support point cloud transparency.\n        const rgb = new Uint8Array(nComponents);\n        const rgba = new Uint8Array(stream.arrayBuffer, dataOffset + pnts.RGBA.byteOffset, nComponents);\n        for (let i = 0; i < nComponents; i += 4) {\n            rgb[i + 0] = rgba[i + 0];\n            rgb[i + 1] = rgba[i + 1];\n            rgb[i + 2] = rgba[i + 2];\n        }\n        return rgb;\n    }\n    else if (pnts.RGB565) {\n        // Each color is 16 bits: 5 red, 6 green, 5 blue.\n        const crgb = new Uint16Array(stream.arrayBuffer, dataOffset + pnts.RGB565.byteOffset, nPts);\n        const rgb = new Uint8Array(nComponents);\n        for (let i = 0; i < nPts; i++) {\n            const c = crgb[i];\n            rgb[i + 0] = (c >> 11) & 0x1f;\n            rgb[i + 1] = (c >> 5) & 0x3f;\n            rgb[i + 2] = c & 0x1f;\n        }\n        return rgb;\n    }\n    return undefined;\n}\nfunction readPnts(stream, dataOffset, pnts) {\n    const nPts = pnts.POINTS_LENGTH;\n    let params;\n    let points;\n    if (pnts.POSITION_QUANTIZED) {\n        const qpos = pnts.POSITION_QUANTIZED;\n        const offset = pnts.QUANTIZED_VOLUME_OFFSET;\n        const scale = pnts.QUANTIZED_VOLUME_SCALE;\n        const qOrigin = new Point3d(offset[0], offset[1], offset[2]);\n        const qScale = new Point3d(Quantization.computeScale(scale[0]), Quantization.computeScale(scale[1]), Quantization.computeScale(scale[2]));\n        params = QParams3d.fromOriginAndScale(qOrigin, qScale);\n        points = new Uint16Array(stream.arrayBuffer, dataOffset + qpos.byteOffset, 3 * nPts);\n    }\n    else {\n        const qOrigin = new Point3d(0, 0, 0);\n        const qScale = new Point3d(1, 1, 1);\n        params = QParams3d.fromOriginAndScale(qOrigin, qScale);\n        points = new Float32Array(stream.arrayBuffer, dataOffset + pnts.POSITION.byteOffset, 3 * nPts);\n    }\n    const colors = readPntsColors(stream, dataOffset, pnts);\n    return { params, points, colors };\n}\nasync function decodeDracoPointCloud(buf) {\n    try {\n        const dracoLoader = (await import(\"@loaders.gl/draco\")).DracoLoader;\n        const mesh = await dracoLoader.parse(buf, {});\n        if (mesh.topology !== \"point-list\")\n            return undefined;\n        const pos = mesh.attributes.POSITION?.value;\n        if (!pos || (pos.length % 3) !== 0)\n            return undefined;\n        let colors = mesh.attributes.RGB?.value ?? mesh.attributes.COLOR_0?.value;\n        if (!colors) {\n            // ###TODO support point cloud transparency.\n            const rgba = mesh.attributes.RGBA?.value;\n            if (rgba && (rgba.length % 4) === 0) {\n                // We currently don't support alpha channel for point clouds - strip it.\n                colors = new Uint8Array(3 * rgba.length / 4);\n                let j = 0;\n                for (let i = 0; i < rgba.length; i += 4) {\n                    colors[j++] = rgba[i];\n                    colors[j++] = rgba[i + 1];\n                    colors[j++] = rgba[i + 2];\n                }\n            }\n        }\n        let posRange;\n        const bbox = mesh.header?.boundingBox;\n        if (bbox) {\n            posRange = Range3d.createXYZXYZ(bbox[0][0], bbox[0][1], bbox[0][2], bbox[1][0], bbox[1][1], bbox[1][2]);\n        }\n        else {\n            posRange = Range3d.createNull();\n            for (let i = 0; i < pos.length; i += 3)\n                posRange.extendXYZ(pos[i], pos[i + 1], pos[i + 2]);\n        }\n        const params = QParams3d.fromRange(posRange);\n        const pt = Point3d.createZero();\n        const qpt = QPoint3d.create(pt, params);\n        const points = new Uint16Array(pos.length);\n        for (let i = 0; i < pos.length; i += 3) {\n            pt.set(pos[i], pos[i + 1], pos[i + 2]);\n            qpt.init(pt, params);\n            points[i] = qpt.x;\n            points[i + 1] = qpt.y;\n            points[i + 2] = qpt.z;\n        }\n        return { points, params, colors: colors instanceof Uint8Array ? colors : undefined };\n    }\n    catch (err) {\n        Logger.logWarning(FrontendLoggerCategory.Render, \"Failed to decode draco-encoded point cloud\");\n        Logger.logException(FrontendLoggerCategory.Render, err);\n        return undefined;\n    }\n}\n/** Deserialize a point cloud tile and return it as a RenderGraphic.\n * @internal\n */\nexport async function readPointCloudTileContent(stream, iModel, modelId, _is3d, tile, system) {\n    let graphic;\n    let rtcCenter;\n    const header = new PntsHeader(stream);\n    if (!header.isValid)\n        return { graphic, rtcCenter };\n    const range = tile.contentRange;\n    const featureTableJsonOffset = stream.curPos;\n    const featureStrData = stream.nextBytes(header.featureTableJsonLength);\n    const featureStr = utf8ToString(featureStrData);\n    const featureValue = JSON.parse(featureStr);\n    if (undefined === featureValue)\n        return { graphic, rtcCenter };\n    let props;\n    const dataOffset = featureTableJsonOffset + header.featureTableJsonLength;\n    const draco = featureValue.extensions ? featureValue.extensions[\"3DTILES_draco_point_compression\"] : undefined;\n    if (draco) {\n        try {\n            const buf = new Uint8Array(stream.arrayBuffer, dataOffset + draco.byteOffset, draco.byteLength);\n            props = await decodeDracoPointCloud(buf);\n        }\n        catch (_) {\n            //\n        }\n    }\n    else {\n        props = readPnts(stream, dataOffset, featureValue);\n    }\n    if (!props)\n        return { graphic, rtcCenter };\n    let batchRange = range;\n    if (featureValue.RTC_CENTER) {\n        rtcCenter = Point3d.fromJSON(featureValue.RTC_CENTER);\n        batchRange = range.clone();\n        batchRange.low.minus(rtcCenter, batchRange.low);\n        batchRange.high.minus(rtcCenter, batchRange.high);\n    }\n    if (!props.colors) {\n        // ###TODO we really should support uniform color instead of allocating an RGB value per point...\n        props.colors = new Uint8Array(3 * featureValue.POINTS_LENGTH);\n        const rgba = featureValue.CONSTANT_RGBA;\n        if (rgba) {\n            // ###TODO support point cloud transparency.\n            for (let i = 0; i < featureValue.POINTS_LENGTH * 3; i += 3) {\n                props.colors[i] = rgba[0];\n                props.colors[i + 1] = rgba[1];\n                props.colors[i + 2] = rgba[2];\n            }\n        }\n        else {\n            // Default to white.\n            props.colors.fill(0xff, 0, props.colors.length);\n        }\n    }\n    const featureTable = new FeatureTable(1, modelId, BatchType.Primary);\n    const features = new Mesh.Features(featureTable);\n    features.add(new Feature(modelId), 1);\n    let params = props.params;\n    if (props.points instanceof Float32Array) {\n        // we don't have a true range for unquantized points, so calc one here for voxelSize\n        const rng = Range3d.createNull();\n        for (let i = 0; i < props.points.length; i += 3)\n            rng.extendXYZ(props.points[i], props.points[i + 1], props.points[i + 2]);\n        params = QParams3d.fromRange(rng);\n    }\n    // 256 here is tile.maximumSize (on non-additive refinement tiles)\n    // If additiveRefinement, set voxelSize to 0 which will cause it draw to with minPixelsPerVoxel, which defaults to 2\n    // That way, it will draw as if in pixel mode, and voxelScale will still function\n    // Checking across a variety of 10 point clouds, 2 to 4 seems to work well for pixel settings (depending on the\n    // cloud), so 2 is a decent default\n    // (If voxelSize is used normally in this case, it draws different size pixels for different tiles, and since\n    // they can overlap ranges, no good way found to calculate a voxelSize)\n    const voxelSize = tile.additiveRefinement ? 0 : params.rangeDiagonal.maxAbs() / 256;\n    graphic = system.createPointCloud({\n        positions: props.points,\n        qparams: props.params,\n        colors: props.colors,\n        features: features.toFeatureIndex(),\n        voxelSize,\n        colorFormat: \"rgb\",\n    }, iModel);\n    graphic = system.createBatch(graphic, PackedFeatureTable.pack(featureTable), batchRange);\n    return { graphic, rtcCenter };\n}\n//# sourceMappingURL=PntsReader.js.map",
      "start": 1693508121888,
      "end": 1693508122027,
      "sourcemaps": null
    },
    {
      "name": "vite:build-import-analysis",
      "result": "import { __vitePreload } from \"\u0000vite/preload-helper\";/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tiles\n */\nimport { Logger, utf8ToString } from \"@itwin/core-bentley\";\nimport { Point3d, Range3d } from \"@itwin/core-geometry\";\nimport { BatchType, Feature, FeatureTable, PackedFeatureTable, PntsHeader, QParams3d, QPoint3d, Quantization } from \"@itwin/core-common\";\nimport { FrontendLoggerCategory } from \"../common/FrontendLoggerCategory\";\nimport { Mesh } from \"../render/primitives/mesh/MeshPrimitives\";\nfunction readPntsColors(stream, dataOffset, pnts) {\n    const nPts = pnts.POINTS_LENGTH;\n    const nComponents = 3 * nPts;\n    if (pnts.RGB)\n        return new Uint8Array(stream.arrayBuffer, dataOffset + pnts.RGB.byteOffset, nComponents);\n    if (pnts.RGBA) {\n        // ###TODO support point cloud transparency.\n        const rgb = new Uint8Array(nComponents);\n        const rgba = new Uint8Array(stream.arrayBuffer, dataOffset + pnts.RGBA.byteOffset, nComponents);\n        for (let i = 0; i < nComponents; i += 4) {\n            rgb[i + 0] = rgba[i + 0];\n            rgb[i + 1] = rgba[i + 1];\n            rgb[i + 2] = rgba[i + 2];\n        }\n        return rgb;\n    }\n    else if (pnts.RGB565) {\n        // Each color is 16 bits: 5 red, 6 green, 5 blue.\n        const crgb = new Uint16Array(stream.arrayBuffer, dataOffset + pnts.RGB565.byteOffset, nPts);\n        const rgb = new Uint8Array(nComponents);\n        for (let i = 0; i < nPts; i++) {\n            const c = crgb[i];\n            rgb[i + 0] = (c >> 11) & 0x1f;\n            rgb[i + 1] = (c >> 5) & 0x3f;\n            rgb[i + 2] = c & 0x1f;\n        }\n        return rgb;\n    }\n    return undefined;\n}\nfunction readPnts(stream, dataOffset, pnts) {\n    const nPts = pnts.POINTS_LENGTH;\n    let params;\n    let points;\n    if (pnts.POSITION_QUANTIZED) {\n        const qpos = pnts.POSITION_QUANTIZED;\n        const offset = pnts.QUANTIZED_VOLUME_OFFSET;\n        const scale = pnts.QUANTIZED_VOLUME_SCALE;\n        const qOrigin = new Point3d(offset[0], offset[1], offset[2]);\n        const qScale = new Point3d(Quantization.computeScale(scale[0]), Quantization.computeScale(scale[1]), Quantization.computeScale(scale[2]));\n        params = QParams3d.fromOriginAndScale(qOrigin, qScale);\n        points = new Uint16Array(stream.arrayBuffer, dataOffset + qpos.byteOffset, 3 * nPts);\n    }\n    else {\n        const qOrigin = new Point3d(0, 0, 0);\n        const qScale = new Point3d(1, 1, 1);\n        params = QParams3d.fromOriginAndScale(qOrigin, qScale);\n        points = new Float32Array(stream.arrayBuffer, dataOffset + pnts.POSITION.byteOffset, 3 * nPts);\n    }\n    const colors = readPntsColors(stream, dataOffset, pnts);\n    return { params, points, colors };\n}\nasync function decodeDracoPointCloud(buf) {\n    try {\n        const dracoLoader = (await __vitePreload(() => import(\"@loaders.gl/draco\"),__VITE_IS_MODERN__?\"__VITE_PRELOAD__\":void 0)).DracoLoader;\n        const mesh = await dracoLoader.parse(buf, {});\n        if (mesh.topology !== \"point-list\")\n            return undefined;\n        const pos = mesh.attributes.POSITION?.value;\n        if (!pos || (pos.length % 3) !== 0)\n            return undefined;\n        let colors = mesh.attributes.RGB?.value ?? mesh.attributes.COLOR_0?.value;\n        if (!colors) {\n            // ###TODO support point cloud transparency.\n            const rgba = mesh.attributes.RGBA?.value;\n            if (rgba && (rgba.length % 4) === 0) {\n                // We currently don't support alpha channel for point clouds - strip it.\n                colors = new Uint8Array(3 * rgba.length / 4);\n                let j = 0;\n                for (let i = 0; i < rgba.length; i += 4) {\n                    colors[j++] = rgba[i];\n                    colors[j++] = rgba[i + 1];\n                    colors[j++] = rgba[i + 2];\n                }\n            }\n        }\n        let posRange;\n        const bbox = mesh.header?.boundingBox;\n        if (bbox) {\n            posRange = Range3d.createXYZXYZ(bbox[0][0], bbox[0][1], bbox[0][2], bbox[1][0], bbox[1][1], bbox[1][2]);\n        }\n        else {\n            posRange = Range3d.createNull();\n            for (let i = 0; i < pos.length; i += 3)\n                posRange.extendXYZ(pos[i], pos[i + 1], pos[i + 2]);\n        }\n        const params = QParams3d.fromRange(posRange);\n        const pt = Point3d.createZero();\n        const qpt = QPoint3d.create(pt, params);\n        const points = new Uint16Array(pos.length);\n        for (let i = 0; i < pos.length; i += 3) {\n            pt.set(pos[i], pos[i + 1], pos[i + 2]);\n            qpt.init(pt, params);\n            points[i] = qpt.x;\n            points[i + 1] = qpt.y;\n            points[i + 2] = qpt.z;\n        }\n        return { points, params, colors: colors instanceof Uint8Array ? colors : undefined };\n    }\n    catch (err) {\n        Logger.logWarning(FrontendLoggerCategory.Render, \"Failed to decode draco-encoded point cloud\");\n        Logger.logException(FrontendLoggerCategory.Render, err);\n        return undefined;\n    }\n}\n/** Deserialize a point cloud tile and return it as a RenderGraphic.\n * @internal\n */\nexport async function readPointCloudTileContent(stream, iModel, modelId, _is3d, tile, system) {\n    let graphic;\n    let rtcCenter;\n    const header = new PntsHeader(stream);\n    if (!header.isValid)\n        return { graphic, rtcCenter };\n    const range = tile.contentRange;\n    const featureTableJsonOffset = stream.curPos;\n    const featureStrData = stream.nextBytes(header.featureTableJsonLength);\n    const featureStr = utf8ToString(featureStrData);\n    const featureValue = JSON.parse(featureStr);\n    if (undefined === featureValue)\n        return { graphic, rtcCenter };\n    let props;\n    const dataOffset = featureTableJsonOffset + header.featureTableJsonLength;\n    const draco = featureValue.extensions ? featureValue.extensions[\"3DTILES_draco_point_compression\"] : undefined;\n    if (draco) {\n        try {\n            const buf = new Uint8Array(stream.arrayBuffer, dataOffset + draco.byteOffset, draco.byteLength);\n            props = await decodeDracoPointCloud(buf);\n        }\n        catch (_) {\n            //\n        }\n    }\n    else {\n        props = readPnts(stream, dataOffset, featureValue);\n    }\n    if (!props)\n        return { graphic, rtcCenter };\n    let batchRange = range;\n    if (featureValue.RTC_CENTER) {\n        rtcCenter = Point3d.fromJSON(featureValue.RTC_CENTER);\n        batchRange = range.clone();\n        batchRange.low.minus(rtcCenter, batchRange.low);\n        batchRange.high.minus(rtcCenter, batchRange.high);\n    }\n    if (!props.colors) {\n        // ###TODO we really should support uniform color instead of allocating an RGB value per point...\n        props.colors = new Uint8Array(3 * featureValue.POINTS_LENGTH);\n        const rgba = featureValue.CONSTANT_RGBA;\n        if (rgba) {\n            // ###TODO support point cloud transparency.\n            for (let i = 0; i < featureValue.POINTS_LENGTH * 3; i += 3) {\n                props.colors[i] = rgba[0];\n                props.colors[i + 1] = rgba[1];\n                props.colors[i + 2] = rgba[2];\n            }\n        }\n        else {\n            // Default to white.\n            props.colors.fill(0xff, 0, props.colors.length);\n        }\n    }\n    const featureTable = new FeatureTable(1, modelId, BatchType.Primary);\n    const features = new Mesh.Features(featureTable);\n    features.add(new Feature(modelId), 1);\n    let params = props.params;\n    if (props.points instanceof Float32Array) {\n        // we don't have a true range for unquantized points, so calc one here for voxelSize\n        const rng = Range3d.createNull();\n        for (let i = 0; i < props.points.length; i += 3)\n            rng.extendXYZ(props.points[i], props.points[i + 1], props.points[i + 2]);\n        params = QParams3d.fromRange(rng);\n    }\n    // 256 here is tile.maximumSize (on non-additive refinement tiles)\n    // If additiveRefinement, set voxelSize to 0 which will cause it draw to with minPixelsPerVoxel, which defaults to 2\n    // That way, it will draw as if in pixel mode, and voxelScale will still function\n    // Checking across a variety of 10 point clouds, 2 to 4 seems to work well for pixel settings (depending on the\n    // cloud), so 2 is a decent default\n    // (If voxelSize is used normally in this case, it draws different size pixels for different tiles, and since\n    // they can overlap ranges, no good way found to calculate a voxelSize)\n    const voxelSize = tile.additiveRefinement ? 0 : params.rangeDiagonal.maxAbs() / 256;\n    graphic = system.createPointCloud({\n        positions: props.points,\n        qparams: props.params,\n        colors: props.colors,\n        features: features.toFeatureIndex(),\n        voxelSize,\n        colorFormat: \"rgb\",\n    }, iModel);\n    graphic = system.createBatch(graphic, PackedFeatureTable.pack(featureTable), batchRange);\n    return { graphic, rtcCenter };\n}\n//# sourceMappingURL=PntsReader.js.map",
      "start": 1693508122034,
      "end": 1693508122034,
      "order": "normal",
      "sourcemaps": null
    }
  ]
}
