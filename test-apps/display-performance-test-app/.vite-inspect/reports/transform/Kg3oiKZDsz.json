{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/bentley/lib/esm/PriorityQueue.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Collections\n */\nimport { shallowClone } from \"./SortedArray\";\n/**\n * A [priority queue](https://en.wikipedia.org/wiki/Priority_queue) implemented as a heap array.\n * The queue is ordered by an [[OrderedComparator]] function supplied by the user such that the value in the queue that compares less than all other values is always located at the front of the queue.\n * @public\n */\nexport class PriorityQueue {\n    /**\n     * Constructor\n     * @param compare The function used to compare values in the queue. If `compare(x, y)` returns a negative value, then x is placed before y in the queue.\n     * @param clone The function used to clone a value for insertion onto the queue. The default implementation simply returns its input.\n     * @note If the criterion which control the result of the `compare` function changes, then [[PriorityQueue.sort]] should be used to reorder the queue according to the new criterion.\n     */\n    constructor(compare, clone = shallowClone) {\n        this._array = [];\n        this._compare = compare;\n        this._clone = clone;\n    }\n    /** The number of values in the queue. */\n    get length() { return this._array.length; }\n    /** Returns true if the queue contains no values. */\n    get isEmpty() { return 0 === this.length; }\n    /** Returns an iterator over the contents of the heap suitable for use in `for-of` loops. */\n    [Symbol.iterator]() { return this._array[Symbol.iterator](); }\n    _swap(a, b) {\n        const temp = this._array[a];\n        this._array[a] = this._array[b];\n        this._array[b] = temp;\n    }\n    _heapify(index) {\n        let candidate = -1;\n        while (true) {\n            const right = 2 * (index + 1);\n            const left = right - 1;\n            if (left < this.length && this._compare(this._array[left], this._array[index]) < 0)\n                candidate = left;\n            else\n                candidate = index;\n            if (right < this.length && this._compare(this._array[right], this._array[candidate]) < 0)\n                candidate = right;\n            if (candidate !== index) {\n                this._swap(candidate, index);\n                index = candidate;\n            }\n            else {\n                break;\n            }\n        }\n    }\n    /**\n     * Reorders the queue. This function should only (and *always*) be called when the criteria governing the ordering of items on the queue have changed.\n     * For example, a priority queue containing graphics sorted by their distance from the camera would need to be reordered when the position of the camera changes.\n     */\n    sort() {\n        for (let i = Math.ceil(this.length / 2); i >= 0; i--)\n            this._heapify(i);\n    }\n    /**\n     * Pushes a value onto the queue according to the sorting criterion.\n     * @param value The value to insert\n     * @returns The inserted value, cloned according to the [[CloneFunction]] supplied to this queue's constructor.\n     */\n    push(value) {\n        const clone = this._clone(value);\n        let index = this.length;\n        this._array.push(clone);\n        while (index !== 0) {\n            const parent = Math.floor((index - 1) / 2);\n            if (this._compare(this._array[index], this._array[parent]) < 0) {\n                this._swap(index, parent);\n                index = parent;\n            }\n            else {\n                break;\n            }\n        }\n        return clone;\n    }\n    /** Pushes a value onto the back of the queue without making any attempt to enforce ordering.\n     * After using this function, you must manually invoke sort() to ensure the queue is sorted again.\n     * @param value The value to append\n     * @returns The appended value, cloned according to the [[CloneFunction]] supplied to this queue's constructor.\n     */\n    append(value) {\n        const clone = this._clone(value);\n        this._array.push(clone);\n        return clone;\n    }\n    /** Returns the element at the front of the queue, or `undefined` if the queue is empty. */\n    get front() {\n        return this._peek(0);\n    }\n    /**\n     * Removes the front-most element off of the queue and returns it.\n     * @returns The front-most element, or undefined if the queue is empty.\n     */\n    pop() {\n        return this._pop(0);\n    }\n    /** Removes all values from the queue. */\n    clear() {\n        this._array.length = 0;\n    }\n    /**\n     * Removes the value at the specified index from the queue and reorders the queue.\n     * @param index The index of the value to remove\n     * @returns the value at the specified index, or undefined if the index is out of range.\n     */\n    _pop(index) {\n        if (index < 0 || index >= this.length)\n            return undefined;\n        const root = this._array[index];\n        this._swap(index, this.length - 1);\n        this._array.length--;\n        this._heapify(index);\n        return root;\n    }\n    /**\n     * Returns the value at the specified index in the queue.\n     * @param index The index of the value to retrieve\n     * @returns the value at the specified index, or undefined if the index is out of range.\n     */\n    _peek(index) {\n        if (index < 0 || index >= this.length)\n            return undefined;\n        else\n            return this._array[index];\n    }\n}\n//# sourceMappingURL=PriorityQueue.js.map",
      "start": 1693508120404,
      "end": 1693508120474,
      "sourcemaps": null
    }
  ]
}
