{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/bentley/lib/esm/Logger.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Logging\n */\nimport { BentleyError, IModelStatus } from \"./BentleyError\";\nimport { BentleyLoggerCategory } from \"./BentleyLoggerCategory\";\n/** Use to categorize logging messages by severity.\n * @public\n */\nexport var LogLevel;\n(function (LogLevel) {\n    /** Tracing and debugging - low level */\n    LogLevel[LogLevel[\"Trace\"] = 0] = \"Trace\";\n    /** Information - mid level */\n    LogLevel[LogLevel[\"Info\"] = 1] = \"Info\";\n    /** Warnings - high level */\n    LogLevel[LogLevel[\"Warning\"] = 2] = \"Warning\";\n    /** Errors - highest level */\n    LogLevel[LogLevel[\"Error\"] = 3] = \"Error\";\n    /** Higher than any real logging level. This is used to turn a category off. */\n    LogLevel[LogLevel[\"None\"] = 4] = \"None\";\n})(LogLevel || (LogLevel = {}));\n/** Logger allows libraries and apps to report potentially useful information about operations, and it allows apps and users to control\n * how or if the logged information is displayed or collected. See [Learning about Logging]($docs/learning/common/Logging.md).\n * @public\n */\nclass Logger {\n    /** Initialize the logger streams. Should be called at application initialization time. */\n    static initialize(logError, logWarning, logInfo, logTrace) {\n        Logger._logError = logError;\n        Logger._logWarning = logWarning;\n        Logger._logInfo = logInfo;\n        Logger._logTrace = logTrace;\n        Logger.turnOffLevelDefault();\n        Logger.turnOffCategories();\n    }\n    /** Initialize the logger to output to the console. */\n    static initializeToConsole() {\n        const logConsole = (level) => (category, message, metaData) => console.log(`${level} | ${category} | ${message} ${Logger.stringifyMetaData(metaData)}`); // eslint-disable-line no-console\n        Logger.initialize(logConsole(\"Error\"), logConsole(\"Warning\"), logConsole(\"Info\"), logConsole(\"Trace\"));\n    }\n    /** merge the supplied metadata with all static metadata into one object */\n    static getMetaData(metaData) {\n        const metaObj = {};\n        for (const meta of Logger.staticMetaData) {\n            const val = BentleyError.getMetaData(meta[1]);\n            if (val)\n                Object.assign(metaObj, val);\n        }\n        Object.assign(metaObj, BentleyError.getMetaData(metaData)); // do this last so user supplied values take precedence\n        return metaObj;\n    }\n    /** stringify the metadata for a log message by merging the supplied metadata with all static metadata into one object that is then `JSON.stringify`ed. */\n    static stringifyMetaData(metaData) {\n        const metaObj = this.getMetaData(metaData);\n        return Object.keys(metaObj).length > 0 ? JSON.stringify(metaObj) : \"\";\n    }\n    /** Set the least severe level at which messages should be displayed by default. Call setLevel to override this default setting for specific categories. */\n    static setLevelDefault(minLevel) {\n        this._minLevel = minLevel;\n        this.logLevelChangedFn?.();\n    }\n    /** Set the minimum logging level for the specified category. The minimum level is least severe level at which messages in the\n     * specified category should be displayed.\n     */\n    static setLevel(category, minLevel) {\n        Logger._categoryFilter.set(category, minLevel);\n        this.logLevelChangedFn?.();\n    }\n    /** Interpret a string as the name of a LogLevel */\n    static parseLogLevel(str) {\n        switch (str.toUpperCase()) {\n            case \"EXCEPTION\": return LogLevel.Error;\n            case \"FATAL\": return LogLevel.Error;\n            case \"ERROR\": return LogLevel.Error;\n            case \"WARNING\": return LogLevel.Warning;\n            case \"INFO\": return LogLevel.Info;\n            case \"TRACE\": return LogLevel.Trace;\n            case \"DEBUG\": return LogLevel.Trace;\n        }\n        return LogLevel.None;\n    }\n    /** Set the log level for multiple categories at once. Also see [[validateProps]] */\n    static configureLevels(cfg) {\n        Logger.validateProps(cfg);\n        if (cfg.defaultLevel !== undefined) {\n            this.setLevelDefault(Logger.parseLogLevel(cfg.defaultLevel));\n        }\n        if (cfg.categoryLevels !== undefined) {\n            for (const cl of cfg.categoryLevels) {\n                this.setLevel(cl.category, Logger.parseLogLevel(cl.logLevel));\n            }\n        }\n    }\n    static isLogLevel(v) {\n        return LogLevel.hasOwnProperty(v);\n    }\n    /** Check that the specified object is a valid LoggerLevelsConfig. This is useful when reading a config from a .json file. */\n    static validateProps(config) {\n        const validProps = [\"defaultLevel\", \"categoryLevels\"];\n        for (const prop of Object.keys(config)) {\n            if (!validProps.includes(prop))\n                throw new BentleyError(IModelStatus.BadArg, `LoggerLevelsConfig - unrecognized property: ${prop}`);\n            if (prop === \"defaultLevel\") {\n                if (!Logger.isLogLevel(config.defaultLevel))\n                    throw new BentleyError(IModelStatus.BadArg, `LoggerLevelsConfig.defaultLevel must be a LogLevel. Invalid value: ${JSON.stringify(config.defaultLevel)}`);\n            }\n            else if (prop === \"categoryLevels\") {\n                const value = config[prop];\n                if (!Array.isArray(value))\n                    throw new BentleyError(IModelStatus.BadArg, `LoggerLevelsConfig.categoryLevels must be an array. Invalid value: ${JSON.stringify(value)}`);\n                for (const item of config[prop]) {\n                    if (!item.hasOwnProperty(\"category\") || !item.hasOwnProperty(\"logLevel\"))\n                        throw new BentleyError(IModelStatus.BadArg, `LoggerLevelsConfig.categoryLevels - each item must be a LoggerCategoryAndLevel {category: logLevel:}. Invalid value: ${JSON.stringify(item)}`);\n                    if (!Logger.isLogLevel(item.logLevel))\n                        throw new BentleyError(IModelStatus.BadArg, `LoggerLevelsConfig.categoryLevels - each item's logLevel property must be a LogLevel. Invalid value: ${JSON.stringify(item.logLevel)}`);\n                }\n            }\n        }\n    }\n    /** Get the minimum logging level for the specified category. */\n    static getLevel(category) {\n        // Prefer the level set for this category specifically\n        const minLevelForThisCategory = Logger._categoryFilter.get(category);\n        if (minLevelForThisCategory !== undefined)\n            return minLevelForThisCategory;\n        // Fall back on the level set for the parent of this category.\n        const parent = category.lastIndexOf(\".\");\n        if (parent !== -1)\n            return Logger.getLevel(category.slice(0, parent));\n        // Fall back on the default level.\n        return Logger._minLevel;\n    }\n    /** Turns off the least severe level at which messages should be displayed by default.\n     * This turns off logging for all messages for which no category minimum level is defined.\n     */\n    static turnOffLevelDefault() {\n        Logger._minLevel = undefined;\n    }\n    /** Turns off all category level filters previously defined with [[Logger.setLevel]].\n     */\n    static turnOffCategories() {\n        Logger._categoryFilter.clear();\n    }\n    /** Check if messages in the specified category should be displayed at this level of severity. */\n    static isEnabled(category, level) {\n        const minLevel = Logger.getLevel(category);\n        return (minLevel !== undefined) && (level >= minLevel);\n    }\n    /** Log the specified message to the **error** stream.\n     * @param category  The category of the message.\n     * @param message  The message.\n     * @param metaData  Optional data for the message\n     */\n    static logError(category, message, metaData) {\n        if (Logger._logError && Logger.isEnabled(category, LogLevel.Error))\n            Logger._logError(category, message, metaData);\n    }\n    static getExceptionMessage(err) {\n        const stack = Logger.logExceptionCallstacks ? `\\n${BentleyError.getErrorStack(err)}` : \"\";\n        return BentleyError.getErrorMessage(err) + stack;\n    }\n    /** Log the specified exception. The special \"ExceptionType\" property will be added as metadata,\n     * in addition to any other metadata that may be supplied by the caller, unless the\n     * metadata supplied by the caller already includes this property.\n     * @param category  The category of the message.\n     * @param err  The exception object.\n     * @param log The logger output function to use - defaults to Logger.logError\n     * @param metaData  Optional data for the message\n     */\n    static logException(category, err, log = (_category, message) => Logger.logError(_category, message)) {\n        log(category, Logger.getExceptionMessage(err), () => {\n            return { ...BentleyError.getErrorMetadata(err), exceptionType: err.constructor.name };\n        });\n    }\n    /** Log the specified message to the **warning** stream.\n     * @param category  The category of the message.\n     * @param message  The message.\n     * @param metaData  Optional data for the message\n     */\n    static logWarning(category, message, metaData) {\n        if (Logger._logWarning && Logger.isEnabled(category, LogLevel.Warning))\n            Logger._logWarning(category, message, metaData);\n    }\n    /** Log the specified message to the **info** stream.\n     * @param category  The category of the message.\n     * @param message  The message.\n     * @param metaData  Optional data for the message\n     */\n    static logInfo(category, message, metaData) {\n        if (Logger._logInfo && Logger.isEnabled(category, LogLevel.Info))\n            Logger._logInfo(category, message, metaData);\n    }\n    /** Log the specified message to the **trace** stream.\n     * @param category  The category of the message.\n     * @param message  The message.\n     * @param metaData  Optional data for the message\n     */\n    static logTrace(category, message, metaData) {\n        if (Logger._logTrace && Logger.isEnabled(category, LogLevel.Trace))\n            Logger._logTrace(category, message, metaData);\n    }\n}\nLogger._categoryFilter = new Map(); // do not change the name of this member, it is referenced directly from node addon\nLogger._minLevel = undefined; // do not change the name of this member, it is referenced directly from node addon\n/** Should the call stack be included when an exception is logged?  */\nLogger.logExceptionCallstacks = false;\n/** All static metadata is combined with per-call metadata and stringified in every log message.\n * Static metadata can either be an object or a function that returns an object.\n * Use a key to identify entries in the map so the can be removed individually.\n * @internal */\nLogger.staticMetaData = new Map();\nexport { Logger };\n/** Simple performance diagnostics utility.\n * It measures the time from construction to disposal. On disposal it logs the routine name along with\n * the duration in milliseconds.\n * It also logs the routine name at construction time so that nested calls can be disambiguated.\n *\n * The timings are logged using the log category **Performance** and log severity [[LogLevel.INFO]].\n * Enable those, if you want to capture timings.\n * @public\n */\nclass PerfLogger {\n    constructor(operation, metaData) {\n        this._operation = operation;\n        this._metaData = metaData;\n        if (!Logger.isEnabled(BentleyLoggerCategory.Performance, PerfLogger._severity)) {\n            this._startTimeStamp = 0;\n            return;\n        }\n        Logger.logInfo(BentleyLoggerCategory.Performance, `${this._operation},START`, this._metaData);\n        this._startTimeStamp = new Date().getTime(); // take timestamp\n    }\n    logMessage() {\n        const endTimeStamp = new Date().getTime();\n        if (!Logger.isEnabled(BentleyLoggerCategory.Performance, PerfLogger._severity))\n            return;\n        Logger.logInfo(BentleyLoggerCategory.Performance, `${this._operation},END`, () => {\n            const mdata = this._metaData ? BentleyError.getMetaData(this._metaData) : {};\n            return {\n                ...mdata, TimeElapsed: endTimeStamp - this._startTimeStamp, // eslint-disable-line @typescript-eslint/naming-convention\n            };\n        });\n    }\n    dispose() {\n        this.logMessage();\n    }\n}\nPerfLogger._severity = LogLevel.Info;\nexport { PerfLogger };\n//# sourceMappingURL=Logger.js.map",
      "start": 1693508120317,
      "end": 1693508120460,
      "sourcemaps": null
    }
  ]
}
