{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/common/imdl/ParseImdlDocument.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tiles\n */\nimport { assert, ByteStream, JsonUtils, utf8ToString } from \"@itwin/core-bentley\";\nimport { Point3d, Range2d, Range3d } from \"@itwin/core-geometry\";\nimport { BatchType, ColorDef, FeatureTableHeader, FillFlags, GltfV2ChunkTypes, GltfVersions, Gradient, ImdlFlags, ImdlHeader, LinePixels, MultiModelPackedFeatureTable, PackedFeatureTable, PolylineTypeFlags, QParams2d, QParams3d, RenderMaterial, RenderTexture, RgbColor, TextureMapping, TileFormat, TileHeader, TileReadStatus, } from \"@itwin/core-common\";\nimport { MeshPrimitiveType } from \"../render/primitives/MeshPrimitive\";\nimport { isValidSurfaceType } from \"../render/primitives/SurfaceParams\";\nimport { DisplayParams } from \"../render/primitives/DisplayParams\";\nimport { AuxChannelTable } from \"../render/primitives/AuxChannelTable\";\nimport { splitMeshParams, splitPointStringParams, splitPolylineParams } from \"../render/primitives/VertexTableSplitter\";\nimport { AnimationNodeId } from \"../render/AnimationNodeId\";\nimport { VertexIndices } from \"../render/primitives/VertexIndices\";\nimport { indexedEdgeParamsFromCompactEdges } from \"./CompactEdges\";\n/** Header preceding \"glTF\" data in iMdl tile. */\nclass GltfHeader extends TileHeader {\n    get isValid() { return TileFormat.Gltf === this.format; }\n    constructor(stream) {\n        super(stream);\n        this.scenePosition = 0;\n        this.sceneStrLength = 0;\n        this.binaryPosition = 0;\n        this.gltfLength = stream.readUint32();\n        this.sceneStrLength = stream.readUint32();\n        const value5 = stream.readUint32();\n        // Early versions of the reality data tile publisher incorrectly put version 2 into header - handle these old tiles\n        // validating the chunk type.\n        if (this.version === GltfVersions.Version2 && value5 === GltfVersions.Gltf1SceneFormat)\n            this.version = GltfVersions.Version1;\n        if (this.version === GltfVersions.Version1) {\n            const gltfSceneFormat = value5;\n            if (GltfVersions.Gltf1SceneFormat !== gltfSceneFormat) {\n                this.invalidate();\n                return;\n            }\n            this.scenePosition = stream.curPos;\n            this.binaryPosition = stream.curPos + this.sceneStrLength;\n        }\n        else if (this.version === GltfVersions.Version2) {\n            const sceneChunkType = value5;\n            this.scenePosition = stream.curPos;\n            stream.curPos = stream.curPos + this.sceneStrLength;\n            const binaryLength = stream.readUint32();\n            const binaryChunkType = stream.readUint32();\n            if (GltfV2ChunkTypes.JSON !== sceneChunkType || GltfV2ChunkTypes.Binary !== binaryChunkType || 0 === binaryLength) {\n                this.invalidate();\n                return;\n            }\n            this.binaryPosition = stream.curPos;\n        }\n        else {\n            this.invalidate();\n        }\n    }\n}\nconst nodeIdRegex = /Node_(.*)/;\nfunction extractNodeId(nodeName) {\n    const match = nodeName.match(nodeIdRegex);\n    assert(!!match && match.length === 2);\n    if (!match || match.length !== 2)\n        return 0;\n    const nodeId = Number.parseInt(match[1], 10);\n    assert(!Number.isNaN(nodeId));\n    return Number.isNaN(nodeId) ? 0 : nodeId;\n}\nclass Texture extends RenderTexture {\n    constructor(type) {\n        super(type);\n    }\n    dispose() { }\n    get bytesUsed() { return 0; }\n}\nclass NamedTexture extends Texture {\n    constructor(_name, type) {\n        super(type);\n        this._name = _name;\n    }\n    toImdl() {\n        return this._name;\n    }\n}\nclass GradientTexture extends Texture {\n    constructor(_gradient) {\n        super(RenderTexture.Type.Normal);\n        this._gradient = _gradient;\n    }\n    toImdl() {\n        return this._gradient;\n    }\n}\nclass Material extends RenderMaterial {\n    toImdl() {\n        const material = this.key ?? this.materialParams;\n        return { isAtlas: false, material };\n    }\n    // eslint-disable-next-line deprecation/deprecation\n    constructor(params, imdl) {\n        super(params);\n        this.materialParams = imdl ?? {\n            alpha: params.alpha,\n            diffuse: {\n                color: params.diffuseColor?.toJSON(),\n                weight: params.diffuse,\n            },\n            specular: {\n                color: params.specularColor?.toJSON(),\n                weight: params.specular,\n                exponent: params.specularExponent,\n            },\n        };\n    }\n    static create(args) {\n        // eslint-disable-next-line deprecation/deprecation\n        const params = new RenderMaterial.Params();\n        params.alpha = args.alpha;\n        if (args.diffuse) {\n            if (undefined !== args.diffuse.weight)\n                params.diffuse = args.diffuse?.weight;\n            if (args.diffuse?.color)\n                params.diffuseColor = args.diffuse.color instanceof ColorDef ? args.diffuse.color : RgbColor.fromJSON(args.diffuse.color).toColorDef();\n        }\n        if (args.specular) {\n            if (undefined !== args.specular.weight)\n                params.specular = args.specular.weight;\n            if (undefined !== args.specular.exponent)\n                params.specularExponent = args.specular.exponent;\n            if (args.specular.color)\n                params.specularColor = args.specular.color instanceof ColorDef ? args.specular.color : RgbColor.fromJSON(args.specular.color).toColorDef();\n        }\n        return new Material(params);\n    }\n}\n/** @internal */\nexport function toVertexTable(imdl) {\n    return {\n        ...imdl,\n        uniformColor: undefined !== imdl.uniformColor ? ColorDef.fromJSON(imdl.uniformColor) : undefined,\n        qparams: QParams3d.fromJSON(imdl.qparams),\n        uvParams: imdl.uvParams ? QParams2d.fromJSON(imdl.uvParams) : undefined,\n    };\n}\nfunction fromVertexTable(table) {\n    return {\n        ...table,\n        uniformColor: table.uniformColor?.toJSON(),\n        qparams: table.qparams.toJSON(),\n        uvParams: table.uvParams?.toJSON(),\n    };\n}\n/** @internal */\nexport function edgeParamsFromImdl(imdl) {\n    return {\n        ...imdl,\n        segments: imdl.segments ? {\n            ...imdl.segments,\n            indices: new VertexIndices(imdl.segments.indices),\n        } : undefined,\n        silhouettes: imdl.silhouettes ? {\n            ...imdl.silhouettes,\n            indices: new VertexIndices(imdl.silhouettes.indices),\n        } : undefined,\n        polylines: imdl.polylines ? {\n            ...imdl.polylines,\n            indices: new VertexIndices(imdl.polylines.indices),\n            prevIndices: new VertexIndices(imdl.polylines.prevIndices),\n        } : undefined,\n        indexed: imdl.indexed ? {\n            indices: new VertexIndices(imdl.indexed.indices),\n            edges: imdl.indexed.edges,\n        } : undefined,\n    };\n}\nfunction edgeParamsToImdl(params) {\n    return {\n        ...params,\n        segments: params.segments ? {\n            ...params.segments,\n            indices: params.segments.indices.data,\n        } : undefined,\n        silhouettes: params.silhouettes ? {\n            ...params.silhouettes,\n            indices: params.silhouettes.indices.data,\n        } : undefined,\n        polylines: params.polylines ? {\n            ...params.polylines,\n            indices: params.polylines.indices.data,\n            prevIndices: params.polylines.prevIndices.data,\n        } : undefined,\n        indexed: params.indexed ? {\n            indices: params.indexed.indices.data,\n            edges: params.indexed.edges,\n        } : undefined,\n    };\n}\nclass Parser {\n    constructor(doc, binaryData, options, featureTableInfo, stream) {\n        this._patterns = new Map();\n        this._document = doc;\n        this._binaryData = binaryData;\n        this._options = options;\n        this._featureTableInfo = featureTableInfo;\n        this._stream = stream;\n        this._timeline = options.timeline;\n    }\n    parse() {\n        const featureTable = this.parseFeatureTable();\n        if (!featureTable)\n            return TileReadStatus.InvalidFeatureTable;\n        const rtcCenter = this._document.rtcCenter ? {\n            x: this._document.rtcCenter[0] ?? 0,\n            y: this._document.rtcCenter[1] ?? 0,\n            z: this._document.rtcCenter[2] ?? 0,\n        } : undefined;\n        const nodes = this.parseNodes(featureTable);\n        return {\n            featureTable,\n            nodes,\n            rtcCenter,\n            binaryData: this._binaryData,\n            json: this._document,\n            patterns: this._patterns,\n        };\n    }\n    parseFeatureTable() {\n        this._stream.curPos = this._featureTableInfo.startPos;\n        const header = FeatureTableHeader.readFrom(this._stream);\n        if (!header || 0 !== header.length % 4)\n            return undefined;\n        // NB: We make a copy of the sub-array because we don't want to pin the entire data array in memory.\n        const numUint32s = (header.length - FeatureTableHeader.sizeInBytes) / 4;\n        const packedFeatureArray = new Uint32Array(this._stream.nextUint32s(numUint32s));\n        if (this._stream.isPastTheEnd)\n            return undefined;\n        let featureTable;\n        if (this._featureTableInfo.multiModel) {\n            featureTable = {\n                multiModel: true,\n                data: packedFeatureArray,\n                numFeatures: header.count,\n                numSubCategories: header.numSubCategories,\n            };\n        }\n        else {\n            let animNodesArray;\n            const animationNodes = this._document.animationNodes;\n            if (undefined !== animationNodes) {\n                const bytesPerId = JsonUtils.asInt(animationNodes.bytesPerId);\n                const bufferViewId = JsonUtils.asString(animationNodes.bufferView);\n                const bufferViewJson = this._document.bufferViews[bufferViewId];\n                if (undefined !== bufferViewJson) {\n                    const byteOffset = JsonUtils.asInt(bufferViewJson.byteOffset);\n                    const byteLength = JsonUtils.asInt(bufferViewJson.byteLength);\n                    const bytes = this._binaryData.subarray(byteOffset, byteOffset + byteLength);\n                    switch (bytesPerId) {\n                        case 1:\n                            animNodesArray = new Uint8Array(bytes);\n                            break;\n                        case 2:\n                            // NB: A *copy* of the subarray.\n                            animNodesArray = Uint16Array.from(new Uint16Array(bytes.buffer, bytes.byteOffset, bytes.byteLength / 2));\n                            break;\n                        case 4:\n                            // NB: A *copy* of the subarray.\n                            animNodesArray = Uint32Array.from(new Uint32Array(bytes.buffer, bytes.byteOffset, bytes.byteLength / 4));\n                            break;\n                    }\n                }\n            }\n            featureTable = {\n                multiModel: false,\n                data: packedFeatureArray,\n                numFeatures: header.count,\n                animationNodeIds: animNodesArray,\n            };\n        }\n        this._stream.curPos = this._featureTableInfo.startPos + header.length;\n        return featureTable;\n    }\n    parseNodes(featureTable) {\n        const nodes = [];\n        const docNodes = this._document.nodes;\n        const docMeshes = this._document.meshes;\n        if (undefined === docNodes.Node_Root) {\n            // A veeeery early version of the tile format (prior to introduction of schedule animation support) just supplied a flat list of meshes.\n            // We shall never encounter such tiles again.\n            return nodes;\n        }\n        for (const nodeKey of Object.keys(docNodes)) {\n            const docNode = this._document.nodes[nodeKey];\n            assert(undefined !== docNode); // we're iterating the keys...\n            const docMesh = docMeshes[docNode];\n            const docPrimitives = docMesh?.primitives;\n            if (!docPrimitives)\n                continue;\n            const layerId = docMesh.layer;\n            if (\"Node_Root\" === nodeKey) {\n                if (this._timeline) {\n                    // Split up the root node into transform nodes.\n                    this.parseAnimationBranches(nodes, docMesh, featureTable, this._timeline);\n                }\n                else if (this._options.createUntransformedRootNode) {\n                    // If transform nodes exist in the tile tree, then we need to create a branch for the root node so that elements not associated with\n                    // any node in the schedule script can be grouped together.\n                    nodes.push({\n                        animationNodeId: AnimationNodeId.Untransformed,\n                        primitives: this.parseNodePrimitives(docPrimitives),\n                    });\n                }\n                else {\n                    nodes.push({ primitives: this.parseNodePrimitives(docPrimitives) });\n                }\n            }\n            else if (undefined === layerId) {\n                nodes.push({\n                    animationNodeId: extractNodeId(nodeKey),\n                    animationId: `${this._options.batchModelId}_${nodeKey}`,\n                    primitives: this.parseNodePrimitives(docPrimitives),\n                });\n            }\n            else {\n                nodes.push({\n                    layerId,\n                    primitives: this.parseNodePrimitives(docPrimitives),\n                });\n            }\n        }\n        return nodes;\n    }\n    parseAnimationBranches(output, docMesh, imdlFeatureTable, timeline) {\n        const docPrimitives = docMesh.primitives;\n        if (!docPrimitives)\n            return;\n        const nodesById = new Map();\n        const getNode = (nodeId) => {\n            let node = nodesById.get(nodeId);\n            if (!node) {\n                node = {\n                    animationNodeId: nodeId,\n                    animationId: `${this._options.batchModelId}_Node_${nodeId}`,\n                    primitives: [],\n                };\n                nodesById.set(nodeId, node);\n                output.push(node);\n            }\n            return node;\n        };\n        // NB: The BatchType is irrelevant - just use Primary.\n        assert(undefined === imdlFeatureTable.animationNodeIds);\n        const featureTable = convertFeatureTable(imdlFeatureTable, this._options.batchModelId);\n        featureTable.populateAnimationNodeIds((feature) => timeline.getBatchIdForFeature(feature), timeline.maxBatchId);\n        imdlFeatureTable.animationNodeIds = featureTable.animationNodeIds;\n        const discreteNodeIds = timeline.discreteBatchIds;\n        const computeNodeId = (featureIndex) => {\n            const nodeId = featureTable.getAnimationNodeId(featureIndex);\n            return 0 !== nodeId && discreteNodeIds.has(nodeId) ? nodeId : 0;\n        };\n        const splitArgs = {\n            maxDimension: this._options.maxVertexTableSize,\n            computeNodeId,\n            featureTable,\n        };\n        const convertMaterial = (imdl) => {\n            if (!imdl)\n                return undefined;\n            else if (imdl.isAtlas)\n                return imdl;\n            const material = (typeof imdl.material === \"string\") ? this.materialFromJson(imdl.material) : Material.create(toMaterialParams(imdl.material));\n            return material ? { isAtlas: false, material } : undefined;\n        };\n        for (const docPrimitive of docPrimitives) {\n            const primitive = this.parseNodePrimitive(docPrimitive);\n            if (!primitive)\n                continue;\n            switch (primitive.type) {\n                case \"pattern\":\n                    // ###TODO animated area patterns\n                    getNode(AnimationNodeId.Untransformed).primitives.push(primitive);\n                    break;\n                case \"mesh\": {\n                    const mesh = primitive.params;\n                    const texMap = mesh.surface.textureMapping;\n                    const params = {\n                        vertices: toVertexTable(primitive.params.vertices),\n                        surface: {\n                            ...primitive.params.surface,\n                            indices: new VertexIndices(primitive.params.surface.indices),\n                            material: convertMaterial(mesh.surface.material),\n                            textureMapping: texMap ? {\n                                alwaysDisplayed: texMap.alwaysDisplayed,\n                                // The texture type doesn't actually matter here.\n                                texture: typeof texMap.texture === \"string\" ? new NamedTexture(texMap.texture, RenderTexture.Type.Normal) : new GradientTexture(texMap.texture),\n                            } : undefined,\n                        },\n                        edges: primitive.params.edges ? edgeParamsFromImdl(primitive.params.edges) : undefined,\n                        isPlanar: primitive.params.isPlanar,\n                        auxChannels: primitive.params.auxChannels ? AuxChannelTable.fromJSON(primitive.params.auxChannels) : undefined,\n                    };\n                    const split = splitMeshParams({\n                        ...splitArgs,\n                        params,\n                        createMaterial: (args) => Material.create(args),\n                    });\n                    for (const [nodeId, p] of split) {\n                        let material;\n                        if (p.surface.material) {\n                            if (p.surface.material.isAtlas) {\n                                material = p.surface.material;\n                            }\n                            else {\n                                assert(p.surface.material.material instanceof Material);\n                                material = p.surface.material.material.toImdl();\n                            }\n                        }\n                        assert(p.surface.textureMapping === undefined || p.surface.textureMapping.texture instanceof Texture);\n                        getNode(nodeId).primitives.push({\n                            type: \"mesh\",\n                            params: {\n                                vertices: fromVertexTable(p.vertices),\n                                surface: {\n                                    ...p.surface,\n                                    indices: p.surface.indices.data,\n                                    material,\n                                    textureMapping: p.surface.textureMapping?.texture instanceof Texture ? {\n                                        texture: p.surface.textureMapping.texture.toImdl(),\n                                        alwaysDisplayed: p.surface.textureMapping.alwaysDisplayed,\n                                    } : undefined,\n                                },\n                                edges: p.edges ? edgeParamsToImdl(p.edges) : undefined,\n                                isPlanar: p.isPlanar,\n                                auxChannels: p.auxChannels?.toJSON(),\n                            },\n                        });\n                    }\n                    break;\n                }\n                case \"point\": {\n                    const params = {\n                        vertices: toVertexTable(primitive.params.vertices),\n                        indices: new VertexIndices(primitive.params.indices),\n                        weight: primitive.params.weight,\n                    };\n                    const split = splitPointStringParams({ ...splitArgs, params });\n                    for (const [nodeId, p] of split) {\n                        getNode(nodeId).primitives.push({\n                            type: \"point\",\n                            params: {\n                                vertices: fromVertexTable(p.vertices),\n                                indices: p.indices.data,\n                                weight: p.weight,\n                            },\n                        });\n                    }\n                    break;\n                }\n                case \"polyline\": {\n                    const params = {\n                        ...primitive.params,\n                        vertices: toVertexTable(primitive.params.vertices),\n                        polyline: {\n                            indices: new VertexIndices(primitive.params.polyline.indices),\n                            prevIndices: new VertexIndices(primitive.params.polyline.prevIndices),\n                            nextIndicesAndParams: primitive.params.polyline.nextIndicesAndParams,\n                        },\n                    };\n                    const split = splitPolylineParams({ ...splitArgs, params });\n                    for (const [nodeId, p] of split) {\n                        getNode(nodeId).primitives.push({\n                            type: \"polyline\",\n                            params: {\n                                ...p,\n                                vertices: fromVertexTable(p.vertices),\n                                polyline: {\n                                    indices: p.polyline.indices.data,\n                                    prevIndices: p.polyline.prevIndices.data,\n                                    nextIndicesAndParams: p.polyline.nextIndicesAndParams,\n                                },\n                            },\n                        });\n                    }\n                    break;\n                }\n            }\n        }\n    }\n    parseTesselatedPolyline(json) {\n        const indices = this.findBuffer(json.indices);\n        const prevIndices = this.findBuffer(json.prevIndices);\n        const nextIndicesAndParams = this.findBuffer(json.nextIndicesAndParams);\n        return indices && prevIndices && nextIndicesAndParams ? { indices, prevIndices, nextIndicesAndParams } : undefined;\n    }\n    parseSegmentEdges(imdl) {\n        const indices = this.findBuffer(imdl.indices);\n        const endPointAndQuadIndices = this.findBuffer(imdl.endPointAndQuadIndices);\n        return indices && endPointAndQuadIndices ? { indices, endPointAndQuadIndices } : undefined;\n    }\n    parseSilhouetteEdges(imdl) {\n        const segments = this.parseSegmentEdges(imdl);\n        const normalPairs = this.findBuffer(imdl.normalPairs);\n        return segments && normalPairs ? { ...segments, normalPairs } : undefined;\n    }\n    parseIndexedEdges(imdl) {\n        const indices = this.findBuffer(imdl.indices);\n        const edgeTable = this.findBuffer(imdl.edges);\n        if (!indices || !edgeTable)\n            return undefined;\n        return {\n            indices,\n            edges: {\n                data: edgeTable,\n                width: imdl.width,\n                height: imdl.height,\n                silhouettePadding: imdl.silhouettePadding,\n                numSegments: imdl.numSegments,\n            },\n        };\n    }\n    parseCompactEdges(imdl, vertexIndices) {\n        const visibility = this.findBuffer(imdl.visibility);\n        if (!visibility)\n            return undefined;\n        const normals = undefined !== imdl.normalPairs ? this.findBuffer(imdl.normalPairs) : undefined;\n        return indexedEdgeParamsFromCompactEdges({\n            numVisibleEdges: imdl.numVisible,\n            visibility,\n            vertexIndices,\n            normalPairs: normals ? new Uint32Array(normals.buffer, normals.byteOffset, normals.byteLength / 4) : undefined,\n            maxEdgeTableDimension: this._options.maxVertexTableSize,\n        });\n    }\n    parseEdges(imdl, displayParams, indices) {\n        if (!imdl)\n            return undefined;\n        const segments = imdl.segments ? this.parseSegmentEdges(imdl.segments) : undefined;\n        const silhouettes = imdl.silhouettes ? this.parseSilhouetteEdges(imdl.silhouettes) : undefined;\n        const polylines = imdl.polylines ? this.parseTesselatedPolyline(imdl.polylines) : undefined;\n        let indexed = imdl.indexed ? this.parseIndexedEdges(imdl.indexed) : undefined;\n        if (!indexed && imdl.compact)\n            indexed = this.parseCompactEdges(imdl.compact, new VertexIndices(indices));\n        if (!segments && !silhouettes && !indexed && !polylines)\n            return undefined;\n        return {\n            segments,\n            silhouettes,\n            polylines,\n            indexed,\n            weight: displayParams.width,\n            linePixels: displayParams.linePixels,\n        };\n    }\n    getPattern(name) {\n        let primitives = this._patterns.get(name);\n        if (!primitives) {\n            const symbol = this._document.patternSymbols[name];\n            primitives = symbol ? this.parsePrimitives(symbol.primitives) : [];\n            this._patterns.set(name, primitives);\n        }\n        return primitives.length > 0 ? primitives : undefined;\n    }\n    parseAreaPattern(json) {\n        const primitives = this.getPattern(json.symbolName);\n        if (!primitives || primitives.length === 0)\n            return undefined;\n        const xyOffsets = this.findBuffer(json.xyOffsets);\n        if (!xyOffsets)\n            return undefined;\n        return {\n            type: \"pattern\",\n            params: {\n                ...json,\n                xyOffsets: new Float32Array(xyOffsets.buffer, xyOffsets.byteOffset, xyOffsets.byteLength / 4),\n            },\n        };\n    }\n    parseNodePrimitives(docPrimitives) {\n        const primitives = [];\n        for (const docPrimitive of docPrimitives) {\n            const primitive = this.parseNodePrimitive(docPrimitive);\n            if (primitive)\n                primitives.push(primitive);\n        }\n        return primitives;\n    }\n    parseNodePrimitive(docPrimitive) {\n        return docPrimitive.type === \"areaPattern\" ? this.parseAreaPattern(docPrimitive) : this.parsePrimitive(docPrimitive);\n    }\n    parsePrimitives(docPrimitives) {\n        const primitives = [];\n        for (const docPrimitive of docPrimitives) {\n            const primitive = this.parsePrimitive(docPrimitive);\n            if (primitive)\n                primitives.push(primitive);\n        }\n        return primitives;\n    }\n    parsePrimitive(docPrimitive) {\n        let modifier = this.parseInstances(docPrimitive);\n        if (!modifier && docPrimitive.viewIndependentOrigin) {\n            const origin = Point3d.fromJSON(docPrimitive.viewIndependentOrigin);\n            modifier = {\n                type: \"viewIndependentOrigin\",\n                origin: { x: origin.x, y: origin.y, z: origin.z },\n            };\n        }\n        const materialName = docPrimitive.material ?? \"\";\n        const dpMaterial = materialName.length ? JsonUtils.asObject(this._document.materials[materialName]) : undefined;\n        const displayParams = dpMaterial ? this.parseDisplayParams(dpMaterial) : undefined;\n        if (!displayParams)\n            return undefined;\n        const vertices = this.parseVertexTable(docPrimitive);\n        if (!vertices)\n            return undefined;\n        let primitive;\n        const isPlanar = !this._options.is3d || JsonUtils.asBool(docPrimitive.isPlanar);\n        switch (docPrimitive.type) {\n            case MeshPrimitiveType.Mesh: {\n                const surface = this.parseSurface(docPrimitive, displayParams);\n                if (surface) {\n                    primitive = {\n                        type: \"mesh\",\n                        params: {\n                            vertices,\n                            surface,\n                            isPlanar,\n                            auxChannels: this.parseAuxChannelTable(docPrimitive),\n                            edges: this.parseEdges(docPrimitive.edges, displayParams, surface.indices),\n                        },\n                    };\n                }\n                break;\n            }\n            case MeshPrimitiveType.Polyline: {\n                const polyline = this.parseTesselatedPolyline(docPrimitive);\n                if (polyline) {\n                    let type = PolylineTypeFlags.Normal;\n                    if (DisplayParams.RegionEdgeType.Outline === displayParams.regionEdgeType)\n                        type = (!displayParams.gradient || displayParams.gradient.isOutlined) ? PolylineTypeFlags.Edge : PolylineTypeFlags.Outline;\n                    primitive = {\n                        type: \"polyline\",\n                        params: {\n                            vertices,\n                            polyline,\n                            isPlanar,\n                            type,\n                            weight: displayParams.width,\n                            linePixels: displayParams.linePixels,\n                        },\n                    };\n                }\n                break;\n            }\n            case MeshPrimitiveType.Point: {\n                const indices = this.findBuffer(docPrimitive.indices);\n                const weight = displayParams.width;\n                if (indices) {\n                    primitive = {\n                        type: \"point\",\n                        params: { vertices, indices, weight },\n                    };\n                }\n                break;\n            }\n        }\n        if (primitive)\n            primitive.modifier = modifier;\n        return primitive;\n    }\n    parseSurface(mesh, displayParams) {\n        const surf = mesh.surface;\n        if (!surf)\n            return undefined;\n        const indices = this.findBuffer(surf.indices);\n        if (!indices)\n            return undefined;\n        const type = surf.type;\n        if (!isValidSurfaceType(type))\n            return undefined;\n        const texture = displayParams.textureMapping?.texture;\n        let material;\n        const atlas = mesh.vertices.materialAtlas;\n        const numColors = mesh.vertices.numColors;\n        if (atlas && undefined !== numColors) {\n            material = {\n                isAtlas: true,\n                hasTranslucency: JsonUtils.asBool(atlas.hasTranslucency),\n                overridesAlpha: JsonUtils.asBool(atlas.overridesAlpha, false),\n                vertexTableOffset: JsonUtils.asInt(numColors),\n                numMaterials: JsonUtils.asInt(atlas.numMaterials),\n            };\n        }\n        else if (displayParams.material) {\n            assert(displayParams.material instanceof Material);\n            material = displayParams.material.toImdl();\n        }\n        let textureMapping;\n        if (texture) {\n            assert(texture instanceof Texture);\n            textureMapping = {\n                texture: texture.toImdl(),\n                alwaysDisplayed: JsonUtils.asBool(surf.alwaysDisplayTexture),\n            };\n        }\n        return {\n            type,\n            indices,\n            fillFlags: displayParams.fillFlags,\n            hasBakedLighting: false,\n            material,\n            textureMapping,\n        };\n    }\n    parseAuxChannelTable(primitive) {\n        const json = primitive.auxChannels;\n        if (undefined === json)\n            return undefined;\n        const bytes = this.findBuffer(JsonUtils.asString(json.bufferView));\n        if (undefined === bytes)\n            return undefined;\n        return {\n            data: bytes,\n            width: json.width,\n            height: json.height,\n            count: json.count,\n            numBytesPerVertex: json.numBytesPerVertex,\n            displacements: json.displacements,\n            normals: json.normals,\n            params: json.params,\n        };\n    }\n    parseVertexTable(primitive) {\n        const json = primitive.vertices;\n        if (!json)\n            return undefined;\n        const bytes = this.findBuffer(JsonUtils.asString(json.bufferView));\n        if (!bytes)\n            return undefined;\n        const uniformFeatureID = undefined !== json.featureID ? JsonUtils.asInt(json.featureID) : undefined;\n        const rangeMin = JsonUtils.asArray(json.params.decodedMin);\n        const rangeMax = JsonUtils.asArray(json.params.decodedMax);\n        if (undefined === rangeMin || undefined === rangeMax)\n            return undefined;\n        const qparams = QParams3d.fromRange(Range3d.create(Point3d.create(rangeMin[0], rangeMin[1], rangeMin[2]), Point3d.create(rangeMax[0], rangeMax[1], rangeMax[2])));\n        const uniformColor = undefined !== json.uniformColor ? ColorDef.fromJSON(json.uniformColor) : undefined;\n        let uvParams;\n        if (MeshPrimitiveType.Mesh === primitive.type && primitive.surface && primitive.surface.uvParams) {\n            const uvMin = primitive.surface.uvParams.decodedMin;\n            const uvMax = primitive.surface.uvParams.decodedMax;\n            const uvRange = new Range2d(uvMin[0], uvMin[1], uvMax[0], uvMax[1]);\n            uvParams = QParams2d.fromRange(uvRange);\n        }\n        return {\n            data: bytes,\n            usesUnquantizedPositions: true === json.usesUnquantizedPositions,\n            qparams: qparams.toJSON(),\n            width: json.width,\n            height: json.height,\n            hasTranslucency: json.hasTranslucency,\n            uniformColor: uniformColor?.toJSON(),\n            featureIndexType: json.featureIndexType,\n            uniformFeatureID,\n            numVertices: json.count,\n            numRgbaPerVertex: json.numRgbaPerVertex,\n            uvParams: uvParams?.toJSON(),\n        };\n    }\n    parseInstances(primitive) {\n        const json = primitive.instances;\n        if (!json)\n            return undefined;\n        const count = JsonUtils.asInt(json.count, 0);\n        if (count <= 0)\n            return undefined;\n        const centerComponents = JsonUtils.asArray(json.transformCenter);\n        if (undefined === centerComponents || 3 !== centerComponents.length)\n            return undefined;\n        const transformCenter = Point3d.create(centerComponents[0], centerComponents[1], centerComponents[2]);\n        const featureIds = this.findBuffer(JsonUtils.asString(json.featureIds));\n        if (undefined === featureIds)\n            return undefined;\n        const transformBytes = this.findBuffer(JsonUtils.asString(json.transforms));\n        if (undefined === transformBytes)\n            return undefined;\n        // 1 transform = 3 rows of 4 floats = 12 floats per instance\n        const numFloats = transformBytes.byteLength / 4;\n        assert(Math.floor(numFloats) === numFloats);\n        assert(0 === numFloats % 12);\n        const transforms = new Float32Array(transformBytes.buffer, transformBytes.byteOffset, numFloats);\n        let symbologyOverrides;\n        if (undefined !== json.symbologyOverrides)\n            symbologyOverrides = this.findBuffer(JsonUtils.asString(json.symbologyOverrides));\n        return {\n            type: \"instances\",\n            count,\n            transforms,\n            transformCenter,\n            featureIds,\n            symbologyOverrides,\n        };\n    }\n    findBuffer(bufferViewId) {\n        if (typeof bufferViewId !== \"string\" || 0 === bufferViewId.length)\n            return undefined;\n        const bufferViewJson = this._document.bufferViews[bufferViewId];\n        if (undefined === bufferViewJson)\n            return undefined;\n        const byteOffset = JsonUtils.asInt(bufferViewJson.byteOffset);\n        const byteLength = JsonUtils.asInt(bufferViewJson.byteLength);\n        if (0 === byteLength)\n            return undefined;\n        return this._binaryData.subarray(byteOffset, byteOffset + byteLength);\n    }\n    colorDefFromMaterialJson(json) {\n        return undefined !== json ? ColorDef.from(json[0] * 255 + 0.5, json[1] * 255 + 0.5, json[2] * 255 + 0.5) : undefined;\n    }\n    materialFromJson(key) {\n        const materialJson = this._document.renderMaterials[key];\n        if (!materialJson)\n            return undefined;\n        // eslint-disable-next-line deprecation/deprecation\n        const materialParams = new RenderMaterial.Params(key);\n        materialParams.diffuseColor = this.colorDefFromMaterialJson(materialJson.diffuseColor);\n        if (materialJson.diffuse !== undefined)\n            materialParams.diffuse = JsonUtils.asDouble(materialJson.diffuse);\n        materialParams.specularColor = this.colorDefFromMaterialJson(materialJson.specularColor);\n        if (materialJson.specular !== undefined)\n            materialParams.specular = JsonUtils.asDouble(materialJson.specular);\n        materialParams.reflectColor = this.colorDefFromMaterialJson(materialJson.reflectColor);\n        if (materialJson.reflect !== undefined)\n            materialParams.reflect = JsonUtils.asDouble(materialJson.reflect);\n        if (materialJson.specularExponent !== undefined)\n            materialParams.specularExponent = materialJson.specularExponent;\n        if (undefined !== materialJson.transparency)\n            materialParams.alpha = 1.0 - materialJson.transparency;\n        materialParams.refract = JsonUtils.asDouble(materialJson.refract);\n        materialParams.shadows = JsonUtils.asBool(materialJson.shadows);\n        materialParams.ambient = JsonUtils.asDouble(materialJson.ambient);\n        if (undefined !== materialJson.textureMapping)\n            materialParams.textureMapping = this.textureMappingFromJson(materialJson.textureMapping.texture);\n        // eslint-disable-next-line deprecation/deprecation\n        return new Material(materialParams);\n    }\n    parseNamedTexture(namedTex, name) {\n        const textureType = JsonUtils.asBool(namedTex.isGlyph) ? RenderTexture.Type.Glyph :\n            (JsonUtils.asBool(namedTex.isTileSection) ? RenderTexture.Type.TileSection : RenderTexture.Type.Normal);\n        return new NamedTexture(name, textureType);\n    }\n    parseConstantLodProps(propsJson) {\n        if (undefined === propsJson)\n            return undefined;\n        return {\n            repetitions: JsonUtils.asDouble(propsJson.repetitions, 1.0),\n            offset: { x: propsJson.offset ? JsonUtils.asDouble(propsJson.offset[0]) : 0.0, y: propsJson.offset ? JsonUtils.asDouble(propsJson.offset[1]) : 0.0 },\n            minDistClamp: JsonUtils.asDouble(propsJson.minDistClamp, 1.0),\n            maxDistClamp: JsonUtils.asDouble(propsJson.maxDistClamp, 4096.0 * 1024.0 * 1024.0),\n        };\n    }\n    textureMappingFromJson(json) {\n        if (!json)\n            return undefined;\n        const name = JsonUtils.asString(json.name);\n        const namedTex = 0 !== name.length ? this._document.namedTextures[name] : undefined;\n        const texture = namedTex ? this.parseNamedTexture(namedTex, name) : undefined;\n        if (!texture)\n            return undefined;\n        const paramsJson = json.params;\n        const tf = paramsJson.transform;\n        const paramProps = {\n            textureMat2x3: new TextureMapping.Trans2x3(tf[0][0], tf[0][1], tf[0][2], tf[1][0], tf[1][1], tf[1][2]),\n            textureWeight: JsonUtils.asDouble(paramsJson.weight, 1.0),\n            mapMode: JsonUtils.asInt(paramsJson.mode),\n            worldMapping: JsonUtils.asBool(paramsJson.worldMapping),\n            useConstantLod: JsonUtils.asBool(paramsJson.useConstantLod),\n            constantLodProps: this.parseConstantLodProps(paramsJson.constantLodParams),\n        };\n        const textureMapping = new TextureMapping(texture, new TextureMapping.Params(paramProps));\n        const normalMapJson = json.normalMapParams;\n        if (normalMapJson) {\n            const normalTexName = JsonUtils.asString(normalMapJson.textureName);\n            const namedNormalTex = normalTexName.length > 0 ? this._document.namedTextures[normalTexName] : undefined;\n            const normalMap = namedNormalTex ? this.parseNamedTexture(namedNormalTex, normalTexName) : undefined;\n            if (normalMap) {\n                textureMapping.normalMapParams = {\n                    normalMap,\n                    greenUp: JsonUtils.asBool(normalMapJson.greenUp),\n                    scale: JsonUtils.asDouble(normalMapJson.scale, 1),\n                    useConstantLod: JsonUtils.asBool(normalMapJson.useConstantLod),\n                };\n            }\n        }\n        return textureMapping;\n    }\n    parseDisplayParams(json) {\n        const type = JsonUtils.asInt(json.type, DisplayParams.Type.Mesh);\n        const lineColor = ColorDef.create(JsonUtils.asInt(json.lineColor));\n        const fillColor = ColorDef.create(JsonUtils.asInt(json.fillColor));\n        const width = JsonUtils.asInt(json.lineWidth);\n        const linePixels = JsonUtils.asInt(json.linePixels, LinePixels.Solid);\n        const fillFlags = JsonUtils.asInt(json.fillFlags, FillFlags.None);\n        const ignoreLighting = JsonUtils.asBool(json.ignoreLighting);\n        // Material will always contain its own texture if it has one\n        const materialKey = json.materialId;\n        const material = undefined !== materialKey ? this.materialFromJson(materialKey) : undefined;\n        // We will only attempt to include the texture if material is undefined\n        let textureMapping;\n        let gradient;\n        if (!material) {\n            const textureJson = json.texture;\n            textureMapping = undefined !== textureJson ? this.textureMappingFromJson(textureJson) : undefined;\n            if (undefined === textureMapping) {\n                const gradientProps = json.gradient;\n                gradient = undefined !== gradientProps ? Gradient.Symb.fromJSON(gradientProps) : undefined;\n                if (gradient) {\n                    assert(undefined !== gradientProps);\n                    const texture = new GradientTexture(gradientProps);\n                    textureMapping = new TextureMapping(texture, new TextureMapping.Params({ textureMat2x3: new TextureMapping.Trans2x3(0, 1, 0, 1, 0, 0) }));\n                }\n            }\n        }\n        return new DisplayParams(type, lineColor, fillColor, width, linePixels, fillFlags, material, gradient, ignoreLighting, textureMapping);\n    }\n}\n/** @internal */\nexport function toMaterialParams(mat) {\n    const args = { alpha: mat.alpha };\n    if (mat.diffuse) {\n        args.diffuse = {\n            weight: mat.diffuse.weight,\n            color: undefined !== mat.diffuse.color ? ColorDef.fromJSON(mat.diffuse.color) : undefined,\n        };\n    }\n    if (mat.specular) {\n        args.specular = {\n            weight: mat.specular.weight,\n            exponent: mat.specular.exponent,\n            color: undefined !== mat.specular.color ? ColorDef.fromJSON(mat.specular.color) : undefined,\n        };\n    }\n    return args;\n}\n/** @internal */\nexport function convertFeatureTable(imdlFeatureTable, batchModelId) {\n    const table = imdlFeatureTable.multiModel\n        ? MultiModelPackedFeatureTable.create(imdlFeatureTable.data, batchModelId, imdlFeatureTable.numFeatures, BatchType.Primary, imdlFeatureTable.numSubCategories)\n        : new PackedFeatureTable(imdlFeatureTable.data, batchModelId, imdlFeatureTable.numFeatures, BatchType.Primary);\n    table.animationNodeIds = imdlFeatureTable.animationNodeIds;\n    return table;\n}\n/** @internal */\nexport function parseImdlDocument(options) {\n    const stream = ByteStream.fromUint8Array(options.data);\n    const imdlHeader = new ImdlHeader(stream);\n    if (!imdlHeader.isValid)\n        return TileReadStatus.InvalidHeader;\n    else if (!imdlHeader.isReadableVersion)\n        return TileReadStatus.NewerMajorVersion;\n    // Skip the feature table - we need to parse the JSON segment first to access its animationNodeIds.\n    const ftStartPos = stream.curPos;\n    const ftHeader = FeatureTableHeader.readFrom(stream);\n    if (!ftHeader)\n        return TileReadStatus.InvalidFeatureTable;\n    stream.curPos = ftStartPos + ftHeader.length;\n    // A glTF header follows the feature table\n    const gltfHeader = new GltfHeader(stream);\n    if (!gltfHeader.isValid)\n        return TileReadStatus.InvalidTileData;\n    stream.curPos = gltfHeader.scenePosition;\n    const sceneStrData = stream.nextBytes(gltfHeader.sceneStrLength);\n    const sceneStr = utf8ToString(sceneStrData);\n    if (!sceneStr)\n        return TileReadStatus.InvalidScene;\n    try {\n        const sceneValue = JSON.parse(sceneStr);\n        const imdlDoc = {\n            scene: JsonUtils.asString(sceneValue.scene),\n            scenes: JsonUtils.asArray(sceneValue.scenes),\n            animationNodes: JsonUtils.asObject(sceneValue.animationNodes),\n            bufferViews: JsonUtils.asObject(sceneValue.bufferViews) ?? {},\n            meshes: JsonUtils.asObject(sceneValue.meshes),\n            nodes: JsonUtils.asObject(sceneValue.nodes) ?? {},\n            materials: JsonUtils.asObject(sceneValue.materials) ?? {},\n            renderMaterials: JsonUtils.asObject(sceneValue.renderMaterials) ?? {},\n            namedTextures: JsonUtils.asObject(sceneValue.namedTextures) ?? {},\n            patternSymbols: JsonUtils.asObject(sceneValue.patternSymbols) ?? {},\n            rtcCenter: JsonUtils.asArray(sceneValue.rtcCenter),\n        };\n        if (!imdlDoc.meshes)\n            return TileReadStatus.InvalidTileData;\n        const binaryData = new Uint8Array(stream.arrayBuffer, gltfHeader.binaryPosition);\n        const featureTable = {\n            startPos: ftStartPos,\n            multiModel: 0 !== (imdlHeader.flags & ImdlFlags.MultiModelFeatureTable),\n        };\n        const parser = new Parser(imdlDoc, binaryData, options, featureTable, stream);\n        return parser.parse();\n    }\n    catch (_) {\n        return TileReadStatus.InvalidTileData;\n    }\n}\n//# sourceMappingURL=ParseImdlDocument.js.map",
      "start": 1693508118467,
      "end": 1693508118784,
      "sourcemaps": null
    }
  ]
}
