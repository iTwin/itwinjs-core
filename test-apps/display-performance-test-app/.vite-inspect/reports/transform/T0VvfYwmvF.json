{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/geometry3d/YawPitchRollAngles.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module CartesianGeometry\n */\nimport { Geometry } from \"../Geometry\";\nimport { Angle } from \"./Angle\";\nimport { Matrix3d } from \"./Matrix3d\";\nimport { Point3d } from \"./Point3dVector3d\";\n/**\n * Three angles that determine the orientation of an object in space, sometimes referred to as [Taitâ€“Bryan angles]\n * (https://en.wikipedia.org/wiki/Euler_angles).\n * * The matrix construction can be replicated by this logic:\n * * xyz coordinates have\n *   * x forward\n *   * y to left\n *   * z up\n * * Note that this is a right handed coordinate system.\n * * yaw is a rotation of x towards y, i.e. around positive z (counterclockwise):\n *     * `yawMatrix = Matrix3d.createRotationAroundAxisIndex(2, Angle.createDegrees(yawDegrees));`\n * * pitch is a rotation that raises x towards z, i.e. rotation around **negative y** (**clockwise**):\n *     * `pitchMatrix = Matrix3d.createRotationAroundAxisIndex(1, Angle.createDegrees(-pitchDegrees));`\n * * roll is rotation of y towards z, i.e. rotation around positive x (counterclockwise):\n *     * `rollMatrix = Matrix3d.createRotationAroundAxisIndex(0, Angle.createDegrees(rollDegrees));`\n * * The YPR matrix is the product\n *     * `result = yawMatrix.multiplyMatrixMatrix(pitchMatrix.multiplyMatrixMatrix(rollMatrix));`\n * * Note that this is for \"column based\" matrix with vectors multiplying on the right of the matrix.\n * Hence a vector is first rotated by roll, then the pitch, finally yaw. So multiplication order in\n * the sense of AxisOrder is `RPY` (i.e., XYZ), in contrast to the familiar name `YPR`.\n * @public\n */\nexport class YawPitchRollAngles {\n    /**\n     * Constructor\n     * @param yaw counterclockwise rotation angle around z\n     * @param pitch **clockwise** rotation angle around y\n     * @param roll counterclockwise rotation angle around x\n     */\n    constructor(yaw = Angle.zero(), pitch = Angle.zero(), roll = Angle.zero()) {\n        this.yaw = yaw;\n        this.pitch = pitch;\n        this.roll = roll;\n    }\n    /** Freeze this YawPitchRollAngles */\n    freeze() {\n        this.yaw.freeze();\n        this.pitch.freeze();\n        this.roll.freeze();\n        return Object.freeze(this);\n    }\n    /**\n     * Constructor for YawPitchRollAngles with angles in degrees.\n     * @param yawDegrees counterclockwise rotation angle (in degrees) around z\n     * @param pitchDegrees **clockwise** rotation angle (in degrees) around y\n     * @param rollDegrees counterclockwise rotation angle (in degrees) around x\n     */\n    static createDegrees(yawDegrees, pitchDegrees, rollDegrees) {\n        return new YawPitchRollAngles(Angle.createDegrees(yawDegrees), Angle.createDegrees(pitchDegrees), Angle.createDegrees(rollDegrees));\n    }\n    /**\n     * Constructor for YawPitchRollAngles with angles in radians.\n     * @param yawRadians counterclockwise rotation angle (in radians) around z\n     * @param pitchRadians **clockwise** rotation angle (in radians) around y\n     * @param rollRadians counterclockwise rotation angle (in radians) around x\n     */\n    static createRadians(yawRadians, pitchRadians, rollRadians) {\n        return new YawPitchRollAngles(Angle.createRadians(yawRadians), Angle.createRadians(pitchRadians), Angle.createRadians(rollRadians));\n    }\n    /** Construct a `YawPitchRoll` object from an object with 3 named angles */\n    static fromJSON(json) {\n        json = json ? json : {};\n        return new YawPitchRollAngles(Angle.fromJSON(json.yaw), Angle.fromJSON(json.pitch), Angle.fromJSON(json.roll));\n    }\n    /** Populate yaw, pitch and roll fields using `Angle.fromJSON` */\n    setFromJSON(json) {\n        json = json ? json : {};\n        this.yaw = Angle.fromJSON(json.yaw);\n        this.pitch = Angle.fromJSON(json.pitch);\n        this.roll = Angle.fromJSON(json.roll);\n    }\n    /**\n     * Convert to a JSON object of form { pitch: 20 , roll: 30 , yaw: 10 }. Angles are in degrees.\n     * Any values that are exactly zero (with tolerance `Geometry.smallAngleRadians`) are omitted.\n     */\n    toJSON() {\n        const val = {};\n        if (!this.pitch.isAlmostZero)\n            val.pitch = this.pitch.toJSON();\n        if (!this.roll.isAlmostZero)\n            val.roll = this.roll.toJSON();\n        if (!this.yaw.isAlmostZero)\n            val.yaw = this.yaw.toJSON();\n        return val;\n    }\n    /**\n     * Install all rotations from `other` into `this`.\n     * @param other YawPitchRollAngles source\n     */\n    setFrom(other) {\n        this.yaw.setFrom(other.yaw);\n        this.pitch.setFrom(other.pitch);\n        this.roll.setFrom(other.roll);\n    }\n    /**\n     * Compare angles between `this` and `other`.\n     * * Comparisons are via `isAlmostEqualAllowPeriodShift`.\n     * @param other YawPitchRollAngles source\n     */\n    isAlmostEqual(other) {\n        return this.yaw.isAlmostEqualAllowPeriodShift(other.yaw)\n            && this.pitch.isAlmostEqualAllowPeriodShift(other.pitch)\n            && this.roll.isAlmostEqualAllowPeriodShift(other.roll);\n    }\n    /** Make a copy of this YawPitchRollAngles */\n    clone() {\n        return new YawPitchRollAngles(this.yaw.clone(), this.pitch.clone(), this.roll.clone());\n    }\n    /**\n     * Expand the angles into a (rigid rotation) matrix.\n     * * The returned matrix is \"rigid\" (i.e., it has unit length rows and columns, and its transpose is its inverse).\n     * * The rigid matrix is always a right handed coordinate system.\n     * @param result optional pre-allocated `Matrix3d`\n     */\n    toMatrix3d(result) {\n        const cz = Math.cos(this.yaw.radians);\n        const sz = Math.sin(this.yaw.radians);\n        const cy = Math.cos(this.pitch.radians);\n        const sy = Math.sin(this.pitch.radians);\n        const cx = Math.cos(this.roll.radians);\n        const sx = Math.sin(this.roll.radians);\n        /**\n        * The axis order is XYZ (i.e., RPY) so the rotation matrix is calculated via rZ*rY*rX where\n        * rX, rY, and rZ are base rotation matrixes:\n        *\n        *     const rX = Matrix3d.createRowValues(\n        *        1, 0, 0,\n        *        0, Math.cos(x), -Math.sin(x),\n        *        0, Math.sin(x), Math.cos(x),\n        *      );\n        *      const rY = Matrix3d.createRowValues(\n        *        Math.cos(y), 0, Math.sin(y),\n        *        0, 1, 0,\n        *        -Math.sin(y), 0, Math.cos(y),\n        *      );\n        *      const rZ = Matrix3d.createRowValues(\n        *        Math.cos(z), -Math.sin(z), 0,\n        *        Math.sin(z), Math.cos(z), 0,\n        *        0, 0, 1,\n        *      );\n        *\n        * Then we replace sin(y) with -sin(y) because y rotation (i.e., pitch) is clockwise (alternatively, you\n        * can use transpose of rY in the matrix multiplication to get the same result)\n        */\n        return Matrix3d.createRowValues(cz * cy, -(sz * cx + cz * sy * sx), (sz * sx - cz * sy * cx), sz * cy, (cz * cx - sz * sy * sx), -(cz * sx + sz * sy * cx), sy, cy * sx, cy * cx, result);\n    }\n    /**\n     * Returns true if this rotation does nothing.\n     * * If allowPeriodShift is false, any nonzero angle is considered a non-identity\n     * * If allowPeriodShift is true, all angles are individually allowed to be any multiple of 360 degrees.\n     */\n    isIdentity(allowPeriodShift = true) {\n        if (allowPeriodShift)\n            return Angle.isAlmostEqualRadiansAllowPeriodShift(0.0, this.yaw.radians)\n                && Angle.isAlmostEqualRadiansAllowPeriodShift(0.0, this.pitch.radians)\n                && Angle.isAlmostEqualRadiansAllowPeriodShift(0.0, this.roll.radians);\n        else\n            return Angle.isAlmostEqualRadiansNoPeriodShift(0.0, this.yaw.radians)\n                && Angle.isAlmostEqualRadiansNoPeriodShift(0.0, this.pitch.radians)\n                && Angle.isAlmostEqualRadiansNoPeriodShift(0.0, this.roll.radians);\n    }\n    /** Return the largest angle in radians */\n    maxAbsRadians() {\n        return Geometry.maxAbsXYZ(this.yaw.radians, this.pitch.radians, this.roll.radians);\n    }\n    /** Return the sum of the angles in squared radians */\n    sumSquaredRadians() {\n        return Geometry.hypotenuseSquaredXYZ(this.yaw.radians, this.pitch.radians, this.roll.radians);\n    }\n    /** Return the largest difference of angles (in radians) between this and other */\n    maxDiffRadians(other) {\n        return Math.max(this.yaw.radians - other.yaw.radians, this.pitch.radians - other.pitch.radians, this.roll.radians - other.roll.radians);\n    }\n    /** Return the largest angle in degrees. */\n    maxAbsDegrees() {\n        return Geometry.maxAbsXYZ(this.yaw.degrees, this.pitch.degrees, this.roll.degrees);\n    }\n    /** Return the sum of squared angles in degrees. */\n    sumSquaredDegrees() {\n        return Geometry.hypotenuseSquaredXYZ(this.yaw.degrees, this.pitch.degrees, this.roll.degrees);\n    }\n    /** Return the largest difference of angles (in degrees) between this and other */\n    maxDiffDegrees(other) {\n        return Math.max(this.yaw.degrees - other.yaw.degrees, this.pitch.degrees - other.pitch.degrees, this.roll.degrees - other.roll.degrees);\n    }\n    /** Return an object from a Transform as an origin and YawPitchRollAngles. */\n    static tryFromTransform(transform) {\n        return {\n            origin: Point3d.createFrom(transform.origin),\n            angles: YawPitchRollAngles.createFromMatrix3d(transform.matrix),\n        };\n    }\n    /**\n     * Attempts to create a YawPitchRollAngles object from a Matrix3d\n     * * This conversion fails if the matrix is not rigid (unit rows and columns, and transpose is inverse)\n     * * In the failure case the method's return value is `undefined`.\n     * * In the failure case, if the optional result was supplied, that result will nonetheless be filled with\n     * a set of angles.\n     */\n    static createFromMatrix3d(matrix, result) {\n        /**\n         * The rotation matrix for is\n         *\n         * Matrix3d.createRowValues(\n         *      cz * cy, -(sz * cx + cz * sy * sx), (sz * sx - cz * sy * cx),\n         *      sz * cy, (cz * cx - sz * sy * sx), -(cz * sx + sz * sy * cx),\n         *      sy, cy * sx, cy * cx\n         * );\n         *\n         * where cx = cos(x), sx = sin(x), cy = cos(y), sy = sin(y), cz = cos(z), and sz = sin(z)\n         */\n        const sy = matrix.at(2, 0); // sin(y)\n        const cy = Math.sqrt(matrix.at(2, 1) * matrix.at(2, 1) + matrix.at(2, 2) * matrix.at(2, 2)); // |cos(y)|\n        const pitchA = Angle.createAtan2(sy, cy); // with positive cosine\n        const pitchB = Angle.createAtan2(sy, -cy); // with negative cosine\n        const angles = result ? result : new YawPitchRollAngles();\n        /**\n         * If cos(y) = 0 then y = +-90 degrees so we have a gimbal lock.\n         * This means x and z can be anything as long as their sum x + z is constant.\n         * so we can pick z = 0 and calculate x (or pick x = 0 and calculate z).\n         * Math details can be found\n         * https://en.wikipedia.org/wiki/Gimbal_lock#Loss_of_a_degree_of_freedom_with_Euler_angles\n         *\n         * The rotation matrix for y = +-90 degrees and x = 0 becomes\n         *\n         * Matrix3d.createRowValues(\n         *      0, -sz, -+cz,\n         *      0, cz, -+sz,\n         *      +-1, 0, 0\n         * );\n         *\n         * so z = atan(sz/cz) = atan(-matrix.at(0, 1), matrix.at(1, 1))\n         */\n        if (cy < Geometry.smallAngleRadians) {\n            angles.yaw = Angle.createAtan2(-matrix.at(0, 1), matrix.at(1, 1));\n            angles.pitch = pitchA; // this is an arbitrary choice. can pick pitchB instead.\n            angles.roll = Angle.createRadians(0.0);\n        }\n        else {\n            /**\n             * positive cosine\n             * z = atan(sz/cz) = atan(matrix.at(1, 0), matrix.at(0, 0))\n             * x = atan(sx/cx) = atan(matrix.at(2, 1), matrix.at(2, 2))\n             */\n            const yawA = Angle.createAtan2(matrix.at(1, 0), matrix.at(0, 0));\n            const rollA = Angle.createAtan2(matrix.at(2, 1), matrix.at(2, 2));\n            // similar with negative cosine\n            const yawB = Angle.createAtan2(-matrix.at(1, 0), -matrix.at(0, 0));\n            const rollB = Angle.createAtan2(-matrix.at(2, 1), -matrix.at(2, 2));\n            // create YPR\n            const yprA = new YawPitchRollAngles(yawA, pitchA, rollA);\n            const yprB = new YawPitchRollAngles(yawB, pitchB, rollB);\n            // decide to pick yprA or yprB with smallest magnitude angles\n            const absFactor = 0.95;\n            const maxRadiansA = yprA.maxAbsRadians();\n            const maxRadiansB = yprB.maxAbsRadians();\n            if (maxRadiansA < absFactor * maxRadiansB) {\n                angles.setFrom(yprA);\n            }\n            else if (maxRadiansB < absFactor * maxRadiansA) {\n                angles.setFrom(yprB);\n            }\n            else {\n                const sumA = yprA.sumSquaredRadians();\n                const sumB = yprB.sumSquaredRadians();\n                if (sumA <= sumB) {\n                    angles.setFrom(yprA);\n                }\n                else {\n                    angles.setFrom(yprB);\n                }\n            }\n        }\n        // sanity check\n        const matrix1 = angles.toMatrix3d();\n        return matrix.maxDiff(matrix1) < Geometry.smallAngleRadians ? angles : undefined;\n    }\n}\n//# sourceMappingURL=YawPitchRollAngles.js.map",
      "start": 1693508122441,
      "end": 1693508122611,
      "sourcemaps": null
    }
  ]
}
