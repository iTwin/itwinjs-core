{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/quantity/lib/esm/Formatter/FormatEnums.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Quantity\n */\nimport { QuantityError, QuantityStatus } from \"../Exception\";\n/** The regular expression to parse [format strings]($docs/bis/ec/kindofquantity.md#format-string)\n * provided in serialized formats as well as the full name of an [[OverrideFormat]].\n *\n * `formatName(precision)[unitName|unitLabel][unitName|unitLabel][unitName|unitLabel][unitName|unitLabel]`\n *\n * Explanation of the regex:\n * - ([\\w.:]+)\n *   - Grabs the format full name\n * - (\\(([^\\)]+)\\))?\n *   - Grabs the precision part with and without the `()`.\n *   - The parentheses are needed to validate the entire string.  (TODO: Need to check if this is true)\n * - (\\[([^\\|\\]]+)([\\|])?([^\\]]+)?\\])?\n *   - 4 of these make up the rest of the regex, none of them are required so each end in `?`\n *   - Grabs the unit name and label including the `[]`\n *   - Grabs the unit name, `|` and label separately\n * @internal\n */\nexport const formatStringRgx = /([\\w.:]+)(\\(([^\\)]+)\\))?(\\[([^\\|\\]]+)([\\|])?([^\\]]+)?\\])?(\\[([^\\|\\]]+)([\\|])?([^\\]]+)?\\])?(\\[([^\\|\\]]+)([\\|])?([^\\]]+)?\\])?(\\[([^\\|\\]]+)([\\|])?([^\\]]+)?\\])?/;\n/** @internal */\nexport function* getItemNamesFromFormatString(formatString) {\n    const match = formatString.split(formatStringRgx);\n    yield match[1]; // the Format Name\n    let index = 4;\n    while (index < match.length - 1) { // index 0 and 21 are empty strings\n        if (match[index] !== undefined)\n            yield match[index + 1]; // Unit Name\n        else\n            break;\n        index += 4;\n    }\n}\n/** @beta */\nexport var FormatTraits;\n(function (FormatTraits) {\n    FormatTraits[FormatTraits[\"Uninitialized\"] = 0] = \"Uninitialized\";\n    /** Show trailing zeroes to requested precision. */\n    FormatTraits[FormatTraits[\"TrailZeroes\"] = 1] = \"TrailZeroes\";\n    /** Indicates that the fractional part of the number is required when the fraction is zero */\n    FormatTraits[FormatTraits[\"KeepSingleZero\"] = 2] = \"KeepSingleZero\";\n    /** Zero magnitude returns blank display value */\n    FormatTraits[FormatTraits[\"ZeroEmpty\"] = 4] = \"ZeroEmpty\";\n    /** Show decimal point when value to right of decimal is empty */\n    FormatTraits[FormatTraits[\"KeepDecimalPoint\"] = 8] = \"KeepDecimalPoint\";\n    /** Use the rounding factor. Not yet supported  */\n    FormatTraits[FormatTraits[\"ApplyRounding\"] = 16] = \"ApplyRounding\";\n    /** Show a dash between whole value and fractional value */\n    FormatTraits[FormatTraits[\"FractionDash\"] = 32] = \"FractionDash\";\n    /** Append the quantity's unit label */\n    FormatTraits[FormatTraits[\"ShowUnitLabel\"] = 64] = \"ShowUnitLabel\";\n    /** Prepend unit label. Not yet supported */\n    FormatTraits[FormatTraits[\"PrependUnitLabel\"] = 128] = \"PrependUnitLabel\";\n    /** show a grouping in each group of 1000. */\n    FormatTraits[FormatTraits[\"Use1000Separator\"] = 256] = \"Use1000Separator\";\n    /** Indicates that if an exponent value is positive to not include a `+`. By default a sign, `+` or `-`, is always shown. Not yet supported */\n    FormatTraits[FormatTraits[\"ExponentOnlyNegative\"] = 512] = \"ExponentOnlyNegative\";\n})(FormatTraits || (FormatTraits = {}));\n/** Precision for Fractional formatted value types. Range from Whole (1/1) through 1/256.\n * @beta */\nexport var FractionalPrecision;\n(function (FractionalPrecision) {\n    FractionalPrecision[FractionalPrecision[\"One\"] = 1] = \"One\";\n    FractionalPrecision[FractionalPrecision[\"Two\"] = 2] = \"Two\";\n    FractionalPrecision[FractionalPrecision[\"Four\"] = 4] = \"Four\";\n    FractionalPrecision[FractionalPrecision[\"Eight\"] = 8] = \"Eight\";\n    FractionalPrecision[FractionalPrecision[\"Sixteen\"] = 16] = \"Sixteen\";\n    FractionalPrecision[FractionalPrecision[\"ThirtyTwo\"] = 32] = \"ThirtyTwo\";\n    FractionalPrecision[FractionalPrecision[\"SixtyFour\"] = 64] = \"SixtyFour\";\n    FractionalPrecision[FractionalPrecision[\"OneHundredTwentyEight\"] = 128] = \"OneHundredTwentyEight\";\n    FractionalPrecision[FractionalPrecision[\"TwoHundredFiftySix\"] = 256] = \"TwoHundredFiftySix\";\n})(FractionalPrecision || (FractionalPrecision = {}));\n/** Precision for Decimal, Scientific, and Station formatted value types. Range from 1/(10^0) through 1/(10^12).\n * @beta */\nexport var DecimalPrecision;\n(function (DecimalPrecision) {\n    DecimalPrecision[DecimalPrecision[\"Zero\"] = 0] = \"Zero\";\n    DecimalPrecision[DecimalPrecision[\"One\"] = 1] = \"One\";\n    DecimalPrecision[DecimalPrecision[\"Two\"] = 2] = \"Two\";\n    DecimalPrecision[DecimalPrecision[\"Three\"] = 3] = \"Three\";\n    DecimalPrecision[DecimalPrecision[\"Four\"] = 4] = \"Four\";\n    DecimalPrecision[DecimalPrecision[\"Five\"] = 5] = \"Five\";\n    DecimalPrecision[DecimalPrecision[\"Six\"] = 6] = \"Six\";\n    DecimalPrecision[DecimalPrecision[\"Seven\"] = 7] = \"Seven\";\n    DecimalPrecision[DecimalPrecision[\"Eight\"] = 8] = \"Eight\";\n    DecimalPrecision[DecimalPrecision[\"Nine\"] = 9] = \"Nine\";\n    DecimalPrecision[DecimalPrecision[\"Ten\"] = 10] = \"Ten\";\n    DecimalPrecision[DecimalPrecision[\"Eleven\"] = 11] = \"Eleven\";\n    DecimalPrecision[DecimalPrecision[\"Twelve\"] = 12] = \"Twelve\";\n})(DecimalPrecision || (DecimalPrecision = {}));\n/** Supported format types\n *  @beta */\nexport var FormatType;\n(function (FormatType) {\n    /** Decimal display (ie 2.125) */\n    FormatType[FormatType[\"Decimal\"] = 0] = \"Decimal\";\n    /** Fractional display (ie 2-1/8) */\n    FormatType[FormatType[\"Fractional\"] = 1] = \"Fractional\";\n    /** Scientific Notation (ie 1.04e3) */\n    FormatType[FormatType[\"Scientific\"] = 2] = \"Scientific\";\n    /** Civil Engineering Stationing (ie 1+00). */\n    FormatType[FormatType[\"Station\"] = 3] = \"Station\";\n})(FormatType || (FormatType = {}));\n/** required if type is scientific\n * @beta */\nexport var ScientificType;\n(function (ScientificType) {\n    /** Non-zero value left of decimal point (ie 1.2345e3) */\n    ScientificType[ScientificType[\"Normalized\"] = 0] = \"Normalized\";\n    /** Zero value left of decimal point (ie 0.12345e4) */\n    ScientificType[ScientificType[\"ZeroNormalized\"] = 1] = \"ZeroNormalized\";\n})(ScientificType || (ScientificType = {}));\n/** Determines how the sign of values are displayed\n * @beta */\nexport var ShowSignOption;\n(function (ShowSignOption) {\n    /** Never show a sign even if the value is negative. */\n    ShowSignOption[ShowSignOption[\"NoSign\"] = 0] = \"NoSign\";\n    /** Only show a sign when the value is negative. */\n    ShowSignOption[ShowSignOption[\"OnlyNegative\"] = 1] = \"OnlyNegative\";\n    /** Always show a sign whether the value is positive or negative. */\n    ShowSignOption[ShowSignOption[\"SignAlways\"] = 2] = \"SignAlways\";\n    /** Only show a sign when the value is negative but use parentheses instead of a negative sign. For example, -10 is formatted as `(10)`. */\n    ShowSignOption[ShowSignOption[\"NegativeParentheses\"] = 3] = \"NegativeParentheses\";\n})(ShowSignOption || (ShowSignOption = {}));\n// parse and toString methods\n/**  @beta   */\nexport function parseScientificType(scientificType, formatName) {\n    switch (scientificType.toLowerCase()) {\n        case \"normalized\": return ScientificType.Normalized;\n        case \"zeronormalized\": return ScientificType.ZeroNormalized;\n        default:\n            throw new QuantityError(QuantityStatus.InvalidJson, `The Format ${formatName} has an invalid 'scientificType' attribute.`);\n    }\n}\n/**  @beta   */\nexport function scientificTypeToString(scientificType) {\n    return (scientificType === ScientificType.Normalized) ? \"Normalized\" : \"ZeroNormalized\";\n}\n/** @beta    */\nexport function parseShowSignOption(showSignOption, formatName) {\n    switch (showSignOption.toLowerCase()) {\n        case \"nosign\": return ShowSignOption.NoSign;\n        case \"onlynegative\": return ShowSignOption.OnlyNegative;\n        case \"signalways\": return ShowSignOption.SignAlways;\n        case \"negativeparentheses\": return ShowSignOption.NegativeParentheses;\n        default:\n            throw new QuantityError(QuantityStatus.InvalidJson, `The Format ${formatName} has an invalid 'showSignOption' attribute.`);\n    }\n}\n/**  @beta  */\nexport function showSignOptionToString(showSign) {\n    switch (showSign) {\n        case ShowSignOption.NegativeParentheses: return \"NegativeParentheses\";\n        case ShowSignOption.NoSign: return \"NoSign\";\n        case ShowSignOption.OnlyNegative: return \"OnlyNegative\";\n        case ShowSignOption.SignAlways: return \"SignAlways\";\n    }\n}\n/**  @beta  */\nexport function parseFormatTrait(formatTraitsString, formatName) {\n    switch (formatTraitsString.toLowerCase()) {\n        case \"trailzeroes\": return FormatTraits.TrailZeroes;\n        case \"keepsinglezero\": return FormatTraits.KeepSingleZero;\n        case \"zeroempty\": return FormatTraits.ZeroEmpty;\n        case \"keepdecimalpoint\": return FormatTraits.KeepDecimalPoint;\n        case \"applyrounding\": return FormatTraits.ApplyRounding;\n        case \"fractiondash\": return FormatTraits.FractionDash;\n        case \"showunitlabel\": return FormatTraits.ShowUnitLabel;\n        case \"prependunitlabel\": return FormatTraits.PrependUnitLabel;\n        case \"use1000separator\": return FormatTraits.Use1000Separator;\n        case \"exponentonlynegative\": return FormatTraits.ExponentOnlyNegative;\n        default:\n            throw new QuantityError(QuantityStatus.InvalidJson, `The Format ${formatName} has an invalid 'formatTraits' attribute.`);\n    }\n}\n/** @beta */\nexport function getTraitString(trait) {\n    switch (trait) {\n        case FormatTraits.TrailZeroes:\n            return \"trailZeroes\";\n        case FormatTraits.KeepSingleZero:\n            return \"keepSingleZero\";\n        case FormatTraits.ZeroEmpty:\n            return \"zeroEmpty\";\n        case FormatTraits.KeepDecimalPoint:\n            return \"keepDecimalPoint\";\n        case FormatTraits.ApplyRounding:\n            return \"applyRounding\";\n        case FormatTraits.FractionDash:\n            return \"fractionDash\";\n        case FormatTraits.ShowUnitLabel:\n            return \"showUnitLabel\";\n        case FormatTraits.PrependUnitLabel:\n            return \"prependUnitLabel\";\n        case FormatTraits.Use1000Separator:\n            return \"use1000Separator\";\n        case FormatTraits.ExponentOnlyNegative:\n        default:\n            return \"exponentOnlyNegative\";\n    }\n}\n/**  @beta  */\nexport function formatTraitsToArray(currentFormatTrait) {\n    const formatTraitsArr = Array();\n    if ((currentFormatTrait & FormatTraits.TrailZeroes) === FormatTraits.TrailZeroes)\n        formatTraitsArr.push(\"TrailZeroes\");\n    if ((currentFormatTrait & FormatTraits.KeepSingleZero) === FormatTraits.KeepSingleZero)\n        formatTraitsArr.push(\"KeepSingleZero\");\n    if ((currentFormatTrait & FormatTraits.ZeroEmpty) === FormatTraits.ZeroEmpty)\n        formatTraitsArr.push(\"ZeroEmpty\");\n    if ((currentFormatTrait & FormatTraits.KeepDecimalPoint) === FormatTraits.KeepDecimalPoint)\n        formatTraitsArr.push(\"KeepDecimalPoint\");\n    if ((currentFormatTrait & FormatTraits.ApplyRounding) === FormatTraits.ApplyRounding)\n        formatTraitsArr.push(\"ApplyRounding\");\n    if ((currentFormatTrait & FormatTraits.FractionDash) === FormatTraits.FractionDash)\n        formatTraitsArr.push(\"FractionDash\");\n    if ((currentFormatTrait & FormatTraits.ShowUnitLabel) === FormatTraits.ShowUnitLabel)\n        formatTraitsArr.push(\"ShowUnitLabel\");\n    if ((currentFormatTrait & FormatTraits.PrependUnitLabel) === FormatTraits.PrependUnitLabel)\n        formatTraitsArr.push(\"PrependUnitLabel\");\n    if ((currentFormatTrait & FormatTraits.Use1000Separator) === FormatTraits.Use1000Separator)\n        formatTraitsArr.push(\"Use1000Separator\");\n    if ((currentFormatTrait & FormatTraits.ExponentOnlyNegative) === FormatTraits.ExponentOnlyNegative)\n        formatTraitsArr.push(\"ExponentOnlyNegative\");\n    return formatTraitsArr;\n}\n/**  @beta    */\nexport function parseFormatType(jsonObjType, formatName) {\n    switch (jsonObjType.toLowerCase()) {\n        case \"decimal\": return FormatType.Decimal;\n        case \"scientific\": return FormatType.Scientific;\n        case \"station\": return FormatType.Station;\n        case \"fractional\": return FormatType.Fractional;\n        default:\n            throw new QuantityError(QuantityStatus.InvalidJson, `The Format ${formatName} has an invalid 'type' attribute.`);\n    }\n}\n/** @beta    */\nexport function formatTypeToString(type) {\n    switch (type) {\n        case FormatType.Decimal: return \"Decimal\";\n        case FormatType.Scientific: return \"Scientific\";\n        case FormatType.Station: return \"Station\";\n        case FormatType.Fractional: return \"Fractional\";\n    }\n}\n/**  @beta    */\nexport function parseDecimalPrecision(jsonObjPrecision, formatName) {\n    switch (jsonObjPrecision) {\n        case 0: return DecimalPrecision.Zero;\n        case 1: return DecimalPrecision.One;\n        case 2: return DecimalPrecision.Two;\n        case 3: return DecimalPrecision.Three;\n        case 4: return DecimalPrecision.Four;\n        case 5: return DecimalPrecision.Five;\n        case 6: return DecimalPrecision.Six;\n        case 7: return DecimalPrecision.Seven;\n        case 8: return DecimalPrecision.Eight;\n        case 9: return DecimalPrecision.Nine;\n        case 10: return DecimalPrecision.Ten;\n        case 11: return DecimalPrecision.Eleven;\n        case 12: return DecimalPrecision.Twelve;\n        default:\n            throw new QuantityError(QuantityStatus.InvalidJson, `The Format ${formatName} has an invalid 'precision' attribute.`);\n    }\n}\n/**  @beta validates the input value, that is typically extracted for persisted JSON data, is a valid FractionalPrecision */\nexport function parseFractionalPrecision(jsonObjPrecision, formatName) {\n    switch (jsonObjPrecision) {\n        case 1: return FractionalPrecision.One;\n        case 2: return FractionalPrecision.Two;\n        case 4: return FractionalPrecision.Four;\n        case 8: return FractionalPrecision.Eight;\n        case 16: return FractionalPrecision.Sixteen;\n        case 32: return FractionalPrecision.ThirtyTwo;\n        case 64: return FractionalPrecision.SixtyFour;\n        case 128: return FractionalPrecision.OneHundredTwentyEight;\n        case 256: return FractionalPrecision.TwoHundredFiftySix;\n        default:\n            throw new QuantityError(QuantityStatus.InvalidJson, `The Format ${formatName} has an invalid 'precision' attribute.`);\n    }\n}\n/** @beta  validates the input value, that is typically extracted for persisted JSON data, is a valid DecimalPrecision or FractionalPrecision. */\nexport function parsePrecision(precision, type, formatName) {\n    switch (type) { // type must be decimal, fractional, scientific, or station\n        case FormatType.Decimal:\n        case FormatType.Scientific:\n        case FormatType.Station:\n            return parseDecimalPrecision(precision, formatName);\n        case FormatType.Fractional:\n            return parseFractionalPrecision(precision, formatName);\n        default:\n            throw new QuantityError(QuantityStatus.InvalidJson, `The Format ${formatName} has an invalid 'precision' attribute.`);\n    }\n}\n//# sourceMappingURL=FormatEnums.js.map",
      "start": 1693508123250,
      "end": 1693508123504,
      "sourcemaps": null
    }
  ]
}
