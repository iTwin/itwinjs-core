{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/glsl/EVSMFromDepth.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { AttributeMap } from \"../AttributeMap\";\nimport { TextureUnit } from \"../RenderFlags\";\nimport { ProgramBuilder } from \"../ShaderBuilder\";\nimport { Texture2DHandle } from \"../Texture\";\nimport { assignFragColor } from \"./Fragment\";\nimport { addEvsmExponent, warpDepth } from \"./SolarShadowMapping\";\n// This shader reads the depth texture, converts it to EVSM values, then averages those down 4 to 1\n// Positions are in NDC [-1..1]. Compute UV params in [0..1]\nconst computeTexCoord = \"v_texCoord = (rawPosition.xy + 1.0) * 0.5;\";\nconst computePosition = \"return rawPos;\";\nconst computeEVSM = `\r\n  const float sampleWeight = 0.25;\r\n  vec4 average = vec4(0.0);\r\n  vec2 tc = v_texCoord - u_stepSize * 0.5; // v_texCoord starts in between the 4 texels\r\n\r\n  float depth = TEXTURE(u_depthTexture, tc).r;\r\n  vec2 vsmDepth = warpDepth(depth, u_evsmExponent);\r\n  average += sampleWeight * vec4(vsmDepth.xy, vsmDepth.xy * vsmDepth.xy);\r\n\r\n  tc.x += u_stepSize.x;\r\n  depth = TEXTURE(u_depthTexture, tc).r;\r\n  vsmDepth = warpDepth(depth, u_evsmExponent);\r\n  average += sampleWeight * vec4(vsmDepth.xy, vsmDepth.xy * vsmDepth.xy);\r\n\r\n  tc.y += u_stepSize.y;\r\n  depth = TEXTURE(u_depthTexture, tc).r;\r\n  vsmDepth = warpDepth(depth, u_evsmExponent);\r\n  average += sampleWeight * vec4(vsmDepth.xy, vsmDepth.xy * vsmDepth.xy);\r\n\r\n  tc.x -= u_stepSize.x;\r\n  depth = TEXTURE(u_depthTexture, tc).r;\r\n  vsmDepth = warpDepth(depth, u_evsmExponent);\r\n  average += sampleWeight * vec4(vsmDepth.xy, vsmDepth.xy * vsmDepth.xy);\r\n\r\n  return average;\r\n`;\n/** @internal */\nexport function createEVSMProgram(context) {\n    const builder = new ProgramBuilder(AttributeMap.findAttributeMap(undefined, false));\n    const vert = builder.vert;\n    const frag = builder.frag;\n    vert.set(10 /* VertexShaderComponent.ComputePosition */, computePosition);\n    builder.addInlineComputedVarying(\"v_texCoord\", 3 /* VariableType.Vec2 */, computeTexCoord);\n    frag.addUniform(\"u_depthTexture\", 8 /* VariableType.Sampler2D */, (prog) => {\n        prog.addGraphicUniform(\"u_depthTexture\", (uniform, params) => {\n            const geom = params.geometry;\n            Texture2DHandle.bindSampler(uniform, geom.depthTexture, TextureUnit.Zero);\n        });\n    });\n    frag.addUniform(\"u_stepSize\", 3 /* VariableType.Vec2 */, (prog) => {\n        prog.addGraphicUniform(\"u_stepSize\", (uniform, params) => {\n            const geom = params.geometry;\n            uniform.setUniform2fv(geom.stepSize);\n        });\n    }, 3 /* VariablePrecision.High */);\n    addEvsmExponent(frag);\n    frag.addFunction(warpDepth);\n    frag.set(1 /* FragmentShaderComponent.ComputeBaseColor */, computeEVSM);\n    frag.set(16 /* FragmentShaderComponent.AssignFragData */, assignFragColor);\n    builder.vert.headerComment = \"//!V! EVSMFromDepth\";\n    builder.frag.headerComment = \"//!F! EVSMFromDepth\";\n    return builder.buildProgram(context);\n}\n//# sourceMappingURL=EVSMFromDepth.js.map",
      "start": 1693508124659,
      "end": 1693508124785,
      "sourcemaps": null
    }
  ]
}
