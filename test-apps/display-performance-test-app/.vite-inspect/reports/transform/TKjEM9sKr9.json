{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/glsl/FeatureSymbology.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { assert } from \"@itwin/core-bentley\";\nimport { Pass, TextureUnit } from \"../RenderFlags\";\nimport { addExtractNthBit, addEyeSpace, addUInt32s } from \"./Common\";\nimport { decodeDepthRgb, decodeUint24 } from \"./Decode\";\nimport { addWindowToTexCoords, assignFragColor, computeLinearDepth } from \"./Fragment\";\nimport { addLookupTable } from \"./LookupTable\";\nimport { addRenderPass } from \"./RenderPass\";\nimport { addAlpha, addLineWeight, replaceLineCode, replaceLineWeight } from \"./Vertex\";\n/** @internal */\nexport function addOvrFlagConstants(builder) {\n    // NB: These are the bit positions of each flag in OvrFlags enum - not the flag values\n    builder.addBitFlagConstant(\"kOvrBit_Visibility\", 0);\n    builder.addBitFlagConstant(\"kOvrBit_Rgb\", 1);\n    builder.addBitFlagConstant(\"kOvrBit_Alpha\", 2);\n    builder.addBitFlagConstant(\"kOvrBit_IgnoreMaterial\", 3);\n    builder.addBitFlagConstant(\"kOvrBit_Flashed\", 4);\n    builder.addBitFlagConstant(\"kOvrBit_NonLocatable\", 5);\n    builder.addBitFlagConstant(\"kOvrBit_LineCode\", 6);\n    builder.addBitFlagConstant(\"kOvrBit_Weight\", 7);\n    // NB: We treat the 16-bit flags as 2 bytes - so subtract 8 from each of these bit indices.\n    builder.addBitFlagConstant(\"kOvrBit_Hilited\", 0);\n    builder.addBitFlagConstant(\"kOvrBit_Emphasized\", 1);\n    builder.addBitFlagConstant(\"kOvrBit_ViewIndependentTransparency\", 2);\n}\nconst computeLUTFeatureIndex = `g_featureAndMaterialIndex.xyz`;\nconst computeInstanceFeatureIndex = `g_isAreaPattern ? u_patternFeatureId : a_featureId`;\nfunction computeFeatureIndex(vertex) {\n    if (vertex.usesInstancedGeometry) {\n        vertex.addUniform(\"u_patternFeatureId\", 4 /* VariableType.Vec3 */, (prog) => {\n            prog.addGraphicUniform(\"u_patternFeatureId\", (uniform, params) => {\n                const id = params.geometry.asInstanced?.patternFeatureId;\n                assert(undefined !== id);\n                if (id)\n                    uniform.setUniform3fv(id);\n            });\n        });\n        return `g_featureIndex = ${computeInstanceFeatureIndex};`;\n    }\n    return vertex.usesVertexTable ? `g_featureIndex = ${computeLUTFeatureIndex};` : \"\";\n}\nfunction getFeatureIndex(vertex) {\n    return `\r\nfloat getFeatureIndex() {\r\n  ${computeFeatureIndex(vertex)}\r\n  return decodeUInt24(g_featureIndex);\r\n}\r\n`;\n}\nconst nthFeatureBitSet = `\r\nbool nthFeatureBitSet(float flags, uint n) {\r\n  return 0u == (u_globalOvrFlags & n) && nthBitSet(flags, n);\r\n}\r\n`;\nconst extractNthFeatureBit = `\r\nfloat extractNthFeatureBit(float flags, uint n) {\r\n  return 0u == (u_globalOvrFlags & n) && nthBitSet(flags, n) ? 1.0 : 0.0;\r\n}\r\n`;\nconst computeFeatureTextureCoords = `\r\nvec2 computeFeatureTextureCoords() { return compute_feature_coords(getFeatureIndex()); }\r\n`;\nconst getFirstFeatureRgba = `\r\nvec4 getFirstFeatureRgba() {\r\n  feature_texCoord = computeFeatureTextureCoords();\r\n  return TEXTURE(u_featureLUT, feature_texCoord);\r\n}\r\n`;\nconst getSecondFeatureRgba = `\r\nvec4 getSecondFeatureRgba() {\r\n  vec2 coord = feature_texCoord;\r\n  coord.x += g_feature_stepX;\r\n  return TEXTURE(u_featureLUT, coord);\r\n}\r\n`;\nconst computeLineWeight = `\r\nfloat computeLineWeight() {\r\n  return linear_feature_overrides.x > 0.5 ? linear_feature_overrides.y : g_lineWeight;\r\n}\r\n`;\nconst computeLineCode = `\r\nfloat computeLineCode() {\r\n  return linear_feature_overrides.z > 0.5 ? linear_feature_overrides.w : g_lineCode;\r\n}\r\n`;\nfunction addFeatureIndex(vert) {\n    vert.addGlobal(\"g_featureIndex\", 4 /* VariableType.Vec3 */);\n    vert.addFunction(decodeUint24);\n    vert.addFunction(getFeatureIndex(vert));\n}\n// Discards vertex if feature is invisible; or rendering opaque during translucent pass or vice-versa\n// (The latter occurs when some translucent feature is overridden to be opaque, or vice-versa)\nconst checkVertexDiscard = `\r\n  if (feature_invisible)\r\n    return true;\r\n\r\n  bool hasAlpha = 1.0 == u_hasAlpha;\r\n  if (feature_alpha > 0.0)\r\n    hasAlpha = feature_alpha <= s_maxAlpha;\r\n\r\n  int discardFlags = u_transparencyDiscardFlags;\r\n  bool discardViewIndependentDuringOpaque = discardFlags >= 4;\r\n  if (discardViewIndependentDuringOpaque)\r\n    discardFlags = discardFlags - 4;\r\n\r\n  bool isOpaquePass = (kRenderPass_OpaqueLinear <= u_renderPass && kRenderPass_OpaqueGeneral >= u_renderPass);\r\n  bool discardTranslucentDuringOpaquePass = 1 == discardFlags || 3 == discardFlags || (feature_viewIndependentTransparency && discardViewIndependentDuringOpaque);\r\n  if (isOpaquePass && !discardTranslucentDuringOpaquePass)\r\n    return false;\r\n\r\n  bool isTranslucentPass = kRenderPass_Translucent == u_renderPass;\r\n  bool discardOpaqueDuringTranslucentPass = 2 == discardFlags || 3 == discardFlags;\r\n  if (isTranslucentPass && !discardOpaqueDuringTranslucentPass)\r\n    return false;\r\n\r\n  return (isOpaquePass && hasAlpha) || (isTranslucentPass && !hasAlpha);\r\n`;\nfunction addTransparencyDiscardFlags(vert) {\n    // Even when transparency view flag is off, we need to allow features to override transparency, because it\n    // is used when applying transparency threshold. However, we need to ensure we don't DISCARD transparent stuff during\n    // opaque pass if transparency is off (see checkVertexDiscard). Especially important for transparency threshold and readPixels().\n    // Also, if we override raster text to be opaque we must still draw it in the translucent pass.\n    // Finally, if the transparency override is view-independent (i.e., ignores view flags and render mode) we want to discard it during opaque pass\n    // unless we're reading pixels.\n    // So we have a bit field:\n    // 1: discard translucent during opaque.\n    // 2: discard opaque during translucent.\n    // 4: discard view-independent translucent during opaque.\n    vert.addUniform(\"u_transparencyDiscardFlags\", 1 /* VariableType.Int */, (prog) => {\n        prog.addGraphicUniform(\"u_transparencyDiscardFlags\", (uniform, params) => {\n            let flags = 0;\n            // Textured surfaces may render in both passes. If so, it's up to fragment shader to handle discard.\n            const pass = params.geometry.getPass(params.target);\n            if (!Pass.rendersOpaqueAndTranslucent(pass)) {\n                // During readPixels() we force transparency off. Make sure to ignore a Branch that turns it back on.\n                if (!params.target.isReadPixelsInProgress)\n                    flags = params.target.currentViewFlags.transparency ? 1 : 4;\n                if (!params.geometry.alwaysRenderTranslucent)\n                    flags += 2;\n            }\n            uniform.setUniform1i(flags);\n        });\n    });\n}\nfunction addCommon(builder, mode, opts, wantGlobalOvrFlags = true) {\n    if (0 /* FeatureMode.None */ === mode)\n        return false;\n    const vert = builder.vert;\n    addFeatureIndex(vert);\n    const haveOverrides = 0 /* FeatureSymbologyOptions.None */ !== (opts & 4 /* FeatureSymbologyOptions.HasOverrides */);\n    if (!haveOverrides) {\n        // For pick output we must compute g_featureIndex...\n        if (1 /* FeatureMode.Pick */ === mode)\n            vert.set(3 /* VertexShaderComponent.ComputeFeatureOverrides */, computeFeatureIndex(vert));\n        return true;\n    }\n    const wantWeight = 0 /* FeatureSymbologyOptions.None */ !== (opts & 1 /* FeatureSymbologyOptions.Weight */);\n    const wantLineCode = 0 /* FeatureSymbologyOptions.None */ !== (opts & 2 /* FeatureSymbologyOptions.LineCode */);\n    const wantColor = 0 /* FeatureSymbologyOptions.None */ !== (opts & 8 /* FeatureSymbologyOptions.Color */);\n    const wantAlpha = 0 /* FeatureSymbologyOptions.None */ !== (opts & 16 /* FeatureSymbologyOptions.Alpha */);\n    assert(wantColor || !wantAlpha);\n    addExtractNthBit(vert);\n    addOvrFlagConstants(vert);\n    vert.addGlobal(\"linear_feature_overrides\", 5 /* VariableType.Vec4 */, \"vec4(0.0)\");\n    vert.addGlobal(\"feature_ignore_material\", 0 /* VariableType.Boolean */, \"false\");\n    if (wantWeight || wantLineCode) {\n        if (wantLineCode)\n            replaceLineCode(vert, computeLineCode);\n        if (wantWeight) {\n            replaceLineWeight(vert, computeLineWeight);\n        }\n    }\n    if (wantGlobalOvrFlags) {\n        const bitmapType = 10 /* VariableType.Uint */;\n        vert.addFunction(nthFeatureBitSet);\n        vert.addFunction(extractNthFeatureBit);\n        vert.addUniform(\"u_globalOvrFlags\", bitmapType, (prog) => {\n            prog.addGraphicUniform(\"u_globalOvrFlags\", (uniform, params) => {\n                let flags = 0.0;\n                if (params.geometry.isEdge) {\n                    const settings = params.target.currentEdgeSettings;\n                    flags = settings.computeOvrFlags(params.renderPass, params.target.currentViewFlags);\n                }\n                if (!params.geometry.allowColorOverride)\n                    flags |= 6 /* OvrFlags.Rgba */;\n                uniform.setUniformBitflags(flags);\n            });\n        });\n    }\n    addLookupTable(vert, \"feature\", \"2.0\");\n    vert.addGlobal(\"feature_texCoord\", 3 /* VariableType.Vec2 */);\n    vert.addFunction(computeFeatureTextureCoords);\n    vert.addFunction(getFirstFeatureRgba);\n    vert.addUniform(\"u_featureLUT\", 8 /* VariableType.Sampler2D */, (prog) => {\n        prog.addGraphicUniform(\"u_featureLUT\", (uniform, params) => {\n            params.target.uniforms.batch.bindLUT(uniform);\n        });\n    });\n    vert.addUniform(\"u_featureParams\", 3 /* VariableType.Vec2 */, (prog) => {\n        prog.addGraphicUniform(\"u_featureParams\", (uniform, params) => {\n            params.target.uniforms.batch.bindLUTParams(uniform);\n        });\n    });\n    if (wantColor) {\n        vert.addFunction(getSecondFeatureRgba);\n        if (wantAlpha) {\n            addMaxAlpha(vert);\n            addRenderPass(vert);\n            addAlpha(vert);\n            addTransparencyDiscardFlags(vert);\n            vert.set(9 /* VertexShaderComponent.CheckForDiscard */, checkVertexDiscard);\n        }\n    }\n    return true;\n}\nexport function addMaxAlpha(builder) {\n    const minTransparency = 15.0; // NB: See DisplayParams.getMinTransparency() - this must match!\n    const maxAlpha = (255 - minTransparency) / 255;\n    builder.addConstant(\"s_maxAlpha\", 2 /* VariableType.Float */, maxAlpha.toString());\n}\n/** @internal */\nfunction addEmphasisFlags(builder) {\n    // Must be kept in sync with EmphasisFlags enum.\n    builder.addBitFlagConstant(\"kEmphBit_Hilite\", 0);\n    builder.addBitFlagConstant(\"kEmphBit_Emphasize\", 1);\n    builder.addBitFlagConstant(\"kEmphBit_Flash\", 2);\n    builder.addBitFlagConstant(\"kEmphBit_NonLocatable\", 3);\n    builder.addConstant(\"kEmphFlag_Hilite\", 2 /* VariableType.Float */, \"1.0\");\n    builder.addConstant(\"kEmphFlag_Emphasize\", 2 /* VariableType.Float */, \"2.0\");\n    builder.addConstant(\"kEmphFlag_Flash\", 2 /* VariableType.Float */, \"4.0\");\n    builder.addConstant(\"kEmphFlag_NonLocatable\", 2 /* VariableType.Float */, \"8.0\");\n}\nfunction addHiliteSettings(frag, wantFlashMode) {\n    frag.addUniform(\"u_hilite_settings\", 6 /* VariableType.Mat3 */, (prog) => {\n        prog.addProgramUniform(\"u_hilite_settings\", (uniform, params) => {\n            params.target.uniforms.hilite.bindFeatureSettings(uniform);\n        });\n    });\n    if (wantFlashMode) {\n        frag.addUniform(\"u_flash_mode\", 2 /* VariableType.Float */, (prog) => {\n            prog.addGraphicUniform(\"u_flash_mode\", (uniform, params) => {\n                uniform.setUniform1f(params.geometry.getFlashMode(params));\n            });\n        });\n    }\n}\n// If feature is not hilited, discard it.\nconst checkVertexHiliteDiscard = \"return 0.0 == v_feature_hilited;\";\n// The result is a mask in which each pixel's r=1 if hilited and g=1 if emphasized (and not hilited).\nconst computeHiliteColor = `\r\n  float flags = floor(v_feature_hilited + 0.5);\r\n  float hilited = extractNthBit(flags, kEmphBit_Hilite);\r\n  float emphasized = extractNthBit(flags, kEmphBit_Emphasize);\r\n  return vec4(hilited, emphasized, 0.0, 0.0);\r\n`;\nconst computeSurfaceHiliteColor = `\r\n  if (isSurfaceBitSet(kSurfaceBit_HasTexture) && TEXTURE(s_texture, v_texCoord).a <= 0.15)\r\n    return vec4(0.0);\r\n${computeHiliteColor}`;\nconst computeHiliteOverrides = `\r\n  vec4 value = getFirstFeatureRgba();\r\n  float emphFlags = value.g * 256.0;\r\n  v_feature_hilited = kEmphFlag_Hilite * extractNthBit(emphFlags, kOvrBit_Hilited) + kEmphFlag_Emphasize * extractNthBit(emphFlags, kOvrBit_Emphasized);\r\n`;\nconst computeHiliteOverridesWithWeight = `${computeHiliteOverrides}\r\n  float flags = value.r * 256.0;\r\n  linear_feature_overrides = vec4(nthFeatureBitSet(flags, kOvrBit_Weight),\r\n  value.a * 256.0,\r\n  nthFeatureBitSet(flags, kOvrBit_LineCode),\r\n  value.b * 256.0);\r\n`;\n/** @internal */\nexport function addSurfaceHiliter(builder, wantWeight = false) {\n    addHiliter(builder, wantWeight);\n    builder.frag.set(1 /* FragmentShaderComponent.ComputeBaseColor */, computeSurfaceHiliteColor);\n}\n/** @internal */\nexport function addHiliter(builder, wantWeight = false) {\n    let opts = 4 /* FeatureSymbologyOptions.HasOverrides */;\n    if (wantWeight)\n        opts |= 1 /* FeatureSymbologyOptions.Weight */; // hiliter never needs line code or color...\n    if (!addCommon(builder, 2 /* FeatureMode.Overrides */, opts, wantWeight))\n        return;\n    builder.addVarying(\"v_feature_hilited\", 2 /* VariableType.Float */);\n    addEmphasisFlags(builder.vert);\n    builder.vert.set(3 /* VertexShaderComponent.ComputeFeatureOverrides */, wantWeight ? computeHiliteOverridesWithWeight : computeHiliteOverrides);\n    builder.vert.set(9 /* VertexShaderComponent.CheckForDiscard */, checkVertexHiliteDiscard);\n    addEmphasisFlags(builder.frag);\n    addExtractNthBit(builder.frag);\n    builder.frag.set(1 /* FragmentShaderComponent.ComputeBaseColor */, computeHiliteColor);\n    builder.frag.set(16 /* FragmentShaderComponent.AssignFragData */, assignFragColor);\n}\nfunction addSamplers(frag, testFeatureId) {\n    if (testFeatureId) {\n        frag.addUniform(\"u_pickFeatureId\", 8 /* VariableType.Sampler2D */, (prog) => {\n            prog.addProgramUniform(\"u_pickFeatureId\", (uniform, params) => {\n                params.target.compositor.featureIds.bindSampler(uniform, TextureUnit.PickFeatureId);\n            });\n        }, 3 /* VariablePrecision.High */);\n    }\n    frag.addUniform(\"u_pickDepthAndOrder\", 8 /* VariableType.Sampler2D */, (prog) => {\n        prog.addProgramUniform(\"u_pickDepthAndOrder\", (uniform, params) => {\n            params.target.compositor.depthAndOrder.bindSampler(uniform, TextureUnit.PickDepthAndOrder);\n        });\n    }, 3 /* VariablePrecision.High */);\n}\n/** @internal */\nexport const readDepthAndOrder = `\r\nvec2 readDepthAndOrder(vec2 tc) {\r\n  vec4 pdo = TEXTURE(u_pickDepthAndOrder, tc);\r\n  float order = floor(pdo.x * 16.0 + 0.5);\r\n  return vec2(order, decodeDepthRgb(pdo.yzw));\r\n}\r\n`;\nconst checkForEarlySurfaceDiscard = `\r\n  float factor = float(u_renderPass <= kRenderPass_Translucent); // never discard during specific passes\r\n  float term = 0.0;\r\n\r\n  vec2 tc = windowCoordsToTexCoords(gl_FragCoord.xy);\r\n  vec2 depthAndOrder = readDepthAndOrder(tc);\r\n\r\n  float surfaceDepth = computeLinearDepth(v_eyeSpace.z);\r\n  term += float(depthAndOrder.x > u_renderOrder && abs(depthAndOrder.y - surfaceDepth) < 4.0e-5);\r\n  return factor * term > 0.0;\r\n`;\nconst checkForEarlySurfaceDiscardWithFeatureID = `\r\n  // No normals => unlt => reality model => no edges.\r\n  if (u_renderPass > kRenderPass_Translucent || u_renderPass == kRenderPass_Layers || !u_surfaceFlags[kSurfaceBitIndex_HasNormals])\r\n    return false;\r\n\r\n  vec2 tc = windowCoordsToTexCoords(gl_FragCoord.xy);\r\n  vec2 depthAndOrder = readDepthAndOrder(tc);\r\n\r\n  if (depthAndOrder.x <= u_renderOrder)\r\n    return false;\r\n\r\n  // Calculate depthTolerance for letting edges show through their own surfaces\r\n  float perspectiveFrustum = step(kFrustumType_Perspective, u_frustum.z);\r\n  vec4 eyeDirAndWidthFactor = mix(vec4(0.0, 0.0, 1.0, u_pixelWidthFactor), vec4(normalize(-v_eyeSpace.xyz), -v_eyeSpace.z * u_pixelWidthFactor), perspectiveFrustum);\r\n  vec3 eyeDir = eyeDirAndWidthFactor.xyz;\r\n  float dtWidthFactor = eyeDirAndWidthFactor.w;\r\n\r\n  // Compute depth tolerance based on angle of triangle to screen\r\n  float isSilhouette = float(depthAndOrder.x == kRenderOrder_Silhouette);\r\n  float dSq = dot(eyeDir, v_n);\r\n  dSq *= 0.5 + 0.4 * (1.0 - isSilhouette);\r\n  dSq = dSq * dSq;\r\n  dSq = max(dSq, 0.0001);\r\n  dSq = min(dSq, 0.999);\r\n\r\n  float depthTolerance = dtWidthFactor * v_lineWeight * sqrt((1.0 - dSq) / dSq);\r\n  depthTolerance *= 1.0 + .333 * isSilhouette;\r\n\r\n  // Make sure stuff behind camera doesn't get pushed in front of it\r\n  depthTolerance = max(depthTolerance, 0.0);\r\n\r\n  // Convert depthTolerance from eye space to linear depth\r\n  depthTolerance /= (u_frustum.y - u_frustum.x);\r\n\r\n  float surfaceDepth = computeLinearDepth(v_eyeSpace.z);\r\n  float depthDelta = abs(depthAndOrder.y - surfaceDepth);\r\n  if (depthDelta > depthTolerance)\r\n    return false;\r\n\r\n  // Does pick buffer contain same feature?\r\n  vec4 featId = TEXTURE(u_pickFeatureId, tc);\r\n\r\n  // Converting to ints to test since varying floats can be interpolated incorrectly\r\n  ivec4 featId_i = ivec4(featId * 255.0 + 0.5);\r\n  ivec4 feature_id_i = ivec4(feature_id * 255.0 + 0.5);\r\n  if (featId_i == feature_id_i)\r\n    return true;\r\n\r\n  // In 2d, display priority controls draw order of different elements.\r\n  if (!u_checkInterElementDiscard)\r\n    return false;\r\n\r\n  // Use a tighter tolerance for two different elements since we're only fighting roundoff error.\r\n  return depthDelta <= 4.0e-5;\r\n`;\n// This only adds the constants that are actually used in shader code.\nexport function addRenderOrderConstants(builder) {\n    builder.addConstant(\"kRenderOrder_BlankingRegion\", 2 /* VariableType.Float */, 2 /* RenderOrder.BlankingRegion */.toFixed(1));\n    builder.addConstant(\"kRenderOrder_Linear\", 2 /* VariableType.Float */, 5 /* RenderOrder.Linear */.toFixed(1));\n    builder.addConstant(\"kRenderOrder_Edge\", 2 /* VariableType.Float */, 6 /* RenderOrder.Edge */.toFixed(1));\n    builder.addConstant(\"kRenderOrder_PlanarEdge\", 2 /* VariableType.Float */, 14 /* RenderOrder.PlanarEdge */.toFixed(1));\n    builder.addConstant(\"kRenderOrder_Silhouette\", 2 /* VariableType.Float */, 7 /* RenderOrder.Silhouette */.toFixed(1));\n    builder.addConstant(\"kRenderOrder_PlanarSilhouette\", 2 /* VariableType.Float */, 15 /* RenderOrder.PlanarSilhouette */.toFixed(1));\n    builder.addConstant(\"kRenderOrder_UnlitSurface\", 2 /* VariableType.Float */, 3 /* RenderOrder.UnlitSurface */.toFixed(1));\n    builder.addConstant(\"kRenderOrder_LitSurface\", 2 /* VariableType.Float */, 4 /* RenderOrder.LitSurface */.toFixed(1));\n    builder.addConstant(\"kRenderOrder_PlanarUnlitSurface\", 2 /* VariableType.Float */, 11 /* RenderOrder.PlanarUnlitSurface */.toFixed(1));\n    builder.addConstant(\"kRenderOrder_PlanarLitSurface\", 2 /* VariableType.Float */, 12 /* RenderOrder.PlanarLitSurface */.toFixed(1));\n    builder.addConstant(\"kRenderOrder_PlanarBit\", 2 /* VariableType.Float */, 8 /* RenderOrder.PlanarBit */.toFixed(1));\n    builder.addConstant(\"kRenderOrder_Background\", 2 /* VariableType.Float */, 1 /* RenderOrder.Background */.toFixed(1));\n}\n/** @internal */\nexport function addRenderOrder(builder) {\n    builder.addUniform(\"u_renderOrder\", 2 /* VariableType.Float */, (prog) => {\n        prog.addGraphicUniform(\"u_renderOrder\", (uniform, params) => {\n            const order = params.target.drawingBackgroundForReadPixels ? 1 /* RenderOrder.Background */ : params.geometry.renderOrder;\n            uniform.setUniform1f(order);\n        });\n    });\n}\nfunction addPixelWidthFactor(builder) {\n    builder.addUniform(\"u_pixelWidthFactor\", 2 /* VariableType.Float */, (prog) => {\n        prog.addGraphicUniform(\"u_pixelWidthFactor\", (uniform, params) => {\n            params.target.uniforms.bindPixelWidthFactor(uniform);\n        });\n    });\n}\nfunction addBatchId(builder) {\n    builder.addUniform(\"u_batch_id\", 5 /* VariableType.Vec4 */, (prog) => {\n        prog.addGraphicUniform(\"u_batch_id\", (uniform, params) => {\n            params.target.uniforms.batch.bindBatchId(uniform);\n        });\n    }, 3 /* VariablePrecision.High */);\n}\nconst computeIdVert = `v_feature_id = addUInt32s(u_batch_id, vec4(g_featureIndex, 0.0)) / 255.0;`;\nconst computeIdFrag = `\r\n  vec4 featureIndex = vec4(floor(v_feature_index + 0.5), 0.0);\r\n  feature_id = addUInt32s(u_batch_id, featureIndex) / 255.0;\r\n`;\n/** @internal */\nexport function addFeatureId(builder, computeInFrag) {\n    const vert = builder.vert;\n    const frag = builder.frag;\n    frag.addGlobal(\"feature_id\", 5 /* VariableType.Vec4 */);\n    if (!computeInFrag) {\n        vert.addFunction(addUInt32s);\n        addBatchId(vert);\n        builder.addInlineComputedVarying(\"v_feature_id\", 5 /* VariableType.Vec4 */, computeIdVert);\n        frag.addInitializer(\"feature_id = v_feature_id;\");\n    }\n    else {\n        frag.addFunction(addUInt32s);\n        builder.addInlineComputedVarying(\"v_feature_index\", 4 /* VariableType.Vec3 */, \"v_feature_index = g_featureIndex;\");\n        addBatchId(frag);\n        frag.addInitializer(computeIdFrag);\n    }\n}\n// Discard vertex if transparency is less than the display style's transparency threshold, IFF the specific bit is set. The bit is set if:\n//  - Solid Fill or Hidden Line mode; or\n//  - Shaded mode and generating shadow map (sufficiently transparent surfaces receive but do not cast shadows).\nconst isBelowTransparencyThreshold = `\r\n  return v_color.a < u_transparencyThreshold && u_surfaceFlags[kSurfaceBitIndex_TransparencyThreshold];\r\n`;\n/** @internal */\nexport function addSurfaceDiscard(builder, flags) {\n    const feat = flags.featureMode;\n    const isEdgeTestNeeded = flags.isEdgeTestNeeded;\n    const isClassified = flags.isClassified;\n    const computeIdInFrag = !flags.isTranslucent && 0 !== flags.isClassified && 2 /* FeatureMode.Overrides */ === feat;\n    const frag = builder.frag;\n    const vert = builder.vert;\n    vert.set(12 /* VertexShaderComponent.CheckForLateDiscard */, isBelowTransparencyThreshold);\n    vert.addUniform(\"u_transparencyThreshold\", 2 /* VariableType.Float */, (prog) => {\n        prog.addGraphicUniform(\"u_transparencyThreshold\", (uniform, params) => {\n            uniform.setUniform1f(params.target.currentTransparencyThreshold);\n        });\n    });\n    if (isEdgeTestNeeded) {\n        addWindowToTexCoords(frag);\n        if (!flags.isHilite)\n            addEyeSpace(builder);\n        if (0 /* FeatureMode.None */ === feat) {\n            addSamplers(frag, false);\n            frag.addFunction(computeLinearDepth);\n            frag.addFunction(decodeDepthRgb);\n            frag.addFunction(readDepthAndOrder);\n            frag.set(0 /* FragmentShaderComponent.CheckForEarlyDiscard */, checkForEarlySurfaceDiscard);\n        }\n        else {\n            frag.addUniform(\"u_checkInterElementDiscard\", 0 /* VariableType.Boolean */, (prog) => {\n                prog.addGraphicUniform(\"u_checkInterElementDiscard\", (uniform, params) => {\n                    uniform.setUniform1i(params.target.uniforms.branch.top.is3d ? 1 : 0);\n                });\n            });\n            addFeatureIndex(vert);\n            addLineWeight(vert);\n            addSamplers(frag, true);\n            addRenderOrderConstants(frag);\n            addPixelWidthFactor(frag);\n            frag.addFunction(computeLinearDepth);\n            frag.addFunction(decodeDepthRgb);\n            frag.addFunction(readDepthAndOrder);\n            frag.set(0 /* FragmentShaderComponent.CheckForEarlyDiscard */, checkForEarlySurfaceDiscardWithFeatureID);\n            builder.addInlineComputedVarying(\"v_lineWeight\", 2 /* VariableType.Float */, \"v_lineWeight = computeLineWeight();\");\n            addFeatureId(builder, computeIdInFrag);\n        }\n        addRenderOrder(frag);\n        addRenderPass(frag);\n    }\n    else if (isClassified && 0 /* FeatureMode.None */ !== feat) {\n        addFeatureIndex(vert);\n        addFeatureId(builder, computeIdInFrag);\n        if (!flags.isTranslucent)\n            addRenderOrder(frag);\n    }\n}\n// bool feature_invisible = false;\n// vec3 feature_rgb; // if not overridden, .r < 0; else rgb color override\n// float feature_alpha // alpha if overridden, else < 0\n// varying float v_feature_emphasis // bitmask - see kEmph_* constants\n// vec4 linear_feature_overrides; // x: weight overridden y: weight z: line code overridden w: line code\nconst computeFeatureOverrides = `\r\n  feature_rgb = vec3(-1.0);\r\n  feature_alpha = -1.0;\r\n  vec4 value = getFirstFeatureRgba();\r\n\r\n  float emphFlags = value.y * 256.0;\r\n  v_feature_emphasis = kEmphFlag_Hilite * extractNthBit(emphFlags, kOvrBit_Hilited) + kEmphFlag_Emphasize * extractNthBit(emphFlags, kOvrBit_Emphasized);\r\n\r\n  float flags = value.x * 256.0;\r\n  if (0.0 == flags)\r\n    return; // nothing overridden for this feature\r\n\r\n  bool nonLocatable = (u_shaderFlags[kShaderBit_IgnoreNonLocatable] ? nthFeatureBitSet(flags, kOvrBit_NonLocatable) : false);\r\n  v_feature_emphasis += kEmphFlag_NonLocatable * float(nthFeatureBitSet(flags, kOvrBit_NonLocatable));\r\n  bool invisible = nthFeatureBitSet(flags, kOvrBit_Visibility);\r\n  feature_invisible = invisible || nonLocatable;\r\n  if (feature_invisible)\r\n    return;\r\n\r\n  bool rgbOverridden = nthFeatureBitSet(flags, kOvrBit_Rgb);\r\n  bool alphaOverridden = nthFeatureBitSet(flags, kOvrBit_Alpha);\r\n  if (alphaOverridden || rgbOverridden) {\r\n    vec4 rgba = getSecondFeatureRgba();\r\n    if (rgbOverridden)\r\n      feature_rgb = rgba.rgb;\r\n\r\n    if (alphaOverridden) {\r\n      feature_alpha = rgba.a;\r\n      feature_viewIndependentTransparency = nthFeatureBitSet(emphFlags, kOvrBit_ViewIndependentTransparency);\r\n    }\r\n  }\r\n\r\n  linear_feature_overrides = vec4(nthFeatureBitSet(flags, kOvrBit_Weight),\r\n                                  value.w * 256.0,\r\n                                  nthFeatureBitSet(flags, kOvrBit_LineCode),\r\n                                  value.z * 256.0);\r\n\r\n  feature_ignore_material = nthFeatureBitSet(flags, kOvrBit_IgnoreMaterial);\r\n  use_material = use_material && !feature_ignore_material;\r\n\r\n  v_feature_emphasis += kEmphFlag_Flash * extractNthFeatureBit(flags, kOvrBit_Flashed);\r\n`;\n// feature_rgb.r = -1.0 if rgb color not overridden for feature.\n// feature_alpha = -1.0 if alpha not overridden for feature.\nconst applyFeatureColor = `\r\n  vec3 rgb = mix(baseColor.rgb, feature_rgb.rgb, step(0.0, feature_rgb.r));\r\n  float alpha = mix(baseColor.a, feature_alpha, step(0.0, feature_alpha));\r\n  return vec4(rgb, alpha);\r\n`;\n// feature_rgb.r = -1.0 if rgb color not overridden for feature, else mix based on u_overrrideColorMix.\n// feature_alpha = -1.0 if alpha not overridden for feature.\nexport const mixFeatureColor = `\r\n  vec3 rgb = mix(baseColor.rgb, mix(baseColor.rgb, feature_rgb.rgb, u_overrideColorMix), step(0.0, feature_rgb.r));\r\n  float alpha = mix(baseColor.a, feature_alpha, step(0.0, feature_alpha));\r\n  return vec4(rgb, alpha);\r\n  `;\nconst applyFlash = `\r\n  float flashHilite = floor(v_feature_emphasis + 0.5);\r\n  return doApplyFlash(flashHilite, baseColor);\r\n`;\nconst doApplyFlash = `\r\nvec4 doApplyFlash(float flags, vec4 baseColor) {\r\n  bool isFlashed = nthBitSet(flags, kEmphBit_Flash);\r\n  bool isHilited = nthBitSet(flags, kEmphBit_Hilite);\r\n  bool isEmphasized = !isHilited && nthBitSet(flags, kEmphBit_Emphasize);\r\n  vec3 hiliteRgb = isEmphasized ? u_hilite_settings[1] : u_hilite_settings[0];\r\n\r\n  isHilited = isEmphasized || isHilited;\r\n  float hiliteRatio = isHilited ? (isEmphasized ? u_hilite_settings[2][1] : u_hilite_settings[2][0]) : 0.0;\r\n  baseColor.rgb = mix(baseColor.rgb, hiliteRgb, hiliteRatio);\r\n\r\n  const float maxBrighten = 0.2;\r\n  float brighten = isFlashed ? u_flash_intensity * maxBrighten : 0.0;\r\n  vec3 brightRgb = baseColor.rgb + brighten;\r\n\r\n  const float maxTween = 0.75;\r\n  float hiliteFraction = isFlashed ? u_flash_intensity * maxTween : 0.0;\r\n  vec3 tweenRgb = baseColor.rgb * (1.0 - hiliteFraction);\r\n  tweenRgb += u_hilite_settings[0] * hiliteFraction;\r\n\r\n  return vec4(mix(tweenRgb, brightRgb, u_flash_mode), baseColor.a);\r\n}\r\n`;\nconst doClassifierFlash = `\r\nvec4 applyClassifierFlash(vec4 baseColor) {\r\n  const float maxBrighten = 0.2;\r\n  float brighten = u_flash_intensity * maxBrighten;\r\n  vec3 brightRgb = baseColor.rgb + brighten;\r\n  return vec4(brightRgb, baseColor.a);\r\n}\r\n`;\n/** @internal */\nexport function addClassifierFlash(frag) {\n    addFlashIntensity(frag);\n    addHiliteSettings(frag, false);\n    frag.addFunction(doClassifierFlash);\n}\nfunction addFlashIntensity(frag) {\n    frag.addUniform(\"u_flash_intensity\", 2 /* VariableType.Float */, (prog) => {\n        prog.addProgramUniform(\"u_flash_intensity\", (uniform, params) => {\n            uniform.setUniform1f(params.target.flashIntensity);\n        });\n    });\n}\nfunction addApplyFlash(frag) {\n    addHiliteSettings(frag, true);\n    addEmphasisFlags(frag);\n    addExtractNthBit(frag);\n    frag.addFunction(doApplyFlash);\n    frag.set(11 /* FragmentShaderComponent.ApplyFlash */, applyFlash);\n    addFlashIntensity(frag);\n}\n/** @internal */\nexport function addFeatureSymbology(builder, feat, opts) {\n    if (!addCommon(builder, feat, opts) || 0 /* FeatureSymbologyOptions.None */ === opts)\n        return;\n    assert((4 /* FeatureSymbologyOptions.HasOverrides */ | 8 /* FeatureSymbologyOptions.Color */) === (opts & (4 /* FeatureSymbologyOptions.HasOverrides */ | 8 /* FeatureSymbologyOptions.Color */)));\n    builder.addGlobal(\"feature_rgb\", 4 /* VariableType.Vec3 */);\n    builder.addGlobal(\"feature_alpha\", 2 /* VariableType.Float */);\n    builder.addVarying(\"v_feature_emphasis\", 2 /* VariableType.Float */);\n    const vert = builder.vert;\n    vert.addGlobal(\"feature_invisible\", 0 /* VariableType.Boolean */, \"false\");\n    vert.addGlobal(\"feature_viewIndependentTransparency\", 0 /* VariableType.Boolean */, \"false\");\n    addEmphasisFlags(vert);\n    vert.addGlobal(\"use_material\", 0 /* VariableType.Boolean */, \"true\");\n    vert.set(3 /* VertexShaderComponent.ComputeFeatureOverrides */, computeFeatureOverrides);\n    vert.set(7 /* VertexShaderComponent.ApplyFeatureColor */, applyFeatureColor);\n    addApplyFlash(builder.frag);\n}\n/** If we're running the hilite shader for a uniform feature, it follows that the feature must be hilited.\n * So the hilite shader simply needs to output '1' for every fragment.\n * @internal\n */\nexport function addUniformHiliter(builder) {\n    builder.frag.addUniform(\"v_feature_hilited\", 2 /* VariableType.Float */, (prog) => {\n        prog.addGraphicUniform(\"v_feature_hilited\", (uniform, params) => {\n            params.target.uniforms.batch.bindUniformSymbologyFlags(uniform);\n        });\n    });\n    addEmphasisFlags(builder.frag);\n    addExtractNthBit(builder.frag);\n    builder.frag.set(1 /* FragmentShaderComponent.ComputeBaseColor */, computeHiliteColor);\n    builder.frag.set(16 /* FragmentShaderComponent.AssignFragData */, assignFragColor);\n}\n/** For a uniform feature table, the feature ID output to pick buffers is equal to the batch ID.\n * The following symbology overrides are supported:\n *  - Visibility - implcitly, because if the feature is invisible its geometry will never be drawn.\n *  - Flash\n *  - Hilite\n *  - Color and Transparency- only for point clouds currently which set addFeatureColor to true.\n * This shader could be simplified, but want to share code with the non-uniform versions...hence uniforms/globals with \"v_\" prefix typically used for varyings on no prefix...\n * @internal\n */\nexport function addUniformFeatureSymbology(builder, addFeatureColor) {\n    builder.vert.addGlobal(\"g_featureIndex\", 4 /* VariableType.Vec3 */, \"vec3(0.0)\", true);\n    builder.frag.addUniform(\"v_feature_emphasis\", 2 /* VariableType.Float */, (prog) => {\n        prog.addGraphicUniform(\"v_feature_emphasis\", (uniform, params) => {\n            params.target.uniforms.batch.bindUniformSymbologyFlags(uniform);\n        });\n    });\n    if (addFeatureColor) {\n        builder.vert.addUniform(\"feature_rgb\", 4 /* VariableType.Vec3 */, (prog) => {\n            prog.addGraphicUniform(\"feature_rgb\", (uniform, params) => {\n                params.target.uniforms.batch.bindUniformColorOverride(uniform);\n            });\n        });\n        builder.vert.addUniform(\"feature_alpha\", 2 /* VariableType.Float */, (prog) => {\n            prog.addGraphicUniform(\"feature_alpha\", (uniform, params) => {\n                params.target.uniforms.batch.bindUniformTransparencyOverride(uniform);\n            });\n        });\n        builder.vert.set(7 /* VertexShaderComponent.ApplyFeatureColor */, applyFeatureColor);\n        addAlpha(builder.vert);\n        addMaxAlpha(builder.vert);\n        addRenderPass(builder.vert);\n        addTransparencyDiscardFlags(builder.vert);\n        builder.vert.set(9 /* VertexShaderComponent.CheckForDiscard */, checkVertexDiscard);\n    }\n    else {\n        builder.vert.set(9 /* VertexShaderComponent.CheckForDiscard */, \"return feature_invisible;\");\n    }\n    // Non-Locatable...  Discard if picking\n    builder.vert.addUniform(\"feature_invisible\", 0 /* VariableType.Boolean */, (prog) => {\n        prog.addGraphicUniform(\"feature_invisible\", (uniform, params) => {\n            params.target.uniforms.batch.bindUniformNonLocatable(uniform, params.target.drawNonLocatable);\n        });\n    });\n    builder.vert.addGlobal(\"feature_viewIndependentTransparency\", 0 /* VariableType.Boolean */, \"false\");\n    addApplyFlash(builder.frag);\n}\n//# sourceMappingURL=FeatureSymbology.js.map",
      "start": 1693508124667,
      "end": 1693508124753,
      "sourcemaps": null
    }
  ]
}
