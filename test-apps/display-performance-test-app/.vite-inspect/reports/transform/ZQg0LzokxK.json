{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/topology/HalfEdgeGraphSearch.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Topology\n */\nimport { HalfEdgeGraph, HalfEdgeMask } from \"./Graph\";\nimport { SignedDataSummary } from \"./SignedDataSummary\";\nimport { XYParitySearchContext } from \"./XYParitySearchContext\";\n/**\n */\nexport class HalfEdgeMaskTester {\n    /**\n     *\n     * @param mask mask to test in `testEdge` function\n     * @param targetValue value to match for true return\n     */\n    constructor(mask, targetValue = true) {\n        this._targetMask = mask;\n        this._targetValue = targetValue;\n    }\n    /** Return true if the value of the targetMask matches the targetValue */\n    testEdge(edge) {\n        return edge.isMaskSet(this._targetMask) === this._targetValue;\n    }\n}\n// Search services for HalfEdgeGraph\nexport class HalfEdgeGraphSearch {\n    /**\n     * * for each node of face, set the mask push to allNodesStack\n     * * push the faceSeed on onePerFaceStack[]\n     */\n    static pushAndMaskAllNodesInFace(faceSeed, mask, allNodeStack, onePerFaceStack) {\n        onePerFaceStack.push(faceSeed);\n        faceSeed.collectAroundFace((node) => {\n            node.setMask(mask);\n            allNodeStack.push(node);\n        });\n    }\n    /**\n     * Search an array of faceSeed nodes for the face with the most negative area.\n     * @param oneCandidateNodePerFace array containing one node from each face to be considered.\n     * @returns node on the minimum area face, or undefined if no such face (e.g., all faces have zero area).\n     */\n    static findMinimumAreaFace(oneCandidateNodePerFace, faceAreaFunction) {\n        const summary = HalfEdgeGraphSearch.collectFaceAreaSummary(oneCandidateNodePerFace, false, faceAreaFunction);\n        return summary.largestNegativeItem;\n    }\n    /**\n     * static method for face area computation -- useful as function parameter in collect FaceAreaSummary.\n     * * This simply calls `node.signedFaceArea ()`\n     * @param node instance for signedFaceArea call.\n     */\n    static signedFaceArea(node) { return node.signedFaceArea(); }\n    /**\n     *\n     * Return a summary structure data about face (or other numeric quantity if the caller's areaFunction returns other value)\n     * * The default areaFunction computes area of polygonal face.\n     * * Callers with curved edge graphs must supply their own area function.\n     * @param source graph or array of nodes to examine\n     * @param collectAllNodes flag to pass to the SignedDataSummary constructor to control collection of nodes.\n     * @param areaFunction function to all to obtain area (or other numeric value)\n     */\n    static collectFaceAreaSummary(source, collectAllNodes = false, areaFunction = (node) => HalfEdgeGraphSearch.signedFaceArea(node)) {\n        const result = new SignedDataSummary(collectAllNodes);\n        let allFaces;\n        if (source instanceof HalfEdgeGraph)\n            allFaces = source.collectFaceLoops();\n        else\n            allFaces = source;\n        for (const node of allFaces) {\n            const area = areaFunction(node);\n            result.announceItem(node, area);\n        }\n        return result;\n    }\n    /**\n     * * Test if the graph is triangulated.\n     * * Return false if:\n     *   * Positive area face with more than 3 edges\n     *   * more than 1 negative area face with `allowMultipleNegativeAreaFaces` false\n     * * 2-edge faces are ignored.\n     */\n    static isTriangulatedCCW(source, allowMultipleNegativeAreaFaces = true, numPositiveExceptionsAllowed = 0) {\n        let allFaces;\n        if (source instanceof HalfEdgeGraph)\n            allFaces = source.collectFaceLoops();\n        else\n            allFaces = source;\n        let numNegative = 0;\n        let numPositiveExceptions = 0;\n        for (const node of allFaces) {\n            const numEdges = node.countEdgesAroundFace();\n            if (numEdges >= 3) {\n                const area = node.signedFaceArea();\n                if (area > 0) {\n                    if (numEdges > 3) {\n                        numPositiveExceptions++;\n                        if (numPositiveExceptions > numPositiveExceptionsAllowed)\n                            return false;\n                    }\n                }\n                else {\n                    numNegative++;\n                    if (numNegative > 1) {\n                        if (!allowMultipleNegativeAreaFaces)\n                            return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n    /**\n     * Search to all accessible faces from given seed.\n     * * The returned array contains one representative node in each face of the connected component.\n     * * If (nonnull) parity mask is given, on return:\n     *    * It is entirely set or entirely clear around each face\n     *    * It is entirely set on all faces that are an even number of face-to-face steps away from the seed.\n     *    * It is entirely clear on all faces that are an odd number of face-to-face steps away from the seed.\n     * @param seedEdge first edge to search.\n     * @param visitMask mask applied to all faces as visited.\n     * @param parityMask mask to apply (a) to first face, (b) to faces with alternating parity during the search.\n     */\n    static parityFloodFromSeed(seedEdge, visitMask, parityEdgeTester, parityMask) {\n        const faces = [];\n        if (seedEdge.isMaskSet(visitMask))\n            return faces; // empty\n        const allMasks = parityMask | visitMask;\n        const stack = [];\n        // arbitrarily call the seed face exterior ... others will alternate as visited.\n        HalfEdgeGraphSearch.pushAndMaskAllNodesInFace(seedEdge, allMasks, stack, faces); // Start with exterior as mask\n        while (stack.length > 0) {\n            const p = stack.pop();\n            const mate = p.edgeMate;\n            if (!mate)\n                continue;\n            if (!mate.isMaskSet(visitMask)) {\n                let newState = p.isMaskSet(parityMask);\n                if (!parityEdgeTester || parityEdgeTester.testEdge(p))\n                    newState = !newState;\n                HalfEdgeGraphSearch.pushAndMaskAllNodesInFace(mate, newState ? allMasks : visitMask, stack, faces);\n            }\n        }\n        return faces;\n    }\n    /**\n     * * Search the given faces for the one with the minimum area.\n     * * If the mask in that face is OFF, toggle it on (all half edges of) all the faces.\n     * * In a properly merged planar subdivision there should be only one true negative area face per component.\n     * @param graph parent graph\n     * @param parityMask mask which was previously set with alternating parity, but with an arbitrary start face.\n     * @param faces array of faces to search.\n     */\n    static correctParityInSingleComponent(_graph, mask, faces) {\n        const exteriorHalfEdge = HalfEdgeGraphSearch.findMinimumAreaFace(faces);\n        if (!exteriorHalfEdge) {\n        }\n        else if (exteriorHalfEdge.isMaskSet(mask)) {\n            // all should be well .. nothing to do.\n        }\n        else {\n            // TOGGLE around the face (assuming all are consistent with the seed)\n            for (const faceSeed of faces) {\n                if (faceSeed.isMaskSet(mask)) {\n                    faceSeed.clearMaskAroundFace(mask);\n                }\n                else {\n                    faceSeed.setMaskAroundFace(mask);\n                }\n            }\n        }\n    }\n    /** Apply correctParityInSingleComponent to each array in components. (Quick exit if mask in NULL_MASK) */\n    static correctParityInComponentArrays(graph, mask, components) {\n        if (mask === HalfEdgeMask.NULL_MASK)\n            return;\n        for (const facesInComponent of components)\n            HalfEdgeGraphSearch.correctParityInSingleComponent(graph, mask, facesInComponent);\n    }\n    /**\n     * Collect arrays gathering faces by connected component.\n     * @param graph graph to inspect\n     * @param parityEdgeTester (optional) function to test if an edge is a parity change (e.g., a boundary edge).\n     * @param parityMask (optional, along with parityEdgeTester) mask to apply indicating parity.  If this is Mask.NULL_MASK, there is no record of parity.\n     */\n    static collectConnectedComponentsWithExteriorParityMasks(graph, parityEdgeTester, parityMask = HalfEdgeMask.NULL_MASK) {\n        const components = [];\n        const visitMask = HalfEdgeMask.VISITED;\n        const allMasks = parityMask | visitMask;\n        graph.clearMask(allMasks);\n        for (const faceSeed of graph.allHalfEdges) {\n            if (!faceSeed.isMaskSet(HalfEdgeMask.VISITED)) {\n                const newFaces = HalfEdgeGraphSearch.parityFloodFromSeed(faceSeed, visitMask, parityEdgeTester, parityMask);\n                components.push(newFaces);\n            }\n        }\n        HalfEdgeGraphSearch.correctParityInComponentArrays(graph, parityMask, components);\n        return components;\n    }\n    /**\n     * Test if (x,y) is inside (1), on an edge (0) or outside (-1) a face.\n     * @param seedNode any node on the face loop\n     * @param x x coordinate of test point.\n     * @param y y coordinate of test point.\n     */\n    static pointInOrOnFaceXY(seedNode, x, y) {\n        const context = new XYParitySearchContext(x, y);\n        // walk around looking for an accepted node to start the search (seedNode is usually ok!)\n        let nodeA = seedNode;\n        let nodeB = seedNode.faceSuccessor;\n        for (;; nodeA = nodeB) {\n            if (context.tryStartEdge(nodeA.x, nodeA.y, nodeB.x, nodeB.y))\n                break;\n            if (nodeB === seedNode) {\n                // umm.. the face is all on the x axis?\n                return context.classifyCounts();\n            }\n            nodeB = nodeA.faceSuccessor;\n        }\n        // nodeB is the real start node for search ... emit ends of each edge around the face,\n        //   stopping after emitting nodeB as an edge end.\n        let node = nodeB.faceSuccessor;\n        for (;;) {\n            if (!context.advance(node.x, node.y)) {\n                return context.classifyCounts();\n            }\n            if (node === nodeB)\n                break;\n            node = node.faceSuccessor;\n        }\n        return context.classifyCounts();\n    }\n    /**\n     * Announce nodes that are \"extended face boundary\" by conditions (usually mask of node and mate) in test functions.\n     * * After each node, the next candidate in reached by looking \"around the head vertex loop\" for the next boundary.\n     *   * \"Around the vertex\" from nodeA means\n     *      * First look at nodeA.faceSuccessor;\n     *      * Then look at vertexPredecessor around that vertex loop.\n     * * Each accepted node is passed to announceNode, and marked with the visit mask.\n     * * The counter of the announceEdge function is zero for the first edge, then increases with each edge.\n     * @param seed start node.\n     * @param isBoundaryEdge\n     * @param announceEdge\n     */\n    static collectExtendedBoundaryLoopFromSeed(seed, visitMask, isBoundaryEdge, announceEdge) {\n        let counter = 0;\n        while (!seed.getMask(visitMask) && isBoundaryEdge(seed)) {\n            announceEdge(seed, counter++);\n            seed.setMask(visitMask);\n            const vertexBase = seed.faceSuccessor;\n            let candidateAroundVertex = vertexBase;\n            for (;;) {\n                if (candidateAroundVertex.getMask(visitMask))\n                    return;\n                if (isBoundaryEdge(candidateAroundVertex)) {\n                    seed = candidateAroundVertex;\n                    break;\n                }\n                candidateAroundVertex = candidateAroundVertex.vertexPredecessor;\n                if (candidateAroundVertex === vertexBase)\n                    break;\n            }\n        }\n    }\n    /**\n     * Collect arrays of nodes \"around the boundary\" of a graph with extraneous (non-boundary) edges.\n     * * The \"boundary\" is nodes that do NOT have the exterior mask, but whose mates DO have the exterior mask.\n     * * After each node, the next candidate in reached by looking \"around the head vertex loop\" for the next boundary.\n     *   * \"Around the vertex\" from nodeA means\n     *      * First look at nodeA.faceSuccessor;\n     *      * Then look at vertexPredecessor around that vertex loop.\n     * * Each accepted node is passed to announceNode, and marked with the visit mask.\n     * @param seed start node.\n     * @param isBoundaryNode\n     * @param announceNode\n     */\n    static collectExtendedBoundaryLoopsInGraph(graph, exteriorMask) {\n        const loops = [];\n        const visitMask = graph.grabMask(true);\n        const isBoundaryEdge = (edge) => {\n            return edge.getMask(exteriorMask) === 0 && edge.edgeMate.getMask(exteriorMask) !== 0;\n        };\n        const announceEdgeInBoundary = (edge, counter) => {\n            if (counter === 0)\n                loops.push([]);\n            loops[loops.length - 1].push(edge);\n        };\n        for (const seed of graph.allHalfEdges) {\n            this.collectExtendedBoundaryLoopFromSeed(seed, visitMask, isBoundaryEdge, announceEdgeInBoundary);\n        }\n        graph.dropMask(visitMask);\n        return loops;\n    }\n}\n//# sourceMappingURL=HalfEdgeGraphSearch.js.map",
      "start": 1693508124162,
      "end": 1693508124301,
      "sourcemaps": null
    }
  ]
}
