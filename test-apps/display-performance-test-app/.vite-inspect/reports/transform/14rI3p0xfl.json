{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/curve/ProxyCurve.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Curve\n */\nimport { CurvePrimitive } from \"../curve/CurvePrimitive\";\n/**\n * A ProxyCurve is expected to be used as a base class for curve types that use some existing curve (the proxy)\n * for evaluation and display but carry other defining data.\n * * The ProxyCurve implements all required CurvePrimitive methods by dispatching to the proxy.\n * * These methods presumably require support from the application class and are left abstract:\n *    * clone\n *    * curvePrimitiveType\n *    * isSameCurvePrimitiveType\n *    * isSameGeometryClass\n *    * tryTransformInPlace\n *    * reverseInPlace\n *\n * @public\n */\nexport class ProxyCurve extends CurvePrimitive {\n    dispatchToGeometryHandler(handler) {\n        return this._proxyCurve.dispatchToGeometryHandler(handler);\n    }\n    /** Constructor CAPTURES the proxyCurve pointer */\n    constructor(proxyCurve) {\n        super();\n        this._proxyCurve = proxyCurve;\n    }\n    /** Return the (pointer to) the proxy curve. */\n    get proxyCurve() {\n        return this._proxyCurve;\n    }\n    /** Implement by proxyCurve */\n    computeStrokeCountForOptions(options) {\n        return this._proxyCurve.computeStrokeCountForOptions(options);\n    }\n    /** Implement by proxyCurve */\n    emitStrokableParts(dest, options) {\n        this._proxyCurve.emitStrokableParts(dest, options);\n    }\n    /** Return a transformed clone. */\n    cloneTransformed(transform) {\n        const myClone = this.clone();\n        if (myClone.tryTransformInPlace(transform))\n            return myClone;\n        return undefined;\n    }\n    /** Implement by proxyCurve. Subclasses may eventually override this default implementation. */\n    clonePartialCurve(fractionA, fractionB) {\n        return this._proxyCurve.clonePartialCurve(fractionA, fractionB);\n    }\n    /** Implement by proxyCurve */\n    emitStrokes(dest, options) {\n        this._proxyCurve.emitStrokes(dest, options);\n    }\n    /** Implement by proxyCurve */\n    extendRange(rangeToExtend, transform) {\n        this._proxyCurve.extendRange(rangeToExtend, transform);\n    }\n    /** Implement by proxyCurve */\n    range(transform, result) {\n        return this._proxyCurve.range(transform, result);\n    }\n    /** Implement by proxyCurve */\n    fractionToPoint(fraction, result) {\n        return this._proxyCurve.fractionToPoint(fraction, result);\n    }\n    /** Implement by proxyCurve */\n    fractionToPointAndDerivative(fraction, result) {\n        return this._proxyCurve.fractionToPointAndDerivative(fraction, result);\n    }\n    /** Implement by proxyCurve */\n    fractionToPointAnd2Derivatives(fraction, result) {\n        return this._proxyCurve.fractionToPointAnd2Derivatives(fraction, result);\n    }\n    /** Implement by proxyCurve */\n    isInPlane(plane) {\n        return this._proxyCurve.isInPlane(plane);\n    }\n    /** Implement by proxyCurve */\n    quickLength() {\n        return this._proxyCurve.quickLength();\n    }\n    /** Implement by proxyCurve */\n    constructOffsetXY(offsetDistanceOrOptions) {\n        return this._proxyCurve.constructOffsetXY(offsetDistanceOrOptions);\n    }\n    /** Implement by proxyCurve */\n    projectedParameterRange(ray, lowHigh) {\n        return this._proxyCurve.projectedParameterRange(ray, lowHigh);\n    }\n}\n//# sourceMappingURL=ProxyCurve.js.map",
      "start": 1693508122829,
      "end": 1693508122994,
      "sourcemaps": null
    }
  ]
}
