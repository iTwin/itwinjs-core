{
  "resolvedId": "D:/hub2023A/itwinjs-core/ui/appui-abstract/lib/esm/appui-abstract/utils/UiEventDispatcher.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Utilities\n */\n// cSpell:ignore configurableui\nimport { UiEvent } from \"./UiEvent\";\n/** UiSync Event class.\n * @public\n */\nexport class UiSyncEvent extends UiEvent {\n}\n/** This class is used to send eventIds to interested UI components so the component can determine if it needs\n * to refresh its display by calling setState on itself.\n * @public\n */\nexport class UiEventDispatcher {\n    constructor() {\n        this._eventIds = new Set();\n        this._eventIdAdded = false;\n        this._uiSyncEvent = new UiSyncEvent();\n        this._timeoutPeriod = 100;\n        this._secondaryTimeoutPeriod = this._timeoutPeriod / 2;\n    }\n    /** @internal - used for testing only */\n    /* istanbul ignore next */\n    setTimeoutPeriod(period) {\n        this._timeoutPeriod = period;\n        this._secondaryTimeoutPeriod = Math.floor(this._timeoutPeriod / 2);\n        if (this._secondaryTimeoutPeriod < 1)\n            this._secondaryTimeoutPeriod = 1;\n        if (this._syncEventTimerId) {\n            window.clearTimeout(this._syncEventTimerId);\n            this._syncEventTimerId = undefined;\n        }\n        if (this._eventIds)\n            this._eventIds.clear();\n        this._eventIdAdded = false;\n    }\n    /** The current timeout period */\n    get timeoutPeriod() {\n        return this._timeoutPeriod;\n    }\n    /** Return set of event ids that will be sent to listeners/. */\n    get syncEventIds() {\n        return this._eventIds;\n    }\n    /** Return UiSyncEvent so callers can register an event callback. */\n    get onSyncUiEvent() {\n        return this._uiSyncEvent;\n    }\n    /** Immediately trigger sync event processing. */\n    dispatchImmediateSyncUiEvent(eventId) {\n        const eventIds = new Set();\n        eventIds.add(eventId.toLowerCase());\n        this.onSyncUiEvent.emit({ eventIds });\n    }\n    /** Save eventId in Set for processing. */\n    dispatchSyncUiEvent(eventId) {\n        // istanbul ignore if\n        if (0 === this._timeoutPeriod) {\n            return;\n        }\n        this.syncEventIds.add(eventId.toLowerCase());\n        if (!this._syncEventTimerId) { // if there is not a timer active, create one\n            this._syncEventTimerId = window.setTimeout(() => { this.checkForAdditionalIds(); }, this._timeoutPeriod);\n        }\n        else {\n            this._eventIdAdded = true;\n        }\n    }\n    /** Save multiple eventIds in Set for processing. */\n    dispatchSyncUiEvents(eventIds) {\n        // istanbul ignore if\n        if (0 === this._timeoutPeriod) {\n            return;\n        }\n        eventIds.forEach((id) => this.syncEventIds.add(id.toLowerCase()));\n        // istanbul ignore else\n        if (!this._syncEventTimerId) { // if there is not a timer active, create one\n            this._syncEventTimerId = window.setTimeout(() => { this.checkForAdditionalIds(); }, this._timeoutPeriod);\n        }\n        else {\n            this._eventIdAdded = true;\n        }\n    }\n    /** Trigger registered event processing when timer has expired and no addition eventId are added. */\n    checkForAdditionalIds() {\n        /* istanbul ignore else */\n        if (!this._eventIdAdded) {\n            // istanbul ignore else\n            if (this._syncEventTimerId) {\n                window.clearTimeout(this._syncEventTimerId);\n                this._syncEventTimerId = undefined;\n            }\n            this._eventIdAdded = false;\n            // istanbul ignore else\n            if (this.syncEventIds.size > 0) {\n                const eventIds = new Set();\n                this.syncEventIds.forEach((value) => eventIds.add(value));\n                this._eventIds.clear();\n                this.onSyncUiEvent.emit({ eventIds });\n            }\n            return;\n        }\n        // istanbul ignore next\n        if (this._syncEventTimerId) {\n            window.clearTimeout(this._syncEventTimerId);\n            this._syncEventTimerId = undefined;\n        }\n        // istanbul ignore next\n        this._eventIdAdded = false;\n        // if events have been added before the initial timer expired wait half that time to see if events are still being added.\n        // istanbul ignore next\n        this._syncEventTimerId = window.setTimeout(() => { this.checkForAdditionalIds(); }, this._secondaryTimeoutPeriod);\n    }\n    /** Checks to see if an eventId of interest is contained in the set of eventIds */\n    hasEventOfInterest(eventIds, idsOfInterest) {\n        /* istanbul ignore else */\n        if ((idsOfInterest.length > 0) && idsOfInterest.some((value) => eventIds.has(value.toLowerCase())))\n            return true;\n        return false;\n    }\n}\n//# sourceMappingURL=UiEventDispatcher.js.map",
      "start": 1693508123611,
      "end": 1693508123646,
      "sourcemaps": null
    }
  ]
}
