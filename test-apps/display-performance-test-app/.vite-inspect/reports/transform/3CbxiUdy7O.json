{
  "resolvedId": "D:/hub2023A/itwinjs-core/common/temp/node_modules/.pnpm/@loaders.gl+schema@3.4.7/node_modules/@loaders.gl/schema/dist/esm/lib/batches/table-batch-builder.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport BaseTableBatchAggregator from './base-table-batch-aggregator';\nimport RowTableBatchAggregator from './row-table-batch-aggregator';\nimport ColumnarTableBatchAggregator from './columnar-table-batch-aggregator';\nconst DEFAULT_OPTIONS = {\n  shape: 'array-row-table',\n  batchSize: 'auto',\n  batchDebounceMs: 0,\n  limit: 0,\n  _limitMB: 0\n};\nconst ERR_MESSAGE = 'TableBatchBuilder';\nexport default class TableBatchBuilder {\n  constructor(schema, options) {\n    _defineProperty(this, \"schema\", void 0);\n    _defineProperty(this, \"options\", void 0);\n    _defineProperty(this, \"aggregator\", null);\n    _defineProperty(this, \"batchCount\", 0);\n    _defineProperty(this, \"bytesUsed\", 0);\n    _defineProperty(this, \"isChunkComplete\", false);\n    _defineProperty(this, \"lastBatchEmittedMs\", Date.now());\n    _defineProperty(this, \"totalLength\", 0);\n    _defineProperty(this, \"totalBytes\", 0);\n    _defineProperty(this, \"rowBytes\", 0);\n    this.schema = schema;\n    this.options = {\n      ...DEFAULT_OPTIONS,\n      ...options\n    };\n  }\n  limitReached() {\n    var _this$options, _this$options2;\n    if (Boolean((_this$options = this.options) === null || _this$options === void 0 ? void 0 : _this$options.limit) && this.totalLength >= this.options.limit) {\n      return true;\n    }\n    if (Boolean((_this$options2 = this.options) === null || _this$options2 === void 0 ? void 0 : _this$options2._limitMB) && this.totalBytes / 1e6 >= this.options._limitMB) {\n      return true;\n    }\n    return false;\n  }\n  addRow(row) {\n    if (this.limitReached()) {\n      return;\n    }\n    this.totalLength++;\n    this.rowBytes = this.rowBytes || this._estimateRowMB(row);\n    this.totalBytes += this.rowBytes;\n    if (Array.isArray(row)) {\n      this.addArrayRow(row);\n    } else {\n      this.addObjectRow(row);\n    }\n  }\n  addArrayRow(row) {\n    if (!this.aggregator) {\n      const TableBatchType = this._getTableBatchType();\n      this.aggregator = new TableBatchType(this.schema, this.options);\n    }\n    this.aggregator.addArrayRow(row);\n  }\n  addObjectRow(row) {\n    if (!this.aggregator) {\n      const TableBatchType = this._getTableBatchType();\n      this.aggregator = new TableBatchType(this.schema, this.options);\n    }\n    this.aggregator.addObjectRow(row);\n  }\n  chunkComplete(chunk) {\n    if (chunk instanceof ArrayBuffer) {\n      this.bytesUsed += chunk.byteLength;\n    }\n    if (typeof chunk === 'string') {\n      this.bytesUsed += chunk.length;\n    }\n    this.isChunkComplete = true;\n  }\n  getFullBatch(options) {\n    return this._isFull() ? this._getBatch(options) : null;\n  }\n  getFinalBatch(options) {\n    return this._getBatch(options);\n  }\n  _estimateRowMB(row) {\n    return Array.isArray(row) ? row.length * 8 : Object.keys(row).length * 8;\n  }\n  _isFull() {\n    if (!this.aggregator || this.aggregator.rowCount() === 0) {\n      return false;\n    }\n    if (this.options.batchSize === 'auto') {\n      if (!this.isChunkComplete) {\n        return false;\n      }\n    } else if (this.options.batchSize > this.aggregator.rowCount()) {\n      return false;\n    }\n    if (this.options.batchDebounceMs > Date.now() - this.lastBatchEmittedMs) {\n      return false;\n    }\n    this.isChunkComplete = false;\n    this.lastBatchEmittedMs = Date.now();\n    return true;\n  }\n  _getBatch(options) {\n    if (!this.aggregator) {\n      return null;\n    }\n    if (options !== null && options !== void 0 && options.bytesUsed) {\n      this.bytesUsed = options.bytesUsed;\n    }\n    const normalizedBatch = this.aggregator.getBatch();\n    normalizedBatch.count = this.batchCount;\n    normalizedBatch.bytesUsed = this.bytesUsed;\n    Object.assign(normalizedBatch, options);\n    this.batchCount++;\n    this.aggregator = null;\n    return normalizedBatch;\n  }\n  _getTableBatchType() {\n    switch (this.options.shape) {\n      case 'row-table':\n        return BaseTableBatchAggregator;\n      case 'array-row-table':\n      case 'object-row-table':\n        return RowTableBatchAggregator;\n      case 'columnar-table':\n        return ColumnarTableBatchAggregator;\n      case 'arrow-table':\n        if (!TableBatchBuilder.ArrowBatch) {\n          throw new Error(ERR_MESSAGE);\n        }\n        return TableBatchBuilder.ArrowBatch;\n      default:\n        throw new Error(ERR_MESSAGE);\n    }\n  }\n}\n_defineProperty(TableBatchBuilder, \"ArrowBatch\", void 0);\n//# sourceMappingURL=table-batch-builder.js.map",
      "start": 1693508125009,
      "end": 1693508125133,
      "sourcemaps": null
    }
  ]
}
