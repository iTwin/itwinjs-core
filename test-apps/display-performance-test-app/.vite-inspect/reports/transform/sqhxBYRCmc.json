{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/GraphicalEditingScope.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module IModelConnection\n */\nimport { assert, BeEvent, compareStrings, DbOpcode, DuplicatePolicy, SortedArray } from \"@itwin/core-bentley\";\nimport { ipcAppChannels, ModelGeometryChanges, } from \"@itwin/core-common\";\nimport { BriefcaseNotificationHandler } from \"./BriefcaseTxns\";\nimport { IpcApp } from \"./IpcApp\";\nclass ModelChanges extends SortedArray {\n    constructor(geometryGuid, range) {\n        super((lhs, rhs) => compareStrings(lhs.id, rhs.id), DuplicatePolicy.Replace);\n        this.geometryGuid = geometryGuid;\n        this.range = range;\n    }\n}\n/** Represents a period of time within an [interactive editing]($docs/learning/InteractiveEditing.md) session during which the\n * geometry of elements being displayed in one or more [[Viewport]]s is being modified. Outside of such a scope, whenever the\n * geometry within a [GeometricModel]($backend) changes new [[Tile]]s must be generated to reflect those changes in a viewport.\n * Regenerating entire tiles each time individual elements change can be time-consuming, which may introduce an unacceptable delay\n * between making a modification and seeing its result on the screen.\n *\n * Within the context of a graphical editing scope, no new tiles are generated. Instead, the geometry for any deleted or modified elements\n * is hidden in the tile graphics, and additional temporary graphics are displayed for any newly-inserted or modified elements. Only when the\n * scope exits are new tiles produced.\n *\n * The application decides when to enter and exit a graphical editing scope. A single interactive editing session may involve any number of\n * editing scopes. Typically, applications will enter a new editing scope (after first exiting a previous scope, if one exists):\n *  - When switching from a non-graphical workflow to one that involves editing geometry; or\n *  - When changing which geometric model is being edited; or\n *  - After performing an operation that creates or modifies a \"large\" number (perhaps hundreds?) of elements.\n *\n * An application should typically exit any graphical editing scope before:\n *  - Pulling changesets; or\n *  - Switching from a graphical editing workflow to some non-graphical workflow.\n *\n * Graphical editing scopes are only supported for [[BriefcaseConnection]]s opened in read-write mode that contain version 1.0.11 or newer of the BisCore schema.\n * @see [[BriefcaseConnection.enterEditingScope]] to create a scope for a briefcase.\n * @see [[BriefcaseConnection.editingScope]] to obtain a briefcase's current scope.\n * @see [[exit]] to terminate a scope.\n * @public\n */\nclass GraphicalEditingScope extends BriefcaseNotificationHandler {\n    get briefcaseChannelName() { return ipcAppChannels.editingScope; }\n    /** Don't call this directly - use BriefcaseConnection.enterEditingScope.\n     * @internal\n     */\n    static async enter(imodel) {\n        if (imodel.editingScope)\n            throw new Error(\"Cannot create an editing scope for an iModel that already has one\");\n        // Register the scope synchronously, in case enter() is called again for same iModel while awaiting asynchronous initialization.\n        const scope = new GraphicalEditingScope(imodel);\n        try {\n            const scopeStarted = await IpcApp.appFunctionIpc.toggleGraphicalEditingScope(imodel.key, true);\n            assert(scopeStarted); // If it didn't, the backend threw an error.\n        }\n        catch (e) {\n            scope.dispose();\n            throw e;\n        }\n        this.onEnter.raiseEvent(scope);\n        return scope;\n    }\n    /** Exits this editing scope. The associated [[BriefcaseConnection]]'s `editingScope` will be reset to `undefined`.\n     * @throws Error if the scope could not be exited, e.g., if it has already been exited.\n     * @see [[BriefcaseConnection.enterEditingScope]] to enter an editing scope.\n     */\n    async exit() {\n        if (this._disposed || this.iModel.editingScope !== this)\n            throw new Error(\"Cannot exit editing scope after it is disconnected from the iModel\");\n        this._disposed = true;\n        try {\n            this.onExiting.raiseEvent(this);\n        }\n        finally {\n            const scopeExited = await IpcApp.appFunctionIpc.toggleGraphicalEditingScope(this.iModel.key, false);\n            assert(!scopeExited);\n            try {\n                this.onExited.raiseEvent(this);\n            }\n            finally {\n                this.dispose();\n            }\n        }\n    }\n    /** Obtain all geometric changes to elements within the specified model accumulated within this scope. */\n    getGeometryChangesForModel(modelId) {\n        return this._geometryChanges.get(modelId);\n    }\n    /** Obtain all geometric changes to models accumulated within this scope. */\n    getGeometryChanges() {\n        return { [Symbol.iterator]: () => this.geometryChangeIterator() };\n    }\n    /** @internal */\n    get isDisposed() {\n        return this._disposed;\n    }\n    *geometryChangeIterator() {\n        for (const [key, value] of this._geometryChanges) {\n            yield {\n                id: key,\n                geometryGuid: value.geometryGuid,\n                range: value.range,\n                elements: value,\n            };\n        }\n    }\n    constructor(iModel) {\n        super(iModel.key);\n        /** Maps model Id to accumulated changes to geometric elements within the associated model. */\n        this._geometryChanges = new Map();\n        this._disposed = false;\n        /** Event raised when this scope is about to exit.\n         * @see [[onEnter]] for the complementary event.\n         * @see [[onExited]] for an event raised after the scope exits.\n         */\n        this.onExiting = new BeEvent();\n        /** Event raised when this scope has exited.\n         * @see [[onEnter]] for the complementary event.\n         * @see [[onExiting]] for an event raised just before the scope is exited.\n         */\n        this.onExited = new BeEvent();\n        /** Event raised after geometric changes are written to the iModel. */\n        this.onGeometryChanges = new BeEvent();\n        this.iModel = iModel;\n        this._cleanup = this.registerImpl();\n    }\n    dispose() {\n        this._disposed = true;\n        this.onExiting.clear();\n        this.onGeometryChanges.clear();\n        this.onExited.clear();\n        this._geometryChanges.clear();\n        if (this._cleanup) {\n            this._cleanup();\n            this._cleanup = undefined;\n        }\n    }\n    /** @internal */\n    notifyGeometryChanged(props) {\n        const changes = ModelGeometryChanges.iterable(props);\n        const modelIds = [];\n        let deletedIds;\n        for (const modelChanges of changes) {\n            // ###TODO do we care about the model range?\n            let list = this._geometryChanges.get(modelChanges.id);\n            modelIds.push(modelChanges.id);\n            for (const elementChange of modelChanges.elements) {\n                if (!list) {\n                    this._geometryChanges.set(modelChanges.id, list = new ModelChanges(modelChanges.geometryGuid, modelChanges.range));\n                }\n                else {\n                    list.geometryGuid = modelChanges.geometryGuid;\n                    modelChanges.range.clone(list.range);\n                }\n                list.insert(elementChange);\n                if (DbOpcode.Delete === elementChange.type) {\n                    if (undefined === deletedIds)\n                        deletedIds = new Set();\n                    deletedIds.add(elementChange.id);\n                }\n            }\n        }\n        if (deletedIds) {\n            this.iModel.selectionSet.remove(deletedIds);\n            this.iModel.hilited.setHilite(deletedIds, false);\n        }\n        this.onGeometryChanges.raiseEvent(changes, this);\n    }\n}\n/** Event raised when a new scope is created for any [[BriefcaseConnection]].\n * @see [[onExiting]] and [[onExited]] for complementary events.\n */\nGraphicalEditingScope.onEnter = new BeEvent();\nexport { GraphicalEditingScope };\n//# sourceMappingURL=GraphicalEditingScope.js.map",
      "start": 1693508118983,
      "end": 1693508119164,
      "sourcemaps": null
    }
  ]
}
