{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/curve/Path.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\nimport { CurveChain } from \"./CurveCollection\";\nimport { CurvePrimitive } from \"./CurvePrimitive\";\nimport { LineString3d } from \"./LineString3d\";\n/**\n * * A `Path` object is a collection of curves that join head-to-tail to form a path.\n * * A `Path` object does not bound a planar region. Use `Loop` to indicate region bounding.\n * @see [Curve Collections]($docs/learning/geometry/CurveCollection.md) learning article.\n * @public\n */\nexport class Path extends CurveChain {\n    /** Test if `other` is an instance of `Path` */\n    isSameGeometryClass(other) {\n        return other instanceof Path;\n    }\n    /** Invoke `processor.announcePath(this, indexInParent)` */\n    announceToCurveProcessor(processor, indexInParent = -1) {\n        return processor.announcePath(this, indexInParent);\n    }\n    /** Construct an empty path. */\n    constructor() {\n        super();\n        /** String name for schema properties */\n        this.curveCollectionType = \"path\";\n    }\n    /**\n     * Create a path from a variable length list of curve primitives\n     * * CurvePrimitive params are captured.\n     * @param curves variable length list of individual curve primitives or point arrays.\n     */\n    static create(...curves) {\n        const result = new Path();\n        for (const curve of curves) {\n            if (curve instanceof CurvePrimitive)\n                result.children.push(curve);\n            else if (Array.isArray(curve) && curve.length > 0 && curve[0] instanceof Point3d) {\n                result.children.push(LineString3d.create(curve));\n            }\n        }\n        return result;\n    }\n    /**\n     * Create a path from a an array of curve primitives.\n     * @param curves array of individual curve primitives.\n     */\n    static createArray(curves) {\n        const result = new Path();\n        for (const curve of curves) {\n            result.children.push(curve);\n        }\n        return result;\n    }\n    /** Return a deep copy, with leaf-level curve primitives stroked. */\n    cloneStroked(options) {\n        const strokes = LineString3d.create();\n        for (const curve of this.children)\n            curve.emitStrokes(strokes, options);\n        return Path.create(strokes);\n    }\n    /** Return the boundary type (1) of a corresponding MicroStation CurveVector */\n    dgnBoundaryType() {\n        return 1;\n    }\n    /** Clone as a new `Path` with no primitives */\n    cloneEmptyPeer() {\n        return new Path();\n    }\n    /** Second step of double dispatch: call `handler.handlePath(this)` */\n    dispatchToGeometryHandler(handler) {\n        return handler.handlePath(this);\n    }\n}\n//# sourceMappingURL=Path.js.map",
      "start": 1693508122798,
      "end": 1693508122958,
      "sourcemaps": null
    }
  ]
}
