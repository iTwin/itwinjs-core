{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tile/RealityTileLoader.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tiles\n */\nimport { assert, ByteStream } from \"@itwin/core-bentley\";\nimport { Point2d, Point3d, Transform } from \"@itwin/core-geometry\";\nimport { BatchType, CompositeTileHeader, TileFormat } from \"@itwin/core-common\";\nimport { IModelApp } from \"../IModelApp\";\nimport { GraphicBranch } from \"../render/GraphicBranch\";\nimport { ScreenViewport } from \"../Viewport\";\nimport { GltfWrapMode } from \"../common/gltf/GltfSchema\";\nimport { B3dmReader, createDefaultViewFlagOverrides, GltfGraphicsReader, GltfReader, GltfReaderProps, I3dmReader, ImdlReader, readPointCloudTileContent, } from \"./internal\";\nconst defaultViewFlagOverrides = createDefaultViewFlagOverrides({});\nconst scratchTileCenterWorld = new Point3d();\nconst scratchTileCenterView = new Point3d();\n/** Serves as a \"handler\" for a specific type of [[TileTree]]. Its primary responsibilities involve loading tile content.\n * @internal\n */\nexport class RealityTileLoader {\n    constructor(_produceGeometry) {\n        this._produceGeometry = _produceGeometry;\n        this._containsPointClouds = false;\n        this.preloadRealityParentDepth = IModelApp.tileAdmin.contextPreloadParentDepth;\n        this.preloadRealityParentSkip = IModelApp.tileAdmin.contextPreloadParentSkip;\n    }\n    computeTilePriority(tile, viewports, _users) {\n        // ###TODO: Handle case where tile tree reference(s) have a transform different from tree's (background map with ground bias).\n        return RealityTileLoader.computeTileLocationPriority(tile, viewports, tile.tree.iModelTransform);\n    }\n    get wantDeduplicatedVertices() { return false; }\n    get _batchType() { return BatchType.Primary; }\n    get _loadEdges() { return true; }\n    getBatchIdMap() { return undefined; }\n    get isContentUnbounded() { return false; }\n    get containsPointClouds() { return this._containsPointClouds; }\n    get parentsAndChildrenExclusive() { return true; }\n    forceTileLoad(_tile) { return false; }\n    get maximumScreenSpaceError() { return undefined; }\n    processSelectedTiles(selected, _args) { return selected; }\n    // NB: The isCanceled arg is chiefly for tests...in usual case it just returns false if the tile is no longer in 'loading' state.\n    async loadTileContent(tile, data, system, isCanceled) {\n        assert(data instanceof Uint8Array);\n        const blob = data;\n        const streamBuffer = ByteStream.fromUint8Array(blob);\n        const realityTile = tile;\n        return this._produceGeometry ? this.loadGeometryFromStream(realityTile, streamBuffer, system) : this.loadGraphicsFromStream(realityTile, streamBuffer, system, isCanceled);\n    }\n    _getFormat(streamBuffer) {\n        const position = streamBuffer.curPos;\n        const format = streamBuffer.readUint32();\n        streamBuffer.curPos = position;\n        return format;\n    }\n    async loadGeometryFromStream(tile, streamBuffer, system) {\n        const format = this._getFormat(streamBuffer);\n        if (format !== TileFormat.B3dm)\n            return {};\n        const { is3d, yAxisUp, iModel, modelId } = tile.realityRoot;\n        const reader = B3dmReader.create(streamBuffer, iModel, modelId, is3d, tile.contentRange, system, yAxisUp, tile.isLeaf, tile.center, tile.transformToRoot, undefined, this.getBatchIdMap());\n        if (reader)\n            reader.defaultWrapMode = GltfWrapMode.ClampToEdge;\n        return { geometry: reader?.readGltfAndCreateGeometry(tile.tree.iModelTransform) };\n    }\n    async loadGraphicsFromStream(tile, streamBuffer, system, isCanceled) {\n        const format = this._getFormat(streamBuffer);\n        if (undefined === isCanceled)\n            isCanceled = () => !tile.isLoading;\n        const { is3d, yAxisUp, iModel, modelId } = tile.realityRoot;\n        let reader;\n        switch (format) {\n            case TileFormat.IModel:\n                reader = ImdlReader.create({\n                    stream: streamBuffer,\n                    iModel,\n                    modelId,\n                    is3d,\n                    system,\n                    isCanceled,\n                });\n                break;\n            case TileFormat.Pnts:\n                this._containsPointClouds = true;\n                const res = await readPointCloudTileContent(streamBuffer, iModel, modelId, is3d, tile, system);\n                let graphic = res.graphic;\n                const rtcCenter = res.rtcCenter;\n                if (graphic && (rtcCenter || tile.transformToRoot && !tile.transformToRoot.isIdentity)) {\n                    const transformBranch = new GraphicBranch(true);\n                    transformBranch.add(graphic);\n                    let xform;\n                    if (!tile.transformToRoot && rtcCenter)\n                        xform = Transform.createTranslation(rtcCenter);\n                    else {\n                        if (rtcCenter)\n                            xform = Transform.createOriginAndMatrix(rtcCenter.plus(tile.transformToRoot.origin), tile.transformToRoot.matrix);\n                        else\n                            xform = tile.transformToRoot;\n                    }\n                    graphic = system.createBranch(transformBranch, xform);\n                }\n                return { graphic };\n            case TileFormat.B3dm:\n                reader = B3dmReader.create(streamBuffer, iModel, modelId, is3d, tile.contentRange, system, yAxisUp, tile.isLeaf, tile.center, tile.transformToRoot, isCanceled, this.getBatchIdMap(), this.wantDeduplicatedVertices);\n                if (reader) {\n                    // glTF spec defaults wrap mode to \"repeat\" but many reality tiles omit the wrap mode and should not repeat.\n                    // The render system also currently only produces mip-maps for repeating textures, and we don't want mip-maps for reality tile textures.\n                    assert(reader instanceof GltfReader);\n                    reader.defaultWrapMode = GltfWrapMode.ClampToEdge;\n                }\n                break;\n            case TileFormat.I3dm:\n                reader = I3dmReader.create(streamBuffer, iModel, modelId, is3d, tile.contentRange, system, yAxisUp, tile.isLeaf, isCanceled, undefined, this.wantDeduplicatedVertices);\n                break;\n            case TileFormat.Gltf:\n                const props = GltfReaderProps.create(streamBuffer.nextBytes(streamBuffer.arrayBuffer.byteLength), yAxisUp);\n                if (props) {\n                    reader = new GltfGraphicsReader(props, {\n                        iModel,\n                        gltf: props.glTF,\n                        contentRange: tile.contentRange,\n                        transform: tile.transformToRoot,\n                        hasChildren: !tile.isLeaf,\n                        pickableOptions: { id: modelId },\n                    });\n                }\n                break;\n            case TileFormat.Cmpt:\n                const header = new CompositeTileHeader(streamBuffer);\n                if (!header.isValid)\n                    return {};\n                const branch = new GraphicBranch(true);\n                for (let i = 0; i < header.tileCount; i++) {\n                    const tilePosition = streamBuffer.curPos;\n                    streamBuffer.advance(8); // Skip magic and version.\n                    const tileBytes = streamBuffer.readUint32();\n                    streamBuffer.curPos = tilePosition;\n                    const result = await this.loadGraphicsFromStream(tile, streamBuffer, system, isCanceled);\n                    if (result.graphic)\n                        branch.add(result.graphic);\n                    streamBuffer.curPos = tilePosition + tileBytes;\n                }\n                return { graphic: branch.isEmpty ? undefined : system.createBranch(branch, Transform.createIdentity()), isLeaf: tile.isLeaf };\n            default:\n                assert(false, `unknown tile format ${format}`);\n                break;\n        }\n        let content = {};\n        if (undefined !== reader) {\n            try {\n                content = await reader.read();\n                if (content.containsPointCloud)\n                    this._containsPointClouds = true;\n            }\n            catch (_err) {\n                // Failure to load should prevent us from trying to load children\n                content.isLeaf = true;\n            }\n        }\n        return content;\n    }\n    get viewFlagOverrides() { return defaultViewFlagOverrides; }\n    static computeTileLocationPriority(tile, viewports, location) {\n        // Compute a priority value for tiles that are:\n        // * Closer to the eye;\n        // * Closer to the center of attention (center of the screen or zoom target).\n        // This way, we can load in priority tiles that are more likely to be important.\n        let center;\n        let minDistance = 1.0;\n        const currentInputState = IModelApp.toolAdmin.currentInputState;\n        const now = Date.now();\n        const wheelEventRelevanceTimeout = 1000; // Wheel events older than this value will not be considered\n        for (const viewport of viewports) {\n            center = center ?? location.multiplyPoint3d(tile.center, scratchTileCenterWorld);\n            const npc = viewport.worldToNpc(center, scratchTileCenterView);\n            let focusPoint = new Point2d(0.5, 0.5);\n            if (currentInputState.viewport === viewport && viewport instanceof ScreenViewport) {\n                // Try to get a better target point from the last zoom target\n                const { lastWheelEvent } = currentInputState;\n                if (lastWheelEvent !== undefined && now - lastWheelEvent.time < wheelEventRelevanceTimeout) {\n                    const focusPointCandidate = Point2d.fromJSON(viewport.worldToNpc(lastWheelEvent.point));\n                    if (focusPointCandidate.x > 0 && focusPointCandidate.x < 1 && focusPointCandidate.y > 0 && focusPointCandidate.y < 1)\n                        focusPoint = focusPointCandidate;\n                }\n            }\n            // NB: In NPC coords, 0 = far plane, 1 = near plane.\n            const distanceToEye = 1.0 - npc.z;\n            const distanceToCenter = Math.min(npc.distanceXY(focusPoint) / 0.707, 1.0); // Math.sqrt(0.5) = 0.707\n            // Distance is a mix of the two previously computed values, still in range [0; 1]\n            // We use this factor to determine how much the distance to the center of attention is important compared to distance to the eye\n            const distanceToCenterWeight = 0.3;\n            const distance = distanceToEye * (1.0 - distanceToCenterWeight) + distanceToCenter * distanceToCenterWeight;\n            minDistance = Math.min(distance, minDistance);\n        }\n        return minDistance;\n    }\n}\n//# sourceMappingURL=RealityTileLoader.js.map",
      "start": 1693508121862,
      "end": 1693508122003,
      "sourcemaps": null
    }
  ]
}
