{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/curve/CurvePrimitive.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Curve\n */\nimport { assert } from \"@itwin/core-bentley\";\nimport { StrokeCountMap } from \"../curve/Query/StrokeCountMap\";\nimport { AxisOrder, Geometry } from \"../Geometry\";\nimport { Matrix3d } from \"../geometry3d/Matrix3d\";\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\nimport { Range3d } from \"../geometry3d/Range\";\nimport { Ray3d } from \"../geometry3d/Ray3d\";\nimport { Transform } from \"../geometry3d/Transform\";\nimport { CurveIntervalRole, CurveLocationDetail, CurveSearchStatus } from \"./CurveLocationDetail\";\nimport { GeometryQuery } from \"./GeometryQuery\";\nimport { AppendPlaneIntersectionStrokeHandler } from \"./internalContexts/AppendPlaneIntersectionStrokeHandler\";\nimport { ClosestPointStrokeHandler } from \"./internalContexts/ClosestPointStrokeHandler\";\nimport { CurveLengthContext } from \"./internalContexts/CurveLengthContext\";\n/**\n * A curve primitive is bounded.\n * A curve primitive maps fractions in 0..1 to points in space.\n * As the fraction proceeds from 0 towards 1, the point moves \"forward\" along the curve.\n * True distance along the curve is not always strictly proportional to fraction.\n * * A LineSegment3d always has proportional fraction and distance.\n * * An Arc3d which is true circular has proportional fraction and distance.\n * * A LineString3d is not proportional (except for special case of all segments of equal length).\n * * A Spiral3d is proportional.\n * * A BsplineCurve3d is only proportional for special cases.\n * For fractions outside 0..1, the curve primitive class may either (a) return the near endpoint or (b) evaluate\n * an extended curve.\n * @public\n */\nexport class CurvePrimitive extends GeometryQuery {\n    /** Constructor */\n    constructor() {\n        super();\n        /** String name for schema properties */\n        this.geometryCategory = \"curvePrimitive\";\n    }\n    /**\n     * Returns a ray whose origin is the curve point and direction is the unit tangent.\n     * @param fraction fractional position on the curve\n     * @param result optional preallocated ray.\n     */\n    fractionToPointAndUnitTangent(fraction, result) {\n        const ray = this.fractionToPointAndDerivative(fraction, result);\n        ray.trySetDirectionMagnitudeInPlace(1.0);\n        return ray;\n    }\n    /**\n     * Returns the (absolute) curvature magnitude.\n     * * Base implementation in CurvePrimitive computes curvature from the first and second derivative vectors.\n     * @param fraction fractional position on the curve\n     */\n    fractionToCurvature(fraction) {\n        const data = this.fractionToPointAnd2Derivatives(fraction);\n        const cross = data.vectorU.crossProduct(data.vectorV);\n        const a = cross.magnitude();\n        const b = data.vectorU.magnitude();\n        return Geometry.conditionalDivideFraction(a, b * b * b);\n    }\n    /**\n     * Construct a frenet frame:\n     * * origin at the point on the curve\n     * * x axis is unit vector along the curve (tangent)\n     * * y axis is perpendicular and in the plane of the osculating circle. y axis is called \"main normal\"\n     * * z axis perpendicular to those. z axis is called \"bi-normal\"\n     */\n    fractionToFrenetFrame(fraction, result) {\n        const plane = this.fractionToPointAnd2Derivatives(fraction);\n        if (!plane)\n            return undefined;\n        // first derivative (plane.vectorU) and second derivative (plane.vectorV) are not essentially\n        // perpendicular so we use createRigidFromColumns to make 3 perpendicular vectors.\n        let axes = Matrix3d.createRigidFromColumns(plane.vectorU, plane.vectorV, AxisOrder.XYZ);\n        if (axes)\n            return Transform.createRefs(plane.origin, axes, result);\n        // 2nd derivative not distinct. for example if curve is linear at fraction so second derivative is 0.\n        // in this case we find perpendicular vector to plane.vectorU and pass it to createRigidFromColumns.\n        const perpVector = Matrix3d.createPerpendicularVectorFavorXYPlane(plane.vectorU, plane.vectorV);\n        axes = Matrix3d.createRigidFromColumns(plane.vectorU, perpVector, AxisOrder.XYZ);\n        if (axes)\n            return Transform.createRefs(plane.origin, axes, result);\n        return undefined;\n    }\n    /**\n     * Construct signed distance from a point on the planar curve to its center of curvature (in xy only).\n     * * Positive distance means the center is to the left of the curve at fraction.\n     * * Negative distance means the center is to the right of the curve at fraction.\n     * * Zero distance means curve is linear at fraction.\n     */\n    fractionToSignedXYRadiusOfCurvature(fraction) {\n        const plane = this.fractionToPointAnd2Derivatives(fraction);\n        if (!plane)\n            return 0.0;\n        const cross = plane.vectorU.crossProductXY(plane.vectorV);\n        const b = plane.vectorU.magnitude();\n        if (b === 0.0)\n            return 0.0;\n        const r = Geometry.conditionalDivideCoordinate(b * b * b, cross);\n        if (r !== undefined)\n            return r;\n        return 0.0;\n    }\n    /**\n     * Construct a point extrapolated along tangent at fraction.\n     * @param fraction fractional position on the primitive\n     * @param distance (signed) distance to move on the tangent.\n     */\n    fractionAndDistanceToPointOnTangent(fraction, distance) {\n        const ray = this.fractionToPointAndUnitTangent(fraction);\n        return ray.fractionToPoint(distance);\n    }\n    /**\n     * Return the length of the curve.\n     * * Curve length is always positive.\n     */\n    curveLength() {\n        const context = new CurveLengthContext();\n        this.emitStrokableParts(context);\n        return context.getSum();\n    }\n    /**\n     * Returns a (high accuracy) length of the curve between fractional positions.\n     * * Curve length is always positive.\n     * * Default implementation applies a generic Gaussian integration.\n     * * Most curve classes (certainly LineSegment, LineString, Arc) are expected to provide efficient implementations.\n     */\n    curveLengthBetweenFractions(fraction0, fraction1) {\n        if (fraction0 === fraction1)\n            return 0.0;\n        const scale = this.getFractionToDistanceScale();\n        if (scale !== undefined) {\n            // We are in luck! simple proportions determine it all !!!\n            // (for example, a LineSegment3d or a circular arc)\n            const totalLength = this.curveLength();\n            return Math.abs((fraction1 - fraction0) * totalLength);\n        }\n        const context = new CurveLengthContext(fraction0, fraction1);\n        this.emitStrokableParts(context);\n        return Math.abs(context.getSum());\n    }\n    /**\n     * Returns a (high accuracy) range of the curve between fractional positions\n     * * Default implementation returns the range of the curve from clonePartialCurve.\n     */\n    rangeBetweenFractions(fraction0, fraction1, transform) {\n        return this.rangeBetweenFractionsByClone(fraction0, fraction1, transform);\n    }\n    /**\n     * Returns a (high accuracy) range of the curve between fractional positions\n     * * Default implementation returns the range of the curve from clonePartialCurve\n     */\n    rangeBetweenFractionsByClone(fraction0, fraction1, transform) {\n        if (fraction0 === fraction1)\n            return Range3d.create(this.fractionToPoint(fraction0));\n        const fragment = this.clonePartialCurve(fraction0, fraction1);\n        if (fragment)\n            return fragment.range(transform);\n        return Range3d.createNull();\n    }\n    /**\n     * Returns an approximate range based on a fixed number of evaluations\n     * * Default implementation returns a range determined by evaluating a specified number of points on the curve.\n     * * Optional evaluate again at interval midpoints and extrapolate any increase\n     * * For a smooth curve, Richardson extrapolation suggests each subdivision moves 3/4 of the way to final. So\n     * extrapolationFactor of 1/3 gets speculatively moves closer to the tight range, and larger multipliers increase\n     * confidence in being safely larger.\n     * * This function is faster version to compute the range of a portion of a curve (because some curves can be\n     * expensive to compute the partial curve and/or to compute the partial curve's range.\n     * @param fraction0 start fraction for evaluation\n     * @param fraction1 end fraction for evaluation\n     * @param count number of points to evaluate\n     * @param transform optional transform to be applied to the curve\n     * @param extrapolationFactor if positive, evaluate again at interval midpoints and apply this fraction multiplier\n     * to any increase in size.\n     */\n    rangeBetweenFractionsByCount(fraction0, fraction1, count, transform, extrapolationFactor = 0.0) {\n        const range = Range3d.createNull();\n        const workPoint = Point3d.create();\n        range.extendPoint(this.startPoint(workPoint));\n        range.extendPoint(this.endPoint(workPoint));\n        // Evaluate at count fractions (fraction0 + i * fractionStep)\n        const evaluateSteps = (fractionA, fractionStep, countA) => {\n            let f = fractionA;\n            for (let i = 0; i < countA; i++, f += fractionStep) {\n                this.fractionToPoint(f, workPoint);\n                if (transform)\n                    range.extendTransformedPoint(transform, workPoint);\n                else\n                    range.extendPoint(workPoint);\n            }\n        };\n        const interiorCount = count - 2;\n        if (interiorCount > 0) {\n            const localFraction0 = 1.0 / (interiorCount + 1);\n            const globalFractionStep = localFraction0 * (fraction1 - fraction0);\n            evaluateSteps(fraction0 + globalFractionStep, globalFractionStep, interiorCount);\n        }\n        if (extrapolationFactor > 0.0) {\n            // Evaluate at midpoints.  Where this makes the range larger, apply extrapolationFactor to move it to safer\n            // excess value. same interior step, but shift to interval midpoints.\n            const baseRange = range.clone();\n            const interiorCount1 = interiorCount + 1;\n            const localFraction0 = 0.5 / interiorCount1; // we only evaluate at new midpoints.\n            const globalFractionStep = 2 * localFraction0 * (fraction1 - fraction0); // same as above, but avoids special logic for interiorCount = 0\n            evaluateSteps(fraction0 + globalFractionStep * 0.5, globalFractionStep, interiorCount1);\n            range.extendWhenLarger(baseRange, extrapolationFactor);\n        }\n        return range;\n    }\n    /**\n     * Run an integration (with a default Gaussian quadrature) with a fixed fractional step\n     * * This is typically called by specific curve type implementations of curveLengthBetweenFractions.\n     * * For example, in Arc3d implementation of curveLengthBetweenFractions:\n     *     * If the Arc3d is true circular, it the arc is true circular, use the direct `arcLength = radius * sweepRadians`\n     *     * If the Arc3d is not true circular, call this method with an interval count appropriate to eccentricity and\n     * sweepRadians.\n     * @returns Returns the curve length via an integral estimated by numerical quadrature between the fractional positions.\n     * @param fraction0 start fraction for integration\n     * @param fraction1 end fraction for integration\n     * @param numInterval number of quadrature intervals\n     */\n    curveLengthWithFixedIntervalCountQuadrature(fraction0, fraction1, numInterval, numGauss = 5) {\n        if (fraction0 > fraction1) {\n            const fSave = fraction0;\n            fraction0 = fraction1;\n            fraction1 = fSave;\n        }\n        const context = new CurveLengthContext(fraction0, fraction1, numGauss);\n        context.announceIntervalForUniformStepStrokes(this, numInterval, fraction0, fraction1);\n        return Math.abs(context.getSum());\n    }\n    /**\n     * (Attempt to) find a position on the curve at a signed distance from start fraction.\n     * * Return the position as a CurveLocationDetail.\n     * * In the `CurveLocationDetail`, record:\n     *   * `fraction` = fractional position\n     *   * `point` = coordinates of the point\n     *   * `a` = (signed!) distance moved.   If `allowExtension` is false and the move reached the start or end of the\n     * curve, this distance is smaller than the requested signedDistance.\n     *   * `curveSearchStatus` indicates one of:\n     *     * `error` (unusual) computation failed not supported for this curve.\n     *     * `success` full movement completed\n     *     * `stoppedAtBoundary` partial movement completed. This can be due to either\n     *        * `allowExtension` parameter sent as `false`\n     *        * the curve type (e.g. bspline) does not support extended range.\n     * * if `allowExtension` is true, movement may still end at the startPoint or end point for curves that do not support\n     * extended geometry (specifically bsplines)\n     * * if the curve returns a value (i.e. not `undefined`) for `curve.getFractionToDistanceScale()`, the base class\n     * carries out the computation\n     *    and returns a final location.\n     *   * LineSegment3d relies on this.\n     * * If the curve does not implement the computation or the curve has zero length, the returned `CurveLocationDetail`\n     * has\n     *    * `fraction` = the value of `startFraction`\n     *    * `point` = result of `curve.fractionToPoint(startFraction)`\n     *    * `a` = 0\n     *    * `curveStartState` = `CurveSearchStatus.error`\n     * @param startFraction fractional position where the move starts\n     * @param signedDistance distance to move.   Negative distance is backwards in the fraction space\n     * @param allowExtension if true, allow the move to go beyond the startPoint or endpoint of the curve.  If false,\n     * do not allow movement beyond the startPoint or endpoint\n     * @param result optional result.\n     * @returns A CurveLocationDetail annotated as above. Note that if the curve does not support the calculation, there is\n     * still a result which contains the point at the input startFraction, with failure indicated in the `curveStartState`\n     * member\n     */\n    moveSignedDistanceFromFraction(startFraction, signedDistance, allowExtension, result) {\n        const scale = this.getFractionToDistanceScale();\n        if (scale !== undefined) {\n            // We are in luck! simple proportions determine it all  !!!\n            // (for example, a LineSegment3d or a circular arc)\n            const totalLength = this.curveLength();\n            const signedFractionMove = Geometry.conditionalDivideFraction(signedDistance, totalLength);\n            if (signedFractionMove === undefined) {\n                return CurveLocationDetail.createCurveFractionPointDistanceCurveSearchStatus(this, startFraction, this.fractionToPoint(startFraction), 0.0, CurveSearchStatus.error);\n            }\n            return CurveLocationDetail.createConditionalMoveSignedDistance(allowExtension, this, startFraction, startFraction + signedFractionMove, signedDistance, result);\n        }\n        return this.moveSignedDistanceFromFractionGeneric(startFraction, signedDistance, allowExtension, result);\n    }\n    /**\n     * Generic algorithm to search for point at signed distance from a fractional startPoint.\n     * * This will work for well for smooth curves.\n     * * Curves with tangent or other low-order-derivative discontinuities may need to implement specialized algorithms.\n     * * We need to find an endFraction which is the end-of-interval (usually upper) limit of integration of the tangent\n     * magnitude from startFraction to endFraction\n     * * That integral is a function of endFraction.\n     * * The derivative of that integral with respect to end fraction is the tangent magnitude at end fraction.\n     * * Use that function and (easily evaluated!) derivative for a Newton iteration\n     * * TO ALL WHO HAVE FUZZY MEMORIES OF CALCULUS CLASS: \"The derivative of the integral wrt upper limit is the value\n     * of the integrand there\" is the fundamental theorem of integral calculus !!! The fundamental theorem is not just\n     * an abstraction !!! It is being used  here in its barest possible form !!!\n     * * See https://en.wikipedia.org/wiki/Fundamental_theorem_of_calculus\n     * @param startFraction\n     * @param signedDistance\n     * @param _allowExtension\n     * @param result\n     */\n    moveSignedDistanceFromFractionGeneric(startFraction, signedDistance, allowExtension, result) {\n        let limitFraction;\n        const slackFraction = 0.1; // slack to use when integration would otherwise have no room to work\n        if (signedDistance === 0.0)\n            return CurveLocationDetail.createCurveEvaluatedFraction(this, startFraction, result); // no movement, just evaluate at startFraction\n        if (signedDistance > 0.0) {\n            limitFraction = 1.0;\n            if (startFraction >= 1.0) {\n                const newStartFraction = 1.0 - slackFraction;\n                signedDistance += this.curveLengthBetweenFractions(newStartFraction, startFraction);\n                startFraction = newStartFraction;\n            }\n        }\n        else { // signedDistance < 0.0\n            limitFraction = 0.0;\n            if (startFraction <= 0.0) {\n                const newStartFraction = 0.0 + slackFraction;\n                signedDistance -= this.curveLengthBetweenFractions(startFraction, newStartFraction);\n                startFraction = newStartFraction;\n            }\n        }\n        const availableLength = this.curveLengthBetweenFractions(startFraction, limitFraction);\n        assert(availableLength > 0.0);\n        const absDistance = Math.abs(signedDistance);\n        if (availableLength < absDistance && !allowExtension)\n            return CurveLocationDetail.createConditionalMoveSignedDistance(allowExtension, this, startFraction, limitFraction, signedDistance, result);\n        const fractionStep = Geometry.conditionalDivideCoordinate(absDistance, availableLength);\n        if (undefined === fractionStep) {\n            // no available length!\n            result = CurveLocationDetail.createCurveEvaluatedFraction(this, startFraction, result);\n            result.curveSearchStatus = CurveSearchStatus.error;\n            return result;\n        }\n        const directionFactor = signedDistance < 0.0 ? -1.0 : 1.0;\n        let fractionB = Geometry.interpolate(startFraction, fractionStep, limitFraction);\n        let fractionA = startFraction;\n        let distanceA = 0.0;\n        const tol = 1.0e-12 * availableLength;\n        let numConverged = 0;\n        const tangent = Ray3d.createXAxis();\n        // on each loop entry:\n        // fractionA is the most recent endOfInterval.  (It may have been reached by a mixture of forward and backward step.)\n        // distanceA is the distance to (the point at) fractionA\n        // fractionB is the next end fraction\n        for (let iterations = 0; iterations < 10; iterations++) {\n            const distanceAB = this.curveLengthBetweenFractions(fractionA, fractionB);\n            const directionAB = fractionB > fractionA ? directionFactor : -directionFactor;\n            const distance0B = distanceA + directionAB * distanceAB;\n            const distanceError = absDistance - distance0B;\n            if (Math.abs(distanceError) < tol) {\n                numConverged++;\n                if (numConverged > 1)\n                    break;\n            }\n            else {\n                numConverged = 0;\n            }\n            this.fractionToPointAndDerivative(fractionB, tangent);\n            const tangentMagnitude = tangent.direction.magnitude();\n            fractionA = fractionB;\n            fractionB = fractionA + directionFactor * distanceError / tangentMagnitude;\n            if (fractionA === fractionB) { // YES -- that is an exact equality test.   When it happens, there's no need for confirming with another iteration.\n                numConverged = 100;\n                break;\n            }\n            distanceA = distance0B;\n        }\n        if (numConverged > 1)\n            return CurveLocationDetail.createConditionalMoveSignedDistance(allowExtension, this, startFraction, fractionB, signedDistance, result);\n        result = CurveLocationDetail.createCurveEvaluatedFraction(this, startFraction, result);\n        result.curveSearchStatus = CurveSearchStatus.error;\n        return result;\n    }\n    /**\n     * * Returns true if the curve can be easily extended past its start/end point (i.e., beyond the usual\n     * fraction space [0,1]). Otherwise, returns false.\n     * * Base class default implementation returns false.\n     * * These classes (and perhaps others in the future) will return true:\n     *   * LineSegment3d\n     *   * LineString3d\n     *   * Arc3d\n     */\n    get isExtensibleFractionSpace() {\n        return false;\n    }\n    /**\n     * Search for a point on the curve that is closest to the spacePoint.\n     * * If the space point is exactly on the curve, this is the reverse of fractionToPoint.\n     * * Since CurvePrimitive should always have start and end available as candidate points, this method should always\n     * succeed\n     * @param spacePoint point in space\n     * @param extend true to extend the curve (if possible), false for no extend, single CurveExtendOptions (for both\n     * directions), or array of distinct CurveExtendOptions for start and end.\n     * @returns Returns a CurveLocationDetail structure that holds the details of the close point.\n     */\n    closestPoint(spacePoint, extend) {\n        const strokeHandler = new ClosestPointStrokeHandler(spacePoint, extend);\n        this.emitStrokableParts(strokeHandler);\n        return strokeHandler.claimResult();\n    }\n    /**\n     * Find intervals of this curvePrimitive that are interior to a clipper\n     * @param clipper clip structure (e.g. clip planes)\n     * @param announce (optional) function to be called announcing fractional intervals\n     * `announce(fraction0, fraction1, curvePrimitive)`\n     * @returns true if any \"in\" segments are announced.\n     */\n    announceClipIntervals(_clipper, _announce) {\n        // DEFAULT IMPLEMENTATION -- no interior parts\n        return false;\n    }\n    /**\n     * Return (if possible) a curve primitive which is a portion of this curve.\n     * @param _fractionA [in] start fraction\n     * @param _fractionB [in] end fraction\n     */\n    clonePartialCurve(_fractionA, _fractionB) {\n        return undefined;\n    }\n    /**\n     * If the curve primitive has distance-along-curve strictly proportional to curve fraction, return the scale factor.\n     * If distance-along-the-curve is not proportional, return undefined.\n     * * When defined, the scale factor is always the length of the curve.\n     * * This scale factor is typically available for these curve types:\n     * * * All `LineSegment3d`\n     * * * Arc3d which is a true circular arc (axes perpendicular and of equal length).\n     * * * CurveChainWithDistanceIndex\n     * * This scale factor is undefined for these curve types:\n     * * * Arc3d which is a true ellipse, i.e. unequal lengths of defining vectors or non-perpendicular defining vectors.\n     * * * bspline and bezier curves\n     * @returns scale factor or undefined\n     */\n    getFractionToDistanceScale() {\n        return undefined;\n    }\n    /**\n     * Compute intersections of the curve with a plane.\n     * * The intersections are appended to the result array.\n     * * The base class implementation emits strokes to an AppendPlaneIntersectionStrokeHandler object, which uses a\n     * Newton iteration to get high-accuracy intersection points within strokes.\n     * * Derived classes should override this default implementation if there are easy analytic solutions.\n     * * Derived classes are free to implement extended intersections (e.g. arc!!!)\n     * @param plane The plane to be intersected.\n     * @param result Array to receive intersections\n     * @returns Return the number of CurveLocationDetail's added to the result array.\n     */\n    appendPlaneIntersectionPoints(plane, result) {\n        const strokeHandler = new AppendPlaneIntersectionStrokeHandler(plane, result);\n        const n0 = result.length;\n        this.emitStrokableParts(strokeHandler);\n        return result.length - n0;\n    }\n    /**\n     * Examine contents of an array of CurveLocationDetail.\n     * Filter the intersections according to the parameters.\n     * @param allowExtend if false, remove points on the extension.\n     * @param applySnappedCoordinates if true, change the stored fractions and coordinates to exact end values.\n     * Otherwise use the exact values only for purpose of updating the curveIntervalRole.\n     * @param startEndFractionTolerance if nonzero, adjust fraction to 0 or 1 with this tolerance.\n     * @param startEndXYZTolerance if nonzero, adjust to endpoint with this tolerance.\n     * @internal\n     */\n    static snapAndRestrictDetails(details, allowExtend = true, applySnappedCoordinates = false, startEndFractionTolerance = Geometry.smallAngleRadians, startEndXYZTolerance = Geometry.smallMetricDistance) {\n        const n0 = details.length;\n        let acceptIndex = 0;\n        const point0 = Point3d.create();\n        const point1 = Point3d.create();\n        let snappedCoordinates;\n        for (let candidateIndex = 0; candidateIndex < n0; candidateIndex++) {\n            snappedCoordinates = undefined;\n            const detail = details[candidateIndex];\n            let fraction = detail.fraction;\n            let accept = allowExtend || Geometry.isIn01(fraction);\n            if (detail.curve) {\n                detail.curve.startPoint(point0);\n                detail.curve.endPoint(point1);\n            }\n            if (startEndFractionTolerance > 0) {\n                if (Math.abs(fraction) < startEndFractionTolerance) {\n                    fraction = 0.0;\n                    accept = true;\n                    detail.intervalRole = CurveIntervalRole.isolatedAtVertex;\n                    snappedCoordinates = point0;\n                }\n                if (Math.abs(fraction - 1.0) < startEndFractionTolerance) {\n                    fraction = 1.0;\n                    accept = true;\n                    detail.intervalRole = CurveIntervalRole.isolatedAtVertex;\n                    snappedCoordinates = point1;\n                    if (detail.curve)\n                        snappedCoordinates = detail.curve.startPoint(point1);\n                }\n            }\n            if (startEndXYZTolerance > 0 && detail.curve !== undefined) {\n                // REMARK: always test both endpoints.   If there is a cyclic fraction space, an intersection marked as \"after\" the end might have wrapped all the way to the beginning.\n                if (detail.point.distance(point0) <= startEndXYZTolerance) {\n                    fraction = 0.0;\n                    detail.intervalRole = CurveIntervalRole.isolatedAtVertex;\n                    snappedCoordinates = point0;\n                }\n                else if (detail.point.distance(point1) <= startEndXYZTolerance) {\n                    fraction = 1.0;\n                    detail.intervalRole = CurveIntervalRole.isolatedAtVertex;\n                    snappedCoordinates = point1;\n                }\n            }\n            if (accept) {\n                if (applySnappedCoordinates) {\n                    detail.fraction = fraction;\n                    if (snappedCoordinates !== undefined)\n                        detail.point.setFrom(snappedCoordinates);\n                }\n                if (acceptIndex < candidateIndex)\n                    details[acceptIndex] = detail;\n                acceptIndex++;\n            }\n        }\n        if (acceptIndex < n0)\n            details.length = acceptIndex;\n    }\n    /** Return the startPoint of the primitive. The default implementation returns fractionToPoint(0.0) */\n    startPoint(result) {\n        return this.fractionToPoint(0.0, result);\n    }\n    /** Return the end point of the primitive. The default implementation returns fractionToPoint(1.0) */\n    endPoint(result) {\n        return this.fractionToPoint(1.0, result);\n    }\n    /**\n     * Attach StrokeCountMap structure to this primitive (and recursively to any children)\n     * * Base class implementation (here) gets the simple count from computeStrokeCountForOptions and attaches it.\n     * * LineString3d, arc3d, BezierCurve3d, BezierCurve3dH accept that default.\n     * * Subdivided primitives (linestring, bspline curve) implement themselves and attach a StrokeCountMap containing the\n     *       total count, and also containing an array of StrokeCountMap per component.\n     * * For CurvePrimitiveWithDistanceIndex, the top level gets (only) a total count, and each child gets\n     *       its own StrokeCountMap with appropriate structure.\n     * @param options StrokeOptions that determine count\n     * @param parentStrokeMap optional map from parent.  Its count, curveLength, and a1 values are increased with count\n     * and distance from this primitive.\n     * @return sum of `a0+this.curveLength()`, for use as `a0` of successor in chain.\n     */\n    computeAndAttachRecursiveStrokeCounts(options, parentMap) {\n        const n = this.computeStrokeCountForOptions(options);\n        const a = this.curveLength();\n        CurvePrimitive.installStrokeCountMap(this, StrokeCountMap.createWithCurvePrimitive(this, n, a, 0, a), parentMap);\n    }\n    /**\n     * Evaluate strokes at fractions indicated in a StrokeCountMap.\n     *   * Base class implementation (here) gets the simple count from computeStrokeCountForOptions and strokes at\n     * uniform fractions.\n     *   * LineString3d, arc3d, BezierCurve3d, BezierCurve3dH accept that default.\n     *   * Subdivided primitives (linestring, bspline curve) implement themselves and evaluate within components.\n     *   * CurvePrimitiveWithDistanceIndex recurses to its children.\n     * * if packedFraction and packedDerivative arrays are present in the LineString3d, fill them.\n     * @param map = stroke count data.\n     * @param linestring = receiver linestring.\n     * @return number of strokes added.  0 if any errors matching the map to the curve primitive.\n     */\n    addMappedStrokesToLineString3D(map, linestring) {\n        const numPoint0 = linestring.numPoints();\n        if (map.primitive && map.primitive === this && map.numStroke > 0) {\n            for (let i = 0; i <= map.numStroke; i++) {\n                const fraction = i / map.numStroke;\n                linestring.appendFractionToPoint(this, fraction);\n            }\n        }\n        return linestring.numPoints() - numPoint0;\n    }\n    /**\n     * Final install step to save curveMap in curve. If parentMap is given, update its length, count, and a1 fields\n     * @param curve curve to receive the annotation\n     * @param map\n     * @param parentMap\n     */\n    static installStrokeCountMap(curve, curveMap, parentMap) {\n        if (parentMap)\n            parentMap.addToCountAndLength(curveMap.numStroke, curveMap.curveLength);\n        curve.strokeData = curveMap;\n    }\n    /**\n     * Return an array containing only the curve primitives.\n     * * This DEFAULT implementation simply pushes `this` to the collectorArray.\n     * @param collectorArray array to receive primitives (pushed -- the array is not cleared)\n     * @param smallestPossiblePrimitives if true, a [[CurvePrimitiveWithDistanceIndex]] recurses on its (otherwise hidden)\n     * children. If false, it returns only itself.\n     * @param explodeLinestrings if true, push a [[LineSegment3d]] for each segment of a [[LineString3d]]. If false,\n     * push only the [[LineString3d]].\n     */\n    collectCurvePrimitivesGo(collectorArray, _smallestPossiblePrimitives, _explodeLinestrings = false) {\n        collectorArray.push(this);\n    }\n    /**\n     * Return an array containing only the curve primitives.\n     * * This DEFAULT implementation captures the optional collector and calls [[collectCurvePrimitivesGo]].\n     * @param collectorArray optional array to receive primitives.   If present, new primitives are ADDED (without\n     * clearing the array.)\n     * @param smallestPossiblePrimitives if false, CurvePrimitiveWithDistanceIndex returns only itself.  If true,\n     * it recurses to its (otherwise hidden) children.\n     */\n    collectCurvePrimitives(collectorArray, smallestPossiblePrimitives = false, explodeLinestrings = false) {\n        const results = collectorArray === undefined ? [] : collectorArray;\n        this.collectCurvePrimitivesGo(results, smallestPossiblePrimitives, explodeLinestrings);\n        return results;\n    }\n    /**\n     * Project instance geometry (via dispatch) onto the line of the given ray, and return the extreme fractional\n     * parameters of projection.\n     * @param ray ray onto which the instance is projected. A `Vector3d` is treated as a `Ray3d` with zero origin.\n     * @param lowHigh optional receiver for output\n     * @returns range of fractional projection parameters onto the ray, where 0.0 is start of the ray and 1.0 is the\n     * end of the ray.\n     */\n    projectedParameterRange(_ray, _lowHigh) {\n        return undefined; // common implementation delegated to subclasses to avoid circular dependency\n    }\n}\n//# sourceMappingURL=CurvePrimitive.js.map",
      "start": 1693508122739,
      "end": 1693508122883,
      "sourcemaps": null
    }
  ]
}
