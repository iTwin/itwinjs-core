{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/glsl/AmbientOcclusion.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { TextureUnit } from \"../RenderFlags\";\nimport { System } from \"../System\";\nimport { Texture2DHandle } from \"../Texture\";\nimport { addFrustum } from \"./Common\";\nimport { decodeDepthRgb } from \"./Decode\";\nimport { addRenderOrderConstants, readDepthAndOrder } from \"./FeatureSymbology\";\nimport { addWindowToTexCoords, assignFragColor } from \"./Fragment\";\nimport { addViewport } from \"./Viewport\";\nimport { createViewportQuadBuilder } from \"./ViewportQuad\";\n// 'PB' indicates a shader variation when only the pickbuffer is available\n// 'DB' indicates a shader variation when the real floating point depth buffer is available.\nconst computeAmbientOcclusionPrefixPB = `\r\nvec2 tc = windowCoordsToTexCoords(gl_FragCoord.xy);\r\nvec2 depthAndOrder = readDepthAndOrder(tc);\r\nfloat db = depthAndOrder.y;\r\n`;\nconst computeAmbientOcclusionPrefixDB = `\r\nvec2 tc = windowCoordsToTexCoords(gl_FragCoord.xy);\r\nvec2 depthAndOrder = readDepthAndOrder(tc);\r\nfloat db = readDepth(tc);\r\n`;\n// This outputs 1 for unlit surfaces, and for polylines and point strings.\n// Otherwise it computes ambient occlusion based on normal reconstructed from pick depth.\n// NB: This shader code actually begins with a `computeAmbientOcclusionPrefix` variation as shown above.\nconst computeAmbientOcclusion = `\r\n  depthAndOrder.y = unfinalizeLinearDepth(db);\r\n  float order = depthAndOrder.x;\r\n  if (order >= kRenderOrder_PlanarBit)\r\n    order = order - kRenderOrder_PlanarBit;\r\n\r\n  if (order < kRenderOrder_LitSurface || order == kRenderOrder_Linear)\r\n    return vec4(1.0);\r\n\r\n  // NB: linearDepth: 1 == near, 0 == far\r\n\r\n  float linearDepth = depthAndOrder.y;\r\n  float nonLinearDepth = computeNonLinearDepth(db);\r\n  if (nonLinearDepth > u_maxDistance)\r\n    return vec4(1.0);\r\n\r\n  vec3 viewPos = computePositionFromDepth(tc, nonLinearDepth).xyz;\r\n\r\n  vec2 pixelSize = 1.0 / u_viewport;\r\n  vec3 viewNormal = computeNormalFromDepth(viewPos, tc, pixelSize);\r\n\r\n  vec2 sampleDirection = vec2(1.0, 0.0);\r\n  float gapAngle = 90.0 * 0.017453292519943295; // radians per degree\r\n\r\n  // Grab some random noise\r\n  // Multiply screen UV (range 0..1) with size of viewport divided by 4 in order to tile the 4x4 noise texture across the screen.\r\n  // Multiply the random 0..1 vec3 by 2 and then substract 1.  This puts the components of the vec3 in the range -1..1.\r\n  vec3 noiseVec = (TEXTURE(u_noise, tc * vec2(u_viewport.x / 4.0, u_viewport.y / 4.0)).rgb + 1.0) / 2.0;\r\n\r\n  float bias = u_hbaoSettings.x; // Represents an angle in radians. If the dot product between the normal of the sample and the vector to the camera is less than this value, sampling stops in the current direction. This is used to remove shadows from near planar edges.\r\n  float zLengthCap = u_hbaoSettings.y; // If the distance in linear Z from the current sample to first sample is greater than this value, sampling stops in the current direction.\r\n  float intensity = u_hbaoSettings.z; // Raise the final occlusion to the power of this value.  Larger values make the ambient shadows darker.\r\n  float texelStepSize = clamp(u_hbaoSettings.w * linearDepth, 1.0, u_hbaoSettings.w); // Indicates the distance to step toward the next texel sample in the current direction.\r\n\r\n  float tOcclusion = 0.0;\r\n\r\n  // loop for each direction\r\n  for (int i = 0; i < 4; i++) {\r\n    float newGapAngle = gapAngle * (float(i) + noiseVec.x);\r\n    float cosVal = cos(newGapAngle);\r\n    float sinVal = sin(newGapAngle);\r\n\r\n    // rotate sampling direction\r\n    vec2 rotatedSampleDirection = vec2(cosVal * sampleDirection.x - sinVal * sampleDirection.y, sinVal * sampleDirection.x + cosVal * sampleDirection.y);\r\n    float curOcclusion = 0.0;\r\n    float curStepSize = texelStepSize; // 1.0 = stepsize, StepSize should be specified by uniform - what are good values?\r\n\r\n    // loop for each step\r\n    for (int j = 0; j < 6; j++) {\r\n      vec2 directionWithStep = vec2(rotatedSampleDirection.x * curStepSize * pixelSize.x, rotatedSampleDirection.y * curStepSize * pixelSize.y);\r\n      vec2 newCoords = directionWithStep + tc;\r\n\r\n      // do not repeat around the depth texture\r\n      if(newCoords.x > 1.0 || newCoords.y > 1.0 || newCoords.x < 0.0 || newCoords.y < 0.0) {\r\n          break;\r\n      }\r\n\r\n      db = readDepth(newCoords);\r\n      float curLinearDepth = unfinalizeLinearDepth(db);\r\n      float curNonLinearDepth = computeNonLinearDepth(db);\r\n      vec3 curViewPos = computePositionFromDepth(newCoords, curNonLinearDepth).xyz;\r\n      vec3 diffVec = curViewPos.xyz - viewPos.xyz;\r\n      float zLength = abs(curLinearDepth - linearDepth);\r\n\r\n      float dotVal = clamp(dot(viewNormal, normalize(diffVec)), 0.0, 1.0);\r\n      float weight = smoothstep(0.0, 1.0, zLengthCap / zLength);\r\n\r\n      if (dotVal < bias) {\r\n          dotVal = 0.0;\r\n      }\r\n\r\n      curOcclusion = max(curOcclusion, dotVal * weight);\r\n      curStepSize += texelStepSize;\r\n    }\r\n    tOcclusion += curOcclusion;\r\n  }\r\n\r\n  float distanceFadeFactor = kFrustumType_Perspective == u_frustum.z ? 1.0 - pow(clamp(nonLinearDepth / u_maxDistance, 0.0, 1.0), 4.0) : 1.0;\r\n  tOcclusion *= distanceFadeFactor;\r\n\r\n  tOcclusion /= 4.0;\r\n  tOcclusion = 1.0 - clamp(tOcclusion, 0.0, 1.0);\r\n  tOcclusion = pow(tOcclusion, intensity);\r\n\r\n  return vec4(tOcclusion, tOcclusion, tOcclusion, 1.0);\r\n`;\nconst computePositionFromDepth = `\r\nvec4 computePositionFromDepth(vec2 tc, float nonLinearDepth) {\r\n  if (kFrustumType_Perspective == u_frustum.z) {\r\n    vec2 xy = vec2((tc.x * 2.0 - 1.0), ((1.0 - tc.y) * 2.0 - 1.0));\r\n    vec4 posEC = u_invProj * vec4(xy, nonLinearDepth, 1.0);\r\n    posEC = posEC / posEC.w;\r\n    return posEC;\r\n  } else {\r\n    float top = u_frustumPlanes.x;\r\n    float bottom = u_frustumPlanes.y;\r\n    float left = u_frustumPlanes.z;\r\n    float right = u_frustumPlanes.w;\r\n    return vec4(mix(left, right, tc.x), mix(bottom, top, tc.y), nonLinearDepth, 1.0);\r\n  }\r\n}\r\n`;\nconst computeNormalFromDepth = `\r\nvec3 computeNormalFromDepth(vec3 viewPos, vec2 tc, vec2 pixelSize) {\r\n  float nonLinearDepthU = computeNonLinearDepth(readDepth(tc - vec2(0.0, pixelSize.y)));\r\n  float nonLinearDepthD = computeNonLinearDepth(readDepth(tc + vec2(0.0, pixelSize.y)));\r\n  float nonLinearDepthL = computeNonLinearDepth(readDepth(tc - vec2(pixelSize.x, 0.0)));\r\n  float nonLinearDepthR = computeNonLinearDepth(readDepth(tc + vec2(pixelSize.x, 0.0)));\r\n\r\n  vec3 viewPosUp = computePositionFromDepth(tc - vec2(0.0, pixelSize.y), nonLinearDepthU).xyz;\r\n  vec3 viewPosDown = computePositionFromDepth(tc + vec2(0.0, pixelSize.y), nonLinearDepthD).xyz;\r\n  vec3 viewPosLeft = computePositionFromDepth(tc - vec2(pixelSize.x, 0.0), nonLinearDepthL).xyz;\r\n  vec3 viewPosRight = computePositionFromDepth(tc + vec2(pixelSize.x, 0.0), nonLinearDepthR).xyz;\r\n\r\n  vec3 up = viewPos.xyz - viewPosUp.xyz;\r\n  vec3 down = viewPosDown.xyz - viewPos.xyz;\r\n  vec3 left = viewPos.xyz - viewPosLeft.xyz;\r\n  vec3 right = viewPosRight.xyz - viewPos.xyz;\r\n\r\n  vec3 dx = length(left) < length(right) ? left : right;\r\n  vec3 dy = length(up) < length(down) ? up : down;\r\n\r\n  return normalize(cross(dy, dx));\r\n}\r\n`;\nconst computeNonLinearDepthPB = `\r\nfloat computeNonLinearDepth(float linearDepth) {\r\n  return mix(u_frustum.y, u_frustum.x, linearDepth);\r\n}\r\n`;\nconst computeNonLinearDepthDB = `\r\nfloat computeNonLinearDepth(float depth) {\r\n  return 0.0 == u_logZ.x ? depth * u_logZ.y : exp(depth * u_logZ.y) / u_logZ.x;\r\n}\r\n`;\nconst readDepthPB = `\r\nfloat readDepth(vec2 tc) {\r\n  return readDepthAndOrder(tc).y;\r\n}\r\n`;\nconst readDepthDB = `\r\nfloat readDepth(vec2 tc) {\r\n  return TEXTURE(u_depthBuffer, tc).r;\r\n}\r\n`;\nconst unfinalizeLinearDepthDB = `\r\n  float unfinalizeLinearDepth(float depth) {\r\n    float eyeZ = 0.0 == u_logZ.x ? depth * u_logZ.y : exp(depth * u_logZ.y) / u_logZ.x;\r\n    float near = u_frustum.x, far = u_frustum.y;\r\n    float depthRange = far - near;\r\n    float linearDepth = (eyeZ - near) / depthRange;\r\n    return 1.0 - linearDepth;\r\n  }\r\n`;\nfunction _shouldUseDB() {\n    return System.instance.supportsLogZBuffer;\n}\n/** @internal */\nexport function createAmbientOcclusionProgram(context) {\n    const builder = createViewportQuadBuilder(true);\n    const frag = builder.frag;\n    const shouldUseDB = _shouldUseDB();\n    addWindowToTexCoords(frag);\n    frag.addFunction(decodeDepthRgb);\n    frag.addFunction(readDepthAndOrder);\n    if (shouldUseDB) {\n        frag.addFunction(unfinalizeLinearDepthDB);\n        frag.addFunction(computeNonLinearDepthDB);\n        frag.addFunction(readDepthDB);\n    }\n    else {\n        frag.addDefine(\"unfinalizeLinearDepth\", \"\");\n        frag.addFunction(computeNonLinearDepthPB);\n        frag.addFunction(readDepthPB);\n    }\n    frag.addFunction(computePositionFromDepth);\n    frag.addFunction(computeNormalFromDepth);\n    addRenderOrderConstants(frag);\n    if (shouldUseDB)\n        frag.addUniform(\"u_logZ\", 3 /* VariableType.Vec2 */, (prog) => {\n            prog.addProgramUniform(\"u_logZ\", (uniform, params) => {\n                uniform.setUniform2fv(params.target.uniforms.frustum.logZ);\n            });\n        });\n    frag.set(1 /* FragmentShaderComponent.ComputeBaseColor */, shouldUseDB ?\n        computeAmbientOcclusionPrefixDB + computeAmbientOcclusion :\n        computeAmbientOcclusionPrefixPB + computeAmbientOcclusion);\n    frag.set(16 /* FragmentShaderComponent.AssignFragData */, assignFragColor);\n    frag.addUniform(\"u_pickDepthAndOrder\", 8 /* VariableType.Sampler2D */, (prog) => {\n        prog.addGraphicUniform(\"u_pickDepthAndOrder\", (uniform, params) => {\n            const geom = params.geometry;\n            Texture2DHandle.bindSampler(uniform, geom.depthAndOrder, TextureUnit.Zero);\n        });\n    });\n    if (shouldUseDB)\n        frag.addUniform(\"u_depthBuffer\", 8 /* VariableType.Sampler2D */, (prog) => {\n            prog.addGraphicUniform(\"u_depthBuffer\", (uniform, params) => {\n                const geom = params.geometry;\n                Texture2DHandle.bindSampler(uniform, geom.depth, TextureUnit.Two);\n            });\n        });\n    frag.addUniform(\"u_noise\", 8 /* VariableType.Sampler2D */, (prog) => {\n        prog.addGraphicUniform(\"u_noise\", (uniform, params) => {\n            const geom = params.geometry;\n            Texture2DHandle.bindSampler(uniform, geom.noise, TextureUnit.One);\n        });\n    });\n    addFrustum(builder);\n    addViewport(frag);\n    frag.addUniform(\"u_invProj\", 7 /* VariableType.Mat4 */, (prog) => {\n        prog.addProgramUniform(\"u_invProj\", (uniform, params) => {\n            const invProj = params.projectionMatrix.clone();\n            invProj.invert();\n            uniform.setMatrix4(invProj);\n        });\n    });\n    frag.addUniform(\"u_frustumPlanes\", 5 /* VariableType.Vec4 */, (prog) => {\n        prog.addProgramUniform(\"u_frustumPlanes\", (uniform, params) => {\n            uniform.setUniform4fv(params.target.uniforms.frustum.planes);\n        });\n    });\n    frag.addUniform(\"u_hbaoSettings\", 5 /* VariableType.Vec4 */, (prog) => {\n        prog.addProgramUniform(\"u_hbaoSettings\", (uniform, params) => {\n            const hbaoSettings = new Float32Array([\n                params.target.ambientOcclusionSettings.bias,\n                params.target.ambientOcclusionSettings.zLengthCap,\n                params.target.ambientOcclusionSettings.intensity,\n                params.target.ambientOcclusionSettings.texelStepSize\n            ]);\n            uniform.setUniform4fv(hbaoSettings);\n        });\n    }, 3 /* VariablePrecision.High */);\n    frag.addUniform(\"u_maxDistance\", 2 /* VariableType.Float */, (prog) => {\n        prog.addProgramUniform(\"u_maxDistance\", (uniform, params) => {\n            uniform.setUniform1f(params.target.ambientOcclusionSettings.maxDistance);\n        });\n    }, 3 /* VariablePrecision.High */);\n    builder.vert.headerComment = \"//!V! AmbientOcclusion\";\n    builder.frag.headerComment = \"//!F! AmbientOcclusion\";\n    return builder.buildProgram(context);\n}\n//# sourceMappingURL=AmbientOcclusion.js.map",
      "start": 1693508124600,
      "end": 1693508124700,
      "sourcemaps": null
    }
  ]
}
