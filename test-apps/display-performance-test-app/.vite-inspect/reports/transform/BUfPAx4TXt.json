{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/curve/PointString3d.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Curve\n */\nimport { Geometry } from \"../Geometry\";\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\nimport { Point3dArray } from \"../geometry3d/PointHelpers\";\nimport { GeometryQuery } from \"./GeometryQuery\";\n/* eslint-disable @typescript-eslint/naming-convention, no-empty */\n/**\n * A PointString3d is an array of points.\n * * PointString3D is first class (displayable, possibly persistent) geometry derived from the GeometryQuery base class.\n * * The various points in the PointString3d are NOT connected by line segments for display or other calculations.\n * @public\n */\nexport class PointString3d extends GeometryQuery {\n    /** Test if `other` is a PointString3d */\n    isSameGeometryClass(other) { return other instanceof PointString3d; }\n    /** return a clone of the points array. */\n    get points() { return this._points; }\n    constructor() {\n        super();\n        /** String name for schema properties */\n        this.geometryCategory = \"pointCollection\";\n        this._points = [];\n    }\n    /** Clone and apply a transform. */\n    cloneTransformed(transform) {\n        const c = this.clone();\n        c.tryTransformInPlace(transform);\n        return c;\n    }\n    static flattenArray(arr) {\n        return arr.reduce((flat, toFlatten) => {\n            return flat.concat(Array.isArray(toFlatten) ? PointString3d.flattenArray(toFlatten) : toFlatten);\n        }, []);\n    }\n    /** Create a PointString3d from points. */\n    static create(...points) {\n        const result = new PointString3d();\n        result.addPoints(points);\n        return result;\n    }\n    /** Add multiple points to the PointString3d */\n    addPoints(...points) {\n        const toAdd = PointString3d.flattenArray(points);\n        for (const p of toAdd) {\n            if (p instanceof Point3d)\n                this._points.push(p);\n        }\n    }\n    /** Add a single point to the PointString3d */\n    addPoint(point) {\n        this._points.push(point);\n    }\n    /** Remove the last point added to the PointString3d */\n    popPoint() {\n        this._points.pop();\n    }\n    /** Replace this PointString3d's point array by a clone of the array in `other` */\n    setFrom(other) {\n        this._points = Point3dArray.clonePoint3dArray(other._points);\n    }\n    /** Create from an array of Point3d */\n    static createPoints(points) {\n        const ps = new PointString3d();\n        ps._points = Point3dArray.clonePoint3dArray(points);\n        return ps;\n    }\n    /** Create a PointString3d from xyz coordinates packed in a Float64Array */\n    static createFloat64Array(xyzData) {\n        const ps = new PointString3d();\n        for (let i = 0; i + 3 <= xyzData.length; i += 3)\n            ps._points.push(Point3d.create(xyzData[i], xyzData[i + 1], xyzData[i + 2]));\n        return ps;\n    }\n    /** Return a deep clone. */\n    clone() {\n        const retVal = new PointString3d();\n        retVal.setFrom(this);\n        return retVal;\n    }\n    /** Replace this instance's points by those from a json array, e.g. `[[1,2,3], [4,2,2]]` */\n    setFromJSON(json) {\n        this._points.length = 0;\n        if (Array.isArray(json)) {\n            let xyz;\n            for (xyz of json)\n                this._points.push(Point3d.fromJSON(xyz));\n        }\n    }\n    /**\n     * Convert an PointString3d to a JSON object.\n     * @return {*} [[x,y,z],...[x,y,z]]\n     */\n    toJSON() {\n        const value = [];\n        for (const p of this._points)\n            value.push(p.toJSON());\n        return value;\n    }\n    /** Create a PointString3d from a json array, e.g. `[[1,2,3], [4,2,2]]` */\n    static fromJSON(json) {\n        const ps = new PointString3d();\n        ps.setFromJSON(json);\n        return ps;\n    }\n    /** Access a single point by index. */\n    pointAt(i, result) {\n        if (i >= 0 && i < this._points.length) {\n            if (result) {\n                result.setFrom(this._points[i]);\n                return result;\n            }\n            return this._points[i].clone();\n        }\n        return undefined;\n    }\n    /** Return the number of points. */\n    numPoints() { return this._points.length; }\n    /** Reverse the point order */\n    reverseInPlace() {\n        if (this._points.length >= 2) {\n            let i0 = 0;\n            let i1 = this._points.length - 1;\n            while (i0 < i1) {\n                const a = this._points[i0];\n                this._points[i1] = this._points[i0];\n                this._points[i0] = a;\n                i0++;\n                i1--;\n            }\n        }\n    }\n    /** Return the number of points. */\n    tryTransformInPlace(transform) {\n        transform.multiplyPoint3dArrayInPlace(this._points);\n        return true;\n    }\n    /** Return the index and coordinates of the closest point to spacePoint. */\n    closestPoint(spacePoint) {\n        const result = { index: -1, xyz: Point3d.create() };\n        const index = Point3dArray.closestPointIndex(this._points, spacePoint);\n        if (index >= 0) {\n            result.index = index;\n            result.xyz.setFrom(this._points[index]);\n        }\n        return result;\n    }\n    /** Return true if all points are in the given plane. */\n    isInPlane(plane) {\n        return Point3dArray.isCloseToPlane(this._points, plane, Geometry.smallMetricDistance);\n    }\n    /** Extend a range to include the points in this PointString3d. */\n    extendRange(rangeToExtend, transform) {\n        rangeToExtend.extendArray(this._points, transform);\n    }\n    /** Return true if corresponding points are almost equal. */\n    isAlmostEqual(other) {\n        if (!(other instanceof PointString3d))\n            return false;\n        return Point3dArray.isAlmostEqual(this._points, other._points);\n    }\n    /** Reduce to empty set of points. */\n    clear() { this._points.length = 0; }\n    /** Second step of double dispatch:  call `handler.handlePointString(this)` */\n    dispatchToGeometryHandler(handler) {\n        return handler.handlePointString3d(this);\n    }\n}\n//# sourceMappingURL=PointString3d.js.map",
      "start": 1693508122825,
      "end": 1693508122982,
      "sourcemaps": null
    }
  ]
}
