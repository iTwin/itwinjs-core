{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/AccuDraw.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module AccuDraw\n */\nimport { BentleyStatus } from \"@itwin/core-bentley\";\nimport { Arc3d, AxisOrder, CurveCurve, Geometry, IModelJson as GeomJson, LineSegment3d, LineString3d, Matrix3d, Plane3dByOriginAndUnitNormal, Point2d, Point3d, PointString3d, Ray3d, Transform, Vector3d, } from \"@itwin/core-geometry\";\nimport { ColorByName, ColorDef, LinePixels } from \"@itwin/core-common\";\nimport { TentativeOrAccuSnap } from \"./AccuSnap\";\nimport { ACSDisplayOptions } from \"./AuxCoordSys\";\nimport { SnapHeat, SnapMode } from \"./HitDetail\";\nimport { IModelApp } from \"./IModelApp\";\nimport { GraphicType } from \"./render/GraphicBuilder\";\nimport { StandardViewId } from \"./StandardView\";\nimport { BeButton, BeButtonEvent, CoordinateLockOverrides, InputCollector, InputSource } from \"./tools/Tool\";\nimport { ViewTool } from \"./tools/ViewTool\";\nimport { linePlaneIntersect } from \"./LinePlaneIntersect\";\nimport { ViewState } from \"./ViewState\";\nimport { QuantityType } from \"./quantity-formatting/QuantityFormatter\";\nimport { ParseError, Parser } from \"@itwin/core-quantity\";\n// cspell:ignore dont primitivetools\n/** @internal */\nexport var AccuDrawFlags;\n(function (AccuDrawFlags) {\n    AccuDrawFlags[AccuDrawFlags[\"None\"] = 0] = \"None\";\n    AccuDrawFlags[AccuDrawFlags[\"SetModePolar\"] = 1] = \"SetModePolar\";\n    AccuDrawFlags[AccuDrawFlags[\"SetModeRect\"] = 2] = \"SetModeRect\";\n    AccuDrawFlags[AccuDrawFlags[\"SetOrigin\"] = 4] = \"SetOrigin\";\n    AccuDrawFlags[AccuDrawFlags[\"FixedOrigin\"] = 8] = \"FixedOrigin\";\n    AccuDrawFlags[AccuDrawFlags[\"SetRMatrix\"] = 16] = \"SetRMatrix\";\n    AccuDrawFlags[AccuDrawFlags[\"SetXAxis\"] = 32] = \"SetXAxis\";\n    AccuDrawFlags[AccuDrawFlags[\"SetNormal\"] = 64] = \"SetNormal\";\n    AccuDrawFlags[AccuDrawFlags[\"SetDistance\"] = 128] = \"SetDistance\";\n    AccuDrawFlags[AccuDrawFlags[\"LockDistance\"] = 256] = \"LockDistance\";\n    AccuDrawFlags[AccuDrawFlags[\"Lock_X\"] = 512] = \"Lock_X\";\n    AccuDrawFlags[AccuDrawFlags[\"Lock_Y\"] = 1024] = \"Lock_Y\";\n    AccuDrawFlags[AccuDrawFlags[\"Lock_Z\"] = 2048] = \"Lock_Z\";\n    AccuDrawFlags[AccuDrawFlags[\"Disable\"] = 4096] = \"Disable\";\n    AccuDrawFlags[AccuDrawFlags[\"OrientDefault\"] = 16384] = \"OrientDefault\";\n    AccuDrawFlags[AccuDrawFlags[\"SetFocus\"] = 32768] = \"SetFocus\";\n    AccuDrawFlags[AccuDrawFlags[\"OrientACS\"] = 131072] = \"OrientACS\";\n    AccuDrawFlags[AccuDrawFlags[\"SetXAxis2\"] = 262144] = \"SetXAxis2\";\n    AccuDrawFlags[AccuDrawFlags[\"LockAngle\"] = 524288] = \"LockAngle\";\n    AccuDrawFlags[AccuDrawFlags[\"AlwaysSetOrigin\"] = 2097156] = \"AlwaysSetOrigin\";\n    AccuDrawFlags[AccuDrawFlags[\"RedrawCompass\"] = 4194304] = \"RedrawCompass\";\n    AccuDrawFlags[AccuDrawFlags[\"UpdateRotation\"] = 8388608] = \"UpdateRotation\";\n    AccuDrawFlags[AccuDrawFlags[\"SmartRotation\"] = 16777216] = \"SmartRotation\";\n})(AccuDrawFlags || (AccuDrawFlags = {}));\n/** AccuDraw coordinate input mode\n * @public\n */\nexport var CompassMode;\n(function (CompassMode) {\n    /** Coordinate input using distance and angle */\n    CompassMode[CompassMode[\"Polar\"] = 0] = \"Polar\";\n    /** Coordinate input using x, y, and z deltas */\n    CompassMode[CompassMode[\"Rectangular\"] = 1] = \"Rectangular\";\n})(CompassMode || (CompassMode = {}));\n/** AccuDraw compass base rotation\n * @public\n */\nexport var RotationMode;\n(function (RotationMode) {\n    /** Aligned with standard view top or ACS top when [[ToolAdmin.acsContextLock]] is enabled */\n    RotationMode[RotationMode[\"Top\"] = 1] = \"Top\";\n    /** Aligned with standard view front or ACS front when [[ToolAdmin.acsContextLock]] is enabled */\n    RotationMode[RotationMode[\"Front\"] = 2] = \"Front\";\n    /** Aligned with standard view right or ACS right when [[ToolAdmin.acsContextLock]] is enabled */\n    RotationMode[RotationMode[\"Side\"] = 3] = \"Side\";\n    /** Aligned with view */\n    RotationMode[RotationMode[\"View\"] = 4] = \"View\";\n    /** Aligned with view ACS */\n    RotationMode[RotationMode[\"ACS\"] = 5] = \"ACS\";\n    /** Not aligned with a standard rotation or ACS */\n    RotationMode[RotationMode[\"Context\"] = 6] = \"Context\";\n})(RotationMode || (RotationMode = {}));\n/** @internal */\nexport var LockedStates;\n(function (LockedStates) {\n    LockedStates[LockedStates[\"NONE_LOCKED\"] = 0] = \"NONE_LOCKED\";\n    LockedStates[LockedStates[\"X_BM\"] = 1] = \"X_BM\";\n    LockedStates[LockedStates[\"Y_BM\"] = 2] = \"Y_BM\";\n    LockedStates[LockedStates[\"VEC_BM\"] = 4] = \"VEC_BM\";\n    LockedStates[LockedStates[\"DIST_BM\"] = 8] = \"DIST_BM\";\n    LockedStates[LockedStates[\"XY_BM\"] = 3] = \"XY_BM\";\n    LockedStates[LockedStates[\"ANGLE_BM\"] = 7] = \"ANGLE_BM\";\n})(LockedStates || (LockedStates = {}));\n/** AccuDraw enabled states\n * @public\n */\nexport var CurrentState;\n(function (CurrentState) {\n    /** Compass disabled/unwanted for this session */\n    CurrentState[CurrentState[\"NotEnabled\"] = 0] = \"NotEnabled\";\n    /** Compass deactivated but CAN be activated by user */\n    CurrentState[CurrentState[\"Deactivated\"] = 1] = \"Deactivated\";\n    /** Compass not displayed awaiting automatic activation (default tool state) */\n    CurrentState[CurrentState[\"Inactive\"] = 2] = \"Inactive\";\n    /** Compass displayed and adjusting points */\n    CurrentState[CurrentState[\"Active\"] = 3] = \"Active\";\n})(CurrentState || (CurrentState = {}));\n/** @internal */\nexport var ContextMode;\n(function (ContextMode) {\n    ContextMode[ContextMode[\"Locked\"] = 0] = \"Locked\";\n    ContextMode[ContextMode[\"XAxis\"] = 1] = \"XAxis\";\n    ContextMode[ContextMode[\"YAxis\"] = 2] = \"YAxis\";\n    ContextMode[ContextMode[\"ZAxis\"] = 3] = \"ZAxis\";\n    ContextMode[ContextMode[\"XAxis2\"] = 4] = \"XAxis2\";\n    ContextMode[ContextMode[\"None\"] = 15] = \"None\";\n})(ContextMode || (ContextMode = {}));\n/** AccuDraw coordinate input fields\n * @public\n */\nexport var ItemField;\n(function (ItemField) {\n    /** Distance for polar mode */\n    ItemField[ItemField[\"DIST_Item\"] = 0] = \"DIST_Item\";\n    /** Angle for polar mode */\n    ItemField[ItemField[\"ANGLE_Item\"] = 1] = \"ANGLE_Item\";\n    /** X delta for rectangular mode */\n    ItemField[ItemField[\"X_Item\"] = 2] = \"X_Item\";\n    /** Y delta for rectangular mode */\n    ItemField[ItemField[\"Y_Item\"] = 3] = \"Y_Item\";\n    /** Z delta (3d only) */\n    ItemField[ItemField[\"Z_Item\"] = 4] = \"Z_Item\";\n})(ItemField || (ItemField = {}));\n/** @internal */\nexport var KeyinStatus;\n(function (KeyinStatus) {\n    KeyinStatus[KeyinStatus[\"Dynamic\"] = 0] = \"Dynamic\";\n    KeyinStatus[KeyinStatus[\"Partial\"] = 1] = \"Partial\";\n    KeyinStatus[KeyinStatus[\"DontUpdate\"] = 2] = \"DontUpdate\";\n})(KeyinStatus || (KeyinStatus = {}));\n/** @internal */\nexport class AccudrawData {\n    constructor() {\n        this.flags = 0; // AccuDrawFlags\n        this.origin = new Point3d(); // used if ACCUDRAW_SetOrigin\n        this.delta = new Point3d(); // if ACCUDRAW_Lock_X, etc.\n        this.rMatrix = new Matrix3d(); // if ACCUDRAW_SetRMatrix/ACCUDRAW_Set3dMatrix\n        this.vector = new Vector3d(); // if ACCUDRAW_SetXAxis, etc.\n        this.distance = 0; // if ACCUDRAW_SetDistance\n        this.angle = 0; // if ACCUDRAW_SetAngle\n    }\n    zero() {\n        this.flags = this.distance = this.angle = 0;\n        this.origin.setZero();\n        this.delta.setZero();\n        this.vector.setZero();\n        this.rMatrix.setIdentity();\n    }\n}\n/** @internal */\nexport class Flags {\n    constructor() {\n        this.redrawCompass = false;\n        this.dialogNeedsUpdate = false;\n        this.rotationNeedsUpdate = true;\n        this.lockedRotation = false;\n        this.indexLocked = false;\n        this.haveValidOrigin = false;\n        this.fixedOrg = false;\n        this.auxRotationPlane = RotationMode.Top;\n        this.contextRotMode = 0;\n        this.baseRotation = RotationMode.View;\n        this.baseMode = 0;\n        this.pointIsOnPlane = false; // whether rawPointOnPlane is on compass plane\n        this.softAngleLock = false;\n        this.bearingFixToPlane2D = false;\n        this.inDataPoint = false;\n        this.ignoreDataButton = false;\n        this.animateRotation = false;\n    }\n}\n/** @internal */\nexport class RoundOff {\n    constructor() {\n        this.active = false;\n        this.units = new Set();\n    }\n}\n/** @internal */\nexport class SavedState {\n    constructor() {\n        this.state = CurrentState.NotEnabled;\n        this.mode = CompassMode.Polar;\n        this.rotationMode = RotationMode.View;\n        this.axes = new ThreeAxes();\n        this.origin = new Point3d();\n        this.auxRotationPlane = 0;\n        this.contextRotMode = 0;\n        this.fixedOrg = false;\n        this.ignoreDataButton = true; // By default the data point that terminates a view tool or input collector should be ignored...\n        this.ignoreFlags = 0;\n    }\n}\n/** @internal */\nclass SavedCoords {\n    constructor() {\n        this.nSaveValues = 0;\n        this.savedValues = [];\n        this.savedValIsAngle = [];\n    }\n}\n/** @internal */\nexport class ThreeAxes {\n    constructor() {\n        this.x = Vector3d.unitX();\n        this.y = Vector3d.unitY();\n        this.z = Vector3d.unitZ();\n    }\n    setFrom(other) {\n        this.x.setFrom(other.x);\n        this.y.setFrom(other.y);\n        this.z.setFrom(other.z);\n    }\n    fromMatrix3d(rMatrix) {\n        rMatrix.getRow(0, this.x);\n        rMatrix.getRow(1, this.y);\n        rMatrix.getRow(2, this.z);\n    }\n    static createFromMatrix3d(rMatrix, result) {\n        result = result ? result : new ThreeAxes();\n        result.fromMatrix3d(rMatrix);\n        return result;\n    }\n    toMatrix3d(out) { return Matrix3d.createRows(this.x, this.y, this.z, out); }\n    clone() {\n        const out = new ThreeAxes();\n        out.setFrom(this);\n        return out;\n    }\n    equals(other) { return this.x.isExactEqual(other.x) && this.y.isExactEqual(other.y) && this.z.isExactEqual(other.z); }\n}\n/** Accudraw is an aide for entering coordinate data.\n * This class is public to allow applications to provide a user interface for AccuDraw, either by implementing their own, or\n * using the one supplied by the itwin appui package.\n * @note When writing an [[InteractiveTool]] it is not correct to call methods on AccuDraw directly, tools should instead\n * provide hints to AccuDraw using [[AccuDrawHintBuilder]].\n * @public\n */\nclass AccuDraw {\n    constructor() {\n        this.currentState = CurrentState.NotEnabled; // Compass state\n        this.compassMode = CompassMode.Rectangular; // Compass mode\n        this.rotationMode = RotationMode.View; // Compass rotation\n        /** @internal */\n        this.published = new AccudrawData(); // Staging area for hints\n        /** @internal */\n        this.origin = new Point3d(); // origin point...not on compass plane when z != 0.0\n        /** @internal */\n        this.axes = new ThreeAxes(); // X, Y and Z vectors (3d rotation matrix)\n        /** @internal */\n        this.delta = Vector3d.unitZ(); // dialog items (x, y & z)\n        this._distance = 0; // current distance\n        this._angle = 0; // current angle\n        /** @internal */\n        this.locked = LockedStates.NONE_LOCKED; // axis/distance locked bit mask\n        /** @internal */\n        this.indexed = LockedStates.NONE_LOCKED; // axis/distance indexed bit mask\n        this._distanceRoundOff = new RoundOff(); // distance round off enabled and unit\n        this._angleRoundOff = new RoundOff(); // angle round off enabled and unit\n        /** @internal */\n        this.flags = new Flags(); // current state flags\n        this._fieldLocked = []; // locked state of fields\n        this._keyinStatus = []; // state of input field\n        /** @internal */\n        this.savedStateViewTool = new SavedState(); // Restore point for shortcuts/tools...\n        /** @internal */\n        this.savedStateInputCollector = new SavedState(); // Restore point for shortcuts/tools...\n        this._savedCoords = new SavedCoords(); // History of previous angles/distances...\n        /** @internal */\n        this.baseAxes = new ThreeAxes(); // Used for \"context\" base rotation to hold arbitrary rotation w/o needing to change ACS...\n        /** @internal */\n        this.lastAxes = new ThreeAxes(); // Last result from UpdateRotation, replaces cM.rMatrix...\n        this._lastDistance = 0; // previous saved distance or distance indexing tick\n        this._tolerance = 0; // computed view based indexing tolerance\n        this._percentChanged = 0; // Compass animation state\n        this._threshold = 0; // Threshold for automatic x/y field focus change.\n        /** @internal */\n        this.planePt = new Point3d(); // same as origin unless non-zero locked z value\n        this._rawDelta = new Point2d(); // used by rect fix point\n        this._rawPoint = new Point3d(); // raw uor point passed to fix point\n        this._rawPointOnPlane = new Point3d(); // adjusted rawPoint by applying hard/soft construction plane\n        /** @internal */\n        this.point = new Point3d(); // current cursor point\n        /** @internal */\n        this.vector = Vector3d.unitZ(); // current/last good locked direction\n        this._xIsNegative = false; // Last delta.x was negative\n        this._yIsNegative = false; // Last delta.y was negative\n        this._xIsExplicit = false; // Sign of delta.x established from user input input, don't allow +/- side flip.\n        this._yIsExplicit = false; // Sign of delta.y established from user input input, don't allow +/- side flip.\n        /** Disable automatic focus change when user is entering input. */\n        this.dontMoveFocus = false;\n        /** Set input field to move focus to (X_Item or Y_Item) for automatic focus change. */\n        this.newFocus = ItemField.X_Item;\n        this._rMatrix = new Matrix3d();\n        // Compass Display Preferences...\n        /** @internal */\n        this._compassSizeInches = 0.44;\n        /** @internal */\n        this._animationFrames = 12;\n        /** @internal */\n        this._indexToleranceInches = 0.11;\n        /** @internal */\n        this._frameColor = ColorDef.create(ColorByName.lightGrey);\n        /** @internal */\n        this._fillColor = ColorDef.create(ColorByName.blue);\n        /** @internal */\n        this._xColor = ColorDef.create(ColorByName.red);\n        /** @internal */\n        this._yColor = ColorDef.create(ColorByName.green);\n        /** @internal */\n        this._indexColor = ColorDef.create(ColorByName.white);\n        /** @internal */\n        this._frameColorNoFocus = ColorDef.create(ColorByName.darkGrey);\n        /** @internal */\n        this._fillColorNoFocus = ColorDef.create(ColorByName.lightGrey);\n        // User Preference Settings...\n        this.smartKeyin = true;\n        this.floatingOrigin = true;\n        this.stickyZLock = false;\n        this.alwaysShowCompass = false;\n        this.contextSensitive = true;\n        this.axisIndexing = true;\n        this.distanceIndexing = true;\n        this.autoFocusFields = true;\n        this.autoPointPlacement = false;\n    }\n    /** @internal */\n    onInitialized() { this.enableForSession(); }\n    /** @internal */\n    getRotation(rMatrix) {\n        if (!rMatrix)\n            rMatrix = this._rMatrix;\n        Matrix3d.createRows(this.axes.x, this.axes.y, this.axes.z, rMatrix);\n        return rMatrix;\n    }\n    get isActive() { return CurrentState.Active === this.currentState; }\n    get isEnabled() { return (this.currentState > CurrentState.NotEnabled); }\n    get isInactive() { return (CurrentState.Inactive === this.currentState); }\n    get isDeactivated() { return (CurrentState.Deactivated === this.currentState); }\n    /** Get the current lock state for the supplied input field */\n    getFieldLock(index) { return this._fieldLocked[index]; }\n    /** @internal */\n    getKeyinStatus(index) { return this._keyinStatus[index]; }\n    /** Implement this method to set focus to the AccuDraw UI. */\n    grabInputFocus() { }\n    /** @internal */\n    activate() {\n        // Upgrade state to inactive so upgradeToActiveState knows it is ok to move to active...\n        if (CurrentState.Deactivated === this.currentState)\n            this.currentState = CurrentState.Inactive;\n        this.upgradeToActiveState();\n    }\n    /** @internal */\n    deactivate() {\n        this.downgradeInactiveState();\n        // Don't allow compass to come back until user re-enables it...\n        if (CurrentState.Inactive === this.currentState)\n            this.currentState = CurrentState.Deactivated;\n    }\n    /** Change current compass input mode to either polar or rectangular */\n    setCompassMode(mode) {\n        if (mode === this.compassMode)\n            return;\n        this.compassMode = mode;\n        this.onCompassModeChange();\n    }\n    /** Change current compass orientation */\n    setRotationMode(mode) {\n        if (mode === this.rotationMode)\n            return;\n        this.rotationMode = mode;\n        this.onRotationModeChange();\n    }\n    /** Change the lock status for the supplied input field */\n    setFieldLock(index, locked) {\n        if (locked === this._fieldLocked[index])\n            return;\n        this._fieldLocked[index] = locked;\n        this.onFieldLockChange(index);\n    }\n    /** @internal */\n    setKeyinStatus(index, status) {\n        this._keyinStatus[index] = status;\n        if (KeyinStatus.Dynamic !== status)\n            this.dontMoveFocus = true;\n        if (KeyinStatus.Partial === status)\n            this._threshold = Math.abs(ItemField.X_Item === index ? this._rawDelta.y : this._rawDelta.x) + this._tolerance;\n    }\n    needsRefresh(vp) {\n        if (!this.isEnabled || this.isDeactivated)\n            return false;\n        // Get snap point from AccuSnap/Tentative or use raw point...\n        let distance = 0.0;\n        let snapPt = this._rawPoint;\n        const ptP = this.point;\n        const snap = TentativeOrAccuSnap.getCurrentSnap();\n        if (snap) {\n            snapPt = snap.snapPoint;\n            distance = ptP.distance(snapPt);\n        }\n        const isRectMode = (CompassMode.Rectangular === this.compassMode);\n        const offsetSnap = ((TentativeOrAccuSnap.isHot || IModelApp.tentativePoint.isActive) && ((this.locked) || (distance > 0.0)));\n        // XY Offset:\n        if (offsetSnap) {\n            if (isRectMode) {\n                let xIsOffset = false, yIsOffset = false;\n                const vec = ptP.vectorTo(this._rawPointOnPlane);\n                const xOffset = vec.dotProduct(this.axes.x);\n                const yOffset = vec.dotProduct(this.axes.y);\n                xIsOffset = (Math.abs(xOffset) > 1.0);\n                yIsOffset = (Math.abs(yOffset) > 1.0);\n                if (xIsOffset || yIsOffset)\n                    return true;\n            }\n        }\n        const isOnCompassPlane = (!vp.view.is3d() || this.flags.pointIsOnPlane || this.isZLocked(vp));\n        // Z Offset:\n        if (offsetSnap) {\n            if (isOnCompassPlane) {\n                const zOffset = snapPt.distance(this._rawPointOnPlane);\n                if (zOffset > 1e-12 /* Constants.SMALL_ANGLE */ || zOffset < -1e-12 /* Constants.SMALL_ANGLE */)\n                    return true;\n            }\n        }\n        // Fat Point:\n        if (offsetSnap)\n            return true;\n        let axisIsIndexed = false;\n        // Axis Indexing:\n        if (isRectMode) {\n            if ((this.indexed & LockedStates.XY_BM) && (this.flags.pointIsOnPlane || this._fieldLocked[ItemField.Z_Item]))\n                axisIsIndexed = true;\n        }\n        else {\n            if ((this.indexed & LockedStates.ANGLE_BM || this.locked & LockedStates.ANGLE_BM) && (this.flags.pointIsOnPlane || this._fieldLocked[ItemField.Z_Item]))\n                axisIsIndexed = true;\n        }\n        if (axisIsIndexed)\n            return true;\n        // Distance Indexing:\n        if (this.indexed & LockedStates.DIST_BM)\n            return true;\n        // XY Lock:\n        if (isRectMode) {\n            const locked = this.locked & LockedStates.XY_BM;\n            if ((0 !== locked) && isOnCompassPlane) {\n                switch (locked) {\n                    case LockedStates.X_BM:\n                    case LockedStates.Y_BM:\n                    case LockedStates.XY_BM:\n                        return true;\n                }\n            }\n        }\n        return false;\n    }\n    /** @internal */\n    adjustPoint(pointActive, vp, fromSnap) {\n        if (!this.isEnabled)\n            return false;\n        const lastWasIndexed = (0 !== this.indexed);\n        let pointChanged = false, handled = false;\n        if (0.0 !== pointActive.z && !vp.isPointAdjustmentRequired)\n            pointActive.z = 0.0;\n        if (1.0 !== vp.view.getAspectRatioSkew())\n            this.downgradeInactiveState(); // Disable AccuDraw if skew is applied with AccuDraw already active...\n        if (this.isInactive) {\n            this.point.setFrom(pointActive);\n            this.currentView = vp;\n            this.fixPoint(pointActive, vp);\n            if (!fromSnap && IModelApp.accuSnap.currHit)\n                this.flags.redrawCompass = true;\n        }\n        else if (this.isActive) {\n            const lastPt = this.point.clone();\n            this.fixPoint(pointActive, vp);\n            pointChanged = !lastPt.isExactEqual(this.point);\n            this.processHints();\n            handled = true;\n        }\n        else {\n            this.currentView = vp; // Keep view up to date...\n        }\n        // If redraw of compass isn't required (yet!) check if needed...\n        if (!this.flags.redrawCompass && this.isActive) {\n            // Redraw required to erase/draw old/new indexing geometry...\n            if (pointChanged && (lastWasIndexed || this.needsRefresh(vp)))\n                this.flags.redrawCompass = true;\n        }\n        // Redraw is necessary, force decorators to be called...\n        if (this.flags.redrawCompass)\n            vp.invalidateDecorations();\n        return handled;\n    }\n    setDefaultOrigin(vp) {\n        if (!vp || this.locked || this._fieldLocked[ItemField.Z_Item])\n            return;\n        const view = vp.view;\n        const rMatrix = view.getRotation();\n        const acsOrigin = vp.getAuxCoordOrigin();\n        rMatrix.multiplyVectorInPlace(acsOrigin);\n        const origin = view.getCenter();\n        view.getRotation().multiplyVectorInPlace(origin);\n        origin.z = acsOrigin.z;\n        view.getRotation().multiplyTransposeVectorInPlace(origin);\n        this.origin.setFrom(origin); // View center at acs z...\n        this.planePt.setFrom(origin);\n    }\n    /** @internal */\n    isZLocked(vp) {\n        if (this._fieldLocked[ItemField.Z_Item])\n            return true;\n        if (vp.isSnapAdjustmentRequired) //  && TentativeOrAccuSnap.isHot())\n            return true;\n        return false;\n    }\n    /** @internal */\n    accountForAuxRotationPlane(rot, plane) {\n        // ACS mode now can have \"front\" and \"side\" variations...\n        switch (plane) {\n            case RotationMode.Top:\n                return;\n            case RotationMode.Front:\n                const temp = rot.y.clone();\n                rot.y.setFrom(rot.z);\n                temp.scale(-1.0, rot.z);\n                return;\n            case RotationMode.Side:\n                const temp0 = rot.x.clone();\n                rot.x.setFrom(rot.y);\n                rot.y.setFrom(rot.z);\n                rot.z.setFrom(temp0);\n        }\n    }\n    accountForACSContextLock(vec) {\n        // Base rotation is relative to ACS when ACS context lock is enabled...\n        if (!this.currentView || !this.currentView.isContextRotationRequired)\n            return;\n        const rMatrix = AccuDraw.getStandardRotation(StandardViewId.Top, this.currentView, true);\n        rMatrix.multiplyTransposeVectorInPlace(vec);\n    }\n    static useACSContextRotation(vp, isSnap) {\n        if (isSnap) {\n            if (!vp.isSnapAdjustmentRequired)\n                return false;\n        }\n        else {\n            if (!vp.isContextRotationRequired)\n                return false;\n        }\n        return true;\n    }\n    /** Gets X, Y or Z vector from top, front, (right) side, ACS, or View. */\n    getStandardVector(whichVec) {\n        const vp = this.currentView;\n        let rMatrix;\n        let myAxes;\n        const vecP = Vector3d.createZero();\n        /* eslint-disable max-statements-per-line */\n        switch (this.flags.baseRotation) {\n            case RotationMode.Top:\n                switch (whichVec) {\n                    case 0:\n                        vecP.x = 1.0;\n                        break;\n                    case 1:\n                        vecP.y = 1.0;\n                        break;\n                    case 2:\n                        vecP.z = 1.0;\n                        break;\n                }\n                this.accountForACSContextLock(vecP);\n                break;\n            case RotationMode.Front:\n                switch (whichVec) {\n                    case 0:\n                        vecP.x = 1.0;\n                        break;\n                    case 1:\n                        vecP.z = 1.0;\n                        break;\n                    case 2:\n                        vecP.y = -1.0;\n                        break;\n                }\n                this.accountForACSContextLock(vecP);\n                break;\n            case RotationMode.Side:\n                switch (whichVec) {\n                    case 0:\n                        vecP.y = 1.0;\n                        break;\n                    case 1:\n                        vecP.z = 1.0;\n                        break;\n                    case 2:\n                        vecP.x = 1.0;\n                        break;\n                }\n                this.accountForACSContextLock(vecP);\n                break;\n            case RotationMode.ACS:\n                rMatrix = vp ? vp.getAuxCoordRotation() : Matrix3d.createIdentity();\n                myAxes = ThreeAxes.createFromMatrix3d(rMatrix);\n                this.accountForAuxRotationPlane(myAxes, this.flags.auxRotationPlane);\n                switch (whichVec) {\n                    case 0:\n                        vecP.setFrom(myAxes.x);\n                        break;\n                    case 1:\n                        vecP.setFrom(myAxes.y);\n                        break;\n                    case 2:\n                        vecP.setFrom(myAxes.z);\n                        break;\n                }\n                break;\n            case RotationMode.View:\n                rMatrix = vp ? vp.rotation : Matrix3d.createIdentity();\n                rMatrix.getRow(whichVec, vecP);\n                break;\n            case RotationMode.Context:\n                myAxes = this.baseAxes.clone();\n                this.accountForAuxRotationPlane(myAxes, this.flags.auxRotationPlane);\n                switch (whichVec) {\n                    case 0:\n                        vecP.setFrom(myAxes.x);\n                        break;\n                    case 1:\n                        vecP.setFrom(myAxes.y);\n                        break;\n                    case 2:\n                        vecP.setFrom(myAxes.z);\n                        break;\n                }\n                break;\n        }\n        /* eslint-enable max-statements-per-line */\n        return vecP;\n    }\n    getBestViewedRotationFromXVector(rotation, vp) {\n        const viewZ = vp.rotation.getRow(2);\n        const vec1 = this.getStandardVector(2);\n        const vec2 = this.getStandardVector(1);\n        const vec3 = this.getStandardVector(0);\n        const rot1 = vec1.crossProduct(rotation.x);\n        const rot2 = vec2.crossProduct(rotation.x);\n        const rot3 = vec3.crossProduct(rotation.x);\n        const useRot1 = (rot1.normalizeWithLength(rot1).mag > 0.00001);\n        const useRot2 = (rot2.normalizeWithLength(rot2).mag > 0.00001);\n        const useRot3 = (rot3.normalizeWithLength(rot3).mag > 0.00001);\n        const dot1 = (useRot1 ? Math.abs(rotation.x.crossProduct(rot1).dotProduct(viewZ)) : -1.0);\n        const dot2 = (useRot2 ? Math.abs(rotation.x.crossProduct(rot2).dotProduct(viewZ)) : -1.0);\n        const dot3 = (useRot3 ? Math.abs(rotation.x.crossProduct(rot3).dotProduct(viewZ)) : -1.0);\n        const max = Math.max(dot1, dot2, dot3);\n        if (Geometry.isDistanceWithinTol(dot1 - dot2, 0.1) && (max !== dot3))\n            rotation.y.setFrom(rot1);\n        else if (max === dot1)\n            rotation.y.setFrom(rot1);\n        else if (max === dot2)\n            rotation.y.setFrom(rot2);\n        else\n            rotation.y.setFrom(rot3);\n        rotation.z.setFrom(rotation.x.crossProduct(rotation.y));\n    }\n    getRotationFromVector(rotation, whichVec) {\n        let vec;\n        switch (whichVec) {\n            case 0:\n                vec = this.getStandardVector(2);\n                vec.crossProduct(rotation.x, rotation.y);\n                if (rotation.y.normalizeWithLength(rotation.y).mag < .00001) {\n                    vec = this.getStandardVector(1);\n                    vec.crossProduct(rotation.x, rotation.y);\n                    rotation.y.normalizeInPlace();\n                }\n                rotation.x.crossProduct(rotation.y, rotation.z);\n                break;\n            case 1:\n                vec = this.getStandardVector(2);\n                vec.crossProduct(rotation.y, rotation.x);\n                if (rotation.x.normalizeWithLength(rotation.x).mag < .00001) {\n                    vec = this.getStandardVector(0);\n                    vec.crossProduct(rotation.y, rotation.x);\n                    rotation.x.normalizeInPlace();\n                }\n                rotation.x.crossProduct(rotation.y, rotation.z);\n                break;\n            case 2:\n                vec = this.getStandardVector(0);\n                rotation.z.crossProduct(vec, rotation.y);\n                if (rotation.y.normalizeWithLength(rotation.y).mag < .00001) {\n                    vec = this.getStandardVector(1);\n                    vec.crossProduct(rotation.z, rotation.x);\n                    rotation.x.normalizeInPlace();\n                    rotation.z.crossProduct(rotation.x, rotation.y);\n                }\n                else {\n                    rotation.y.crossProduct(rotation.z, rotation.x);\n                }\n                break;\n        }\n    }\n    /** @internal */\n    updateRotation(animate = false, newRotationIn) {\n        let clearLocks = true;\n        const oldRotation = this.axes.clone();\n        let rMatrix;\n        let newRotation;\n        if (!newRotationIn)\n            newRotation = this.axes.clone(); // for axis based\n        else\n            newRotation = ThreeAxes.createFromMatrix3d(newRotationIn); // for animating context rotation change...\n        const vp = this.currentView;\n        const useACS = vp ? vp.isContextRotationRequired : false;\n        switch (this.rotationMode) {\n            case RotationMode.Top:\n                // Get standard rotation relative to ACS when ACS context lock is enabled...\n                newRotation.fromMatrix3d(AccuDraw.getStandardRotation(StandardViewId.Top, vp, useACS));\n                this.flags.lockedRotation = true;\n                break;\n            case RotationMode.Front:\n                // Get standard rotation relative to ACS when ACS context lock is enabled...\n                newRotation.fromMatrix3d(AccuDraw.getStandardRotation(StandardViewId.Front, vp, useACS));\n                this.flags.lockedRotation = true;\n                break;\n            case RotationMode.Side:\n                // Get standard rotation relative to ACS when ACS context lock is enabled...\n                newRotation.fromMatrix3d(AccuDraw.getStandardRotation(StandardViewId.Right, vp, useACS));\n                this.flags.lockedRotation = true;\n                break;\n            case RotationMode.ACS:\n                rMatrix = vp ? vp.getAuxCoordRotation() : Matrix3d.createIdentity();\n                newRotation.fromMatrix3d(rMatrix);\n                this.accountForAuxRotationPlane(newRotation, this.flags.auxRotationPlane);\n                this.flags.lockedRotation = true;\n                break;\n            case RotationMode.View:\n                rMatrix = vp ? vp.rotation : Matrix3d.createIdentity();\n                newRotation.fromMatrix3d(rMatrix);\n                this.flags.lockedRotation = false;\n                break;\n            case RotationMode.Context:\n                switch (this.flags.contextRotMode) {\n                    case ContextMode.XAxis:\n                        this.getRotationFromVector(newRotation, 0);\n                        clearLocks = (LockedStates.Y_BM !== this.locked || !oldRotation.x.isExactEqual(newRotation.x)); // Try to keep locked axis when tool being unsuspended...\n                        break;\n                    case ContextMode.XAxis2:\n                        if (vp)\n                            this.getBestViewedRotationFromXVector(newRotation, vp); // Use base rotation axis that results in compass being most closely aligned to view direction....\n                        else\n                            this.getRotationFromVector(newRotation, 0);\n                        clearLocks = (LockedStates.Y_BM !== this.locked || !oldRotation.x.isExactEqual(newRotation.x)); // Try to keep locked axis when tool being unsuspended...\n                        break;\n                    case ContextMode.YAxis:\n                        this.getRotationFromVector(newRotation, 1);\n                        clearLocks = (LockedStates.X_BM !== this.locked || !oldRotation.y.isExactEqual(newRotation.y)); // Try to keep locked axis when tool being unsuspended...\n                        break;\n                    case ContextMode.ZAxis:\n                        this.getRotationFromVector(newRotation, 2);\n                        break;\n                    case ContextMode.Locked:\n                        break;\n                }\n                break;\n        }\n        const isChanged = !oldRotation.equals(newRotation);\n        // unlock stuff if rotation has changed\n        if (isChanged && clearLocks && (CompassMode.Rectangular === this.compassMode || !this._fieldLocked[ItemField.DIST_Item] || animate)) {\n            this.locked = this.indexed = LockedStates.NONE_LOCKED;\n            this.unlockAllFields();\n        }\n        this.axes.setFrom(newRotation);\n        this.lastAxes.setFrom(newRotation);\n        this.flags.redrawCompass = true;\n        // If animate frame preference is set...\n        if (!animate || !vp)\n            return;\n        // AccuDrawAnimatorPtr animator = AccuDrawAnimator:: Create();\n        // viewport -> SetAnimator(* animator);\n        // animator -> ChangeOfRotation(Matrix3d:: FromColumnVectors(oldRotation[0], oldRotation[1], oldRotation[2]));\n    }\n    /** @internal */\n    enableForSession() {\n        if (CurrentState.NotEnabled === this.currentState)\n            this.currentState = CurrentState.Inactive;\n    }\n    /** @internal */\n    disableForSession() {\n        this.currentState = CurrentState.NotEnabled;\n        this.flags.redrawCompass = true; // Make sure decorators are called so we don't draw (i.e. erase AccuDraw compass)\n    }\n    /** @internal */\n    setLastPoint(pt) {\n        const viewport = this.currentView;\n        if (!viewport)\n            return;\n        const ev = new BeButtonEvent({ point: pt, rawPoint: pt, viewPoint: viewport.worldToView(pt), viewport });\n        IModelApp.toolAdmin.setAdjustedDataPoint(ev);\n    }\n    /** Emulate a mouse click at the specified location in the supplied view by sending button down/up events. */\n    async sendDataPoint(pt, viewport) {\n        const ev = new BeButtonEvent({ point: pt, rawPoint: pt, viewPoint: viewport.worldToView(pt), viewport, inputSource: InputSource.Mouse, isDown: true });\n        // Send both down and up events...\n        await IModelApp.toolAdmin.sendButtonEvent(ev);\n        ev.isDown = false;\n        return IModelApp.toolAdmin.sendButtonEvent(ev);\n    }\n    /** @internal */\n    clearTentative() {\n        if (!IModelApp.tentativePoint.isActive)\n            return false;\n        const wasSnapped = IModelApp.tentativePoint.isSnapped;\n        IModelApp.tentativePoint.clear(true);\n        return wasSnapped;\n    }\n    /** @internal */\n    async doAutoPoint(index, mode) {\n        const vp = this.currentView;\n        if (!vp)\n            return;\n        if (CompassMode.Polar === mode) {\n            if (!this.autoPointPlacement)\n                return;\n            if (this._fieldLocked[ItemField.DIST_Item] && (this._fieldLocked[ItemField.ANGLE_Item] || this.indexed & LockedStates.ANGLE_BM) && KeyinStatus.Dynamic === this._keyinStatus[index]) {\n                this.fixPointPolar(vp);\n                return this.sendDataPoint(this.point, vp);\n            }\n            return;\n        }\n        if (this._fieldLocked[ItemField.X_Item] && this._fieldLocked[ItemField.Y_Item]) {\n            if (!this.isActive) {\n                if (!vp.view.is3d() || this._fieldLocked[ItemField.Z_Item]) {\n                    const globalOrigin = new Point3d();\n                    if (vp.view.isSpatialView())\n                        globalOrigin.setFrom(vp.view.iModel.globalOrigin);\n                    return this.sendDataPoint(globalOrigin.plus(this.delta), vp);\n                }\n                return;\n            }\n            if (!this.autoPointPlacement || KeyinStatus.Dynamic !== this._keyinStatus[index])\n                return;\n            this.origin.plus3Scaled(this.axes.x, this.delta.x, this.axes.y, this.delta.y, this.axes.z, this.delta.z, this.point);\n            return this.sendDataPoint(this.point, vp);\n        }\n        if (!this.autoPointPlacement || KeyinStatus.Dynamic !== this._keyinStatus[index])\n            return;\n        if ((ItemField.X_Item === index && this._fieldLocked[ItemField.X_Item] && (this.indexed & LockedStates.Y_BM)) || (ItemField.Y_Item === index && this._fieldLocked[ItemField.Y_Item] && (this.indexed & LockedStates.X_BM))) {\n            this.origin.plus3Scaled(this.axes.x, this.delta.x, this.axes.y, this.delta.y, this.axes.z, this.delta.z, this.point);\n            return this.sendDataPoint(this.point, vp);\n        }\n    }\n    /** Get the current value for the supplied input field */\n    getValueByIndex(index) {\n        switch (index) {\n            case ItemField.X_Item: return this.delta.x;\n            case ItemField.Y_Item: return this.delta.y;\n            case ItemField.Z_Item: return this.delta.z;\n            case ItemField.DIST_Item: return this._distance;\n            case ItemField.ANGLE_Item: return this._angle;\n            default:\n                return 0.0;\n        }\n    }\n    /** Set the current value for the supplied input field */\n    setValueByIndex(index, value) {\n        switch (index) {\n            case ItemField.X_Item:\n                this.delta.x = value;\n                break;\n            case ItemField.Y_Item:\n                this.delta.y = value;\n                break;\n            case ItemField.Z_Item:\n                this.delta.z = value;\n                break;\n            case ItemField.DIST_Item:\n                this._distance = value;\n                break;\n            case ItemField.ANGLE_Item:\n                this._angle = value;\n                break;\n        }\n    }\n    updateVector(angle) {\n        this.vector.set(Math.cos(angle), Math.sin(angle), 0.0);\n        const rMatrix = this.getRotation();\n        rMatrix.multiplyTransposeVector(this.vector);\n    }\n    stringToDistance(str) {\n        const parserSpec = IModelApp.quantityFormatter.findParserSpecByQuantityType(QuantityType.Length);\n        if (parserSpec)\n            return parserSpec.parseToQuantityValue(str);\n        return { ok: false, error: ParseError.InvalidParserSpec };\n    }\n    stringToAngle(inString) {\n        // Need to update once there is an official \"Bearing\" QuantityType. Once available then\n        // use QuantityType.Angle for isBearing=false and \"Bearing\" for isBearing=true.\n        const parserSpec = IModelApp.quantityFormatter.findParserSpecByQuantityType(QuantityType.Angle);\n        if (parserSpec)\n            return parserSpec.parseToQuantityValue(inString);\n        return { ok: false, error: ParseError.InvalidParserSpec };\n    }\n    updateFieldValue(index, input, _out) {\n        if (input.length === 0)\n            return BentleyStatus.ERROR;\n        if (input.length === 1)\n            switch (input) {\n                case \":\":\n                case \"-\":\n                case \"+\":\n                case \".\":\n                    return BentleyStatus.ERROR;\n            }\n        let parseResult;\n        switch (index) {\n            case ItemField.DIST_Item:\n                parseResult = this.stringToDistance(input);\n                if (Parser.isParsedQuantity(parseResult)) {\n                    this._distance = parseResult.value;\n                    break;\n                }\n                return BentleyStatus.ERROR;\n            case ItemField.ANGLE_Item:\n                parseResult = this.stringToAngle(input);\n                if (Parser.isParsedQuantity(parseResult)) {\n                    this._angle = parseResult.value;\n                    break;\n                }\n                return BentleyStatus.ERROR;\n            case ItemField.X_Item:\n                parseResult = this.stringToDistance(input);\n                if (Parser.isParsedQuantity(parseResult)) {\n                    this.delta.x = parseResult.value;\n                    this._xIsExplicit = (input[0] === \"+\" || input[0] === \"-\");\n                    if (!this._xIsExplicit) {\n                        if (this.smartKeyin && this.isActive && this._xIsNegative === (this.delta.x >= 0.0))\n                            this.delta.x = -this.delta.x;\n                    }\n                    break;\n                }\n                return BentleyStatus.ERROR;\n            case ItemField.Y_Item:\n                parseResult = this.stringToDistance(input);\n                if (Parser.isParsedQuantity(parseResult)) {\n                    this.delta.y = parseResult.value;\n                    this._yIsExplicit = (input[0] === \"+\" || input[0] === \"-\");\n                    if (!this._yIsExplicit) {\n                        if (this.smartKeyin && this.isActive && this._yIsNegative === (this.delta.y >= 0.0))\n                            this.delta.y = -this.delta.y;\n                    }\n                    break;\n                }\n                return BentleyStatus.ERROR;\n            case ItemField.Z_Item:\n                parseResult = this.stringToDistance(input);\n                if (Parser.isParsedQuantity(parseResult)) {\n                    this.delta.z = parseResult.value;\n                    break;\n                }\n                return BentleyStatus.ERROR;\n        }\n        return BentleyStatus.SUCCESS;\n    }\n    /** @internal */\n    unlockAllFields() {\n        this.locked = 0;\n        if (CompassMode.Polar === this.compassMode) {\n            if (this._fieldLocked[ItemField.DIST_Item])\n                this.setFieldLock(ItemField.DIST_Item, false);\n            if (this._fieldLocked[ItemField.ANGLE_Item])\n                this.setFieldLock(ItemField.ANGLE_Item, false);\n        }\n        else {\n            if (this._fieldLocked[ItemField.X_Item])\n                this.setFieldLock(ItemField.X_Item, false);\n            if (this._fieldLocked[ItemField.Y_Item])\n                this.setFieldLock(ItemField.Y_Item, false);\n        }\n        if (this._fieldLocked[ItemField.Z_Item]) {\n            if (this.stickyZLock)\n                this.delta.z = 0.0;\n            else\n                this.setFieldLock(ItemField.Z_Item, false);\n        }\n        this.setKeyinStatus(ItemField.DIST_Item, KeyinStatus.Dynamic);\n        this.setKeyinStatus(ItemField.ANGLE_Item, KeyinStatus.Dynamic);\n        this.setKeyinStatus(ItemField.X_Item, KeyinStatus.Dynamic);\n        this.setKeyinStatus(ItemField.Y_Item, KeyinStatus.Dynamic);\n        this.setKeyinStatus(ItemField.Z_Item, KeyinStatus.Dynamic);\n        if (!this.smartKeyin)\n            this.setFocusItem(CompassMode.Polar === this.compassMode ? ItemField.DIST_Item : ItemField.X_Item);\n        this.dontMoveFocus = false;\n    }\n    /** produces the normal vector of the closest plane to the view which\n     * contains inVec (uses true view rotation, never auxiliary)\n     */\n    planeByVectorAndView(normalVec, inVec, vp) {\n        if (!vp.view.is3d()) {\n            normalVec.setFrom(Vector3d.unitZ());\n            return true;\n        }\n        const viewNormal = vp.rotation.getRow(2);\n        const yVec = viewNormal.crossProduct(inVec);\n        if (!yVec.normalizeInPlace()) {\n            normalVec.setFrom(viewNormal);\n            return false;\n        }\n        inVec.crossProduct(yVec, normalVec);\n        return true;\n    }\n    handleDegeneratePolarCase() {\n        if (!(this.locked & LockedStates.DIST_BM))\n            this._distance = 0.0;\n        if (this.locked & LockedStates.VEC_BM) {\n            this._angle = Math.acos(this.vector.dotProduct(this.axes.x));\n        }\n        else if (this.locked & LockedStates.Y_BM) {\n            this.vector.setFrom(this.axes.y);\n            this._angle = Math.PI / 2.0;\n            this.indexed = this.locked;\n        }\n        else if (this.locked & LockedStates.X_BM) {\n            this.vector.setFrom(this.axes.x);\n            this._angle = 0.0;\n            this.indexed = this.locked;\n        }\n        else {\n            // use last good vector\n            this._angle = Math.acos(this.vector.dotProduct(this.axes.x));\n        }\n        this.origin.plusScaled(this.vector, this._distance, this.point);\n    }\n    rawDeltaIsValid(rawDelta) {\n        /* Cursor Distance (*(+/-)) sense testing is not valid when raw delta is\n           meaningless (0.0)...to make this change safer only reject the\n           raw delta if unit or grid lock is also on. */\n        if (0.0 !== rawDelta)\n            return true;\n        // The \"I don't want grid lock\" flag can be set by tools to override the default behavior...\n        if (0 === (IModelApp.toolAdmin.toolState.coordLockOvr & CoordinateLockOverrides.Grid))\n            return true;\n        return (!IModelApp.toolAdmin.gridLock);\n    }\n    /** Call from an AccuDraw UI event to sync the supplied input field value */\n    async processFieldInput(index, input, synchText) {\n        const isBearing = false;\n        if (BentleyStatus.SUCCESS !== this.updateFieldValue(index, input, { isBearing })) {\n            const saveKeyinStatus = this._keyinStatus[index]; // Don't want this to change when entering '.', etc.\n            this.updateFieldLock(index, false);\n            this._keyinStatus[index] = saveKeyinStatus;\n            return;\n        }\n        switch (index) {\n            case ItemField.DIST_Item:\n                this.distanceLock(synchText, true);\n                await this.doAutoPoint(index, CompassMode.Polar);\n                break;\n            case ItemField.ANGLE_Item:\n                this.setFieldLock(index, true);\n                if (synchText) {\n                    this.onFieldValueChange(index);\n                    this.setKeyinStatus(index, KeyinStatus.Dynamic);\n                }\n                if (!isBearing || !this.flags.bearingFixToPlane2D)\n                    this.updateVector(this._angle);\n                else\n                    this.vector.set(Math.cos(this._angle), Math.sin(this._angle), 0.0);\n                this.locked |= LockedStates.VEC_BM;\n                await this.doAutoPoint(index, CompassMode.Polar);\n                break;\n            case ItemField.X_Item:\n            case ItemField.Y_Item:\n                this.locked |= (ItemField.X_Item === index) ? LockedStates.X_BM : LockedStates.Y_BM;\n            // falls through\n            case ItemField.Z_Item:\n                this.setFieldLock(index, true);\n                if (synchText) {\n                    this.onFieldValueChange(index);\n                    this.setKeyinStatus(index, KeyinStatus.Dynamic);\n                }\n                await this.doAutoPoint(index, this.compassMode);\n                break;\n        }\n        this.refreshDecorationsAndDynamics();\n    }\n    /** @internal */\n    updateFieldLock(index, locked) {\n        if (locked) {\n            if (!this._fieldLocked[index]) {\n                this.setFieldLock(index, true);\n                switch (index) {\n                    case ItemField.DIST_Item:\n                        this.distanceLock(true, false);\n                        break;\n                    case ItemField.ANGLE_Item:\n                        this.angleLock();\n                        break;\n                    case ItemField.X_Item:\n                        this.locked |= LockedStates.X_BM;\n                        break;\n                    case ItemField.Y_Item:\n                        this.locked |= LockedStates.Y_BM;\n                        break;\n                    case ItemField.Z_Item:\n                        break;\n                }\n            }\n            return;\n        }\n        switch (index) {\n            case ItemField.DIST_Item:\n                this.locked &= ~LockedStates.DIST_BM;\n                break;\n            case ItemField.ANGLE_Item:\n                this.locked &= ~LockedStates.VEC_BM;\n                break;\n            case ItemField.X_Item:\n                this.locked &= ~LockedStates.X_BM;\n                break;\n            case ItemField.Y_Item:\n                this.locked &= ~LockedStates.Y_BM;\n                break;\n        }\n        if (index !== ItemField.Z_Item || !this.stickyZLock)\n            this.setFieldLock(index, false);\n        this.setKeyinStatus(index, KeyinStatus.Dynamic);\n    }\n    /** @internal */\n    static getSnapRotation(snap, currentVp, out) {\n        const vp = (undefined !== currentVp) ? currentVp : snap.viewport;\n        const rotation = out ? out : new Matrix3d();\n        const viewZ = vp.rotation.rowZ();\n        const snapLoc = (undefined !== snap.primitive ? snap.primitive.closestPoint(snap.snapPoint, false) : undefined);\n        if (undefined !== snapLoc) {\n            const frame = snap.primitive.fractionToFrenetFrame(snapLoc.fraction);\n            const frameZ = (undefined !== frame ? frame.matrix.columnZ() : Vector3d.unitZ());\n            let xVec = (undefined !== frame ? frame.matrix.columnX() : Vector3d.unitX());\n            const zVec = (vp.view.allow3dManipulations() ? (undefined !== snap.normal ? snap.normal.clone() : frameZ.clone()) : Vector3d.unitZ());\n            if (!vp.isCameraOn && viewZ.isPerpendicularTo(zVec))\n                zVec.setFrom(viewZ);\n            xVec.normalizeInPlace();\n            zVec.normalizeInPlace();\n            let yVec = xVec.unitCrossProduct(zVec);\n            if (undefined !== yVec) {\n                const viewX = vp.rotation.rowX();\n                if (snap.primitive instanceof LineString3d) {\n                    if (Math.abs(xVec.dotProduct(viewX)) < Math.abs(yVec.dotProduct(viewX)))\n                        xVec = yVec;\n                    if (xVec.dotProduct(viewX) < 0.0)\n                        xVec.negate(xVec);\n                }\n                else {\n                    const ray = snap.primitive.fractionToPointAndUnitTangent(0.0);\n                    if (ray.direction.dotProduct(viewX) < 0.0 && ray.direction.dotProduct(xVec) > 0.0)\n                        xVec.negate(xVec);\n                }\n                if (zVec.dotProduct(viewZ) < 0.0)\n                    zVec.negate(zVec);\n                yVec = xVec.unitCrossProduct(zVec);\n                if (undefined !== yVec) {\n                    rotation.setColumns(xVec, yVec, zVec);\n                    Matrix3d.createRigidFromMatrix3d(rotation, AxisOrder.XZY, rotation);\n                    rotation.transposeInPlace();\n                    return rotation;\n                }\n            }\n        }\n        if (undefined !== snap.normal) {\n            const zVec = (vp.view.allow3dManipulations() ? snap.normal.clone() : Vector3d.unitZ());\n            if (!vp.isCameraOn && viewZ.isPerpendicularTo(zVec))\n                zVec.setFrom(viewZ);\n            zVec.normalizeInPlace();\n            Matrix3d.createRigidHeadsUp(zVec, undefined, rotation);\n            rotation.transposeInPlace();\n            return rotation;\n        }\n        return undefined;\n    }\n    /** @internal */\n    static getStandardRotation(nStandard, vp, useACS, out) {\n        const rMatrix = out ? out : new Matrix3d();\n        rMatrix.setFrom(ViewState.getStandardViewMatrix(nStandard));\n        const useVp = vp ? vp : IModelApp.viewManager.selectedView;\n        if (!useACS) {\n            const globeToWorld = vp?.view.getGlobeRotation();\n            if (globeToWorld)\n                rMatrix.multiplyMatrixMatrix(globeToWorld, rMatrix);\n        }\n        if (!useACS || !useVp)\n            return rMatrix;\n        rMatrix.multiplyMatrixMatrix(useVp.getAuxCoordRotation(AccuDraw._tempRot), rMatrix);\n        return rMatrix;\n    }\n    /** @internal */\n    static getCurrentOrientation(vp, checkAccuDraw, checkACS, rMatrix) {\n        if (checkAccuDraw && IModelApp.accuDraw.isActive)\n            return IModelApp.accuDraw.getRotation(rMatrix);\n        const useVp = vp ? vp : IModelApp.viewManager.selectedView;\n        if (!useVp)\n            return Matrix3d.createIdentity(rMatrix);\n        if (checkACS && useVp.isContextRotationRequired)\n            return useVp.getAuxCoordRotation(rMatrix);\n        return useVp.rotation;\n    }\n    /** @internal */\n    static updateAuxCoordinateSystem(acs, vp, allViews = true) {\n        // When modeling with multiple spatial views open, you'd typically want the same ACS in all views...\n        if (allViews && vp.view.isSpatialView()) {\n            for (const otherVp of IModelApp.viewManager) {\n                if (otherVp !== vp && otherVp.view.isSpatialView())\n                    otherVp.view.setAuxiliaryCoordinateSystem(acs);\n            }\n        }\n        vp.view.setAuxiliaryCoordinateSystem(acs);\n        // NOTE: Change AccuDraw's base rotation to ACS.\n        IModelApp.accuDraw.setContext(AccuDrawFlags.OrientACS);\n    }\n    /** @internal */\n    distanceLock(synchText, saveInHistory) {\n        this.locked |= LockedStates.DIST_BM;\n        if (!this._fieldLocked[ItemField.DIST_Item])\n            this.setFieldLock(ItemField.DIST_Item, true);\n        if (saveInHistory)\n            this.saveCoordinate(ItemField.DIST_Item, this._distance);\n        if (synchText) {\n            this.onFieldValueChange(ItemField.DIST_Item);\n            this.setKeyinStatus(ItemField.DIST_Item, KeyinStatus.Dynamic);\n        }\n    }\n    /** @internal */\n    angleLock() {\n        if (this.indexed & LockedStates.Y_BM)\n            this.locked |= LockedStates.Y_BM;\n        else if (this.indexed & LockedStates.X_BM)\n            this.locked |= LockedStates.X_BM;\n        else\n            this.locked |= LockedStates.VEC_BM;\n        this.clearTentative();\n        if (!this._fieldLocked[ItemField.ANGLE_Item]) {\n            this.setFieldLock(ItemField.ANGLE_Item, true);\n            this.setKeyinStatus(ItemField.ANGLE_Item, KeyinStatus.Dynamic);\n        }\n        this.flags.lockedRotation = true;\n        this.flags.softAngleLock = false;\n    }\n    /** @internal */\n    doLockAngle(isSnapped) {\n        if (CompassMode.Polar !== this.compassMode) {\n            this.locked = LockedStates.NONE_LOCKED;\n            this._rawPoint.setFrom(this.point);\n            const vp = this.currentView;\n            if (vp)\n                this.fixPointPolar(vp);\n            this.changeCompassMode(true);\n        }\n        this.setFieldLock(ItemField.ANGLE_Item, !this._fieldLocked[ItemField.ANGLE_Item]);\n        if (this._fieldLocked[ItemField.ANGLE_Item]) {\n            // Move focus to angle field...\n            if (!isSnapped && this.autoFocusFields)\n                this.setFocusItem(ItemField.ANGLE_Item);\n            this.angleLock();\n            if (!isSnapped)\n                this.flags.softAngleLock = true;\n        }\n        else {\n            this.locked &= ~LockedStates.ANGLE_BM;\n            this.saveCoordinate(ItemField.ANGLE_Item, this._angle);\n        }\n    }\n    /** @internal */\n    saveCoordinate(index, value) {\n        const isAngle = (ItemField.ANGLE_Item === index);\n        let currIndex = this._savedCoords.nSaveValues + 1;\n        if (currIndex >= 20 /* Constants.MAX_SAVED_VALUES */)\n            currIndex = 0;\n        if (this._savedCoords.savedValues[this._savedCoords.nSaveValues] === value && this._savedCoords.savedValIsAngle[this._savedCoords.nSaveValues] === isAngle)\n            return;\n        if (isAngle) {\n            // don't accept 0, 90, -90, and 180 degrees\n            if (value === 0.0 || value === Math.PI || value === (Math.PI / 2.0) || value === -Math.PI)\n                return;\n        }\n        else {\n            // don't accept zero\n            value = Math.abs(value);\n            if (value < 1e-12 /* Constants.SMALL_ANGLE */)\n                return;\n        }\n        this._savedCoords.savedValues[currIndex] = value;\n        this._savedCoords.savedValIsAngle[currIndex] = isAngle;\n        this._savedCoords.nSaveValues = currIndex;\n        if (!isAngle)\n            this._lastDistance = value;\n    }\n    /** @internal */\n    changeCompassMode(animate = false) {\n        this.setCompassMode(CompassMode.Polar === this.compassMode ? CompassMode.Rectangular : CompassMode.Polar);\n        const viewport = this.currentView;\n        if (!animate || !viewport)\n            return;\n        // AccuDrawAnimatorPtr animator = AccuDrawAnimator:: Create();\n        // viewport.setAnimator(* animator);\n        // animator -> ChangeOfMode();\n    }\n    /** @internal */\n    changeBaseRotationMode(mode) {\n        if (mode > RotationMode.Context)\n            return;\n        if (RotationMode.Context === mode) {\n            // See if it is better to stay with the current base rotation (only care about z)...\n            if (RotationMode.Context !== this.flags.baseRotation) {\n                const baseRMatrix = this.getBaseRotation();\n                const baseZ = baseRMatrix.getRow(2);\n                if (baseZ.isParallelTo(this.axes.z, true))\n                    return;\n            }\n            this.baseAxes.setFrom(this.axes);\n            this.flags.auxRotationPlane = RotationMode.Top;\n        }\n        this.flags.baseRotation = mode;\n    }\n    getBaseRotation() {\n        const vp = this.currentView;\n        let baseRMatrix;\n        const useAcs = vp ? vp.isContextRotationRequired : false;\n        switch (this.flags.baseRotation) {\n            case RotationMode.Top: {\n                baseRMatrix = AccuDraw.getStandardRotation(StandardViewId.Top, vp, useAcs);\n                break;\n            }\n            case RotationMode.Front: {\n                baseRMatrix = AccuDraw.getStandardRotation(StandardViewId.Front, vp, useAcs);\n                break;\n            }\n            case RotationMode.Side: {\n                baseRMatrix = AccuDraw.getStandardRotation(StandardViewId.Right, vp, useAcs);\n                break;\n            }\n            case RotationMode.ACS: {\n                baseRMatrix = vp ? vp.getAuxCoordRotation() : Matrix3d.createIdentity();\n                const axes = ThreeAxes.createFromMatrix3d(baseRMatrix);\n                this.accountForAuxRotationPlane(axes, this.flags.auxRotationPlane);\n                axes.toMatrix3d(baseRMatrix);\n                break;\n            }\n            case RotationMode.View: {\n                baseRMatrix = vp ? vp.rotation : Matrix3d.createIdentity();\n                break;\n            }\n            case RotationMode.Context: {\n                const axes = new ThreeAxes();\n                axes.setFrom(this.baseAxes);\n                this.accountForAuxRotationPlane(axes, this.flags.auxRotationPlane);\n                baseRMatrix = axes.toMatrix3d();\n                break;\n            }\n            default: {\n                baseRMatrix = Matrix3d.createIdentity();\n                break;\n            }\n        }\n        return baseRMatrix;\n    }\n    /** @internal */\n    setContextRotation(rMatrix, locked, animate) {\n        this.flags.lockedRotation = locked;\n        this.flags.contextRotMode = locked ? ContextMode.Locked : ContextMode.None;\n        this.setRotationMode(RotationMode.Context);\n        this.updateRotation(animate, rMatrix);\n    }\n    clearContext() {\n        this.published.flags = 0;\n        this.flags.rotationNeedsUpdate = true;\n        this.flags.fixedOrg = false;\n        this.newFocus = ItemField.X_Item;\n        this.unlockAllFields();\n        if (this.rotationMode !== this.flags.baseRotation)\n            this.setRotationMode(this.flags.baseRotation);\n        if (this.compassMode !== this.flags.baseMode)\n            this.setCompassMode(this.flags.baseMode);\n    }\n    /** @internal */\n    setContext(flags, originP, orientationP, deltaP, distanceP, angleP, transP) {\n        this.published.flags |= flags;\n        if (flags & AccuDrawFlags.SetOrigin && originP) {\n            this.published.origin.setFrom(originP);\n            if (transP)\n                transP.multiplyPoint3d(this.published.origin, this.published.origin);\n        }\n        if (deltaP) {\n            this.published.delta.setFrom(deltaP);\n            if (transP)\n                this.published.delta.scaleInPlace(transP.matrix.columnX().magnitude());\n        }\n        if (typeof distanceP === \"number\") {\n            this.published.distance = distanceP;\n            if (transP)\n                this.published.distance *= transP.matrix.columnX().magnitude();\n        }\n        if (typeof angleP === \"number\")\n            this.published.angle = angleP;\n        if (orientationP) {\n            if (flags & AccuDrawFlags.SetXAxis || flags & AccuDrawFlags.SetNormal || flags & AccuDrawFlags.SetXAxis2) {\n                this.published.vector.setFrom(orientationP);\n                if (transP)\n                    transP.matrix.multiplyVectorInPlace(this.published.vector);\n                this.published.vector.normalizeInPlace();\n            }\n            else if (flags & AccuDrawFlags.SetRMatrix) {\n                this.published.rMatrix.setFrom(orientationP);\n                if (transP) {\n                    this.published.rMatrix.multiplyMatrixMatrix(transP.matrix, this.published.rMatrix);\n                    this.published.rMatrix.normalizeColumnsInPlace();\n                }\n            }\n        }\n        if (flags) {\n            this.onEventCommon();\n            if (!this.flags.haveValidOrigin)\n                this.setDefaultOrigin(this.currentView);\n        }\n        return this.isEnabled ? BentleyStatus.SUCCESS : BentleyStatus.ERROR;\n    }\n    onEventCommon() {\n        if (this.published.flags & AccuDrawFlags.RedrawCompass) {\n            this.flags.indexLocked = true;\n            this.flags.redrawCompass = true;\n        }\n        if (this.published.flags & AccuDrawFlags.UpdateRotation) {\n            this.flags.indexLocked = true;\n            this.flags.contextRotMode = ContextMode.XAxis;\n            this.setRotationMode(RotationMode.Context);\n            this.updateRotation();\n            this.flags.indexLocked = true;\n        }\n    }\n    /** @internal */\n    onPrimitiveToolInstall() {\n        if (!this.isEnabled)\n            return false;\n        this.onEventCommon();\n        this.saveLockedCoords();\n        // Setup default starting tool state...\n        this.currentState = CurrentState.Inactive;\n        this.clearContext();\n        if (this.alwaysShowCompass)\n            this.activate();\n        return false;\n    }\n    /** @internal */\n    onViewToolInstall() {\n        if (!this.isEnabled)\n            return false;\n        this.onEventCommon();\n        const tool = IModelApp.toolAdmin.activeTool;\n        if (tool && !(tool instanceof ViewTool))\n            this.saveState(this.savedStateViewTool); // Save AccuDraw state of tool being suspended...\n        this.currentState = CurrentState.Deactivated; // Default to disabled for view tools.\n        return false;\n    }\n    /** @internal */\n    onViewToolExit() {\n        if (!this.isEnabled)\n            return false;\n        this.onEventCommon();\n        this.restoreState(this.savedStateViewTool); // Restore AccuDraw state of suspended tool...\n        return false;\n    }\n    /** @internal */\n    onInputCollectorInstall() {\n        if (!this.isEnabled)\n            return false;\n        this.onEventCommon();\n        const tool = IModelApp.toolAdmin.activeTool;\n        if (tool && !(tool instanceof InputCollector))\n            this.saveState(this.savedStateInputCollector); // Save AccuDraw state of tool being suspended...\n        this.currentState = CurrentState.Inactive; // Default to inactive for input collectors.\n        return false;\n    }\n    /** @internal */\n    onInputCollectorExit() {\n        if (!this.isEnabled)\n            return false;\n        this.onEventCommon();\n        this.restoreState(this.savedStateInputCollector); // Restore AccuDraw state of suspended tool...\n        return false;\n    }\n    /** @internal */\n    saveState(stateBuffer) {\n        stateBuffer.state = this.currentState;\n        stateBuffer.mode = this.compassMode;\n        stateBuffer.rotationMode = this.rotationMode;\n        stateBuffer.axes.setFrom(this.axes);\n        stateBuffer.origin.setFrom(this.origin);\n        stateBuffer.auxRotationPlane = this.flags.auxRotationPlane;\n        stateBuffer.contextRotMode = this.flags.contextRotMode;\n        stateBuffer.fixedOrg = this.flags.fixedOrg;\n        stateBuffer.ignoreDataButton = true;\n        stateBuffer.ignoreFlags = 0;\n    }\n    /** @internal */\n    restoreState(stateBuffer) {\n        if (0 === (stateBuffer.ignoreFlags & AccuDrawFlags.Disable)) {\n            this.currentState = stateBuffer.state;\n        }\n        if (0 === (stateBuffer.ignoreFlags & AccuDrawFlags.SetOrigin)) {\n            this.origin.setFrom(stateBuffer.origin);\n            this.planePt.setFrom(stateBuffer.origin);\n        }\n        if (0 === (stateBuffer.ignoreFlags & AccuDrawFlags.SetRMatrix)) {\n            this.axes.setFrom(stateBuffer.axes);\n            this.setRotationMode(stateBuffer.rotationMode);\n            this.flags.auxRotationPlane = stateBuffer.auxRotationPlane;\n            this.flags.contextRotMode = stateBuffer.contextRotMode;\n        }\n        this.flags.fixedOrg = stateBuffer.fixedOrg;\n        this.setCompassMode(stateBuffer.mode);\n        this.updateRotation();\n        if (stateBuffer.ignoreDataButton)\n            this.flags.ignoreDataButton = (this.flags.inDataPoint ? true : false);\n    }\n    getCompassPlanePoint(point, vp) {\n        point.setFrom(this.origin); // Isn't this just planePt?!? Maybe at display time it is not setup yet?!?\n        if (this._fieldLocked[ItemField.Z_Item] && vp.view.is3d()) {\n            if (0.0 !== this.delta.z && !(this.delta.z < 1e-12 /* Constants.SMALL_ANGLE */ && this.delta.z > -1e-12 /* Constants.SMALL_ANGLE */)) {\n                point.addScaledInPlace(this.axes.z, this.delta.z);\n                return true;\n            }\n        }\n        return false;\n    }\n    getDisplayTransform(vp) {\n        const rMatrix = (!this.flags.animateRotation || 0.0 === this._percentChanged) ? this.axes.toMatrix3d() : this.lastAxes.toMatrix3d();\n        const origin = new Point3d(); // Compass origin is adjusted by active z-lock...\n        this.getCompassPlanePoint(origin, vp);\n        const scale = vp.pixelsFromInches(this._compassSizeInches) * vp.getPixelSizeAtPoint(origin);\n        rMatrix.transposeInPlace();\n        rMatrix.scaleColumns(scale, scale, scale, rMatrix);\n        return Transform.createRefs(origin, rMatrix);\n    }\n    setIndexingTolerance(vp) {\n        const origin = new Point3d(); // Compass origin is adjusted by active z-lock...\n        this.getCompassPlanePoint(origin, vp);\n        this._tolerance = vp.pixelsFromInches(this._indexToleranceInches) * vp.getPixelSizeAtPoint(origin);\n        if (1e-12 /* Constants.SMALL_ANGLE */ > this._tolerance)\n            this._tolerance = 1e-12 /* Constants.SMALL_ANGLE */;\n    }\n    displayAlignments(graphic, vp) {\n        const bgColor = vp.view.backgroundColor;\n        const colorIndex = this._indexColor.adjustedForContrast(bgColor, 130);\n        const origin = new Point3d(); // Compass origin is adjusted by active z-lock...\n        // For non-zero Z value draw indicator line from plane point to compass origin...\n        if (this.getCompassPlanePoint(origin, vp)) {\n            const colorZ = this._frameColor.adjustedForContrast(bgColor, 155);\n            graphic.setSymbology(colorZ, colorZ, 2);\n            graphic.addLineString([origin, this.origin]);\n            graphic.setSymbology(colorZ, colorZ, 4);\n            graphic.addPointString([this.origin]);\n        }\n        // Get snap point from AccuSnap/Tentative or use raw point...\n        let distance = 0.0;\n        let snapPt = this._rawPoint;\n        const snap = TentativeOrAccuSnap.getCurrentSnap();\n        if (snap) {\n            snapPt = snap.snapPoint;\n            distance = this.point.distance(snapPt);\n        }\n        const isRectMode = (CompassMode.Rectangular === this.compassMode);\n        const offsetSnap = ((TentativeOrAccuSnap.isHot || IModelApp.tentativePoint.isActive) && ((this.locked) || (distance > 0.0)));\n        // XY Offset:\n        if (offsetSnap) {\n            if (isRectMode) {\n                const vec = this.point.vectorTo(this._rawPointOnPlane);\n                const xOffset = vec.dotProduct(this.axes.x);\n                const yOffset = vec.dotProduct(this.axes.y);\n                const xIsOffset = (Math.abs(xOffset) > 1.0);\n                const yIsOffset = (Math.abs(yOffset) > 1.0);\n                if (xIsOffset) {\n                    if (yIsOffset) { /* both */\n                        const pts = [\n                            this.point,\n                            this.point.plusScaled(this.axes.y, yOffset),\n                            this._rawPointOnPlane,\n                            this.point.plusScaled(this.axes.x, xOffset)\n                        ];\n                        pts[4] = pts[0];\n                        graphic.setSymbology(colorIndex, colorIndex, 2, LinePixels.Code5);\n                        graphic.addLineString(pts);\n                    }\n                    else { /* just X */\n                        graphic.setSymbology(colorIndex, colorIndex, 2, LinePixels.Code5);\n                        graphic.addLineString([this.point, this._rawPointOnPlane]);\n                    }\n                }\n                else if (yIsOffset) { /* just Y */\n                    graphic.setSymbology(colorIndex, colorIndex, 2, LinePixels.Code5);\n                    graphic.addLineString([this.point, this._rawPointOnPlane]);\n                }\n            }\n        }\n        const isOnCompassPlane = (!vp.view.is3d() || this.flags.pointIsOnPlane || this.isZLocked(vp));\n        // Z Offset:\n        if (offsetSnap) {\n            if (isOnCompassPlane) {\n                if (isRectMode) {\n                    const zOffset = snapPt.distance(this._rawPointOnPlane);\n                    if (zOffset > 1e-12 /* Constants.SMALL_ANGLE */ || zOffset < -1e-12 /* Constants.SMALL_ANGLE */) {\n                        graphic.setSymbology(colorIndex, colorIndex, 2, LinePixels.Code5);\n                        graphic.addLineString([this._rawPointOnPlane, this._rawPoint]);\n                    }\n                }\n                else {\n                    graphic.setSymbology(colorIndex, colorIndex, 2, LinePixels.Code5);\n                    graphic.addLineString([this.point, this._rawPoint]);\n                }\n            }\n        }\n        // Fat Point:\n        if (offsetSnap) {\n            graphic.setSymbology(colorIndex, colorIndex, 8);\n            graphic.addPointString([this.point]);\n        }\n        let axisIsIndexed = false;\n        // Axis Indexing:\n        if (isRectMode) {\n            if ((this.indexed & LockedStates.XY_BM) && (this.flags.pointIsOnPlane || this._fieldLocked[ItemField.Z_Item]))\n                axisIsIndexed = true;\n        }\n        else {\n            if ((this.indexed & LockedStates.ANGLE_BM || this.locked & LockedStates.ANGLE_BM) && (this.flags.pointIsOnPlane || this._fieldLocked[ItemField.Z_Item]))\n                axisIsIndexed = true;\n        }\n        if (axisIsIndexed) {\n            graphic.setSymbology(colorIndex, colorIndex, 4);\n            graphic.addLineString([this.point, this.planePt]);\n        }\n        // Distance Indexing:\n        if (this.indexed & LockedStates.DIST_BM) {\n            const len = this._tolerance; // Show tick mark based on _GetIndexToleranceInches for length...\n            let vec;\n            if (isRectMode) {\n                let index = this.indexed & LockedStates.XY_BM;\n                if (!index)\n                    index = this.locked & LockedStates.XY_BM;\n                vec = (index === LockedStates.X_BM) ? this.axes.x : this.axes.y;\n            }\n            else {\n                const deltaVec = this.origin.vectorTo(this.point);\n                vec = this.axes.z.crossProduct(deltaVec);\n                vec.normalizeInPlace();\n            }\n            graphic.setSymbology(colorIndex, colorIndex, 3);\n            graphic.addLineString([this.point.plusScaled(vec, len), this.point.plusScaled(vec, -len)]);\n        }\n        // XY Lock:\n        if (isRectMode && !axisIsIndexed) {\n            const locked = this.locked & LockedStates.XY_BM;\n            if ((0 !== locked) && isOnCompassPlane) {\n                const pts = [this.point, this.point, this.point];\n                if (locked & LockedStates.X_BM)\n                    pts[2].setFrom(this.planePt.plusScaled(this.axes.x, this.delta.x));\n                if (locked & LockedStates.Y_BM)\n                    pts[0].setFrom(this.planePt.plusScaled(this.axes.y, this.delta.y));\n                switch (locked) {\n                    case LockedStates.X_BM:\n                        graphic.setSymbology(colorIndex, colorIndex, 2, LinePixels.Code5);\n                        graphic.addLineString([pts[1], pts[2]]);\n                        break;\n                    case LockedStates.Y_BM:\n                        graphic.setSymbology(colorIndex, colorIndex, 2, LinePixels.Code5);\n                        graphic.addLineString([pts[0], pts[1]]);\n                        break;\n                    case LockedStates.XY_BM:\n                        graphic.setSymbology(colorIndex, colorIndex, 2, LinePixels.Code5);\n                        graphic.addLineString(pts);\n                        break;\n                }\n            }\n        }\n    }\n    /** @internal */\n    testDecorationHit(id) { return id === this._acsPickId; }\n    /** @internal */\n    getDecorationGeometry(hit) {\n        if (!hit.viewport.viewFlags.acsTriad)\n            return undefined;\n        const geomData = GeomJson.Writer.toIModelJson(PointString3d.create(hit.viewport.view.auxiliaryCoordinateSystem.getOrigin()));\n        if (undefined === geomData)\n            return undefined;\n        const acsGeom = [geomData];\n        return acsGeom;\n    }\n    /** @internal */\n    decorate(context) {\n        if (context.viewport.viewFlags.acsTriad) {\n            context.viewport.view.auxiliaryCoordinateSystem.display(context, (ACSDisplayOptions.CheckVisible | ACSDisplayOptions.Active));\n            if (undefined === this._acsPickId)\n                this._acsPickId = context.viewport.iModel.transientIds.getNext();\n            const acsPickBuilder = context.createGraphicBuilder(GraphicType.WorldDecoration, undefined, this._acsPickId);\n            const color = ColorDef.blue.adjustedForContrast(context.viewport.view.backgroundColor, 50);\n            acsPickBuilder.setSymbology(color, color, 6);\n            acsPickBuilder.addPointString([context.viewport.view.auxiliaryCoordinateSystem.getOrigin()]);\n            context.addDecorationFromBuilder(acsPickBuilder);\n        }\n        // Make sure this is cleared even if we do nothing...redraw might have been to make compass go away...\n        this.flags.redrawCompass = false;\n        // Check that AccuDraw is enabled...\n        if (!this.isActive)\n            return;\n        const vp = context.viewport;\n        if (this.currentView !== vp) // Do nothing if AccuDraw is not enabled for this view...\n            return;\n        this.setIndexingTolerance(vp);\n        // Display indexing lines, distance locks, etc. without compass transform...\n        let builder = context.createGraphicBuilder(GraphicType.WorldOverlay);\n        this.displayAlignments(builder, vp);\n        context.addDecorationFromBuilder(builder);\n        // Create a new graphics with the compass transform and scale so that compass size is 1.0...\n        builder = context.createGraphicBuilder(GraphicType.WorldOverlay, this.getDisplayTransform(vp));\n        const hasFocus = this.hasInputFocus;\n        const bgColor = vp.view.backgroundColor;\n        const frameColor = (hasFocus ? this._frameColor : this._frameColorNoFocus).adjustedForContrast(bgColor, 155);\n        const fillColor = (hasFocus ? this._fillColor : this._fillColorNoFocus).adjustedForContrast(bgColor, 75);\n        const xColor = (hasFocus ? this._xColor : this._frameColorNoFocus).adjustedForContrast(bgColor, 155);\n        const yColor = (hasFocus ? this._yColor : this._frameColorNoFocus).adjustedForContrast(bgColor, 155);\n        const shadowColor = frameColor;\n        // Display compass frame...\n        builder.setSymbology(shadowColor, fillColor, 1);\n        const center = Point3d.createZero();\n        if (this.flags.animateRotation || 0.0 === this._percentChanged) {\n            if (CompassMode.Polar === this.compassMode) {\n                const ellipse = Arc3d.createXYEllipse(center, 1, 1);\n                builder.addArc(ellipse, true, true);\n                builder.addArc(ellipse, false, false);\n            }\n            else {\n                const pts = [\n                    new Point3d(-1.0, 1.0, 0.0),\n                    new Point3d(1.0, 1.0, 0.0),\n                    new Point3d(1.0, -1.0, 0.0),\n                    new Point3d(-1.0, -1.0, 0.0)\n                ];\n                pts[4] = pts[0].clone();\n                builder.addShape(pts);\n                builder.addLineString(pts);\n            }\n        }\n        else {\n            let nSides, radius;\n            const minSides = 7, maxSides = 24, factor = 1.0 / 5.0;\n            // if currently animating change to polar need to get larger radius...go between 1.0 && 1.0 * sqrt (2.0)\n            if (CompassMode.Polar === this.compassMode) {\n                nSides = minSides + Math.floor(maxSides * this._percentChanged);\n                radius = 1.0 + factor - (factor * this._percentChanged);\n            }\n            else {\n                nSides = (maxSides - Math.floor(maxSides * this._percentChanged)) + minSides;\n                radius = 1.0 + (factor * this._percentChanged);\n            }\n            let angle = 0.0;\n            const delta = (Math.PI * 2) / nSides;\n            const pts = [];\n            for (let iSide = 0; iSide < nSides; iSide++, angle += delta)\n                pts[iSide] = new Point3d(radius * Math.cos(angle), radius * Math.sin(angle), 0.0);\n            pts[nSides] = pts[0].clone();\n            builder.addShape(pts);\n            builder.addLineString(pts);\n        }\n        // Display sticky z-lock indicator as frame inset...\n        if (this._fieldLocked[ItemField.Z_Item] && this.stickyZLock && vp.view.is3d()) {\n            builder.setSymbology(frameColor, fillColor, 1);\n            if (CompassMode.Polar === this.compassMode) {\n                const ellipse = Arc3d.createXYEllipse(center, .5, .5);\n                builder.addArc(ellipse, false, false);\n            }\n            else {\n                const pts = [\n                    new Point3d(-0.5, 0.5, 0.0),\n                    new Point3d(0.5, 0.5, 0.0),\n                    new Point3d(0.5, -0.5, 0.0),\n                    new Point3d(-0.5, -0.5, 0.0)\n                ];\n                pts[4] = pts[0].clone();\n                builder.addLineString(pts);\n            }\n        }\n        // Display compass center mark...\n        builder.setSymbology(frameColor, frameColor, 8);\n        builder.addPointString([center]);\n        // Display positive \"X\" tick...\n        builder.setSymbology(xColor, xColor, 4);\n        builder.addLineString([new Point3d(1.2, 0.0, 0.0), new Point3d(0.8, 0.0, 0.0)]);\n        // Display negative \"X\" tick...\n        builder.setSymbology(frameColor, frameColor, 1);\n        builder.addLineString([new Point3d(-1.2, 0.0, 0.0), new Point3d(-0.8, 0.0, 0.0)]);\n        // Display positive \"Y\" tick...\n        builder.setSymbology(yColor, yColor, 4);\n        builder.addLineString([new Point3d(0.0, 1.2, 0.0), new Point3d(0.0, 0.8, 0.0)]);\n        // Display negative \"Y\" tick...\n        builder.setSymbology(frameColor, frameColor, 1);\n        builder.addLineString([new Point3d(0.0, -1.2, 0.0), new Point3d(0.0, -0.8, 0.0)]);\n        context.addDecorationFromBuilder(builder); // add compass as world overlay decorator\n    }\n    checkRotation() {\n        this.updateRotation();\n        if (RotationMode.View === this.rotationMode || !this.flags.lockedRotation)\n            return;\n        const vp = this.currentView;\n        if (!vp || vp.isCameraOn)\n            return;\n        const viewZRoot = vp.rotation.getRow(2);\n        if (!this.axes.z.isPerpendicularTo(viewZRoot))\n            return;\n        const preferY = (Math.abs(this.axes.x.dotProduct(viewZRoot)) < Math.abs(this.axes.y.dotProduct(viewZRoot)));\n        // NOTE: Cycle rotation to get one that isn't edge-on...\n        switch (this.rotationMode) {\n            case RotationMode.Top:\n                this.setRotationMode(preferY ? RotationMode.Front : RotationMode.Side);\n                break;\n            case RotationMode.Front:\n                this.setRotationMode(preferY ? RotationMode.Top : RotationMode.Side);\n                break;\n            case RotationMode.Side:\n                this.setRotationMode(preferY ? RotationMode.Top : RotationMode.Front);\n                break;\n            case RotationMode.ACS:\n                switch (this.flags.auxRotationPlane) {\n                    case RotationMode.Top:\n                        this.flags.auxRotationPlane = preferY ? RotationMode.Front : RotationMode.Side;\n                        break;\n                    case RotationMode.Front:\n                        this.flags.auxRotationPlane = preferY ? RotationMode.Top : RotationMode.Side;\n                        break;\n                    case RotationMode.Side:\n                        this.flags.auxRotationPlane = preferY ? RotationMode.Top : RotationMode.Front;\n                        break;\n                    default:\n                        return;\n                }\n                break;\n            default:\n                return;\n        }\n        this.updateRotation();\n        this.flags.baseRotation = this.rotationMode;\n    }\n    saveLockedCoords() {\n        if (CompassMode.Polar === this.compassMode) {\n            if (this._fieldLocked[ItemField.DIST_Item])\n                this.saveCoordinate(ItemField.DIST_Item, this._distance);\n            if (this._fieldLocked[ItemField.ANGLE_Item])\n                this.saveCoordinate(ItemField.ANGLE_Item, this._angle);\n        }\n        else {\n            if (this._fieldLocked[ItemField.X_Item])\n                this.saveCoordinate(ItemField.X_Item, this.delta.x);\n            if (this._fieldLocked[ItemField.Y_Item])\n                this.saveCoordinate(ItemField.Y_Item, this.delta.y);\n        }\n        const vp = this.currentView;\n        if (vp && vp.view.is3d()) {\n            if (this._fieldLocked[ItemField.Z_Item])\n                this.saveCoordinate(ItemField.Z_Item, this.delta.z);\n        }\n    }\n    /** Called after compass mode is changed between polar and rectangular */\n    onCompassModeChange() { }\n    /** Called after compass rotation is changed */\n    onRotationModeChange() { }\n    /** Called after input field locked state is changed */\n    onFieldLockChange(_index) { }\n    /** Called after input field value changes */\n    onFieldValueChange(_index) { }\n    /** Whether AccuDraw currently has input focus */\n    get hasInputFocus() { return true; }\n    /** Set focus to the specified input field */\n    setFocusItem(_index) { }\n    static getMinPolarMag(origin) {\n        return (1.0e-12 * (1.0 + origin.magnitude()));\n    }\n    /** projects cursor onto plane in view, or returns an error */\n    constructionPlane(outPtP, inPtP, pointOnPlaneP, normalVectorP, vp, perpendicular) {\n        let fromPtP;\n        let dotProduct;\n        let distance;\n        let projectionVector = new Vector3d();\n        if (perpendicular) {\n            if (AccuDraw.useACSContextRotation(vp, true)) { // Project along ACS axis to AccuDraw plane...\n                const rMatrix = vp.getAuxCoordRotation(AccuDraw._tempRot);\n                const axes = ThreeAxes.createFromMatrix3d(rMatrix);\n                this.accountForAuxRotationPlane(axes, this.flags.auxRotationPlane);\n                linePlaneIntersect(outPtP, inPtP, axes.z, pointOnPlaneP, normalVectorP, false);\n            }\n            else {\n                projectionVector = inPtP.vectorTo(pointOnPlaneP);\n                distance = projectionVector.dotProduct(normalVectorP);\n                inPtP.plusScaled(normalVectorP, distance, outPtP);\n            }\n        }\n        else {\n            const isCamera = vp.isCameraOn;\n            if (vp.view.is3d() && isCamera) {\n                const cameraPos = vp.view.getEyePoint();\n                fromPtP = cameraPos;\n                fromPtP.vectorTo(inPtP, projectionVector).normalizeInPlace();\n            }\n            else {\n                const rMatrix = vp.rotation;\n                fromPtP = inPtP;\n                rMatrix.getRow(2, projectionVector);\n            }\n            dotProduct = projectionVector.dotProduct(normalVectorP);\n            if (Math.abs(dotProduct) < 0.00001 /* Constants.SMALL_DELTA */)\n                return BentleyStatus.ERROR; // PARALLEL;\n            distance = (normalVectorP.dotProduct(pointOnPlaneP) - normalVectorP.dotProduct(fromPtP)) / dotProduct;\n            if (isCamera && distance < 0.00001 /* Constants.SMALL_DELTA */)\n                return BentleyStatus.ERROR; // BEHIND_EYE_POINT;\n            fromPtP.plusScaled(projectionVector, distance, outPtP);\n        }\n        return BentleyStatus.SUCCESS;\n    }\n    /** @internal */\n    softConstructionPlane(outPtP, inPtP, pointOnPlaneP, normalVectorP, vp, isSnap) {\n        if (!vp.isPointAdjustmentRequired) {\n            outPtP.setFrom(inPtP);\n            return true;\n        }\n        if (isSnap) {\n            outPtP.setFrom(inPtP);\n            const delta = pointOnPlaneP.vectorTo(outPtP);\n            return (Math.abs(normalVectorP.dotProduct(delta)) < 0.00001 /* Constants.SMALL_DELTA */);\n        }\n        if (BentleyStatus.SUCCESS !== this.constructionPlane(outPtP, inPtP, pointOnPlaneP, normalVectorP, vp, false)) {\n            const viewNormal = vp.rotation.getRow(2);\n            this.constructionPlane(outPtP, inPtP, pointOnPlaneP, viewNormal, vp, false);\n            this.constructionPlane(outPtP, outPtP, pointOnPlaneP, normalVectorP, vp, true);\n            return false;\n        }\n        return true;\n    }\n    /** @internal */\n    hardConstructionPlane(outPtP, inPtP, pointOnPlaneP, normalVectorP, vp, isSnap) {\n        if (!vp.isPointAdjustmentRequired) {\n            outPtP.setFrom(inPtP);\n            return true;\n        }\n        if (BentleyStatus.SUCCESS !== this.constructionPlane(outPtP, inPtP, pointOnPlaneP, normalVectorP, vp, isSnap)) {\n            const viewNormal = vp.rotation.getRow(2);\n            this.constructionPlane(outPtP, inPtP, pointOnPlaneP, viewNormal, vp, false);\n            this.constructionPlane(outPtP, outPtP, pointOnPlaneP, normalVectorP, vp, true);\n        }\n        return true;\n    }\n    static allowAxisIndexing(pointIsOnPlane) {\n        // NOTE: Normally we don't want indexing overriding a hot snap location. The\n        //       exception to this is nearest snap. If the nearest snap is in the plane\n        //       of the AccuDraw compass, it is confusing not having axis indexing.\n        if (!TentativeOrAccuSnap.isHot)\n            return true;\n        if (!pointIsOnPlane)\n            return false;\n        const snapDetail = IModelApp.accuSnap.getCurrSnapDetail();\n        return (undefined !== snapDetail && (SnapMode.Nearest === snapDetail.snapMode));\n    }\n    applyDistanceRoundOff(distance, vp) {\n        if (!this._distanceRoundOff.active || !this._distanceRoundOff.units.size)\n            return undefined;\n        let roundValue = this._distanceRoundOff.units.values().next().value;\n        if (this._distanceRoundOff.units.size > 1) {\n            // NOTE: Set isn't ordered, find smallest entry...\n            this._distanceRoundOff.units.forEach((thisRoundValue) => {\n                if (thisRoundValue < roundValue)\n                    roundValue = thisRoundValue;\n            });\n            if (vp.viewDelta.magnitudeXY() < roundValue)\n                return undefined; // Smallest rounding value is larger than view...don't use...\n            const smallScreenDist = 0.0787402; // ~2 mm...\n            const pixelSize = vp.getPixelSizeAtPoint(this.origin);\n            const screenDist = vp.pixelsFromInches(smallScreenDist) * pixelSize;\n            this._distanceRoundOff.units.forEach((thisRoundValue) => {\n                if (thisRoundValue > roundValue && thisRoundValue < screenDist)\n                    roundValue = thisRoundValue;\n            });\n        }\n        if (roundValue <= 0.0)\n            return undefined;\n        return roundValue * Math.floor((distance / roundValue) + 0.5);\n    }\n    applyAngleRoundOff(angle, distance, vp) {\n        if (!this._angleRoundOff.active || !this._angleRoundOff.units.size)\n            return undefined;\n        let roundValue = this._angleRoundOff.units.values().next().value;\n        if (this._angleRoundOff.units.size > 1) {\n            // NOTE: Set isn't ordered, find smallest entry...\n            this._angleRoundOff.units.forEach((thisRoundValue) => {\n                if (thisRoundValue < roundValue)\n                    roundValue = thisRoundValue;\n            });\n            const circumference = 2.0 * Math.PI * distance;\n            const roundDist = circumference / ((2.0 * Math.PI) / roundValue);\n            if (vp.viewDelta.magnitudeXY() < roundDist)\n                return undefined; // Smallest rounding value is larger than view...don't use...\n            const smallScreenDist = 0.0787402; // ~2 mm...\n            const pixelSize = vp.getPixelSizeAtPoint(this.origin);\n            const screenDist = vp.pixelsFromInches(smallScreenDist) * pixelSize;\n            this._angleRoundOff.units.forEach((thisRoundValue) => {\n                const thisRoundDist = circumference / ((2.0 * Math.PI) / thisRoundValue);\n                if (thisRoundValue > roundValue && thisRoundDist < screenDist)\n                    roundValue = thisRoundValue;\n            });\n        }\n        if (roundValue <= 0.0)\n            return undefined;\n        return roundValue * Math.floor((angle / roundValue) + 0.5);\n    }\n    /** @internal */\n    fixPointPolar(vp) {\n        let angleChanged = false;\n        let distChanged = false;\n        const zLocked = this.isZLocked(vp);\n        const xyCorrection = new Point3d();\n        this.planePt.setFrom(this.origin);\n        if (zLocked && !(this.delta.z < 1e-12 /* Constants.SMALL_ANGLE */ && this.delta.z > -1e-12 /* Constants.SMALL_ANGLE */))\n            this.planePt.addScaledInPlace(this.axes.z, this.delta.z);\n        if (this.locked & LockedStates.VEC_BM) {\n            if (!TentativeOrAccuSnap.isHot) {\n                const normVec = new Vector3d();\n                this.planeByVectorAndView(normVec, this.vector, vp);\n                this.softConstructionPlane(this._rawPointOnPlane, this._rawPoint, this.planePt, normVec, vp, false);\n            }\n            else {\n                this._rawPointOnPlane.setFrom(this._rawPoint);\n                this.flags.pointIsOnPlane = false;\n            }\n        }\n        else {\n            if (zLocked) {\n                this.hardConstructionPlane(this._rawPointOnPlane, this._rawPoint, this.planePt, this.axes.z, vp, TentativeOrAccuSnap.isHot);\n                this.flags.pointIsOnPlane = true;\n            }\n            else {\n                this.flags.pointIsOnPlane = (this.softConstructionPlane(this._rawPointOnPlane, this._rawPoint, this.planePt, this.axes.z, vp, TentativeOrAccuSnap.isHot) || !!(this.locked & LockedStates.XY_BM));\n            }\n        }\n        let delta;\n        if (zLocked)\n            delta = this.planePt.vectorTo(this._rawPointOnPlane);\n        else\n            delta = this.origin.vectorTo(this._rawPointOnPlane);\n        const minPolarMag = AccuDraw.getMinPolarMag(this.origin);\n        let mag;\n        if (this.locked & LockedStates.VEC_BM) {\n            mag = delta.dotProduct(this.vector);\n            xyCorrection.x -= delta.x - mag * this.vector.x;\n            xyCorrection.y -= delta.y - mag * this.vector.y;\n            xyCorrection.z -= delta.z - mag * this.vector.z;\n            this.vector.scale(mag, delta);\n            if (mag < 0.0)\n                mag = -mag;\n            if (mag < minPolarMag) {\n                this.handleDegeneratePolarCase();\n                return;\n            }\n            this.flags.pointIsOnPlane = (Math.abs(this.axes.z.dotProduct(delta)) < 0.00001 /* Constants.SMALL_DELTA */);\n        }\n        else {\n            mag = delta.magnitude();\n            if (mag < minPolarMag) {\n                this.handleDegeneratePolarCase();\n                return;\n            }\n        }\n        const newPt = this._rawPointOnPlane.plus(xyCorrection);\n        xyCorrection.setZero();\n        // measure angle\n        const rotVec = new Point3d();\n        rotVec.x = this.axes.x.dotProduct(delta);\n        // NOTE: Always return angle relative to compass plane...used to return \"angle out of plane\" for points off plane.\n        rotVec.y = this.axes.y.dotProduct(delta);\n        this._angle = Math.atan2(rotVec.y, rotVec.x);\n        // constrain angle\n        if (this.flags.pointIsOnPlane && !(this.locked & LockedStates.VEC_BM)) {\n            if (!TentativeOrAccuSnap.isHot) {\n                const newAngle = this.applyAngleRoundOff(this._angle, mag, vp);\n                if (undefined !== newAngle) {\n                    angleChanged = true;\n                    this._angle = newAngle;\n                    xyCorrection.x += Math.cos(this._angle) * mag - rotVec.x;\n                    xyCorrection.y += Math.sin(this._angle) * mag - rotVec.y;\n                    rotVec.x = Math.cos(this._angle) * mag;\n                    rotVec.y = Math.sin(this._angle) * mag;\n                }\n            }\n            if (this.locked & LockedStates.X_BM || (AccuDraw.allowAxisIndexing(this.flags.pointIsOnPlane) && (rotVec.x < this._tolerance && rotVec.x > -this._tolerance) && !this.flags.indexLocked && this.axisIndexing)) {\n                this.indexed |= LockedStates.X_BM; // indexed in X\n                xyCorrection.x -= rotVec.x;\n                rotVec.x = 0.0;\n                if (TentativeOrAccuSnap.isHot)\n                    xyCorrection.z -= delta.dotProduct(this.axes.z);\n                this._angle = (rotVec.y < 0.0) ? -Math.PI / 2.0 : Math.PI / 2.0;\n                angleChanged = true;\n            }\n            if (this.locked & LockedStates.Y_BM || (AccuDraw.allowAxisIndexing(this.flags.pointIsOnPlane) && (rotVec.y < this._tolerance && rotVec.y > -this._tolerance) && !this.flags.indexLocked && this.axisIndexing)) {\n                if (this.indexed & LockedStates.X_BM) { // both indexed\n                    this.handleDegeneratePolarCase();\n                    return;\n                }\n                this.indexed |= LockedStates.Y_BM; // indexed in Y\n                xyCorrection.y -= rotVec.y;\n                if (TentativeOrAccuSnap.isHot)\n                    xyCorrection.z -= delta.dotProduct(this.axes.z);\n                rotVec.y = 0.0;\n                this._angle = (rotVec.x < 0.0) ? Math.PI : 0.0;\n                angleChanged = true;\n            }\n            if (angleChanged) {\n                this.axes.x.scale(rotVec.x, delta);\n                delta.addScaledInPlace(this.axes.y, rotVec.y);\n                mag = delta.magnitude();\n                if (mag < minPolarMag) {\n                    this.handleDegeneratePolarCase();\n                    return;\n                }\n            }\n        }\n        // constrain distance\n        const oldMag = mag;\n        if (this.locked & LockedStates.DIST_BM) { // distance locked\n            mag = this._distance;\n            distChanged = true;\n            this.indexed &= ~LockedStates.DIST_BM;\n        }\n        else if (!TentativeOrAccuSnap.isHot) { // if non-snap, try rounding and aligning\n            const newDist = this.applyDistanceRoundOff(mag, vp);\n            if (undefined !== newDist) {\n                distChanged = true;\n                mag = newDist;\n            }\n            if (Geometry.isDistanceWithinTol(mag - this._lastDistance, this._tolerance) && !this.flags.indexLocked && this.distanceIndexing) {\n                this.indexed |= LockedStates.DIST_BM; // distance indexed\n                mag = this._lastDistance;\n                distChanged = true;\n            }\n        }\n        // project to corrected point\n        newPt.plus3Scaled(this.axes.x, xyCorrection.x, this.axes.y, xyCorrection.y, this.axes.z, xyCorrection.z, newPt);\n        // display index highlight even if snapped\n        if (TentativeOrAccuSnap.isHot && this.flags.pointIsOnPlane) {\n            if (Math.abs(rotVec.x) < 1e-12 /* Constants.SMALL_ANGLE */)\n                this.indexed |= LockedStates.X_BM;\n            else if (Math.abs(rotVec.y) < 1e-12 /* Constants.SMALL_ANGLE */)\n                this.indexed |= LockedStates.Y_BM;\n        }\n        if (distChanged) {\n            if (mag < minPolarMag && mag > -minPolarMag) {\n                this.handleDegeneratePolarCase();\n                return;\n            }\n            // adjust corrected point for distance indexing\n            newPt.addScaledInPlace(delta, mag / oldMag - 1.0);\n            delta.scaleInPlace(mag / oldMag);\n        }\n        // save corrected point\n        this.point.setFrom(newPt);\n        // finish up\n        this._distance = mag;\n        if (!(this.locked & LockedStates.VEC_BM))\n            delta.scale(1.0 / mag, this.vector);\n        if (this.locked & LockedStates.XY_BM)\n            this.indexed |= this.locked;\n        if (!zLocked)\n            this.delta.z = (this.flags.pointIsOnPlane) ? 0.0 : delta.dotProduct(this.axes.z);\n    }\n    /** @internal */\n    fixPointRectangular(vp) {\n        const zLocked = this.isZLocked(vp);\n        const xyCorrection = new Vector3d();\n        this.planePt.setFrom(this.origin);\n        this.indexed = 0;\n        if (zLocked) {\n            this.flags.pointIsOnPlane = (this.delta.z < 1e-12 /* Constants.SMALL_ANGLE */ && this.delta.z > -1e-12 /* Constants.SMALL_ANGLE */);\n            if (!this.flags.pointIsOnPlane)\n                this.planePt.addScaledInPlace(this.axes.z, this.delta.z);\n            this.hardConstructionPlane(this._rawPointOnPlane, this._rawPoint, this.planePt, this.axes.z, vp, TentativeOrAccuSnap.isHot);\n        }\n        else {\n            this.flags.pointIsOnPlane = this.softConstructionPlane(this._rawPointOnPlane, this._rawPoint, this.origin, this.axes.z, vp, TentativeOrAccuSnap.isHot);\n        }\n        const trueDelta = this.origin.vectorTo(this._rawPointOnPlane);\n        this._rawDelta.x = trueDelta.dotProduct(this.axes.x);\n        this._xIsNegative = (this._rawDelta.x < -1e-12 /* Constants.SMALL_ANGLE */);\n        this._rawDelta.y = trueDelta.dotProduct(this.axes.y);\n        this._yIsNegative = (this._rawDelta.y < -1e-12 /* Constants.SMALL_ANGLE */);\n        if (!zLocked)\n            this.delta.z = (this.flags.pointIsOnPlane) ? 0.0 : trueDelta.dotProduct(this.axes.z);\n        if (AccuDraw.allowAxisIndexing(this.flags.pointIsOnPlane)) {\n            if (!(this.locked & LockedStates.X_BM)) { // not locked in x\n                const roundedDeltaX = this.applyDistanceRoundOff(this._rawDelta.x, vp); // round x\n                if (undefined !== roundedDeltaX) {\n                    xyCorrection.x = roundedDeltaX - this._rawDelta.x;\n                    this._rawDelta.x = roundedDeltaX;\n                }\n                if (this._rawDelta.x < this._tolerance && this._rawDelta.x > -this._tolerance &&\n                    !this.flags.indexLocked && this.axisIndexing) { // index x\n                    this.indexed |= LockedStates.X_BM; // indexed in X\n                    xyCorrection.x -= this._rawDelta.x;\n                    this._rawDelta.x = 0.0;\n                }\n            }\n            if (!(this.locked & LockedStates.Y_BM)) {\n                const roundedDeltaY = this.applyDistanceRoundOff(this._rawDelta.y, vp); // round y\n                if (undefined !== roundedDeltaY) {\n                    xyCorrection.y = roundedDeltaY - this._rawDelta.y;\n                    this._rawDelta.y = roundedDeltaY;\n                }\n                if (this._rawDelta.y < this._tolerance && this._rawDelta.y > -this._tolerance &&\n                    !this.flags.indexLocked && this.axisIndexing) { // index y\n                    this.indexed |= LockedStates.Y_BM; // indexed in Y\n                    xyCorrection.y -= this._rawDelta.y;\n                    this._rawDelta.y = 0.0;\n                }\n            }\n        }\n        if (this.locked & LockedStates.X_BM) {\n            if (this.rawDeltaIsValid(this._rawDelta.x)) {\n                // cursor changed sides, reverse value\n                if ((this.delta.x < -1e-12 /* Constants.SMALL_ANGLE */) !== this._xIsNegative &&\n                    this.smartKeyin && this._keyinStatus[ItemField.X_Item] === KeyinStatus.Partial &&\n                    !this._xIsExplicit)\n                    this.delta.x = -this.delta.x;\n            }\n            xyCorrection.x = this.delta.x - this._rawDelta.x;\n        }\n        else {\n            const lastDist = (this._rawDelta.x < 0.0) ? (-this._lastDistance) : this._lastDistance;\n            if (!TentativeOrAccuSnap.isHot && ((this.locked & LockedStates.Y_BM) || (this.indexed & LockedStates.Y_BM)) && !(this.indexed & LockedStates.X_BM) &&\n                Geometry.isDistanceWithinTol(this._rawDelta.x - lastDist, this._tolerance) &&\n                !this.flags.indexLocked && this.distanceIndexing) {\n                xyCorrection.x += lastDist - this._rawDelta.x;\n                this.delta.x = lastDist;\n                this.indexed |= LockedStates.DIST_BM;\n            }\n            else {\n                this.delta.x = this._rawDelta.x;\n            }\n        }\n        if (this.locked & LockedStates.Y_BM) {\n            if (this.rawDeltaIsValid(this._rawDelta.y)) {\n                // cursor changed sides, reverse value\n                if ((this.delta.y < -1e-12 /* Constants.SMALL_ANGLE */) !== this._yIsNegative &&\n                    this.smartKeyin && this._keyinStatus[ItemField.Y_Item] === KeyinStatus.Partial &&\n                    !this._yIsExplicit)\n                    this.delta.y = -this.delta.y;\n            }\n            xyCorrection.y = this.delta.y - this._rawDelta.y;\n        }\n        else {\n            const lastDist = (this._rawDelta.y < 1e-12 /* Constants.SMALL_ANGLE */) ? -this._lastDistance : this._lastDistance;\n            if (!TentativeOrAccuSnap.isHot && ((this.locked & LockedStates.X_BM) || (this.indexed & LockedStates.X_BM)) && !(this.indexed & LockedStates.Y_BM) &&\n                Geometry.isDistanceWithinTol(this._rawDelta.y - lastDist, this._tolerance) &&\n                !this.flags.indexLocked && this.distanceIndexing) {\n                xyCorrection.y += lastDist - this._rawDelta.y;\n                this.delta.y = lastDist;\n                this.indexed |= LockedStates.DIST_BM;\n            }\n            else {\n                this.delta.y = this._rawDelta.y;\n            }\n        }\n        this._rawPointOnPlane.plus2Scaled(this.axes.x, xyCorrection.x, this.axes.y, xyCorrection.y, this.point);\n        if (zLocked && !this.flags.pointIsOnPlane)\n            this.hardConstructionPlane(this.point, this.point, this.planePt, this.axes.z, vp, TentativeOrAccuSnap.isHot);\n        if ((this.locked & LockedStates.X_BM && this.delta.x === 0.0) || (this.locked & LockedStates.Y_BM && this.delta.y === 0.0)) {\n            this.indexed |= this.locked; // to display index highlight\n        }\n        else if (TentativeOrAccuSnap.isHot) {\n            if (Math.abs(this.delta.x) < 1e-12 /* Constants.SMALL_ANGLE */)\n                this.indexed |= LockedStates.X_BM;\n            else if (Math.abs(this.delta.y) < 1e-12 /* Constants.SMALL_ANGLE */)\n                this.indexed |= LockedStates.Y_BM;\n        }\n        const lock = this.locked & LockedStates.XY_BM;\n        const index = this.indexed & LockedStates.XY_BM;\n        if (lock === LockedStates.Y_BM && index !== LockedStates.X_BM) {\n            if (this._keyinStatus[ItemField.Y_Item] !== KeyinStatus.Dynamic) {\n                if (Math.abs(this._rawDelta.x) < this._threshold)\n                    return;\n            }\n            this.newFocus = ItemField.X_Item;\n            this.dontMoveFocus = false;\n        }\n        else if (lock === LockedStates.X_BM && index !== LockedStates.Y_BM) {\n            if (this._keyinStatus[ItemField.X_Item] !== KeyinStatus.Dynamic) {\n                if (Math.abs(this._rawDelta.y) < this._threshold)\n                    return;\n            }\n            this.newFocus = ItemField.Y_Item;\n            this.dontMoveFocus = false;\n        }\n        else {\n            this.newFocus = ((Math.abs(this._rawDelta.x) > Math.abs(this._rawDelta.y)) ? ItemField.X_Item : ItemField.Y_Item);\n        }\n    }\n    fixPoint(pointActive, vp) {\n        if (this.isActive && ((vp !== this.currentView) || this.flags.rotationNeedsUpdate)) {\n            this.currentView = vp;\n            if (!(this.locked & LockedStates.ANGLE_BM || this._fieldLocked[ItemField.Z_Item])) {\n                // origin not locked down...may change when vie changes...\n                if (!this.flags.haveValidOrigin)\n                    this.setDefaultOrigin(vp);\n                // in a view based rotation, and the view has changed, so update the rotation...\n                if (!this.flags.lockedRotation) {\n                    this.updateRotation();\n                    this.flags.rotationNeedsUpdate = false;\n                }\n            }\n        }\n        if (this.isInactive || this.isDeactivated) {\n            this.point.setFrom(pointActive);\n            this.currentView = vp;\n            this.processHints();\n            return;\n        }\n        if (this.isActive) {\n            this._rawPoint.setFrom(pointActive);\n            this.currentView = vp;\n            this.flags.dialogNeedsUpdate = true;\n            if (TentativeOrAccuSnap.isHot && CompassMode.Polar === this.compassMode)\n                this.indexed = this.locked;\n            else\n                this.indexed = LockedStates.NONE_LOCKED;\n            if (CompassMode.Polar === this.compassMode)\n                this.fixPointPolar(vp);\n            else\n                this.fixPointRectangular(vp);\n            pointActive.setFrom(this.point);\n        }\n        else if (CompassMode.Rectangular === this.compassMode) {\n            if (this._fieldLocked[ItemField.X_Item])\n                pointActive.x = this.delta.x;\n            if (this._fieldLocked[ItemField.Y_Item])\n                pointActive.y = this.delta.y;\n            if (this._fieldLocked[ItemField.Z_Item])\n                pointActive.z = this.delta.z;\n        }\n    }\n    /** @internal */\n    refreshDecorationsAndDynamics() {\n        // Immediately process hints and show dynamics using adjusted point when not called from button down...\n        if (!this.flags.inDataPoint)\n            this.processHints();\n        // Make sure AccuDraw updates its decorations...\n        if (undefined !== this.currentView)\n            this.currentView.invalidateDecorations();\n        // Make sure active tool updates its dynamics. NOTE: Need point adjusted for new locks, etc.\n        IModelApp.toolAdmin.updateDynamics(undefined, undefined, true);\n    }\n    /** @internal */\n    upgradeToActiveState() {\n        if (!this.isEnabled)\n            return false;\n        this.onEventCommon();\n        if (!this.isInactive)\n            return false;\n        const vp = this.currentView;\n        if (!vp || 1.0 !== vp.view.getAspectRatioSkew())\n            return false; // Disallow AccuDraw being enabled for exaggerated views...\n        // NOTE: If ACS Plane lock setup initial and base rotation to ACS...\n        if (vp && AccuDraw.useACSContextRotation(vp, false)) {\n            this.setRotationMode(RotationMode.ACS);\n            this.flags.baseRotation = RotationMode.ACS;\n            this.flags.auxRotationPlane = RotationMode.Top;\n        }\n        if (this.published.flags & AccuDrawFlags.SmartRotation) {\n            const snap = TentativeOrAccuSnap.getCurrentSnap(false);\n            if (undefined !== snap) {\n                const rotation = AccuDraw.getSnapRotation(snap, vp);\n                if (undefined !== rotation) {\n                    this.setContextRotation(rotation, true, false);\n                    this.changeBaseRotationMode(RotationMode.Context);\n                }\n            }\n        }\n        this.checkRotation();\n        // Compass will jump to correct location when fixPoint is called...but we don't want to see the jump...\n        if (!this.flags.haveValidOrigin)\n            this.setDefaultOrigin(vp);\n        // Initialize rawPoint data...invalid for alignments until next fixPoint...\n        this._rawPoint.setFrom(this.point);\n        this._rawPointOnPlane.setFrom(this.point);\n        // Upgrade state to enabled...want compass to display...\n        this.currentState = CurrentState.Active;\n        return false;\n    }\n    /** @internal */\n    downgradeInactiveState() {\n        if (!this.isEnabled)\n            return false;\n        this.onEventCommon();\n        if (!this.isActive)\n            return false;\n        // Downgrade state back to inactive...\n        this.currentState = CurrentState.Inactive;\n        return false;\n    }\n    /** @internal */\n    onBeginDynamics() { return this.upgradeToActiveState(); }\n    /** @internal */\n    onEndDynamics() { return this.downgradeInactiveState(); }\n    /** Implemented by sub-classes to update ui fields to show current deltas or coordinates when inactive.\n     * Should also choose active x or y input field in rectangular mode based on cursor position when\n     * axis isn't locked to support \"smart lock\".\n     */\n    onMotion(_ev) { }\n    /** @internal */\n    onPreButtonEvent(ev) {\n        if (BeButton.Reset === ev.button && !ev.isDown && !ev.isDragging) {\n            if (IModelApp.tentativePoint.isActive && this.isActive) {\n                IModelApp.tentativePoint.clear(true);\n                this.refreshDecorationsAndDynamics();\n                return true;\n            }\n            if (this.isEnabled)\n                this.onEventCommon();\n            return false;\n        }\n        if (BeButton.Data !== ev.button || !ev.isDown || !this.isEnabled)\n            return false;\n        this.onEventCommon();\n        this.flags.inDataPoint = true;\n        if (this.currentState < CurrentState.Inactive)\n            return false;\n        if (!this.currentView)\n            this.currentView = ev.viewport;\n        this.updateRotation();\n        return false;\n    }\n    /** @internal */\n    onPostButtonEvent(ev) {\n        if (BeButton.Data !== ev.button || !ev.isDown || !this.isEnabled)\n            return false;\n        this.onEventCommon();\n        if (this.flags.ignoreDataButton) {\n            // NOTE: Ignore this data point, was used to terminate a viewing command or input collector...\n            this.flags.ignoreDataButton = false;\n        }\n        else if (!this.flags.fixedOrg && this.currentState >= CurrentState.Inactive) {\n            /* set origin to last point placed unless its being set elsewhere */\n            if (((!this.contextSensitive &&\n                !(this.published.flags & (AccuDrawFlags.AlwaysSetOrigin ^ AccuDrawFlags.SetOrigin))) ||\n                !(this.published.flags & AccuDrawFlags.SetOrigin))) {\n                this.published.flags |= AccuDrawFlags.SetOrigin;\n                if (this.currentState >= CurrentState.Inactive)\n                    this.published.origin.setFrom(ev.point);\n                else\n                    this.published.origin.setFrom(this.point);\n            }\n            this.saveLockedCoords();\n            this.processHints();\n            if (this.currentState >= CurrentState.Inactive)\n                this.updateRotation();\n        }\n        this.flags.inDataPoint = false;\n        this.flags.indexLocked = false;\n        return false;\n    }\n    /** @internal */\n    onTentative() {\n        if (this.isActive || this.isInactive)\n            this.grabInputFocus(); // AccuDraw gets input focus on a tentative\n        return false;\n    }\n    intersectXYCurve(snap, curve, usePointOnSnap) {\n        if (undefined === this.currentView)\n            return;\n        const curveSegment = snap.getCurvePrimitive(); // Get single segment of linestring/shape...\n        if (undefined === curveSegment)\n            return;\n        const worldToView = this.currentView.worldToViewMap.transform0;\n        const detail = CurveCurve.intersectionProjectedXYPairs(worldToView, usePointOnSnap ? curveSegment : curve, true, usePointOnSnap ? curve : curveSegment, true);\n        if (0 === detail.length)\n            return;\n        let closeIndex = 0;\n        if (detail.length > 1) {\n            const snapPt = worldToView.multiplyPoint3d(snap.getPoint(), 1);\n            let lastDist;\n            for (let i = 0; i < detail.length; i++) {\n                const testPt = worldToView.multiplyPoint3d(detail[i].detailA.point, 1);\n                const testDist = snapPt.realDistanceXY(testPt);\n                if (undefined !== testDist && (undefined === lastDist || testDist < lastDist)) {\n                    lastDist = testDist;\n                    closeIndex = i;\n                }\n            }\n        }\n        snap.setSnapPoint(detail[closeIndex].detailA.point, SnapHeat.NotInRange);\n    }\n    intersectLine(snap, linePt, unitVec) {\n        const vec = Vector3d.createStartEnd(linePt, snap.getPoint());\n        const endPt = linePt.plusScaled(unitVec, vec.dotProduct(unitVec));\n        const cpLine = LineSegment3d.create(linePt, endPt);\n        this.intersectXYCurve(snap, cpLine, true); // Get point on snapped curve, not AccuDraw axis. Snap point isn't required to be in AccuDraw plane when Z isn't locked.\n    }\n    intersectCircle(snap, center, normal, radius) {\n        const matrix = Matrix3d.createRigidHeadsUp(normal);\n        const vector0 = matrix.columnX();\n        const vector90 = matrix.columnY();\n        vector0.scaleToLength(radius, vector0);\n        vector90.scaleToLength(radius, vector90);\n        const cpArc = Arc3d.create(center, vector0, vector90);\n        this.intersectXYCurve(snap, cpArc, false); // Get point on AccuDraw distance circle, not snapped curve. Want to preserve distance constraint with apparent intersection in XY.\n    }\n    /** @internal */\n    onSnap(snap) {\n        // If accudraw is locked, adjust near snap point to be the nearest point on this element, CONSTRAINED by the accudraw lock.\n        if (!this.isActive || !this.locked)\n            return false;\n        if (SnapMode.Nearest !== snap.snapMode)\n            return false;\n        if (!snap.primitive)\n            return false;\n        switch (this.locked) {\n            case LockedStates.VEC_BM: {\n                this.intersectLine(snap, this.origin, this.vector);\n                break;\n            }\n            case LockedStates.X_BM: {\n                const refPt = (CompassMode.Rectangular === this.compassMode) ? this.planePt.plusScaled(this.axes.x, this.delta.x) : this.origin;\n                this.intersectLine(snap, refPt, this.axes.y);\n                break;\n            }\n            case LockedStates.Y_BM: {\n                const refPt = (CompassMode.Rectangular === this.compassMode) ? this.planePt.plusScaled(this.axes.y, this.delta.y) : this.origin;\n                this.intersectLine(snap, refPt, this.axes.x);\n                break;\n            }\n            case LockedStates.DIST_BM: {\n                this.intersectCircle(snap, this.origin, this.axes.z, this._distance);\n                break;\n            }\n        }\n        return false;\n    }\n    /** @internal */\n    onSelectedViewportChanged(previous, current) {\n        // In case previous is closing, always update AccuDraw to current view...\n        if (undefined !== this.currentView && this.currentView === previous)\n            this.currentView = current;\n        // Reset AccuDraw when iModel or view type changes...\n        if (undefined !== current && undefined !== previous &&\n            (current.view.classFullName === previous.view.classFullName) &&\n            (current.view.iModel === previous.view.iModel))\n            return;\n        this._acsPickId = undefined;\n        this.currentView = undefined;\n        this.flags.redrawCompass = false;\n        this.flags.baseRotation = RotationMode.View;\n        this.flags.auxRotationPlane = RotationMode.Top;\n        this.flags.rotationNeedsUpdate = true;\n        this.flags.haveValidOrigin = false;\n        this.flags.indexLocked = false;\n        this.flags.bearingFixToPlane2D = false;\n        this.setRotationMode(RotationMode.View);\n        this.updateRotation();\n        this.saveState(this.savedStateViewTool);\n        this.saveState(this.savedStateInputCollector);\n    }\n    doProcessHints() {\n        if (!this.floatingOrigin) {\n            if (this.published.flags & AccuDrawFlags.SetOrigin)\n                this.unlockAllFields();\n            return;\n        }\n        // Set Context Origin\n        if (this.published.flags & AccuDrawFlags.SetOrigin) {\n            if (this.floatingOrigin) {\n                this.origin.setFrom(this.published.origin);\n                this.point.setFrom(this.origin);\n                this.planePt.setFrom(this.origin);\n            }\n            this.flags.haveValidOrigin = true;\n            this.setLastPoint(this.origin);\n            this.unlockAllFields();\n            this.updateRotation();\n        }\n        if (!this.contextSensitive)\n            return;\n        // Mode -- Polar or Rectangular\n        if (this.published.flags & (AccuDrawFlags.SetModePolar | AccuDrawFlags.SetModeRect)) {\n            if (this.compassMode !== ((this.published.flags & AccuDrawFlags.SetModePolar) ? CompassMode.Polar : CompassMode.Rectangular))\n                this.changeCompassMode();\n        }\n        // Fixed Origin\n        if (this.published.flags & AccuDrawFlags.FixedOrigin)\n            this.flags.fixedOrg = true;\n        // Save Distance\n        if (this.published.flags & (AccuDrawFlags.SetDistance | AccuDrawFlags.LockDistance))\n            this.saveCoordinate(ItemField.DIST_Item, this.published.distance);\n        const vp = this.currentView;\n        // Do Context Rotation\n        if (this.published.flags & AccuDrawFlags.SetRMatrix) {\n            this.axes.fromMatrix3d(this.published.rMatrix);\n            this.flags.lockedRotation = true;\n            this.flags.contextRotMode = ContextMode.Locked;\n            this.setRotationMode(RotationMode.Context);\n            this.updateRotation();\n        }\n        else if (this.published.flags & AccuDrawFlags.SetXAxis) {\n            this.axes.x.setFrom(this.published.vector);\n            this.flags.contextRotMode = ContextMode.XAxis;\n            this.setRotationMode(RotationMode.Context);\n            this.updateRotation();\n        }\n        else if (this.published.flags & AccuDrawFlags.SetXAxis2) {\n            this.axes.x.setFrom(this.published.vector);\n            this.flags.contextRotMode = ContextMode.XAxis2;\n            this.setRotationMode(RotationMode.Context);\n            this.updateRotation();\n        }\n        else if (this.published.flags & AccuDrawFlags.SetNormal) {\n            if (vp && vp.view.is3d()) {\n                this.axes.z.setFrom(this.published.vector);\n                this.flags.contextRotMode = ContextMode.ZAxis;\n                this.setRotationMode(RotationMode.Context);\n                this.updateRotation();\n            }\n        }\n        else if (this.published.flags & AccuDrawFlags.OrientACS) {\n            this.flags.lockedRotation = true;\n            this.flags.baseRotation = RotationMode.ACS;\n            this.setRotationMode(RotationMode.ACS);\n            this.updateRotation();\n        }\n        else if (this.isInactive || (this.published.flags & AccuDrawFlags.OrientDefault)) {\n            this.setRotationMode(this.flags.baseRotation);\n            this.updateRotation();\n        }\n        // Lock Items\n        switch (this.compassMode) {\n            case CompassMode.Polar:\n                if (this.published.flags & AccuDrawFlags.LockDistance) {\n                    this._distance = this.published.distance;\n                    this.distanceLock(true, true);\n                }\n                if (this.published.flags & AccuDrawFlags.LockAngle) {\n                    this.updateVector(this.published.angle);\n                    this.indexed = LockedStates.NONE_LOCKED;\n                    this.angleLock();\n                    this.saveCoordinate(ItemField.ANGLE_Item, this.published.angle);\n                }\n                break;\n            case CompassMode.Rectangular:\n                if ((this.published.flags & AccuDrawFlags.Lock_X)) {\n                    this.locked |= LockedStates.X_BM;\n                    this.delta.x = this.published.delta.x;\n                    this.setFieldLock(ItemField.X_Item, true);\n                    this.saveCoordinate(ItemField.X_Item, this.published.delta.x);\n                }\n                if ((this.published.flags & AccuDrawFlags.Lock_Y)) {\n                    this.locked |= LockedStates.Y_BM;\n                    this.delta.y = this.published.delta.y;\n                    this.setFieldLock(ItemField.Y_Item, true);\n                    this.saveCoordinate(ItemField.Y_Item, this.published.delta.y);\n                }\n                if ((this.published.flags & AccuDrawFlags.Lock_Z)) {\n                    if (vp && vp.view.is3d()) {\n                        this.delta.z = this.published.delta.z;\n                        this.setFieldLock(ItemField.Z_Item, true);\n                        this.saveCoordinate(ItemField.Z_Item, this.published.delta.z);\n                    }\n                }\n                break;\n        }\n    }\n    /** @internal */\n    processHints() {\n        if (!this.published.flags || !this.isEnabled)\n            return;\n        if (this.published.flags & AccuDrawFlags.Disable) {\n            this.published.flags = 0;\n            this.currentState = CurrentState.Deactivated;\n            return;\n        }\n        const setFocus = !!(this.published.flags & AccuDrawFlags.SetFocus);\n        const smartRotation = !!(this.published.flags & AccuDrawFlags.SmartRotation);\n        this.doProcessHints();\n        this.published.zero();\n        if (smartRotation && this.isInactive) // Preserve smart rotation hint until when/if AccuDraw is enabled for the current tool...\n            this.published.flags = AccuDrawFlags.SmartRotation;\n        if (this.isEnabled || setFocus)\n            this.grabInputFocus();\n    }\n}\nAccuDraw._tempRot = new Matrix3d();\nexport { AccuDraw };\n/** Specify the rotation to return from [[AccuDrawHintBuilder.getContextRotation]].\n * @public\n * @extensions\n */\nexport var ContextRotationId;\n(function (ContextRotationId) {\n    ContextRotationId[ContextRotationId[\"Top\"] = 0] = \"Top\";\n    ContextRotationId[ContextRotationId[\"Front\"] = 1] = \"Front\";\n    ContextRotationId[ContextRotationId[\"Left\"] = 2] = \"Left\";\n    ContextRotationId[ContextRotationId[\"Bottom\"] = 3] = \"Bottom\";\n    ContextRotationId[ContextRotationId[\"Back\"] = 4] = \"Back\";\n    ContextRotationId[ContextRotationId[\"Right\"] = 5] = \"Right\";\n    ContextRotationId[ContextRotationId[\"View\"] = 6] = \"View\";\n    ContextRotationId[ContextRotationId[\"Face\"] = 7] = \"Face\";\n})(ContextRotationId || (ContextRotationId = {}));\n/** [[AccuDrawHintBuilder]] is an [[InteractiveTool]] helper class that facilitates AccuDraw interaction.\n * Accudraw is an aide for entering coordinate data.\n * A tool does not directly change the current AccuDraw state; the tool's job is merely\n * to supply \"hints\" to AccuDraw regarding its preferred AccuDraw configuration for the\n * current tool state. User settings such as \"Context Sensitivity\" and \"Floating Origin\"\n * affect how and which hints are applied. Additionally the user can drive AccuDraw\n * through keyboard shortcuts.\n * @see [Using AccuDraw]($docs/learning/frontend/primitivetools.md#AccuDraw)*\n * @public\n * @extensions\n */\nexport class AccuDrawHintBuilder {\n    constructor() {\n        this._flagOrigin = false;\n        this._flagNormal = false;\n        this._flagRotation = false;\n        this._flagXAxis = false;\n        this._flagXAxis2 = false;\n        this._flagDistance = false;\n        this._flagAngle = false;\n        this._flagModePolar = false;\n        this._flagModeRectangular = false;\n        this._distance = 0;\n        this._angle = 0;\n        /** Don't automatically set compass origin to point from data button events */\n        this.setOriginFixed = false;\n        /** Override \"fixed\" and \"floating\" origin settings for [[setOrigin] hint */\n        this.setOriginAlways = false;\n        /** Lock current distance value in polar mode */\n        this.setLockDistance = false;\n        /** Lock current angle value in polar mode */\n        this.setLockAngle = false;\n        /** Lock current x delta value in rectangular mode */\n        this.setLockX = false;\n        /** Lock current y delta value in rectangular mode  */\n        this.setLockY = false;\n        /** Lock current z delta value in 3d views */\n        this.setLockZ = false;\n        /** Set the initial compass orientation from the current [[SnapDetail]] when activating */\n        this.enableSmartRotation = false;\n    }\n    /** Add hint to specify a new compass origin */\n    setOrigin(origin) {\n        this._origin = origin.clone();\n        this._flagOrigin = true;\n    }\n    /** Add hint to fully specify compass orientation from a Matrix3d */\n    setMatrix(matrix) {\n        const invMatrix = matrix.inverse();\n        if (undefined === invMatrix)\n            return false;\n        this.setRotation(invMatrix);\n        return true;\n    }\n    /** @internal Add hint to fully specify compass orientation from a Matrix3d in row format */\n    setRotation(rowMatrix) {\n        this._rMatrix = rowMatrix.clone();\n        this._flagRotation = true;\n        this._flagXAxis = this._flagNormal = false;\n    }\n    /** Add hint to change compass orientation by combining the supplied x axis direction with the current base rotation */\n    setXAxis(xAxis) {\n        this._axis = xAxis.clone();\n        this._flagXAxis = true;\n        this._flagRotation = this._flagNormal = this._flagXAxis2 = false;\n    }\n    /** Add hint to change compass orientation by combining the supplied x axis direction with the current base rotation preferring the result most closely aligned to the view */\n    setXAxis2(xAxis) {\n        this._axis = xAxis.clone();\n        this._flagXAxis2 = true;\n        this._flagRotation = this._flagNormal = this._flagXAxis = false;\n    }\n    /** Add hint to change compass orientation by combining the supplied z axis direction with the current base rotation */\n    setNormal(normal) {\n        this._axis = normal.clone();\n        this._flagNormal = true;\n        this._flagRotation = this._flagXAxis = this._flagXAxis2 = false;\n    }\n    /** Add hint to change compass to polar mode */\n    setModePolar() {\n        this._flagModePolar = true;\n        this._flagModeRectangular = false;\n    }\n    /** Add hint to change compass to rectangular mode */\n    setModeRectangular() {\n        this._flagModeRectangular = true;\n        this._flagModePolar = false;\n    }\n    /** Set current distance value in polar mode */\n    setDistance(distance) {\n        this._distance = distance;\n        this._flagDistance = true;\n    }\n    /** Set current angle value in polar mode */\n    setAngle(angle) {\n        this._angle = angle;\n        this._flagAngle = true;\n    }\n    /** Enable AccuDraw for the current tool without sending any hints */\n    static activate() { IModelApp.accuDraw.activate(); }\n    /** Disable AccuDraw for the current tool */\n    static deactivate() { IModelApp.accuDraw.deactivate(); }\n    /** Whether AccuDraw is enabled by the host application this session and can be used */\n    static get isEnabled() { return IModelApp.accuDraw.isEnabled; }\n    /** Whether AccuDraw compass is currently displayed and points are being adjusted */\n    static get isActive() { return IModelApp.accuDraw.isEnabled; }\n    /**\n     * Provide hints to AccuDraw using the current builder state.\n     * @return true if hints were successfully sent.\n     */\n    sendHints(activate = true) {\n        let flags = 0;\n        if (this._flagOrigin)\n            flags |= AccuDrawFlags.SetOrigin;\n        if (this.setOriginFixed)\n            flags |= AccuDrawFlags.FixedOrigin;\n        if (this.setOriginAlways)\n            flags |= AccuDrawFlags.AlwaysSetOrigin;\n        if (this._flagRotation)\n            flags |= AccuDrawFlags.SetRMatrix;\n        if (this._flagXAxis)\n            flags |= AccuDrawFlags.SetXAxis;\n        if (this._flagXAxis2)\n            flags |= AccuDrawFlags.SetXAxis2;\n        if (this._flagNormal)\n            flags |= AccuDrawFlags.SetNormal;\n        if (this._flagModePolar)\n            flags |= AccuDrawFlags.SetModePolar;\n        if (this._flagModeRectangular)\n            flags |= AccuDrawFlags.SetModeRect;\n        if (this.setLockDistance)\n            flags |= AccuDrawFlags.LockDistance;\n        if (this.setLockAngle)\n            flags |= AccuDrawFlags.LockAngle;\n        if (this.setLockX)\n            flags |= AccuDrawFlags.Lock_X;\n        if (this.setLockY)\n            flags |= AccuDrawFlags.Lock_Y;\n        if (this.setLockZ)\n            flags |= AccuDrawFlags.Lock_Z;\n        if (this.enableSmartRotation)\n            flags |= AccuDrawFlags.SmartRotation;\n        const accuDraw = IModelApp.accuDraw;\n        if (BentleyStatus.SUCCESS !== accuDraw.setContext(flags, this._origin, this._flagRotation ? this._rMatrix : this._axis, undefined, this._flagDistance ? this._distance : undefined, this._flagAngle ? this._angle : undefined))\n            return false; // Not enabled for this session...\n        if (activate)\n            accuDraw.activate(); // If not already enabled (ex. dynamics not started) most/all callers would want to enable it now (optional activate arg provided just in case)...\n        return true;\n    }\n    /** Create a [[Ray3d]] whose origin is the supplied space point and direction is into the view */\n    static getBoresite(spacePt, vp, checkAccuDraw = false, checkACS = false) {\n        if (checkAccuDraw && IModelApp.accuDraw.isActive)\n            return Ray3d.create(spacePt, IModelApp.accuDraw.getRotation().getRow(2).negate());\n        if (checkACS && vp.isContextRotationRequired)\n            return Ray3d.create(spacePt, vp.getAuxCoordRotation().getRow(2).negate());\n        const eyePoint = vp.worldToViewMap.transform1.columnZ();\n        const direction = Vector3d.createFrom(eyePoint);\n        const aa = Geometry.conditionalDivideFraction(1, eyePoint.w);\n        if (aa !== undefined) {\n            const xyzEye = direction.scale(aa);\n            direction.setFrom(spacePt.vectorTo(xyzEye));\n        }\n        direction.scaleToLength(-1.0, direction);\n        return Ray3d.create(spacePt, direction);\n    }\n    /** Return ray intersection with a plane defined by a point and normal\n     * @see [[getBoresite]]\n     */\n    static projectPointToPlaneInView(spacePt, planePt, planeNormal, vp, checkAccuDraw = false, checkACS = false) {\n        const plane = Plane3dByOriginAndUnitNormal.create(planePt, planeNormal);\n        if (undefined === plane)\n            return undefined;\n        const rayToEye = AccuDrawHintBuilder.getBoresite(spacePt, vp, checkAccuDraw, checkACS);\n        const projectedPt = Point3d.createZero();\n        if (undefined === rayToEye.intersectionWithPlane(plane, projectedPt))\n            return undefined;\n        return projectedPt;\n    }\n    /** Return ray intersection with a line defined by a point and direction\n     * @see [[getBoresite]]\n     */\n    static projectPointToLineInView(spacePt, linePt, lineDirection, vp, checkAccuDraw = false, checkACS = false) {\n        const lineRay = Ray3d.create(linePt, lineDirection);\n        const rayToEye = AccuDrawHintBuilder.getBoresite(spacePt, vp, checkAccuDraw, checkACS);\n        if (rayToEye.direction.isParallelTo(lineRay.direction, true))\n            return lineRay.projectPointToRay(spacePt);\n        const matrix = Matrix3d.createRigidFromColumns(lineRay.direction, rayToEye.direction, AxisOrder.XZY);\n        if (undefined === matrix)\n            return undefined;\n        const plane = Plane3dByOriginAndUnitNormal.create(linePt, matrix.columnZ());\n        if (undefined === plane)\n            return undefined;\n        const projectedPt = Point3d.createZero();\n        if (undefined === rayToEye.intersectionWithPlane(plane, projectedPt))\n            return undefined;\n        return lineRay.projectPointToRay(projectedPt);\n    }\n    /** Return a [[Matrix3d]] representing the current working plane specified by AccuDraw, [[Viewport.auxCoordSystem]], or [[Viewport.rotation]]. */\n    static getCurrentRotation(vp, checkAccuDraw, checkACS, matrix) {\n        const current = AccuDraw.getCurrentOrientation(vp, checkAccuDraw, checkACS, matrix);\n        return (undefined !== current ? current.inverse() : undefined);\n    }\n    /** Return a [[Matrix3d]] corresponding to the supplied [[ContextRotationId]].\n     * A [[ContextRotationId]] that corresponds to a standard view, \"Top\", \"Front\", etc. will return a [[Matrix3d]] that\n     * is relative to the current [[Viewport.auxCoordSystem]] when ACS context lock is enabled.\n     * @see [[ToolAdmin.acsContextLock]]\n     */\n    static getContextRotation(id, vp) {\n        switch (id) {\n            case ContextRotationId.Top:\n                return AccuDraw.getStandardRotation(StandardViewId.Top, vp, vp.isContextRotationRequired).inverse();\n            case ContextRotationId.Front:\n                return AccuDraw.getStandardRotation(StandardViewId.Front, vp, vp.isContextRotationRequired).inverse();\n            case ContextRotationId.Left:\n                return AccuDraw.getStandardRotation(StandardViewId.Left, vp, vp.isContextRotationRequired).inverse();\n            case ContextRotationId.Bottom:\n                return AccuDraw.getStandardRotation(StandardViewId.Bottom, vp, vp.isContextRotationRequired).inverse();\n            case ContextRotationId.Back:\n                return AccuDraw.getStandardRotation(StandardViewId.Back, vp, vp.isContextRotationRequired).inverse();\n            case ContextRotationId.Right:\n                return AccuDraw.getStandardRotation(StandardViewId.Right, vp, vp.isContextRotationRequired).inverse();\n            case ContextRotationId.View:\n                return vp.view.getRotation().inverse();\n            case ContextRotationId.Face:\n                const snap = TentativeOrAccuSnap.getCurrentSnap(false);\n                if (undefined === snap || undefined === snap.normal)\n                    return undefined;\n                const normal = Vector3d.createZero();\n                const boresite = this.getBoresite(snap.hitPoint, vp);\n                if (snap.normal.dotProduct(boresite.direction) < 0.0)\n                    normal.setFrom(snap.normal);\n                else\n                    snap.normal.negate(normal);\n                return Matrix3d.createRigidHeadsUp(normal);\n        }\n    }\n}\n//# sourceMappingURL=AccuDraw.js.map",
      "start": 1693508118341,
      "end": 1693508118578,
      "sourcemaps": null
    }
  ]
}
