{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/TentativePoint.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module LocatingElements\n */\nimport { Point3d } from \"@itwin/core-geometry\";\nimport { AccuSnap } from \"./AccuSnap\";\nimport { HitDetail, HitPriority, HitSource, SnapDetail, SnapHeat, SnapMode } from \"./HitDetail\";\nimport { IModelApp } from \"./IModelApp\";\nimport { BeButton } from \"./tools/Tool\";\nimport { ViewHandleType, ViewManip } from \"./tools/ViewTool\";\n/**\n * @public\n * @extensions\n */\nexport class TentativePoint {\n    constructor() {\n        this.isActive = false;\n        this._point = new Point3d();\n        this._rawPoint = new Point3d();\n        this._viewPoint = new Point3d();\n    }\n    get _hotDistanceInches() { return 0.21; }\n    onInitialized() { }\n    setHitList(list) { this.tpHits = list; }\n    /** @return true if the tentative point is currently active and snapped to an element. */\n    get isSnapped() { return undefined !== this.currSnap; }\n    /** @return The current snap path when TentativePoint.isSnapped or undefined. */\n    getCurrSnap() { return this.currSnap; }\n    getPoint() {\n        const snap = this.currSnap;\n        return !snap ? this._point : snap.adjustedPoint;\n    }\n    setPoint(point) {\n        this.setCurrSnap(undefined);\n        this.tpHits = undefined;\n        this._point.setFrom(point);\n    }\n    clear(doErase) {\n        if (doErase) {\n            this.removeTentative();\n            IModelApp.accuSnap.synchSnapMode();\n        }\n        IModelApp.accuSnap.destroy();\n        this.isActive = false;\n        this.setCurrSnap(undefined);\n        this.tpHits = undefined;\n    }\n    removeTentative() {\n        this._tentativePromise = undefined;\n        if (!this.isActive)\n            return;\n        IModelApp.accuSnap.erase();\n        if (this.getCurrSnap())\n            IModelApp.viewManager.invalidateDecorationsAllViews();\n        else\n            this.viewport.invalidateDecorations();\n        this.isActive = false;\n    }\n    setCurrSnap(newSnap) {\n        if (newSnap)\n            newSnap.setSnapPoint(newSnap.snapPoint, SnapHeat.InRange); // Reset adjustedPoint from pre-located snap and set SnapHeat...\n        this.currSnap = newSnap;\n    }\n    showTentative() {\n        if (this.isSnapped) {\n            IModelApp.viewManager.invalidateDecorationsAllViews();\n            IModelApp.accuSnap.displayToolTip(this._viewPoint, this.viewport, undefined); // eslint-disable-line @typescript-eslint/no-floating-promises\n        }\n        else {\n            this.viewport.invalidateDecorations();\n        }\n        this.isActive = true;\n    }\n    getHitAndList(holder) {\n        const hit = this.currSnap;\n        if (hit) {\n            holder.setHitList(this.tpHits);\n            this.tpHits = undefined;\n        }\n        return hit;\n    }\n    onButtonEvent(ev) {\n        switch (ev.button) {\n            case BeButton.Data:\n                if (!ev.isDown)\n                    return; // cleared on down...\n                break;\n            case BeButton.Reset:\n                if (ev.isDown)\n                    return; // cleared on up...\n                break;\n            case BeButton.Middle:\n                return;\n        }\n        this.removeTentative();\n        IModelApp.accuSnap.synchSnapMode();\n        this.setCurrSnap(undefined);\n        this.tpHits = undefined;\n    }\n    decorate(context) {\n        const viewport = context.viewport;\n        if (!this.isActive || !viewport)\n            return;\n        const tpSize = Math.floor(viewport.pixelsPerInch * 0.4) + 0.5;\n        const toSizeOutline = tpSize + 1;\n        const position = context.viewport.worldToView(this._point);\n        position.x = Math.floor(position.x) + 0.5;\n        position.y = Math.floor(position.y) + 0.5;\n        const drawDecoration = (ctx) => {\n            ctx.beginPath();\n            ctx.strokeStyle = \"rgba(0,0,0,.5)\";\n            ctx.lineWidth = 3;\n            ctx.moveTo(-toSizeOutline, 0);\n            ctx.lineTo(toSizeOutline, 0);\n            ctx.moveTo(0, -toSizeOutline);\n            ctx.lineTo(0, toSizeOutline);\n            ctx.stroke();\n            ctx.beginPath();\n            ctx.strokeStyle = \"white\";\n            ctx.lineWidth = 1;\n            if (!this.isSnapped)\n                ctx.setLineDash([4, 1]);\n            ctx.shadowColor = \"black\";\n            ctx.shadowBlur = 5;\n            ctx.moveTo(-tpSize, 0);\n            ctx.lineTo(tpSize, 0);\n            ctx.moveTo(0, -tpSize);\n            ctx.lineTo(0, tpSize);\n            ctx.stroke();\n        };\n        context.addCanvasDecoration({ position, drawDecoration });\n    }\n    async getSnap(newSearch) {\n        // Use next hit from previous search when using tentative to cycle through hits...\n        let thisHit = (!newSearch && undefined !== this.tpHits ? this.tpHits.getNextHit() : undefined);\n        // Use existing AccuSnap hit list if one exists...\n        if (undefined === thisHit) {\n            this.tpHits = undefined;\n            thisHit = IModelApp.accuSnap.getHitAndList(this);\n        }\n        if (undefined === thisHit) {\n            // search for elements around the current raw point (search should not be affected by locks!)\n            const aperture = (2.0 * this.viewport.pixelsFromInches(IModelApp.locateManager.apertureInches) / 2.0) + 1.5;\n            const options = IModelApp.locateManager.options.clone(); // Copy to avoid changing out from under active Tool...\n            const picker = IModelApp.locateManager.picker;\n            options.hitSource = HitSource.TentativeSnap;\n            if (0 === picker.doPick(this.viewport, this._rawPoint, aperture, options))\n                return undefined;\n            this.tpHits = picker.getHitList(true);\n            thisHit = (undefined !== this.tpHits ? this.tpHits.getNextHit() : undefined);\n        }\n        else if (thisHit instanceof SnapDetail) {\n            // Make the current AccuSnap the TentativePoint snap...\n            return thisHit;\n        }\n        if (undefined === thisHit)\n            return undefined;\n        const snapModes = IModelApp.accuSnap.getActiveSnapModes(); // Get the list of point snap modes to consider\n        if (1 === snapModes.length && SnapMode.Intersection === snapModes[0])\n            snapModes.push(SnapMode.Nearest); // Add nearest when doing intersection by itself to support finding extended intersections...\n        const thisSnap = await AccuSnap.requestSnap(thisHit, snapModes, this._hotDistanceInches, IModelApp.accuSnap.keypointDivisor, this.tpHits);\n        if (undefined !== thisSnap)\n            IModelApp.accuDraw.onSnap(thisSnap); // AccuDraw can adjust nearest snap to intersection of circle (polar distance lock) or line (axis lock) with snapped to curve...\n        return thisSnap;\n    }\n    static arePointsCloseEnough(pt1, pt2, pixelDistance) { return pt1.distance(pt2) < (pixelDistance + 1.5); }\n    process(ev) {\n        if (undefined !== this._tentativePromise)\n            return;\n        const currTool = IModelApp.toolAdmin.viewTool;\n        if (currTool && currTool.inDynamicUpdate)\n            return; // trying to tentative snap while view is changing isn't useful...\n        const wasActive = this.isActive;\n        this.removeTentative(); // remove the TP cross if it is already on the screen\n        const lastPtView = this._viewPoint.clone();\n        this.viewport = ev.viewport;\n        this._point.setFrom(ev.point);\n        this._rawPoint.setFrom(ev.rawPoint);\n        this._viewPoint.setFrom(ev.viewPoint);\n        const newSearch = (!this.isSnapped || !TentativePoint.arePointsCloseEnough(lastPtView, this._viewPoint, this.viewport.pixelsFromInches(IModelApp.locateManager.apertureInches)));\n        const promise = this.getSnap(newSearch);\n        this._tentativePromise = promise;\n        promise.then((newSnap) => {\n            // Ignore response if we're no longer interested in this tentative.\n            if (this._tentativePromise === promise) {\n                this._tentativePromise = undefined;\n                this.setCurrSnap(newSnap); // Adopt the snap as current\n                IModelApp.accuSnap.clear(); // make sure there's no AccuSnap active after a tentative point (otherwise we continually snap to it).\n                if (this.isSnapped)\n                    this._point.setFrom(this.currSnap.snapPoint);\n                else if (wasActive && newSearch)\n                    this._point.setFrom(ev.rawPoint);\n                this.showTentative(); // show the TP cross\n                if (this.isSnapped) {\n                    IModelApp.toolAdmin.adjustSnapPoint();\n                }\n                else if (IModelApp.accuDraw.isActive) {\n                    const point = this.getPoint().clone();\n                    const vp = ev.viewport;\n                    if (vp.isSnapAdjustmentRequired) {\n                        IModelApp.toolAdmin.adjustPointToACS(point, vp, false);\n                        const hit = new HitDetail({\n                            testPoint: point,\n                            viewport: vp,\n                            hitSource: HitSource.TentativeSnap,\n                            hitPoint: point,\n                            sourceId: \"\",\n                            priority: HitPriority.Unknown,\n                            distXY: 0,\n                            distFraction: 0,\n                        });\n                        const snap = new SnapDetail(hit);\n                        this.setCurrSnap(snap);\n                        IModelApp.toolAdmin.adjustSnapPoint();\n                        this.setPoint(this.getPoint());\n                    }\n                    else {\n                        IModelApp.accuDraw.adjustPoint(point, vp, false);\n                        const savePoint = point.clone();\n                        IModelApp.toolAdmin.adjustPointToGrid(point, vp);\n                        if (!point.isExactEqual(savePoint))\n                            IModelApp.accuDraw.adjustPoint(point, vp, false);\n                        this.setPoint(point);\n                    }\n                }\n                else {\n                    IModelApp.toolAdmin.adjustPoint(this.getPoint(), ev.viewport);\n                }\n                IModelApp.accuDraw.onTentative();\n                if (currTool && currTool instanceof ViewManip && currTool.viewHandles.hasHandle(ViewHandleType.TargetCenter))\n                    currTool.updateTargetCenter(); // Change target center to tentative location...\n                else\n                    IModelApp.toolAdmin.updateDynamics(undefined, undefined, true); // Don't wait for motion to update dynamics...\n            }\n        });\n    }\n}\n//# sourceMappingURL=TentativePoint.js.map",
      "start": 1693508119211,
      "end": 1693508119391,
      "sourcemaps": null
    }
  ]
}
