{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/geometry3d/PolygonOps.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module CartesianGeometry\n */\nimport { assert } from \"@itwin/core-bentley\";\nimport { AxisOrder, Geometry, PolygonLocation } from \"../Geometry\";\nimport { Matrix4d } from \"../geometry4d/Matrix4d\";\nimport { Point4d } from \"../geometry4d/Point4d\";\nimport { XYParitySearchContext } from \"../topology/XYParitySearchContext\";\nimport { FrameBuilder } from \"./FrameBuilder\";\nimport { GrowableXYZArray } from \"./GrowableXYZArray\";\nimport { IndexedXYZCollection } from \"./IndexedXYZCollection\";\nimport { Matrix3d } from \"./Matrix3d\";\nimport { Plane3dByOriginAndUnitNormal } from \"./Plane3dByOriginAndUnitNormal\";\nimport { Point2d, Vector2d } from \"./Point2dVector2d\";\nimport { Point3dArrayCarrier } from \"./Point3dArrayCarrier\";\nimport { Point3d, Vector3d } from \"./Point3dVector3d\";\nimport { Ray3d } from \"./Ray3d\";\nimport { SortablePolygon } from \"./SortablePolygon\";\n/**\n * Carries data about a point in the plane of a polygon.\n * @public\n */\nexport class PolygonLocationDetail {\n    constructor() {\n        this.point = new Point3d();\n        this.a = 0.0;\n        this.v = new Vector3d();\n        this.code = PolygonLocation.Unknown;\n        this.closestEdgeIndex = 0;\n        this.closestEdgeParam = 0.0;\n    }\n    /** Invalidate this detail. */\n    invalidate() {\n        this.point.setZero();\n        this.a = 0.0;\n        this.v.setZero();\n        this.code = PolygonLocation.Unknown;\n        this.closestEdgeIndex = 0;\n        this.closestEdgeParam = 0.0;\n    }\n    /** Create an invalid detail.\n     * @param result optional pre-allocated object to fill and return\n     */\n    static create(result) {\n        if (undefined === result)\n            result = new PolygonLocationDetail();\n        else\n            result.invalidate();\n        return result;\n    }\n    /** Set the instance contents from the other detail.\n     * @param other detail to clone\n     */\n    copyContentsFrom(other) {\n        this.point.setFrom(other.point);\n        this.a = other.a;\n        this.v.setFrom(other.v);\n        this.code = other.code;\n        this.closestEdgeIndex = other.closestEdgeIndex;\n        this.closestEdgeParam = other.closestEdgeParam;\n    }\n    /** Whether this detail is valid. */\n    get isValid() {\n        return this.code !== PolygonLocation.Unknown;\n    }\n    /** Whether this instance specifies a location inside or on the polygon. */\n    get isInsideOrOn() {\n        return this.code === PolygonLocation.InsidePolygon ||\n            this.code === PolygonLocation.OnPolygonVertex || this.code === PolygonLocation.OnPolygonEdgeInterior ||\n            this.code === PolygonLocation.InsidePolygonProjectsToVertex || this.code === PolygonLocation.InsidePolygonProjectsToEdgeInterior;\n    }\n}\n/**\n * Carrier for a loop extracted from clip operation, annotated for sorting\n * @internal\n */\nexport class CutLoop {\n    constructor(xyz) {\n        this.xyz = xyz;\n        this.edge = undefined;\n        this.sortCoordinate0 = this.sortCoordinate1 = 0;\n        this.sortDelta = 0;\n        this.isNotch = false;\n    }\n    /**\n     * Create a `CutLoop` structure annotated with the vector from last point to first.\n     * @param xyz coordinates to capture\n     */\n    static createCaptureWithReturnEdge(xyz) {\n        const result = new CutLoop(xyz);\n        if (xyz.length >= 2)\n            result.edge = Ray3d.createStartEnd(xyz.front(), xyz.back());\n        return result;\n    }\n    /**\n     * Set up coordinates for sort steps:\n     * * Make `sortCoordinate0` and `sortCoordinate` the (algebraically sorted) start and end fractions along the ray\n     * * Make `sortDelta` the oriented difference of those two\n     * * Hence sorting on the coordinates puts loops in left-to-right order by the their edge vector leftmost point.\n     */\n    setSortCoordinates(ray) {\n        this.sortDelta = this.edge.direction.dotProduct(ray.direction);\n        const a = ray.dotProductToPoint(this.edge.origin);\n        if (this.sortDelta >= 0) {\n            this.sortCoordinate0 = a;\n            this.sortCoordinate1 = a + this.sortDelta;\n        }\n        else {\n            this.sortCoordinate0 = a + this.sortDelta; // and sortDelta is negative !!!\n            this.sortCoordinate1 = a;\n        }\n    }\n    /** Return\n     * * 0 if other sort limits are not strictly contained in this.\n     * * 1 if other sort limits are strictly contained with same direction\n     * * -1 if other sort limits are strictly contained in opposite direction.\n     */\n    containsSortLimits(other) {\n        if (other.sortCoordinate0 >= this.sortCoordinate1\n            || other.sortCoordinate0 <= this.sortCoordinate0\n            || other.sortCoordinate1 <= this.sortCoordinate0\n            || other.sortCoordinate1 >= this.sortCoordinate1)\n            return 0;\n        return this.sortDelta * other.sortDelta > 0 ? 1 : -1;\n    }\n    /**\n     * * push coordinates from other onto this\n     * * reset this.sortCoordinate0 to other.sortCoordinate1\n     * @param other new coordinates\n     */\n    absorb(other) {\n        this.xyz.pushFromGrowableXYZArray(other.xyz);\n        this.sortCoordinate0 = other.sortCoordinate1;\n    }\n    /** Comparison function for system sort function applied to an array of CutLoop .... */\n    static sortFunction(loopA, loopB) {\n        const q = loopA.sortCoordinate0 - loopB.sortCoordinate0;\n        return q > 0 ? 1 : -1;\n    }\n    /** Return first point coordinates.\n     * * For type checking, assume array is not empty.\n     */\n    front(result) { return this.xyz.front(result); }\n    /** Return last point coordinates.\n     * * For type checking, assume array is not empty.\n     */\n    back(result) { return this.xyz.back(result); }\n}\n/**\n * Context to hold an array of input loops and apply sort logic.\n * * This is used when a non-convex face is clipped by a plane\n * *  Simple convex clip logic in this case generates double-back edges that need to be eliminated.\n * * This class manages the elimination.\n * * Usage pattern is:\n * @internal\n */\nexport class CutLoopMergeContext {\n    // Initialize with empty loop arrays.\n    constructor() {\n        this.inputLoops = [];\n        this.outputLoops = [];\n    }\n    /**\n     *  * Search all start and end points for the one most distant from point0.\n     */\n    mostDistantPoint(point0, workPoint, resultPoint) {\n        let dMax = -1.0;\n        resultPoint.setZero();\n        let d;\n        for (const loop of this.inputLoops) {\n            loop.front(workPoint);\n            d = workPoint.distanceSquared(point0);\n            if (d > dMax) {\n                dMax = d;\n                resultPoint.setFromPoint3d(workPoint);\n            }\n            loop.back(workPoint);\n            d = workPoint.distanceSquared(point0);\n            if (d > dMax) {\n                dMax = d;\n                resultPoint.setFromPoint3d(workPoint);\n            }\n        }\n    }\n    /**\n     * * Find a long (probably longest) edge through start and end points of inputs.\n     * * Setup sortCoordinate0 and sortCoordinate1 along that edge for each loop\n     * * sort all inputLoop members by sortCoordinate0.\n     */\n    sortInputs() {\n        if (this.inputLoops.length > 0 && this.inputLoops[0].xyz.length > 0) {\n            const point0 = this.inputLoops[0].xyz.front();\n            const workPoint = Point3d.create();\n            const point1 = Point3d.create();\n            // point0 could be in the middle.   Find the most distant point ...\n            this.mostDistantPoint(point0, workPoint, point1);\n            // And again from point1 to get to the other extreme .  .\n            this.mostDistantPoint(point1, workPoint, point0);\n            const sortRay = Ray3d.createStartEnd(point0, point1);\n            sortRay.direction.normalizeInPlace();\n            for (const loop of this.inputLoops)\n                loop.setSortCoordinates(sortRay);\n            this.inputLoops.sort((loopA, loopB) => CutLoop.sortFunction(loopA, loopB));\n        }\n    }\n    /**\n     * * sort all input loops by coordinate along the cut edge\n     * * sweep left to right, using start and end coordinates to decide if loops are outer or hole, and combine holes into their containing outer loops.\n     */\n    sortAndMergeLoops() {\n        this.sortInputs();\n        const inputs = this.inputLoops;\n        const outputs = this.outputLoops;\n        const stack = [];\n        outputs.length = 0;\n        for (const candidate of inputs) {\n            candidate.isNotch = false;\n            // candidate must be either (a) absorbed in to of stack or (b) pushed onto stack.\n            // If pushed, must have indication of natch state.\n            for (; stack.length > 0;) {\n                const topOfStack = stack[stack.length - 1];\n                const containment = topOfStack.containsSortLimits(candidate);\n                if (containment === 0) {\n                    if (!topOfStack.isNotch)\n                        outputs.push(topOfStack);\n                    stack.pop();\n                    continue; // a larger topOfStack may have appeared !\n                    candidate.isNotch = false;\n                }\n                else if (containment === 1) {\n                    candidate.isNotch = false;\n                    break;\n                }\n                else {\n                    topOfStack.absorb(candidate);\n                    candidate.isNotch = true;\n                    break;\n                }\n            }\n            stack.push(candidate);\n        }\n        // Anything on stack must be complete ...\n        for (const p of stack) {\n            if (!p.isNotch)\n                outputs.push(p);\n        }\n    }\n}\n/**\n * Various static methods to perform computations on an array of points interpreted as a polygon.\n * @public\n */\nclass PolygonOps {\n    /** Sum areas of triangles from points[0] to each far edge.\n     * * Consider triangles from points[0] to each edge.\n     * * Sum the absolute areas (without regard to orientation) all these triangles.\n     * @returns sum of absolute triangle areas.\n     */\n    static sumTriangleAreas(points) {\n        let s = 0;\n        const n = points.length;\n        if (Array.isArray(points)) {\n            if (n >= 3) {\n                const origin = points[0];\n                const vector0 = origin.vectorTo(points[1]);\n                let vector1 = Vector3d.create();\n                // This will work with or without closure edge.  If closure is given, the last vector is 000.\n                for (let i = 2; i < n; i++) {\n                    vector1 = origin.vectorTo(points[i], vector1);\n                    s += vector0.crossProductMagnitude(vector1);\n                    vector0.setFrom(vector1);\n                }\n            }\n            return s * 0.5;\n        }\n        const crossVector = Vector3d.create();\n        for (let i = 2; i < n; i++) {\n            points.crossProductIndexIndexIndex(0, i - 1, i, crossVector);\n            s += crossVector.magnitude();\n        }\n        return s * 0.5;\n    }\n    /** Sum areas of triangles from points[0] to each far edge, as viewed with upVector pointing up.\n     * * Consider triangles from points[0] to each edge.\n     * * Sum the areas perpendicular to the upVector.\n     * * If the upVector is near-zero length, a simple z vector is used.\n     * @returns sum of triangle areas.\n     */\n    static sumTriangleAreasPerpendicularToUpVector(points, upVector) {\n        let scale = upVector.magnitude();\n        if (scale < Geometry.smallMetricDistance) {\n            upVector = Vector3d.create(0, 0, 1);\n            scale = 1.0;\n        }\n        let s = 0;\n        const n = points.length;\n        if (Array.isArray(points)) {\n            if (n >= 3) {\n                const origin = points[0];\n                const vector0 = origin.vectorTo(points[1]);\n                let vector1 = Vector3d.create();\n                // This will work with or without closure edge.  If closure is given, the last vector is 000.\n                for (let i = 2; i < n; i++) {\n                    vector1 = origin.vectorTo(points[i], vector1);\n                    s += vector0.tripleProduct(vector1, upVector);\n                    vector0.setFrom(vector1);\n                }\n            }\n            return s * 0.5 / scale;\n        }\n        const crossVector = Vector3d.create();\n        for (let i = 2; i < n; i++) {\n            points.crossProductIndexIndexIndex(0, i - 1, i, crossVector);\n            s += crossVector.dotProduct(upVector);\n        }\n        return s * 0.5 / scale;\n    }\n    /** Sum areas of triangles from points[0] to each far edge.\n     * * Consider triangles from points[0] to each edge.\n     * * Sum the signed areas of all these triangles. (An area can be negative at a concave corner.)\n     * @returns sum of signed triangle areas.\n     */\n    static sumTriangleAreasXY(points) {\n        let s = 0.0;\n        const n = points.length;\n        if (n >= 3) {\n            const origin = points[0];\n            const vector0 = origin.vectorTo(points[1]);\n            let vector1 = Vector3d.create();\n            // This will work with or without closure edge.  If closure is given, the last vector is 000.\n            for (let i = 2; i < n; i++) {\n                vector1 = origin.vectorTo(points[i], vector1);\n                s += vector0.crossProductXY(vector1);\n                vector0.setFrom(vector1);\n            }\n        }\n        s *= 0.5;\n        // GeometryCoreTestIO.consoleLog(\"polygon area \", s, points);\n        return s;\n    }\n    /** return a vector which is perpendicular to the polygon and has magnitude equal to the polygon area. */\n    static areaNormalGo(points, result) {\n        if (!result)\n            result = new Vector3d();\n        else\n            result.setZero();\n        const n = points.length;\n        if (n === 3) {\n            points.crossProductIndexIndexIndex(0, 1, 2, result);\n        }\n        else if (n > 3) {\n            // This will work with or without closure edge.  If closure is given, the last vector is 000.\n            for (let i = 2; i < n; i++) {\n                points.accumulateCrossProductIndexIndexIndex(0, i - 1, i, result);\n            }\n        }\n        // ALL BRANCHES SUM FULL CROSS PRODUCTS AND EXPECT SCALE HERE\n        result.scaleInPlace(0.5);\n        return result.isZero ? undefined : result;\n    }\n    /** return a vector which is perpendicular to the polygon and has magnitude equal to the polygon area. */\n    static areaNormal(points, result) {\n        if (!result)\n            result = Vector3d.create();\n        PolygonOps.areaNormalGo(new Point3dArrayCarrier(points), result);\n        return result;\n    }\n    /** return the area of the polygon.\n     * * This assumes the polygon is planar\n     * * This does NOT assume the polygon is on the xy plane.\n     */\n    static area(points) {\n        return PolygonOps.areaNormal(points).magnitude();\n    }\n    /** return the projected XY area of the polygon. */\n    static areaXY(points) {\n        let area = 0.0;\n        if (points instanceof IndexedXYZCollection) {\n            if (points.length > 2) {\n                const x0 = points.getXAtUncheckedPointIndex(0);\n                const y0 = points.getYAtUncheckedPointIndex(0);\n                let u1 = points.getXAtUncheckedPointIndex(1) - x0;\n                let v1 = points.getYAtUncheckedPointIndex(1) - y0;\n                let u2, v2;\n                for (let i = 1; i + 1 < points.length; i++, u1 = u2, v1 = v2) {\n                    u2 = points.getXAtUncheckedPointIndex(i) - x0;\n                    v2 = points.getYAtUncheckedPointIndex(i) - y0;\n                    area += Geometry.crossProductXYXY(u1, v1, u2, v2);\n                }\n            }\n        }\n        else {\n            for (let i = 1; i + 1 < points.length; i++)\n                area += points[0].crossProductToPointsXY(points[i], points[i + 1]);\n        }\n        return 0.5 * area;\n    }\n    /** Sum the areaXY () values for multiple polygons */\n    static sumAreaXY(polygons) {\n        let s = 0.0;\n        for (const p of polygons)\n            s += this.areaXY(p);\n        return s;\n    }\n    /**\n     * Return a Ray3d with (assuming the polygon is planar and not self-intersecting)\n     * * origin at the centroid of the (3D) polygon\n     * * normal is a unit vector perpendicular to the plane\n     * * 'a' member is the area.\n     * @param points\n     */\n    static centroidAreaNormal(points) {\n        if (Array.isArray(points)) {\n            const carrier = new Point3dArrayCarrier(points);\n            return this.centroidAreaNormal(carrier);\n        }\n        const n = points.length;\n        if (n === 3) {\n            const normal = points.crossProductIndexIndexIndex(0, 1, 2);\n            const a = 0.5 * normal.magnitude();\n            const centroid = points.getPoint3dAtCheckedPointIndex(0);\n            points.accumulateScaledXYZ(1, 1.0, centroid);\n            points.accumulateScaledXYZ(2, 1.0, centroid);\n            centroid.scaleInPlace(1.0 / 3.0);\n            const result = Ray3d.createCapture(centroid, normal);\n            if (result.tryNormalizeInPlaceWithAreaWeight(a))\n                return result;\n            return undefined;\n        }\n        if (n >= 3) {\n            const areaNormal = Vector3d.createZero();\n            // This will work with or without closure edge.  If closure is given, the last vector is 000.\n            for (let i = 2; i < n; i++) {\n                points.accumulateCrossProductIndexIndexIndex(0, i - 1, i, areaNormal);\n            }\n            areaNormal.normalizeInPlace();\n            const origin = points.getPoint3dAtCheckedPointIndex(0);\n            const vector0 = Vector3d.create();\n            const vector1 = Vector3d.create();\n            points.vectorXYAndZIndex(origin, 1, vector0);\n            let cross = Vector3d.create();\n            const centroidSum = Vector3d.createZero();\n            const normalSum = Vector3d.createZero();\n            let signedTriangleArea;\n            // This will work with or without closure edge.  If closure is given, the last vector is 000.\n            for (let i = 2; i < n; i++) {\n                points.vectorXYAndZIndex(origin, i, vector1);\n                cross = vector0.crossProduct(vector1, cross);\n                signedTriangleArea = areaNormal.dotProduct(cross); // well, actually twice the area.\n                normalSum.addInPlace(cross); // this grows to twice the area\n                const b = signedTriangleArea / 6.0;\n                centroidSum.plus2Scaled(vector0, b, vector1, b, centroidSum);\n                vector0.setFrom(vector1);\n            }\n            const area = 0.5 * normalSum.magnitude();\n            const inverseArea = Geometry.conditionalDivideFraction(1, area);\n            if (inverseArea !== undefined) {\n                const result = Ray3d.createCapture(origin.plusScaled(centroidSum, inverseArea), normalSum);\n                result.tryNormalizeInPlaceWithAreaWeight(area);\n                return result;\n            }\n        }\n        return undefined;\n    }\n    // Has the potential to be combined with centroidAreaNormal for point3d array and Ray3d return listed above...\n    // Returns undefined if given point array less than 3 or if not safe to divide at any point\n    /**\n     * * Return (in caller-allocated centroid) the centroid of the xy polygon.\n     * * Return (as function value)  the area\n     */\n    static centroidAndAreaXY(points, centroid) {\n        let area = 0.0;\n        centroid.set(0, 0);\n        if (points.length < 3)\n            return undefined;\n        const origin = points[0];\n        let vectorSum = Vector2d.create(0, 0); // == sum ((U+V)/3) * (U CROSS V)/2 -- but leave out divisions\n        let areaSum = 0.0; // == sum (U CROSS V) / 2 -- but leave out divisions\n        for (let i = 1; i + 1 < points.length; i++) {\n            const vector0 = origin.vectorTo(points[i]);\n            const vector1 = origin.vectorTo(points[i + 1]);\n            const tempArea = vector0.crossProduct(vector1);\n            vectorSum = vectorSum.plus(vector0.plus(vector1).scale(tempArea));\n            areaSum += tempArea;\n        }\n        area = areaSum * 0.5;\n        const a = Geometry.conditionalDivideFraction(1.0, 6.0 * area);\n        if (a === undefined) {\n            centroid.setFrom(origin);\n            return undefined;\n        }\n        centroid.setFrom(origin.plusScaled(vectorSum, a));\n        return area;\n    }\n    /**\n     * Return a unit normal to the plane of the polygon.\n     * @param points array of points around the polygon.\n     * @param result caller-allocated result vector.\n     * @return true if and only if result has unit length\n     */\n    static unitNormal(points, result) {\n        result.setZero();\n        let n = points.length;\n        if (n > 1 && points.getPoint3dAtUncheckedPointIndex(0).isExactEqual(points.getPoint3dAtUncheckedPointIndex(n - 1)))\n            --n; // ignore closure point\n        if (n === 3) {\n            points.crossProductIndexIndexIndex(0, 1, 2, result);\n            return result.normalizeInPlace();\n        }\n        if (n === 4) {\n            // cross product of diagonals is more stable than from single of the points . . .\n            points.vectorIndexIndex(0, 2, PolygonOps._vector0);\n            points.vectorIndexIndex(1, 3, PolygonOps._vector1);\n            PolygonOps._vector0.crossProduct(PolygonOps._vector1, result);\n            return result.normalizeInPlace();\n        }\n        // more than 4 points  ... no shortcuts ...\n        PolygonOps.areaNormalGo(points, result);\n        return result.normalizeInPlace();\n    }\n    /** Accumulate to the matrix of area products of a polygon with respect to an origin.\n     * The polygon is assumed to be planar and non-self-intersecting.\n     */\n    /** Accumulate to the matrix of area products of a polygon with respect to an origin.\n     * * The polygon is assumed to be planar and non-self-intersecting.\n     * * Accumulated values are integrals over triangles from point 0 of the polygon to other edges of the polygon.\n     * * Integral over each triangle is transformed to integrals from the given origin.\n     * @param points array of points around the polygon.   Final closure point is not needed.\n     * @param origin origin for global accumulation.\n     * @param moments 4x4 matrix where products are accumulated.\n     */\n    static addSecondMomentAreaProducts(points, origin, moments) {\n        this.addSecondMomentTransformedProducts(PolygonOps._triangleMomentWeights, points, origin, 2, moments);\n    }\n    /** Accumulate to the matrix of volume products of a polygon with respect to an origin.\n     * * The polygon is assumed to be planar and non-self-intersecting.\n     * * Accumulated values are integrals over tetrahedra from the origin to triangles on the polygon.\n     * @param points array of points around the polygon.   Final closure point is not needed.\n     * @param origin origin for tetrahedra\n     * @param moments 4x4 matrix where products are accumulated.\n     */\n    static addSecondMomentVolumeProducts(points, origin, moments) {\n        this.addSecondMomentTransformedProducts(PolygonOps._tetrahedralMomentWeights, points, origin, 3, moments);\n    }\n    /** Return the matrix of area products of a polygon with respect to an origin.\n     * The polygon is assumed to be planar and non-self-intersecting.\n     * * `frameType===2` has xy vectors in the plane of the polygon, plus a unit normal z. (Used for area integrals)\n     * * `frameType===3` has vectors from origin to 3 points in the triangle. (Used for volume integrals)\n     */\n    static addSecondMomentTransformedProducts(firstQuadrantMoments, points, origin, frameType, moments) {\n        const unitNormal = PolygonOps._normal;\n        if (PolygonOps.unitNormal(points, unitNormal)) {\n            // The direction of the normal makes the various detJ values positive or negative so that non-convex polygons\n            // sum correctly.\n            const vector01 = PolygonOps._vector0;\n            const vector02 = PolygonOps._vector1;\n            const vector03 = PolygonOps._vector2;\n            const placement = PolygonOps._matrixA;\n            const matrixAB = PolygonOps._matrixB;\n            const matrixABC = PolygonOps._matrixC;\n            const vectorOrigin = points.vectorXYAndZIndex(origin, 0, PolygonOps._vectorOrigin);\n            const numPoints = points.length;\n            let detJ = 0;\n            for (let i2 = 2; i2 < numPoints; i2++) {\n                if (frameType === 2) {\n                    points.vectorIndexIndex(0, i2 - 1, vector01);\n                    points.vectorIndexIndex(0, i2, vector02);\n                    detJ = unitNormal.tripleProduct(vector01, vector02);\n                    placement.setOriginAndVectors(vectorOrigin, vector01, vector02, unitNormal);\n                    placement.multiplyMatrixMatrix(firstQuadrantMoments, matrixAB);\n                    matrixAB.multiplyMatrixMatrixTranspose(placement, matrixABC);\n                    moments.addScaledInPlace(matrixABC, detJ);\n                }\n                else if (frameType === 3) {\n                    points.vectorXYAndZIndex(origin, 0, vector01);\n                    points.vectorXYAndZIndex(origin, i2 - 1, vector02);\n                    points.vectorXYAndZIndex(origin, i2, vector03);\n                    detJ = vector01.tripleProduct(vector02, vector03);\n                    placement.setOriginAndVectors(origin, vector01, vector02, vector03);\n                    placement.multiplyMatrixMatrix(firstQuadrantMoments, matrixAB);\n                    matrixAB.multiplyMatrixMatrixTranspose(placement, matrixABC);\n                    moments.addScaledInPlace(matrixABC, detJ);\n                }\n            }\n        }\n    }\n    /** Test the direction of turn at the vertices of the polygon, ignoring z-coordinates.\n     * * For a polygon without self-intersections and successive colinear edges, this is a convexity and orientation test: all positive is convex and counterclockwise, all negative is convex and clockwise.\n     * * Beware that a polygon which turns through more than a full turn can cross itself and close, but is not convex.\n     * @returns 1 if all turns are to the left, -1 if all to the right, and 0 if there are any zero or reverse turns\n     */\n    static testXYPolygonTurningDirections(points) {\n        // Reduce count by trailing duplicates; leaves iLast at final index\n        let numPoint = points.length;\n        let iLast = numPoint - 1;\n        while (iLast > 1 && points[iLast].x === points[0].x && points[iLast].y === points[0].y) {\n            numPoint = iLast--;\n        }\n        if (numPoint > 2) {\n            let vector0 = Point2d.create(points[iLast].x - points[iLast - 1].x, points[iLast].y - points[iLast - 1].y);\n            const vector1 = Point2d.create(points[0].x - points[iLast].x, points[0].y - points[iLast].y);\n            const baseArea = vector0.x * vector1.y - vector0.y * vector1.x;\n            // In a convex polygon, all successive-vector cross products will\n            // have the same sign as the base area, hence all products will be\n            // positive.\n            for (let i1 = 1; i1 < numPoint; i1++) {\n                vector0 = vector1.clone();\n                Point2d.create(points[i1].x - points[i1 - 1].x, points[i1].y - points[i1 - 1].y, vector1);\n                const currArea = vector0.x * vector1.y - vector0.y * vector1.x;\n                if (currArea * baseArea <= 0.0)\n                    return 0;\n            }\n            // Fall out with all signs same as base area\n            return baseArea > 0.0 ? 1 : -1;\n        }\n        return 0;\n    }\n    /**\n     * Determine whether the polygon is convex.\n     * @param polygon vertices, closure point optional\n     * @returns whether the polygon is convex.\n     */\n    static isConvex(polygon) {\n        if (!(polygon instanceof IndexedXYZCollection))\n            return this.isConvex(new Point3dArrayCarrier(polygon));\n        let n = polygon.length;\n        if (n > 1 && polygon.getPoint3dAtUncheckedPointIndex(0).isExactEqual(polygon.getPoint3dAtUncheckedPointIndex(n - 1)))\n            --n; // ignore closure point\n        const normal = Vector3d.create();\n        if (!this.unitNormal(polygon, normal))\n            return false;\n        let positiveArea = 0.0;\n        let negativeArea = 0.0;\n        const vecA = this._vector0;\n        let vecB = Vector3d.createStartEnd(polygon.getPoint3dAtUncheckedPointIndex(n - 1), polygon.getPoint3dAtUncheckedPointIndex(0), this._vector1);\n        for (let i = 1; i <= n; i++) {\n            // check turn through vertices i-1,i,i+1\n            vecA.setFromVector3d(vecB);\n            vecB = Vector3d.createStartEnd(polygon.getPoint3dAtUncheckedPointIndex(i - 1), polygon.getPoint3dAtUncheckedPointIndex(i % n), vecB);\n            const signedArea = normal.tripleProduct(vecA, vecB);\n            if (signedArea >= 0.0)\n                positiveArea += signedArea;\n            else\n                negativeArea += signedArea;\n        }\n        return Math.abs(negativeArea) < Geometry.smallMetricDistanceSquared * positiveArea;\n    }\n    /**\n     * Test if point (x,y) is IN, OUT or ON a polygon.\n     * @return (1) for in, (-1) for OUT, (0) for ON\n     * @param x x coordinate\n     * @param y y coordinate\n     * @param points array of xy coordinates.\n     */\n    static classifyPointInPolygon(x, y, points) {\n        const context = new XYParitySearchContext(x, y);\n        let i0 = 0;\n        const n = points.length;\n        let i1;\n        let iLast = -1;\n        // walk to an acceptable start index ...\n        for (i0 = 0; i0 < n; i0++) {\n            i1 = i0 + 1;\n            if (i1 >= n)\n                i1 = 0;\n            if (context.tryStartEdge(points[i0].x, points[i0].y, points[i1].x, points[i1].y)) {\n                iLast = i1;\n                break;\n            }\n        }\n        if (iLast < 0)\n            return undefined;\n        for (let i = 1; i <= n; i++) {\n            i1 = iLast + i;\n            if (i1 >= n)\n                i1 -= n;\n            if (!context.advance(points[i1].x, points[i1].y))\n                return context.classifyCounts();\n        }\n        return context.classifyCounts();\n    }\n    /**\n     * Test if point (x,y) is IN, OUT or ON a polygon.\n     * @return (1) for in, (-1) for OUT, (0) for ON\n     * @param x x coordinate\n     * @param y y coordinate\n     * @param points array of xy coordinates.\n     */\n    static classifyPointInPolygonXY(x, y, points) {\n        const context = new XYParitySearchContext(x, y);\n        let i0 = 0;\n        const n = points.length;\n        let i1;\n        let iLast = -1;\n        // walk to an acceptable start index ...\n        for (i0 = 0; i0 < n; i0++) {\n            i1 = i0 + 1;\n            if (i1 >= n)\n                i1 = 0;\n            if (context.tryStartEdge(points.getXAtUncheckedPointIndex(i0), points.getYAtUncheckedPointIndex(i0), points.getXAtUncheckedPointIndex(i1), points.getYAtUncheckedPointIndex(i1))) {\n                iLast = i1;\n                break;\n            }\n        }\n        if (iLast < 0)\n            return undefined;\n        for (let i = 1; i <= n; i++) {\n            i1 = iLast + i;\n            if (i1 >= n)\n                i1 -= n;\n            if (!context.advance(points.getXAtUncheckedPointIndex(i1), points.getYAtUncheckedPointIndex(i1)))\n                return context.classifyCounts();\n        }\n        return context.classifyCounts();\n    }\n    /**\n     * Reverse loops as necessary to make them all have CCW orientation for given outward normal.\n     * @param loops\n     * @param outwardNormal\n     * @return the number of loops reversed.\n     */\n    static orientLoopsCCWForOutwardNormalInPlace(loops, outwardNormal) {\n        if (loops instanceof IndexedXYZCollection)\n            return this.orientLoopsCCWForOutwardNormalInPlace([loops], outwardNormal);\n        const orientations = [];\n        const unitNormal = Vector3d.create();\n        // orient individually ... (no hole analysis)\n        let numReverse = 0;\n        for (const loop of loops) {\n            if (this.unitNormal(loop, unitNormal)) {\n                const q = unitNormal.dotProduct(outwardNormal);\n                orientations.push(q);\n                if (q <= 0.0)\n                    loop.reverseInPlace();\n                numReverse++;\n            }\n            else {\n                orientations.push(0.0);\n            }\n        }\n        return numReverse;\n    }\n    /**\n     * Reverse and reorder loops in the xy-plane for consistency and containment.\n     * @param loops multiple polygons in any order and orientation, z-coordinates ignored\n     * @returns array of arrays of polygons that capture the input pointers. In each first level array:\n     * * The first polygon is an outer loop, oriented counterclockwise.\n     * * Any subsequent polygons are holes of the outer loop, oriented clockwise.\n     * @see [[RegionOps.sortOuterAndHoleLoopsXY]]\n     */\n    static sortOuterAndHoleLoopsXY(loops) {\n        const loopAndArea = [];\n        for (const loop of loops) {\n            SortablePolygon.pushPolygon(loopAndArea, loop);\n        }\n        return SortablePolygon.sortAsArrayOfArrayOfPolygons(loopAndArea);\n    }\n    /**\n     * Exactly like `sortOuterAndHoleLoopsXY` but allows loops in any plane.\n     * @param loops multiple loops to sort and reverse.\n     * @param defaultNormal optional normal for the loops, if known\n     * @see [[sortOuterAndHoleLoopsXY]]\n     */\n    static sortOuterAndHoleLoops(loops, defaultNormal) {\n        const localToWorld = FrameBuilder.createRightHandedFrame(defaultNormal, loops);\n        const worldToLocal = localToWorld?.inverse();\n        const xyLoops = [];\n        if (worldToLocal !== undefined) {\n            // transform into plane so we can ignore z in the sort\n            for (const loop of loops) {\n                const xyLoop = new GrowableXYZArray(loop.length);\n                for (const point of loop.points)\n                    xyLoop.push(worldToLocal.multiplyPoint3d(point));\n                xyLoops.push(xyLoop);\n            }\n        }\n        const xySortedLoopsArray = PolygonOps.sortOuterAndHoleLoopsXY(xyLoops);\n        const sortedLoopsArray = [];\n        if (localToWorld !== undefined) {\n            for (const xySortedLoops of xySortedLoopsArray) {\n                const sortedLoops = [];\n                for (const xySortedLoop of xySortedLoops) {\n                    const sortedLoop = new GrowableXYZArray(xySortedLoop.length);\n                    for (const point of xySortedLoop.points)\n                        sortedLoop.push(localToWorld.multiplyPoint3d(point));\n                    sortedLoops.push(sortedLoop);\n                }\n                sortedLoopsArray.push(sortedLoops);\n            }\n        }\n        return sortedLoopsArray;\n    }\n    /** Compute the closest point on the polygon boundary to the given point.\n     * @param polygon points of the polygon, closure point optional\n     * @param testPoint point p to project onto the polygon edges. Works best when p is in the plane of the polygon.\n     * @param tolerance optional distance tolerance to determine point-vertex and point-edge coincidence.\n     * @param result optional pre-allocated object to fill and return\n     * @returns details d of the closest point `d.point`:\n     * * `d.isValid()` returns true if and only if the polygon is nontrivial.\n     * * `d.edgeIndex` and `d.edgeParam` specify the location of the closest point, within `distTol`.\n     * * `d.code` classifies the closest point as a vertex (`PolygonLocation.OnPolygonVertex`) or as a point on an edge (`PolygonLocation.OnPolygonEdgeInterior`).\n     * * `d.a` is the distance from testPoint to the closest point.\n     * * `d.v` can be used to classify p (if p and polygon are coplanar): if n is the polygon normal then `d.v.dotProduct(n)` is +/-/0 if and only if p is inside/outside/on the polygon.\n    */\n    static closestPointOnBoundary(polygon, testPoint, tolerance = Geometry.smallMetricDistance, result) {\n        if (!(polygon instanceof IndexedXYZCollection))\n            return this.closestPointOnBoundary(new Point3dArrayCarrier(polygon), testPoint, tolerance, result);\n        const distTol2 = tolerance * tolerance;\n        let numPoints = polygon.length;\n        while (numPoints > 1) {\n            if (polygon.distanceSquaredIndexIndex(0, numPoints - 1) > distTol2)\n                break;\n            --numPoints; // ignore closure point\n        }\n        result = PolygonLocationDetail.create(result);\n        if (0 === numPoints)\n            return result; // invalid\n        if (1 === numPoints) {\n            polygon.getPoint3dAtUncheckedPointIndex(0, result.point);\n            result.a = result.point.distance(testPoint);\n            result.v.setZero();\n            result.code = PolygonLocation.OnPolygonVertex;\n            result.closestEdgeIndex = 0;\n            result.closestEdgeParam = 0.0;\n            return result;\n        }\n        let iPrev = numPoints - 1;\n        let minDist2 = Geometry.largeCoordinateResult;\n        for (let iBase = 0; iBase < numPoints; ++iBase) {\n            let iNext = iBase + 1;\n            if (iNext === numPoints)\n                iNext = 0;\n            const uDotU = polygon.distanceSquaredIndexIndex(iBase, iNext);\n            if (uDotU <= distTol2)\n                continue; // ignore trivial polygon edge (keep iPrev)\n            const vDotV = polygon.distanceSquaredIndexXYAndZ(iBase, testPoint);\n            const uDotV = polygon.dotProductIndexIndexXYAndZ(iBase, iNext, testPoint);\n            const edgeParam = uDotV / uDotU; // param of projection of testPoint onto this edge\n            if (edgeParam <= 0.0) { // testPoint projects to/before edge start\n                const distToStart2 = vDotV;\n                if (distToStart2 <= distTol2) {\n                    // testPoint is at edge start; we are done\n                    polygon.getPoint3dAtUncheckedPointIndex(iBase, result.point);\n                    result.a = Math.sqrt(distToStart2);\n                    result.v.setZero();\n                    result.code = PolygonLocation.OnPolygonVertex;\n                    result.closestEdgeIndex = iBase;\n                    result.closestEdgeParam = 0.0;\n                    return result;\n                }\n                if (distToStart2 < minDist2) {\n                    if (polygon.dotProductIndexIndexXYAndZ(iBase, iPrev, testPoint) <= 0.0) {\n                        // update candidate (to edge start) only if previous edge was NOOP\n                        polygon.getPoint3dAtUncheckedPointIndex(iBase, result.point);\n                        result.a = Math.sqrt(distToStart2);\n                        polygon.crossProductIndexIndexIndex(iBase, iPrev, iNext, result.v);\n                        result.code = PolygonLocation.OnPolygonVertex;\n                        result.closestEdgeIndex = iBase;\n                        result.closestEdgeParam = 0.0;\n                        minDist2 = distToStart2;\n                    }\n                }\n            }\n            else if (edgeParam <= 1.0) { // testPoint projects inside edge, or to edge end\n                const projDist2 = vDotV - edgeParam * edgeParam * uDotU;\n                if (projDist2 <= distTol2) {\n                    // testPoint is on edge; we are done\n                    const distToStart2 = vDotV;\n                    if (edgeParam <= 0.5 && distToStart2 <= distTol2) {\n                        // testPoint is at edge start\n                        polygon.getPoint3dAtUncheckedPointIndex(iBase, result.point);\n                        result.a = Math.sqrt(distToStart2);\n                        result.v.setZero();\n                        result.code = PolygonLocation.OnPolygonVertex;\n                        result.closestEdgeIndex = iBase;\n                        result.closestEdgeParam = 0.0;\n                        return result;\n                    }\n                    const distToEnd2 = projDist2 + (1.0 - edgeParam) * (1.0 - edgeParam) * uDotU;\n                    if (edgeParam > 0.5 && distToEnd2 <= distTol2) {\n                        // testPoint is at edge end\n                        polygon.getPoint3dAtUncheckedPointIndex(iNext, result.point);\n                        result.a = Math.sqrt(distToEnd2);\n                        result.v.setZero();\n                        result.code = PolygonLocation.OnPolygonVertex;\n                        result.closestEdgeIndex = iNext;\n                        result.closestEdgeParam = 0.0;\n                        return result;\n                    }\n                    // testPoint is on edge interior\n                    polygon.interpolateIndexIndex(iBase, edgeParam, iNext, result.point);\n                    result.a = Math.sqrt(projDist2);\n                    result.v.setZero();\n                    result.code = PolygonLocation.OnPolygonEdgeInterior;\n                    result.closestEdgeIndex = iBase;\n                    result.closestEdgeParam = edgeParam;\n                    return result;\n                }\n                if (projDist2 < minDist2) {\n                    // update candidate (to edge interior)\n                    polygon.interpolateIndexIndex(iBase, edgeParam, iNext, result.point);\n                    result.a = Math.sqrt(projDist2);\n                    polygon.crossProductIndexIndexXYAndZ(iBase, iNext, testPoint, result.v);\n                    result.code = PolygonLocation.OnPolygonEdgeInterior;\n                    result.closestEdgeIndex = iBase;\n                    result.closestEdgeParam = edgeParam;\n                    minDist2 = projDist2;\n                }\n            }\n            else { // edgeParam > 1.0\n                // NOOP: testPoint projects beyond edge end, handled by next edge\n            }\n            iPrev = iBase;\n        }\n        return result;\n    }\n    /** Compute the intersection of a line (parameterized as a ray) with the plane of this polygon.\n     * @param polygon points of the polygon, closure point optional\n     * @param ray infinite line to intersect, as a ray\n     * @param tolerance optional distance tolerance to determine point-vertex and point-edge coincidence.\n     * @param result optional pre-allocated object to fill and return\n     * @returns details d of the line-plane intersection `d.point`:\n     * * `d.isValid()` returns true if and only if the line intersects the plane.\n     * * `d.code` indicates where the intersection lies with respect to the polygon.\n     * * `d.a` is the ray intersection parameter. If `d.a` >= 0, the ray intersects the plane of the polygon.\n     * * `d.edgeIndex` and `d.edgeParam` specify the location of the closest point on the polygon to the intersection, within `distTol`.\n     */\n    static intersectRay3d(polygon, ray, tolerance = Geometry.smallMetricDistance, result) {\n        if (!(polygon instanceof IndexedXYZCollection))\n            return this.intersectRay3d(new Point3dArrayCarrier(polygon), ray, tolerance, result);\n        if (!this.unitNormal(polygon, this._normal))\n            return PolygonLocationDetail.create(result); // invalid\n        this._workPlane = Plane3dByOriginAndUnitNormal.createXYZUVW(polygon.getXAtUncheckedPointIndex(0), polygon.getYAtUncheckedPointIndex(0), polygon.getZAtUncheckedPointIndex(0), this._normal.x, this._normal.y, this._normal.z, this._workPlane);\n        const intersectionPoint = Point3d.createZero(this._workXYZ);\n        const rayParam = ray.intersectionWithPlane(this._workPlane, intersectionPoint);\n        if (undefined === rayParam)\n            return PolygonLocationDetail.create(result);\n        result = this.closestPointOnBoundary(polygon, intersectionPoint, tolerance, result);\n        if (result.isValid) {\n            result.point.setFrom(intersectionPoint);\n            result.a = rayParam;\n            const dot = result.v.dotProduct(this._normal);\n            if (dot === 0.0) {\n                // NOOP: intersectionPoint is on the polygon, so result.code already classifies it\n            }\n            else {\n                // intersectionPoint is not on polygon, so result.code refers to the closest point. Update it to refer to intersectionPoint.\n                if (PolygonLocation.OnPolygonVertex === result.code)\n                    result.code = (dot > 0.0) ? PolygonLocation.InsidePolygonProjectsToVertex : PolygonLocation.OutsidePolygonProjectsToVertex;\n                else if (PolygonLocation.OnPolygonEdgeInterior === result.code)\n                    result.code = (dot > 0.0) ? PolygonLocation.InsidePolygonProjectsToEdgeInterior : PolygonLocation.OutsidePolygonProjectsToEdgeInterior;\n            }\n        }\n        return result;\n    }\n    /** Compute the intersection of a line (parameterized as a line segment) with the plane of this polygon.\n     * @param polygon points of the polygon, closure point optional\n     * @param point0 start point of segment on line to intersect\n     * @param point1 end point of segment on line to intersect\n     * @param tolerance optional distance tolerance to determine point-vertex and point-edge coincidence.\n     * @param result optional pre-allocated object to fill and return\n     * @returns details d of the line-plane intersection `d.point`:\n     * * `d.isValid()` returns true if and only if the line intersects the plane.\n     * * `d.code` indicates where the intersection lies with respect to the polygon.\n     * * `d.a` is the segment intersection parameter. If `d.a` is in [0,1], the segment intersects the plane of the polygon.\n     * * `d.edgeIndex` and `d.edgeParam` specify the location of the closest point on the polygon to the intersection, within `distTol`.\n     * @see intersectRay3d\n     */\n    static intersectSegment(polygon, point0, point1, tolerance = Geometry.smallMetricDistance, result) {\n        this._workRay = Ray3d.createStartEnd(point0, point1, this._workRay);\n        return this.intersectRay3d(polygon, this._workRay, tolerance, result);\n    }\n    /** Compute edge data for the barycentric coordinate computation, ignoring all z-coordinates.\n     * @param polygon points of the polygon (without closure point)\n     * @param edgeStartVertexIndex index of start vertex of the edge (unchecked)\n     * @param point point to project to the edge\n     * @param edgeOutwardUnitNormal pre-allocated vector to be populated on return with the unit perpendicular to the edge, facing outward, in xy-plane\n     * @param tolerance used to clamp outputs\n     * @param result optional pre-allocated result\n     * @returns x: signed projection distance of `point` to the edge, y: edge parameter of the projection\n     */\n    static computeEdgeDataXY(polygon, edgeStartVertexIndex, point, edgeOutwardUnitNormal, tolerance = Geometry.smallMetricDistance, result) {\n        const i0 = edgeStartVertexIndex % polygon.length;\n        const i1 = (i0 + 1) % polygon.length;\n        polygon.vectorIndexIndex(i0, i1, edgeOutwardUnitNormal).unitPerpendicularXY(edgeOutwardUnitNormal).negate(edgeOutwardUnitNormal); // z is zero\n        const hypDeltaX = polygon.getXAtUncheckedPointIndex(i0) - point.x;\n        const hypDeltaY = polygon.getYAtUncheckedPointIndex(i0) - point.y;\n        let projDist = Geometry.dotProductXYXY(hypDeltaX, hypDeltaY, edgeOutwardUnitNormal.x, edgeOutwardUnitNormal.y);\n        const edgeDist = Geometry.crossProductXYXY(hypDeltaX, hypDeltaY, edgeOutwardUnitNormal.x, edgeOutwardUnitNormal.y);\n        const edgeLength = Geometry.distanceXYXY(polygon.getXAtUncheckedPointIndex(i0), polygon.getYAtUncheckedPointIndex(i0), polygon.getXAtUncheckedPointIndex(i1), polygon.getYAtUncheckedPointIndex(i1));\n        let edgeParam = Geometry.safeDivideFraction(edgeDist, edgeLength, 0.0);\n        if (Geometry.isSameCoordinate(0.0, projDist, tolerance))\n            projDist = 0.0;\n        if (Geometry.isSameCoordinate(0.0, edgeParam, tolerance))\n            edgeParam = 0.0;\n        else if (Geometry.isSameCoordinate(1.0, edgeParam, tolerance))\n            edgeParam = 1.0;\n        return Point2d.create(projDist, edgeParam, result);\n    }\n    /** Compute the barycentric coordinates for a point on either of a pair of adjacent edges of a convex polygon.\n     * @param polygon points of the polygon, assumed to be convex. Assumed to have no closure point.\n     * @param iPrev start index of previous edge\n     * @param prevNormal outward unit normal of previous edge\n     * @param prevProj x = signed distance from point to previous edge; y = edge parameter of this projection in [0,1]\n     * @param i start index of current edge\n     * @param normal outward unit normal of current edge\n     * @param proj x = signed distance from point to current edge; y = edge parameter of this projection in [0,1]\n     * @param coords pre-allocated barycentric coordinate array to return, assumed to have length at least `polygon.length`\n     * @returns barycentric coordinates, or undefined if not on either edge\n     */\n    static convexBarycentricCoordinatesOnEdge(polygon, iPrev, prevNormal, prevProj, i, normal, proj, coords) {\n        // ignore degenerate edges\n        const pointIsOnPrevEdge = !prevNormal.isZero && (0.0 === prevProj.x) && Geometry.isIn01(prevProj.y);\n        const pointIsOnEdge = !normal.isZero && (0.0 === proj.x) && Geometry.isIn01(proj.y);\n        if (pointIsOnPrevEdge && pointIsOnEdge) { // the point is at vertex i\n            coords.fill(0);\n            coords[i] = 1.0;\n            return coords;\n        }\n        const n = polygon.length;\n        if (pointIsOnPrevEdge) { // the point is on the previous edge\n            coords.fill(0);\n            const i0 = iPrev;\n            const i1 = i;\n            const edgeParam = prevProj.y;\n            coords[i0] = 1.0 - edgeParam;\n            coords[i1] = edgeParam;\n            return coords;\n        }\n        if (pointIsOnEdge) { // the point is on the edge starting at the i_th vertex\n            coords.fill(0);\n            const i0 = i;\n            const i1 = (i + 1) % n;\n            const edgeParam = proj.y;\n            coords[i0] = 1.0 - edgeParam;\n            coords[i1] = edgeParam;\n            return coords;\n        }\n        return undefined; // not on edge\n    }\n    // cspell:word CAGD\n    /** Compute the barycentric coordinates for a point inside a convex polygon.\n     * @param polygon points of the polygon, assumed to be convex. Closure point optional.\n     * @param point point assumed to be inside or on polygon\n     * @param tolerance distance tolerance for point to be considered on a polygon edge\n     * @return barycentric coordinates of the interior point, or undefined if invalid polygon or exterior point. Length is same as `polygon.length`.\n     * @see BarycentricTriangle.pointToFraction\n     */\n    static convexBarycentricCoordinates(polygon, point, tolerance = Geometry.smallMetricDistance) {\n        // cf. \"Barycentric Coordinates for Convex Sets\", by Warren et al., CAGD (2003)\n        if (Array.isArray(polygon))\n            return this.convexBarycentricCoordinates(new Point3dArrayCarrier(polygon), point);\n        let n = polygon.length;\n        while (n > 1 && polygon.getPoint3dAtUncheckedPointIndex(0).isExactEqual(polygon.getPoint3dAtUncheckedPointIndex(n - 1)))\n            --n; // ignore closure point(s)\n        if (n < 3 || !PolygonOps.unitNormal(polygon, this._normal))\n            return undefined;\n        const localToWorld = this._workMatrix3d = Matrix3d.createRigidHeadsUp(this._normal, AxisOrder.ZXY, this._workMatrix3d);\n        const polygonXY = new GrowableXYZArray(n);\n        for (let i = 0; i < n; ++i)\n            polygonXY.push(localToWorld.multiplyInverseXYZAsPoint3d(polygon.getXAtUncheckedPointIndex(i), polygon.getYAtUncheckedPointIndex(i), polygon.getZAtUncheckedPointIndex(i), this._workXYZ));\n        const pointXY = this._workXYZ = localToWorld.multiplyInverseXYZAsPoint3d(point.x, point.y, point.z, this._workXYZ);\n        // now we know polygon orientation is ccw, its last edge has positive length, and we can ignore z-coords\n        let iPrev = n - 1;\n        const outwardUnitNormalOfLastEdge = this._vector0;\n        const projToLastEdge = this._workXY0 = this.computeEdgeDataXY(polygonXY, iPrev, pointXY, outwardUnitNormalOfLastEdge, tolerance, this._workXY0);\n        // we can compare to exact zero because computeEdgeDataXY has chopped small distances to zero\n        if (projToLastEdge.x < 0.0)\n            return undefined; // point is outside polygon, or polygon is nonconvex\n        const outwardUnitNormalOfPrevEdge = Vector3d.createFrom(outwardUnitNormalOfLastEdge, this._vector1);\n        const projToPrevEdge = this._workXY1 = Point2d.createFrom(projToLastEdge, this._workXY1);\n        const coords = Array(polygon.length).fill(0); // use original length\n        const largestResult = (tolerance > 0.0) ? 1.0 / (tolerance * tolerance) : Geometry.largeCoordinateResult;\n        let coordSum = 0.0;\n        for (let i = 0; i < n; ++i) {\n            const outwardUnitNormalOfEdge = Vector3d.createFrom(outwardUnitNormalOfLastEdge, this._vector2);\n            const projToEdge = this._workXY2 = (i < n - 1) ? this.computeEdgeDataXY(polygonXY, i, pointXY, outwardUnitNormalOfEdge, tolerance, this._workXY2) : Point2d.createFrom(projToLastEdge, this._workXY2);\n            if (projToEdge.x < 0.0)\n                return undefined; // point is outside polygon, or polygon is nonconvex\n            if (undefined !== this.convexBarycentricCoordinatesOnEdge(polygonXY, iPrev, outwardUnitNormalOfPrevEdge, projToPrevEdge, i, outwardUnitNormalOfEdge, projToEdge, coords))\n                return coords; // point is on vertex or edge; we are done\n            if (outwardUnitNormalOfEdge.x === 0.0 && outwardUnitNormalOfEdge.y === 0.0)\n                continue; // edge is degenerate; coords[i] = 0; keep previous edge data\n            if (0.0 === projToPrevEdge.x || 0.0 === projToEdge.x)\n                continue; // point is on subsequent colinear edge (ASSUMING interior point, convex polygon!); coords[i] = 0; keep previous edge data\n            const areaOfNormalParallelogram = Math.abs(outwardUnitNormalOfPrevEdge.crossProductXY(outwardUnitNormalOfEdge));\n            const coord = Geometry.conditionalDivideCoordinate(areaOfNormalParallelogram, projToPrevEdge.x * projToEdge.x, largestResult);\n            if (undefined === coord) {\n                assert(!\"unexpectedly small projection distance to an edge\");\n                return undefined; // shouldn't happen due to chopping in computeEdgeDataXY: area/(dist*dist) <= 1/tol^2 = largestResult\n            }\n            coords[i] = coord;\n            coordSum += coord;\n            outwardUnitNormalOfPrevEdge.setFrom(outwardUnitNormalOfEdge);\n            projToPrevEdge.setFrom(projToEdge);\n            iPrev = i;\n        }\n        const scale = Geometry.conditionalDivideCoordinate(1.0, coordSum);\n        if (undefined === scale) {\n            assert(!\"unexpected zero barycentric coordinate sum\");\n            return undefined;\n        }\n        for (let i = 0; i < n; ++i)\n            coords[i] *= scale; // normalized\n        return coords;\n    }\n}\n/** These values are the integrated area moment products [xx,xy,xz, x]\n * for a right triangle in the first quadrant at the origin -- (0,0),(1,0),(0,1)\n */\nPolygonOps._triangleMomentWeights = Matrix4d.createRowValues(2.0 / 24.0, 1.0 / 24.0, 0, 4.0 / 24.0, 1.0 / 24.0, 2.0 / 24.0, 0, 4.0 / 24.0, 0, 0, 0, 0, 4.0 / 24.0, 4.0 / 24.0, 0, 12.0 / 24.0);\n/** These values are the integrated volume moment products [xx,xy,xz, x, yx,yy,yz,y, zx,zy,zz,z,x,y,z,1]\n * for a tetrahedron in the first quadrant at the origin -- (0,00),(1,0,0),(0,1,0),(0,0,1)\n */\nPolygonOps._tetrahedralMomentWeights = Matrix4d.createRowValues(1.0 / 60.0, 1.0 / 120, 1.0 / 120, 1.0 / 24.0, 1.0 / 120, 1.0 / 60.0, 1.0 / 120, 1.0 / 24.0, 1.0 / 120, 1.0 / 120, 1.0 / 60.0, 1.0 / 24.0, 1.0 / 24.0, 1.0 / 24.0, 1.0 / 24.0, 1.0 / 6.0);\n// statics for shared reuse.\n// many methods use these.\n// only use them in \"leaf\" methods that are certain not to call other users . . .\nPolygonOps._vector0 = Vector3d.create();\nPolygonOps._vector1 = Vector3d.create();\nPolygonOps._vector2 = Vector3d.create();\nPolygonOps._vectorOrigin = Vector3d.create();\nPolygonOps._normal = Vector3d.create();\nPolygonOps._matrixA = Matrix4d.createIdentity();\nPolygonOps._matrixB = Matrix4d.createIdentity();\nPolygonOps._matrixC = Matrix4d.createIdentity();\nexport { PolygonOps };\n/**\n *  `IndexedXYZCollectionPolygonOps` class contains _static_ methods for typical operations on polygons carried as `IndexedXyZCollection`\n * @public\n */\nclass IndexedXYZCollectionPolygonOps {\n    /**\n     * Split a (convex) polygon into 2 parts based on altitude evaluations.\n     * * POSITIVE ALTITUDE IS IN\n     * @param plane any `PlaneAltitudeEvaluator` object that can evaluate `plane.altitude(xyz)` for distance from the plane.\n     * @param xyz original polygon\n     * @param xyzPositive array to receive inside part (altitude > 0)\n     * @param xyzNegative array to receive outside part\n     * @param altitudeRange min and max altitudes encountered.\n     */\n    static splitConvexPolygonInsideOutsidePlane(plane, xyz, xyzPositive, xyzNegative, altitudeRange) {\n        const xyz0 = IndexedXYZCollectionPolygonOps._xyz0Work;\n        const xyz1 = IndexedXYZCollectionPolygonOps._xyz1Work;\n        const xyzInterpolated = IndexedXYZCollectionPolygonOps._xyz2Work;\n        const n = xyz.length;\n        xyzPositive.clear();\n        xyzNegative.clear();\n        // let numSplit = 0;\n        const fractionTol = 1.0e-8;\n        if (n > 2) {\n            xyz.back(xyz0);\n            altitudeRange.setNull();\n            let a0 = plane.altitude(xyz0);\n            altitudeRange.extendX(a0);\n            //    if (a0 >= 0.0)\n            //      work.push_back (xyz0);\n            for (let i1 = 0; i1 < n; i1++) {\n                xyz.getPoint3dAtUncheckedPointIndex(i1, xyz1);\n                const a1 = plane.altitude(xyz1);\n                altitudeRange.extendX(a1);\n                let nearZero = false;\n                if (a0 * a1 < 0.0) {\n                    // simple crossing. . .\n                    const f = -a0 / (a1 - a0);\n                    if (f > 1.0 - fractionTol && a1 >= 0.0) {\n                        // the endpoint will be saved -- avoid the duplicate\n                        nearZero = true;\n                    }\n                    else {\n                        xyz0.interpolate(f, xyz1, xyzInterpolated);\n                        xyzPositive.push(xyzInterpolated);\n                        xyzNegative.push(xyzInterpolated);\n                    }\n                    // numSplit++;\n                }\n                if (a1 >= 0.0 || nearZero)\n                    xyzPositive.push(xyz1);\n                if (a1 <= 0.0 || nearZero)\n                    xyzNegative.push(xyz1);\n                xyz0.setFromPoint3d(xyz1);\n                a0 = a1;\n            }\n        }\n    }\n    /**\n     * Clip a polygon to one side of a plane.\n     * * Results with 2 or fewer points are ignored.\n     * * Other than ensuring capacity in the arrays, there are no object allocations during execution of this function.\n     * * plane is passed as unrolled Point4d (ax,ay,az,aw) point (x,y,z) acts as homogeneous (x,y,z,1)\n     *   * `keepPositive === true` selects positive altitudes.\n     * @param plane any type that has `plane.altitude`\n     * @param xyz input points.\n     * @param work work buffer\n     * @param tolerance tolerance for \"on plane\" decision.\n     * @return the number of crossings.   If this is larger than 2, the result is \"correct\" in a parity sense but may have overlapping (hence cancelling) parts.\n     */\n    static clipConvexPolygonInPlace(plane, xyz, work, keepPositive = true, tolerance = Geometry.smallMetricDistance) {\n        work.clear();\n        const s = keepPositive ? 1.0 : -1.0;\n        const n = xyz.length;\n        let numNegative = 0;\n        const fractionTol = 1.0e-8;\n        const b = -tolerance;\n        let numCrossings = 0;\n        if (xyz.length > 1) {\n            let a1;\n            let index0 = xyz.length - 1;\n            let a0 = s * xyz.evaluateUncheckedIndexPlaneAltitude(index0, plane);\n            if (Math.abs(a0) < tolerance)\n                a0 = 0;\n            //    if (a0 >= 0.0)\n            //      work.push_back (xyz0);\n            for (let index1 = 0; index1 < n; a0 = a1, index0 = index1++) {\n                a1 = s * xyz.evaluateUncheckedIndexPlaneAltitude(index1, plane);\n                if (Math.abs(a1) < tolerance)\n                    a1 = 0;\n                if (a1 < 0)\n                    numNegative++;\n                if (a0 * a1 < 0.0) {\n                    // simple crossing . . .\n                    const f = -a0 / (a1 - a0);\n                    if (f > 1.0 - fractionTol && a1 >= 0.0) {\n                        // the endpoint will be saved -- avoid the duplicate\n                    }\n                    else {\n                        work.pushInterpolatedFromGrowableXYZArray(xyz, index0, f, index1);\n                        if (a1 > 0)\n                            numCrossings++; // \"out to in\"\n                    }\n                }\n                if (a1 >= b) {\n                    work.pushFromGrowableXYZArray(xyz, index1);\n                    if (a0 < -b) {\n                        numCrossings++; // \"in to out\"\n                    }\n                }\n                index0 = index1;\n                a0 = a1;\n            }\n        }\n        if (work.length <= 2) {\n            xyz.clear();\n        }\n        else if (numNegative > 0) {\n            xyz.clear();\n            xyz.pushFromGrowableXYZArray(work);\n        }\n        work.clear();\n        return numCrossings;\n    }\n    /** Return an array containing\n     * * All points that are exactly on the plane.\n     * * Crossing points between adjacent points that are (strictly) on opposite sides.\n     */\n    static polygonPlaneCrossings(plane, xyz, crossings) {\n        crossings.length = 0;\n        if (xyz.length >= 2) {\n            const xyz0 = this._xyz0Work;\n            xyz.getPoint3dAtUncheckedPointIndex(xyz.length - 1, xyz0);\n            let a0 = plane.altitude(xyz0);\n            const xyz1 = this._xyz1Work;\n            for (let i = 0; i < xyz.length; i++) {\n                xyz.getPoint3dAtUncheckedPointIndex(i, xyz1);\n                const a1 = plane.altitude(xyz1);\n                if (a0 * a1 < 0.0) {\n                    // simple crossing. . .\n                    const f = -a0 / (a1 - a0);\n                    crossings.push(xyz0.interpolate(f, xyz1));\n                }\n                if (a1 === 0.0) { // IMPORTANT -- every point is directly tested here\n                    crossings.push(xyz1.clone());\n                }\n                xyz0.setFromPoint3d(xyz1);\n                a0 = a1;\n            }\n        }\n    }\n    /**\n     * * Input a \"clipped\" polygon (from clipConvexPolygonInPlace) with more than 2 crossings, i.e. is from a non-convex polygon with configurations like:\n     *   * multiple distinct polygons\n     *   * single polygon, but cut lines overlap and cancel by parity rules.\n     * * return 1 or more polygons, each having first and last points \"on\" the plane and intermediate points \"off\"\n     * * `minChainLength` indicates the shortest chain to be returned.\n     * @internal\n     */\n    static gatherCutLoopsFromPlaneClip(plane, xyz, minChainLength = 3, tolerance = Geometry.smallMetricDistance) {\n        const result = new CutLoopMergeContext();\n        // find the first on-plane point\n        let firstOnPlaneIndex = 0;\n        const n = xyz.length;\n        for (; firstOnPlaneIndex < n; firstOnPlaneIndex++) {\n            const a = xyz.evaluateUncheckedIndexPlaneAltitude(firstOnPlaneIndex, plane);\n            if (Math.abs(a) <= tolerance)\n                break;\n        }\n        if (firstOnPlaneIndex === n)\n            return result;\n        // find contiguous blocks of \"off plane\" points with on-plane points at their end.\n        let candidateA = firstOnPlaneIndex;\n        while (candidateA < n) {\n            const currentChain = new GrowableXYZArray();\n            currentChain.pushFromGrowableXYZArray(xyz, candidateA);\n            let candidateB = candidateA + 1;\n            while (candidateB < n) {\n                currentChain.pushFromGrowableXYZArray(xyz, candidateB);\n                const a = xyz.evaluateUncheckedIndexPlaneAltitude(candidateB, plane);\n                if (Math.abs(a) <= tolerance) {\n                    break;\n                }\n                candidateB++;\n            }\n            if (candidateB === n)\n                for (let i = 0; i <= firstOnPlaneIndex; i++)\n                    currentChain.pushFromGrowableXYZArray(xyz, i);\n            if (currentChain.length >= minChainLength)\n                result.inputLoops.push(CutLoop.createCaptureWithReturnEdge(currentChain));\n            candidateA = candidateB;\n        }\n        return result;\n    }\n    /**\n     * * Input the loops from `gatherCutLoopsFromClipPlane`\n     * * Consolidate loops for reentrant configurations.\n     * * WARNING: The output reuses and modifies input loops whenever possible.\n     * @internal\n     */\n    static reorderCutLoops(loops) {\n        // Simple case: all loops have common orientation\n        if (loops.inputLoops.length === 1)\n            return;\n        // Simple cases: 2 loops . . .\n        if (loops.inputLoops.length === 2) {\n            // if edges are in the same direction, it must be a pair of unrelated loop . . .\n            if (loops.inputLoops[0].edge.direction.dotProduct(loops.inputLoops[1].edge.direction) > 0) {\n                loops.outputLoops.push(loops.inputLoops[0]);\n                loops.outputLoops.push(loops.inputLoops[1]);\n                return;\n            }\n            // twist the two loops into 1,\n            const source = loops.inputLoops[1].xyz;\n            const dest = loops.inputLoops[0].xyz;\n            dest.pushFromGrowableXYZArray(source);\n            loops.outputLoops.push(loops.inputLoops[0]);\n            return;\n        }\n        // 3 or more loops.\n        loops.sortAndMergeLoops();\n        //\n    }\n    /**\n     * Return the intersection of the plane with a range cube.\n     * @param range\n     * @param xyzOut intersection polygon.  This is convex.\n     * @return reference to xyz if the polygon still has points; undefined if all points are clipped away.\n     */\n    static intersectRangeConvexPolygonInPlace(range, xyz) {\n        if (range.isNull)\n            return undefined;\n        const work = new GrowableXYZArray();\n        const plane = Point4d.create();\n        plane.set(0, 0, -1, range.high.z);\n        this.clipConvexPolygonInPlace(plane, xyz, work, true);\n        if (xyz.length === 0)\n            return undefined;\n        plane.set(0, 0, 1, -range.low.z);\n        this.clipConvexPolygonInPlace(plane, xyz, work, true);\n        if (xyz.length === 0)\n            return undefined;\n        plane.set(0, -1, 0, range.high.y);\n        this.clipConvexPolygonInPlace(plane, xyz, work, true);\n        if (xyz.length === 0)\n            return undefined;\n        plane.set(0, 1, 0, -range.low.y);\n        this.clipConvexPolygonInPlace(plane, xyz, work, true);\n        if (xyz.length === 0)\n            return undefined;\n        plane.set(-1, 0, 0, range.high.x);\n        this.clipConvexPolygonInPlace(plane, xyz, work, true);\n        if (xyz.length === 0)\n            return undefined;\n        plane.set(1, 0, 0, -range.low.x);\n        this.clipConvexPolygonInPlace(plane, xyz, work, true);\n        if (xyz.length === 0)\n            return undefined;\n        return xyz;\n    }\n}\nIndexedXYZCollectionPolygonOps._xyz0Work = Point3d.create();\nIndexedXYZCollectionPolygonOps._xyz1Work = Point3d.create();\nIndexedXYZCollectionPolygonOps._xyz2Work = Point3d.create();\nexport { IndexedXYZCollectionPolygonOps };\n/**\n * `Point3dArrayPolygonOps` class contains _static_ methods for typical operations on polygons carried as `Point3d[]`\n * @public\n */\nclass Point3dArrayPolygonOps {\n    //  private static _xyz1Work: Point3d = Point3d.create();\n    //  private static _xyz2Work: Point3d = Point3d.create();\n    /**\n     * Split a (convex) polygon into 2 parts.\n     * @param xyz original polygon\n     * @param xyzIn array to receive inside part\n     * @param xyzOut array to receive outside part\n     * @param altitudeRange min and max altitudes encountered.\n     */\n    static convexPolygonSplitInsideOutsidePlane(plane, xyz, xyzIn, xyzOut, altitudeRange) {\n        const xyzCarrier = new Point3dArrayCarrier(xyz);\n        const xyzInCarrier = new Point3dArrayCarrier(xyzIn);\n        const xyzOutCarrier = new Point3dArrayCarrier(xyzOut);\n        IndexedXYZCollectionPolygonOps.splitConvexPolygonInsideOutsidePlane(plane, xyzCarrier, xyzInCarrier, xyzOutCarrier, altitudeRange);\n    }\n    /** Return an array containing\n     * * All points that are exactly on the plane.\n     * * Crossing points between adjacent points that are (strictly) on opposite sides.\n     */\n    static polygonPlaneCrossings(plane, xyz, crossings) {\n        const xyzSource = new Point3dArrayCarrier(xyz);\n        return IndexedXYZCollectionPolygonOps.polygonPlaneCrossings(plane, xyzSource, crossings);\n    }\n    /**\n     * Clip a polygon, returning the clip result in the same object.\n     * @param xyz input/output polygon\n     * @param work scratch object\n     * @param tolerance tolerance for on-plane decision.\n     */\n    static convexPolygonClipInPlace(plane, xyz, work, tolerance = Geometry.smallMetricDistance) {\n        if (work === undefined)\n            work = [];\n        work.length = 0;\n        let numNegative = 0;\n        const fractionTol = 1.0e-8;\n        const b = -tolerance;\n        if (xyz.length > 2) {\n            let xyz0 = xyz[xyz.length - 1];\n            let a0 = plane.altitude(xyz0);\n            //    if (a0 >= 0.0)\n            //      work.push_back (xyz0);\n            for (const xyz1 of xyz) {\n                const a1 = plane.altitude(xyz1);\n                if (a1 < 0)\n                    numNegative++;\n                if (a0 * a1 < 0.0) {\n                    // simple crossing . . .\n                    const f = -a0 / (a1 - a0);\n                    if (f > 1.0 - fractionTol && a1 >= 0.0) {\n                        // the endpoint will be saved -- avoid the duplicate\n                    }\n                    else {\n                        work.push(xyz0.interpolate(f, xyz1));\n                    }\n                }\n                if (a1 >= b)\n                    work.push(xyz1);\n                xyz0 = Point3d.createFrom(xyz1);\n                a0 = a1;\n            }\n        }\n        if (work.length <= 2) {\n            xyz.length = 0;\n        }\n        else if (numNegative > 0) {\n            xyz.length = 0;\n            for (const xyzI of work) {\n                xyz.push(xyzI);\n            }\n            work.length = 0;\n        }\n    }\n}\nPoint3dArrayPolygonOps._xyz0Work = Point3d.create();\nexport { Point3dArrayPolygonOps };\n//# sourceMappingURL=PolygonOps.js.map",
      "start": 1693508122392,
      "end": 1693508122548,
      "sourcemaps": null
    }
  ]
}
