{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/solid/Sphere.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Solid\n */\nimport { Arc3d } from \"../curve/Arc3d\";\nimport { LineString3d } from \"../curve/LineString3d\";\nimport { Loop } from \"../curve/Loop\";\nimport { StrokeOptions } from \"../curve/StrokeOptions\";\nimport { Geometry } from \"../Geometry\";\nimport { AngleSweep } from \"../geometry3d/AngleSweep\";\nimport { Matrix3d } from \"../geometry3d/Matrix3d\";\nimport { Plane3dByOriginAndVectors } from \"../geometry3d/Plane3dByOriginAndVectors\";\nimport { Vector2d } from \"../geometry3d/Point2dVector2d\";\nimport { Vector3d } from \"../geometry3d/Point3dVector3d\";\nimport { Transform } from \"../geometry3d/Transform\";\nimport { SolidPrimitive } from \"./SolidPrimitive\";\n/**\n * A Sphere is\n *\n * * A unit sphere (but read on ....)\n * * mapped by an arbitrary (possibly skewed, non-uniform scaled) transform\n * * hence possibly the final geometry is ellipsoidal\n * @public\n */\nexport class Sphere extends SolidPrimitive {\n    /** Return the latitude (in radians) all fractional v. */\n    vFractionToRadians(v) {\n        return this._latitudeSweep.fractionToRadians(v);\n    }\n    /** Return the longitude (in radians) all fractional u. */\n    uFractionToRadians(u) {\n        return u * Math.PI * 2.0;\n    }\n    constructor(localToWorld, latitudeSweep, capped) {\n        super(capped);\n        /** String name for schema properties */\n        this.solidPrimitiveType = \"sphere\";\n        this._localToWorld = localToWorld;\n        this._latitudeSweep = latitudeSweep ? latitudeSweep : AngleSweep.createFullLatitude();\n    }\n    /** return a deep clone */\n    clone() {\n        return new Sphere(this._localToWorld.clone(), this._latitudeSweep.clone(), this.capped);\n    }\n    /** Transform the sphere in place.\n     * * Fails if the transform is singular.\n     */\n    tryTransformInPlace(transform) {\n        if (transform.matrix.isSingular())\n            return false;\n        transform.multiplyTransformTransform(this._localToWorld, this._localToWorld);\n        return true;\n    }\n    /** Return a transformed clone. */\n    cloneTransformed(transform) {\n        const sphere1 = this.clone();\n        transform.multiplyTransformTransform(sphere1._localToWorld, sphere1._localToWorld);\n        if (transform.matrix.determinant() < 0.0) {\n            if (sphere1._latitudeSweep !== undefined) {\n                sphere1._latitudeSweep.reverseInPlace();\n            }\n        }\n        return sphere1;\n    }\n    /** Return a coordinate frame (right handed, unit axes)\n     * * origin at sphere center\n     * * equator in xy plane\n     * * z axis perpendicular\n     */\n    getConstructiveFrame() {\n        return this._localToWorld.cloneRigid();\n    }\n    /** Return the latitude sweep as fraction of south pole to north pole. */\n    get latitudeSweepFraction() { return this._latitudeSweep.sweepRadians / Math.PI; }\n    /** Create from center and radius, with optional restricted latitudes. */\n    static createCenterRadius(center, radius, latitudeSweep) {\n        const localToWorld = Transform.createOriginAndMatrix(center, Matrix3d.createUniformScale(radius));\n        return new Sphere(localToWorld, latitudeSweep ? latitudeSweep : AngleSweep.createFullLatitude(), false);\n    }\n    /** Create an ellipsoid which is a unit sphere mapped to position by an (arbitrary, possibly skewed and scaled) transform. */\n    static createEllipsoid(localToWorld, latitudeSweep, capped) {\n        return new Sphere(localToWorld, latitudeSweep, capped);\n    }\n    /** Create a sphere from the typical parameters of the Dgn file */\n    static createDgnSphere(center, vectorX, vectorZ, radiusXY, radiusZ, latitudeSweep, capped) {\n        const vectorY = vectorX.rotate90Around(vectorZ);\n        if (vectorY && !vectorX.isParallelTo(vectorZ)) {\n            const matrix = Matrix3d.createColumns(vectorX, vectorY, vectorZ);\n            matrix.scaleColumns(radiusXY, radiusXY, radiusZ, matrix);\n            const frame = Transform.createOriginAndMatrix(center, matrix);\n            return new Sphere(frame, latitudeSweep.clone(), capped);\n        }\n        return undefined;\n    }\n    /** Create a sphere from the typical parameters of the Dgn file */\n    static createFromAxesAndScales(center, axes, radiusX, radiusY, radiusZ, latitudeSweep, capped) {\n        const localToWorld = Transform.createOriginAndMatrix(center, axes);\n        localToWorld.matrix.scaleColumnsInPlace(radiusX, radiusY, radiusZ);\n        return new Sphere(localToWorld, latitudeSweep ? latitudeSweep.clone() : AngleSweep.createFullLatitude(), capped);\n    }\n    /** return (copy of) sphere center */\n    cloneCenter() { return this._localToWorld.getOrigin(); }\n    /** return the (full length, i.e. scaled by radius) X vector from the sphere transform */\n    cloneVectorX() { return this._localToWorld.matrix.columnX(); }\n    /** return the (full length, i.e. scaled by radius) Y vector from the sphere transform */\n    cloneVectorY() { return this._localToWorld.matrix.columnY(); }\n    /** return the (full length, i.e. scaled by radius) Z vector from the sphere transform */\n    cloneVectorZ() { return this._localToWorld.matrix.columnZ(); }\n    /** return (a copy of) the sphere's angle sweep. */\n    cloneLatitudeSweep() { return this._latitudeSweep.clone(); }\n    /** Test if the geometry is a true sphere taking the transform (which might have nonuniform scaling) is applied. */\n    trueSphereRadius() {\n        const factors = this._localToWorld.matrix.factorRigidWithSignedScale();\n        if (!factors)\n            return undefined;\n        if (factors && factors.scale > 0) // why do we rule out mirror?\n            return factors.scale;\n        return undefined;\n    }\n    /**\n     * Return the largest of the primary xyz axis radii\n     */\n    maxAxisRadius() {\n        const matrix = this._localToWorld.matrix;\n        return Geometry.maxXYZ(matrix.columnXMagnitude(), matrix.columnYMagnitude(), matrix.columnZMagnitude());\n    }\n    /**\n     * Return a (clone of) the sphere's local to world transformation.\n     */\n    cloneLocalToWorld() { return this._localToWorld.clone(); }\n    /** Test if `other` is a `Sphere` */\n    isSameGeometryClass(other) { return other instanceof Sphere; }\n    /** Test for same geometry in `other` */\n    isAlmostEqual(other) {\n        if (other instanceof Sphere) {\n            if (this.capped !== other.capped)\n                return false;\n            if (!this._localToWorld.isAlmostEqual(other._localToWorld))\n                return false;\n            return true;\n        }\n        return false;\n    }\n    /**\n     *  return strokes for a cross-section (elliptic arc) at specified fraction v along the axis.\n     * * if strokeOptions is supplied, it is applied to the equator radii.\n     * @param v fractional position along the cone axis\n     * @param strokes stroke count or options.\n     */\n    strokeConstantVSection(v, fixedStrokeCount, options) {\n        let strokeCount = 16;\n        if (fixedStrokeCount !== undefined && Number.isFinite(fixedStrokeCount)) {\n            strokeCount = fixedStrokeCount;\n        }\n        else if (options instanceof StrokeOptions) {\n            strokeCount = options.applyTolerancesToArc(Geometry.maxXY(this._localToWorld.matrix.columnXMagnitude(), this._localToWorld.matrix.columnYMagnitude()));\n        }\n        strokeCount = Geometry.clampToStartEnd(strokeCount, 4, 64);\n        const transform = this._localToWorld;\n        const phi = this.vFractionToRadians(v);\n        const c1 = Math.cos(phi);\n        const s1 = Math.sin(phi);\n        let c0, s0;\n        const result = LineString3d.createForStrokes(fixedStrokeCount, options);\n        const deltaRadians = Math.PI * 2.0 / strokeCount;\n        const fractions = result.fractions; // possibly undefined !!!\n        const derivatives = result.packedDerivatives; // possibly undefined !!!\n        const uvParams = result.packedUVParams; // possibly undefined !!\n        const surfaceNormals = result.packedSurfaceNormals;\n        const dXdu = Vector3d.create();\n        const dXdv = Vector3d.create();\n        const normal = Vector3d.create();\n        let radians = 0;\n        for (let i = 0; i <= strokeCount; i++) {\n            if (i * 2 <= strokeCount)\n                radians = i * deltaRadians;\n            else\n                radians = (i - strokeCount) * deltaRadians;\n            c0 = Math.cos(radians);\n            s0 = Math.sin(radians);\n            const xyz = transform.multiplyXYZ(c1 * c0, c1 * s0, s1);\n            result.addPoint(xyz);\n            if (fractions)\n                fractions.push(i / strokeCount);\n            if (derivatives) {\n                transform.matrix.multiplyXYZ(-c1 * s0, c1 * c0, 0.0, dXdu);\n                derivatives.push(dXdu);\n            }\n            if (uvParams) {\n                uvParams.pushXY(i / strokeCount, v);\n            }\n            if (surfaceNormals) {\n                transform.matrix.multiplyXYZ(-s0, c0, 0, dXdu);\n                transform.matrix.multiplyXYZ(-s1 * c0, -s1 * s0, c1, dXdv);\n                dXdu.unitCrossProduct(dXdv, normal);\n                surfaceNormals.push(normal);\n            }\n        }\n        return result;\n    }\n    /** Second step of double dispatch:  call `handler.handleSphere(this)` */\n    dispatchToGeometryHandler(handler) {\n        return handler.handleSphere(this);\n    }\n    /**\n     * Return the Arc3d section at vFraction.  For the sphere, this is a latitude circle.\n     * @param vFraction fractional position along the sweep direction\n     */\n    constantVSection(vFraction) {\n        const phi = this._latitudeSweep.fractionToRadians(vFraction);\n        const s1 = Math.sin(phi);\n        const c1 = Math.cos(phi);\n        const transform = this._localToWorld;\n        const center = transform.multiplyXYZ(0, 0, s1);\n        const vector0 = transform.matrix.multiplyXYZ(c1, 0, 0);\n        const vector90 = transform.matrix.multiplyXYZ(0, c1, 0);\n        return Loop.create(Arc3d.create(center, vector0, vector90));\n    }\n    /** Extend a range to contain this sphere. */\n    extendRange(range, transform) {\n        let placement = this._localToWorld;\n        if (transform) {\n            placement = transform.multiplyTransformTransform(placement);\n        }\n        range.extendTransformedXYZ(placement, -1, -1, -1);\n        range.extendTransformedXYZ(placement, 1, -1, -1);\n        range.extendTransformedXYZ(placement, -1, 1, -1);\n        range.extendTransformedXYZ(placement, 1, 1, -1);\n        range.extendTransformedXYZ(placement, -1, -1, 1);\n        range.extendTransformedXYZ(placement, 1, -1, 1);\n        range.extendTransformedXYZ(placement, -1, 1, 1);\n        range.extendTransformedXYZ(placement, 1, 1, 1);\n    }\n    /** Evaluate as a uv surface\n     * @param uFraction fractional position on minor arc (theta, longitude)\n     * @param vFraction fractional position on major arc (phi, latitude)\n     */\n    uvFractionToPoint(uFraction, vFraction, result) {\n        // sphere with radius 1 . . .\n        const thetaRadians = this.uFractionToRadians(uFraction);\n        const phiRadians = this.vFractionToRadians(vFraction);\n        const cosTheta = Math.cos(thetaRadians);\n        const sinTheta = Math.sin(thetaRadians);\n        const sinPhi = Math.sin(phiRadians);\n        const cosPhi = Math.cos(phiRadians);\n        return this._localToWorld.multiplyXYZ(cosTheta * cosPhi, sinTheta * cosPhi, sinPhi, result);\n    }\n    /** Evaluate as a uv surface, returning point and two vectors.\n     * @param uFraction fractional position on minor arc (theta, longitude)\n     * @param vFraction fractional position on major arc (phi, latitude)\n     */\n    uvFractionToPointAndTangents(uFraction, vFraction, result) {\n        const thetaRadians = this.uFractionToRadians(uFraction);\n        const phiRadians = this.vFractionToRadians(vFraction);\n        const fTheta = Math.PI * 2.0;\n        const fPhi = this._latitudeSweep.sweepRadians;\n        const cosTheta = Math.cos(thetaRadians);\n        const sinTheta = Math.sin(thetaRadians);\n        const sinPhi = Math.sin(phiRadians);\n        const cosPhi = Math.cos(phiRadians);\n        return Plane3dByOriginAndVectors.createOriginAndVectors(this._localToWorld.multiplyXYZ(cosTheta * cosPhi, sinTheta * cosPhi, sinPhi), this._localToWorld.matrix.multiplyXYZ(-fTheta * sinTheta, fTheta * cosTheta, 0), // !!! note cosTheta term is omitted -- scale is wrong, but remains non-zero at poles.\n        this._localToWorld.matrix.multiplyXYZ(-fPhi * cosTheta * sinPhi, -fPhi * sinTheta * sinPhi, fPhi * cosPhi), result);\n    }\n    /**\n     * * A sphere is can be closed two ways:\n     *   * full sphere (no caps needed for closure)\n     *   * incomplete but with caps\n     * @return true if this is a closed volume.\n     */\n    get isClosedVolume() {\n        return this.capped || this._latitudeSweep.isFullLatitudeSweep;\n    }\n    /**\n     * Directional distance query\n     * * u direction is around latitude circle at maximum distance from axis.\n     * * v direction is on a line of longitude between the latitude limits.\n     */\n    maxIsoParametricDistance() {\n        // approximate radius at equator .. if elliptic, this is not exact . . .\n        const rX = this._localToWorld.matrix.columnXMagnitude();\n        const rY = this._localToWorld.matrix.columnYMagnitude();\n        const rZ = this._localToWorld.matrix.columnZMagnitude();\n        const rMaxU = Math.max(rX, rY);\n        let dMaxU = Math.PI * 2.0 * rMaxU;\n        if (!this._latitudeSweep.isRadiansInSweep(0.0))\n            dMaxU *= Math.max(Math.cos(Math.abs(this._latitudeSweep.startRadians)), Math.cos(Math.abs(this._latitudeSweep.endRadians)));\n        const dMaxV = Math.max(rMaxU, rZ) * Math.abs(this._latitudeSweep.sweepRadians);\n        return Vector2d.create(dMaxU, dMaxV);\n    }\n}\n//# sourceMappingURL=Sphere.js.map",
      "start": 1693508122923,
      "end": 1693508123062,
      "sourcemaps": null
    }
  ]
}
