{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tools/ViewTool.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tools\n */\nimport { BeTimePoint } from \"@itwin/core-bentley\";\nimport { Angle, AngleSweep, Arc3d, AxisOrder, ClipUtilities, Constant, Geometry, LineString3d, Matrix3d, Plane3dByOriginAndUnitNormal, Point2d, Point3d, Range2d, Range3d, Ray3d, Transform, Vector2d, Vector3d, YawPitchRollAngles, } from \"@itwin/core-geometry\";\nimport { Cartographic, ColorDef, Frustum, LinePixels, NpcCenter } from \"@itwin/core-common\";\nimport { DialogProperty, PropertyDescriptionHelper, } from \"@itwin/appui-abstract\";\nimport { AccuDraw, AccuDrawHintBuilder } from \"../AccuDraw\";\nimport { BingLocationProvider } from \"../BingLocation\";\nimport { CoordSystem } from \"../CoordSystem\";\nimport { IModelApp } from \"../IModelApp\";\nimport { LengthDescription } from \"../properties/LengthDescription\";\nimport { GraphicType } from \"../render/GraphicBuilder\";\nimport { Pixel } from \"../render/Pixel\";\nimport { StandardViewId } from \"../StandardView\";\nimport { eyeToCartographicOnGlobeFromGcs, queryTerrainElevationOffset, rangeToCartographicArea, viewGlobalLocation, ViewGlobalLocationConstants, } from \"../ViewGlobalLocation\";\nimport { DepthPointSource, ScreenViewport } from \"../Viewport\";\nimport { ViewRect } from \"../common/ViewRect\";\nimport { ViewState3d } from \"../ViewState\";\nimport { ViewStatus } from \"../ViewStatus\";\nimport { EditManipulator } from \"./EditManipulator\";\nimport { PrimitiveTool } from \"./PrimitiveTool\";\nimport { BeButton, BeButtonEvent, BeTouchEvent, CoordSource, CoreTools, EventHandled, InputSource, InteractiveTool, } from \"./Tool\";\nimport { ToolAssistance, ToolAssistanceImage, ToolAssistanceInputMethod } from \"./ToolAssistance\";\nimport { ToolSettings } from \"./ToolSettings\";\n/** @internal */\nexport var ViewHandleType;\n(function (ViewHandleType) {\n    ViewHandleType[ViewHandleType[\"None\"] = 0] = \"None\";\n    ViewHandleType[ViewHandleType[\"Rotate\"] = 1] = \"Rotate\";\n    ViewHandleType[ViewHandleType[\"TargetCenter\"] = 2] = \"TargetCenter\";\n    ViewHandleType[ViewHandleType[\"Pan\"] = 4] = \"Pan\";\n    ViewHandleType[ViewHandleType[\"Scroll\"] = 8] = \"Scroll\";\n    ViewHandleType[ViewHandleType[\"Zoom\"] = 16] = \"Zoom\";\n    ViewHandleType[ViewHandleType[\"Walk\"] = 32] = \"Walk\";\n    ViewHandleType[ViewHandleType[\"Fly\"] = 64] = \"Fly\";\n    ViewHandleType[ViewHandleType[\"Look\"] = 128] = \"Look\";\n    ViewHandleType[ViewHandleType[\"LookAndMove\"] = 256] = \"LookAndMove\";\n})(ViewHandleType || (ViewHandleType = {}));\n/* eslint-enable no-restricted-syntax */\n// dampen an inertia vector according to tool settings\nconst inertialDampen = (pt) => {\n    pt.scaleInPlace(Geometry.clamp(ToolSettings.viewingInertia.damping, .75, .999));\n};\n/** An InteractiveTool that manipulates a view.\n * @public\n * @extensions\n */\nexport class ViewTool extends InteractiveTool {\n    static translate(val) { return CoreTools.translate(`View.${val}`); }\n    beginDynamicUpdate() { this.inDynamicUpdate = true; }\n    endDynamicUpdate() { this.inDynamicUpdate = false; }\n    async run(..._args) {\n        const toolAdmin = IModelApp.toolAdmin;\n        if (undefined !== this.viewport && this.viewport === toolAdmin.markupView) {\n            IModelApp.notifications.outputPromptByKey(\"iModelJs:Viewing.NotDuringMarkup\");\n            return false;\n        }\n        if (!await toolAdmin.onInstallTool(this))\n            return false;\n        await toolAdmin.startViewTool(this);\n        await toolAdmin.onPostInstallTool(this);\n        return true;\n    }\n    constructor(viewport) {\n        super();\n        this.viewport = viewport;\n        this.inDynamicUpdate = false;\n    }\n    async onResetButtonUp(_ev) {\n        await this.exitTool();\n        return EventHandled.Yes;\n    }\n    /** Do not override. */\n    async exitTool() { return IModelApp.toolAdmin.exitViewTool(); }\n    static showPrompt(prompt) {\n        IModelApp.notifications.outputPrompt(ViewTool.translate(prompt));\n    }\n}\n/** @internal */\nexport class ViewingToolHandle {\n    constructor(viewTool) {\n        this.viewTool = viewTool;\n        this._lastPtNpc = new Point3d();\n        this._depthPoint = undefined;\n    }\n    onReinitialize() { }\n    onCleanup() { }\n    focusOut() { }\n    motion(_ev) { return false; }\n    checkOneShot() { return true; }\n    getHandleCursor() { return \"default\"; }\n    focusIn() { IModelApp.toolAdmin.setCursor(this.getHandleCursor()); }\n    drawHandle(_context, _hasFocus) { }\n    onWheel(_ev) { return false; }\n    onTouchStart(_ev) { return false; }\n    onTouchEnd(_ev) { return false; }\n    async onTouchComplete(_ev) { return false; }\n    async onTouchCancel(_ev) { return false; }\n    onTouchMove(_ev) { return false; }\n    onTouchMoveStart(_ev, _startEv) { return false; }\n    onTouchTap(_ev) { return false; }\n    onKeyTransition(_wentDown, _keyEvent) { return false; }\n    onModifierKeyTransition(_wentDown, _modifier, _event) { return false; }\n    needDepthPoint(_ev, _isPreview) { return false; }\n    adjustDepthPoint(isValid, _vp, _plane, source) {\n        switch (source) {\n            case DepthPointSource.Geometry:\n            case DepthPointSource.Model:\n            case DepthPointSource.BackgroundMap:\n            case DepthPointSource.GroundPlane:\n            case DepthPointSource.Grid:\n            case DepthPointSource.Map:\n                return isValid; // Sources with visible geometry/graphics are considered valid by default...\n            default:\n                return false; // Sources without visible geometry/graphics are NOT considered valid by default...\n        }\n    }\n    pickDepthPoint(ev) {\n        this._depthPoint = this.viewTool.pickDepthPoint(ev);\n    }\n    // if we have a valid depth point, set the focus distance to\n    changeFocusFromDepthPoint() {\n        if (undefined !== this._depthPoint) {\n            const view = this.viewTool.viewport.view;\n            if (view.is3d() && view.isCameraOn)\n                view.changeFocusFromPoint(this._depthPoint); // set the focus distance to the depth point\n        }\n    }\n}\n/** @internal */\nexport class ViewHandleArray {\n    constructor(viewTool) {\n        this.viewTool = viewTool;\n        this.handles = [];\n        this.focus = -1;\n        this.focusDrag = false;\n        this.hitHandleIndex = 0;\n    }\n    empty() {\n        this.focus = -1;\n        this.focusDrag = false;\n        this.hitHandleIndex = -1; // setting to -1 will result in onReinitialize getting called before testHit which sets the hit index\n        this.handles.length = 0;\n    }\n    get count() { return this.handles.length; }\n    get hitHandle() { return this.getByIndex(this.hitHandleIndex); }\n    get focusHandle() { return this.getByIndex(this.focus); }\n    add(handle) { this.handles.push(handle); }\n    getByIndex(index) { return (index >= 0 && index < this.count) ? this.handles[index] : undefined; }\n    focusHitHandle() { this.setFocus(this.hitHandleIndex); }\n    testHit(ptScreen, forced = ViewHandleType.None) {\n        this.hitHandleIndex = -1;\n        const data = { distance: 0.0, priority: 10 /* ViewManipPriority.Normal */ };\n        let minDistance = 0.0;\n        let minDistValid = false;\n        let highestPriority = 1 /* ViewManipPriority.Low */;\n        let nearestHitHandle;\n        for (let i = 0; i < this.count; i++) {\n            data.priority = 10 /* ViewManipPriority.Normal */;\n            const handle = this.handles[i];\n            if (forced) {\n                if (handle.handleType === forced) {\n                    this.hitHandleIndex = i;\n                    return true;\n                }\n            }\n            else if (handle.testHandleForHit(ptScreen, data)) {\n                if (data.priority >= highestPriority) {\n                    if (data.priority > highestPriority)\n                        minDistValid = false;\n                    highestPriority = data.priority;\n                    if (!minDistValid || (data.distance < minDistance)) {\n                        minDistValid = true;\n                        minDistance = data.distance;\n                        nearestHitHandle = handle;\n                        this.hitHandleIndex = i;\n                    }\n                }\n            }\n        }\n        return undefined !== nearestHitHandle;\n    }\n    drawHandles(context) {\n        if (0 === this.count)\n            return;\n        // all handle objects must draw themselves\n        for (let i = 0; i < this.count; ++i) {\n            if (i !== this.hitHandleIndex) {\n                const handle = this.handles[i];\n                handle.drawHandle(context, this.focus === i);\n            }\n        }\n        // draw the hit handle last\n        if (-1 !== this.hitHandleIndex) {\n            const handle = this.handles[this.hitHandleIndex];\n            handle.drawHandle(context, this.focus === this.hitHandleIndex);\n        }\n    }\n    setFocus(index) {\n        if (this.focus === index && (this.focusDrag === this.viewTool.inHandleModify))\n            return;\n        let focusHandle;\n        if (this.focus >= 0) {\n            focusHandle = this.getByIndex(this.focus);\n            if (focusHandle)\n                focusHandle.focusOut();\n        }\n        if (index >= 0) {\n            focusHandle = this.getByIndex(index);\n            if (focusHandle)\n                focusHandle.focusIn();\n        }\n        this.focus = index;\n        this.focusDrag = this.viewTool.inHandleModify;\n        const vp = this.viewTool.viewport;\n        if (undefined !== vp)\n            vp.invalidateDecorations();\n    }\n    onReinitialize() { this.handles.forEach((handle) => handle.onReinitialize()); }\n    onCleanup() { this.handles.forEach((handle) => handle.onCleanup()); }\n    motion(ev) { this.handles.forEach((handle) => handle.motion(ev)); }\n    onWheel(ev) {\n        let preventDefault = false;\n        this.handles.forEach((handle) => {\n            if (handle.onWheel(ev))\n                preventDefault = true;\n        });\n        return preventDefault;\n    }\n    /** determine whether a handle of a specific type exists */\n    hasHandle(handleType) { return this.handles.some((handle) => handle.handleType === handleType); }\n}\n/** Base class for tools that manipulate the frustum of a Viewport.\n * @public\n * @extensions\n */\nexport class ViewManip extends ViewTool {\n    constructor(viewport, handleMask, oneShot, isDraggingRequired = false) {\n        super(viewport);\n        this.handleMask = handleMask;\n        this.oneShot = oneShot;\n        this.isDraggingRequired = isDraggingRequired;\n        this.frustumValid = false; // unused\n        this.targetCenterWorld = new Point3d();\n        this.inHandleModify = false;\n        this.isDragging = false;\n        this.targetCenterValid = false;\n        this.targetCenterLocked = false;\n        this.nPts = 0;\n        /** @internal */\n        this.forcedHandle = ViewHandleType.None;\n        this.viewHandles = new ViewHandleArray(this);\n        this.changeViewport(viewport);\n    }\n    decorate(context) {\n        this.viewHandles.drawHandles(context);\n        this.previewDepthPoint(context);\n    }\n    /** @internal */\n    previewDepthPoint(context) {\n        if (undefined === this._depthPreview)\n            return;\n        const cursorVp = IModelApp.toolAdmin.cursorView;\n        if (cursorVp !== context.viewport)\n            return;\n        let origin = this._depthPreview.plane.getOriginRef();\n        let normal = this._depthPreview.plane.getNormalRef();\n        if (this._depthPreview.isDefaultDepth) {\n            origin = cursorVp.worldToView(origin);\n            origin.z = 0.0;\n            cursorVp.viewToWorld(origin, origin); // Avoid getting clipped out in z...\n            normal = context.viewport.view.getZVector(); // Always draw circle for invalid depth point oriented to view...\n        }\n        const pixelSize = context.viewport.getPixelSizeAtPoint(origin);\n        const skew = context.viewport.view.getAspectRatioSkew();\n        const radius = this._depthPreview.pickRadius * pixelSize;\n        const rMatrix = Matrix3d.createRigidHeadsUp(normal);\n        const ellipse = Arc3d.createScaledXYColumns(origin, rMatrix, radius, radius / skew, AngleSweep.create360());\n        const colorBase = (this._depthPreview.isDefaultDepth ? ColorDef.red : (DepthPointSource.Geometry === this._depthPreview.source ? ColorDef.green : context.viewport.hilite.color));\n        const colorLine = EditManipulator.HandleUtils.adjustForBackgroundColor(colorBase, cursorVp).withTransparency(50);\n        const colorFill = colorLine.withTransparency(200);\n        const builder = context.createGraphicBuilder(GraphicType.WorldOverlay);\n        builder.setSymbology(colorLine, colorFill, 1, this._depthPreview.isDefaultDepth ? LinePixels.Code2 : LinePixels.Solid);\n        builder.addArc(ellipse, true, true);\n        builder.addArc(ellipse, false, false);\n        context.addDecorationFromBuilder(builder);\n        ViewTargetCenter.drawCross(context, origin, this._depthPreview.pickRadius * 0.5, false);\n    }\n    /** @internal */\n    getDepthPointGeometryId() {\n        if (undefined === this._depthPreview)\n            return undefined;\n        return (DepthPointSource.Geometry === this._depthPreview.source ? this._depthPreview.sourceId : undefined);\n    }\n    /** @internal */\n    clearDepthPoint() {\n        if (undefined === this._depthPreview)\n            return false;\n        this._depthPreview = undefined;\n        return true;\n    }\n    /** @internal */\n    pickDepthPoint(ev, isPreview = false) {\n        if (!isPreview && ev.viewport && undefined !== this.getDepthPointGeometryId())\n            ev.viewport.flashedId = undefined;\n        this.clearDepthPoint();\n        if (isPreview && this.inDynamicUpdate)\n            return undefined;\n        const vp = ev.viewport;\n        if (undefined === vp || undefined === this.viewHandles.hitHandle || !this.viewHandles.hitHandle.needDepthPoint(ev, isPreview))\n            return undefined;\n        const pickRadiusPixels = vp.pixelsFromInches(ToolSettings.viewToolPickRadiusInches);\n        const result = vp.pickDepthPoint(ev.rawPoint, pickRadiusPixels);\n        let isValidDepth = false;\n        switch (result.source) {\n            case DepthPointSource.Geometry:\n            case DepthPointSource.Model:\n            case DepthPointSource.Map:\n                isValidDepth = true;\n                break;\n            case DepthPointSource.BackgroundMap:\n            case DepthPointSource.GroundPlane:\n            case DepthPointSource.Grid:\n            case DepthPointSource.ACS:\n            case DepthPointSource.TargetPoint:\n                const npcPt = vp.worldToNpc(result.plane.getOriginRef());\n                isValidDepth = !(npcPt.z < 0.0 || npcPt.z > 1.0);\n                break;\n        }\n        // Allow handle to reject depth depending on source and to set a default depth point when invalid...\n        isValidDepth = this.viewHandles.hitHandle.adjustDepthPoint(isValidDepth, vp, result.plane, result.source);\n        if (isPreview)\n            this._depthPreview = { testPoint: ev.rawPoint, pickRadius: pickRadiusPixels, plane: result.plane, source: result.source, isDefaultDepth: !isValidDepth, sourceId: result.sourceId };\n        return (isValidDepth || isPreview ? result.plane.getOriginRef() : undefined);\n    }\n    async onReinitialize() {\n        if (undefined !== this.viewport) {\n            this.viewport.synchWithView(); // make sure we store any changes in view undo buffer.\n            this.viewHandles.setFocus(-1);\n        }\n        this.nPts = 0;\n        this.inHandleModify = false;\n        this.inDynamicUpdate = false;\n        this._startPose = undefined;\n        this.viewHandles.onReinitialize();\n    }\n    async onDataButtonDown(ev) {\n        // Tool was started in \"drag required\" mode, don't advance tool state and wait to see if we get the start drag event.\n        if ((0 === this.nPts && this.isDraggingRequired && !this.isDragging) || undefined === ev.viewport)\n            return EventHandled.No;\n        switch (this.nPts) {\n            case 0:\n                this.changeViewport(ev.viewport);\n                if (this.processFirstPoint(ev))\n                    this.nPts = 1;\n                break;\n            case 1:\n                this.nPts = 2;\n                break;\n        }\n        if (this.nPts > 1) {\n            this.inDynamicUpdate = false;\n            if (this.processPoint(ev, false) && this.oneShot)\n                await this.exitTool();\n            else\n                await this.onReinitialize();\n        }\n        return EventHandled.Yes;\n    }\n    async onDataButtonUp(_ev) {\n        if (this.nPts <= 1 && this.isDraggingRequired && !this.isDragging && this.oneShot)\n            await this.exitTool();\n        return EventHandled.No;\n    }\n    async onMouseWheel(inputEv) {\n        const ev = inputEv.clone();\n        if (this.viewHandles.onWheel(ev)) // notify handles that wheel has rolled.\n            return EventHandled.Yes;\n        await IModelApp.toolAdmin.processWheelEvent(ev, false);\n        return EventHandled.Yes;\n    }\n    /** @internal */\n    async startHandleDrag(ev, forcedHandle) {\n        if (this.inHandleModify)\n            return EventHandled.No; // If already changing the view reject the request...\n        if (undefined !== forcedHandle) {\n            if (!this.viewHandles.hasHandle(forcedHandle))\n                return EventHandled.No; // If requested handle isn't present reject the request...\n            this.forcedHandle = forcedHandle;\n        }\n        this.receivedDownEvent = true; // Request up events even though we may not have gotten the down event...\n        this.isDragging = true;\n        if (0 === this.nPts)\n            await this.onDataButtonDown(ev);\n        return EventHandled.Yes;\n    }\n    async onMouseStartDrag(ev) {\n        if (BeButton.Data !== ev.button)\n            return EventHandled.No;\n        return this.startHandleDrag(ev);\n    }\n    async onMouseEndDrag(ev) {\n        // NOTE: To support startHandleDrag being called by IdleTool for middle button drag, check inHandleModify and not the button type...\n        if (!this.inHandleModify)\n            return EventHandled.No;\n        this.isDragging = false;\n        return (0 === this.nPts) ? EventHandled.Yes : this.onDataButtonDown(ev);\n    }\n    async onMouseMotion(ev) {\n        if (0 === this.nPts && this.viewHandles.testHit(ev.viewPoint))\n            this.viewHandles.focusHitHandle();\n        if (0 !== this.nPts)\n            this.processPoint(ev, true);\n        this.viewHandles.motion(ev);\n        const prevSourceId = this.getDepthPointGeometryId();\n        const showDepthChanged = (undefined !== this.pickDepthPoint(ev, true) || this.clearDepthPoint());\n        if (ev.viewport && (showDepthChanged || prevSourceId)) {\n            const currSourceId = this.getDepthPointGeometryId();\n            if (currSourceId !== prevSourceId)\n                ev.viewport.flashedId = currSourceId;\n            ev.viewport.invalidateDecorations();\n        }\n    }\n    async onTouchStart(ev) {\n        if (0 === this.nPts && this.viewHandles.testHit(ev.viewPoint))\n            this.viewHandles.focusHitHandle();\n        const focusHandle = this.viewHandles.focusHandle;\n        if (undefined !== focusHandle)\n            focusHandle.onTouchStart(ev);\n    }\n    async onTouchEnd(ev) {\n        const focusHandle = this.viewHandles.focusHandle;\n        if (undefined !== focusHandle)\n            focusHandle.onTouchEnd(ev);\n    }\n    async onTouchComplete(ev) {\n        const focusHandle = this.viewHandles.focusHandle;\n        if (undefined !== focusHandle && await focusHandle.onTouchComplete(ev))\n            return;\n        if (this.inHandleModify)\n            return IModelApp.toolAdmin.convertTouchEndToButtonUp(ev);\n    }\n    async onTouchCancel(ev) {\n        const focusHandle = this.viewHandles.focusHandle;\n        if (undefined !== focusHandle && await focusHandle.onTouchCancel(ev))\n            return;\n        if (this.inHandleModify)\n            return IModelApp.toolAdmin.convertTouchEndToButtonUp(ev, BeButton.Reset);\n    }\n    async onTouchMove(ev) {\n        const focusHandle = this.viewHandles.focusHandle;\n        if (undefined !== focusHandle && focusHandle.onTouchMove(ev))\n            return;\n        if (this.inHandleModify)\n            return IModelApp.toolAdmin.convertTouchMoveToMotion(ev);\n    }\n    async onTouchMoveStart(ev, startEv) {\n        const focusHandle = this.viewHandles.focusHandle;\n        if (undefined !== focusHandle && focusHandle.onTouchMoveStart(ev, startEv))\n            return EventHandled.Yes;\n        if (!this.inHandleModify && startEv.isSingleTouch)\n            await IModelApp.toolAdmin.convertTouchMoveStartToButtonDownAndMotion(startEv, ev);\n        return this.inHandleModify ? EventHandled.Yes : EventHandled.No;\n    }\n    async onTouchTap(ev) {\n        const focusHandle = this.viewHandles.focusHandle;\n        if (undefined !== focusHandle && focusHandle.onTouchTap(ev))\n            return EventHandled.Yes;\n        return ev.isSingleTap ? EventHandled.Yes : EventHandled.No; // Prevent IdleTool from converting single tap into data button down/up...\n    }\n    async onKeyTransition(wentDown, keyEvent) {\n        const focusHandle = this.viewHandles.focusHandle;\n        return (undefined !== focusHandle && focusHandle.onKeyTransition(wentDown, keyEvent) ? EventHandled.Yes : EventHandled.No);\n    }\n    async onModifierKeyTransition(wentDown, modifier, event) {\n        const focusHandle = this.viewHandles.focusHandle;\n        return (undefined !== focusHandle && focusHandle.onModifierKeyTransition(wentDown, modifier, event) ? EventHandled.Yes : EventHandled.No);\n    }\n    async onPostInstall() {\n        await super.onPostInstall();\n        await this.onReinitialize(); // Call onReinitialize now that tool is installed.\n    }\n    /** @beta */\n    provideToolAssistance(mainInstrKey, additionalInstr) {\n        const mainInstruction = ToolAssistance.createInstruction(this.iconSpec, ViewTool.translate(mainInstrKey));\n        const mouseInstructions = [];\n        const touchInstructions = [];\n        const acceptMsg = CoreTools.translate(\"ElementSet.Inputs.AcceptPoint\");\n        const rejectMsg = CoreTools.translate(\"ElementSet.Inputs.Exit\");\n        touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.OneTouchDrag, acceptMsg, false, ToolAssistanceInputMethod.Touch));\n        mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.LeftClick, acceptMsg, false, ToolAssistanceInputMethod.Mouse));\n        touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.TwoTouchTap, rejectMsg, false, ToolAssistanceInputMethod.Touch));\n        mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.RightClick, rejectMsg, false, ToolAssistanceInputMethod.Mouse));\n        if (undefined !== additionalInstr) {\n            for (const instr of additionalInstr) {\n                if (ToolAssistanceInputMethod.Touch === instr.inputMethod)\n                    touchInstructions.push(instr);\n                else\n                    mouseInstructions.push(instr);\n            }\n        }\n        const sections = [];\n        sections.push(ToolAssistance.createSection(mouseInstructions, ToolAssistance.inputsLabel));\n        sections.push(ToolAssistance.createSection(touchInstructions, ToolAssistance.inputsLabel));\n        const instructions = ToolAssistance.createInstructions(mainInstruction, sections);\n        IModelApp.notifications.setToolAssistance(instructions);\n    }\n    async onCleanup() {\n        let restorePrevious = false;\n        if (this.inDynamicUpdate) {\n            this.endDynamicUpdate();\n            restorePrevious = true;\n        }\n        const vp = this.viewport;\n        if (undefined !== vp) {\n            if (restorePrevious && this._startPose) {\n                vp.view.applyPose(this._startPose);\n                vp.animateFrustumChange();\n            }\n            else {\n                vp.synchWithView();\n            }\n            vp.invalidateDecorations();\n        }\n        this.viewHandles.onCleanup();\n        this.viewHandles.empty();\n    }\n    /**\n     * Set the center of rotation for rotate handle.\n     * @param pt the new target point in world coordinates\n     * @param lockTarget consider the target point locked for this tool instance\n     * @param saveTarget save this target point for use between tool instances\n     */\n    setTargetCenterWorld(pt, lockTarget, saveTarget) {\n        this.targetCenterWorld.setFrom(pt);\n        this.targetCenterValid = true;\n        this.targetCenterLocked = lockTarget;\n        if (!this.viewport)\n            return;\n        if (!this.viewport.view.allow3dManipulations())\n            this.targetCenterWorld.z = 0.0;\n        this.viewport.viewCmdTargetCenter = (saveTarget ? pt : undefined);\n    }\n    updateTargetCenter() {\n        const vp = this.viewport;\n        if (!vp)\n            return;\n        if (this.targetCenterValid) {\n            if (this.inHandleModify)\n                return;\n            if (IModelApp.tentativePoint.isActive) {\n                let tentPt = IModelApp.tentativePoint.getPoint();\n                if (!IModelApp.tentativePoint.isSnapped) {\n                    if (undefined === this._depthPreview && this.targetCenterLocked) {\n                        const ev = new BeButtonEvent();\n                        IModelApp.toolAdmin.fillEventFromCursorLocation(ev);\n                        this.targetCenterLocked = false; // Depth preview won't be active (or requested) if target is currently locked...\n                        this.pickDepthPoint(ev, true);\n                    }\n                    if (undefined !== this._depthPreview && !this._depthPreview.isDefaultDepth)\n                        tentPt = this._depthPreview.plane.getOriginRef(); // Prefer valid depth preview point to unsnapped tentative location...\n                }\n                this.setTargetCenterWorld(tentPt, true, false);\n                IModelApp.tentativePoint.clear(true); // Clear tentative, there won't be a datapoint to accept...\n            }\n            return;\n        }\n        if (IModelApp.tentativePoint.isActive)\n            return this.setTargetCenterWorld(IModelApp.tentativePoint.getPoint(), true, false);\n        if (vp.viewCmdTargetCenter && this.isPointVisible(vp.viewCmdTargetCenter))\n            return this.setTargetCenterWorld(vp.viewCmdTargetCenter, true, true);\n        return this.setTargetCenterWorld(ViewManip.getDefaultTargetPointWorld(vp), false, false);\n    }\n    processFirstPoint(ev) {\n        const forcedHandle = this.forcedHandle;\n        this.forcedHandle = ViewHandleType.None;\n        if (this.viewHandles.testHit(ev.viewPoint, forcedHandle)) {\n            this.inHandleModify = true;\n            this.viewHandles.focusHitHandle();\n            const handle = this.viewHandles.hitHandle;\n            if (undefined !== handle && !handle.firstPoint(ev))\n                return false;\n        }\n        this._startPose = this.viewport ? this.viewport.view.savePose() : undefined;\n        return true;\n    }\n    processPoint(ev, inDynamics) {\n        const hitHandle = this.viewHandles.hitHandle;\n        if (undefined === hitHandle)\n            return true;\n        const doUpdate = hitHandle.doManipulation(ev, inDynamics);\n        return inDynamics || (doUpdate && hitHandle.checkOneShot());\n    }\n    lensAngleMatches(angle, tolerance) {\n        const cameraView = this.viewport.view;\n        return !cameraView.is3d() ? false : Math.abs(cameraView.calcLensAngle().radians - angle.radians) < tolerance;\n    }\n    get isZUp() {\n        const view = this.viewport.view;\n        const viewX = view.getXVector();\n        const viewY = view.getXVector();\n        const zVec = Vector3d.unitZ();\n        return (Math.abs(zVec.dotProduct(viewY)) > 0.99 && Math.abs(zVec.dotProduct(viewX)) < 0.01);\n    }\n    static getFocusPlaneNpc(vp) {\n        const pt = vp.worldToNpc(vp.view.getTargetPoint());\n        return (pt.z < 0.0 || pt.z > 1.0) ? 0.5 : pt.z;\n    }\n    static getDefaultTargetPointWorld(vp) {\n        if (!vp.view.allow3dManipulations())\n            return vp.npcToWorld(NpcCenter);\n        const targetPoint = vp.view.getTargetPoint();\n        const targetPointNpc = vp.worldToNpc(targetPoint);\n        if (targetPointNpc.z < 0.0 || targetPointNpc.z > 1.0) {\n            targetPointNpc.z = 0.5;\n            vp.npcToWorld(targetPointNpc, targetPoint);\n        }\n        return targetPoint;\n    }\n    /** Determine whether the supplied point is visible in this Viewport. */\n    isPointVisible(testPt) {\n        const vp = this.viewport;\n        if (!vp)\n            return false;\n        return vp.isPointVisibleXY(testPt);\n    }\n    /** @internal */\n    static computeFitRange(viewport) {\n        const range = viewport.computeViewRange();\n        const clip = (viewport.viewFlags.clipVolume ? viewport.view.getViewClip() : undefined);\n        if (undefined !== clip) {\n            const clipRange = ClipUtilities.rangeOfClipperIntersectionWithRange(clip, range);\n            if (!clipRange.isNull)\n                range.setFrom(clipRange);\n        }\n        return range;\n    }\n    static fitView(viewport, animateFrustumChange, options) {\n        const range = this.computeFitRange(viewport);\n        const aspect = viewport.viewRect.aspect;\n        viewport.view.lookAtVolume(range, aspect, options);\n        viewport.synchWithView({ animateFrustumChange });\n        viewport.viewCmdTargetCenter = undefined;\n    }\n    /** @internal */\n    static fitViewWithGlobeAnimation(viewport, animateFrustumChange, options) {\n        const range = this.computeFitRange(viewport);\n        if (viewport.view.isSpatialView() && animateFrustumChange && (viewport.viewingGlobe || !viewport.view.getIsViewingProject())) {\n            const cartographicCenter = viewport.view.rootToCartographic(range.center);\n            if (undefined !== cartographicCenter) {\n                const cartographicArea = rangeToCartographicArea(viewport.view, range);\n                (async () => {\n                    await viewport.animateFlyoverToGlobalLocation({ center: cartographicCenter, area: cartographicArea }); // NOTE: Turns on camera...which is why we checked that it was already on...\n                    viewport.viewCmdTargetCenter = undefined;\n                })().catch(() => { });\n                return;\n            }\n        }\n        const aspect = viewport.viewRect.aspect;\n        viewport.view.lookAtVolume(range, aspect, options);\n        viewport.synchWithView({ animateFrustumChange });\n        viewport.viewCmdTargetCenter = undefined;\n    }\n    static async zoomToAlwaysDrawnExclusive(viewport, options) {\n        if (!viewport.isAlwaysDrawnExclusive || undefined === viewport.alwaysDrawn || 0 === viewport.alwaysDrawn.size)\n            return false;\n        await viewport.zoomToElements(viewport.alwaysDrawn, options);\n        return true;\n    }\n    setCameraLensAngle(lensAngle, retainEyePoint) {\n        const vp = this.viewport;\n        if (!vp)\n            return ViewStatus.InvalidViewport;\n        const view = vp.view;\n        if (!view.is3d() || !view.allow3dManipulations())\n            return ViewStatus.InvalidViewport;\n        const result = (retainEyePoint && view.isCameraOn) ?\n            view.lookAt({ eyePoint: view.getEyePoint(), targetPoint: view.getTargetPoint(), upVector: view.getYVector(), lensAngle }) :\n            vp.turnCameraOn(lensAngle);\n        if (result !== ViewStatus.Success)\n            return result;\n        vp.setupFromView();\n        return ViewStatus.Success;\n    }\n    enforceZUp(pivotPoint) {\n        const vp = this.viewport;\n        if (!vp || this.isZUp)\n            return false;\n        const viewY = vp.view.getYVector();\n        const rotMatrix = Matrix3d.createRotationVectorToVector(viewY, Vector3d.unitZ());\n        if (!rotMatrix)\n            return false;\n        const transform = Transform.createFixedPointAndMatrix(pivotPoint, rotMatrix);\n        const frust = vp.getWorldFrustum();\n        frust.multiply(transform);\n        vp.setupViewFromFrustum(frust);\n        return true;\n    }\n    changeViewport(vp) {\n        if (vp === this.viewport && 0 !== this.viewHandles.count) // If viewport isn't really changing do nothing...\n            return;\n        if (this.viewport)\n            this.viewport.invalidateDecorations(); // Remove decorations from current viewport...\n        this.viewport = vp;\n        this.targetCenterValid = false;\n        if (this.handleMask & (ViewHandleType.Rotate | ViewHandleType.TargetCenter))\n            this.updateTargetCenter();\n        this.viewHandles.empty();\n        if (this.handleMask & ViewHandleType.Rotate)\n            this.viewHandles.add(new ViewRotate(this));\n        if (this.handleMask & ViewHandleType.TargetCenter)\n            this.viewHandles.add(new ViewTargetCenter(this));\n        if (this.handleMask & ViewHandleType.Pan)\n            this.viewHandles.add(new ViewPan(this));\n        if (this.handleMask & ViewHandleType.Scroll)\n            this.viewHandles.add(new ViewScroll(this));\n        if (this.handleMask & ViewHandleType.Zoom)\n            this.viewHandles.add(new ViewZoom(this));\n        if (this.handleMask & ViewHandleType.Walk)\n            this.viewHandles.add(new ViewWalk(this));\n        if (this.handleMask & ViewHandleType.Fly)\n            this.viewHandles.add(new ViewFly(this));\n        if (this.handleMask & ViewHandleType.Look)\n            this.viewHandles.add(new ViewLook(this));\n        if (this.handleMask & ViewHandleType.LookAndMove)\n            this.viewHandles.add(new ViewLookAndMove(this));\n    }\n}\n/** ViewingToolHandle for modifying the view's target point for operations like rotate */\nclass ViewTargetCenter extends ViewingToolHandle {\n    get handleType() { return ViewHandleType.TargetCenter; }\n    checkOneShot() { return false; } // Don't exit tool after moving target in single-shot mode...\n    firstPoint(ev) {\n        if (undefined === ev.viewport)\n            return false;\n        ev.viewport.viewCmdTargetCenter = undefined; // Clear current saved target, must accept a new location with ctrl...\n        return true;\n    }\n    testHandleForHit(ptScreen, out) {\n        if (this.viewTool.isDraggingRequired)\n            return false; // Target center handle is not movable in this mode, but it's still nice to display the point we're rotating about...\n        const targetPt = this.viewTool.viewport.worldToView(this.viewTool.targetCenterWorld);\n        const distance = targetPt.distanceXY(ptScreen);\n        const locateThreshold = this.viewTool.viewport.pixelsFromInches(0.15);\n        if (distance > locateThreshold)\n            return false;\n        out.distance = distance;\n        out.priority = 1000 /* ViewManipPriority.High */;\n        return true;\n    }\n    /** @internal */\n    static drawCross(context, worldPoint, sizePixels, hasFocus) {\n        const crossSize = Math.floor(sizePixels) + 0.5;\n        const outlineSize = crossSize + 1;\n        const position = context.viewport.worldToView(worldPoint);\n        position.x = Math.floor(position.x) + 0.5;\n        position.y = Math.floor(position.y) + 0.5;\n        const drawDecoration = (ctx) => {\n            ctx.beginPath();\n            ctx.strokeStyle = \"rgba(0,0,0,.5)\";\n            ctx.lineWidth = hasFocus ? 5 : 3;\n            ctx.moveTo(-outlineSize, 0);\n            ctx.lineTo(outlineSize, 0);\n            ctx.moveTo(0, -outlineSize);\n            ctx.lineTo(0, outlineSize);\n            ctx.stroke();\n            ctx.beginPath();\n            ctx.strokeStyle = \"white\";\n            ctx.lineWidth = hasFocus ? 3 : 1;\n            ctx.shadowColor = \"black\";\n            ctx.shadowBlur = hasFocus ? 7 : 5;\n            ctx.moveTo(-crossSize, 0);\n            ctx.lineTo(crossSize, 0);\n            ctx.moveTo(0, -crossSize);\n            ctx.lineTo(0, crossSize);\n            ctx.stroke();\n        };\n        context.addCanvasDecoration({ position, drawDecoration });\n    }\n    drawHandle(context, hasFocus) {\n        if (context.viewport !== this.viewTool.viewport)\n            return;\n        if (!this.viewTool.targetCenterLocked && !this.viewTool.inHandleModify)\n            return; // Don't display default target center, will be updated to use pick point on element...\n        if (hasFocus && this.viewTool.inHandleModify)\n            return; // Cross display handled by preview depth point...\n        let sizeInches = 0.2;\n        if (!hasFocus && this.viewTool.inHandleModify) {\n            const hitHandle = this.viewTool.viewHandles.hitHandle;\n            if (undefined !== hitHandle && ViewHandleType.Rotate !== hitHandle.handleType)\n                return; // Only display when modifying another handle if that handle is rotate (not pan)...\n            sizeInches = 0.1; // Display small target when dragging...\n        }\n        const crossSize = context.viewport.pixelsFromInches(sizeInches);\n        ViewTargetCenter.drawCross(context, this.viewTool.targetCenterWorld, crossSize, hasFocus);\n    }\n    doManipulation(ev, inDynamics) {\n        if (inDynamics || ev.viewport !== this.viewTool.viewport)\n            return false;\n        this.pickDepthPoint(ev);\n        this.viewTool.setTargetCenterWorld(undefined !== this._depthPoint ? this._depthPoint : ev.point, true, ev.isControlKey); // Lock target for just this tool instance, only save if control is down...\n        return false; // false means don't do screen update\n    }\n    /** @internal */\n    needDepthPoint(_ev, _isPreview) {\n        const focusHandle = this.viewTool.inHandleModify ? this.viewTool.viewHandles.focusHandle : undefined;\n        return (undefined !== focusHandle && ViewHandleType.TargetCenter === focusHandle.handleType);\n    }\n}\n/** A ViewingToolHandle with inertia.\n * If the handle is used with *throwing action* (mouse is moving when button goes up or via a touch with movement).\n * it continues to move briefly causing the operation to continue.\n */\nclass HandleWithInertia extends ViewingToolHandle {\n    doManipulation(ev, inDynamics) {\n        if (ToolSettings.viewingInertia.enabled && !inDynamics && undefined !== this._inertiaVec)\n            return this.beginAnimation();\n        const thisPtNpc = ev.viewport.worldToNpc(ev.point);\n        thisPtNpc.z = this._lastPtNpc.z;\n        this._inertiaVec = undefined;\n        if (this._lastPtNpc.isAlmostEqual(thisPtNpc, 1.0e-10))\n            return true;\n        this._inertiaVec = this._lastPtNpc.vectorTo(thisPtNpc);\n        return this.perform(thisPtNpc);\n    }\n    /** Set this handle to become the Viewport's animator */\n    beginAnimation() {\n        this._duration = ToolSettings.viewingInertia.duration;\n        if (this._duration.isTowardsFuture) { // ensure duration is towards future. Otherwise, don't start animation\n            this._end = BeTimePoint.fromNow(this._duration);\n            this.viewTool.viewport.setAnimator(this);\n        }\n        return true;\n    }\n    /** Move this handle during the inertia duration */\n    animate() {\n        if (undefined === this._inertiaVec)\n            return true; // handle was removed\n        // get the fraction of the inertia duration that remains. The decay is a combination of the number of iterations (see damping below)\n        // and time. That way the handle slows down even if the framerate is lower.\n        const remaining = ((this._end.milliseconds - BeTimePoint.now().milliseconds) / this._duration.milliseconds);\n        const pt = this._lastPtNpc.plusScaled(this._inertiaVec, remaining);\n        // if we're not moving any more, or if the duration has elapsed, we're done\n        if (remaining <= 0 || (this._lastPtNpc.minus(pt).magnitudeSquared() < .000001)) {\n            this.viewTool.viewport.saveViewUndo();\n            return true; // remove this as the animator\n        }\n        this.perform(pt); // perform the viewing operation\n        inertialDampen(this._inertiaVec);\n        return false;\n    }\n    interrupt() { }\n}\n/** ViewingToolHandle for performing the \"pan view\" operation */\nclass ViewPan extends HandleWithInertia {\n    get handleType() { return ViewHandleType.Pan; }\n    getHandleCursor() { return this.viewTool.inHandleModify ? IModelApp.viewManager.grabbingCursor : IModelApp.viewManager.grabCursor; }\n    firstPoint(ev) {\n        const tool = this.viewTool;\n        const vp = tool.viewport;\n        vp.worldToNpc(ev.point, this._lastPtNpc);\n        this._inertiaVec = undefined;\n        // if the camera is on, we need to find the element under the starting point to get the z\n        if (this.needDepthPoint(ev, false)) {\n            this.pickDepthPoint(ev);\n            if (undefined !== this._depthPoint)\n                vp.worldToNpc(this._depthPoint, this._lastPtNpc);\n            else\n                this._lastPtNpc.z = ViewManip.getFocusPlaneNpc(vp);\n        }\n        tool.beginDynamicUpdate();\n        tool.provideToolAssistance(\"Pan.Prompts.NextPoint\");\n        return true;\n    }\n    testHandleForHit(_ptScreen, out) {\n        out.distance = 0.0;\n        out.priority = 1 /* ViewManipPriority.Low */;\n        return true;\n    }\n    /** perform the view pan operation */\n    perform(thisPtNpc) {\n        const tool = this.viewTool;\n        const vp = tool.viewport;\n        const view = vp.view;\n        const lastWorld = vp.npcToWorld(this._lastPtNpc);\n        const thisWorld = vp.npcToWorld(thisPtNpc);\n        const dist = thisWorld.vectorTo(lastWorld);\n        if (view.is3d()) {\n            if (ViewStatus.Success !== (vp.viewingGlobe ? view.moveCameraGlobal(lastWorld, thisWorld) : view.moveCameraWorld(dist)))\n                return false;\n            this.changeFocusFromDepthPoint(); // if we have a valid depth point, set it focus distance from it\n        }\n        else {\n            view.setOrigin(view.getOrigin().plus(dist));\n        }\n        vp.setupFromView();\n        this._lastPtNpc.setFrom(thisPtNpc);\n        return true;\n    }\n    /** @internal */\n    needDepthPoint(ev, _isPreview) {\n        return ev.viewport.isCameraOn && CoordSource.User === ev.coordsFrom;\n    }\n}\n/** ViewingToolHandle for performing the \"rotate view\" operation */\nclass ViewRotate extends HandleWithInertia {\n    constructor() {\n        super(...arguments);\n        this._frustum = new Frustum();\n        this._activeFrustum = new Frustum();\n        this._anchorPtNpc = new Point3d();\n    }\n    get handleType() { return ViewHandleType.Rotate; }\n    getHandleCursor() { return IModelApp.viewManager.rotateCursor; }\n    testHandleForHit(_ptScreen, out) {\n        out.distance = 0.0;\n        out.priority = 100 /* ViewManipPriority.Medium */; // Always prefer over pan handle which is only force enabled by IdleTool middle button action...\n        return true;\n    }\n    firstPoint(ev) {\n        this._inertiaVec = undefined;\n        const tool = this.viewTool;\n        const vp = ev.viewport;\n        this.pickDepthPoint(ev);\n        if (undefined !== this._depthPoint)\n            tool.setTargetCenterWorld(this._depthPoint, false, false);\n        vp.worldToNpc(ev.rawPoint, this._anchorPtNpc);\n        this._lastPtNpc.setFrom(this._anchorPtNpc);\n        vp.getFrustum(CoordSystem.World, false, this._activeFrustum);\n        this._frustum.setFrom(this._activeFrustum);\n        tool.beginDynamicUpdate();\n        this.viewTool.provideToolAssistance(\"Rotate.Prompts.NextPoint\");\n        return true;\n    }\n    perform(ptNpc) {\n        const tool = this.viewTool;\n        const vp = tool.viewport;\n        if (this._anchorPtNpc.isAlmostEqual(ptNpc, 1.0e-2)) // too close to anchor pt\n            ptNpc.setFrom(this._anchorPtNpc);\n        const currentFrustum = vp.getFrustum(CoordSystem.World, false);\n        const frustumChange = !currentFrustum.equals(this._activeFrustum);\n        if (frustumChange)\n            this._frustum.setFrom(currentFrustum);\n        else {\n            if (!vp.setupViewFromFrustum(this._frustum))\n                return false;\n        }\n        const currPt = vp.npcToView(ptNpc);\n        if (frustumChange)\n            this._anchorPtNpc.setFrom(ptNpc);\n        const view = vp.view;\n        let angle;\n        let worldAxis;\n        const worldPt = tool.targetCenterWorld;\n        if (!view.allow3dManipulations()) {\n            const centerPt = vp.worldToView(worldPt);\n            const firstPt = vp.npcToView(this._anchorPtNpc);\n            const vector0 = Vector2d.createStartEnd(centerPt, firstPt);\n            const vector1 = Vector2d.createStartEnd(centerPt, currPt);\n            angle = vector0.angleTo(vector1);\n            worldAxis = Vector3d.unitZ();\n        }\n        else {\n            const viewRect = vp.viewRect;\n            vp.npcToView(ptNpc, currPt);\n            const firstPt = vp.npcToView(this._anchorPtNpc);\n            const xDelta = (currPt.x - firstPt.x);\n            const yDelta = (currPt.y - firstPt.y);\n            // Movement in screen x == rotation about drawing Z (preserve up) or rotation about screen  Y...\n            const xAxis = ToolSettings.preserveWorldUp && !vp.viewingGlobe ? (undefined !== this._depthPoint ? vp.view.getUpVector(this._depthPoint) : Vector3d.unitZ()) : vp.rotation.getRow(1);\n            // Movement in screen y == rotation about screen X...\n            const yAxis = vp.rotation.getRow(0);\n            const xRMatrix = xDelta ? Matrix3d.createRotationAroundVector(xAxis, Angle.createRadians(Math.PI / (viewRect.width / xDelta))) : Matrix3d.identity;\n            const yRMatrix = yDelta ? Matrix3d.createRotationAroundVector(yAxis, Angle.createRadians(Math.PI / (viewRect.height / yDelta))) : Matrix3d.identity;\n            const worldRMatrix = yRMatrix.multiplyMatrixMatrix(xRMatrix);\n            const result = worldRMatrix.getAxisAndAngleOfRotation();\n            angle = Angle.createRadians(-result.angle.radians);\n            worldAxis = result.axis;\n        }\n        const worldMatrix = Matrix3d.createRotationAroundVector(worldAxis, angle);\n        if (undefined !== worldMatrix) {\n            const worldTransform = Transform.createFixedPointAndMatrix(worldPt, worldMatrix);\n            const frustum = this._frustum.transformBy(worldTransform);\n            view.setupFromFrustum(frustum);\n            if (view.is3d())\n                view.alignToGlobe(view.getCenter());\n            this.changeFocusFromDepthPoint(); // if we have a valid depth point, set it focus distance from it\n            vp.setupFromView();\n        }\n        vp.getWorldFrustum(this._activeFrustum);\n        this._lastPtNpc.setFrom(ptNpc);\n        return true;\n    }\n    onWheel(ev) {\n        // When rotate is active, the mouse wheel should zoom about the target center when it's displayed...\n        const tool = this.viewTool;\n        if (tool.targetCenterLocked || tool.inHandleModify) {\n            ev.point = tool.targetCenterWorld;\n            ev.coordsFrom = CoordSource.Precision; // WheelEventProcessor.doZoom checks this to decide whether to use raw or adjusted point...\n        }\n        return false;\n    }\n    /** @internal */\n    needDepthPoint(ev, _isPreview) {\n        return (!this.viewTool.targetCenterLocked && ev.viewport.view.allow3dManipulations());\n    }\n    /** @internal */\n    adjustDepthPoint(isValid, vp, plane, source) {\n        if (vp.viewingGlobe && this.viewTool.isPointVisible(vp.iModel.ecefLocation.earthCenter)) {\n            plane.getOriginRef().setFrom(vp.iModel.ecefLocation.earthCenter);\n            plane.getNormalRef().setFrom(vp.view.getZVector());\n            return true;\n        }\n        if (super.adjustDepthPoint(isValid, vp, plane, source))\n            return true;\n        plane.getOriginRef().setFrom(this.viewTool.targetCenterWorld);\n        return false;\n    }\n}\n/** ViewingToolHandle for performing the \"look view\" operation */\nclass ViewLook extends ViewingToolHandle {\n    constructor() {\n        super(...arguments);\n        this._eyePoint = new Point3d();\n        this._firstPtView = new Point3d();\n        this._rotation = new Matrix3d();\n        this._frustum = new Frustum();\n    }\n    get handleType() { return ViewHandleType.Look; }\n    getHandleCursor() { return IModelApp.viewManager.lookCursor; }\n    testHandleForHit(_ptScreen, out) {\n        out.distance = 0.0;\n        out.priority = 100 /* ViewManipPriority.Medium */; // Always prefer over pan handle which is only force enabled by IdleTool middle button action...\n        return true;\n    }\n    firstPoint(ev) {\n        const tool = this.viewTool;\n        const vp = ev.viewport;\n        const view = vp.view;\n        if (!view || !view.is3d() || !view.allow3dManipulations())\n            return false;\n        this._firstPtView.setFrom(ev.viewPoint);\n        this._eyePoint.setFrom(view.getEyePoint());\n        this._rotation.setFrom(vp.rotation);\n        vp.getWorldFrustum(this._frustum);\n        tool.beginDynamicUpdate();\n        this.viewTool.provideToolAssistance(\"Look.Prompts.NextPoint\");\n        return true;\n    }\n    onWheel(_ev) {\n        const tool = this.viewTool;\n        if (!tool.inHandleModify)\n            return false;\n        tool.nPts = 0; // start over\n        tool.inHandleModify = false;\n        tool.inDynamicUpdate = false;\n        tool.viewHandles.setFocus(-1);\n        return false;\n    }\n    doManipulation(ev, _inDynamics) {\n        const tool = this.viewTool;\n        const viewport = tool.viewport;\n        if (ev.viewport !== viewport)\n            return false;\n        const worldTransform = this.getLookTransform(viewport, this._firstPtView, ev.viewPoint);\n        const frustum = this._frustum.transformBy(worldTransform);\n        this.viewTool.viewport.setupViewFromFrustum(frustum);\n        return true;\n    }\n    getLookTransform(vp, firstPt, currPt) {\n        const viewRect = vp.viewRect;\n        const xExtent = viewRect.width;\n        const yExtent = viewRect.height;\n        const xDelta = (currPt.x - firstPt.x);\n        const yDelta = (currPt.y - firstPt.y);\n        const xAngle = -(xDelta / xExtent) * Math.PI;\n        const yAngle = -(yDelta / yExtent) * Math.PI;\n        const inverseRotation = this._rotation.inverse();\n        const horizontalRotation = Matrix3d.createRotationAroundVector(Vector3d.unitZ(), Angle.createRadians(xAngle));\n        const verticalRotation = Matrix3d.createRotationAroundVector(Vector3d.unitX(), Angle.createRadians(yAngle));\n        if (undefined === inverseRotation || undefined === horizontalRotation || undefined === verticalRotation)\n            return Transform.createIdentity();\n        verticalRotation.multiplyMatrixMatrix(this._rotation, verticalRotation);\n        inverseRotation.multiplyMatrixMatrix(verticalRotation, verticalRotation);\n        const newRotation = horizontalRotation.multiplyMatrixMatrix(verticalRotation);\n        const transform = Transform.createFixedPointAndMatrix(this._eyePoint, newRotation);\n        return transform;\n    }\n}\n/** handle for tools that animate a frustum change based on the position of the cursor relative to an anchor point. */\nclass AnimatedHandle extends ViewingToolHandle {\n    constructor() {\n        super(...arguments);\n        this._anchorPtView = new Point3d();\n        this._lastPtView = new Point3d();\n        this._lastMotionTime = 0;\n        this._deadZone = 36;\n    }\n    testHandleForHit(_ptScreen, out) {\n        out.distance = 0.0;\n        out.priority = 100 /* ViewManipPriority.Medium */;\n        return true;\n    }\n    getElapsedTime() {\n        const prev = this._lastMotionTime;\n        this._lastMotionTime = Date.now();\n        return Geometry.clamp(this._lastMotionTime - prev, 0, 1000) / 1000;\n    }\n    // called on mouse motion\n    doManipulation(ev) {\n        this._lastPtView.setFrom(ev.viewPoint);\n        return true;\n    }\n    // called when animation is interrupted\n    interrupt() { }\n    animate() {\n        // Don't continue animation when mouse is outside view, and don't jump if it returns...\n        if (undefined !== IModelApp.toolAdmin.cursorView)\n            return true;\n        this.getElapsedTime();\n        return false;\n    }\n    firstPoint(ev) {\n        const vp = ev.viewport;\n        const tool = this.viewTool;\n        tool.inDynamicUpdate = true;\n        if (vp && this.needDepthPoint(ev, false)) {\n            this.pickDepthPoint(ev);\n            if (undefined !== this._depthPoint) {\n                vp.worldToView(this._depthPoint, this._anchorPtView);\n            }\n            else {\n                vp.worldToNpc(ev.point, this._anchorPtView);\n                this._anchorPtView.z = ViewManip.getFocusPlaneNpc(vp);\n                vp.npcToView(this._anchorPtView, this._anchorPtView);\n            }\n        }\n        else {\n            this._anchorPtView.setFrom(ev.viewPoint);\n        }\n        this._lastPtView.setFrom(this._anchorPtView);\n        this._lastMotionTime = Date.now();\n        tool.viewport.setAnimator(this);\n        return true;\n    }\n    getDirection() {\n        const dir = this._anchorPtView.vectorTo(this._lastPtView);\n        dir.z = 0;\n        return dir.magnitudeSquared() < this._deadZone ? undefined : dir; // dead zone around starting point\n    }\n    getInputVector() {\n        const dir = this.getDirection();\n        if (undefined === dir)\n            return undefined;\n        const viewRect = this.viewTool.viewport.viewRect;\n        return new Vector3d(dir.x * (2.0 / viewRect.width), dir.y * (2.0 / viewRect.height));\n    }\n    onReinitialize() {\n        const tool = this.viewTool;\n        tool.inDynamicUpdate = false;\n        const vp = tool.viewport;\n        if (undefined !== vp)\n            vp.setAnimator();\n    }\n    // called when wheel rolls, reset tool\n    onWheel(_ev) {\n        const tool = this.viewTool;\n        tool.nPts = 0; // start over\n        tool.inDynamicUpdate = false; // not active\n        return false;\n    }\n}\n/** ViewingToolHandle for performing the \"scroll view\" operation */\nclass ViewScroll extends AnimatedHandle {\n    get handleType() { return ViewHandleType.Scroll; }\n    getHandleCursor() { return \"move\"; }\n    drawHandle(context, _hasFocus) {\n        if (context.viewport !== this.viewTool.viewport || !this.viewTool.inDynamicUpdate)\n            return;\n        const radius = Math.floor(context.viewport.pixelsFromInches(0.1)) + 0.5;\n        const position = this._anchorPtView.clone();\n        const position2 = this._lastPtView.clone();\n        const offset = position2.minus(position);\n        const drawDecoration = (ctx) => {\n            ctx.beginPath();\n            ctx.strokeStyle = \"rgba(0,255,0,.3)\";\n            ctx.setLineDash([10, 4]);\n            ctx.lineWidth = 3;\n            ctx.moveTo(0, 0);\n            ctx.lineTo(offset.x, offset.y);\n            ctx.stroke();\n            ctx.beginPath();\n            ctx.setLineDash([]);\n            ctx.strokeStyle = \"rgba(0,0,0,.5)\";\n            ctx.lineWidth = 1;\n            ctx.fillStyle = \"rgba(255,255,255,.5)\";\n            ctx.arc(0, 0, radius, 0, 2 * Math.PI);\n            ctx.fill();\n            ctx.stroke();\n            let vec = Vector2d.createStartEnd(position, position2);\n            if (undefined === vec)\n                vec = Vector2d.unitX();\n            else\n                vec.normalize(vec);\n            const slashPts = [new Point2d(), new Point2d()];\n            slashPts[0].plusScaled(vec, radius, slashPts[0]);\n            slashPts[1].plusScaled(vec, -radius, slashPts[1]);\n            ctx.beginPath();\n            ctx.strokeStyle = \"black\";\n            ctx.lineWidth = 2;\n            ctx.moveTo(slashPts[0].x, slashPts[0].y);\n            ctx.lineTo(slashPts[1].x, slashPts[1].y);\n            ctx.stroke();\n        };\n        context.addCanvasDecoration({ position, drawDecoration }, true);\n    }\n    firstPoint(ev) {\n        super.firstPoint(ev);\n        this.viewTool.provideToolAssistance(\"Scroll.Prompts.NextPoint\");\n        return true;\n    }\n    animate() {\n        if (!super.animate())\n            return false;\n        const dist = this.getDirection();\n        if (undefined === dist)\n            return false;\n        dist.scaleInPlace(ToolSettings.scrollSpeed * this.getElapsedTime());\n        const tool = this.viewTool;\n        const viewport = tool.viewport;\n        if (viewport.isCameraOn) {\n            const points = new Array(2);\n            points[0] = this._anchorPtView.clone();\n            points[1] = points[0].plus(dist);\n            viewport.viewToNpcArray(points);\n            points[1].z = points[0].z;\n            viewport.npcToWorldArray(points);\n            const offset = points[1].minus(points[0]);\n            const offsetTransform = Transform.createTranslation(offset);\n            const frustum = viewport.getWorldFrustum();\n            frustum.transformBy(offsetTransform, frustum);\n            viewport.setupViewFromFrustum(frustum);\n        }\n        else {\n            viewport.scroll(dist, { noSaveInUndo: true });\n        }\n        return false;\n    }\n    /** @internal */\n    needDepthPoint(ev, _isPreview) {\n        return ev.viewport.isCameraOn && CoordSource.User === ev.coordsFrom;\n    }\n}\n/** ViewingToolHandle for performing the \"zoom view\" operation */\nclass ViewZoom extends ViewingToolHandle {\n    constructor() {\n        super(...arguments);\n        this._anchorPtNpc = new Point3d();\n        this._anchorPtView = new Point3d();\n        this._anchorPtWorld = new Point3d();\n        this._lastPtView = new Point3d();\n        this._startEyePoint = new Point3d();\n        this._lastZoomRatio = 1.0;\n    }\n    get handleType() { return ViewHandleType.Zoom; }\n    getHandleCursor() { return IModelApp.viewManager.zoomCursor; }\n    testHandleForHit(_ptScreen, out) {\n        out.distance = 0.0;\n        out.priority = 100 /* ViewManipPriority.Medium */; // Always prefer over pan handle which is only force enabled by IdleTool middle button action...\n        return true;\n    }\n    drawHandle(context, hasFocus) {\n        if (!hasFocus || context.viewport !== this.viewTool.viewport || !this.viewTool.inDynamicUpdate)\n            return;\n        const radius = Math.floor(context.viewport.pixelsFromInches(0.15)) + 0.5;\n        const crossRadius = radius * 0.6;\n        const position = this._anchorPtView.clone();\n        position.x = Math.floor(position.x) + 0.5;\n        position.y = Math.floor(position.y) + 0.5;\n        const drawDecoration = (ctx) => {\n            ctx.beginPath();\n            ctx.strokeStyle = \"rgba(0,0,0,.5)\";\n            ctx.lineWidth = 1;\n            ctx.fillStyle = \"rgba(255,255,255,.5)\";\n            ctx.arc(0, 0, radius, 0, 2 * Math.PI);\n            ctx.fill();\n            ctx.stroke();\n            ctx.beginPath();\n            ctx.strokeStyle = \"black\";\n            ctx.lineWidth = 2;\n            ctx.moveTo(-crossRadius, 0);\n            ctx.lineTo(crossRadius, 0);\n            if (this._lastZoomRatio < 1.0) {\n                ctx.moveTo(0, -crossRadius);\n                ctx.lineTo(0, crossRadius);\n            }\n            ctx.stroke();\n        };\n        context.addCanvasDecoration({ position, drawDecoration }, true);\n    }\n    firstPoint(ev) {\n        const vp = ev.viewport;\n        this.viewTool.inDynamicUpdate = true;\n        if (this.needDepthPoint(ev, false)) {\n            this.pickDepthPoint(ev);\n            if (undefined !== this._depthPoint) {\n                vp.worldToView(this._depthPoint, this._anchorPtView);\n            }\n            else {\n                vp.worldToNpc(ev.point, this._anchorPtView);\n                this._anchorPtView.z = ViewManip.getFocusPlaneNpc(vp);\n                vp.npcToView(this._anchorPtView, this._anchorPtView);\n            }\n        }\n        else {\n            this._anchorPtView.setFrom(ev.viewPoint);\n        }\n        this._lastPtView.setFrom(this._anchorPtView);\n        vp.viewToNpc(this._anchorPtView, this._anchorPtNpc);\n        vp.viewToWorld(this._anchorPtView, this._anchorPtWorld);\n        this._startFrust = vp.getWorldFrustum();\n        if (vp.view.is3d() && vp.view.isCameraOn)\n            this._startEyePoint.setFrom(vp.view.getEyePoint());\n        this.viewTool.provideToolAssistance(\"Zoom.Prompts.NextPoint\");\n        return true;\n    }\n    onWheel(_ev) {\n        const tool = this.viewTool;\n        if (!tool.inHandleModify)\n            return false;\n        tool.nPts = 0; // start over\n        tool.inHandleModify = false;\n        tool.inDynamicUpdate = false;\n        tool.viewHandles.setFocus(-1);\n        return false;\n    }\n    getDirection() {\n        const dir = this._anchorPtView.vectorTo(this._lastPtView);\n        dir.z = 0;\n        return dir.magnitudeSquared() < 36 ? undefined : dir; // dead zone around starting point\n    }\n    doManipulation(ev) {\n        this._lastPtView.setFrom(ev.viewPoint);\n        if (undefined === this._startFrust || undefined === this.getDirection()) // on anchor point?\n            return false;\n        const viewport = this.viewTool.viewport;\n        const view = viewport.view;\n        const thisPtNpc = viewport.viewToNpc(this._lastPtView);\n        const dist = this._anchorPtNpc.minus(thisPtNpc);\n        dist.z = 0.0;\n        dist.x = 0.0;\n        let zoomRatio = 1.0 + (dist.magnitude() * ToolSettings.zoomSpeed);\n        if (dist.y > 0)\n            zoomRatio = 1.0 / zoomRatio;\n        this._lastZoomRatio = zoomRatio;\n        const frustum = this._startFrust.clone();\n        const transform = Transform.createFixedPointAndMatrix(this._anchorPtWorld, Matrix3d.createScale(zoomRatio, zoomRatio, view.is3d() ? zoomRatio : 1.0));\n        if (view.is3d() && view.isCameraOn) {\n            const oldEyePoint = this._startEyePoint;\n            const newEyePoint = transform.multiplyPoint3d(oldEyePoint);\n            const cameraOffset = Vector3d.createStartEnd(oldEyePoint, newEyePoint);\n            Transform.createTranslation(cameraOffset, transform);\n        }\n        frustum.transformBy(transform, frustum);\n        if (ViewStatus.Success !== view.setupFromFrustum(frustum))\n            return false;\n        if (view.is3d() && view.isCameraOn)\n            this.changeFocusFromDepthPoint(); // if we have a valid depth point, set it focus distance from it\n        return ViewStatus.Success === viewport.setupFromView();\n    }\n    /** @internal */\n    needDepthPoint(ev, _isPreview) {\n        return ev.viewport.isCameraOn && CoordSource.User === ev.coordsFrom;\n    }\n}\n/** @internal */\nclass NavigateMotion {\n    constructor(viewport) {\n        this.viewport = viewport;\n        this._seconds = 0;\n        this.transform = Transform.createIdentity();\n    }\n    init(seconds) {\n        this._seconds = seconds;\n        this.transform.setIdentity();\n    }\n    getViewUp(result) { return this.viewport.rotation.getRow(1, result); }\n    getViewDirection(result) {\n        const forward = this.viewport.rotation.getRow(2, result);\n        forward.scale(-1, forward); // positive z is out of the screen, but we want direction into the screen\n        return forward;\n    }\n    takeElevator(height) {\n        const up = Point3d.create(0, 0, height * this._seconds);\n        Transform.createTranslation(up, this.transform);\n    }\n    modifyPitchAngleToPreventInversion(pitchAngle) {\n        const angleLimit = Angle.degreesToRadians(85);\n        const angleTolerance = Angle.degreesToRadians(0.01);\n        if (0.0 === pitchAngle)\n            return 0.0;\n        const viewUp = this.getViewUp();\n        const viewDir = this.getViewDirection();\n        const worldUp = Vector3d.unitZ();\n        let viewAngle = worldUp.angleTo(viewUp).radians;\n        if (viewDir.z < 0)\n            viewAngle *= -1;\n        let newAngle = pitchAngle + viewAngle;\n        if (Math.abs(newAngle) < angleLimit)\n            return pitchAngle; // not close to the limit\n        if ((pitchAngle > 0) !== (viewAngle > 0) && (Math.abs(pitchAngle) < Math.PI / 2))\n            return pitchAngle; // tilting away from the limit\n        if (Math.abs(viewAngle) >= (angleLimit - angleTolerance))\n            return 0.0; // at the limit already\n        const difference = Math.abs(newAngle) - angleLimit;\n        newAngle = (pitchAngle > 0) ? pitchAngle - difference : pitchAngle + difference;\n        return newAngle; // almost at the limit, but still can go a little bit closer\n    }\n    generateMouseLookTransform(accumulator, movement, result) {\n        const vp = this.viewport;\n        const view = vp.view;\n        if (!view.is3d() || !vp.isCameraOn)\n            return Transform.createIdentity();\n        const viewRect = this.viewport.viewRect;\n        const xExtent = viewRect.width;\n        const yExtent = viewRect.height;\n        accumulator.z += this._seconds; // accumulate time delta since start...\n        const snappiness = 10.0; // larger values are more responsive...\n        const fraction = Geometry.clamp(snappiness * accumulator.z, 0.0, 1.0);\n        accumulator.x = Geometry.interpolate(accumulator.x, fraction, movement.x);\n        accumulator.y = Geometry.interpolate(accumulator.y, fraction, movement.y);\n        const xAngle = -(accumulator.x / xExtent) * Math.PI * 2.0;\n        const yAngle = -(accumulator.y / yExtent) * Math.PI;\n        const viewRot = vp.rotation;\n        const invViewRot = viewRot.inverse();\n        const pitchAngle = Angle.createRadians(this.modifyPitchAngleToPreventInversion(yAngle));\n        const pitchMatrix = Matrix3d.createRotationAroundVector(Vector3d.unitX(), pitchAngle);\n        const pitchTimesView = pitchMatrix.multiplyMatrixMatrix(viewRot);\n        const inverseViewTimesPitchTimesView = invViewRot.multiplyMatrixMatrix(pitchTimesView);\n        const yawMatrix = Matrix3d.createRotationAroundVector(Vector3d.unitZ(), Angle.createRadians(xAngle));\n        const yawTimesInverseViewTimesPitchTimesView = yawMatrix.multiplyMatrixMatrix(inverseViewTimesPitchTimesView);\n        return Transform.createFixedPointAndMatrix(view.getEyePoint(), yawTimesInverseViewTimesPitchTimesView, result);\n    }\n    generateRotationTransform(yawRate, pitchRate, result) {\n        const vp = this.viewport;\n        const view = vp.view;\n        if (!view.is3d() || !vp.isCameraOn)\n            return Transform.createIdentity();\n        const viewRot = vp.rotation;\n        const invViewRot = viewRot.inverse();\n        const pitchAngle = Angle.createRadians(this.modifyPitchAngleToPreventInversion(pitchRate * this._seconds));\n        const pitchMatrix = Matrix3d.createRotationAroundVector(Vector3d.unitX(), pitchAngle);\n        const pitchTimesView = pitchMatrix.multiplyMatrixMatrix(viewRot);\n        const inverseViewTimesPitchTimesView = invViewRot.multiplyMatrixMatrix(pitchTimesView);\n        const yawMatrix = Matrix3d.createRotationAroundVector(Vector3d.unitZ(), Angle.createRadians(yawRate * this._seconds));\n        const yawTimesInverseViewTimesPitchTimesView = yawMatrix.multiplyMatrixMatrix(inverseViewTimesPitchTimesView);\n        return Transform.createFixedPointAndMatrix(view.getEyePoint(), yawTimesInverseViewTimesPitchTimesView, result);\n    }\n    generateTranslationTransform(velocity, isConstrainedToXY, result) {\n        const points = new Array(3);\n        points[0] = new Point3d(0, 0, 0);\n        points[1] = new Point3d(1, 0, 0);\n        points[2] = new Point3d(0, 1, 0);\n        if (this.viewport.isCameraOn) {\n            this.viewport.viewToNpcArray(points);\n            points[0].z = points[1].z = points[2].z = ViewManip.getFocusPlaneNpc(this.viewport); // use the focal plane for z coordinates\n            this.viewport.npcToViewArray(points);\n        }\n        this.viewport.viewToWorldArray(points);\n        const xDir = Vector3d.createStartEnd(points[0], points[1]);\n        xDir.normalizeInPlace();\n        const yDir = Vector3d.createStartEnd(points[0], points[2]);\n        yDir.normalizeInPlace();\n        const zDir = this.getViewDirection();\n        if (isConstrainedToXY) {\n            const up = Vector3d.unitZ();\n            const cross = up.crossProduct(zDir);\n            cross.crossProduct(up, zDir);\n            zDir.normalizeInPlace();\n        }\n        xDir.scale(velocity.x * this._seconds, xDir);\n        yDir.scale(velocity.y * this._seconds, yDir);\n        zDir.scale(velocity.z * this._seconds, zDir);\n        xDir.plus(yDir, xDir).plus(zDir, xDir);\n        return Transform.createTranslation(xDir, result);\n    }\n    moveAndMouseLook(accumulator, linearVelocity, movement, isConstrainedToXY) {\n        const rotateTrans = this.generateMouseLookTransform(accumulator, movement);\n        const dollyTrans = this.generateTranslationTransform(linearVelocity, isConstrainedToXY);\n        this.transform.setMultiplyTransformTransform(rotateTrans, dollyTrans);\n        return (accumulator.x >= movement.x && accumulator.y >= movement.y);\n    }\n    moveAndLook(linearVelocity, angularVelocityX, angularVelocityY, isConstrainedToXY) {\n        const rotateTrans = this.generateRotationTransform(angularVelocityX, angularVelocityY);\n        const dollyTrans = this.generateTranslationTransform(linearVelocity, isConstrainedToXY);\n        this.transform.setMultiplyTransformTransform(rotateTrans, dollyTrans);\n    }\n    pan(horizontalVelocity, verticalVelocity) {\n        const travel = new Vector3d(horizontalVelocity, verticalVelocity, 0);\n        this.moveAndLook(travel, 0, 0, false);\n    }\n    travel(yawRate, pitchRate, forwardVelocity, isConstrainedToXY) {\n        const travel = new Vector3d(0, 0, forwardVelocity);\n        this.moveAndLook(travel, yawRate, pitchRate, isConstrainedToXY);\n    }\n    look(yawRate, pitchRate) { this.generateRotationTransform(yawRate, pitchRate, this.transform); }\n    /** reset pitch of view to zero */\n    resetToLevel() {\n        const view = this.viewport.view;\n        if (!view.is3d() || !view.isCameraOn)\n            return;\n        const angles = YawPitchRollAngles.createFromMatrix3d(this.viewport.rotation);\n        angles.pitch.setRadians(0); // reset pitch to zero\n        Transform.createFixedPointAndMatrix(view.getEyePoint(), angles.toMatrix3d(), this.transform);\n    }\n}\n/** ViewingToolHandle for performing the Walk and Fly operations */\nclass ViewNavigate extends AnimatedHandle {\n    constructor() {\n        super(...arguments);\n        this._initialized = false;\n    }\n    getHandleCursor() { return IModelApp.viewManager.walkCursor; }\n    getMaxLinearVelocity() { return ToolSettings.walkVelocity; }\n    getMaxAngularVelocity() { return Math.PI / 4; }\n    getNavigateMode() {\n        const state = IModelApp.toolAdmin.currentInputState;\n        return (state.isShiftDown || !this.viewTool.viewport.isCameraOn) ? 0 /* NavigateMode.Pan */ :\n            state.isControlDown ? 1 /* NavigateMode.Look */ : 2 /* NavigateMode.Travel */;\n    }\n    // called in animation loop\n    animate() {\n        if (!super.animate())\n            return false;\n        const motion = this.getNavigateMotion(this.getElapsedTime());\n        if (undefined !== motion) {\n            const vp = this.viewTool.viewport;\n            const frust = vp.getWorldFrustum();\n            frust.multiply(motion.transform);\n            vp.setupViewFromFrustum(frust);\n        }\n        return false;\n    }\n    onReinitialize() {\n        super.onReinitialize();\n        if (this._initialized)\n            return;\n        this._initialized = true;\n        const tool = this.viewTool;\n        const vp = tool.viewport;\n        if (undefined === vp)\n            return;\n        const view = vp.view;\n        if (!view.allow3dManipulations())\n            return;\n        const walkAngle = ToolSettings.walkCameraAngle;\n        if (!tool.lensAngleMatches(walkAngle, Angle.degreesToRadians(15.)) || !tool.isZUp) {\n            //  This turns on the camera if its not already on. It also assures the camera is centered. Obviously this is required if\n            //  the camera is not on or the lens angle is not what we want. We also want to do it if Z will be\n            //  adjusted because EnforceZUp swivels the camera around what GetTargetPoint returns. If the FocusDistance is not set to something\n            //  reasonable the target point may be far beyond anything relevant.\n            tool.setCameraLensAngle(walkAngle, tool.lensAngleMatches(walkAngle, Angle.degreesToRadians(45.)));\n        }\n        if (ToolSettings.walkEnforceZUp)\n            tool.enforceZUp(view.getTargetPoint());\n        vp.animateFrustumChange();\n    }\n    drawHandle(context, hasFocus) {\n        if (!hasFocus || context.viewport !== this.viewTool.viewport || !this.viewTool.inDynamicUpdate)\n            return;\n        const position = this._anchorPtView.clone();\n        position.x = Math.floor(position.x) + 0.5;\n        position.y = Math.floor(position.y) + 0.5;\n        const drawDecoration = (ctx) => {\n            ctx.beginPath();\n            ctx.strokeStyle = \"black\";\n            ctx.fillStyle = \"rgba(255,255,255,.3)\";\n            ctx.lineWidth = 1;\n            ctx.arc(0, 0, 5, 0, 2 * Math.PI);\n            ctx.stroke();\n            ctx.fill();\n        };\n        context.addCanvasDecoration({ position, drawDecoration });\n    }\n}\n/** ViewingToolHandle for looking around and moving through a model using mouse+wasd or on-screen control sticks for touch */\nclass ViewLookAndMove extends ViewNavigate {\n    constructor(viewManip) {\n        super(viewManip);\n        this._lastCollision = 0;\n        this._lastReadPt = new Point3d();\n        this._positionInput = new Vector3d();\n        this._accumulator = new Vector3d();\n        this._touchElevate = false;\n        this._touchLook = false;\n        this._touchSpeedUp = false;\n        this._havePointerLock = false;\n        this._navigateMotion = new NavigateMotion(this.viewTool.viewport);\n    }\n    get handleType() { return ViewHandleType.LookAndMove; }\n    getHandleCursor() { return IModelApp.viewManager.lookCursor; }\n    testHandleForHit(_ptScreen, out) {\n        out.distance = 0.0;\n        out.priority = 100 /* ViewManipPriority.Medium */; // Always prefer over pan handle which is only force enabled by IdleTool middle button action...\n        return true;\n    }\n    onReinitialize() {\n        super.onReinitialize();\n        this._touchStartL = this._touchStartR = this._touchLast = undefined;\n        this._touchElevate = this._touchSpeedUp = this._touchLook = false;\n        if (this.viewTool.viewHandles.testHit(Point3d.createZero(), ViewHandleType.LookAndMove))\n            this.viewTool.viewHandles.focusHitHandle(); // Ensure key events go to this handle by default w/o requiring motion...\n        this.onCleanup();\n        this.requestPointerLock(true);\n    }\n    onCleanup() {\n        super.onCleanup();\n        this.releasePointerLock();\n    }\n    async pointerLockChangeEvent() {\n        const vp = this.viewTool.viewport;\n        if (undefined !== vp && document.pointerLockElement === vp.canvas) {\n            vp.npcToView(NpcCenter, this._anchorPtView); // Display indicator in the middle of the view for pointer lock...\n            this._lastPtView.setFrom(this._anchorPtView);\n            this._havePointerLock = true;\n            vp.invalidateDecorations();\n        }\n        else {\n            // If ESC is used to disable pointer lock, exit the tool instead of continuing in drag mode...\n            if (this._havePointerLock && this.viewTool.inDynamicUpdate)\n                await this.viewTool.exitTool();\n            else\n                this._havePointerLock = false;\n        }\n    }\n    requestPointerLock(enable) {\n        if (!enable) {\n            if (undefined !== this._pointerLockClickEngagementListener) {\n                document.removeEventListener(\"click\", this._pointerLockClickEngagementListener, false);\n                this._pointerLockClickEngagementListener = undefined;\n            }\n            if (undefined !== this._pointerLockKeyEngagementListener) {\n                document.removeEventListener(\"keydown\", this._pointerLockKeyEngagementListener, false);\n                this._pointerLockKeyEngagementListener = undefined;\n            }\n            return;\n        }\n        if (!ToolSettings.walkRequestPointerLock)\n            return;\n        const vp = this.viewTool.viewport;\n        if (undefined === vp)\n            return;\n        // NOTE: Chrome appears to be the only browser that doesn't require pointer lock to be requested from an engagement event like click.\n        //       Currently pointer lock is requested for \"click\" and not \"mousedown\" since we don't want pointer lock for drag operation.\n        if (undefined === this._pointerLockChangeListener) {\n            this._pointerLockChangeListener = async () => this.pointerLockChangeEvent();\n            document.addEventListener(\"pointerlockchange\", this._pointerLockChangeListener, false);\n        }\n        if (undefined === this._pointerLockClickEngagementListener) {\n            this._pointerLockClickEngagementListener = () => {\n                if (1 === this.viewTool.nPts && undefined !== IModelApp.toolAdmin.cursorView)\n                    vp.canvas.requestPointerLock();\n            };\n            document.addEventListener(\"click\", this._pointerLockClickEngagementListener, false);\n        }\n        if (undefined === this._pointerLockKeyEngagementListener) {\n            this._pointerLockKeyEngagementListener = (ev) => {\n                if (0 === this.viewTool.nPts && undefined !== IModelApp.toolAdmin.cursorView && this.isNavigationKey(ev))\n                    vp.canvas.requestPointerLock();\n            };\n            document.addEventListener(\"keydown\", this._pointerLockKeyEngagementListener, false);\n        }\n    }\n    releasePointerLock() {\n        this._havePointerLock = false;\n        this.requestPointerLock(false);\n        if (undefined !== this._pointerLockChangeListener) {\n            document.removeEventListener(\"pointerlockchange\", this._pointerLockChangeListener, false);\n            this._pointerLockChangeListener = undefined;\n        }\n        if (null !== document.pointerLockElement && undefined !== document.exitPointerLock)\n            document.exitPointerLock();\n    }\n    firstPoint(ev) {\n        this.viewTool.provideToolAssistance(\"LookAndMove.Prompts.NextPoint\");\n        if (!super.firstPoint(ev))\n            return false;\n        const vp = this.viewTool.viewport;\n        if (undefined === vp || !vp.isCameraOn)\n            return true;\n        if (InputSource.Mouse === ev.inputSource) {\n            this._deadZone = Math.pow(vp.pixelsFromInches(0.5), 2); // Only used if pointer lock isn't supported...\n        }\n        else {\n            this._touchLook = true;\n            vp.npcToView(NpcCenter, this._anchorPtView); // Display indicator in the middle of the view for touch look...\n        }\n        return true;\n    }\n    doManipulation(ev) {\n        if (InputSource.Mouse === ev.inputSource)\n            this._lastMovement = this._havePointerLock ? ev.movement : undefined;\n        else\n            this._lastMovement = this._lastPtView.vectorTo(ev.viewPoint).scale(2.0); // ev.movement isn't available for button event created from touch event...\n        this._accumulator.setZero();\n        return super.doManipulation(ev);\n    }\n    getMaxLinearVelocity() {\n        const maxLinearVelocity = super.getMaxLinearVelocity();\n        if (0 === ToolSettings.walkVelocityChange)\n            return (this._touchSpeedUp ? maxLinearVelocity * 2.0 : maxLinearVelocity);\n        const speedFactor = Geometry.clamp(ToolSettings.walkVelocityChange + (ToolSettings.walkVelocityChange > 0 ? 1 : -1), -10, 10);\n        const speedMultiplier = (speedFactor >= 0 ? speedFactor : 1 / Math.abs(speedFactor));\n        return maxLinearVelocity * speedMultiplier;\n    }\n    getMaxAngularVelocityX() { return 2 * this.getMaxAngularVelocity(); } // Allow turning to be faster than looking up/down...\n    getMaxAngularVelocityY() { return this.getMaxAngularVelocity(); }\n    getLinearVelocity() {\n        const positionInput = Vector3d.create();\n        const vp = this.viewTool.viewport;\n        const position = this.getTouchStartPosition(this._touchStartL);\n        if (undefined !== position) {\n            const outerRadius = this.getTouchControlRadius(vp);\n            const offset = this.getTouchOffset(this._touchStartL, outerRadius);\n            const inputL = new Vector3d(offset.x * (1.0 / outerRadius), offset.y * (1.0 / outerRadius));\n            positionInput.x = inputL.x * this.getMaxLinearVelocity();\n            if (this._touchElevate)\n                positionInput.y = inputL.y * this.getMaxLinearVelocity();\n            else\n                positionInput.z = inputL.y * -this.getMaxLinearVelocity();\n            return positionInput;\n        }\n        this._positionInput.scale(this.getMaxLinearVelocity(), positionInput);\n        return positionInput;\n    }\n    getAngularVelocity() {\n        const angularInput = Vector3d.create();\n        const vp = this.viewTool.viewport;\n        const position = this.getTouchStartPosition(this._touchStartR);\n        if (undefined !== position) {\n            const outerRadius = this.getTouchControlRadius(vp);\n            const offset = this.getTouchOffset(this._touchStartR, outerRadius);\n            const inputA = new Vector3d(offset.x * (1.0 / outerRadius), offset.y * (1.0 / outerRadius));\n            angularInput.x = inputA.x * -this.getMaxAngularVelocityX();\n            angularInput.y = inputA.y * -this.getMaxAngularVelocityY();\n            return angularInput;\n        }\n        if (this._havePointerLock || this._touchLook)\n            return angularInput;\n        const input = this.getInputVector();\n        if (undefined !== input) {\n            angularInput.x = input.x * -this.getMaxAngularVelocityX();\n            angularInput.y = input.y * -this.getMaxAngularVelocityY();\n        }\n        return angularInput;\n    }\n    getHorizAndVertVelocity() {\n        const input = this.getInputVector();\n        if (undefined === input)\n            return undefined;\n        input.scale(this.getMaxLinearVelocity(), input);\n        return input;\n    }\n    computeCollisionData(vp, eyePt) {\n        const contourLine = LineString3d.create();\n        const viewPt = vp.npcToView(NpcCenter);\n        const pts = [];\n        pts[0] = new Point2d(Math.floor(viewPt.x + 0.5), vp.viewRect.top);\n        pts[1] = new Point2d(pts[0].x + 1, vp.viewRect.bottom);\n        const range = Range2d.createArray(pts);\n        let detectStepUp = false;\n        const rect = new ViewRect();\n        rect.initFromRange(range);\n        vp.readPixels(rect, Pixel.Selector.GeometryAndDistance, (pixels) => {\n            if (undefined === pixels)\n                return;\n            const sRange = Range2d.createNull();\n            sRange.extendPoint(Point2d.create(vp.cssPixelsToDevicePixels(range.low.x), vp.cssPixelsToDevicePixels(range.low.y)));\n            sRange.extendPoint(Point2d.create(vp.cssPixelsToDevicePixels(range.high.x), vp.cssPixelsToDevicePixels(range.high.y)));\n            const testPoint = Point2d.create(sRange.low.x);\n            for (testPoint.y = sRange.high.y; testPoint.y >= sRange.low.y; --testPoint.y) {\n                const pixel = pixels.getPixel(testPoint.x, testPoint.y);\n                if (pixel.distanceFraction < 0)\n                    continue; // No geometry at location...\n                const hitPointWorld = vp.getPixelDataWorldPoint({ pixels, x: testPoint.x, y: testPoint.y, preserveModelDisplayTransforms: true });\n                if (undefined === hitPointWorld)\n                    continue;\n                if (0 === contourLine.numPoints()) {\n                    if (undefined === this._lastReference) {\n                        const refPt = (ToolSettings.walkDetectFloor ? eyePt.plusScaled(Vector3d.unitZ(), -ToolSettings.walkEyeHeight) : hitPointWorld);\n                        this._lastReference = Plane3dByOriginAndUnitNormal.create(refPt, Vector3d.unitZ());\n                        detectStepUp = ToolSettings.walkDetectFloor;\n                    }\n                    else if (undefined !== this._lastContour && this._lastContour.numPoints() > 1) {\n                        let fractLo, fractHi;\n                        const forwardDir = Vector3d.unitZ().crossProduct(vp.view.getXVector());\n                        const yPlaneHi = Plane3dByOriginAndUnitNormal.create(hitPointWorld, forwardDir);\n                        if (undefined !== yPlaneHi) {\n                            yPlaneHi.getNormalRef().scaleInPlace(-1);\n                            yPlaneHi.getOriginRef().addScaledInPlace(yPlaneHi.getNormalRef(), Constant.oneCentimeter * 5);\n                            const resultHi = [];\n                            this._lastContour.appendPlaneIntersectionPoints(yPlaneHi, resultHi);\n                            for (const intersectionHi of resultHi) {\n                                if ((undefined === fractHi || intersectionHi.fraction < fractHi) && intersectionHi.point.distance(hitPointWorld) < ToolSettings.walkEyeHeight)\n                                    fractHi = intersectionHi.fraction;\n                            }\n                            if (undefined !== fractHi) {\n                                const yPlaneLo = yPlaneHi.clone();\n                                yPlaneLo.getOriginRef().addScaledInPlace(yPlaneLo.getNormalRef(), ToolSettings.walkEyeHeight * 2);\n                                const resultLo = [];\n                                this._lastContour.appendPlaneIntersectionPoints(yPlaneLo, resultLo);\n                                for (const intersectionLo of resultLo) {\n                                    if (undefined === fractLo || intersectionLo.fraction < fractLo)\n                                        fractLo = intersectionLo.fraction;\n                                }\n                                if (undefined === fractLo && yPlaneHi.altitude(this._lastContour.startPoint()) > 0)\n                                    fractLo = 0; // Include from start if last path was shorter than requested section...\n                            }\n                        }\n                        if (undefined !== fractLo && undefined !== fractHi && fractHi > fractLo) {\n                            // Keep section of last contour to account for loosing sight of what is underfoot while moving forward...\n                            const partialCurve = this._lastContour.clonePartialCurve(fractLo, fractHi);\n                            if (undefined !== partialCurve && partialCurve instanceof LineString3d)\n                                contourLine.addPoints(partialCurve.packedPoints);\n                        }\n                        else {\n                            // Moved too far from last contour...\n                            detectStepUp = true;\n                        }\n                    }\n                }\n                else if (contourLine.numPoints() > 1) {\n                    const startPt = contourLine.packedPoints.getPoint3dAtUncheckedPointIndex(contourLine.numPoints() - 2);\n                    const testPt = contourLine.packedPoints.getPoint3dAtUncheckedPointIndex(contourLine.numPoints() - 1);\n                    const fraction = testPt.fractionOfProjectionToLine(startPt, hitPointWorld, 0.0);\n                    const closePoint = startPt.interpolate(fraction, hitPointWorld);\n                    if (closePoint.isAlmostEqual(testPt, 1.0e-5)) {\n                        // Colinear point, extent segment...\n                        contourLine.packedPoints.setAtCheckedPointIndex(contourLine.numPoints() - 1, hitPointWorld);\n                        continue;\n                    }\n                }\n                contourLine.addPoint(hitPointWorld);\n            }\n        }, true);\n        // Use single point to denote \"no geometry found\" until movement is detected...\n        if (0 === contourLine.numPoints()) {\n            contourLine.addPoint(this._lastReadPt);\n        }\n        else if (detectStepUp && undefined !== this._lastReference) {\n            const start = contourLine.startPoint();\n            const forwardDir = Vector3d.unitZ().crossProduct(vp.view.getXVector());\n            const stepPlane = Plane3dByOriginAndUnitNormal.create(start.plusScaled(forwardDir, ToolSettings.walkStepHeight), forwardDir);\n            const resultStep = [];\n            if (undefined !== stepPlane)\n                contourLine.appendPlaneIntersectionPoints(stepPlane, resultStep);\n            let stepPt;\n            for (const step of resultStep) {\n                if (undefined === stepPt || step.point.z > stepPt.z)\n                    stepPt = step.point;\n            }\n            if (undefined !== stepPt) {\n                const xyDist = start.distanceXY(stepPt);\n                const zDist = stepPt.z - start.z;\n                const slope = (0.0 === xyDist ? Math.PI : Math.atan(zDist / xyDist));\n                if (slope > Angle.createDegrees(10.0).radians && slope < Angle.createDegrees(50.0).radians) {\n                    const slopeRay = Ray3d.create(start, Vector3d.createStartEnd(stepPt, start));\n                    const slopePt = Point3d.create();\n                    if (undefined !== slopeRay.intersectionWithPlane(this._lastReference, slopePt)) {\n                        contourLine.reverseInPlace();\n                        contourLine.addPoint(slopePt);\n                        contourLine.reverseInPlace();\n                    }\n                }\n            }\n        }\n        this._currentContour = contourLine;\n        if (ToolSettings.walkDetectFloor)\n            this._lastContour = this._currentContour;\n    }\n    checkForCollision(vp, motion, positionInput) {\n        if (!ToolSettings.walkCollisions)\n            return 0;\n        const view = vp.view;\n        if (!view.is3d() || !view.isCameraOn)\n            return 0;\n        if (undefined !== this._currentContour) {\n            const pixelSize = vp.pixelsFromInches(0.75);\n            const viewPt = vp.npcToView(NpcCenter);\n            const readPt = vp.worldToView(this._lastReadPt);\n            if (viewPt.distanceXY(readPt) > pixelSize)\n                this._currentContour = undefined;\n            if (0.0 !== positionInput.y)\n                this._lastReference = undefined; // Choose a new reference plane after elevation change...\n        }\n        const eyePt = view.getEyePoint();\n        if (undefined === this._currentContour && positionInput.z > 0.0) {\n            vp.viewToNpc(vp.npcToView(NpcCenter), this._lastReadPt);\n            this._lastReadPt.z = ViewManip.getFocusPlaneNpc(vp);\n            vp.npcToWorld(this._lastReadPt, this._lastReadPt);\n            this.computeCollisionData(vp, eyePt);\n        }\n        if (undefined === this._currentContour || this._currentContour.numPoints() < 2 || positionInput.z <= 0.0)\n            return 0;\n        const newEyePt = motion.transform.multiplyPoint3d(eyePt);\n        const planeY = Plane3dByOriginAndUnitNormal.create(eyePt, vp.view.getYVector());\n        const resultY = [];\n        const nIntersectY = planeY ? this._currentContour.appendPlaneIntersectionPoints(planeY, resultY) : 0;\n        const padDist = Constant.oneMeter * 0.5; // stop well before point directly underfoot to avoid clipping through walls...\n        if (0 !== nIntersectY) {\n            let resultVec;\n            for (const intersection of resultY) {\n                const resultNpc = vp.worldToNpc(intersection.point);\n                if (resultNpc.z >= 1 || resultNpc.z <= 0)\n                    continue;\n                const hitVec = Vector3d.createStartEnd(newEyePt, intersection.point);\n                if (undefined === resultVec)\n                    resultVec = hitVec;\n                else if (hitVec.magnitude() < resultVec.magnitude())\n                    resultVec.setFrom(hitVec);\n            }\n            if (undefined !== resultVec) {\n                const eyeVec = Vector3d.createStartEnd(eyePt, newEyePt);\n                if (eyeVec.dotProduct(resultVec) <= 0.0 || resultVec.magnitude() < padDist)\n                    return 1; // Stay put, high barrier...\n            }\n        }\n        if (!ToolSettings.walkDetectFloor || undefined === this._lastReference)\n            return 0;\n        const forwardDir = Vector3d.unitZ().crossProduct(vp.view.getXVector());\n        const planeZ = Plane3dByOriginAndUnitNormal.create(newEyePt, forwardDir);\n        const resultZ = [];\n        const nIntersectZ = planeZ ? this._currentContour.appendPlaneIntersectionPoints(planeZ, resultZ) : 0;\n        if (0 !== nIntersectZ) {\n            const heightPt = Point3d.create();\n            const maintainHeight = Vector3d.create();\n            for (const intersection of resultZ) {\n                if (intersection.point.z > newEyePt.z)\n                    continue; // Ignore overhead point...\n                const refPt = this._lastReference.projectPointToPlane(intersection.point);\n                const offset = Vector3d.createStartEnd(refPt, intersection.point);\n                if (offset.magnitude() > maintainHeight.magnitude()) {\n                    heightPt.setFrom(intersection.point);\n                    maintainHeight.setFrom(offset);\n                }\n            }\n            if (maintainHeight.magnitude() >= ToolSettings.walkStepHeight && maintainHeight.dotProduct(this._lastReference.getNormalRef()) > 0)\n                return 2; // Stay put, low barrier...\n            const moveTransform = Transform.createTranslation(maintainHeight);\n            motion.transform.multiplyTransformTransform(moveTransform, motion.transform);\n            this._lastReference.getOriginRef().setFrom(heightPt);\n        }\n        return 0;\n    }\n    getNavigateMotion(elapsedTime) {\n        const vp = this.viewTool.viewport;\n        if (undefined === vp)\n            return;\n        const motion = this._navigateMotion;\n        motion.init(elapsedTime);\n        if (!vp.isCameraOn) {\n            const input = this.getHorizAndVertVelocity();\n            if (undefined === input)\n                return;\n            motion.pan(input.x, input.y);\n            return motion;\n        }\n        const positionInput = this.getLinearVelocity();\n        const angularInput = this.getAngularVelocity();\n        if (0.0 === angularInput.magnitude() && 0.0 === positionInput.magnitude() && undefined === this._lastMovement)\n            return;\n        this.requestPointerLock(false); // Ignore engagement events after modification starts (either from mouse or keys)...\n        const current = IModelApp.toolAdmin.currentInputState;\n        if (!this._havePointerLock && InputSource.Mouse === current.inputSource && !current.isDragging(BeButton.Data))\n            current.onStartDrag(BeButton.Data); // Treat data down -> navigate key -> data up the same as a drag...\n        if (undefined !== this._lastMovement) {\n            if (motion.moveAndMouseLook(this._accumulator, positionInput, this._lastMovement, true))\n                this._lastMovement = undefined;\n        }\n        else {\n            motion.moveAndLook(positionInput, angularInput.x, angularInput.y, true);\n        }\n        const prevCollision = this._lastCollision;\n        this._lastCollision = this.checkForCollision(vp, motion, positionInput);\n        if (this._lastCollision !== prevCollision)\n            vp.invalidateDecorations();\n        return this._lastCollision ? undefined : motion;\n    }\n    enableDynamicUpdate(vp) {\n        const tool = this.viewTool;\n        if (tool.inDynamicUpdate)\n            return;\n        tool.changeViewport(vp);\n        tool.viewport.setAnimator(this);\n        tool.inDynamicUpdate = true;\n        tool.inHandleModify = true;\n        vp.npcToView(NpcCenter, this._anchorPtView);\n        this._lastPtView.setFrom(this._anchorPtView); // Display indicator in the middle of the view...\n    }\n    toggleCollisions() {\n        ToolSettings.walkCollisions = !ToolSettings.walkCollisions;\n        this._lastCollision = 0;\n        this._lastReference = this._lastContour = this._currentContour = undefined;\n        if (this.viewTool.viewport)\n            this.viewTool.viewport.invalidateDecorations();\n    }\n    toggleDetectFloor() {\n        ToolSettings.walkDetectFloor = !ToolSettings.walkDetectFloor;\n        if (ToolSettings.walkDetectFloor && !ToolSettings.walkCollisions)\n            return this.toggleCollisions();\n        this._lastReference = this._lastContour = this._currentContour = undefined;\n        if (this.viewTool.viewport)\n            this.viewTool.viewport.invalidateDecorations();\n    }\n    changeWalkVelocity(increase) {\n        if (undefined === increase)\n            ToolSettings.walkVelocityChange = 0;\n        else\n            ToolSettings.walkVelocityChange = Geometry.clamp(ToolSettings.walkVelocityChange + (increase ? 1 : -1), -9, 9);\n        if (this.viewTool.viewport)\n            this.viewTool.viewport.invalidateDecorations();\n    }\n    onWheel(ev) {\n        const tool = this.viewTool;\n        if (!tool.inHandleModify || undefined === tool.viewport)\n            return super.onWheel(ev);\n        const focusHandle = tool.viewHandles.focusHandle;\n        if (undefined === focusHandle || ViewHandleType.LookAndMove !== focusHandle.handleType)\n            return super.onWheel(ev);\n        this.changeWalkVelocity(ev.wheelDelta > 0);\n        tool.viewport.setAnimator(this); // animator was cleared by wheel event...\n        return true;\n    }\n    isNavigationKey(keyEvent) {\n        if (keyEvent.repeat || keyEvent.ctrlKey || keyEvent.altKey)\n            return false;\n        switch (keyEvent.key.toLowerCase()) {\n            case \"arrowright\":\n            case \"d\":\n            case \"arrowleft\":\n            case \"a\":\n            case \"arrowup\":\n            case \"w\":\n            case \"arrowdown\":\n            case \"s\":\n            case \"pagedown\":\n            case \"q\":\n            case \"pageup\":\n            case \"e\":\n                return true;\n            default:\n                return false;\n        }\n    }\n    enableKeyStart() {\n        const vp = this.viewTool.viewport;\n        if (0 !== this.viewTool.nPts || undefined === vp)\n            return false;\n        const pt = vp.view.getTargetPoint();\n        const ev = new BeButtonEvent({ point: pt, rawPoint: pt, viewPoint: vp.worldToView(pt), viewport: vp, inputSource: InputSource.Mouse, isDown: true });\n        this.viewTool.changeViewport(ev.viewport);\n        if (!this.viewTool.processFirstPoint(ev))\n            return false;\n        this.viewTool.nPts = 1;\n        return true;\n    }\n    onKeyTransition(wentDown, keyEvent) {\n        if (!this.viewTool.inDynamicUpdate) {\n            this._positionInput.setZero(); // clear input from a previous dynamic update...\n            if (!wentDown || !this.isNavigationKey(keyEvent) || !this.enableKeyStart())\n                return false;\n        }\n        if (keyEvent.ctrlKey || keyEvent.altKey)\n            return false;\n        switch (keyEvent.key.toLowerCase()) {\n            case \"arrowright\":\n            case \"d\":\n                this._positionInput.x = Geometry.clamp(this._positionInput.x + (wentDown ? 1.0 : -1.0), -1.0, 1.0);\n                return true;\n            case \"arrowleft\":\n            case \"a\":\n                this._positionInput.x = Geometry.clamp(this._positionInput.x + (wentDown ? -1.0 : 1.0), -1.0, 1.0);\n                return true;\n            case \"arrowup\":\n            case \"w\":\n                this._positionInput.z = Geometry.clamp(this._positionInput.z + (wentDown ? 1.0 : -1.0), -1.0, 1.0);\n                return true;\n            case \"arrowdown\":\n            case \"s\":\n                this._positionInput.z = Geometry.clamp(this._positionInput.z + (wentDown ? -1.0 : 1.0), -1.0, 1.0);\n                return true;\n            case \"pagedown\":\n            case \"q\":\n                this._positionInput.y = Geometry.clamp(this._positionInput.y + (wentDown ? 1.0 : -1.0), -1.0, 1.0);\n                return true;\n            case \"pageup\":\n            case \"e\":\n                this._positionInput.y = Geometry.clamp(this._positionInput.y + (wentDown ? -1.0 : 1.0), -1.0, 1.0);\n                return true;\n            case \"c\":\n                if (wentDown)\n                    this.toggleCollisions();\n                return true;\n            case \"z\":\n                if (wentDown)\n                    this.toggleDetectFloor();\n                return true;\n            case \"+\":\n                if (wentDown)\n                    this.changeWalkVelocity(true);\n                return true;\n            case \"-\":\n                if (wentDown)\n                    this.changeWalkVelocity(false);\n                return true;\n            case \"=\":\n                if (wentDown)\n                    this.changeWalkVelocity();\n                return true;\n            default:\n                return false;\n        }\n    }\n    getTouchControlRadius(vp) {\n        const viewRect = vp.viewRect;\n        const radius = Math.floor(Math.min(viewRect.width, viewRect.height) / 15.0) + 0.5;\n        const minRadius = vp.pixelsFromInches(0.1);\n        const maxRadius = vp.pixelsFromInches(1.0);\n        return Geometry.clamp(radius, minRadius, maxRadius);\n    }\n    getTouchZoneLowerLeft(vp) {\n        const viewRect = vp.viewRect;\n        const rectLL = viewRect.clone();\n        rectLL.top += viewRect.height * 0.6;\n        rectLL.right -= viewRect.width * 0.6;\n        rectLL.insetByPercent(0.05);\n        return rectLL;\n    }\n    getTouchZoneLowerRight(vp) {\n        const viewRect = vp.viewRect;\n        const rectLR = viewRect.clone();\n        rectLR.top += viewRect.height * 0.6;\n        rectLR.left += viewRect.width * 0.6;\n        rectLR.insetByPercent(0.05);\n        return rectLR;\n    }\n    getTouchStartPosition(touchStart) {\n        if (undefined === touchStart || undefined === touchStart.viewport)\n            return undefined;\n        return BeTouchEvent.getTouchPosition(touchStart.touchEvent.changedTouches[0], touchStart.viewport);\n    }\n    getTouchOffset(touchStart, radius) {\n        const offset = Vector2d.create();\n        if (undefined === this._touchLast)\n            return offset;\n        const position = this.getTouchStartPosition(touchStart);\n        if (undefined === position)\n            return offset;\n        const lastTouch = BeTouchEvent.findTouchById(this._touchLast.touchEvent.targetTouches, touchStart.touchEvent.changedTouches[0].identifier);\n        if (undefined === lastTouch)\n            return offset;\n        const minOffsetRadius = Math.floor(radius * 0.1) + 0.5;\n        const maxOffsetRadius = Math.floor(radius * 1.2) + 0.5;\n        const lastPos = BeTouchEvent.getTouchPosition(lastTouch, touchStart.viewport);\n        const lastVec = Vector2d.createStartEnd(position, lastPos);\n        if (lastVec.magnitude() > maxOffsetRadius)\n            lastVec.scaleToLength(maxOffsetRadius, lastVec);\n        if (lastVec.magnitude() > minOffsetRadius)\n            offset.plus(lastVec, offset);\n        return offset;\n    }\n    onTouchStart(ev) {\n        if (undefined === ev.viewport || !ev.viewport.isCameraOn || 1 !== ev.touchEvent.changedTouches.length)\n            return (undefined === this._touchStartL && undefined !== this._touchStartR ? false : true);\n        const startPos = this.getTouchStartPosition(ev);\n        if (undefined === startPos)\n            return false;\n        const rectLL = this.getTouchZoneLowerLeft(ev.viewport);\n        const rectLR = this.getTouchZoneLowerRight(ev.viewport);\n        if (undefined === this._touchStartL && rectLL.containsPoint(startPos)) {\n            this._touchStartL = this._touchLast = ev;\n            ev.viewport.invalidateDecorations();\n            return true;\n        }\n        if (undefined === this._touchStartR && rectLR.containsPoint(startPos)) {\n            this._touchStartR = this._touchLast = ev;\n            ev.viewport.invalidateDecorations();\n            return true;\n        }\n        return false;\n    }\n    onTouchEnd(ev) {\n        let changed = false;\n        if (undefined !== this._touchStartL && undefined !== BeTouchEvent.findTouchById(ev.touchEvent.changedTouches, this._touchStartL.touchEvent.changedTouches[0].identifier)) {\n            this._touchStartL = undefined;\n            changed = true;\n        }\n        if (undefined !== this._touchStartR && undefined !== BeTouchEvent.findTouchById(ev.touchEvent.changedTouches, this._touchStartR.touchEvent.changedTouches[0].identifier)) {\n            this._touchStartR = undefined;\n            changed = true;\n        }\n        if (changed && undefined !== ev.viewport)\n            ev.viewport.invalidateDecorations();\n        return changed;\n    }\n    async onTouchComplete(_ev) {\n        if (!this.viewTool.inDynamicUpdate || undefined === this._touchLast)\n            return false;\n        await this.viewTool.onReinitialize();\n        return true;\n    }\n    async onTouchCancel(ev) {\n        return this.onTouchComplete(ev);\n    }\n    onTouchMove(ev) {\n        if (undefined === ev.viewport || !this.viewTool.inDynamicUpdate || (undefined === this._touchStartL && undefined === this._touchStartR))\n            return false;\n        let changed = false;\n        if (undefined !== this._touchStartL && undefined !== BeTouchEvent.findTouchById(ev.touchEvent.changedTouches, this._touchStartL.touchEvent.changedTouches[0].identifier))\n            changed = true;\n        if (undefined !== this._touchStartR && undefined !== BeTouchEvent.findTouchById(ev.touchEvent.changedTouches, this._touchStartR.touchEvent.changedTouches[0].identifier))\n            changed = true;\n        if (changed) {\n            this._touchLast = ev;\n            ev.viewport.invalidateDecorations();\n        }\n        return true;\n    }\n    onTouchMoveStart(ev, _startEv) {\n        if (undefined === ev.viewport)\n            return false;\n        if (undefined === this._touchStartL && undefined === this._touchStartR)\n            return false;\n        this.enableDynamicUpdate(ev.viewport);\n        return true;\n    }\n    onTouchTap(ev) {\n        if (undefined === ev.viewport || this.viewTool.inDynamicUpdate || !ev.isSingleTap)\n            return false;\n        const rectLL = this.getTouchZoneLowerLeft(ev.viewport);\n        if (rectLL.containsPoint(ev.viewPoint))\n            this._touchElevate = !this._touchElevate; // Toggle elevate mode for left control until next touch complete...\n        const rectLR = this.getTouchZoneLowerRight(ev.viewport);\n        if (rectLR.containsPoint(ev.viewPoint))\n            this._touchSpeedUp = !this._touchSpeedUp; // Toggle speed increase for left control until next touch complete...\n        return false;\n    }\n    drawHandle(context, hasFocus) {\n        super.drawHandle(context, hasFocus);\n        if (!hasFocus || context.viewport !== this.viewTool.viewport)\n            return;\n        if (ToolSettings.walkCollisions && this.viewTool.inDynamicUpdate) {\n            const position = this._anchorPtView.clone();\n            position.x = Math.floor(position.x) + 0.5;\n            position.y = Math.floor(position.y) + 0.5;\n            const drawCollisionArrows = (ctx) => {\n                const arrowSize = 20;\n                const addArrow = (angle) => {\n                    const end = arrowSize;\n                    const start = end / 2;\n                    const mid = start / 2;\n                    ctx.rotate(angle);\n                    ctx.beginPath();\n                    ctx.moveTo(start, 0);\n                    ctx.lineTo(end, 0);\n                    ctx.moveTo(start, 0);\n                    ctx.lineTo(start + mid, mid);\n                    ctx.moveTo(start, 0);\n                    ctx.lineTo(start + mid, -mid);\n                    ctx.stroke();\n                    ctx.rotate(-angle);\n                };\n                ctx.strokeStyle = \"black\";\n                ctx.lineWidth = 5;\n                ctx.lineCap = \"round\";\n                addArrow(0);\n                addArrow(Math.PI);\n                ctx.strokeStyle = (1 === this._lastCollision ? \"red\" : \"white\");\n                ctx.lineWidth = 1;\n                addArrow(0);\n                addArrow(Math.PI);\n                if (ToolSettings.walkDetectFloor) {\n                    ctx.strokeStyle = \"black\";\n                    ctx.lineWidth = 5;\n                    addArrow(-Math.PI / 2);\n                    ctx.strokeStyle = (2 === this._lastCollision ? \"red\" : \"white\");\n                    ctx.lineWidth = 1;\n                    addArrow(-Math.PI / 2);\n                }\n            };\n            context.addCanvasDecoration({ position, drawDecoration: drawCollisionArrows });\n        }\n        if ((0 !== ToolSettings.walkVelocityChange || this._touchSpeedUp) && this.viewTool.inDynamicUpdate) {\n            const arrowSize = 12;\n            const speedUp = (ToolSettings.walkVelocityChange > 0 || this._touchSpeedUp ? true : false);\n            const position = this._anchorPtView.clone();\n            position.x = Math.floor(position.x) + 0.5;\n            position.y = Math.floor(position.y + (arrowSize / 3)) + 0.5;\n            const drawSpeedChange = (ctx) => {\n                const addArrows = () => {\n                    const end = arrowSize;\n                    const start = end / 2;\n                    const midY = (end + start) / 2;\n                    const midX = (arrowSize / 4) * (speedUp ? 1 : -1);\n                    ctx.beginPath();\n                    ctx.moveTo(0, start);\n                    ctx.lineTo(midX, midY);\n                    ctx.lineTo(0, end);\n                    ctx.stroke();\n                    ctx.beginPath();\n                    ctx.moveTo(-midX, start);\n                    ctx.lineTo(0, midY);\n                    ctx.lineTo(-midX, end);\n                    ctx.stroke();\n                };\n                ctx.strokeStyle = \"black\";\n                ctx.lineWidth = 3;\n                ctx.lineCap = \"round\";\n                addArrows();\n                ctx.strokeStyle = \"white\";\n                ctx.lineWidth = 1;\n                addArrows();\n            };\n            context.addCanvasDecoration({ position, drawDecoration: drawSpeedChange });\n        }\n        const positionL = this.getTouchStartPosition(this._touchStartL);\n        const positionR = this.getTouchStartPosition(this._touchStartR);\n        if (undefined === positionL && undefined === positionR)\n            return;\n        const outerRadius = this.getTouchControlRadius(context.viewport);\n        const innerRadius = Math.floor(outerRadius * 0.65) + 0.5;\n        const offsetL = this.getTouchOffset(this._touchStartL, outerRadius);\n        const offsetR = this.getTouchOffset(this._touchStartR, outerRadius);\n        const drawDecoration = (ctx, isLeft) => {\n            ctx.beginPath();\n            ctx.strokeStyle = \"black\";\n            ctx.fillStyle = \"rgba(150,150,150,0.4)\";\n            ctx.lineWidth = 2;\n            ctx.arc(0, 0, outerRadius, 0, 2 * Math.PI);\n            ctx.stroke();\n            ctx.fill();\n            ctx.shadowColor = \"black\";\n            ctx.shadowBlur = 10;\n            ctx.shadowOffsetX = 5;\n            ctx.shadowOffsetY = 5;\n            ctx.beginPath();\n            ctx.strokeStyle = \"rgba(0,0,0,0.4)\";\n            ctx.lineWidth = innerRadius;\n            ctx.lineCap = \"round\";\n            ctx.moveTo(0, 0);\n            ctx.lineTo(isLeft ? offsetL.x : offsetR.x, isLeft ? offsetL.y : offsetR.y);\n            ctx.stroke();\n            ctx.beginPath();\n            ctx.strokeStyle = \"black\";\n            ctx.fillStyle = \"rgba(200,200,200,0.8\";\n            ctx.lineWidth = 1;\n            ctx.arc(isLeft ? offsetL.x : offsetR.x, isLeft ? offsetL.y : offsetR.y, innerRadius, 0, 2 * Math.PI);\n            ctx.stroke();\n            ctx.fill();\n        };\n        const drawDecorationL = (ctx) => drawDecoration(ctx, true);\n        const drawDecorationR = (ctx) => drawDecoration(ctx, false);\n        if (undefined !== positionL)\n            context.addCanvasDecoration({ position: positionL, drawDecoration: drawDecorationL });\n        if (undefined !== positionR)\n            context.addCanvasDecoration({ position: positionR, drawDecoration: drawDecorationR });\n    }\n}\n/** ViewingToolHandle for performing the \"walk view\" operation */\nclass ViewWalk extends ViewNavigate {\n    constructor(viewManip) {\n        super(viewManip);\n        this._navigateMotion = new NavigateMotion(this.viewTool.viewport);\n    }\n    get handleType() { return ViewHandleType.Walk; }\n    firstPoint(ev) {\n        this.viewTool.provideToolAssistance(\"Walk.Prompts.NextPoint\");\n        return super.firstPoint(ev);\n    }\n    getNavigateMotion(elapsedTime) {\n        const input = this.getInputVector();\n        if (undefined === input)\n            return undefined;\n        const motion = this._navigateMotion;\n        motion.init(elapsedTime);\n        switch (this.getNavigateMode()) {\n            case 0 /* NavigateMode.Pan */:\n                input.scale(this.getMaxLinearVelocity(), input);\n                motion.pan(input.x, input.y);\n                break;\n            case 1 /* NavigateMode.Look */:\n                input.scale(-this.getMaxAngularVelocity(), input);\n                motion.look(input.x, input.y);\n                break;\n            case 2 /* NavigateMode.Travel */:\n                motion.travel(-input.x * this.getMaxAngularVelocity(), 0, -input.y * this.getMaxLinearVelocity(), true);\n                break;\n        }\n        return motion;\n    }\n}\n/** ViewingToolHandle for performing the \"fly view\" operation */\nclass ViewFly extends ViewNavigate {\n    constructor(viewManip) {\n        super(viewManip);\n        this._navigateMotion = new NavigateMotion(this.viewTool.viewport);\n    }\n    get handleType() { return ViewHandleType.Fly; }\n    firstPoint(ev) {\n        this.viewTool.provideToolAssistance(\"Fly.Prompts.NextPoint\");\n        return super.firstPoint(ev);\n    }\n    getNavigateMotion(elapsedTime) {\n        const input = this.getInputVector();\n        if (undefined === input)\n            return undefined;\n        const motion = this._navigateMotion;\n        motion.init(elapsedTime);\n        switch (this.getNavigateMode()) {\n            case 0 /* NavigateMode.Pan */:\n                input.scale(this.getMaxLinearVelocity(), input);\n                motion.pan(input.x, input.y);\n                break;\n            case 1 /* NavigateMode.Look */:\n                input.scale(-this.getMaxAngularVelocity(), input);\n                motion.look(input.x, input.y);\n                break;\n            case 2 /* NavigateMode.Travel */:\n                input.scale(-this.getMaxAngularVelocity() * 2.0, input);\n                motion.travel(input.x, input.y, this.getMaxLinearVelocity(), false);\n                break;\n        }\n        return motion;\n    }\n}\n/** The tool that performs a Pan view operation\n * @public\n */\nclass PanViewTool extends ViewManip {\n    constructor(vp, oneShot = false, isDraggingRequired = false) {\n        super(vp, ViewHandleType.Pan, oneShot, isDraggingRequired);\n    }\n    async onReinitialize() {\n        await super.onReinitialize();\n        this.provideToolAssistance(\"Pan.Prompts.FirstPoint\");\n    }\n}\nPanViewTool.toolId = \"View.Pan\";\nPanViewTool.iconSpec = \"icon-hand-2\";\nexport { PanViewTool };\n/** A tool that performs a Rotate view operation\n * @public\n */\nclass RotateViewTool extends ViewManip {\n    constructor(vp, oneShot = false, isDraggingRequired = false) {\n        super(vp, ViewHandleType.Rotate | ViewHandleType.Pan | ViewHandleType.TargetCenter, oneShot, isDraggingRequired);\n    }\n    async onReinitialize() {\n        await super.onReinitialize();\n        this.provideToolAssistance(\"Rotate.Prompts.FirstPoint\");\n    }\n}\nRotateViewTool.toolId = \"View.Rotate\";\nRotateViewTool.iconSpec = \"icon-gyroscope\";\nexport { RotateViewTool };\n/** A tool that performs the look operation\n * @public\n */\nclass LookViewTool extends ViewManip {\n    constructor(vp, oneShot = false, isDraggingRequired = false) {\n        super(vp, ViewHandleType.Look | ViewHandleType.Pan, oneShot, isDraggingRequired);\n    }\n    async onReinitialize() {\n        await super.onReinitialize();\n        this.provideToolAssistance(\"Look.Prompts.FirstPoint\");\n    }\n}\nLookViewTool.toolId = \"View.Look\";\nLookViewTool.iconSpec = \"icon-view-navigation\";\nexport { LookViewTool };\n/** A tool that performs the scroll operation\n * @public\n */\nclass ScrollViewTool extends ViewManip {\n    constructor(vp, oneShot = false, isDraggingRequired = false) {\n        super(vp, ViewHandleType.Scroll, oneShot, isDraggingRequired);\n    }\n    async onReinitialize() {\n        await super.onReinitialize();\n        this.provideToolAssistance(\"Scroll.Prompts.FirstPoint\");\n    }\n}\nScrollViewTool.toolId = \"View.Scroll\";\nScrollViewTool.iconSpec = \"icon-move\";\nexport { ScrollViewTool };\n/** A tool that performs the zoom operation\n * @public\n */\nclass ZoomViewTool extends ViewManip {\n    constructor(vp, oneShot = false, isDraggingRequired = false) {\n        super(vp, ViewHandleType.Zoom | ViewHandleType.Pan, oneShot, isDraggingRequired);\n    }\n    async onReinitialize() {\n        await super.onReinitialize();\n        this.provideToolAssistance(\"Zoom.Prompts.FirstPoint\");\n    }\n}\nZoomViewTool.toolId = \"View.Zoom\";\nZoomViewTool.iconSpec = \"icon-zoom\";\nexport { ZoomViewTool };\n/** A tool that performs the walk operation using mouse+keyboard or touch controls.\n * Keyboard and mouse controls are similar to those used by many video games:\n *  - Mouse motion: look around.\n *  - W, A, S, D (or arrow keys): move forward, left, right, or backward respectively.\n *  - E, Q (or PgUp, PgDn): move up and down respectively.\n *  - +, - (or scroll wheel): increase or decrease velocity.\n * @public\n */\nclass LookAndMoveTool extends ViewManip {\n    constructor(vp, oneShot = false, isDraggingRequired = false) {\n        const viewport = (undefined === vp ? IModelApp.viewManager.selectedView : vp); // Need vp to enable camera/check lens in onReinitialize...\n        super(viewport, ViewHandleType.LookAndMove | ViewHandleType.Pan, oneShot, isDraggingRequired);\n    }\n    async onReinitialize() {\n        await super.onReinitialize();\n        this.provideToolAssistance(\"LookAndMove.Prompts.FirstPoint\");\n    }\n    /** @beta */\n    provideToolAssistance(mainInstrKey) {\n        const mainInstruction = ToolAssistance.createInstruction(this.iconSpec, ViewTool.translate(mainInstrKey));\n        const mouseInstructions = [];\n        const touchInstructions = [];\n        const acceptMsg = this.inDynamicUpdate ? CoreTools.translate(\"ElementSet.Inputs.AcceptPoint\") : ViewTool.translate(\"LookAndMove.Inputs.AcceptLookPoint\");\n        const rejectMsg = CoreTools.translate(\"ElementSet.Inputs.Exit\");\n        mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.LeftClick, acceptMsg, false, ToolAssistanceInputMethod.Mouse));\n        mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.RightClick, rejectMsg, false, ToolAssistanceInputMethod.Mouse));\n        mouseInstructions.push(ToolAssistance.createKeyboardInstruction(ToolAssistance.createKeyboardInfo([\"W\"], [\"A\", \"S\", \"D\"]), ViewTool.translate(\"LookAndMove.Inputs.WalkKeys\"), false));\n        mouseInstructions.push(ToolAssistance.createKeyboardInstruction(ToolAssistance.arrowKeyboardInfo, ViewTool.translate(\"LookAndMove.Inputs.WalkKeys\"), false));\n        mouseInstructions.push(ToolAssistance.createKeyboardInstruction(ToolAssistance.createKeyboardInfo([\"Q\", \"E\"]), ViewTool.translate(\"LookAndMove.Inputs.ElevateKeys\"), false));\n        mouseInstructions.push(ToolAssistance.createKeyboardInstruction(ToolAssistance.createKeyboardInfo([\"\\u21de\", \"\\u21df\"]), ViewTool.translate(\"LookAndMove.Inputs.ElevateKeys\"), false));\n        mouseInstructions.push(ToolAssistance.createKeyboardInstruction(ToolAssistance.createKeyboardInfo([\"C\", \"Z\"]), ViewTool.translate(\"LookAndMove.Inputs.CollideKeys\"), false));\n        mouseInstructions.push(ToolAssistance.createKeyboardInstruction(ToolAssistance.createKeyboardInfo([\"+\", \"-\"]), ViewTool.translate(\"LookAndMove.Inputs.VelocityChange\"), false));\n        mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.MouseWheel, ViewTool.translate(\"LookAndMove.Inputs.VelocityChange\"), false, ToolAssistanceInputMethod.Mouse));\n        touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.TouchCursorDrag, ViewTool.translate(\"LookAndMove.Inputs.TouchZoneLL\"), false, ToolAssistanceInputMethod.Touch));\n        touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.TouchCursorDrag, ViewTool.translate(\"LookAndMove.Inputs.TouchZoneLR\"), false, ToolAssistanceInputMethod.Touch));\n        touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.OneTouchTap, ViewTool.translate(\"LookAndMove.Inputs.TouchTapLL\"), false, ToolAssistanceInputMethod.Touch));\n        touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.OneTouchTap, ViewTool.translate(\"LookAndMove.Inputs.TouchTapLR\"), false, ToolAssistanceInputMethod.Touch));\n        touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.OneTouchDrag, acceptMsg, false, ToolAssistanceInputMethod.Touch));\n        touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.TwoTouchTap, rejectMsg, false, ToolAssistanceInputMethod.Touch));\n        const sections = [];\n        sections.push(ToolAssistance.createSection(mouseInstructions, ToolAssistance.inputsLabel));\n        sections.push(ToolAssistance.createSection(touchInstructions, ToolAssistance.inputsLabel));\n        const instructions = ToolAssistance.createInstructions(mainInstruction, sections);\n        IModelApp.notifications.setToolAssistance(instructions);\n    }\n}\nLookAndMoveTool.toolId = \"View.LookAndMove\";\nLookAndMoveTool.iconSpec = \"icon-walk\";\nexport { LookAndMoveTool };\n/** A tool that performs the walk operation\n * @public\n */\nclass WalkViewTool extends ViewManip {\n    constructor(vp, oneShot = false, isDraggingRequired = false) {\n        const viewport = (undefined === vp ? IModelApp.viewManager.selectedView : vp); // Need vp to enable camera/check lens in onReinitialize...\n        super(viewport, ViewHandleType.Walk | ViewHandleType.Pan, oneShot, isDraggingRequired);\n    }\n    async onReinitialize() {\n        await super.onReinitialize();\n        this.provideToolAssistance(\"Walk.Prompts.FirstPoint\");\n    }\n    /** @beta */\n    provideToolAssistance(mainInstrKey) {\n        const walkInstructions = [];\n        walkInstructions.push(ToolAssistance.createModifierKeyInstruction(ToolAssistance.shiftKey, ToolAssistanceImage.LeftClickDrag, ViewTool.translate(\"Pan.flyover\"), false, ToolAssistanceInputMethod.Mouse));\n        walkInstructions.push(ToolAssistance.createModifierKeyInstruction(ToolAssistance.ctrlKey, ToolAssistanceImage.LeftClickDrag, ViewTool.translate(\"Look.flyover\"), false, ToolAssistanceInputMethod.Mouse));\n        super.provideToolAssistance(mainInstrKey, walkInstructions);\n    }\n}\nWalkViewTool.toolId = \"View.Walk\";\nWalkViewTool.iconSpec = \"icon-walk\";\nexport { WalkViewTool };\n/** A tool that performs the fly operation\n * @public\n */\nclass FlyViewTool extends ViewManip {\n    constructor(vp, oneShot = false, isDraggingRequired = false) {\n        super(vp, ViewHandleType.Fly | ViewHandleType.Pan, oneShot, isDraggingRequired);\n    }\n    async onReinitialize() {\n        await super.onReinitialize();\n        this.provideToolAssistance(\"Fly.Prompts.FirstPoint\");\n    }\n    /** @beta */\n    provideToolAssistance(mainInstrKey) {\n        const flyInstructions = [];\n        flyInstructions.push(ToolAssistance.createModifierKeyInstruction(ToolAssistance.shiftKey, ToolAssistanceImage.LeftClickDrag, ViewTool.translate(\"Pan.flyover\"), false, ToolAssistanceInputMethod.Mouse));\n        flyInstructions.push(ToolAssistance.createModifierKeyInstruction(ToolAssistance.ctrlKey, ToolAssistanceImage.LeftClickDrag, ViewTool.translate(\"Look.flyover\"), false, ToolAssistanceInputMethod.Mouse));\n        super.provideToolAssistance(mainInstrKey, flyInstructions);\n    }\n}\nFlyViewTool.toolId = \"View.Fly\";\nFlyViewTool.iconSpec = \"icon-airplane\";\nexport { FlyViewTool };\n/** A tool that performs a fit view\n * @public\n */\nclass FitViewTool extends ViewTool {\n    constructor(viewport, oneShot, doAnimate = true, isolatedOnly = true) {\n        super(viewport);\n        this.viewport = viewport;\n        this.oneShot = oneShot;\n        this.doAnimate = doAnimate;\n        this.isolatedOnly = isolatedOnly;\n    }\n    /** @beta */\n    provideToolAssistance() {\n        const mainInstruction = ToolAssistance.createInstruction(this.iconSpec, ViewTool.translate(\"Fit.Prompts.FirstPoint\"));\n        const mouseInstructions = [];\n        const touchInstructions = [];\n        const acceptMsg = CoreTools.translate(\"ElementSet.Inputs.Accept\");\n        const rejectMsg = CoreTools.translate(\"ElementSet.Inputs.Exit\");\n        touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.OneTouchTap, acceptMsg, false, ToolAssistanceInputMethod.Touch));\n        mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.LeftClick, acceptMsg, false, ToolAssistanceInputMethod.Mouse));\n        touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.TwoTouchTap, rejectMsg, false, ToolAssistanceInputMethod.Touch));\n        mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.RightClick, rejectMsg, false, ToolAssistanceInputMethod.Mouse));\n        const sections = [];\n        sections.push(ToolAssistance.createSection(mouseInstructions, ToolAssistance.inputsLabel));\n        sections.push(ToolAssistance.createSection(touchInstructions, ToolAssistance.inputsLabel));\n        const instructions = ToolAssistance.createInstructions(mainInstruction, sections);\n        IModelApp.notifications.setToolAssistance(instructions);\n    }\n    async onDataButtonDown(ev) {\n        if (ev.viewport)\n            return await this.doFit(ev.viewport, this.oneShot, this.doAnimate, this.isolatedOnly) ? EventHandled.Yes : EventHandled.No;\n        return EventHandled.No;\n    }\n    async onPostInstall() {\n        await super.onPostInstall();\n        if (undefined === this.viewport || !this.oneShot)\n            this.provideToolAssistance();\n        if (this.viewport)\n            await this.doFit(this.viewport, this.oneShot, this.doAnimate, this.isolatedOnly);\n    }\n    async doFit(viewport, oneShot, doAnimate = true, isolatedOnly = true) {\n        if (!isolatedOnly || !await ViewManip.zoomToAlwaysDrawnExclusive(viewport, { animateFrustumChange: doAnimate }))\n            ViewManip.fitViewWithGlobeAnimation(viewport, doAnimate);\n        if (oneShot)\n            await this.exitTool();\n        return oneShot;\n    }\n}\nFitViewTool.toolId = \"View.Fit\";\nFitViewTool.iconSpec = \"icon-fit-to-view\";\nexport { FitViewTool };\n/** A tool that views a location on the background map from a satellite's perspective; the viewed location is derived from the position of the current camera's eye above the background map. Operates on the selected view.\n * @public\n */\nclass ViewGlobeSatelliteTool extends ViewTool {\n    constructor(viewport, oneShot = true, doAnimate = true) {\n        super(viewport);\n        this.viewport = viewport;\n        this.oneShot = oneShot;\n        this.doAnimate = doAnimate;\n    }\n    /** @internal */\n    async onDataButtonDown(ev) {\n        if (ev.viewport)\n            return (await this._beginSatelliteView(ev.viewport, this.oneShot, this.doAnimate)) ? EventHandled.Yes : EventHandled.No;\n        return EventHandled.No;\n    }\n    /** @internal */\n    async onPostInstall() {\n        await super.onPostInstall();\n        const viewport = undefined === this.viewport ? IModelApp.viewManager.selectedView : this.viewport;\n        if (viewport) {\n            (async () => {\n                await this._beginSatelliteView(viewport, this.oneShot, this.doAnimate);\n            })().catch(() => { });\n        }\n    }\n    async _beginSatelliteView(viewport, oneShot, doAnimate = true) {\n        const carto = await eyeToCartographicOnGlobeFromGcs(viewport);\n        if (carto !== undefined) {\n            try {\n                let elevationOffset = 0;\n                const elevation = await queryTerrainElevationOffset(viewport, carto);\n                if (elevation !== undefined)\n                    elevationOffset = elevation;\n                return await this._doSatelliteView(viewport, oneShot, doAnimate, elevationOffset);\n            }\n            catch {\n            }\n        }\n        return true;\n    }\n    async _doSatelliteView(viewport, oneShot, doAnimate = true, elevationOffset = 0) {\n        viewGlobalLocation(viewport, doAnimate, ViewGlobalLocationConstants.satelliteHeightAboveEarthInMeters + elevationOffset);\n        if (oneShot)\n            await this.exitTool();\n        return oneShot;\n    }\n}\nViewGlobeSatelliteTool.toolId = \"View.GlobeSatellite\";\nexport { ViewGlobeSatelliteTool };\n/** A tool that views a location on the background map from a bird's eye perspective; the viewed location is derived from the position of the current camera's eye above the background map. Operates on the selected view.\n * @public\n */\nclass ViewGlobeBirdTool extends ViewTool {\n    constructor(viewport, oneShot = true, doAnimate = true) {\n        super(viewport);\n        this.viewport = viewport;\n        this.oneShot = oneShot;\n        this.doAnimate = doAnimate;\n    }\n    /** @internal */\n    async onDataButtonDown(ev) {\n        if (ev.viewport)\n            return (await this._beginDoBirdView(ev.viewport, this.oneShot, this.doAnimate)) ? EventHandled.Yes : EventHandled.No;\n        return EventHandled.No;\n    }\n    /** @internal */\n    async onPostInstall() {\n        await super.onPostInstall();\n        const viewport = undefined === this.viewport ? IModelApp.viewManager.selectedView : this.viewport;\n        if (viewport)\n            await this._beginDoBirdView(viewport, this.oneShot, this.doAnimate);\n    }\n    async _beginDoBirdView(viewport, oneShot, doAnimate = true) {\n        const carto = await eyeToCartographicOnGlobeFromGcs(viewport);\n        if (carto !== undefined) {\n            try {\n                let elevationOffset = 0;\n                const elevation = await queryTerrainElevationOffset(viewport, carto);\n                if (elevation !== undefined)\n                    elevationOffset = elevation;\n                return await this._doBirdView(viewport, oneShot, doAnimate, elevationOffset);\n            }\n            catch {\n            }\n        }\n        return true;\n    }\n    async _doBirdView(viewport, oneShot, doAnimate = true, elevationOffset = 0) {\n        viewGlobalLocation(viewport, doAnimate, ViewGlobalLocationConstants.birdHeightAboveEarthInMeters + elevationOffset, ViewGlobalLocationConstants.birdPitchAngleRadians);\n        if (oneShot)\n            await this.exitTool();\n        return oneShot;\n    }\n}\nViewGlobeBirdTool.toolId = \"View.GlobeBird\";\nexport { ViewGlobeBirdTool };\n/** A tool that views a location on the background map corresponding to a specified string.\n * This will either look down at the location using a bird's eye height, or, if a range is available, the entire range corresponding to the location will be viewed.\n * Operates on the selected view.\n * @public\n */\nclass ViewGlobeLocationTool extends ViewTool {\n    constructor(viewport, oneShot = true, doAnimate = true) {\n        super(viewport);\n        this.viewport = viewport;\n        this.oneShot = oneShot;\n        this.doAnimate = doAnimate;\n    }\n    static get minArgs() { return 1; }\n    static get maxArgs() { return undefined; }\n    /** This runs the tool based on the provided location arguments.\n     * arguments: latitude longitude | string\n     * If specified, the latitude and longitude arguments are numbers specified in degrees.\n     * If specified, the string argument contains a location name. Examples of location name include named geographic areas like \"Seattle, WA\" or \"Alaska\", a specific address like \"1600 Pennsylvania Avenue NW, Washington, DC 20500\", or a place name like \"Philadelphia Museum of Art\".\n     **/\n    async parseAndRun(...args) {\n        if (2 === args.length) { // try to parse latitude and longitude\n            const latitude = parseFloat(args[0]);\n            const longitude = parseFloat(args[1]);\n            if (!Number.isNaN(latitude) || !Number.isNaN(longitude)) {\n                const center = Cartographic.fromDegrees({ longitude, latitude });\n                this._globalLocation = { center };\n            }\n        }\n        if (this._globalLocation === undefined) {\n            const locationString = args.join(\" \");\n            const bingLocationProvider = new BingLocationProvider();\n            try {\n                this._globalLocation = await bingLocationProvider.getLocation(locationString);\n                if (this._globalLocation !== undefined) {\n                    const viewport = undefined === this.viewport ? IModelApp.viewManager.selectedView : this.viewport;\n                    if (viewport !== undefined) {\n                        const elevationOffset = await queryTerrainElevationOffset(viewport, this._globalLocation.center);\n                        if (elevationOffset !== undefined)\n                            this._globalLocation.center.height = elevationOffset;\n                    }\n                }\n            }\n            catch {\n            }\n        }\n        if (this._globalLocation !== undefined)\n            return this.run();\n        return true;\n    }\n    /** @internal */\n    async onPostInstall() {\n        await super.onPostInstall();\n        await this._doLocationView();\n    }\n    async _doLocationView() {\n        const viewport = undefined === this.viewport ? IModelApp.viewManager.selectedView : this.viewport;\n        if (viewport) {\n            if (undefined !== this._globalLocation)\n                await viewport.animateFlyoverToGlobalLocation(this._globalLocation);\n        }\n        if (this.oneShot)\n            await this.exitTool();\n        return this.oneShot;\n    }\n}\nViewGlobeLocationTool.toolId = \"View.GlobeLocation\";\nexport { ViewGlobeLocationTool };\n/** A tool that views the current iModel on the background map so that the extent of the project is visible. Operates on the selected view.\n * @public\n */\nclass ViewGlobeIModelTool extends ViewTool {\n    constructor(viewport, oneShot = true, doAnimate = true) {\n        super(viewport);\n        this.viewport = viewport;\n        this.oneShot = oneShot;\n        this.doAnimate = doAnimate;\n    }\n    /** @internal */\n    async onDataButtonDown(ev) {\n        if (ev.viewport)\n            return await this._doIModelView() ? EventHandled.Yes : EventHandled.No;\n        return EventHandled.No;\n    }\n    /** @internal */\n    async onPostInstall() {\n        await super.onPostInstall();\n        await this._doIModelView();\n    }\n    async _doIModelView() {\n        const viewport = undefined === this.viewport ? IModelApp.viewManager.selectedView : this.viewport;\n        if (viewport && (viewport.view instanceof ViewState3d)) {\n            const extents = viewport.view.iModel.projectExtents;\n            const center = viewport.view.iModel.projectExtents.center;\n            const view3d = viewport.view;\n            const cartographicCenter = view3d.rootToCartographic(center);\n            if (cartographicCenter !== undefined) {\n                const cartographicArea = rangeToCartographicArea(view3d, extents);\n                (async () => {\n                    await viewport.animateFlyoverToGlobalLocation({ center: cartographicCenter, area: cartographicArea });\n                })().catch(() => { });\n            }\n        }\n        if (this.oneShot)\n            await this.exitTool();\n        return this.oneShot;\n    }\n}\nViewGlobeIModelTool.toolId = \"View.GlobeIModel\";\nexport { ViewGlobeIModelTool };\n/** A tool that rotates the view to one of the standard views.\n * @public\n */\nclass StandardViewTool extends ViewTool {\n    constructor(viewport, _standardViewId) {\n        super(viewport);\n        this._standardViewId = _standardViewId;\n    }\n    async onPostInstall() {\n        await super.onPostInstall();\n        if (this.viewport) {\n            const vp = this.viewport;\n            const id = vp.view.allow3dManipulations() ? this._standardViewId : StandardViewId.Top;\n            const rMatrix = AccuDraw.getStandardRotation(id, vp, vp.isContextRotationRequired);\n            const inverse = rMatrix.inverse();\n            if (undefined !== inverse) {\n                const targetMatrix = inverse.multiplyMatrixMatrix(vp.rotation);\n                const rotateTransform = Transform.createFixedPointAndMatrix(ViewManip.getDefaultTargetPointWorld(vp), targetMatrix);\n                const newFrustum = vp.getFrustum();\n                newFrustum.multiply(rotateTransform);\n                vp.view.setupFromFrustum(newFrustum);\n                vp.synchWithView({ animateFrustumChange: true });\n            }\n        }\n        return this.exitTool();\n    }\n}\nStandardViewTool.toolId = \"View.Standard\";\nStandardViewTool.iconSpec = \"icon-cube-faces-top\";\nexport { StandardViewTool };\n/** A tool that performs a Window-area view operation\n * @public\n */\nclass WindowAreaTool extends ViewTool {\n    constructor() {\n        super(...arguments);\n        this._haveFirstPoint = false;\n        this._firstPtWorld = Point3d.create();\n        this._secondPtWorld = Point3d.create();\n        this._corners = [new Point3d(), new Point3d()];\n        this._shapePts = [new Point3d(), new Point3d(), new Point3d(), new Point3d(), new Point3d()];\n        this._fillColor = ColorDef.from(0, 0, 255, 200);\n    }\n    async onPostInstall() {\n        await super.onPostInstall();\n        this.provideToolAssistance();\n    }\n    async onReinitialize() {\n        this._haveFirstPoint = false;\n        this._firstPtWorld.setZero();\n        this._secondPtWorld.setZero();\n        this.provideToolAssistance();\n    }\n    async onResetButtonUp(ev) {\n        if (this._haveFirstPoint) {\n            await this.onReinitialize();\n            return EventHandled.Yes;\n        }\n        return super.onResetButtonUp(ev);\n    }\n    /** @beta */\n    provideToolAssistance() {\n        const mainInstruction = ToolAssistance.createInstruction(this.iconSpec, ViewTool.translate(this._haveFirstPoint ? \"WindowArea.Prompts.NextPoint\" : \"WindowArea.Prompts.FirstPoint\"));\n        const mouseInstructions = [];\n        const touchInstructions = [];\n        const acceptMsg = CoreTools.translate(\"ElementSet.Inputs.AcceptPoint\");\n        const restartMsg = CoreTools.translate(\"ElementSet.Inputs.Restart\");\n        const exitMsg = CoreTools.translate(\"ElementSet.Inputs.Exit\");\n        touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.OneTouchDrag, acceptMsg, false, ToolAssistanceInputMethod.Touch));\n        mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.LeftClick, acceptMsg, false, ToolAssistanceInputMethod.Mouse));\n        touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.TwoTouchTap, exitMsg, false, ToolAssistanceInputMethod.Touch));\n        mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.RightClick, this._haveFirstPoint ? restartMsg : exitMsg, false, ToolAssistanceInputMethod.Mouse));\n        const sections = [];\n        sections.push(ToolAssistance.createSection(mouseInstructions, ToolAssistance.inputsLabel));\n        sections.push(ToolAssistance.createSection(touchInstructions, ToolAssistance.inputsLabel));\n        const instructions = ToolAssistance.createInstructions(mainInstruction, sections);\n        IModelApp.notifications.setToolAssistance(instructions);\n    }\n    async onDataButtonDown(ev) {\n        if (undefined === ev.viewport)\n            return EventHandled.Yes;\n        if (undefined === this.viewport) {\n            this.viewport = ev.viewport;\n        }\n        else if (!ev.viewport.view.hasSameCoordinates(this.viewport.view)) {\n            if (this._haveFirstPoint)\n                return EventHandled.Yes;\n            this.viewport = ev.viewport;\n            this._lastPtView = ev.viewPoint;\n            IModelApp.viewManager.invalidateDecorationsAllViews();\n            return EventHandled.Yes;\n        }\n        if (this._haveFirstPoint) {\n            this._secondPtWorld.setFrom(ev.point);\n            this.doManipulation(ev, false);\n            await this.onReinitialize();\n            this.viewport.invalidateDecorations();\n        }\n        else {\n            this._firstPtWorld.setFrom(ev.point);\n            this._secondPtWorld.setFrom(this._firstPtWorld);\n            this._haveFirstPoint = true;\n            this._lastPtView = ev.viewPoint;\n            this.provideToolAssistance();\n        }\n        return EventHandled.Yes;\n    }\n    async onMouseMotion(ev) { this.doManipulation(ev, true); }\n    async onTouchTap(ev) { return ev.isSingleTap ? EventHandled.Yes : EventHandled.No; } // Prevent IdleTool from converting single tap into data button down/up...\n    async onTouchMoveStart(ev, startEv) {\n        if (!this._haveFirstPoint && startEv.isSingleTouch)\n            await IModelApp.toolAdmin.convertTouchMoveStartToButtonDownAndMotion(startEv, ev);\n        return this._haveFirstPoint ? EventHandled.Yes : EventHandled.No;\n    }\n    async onTouchMove(ev) {\n        if (this._haveFirstPoint)\n            return IModelApp.toolAdmin.convertTouchMoveToMotion(ev);\n    }\n    async onTouchComplete(ev) {\n        if (this._haveFirstPoint)\n            return IModelApp.toolAdmin.convertTouchEndToButtonUp(ev);\n    }\n    async onTouchCancel(ev) {\n        if (this._haveFirstPoint)\n            return IModelApp.toolAdmin.convertTouchEndToButtonUp(ev, BeButton.Reset);\n    }\n    computeWindowCorners() {\n        const vp = this.viewport;\n        const corners = this._corners;\n        corners[0].setFrom(this._firstPtWorld);\n        corners[1].setFrom(this._secondPtWorld);\n        vp.worldToViewArray(corners);\n        const delta = corners[1].minus(corners[0]);\n        if (delta.magnitudeXY() < vp.pixelsFromInches(ToolSettings.startDragDistanceInches))\n            return undefined;\n        const currentDelta = vp.viewDelta;\n        if (currentDelta.x === 0 || delta.x === 0)\n            return undefined;\n        const skew = vp.view.getAspectRatioSkew();\n        const viewAspect = skew * currentDelta.y / currentDelta.x;\n        const aspectRatio = Math.abs(delta.y / delta.x);\n        let halfDeltaX;\n        let halfDeltaY;\n        if (aspectRatio < viewAspect) {\n            halfDeltaX = Math.abs(delta.x) / 2.0;\n            halfDeltaY = halfDeltaX * viewAspect;\n        }\n        else {\n            halfDeltaY = Math.abs(delta.y) / 2.0;\n            halfDeltaX = halfDeltaY / viewAspect;\n        }\n        const center = corners[0].plusScaled(delta, 0.5);\n        corners[0].x = center.x - halfDeltaX;\n        corners[0].y = center.y - halfDeltaY;\n        corners[1].x = center.x + halfDeltaX;\n        corners[1].y = center.y + halfDeltaY;\n        return corners;\n    }\n    decorate(context) {\n        if (undefined === this.viewport || !context.viewport.view.hasSameCoordinates(this.viewport.view))\n            return;\n        const vp = this.viewport;\n        const color = vp.getContrastToBackgroundColor();\n        if (this._haveFirstPoint) {\n            const corners = this.computeWindowCorners();\n            if (undefined === corners)\n                return;\n            this._shapePts[0].x = this._shapePts[3].x = corners[0].x;\n            this._shapePts[1].x = this._shapePts[2].x = corners[1].x;\n            this._shapePts[0].y = this._shapePts[1].y = corners[0].y;\n            this._shapePts[2].y = this._shapePts[3].y = corners[1].y;\n            this._shapePts[0].z = this._shapePts[1].z = this._shapePts[2].z = this._shapePts[3].z = corners[0].z;\n            this._shapePts[4].setFrom(this._shapePts[0]);\n            vp.viewToWorldArray(this._shapePts);\n            const builder = context.createGraphicBuilder(GraphicType.WorldOverlay);\n            builder.setBlankingFill(this._fillColor);\n            builder.addShape(this._shapePts);\n            builder.setSymbology(color, color, 1 /* ViewHandleWeight.Thin */);\n            builder.addLineString(this._shapePts);\n            builder.setSymbology(color, color, 8 /* ViewHandleWeight.FatDot */);\n            builder.addPointString([this._firstPtWorld]);\n            context.addDecorationFromBuilder(builder);\n            return;\n        }\n        if (undefined === this._lastPtView || context.viewport !== IModelApp.toolAdmin.cursorView)\n            return; // Full screen cross-hair only displays in cursor view...\n        const cursorPt = this._lastPtView.clone();\n        cursorPt.x = Math.floor(cursorPt.x) + 0.5;\n        cursorPt.y = Math.floor(cursorPt.y) + 0.5;\n        const viewRect = vp.viewRect;\n        const drawDecoration = (ctx) => {\n            ctx.beginPath();\n            ctx.strokeStyle = (ColorDef.black === color ? \"black\" : \"white\");\n            ctx.lineWidth = 1;\n            ctx.moveTo(viewRect.left, cursorPt.y);\n            ctx.lineTo(viewRect.right, cursorPt.y);\n            ctx.moveTo(cursorPt.x, viewRect.top);\n            ctx.lineTo(cursorPt.x, viewRect.bottom);\n            ctx.stroke();\n        };\n        context.addCanvasDecoration({ drawDecoration });\n    }\n    doManipulation(ev, inDynamics) {\n        this._secondPtWorld.setFrom(ev.point);\n        if (inDynamics) {\n            if (undefined !== this.viewport && undefined !== ev.viewport && !ev.viewport.view.hasSameCoordinates(this.viewport.view)) {\n                this._lastPtView = undefined;\n                return;\n            }\n            this._lastPtView = ev.viewPoint;\n            IModelApp.viewManager.invalidateDecorationsAllViews();\n            return;\n        }\n        const corners = this.computeWindowCorners();\n        if (undefined === corners)\n            return;\n        let delta;\n        const vp = this.viewport;\n        const view = vp.view;\n        vp.viewToWorldArray(corners);\n        const opts = {\n            onExtentsError: (stat) => view.outputStatusMessage(stat),\n        };\n        let globalAlignment;\n        if (view.is3d() && view.isCameraOn) {\n            const windowArray = [corners[0].clone(), corners[1].clone()];\n            vp.worldToViewArray(windowArray);\n            const windowRange = new ViewRect(windowArray[0].x, windowArray[0].y, windowArray[1].x, windowArray[1].y);\n            let npcZValues = vp.determineVisibleDepthRange(windowRange);\n            if (undefined === npcZValues)\n                npcZValues = { minimum: 0, maximum: ViewManip.getFocusPlaneNpc(vp) };\n            const lensAngle = view.getLensAngle();\n            vp.worldToNpcArray(corners);\n            corners[0].z = corners[1].z = npcZValues.maximum;\n            vp.npcToWorldArray(corners); // Put corners back in world at correct depth\n            const viewPts = [corners[0].clone(), corners[1].clone()];\n            vp.rotation.multiplyVectorArrayInPlace(viewPts); // rotate to view orientation to get extents\n            const range = Range3d.createArray(viewPts);\n            delta = Vector3d.createStartEnd(range.low, range.high);\n            const focusDist = delta.x / (2.0 * Math.tan(lensAngle.radians / 2));\n            const newTarget = corners[0].interpolate(.5, corners[1]);\n            const newEye = newTarget.plusScaled(view.getZVector(), focusDist);\n            if (ViewStatus.Success !== view.lookAt({ eyePoint: newEye, targetPoint: newTarget, upVector: view.getYVector(), lensAngle, opts }))\n                return;\n            globalAlignment = { target: newTarget };\n        }\n        else {\n            const rot = vp.rotation;\n            rot.multiplyVectorArrayInPlace(corners);\n            const range = Range3d.createArray(corners);\n            delta = Vector3d.createStartEnd(range.low, range.high);\n            // get the view extents\n            delta.z = view.getExtents().z;\n            const originVec = rot.multiplyTransposeXYZ(range.low.x, range.low.y, range.low.z);\n            // make sure its not too big or too small\n            const stat = view.adjustViewDelta(delta, originVec, rot, vp.viewRect.aspect, opts);\n            if (stat !== ViewStatus.Success)\n                return;\n            view.setExtents(delta);\n            view.setOrigin(originVec);\n            if (view.is3d())\n                globalAlignment = { target: range.center };\n        }\n        vp.synchWithView({ animateFrustumChange: true, globalAlignment });\n    }\n}\nWindowAreaTool.toolId = \"View.WindowArea\";\nWindowAreaTool.iconSpec = \"icon-window-area\";\nexport { WindowAreaTool };\n/** @internal */\nclass DefaultViewTouchTool extends ViewManip {\n    /** Move this handle during the inertia duration */\n    animate() {\n        if (undefined === this._inertiaVec)\n            return true; // handle was removed\n        // get the fraction of the inertia duration that remains. The decay is a combination of the number of iterations (see damping below)\n        // and time. That way the handle slows down even if the framerate is lower.\n        const remaining = ((this._end.milliseconds - BeTimePoint.now().milliseconds) / this._duration.milliseconds);\n        const pt = this._lastPtView.plusScaled(this._inertiaVec, remaining);\n        const vec = this._lastPtView.minus(pt);\n        // if we're not moving any more, or if the duration has elapsed, we're done\n        if (remaining <= 0 || (vec.magnitudeSquared() < .000001)) {\n            this.viewport.saveViewUndo();\n            return true; // remove this as the animator\n        }\n        this._lastPtView.setFrom(pt);\n        this.perform();\n        inertialDampen(this._inertiaVec);\n        return false;\n    }\n    interrupt() { }\n    constructor(startEv, ev, only2dManipulations = false) {\n        super(startEv.viewport, 0, true, false);\n        this._lastPtView = new Point3d();\n        this._startPtWorld = new Point3d();\n        this._startPtView = new Point3d();\n        this._frustum = new Frustum();\n        this._startDistance = 0.0;\n        this._startTouchCount = 0;\n        this._singleTouch = false;\n        this._rotate2dDisabled = false;\n        this._only2dManipulations = false;\n        this._only2dManipulations = only2dManipulations;\n        this.onStart(ev);\n    }\n    onStart(ev) {\n        const vp = this.viewport;\n        vp.getWorldFrustum(this._frustum);\n        const visiblePoint = vp.pickNearestVisibleGeometry(ev.rawPoint);\n        if (undefined !== visiblePoint) {\n            this._startPtWorld.setFrom(visiblePoint);\n            vp.worldToView(this._startPtWorld, this._startPtView);\n        }\n        else {\n            this._startPtView.setFrom(ev.viewPoint);\n            this._startPtView.z = vp.worldToView(ViewManip.getDefaultTargetPointWorld(vp)).z;\n            vp.viewToWorld(this._startPtView, this._startPtWorld);\n        }\n        this._rotate2dDisabled = false;\n        this._rotate2dThreshold = undefined;\n        this._lastPtView.setFrom(this._startPtView);\n        this._startTouchCount = ev.touchCount;\n        this._startDirection = (2 <= ev.touchCount ? Vector2d.createStartEnd(BeTouchEvent.getTouchPosition(ev.touchEvent.targetTouches[0], vp), BeTouchEvent.getTouchPosition(ev.touchEvent.targetTouches[1], vp)) : Vector2d.createZero());\n        this._startDistance = (2 === ev.touchCount ? this._startDirection.magnitude() : 0.0);\n    }\n    computeZoomRatio(ev) {\n        if (undefined === ev || 0.0 === this._startDistance)\n            return 1.0;\n        const vp = this.viewport;\n        const distance = (2 === ev.touchCount ? BeTouchEvent.getTouchPosition(ev.touchEvent.targetTouches[0], vp).distance(BeTouchEvent.getTouchPosition(ev.touchEvent.targetTouches[1], vp)) : 0.0);\n        const threshold = this.viewport.pixelsFromInches(ToolSettings.touchZoomChangeThresholdInches);\n        if (0.0 === distance || Math.abs(this._startDistance - distance) < threshold)\n            return 1.0;\n        // Remove inertia if the viewing operation includes zoom, only use it for pan and rotate.\n        this._inertiaVec = undefined;\n        const adjustedDist = (distance > this._startDistance ? (distance - threshold) : (distance + threshold)); // Avoid sudden jump in zoom scale by subtracting zoom threshold distance...\n        return Geometry.clamp(this._startDistance / adjustedDist, .1, 10);\n    }\n    computeRotation(ev) {\n        if (undefined === ev || ev.touchCount < 2 || this._rotate2dDisabled)\n            return Angle.createDegrees(0.0);\n        const vp = this.viewport;\n        const direction = Vector2d.createStartEnd(BeTouchEvent.getTouchPosition(ev.touchEvent.targetTouches[0], vp), BeTouchEvent.getTouchPosition(ev.touchEvent.targetTouches[1], vp));\n        const rotation = this._startDirection.angleTo(direction);\n        if (undefined === this._rotate2dThreshold) {\n            if (Math.abs(rotation.radians) < Angle.createDegrees(5.0).radians)\n                return Angle.createDegrees(0.0); // Check against threshold until sufficient rotation is detected...\n            const angularDistance = Math.abs(direction.magnitude() / 2.0 * Math.sin(Math.abs(rotation.radians)));\n            const zoomDistance = Math.abs(direction.magnitude() - this._startDirection.magnitude());\n            const panDistance = this._startPtView.distanceXY(this._lastPtView);\n            // NOTE: The * 0.75 below is because it's easy to confuse an attempted rotate for an attempted pan or zoom, and this tries to balance that without having a false positive in the opposite direction.\n            if (angularDistance < (zoomDistance * 0.75) || angularDistance < (panDistance * 0.75)) {\n                this._rotate2dDisabled = true; // Restrict subsequent view changes to pan and zoom only...\n                return Angle.createDegrees(0.0);\n            }\n            this._rotate2dThreshold = Angle.createRadians(-rotation.radians);\n        }\n        return Angle.createRadians(rotation.radians + this._rotate2dThreshold.radians); // Avoid jump when starting rotation...\n    }\n    handle2dPan() {\n        const screenDist = Point2d.create(this._startPtView.x - this._lastPtView.x, this._startPtView.y - this._lastPtView.y);\n        this.viewport.scroll(screenDist, { noSaveInUndo: true });\n    }\n    handle2dRotateZoom(ev) {\n        const vp = this.viewport;\n        const rotation = this.computeRotation(ev);\n        const zoomRatio = this.computeZoomRatio(ev);\n        const targetWorld = vp.viewToWorld(this._lastPtView);\n        const translateTransform = Transform.createTranslation(this._startPtWorld.minus(targetWorld));\n        const rotationTransform = Transform.createFixedPointAndMatrix(targetWorld, Matrix3d.createRotationAroundVector(vp.view.getZVector(), rotation));\n        const scaleTransform = Transform.createScaleAboutPoint(this._startPtWorld, zoomRatio);\n        const transform = translateTransform.multiplyTransformTransform(rotationTransform);\n        scaleTransform.multiplyTransformTransform(transform, transform);\n        const frustum = this._frustum.transformBy(transform);\n        vp.setupViewFromFrustum(frustum);\n    }\n    handle3dRotate() {\n        const vp = this.viewport;\n        const viewRect = vp.viewRect;\n        const xExtent = viewRect.width;\n        const yExtent = viewRect.height;\n        const xDelta = this._lastPtView.x - this._startPtView.x;\n        const yDelta = this._lastPtView.y - this._startPtView.y;\n        const xAxis = ToolSettings.preserveWorldUp ? Vector3d.unitZ() : vp.rotation.getRow(1);\n        const yAxis = vp.rotation.getRow(0);\n        const xRMatrix = (0.0 !== xDelta) ? Matrix3d.createRotationAroundVector(xAxis, Angle.createRadians(Math.PI / (xExtent / xDelta))) : Matrix3d.identity;\n        const yRMatrix = (0.0 !== yDelta) ? Matrix3d.createRotationAroundVector(yAxis, Angle.createRadians(Math.PI / (yExtent / yDelta))) : Matrix3d.identity;\n        const worldRMatrix = yRMatrix.multiplyMatrixMatrix(xRMatrix);\n        const result = worldRMatrix.getAxisAndAngleOfRotation();\n        const radians = Angle.createRadians(-result.angle.radians);\n        const worldAxis = result.axis;\n        const rotationMatrix = Matrix3d.createRotationAroundVector(worldAxis, radians);\n        if (undefined === rotationMatrix)\n            return;\n        const worldTransform = Transform.createFixedPointAndMatrix(this._startPtWorld, rotationMatrix);\n        const frustum = this._frustum.transformBy(worldTransform);\n        vp.setupViewFromFrustum(frustum);\n    }\n    handle3dPanZoom(ev) {\n        const vp = this.viewport;\n        const zoomRatio = this.computeZoomRatio(ev);\n        if (vp.isCameraOn) {\n            const targetWorld = vp.viewToWorld(this._lastPtView);\n            const preTrans = Transform.createTranslationXYZ(-targetWorld.x, -targetWorld.y, -targetWorld.z);\n            const postTrans = Transform.createTranslation(this._startPtWorld);\n            preTrans.origin.scaleInPlace(zoomRatio);\n            preTrans.matrix.scale(zoomRatio, preTrans.matrix);\n            const cameraTransform = postTrans.multiplyTransformTransform(preTrans);\n            const view = vp.view;\n            const oldEyePoint = view.getEyePoint();\n            const newEyePoint = cameraTransform.multiplyPoint3d(oldEyePoint);\n            const cameraOffset = newEyePoint.minus(oldEyePoint);\n            const cameraOffsetTransform = Transform.createTranslation(cameraOffset);\n            const frustum = this._frustum.transformBy(cameraOffsetTransform);\n            vp.setupViewFromFrustum(frustum);\n            return;\n        }\n        const targetNpc = vp.viewToNpc(this._lastPtView);\n        const transform = Transform.createFixedPointAndMatrix(targetNpc, Matrix3d.createScale(zoomRatio, zoomRatio, 1.0));\n        const viewCenter = Point3d.create(.5, .5, .5);\n        const startPtNpc = vp.viewToNpc(this._startPtView);\n        const shift = startPtNpc.minus(targetNpc);\n        shift.z = 0.0;\n        const offset = Transform.createTranslation(shift);\n        offset.multiplyTransformTransform(transform, transform);\n        transform.multiplyPoint3d(viewCenter, viewCenter);\n        vp.npcToWorld(viewCenter, viewCenter);\n        vp.zoom(viewCenter, zoomRatio, { noSaveInUndo: true });\n    }\n    handleEvent(ev) {\n        if (undefined === this.viewport)\n            return;\n        if (this._startTouchCount !== ev.touchCount) {\n            this.onStart(ev);\n            return;\n        }\n        this._inertiaVec = undefined;\n        const thisPt = ev.viewPoint;\n        const smallDistance = 2.0;\n        const samePoint = this._lastPtView.isAlmostEqualXY(thisPt, smallDistance);\n        if (1 === ev.touchCount && samePoint)\n            return; // Don't early return if multi-touch, center doesn't have to move for zoom...\n        if (this._startPtView.isAlmostEqualXY(thisPt, smallDistance)) {\n            this._lastPtView.setFrom(this._startPtView);\n        }\n        else {\n            if (!samePoint) {\n                this._inertiaVec = this._lastPtView.vectorTo(thisPt);\n                this._inertiaVec.z = 0;\n            }\n            this._singleTouch = ev.isSingleTouch;\n            this._lastPtView.setFrom(thisPt);\n            this._lastPtView.z = this._startPtView.z;\n        }\n        this.perform(ev);\n    }\n    perform(ev) {\n        const vp = this.viewport;\n        vp.setupViewFromFrustum(this._frustum);\n        const singleTouch = this._singleTouch;\n        return (!this._only2dManipulations && vp.view.allow3dManipulations()) ?\n            singleTouch ? this.handle3dRotate() : this.handle3dPanZoom(ev) :\n            singleTouch ? this.handle2dPan() : this.handle2dRotateZoom(ev);\n    }\n    async onDataButtonDown(_ev) { return EventHandled.Yes; }\n    async onDataButtonUp(_ev) { return EventHandled.Yes; }\n    async onTouchStart(ev) {\n        if (undefined !== this.viewport)\n            this.onStart(ev);\n    }\n    async onTouchMove(ev) {\n        this.handleEvent(ev);\n    }\n    async onTouchCancel(_ev) { return this.exitTool(); }\n    async onTouchComplete(_ev) {\n        // if we were moving when the touch ended, add inertia to the viewing operation\n        if (this._inertiaVec) {\n            this._duration = ToolSettings.viewingInertia.duration;\n            if (this._duration.isTowardsFuture) { // ensure duration is towards future. Otherwise, don't start animation\n                this._end = BeTimePoint.fromNow(this._duration);\n                this.viewport.setAnimator(this);\n            }\n        }\n        return this.exitTool();\n    }\n}\nDefaultViewTouchTool.toolId = \"\"; // touch tools installed by IdleTool are never registered\nexport { DefaultViewTouchTool };\n/** A tool that performs view undo operation. An application could also just call Viewport.doUndo directly, creating a ViewTool isn't required.\n * @public\n */\nclass ViewUndoTool extends ViewTool {\n    async onPostInstall() {\n        if (this.viewport)\n            this.viewport.doUndo(ScreenViewport.animation.time.normal);\n        return this.exitTool();\n    }\n}\nViewUndoTool.toolId = \"View.Undo\";\nViewUndoTool.iconSpec = \"icon-window-backward\";\nexport { ViewUndoTool };\n/** A tool that performs view redo operation. An application could also just call Viewport.doRedo directly, creating a ViewTool isn't required.\n * @public\n */\nclass ViewRedoTool extends ViewTool {\n    async onPostInstall() {\n        if (this.viewport)\n            this.viewport.doRedo(ScreenViewport.animation.time.normal);\n        return this.exitTool();\n    }\n}\nViewRedoTool.toolId = \"View.Redo\";\nViewRedoTool.iconSpec = \"icon-window-forward\";\nexport { ViewRedoTool };\n/** A tool that toggles the camera on/off in a spatial view\n * @public\n */\nclass ViewToggleCameraTool extends ViewTool {\n    async onInstall() { return (undefined !== this.viewport && this.viewport.view.allow3dManipulations()); }\n    async onPostInstall() {\n        if (this.viewport) {\n            const vp = this.viewport;\n            if (vp.isCameraOn)\n                vp.view.turnCameraOff();\n            else\n                vp.turnCameraOn();\n            vp.synchWithView();\n        }\n        return this.exitTool();\n    }\n}\nViewToggleCameraTool.toolId = \"View.ToggleCamera\";\nViewToggleCameraTool.iconSpec = \"icon-camera\";\nexport { ViewToggleCameraTool };\n/** A tool that sets the view camera by two points. This is a PrimitiveTool and not a ViewTool to allow the view to be panned, zoomed, and rotated while defining the points.\n * To show tool settings for specifying camera and target heights above the snap point, make sure formatting and parsing data are cached before the tool starts\n * by calling QuantityFormatter.onInitialized at app startup.\n * @public\n */\nclass SetupCameraTool extends PrimitiveTool {\n    constructor() {\n        super(...arguments);\n        this._haveEyePt = false;\n        this._eyePtWorld = Point3d.create();\n        this._targetPtWorld = Point3d.create();\n    }\n    isCompatibleViewport(vp, isSelectedViewChange) { return (super.isCompatibleViewport(vp, isSelectedViewChange) && undefined !== vp && vp.view.allow3dManipulations()); }\n    isValidLocation(_ev, _isButtonEvent) { return true; }\n    requireWriteableTarget() { return false; }\n    async onPostInstall() {\n        await super.onPostInstall();\n        this.setupAndPromptForNextAction();\n    }\n    async onUnsuspend() { this.provideToolAssistance(); }\n    setupAndPromptForNextAction() {\n        IModelApp.accuSnap.enableSnap(true);\n        this.provideToolAssistance();\n    }\n    async onResetButtonUp(_ev) {\n        if (this._haveEyePt)\n            await this.onReinitialize();\n        else\n            await this.exitTool();\n        return EventHandled.Yes;\n    }\n    /** @beta */\n    provideToolAssistance() {\n        const mainInstruction = ToolAssistance.createInstruction(this.iconSpec, ViewTool.translate(this._haveEyePt ? \"SetupCamera.Prompts.NextPoint\" : \"SetupCamera.Prompts.FirstPoint\"));\n        const mouseInstructions = [];\n        const touchInstructions = [];\n        const acceptMsg = CoreTools.translate(\"ElementSet.Inputs.AcceptPoint\");\n        const rejectMsg = CoreTools.translate(this._haveEyePt ? \"ElementSet.Inputs.Restart\" : \"ElementSet.Inputs.Exit\");\n        if (!ToolAssistance.createTouchCursorInstructions(touchInstructions))\n            touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.OneTouchTap, acceptMsg, false, ToolAssistanceInputMethod.Touch));\n        mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.LeftClick, acceptMsg, false, ToolAssistanceInputMethod.Mouse));\n        touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.TwoTouchTap, rejectMsg, false, ToolAssistanceInputMethod.Touch));\n        mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.RightClick, rejectMsg, false, ToolAssistanceInputMethod.Mouse));\n        const sections = [];\n        sections.push(ToolAssistance.createSection(mouseInstructions, ToolAssistance.inputsLabel));\n        sections.push(ToolAssistance.createSection(touchInstructions, ToolAssistance.inputsLabel));\n        const instructions = ToolAssistance.createInstructions(mainInstruction, sections);\n        IModelApp.notifications.setToolAssistance(instructions);\n    }\n    async onRestartTool() {\n        const tool = new SetupCameraTool();\n        if (!await tool.run())\n            return this.exitTool();\n    }\n    getAdjustedEyePoint() { return this.useCameraHeight ? this._eyePtWorld.plusScaled(Vector3d.unitZ(), this.cameraHeight) : this._eyePtWorld; }\n    getAdjustedTargetPoint() { return this.useTargetHeight ? this._targetPtWorld.plusScaled(Vector3d.unitZ(), this.targetHeight) : this._targetPtWorld; }\n    async onDataButtonDown(ev) {\n        if (undefined === ev.viewport) {\n            return EventHandled.Yes;\n        }\n        else if (undefined === this.viewport) {\n            if (!ev.viewport.view.allow3dManipulations())\n                return EventHandled.Yes;\n            this.viewport = ev.viewport;\n        }\n        else if (this.viewport.view.iModel !== ev.viewport.view.iModel) {\n            if (this._haveEyePt)\n                return EventHandled.Yes;\n            this.viewport = ev.viewport;\n            return EventHandled.Yes;\n        }\n        if (this._haveEyePt) {\n            this._targetPtWorld.setFrom(ev.point);\n            this.doManipulation();\n            await this.onReinitialize();\n        }\n        else {\n            this._eyePtWorld.setFrom(ev.point);\n            this._targetPtWorld.setFrom(this._eyePtWorld);\n            this._haveEyePt = true;\n            this.setupAndPromptForNextAction();\n        }\n        return EventHandled.Yes;\n    }\n    async onMouseMotion(ev) {\n        if (!this._haveEyePt)\n            return;\n        this._targetPtWorld.setFrom(ev.point);\n        IModelApp.viewManager.invalidateDecorationsAllViews();\n    }\n    static drawCameraFrustum(context, vp, eyePtWorld, targetPtWorld, eyeSnapPtWorld, targetSnapPtWorld) {\n        if (!vp.view.is3d() || vp.view.iModel !== context.viewport.view.iModel)\n            return;\n        const zVec = Vector3d.createStartEnd(eyePtWorld, targetPtWorld);\n        const focusDist = zVec.normalizeWithLength(zVec).mag;\n        if (focusDist <= Constant.oneMillimeter) // eye and target are too close together\n            return;\n        const xVec = new Vector3d();\n        const yVec = Vector3d.unitZ();\n        if (yVec.crossProduct(zVec).normalizeWithLength(xVec).mag < Geometry.smallMetricDistance)\n            return;\n        if (zVec.crossProduct(xVec).normalizeWithLength(yVec).mag < Geometry.smallMetricDistance)\n            return;\n        const lensAngle = ToolSettings.walkCameraAngle;\n        const extentX = Math.tan(lensAngle.radians / 2.0) * focusDist;\n        const extentY = extentX * (vp.view.extents.y / vp.view.extents.x);\n        const pt1 = targetPtWorld.plusScaled(xVec, -extentX);\n        pt1.plusScaled(yVec, extentY, pt1);\n        const pt2 = targetPtWorld.plusScaled(xVec, extentX);\n        pt2.plusScaled(yVec, extentY, pt2);\n        const pt3 = targetPtWorld.plusScaled(xVec, extentX);\n        pt3.plusScaled(yVec, -extentY, pt3);\n        const pt4 = targetPtWorld.plusScaled(xVec, -extentX);\n        pt4.plusScaled(yVec, -extentY, pt4);\n        const color = EditManipulator.HandleUtils.adjustForBackgroundColor(ColorDef.black, vp);\n        const builderHid = context.createGraphicBuilder(GraphicType.WorldOverlay);\n        builderHid.setSymbology(color, color, 3 /* ViewHandleWeight.Bold */);\n        builderHid.addLineString([eyePtWorld, targetPtWorld]);\n        builderHid.setSymbology(color, color, 1 /* ViewHandleWeight.Thin */, LinePixels.Code2);\n        builderHid.addLineString([eyePtWorld, pt1]);\n        builderHid.addLineString([eyePtWorld, pt2]);\n        builderHid.addLineString([eyePtWorld, pt3]);\n        builderHid.addLineString([eyePtWorld, pt4]);\n        builderHid.addLineString([pt1, pt2, pt3, pt4, pt1]);\n        if (eyeSnapPtWorld)\n            builderHid.addLineString([eyeSnapPtWorld, eyePtWorld]);\n        if (targetSnapPtWorld)\n            builderHid.addLineString([targetSnapPtWorld, targetPtWorld]);\n        builderHid.setSymbology(color, color, 8 /* ViewHandleWeight.FatDot */);\n        builderHid.addPointString([eyePtWorld, targetPtWorld]);\n        if (eyeSnapPtWorld)\n            builderHid.addPointString([eyeSnapPtWorld]);\n        if (targetSnapPtWorld)\n            builderHid.addPointString([targetSnapPtWorld]);\n        context.addDecorationFromBuilder(builderHid);\n        const backColor = ColorDef.from(0, 0, 255, 200);\n        const sideColor = context.viewport.hilite.color.withAlpha(25);\n        const builderVis = context.createGraphicBuilder(GraphicType.WorldDecoration);\n        builderVis.setSymbology(color, color, 2 /* ViewHandleWeight.Normal */);\n        builderVis.addLineString([eyePtWorld, pt1]);\n        builderVis.addLineString([eyePtWorld, pt2]);\n        builderVis.addLineString([eyePtWorld, pt3]);\n        builderVis.addLineString([eyePtWorld, pt4]);\n        builderVis.addLineString([pt1, pt2, pt3, pt4, pt1]);\n        builderVis.setSymbology(color, backColor, 1 /* ViewHandleWeight.Thin */);\n        builderVis.addShape([pt1, pt2, pt3, pt4]);\n        builderVis.setSymbology(color, sideColor, 1 /* ViewHandleWeight.Thin */);\n        builderVis.addShape([eyePtWorld, pt1, pt2]);\n        builderVis.addShape([eyePtWorld, pt2, pt3]);\n        builderVis.addShape([eyePtWorld, pt3, pt4]);\n        builderVis.addShape([eyePtWorld, pt4, pt1]);\n        context.addDecorationFromBuilder(builderVis);\n    }\n    decorate(context) {\n        if (!this._haveEyePt || undefined === this.viewport)\n            return;\n        SetupCameraTool.drawCameraFrustum(context, this.viewport, this.getAdjustedEyePoint(), this.getAdjustedTargetPoint(), this.useCameraHeight ? this._eyePtWorld : undefined, this.useTargetHeight ? this._targetPtWorld : undefined);\n    }\n    decorateSuspended(context) { this.decorate(context); }\n    doManipulation() {\n        const vp = this.viewport;\n        if (undefined === vp)\n            return;\n        const view = vp.view;\n        if (!view.is3d() || !view.allow3dManipulations())\n            return;\n        const eyePoint = this.getAdjustedEyePoint();\n        const targetPoint = this.getAdjustedTargetPoint();\n        const lensAngle = ToolSettings.walkCameraAngle;\n        if (ViewStatus.Success !== view.lookAt({ eyePoint, targetPoint, upVector: Vector3d.unitZ(), lensAngle }))\n            return;\n        vp.synchWithView({ animateFrustumChange: true });\n    }\n    get useCameraHeightProperty() {\n        if (!this._useCameraHeightProperty)\n            this._useCameraHeightProperty = new DialogProperty(PropertyDescriptionHelper.buildLockPropertyDescription(\"useCameraHeight\"), false, undefined, false);\n        return this._useCameraHeightProperty;\n    }\n    get useCameraHeight() { return this.useCameraHeightProperty.value; }\n    set useCameraHeight(option) { this.useCameraHeightProperty.value = option; }\n    get cameraHeightProperty() {\n        if (!this._cameraHeightProperty)\n            this._cameraHeightProperty = new DialogProperty(new LengthDescription(\"cameraHeight\", ViewTool.translate(\"SetupCamera.Labels.CameraHeight\")), 0.0, undefined, !this.useCameraHeight);\n        return this._cameraHeightProperty;\n    }\n    get cameraHeight() { return this.cameraHeightProperty.value; }\n    set cameraHeight(value) { this.cameraHeightProperty.value = value; }\n    get useTargetHeightProperty() {\n        if (!this._useTargetHeightProperty)\n            this._useTargetHeightProperty = new DialogProperty(PropertyDescriptionHelper.buildLockPropertyDescription(\"useTargetHeight\"), false, undefined, false);\n        return this._useTargetHeightProperty;\n    }\n    get useTargetHeight() { return this.useTargetHeightProperty.value; }\n    set useTargetHeight(value) { this.useTargetHeightProperty.value = value; }\n    get targetHeightProperty() {\n        if (!this._targetHeightProperty)\n            this._targetHeightProperty = new DialogProperty(new LengthDescription(\"targetHeight\", ViewTool.translate(\"SetupCamera.Labels.TargetHeight\")), 0.0, undefined, !this.useTargetHeight);\n        return this._targetHeightProperty;\n    }\n    get targetHeight() { return this.targetHeightProperty.value; }\n    set targetHeight(value) { this.targetHeightProperty.value = value; }\n    syncCameraHeightState() {\n        this.cameraHeightProperty.displayValue = this.cameraHeightProperty.description.format(this.cameraHeight);\n        this.cameraHeightProperty.isDisabled = !this.useCameraHeight;\n        this.syncToolSettingsProperties([this.cameraHeightProperty.syncItem]);\n    }\n    syncTargetHeightState() {\n        this.targetHeightProperty.displayValue = this.targetHeightProperty.description.format(this.targetHeight);\n        this.targetHeightProperty.isDisabled = !this.useTargetHeight;\n        this.syncToolSettingsProperties([this.targetHeightProperty.syncItem]);\n    }\n    async applyToolSettingPropertyChange(updatedValue) {\n        if (updatedValue.propertyName === this.useCameraHeightProperty.name) {\n            this.useCameraHeight = updatedValue.value.value;\n            IModelApp.toolAdmin.toolSettingsState.saveToolSettingProperty(this.toolId, this.useCameraHeightProperty.item);\n            this.syncCameraHeightState();\n        }\n        else if (updatedValue.propertyName === this.useTargetHeightProperty.name) {\n            this.useTargetHeight = updatedValue.value.value;\n            IModelApp.toolAdmin.toolSettingsState.saveToolSettingProperty(this.toolId, this.useTargetHeightProperty.item);\n            this.syncTargetHeightState();\n        }\n        else if (updatedValue.propertyName === this.cameraHeightProperty.name) {\n            this.cameraHeight = updatedValue.value.value;\n            IModelApp.toolAdmin.toolSettingsState.saveToolSettingProperty(this.toolId, this.cameraHeightProperty.item);\n        }\n        else if (updatedValue.propertyName === this.targetHeightProperty.name) {\n            this.targetHeight = updatedValue.value.value;\n            IModelApp.toolAdmin.toolSettingsState.saveToolSettingProperty(this.toolId, this.targetHeightProperty.item);\n        }\n        return true;\n    }\n    supplyToolSettingsProperties() {\n        // load latest values from session\n        IModelApp.toolAdmin.toolSettingsState.getInitialToolSettingValues(this.toolId, [\n            this.useCameraHeightProperty.name, this.useTargetHeightProperty.name, this.cameraHeightProperty.name, this.targetHeightProperty.name,\n        ])\n            ?.forEach((value) => {\n            if (value.propertyName === this.useCameraHeightProperty.name)\n                this.useCameraHeightProperty.dialogItemValue = value.value;\n            else if (value.propertyName === this.cameraHeightProperty.name)\n                this.cameraHeightProperty.dialogItemValue = value.value;\n            else if (value.propertyName === this.useTargetHeightProperty.name)\n                this.useTargetHeightProperty.dialogItemValue = value.value;\n            else if (value.propertyName === this.targetHeightProperty.name)\n                this.targetHeightProperty.dialogItemValue = value.value;\n        });\n        // ensure controls are enabled/disabled base on current lock property state\n        this.targetHeightProperty.isDisabled = !this.useTargetHeight;\n        this.cameraHeightProperty.isDisabled = !this.useCameraHeight;\n        const cameraHeightLock = this.useCameraHeightProperty.toDialogItem({ rowPriority: 1, columnIndex: 0 });\n        const targetHeightLock = this.useTargetHeightProperty.toDialogItem({ rowPriority: 2, columnIndex: 0 });\n        const toolSettings = new Array();\n        toolSettings.push(this.cameraHeightProperty.toDialogItem({ rowPriority: 1, columnIndex: 1 }, cameraHeightLock));\n        toolSettings.push(this.targetHeightProperty.toDialogItem({ rowPriority: 2, columnIndex: 1 }, targetHeightLock));\n        return toolSettings;\n    }\n}\nSetupCameraTool.toolId = \"View.SetupCamera\";\nSetupCameraTool.iconSpec = \"icon-camera-location\";\nexport { SetupCameraTool };\n/** A tool that sets a walk tool starting position by a floor point and look direction. This is a PrimitiveTool and not a ViewTool to allow the view to be panned, zoomed, and rotated while defining the points.\n * @public\n */\nclass SetupWalkCameraTool extends PrimitiveTool {\n    constructor() {\n        super(...arguments);\n        this._haveEyePt = false;\n        this._eyePtWorld = Point3d.create();\n        this._targetPtWorld = Point3d.create();\n    }\n    isCompatibleViewport(vp, isSelectedViewChange) { return (super.isCompatibleViewport(vp, isSelectedViewChange) && undefined !== vp && vp.view.allow3dManipulations()); }\n    isValidLocation(_ev, _isButtonEvent) { return true; }\n    requireWriteableTarget() { return false; }\n    async onPostInstall() {\n        await super.onPostInstall();\n        this.setupAndPromptForNextAction();\n    }\n    async onUnsuspend() { this.provideToolAssistance(); }\n    setupAndPromptForNextAction() {\n        IModelApp.accuSnap.enableSnap(true);\n        this.provideToolAssistance();\n    }\n    async onResetButtonUp(_ev) {\n        if (this._haveEyePt)\n            await this.onReinitialize();\n        else\n            await this.exitTool();\n        return EventHandled.Yes;\n    }\n    /** @beta */\n    provideToolAssistance() {\n        const mainInstruction = ToolAssistance.createInstruction(this.iconSpec, ViewTool.translate(this._haveEyePt ? \"SetupWalkCamera.Prompts.NextPoint\" : \"SetupWalkCamera.Prompts.FirstPoint\"));\n        const mouseInstructions = [];\n        const touchInstructions = [];\n        const acceptMsg = CoreTools.translate(\"ElementSet.Inputs.AcceptPoint\");\n        const rejectMsg = CoreTools.translate(this._haveEyePt ? \"ElementSet.Inputs.Restart\" : \"ElementSet.Inputs.Exit\");\n        if (!ToolAssistance.createTouchCursorInstructions(touchInstructions))\n            touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.OneTouchTap, acceptMsg, false, ToolAssistanceInputMethod.Touch));\n        mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.LeftClick, acceptMsg, false, ToolAssistanceInputMethod.Mouse));\n        touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.TwoTouchTap, rejectMsg, false, ToolAssistanceInputMethod.Touch));\n        mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.RightClick, rejectMsg, false, ToolAssistanceInputMethod.Mouse));\n        const sections = [];\n        sections.push(ToolAssistance.createSection(mouseInstructions, ToolAssistance.inputsLabel));\n        sections.push(ToolAssistance.createSection(touchInstructions, ToolAssistance.inputsLabel));\n        const instructions = ToolAssistance.createInstructions(mainInstruction, sections);\n        IModelApp.notifications.setToolAssistance(instructions);\n    }\n    async onRestartTool() {\n        const tool = new SetupWalkCameraTool();\n        if (!await tool.run())\n            return this.exitTool();\n    }\n    getAdjustedEyePoint() { return this._eyePtWorld.plusScaled(Vector3d.unitZ(), ToolSettings.walkEyeHeight); }\n    getAdjustedTargetPoint() { return Point3d.create(this._targetPtWorld.x, this._targetPtWorld.y, this.getAdjustedEyePoint().z); }\n    async onDataButtonDown(ev) {\n        if (undefined === ev.viewport) {\n            return EventHandled.Yes;\n        }\n        else if (undefined === this.viewport) {\n            if (!ev.viewport.view.allow3dManipulations())\n                return EventHandled.Yes;\n            this.viewport = ev.viewport;\n        }\n        else if (this.viewport.view.iModel !== ev.viewport.view.iModel) {\n            if (this._haveEyePt)\n                return EventHandled.Yes;\n            this.viewport = ev.viewport;\n            return EventHandled.Yes;\n        }\n        if (this._haveEyePt) {\n            this._targetPtWorld.setFrom(ev.point);\n            this.doManipulation();\n            await this.onReinitialize();\n        }\n        else {\n            this._eyePtWorld.setFrom(ev.point);\n            this._targetPtWorld.setFrom(this._eyePtWorld);\n            this._haveEyePt = true;\n            this.setupAndPromptForNextAction();\n        }\n        return EventHandled.Yes;\n    }\n    async onMouseMotion(ev) {\n        if (!this._haveEyePt)\n            return;\n        this._targetPtWorld.setFrom(ev.point);\n        IModelApp.viewManager.invalidateDecorationsAllViews();\n    }\n    static getFigurePoints() {\n        const figurePts = [];\n        figurePts.push(Point3d.create(1.064, -0.014));\n        figurePts.push(Point3d.create(1.051, 0.039));\n        figurePts.push(Point3d.create(1.008, 0.058));\n        figurePts.push(Point3d.create(0.962, 0.048));\n        figurePts.push(Point3d.create(0.920, 0.026));\n        figurePts.push(Point3d.create(0.898, 0.026));\n        figurePts.push(Point3d.create(0.853, 0.094));\n        figurePts.push(Point3d.create(0.741, 0.120));\n        figurePts.push(Point3d.create(0.652, 0.091));\n        figurePts.push(Point3d.create(0.514, 0.107));\n        figurePts.push(Point3d.create(0.304, 0.108));\n        figurePts.push(Point3d.create(0.040, 0.135));\n        figurePts.push(Point3d.create(-0.023, 0.133));\n        figurePts.push(Point3d.create(-0.031, 0.088));\n        figurePts.push(Point3d.create(0.041, 0.068));\n        figurePts.push(Point3d.create(0.299, 0.035));\n        figurePts.push(Point3d.create(0.447, -0.015));\n        figurePts.push(Point3d.create(0.267, -0.042));\n        figurePts.push(Point3d.create(0.019, -0.036));\n        figurePts.push(Point3d.create(-0.027, -0.146));\n        figurePts.push(Point3d.create(-0.005, -0.179));\n        figurePts.push(Point3d.create(0.056, -0.108));\n        figurePts.push(Point3d.create(0.270, -0.122));\n        figurePts.push(Point3d.create(0.483, -0.120));\n        figurePts.push(Point3d.create(0.649, -0.145));\n        figurePts.push(Point3d.create(0.715, -0.186));\n        figurePts.push(Point3d.create(0.865, -0.135));\n        figurePts.push(Point3d.create(0.905, -0.039));\n        figurePts.push(Point3d.create(0.948, -0.035));\n        figurePts.push(Point3d.create(0.979, -0.051));\n        figurePts.push(Point3d.create(1.037, -0.046));\n        figurePts.push(figurePts[0].clone());\n        return figurePts;\n    }\n    static getFigureTransform(vp, base, direction, scale) {\n        const boresite = AccuDrawHintBuilder.getBoresite(base, vp);\n        if (Math.abs(direction.dotProduct(boresite.direction)) >= 0.9999)\n            return undefined;\n        const matrix = Matrix3d.createRigidFromColumns(direction, boresite.direction, AxisOrder.XZY);\n        if (undefined === matrix)\n            return undefined;\n        matrix.scaleColumnsInPlace(scale, scale, scale);\n        return Transform.createRefs(base.clone(), matrix);\n    }\n    static drawFigure(context, vp, groundPt, eyeHeight) {\n        if (!vp.view.is3d() || vp.view.iModel !== context.viewport.view.iModel)\n            return;\n        const transform = this.getFigureTransform(context.viewport, groundPt, Vector3d.unitZ(), eyeHeight);\n        if (undefined === transform)\n            return;\n        const figurePts = this.getFigurePoints();\n        const color = EditManipulator.HandleUtils.adjustForBackgroundColor(ColorDef.black, vp);\n        const fill = ColorDef.from(255, 245, 225, 100);\n        const builderShadow = context.createGraphicBuilder(GraphicType.WorldOverlay);\n        builderShadow.setSymbology(color, ColorDef.black.withAlpha(30), 1 /* ViewHandleWeight.Thin */);\n        builderShadow.addArc(Arc3d.createXY(groundPt, eyeHeight * 0.22), true, true);\n        context.addDecorationFromBuilder(builderShadow);\n        const builderHid = context.createGraphicBuilder(GraphicType.WorldDecoration, transform);\n        builderHid.setSymbology(color, fill, 1 /* ViewHandleWeight.Thin */);\n        builderHid.addShape(figurePts); // Copies points...\n        context.addDecorationFromBuilder(builderHid);\n        const builderVis = context.createGraphicBuilder(GraphicType.WorldOverlay, transform);\n        builderVis.setSymbology(color, color, 2 /* ViewHandleWeight.Normal */);\n        builderVis.addLineString(figurePts); // Owns points...\n        context.addDecorationFromBuilder(builderVis);\n    }\n    decorate(context) {\n        if (!this._haveEyePt || undefined === this.viewport)\n            return;\n        SetupWalkCameraTool.drawFigure(context, this.viewport, this._eyePtWorld, ToolSettings.walkEyeHeight);\n        SetupCameraTool.drawCameraFrustum(context, this.viewport, this.getAdjustedEyePoint(), this.getAdjustedTargetPoint(), this._eyePtWorld, this._targetPtWorld);\n    }\n    decorateSuspended(context) { this.decorate(context); }\n    doManipulation() {\n        const vp = this.viewport;\n        if (undefined === vp)\n            return;\n        const view = vp.view;\n        if (!view.is3d() || !view.allow3dManipulations())\n            return;\n        const eyePoint = this.getAdjustedEyePoint();\n        const targetPoint = this.getAdjustedTargetPoint();\n        const lensAngle = ToolSettings.walkCameraAngle;\n        if (ViewStatus.Success !== view.lookAt({ eyePoint, targetPoint, upVector: Vector3d.unitZ(), lensAngle }))\n            return;\n        vp.synchWithView({ animateFrustumChange: true });\n    }\n}\nSetupWalkCameraTool.toolId = \"View.SetupWalkCamera\";\nSetupWalkCameraTool.iconSpec = \"icon-camera-location\";\nexport { SetupWalkCameraTool };\n//# sourceMappingURL=ViewTool.js.map",
      "start": 1693508119790,
      "end": 1693508120140,
      "sourcemaps": null
    }
  ]
}
