{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/orbitgt/lib/esm/pointcloud/format/opc/BlockRecord.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module OrbitGT\n */\nimport { LittleEndian } from \"../../../system/buffer/LittleEndian\";\nimport { Numbers } from \"../../../system/runtime/Numbers\";\nimport { BlockIndex } from \"../../model/BlockIndex\";\nimport { GridIndex } from \"../../model/GridIndex\";\n/**\n * Class BlockRecord defines a (32x32x32) block of tiles.\n *\n * @version 1.0 January 2014\n */\n/** @internal */\nclass BlockRecord {\n    /**\n     * No instances.\n     */\n    constructor() {\n    }\n    /**\n     * Convert a tile grid index to a block grid index.\n     * @param tileIndex the tile index.\n     * @param blockSize the block size.\n     * @return the block index.\n     */\n    static toBlockIndex1(tileIndex, blockSize) {\n        if (tileIndex < 0)\n            return Numbers.divInt((tileIndex + 1), blockSize) - 1;\n        return Numbers.divInt(tileIndex, blockSize);\n    }\n    /**\n     * Convert a tile grid index to a block grid index.\n     * @param tileX the x index of the tile.\n     * @param tileY the y index of the tile.\n     * @param tileZ the z index of the tile.\n     * @param blockSize the block size.\n     * @return the block index.\n     */\n    static toBlockIndex(tileX, tileY, tileZ, blockSize) {\n        return new GridIndex(BlockRecord.toBlockIndex1(tileX, blockSize), BlockRecord.toBlockIndex1(tileY, blockSize), BlockRecord.toBlockIndex1(tileZ, blockSize));\n    }\n    /**\n     * Write a record.\n     * @param output the output stream.\n     */\n    static write(block, output) {\n        let blockX = block.gridIndex.x;\n        let blockY = block.gridIndex.y;\n        let blockZ = block.gridIndex.z;\n        LittleEndian.writeStreamInt(output, blockX);\n        LittleEndian.writeStreamInt(output, blockY);\n        LittleEndian.writeStreamInt(output, blockZ);\n        LittleEndian.writeStreamInt(output, block.tileCount);\n        LittleEndian.writeStreamLong(output, block.pointCount);\n    }\n    /**\n     * Read a record.\n     * @param level the level.\n     * @param in the input stream from the file.\n     * @param tileIndex the index of the tile.\n     * @param pointIndex the index of the first point in the block.\n     * @return the requested record.\n     */\n    static readNew(level, input, blockIndex, tileIndex, pointIndex) {\n        /* Read the record */\n        let blockX = LittleEndian.readStreamInt(input);\n        let blockY = LittleEndian.readStreamInt(input);\n        let blockZ = LittleEndian.readStreamInt(input);\n        let tileCount = LittleEndian.readStreamInt(input);\n        let pointCount = LittleEndian.readStreamLong(input);\n        /* Create the record */\n        return new BlockIndex(level, blockIndex, new GridIndex(blockX, blockY, blockZ), tileIndex, tileCount, pointIndex, pointCount);\n    }\n}\n/** The size of the record in the file */\nBlockRecord.RECORD_SIZE = 24;\nexport { BlockRecord };\n//# sourceMappingURL=BlockRecord.js.map",
      "start": 1693508125604,
      "end": 1693508125637,
      "sourcemaps": null
    }
  ]
}
