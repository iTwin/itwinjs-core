{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tile/Tile.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tiles\n */\nimport { assert, dispose } from \"@itwin/core-bentley\";\nimport { Arc3d, ClipPlaneContainment, Point2d, Point4d, Vector3d } from \"@itwin/core-geometry\";\nimport { BoundingSphere, ColorDef, Frustum, FrustumPlanes } from \"@itwin/core-common\";\nimport { IModelApp } from \"../IModelApp\";\nimport { TileRequest, TileTreeLoadStatus, TileUsageMarker, } from \"./internal\";\n// cSpell:ignore undisplayable bitfield\nconst scratchRange2d = [new Point2d(), new Point2d(), new Point2d(), new Point2d()];\n/** @internal */\nexport function addRangeGraphic(builder, range, is2d) {\n    if (!is2d) {\n        builder.addRangeBox(range);\n        return;\n    }\n    // 3d box is useless in 2d and will be clipped by near/far planes anyway\n    const pts = scratchRange2d;\n    pts[0].set(range.low.x, range.low.y);\n    pts[1].set(range.high.x, range.low.y);\n    pts[2].set(range.high.x, range.high.y);\n    pts[3].set(range.low.x, range.high.y);\n    builder.addLineString2d(pts, 0);\n}\nconst scratchWorldFrustum = new Frustum();\nconst scratchRootFrustum = new Frustum();\nconst scratchWorldSphere = new BoundingSphere();\nconst scratchPoint4d = Point4d.createZero();\nconst scratchFrustum = new Frustum();\n/** A 3d tile within a [[TileTree]].\n *\n * A tile represents the contents of some sub-volume of the tile tree's volume. It may produce graphics representing those contents, or may have no graphics.\n * A tile can have child tiles that further sub-divide its own volume, providing higher-resolution representations of its contents. A tile that has no children is\n * referred to as a \"leaf\" of the tile tree. A non-leaf tile's children are produced when they are needed, and discarded when no longer needed.\n * A tile's contents can be discarded at any time by [[TileAdmin]] when GPU memory needs to be reclaimed; or when the Tile itself is discarded via\n * [[Tile.dispose]].\n *\n * Several public [[Tile]] methods carry a warning that they should **not** be overridden by subclasses; typically a protected method exists that can be overridden instead.\n * For example, [[loadChildren]] should not be overridden, but it calls [[_loadChildren]], which must be overridden because it is abstract.\n * @public\n * @extensions\n */\nexport class Tile {\n    /** The point at the center of this tile's volume. */\n    get center() { return this.boundingSphere.center; }\n    /** The radius of a sphere fully encompassing this tile's volume - used for culling. */\n    get radius() { return this.boundingSphere.radius; }\n    /** Constructor */\n    constructor(params, tree) {\n        this._state = 0 /* TileState.NotReady */;\n        this._rangeGraphicType = TileBoundingBoxes.None;\n        /** True if this tile ever had graphics loaded. Used to determine when a tile's graphics were later freed to conserve memory. */\n        this._hadGraphics = false;\n        /** Tracks the usage of this tile. After a period of disuse, the tile may be [[prune]]d to free up memory. */\n        this.usageMarker = new TileUsageMarker();\n        /** Exclusively for use by LRUTileList. @internal */\n        this.bytesUsed = 0;\n        this.tree = tree;\n        this.parent = params.parent;\n        this.depth = undefined !== this.parent ? this.parent.depth + 1 : 0;\n        this.range = params.range;\n        this._maximumSize = params.maximumSize;\n        this._contentRange = params.contentRange;\n        this._contentId = params.contentId;\n        const center = this.range.low.interpolate(0.5, this.range.high);\n        const radius = 0.5 * this.range.low.distance(this.range.high);\n        this.boundingSphere = new BoundingSphere(center, radius);\n        if (params.maximumSize <= 0)\n            this.setIsReady();\n        this._isLeaf = true === params.isLeaf;\n        this._childrenLoadStatus = (undefined === tree.maxDepth || this.depth < tree.maxDepth) ? TileTreeLoadStatus.NotLoaded : TileTreeLoadStatus.Loaded;\n    }\n    /** Free memory-consuming resources owned by this tile to reduce memory pressure.\n     * By default, this calls [[disposeContents]]. Problematic subclasses (MapTile, ImageryMapTile) may opt out for now by overriding this method to do nothing.\n     * That option may be removed in the future.\n     * @alpha\n     */\n    freeMemory() {\n        this.disposeContents();\n    }\n    /** Dispose of resources held by this tile. */\n    disposeContents() {\n        this._state = 0 /* TileState.NotReady */;\n        this._graphic = dispose(this._graphic);\n        this._rangeGraphic = dispose(this._rangeGraphic);\n        this._rangeGraphicType = TileBoundingBoxes.None;\n        IModelApp.tileAdmin.onTileContentDisposed(this);\n    }\n    /** Dispose of resources held by this tile and all of its children, marking it and all of its children as \"abandoned\". */\n    dispose() {\n        this.disposeContents();\n        this._state = 5 /* TileState.Abandoned */;\n        this.disposeChildren();\n    }\n    /** This tile's child tiles, if they exist and are loaded. The children are fully contained within this tile's volume and provide higher-resolution graphics than this tile.\n     * @see [[loadChildren]]\n     */\n    get children() { return this._children; }\n    /** The [[IModelConnection]] to which this tile belongs. */\n    get iModel() { return this.tree.iModel; }\n    /** Uniquely identifies this tile's content. */\n    get contentId() { return this._contentId; }\n    /** True if this tile's content is currently being loaded. */\n    get isLoading() { return TileLoadStatus.Loading === this.loadStatus; }\n    /** True if a request for this tile's content has been enqueued. */\n    get isQueued() { return TileLoadStatus.Queued === this.loadStatus; }\n    /** True if an attempt to load this tile's content failed. */\n    get isNotFound() { return TileLoadStatus.NotFound === this.loadStatus; }\n    /** True if this tile's content has been loaded and is ready to be drawn. */\n    get isReady() { return TileLoadStatus.Ready === this.loadStatus; }\n    /** Indicates the tile should not be selected for display because it is out of the range of LODs supported by the tile provider.\n     * @see [[ImageryMapTile.isOutOfLodRange]].\n     * @alpha\n     */\n    get isOutOfLodRange() { return false; }\n    /** @public */\n    setNotFound() {\n        this._state = 4 /* TileState.NotFound */;\n    }\n    /** @public */\n    setIsReady() {\n        if (this.hasGraphics)\n            this._hadGraphics = true;\n        this._state = 3 /* TileState.Ready */;\n        IModelApp.tileAdmin.onTileContentLoaded(this);\n    }\n    /** @public */\n    setLeaf() {\n        // Don't potentially re-request the children later.\n        this.disposeChildren();\n        this._isLeaf = true;\n        this._childrenLoadStatus = TileTreeLoadStatus.Loaded;\n    }\n    /** True if this tile has no child tiles. */\n    get isLeaf() { return this._isLeaf; }\n    /** @internal */\n    get isEmpty() { return this.isReady && !this.hasGraphics && this.isLeaf; }\n    /** @internal */\n    get isDisplayable() { return 0 < this.maximumSize; }\n    /** The maximum size in pixels this tile can be drawn. If the size of the tile on screen exceeds this maximum, a higher-resolution tile should be drawn in its place. */\n    get maximumSize() { return this._maximumSize; }\n    /** @internal */\n    get isParentDisplayable() { return undefined !== this.parent && this.parent.isDisplayable; }\n    /** @internal */\n    get isUndisplayableRootTile() { return undefined === this.parent && !this.isDisplayable; }\n    /** @internal */\n    get request() { return this._request; }\n    set request(request) {\n        assert(undefined === request || undefined === this.request);\n        this._request = request;\n    }\n    /** Compute the load priority of this tile. This determines which tiles' contents are requested first.\n     * @param _viewports The subset of `users` that are [[Viewport]]s - typically, these viewports want to display the tile's content.\n     * @param users The [[TileUser]]s that are currently using the tile for some purpose, such as displaying its content.\n     * @returns The priority.\n     * @see [[TileLoadPriority]] for suggested priority values.\n     */\n    computeLoadPriority(_viewports, _users) {\n        return this.depth;\n    }\n    /** True if this tile has graphics ready to draw. */\n    get hasGraphics() { return undefined !== this._graphic; }\n    /** True if this tile has a known volume tightly encompassing its graphics. */\n    get hasContentRange() { return undefined !== this._contentRange; }\n    /** A volume no larger than this tile's `range`, and optionally more tightly encompassing its contents, used for more accurate culling. */\n    get contentRange() {\n        if (undefined !== this._contentRange)\n            return this._contentRange;\n        else if (undefined === this.parent && undefined !== this.tree.contentRange)\n            return this.tree.contentRange;\n        else\n            return this.range;\n    }\n    /** Tile contents are loaded asynchronously on demand. This member tracks the current loading status of this tile's contents. */\n    get loadStatus() {\n        switch (this._state) {\n            case 0 /* TileState.NotReady */: {\n                if (undefined === this.request)\n                    return TileLoadStatus.NotLoaded;\n                else if (TileRequest.State.Loading === this.request.state)\n                    return TileLoadStatus.Loading;\n                assert(TileRequest.State.Completed !== this.request.state && TileRequest.State.Failed !== this.request.state); // this.request should be undefined in these cases...\n                return TileLoadStatus.Queued;\n            }\n            case 3 /* TileState.Ready */: {\n                assert(undefined === this.request);\n                return TileLoadStatus.Ready;\n            }\n            case 4 /* TileState.NotFound */: {\n                assert(undefined === this.request);\n                return TileLoadStatus.NotFound;\n            }\n            default: {\n                assert(5 /* TileState.Abandoned */ === this._state);\n                return TileLoadStatus.Abandoned;\n            }\n        }\n    }\n    /** Produce the graphics that should be drawn. */\n    produceGraphics() {\n        return this._graphic;\n    }\n    setGraphic(graphic) {\n        dispose(this._graphic);\n        this._graphic = graphic;\n        this.setIsReady();\n    }\n    /** Set this tile's content to the result of [[readContent]] */\n    setContent(content) {\n        const { graphic, isLeaf, contentRange } = content;\n        this.setGraphic(graphic);\n        if (undefined !== isLeaf && isLeaf !== this._isLeaf) {\n            if (isLeaf)\n                this.setLeaf();\n            else\n                this._isLeaf = false;\n        }\n        if (undefined !== contentRange)\n            this._contentRange = contentRange;\n        this.setIsReady();\n    }\n    /** Disclose any resources owned by this tile, other than its [[RenderGraphic]].\n     * @internal\n     */\n    _collectStatistics(_stats) { }\n    /** Disclose resources owned by this tile and (by default) all of its child tiles.\n     * @note Do not override this method! Override `_collectStatistics` instead.\n     * @internal\n     */\n    collectStatistics(stats, includeChildren = true) {\n        if (undefined !== this._graphic)\n            this._graphic.collectStatistics(stats);\n        this._collectStatistics(stats);\n        if (!includeChildren)\n            return;\n        const children = this.children;\n        if (undefined !== children)\n            for (const child of children)\n                child.collectStatistics(stats);\n    }\n    /** If this tile's child tiles have not yet been requested, enqueue an asynchronous request to load them.\n     * @note This function itself is *not* asynchronous - it immediately returns the current loading status.\n     * @note Do not override this method - implement [[_loadChildren]].\n     */\n    loadChildren() {\n        if (this._childrenLoadStatus !== TileTreeLoadStatus.NotLoaded)\n            return this._childrenLoadStatus;\n        this._childrenLoadStatus = TileTreeLoadStatus.Loading;\n        this._loadChildren((children) => {\n            this._children = children;\n            this._childrenLoadStatus = TileTreeLoadStatus.Loaded;\n            if (undefined === children || 0 === children.length)\n                this._isLeaf = true;\n            IModelApp.tileAdmin.onTileChildrenLoad.raiseEvent(this);\n        }, (_error) => {\n            this._isLeaf = true;\n            this._childrenLoadStatus = TileTreeLoadStatus.NotFound;\n            IModelApp.tileAdmin.onTileChildrenLoad.raiseEvent(this);\n        });\n        return this._childrenLoadStatus;\n    }\n    /** Dispose of this tile's child tiles and mark them as \"not loaded\". */\n    disposeChildren() {\n        const children = this.children;\n        if (undefined === children)\n            return;\n        for (const child of children)\n            child.dispose();\n        this._childrenLoadStatus = TileTreeLoadStatus.NotLoaded;\n        this._children = undefined;\n    }\n    /** Returns true if this tile's bounding volume is culled by the frustum or clip volumes specified by `args`. */\n    isRegionCulled(args) {\n        return this.isCulled(this.range, args, true, this.boundingSphere);\n    }\n    /** Returns true if this tile's content bounding volume is culled by the frustum or clip volumes specified by `args`. */\n    isContentCulled(args) {\n        return this.isCulled(this.contentRange, args, false);\n    }\n    isCulled(range, args, testClipIntersection, sphere) {\n        const box = Frustum.fromRange(range, scratchRootFrustum);\n        return this.isFrustumCulled(box, args, testClipIntersection, sphere);\n    }\n    isFrustumCulled(box, args, testClipIntersection, sphere) {\n        const worldBox = box.transformBy(args.location, scratchWorldFrustum);\n        const worldSphere = sphere?.transformBy(args.location, scratchWorldSphere);\n        // Test against frustum.\n        if (FrustumPlanes.Containment.Outside === args.frustumPlanes.computeFrustumContainment(worldBox, worldSphere))\n            return true;\n        // Test against TileTree's own clip volume, if any.\n        if (undefined !== args.clip && ClipPlaneContainment.StronglyOutside === args.clip.classifyPointContainment(worldBox.points))\n            return true;\n        // Test against view clip, if any (will be undefined if TileTree does not want view clip applied to it).\n        if (undefined !== args.viewClip && ClipPlaneContainment.StronglyOutside === args.viewClip.classifyPointContainment(worldBox.points))\n            return true;\n        // Test against intersection clip - reject if tile doesn't intersect (used for section-cut graphics).\n        if (testClipIntersection && undefined !== args.intersectionClip && ClipPlaneContainment.Ambiguous !== args.intersectionClip.classifyPointContainment(worldBox.points))\n            return true;\n        return false;\n    }\n    /** Determine the visibility of this tile according to the specified args. */\n    computeVisibility(args) {\n        if (this.isEmpty)\n            return TileVisibility.OutsideFrustum;\n        if (args.boundingRange && !args.boundingRange.intersectsRange(this.range))\n            return TileVisibility.OutsideFrustum;\n        // NB: We test for region culling before isDisplayable - otherwise we will never unload children of undisplayed tiles when\n        // they are outside frustum\n        if (this.isRegionCulled(args))\n            return TileVisibility.OutsideFrustum;\n        // some nodes are merely for structure and don't have any geometry\n        if (!this.isDisplayable)\n            return TileVisibility.TooCoarse;\n        if (this.isLeaf) {\n            if (this.hasContentRange && this.isContentCulled(args))\n                return TileVisibility.OutsideFrustum;\n            else\n                return TileVisibility.Visible;\n        }\n        return this.meetsScreenSpaceError(args) ? TileVisibility.Visible : TileVisibility.TooCoarse;\n    }\n    /** Returns true if this tile is of at least high enough resolution to be displayed, per the supplied [[TileDrawArgs]]; or false if\n     * a higher-resolution tile should be substituted for it.\n     * This method is called by [[computeVisibility]] if the tile has passed all culling checks.\n     */\n    meetsScreenSpaceError(args) {\n        const pixelSize = args.getPixelSize(this) * args.pixelSizeScaleFactor;\n        const maxSize = this.maximumSize * args.tileSizeModifier;\n        return pixelSize <= maxSize;\n    }\n    /** @internal */\n    extendRangeForContent(range, matrix, treeTransform, frustumPlanes) {\n        if (this.isEmpty || this.contentRange.isNull)\n            return;\n        const box = Frustum.fromRange(this.contentRange, scratchFrustum);\n        box.transformBy(treeTransform, box);\n        if (frustumPlanes !== undefined && FrustumPlanes.Containment.Outside === frustumPlanes.computeFrustumContainment(box))\n            return;\n        if (this.children === undefined) {\n            for (const boxPoint of box.points) {\n                const pt = matrix.multiplyPoint3d(boxPoint, 1, scratchPoint4d);\n                if (pt.w > .0001)\n                    range.extendXYZW(pt.x, pt.y, pt.z, pt.w);\n                else\n                    range.high.z = Math.max(1.0, range.high.z); // behind eye plane...\n            }\n        }\n        else {\n            for (const child of this.children)\n                child.extendRangeForContent(range, matrix, treeTransform, frustumPlanes);\n        }\n    }\n    /** Primarily for debugging purposes, compute the number of tiles below this one in the [[TileTree]]. */\n    countDescendants() {\n        const children = this.children;\n        if (undefined === children || 0 === children.length)\n            return 0;\n        let count = 0;\n        for (const child of children)\n            count += child.countDescendants();\n        return count;\n    }\n    /** Output this tile's graphics. */\n    drawGraphics(args) {\n        const gfx = this.produceGraphics();\n        if (undefined === gfx)\n            return;\n        args.graphics.add(gfx);\n        const rangeGfx = this.getRangeGraphic(args.context);\n        if (undefined !== rangeGfx)\n            args.graphics.add(rangeGfx);\n    }\n    /** @internal */\n    get rangeGraphicColor() {\n        return this.isLeaf ? ColorDef.blue : ColorDef.green;\n    }\n    /** @internal */\n    getRangeGraphic(context) {\n        const type = context.viewport.debugBoundingBoxes;\n        if (type === this._rangeGraphicType)\n            return this._rangeGraphic;\n        this._rangeGraphic = dispose(this._rangeGraphic);\n        this._rangeGraphicType = type;\n        if (TileBoundingBoxes.None !== type) {\n            const builder = context.createSceneGraphicBuilder();\n            this.addRangeGraphic(builder, type);\n            this._rangeGraphic = builder.finish();\n        }\n        return this._rangeGraphic;\n    }\n    /** @internal */\n    addRangeGraphic(builder, type) {\n        if (TileBoundingBoxes.Both === type) {\n            builder.setSymbology(ColorDef.blue, ColorDef.blue, 1);\n            addRangeGraphic(builder, this.range, this.tree.is2d);\n            if (this.hasContentRange) {\n                builder.setSymbology(ColorDef.red, ColorDef.red, 1);\n                addRangeGraphic(builder, this.contentRange, this.tree.is2d);\n            }\n        }\n        else if (TileBoundingBoxes.Sphere === type) {\n            builder.setSymbology(ColorDef.green, ColorDef.green, 1);\n            const x = new Vector3d(this.radius, 0, 0);\n            const y = new Vector3d(0, this.radius, 0);\n            const z = new Vector3d(0, 0, this.radius);\n            builder.addArc(Arc3d.create(this.center, x, y), false, false);\n            builder.addArc(Arc3d.create(this.center, x, z), false, false);\n            builder.addArc(Arc3d.create(this.center, y, z), false, false);\n        }\n        else if (TileBoundingBoxes.SolidBox === type) {\n            const range = this.range;\n            let color = this.rangeGraphicColor;\n            builder.setSymbology(color, color, 1);\n            addRangeGraphic(builder, range, this.tree.is2d);\n            color = color.withTransparency(0xcf);\n            builder.setSymbology(color, color, 1);\n            builder.addRangeBox(range, true);\n        }\n        else {\n            const color = this.rangeGraphicColor;\n            builder.setSymbology(color, color, 1);\n            const range = TileBoundingBoxes.Content === type ? this.contentRange : this.range;\n            addRangeGraphic(builder, range, this.tree.is2d);\n        }\n    }\n    /** Optional corners used to compute the screen size of the tile. These are used, e.g., by reality tiles with oriented bounding boxes to\n     * produce more accurate size calculation.\n     */\n    getSizeProjectionCorners() { return undefined; }\n}\n/** Describes the current status of a [[Tile]]'s content. Tile content is loaded via an asynchronous [[TileRequest]].\n * @see [[Tile.loadStatus]].\n * @public\n * @extensions\n */\nexport var TileLoadStatus;\n(function (TileLoadStatus) {\n    /** No attempt to load the tile's content has been made, or the tile has since been unloaded. It currently has no graphics. */\n    TileLoadStatus[TileLoadStatus[\"NotLoaded\"] = 0] = \"NotLoaded\";\n    /** A request has been dispatched to load the tile's contents, and a response is pending. */\n    TileLoadStatus[TileLoadStatus[\"Queued\"] = 1] = \"Queued\";\n    /** A response has been received and the tile's graphics and other data are being loaded on the frontend. */\n    TileLoadStatus[TileLoadStatus[\"Loading\"] = 2] = \"Loading\";\n    /** The tile has been loaded, and if the tile is displayable it has graphics. */\n    TileLoadStatus[TileLoadStatus[\"Ready\"] = 3] = \"Ready\";\n    /** A request to load the tile's contents failed. */\n    TileLoadStatus[TileLoadStatus[\"NotFound\"] = 4] = \"NotFound\";\n    /** The tile has been disposed. */\n    TileLoadStatus[TileLoadStatus[\"Abandoned\"] = 5] = \"Abandoned\";\n})(TileLoadStatus || (TileLoadStatus = {}));\n/**\n * Describes the visibility of a tile based on its size and a view frustum.\n * @public\n * @extensions\n */\nexport var TileVisibility;\n(function (TileVisibility) {\n    /** The tile is entirely outside of the viewing frustum. */\n    TileVisibility[TileVisibility[\"OutsideFrustum\"] = 0] = \"OutsideFrustum\";\n    /** The tile's graphics are of too low a resolution for the viewing frustum. */\n    TileVisibility[TileVisibility[\"TooCoarse\"] = 1] = \"TooCoarse\";\n    /** The tile's graphics are of appropriate resolution for the viewing frustum. */\n    TileVisibility[TileVisibility[\"Visible\"] = 2] = \"Visible\";\n})(TileVisibility || (TileVisibility = {}));\n/**\n * Loosely describes the \"importance\" of a [[Tile]]. Requests for tiles of greater \"importance\" are prioritized for loading.\n * @note A lower priority value indicates higher importance.\n * @public\n * @extensions\n */\nexport var TileLoadPriority;\n(function (TileLoadPriority) {\n    /** Contents of geometric models that are being interactively edited. */\n    TileLoadPriority[TileLoadPriority[\"Dynamic\"] = 5] = \"Dynamic\";\n    /** Background map tiles. */\n    TileLoadPriority[TileLoadPriority[\"Map\"] = 15] = \"Map\";\n    /** Typically, tiles generated from the contents of geometric models. */\n    TileLoadPriority[TileLoadPriority[\"Primary\"] = 20] = \"Primary\";\n    /** 3d terrain tiles onto which background map imagery is draped. */\n    TileLoadPriority[TileLoadPriority[\"Terrain\"] = 10] = \"Terrain\";\n    /** Typically, reality models. */\n    TileLoadPriority[TileLoadPriority[\"Context\"] = 40] = \"Context\";\n    /** Supplementary tiles used to classify the contents of geometric or reality models. */\n    TileLoadPriority[TileLoadPriority[\"Classifier\"] = 50] = \"Classifier\";\n})(TileLoadPriority || (TileLoadPriority = {}));\n/**\n * Options for displaying tile bounding boxes for debugging purposes.\n *\n * Bounding boxes are color-coded based on refinement strategy:\n *  - Blue: A leaf tile (has no child tiles).\n *  - Green: An ordinary tile (sub-divides into 4 or 8 child tiles).\n *  - Red: A tile which refines to a single higher-resolution child occupying the same volume.\n * @see [[Viewport.debugBoundingBoxes]]\n * @public\n * @extensions\n */\nexport var TileBoundingBoxes;\n(function (TileBoundingBoxes) {\n    /** Display no bounding boxes */\n    TileBoundingBoxes[TileBoundingBoxes[\"None\"] = 0] = \"None\";\n    /** Display boxes representing the tile's full volume. */\n    TileBoundingBoxes[TileBoundingBoxes[\"Volume\"] = 1] = \"Volume\";\n    /** Display boxes representing the range of the tile's contents, which may be tighter than (but never larger than) the tile's full volume. */\n    TileBoundingBoxes[TileBoundingBoxes[\"Content\"] = 2] = \"Content\";\n    /** Display both volume and content boxes. */\n    TileBoundingBoxes[TileBoundingBoxes[\"Both\"] = 3] = \"Both\";\n    /** Display boxes for direct children, where blue boxes indicate empty volumes. */\n    TileBoundingBoxes[TileBoundingBoxes[\"ChildVolumes\"] = 4] = \"ChildVolumes\";\n    /** Display bounding sphere. */\n    TileBoundingBoxes[TileBoundingBoxes[\"Sphere\"] = 5] = \"Sphere\";\n    /** Display a transparent solid box representing the tile's full volume.\n     * @alpha To be replaced with a separate option that applies to any of the other TileBoundingBoxes modes.\n     */\n    TileBoundingBoxes[TileBoundingBoxes[\"SolidBox\"] = 6] = \"SolidBox\";\n})(TileBoundingBoxes || (TileBoundingBoxes = {}));\n//# sourceMappingURL=Tile.js.map",
      "start": 1693508121344,
      "end": 1693508121575,
      "sourcemaps": null
    }
  ]
}
