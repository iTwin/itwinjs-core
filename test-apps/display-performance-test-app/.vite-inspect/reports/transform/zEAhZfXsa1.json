{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/curve/spiral/DirectSpiral3d.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Curve\n */\nimport { Geometry } from \"../../Geometry\";\nimport { Segment1d } from \"../../geometry3d/Segment1d\";\nimport { CurveLengthContext } from \"../internalContexts/CurveLengthContext\";\nimport { LineString3d } from \"../LineString3d\";\nimport { StrokeOptions } from \"../StrokeOptions\";\nimport { AustralianRailCorpXYEvaluator } from \"./AustralianRailCorpXYEvaluator\";\nimport { ClothoidSeriesRLEvaluator } from \"./ClothoidSeries\";\nimport { CzechSpiralEvaluator, ItalianSpiralEvaluator } from \"./CzechSpiralEvaluator\";\nimport { DirectHalfCosineSpiralEvaluator } from \"./DirectHalfCosineSpiralEvaluator\";\nimport { MXCubicAlongArcEvaluator } from \"./MXCubicAlongArcSpiralEvaluator\";\nimport { PolishCubicEvaluator } from \"./PolishCubicSpiralEvaluator\";\nimport { TransitionSpiral3d } from \"./TransitionSpiral3d\";\n/**\n* DirectSpiral3d acts like a TransitionSpiral3d for serialization purposes, but implements spiral types that have \"direct\" xy calculations without the integrations required\n* for IntegratedSpiral3d.\n* * Each DirectSpiral3d carries an XYCurveEvaluator to give it specialized behavior.\n* * Direct spirals that flow through serialization to native imodel02 are create with these static methods:\n*   * createArema\n*   * createJapaneseCubic\n*   * createAustralianRail\n*   * createDirectHalfCosine\n*   * createChineseCubic\n*   * createCzechCubic\n*   * createPolishCubic\n*   * createItalian\n*   * createWesternAustralian\n* @public\n*/\nexport class DirectSpiral3d extends TransitionSpiral3d {\n    /** Return the internal stroked form of the (possibly partial) spiral   */\n    get activeStrokes() { return this._activeStrokes !== undefined ? this._activeStrokes : this._globalStrokes; }\n    /** Return the nominal end radius. */\n    get nominalR1() { return this._nominalR1; }\n    /** Return the nominal distance from inflection to endpoint. */\n    get nominalL1() { return this._nominalL1; }\n    /** Return the nominal end curvature */\n    get nominalCurvature1() { return TransitionSpiral3d.radiusToCurvature(this._nominalR1); }\n    /** Return the low level evaluator\n     * @internal\n     */\n    get evaluator() { return this._evaluator; }\n    // constructor demands radius1 and distance1 for nominal construction.\n    // caller is responsible for managing intervals of partial spiral\n    constructor(localToWorld, spiralType, originalProperties, nominalL1, nominalR1, activeFractionInterval, evaluator) {\n        super(spiralType, localToWorld, activeFractionInterval, originalProperties);\n        /** String name for schema properties */\n        this.curvePrimitiveType = \"transitionSpiral\";\n        this._nominalL1 = nominalL1;\n        this._nominalR1 = nominalR1;\n        this._evaluator = evaluator;\n        this._globalStrokes = LineString3d.create();\n        this._activeStrokes = LineString3d.create();\n        // initialize for compiler -- but this will be recomputed in refreshComputeProperties ...\n        this.refreshComputedProperties();\n    }\n    /**\n     * Compute stroke data in an interval.\n     * @param strokes strokes to clear and refill.\n     * @param fraction0 start fraction\n     * @param fraction1 end fraction\n     */\n    computeStrokes(strokes, fractionA, fractionB, numInterval, applyLocalToWorld = true) {\n        if (numInterval < 1)\n            numInterval = 1;\n        strokes.clear();\n        strokes.ensureEmptyUVParams();\n        strokes.ensureEmptyFractions();\n        const distances = strokes.packedUVParams;\n        const nominalIntervalLength = Math.abs(fractionB - fractionA) * this._nominalL1;\n        for (let i = 0; i <= numInterval; i++) {\n            const fraction = Geometry.interpolate(fractionA, i / numInterval, fractionB);\n            const nominalDistanceAlong = fraction * nominalIntervalLength;\n            strokes.packedPoints.pushXYZ(this._evaluator.fractionToX(fraction), this._evaluator.fractionToY(fraction), 0);\n            distances.pushXY(fraction, nominalDistanceAlong); // the second distance will be updated below\n        }\n        if (applyLocalToWorld)\n            strokes.tryTransformInPlace(this._localToWorld);\n        let fraction0 = distances.getXAtUncheckedPointIndex(0);\n        let trueDistance0 = distances.getYAtUncheckedPointIndex(0); // whatever was assigned as start distance is fine\n        let trueDistance1, fraction1;\n        for (let i = 1; i <= numInterval; i++) {\n            fraction1 = distances.getXAtUncheckedPointIndex(i);\n            trueDistance1 = trueDistance0 + this._evaluator.integrateDistanceBetweenFractions(fraction0, fraction1);\n            distances.setXYAtCheckedPointIndex(i, fraction1, trueDistance1);\n            fraction0 = fraction1;\n            trueDistance0 = trueDistance1;\n        }\n    }\n    /** Recompute strokes */\n    refreshComputedProperties() {\n        const sweepRadians = this.nominalL1 / (2.0 * this.nominalR1);\n        const radiansStep = 0.02;\n        const numInterval = StrokeOptions.applyAngleTol(undefined, 4, sweepRadians, radiansStep);\n        this.computeStrokes(this._globalStrokes, 0, 1, numInterval);\n        const numActiveInterval = Math.ceil(this._activeFractionInterval.absoluteDelta() * numInterval);\n        this._activeStrokes = LineString3d.create();\n        this.computeStrokes(this._activeStrokes, this._activeFractionInterval.x0, this._activeFractionInterval.x1, numActiveInterval);\n    }\n    /**\n     * Create a spiral object which uses numXTerm terms from the clothoid X series and numYTerm from the clothoid Y series.\n     * @param numXTerm  number of terms to use from X series\n     * @param numYTerm number of terms to use from Y series\n     * @param localToWorld placement frame.  Inflection point is at origin, initial direction is along x axis.\n     * @param nominalL1 design distance from inflection to end point.\n     * @param nominalR1 design radius at end point.\n     * @param activeInterval active interval (as fractions of nominalL1 !!!)\n     */\n    static createTruncatedClothoid(spiralType, localToWorld, numXTerm, numYTerm, originalProperties, nominalL1, nominalR1, activeInterval) {\n        if (numXTerm < 1)\n            numXTerm = 1;\n        if (numYTerm < 1)\n            numYTerm = 1;\n        const evaluator = new ClothoidSeriesRLEvaluator(nominalL1, 1.0 / (2.0 * nominalL1 * nominalR1), numXTerm, numYTerm);\n        return new DirectSpiral3d(localToWorld.clone(), spiralType, originalProperties, nominalL1, nominalR1, activeInterval ? activeInterval.clone() : Segment1d.create(0, 1), evaluator);\n    }\n    /**\n     * Create an Japanese spiral clothoid approximation\n     *   * X is 1 terms of the clothoid series as a function of nominal distance along.\n     *   * Y is 1 terms f the clothoid series as a function of nominal distance along.\n     *   * Remark: This is identical to the ChineseCubic\n     * @param localToWorld axes with inflection at origin, tangent along x axis\n     * @param nominalL1 nominal length as used in series LR terms.\n     * @param nominalR1 nominal final radius as used in series LR terms\n     * @param activeInterval fractional interval with (0, nominalL1) range for nominal distance along\n     */\n    static createJapaneseCubic(localToWorld, nominalL1, nominalR1, activeInterval) {\n        return this.createTruncatedClothoid(\"JapaneseCubic\", localToWorld, 1, 1, undefined, nominalL1, nominalR1, activeInterval);\n    }\n    /**\n     * Create a czech cubic.\n     * This is y= m*x^3 with\n     * * x any point on the x axis\n     * * `fraction` along the spiral goes to `x = fraction * L`\n     * * m is gamma / (6RL)\n     *    * 1/(6RL) is the leading term of the sine series.\n     *    * `gamma = 2R/sqrt (4RR-LL)` pushes y up a little bit to simulate the lost series terms.\n     * @param localToWorld\n     * @param nominalLx nominal length along x axis\n     * @param nominalR1\n     * @param activeInterval\n     */\n    static createCzechCubic(localToWorld, nominalLx, nominalR1, activeInterval) {\n        const evaluator = CzechSpiralEvaluator.create(nominalLx, nominalR1);\n        if (evaluator === undefined)\n            return undefined;\n        return new DirectSpiral3d(localToWorld.clone(), \"Czech\", undefined, nominalLx, nominalR1, activeInterval ? activeInterval.clone() : Segment1d.create(0, 1), evaluator);\n    }\n    /**\n     * Create an italian spiral\n     * This is y= m*x^3 with\n     * * x any point on the x axis\n     * * `fraction` along the spiral goes to `x = fraction * L`\n     * * m is gamma / (6RL)\n     *    * 1/(6RL) is the leading term of the sine series.\n     *    * `gamma = 2R/sqrt (4RR-LL)` pushes y up a little bit to simulate the lost series terms.\n     * * L in gamma and m is the\n     * @param localToWorld\n     * @param nominalL1 nominal length along the spiral\n     * @param nominalR1\n     * @param activeInterval\n     */\n    static createItalian(localToWorld, nominalL1, nominalR1, activeInterval) {\n        const evaluator = ItalianSpiralEvaluator.create(nominalL1, nominalR1);\n        if (evaluator === undefined)\n            return undefined;\n        return new DirectSpiral3d(localToWorld.clone(), \"Italian\", undefined, nominalL1, nominalR1, activeInterval ? activeInterval.clone() : Segment1d.create(0, 1), evaluator);\n    }\n    /**\n     * Create an MX Cubic whose nominal length is close to along the curve.\n     * This is y= m*x^3 with\n     * * m is 1/ (6RL1)\n     *    * 1/(6RL) is the leading term of the sine series.\n     * * L1 is an along-the-x-axis distance that is slightly LESS THAN the nominal length\n     * * x is axis position that is slightly LESS than nominal distance along\n     * * L1, x use the approximation   `x = s * ( 1 - s^4/ (40 R R L L))\n     * @param localToWorld\n     * @param nominalL1\n     * @param nominalR1\n     * @param activeInterval\n     */\n    static createMXCubicAlongArc(localToWorld, nominalL1, nominalR1, activeInterval) {\n        const evaluator = MXCubicAlongArcEvaluator.create(nominalL1, nominalR1);\n        if (evaluator === undefined)\n            return undefined;\n        return new DirectSpiral3d(localToWorld.clone(), \"MXCubicAlongArc\", undefined, nominalL1, nominalR1, activeInterval ? activeInterval.clone() : Segment1d.create(0, 1), evaluator);\n    }\n    /**\n     * Create a polish cubic\n     * This is y= m*x^3 with\n     * * m is 1/ (6RL)\n     *    * 1/(6RL) is the leading term of the sine series.\n     * * L is nominal length\n     * * R is nominal end radius.\n     * * x ranges up to the x axis distance for which the polish distance series produces f(x)=L\n     * * The support class PolishCubicEvaluator has static methods for the distance series and its inversion.\n     */\n    static createPolishCubic(localToWorld, nominalL1, nominalR1, activeInterval) {\n        const evaluator = PolishCubicEvaluator.create(nominalL1, nominalR1);\n        if (evaluator === undefined)\n            return undefined;\n        return new DirectSpiral3d(localToWorld.clone(), \"PolishCubic\", undefined, nominalL1, nominalR1, activeInterval ? activeInterval.clone() : Segment1d.create(0, 1), evaluator);\n    }\n    /**\n     * Create an AustralianRailCorp spiral\n     * This is y= m*x^3 with\n     * * x any point on the x axis\n     * * `fraction` along the spiral goes to `x = fraction * L`\n     * * m is gamma / (6RL)\n     *    * 1/(6RL) is the leading term of the sine series.\n     *    * `gamma = 2R/sqrt (4RR-LL)` pushes y up a little bit to simulate the lost series terms.\n     * @param localToWorld\n     * @param nominalL1\n     * @param nominalR1\n     * @param activeInterval\n     */\n    static createAustralianRail(localToWorld, nominalL1, nominalR1, activeInterval) {\n        const evaluator = AustralianRailCorpXYEvaluator.create(nominalL1, nominalR1);\n        if (evaluator === undefined)\n            return undefined;\n        return new DirectSpiral3d(localToWorld.clone(), \"AustralianRailCorp\", undefined, nominalL1, nominalR1, activeInterval ? activeInterval.clone() : Segment1d.create(0, 1), evaluator);\n    }\n    static createDirectHalfCosine(localToWorld, nominalL1, nominalR1, activeInterval) {\n        return new this(localToWorld, \"HalfCosine\", undefined, nominalL1, nominalR1, activeInterval, new DirectHalfCosineSpiralEvaluator(nominalL1, nominalR1));\n    }\n    /**\n     * Create an Arema spiral clothoid approximation\n     *   * X is 2 terms of the clothoid series as a function of nominal distance along\n     *   * Y is 2 terms f the clothoid series as a function of nominal distance along\n     *   * Remark: This is identical to the ChineseCubic\n     * @param localToWorld axes with inflection at origin, tangent along x axis\n     * @param nominalL1 nominal length as used in series LR terms.\n     * @param nominalR1 nominal final radius as used in series LR terms\n     * @param activeInterval fractional interval with (0, nominalL1) range for nominal distance along\n     */\n    static createArema(localToWorld, nominalL1, nominalR1, activeInterval) {\n        return this.createTruncatedClothoid(\"Arema\", localToWorld, 2, 2, undefined, nominalL1, nominalR1, activeInterval);\n    }\n    /**\n     * Create a Chinese clothoid approximation\n     *   * X is 2 terms of the clothoid series as a function of nominal distance along\n     *   * Y is 2 terms f the clothoid series as a function of nominal distance along\n     *   * Remark: This is identical to the Arema spiral\n     * @param localToWorld axes with inflection at origin, tangent along x axis\n     * @param nominalL1 nominal length as used in series LR terms.\n     * @param nominalR1 nominal final radius as used in series LR terms\n     * @param activeInterval fractional interval with (0, nominalL1) range for nominal distance along\n     */\n    static createChineseCubic(localToWorld, nominalL1, nominalR1, activeInterval) {\n        return this.createTruncatedClothoid(\"ChineseCubic\", localToWorld, 2, 2, undefined, nominalL1, nominalR1, activeInterval);\n    }\n    /**\n     * Create a Western Australian direct spiral.\n     *   * X is 2 terms of the clothoid series as a function of distance along\n     *   * Y is 1 term (cubic in nominal distance along)\n     * @param localToWorld axes with inflection at origin, tangent along x axis\n     * @param nominalL1 nominal length as used in series LR terms.\n     * @param nominalR1 nominal final radius as used in series LR terms\n     * @param activeInterval fractional interval with (0, nominalL1) range for nominal distance along\n     */\n    static createWesternAustralian(localToWorld, nominalL1, nominalR1, activeInterval) {\n        return this.createTruncatedClothoid(\"WesternAustralian\", localToWorld, 2, 1, undefined, nominalL1, nominalR1, activeInterval);\n    }\n    /**\n     * Create (if possible) a DirectSpiral3d, applying various strict conditions appropriate to the spiral type.\n     * The parameter list includes extraneous values in order to directly match IntegratedSpiral3d.create, which has greater flexibility about\n     *    mixtures of values.\n     * * IMPORTANT RESTRICTIONS\n     *   * Direct spirals must have the inflection at the origin of their coordinate system, aligned with the x axis.\n     *      * hence bearing0 = 0\n     *      * hence radius0 = 0\n     *   * bearing1 is ignored\n     *   * radius1 must be given.\n     *   * arcLength must be given,\n     * @param spiralType one of the types in `DirectSpiralTypeNames`\n     * @param radius0 radius (or 0 for tangent to line) at start.   Must be ZERO or UNDEFINED\n     * @param radius1 radius (or 0 for tangent to line) at end.\n     * @param bearing0 bearing, measured CCW from x axis at start.   Must be ZERO or UNDEFINED\n     * @param bearing1 bearing, measured CCW from x axis at end.    IGNORED.\n     * @param fractionInterval optional fractional interval for an \"active\" portion of the curve.   if omitted, the full [0,1] is used.\n     * @param localToWorld placement transform\n     */\n    static createFromLengthAndRadius(spiralType, radius0, radius1, bearing0, _bearing1, arcLength, activeInterval, localToWorld) {\n        if (bearing0 !== undefined && !bearing0.isAlmostZero)\n            return undefined;\n        if (radius0 !== undefined && !Geometry.isSmallMetricDistance(radius0))\n            return undefined;\n        if (radius1 === undefined || Geometry.isSmallMetricDistance(radius1))\n            return undefined;\n        if (arcLength === undefined)\n            return undefined;\n        if (Geometry.equalStringNoCase(spiralType, \"Arema\"))\n            return this.createArema(localToWorld, arcLength, radius1, activeInterval);\n        if (Geometry.equalStringNoCase(spiralType, \"ChineseCubic\"))\n            return this.createChineseCubic(localToWorld, arcLength, radius1, activeInterval);\n        if (Geometry.equalStringNoCase(spiralType, \"JapaneseCubic\"))\n            return this.createJapaneseCubic(localToWorld, arcLength, radius1, activeInterval);\n        if (Geometry.equalStringNoCase(spiralType, \"HalfCosine\"))\n            return this.createDirectHalfCosine(localToWorld, arcLength, radius1, activeInterval);\n        if (Geometry.equalStringNoCase(spiralType, \"Czech\"))\n            return this.createCzechCubic(localToWorld, arcLength, radius1, activeInterval);\n        if (Geometry.equalStringNoCase(spiralType, \"Italian\"))\n            return this.createItalian(localToWorld, arcLength, radius1, activeInterval);\n        if (Geometry.equalStringNoCase(spiralType, \"AustralianRailCorp\"))\n            return this.createAustralianRail(localToWorld, arcLength, radius1, activeInterval);\n        if (Geometry.equalStringNoCase(spiralType, \"MXCubicAlongArc\"))\n            return this.createMXCubicAlongArc(localToWorld, arcLength, radius1, activeInterval);\n        if (Geometry.equalStringNoCase(spiralType, \"WesternAustralian\"))\n            return this.createWesternAustralian(localToWorld, arcLength, radius1, activeInterval);\n        if (Geometry.equalStringNoCase(spiralType, \"PolishCubic\"))\n            return this.createPolishCubic(localToWorld, arcLength, radius1, activeInterval);\n        return undefined;\n    }\n    /** Deep clone of this spiral */\n    clone() {\n        return new DirectSpiral3d(this.localToWorld.clone(), this._spiralType, this.designProperties?.clone(), this._nominalL1, this._nominalR1, this._activeFractionInterval?.clone(), this._evaluator.clone());\n    }\n    /** apply `transform` to this spiral's local to world transform. */\n    tryTransformInPlace(transformA) {\n        const rigidData = this.applyRigidPartOfTransform(transformA);\n        if (rigidData !== undefined) {\n            this._nominalL1 *= rigidData.scale;\n            this._nominalR1 *= rigidData.scale;\n            this.evaluator.scaleInPlace(rigidData.scale);\n        }\n        this.refreshComputedProperties();\n        return true;\n    }\n    /** Return the spiral start point. */\n    startPoint() { return this.activeStrokes.startPoint(); }\n    /** return the spiral end point. */\n    endPoint() { return this.activeStrokes.endPoint(); }\n    /** test if the local to world transform places the spiral xy plane into `plane` */\n    isInPlane(plane) {\n        return plane.isPointInPlane(this.localToWorld.origin)\n            && Geometry.isSameCoordinate(0.0, this.localToWorld.matrix.dotColumnX(plane.getNormalRef()))\n            && Geometry.isSameCoordinate(0.0, this.localToWorld.matrix.dotColumnY(plane.getNormalRef()));\n    }\n    /** Return quick length of the spiral.\n     * The tangent vector of a true clothoid is length 1 everywhere, so simple proportion of nominalL1 is a good approximation.\n     */\n    quickLength() {\n        const distanceData = this._globalStrokes.packedUVParams;\n        const n = distanceData.length;\n        return distanceData.getYAtUncheckedPointIndex(n - 1);\n    }\n    /** Return length of the spiral.\n     * * True length is stored at back of uvParams . . .\n     */\n    //   use the generic integrator ... public override curveLength() { return this.quickLength(); }\n    /** Test if `other` is an instance of `TransitionSpiral3d` */\n    isSameGeometryClass(other) { return other instanceof DirectSpiral3d; }\n    /** Add strokes from this spiral to `dest`.\n     * * Linestrings will usually stroke as just their points.\n     * * If maxEdgeLength is given, this will sub-stroke within the linestring -- not what we want.\n     */\n    emitStrokes(dest, options) { this.activeStrokes.emitStrokes(dest, options); }\n    /** emit stroke fragments to `dest` handler. */\n    emitStrokableParts(dest, options) {\n        const n = this.computeStrokeCountForOptions(options);\n        const activeStrokes = this.activeStrokes;\n        dest.startParentCurvePrimitive(this);\n        // hack: specify the extended range so we can compute length of an extended spiral\n        let globalFraction0 = 0.0;\n        let globalFraction1 = 1.0;\n        if (dest instanceof CurveLengthContext) {\n            if (dest.getFraction0 < 0.0)\n                globalFraction0 = dest.getFraction0;\n            if (dest.getFraction1 > 1.0)\n                globalFraction1 = dest.getFraction1;\n        }\n        if (n <= activeStrokes.numPoints())\n            dest.announceIntervalForUniformStepStrokes(this, 2 * activeStrokes.numPoints(), globalFraction0, globalFraction1);\n        else\n            dest.announceIntervalForUniformStepStrokes(this, n, globalFraction0, globalFraction1);\n        dest.endParentCurvePrimitive(this);\n    }\n    /**\n     * return the stroke count required for given options.\n     * @param options StrokeOptions that determine count\n     */\n    computeStrokeCountForOptions(options) {\n        let numStroke;\n        const nominalRadians = this._nominalL1 / (2.0 * this._nominalR1);\n        if (options) {\n            const rMin = Math.abs(this._nominalR1);\n            numStroke = options.applyTolerancesToArc(rMin, nominalRadians);\n            numStroke = options.applyMaxEdgeLength(numStroke, this.quickLength());\n            numStroke = options.applyMinStrokesPerPrimitive(numStroke);\n        }\n        else {\n            numStroke = StrokeOptions.applyAngleTol(undefined, 4, nominalRadians, 0.02);\n        }\n        numStroke = Math.ceil(this._activeFractionInterval.absoluteDelta() * numStroke);\n        return numStroke;\n    }\n    /** Reverse the active interval and active strokes.\n     * * Primary defining data remains unchanged !!!\n     */\n    reverseInPlace() {\n        this._activeFractionInterval.reverseInPlace();\n        if (this._activeStrokes === undefined)\n            this._activeStrokes = this._globalStrokes.clone();\n        this._activeStrokes.reverseInPlace();\n    }\n    /** Evaluate curve point with respect to fraction. */\n    fractionToPoint(activeFraction, result) {\n        const globalFraction = this._activeFractionInterval.fractionToPoint(activeFraction);\n        result = this._evaluator.fractionToPoint(globalFraction, result);\n        this.localToWorld.multiplyPoint3d(result, result);\n        return result;\n    }\n    /** Evaluate curve point and derivative with respect to fraction. */\n    fractionToPointAndDerivative(activeFraction, result) {\n        const globalFraction = this._activeFractionInterval.fractionToPoint(activeFraction);\n        result = this._evaluator.fractionToPointAndDerivative(globalFraction, result);\n        result.direction.scaleInPlace(this._activeFractionInterval.signedDelta());\n        result.transformInPlace(this.localToWorld);\n        return result;\n    }\n    /** Return a plane with\n     *\n     * * origin at fractional position along the curve\n     * * vectorU is the first derivative, i.e. tangent vector with length equal to the rate of change with respect to the fraction.\n     * * vectorV is the second derivative, i.e.derivative of vectorU.\n     */\n    fractionToPointAnd2Derivatives(activeFraction, result) {\n        const globalFraction = this._activeFractionInterval.fractionToPoint(activeFraction);\n        result = this._evaluator.fractionToPointAnd2Derivatives(globalFraction, result);\n        const a = this._activeFractionInterval.signedDelta();\n        result.vectorU.scaleInPlace(a);\n        result.vectorV.scaleInPlace(a * a);\n        result.transformInPlace(this.localToWorld);\n        return result;\n    }\n    /** Second step of double dispatch:  call `handler.handleTransitionSpiral(this)` */\n    dispatchToGeometryHandler(handler) {\n        return handler.handleTransitionSpiral(this);\n    }\n    /** compare various coordinate quantities */\n    isAlmostEqual(other) {\n        if (other instanceof DirectSpiral3d) {\n            return Geometry.isSameCoordinate(this._nominalL1, other._nominalL1)\n                && Geometry.isSameCoordinate(this._nominalR1, other._nominalR1)\n                && this.localToWorld.isAlmostEqual(other.localToWorld)\n                && this._activeFractionInterval.isAlmostEqual(other._activeFractionInterval)\n                && this._evaluator.isAlmostEqual(other._evaluator);\n        }\n        return false;\n    }\n}\n//# sourceMappingURL=DirectSpiral3d.js.map",
      "start": 1693508122860,
      "end": 1693508122997,
      "sourcemaps": null
    }
  ]
}
