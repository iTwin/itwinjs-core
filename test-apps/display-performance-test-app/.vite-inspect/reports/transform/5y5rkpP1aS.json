{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/AttributeMap.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nclass AttributeMapEntry {\n    constructor(attributes) {\n        this.uninstanced = new Map();\n        this.instanced = new Map();\n        for (const attr of attributes) {\n            const detail = { location: attr[1], type: attr[2] };\n            this.uninstanced.set(attr[0], detail);\n            this.instanced.set(attr[0], detail);\n        }\n        const instanceAttrs = [\n            [\"a_instanceMatrixRow0\", 5 /* VariableType.Vec4 */],\n            [\"a_instanceMatrixRow1\", 5 /* VariableType.Vec4 */],\n            [\"a_instanceMatrixRow2\", 5 /* VariableType.Vec4 */],\n            [\"a_instanceOverrides\", 5 /* VariableType.Vec4 */],\n            [\"a_instanceRgba\", 5 /* VariableType.Vec4 */],\n            [\"a_featureId\", 4 /* VariableType.Vec3 */],\n            [\"a_patternX\", 2 /* VariableType.Float */],\n            [\"a_patternY\", 2 /* VariableType.Float */],\n        ];\n        let location = attributes.length;\n        for (const attr of instanceAttrs) {\n            this.instanced.set(attr[0], { location, type: attr[1] });\n            ++location;\n        }\n    }\n}\n/**\n * A class with static methods which provide access to a global mapping between techniques and attribute details (location and variable type).\n * These details are used when constructing shaders and when setting up buffers through implementations of the BuffersContainer abstract class.\n * @internal\n */\nexport class AttributeMap {\n    constructor() {\n        const posOnly = new AttributeMapEntry([[\"a_pos\", 0, 4 /* VariableType.Vec3 */]]);\n        const skySphere = new AttributeMapEntry([\n            [\"a_pos\", 0, 4 /* VariableType.Vec3 */],\n            [\"a_worldPos\", 1, 4 /* VariableType.Vec3 */],\n        ]);\n        const polyline = new AttributeMapEntry([\n            [\"a_pos\", 0, 4 /* VariableType.Vec3 */],\n            [\"a_prevIndex\", 1, 4 /* VariableType.Vec3 */],\n            [\"a_nextIndex\", 2, 4 /* VariableType.Vec3 */],\n            [\"a_param\", 3, 2 /* VariableType.Float */],\n        ]);\n        const edge = new AttributeMapEntry([\n            [\"a_pos\", 0, 4 /* VariableType.Vec3 */],\n            [\"a_endPointAndQuadIndices\", 1, 5 /* VariableType.Vec4 */],\n        ]);\n        const silhouette = new AttributeMapEntry([\n            [\"a_pos\", 0, 4 /* VariableType.Vec3 */],\n            [\"a_endPointAndQuadIndices\", 1, 5 /* VariableType.Vec4 */],\n            [\"a_normals\", 2, 5 /* VariableType.Vec4 */],\n        ]);\n        const pointCloud = new AttributeMapEntry([\n            [\"a_pos\", 0, 4 /* VariableType.Vec3 */],\n            [\"a_color\", 1, 4 /* VariableType.Vec3 */],\n        ]);\n        const realityMesh = new AttributeMapEntry([\n            [\"a_pos\", 0, 4 /* VariableType.Vec3 */],\n            [\"a_norm\", 1, 3 /* VariableType.Vec2 */],\n            [\"a_uvParam\", 2, 3 /* VariableType.Vec2 */],\n        ]);\n        const planarGrid = new AttributeMapEntry([\n            [\"a_pos\", 0, 4 /* VariableType.Vec3 */],\n            [\"a_uvParam\", 1, 3 /* VariableType.Vec2 */],\n        ]);\n        const screenPoints = new AttributeMapEntry([\n            [\"a_pos\", 0, 3 /* VariableType.Vec2 */],\n        ]);\n        this._attrMaps = new Map([\n            [undefined, posOnly],\n            [24 /* TechniqueId.SkySphereGradient */, skySphere],\n            [25 /* TechniqueId.SkySphereTexture */, skySphere],\n            [1 /* TechniqueId.Polyline */, polyline],\n            [4 /* TechniqueId.Edge */, edge],\n            [5 /* TechniqueId.SilhouetteEdge */, silhouette],\n            [2 /* TechniqueId.PointCloud */, pointCloud],\n            [31 /* TechniqueId.VolClassCopyZ */, screenPoints],\n            [7 /* TechniqueId.RealityMesh */, realityMesh],\n            [8 /* TechniqueId.PlanarGrid */, planarGrid],\n        ]);\n    }\n    static findAttributeMap(techniqueId, instanced) {\n        let entry = attributeMap._attrMaps.get(techniqueId);\n        if (undefined === entry) {\n            entry = attributeMap._attrMaps.get(undefined);\n            attributeMap._attrMaps.set(techniqueId, entry);\n        }\n        return instanced ? entry.instanced : entry.uninstanced;\n    }\n    static findAttribute(attributeName, techniqueId, instanced) {\n        return AttributeMap.findAttributeMap(techniqueId, instanced).get(attributeName);\n    }\n}\nconst attributeMap = new AttributeMap();\n//# sourceMappingURL=AttributeMap.js.map",
      "start": 1693508123671,
      "end": 1693508123826,
      "sourcemaps": null
    }
  ]
}
