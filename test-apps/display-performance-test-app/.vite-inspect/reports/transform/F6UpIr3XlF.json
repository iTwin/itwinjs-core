{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/primitives/PolylineParams.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Rendering\n */\nimport { assert } from \"@itwin/core-bentley\";\nimport { Vector3d } from \"@itwin/core-geometry\";\nimport { PolylineTypeFlags, QPoint3dList } from \"@itwin/core-common\";\nimport { VertexTableBuilder } from \"./VertexTableBuilder\";\nimport { VertexIndices } from \"../../common/render/primitives/VertexIndices\";\nimport { IModelApp } from \"../../IModelApp\";\n/** @internal */\nexport function tesselatePolylineFromMesh(args) {\n    const tesselator = PolylineTesselator.fromMesh(args);\n    return tesselator?.tesselate();\n}\nclass PolylineVertex {\n    constructor() {\n        this.isSegmentStart = false;\n        this.isPolylineStartOrEnd = false;\n        this.vertexIndex = 0;\n        this.prevIndex = 0;\n        this.nextIndex = 0;\n    }\n    init(isSegmentStart, isPolylineStartOrEnd, vertexIndex, prevIndex, nextIndex) {\n        this.isSegmentStart = isSegmentStart;\n        this.isPolylineStartOrEnd = isPolylineStartOrEnd;\n        this.vertexIndex = vertexIndex;\n        this.prevIndex = prevIndex;\n        this.nextIndex = nextIndex;\n    }\n    computeParam(negatePerp, adjacentToJoint = false, joint = false, noDisplacement = false) {\n        if (joint)\n            return 12 /* PolylineParam.kJointBase */;\n        let param;\n        if (noDisplacement)\n            param = 96 /* PolylineParam.kNoneAdjustWeight */; // prevent getting tossed before width adjustment\n        else if (adjacentToJoint)\n            param = 9 /* PolylineParam.kMiterInsideOnly */;\n        else\n            param = this.isPolylineStartOrEnd ? 3 /* PolylineParam.kSquare */ : 6 /* PolylineParam.kMiter */;\n        let adjust = 0;\n        if (negatePerp)\n            adjust = 24 /* PolylineParam.kNegatePerp */;\n        if (!this.isSegmentStart)\n            adjust += 48 /* PolylineParam.kNegateAlong */;\n        return param + adjust;\n    }\n}\nclass PolylineTesselator {\n    constructor(polylines, points, doJointTriangles) {\n        this._numIndices = 0;\n        this._vertIndex = [];\n        this._prevIndex = [];\n        this._nextIndex = [];\n        this._nextParam = [];\n        this._position = [];\n        this._polylines = polylines;\n        if (points instanceof QPoint3dList) {\n            for (const p of points.list)\n                this._position.push(p.unquantize(points.params));\n        }\n        else {\n            this._position = points;\n        }\n        this._doJoints = doJointTriangles;\n    }\n    static fromPolyline(args) {\n        return new PolylineTesselator(args.polylines, args.points, wantJointTriangles(args.width, !!args.flags.is2d));\n    }\n    static fromMesh(args) {\n        if (undefined !== args.edges?.polylines.lines && undefined !== args.points)\n            return new PolylineTesselator(args.edges.polylines.lines, args.points, wantJointTriangles(args.edges.width, true === args.is2d));\n        return undefined;\n    }\n    tesselate() {\n        this._tesselate();\n        const vertIndex = VertexIndices.fromArray(this._vertIndex);\n        const prevIndex = VertexIndices.fromArray(this._prevIndex);\n        const nextIndexAndParam = new Uint8Array(this._numIndices * 4);\n        for (let i = 0; i < this._numIndices; i++) {\n            const index = this._nextIndex[i];\n            const j = i * 4;\n            VertexIndices.encodeIndex(index, nextIndexAndParam, j);\n            nextIndexAndParam[j + 3] = this._nextParam[i] & 0x000000ff;\n        }\n        return {\n            indices: vertIndex,\n            prevIndices: prevIndex,\n            nextIndicesAndParams: nextIndexAndParam,\n        };\n    }\n    _tesselate() {\n        const v0 = new PolylineVertex(), v1 = new PolylineVertex();\n        const maxJointDot = -0.7;\n        for (const line of this._polylines) {\n            if (line.length < 2)\n                continue;\n            const last = line.length - 1;\n            const isClosed = line[0] === line[last];\n            for (let i = 0; i < last; ++i) {\n                const idx0 = line[i];\n                const idx1 = line[i + 1];\n                const isStart = (0 === i);\n                const isEnd = (last - 1 === i);\n                const prevIdx0 = isStart ? (isClosed ? line[last - 1] : idx0) : line[i - 1];\n                const nextIdx1 = isEnd ? (isClosed ? line[1] : idx1) : line[i + 2];\n                v0.init(true, isStart && !isClosed, idx0, prevIdx0, idx1);\n                v1.init(false, isEnd && !isClosed, idx1, nextIdx1, idx0);\n                const jointAt0 = this._doJoints && (isClosed || !isStart) && this._dotProduct(v0) > maxJointDot;\n                const jointAt1 = this._doJoints && (isClosed || !isEnd) && this._dotProduct(v1) > maxJointDot;\n                if (jointAt0 || jointAt1) {\n                    this._addVertex(v0, v0.computeParam(true, jointAt0, false, false));\n                    this._addVertex(v1, v1.computeParam(false, jointAt1, false, false));\n                    this._addVertex(v0, v0.computeParam(false, jointAt0, false, true));\n                    this._addVertex(v0, v0.computeParam(false, jointAt0, false, true));\n                    this._addVertex(v1, v1.computeParam(false, jointAt1, false, false));\n                    this._addVertex(v1, v1.computeParam(false, jointAt1, false, true));\n                    this._addVertex(v0, v0.computeParam(false, jointAt0, false, true));\n                    this._addVertex(v1, v1.computeParam(false, jointAt1, false, true));\n                    this._addVertex(v0, v0.computeParam(false, jointAt0, false, false));\n                    this._addVertex(v0, v0.computeParam(false, jointAt0, false, false));\n                    this._addVertex(v1, v1.computeParam(false, jointAt1, false, true));\n                    this._addVertex(v1, v1.computeParam(true, jointAt1, false, false));\n                    if (jointAt0)\n                        this.addJointTriangles(v0, v0.computeParam(false, true, false, true), v0);\n                    if (jointAt1)\n                        this.addJointTriangles(v1, v1.computeParam(false, true, false, true), v1);\n                }\n                else {\n                    this._addVertex(v0, v0.computeParam(true));\n                    this._addVertex(v1, v1.computeParam(false));\n                    this._addVertex(v0, v0.computeParam(false));\n                    this._addVertex(v0, v0.computeParam(false));\n                    this._addVertex(v1, v1.computeParam(false));\n                    this._addVertex(v1, v1.computeParam(true));\n                }\n            }\n        }\n    }\n    addJointTriangles(v0, p0, v1) {\n        const param = v1.computeParam(false, false, true);\n        for (let i = 0; i < 3; i++) {\n            this._addVertex(v0, p0);\n            this._addVertex(v1, param + i + 1);\n            this._addVertex(v1, param + i);\n        }\n    }\n    _dotProduct(v) {\n        const pos = this._position[v.vertexIndex];\n        const prevDir = Vector3d.createStartEnd(this._position[v.prevIndex], pos);\n        const nextDir = Vector3d.createStartEnd(this._position[v.nextIndex], pos);\n        return prevDir.dotProduct(nextDir);\n    }\n    _addVertex(vertex, param) {\n        this._vertIndex[this._numIndices] = vertex.vertexIndex;\n        this._prevIndex[this._numIndices] = vertex.prevIndex;\n        this._nextIndex[this._numIndices] = vertex.nextIndex;\n        this._nextParam[this._numIndices] = param;\n        this._numIndices++;\n    }\n}\n/** Strictly for tests. @internal */\nexport function tesselatePolyline(polylines, points, doJointTriangles) {\n    const tesselator = new PolylineTesselator(polylines, points, doJointTriangles);\n    return tesselator.tesselate();\n}\n/** @internal */\nexport function createPolylineParams(args) {\n    assert(!args.flags.isDisjoint);\n    const vertices = VertexTableBuilder.buildFromPolylines(args, IModelApp.renderSystem.maxTextureSize);\n    if (undefined === vertices)\n        return undefined;\n    const tesselator = PolylineTesselator.fromPolyline(args);\n    if (undefined === tesselator)\n        return undefined;\n    return {\n        vertices,\n        polyline: tesselator.tesselate(),\n        isPlanar: !!args.flags.isPlanar,\n        type: args.flags.type ?? PolylineTypeFlags.Normal,\n        weight: args.width,\n        linePixels: args.linePixels,\n    };\n}\n/** @internal */\nexport function wantJointTriangles(weight, is2d) {\n    // Joints are incredibly expensive. In 3d, only generate them if the line is sufficiently wide for them to be noticeable.\n    const jointWidthThreshold = 3;\n    return is2d || weight >= jointWidthThreshold;\n}\n//# sourceMappingURL=PolylineParams.js.map",
      "start": 1693508119644,
      "end": 1693508119730,
      "sourcemaps": null
    }
  ]
}
