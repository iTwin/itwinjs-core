{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/hypermodeling/lib/esm/SectionGraphicsProvider.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module HyperModeling\n */\nimport { assert, compareBooleans, compareStrings, Id64 } from \"@itwin/core-bentley\";\nimport { ClipShape, ClipVector, Point3d, Transform } from \"@itwin/core-geometry\";\nimport { ColorDef, Placement2d } from \"@itwin/core-common\";\nimport { CategorySelectorState, DisplayStyle2dState, DrawingViewState, FeatureSymbology, GeometricModel2dState, GraphicBranch, IModelApp, SheetModelState, Tile, TileDrawArgs, TileLoadPriority, TileTree, TileTreeReference, } from \"@itwin/core-frontend\";\nimport { HyperModeling } from \"./HyperModeling\";\nclass ProxyTreeSupplier {\n    compareTileTreeIds(lhs, rhs) {\n        let cmp = compareBooleans(lhs.isSheet, rhs.isSheet);\n        if (0 === cmp)\n            cmp = compareStrings(lhs.state.id, rhs.state.id);\n        return cmp;\n    }\n    async createTileTree(id, iModel) {\n        let view;\n        if (id.isSheet) {\n            assert(undefined !== id.attachment);\n            view = await this.createSheetViewState(id.state, id.attachment);\n        }\n        else {\n            view = await id.state.tryLoadDrawingView();\n        }\n        if (undefined === view)\n            return undefined;\n        try {\n            await iModel.models.load(view.baseModelId);\n            const model = iModel.models.getLoaded(view.baseModelId);\n            if (undefined === model || !(model instanceof GeometricModel2dState))\n                return undefined;\n            const treeRef = model.createTileTreeReference(view);\n            const tree = await treeRef.treeOwner.loadTree();\n            if (undefined === tree)\n                return undefined;\n            const ctor = id.isSheet ? SheetProxyTree : DrawingProxyTree;\n            return new ctor({ tree, ref: treeRef, view, state: id.state, attachment: id.attachment });\n        }\n        catch {\n            return undefined;\n        }\n    }\n    async createSheetViewState(state, attachment) {\n        assert(undefined !== state.viewAttachment);\n        try {\n            // A persistent view of the sheet doesn't necessarily exist, and we don't want a SheetViewState anyway.\n            // All we want is to draw all the elements in the sheet (sans view attachments) clipped by the drawing boundary.\n            // However, ModelState.createTileTreeReference() requires a ViewState.\n            await state.iModel.models.load(attachment.model);\n            const sheet = state.iModel.models.getLoaded(attachment.model);\n            if (undefined === sheet || !(sheet instanceof SheetModelState))\n                return undefined;\n            const sheetExtents = await sheet.queryModelRange();\n            const viewProps = {\n                baseModelId: attachment.model,\n                origin: { x: 0, y: 0 },\n                delta: { x: sheetExtents.high.x, y: sheetExtents.high.y },\n                angle: 0,\n                categorySelectorId: Id64.invalid,\n                displayStyleId: Id64.invalid,\n                model: Id64.invalid,\n                code: {\n                    spec: Id64.invalid,\n                    scope: Id64.invalid,\n                },\n                classFullName: DrawingViewState.classFullName,\n            };\n            const displayStyle = new DisplayStyle2dState({}, state.iModel);\n            const categorySelector = new CategorySelectorState({}, state.iModel);\n            return new DrawingViewState(viewProps, state.iModel, categorySelector, displayStyle, sheetExtents);\n        }\n        catch {\n            return undefined;\n        }\n    }\n}\nconst proxyTreeSupplier = new ProxyTreeSupplier();\n/** A proxy for a 2d tile tree to be drawn in the context of a spatial view. */\nclass ProxyTreeReference extends TileTreeReference {\n    constructor(id) {\n        super();\n        this._owner = id.state.iModel.tiles.getTileTreeOwner(id, proxyTreeSupplier);\n    }\n    get castsShadows() {\n        return false;\n    }\n    getClipVolume(tree) {\n        return true !== HyperModeling.graphicsConfig.ignoreClip ? super.getClipVolume(tree) : undefined;\n    }\n    get treeOwner() { return this._owner; }\n    get _proxiedRef() {\n        const proxiedTree = this.treeOwner.tileTree;\n        return undefined !== proxiedTree ? proxiedTree.ref : undefined;\n    }\n    discloseTileTrees(trees) {\n        super.discloseTileTrees(trees);\n        const ref = this._proxiedRef;\n        if (undefined !== ref)\n            ref.discloseTileTrees(trees);\n    }\n    async getToolTip(hit) {\n        const ref = this._proxiedRef;\n        return undefined !== ref ? ref.getToolTip(hit) : super.getToolTip(hit);\n    }\n}\n/** A proxy for a 2d tile tree to be drawn in the context of a spatial view. */\nclass ProxyTree extends TileTree {\n    constructor(params, location, clipVolume) {\n        const { tree, ref, view } = { ...params };\n        super({\n            id: params.state.id,\n            modelId: tree.modelId,\n            iModel: tree.iModel,\n            location,\n            priority: TileLoadPriority.Primary,\n            clipVolume,\n        });\n        this.tree = tree;\n        this.ref = ref;\n        this.symbologyOverrides = new FeatureSymbology.Overrides(view);\n        const range = tree.iModelTransform.multiplyRange(tree.rootTile.range);\n        const inverse = location.inverse();\n        if (undefined !== inverse)\n            inverse.multiplyRange(range, range);\n        this._viewFlagOverrides = {\n            ...view.viewFlags,\n            lighting: false,\n            // View clip (section clip) should not apply to 2d graphics.\n            clipVolume: false,\n        };\n        this._rootTile = new ProxyTile(this, range);\n    }\n    get rootTile() { return this._rootTile; }\n    get viewFlagOverrides() { return this._viewFlagOverrides; }\n    get is3d() { return false; }\n    get isContentUnbounded() { return false; }\n    get maxDepth() { return 1; }\n    draw(args) {\n        if (!this.isDisplayed)\n            return;\n        const tiles = this.selectTiles(args);\n        for (const tile of tiles)\n            tile.drawGraphics(args);\n        args.drawGraphics();\n    }\n    _selectTiles(_args) {\n        return this.isDisplayed ? [this.rootTile] : [];\n    }\n    prune() {\n        // Our single tile is only a proxy. Our proxied tree(s) will be pruned separately\n    }\n}\nclass DrawingProxyTree extends ProxyTree {\n    constructor(params) {\n        const { state, attachment } = { ...params };\n        const location = state.drawingToSpatialTransform.clone();\n        let clipVolume;\n        if (attachment) {\n            assert(undefined !== state.viewAttachment);\n            const clipJSON = attachment.jsonProperties?.clip;\n            const clip = clipJSON ? ClipVector.fromJSON(clipJSON) : ClipVector.createEmpty();\n            if (!clipJSON) {\n                const placement = Placement2d.fromJSON(attachment.placement);\n                const range = placement.calculateRange();\n                clip.appendShape([\n                    Point3d.create(range.low.x, range.low.y),\n                    Point3d.create(range.high.x, range.low.y),\n                    Point3d.create(range.high.x, range.high.y),\n                    Point3d.create(range.low.x, range.high.y),\n                ]);\n            }\n            if (clip.isValid) {\n                const sheetToWorld = state.viewAttachment.transformToSpatial.clone();\n                clip.transformInPlace(sheetToWorld);\n                clipVolume = IModelApp.renderSystem.createClipVolume(clip);\n            }\n        }\n        super(params, location, clipVolume);\n    }\n    get isDisplayed() { return true !== HyperModeling.graphicsConfig.hideSectionGraphics; }\n}\nclass SheetProxyTree extends ProxyTree {\n    constructor(params) {\n        const { state, attachment } = { ...params };\n        assert(undefined !== state.viewAttachment);\n        assert(undefined !== attachment);\n        const location = state.viewAttachment.transformToSpatial.clone();\n        let clipVolume;\n        if (state.viewAttachment.clip)\n            clipVolume = IModelApp.renderSystem.createClipVolume(state.viewAttachment.clip);\n        super(params, location, clipVolume);\n        // Our view is manufactured. It draws everything regardless of subcategory.\n        this.symbologyOverrides.ignoreSubCategory = true;\n    }\n    get isDisplayed() { return true !== HyperModeling.graphicsConfig.hideSheetAnnotations; }\n}\n/** The single Tile belonging to a ProxyTree, serving as a proxy for all of the proxied tree's tiles. */\nclass ProxyTile extends Tile {\n    constructor(tree, range) {\n        super({ contentId: \"\", range, maximumSize: 512, isLeaf: true }, tree);\n        this.setIsReady();\n    }\n    get hasChildren() { return false; }\n    get hasGraphics() { return true; }\n    get channel() { throw new Error(\"Proxy tile has no content\"); }\n    async requestContent(_isCanceled) { return undefined; }\n    async readContent(_data, _system, _isCanceled) { return {}; }\n    _loadChildren(_resolve, _reject) { }\n    drawGraphics(args) {\n        const proxyTree = this.tree;\n        const sectionTree = proxyTree.tree;\n        const location = proxyTree.iModelTransform.multiplyTransformTransform(sectionTree.iModelTransform);\n        const clipVolume = true === proxyTree.viewFlagOverrides.clipVolume ? proxyTree.clipVolume : undefined;\n        args = new TileDrawArgs({ context: args.context, location, tree: sectionTree, now: args.now, viewFlagOverrides: proxyTree.viewFlagOverrides, clipVolume, parentsAndChildrenExclusive: args.parentsAndChildrenExclusive, symbologyOverrides: proxyTree.symbologyOverrides });\n        sectionTree.draw(args);\n        const rangeGfx = this.getRangeGraphic(args.context);\n        if (undefined !== rangeGfx)\n            args.graphics.add(rangeGfx);\n        if (true !== HyperModeling.graphicsConfig.debugClipVolumes || undefined === proxyTree.clipVolume)\n            return;\n        const builder = args.context.createSceneGraphicBuilder();\n        builder.setSymbology(ColorDef.red, ColorDef.red, 2);\n        for (const prim of proxyTree.clipVolume.clipVector.clips) {\n            if (!(prim instanceof ClipShape))\n                continue;\n            const tf = prim.transformFromClip;\n            const pts = prim.polygon.map((pt) => tf ? tf.multiplyPoint3d(pt) : pt.clone());\n            builder.addLineString(pts);\n        }\n        const branch = new GraphicBranch();\n        branch.entries.push(builder.finish());\n        branch.setViewFlagOverrides({ clipVolume: false });\n        args.context.outputGraphic(args.context.createGraphicBranch(branch, Transform.createIdentity()));\n    }\n}\n/** Draws the 2d section graphics into the 3d view. */\nclass SectionGraphicsProvider {\n    constructor(state, attachment) {\n        this._drawingRef = new ProxyTreeReference({ state, attachment, isSheet: false });\n        if (attachment)\n            this._sheetRef = new ProxyTreeReference({ state, attachment, isSheet: true });\n    }\n    forEachTileTreeRef(_viewport, func) {\n        func(this._drawingRef);\n        if (undefined !== this._sheetRef)\n            func(this._sheetRef);\n    }\n}\n/** Creates a TiledGraphicsProvider that can be associated with a [Viewport]($frontend) to display 2d section graphics and annotations in the context of a [SpatialViewState]($frontend).\n * Typically used indirectly via [[HyperModelingDecorator]].\n * @param state The section drawing location specifying which section drawing to display.\n * @returns A provider suitable for passing to [Viewport.addTiledGraphicsProvider]($frontend).\n * @see [[HyperModelingDecorator.toggleAttachment]] to activate section graphics for a given [[SectionMarker]].\n * @public\n */\nexport async function createSectionGraphicsProvider(state) {\n    let attachment;\n    if (undefined !== state.viewAttachment) {\n        const attachments = await state.iModel.elements.getProps(state.viewAttachment.id);\n        if (1 === attachments.length)\n            attachment = attachments[0];\n    }\n    return new SectionGraphicsProvider(state, attachment);\n}\n//# sourceMappingURL=SectionGraphicsProvider.js.map",
      "start": 1693508120977,
      "end": 1693508121072,
      "sourcemaps": null
    }
  ]
}
