{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/polyface/TriangleCandidate.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Polyface\n */\nimport { Geometry } from \"../Geometry\";\nimport { BarycentricTriangle } from \"../geometry3d/BarycentricTriangle\";\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\n/**\n * `TriangleCandidate` is a `BarycentricTriangle` with additional application-specific label data:\n * * `quality` = numeric indicator of quality (e.g. aspect ratio of this triangle or a combination with other triangles)\n * * `isValid` = boolean flag.\n * * `id` = application specific identifier\n * @internal\n */\nexport class TriangleCandidate extends BarycentricTriangle {\n    constructor(point0, point1, point2, id, quality, isValid) {\n        super(point0, point1, point2);\n        this._isValid = isValid;\n        this._quality = quality;\n        this.id = id;\n    }\n    /**\n     * Copy all coordinate and label data from `other` to this.\n     * @param other source triangle\n     */\n    setFrom(other) {\n        super.setFrom(other);\n        this._isValid = other._isValid;\n        this._quality = other._quality;\n        this.id = other.id;\n        return this;\n    }\n    /** Create (always) a TriangleCandidate.\n     * * Access points from multiple `IndexedXYZCollection`\n     * * mark invalid if any indices are invalid.\n     */\n    static createFromIndexedXYZ(source0, index0, source1, index1, source2, index2, id, result) {\n        if (!result)\n            result = new TriangleCandidate(Point3d.create(), Point3d.create(), Point3d.create(), id, 0.0, false);\n        result.id = id;\n        let numValid = 0;\n        if (undefined !== source0.getPoint3dAtCheckedPointIndex(index0, result.points[0]))\n            numValid++;\n        if (undefined !== source1.getPoint3dAtCheckedPointIndex(index1, result.points[1]))\n            numValid++;\n        if (undefined !== source2.getPoint3dAtCheckedPointIndex(index2, result.points[2]))\n            numValid++;\n        if (numValid === 3)\n            result.updateAspectRatio();\n        else\n            result.markInvalid();\n        return result;\n    }\n    /** (property) return the validity flag. */\n    get isValid() { return this._isValid; }\n    /**\n     * * Mark this triangle invalid.\n     * * optionally set aspect ratio.\n     * * points are not changed\n     * @param aspectRatio\n     */\n    markInvalid(quality) {\n        this._isValid = false;\n        if (quality !== undefined)\n            this._quality = quality;\n    }\n    /**\n     * * Recompute the aspect ratio.\n     * * Mark invalid if aspect ratio is 0 or negative.\n     */\n    updateAspectRatio() {\n        this._quality = super.aspectRatio;\n        this._isValid = this._quality > 0.0;\n    }\n    /**\n     * Clone all coordinate and label data.\n     * @param result optional preallocated `TriangleCandidate`\n     */\n    clone(result) {\n        if (result)\n            return result.setFrom(this);\n        return new TriangleCandidate(this.points[0].clone(), this.points[1].clone(), this.points[2].clone(), this.id, this._quality, this._isValid);\n    }\n    /**\n     * Return a `TriangleCandidate` with\n     *  * coordinate data and labels from `candidateA`\n     *  * LOWER quality of the two candidates.\n     *  * quality reduced by 1 if triangles have opposing normals (negative dot product of the two normals)\n     * @param candidateA candidate known to be valid\n     * @param candidateB candidate that may by valid\n     * @param result copy of candidate A, but if candidateB is valid the result aspect ratio is reduced (a) to the minimum of the two ratios and then (b) reduced by 1 if orientations clash.\n     */\n    static copyWithLowerQuality(candidateA, candidateB, result) {\n        result = candidateA.clone(result);\n        if (candidateB.isValid) {\n            const dot = candidateA.dotProductOfCrossProductsFromOrigin(candidateB);\n            result._quality = Geometry.minXY(candidateA.aspectRatio, candidateB.aspectRatio);\n            if (dot < 0.0)\n                result._quality -= 1.0;\n        }\n        return result;\n    }\n    /**\n     * choose better aspect ratio of triangle, other.\n     * @param triangle known valid triangle, to be updated\n     * @param other candidate replacement\n     */\n    static updateIfOtherHasHigherQuality(triangle, other) {\n        if (other.isValid && other._quality > triangle._quality)\n            triangle.setFrom(other);\n    }\n}\n//# sourceMappingURL=TriangleCandidate.js.map",
      "start": 1693508124982,
      "end": 1693508125058,
      "sourcemaps": null
    }
  ]
}
