{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/glsl/Clipping.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { assert } from \"@itwin/core-bentley\";\nimport { TextureUnit } from \"../RenderFlags\";\nimport { addEyeSpace } from \"./Common\";\nimport { addModelViewMatrix } from \"./Vertex\";\nconst getClipPlaneFloat = `\r\nvec4 getClipPlane(int index) {\r\n  float x = 0.5;\r\n  float y = (float(index) + 0.5) / float(u_clipParams[2]);\r\n  return TEXTURE(s_clipSampler, vec2(x, y));\r\n}\r\n`;\nexport const unpackFloat = `\r\nfloat unpackFloat(vec4 v) {\r\n  const float bias = 38.0;\r\n  v = floor(v * 255.0 + 0.5);\r\n  float temp = v.w / 2.0;\r\n  float exponent = floor(temp);\r\n  float sign = (temp - exponent) * 2.0;\r\n  exponent = exponent - bias;\r\n  sign = -(sign * 2.0 - 1.0);\r\n  float unpacked = dot(sign * v.xyz, vec3(1.0 / 256.0, 1.0 / 65536.0, 1.0 / 16777216.0)); // shift x right 8, y right 16 and z right 24\r\n  return unpacked * pow(10.0, exponent);\r\n}\r\n`;\nconst calcClipPlaneDist = `\r\nfloat calcClipPlaneDist(vec3 camPos, vec4 plane) {\r\n  return dot(vec4(camPos, 1.0), plane);\r\n}\r\n`;\nconst applyClipPlanesPrelude = `\r\n  int numPlaneSets = 1;\r\n  int numSetsClippedBy = 0;\r\n  bool clippedByCurrentPlaneSet = false;\r\n`;\nconst applyClipPlanesLoop = `\r\n  for (int i = u_clipParams[0]; i < u_clipParams[1]; i++) {\r\n`;\nconst applyClipPlanesPostlude = `\r\n    vec4 plane = getClipPlane(i);\r\n    if (plane.x == 2.0) { // indicates start of new UnionOfConvexClipPlaneSets\r\n      if (numSetsClippedBy + int(clippedByCurrentPlaneSet) == numPlaneSets)\r\n        break;\r\n\r\n      numPlaneSets = 1;\r\n      numSetsClippedBy = 0;\r\n      clippedByCurrentPlaneSet = false;\r\n    } else if (plane.xyz == vec3(0.0)) { // indicates start of new clip plane set\r\n      numPlaneSets = numPlaneSets + 1;\r\n      numSetsClippedBy += int(clippedByCurrentPlaneSet);\r\n      clippedByCurrentPlaneSet = false;\r\n    } else if (!clippedByCurrentPlaneSet && calcClipPlaneDist(v_eyeSpace, plane) < 0.0) {\r\n      clippedByCurrentPlaneSet = true;\r\n    }\r\n  }\r\n\r\n  numSetsClippedBy += int(clippedByCurrentPlaneSet);\r\n  if (numSetsClippedBy == numPlaneSets) {\r\n    if (u_outsideRgba.a > 0.0) {\r\n      g_clipColor = u_outsideRgba.rgb;\r\n      return true;\r\n    } else {\r\n      discard;\r\n    }\r\n  } else if (u_insideRgba.a > 0.0) {\r\n    g_clipColor = u_insideRgba.rgb;\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n`;\nconst applyClipPlanes = applyClipPlanesPrelude + applyClipPlanesLoop + applyClipPlanesPostlude;\nconst clipParams = new Int32Array(3);\n/** @internal */\nexport function addClipping(prog) {\n    const frag = prog.frag;\n    const vert = prog.vert;\n    addEyeSpace(prog);\n    // [0] = index of first plane\n    // [1] = index of last plane (one past the end)\n    // [2] = texture height\n    prog.addUniformArray(\"u_clipParams\", 1 /* VariableType.Int */, 3, (program) => {\n        program.addGraphicUniform(\"u_clipParams\", (uniform, params) => {\n            // Set this to false to visualize pre-shader culling of geometry.\n            const doClipping = true;\n            const stack = params.target.uniforms.branch.clipStack;\n            clipParams[0] = stack.startIndex;\n            clipParams[1] = stack.endIndex;\n            clipParams[2] = doClipping ? stack.textureHeight : 0;\n            assert(clipParams[2] > 0 || !doClipping);\n            uniform.setUniform1iv(clipParams);\n        });\n    });\n    prog.addUniform(\"u_outsideRgba\", 5 /* VariableType.Vec4 */, (program) => {\n        program.addGraphicUniform(\"u_outsideRgba\", (uniform, params) => {\n            params.target.uniforms.branch.clipStack.outsideColor.bind(uniform);\n        });\n    });\n    prog.addUniform(\"u_insideRgba\", 5 /* VariableType.Vec4 */, (program) => {\n        program.addGraphicUniform(\"u_insideRgba\", (uniform, params) => {\n            params.target.uniforms.branch.clipStack.insideColor.bind(uniform);\n        });\n    });\n    addModelViewMatrix(vert);\n    frag.addFunction(getClipPlaneFloat);\n    frag.addFunction(calcClipPlaneDist);\n    frag.addUniform(\"s_clipSampler\", 8 /* VariableType.Sampler2D */, (program) => {\n        program.addGraphicUniform(\"s_clipSampler\", (uniform, params) => {\n            const texture = params.target.uniforms.branch.clipStack.texture;\n            assert(texture !== undefined);\n            if (texture !== undefined)\n                texture.bindSampler(uniform, TextureUnit.ClipVolume);\n        });\n    }, 3 /* VariablePrecision.High */);\n    frag.set(10 /* FragmentShaderComponent.ApplyClipping */, applyClipPlanes);\n}\n//# sourceMappingURL=Clipping.js.map",
      "start": 1693508125129,
      "end": 1693508125295,
      "sourcemaps": null
    }
  ]
}
