{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tile/map/ArcGISTileMap.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tiles\n */\nimport { request } from \"../../request/Request\";\nimport { assert, compareStrings, Dictionary } from \"@itwin/core-bentley\";\nimport { ArcGisUtilities, QuadId } from \"../internal\";\nconst nonVisibleChildren = [false, false, false, false];\n/** @internal */\nexport class ArcGISTileMap {\n    constructor(restBaseUrl, settings, nbLods, accessClient) {\n        this.tileMapRequestSize = 32;\n        this.fallbackTileMapRequestSize = 2;\n        this._tilesCache = new Dictionary((lhs, rhs) => compareStrings(lhs, rhs));\n        this._restBaseUrl = restBaseUrl;\n        this._accessClient = accessClient;\n        this._settings = settings;\n        if (nbLods !== undefined && nbLods > 0) {\n            this._callQueues = new Array(nbLods).fill(Promise.resolve(nonVisibleChildren));\n        }\n    }\n    async fetchTileMapFromServer(level, row, column, width, height) {\n        const tmpUrl = `${this._restBaseUrl}/tilemap/${level}/${row}/${column}/${width}/${height}?f=json`;\n        const urlObj = new URL(tmpUrl);\n        try {\n            if (this._accessClient) {\n                await ArcGisUtilities.appendSecurityToken(urlObj, this._accessClient, {\n                    mapLayerUrl: new URL(this._settings.url),\n                    userName: this._settings.userName,\n                    password: this._settings.password,\n                });\n            }\n        }\n        catch {\n        }\n        return request(urlObj.toString(), \"json\");\n    }\n    getAvailableTilesFromCache(tiles) {\n        let allTilesFound = true;\n        // Check children visibility from cache\n        const available = tiles.map((tileId) => {\n            const avail = this._tilesCache.get(tileId.contentId);\n            if (undefined === avail) {\n                allTilesFound = false;\n            }\n            return avail ?? false;\n        });\n        return { allTilesFound, available };\n    }\n    async getChildrenAvailability(childIds) {\n        if (!childIds.length)\n            return [];\n        // We need to check cache again:\n        // Tiles we are looking for may have been added to cache while we were waiting in the call queue.\n        const cacheInfo = this.getAvailableTilesFromCache(childIds);\n        if (cacheInfo.allTilesFound) {\n            return cacheInfo.available;\n        }\n        // If we never encountered this tile level before, then a tilemap request must be made to get tiles visibility.\n        // However, we dont want several overlapping large tilemap request being made simultaneously for tiles on the same level.\n        // To avoid this from happening, we 'serialize' async calls so that we wait until the first tilemap request has completed\n        // before making another one.\n        const childLevel = childIds[0].level + 1;\n        if (this._callQueues && childLevel < this._callQueues.length) {\n            const res = this._callQueues[childLevel].then(async () => this.getChildrenAvailabilityFromServer(childIds));\n            this._callQueues[childLevel] = res.catch(() => nonVisibleChildren);\n            return res;\n        }\n        else {\n            // We should not be in this case, probably because server info is missing LODs in the capabilities?!\n            return this.getChildrenAvailabilityFromServer(childIds);\n        }\n    }\n    // Query tiles are tiles that we need to check availability\n    // The array is assumed to be in in row major orientation, i.e.: [TileRow0Col0, TileRow0Col1, TileRow1Col0, TileRow1Col1,]\n    async fetchAndReadTilemap(queryTiles, reqWidth, reqHeight) {\n        let available = [];\n        if (queryTiles.length === 0) {\n            return available;\n        }\n        const row = queryTiles[0].row;\n        const column = queryTiles[0].column;\n        const level = queryTiles[0].level;\n        let reqRow, reqColumn;\n        if (reqWidth === this.fallbackTileMapRequestSize && reqHeight === this.fallbackTileMapRequestSize) {\n            reqRow = row;\n            reqColumn = column;\n        }\n        else {\n            // If tile map if big enough. create offset that will place the current tile in the middle of the tilemap.\n            // If we place the first query tile in the top-left corner (i.e. without offset), any query for a tile located above or on the left\n            // will trigger a new request.\n            const offsetRow = (reqHeight / 2.0) - 1;\n            const offsetColumn = (reqWidth / 2.0) - 1;\n            reqRow = Math.max(row - offsetRow, 0);\n            reqColumn = Math.max(column - offsetColumn, 0);\n        }\n        try {\n            // console.log(`Tilemap request: ${level},${reqRow},${reqColumn},${reqWidth},${reqHeight}`);\n            const json = await this.fetchTileMapFromServer(level, reqRow, reqColumn, reqWidth, reqHeight);\n            let tileMapWidth = reqWidth;\n            let tileMapHeight = reqHeight;\n            if (Array.isArray(json.data)) {\n                // The response width and height might be different than the requested dimensions.\n                // Ref: https://developers.arcgis.com/rest/services-reference/enterprise/tile-map.htm\n                if (json.adjusted) {\n                    // If tilemap size got adjusted, I'm expecting to get adjusted size...\n                    // otherwise there is something really odd with this server.\n                    assert(json.location?.width !== undefined && json.location?.height !== undefined);\n                    if (json.location?.width !== undefined && json.location?.height !== undefined) {\n                        tileMapWidth = json.location?.width;\n                        tileMapHeight = json.location?.height;\n                    }\n                }\n                let k = 0;\n                for (let j = 0; j < tileMapWidth; j++) {\n                    for (let i = 0; i < tileMapHeight; i++) {\n                        const avail = json.data[(j * tileMapWidth) + i] !== 0;\n                        const curColumn = reqColumn + i;\n                        const curRow = reqRow + j;\n                        // console.log(`Tilemap tile:: ${level},${curRow},${curColumn} => ${avail}`);\n                        this._tilesCache.set(QuadId.getTileContentId(level, curColumn, curRow), avail);\n                        // Check if actual tile is among the children we are looking for, if so update the availability array.\n                        if (curColumn >= queryTiles[0].column && curColumn <= queryTiles[queryTiles.length - 1].column\n                            && curRow >= queryTiles[0].row && curRow <= queryTiles[queryTiles.length - 1].row) {\n                            available[k++] = avail;\n                        }\n                    }\n                }\n            }\n            else {\n                // If server returns data (i.e. error 422), thats fine we assume all tiles of tilemap are not available.\n                available = queryTiles.map(() => false);\n                // Mark all tilemap tiles to non-available in the cache too\n                for (let j = 0; j < tileMapWidth; j++) {\n                    for (let i = 0; i < tileMapHeight; i++) {\n                        this._tilesCache.set(QuadId.getTileContentId(level, reqColumn + i, reqRow + j), false);\n                    }\n                }\n            }\n        }\n        catch (_error) {\n            available = queryTiles.map(() => false);\n        }\n        return available;\n    }\n    async getChildrenAvailabilityFromServer(childIds) {\n        // We need to check cache again:\n        // Tiles we are looking for may have been added to cache while we were waiting in the call queue.\n        const cacheInfo = this.getAvailableTilesFromCache(childIds);\n        if (cacheInfo.allTilesFound) {\n            return cacheInfo.available;\n        }\n        let available;\n        try {\n            available = await this.fetchAndReadTilemap(childIds, this.tileMapRequestSize, this.tileMapRequestSize);\n            if (available.length !== childIds.length) {\n                if (this.tileMapRequestSize > this.fallbackTileMapRequestSize) {\n                    // Maybe we were unlucky and the tilemap got adjusted our the tiles we are looking for got clipped,\n                    // so let try we a smaller tilemap\n                    available = await this.fetchAndReadTilemap(childIds, this.fallbackTileMapRequestSize, this.fallbackTileMapRequestSize);\n                }\n                if (available.length < childIds.length) {\n                    // Could not all tiles children tiles, returns what we got and fill any gaps with false.\n                    const tmpAvail = childIds.map(() => false);\n                    for (let i = 0; i < available.length; i++) {\n                        tmpAvail[i] = available[i];\n                    }\n                    available = tmpAvail;\n                }\n            }\n        }\n        catch (_error) {\n            // if any error occurs, we assume tiles not to be visible\n            available = childIds.map(() => false);\n        }\n        return available;\n    }\n}\n//# sourceMappingURL=ArcGISTileMap.js.map",
      "start": 1693508121658,
      "end": 1693508121812,
      "sourcemaps": null
    }
  ]
}
