{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/curve/spiral/CzechSpiralEvaluator.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Curve\n */\nimport { Geometry } from \"../../Geometry\";\nimport { CubicEvaluator } from \"./CubicEvaluator\";\nimport { SimpleNewton } from \"../../numerics/Newton\";\n/**\n * Czech cubic.\n * This is y= m*x^3 with\n * * x any point on the x axis\n * * `fraction` along the spiral goes to `x = fraction * L`\n * * m is gamma / (6RL)\n *    * 1/(6RL) is the leading term of the sine series.\n *    * `gamma = 2R/sqrt (4RR-LL)` pushes y down a little bit to simulate the lost series terms.\n * @param localToWorld\n * @param nominalL1\n * @param nominalR1\n * @param activeInterval\n * @internal\n */\nexport class CzechSpiralEvaluator extends CubicEvaluator {\n    /** Constructor is private.  Caller responsible for cubicM validity. */\n    constructor(length1, radius1, cubicM) {\n        super(length1, cubicM);\n        this.nominalLength1 = length1;\n        this.nominalRadius1 = radius1;\n    }\n    /**\n     * Return the scale factor between simple x^3 / (6RL) cubic and the czech correction.\n     * * For typical case with l1/R1 smallish, this is just less than 1.0:\n     *   (0.25==>0.99215), (0.15==>0.997184), (0.10==>0.998749), (0.05==>999687)\n     * @param length1\n     * @param radius1\n     */\n    static gammaConstant(length1, radius1) {\n        return 2.0 * radius1 / Math.sqrt(4.0 * radius1 * radius1 - length1 * length1);\n    }\n    /** Compute the czech cubic constant. */\n    static computeCubicM(length1, radius1) {\n        const gamma = CzechSpiralEvaluator.gammaConstant(length1, radius1);\n        // In the private update method, the LR values should have been vetted.\n        if (gamma === undefined)\n            return undefined;\n        // If radius is negative, it shows up in gamma.  But the a signed denominator undoes it.  So take abs of denominator.\n        return gamma / Math.abs((6.0 * radius1 * length1));\n    }\n    static create(length1, radius1) {\n        const m = this.computeCubicM(length1, radius1);\n        if (m === undefined)\n            return undefined;\n        return new CzechSpiralEvaluator(length1, radius1, m);\n    }\n    scaleInPlace(scaleFactor) {\n        this.nominalLength1 *= scaleFactor;\n        this.nominalRadius1 *= scaleFactor;\n        super.scaleInPlace(scaleFactor);\n    }\n    /** return a deep copy of the evaluator */\n    clone() { return new CzechSpiralEvaluator(this.nominalLength1, this.nominalRadius1, this.cubicM); }\n    /** Member by member matchup ... */\n    isAlmostEqual(other) {\n        if (other instanceof CzechSpiralEvaluator) {\n            return Geometry.isSameCoordinate(this.nominalLength1, other.nominalLength1)\n                && Geometry.isSameCoordinate(this.nominalRadius1, other.nominalRadius1);\n        }\n        return false;\n    }\n    /**\n     * Return a (fast but mediocre) approximation of spiral length as a function of x axis position.\n     * * This x-to-distance relation is not as precise as the CurvePrimitive method moveSignedDistanceFromFraction.\n     * * It is supported here for users interested in replicating the Czech distance mapping rather than the more accurate CurvePrimitive measurements.\n     * @param x distance along the x axis.\n     */\n    xToCzechApproximateDistance(x) {\n        return CzechSpiralEvaluator.forwardL2R2Map(x, 1.0, this.nominalLength1, this.nominalRadius1);\n    }\n    /**\n     * Return the inverse of the `forwardL2R2Map` function.\n     * * The undefined result can only occur for distances outside the usual spirals.\n     * @param s (approximate) distance along the spiral.\n     *\n     */\n    czechApproximateDistanceToX(d) {\n        return CzechSpiralEvaluator.inverseL2R2Map(d, 1.0, this.nominalLength1, this.nominalRadius1);\n    }\n    /**\n       * evaluate a series expansion that is used with varying signs (plus or minus 1) in czech and italian spirals.\n       * @param x distance along the x axis.\n       */\n    static forwardL2R2Map(x, sign, length, radius) {\n        const l2 = length * length;\n        const r2 = radius * radius;\n        const Q = 4.0 * r2 - l2;\n        const xx = x * x;\n        return x * (1.0 + sign * xx * xx / (10.0 * Q * l2));\n    }\n    /**\n     * Return the inverse of the `forwardL2R2Map` function.\n     * * The undefined result can only occur for distances outside the usual spirals.\n     * @param s (approximate) distance along the spiral.\n     *\n     */\n    static inverseL2R2Map(b, sign, length, radius) {\n        const l2 = length * length;\n        const r2 = radius * radius;\n        const Q = 4.0 * r2 - l2;\n        const a = sign / (10.0 * Q * l2);\n        return SimpleNewton.runNewton1D(b, (x) => {\n            const xx = x * x;\n            return x * (1.0 + xx * xx * a) - b;\n        }, (x) => {\n            const xx = x * x;\n            return 1.0 + 5 * xx * xx * a;\n        });\n    }\n}\n/**\n * Italian cubic.\n * This is y= m*x^3 with\n * * x any point on the x axis\n * * `fraction` along the spiral goes to `x = fraction * L`\n * * m is gamma / (6RL)\n *    * 1/(6RL) is the leading term of the sine series.\n *    * `gamma = 2R/sqrt (4RR-LL)` pushes y down a little bit to simulate the lost series terms.\n * @param localToWorld\n * @param nominalL1\n * @param nominalR1\n * @param activeInterval\n * @internal\n */\nexport class ItalianSpiralEvaluator extends CubicEvaluator {\n    /** Compute the czech cubic constant.\n     * ** funky mixture of lengths ....\n     */\n    static computeCubicM(lengthXByForward, radius1) {\n        const gamma = CzechSpiralEvaluator.gammaConstant(lengthXByForward, radius1);\n        // In the private update method, the LR values should have been vetted.\n        if (gamma === undefined)\n            return undefined;\n        // If radius is negative, it shows up in gamma.  But the a signed denominator undoes it.  So take abs of denominator.\n        return gamma / Math.abs((6.0 * radius1 * lengthXByForward));\n    }\n    /** Constructor is private.  Caller responsible for cubicM validity. */\n    constructor(length1, radius1, lengthX, cubicM) {\n        super(lengthX, cubicM);\n        this.nominalLength1 = length1;\n        this.nominalRadius1 = radius1;\n    }\n    static create(length1, radius1) {\n        // um ... this seems goofy.  lengthX from forward, then invert for another .   But that's what the native code does ...\n        const lengthX = CzechSpiralEvaluator.forwardL2R2Map(length1, -1.0, length1, radius1);\n        const lengthX1 = CzechSpiralEvaluator.inverseL2R2Map(length1, 1.0, lengthX, radius1);\n        if (lengthX1 === undefined)\n            return undefined;\n        const m = ItalianSpiralEvaluator.computeCubicM(lengthX, radius1);\n        if (m === undefined)\n            return undefined;\n        return new ItalianSpiralEvaluator(length1, radius1, lengthX1, m);\n    }\n    scaleInPlace(scaleFactor) {\n        this.nominalLength1 *= scaleFactor;\n        this.nominalRadius1 *= scaleFactor;\n        super.scaleInPlace(scaleFactor);\n    }\n    /** return a deep copy of the evaluator */\n    clone() { return new ItalianSpiralEvaluator(this.nominalLength1, this.nominalRadius1, super.axisLength, this.cubicM); }\n    /** Member by member matchup ... */\n    isAlmostEqual(other) {\n        if (other instanceof ItalianSpiralEvaluator) {\n            return Geometry.isSameCoordinate(this.nominalLength1, other.nominalLength1)\n                && Geometry.isSameCoordinate(this.nominalRadius1, other.nominalRadius1);\n        }\n        return false;\n    }\n    /**\n       * Return a (fast but mediocre) approximation of spiral length as a function of x axis position.\n       * * This x-to-distance relation is not as precise as the CurvePrimitive method moveSignedDistanceFromFraction.\n       * * It is supported here for users interested in replicating the Czech distance mapping rather than the more accurate CurvePrimitive measurements.\n       * @param x distance along the x axis.\n       */\n    distanceToItalianApproximateX(x) {\n        return CzechSpiralEvaluator.forwardL2R2Map(x, -1.0, this.nominalLength1, this.nominalRadius1);\n    }\n    /**\n     * Return the inverse of the `forwardL2R2Map` function.\n     * * The undefined result can only occur for distances outside the usual spirals.\n     * @param s (approximate) distance along the spiral.\n     *\n     */\n    xToItalianApproximateDistance(d) {\n        return CzechSpiralEvaluator.inverseL2R2Map(d, -1.0, this.nominalLength1, this.nominalRadius1);\n    }\n}\n//# sourceMappingURL=CzechSpiralEvaluator.js.map",
      "start": 1693508124214,
      "end": 1693508124365,
      "sourcemaps": null
    }
  ]
}
