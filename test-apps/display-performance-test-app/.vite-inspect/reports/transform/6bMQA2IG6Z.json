{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/PlanarClassifier.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { dispose } from \"@itwin/core-bentley\";\nimport { ColorDef, FrustumPlanes, RenderMode, RenderTexture, SpatialClassifierInsideDisplay, SpatialClassifierOutsideDisplay, TextureTransparency, } from \"@itwin/core-common\";\nimport { Matrix4d, Plane3dByOriginAndUnitNormal, Point3d, Vector3d } from \"@itwin/core-geometry\";\nimport { GraphicsCollectorDrawArgs } from \"../../tile/internal\";\nimport { RenderPlanarClassifier } from \"../RenderPlanarClassifier\";\nimport { BatchState } from \"./BatchState\";\nimport { BranchStack } from \"./BranchStack\";\nimport { Combine3TexturesGeometry, CombineTexturesGeometry, ViewportQuadGeometry } from \"./CachedGeometry\";\nimport { FrameBuffer } from \"./FrameBuffer\";\nimport { GL } from \"./GL\";\nimport { Batch, Branch } from \"./Graphic\";\nimport { PlanarTextureProjection } from \"./PlanarTextureProjection\";\nimport { RenderCommands } from \"./RenderCommands\";\nimport { RenderState } from \"./RenderState\";\nimport { getDrawParams } from \"./ScratchDrawParams\";\nimport { System } from \"./System\";\nimport { Texture, TextureHandle } from \"./Texture\";\nexport var PlanarClassifierContent;\n(function (PlanarClassifierContent) {\n    PlanarClassifierContent[PlanarClassifierContent[\"None\"] = 0] = \"None\";\n    PlanarClassifierContent[PlanarClassifierContent[\"MaskOnly\"] = 1] = \"MaskOnly\";\n    PlanarClassifierContent[PlanarClassifierContent[\"ClassifierOnly\"] = 2] = \"ClassifierOnly\";\n    PlanarClassifierContent[PlanarClassifierContent[\"ClassifierAndMask\"] = 3] = \"ClassifierAndMask\";\n})(PlanarClassifierContent || (PlanarClassifierContent = {}));\nfunction createTexture(handle) {\n    return new Texture({\n        handle,\n        ownership: \"external\",\n        type: RenderTexture.Type.TileSection,\n        transparency: TextureTransparency.Opaque,\n    });\n}\nfunction createTextureHandle(width, height, heightMult = 1.0) {\n    return TextureHandle.createForAttachment(width, height * heightMult, GL.Texture.Format.Rgba, GL.Texture.DataType.UnsignedByte);\n}\nclass ClassifierTextures {\n    constructor(color, feature, hilite) {\n        this.color = color;\n        this.feature = feature;\n        this.hilite = hilite;\n    }\n    get isDisposed() {\n        return this.color.isDisposed\n            && this.feature.isDisposed\n            && this.hilite.isDisposed;\n    }\n    dispose() {\n        dispose(this.color);\n        dispose(this.feature);\n        dispose(this.hilite);\n    }\n    collectStatistics(stats) {\n        stats.addPlanarClassifier(this.color.bytesUsed);\n        stats.addPlanarClassifier(this.feature.bytesUsed);\n        stats.addPlanarClassifier(this.hilite.bytesUsed);\n    }\n    static create(width, height) {\n        const hColor = createTextureHandle(width, height);\n        const hFeature = createTextureHandle(width, height);\n        const hHilite = createTextureHandle(width, height);\n        if (!hColor || !hFeature || !hHilite)\n            return undefined;\n        const color = createTexture(hColor);\n        const feature = createTexture(hFeature);\n        const hilite = createTexture(hHilite);\n        if (!color || !feature || !hilite)\n            return undefined;\n        return new ClassifierTextures(color, feature, hilite);\n    }\n}\nclass ClassifierFrameBuffers {\n    constructor(textures, _hilite, _fbo, _clearGeom) {\n        this.textures = textures;\n        this._hilite = _hilite;\n        this._fbo = _fbo;\n        this._clearGeom = _clearGeom;\n    }\n    get isDisposed() {\n        return this.textures.isDisposed && this._hilite.isDisposed && this._fbo.isDisposed && this._clearGeom.isDisposed;\n    }\n    dispose() {\n        dispose(this._fbo);\n        dispose(this._clearGeom);\n        dispose(this.textures);\n        dispose(this._hilite);\n    }\n    draw(cmds, target) {\n        System.instance.frameBufferStack.execute(this._fbo, true, false, () => {\n            target.techniques.draw(getDrawParams(target, this._clearGeom));\n            target.techniques.execute(target, cmds, 19 /* RenderPass.PlanarClassification */);\n        });\n    }\n    drawHilite(cmds, target) {\n        const system = System.instance;\n        const gl = system.context;\n        system.frameBufferStack.execute(this._hilite, true, false, () => {\n            gl.clearColor(0, 0, 0, 0);\n            gl.clear(GL.BufferBit.Color);\n            target.techniques.execute(target, cmds, 10 /* RenderPass.Hilite */);\n        });\n    }\n    static create(width, height) {\n        const textures = ClassifierTextures.create(width, height);\n        if (undefined === textures)\n            return undefined;\n        const hiliteFbo = FrameBuffer.create([textures.hilite.texture]);\n        if (undefined === hiliteFbo)\n            return undefined;\n        const fbo = FrameBuffer.create([textures.color.texture, textures.feature.texture]);\n        if (undefined === fbo)\n            return undefined;\n        const geom = ViewportQuadGeometry.create(21 /* TechniqueId.ClearPickAndColor */);\n        return undefined !== geom ? new this(textures, hiliteFbo, fbo, geom) : undefined;\n    }\n}\nclass SingleTextureFrameBuffer {\n    get isDisposed() { return this.texture.isDisposed && this.fbo.isDisposed; }\n    collectStatistics(stats) { stats.addPlanarClassifier(this.texture.bytesUsed); }\n    constructor(textureAndFbo) {\n        this.texture = textureAndFbo.texture;\n        this.fbo = textureAndFbo.fbo;\n    }\n    dispose() {\n        dispose(this.texture);\n        dispose(this.fbo);\n    }\n    static createTextureAndFrameBuffer(width, height) {\n        const hTexture = TextureHandle.createForAttachment(width, height, GL.Texture.Format.Rgba, GL.Texture.DataType.UnsignedByte);\n        if (!hTexture)\n            return undefined;\n        const texture = new Texture({ type: RenderTexture.Type.TileSection, ownership: \"external\", handle: hTexture, transparency: TextureTransparency.Opaque });\n        if (!texture)\n            return undefined;\n        const fbo = FrameBuffer.create([texture.texture]);\n        if (undefined === fbo)\n            return undefined;\n        return { texture, fbo };\n    }\n}\nclass MaskFrameBuffer extends SingleTextureFrameBuffer {\n    static create(width, height) {\n        const textureFbo = SingleTextureFrameBuffer.createTextureAndFrameBuffer(width, height);\n        return undefined === textureFbo ? undefined : new MaskFrameBuffer(textureFbo);\n    }\n    draw(cmds, target) {\n        const system = System.instance;\n        const gl = system.context;\n        system.frameBufferStack.execute(this.fbo, true, false, () => {\n            gl.clearColor(0, 0, 0, 0);\n            gl.clear(GL.BufferBit.Color);\n            target.techniques.execute(target, cmds, 19 /* RenderPass.PlanarClassification */);\n        });\n    }\n}\nclass CombineTexturesFrameBuffer extends SingleTextureFrameBuffer {\n    constructor(textureAndFbo, _combineGeom, _width, _height, _heightMult) {\n        super(textureAndFbo);\n        this._combineGeom = _combineGeom;\n        this._width = _width;\n        this._height = _height;\n        this._heightMult = _heightMult;\n    }\n    compose(target) {\n        const system = System.instance;\n        const gl = system.context;\n        system.context.viewport(0, 0, this._width, this._heightMult * this._height);\n        system.frameBufferStack.execute(this.fbo, true, false, () => {\n            gl.clearColor(0, 0, 0, 0);\n            gl.clear(GL.BufferBit.Color);\n            target.techniques.draw(getDrawParams(target, this._combineGeom));\n        });\n    }\n}\nclass ClassifierCombinationBuffer extends CombineTexturesFrameBuffer {\n    static create(width, height, classifierColor, classifierFeature) {\n        const combineGeom = CombineTexturesGeometry.createGeometry(classifierColor.texture.getHandle(), classifierFeature.texture.getHandle());\n        if (undefined === combineGeom)\n            return undefined;\n        const textureFbo = SingleTextureFrameBuffer.createTextureAndFrameBuffer(width, 2 * height);\n        return undefined === textureFbo ? undefined : new ClassifierCombinationBuffer(textureFbo, combineGeom, width, height, 2);\n    }\n}\nclass ClassifierAndMaskCombinationBuffer extends CombineTexturesFrameBuffer {\n    static create(width, height, classifierColor, classifierFeature, mask) {\n        const combineGeom = Combine3TexturesGeometry.createGeometry(classifierColor.texture.getHandle(), classifierFeature.texture.getHandle(), mask.texture.getHandle());\n        if (undefined === combineGeom)\n            return undefined;\n        const textureFbo = SingleTextureFrameBuffer.createTextureAndFrameBuffer(width, 3 * height);\n        return undefined === textureFbo ? undefined : new ClassifierAndMaskCombinationBuffer(textureFbo, combineGeom, width, height, 3);\n    }\n}\nconst scratchPrevRenderState = new RenderState();\n/** @internal */\nclass PlanarClassifier extends RenderPlanarClassifier {\n    constructor(classifier, target) {\n        super();\n        this._projectionMatrix = Matrix4d.createIdentity();\n        this._classifierGraphics = [];\n        this._maskGraphics = [];\n        this._width = 0;\n        this._height = 0;\n        this._baseBatchId = 0;\n        this._anyHilited = false;\n        this._anyOpaque = false;\n        this._anyTranslucent = false;\n        this._plane = Plane3dByOriginAndUnitNormal.create(new Point3d(0, 0, 0), new Vector3d(0, 0, 1)); // TBD -- Support other planes - default to X-Y for now.\n        this._renderState = new RenderState();\n        this._branchStack = new BranchStack();\n        this._contentMode = PlanarClassifierContent.None;\n        this._doDebugFrustum = false;\n        this._debugFrustumGraphic = undefined;\n        this._bgColor = ColorDef.from(0, 0, 0, 255);\n        this._classifier = classifier;\n        const flags = this._renderState.flags;\n        flags.depthMask = flags.blend = flags.depthTest = false;\n        this._batchState = new BatchState(this._branchStack);\n        this._renderCommands = new RenderCommands(target, this._branchStack, this._batchState);\n    }\n    get textureImageCount() { return this._contentMode; }\n    getParams(params) {\n        params[0] = this.insideDisplay;\n        params[1] = this.outsideDisplay;\n        params[2] = this._contentMode;\n        if (this._planarClipMask?.settings.invert) // If the mask sense is inverted, negate the contentMode to indicate this to the shader.\n            params[2] = -params[2];\n        params[3] = (this._planarClipMask?.settings.transparency === undefined) ? -1 : this._planarClipMask.settings.transparency;\n    }\n    get hiliteTexture() { return undefined !== this._classifierBuffers ? this._classifierBuffers.textures.hilite : undefined; }\n    get projectionMatrix() { return this._projectionMatrix; }\n    // public get properties(): SpatialClassifier { return this._classifier; }\n    get baseBatchId() { return this._baseBatchId; }\n    get anyHilited() { return this._anyHilited; }\n    get anyOpaque() { return this._anyOpaque; }\n    get anyTranslucent() { return this._anyTranslucent; }\n    get insideDisplay() { return this._classifier ? this._classifier.flags.inside : SpatialClassifierInsideDisplay.Off; }\n    get outsideDisplay() { return this._classifier ? this._classifier.flags.outside : SpatialClassifierOutsideDisplay.On; }\n    get isClassifyingPointCloud() { return true === this._isClassifyingPointCloud; }\n    addGraphic(graphic) {\n        this._graphics.push(graphic);\n    }\n    static create(properties, target) {\n        return new PlanarClassifier(properties, target);\n    }\n    collectStatistics(stats) {\n        if (undefined !== this._classifierBuffers)\n            this._classifierBuffers.textures.collectStatistics(stats);\n        if (undefined !== this._maskBuffer)\n            this._maskBuffer.collectStatistics(stats);\n        if (undefined !== this._classifierCombinedBuffer)\n            this._classifierCombinedBuffer.collectStatistics(stats);\n        if (undefined !== this._classifierAndMaskCombinedBuffer)\n            this._classifierAndMaskCombinedBuffer.collectStatistics(stats);\n    }\n    get isDisposed() { return undefined === this._classifierBuffers; }\n    dispose() {\n        this._classifierBuffers = dispose(this._classifierBuffers);\n        this._maskBuffer = dispose(this._maskBuffer);\n        this._classifierCombinedBuffer = dispose(this._classifierCombinedBuffer);\n        this._classifierAndMaskCombinedBuffer = dispose(this._classifierAndMaskCombinedBuffer);\n    }\n    get texture() {\n        switch (this._contentMode) {\n            case PlanarClassifierContent.None:\n                return undefined;\n            case PlanarClassifierContent.ClassifierOnly:\n                return this._classifierCombinedBuffer?.texture;\n            case PlanarClassifierContent.MaskOnly:\n                return this._maskBuffer?.texture;\n            case PlanarClassifierContent.ClassifierAndMask:\n                return this._classifierAndMaskCombinedBuffer?.texture;\n        }\n    }\n    getOrCreateClassifierTexture() {\n        if (undefined === this._classifierBuffers)\n            this._classifierBuffers = ClassifierFrameBuffers.create(this._width, this._height);\n        if (undefined !== this._classifierBuffers && undefined === this._classifierCombinedBuffer)\n            this._classifierCombinedBuffer = ClassifierCombinationBuffer.create(this._width, this._height, this._classifierBuffers.textures.color, this._classifierBuffers.textures.feature);\n        return this._classifierCombinedBuffer?.texture;\n    }\n    pushBatches(batchState, graphics) {\n        graphics.forEach((graphic) => {\n            if (graphic instanceof Batch) {\n                batchState.push(graphic, true);\n                batchState.pop();\n            }\n            else if (graphic instanceof Branch) {\n                this.pushBatches(batchState, graphic.branch.entries);\n            }\n        });\n    }\n    get sourceTransparency() {\n        return this._classifierTreeRef?.transparency;\n    }\n    pushBatchState(batchState) {\n        this._baseBatchId = batchState.nextBatchId - 1;\n        if (undefined !== this._classifierGraphics)\n            this.pushBatches(batchState, this._classifierGraphics);\n    }\n    setSource(classifierTreeRef, planarClipMask) {\n        this._classifierTreeRef = classifierTreeRef;\n        this._classifier = classifierTreeRef?.activeClassifier;\n        this._planarClipMask = planarClipMask;\n    }\n    collectGraphics(context, target) {\n        this._classifierGraphics.length = this._maskGraphics.length = 0;\n        if (undefined === context.viewingSpace)\n            return;\n        const viewState = context.viewingSpace.view;\n        if (undefined === viewState)\n            return;\n        const requiredHeight = context.target.viewRect.height;\n        const requiredWidth = context.target.viewRect.width;\n        if (requiredWidth !== this._width || requiredHeight !== this._height)\n            this.dispose();\n        this._width = requiredWidth;\n        this._height = requiredHeight;\n        const maskTrees = this._planarClipMask?.getTileTrees(viewState, target.modelId);\n        if (!maskTrees && !this._classifierTreeRef)\n            return;\n        const allTrees = maskTrees ? maskTrees.slice() : new Array();\n        if (this._classifierTreeRef)\n            allTrees.push(this._classifierTreeRef);\n        const projection = PlanarTextureProjection.computePlanarTextureProjection(this._plane, context, target, allTrees, viewState, this._width, this._height);\n        if (!projection.textureFrustum || !projection.projectionMatrix || !projection.worldToViewMap)\n            return;\n        this._projectionMatrix = projection.projectionMatrix;\n        this._frustum = projection.textureFrustum;\n        this._debugFrustum = projection.debugFrustum;\n        this._planarClipMaskOverrides = this._planarClipMask?.getPlanarClipMaskSymbologyOverrides();\n        const drawTree = (treeRef, graphics) => {\n            this._graphics = graphics;\n            const frustumPlanes = this._frustum ? FrustumPlanes.fromFrustum(this._frustum) : FrustumPlanes.createEmpty();\n            const drawArgs = GraphicsCollectorDrawArgs.create(context, this, treeRef, frustumPlanes, projection.worldToViewMap);\n            if (undefined !== drawArgs)\n                treeRef.draw(drawArgs);\n            this._graphics = undefined;\n        };\n        if (this._classifierTreeRef)\n            drawTree(this._classifierTreeRef, this._classifierGraphics);\n        if (maskTrees)\n            maskTrees.forEach((maskTree) => drawTree(maskTree, this._maskGraphics));\n        // Shader behaves slightly differently when classifying surfaces vs point clouds.\n        this._isClassifyingPointCloud = target.isPointCloud;\n        if (this._doDebugFrustum) {\n            this._debugFrustumGraphic = dispose(this._debugFrustumGraphic);\n            const builder = context.createSceneGraphicBuilder();\n            builder.setSymbology(ColorDef.green, ColorDef.green, 1);\n            builder.addFrustum(context.viewingSpace.getFrustum());\n            builder.setSymbology(ColorDef.red, ColorDef.red, 1);\n            builder.addFrustum(this._debugFrustum);\n            builder.setSymbology(ColorDef.white, ColorDef.white, 1);\n            builder.addFrustum(this._frustum);\n            this._debugFrustumGraphic = builder.finish();\n        }\n    }\n    draw(target) {\n        if (undefined === this._frustum)\n            return;\n        this._contentMode = PlanarClassifierContent.None;\n        let combinationBuffer;\n        if (this._classifierGraphics.length === 0) {\n            if (this._maskGraphics.length === 0) {\n                return;\n            }\n            else {\n                if (undefined === this._maskBuffer) {\n                    this._maskBuffer = MaskFrameBuffer.create(this._width, this._height);\n                    if (undefined === this._maskBuffer)\n                        return;\n                }\n                this._contentMode = PlanarClassifierContent.MaskOnly;\n            }\n        }\n        else {\n            if (undefined === this._classifierBuffers) {\n                this._classifierBuffers = ClassifierFrameBuffers.create(this._width, this._height);\n                if (undefined === this._classifierBuffers)\n                    return;\n            }\n            if (this._maskGraphics.length === 0) {\n                if (undefined === this._classifierCombinedBuffer) {\n                    combinationBuffer = this._classifierCombinedBuffer = ClassifierCombinationBuffer.create(this._width, this._height, this._classifierBuffers.textures.color, this._classifierBuffers.textures.feature);\n                    if (undefined === this._classifierCombinedBuffer)\n                        return;\n                }\n                this._contentMode = PlanarClassifierContent.ClassifierOnly;\n                combinationBuffer = this._classifierCombinedBuffer;\n            }\n            else {\n                if (undefined === this._maskBuffer) {\n                    this._maskBuffer = MaskFrameBuffer.create(this._width, this._height);\n                    if (undefined === this._maskBuffer)\n                        return;\n                }\n                if (undefined === this._classifierAndMaskCombinedBuffer) {\n                    combinationBuffer = this._classifierAndMaskCombinedBuffer = ClassifierAndMaskCombinationBuffer.create(this._width, this._height, this._classifierBuffers.textures.color, this._classifierBuffers.textures.feature, this._maskBuffer.texture);\n                    if (undefined === this._classifierAndMaskCombinedBuffer)\n                        return;\n                }\n                combinationBuffer = this._classifierAndMaskCombinedBuffer;\n                this._contentMode = PlanarClassifierContent.ClassifierAndMask;\n            }\n        }\n        if (undefined !== this._debugFrustumGraphic)\n            target.graphics.foreground.push(this._debugFrustumGraphic);\n        // Temporarily override the Target's state.\n        const system = System.instance;\n        const maskViewFlags = {\n            renderMode: RenderMode.SmoothShade,\n            wiremesh: false,\n            transparency: !this.isClassifyingPointCloud,\n            textures: false,\n            lighting: false,\n            shadows: false,\n            monochrome: false,\n            materials: false,\n            ambientOcclusion: false,\n            visibleEdges: false,\n            hiddenEdges: false,\n        };\n        const prevState = system.currentRenderState.clone(scratchPrevRenderState);\n        system.context.viewport(0, 0, this._width, this._height);\n        const vf = target.currentViewFlags.copy(this._classifierTreeRef ? this._classifierTreeRef.viewFlags : maskViewFlags);\n        system.applyRenderState(this._renderState);\n        const prevPlan = target.plan;\n        const prevOverrides = target.currentFeatureSymbologyOverrides;\n        target.uniforms.style.changeBackgroundColor(this._bgColor); // Avoid white on white reversal. Will be reset in changeRenderPlan below.\n        target.changeFrustum(this._frustum, this._frustum.getFraction(), true);\n        this._anyTranslucent = false;\n        const prevProjMatrix = target.uniforms.frustum.projectionMatrix;\n        target.uniforms.frustum.changeProjectionMatrix(PlanarClassifier._postProjectionMatrix.multiplyMatrixMatrix(prevProjMatrix));\n        target.uniforms.branch.changeRenderPlan(vf, target.plan.is3d, target.plan.hline);\n        const renderCommands = this._renderCommands;\n        const getDrawCommands = (graphics) => {\n            this._batchState.reset();\n            renderCommands.reset(target, this._branchStack, this._batchState);\n            renderCommands.collectGraphicsForPlanarProjection(graphics);\n            // Draw the classifiers into our attachments.\n            // When using Display.ElementColor, the color and transparency come from the classifier geometry. Therefore we may need to draw the classified geometry\n            // in a different pass - or both passes - depending on the transparency of the classifiers.\n            // NB: \"Outside\" geometry by definition cannot take color/transparency from element...\n            const cmds = renderCommands.getCommands(3 /* RenderPass.OpaquePlanar */);\n            // NB: We don't strictly require the classifier geometry to be planar, and sometimes (e.g., \"planar\" polyface/bspsurf) we do not detect planarity.\n            cmds.push(...renderCommands.getCommands(5 /* RenderPass.OpaqueGeneral */));\n            cmds.push(...renderCommands.getCommands(2 /* RenderPass.OpaqueLinear */));\n            this._anyOpaque = cmds.length > 0;\n            const transCmds = renderCommands.getCommands(8 /* RenderPass.Translucent */);\n            if (transCmds.length > 0) {\n                cmds.push(...transCmds);\n                this._anyTranslucent = true;\n            }\n            return cmds;\n        };\n        if (this._classifierGraphics.length > 0 && this._classifierBuffers) {\n            this._classifierBuffers.draw(getDrawCommands(this._classifierGraphics), target);\n            // Draw any hilited classifiers.\n            const hiliteCommands = renderCommands.getCommands(10 /* RenderPass.Hilite */);\n            this._anyHilited = 0 !== hiliteCommands.length;\n            if (this._anyHilited)\n                this._classifierBuffers.drawHilite(hiliteCommands, target);\n        }\n        if (this._maskGraphics.length > 0 && this._maskBuffer) {\n            if (this._planarClipMaskOverrides)\n                target.overrideFeatureSymbology(this._planarClipMaskOverrides);\n            if (this._planarClipMask && this._planarClipMask.settings.transparency !== undefined && this._planarClipMask.settings.transparency > 0.0)\n                this._anyTranslucent = true;\n            this._maskBuffer.draw(getDrawCommands(this._maskGraphics), target);\n        }\n        if (combinationBuffer)\n            combinationBuffer.compose(target);\n        this._batchState.reset();\n        target.changeRenderPlan(prevPlan);\n        target.overrideFeatureSymbology(prevOverrides);\n        system.applyRenderState(prevState);\n        system.context.viewport(0, 0, target.viewRect.width, target.viewRect.height);\n    }\n}\nPlanarClassifier._postProjectionMatrix = Matrix4d.createRowValues(0, 1, 0, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 0, 0, 1);\nexport { PlanarClassifier };\n//# sourceMappingURL=PlanarClassifier.js.map",
      "start": 1693508121151,
      "end": 1693508121387,
      "sourcemaps": null
    }
  ]
}
