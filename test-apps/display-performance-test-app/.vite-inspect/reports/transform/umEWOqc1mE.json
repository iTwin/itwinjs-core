{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/primitives/mesh/MeshBuilder.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Rendering\n */\nimport { assert, Dictionary } from \"@itwin/core-bentley\";\nimport { Angle, Point3d, Vector3d } from \"@itwin/core-geometry\";\nimport { MeshEdge, MeshEdges, MeshPolyline, OctEncodedNormal, OctEncodedNormalPair, QPoint3dList } from \"@itwin/core-common\";\nimport { Triangle, TriangleSet } from \"../Primitives\";\nimport { VertexMap } from \"../VertexKey\";\nimport { Mesh } from \"./MeshPrimitives\";\n/** @internal */\nexport class MeshBuilder {\n    get currentPolyface() { return this._currentPolyface; }\n    get displayParams() { return this.mesh.displayParams; }\n    set displayParams(params) { this.mesh.displayParams = params; }\n    /** create reference for triangleSet on demand */\n    get triangleSet() {\n        if (undefined === this._triangleSet)\n            this._triangleSet = new TriangleSet();\n        return this._triangleSet;\n    }\n    constructor(mesh, tolerance, areaTolerance, tileRange) {\n        this.mesh = mesh;\n        this.tolerance = tolerance;\n        this.areaTolerance = areaTolerance;\n        this.tileRange = tileRange;\n        let vertexTolerance;\n        if (mesh.points instanceof QPoint3dList) {\n            const p0 = mesh.points.params.unquantize(0, 0, 0);\n            const p1 = mesh.points.params.unquantize(1, 1, 1);\n            vertexTolerance = p1.minus(p0, p0);\n        }\n        else {\n            vertexTolerance = { x: tolerance, y: tolerance, z: tolerance };\n        }\n        this.vertexMap = new VertexMap(vertexTolerance);\n    }\n    /** create a new MeshBuilder */\n    static create(props) {\n        const mesh = Mesh.create(props);\n        const { tolerance, areaTolerance, range } = props;\n        return new MeshBuilder(mesh, tolerance, areaTolerance, range);\n    }\n    /**\n     * iterate through each point list of the strokes primitive and either load the point string or polyline into builder\n     * @param strokes lists of stroke primitive point lists to iterate\n     * @param isDisjoint if true add point string, else add polyline\n     * @param fillColor\n     */\n    addStrokePointLists(strokes, isDisjoint, fillColor, feature) {\n        for (const strokePoints of strokes) {\n            if (isDisjoint)\n                this.addPointString(strokePoints.points, fillColor, feature);\n            else\n                this.addPolyline(strokePoints.points, fillColor, feature);\n        }\n    }\n    /**\n     * add data from polyface into mesh builder\n     * @param polyface the indexed polyface to iterate the facets of to load each facet's triangles' vertices\n     * @param props the properties required for this operation\n     */\n    addFromPolyface(polyface, props, feature) {\n        this.beginPolyface(polyface, props.edgeOptions);\n        const visitor = polyface.createVisitor();\n        while (visitor.moveToNextFacet()) {\n            this.addFromPolyfaceVisitor(visitor, props, feature);\n        }\n        this.endPolyface();\n    }\n    /**\n     * @param visitor the PolyfaceVisitor containing the face data to be added\n     * @param props the properties required for this operation:\n     */\n    addFromPolyfaceVisitor(visitor, options, feature) {\n        const { pointCount, normalCount, paramCount, requireNormals } = visitor;\n        const { includeParams, mappedTexture } = options;\n        const isDegenerate = requireNormals && normalCount < pointCount; // TFS#790263: Degenerate triangle - no normals.\n        // a triangle must have at least 3 points\n        if (pointCount < 3 || isDegenerate)\n            return;\n        const haveParam = includeParams && paramCount > 0;\n        const triangleCount = pointCount - 2;\n        assert(!includeParams || paramCount > 0);\n        assert(!haveParam || undefined !== mappedTexture);\n        // The face represented by this visitor should be convex (we request that in facet options) - so we do a simple fan triangulation.\n        const polyfaceVisitorOptions = { ...options, triangleCount, haveParam };\n        for (let triangleIndex = 0; triangleIndex < triangleCount; triangleIndex++) {\n            const triangle = this.createTriangle(triangleIndex, visitor, polyfaceVisitorOptions, feature);\n            if (undefined !== triangle)\n                this.addTriangle(triangle);\n        }\n    }\n    createTriangleVertices(triangleIndex, visitor, options, feature) {\n        const { point, requireNormals } = visitor;\n        const { fillColor, haveParam } = options;\n        // If we do not have UVParams stored on the IndexedPolyface, compute them now\n        let params;\n        if (haveParam && options.mappedTexture) {\n            assert(this.mesh.points.length === 0 || this.mesh.uvParams.length !== 0);\n            const mappedTexture = options.mappedTexture;\n            const transformToImodel = mappedTexture.params.textureMatrix.transform;\n            if (transformToImodel)\n                params = mappedTexture.computeUVParams(visitor, transformToImodel);\n            assert(params !== undefined);\n        }\n        const vertices = [];\n        for (let i = 0; i < 3; ++i) {\n            const vertexIndex = 0 === i ? 0 : triangleIndex + i;\n            const position = point.getPoint3dAtUncheckedPointIndex(vertexIndex);\n            const normal = requireNormals ? OctEncodedNormal.fromVector(visitor.getNormal(vertexIndex)) : undefined;\n            const uvParam = params ? params[vertexIndex] : undefined;\n            vertices[i] = { position, fillColor, normal, uvParam, sourceIndex: vertexIndex, feature };\n        }\n        // Previously we would add all 3 vertices to our map, then detect degenerate triangles in AddTriangle().\n        // This led to unused vertex data, and caused mismatch in # of vertices when recreating the MeshBuilder from the data in the tile cache.\n        // Detect beforehand instead.\n        if (this.vertexMap.arePositionsAlmostEqual(vertices[0], vertices[1])\n            || this.vertexMap.arePositionsAlmostEqual(vertices[0], vertices[2])\n            || this.vertexMap.arePositionsAlmostEqual(vertices[1], vertices[2]))\n            return undefined;\n        return vertices;\n    }\n    createTriangle(triangleIndex, visitor, options, feature) {\n        // generate vertex key properties for each of the three sides of the triangle\n        const vertices = this.createTriangleVertices(triangleIndex, visitor, options, feature);\n        // avoid creating degenerate triangles\n        if (undefined === vertices)\n            return undefined;\n        const { edgeVisible } = visitor;\n        const triangle = new Triangle();\n        triangle.setEdgeVisibility(0 === triangleIndex ? edgeVisible[0] : false, edgeVisible[triangleIndex + 1], triangleIndex === options.triangleCount - 1 ? edgeVisible[triangleIndex + 2] : false);\n        // set each triangle index to the index associated with the vertex key location in the vertex map\n        vertices.forEach((vertexProps, i) => {\n            let vertexKeyIndex;\n            if (visitor.auxData) {\n                // No deduplication with auxData (for now...)\n                vertexKeyIndex = this.mesh.addVertex(vertexProps);\n                this.mesh.addAuxChannels(visitor.auxData.channels, vertexProps.sourceIndex);\n            }\n            else {\n                vertexKeyIndex = this.addVertex(vertexProps);\n            }\n            triangle.indices[i] = vertexKeyIndex;\n            // if the current polyface exists, map the vertex key index to the visitor's client point index\n            if (this.currentPolyface !== undefined)\n                this.currentPolyface.vertexIndexMap.set(vertexKeyIndex, visitor.clientPointIndex(vertexProps.sourceIndex));\n        });\n        return triangle;\n    }\n    /** removed Feature for now */\n    addPolyline(points, fillColor, feature) {\n        const { mesh } = this;\n        const poly = new MeshPolyline();\n        for (const position of points)\n            poly.addIndex(this.addVertex({ position, fillColor, feature }));\n        mesh.addPolyline(poly);\n    }\n    /** removed Feature for now */\n    addPointString(points, fillColor, feature) {\n        const { mesh } = this;\n        const poly = new MeshPolyline();\n        for (const position of points)\n            poly.addIndex(this.addVertex({ position, fillColor, feature }));\n        mesh.addPolyline(poly);\n    }\n    beginPolyface(polyface, options) {\n        if (!options.generateNoEdges) {\n            const triangles = this.mesh.triangles;\n            this._currentPolyface = new MeshBuilderPolyface(polyface, options, triangles === undefined ? 0 : triangles.length);\n        }\n    }\n    endPolyface() {\n        const { currentPolyface, mesh } = this;\n        if (undefined === currentPolyface)\n            return;\n        this._currentPolyface = undefined;\n        buildMeshEdges(mesh, currentPolyface);\n    }\n    addVertex(vertex, addToMeshOnInsert = true) {\n        // if vertex key isn't duplicate, then also insert properties into mesh\n        const onInsert = (vk) => this.mesh.addVertex(vk);\n        return this.vertexMap.insertKey(vertex, addToMeshOnInsert ? onInsert : undefined);\n    }\n    addTriangle(triangle) {\n        // Attempt to avoid adding vertices originating from degenerate triangles before we get here.\n        // Removed assert and just return if degenerate at this point because uncommon cases (not worth testing for) can still occur.\n        if (triangle.isDegenerate)\n            return;\n        const onInsert = (_vk) => this.mesh.addTriangle(triangle);\n        this.triangleSet.insertKey(triangle, onInsert);\n    }\n}\n/** @internal */\nexport class MeshEdgeCreationOptions {\n    get generateAllEdges() { return this.type === MeshEdgeCreationOptions.Type.AllEdges; }\n    get generateNoEdges() { return this.type === MeshEdgeCreationOptions.Type.NoEdges; }\n    get generateCreaseEdges() { return 0 !== (this.type & MeshEdgeCreationOptions.Type.CreaseEdges); }\n    /** Create edge chains for polyfaces that do not already have them. */\n    get createEdgeChains() { return 0 !== (this.type & MeshEdgeCreationOptions.Type.CreateChains); }\n    constructor(type = MeshEdgeCreationOptions.Type.NoEdges) {\n        this.minCreaseAngle = 20.0 * Angle.radiansPerDegree;\n        this.type = type;\n    }\n}\n/** @internal */\n(function (MeshEdgeCreationOptions) {\n    let Type;\n    (function (Type) {\n        Type[Type[\"NoEdges\"] = 0] = \"NoEdges\";\n        Type[Type[\"CreaseEdges\"] = 2] = \"CreaseEdges\";\n        Type[Type[\"SmoothEdges\"] = 4] = \"SmoothEdges\";\n        Type[Type[\"CreateChains\"] = 8] = \"CreateChains\";\n        Type[Type[\"DefaultEdges\"] = 2] = \"DefaultEdges\";\n        Type[Type[\"AllEdges\"] = 6] = \"AllEdges\";\n    })(Type = MeshEdgeCreationOptions.Type || (MeshEdgeCreationOptions.Type = {}));\n})(MeshEdgeCreationOptions || (MeshEdgeCreationOptions = {}));\n/** @internal */\nexport class MeshBuilderPolyface {\n    constructor(polyface, edgeOptions, baseTriangleIndex) {\n        this.vertexIndexMap = new Map();\n        this.polyface = polyface;\n        this.edgeOptions = edgeOptions;\n        this.baseTriangleIndex = baseTriangleIndex;\n    }\n}\nclass EdgeInfo {\n    constructor(visible, faceIndex0, edge, point0, point1) {\n        this.visible = visible;\n        this.faceIndex0 = faceIndex0;\n        this.edge = edge;\n        this.point0 = point0;\n        this.point1 = point1;\n    }\n    addFace(visible, faceIndex) {\n        if (undefined === this.faceIndex1) {\n            this.visible ||= visible;\n            this.faceIndex1 = faceIndex;\n        }\n    }\n}\nfunction buildMeshEdges(mesh, polyface) {\n    if (!mesh.triangles)\n        return;\n    const edgeMap = new Dictionary((lhs, rhs) => lhs.compareTo(rhs));\n    const triangleNormals = [];\n    // We need to detect the edge pairs -- Can't do that from the Mesh indices as these are not shared - so we'll\n    // assume that the polyface indices are properly shared, this should be true as a seperate index array is used\n    // for Polyfaces.\n    const triangle = new Triangle();\n    const polyfacePoints = [new Point3d(), new Point3d(), new Point3d()];\n    const polyfaceIndices = [0, 0, 0];\n    for (let triangleIndex = polyface.baseTriangleIndex; triangleIndex < mesh.triangles.length; triangleIndex++) {\n        let indexNotFound = false;\n        mesh.triangles.getTriangle(triangleIndex, triangle);\n        for (let j = 0; j < 3; j++) {\n            const foundPolyfaceIndex = polyface.vertexIndexMap.get(triangle.indices[j]);\n            assert(undefined !== foundPolyfaceIndex);\n            if (undefined === foundPolyfaceIndex) {\n                indexNotFound = true;\n                continue;\n            }\n            polyfaceIndices[j] = foundPolyfaceIndex;\n            polyface.polyface.data.getPoint(foundPolyfaceIndex, polyfacePoints[j]);\n        }\n        if (indexNotFound)\n            continue;\n        for (let j = 0; j < 3; j++) {\n            const jNext = (j + 1) % 3;\n            const triangleNormalIndex = triangleNormals.length;\n            const meshEdge = new MeshEdge(triangle.indices[j], triangle.indices[jNext]);\n            const polyfaceEdge = new MeshEdge(polyfaceIndices[j], polyfaceIndices[jNext]);\n            const edgeInfo = new EdgeInfo(triangle.isEdgeVisible(j), triangleNormalIndex, meshEdge, polyfacePoints[j], polyfacePoints[jNext]);\n            const findOrInsert = edgeMap.findOrInsert(polyfaceEdge, edgeInfo);\n            if (!findOrInsert.inserted)\n                findOrInsert.value.addFace(edgeInfo.visible, triangleNormalIndex);\n        }\n        const normal = Vector3d.createCrossProductToPoints(polyfacePoints[0], polyfacePoints[1], polyfacePoints[2]);\n        normal.normalizeInPlace();\n        triangleNormals.push(normal);\n    }\n    // If there is no visibility indication in the mesh, infer from the mesh geometry.\n    if (!polyface.edgeOptions.generateAllEdges) {\n        const minEdgeDot = Math.cos(polyface.edgeOptions.minCreaseAngle);\n        for (const edgeInfo of edgeMap.values()) {\n            if (undefined !== edgeInfo.faceIndex1) {\n                const normal0 = triangleNormals[edgeInfo.faceIndex0];\n                const normal1 = triangleNormals[edgeInfo.faceIndex1];\n                if (Math.abs(normal0.dotProduct(normal1)) > minEdgeDot)\n                    edgeInfo.visible = false;\n            }\n        }\n    }\n    // Now populate the MeshEdges.\n    // ###TODO edge chains?\n    if (undefined === mesh.edges)\n        mesh.edges = new MeshEdges();\n    const maxPlanarDot = 0.999999;\n    for (const edgeInfo of edgeMap.values()) {\n        if (edgeInfo.visible) {\n            mesh.edges.visible.push(edgeInfo.edge);\n        }\n        else if (undefined !== edgeInfo.faceIndex1) {\n            const normal0 = triangleNormals[edgeInfo.faceIndex0];\n            const normal1 = triangleNormals[edgeInfo.faceIndex1];\n            if (Math.abs(normal0.dotProduct(normal1)) < maxPlanarDot) {\n                mesh.edges.silhouette.push(edgeInfo.edge);\n                mesh.edges.silhouetteNormals.push(new OctEncodedNormalPair(OctEncodedNormal.fromVector(normal0), OctEncodedNormal.fromVector(normal1)));\n            }\n        }\n    }\n}\n//# sourceMappingURL=MeshBuilder.js.map",
      "start": 1693508119688,
      "end": 1693508119784,
      "sourcemaps": null
    }
  ]
}
