{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/geometry3d/Ray3d.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module CartesianGeometry\n */\nimport { CurveCurveApproachType, CurveLocationDetail, CurveLocationDetailPair } from \"../curve/CurveLocationDetail\";\nimport { AxisOrder, Geometry } from \"../Geometry\";\nimport { SmallSystem } from \"../numerics/Polynomials\";\nimport { Matrix3d } from \"./Matrix3d\";\nimport { Vector2d } from \"./Point2dVector2d\";\nimport { Point3d, Vector3d } from \"./Point3dVector3d\";\nimport { Range1d } from \"./Range\";\nimport { Transform } from \"./Transform\";\n// cspell:word Cramer\n/**\n * A Ray3d contains\n * * an `origin` point.\n * * a `direction` vector (The vector is not required to be normalized).\n * * an optional weight (number).\n * @public\n */\nexport class Ray3d {\n    // constructor (captures references)\n    constructor(origin, direction) {\n        this.origin = origin;\n        this.direction = direction;\n        this.a = undefined;\n    }\n    static _create(x, y, z, u, v, w) {\n        return new Ray3d(Point3d.create(x, y, z), Vector3d.create(u, v, w));\n    }\n    /** Create a ray on the x axis. */\n    static createXAxis() {\n        return Ray3d._create(0, 0, 0, 1, 0, 0);\n    }\n    /** Create a ray on the y axis. */\n    static createYAxis() {\n        return Ray3d._create(0, 0, 0, 0, 1, 0);\n    }\n    /** Create a ray on the z axis. */\n    static createZAxis() {\n        return Ray3d._create(0, 0, 0, 0, 0, 1);\n    }\n    /** Create a ray with all zeros. */\n    static createZero(result) {\n        if (result) {\n            result.origin.setZero();\n            result.direction.setZero();\n            return result;\n        }\n        return new Ray3d(Point3d.createZero(), Vector3d.createZero());\n    }\n    /**\n     * Test for nearly equal Ray3d objects.\n     * * This tests for near equality of origin and direction -- i.e. member-by-member comparison.\n     * * Use [[isAlmostEqualPointSet]] to allow origins to be anywhere along the common ray and to have to allow the\n     * directions to be scaled or opposing.\n     */\n    isAlmostEqual(other) {\n        return this.origin.isAlmostEqual(other.origin) && this.direction.isAlmostEqual(other.direction);\n    }\n    /**\n     * Return the dot product of the ray's direction vector with a vector from the ray origin\n     * to the `spacePoint`.\n     * * If the instance is the unit normal of a plane, then this method returns the (signed) altitude\n     * of `spacePoint` with respect to the plane.\n     * * Visualization can be found at https://www.itwinjs.org/sandbox/SaeedTorabi/ProjectVectorOnPlane\n     */\n    dotProductToPoint(spacePoint) {\n        return this.direction.dotProductStartEnd(this.origin, spacePoint);\n    }\n    /** Return the fractional coordinate (along the direction vector) of the `spacePoint` projected to the ray. */\n    pointToFraction(spacePoint) {\n        return Geometry.safeDivideFraction(this.dotProductToPoint(spacePoint), this.direction.magnitudeSquared(), 0);\n    }\n    /** Return the `spacePoint` projected onto the ray. */\n    projectPointToRay(spacePoint) {\n        /**\n         * To project a point to the ray, we can create a vector called \"v\" from ray origin to the spacePoint and project\n         * that vector to the ray direction vector \"r\". The projection is \"((v.r)/||r||^2) r\" where \"v.r\" is the dot\n         * product. Note that pointToFraction returns \"(v.r)/||r||^2\".\n         * Note: If r is the normal of a plane, then projection length \"(v.r)/||r||\" is the signed altitude of the\n         * spacePoint with respect to the plane.\n         */\n        return this.origin.plusScaled(this.direction, this.pointToFraction(spacePoint));\n    }\n    /**\n     * Test for nearly equal rays, allowing origin float and direction scaling.\n     * * Use [[isAlmostEqual]] to require member-by-member comparison.\n     */\n    isAlmostEqualPointSet(other) {\n        /**\n         * This function tests two rays to determine if they define the same infinite lines.\n         * So the origins can be different as long as they are on the infinite line (they can\n         * \"float\") but the directions must be parallel or antiparallel.\n         */\n        if (!this.direction.isParallelTo(other.direction, true))\n            return false;\n        /**\n         * In exact math, we consider a ray to have an infinite line as direction (not a finite vector).\n         * Therefore, in exact math it is not possible for one origin to be on the other ray but not vice\n         * versa. However, we test both ways because first check may pass due to round-off errors.\n         */\n        let workPoint = this.projectPointToRay(other.origin);\n        if (!other.origin.isAlmostEqualMetric(workPoint))\n            return false;\n        workPoint = other.projectPointToRay(this.origin);\n        if (!this.origin.isAlmostEqualMetric(workPoint))\n            return false;\n        return true;\n    }\n    /** Create a ray from origin and direction. */\n    static create(origin, direction, result) {\n        if (result) {\n            result.set(origin, direction);\n            return result;\n        }\n        return new Ray3d(origin.clone(), direction.clone());\n    }\n    /**\n     * Given a homogeneous point and its derivative components, construct a Ray3d with cartesian\n     * coordinates and derivatives.\n     * @param weightedPoint `[x,y,z,w]` parts of weighted point.\n     * @param weightedDerivative `[x,y,z,w]` derivatives\n     * @param result\n     */\n    static createWeightedDerivative(weightedPoint, weightedDerivative, result) {\n        const w = weightedPoint[3];\n        const dw = weightedDerivative[3];\n        const x = weightedPoint[0];\n        const y = weightedPoint[1];\n        const z = weightedPoint[2];\n        const dx = weightedDerivative[0] * w - weightedPoint[0] * dw;\n        const dy = weightedDerivative[1] * w - weightedPoint[1] * dw;\n        const dz = weightedDerivative[2] * w - weightedPoint[2] * dw;\n        if (Geometry.isSmallMetricDistance(w))\n            return undefined;\n        const divW = 1.0 / w;\n        const divWW = divW * divW;\n        return Ray3d.createXYZUVW(x * divW, y * divW, z * divW, dx * divWW, dy * divWW, dz * divWW, result);\n    }\n    /** Create from coordinates of the origin and direction. */\n    static createXYZUVW(originX, originY, originZ, directionX, directionY, directionZ, result) {\n        if (result) {\n            result.getOriginRef().set(originX, originY, originZ);\n            result.getDirectionRef().set(directionX, directionY, directionZ);\n            return result;\n        }\n        return new Ray3d(Point3d.create(originX, originY, originZ), Vector3d.create(directionX, directionY, directionZ));\n    }\n    /** Capture origin and direction in a new Ray3d. */\n    static createCapture(origin, direction) {\n        return new Ray3d(origin, direction);\n    }\n    /** Create from (clones of) origin, direction, and numeric weight. */\n    static createPointVectorNumber(origin, direction, a, result) {\n        if (result) {\n            result.origin.setFrom(origin);\n            result.direction.setFrom(direction);\n            result.a = a;\n            return result;\n        }\n        result = new Ray3d(origin.clone(), direction.clone());\n        result.a = a;\n        return result;\n    }\n    /** Create from origin and target. The direction vector is the full length (non-unit) vector from origin to target. */\n    static createStartEnd(origin, target, result) {\n        if (result) {\n            result.origin.setFrom(origin);\n            result.direction.setStartEnd(origin, target);\n            return result;\n        }\n        return new Ray3d(origin.clone(), Vector3d.createStartEnd(origin, target));\n    }\n    /** Return a reference to the ray's origin. */\n    getOriginRef() {\n        return this.origin;\n    }\n    /** Return a reference to the ray's direction vector. */\n    getDirectionRef() {\n        return this.direction;\n    }\n    /** Copy coordinates from origin and direction. */\n    set(origin, direction) {\n        this.origin.setFrom(origin);\n        this.direction.setFrom(direction);\n    }\n    /** Clone the ray. */\n    clone(result) {\n        if (result) {\n            result.set(this.origin.clone(), this.direction.clone());\n            return result;\n        }\n        return new Ray3d(this.origin.clone(), this.direction.clone());\n    }\n    /** Return a clone of the transformed instance */\n    cloneTransformed(transform, result) {\n        return Ray3d.create(transform.multiplyPoint3d(this.origin, result?.origin), transform.multiplyVector(this.direction, result?.direction), result);\n    }\n    /** Create a clone and return the inverse transform of the clone. */\n    cloneInverseTransformed(transform, result) {\n        if (!transform.computeCachedInverse(true))\n            return undefined;\n        return Ray3d.create(transform.multiplyInversePoint3d(this.origin, result?.origin), transform.matrix.multiplyInverseXYZAsVector3d(this.direction.x, this.direction.y, this.direction.z, result?.direction), result);\n    }\n    /** Apply a transform in place. */\n    transformInPlace(transform) {\n        transform.multiplyPoint3d(this.origin, this.origin);\n        transform.multiplyVector(this.direction, this.direction);\n    }\n    /** Copy data from another ray. */\n    setFrom(source) {\n        this.set(source.origin, source.direction);\n    }\n    /**\n     * Return a point at fractional position along the ray.\n     * * fraction 0 is the ray origin.\n     * * fraction 1 is at the end of the direction vector when placed at the origin.\n     */\n    fractionToPoint(fraction, result) {\n        return this.origin.plusScaled(this.direction, fraction, result);\n    }\n    /**\n     * Return a transform for rigid axes at ray origin with z in ray direction.\n     * * If the direction vector is zero, axes default to identity (from [[Matrix3d.createRigidHeadsUp]])\n     */\n    toRigidZFrame(result) {\n        const axes = Ray3d._workMatrix = Matrix3d.createRigidHeadsUp(this.direction, AxisOrder.ZXY, Ray3d._workMatrix);\n        return Transform.createOriginAndMatrix(this.origin, axes, result);\n    }\n    /** Convert {origin:[x,y,z], direction:[u,v,w]} to a Ray3d. */\n    setFromJSON(json) {\n        if (!json) {\n            this.origin.set(0, 0, 0);\n            this.direction.set(0, 0, 1);\n            return;\n        }\n        this.origin.setFromJSON(json.origin);\n        this.direction.setFromJSON(json.direction);\n    }\n    /**\n     * Construct a JSON object from this Ray3d.\n     * @return {*} [origin,normal]\n     */\n    toJSON() {\n        return { origin: this.origin.toJSON(), direction: this.direction.toJSON() };\n    }\n    /** Create a new ray from json object. See `setFromJSON` for json structure; */\n    static fromJSON(json) {\n        const result = Ray3d.createXAxis();\n        result.setFromJSON(json);\n        return result;\n    }\n    /**\n     * Try to scale the direction vector to a given `magnitude`.\n     * * Returns `false` if the ray direction is a zero vector.\n     */\n    trySetDirectionMagnitudeInPlace(magnitude = 1.0) {\n        if (this.direction.tryNormalizeInPlace()) {\n            this.direction.scaleInPlace(magnitude);\n            return true;\n        }\n        this.direction.setZero();\n        this.a = 0.0;\n        return false;\n    }\n    /**\n     * Normalize the ray direction in place.\n     * * If parameter `a` is clearly nonzero and the direction vector can be normalized,\n     *    * Save the parameter `a` as the optional `a` member of the ray.\n     *    * Normalize the ray's direction vector.\n     * * If parameter `a` is nearly zero,\n     *    * Set the `a` member to zero.\n     *    * Set the ray's direction vector to zero.\n     * @param a value to be saved (e.g,. area).\n     * @returns `true` if `a` is nonzero and normalization was successful. Otherwise, return `false`.\n     */\n    tryNormalizeInPlaceWithAreaWeight(a) {\n        const tolerance = Geometry.smallMetricDistanceSquared;\n        this.a = a;\n        if (Math.abs(a) > tolerance && this.direction.tryNormalizeInPlace(tolerance))\n            return true;\n        this.direction.setZero();\n        this.a = 0.0;\n        return false;\n    }\n    /** Return distance from the ray to point in space. */\n    distance(spacePoint) {\n        const uu = this.direction.magnitudeSquared();\n        const uv = this.dotProductToPoint(spacePoint);\n        const aa = Geometry.inverseMetricDistanceSquared(uu);\n        if (aa)\n            return Math.sqrt(this.origin.distanceSquared(spacePoint) - uv * uv * aa);\n        else\n            return Math.sqrt(this.origin.distanceSquared(spacePoint));\n    }\n    /**\n     * Return the intersection parameter of the line defined by the ray with a `plane`.\n     * * Stores the point of intersection in the `result` point (if passed as a parameter) and returns the parameter\n     * along the ray where the intersection occurs. If we call the parameter 'f' then the point of intersection would\n     * be `ray.origin + f * ray.direction`. Therefore:\n     *    * if ray intersects the plane at its origin, the function returns f = 0.\n     *    * if intersects at `ray.origin + ray.direction`, the function returns f = 1.\n     *    * if intersects behind the ray origin, the function returns f < 0.\n     *    * if intersects after `ray.origin + ray.direction`, the function returns f > 1.\n     * * Returns `undefined` if the ray and plane are parallel or coplanar.\n     */\n    intersectionWithPlane(plane, result) {\n        const vectorA = Vector3d.createStartEnd(plane.getOriginRef(), this.origin);\n        const uDotN = this.direction.dotProduct(plane.getNormalRef());\n        const nDotN = this.direction.magnitudeSquared();\n        const aDotN = vectorA.dotProduct(plane.getNormalRef());\n        const division = Geometry.conditionalDivideFraction(-aDotN, uDotN);\n        if (undefined === division)\n            return undefined;\n        const division1 = Geometry.conditionalDivideFraction(nDotN, uDotN);\n        if (undefined === division1)\n            return undefined;\n        if (result) {\n            this.origin.plusScaled(this.direction, division, result);\n        }\n        return division;\n    }\n    /**\n     * Find the intersection of the line defined by the ray with a Range3d.\n     * * Return the range of parameters (on the ray) which are \"inside\" the range.\n     * * Note that a range is always returned; if there is no intersection it is indicated by the test `result.isNull`.\n     */\n    intersectionWithRange3d(range, result) {\n        if (range.isNull)\n            return Range1d.createNull(result);\n        const interval = Range1d.createXX(-Geometry.largeCoordinateResult, Geometry.largeCoordinateResult, result);\n        if (interval.clipLinearMapToInterval(this.origin.x, this.direction.x, range.low.x, range.high.x)\n            && interval.clipLinearMapToInterval(this.origin.y, this.direction.y, range.low.y, range.high.y)\n            && interval.clipLinearMapToInterval(this.origin.z, this.direction.z, range.low.z, range.high.z))\n            return interval;\n        return interval;\n    }\n    /**\n     * Compute the intersection of the ray with a triangle.\n     * * This method is faster than `BarycentricTriangle.intersectRay3d`.\n     * @param vertex0 first vertex of the triangle\n     * @param vertex1 second vertex of the triangle\n     * @param vertex2 third vertex of the triangle\n     * @param distanceTol optional tolerance used to check if ray is parallel to the triangle or if we have line\n     * intersection but not ray intersection (if tolerance is not provided, Geometry.smallMetricDistance is used)\n     * @param parameterTol optional tolerance used to snap barycentric coordinates of the intersection point to\n     * a triangle edge or vertex (if tolerance is not provided, Geometry.smallFloatingPoint is used)\n     * @param result optional pre-allocated object to fill and return\n     * @returns the intersection point if ray intersects the triangle. Otherwise, return undefined.\n    */\n    intersectionWithTriangle(vertex0, vertex1, vertex2, distanceTol, parameterTol, result) {\n        /**\n         * Suppose ray is shown by \"rayOrigin + t*rayVector\" and barycentric coordinate of point\n         * P = w*v0 + u*v1 + v*v2 = (1-u-v)*v0 + u*v1 + v*v2 = v0 + u*(v1-v0) + v*(v2-v0)\n         *\n         * Then if ray intersects triangle at a point we have\n         * v0 + u*(v1-v0) + v*(v2-v0) = rayOrigin + t*rayVector\n         * or\n         * -t*rayVector + u*(v1-v0) + v*(v2-v0) = rayOrigin - v0\n         *\n         * This equation can be reformulated as the following linear system:\n         *\n         * [    |          |      |  ] [t]   [      |       ]\n         * [-rayVector  v1-v0   v2-v0] [u] = [rayOrigin - v0]\n         * [   |          |      |   ] [v]   [      |       ]\n         *\n         * Then to find t, u, and v use Cramer's Rule and also the fact that if matrix A = [c1,c2,c3], then\n         * det(A) = c1.(c2 x c3) which leads to\n         *\n         * t = [(rayOrigin - v0).((v1-v0) x (v2-v0))] / [-rayVector.((v1-v0) x (v2-v0))]\n         * u = [-rayVector.((rayOrigin - v0) x (v2-v0))] / [-rayVector.((v1-v0) x (v2-v0))]\n         * v = [-rayVector.((v1-v0) x (rayOrigin - v0))] / [-rayVector.((v1-v0) x (v2-v0))]\n         *\n         * Now note that swapping any 2 vectors c_i and c_j in formula c1.(c2 x c3) negates it. For example:\n         * c1.(c2 x c3) = -c3.(c2 x c1) = c2.(c3 x c1)\n         *\n         * This leads to the final formulas used in the following code:\n         * t = [(v2-v0).((rayOrigin - v0) x (v1-v0))] / [(v1-v0).(rayVector x (v2-v0))]\n         * u = [(rayOrigin - v0).(rayVector x (v2-v0))] / [(v1-v0).(rayVector x (v2-v0))]\n         * v = [-rayVector.((rayOrigin - v0) x (v1-v0))] / [(v1-v0).(rayVector x (v2-v0))]\n         *\n         * Note that we should verify 0 <= u,v,w <= 1. To do so we only need to check 0 <= u <= 1, 0 <= v, and u+v <= 1.\n         * That's because w = 1-(u+v) and if we have those 4 checks, it's guaranteed that v <= 1 and 0 <= u+v and so\n         * 0 <= w <= 1.\n         *\n         * More info be found at\n         * https://en.wikipedia.org/wiki/M%C3%B6ller%E2%80%93Trumbore_intersection_algorithm\n         */\n        if (distanceTol === undefined || distanceTol < 0) // we explicitly allow zero tolerance\n            distanceTol = Geometry.smallMetricDistance;\n        if (parameterTol === undefined || parameterTol < 0) // we explicitly allow zero tolerance\n            parameterTol = Geometry.smallFloatingPoint;\n        const edge1 = Ray3d._workVector0 = Vector3d.createStartEnd(vertex0, vertex1, Ray3d._workVector0);\n        const edge2 = Ray3d._workVector1 = Vector3d.createStartEnd(vertex0, vertex2, Ray3d._workVector1);\n        const h = Ray3d._workVector2 = this.direction.crossProduct(edge2, Ray3d._workVector2);\n        const a = edge1.dotProduct(h);\n        if (a >= -distanceTol && a <= distanceTol)\n            return undefined; // ray is parallel to the triangle (includes coplanar case)\n        const f = 1.0 / a;\n        const s = Ray3d._workVector3 = Vector3d.createStartEnd(vertex0, this.origin, Ray3d._workVector3);\n        let u = f * s.dotProduct(h);\n        if (u < 0.0) {\n            if (u > -parameterTol)\n                u = 0.0;\n            else\n                return undefined; // ray does not intersect the triangle\n        }\n        else if (u > 1.0) {\n            if (u < 1.0 + parameterTol)\n                u = 1.0;\n            else\n                return undefined; // ray does not intersect the triangle\n        }\n        const q = Ray3d._workVector4 = s.crossProduct(edge1, Ray3d._workVector4);\n        let v = f * this.direction.dotProduct(q);\n        if (v < 0.0) {\n            if (v > -parameterTol)\n                v = 0.0;\n            else\n                return undefined; // ray does not intersect the triangle\n        }\n        else if (u + v > 1.0) {\n            if (u + v < 1.0 + parameterTol)\n                v = 1.0 - u;\n            else\n                return undefined; // ray does not intersect the triangle\n        }\n        // at this stage, we know the line (parameterized as the ray) intersects the triangle\n        const t = f * edge2.dotProduct(q);\n        if (t <= distanceTol) // line intersection but not ray intersection\n            return undefined;\n        return this.origin.plusScaled(this.direction, t, result); // ray intersection\n    }\n    /**\n     * Return the shortest vector `v` to `targetPoint` from the line defined by this ray.\n     * * If the projection of `targetPoint` onto the line defined by this ray is q, then `v  = targetPoint - q`.\n     */\n    perpendicularPartOfVectorToTarget(targetPoint, result) {\n        const vectorV = Vector3d.createStartEnd(this.origin, targetPoint);\n        const uu = this.direction.magnitudeSquared();\n        const uv = this.direction.dotProductStartEnd(this.origin, targetPoint);\n        const fraction = Geometry.safeDivideFraction(uv, uu, 0.0);\n        return vectorV.plusScaled(this.direction, -fraction, result);\n    }\n    /**\n     * Determine if two rays intersect, or are fully overlapped, or parallel but not coincident, or skew.\n     * * Return a CurveLocationDetailPair which contains fraction and point on each ray and has\n     * annotation (in member `approachType`) indicating one of these relationships:\n     *   * CurveCurveApproachType.Intersection -- the rays have a simple intersection, at fractions indicated\n     * in detailA and detailB\n     *   * CurveCurveApproachType.PerpendicularChord -- there is pair of where the rays have closest approach.\n     * The rays are skew in space.\n     *   * CurveCurveApproachType.CoincidentGeometry -- the rays are the same unbounded line in space. The\n     * fractions and points are a representative single common point.\n     *   * CurveCurveApproachType.Parallel -- the rays are parallel (and not coincident). The two points are\n     * at the minimum distance\n     */\n    static closestApproachRay3dRay3d(rayA, rayB) {\n        const intersectionFractions = Vector2d.create();\n        let fractionA, fractionB;\n        let pointA, pointB;\n        let pairType;\n        if (SmallSystem.ray3dXYZUVWClosestApproachUnbounded(rayA.origin.x, rayA.origin.y, rayA.origin.z, rayA.direction.x, rayA.direction.y, rayA.direction.z, rayB.origin.x, rayB.origin.y, rayB.origin.z, rayB.direction.x, rayB.direction.y, rayB.direction.z, intersectionFractions)) {\n            fractionA = intersectionFractions.x;\n            fractionB = intersectionFractions.y;\n            pointA = rayA.fractionToPoint(fractionA);\n            pointB = rayB.fractionToPoint(fractionB);\n            pairType = pointA.isAlmostEqualMetric(pointB) ?\n                CurveCurveApproachType.Intersection : CurveCurveApproachType.PerpendicularChord;\n        }\n        else {\n            fractionB = 0.0;\n            fractionA = rayA.pointToFraction(rayB.origin);\n            pointA = rayA.fractionToPoint(fractionA);\n            pointB = rayB.fractionToPoint(fractionB);\n            pairType = pointA.isAlmostEqualMetric(pointB) ?\n                CurveCurveApproachType.CoincidentGeometry : CurveCurveApproachType.ParallelGeometry;\n        }\n        const pair = CurveLocationDetailPair.createCapture(CurveLocationDetail.createRayFractionPoint(rayA, fractionA, rayA.fractionToPoint(fractionA)), CurveLocationDetail.createRayFractionPoint(rayB, fractionB, rayB.fractionToPoint(fractionB)));\n        pair.approachType = pairType;\n        return pair;\n    }\n    /**\n     * Return a ray with `ray.origin` interpolated between `pt1` and `pt2` at the given `fraction`\n     * and `ray.direction` set to the vector from `pt1` to `pt2` multiplied by the given `tangentScale`.\n     * @param pt1 start point of the interpolation.\n     * @param fraction fractional position between points.\n     * @param pt2 end point of the interpolation.\n     * @param tangentScale scale factor to apply to the startToEnd vector.\n     * @param result optional receiver.\n     */\n    static interpolatePointAndTangent(pt1, fraction, pt2, tangentScale, result) {\n        result = result ?? Ray3d.createZero();\n        const dx = pt2.x - pt1.x;\n        const dy = pt2.y - pt1.y;\n        const dz = pt2.z - pt1.z;\n        result.direction.set(tangentScale * dx, tangentScale * dy, tangentScale * dz);\n        if (fraction <= 0.5)\n            result.origin.set(pt1.x + fraction * dx, pt1.y + fraction * dy, pt1.z + fraction * dz);\n        else {\n            const t = fraction - 1.0;\n            result.origin.set(pt2.x + t * dx, pt2.y + t * dy, pt2.z + t * dz);\n        }\n        return result;\n    }\n}\n//# sourceMappingURL=Ray3d.js.map",
      "start": 1693508122408,
      "end": 1693508122585,
      "sourcemaps": null
    }
  ]
}
