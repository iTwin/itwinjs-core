{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/orbitgt/lib/esm/spatial/ecrs/Ellipsoid.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module OrbitGT\n */\nimport { Registry } from \"./Registry\";\nimport { Unit } from \"./Unit\";\n/**\n * Class Ellipsoid defines the parameters of an earth ellipsoid.\n *\n * Based on the following document:\n *\n * Coordinate Conversions and Transformations including Formulas\n * Guidance Note Number 7, part 2\n * Revised May 2005\n * Available at: http://www.epsg.org/\n *\n * Geocentric coordinates are defined as follows:\n * The point (0,0,0) denotes the center of the ellipsoid. The z-axis is defined as being parallel to the earth rotational axis, pointing towards north.\n * The x-axis intersects the ellipsoid at the 0 deg latitude, 0 deg longitude point.\n *\n * @version 1.0 July 2005\n */\n/** @internal */\nexport class Ellipsoid {\n    /**\n     * Create a new ellipsoid.\n     * @param code the code.\n     * @param name the name.\n     * @param unitCode the code of the unit of measure.\n     * @param a the semi-major axis.\n     * @param invF the inverse flattening (value like 300, not like 1/300).\n     * @param b the semi-minor axis.\n     */\n    constructor(code, name, unitCode, a, invF, b) {\n        /* Store parameters */\n        this._code = code;\n        this._name = name;\n        this._unitCode = unitCode;\n        this._a = (unitCode == Unit.METER) ? a : Registry.getUnit(this._unitCode).toStandard(a);\n        this._invF = invF;\n        this._b = (unitCode == Unit.METER) ? b : Registry.getUnit(this._unitCode).toStandard(b);\n        /* Derive parameters */\n        if (this._invF == 0.0)\n            this._invF = a / (a - b);\n        this._f = (1.0 / this._invF);\n        if (this._b == 0.0)\n            this._b = this._a * (1.0 - this._f);\n        this._e = Math.sqrt(2.0 * this._f - this._f * this._f);\n        this._e2 = this._e * this._e; // or = (a*a-b*b)/(a*a);\n    }\n    /**\n     * Get the code.\n     * @return the code.\n     */\n    getCode() {\n        return this._code;\n    }\n    /**\n     * Get the name.\n     * @return the name.\n     */\n    getName() {\n        return this._name;\n    }\n    /**\n     * Get the code of the unit of measure.\n     * @return the code of the unit of measure.\n     */\n    getUnitCode() {\n        return this._unitCode;\n    }\n    /**\n     * Get the semi-major axis (in meter).\n     * @return the semi-major axis.\n     */\n    getA() {\n        return this._a;\n    }\n    /**\n     * Get the semi-minor axis (in meter).\n     * @return the semi-minor axis.\n     */\n    getB() {\n        return this._b;\n    }\n    /**\n     * Get the flattening.\n     * @return the flattening.\n     */\n    getF() {\n        return this._f;\n    }\n    /**\n     * Get the inverse flattening.\n     * @return the inverse flattening.\n     */\n    getInvF() {\n        return this._invF;\n    }\n    /**\n     * Get the eccentricity.\n     * @return the eccentricity.\n     */\n    getE() {\n        return this._e;\n    }\n    /**\n     * Get the radius of curvature of the ellipsoid in the plane of the meridian at a given latitude (how latitude curves).\n     * @param lat the latitude (in radians).\n     * @return a radius (in meter).\n     */\n    getMeridianRadius(lat) {\n        // Formula: see http://en.wikipedia.org/wiki/Latitude\n        let t = this._e * Math.sin(lat);\n        return this._a * (1.0 - this._e2) / Math.pow(1.0 - t * t, 3.5);\n    }\n    /**\n     * Get the radius of the circle defined by all points at a certain latitude (a circle of latitude, also called a parallel) (a at latitude 0, 0 at latitude 90) (how longitude curves).\n     * @param lat the latitude (in radians).\n     * @return a radius (in meter).\n     */\n    getParallelRadius(lat) {\n        // Formula: see http://en.wikipedia.org/wiki/Longitude\n        let t = this._e * Math.sin(lat);\n        return this._a * Math.cos(lat) / Math.sqrt(1.0 - t * t);\n    }\n    /**\n     * Get the radius of curvature of the ellipsoid perpendicular to the meridian at a given latitude (a at latitude 0, a*a/b at latitude 90).\n     * @param lat the latitude (in radians).\n     * @return a radius (in meter).\n     */\n    getPrimeVerticalRadius(lat) {\n        let t = this._e * Math.sin(lat);\n        return this._a / Math.sqrt(1.0 - t * t);\n    }\n    /**\n     * Get the radius of curvature of the ellipsoid perpendicular to the meridian at a given latitude (a at latitude 0, a*a/b at latitude 90).\n     * @param lat the latitude (in radians).\n     * @param sinLat the sinus of the latitude.\n     * @return a radius (in meter).\n     */\n    getPrimeVerticalRadius2(lat, sinLat) {\n        let t = this._e * sinLat;\n        return this._a / Math.sqrt(1.0 - t * t);\n    }\n    /**\n     * Get the number of meter per radian of longitude.\n     * @param lat the latitude (in radians).\n     * @return the number of meter per radian.\n     */\n    getMeterPerRadOfLon(lat) {\n        return this.getParallelRadius(lat);\n    }\n    /**\n     * Get the number of meter per degree of longitude.\n     * @param lat the latitude (in radians).\n     * @return the number of meter per degree.\n     */\n    getMeterPerDegreeOfLon(lat) {\n        return this.getMeterPerRadOfLon(lat) * Math.PI / 180.0;\n    }\n    /**\n     * Get the number of meter per radian of latitude.\n     * @param lat the latitude (in radians).\n     * @return the number of meter per radian.\n     */\n    getMeterPerRadOfLat(lat) {\n        return this.getMeridianRadius(lat);\n    }\n    /**\n     * Get the number of meter per degree of latitude.\n     * @param lat the latitude (in radians).\n     * @return the number of meter per degree.\n     */\n    getMeterPerDegreeOfLat(lat) {\n        return this.getMeterPerRadOfLat(lat) * Math.PI / 180.0;\n    }\n    /**\n     * Calculate the secant.\n     * @param v an angle (in radians).\n     * @return the secant.\n     */\n    static sec(v) {\n        return 1.0 / Math.cos(v);\n    }\n    /**\n     * Convert 3D geographic coordinates to 3D geocentric coordinates.\n     * See the EPSG Guidance Note, 2.2.1\n     * @param geographic the geographic coordinates (lon(x) and lat(y) in radians, height(z) in meter).\n     * @param geocentric the new geocentric coordinates (in meter) (the result object).\n     */\n    toGeoCentric(geographic, geocentric) {\n        /* Get the parameters */\n        let lon = geographic.getX();\n        let lat = geographic.getY();\n        let h = geographic.getZ();\n        /* Calculate */\n        let sinLat = Math.sin(lat);\n        let v = this.getPrimeVerticalRadius2(lat, sinLat);\n        let s = (v + h) * Math.cos(lat);\n        let x = s * Math.cos(lon);\n        let y = s * Math.sin(lon);\n        let z = ((1.0 - this._e2) * v + h) * sinLat;\n        /* Store the new coordinates */\n        geocentric.setX(x);\n        geocentric.setY(y);\n        geocentric.setZ(z);\n    }\n    /**\n     * Convert 3D geographic coordinates to 3D geocentric coordinates.\n     * See the EPSG Guidance Note, 2.2.1\n     * @param geographic the geographic coordinates (lon(x) and lat(y) in degrees, height(z) in meter).\n     * @param geocentric the new geocentric coordinates (in meter) (the result object).\n     */\n    toGeoCentricDeg(geographic, geocentric) {\n        /* Get the parameters */\n        let lon = geographic.getX() / 180.0 * Math.PI;\n        let lat = geographic.getY() / 180.0 * Math.PI;\n        let h = geographic.getZ();\n        /* Calculate */\n        let sinLat = Math.sin(lat);\n        let v = this.getPrimeVerticalRadius2(lat, sinLat);\n        let s = (v + h) * Math.cos(lat);\n        let x = s * Math.cos(lon);\n        let y = s * Math.sin(lon);\n        let z = ((1.0 - this._e2) * v + h) * sinLat;\n        /* Store the new coordinates */\n        geocentric.setX(x);\n        geocentric.setY(y);\n        geocentric.setZ(z);\n    }\n    /**\n     * Convert 3D geocentric coordinates to 3D geographic coordinates.\n     * See the EPSG Guidance Note, 2.2.1\n     * @param geocentric the geocentric coordinates (in meter).\n     * @param geographic the new geographic coordinates (lon(x) and lat(y) in radians, height(z) in meter) (the result object).\n     */\n    toGeoGraphic(geocentric, geographic) {\n        /* Get the parameters */\n        let x = geocentric.getX();\n        let y = geocentric.getY();\n        let z = geocentric.getZ();\n        /* Calculate */\n        let r = Math.sqrt(x * x + y * y);\n        let ir = (1.0 / r);\n        let lat = Math.atan(z * ir);\n        for (let i = 0; i < 7; i++) {\n            let sinLat = Math.sin(lat);\n            let vi = this.getPrimeVerticalRadius2(lat, sinLat);\n            lat = Math.atan((z + this._e2 * vi * sinLat) * ir);\n        }\n        let lon = Math.atan2(y, x);\n        let v = this.getPrimeVerticalRadius(lat);\n        let h = x * Ellipsoid.sec(lon) * Ellipsoid.sec(lat) - v;\n        /* Store the new coordinates */\n        geographic.setX(lon);\n        geographic.setY(lat);\n        geographic.setZ(h);\n        //\n        // loop lat error:\n        //\n        // i=0: 0.0031239393816600014 // km level\n        // i=1: 6.753891540589585E-6 // m level\n        // i=2: 1.4568768968992174E-8 // mm level\n        // i=3: 3.1426083957342144E-11 // um level\n        // i=4: 6.783462680459706E-14 // nm level\n        // i=5: 1.1102230246251565E-16 // atomic level\n        // i=6: 0.0\n        //\n        // EPSG example for the WGS84 datum/ellipsoid:\n        // X = 3771793.97;\n        // Y =  140253.34;\n        // Z = 5124304.35;\n        // lat = 53.8093944; (degrees)\n        // lon =  2.12955; (degrees)\n        // h = 73.001873;\n    }\n    /**\n     * Convert 3D geocentric coordinates to 3D geographic coordinates.\n     * See the EPSG Guidance Note, 2.2.1\n     * @param geocentric the geocentric coordinates (in meter).\n     * @param geographic the new geographic coordinates (lon(x) and lat(y) in degrees, height(z) in meter) (the result object).\n     */\n    toGeoGraphicDeg(geocentric, geographic) {\n        /* Get the parameters */\n        let x = geocentric.getX();\n        let y = geocentric.getY();\n        let z = geocentric.getZ();\n        /* Calculate */\n        let r = Math.sqrt(x * x + y * y);\n        let ir = (1.0 / r);\n        let lat = Math.atan(z * ir);\n        for (let i = 0; i < 7; i++) {\n            let sinLat = Math.sin(lat);\n            let vi = this.getPrimeVerticalRadius2(lat, sinLat);\n            lat = Math.atan((z + this._e2 * vi * sinLat) * ir);\n        }\n        let lon = Math.atan2(y, x);\n        let v = this.getPrimeVerticalRadius(lat);\n        let h = x * Ellipsoid.sec(lon) * Ellipsoid.sec(lat) - v;\n        /* Store the new coordinates */\n        geographic.setX(lon / Math.PI * 180.0);\n        geographic.setY(lat / Math.PI * 180.0);\n        geographic.setZ(h);\n    }\n    /**\n     * Check if another ellipsoid is compatible with this one.\n     * @param other the other ellipsoid.\n     * @return true if compatible.\n     */\n    isCompatible(other) {\n        if (other._code == this._code)\n            return true;\n        if (other._unitCode != this._unitCode)\n            return false;\n        if (Math.abs(other._a - this._a) > 0.001)\n            return false;\n        if (Math.abs(other._b - this._b) > 0.001)\n            return false;\n        return true;\n    }\n    /**\n     * The standard toString method.\n     * @see Object#toString\n     */\n    toString() {\n        return \"[Ellipsoid:code=\" + this._code + \",name='\" + this._name + \"']\";\n    }\n}\n//# sourceMappingURL=Ellipsoid.js.map",
      "start": 1693508125614,
      "end": 1693508125651,
      "sourcemaps": null
    }
  ]
}
