{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/curve/internalContexts/MultiChainCollector.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Curve\n */\nimport { Geometry } from \"../../Geometry\";\nimport { FrameBuilder } from \"../../geometry3d/FrameBuilder\";\nimport { Arc3d } from \"../Arc3d\";\nimport { BagOfCurves, CurveCollection } from \"../CurveCollection\";\nimport { CurveCurve } from \"../CurveCurve\";\nimport { CurvePrimitive } from \"../CurvePrimitive\";\nimport { LineSegment3d } from \"../LineSegment3d\";\nimport { LineString3d } from \"../LineString3d\";\nimport { Loop } from \"../Loop\";\nimport { Path } from \"../Path\";\nimport { RegionOps } from \"../RegionOps\";\n/**\n * Manage a growing array of arrays of curve primitives that are to be joined \"head to tail\" in paths.\n * * The caller makes a sequence of calls to announce individual primitives.\n * * This collector (unlike the simpler [[ChainCollectorContext]]) expects to have inputs arriving in random order, leaving multiple open chains in play at any time.\n * * When all curves have been announced, the call to `grabResults` restructures the various active chains into Paths (and optionally, Loops).\n * * Chain formation is dependent upon input fragment order, as a greedy algorithm is employed.\n * * Usage pattern is\n *   * initialization: `context = new MultiChainCollector(gapTol, planeTol)`\n *   * many times:\n *       * `context.captureCurve(anyCurve)`\n *       * `context.captureCurvePrimitive(primitive)`\n *   * end: `result = context.grabResult(makeLoopIfClosed)`\n * @internal\n */\nexport class MultiChainCollector {\n    /** Initialize with an empty array of chains.\n     * @param gapTolerance tolerance for calling endpoints identical\n     * @param planeTolerance tolerance for considering a closed chain to be planar. If undefined, only create Path. If defined, create Loops for closed chains within tolerance of a plane.\n     */\n    constructor(gapTolerance = Geometry.smallMetricDistance, planeTolerance = Geometry.smallMetricDistance) {\n        this._chains = [];\n        this._gapTolerance = gapTolerance;\n        this._snapTolerance = Geometry.smallMetricDistance;\n        this._planeTolerance = planeTolerance;\n    }\n    /**\n     * Find a chain (with index _other than_ exceptChainIndex) that starts or ends at xyz\n     * @param xyz endpoint to check\n     * @param tolerance absolute distance tolerance for equating endpoints\n     * @param exceptChainIndex index of chain to ignore. Send -1 to consider all chains.\n     */\n    findAnyChainToConnect(xyz, tolerance, exceptChainIndex = -1) {\n        for (let chainIndexA = 0; chainIndexA < this._chains.length; chainIndexA++) {\n            if (exceptChainIndex === chainIndexA)\n                continue;\n            const chain = this._chains[chainIndexA];\n            this._xyzWork1 = chain[chain.length - 1].endPoint(this._xyzWork1);\n            if (this._xyzWork1.isAlmostEqual(xyz, tolerance))\n                return { chainIndex: chainIndexA, atEnd: true };\n            this._xyzWork1 = chain[0].startPoint(this._xyzWork1);\n            if (this._xyzWork1.isAlmostEqual(xyz, tolerance))\n                return { chainIndex: chainIndexA, atEnd: false };\n        }\n        return undefined;\n    }\n    /**\n     * Insert a single curve primitive into the active chains.\n     * * The primitive is captured (not cloned)\n     * * The primitive may be reversed in place\n     * @param candidate curve to add to the context\n     */\n    captureCurvePrimitive(candidate) {\n        if (this._snapTolerance < this._gapTolerance) {\n            if (this.attachPrimitiveToAnyChain(candidate, this._snapTolerance))\n                return;\n        }\n        if (this.attachPrimitiveToAnyChain(candidate, this._gapTolerance))\n            return;\n        this._chains.push([candidate]);\n    }\n    /**\n     * Insert any curve into the collection.\n     * * This recurses into Path, Loop, BagOfCurves etc\n     * * All primitives are captured, and may be reversed in place.\n     * @param candidate curve to add to the context\n     */\n    captureCurve(candidate) {\n        if (candidate instanceof CurvePrimitive)\n            this.captureCurvePrimitive(candidate);\n        else if (candidate instanceof CurveCollection && candidate.children !== undefined) {\n            for (const c of candidate.children) {\n                this.captureCurve(c);\n            }\n        }\n    }\n    /** If allowed by the geometry type, move an endpoint. */\n    static simpleEndPointMove(curve, atEnd, to) {\n        if (curve instanceof (LineSegment3d)) {\n            if (atEnd) {\n                curve.point1Ref.setFrom(to);\n            }\n            else {\n                curve.point0Ref.setFrom(to);\n            }\n            return true;\n        }\n        else if (curve instanceof LineString3d && curve.numPoints() > 0) {\n            const i = atEnd ? curve.numPoints() - 1 : 0;\n            curve.packedPoints.setAtCheckedPointIndex(i, to);\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Try to move the end of curve0 and/or the start of curve1 to a common point.\n     * * All z-coordinates are ignored.\n     * @param curve0 first curve, assumed to end close to the start of curve1\n     * @param curve1 second curve, assumed to start close to the end of curve0\n     * @param gapTolerance max distance to move a curve start/end point\n     * @returns whether curve start/end point(s) moved\n     */\n    static moveHeadOrTail(curve0, curve1, gapTolerance) {\n        const xyz0 = curve0.endPoint();\n        const xyz1 = curve1.startPoint();\n        const minShift = Geometry.smallMetricDistance * 0.001;\n        const d01 = xyz0.distanceXY(xyz1);\n        if (d01 < minShift)\n            return false;\n        // try lines and linestrings\n        if (d01 < gapTolerance) {\n            if (this.simpleEndPointMove(curve1, false, xyz0) || this.simpleEndPointMove(curve0, true, xyz1))\n                return true;\n        }\n        // try other primitive types\n        const intersections = CurveCurve.intersectionXYPairs(curve0, true, curve1, true);\n        const shiftFactor = 5.0;\n        for (const pair of intersections) {\n            const detail0 = pair.detailA;\n            const detail1 = pair.detailB;\n            const distance0 = detail0.point.distanceXY(xyz0);\n            const distance1 = detail1.point.distanceXY(xyz1);\n            if (distance0 < shiftFactor * gapTolerance && distance1 < shiftFactor * gapTolerance) {\n                if (curve0 instanceof Arc3d && curve1 instanceof Arc3d) {\n                    const radians0End = curve0.sweep.fractionToRadians(detail0.fraction);\n                    curve0.sweep.setStartEndRadians(curve0.sweep.startRadians, radians0End);\n                    const radians1Start = curve1.sweep.fractionToRadians(detail1.fraction);\n                    curve1.sweep.setStartEndRadians(radians1Start, curve1.sweep.endRadians);\n                    return true;\n                }\n                // TODO: other combinations of types\n            }\n        }\n        return false;\n    }\n    /** Announce a curve primitive\n     * * If a \"nearby\" connection is possible, insert the candidate in the chain and force endpoint match.\n     * * Otherwise start a new chain.\n     */\n    attachPrimitiveToAnyChain(candidate, tolerance) {\n        if (candidate) {\n            this._xyzWork0 = candidate.startPoint(this._xyzWork0);\n            let connect = this.findAnyChainToConnect(this._xyzWork0, tolerance);\n            if (connect) {\n                if (connect.atEnd) {\n                    const chain = this._chains[connect.chainIndex];\n                    const index0 = chain.length - 1;\n                    this._chains[connect.chainIndex].push(candidate);\n                    MultiChainCollector.moveHeadOrTail(chain[index0], chain[index0 + 1], this._gapTolerance);\n                    this.searchAndMergeChainIndex(connect.chainIndex, tolerance);\n                    return true;\n                }\n                else {\n                    candidate.reverseInPlace();\n                    const chain = this._chains[connect.chainIndex];\n                    chain.splice(0, 0, candidate);\n                    MultiChainCollector.moveHeadOrTail(chain[0], chain[1], this._gapTolerance);\n                    this.searchAndMergeChainIndex(connect.chainIndex, tolerance);\n                    return true;\n                }\n            }\n            else {\n                this._xyzWork0 = candidate.endPoint(this._xyzWork0);\n                connect = this.findAnyChainToConnect(this._xyzWork0, tolerance);\n                if (connect) {\n                    if (connect.atEnd) {\n                        candidate.reverseInPlace();\n                        const chain = this._chains[connect.chainIndex];\n                        const index0 = chain.length - 1;\n                        this._chains[connect.chainIndex].push(candidate);\n                        MultiChainCollector.moveHeadOrTail(chain[index0], chain[index0 + 1], this._gapTolerance);\n                        this.searchAndMergeChainIndex(connect.chainIndex, tolerance);\n                        return true;\n                    }\n                    else {\n                        const chain = this._chains[connect.chainIndex];\n                        chain.splice(0, 0, candidate);\n                        MultiChainCollector.moveHeadOrTail(chain[0], chain[1], this._gapTolerance);\n                        this.searchAndMergeChainIndex(connect.chainIndex, tolerance);\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n    /**\n     * Merge two entries in the chain array.\n     * * Move each primitive from chainB to the end of chainA.\n     * * Clear chainB.\n     * * Move the final chain to chainB index.\n     * * Decrement the array length.\n     * @param chainIndexA index of chainA\n     * @param chainIndexB index of chainB\n     */\n    mergeChainsForwardForward(chainIndexA, chainIndexB) {\n        const chainA = this._chains[chainIndexA];\n        const chainB = this._chains[chainIndexB];\n        for (const p of chainB) {\n            chainA.push(p);\n        }\n        chainB.length = 0; // chainIndexB is unused\n        const lastChainIndex = this._chains.length - 1;\n        if (chainIndexB !== lastChainIndex)\n            this._chains[chainIndexB] = this._chains[lastChainIndex];\n        this._chains.pop();\n    }\n    /** Reverse the curve chain in place. */\n    reverseChain(chainIndex) {\n        const chain = this._chains[chainIndex];\n        chain.reverse();\n        for (const p of chain)\n            p.reverseInPlace();\n    }\n    /** See if the head or tail of chainIndex matches any existing chain. If so, merge the two chains. */\n    searchAndMergeChainIndex(chainIndex, tolerance) {\n        // ASSUME valid index of non-empty chain\n        const chain = this._chains[chainIndex];\n        const lastIndexInChain = chain.length - 1;\n        this._xyzWork0 = chain[0].startPoint(this._xyzWork0);\n        // try start with any other chain\n        let connect = this.findAnyChainToConnect(this._xyzWork0, tolerance, chainIndex);\n        if (connect) {\n            if (!connect.atEnd)\n                this.reverseChain(connect.chainIndex);\n            this.mergeChainsForwardForward(connect.chainIndex, chainIndex);\n            return;\n        }\n        // try end with any other chain\n        this._xyzWork0 = chain[lastIndexInChain].endPoint(this._xyzWork0);\n        connect = this.findAnyChainToConnect(this._xyzWork0, tolerance, chainIndex);\n        if (connect) {\n            if (connect.atEnd)\n                this.reverseChain(connect.chainIndex);\n            this.mergeChainsForwardForward(chainIndex, connect.chainIndex);\n            return;\n        }\n    }\n    /**\n     * Convert an array of curve primitives into the simplest possible strongly typed curve structure.\n     * @param curves input array, assembled correctly into a single contiguous path, captured by returned object\n     * @param makeLoopIfClosed whether to return a Loop from physically closed curves array, otherwise Path\n     * @return Loop or Path if multiple curves; the primitive if only one curve; undefined if no curves\n     */\n    promoteArrayToCurves(curves, makeLoopIfClosed) {\n        if (curves.length === 0)\n            return undefined;\n        if (makeLoopIfClosed) {\n            const primitive0 = curves[0];\n            const primitiveN = curves[curves.length - 1];\n            MultiChainCollector._staticPointA = primitive0.startPoint(MultiChainCollector._staticPointA);\n            MultiChainCollector._staticPointB = primitiveN.endPoint(MultiChainCollector._staticPointB);\n            if (MultiChainCollector.moveHeadOrTail(primitiveN, primitive0, this._gapTolerance)) {\n                // get the corrected coordinates\n                MultiChainCollector._staticPointA = primitive0.startPoint(MultiChainCollector._staticPointA);\n                MultiChainCollector._staticPointB = primitiveN.endPoint(MultiChainCollector._staticPointB);\n            }\n            if (MultiChainCollector._staticPointA.isAlmostEqual(MultiChainCollector._staticPointB, this._gapTolerance)) {\n                const localToWorld = FrameBuilder.createRightHandedLocalToWorld(curves);\n                if (localToWorld) {\n                    const worldToLocal = localToWorld.inverse();\n                    if (worldToLocal) {\n                        const range = RegionOps.curveArrayRange(curves, worldToLocal);\n                        if (this._planeTolerance !== undefined && range.zLength() <= this._planeTolerance) {\n                            return Loop.createArray(curves);\n                        }\n                    }\n                }\n                return Path.createArray(curves);\n            }\n        }\n        if (curves.length === 1)\n            return curves[0];\n        return Path.createArray(curves);\n    }\n    /** Stroke the curve chain to a line string, de-duplicate the points. */\n    chainToLineString3d(chain, options) {\n        if (chain.length === 0)\n            return undefined;\n        const linestring = LineString3d.create();\n        for (const curve of chain)\n            curve.emitStrokes(linestring, options);\n        linestring.removeDuplicatePoints(this._gapTolerance);\n        return linestring;\n    }\n    /** Return the collected results, structured as the simplest possible type. */\n    grabResult(makeLoopIfClosed = false) {\n        const chains = this._chains;\n        if (chains.length === 0)\n            return undefined;\n        if (chains.length === 1)\n            return this.promoteArrayToCurves(chains[0], makeLoopIfClosed);\n        const bag = BagOfCurves.create();\n        for (const chain of chains) {\n            const q = this.promoteArrayToCurves(chain, makeLoopIfClosed);\n            bag.tryAddChild(q);\n        }\n        return bag;\n    }\n    /** Return chains as individual calls to announceChain. */\n    announceChainsAsLineString3d(announceChain, options) {\n        const chains = this._chains;\n        if (chains.length === 1) {\n            const ls = this.chainToLineString3d(chains[0], options);\n            if (ls)\n                announceChain(ls);\n        }\n        else if (chains.length > 1) {\n            for (const chain of chains) {\n                const ls = this.chainToLineString3d(chain, options);\n                if (ls)\n                    announceChain(ls);\n            }\n        }\n    }\n}\n//# sourceMappingURL=MultiChainCollector.js.map",
      "start": 1693508124151,
      "end": 1693508124272,
      "sourcemaps": null
    }
  ]
}
