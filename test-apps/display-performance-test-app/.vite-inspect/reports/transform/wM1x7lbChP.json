{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/common/gltf/GltfSchema.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Rendering\n */\n/** Enumerates the types of [[GltfMeshPrimitive]] topologies.\n * @internal\n */\nexport var GltfMeshMode;\n(function (GltfMeshMode) {\n    GltfMeshMode[GltfMeshMode[\"Points\"] = 0] = \"Points\";\n    GltfMeshMode[GltfMeshMode[\"Lines\"] = 1] = \"Lines\";\n    GltfMeshMode[GltfMeshMode[\"LineStrip\"] = 3] = \"LineStrip\";\n    GltfMeshMode[GltfMeshMode[\"Triangles\"] = 4] = \"Triangles\";\n    /** Not currently supported. */\n    GltfMeshMode[GltfMeshMode[\"TriangleStrip\"] = 5] = \"TriangleStrip\";\n    /** Not currently supported. */\n    GltfMeshMode[GltfMeshMode[\"TriangleFan\"] = 6] = \"TriangleFan\";\n})(GltfMeshMode || (GltfMeshMode = {}));\n/** Enumerates the basic data types supported by accessors, material values, technique uniforms, etc.\n * @internal\n */\nexport var GltfDataType;\n(function (GltfDataType) {\n    GltfDataType[GltfDataType[\"SignedByte\"] = 5120] = \"SignedByte\";\n    GltfDataType[GltfDataType[\"UnsignedByte\"] = 5121] = \"UnsignedByte\";\n    GltfDataType[GltfDataType[\"SignedShort\"] = 5122] = \"SignedShort\";\n    GltfDataType[GltfDataType[\"UnsignedShort\"] = 5123] = \"UnsignedShort\";\n    GltfDataType[GltfDataType[\"UInt32\"] = 5125] = \"UInt32\";\n    GltfDataType[GltfDataType[\"Float\"] = 5126] = \"Float\";\n    GltfDataType[GltfDataType[\"Rgb\"] = 6407] = \"Rgb\";\n    GltfDataType[GltfDataType[\"Rgba\"] = 6408] = \"Rgba\";\n    GltfDataType[GltfDataType[\"IntVec2\"] = 35667] = \"IntVec2\";\n    GltfDataType[GltfDataType[\"IntVec3\"] = 35668] = \"IntVec3\";\n    GltfDataType[GltfDataType[\"FloatVec2\"] = 35664] = \"FloatVec2\";\n    GltfDataType[GltfDataType[\"FloatVec3\"] = 35665] = \"FloatVec3\";\n    GltfDataType[GltfDataType[\"FloatVec4\"] = 35666] = \"FloatVec4\";\n    GltfDataType[GltfDataType[\"FloatMat3\"] = 35675] = \"FloatMat3\";\n    GltfDataType[GltfDataType[\"FloatMat4\"] = 35676] = \"FloatMat4\";\n    GltfDataType[GltfDataType[\"Sampler2d\"] = 35678] = \"Sampler2d\";\n})(GltfDataType || (GltfDataType = {}));\n/** @internal */\nexport var GltfMagFilter;\n(function (GltfMagFilter) {\n    GltfMagFilter[GltfMagFilter[\"Nearest\"] = 9728] = \"Nearest\";\n    GltfMagFilter[GltfMagFilter[\"Linear\"] = 9729] = \"Linear\";\n})(GltfMagFilter || (GltfMagFilter = {}));\n/** @internal */\nexport var GltfMinFilter;\n(function (GltfMinFilter) {\n    GltfMinFilter[GltfMinFilter[\"Nearest\"] = 9728] = \"Nearest\";\n    GltfMinFilter[GltfMinFilter[\"Linear\"] = 9729] = \"Linear\";\n    GltfMinFilter[GltfMinFilter[\"NearestMipMapNearest\"] = 9984] = \"NearestMipMapNearest\";\n    GltfMinFilter[GltfMinFilter[\"LinearMipMapNearest\"] = 9985] = \"LinearMipMapNearest\";\n    GltfMinFilter[GltfMinFilter[\"NearestMipMapLinear\"] = 9986] = \"NearestMipMapLinear\";\n    GltfMinFilter[GltfMinFilter[\"LinearMipMapLinear\"] = 9987] = \"LinearMipMapLinear\";\n})(GltfMinFilter || (GltfMinFilter = {}));\n/** Describes how texture coordinates outside of the range [0..1] are handled.\n * @internal\n */\nexport var GltfWrapMode;\n(function (GltfWrapMode) {\n    GltfWrapMode[GltfWrapMode[\"ClampToEdge\"] = 33071] = \"ClampToEdge\";\n    GltfWrapMode[GltfWrapMode[\"MirroredRepeat\"] = 33648] = \"MirroredRepeat\";\n    GltfWrapMode[GltfWrapMode[\"Repeat\"] = 10497] = \"Repeat\";\n})(GltfWrapMode || (GltfWrapMode = {}));\n/** Describes the intended target of a [[GltfBufferViewProps]].\n * @internal\n */\nexport var GltfBufferTarget;\n(function (GltfBufferTarget) {\n    GltfBufferTarget[GltfBufferTarget[\"ArrayBuffer\"] = 34962] = \"ArrayBuffer\";\n    GltfBufferTarget[GltfBufferTarget[\"ElementArrayBuffer\"] = 24963] = \"ElementArrayBuffer\";\n})(GltfBufferTarget || (GltfBufferTarget = {}));\n/** Iterate the contents of a [[GltfDictionary]].\n * @internal\n */\nexport function* gltfDictionaryIterator(dict) {\n    if (Array.isArray(dict)) {\n        for (const elem of dict)\n            yield elem;\n    }\n    else {\n        for (const key of Object.keys(dict)) {\n            const value = dict[key];\n            if (undefined !== value)\n                yield value;\n        }\n    }\n}\n/** Get the Ids of the meshes associated with a node.\n * @internal\n */\nexport function getGltfNodeMeshIds(node) {\n    if (undefined !== node.meshes)\n        return typeof node.meshes === \"string\" ? [node.meshes] : node.meshes;\n    else if (undefined !== node.mesh)\n        return [node.mesh];\n    return [];\n}\n/** @internal */\nexport function* traverseGltfNodes(ids, nodes, traversed) {\n    for (const id of ids) {\n        if (traversed.has(id))\n            throw new Error(\"Cycle detected while traversing glTF nodes\");\n        const node = nodes[id];\n        if (!node)\n            continue;\n        traversed.add(id);\n        yield node;\n        if (node.children)\n            for (const child of traverseGltfNodes(node.children, nodes, traversed))\n                yield child;\n    }\n}\n/** GL states that can be enabled by a [[GltfTechnique]]. Only those queried by this implementation are enumerated.\n * @internal\n */\nexport var GltfTechniqueState;\n(function (GltfTechniqueState) {\n    /** Enables alpha blending. */\n    GltfTechniqueState[GltfTechniqueState[\"Blend\"] = 3042] = \"Blend\";\n})(GltfTechniqueState || (GltfTechniqueState = {}));\n/** @internal */\nexport function isGltf1Material(material) {\n    const mat1 = material;\n    return undefined !== mat1.technique || undefined !== mat1.values;\n}\n//# sourceMappingURL=GltfSchema.js.map",
      "start": 1693508118452,
      "end": 1693508118768,
      "sourcemaps": null
    }
  ]
}
