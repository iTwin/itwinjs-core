{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tile/ClassifierTileTree.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tiles\n */\nimport { comparePossiblyUndefined, compareStrings, compareStringsOrUndefined, Id64 } from \"@itwin/core-bentley\";\nimport { BatchType, iModelTileTreeIdToString, RenderMode, } from \"@itwin/core-common\";\nimport { IModelApp } from \"../IModelApp\";\nimport { GeometricModelState } from \"../ModelState\";\nimport { IModelTileTree, iModelTileTreeParamsFromJSON, TileTreeLoadStatus, TileTreeReference, } from \"./internal\";\nfunction compareIds(lhs, rhs) {\n    return compareStrings(lhs.modelId, rhs.modelId) || compareStringsOrUndefined(lhs.animationId, rhs.animationId)\n        || comparePossiblyUndefined((x, y) => x.compareTo(y), lhs.timeline, rhs.timeline);\n}\nclass ClassifierTreeSupplier {\n    constructor() {\n        this._nonexistentTreeOwner = {\n            tileTree: undefined,\n            loadStatus: TileTreeLoadStatus.NotFound,\n            load: () => undefined,\n            dispose: () => undefined,\n            loadTree: async () => undefined,\n            iModel: undefined,\n        };\n    }\n    compareTileTreeIds(lhs, rhs) {\n        return compareIds(lhs, rhs);\n    }\n    async createTileTree(id, iModel) {\n        await iModel.models.load(id.modelId);\n        const model = iModel.models.getLoaded(id.modelId);\n        if (undefined === model || !(model instanceof GeometricModelState))\n            return undefined;\n        const idStr = iModelTileTreeIdToString(id.modelId, id, IModelApp.tileAdmin);\n        const props = await IModelApp.tileAdmin.requestTileTreeProps(iModel, idStr);\n        const params = iModelTileTreeParamsFromJSON(props, iModel, id.modelId, {\n            edges: false,\n            allowInstancing: false,\n            is3d: true,\n            batchType: id.type,\n            timeline: id.timeline,\n        });\n        return new IModelTileTree(params, id);\n    }\n    getOwner(id, iModel) {\n        return Id64.isValid(id.modelId) ? iModel.tiles.getTileTreeOwner(id, this) : this._nonexistentTreeOwner;\n    }\n    addModelsAnimatedByScript(modelIds, scriptSourceId, trees) {\n        // Note: This is invoked when an element hosting a schedule script is updated - it doesn't care about frontend schedule scripts.\n        for (const tree of trees)\n            if (scriptSourceId === tree.id.animationId)\n                modelIds.add(tree.id.modelId);\n    }\n    addSpatialModels(modelIds, trees) {\n        for (const tree of trees)\n            modelIds.add(tree.id.modelId);\n    }\n}\nconst classifierTreeSupplier = new ClassifierTreeSupplier();\n/** @internal */\nexport class SpatialClassifierTileTreeReference extends TileTreeReference {\n    get isOpaque() { return false; } /** When referenced as a map layer reference, BIM models are never opaque. */\n    get transparency() { return undefined; }\n}\n/** @internal */\nclass ClassifierTreeReference extends SpatialClassifierTileTreeReference {\n    constructor(classifiers, classifiedTree, iModel, source) {\n        super();\n        this._id = createClassifierId(classifiers.active, source);\n        this._source = source;\n        this._iModel = iModel;\n        this._classifiers = classifiers;\n        this._classifiedTree = classifiedTree;\n        this._owner = classifierTreeSupplier.getOwner(this._id, iModel);\n    }\n    get classifiers() { return this._classifiers; }\n    get activeClassifier() { return this.classifiers.active; }\n    get castsShadows() {\n        return false;\n    }\n    get treeOwner() {\n        const newId = createClassifierId(this._classifiers.active, this._source);\n        if (0 !== compareIds(this._id, newId)) {\n            this._id = newId;\n            this._owner = classifierTreeSupplier.getOwner(this._id, this._iModel);\n        }\n        return this._owner;\n    }\n    discloseTileTrees(trees) {\n        // NB: We do NOT call super because we don't use our tree if no classifier is active.\n        trees.disclose(this._classifiedTree);\n        const classifier = this.activeClassifier;\n        const classifierTree = undefined !== classifier ? this.treeOwner.tileTree : undefined;\n        if (undefined !== classifierTree)\n            trees.add(classifierTree);\n    }\n    get isPlanar() { return BatchType.PlanarClassifier === this._id.type; }\n    get viewFlags() {\n        return {\n            renderMode: RenderMode.SmoothShade,\n            transparency: true,\n            textures: false,\n            lighting: false,\n            shadows: false,\n            monochrome: false,\n            materials: false,\n            ambientOcclusion: false,\n            visibleEdges: false,\n            hiddenEdges: false,\n        };\n    }\n    // Add volume classifiers to scene (planar classifiers are added seperately.)\n    addToScene(context) {\n        if (this.isPlanar)\n            return;\n        const classifiedTree = this._classifiedTree.treeOwner.load();\n        if (undefined === classifiedTree)\n            return;\n        const classifier = this._classifiers.active;\n        if (undefined === classifier)\n            return;\n        const classifierTree = this.treeOwner.load();\n        if (undefined === classifierTree)\n            return;\n        context.setVolumeClassifier(classifier, classifiedTree.modelId);\n        super.addToScene(context);\n    }\n}\n/** @internal */\nexport function createClassifierTileTreeReference(classifiers, classifiedTree, iModel, source) {\n    return new ClassifierTreeReference(classifiers, classifiedTree, iModel, source);\n}\nfunction createClassifierId(classifier, source) {\n    if (undefined === classifier)\n        return { modelId: Id64.invalid, type: BatchType.PlanarClassifier, expansion: 0, animationId: undefined };\n    const type = classifier.flags.isVolumeClassifier ? BatchType.VolumeClassifier : BatchType.PlanarClassifier;\n    const scriptInfo = IModelApp.tileAdmin.getScriptInfoForTreeId(classifier.modelId, source?.scheduleScriptReference); // eslint-disable-line deprecation/deprecation\n    return {\n        modelId: classifier.modelId,\n        type,\n        expansion: classifier.expand,\n        animationId: scriptInfo?.animationId,\n        timeline: scriptInfo?.timeline,\n    };\n}\n//# sourceMappingURL=ClassifierTileTree.js.map",
      "start": 1693508121913,
      "end": 1693508122129,
      "sourcemaps": null
    }
  ]
}
