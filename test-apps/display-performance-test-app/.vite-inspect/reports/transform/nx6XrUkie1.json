{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tile/TileRequestChannel.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tiles\n */\nimport { assert, PriorityQueue } from \"@itwin/core-bentley\";\nclass TileRequestQueue extends PriorityQueue {\n    constructor() {\n        super((lhs, rhs) => {\n            const diff = lhs.tile.tree.loadPriority - rhs.tile.tree.loadPriority;\n            return 0 !== diff ? diff : lhs.priority - rhs.priority;\n        });\n    }\n}\n/** Statistics regarding the current and cumulative state of one or more [[TileRequestChannel]]s. Useful for monitoring performance and diagnosing problems.\n * @see [[TileRequestChannel.statistics]] for a specific channel's statistics.\n * @see [[TileRequestChannels.statistics]] for statistics from all channels.\n * @see [[TileAdmin.statistics]] for additional statistics.\n * @public\n * @extensions\n */\nexport class TileRequestChannelStatistics {\n    constructor() {\n        /** The number of queued requests that have not yet been dispatched. */\n        this.numPendingRequests = 0;\n        /** The number of requests that have been dispatched but not yet completed. */\n        this.numActiveRequests = 0;\n        /** The number of requests canceled during the most recent update. */\n        this.numCanceled = 0;\n        /** The total number of completed requests during this session. */\n        this.totalCompletedRequests = 0;\n        /** The total number of failed requests during this session. */\n        this.totalFailedRequests = 0;\n        /** The total number of timed-out requests during this session. */\n        this.totalTimedOutRequests = 0;\n        /** The total number of completed requests during this session which produced an empty tile.\n         * These tiles also contribute to [[totalCompletedRequests]], but not to [[totalUndisplayableTiles]].\n         */\n        this.totalEmptyTiles = 0;\n        /** The total number of completed requests during this session that produced an undisplayable tile.\n         * These tiles also contribute to [[totalCompletedRequests]], but not to [[totalEmptyTiles]].\n         */\n        this.totalUndisplayableTiles = 0;\n        /** The total number of tiles whose contents were not found in cloud storage cache and therefore resulted in a backend request to generate the tile content. */\n        this.totalCacheMisses = 0;\n        /** The total number of tiles for which content requests were dispatched. */\n        this.totalDispatchedRequests = 0;\n        /** The total number of tiles for which content requests were dispatched and then canceled on the backend before completion. */\n        this.totalAbortedRequests = 0;\n        /** Statistics summarizing time spent decoding tile content.\n         * @beta\n         */\n        this.decoding = {\n            total: 0,\n            mean: 0,\n            max: Number.MIN_SAFE_INTEGER,\n            min: Number.MAX_SAFE_INTEGER,\n        };\n    }\n    /** @internal */\n    addTo(stats) {\n        for (const propName in this) { // eslint-disable-line guard-for-in\n            const key = propName;\n            const val = this[key];\n            if (typeof val === \"number\") {\n                assert(typeof stats[key] === \"number\");\n                stats[key] += val;\n            }\n        }\n        stats.decoding.total += this.decoding.total;\n        stats.decoding.max = Math.max(this.decoding.max, stats.decoding.max);\n        stats.decoding.min = Math.min(this.decoding.min, stats.decoding.min);\n        if (stats.totalCompletedRequests > 0)\n            stats.decoding.mean = (stats.decoding.total) / stats.totalCompletedRequests;\n    }\n    /** @internal */\n    recordCompletion(tile, elapsedMilliseconds) {\n        ++this.totalCompletedRequests;\n        if (tile.isEmpty)\n            ++this.totalEmptyTiles;\n        else if (!tile.isDisplayable)\n            ++this.totalUndisplayableTiles;\n        this.decoding.total += elapsedMilliseconds;\n        this.decoding.mean = this.decoding.total / this.totalCompletedRequests;\n        this.decoding.max = Math.max(this.decoding.max, elapsedMilliseconds);\n        this.decoding.min = Math.min(this.decoding.min, elapsedMilliseconds);\n    }\n}\n/** A channel over which requests for tile content can be made. The channel may request content over HTTP, calls to the backend via IPC or RPC, or any other method like generating the content\n * on the frontend. The channel consists of a queue of pending requests and a set of \"active\" requests (dispatched and awaiting a response). Incoming requests are placed onto the queue. Requests are popped of the queue in order of priority and dispatched, until the maximum number of simultaneously-active requests is reached.\n * The maximum number of active requests depends on the transport mechanism. For HTTP 1.1, browsers impose a limit of 6 simultaneous connections to a given domain, so ideally each unique domain will use its own unique channel with a limit of 6 active requests. Even for requests satisfied entirely by the frontend, imposing a limit is important for throttling the amount of work done at one time, especially because as the user navigates the view, tiles that were previously requested may no longer be of interest and we shouldn't waste resources producing their content.\n * A channel must be registered with [[TileRequestChannels]] and must have a unique name among all registered channels.\n * @see [[TileRequestChannels.getForHttp]] to obtain (and register if not already registered) an HTTP-based channel.\n * @see [[TileAdmin.channels]] for the channels configured for use with the iTwin.js display system.\n * @see [[Tile.channel]] to specify the channel to be used to request a given tile's content.\n * @public\n * @extensions\n */\nexport class TileRequestChannel {\n    /** Create a new channel.\n     * @param name The unique name of the channel.\n     * @param concurrency The maximum number of requests that can be dispatched and awaiting a response at any given time. Requests beyond this maximum are enqueued for deferred dispatch.\n     * @see [[TileRequestChannels.getForHttp]] to create an HTTP-based channel.\n     */\n    constructor(name, concurrency) {\n        /** Protected strictly for tests. @internal */\n        this._active = new Set();\n        this._pending = new TileRequestQueue();\n        this._previouslyPending = new TileRequestQueue();\n        this._statistics = new TileRequestChannelStatistics();\n        this.name = name;\n        this._concurrency = concurrency;\n    }\n    /** The maximum number of active requests. This is generally only modified for debugging purposes.\n     * @note When reducing `concurrency`, the number of active requests ([[numActive]]) will only decrease to the new value after a sufficient number of dispatched requests are resolved.\n     */\n    get concurrency() {\n        return this._concurrency;\n    }\n    set concurrency(max) {\n        this._concurrency = max;\n    }\n    /** The number of requests that have been dispatched and are awaiting a response. */\n    get numActive() {\n        return this._active.size;\n    }\n    /** The number of requests that have been enqueued for later dispatch. */\n    get numPending() {\n        return this._pending.length;\n    }\n    /** The total number of requests in this channel, whether dispatched or enqueued. */\n    get size() {\n        return this.numActive + this.numPending;\n    }\n    /** Statistics intended primarily for debugging. */\n    get statistics() {\n        this._statistics.numPendingRequests = this.numPending;\n        this._statistics.numActiveRequests = this.numActive;\n        return this._statistics;\n    }\n    /** Reset all of this channel's [[statistics]] to zero. */\n    resetStatistics() {\n        this._statistics = new TileRequestChannelStatistics();\n    }\n    /** Invoked by [[TileRequest]] when a request times out.\n     * @internal\n     */\n    recordTimeout() {\n        ++this._statistics.totalTimedOutRequests;\n    }\n    /** Invoked by [[TileRequest]] when a request fails to produce a response.\n     * @internal\n     */\n    recordFailure() {\n        ++this._statistics.totalFailedRequests;\n    }\n    /** Invoked by [[TileRequest]] after a request completes.\n     * @internal\n     */\n    recordCompletion(tile, content, elapsedMilliseconds) {\n        this._statistics.recordCompletion(tile, elapsedMilliseconds);\n        if (this.contentCallback)\n            this.contentCallback(tile, content);\n    }\n    /** Invoked by [[TileRequestChannels.swapPending]] when [[TileAdmin]] is about to start enqueuing new requests.\n     * @internal\n     */\n    swapPending() {\n        const previouslyPending = this._pending;\n        this._pending = this._previouslyPending;\n        this._previouslyPending = previouslyPending;\n    }\n    /** Invoked by [[TileAdmin.processRequests]] to enqueue a request. Ordering is ignored - the queue will be re-sorted later.\n     * @internal\n     */\n    append(request) {\n        assert(request.channel === this);\n        this._pending.append(request);\n    }\n    /** Invoked by [[TileRequestChannels.process]] to process the active and pending requests.\n     * @internal\n     */\n    process() {\n        this._statistics.numCanceled = 0;\n        // Recompute priority of each request.\n        for (const pending of this._pending)\n            pending.priority = pending.tile.computeLoadPriority(pending.viewports, pending.users);\n        // Sort pending requests by priority.\n        this._pending.sort();\n        // Cancel any previously pending requests that are no longer needed.\n        for (const queued of this._previouslyPending)\n            if (queued.users.isEmpty)\n                this.cancel(queued);\n        this._previouslyPending.clear();\n        // Cancel any active requests that are no longer needed.\n        // NB: Do NOT remove them from the active set until their http activity has completed.\n        for (const active of this._active)\n            if (active.users.isEmpty)\n                this.cancel(active);\n        // Batch-cancel running requests.\n        this.processCancellations();\n        // Dispatch requests from the queue up to our maximum.\n        while (this._active.size < this._concurrency) {\n            const request = this._pending.pop();\n            if (!request)\n                break;\n            this.dispatch(request);\n        }\n    }\n    /** Cancel all active and queued requests and clear the active set and queue.\n     * @internal\n     */\n    cancelAndClearAll() {\n        for (const active of this._active)\n            active.cancel();\n        for (const queued of this._pending)\n            queued.cancel();\n        this._active.clear();\n        this._pending.clear();\n    }\n    /** Invoked when [[Tile.requestContent]] returns `undefined`. Return true if the request can be retried, e.g., via different channel.\n     * If so, the tile will remain marked as \"not loaded\" and, if re-selected for display, a new [[TileRequest]] will be enqueued for it.\n     * Otherwise, the tile will be marked as \"failed to load\" and no further requests will be made for its content.\n     * The default implementation always returns `false`.\n     */\n    onNoContent(_request) {\n        return false;\n    }\n    /** Invoked when a request that was previously dispatched is canceled before a response is received.\n     * Some channels accumulate such requests for later cancellation in [[processCancellations]].\n     */\n    onActiveRequestCanceled(_request) { }\n    /** Invoked to do any additional work to cancel tiles accumulated by [[onActiveRequestCanceled]]. For example, a channel that requests tile content\n     * over IPC may signal to the tile generation process that it should cease generating content for those tiles.\n     */\n    processCancellations() { }\n    /** Invoked when an iModel is closed, to clean up any state associated with that iModel. */\n    onIModelClosed(_iModel) { }\n    /** Request content for the specified tile. The default implementation simply forwards to [[Tile.requestContent]]. */\n    async requestContent(tile, isCanceled) {\n        return tile.requestContent(isCanceled);\n    }\n    /** Protected only for tests - do not override.\n     * @internal\n     */\n    dispatch(request) {\n        ++this._statistics.totalDispatchedRequests;\n        this._active.add(request);\n        request.dispatch(() => {\n            this.dropActiveRequest(request);\n        }).catch((_) => {\n            //\n        });\n    }\n    /** Protected only for tests - do not override.\n     * @internal\n     */\n    cancel(request) {\n        request.cancel();\n        ++this._statistics.numCanceled;\n    }\n    /** Protected only for tests - do not override.\n     * @internal\n     */\n    dropActiveRequest(request) {\n        assert(this._active.has(request) || request.isCanceled);\n        this._active.delete(request);\n    }\n}\n//# sourceMappingURL=TileRequestChannel.js.map",
      "start": 1693508121579,
      "end": 1693508121720,
      "sourcemaps": null
    }
  ]
}
