{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/common/lib/esm/tile/B3dmTileIO.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tile\n */\nimport { utf8ToString } from \"@itwin/core-bentley\";\nimport { TileFormat, TileHeader } from \"./TileIO\";\n/** Header preceding tile content in [b3dm](https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/specification/TileFormats/Batched3DModel) format.\n * @internal\n */\nexport class B3dmHeader extends TileHeader {\n    get isValid() { return TileFormat.B3dm === this.format; }\n    constructor(stream) {\n        super(stream);\n        this.length = stream.readUint32();\n        this.featureTableJsonLength = stream.readUint32();\n        this.featureTableBinaryLength = stream.readUint32();\n        this.batchTableJsonLength = stream.readUint32();\n        this.batchTableBinaryLength = stream.readUint32();\n        // Keep this legacy check in for now since a lot of tilesets are still using the old header.\n        // Legacy header #1: [batchLength] [batchTableByteLength]\n        // Legacy header #2: [batchTableJsonByteLength] [batchTableBinaryByteLength] [batchLength]\n        // Current header: [featureTableJsonByteLength] [featureTableBinaryByteLength] [batchTableJsonByteLength] [batchTableBinaryByteLength]\n        // If the header is in the first legacy format 'batchTableJsonByteLength' will be the start of the JSON string (a quotation mark) or the glTF magic.\n        // Accordingly its first byte will be either 0x22 or 0x67, and so the minimum uint32 expected is 0x22000000 = 570425344 = 570MB. It is unlikely that the feature table Json will exceed this length.\n        // The check for the second legacy format is similar, except it checks 'batchTableBinaryByteLength' instead\n        if (this.batchTableJsonLength >= 570425344) {\n            // First legacy check\n            stream.curPos = 20;\n            this.batchTableJsonLength = this.featureTableBinaryLength;\n            this.batchTableBinaryLength = 0;\n            this.featureTableJsonLength = 0;\n            this.featureTableBinaryLength = 0;\n        }\n        else if (this.batchTableBinaryLength >= 570425344) {\n            // Second legacy check\n            stream.curPos = 24;\n            this.batchTableJsonLength = this.featureTableJsonLength;\n            this.batchTableBinaryLength = this.featureTableBinaryLength;\n            this.featureTableJsonLength = 0;\n            this.featureTableBinaryLength = 0;\n        }\n        if (0 !== this.featureTableJsonLength) {\n            const sceneStrData = stream.nextBytes(this.featureTableJsonLength);\n            const sceneStr = utf8ToString(sceneStrData);\n            if (sceneStr)\n                this.featureTableJson = JSON.parse(sceneStr);\n        }\n        stream.advance(this.featureTableBinaryLength);\n        if (0 !== this.batchTableJsonLength) {\n            const batchStrData = stream.nextBytes(this.batchTableJsonLength);\n            const batchStr = utf8ToString(batchStrData);\n            if (batchStr)\n                this.batchTableJson = JSON.parse(batchStr);\n        }\n        stream.advance(this.batchTableBinaryLength);\n        if (stream.isPastTheEnd)\n            this.invalidate();\n    }\n}\n//# sourceMappingURL=B3dmTileIO.js.map",
      "start": 1693508120891,
      "end": 1693508120972,
      "sourcemaps": null
    }
  ]
}
