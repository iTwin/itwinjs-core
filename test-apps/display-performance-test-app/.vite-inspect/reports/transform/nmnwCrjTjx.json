{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/geometry3d/FrustumAnimation.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Solid\n */\nimport { AxisOrder, Geometry } from \"../Geometry\";\nimport { Matrix3d } from \"./Matrix3d\";\nimport { Vector3d } from \"./Point3dVector3d\";\nimport { Point3dArray } from \"./PointHelpers\";\nimport { Transform } from \"./Transform\";\n/**\n * context for constructing smooth motion a startFrustum and endFrustum.\n * The externally interesting calls are\n * * Create a context to shift corner0 to corner1, with the(NPC coordinate) point(fractionU, fractionV, fractionW) moving along its connecting segment, all other points rotating smoothly from the start orientation to end orientation:\n * `const context = SmoothTransformBetweenFrusta (cornerA, cornerB)`\n *  * Get any intermediate 8 corners(at fraction) with `context.fractionToWorldCorners(fraction)`\n * * Frustum corners are ordered by \"x varies fastest, then y, then z\", hence (xyz) order on nondimensional space is\n *   * (left lower rear) (000)\n *   * (right lower rear) (100)\n *   * (left upper rear) (010)\n *   * (right upper rear) (100)\n *   * (left lower front) (001)\n *   * (right lower front) (101)\n *   * (left upper front) (011)\n *   * (right upper front) (101)\n * * which uses names\n *    * (left,right) for horizontal (x)\n *    * (bottom, top) for vertical (y)\n *    * (rear, front) for back and front planes (z)\n * @public\n */\nexport class SmoothTransformBetweenFrusta {\n    /** (property accessor) rigid frame at start of motion */\n    get localToWorldA() { return this._localToWorldA; }\n    /** (property accessor) rigid frame at end of motion */\n    get localToWorldB() { return this._localToWorldB; }\n    /**\n     * CAPTURE local corners, pickup and putdown frames, and rotation-around-vector data\n     * @param localCornerA\n     * @param localCornerB\n     * @param localToWordA\n     * @param localToWordB\n     * @param rotationAxis\n     * @param rotationAngle\n     */\n    constructor(localToWorldA, localCornerA, localToWorldB, localCornerB, rotationAxis, rotationAngle) {\n        this._localCornerA = localCornerA;\n        this._localCornerB = localCornerB;\n        this._localToWorldA = localToWorldA;\n        this._localToWorldB = localToWorldB;\n        this._rotationAxis = rotationAxis;\n        this._rotationAngle = rotationAngle;\n    }\n    /**\n     * Set up rotation data for smooth transition from 8 point frusta cornerA and cornerB\n     * @param cornerA\n     * @param cornerB\n     */\n    static create(cornerA, cornerB, preferSimpleRotation = true) {\n        const localToWorldA = Point3dArray.evaluateTrilinearDerivativeTransform(cornerA, 0.5, 0.5, 0.5);\n        const localToWorldB = Point3dArray.evaluateTrilinearDerivativeTransform(cornerB, 0.5, 0.5, 0.5);\n        const rigidA = Transform.createOriginAndMatrix(localToWorldA.origin, Matrix3d.createRigidFromMatrix3d(localToWorldA.matrix, AxisOrder.ZXY));\n        const rigidB = Transform.createOriginAndMatrix(localToWorldB.origin, Matrix3d.createRigidFromMatrix3d(localToWorldB.matrix, AxisOrder.ZXY));\n        if (rigidA.matrix.computeCachedInverse(true) && rigidB.matrix.computeCachedInverse(true)) {\n            const spinMatrix = rigidB.matrix.multiplyMatrixMatrixInverse(rigidA.matrix);\n            const spinAxis = spinMatrix.getAxisAndAngleOfRotation();\n            const localCornerA = rigidA.multiplyInversePoint3dArray(cornerA);\n            const localCornerB = rigidB.multiplyInversePoint3dArray(cornerB);\n            /** Is this a pure rotation -- i.e. no clip volume resizing for camera or clip changes */\n            if (preferSimpleRotation && Point3dArray.isAlmostEqual(localCornerA, localCornerB) && !spinAxis.angle.isAlmostZero) {\n                // world vectors\n                const worldOriginShift = Vector3d.createStartEnd(localToWorldA.origin, localToWorldB.origin);\n                const chordMidPoint = localToWorldA.getOrigin().interpolate(0.5, localToWorldB.getOrigin());\n                const bisector = spinAxis.axis.unitCrossProduct(worldOriginShift);\n                if (bisector) {\n                    const halfChordLength = 0.5 * worldOriginShift.magnitude();\n                    const alpha = Geometry.conditionalDivideFraction(halfChordLength, Math.tan(spinAxis.angle.radians * 0.5));\n                    if (alpha !== undefined) {\n                        const spinCenter = chordMidPoint.plusScaled(bisector, alpha);\n                        const rigidA1 = Transform.createOriginAndMatrix(spinCenter, rigidA.matrix);\n                        const rigidB1 = Transform.createOriginAndMatrix(spinCenter, rigidB.matrix);\n                        const localCornerA1 = rigidA1.multiplyInversePoint3dArray(cornerA);\n                        const localCornerB1 = rigidB1.multiplyInversePoint3dArray(cornerB);\n                        return new SmoothTransformBetweenFrusta(rigidA1, localCornerA1, rigidB1, localCornerB1, spinAxis.axis, spinAxis.angle);\n                    }\n                }\n            }\n            return new SmoothTransformBetweenFrusta(rigidA, localCornerA, rigidB, localCornerB, spinAxis.axis, spinAxis.angle);\n        }\n        return undefined;\n    }\n    /** interpolate local corner coordinates at fractional move from m_localFrustum0 to m_localFrustum1 */\n    interpolateLocalCorners(fraction, result) {\n        result = result || [];\n        result.length = 0;\n        const n = this._localCornerA.length;\n        for (let i = 0; i < n; i++) {\n            result.push(this._localCornerA[i].interpolate(fraction, this._localCornerB[i]));\n        }\n        return result;\n    }\n    /**\n     * After initialization, call this for various intermediate fractions.\n     * The returned corner points are in world coordinates \"between\" start and end positions.\n     */\n    fractionToWorldCorners(fraction, result) {\n        const corners = this.interpolateLocalCorners(fraction, result);\n        const fractionalRotation = Matrix3d.createRotationAroundVector(this._rotationAxis, this._rotationAngle.cloneScaled(fraction));\n        const axes0 = this._localToWorldA.matrix;\n        const fractionalAxes = fractionalRotation.multiplyMatrixMatrix(axes0);\n        const fractionalOrigin = this._localToWorldA.getOrigin().interpolate(fraction, this._localToWorldB.origin);\n        const putdownFrame = Transform.createOriginAndMatrix(fractionalOrigin, fractionalAxes);\n        putdownFrame.multiplyPoint3dArray(corners, corners);\n        return corners;\n    }\n}\n//# sourceMappingURL=FrustumAnimation.js.map",
      "start": 1693508122303,
      "end": 1693508122365,
      "sourcemaps": null
    }
  ]
}
