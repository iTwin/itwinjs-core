{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/Graphic.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { assert, dispose } from \"@itwin/core-bentley\";\nimport { ThematicDisplayMode } from \"@itwin/core-common\";\nimport { Transform } from \"@itwin/core-geometry\";\nimport { FeatureSymbology } from \"../FeatureSymbology\";\nimport { GraphicBranch } from \"../GraphicBranch\";\nimport { RenderGraphic } from \"../RenderGraphic\";\nimport { EdgeSettings } from \"./EdgeSettings\";\nimport { FeatureOverrides } from \"./FeatureOverrides\";\nimport { PlanarClassifier } from \"./PlanarClassifier\";\nimport { TextureDrape } from \"./TextureDrape\";\nimport { ThematicSensors } from \"./ThematicSensors\";\n/** @internal */\nexport class Graphic extends RenderGraphic {\n    addHiliteCommands(_commands, _pass) { assert(false); }\n    toPrimitive() { return undefined; }\n}\nexport class GraphicOwner extends Graphic {\n    constructor(graphic) {\n        super();\n        this._isDisposed = false;\n        this._graphic = graphic;\n    }\n    get graphic() { return this._graphic; }\n    get isDisposed() { return this._isDisposed; }\n    dispose() { this._isDisposed = true; }\n    disposeGraphic() {\n        this.graphic.dispose();\n    }\n    collectStatistics(stats) {\n        this.graphic.collectStatistics(stats);\n    }\n    addCommands(commands) {\n        this._graphic.addCommands(commands);\n    }\n    get isPickable() {\n        return this._graphic.isPickable;\n    }\n    addHiliteCommands(commands, pass) {\n        this._graphic.addHiliteCommands(commands, pass);\n    }\n    toPrimitive() {\n        return this._graphic.toPrimitive();\n    }\n}\n/** @internal exported strictly for tests. */\nexport class PerTargetBatchData {\n    constructor(target) {\n        this._featureOverrides = new Map();\n        this.target = target;\n    }\n    dispose() {\n        this._thematicSensors = dispose(this._thematicSensors);\n        for (const value of this._featureOverrides.values())\n            dispose(value);\n        this._featureOverrides.clear();\n    }\n    getThematicSensors(batch) {\n        if (this._thematicSensors && !this._thematicSensors.matchesTarget(this.target))\n            this._thematicSensors = dispose(this._thematicSensors);\n        if (!this._thematicSensors)\n            this._thematicSensors = ThematicSensors.create(this.target, batch.range);\n        this._thematicSensors.update(this.target.uniforms.frustum.viewMatrix);\n        return this._thematicSensors;\n    }\n    getFeatureOverrides(batch) {\n        const source = this.target.currentFeatureSymbologyOverrides?.source;\n        let ovrs = this._featureOverrides.get(source);\n        if (!ovrs) {\n            const cleanup = source ? source.onSourceDisposed.addOnce(() => this.onSourceDisposed(source)) : undefined;\n            this._featureOverrides.set(source, ovrs = FeatureOverrides.createFromTarget(this.target, batch.options, cleanup));\n            ovrs.initFromMap(batch.featureTable);\n        }\n        ovrs.update(batch.featureTable);\n        return ovrs;\n    }\n    collectStatistics(stats) {\n        if (this._thematicSensors)\n            stats.addThematicTexture(this._thematicSensors.bytesUsed);\n        for (const ovrs of this._featureOverrides.values())\n            stats.addFeatureOverrides(ovrs.byteLength);\n    }\n    /** Exposed strictly for tests. */\n    get featureOverrides() { return this._featureOverrides; }\n    onSourceDisposed(source) {\n        const ovrs = this._featureOverrides.get(source);\n        if (ovrs) {\n            this._featureOverrides.delete(source);\n            ovrs.dispose();\n        }\n    }\n}\n/** @internal exported strictly for tests. */\nexport class PerTargetData {\n    constructor(batch) {\n        this._data = [];\n        this._batch = batch;\n    }\n    dispose() {\n        for (const data of this._data) {\n            data.target.onBatchDisposed(this._batch);\n            data.dispose();\n        }\n        this._data.length = 0;\n    }\n    get isDisposed() {\n        return this._data.length === 0;\n    }\n    /** Exposed strictly for tests. */\n    get data() { return this._data; }\n    onTargetDisposed(target) {\n        const index = this._data.findIndex((x) => x.target === target);\n        if (-1 === index)\n            return;\n        const data = this._data[index];\n        data.dispose();\n        this._data.splice(index, 1);\n    }\n    collectStatistics(stats) {\n        for (const data of this._data)\n            data.collectStatistics(stats);\n    }\n    getThematicSensors(target) {\n        return this.getBatchData(target).getThematicSensors(this._batch);\n    }\n    getFeatureOverrides(target) {\n        return this.getBatchData(target).getFeatureOverrides(this._batch);\n    }\n    getBatchData(target) {\n        let data = this._data.find((x) => x.target === target);\n        if (!data) {\n            this._data.push(data = new PerTargetBatchData(target));\n            target.addBatch(this._batch);\n        }\n        return data;\n    }\n}\n/** @internal */\nexport class Batch extends Graphic {\n    // Chiefly for debugging.\n    get tileId() {\n        return this.options.tileId;\n    }\n    get locateOnly() {\n        return true === this.options.locateOnly;\n    }\n    /** The following are valid only during a draw and reset afterward. */\n    get batchId() { return this._context.batchId; }\n    get batchIModel() { return this._context.iModel; }\n    get viewAttachmentId() { return this._context.viewAttachmentId; }\n    setContext(batchId, branch) {\n        this._context.batchId = batchId;\n        this._context.iModel = branch.iModel;\n        this._context.viewAttachmentId = branch.viewAttachmentId;\n    }\n    resetContext() {\n        this._context.batchId = 0;\n        this._context.iModel = undefined;\n        this._context.viewAttachmentId = undefined;\n    }\n    constructor(graphic, features, range, options) {\n        super();\n        this._context = { batchId: 0 };\n        /** Public strictly for tests. */\n        this.perTargetData = new PerTargetData(this);\n        this._isDisposed = false;\n        this.graphic = graphic;\n        this.featureTable = features;\n        this.range = range;\n        this.options = options ?? {};\n    }\n    get isDisposed() {\n        return this._isDisposed && this.perTargetData.isDisposed;\n    }\n    // Note: This does not remove FeatureOverrides from the array, but rather disposes of the WebGL resources they contain\n    dispose() {\n        dispose(this.graphic);\n        this.perTargetData.dispose();\n        this._isDisposed = true;\n    }\n    collectStatistics(stats) {\n        this.graphic.collectStatistics(stats);\n        stats.addFeatureTable(this.featureTable.byteLength);\n        this.perTargetData.collectStatistics(stats);\n    }\n    addCommands(commands) {\n        commands.addBatch(this);\n    }\n    get isPickable() {\n        return true;\n    }\n    getThematicSensors(target) {\n        assert(target.plan.thematic !== undefined, \"thematic display settings must exist\");\n        assert(target.plan.thematic.displayMode === ThematicDisplayMode.InverseDistanceWeightedSensors, \"thematic display mode must be sensor-based\");\n        assert(target.plan.thematic.sensorSettings.sensors.length > 0, \"must have at least one sensor to process\");\n        return this.perTargetData.getThematicSensors(target);\n    }\n    getOverrides(target) {\n        return this.perTargetData.getFeatureOverrides(target);\n    }\n    onTargetDisposed(target) {\n        this.perTargetData.onTargetDisposed(target);\n    }\n}\n/** @internal */\nexport class Branch extends Graphic {\n    constructor(branch, localToWorld, viewFlags, opts) {\n        super();\n        this.branch = branch;\n        this.localToWorldTransform = localToWorld;\n        if (undefined !== viewFlags)\n            branch.setViewFlags(viewFlags);\n        if (!opts)\n            return;\n        this.appearanceProvider = opts.appearanceProvider;\n        this.clips = opts.clipVolume;\n        this.iModel = opts.iModel;\n        this.frustum = opts.frustum;\n        this.viewAttachmentId = opts.viewAttachmentId;\n        if (opts.hline)\n            this.edgeSettings = EdgeSettings.create(opts.hline);\n        if (opts.classifierOrDrape instanceof PlanarClassifier)\n            this.planarClassifier = opts.classifierOrDrape;\n        else if (opts.classifierOrDrape instanceof TextureDrape)\n            this.textureDrape = opts.classifierOrDrape;\n        if (opts.secondaryClassifiers) {\n            this.secondaryClassifiers = new Array();\n            opts.secondaryClassifiers.forEach((classifier) => {\n                if (classifier instanceof PlanarClassifier)\n                    this.secondaryClassifiers?.push(classifier);\n            });\n        }\n    }\n    get isDisposed() {\n        return 0 === this.branch.entries.length;\n    }\n    dispose() {\n        this.branch.dispose();\n    }\n    get isPickable() {\n        return this.branch.entries.some((gf) => gf.isPickable);\n    }\n    collectStatistics(stats) {\n        this.branch.collectStatistics(stats);\n    }\n    shouldAddCommands(commands) {\n        const nodeId = commands.target.getAnimationTransformNodeId(this.branch.animationNodeId);\n        return undefined === nodeId || nodeId === commands.target.currentAnimationTransformNodeId;\n    }\n    addCommands(commands) {\n        if (this.shouldAddCommands(commands))\n            commands.addBranch(this);\n    }\n    addHiliteCommands(commands, pass) {\n        if (this.shouldAddCommands(commands))\n            commands.addHiliteBranch(this, pass);\n    }\n}\n/** @internal */\nexport class AnimationTransformBranch extends Graphic {\n    constructor(graphic, nodeId) {\n        super();\n        assert(graphic instanceof Graphic);\n        this.graphic = graphic;\n        this.nodeId = nodeId;\n    }\n    dispose() {\n        this.graphic.dispose();\n    }\n    get isDisposed() {\n        return this.graphic.isDisposed;\n    }\n    get isPickable() {\n        return this.graphic.isPickable;\n    }\n    collectStatistics(stats) {\n        this.graphic.collectStatistics(stats);\n    }\n    addCommands(commands) {\n        commands.target.currentAnimationTransformNodeId = this.nodeId;\n        this.graphic.addCommands(commands);\n        commands.target.currentAnimationTransformNodeId = undefined;\n    }\n    addHiliteCommands(commands, pass) {\n        commands.target.currentAnimationTransformNodeId = this.nodeId;\n        this.graphic.addHiliteCommands(commands, pass);\n        commands.target.currentAnimationTransformNodeId = undefined;\n    }\n}\n/** @internal */\nexport class WorldDecorations extends Branch {\n    constructor(viewFlags) {\n        super(new GraphicBranch(), Transform.identity, viewFlags);\n        // World decorations ignore all the symbology overrides for the \"scene\" geometry...\n        this.branch.symbologyOverrides = new FeatureSymbology.Overrides();\n    }\n    init(decs) {\n        this.branch.clear();\n        for (const dec of decs) {\n            this.branch.add(dec);\n        }\n    }\n}\n/** @internal */\nexport class GraphicsArray extends Graphic {\n    // Note: We assume the graphics array we get contains undisposed graphics to start\n    constructor(graphics) {\n        super();\n        this.graphics = graphics;\n    }\n    get isDisposed() { return 0 === this.graphics.length; }\n    get isPickable() {\n        return this.graphics.some((x) => x.isPickable);\n    }\n    dispose() {\n        for (const graphic of this.graphics)\n            dispose(graphic);\n        this.graphics.length = 0;\n    }\n    addCommands(commands) {\n        for (const graphic of this.graphics) {\n            graphic.addCommands(commands);\n        }\n    }\n    addHiliteCommands(commands, pass) {\n        for (const graphic of this.graphics) {\n            graphic.addHiliteCommands(commands, pass);\n        }\n    }\n    collectStatistics(stats) {\n        for (const graphic of this.graphics)\n            graphic.collectStatistics(stats);\n    }\n}\n//# sourceMappingURL=Graphic.js.map",
      "start": 1693508121144,
      "end": 1693508121401,
      "sourcemaps": null
    }
  ]
}
