{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tile/map/ImageryProviders/ArcGISMapLayerImageryProvider.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tiles\n */\nimport { IModelStatus, ServerError } from \"@itwin/core-common\";\nimport { IModelApp } from \"../../../IModelApp\";\nimport { ArcGisErrorCode, ArcGisGeometryReaderJSON, ArcGisGraphicsRenderer, ArcGISImageryProvider, ArcGISTileMap, ArcGisUtilities, MapCartoRectangle, MapLayerImageryProviderStatus, } from \"../../internal\";\nimport { PropertyValueFormat, StandardTypeNames } from \"@itwin/appui-abstract\";\nimport { Point2d, Range2d } from \"@itwin/core-geometry\";\nimport { Logger } from \"@itwin/core-bentley\";\nconst loggerCategory = \"MapLayerImageryProvider.ArcGISMapLayerImageryProvider\";\n/** @internal */\nexport class ArcGISIdentifyRequestUrl {\n    static fromJSON(baseUrl, json, srFractionDigits) {\n        const newUrl = new URL(baseUrl);\n        newUrl.pathname = `${newUrl.pathname}/identify`;\n        if (json.f) {\n            newUrl.searchParams.append(\"f\", json.f);\n        }\n        const geomPt = Point2d.fromJSON(json.geometry);\n        newUrl.searchParams.append(\"geometry\", `${this.toFixed(geomPt.x, srFractionDigits)},${this.toFixed(geomPt.y, srFractionDigits)}`);\n        newUrl.searchParams.append(\"geometryType\", json.geometryType);\n        if (json.sr) {\n            newUrl.searchParams.append(\"sr\", `${json.geometryType}`);\n        }\n        if (json.layers) {\n            newUrl.searchParams.append(\"layers\", `${json.layers.prefix}${json.layers.layerIds?.length ? `: ${json.layers.layerIds.join(\",\")}` : \"\"}`);\n        }\n        newUrl.searchParams.append(\"tolerance\", `${json.tolerance}`);\n        newUrl.searchParams.append(\"mapExtent\", ArcGISIdentifyRequestUrl.getExtentString(json.mapExtent, srFractionDigits));\n        newUrl.searchParams.append(\"imageDisplay\", `${json.imageDisplay.width},${json.imageDisplay.height},${json.imageDisplay.dpi}`);\n        if (json.returnGeometry !== undefined) {\n            newUrl.searchParams.append(\"returnGeometry\", json.returnGeometry ? \"true\" : \"false\");\n        }\n        if (json.maxAllowableOffset !== undefined) {\n            newUrl.searchParams.append(\"maxAllowableOffset\", `${this.toFixed(json.maxAllowableOffset, srFractionDigits)}`);\n        }\n        return newUrl;\n    }\n    static toFixed(value, srFractionDigits) {\n        return srFractionDigits === undefined ? value.toString() : value.toFixed(srFractionDigits);\n    }\n    static getExtentString(range, srFractionDigits) {\n        const extent = Range2d.fromJSON(range);\n        const extentStringArray = [];\n        extent.toFloat64Array().forEach((value) => extentStringArray.push(this.toFixed(value, srFractionDigits)));\n        return extentStringArray.join(\",\");\n    }\n}\n/** @internal */\nexport class ArcGISMapLayerImageryProvider extends ArcGISImageryProvider {\n    constructor(settings) {\n        super(settings, false);\n        this._maxDepthFromLod = 0;\n        this._minDepthFromLod = 0;\n        this._copyrightText = \"Copyright\";\n        this._tileMapSupported = false;\n        this._mapSupported = false;\n        this._tilesOnly = false;\n        this._accessClient = IModelApp.mapLayerFormatRegistry.getAccessClient(settings.formatId);\n    }\n    get _filterByCartoRange() { return false; } // Can't trust footprint ranges (USGS Hydro)\n    get minimumZoomLevel() { return Math.max(super.minimumZoomLevel, this._minDepthFromLod); }\n    get maximumZoomLevel() { return this._maxDepthFromLod > 0 ? this._maxDepthFromLod : super.maximumZoomLevel; }\n    uintToString(uintArray) {\n        return Buffer.from(uintArray).toJSON();\n    }\n    async fetchTile(row, column, zoomLevel) {\n        const tileUrl = await this.constructUrl(row, column, zoomLevel);\n        if (tileUrl.length === 0)\n            return undefined;\n        return this.fetch(new URL(tileUrl), { method: \"GET\" });\n    }\n    async loadTile(row, column, zoomLevel) {\n        if ((this.status === MapLayerImageryProviderStatus.RequireAuth)) {\n            return undefined;\n        }\n        try {\n            const tileResponse = await this.fetchTile(row, column, zoomLevel);\n            if (tileResponse === undefined)\n                return undefined;\n            if (!this._hasSuccessfullyFetchedTile) {\n                this._hasSuccessfullyFetchedTile = true;\n            }\n            return await this.getImageFromTileResponse(tileResponse, zoomLevel);\n        }\n        catch (error) {\n            Logger.logError(loggerCategory, `Error occurred when loading tile(${row},${column},${zoomLevel}) : ${error}`);\n            return undefined;\n        }\n    }\n    _generateChildIds(tile, resolveChildren) {\n        const childIds = this.getPotentialChildIds(tile);\n        if (tile.quadId.level < Math.max(1, this.minimumZoomLevel - 1)) {\n            resolveChildren(childIds);\n            return;\n        }\n        if (this._tileMap) {\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            this._tileMap.getChildrenAvailability(childIds).then((availability) => {\n                const availableChildIds = new Array();\n                for (let i = 0; i < availability.length; i++)\n                    if (availability[i])\n                        availableChildIds.push(childIds[i]);\n                resolveChildren(availableChildIds);\n            });\n        }\n        else if (this._usesCachedTiles && this.cartoRange) {\n            // Filter children by range\n            const availableChildIds = new Array();\n            // eslint-disable-next-line @typescript-eslint/prefer-for-of\n            for (let i = 0; i < childIds.length; i++) {\n                const childExtent = this.getEPSG4326Extent(childIds[i].row, childIds[i].column, childIds[i].level);\n                const childRange = MapCartoRectangle.fromDegrees(childExtent.longitudeLeft, childExtent.latitudeBottom, childExtent.longitudeRight, childExtent.latitudeTop);\n                if (childRange.intersectsRange(this.cartoRange)) {\n                    availableChildIds.push(childIds[i]);\n                }\n            }\n            resolveChildren(availableChildIds);\n        }\n        else {\n            resolveChildren(childIds); // Resolve all children\n        }\n    }\n    async initialize() {\n        const metadata = await this.getServiceJson();\n        if (metadata?.content === undefined)\n            throw new ServerError(IModelStatus.ValidationFailed, \"\");\n        const json = metadata.content;\n        if (json?.error?.code === ArcGisErrorCode.TokenRequired || json?.error?.code === ArcGisErrorCode.InvalidToken) {\n            // Check again layer status, it might have change during await.\n            if (this.status === MapLayerImageryProviderStatus.Valid) {\n                this.setStatus(MapLayerImageryProviderStatus.RequireAuth);\n                return; // By returning (i.e not throwing), we ensure the tileTree get created and current provider is preserved to report status.\n            }\n        }\n        this.serviceJson = json;\n        if (json.capabilities) {\n            const capabilities = json.capabilities.split(\",\");\n            this._querySupported = capabilities.includes(\"Query\");\n            this._tileMapSupported = capabilities.includes(\"Tilemap\");\n            this._mapSupported = capabilities.includes(\"Map\");\n            this._tilesOnly = capabilities.includes(\"TilesOnly\");\n        }\n        if (json.copyrightText)\n            this._copyrightText = json.copyrightText;\n        this._usesCachedTiles = !!json.tileInfo;\n        if (this._usesCachedTiles) {\n            // Only EPSG:3857 is supported with pre-rendered tiles.  Fall back to 'Export' queries if possible otherwise throw.\n            if (!ArcGisUtilities.isEpsg3857Compatible(json.tileInfo)) {\n                if (this._mapSupported && !this._tilesOnly) {\n                    this._usesCachedTiles = false;\n                }\n                else {\n                    throw new ServerError(IModelStatus.ValidationFailed, \"Invalid coordinate system\");\n                }\n            }\n        }\n        if (this._usesCachedTiles) {\n            // Read max LOD\n            if (json.maxScale !== undefined && json.maxScale !== 0 && Array.isArray(json.tileInfo.lods)) {\n                for (; this._maxDepthFromLod < json.tileInfo.lods.length && json.tileInfo.lods[this._maxDepthFromLod].scale > json.maxScale; this._maxDepthFromLod++)\n                    ;\n            }\n            // Create tile map object only if we are going to request tiles from this server and it support tilemap requests.\n            if (this._tileMapSupported) {\n                this._tileMap = new ArcGISTileMap(this._settings.url, this._settings, json.tileInfo?.lods?.length, this._accessClient);\n            }\n        }\n        // Read range using fullextent from service metadata\n        if (json.fullExtent) {\n            if (json.fullExtent.spatialReference.latestWkid === 3857 || json.fullExtent.spatialReference.wkid === 102100) {\n                const range3857 = Range2d.createFrom({\n                    low: { x: json.fullExtent.xmin, y: json.fullExtent.ymin },\n                    high: { x: json.fullExtent.xmax, y: json.fullExtent.ymax }\n                });\n                const west = this.getEPSG4326Lon(range3857.xLow);\n                const south = this.getEPSG4326Lat(range3857.yLow);\n                const east = this.getEPSG4326Lon(range3857.xHigh);\n                const north = this.getEPSG4326Lat(range3857.yHigh);\n                this.cartoRange = MapCartoRectangle.fromDegrees(west, south, east, north);\n            }\n        }\n        // Read minLOD if available\n        if (json.minLOD !== undefined) {\n            const minLod = parseInt(json.minLOD, 10);\n            if (!Number.isNaN(minLod)) {\n                this._minDepthFromLod = minLod;\n            }\n        }\n        else if (json.minScale) {\n            // Read min LOD using minScale\n            const minScale = json.minScale;\n            if (json.tileInfo?.lods !== undefined && Array.isArray(json.tileInfo.lods)) {\n                for (const lod of json.tileInfo.lods) {\n                    if (lod.scale < minScale) {\n                        this._minDepthFromLod = lod.level;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    addLogoCards(cards) {\n        if (!cards.dataset.arcGisLogoCard) {\n            cards.dataset.arcGisLogoCard = \"true\";\n            cards.appendChild(IModelApp.makeLogoCard({ heading: \"ArcGIS\", notice: this._copyrightText }));\n        }\n    }\n    // Translates the provided Cartographic into a EPSG:3857 point, and retrieve information.\n    // tolerance is in pixels\n    async getIdentifyData(quadId, carto, tolerance, returnGeometry, maxAllowableOffset) {\n        const bbox = this.getEPSG3857Extent(quadId.row, quadId.column, quadId.level);\n        const layerIds = new Array();\n        this._settings.subLayers.forEach((subLayer) => {\n            if (this._settings.isSubLayerVisible(subLayer))\n                layerIds.push(subLayer.idString);\n        });\n        const urlObj = ArcGISIdentifyRequestUrl.fromJSON(this._settings.url, {\n            f: \"json\",\n            geometry: { x: this.getEPSG3857X(carto.longitudeDegrees), y: this.getEPSG3857Y(carto.latitudeDegrees) },\n            geometryType: \"esriGeometryPoint\",\n            tolerance,\n            mapExtent: { low: { x: bbox.left, y: bbox.bottom }, high: { x: bbox.right, y: bbox.top } },\n            imageDisplay: { width: this.tileSize, height: this.tileSize, dpi: 96 },\n            layers: { prefix: \"visible\", layerIds },\n            returnGeometry,\n            maxAllowableOffset\n        }, 3 /* 1mm accuracy*/);\n        const response = await this.fetch(urlObj, { method: \"GET\" });\n        return response.json();\n    }\n    // Makes an identify request to ESRI MapService server, and return it as a list of formatted strings\n    async getToolTip(strings, quadId, carto, tree) {\n        await super.getToolTip(strings, quadId, carto, tree);\n        if (!this._querySupported)\n            return;\n        const stringSet = new Set();\n        const json = await this.getIdentifyData(quadId, carto, 1);\n        if (json && Array.isArray(json.results)) {\n            for (const result of json.results) {\n                if (result.attributes !== undefined && result.attributes[result.displayFieldName] !== undefined) {\n                    const thisString = `${result.displayFieldName}: ${result.attributes[result.displayFieldName]}`;\n                    if (!stringSet.has(thisString)) {\n                        strings.push(thisString);\n                        stringSet.add(thisString);\n                    }\n                }\n            }\n        }\n    }\n    // Makes an identify request to ESRI MapService , and return it as a list MapLayerFeatureInfo object\n    async getFeatureInfo(featureInfos, quadId, carto, _tree, hit) {\n        if (!this._querySupported)\n            return;\n        const tileExtent = this.getEPSG3857Extent(quadId.row, quadId.column, quadId.level);\n        const toleranceWorld = (tileExtent.top - tileExtent.bottom) / this.tileSize;\n        const maxAllowableOffsetFactor = 2;\n        const maxAllowableOffset = maxAllowableOffsetFactor * toleranceWorld;\n        const json = await this.getIdentifyData(quadId, carto, 5, true, maxAllowableOffset);\n        if (json && Array.isArray(json.results)) {\n            const renderer = new ArcGisGraphicsRenderer(hit.iModel);\n            const layerInfo = { layerName: this._settings.name, subLayerInfos: [] };\n            // The 'identify' service returns us a flat/unordered list of records..\n            // results may represent features for the a common subLayer.\n            // For simplicity, we group together features for a given sub-layer.\n            const subLayers = new Map();\n            for (const result of json.results) {\n                let subLayerInfo = subLayers.get(result.layerName);\n                if (!subLayerInfo) {\n                    subLayerInfo = {\n                        subLayerName: result.layerName ?? \"\",\n                        displayFieldName: result.displayFieldName,\n                        features: [],\n                    };\n                    subLayers.set(result.layerName, subLayerInfo);\n                }\n                const feature = { geometries: [], attributes: [] };\n                // Read all feature attributes\n                for (const [key, value] of Object.entries(result.attributes)) {\n                    // Convert everything to string for now\n                    const strValue = String(value);\n                    feature.attributes.push({\n                        value: { valueFormat: PropertyValueFormat.Primitive, value: strValue, displayValue: strValue },\n                        property: { name: key, displayLabel: key, typename: StandardTypeNames.String },\n                    });\n                }\n                // Read feature geometries\n                const geomReader = new ArcGisGeometryReaderJSON(result.geometryType, renderer);\n                await geomReader.readGeometry(result.geometry);\n                const graphics = renderer.moveGraphics();\n                feature.geometries = graphics.map((graphic) => {\n                    return { graphic };\n                });\n                subLayerInfo.features.push(feature);\n            }\n            for (const value of subLayers.values()) {\n                layerInfo.subLayerInfos.push(value);\n            }\n            featureInfos.push(layerInfo);\n        }\n    }\n    getLayerString(prefix = \"show\") {\n        const layers = new Array();\n        this._settings.subLayers.forEach((subLayer) => {\n            if (this._settings.isSubLayerVisible(subLayer))\n                layers.push(subLayer.idString);\n        });\n        return `${prefix}: ${layers.join(\",\")} `;\n    }\n    // construct the Url from the desired Tile\n    async constructUrl(row, column, zoomLevel) {\n        let tmpUrl;\n        if (this._usesCachedTiles) {\n            tmpUrl = `${this._settings.url}/tile/${zoomLevel}/${row}/${column} `;\n        }\n        else {\n            const bboxString = `${this.getEPSG3857ExtentString(row, column, zoomLevel)}&bboxSR=3857`;\n            tmpUrl = `${this._settings.url}/export?bbox=${bboxString}&size=${this.tileSize},${this.tileSize}&layers=${this.getLayerString()}&format=png&transparent=${this.transparentBackgroundString}&f=image&sr=3857&imagesr=3857`;\n        }\n        return tmpUrl;\n    }\n}\n//# sourceMappingURL=ArcGISMapLayerImageryProvider.js.map",
      "start": 1693508121788,
      "end": 1693508121884,
      "sourcemaps": null
    }
  ]
}
