{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/Texture.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { assert, BeEvent, dispose } from \"@itwin/core-bentley\";\nimport { ImageBuffer, ImageBufferFormat, ImageSource, isPowerOfTwo, nextHighestPowerOfTwo, RenderTexture, TextureTransparency, } from \"@itwin/core-common\";\nimport { getImageSourceMimeType, imageBufferToPngDataUrl, imageElementFromImageSource, openImageDataUrlInNewWindow } from \"../../common/ImageUtil\";\nimport { IModelApp } from \"../../IModelApp\";\nimport { GL } from \"./GL\";\nimport { TextureUnit } from \"./RenderFlags\";\nimport { System } from \"./System\";\nfunction computeBytesUsed(width, height, format, dataType) {\n    const bytesPerComponent = GL.Texture.DataType.UnsignedByte === dataType ? 1 : 4;\n    let componentsPerPixel = 1;\n    switch (format) {\n        case GL.Texture.Format.Rgb:\n            componentsPerPixel = 3;\n            break;\n        case GL.Texture.Format.Rgba:\n            componentsPerPixel = 4;\n            break;\n    }\n    return width * height * componentsPerPixel * bytesPerComponent;\n}\n/** Associate texture data with a WebGLTexture from a canvas, image, OR a bitmap. */\nfunction loadTexture2DImageData(handle, params, bytes, source) {\n    handle.bytesUsed = undefined !== bytes ? bytes.byteLength : computeBytesUsed(params.width, params.height, params.format, params.dataType);\n    const tex = handle.getHandle();\n    const gl = System.instance.context;\n    // Use tightly packed data\n    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);\n    // Bind the texture object; make sure we do not interfere with other active textures\n    System.instance.activateTexture2d(TextureUnit.Zero, tex);\n    // Figure out the internal format.  For all but WebGL2 float/half-float datatypes it is just same as format.\n    // TODO: probably need to just support internal format types in Texture2DCreateParams.\n    let internalFormat = params.format;\n    const context2 = System.instance.context;\n    if (GL.Texture.Format.Rgba === params.format) {\n        if (GL.Texture.DataType.Float === params.dataType)\n            internalFormat = context2.RGBA32F;\n        else if (context2.HALF_FLOAT === params.dataType)\n            internalFormat = context2.RGBA16F;\n    }\n    else if (GL.Texture.Format.DepthStencil === params.format)\n        internalFormat = context2.DEPTH24_STENCIL8;\n    // send the texture data\n    if (undefined !== source) {\n        gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, params.format, params.dataType, source);\n    }\n    else {\n        const pixelData = undefined !== bytes ? bytes : null;\n        gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, params.width, params.height, 0, params.format, params.dataType, pixelData);\n    }\n    if (params.useMipMaps) {\n        gl.generateMipmap(gl.TEXTURE_2D);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n    }\n    else {\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, params.interpolate ? gl.LINEAR : gl.NEAREST);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, params.interpolate ? gl.LINEAR : gl.NEAREST);\n    }\n    if (params.anisotropicFilter) {\n        System.instance.setMaxAnisotropy(params.anisotropicFilter);\n    }\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, params.wrapMode);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, params.wrapMode);\n    System.instance.bindTexture2d(TextureUnit.Zero, undefined);\n}\nfunction loadTextureFromBytes(handle, params, bytes) {\n    loadTexture2DImageData(handle, params, bytes);\n}\n/** Associate cube texture data with a WebGLTexture from an image. */\nfunction loadTextureCubeImageData(handle, params, images) {\n    handle.bytesUsed = computeBytesUsed(params.dim * 6, params.dim, params.format, params.dataType);\n    const tex = handle.getHandle();\n    const gl = System.instance.context;\n    // Use tightly packed data\n    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);\n    // Bind the texture object; make sure we do not interfere with other active textures\n    System.instance.activateTextureCubeMap(TextureUnit.Zero, tex);\n    const cubeTargets = [GL.Texture.Target.CubeMapPositiveX, GL.Texture.Target.CubeMapNegativeX, GL.Texture.Target.CubeMapPositiveY, GL.Texture.Target.CubeMapNegativeY, GL.Texture.Target.CubeMapPositiveZ, GL.Texture.Target.CubeMapNegativeZ];\n    for (let i = 0; i < 6; i++) {\n        gl.texImage2D(cubeTargets[i], 0, params.format, params.format, params.dataType, images[i]);\n    }\n    gl.texParameteri(GL.Texture.Target.CubeMap, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n    gl.texParameteri(GL.Texture.Target.CubeMap, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n    gl.texParameteri(GL.Texture.Target.CubeMap, gl.TEXTURE_WRAP_S, params.wrapMode);\n    gl.texParameteri(GL.Texture.Target.CubeMap, gl.TEXTURE_WRAP_T, params.wrapMode);\n    // gl.texParameteri(GL.Texture.Target.CubeMap, gl.TEXTURE_WRAP_R, params.wrapMode); // Unavailable in GLES2\n    System.instance.bindTextureCubeMap(TextureUnit.Zero, undefined);\n}\n/** Wrapper class for a WebGL texture handle and parameters specific to an individual texture.\n * @internal\n */\nexport class Texture extends RenderTexture {\n    get bytesUsed() { return this.texture.bytesUsed; }\n    get hasOwner() { return undefined !== this.ownership; }\n    get key() {\n        return typeof this.ownership !== \"string\" && typeof this.ownership?.key === \"string\" ? this.ownership.key : undefined;\n    }\n    constructor(params) {\n        super(params.type);\n        this.ownership = params.ownership;\n        this.texture = params.handle;\n        this.transparency = params.handle.format === GL.Texture.Format.Rgba ? params.transparency : TextureTransparency.Opaque;\n    }\n    get isDisposed() { return this.texture.isDisposed; }\n    /** Free this object in the WebGL wrapper. */\n    dispose() {\n        dispose(this.texture);\n    }\n}\nfunction getDataType(data) {\n    return data instanceof Float32Array ? GL.Texture.DataType.Float : GL.Texture.DataType.UnsignedByte;\n}\n/** Parameters used internally to define how to create a texture for use with WebGL. */\nclass Texture2DCreateParams {\n    constructor(width, height, format, dataType, wrapMode, loadImageData, useMipMaps, interpolate, anisotropicFilter, dataBytes) {\n        this.width = width;\n        this.height = height;\n        this.format = format;\n        this.dataType = dataType;\n        this.wrapMode = wrapMode;\n        this.loadImageData = loadImageData;\n        this.useMipMaps = useMipMaps;\n        this.interpolate = interpolate;\n        this.anisotropicFilter = anisotropicFilter;\n        this.dataBytes = dataBytes;\n    }\n    static createForData(width, height, data, preserveData = false, wrapMode = GL.Texture.WrapMode.ClampToEdge, format = GL.Texture.Format.Rgba) {\n        const bytes = (preserveData && data instanceof Uint8Array) ? data : undefined;\n        return new Texture2DCreateParams(width, height, format, getDataType(data), wrapMode, (tex, params) => loadTextureFromBytes(tex, params, data), undefined, undefined, undefined, bytes);\n    }\n    static createForImageBuffer(image, type) {\n        const props = this.getImageProperties(type);\n        if (ImageBufferFormat.Rgb === image.format)\n            props.format = GL.Texture.Format.Rgb;\n        return new Texture2DCreateParams(image.width, image.height, props.format, GL.Texture.DataType.UnsignedByte, props.wrapMode, (tex, params) => loadTextureFromBytes(tex, params, image.data), props.useMipMaps, props.interpolate);\n    }\n    static createForAttachment(width, height, format, dataType) {\n        return new Texture2DCreateParams(width, height, format, dataType, GL.Texture.WrapMode.ClampToEdge, (tex, params) => loadTextureFromBytes(tex, params), undefined, undefined);\n    }\n    static createForImage(image, type) {\n        const props = this.getImageProperties(type);\n        let targetWidth = image.naturalWidth;\n        let targetHeight = image.naturalHeight;\n        if (RenderTexture.Type.Glyph === type) {\n            targetWidth = nextHighestPowerOfTwo(targetWidth);\n            targetHeight = nextHighestPowerOfTwo(targetHeight);\n        }\n        else if (!System.instance.supportsNonPowerOf2Textures && (!isPowerOfTwo(targetWidth) || !isPowerOfTwo(targetHeight))) {\n            if (GL.Texture.WrapMode.ClampToEdge === props.wrapMode) {\n                // NPOT are supported but not mipmaps\n                // Probably on poor hardware so I choose to disable mipmaps for lower memory usage over quality. If quality is required we need to resize the image to a pow of 2.\n                // Above comment is not necessarily true - WebGL doesn't support NPOT mipmapping, only supporting base NPOT caps\n                props.useMipMaps = undefined;\n            }\n            else if (GL.Texture.WrapMode.Repeat === props.wrapMode) {\n                targetWidth = nextHighestPowerOfTwo(targetWidth);\n                targetHeight = nextHighestPowerOfTwo(targetHeight);\n            }\n        }\n        // Cap texture dimensions to system WebGL capabilities\n        const maxTexSize = System.instance.maxTextureSize;\n        targetWidth = Math.min(targetWidth, maxTexSize);\n        targetHeight = Math.min(targetHeight, maxTexSize);\n        let element = image;\n        if (targetWidth !== image.naturalWidth || targetHeight !== image.naturalHeight) {\n            // Resize so dimensions are powers-of-two\n            const canvas = document.createElement(\"canvas\");\n            canvas.width = targetWidth;\n            canvas.height = targetHeight;\n            const context = canvas.getContext(\"2d\");\n            context.drawImage(image, 0, 0, canvas.width, canvas.height);\n            element = canvas;\n        }\n        return new Texture2DCreateParams(targetWidth, targetHeight, props.format, GL.Texture.DataType.UnsignedByte, props.wrapMode, (tex, params) => loadTexture2DImageData(tex, params, undefined, element), props.useMipMaps, props.interpolate, props.anisotropicFilter);\n    }\n    static createForImageBitmap(image, type) {\n        const props = this.getImageProperties(type);\n        let targetWidth = image.width;\n        let targetHeight = image.height;\n        if (RenderTexture.Type.Glyph === type) {\n            targetWidth = nextHighestPowerOfTwo(targetWidth);\n            targetHeight = nextHighestPowerOfTwo(targetHeight);\n        }\n        else if (!System.instance.supportsNonPowerOf2Textures && (!isPowerOfTwo(targetWidth) || !isPowerOfTwo(targetHeight))) {\n            if (GL.Texture.WrapMode.ClampToEdge === props.wrapMode) {\n                // NPOT are supported but not mipmaps\n                // Probably on poor hardware so I choose to disable mipmaps for lower memory usage over quality. If quality is required we need to resize the image to a pow of 2.\n                // Above comment is not necessarily true - WebGL doesn't support NPOT mipmapping, only supporting base NPOT caps\n                props.useMipMaps = undefined;\n            }\n            else if (GL.Texture.WrapMode.Repeat === props.wrapMode) {\n                targetWidth = nextHighestPowerOfTwo(targetWidth);\n                targetHeight = nextHighestPowerOfTwo(targetHeight);\n            }\n        }\n        // If we have to resize, use a canvas\n        let source = image;\n        if (image.width !== targetWidth || image.height !== targetHeight) {\n            const canvas = document.createElement(\"canvas\");\n            canvas.width = targetWidth;\n            canvas.height = targetHeight;\n            const context = canvas.getContext(\"2d\");\n            context.drawImage(image, 0, 0, canvas.width, canvas.height);\n            source = canvas;\n        }\n        return new Texture2DCreateParams(targetWidth, targetHeight, props.format, GL.Texture.DataType.UnsignedByte, props.wrapMode, (tex, params) => loadTexture2DImageData(tex, params, undefined, source), props.useMipMaps, props.interpolate, props.anisotropicFilter);\n    }\n    static getImageProperties(type) {\n        const isSky = RenderTexture.Type.SkyBox === type;\n        const isTile = RenderTexture.Type.TileSection === type;\n        const isThematic = RenderTexture.Type.ThematicGradient === type;\n        const isFilteredTile = RenderTexture.Type.FilteredTileSection === type;\n        const maxAnisotropicFilterLevel = 16;\n        const wrapMode = RenderTexture.Type.Normal === type ? GL.Texture.WrapMode.Repeat : GL.Texture.WrapMode.ClampToEdge;\n        const useMipMaps = (!isSky && !isTile && !isFilteredTile && !isThematic) ? true : undefined;\n        const interpolate = isThematic ? undefined : true;\n        const anisotropicFilter = isFilteredTile ? maxAnisotropicFilterLevel : undefined;\n        // Always use RGBA. RGB is much slower and almost certainly does not actually save any GPU memory.\n        const format = GL.Texture.Format.Rgba;\n        return { format, wrapMode, useMipMaps, interpolate, anisotropicFilter };\n    }\n}\nTexture2DCreateParams.placeholderParams = new Texture2DCreateParams(1, 1, GL.Texture.Format.Rgba, GL.Texture.DataType.UnsignedByte, GL.Texture.WrapMode.ClampToEdge, (_tex, _params) => undefined);\nclass TextureCubeCreateParams {\n    constructor(dim, format, dataType, wrapMode, loadImageData) {\n        this.dim = dim;\n        this.format = format;\n        this.dataType = dataType;\n        this.wrapMode = wrapMode;\n        this.loadImageData = loadImageData;\n    }\n    static createForCubeImages(posX, negX, posY, negY, posZ, negZ) {\n        const targetDim = posX.naturalWidth;\n        if (posX.naturalHeight !== targetDim) // Cube texture dimensions must match (width must equal height)\n            return undefined;\n        const images = [posX, negX, posY, negY, posZ, negZ];\n        for (let i = 1; i < images.length; i++) { // Dimensions of all six sides must match each other\n            if (images[i].naturalWidth !== targetDim || images[i].naturalHeight !== targetDim)\n                return undefined;\n        }\n        return new TextureCubeCreateParams(targetDim, GL.Texture.Format.Rgba, GL.Texture.DataType.UnsignedByte, GL.Texture.WrapMode.ClampToEdge, (tex, params) => loadTextureCubeImageData(tex, params, images));\n    }\n}\n/** Wraps a WebGLTextureHandle\n * @internal\n */\nexport class TextureHandle {\n    get bytesUsed() { return this._bytesUsed; }\n    set bytesUsed(bytesUsed) {\n        // assert(0 === this.bytesUsed);\n        this._bytesUsed = bytesUsed;\n    }\n    /** Get the WebGLTexture for this TextureHandle. */\n    getHandle() { return this._glTexture; }\n    get isDisposed() { return this._glTexture === undefined; }\n    dispose() {\n        if (!this.isDisposed) {\n            System.instance.disposeTexture(this._glTexture);\n            this._glTexture = undefined;\n            this.bytesUsed = 0;\n        }\n    }\n    /** Create a 2D texture for use as a color attachment for rendering */\n    static createForAttachment(width, height, format, dataType) {\n        return Texture2DHandle.createForAttachment(width, height, format, dataType);\n    }\n    /** Create a 2D texture to hold non-image data */\n    static createForData(width, height, data, wantPreserveData = false, wrapMode = GL.Texture.WrapMode.ClampToEdge, format = GL.Texture.Format.Rgba) {\n        return Texture2DHandle.createForData(width, height, data, wantPreserveData, wrapMode, format);\n    }\n    /** Create a 2D texture from a bitmap */\n    static createForImageBuffer(image, type) {\n        return Texture2DHandle.createForImageBuffer(image, type);\n    }\n    /** Create a 2D texture from an HTMLImageElement. */\n    static createForImage(image, type) {\n        return Texture2DHandle.createForImage(image, type);\n    }\n    /** Create a 2D texture from an ImageBitmap. */\n    static createForImageBitmap(image, type) {\n        return Texture2DHandle.createForImageBitmap(image, type);\n    }\n    /** Create a cube map texture from six HTMLImageElement objects. */\n    static createForCubeImages(posX, negX, posY, negY, posZ, negZ) {\n        return TextureCubeHandle.createForCubeImages(posX, negX, posY, negY, posZ, negZ);\n    }\n    static createForElement(id, imodel, type, format, onLoaded) {\n        return Texture2DHandle.createForElement(id, imodel, type, format, onLoaded);\n    }\n    constructor(glTexture) {\n        this._bytesUsed = 0;\n        this._glTexture = glTexture;\n    }\n    /** For debugging purposes, open a new window containing this texture as an image. */\n    showDebugImage() {\n        const gl = System.instance.context;\n        const fbo = gl.createFramebuffer();\n        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.getHandle(), 0);\n        if (gl.FRAMEBUFFER_COMPLETE === gl.checkFramebufferStatus(gl.FRAMEBUFFER)) {\n            const w = this.width;\n            const h = this.height;\n            const pixels = new Uint8Array(w * h * 4);\n            gl.readPixels(0, 0, w, h, gl.RGBA, gl.UNSIGNED_BYTE, pixels);\n            const buffer = ImageBuffer.create(pixels, ImageBufferFormat.Rgba, w);\n            const url = imageBufferToPngDataUrl(buffer, false);\n            openImageDataUrlInNewWindow(url, \"Classifiers\");\n        }\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        gl.deleteFramebuffer(fbo);\n    }\n}\n/** @internal */\nclass Texture2DHandle extends TextureHandle {\n    get width() { return this._width; }\n    get height() { return this._height; }\n    get format() { return this._format; }\n    get dataType() { return this._dataType; }\n    get dataBytes() { return this._dataBytes; }\n    /** Bind specified texture handle to specified texture unit. */\n    static bindTexture(texUnit, glTex) {\n        assert(!(glTex instanceof TextureHandle));\n        System.instance.bindTexture2d(texUnit, glTex);\n    }\n    /** Bind the specified texture to a uniform sampler2D */\n    static bindSampler(uniform, tex, unit) {\n        assert(!(tex instanceof TextureHandle));\n        this.bindTexture(unit, tex);\n        uniform.setUniform1i(unit - TextureUnit.Zero);\n    }\n    /** Bind texture handle (if available) associated with an instantiation of this class to specified texture unit. */\n    bind(texUnit) {\n        if (undefined === this._glTexture)\n            return false;\n        Texture2DHandle.bindTexture(texUnit, this._glTexture);\n        return true;\n    }\n    /** Bind this texture to a uniform sampler2D */\n    bindSampler(uniform, unit) {\n        if (undefined !== this._glTexture)\n            Texture2DHandle.bindSampler(uniform, this._glTexture, unit);\n    }\n    /** Update the 2D texture contents. */\n    update(updater) {\n        if (0 === this.width || 0 === this.height || undefined === this._dataBytes || 0 === this._dataBytes.length) {\n            assert(false);\n            return false;\n        }\n        if (!updater.modified)\n            return false;\n        return this.replaceTextureData(this._dataBytes);\n    }\n    /** Replace the 2D texture contents. */\n    replaceTextureData(data) {\n        assert((GL.Texture.DataType.Float === this._dataType) === (data instanceof Float32Array));\n        const tex = this.getHandle();\n        if (undefined === tex)\n            return false;\n        const gl = System.instance.context;\n        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);\n        // Go through System to ensure we don't interfere with currently-bound textures!\n        System.instance.activateTexture2d(TextureUnit.Zero, tex);\n        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, this.width, this.height, this._format, this._dataType, data);\n        System.instance.bindTexture2d(TextureUnit.Zero, undefined);\n        return true;\n    }\n    static create(params) {\n        const glTex = System.instance.context.createTexture();\n        return null !== glTex ? new Texture2DHandle(glTex, params) : undefined;\n    }\n    /** Create a texture for use as a color attachment for rendering */\n    static createForAttachment(width, height, format, dataType) {\n        return this.create(Texture2DCreateParams.createForAttachment(width, height, format, dataType));\n    }\n    /** Create a texture to hold non-image data */\n    static createForData(width, height, data, wantPreserveData = false, wrapMode = GL.Texture.WrapMode.ClampToEdge, format = GL.Texture.Format.Rgba) {\n        return this.create(Texture2DCreateParams.createForData(width, height, data, wantPreserveData, wrapMode, format));\n    }\n    /** Create a texture from a bitmap */\n    static createForImageBuffer(image, type) {\n        if (RenderTexture.Type.TileSection !== type && RenderTexture.Type.ThematicGradient !== type)\n            assert(isPowerOfTwo(image.width) && isPowerOfTwo(image.height), \"###TODO: Resize image dimensions to powers-of-two if necessary\");\n        return this.create(Texture2DCreateParams.createForImageBuffer(image, type));\n    }\n    /** Create a 2D texture from an HTMLImageElement. */\n    static createForImage(image, type) {\n        return this.create(Texture2DCreateParams.createForImage(image, type));\n    }\n    /** Create a 2D texture from an ImageBitmap. */\n    static createForImageBitmap(image, type) {\n        return this.create(Texture2DCreateParams.createForImageBitmap(image, type));\n    }\n    static createForElement(id, imodel, type, format, onLoaded) {\n        // set a placeholder texture while we wait for the external texture to load\n        const handle = this.createForData(1, 1, this._placeHolderTextureData, undefined, undefined, GL.Texture.Format.Rgba);\n        if (undefined === handle)\n            return undefined;\n        // kick off loading the texture from the backend\n        ExternalTextureLoader.instance.loadTexture(handle, id, imodel, type, format, onLoaded);\n        return handle;\n    }\n    reload(params) {\n        this._width = params.width;\n        this._height = params.height;\n        this._format = params.format;\n        this._dataType = params.dataType;\n        this._dataBytes = params.dataBytes;\n        params.loadImageData(this, params);\n    }\n    constructor(glTexture, params) {\n        super(glTexture);\n        this._width = params.width;\n        this._height = params.height;\n        this._format = params.format;\n        this._dataType = params.dataType;\n        this._dataBytes = params.dataBytes;\n        params.loadImageData(this, params);\n    }\n}\nTexture2DHandle._placeHolderTextureData = new Uint8Array([128, 128, 128, 255]);\nexport { Texture2DHandle };\n/** @internal */\nclass ExternalTextureLoader {\n    get numActiveRequests() { return this._activeRequests.length; }\n    get numPendingRequests() { return this._pendingRequests.length; }\n    get maxActiveRequests() { return this._maxActiveRequests; }\n    constructor(maxActiveRequests) {\n        this.onTexturesLoaded = new BeEvent();\n        this._activeRequests = [];\n        this._pendingRequests = [];\n        this._convertRequests = [];\n        this._convertPending = false;\n        this._maxActiveRequests = maxActiveRequests;\n    }\n    async _nextRequest(prevReq) {\n        this._activeRequests.splice(this._activeRequests.indexOf(prevReq), 1);\n        if (this._activeRequests.length < this._maxActiveRequests && this._pendingRequests.length > 0) {\n            const req = this._pendingRequests.shift();\n            await this._activateRequest(req);\n        }\n        if (this._activeRequests.length < 1 && this._pendingRequests.length < 1)\n            this.onTexturesLoaded.raiseEvent();\n    }\n    async _activateRequest(req) {\n        if (req.imodel.isClosed)\n            return;\n        this._activeRequests.push(req);\n        try {\n            if (!req.imodel.isClosed) {\n                const maxTextureSize = System.instance.maxTexSizeAllow;\n                const texData = await req.imodel.queryTextureData({ name: req.name, maxTextureSize });\n                if (undefined !== texData) {\n                    const cnvReq = { req, texData };\n                    this._convertRequests.push(cnvReq);\n                    // _convertPending is used to prevent overlapping calls to _convertTexture (from overlapping calls to _activateRequest)\n                    // it has been put on the list, so if it doesn't get converted here it will get converted by the loop that is converting the current one\n                    do {\n                        if (!this._convertPending)\n                            await this._convertTexture();\n                    } while (!this._convertPending && this._convertRequests.length > 0);\n                    if (!req.imodel.isClosed) {\n                        IModelApp.tileAdmin.invalidateAllScenes();\n                        if (undefined !== req.onLoaded)\n                            req.onLoaded(req, texData);\n                    }\n                }\n            }\n        }\n        catch (_e) { }\n        return this._nextRequest(req);\n    }\n    async _convertTexture() {\n        this._convertPending = true;\n        try {\n            const cnvReq = this._convertRequests.shift();\n            if (undefined !== cnvReq) {\n                const imageSource = new ImageSource(cnvReq.texData.bytes, cnvReq.texData.format);\n                if (System.instance.supportsCreateImageBitmap) {\n                    const blob = new Blob([imageSource.data], { type: getImageSourceMimeType(imageSource.format) });\n                    const image = await createImageBitmap(blob, 0, 0, cnvReq.texData.width, cnvReq.texData.height);\n                    if (!cnvReq.req.imodel.isClosed) {\n                        cnvReq.req.handle.reload(Texture2DCreateParams.createForImageBitmap(image, cnvReq.req.type));\n                    }\n                }\n                else {\n                    const image = await imageElementFromImageSource(imageSource);\n                    if (!cnvReq.req.imodel.isClosed) {\n                        cnvReq.req.handle.reload(Texture2DCreateParams.createForImage(image, cnvReq.req.type));\n                    }\n                }\n            }\n        }\n        catch (_e) { }\n        this._convertPending = false;\n    }\n    _requestExists(reqToCheck) {\n        for (const r of this._activeRequests)\n            if (reqToCheck.name === r.name && reqToCheck.imodel === r.imodel)\n                return true;\n        for (const r of this._pendingRequests)\n            if (reqToCheck.name === r.name && reqToCheck.imodel === r.imodel)\n                return true;\n        return false;\n    }\n    loadTexture(handle, name, imodel, type, format, onLoaded) {\n        const req = { handle, name, imodel, type, format, onLoaded };\n        if (this._requestExists(req))\n            return;\n        if (this._activeRequests.length + 1 > this._maxActiveRequests) {\n            this._pendingRequests.push(req);\n        }\n        else\n            this._activateRequest(req); // eslint-disable-line @typescript-eslint/no-floating-promises\n    }\n}\nExternalTextureLoader.instance = new ExternalTextureLoader(2);\nexport { ExternalTextureLoader };\n/** @internal */\nexport class TextureCubeHandle extends TextureHandle {\n    get width() { return this._dim; }\n    get height() { return this._dim; }\n    get format() { return this._format; }\n    get dataType() { return this._dataType; }\n    get dataBytes() { return undefined; }\n    /** Bind specified cubemap texture handle to specified texture unit. */\n    static bindTexture(texUnit, glTex) {\n        assert(!(glTex instanceof TextureHandle));\n        System.instance.bindTextureCubeMap(texUnit, glTex);\n    }\n    /** Bind the specified texture to a uniform sampler2D */\n    static bindSampler(uniform, tex, unit) {\n        assert(!(tex instanceof TextureHandle));\n        this.bindTexture(unit, tex);\n        uniform.setUniform1i(unit - TextureUnit.Zero);\n    }\n    /** Bind texture handle (if available) associated with an instantiation of this class to specified texture unit. */\n    bind(texUnit) {\n        if (undefined === this._glTexture)\n            return false;\n        TextureCubeHandle.bindTexture(texUnit, this._glTexture);\n        return true;\n    }\n    /** Bind this texture to a uniform sampler2D */\n    bindSampler(uniform, unit) {\n        if (undefined !== this._glTexture)\n            TextureCubeHandle.bindSampler(uniform, this._glTexture, unit);\n    }\n    static create(params) {\n        const glTex = System.instance.context.createTexture();\n        return null !== glTex ? new TextureCubeHandle(glTex, params) : undefined;\n    }\n    /** Create a cube map texture from six HTMLImageElement objects. */\n    static createForCubeImages(posX, negX, posY, negY, posZ, negZ) {\n        const params = TextureCubeCreateParams.createForCubeImages(posX, negX, posY, negY, posZ, negZ);\n        return params !== undefined ? this.create(params) : undefined;\n    }\n    constructor(glTexture, params) {\n        super(glTexture);\n        this._dim = params.dim;\n        this._format = params.format;\n        this._dataType = params.dataType;\n        params.loadImageData(this, params);\n    }\n}\n/** @internal */\nexport class Texture2DDataUpdater {\n    constructor(data) {\n        this.modified = false;\n        this.data = data;\n    }\n    setByteAtIndex(index, byte) {\n        assert(index < this.data.length);\n        if (byte !== this.data[index]) {\n            this.data[index] = byte;\n            this.modified = true;\n        }\n    }\n    setOvrFlagsAtIndex(index, value) {\n        assert(index < this.data.length - 1);\n        assert(value < 0xffff);\n        this.setByteAtIndex(index, value & 0xff);\n        this.setByteAtIndex(index + 1, (value & 0xff00) >> 8);\n    }\n    getByteAtIndex(index) {\n        assert(index < this.data.length);\n        return this.data[index];\n    }\n    getOvrFlagsAtIndex(index) {\n        const lo = this.getByteAtIndex(index);\n        const hi = this.getByteAtIndex(index + 1);\n        return lo | (hi << 8);\n    }\n}\n//# sourceMappingURL=Texture.js.map",
      "start": 1693508121280,
      "end": 1693508121517,
      "sourcemaps": null
    }
  ]
}
