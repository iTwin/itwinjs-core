{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/curve/Arc3d.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\nimport { AxisOrder, Geometry } from \"../Geometry\";\nimport { Angle } from \"../geometry3d/Angle\";\nimport { AngleSweep } from \"../geometry3d/AngleSweep\";\nimport { Matrix3d } from \"../geometry3d/Matrix3d\";\nimport { Plane3dByOriginAndVectors } from \"../geometry3d/Plane3dByOriginAndVectors\";\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\nimport { Range1d, Range3d } from \"../geometry3d/Range\";\nimport { Ray3d } from \"../geometry3d/Ray3d\";\nimport { SineCosinePolynomial, SmallSystem, TrigPolynomial } from \"../numerics/Polynomials\";\nimport { CurveExtendMode, CurveExtendOptions } from \"./CurveExtendMode\";\nimport { CurveIntervalRole, CurveLocationDetail, CurveSearchStatus } from \"./CurveLocationDetail\";\nimport { CurvePrimitive } from \"./CurvePrimitive\";\nimport { CurveOffsetXYHandler } from \"./internalContexts/CurveOffsetXYHandler\";\nimport { PlaneAltitudeRangeContext } from \"./internalContexts/PlaneAltitudeRangeContext\";\nimport { LineString3d } from \"./LineString3d\";\nimport { OffsetOptions } from \"./OffsetOptions\";\nimport { StrokeOptions } from \"./StrokeOptions\";\n/**\n * Circular or elliptic arc.\n * * The angle to point equation is:\n * * `X = center + cos(theta) * vector0 + sin(theta) * vector90`\n * * When the two vectors are perpendicular and have equal length, it is a true circle.\n * * Non-perpendicular vectors are always elliptic.\n * * Vectors of unequal length are always elliptic.\n * * To create an ellipse in the common \"major and minor axis\" form of an ellipse:\n * ** vector0 is the vector from the center to the major axis extreme.\n * ** vector90 is the vector from the center to the minor axis extreme.\n * ** note that constructing the vectors to the extreme points makes them perpendicular.\n * * The method toScaledMatrix3d() can be called to convert the unrestricted vector0,vector90 to perpendicular form.\n * * The unrestricted form is much easier to work with for common calculations -- stroking, projection to 2d,\n * intersection with plane.\n * @public\n */\nclass Arc3d extends CurvePrimitive {\n    /** Test if this and other are both instances of Arc3d. */\n    isSameGeometryClass(other) {\n        return other instanceof Arc3d;\n    }\n    /** Read property for (clone of) center */\n    get center() {\n        return this._center.clone();\n    }\n    /** Read property for (clone of) vector0 */\n    get vector0() {\n        return this._matrix.columnX();\n    }\n    /** Read property for (clone of) vector90 */\n    get vector90() {\n        return this._matrix.columnY();\n    }\n    /** Read property for (clone of) plane normal, with arbitrary length. */\n    get perpendicularVector() {\n        return this._matrix.columnZ();\n    }\n    /** Read property for (clone of) matrix of vector0, vector90, unit normal */\n    matrixClone() {\n        return this._matrix.clone();\n    }\n    /** Read property for (reference to) matrix of vector0, vector90, unit normal */\n    get matrixRef() {\n        return this._matrix;\n    }\n    /** Sweep of the angle. */\n    get sweep() {\n        return this._sweep;\n    }\n    set sweep(value) {\n        this._sweep.setFrom(value);\n    }\n    /** An Arc3d extends along its complete elliptic arc */\n    get isExtensibleFractionSpace() {\n        return true;\n    }\n    // constructor copies the pointers\n    constructor(center, matrix, sweep) {\n        super();\n        /** String name for schema properties */\n        this.curvePrimitiveType = \"arc\";\n        this._center = center;\n        this._matrix = matrix;\n        this._sweep = sweep;\n    }\n    /**\n     * Return a clone of the arc, with transform applied\n     * @param transform\n     */\n    cloneTransformed(transform) {\n        const c = this.clone();\n        c.tryTransformInPlace(transform);\n        return c;\n    }\n    /**\n     * Redefine the arc with (captured references to) given data.\n     * @param center arc center\n     * @param matrix matrix with columns vector0, vector 90, and their unit cross product\n     * @param sweep angle sweep\n     */\n    setRefs(center, matrix, sweep) {\n        this._center = center;\n        this._matrix = matrix;\n        this._sweep = sweep;\n    }\n    /**\n     * Redefine the arc with (clones of) given data.\n     * @param center arc center\n     * @param matrix matrix with columns vector0, vector 90, and their unit cross product\n     * @param sweep angle sweep\n     */\n    set(center, matrix, sweep) {\n        this.setRefs(center.clone(), matrix.clone(), sweep ? sweep.clone() : AngleSweep.create360());\n    }\n    /** Copy center, matrix, and sweep from other Arc3d */\n    setFrom(other) {\n        this._center.setFrom(other._center);\n        this._matrix.setFrom(other._matrix);\n        this._sweep.setFrom(other._sweep);\n    }\n    /** Return a clone of this arc. */\n    clone() {\n        return new Arc3d(this._center.clone(), this._matrix.clone(), this._sweep.clone());\n    }\n    /**\n     * Create an arc, capturing references to center, matrix and sweep.\n     * @param center center point\n     * @param matrix matrix with columns vector0, vector90, and unit cross product\n     * @param sweep sweep limits\n     * @param result optional preallocated result.\n     */\n    static createRefs(center, matrix, sweep, result) {\n        if (result) {\n            result.setRefs(center, matrix, sweep);\n            return result;\n        }\n        return new Arc3d(center, matrix, sweep);\n    }\n    /**\n     * Create an arc from center, x column to be scaled, and y column to be scaled.\n     * @param center center of ellipse\n     * @param matrix matrix whose x and y columns are unit vectors to be scaled by radius0 and radius90\n     * @param radius0 radius in x direction.\n     * @param radius90 radius in y direction.\n     * @param sweep sweep limits\n     * @param result optional preallocated result.\n     */\n    static createScaledXYColumns(center, matrix, radius0, radius90, sweep, result) {\n        const vector0 = matrix.columnX();\n        const vector90 = matrix.columnY();\n        return Arc3d.create(center, vector0.scale(radius0, vector0), vector90.scale(radius90, vector90), sweep, result);\n    }\n    /**\n     * Create a (full circular) arc from center, normal and radius\n     * @param center center of ellipse.  If undefined, center at 000\n     * @param normal normal vector\n     * @param radius radius in x direction.\n     * @param result optional preallocated result.\n     */\n    static createCenterNormalRadius(center, normal, radius, result) {\n        const frame = Matrix3d.createRigidHeadsUp(normal);\n        return Arc3d.createScaledXYColumns(center, frame, radius, radius, undefined, result);\n    }\n    /**\n     * Create an arc by center with vectors to points at 0 and 90 degrees in parameter space.\n     * @param center arc center\n     * @param vector0 vector to 0 degrees (commonly major axis)\n     * @param vector90 vector to 90 degree point (commonly minor axis)\n     * @param sweep sweep limits\n     * @param result optional preallocated result\n     */\n    static create(center, vector0, vector90, sweep, result) {\n        const normal = vector0.unitCrossProductWithDefault(vector90, 0, 0, 0); // normal will be 000 for degenerate case\n        const matrix = Matrix3d.createColumns(vector0, vector90, normal);\n        return Arc3d.createRefs(center !== undefined ? center.clone() : Point3d.create(0, 0, 0), matrix, sweep ? sweep.clone() : AngleSweep.create360(), result);\n    }\n    /**\n     * Return a clone of this arc, projected to given z value.\n     * * If `z` is omitted, the clone is at the z of the center.\n     * * This function projects the arc into a plane parallel to xy-plane.\n     * * Note that projection to fixed z can change circle into ellipse (and (rarely) ellipse to circle)\n     */\n    cloneAtZ(z) {\n        if (z === undefined)\n            z = this._center.z;\n        return Arc3d.createXYZXYZXYZ(this._center.x, this._center.y, this._center.z, this._matrix.coffs[0], this._matrix.coffs[3], 0, this._matrix.coffs[1], this._matrix.coffs[4], 0, this._sweep);\n    }\n    /**\n     * Create an arc by center (cx,cy,xz) with vectors (ux,uy,uz) and (vx,vy,vz) to points at 0 and 90 degrees in\n     * parameter space.\n     * @param result optional preallocated result\n     */\n    static createXYZXYZXYZ(cx, cy, cz, ux, uy, uz, vx, vy, vz, sweep, result) {\n        return Arc3d.create(Point3d.create(cx, cy, cz), Vector3d.create(ux, uy, uz), Vector3d.create(vx, vy, vz), sweep, result);\n    }\n    /**\n     * Return a quick estimate of the eccentricity of the ellipse.\n     * * The estimator is the cross magnitude of the product of vectors U and V, divided by square of the larger magnitude\n     * * for typical Arc3d with perpendicular UV, this is exactly the small axis divided by large.\n     * * note that the eccentricity is AT MOST ONE.\n     */\n    quickEccentricity() {\n        const magX = this._matrix.columnXMagnitude();\n        const magY = this._matrix.columnYMagnitude();\n        const jacobian = this._matrix.columnXYCrossProductMagnitude();\n        const largeAxis = Geometry.maxXY(magX, magY);\n        return jacobian / (largeAxis * largeAxis);\n    }\n    /**\n     * Create a circular arc defined by start point, any intermediate point, and end point.\n     * If the points are colinear, assemble them into a linestring.\n     */\n    static createCircularStartMiddleEnd(pointA, pointB, pointC, result) {\n        const vectorAB = Vector3d.createStartEnd(pointA, pointB);\n        const vectorAC = Vector3d.createStartEnd(pointA, pointC);\n        const ab = vectorAB.magnitude();\n        const bc = vectorAC.magnitude();\n        const normal = vectorAB.sizedCrossProduct(vectorAC, Math.sqrt(ab * bc));\n        if (normal) {\n            const vectorToCenter = SmallSystem.linearSystem3d(normal.x, normal.y, normal.z, vectorAB.x, vectorAB.y, vectorAB.z, vectorAC.x, vectorAC.y, vectorAC.z, 0, // vectorToCenter DOT normal = 0\n            0.5 * ab * ab, // vectorToCenter DOT vectorBA = 0.5 * vectorBA DOT vectorBA  (Rayleigh quotient)\n            0.5 * bc * bc); // vectorToCenter DOT vectorBC = 0.5 * vectorBC DOT vectorBC  (Rayleigh quotient)\n            if (vectorToCenter) {\n                const center = Point3d.create(pointA.x, pointA.y, pointA.z).plus(vectorToCenter);\n                const vectorX = Vector3d.createStartEnd(center, pointA);\n                const vectorY = Vector3d.createRotateVectorAroundVector(vectorX, normal, Angle.createDegrees(90));\n                if (vectorY) {\n                    const vectorCenterToC = Vector3d.createStartEnd(center, pointC);\n                    const sweepAngle = vectorX.signedAngleTo(vectorCenterToC, normal);\n                    if (sweepAngle.radians < 0.0)\n                        sweepAngle.addMultipleOf2PiInPlace(1.0);\n                    return Arc3d.create(center, vectorX, vectorY, AngleSweep.createStartEndRadians(0.0, sweepAngle.radians), result);\n                }\n            }\n        }\n        return LineString3d.create(pointA, pointB, pointC);\n    }\n    /** The arc has simple proportional arc length if and only if it is a circular arc. */\n    getFractionToDistanceScale() {\n        const radius = this.circularRadius();\n        if (radius !== undefined)\n            return Math.abs(radius * this._sweep.sweepRadians);\n        return undefined;\n    }\n    /**\n     * Convert a fractional position to xyz coordinates\n     * @param fraction fractional position on arc\n     * @param result optional preallocated result\n     */\n    fractionToPoint(fraction, result) {\n        const radians = this._sweep.fractionToRadians(fraction);\n        return this._matrix.originPlusMatrixTimesXY(this._center, Math.cos(radians), Math.sin(radians), result);\n    }\n    /**\n     * Convert fractional arc and radial positions to xyz coordinates\n     * @param fraction fractional position on arc\n     * @param result optional preallocated result\n     */\n    fractionAndRadialFractionToPoint(arcFraction, radialFraction, result) {\n        const radians = this._sweep.fractionToRadians(arcFraction);\n        return this._matrix.originPlusMatrixTimesXY(this._center, radialFraction * Math.cos(radians), radialFraction * Math.sin(radians), result);\n    }\n    /**\n     * Convert a fractional position to xyz coordinates and derivative with respect to fraction.\n     * @param fraction fractional position on arc\n     * @param result optional preallocated result\n     */\n    fractionToPointAndDerivative(fraction, result) {\n        result = this.radiansToPointAndDerivative(this._sweep.fractionToRadians(fraction), result);\n        result.direction.scaleInPlace(this._sweep.sweepRadians);\n        return result;\n    }\n    /**\n     * Construct a plane with\n     * * origin at the fractional position along the arc\n     * * x axis is the first derivative, i.e. tangent along the arc\n     * * y axis is the second derivative, i.e. in the plane and on the center side of the tangent.\n     * If the arc is circular, the second derivative is directly towards the center\n     */\n    fractionToPointAnd2Derivatives(fraction, result) {\n        const radians = this._sweep.fractionToRadians(fraction);\n        if (!result)\n            result = Plane3dByOriginAndVectors.createXYPlane();\n        const c = Math.cos(radians);\n        const s = Math.sin(radians);\n        this._matrix.originPlusMatrixTimesXY(this._center, c, s, result.origin);\n        const a = this._sweep.sweepRadians;\n        this._matrix.multiplyXY(-a * s, a * c, result.vectorU);\n        const aa = a * a;\n        this._matrix.multiplyXY(-aa * c, -aa * s, result.vectorV);\n        return result;\n    }\n    /**\n     * Evaluate the point and derivative with respect to the angle (in radians)\n     * @param radians angular position\n     * @param result optional preallocated ray.\n     */\n    radiansToPointAndDerivative(radians, result) {\n        result = result ? result : Ray3d.createZero();\n        const c = Math.cos(radians);\n        const s = Math.sin(radians);\n        this._matrix.originPlusMatrixTimesXY(this._center, c, s, result.origin);\n        this._matrix.multiplyXY(-s, c, result.direction);\n        return result;\n    }\n    /**\n     * Evaluate the point and derivative with respect to the angle (in radians)\n     * @param radians angular position\n     * @param result optional preallocated ray.\n     */\n    radiansToPoint(radians, result) {\n        result = result ? result : Point3d.create();\n        const c = Math.cos(radians);\n        const s = Math.sin(radians);\n        this._matrix.originPlusMatrixTimesXY(this._center, c, s, result);\n        return result;\n    }\n    /**\n     * Return a parametric plane with\n     * * origin at arc center\n     * * vectorU from center to arc at angle (in radians)\n     * * vectorV from center to arc at 90 degrees past the angle.\n     * @param radians angular position\n     * @param result optional preallocated plane\n     */\n    radiansToRotatedBasis(radians, result) {\n        result = result ? result : Plane3dByOriginAndVectors.createXYPlane();\n        const c = Math.cos(radians);\n        const s = Math.sin(radians);\n        result.origin.setFromPoint3d(this.center);\n        this._matrix.multiplyXY(c, s, result.vectorU);\n        this._matrix.multiplyXY(-s, c, result.vectorV);\n        return result;\n    }\n    /**\n     * Evaluate the point and derivative with respect to the angle (in radians)\n     * @param theta angular position\n     * @param result optional preallocated ray.\n     */\n    angleToPointAndDerivative(theta, result) {\n        result = result ? result : Ray3d.createZero();\n        const c = theta.cos();\n        const s = theta.sin();\n        this._matrix.originPlusMatrixTimesXY(this._center, c, s, result.origin);\n        this._matrix.multiplyXY(-s, c, result.direction);\n        return result;\n    }\n    /**\n     * Return the start point tof the arc.\n     * @param result optional preallocated result\n     */\n    startPoint(result) {\n        return this.fractionToPoint(0.0, result);\n    }\n    /**\n     * Return the end point tof the arc.\n     * @param result optional preallocated result\n     */\n    endPoint(result) {\n        return this.fractionToPoint(1.0, result);\n    }\n    /** * If this is a circular arc, return the simple length derived from radius and sweep.\n     * * Otherwise (i.e. if this elliptical) fall through to CurvePrimitive base implementation which\n     *     Uses quadrature.\n     */\n    curveLength() {\n        return this.curveLengthBetweenFractions(0, 1);\n    }\n    /**\n     * * If this is a circular arc, return the simple length derived from radius and sweep.\n     * * Otherwise (i.e. if this elliptical) fall through CurvePrimitive integrator.\n     */\n    curveLengthBetweenFractions(fraction0, fraction1) {\n        const simpleLength = this.getFractionToDistanceScale();\n        if (simpleLength !== undefined)\n            return simpleLength * Math.abs(fraction1 - fraction0);\n        // fall through for true ellipse . .. stroke and accumulate quadrature with typical count .  ..\n        let f0 = fraction0;\n        let f1 = fraction1;\n        if (fraction0 > fraction1) {\n            f0 = fraction1;\n            f1 = fraction0;\n        }\n        const sweepDegrees = (f1 - f0) * this._sweep.sweepDegrees;\n        let eccentricity = this.quickEccentricity();\n        if (eccentricity < 0.00001)\n            eccentricity = 0.00001;\n        let numInterval = Math.ceil(sweepDegrees / (eccentricity * Arc3d.quadratureIntervalAngleDegrees));\n        if (numInterval > 400)\n            numInterval = 400;\n        if (numInterval < 1)\n            numInterval = 1;\n        return super.curveLengthWithFixedIntervalCountQuadrature(f0, f1, numInterval, Arc3d.quadratureGuassCount);\n    }\n    /**\n     * Return an approximate (but easy to compute) arc length.\n     * The estimate is:\n     * * Form 8 chords on full circle, proportionally fewer for partials (but 2 extras if less than half circle).\n     * * Sum the chord lengths.\n     * * For a circle, we know this crude approximation has to be increased by a factor (theta/(2*sin(theta/2))).\n     * * Apply that factor.\n     * * Experiments confirm that this is within 3 percent for a variety of eccentricities and arc sweeps.\n     */\n    quickLength() {\n        const totalSweep = Math.abs(this._sweep.sweepRadians);\n        let numInterval = Math.ceil(4 * totalSweep / Math.PI);\n        if (numInterval < 1)\n            numInterval = 1;\n        if (numInterval < 4)\n            numInterval += 3;\n        else if (numInterval < 6)\n            numInterval += 2; // force extras for short arcs\n        const pointA = Arc3d._workPointA;\n        const pointB = Arc3d._workPointB;\n        let chordSum = 0.0;\n        this.fractionToPoint(0.0, pointA);\n        for (let i = 1; i <= numInterval; i++) {\n            this.fractionToPoint(i / numInterval, pointB);\n            chordSum += pointA.distance(pointB);\n            pointA.setFromPoint3d(pointB);\n        }\n        // The chord sum is always shorter.\n        // if it is a true circular arc, the ratio of correct over sum is easy ...\n        const dTheta = totalSweep / numInterval;\n        const factor = dTheta / (2.0 * Math.sin(0.5 * dTheta));\n        return chordSum * factor;\n    }\n    /**\n     * * See extended comments on `CurvePrimitive.moveSignedDistanceFromFraction`\n     * * A zero length line generates `CurveSearchStatus.error`\n     * * Nonzero length line generates `CurveSearchStatus.success` or `CurveSearchStatus.stoppedAtBoundary`\n     */\n    moveSignedDistanceFromFraction(startFraction, signedDistance, allowExtension, result) {\n        if (!this.isCircular) // suppress extension !!!\n            return super.moveSignedDistanceFromFractionGeneric(startFraction, signedDistance, allowExtension, result);\n        const totalLength = this.curveLength();\n        const signedFractionMove = Geometry.conditionalDivideFraction(signedDistance, totalLength);\n        if (signedFractionMove === undefined) {\n            return CurveLocationDetail.createCurveFractionPointDistanceCurveSearchStatus(this, startFraction, this.fractionToPoint(startFraction), 0.0, CurveSearchStatus.error);\n        }\n        return CurveLocationDetail.createConditionalMoveSignedDistance(allowExtension, this, startFraction, startFraction + signedFractionMove, signedDistance, result);\n    }\n    /**\n     * Return all angles (in radians) where the ellipse tangent is perpendicular to the vector to a spacePoint.\n     * @param spacePoint point of origin of vectors to the ellipse\n     * @param _extend (NOT SUPPORTED -- ALWAYS ACTS AS \"true\")\n     * @param _endpoints if true, force the end radians into the result.\n     */\n    allPerpendicularAngles(spacePoint, _extend = true, _endpoints = false) {\n        const radians = [];\n        const vectorQ = spacePoint.vectorTo(this.center);\n        const uu = this._matrix.columnXMagnitudeSquared();\n        const uv = this._matrix.columnXDotColumnY();\n        const vv = this._matrix.columnYMagnitudeSquared();\n        TrigPolynomial.solveUnitCircleImplicitQuadricIntersection(uv, vv - uu, -uv, this._matrix.dotColumnY(vectorQ), -this._matrix.dotColumnX(vectorQ), 0.0, radians);\n        if (_endpoints) {\n            radians.push(this.sweep.startRadians);\n            radians.push(this.sweep.endRadians);\n        }\n        return radians;\n    }\n    /**\n     * Return details of the closest point on the arc, optionally extending to full ellipse.\n     * @param spacePoint search for point closest to this point.\n     * @param extend if true, consider projections to the complete ellipse. If false, consider only endpoints and\n     * projections within the arc sweep.\n     * @param result optional preallocated result.\n     */\n    closestPoint(spacePoint, extend, result) {\n        result = CurveLocationDetail.create(this, result);\n        const allRadians = this.allPerpendicularAngles(spacePoint, true, true);\n        let extend0 = CurveExtendOptions.resolveVariantCurveExtendParameterToCurveExtendMode(extend, 0);\n        let extend1 = CurveExtendOptions.resolveVariantCurveExtendParameterToCurveExtendMode(extend, 1);\n        // distinct extends for cyclic space are awkward ....\n        if (this._sweep.isFullCircle) {\n            extend0 = CurveExtendMode.None;\n            extend1 = CurveExtendMode.None;\n        }\n        if (extend0 !== CurveExtendMode.None && extend1 !== CurveExtendMode.None) {\n            allRadians.push(this._sweep.startRadians);\n            allRadians.push(this._sweep.endRadians);\n        }\n        // hm... logically there must at least two angles there ...  but if it happens return the start point ...\n        const workRay = Ray3d.createZero();\n        if (allRadians.length === 0) {\n            result.setFR(0.0, this.radiansToPointAndDerivative(this._sweep.startRadians, workRay));\n            result.a = spacePoint.distance(result.point);\n        }\n        else {\n            let dMin = Number.MAX_VALUE;\n            let d = 0;\n            for (const radians of allRadians) {\n                const fraction = CurveExtendOptions.resolveRadiansToSweepFraction(extend, radians, this.sweep);\n                if (fraction !== undefined) {\n                    this.fractionToPointAndDerivative(fraction, workRay);\n                    d = spacePoint.distance(workRay.origin);\n                    if (d < dMin) {\n                        dMin = d;\n                        result.setFR(fraction, workRay);\n                        result.a = d;\n                    }\n                }\n            }\n        }\n        return result;\n    }\n    /** Reverse the sweep  of the arc. */\n    reverseInPlace() {\n        this._sweep.reverseInPlace();\n    }\n    /**\n     * Apply a transform to the arc basis vectors.\n     * * nonuniform (i.e. skewing) transforms are allowed.\n     * * The transformed vector0 and vector90 are NOT squared up as major minor axes.  (This is a good feature!!)\n     */\n    tryTransformInPlace(transform) {\n        this._center = transform.multiplyPoint3d(this._center, this._center);\n        this._matrix = transform.matrix.multiplyMatrixMatrix(this._matrix, this._matrix);\n        // force re-normalization of columnZ.\n        this.setVector0Vector90(this._matrix.columnX(), this._matrix.columnY());\n        return true;\n    }\n    /**\n     * Return true if the ellipse center and basis vectors are in the plane\n     * @param plane\n     */\n    isInPlane(plane) {\n        const normal = plane.getNormalRef();\n        // The ellipse vectors are full-length  -- true distance comparisons say things.\n        return Geometry.isSmallMetricDistance(plane.altitude(this._center))\n            && Geometry.isSmallMetricDistance(this._matrix.dotColumnX(normal))\n            && Geometry.isSmallMetricDistance(this._matrix.dotColumnY(normal));\n    }\n    /** Return true if the vector0 and vector90 are of equal length and perpendicular. */\n    get isCircular() {\n        const axx = this._matrix.columnXMagnitudeSquared();\n        const ayy = this._matrix.columnYMagnitudeSquared();\n        const axy = this._matrix.columnXDotColumnY();\n        return Angle.isPerpendicularDotSet(axx, ayy, axy) && Geometry.isSameCoordinateSquared(axx, ayy);\n    }\n    /** Return radius if the vector0 and vector90 are of equal length and perpendicular. */\n    circularRadiusXY() {\n        const ux = this._matrix.at(0, 0);\n        const uy = this._matrix.at(1, 0);\n        const vx = this._matrix.at(0, 1);\n        const vy = this._matrix.at(1, 1);\n        const axx = Geometry.dotProductXYXY(ux, uy, ux, uy);\n        const ayy = Geometry.dotProductXYXY(vx, vy, vx, vy);\n        const axy = Geometry.dotProductXYXY(ux, uy, vx, vy);\n        if (Angle.isPerpendicularDotSet(axx, ayy, axy) && Geometry.isSameCoordinateSquared(axx, ayy))\n            return Geometry.hypotenuseXY(ux, uy);\n        return undefined;\n    }\n    /** If the arc is circular, return its radius. Otherwise return undefined */\n    circularRadius() {\n        return this.isCircular ? this._matrix.columnXMagnitude() : undefined;\n    }\n    /** Return the larger of the two defining vectors. */\n    maxVectorLength() {\n        return Math.max(this._matrix.columnXMagnitude(), this._matrix.columnYMagnitude());\n    }\n    /**\n     * Compute intersections with a plane.\n     * @param plane plane to intersect\n     * @param result array of locations on the curve.\n     */\n    appendPlaneIntersectionPoints(plane, result) {\n        const constCoff = plane.altitude(this._center);\n        const coffs = this._matrix.coffs;\n        const cosCoff = plane.velocityXYZ(coffs[0], coffs[3], coffs[6]);\n        const sinCoff = plane.velocityXYZ(coffs[1], coffs[4], coffs[7]);\n        const trigPoints = Geometry.solveTrigForm(constCoff, cosCoff, sinCoff);\n        let numIntersection = 0;\n        if (trigPoints !== undefined) {\n            numIntersection = trigPoints.length;\n            let xy;\n            for (xy of trigPoints) {\n                const radians = Math.atan2(xy.y, xy.x);\n                const fraction = this._sweep.radiansToPositivePeriodicFraction(radians);\n                const detail = CurveLocationDetail.createCurveFractionPoint(this, fraction, this.fractionToPoint(fraction));\n                detail.intervalRole = CurveIntervalRole.isolated;\n                if (Angle.isAlmostEqualRadiansAllowPeriodShift(radians, this._sweep.startRadians))\n                    detail.intervalRole = CurveIntervalRole.isolatedAtVertex;\n                else if (Angle.isAlmostEqualRadiansAllowPeriodShift(radians, this._sweep.endRadians))\n                    detail.intervalRole = CurveIntervalRole.isolatedAtVertex;\n                result.push(detail);\n            }\n        }\n        return numIntersection;\n    }\n    /**\n     * Extend a range to include the range of the arc.\n     * @param range range being extended.\n     * @param transform optional transform to apply to the arc.\n     */\n    extendRange(range, transform) {\n        this.extendRangeInSweep(range, this._sweep, transform);\n    }\n    /**\n     * Extend a range to include the range of the arc, using specified range in place of the arc range.\n     * @param range range being extended.\n     * @param transform optional transform to apply to the arc.\n     */\n    extendRangeInSweep(range, sweep, transform) {\n        const trigForm = new SineCosinePolynomial(0, 0, 0);\n        const center = this._center.clone(Arc3d._workPointA);\n        const vectorU = this._matrix.columnX(Arc3d._workVectorU);\n        const vectorV = this._matrix.columnY(Arc3d._workVectorV);\n        if (transform) {\n            transform.multiplyPoint3d(center, center);\n            transform.multiplyVector(vectorU, vectorU);\n            transform.multiplyVector(vectorV, vectorV);\n        }\n        const lowPoint = Arc3d._workPointB;\n        const highPoint = Arc3d._workPointC;\n        const range1 = Range1d.createNull();\n        for (let i = 0; i < 3; i++) {\n            trigForm.set(center.at(i), vectorU.at(i), vectorV.at(i));\n            trigForm.rangeInSweep(sweep, range1);\n            lowPoint.setAt(i, range1.low);\n            highPoint.setAt(i, range1.high);\n        }\n        range.extend(lowPoint);\n        range.extend(highPoint);\n    }\n    /**\n     * Returns a (high accuracy) range of the curve between fractional positions\n     * * Default implementation returns teh range of the curve from clonePartialCurve\n     */\n    rangeBetweenFractions(fraction0, fraction1, transform) {\n        const sweep = AngleSweep.createStartEndRadians(this.sweep.fractionToRadians(fraction0), this.sweep.fractionToRadians(fraction1));\n        const range = Range3d.create();\n        this.extendRangeInSweep(range, sweep, transform);\n        return range;\n    }\n    /**\n     * Set up a SineCosinePolynomial as the function c+u*cos(theta)+v*sin(theta) where\n     *  c,u,v are coefficients obtained by evaluating altitude and velocity relative to the plane.\n     * @param plane plane for altitude calculation.\n     * @param result optional result.\n     * @internal\n     */\n    getPlaneAltitudeSineCosinePolynomial(plane, result) {\n        if (!result)\n            result = new SineCosinePolynomial(0, 0, 0);\n        // altitude function of angle t, given plane with origin o and unit normal n:\n        //  A(t) = (c + u cos(t) + v sin(t)) . n = (c-o).n + u.n cos(t) + v.n sin(t)\n        // Note the different functions for computing dot product against a point vs. a vector!\n        result.set(plane.altitude(this._center), plane.velocityXYZ(this._matrix.coffs[0], this._matrix.coffs[3], this._matrix.coffs[6]), plane.velocityXYZ(this._matrix.coffs[1], this._matrix.coffs[4], this._matrix.coffs[7]));\n        return result;\n    }\n    /** Create a new arc which is a unit circle centered at the origin. */\n    static createUnitCircle() {\n        return Arc3d.createRefs(Point3d.create(0, 0, 0), Matrix3d.createIdentity(), AngleSweep.create360());\n    }\n    /**\n     * Create a new arc which is parallel to the xy plane, with given center and radius and optional angle sweep.\n     * @param center center of arc\n     * @param radius radius of arc\n     * @param sweep sweep limits.  defaults to full circle.\n     */\n    static createXY(center, radius, sweep = AngleSweep.create360()) {\n        return new Arc3d(center.clone(), Matrix3d.createScale(radius, radius, 1.0), sweep);\n    }\n    /**\n     * Create a new arc which is parallel to the xy plane, with given center and x,y radii, and optional angle sweep\n     * @param center center of ellipse\n     * @param radiusA x axis radius\n     * @param radiusB y axis radius\n     * @param sweep angle sweep\n     */\n    static createXYEllipse(center, radiusA, radiusB, sweep = AngleSweep.create360()) {\n        return new Arc3d(center.clone(), Matrix3d.createScale(radiusA, radiusB, 1.0), sweep);\n    }\n    /**\n     * Replace the arc's 0 and 90 degree vectors.\n     * @param vector0 vector from center to ellipse point at 0 degrees in parameter space\n     * @param vector90 vector from center to ellipse point at 90 degrees in parameter space\n     */\n    setVector0Vector90(vector0, vector90) {\n        this._matrix.setColumns(vector0, vector90, vector0.unitCrossProductWithDefault(vector90, 0, 0, 0));\n    }\n    /** Return the arc definition with rigid matrix form with axis radii */\n    toScaledMatrix3d() {\n        const angleData = Angle.dotProductsToHalfAngleTrigValues(this._matrix.columnXMagnitudeSquared(), this._matrix.columnYMagnitudeSquared(), this._matrix.columnXDotColumnY(), true);\n        const vector0A = this._matrix.multiplyXY(angleData.c, angleData.s);\n        const vector90A = this._matrix.multiplyXY(-angleData.s, angleData.c);\n        const axes = Matrix3d.createRigidFromColumns(vector0A, vector90A, AxisOrder.XYZ);\n        return {\n            axes: (axes ? axes : Matrix3d.createIdentity()),\n            center: this._center,\n            r0: vector0A.magnitude(),\n            r90: vector90A.magnitude(),\n            sweep: this.sweep.cloneMinusRadians(angleData.radians),\n        };\n    }\n    /** Return the arc definition with center, two vectors, and angle sweep; */\n    toVectors() {\n        return {\n            center: this.center,\n            vector0: this._matrix.columnX(),\n            vector90: this._matrix.columnY(),\n            sweep: this.sweep,\n        };\n    }\n    /** Return the arc definition with center, two vectors, and angle sweep, optionally transformed. */\n    toTransformedVectors(transform) {\n        return transform ? {\n            center: transform.multiplyPoint3d(this._center),\n            vector0: transform.multiplyVector(this._matrix.columnX()),\n            vector90: transform.multiplyVector(this._matrix.columnY()),\n            sweep: this.sweep,\n        }\n            : {\n                center: this._center.clone(),\n                vector0: this._matrix.columnX(),\n                vector90: this._matrix.columnY(),\n                sweep: this.sweep,\n            };\n    }\n    /** Return the arc definition with center, two vectors, and angle sweep, transformed to 4d points. */\n    toTransformedPoint4d(matrix) {\n        return {\n            center: matrix.multiplyPoint3d(this._center, 1.0),\n            vector0: matrix.multiplyPoint3d(this._matrix.columnX(), 0.0),\n            vector90: matrix.multiplyPoint3d(this._matrix.columnY(), 0.0),\n            sweep: this.sweep,\n        };\n    }\n    /**\n     * Set this arc from a json object with these values:\n     * * center center point\n     * * vector0 vector from center to 0 degree point in parameter space (commonly but not always the major axis vector)\n     * * vector90 vector from center to 90 degree point in parameter space (commonly but not always the minor axis vector)\n     * @param json\n     */\n    setFromJSON(json) {\n        if (json && json.center && json.vector0 && json.vector90 && json.sweep) {\n            this._center.setFromJSON(json.center);\n            const vector0 = Vector3d.create();\n            const vector90 = Vector3d.create();\n            vector0.setFromJSON(json.vector0);\n            vector90.setFromJSON(json.vector90);\n            this.setVector0Vector90(vector0, vector90);\n            this._sweep.setFromJSON(json.sweep);\n        }\n        else {\n            this._center.set(0, 0, 0);\n            this._matrix.setFrom(Matrix3d.identity);\n            this._sweep.setStartEndRadians();\n        }\n    }\n    /**\n     * Convert to a JSON object.\n     * @return {*} [center:  [], vector0:[], vector90:[], sweep []}\n     */\n    toJSON() {\n        return {\n            center: this._center.toJSON(),\n            sweep: this._sweep.toJSON(),\n            vector0: this._matrix.columnX().toJSON(),\n            vector90: this._matrix.columnY().toJSON(),\n        };\n    }\n    /** Test if this arc is almost equal to another GeometryQuery object */\n    isAlmostEqual(otherGeometry) {\n        if (otherGeometry instanceof Arc3d) {\n            const other = otherGeometry;\n            return this._center.isAlmostEqual(other._center)\n                && this._matrix.isAlmostEqual(other._matrix)\n                && this._sweep.isAlmostEqualAllowPeriodShift(other._sweep);\n        }\n        return false;\n    }\n    /** Emit strokes to caller-supplied linestring */\n    emitStrokes(dest, options) {\n        const numStrokes = this.computeStrokeCountForOptions(options);\n        dest.appendFractionalStrokePoints(this, numStrokes, 0.0, 1.0, true);\n    }\n    /** Emit strokes to caller-supplied handler */\n    emitStrokableParts(handler, options) {\n        const numStrokes = this.computeStrokeCountForOptions(options);\n        handler.startCurvePrimitive(this);\n        handler.announceIntervalForUniformStepStrokes(this, numStrokes, 0.0, 1.0);\n        handler.endCurvePrimitive(this);\n    }\n    /**\n     * Return the stroke count required for given options.\n     * @param options StrokeOptions that determine count\n     */\n    computeStrokeCountForOptions(options) {\n        let numStroke;\n        if (options) {\n            const rMax = this.maxVectorLength();\n            numStroke = options.applyTolerancesToArc(rMax, this._sweep.sweepRadians);\n        }\n        else {\n            numStroke = StrokeOptions.applyAngleTol(undefined, 1, this._sweep.sweepRadians);\n        }\n        return numStroke;\n    }\n    /** Second step of double dispatch:  call `handler.handleArc3d(this)` */\n    dispatchToGeometryHandler(handler) {\n        return handler.handleArc3d(this);\n    }\n    /**\n     * Return (if possible) an arc which is a portion of this curve.\n     * @param fractionA [in] start fraction\n     * @param fractionB [in] end fraction\n     */\n    clonePartialCurve(fractionA, fractionB) {\n        if (fractionB < fractionA) {\n            const arcA = this.clonePartialCurve(fractionB, fractionA);\n            arcA.reverseInPlace();\n            return arcA;\n        }\n        const arcB = this.clone();\n        arcB.sweep.setStartEndRadians(this.sweep.fractionToRadians(fractionA), this.sweep.fractionToRadians(fractionB));\n        return arcB;\n    }\n    /**\n     * Return an arc whose basis vectors are rotated by given angle within the current basis space.\n     * * the result arc will have its zero-degree point (new `vector0`) at the current\n     * `vector0 * cos(theta) + vector90 * sin(theta)`\n     * * the result sweep is adjusted so all fractional coordinates (e.g. start and end) evaluate to the same xyz.\n     *   * Specifically, theta is subtracted from the original start and end angles.\n     * @param theta the angle (in the input arc space) which is to become the 0-degree point in the new arc.\n     */\n    cloneInRotatedBasis(theta) {\n        const c = theta.cos();\n        const s = theta.sin();\n        const vector0 = this._matrix.multiplyXY(c, s);\n        const vector90 = this._matrix.multiplyXY(-s, c);\n        const newSweep = AngleSweep.createStartEndRadians(this._sweep.startRadians - theta.radians, this._sweep.endRadians - theta.radians);\n        const arcB = Arc3d.create(this._center.clone(), vector0, vector90, newSweep);\n        return arcB;\n    }\n    /**\n     * Find intervals of this CurvePrimitive that are interior to a clipper\n     * @param clipper clip structure (e.g.clip planes)\n     * @param announce(optional) function to be called announcing fractional intervals\"\n     * ` announce(fraction0, fraction1, curvePrimitive)`\n     * @returns true if any \"in\" segments are announced.\n     */\n    announceClipIntervals(clipper, announce) {\n        return clipper.announceClippedArcIntervals(this, announce);\n    }\n    /** Compute the center and vectors of another arc as local coordinates within this arc's frame. */\n    otherArcAsLocalVectors(other) {\n        const otherOrigin = this._matrix.multiplyInverseXYZAsPoint3d(other.center.x - this.center.x, other.center.y - this.center.y, other.center.z - this.center.z);\n        const otherVector0 = this._matrix.multiplyInverse(other.vector0);\n        const otherVector90 = this._matrix.multiplyInverse(other.vector90);\n        if (otherOrigin && otherVector0 && otherVector90) {\n            return { center: otherOrigin, vector0: otherVector0, vector90: otherVector90, sweep: this.sweep.clone() };\n        }\n        return undefined;\n    }\n    /**\n     * Determine an arc \"at a point of inflection\" of a point sequence.\n     * * Return the arc along with the fractional positions of the tangency points.\n     * * In the returned object:\n     *   * `arc` is the (bounded) arc\n     *   * `fraction10` is the tangency point's position as an interpolating fraction of the line segment from\n     * `point1` (backwards) to `point0`\n     *   * `fraction12` is the tangency point's position as an interpolating fraction of the line segment from\n     * `point1` (forward) to `point2`\n     *   * `point` is the `point1` input.\n     * * If unable to construct the arc:\n     *   * `point` is the `point1` input.\n     *   * both fractions are zero\n     *   * `arc` is undefined.\n     * @param point0 first point of path. (the point before the point of inflection)\n     * @param point1 second point of path (the point of inflection)\n     * @param point2 third point of path (the point after the point of inflection)\n     * @param radius arc radius\n     *\n     */\n    static createFilletArc(point0, point1, point2, radius) {\n        const vector10 = Vector3d.createStartEnd(point1, point0);\n        const vector12 = Vector3d.createStartEnd(point1, point2);\n        const d10 = vector10.magnitude();\n        const d12 = vector12.magnitude();\n        if (vector10.normalizeInPlace() && vector12.normalizeInPlace()) {\n            const bisector = vector10.plus(vector12);\n            if (bisector.normalizeInPlace()) {\n                // const theta = vector12.angleTo(bisector);\n                // vector10, vector12, and bisector are UNIT vectors\n                // bisector splits the angle between vector10 and vector12\n                const perpendicular = vector12.minus(vector10);\n                const perpendicularMagnitude = perpendicular.magnitude(); // == 2 * sin(theta)\n                const sinTheta = 0.5 * perpendicularMagnitude;\n                if (!Geometry.isSmallAngleRadians(sinTheta)) { // (for small theta, sinTheta is almost equal to theta)\n                    const cosTheta = Math.sqrt(1 - sinTheta * sinTheta);\n                    const tanTheta = sinTheta / cosTheta;\n                    const alphaRadians = Math.acos(sinTheta);\n                    const distanceToCenter = radius / sinTheta;\n                    const distanceToTangency = radius / tanTheta;\n                    const f10 = distanceToTangency / d10;\n                    const f12 = distanceToTangency / d12;\n                    const center = point1.plusScaled(bisector, distanceToCenter);\n                    bisector.scaleInPlace(-radius);\n                    perpendicular.scaleInPlace(radius / perpendicularMagnitude);\n                    const arc02 = Arc3d.create(center, bisector, perpendicular, AngleSweep.createStartEndRadians(-alphaRadians, alphaRadians));\n                    return { arc: arc02, fraction10: f10, fraction12: f12, point: point1.clone() };\n                }\n            }\n        }\n        return { fraction10: 0.0, fraction12: 0.0, point: point1.clone() };\n    }\n    /** Scale the vector0 and vector90 vectors by `scaleFactor` */\n    scaleAboutCenterInPlace(scaleFactor) {\n        this._matrix.scaleColumnsInPlace(scaleFactor, scaleFactor, 1.0);\n    }\n    /** Return the (signed!) area between (a fractional portion of) the arc and the chord between those points */\n    areaToChordXY(fraction0, fraction1) {\n        let detJ = Geometry.crossProductXYXY(this._matrix.coffs[0], this._matrix.coffs[3], this._matrix.coffs[1], this._matrix.coffs[4]);\n        // areas in arc of unit circle with radians limits\n        const radians0 = this._sweep.fractionToRadians(fraction0);\n        const radians1 = this._sweep.fractionToRadians(fraction1);\n        // const midRadians = 0.5 * (radians0 + radians1);\n        const alpha = 0.5 * (radians1 - radians0);\n        if (alpha < 0.0)\n            detJ = -detJ;\n        const wedgeArea = Math.cos(alpha) * Math.sin(alpha);\n        return (alpha - wedgeArea) * detJ;\n    }\n    /**\n     * Construct an offset of the instance curve as viewed in the xy-plane (ignoring z).\n     * @param offsetDistanceOrOptions offset distance (positive to left of the instance curve), or options object\n     */\n    constructOffsetXY(offsetDistanceOrOptions) {\n        const options = OffsetOptions.create(offsetDistanceOrOptions);\n        if (this.isCircular || options.preserveEllipticalArcs) {\n            const arcXY = this.cloneAtZ();\n            const sign = arcXY.sweep.sweepRadians * arcXY.matrixRef.coffs[8] >= 0.0 ? 1.0 : -1.0;\n            const r0 = arcXY.matrixRef.columnXMagnitude();\n            const r0new = r0 - sign * options.leftOffsetDistance;\n            const r90 = this.isCircular ? r0 : arcXY.matrixRef.columnYMagnitude();\n            const r90new = this.isCircular ? r0new : r90 - sign * options.leftOffsetDistance;\n            if (!Geometry.isSmallMetricDistance(r0new)\n                && (r0 * r0new > 0.0)\n                && (this.isCircular || (!Geometry.isSmallMetricDistance(r90new) && (r90 * r90new > 0.0)))) {\n                const factor0 = r0new / r0;\n                const factor90 = this.isCircular ? factor0 : r90new / r90;\n                const matrix = arcXY.matrixClone();\n                matrix.scaleColumnsInPlace(factor0, factor90, 1.0);\n                return Arc3d.createRefs(arcXY.center.clone(), matrix, arcXY.sweep.clone());\n            }\n            else {\n                return undefined; // zero radius\n            }\n        }\n        // default impl\n        const handler = new CurveOffsetXYHandler(this, options.leftOffsetDistance);\n        this.emitStrokableParts(handler, options.strokeOptions);\n        return handler.claimResult();\n    }\n    /**\n     * Project instance geometry (via dispatch) onto the given ray, and return the extreme fractional parameters of projection.\n     * @param ray ray onto which the instance is projected. A `Vector3d` is treated as a `Ray3d` with zero origin.\n     * @param lowHigh optional receiver for output\n     * @returns range of fractional projection parameters onto the ray, where 0.0 is start of the ray and 1.0 is the end of the ray.\n     */\n    projectedParameterRange(ray, lowHigh) {\n        return PlaneAltitudeRangeContext.findExtremeFractionsAlongDirection(this, ray, lowHigh);\n    }\n}\nArc3d._workPointA = Point3d.create();\nArc3d._workPointB = Point3d.create();\nArc3d._workPointC = Point3d.create();\nArc3d._workVectorU = Vector3d.create();\nArc3d._workVectorV = Vector3d.create();\n// !! misspelled Gauss in the published static !! Declare it ok.\n// cspell::word Guass\n/** Gauss point quadrature count for evaluating curve length. (The number of intervals is adjusted to the arc sweep) */\nArc3d.quadratureGuassCount = 5;\n/** In quadrature for arc length, use this interval (divided by quickEccentricity) */\nArc3d.quadratureIntervalAngleDegrees = 10.0;\nexport { Arc3d };\n//# sourceMappingURL=Arc3d.js.map",
      "start": 1693508122642,
      "end": 1693508122805,
      "sourcemaps": null
    }
  ]
}
