{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/webgl-compatibility/lib/esm/Capabilities.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Compatibility\n */\nimport { ProcessDetector } from \"@itwin/core-bentley\";\nimport { WebGLFeature, WebGLRenderCompatibilityStatus, } from \"./RenderCompatibility\";\nconst knownExtensions = [\n    \"WEBGL_draw_buffers\",\n    \"OES_element_index_uint\",\n    \"OES_texture_float\",\n    \"OES_texture_float_linear\",\n    \"OES_texture_half_float\",\n    \"OES_texture_half_float_linear\",\n    \"EXT_texture_filter_anisotropic\",\n    \"WEBGL_depth_texture\",\n    \"EXT_color_buffer_float\",\n    \"EXT_shader_texture_lod\",\n    \"EXT_frag_depth\",\n    \"ANGLE_instanced_arrays\",\n    \"OES_vertex_array_object\",\n    \"WEBGL_lose_context\",\n    \"EXT_disjoint_timer_query\",\n    \"EXT_disjoint_timer_query_webgl2\",\n    \"OES_standard_derivatives\",\n    \"EXT_float_blend\",\n];\n/** Describes the type of a render target. Used by Capabilities to represent maximum precision render target available on host system.\n * @internal\n */\nexport var RenderType;\n(function (RenderType) {\n    RenderType[RenderType[\"TextureUnsignedByte\"] = 0] = \"TextureUnsignedByte\";\n    RenderType[RenderType[\"TextureHalfFloat\"] = 1] = \"TextureHalfFloat\";\n    RenderType[RenderType[\"TextureFloat\"] = 2] = \"TextureFloat\";\n})(RenderType || (RenderType = {}));\n/**\n * Describes the type of a depth buffer. Used by Capabilities to represent maximum depth buffer precision available on host system.\n * Note: the commented-out values are unimplemented but left in place for reference, in case desired for future implementation.\n * @internal\n */\nexport var DepthType;\n(function (DepthType) {\n    DepthType[DepthType[\"RenderBufferUnsignedShort16\"] = 0] = \"RenderBufferUnsignedShort16\";\n    // TextureUnsignedShort16,       // core to WebGL2; available to WebGL1 via WEBGL_depth_texture\n    // TextureUnsignedInt24,         // core to WebGL2\n    DepthType[DepthType[\"TextureUnsignedInt24Stencil8\"] = 1] = \"TextureUnsignedInt24Stencil8\";\n    DepthType[DepthType[\"TextureUnsignedInt32\"] = 2] = \"TextureUnsignedInt32\";\n    // TextureFloat32,               // core to WebGL2\n    // TextureFloat32Stencil8,       // core to WeBGL2\n})(DepthType || (DepthType = {}));\nconst maxTexSizeAllowed = 4096; // many devices and browsers have issues with source textures larger than this\n// Regexes to match Intel UHD/HD 620/630 integrated GPUS that suffer from GraphicsDriverBugs.fragDepthDoesNotDisableEarlyZ.\nconst buggyIntelMatchers = [\n    // Original unmasked renderer string when workaround we implemented.\n    /ANGLE \\(Intel\\(R\\) (U)?HD Graphics 6(2|3)0 Direct3D11/,\n    // New unmasked renderer string circa October 2021.\n    /ANGLE \\(Intel, Intel\\(R\\) (U)?HD Graphics 6(2|3)0 Direct3D11/,\n];\n// Regexes to match Mali GPUs known to suffer from GraphicsDriverBugs.msaaWillHang.\nconst buggyMaliMatchers = [\n    /Mali-G71/,\n    /Mali-G72/,\n    /Mali-G76/,\n];\n// Regexes to match as many Intel integrated GPUs as possible.\n// https://en.wikipedia.org/wiki/List_of_Intel_graphics_processing_units\nconst integratedIntelGpuMatchers = [\n    /(U)?HD Graphics/,\n    /Iris/,\n];\nfunction isIntegratedGraphics(args) {\n    if (args.unmaskedRenderer && args.unmaskedRenderer.includes(\"Intel\") && integratedIntelGpuMatchers.some((x) => x.test(args.unmaskedRenderer)))\n        return true;\n    // NB: For now, we do not attempt to detect AMD integrated graphics.\n    // It appears that AMD integrated graphics are not usually paired with a graphics card so detecting integrated usage there is less important than Intel.\n    return false;\n}\n/** Describes the rendering capabilities of the host system.\n * @internal\n */\nclass Capabilities {\n    constructor() {\n        this._maxRenderType = RenderType.TextureUnsignedByte;\n        this._maxDepthType = DepthType.RenderBufferUnsignedShort16;\n        this._maxTextureSize = 0;\n        this._maxColorAttachments = 0;\n        this._maxDrawBuffers = 0;\n        this._maxFragTextureUnits = 0;\n        this._maxVertTextureUnits = 0;\n        this._maxVertAttribs = 0;\n        this._maxVertUniformVectors = 0;\n        this._maxVaryingVectors = 0;\n        this._maxFragUniformVectors = 0;\n        this._maxAntialiasSamples = 1;\n        this._supportsCreateImageBitmap = false;\n        this._maxTexSizeAllow = maxTexSizeAllowed;\n        this._extensionMap = {}; // Use this map to store actual extension objects retrieved from GL.\n        this._presentFeatures = []; // List of features the system can support (not necessarily dependent on extensions)\n        this._isWebGL2 = false;\n        this._isMobile = false;\n        this._driverBugs = {};\n    }\n    get maxRenderType() { return this._maxRenderType; }\n    get maxDepthType() { return this._maxDepthType; }\n    get maxTextureSize() { return this._maxTextureSize; }\n    get maxTexSizeAllow() { return this._maxTexSizeAllow; }\n    get supportsCreateImageBitmap() { return this._supportsCreateImageBitmap; }\n    get maxColorAttachments() { return this._maxColorAttachments; }\n    get maxDrawBuffers() { return this._maxDrawBuffers; }\n    get maxFragTextureUnits() { return this._maxFragTextureUnits; }\n    get maxVertTextureUnits() { return this._maxVertTextureUnits; }\n    get maxVertAttribs() { return this._maxVertAttribs; }\n    get maxVertUniformVectors() { return this._maxVertUniformVectors; }\n    get maxVaryingVectors() { return this._maxVaryingVectors; }\n    get maxFragUniformVectors() { return this._maxFragUniformVectors; }\n    get maxAntialiasSamples() { return this._maxAntialiasSamples; }\n    get isWebGL2() { return this._isWebGL2; }\n    get driverBugs() { return this._driverBugs; }\n    /** These getters check for existence of extension objects to determine availability of features.  In WebGL2, could just return true for some. */\n    get supportsNonPowerOf2Textures() { return false; }\n    get supportsDrawBuffers() { return this._isWebGL2 || this.queryExtensionObject(\"WEBGL_draw_buffers\") !== undefined; }\n    get supportsInstancing() { return this._isWebGL2 || this.queryExtensionObject(\"ANGLE_instanced_arrays\") !== undefined; }\n    get supports32BitElementIndex() { return this._isWebGL2 || this.queryExtensionObject(\"OES_element_index_uint\") !== undefined; }\n    get supportsTextureFloat() { return this._isWebGL2 || this.queryExtensionObject(\"OES_texture_float\") !== undefined; }\n    get supportsTextureFloatLinear() { return this._isWebGL2 || this.queryExtensionObject(\"OES_texture_float_linear\") !== undefined; }\n    get supportsTextureHalfFloat() { return this._isWebGL2 || this.queryExtensionObject(\"OES_texture_half_float\") !== undefined; }\n    get supportsTextureHalfFloatLinear() { return this._isWebGL2 || this.queryExtensionObject(\"OES_texture_half_float_linear\") !== undefined; }\n    get supportsTextureFilterAnisotropic() { return this.queryExtensionObject(\"EXT_texture_filter_anisotropic\") !== undefined; }\n    get supportsShaderTextureLOD() { return this._isWebGL2 || this.queryExtensionObject(\"EXT_shader_texture_lod\") !== undefined; }\n    get supportsVertexArrayObjects() { return this._isWebGL2 || this.queryExtensionObject(\"OES_vertex_array_object\") !== undefined; }\n    get supportsFragDepth() { return this._isWebGL2 || this.queryExtensionObject(\"EXT_frag_depth\") !== undefined; }\n    get supportsDisjointTimerQuery() { return (this._isWebGL2 && this.queryExtensionObject(\"EXT_disjoint_timer_query_webgl2\") !== undefined) || this.queryExtensionObject(\"EXT_disjoint_timer_query\") !== undefined; }\n    get supportsStandardDerivatives() { return this._isWebGL2 || this.queryExtensionObject(\"OES_standard_derivatives\") !== undefined; }\n    get supportsMRTTransparency() { return this.maxColorAttachments >= 2; }\n    get supportsMRTPickShaders() { return this.maxColorAttachments >= 3; }\n    get supportsShadowMaps() {\n        return this.supportsTextureFloat || this.supportsTextureHalfFloat;\n    }\n    get supportsAntiAliasing() { return this._isWebGL2 && this.maxAntialiasSamples > 1; }\n    get isMobile() { return this._isMobile; }\n    findExtension(name) {\n        const ext = this._extensionMap[name];\n        return null !== ext ? ext : undefined;\n    }\n    /** Queries an extension object if available.  This is necessary for other parts of the system to access some constants within extensions. */\n    queryExtensionObject(ext) {\n        return this.findExtension(ext);\n    }\n    get _hasRequiredTextureUnits() { return this.maxFragTextureUnits >= 4 && this.maxVertTextureUnits >= 5; }\n    /** Return an array containing any features not supported by the system as compared to the input array. */\n    _findMissingFeatures(featuresToSeek) {\n        const missingFeatures = [];\n        for (const featureName of featuresToSeek) {\n            if (-1 === this._presentFeatures.indexOf(featureName))\n                missingFeatures.push(featureName);\n        }\n        return missingFeatures;\n    }\n    /** Populate and return an array containing features that this system supports. */\n    _gatherFeatures() {\n        const features = [];\n        // simply check for presence of various extensions if that gives enough information\n        if (this._isWebGL2 || this._extensionMap[\"OES_element_index_uint\"] !== undefined)\n            features.push(WebGLFeature.UintElementIndex);\n        if (this._isWebGL2 || this._extensionMap[\"ANGLE_instanced_arrays\"] !== undefined)\n            features.push(WebGLFeature.Instancing);\n        if (this.supportsMRTTransparency)\n            features.push(WebGLFeature.MrtTransparency);\n        if (this.supportsMRTPickShaders)\n            features.push(WebGLFeature.MrtPick);\n        if (this.supportsShadowMaps)\n            features.push(WebGLFeature.ShadowMaps);\n        if (this._hasRequiredTextureUnits)\n            features.push(WebGLFeature.MinimalTextureUnits);\n        if (this.supportsFragDepth)\n            features.push(WebGLFeature.FragDepth);\n        if (this.supportsStandardDerivatives)\n            features.push(WebGLFeature.StandardDerivatives);\n        if (this.supportsAntiAliasing)\n            features.push(WebGLFeature.AntiAliasing);\n        if (DepthType.TextureUnsignedInt24Stencil8 === this._maxDepthType)\n            features.push(WebGLFeature.DepthTexture);\n        // check if at least half-float rendering is available based on maximum discovered renderable target\n        if (RenderType.TextureUnsignedByte !== this._maxRenderType)\n            features.push(WebGLFeature.FloatRendering);\n        return features;\n    }\n    /** Retrieve compatibility status based on presence of various features. */\n    _getCompatibilityStatus(missingRequiredFeatures, missingOptionalFeatures) {\n        let status = WebGLRenderCompatibilityStatus.AllOkay;\n        if (missingOptionalFeatures.length > 0)\n            status = WebGLRenderCompatibilityStatus.MissingOptionalFeatures;\n        if (missingRequiredFeatures.length > 0)\n            status = WebGLRenderCompatibilityStatus.MissingRequiredFeatures;\n        return status;\n    }\n    /** Initializes the capabilities based on a GL context. Must be called first. */\n    init(gl, disabledExtensions) {\n        const gl2 = !(gl instanceof WebGLRenderingContext) ? gl : undefined;\n        this._isWebGL2 = undefined !== gl2;\n        this._isMobile = ProcessDetector.isMobileBrowser;\n        const debugInfo = gl.getExtension(\"WEBGL_debug_renderer_info\");\n        const unmaskedRenderer = debugInfo !== null ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : undefined;\n        const unmaskedVendor = debugInfo !== null ? gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) : undefined;\n        this._driverBugs = {};\n        if (unmaskedRenderer && buggyIntelMatchers.some((x) => x.test(unmaskedRenderer)))\n            this._driverBugs.fragDepthDoesNotDisableEarlyZ = true;\n        if (unmaskedRenderer && buggyMaliMatchers.some((x) => x.test(unmaskedRenderer)))\n            this._driverBugs.msaaWillHang = true;\n        this._maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n        this._supportsCreateImageBitmap = typeof createImageBitmap === \"function\" && ProcessDetector.isChromium && !ProcessDetector.isIOSBrowser;\n        this._maxTexSizeAllow = Math.min(this._maxTextureSize, maxTexSizeAllowed);\n        this._maxFragTextureUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n        this._maxVertTextureUnits = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);\n        this._maxVertAttribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);\n        this._maxVertUniformVectors = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);\n        this._maxVaryingVectors = gl.getParameter(gl.MAX_VARYING_VECTORS);\n        this._maxFragUniformVectors = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);\n        this._maxAntialiasSamples = this._driverBugs.msaaWillHang ? 1 : (this._isWebGL2 && undefined !== gl2 ? gl.getParameter(gl2.MAX_SAMPLES) : 1);\n        const extensions = gl.getSupportedExtensions(); // This just retrieves a list of available extensions (not necessarily enabled).\n        if (extensions) {\n            for (const extStr of extensions) {\n                const ext = extStr;\n                if (-1 === knownExtensions.indexOf(ext))\n                    continue;\n                else if (undefined !== disabledExtensions && -1 !== disabledExtensions.indexOf(ext))\n                    continue;\n                const extObj = gl.getExtension(ext); // This call enables the extension and returns a WebGLObject containing extension instance.\n                if (null !== extObj)\n                    this._extensionMap[ext] = extObj;\n            }\n        }\n        if (this._isWebGL2 && undefined !== gl2) {\n            this._maxColorAttachments = gl.getParameter(gl2.MAX_COLOR_ATTACHMENTS);\n            this._maxDrawBuffers = gl.getParameter(gl2.MAX_DRAW_BUFFERS);\n        }\n        else {\n            const dbExt = this.queryExtensionObject(\"WEBGL_draw_buffers\");\n            this._maxColorAttachments = dbExt !== undefined ? gl.getParameter(dbExt.MAX_COLOR_ATTACHMENTS_WEBGL) : 1;\n            this._maxDrawBuffers = dbExt !== undefined ? gl.getParameter(dbExt.MAX_DRAW_BUFFERS_WEBGL) : 1;\n        }\n        // Determine the maximum color-renderable attachment type.\n        const allowFloatRender = (undefined === disabledExtensions || -1 === disabledExtensions.indexOf(\"OES_texture_float\"))\n            // iOS>=15 allows full-float rendering. However, it does not actually work on non-M1 devices.\n            // Because of this, for now we disallow full float rendering on iOS devices.\n            // ###TODO: Re-assess this after future iOS updates.\n            && !ProcessDetector.isIOSBrowser\n            // Samsung Galaxy Note 8 exhibits same issue as described above for iOS >= 15.\n            // It uses specifically Mali-G71 MP20 but reports its renderer as follows.\n            // Samsung Galaxy A50 and S9 exhibits same issue; they use Mali-G72.\n            // HUAWEI P30 exhibits same issue; it uses Mali-G76.\n            && unmaskedRenderer !== \"Mali-G71\" && unmaskedRenderer !== \"Mali-G72\" && unmaskedRenderer !== \"Mali-G76\";\n        if (allowFloatRender && undefined !== this.queryExtensionObject(\"EXT_float_blend\") && this.isTextureRenderable(gl, gl.FLOAT)) {\n            this._maxRenderType = RenderType.TextureFloat;\n        }\n        else if (this.isWebGL2) {\n            this._maxRenderType = (this.isTextureRenderable(gl, gl.HALF_FLOAT)) ? RenderType.TextureHalfFloat : RenderType.TextureUnsignedByte;\n        }\n        else {\n            const hfExt = this.queryExtensionObject(\"OES_texture_half_float\");\n            this._maxRenderType = (hfExt !== undefined && this.isTextureRenderable(gl, hfExt.HALF_FLOAT_OES)) ? RenderType.TextureHalfFloat : RenderType.TextureUnsignedByte;\n        }\n        // Determine the maximum depth attachment type.\n        // this._maxDepthType = this.queryExtensionObject(\"WEBGL_depth_texture\") !== undefined ? DepthType.TextureUnsignedInt32 : DepthType.RenderBufferUnsignedShort16;\n        this._maxDepthType = this._isWebGL2 || this.queryExtensionObject(\"WEBGL_depth_texture\") !== undefined ? DepthType.TextureUnsignedInt24Stencil8 : DepthType.RenderBufferUnsignedShort16;\n        this._presentFeatures = this._gatherFeatures();\n        const missingRequiredFeatures = this._findMissingFeatures(Capabilities.requiredFeatures);\n        const missingOptionalFeatures = this._findMissingFeatures(Capabilities.optionalFeatures);\n        return {\n            status: this._getCompatibilityStatus(missingRequiredFeatures, missingOptionalFeatures),\n            missingRequiredFeatures,\n            missingOptionalFeatures,\n            unmaskedRenderer,\n            unmaskedVendor,\n            usingIntegratedGraphics: isIntegratedGraphics({ unmaskedVendor, unmaskedRenderer }),\n            driverBugs: { ...this._driverBugs },\n            userAgent: navigator.userAgent,\n            createdContext: gl,\n        };\n    }\n    static create(gl, disabledExtensions) {\n        const caps = new Capabilities();\n        const compatibility = caps.init(gl, disabledExtensions);\n        if (WebGLRenderCompatibilityStatus.CannotCreateContext === compatibility.status || WebGLRenderCompatibilityStatus.MissingRequiredFeatures === compatibility.status)\n            return undefined;\n        return caps;\n    }\n    /** Determines if a particular texture type is color-renderable on the host system. */\n    isTextureRenderable(gl, texType) {\n        const tex = gl.createTexture();\n        gl.bindTexture(gl.TEXTURE_2D, tex);\n        if (this.isWebGL2) {\n            if (gl.FLOAT === texType)\n                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, 1, 1, 0, gl.RGBA, texType, null);\n            else\n                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA16F, 1, 1, 0, gl.RGBA, texType, null);\n        }\n        else\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, texType, null);\n        const fb = gl.createFramebuffer();\n        gl.bindFramebuffer(gl.FRAMEBUFFER, fb);\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);\n        const fbStatus = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        gl.deleteFramebuffer(fb);\n        gl.deleteTexture(tex);\n        gl.getError(); // clear any errors\n        return fbStatus === gl.FRAMEBUFFER_COMPLETE;\n    }\n    setMaxAnisotropy(desiredMax, gl) {\n        const ext = this.queryExtensionObject(\"EXT_texture_filter_anisotropic\");\n        if (undefined === ext)\n            return;\n        if (undefined === this._maxAnisotropy)\n            this._maxAnisotropy = gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT);\n        const max = (undefined !== desiredMax) ? Math.min(desiredMax, this._maxAnisotropy) : this._maxAnisotropy;\n        gl.texParameterf(gl.TEXTURE_2D, ext.TEXTURE_MAX_ANISOTROPY_EXT, max);\n    }\n}\nCapabilities.optionalFeatures = [\n    WebGLFeature.MrtTransparency,\n    WebGLFeature.MrtPick,\n    WebGLFeature.DepthTexture,\n    WebGLFeature.FloatRendering,\n    WebGLFeature.Instancing,\n    WebGLFeature.ShadowMaps,\n    WebGLFeature.FragDepth,\n    WebGLFeature.StandardDerivatives,\n    WebGLFeature.AntiAliasing,\n];\nCapabilities.requiredFeatures = [\n    WebGLFeature.UintElementIndex,\n    WebGLFeature.MinimalTextureUnits,\n];\nexport { Capabilities };\n//# sourceMappingURL=Capabilities.js.map",
      "start": 1693508124569,
      "end": 1693508124639,
      "sourcemaps": null
    }
  ]
}
