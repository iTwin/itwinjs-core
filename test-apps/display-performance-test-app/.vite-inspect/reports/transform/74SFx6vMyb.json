{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/polyface/multiclip/RangeSearch.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module RangeSearch\n */\nimport { Geometry } from \"../../Geometry\";\nimport { Range2d } from \"../../geometry3d/Range\";\nimport { GriddedRaggedRange2dSetWithOverflow } from \"./GriddedRaggedRange2dSetWithOverflow\";\nimport { LinearSearchRange2dArray } from \"./LinearSearchRange2dArray\";\n/** Class with static members to work with various range searchers. */\nclass RangeSearch {\n    /** Based on range count and distribution, return an object which can answer 2d range queries */\n    static create2dSearcherForRangeLengthData(rangeLengthData, rangesPerBlockEdge = RangeSearch.defaultRangesPerBlockEdge, standardDeviationAdjustment = RangeSearch.defaultStandardDeviationAdjustment) {\n        // for smallish sets, just linear search  . . ..\n        if (rangeLengthData.xSums.count < RangeSearch.smallCountLimit)\n            return new LinearSearchRange2dArray();\n        const numXBlock = this.estimateGridBlockCount(rangeLengthData.range.xLength(), rangeLengthData.xSums, rangesPerBlockEdge, standardDeviationAdjustment);\n        const numYBlock = this.estimateGridBlockCount(rangeLengthData.range.yLength(), rangeLengthData.ySums, rangesPerBlockEdge, standardDeviationAdjustment);\n        if (numXBlock < 2 && numYBlock < 2)\n            return new LinearSearchRange2dArray();\n        return GriddedRaggedRange2dSetWithOverflow.create(Range2d.createFrom(rangeLengthData.range), numXBlock, numYBlock);\n    }\n    /** Return the number of grid bocks (in one direction) for\n     * * The total range length in this direction\n     * * individual ranges whose count, mean and standard deviation are available in the sums.\n     * @param totalRange the total range being searched (in this direction)\n     * @param sums source for mean, count, and standard deviation of individual ranges\n     * @param rangesPerBlockEdge target ratio of edge length in search blocks divided by representative length of individual range edges\n     * @param standardDeviationAdjustment the number of standard deviations above the mean to be applied to convert mean to representative length.  Typically 0 to 1.\n     * @returns number of blocks in grid.\n     */\n    static estimateGridBlockCount(totalLength, sums, rangesPerBlockEdge = RangeSearch.defaultRangesPerBlockEdge, standardDeviationAdjustment = RangeSearch.defaultStandardDeviationAdjustment) {\n        if (sums.count < 1)\n            return 1;\n        const representativeRangeLength = rangesPerBlockEdge * (sums.mean + standardDeviationAdjustment * sums.standardDeviation);\n        const gridEdgeLength = Geometry.conditionalDivideFraction(totalLength, representativeRangeLength);\n        if (gridEdgeLength === undefined)\n            return 1;\n        return Math.ceil(gridEdgeLength);\n    }\n}\nRangeSearch.smallCountLimit = 40;\n/** Target size for grid block size divided by representative per-entry range size. */\nRangeSearch.defaultRangesPerBlockEdge = 4;\n/** the \"representative range size\"is the mean range size plus this number of standard deviations */\nRangeSearch.defaultStandardDeviationAdjustment = 1.0;\nexport { RangeSearch };\n//# sourceMappingURL=RangeSearch.js.map",
      "start": 1693508124325,
      "end": 1693508124417,
      "sourcemaps": null
    }
  ]
}
