{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/curve/spiral/ClothoidSeries.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Curve\n */\nimport { Geometry } from \"../../Geometry\";\nimport { XYCurveEvaluator } from \"./XYCurveEvaluator\";\nimport { SimpleNewton } from \"../../numerics/Newton\";\n/**\n * Methods to evaluate caller-specified number of terms of the x and y series for a clothoid.\n * Each instance has\n * * Number of x and y terms to use.\n * * constant for theta=c * x * x\n *    * This value is c=1/(2 R L)  for curve length L measured from inflection to point with radius R.\n * @internal\n */\nexport class ClothoidSeriesRLEvaluator extends XYCurveEvaluator {\n    constructor(nominalLength1, constantDiv2LR, numXTerms = 4, numYTerms = 4) {\n        super();\n        this.nominalLength1 = nominalLength1;\n        this.constantDiv2LR = constantDiv2LR;\n        this.numXTerms = numXTerms;\n        this.numYTerms = numYTerms;\n    }\n    /** Return a deep clone. */\n    clone() {\n        return new ClothoidSeriesRLEvaluator(this.nominalLength1, this.constantDiv2LR, this.numXTerms, this.numYTerms);\n    }\n    scaleInPlace(scaleFactor) {\n        this.nominalLength1 *= scaleFactor;\n        this.constantDiv2LR /= (scaleFactor * scaleFactor);\n    }\n    /** Member by member matchup ... */\n    isAlmostEqual(other) {\n        if (other instanceof ClothoidSeriesRLEvaluator) {\n            return this.numXTerms === other.numXTerms\n                && this.numYTerms === other.numYTerms\n                && Geometry.isAlmostEqualNumber(this.constantDiv2LR, other.constantDiv2LR)\n                && Geometry.isSameCoordinate(this.nominalLength1, other.nominalLength1);\n        }\n        return false;\n    }\n    /**\n     * Evaluate the X series at a nominal distance along the curve.\n     * @param fraction fractional position along the curve.\n     */\n    fractionToX(fraction) { return this.fractionToXGo(fraction, this.numXTerms); }\n    /**\n     * Evaluate the Y series at a nominal distance along the curve.\n     * @param fraction fractional position along the curve.\n     */\n    fractionToY(fraction) { return this.fractionToYGo(fraction, this.numYTerms); }\n    /**\n     * Evaluate the derivative of the X series at a nominal distance along the curve.\n     * @param fraction fractional position along the curve.\n     */\n    fractionToDX(fraction) { return this.fractionToDXGo(fraction, this.numXTerms); }\n    /**\n     * Evaluate the derivative of the Y series at a nominal distance along the curve.\n     * @param fraction fractional position along the curve.\n     */\n    fractionToDY(fraction) { return this.fractionToDYGo(fraction, this.numYTerms); }\n    /**\n     * Evaluate the derivative of the X series at a nominal distance along the curve.\n     * @param fraction fractional position along the curve.\n     */\n    fractionToDDX(fraction) { return this.fractionToDDXGo(fraction, this.numXTerms); }\n    /**\n     * Evaluate the derivative of the Y series at a nominal distance along the curve.\n     * @param fraction fractional position along the curve.\n     */\n    fractionToDDY(fraction) { return this.fractionToDDYGo(fraction, this.numYTerms); }\n    /**\n     * Evaluate the X series at a nominal distance along the curve.\n     * @param fraction fractional position along the curve.\n     * @param numTerms number of terms to use.\n     */\n    fractionToXGo(fraction, numTerms) {\n        // Write the series for cos (theta)\n        // replace theta by s*s*c\n        // integrate wrt s\n        //  x = s - s^5 c^4/ 2 + s^9 c^8/(4!) - s^13 c^12 / 6!\n        //  x = s(1 - (s^4 c^2/2) ( 1/5 -s^4 c^2 / (3*4)  ( 1/9 - ....) ) )\n        const s = fraction * this.nominalLength1;\n        let result = s;\n        if (numTerms < 2)\n            return result;\n        const q1 = s * s * this.constantDiv2LR;\n        const beta = -q1 * q1;\n        let alpha = s;\n        let m = 1;\n        let n = 5;\n        for (let i = 1; i < numTerms; i++) {\n            alpha *= beta / (m * (m + 1));\n            result += alpha / n;\n            m += 2;\n            n += 4;\n        }\n        return result;\n    }\n    fractionToYGo(fraction, numTerms) {\n        // Write the series for sin (theta)\n        // replace theta by s*s*c\n        // integrate wrt s\n        //  x = s^3 c^2/ 3( (1/3)) - s^7 c^6/(3!) ((1/7)) - s^11 c^10 / 5! ((1/9) - ...)\n        const s = fraction * this.nominalLength1;\n        const q1 = s * s * this.constantDiv2LR;\n        let result = q1 * s / 3;\n        if (numTerms < 2)\n            return result;\n        const beta = -q1 * q1;\n        let alpha = q1 * s;\n        let m = 2;\n        let n = 7;\n        for (let i = 1; i < numTerms; i++) {\n            alpha *= beta / (m * (m + 1));\n            result += alpha / n;\n            m += 2;\n            n += 4;\n        }\n        return result;\n    }\n    fractionToDXGo(fraction, numTerms) {\n        // Yes -- this does happen during derivatives of cosines with more than 0 terms !!\n        if (numTerms <= 0)\n            return 0;\n        // dX = 1 - s^4c^2/2 + s^8 c^4 / 4! -\n        // new Term = old Term * beta / (m(m+1))\n        const s = fraction * this.nominalLength1;\n        let result = 1;\n        if (numTerms < 2) {\n            return result * this.nominalLength1;\n        }\n        const q1 = s * s * this.constantDiv2LR;\n        const beta = -q1 * q1;\n        let alpha = 1.0;\n        let m = 1;\n        for (let i = 1; i < numTerms; i++) {\n            alpha *= beta / (m * (m + 1));\n            result += alpha;\n            m += 2;\n        }\n        return result * this.nominalLength1;\n    }\n    fractionToDYGo(fraction, numTerms) {\n        if (numTerms <= 0)\n            return 0;\n        // dY = q - q^3/3!\n        // q = s^2 c\n        // dY = s^2 c - s^6 c^3/3! + s^10 c^5/ 5!\n        // recurrence  advancing m by 2  alpha *= -(s^4 c^2) / (m(m+1))\n        const s = fraction * this.nominalLength1;\n        const q1 = s * s * this.constantDiv2LR;\n        let result = q1;\n        if (numTerms < 2)\n            return result * this.nominalLength1;\n        const beta = -q1 * q1;\n        let alpha = q1;\n        let m = 2;\n        for (let i = 1; i < numTerms; i++) {\n            alpha *= beta / (m * (m + 1));\n            result += alpha;\n            m += 2;\n        }\n        return result * this.nominalLength1;\n    }\n    fractionToDDXGo(fraction, numTerms) {\n        // DX is \"cosine\"\n        // DDX is \"- sine\" series times chain rule dTheta/ds = 2 * s * this.constantDivLR\n        const s = fraction * this.nominalLength1;\n        const dTheta = 2 * this.constantDiv2LR * s;\n        const sine = this.fractionToDYGo(fraction, numTerms - 1);\n        const resultA = (-dTheta * sine * this.nominalLength1);\n        return resultA;\n    }\n    fractionToDDYGo(fraction, numTerms) {\n        // DY is \"sine\"\n        // DDY is \"cosine\" series times chain rule dTheta/ds = 2 * s * this.constantDivLR\n        // BUT  .... derivative of the cosine series leading term is zero ... use one less term!\n        const s = fraction * this.nominalLength1;\n        const dTheta = 2 * this.constantDiv2LR * s;\n        const cosine = this.fractionToDXGo(fraction, numTerms);\n        return cosine * dTheta * this.nominalLength1;\n    }\n    fractionToD3X(fraction) {\n        if (this.numXTerms <= 1)\n            return 0.0;\n        // DX is \"cosine\"\n        // DDX is \"- sine\" series times chain rule dTheta/ds = 2 * s * this.constantDivLR\n        const s = fraction * this.nominalLength1;\n        const dTheta = 2.0 * this.constantDiv2LR * s;\n        const d2Theta = 2.0 * this.constantDiv2LR;\n        const sine = this.fractionToDYGo(fraction, this.numXTerms - 1);\n        const cosine = this.fractionToDXGo(fraction, this.numXTerms - 1);\n        return (-cosine * dTheta * dTheta - sine * d2Theta) * this.nominalLength1 * this.nominalLength1;\n    }\n    fractionToD3Y(fraction) {\n        // DY is \"sine\"\n        // DDY is \"cosine\" series times chain rule dTheta/ds = 2 * s * this.constantDivLR\n        const s = fraction * this.nominalLength1;\n        const dTheta = 2.0 * this.constantDiv2LR * s;\n        const d2Theta = 2.0 * this.constantDiv2LR;\n        // dY is sine series with numYTerms.\n        // ddY is cosine series.  Leading term of sine series is non-constant, so numYTerms here also\n        // d3Y is sine series. Derivative of preceding cosine killed first term.\n        const cosine = this.fractionToDXGo(fraction, this.numYTerms);\n        const sine = this.fractionToDYGo(fraction, this.numYTerms - 1);\n        return (-sine * dTheta * dTheta + cosine * d2Theta) * this.nominalLength1 * this.nominalLength1;\n    }\n    xToFraction(x) {\n        const fraction0 = x / this.nominalLength1;\n        const fraction1 = SimpleNewton.runNewton1D(fraction0, (f) => (this.fractionToX(f) - x), (f) => this.fractionToDX(f));\n        if (fraction1 === undefined)\n            return undefined;\n        return fraction1;\n    }\n}\n//# sourceMappingURL=ClothoidSeries.js.map",
      "start": 1693508124212,
      "end": 1693508124344,
      "sourcemaps": null
    }
  ]
}
