{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/ViewManager.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Views\n */\nimport { BeEvent, BentleyStatus, BeUiEvent } from \"@itwin/core-bentley\";\nimport { IModelApp } from \"./IModelApp\";\nimport { DisclosedTileTreeSet } from \"./tile/internal\";\nimport { EventHandled } from \"./tools/Tool\";\nimport { System } from \"./render/webgl/System\";\n/** The ViewManager holds the list of opened views, plus the *selected view*. It also provides notifications of view open/close and suspend/resume.\n * Applications must call [[addViewport]] when new Viewports that should be associated with user events are created.\n *\n * A single ViewManager is created when [[IModelApp.startup]] is called. It can be accessed via the static member [[IModelApp.viewManager]].\n *\n * The ViewManager controls the render loop, which causes the contents of each registered [[Viewport]] to update on the screen.\n * @public\n * @extensions\n */\nexport class ViewManager {\n    constructor() {\n        this.inDynamicsMode = false;\n        this.cursor = \"default\";\n        this._viewports = [];\n        this.decorators = [];\n        this._invalidateScenes = false;\n        this._skipSceneCreation = false;\n        this._doIdleWork = false;\n        /** @internal */\n        this.toolTipProviders = [];\n        /** Called after the selected view changes.\n         * @param old Previously selected viewport.\n         * @param current Currently selected viewport.\n         */\n        this.onSelectedViewportChanged = new BeUiEvent();\n        /** Called after a view is opened. This can happen when the iModel is first opened or when a user opens a new view. */\n        this.onViewOpen = new BeUiEvent();\n        /** Called after a view is closed. This can happen when the iModel is closed or when a user closes an open view. */\n        this.onViewClose = new BeUiEvent();\n        /** Called after a view is suspended. This happens when the application is minimized or, on a tablet, when the application\n         * is moved to the background.\n         */\n        this.onViewSuspend = new BeUiEvent();\n        /** Called after a suspended view is resumed. This can happen when a minimized application is restored\n         * or, on a tablet, when the application is moved to the foreground.\n         */\n        this.onViewResume = new BeUiEvent();\n        /** Called at the beginning of each tick of the render loop, before any viewports have been updated.\n         * The render loop is typically invoked by a requestAnimationFrame() callback. It will not be invoked if the ViewManager is tracking no viewports.\n         * @note Due to the frequency of this event, avoid performing expensive work inside event listeners.\n         * @see [[ViewManager.onFinishRender]]\n         */\n        this.onBeginRender = new BeEvent();\n        /** Called at the end of each tick of the render loop, after all viewports have been updated.\n         * The render loop is typically invoked by a requestAnimationFrame() callback. It will not be invoked if the ViewManager is tracking no viewports.\n         * @note Due to the frequency of this event, avoid performing expensive work inside event listeners.\n         * @see [[ViewManager.onBeginRender]]\n         */\n        this.onFinishRender = new BeEvent();\n    }\n    _beginIdleWork() {\n        const idleWork = () => {\n            if (undefined === this._idleWorkTimer)\n                return;\n            if (this._viewports.length > 0) {\n                this._idleWorkTimer = undefined;\n                return;\n            }\n            if (IModelApp.renderSystem.doIdleWork())\n                this._idleWorkTimer = setTimeout(idleWork, 1);\n            else\n                this._idleWorkTimer = undefined;\n        };\n        if (undefined === this._idleWorkTimer)\n            this._idleWorkTimer = setTimeout(idleWork, 1);\n    }\n    /** @internal */\n    onInitialized() {\n        this.addDecorator(IModelApp.accuSnap);\n        this.addDecorator(IModelApp.tentativePoint);\n        this.addDecorator(IModelApp.accuDraw);\n        this.addDecorator(IModelApp.toolAdmin);\n        this.cursor = \"default\";\n        const options = IModelApp.renderSystem.options;\n        this._doIdleWork = true === options.doIdleWork;\n        if (this._doIdleWork)\n            this._beginIdleWork();\n    }\n    /** @internal */\n    onShutDown() {\n        if (undefined !== this._idleWorkTimer) {\n            clearTimeout(this._idleWorkTimer);\n            this._idleWorkTimer = undefined;\n        }\n        this._viewports.length = 0;\n        this.decorators.length = 0;\n        this.toolTipProviders.length = 0;\n        this._selectedView = undefined;\n    }\n    /** Returns true if the specified viewport is currently being managed by this ViewManager.\n     * @see [[addViewport]] to enable management of a viewport and [[dropViewport]] to disable it.\n     */\n    hasViewport(viewport) {\n        return this._viewports.includes(viewport);\n    }\n    /** @internal */\n    endDynamicsMode() {\n        if (!this.inDynamicsMode)\n            return;\n        this.inDynamicsMode = false;\n        const cursorVp = IModelApp.toolAdmin.cursorView;\n        if (cursorVp)\n            cursorVp.changeDynamics(undefined);\n        for (const vp of this._viewports) {\n            if (vp !== cursorVp)\n                vp.changeDynamics(undefined);\n        }\n    }\n    /** @internal */\n    beginDynamicsMode() { this.inDynamicsMode = true; }\n    /** @internal */\n    get doesHostHaveFocus() { return document.hasFocus(); }\n    /** Set the selected [[Viewport]] to undefined. */\n    clearSelectedView() {\n        const previousVp = this.selectedView;\n        this._selectedView = undefined;\n        this.notifySelectedViewportChanged(previousVp, undefined);\n    }\n    /** Sets the selected [[Viewport]]. */\n    async setSelectedView(vp) {\n        if (undefined === vp)\n            vp = this.getFirstOpenView();\n        if (vp === this.selectedView) // already the selected view\n            return BentleyStatus.SUCCESS;\n        if (undefined === vp) {\n            this.clearSelectedView();\n            return BentleyStatus.ERROR;\n        }\n        const previousVp = this.selectedView;\n        this._selectedView = vp;\n        this.notifySelectedViewportChanged(previousVp, vp);\n        if (undefined === previousVp)\n            await IModelApp.toolAdmin.startDefaultTool();\n        return BentleyStatus.SUCCESS;\n    }\n    /** @internal */\n    notifySelectedViewportChanged(previous, current) {\n        IModelApp.toolAdmin.onSelectedViewportChanged(previous, current); // eslint-disable-line @typescript-eslint/no-floating-promises\n        this.onSelectedViewportChanged.emit({ previous, current });\n    }\n    /** The \"selected view\" is the default for certain operations.  */\n    get selectedView() { return this._selectedView; }\n    /** Get the first opened view. */\n    getFirstOpenView() { return this._viewports.length > 0 ? this._viewports[0] : undefined; }\n    /** Check if only a single viewport is being used.  If so, render directly on-screen using its WebGL canvas.  Otherwise, render each view offscreen. */\n    updateRenderToScreen() {\n        const renderToScreen = 1 === this._viewports.length;\n        for (const vp of this)\n            vp.rendersToScreen = renderToScreen;\n    }\n    /** Add a new Viewport to the list of opened views and create an EventController for it.\n     * @param newVp the Viewport to add\n     * @returns SUCCESS if vp was successfully added, ERROR if it was already present.\n     * @note raises onViewOpen event with newVp.\n     */\n    addViewport(newVp) {\n        if (this.hasViewport(newVp)) // make sure its not already added\n            return BentleyStatus.ERROR;\n        newVp.onViewManagerAdd();\n        this._viewports.push(newVp);\n        this.updateRenderToScreen();\n        this.setSelectedView(newVp); // eslint-disable-line @typescript-eslint/no-floating-promises\n        // Start up the render loop if necessary.\n        if (1 === this._viewports.length)\n            IModelApp.startEventLoop();\n        this.onViewOpen.emit(newVp);\n        return BentleyStatus.SUCCESS;\n    }\n    /** Remove a Viewport from the list of opened views, and optionally dispose of it.\n     * Typically a Viewport is dropped when it is no longer of any use to the application, in which case it should also be\n     * disposed of as it may hold significant GPU resources.\n     * However in some cases a Viewport may be temporarily dropped to suspend rendering; and subsequently re-added to\n     * resume rendering - for example, when the Viewport is temporarily hidden by other UI elements.\n     * In the latter case it is up to the caller to ensure the Viewport is properly disposed of when it is no longer needed.\n     * Attempting to invoke any function on a Viewport after it has been disposed is an error.\n     * @param vp the Viewport to remove.\n     * @param disposeOfViewport Whether or not to dispose of the Viewport. Defaults to true.\n     * @return SUCCESS if vp was successfully removed, ERROR if it was not present.\n     * @note raises onViewClose event with vp.\n     */\n    dropViewport(vp, disposeOfViewport = true) {\n        const index = this._viewports.indexOf(vp);\n        if (index === -1)\n            return BentleyStatus.ERROR;\n        this.onViewClose.emit(vp);\n        // make sure tools don't think the cursor is still in this viewport\n        IModelApp.toolAdmin.forgetViewport(vp);\n        vp.onViewManagerDrop();\n        this._viewports.splice(index, 1);\n        if (this.selectedView === vp) // if removed viewport was selectedView, set it to undefined.\n            this.setSelectedView(undefined); // eslint-disable-line @typescript-eslint/no-floating-promises\n        vp.rendersToScreen = false;\n        this.updateRenderToScreen();\n        if (disposeOfViewport)\n            vp.dispose();\n        if (this._doIdleWork && this._viewports.length === 0)\n            this._beginIdleWork();\n        return BentleyStatus.SUCCESS;\n    }\n    /** Iterate over the viewports registered with the view manager. */\n    [Symbol.iterator]() {\n        return this._viewports[Symbol.iterator]();\n    }\n    /** Force each registered [[Viewport]] to regenerate all of its cached [[Decorations]] on the next frame. If the decorator parameter is specified, only\n     * the specified decorator will have its cached decorations invalidated for all viewports.\n     * @see [[Viewport.invalidateCachedDecorations]] to manually remove a decorator's cached decorations from a viewport, forcing them to be regenerated.\n     * @beta\n     */\n    invalidateCachedDecorationsAllViews(decorator) {\n        if (decorator.useCachedDecorations)\n            for (const vp of this)\n                vp.invalidateCachedDecorations(decorator);\n    }\n    /** Force each registered [[Viewport]] to regenerate its [[Decorations]] on the next frame. */\n    invalidateDecorationsAllViews() {\n        for (const vp of this)\n            vp.invalidateDecorations();\n    }\n    /** Force each registered [[Viewport]] to regenerate its [[FeatureSymbology.Overrides]] on the next frame.\n     * This is rarely needed - viewports keep track of their own states to detect when the overrides need to be recreated.\n     */\n    invalidateSymbologyOverridesAllViews() {\n        for (const vp of this)\n            vp.setFeatureOverrideProviderChanged();\n    }\n    /** @internal */\n    onSelectionSetChanged(_iModel) {\n        for (const vp of this)\n            vp.markSelectionSetDirty();\n        IModelApp.requestNextAnimation();\n    }\n    /** @internal */\n    invalidateViewportScenes() {\n        for (const vp of this)\n            vp.invalidateScene();\n    }\n    /** @internal */\n    validateViewportScenes() {\n        for (const vp of this)\n            vp.setValidScene();\n    }\n    /** Requests that [[Viewport.createScene]] be invoked for every viewport on the next frame.\n     * This is rarely useful - viewports keep track of their own states to detect when the scene needs to be recreated.\n     */\n    invalidateScenes() {\n        this._invalidateScenes = true;\n        IModelApp.requestNextAnimation();\n    }\n    /** @internal */\n    get sceneInvalidated() { return this._invalidateScenes; }\n    /** Invoked by ToolAdmin event loop.\n     * @internal\n     */\n    renderLoop() {\n        if (0 === this._viewports.length)\n            return;\n        if (this._skipSceneCreation)\n            this.validateViewportScenes();\n        else if (this._invalidateScenes)\n            this.invalidateViewportScenes();\n        this._invalidateScenes = false;\n        this.onBeginRender.raiseEvent();\n        for (const vp of this._viewports)\n            vp.renderFrame();\n        this.onFinishRender.raiseEvent();\n    }\n    /** Purge TileTrees that haven't been drawn since the specified time point and are not currently in use by any ScreenViewport.\n     * Intended strictly for debugging purposes - TileAdmin takes care of properly purging.\n     * @internal\n     */\n    purgeTileTrees(olderThan) {\n        // A single viewport can display tiles from more than one IModelConnection.\n        // NOTE: A viewport may be displaying no trees - but we need to record its IModel so we can purge those which are NOT being displayed\n        //  NOTE: That won't catch external tile trees previously used by that viewport.\n        const trees = new DisclosedTileTreeSet();\n        const treesByIModel = new Map();\n        for (const vp of this._viewports) {\n            vp.discloseTileTrees(trees);\n            if (undefined === treesByIModel.get(vp.iModel))\n                treesByIModel.set(vp.iModel, new Set());\n        }\n        for (const tree of trees) {\n            let set = treesByIModel.get(tree.iModel);\n            if (undefined === set) {\n                set = new Set();\n                treesByIModel.set(tree.iModel, set);\n            }\n            set.add(tree);\n        }\n        for (const entry of treesByIModel) {\n            const iModel = entry[0];\n            iModel.tiles.purge(olderThan, entry[1]);\n        }\n    }\n    /** Get the tooltip for a persistent element.\n     * Calls the backend method [Element.getToolTipMessage]($backend), and replaces all instances of `${localizeTag}` with localized string from IModelApp.i18n.\n     * @beta\n     */\n    async getElementToolTip(hit) {\n        const msg = await hit.iModel.getToolTipMessage(hit.sourceId); // wait for the locate message(s) from the backend\n        return IModelApp.formatElementToolTip(msg);\n    }\n    /** Register a new [[ToolTipProvider]] to customize the locate tooltip.\n     * @param provider The new tooltip provider to add.\n     * @throws Error if `provider` is already registered.\n     * @returns a function that may be called to remove this provider (in lieu of calling [[dropToolTipProvider]].)\n     */\n    addToolTipProvider(provider) {\n        if (this.toolTipProviders.includes(provider))\n            throw new Error(\"tooltip provider already registered\");\n        this.toolTipProviders.push(provider);\n        return () => this.dropToolTipProvider(provider);\n    }\n    /** Drop (remove) a [[ToolTipProvider]] so it is no longer active.\n     * @param provider The tooltip provider to drop.\n     * @note Does nothing if provider is not currently active.\n     */\n    dropToolTipProvider(provider) {\n        const index = this.toolTipProviders.indexOf(provider);\n        if (index >= 0)\n            this.toolTipProviders.splice(index, 1);\n    }\n    /** Add a new [[Decorator]] to display decorations into the active views.\n     * @param decorator The new decorator to add.\n     * @throws Error if decorator is already active.\n     * @returns a function that may be called to remove this decorator (in lieu of calling [[dropDecorator]].)\n     * @see [[dropDecorator]]\n     */\n    addDecorator(decorator) {\n        if (this.decorators.includes(decorator))\n            throw new Error(\"decorator already registered\");\n        this.decorators.push(decorator);\n        this.invalidateDecorationsAllViews();\n        return () => this.dropDecorator(decorator);\n    }\n    /** Drop (remove) a [[Decorator]] so it is no longer active.\n     * @param decorator The Decorator to drop.\n     * @returns true if the decorator was found and removed; false if the decorator was not found.\n     */\n    dropDecorator(decorator) {\n        const index = this.decorators.indexOf(decorator);\n        if (index < 0)\n            return false;\n        this.invalidateCachedDecorationsAllViews(decorator);\n        this.decorators.splice(index, 1);\n        this.invalidateDecorationsAllViews();\n        return true;\n    }\n    /** Get the tooltip for a pickable decoration.\n     * @internal\n     */\n    async getDecorationToolTip(hit) {\n        for (const decorator of this.decorators) {\n            if (undefined !== decorator.testDecorationHit && undefined !== decorator.getDecorationToolTip && decorator.testDecorationHit(hit.sourceId))\n                return decorator.getDecorationToolTip(hit);\n        }\n        return hit.viewport ? hit.viewport.getToolTip(hit) : \"\";\n    }\n    /** Allow a pickable decoration to handle a button event that identified it for the SelectTool.\n     * @internal\n     */\n    async onDecorationButtonEvent(hit, ev) {\n        for (const decorator of IModelApp.viewManager.decorators) {\n            if (undefined !== decorator.testDecorationHit && undefined !== decorator.onDecorationButtonEvent && decorator.testDecorationHit(hit.sourceId))\n                return decorator.onDecorationButtonEvent(hit, ev);\n        }\n        return EventHandled.No;\n    }\n    /** Allow a pickable decoration to be snapped to by AccuSnap or TentativePoint.\n     * @internal\n     */\n    getDecorationGeometry(hit) {\n        for (const decorator of IModelApp.viewManager.decorators) {\n            if (undefined !== decorator.testDecorationHit && undefined !== decorator.getDecorationGeometry && decorator.testDecorationHit(hit.sourceId))\n                return decorator.getDecorationGeometry(hit);\n        }\n        return undefined;\n    }\n    /** Allow a pickable decoration created using a persistent element id to augment or replace the the persistent element's tooltip.\n     * @internal\n     */\n    async overrideElementToolTip(hit) {\n        for (const decorator of this.decorators) {\n            if (undefined !== decorator.overrideElementHit && undefined !== decorator.getDecorationToolTip && decorator.overrideElementHit(hit))\n                return decorator.getDecorationToolTip(hit);\n        }\n        return this.getElementToolTip(hit);\n    }\n    /** Allow a pickable decoration created using a persistent element id to handle a button event that identified it for the SelectTool.\n     * @internal\n     */\n    async overrideElementButtonEvent(hit, ev) {\n        for (const decorator of IModelApp.viewManager.decorators) {\n            if (undefined !== decorator.overrideElementHit && undefined !== decorator.onDecorationButtonEvent && decorator.overrideElementHit(hit))\n                return decorator.onDecorationButtonEvent(hit, ev);\n        }\n        return EventHandled.No;\n    }\n    /** Allow a pickable decoration created using a persistent element id to control whether snapping uses the persistent element's geometry.\n     * @internal\n     */\n    overrideElementGeometry(hit) {\n        for (const decorator of IModelApp.viewManager.decorators) {\n            if (undefined !== decorator.overrideElementHit && undefined !== decorator.getDecorationGeometry && decorator.overrideElementHit(hit))\n                return decorator.getDecorationGeometry(hit);\n        }\n        return undefined;\n    }\n    get crossHairCursor() { return `url(${IModelApp.publicPath}cursors/crosshair.cur), crosshair`; }\n    get dynamicsCursor() { return `url(${IModelApp.publicPath}cursors/dynamics.cur), move`; }\n    get grabCursor() { return `url(${IModelApp.publicPath}cursors/openHand.cur), auto`; }\n    get grabbingCursor() { return `url(${IModelApp.publicPath}cursors/closedHand.cur), auto`; }\n    get walkCursor() { return `url(${IModelApp.publicPath}cursors/walk.cur), auto`; }\n    get rotateCursor() { return `url(${IModelApp.publicPath}cursors/rotate.cur), auto`; }\n    get lookCursor() { return `url(${IModelApp.publicPath}cursors/look.cur), auto`; }\n    get zoomCursor() { return `url(${IModelApp.publicPath}cursors/zoom.cur), auto`; }\n    /** Change the cursor shown in all Viewports.\n     * @param cursor The new cursor to display. If undefined, the default cursor is used.\n     */\n    setViewCursor(cursor = \"default\") {\n        if (cursor === this.cursor)\n            return;\n        this.cursor = cursor;\n        for (const vp of this._viewports)\n            vp.setCursor(cursor);\n    }\n    /** Intended strictly as a temporary solution for interactive editing applications, until official support for such apps is implemented.\n     * Call this after editing one or more models, passing in the Ids of those models, to cause new tiles to be generated reflecting the changes.\n     * Pass undefined if you are unsure which models changed (this is less efficient as it discards all tiles for all viewed models in all viewports).\n     * @internal\n     */\n    refreshForModifiedModels(modelIds) {\n        for (const vp of this._viewports)\n            vp.refreshForModifiedModels(modelIds);\n    }\n    /** Sets the number of [MSAA]($docs/learning/display/MSAA.md) samples for all currently- and subsequently-opened [[ScreenViewport]]s.\n     * @param numSamples The number of samples as a power of two. Values of 1 or less indicates anti-aliasing should be disabled. Non-power-of-two values are rounded\n     * down to the nearest power of two. The maximum number of samples supported depends upon the client's graphics hardware capabilities. Higher values produce\n     * a higher-quality image but also may also reduce framerate.\n     * @see [[Viewport.antialiasSamples]] to adjust the number of samples for a specific viewport.\n     */\n    setAntialiasingAllViews(numSamples) {\n        for (const vp of this)\n            vp.antialiasSamples = numSamples;\n        System.instance.antialiasSamples = numSamples;\n    }\n}\n//# sourceMappingURL=ViewManager.js.map",
      "start": 1693508119282,
      "end": 1693508119433,
      "sourcemaps": null
    }
  ]
}
