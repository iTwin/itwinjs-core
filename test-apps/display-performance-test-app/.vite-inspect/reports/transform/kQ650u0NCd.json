{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/numerics/BandedSystem.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\nimport { Geometry } from \"../Geometry\";\n/**\n * `BandedSystem` is a class with static methods for solving banded linear systems, such as in computing\n * Bspline poles for pass-through points\n * @internal\n */\nexport class BandedSystem {\n    /** apply LU decomposition to a banded system */\n    static decomposeLU(numRow, bw, /* band width */ data) {\n        const n = numRow - 1;\n        const sbw = Math.floor(bw / 2); // ASSUMES bw is odd?\n        let sum;\n        // Phase 1:\n        //   [A b C]\n        //   [d q f]\n        //   [G h I]\n        // q is a diagonal (pivot\n        // d, f are row vectors\n        // A,C,I are blocks\n        // b,h are column vectors.\n        // Phase 1:  [q,f] -= d * [b,C]\n        // Phase 2: h = (h- G*b)/q\n        // This is standard gaussian elimination, but in row-think rather than the usual column-think\n        for (let i = 0; i <= n; i++) {\n            const jh = Math.min(n, i + sbw);\n            for (let j = i; j <= jh; j++) {\n                const kl = Math.max(0, j - sbw);\n                sum = 0.0;\n                for (let k = kl; k < i; k++)\n                    sum += data[i * bw + k - i + sbw] * data[k * bw + j - k + sbw];\n                data[i * bw + j - i + sbw] -= sum;\n            }\n            for (let j = i + 1; j <= jh; j++) {\n                const kl = Math.max(0, j - sbw);\n                sum = 0.0;\n                for (let k = kl; k < i; k++)\n                    sum += data[j * bw + k - j + sbw] * data[k * bw + i - k + sbw];\n                if (Math.abs(data[i * bw + sbw]) < 1e-9) // TODO -- tolerance !!!\n                    return false;\n                data[j * bw + i - j + sbw] = (data[j * bw + i - j + sbw] - sum) / data[i * bw + sbw];\n            }\n        }\n        return true;\n    }\n    /**\n     *\n     * @param sum evolving sum.  sum.length\n     * @param source data being added\n     * @param sourceRow row in source.  Plain offset is sourceRow * sum.length\n     * @param scale scale factor to apply.\n     */\n    static arrayAddScaledBlock(sum, source, sourceRow, scale) {\n        const n = sum.length;\n        let k = n * sourceRow;\n        for (let i = 0; i < n; i++, k++) {\n            sum[i] += source[k] * scale;\n        }\n    }\n    //   dest[destRow][*] = sourceA[sourceRow][*] - sourceB[*]\n    static blockAssignBlockMinusArray(dest, destRow, sourceA, sourceARow, sourceB) {\n        const n = sourceB.length;\n        let destIndex = destRow * n;\n        let sourceIndex = sourceARow * n;\n        for (let i = 0; i < n; i++, sourceIndex++, destIndex++) {\n            dest[destIndex] = sourceA[sourceIndex] - sourceB[i];\n        }\n    }\n    //   dest[destRow][*] = sourceA[sourceBRow][*] * scaleA - sourceB[*] * scaleB\n    static blockSumOfScaledBlockScaledArray(dest, destRow, sourceA, sourceBRow, scaleA, sourceB, scaleB) {\n        const n = sourceB.length;\n        let destIndex = destRow * n;\n        let sourceBIndex = sourceBRow * n;\n        for (let i = 0; i < n; i++, sourceBIndex++, destIndex++) {\n            dest[destIndex] = sourceA[sourceBIndex] * scaleA + sourceB[i] * scaleB;\n        }\n    }\n    /**\n     * Solve a linear system A*X=B where\n     * * A is nominally an `numRow*numRow` matrix, but is stored in banded row-major form\n     * * The band storage is `bw` numbers per row, with the middle value being the diagonal of that row.\n     *    * Hence rows near top and bottom have band values `outside` the matrix.\n     * * The right hand side is an `numRow*numRHS` matrix in row-major order.\n     * @param numRow number of rows (and columns) of the nominal full matrix.\n     * @param bw total bandwidth (diagonal + equal number of values to left and right)\n     * @param matrix the banded matrix, as packed row-major\n     * @param numRHS the number of right hand sides.\n     * @param rhs the right hand sides\n     */\n    static solveBandedSystemMultipleRHS(numRow, bw, /* band width */ matrix, numRHS, // number of components in each RHS row.\n    rhs) {\n        if (!this.decomposeLU(numRow, bw, matrix))\n            return undefined;\n        const n = numRow - 1;\n        const sbw = Math.floor(bw / 2);\n        const rhsRowS = new Float64Array(numRHS);\n        /* Compute solution vector */\n        // Z is solution vector . . .\n        const reducedRHS = new Float64Array(numRHS * numRow);\n        const result = new Float64Array(numRHS * numRow);\n        for (let i = 0; i <= n; i++) {\n            rhsRowS.fill(0);\n            const jl = Math.max(0, i - sbw);\n            for (let j = jl; j < i; j++) {\n                this.arrayAddScaledBlock(rhsRowS, reducedRHS, j, matrix[i * bw + j - i + sbw]);\n                // S.SumOf(S, Z[j], data[i * bw + j - i + sbw]);\n            }\n            this.blockAssignBlockMinusArray(reducedRHS, i, rhs, i, rhsRowS);\n        }\n        for (let i = n; i >= 0; i--) {\n            const fact = Geometry.conditionalDivideCoordinate(1.0, matrix[i * bw + sbw]);\n            if (fact === undefined)\n                return undefined;\n            rhsRowS.fill(0);\n            const jh = Math.min(n, i + sbw);\n            for (let j = i + 1; j <= jh; j++) {\n                // S.SumOf(S, Q[j], data[i * bw + j - i + sbw]);\n                this.arrayAddScaledBlock(rhsRowS, result, j, matrix[i * bw + j - i + sbw]);\n            }\n            this.blockSumOfScaledBlockScaledArray(result, i, reducedRHS, i, fact, rhsRowS, -fact);\n            // Q[i].SumOf(O, Z[i], fact, S, -fact);\n        }\n        return result;\n    }\n    /**\n     * Multiply a banded numRow*numRow matrix times a full numRow*numRHS, return as new matrix\n     */\n    static multiplyBandedTimesFull(numRow, bw, /* band width */ bandedMatrix, numRHS, // number of components in each RHS row.\n    rhs) {\n        const result = new Float64Array(rhs.length);\n        const halfBandWidth = Math.floor(bw / 2);\n        let sum, k0, k1, kRef;\n        for (let pivot = 0; pivot < numRow; pivot++) {\n            // \"k\" vars are nominal column indices in the matrix, and nominal row indices in the rhs.\n            k0 = pivot - halfBandWidth;\n            if (k0 < 0)\n                k0 = 0;\n            k1 = pivot + halfBandWidth + 1;\n            if (k1 > numRow)\n                k1 = numRow;\n            kRef = halfBandWidth + pivot * (bw - 1);\n            for (let m = 0; m < numRHS; m++) {\n                sum = 0;\n                for (let k = k0; k < k1; k++) {\n                    sum += bandedMatrix[kRef + k] * rhs[k * numRHS + m];\n                }\n                result[pivot * numRHS + m] = sum;\n            }\n        }\n        return result;\n    }\n}\n//# sourceMappingURL=BandedSystem.js.map",
      "start": 1693508124263,
      "end": 1693508124389,
      "sourcemaps": null
    }
  ]
}
