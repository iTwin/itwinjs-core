{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/common/lib/esm/geometry/GeodeticDatum.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Geometry\n */\n// cspell:ignore JSONXYZ, ETRF, OSGB, DHDN, NADCON, GEOCN\nimport { Geometry, Vector3d } from \"@itwin/core-geometry\";\nimport { GeodeticEllipsoid } from \"./GeodeticEllipsoid\";\n/** Hold 3 components data of a Positional Vector rotation definition in arc seconds\n *  @public\n */\nexport class XyzRotation {\n    constructor(data) {\n        if (data) {\n            this.x = data.x;\n            this.y = data.y;\n            this.z = data.z;\n        }\n    }\n    /** Creates a Rotations object from JSON representation.\n     * @public */\n    static fromJSON(data) {\n        return new XyzRotation(data);\n    }\n    /** Creates a JSON from the Rotations definition\n     * @public */\n    toJSON() {\n        return { x: this.x, y: this.y, z: this.z };\n    }\n    /** Compares two geodetic rotations. It applies a minuscule angular tolerance\n     *  @public */\n    equals(other) {\n        return (Math.abs(this.x - other.x) < Geometry.smallAngleSeconds &&\n            Math.abs(this.y - other.y) < Geometry.smallAngleSeconds &&\n            Math.abs(this.z - other.z) < Geometry.smallAngleSeconds);\n    }\n}\n/** This class represents a geocentric (three parameters) geodetic transformation.\n *  @public\n */\nexport class GeocentricTransform {\n    constructor(data) {\n        this.delta = data ? Vector3d.fromJSON(data.delta) : new Vector3d();\n    }\n    /** Creates a Geocentric Transform from JSON representation.\n     * @public */\n    static fromJSON(data) {\n        return new GeocentricTransform(data);\n    }\n    /** Creates a JSON from the Geodetic GeocentricTransform definition\n     * @public */\n    toJSON() {\n        return { delta: { x: this.delta.x, y: this.delta.y, z: this.delta.z } };\n    }\n    /** Compares two geodetic transforms. It applies a minuscule tolerance.\n     *  @public */\n    equals(other) {\n        return (Math.abs(this.delta.x - other.delta.x) < Geometry.smallMetricDistance &&\n            Math.abs(this.delta.y - other.delta.y) < Geometry.smallMetricDistance &&\n            Math.abs(this.delta.z - other.delta.z) < Geometry.smallMetricDistance);\n    }\n}\n/** This class represents a positional vector (seven parameters) geodetic transformation corresponding to\n *  EPSG operation 9606. Beware that the convention relative to rotation direction is different\n *  from the Coordinate Frame operation (epsg 9607).\n *  @public\n */\nexport class PositionalVectorTransform {\n    constructor(data) {\n        if (data) {\n            this.delta = data.delta ? Vector3d.fromJSON(data.delta) : new Vector3d();\n            this.rotation = data.rotation ? XyzRotation.fromJSON(data.rotation) : new XyzRotation();\n            this.scalePPM = data.scalePPM;\n        }\n    }\n    /** Creates a Positional Vector Transform from JSON representation.\n     * @public */\n    static fromJSON(data) {\n        return new PositionalVectorTransform(data);\n    }\n    /** Creates a JSON from the Positional Vector Transform definition\n     * @public */\n    toJSON() {\n        return {\n            delta: { x: this.delta.x, y: this.delta.y, z: this.delta.z },\n            rotation: this.rotation.toJSON(),\n            scalePPM: this.scalePPM,\n        };\n    }\n    /** Compares two Positional Vector Transforms. It applies a minuscule tolerance to number compares.\n     *  @public */\n    equals(other) {\n        if (Math.abs(this.delta.x - other.delta.x) > Geometry.smallMetricDistance ||\n            Math.abs(this.delta.y - other.delta.y) > Geometry.smallMetricDistance ||\n            Math.abs(this.delta.z - other.delta.z) > Geometry.smallMetricDistance ||\n            Math.abs(this.scalePPM - other.scalePPM) > Geometry.smallFraction)\n            return false;\n        return this.rotation.equals(other.rotation);\n    }\n}\n/** Grid file definition containing name of the file, the format and the direction it should be applied\n *  @public\n */\nexport class GridFileDefinition {\n    constructor(data) {\n        this.fileName = data ? data.fileName : \"\";\n        this.format = data ? data.format : \"NTv2\";\n        this.direction = data ? data.direction : \"Direct\";\n    }\n    /** Creates a Grid File Definition from JSON representation.\n     * @public */\n    static fromJSON(data) {\n        return new GridFileDefinition(data);\n    }\n    /** Creates a JSON from the Grid File Definition\n     * @public */\n    toJSON() {\n        return { fileName: this.fileName, format: this.format, direction: this.direction };\n    }\n    /** Compares two grid file definition. It is a strict compare operation not an equivalence test.\n     *  @public */\n    equals(other) {\n        return (this.fileName === other.fileName && this.direction === other.direction && this.format === other.format);\n    }\n}\n/** This class represents a grid files based geodetic transformation.\n *  @public\n */\nexport class GridFileTransform {\n    constructor(data) {\n        this.files = [];\n        if (data) {\n            this.fallback = data.fallback ? PositionalVectorTransform.fromJSON(data.fallback) : undefined;\n            if (Array.isArray(data.files)) {\n                this.files = [];\n                for (const item of data.files)\n                    this.files.push(GridFileDefinition.fromJSON(item));\n            }\n        }\n    }\n    /** Creates a Grid File Transform from JSON representation.\n     * @public */\n    static fromJSON(data) {\n        return new GridFileTransform(data);\n    }\n    /** Creates a JSON from the Grid File Transform definition\n     * @public */\n    toJSON() {\n        const data = { files: [] };\n        data.fallback = this.fallback ? this.fallback.toJSON() : undefined;\n        if (Array.isArray(this.files)) {\n            for (const item of this.files)\n                data.files.push(item.toJSON());\n        }\n        return data;\n    }\n    /** Compares two Grid File Transforms. It is a strict compare operation not an equivalence test.\n     *  @public */\n    equals(other) {\n        if (this.files.length !== other.files.length)\n            return false;\n        for (let idx = 0; idx < this.files.length; ++idx)\n            if (!this.files[idx].equals(other.files[idx]))\n                return false;\n        if ((this.fallback === undefined) !== (other.fallback === undefined))\n            return false;\n        if (this.fallback && !this.fallback.equals(other.fallback))\n            return false;\n        return true;\n    }\n}\n/** This class represents a geodetic transformation that enables transforming longitude/latitude coordinates\n *  from one datum to another.\n *  @public\n */\nexport class GeodeticTransform {\n    constructor(data) {\n        this.method = \"None\";\n        if (data) {\n            this.method = data.method;\n            this.sourceEllipsoid = data.sourceEllipsoid ? GeodeticEllipsoid.fromJSON(data.sourceEllipsoid) : undefined;\n            this.targetEllipsoid = data.targetEllipsoid ? GeodeticEllipsoid.fromJSON(data.targetEllipsoid) : undefined;\n            this.sourceDatumId = data.sourceDatumId;\n            this.targetDatumId = data.targetDatumId;\n            this.geocentric = data.geocentric ? GeocentricTransform.fromJSON(data.geocentric) : undefined;\n            this.positionalVector = data.positionalVector ? PositionalVectorTransform.fromJSON(data.positionalVector) : undefined;\n            this.gridFile = data.gridFile ? GridFileTransform.fromJSON(data.gridFile) : undefined;\n        }\n    }\n    /** Creates a Geodetic Transform from JSON representation.\n     * @public */\n    static fromJSON(data) {\n        return new GeodeticTransform(data);\n    }\n    /** Creates a JSON from the Geodetic Transform definition\n     * @public */\n    toJSON() {\n        const data = { method: this.method };\n        data.sourceEllipsoid = this.sourceEllipsoid ? this.sourceEllipsoid.toJSON() : undefined;\n        data.targetEllipsoid = this.targetEllipsoid ? this.targetEllipsoid.toJSON() : undefined;\n        data.sourceDatumId = this.sourceDatumId;\n        data.targetDatumId = this.targetDatumId;\n        data.geocentric = this.geocentric ? this.geocentric.toJSON() : undefined;\n        data.positionalVector = this.positionalVector ? this.positionalVector.toJSON() : undefined;\n        data.gridFile = this.gridFile ? this.gridFile.toJSON() : undefined;\n        return data;\n    }\n    /** Compares two geodetic Transforms. It is not an equivalence test since\n     * descriptive information is strictly compared. A minuscule tolerance is applied to number compares.\n     *  @public */\n    equals(other) {\n        if (this.method !== other.method)\n            return false;\n        if (this.sourceDatumId !== other.sourceDatumId || this.targetDatumId !== other.targetDatumId)\n            return false;\n        if ((this.sourceEllipsoid === undefined) !== (other.sourceEllipsoid === undefined))\n            return false;\n        if (this.sourceEllipsoid && !this.sourceEllipsoid.equals(other.sourceEllipsoid))\n            return false;\n        if ((this.targetEllipsoid === undefined) !== (other.targetEllipsoid === undefined))\n            return false;\n        if (this.targetEllipsoid && !this.targetEllipsoid.equals(other.targetEllipsoid))\n            return false;\n        if ((this.geocentric === undefined) !== (other.geocentric === undefined))\n            return false;\n        if (this.geocentric && !this.geocentric.equals(other.geocentric))\n            return false;\n        if ((this.positionalVector === undefined) !== (other.positionalVector === undefined))\n            return false;\n        if (this.positionalVector && !this.positionalVector.equals(other.positionalVector))\n            return false;\n        if ((this.gridFile === undefined) !== (other.gridFile === undefined))\n            return false;\n        if (this.gridFile && !this.gridFile.equals(other.gridFile))\n            return false;\n        return true;\n    }\n}\n/** This class represents a geodetic datum transform path. It contains a list of transforms linking\n *  a source to a target geodetic datum.\n *  @public\n */\nexport class GeodeticTransformPath {\n    constructor(_data) {\n        if (_data) {\n            this.sourceDatumId = _data.sourceDatumId;\n            this.targetDatumId = _data.targetDatumId;\n            if (Array.isArray(_data.transforms)) {\n                this.transforms = [];\n                for (const item of _data.transforms)\n                    this.transforms.push(GeodeticTransform.fromJSON(item));\n            }\n        }\n    }\n    /** Creates a Geodetic transform path from JSON representation.\n     * @public */\n    static fromJSON(data) {\n        return new GeodeticTransformPath(data);\n    }\n    /** Creates a JSON from the Geodetic transform path definition\n     * @public */\n    toJSON() {\n        const data = {};\n        data.sourceDatumId = this.sourceDatumId;\n        data.targetDatumId = this.targetDatumId;\n        if (Array.isArray(this.transforms)) {\n            data.transforms = [];\n            for (const item of this.transforms)\n                data.transforms.push(item.toJSON());\n        }\n        return data;\n    }\n    /** Compares two Geodetic Transform Paths. It is a strict compare operation not an equivalence test.\n     * It takes into account descriptive properties not only mathematical definition properties.\n     *  @public */\n    equals(other) {\n        if (this.sourceDatumId !== other.sourceDatumId || this.targetDatumId !== other.targetDatumId)\n            return false;\n        if ((this.transforms === undefined) !== (other.transforms === undefined))\n            return false;\n        if (this.transforms && other.transforms) {\n            if (this.transforms.length !== other.transforms.length)\n                return false;\n            for (let idx = 0; idx < this.transforms.length; ++idx)\n                if (!this.transforms[idx].equals(other.transforms[idx]))\n                    return false;\n        }\n        return true;\n    }\n}\n/** This class represents a geodetic datum. Geodetic datums are based on an ellipsoid.\n *  In addition to the ellipsoid definition they are the base for longitude/latitude coordinates.\n *  Geodetic datums are the basis for geodetic transformations. Most geodetic datums are defined by specifying\n *  the transformation to the common base WGS84 (or local equivalent). The transforms property can contain the\n *  definition of the transformation path to WGS84.\n *  Sometimes there exists transformation paths direct from one non-WGS84 datum to another non-WGS84. The current model\n *  does not allow specifications of these special paths at the moment.\n *  @public\n */\nexport class GeodeticDatum {\n    constructor(_data) {\n        this.deprecated = false;\n        if (_data) {\n            this.id = _data.id;\n            this.description = _data.description;\n            this.deprecated = _data.deprecated ?? false;\n            this.source = _data.source;\n            this.epsg = _data.epsg;\n            this.ellipsoidId = _data.ellipsoidId;\n            this.ellipsoid = _data.ellipsoid ? GeodeticEllipsoid.fromJSON(_data.ellipsoid) : undefined;\n            if (Array.isArray(_data.transforms)) {\n                this.transforms = [];\n                for (const item of _data.transforms)\n                    this.transforms.push(GeodeticTransform.fromJSON(item));\n            }\n            if (Array.isArray(_data.additionalTransformPaths)) {\n                this.additionalTransformPaths = [];\n                for (const item of _data.additionalTransformPaths)\n                    this.additionalTransformPaths.push(GeodeticTransformPath.fromJSON(item));\n            }\n        }\n    }\n    /** Creates a Geodetic Datum from JSON representation.\n     * @public */\n    static fromJSON(data) {\n        return new GeodeticDatum(data);\n    }\n    /** Creates a JSON from the Geodetic Datum definition\n     * @public */\n    toJSON() {\n        const data = {};\n        data.id = this.id;\n        data.description = this.description;\n        /* We prefer to use the default undef instead of false value for deprecated value in Json */\n        data.deprecated = (this.deprecated === false ? undefined : true);\n        data.source = this.source;\n        data.epsg = this.epsg;\n        data.ellipsoidId = this.ellipsoidId;\n        data.ellipsoid = this.ellipsoid ? this.ellipsoid.toJSON() : undefined;\n        if (Array.isArray(this.transforms)) {\n            data.transforms = [];\n            for (const item of this.transforms)\n                data.transforms.push(item.toJSON());\n        }\n        if (Array.isArray(this.additionalTransformPaths)) {\n            data.additionalTransformPaths = [];\n            for (const item of this.additionalTransformPaths)\n                data.additionalTransformPaths.push(item.toJSON());\n        }\n        return data;\n    }\n    /** Compares two Geodetic Datums. It is a strict compare operation not an equivalence test.\n     * It takes into account descriptive properties not only mathematical definition properties.\n     *  @public */\n    equals(other) {\n        if (this.id !== other.id ||\n            this.description !== other.description ||\n            this.deprecated !== other.deprecated ||\n            this.source !== other.source ||\n            this.epsg !== other.epsg ||\n            this.ellipsoidId !== other.ellipsoidId)\n            return false;\n        if ((this.ellipsoid === undefined) !== (other.ellipsoid === undefined))\n            return false;\n        if (this.ellipsoid && !this.ellipsoid.equals(other.ellipsoid))\n            return false;\n        if ((this.transforms === undefined) !== (other.transforms === undefined))\n            return false;\n        if (this.transforms && other.transforms) {\n            if (this.transforms.length !== other.transforms.length)\n                return false;\n            for (let idx = 0; idx < this.transforms.length; ++idx)\n                if (!this.transforms[idx].equals(other.transforms[idx]))\n                    return false;\n        }\n        if ((this.additionalTransformPaths === undefined) !== (other.additionalTransformPaths === undefined))\n            return false;\n        if (this.additionalTransformPaths && other.additionalTransformPaths) {\n            if (this.additionalTransformPaths.length !== other.additionalTransformPaths.length)\n                return false;\n            for (let idx = 0; idx < this.additionalTransformPaths.length; ++idx)\n                if (!this.additionalTransformPaths[idx].equals(other.additionalTransformPaths[idx]))\n                    return false;\n        }\n        return true;\n    }\n}\n//# sourceMappingURL=GeodeticDatum.js.map",
      "start": 1693508120571,
      "end": 1693508120661,
      "sourcemaps": null
    }
  ]
}
