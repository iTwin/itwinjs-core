{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/orbitgt/lib/esm/pointcloud/render/DataManager.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module OrbitGT\n */\nimport { AList } from \"../../system/collection/AList\";\nimport { StringMap } from \"../../system/collection/StringMap\";\nimport { ALong } from \"../../system/runtime/ALong\";\nimport { ASystem } from \"../../system/runtime/ASystem\";\nimport { Message } from \"../../system/runtime/Message\";\nimport { ContentLoader } from \"../../system/storage/ContentLoader\";\nimport { Block } from \"./Block\";\nimport { Level } from \"./Level\";\nimport { ViewTree } from \"./ViewTree\";\n/**\n * Class DataManager manages the (shared) data model part of the rendering in multiple layers (see the CLOUD-461 issue).\n *\n * @version 1.0 December 2017\n */\n/** @internal */\nclass DataManager {\n    /**\n     * Create a new data model (to be shared between different views).\n     * @param pointCloudReader the reader of the pointcloud file.\n     * @param pointCloudCRS the CRS of the point cloud.\n     * @param dataFormat the requested data format to load point data (PointDataRaw.TYPE for example).\n     */\n    constructor(pointCloudReader, pointCloudCRS, dataFormat) {\n        /* Store the parameters */\n        this._pointCloudReader = pointCloudReader;\n        this._pointCloudCRS = pointCloudCRS;\n        this._dataFormat = dataFormat;\n        /* Initialize */\n        if (this._pointCloudCRS == null)\n            this._pointCloudCRS = this._pointCloudReader.getFileCRS();\n        /* Clear */\n        this._fileTileIndex = this.createSpatialIndex();\n        this._dataPool = new StringMap();\n        this._levelsLoading = new StringMap();\n        this._levelsLoaded = new StringMap();\n        this._blocksLoading = new StringMap();\n        this._blocksLoaded = new StringMap();\n        this._tilesLoading = new StringMap();\n        this._tilesLoaded = new StringMap();\n        this._loadingData = false;\n        this._loadedDataTime = 0.0;\n        this._dataLoadSize = ALong.ZERO;\n        this._lastGarbageCollectTime = 0.0;\n        /* Log */\n        Message.print(DataManager.MODULE, \"Pointcloud CRS is \" + this._pointCloudCRS);\n    }\n    /**\n     * Close the data model.\n     */\n    close() {\n        if (this._pointCloudReader != null) {\n            this._pointCloudReader.close();\n            this._pointCloudReader = null;\n        }\n        this._fileTileIndex = null;\n        this._dataPool.clear();\n        this._levelsLoading.clear();\n        this._levelsLoaded.clear();\n        this._blocksLoading.clear();\n        this._blocksLoaded.clear();\n        this._tilesLoading.clear();\n        this._tilesLoaded.clear();\n    }\n    /**\n     * Create a spatial index of a pointcloud.\n     * @return the spatial index.\n     */\n    createSpatialIndex() {\n        /* Create the levels */\n        Message.print(DataManager.MODULE, \"Creating pointcloud spatial index\");\n        let levels = new Array(this._pointCloudReader.getLevelCount());\n        for (let i = 0; i < levels.length; i++) {\n            /* Get the grids */\n            let blockGrid = this._pointCloudReader.getLevelBlockGrid(i);\n            let tileGrid = this._pointCloudReader.getLevelTileGrid(i);\n            /* Get the blocks */\n            let blockIndexes = this._pointCloudReader.peekBlockIndexes(i);\n            let blockList = new Array(blockIndexes.length);\n            for (let j = 0; j < blockList.length; j++)\n                blockList[j] = new Block(blockIndexes[j]);\n            /* Create the level */\n            levels[i] = new Level(i, blockGrid, tileGrid, blockList);\n            Message.print(DataManager.MODULE, \"Level \" + i + \" has \" + blockList.length + \" blocks\");\n        }\n        /* Get the data bounds */\n        let dataBounds = this._pointCloudReader.getFileBounds();\n        Message.print(DataManager.MODULE, \"The data bounds are \" + dataBounds);\n        /* Return a new spatial index */\n        return new ViewTree(this, levels, dataBounds);\n    }\n    /**\n     * Get the pointcloud reader.\n     * @return the pointcloud reader.\n     */\n    getPointCloudReader() {\n        return this._pointCloudReader;\n    }\n    /**\n     * Get the pointcloud CRS.\n     * @return the pointcloud CRS.\n     */\n    getPointCloudCRS() {\n        return this._pointCloudCRS;\n    }\n    /**\n     * Get the bounds of the data.\n     * @return the bounds of the data.\n     */\n    getPointCloudBounds() {\n        return this._pointCloudReader.getFileBounds();\n    }\n    /**\n     * Get the spatial index.\n     * @return the spatial index.\n     */\n    getViewTree() {\n        return this._fileTileIndex;\n    }\n    /**\n     * Check if a tile has been loaded to the data pool.\n     * @param tileIndex the index of the tile.\n     * @return the point data if loaded, null otherwise.\n     */\n    isTileLoaded(tileIndex) {\n        return this._dataPool.get(tileIndex.key);\n    }\n    /**\n     * Is the model loading data?\n     * @return true when loading data.\n     */\n    isLoadingData() {\n        return this._loadingData;\n    }\n    /**\n     * Get the size of the loaded data.\n     * @return the size of the loaded data.\n     */\n    getDataLoadSize() {\n        return this._dataLoadSize;\n    }\n    /**\n     * Filter the list of blocks and tiles that should be loaded.\n     * @param levelsToLoad the list of levels to load.\n     * @param blocksToLoad the list of blocks to load.\n     * @param tilesToLoad the list of tiles to load.\n     * @param levelList the filtered list of levels to load.\n     * @param blockList the filtered list of blocks to load.\n     * @param tileList the filtered list of tiles to load.\n     */\n    filterLoadList(levelsToLoad, blocksToLoad, tilesToLoad, levelList, blockList, tileList) {\n        /* Filter the levels to load */\n        for (let i = 0; i < levelsToLoad.size(); i++) {\n            /* Do not request the same level twice */\n            let level = levelsToLoad.get(i);\n            if (this._levelsLoading.contains(level.getKey()))\n                continue;\n            if (this._levelsLoaded.contains(level.getKey()))\n                continue;\n            /* Add the level */\n            levelList.add(level);\n        }\n        levelsToLoad.clear();\n        /* Filter the blocks to load */\n        for (let i = 0; i < blocksToLoad.size(); i++) {\n            /* Do not request the same block twice */\n            let blockIndex = blocksToLoad.get(i);\n            if (this._blocksLoading.contains(blockIndex.key))\n                continue;\n            if (this._blocksLoaded.contains(blockIndex.key))\n                continue;\n            /* Add the block */\n            blockList.add(blockIndex);\n        }\n        blocksToLoad.clear();\n        /* Filter the tiles to load */\n        for (let i = 0; i < tilesToLoad.size(); i++) {\n            /* Do not request the same tile twice */\n            let tileIndex = tilesToLoad.get(i);\n            if (this._tilesLoading.contains(tileIndex.key))\n                continue;\n            if (this._tilesLoaded.contains(tileIndex.key))\n                continue;\n            /* Add the tile */\n            tileList.add(tileIndex);\n        }\n        tilesToLoad.clear();\n    }\n    /**\n     * Load blocks and tiles.\n     * @param layer the layer requesting the load.\n     * @param levelList the filtered list of levels to load.\n     * @param blockList the filtered list of blocks to load.\n     * @param tileList the filtered list of tiles to load.\n     * @return the data model.\n     */\n    async loadData(frameData) {\n        /* No data to load? */\n        if (frameData.hasMissingData() == false)\n            return frameData;\n        /* Do not make overlapping load requests */\n        if (this._loadingData)\n            return frameData;\n        this._loadingData = true;\n        /* Log */\n        let levelList = frameData.levelsToLoad;\n        let blockList = frameData.blocksToLoad;\n        let tileList = frameData.tilesToLoad;\n        //\t\tMessage.print(MODULE,\"Loading \"+levelList.size()+\" levels, \"+blockList.size()+\" blocks and \"+tileList.size()+\" tiles\");\n        //\t\tMessage.print(MODULE,\"Already loaded \"+this._blocksLoaded.size()+\" blocks\");\n        //\t\tMessage.print(MODULE,\"Already loading \"+this._blocksLoading.size()+\" blocks\");\n        //\t\tMessage.print(MODULE,\"Already loaded \"+this._tilesLoaded.size()+\" tiles\");\n        //\t\tMessage.print(MODULE,\"Already loading \"+this._tilesLoading.size()+\" tiles\");\n        /* Define the content we are going to need */\n        let loadTime = ASystem.time();\n        let fileContents = new ContentLoader(this._pointCloudReader.getFileStorage(), this._pointCloudReader.getFileName());\n        /* Prepare the loading of the levels */\n        for (let i = 0; i < levelList.size(); i++) {\n            /* Prepare to load the block */\n            let level = levelList.get(i);\n            this._levelsLoading.set(level.getKey(), level);\n            this._pointCloudReader.readBlockIndexes(level.getIndex(), fileContents);\n            Message.print(DataManager.MODULE, \"Loading level \" + level.getIndex());\n        }\n        /* Prepare the loading of the blocks */\n        for (let i = 0; i < blockList.size(); i++) {\n            /* Prepare to load the block */\n            let blockIndex = blockList.get(i);\n            this._blocksLoading.set(blockIndex.key, blockIndex);\n            this._pointCloudReader.readTileIndexes(blockIndex, fileContents);\n        }\n        /* Prepare the loading of the tiles */\n        let loadTileCount = 0;\n        for (let i = 0; i < tileList.size(); i++) {\n            /* Prepare to load the tile */\n            let tileIndex = tileList.get(i);\n            this._tilesLoading.set(tileIndex.key, tileIndex);\n            this._pointCloudReader.readPointData(tileIndex, this._dataFormat, loadTime, fileContents);\n            loadTileCount++;\n            /* Do not load too many tiles at once */\n            if (fileContents.getTotalRequestSize() > DataManager.MAX_FILE_CONTENT_SIZE) {\n                /* Stop loading tiles */\n                Message.print(DataManager.MODULE, \"Limited pointcloud content load request to \" + fileContents.getTotalRequestSize() + \" bytes\");\n                break;\n            }\n        }\n        /* Log */\n        Message.print(DataManager.MODULE, \"Loading of \" + blockList.size() + \" blocks, \" + loadTileCount + \"/\" + tileList.size() + \" tiles, \" + fileContents.getTotalRequestSize() + \" bytes\");\n        /* Load the data */\n        this._dataLoadSize = this._dataLoadSize.addInt(fileContents.getTotalRequestSize());\n        fileContents = await fileContents.load();\n        //Message.print(MODULE,\"Creating \"+blockList.size()+\" blocks and \"+tileList.size()+\" tiles\");\n        /* Load the levels */\n        for (let i = 0; i < levelList.size(); i++) {\n            /* Load the block list */\n            let level = levelList.get(i);\n            this._levelsLoaded.set(level.getKey(), level);\n            this._levelsLoading.remove(level.getKey());\n            let blockIndexes = this._pointCloudReader.readBlockIndexes(level.getIndex(), fileContents);\n            /* Add the blocks */\n            this._fileTileIndex.setLevelBlocks(level, blockIndexes);\n        }\n        /* Load the blocks */\n        for (let i = 0; i < blockList.size(); i++) {\n            /* Load the block */\n            let blockIndex = blockList.get(i);\n            this._blocksLoaded.set(blockIndex.key, blockIndex);\n            this._blocksLoading.remove(blockIndex.key);\n            let tileIndexes = this._pointCloudReader.readTileIndexes(blockIndex, fileContents);\n            /* Add the block */\n            this._fileTileIndex.setBlockTiles(blockIndex, tileIndexes);\n        }\n        /* Load the tiles */\n        let newTiles = new AList();\n        for (let i = 0; i < loadTileCount; i++) {\n            /* Get the next tile */\n            let tileIndex = tileList.get(i);\n            newTiles.add(tileIndex);\n            /* Load the tile */\n            this._tilesLoaded.set(tileIndex.key, tileIndex);\n            this._tilesLoading.remove(tileIndex.key);\n            let pointData = this._pointCloudReader.readPointData(tileIndex, this._dataFormat, loadTime, fileContents);\n            /* Add the tile */\n            this._dataPool.set(tileIndex.key, pointData);\n        }\n        /* We stopped loading */\n        this._loadingData = false;\n        this._loadedDataTime = ASystem.time();\n        /* Log */\n        Message.print(DataManager.MODULE, \"Created \" + blockList.size() + \" blocks and \" + loadTileCount + \" tiles\");\n        /* Return the frame data */\n        return frameData;\n    }\n    /**\n     * Do a garbage collect (this method can be called often, it throttles itself to once per minute).\n     * @param time the current time.\n     */\n    doGarbageCollect(time) {\n        /* First call? */\n        if (this._lastGarbageCollectTime == 0.0)\n            this._lastGarbageCollectTime = time;\n        /* Throttle to one per minute */\n        if (time < this._lastGarbageCollectTime + 60.0)\n            return;\n        this._lastGarbageCollectTime = time;\n        /* Define the expire time */\n        let expireTime = (time - DataManager.POINT_DATA_EXIRE_TIME);\n        /* Check all loaded tiles */\n        let dropCount = 0;\n        let dataKeys = this._dataPool.keys();\n        for (let i = 0; i < dataKeys.size(); i++) {\n            /* Get the next tile */\n            let tileKey = dataKeys.get(i);\n            let pointData = this._dataPool.get(tileKey);\n            /* Expired? */\n            if (pointData.tileIndex.accessTime < expireTime) {\n                this._dataPool.remove(tileKey);\n                this._tilesLoaded.remove(tileKey);\n                dropCount++;\n            }\n        }\n        /* Log? */\n        if (dropCount > 0)\n            Message.print(DataManager.MODULE, \"Dropped the point data of \" + dropCount + \" tiles\");\n    }\n}\n/** The name of this module */\nDataManager.MODULE = \"DataManager\";\n/** The maximum size of a single file-content request */\nDataManager.MAX_FILE_CONTENT_SIZE = 128 * 1024;\n/** The expire time to unload unused point data (seconds) */\nDataManager.POINT_DATA_EXIRE_TIME = 5 * 60.0;\nexport { DataManager };\n//# sourceMappingURL=DataManager.js.map",
      "start": 1693508124781,
      "end": 1693508124907,
      "sourcemaps": null
    }
  ]
}
