{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/curve/LineString3d.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import { AxisOrder, Geometry } from \"../Geometry\";\nimport { Angle } from \"../geometry3d/Angle\";\nimport { GrowableFloat64Array } from \"../geometry3d/GrowableFloat64Array\";\nimport { GrowableXYArray } from \"../geometry3d/GrowableXYArray\";\nimport { GrowableXYZArray } from \"../geometry3d/GrowableXYZArray\";\nimport { Matrix3d } from \"../geometry3d/Matrix3d\";\nimport { Plane3dByOriginAndVectors } from \"../geometry3d/Plane3dByOriginAndVectors\";\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\nimport { PointStreamGrowableXYZArrayCollector, VariantPointDataStream } from \"../geometry3d/PointStreaming\";\nimport { Range3d } from \"../geometry3d/Range\";\nimport { Ray3d } from \"../geometry3d/Ray3d\";\nimport { Transform } from \"../geometry3d/Transform\";\nimport { CurveExtendOptions } from \"./CurveExtendMode\";\nimport { CurveIntervalRole, CurveLocationDetail, CurveSearchStatus } from \"./CurveLocationDetail\";\nimport { CurvePrimitive } from \"./CurvePrimitive\";\nimport { PlaneAltitudeRangeContext } from \"./internalContexts/PlaneAltitudeRangeContext\";\nimport { LineSegment3d } from \"./LineSegment3d\";\nimport { OffsetOptions } from \"./OffsetOptions\";\nimport { StrokeCountMap } from \"./Query/StrokeCountMap\";\n/* eslint-disable @typescript-eslint/naming-convention, no-empty */\n/**\n * Starting with baseIndex and moving index by stepDirection:\n * If the vector from baseIndex to baseIndex +1 crossed with vectorA can be normalized, accumulate it (scaled) to normal.\n * Return when successful.\n * (Do nothing if everything is parallel through limits of the array)\n */\nfunction accumulateGoodUnitPerpendicular(points, vectorA, baseIndex, stepDirection, weight, normal, workVector) {\n    const n = points.length;\n    if (stepDirection > 0) {\n        for (let i = baseIndex; i + 1 < n; i++) {\n            points.vectorIndexIndex(i, i + 1, workVector);\n            vectorA.crossProduct(workVector, workVector);\n            if (workVector.normalizeInPlace()) {\n                normal.addScaledInPlace(workVector, weight);\n                return true;\n            }\n        }\n    }\n    else {\n        if (baseIndex + 1 >= n)\n            baseIndex = n - 2;\n        for (let i = baseIndex; i >= 0; i--) {\n            points.vectorIndexIndex(i, i + 1, workVector);\n            workVector.crossProduct(vectorA, workVector);\n            if (workVector.normalizeInPlace()) {\n                normal.addScaledInPlace(workVector, weight);\n                return true;\n            }\n        }\n    }\n    return false;\n}\n/**\n * * A LineString3d (sometimes called a PolyLine) is a sequence of xyz coordinates that are to be joined by line\n * segments.\n * * The point coordinates are stored in a GrowableXYZArray, not as full point objects.\n * * The parameterization of \"fraction along\" is\n *    * In a linestring with `N` segments (i.e. `N+1` points), each segment (regardless of physical length) occupies\n * the same fraction (1/N) of the 0-to-1 fraction space.\n *    * Within segment `i`, the fraction interval `i/N` to `(i+1)/N` is mapped proportionally to the segment\n *    * Note that this `fraction` is therefore NOT fraction of true distance along.\n *    * Use `moveSignedDistanceFromFraction` to do true-length evaluations.\n * @public\n */\nclass LineString3d extends CurvePrimitive {\n    /** test if `other` is an instance of `LineString3d` */\n    isSameGeometryClass(other) {\n        return other instanceof LineString3d;\n    }\n    /** A LineString3d extends along its first and final segments. */\n    get isExtensibleFractionSpace() {\n        return true;\n    }\n    /** Return the points array (cloned). */\n    get points() {\n        return this._points.getPoint3dArray();\n    }\n    /** Return (reference to) point data in packed GrowableXYZArray. */\n    get packedPoints() {\n        return this._points;\n    }\n    /**\n     * Return array of fraction parameters.\n     * * These Are only present during certain constructions such as faceting.\n     * * When present, these fractions are fractions of some other curve being stroked, and are NOT related to the\n     * linestring fraction parameters.\n     */\n    get fractions() {\n        return this._fractions;\n    }\n    /** Return the (optional) array of derivatives. These Are only present during certain constructions such as faceting. */\n    get packedDerivatives() {\n        return this._derivatives;\n    }\n    /** Return the (optional) array of uv params. These Are only present during certain constructions such as faceting. */\n    get packedUVParams() {\n        return this._uvParams;\n    }\n    /** Return the (optional) array of surface normals. These Are only present during certain constructions such as faceting. */\n    get packedSurfaceNormals() {\n        return this._surfaceNormals;\n    }\n    /** Return the (optional) array of normal indices. These Are only present during certain constructions such as faceting. */\n    get normalIndices() {\n        return this._normalIndices;\n    }\n    /** Return the (optional) array of param indices. These Are only present during certain constructions such as faceting. */\n    get paramIndices() {\n        return this._uvIndices;\n    }\n    /** Return the (optional) array of point indices. These Are only present during certain constructions such as faceting. */\n    get pointIndices() {\n        return this._pointIndices;\n    }\n    constructor(points) {\n        super();\n        /** String name for schema properties */\n        this.curvePrimitiveType = \"lineString\";\n        if (points)\n            this._points = points;\n        else\n            this._points = new GrowableXYZArray();\n    }\n    /** Clone this linestring and apply the transform to the clone points. */\n    cloneTransformed(transform) {\n        const c = this.clone();\n        c.tryTransformInPlace(transform);\n        return c;\n    }\n    /**\n     * Create a linestring, using flex length arg list and any typical combination of points such as\n     * Point3d, Point2d, `[1,2,3]', array of any of those, or GrowableXYZArray\n     */\n    static create(...points) {\n        const result = new LineString3d();\n        result.addPoints(points);\n        return result;\n    }\n    /**\n     * Create a linestring, capturing the given GrowableXYZArray as the points.\n     * Point3d, Point2d, `[1,2,3]', array of any of those, or GrowableXYZArray\n     */\n    static createCapture(points) {\n        return new LineString3d(points);\n    }\n    /** Create a linestring from `XAndY` points, with a specified z applied to all. */\n    static createXY(points, z, enforceClosure = false) {\n        const result = new LineString3d();\n        const xyz = result._points;\n        for (const xy of points) {\n            xyz.pushXYZ(xy.x, xy.y, z);\n        }\n        if (enforceClosure && points.length > 1) {\n            const distance = xyz.distanceIndexIndex(0, xyz.length - 1);\n            if (distance !== undefined && distance !== 0.0) {\n                if (Geometry.isSameCoordinate(0, distance)) {\n                    xyz.pop(); // nonzero but small distance -- to be replaced by point 0 exactly.\n                    const xyzA = xyz.front();\n                    xyz.push(xyzA);\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Add points to the linestring.\n     * Valid inputs are:\n     * * a Point2d\n     * * a point3d\n     * * An array of 2 doubles\n     * * An array of 3 doubles\n     * * A GrowableXYZArray\n     * * An array of any of the above\n     */\n    addPoints(...points) {\n        this._points.pushFrom(points);\n    }\n    /** Add points accessed by index in a GrowableXYZArray, with a specified index step. */\n    addSteppedPoints(source, pointIndex0, step, numAdd) {\n        this._points.addSteppedPoints(source, pointIndex0, step, numAdd);\n    }\n    /**\n     * Add a point to the linestring.\n     * @param point\n     */\n    addPoint(point) {\n        this._points.push(point);\n    }\n    /**\n     * Add a point to the linestring.\n     * @param point\n     */\n    addPointXYZ(x, y, z = 0) {\n        this._points.pushXYZ(x, y, z);\n    }\n    /**\n     * Append a fraction to the fractions array.\n     * @param fraction\n     */\n    addFraction(fraction) {\n        if (!this._fractions)\n            this._fractions = new GrowableFloat64Array();\n        this._fractions.push(fraction);\n    }\n    /** Ensure that the fraction array exists with no fractions but at least the capacity of the point array. */\n    ensureEmptyFractions() {\n        const n = this.numPoints();\n        if (!this._fractions) {\n            this._fractions = new GrowableFloat64Array(n);\n            return this._fractions;\n        }\n        this._fractions.clear();\n        this._fractions.ensureCapacity(n);\n        return this._fractions;\n    }\n    /** Ensure that the parameter array exists with no points but at least the capacity of the point array. */\n    ensureEmptyUVParams() {\n        const n = this.numPoints();\n        if (!this._uvParams) {\n            this._uvParams = new GrowableXYArray(n);\n            return this._uvParams;\n        }\n        this._uvParams.clear();\n        this._uvParams.ensureCapacity(n);\n        return this._uvParams;\n    }\n    /** Ensure that the surfaceNormals array exists with no points but at least the capacity of the point array. */\n    ensureEmptySurfaceNormals() {\n        const n = this.numPoints();\n        if (!this._surfaceNormals) {\n            this._surfaceNormals = new GrowableXYZArray(n);\n            return this._surfaceNormals;\n        }\n        this._surfaceNormals.clear();\n        this._surfaceNormals.ensureCapacity(n);\n        return this._surfaceNormals;\n    }\n    /** Ensure that the surfaceNormals array exists with no points but at least the capacity of the point array. */\n    ensureEmptyDerivatives() {\n        const n = this.numPoints();\n        if (!this._derivatives) {\n            this._derivatives = new GrowableXYZArray(n);\n            return this._derivatives;\n        }\n        this._derivatives.clear();\n        this._derivatives.ensureCapacity(n);\n        return this._derivatives;\n    }\n    /** Ensure that the surfaceNormals array exists with no points but at least the capacity of the point array. */\n    ensureEmptyNormalIndices() {\n        const n = this.numPoints();\n        if (!this._normalIndices) {\n            this._normalIndices = new GrowableFloat64Array(n);\n            return this._normalIndices;\n        }\n        this._normalIndices.clear();\n        this._normalIndices.ensureCapacity(n);\n        return this._normalIndices;\n    }\n    /** Ensure that the surfaceNormals array exists with no points but at least the capacity of the point array. */\n    ensureEmptyUVIndices() {\n        const n = this.numPoints();\n        if (!this._uvIndices) {\n            this._uvIndices = new GrowableFloat64Array(n);\n            return this._uvIndices;\n        }\n        this._uvIndices.clear();\n        this._uvIndices.ensureCapacity(n);\n        return this._uvIndices;\n    }\n    /** Ensure that the surfaceNormals array exists with no points but at least the capacity of the point array. */\n    ensureEmptyPointIndices() {\n        const n = this.numPoints();\n        if (!this._pointIndices) {\n            this._pointIndices = new GrowableFloat64Array(n);\n            return this._pointIndices;\n        }\n        this._pointIndices.clear();\n        this._pointIndices.ensureCapacity(n);\n        return this._pointIndices;\n    }\n    /**\n     * Append a uv coordinate to the uvParams array\n     * @param uv\n     */\n    addUVParam(uvParam) {\n        if (!this._uvParams)\n            this._uvParams = new GrowableXYArray();\n        this._uvParams.pushXY(uvParam.x, uvParam.y);\n    }\n    /**\n     * Append a uv coordinate to the uvParams array\n     * @param uv\n     */\n    addUVParamAsUV(u, v) {\n        if (!this._uvParams)\n            this._uvParams = new GrowableXYArray();\n        this._uvParams.pushXY(u, v);\n    }\n    /**\n     * Append a derivative to the derivative array\n     * @param vector\n     */\n    addDerivative(vector) {\n        if (!this._derivatives)\n            this._derivatives = new GrowableXYZArray();\n        this._derivatives.push(vector);\n    }\n    /**\n     * Append a surface normal to the surface normal array.\n     * @param vector\n     */\n    addSurfaceNormal(vector) {\n        if (!this._surfaceNormals)\n            this._surfaceNormals = new GrowableXYZArray();\n        this._surfaceNormals.push(vector);\n    }\n    /** If the linestring is not already closed, add a closure point. */\n    addClosurePoint() {\n        const distance = this._points.distanceIndexIndex(0, this._points.length - 1);\n        if (distance !== undefined && !Geometry.isSameCoordinate(distance, 0))\n            this._points.pushWrap(1);\n    }\n    /** Eliminate (but do not return!!) the final point of the linestring */\n    popPoint() {\n        this._points.pop();\n    }\n    /** Compute `uvParams` array as (xy parts of) a linear transform of the xyz coordinates */\n    computeUVFromXYZTransform(transform) {\n        this._uvParams = GrowableXYArray.createFromGrowableXYZArray(this._points, transform);\n    }\n    /**\n     * Create the linestring for a rectangle parallel to the xy plane.\n     * * The z coordinate from `point0` is used for all points.\n     * * `ax` and `ay` are signed.\n     * * The point sequence is:\n     *    * Start at `point0`\n     *    * move by (signed !) `ax` in the x direction.\n     *    * move by (signed !) `ay` in the y direction.\n     *    * move by (signed !) negative `ax` in the x direction.\n     *    * move by (signed !) negative `ay` in the y direction.\n     *    * (this returns to `point0`)\n     */\n    static createRectangleXY(point0, ax, ay, closed = true) {\n        const ls = LineString3d.create();\n        const x0 = point0.x;\n        const x1 = point0.x + ax;\n        const y0 = point0.y;\n        const y1 = point0.y + ay;\n        const z = point0.z;\n        ls.addPointXYZ(x0, y0, z);\n        ls.addPointXYZ(x1, y0, z);\n        ls.addPointXYZ(x1, y1, z);\n        ls.addPointXYZ(x0, y1, z);\n        if (closed)\n            ls.addClosurePoint();\n        return ls;\n    }\n    /**\n     * Create a regular polygon centered\n     * @param center center of the polygon.\n     * @param edgeCount number of edges.\n     * @param radius distance to vertex or edge (see `radiusToVertices`)\n     * @param radiusToVertices true if polygon is inscribed in circle (radius measured to vertices); false if polygon\n     * is outside circle (radius to edges)\n     */\n    static createRegularPolygonXY(center, edgeCount, radius, radiusToVertices = true) {\n        if (edgeCount < 3)\n            edgeCount = 3;\n        const ls = LineString3d.create();\n        const i0 = radiusToVertices ? 0 : -1; // offset to make first vector (radius,0,0)\n        const radiansStep = Math.PI / edgeCount;\n        let c;\n        let s;\n        let radians;\n        if (!radiusToVertices)\n            radius = radius / Math.cos(radiansStep);\n        for (let i = 0; i < edgeCount; i++) {\n            radians = (i0 + 2 * i) * radiansStep;\n            c = Angle.cleanupTrigValue(Math.cos(radians));\n            s = Angle.cleanupTrigValue(Math.sin(radians));\n            ls.addPointXYZ(center.x + radius * c, center.y + radius * s, center.z);\n        }\n        ls.addClosurePoint();\n        return ls;\n    }\n    /**\n     * Copy coordinate data from another linestring.\n     *  * The copied content is:\n     *    * points\n     *    * derivatives (if present)\n     *    * fractions (if present)\n     *    * surfaceNormals (if present)\n     *    * uvParams (if present)\n     * @param other\n     */\n    setFrom(other) {\n        // ugly -- \"clone\" methods are inconsistent about 'reuse' and 'result' parameter . . .\n        this._points = other._points.clone(this._points);\n        if (other._derivatives)\n            this._derivatives = other._derivatives.clone(this._derivatives);\n        else\n            this._derivatives = undefined;\n        if (other._fractions)\n            this._fractions = other._fractions.clone(false);\n        else\n            this._fractions = undefined;\n        if (other._surfaceNormals)\n            this._surfaceNormals = other._surfaceNormals.clone(this._surfaceNormals);\n        else\n            this._surfaceNormals = undefined;\n        if (other._uvParams)\n            this._uvParams = other._uvParams.clone();\n        else\n            this._uvParams = undefined;\n    }\n    /** Create a linestring from an array of points. */\n    static createPoints(points) {\n        const ls = new LineString3d();\n        let point;\n        for (point of points)\n            ls._points.push(point);\n        return ls;\n    }\n    /** Create a linestring, taking points at specified indices from an array of points. */\n    static createIndexedPoints(points, index, addClosure = false) {\n        const ls = new LineString3d();\n        for (const i of index)\n            ls._points.push(points[i]); // no clone needed -- we know this reformats to packed array.\n        if (addClosure && index.length > 1)\n            ls._points.push(points[index[0]]);\n        return ls;\n    }\n    /** Create a LineString3d from xyz coordinates packed in a Float64Array */\n    static createFloat64Array(xyzData) {\n        const ls = new LineString3d();\n        for (let i = 0; i + 3 <= xyzData.length; i += 3)\n            ls._points.push(Point3d.create(xyzData[i], xyzData[i + 1], xyzData[i + 2]));\n        return ls;\n    }\n    /** Return a clone of this linestring. */\n    clone() {\n        const retVal = new LineString3d();\n        retVal.setFrom(this);\n        return retVal;\n    }\n    /**\n     * Set point coordinates from a json array, e.g. `[[1,2,3],[4,5,6] . . .]`\n     * * The `json` parameter must be an array.\n     * * Each member `i` of the array is converted to a point with `Point3d.fromJSON(json[i]`)\n     */\n    setFromJSON(json) {\n        this._points.clear();\n        if (Array.isArray(json)) {\n            let xyz;\n            for (xyz of json)\n                this._points.push(Point3d.fromJSON(xyz));\n        }\n    }\n    /**\n     * Convert an LineString3d to a JSON object.\n     * * The returned object is an array of arrays of x,y,z coordinates, `[[x,y,z],...[x,y,z]]`\n     */\n    toJSON() {\n        const value = [];\n        let i = 0;\n        while (this._points.isIndexValid(i)) {\n            value.push(this._points.getPoint3dAtUncheckedPointIndex(i).toJSON());\n            i++;\n        }\n        return value;\n    }\n    /**\n     * Construct a new linestring.\n     * * See `LineString3d.setFromJSON ()` for remarks on `json` structure.\n     */\n    static fromJSON(json) {\n        const ls = new LineString3d();\n        ls.setFromJSON(json);\n        return ls;\n    }\n    /**\n     * Evaluate a point a fractional position along this linestring.\n     * * See `LineString3d` class comments for description of how fraction relates to the linestring points.\n     * @param fraction fractional position\n     * @param result optional result\n     */\n    fractionToPoint(fraction, result) {\n        const n = this._points.length;\n        if (n === 0)\n            return Point3d.createZero();\n        if (n === 1)\n            return Point3d.createFrom(this._points.getPoint3dAtUncheckedPointIndex(0), result);\n        const df = 1.0 / (n - 1);\n        if (fraction <= df)\n            return this._points.interpolate(0, fraction / df, 1, result);\n        if (fraction + df >= 1.0)\n            return this._points.interpolate(n - 1, (1.0 - fraction) / df, n - 2, result);\n        const index0 = Math.floor(fraction / df);\n        return this._points.interpolate(index0, (fraction - index0 * df) / df, index0 + 1, result);\n    }\n    /**\n     * Evaluate a point a fractional position and derivative with respect to fraction along this linestring.\n     * * See `LineString3d` class comments for description of how fraction relates to the linestring points.\n     * @param fraction fractional position\n     * @param result optional result\n     */\n    fractionToPointAndDerivative(fraction, result) {\n        result = result ? result : Ray3d.createZero();\n        const n = this._points.length;\n        if (n <= 1) {\n            result.direction.setZero();\n            if (n === 1)\n                result.origin.setFrom(this._points.getPoint3dAtUncheckedPointIndex(0));\n            else\n                result.origin.setZero();\n            return result;\n        }\n        const numSegment = n - 1;\n        const df = 1.0 / numSegment;\n        if (fraction <= df) {\n            result = result ? result : Ray3d.createZero();\n            this._points.interpolate(0, fraction / df, 1, result.origin);\n            this._points.vectorIndexIndex(0, 1, result.direction);\n            result.direction.scaleInPlace(1.0 / df);\n            return result;\n        }\n        if (fraction + df >= 1.0) {\n            result = result ? result : Ray3d.createZero();\n            this._points.interpolate(n - 2, 1.0 - (1.0 - fraction) / df, n - 1, result.origin);\n            this._points.vectorIndexIndex(n - 2, n - 1, result.direction);\n            result.direction.scaleInPlace(1.0 / df);\n            return result;\n        }\n        /* true interior point */\n        result = result ? result : Ray3d.createZero();\n        const index0 = Math.floor(fraction / df);\n        const localFraction = (fraction - index0 * df) / df;\n        this._points.interpolate(index0, localFraction, index0 + 1, result.origin);\n        this._points.vectorIndexIndex(index0, index0 + 1, result.direction);\n        result.direction.scaleInPlace(1.0 / df);\n        return result;\n    }\n    /** Return point and derivative at fraction, with 000 second derivative. */\n    fractionToPointAnd2Derivatives(fraction, result) {\n        const ray = this.fractionToPointAndDerivative(fraction);\n        result = Plane3dByOriginAndVectors.createCapture(ray.origin, ray.direction, Vector3d.createZero(), result);\n        return result;\n    }\n    /**\n     * Convert a segment index and local fraction to a global fraction.\n     * @param index index of segment being evaluated\n     * @param localFraction local fraction in [0,1] within the segment\n     * @return global fraction f in [0,1] such that the segment is parameterized by index/N <= f <= (index+1)/N.\n     */\n    segmentIndexAndLocalFractionToGlobalFraction(index, localFraction) {\n        const numSegment = this._points.length - 1;\n        if (numSegment < 1)\n            return 0.0;\n        return (index + localFraction) / numSegment;\n    }\n    /**\n     * Convert a global fraction to a segment index and local fraction.\n     * @param globalFraction a fraction f in [0,1] in the linestring parameterization, where the i_th segment\n     * (0 <= i < N) is parameterized by i/N <= f <= (i+1)/N.\n     */\n    globalFractionToSegmentIndexAndLocalFraction(globalFraction) {\n        const numSegment = this._points.length - 1;\n        if (numSegment < 1)\n            return { index: 0, fraction: 0.0 };\n        const scaledGlobalFraction = globalFraction * numSegment;\n        let segmentIndex;\n        if (globalFraction < 0)\n            segmentIndex = 0;\n        else if (globalFraction > 1)\n            segmentIndex = numSegment - 1;\n        else // globalFraction in [0,1]\n            segmentIndex = Math.floor(scaledGlobalFraction);\n        const localFraction = scaledGlobalFraction - segmentIndex;\n        return { index: segmentIndex, fraction: localFraction };\n    }\n    /** Return a frenet frame, using nearby points to estimate a plane. */\n    fractionToFrenetFrame(fraction, result) {\n        const n = this._points.length;\n        if (n <= 1) {\n            if (n === 1)\n                return Transform.createTranslation(this._points.getPoint3dAtUncheckedPointIndex(0), result);\n            return Transform.createIdentity(result);\n        }\n        if (n === 2)\n            return Transform.createRefs(this._points.interpolate(0, fraction, 1), Matrix3d.createRigidHeadsUp(this._points.vectorIndexIndex(0, 1), AxisOrder.XYZ));\n        /** 3 or more points. */\n        const numSegment = n - 1;\n        const df = 1.0 / numSegment;\n        let baseIndex = 0;\n        let localFraction = 0;\n        if (fraction <= df) {\n            localFraction = fraction / df;\n            baseIndex = 0;\n        }\n        else if (fraction + df >= 1.0) {\n            baseIndex = n - 2;\n            localFraction = 1.0 - (1.0 - fraction) / df;\n        }\n        else {\n            baseIndex = Math.floor(fraction / df);\n            localFraction = fraction * numSegment - baseIndex;\n        }\n        const origin = this._points.interpolate(baseIndex, localFraction, baseIndex + 1);\n        const vectorA = this._points.vectorIndexIndex(baseIndex, baseIndex + 1);\n        // tricky stuff to handle colinear points.   But if vectorA is zero it is still a mess . ..\n        const normal = Vector3d.create();\n        const workVector = Vector3d.create();\n        if (baseIndex === 0) { // only look forward\n            accumulateGoodUnitPerpendicular(this._points, vectorA, baseIndex + 1, 1, 1.0, normal, workVector);\n        }\n        else if (baseIndex + 2 >= n) { // only look back\n            accumulateGoodUnitPerpendicular(this._points, vectorA, baseIndex - 1, -1, 1.0, normal, workVector);\n        }\n        else {\n            accumulateGoodUnitPerpendicular(this._points, vectorA, baseIndex - 1, -1, (1.0 - localFraction), normal, workVector);\n            accumulateGoodUnitPerpendicular(this._points, vectorA, baseIndex + 1, 1, (localFraction), normal, workVector);\n        }\n        const matrix = Matrix3d.createRigidFromColumns(normal, vectorA, AxisOrder.ZXY);\n        if (matrix)\n            return Transform.createOriginAndMatrix(origin, matrix, result);\n        return Transform.createTranslation(origin, result);\n    }\n    /** Evaluate the start point of the linestring. */\n    startPoint() {\n        if (this._points.length === 0)\n            return Point3d.createZero();\n        return this._points.getPoint3dAtUncheckedPointIndex(0);\n    }\n    /** If i is a valid index, return that point. */\n    pointAt(i, result) {\n        if (this._points.isIndexValid(i))\n            return this._points.getPoint3dAtUncheckedPointIndex(i, result);\n        return undefined;\n    }\n    /** If i and j are both valid indices, return the vector from point i to point j */\n    vectorBetween(i, j, result) {\n        return this._points.vectorIndexIndex(i, j, result);\n    }\n    /** If i is a valid index, return that stored derivative vector. */\n    derivativeAt(i, result) {\n        if (this._derivatives && this._derivatives.isIndexValid(i))\n            return this._derivatives.getVector3dAtCheckedVectorIndex(i, result);\n        return undefined;\n    }\n    /** If i is a valid index, return that stored surfaceNormal vector. */\n    surfaceNormalAt(i, result) {\n        if (this._surfaceNormals && this._surfaceNormals.isIndexValid(i))\n            return this._surfaceNormals.getVector3dAtCheckedVectorIndex(i, result);\n        return undefined;\n    }\n    /** Return the number of points in this linestring. */\n    numPoints() {\n        return this._points.length;\n    }\n    /** Evaluate the end point of the linestring. */\n    endPoint() {\n        if (this._points.length === 0)\n            return Point3d.createZero();\n        return this._points.getPoint3dAtUncheckedPointIndex(this._points.length - 1);\n    }\n    /** Reverse the points within the linestring. */\n    reverseInPlace() {\n        if (this._points.length >= 2) {\n            this._points.reverseInPlace();\n            if (this._uvParams)\n                this._uvParams.reverseInPlace();\n        }\n    }\n    /** Apply `transform` to each point of this linestring. */\n    tryTransformInPlace(transform) {\n        this._points.multiplyTransformInPlace(transform);\n        if (this._derivatives)\n            this._derivatives.multiplyMatrix3dInPlace(transform.matrix);\n        if (this._surfaceNormals)\n            this._surfaceNormals.multiplyAndRenormalizeMatrix3dInverseTransposeInPlace(transform.matrix);\n        return true;\n    }\n    /** Sum the lengths of segments within the linestring */\n    curveLength() {\n        return this._points.sumLengths();\n    }\n    /** Sum the lengths of segments between fractional positions on a linestring. */\n    curveLengthBetweenFractions(fraction0, fraction1) {\n        const numSegments = this._points.length - 1;\n        if (fraction1 === fraction0 || numSegments < 1)\n            return 0.0;\n        if (fraction1 < fraction0)\n            return this.curveLengthBetweenFractions(fraction1, fraction0);\n        const scaledFraction0 = fraction0 * numSegments;\n        const scaledFraction1 = fraction1 * numSegments;\n        const index0 = Math.max(1, Math.ceil(scaledFraction0));\n        const index1 = Math.min(Math.floor(scaledFraction1), numSegments - 1);\n        const localFraction0 = index0 - scaledFraction0;\n        const localFraction1 = scaledFraction1 - index1;\n        if (index0 > index1) {\n            // the interval is entirely within a single segment\n            return Math.abs(scaledFraction1 - scaledFraction0) * this._points.distanceIndexIndex(index0 - 1, index0);\n        }\n        else {\n            // there is leading partial interval, 0 or more complete segments, and a trailing partial interval.\n            // (either or both partial may be zero length)\n            let sum = localFraction0 * this._points.distanceIndexIndex(index0 - 1, index0)\n                + localFraction1 * (this._points.distanceIndexIndex(index1, index1 + 1));\n            for (let i = index0; i < index1; i++)\n                sum += this._points.distanceIndexIndex(i, i + 1);\n            return sum;\n        }\n    }\n    /** Compute the range of points between fractional positions on the linestring. */\n    rangeBetweenFractions(fraction0, fraction1, transform) {\n        const range = Range3d.create();\n        if (this.points.length < 1)\n            return range;\n        if (fraction1 < fraction0)\n            return this.rangeBetweenFractions(fraction1, fraction0, transform);\n        const numSegments = this._points.length - 1;\n        const scaledFraction0 = fraction0 * numSegments;\n        const index0 = Math.max(0, Math.floor(scaledFraction0));\n        const localFraction0 = scaledFraction0 - index0;\n        const workPoint = Point3d.create();\n        this._points.interpolate(index0, localFraction0, index0 + 1, workPoint);\n        range.extendPoint(workPoint, transform);\n        if (fraction1 === fraction0)\n            return range; // 1-point range\n        const scaledFraction1 = fraction1 * numSegments;\n        const index1 = Math.min(Math.floor(scaledFraction1), numSegments - 1);\n        const localFraction1 = scaledFraction1 - index1;\n        this._points.interpolate(index1, localFraction1, index1 + 1, workPoint);\n        range.extendPoint(workPoint, transform);\n        for (let i = index0 + 1; i <= index1; i++) {\n            this._points.getPoint3dAtUncheckedPointIndex(i, workPoint);\n            range.extendPoint(workPoint, transform);\n        }\n        return range;\n    }\n    /**\n     * * Implementation of `CurvePrimitive.moveSignedDistanceFromFraction`.  (see comments there!)\n     * * Find the segment that contains the start fraction\n     * * Move point-by-point from that position to the start or end (respectively for negative or positive signedDistance)\n     * * Optionally extrapolate\n     * @param startFraction\n     * @param signedDistance\n     * @param allowExtension\n     * @param result\n     */\n    moveSignedDistanceFromFraction(startFraction, signedDistance, allowExtension, result) {\n        const numSegments = this._points.length - 1;\n        const scaledFraction = startFraction * numSegments;\n        let leftPointIndex = Geometry.restrictToInterval(Math.floor(scaledFraction), 0, numSegments - 1); // lower point index on active segment.\n        const localFraction = scaledFraction - leftPointIndex;\n        const point0 = this._points.interpolate(leftPointIndex, localFraction, leftPointIndex + 1, LineString3d._workPointA);\n        const point1 = LineString3d._workPointB;\n        const context = new MoveByDistanceContext(point0, startFraction, signedDistance);\n        if (signedDistance > 0.0) {\n            for (; leftPointIndex <= numSegments;) {\n                leftPointIndex++;\n                this._points.getPoint3dAtCheckedPointIndex(leftPointIndex, point1);\n                if (context.announcePoint(point1, leftPointIndex / numSegments))\n                    return CurveLocationDetail.createCurveFractionPointDistanceCurveSearchStatus(this, context.fraction0, context.point0, signedDistance, CurveSearchStatus.success, result);\n            }\n            // fall through for extrapolation from final segment\n            if (allowExtension)\n                context.announceExtrapolation(this._points, numSegments - 1, numSegments, (numSegments - 1) / numSegments, 1.0);\n            return CurveLocationDetail.createCurveFractionPointDistanceCurveSearchStatus(this, context.fraction0, context.point0, signedDistance, context.distanceStatus(), result);\n        }\n        else { // (moving backwards)\n            if (localFraction <= 0.0)\n                leftPointIndex--;\n            for (; leftPointIndex >= 0; leftPointIndex--) {\n                this._points.getPoint3dAtCheckedPointIndex(leftPointIndex, point1);\n                if (context.announcePoint(point1, leftPointIndex / numSegments))\n                    return CurveLocationDetail.createCurveFractionPointDistanceCurveSearchStatus(this, context.fraction0, context.point0, signedDistance, CurveSearchStatus.success, result);\n            }\n            // fall through for backward extrapolation from initial segment\n            if (allowExtension)\n                context.announceExtrapolation(this._points, 1, 0, 1.0 / numSegments, 0.0);\n            return CurveLocationDetail.createCurveFractionPointDistanceCurveSearchStatus(this, context.fraction0, context.point0, -context.distance0, context.distanceStatus(), result);\n        }\n    }\n    /** Sum lengths of segments in the linestring.  (This is a true length.) */\n    quickLength() { return this.curveLength(); }\n    /**\n     * Compute and normalize cross product among 3 points on the linestring.\n     * * \"any\" 3 points are acceptable -- no test for positive overall sense.\n     * * This is appropriate for polygon known to be convex.\n     * * use points spread at index step n/3, hopefully avoiding colinear points.\n     * * If that fails, try points 012\n     * @param result computed normal.\n     */\n    quickUnitNormal(result) {\n        let step = Math.floor(this._points.length / 3);\n        if (step < 1)\n            step = 1;\n        result = this._points.crossProductIndexIndexIndex(0, step, step + step);\n        if (result && result.normalizeInPlace())\n            return result;\n        return undefined;\n    }\n    /** Find the point on the linestring (including its segment interiors) that is closest to spacePoint. */\n    closestPoint(spacePoint, extend, result) {\n        result = CurveLocationDetail.create(this, result);\n        const extend0 = CurveExtendOptions.resolveVariantCurveExtendParameterToCurveExtendMode(extend, 0);\n        const extend1 = CurveExtendOptions.resolveVariantCurveExtendParameterToCurveExtendMode(extend, 1);\n        const numPoints = this._points.length;\n        if (numPoints > 0) {\n            const lastIndex = numPoints - 1;\n            result.setFP(1.0, this._points.getPoint3dAtUncheckedPointIndex(lastIndex), undefined);\n            result.setDistanceTo(spacePoint);\n            if (numPoints > 1) {\n                let segmentFraction = 0;\n                let d = 0;\n                for (let i = 1; i < numPoints; i++) {\n                    segmentFraction = spacePoint.fractionOfProjectionToLine(this._points.getPoint3dAtUncheckedPointIndex(i - 1), this._points.getPoint3dAtUncheckedPointIndex(i));\n                    if (segmentFraction < 0) {\n                        if (!extend0 || i > 1)\n                            segmentFraction = 0.0;\n                    }\n                    else if (segmentFraction > 1.0) {\n                        if (!extend1 || i < lastIndex)\n                            segmentFraction = 1.0;\n                    }\n                    this._points.getPoint3dAtUncheckedPointIndex(i - 1)\n                        .interpolate(segmentFraction, this._points.getPoint3dAtUncheckedPointIndex(i), result.pointQ);\n                    d = result.pointQ.distance(spacePoint);\n                    if (d < result.a) {\n                        result.setFP(this.segmentIndexAndLocalFractionToGlobalFraction(i - 1, segmentFraction), result.pointQ, undefined, d);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n    /** Test if all points of the linestring are in a plane. */\n    isInPlane(plane) {\n        return this._points.isCloseToPlane(plane, Geometry.smallMetricDistance);\n    }\n    /**\n     * Push a hit, fixing up the prior entry if needed.\n     * Return the incremented counter.\n     */\n    static pushVertexHit(result, counter, cp, fraction, point) {\n        const detail = CurveLocationDetail.createCurveFractionPoint(cp, fraction, point);\n        result.push(detail);\n        if (counter === 0) {\n            detail.setIntervalRole(CurveIntervalRole.isolatedAtVertex);\n        }\n        else if (counter === 1) { // last entry must be isolatedAtVertex !!!\n            result[result.length - 2].setIntervalRole(CurveIntervalRole.intervalStart);\n            detail.setIntervalRole(CurveIntervalRole.intervalEnd);\n        }\n        else {\n            result[result.length - 2].setIntervalRole(CurveIntervalRole.intervalInterior);\n            detail.setIntervalRole(CurveIntervalRole.intervalEnd);\n        }\n    }\n    /**\n     * Find intersections with a plane.\n     *  Intersections within segments are recorded as CurveIntervalRole.isolated\n     *   Intersections at isolated \"on\" vertex are recoded as CurveIntervalRole.isolatedAtVertex.\n     */\n    appendPlaneIntersectionPoints(plane, result) {\n        if (this._points.length < 1)\n            return 0;\n        const initialLength = result.length;\n        const n = this._points.length;\n        const divisor = n === 1 ? 1.0 : n - 1;\n        const pointA = LineString3d._workPointA;\n        const pointB = LineString3d._workPointB;\n        const pointC = LineString3d._workPointC;\n        this._points.getPoint3dAtUncheckedPointIndex(0, pointA);\n        let hB = 0;\n        let numConsecutiveZero = 0;\n        let hA = 0;\n        let segmentFraction = 0;\n        for (let i = 0; i < this._points.length; i++, pointA.setFrom(pointB), hA = hB) {\n            this._points.getPoint3dAtUncheckedPointIndex(i, pointB);\n            hB = Geometry.correctSmallMetricDistance(plane.altitude(pointB));\n            if (hB === 0.0)\n                LineString3d.pushVertexHit(result, numConsecutiveZero++, this, i / divisor, pointB);\n            else {\n                if (hA * hB < 0.0) { // at point0, hA=0 will keep us out of here . ..\n                    segmentFraction = hA / (hA - hB); // this division is safe because the signs are different.\n                    pointA.interpolate(segmentFraction, pointB, pointC);\n                    const detail = CurveLocationDetail.createCurveFractionPoint(this, (i - 1 + segmentFraction) / divisor, pointC);\n                    detail.setIntervalRole(CurveIntervalRole.isolated);\n                    result.push(detail);\n                    numConsecutiveZero = 0;\n                }\n            }\n        }\n        return result.length - initialLength;\n    }\n    /** Extend `rangeToExtend` to include all points of this linestring. */\n    extendRange(rangeToExtend, transform) {\n        this._points.extendRange(rangeToExtend, transform);\n    }\n    /** Test if each point of this linestring isAlmostEqual with corresponding point in `other`. */\n    isAlmostEqual(other) {\n        if (!(other instanceof LineString3d))\n            return false;\n        if (!GrowableXYZArray.isAlmostEqual(this._points, other._points))\n            return false;\n        return true;\n    }\n    /**\n     * Append (clone of) one point.\n     * * BUT ... skip if duplicates the tail of prior points.\n     * * if fraction is given, \"duplicate\" considers both point and fraction.\n     */\n    appendStrokePoint(point, fraction) {\n        const n = this._points.length;\n        let add = true;\n        const addFraction = fraction !== undefined && this._fractions !== undefined;\n        if (n > 0) {\n            if (addFraction && Geometry.isSameCoordinate(fraction, this._fractions.back()))\n                add = false;\n            if (point.isAlmostEqual(this._points.getPoint3dAtUncheckedPointIndex(n - 1)))\n                add = false;\n        }\n        if (add) {\n            this._points.push(point);\n            if (addFraction)\n                this.addFraction(fraction);\n        }\n    }\n    /** Compress out duplicate points (according to point.isAlmostEqual) */\n    removeDuplicatePoints(tolerance = Geometry.smallMetricDistance) {\n        const n = this._points.length;\n        if (n < 2)\n            return;\n        let n1 = 1;\n        for (let i = 1; i < n; i++) {\n            const q = this._points.distanceIndexIndex(i, n1 - 1);\n            if (q !== undefined && q > tolerance) {\n                this._points.moveIndexToIndex(i, n1);\n                if (this._fractions !== undefined)\n                    this._fractions.setAtUncheckedIndex(n1, this._fractions.atUncheckedIndex(i));\n                if (this._derivatives)\n                    this._derivatives.moveIndexToIndex(i, n1);\n                n1++;\n            }\n        }\n        this._points.resize(n1);\n        if (this._fractions)\n            this._fractions.resize(n1);\n        if (this._derivatives)\n            this._derivatives.resize(n1);\n    }\n    /**\n     * Append a suitable evaluation of a curve ..\n     * * always append the curve point\n     * * if fraction array is present, append the fraction\n     * * if derivative array is present, append the derivative\n     * BUT ... skip if duplicates the tail of prior points.\n     */\n    appendFractionToPoint(curve, fraction) {\n        if (this._derivatives) {\n            const ray = curve.fractionToPointAndDerivative(fraction, LineString3d._workRay);\n            if (this._fractions)\n                this._fractions.push(fraction);\n            this._points.push(ray.origin);\n            if (this._derivatives)\n                this._derivatives.push(ray.direction);\n        }\n        else {\n            const point = curve.fractionToPoint(fraction, LineString3d._workPointA);\n            if (this._fractions)\n                this._fractions.push(fraction);\n            this._points.push(point);\n        }\n    }\n    /**\n     * Clear all array data:\n     * * points\n     * * optional fractions.\n     * * optional derivatives.\n     */\n    clear() {\n        this._points.clear();\n        if (this._fractions)\n            this._fractions.clear();\n        if (this._derivatives)\n            this._derivatives.clear();\n    }\n    /**\n     * * options.needParams triggers creation of fraction array and uvParams array.\n     * * options.needNormals triggers creation of derivatives array\n     * @param capacity if positive, initial capacity of arrays\n     * @param options  optional, to indicate if fraction and derivative arrays are required.\n     */\n    static createForStrokes(capacity = 0, options) {\n        const ls = LineString3d.create();\n        if (capacity > 0)\n            ls._points.ensureCapacity(capacity);\n        if (options) {\n            if (options.needParams) {\n                ls._fractions = new GrowableFloat64Array(capacity);\n                ls._uvParams = new GrowableXYArray(capacity);\n            }\n            if (options.needNormals) {\n                ls._derivatives = new GrowableXYZArray(capacity);\n                ls._surfaceNormals = new GrowableXYZArray(capacity);\n            }\n        }\n        return ls;\n    }\n    /**\n     * Evaluate a curve at uniform fractions. Append the evaluations to this linestring.\n     * @param curve primitive to evaluate.\n     * @param numStrokes number of strokes (edges).\n     * @param fraction0 starting fraction coordinate\n     * @param fraction1 end fraction coordinate\n     * @param include01 if false, points at fraction0 and fraction1 are omitted.\n     */\n    appendFractionalStrokePoints(curve, numStrokes, fraction0 = 0, fraction1 = 1, include01 = true) {\n        let i0 = 1;\n        let i1 = numStrokes - 1;\n        if (include01) {\n            i0 = 0;\n            i1 = numStrokes;\n        }\n        if (numStrokes >= 1) {\n            const df = (fraction1 - fraction0) / numStrokes;\n            for (let i = i0; i <= i1; i++)\n                this.appendFractionToPoint(curve, fraction0 + i * df);\n        }\n    }\n    /**\n     * Append points constructed as interpolation between two points.\n     * @param numStrokes number of strokes.\n     * @param point0 first point\n     * @param point1 last point\n     * @param include01 if false, OMIT both start and end points (i.e. only compute and add true interior points)\n     */\n    appendInterpolatedStrokePoints(numStrokes, point0, point1, include01) {\n        if (include01)\n            this.appendStrokePoint(point0, 0.0);\n        if (numStrokes > 1) {\n            const df = 1.0 / numStrokes;\n            for (let i = 1; i < numStrokes; i++) {\n                const f = i * df;\n                this.appendStrokePoint(point0.interpolate(f, point1), f);\n            }\n        }\n        if (include01)\n            this.appendStrokePoint(point1, 1.0);\n    }\n    /** Emit strokes to caller-supplied linestring */\n    emitStrokes(dest, options) {\n        const n = this._points.length;\n        const pointA = LineString3d._workPointA;\n        const pointB = LineString3d._workPointB;\n        if (n > 0) {\n            // This is a linestring.\n            // There is no need for chordTol and angleTol within a segment.\n            // Do NOT apply min strokes per primitive.\n            if (options && options.hasMaxEdgeLength) {\n                dest.appendStrokePoint(this._points.getPoint3dAtUncheckedPointIndex(0));\n                for (let i = 1; i < n; i++) {\n                    this._points.getPoint3dAtUncheckedPointIndex(i - 1, pointA);\n                    this._points.getPoint3dAtUncheckedPointIndex(i, pointB);\n                    const numStroke = options.applyMaxEdgeLength(1, pointA.distance(pointB));\n                    if (numStroke > 1)\n                        dest.appendInterpolatedStrokePoints(numStroke, pointA, pointB, false);\n                    dest.appendStrokePoint(pointB);\n                }\n            }\n            else {\n                for (let i = 0; i < n; i++) {\n                    dest.appendStrokePoint(this._points.getPoint3dAtUncheckedPointIndex(i));\n                }\n            }\n        }\n    }\n    /**\n     * Emit strokable parts of the curve to a caller-supplied handler.\n     * If the stroke options does not have a maxEdgeLength, one stroke is emitted for each segment of the linestring.\n     * If the stroke options has a maxEdgeLength, smaller segments are emitted as needed.\n     */\n    emitStrokableParts(handler, options) {\n        const n = this._points.length;\n        handler.startCurvePrimitive(this);\n        if (n > 1) {\n            const df = 1.0 / (n - 1);\n            // This is a linestring.\n            // There is no need for chordTol and angleTol within a segment.\n            // Do NOT apply min strokes per primitive.\n            if (options && options.hasMaxEdgeLength) {\n                for (let i = 1; i < n; i++) {\n                    const numStroke = options.applyMaxEdgeLength(1, this._points.getPoint3dAtUncheckedPointIndex(i - 1).distance(this._points.getPoint3dAtUncheckedPointIndex(i)));\n                    handler.announceSegmentInterval(this, this._points.getPoint3dAtUncheckedPointIndex(i - 1), this._points.getPoint3dAtUncheckedPointIndex(i), numStroke, (i - 1) * df, i * df);\n                }\n            }\n            else {\n                for (let i = 1; i < n; i++) {\n                    handler.announceSegmentInterval(this, this._points.getPoint3dAtUncheckedPointIndex(i - 1), this._points.getPoint3dAtUncheckedPointIndex(i), 1, (i - 1) * df, i * df);\n                }\n            }\n        }\n        handler.endCurvePrimitive(this);\n    }\n    /**\n     * Return the stroke count required for given options.\n     * @param options StrokeOptions that determine count\n     */\n    computeStrokeCountForOptions(options) {\n        const numPoints = this._points.length;\n        let numStroke = numPoints - 1;\n        if (options && options.hasMaxEdgeLength) {\n            numStroke = 0;\n            for (let i = 1; i < numPoints; i++) {\n                numStroke += options.applyMaxEdgeLength(1, this._points.distanceIndexIndex(i - 1, i));\n            }\n        }\n        return numStroke;\n    }\n    /**\n     * Compute individual segment stroke counts.  Attach in a StrokeCountMap.\n     * @param options StrokeOptions that determine count\n     * @param parentStrokeMap evolving parent map.\n     */\n    computeAndAttachRecursiveStrokeCounts(options, parentStrokeMap) {\n        const numPoints = this._points.length;\n        const applyOptions = options !== undefined && options.hasMaxEdgeLength;\n        const myData = StrokeCountMap.createWithCurvePrimitiveAndOptionalParent(this, parentStrokeMap, []);\n        for (let i = 1; i < numPoints; i++) {\n            const segmentLength = this._points.distanceIndexIndex(i - 1, i);\n            const numStrokeOnSegment = applyOptions ? options.applyMaxEdgeLength(1, segmentLength) : 1;\n            myData.addToCountAndLength(numStrokeOnSegment, segmentLength);\n        }\n        CurvePrimitive.installStrokeCountMap(this, myData, parentStrokeMap);\n    }\n    /** Second step of double dispatch:  call `handler.handleLineString3d(this)` */\n    dispatchToGeometryHandler(handler) {\n        return handler.handleLineString3d(this);\n    }\n    // HARD TO TEST -- tests that get to announceClipInterval for arc, bspline do NOT get here with\n    // linestring because the controller has special case loops through segments?\n    /**\n     * Find intervals of this CurvePrimitive that are interior to a clipper\n     * @param clipper clip structure (e.g. clip planes)\n     * @param announce (optional) function to be called announcing fractional intervals\"\n     * ` announce(fraction0, fraction1, curvePrimitive)`\n     * @returns true if any \"in\" segments are announced.\n     */\n    announceClipIntervals(clipper, announce) {\n        const n = this._points.length;\n        if (n < 2)\n            return false;\n        let globalFractionA = 0.0;\n        let globalFractionB = 1.0;\n        const capture = (localFraction0, localFraction1) => {\n            if (announce)\n                announce(Geometry.interpolate(globalFractionA, localFraction0, globalFractionB), Geometry.interpolate(globalFractionA, localFraction1, globalFractionB), this);\n        };\n        const pointA = LineString3d._workPointA;\n        const pointB = LineString3d._workPointB;\n        this._points.getPoint3dAtUncheckedPointIndex(0, pointA);\n        let status = false;\n        for (let i = 1; i < n; i++, pointA.setFrom(pointB), globalFractionA = globalFractionB) {\n            this._points.getPoint3dAtUncheckedPointIndex(i, pointB);\n            globalFractionB = i / (n - 1);\n            if (clipper.announceClippedSegmentIntervals(0.0, 1.0, pointA, pointB, capture))\n                status = true;\n        }\n        return status;\n    }\n    /** @param fraction used to interpolate between points at index and index + 1 */\n    addResolvedPoint(index, fraction, dest) {\n        const n = this._points.length;\n        if (n === 0)\n            return;\n        if (n === 1) {\n            this._points.getPoint3dAtUncheckedPointIndex(0, LineString3d._indexPoint);\n            dest.push(LineString3d._indexPoint);\n            return;\n        }\n        if (index < 0)\n            index = 0;\n        if (index > n - 2) {\n            index = n - 2;\n            fraction += 1;\n        }\n        this._points.interpolate(index, fraction, index + 1, LineString3d._indexPoint);\n        dest.push(LineString3d._indexPoint);\n    }\n    /**\n     * Return a LineString which is a portion of this curve.\n     * * Fractions outside [0,1] extend the relevant end segment.\n     * @param fractionA [in] start fraction\n     * @param fractionB [in] end fraction\n     */\n    clonePartialCurve(fractionA, fractionB) {\n        if (fractionB < fractionA) {\n            const linestringA = this.clonePartialCurve(fractionB, fractionA);\n            if (linestringA)\n                linestringA.reverseInPlace();\n            return linestringA;\n        }\n        const n = this._points.length;\n        if (n < 2)\n            return this.clone();\n        if (n > 2 && this.isPhysicallyClosed) {\n            // don't extend a closed linestring\n            if (fractionA < 0)\n                fractionA = 0;\n            if (fractionB > 1)\n                fractionB = 1;\n        }\n        let index0, index1; // range of original vertices to copy into clone\n        const localA = this.globalFractionToSegmentIndexAndLocalFraction(fractionA);\n        const localB = this.globalFractionToSegmentIndexAndLocalFraction(fractionB);\n        if (fractionA < 0) {\n            index0 = 1; // first original vertex is not in clone\n        }\n        else if (0 <= fractionA && fractionA <= 1) {\n            index0 = Geometry.isSmallRelative(1 - localA.fraction) ? localA.index + 2 : localA.index + 1;\n        }\n        else { // 1 < fractionA\n            index0 = n; // no original vertices in clone\n        }\n        if (fractionB < 0) {\n            index1 = -1; // no original vertices in clone\n        }\n        else if (0 <= fractionB && fractionB <= 1) {\n            index1 = Geometry.isSmallRelative(localB.fraction) ? localB.index - 1 : localB.index;\n        }\n        else { // 1 < fractionB\n            index1 = n - 2; // last original vertex is not in clone\n        }\n        const result = LineString3d.create();\n        this.addResolvedPoint(localA.index, localA.fraction, result._points);\n        for (let index = index0; index <= index1; index++) {\n            if (this._points.isIndexValid(index)) {\n                this._points.getPoint3dAtUncheckedPointIndex(index, LineString3d._workPointA);\n                result._points.push(LineString3d._workPointA);\n            }\n        }\n        this.addResolvedPoint(localB.index, localB.fraction, result._points);\n        return result;\n    }\n    /** Return (if possible) a specific segment of the linestring */\n    getIndexedSegment(index) {\n        if (index >= 0 && index + 1 < this._points.length)\n            return LineSegment3d.create(this._points.getPoint3dAtCheckedPointIndex(index), this._points.getPoint3dAtCheckedPointIndex(index + 1));\n        return undefined;\n    }\n    /** Returns true if first and last points are within metric tolerance. */\n    get isPhysicallyClosed() {\n        return this._points.length > 0 && Geometry.isSmallMetricDistance(this._points.distanceIndexIndex(0, this._points.length - 1));\n    }\n    /**\n     * Evaluate strokes at fractions indicated in a StrokeCountMap.\n     * * The map must have an array of component counts corresponding to the segment of this linestring.\n     * * \"fractions\" in the output are mapped within a0,a1 of the map.componentData\n     * @param map = stroke count data.\n     * @param destLinestring = receiver linestring.\n     * @return number of strokes added.  0 if `map.componentData` does not match the linestring\n     */\n    addMappedStrokesToLineString3D(map, destLinestring) {\n        const numPoint0 = destLinestring.numPoints();\n        const needFractions = destLinestring._fractions !== undefined;\n        const needDerivatives = destLinestring._derivatives !== undefined;\n        const points = this._points;\n        const pointA = LineString3d._workPointA;\n        const pointB = LineString3d._workPointB;\n        const pointC = LineString3d._workPointC;\n        const numParentPoint = points.length;\n        if (map.primitive && map.primitive === this && map.componentData && map.componentData.length + 1 === numParentPoint) {\n            points.getPoint3dAtUncheckedPointIndex(0, pointA);\n            for (let k = 0; k + 1 < numParentPoint; k++, pointA.setFromPoint3d(pointB)) {\n                points.getPoint3dAtUncheckedPointIndex(k + 1, pointB);\n                const segmentMap = map.componentData[k];\n                const m = segmentMap.numStroke;\n                const vectorAB = pointA.vectorTo(pointB);\n                vectorAB.scale(m);\n                for (let i = 0; i <= m; i++) {\n                    const fraction = i / m;\n                    const outputFraction = segmentMap.fractionToA(fraction);\n                    destLinestring.addPoint(pointA.interpolate(fraction, pointB, pointC));\n                    if (needFractions)\n                        destLinestring._fractions.push((outputFraction));\n                    if (needDerivatives)\n                        destLinestring._derivatives.push(vectorAB);\n                }\n            }\n        }\n        return destLinestring.numPoints() - numPoint0;\n    }\n    /**\n     * Convert variant point data to a single level array of linestrings.\n     * * The result is always an array of LineString3d.\n     *   * Single linestring is NOT bubbled out as a special case.\n     *   * data with no point is an empty array.\n     *   * \"deep\" data is flattened to a single array of linestrings, losing structure.\n     */\n    static createArrayOfLineString3d(data) {\n        const collector = new PointStreamGrowableXYZArrayCollector();\n        VariantPointDataStream.streamXYZ(data, collector);\n        const growableArrays = collector.claimArrayOfGrowableXYZArray();\n        const result = [];\n        if (growableArrays !== undefined) {\n            for (const points of growableArrays)\n                result.push(LineString3d.createCapture(points));\n        }\n        return result;\n    }\n    /**\n     * Return an array containing only the curve primitives.\n     * @param collectorArray array to receive primitives (pushed -- the array is not cleared)\n     * @param _smallestPossiblePrimitives unused\n     * @param explodeLinestrings if true, push a [[LineSegment3d]] for each segment. If false, only push `this`.\n     */\n    collectCurvePrimitivesGo(collectorArray, _smallestPossiblePrimitives, explodeLinestrings = false) {\n        if (explodeLinestrings) {\n            let segment;\n            for (let i = 0; (segment = this.getIndexedSegment(i)) !== undefined; i++)\n                collectorArray.push(segment);\n        }\n        else {\n            collectorArray.push(this);\n        }\n    }\n    /**\n     * Construct an offset of each segment as viewed in the xy-plane (ignoring z).\n     * * No attempt is made to join the offset segments. Use RegionOps.constructCurveXYOffset() to return a fully\n     * joined offset.\n     * @param offsetDistanceOrOptions offset distance (positive to left of the instance curve), or options object\n     */\n    constructOffsetXY(offsetDistanceOrOptions) {\n        const options = OffsetOptions.create(offsetDistanceOrOptions);\n        const offsets = [];\n        for (const seg of this.collectCurvePrimitives(undefined, true, true)) {\n            const offset = seg.constructOffsetXY(options);\n            if (offset !== undefined) {\n                if (offset instanceof CurvePrimitive)\n                    offsets.push(offset);\n                else if (Array.isArray(offset))\n                    offset.forEach((cp) => offsets.push(cp));\n            }\n        }\n        return offsets;\n    }\n    /**\n     * Project instance geometry (via dispatch) onto the given ray, and return the extreme fractional parameters\n     * of projection.\n     * @param ray ray onto which the instance is projected. A `Vector3d` is treated as a `Ray3d` with zero origin.\n     * @param lowHigh optional receiver for output\n     * @returns range of fractional projection parameters onto the ray, where 0.0 is start of the ray and 1.0 is\n     * the end of the ray.\n     */\n    projectedParameterRange(ray, lowHigh) {\n        return PlaneAltitudeRangeContext.findExtremeFractionsAlongDirection(this, ray, lowHigh);\n    }\n}\nLineString3d._workPointA = Point3d.create();\nLineString3d._workPointB = Point3d.create();\nLineString3d._workPointC = Point3d.create();\nLineString3d._workRay = Ray3d.createXAxis();\nLineString3d._indexPoint = Point3d.create(); // private point for addResolvedPoint\nexport { LineString3d };\n/**\n * An AnnotatedLineString3d is a linestring with additional surface-related data attached to each point\n * * This is useful in facet construction.\n * @internal\n */\nexport class AnnotatedLineString3d {\n}\n/**\n * Context to be called to incrementally accumulate distance along line segments.\n */\nclass MoveByDistanceContext {\n    /** CAPTURE point0, fraction0, targetDistance */\n    constructor(point0, fraction0, targetDistance) {\n        this.point0 = point0;\n        this.distance0 = 0.0;\n        this.targetDistance = Math.abs(targetDistance);\n        this.fraction0 = fraction0;\n    }\n    // Return CurveSearchStatus indicating whether the accumulated distance has reached the target.\n    distanceStatus() {\n        return Geometry.isSameCoordinate(this.distance0, this.targetDistance) ?\n            CurveSearchStatus.success : CurveSearchStatus.stoppedAtBoundary;\n    }\n    /**\n     * Announce next point on the polyline.\n     * * if the additional segment does NOT reach the target:\n     *   * accumulate the segment length\n     *   * update point0 and fraction0\n     *   * return false\n     *  * if the additional segment DOES reach the target:\n     *    * update point0 and fraction0 to the (possibly interpolated) final point and fraction\n     *    * return true\n     * @param point1 new point\n     * @param fraction1 fraction at point1\n     * @return true if targetDistance reached.\n     */\n    announcePoint(point1, fraction1) {\n        const a = this.point0.distance(point1);\n        const distance1 = this.distance0 + a;\n        if (distance1 < this.targetDistance && !Geometry.isSameCoordinate(distance1, this.targetDistance)) {\n            this.point0.setFromPoint3d(point1);\n            this.distance0 = distance1;\n            this.fraction0 = fraction1;\n            return false;\n        }\n        const b = this.targetDistance - this.distance0;\n        const intervalFraction = Geometry.safeDivideFraction(b, a, 0.0);\n        this.point0.interpolate(intervalFraction, point1, this.point0);\n        this.fraction0 = Geometry.interpolate(this.fraction0, intervalFraction, fraction1);\n        this.distance0 = this.targetDistance;\n        return true;\n    }\n    /**\n     * Update point0, fraction0, and distance0 based on extrapolation of a segment between indices of a point array.\n     * @returns true if extrapolation succeeded.  (False if indexed points are coincident)\n     * @param points\n     * @param index0\n     * @param index1\n     * @param fraction0\n     * @param fraction1\n     * @param result\n     * @param CurveLocationDetail\n     */\n    announceExtrapolation(points, index0, index1, fraction0, fraction1) {\n        const residual = this.targetDistance - this.distance0;\n        const d01 = points.distanceIndexIndex(index0, index1);\n        if (!d01)\n            return false;\n        const extensionFraction = Geometry.conditionalDivideFraction(residual, d01);\n        if (extensionFraction === undefined)\n            return false;\n        // (Remark: indices are swapped and extensionFraction negated to prevent incidental precision\n        // loss with the alternative call with (index0, 1 + extensionFraction, index1);\n        points.interpolate(index1, -extensionFraction, index0, this.point0);\n        this.distance0 = this.targetDistance;\n        this.fraction0 = Geometry.interpolate(fraction1, -extensionFraction, fraction0);\n        return true;\n    }\n}\n//# sourceMappingURL=LineString3d.js.map",
      "start": 1693508122767,
      "end": 1693508122922,
      "sourcemaps": null
    }
  ]
}
