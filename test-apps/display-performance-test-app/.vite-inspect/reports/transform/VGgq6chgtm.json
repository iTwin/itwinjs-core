{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/topology/Merging.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\nimport { LineSegment3d } from \"../curve/LineSegment3d\";\nimport { Geometry } from \"../Geometry\";\nimport { Angle } from \"../geometry3d/Angle\";\nimport { Point2d, Vector2d } from \"../geometry3d/Point2dVector2d\";\nimport { Range3d } from \"../geometry3d/Range\";\nimport { ClusterableArray } from \"../numerics/ClusterableArray\";\nimport { SmallSystem } from \"../numerics/Polynomials\";\nimport { HalfEdge, HalfEdgeGraph, HalfEdgeMask } from \"./Graph\";\nimport { HalfEdgePriorityQueueWithPartnerArray } from \"./HalfEdgePriorityQueue\";\nimport { RegularizationContext } from \"./RegularizeFace\";\nimport { Triangulator } from \"./Triangulation\";\nexport class GraphSplitData {\n    constructor() {\n        this.numUpEdge = 0;\n        this.numIntersectionTest = 0;\n        this.numSplit = 0;\n        this.numPopOut = 0;\n        this.numA0B0 = 0;\n        this.numA0B1 = 0;\n    }\n}\n/**\n * Structure for data used when sorting outbound edges \"around a node\"\n */\nexport class VertexNeighborhoodSortData {\n    constructor(index, key, node, radians) {\n        this.index = index;\n        this.radiusOfCurvature = key;\n        this.node = node;\n        this.radians = radians;\n    }\n}\n/**\n * * Assorted methods used in algorithms on HalfEdgeGraph.\n * @internal\n */\nexport class HalfEdgeGraphOps {\n    /** Compare function for sorting with primary y compare, secondary  x compare. */\n    static compareNodesYXUp(a, b) {\n        // Check y's\n        // if (!Geometry.isSameCoordinate(a.y, b.y))\n        if (a.y < b.y)\n            return -1;\n        else if (a.y > b.y)\n            return 1;\n        // Check x's\n        // if (!Geometry.isSameCoordinate(a.x, b.x))\n        if (a.x < b.x)\n            return -1;\n        else if (a.x > b.x)\n            return 1;\n        return 0;\n    }\n    /** Return true if nodeB (a) is lower than both its neighbors and (b) inflects as a downward peak (rather than an upward trough) */\n    static isDownPeak(nodeB) {\n        const nodeA = nodeB.facePredecessor;\n        const nodeC = nodeB.faceSuccessor;\n        return this.compareNodesYXUp(nodeB, nodeA) < 0\n            && this.compareNodesYXUp(nodeB, nodeC) < 0\n            && this.crossProductToTargets(nodeB, nodeA, nodeC) > 0;\n    }\n    /** return the cross product of vectors from base to targetA and base to targetB\n     * @param base base vertex of both vectors.\n     * @param targetA target vertex of first vector\n     * @param targetB target vertex of second vector\n     */\n    static crossProductToTargets(base, targetA, targetB) {\n        return Geometry.crossProductXYXY(targetA.x - base.x, targetA.y - base.y, targetB.x - base.x, targetB.y - base.y);\n    }\n    // ---------------------------------------------------------------------------------------------------------------------\n    // ----------------------------------------------------------------------------------------------------------------------\n    static graphRange(graph) {\n        const range = Range3d.create();\n        for (const node of graph.allHalfEdges) {\n            range.extendXYZ(node.x, node.y, node.z);\n        }\n        return range;\n    }\n    /** Returns an array of all nodes (both ends) of edges created from segments. */\n    static segmentArrayToGraphEdges(segments, returnGraph, mask) {\n        const result = [];\n        let idxCounter = 0;\n        // Push the endpoints of each segment onto arr[] in the form {(x, y, theta), Node}\n        for (const segment of segments) {\n            const node0 = returnGraph.createEdgeXYZXYZ(segment.point0Ref.x, segment.point0Ref.y, segment.point0Ref.z, idxCounter, segment.point1Ref.x, segment.point1Ref.y, segment.point1Ref.z, idxCounter + 1);\n            const node1 = node0.edgeMate;\n            idxCounter += 2;\n            node0.setMaskAroundFace(mask); // Original given coordinates must be part of boundary\n            result.push(node0);\n            result.push(node1);\n        }\n        return result;\n    }\n    /**\n     * * Visit all nodes in `graph`.\n     * * invoke `pinch(node, vertexPredecessor)`\n     * * this leaves the graph as isolated edges.\n     * @param graph graph to modify\n     */\n    static isolateAllEdges(graph) {\n        for (const nodeA of graph.allHalfEdges) {\n            const nodeB = nodeA.vertexPredecessor;\n            HalfEdge.pinch(nodeA, nodeB);\n        }\n    }\n    /**\n     * Compute convexity of a sector of a super-face.\n     * @param base node whose edge is to be tested for removal\n     * @param ignore edges with this mask (on either side) are ignored for the purposes of computing convexity\n     * @param barrier edges with this mask (on either side) will not be removed\n     * @return whether removing the edge at base would create a convex sector in the super-face\n     */\n    static isSectorConvexAfterEdgeRemoval(base, ignore, barrier) {\n        let vs = base;\n        do { // loop ccw around vertex looking for a super-face predecessor\n            if (vs.isMaskSet(barrier) || vs.edgeMate.isMaskSet(barrier))\n                break;\n            vs = vs.vertexSuccessor;\n        } while (vs !== base && vs.isMaskSet(ignore));\n        if (vs === base)\n            return false;\n        let vp = base;\n        do { // loop cw around vertex looking for a super-face successor\n            if (vp.isMaskSet(barrier) || vp.edgeMate.isMaskSet(barrier))\n                break;\n            vp = vp.vertexPredecessor;\n        } while (vp !== base && vp.isMaskSet(ignore));\n        if (vp === base)\n            return false;\n        return HalfEdge.isSectorConvex(vs.edgeMate, base, vp.faceSuccessor);\n    }\n    /**\n     * Mask edges between faces if the union of the faces is convex.\n     * Uses a greedy algorithm with no regard to quality of resulting convex faces.\n     * Best results when input faces are convex.\n     * @param graph graph to examine and mark\n     * @param mark the mask used to mark (both sides of) removable edges\n     * @param barrier edges with this mask (on either side) will not be marked. Defaults to HalfEdgeMask.BOUNDARY_EDGE.\n     * @return number of edges masked (half the number of HalfEdges masked)\n     */\n    static markRemovableEdgesToExpandConvexFaces(graph, mark, barrier = HalfEdgeMask.BOUNDARY_EDGE) {\n        if (HalfEdgeMask.NULL_MASK === mark)\n            return 0;\n        const visit = graph.grabMask(true);\n        let numMarked = 0;\n        for (const node of graph.allHalfEdges) {\n            if (!node.isMaskSet(visit)) {\n                if (!node.isMaskSet(barrier) && !node.edgeMate.isMaskSet(barrier)) {\n                    if (this.isSectorConvexAfterEdgeRemoval(node, mark, barrier) && this.isSectorConvexAfterEdgeRemoval(node.edgeMate, mark, barrier)) {\n                        node.setMaskAroundEdge(mark);\n                        ++numMarked;\n                    }\n                }\n            }\n            node.setMaskAroundEdge(visit);\n        }\n        return numMarked;\n    }\n    /**\n     * Collect edges between faces if the union of the faces is convex.\n     * Uses a greedy algorithm with no regard to quality of resulting convex faces.\n     * Best results when input faces are convex.\n     * @param graph graph to examine\n     * @param barrier edges with this mask (on either side) will not be collected. Defaults to HalfEdgeMask.BOUNDARY_EDGE.\n     * @return one HalfEdge per removable edge\n     */\n    static collectRemovableEdgesToExpandConvexFaces(graph, barrier = HalfEdgeMask.BOUNDARY_EDGE) {\n        const removable = [];\n        const mark = graph.grabMask(true);\n        if (0 < this.markRemovableEdgesToExpandConvexFaces(graph, mark, barrier)) {\n            const visited = graph.grabMask(true);\n            for (const node of graph.allHalfEdges) {\n                if (node.isMaskSet(mark) && !node.isMaskSet(visited)) {\n                    node.setMaskAroundEdge(visited);\n                    removable.push(node);\n                }\n            }\n            graph.dropMask(visited);\n        }\n        graph.dropMask(mark);\n        return removable;\n    }\n    /**\n     * Remove edges between faces if the union of the faces is convex.\n     * Uses a greedy algorithm with no regard to quality of resulting convex faces.\n     * Best results when input faces are convex.\n     * @param graph graph to modify\n     * @param barrier edges with this mask (on either side) will not be removed. Defaults to HalfEdgeMask.BOUNDARY_EDGE.\n     * @return number of edges deleted\n     */\n    static expandConvexFaces(graph, barrier = HalfEdgeMask.BOUNDARY_EDGE) {\n        const mark = graph.grabMask(true);\n        const numRemovedEdges = this.markRemovableEdgesToExpandConvexFaces(graph, mark, barrier);\n        if (numRemovedEdges > 0)\n            graph.yankAndDeleteEdges((node) => node.getMask(mark));\n        graph.dropMask(mark);\n        return numRemovedEdges;\n    }\n    /**\n     * Test desired faces for convexity.\n     * @param graph graph to examine\n     * @param avoid faces with this mask will not be examined. Defaults to HalfEdgeMask.EXTERIOR.\n     * @return whether every face in the graph is convex\n     */\n    static isEveryFaceConvex(graph, avoid = HalfEdgeMask.EXTERIOR) {\n        const allFaces = graph.collectFaceLoops();\n        for (const node of allFaces) {\n            if (node.isMaskedAroundFace(avoid))\n                continue;\n            if (!node.isFaceConvex())\n                return false;\n        }\n        return true;\n    }\n}\n/**\n * Note: this class uses hardcoded micrometer coordinate/cluster tolerance throughout.\n * @internal\n */\nexport class HalfEdgeGraphMerge {\n    // return kC such that all angles k are equal, with kA <= k < kC <= kB.\n    // * Assume: angles k are stored at extra data index 0.\n    // * Note that the usual case (when angle at kA is not repeated) is kA+1 === kC\n    static getCommonThetaEndIndex(clusters, order, kA, kB) {\n        let kC = kA + 1;\n        const thetaA = clusters.getExtraData(order[kA], 0);\n        while (kC < kB) {\n            const thetaB = clusters.getExtraData(order[kC], 0);\n            if (!Angle.isAlmostEqualRadiansAllowPeriodShift(thetaA, thetaB)) {\n                return kC;\n            }\n            kC++;\n        }\n        return kC;\n    }\n    /**\n     * public property setter for a function to be called with sorted edge data around a vertex.\n     */\n    static set announceVertexNeighborhoodFunction(func) { this._announceVertexNeighborhoodFunction = func; }\n    static doAnnounceVertexNeighborhood(clusters, order, allNodes, k0, k1) {\n        if (this._announceVertexNeighborhoodFunction) {\n            const sortData = [];\n            // build and share the entire vertex order\n            for (let k = k0; k < k1; k++) {\n                const index = clusters.getExtraData(order[k], 1);\n                const theta = clusters.getExtraData(order[k], 0);\n                const node = allNodes[index];\n                const signedDistance = this.curvatureSortKey(node);\n                sortData.push(new VertexNeighborhoodSortData(order[k], signedDistance, node, theta));\n            }\n            this._announceVertexNeighborhoodFunction(sortData);\n        }\n    }\n    // assumptions about cluster array:\n    //   * data order is: x,y,theta,nodeIndex\n    //   * theta and nodeIndex are the \"extra\" data.\n    //   * only want to do anything here when curves are present.\n    //   * k0<=k<k1 are around a vertex\n    //   * These are sorted by theta.\n    static secondarySortAroundVertex(clusters, order, allNodes, k0, k1) {\n        const sortData = [];\n        for (let k = k0; k < k1;) {\n            const kB = this.getCommonThetaEndIndex(clusters, order, k, k1);\n            if (k + 1 < kB) {\n                sortData.length = 0;\n                for (let kA = k; kA < kB; kA++) {\n                    const index = clusters.getExtraData(order[kA], 1);\n                    const node = allNodes[index];\n                    const signedDistance = this.curvatureSortKey(node);\n                    sortData.push(new VertexNeighborhoodSortData(order[kA], signedDistance, node));\n                }\n                sortData.sort((a, b) => (a.radiusOfCurvature - b.radiusOfCurvature));\n                for (let i = 0; i < sortData.length; i++) {\n                    order[k + i] = sortData[i].index;\n                }\n            }\n            k = kB;\n        }\n    }\n    /** Return the sort key for sorting by curvature.\n     * * This is the signed distance from the curve at the edge start, to center of curvature.\n     * * NOTE: Currently does not account for higher derivatives in the case of higher-than-tangent match.\n     */\n    static curvatureSortKey(node) {\n        const cld = node.edgeTag;\n        if (cld !== undefined) {\n            const fraction = cld.fraction;\n            const curve = cld.curve;\n            if (curve) {\n                let radius = curve.fractionToSignedXYRadiusOfCurvature(fraction);\n                if (node.sortData !== undefined && node.sortData < 0)\n                    radius = -radius;\n                return radius;\n            }\n        }\n        return 0.0;\n    }\n    /** Simplest merge algorithm:\n     * * collect array of (x,y,theta) at all nodes\n     * * lexical sort of the array.\n     * * twist all vertices together.\n     * * This effectively creates valid face loops for a planar subdivision if there are no edge crossings.\n     * * If there are edge crossings, the graph can be a (highly complicated) Klein bottle topology.\n     * * Mask.NULL_FACE is cleared throughout and applied within null faces.\n     */\n    static clusterAndMergeXYTheta(graph, outboundRadiansFunction) {\n        const allNodes = graph.allHalfEdges;\n        const numNodes = allNodes.length;\n        graph.clearMask(HalfEdgeMask.NULL_FACE);\n        const clusters = new ClusterableArray(2, 2, numNodes); // data order: x,y,theta,nodeIndex.  But theta is not set in first round.\n        for (let i = 0; i < numNodes; i++) {\n            const nodeA = allNodes[i];\n            const xA = nodeA.x;\n            const yA = nodeA.y;\n            HalfEdge.pinch(nodeA, nodeA.vertexSuccessor); // pull it out of its current vertex loop.\n            clusters.addDirect(xA, yA, 0.0, i);\n        }\n        const clusterTol = Geometry.smallMetricDistance;\n        const order = clusters.clusterIndicesLexical(clusterTol);\n        let k0 = 0;\n        const numK = order.length;\n        for (let k1 = 0; k1 < numK; k1++) {\n            if (order[k1] === ClusterableArray.clusterTerminator) {\n                // nodes identified in order[k0]..order[k1-1] are at a vertex cluster; equate their xy\n                if (k1 > k0) {\n                    const iA = clusters.getExtraData(order[k0], 1);\n                    const nodeA0 = allNodes[iA];\n                    for (let k = k0 + 1; k < k1; k++) {\n                        const iB = clusters.getExtraData(order[k], 1);\n                        const nodeB = allNodes[iB];\n                        nodeB.x = nodeA0.x;\n                        nodeB.y = nodeA0.y;\n                    }\n                }\n                k0 = k1 + 1;\n            }\n        }\n        // NOW\n        //  1) There are identical coordinates at all nodes around each vertex loop.\n        //  2) Hence ready do sort (at each vertex) by theta.\n        // insert theta as extra data in the sort table . . .\n        for (const clusterTableIndex of order) {\n            if (clusterTableIndex !== ClusterableArray.clusterTerminator) {\n                const nodeA = allNodes[clusterTableIndex];\n                const nodeB = nodeA.faceSuccessor;\n                let getPrecomputedRadians = outboundRadiansFunction;\n                if (getPrecomputedRadians) {\n                    // Recompute theta when edge geometry is completely determined by the vertices, which may have been perturbed by clustering.\n                    const detail = nodeA.edgeTag;\n                    if (undefined === detail || undefined === detail.curve || detail.curve instanceof LineSegment3d)\n                        getPrecomputedRadians = undefined;\n                }\n                let radians = getPrecomputedRadians ? getPrecomputedRadians(nodeA) : Math.atan2(nodeB.y - nodeA.y, nodeB.x - nodeA.x);\n                if (Angle.isAlmostEqualRadiansAllowPeriodShift(radians, -Math.PI))\n                    radians = Math.PI;\n                clusters.setExtraData(clusterTableIndex, 0, radians);\n            }\n        }\n        clusters.sortSubsetsBySingleKey(order, 2);\n        const unmatchedNullFaceNodes = [];\n        k0 = 0;\n        let thetaA, thetaB;\n        // GeometryCoreTestIO.consoleLog(\"START VERTEX LINKS\");\n        // now pinch each neighboring pair together\n        for (let k1 = 0; k1 < numK; k1++) {\n            if (order[k1] === ClusterableArray.clusterTerminator) {\n                // nodes identified in order[k0]..order[k1-1] are properly sorted around a vertex.\n                if (k1 > k0) {\n                    // const xy = clusters.getPoint2d(order[k0]);\n                    // GeometryCoreTestIO.consoleLog({ k0, k1, x: xy.x, y: xy.y });\n                    if (k1 > k0 + 1)\n                        this.secondarySortAroundVertex(clusters, order, allNodes, k0, k1);\n                    this.doAnnounceVertexNeighborhood(clusters, order, allNodes, k0, k1);\n                    const iA = clusters.getExtraData(order[k0], 1);\n                    thetaA = clusters.getExtraData(order[k0], 0);\n                    const nodeA0 = allNodes[iA];\n                    let nodeA = nodeA0;\n                    for (let k = k0 + 1; k < k1; k++) {\n                        const iB = clusters.getExtraData(order[k], 1);\n                        thetaB = clusters.getExtraData(order[k], 0);\n                        const nodeB = allNodes[iB];\n                        if (nodeA.isMaskSet(HalfEdgeMask.NULL_FACE)) {\n                            // nope, this edge was flagged and pinched from the other end.\n                            const j = unmatchedNullFaceNodes.findIndex((node) => nodeA === node);\n                            if (j >= 0) {\n                                unmatchedNullFaceNodes[j] = unmatchedNullFaceNodes[unmatchedNullFaceNodes.length - 1];\n                                unmatchedNullFaceNodes.pop();\n                            }\n                            nodeA = nodeB;\n                            thetaA = thetaB;\n                        }\n                        else if (nodeB.isMaskSet(HalfEdgeMask.NULL_FACE)) {\n                            const j = unmatchedNullFaceNodes.findIndex((node) => nodeB === node);\n                            if (j >= 0) {\n                                unmatchedNullFaceNodes[j] = unmatchedNullFaceNodes[unmatchedNullFaceNodes.length - 1];\n                                unmatchedNullFaceNodes.pop();\n                            }\n                            // NO leave nodeA and thetaA   ignore nodeB -- later step will get the outside of its banana.\n                        }\n                        else {\n                            HalfEdge.pinch(nodeA, nodeB);\n                            // Detect null face using the heuristic:\n                            //  * near vertex angles are same (periodic, toleranced)\n                            //  * far vertex is clustered (exactly equal)\n                            //  * near vertex curvatures are same (toleranced)\n                            // Note that near vertex is already clustered.\n                            if (Angle.isAlmostEqualRadiansAllowPeriodShift(thetaA, thetaB)) {\n                                const nodeA1 = nodeA.faceSuccessor;\n                                const nodeB1 = nodeB.edgeMate;\n                                if (nodeA1.isEqualXY(nodeB1)) {\n                                    const cA = this.curvatureSortKey(nodeA);\n                                    const cB = this.curvatureSortKey(nodeB);\n                                    if (Geometry.isSameCoordinate(cA, cB, clusterTol)) { // rule out banana\n                                        HalfEdge.pinch(nodeA1, nodeB1);\n                                        nodeA.setMask(HalfEdgeMask.NULL_FACE);\n                                        nodeB1.setMask(HalfEdgeMask.NULL_FACE);\n                                        unmatchedNullFaceNodes.push(nodeB1);\n                                    }\n                                }\n                            }\n                            nodeA = nodeB;\n                            thetaA = thetaB;\n                        }\n                    }\n                }\n                k0 = k1 + 1;\n            }\n        }\n    }\n    static buildVerticalSweepPriorityQueue(graph) {\n        const sweepHeap = new HalfEdgePriorityQueueWithPartnerArray();\n        for (const p of graph.allHalfEdges) {\n            if (HalfEdgeGraphOps.compareNodesYXUp(p, p.faceSuccessor) < 0) {\n                sweepHeap.priorityQueue.push(p);\n            }\n        }\n        return sweepHeap;\n    }\n    static snapFractionToNode(xy, fraction, node, nodeFraction) {\n        if (Geometry.isSameCoordinate(xy.x, node.x) && Geometry.isSameCoordinate(xy.y, node.y))\n            return nodeFraction;\n        return fraction;\n    }\n    static computeIntersectionFractionsOnEdges(nodeA0, nodeB0, fractions, pointA, pointB) {\n        const nodeA1 = nodeA0.faceSuccessor;\n        const ax0 = nodeA0.x;\n        const ay0 = nodeA0.y;\n        const ux = nodeA1.x - ax0;\n        const uy = nodeA1.y - ay0;\n        const nodeB1 = nodeB0.faceSuccessor;\n        const bx0 = nodeB0.x;\n        const by0 = nodeB0.y;\n        const vx = nodeB1.x - bx0;\n        const vy = nodeB1.y - by0;\n        // cspell:word lineSegmentXYUVTransverseIntersectionUnbounded\n        if (SmallSystem.lineSegmentXYUVTransverseIntersectionUnbounded(ax0, ay0, ux, uy, bx0, by0, vx, vy, fractions)) {\n            pointA.x = ax0 + fractions.x * ux;\n            pointA.y = ay0 + fractions.x * uy;\n            pointB.x = bx0 + fractions.y * vx;\n            pointB.y = by0 + fractions.y * vy;\n            fractions.x = this.snapFractionToNode(pointA, fractions.x, nodeA0, 0.0);\n            fractions.x = this.snapFractionToNode(pointA, fractions.x, nodeA1, 1.0);\n            fractions.y = this.snapFractionToNode(pointB, fractions.y, nodeB0, 0.0);\n            fractions.y = this.snapFractionToNode(pointB, fractions.y, nodeB1, 1.0);\n            return Geometry.isIn01(fractions.x) && Geometry.isIn01(fractions.y);\n        }\n        return false;\n    }\n    /**\n     * Split edges at intersections.\n     * * This is a large operation.\n     * @param graph\n     */\n    static splitIntersectingEdges(graph) {\n        const data = new GraphSplitData();\n        const sweepHeap = this.buildVerticalSweepPriorityQueue(graph);\n        let nodeA0, nodeB1;\n        const smallFraction = 1.0e-8;\n        const largeFraction = 1.0 - smallFraction;\n        let i;\n        const fractions = Vector2d.create();\n        const pointA = Point2d.create();\n        const pointB = Point2d.create();\n        let nodeB0;\n        const popTolerance = Geometry.smallMetricDistance;\n        while (undefined !== (nodeA0 = sweepHeap.priorityQueue.pop())) {\n            data.numUpEdge++;\n            const n0 = sweepHeap.activeEdges.length;\n            sweepHeap.removeArrayMembersWithY1Below(nodeA0.y - popTolerance);\n            data.numPopOut += n0 - sweepHeap.activeEdges.length;\n            for (i = 0; i < sweepHeap.activeEdges.length; i++) {\n                nodeB0 = sweepHeap.activeEdges[i];\n                nodeB1 = nodeB0.faceSuccessor;\n                // const nodeB1 = nodeB0.faceSuccessor;\n                if (Geometry.isSameCoordinateXY(nodeA0.x, nodeA0.y, nodeB0.x, nodeB0.y)) {\n                    data.numA0B0++;\n                }\n                else if (Geometry.isSameCoordinateXY(nodeB1.x, nodeB1.y, nodeA0.x, nodeA0.y)) {\n                    data.numA0B1++;\n                }\n                else {\n                    data.numIntersectionTest++;\n                    if (this.computeIntersectionFractionsOnEdges(nodeA0, nodeB0, fractions, pointA, pointB)) {\n                        if (fractions.x > smallFraction && fractions.x < largeFraction) {\n                            const nodeC0 = graph.splitEdgeAtFraction(nodeA0, fractions.x);\n                            sweepHeap.priorityQueue.push(nodeC0); // The upper portion will be reviewed as a nodeA0 later !!!\n                            data.numSplit++;\n                        }\n                        if (fractions.y > smallFraction && fractions.y < largeFraction) {\n                            const nodeD0 = graph.splitEdgeAtFraction(nodeB0, fractions.y);\n                            sweepHeap.priorityQueue.push(nodeD0); // The upper portion will be reviewed as a nodeA0 later !!!\n                            data.numSplit++;\n                        }\n                        // existing nodeA0 and its shortened edge remain for further intersections\n                    }\n                }\n            }\n            sweepHeap.activeEdges.push(nodeA0);\n        }\n        return data;\n    }\n    /**\n     * Returns a graph structure formed from the given LineSegment array\n     *\n     * *  Find all intersections among segments, and split them if necessary\n     * *  Record endpoints of every segment in the form X, Y, Theta; This information is stored as a new node and sorted to match up\n     *      vertices.\n     * *  For vertices that match up, pinch the nodes to create vertex loops, which in closed objects, will also eventually form face\n     *      loops\n     */\n    static formGraphFromSegments(lineSegments) {\n        // Structure of an index of the array: { xyTheta: Point3d, node: Node }\n        const graph = new HalfEdgeGraph();\n        HalfEdgeGraphOps.segmentArrayToGraphEdges(lineSegments, graph, HalfEdgeMask.BOUNDARY_EDGE);\n        this.splitIntersectingEdges(graph);\n        this.clusterAndMergeXYTheta(graph);\n        return graph;\n    }\n    /**\n     * * Input is random linestrings, not necessarily loops\n     * * Graph gets full splitEdges, regularize, and triangulate.\n     * @returns triangulated graph, or undefined if bad data.\n     */\n    static formGraphFromChains(chains, regularize = true, mask = HalfEdgeMask.PRIMARY_EDGE) {\n        if (chains.length < 1)\n            return undefined;\n        const graph = new HalfEdgeGraph();\n        const chainSeeds = Triangulator.directCreateChainsFromCoordinates(graph, chains);\n        for (const seed of chainSeeds)\n            seed.setMaskAroundFace(mask);\n        this.splitIntersectingEdges(graph);\n        this.clusterAndMergeXYTheta(graph);\n        if (regularize) {\n            const context = new RegularizationContext(graph);\n            context.regularizeGraph(true, true);\n        }\n        return graph;\n    }\n}\n//# sourceMappingURL=Merging.js.map",
      "start": 1693508124337,
      "end": 1693508124429,
      "sourcemaps": null
    }
  ]
}
