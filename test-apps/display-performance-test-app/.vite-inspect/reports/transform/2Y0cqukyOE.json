{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tile/ImdlReader.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tiles\n */\nimport { ByteStream } from \"@itwin/core-bentley\";\nimport { Point3d, Transform } from \"@itwin/core-geometry\";\nimport { BatchType, decodeTileContentDescription, TileReadError, TileReadStatus, } from \"@itwin/core-common\";\nimport { IModelApp } from \"../IModelApp\";\nimport { GraphicBranch } from \"../render/GraphicBranch\";\nimport { convertFeatureTable, parseImdlDocument } from \"../common/imdl/ParseImdlDocument\";\nimport { decodeImdlGraphics } from \"./internal\";\n/** Convert the byte array returned by [[TileAdmin.requestElementGraphics]] into a [[RenderGraphic]].\n * @param bytes The binary graphics data obtained from `requestElementGraphics`.\n * @param iModel The iModel with which the graphics are associated.\n * @param modelId The Id of the [[GeometricModelState]] with which the graphics are associated. Can be an invalid Id.\n * @param is3d True if the graphics are 3d.\n * @param options Options customizing how [Feature]($common)s within the graphic can be resymbolized; or false if you don't want to produce a batch.\n * @public\n * @extensions\n */\nexport async function readElementGraphics(bytes, iModel, modelId, is3d, options) {\n    const stream = ByteStream.fromUint8Array(bytes);\n    const reader = ImdlReader.create({\n        stream, iModel, modelId, is3d, options,\n        system: IModelApp.renderSystem,\n    });\n    const result = await reader.read();\n    return result.graphic;\n}\n/** @internal */\nexport async function readImdlContent(args) {\n    const isCanceled = args.isCanceled ?? (() => false);\n    let content;\n    try {\n        content = decodeTileContentDescription({\n            stream: args.stream,\n            sizeMultiplier: args.sizeMultiplier,\n            is2d: !args.is3d,\n            options: IModelApp.tileAdmin,\n            isVolumeClassifier: BatchType.VolumeClassifier === args.type,\n            isLeaf: args.isLeaf,\n        });\n    }\n    catch (e) {\n        if (e instanceof TileReadError)\n            return { isLeaf: true, readStatus: e.errorNumber };\n        else\n            throw e;\n    }\n    args.stream.reset();\n    const parseOpts = {\n        data: args.stream.readBytes(0, args.stream.length),\n        batchModelId: args.modelId,\n        is3d: args.is3d,\n        maxVertexTableSize: IModelApp.renderSystem.maxTextureSize,\n        omitEdges: false === args.loadEdges,\n        createUntransformedRootNode: args.containsTransformNodes,\n    };\n    const document = args.parseDocument ? (await args.parseDocument(parseOpts)) : parseImdlDocument({ ...parseOpts, timeline: args.timeline });\n    if (isCanceled())\n        return { isLeaf: true, readStatus: TileReadStatus.Canceled };\n    else if (typeof document === \"number\")\n        return { isLeaf: true, readStatus: document };\n    let graphic = await decodeImdlGraphics({\n        system: args.system,\n        iModel: args.iModel,\n        document,\n        isCanceled: args.isCanceled,\n    });\n    if (isCanceled())\n        return { isLeaf: true, readStatus: TileReadStatus.Canceled };\n    if (graphic && false !== args.options) {\n        const featureTable = convertFeatureTable(document.featureTable, args.modelId);\n        graphic = args.system.createBatch(graphic, featureTable, content.contentRange, args.options);\n    }\n    if (graphic && document.rtcCenter) {\n        const rtcBranch = new GraphicBranch(true);\n        rtcBranch.add(graphic);\n        graphic = args.system.createBranch(rtcBranch, Transform.createTranslation(Point3d.fromJSON(document.rtcCenter)));\n    }\n    return {\n        readStatus: TileReadStatus.Success,\n        isLeaf: content.isLeaf,\n        sizeMultiplier: content.sizeMultiplier,\n        contentRange: content.contentRange.isNull ? undefined : content.contentRange,\n        graphic,\n        emptySubRangeMask: content.emptySubRangeMask,\n    };\n}\n/** @internal */\nexport var ImdlReader;\n(function (ImdlReader) {\n    function create(args) {\n        return {\n            read: async () => readImdlContent(args),\n        };\n    }\n    ImdlReader.create = create;\n})(ImdlReader || (ImdlReader = {}));\n//# sourceMappingURL=ImdlReader.js.map",
      "start": 1693508121622,
      "end": 1693508121793,
      "sourcemaps": null
    }
  ]
}
