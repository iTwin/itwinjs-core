{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/EDL.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { assert, dispose } from \"@itwin/core-bentley\";\nimport { EDLCalcBasicGeometry, EDLCalcFullGeometry, EDLFilterGeometry, EDLMixGeometry } from \"./CachedGeometry\";\nimport { FrameBuffer } from \"./FrameBuffer\";\nimport { GL } from \"./GL\";\nimport { RenderState } from \"./RenderState\";\nimport { collectGeometryStatistics, collectTextureStatistics } from \"./SceneCompositor\";\nimport { getDrawParams } from \"./ScratchDrawParams\";\nimport { System } from \"./System\";\nimport { TextureHandle } from \"./Texture\";\nclass Bundle {\n    constructor(edlCalcTex1, edlCalcTex2, edlCalcTex4, edlFiltTex2, edlFiltTex4, edlCalcFbo1, edlCalcFbo2, edlCalcFbo4, edlFiltFbo2, edlFiltFbo4, edlCalcBasicGeom, edlCalcFullGeom, edlFiltGeom, edlMixGeom) {\n        this.edlCalcTex1 = edlCalcTex1;\n        this.edlCalcTex2 = edlCalcTex2;\n        this.edlCalcTex4 = edlCalcTex4;\n        this.edlFiltTex2 = edlFiltTex2;\n        this.edlFiltTex4 = edlFiltTex4;\n        this.edlCalcFbo1 = edlCalcFbo1;\n        this.edlCalcFbo2 = edlCalcFbo2;\n        this.edlCalcFbo4 = edlCalcFbo4;\n        this.edlFiltFbo2 = edlFiltFbo2;\n        this.edlFiltFbo4 = edlFiltFbo4;\n        this.edlCalcBasicGeom = edlCalcBasicGeom;\n        this.edlCalcFullGeom = edlCalcFullGeom;\n        this.edlFiltGeom = edlFiltGeom;\n        this.edlMixGeom = edlMixGeom;\n    }\n    static create(width, height) {\n        const edlCalcTex1 = TextureHandle.createForAttachment(width, height, GL.Texture.Format.Rgba, GL.Texture.DataType.UnsignedByte);\n        const edlCalcTex2 = TextureHandle.createForAttachment(width >> 1, height >> 1, GL.Texture.Format.Rgba, GL.Texture.DataType.UnsignedByte);\n        const edlCalcTex4 = TextureHandle.createForAttachment(width >> 2, height >> 2, GL.Texture.Format.Rgba, GL.Texture.DataType.UnsignedByte);\n        const edlFiltTex2 = TextureHandle.createForAttachment(width >> 1, height >> 1, GL.Texture.Format.Rgba, GL.Texture.DataType.UnsignedByte);\n        const edlFiltTex4 = TextureHandle.createForAttachment(width >> 2, height >> 2, GL.Texture.Format.Rgba, GL.Texture.DataType.UnsignedByte);\n        if (undefined === edlCalcTex1 || undefined === edlCalcTex2 || undefined === edlCalcTex4 || undefined === edlFiltTex2 || undefined === edlFiltTex4) {\n            dispose(edlCalcTex1);\n            dispose(edlCalcTex2);\n            dispose(edlCalcTex4);\n            dispose(edlFiltTex2);\n            dispose(edlFiltTex4);\n            return undefined;\n        }\n        const edlCalcFbo1 = FrameBuffer.create([edlCalcTex1]);\n        const edlCalcFbo2 = FrameBuffer.create([edlCalcTex2]);\n        const edlCalcFbo4 = FrameBuffer.create([edlCalcTex4]);\n        const edlFiltFbo2 = FrameBuffer.create([edlFiltTex2]);\n        const edlFiltFbo4 = FrameBuffer.create([edlFiltTex4]);\n        if (undefined === edlCalcFbo1 || undefined === edlCalcFbo2 || undefined === edlCalcFbo4 || undefined === edlFiltFbo2 || undefined === edlFiltFbo4) {\n            dispose(edlCalcFbo1);\n            dispose(edlCalcFbo2);\n            dispose(edlCalcFbo4);\n            dispose(edlFiltFbo2);\n            dispose(edlFiltFbo4);\n            return undefined;\n        }\n        return new Bundle(edlCalcTex1, edlCalcTex2, edlCalcTex4, edlFiltTex2, edlFiltTex4, edlCalcFbo1, edlCalcFbo2, edlCalcFbo4, edlFiltFbo2, edlFiltFbo4);\n    }\n    get isDisposed() {\n        return undefined === this.edlCalcTex1\n            && undefined === this.edlCalcTex2\n            && undefined === this.edlCalcTex4\n            && undefined === this.edlFiltTex2\n            && undefined === this.edlFiltTex4\n            && undefined === this.edlCalcFbo1\n            && undefined === this.edlCalcFbo2\n            && undefined === this.edlCalcFbo4\n            && undefined === this.edlFiltFbo2\n            && undefined === this.edlFiltFbo4\n            && undefined === this.edlCalcBasicGeom\n            && undefined === this.edlCalcFullGeom?.[0]\n            && undefined === this.edlCalcFullGeom?.[1]\n            && undefined === this.edlCalcFullGeom?.[2]\n            && undefined === this.edlCalcFullGeom\n            && undefined === this.edlFiltGeom?.[0]\n            && undefined === this.edlFiltGeom?.[1]\n            && undefined === this.edlFiltGeom\n            && undefined === this.edlMixGeom;\n    }\n    dispose() {\n        this.edlCalcTex1 = dispose(this.edlCalcTex1);\n        this.edlCalcTex2 = dispose(this.edlCalcTex2);\n        this.edlCalcTex4 = dispose(this.edlCalcTex4);\n        this.edlFiltTex2 = dispose(this.edlFiltTex2);\n        this.edlFiltTex4 = dispose(this.edlFiltTex4);\n        this.edlCalcFbo1 = dispose(this.edlCalcFbo1);\n        this.edlCalcFbo2 = dispose(this.edlCalcFbo2);\n        this.edlCalcFbo4 = dispose(this.edlCalcFbo4);\n        this.edlFiltFbo2 = dispose(this.edlFiltFbo2);\n        this.edlFiltFbo4 = dispose(this.edlFiltFbo4);\n        this.edlCalcBasicGeom = dispose(this.edlCalcBasicGeom);\n        if (this.edlCalcFullGeom) {\n            this.edlCalcFullGeom[0] = dispose(this.edlCalcFullGeom?.[0]);\n            this.edlCalcFullGeom[1] = dispose(this.edlCalcFullGeom?.[1]);\n            this.edlCalcFullGeom[2] = dispose(this.edlCalcFullGeom?.[2]);\n            this.edlCalcFullGeom = undefined;\n        }\n        if (this.edlFiltGeom) {\n            this.edlFiltGeom[0] = dispose(this.edlFiltGeom?.[0]);\n            this.edlFiltGeom[1] = dispose(this.edlFiltGeom?.[1]);\n            this.edlFiltGeom = undefined;\n        }\n        this.edlMixGeom = dispose(this.edlMixGeom);\n    }\n}\n/** @internal */\nexport var EDLMode;\n(function (EDLMode) {\n    EDLMode[EDLMode[\"Off\"] = 0] = \"Off\";\n    EDLMode[EDLMode[\"On\"] = 1] = \"On\";\n    EDLMode[EDLMode[\"Full\"] = 2] = \"Full\";\n})(EDLMode || (EDLMode = {}));\nexport class EyeDomeLighting {\n    getBundle() {\n        if (undefined === this._bundle) {\n            this._bundle = Bundle.create(this._width, this._height);\n            assert(undefined !== this._bundle);\n        }\n        return this._bundle;\n    }\n    constructor(target) {\n        this._target = target;\n        this._width = target.viewRect.width;\n        this._height = target.viewRect.height;\n    }\n    init(width, height, depth) {\n        this._width = width;\n        this._height = height;\n        this._depth = depth;\n        // don't create buffers until we know we will use them (first draw)\n        return true;\n    }\n    collectStatistics(stats) {\n        const bundle = this._bundle;\n        if (undefined !== bundle) {\n            collectTextureStatistics(bundle.edlCalcTex1, stats);\n            collectTextureStatistics(bundle.edlCalcTex2, stats);\n            collectTextureStatistics(bundle.edlCalcTex4, stats);\n            collectTextureStatistics(bundle.edlFiltTex2, stats);\n            collectTextureStatistics(bundle.edlFiltTex4, stats);\n            collectGeometryStatistics(bundle.edlCalcBasicGeom, stats);\n            collectGeometryStatistics(bundle.edlCalcFullGeom?.[0], stats);\n            collectGeometryStatistics(bundle.edlCalcFullGeom?.[1], stats);\n            collectGeometryStatistics(bundle.edlCalcFullGeom?.[2], stats);\n            collectGeometryStatistics(bundle.edlFiltGeom?.[0], stats);\n            collectGeometryStatistics(bundle.edlFiltGeom?.[1], stats);\n            collectGeometryStatistics(bundle.edlMixGeom, stats);\n        }\n    }\n    get isDisposed() { return undefined === this._bundle && undefined === this._edlFinalFbo; }\n    dispose() {\n        this._bundle = dispose(this._bundle);\n        this._edlFinalFbo = dispose(this._edlFinalFbo);\n    }\n    reset() {\n        this.dispose();\n    }\n    /** calculate EyeDomeLighting at specified quality using screen space shaders\n     * returns true if succeeds\n     */\n    draw(edlParams) {\n        if (undefined === edlParams.inputTex || undefined === this._depth || undefined === edlParams.curFbo)\n            return false;\n        const bundle = this.getBundle();\n        if (undefined === bundle)\n            return false;\n        // NB: have to test and create MS buffer as well if useMsBuffers, not outputting to depth\n        const finalBufs = edlParams.curFbo.getColorTargets(edlParams.useMsBuffers, 0);\n        if (undefined === this._edlFinalFbo || this._edlFinalBufs?.tex !== finalBufs.tex ||\n            (edlParams.useMsBuffers && this._edlFinalBufs?.msBuf !== finalBufs.msBuf)) {\n            this._edlFinalFbo = dispose(this._edlFinalFbo);\n            this._edlFinalBufs = finalBufs;\n            const filters = [GL.MultiSampling.Filter.Linear];\n            this._edlFinalFbo = FrameBuffer.create([this._edlFinalBufs.tex], undefined, edlParams.useMsBuffers && this._edlFinalBufs.msBuf ? [this._edlFinalBufs.msBuf] : undefined, filters, undefined);\n            if (undefined === this._edlFinalFbo)\n                return false;\n        }\n        const fbStack = System.instance.frameBufferStack;\n        const useMsBuffers = edlParams.useMsBuffers;\n        System.instance.applyRenderState(RenderState.defaults);\n        // ###TODO: should radius be (optionally?) voxel based instead of pixel here?\n        if (edlParams.edlMode === EDLMode.On) {\n            // draw using single pass version (still 8 samples, full size)\n            fbStack.execute(this._edlFinalFbo, true, useMsBuffers, () => {\n                if (bundle.edlCalcBasicGeom === undefined) {\n                    const ct1 = edlParams.inputTex;\n                    const ctd = this._depth.getHandle();\n                    bundle.edlCalcBasicGeom = EDLCalcBasicGeometry.createGeometry(ct1.getHandle(), ctd, ct1.width, ct1.height);\n                }\n                const params = getDrawParams(this._target, bundle.edlCalcBasicGeom);\n                this._target.techniques.draw(params);\n            });\n        }\n        else { // EDLMode.Full\n            // draw with full method based on original paper using full, 1/2, and 1/4 sizes\n            const edlCalc2FB = [bundle.edlCalcFbo1, bundle.edlCalcFbo2, bundle.edlCalcFbo4];\n            if (bundle.edlCalcFullGeom === undefined) {\n                const ct1 = edlParams.inputTex;\n                const ct2 = bundle.edlCalcTex2;\n                const ct4 = bundle.edlCalcTex4;\n                const ctd = this._depth.getHandle();\n                bundle.edlCalcFullGeom = [EDLCalcFullGeometry.createGeometry(ct1.getHandle(), ctd, 1, ct1.width, ct1.height),\n                    EDLCalcFullGeometry.createGeometry(ct1.getHandle(), ctd, 2, ct2.width, ct2.height),\n                    EDLCalcFullGeometry.createGeometry(ct1.getHandle(), ctd, 4, ct4.width, ct4.height)];\n            }\n            const edlFiltFbos = [bundle.edlFiltFbo2, bundle.edlFiltFbo4];\n            if (bundle.edlFiltGeom === undefined) {\n                const ft2 = bundle.edlCalcTex2;\n                const ft4 = bundle.edlCalcTex4;\n                const ftd = this._depth.getHandle();\n                bundle.edlFiltGeom = [EDLFilterGeometry.createGeometry(ft2.getHandle(), ftd, 2, ft2.width, ft2.height),\n                    EDLFilterGeometry.createGeometry(ft4.getHandle(), ftd, 4, ft4.width, ft4.height)];\n            }\n            const gl = System.instance.context;\n            // Loop through the 3 sizes calculating an edl buffer, and if not first size, then optionally filtering those\n            for (let i = 0; i < 3; ++i) {\n                fbStack.execute(edlCalc2FB[i], true, false, () => {\n                    const colTex = edlCalc2FB[i].getColor(0);\n                    gl.viewport(0, 0, colTex.width, colTex.height); // have to set viewport to current texture size\n                    const params = getDrawParams(this._target, bundle.edlCalcFullGeom[i]);\n                    this._target.techniques.draw(params);\n                });\n                if (edlParams.edlFilter && i > 0) {\n                    fbStack.execute(edlFiltFbos[i - 1], true, false, () => {\n                        const params = getDrawParams(this._target, bundle.edlFiltGeom[i - 1]);\n                        this._target.techniques.draw(params);\n                    });\n                }\n            }\n            gl.viewport(0, 0, this._width, this._height); // Restore viewport\n            // Now combine the 3 results and output\n            const tex1 = bundle.edlCalcTex1.getHandle();\n            const tex2 = edlParams.edlFilter ? bundle.edlFiltTex2.getHandle() : bundle.edlCalcTex2.getHandle();\n            const tex4 = edlParams.edlFilter ? bundle.edlFiltTex4.getHandle() : bundle.edlCalcTex4.getHandle();\n            fbStack.execute(this._edlFinalFbo, true, useMsBuffers, () => {\n                if (bundle.edlMixGeom === undefined) {\n                    bundle.edlMixGeom = EDLMixGeometry.createGeometry(tex1, tex2, tex4);\n                }\n                else {\n                    if (bundle.edlMixGeom.colorTexture1 !== tex1 || bundle.edlMixGeom.colorTexture2 !== tex2 || bundle.edlMixGeom.colorTexture4 !== tex4) {\n                        dispose(bundle.edlMixGeom);\n                        bundle.edlMixGeom = EDLMixGeometry.createGeometry(tex1, tex2, tex4);\n                    }\n                }\n                const params = getDrawParams(this._target, bundle.edlMixGeom);\n                this._target.techniques.draw(params);\n            });\n        }\n        return true;\n    }\n}\n//# sourceMappingURL=EDL.js.map",
      "start": 1693508123760,
      "end": 1693508123992,
      "sourcemaps": null
    }
  ]
}
