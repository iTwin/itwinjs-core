{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/numerics/UsageSums.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\nimport { Geometry } from \"../Geometry\";\nimport { Range1d } from \"../geometry3d/Range\";\n/**\n * Accumulator for computing average and standard deviations.\n * * Usual usage pattern:\n *   * create with `sums = new UsageSums ()`\n *   * announce data values with any combination of\n *      * `sums.accumulate (x: number)`\n *      * `sums.accumulateArray (data: numberArray)`\n *   * query properties at any time:\n *      * `sums.mean`\n *      * `sums.count`\n *      * `sums.meanSquare`\n *      * `sums.standardDeviation`\n *      * `sums.minMax`\n * * Optional `origin`\n *   * if `origin` is nonzero:\n *      * when a value `x` is announced to the `accumulate(x)` method, the value used for sums is `(x-origin)`\n *   * All queries (mean, minMax, meanSquare, standardDeviation) return values relative to the origin.\n *   * The origin can be reset in two different ways:\n *     * `setOrigin(a)` sets the saved origin value to `a`, but leaves sums unchanged.\n *       * This affects subsequence how sums are changed by `announce(x)`\n *     * `shiftOriginAndSums` sets the origin (like `sums.setOrigin (a))` and also corrects all sums and minMax so they appear that the new origin had been in effect during all prior `accumulate(x)` calls.\n * @internal\n */\nexport class UsageSums {\n    /** Constructor:\n     * * All sums 0\n     * * min and max set to extreme values.\n     * * origin assigned.\n     */\n    constructor(origin = 0) {\n        this._minMax = Range1d.createNull();\n        this._count = this._sumX = this._sumXX = 0;\n        this._origin = origin;\n    }\n    /** Return the number of samples seen */\n    get count() { return this._count; }\n    /** return the mean of all samples.\n     * * Return 0 if no samples\n     */\n    get mean() { return this._count > 0 ? this._sumX / this._count : 0.0; }\n    /** Return the mean of  squared samples.\n     * * Return 0 if no samples.\n     */\n    get meanSquare() { return this._count > 0 ? this._sumXX / this._count : 0.0; }\n    get minMax() { return this._minMax.clone(); }\n    /**\n     * Return the \"biased standard deviation\" (https://en.wikipedia.org/wiki/Standard_deviation)\n     * * This is zero if count is zero.\n     */\n    get standardDeviation() {\n        if (this._count < 1)\n            return 0.0;\n        const xBar = this.mean;\n        const sumXX = this._sumXX;\n        const sumX = this._sumX;\n        return Math.sqrt((sumXX - 2 * xBar * sumX + this._count * xBar * xBar) / this._count);\n    }\n    /** Reinitialize all sums.\n     * * origin is unchanged\n     */\n    clearSums() {\n        this._count = this._sumX = this._sumXX = 0;\n        this._minMax.setNull();\n    }\n    /**\n     * return the origin being used in the `accumulate(x)` method.\n     */\n    get origin() { return this._origin; }\n    /**\n     * Reset the origin.\n     * * Former sums are unchanged !!\n     * @param origin new origin\n     */\n    setOrigin(origin) {\n        this._origin = origin;\n    }\n    /**\n     * * reset the origin\n     * * adjust all sums to what they would be if the new origin had been in effect.\n     */\n    shiftOriginAndSums(origin) {\n        const delta = origin - this._origin;\n        this._origin = origin;\n        // adjust sumXX first to get old sumX value before it is modified.\n        this._sumXX = this._sumXX - 2 * delta * this._sumX + this._count * delta * delta;\n        this._sumX = this._sumX - this._count * delta;\n        this._minMax.cloneTranslated(-delta, this._minMax);\n    }\n    /** Accumulate a single value */\n    accumulate(x) {\n        x = x - this._origin;\n        this._count += 1;\n        this._sumX += x;\n        this._sumXX += x * x;\n        this._minMax.extendX(x);\n    }\n    /** Accumulate a single value */\n    accumulateArray(xArray) {\n        for (const x of xArray)\n            this.accumulate(x);\n    }\n    /** Clone all content (origin, count, sums, minMax) */\n    clone(result) {\n        if (!result)\n            result = new UsageSums();\n        this._minMax.clone(result._minMax);\n        result._count = this._count;\n        result._origin = this._origin;\n        result._sumX = this._sumX;\n        result._sumXX = this._sumXX;\n        return result;\n    }\n    /** Compare all content. */\n    isAlmostEqual(other) {\n        return Geometry.isAlmostEqualNumber(this._sumX, other._sumX)\n            && Geometry.isAlmostEqualNumber(this._sumXX, other._sumXX)\n            && Geometry.isAlmostEqualNumber(this._origin, other._origin)\n            && this._count === other._count\n            && this._minMax.isAlmostEqual(other._minMax);\n    }\n}\n//# sourceMappingURL=UsageSums.js.map",
      "start": 1693508124988,
      "end": 1693508125064,
      "sourcemaps": null
    }
  ]
}
