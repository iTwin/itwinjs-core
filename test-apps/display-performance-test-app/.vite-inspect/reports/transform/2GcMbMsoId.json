{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/extension/ExtensionAdmin.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Extensions\n */\nimport { Logger } from \"@itwin/core-bentley\";\nimport { FrontendLoggerCategory } from \"../common/FrontendLoggerCategory\";\n/** The Extension Admin controls the list of currently loaded Extensions.\n *\n * @alpha\n */\nexport class ExtensionAdmin {\n    constructor() {\n        /** Defines the set of extensions that are currently known and can be invoked during activation events.  */\n        this._extensions = new Map();\n        /** Fired when an Extension has been added or removed.\n         * @internal\n         */\n        this.onStartup = async () => {\n            await this.activateExtensionEvents(\"onStartup\");\n        };\n        this._hosts = [];\n    }\n    /**\n     * Adds an extension.\n     * The manifest will be fetched and the extension will be activated on an activation event.\n     * @param provider\n     * @alpha\n     */\n    async addExtension(provider) {\n        if (provider.hostname) {\n            const hostName = provider.hostname;\n            if (this._hosts.length > 0 && this._hosts.indexOf(hostName) < 0) {\n                throw new Error(`Error loading extension: ${hostName} was not registered.`);\n            }\n        }\n        try {\n            const manifest = await provider.getManifest();\n            this._extensions.set(manifest.name, {\n                manifest,\n                provider,\n            });\n            // TODO - temporary fix to execute the missed startup event\n            if (manifest.activationEvents.includes(\"onStartup\"))\n                provider.execute(); // eslint-disable-line @typescript-eslint/no-floating-promises\n        }\n        catch (e) {\n            throw new Error(`Failed to get extension manifest ${provider.hostname ? `at ${provider.hostname}` : \"\"}: ${e}`);\n        }\n    }\n    /**\n     * Adds a list of extensions\n     * @param providers\n     * @alpha\n     */\n    async addExtensions(providers) {\n        return Promise.all(providers.map(async (provider) => this.addExtension(provider)));\n    }\n    /**\n     * Registers a hostname for an extension.\n     * Once a hostname has been registered, only remote extensions from registered hosts are permitted to be added.\n     * @param hostUrl (string) Accepts both URLs and hostnames (e.g., http://localhost:3000, yourdomain.com, https://www.yourdomain.com, etc.).\n     */\n    registerHost(hostUrl) {\n        const hostname = this.getHostName(hostUrl);\n        if (this._hosts.indexOf(hostname) < 0) {\n            this._hosts.push(hostname);\n        }\n    }\n    /** Returns the hostname of an input string. Throws an error if input is not a valid hostname (or URL). */\n    getHostName(inputUrl) {\n        // inputs without a protocol (e.g., http://) will throw an error in URL constructor\n        const inputWithProtocol = /(http|https):\\/\\//.test(inputUrl) ?\n            inputUrl :\n            `https://${inputUrl}`;\n        try {\n            const hostname = new URL(inputWithProtocol).hostname.replace(\"www.\", \"\");\n            return hostname;\n        }\n        catch (e) {\n            if (e instanceof TypeError) {\n                throw new Error(\"Argument hostUrl should be a valid URL or hostname (i.e. http://localhost:3000, yourdomain.com, etc.).\");\n            }\n            throw e;\n        }\n    }\n    /** Loops over all enabled Extensions and triggers each one if the provided event is defined. */\n    async activateExtensionEvents(event) {\n        for (const extension of this._extensions.values()) {\n            if (!extension.manifest.activationEvents)\n                continue;\n            for (const activationEvent of extension.manifest.activationEvents) {\n                if (activationEvent === event) {\n                    this._execute(extension); // eslint-disable-line @typescript-eslint/no-floating-promises\n                }\n            }\n        }\n    }\n    /** Executes the extension. Catches and logs any errors (so that an extension will not crash the main application). */\n    async _execute(extension) {\n        try {\n            await extension.provider.execute();\n        }\n        catch (e) {\n            Logger.logError(FrontendLoggerCategory.Extensions, `Error executing extension ${extension.manifest.name}: ${e}`);\n        }\n    }\n}\n//# sourceMappingURL=ExtensionAdmin.js.map",
      "start": 1693508123480,
      "end": 1693508123556,
      "sourcemaps": null
    }
  ]
}
