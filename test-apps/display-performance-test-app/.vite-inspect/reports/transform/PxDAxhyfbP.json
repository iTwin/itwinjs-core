{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/geometry3d/ReusableObjectCache.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\nimport { GrowableXYZArray } from \"./GrowableXYZArray\";\n/** @packageDocumentation\n * @module ArraysAndInterfaces\n */\n/**\n * abstract class managing an array of objects of type T, available for reuse by trusted callers.\n * * Derived class must implement these methods:\n *   * `createForCache()` -- create a new, ready-to-use object\n *   * `clearForCache (data: T)` -- tidy up `data` so it can be reused.\n * @internal\n */\nexport class ReusableObjectCache {\n    /**\n     * create a new cache for objects of type T\n     */\n    constructor() {\n        this._cachedObjects = [];\n        this.numDrop = 0;\n        this.numCreate = 0;\n        this.numReuse = 0;\n    }\n    /** Present `data` for storage in the cache, and hence reuse by any subsequent `grabFromCache`\n     *   * `data` will be sent to `clearForCache`.\n     *   * caller should never refer to this instance again.\n     */\n    dropToCache(data) {\n        if (data) {\n            this.numDrop++;\n            this.clearForCache(data);\n            this._cachedObjects.push(data);\n        }\n    }\n    /**\n     * grab an object from the cache.\n     *  * The returned object becomes property of the caller.\n     *  * That is, the cache does not remember it for any further management\n     * @param data\n     */\n    grabFromCache() {\n        let data = this._cachedObjects.pop();\n        if (data === undefined) {\n            data = this.createForCache();\n            this.numCreate++;\n        }\n        else {\n            this.numReuse++;\n        }\n        return data;\n    }\n    /** Drop all entries of data[] to the cache.\n     * @param data on input, the data to drop. on output, data is an empty array.\n     */\n    dropAllToCache(data) {\n        while (data.length > 0) {\n            this.dropToCache(data.pop());\n        }\n    }\n}\n/**\n * Cache of GrowableXYZArray.\n * Intended for use by (for instance) clipping methods that can be structured to have disciplined reuse of a small number of arrays for a large number of steps.\n * @internal\n */\nexport class GrowableXYZArrayCache extends ReusableObjectCache {\n    clearForCache(data) { data.length = 0; }\n    createForCache() { return new GrowableXYZArray(10); }\n    constructor() { super(); }\n    /**\n     * Grab an array from the cache and immediately fill from a source\n     * @param source\n     */\n    grabAndFill(source) {\n        const dest = this.grabFromCache();\n        dest.pushFrom(source);\n        return dest;\n    }\n}\n//# sourceMappingURL=ReusableObjectCache.js.map",
      "start": 1693508124098,
      "end": 1693508124168,
      "sourcemaps": null
    }
  ]
}
