{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/geometry3d/Ellipsoid.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module CartesianGeometry\n */\nimport { CurveAndSurfaceLocationDetail, UVSurfaceLocationDetail } from \"../bspline/SurfaceLocationDetail\";\nimport { Arc3d } from \"../curve/Arc3d\";\nimport { CurveLocationDetail } from \"../curve/CurveLocationDetail\";\nimport { AxisOrder, Geometry } from \"../Geometry\";\nimport { Point4d } from \"../geometry4d/Point4d\";\nimport { Order3Bezier } from \"../numerics/BezierPolynomials\";\nimport { Newton2dUnboundedWithDerivative, NewtonEvaluatorRRtoRRD } from \"../numerics/Newton\";\nimport { SineCosinePolynomial, SphereImplicit, TrigPolynomial } from \"../numerics/Polynomials\";\nimport { TriDiagonalSystem } from \"../numerics/TriDiagonalSystem\";\nimport { Angle } from \"./Angle\";\nimport { AngleSweep } from \"./AngleSweep\";\nimport { LongitudeLatitudeNumber } from \"./LongitudeLatitudeAltitude\";\nimport { Matrix3d } from \"./Matrix3d\";\nimport { Plane3dByOriginAndUnitNormal } from \"./Plane3dByOriginAndUnitNormal\";\nimport { Plane3dByOriginAndVectors } from \"./Plane3dByOriginAndVectors\";\nimport { Point3d, Vector3d } from \"./Point3dVector3d\";\nimport { Range1d, Range3d } from \"./Range\";\nimport { Ray3d } from \"./Ray3d\";\nimport { Transform } from \"./Transform\";\n/**\n * For one component (x,y, or z) on the sphere\n *    f(theta,phi) = c + (u * cos(theta) + v * sin(theta)) * cos(phi) + w * sin(phi)\n *\n * For the equator circle, phi=0, cos(phi) = 1, sin(phi)=0\n *           f = u * cos(theta) + v * sin(theta).\n * with derivative\n *          df / dTheta = = u * sin(theta) + v * cos(theta)\n * whose zero is            tan(theta) = v/u\n * (and that has two solutions 180 degrees apart)\n * Then with that theta let      A = u * cos(theta) + v * sin(theta)\n *           f = A * cos(phi) + w * sin(phi)\n *          df/dPhi = - A * sin(phi) + w * cos(phi)\n *            tan(phi) = w / A\n * @internal\n */\nclass EllipsoidComponentExtrema {\n    constructor(c, u, v, w, axisIndex) {\n        this.c = c;\n        this.u = u;\n        this.v = v;\n        this.w = w;\n        this.axisIndex = axisIndex;\n        this.theta0Radians = Math.atan2(v, u);\n        this.cosTheta0 = Math.cos(this.theta0Radians);\n        this.sinTheta0 = Math.sin(this.theta0Radians);\n        const A0 = u * this.cosTheta0 + v * this.sinTheta0;\n        this.phi0Radians = Math.atan2(w, A0);\n        this.cosPhi0 = Math.cos(this.phi0Radians);\n        this.sinPhi0 = Math.sin(this.phi0Radians);\n        this._axisRange = Range1d.createNull();\n        this._trigForm = new SineCosinePolynomial(0, 0, 0);\n    }\n    /**\n     * Create a component object with coefficients from a row of a `Transform`.\n     * @param transform source transform.\n     * @param axisIndex row index within the transform.\n     */\n    static createTransformRow(transform, axisIndex) {\n        const matrix = transform.matrix;\n        return new EllipsoidComponentExtrema(transform.origin.at(axisIndex), matrix.at(axisIndex, 0), matrix.at(axisIndex, 1), matrix.at(axisIndex, 2), axisIndex);\n    }\n    extendRangeForSmoothSurfacePoints(range, theta0Radians, theta1Radians, phi0Radians, phi1Radians) {\n        const delta = (this.u * this.cosTheta0 + this.v * this.sinTheta0) * this.cosPhi0 + this.w * this.sinPhi0;\n        if (AngleSweep.isRadiansInStartEnd(this.theta0Radians, theta0Radians, theta1Radians)\n            && AngleSweep.isRadiansInStartEnd(this.phi0Radians, phi0Radians, phi1Radians, false)) {\n            range.extendSingleAxis(this.c + delta, this.axisIndex);\n        }\n        const thetaRadians = this.theta0Radians + Math.PI;\n        const phiRadians = -this.phi0Radians;\n        if (AngleSweep.isRadiansInStartEnd(thetaRadians, theta0Radians, theta1Radians)\n            && AngleSweep.isRadiansInStartEnd(phiRadians, phi0Radians, phi1Radians, false)) {\n            // cosTheta and sinTheta are both negated\n            // sinPhi is negated\n            // delta is negated\n            range.extendSingleAxis(this.c - delta, this.axisIndex);\n        }\n    }\n    /**\n     * Extend range to include extrema of a phi-bounded arc at constant theta (i.e. a polar circle)\n     * @param range range to extend\n     * @param thetaRadians theta for arc\n     * @param phi0Radians limit value on arc sweep\n     * @param phi1Radians limit value on arc sweep\n     */\n    extendRangeForConstantThetaArc(range, thetaRadians, phi0Radians, phi1Radians) {\n        const cosTheta = Math.cos(thetaRadians);\n        const sinTheta = Math.sin(thetaRadians);\n        this._trigForm.set(this.c, (this.u * cosTheta + this.v * sinTheta), this.w);\n        this._trigForm.rangeInStartEndRadians(phi0Radians, phi1Radians, this._axisRange);\n        range.extendSingleAxis(this._axisRange.low, this.axisIndex);\n        range.extendSingleAxis(this._axisRange.high, this.axisIndex);\n    }\n    /**\n     * Extend range to include extrema of a theta-bounded arc at constant phi (i.e. a circle parallel to the equator)\n     * @param range range to extend\n     * @param phiRadians phi for arc\n     * @param theta0Radians limit value on arc sweep\n     * @param theta1Radians limit value on arc sweep\n     */\n    extendRangeForConstantPhiArc(range, theta0Radians, theta1Radians, phiRadians) {\n        const cosPhi = Math.cos(phiRadians);\n        const sinPhi = Math.sin(phiRadians);\n        this._trigForm.set(this.c + this.w * sinPhi, this.u * cosPhi, this.v * cosPhi);\n        this._trigForm.rangeInStartEndRadians(theta0Radians, theta1Radians, this._axisRange);\n        range.extendSingleAxis(this._axisRange.low, this.axisIndex);\n        range.extendSingleAxis(this._axisRange.high, this.axisIndex);\n    }\n}\n/**\n * * An Ellipsoid is a (complete) unit sphere with an arbitrary (possibly skewed) `Transform` to 3d.\n * * The (unit) sphere parameterization with respect to longitude `theta` and latitude `phi` is\n *    * `u = cos(theta) * cos (phi)`\n *    * `v = sin(theta) * cos(phi)`\n *    * `w = sin(phi)`\n *  * The sphere (u,v,w) multiply the x,y,z columns of the Ellipsoid transform.\n * @public\n */\nexport class Ellipsoid {\n    constructor(transform) {\n        this._transform = transform;\n        this._unitVectorA = Vector3d.create();\n        this._unitVectorB = Vector3d.create();\n        this._workPointA = Point3d.create();\n        this._workPointB = Point3d.create();\n    }\n    /** Create with a clone (not capture) with given transform.\n     * * If transform is undefined, create a unit sphere.\n     */\n    static create(matrixOrTransform) {\n        if (matrixOrTransform instanceof Transform)\n            return new Ellipsoid(matrixOrTransform);\n        else if (matrixOrTransform instanceof Matrix3d)\n            return new Ellipsoid(Transform.createOriginAndMatrix(undefined, matrixOrTransform));\n        else\n            return new Ellipsoid(Transform.createIdentity());\n    }\n    /**\n     * Create a transform with given center and directions, applying the radii as multipliers for the respective columns of the axes.\n     * @param center center of ellipsoid\n     * @param axes x,y,z directions are columns of this matrix\n     * @param radiusX multiplier to be applied to the x direction\n     * @param radiusY multiplier to be applied to the y direction\n     * @param radiusZ  multiplier to be applied to the z direction\n     */\n    static createCenterMatrixRadii(center, axes, radiusX, radiusY, radiusZ) {\n        let scaledAxes;\n        if (axes === undefined)\n            scaledAxes = Matrix3d.createScale(radiusX, radiusY, radiusZ);\n        else\n            scaledAxes = axes.scaleColumns(radiusX, radiusY, radiusZ);\n        return new Ellipsoid(Transform.createOriginAndMatrix(center, scaledAxes));\n    }\n    /** Return a (REFERENCE TO) the transform from world space to the mapped sphere space.\n     * * This maps coordinates \"relative to the sphere\" to world.\n     * * Its inverse maps world coordinates into the sphere space.\n     *   * In the sphere space, an xyz (vector from origin) with magnitude equal to 1 is ON the sphere (hence its world image is ON the ellipsoid)\n     *   * In the sphere space, an xyz (vector from origin) with magnitude less than 1 is INSIDE the sphere (hence its world image is INSIDE the ellipsoid)\n     *   * In the sphere space, an xyz (vector from origin) with magnitude greater than 1 is OUTSIDE the sphere (hence its world image is OUTSIDE the ellipsoid)\n     */\n    get transformRef() { return this._transform; }\n    /**\n     * * Convert a world point to point within the underlying mapped sphere space.\n     *   * In the sphere space, an xyz (vector from origin) with magnitude equal to 1 is ON the sphere (hence its world image is ON the ellipsoid)\n     *   * In the sphere space, an xyz (vector from origin) with magnitude less than 1 is INSIDE the sphere (hence its world image is INSIDE the ellipsoid)\n     *   * In the sphere space, an xyz (vector from origin) with magnitude greater than 1 is OUTSIDE the sphere (hence its world image is OUTSIDE the ellipsoid)\n     * * This is undefined in the highly unusual case that the ellipsoid frame is singular.\n     */\n    worldToLocal(worldPoint, result) {\n        return this._transform.multiplyInversePoint3d(worldPoint, result);\n    }\n    /**\n     * * Convert a point within the underlying mapped sphere space to world coordinates.\n     *   * In the sphere space, an xyz (vector from origin) with magnitude equal to 1 is ON the sphere (hence its world image is ON the ellipsoid)\n     *   * In the sphere space, an xyz (vector from origin) with magnitude less than 1 is INSIDE the sphere (hence its world image is INSIDE the ellipsoid)\n     *   * In the sphere space, an xyz (vector from origin) with magnitude greater than 1 is OUTSIDE the sphere (hence its world image is OUTSIDE the ellipsoid)\n     */\n    localToWorld(localPoint, result) {\n        return this._transform.multiplyPoint3d(localPoint, result);\n    }\n    /** return a clone with same coordinates */\n    clone() {\n        return new Ellipsoid(this._transform.clone());\n    }\n    /** test equality of the 4 points */\n    isAlmostEqual(other) {\n        return this._transform.isAlmostEqual(other._transform);\n    }\n    /** Apply the transform to each point */\n    tryTransformInPlace(transform) {\n        transform.multiplyTransformTransform(this._transform, this._transform);\n        return true;\n    }\n    /**\n     * return a cloned and transformed ellipsoid.\n     * @param transform\n     */\n    cloneTransformed(transform) {\n        const result = this.clone();\n        result.tryTransformInPlace(transform);\n        return result;\n    }\n    /** Find the closest point of the (patch of the) ellipsoid.\n     * * In general there are multiple points where a space point projects onto an ellipse.\n     * * This searches for only one point, using heuristics which are reliable for points close to the surface but not for points distant from highly skewed ellipsoid\n     */\n    projectPointToSurface(spacePoint) {\n        const searcher = new EllipsoidClosestPoint(this);\n        return searcher.searchClosestPoint(spacePoint);\n    }\n    /** Find the silhouette of the ellipsoid as viewed from a homogeneous eyepoint.\n     * * Returns undefined if the eyepoint is inside the ellipsoid\n     */\n    silhouetteArc(eyePoint) {\n        const localEyePoint = this._transform.multiplyInversePoint4d(eyePoint);\n        if (localEyePoint !== undefined) {\n            // localEyePoint is now looking at a unit sphere centered at the origin.\n            // the plane through the silhouette is the eye point with z negated ...\n            const localPlaneA = Point4d.create(localEyePoint.x, localEyePoint.y, localEyePoint.z, -localEyePoint.w);\n            const localPlaneB = localPlaneA.toPlane3dByOriginAndUnitNormal();\n            // if the silhouette plane has origin inside the sphere, there is a silhouette with center at the plane origin.\n            if (localPlaneB) {\n                const rr = 1.0 - localPlaneB.getOriginRef().magnitudeSquared(); // squared distance radius of silhouette arc\n                if (rr > 0.0 && rr <= 1.0) {\n                    const arc = Arc3d.createCenterNormalRadius(localPlaneB.getOriginRef(), localPlaneB.getNormalRef(), Math.sqrt(rr));\n                    if (arc.tryTransformInPlace(this._transform))\n                        return arc;\n                }\n            }\n        }\n        return undefined;\n    }\n    /** Compute intersections with a ray.\n     * * Return the number of intersections\n     * * Fill any combinations of arrays of\n     *    * rayFractions = fractions along the ray\n     *    * xyz = xyz intersection coordinates points in space\n     *    * thetaPhiRadians = sphere longitude and latitude in radians.\n     * * For each optional array, caller must of course initialize an array (usually empty)\n     * * return 0 if ray length is too small.\n     */\n    intersectRay(ray, rayFractions, xyz, thetaPhiRadians) {\n        if (xyz)\n            xyz.length = 0;\n        if (thetaPhiRadians !== undefined)\n            thetaPhiRadians.length = 0;\n        if (rayFractions)\n            rayFractions.length = 0;\n        // if ray comes in unit vector in large ellipsoid, localRay direction is minuscule.\n        // use a ray scaled up so its direction vector magnitude is comparable to the ellipsoid radiusX\n        const ray1 = ray.clone();\n        const a0 = ray.direction.magnitude();\n        const aX = this._transform.matrix.columnXMagnitude();\n        const scale = Geometry.conditionalDivideCoordinate(aX, a0);\n        if (scale === undefined)\n            return 0;\n        ray1.direction.scaleInPlace(scale);\n        const localRay = ray1.cloneInverseTransformed(this._transform);\n        if (localRay !== undefined) {\n            const n = SphereImplicit.intersectSphereRay(Point3d.create(0, 0, 0), 1.0, localRay, rayFractions, xyz, thetaPhiRadians);\n            if (rayFractions !== undefined) {\n                for (let i = 0; i < rayFractions.length; i++)\n                    rayFractions[i] *= scale;\n            }\n            if (xyz !== undefined) {\n                this._transform.multiplyPoint3dArrayInPlace(xyz);\n            }\n            return n;\n        }\n        return 0;\n    }\n    /** Return the range of a uv-aligned patch of the sphere. */\n    patchRangeStartEndRadians(theta0Radians, theta1Radians, phi0Radians, phi1Radians, result) {\n        const xExtreme = EllipsoidComponentExtrema.createTransformRow(this._transform, 0);\n        const yExtreme = EllipsoidComponentExtrema.createTransformRow(this._transform, 1);\n        const zExtreme = EllipsoidComponentExtrema.createTransformRow(this._transform, 2);\n        if (!result)\n            result = Range3d.createNull();\n        else\n            result.setNull();\n        // Range extrema can occur at:\n        //  * 2 smooth surface points in each direction\n        //  * along low and high phi boundary arcs\n        //  * along low and high theta boundary arcs\n        // smooth surface extrema . ..\n        xExtreme.extendRangeForSmoothSurfacePoints(result, theta0Radians, theta1Radians, phi0Radians, phi1Radians);\n        yExtreme.extendRangeForSmoothSurfacePoints(result, theta0Radians, theta1Radians, phi0Radians, phi1Radians);\n        zExtreme.extendRangeForSmoothSurfacePoints(result, theta0Radians, theta1Radians, phi0Radians, phi1Radians);\n        //\n        if (!Angle.isFullCircleRadians(theta1Radians - theta0Radians)) {\n            xExtreme.extendRangeForConstantThetaArc(result, theta0Radians, phi0Radians, phi1Radians);\n            yExtreme.extendRangeForConstantThetaArc(result, theta0Radians, phi0Radians, phi1Radians);\n            zExtreme.extendRangeForConstantThetaArc(result, theta0Radians, phi0Radians, phi1Radians);\n            xExtreme.extendRangeForConstantThetaArc(result, theta1Radians, phi0Radians, phi1Radians);\n            yExtreme.extendRangeForConstantThetaArc(result, theta1Radians, phi0Radians, phi1Radians);\n            zExtreme.extendRangeForConstantThetaArc(result, theta1Radians, phi0Radians, phi1Radians);\n        }\n        if (!Angle.isHalfCircleRadians(phi1Radians - phi0Radians)) {\n            xExtreme.extendRangeForConstantPhiArc(result, theta0Radians, theta1Radians, phi0Radians);\n            yExtreme.extendRangeForConstantPhiArc(result, theta0Radians, theta1Radians, phi0Radians);\n            zExtreme.extendRangeForConstantPhiArc(result, theta0Radians, theta1Radians, phi0Radians);\n            xExtreme.extendRangeForConstantPhiArc(result, theta0Radians, theta1Radians, phi1Radians);\n            yExtreme.extendRangeForConstantPhiArc(result, theta0Radians, theta1Radians, phi1Radians);\n            zExtreme.extendRangeForConstantPhiArc(result, theta0Radians, theta1Radians, phi1Radians);\n        }\n        return result;\n    }\n    /**\n     * Evaluate a point on the ellipsoid at angles give in radians.\n     * @param thetaRadians longitude, in radians\n     * @param phiRadians latitude, in radians\n     * @param result optional point result\n     */\n    radiansToPoint(thetaRadians, phiRadians, result) {\n        const cosTheta = Math.cos(thetaRadians);\n        const sinTheta = Math.sin(thetaRadians);\n        const cosPhi = Math.cos(phiRadians);\n        const sinPhi = Math.sin(phiRadians);\n        return this._transform.multiplyXYZ(cosTheta * cosPhi, sinTheta * cosPhi, sinPhi, result);\n    }\n    /**\n     * * For a given pair of points on an ellipsoid, construct an arc (possibly elliptical) which\n     *   * passes through both points\n     *   * is completely within the ellipsoid surface\n     *   * has its centerEvaluate a point on the ellipsoid at angles give in radians.\n     * * If the ellipsoid is a sphere, this is the shortest great-circle arc between the two points.\n     * * If the ellipsoid is not a sphere, this is close to but not precisely the shortest path.\n     * @param thetaARadians longitude, in radians, for pointA\n     * @param phiARadians latitude, in radians, for pointA\n     * @param thetaBRadians longitude, in radians, for pointB\n     * @param phiBRadians latitude, in radians, for pointB\n     * @param result optional preallocated result\n     */\n    radiansPairToGreatArc(thetaARadians, phiARadians, thetaBRadians, phiBRadians, result) {\n        SphereImplicit.radiansToUnitSphereXYZ(thetaARadians, phiARadians, this._unitVectorA);\n        SphereImplicit.radiansToUnitSphereXYZ(thetaBRadians, phiBRadians, this._unitVectorB);\n        const sweepAngle = this._unitVectorA.angleTo(this._unitVectorB);\n        // the unit vectors (on unit sphere) are never 0, so this cannot fail.\n        const matrix = Matrix3d.createRigidFromColumns(this._unitVectorA, this._unitVectorB, AxisOrder.XYZ);\n        if (matrix !== undefined) {\n            const matrix1 = this._transform.matrix.multiplyMatrixMatrix(matrix);\n            return Arc3d.create(this._transform.getOrigin(), matrix1.columnX(), matrix1.columnY(), AngleSweep.createStartEndRadians(0.0, sweepAngle.radians), result);\n        }\n        return undefined;\n    }\n    /**\n     * See radiansPairToGreatArc, which does this computation with positions from `angleA` and `angleB` directly as radians\n     */\n    anglePairToGreatArc(angleA, angleB, result) {\n        return this.radiansPairToGreatArc(angleA.longitudeRadians, angleA.latitudeRadians, angleB.longitudeRadians, angleB.latitudeRadians, result);\n    }\n    /**\n     * Construct an arc for the section cut of a plane with the ellipsoid.\n     * * this is undefined if the plane does not intersect the ellipsoid.\n     */\n    createPlaneSection(plane) {\n        const localPlane = plane.cloneTransformed(this._transform, true);\n        if (localPlane !== undefined) {\n            // construct center and arc vectors in the local system --- later transform them out to global.\n            const center = localPlane.projectPointToPlane(Point3d.createZero());\n            const d = center.magnitude();\n            if (d < 1.0) {\n                const frame = Matrix3d.createRigidHeadsUp(localPlane.getNormalRef(), AxisOrder.ZYX);\n                const vector0 = frame.columnX();\n                const vector90 = frame.columnY();\n                const sectionRadius = Math.sqrt(1.0 - d * d);\n                vector0.scaleInPlace(sectionRadius);\n                vector90.scaleInPlace(sectionRadius);\n                this._transform.multiplyPoint3d(center, center);\n                this._transform.multiplyVector(vector0, vector0);\n                this._transform.multiplyVector(vector90, vector90);\n                return Arc3d.create(center, vector0, vector90, undefined);\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Construct an arc which\n     *  * start at pointA (defined by its angle position)\n     *  * ends at pointB (defined by its angle position)\n     *  * contains the 3rd vector as an in-plane point.\n     */\n    createSectionArcPointPointVectorInPlane(pointAnglesA, pointAnglesB, inPlaneVector, result) {\n        const xyzA = this.radiansToPoint(pointAnglesA.longitudeRadians, pointAnglesA.latitudeRadians);\n        const xyzB = this.radiansToPoint(pointAnglesB.longitudeRadians, pointAnglesB.latitudeRadians);\n        const localA = this._transform.multiplyInversePoint3d(xyzA);\n        const localB = this._transform.multiplyInversePoint3d(xyzB);\n        const a = this._transform.matrix.maxAbs();\n        const scaledInPlaneVector = inPlaneVector.scaleToLength(a);\n        if (scaledInPlaneVector === undefined)\n            return undefined;\n        const localInPlaneVector = this._transform.matrix.multiplyInverse(scaledInPlaneVector);\n        if (localA !== undefined && localB !== undefined && localInPlaneVector !== undefined) {\n            const localPlane = Plane3dByOriginAndUnitNormal.createPointPointVectorInPlane(localA, localB, localInPlaneVector);\n            if (localPlane !== undefined) {\n                // construct center and arc vectors in the local system --- later transform them out to global.\n                const center = localPlane.projectPointToPlane(Point3d.createZero());\n                const vector0 = Vector3d.createStartEnd(center, localA);\n                const vectorB = Vector3d.createStartEnd(center, localB);\n                const vector90 = Vector3d.createRotateVectorAroundVector(vector0, localPlane.getNormalRef(), undefined);\n                if (vector90 !== undefined) {\n                    const sweepRadians = vector0.planarRadiansTo(vectorB, localPlane.getNormalRef());\n                    this._transform.multiplyPoint3d(center, center);\n                    this._transform.multiplyVector(vector0, vector0);\n                    this._transform.multiplyVector(vector90, vector90);\n                    return Arc3d.create(center, vector0, vector90, AngleSweep.createStartEndRadians(0, sweepRadians), result);\n                }\n            }\n        }\n        return undefined;\n    }\n    /**\n     * * For a given pair of points on an ellipsoid, construct another ellipsoid\n     *   * touches the same xyz points in space\n     *   * has transformation modified so that the original two points are on the equator.\n     * * Note that except for true sphere inputs, the result axes can be both non-perpendicular axes and of different lengths.\n     * @param thetaARadians longitude, in radians, for pointA\n     * @param phiARadians latitude, in radians, for pointA\n     * @param thetaBRadians longitude, in radians, for pointB\n     * @param phiBRadians latitude, in radians, for pointB\n     * @param result optional preallocated result\n     */\n    radiansPairToEquatorialEllipsoid(thetaARadians, phiARadians, thetaBRadians, phiBRadians, result) {\n        SphereImplicit.radiansToUnitSphereXYZ(thetaARadians, phiARadians, this._unitVectorA);\n        SphereImplicit.radiansToUnitSphereXYZ(thetaBRadians, phiBRadians, this._unitVectorB);\n        const matrix = Matrix3d.createRigidFromColumns(this._unitVectorA, this._unitVectorB, AxisOrder.XYZ);\n        if (matrix) {\n            if (result) {\n                this._transform.multiplyTransformMatrix3d(matrix, result._transform);\n                return result;\n            }\n            return Ellipsoid.create(this._transform.multiplyTransformMatrix3d(matrix));\n        }\n        return undefined;\n    }\n    /**\n     * Return an arc (circular or elliptical) at constant longitude\n     * @param longitude (strongly typed) longitude\n     * @param latitude latitude sweep angles\n     * @param result\n     */\n    constantLongitudeArc(longitude, latitudeSweep, result) {\n        if (Angle.isAlmostEqualRadiansNoPeriodShift(0, latitudeSweep.sweepRadians))\n            return undefined;\n        const cosTheta = longitude.cos();\n        const sinTheta = longitude.sin();\n        const vector0 = this._transform.matrix.multiplyXY(cosTheta, sinTheta);\n        const vector90 = this._transform.matrix.columnZ();\n        const center = this._transform.getOrigin();\n        return Arc3d.create(center, vector0, vector90, latitudeSweep, result);\n    }\n    /**\n     * Return an arc (circular or elliptical) at constant longitude\n     * @param latitude sweep angles\n     * @param latitude (strongly typed) latitude\n     * @param result\n     */\n    constantLatitudeArc(longitudeSweep, latitude, result) {\n        if (Angle.isAlmostEqualRadiansNoPeriodShift(0, longitudeSweep.sweepRadians))\n            return undefined;\n        if (latitude.isAlmostNorthOrSouthPole)\n            return undefined;\n        const cosPhi = latitude.cos();\n        const sinPhi = latitude.sin();\n        const vector0 = this._transform.matrix.columnX();\n        vector0.scaleInPlace(cosPhi);\n        const vector90 = this._transform.matrix.columnY();\n        vector90.scaleInPlace(cosPhi);\n        const center = this._transform.multiplyXYZ(0, 0, sinPhi);\n        return Arc3d.create(center, vector0, vector90, longitudeSweep, result);\n    }\n    /**\n     * * create a section arc with and end at positions A and B, and in plane with the normal at a fractional\n     *    interpolation between.\n     * @param angleA start point of arc (given as angles on this ellipsoid)\n     * @param intermediateNormalFraction\n     * @param angleB end point of arc (given as angles on this ellipsoid)\n     */\n    sectionArcWithIntermediateNormal(angleA, intermediateNormalFraction, angleB) {\n        const normalA = this.radiansToUnitNormalRay(angleA.longitudeRadians, angleA.latitudeRadians);\n        const normalB = this.radiansToUnitNormalRay(angleB.longitudeRadians, angleB.latitudeRadians);\n        const normal = normalA.direction.interpolate(intermediateNormalFraction, normalB.direction);\n        const arc = this.createSectionArcPointPointVectorInPlane(angleA, angleB, normal);\n        return arc;\n    }\n    /**\n     * Evaluate a point and derivatives with respect to angle on the ellipsoid at angles give in radians.\n     * * \"u direction\" vector of the returned plane is derivative with respect to longitude.\n     * * \"v direction\" vector fo the returned plane is derivative with respect ot latitude.\n     * @param thetaRadians longitude, in radians\n     * @param phiRadians latitude, in radians\n     * @param applyCosPhiFactor selector for handling of theta (around equator derivative)\n     *   * if true, compute the properly scaled derivative, which goes to zero at the poles.\n     *    * If false, omit he cos(phi) factor on the derivative wrt theta.  This ensures it is always nonzero and can be safely used in cross product for surface normal.\n     * @param result optional plane result\n     */\n    radiansToPointAndDerivatives(thetaRadians, phiRadians, applyCosPhiFactor = true, result) {\n        const cosTheta = Math.cos(thetaRadians);\n        const sinTheta = Math.sin(thetaRadians);\n        const cosPhi = Math.cos(phiRadians);\n        const cosPhiA = applyCosPhiFactor ? cosPhi : 1.0;\n        const sinPhi = Math.sin(phiRadians);\n        const matrix = this._transform.matrix;\n        if (!result)\n            return Plane3dByOriginAndVectors.createCapture(this._transform.multiplyXYZ(cosTheta * cosPhi, sinTheta * cosPhi, sinPhi), matrix.multiplyXYZ(-sinTheta * cosPhiA, cosTheta * cosPhiA, 0), matrix.multiplyXYZ(-sinPhi * cosTheta, -sinPhi * sinTheta, cosPhi));\n        // in place modification requires direct reference to members of the result ...\n        this._transform.multiplyXYZ(cosTheta * cosPhi, sinTheta * cosPhi, sinPhi, result.origin);\n        matrix.multiplyXYZ(-sinTheta * cosPhiA, cosTheta * cosPhiA, 0, result.vectorU);\n        matrix.multiplyXYZ(-sinPhi * cosTheta, -sinPhi * sinTheta, cosPhi, result.vectorV);\n        return result;\n    }\n    /**\n     * Evaluate a point and derivatives wrt to theta, phi, thetaTheta, phiPhi, and thetaPhi.\n     * All outputs are to caller-allocated points and vectors.\n     * @param thetaRadians longitude, in radians\n     * @param phiRadians latitude, in radians\n     * @param point (returned) surface point\n     * @param d1Theta (returned) derivative wrt theta\n     * @param d1Phi (returned) derivative wrt phi\n     * @param d2ThetaTheta (returned) second derivative wrt theta twice\n     * @param d2PhiPhi (returned) second derivative wrt phi twice\n     * @param d2ThetaPhi (returned) second derivative wrt theta and phi\n     * @param result optional plane result\n     */\n    radiansToPointAnd2Derivatives(thetaRadians, phiRadians, point, d1Theta, d1Phi, d2ThetaTheta, d2PhiPhi, d2ThetaPhi) {\n        const cosTheta = Math.cos(thetaRadians);\n        const sinTheta = Math.sin(thetaRadians);\n        const cosPhi = Math.cos(phiRadians);\n        const sinPhi = Math.sin(phiRadians);\n        const matrix = this._transform.matrix;\n        this._transform.multiplyXYZ(cosTheta * cosPhi, sinTheta * cosPhi, sinPhi, point);\n        // theta derivatives\n        matrix.multiplyXYZ(-sinTheta * cosPhi, cosTheta * cosPhi, 0, d1Theta);\n        matrix.multiplyXYZ(-cosTheta * cosPhi, -sinTheta * cosPhi, 0, d2ThetaTheta);\n        // phi derivatives\n        matrix.multiplyXYZ(-cosTheta * sinPhi, -sinTheta * sinPhi, cosPhi, d1Phi);\n        matrix.multiplyXYZ(-cosTheta * cosPhi, -sinTheta * cosPhi, -sinPhi, d2PhiPhi);\n        // mixed derivative\n        matrix.multiplyXYZ(sinTheta * sinPhi, -cosTheta * sinPhi, 0, d2ThetaPhi);\n    }\n    /**\n     * Evaluate a point and rigid local coordinate frame the ellipsoid at angles give in radians.\n     * * The undefined return is only possible if the placement transform is singular (and even then only at critical angles)\n     * @param thetaRadians longitude, in radians\n     * @param phiRadians latitude, in radians\n     * @param result optional transform result\n     *\n     */\n    radiansToFrenetFrame(thetaRadians, phiRadians, result) {\n        const plane = this.radiansToPointAndDerivatives(thetaRadians, phiRadians, false);\n        return plane.toRigidFrame(result);\n    }\n    /**\n     * Evaluate a point and unit normal at given angles.\n     * @param thetaRadians longitude, in radians\n     * @param phiRadians latitude, in radians\n     * @param result optional transform result\n     *\n     */\n    radiansToUnitNormalRay(thetaRadians, phiRadians, result) {\n        const plane = this.radiansToPointAndDerivatives(thetaRadians, phiRadians, false);\n        return plane.unitNormalRay(result);\n    }\n    /**\n     * Find the (unique) extreme point for a given true surface perpendicular vector (outward)\n     */\n    surfaceNormalToAngles(normal, result) {\n        const matrix = this._transform.matrix;\n        const conjugateVector = matrix.multiplyTransposeVector(normal);\n        const thetaRadians = Math.atan2(conjugateVector.y, conjugateVector.x);\n        // For that phi arc,\n        const axy = -(conjugateVector.x * Math.cos(thetaRadians) + conjugateVector.y * Math.sin(thetaRadians));\n        const az = conjugateVector.z;\n        const phiRadians = Math.atan2(az, -axy);\n        return LongitudeLatitudeNumber.createRadians(thetaRadians, phiRadians, 0.0, result);\n    }\n    /**\n     * * Evaluate the surface normal on `other` ellipsoid at given angles\n     *    * If `other` is undefined, default to unit sphere.\n     * * Find the angles for the same normal on `this` ellipsoid\n     */\n    otherEllipsoidAnglesToThisEllipsoidAngles(otherEllipsoid, otherAngles, result) {\n        const normal = Ellipsoid.radiansToUnitNormalRay(otherEllipsoid, otherAngles.longitudeRadians, otherAngles.latitudeRadians);\n        if (normal !== undefined)\n            return this.surfaceNormalToAngles(normal.direction, result);\n        return undefined;\n    }\n    /**\n     * * if ellipsoid is given, return its surface point and unit normal as a Ray3d.\n     * * if not given, return surface point and unit normal for unit sphere.\n     */\n    static radiansToUnitNormalRay(ellipsoid, thetaRadians, phiRadians, result) {\n        if (ellipsoid) {\n            return ellipsoid.radiansToUnitNormalRay(thetaRadians, phiRadians, result);\n        }\n        if (!result)\n            result = Ray3d.createZAxis();\n        // for unit sphere, the vector from center to surface point is identical to the unit normal.\n        SphereImplicit.radiansToUnitSphereXYZ(thetaRadians, phiRadians, result.origin);\n        result.direction.setFromPoint3d(result.origin);\n        return result;\n    }\n    /** Implement the `isPointInOnOrOutside` test fom the `interface` */\n    isPointOnOrInside(point) {\n        const localPoint = this._transform.multiplyInversePoint3d(point, this._workPointA);\n        if (localPoint !== undefined)\n            return localPoint.magnitude() <= 1.0;\n        return false;\n    }\n    /** Announce \"in\" portions of a line segment.  See `Clipper.announceClippedSegmentIntervals` */\n    announceClippedSegmentIntervals(f0, f1, pointA, pointB, announce) {\n        const localA = this._transform.multiplyInversePoint3d(pointA, this._workPointA);\n        const localB = this._transform.multiplyInversePoint3d(pointB, this._workPointB);\n        if (localA && localB) {\n            const dotAA = Vector3d.dotProductAsXYAndZ(this._workPointA, this._workPointA);\n            const dotAB = Vector3d.dotProductAsXYAndZ(this._workPointA, this._workPointB);\n            const dotBB = Vector3d.dotProductAsXYAndZ(this._workPointB, this._workPointB);\n            const bezier = new Order3Bezier(dotAA, dotAB, dotBB);\n            const roots = bezier.roots(1.0, false);\n            if (roots !== undefined && roots.length === 2) {\n                // we know the roots are sorted.  The f0,f1 might not be ..\n                if (f0 < f1) {\n                    if (roots[0] < f0)\n                        roots[0] = f0;\n                    if (f1 < roots[1])\n                        roots[1] = f1;\n                    if (roots[0] < roots[1]) {\n                        if (announce)\n                            announce(roots[0], roots[1]);\n                        return true;\n                    }\n                }\n                else {\n                    // f0,f1 are reversed. do the outputs in the same sense\n                    if (roots[1] > f0)\n                        roots[1] = f0;\n                    if (roots[0] < f1)\n                        roots[0] = f1;\n                    if (roots[1] > roots[0]) {\n                        if (announce)\n                            announce(roots[1], roots[0]);\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n    /** Announce \"in\" portions of a line segment.  See `Clipper.announceClippedSegmentIntervals` */\n    announceClippedArcIntervals(arc, announce) {\n        const arcData = arc.toVectors();\n        let numAnnounce = 0;\n        if (this._transform.multiplyInversePoint3d(arcData.center, arcData.center)\n            && this._transform.matrix.multiplyInverse(arcData.vector0, arcData.vector0)\n            && this._transform.matrix.multiplyInverse(arcData.vector90, arcData.vector90)) {\n            // in local coordinates the arc parameterization is   X = center + vector0 * cos(theta) + vector90 * sin(theta)\n            //  We want X DOT X === 1, viz\n            //    center DOT center + 2 * cos(theta) * center DOT vector0 + 2 * sin(theta) * center DOT vector90 + cos(theta) ^2 * vector0 DOT vector0 + sin (theta)^2 * vector90 DOT vector90 = 1\n            const cc = Vector3d.dotProductAsXYAndZ(arcData.center, arcData.center);\n            const cu = Vector3d.dotProductAsXYAndZ(arcData.center, arcData.vector0);\n            const cv = Vector3d.dotProductAsXYAndZ(arcData.center, arcData.vector90);\n            const uv = Vector3d.dotProductAsXYAndZ(arcData.vector0, arcData.vector90);\n            const uu = Vector3d.dotProductAsXYAndZ(arcData.vector0, arcData.vector0);\n            const vv = Vector3d.dotProductAsXYAndZ(arcData.vector90, arcData.vector90);\n            const intersectionRadians = [];\n            if (TrigPolynomial.solveUnitCircleImplicitQuadricIntersection(uu, 2.0 * uv, vv, 2.0 * cu, 2.0 * cv, cc - 1.0, intersectionRadians)) {\n                const fractions = [0.0, 1.0];\n                for (const radians of intersectionRadians) {\n                    const fraction = arc.sweep.radiansToSignedPeriodicFraction(radians);\n                    if (Geometry.isIn01(fraction))\n                        fractions.push(fraction);\n                }\n                fractions.sort();\n                let f0, f1;\n                for (let i1 = 1; i1 < fractions.length; i1++) {\n                    f0 = fractions[i1 - 1];\n                    f1 = fractions[i1];\n                    if (f1 > f0) {\n                        const xyz = arc.fractionToPoint(Geometry.interpolate(fractions[i1 - 1], 0.5, fractions[i1]));\n                        if (this.isPointOnOrInside(xyz)) {\n                            if (announce)\n                                announce(fractions[i1 - 1], fractions[i1], arc);\n                            numAnnounce++;\n                        }\n                    }\n                }\n            }\n        }\n        return numAnnounce > 0;\n    }\n}\n/**\n * * An `EllipsoidPatch` is\n *   * An underlying (full) `Ellipsoid` object\n *   * an angular range (`AngleSweep`) of longitudes around the equator\n *   * an angular range (`AngleSweep`) of latitudes, with 0 at the equator, +90 degrees at north pole.\n * * The `EllipsoidPatch` implements `UVSurface` methods, so a `PolyfaceBuilder` can generate facets in its method `addUVGridBody`\n * @public\n */\nexport class EllipsoidPatch {\n    /**\n     * CAPTURE ellipsoid and sweeps as an EllipsoidPatch.\n     * @param ellipsoid\n     * @param longitudeSweep\n     * @param latitudeSweep\n     */\n    constructor(ellipsoid, longitudeSweep, latitudeSweep) {\n        this.ellipsoid = ellipsoid;\n        this.longitudeSweep = longitudeSweep;\n        this.latitudeSweep = latitudeSweep;\n    }\n    /**\n     * Create a new EllipsoidPatch, capturing (not cloning) all input object references.\n     * @param ellipsoid  full ellipsoid\n     * @param longitudeSweep sweep of longitudes in the active patch\n     * @param latitudeSweep sweep of latitudes in the active patch.\n     */\n    static createCapture(ellipsoid, longitudeSweep, latitudeSweep) {\n        return new EllipsoidPatch(ellipsoid, longitudeSweep, latitudeSweep);\n    }\n    /** Return the point on the ellipsoid at fractional positions in the angular ranges. */\n    uvFractionToPoint(longitudeFraction, latitudeFraction, result) {\n        return this.ellipsoid.radiansToPoint(this.longitudeSweep.fractionToRadians(longitudeFraction), this.latitudeSweep.fractionToRadians(latitudeFraction), result);\n    }\n    /** Return the point and derivative vectors on the ellipsoid at fractional positions in the angular ranges.\n     * * Derivatives are with respect to fractional position.\n     */\n    uvFractionToPointAndTangents(longitudeFraction, latitudeFraction, result) {\n        result = this.ellipsoid.radiansToPointAndDerivatives(this.longitudeSweep.fractionToRadians(longitudeFraction), this.latitudeSweep.fractionToRadians(latitudeFraction), true, result);\n        result.vectorU.scale(this.longitudeSweep.sweepRadians);\n        result.vectorV.scale(this.latitudeSweep.sweepRadians);\n        return result;\n    }\n    /** Return the range of the patch, considering both boundary and internal extrema. */\n    range(result) {\n        return this.ellipsoid.patchRangeStartEndRadians(this.longitudeSweep.startRadians, this.longitudeSweep.endRadians, this.latitudeSweep.startRadians, this.latitudeSweep.endRadians, result);\n    }\n    /** Return intersections of the ray and surface.\n     * * uv values in the intersections are in radians unless `convertIntersectionRadiansToFractions` is true requesting conversion to patch fractions.\n     */\n    intersectRay(ray, restrictToPatch, convertIntersectionRadiansToFractions = false) {\n        const result = [];\n        const rayFractions = [];\n        const xyz = [];\n        const thetaPhi = [];\n        const n = this.ellipsoid.intersectRay(ray, rayFractions, xyz, thetaPhi);\n        for (let i = 0; i < n; i++) {\n            const longitudeRadians = thetaPhi[i].longitudeRadians;\n            const latitudeRadians = thetaPhi[i].latitudeRadians;\n            if (!restrictToPatch\n                || (this.longitudeSweep.isRadiansInSweep(longitudeRadians)\n                    && this.latitudeSweep.isRadiansInSweep(latitudeRadians))) {\n                if (convertIntersectionRadiansToFractions) {\n                    const uFraction = this.longitudeSweep.radiansToSignedPeriodicFraction(longitudeRadians);\n                    const vFraction = this.latitudeSweep.radiansToSignedPeriodicFraction(latitudeRadians);\n                    result.push(new CurveAndSurfaceLocationDetail(CurveLocationDetail.createRayFractionPoint(ray, rayFractions[i], xyz[i]), UVSurfaceLocationDetail.createSurfaceUVNumbersPoint(this, uFraction, vFraction, xyz[i])));\n                }\n                else {\n                    result.push(new CurveAndSurfaceLocationDetail(CurveLocationDetail.createRayFractionPoint(ray, rayFractions[i], xyz[i]), UVSurfaceLocationDetail.createSurfaceUVNumbersPoint(this, longitudeRadians, latitudeRadians, xyz[i])));\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * test if the angles of the `LongitudeLatitudeNumber` are within the sweep ranges.\n     * @param position longitude and latitude to test.\n     * @param `allowPeriodicLongitude` true to allow the longitude to be in when shifted by a multiple of 2 PI\n     *    (latitude is never periodic for patches)\n     */\n    containsAngles(position, allowPeriodicLongitude = true) {\n        return this.latitudeSweep.isRadiansInSweep(position.latitudeRadians, false)\n            && this.longitudeSweep.isRadiansInSweep(position.longitudeRadians, allowPeriodicLongitude);\n    }\n    /**\n     * Compute point (with altitude) at given angles and altitude.\n     * * Never fails for non-singular ellipsoid.\n     * * In the returned ray,\n     *    * ray.origin is the point at requested altitude.\n     *    * ray.direction is an outward-directed unit vector\n     * @param position longitude, latitude, and height\n     *\n     */\n    anglesToUnitNormalRay(position, result) {\n        const ray = this.ellipsoid.radiansToUnitNormalRay(position.longitudeRadians, position.latitudeRadians, result);\n        if (!ray)\n            return undefined;\n        ray.origin = ray.fractionToPoint(position.altitude, ray.origin);\n        return ray;\n    }\n    /**\n     * Return simple angles of a fractional position in the patch.\n     * @param thetaFraction fractional position in longitude (theta) interval\n     * @param phiFraction fractional position in latitude (phi) interval\n     * @param h optional altitude\n     * @param result optional preallocated result.\n     */\n    uvFractionToAngles(longitudeFraction, phiFraction, h = 0, result) {\n        return LongitudeLatitudeNumber.createRadians(this.longitudeSweep.fractionToRadians(longitudeFraction), this.latitudeSweep.fractionToRadians(phiFraction), h, result);\n    }\n    /** Find the closest point of the (patch of the) ellipsoid. */\n    projectPointToSurface(spacePoint) {\n        return this.ellipsoid.projectPointToSurface(spacePoint);\n    }\n}\n/**\n * Internal class for searching for the closest point (projection of spacePoint) on an ellipsoid.\n */\nclass EllipsoidClosestPoint extends NewtonEvaluatorRRtoRRD {\n    constructor(ellipsoid) {\n        super();\n        this._ellipsoid = ellipsoid;\n        this._surfacePoint = Point3d.create();\n        this._d1Theta = Vector3d.create();\n        this._d1Phi = Vector3d.create();\n        this._d2Theta = Vector3d.create();\n        this._d2Phi = Vector3d.create();\n        this._d2ThetaPhi = Vector3d.create();\n        this._delta = Vector3d.create();\n    }\n    searchClosestPoint(spacePoint) {\n        this._spacePoint = spacePoint;\n        const localPoint = this._ellipsoid.transformRef.multiplyInversePoint3d(spacePoint);\n        if (!localPoint)\n            return undefined;\n        const sphere = new SphereImplicit(1.0);\n        const uv = sphere.xyzToThetaPhiR(localPoint);\n        const newtonSearcher = new Newton2dUnboundedWithDerivative(this);\n        newtonSearcher.setUV(uv.thetaRadians, uv.phiRadians);\n        if (newtonSearcher.runIterations()) {\n            uv.thetaRadians = newtonSearcher.getU();\n            uv.phiRadians = newtonSearcher.getV();\n        }\n        return LongitudeLatitudeNumber.createRadians(uv.thetaRadians, uv.phiRadians, 0.0);\n    }\n    evaluate(thetaRadians, phiRadians) {\n        this._ellipsoid.radiansToPointAnd2Derivatives(thetaRadians, phiRadians, this._surfacePoint, this._d1Theta, this._d1Phi, this._d2Theta, this._d2Phi, this._d2ThetaPhi);\n        Vector3d.createStartEnd(this._spacePoint, this._surfacePoint, this._delta);\n        const q = this._d1Theta.dotProduct(this._d1Phi) + this._delta.dotProduct(this._d2ThetaPhi);\n        this.currentF.setOriginAndVectorsXYZ(\n        // f,g,0\n        this._delta.dotProduct(this._d1Theta), this._delta.dotProduct(this._d1Phi), 0, \n        // df/dTheta, dg/dTheta, 0\n        this._d1Theta.dotProduct(this._d1Theta) + this._delta.dotProduct(this._d2Theta), q, 0, \n        // df/dPhi, dg/dPhi, 0\n        q, this._d1Phi.dotProduct(this._d1Phi) + this._delta.dotProduct(this._d2Phi), 0);\n        return true;\n    }\n}\n/**\n * Detailed data for a point on a 2-angle parameter space.\n * @public\n */\nexport class GeodesicPathPoint {\n    constructor() {\n        this.thetaRadians = 0;\n        this.phiRadians = 0;\n        this.point = Point3d.create();\n        this.dTheta = Vector3d.create();\n        this.dPhi = Vector3d.create();\n        this.d2Theta = Vector3d.create();\n        this.d2Phi = Vector3d.create();\n        this.d2ThetaPhi = Vector3d.create();\n        this.d1Cross = Vector3d.create();\n    }\n    /** Fill all evaluations at given theta and phi. */\n    evaluateDerivativesAtCurrentAngles(ellipsoid) {\n        ellipsoid.radiansToPointAnd2Derivatives(this.thetaRadians, this.phiRadians, this.point, this.dTheta, this.dPhi, this.d2Theta, this.d2Phi, this.d2ThetaPhi);\n        this.dTheta.crossProduct(this.dPhi, this.d1Cross);\n    }\n    /** Evaluate the newton function and derivatives:\n     *          `(UAB cross UCB) dot d1cross`\n     * with as the central data, UAB = vector from pointA to pointB, UCB = vector from pointC to pointB.\n     * * Return order is:\n     *   * values[0] = the function\n     *   * values[1] = derivative wrt pointA.phi\n     *   * values[2] = derivative wrt pointB.phi\n     *   * values[3] = derivative wrt pointC.phi\n     */\n    static evaluateNewtonFunction(pointA, pointB, pointC, values) {\n        this._vectorAB = Vector3d.createStartEnd(pointA.point, pointB.point, this._vectorAB);\n        this._vectorCB = Vector3d.createStartEnd(pointC.point, pointB.point, this._vectorCB);\n        this._vectorCross = this._vectorAB.crossProduct(this._vectorCB);\n        // this._vectorCross is the cross product of vectors from A to B and C to B\n        // it should be perpendicular to (have zero dot product with) the surface normal, which is sitting in pointB as d1Cross\n        values[0] = this._vectorCross.dotProduct(pointB.d1Cross);\n        // Derivatives wrt phi at A, B, C creates derivatives of values[0] wrt each.\n        // derivatives at neighbor appear only on their point-to-point vector, and with negative sign ..\n        values[1] = -pointA.dPhi.tripleProduct(this._vectorCB, pointB.d1Cross);\n        values[3] = -this._vectorAB.tripleProduct(pointC.dPhi, pointB.d1Cross);\n        // values from pointB appear with positive sign everywhere . ..\n        values[2] = pointB.dPhi.tripleProduct(this._vectorCB, pointB.d1Cross)\n            + this._vectorAB.tripleProduct(pointB.dPhi, pointB.d1Cross)\n            + this._vectorCross.tripleProduct(pointB.d2ThetaPhi, pointB.dPhi)\n            + this._vectorCross.tripleProduct(pointB.dTheta, pointB.d2Phi);\n        // CRUNCH CRUNCH CRUNCH\n    }\n    /**\n     * Extract the two angles form this structure to a LongitudeLatitudeNumber structure.\n     */\n    toAngles() {\n        return LongitudeLatitudeNumber.createRadians(this.thetaRadians, this.phiRadians);\n    }\n}\n/**\n * Algorithm implementation class for computing approximate optimal (shortest) path points.\n * * Call the static method `createGeodesicPath` to compute path points.\n * @public\n */\nexport class GeodesicPathSolver {\n    constructor(defaultArc) {\n        this._pathPoints = [];\n        this._defaultArc = defaultArc;\n    }\n    /**\n     *\n     * @param originalEllipsoid Given start and endpoints on an ellipsoid, compute points along a near-optimal shortest path.\n     * * The points are located so that at each point the local surface normal is contained in the plane of the point and its two neighbors.\n     * @param startAngles angles for the start of the path\n     * @param endAngles angles for the end of the path\n     * @param density If this is a number, it is the requested edge count.  If this is an angle, it ias an angular spacing measured in the great arc through the two points.\n     */\n    static createGeodesicPath(originalEllipsoid, startAngles, endAngles, density) {\n        const workEllipsoid1 = originalEllipsoid.radiansPairToEquatorialEllipsoid(startAngles.longitudeRadians, startAngles.latitudeRadians, endAngles.longitudeRadians, endAngles.latitudeRadians);\n        const workArc = originalEllipsoid.radiansPairToGreatArc(startAngles.longitudeRadians, startAngles.latitudeRadians, endAngles.longitudeRadians, endAngles.latitudeRadians);\n        if (workEllipsoid1 === undefined || workArc === undefined)\n            return undefined;\n        let numEdges = 4;\n        if (density instanceof Angle) {\n            numEdges = Geometry.stepCount(density.radians, workArc.sweep.sweepRadians, 4, 180);\n        }\n        else if (Number.isFinite(density)) {\n            numEdges = Math.max(numEdges, density);\n        }\n        if (numEdges > 180)\n            numEdges = 180;\n        const scaledMatrix = workEllipsoid1.transformRef.matrix.clone();\n        const largestCoordinate = scaledMatrix.maxAbs();\n        const inverseLargestCoordinate = 1.0 / largestCoordinate;\n        scaledMatrix.scaleColumnsInPlace(inverseLargestCoordinate, inverseLargestCoordinate, inverseLargestCoordinate);\n        const workEllipsoid = Ellipsoid.create(Transform.createOriginAndMatrix(undefined, scaledMatrix));\n        const solver = new GeodesicPathSolver(workArc);\n        solver.createInitialPointsAndTridiagonalSystem(numEdges);\n        let numConverged = 0;\n        let previousMaxDPhi = 10000.0;\n        let numStep = 0;\n        const dPhiTolerance = 1.0e-8;\n        solver.setupStep(workEllipsoid);\n        while (numStep < 15 && numConverged < 2) {\n            if (!solver.solve())\n                break;\n            previousMaxDPhi = solver.applyUpdate(0.1);\n            solver.setupStep(workEllipsoid);\n            if (previousMaxDPhi < dPhiTolerance)\n                numConverged++;\n            else\n                numConverged = 0;\n            numStep++;\n        }\n        if (numConverged > 0) {\n            const workAngles = LongitudeLatitudeNumber.createRadians(0, 0);\n            const originalAngles = LongitudeLatitudeNumber.createRadians(0, 0);\n            for (const p of solver._pathPoints) {\n                LongitudeLatitudeNumber.createRadians(p.thetaRadians, p.phiRadians, 0, workAngles);\n                originalEllipsoid.otherEllipsoidAnglesToThisEllipsoidAngles(workEllipsoid, workAngles, originalAngles);\n                p.thetaRadians = originalAngles.longitudeRadians;\n                p.phiRadians = originalAngles.latitudeRadians;\n                p.evaluateDerivativesAtCurrentAngles(originalEllipsoid);\n            }\n            return solver._pathPoints;\n        }\n        return numConverged > 0 ? solver._pathPoints : undefined;\n    }\n    createInitialPointsAndTridiagonalSystem(numEdges) {\n        if (numEdges < 2)\n            numEdges = 2;\n        let f, thetaRadians;\n        for (let i = 0; i <= numEdges; i++) {\n            f = i / numEdges;\n            thetaRadians = this._defaultArc.sweep.fractionToRadians(f);\n            const p = new GeodesicPathPoint();\n            p.thetaRadians = thetaRadians;\n            p.phiRadians = 0.0;\n            this._pathPoints.push(p);\n        }\n        this._tridiagonalSolver = new TriDiagonalSystem(this._pathPoints.length);\n    }\n    applyUpdate(maxDPhiRadians) {\n        let dPhiMax = 0;\n        for (let i = 0; i < this._pathPoints.length; i++) {\n            const dPhi = Geometry.clampToStartEnd(this._tridiagonalSolver.getX(i), -maxDPhiRadians, maxDPhiRadians);\n            this._pathPoints[i].phiRadians -= dPhi;\n            dPhiMax = Geometry.maxAbsXY(dPhiMax, dPhi);\n        }\n        return dPhiMax;\n    }\n    /**\n     * Set up a step with specified ellipsoid.\n     * * ASSUME angles in _pathPoints are valid on given ellipsoid.\n     * @param ellipsoid\n     */\n    setupStep(ellipsoid) {\n        for (const p of this._pathPoints) {\n            p.evaluateDerivativesAtCurrentAngles(ellipsoid);\n        }\n        const lastRow = this._pathPoints.length - 1;\n        // first and last points get trivial dPhi=0 equations:\n        this._tridiagonalSolver.reset();\n        this._tridiagonalSolver.addToRow(0, 0, 1, 0);\n        this._tridiagonalSolver.addToB(0, 0);\n        this._tridiagonalSolver.addToRow(lastRow, 0, 1, 0);\n        this._tridiagonalSolver.addToB(lastRow, 0);\n        // interior points get proper newton equations\n        const values = new Float64Array(4);\n        for (let i = 1; i < lastRow; i++) {\n            GeodesicPathPoint.evaluateNewtonFunction(this._pathPoints[i - 1], this._pathPoints[i], this._pathPoints[i + 1], values);\n            this._tridiagonalSolver.addToRow(i, values[1], values[2], values[3]);\n            this._tridiagonalSolver.addToB(i, values[0]);\n        }\n    }\n    solve() {\n        return this._tridiagonalSolver.factorAndBackSubstitute();\n    }\n    /**\n     * Construct various section arcs (on the ellipsoid), using planes that (a) pass through the two given points and (b) have in-plane vector sampled between the normals of the two points.\n     * * Each candidate ellipse has is in a plane with ellipsoid normal at vector constructed \"between\" the endpoint normals.\n     * * The intermediate construction is by interpolation between stated fractions (which maybe outside 0 to 1)\n     * @param ellipsoid\n     * @param angleA start point of all candidates\n     * @param angleB end point of all candidates\n     * @param numSample number of ellipses to construct as candidates.\n     * @param normalInterpolationFraction0\n     * @param normalInterpolationFraction1\n     */\n    static approximateMinimumLengthSectionArc(ellipsoid, angleA, angleB, numSample, normalInterpolationFraction0, normalInterpolationFraction1) {\n        numSample = Geometry.clampToStartEnd(numSample, 2, 200);\n        const normalA = ellipsoid.radiansToUnitNormalRay(angleA.longitudeRadians, angleA.latitudeRadians);\n        const normalB = ellipsoid.radiansToUnitNormalRay(angleB.longitudeRadians, angleB.latitudeRadians);\n        if (normalA !== undefined && normalB !== undefined) {\n            let normalC;\n            let resultArc;\n            let lengthC;\n            let fractionC;\n            for (let i = 1; i <= numSample; i++) {\n                const f = Geometry.interpolate(normalInterpolationFraction0, i / numSample, normalInterpolationFraction1);\n                normalC = normalA.direction.interpolate(f, normalB.direction, normalC);\n                const candidateArc = ellipsoid.createSectionArcPointPointVectorInPlane(angleA, angleB, normalC);\n                if (candidateArc !== undefined) {\n                    const candidateLength = candidateArc.curveLength();\n                    if (lengthC === undefined || candidateLength < lengthC) {\n                        lengthC = candidateLength;\n                        resultArc = candidateArc;\n                        fractionC = f;\n                    }\n                }\n            }\n            if (resultArc !== undefined && fractionC !== undefined)\n                return { minLengthArc: resultArc, minLengthNormalInterpolationFraction: fractionC };\n        }\n        return undefined;\n    }\n}\n//# sourceMappingURL=Ellipsoid.js.map",
      "start": 1693508122302,
      "end": 1693508122369,
      "sourcemaps": null
    }
  ]
}
