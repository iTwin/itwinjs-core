{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/common/lib/esm/Image.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Rendering\n */\n/** Format of an [[ImageBuffer]].\n * The format determines how many bytes are allocated for each pixel in the buffer and the semantics of each byte.\n * @see [[ImageBuffer.getNumBytesPerPixel]]\n * @public\n * @extensions\n */\nexport var ImageBufferFormat;\n(function (ImageBufferFormat) {\n    /** RGBA format - 4 bytes per pixel. */\n    ImageBufferFormat[ImageBufferFormat[\"Rgba\"] = 0] = \"Rgba\";\n    /** RGB format - 3 bytes per pixel. */\n    ImageBufferFormat[ImageBufferFormat[\"Rgb\"] = 2] = \"Rgb\";\n    /** 1 byte per pixel. */\n    ImageBufferFormat[ImageBufferFormat[\"Alpha\"] = 5] = \"Alpha\";\n})(ImageBufferFormat || (ImageBufferFormat = {}));\n/** Uncompressed rectangular bitmap image data.\n * @public\n */\nexport class ImageBuffer {\n    /** Return the number of bytes allocated for each pixel. */\n    get numBytesPerPixel() { return ImageBuffer.getNumBytesPerPixel(this.format); }\n    /** Determine the number of bytes allocated to a single pixel for the specified format. */\n    static getNumBytesPerPixel(format) {\n        switch (format) {\n            case ImageBufferFormat.Alpha: return 1;\n            case ImageBufferFormat.Rgb: return 3;\n            default: return 4;\n        }\n    }\n    /** Get the height of this image in pixels. */\n    get height() { return ImageBuffer.computeHeight(this.data, this.format, this.width); }\n    /** Create a new ImageBuffer.\n     * @note The ImageBuffer takes ownership of the input Uint8Array.\n     * @param data The uncompressed image bytes. Must be a multiple of the width times the number of bytes per pixel specified by the format.\n     * @param format The format of the image.\n     * @param width The width of the image in pixels.\n     * @returns A new ImageBuffer.\n     * @throws Error if the length of the Uint8Array is not appropriate for the specified width and format.\n     */\n    static create(data, format, width) {\n        if (!this.isValidData(data, format, width))\n            throw new Error(\"The number of bytes supplied for ImageBuffer do not match its width and format.\");\n        return new ImageBuffer(data, format, width);\n    }\n    /** @internal */\n    static isValidData(data, format, width) {\n        const height = this.computeHeight(data, format, width);\n        return width > 0 && height > 0 && Math.floor(width) === width && Math.floor(height) === height;\n    }\n    /** @internal */\n    static computeHeight(data, format, width) {\n        return data.length / (width * this.getNumBytesPerPixel(format));\n    }\n    /** @internal */\n    constructor(data, format, width) {\n        this.data = data;\n        this.format = format;\n        this.width = width;\n    }\n}\n/** Returns whether the input is a power of two.\n * @note Floating point inputs are truncated.\n * @public\n */\nexport function isPowerOfTwo(num) {\n    return 0 === (num & (num - 1));\n}\n/** Returns the first power-of-two value greater than or equal to the input.\n * @note Floating point inputs are truncated.\n * @public\n */\nexport function nextHighestPowerOfTwo(num) {\n    --num;\n    for (let i = 1; i < 32; i <<= 1)\n        num = num | num >> i;\n    return num + 1;\n}\n/** The format of an ImageSource.\n * @public\n * @extensions\n */\nexport var ImageSourceFormat;\n(function (ImageSourceFormat) {\n    /** Image data is stored with JPEG compression. */\n    ImageSourceFormat[ImageSourceFormat[\"Jpeg\"] = 0] = \"Jpeg\";\n    /** Image data is stored with PNG compression. */\n    ImageSourceFormat[ImageSourceFormat[\"Png\"] = 2] = \"Png\";\n    /** Image is stored as an Svg stream.\n     * @note SVG is only valid for ImageSources in JavaScript. It *may not* be used for persistent textures.\n     */\n    ImageSourceFormat[ImageSourceFormat[\"Svg\"] = 3] = \"Svg\";\n})(ImageSourceFormat || (ImageSourceFormat = {}));\n/** @internal */\nexport function isValidImageSourceFormat(format) {\n    switch (format) {\n        case ImageSourceFormat.Jpeg:\n        case ImageSourceFormat.Png:\n        case ImageSourceFormat.Svg:\n            return true;\n        default:\n            return false;\n    }\n}\n/** Image data encoded and compressed in either Jpeg or Png format.\n * @public\n */\nexport class ImageSource {\n    /** Construct a new ImageSource, which takes ownership of the Uint8Array. */\n    constructor(data, format) {\n        this.data = data;\n        this.format = format;\n    }\n}\n//# sourceMappingURL=Image.js.map",
      "start": 1693508120631,
      "end": 1693508120721,
      "sourcemaps": null
    }
  ]
}
