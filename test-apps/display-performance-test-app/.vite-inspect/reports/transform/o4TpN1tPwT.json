{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tile/map/ImageryProviders/ArcGisGeometryRenderer.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/** Internal implementation of [[ArcGisGeometryRenderer]]\n * @internal\n */\nexport class ArcGisGeometryBaseRenderer {\n    constructor(world2PixelTransform) {\n        this._transform = world2PixelTransform;\n    }\n    get transform() { return this._transform; }\n    /**\n     * Render a path on the renderer's context.\n     * Note: Inputs are designed based on the PBF format, to avoid any data transformation.\n     * @param geometryLengths  Array be used to determine the start and end of each sub-path / rings. (i.e. [5,5] =  two rings of 5 vertices)\n     * @param geometryCoords Array that linearly encodes the vertices of each sub-path of a polyline / ring of a polygon\n     * @param fill Indicates if the path should be filled or not.\n     * @param stride Dimension of each vertices (i.e. 2 or 3.  3 could be X,Y,Z, X,YM) Currently 3rd dimension is ignored.\n    */\n    async renderPath(geometryLengths, geometryCoords, fill, stride, relativeCoords) {\n        if (stride < 2 || stride > 3) {\n            return;\n        }\n        // Keep track of our position in the in the 'coords' array:\n        // Every time we loop on the 'lengths' array, the position\n        // to start reading vertices in the 'coords' must be the sum of all previously read vertices.\n        let coordsOffset = 0;\n        // Begin the path here.\n        // Note: Even though path is closed inside the 'geometryLengths' loop,\n        //       it's import to begin the path only once.\n        this.beginPath();\n        for (const vertexCount of geometryLengths) {\n            let lastPtX = 0, lastPtY = 0;\n            for (let vertexIdx = 0; vertexIdx < vertexCount; vertexIdx++) {\n                let pX = geometryCoords[coordsOffset + (vertexIdx * stride)];\n                let pY = geometryCoords[coordsOffset + (vertexIdx * stride) + 1];\n                if (vertexIdx === 0) {\n                    // first vertex is always \"absolute\" and must be drawn as 'moveTo' (i.e. not lineTo)\n                    if (relativeCoords) {\n                        lastPtX = pX;\n                        lastPtY = pY;\n                    }\n                    if (this._transform) {\n                        const transformedPoint = this._transform.multiplyPoint2d({ x: pX, y: pY });\n                        pX = transformedPoint.x;\n                        pY = transformedPoint.y;\n                    }\n                    this.moveTo(pX, pY);\n                }\n                else {\n                    // Following vertices are relative to the previous one (sadly not really well documented by ESRI)\n                    // typically this happens when 'coordinates quantization' is active (i.e. no client side transformation is needed)\n                    if (relativeCoords) {\n                        pX = lastPtX = lastPtX + pX;\n                        pY = lastPtY = lastPtY + pY;\n                    }\n                    if (this._transform) {\n                        const transformedPoint = this._transform.multiplyPoint2d({ x: pX, y: pY });\n                        pX = transformedPoint.x;\n                        pY = transformedPoint.y;\n                    }\n                    this.lineTo(pX, pY);\n                }\n            }\n            coordsOffset += stride * vertexCount;\n            if (fill) {\n                // ClosePath but do not 'fill' here, only at the very end (otherwise it will mess up holes)\n                this.closePath();\n            }\n        }\n        if (fill) {\n            await this.fill();\n        }\n        await this.stroke(); // draw line path or polygon outline\n    }\n    /**\n     * Render a point on the renderer's context.\n     * Note: Inputs are designed based on the PBF format, to avoid any data transformation.\n     * @param geometryLengths  Array be used to determine the start and end of each multi-point array, empty for single point.\n     * @param geometryCoords Array that linearly encodes vertices.\n     * @param stride Dimension of each vertices (i.e. 2 or 3.  3 could be X,Y,Z, X,YM) Currently 3rd dimension is ignored.\n    */\n    async renderPoint(geometryLengths, geometryCoords, stride, relativeCoords) {\n        if (stride < 2 || stride > 3) {\n            return;\n        }\n        let coordsOffset = 0;\n        if (geometryLengths.length === 0) {\n            // Strangely, for points, 'lengths' array is empty, so we assume there is a single vertex in 'coords' array.\n            if (geometryCoords.length >= stride) {\n                if (this._transform) {\n                    const transformedPoint = this._transform.multiplyPoint2d({ x: geometryCoords[0], y: geometryCoords[1] });\n                    this.drawPoint(transformedPoint.x, transformedPoint.y);\n                }\n                else {\n                    this.drawPoint(geometryCoords[0], geometryCoords[1]);\n                }\n            }\n        }\n        else {\n            // MULTI-POINTS: Needs testing\n            // I assume 'lengths' array will get populated and 'coords' array will look similar to line/polygons.\n            for (const vertexCount of geometryLengths) {\n                let lastPtX = 0, lastPtY = 0;\n                for (let vertexIdx = 0; vertexIdx < vertexCount; vertexIdx++) {\n                    let pX = geometryCoords[coordsOffset + (vertexIdx * stride)];\n                    let pY = geometryCoords[coordsOffset + (vertexIdx * stride) + 1];\n                    if (relativeCoords) {\n                        pX = lastPtX = lastPtX + pX;\n                        pY = lastPtY = lastPtY + pY;\n                    }\n                    if (this._transform) {\n                        const transformedPoint = this._transform.multiplyPoint2d({ x: pX, y: pY });\n                        pX = transformedPoint.x;\n                        pY = transformedPoint.y;\n                    }\n                    this.drawPoint(pX, pY);\n                }\n                coordsOffset += stride * vertexCount;\n            }\n        }\n        await this.finishPoints();\n    }\n}\n//# sourceMappingURL=ArcGisGeometryRenderer.js.map",
      "start": 1693508121740,
      "end": 1693508121868,
      "sourcemaps": null
    }
  ]
}
