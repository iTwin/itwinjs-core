{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/glsl/Thematic.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { ThematicDisplayMode, ThematicGradientMode } from \"@itwin/core-common\";\nimport { System } from \"../System\";\nimport { addRenderPass } from \"./RenderPass\";\nimport { addInstancedRtcMatrix, addProjectionMatrix } from \"./Vertex\";\nimport { TextureUnit } from \"../RenderFlags\";\nimport { addEyeSpace } from \"./Common\";\nconst getSensorFloat = `\r\nvec4 getSensor(int index) {\r\n  float x = 0.5;\r\n  float y = (float(index) + 0.5) / float(u_numSensors);\r\n  return TEXTURE(s_sensorSampler, vec2(x, y));\r\n}\r\n`;\n// Access a gradient texture at the specified index.\n// A stepped gradient texture is arranged with single unique color pixels for each step. The dimension of a stepped gradient texture is stepCount.\n// A smooth gradient texture is arranged with blended color pixels across the entire span of the texture. The dimension of a smooth gradient texture is the system's maximum texture size.\nconst getColor = `\r\nvec3 getColor(float ndx) {\r\n  if (ndx < 0.0 || ndx > 1.0)\r\n    return u_marginColor;\r\n\r\n  return TEXTURE(s_texture, vec2(0.0, ndx)).rgb;\r\n}\r\n`;\n// Access a stepped gradient texture at the specified index taking into account isolines.\n// The texture format is exactly as described above for stepped mode.  We just access the gradient differently,\n// specifically to ensure that the texels sampled result in lines of overall singular colors - no stepping into the\n// neighboring bands.\nconst getIsoLineColor = `\r\nvec3 getIsoLineColor(float ndx, float stepCount) {\r\n  if (ndx < 0.01 || ndx > 0.99)\r\n    return u_marginColor;\r\n\r\n  ndx += 0.5 / stepCount; // center on step pixels\r\n  return TEXTURE(s_texture, vec2(0.0, ndx)).rgb;\r\n}\r\n`;\nconst fwidth = `\\nfloat _universal_fwidth(float coord) { return fwidth(coord); }\\n`;\nconst slopeAndHillShadeShader = ` else if (kThematicDisplayMode_Slope == u_thematicDisplayMode) {\r\n    float d = dot(g_normal, u_thematicAxis);\r\n    if (d < 0.0)\r\n      d = -d;\r\n\r\n    // The range of d is now 0 to 1 (90 degrees to 0 degrees).\r\n    // However, the range from 0 to 1 is not linear. Therefore, we use acos() to find the actual angle in radians.\r\n    d = acos(d);\r\n\r\n    // range of d is currently 1.5708 to 0 radians.\r\n    if (d < u_thematicRange.x || d > u_thematicRange.y)\r\n      d = -1.0; // use marginColor if outside the requested range\r\n    else { // convert d from radians to 0 to 1 using requested range\r\n      d -= u_thematicRange.x;\r\n      d /= (u_thematicRange.y - u_thematicRange.x);\r\n    }\r\n\r\n    ndx = d;\r\n  } else if (kThematicDisplayMode_HillShade == u_thematicDisplayMode) {\r\n    float d = dot(g_normal, u_thematicSunDirection);\r\n\r\n    ndx = max(0.0, d);\r\n  }`;\n// Access the appropriate gradient texel for a particular index based on display mode and gradient mode.\nconst applyThematicColorPrelude = `\r\n  float ndx = v_thematicIndex;\r\n\r\n  if (kThematicDisplayMode_InverseDistanceWeightedSensors == u_thematicDisplayMode) {\r\n    float sensorSum = 0.0;\r\n    float contributionSum = 0.0;\r\n\r\n    vec3 sensorPos;\r\n    float sensorValue;\r\n    float sensorWeight;\r\n\r\n    ndx = -1.0; // default index = marginColor\r\n\r\n    float distanceCutoff = u_thematicSettings.y;\r\n\r\n    for (int i = 0; i < 8192; i++) { // ###TODO: set maximum number of sensors during an incremental form of shader construction\r\n      if (i >= u_numSensors)\r\n        break;\r\n\r\n      vec4 sensor = getSensor(i);\r\n\r\n      float dist = distance(v_eyeSpace, sensor.xyz);\r\n\r\n      bool skipThisSensor = (distanceCutoff > 0.0 && dist > distanceCutoff);\r\n      if (!skipThisSensor) {\r\n        float contribution = 1.0 / pow(dist, 2.0);\r\n        sensorSum += sensor.w * contribution;\r\n        contributionSum += contribution;\r\n      }\r\n    }\r\n\r\n    if (contributionSum > 0.0) // avoid division by zero\r\n      ndx = sensorSum / contributionSum;\r\n  }`;\nconst applyThematicColorPostlude = `\r\n  float gradientMode = u_thematicSettings.x;\r\n  float stepCount = u_thematicSettings.z;\r\n\r\n  vec4 rgba = vec4((kThematicGradientMode_IsoLines == gradientMode) ? getIsoLineColor(ndx, stepCount) : getColor(ndx), baseColor.a);\r\n  rgba = mix(rgba, baseColor, u_thematicColorMix);\r\n\r\n  if (kThematicGradientMode_IsoLines == gradientMode) {\r\n    float coord = v_thematicIndex * stepCount;\r\n    float line = abs(fract(coord - 0.5) - 0.5) / _universal_fwidth(coord);\r\n    rgba.a = 1.0 - min(line, 1.0);\r\n    if (u_discardBetweenIsolines && 0.0 == rgba.a)\r\n      discard;\r\n  } else if (kThematicGradientMode_SteppedWithDelimiter == gradientMode) {\r\n    float coord = v_thematicIndex * stepCount;\r\n    float line = abs(fract(coord - 0.5) - 0.5) / _universal_fwidth(coord);\r\n    float value = min(line, 1.0);\r\n    rgba.rgb *= value;\r\n  }\r\n\r\n  return rgba;\r\n`;\n// fwidth does not function for point clouds, so we work around the limitation with a less-than-ideal rendering of isolines and delimiters\n// using a tolerance not based on neighboring fragments.\nconst delimiterToleranceForPointClouds = `0.025`; // / (stepCount * 40.0)`;\nconst applyThematicColorPostludeForPointClouds = `\r\n  float gradientMode = u_thematicSettings.x;\r\n  float stepCount = u_thematicSettings.z;\r\n\r\n  vec4 rgba = vec4((kThematicGradientMode_IsoLines == gradientMode) ? getIsoLineColor(ndx, stepCount) : getColor(ndx), baseColor.a);\r\n  rgba = mix(rgba, baseColor, u_thematicColorMix);\r\n\r\n  if (kThematicGradientMode_IsoLines == gradientMode) {\r\n    float coord = v_thematicIndex * stepCount;\r\n    float line = abs(fract(coord - 0.5) - 0.5);\r\n    if (line > ${delimiterToleranceForPointClouds})\r\n      discard;\r\n  } else if (kThematicGradientMode_SteppedWithDelimiter == gradientMode) {\r\n    float coord = v_thematicIndex * stepCount;\r\n    float line = abs(fract(coord - 0.5) - 0.5);\r\n    float value = min(line, 1.0);\r\n    if (line < ${delimiterToleranceForPointClouds} && value < 1.0)\r\n      rgba.rgb *= 0.0;\r\n  }\r\n\r\n  return rgba;\r\n`;\nfunction _getShader(isPointCloud) {\n    return isPointCloud ?\n        applyThematicColorPrelude + applyThematicColorPostludeForPointClouds : // do not include slope and hillshade for point clouds\n        applyThematicColorPrelude + slopeAndHillShadeShader + applyThematicColorPostlude; // include all modes for everything else\n}\n// Compute the value for the varying to be interpolated to the fragment shader in order to access the color in the thematic gradient texture\n// We will project a vector onto another vector using this equation: proju = (v . u) / (v . v) * v\nexport function getComputeThematicIndex(instanced, skipSlopeAndHillShade, decodeNormal) {\n    const modelPos = instanced ? \"(g_instancedRtcMatrix * rawPosition)\" : \"rawPosition\";\n    const heightMode = `\r\n  if (kThematicDisplayMode_Height == u_thematicDisplayMode) {\r\n    vec3 u = (u_modelToWorld * ${modelPos}).xyz;\r\n    vec3 v = u_thematicAxis;\r\n    vec3 proju = (dot(v, u) / dot(v, v)) * v;\r\n    vec3 a = v * u_thematicRange.s;\r\n    vec3 b = v * u_thematicRange.t;\r\n    vec3 c = proju;\r\n    v_thematicIndex = findFractionalPositionOnLine(a, b, c);\r\n  }`;\n    const hillShadeMode = ` else if (kThematicDisplayMode_HillShade == u_thematicDisplayMode) {\r\n    v_thematicIndex = computeSurfaceNormal().z;\r\n  }`;\n    const hillShadeMode2 = ` else if (kThematicDisplayMode_HillShade == u_thematicDisplayMode) {\r\n    v_thematicIndex = g_hillshadeIndex;\r\n  }`;\n    return skipSlopeAndHillShade ? heightMode : heightMode + (decodeNormal ? hillShadeMode : hillShadeMode2);\n}\n// Determine the fractional position of c on line segment ab.  Assumes the three points are aligned on the same axis.\nconst findFractionalPositionOnLine = `\r\n  float abDist = distance(a, b);\r\n  return dot(b - a, c - a) / (abDist * abDist);\r\n`;\nfunction addThematicDisplayModeConstants(builder) {\n    builder.addDefine(\"kThematicDisplayMode_Height\", ThematicDisplayMode.Height.toFixed(1));\n    builder.addDefine(\"kThematicDisplayMode_InverseDistanceWeightedSensors\", ThematicDisplayMode.InverseDistanceWeightedSensors.toFixed(1));\n    builder.addDefine(\"kThematicDisplayMode_Slope\", ThematicDisplayMode.Slope.toFixed(1));\n    builder.addDefine(\"kThematicDisplayMode_HillShade\", ThematicDisplayMode.HillShade.toFixed(1));\n}\nfunction addThematicGradientModeConstants(builder) {\n    builder.addDefine(\"kThematicGradientMode_Smooth\", ThematicGradientMode.Smooth.toFixed(1));\n    builder.addDefine(\"kThematicGradientMode_Stepped\", ThematicGradientMode.Stepped.toFixed(1));\n    builder.addDefine(\"kThematicGradientMode_SteppedWithDelimiter\", ThematicGradientMode.SteppedWithDelimiter.toFixed(1));\n    builder.addDefine(\"kThematicGradientMode_IsoLines\", ThematicGradientMode.IsoLines.toFixed(1));\n}\n/** @internal */\nexport function addThematicDisplay(builder, isForPointClouds = false, isForTerrainMesh = false) {\n    const frag = builder.frag;\n    const vert = builder.vert;\n    addRenderPass(builder.frag);\n    if (!isForPointClouds && !isForTerrainMesh)\n        addProjectionMatrix(vert);\n    addEyeSpace(builder);\n    if (vert.usesInstancedGeometry)\n        addInstancedRtcMatrix(vert);\n    vert.addFunction(\"float findFractionalPositionOnLine(vec3 a, vec3 b, vec3 c)\", findFractionalPositionOnLine);\n    vert.addUniform(\"u_modelToWorld\", 7 /* VariableType.Mat4 */, (prog) => {\n        prog.addGraphicUniform(\"u_modelToWorld\", (uniform, params) => {\n            params.target.uniforms.branch.bindModelToWorldTransform(uniform, params.geometry, false);\n        });\n    });\n    builder.addUniform(\"u_thematicRange\", 3 /* VariableType.Vec2 */, (prog) => {\n        prog.addGraphicUniform(\"u_thematicRange\", (uniform, params) => {\n            params.target.uniforms.thematic.bindRange(uniform);\n        });\n    });\n    builder.addUniform(\"u_thematicAxis\", 4 /* VariableType.Vec3 */, (prog) => {\n        prog.addGraphicUniform(\"u_thematicAxis\", (uniform, params) => {\n            params.target.uniforms.thematic.bindAxis(uniform);\n        });\n    });\n    if (!isForPointClouds) {\n        builder.addUniform(\"u_thematicSunDirection\", 4 /* VariableType.Vec3 */, (prog) => {\n            prog.addGraphicUniform(\"u_thematicSunDirection\", (uniform, params) => {\n                params.target.uniforms.thematic.bindSunDirection(uniform);\n            });\n        });\n    }\n    addThematicGradientModeConstants(builder.frag);\n    addThematicDisplayModeConstants(builder.frag);\n    addThematicDisplayModeConstants(builder.vert);\n    builder.addUniform(\"u_thematicDisplayMode\", 2 /* VariableType.Float */, (prog) => {\n        prog.addGraphicUniform(\"u_thematicDisplayMode\", (uniform, params) => {\n            params.target.uniforms.thematic.bindDisplayMode(uniform);\n        });\n    });\n    frag.addUniform(\"u_marginColor\", 4 /* VariableType.Vec3 */, (prog) => {\n        prog.addGraphicUniform(\"u_marginColor\", (uniform, params) => {\n            params.target.uniforms.thematic.bindMarginColor(uniform);\n        });\n    });\n    // gradientMode, distanceCutoff, stepCount\n    builder.addUniform(\"u_thematicSettings\", 4 /* VariableType.Vec3 */, (prog) => {\n        prog.addGraphicUniform(\"u_thematicSettings\", (uniform, params) => {\n            params.target.uniforms.thematic.bindFragSettings(uniform);\n        });\n    });\n    if (isForPointClouds || isForTerrainMesh) {\n        builder.frag.addUniform(\"u_thematicColorMix\", 2 /* VariableType.Float */, (prog) => {\n            prog.addGraphicUniform(\"u_thematicColorMix\", (uniform, params) => {\n                uniform.setUniform1f(params.target.uniforms.thematic.thematicDisplay?.gradientSettings.colorMix || 0.0);\n            });\n        });\n    }\n    else {\n        builder.frag.addUniform(\"u_thematicColorMix\", 2 /* VariableType.Float */, (prog) => {\n            prog.addGraphicUniform(\"u_thematicColorMix\", (uniform, _params) => {\n                uniform.setUniform1f(0.0);\n            });\n        });\n    }\n    frag.addUniform(\"u_numSensors\", 1 /* VariableType.Int */, (prog) => {\n        prog.addGraphicUniform(\"u_numSensors\", (uniform, params) => {\n            if (params.target.wantThematicSensors) {\n                if (params.target.uniforms.thematic.wantGlobalSensorTexture)\n                    params.target.uniforms.thematic.bindNumSensors(uniform);\n                else // we are batching separate sensor textures per-tile; use the number of sensors from the batch\n                    params.target.uniforms.batch.bindNumThematicSensors(uniform);\n            }\n            else {\n                uniform.setUniform1i(0);\n            }\n        });\n    });\n    frag.addUniform(\"s_sensorSampler\", 8 /* VariableType.Sampler2D */, (prog) => {\n        prog.addGraphicUniform(\"s_sensorSampler\", (uniform, params) => {\n            if (params.target.wantThematicSensors) {\n                if (params.target.uniforms.thematic.wantGlobalSensorTexture) {\n                    params.target.uniforms.thematic.bindSensors(uniform);\n                }\n                else { // we are batching separate sensor textures per-tile; bind the batch's sensor texture\n                    params.target.uniforms.batch.bindThematicSensors(uniform);\n                }\n            }\n            else {\n                System.instance.ensureSamplerBound(uniform, TextureUnit.ThematicSensors);\n            }\n        });\n    });\n    if (!isForPointClouds) { // allows us to know when to discard between isolines to make them pickable\n        builder.frag.addUniform(\"u_discardBetweenIsolines\", 0 /* VariableType.Boolean */, (prog) => {\n            prog.addProgramUniform(\"u_discardBetweenIsolines\", (uniform, params) => {\n                uniform.setUniform1i(params.target.isReadPixelsInProgress ? 1 : 0);\n            });\n        });\n    }\n    frag.addFunction(fwidth);\n    frag.addFunction(getSensorFloat);\n    frag.addFunction(getColor);\n    frag.addFunction(getIsoLineColor);\n    frag.set(7 /* FragmentShaderComponent.ApplyThematicDisplay */, _getShader(isForPointClouds));\n}\n//# sourceMappingURL=Thematic.js.map",
      "start": 1693508125160,
      "end": 1693508125351,
      "sourcemaps": null
    }
  ]
}
