{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/bentley/lib/esm/ByteStream.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Utils\n */\nimport { assert } from \"./Assert\";\nimport { Id64 } from \"./Id\";\n/** Allows the contents of an [ArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer)\n * to be consumed sequentially using methods to extract\n * data of a particular type from the bytes beginning at the current read position.\n * Methods and properties beginning with 'read' and taking no arguments consume data at the current read position and advance it\n * by the size of the data read. The read position can also be directly adjusted by the caller.\n * @public\n */\nexport class ByteStream {\n    /** Construct a new ByteStream with the read position set to the beginning.\n     * @param buffer The underlying buffer from which data is to be extracted.\n     * @param subView If defined, specifies the subset of the underlying buffer's data to use.\n     * This constructor is subject to two common mistakes:\n     *\n     * 1. Given `bytes: Uint8Array`, `new ByteStream(bytes)` will compile but at run-time will produce an error asserting that\n     * the DataView constructor requires an ArrayBuffer. The correct usage is `new ByteStream(bytes.buffer)`.\n     * 2. Given `bytes: Uint8Array`, `new ByteStream(bytes.buffer)` creates a stream for the entire range of bytes represented by the underlying\n     * ArrayBuffer. If `bytes` represents only a **sub-range** of the underlying buffer's data, the results will be unexpected unless the optional `subView`\n     * argument is supplied, with correct offset and length.\n     *\n     * For both of the above reasons, prefer to use [[fromUint8Array]].\n     * @deprecated in 3.x. Use [[fromUint8Array]] or [[fromArrayBuffer]].\n     */\n    constructor(buffer, subView) {\n        this._curPos = 0;\n        if (undefined !== subView) {\n            this._view = new DataView(buffer, subView.byteOffset, subView.byteLength);\n            this._byteOffset = subView.byteOffset;\n        }\n        else {\n            this._view = new DataView(buffer);\n            this._byteOffset = 0;\n        }\n    }\n    /** Construct a new ByteStream for the range of bytes represented by `bytes`, which may be a subset of the range of bytes\n     * represented by the underlying ArrayBuffer. The read position will be set to the beginning of the range of bytes.\n     */\n    static fromUint8Array(bytes) {\n        const { byteOffset, byteLength } = bytes;\n        return new ByteStream(bytes.buffer, { byteOffset, byteLength }); // eslint-disable-line deprecation/deprecation\n    }\n    /** Construct a new ByteStream with the read position set to the beginning.\n     * @param buffer The underlying buffer from which data is to be extracted.\n     * @param subView If defined, specifies the subset of the underlying buffer's data to use.\n     */\n    static fromArrayBuffer(buffer, subView) {\n        return new ByteStream(buffer, subView); // eslint-disable-line deprecation/deprecation\n    }\n    /** The number of bytes in this stream */\n    get length() {\n        return this._view.byteLength;\n    }\n    /** The number of bytes remaining to be read, from [[curPos]] to the end of the stream. */\n    get remainingLength() {\n        return this.length - this.curPos;\n    }\n    /** Returns true if the current read position has been advanced past the end of the stream. This generally indicates that an attempt was made to read more data than is available.\n     * @see [[isAtTheEnd]]\n     */\n    get isPastTheEnd() {\n        return this.curPos > this.length;\n    }\n    /** Returns true if the current read position has advanced precisely to the end of the stream, indicating all of the data has been consumed.\n     * @see [[isPastTheEnd]].\n     */\n    get isAtTheEnd() {\n        return this.curPos === this.length;\n    }\n    /** The current read position as an index into the stream of bytes. */\n    get curPos() { return this._curPos; }\n    set curPos(pos) {\n        this._curPos = pos;\n        assert(!this.isPastTheEnd);\n    }\n    /** Adds the specified number of bytes to the current read position */\n    advance(numBytes) {\n        this.curPos = (this.curPos + numBytes);\n        return !this.isPastTheEnd;\n    }\n    /** Subtracts the specified number of bytes from the current read position */\n    rewind(numBytes) {\n        if (this.curPos - numBytes < 0)\n            return false;\n        this.curPos = this.curPos - numBytes;\n        return true;\n    }\n    /** Resets the current read position to the beginning of the stream */\n    reset() { this.curPos = 0; }\n    /** Read a unsigned 8-bit integer from the current read position and advance by 1 byte. */\n    readUint8() { return this.read(1, (view) => view.getUint8(this.curPos)); }\n    /** Read an unsigned 16-bit integer from the current read position and advance by 2 bytes. */\n    readUint16() { return this.read(2, (view) => view.getUint16(this.curPos, true)); }\n    /** Read an unsigned 32-bit integer from the current read position and advance by 4 bytes. */\n    readUint32() { return this.read(4, (view) => view.getUint32(this.curPos, true)); }\n    /** Read a signed 32-bit integer from the current read position and advance by 4 bytes. */\n    readInt32() { return this.read(4, (view) => view.getInt32(this.curPos, true)); }\n    /** Read a 32-bit floating point number from the current read position and advance by 4 bytes. */\n    readFloat32() { return this.read(4, (view) => view.getFloat32(this.curPos, true)); }\n    /** Read a 64-bit floating point number from the current read position and advance by 8 bytes. */\n    readFloat64() { return this.read(8, (view) => view.getFloat64(this.curPos, true)); }\n    /** Read an unsigned 64-bit integer from the current read position, advance by 8 bytes, and return the 64-bit value as an Id64String. */\n    readId64() { return Id64.fromUint32Pair(this.readUint32(), this.readUint32()); }\n    /** Read an unsigned 24-bit integer from the current read position and advance by 3 bytes. */\n    readUint24() { return this.readUint8() | (this.readUint8() << 8) | (this.readUint8() << 16); }\n    /** @deprecated in 3.x. use [[readUint8]]. */\n    get nextUint8() { return this.readUint8(); }\n    /** @deprecated in 3.x. use [[readUint16]]. */\n    get nextUint16() { return this.readUint16(); }\n    /** @deprecated in 3.x. use [[readUint32]]. */\n    get nextUint32() { return this.readUint32(); }\n    /** @deprecated in 3.x. use [[readInt32]]. */\n    get nextInt32() { return this.readInt32(); }\n    /** @deprecated in 3.x. use [[readFloat32]]. */\n    get nextFloat32() { return this.readFloat32(); }\n    /** @deprecated in 3.x. use [[readFloat64]]. */\n    get nextFloat64() { return this.readFloat64(); }\n    /** @deprecated in 3.x. use [[readId64]]. */\n    get nextId64() { return this.readId64(); }\n    /** @deprecated in 3.x. use [[readUint32]]. */\n    get nextUint24() { return this.readUint24(); }\n    /** Read the specified number of bytes beginning at the current read position into a Uint8Array and advance by the specified number of byte.\n     * @param numBytes The number of bytes to read.\n     */\n    nextBytes(numBytes) {\n        const bytes = new Uint8Array(this.arrayBuffer, this.curPos + this._byteOffset, numBytes);\n        this.advance(numBytes);\n        return bytes;\n    }\n    /** Read the specified number of bytes at the specified offset without changing the read position. */\n    readBytes(readPos, numBytes) {\n        return new Uint8Array(this.arrayBuffer, readPos + this._byteOffset, numBytes);\n    }\n    /** Read the specified number of unsigned 32-bit integers from the current read position and advance the read position. */\n    nextUint32s(numUint32s) {\n        const numBytes = numUint32s * 4;\n        const uint32s = new Uint32Array(this.arrayBuffer, this.curPos + this._byteOffset, numUint32s);\n        this.advance(numBytes);\n        return uint32s;\n    }\n    /** Returns the underlying array buffer */\n    get arrayBuffer() { return this._view.buffer; }\n    read(numBytes, read) {\n        const result = read(this._view);\n        this.advance(numBytes);\n        return result;\n    }\n}\n//# sourceMappingURL=ByteStream.js.map",
      "start": 1693508120086,
      "end": 1693508120422,
      "sourcemaps": null
    }
  ]
}
