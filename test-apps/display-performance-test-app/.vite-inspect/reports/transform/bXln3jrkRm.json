{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/geometry3d/Matrix3d.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module CartesianGeometry\n */\nimport { AxisIndex, AxisOrder, Geometry, StandardViewIndex } from \"../Geometry\";\nimport { Point4d } from \"../geometry4d/Point4d\";\nimport { Angle } from \"./Angle\";\nimport { Point2d } from \"./Point2dVector2d\";\nimport { Point3d, Vector3d } from \"./Point3dVector3d\";\nimport { Transform } from \"./Transform\";\n/* eslint-disable @itwin/prefer-get */\n// cSpell:words XXYZ YXYZ ZXYZ SaeedTorabi arctan newcommand diagonalization\n/**\n * PackedMatrix3dOps contains static methods for matrix operations where the matrix is a Float64Array.\n * * The Float64Array contains the matrix entries in row-major order\n * @internal\n * ```\n * equation\n * \\newcommand[1]\\mij{#1_{00}\\ #1_{01}\\ a_{02}}\n * ```\n */\nexport class PackedMatrix3dOps {\n    /**\n     * Load 9 doubles into the packed format.\n     * @param dest destination, allocated by caller\n     * @param a00 row 0, column 0 entry\n     * @param a01 row 0, column 1 entry\n     * @param a02 row 0, column 2 entry\n     * @param a10 row 1, column 0 entry\n     * @param a11 row 1, column 1 entry\n     * @param a12 row 1, column 2 entry\n     * @param a20 row 2, column 0 entry\n     * @param a21 row 2, column 1 entry\n     * @param a22 row 2, column 2 entry\n     */\n    static loadMatrix(dest, a00, a01, a02, a10, a11, a12, a20, a21, a22) {\n        dest[0] = a00;\n        dest[1] = a01;\n        dest[2] = a02;\n        dest[3] = a10;\n        dest[4] = a11;\n        dest[5] = a12;\n        dest[6] = a20;\n        dest[7] = a21;\n        dest[8] = a22;\n    }\n    /**\n     * Multiply 3x3 matrix `a*b`, store in `result`.\n     * * All params assumed length 9, allocated by caller.\n     * * c may alias either input.\n     */\n    static multiplyMatrixMatrix(a, b, result) {\n        if (!result)\n            result = new Float64Array(9);\n        PackedMatrix3dOps.loadMatrix(result, (a[0] * b[0] + a[1] * b[3] + a[2] * b[6]), (a[0] * b[1] + a[1] * b[4] + a[2] * b[7]), (a[0] * b[2] + a[1] * b[5] + a[2] * b[8]), (a[3] * b[0] + a[4] * b[3] + a[5] * b[6]), (a[3] * b[1] + a[4] * b[4] + a[5] * b[7]), (a[3] * b[2] + a[4] * b[5] + a[5] * b[8]), (a[6] * b[0] + a[7] * b[3] + a[8] * b[6]), (a[6] * b[1] + a[7] * b[4] + a[8] * b[7]), (a[6] * b[2] + a[7] * b[5] + a[8] * b[8]));\n        return result;\n    }\n    /**\n     * Multiply 3x3 matrix `a*bTranspose`, store in `result`.\n     * * All params assumed length 9, allocated by caller.\n     * * c may alias either input.\n     */\n    static multiplyMatrixMatrixTranspose(a, b, result) {\n        if (!result)\n            result = new Float64Array(9);\n        PackedMatrix3dOps.loadMatrix(result, (a[0] * b[0] + a[1] * b[1] + a[2] * b[2]), (a[0] * b[3] + a[1] * b[4] + a[2] * b[5]), (a[0] * b[6] + a[1] * b[7] + a[2] * b[8]), (a[3] * b[0] + a[4] * b[1] + a[5] * b[2]), (a[3] * b[3] + a[4] * b[4] + a[5] * b[5]), (a[3] * b[6] + a[4] * b[7] + a[5] * b[8]), (a[6] * b[0] + a[7] * b[1] + a[8] * b[2]), (a[6] * b[3] + a[7] * b[4] + a[8] * b[5]), (a[6] * b[6] + a[7] * b[7] + a[8] * b[8]));\n        return result;\n    }\n    /**\n     * Multiply 3x3 matrix `aTranspose*b`, store in `result`.\n     * * All params assumed length 9, allocated by caller.\n     * * c may alias either input.\n     */\n    static multiplyMatrixTransposeMatrix(a, b, result) {\n        if (!result)\n            result = new Float64Array(9);\n        PackedMatrix3dOps.loadMatrix(result, (a[0] * b[0] + a[3] * b[3] + a[6] * b[6]), (a[0] * b[1] + a[3] * b[4] + a[6] * b[7]), (a[0] * b[2] + a[3] * b[5] + a[6] * b[8]), (a[1] * b[0] + a[4] * b[3] + a[7] * b[6]), (a[1] * b[1] + a[4] * b[4] + a[7] * b[7]), (a[1] * b[2] + a[4] * b[5] + a[7] * b[8]), (a[2] * b[0] + a[5] * b[3] + a[8] * b[6]), (a[2] * b[1] + a[5] * b[4] + a[8] * b[7]), (a[2] * b[2] + a[5] * b[5] + a[8] * b[8]));\n        return result;\n    }\n    /** Transpose 3x3 matrix `a` in place */\n    static transposeInPlace(a) {\n        let q = a[1];\n        a[1] = a[3];\n        a[3] = q;\n        q = a[2];\n        a[2] = a[6];\n        a[6] = q;\n        q = a[5];\n        a[5] = a[7];\n        a[7] = q;\n    }\n    /**\n     * Returns the transpose of 3x3 matrix `a`\n     * * If `dest` is passed as argument, then the function copies the transpose of 3x3 matrix `a` into `dest`\n     * * `a` is not changed unless also passed as the dest, i.e., copyTransposed(a,a) transposes `a` in place\n     */\n    static copyTransposed(a, dest) {\n        if (dest === a) {\n            PackedMatrix3dOps.transposeInPlace(dest);\n        }\n        else {\n            if (!dest)\n                dest = new Float64Array(9);\n            dest[0] = a[0];\n            dest[1] = a[3];\n            dest[2] = a[6];\n            dest[3] = a[1];\n            dest[4] = a[4];\n            dest[5] = a[7];\n            dest[6] = a[2];\n            dest[7] = a[5];\n            dest[8] = a[8];\n        }\n        return dest;\n    }\n    /** Copy matrix `a` entries into `dest` */\n    static copy(a, dest) {\n        if (dest !== a) {\n            dest[0] = a[0];\n            dest[1] = a[1];\n            dest[2] = a[2];\n            dest[3] = a[3];\n            dest[4] = a[4];\n            dest[5] = a[5];\n            dest[6] = a[6];\n            dest[7] = a[7];\n            dest[8] = a[8];\n        }\n        return dest;\n    }\n}\n/** A Matrix3d is tagged indicating one of the following states:\n * * unknown: it is not know if the matrix is invertible.\n * * inverseStored: the matrix has its inverse stored.\n * * singular: the matrix is known to be singular.\n * @public\n */\nexport var InverseMatrixState;\n(function (InverseMatrixState) {\n    /**\n     * The invertibility of the `coffs` array has not been determined.\n     * Any `inverseCoffs` contents are random.\n     */\n    InverseMatrixState[InverseMatrixState[\"unknown\"] = 0] = \"unknown\";\n    /**\n     * An inverse was computed and stored as the `inverseCoffs`\n     */\n    InverseMatrixState[InverseMatrixState[\"inverseStored\"] = 1] = \"inverseStored\";\n    /**\n     * The `coffs` array is known to be singular.\n     * Any `inverseCoffs` contents are random.\n     */\n    InverseMatrixState[InverseMatrixState[\"singular\"] = 2] = \"singular\";\n})(InverseMatrixState || (InverseMatrixState = {}));\n/** A Matrix3d is a 3x3 matrix.\n * * A very common use is to hold a rigid body rotation (which has no scaling or skew), but the 3x3 contents can\n * also hold scaling and skewing.\n * * The matrix with 2-dimensional layout (note: a 2d array can be shown by a matrix)\n * ```\n * equation\n *      \\matrixXY{A}\n * ```\n * is stored as 9 numbers in \"row-major\" order in a `Float64Array`, viz\n * ```\n * equation\n *      \\rowMajorMatrixXY{A}\n * ```\n * * If the matrix inverse is known it is stored in the inverseCoffs array.\n * * The inverse status (`unknown`, `inverseStored`, `singular`) status is indicated by the `inverseState` property.\n * * Construction methods that are able to trivially construct the inverse, store it immediately and note that in\n * the inverseState.\n * * Constructions (e.g. createRowValues) for which the inverse is not immediately known mark the inverseState as\n * unknown.\n * * Later queries for the inverse, trigger full computation if needed at that time.\n * * Most matrix queries are present with both \"column\" and \"row\" variants.\n * * Usage elsewhere in the library is typically \"column\" based.  For example, in a Transform that carries a\n * coordinate frame, the matrix columns are the unit vectors for the axes.\n * @public\n */\nclass Matrix3d {\n    /** The identity Matrix3d. Value is frozen and cannot be modified. */\n    static get identity() {\n        if (undefined === this._identity) {\n            this._identity = Matrix3d.createIdentity();\n            this._identity.freeze();\n        }\n        return this._identity;\n    }\n    /** Freeze this Matrix3d. */\n    freeze() {\n        this.computeCachedInverse(true);\n        /*\n        hm.. can't freeze the Float64Arrays..\n        Object.freeze(this.coffs);\n        if (this.inverseCoffs)\n          Object.freeze(this.inverseCoffs);\n        */\n        return Object.freeze(this);\n    }\n    /**\n     * Constructor\n     * @param coffs optional coefficient array.\n     * * **WARNING:** coffs is captured (i.e., is now owned by the Matrix3d object and can be modified by it).\n     */\n    constructor(coffs) {\n        this.coffs = coffs ? coffs : new Float64Array(9);\n        this.inverseCoffs = undefined;\n        this.inverseState = InverseMatrixState.unknown;\n    }\n    /**\n     * Return a json object containing the 9 numeric entries as a single array in row major order,\n     * `[ [1, 2, 3],[ 4, 5, 6], [7, 8, 9] ]`\n     */\n    toJSON() {\n        return [[this.coffs[0], this.coffs[1], this.coffs[2]],\n            [this.coffs[3], this.coffs[4], this.coffs[5]],\n            [this.coffs[6], this.coffs[7], this.coffs[8]]];\n    }\n    /**\n     * Copy data from various input forms to this matrix.\n     * The source can be:\n     * * Another `Matrix3d`\n     * * An array of 3 arrays, each of which has the 3 numbers for a row of the matrix.\n     * * An array of 4 or 9 numbers in row major order.\n     * * **WARNING:** if json is an array of numbers but size is not 4 or 9, the matrix is set to zeros.\n     */\n    setFromJSON(json) {\n        this.inverseCoffs = undefined;\n        // if no json is passed\n        if (!json) {\n            this.setRowValues(0, 0, 0, 0, 0, 0, 0, 0, 0);\n            return;\n        }\n        // if json is Matrix3d\n        if (!Array.isArray(json)) {\n            if (json instanceof Matrix3d)\n                this.setFrom(json);\n            return;\n        }\n        // if json is Matrix3dProps and is an array of arrays\n        if (Geometry.isArrayOfNumberArray(json, 3, 3)) {\n            const data = json;\n            this.setRowValues(data[0][0], data[0][1], data[0][2], data[1][0], data[1][1], data[1][2], data[2][0], data[2][1], data[2][2]);\n            return;\n        }\n        // if json is Matrix3dProps and is an array of numbers\n        if (json.length === 9) {\n            const data = json;\n            this.setRowValues(data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8]);\n            return;\n        }\n        else if (json.length === 4) {\n            const data = json;\n            this.setRowValues(data[0], data[1], 0, data[2], data[3], 0, 0, 0, 1);\n            return;\n        }\n        // if json is Matrix3dProps but is not the right size\n        this.setRowValues(0, 0, 0, 0, 0, 0, 0, 0, 0);\n        return;\n    }\n    /** Return a new Matrix3d constructed from contents of the json value. See `setFromJSON` for layout rules */\n    static fromJSON(json) {\n        const result = Matrix3d.createIdentity();\n        result.setFromJSON(json);\n        return result;\n    }\n    /**\n     * Test if `this` and `other` are within tolerance in all numeric entries.\n     * @param tol optional tolerance for comparisons by Geometry.isDistanceWithinTol\n     */\n    isAlmostEqual(other, tol) {\n        return Geometry.isDistanceWithinTol(this.maxDiff(other), tol);\n    }\n    /**\n     * Test if `this` and `other` are within tolerance in the column entries specified by `columnIndex`.\n     * @param tol optional tolerance for comparisons by Geometry.isDistanceWithinTol\n     */\n    isAlmostEqualColumn(columnIndex, other, tol) {\n        const max = Geometry.maxAbsXYZ(this.coffs[columnIndex] - other.coffs[columnIndex], this.coffs[columnIndex + 3] - other.coffs[columnIndex + 3], this.coffs[columnIndex + 6] - other.coffs[columnIndex + 6]);\n        return Geometry.isDistanceWithinTol(max, tol);\n    }\n    /**\n     * Test if column (specified by `columnIndex`) entries of `this` and [ax,ay,az] are within tolerance.\n     * @param tol optional tolerance for comparisons by Geometry.isDistanceWithinTol\n     */\n    isAlmostEqualColumnXYZ(columnIndex, ax, ay, az, tol) {\n        const max = Geometry.maxAbsXYZ(this.coffs[columnIndex] - ax, this.coffs[columnIndex + 3] - ay, this.coffs[columnIndex + 6] - az);\n        return Geometry.isDistanceWithinTol(max, tol);\n    }\n    /**\n     * Test if `this` and `other` have almost equal Z column and have X and Y columns differing only by a\n     * rotation of the same angle around that Z.\n     * * **WARNING:** X and Y columns have to be perpendicular to Z column in both `this` and `other`.\n     * @param tol optional tolerance for comparisons by Geometry.isDistanceWithinTol\n     */\n    isAlmostEqualAllowZRotation(other, tol) {\n        if (this.isAlmostEqual(other, tol))\n            return true;\n        if (this.isAlmostEqualColumn(AxisIndex.Z, other, tol)) {\n            const radians = Angle.radiansBetweenVectorsXYZ(this.coffs[0], this.coffs[3], this.coffs[6], other.coffs[0], other.coffs[3], other.coffs[6]);\n            const angle = Angle.createRadians(radians); // angle between X columns in `this` and `other`\n            const columnX = this.columnX();\n            const columnY = this.columnY();\n            const columnZ = this.columnZ();\n            /**\n             * Here we rotate this.columnX() around this.columnZ() by \"angle\" and expect to get other.columnX().\n             * Then we rotate this.columnY() around this.columnZ() by the same \"angle\" and if we get other.columnY(),\n             * that means `this` and `other` have X and Y columns differing only by a rotation around column Z.\n             */\n            let column = Vector3d.createRotateVectorAroundVector(columnX, columnZ, angle);\n            if (other.isAlmostEqualColumnXYZ(0, column.x, column.y, column.z, tol)) {\n                column = Vector3d.createRotateVectorAroundVector(columnY, columnZ, angle);\n                return other.isAlmostEqualColumnXYZ(1, column.x, column.y, column.z, tol);\n            }\n        }\n        return false;\n    }\n    /** Test for exact (bitwise) equality with other. */\n    isExactEqual(other) {\n        return this.maxDiff(other) === 0.0;\n    }\n    /** test if all entries in the z row and column are exact 001, i.e. the matrix only acts in 2d */\n    get isXY() {\n        return this.coffs[2] === 0.0\n            && this.coffs[5] === 0.0\n            && this.coffs[6] === 0.0\n            && this.coffs[7] === 0.0\n            && this.coffs[8] === 1.0;\n    }\n    /**\n     * If result is not provided, then the method returns a new (zeroed) matrix; otherwise the result is\n     * not zeroed first and is just returned as-is.\n     */\n    static _create(result) {\n        return result ? result : new Matrix3d();\n    }\n    /**\n     * Returns a Matrix3d populated by numeric values given in row-major order.\n     * Sets all entries in the matrix from call parameters appearing in row-major order, i.e.\n     * ```\n     * equation\n     * \\begin{bmatrix}a_{xx}\\ a_{xy}\\ a_{xz}\\\\ a_{yx}\\ a_{yy}\\ a_{yz}\\\\ a_{zx}\\ a_{zy}\\ a_{zz}\\end{bmatrix}\n     * ```\n     * @param axx Row x, column x(0, 0) entry\n     * @param axy Row x, column y(0, 1) entry\n     * @param axz Row x, column z(0, 2) entry\n     * @param ayx Row y, column x(1, 0) entry\n     * @param ayy Row y, column y(1, 1) entry\n     * @param ayz Row y, column z(1, 2) entry\n     * @param azx Row z, column x(2, 0) entry\n     * @param azy Row z, column y(2, 2) entry\n     * @param azz row z, column z(2, 3) entry\n     */\n    static createRowValues(axx, axy, axz, ayx, ayy, ayz, azx, azy, azz, result) {\n        result = result ? result : new Matrix3d();\n        result.inverseState = InverseMatrixState.unknown;\n        result.coffs[0] = axx;\n        result.coffs[1] = axy;\n        result.coffs[2] = axz;\n        result.coffs[3] = ayx;\n        result.coffs[4] = ayy;\n        result.coffs[5] = ayz;\n        result.coffs[6] = azx;\n        result.coffs[7] = azy;\n        result.coffs[8] = azz;\n        return result;\n    }\n    /**\n     * Create a Matrix3d with caller-supplied coefficients and optional inverse coefficients.\n     * * The inputs are captured into (i.e., owned by) the new Matrix3d.\n     * * The caller is responsible for validity of the inverse coefficients.\n     * @param coffs (required) array of 9 coefficients.\n     * @param inverseCoffs (optional) array of 9 coefficients.\n     * @returns a Matrix3d populated by a coffs array.\n     */\n    static createCapture(coffs, inverseCoffs) {\n        const result = new Matrix3d(coffs);\n        if (inverseCoffs) {\n            result.inverseCoffs = inverseCoffs;\n            result.inverseState = InverseMatrixState.inverseStored;\n        }\n        else {\n            result.inverseState = InverseMatrixState.unknown;\n        }\n        return result;\n    }\n    /**\n     * Create a matrix by distributing vectors to columns in one of 6 orders.\n     * @param axisOrder identifies where the columns are placed.\n     * @param columnA vector to place in the column specified by first letter in the AxisOrder name.\n     * @param columnB vector to place in the column specified by second letter in the AxisOrder name.\n     * @param columnC vector to place in the column specified by third letter in the AxisOrder name.\n     * @param result optional result matrix3d\n     * * Example: If you pass AxisOrder.YZX, then result will be [columnC, columnA, columnB] because\n     * first letter Y means columnA should go to the second column, second letter Z means columnB should\n     * go to the third column, and third letter X means columnC should go to the first column.\n     */\n    static createColumnsInAxisOrder(axisOrder, columnA, columnB, columnC, result) {\n        if (!result)\n            result = new Matrix3d();\n        if (axisOrder === AxisOrder.YZX) {\n            result.setColumns(columnC, columnA, columnB);\n        }\n        else if (axisOrder === AxisOrder.ZXY) {\n            result.setColumns(columnB, columnC, columnA);\n        }\n        else if (axisOrder === AxisOrder.XZY) {\n            result.setColumns(columnA, columnC, columnB);\n        }\n        else if (axisOrder === AxisOrder.YXZ) {\n            result.setColumns(columnB, columnA, columnC);\n        }\n        else if (axisOrder === AxisOrder.ZYX) {\n            result.setColumns(columnC, columnB, columnA);\n        }\n        else { // AxisOrder.XYZ\n            result.setColumns(columnA, columnB, columnC);\n        }\n        return result;\n    }\n    /**\n     * Create the inverseCoffs member (filled with zeros)\n     * This is for use by matrix * matrix multiplications which need to be sure the member is there to be\n     * filled with method-specific content.\n     */\n    createInverseCoffsWithZeros() {\n        if (!this.inverseCoffs) {\n            this.inverseState = InverseMatrixState.unknown;\n            this.inverseCoffs = new Float64Array(9);\n        }\n    }\n    /**\n     * Copy the transpose of the coffs to the inverseCoffs.\n     * * Mark the matrix as inverseStored.\n     */\n    setupInverseTranspose() {\n        const coffs = this.coffs;\n        this.inverseState = InverseMatrixState.inverseStored;\n        this.inverseCoffs = Float64Array.from([\n            coffs[0], coffs[3], coffs[6],\n            coffs[1], coffs[4], coffs[7],\n            coffs[2], coffs[5], coffs[8],\n        ]);\n    }\n    /**\n     * Set all entries in the matrix from call parameters appearing in row-major order.\n     * @param axx Row x, column x (0,0) entry\n     * @param axy Row x, column y (0,1) entry\n     * @param axz Row x, column z (0,2) entry\n     * @param ayx Row y, column x (1,0) entry\n     * @param ayy Row y, column y (1,1) entry\n     * @param ayz Row y, column z (1,2) entry\n     * @param azx Row z, column x (2,0) entry\n     * @param azy Row z, column y (2,2) entry\n     * @param azz row z, column z (2,3) entry\n     */\n    setRowValues(axx, axy, axz, ayx, ayy, ayz, azx, azy, azz) {\n        this.coffs[0] = axx;\n        this.coffs[1] = axy;\n        this.coffs[2] = axz;\n        this.coffs[3] = ayx;\n        this.coffs[4] = ayy;\n        this.coffs[5] = ayz;\n        this.coffs[6] = azx;\n        this.coffs[7] = azy;\n        this.coffs[8] = azz;\n        this.inverseState = InverseMatrixState.unknown;\n    }\n    /** Set the matrix to an identity. */\n    setIdentity() {\n        this.setRowValues(1, 0, 0, 0, 1, 0, 0, 0, 1);\n        this.setupInverseTranspose();\n    }\n    /** Set the matrix to all zeros. */\n    setZero() {\n        this.setRowValues(0, 0, 0, 0, 0, 0, 0, 0, 0);\n        this.inverseState = InverseMatrixState.singular;\n    }\n    /** Copy contents from the `other` matrix. If `other` is undefined, use identity matrix. */\n    setFrom(other) {\n        if (other === undefined) {\n            this.setIdentity();\n            return;\n        }\n        if (other !== this) {\n            for (let i = 0; i < 9; i++)\n                this.coffs[i] = other.coffs[i];\n            if (other.inverseState === InverseMatrixState.inverseStored && other.inverseCoffs !== undefined) {\n                this.createInverseCoffsWithZeros();\n                for (let i = 0; i < 9; i++)\n                    this.inverseCoffs[i] = other.inverseCoffs[i];\n                this.inverseState = InverseMatrixState.inverseStored;\n            }\n            else if (other.inverseState !== InverseMatrixState.inverseStored) {\n                this.inverseState = other.inverseState;\n            }\n            else { // This is reached when other says stored but does not have coffs. This should not happen.\n                this.inverseState = InverseMatrixState.unknown;\n            }\n        }\n    }\n    /**\n     * Return a clone of this matrix.\n     * * Coefficients are copied.\n     * * Inverse coefficients and inverse status are copied if stored by `this`.\n     */\n    clone(result) {\n        result = result ? result : new Matrix3d();\n        result.setFrom(this);\n        return result;\n    }\n    /**\n     * Create a matrix with all zeros.\n     * * Note that for geometry transformations \"all zeros\" is not a useful default state.\n     * * Hence, almost always use `createIdentity` for graphics transformations.\n     * * \"All zeros\" is appropriate for summing moment data.\n     * ```\n     * equation\n     * \\begin{bmatrix}0 & 0 & 0 \\\\ 0 & 0 & 0 \\\\ 0 & 0 & 0\\end{bmatrix}\n     * ```\n     */\n    static createZero() {\n        const retVal = new Matrix3d();\n        retVal.inverseState = InverseMatrixState.singular;\n        return retVal;\n    }\n    /**\n     * Create an identity matrix.\n     * * All diagonal entries (xx,yy,zz) are one\n     * * All others are zero.\n     * * This (rather than \"all zeros\") is the useful state for most graphics transformations.\n     * ```\n     * equation\n     * \\begin{bmatrix}1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1\\end{bmatrix}\n     * ```\n     *\n     */\n    static createIdentity(result) {\n        result = result ? result : new Matrix3d();\n        result.setIdentity();\n        return result;\n    }\n    /**\n     * Create a matrix with distinct x,y,z diagonal (scale) entries.\n     * ```\n     * equation\n     * \\begin{bmatrix}s_x & 0 & 0 \\\\ 0 & s_y & 0\\\\ 0 & 0 & s_z\\end{bmatrix}\n     * ```\n     */\n    static createScale(scaleFactorX, scaleFactorY, scaleFactorZ, result) {\n        if (result)\n            result.setZero();\n        else\n            result = new Matrix3d();\n        result.coffs[0] = scaleFactorX;\n        result.coffs[4] = scaleFactorY;\n        result.coffs[8] = scaleFactorZ;\n        if (scaleFactorX === 0 || scaleFactorY === 0 || scaleFactorZ === 0) {\n            result.inverseState = InverseMatrixState.singular;\n        }\n        else {\n            result.inverseState = InverseMatrixState.inverseStored;\n            result.inverseCoffs = Float64Array.from([1 / scaleFactorX, 0, 0,\n                0, 1 / scaleFactorY, 0,\n                0, 0, 1 / scaleFactorZ]);\n        }\n        return result;\n    }\n    /**\n     * Create a matrix with uniform scale factors for scale factor \"s\"\n     * ```\n     * equation\n     * \\begin{bmatrix}s & 0 & 0 \\\\ 0 & s & 0\\\\ 0 & 0 & s\\end{bmatrix}\n     * ```\n     */\n    static createUniformScale(scaleFactor) {\n        return Matrix3d.createScale(scaleFactor, scaleFactor, scaleFactor);\n    }\n    /**\n     * Return a vector that is perpendicular to the input `vectorA`.\n     * * Among the infinite number of perpendiculars possible, this method favors having one in the xy plane.\n     * * Hence, when `vectorA` is close to the Z axis, the returned vector is `vectorA cross -unitY`\n     * but when `vectorA` is NOT close to the Z axis, the returned vector is `unitZ cross vectorA`.\n     */\n    static createPerpendicularVectorFavorXYPlane(vectorA, result) {\n        const a = vectorA.magnitude();\n        const scale = 64.0; // A constant from the dawn of time in the CAD industry\n        const b = a / scale;\n        // if vectorA is close to the Z axis\n        if (Math.abs(vectorA.x) < b && Math.abs(vectorA.y) < b) {\n            return Vector3d.createCrossProduct(vectorA.x, vectorA.y, vectorA.z, 0, -1, 0, result);\n        }\n        // if vectorA is NOT close to the Z axis\n        return Vector3d.createCrossProduct(0, 0, 1, vectorA.x, vectorA.y, vectorA.z, result);\n    }\n    /**\n     * Return a vector that is perpendicular to the input `vectorA`.\n     * * Among the infinite number of perpendiculars possible, this method favors having one near the plane\n     * containing Z.\n     * That is achieved by cross product of `this` vector with the result of createPerpendicularVectorFavorXYPlane.\n     */\n    static createPerpendicularVectorFavorPlaneContainingZ(vectorA, result) {\n        /**\n         * vectorA, result (below), and \"vectorA cross result\" form a coordinate system where \"result\" is located on\n         * the XY-plane. Once you've got a coordinate system with an axis in the XY-plane, your other two axes form\n         * a plane that includes the z-axis.\n         */\n        result = Matrix3d.createPerpendicularVectorFavorXYPlane(vectorA, result);\n        return vectorA.crossProduct(result, result);\n    }\n    /**\n     * Create a matrix from column vectors, shuffled into place per axisOrder\n     * * For example, if axisOrder = XYZ then it returns [vectorU, vectorV, vectorW]\n     * * Another example, if axisOrder = YZX then it returns [vectorW, vectorU, vectorV] because\n     * Y is at index 0 so vectorU goes to the column Y (column 2), Z is at index 1 so vectorV goes\n     * to the column Z (column 3), and X is at index 2 so vectorW goes to the column X (column 1)\n     */\n    static createShuffledColumns(vectorU, vectorV, vectorW, axisOrder, result) {\n        const target = Matrix3d._create(result);\n        target.setColumn(Geometry.axisOrderToAxis(axisOrder, 0), vectorU);\n        target.setColumn(Geometry.axisOrderToAxis(axisOrder, 1), vectorV);\n        target.setColumn(Geometry.axisOrderToAxis(axisOrder, 2), vectorW);\n        return target;\n    }\n    /**\n     * Create a new orthogonal matrix (perpendicular columns, unit length, transpose is inverse).\n     * * `vectorA1 = Normalized vectorA` is placed in the column specified by **first** letter in\n     * the AxisOrder name.\n     * * Normalized `vectorC1 = vectorA1 cross vectorB` is placed in the column specified by **third**\n     * letter in the AxisOrder name.\n     * * Normalized  `vectorC1 cross vectorA` is placed in the column specified by **second**\n     * letter in the AxisOrder name.\n     * * This function internally uses createShuffledColumns.\n     */\n    static createRigidFromColumns(vectorA, vectorB, axisOrder, result) {\n        const vectorA1 = vectorA.normalize();\n        if (vectorA1) {\n            const vectorC1 = vectorA1.unitCrossProduct(vectorB);\n            if (vectorC1) {\n                const vectorB1 = vectorC1.unitCrossProduct(vectorA);\n                if (vectorB1) {\n                    const retVal = Matrix3d.createShuffledColumns(vectorA1, vectorB1, vectorC1, axisOrder, result);\n                    retVal.setupInverseTranspose();\n                    return retVal;\n                }\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Construct a rigid matrix (orthogonal matrix with +1 determinant) using vectorA and its 2 perpendicular.\n     * * If axisOrder is not passed then `AxisOrder = AxisOrder.ZXY` is used as default.\n     * * This function internally uses createPerpendicularVectorFavorXYPlane and createRigidFromColumns.\n     * * If you want to rotate a given plane (which contains (0,0,0)) to the xy-plane, pass the normal vector of\n     * your plane into createRigidHeadsUp. The transpose of the returned Matrix3d can be used to rotate your plane\n     * to the xy-plane. If plane does not contain (0,0,0) then the plane is rotated to a plane parallel to the xy-plane.\n     * * Visualization can be found at https://www.itwinjs.org/sandbox/SaeedTorabi/2PerpendicularVectorsTo1Vector\n     */\n    static createRigidHeadsUp(vectorA, axisOrder = AxisOrder.ZXY, result) {\n        const vectorB = Matrix3d.createPerpendicularVectorFavorXYPlane(vectorA);\n        const matrix = Matrix3d.createRigidFromColumns(vectorA, vectorB, axisOrder, result);\n        if (matrix) {\n            matrix.setupInverseTranspose();\n            return matrix;\n        }\n        return Matrix3d.createIdentity(result);\n    }\n    /**\n     * Return the matrix for rotation of `angle` around desired `axis`\n     * * Visualization can be found at https://www.itwinjs.org/sandbox/SaeedTorabi/CubeRotationAroundAnAxis\n     * @param axis the axis of rotation\n     * @param angle the angle of rotation\n     * @param result caller-allocated matrix (optional)\n     * @returns the `rotation matrix` or `undefined` (if axis magnitude is near zero).\n     */\n    static createRotationAroundVector(axis, angle, result) {\n        // Rodriguez formula (matrix form), https://mathworld.wolfram.com/RodriguesRotationFormula.html\n        const c = angle.cos();\n        const s = angle.sin();\n        const v = 1.0 - c;\n        const unit = axis.normalize();\n        if (unit) {\n            const retVal = Matrix3d.createRowValues(unit.x * unit.x * v + c, unit.x * unit.y * v - s * unit.z, unit.x * unit.z * v + s * unit.y, unit.y * unit.x * v + s * unit.z, unit.y * unit.y * v + c, unit.y * unit.z * v - s * unit.x, unit.z * unit.x * v - s * unit.y, unit.z * unit.y * v + s * unit.x, unit.z * unit.z * v + c, result);\n            retVal.setupInverseTranspose();\n            return retVal;\n        }\n        return undefined;\n    }\n    /** Returns a rotation of specified angle around one of the main axis (X,Y,Z).\n     * @param axisIndex index of axis (AxisIndex.X, AxisIndex.Y, AxisIndex.Z) kept fixed by the rotation.\n     * @param angle angle of rotation\n     * @param result optional result matrix.\n     * * Math details of 3d rotation matrices derivation can be found at docs/learning/geometry/Angle.md\n     */\n    static createRotationAroundAxisIndex(axisIndex, angle, result) {\n        const c = angle.cos();\n        const s = angle.sin();\n        let myResult;\n        if (axisIndex === AxisIndex.X) {\n            myResult = Matrix3d.createRowValues(1, 0, 0, 0, c, -s, 0, s, c, result);\n        }\n        else if (axisIndex === AxisIndex.Y) {\n            myResult = Matrix3d.createRowValues(c, 0, s, 0, 1, 0, -s, 0, c, result);\n        }\n        else {\n            myResult = Matrix3d.createRowValues(c, -s, 0, s, c, 0, 0, 0, 1, result);\n        }\n        myResult.setupInverseTranspose();\n        return myResult;\n    }\n    /**\n     * Replace current rows Ui and Uj with (c*Ui + s*Uj) and (c*Uj - s*Ui).\n     * * There is no checking for i,j being 0,1,2.\n     * * The instance matrix A is multiplied in place on the left by a Givens rotation G, resulting in the matrix G*A.\n     * @param i first row index. **must be 0,1,2** (unchecked)\n     * @param j second row index. **must be 0,1,2** (unchecked)\n     * @param c fist coefficient\n     * @param s second coefficient\n     */\n    applyGivensRowOp(i, j, c, s) {\n        let ii = 3 * i;\n        let jj = 3 * j;\n        const limit = ii + 3;\n        for (; ii < limit; ii++, jj++) {\n            const a = this.coffs[ii];\n            const b = this.coffs[jj];\n            this.coffs[ii] = a * c + b * s;\n            this.coffs[jj] = -a * s + b * c;\n        }\n    }\n    /**\n     * Replace current columns Ui and Uj with (c*Ui + s*Uj) and (c*Uj - s*Ui).\n     * * There is no checking for i,j being 0,1,2.\n     * * The instance matrix A is multiplied in place on the right by a Givens rotation G, resulting in the matrix A*G.\n     * * This is used in compute intensive inner loops\n     * @param i first row index. **must be 0,1,2** (unchecked)\n     * @param j second row index. **must be 0,1,2** (unchecked)\n     * @param c fist coefficient\n     * @param s second coefficient\n     */\n    applyGivensColumnOp(i, j, c, s) {\n        const limit = i + 9;\n        for (; i < limit; i += 3, j += 3) {\n            const a = this.coffs[i];\n            const b = this.coffs[j];\n            this.coffs[i] = a * c + b * s;\n            this.coffs[j] = -a * s + b * c;\n        }\n    }\n    /**\n     * Create a matrix from column vectors.\n     * ```\n     * equation\n     * \\begin{bmatrix}U_x & V_x & W_x \\\\ U_y & V_y & W_y \\\\ U_z & V_z & W_z \\end{bmatrix}\n     * ```\n     */\n    static createColumns(vectorU, vectorV, vectorW, result) {\n        return Matrix3d.createRowValues(vectorU.x, vectorV.x, vectorW.x, vectorU.y, vectorV.y, vectorW.y, vectorU.z, vectorV.z, vectorW.z, result);\n    }\n    /** Create a matrix with each column's _x,y_ parts given `XAndY` and separate numeric z values.\n     * ```\n     * equation\n     * \\begin{bmatrix}U_x & V_x & W_x \\\\ U_y & V_y & W_y \\\\ u & v & w \\end{bmatrix}\n     * ```\n     */\n    static createColumnsXYW(vectorU, u, vectorV, v, vectorW, w, result) {\n        return Matrix3d.createRowValues(vectorU.x, vectorV.x, vectorW.x, vectorU.y, vectorV.y, vectorW.y, u, v, w, result);\n    }\n    /**\n     * Create a matrix from \"as viewed\" right and up vectors.\n     * * ColumnX points in the rightVector direction.\n     * * ColumnY points in the upVector direction.\n     * * ColumnZ is a unit cross product of ColumnX and ColumnY.\n     * * Optionally rotate by 45 degrees around `upVector` to bring its left or right vertical edge to center.\n     * * Optionally rotate by arctan(1/sqrt(2)) ~ 35.264 degrees around `rightVector` to bring the top or bottom\n     * horizontal edge of the view to the center (for isometric views).\n     *\n     * This is expected to be used with various principal unit vectors that are perpendicular to each other.\n     * * STANDARD TOP VIEW: createViewedAxes(Vector3d.unitX(), Vector3d.unitY(), 0, 0)\n     * * STANDARD FRONT VIEW: createViewedAxes(Vector3d.unitX(), Vector3d.unitZ(), 0, 0)\n     * * STANDARD BACK VIEW: createViewedAxes(Vector3d.unitX(-1), Vector3d.unitZ(), 0, 0)\n     * * STANDARD RIGHT VIEW: createViewedAxes(Vector3d.unitY(), Vector3d.unitZ(), 0, 0)\n     * * STANDARD LEFT VIEW: createViewedAxes(Vector3d.unitY(-1), Vector3d.unitZ(), 0, 0)\n     * * STANDARD BOTTOM VIEW: createViewedAxes(Vector3d.unitX(), Vector3d.unitY(-1), 0, 0)\n     * * STANDARD ISO VIEW: createViewedAxes(Vector3d.unitX(), Vector3d.unitZ(), -1, 1)\n     * * STANDARD RIGHT ISO VIEW: createViewedAxes(Vector3d.unitX(), Vector3d.unitZ(), 1, 1)\n     * * Front, right, back, left, top, and bottom standard views are views from faces of the cube\n     * and iso and right iso standard views are views from corners of the cube.\n     * * Note: createViewedAxes is column-based so always returns local to world\n     *\n     * @param rightVector ColumnX of the returned matrix. Expected to be perpendicular to upVector.\n     * @param upVector ColumnY of the returned matrix. Expected to be perpendicular to rightVector.\n     * @param leftNoneRight Specifies the ccw rotation around `upVector` axis. Normally one of \"-1\", \"0\", and \"1\",\n     * where \"-1\" indicates rotation by 45 degrees to bring the left vertical edge to center, \"0\" means no rotation,\n     * and \"1\" indicates rotation by 45 degrees to bring the right vertical edge to center. Other numbers are\n     * used as multiplier for this 45 degree rotation.\n     * @param topNoneBottom Specifies the ccw rotation around `rightVector` axis. Normally one of \"-1\", \"0\", and \"1\",\n     * where \"-1\" indicates isometric rotation (35.264 degrees) to bring the bottom upward, \"0\" means no rotation,\n     * and \"1\" indicates isometric rotation (35.264 degrees) to bring the top downward. Other numbers are\n     * used as multiplier for the 35.264 degree rotation.\n     * @returns matrix = [rightVector, upVector, rightVector cross upVector] with the applied rotations specified\n     * by leftNoneRight and topNoneBottom. Returns undefined if rightVector and upVector are parallel.\n     */\n    static createViewedAxes(rightVector, upVector, leftNoneRight = 0, topNoneBottom = 0) {\n        const columnZ = rightVector.crossProduct(upVector);\n        if (columnZ.normalizeInPlace()) {\n            // matrix = [rightVector, upVector, rightVector cross upVector]\n            const matrix = Matrix3d.createColumns(rightVector, upVector, columnZ);\n            // \"45 degrees * leftNoneRight\" rotation around Y\n            if (leftNoneRight !== 0.0) {\n                let c = Math.sqrt(0.5);\n                let s = leftNoneRight < 0.0 ? -c : c;\n                if (Math.abs(leftNoneRight) !== 1.0) {\n                    const radians = Angle.degreesToRadians(45.0 * leftNoneRight);\n                    c = Math.cos(radians);\n                    s = Math.sin(radians);\n                }\n                matrix.applyGivensColumnOp(2, 0, c, s); // rotate around Y (equivalent to matrix*rotationY)\n            }\n            // \"35.264 degrees * topNoneBottom\" rotation around X\n            if (topNoneBottom !== 0.0) {\n                const theta = topNoneBottom * Math.atan(Math.sqrt(0.5));\n                const c = Math.cos(theta);\n                const s = Math.sin(theta);\n                matrix.applyGivensColumnOp(1, 2, c, -s); // rotate around X (equivalent to matrix*rotationX)\n            }\n            return matrix;\n        }\n        return undefined;\n    }\n    /**\n     * Create a rotation matrix for one of the 8 standard views.\n     * * Default is TOP view (`local X = world X`, `local Y = world Y`, `local Z = world Z`).\n     * * To change view from the TOP to one of the other 7 standard views, we need to multiply \"world data\" to\n     * the corresponding matrix1 provided by `createStandardWorldToView(index, false)` and then\n     * `matrix1.multiply(world data)` will return \"local data\".\n     * * To change view back to the TOP, we need to multiply \"local data\" to the corresponding matrix2 provided\n     * by `createStandardWorldToView(index, true)` and then `matrix2.multiply(local data)` will returns \"world data\".\n     * * Note: No matter how you rotate the world axis, local X is always pointing right, local Y is always pointing up,\n     * and local Z is always pointing toward you.\n     *\n     * @param index standard view index `StandardViewIndex.Top, Bottom, Left, Right, Front, Back, Iso, RightIso`\n     * @param invert if false (default), the return matrix is world to local (view) and if true, the the return\n     * matrix is local (view) to world.\n     * @param result optional result.\n     */\n    static createStandardWorldToView(index, invert = false, result) {\n        switch (index) {\n            // Start with TOP view, ccw rotation by 180 degrees around X\n            case StandardViewIndex.Bottom:\n                result = Matrix3d.createRowValues(1, 0, 0, 0, -1, 0, 0, 0, -1);\n                break;\n            // Start with TOP view, ccw rotation by -90 degrees around X and by 90 degrees around Z\n            case StandardViewIndex.Left:\n                result = Matrix3d.createRowValues(0, -1, 0, 0, 0, 1, -1, 0, 0);\n                break;\n            // Start with TOP view, ccw rotation by -90 degrees around X and by -90 degrees around Z\n            case StandardViewIndex.Right:\n                result = Matrix3d.createRowValues(0, 1, 0, 0, 0, 1, 1, 0, 0);\n                break;\n            // Start with TOP view, ccw rotation by -90 degrees around X\n            case StandardViewIndex.Front:\n                result = Matrix3d.createRowValues(1, 0, 0, 0, 0, 1, 0, -1, 0);\n                break;\n            // Start with TOP view, ccw rotation by -90 degrees around X and by 180 degrees around Z\n            case StandardViewIndex.Back:\n                result = Matrix3d.createRowValues(-1, 0, 0, 0, 0, 1, 0, 1, 0);\n                break;\n            /**\n             * Isometric view\n             * Start with FRONT view, ccw rotation by -45 degrees around Y and by arctan(1/sqrt(2)) ~ 35.264 degrees around X\n             * cos(45) = 1/sqrt(2) = 0.70710678118 and sin(45) = 1/sqrt(2) = 0.70710678118\n             * cos(35.264) = 2/sqrt(6) = 0.81649658092 and sin(35.264) = 1/sqrt(3) = 0.57735026919\n             * More info: https://en.wikipedia.org/wiki/Isometric_projection\n             */\n            case StandardViewIndex.Iso:\n                result = Matrix3d.createRowValues(0.707106781186548, -0.70710678118654757, 0.00000000000000000, 0.408248290463863, 0.40824829046386302, 0.81649658092772603, -0.577350269189626, -0.57735026918962573, 0.57735026918962573);\n                break;\n            // Start with FRONT view, ccw rotation by 45 degrees around Y and by 35.264 degrees around X\n            case StandardViewIndex.RightIso:\n                result = Matrix3d.createRowValues(0.707106781186548, 0.70710678118654757, 0.00000000000000000, -0.408248290463863, 0.40824829046386302, 0.81649658092772603, 0.577350269189626, -0.57735026918962573, 0.57735026918962573);\n                break;\n            // no rotation\n            case StandardViewIndex.Top:\n            default:\n                result = Matrix3d.createIdentity(result);\n        }\n        if (invert)\n            result.transposeInPlace(); // matrix is rigid so transpose and inverse are the same\n        return result;\n    }\n    /**\n     * Apply (in place) a jacobi eigenvalue algorithm.\n     * @param i row index of zeroed member\n     * @param j column index of zeroed member\n     * @param leftEigenvectors a matrix that its columns will be filled by the left eigenvectors of `this` Matrix3d\n     * (allocated by caller, computed and filled by this function). Note that columns of leftEigenVectors will be\n     * mutually perpendicular because `this` matrix is symmetric.\n     * @param lambda a matrix that its diagonal entries will be filled by eigenvalues and its non-diagonal elements\n     * converge to 0 (allocated by caller, computed and filled by this function).\n     */\n    applySymmetricJacobi(i, j, leftEigenvectors, lambda) {\n        const sii = lambda.at(i, i);\n        const sjj = lambda.at(j, j);\n        const sij = lambda.at(i, j);\n        if (Math.abs(sij) < Geometry.smallFloatingPoint * (sii + sjj))\n            return 0.0;\n        const jacobi = Angle.trigValuesToHalfAngleTrigValues(sii - sjj, 2.0 * sij);\n        const c = jacobi.c;\n        const s = jacobi.s;\n        /**\n         * The following check does not exist in applyFastSymmetricJacobi because here if we don't return\n         * early, the matrix remains untouched. However, applyFastSymmetricJacobi zeroes-out elements ij\n         * and ji. Therefore, if we return early in applyFastSymmetricJacobi, zeroing-out wont happen.\n         */\n        if (Math.abs(s) < 2.0e-15)\n            return 0.0;\n        /**\n         * If you apply the following 2 lines to a symmetric matrix, you get same lines used in\n         * applyFastSymmetricJacobi. There are 2 differences which make applyFastSymmetricJacobi\n         * more efficient. First, we directly set elements ij and ji equal to zero rather than\n         * calculation them. Second, we copy symmetric elements from upper triangle to lower\n         * instead of calculating them.\n         */\n        lambda.applyGivensRowOp(i, j, c, s);\n        lambda.applyGivensColumnOp(i, j, c, s);\n        leftEigenvectors.applyGivensColumnOp(i, j, c, s);\n        return Math.abs(sij);\n    }\n    /**\n     * Factor `this` matrix as a product `U * lambda * UT` where `U` is an orthogonal matrix and `lambda`\n     * is a diagonal matrix.\n     *\n     * * **Note 1:** You must apply this function to a `symmetric` matrix. Otherwise, the lower triangle is ignored\n     * and the upper triangle is mirrored to the lower triangle to enforce symmetry.\n     * * **Note 2:** This function is replaced by a faster method called `fastSymmetricEigenvalues` so consider\n     * using the fast version instead.\n     * @param leftEigenvectors a matrix that its columns will be filled by the left eigenvectors of `this` Matrix3d\n     * (allocated by caller, computed and filled by this function). Note that columns of leftEigenVectors will be\n     * mutually perpendicular because `this` matrix is symmetric.\n     * @param lambda a vector that its entries will be filled by eigenvalues of `this` Matrix3d (allocated by\n     * caller, computed and filled by this function).\n     */\n    symmetricEigenvalues(leftEigenvectors, lambda) {\n        const matrix = this.clone();\n        leftEigenvectors.setIdentity();\n        matrix.coffs[3] = matrix.coffs[1];\n        matrix.coffs[6] = matrix.coffs[2];\n        matrix.coffs[7] = matrix.coffs[5];\n        const tolerance = 1.0e-12 * this.sumSquares();\n        const numberOfIterations = 7;\n        for (let iteration = 0; iteration < numberOfIterations; iteration++) {\n            const sum = this.applySymmetricJacobi(0, 1, leftEigenvectors, matrix)\n                + this.applySymmetricJacobi(0, 2, leftEigenvectors, matrix)\n                + this.applySymmetricJacobi(1, 2, leftEigenvectors, matrix);\n            if (sum < tolerance) {\n                lambda.set(matrix.at(0, 0), matrix.at(1, 1), matrix.at(2, 2));\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Apply (in place) a jacobi eigenvalue algorithm that diagonalize `this` matrix, i.e., zeros out this.at(i,j).\n     * * During diagonalization, the upper triangle is mirrored to lower triangle to enforce symmetry.\n     * * Math details can be found at docs/learning/geometry/Matrix.md\n     * @param i row index of zeroed member.\n     * @param j column index of zeroed member.\n     * @param k other row/column index (different from i and j).\n     * @param leftEigenVectors a matrix that its columns will be filled by the left eigenvectors of `this` Matrix3d\n     * (allocated by caller, computed and filled by this function). Note that columns of leftEigenVectors will be\n     * mutually perpendicular because `this` matrix is symmetric.\n     */\n    applyFastSymmetricJacobi(i, j, k, leftEigenVectors) {\n        const indexII = 4 * i;\n        const indexJJ = 4 * j;\n        const indexIJ = 3 * i + j;\n        const indexJI = 3 * j + i;\n        const indexIK = 3 * i + k;\n        const indexKI = 3 * k + i;\n        const indexJK = 3 * j + k;\n        const indexKJ = 3 * k + j;\n        const sii = this.coffs[indexII];\n        const sjj = this.coffs[indexJJ];\n        const sij = this.coffs[indexIJ];\n        if (Math.abs(sij) < Geometry.smallFloatingPoint * (sii + sjj))\n            return 0.0;\n        const jacobi = Angle.trigValuesToHalfAngleTrigValues(sii - sjj, 2.0 * sij);\n        const c = jacobi.c;\n        const s = jacobi.s;\n        const cc = c * c;\n        const ss = s * s;\n        const sc2 = 2.0 * c * s;\n        this.coffs[indexII] = cc * sii + sc2 * sij + ss * sjj;\n        this.coffs[indexJJ] = ss * sii - sc2 * sij + cc * sjj;\n        this.coffs[indexIJ] = 0.0;\n        this.coffs[indexJI] = 0.0;\n        const a = this.coffs[indexIK];\n        const b = this.coffs[indexJK];\n        this.coffs[indexIK] = c * a + s * b;\n        this.coffs[indexJK] = -s * a + c * b;\n        this.coffs[indexKI] = this.coffs[indexIK];\n        this.coffs[indexKJ] = this.coffs[indexJK];\n        leftEigenVectors.applyGivensColumnOp(i, j, c, s);\n        return Math.abs(sij);\n    }\n    /**\n     * Factor `this` matrix as a product `U * lambda * UT` where `U` is an orthogonal matrix and `lambda`\n     * is a diagonal matrix.\n     *\n     * * **Note:** You must apply this function to a `symmetric` matrix. Otherwise, the lower triangle is ignored\n     * and the upper triangle is mirrored to the lower triangle to enforce symmetry.\n     * * Math details can be found at docs/learning/geometry/Matrix.md\n     * @param leftEigenvectors a matrix that its columns will be filled by the left eigenvectors of `this` Matrix3d\n     * (allocated by caller, computed and filled by this function). Note that columns of leftEigenVectors will be\n     * mutually perpendicular because `this` matrix is symmetric.\n     * @param lambda a vector that its entries will be filled by eigenvalues of `this` Matrix3d (allocated by\n     * caller, computed and filled by this function).\n     */\n    fastSymmetricEigenvalues(leftEigenvectors, lambda) {\n        const matrix = this.clone();\n        leftEigenvectors.setIdentity();\n        const tolerance = 1.0e-12 * this.sumSquares();\n        const numberOfIterations = 7;\n        for (let iteration = 0; iteration < numberOfIterations; iteration++) {\n            const sum = matrix.applyFastSymmetricJacobi(0, 1, 2, leftEigenvectors)\n                + matrix.applyFastSymmetricJacobi(0, 2, 1, leftEigenvectors)\n                + matrix.applyFastSymmetricJacobi(1, 2, 0, leftEigenvectors);\n            if (sum < tolerance) {\n                lambda.set(matrix.at(0, 0), matrix.at(1, 1), matrix.at(2, 2));\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Compute the (unit vector) axis and angle for the rotation generated by `this` Matrix3d.\n     * * Math details can be found at docs/learning/geometry/Angle.md\n     * @returns Returns axis and angle of rotation with result.ok === true when the conversion succeeded.\n     */\n    getAxisAndAngleOfRotation() {\n        const trace = this.coffs[0] + this.coffs[4] + this.coffs[8];\n        const skewXY = this.coffs[3] - this.coffs[1]; // 2*z*sin\n        const skewYZ = this.coffs[7] - this.coffs[5]; // 2*y*sin\n        const skewZX = this.coffs[2] - this.coffs[6]; // 2*x*sin\n        // trace = (m00^2 + m11^2 + m22^2) * (1-cos) + 3cos = (1-cos) + 3cos = 1 + 2cos ==> cos = (trace-1) / 2\n        const c = (trace - 1.0) / 2.0; // cosine\n        const s = Geometry.hypotenuseXYZ(skewXY, skewYZ, skewZX) / 2.0; // sine\n        const e = c * c + s * s - 1.0; // s^2 + c^2 = 1\n        // if s^2 + c^2 != 1 then we have a bad matrix so return false\n        if (Math.abs(e) > Geometry.smallAngleRadians) {\n            return { axis: Vector3d.create(0, 0, 1), angle: Angle.createRadians(0), ok: false };\n        }\n        // sin is close to 0 then we got to special cases (angle 0 or 180) which needs to be handled differently\n        if (Math.abs(s) < Geometry.smallAngleRadians) {\n            if (c > 0) // sin = 0 and cos = 1 so angle = 0 (i.e., no rotation)\n                return { axis: Vector3d.create(0, 0, 1), angle: Angle.createRadians(0), ok: true };\n            /**\n             * If sin = 0 and cos = -1 then angle = 180 (i.e., 180 degree rotation around some axis)\n             * then the rotation matrix becomes\n             *                                 2x^2-1  2xy      2xz\n             *                                 2xy     2y^2-1   2yz\n             *                                 2xz     2yz      2z^2-1\n             * Note that the matrix is \"symmetric\".\n             * If rotation is around one the standard basis then non-diagonal entries become 0 and we\n             * have one 1 and two -1s on the diagonal.\n             * If rotation is around an axis other than standard basis, then the axis is the eigenvector\n             * of the rotation matrix with eigenvalue = 1.\n             */\n            const axx = this.coffs[0];\n            const ayy = this.coffs[4];\n            const azz = this.coffs[8];\n            // Look for a pair of \"-1\" entries on the diagonal (for rotation around the basis X,Y,Z axis)\n            if (Geometry.isAlmostEqualNumber(-1.0, ayy) && Geometry.isAlmostEqualNumber(-1, azz)) {\n                return { axis: Vector3d.create(1, 0, 0), angle: Angle.createDegrees(180), ok: true };\n            }\n            else if (Geometry.isAlmostEqualNumber(-1.0, axx) && Geometry.isAlmostEqualNumber(-1, azz)) {\n                return { axis: Vector3d.create(0, 1, 0), angle: Angle.createDegrees(180), ok: true };\n            }\n            else if (Geometry.isAlmostEqualNumber(-1.0, axx) && Geometry.isAlmostEqualNumber(-1, ayy)) {\n                return { axis: Vector3d.create(0, 0, 1), angle: Angle.createDegrees(180), ok: true };\n            }\n            // Look for eigenvector with eigenvalue = 1\n            const eigenvectors = Matrix3d.createIdentity();\n            const eigenvalues = Vector3d.create(0, 0, 0);\n            if (this.fastSymmetricEigenvalues(eigenvectors, eigenvalues)) { // note: this matrix is \"symmetric\"\n                for (let axisIndex = 0; axisIndex < 2; axisIndex++) {\n                    const lambda = eigenvalues.at(axisIndex);\n                    if (Geometry.isAlmostEqualNumber(1, lambda))\n                        return { axis: eigenvectors.getColumn(axisIndex), angle: Angle.createDegrees(180), ok: true };\n                }\n                // if no eigenvalue = 1 was found return false\n                return { axis: Vector3d.create(0, 0, 1), angle: Angle.createRadians(0), ok: false };\n            }\n            // if no axis was found return false\n            return { axis: Vector3d.create(0, 0, 1), angle: Angle.createRadians(0), ok: false };\n        }\n        // good matrix and non-zero sine\n        const a = 1.0 / (2.0 * s);\n        const result = {\n            axis: Vector3d.create(skewYZ * a, skewZX * a, skewXY * a),\n            angle: Angle.createAtan2(s, c),\n            ok: true,\n        };\n        return result;\n    }\n    /**\n     * Rotate columns i and j of `this` matrix to make them perpendicular using the angle that zero-out\n     * `thisTranspose * this`.\n     * @param i row index of zeroed member.\n     * @param j column index of zeroed member.\n     * @param matrixU a matrix that its columns will be filled by the right eigenvectors of `thisTranspose * this`\n     * (allocated by caller, computed and filled by this function). Note that columns of matrixU will be mutually\n     *  perpendicular because `thisTranspose * this` matrix is symmetric.\n     */\n    applyJacobiColumnRotation(i, j, matrixU) {\n        const uDotU = this.coffs[i] * this.coffs[i]\n            + this.coffs[i + 3] * this.coffs[i + 3]\n            + this.coffs[i + 6] * this.coffs[i + 6];\n        const vDotV = this.coffs[j] * this.coffs[j]\n            + this.coffs[j + 3] * this.coffs[j + 3]\n            + this.coffs[j + 6] * this.coffs[j + 6];\n        const uDotV = this.coffs[i] * this.coffs[j]\n            + this.coffs[i + 3] * this.coffs[j + 3]\n            + this.coffs[i + 6] * this.coffs[j + 6];\n        const jacobi = Angle.trigValuesToHalfAngleTrigValues(uDotU - vDotV, 2.0 * uDotV);\n        const c = jacobi.c;\n        const s = jacobi.s;\n        if (Math.abs(s) < 2.0e-15)\n            return 0.0;\n        this.applyGivensColumnOp(i, j, c, s); // make columns i and j of `this` matrix perpendicular\n        matrixU.applyGivensRowOp(i, j, c, s); // right eigenvalues of `thisTranspose * this`\n        return Math.abs(uDotV);\n    }\n    /**\n     * Factor `this` matrix as a product `VD * U` where `VD` has mutually perpendicular columns and `U` is orthogonal.\n     * @param matrixVD a matrix that its columns will be filled by rotating columns of `this` to make them mutually\n     * perpendicular (allocated by caller, computed and filled by this function).\n     * @param matrixU a matrix that its columns will be filled by the right eigenvectors of `thisTranspose * this`\n     * (allocated by caller, computed and filled by this function). Note that columns of matrixU will be mutually\n     *  perpendicular because `thisTranspose * this` matrix is symmetric.\n     */\n    factorPerpendicularColumns(matrixVD, matrixU) {\n        matrixVD.setFrom(this);\n        matrixU.setIdentity();\n        const tolerance = 1.0e-12 * this.sumSquares();\n        const numberOfIterations = 7;\n        for (let iteration = 0; iteration < numberOfIterations; iteration++) {\n            const sum = matrixVD.applyJacobiColumnRotation(0, 1, matrixU)\n                + matrixVD.applyJacobiColumnRotation(0, 2, matrixU)\n                + matrixVD.applyJacobiColumnRotation(1, 2, matrixU);\n            if (sum < tolerance) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Factor `this` matrix as a product `V * D * U` where `V` and `U` are orthogonal and `D` is diagonal with\n     * positive entries.\n     * * This is formally known as the `Singular Value Decomposition` or `SVD`.\n     * @param matrixV an orthogonal matrix that its columns will be filled by the left eigenvectors of\n     * `thisTranspose * this` (allocated by caller, computed and filled by this function).\n     * @param scale singular values of `this` (allocated by caller, computed and filled by this function).\n     * The singular values in the `scale` are non-negative and decreasing.\n     * @param matrixU an orthogonal matrix that its columns will be filled by the right eigenvectors of\n     * `thisTranspose * this` (allocated by caller, computed and filled by this function).\n     */\n    factorOrthogonalScaleOrthogonal(matrixV, scale, matrixU) {\n        const matrixVD = Matrix3d.createZero();\n        if (!this.factorPerpendicularColumns(matrixVD, matrixU))\n            return false;\n        const column = [];\n        column.push(matrixVD.getColumn(0));\n        column.push(matrixVD.getColumn(1));\n        column.push(matrixVD.getColumn(2));\n        scale.set(column[0].magnitude(), column[1].magnitude(), column[2].magnitude()); // singular values of `this`\n        const det = matrixVD.determinant();\n        if (det < 0)\n            scale.z = -scale.z;\n        const almostZero = Geometry.smallFloatingPoint;\n        const scaleXIsZero = Math.abs(scale.x) < almostZero;\n        const scaleYIsZero = Math.abs(scale.y) < almostZero;\n        const scaleZIsZero = Math.abs(scale.z) < almostZero;\n        // NOTE: We assume any zero-magnitude column(s) of matrixVD are last\n        if (!scaleXIsZero && !scaleYIsZero && !scaleZIsZero) { // full rank\n            matrixV = matrixVD.scaleColumns(1 / scale.x, 1 / scale.y, 1 / scale.z, matrixV);\n        }\n        else if (!scaleXIsZero && !scaleYIsZero) { // rank 2\n            column[0].scaleInPlace(1 / scale.x);\n            column[1].scaleInPlace(1 / scale.y);\n            column[2] = column[0].unitCrossProduct(column[1], column[2]);\n            matrixV.setColumns(column[0], column[1], column[2]);\n        }\n        else if (!scaleXIsZero) { // rank 1\n            matrixV = Matrix3d.createRigidHeadsUp(column[0], AxisOrder.XYZ, matrixV); // preserve column0\n        }\n        else { // rank 0\n            matrixV.setIdentity();\n        }\n        return true;\n    }\n    /**\n     * Return a matrix that rotates a fraction of the angular sweep from vectorA to vectorB.\n     * @param vectorA initial vector position\n     * @param fraction fractional rotation (1 means rotate all the way)\n     * @param vectorB final vector position\n     * @param result optional result matrix.\n     */\n    static createPartialRotationVectorToVector(vectorA, fraction, vectorB, result) {\n        let upVector = vectorA.unitCrossProduct(vectorB);\n        // the usual case (both vectors and also their cross product is non-zero)\n        if (upVector) {\n            return Matrix3d.createRotationAroundVector(upVector, Angle.createRadians(fraction * vectorA.planarAngleTo(vectorB, upVector).radians));\n        }\n        // if either vector is zero\n        if (Geometry.isSmallMetricDistance(vectorA.magnitude())\n            || Geometry.isSmallMetricDistance(vectorB.magnitude()))\n            return undefined;\n        // aligned vectors (cross product = 0, dot product > 0)\n        if (vectorA.dotProduct(vectorB) > 0.0)\n            return Matrix3d.createIdentity(result);\n        // opposing vectors (cross product = 0, dot product < 0)\n        upVector = Matrix3d.createPerpendicularVectorFavorPlaneContainingZ(vectorA, upVector);\n        return Matrix3d.createRotationAroundVector(upVector, Angle.createRadians(fraction * Math.PI));\n    }\n    /** Returns a matrix that rotates from vectorA to vectorB. */\n    static createRotationVectorToVector(vectorA, vectorB, result) {\n        return this.createPartialRotationVectorToVector(vectorA, 1.0, vectorB, result);\n    }\n    /** Create a 90 degree rotation around a principal axis */\n    static create90DegreeRotationAroundAxis(axisIndex) {\n        axisIndex = Geometry.cyclic3dAxis(axisIndex);\n        if (axisIndex === 0) {\n            const retVal = Matrix3d.createRowValues(1, 0, 0, 0, 0, -1, 0, 1, 0);\n            retVal.setupInverseTranspose();\n            return retVal;\n        }\n        else if (axisIndex === 1) {\n            const retVal = Matrix3d.createRowValues(0, 0, 1, 0, 1, 0, -1, 0, 0);\n            retVal.setupInverseTranspose();\n            return retVal;\n        }\n        else {\n            const retVal = Matrix3d.createRowValues(0, -1, 0, 1, 0, 0, 0, 0, 1);\n            retVal.setupInverseTranspose();\n            return retVal;\n        }\n    }\n    /** Return (a copy of) the X column */\n    columnX(result) {\n        return Vector3d.create(this.coffs[0], this.coffs[3], this.coffs[6], result);\n    }\n    /** Return (a copy of) the Y column */\n    columnY(result) {\n        return Vector3d.create(this.coffs[1], this.coffs[4], this.coffs[7], result);\n    }\n    /** Return (a copy of) the Z column */\n    columnZ(result) {\n        return Vector3d.create(this.coffs[2], this.coffs[5], this.coffs[8], result);\n    }\n    /** Return the X column magnitude squared */\n    columnXMagnitudeSquared() {\n        return Geometry.hypotenuseSquaredXYZ(this.coffs[0], this.coffs[3], this.coffs[6]);\n    }\n    /** Return the Y column magnitude squared */\n    columnYMagnitudeSquared() {\n        return Geometry.hypotenuseSquaredXYZ(this.coffs[1], this.coffs[4], this.coffs[7]);\n    }\n    /** Return the Z column magnitude squared */\n    columnZMagnitudeSquared() {\n        return Geometry.hypotenuseSquaredXYZ(this.coffs[2], this.coffs[5], this.coffs[8]);\n    }\n    /** Return the X column magnitude */\n    columnXMagnitude() {\n        return Geometry.hypotenuseXYZ(this.coffs[0], this.coffs[3], this.coffs[6]);\n    }\n    /** Return the Y column magnitude */\n    columnYMagnitude() {\n        return Geometry.hypotenuseXYZ(this.coffs[1], this.coffs[4], this.coffs[7]);\n    }\n    /** Return the Z column magnitude */\n    columnZMagnitude() {\n        return Geometry.hypotenuseXYZ(this.coffs[2], this.coffs[5], this.coffs[8]);\n    }\n    /** Return magnitude of columnX cross columnY. */\n    columnXYCrossProductMagnitude() {\n        return Geometry.crossProductMagnitude(this.coffs[0], this.coffs[3], this.coffs[6], this.coffs[1], this.coffs[4], this.coffs[7]);\n    }\n    /** Return the X row magnitude */\n    rowXMagnitude() {\n        return Geometry.hypotenuseXYZ(this.coffs[0], this.coffs[1], this.coffs[2]);\n    }\n    /** Return the Y row magnitude  */\n    rowYMagnitude() {\n        return Geometry.hypotenuseXYZ(this.coffs[3], this.coffs[4], this.coffs[5]);\n    }\n    /** Return the Z row magnitude  */\n    rowZMagnitude() {\n        return Geometry.hypotenuseXYZ(this.coffs[6], this.coffs[7], this.coffs[8]);\n    }\n    /** Return the dot product of column X with column Y */\n    columnXDotColumnY() {\n        return this.coffs[0] * this.coffs[1]\n            + this.coffs[3] * this.coffs[4]\n            + this.coffs[6] * this.coffs[7];\n    }\n    /** Return the dot product of column X with column Z */\n    columnXDotColumnZ() {\n        return this.coffs[0] * this.coffs[2]\n            + this.coffs[3] * this.coffs[5]\n            + this.coffs[6] * this.coffs[8];\n    }\n    /** Return the dot product of column Y with column Z */\n    columnYDotColumnZ() {\n        return this.coffs[1] * this.coffs[2]\n            + this.coffs[4] * this.coffs[5]\n            + this.coffs[7] * this.coffs[8];\n    }\n    /**\n     * Dot product of an indexed column with a vector given as x,y,z\n     * @param columnIndex index of column. Must be 0,1,2.\n     * @param x x component of vector\n     * @param y y component of vector\n     * @param z z component of vector\n     */\n    columnDotXYZ(columnIndex, x, y, z) {\n        return this.coffs[columnIndex] * x + this.coffs[columnIndex + 3] * y + this.coffs[columnIndex + 6] * z;\n    }\n    /** Return (a copy of) the X row */\n    rowX(result) {\n        return Vector3d.create(this.coffs[0], this.coffs[1], this.coffs[2], result);\n    }\n    /** Return (a copy of) the Y row */\n    rowY(result) {\n        return Vector3d.create(this.coffs[3], this.coffs[4], this.coffs[5], result);\n    }\n    /** Return (a copy of) the Z row */\n    rowZ(result) {\n        return Vector3d.create(this.coffs[6], this.coffs[7], this.coffs[8], result);\n    }\n    /** Return the dot product of the vector parameter with the X column. */\n    dotColumnX(vector) {\n        return vector.x * this.coffs[0] + vector.y * this.coffs[3] + vector.z * this.coffs[6];\n    }\n    /** Return the dot product of the vector parameter with the Y column. */\n    dotColumnY(vector) {\n        return vector.x * this.coffs[1] + vector.y * this.coffs[4] + vector.z * this.coffs[7];\n    }\n    /** Return the dot product of the vector parameter with the Z column. */\n    dotColumnZ(vector) {\n        return vector.x * this.coffs[2] + vector.y * this.coffs[5] + vector.z * this.coffs[8];\n    }\n    /** Return the dot product of the vector parameter with the X row. */\n    dotRowX(vector) {\n        return vector.x * this.coffs[0] + vector.y * this.coffs[1] + vector.z * this.coffs[2];\n    }\n    /** Return the dot product of the vector parameter with the Y row. */\n    dotRowY(vector) {\n        return vector.x * this.coffs[3] + vector.y * this.coffs[4] + vector.z * this.coffs[5];\n    }\n    /** Return the dot product of the vector parameter with the Z row. */\n    dotRowZ(vector) {\n        return vector.x * this.coffs[6] + vector.y * this.coffs[7] + vector.z * this.coffs[8];\n    }\n    /** Return the dot product of the x,y,z with the X row. */\n    dotRowXXYZ(x, y, z) {\n        return x * this.coffs[0] + y * this.coffs[1] + z * this.coffs[2];\n    }\n    /** Return the dot product of the x,y,z with the Y row. */\n    dotRowYXYZ(x, y, z) {\n        return x * this.coffs[3] + y * this.coffs[4] + z * this.coffs[5];\n    }\n    /** Return the dot product of the x,y,z with the Z row. */\n    dotRowZXYZ(x, y, z) {\n        return x * this.coffs[6] + y * this.coffs[7] + z * this.coffs[8];\n    }\n    /** Return the cross product of the Z column with the vector parameter. */\n    columnZCrossVector(vector, result) {\n        return Geometry.crossProductXYZXYZ(this.coffs[2], this.coffs[5], this.coffs[8], vector.x, vector.y, vector.z, result);\n    }\n    /** Set data from xyz parts of Point4d  (w part of Point4d ignored) */\n    setColumnsPoint4dXYZ(vectorU, vectorV, vectorW) {\n        this.inverseState = InverseMatrixState.unknown;\n        this.setRowValues(vectorU.x, vectorV.x, vectorW.x, vectorU.y, vectorV.y, vectorW.y, vectorU.z, vectorV.z, vectorW.z);\n    }\n    /**\n     * Set entries in one column of the matrix.\n     * @param columnIndex column index (this is interpreted cyclically. See Geometry.cyclic3dAxis for more info).\n     * @param value x,yz, values for column.  If undefined, zeros are installed.\n     */\n    setColumn(columnIndex, value) {\n        const index = Geometry.cyclic3dAxis(columnIndex);\n        this.inverseState = InverseMatrixState.unknown;\n        if (value) {\n            this.coffs[index] = value.x;\n            this.coffs[index + 3] = value.y;\n            this.coffs[index + 6] = value.z;\n        }\n        else {\n            this.coffs[index] = 0.0;\n            this.coffs[index + 3] = 0.0;\n            this.coffs[index + 6] = 0.0;\n        }\n    }\n    /**\n     * Set all columns of the matrix. Any undefined vector is zeros.\n     * @param vectorX values for column 0\n     * @param vectorY values for column 1\n     * @param vectorZ optional values for column 2 (it's optional in case column 2 is 000, which is a\n     * projection onto the xy-plane)\n     */\n    setColumns(vectorX, vectorY, vectorZ) {\n        this.setColumn(0, vectorX);\n        this.setColumn(1, vectorY);\n        this.setColumn(2, vectorZ);\n    }\n    /**\n     * Set entries in one row of the matrix.\n     * @param rowIndex row index. This is interpreted cyclically (using Geometry.cyclic3dAxis).\n     * @param value x,y,z values for row.\n     */\n    setRow(rowIndex, value) {\n        const index = 3 * Geometry.cyclic3dAxis(rowIndex);\n        this.coffs[index] = value.x;\n        this.coffs[index + 1] = value.y;\n        this.coffs[index + 2] = value.z;\n        this.inverseState = InverseMatrixState.unknown;\n    }\n    /**\n     * Return (a copy of) a column of the matrix.\n     * @param i column index. This is interpreted cyclically (using Geometry.cyclic3dAxis).\n     * @param result optional preallocated result.\n     */\n    getColumn(columnIndex, result) {\n        const index = Geometry.cyclic3dAxis(columnIndex);\n        return Vector3d.create(this.coffs[index], this.coffs[index + 3], this.coffs[index + 6], result);\n    }\n    /**\n     * Return a (copy of) a row of the matrix.\n     * @param i row index. This is interpreted cyclically (using Geometry.cyclic3dAxis).\n     * @param result optional preallocated result.\n     */\n    getRow(columnIndex, result) {\n        const index = 3 * Geometry.cyclic3dAxis(columnIndex);\n        return Vector3d.create(this.coffs[index], this.coffs[index + 1], this.coffs[index + 2], result);\n    }\n    /**\n     * Create a matrix from row vectors.\n     * ```\n     * equation\n     * \\begin{bmatrix}U_x & U_y & U_z \\\\ V_x & V_y & V_z \\\\ W_x & W_y & W_z \\end{bmatrix}\n     * ```\n     */\n    static createRows(vectorU, vectorV, vectorW, result) {\n        return Matrix3d.createRowValues(vectorU.x, vectorU.y, vectorU.z, vectorV.x, vectorV.y, vectorV.z, vectorW.x, vectorW.y, vectorW.z, result);\n    }\n    /**\n     * Create a matrix that scales along a specified `direction`. This means if you multiply the returned matrix\n     * by a `vector`, you get `directional scale` of that `vector`. Suppose `plane` is the plane perpendicular\n     * to the `direction`. When scale = 0, `directional scale` is projection of the `vector` to the `plane`.\n     * When scale = 1, `directional scale` is the `vector` itself. When scale = -1, `directional scale` is\n     * mirror of the `vector` across the `plane`. In general, When scale != 0, the result is computed by first\n     * projecting the `vector` to the `plane`, then translating that projection along the `direction` (if scale > 0)\n     * or in opposite direction (if scale < 0).\n     * ```\n     * equation\n     * \\text{The matrix is } I + (s-1) D D^T\n     * \\\\ \\text{with }D\\text{ being the normalized direction vector and }s\\text{ being the scale.}\n     * ```\n     * * Visualization can be found at itwinjs.org/sandbox/SaeedTorabi/DirectionalScale\n     */\n    static createDirectionalScale(direction, scale, result) {\n        const unit = direction.normalize();\n        if (unit) {\n            const x = unit.x;\n            const y = unit.y;\n            const z = unit.z;\n            const a = scale - 1;\n            return Matrix3d.createRowValues(1 + a * x * x, a * x * y, a * x * z, a * y * x, 1 + a * y * y, a * y * z, a * z * x, a * z * y, 1 + a * z * z, result);\n        }\n        return Matrix3d.createUniformScale(scale);\n    }\n    /**\n     * Create a matrix which sweeps a vector along `sweepVector` until it hits the plane through the origin with the given normal.\n     * * To sweep an arbitrary vector U0 along direction W to the vector U1 in the plane through the origin with normal N:\n     *   *   `U1 = U0 + W * alpha`\n     *   *   `U1 DOT N = (U0 + W * alpha) DOT N = 0`\n     *   *   `U0 DOT N = - alpha * W DOT N`\n     *   *   `alpha = - U0 DOT N / W DOT N`\n     * * Insert the alpha definition in U1:\n     *   *   `U1 = U0 -  W * N DOT U0 / W DOT N`\n     * * Write vector dot expression N DOT U0 as a matrix product (^T indicates transpose):\n     *   *   `U1 = U0 -  W * N^T * U0 / W DOT N`\n     * * Note W * N^T is an outer product, i.e. a 3x3 matrix. By associativity of matrix multiplication:\n     *   *   `U1 = (I - W * N^T / W DOT N) * U0`\n     * * and the matrix to do the sweep for any vector in place of U0 is `I - W * N^T / W DOT N`.\n     * @param sweepVector sweep direction\n     * @param planeNormal normal to the target plane\n     */\n    static createFlattenAlongVectorToPlane(sweepVector, planeNormal) {\n        const result = Matrix3d.createIdentity();\n        const dot = sweepVector.dotProduct(planeNormal);\n        const inverse = Geometry.conditionalDivideCoordinate(1.0, -dot);\n        if (inverse !== undefined) {\n            result.addScaledOuterProductInPlace(sweepVector, planeNormal, inverse);\n            return result;\n        }\n        return undefined;\n    }\n    /**\n    * Multiply `matrix * point`, treating the point as a column vector on the right.\n    * ```\n    * equation\n    * \\matrixXY{A}\\columnSubXYZ{U}\n    * ```\n    * @return the point result\n    */\n    multiplyPoint(point, result) {\n        const x = point.x;\n        const y = point.y;\n        const z = point.z;\n        return Point3d.create(this.coffs[0] * x + this.coffs[1] * y + this.coffs[2] * z, this.coffs[3] * x + this.coffs[4] * y + this.coffs[5] * z, this.coffs[6] * x + this.coffs[7] * y + this.coffs[8] * z, result);\n    }\n    /**\n     * Multiply `matrix * vector`, treating the vector is a column vector on the right.\n     * ```\n     * equation\n     * \\matrixXY{A}\\columnSubXYZ{U}\n     * ```\n     * @return the vector result\n     */\n    multiplyVector(vectorU, result) {\n        const x = vectorU.x;\n        const y = vectorU.y;\n        const z = vectorU.z;\n        return Vector3d.create(this.coffs[0] * x + this.coffs[1] * y + this.coffs[2] * z, this.coffs[3] * x + this.coffs[4] * y + this.coffs[5] * z, this.coffs[6] * x + this.coffs[7] * y + this.coffs[8] * z, result);\n    }\n    /**\n     * Multiply `matrix * vector` in place for vector in the array, i.e. treating the vector is a column\n     * vector on the right.\n     * * Each `vector` is updated to be `matrix * vector`\n     */\n    multiplyVectorArrayInPlace(data) {\n        for (const v of data)\n            v.set(this.coffs[0] * v.x + this.coffs[1] * v.y + this.coffs[2] * v.z, this.coffs[3] * v.x + this.coffs[4] * v.y + this.coffs[5] * v.z, this.coffs[6] * v.x + this.coffs[7] * v.y + this.coffs[8] * v.z);\n    }\n    /** Compute `origin - matrix * vector` */\n    static xyzMinusMatrixTimesXYZ(origin, matrix, vector, result) {\n        const x = vector.x;\n        const y = vector.y;\n        const z = vector.z;\n        return Point3d.create(origin.x - (matrix.coffs[0] * x + matrix.coffs[1] * y + matrix.coffs[2] * z), origin.y - (matrix.coffs[3] * x + matrix.coffs[4] * y + matrix.coffs[5] * z), origin.z - (matrix.coffs[6] * x + matrix.coffs[7] * y + matrix.coffs[8] * z), result);\n    }\n    /** Compute `origin + matrix * vector`  using only the xy parts of the inputs. */\n    static xyPlusMatrixTimesXY(origin, matrix, vector, result) {\n        const x = vector.x;\n        const y = vector.y;\n        return Point2d.create(origin.x + matrix.coffs[0] * x + matrix.coffs[1] * y, origin.y + matrix.coffs[3] * x + matrix.coffs[4] * y, result);\n    }\n    /** Compute `origin + matrix * vector`  using all xyz parts of the inputs. */\n    static xyzPlusMatrixTimesXYZ(origin, matrix, vector, result) {\n        const x = vector.x;\n        const y = vector.y;\n        const z = vector.z;\n        return Point3d.create(origin.x + matrix.coffs[0] * x + matrix.coffs[1] * y + matrix.coffs[2] * z, origin.y + matrix.coffs[3] * x + matrix.coffs[4] * y + matrix.coffs[5] * z, origin.z + matrix.coffs[6] * x + matrix.coffs[7] * y + matrix.coffs[8] * z, result);\n    }\n    /** Updates vector to be `origin + matrix * vector` using all xyz parts of the inputs. */\n    static xyzPlusMatrixTimesXYZInPlace(origin, matrix, vector) {\n        const x = vector.x;\n        const y = vector.y;\n        const z = vector.z;\n        vector.x = origin.x + matrix.coffs[0] * x + matrix.coffs[1] * y + matrix.coffs[2] * z;\n        vector.y = origin.y + matrix.coffs[3] * x + matrix.coffs[4] * y + matrix.coffs[5] * z;\n        vector.z = origin.z + matrix.coffs[6] * x + matrix.coffs[7] * y + matrix.coffs[8] * z;\n    }\n    /** Compute `origin + matrix * vector` where the final vector is given as direct x,y,z coordinates */\n    static xyzPlusMatrixTimesCoordinates(origin, matrix, x, y, z, result) {\n        return Point3d.create(origin.x + matrix.coffs[0] * x + matrix.coffs[1] * y + matrix.coffs[2] * z, origin.y + matrix.coffs[3] * x + matrix.coffs[4] * y + matrix.coffs[5] * z, origin.z + matrix.coffs[6] * x + matrix.coffs[7] * y + matrix.coffs[8] * z, result);\n    }\n    /**\n     * Treat the 3x3 matrix and origin as upper 3x4 part of a 4x4 matrix, with 0001 as the final row.\n     * Multiply the 4x4 matrix by `[x,y,z,w]`\n     * ```\n     * equation\n     * \\begin{bmatrix}M_0 & M_1 & M_2 & Ox \\\\ M_3 & M_4 & M_5 & Oy \\\\ M_6 & M_7 & M_8 & Oz \\\\ 0 & 0 & 0 & 1\\end{bmatrix} * \\begin{bmatrix}x \\\\ y \\\\ z \\\\ w\\end{bmatrix}\n     * ```\n     * @param origin translation part (xyz in column 3)\n     * @param matrix matrix part (leading 3x3)\n     * @param x x part of multiplied point\n     * @param y y part of multiplied point\n     * @param z z part of multiplied point\n     * @param w w part of multiplied point\n     * @param result optional preallocated result.\n     */\n    static xyzPlusMatrixTimesWeightedCoordinates(origin, matrix, x, y, z, w, result) {\n        return Point4d.create(matrix.coffs[0] * x + matrix.coffs[1] * y + matrix.coffs[2] * z + origin.x * w, matrix.coffs[3] * x + matrix.coffs[4] * y + matrix.coffs[5] * z + origin.y * w, matrix.coffs[6] * x + matrix.coffs[7] * y + matrix.coffs[8] * z + origin.z * w, w, result);\n    }\n    /**\n     * Treat the 3x3 matrix and origin as upper 3x4 part of a 4x4 matrix, with 0001 as the final row.\n     * Multiply the 4x4 matrix by `[x,y,z,w]`\n     * ```\n     * equation\n     * \\begin{bmatrix}M_0 & M_1 & M_2 & Ox \\\\ M_3 & M_4 & M_5 & Oy \\\\ M_6 & M_7 & M_8 & Oz \\\\ 0 & 0 & 0 & 1\\end{bmatrix} * \\begin{bmatrix}x \\\\ y \\\\ z \\\\ w\\end{bmatrix}\n     * ```\n     * @param origin translation part (xyz in column 3)\n     * @param matrix matrix part (leading 3x3)\n     * @param x x part of multiplied point\n     * @param y y part of multiplied point\n     * @param z z part of multiplied point\n     * @param w w part of multiplied point\n     * @param result optional preallocated result.\n     */\n    static xyzPlusMatrixTimesWeightedCoordinatesToFloat64Array(origin, matrix, x, y, z, w, result) {\n        if (!result)\n            result = new Float64Array(4);\n        result[0] = matrix.coffs[0] * x + matrix.coffs[1] * y + matrix.coffs[2] * z + origin.x * w;\n        result[1] = matrix.coffs[3] * x + matrix.coffs[4] * y + matrix.coffs[5] * z + origin.y * w;\n        result[2] = matrix.coffs[6] * x + matrix.coffs[7] * y + matrix.coffs[8] * z + origin.z * w;\n        result[3] = w;\n        return result;\n    }\n    /**\n     * Treat the 3x3 matrix and origin as a 3x4 matrix.\n     * * Multiply the 3x4 matrix by `[x,y,z,1]`\n     * ```\n     * equation\n     * \\begin{bmatrix}M_0 & M_1 & M_2 & Ox \\\\ M_3 & M_4 & M_5 & Oy \\\\ M_6 & M_7 & M_8 & Oz\\end{bmatrix} * \\begin{bmatrix}x \\\\ y \\\\ z \\\\ 1\\end{bmatrix}\n     * ```\n     * @param origin translation part (xyz in column 3)\n     * @param matrix matrix part (leading 3x3)\n     * @param x x part of multiplied point\n     * @param y y part of multiplied point\n     * @param z z part of multiplied point\n     * @param result optional preallocated result.\n     */\n    static xyzPlusMatrixTimesCoordinatesToFloat64Array(origin, matrix, x, y, z, result) {\n        if (!result)\n            result = new Float64Array(3);\n        result[0] = matrix.coffs[0] * x + matrix.coffs[1] * y + matrix.coffs[2] * z + origin.x;\n        result[1] = matrix.coffs[3] * x + matrix.coffs[4] * y + matrix.coffs[5] * z + origin.y;\n        result[2] = matrix.coffs[6] * x + matrix.coffs[7] * y + matrix.coffs[8] * z + origin.z;\n        return result;\n    }\n    /**\n     * Multiply the transpose matrix times a vector.\n     * * This produces the same x,y,z as treating the vector as a row on the left of the (un-transposed) matrix.\n     * ```\n     * equation\n     * \\begin{matrix}\n     * \\text{Treating U as a column to the right of transposed matrix\\:  return column}&\\columnSubXYZ{V}&=&\\matrixTransposeSubXY{A}\\columnSubXYZ{U} \\\\\n     * \\text{Treating U as a row to the left of untransposed matrix\\: return row}&\\rowSubXYZ{V}&=&\\rowSubXYZ{U}\\matrixXY{A}\n     * \\end{matrix}\n     * ```\n     * @param result the vector result (optional)\n     */\n    multiplyTransposeVector(vector, result) {\n        result = result ? result : new Vector3d();\n        const x = vector.x;\n        const y = vector.y;\n        const z = vector.z;\n        result.x = this.coffs[0] * x + this.coffs[3] * y + this.coffs[6] * z;\n        result.y = this.coffs[1] * x + this.coffs[4] * y + this.coffs[7] * z;\n        result.z = this.coffs[2] * x + this.coffs[5] * y + this.coffs[8] * z;\n        return result;\n    }\n    /**\n     * Multiply the matrix * [x,y,z], i.e. the vector [x,y,z] is a column vector on the right.\n     * @param result the vector result (optional)\n     */\n    multiplyXYZ(x, y, z, result) {\n        result = result ? result : new Vector3d();\n        result.x = this.coffs[0] * x + this.coffs[1] * y + this.coffs[2] * z;\n        result.y = this.coffs[3] * x + this.coffs[4] * y + this.coffs[5] * z;\n        result.z = this.coffs[6] * x + this.coffs[7] * y + this.coffs[8] * z;\n        return result;\n    }\n    /**\n     * Multiply the matrix * xyz, place result in (required) return value.\n     * @param xyz right side\n     * @param result the result.\n     */\n    multiplyXYZtoXYZ(xyz, result) {\n        const x = xyz.x;\n        const y = xyz.y;\n        const z = xyz.z;\n        result.x = this.coffs[0] * x + this.coffs[1] * y + this.coffs[2] * z;\n        result.y = this.coffs[3] * x + this.coffs[4] * y + this.coffs[5] * z;\n        result.z = this.coffs[6] * x + this.coffs[7] * y + this.coffs[8] * z;\n        return result;\n    }\n    /**\n     * Multiply the matrix * [x,y,0], i.e. the vector [x,y,0] is a column vector on the right.\n     * @param result the vector result (optional)\n     */\n    multiplyXY(x, y, result) {\n        result = result ? result : new Vector3d();\n        result.x = this.coffs[0] * x + this.coffs[1] * y;\n        result.y = this.coffs[3] * x + this.coffs[4] * y;\n        result.z = this.coffs[6] * x + this.coffs[7] * y;\n        return result;\n    }\n    /**\n     * Compute origin + the matrix * [x,y,0].\n     * @param result the Point3d result (optional)\n     */\n    originPlusMatrixTimesXY(origin, x, y, result) {\n        return Point3d.create(origin.x + this.coffs[0] * x + this.coffs[1] * y, origin.y + this.coffs[3] * x + this.coffs[4] * y, origin.z + this.coffs[6] * x + this.coffs[7] * y, result);\n    }\n    /**\n     * Multiply the matrix * (x,y,z) in place, i.e. the vector (x,y,z) is a column vector on the right and\n     * the multiplication updates the vector values.\n     * @param xyzData the vector data.\n     */\n    multiplyVectorInPlace(xyzData) {\n        const x = xyzData.x;\n        const y = xyzData.y;\n        const z = xyzData.z;\n        xyzData.x = this.coffs[0] * x + this.coffs[1] * y + this.coffs[2] * z;\n        xyzData.y = this.coffs[3] * x + this.coffs[4] * y + this.coffs[5] * z;\n        xyzData.z = this.coffs[6] * x + this.coffs[7] * y + this.coffs[8] * z;\n    }\n    /**\n     * Multiply the transpose matrix times [x,y,z] in place, i.e. the vector [x,y,z] is a column vector on\n     * the right and the multiplication updates the vector values.\n     * * This is equivalent to `multiplyTransposeVector` but always returns the result directly in the input.\n     * @param vectorU the vector data\n     */\n    multiplyTransposeVectorInPlace(vectorU) {\n        const x = vectorU.x;\n        const y = vectorU.y;\n        const z = vectorU.z;\n        vectorU.x = this.coffs[0] * x + this.coffs[3] * y + this.coffs[6] * z;\n        vectorU.y = this.coffs[1] * x + this.coffs[4] * y + this.coffs[7] * z;\n        vectorU.z = this.coffs[2] * x + this.coffs[5] * y + this.coffs[8] * z;\n    }\n    /**\n     * Multiply the transpose matrix times column using individual numeric inputs.\n     * * This produces the same x,y,z as treating the vector as a row on the left of the (un-transposed) matrix.\n     * ```\n     * equation\n     * \\begin{matrix}\n     * \\text{treating the input as a column vector } \\columnXYZ{x}{y}{z}\\text{ compute  }&\\columnSubXYZ{V} &= &A^T \\columnXYZ{x}{y}{z} \\\\\n     * \\text{or as a row vector } \\rowXYZ{x}{y}{z} \\text{ compute }&\\rowSubXYZ{V} &= &\\rowXYZ{x}{y}{z} A \\\\\n     * \\phantom{8888}\\text{and return V as a Vector3d} & & &\n     * \\end{matrix}\n     * ````\n     * @param result the vector result (optional)\n     */\n    multiplyTransposeXYZ(x, y, z, result) {\n        result = result ? result : new Vector3d();\n        result.x = this.coffs[0] * x + this.coffs[3] * y + this.coffs[6] * z;\n        result.y = this.coffs[1] * x + this.coffs[4] * y + this.coffs[7] * z;\n        result.z = this.coffs[2] * x + this.coffs[5] * y + this.coffs[8] * z;\n        return result;\n    }\n    /**\n     * Solve `matrix * result = vector` for an unknown `result`.\n     * * This is equivalent to multiplication `result = matrixInverse * vector`.\n     * * Result is `undefined` if the matrix is singular (e.g. has parallel columns or a zero magnitude column)\n     */\n    multiplyInverse(vector, result) {\n        this.computeCachedInverse(true);\n        if (this.inverseCoffs) {\n            const x = vector.x;\n            const y = vector.y;\n            const z = vector.z;\n            return Vector3d.create(this.inverseCoffs[0] * x + this.inverseCoffs[1] * y + this.inverseCoffs[2] * z, this.inverseCoffs[3] * x + this.inverseCoffs[4] * y + this.inverseCoffs[5] * z, this.inverseCoffs[6] * x + this.inverseCoffs[7] * y + this.inverseCoffs[8] * z, result);\n        }\n        return undefined;\n    }\n    /**\n     * Solve `matrixTranspose * result = vector` for an unknown `result`.\n     * * This is equivalent to multiplication `result = matrixInverseTranspose * vector`.\n     * * Result is `undefined` if the matrix is singular (e.g. has parallel columns or a zero magnitude column)\n     */\n    multiplyInverseTranspose(vector, result) {\n        this.computeCachedInverse(true);\n        if (this.inverseCoffs) {\n            const x = vector.x;\n            const y = vector.y;\n            const z = vector.z;\n            return Vector3d.create(this.inverseCoffs[0] * x + this.inverseCoffs[3] * y + this.inverseCoffs[6] * z, this.inverseCoffs[1] * x + this.inverseCoffs[4] * y + this.inverseCoffs[7] * z, this.inverseCoffs[2] * x + this.inverseCoffs[5] * y + this.inverseCoffs[8] * z, result);\n        }\n        return undefined;\n    }\n    /**\n     * Multiply `matrixInverse * [x,y,z]`.\n     * * This is equivalent to solving `matrix * result = [x,y,z]` for an unknown `result`.\n     * * Result is `undefined` if the matrix is singular (e.g. has parallel columns or a zero magnitude column)\n     * @return result as a Vector3d or undefined (if the matrix is singular).\n     */\n    multiplyInverseXYZAsVector3d(x, y, z, result) {\n        this.computeCachedInverse(true);\n        if (this.inverseCoffs) {\n            return Vector3d.create(this.inverseCoffs[0] * x + this.inverseCoffs[1] * y + this.inverseCoffs[2] * z, this.inverseCoffs[3] * x + this.inverseCoffs[4] * y + this.inverseCoffs[5] * z, this.inverseCoffs[6] * x + this.inverseCoffs[7] * y + this.inverseCoffs[8] * z, result);\n        }\n        return undefined;\n    }\n    /**\n     * Multiply `matrixInverse * [x,y,z]` and return result as a `Point4d` with the given weight as the last coordinate.\n     * * Equivalent to solving `matrix * result = [x,y,z]` for an unknown `result`.\n     * * Result is `undefined` if the matrix is singular (e.g. has parallel columns or a zero magnitude column)\n     * @return result as a Point4d with the same weight.\n     */\n    multiplyInverseXYZW(x, y, z, w, result) {\n        this.computeCachedInverse(true);\n        if (this.inverseCoffs) {\n            return Point4d.create(this.inverseCoffs[0] * x + this.inverseCoffs[1] * y + this.inverseCoffs[2] * z, this.inverseCoffs[3] * x + this.inverseCoffs[4] * y + this.inverseCoffs[5] * z, this.inverseCoffs[6] * x + this.inverseCoffs[7] * y + this.inverseCoffs[8] * z, w, result);\n        }\n        return undefined;\n    }\n    /**\n     * Multiply `matrixInverse * [x,y,z]` and return result as `Point3d`.\n     * * Equivalent to solving `matrix * result = [x,y,z]` for an unknown `result`.\n     * @return result as a Point3d or `undefined` (if the matrix is singular).\n     */\n    multiplyInverseXYZAsPoint3d(x, y, z, result) {\n        this.computeCachedInverse(true);\n        if (this.inverseCoffs) {\n            return Point3d.create(this.inverseCoffs[0] * x + this.inverseCoffs[1] * y + this.inverseCoffs[2] * z, this.inverseCoffs[3] * x + this.inverseCoffs[4] * y + this.inverseCoffs[5] * z, this.inverseCoffs[6] * x + this.inverseCoffs[7] * y + this.inverseCoffs[8] * z, result);\n        }\n        return undefined;\n    }\n    /**\n     * Invoke a given matrix*matrix operation to compute the inverse matrix and set this.inverseCoffs\n     * * If either input coffA or coffB is `undefined`, set state to `InverseMatrixState.unknown` but\n     * leave the inverseCoffs untouched.\n     * @param f the given matrix*matrix operation that is called by this function to compute the inverse.\n     * `f` must be a matrix*matrix operation. Otherwise, the function does not generate the inverse properly.\n     */\n    finishInverseCoffs(f, coffA, coffB) {\n        if (coffA && coffB) {\n            this.createInverseCoffsWithZeros();\n            this.inverseState = InverseMatrixState.inverseStored;\n            f(coffA, coffB, this.inverseCoffs); // call function f (which is provided by user) to compute the inverse.\n        }\n        else {\n            this.inverseState = InverseMatrixState.unknown;\n        }\n    }\n    // Notes on inverse of matrix products:\n    //      1) M = A * B           ===>  MInverse = BInverse * AInverse\n    //      2) M = A * BInverse    ===>  MInverse = B * AInverse\n    //      3) M = AInverse * B    ===>  MInverse = BInverse * A\n    //      4) M = A * BTranspose  ===>  MInverse = BInverseTranspose * AInverse\n    //      5) M = ATranspose * B  ===>  MInverse = BInverse * AInverseTranspose\n    /**\n     * Multiply `this` matrix times `other` matrix\n     * @return the matrix result: this*other\n     */\n    multiplyMatrixMatrix(other, result) {\n        result = result ? result : new Matrix3d();\n        PackedMatrix3dOps.multiplyMatrixMatrix(this.coffs, other.coffs, result.coffs);\n        if (this.inverseState === InverseMatrixState.inverseStored\n            && other.inverseState === InverseMatrixState.inverseStored)\n            result.finishInverseCoffs((a, b, _result) => PackedMatrix3dOps.multiplyMatrixMatrix(a, b, _result), other.inverseCoffs, this.inverseCoffs);\n        else if (this.inverseState === InverseMatrixState.singular\n            || other.inverseState === InverseMatrixState.singular)\n            result.inverseState = InverseMatrixState.singular;\n        else\n            result.inverseState = InverseMatrixState.unknown;\n        return result;\n    }\n    /**\n     * Multiply `this` matrix times `inverse of other` matrix\n     * @return the matrix result: this*otherInverse\n     */\n    multiplyMatrixMatrixInverse(other, result) {\n        if (!other.computeCachedInverse(true))\n            return undefined;\n        result = result ? result : new Matrix3d();\n        PackedMatrix3dOps.multiplyMatrixMatrix(this.coffs, other.inverseCoffs, Matrix3d._productBuffer);\n        if (this.inverseState === InverseMatrixState.inverseStored)\n            result.finishInverseCoffs((a, b, _result) => PackedMatrix3dOps.multiplyMatrixMatrix(a, b, _result), other.coffs, this.inverseCoffs);\n        else\n            result.inverseState = InverseMatrixState.unknown;\n        PackedMatrix3dOps.copy(Matrix3d._productBuffer, result.coffs);\n        return result;\n    }\n    /**\n     * Multiply `inverse of this` matrix times `other` matrix\n     * @return the matrix result: thisInverse*other\n     */\n    multiplyMatrixInverseMatrix(other, result) {\n        if (!this.computeCachedInverse(true))\n            return undefined;\n        result = result ? result : new Matrix3d();\n        PackedMatrix3dOps.multiplyMatrixMatrix(this.inverseCoffs, other.coffs, Matrix3d._productBuffer);\n        if (other.inverseState === InverseMatrixState.inverseStored)\n            result.finishInverseCoffs((a, b, _result) => PackedMatrix3dOps.multiplyMatrixMatrix(a, b, _result), other.inverseCoffs, this.coffs);\n        else\n            result.inverseState = InverseMatrixState.unknown;\n        PackedMatrix3dOps.copy(Matrix3d._productBuffer, result.coffs);\n        return result;\n    }\n    /**\n     * Multiply `this` matrix times the transpose of `other` matrix\n     * ```\n     * equation\n     * \\text{for instance matrix }A\\text{ and matrix }B\\text{ return matrix }C{\\text where }\\\\\\matrixXY{C}=\\matrixXY{A}\\matrixTransposeSubXY{B}\n     * ```\n     * @return the matrix result: this*otherTranspose\n     */\n    multiplyMatrixMatrixTranspose(other, result) {\n        result = result ? result : new Matrix3d();\n        PackedMatrix3dOps.multiplyMatrixMatrixTranspose(this.coffs, other.coffs, result.coffs);\n        if (this.inverseState === InverseMatrixState.inverseStored && other.inverseState === InverseMatrixState.inverseStored)\n            result.finishInverseCoffs((a, b, _result) => PackedMatrix3dOps.multiplyMatrixTransposeMatrix(a, b, _result), other.inverseCoffs, this.inverseCoffs);\n        else if (this.inverseState === InverseMatrixState.singular || other.inverseState === InverseMatrixState.singular)\n            result.inverseState = InverseMatrixState.singular;\n        else\n            result.inverseState = InverseMatrixState.unknown;\n        return result;\n    }\n    /**\n     * Multiply the transpose of `this` matrix times `other` matrix\n     * ```\n     * equation\n     * \\matrixXY{result}=\\matrixXY{\\text{this}}\\matrixTransposeSubXY{\\text{other}}\n     * ```\n     * @return the matrix result: thisTranspose*other\n     */\n    multiplyMatrixTransposeMatrix(other, result) {\n        result = result ? result : new Matrix3d();\n        PackedMatrix3dOps.multiplyMatrixTransposeMatrix(this.coffs, other.coffs, result.coffs);\n        if (this.inverseState === InverseMatrixState.inverseStored && other.inverseState === InverseMatrixState.inverseStored)\n            result.finishInverseCoffs((a, b, _result) => PackedMatrix3dOps.multiplyMatrixMatrixTranspose(a, b, _result), other.inverseCoffs, this.inverseCoffs);\n        else if (this.inverseState === InverseMatrixState.singular || other.inverseState === InverseMatrixState.singular)\n            result.inverseState = InverseMatrixState.singular;\n        else\n            result.inverseState = InverseMatrixState.unknown;\n        return result;\n    }\n    /**\n     * Multiply `this` Matrix3d (considered to be a Transform with 0 `origin`) times `other` Transform.\n     * * **Note:** If `this = [A   0]` and `other = [B   b]`, then `this * other` is defined as [A*B   Ab] because:\n     * ```\n     * equation\n     * \\begin{matrix}\n     * \\text{this matrix }\\bold{A}\\text{ promoted to block Transform} & \\blockTransform{A}{0} \\\\\n     * \\text{other Transform with `matrix` part }\\bold{B}\\text{ and origin part }\\bold{b} & \\blockTransform{B}{b}\\\\\n     * \\text{product}& \\blockTransform{A}{0}\\blockTransform{B}{b}=\\blockTransform{AB}{Ab}\n     * \\end{matrix}\n     * ```\n     * @param other the `other` Transform to be multiplied to `this` matrix.\n     * @param result optional preallocated `result` to reuse.\n     */\n    multiplyMatrixTransform(other, result) {\n        if (!result)\n            return Transform.createRefs(this.multiplyXYZ(other.origin.x, other.origin.y, other.origin.z), this.multiplyMatrixMatrix(other.matrix));\n        this.multiplyXYZtoXYZ(other.origin, result.origin);\n        this.multiplyMatrixMatrix(other.matrix, result.matrix);\n        return result;\n    }\n    /**\n     * Return the transpose of `this` matrix.\n     * * If `result` is passed as argument, then the function copies the transpose of `this` into `result`.\n     * * `this` is not changed unless also passed as the result, i.e., `this.transpose(this)` transposes `this` in place.\n     */\n    transpose(result) {\n        if (!result)\n            result = new Matrix3d();\n        PackedMatrix3dOps.copyTransposed(this.coffs, result.coffs);\n        if (this.inverseCoffs !== undefined) {\n            result.inverseState = InverseMatrixState.inverseStored;\n            result.inverseCoffs = PackedMatrix3dOps.copyTransposed(this.inverseCoffs, result.inverseCoffs);\n        }\n        else {\n            result.inverseState = this.inverseState; // singular or unknown.\n            result.inverseCoffs = undefined;\n        }\n        return result;\n    }\n    /**\n     * Transpose this matrix in place.\n     */\n    transposeInPlace() {\n        PackedMatrix3dOps.transposeInPlace(this.coffs);\n        if (this.inverseCoffs)\n            PackedMatrix3dOps.transposeInPlace(this.inverseCoffs); // inverse of transpose is equal to transpose of inverse\n    }\n    /**\n     * Return the inverse matrix.\n     * The return is undefined if the matrix is singular (e.g. has parallel columns or a zero magnitude column)\n     * * If `result == this`, then content of inverse of `this` matrix is copied into `this`. Otherwise, inverse\n     * of `this` is stored in `result`.\n     * * **Note:** Each Matrix3d object caches its own inverse (`this.inverseCoffs`) and has methods to multiply\n     * the inverse times matrices and vectors (e.g., `multiplyMatrixInverseMatrix`, `multiplyMatrixMatrixInverse`,\n     * `multiplyInverse`). Hence explicitly constructing this new inverse object is rarely necessary.\n     */\n    inverse(result) {\n        if (!this.computeCachedInverse(true))\n            return undefined;\n        if (result === this) {\n            // swap the contents of this.coffs and this.inverseCoffs\n            PackedMatrix3dOps.copy(this.coffs, Matrix3d._productBuffer);\n            PackedMatrix3dOps.copy(this.inverseCoffs, this.coffs);\n            PackedMatrix3dOps.copy(Matrix3d._productBuffer, this.inverseCoffs);\n            return result;\n        }\n        if (result === undefined) {\n            result = Matrix3d.createIdentity();\n        }\n        result.createInverseCoffsWithZeros();\n        PackedMatrix3dOps.copy(this.coffs, result.inverseCoffs);\n        PackedMatrix3dOps.copy(this.inverseCoffs, result.coffs);\n        result.inverseState = this.inverseState;\n        return result;\n    }\n    /**\n     * Take the dot product of a row (specified by `rowStartA`) of `coffA` and `columnStartB` of `coffB`.\n     * * **Note:** We don't validate row/column numbers. Pass 0/3/6 for row 0/1/2 and pass 0/1/2 for column 0/1/2.\n     */\n    static rowColumnDot(coffA, rowStartA, coffB, columnStartB) {\n        return coffA[rowStartA] * coffB[columnStartB] +\n            coffA[rowStartA + 1] * coffB[columnStartB + 3] +\n            coffA[rowStartA + 2] * coffB[columnStartB + 6];\n    }\n    /**\n     * Take the cross product of 2 rows (specified by `rowStart0` and `rowStart1`) of `source` and store the result\n     * in `columnStart` of `dest`.\n     * * **Note:** We don't validate row/column numbers. Pass 0/3/6 for row 0/1/2 and pass 0/1/2 for column 0/1/2.\n     */\n    static indexedRowCrossProduct(source, rowStart0, rowStart1, dest, columnStart) {\n        dest[columnStart] = source[rowStart0 + 1] * source[rowStart1 + 2] - source[rowStart0 + 2] * source[rowStart1 + 1];\n        dest[columnStart + 3] = source[rowStart0 + 2] * source[rowStart1] - source[rowStart0] * source[rowStart1 + 2];\n        dest[columnStart + 6] = source[rowStart0] * source[rowStart1 + 1] - source[rowStart0 + 1] * source[rowStart1];\n    }\n    /**\n     * Take the cross product of 2 columns (i.e., `colStart0` and `colStart1`) of `this` matrix and store the\n     * result in `colStart2` of the same matrix.\n     * * **Note:** We don't validate column numbers. Pass 0/1/2 for column 0/1/2.\n     */\n    indexedColumnCrossProductInPlace(colStart0, colStart1, colStart2) {\n        const coffs = this.coffs;\n        coffs[colStart2] = coffs[colStart0 + 3] * coffs[colStart1 + 6] - coffs[colStart0 + 6] * coffs[colStart1 + 3];\n        coffs[colStart2 + 3] = coffs[colStart0 + 6] * coffs[colStart1] - coffs[colStart0] * coffs[colStart1 + 6];\n        coffs[colStart2 + 6] = coffs[colStart0] * coffs[colStart1 + 3] - coffs[colStart0 + 3] * coffs[colStart1];\n    }\n    /**\n     * Form cross products among columns in axisOrder.\n     * For axis order ABC:\n     * * form cross product of column A and B, store in C.\n     * * form cross product of column C and A, store in B.\n     * * [A   B   C] ===> [A   B   AxB] ===> [A   (AxB)xA   AxB]\n     *\n     * This means that in the final matrix:\n     * * first column is same as original column A.\n     * * second column is linear combination of original A and B (i.e., is in the plane of original A and B).\n     * * third column is perpendicular to first and second columns of both the original and final.\n     * * original column C is overwritten and does not participate in the result.\n     *\n     * The final matrix will have 3 orthogonal columns.\n     */\n    axisOrderCrossProductsInPlace(axisOrder) {\n        switch (axisOrder) {\n            case AxisOrder.XYZ: {\n                this.indexedColumnCrossProductInPlace(0, 1, 2);\n                this.indexedColumnCrossProductInPlace(2, 0, 1);\n                break;\n            }\n            case AxisOrder.YZX: {\n                this.indexedColumnCrossProductInPlace(1, 2, 0);\n                this.indexedColumnCrossProductInPlace(0, 1, 2);\n                break;\n            }\n            case AxisOrder.ZXY: {\n                this.indexedColumnCrossProductInPlace(2, 0, 1);\n                this.indexedColumnCrossProductInPlace(1, 2, 0);\n                break;\n            }\n            case AxisOrder.XZY: {\n                this.indexedColumnCrossProductInPlace(0, 2, 1);\n                this.indexedColumnCrossProductInPlace(1, 0, 2);\n                break;\n            }\n            case AxisOrder.YXZ: {\n                this.indexedColumnCrossProductInPlace(1, 0, 2);\n                this.indexedColumnCrossProductInPlace(2, 1, 0);\n                break;\n            }\n            case AxisOrder.ZYX: {\n                this.indexedColumnCrossProductInPlace(2, 1, 0);\n                this.indexedColumnCrossProductInPlace(0, 2, 1);\n                break;\n            }\n        }\n    }\n    /**\n     * Normalize each column in place.\n     * @param originalColumnMagnitudes optional vector to store original column magnitudes.\n     * @returns return true if all columns have non-zero lengths. Otherwise, return false.\n     * * If false is returned, the magnitudes are stored in the `originalColumnMagnitudes` vector but no columns\n     * are altered.\n     */\n    normalizeColumnsInPlace(originalColumnMagnitudes) {\n        const ax = this.columnXMagnitude();\n        const ay = this.columnYMagnitude();\n        const az = this.columnZMagnitude();\n        if (originalColumnMagnitudes)\n            originalColumnMagnitudes.set(ax, ay, az);\n        if (Geometry.isSmallMetricDistance(ax) || Geometry.isSmallMetricDistance(ay) || Geometry.isSmallMetricDistance(az))\n            return false;\n        this.scaleColumns(1.0 / ax, 1.0 / ay, 1.0 / az, this);\n        return true;\n    }\n    /**\n     * Normalize each row in place.\n     * @param originalRowMagnitudes optional vector to store original row magnitudes.\n     * @returns return true if all rows have non-zero lengths. Otherwise, return false.\n     * * If false is returned, the magnitudes are stored in the `originalRowMagnitudes` vector but no rows\n     * are altered.\n     */\n    normalizeRowsInPlace(originalRowMagnitudes) {\n        const ax = this.rowXMagnitude();\n        const ay = this.rowYMagnitude();\n        const az = this.rowZMagnitude();\n        if (originalRowMagnitudes)\n            originalRowMagnitudes.set(ax, ay, az);\n        if (Geometry.isSmallMetricDistance(ax) || Geometry.isSmallMetricDistance(ay) || Geometry.isSmallMetricDistance(az))\n            return false;\n        this.scaleRows(1.0 / ax, 1.0 / ay, 1.0 / az, this);\n        return true;\n    }\n    /**\n     * Returns true if the matrix is singular.\n     */\n    isSingular() {\n        return !this.computeCachedInverse(true);\n    }\n    /**\n     * Mark this matrix as singular.\n     */\n    markSingular() {\n        this.inverseState = InverseMatrixState.singular;\n    }\n    /**\n     * Compute the inverse of `this` Matrix3d. The inverse is stored in `this.inverseCoffs` for later use.\n     * @param useCacheIfAvailable if `true`, use the previously computed inverse if available. If `false`,\n     * recompute the inverse.\n     * @returns return `true` if the inverse is computed. Return `false` if matrix is singular.\n     */\n    computeCachedInverse(useCacheIfAvailable) {\n        if (useCacheIfAvailable && Matrix3d.useCachedInverse && this.inverseState !== InverseMatrixState.unknown) {\n            Matrix3d.numUseCache++;\n            return this.inverseState === InverseMatrixState.inverseStored;\n        }\n        this.inverseState = InverseMatrixState.unknown;\n        this.createInverseCoffsWithZeros();\n        const coffs = this.coffs;\n        const inverseCoffs = this.inverseCoffs;\n        /**\n         * We calculate the inverse using cross products.\n         * Math details can be found at docs/learning/matrix/Matrix.md\n         *                    [   A   ]\n         * In summary, if M = [   B   ] then inverse of M = (1/det)[BxC   CxA   AxB] where\n         *                    [   C   ]\n         * det is the determinant of matrix M (which is equal to \"A dot BxC\").\n         */\n        Matrix3d.indexedRowCrossProduct(coffs, 3, 6, inverseCoffs, 0); // BxC\n        Matrix3d.indexedRowCrossProduct(coffs, 6, 0, inverseCoffs, 1); // CxA\n        Matrix3d.indexedRowCrossProduct(coffs, 0, 3, inverseCoffs, 2); // AxB\n        Matrix3d.numComputeCache++;\n        const det = Matrix3d.rowColumnDot(coffs, 0, inverseCoffs, 0); // A dot BxC\n        if (det === 0.0) {\n            this.inverseState = InverseMatrixState.singular;\n            this.inverseCoffs = undefined;\n            return false;\n        }\n        const f = 1.0 / det;\n        for (let i = 0; i < 9; i++)\n            inverseCoffs[i] *= f;\n        this.inverseState = InverseMatrixState.inverseStored;\n        return true;\n    }\n    /**\n     * Convert a (row,column) index pair to the single index within flattened array of 9 numbers in row-major-order\n     * * **Note:** Out of range row/column is interpreted cyclically.\n     */\n    static flatIndexOf(row, column) {\n        return 3 * Geometry.cyclic3dAxis(row) + Geometry.cyclic3dAxis(column);\n    }\n    /**\n     * Get elements of column `index` packaged as a Point4d with given `weight`.\n     * * **Note:** Out of range index is interpreted cyclically.\n     */\n    indexedColumnWithWeight(index, weight, result) {\n        index = Geometry.cyclic3dAxis(index);\n        return Point4d.create(this.coffs[index], this.coffs[index + 3], this.coffs[index + 6], weight, result);\n    }\n    /** Return the entry at specific row and column */\n    at(row, column) {\n        return this.coffs[Matrix3d.flatIndexOf(row, column)];\n    }\n    /** Set the entry at specific row and column */\n    setAt(row, column, value) {\n        this.coffs[Matrix3d.flatIndexOf(row, column)] = value;\n        this.inverseState = InverseMatrixState.unknown;\n    }\n    /**\n     * Create a Matrix3d whose values are uniformly scaled from `this` Matrix3d.\n     * @param scale scale factor to apply.\n     * @param result optional result.\n     * @returns return the scaled matrix.\n     */\n    scale(scale, result) {\n        return Matrix3d.createRowValues(this.coffs[0] * scale, this.coffs[1] * scale, this.coffs[2] * scale, this.coffs[3] * scale, this.coffs[4] * scale, this.coffs[5] * scale, this.coffs[6] * scale, this.coffs[7] * scale, this.coffs[8] * scale, result);\n    }\n    /**\n     * Create a Matrix3d whose columns are scaled copies of `this` Matrix3d.\n     * @param scaleX scale factor for column 0\n     * @param scaleY scale factor for column 1\n     * @param scaleZ scale factor for column 2\n     * @param result optional result\n     */\n    scaleColumns(scaleX, scaleY, scaleZ, result) {\n        return Matrix3d.createRowValues(this.coffs[0] * scaleX, this.coffs[1] * scaleY, this.coffs[2] * scaleZ, this.coffs[3] * scaleX, this.coffs[4] * scaleY, this.coffs[5] * scaleZ, this.coffs[6] * scaleX, this.coffs[7] * scaleY, this.coffs[8] * scaleZ, result);\n    }\n    /**\n     * Scale the columns of `this` Matrix3d in place.\n     * @param scaleX scale factor for column 0\n     * @param scaleY scale factor for column 1\n     * @param scaleZ scale factor for column 2\n     */\n    scaleColumnsInPlace(scaleX, scaleY, scaleZ) {\n        this.coffs[0] *= scaleX;\n        this.coffs[1] *= scaleY;\n        this.coffs[2] *= scaleZ;\n        this.coffs[3] *= scaleX;\n        this.coffs[4] *= scaleY;\n        this.coffs[5] *= scaleZ;\n        this.coffs[6] *= scaleX;\n        this.coffs[7] *= scaleY;\n        this.coffs[8] *= scaleZ;\n        if (this.inverseState === InverseMatrixState.inverseStored && this.inverseCoffs !== undefined) {\n            // apply reciprocal scales to the ROWS of the inverse\n            const divX = Geometry.conditionalDivideFraction(1.0, scaleX);\n            const divY = Geometry.conditionalDivideFraction(1.0, scaleY);\n            const divZ = Geometry.conditionalDivideFraction(1.0, scaleZ);\n            if (divX !== undefined && divY !== undefined && divZ !== undefined) {\n                this.inverseCoffs[0] *= divX;\n                this.inverseCoffs[1] *= divX;\n                this.inverseCoffs[2] *= divX;\n                this.inverseCoffs[3] *= divY;\n                this.inverseCoffs[4] *= divY;\n                this.inverseCoffs[5] *= divY;\n                this.inverseCoffs[6] *= divZ;\n                this.inverseCoffs[7] *= divZ;\n                this.inverseCoffs[8] *= divZ;\n            }\n            else\n                this.inverseState = InverseMatrixState.singular;\n        }\n    }\n    /**\n     * Create a Matrix3d whose rows are scaled copies of `this` Matrix3d.\n     * @param scaleX scale factor for row 0\n     * @param scaleY scale factor for row 1\n     * @param scaleZ scale factor for row 2\n     * @param result optional result\n     */\n    scaleRows(scaleX, scaleY, scaleZ, result) {\n        return Matrix3d.createRowValues(this.coffs[0] * scaleX, this.coffs[1] * scaleX, this.coffs[2] * scaleX, this.coffs[3] * scaleY, this.coffs[4] * scaleY, this.coffs[5] * scaleY, this.coffs[6] * scaleZ, this.coffs[7] * scaleZ, this.coffs[8] * scaleZ, result);\n    }\n    /**\n     * Scale the rows of `this` Matrix3d in place.\n     * @param scaleX scale factor for row 0\n     * @param scaleY scale factor for row 1\n     * @param scaleZ scale factor for row 2\n     */\n    scaleRowsInPlace(scaleX, scaleY, scaleZ) {\n        this.coffs[0] *= scaleX;\n        this.coffs[1] *= scaleX;\n        this.coffs[2] *= scaleX;\n        this.coffs[3] *= scaleY;\n        this.coffs[4] *= scaleY;\n        this.coffs[5] *= scaleY;\n        this.coffs[6] *= scaleZ;\n        this.coffs[7] *= scaleZ;\n        this.coffs[8] *= scaleZ;\n        if (this.inverseState === InverseMatrixState.inverseStored && this.inverseCoffs !== undefined) {\n            // apply reciprocal scales to the COLUMNs of the inverse\n            const divX = Geometry.conditionalDivideFraction(1.0, scaleX);\n            const divY = Geometry.conditionalDivideFraction(1.0, scaleY);\n            const divZ = Geometry.conditionalDivideFraction(1.0, scaleZ);\n            if (divX !== undefined && divY !== undefined && divZ !== undefined) {\n                this.inverseCoffs[0] *= divX;\n                this.inverseCoffs[1] *= divY;\n                this.inverseCoffs[2] *= divZ;\n                this.inverseCoffs[3] *= divX;\n                this.inverseCoffs[4] *= divY;\n                this.inverseCoffs[5] *= divZ;\n                this.inverseCoffs[6] *= divX;\n                this.inverseCoffs[7] *= divY;\n                this.inverseCoffs[8] *= divZ;\n            }\n            else\n                this.inverseState = InverseMatrixState.singular;\n        }\n    }\n    /**\n     * Add scaled values from `other` Matrix3d to `this` Matrix3d.\n     * @param other Matrix3d with values to be added.\n     * @param scale scale factor to apply to the added values.\n     */\n    addScaledInPlace(other, scale) {\n        for (let i = 0; i < 9; i++)\n            this.coffs[i] += scale * other.coffs[i];\n        this.inverseState = InverseMatrixState.unknown;\n    }\n    /**\n     * Add scaled values from an outer product of vectors U and V.\n     * * The scaled outer product is a matrix with `rank 1` (all columns/rows are linearly dependent).\n     * * This is useful in constructing mirrors and directional scales.\n     * ```\n     * equation\n     * A += s \\columnSubXYZ{U}\\rowSubXYZ{V}\n     * \\\\ \\matrixXY{A} += s \\begin{bmatrix}\n     * U_x * V_x & U_x * V_y & U_x * V_z \\\\\n     * U_y * V_x & U_y * V_y & U_y * V_z \\\\\n     * U_z * V_x & U_z * V_y & U_z * V_z \\end{bmatrix}\n     * ```\n     * @param vectorU first vector in the outer product.\n     * @param vectorV second vector in the outer product.\n     * @param scale scale factor to apply to the added values.\n     */\n    addScaledOuterProductInPlace(vectorU, vectorV, scale) {\n        this.coffs[0] += scale * vectorU.x * vectorV.x;\n        this.coffs[1] += scale * vectorU.x * vectorV.y;\n        this.coffs[2] += scale * vectorU.x * vectorV.z;\n        this.coffs[3] += scale * vectorU.y * vectorV.x;\n        this.coffs[4] += scale * vectorU.y * vectorV.y;\n        this.coffs[5] += scale * vectorU.y * vectorV.z;\n        this.coffs[6] += scale * vectorU.z * vectorV.x;\n        this.coffs[7] += scale * vectorU.z * vectorV.y;\n        this.coffs[8] += scale * vectorU.z * vectorV.z;\n        this.inverseState = InverseMatrixState.unknown;\n    }\n    /**\n     * Create a rigid matrix (columns and rows are unit length and pairwise perpendicular) for the given eye coordinate.\n     * * column 2 is parallel to (x,y,z).\n     * * column 0 is perpendicular to column 2 and is in the xy plane.\n     * * column 1 is perpendicular to both. It is the \"up\" vector on the view plane.\n     * * Multiplying the returned matrix times a local (view) vector gives the world vector.\n     * * Multiplying transpose of the returned matrix times a world vector gives the local (view) vector.\n     * * If you want to rotate a given plane (which contains (0,0,0)) to the xy-plane, pass coordinates of the normal\n     * vector of your plane into createRigidViewAxesZTowardsEye. The transpose of the returned Matrix3d can be used\n     * to rotate your plane to the xy-plane. If plane does not contain (0,0,0) then the plane is rotated to a plane\n     * parallel to the xy-plane.\n     * @param x eye x coordinate\n     * @param y eye y coordinate\n     * @param z eye z coordinate\n     * @param result optional preallocated result\n     */\n    static createRigidViewAxesZTowardsEye(x, y, z, result) {\n        result = Matrix3d.createIdentity(result);\n        const rxy = Geometry.hypotenuseXY(x, y);\n        // if coordinate is (0,0,z), i.e., Top or Bottom view\n        if (Geometry.isSmallMetricDistance(rxy)) {\n            if (z < 0.0)\n                result.scaleColumnsInPlace(1.0, -1.0, -1.0);\n        }\n        else {\n            /**\n             * The matrix that the \"else\" statement creates is\n             *        [-s   -s1*c    c1*c]\n             *        [c    -s1*s    c1*s]\n             *        [0      c1      s1 ]\n             * where\n             *        c = x / sqrt(x*x + y*y)\n             *        s = y / sqrt(x*x + y*y)\n             *        c1 = sqrt(x*x + y*y) / sqrt(x*x + y*y + z*z)\n             *        s1 = z / sqrt(x*x + y*y + z*z)\n             *\n             * This is an orthogonal matrix meaning it rotates the standard XYZ axis to ABC axis system\n             * (if matrix is [A B C]). The matrix rotates (0,0,1), i.e., the default Top view or Z axis,\n             * to the eye point (x/r,y/r,z/r) where r = sqrt(x*x + y*y + z*z). The matrix also rotates\n             * (1,0,0) to a point on XY plane.\n             */\n            const c = x / rxy;\n            const s = y / rxy;\n            // if coordinate is (x,y,0), e.g., Front or Back or Left or Right view (for those 4 views x or y is 0 not both)\n            result.setRowValues(-s, 0, c, c, 0, s, 0, 1, 0);\n            // if coordinate is (x,y,z) and z is not 0, i.e., other views such as Iso or RightIso\n            if (z !== 0.0) {\n                const r = Geometry.hypotenuseXYZ(x, y, z);\n                const s1 = z / r;\n                const c1 = rxy / r;\n                result.applyGivensColumnOp(1, 2, c1, -s1);\n            }\n        }\n        return result;\n    }\n    /** Return the determinant of `this` matrix. */\n    determinant() {\n        return this.coffs[0] * this.coffs[4] * this.coffs[8]\n            - this.coffs[0] * this.coffs[5] * this.coffs[7]\n            - this.coffs[1] * this.coffs[3] * this.coffs[8]\n            + this.coffs[1] * this.coffs[5] * this.coffs[6]\n            + this.coffs[2] * this.coffs[3] * this.coffs[7]\n            - this.coffs[2] * this.coffs[4] * this.coffs[6];\n    }\n    /**\n     * Return an estimate of how independent the columns of `this` matrix are. Near zero is bad (i.e.,\n     * columns are almost dependent and matrix is nearly singular). Near 1 is good (i.e., columns are\n     * almost independent and matrix is invertible).\n     */\n    conditionNumber() {\n        const determinant = Math.abs(this.determinant());\n        const columnMagnitudeSum = Geometry.hypotenuseXYZ(this.coffs[0], this.coffs[3], this.coffs[6])\n            + Geometry.hypotenuseXYZ(this.coffs[1], this.coffs[4], this.coffs[7])\n            + Geometry.hypotenuseXYZ(this.coffs[2], this.coffs[5], this.coffs[8]);\n        return Geometry.safeDivideFraction(determinant, columnMagnitudeSum, 0.0);\n    }\n    /** Return the sum of squares of all entries */\n    sumSquares() {\n        let sum = 0;\n        for (let i = 0; i < 9; i++)\n            sum += this.coffs[i] * this.coffs[i];\n        return sum;\n    }\n    /** Return the sum of squares of diagonal entries */\n    sumDiagonalSquares() {\n        let sum = 0;\n        for (let i = 0; i < 9; i += 4)\n            sum += this.coffs[i] * this.coffs[i];\n        return sum;\n    }\n    /** Return the matrix `trace` (sum of diagonal entries) */\n    sumDiagonal() {\n        return this.coffs[0] + this.coffs[4] + this.coffs[8];\n    }\n    /** Return the Maximum absolute value of any single entry */\n    maxAbs() {\n        let max = 0;\n        for (let i = 0; i < 9; i++)\n            max = Math.max(max, Math.abs(this.coffs[i]));\n        return max;\n    }\n    /** Return the maximum absolute difference between corresponding entries of `this` and `other` */\n    maxDiff(other) {\n        let max = 0;\n        for (let i = 0; i < 9; i++)\n            max = Math.max(max, Math.abs(this.coffs[i] - other.coffs[i]));\n        return max;\n    }\n    /** Test if the matrix is (very near to) an identity */\n    get isIdentity() {\n        return this.maxDiff(Matrix3d.identity) < Geometry.smallAngleRadians;\n    }\n    /** Test if the off diagonal entries are all nearly zero */\n    get isDiagonal() {\n        const sumAll = this.sumSquares();\n        const sumDiagonal = this.sumDiagonalSquares();\n        const sumOff = Math.abs(sumAll - sumDiagonal);\n        return Math.sqrt(sumOff) <= Geometry.smallAngleRadians * (1.0 + Math.sqrt(sumAll));\n    }\n    /** Sum of squared differences between symmetric pairs (symmetric pairs have indices (1,3), (2,6), and (5,7).) */\n    sumSkewSquares() {\n        return Geometry.hypotenuseSquaredXYZ(this.coffs[1] - this.coffs[3], this.coffs[2] - this.coffs[6], this.coffs[5] - this.coffs[7]);\n    }\n    /** Test if the matrix is (very near to) symmetric */\n    isSymmetric() {\n        const offDiagonal = this.sumSkewSquares();\n        return Math.sqrt(offDiagonal) <= Geometry.smallAngleRadians * (1.0 + Math.sqrt(this.sumSquares()));\n    }\n    /** Test if the stored inverse is present and marked valid */\n    get hasCachedInverse() {\n        return this.inverseState === InverseMatrixState.inverseStored && this.inverseCoffs !== undefined;\n    }\n    /** Test if the below diagonal entries (3,6,7) are all nearly zero */\n    get isUpperTriangular() {\n        const sumAll = this.sumSquares();\n        const sumLow = Geometry.hypotenuseSquaredXYZ(this.coffs[3], this.coffs[6], this.coffs[7]);\n        return Math.sqrt(sumLow) <= Geometry.smallAngleRadians * (1.0 + Math.sqrt(sumAll));\n    }\n    /** Test if the above diagonal entries (1,2,5) are all nearly zero */\n    get isLowerTriangular() {\n        const sumAll = this.sumSquares();\n        const sumLow = Geometry.hypotenuseSquaredXYZ(this.coffs[1], this.coffs[2], this.coffs[5]);\n        return Math.sqrt(sumLow) <= Geometry.smallAngleRadians * (1.0 + Math.sqrt(sumAll));\n    }\n    /**\n     * If the matrix is diagonal and all diagonals are almost equal, return the first diagonal (entry 0\n     * which is same as entry 4 and 8). Otherwise return `undefined`.\n     */\n    sameDiagonalScale() {\n        const sumAll = this.sumSquares();\n        const sumDiagonal = this.sumDiagonalSquares();\n        const sumOff = Math.abs(sumAll - sumDiagonal);\n        if (Math.sqrt(sumOff) <= Geometry.smallAngleRadians * (1.0 + Math.sqrt(sumAll))\n            && Geometry.isSameCoordinate(this.coffs[0], this.coffs[4])\n            && Geometry.isSameCoordinate(this.coffs[0], this.coffs[8]))\n            return this.coffs[0];\n        return undefined;\n    }\n    /**\n     * Test if all rows and columns are unit length and are perpendicular to each other, i.e., the matrix is either\n     * a `pure rotation` (determinant is +1) or is a `mirror` (determinant is -1).\n     * * **Note:** such a matrix is called `orthogonal` and its inverse is its transpose.\n     */\n    testPerpendicularUnitRowsAndColumns() {\n        const product = this.multiplyMatrixMatrixTranspose(this);\n        return product.isIdentity;\n    }\n    /**\n     * Test if the matrix is a `rigid` matrix (or `pure rotation`, i.e., columns and rows are unit length and\n     * pairwise perpendicular and determinant is +1).\n     * @param allowMirror whether to widen the test to return true if the matrix is a `mirror` (determinant is -1).\n    */\n    isRigid(allowMirror = false) {\n        return this.testPerpendicularUnitRowsAndColumns() && (allowMirror || this.determinant() > 0);\n    }\n    /**\n     * Test if all rows and columns are perpendicular to each other and have equal length.\n     * If so, the length (or its negative) is the `scale` factor from a set of `orthonormal axes` to\n     * the set of axes created by columns of `this` matrix. Otherwise, returns `undefined`.\n     * @param result optional pre-allocated object to populate and return\n     * @returns returns `{ rigidAxes, scale }` where `rigidAxes` is a Matrix3d with its columns as the rigid axes\n     * (with the scale factor removed) and `scale` is the scale factor.\n     * * Note that determinant of a rigid matrix is +1.\n     * * The context for this method is to determine if the matrix is the product a `rotation` matrix and a uniform\n     * `scale` matrix (diagonal matrix with all diagonal entries the same nonzero number).\n     */\n    factorRigidWithSignedScale(result) {\n        const product = this.multiplyMatrixMatrixTranspose(this);\n        const scaleSquare = product.sameDiagonalScale();\n        if (scaleSquare === undefined || scaleSquare <= 0.0)\n            return undefined;\n        const scale = this.determinant() > 0 ? Math.sqrt(scaleSquare) : -Math.sqrt(scaleSquare);\n        const scaleInverse = 1.0 / scale;\n        return { rigidAxes: this.scaleColumns(scaleInverse, scaleInverse, scaleInverse, result), scale };\n    }\n    /** Test if `this` matrix reorders and/or negates the columns of the `identity` matrix. */\n    get isSignedPermutation() {\n        let count = 0;\n        for (let row = 0; row < 3; row++)\n            for (let col = 0; col < 3; col++) {\n                const q = this.at(row, col);\n                if (q === 0) {\n                    // do nothing\n                }\n                else if (q === 1 || q === -1) {\n                    count++;\n                    // if the rest of this row and column should be 0 (\"at\" will apply cyclic indexing)\n                    if ((this.at(row + 1, col) !== 0) || (this.at(row + 2, col) !== 0) ||\n                        (this.at(row, col + 1) !== 0) || (this.at(row, col + 2) !== 0))\n                        return false;\n                }\n                else { // entry is not 0, 1, or -1\n                    return false;\n                }\n            }\n        return count === 3;\n    }\n    /**\n     * Adjust the matrix in place to make is a `rigid` matrix so that:\n     * * columns are perpendicular and have unit length.\n     * * transpose equals inverse.\n     * * mirroring is removed.\n     * * This function internally uses `axisOrderCrossProductsInPlace` to make the matrix rigid.\n     * @param axisOrder how to reorder the matrix columns\n     * @return whether the adjusted matrix is `rigid` on return\n     */\n    makeRigid(axisOrder = AxisOrder.XYZ) {\n        const maxAbs = this.maxAbs();\n        if (Geometry.isSmallMetricDistance(maxAbs))\n            return false;\n        const scale = 1.0 / maxAbs;\n        this.scaleColumnsInPlace(scale, scale, scale);\n        this.axisOrderCrossProductsInPlace(axisOrder);\n        return this.normalizeColumnsInPlace();\n    }\n    /**\n     * Create a new orthogonal matrix (perpendicular columns, unit length, transpose is inverse).\n     * * Columns are taken from the source Matrix3d in order indicated by the axis order.\n     * * Mirroring in the matrix is removed.\n     * * This function internally uses `axisOrderCrossProductsInPlace` to make the matrix rigid.\n     */\n    static createRigidFromMatrix3d(source, axisOrder = AxisOrder.XYZ, result) {\n        result = source.clone(result);\n        if (result.makeRigid(axisOrder))\n            return result;\n        return undefined;\n    }\n    /**\n     * Create a matrix from a quaternion.\n     * **WARNING:** There is frequent confusion over whether a \"from quaternion\" matrix is organized by\n     * rows or columns. If you find that the matrix seems to rotate by the opposite angle, transpose it.\n     *\n     * Some math details can be found at\n     * http://marc-b-reynolds.github.io/quaternions/2017/08/08/QuatRotMatrix.html\n     */\n    static createFromQuaternion(quat) {\n        const qqx = quat.x * quat.x;\n        const qqy = quat.y * quat.y;\n        const qqz = quat.z * quat.z;\n        const qqw = quat.w * quat.w;\n        const mag2 = qqx + qqy + qqz + qqw;\n        if (mag2 === 0.0) {\n            return Matrix3d.createIdentity();\n        }\n        else {\n            const a = 1.0 / mag2;\n            const matrix = Matrix3d.createRowValues(\n            // first row\n            a * (qqw + qqx - qqy - qqz), 2.0 * a * (quat.w * quat.z + quat.x * quat.y), 2.0 * a * (quat.x * quat.z - quat.w * quat.y), \n            // second row\n            2.0 * a * (quat.x * quat.y - quat.w * quat.z), a * (qqw - qqx + qqy - qqz), 2.0 * a * (quat.w * quat.x + quat.y * quat.z), \n            // third row\n            2.0 * a * (quat.x * quat.z + quat.w * quat.y), 2.0 * a * (quat.y * quat.z - quat.w * quat.x), a * (qqw - qqx - qqy + qqz));\n            return matrix;\n        }\n    }\n    /** Calculate quaternion terms used to convert matrix to a quaternion */\n    static computeQuatTerm(numerator, denomCoff, reciprocal, diagSum) {\n        let coff;\n        const diagTol = 0.500;\n        if (diagSum > diagTol) {\n            coff = 0.5 * Math.sqrt(diagSum);\n            if (denomCoff * numerator < 0.0)\n                coff = -coff;\n        }\n        else {\n            coff = numerator * reciprocal;\n        }\n        return coff;\n    }\n    /**\n     * Create `this` matrix to a quaternion.\n     * **Note:** This calculation requires `this` matrix to have unit length rows and columns.\n     * **WARNING:** There is frequent confusion over whether a \"from quaternion\" matrix is organized by\n     * rows or columns. If you find that the matrix seems to rotate by the opposite angle, transpose it.\n     *\n     * Some math details can be found at\n     * http://marc-b-reynolds.github.io/quaternions/2017/08/08/QuatRotMatrix.html\n     */\n    toQuaternion() {\n        const result = Point4d.createZero();\n        const props = [\n            [this.coffs[0], this.coffs[3], this.coffs[6]],\n            [this.coffs[1], this.coffs[4], this.coffs[7]],\n            [this.coffs[2], this.coffs[5], this.coffs[8]],\n        ];\n        const xx = props[0][0];\n        const yy = props[1][1];\n        const zz = props[2][2];\n        const dSum = [];\n        dSum[0] = 1.0 + xx - yy - zz;\n        dSum[1] = 1.0 - xx + yy - zz;\n        dSum[2] = 1.0 - xx - yy + zz;\n        dSum[3] = 1.0 + xx + yy + zz;\n        let denom;\n        let maxIndex = 0;\n        for (let i = 1; i <= 3; i++) {\n            if (dSum[i] > dSum[maxIndex])\n                maxIndex = i;\n        }\n        if (maxIndex === 0) {\n            result.x = 0.5 * Math.sqrt(dSum[0]);\n            denom = 1.0 / (4.0 * result.x);\n            result.y = Matrix3d.computeQuatTerm(props[0][1] + props[1][0], result.x, denom, dSum[1]);\n            result.z = Matrix3d.computeQuatTerm(props[0][2] + props[2][0], result.x, denom, dSum[2]);\n            result.w = Matrix3d.computeQuatTerm(props[2][1] - props[1][2], result.x, denom, dSum[3]);\n        }\n        else if (maxIndex === 1) {\n            result.y = 0.5 * Math.sqrt(dSum[1]);\n            denom = 1.0 / (4.0 * result.y);\n            result.x = Matrix3d.computeQuatTerm(props[0][1] + props[1][0], result.y, denom, dSum[0]);\n            result.z = Matrix3d.computeQuatTerm(props[1][2] + props[2][1], result.y, denom, dSum[2]);\n            result.w = Matrix3d.computeQuatTerm(props[0][2] - props[2][0], result.y, denom, dSum[3]);\n        }\n        else if (maxIndex === 2) {\n            result.z = 0.5 * Math.sqrt(dSum[2]);\n            denom = 1.0 / (4.0 * result.z);\n            result.x = Matrix3d.computeQuatTerm(props[0][2] + props[2][0], result.z, denom, dSum[0]);\n            result.y = Matrix3d.computeQuatTerm(props[1][2] + props[2][1], result.z, denom, dSum[1]);\n            result.w = Matrix3d.computeQuatTerm(props[1][0] - props[0][1], result.z, denom, dSum[3]);\n        }\n        else {\n            result.w = 0.5 * Math.sqrt(dSum[3]);\n            denom = 1.0 / (4.0 * result.w);\n            result.x = Matrix3d.computeQuatTerm(props[2][1] - props[1][2], result.w, denom, dSum[0]);\n            result.y = Matrix3d.computeQuatTerm(props[0][2] - props[2][0], result.w, denom, dSum[1]);\n            result.z = Matrix3d.computeQuatTerm(props[1][0] - props[0][1], result.w, denom, dSum[2]);\n        }\n        return result;\n    }\n}\n/** Control flag for whether this class uses cached inverse of matrices. */\nMatrix3d.useCachedInverse = true; // cached inverse can be suppressed for testing.\n/** Total number of times a cached inverse was used to avoid recompute */\nMatrix3d.numUseCache = 0;\n/** Total number of times a cached inverse was computed. */\nMatrix3d.numComputeCache = 0;\n/** temporary buffer to store a matrix as a Float64Array (array of 9 floats) */\nMatrix3d._productBuffer = new Float64Array(9);\nexport { Matrix3d };\n//# sourceMappingURL=Matrix3d.js.map",
      "start": 1693508122323,
      "end": 1693508122444,
      "sourcemaps": null
    }
  ]
}
