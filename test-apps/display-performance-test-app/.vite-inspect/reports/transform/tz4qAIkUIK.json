{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/IModelConnection.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module IModelConnection\n */\nimport { assert, BeEvent, GeoServiceStatus, Id64, Logger, OneAtATimeAction, OpenMode, TransientIdSequence, } from \"@itwin/core-bentley\";\nimport { Cartographic, CodeSpec, DbResult, EcefLocation, ECSqlReader, FontMap, GeoCoordStatus, ImageSourceFormat, IModel, IModelError, IModelReadRpcInterface, IModelStatus, mapToGeoServiceStatus, NoContentError, Placement2d, Placement3d, QueryOptionsBuilder, QueryRowFormat, RpcManager, SnapshotIModelRpcInterface, ViewStoreRpc, } from \"@itwin/core-common\";\nimport { Point3d, Range3d, Transform } from \"@itwin/core-geometry\";\nimport { FrontendLoggerCategory } from \"./common/FrontendLoggerCategory\";\nimport { GeoServices } from \"./GeoServices\";\nimport { IModelApp } from \"./IModelApp\";\nimport { IModelRoutingContext } from \"./IModelRoutingContext\";\nimport { ModelState } from \"./ModelState\";\nimport { HiliteSet, SelectionSet } from \"./SelectionSet\";\nimport { SubCategoriesCache } from \"./SubCategoriesCache\";\nimport { BingElevationProvider } from \"./tile/internal\";\nimport { Tiles } from \"./Tiles\";\nimport { ViewState } from \"./ViewState\";\nconst loggerCategory = FrontendLoggerCategory.IModelConnection;\n/** A connection to a [IModelDb]($backend) hosted on the backend.\n * @public\n * @extensions\n */\nclass IModelConnection extends IModel {\n    /** A cache of information about SubCategories chiefly used for rendering.\n     * @internal\n     */\n    get subcategories() { return this.categories.cache; }\n    /** @internal Return true if a GCS is not defined for this iModelConnection; also returns true if GCS is defined but disabled. */\n    get noGcsDefined() { return this._gcsDisabled || undefined === this.geographicCoordinateSystem; }\n    /** @internal */\n    disableGCS(disable) { this._gcsDisabled = disable; }\n    /** Type guard for instanceof [[BriefcaseConnection]] */\n    isBriefcaseConnection() { return false; }\n    /** Type guard for instanceof [[CheckpointConnection]]\n     * @beta\n    */\n    isCheckpointConnection() { return false; }\n    /** Type guard for instanceof [[SnapshotConnection]] */\n    isSnapshotConnection() { return false; }\n    /** Type guard for instanceof [[BlankConnection]] */\n    isBlankConnection() { return false; }\n    /** Returns `true` if this is a briefcase copy of an iModel that is synchronized with iModelHub. */\n    get isBriefcase() { return this.isBriefcaseConnection(); }\n    /** Returns `true` if this is a *snapshot* iModel.\n     * @see [[SnapshotConnection.openSnapshot]]\n     */\n    get isSnapshot() { return this.isSnapshotConnection(); }\n    /** True if this is a [Blank Connection]($docs/learning/frontend/BlankConnection). */\n    get isBlank() { return this.isBlankConnection(); }\n    /** Check the [[openMode]] of this IModelConnection to see if it was opened read-only. */\n    get isReadonly() { return this.openMode === OpenMode.Readonly; }\n    /** Check if the IModelConnection is open (i.e. it has a *connection* to a backend server).\n     * Returns false for [[BlankConnection]] instances and after [[IModelConnection.close]] has been called.\n     * @note no RPC operations are valid on this IModelConnection if this method returns false.\n     */\n    get isOpen() { return !this.isClosed; }\n    /** Load the FontMap for this IModelConnection.\n     * @returns Returns a Promise<FontMap> that is fulfilled when the FontMap member of this IModelConnection is valid.\n     */\n    async loadFontMap() {\n        if (undefined === this.fontMap) {\n            this.fontMap = new FontMap();\n            if (this.isOpen) {\n                const fontProps = await IModelReadRpcInterface.getClientForRouting(this.routingContext.token).readFontJson(this.getRpcProps());\n                this.fontMap.addFonts(fontProps.fonts);\n            }\n        }\n        return this.fontMap;\n    }\n    /** Find the first registered base class of the given EntityState className. This class will \"handle\" the State for the supplied className.\n     * @param className The full name of the class of interest.\n     * @param defaultClass If no base class of the className is registered, return this value.\n     * @note this method is async since it may have to query the server to get the class hierarchy.\n     */\n    async findClassFor(className, defaultClass) {\n        let ctor = IModelApp.lookupEntityClass(className);\n        if (undefined !== ctor)\n            return ctor;\n        // it's not registered, we need to query its class hierarchy.\n        ctor = defaultClass; // in case we cant find a registered class that handles this class\n        // wait until we get the full list of base classes from backend\n        if (this.isOpen) {\n            const baseClasses = await IModelReadRpcInterface.getClientForRouting(this.routingContext.token).getClassHierarchy(this.getRpcProps(), className);\n            // Make sure some other async code didn't register this class while we were await-ing above\n            ctor = IModelApp.lookupEntityClass(className);\n            if (undefined !== ctor)\n                return ctor;\n            // walk through the list until we find a registered base class\n            baseClasses.some((baseClass) => {\n                const test = IModelApp.lookupEntityClass(baseClass);\n                if (test === undefined)\n                    return false; // nope, not registered\n                ctor = test; // found it, save it\n                IModelApp.registerEntityState(className, ctor); // and register the fact that our starting class is handled by this subclass.\n                return true; // stop\n            });\n        }\n        return ctor; // either the baseClass handler or defaultClass if we didn't find a registered baseClass\n    }\n    /** @internal */\n    constructor(iModelProps) {\n        super(iModelProps);\n        /** Generator for unique Ids of transient graphics for this IModelConnection. */\n        this.transientIds = new TransientIdSequence();\n        /** @internal Whether GCS has been disabled for this iModelConnection. */\n        this._gcsDisabled = false;\n        this._extentsExpansion = Range3d.createNull();\n        /** The RPC routing for this connection. */\n        this.routingContext = IModelRoutingContext.default;\n        /** Event called immediately before *this* IModelConnection is closed.\n         * @note This event is called only for this IModelConnection. To monitor *all* IModelConnections,use the static event.\n         * @note Be careful not to perform any asynchronous operations on the IModelConnection because it will close before they are processed.\n         * @beta\n         */\n        this.onClose = new BeEvent();\n        this._snapRpc = new OneAtATimeAction(async (props) => IModelReadRpcInterface.getClientForRouting(this.routingContext.token).requestSnap(this.getRpcProps(), IModelApp.sessionId, props));\n        this._toolTipRpc = new OneAtATimeAction(async (id) => IModelReadRpcInterface.getClientForRouting(this.routingContext.token).getToolTipMessage(this.getRpcProps(), id));\n        /** Event called immediately after map elevation request is completed. This occurs only in the case where background map terrain is displayed\n         * with either geoid or ground offset. These require a query to BingElevation and therefore synching the view may be required\n         * when the request is completed.\n         * @internal\n         */\n        this.onMapElevationLoaded = new BeEvent();\n        super.initialize(iModelProps.name, iModelProps);\n        this.models = new IModelConnection.Models(this);\n        this.elements = new IModelConnection.Elements(this);\n        this.codeSpecs = new IModelConnection.CodeSpecs(this);\n        this.views = new IModelConnection.Views(this);\n        this.categories = new IModelConnection.Categories(this);\n        this.selectionSet = new SelectionSet(this);\n        this.hilited = new HiliteSet(this);\n        this.tiles = new Tiles(this);\n        this.geoServices = GeoServices.createForIModel(this);\n        /* eslint-disable-next-line deprecation/deprecation */\n        this.displayedExtents = Range3d.fromJSON(this.projectExtents);\n        this.onProjectExtentsChanged.addListener(() => {\n            // Compute new displayed extents as the union of the ranges we previously expanded by with the new project extents.\n            /* eslint-disable-next-line deprecation/deprecation */\n            this.expandDisplayedExtents(this._extentsExpansion);\n        });\n        this.hilited.onModelSubCategoryModeChanged.addListener(() => {\n            IModelApp.viewManager.onSelectionSetChanged(this);\n        });\n    }\n    /** Called prior to connection closing. Raises close events and calls tiles.dispose.\n     * @internal\n     */\n    beforeClose() {\n        this.onClose.raiseEvent(this); // event for this connection\n        IModelConnection.onClose.raiseEvent(this); // event for all connections\n        this.tiles.dispose();\n        this.subcategories.onIModelConnectionClose();\n    }\n    /** Allow to execute query and read results along with meta data. The result are streamed.\n     *\n     * See also:\n     * - [ECSQL Overview]($docs/learning/frontend/ExecutingECSQL)\n     * - [Code Examples]($docs/learning/frontend/ECSQLCodeExamples)\n     * - [ECSQL Row Format]($docs/learning/ECSQLRowFormat)\n     *\n     * @param params The values to bind to the parameters (if the ECSQL has any).\n     * @param config Allow to specify certain flags which control how query is executed.\n     * @returns Returns an [ECSqlReader]($common) which helps iterate over the result set and also give access to metadata.\n     * @public\n     * */\n    createQueryReader(ecsql, params, config) {\n        const executor = {\n            execute: async (request) => {\n                return IModelReadRpcInterface.getClientForRouting(this.routingContext.token).queryRows(this.getRpcProps(), request);\n            },\n        };\n        return new ECSqlReader(executor, ecsql, params, config);\n    }\n    /**\n     * queries the BisCore.SubCategory table for the entries that are children of the passed categoryIds\n     * @param compressedCategoryIds compressed category Ids\n     * @returns array of SubCategoryResultRow\n     * @internal\n     */\n    async querySubCategories(compressedCategoryIds) {\n        return IModelReadRpcInterface.getClientForRouting(this.routingContext.token).querySubCategories(this.getRpcProps(), compressedCategoryIds);\n    }\n    /** Execute a query and stream its results\n     * The result of the query is async iterator over the rows. The iterator will get next page automatically once rows in current page has been read.\n     * [ECSQL row]($docs/learning/ECSQLRowFormat).\n     *\n     * See also:\n     * - [ECSQL Overview]($docs/learning/frontend/ExecutingECSQL)\n     * - [Code Examples]($docs/learning/frontend/ECSQLCodeExamples)\n     *\n     * @param ecsql The ECSQL statement to execute\n     * @param params The values to bind to the parameters (if the ECSQL has any).\n     * @param options Allow to specify certain flags which control how query is executed.\n     * @returns Returns the query result as an *AsyncIterableIterator<any>*  which lazy load result as needed. The row format is determined by *rowFormat* parameter.\n     * See [ECSQL row format]($docs/learning/ECSQLRowFormat) for details about the format of the returned rows.\n     * @throws [IModelError]($common) If there was any error while submitting, preparing or stepping into query\n     * @deprecated in 3.7. Use [[createQueryReader]] instead; it accepts the same parameters.\n     */\n    async *query(ecsql, params, options) {\n        const builder = new QueryOptionsBuilder(options);\n        const reader = this.createQueryReader(ecsql, params, builder.getOptions());\n        while (await reader.step())\n            yield reader.formatCurrentRow();\n    }\n    /** Compute number of rows that would be returned by the ECSQL.\n     *\n     * See also:\n     * - [ECSQL Overview]($docs/learning/frontend/ExecutingECSQL)\n     * - [Code Examples]($docs/learning/frontend/ECSQLCodeExamples)\n     *\n     * @param ecsql The ECSQL statement to execute\n     * @param params The values to bind to the parameters (if the ECSQL has any).\n     * See \"[iTwin.js Types used in ECSQL Parameter Bindings]($docs/learning/ECSQLParameterTypes)\" for details.\n     * @returns Return row count.\n     * @throws [IModelError]($common) If the statement is invalid\n     * @deprecated in 3.7. Count the number of results using `count(*)` where the original query is a subquery instead. E.g., `SELECT count(*) FROM (<query-whose-rows-to-count>)`.\n     */\n    async queryRowCount(ecsql, params) {\n        for await (const row of this.createQueryReader(`select count(*) from (${ecsql})`, params)) {\n            return row[0];\n        }\n        throw new IModelError(DbResult.BE_SQLITE_ERROR, \"Failed to get row count\");\n    }\n    /** Cancel any previous query with same token and run execute the current specified query.\n     * The result of the query is async iterator over the rows. The iterator will get next page automatically once rows in current page has been read.\n     * [ECSQL row]($docs/learning/ECSQLRowFormat).\n     *\n     * See also:\n     * - [ECSQL Overview]($docs/learning/frontend/ExecutingECSQL)\n     * - [Code Examples]($docs/learning/frontend/ECSQLCodeExamples)\n     *\n     * @param ecsql The ECSQL statement to execute\n     * @param token None empty restart token. The previous query with same token would be cancelled. This would cause\n     * exception which user code must handle.\n     * @param params The values to bind to the parameters (if the ECSQL has any).\n     * @param options Allow to specify certain flags which control how query is executed.\n     * @returns Returns the query result as an *AsyncIterableIterator<any>*  which lazy load result as needed. The row format is determined by *rowFormat* parameter.\n     * See [ECSQL row format]($docs/learning/ECSQLRowFormat) for details about the format of the returned rows.\n     * @throws [IModelError]($common) If there was any error while submitting, preparing or stepping into query\n     * @deprecated in 3.7. Use [[createQueryReader]] instead. Pass in the restart token as part of the `config` argument; e.g., `{ restartToken: myToken }` or `new QueryOptionsBuilder().setRestartToken(myToken).getOptions()`.\n     */\n    async *restartQuery(token, ecsql, params, options) {\n        for await (const row of this.createQueryReader(ecsql, params, new QueryOptionsBuilder(options).setRestartToken(token).getOptions())) {\n            yield row;\n        }\n    }\n    /** Query for a set of element ids that satisfy the supplied query params\n     * @param params The query parameters. The `limit` and `offset` members should be used to page results.\n     * @throws [IModelError]($common) If the generated statement is invalid or would return too many rows.\n     */\n    async queryEntityIds(params) {\n        return new Set(this.isOpen ? await IModelReadRpcInterface.getClientForRouting(this.routingContext.token).queryEntityIds(this.getRpcProps(), params) : undefined);\n    }\n    /** Request a snap from the backend.\n     * @note callers must gracefully handle Promise rejected with AbandonedError\n     * @internal\n     */\n    async requestSnap(props) {\n        return this.isOpen ? this._snapRpc.request(props) : { status: 2 };\n    }\n    /** Request a tooltip from the backend.\n     * @note If another call to this method occurs before preceding call(s) return, all preceding calls will be abandoned - only the most recent will resolve. Therefore callers must gracefully handle Promise rejected with AbandonedError.\n     */\n    async getToolTipMessage(id) {\n        return this.isOpen ? this._toolTipRpc.request(id) : [];\n    }\n    /** Request element clip containment status from the backend. */\n    async getGeometryContainment(requestProps) { return IModelReadRpcInterface.getClientForRouting(this.routingContext.token).getGeometryContainment(this.getRpcProps(), requestProps); }\n    /** Obtain a summary of the geometry belonging to one or more [GeometricElement]($backend)s suitable for debugging and diagnostics.\n     * @param requestProps Specifies the elements to query and options for how to format the output.\n     * @returns A string containing the summary, typically consisting of multiple lines.\n     * @note Trying to parse the output to programmatically inspect an element's geometry is not recommended.\n     * @see [GeometryStreamIterator]($common) to more directly inspect a geometry stream.\n     */\n    async getGeometrySummary(requestProps) {\n        return IModelReadRpcInterface.getClientForRouting(this.routingContext.token).getGeometrySummary(this.getRpcProps(), requestProps);\n    }\n    /** Request a named texture image from the backend.\n     * @param textureLoadProps The texture load properties which must contain a name property (a valid 64-bit integer identifier). It optionally can contain the maximum texture size supported by the client.\n     * @see [[Id64]]\n     * @public\n     */\n    async queryTextureData(textureLoadProps) {\n        if (this.isOpen) {\n            const rpcClient = IModelReadRpcInterface.getClientForRouting(this.routingContext.token);\n            const img = rpcClient.queryTextureData(this.getRpcProps(), textureLoadProps);\n            return img;\n        }\n        return undefined;\n    }\n    /** Request element mass properties from the backend.\n     * @note For better performance use [[getMassPropertiesPerCandidate]] when called from a loop with identical operations and a single candidate per iteration.\n     */\n    async getMassProperties(requestProps) {\n        return IModelReadRpcInterface.getClientForRouting(this.routingContext.token).getMassProperties(this.getRpcProps(), requestProps);\n    }\n    /** Request mass properties for multiple elements from the backend. */\n    async getMassPropertiesPerCandidate(requestProps) {\n        return IModelReadRpcInterface.getClientForRouting(this.routingContext.token).getMassPropertiesPerCandidate(this.getRpcProps(), requestProps);\n    }\n    /** Produce encoded [Polyface]($core-geometry)s from the geometry stream of a [GeometricElement]($backend).\n     * A polyface is produced for each geometric entry in the element's geometry stream, excluding geometry like open curves that can't be converted into polyfaces.\n     * The polyfaces can be decoded using [readElementMeshes]($common).\n     * Symbology, UV parameters, and normal vectors are not included in the result.\n     * @param requestProps A description of how to produce the polyfaces and from which element to obtain them.\n     * @returns an encoded list of polyfaces that can be decoded by [readElementMeshes]($common).\n     * @throws Error if [ElementMeshRequestProps.source]($common) does not refer to a [GeometricElement]($backend).\n     * @note This function is intended to support limited analysis of an element's geometry as a mesh. It is not intended for producing graphics.\n     * @see [[TileAdmin.requestElementGraphics]] to obtain meshes appropriate for display.\n     * @beta\n     */\n    async generateElementMeshes(requestProps) {\n        return IModelReadRpcInterface.getClientForRouting(this.routingContext.token).generateElementMeshes(this.getRpcProps(), requestProps);\n    }\n    /** Convert a point in this iModel's Spatial coordinates to a [[Cartographic]] using the Geographic location services for this IModelConnection.\n     * @param spatial A point in the iModel's spatial coordinates\n     * @param result If defined, use this for output\n     * @returns A Cartographic location (Horizontal datum depends on iModel's GCS)\n     * @throws IModelError if [[isGeoLocated]] is false or point could not be converted.\n     * @see [[cartographicFromSpatial]] if you have more than one point to convert, or you don't know whether the iModel has a GCS.\n     */\n    async spatialToCartographicFromGcs(spatial, result) {\n        if (!this.isGeoLocated && this.noGcsDefined)\n            throw new IModelError(GeoServiceStatus.NoGeoLocation, \"iModel is not GeoLocated\");\n        const geoConverter = this.geoServices.getConverter();\n        const coordResponse = await geoConverter.getGeoCoordinatesFromIModelCoordinates([spatial]);\n        if (1 !== coordResponse.geoCoords.length || GeoCoordStatus.NoGCSDefined === coordResponse.geoCoords[0].s)\n            throw new IModelError(GeoServiceStatus.NoGeoLocation, \"iModel is not GeoLocated\");\n        if (GeoCoordStatus.Success !== coordResponse.geoCoords[0].s) {\n            const geoServiceStatus = mapToGeoServiceStatus(coordResponse.geoCoords[0].s);\n            throw new IModelError(geoServiceStatus, \"Error converting spatial to cartographic\");\n        }\n        const longLatHeight = Point3d.fromJSON(coordResponse.geoCoords[0].p); // x is longitude in degrees, y is latitude in degrees, z is height in meters...\n        return Cartographic.fromDegrees({ longitude: longLatHeight.x, latitude: longLatHeight.y, height: longLatHeight.z }, result);\n    }\n    /** Convert a point in this iModel's Spatial coordinates to a [[Cartographic]] using the Geographic location services for this IModelConnection or [[IModel.ecefLocation]].\n     * @param spatial A point in the iModel's spatial coordinates\n     * @param result If defined, use this for output\n     * @returns A Cartographic location (Horizontal datum depends on iModel's GCS)\n     * @throws IModelError if [[isGeoLocated]] is false or point could not be converted.\n     * @see [[cartographicFromSpatial]] to convert multiple points at once.\n     * @see [[spatialToCartographicFromEcef]] to synchronously convert points using the iModel's ECEF transform.\n     */\n    async spatialToCartographic(spatial, result) {\n        return (this.noGcsDefined ? this.spatialToCartographicFromEcef(spatial, result) : this.spatialToCartographicFromGcs(spatial, result));\n    }\n    /** Convert points in this iModel's spatial coordinate system to [Cartographic]($common) coordinates using either a [[GeoConverter]] or the iModel's [EcefLocation]($common).\n     * @param spatial Coordinates to be converted from the iModel's spatial coordinate system\n     * @returns The `spatial` coordinates converted to cartographic coordinates, of the same length and order as the `spatial`.\n     * @throws IModelError if [[isGeoLocated]] is false or any point could not be converted.\n     * @see [[spatialFromCartographic]] to perform the inverse conversion.\n     * @see [[spatialToCartographicFromEcef]] to synchronously convert points using the iModel's ECEF transform.\n     */\n    async cartographicFromSpatial(spatial) {\n        return this.cartographicFromSpatialWithGcs(spatial);\n    }\n    /** Convert points in this iModel's spatial coordinate system to [Cartographic]($common) coordinates using either a [[GeoConverter]] or the iModel's [EcefLocation]($common).\n     * @param spatial Coordinates to be converted from the iModel's spatial coordinate system\n     * @returns The `spatial` coordinates converted to cartographic coordinates (WGS84 horizontal datum), of the same length and order as the `spatial`.\n     * @throws IModelError if [[isGeoLocated]] is false or any point could not be converted.\n     * @see [[cartographicFromSpatial]] to perform conversion using iModel's GCS horizontal datum\n     * @beta\n     */\n    async wgs84CartographicFromSpatial(spatial) {\n        return this.cartographicFromSpatialWithGcs(spatial, \"WGS84\");\n    }\n    /** @internal */\n    async cartographicFromSpatialWithGcs(spatial, datumOrGCRS) {\n        if (this.noGcsDefined)\n            return spatial.map((p) => this.spatialToCartographicFromEcef(p));\n        if (!this.isGeoLocated)\n            throw new IModelError(GeoServiceStatus.NoGeoLocation, \"iModel is not GeoLocated\");\n        if (!this.isOpen)\n            throw new IModelError(GeoServiceStatus.NoGeoLocation, \"iModel is not open\");\n        if (spatial.length === 0)\n            return [];\n        const geoConverter = this.geoServices.getConverter(datumOrGCRS);\n        assert(undefined !== geoConverter);\n        const coordResponse = await geoConverter.getGeoCoordinatesFromIModelCoordinates(spatial);\n        if (coordResponse.geoCoords.length !== spatial.length)\n            throw new IModelError(GeoServiceStatus.NoGeoLocation, \"iModel is not GeoLocated\");\n        return coordResponse.geoCoords.map((coord) => {\n            switch (coord.s) {\n                case GeoCoordStatus.NoGCSDefined:\n                    throw new IModelError(GeoServiceStatus.NoGeoLocation, \"iModel is not GeoLocated\");\n                case GeoCoordStatus.Success:\n                    const llh = Point3d.fromJSON(coord.p);\n                    return Cartographic.fromDegrees({ longitude: llh.x, latitude: llh.y, height: llh.z });\n                default:\n                    throw new IModelError(mapToGeoServiceStatus(coord.s), \"Error converting spatial to cartographic\");\n            }\n        });\n    }\n    /** Convert a [Cartographic]($common) to a point in this iModel's spatial coordinate system using a [[GeoConverter]].\n     * @param cartographic A cartographic location\n     * @param result If defined, use this for output\n     * @returns A point in this iModel's spatial coordinates\n     * @throws IModelError if [[isGeoLocated]] is false or cartographic location could not be converted.\n     * @see [[spatialFromCartographic]] to convert multiple points at once, or you don't know whether the iModel has a GCS.\n     */\n    async cartographicToSpatialFromGcs(cartographic, result) {\n        if (!this.isGeoLocated && this.noGcsDefined)\n            throw new IModelError(GeoServiceStatus.NoGeoLocation, \"iModel is not GeoLocated\");\n        const geoConverter = this.geoServices.getConverter();\n        const geoCoord = Point3d.create(cartographic.longitudeDegrees, cartographic.latitudeDegrees, cartographic.height); // x is longitude in degrees, y is latitude in degrees, z is height in meters...\n        const coordResponse = await geoConverter.getIModelCoordinatesFromGeoCoordinates([geoCoord]);\n        if (1 !== coordResponse.iModelCoords.length || GeoCoordStatus.NoGCSDefined === coordResponse.iModelCoords[0].s)\n            throw new IModelError(GeoServiceStatus.NoGeoLocation, \"iModel is not GeoLocated\");\n        if (GeoCoordStatus.Success !== coordResponse.iModelCoords[0].s) {\n            const geoServiceStatus = mapToGeoServiceStatus(coordResponse.iModelCoords[0].s);\n            throw new IModelError(geoServiceStatus, \"Error converting cartographic to spatial\");\n        }\n        result = result ? result : Point3d.createZero();\n        result.setFromJSON(coordResponse.iModelCoords[0].p);\n        return result;\n    }\n    /** Convert a [Cartographic]($common) to a point in this iModel's Spatial coordinates using a [[GeoConverter]] or[[IModel.ecefLocation]($common).\n     * @param cartographic A cartographic location\n     * @param result If defined, use this for output\n     * @returns A point in this iModel's spatial coordinates\n     * @throws IModelError if [[isGeoLocated]] is false or cartographic location could not be converted.\n     * @see [[spatialFromCartographic]] to convert multiple points at once.\n     * @see [[cartographicToSpatialFromEcef]] to synchronously convert points using the iModel's ECEF transform.\n     */\n    async cartographicToSpatial(cartographic, result) {\n        return (this.noGcsDefined ? this.cartographicToSpatialFromEcef(cartographic, result) : this.cartographicToSpatialFromGcs(cartographic, result));\n    }\n    /** Convert [Cartographic]($common) coordinates into points in this iModel's spatial coordinate system using a [[GeoConverter]] or the iModel's [EcefLocation]($common).\n     * @param cartographic Coordinates to be converted to the iModel's spatial coordinate system.\n     * @returns The `cartographic` coordinates converted to spatial coordinates, of the same length and order as `cartographic`.\n     * @throws IModelError if [[isGeoLocated]] is false or any point could not be converted.\n     * @see [[cartographicFromSpatial]] to perform the inverse conversion.\n     */\n    async spatialFromCartographic(cartographic) {\n        if (this.noGcsDefined)\n            return cartographic.map((p) => this.cartographicToSpatialFromEcef(p));\n        const geoCoords = cartographic.map((p) => Point3d.create(p.longitudeDegrees, p.latitudeDegrees, p.height));\n        return this.toSpatialFromGcs(geoCoords);\n    }\n    /** Convert geographic coordinates into points in this iModel's spatial coordinate system using a [[GeoConverter]] or the iModel's [EcefLocation]($common).\n     * @param geoCoords Coordinates to be converted are in the coordinate system described by the `datumOrGCRS` parameter.  Defaults iModel's spatial coordinate system otherwise.\n     * @param datumOrGCRS Datum name or Geographic CRS object definition to use for the conversion.\n     * @returns The `geographics` coordinates converted to spatial coordinates, of the same length and order as `geographics`.\n     * @throws IModelError if [[isGeoLocated]] is false or any point could not be converted.\n     * @beta\n     */\n    async toSpatialFromGcs(geoCoords, datumOrGCRS) {\n        if (!this.isGeoLocated)\n            throw new IModelError(GeoServiceStatus.NoGeoLocation, \"iModel is not GeoLocated\");\n        if (!this.isOpen)\n            throw new IModelError(GeoServiceStatus.NoGeoLocation, \"iModel is not open\");\n        if (geoCoords.length === 0)\n            return [];\n        const geoConverter = this.geoServices.getConverter(datumOrGCRS);\n        assert(undefined !== geoConverter);\n        const coordResponse = await geoConverter.getIModelCoordinatesFromGeoCoordinates(geoCoords);\n        if (coordResponse.iModelCoords.length !== geoCoords.length)\n            throw new IModelError(GeoServiceStatus.NoGeoLocation, \"iModel is not GeoLocated\");\n        return coordResponse.iModelCoords.map((coord) => {\n            switch (coord.s) {\n                case GeoCoordStatus.NoGCSDefined:\n                    throw new IModelError(GeoServiceStatus.NoGeoLocation, \"iModel is not GeoLocated\");\n                case GeoCoordStatus.Success:\n                    return Point3d.fromJSON(coord.p);\n                default:\n                    throw new IModelError(mapToGeoServiceStatus(coord.s), \"Error converting cartographic to spatial\");\n            }\n        });\n    }\n    /** Expand this iModel's [[displayedExtents]] to include the specified range.\n     * This is done automatically when reality models are added to a spatial view. In some cases a [[TiledGraphicsProvider]] may wish to expand\n     * the extents explicitly to include its geometry.\n     * @deprecated in 3.6. See [[displayedExtents]].\n     */\n    expandDisplayedExtents(range) {\n        this._extentsExpansion.extendRange(range);\n        /* eslint-disable-next-line deprecation/deprecation */\n        this.displayedExtents.setFrom(this.projectExtents);\n        /* eslint-disable-next-line deprecation/deprecation */\n        this.displayedExtents.extendRange(this._extentsExpansion);\n    }\n    /** @internal */\n    getMapEcefToDb(bimElevationBias) {\n        if (!this.ecefLocation)\n            return Transform.createIdentity();\n        const mapEcefToDb = this.ecefLocation.getTransform().inverse();\n        if (!mapEcefToDb) {\n            assert(false);\n            return Transform.createIdentity();\n        }\n        mapEcefToDb.origin.z += bimElevationBias;\n        return mapEcefToDb;\n    }\n    /** The offset between sea level and the geodetic ellipsoid. This will return undefined only if the request for the offset to Bing Elevation\n     * is required, and in this case the [[onMapElevationLoaded]] event is raised when the request is completed.\n     * @internal\n     */\n    get geodeticToSeaLevel() {\n        if (undefined === this._geodeticToSeaLevel) {\n            const elevationProvider = new BingElevationProvider();\n            this._geodeticToSeaLevel = elevationProvider.getGeodeticToSeaLevelOffset(this.projectExtents.center, this);\n            this._geodeticToSeaLevel.then((geodeticToSeaLevel) => {\n                this._geodeticToSeaLevel = geodeticToSeaLevel;\n                this.onMapElevationLoaded.raiseEvent(this);\n            }).catch((_error) => this._geodeticToSeaLevel = 0.0);\n        }\n        return (\"number\" === typeof this._geodeticToSeaLevel) ? this._geodeticToSeaLevel : undefined;\n    }\n    /** The altitude (geodetic) at the project center. This will return undefined only if the request for the offset to Bing Elevation\n     * is required, and in this case the [[onMapElevationLoaded]] event is raised when the request is completed.\n     * @internal\n     */\n    get projectCenterAltitude() {\n        if (undefined === this._projectCenterAltitude) {\n            const elevationProvider = new BingElevationProvider();\n            this._projectCenterAltitude = elevationProvider.getHeightValue(this.projectExtents.center, this);\n            this._projectCenterAltitude.then((projectCenterAltitude) => {\n                this._projectCenterAltitude = projectCenterAltitude;\n                this.onMapElevationLoaded.raiseEvent(this);\n            }).catch((_error) => this._projectCenterAltitude = 0.0);\n        }\n        return (\"number\" === typeof this._projectCenterAltitude) ? this._projectCenterAltitude : undefined;\n    }\n}\n/** The maximum time (in milliseconds) to wait before timing out the request to open a connection to a new iModel */\nIModelConnection.connectionTimeout = 10 * 60 * 1000;\n/** Event called immediately before *any* IModelConnection is closed.\n * @note This static event is called when *any* IModelConnection is closed, and the specific IModelConnection is passed as its argument. To\n * monitor closing a specific IModelConnection, use the `onClose` instance event.\n * @note Be careful not to perform any asynchronous operations on the IModelConnection because it will close before they are processed.\n */\nIModelConnection.onClose = new BeEvent();\n/** Event called immediately after *any* IModelConnection is opened. */\nIModelConnection.onOpen = new BeEvent();\nexport { IModelConnection };\n/** A connection that exists without an iModel. Useful for connecting to Reality Data services.\n * @note This class exists because our display system requires an IModelConnection type even if only reality data is drawn.\n * @public\n */\nexport class BlankConnection extends IModelConnection {\n    isBlankConnection() { return true; }\n    /** The Guid that identifies the iTwin for this BlankConnection.\n     * @note This can also be set via the [[create]] method using [[BlankConnectionProps.iTwinId]].\n     */\n    get iTwinId() { return this._iTwinId; }\n    set iTwinId(iTwinId) { this._iTwinId = iTwinId; }\n    /** A BlankConnection does not have an associated iModel, so its `iModelId` is alway `undefined`. */\n    get iModelId() { return undefined; } // GuidString | undefined for the superclass, but always undefined for BlankConnection\n    /** A BlankConnection is always considered closed because it does not have a specific backend nor associated iModel.\n     * @returns `true` is always returned since RPC operations and iModel queries are not valid.\n     * @note Even though true is always returned, it is still valid to call [[close]] to dispose frontend resources.\n     */\n    get isClosed() { return true; }\n    /** Create a new [Blank IModelConnection]($docs/learning/frontend/BlankConnection).\n     * @param props The properties to use for the new BlankConnection.\n     */\n    static create(props) {\n        return new this({\n            rootSubject: { name: props.name },\n            projectExtents: props.extents,\n            globalOrigin: props.globalOrigin,\n            ecefLocation: props.location instanceof Cartographic ? EcefLocation.createFromCartographicOrigin(props.location) : props.location,\n            key: \"\",\n            iTwinId: props.iTwinId,\n        });\n    }\n    /** There are no connections to the backend to close in the case of a BlankConnection.\n     * However, there are frontend resources (like the tile cache) that can be disposed.\n     * @note A BlankConnection should not be used after calling `close`.\n     */\n    async close() {\n        this.beforeClose();\n    }\n    /** @internal */\n    closeSync() {\n        this.beforeClose();\n    }\n}\n/** A connection to a [SnapshotDb]($backend) hosted on a backend.\n * @public\n */\nexport class SnapshotConnection extends IModelConnection {\n    /** Type guard for instanceof [[SnapshotConnection]] */\n    isSnapshotConnection() { return true; }\n    /** The Guid that identifies this iModel. */\n    get iModelId() { return super.iModelId; } // GuidString | undefined for the superclass, but required for SnapshotConnection\n    /** Returns `true` if [[close]] has already been called. */\n    get isClosed() { return this._isClosed ? true : false; }\n    /** Returns `true` if this is a connection to a remote snapshot iModel resolved by the backend.\n     * @see [[openRemote]]\n     */\n    get isRemote() { return this._isRemote ? true : false; }\n    /** Open an IModelConnection to a read-only snapshot iModel from a file name.\n     * @note This method is intended for desktop or mobile applications and should not be used for web applications.\n     */\n    static async openFile(filePath) {\n        const routingContext = IModelRoutingContext.current || IModelRoutingContext.default;\n        RpcManager.setIModel({ iModelId: \"undefined\", key: filePath });\n        const openResponse = await SnapshotIModelRpcInterface.getClientForRouting(routingContext.token).openFile(filePath);\n        Logger.logTrace(loggerCategory, \"SnapshotConnection.openFile\", () => ({ filePath }));\n        const connection = new SnapshotConnection(openResponse);\n        connection.routingContext = routingContext;\n        IModelConnection.onOpen.raiseEvent(connection);\n        return connection;\n    }\n    /** Open an IModelConnection to a remote read-only snapshot iModel from a key that will be resolved by the backend.\n     * @note This method is intended for web applications.\n     */\n    static async openRemote(fileKey) {\n        const routingContext = IModelRoutingContext.current || IModelRoutingContext.default;\n        RpcManager.setIModel({ iModelId: \"undefined\", key: fileKey });\n        const openResponse = await SnapshotIModelRpcInterface.getClientForRouting(routingContext.token).openRemote(fileKey);\n        Logger.logTrace(loggerCategory, \"SnapshotConnection.openRemote\", () => ({ fileKey }));\n        const connection = new SnapshotConnection(openResponse);\n        connection.routingContext = routingContext;\n        connection._isRemote = true;\n        IModelConnection.onOpen.raiseEvent(connection);\n        return connection;\n    }\n    /** Close this SnapshotConnection.\n     * @note For local snapshot files, `close` closes the connection and the underlying [SnapshotDb]($backend) database file.\n     * For remote snapshots, `close` only closes the connection and frees any frontend resources allocated to the connection.\n     * @see [[openFile]], [[openRemote]]\n     */\n    async close() {\n        if (this.isClosed)\n            return;\n        this.beforeClose();\n        try {\n            if (!this.isRemote) {\n                await SnapshotIModelRpcInterface.getClientForRouting(this.routingContext.token).close(this.getRpcProps());\n            }\n        }\n        finally {\n            this._isClosed = true;\n        }\n    }\n}\n/** @public */\n(function (IModelConnection) {\n    /** The collection of loaded ModelState objects for an [[IModelConnection]]. */\n    class Models {\n        /** @internal */\n        get loaded() { return this._loaded; }\n        /** An iterator over all currently-loaded models. */\n        [Symbol.iterator]() {\n            return this._loaded.values()[Symbol.iterator]();\n        }\n        /** @internal */\n        constructor(_iModel) {\n            this._iModel = _iModel;\n            this._loaded = new Map();\n        }\n        /** The Id of the [RepositoryModel]($backend). */\n        get repositoryModelId() { return \"0x1\"; }\n        /** @internal */\n        async getDictionaryModel() {\n            const res = await this._iModel.models.queryProps({ from: \"bis.DictionaryModel\", wantPrivate: true });\n            if (res.length !== 1 || res[0].id === undefined)\n                throw new IModelError(IModelStatus.BadModel, \"bis.DictionaryModel\");\n            return res[0].id;\n        }\n        /** Get a batch of [[ModelProps]] given a list of Model ids. */\n        async getProps(modelIds) {\n            const iModel = this._iModel;\n            return iModel.isOpen ? IModelReadRpcInterface.getClientForRouting(iModel.routingContext.token).getModelProps(iModel.getRpcProps(), [...Id64.toIdSet(modelIds)]) : [];\n        }\n        /** Find a ModelState in the set of loaded Models by ModelId. */\n        getLoaded(id) {\n            return this._loaded.get(id);\n        }\n        /** Given a set of modelIds, return the subset of corresponding models that are not currently loaded.\n         * @param modelIds The set of model Ids\n         * @returns The subset of the supplied Ids corresponding to models that are not currently loaded, or undefined if all of the specified models are loaded.\n         */\n        filterLoaded(modelIds) {\n            let unloaded;\n            for (const id of Id64.iterable(modelIds)) {\n                if (undefined === this.getLoaded(id)) {\n                    if (undefined === unloaded)\n                        unloaded = new Set();\n                    unloaded.add(id);\n                }\n            }\n            return unloaded;\n        }\n        /** load a set of Models by Ids. After the returned Promise resolves, you may get the ModelState objects by calling getLoadedModel. */\n        async load(modelIds) {\n            const notLoaded = this.filterLoaded(modelIds);\n            if (undefined === notLoaded)\n                return; // all requested models are already loaded\n            try {\n                const propArray = await this.getProps(notLoaded);\n                await this.updateLoadedWithModelProps(propArray);\n            }\n            catch (err) {\n                // ignore error, we had nothing to do.\n            }\n        }\n        /** Given an array of modelProps, find the class for each model and construct it. save it in the iModelConnection's loaded set. */\n        async updateLoadedWithModelProps(modelProps) {\n            try {\n                for (const props of modelProps) {\n                    const ctor = await this._iModel.findClassFor(props.classFullName, ModelState);\n                    if (undefined === this.getLoaded(props.id)) { // do not overwrite if someone else loads it while we await\n                        const modelState = new ctor(props, this._iModel); // create a new instance of the appropriate ModelState subclass\n                        this._loaded.set(modelState.id, modelState); // save it in loaded set\n                    }\n                }\n            }\n            catch (err) {\n                // ignore error, we had nothing to do.\n            }\n        }\n        /** Remove a model from the set of loaded models. Used internally by BriefcaseConnection in response to txn events.\n         * @internal\n         */\n        unload(modelId) {\n            this._loaded.delete(modelId);\n        }\n        /** Query for a set of model ranges by ModelIds.\n         * @param modelIds the Id or Ids of the [GeometricModel]($backend)s for which to query the ranges.\n         * @returns An array containing the range of each model of each unique model Id, omitting the range for any Id which did no identify a GeometricModel.\n         * @note The contents of the returned array do not follow a deterministic order.\n         * @throws [IModelError]($common) if exactly one model Id is specified and that Id does not identify a GeometricModel.\n         * @see [[queryExtents]] for a similar function that does not throw and produces a deterministically-ordered result.\n         */\n        async queryModelRanges(modelIds) {\n            const iModel = this._iModel;\n            return iModel.isOpen ? IModelReadRpcInterface.getClientForRouting(iModel.routingContext.token).queryModelRanges(iModel.getRpcProps(), [...Id64.toIdSet(modelIds)]) : [];\n        }\n        /** For each [GeometricModel]($backend) specified by Id, attempts to obtain the union of the volumes of all geometric elements within that model.\n         * @param modelIds The Id or Ids of the geometric models for which to obtain the extents.\n         * @returns An array of results, one per supplied Id, in the order in which the Ids were supplied. If the extents could not be obtained, the\n         * corresponding results entry's `extents` will be a \"null\" range (@see [Range3d.isNull]($geometry) and its `status` will indicate\n         * why the extents could not be obtained (e.g., because the Id did not identify a [GeometricModel]($backend)).\n         */\n        async queryExtents(modelIds) {\n            const iModel = this._iModel;\n            if (!iModel.isOpen)\n                return [];\n            if (typeof modelIds === \"string\")\n                modelIds = [modelIds];\n            return IModelReadRpcInterface.getClientForRouting(iModel.routingContext.token).queryModelExtents(iModel.getRpcProps(), modelIds);\n        }\n        /** Query for a set of ModelProps of the specified ModelQueryParams.\n         * @param queryParams The query parameters. The `limit` and `offset` members should be used to page results.\n         * @throws [IModelError]($common) If the generated statement is invalid or would return too many props.\n         */\n        async queryProps(queryParams) {\n            const iModel = this._iModel;\n            if (!iModel.isOpen)\n                return [];\n            const params = { ...queryParams }; // make a copy\n            params.from = queryParams.from || ModelState.classFullName; // use \"BisCore:Model\" as default class name\n            params.where = queryParams.where || \"\";\n            if (!queryParams.wantPrivate) {\n                if (params.where.length > 0)\n                    params.where += \" AND \";\n                params.where += \"IsPrivate=FALSE \";\n            }\n            if (!queryParams.wantTemplate) {\n                if (params.where.length > 0)\n                    params.where += \" AND \";\n                params.where += \"IsTemplate=FALSE \";\n            }\n            return IModelReadRpcInterface.getClientForRouting(iModel.routingContext.token).queryModelProps(iModel.getRpcProps(), params);\n        }\n        /** Asynchronously stream ModelProps using the specified ModelQueryParams. */\n        async *query(queryParams) {\n            // NOTE: this implementation has the desired API signature, but its implementation must be improved to actually page results\n            const modelPropsArray = await this.queryProps(queryParams);\n            for (const modelProps of modelPropsArray) {\n                yield modelProps;\n            }\n        }\n    }\n    IModelConnection.Models = Models;\n    /** The collection of Elements for an [[IModelConnection]]. */\n    class Elements {\n        /** @internal */\n        constructor(_iModel) {\n            this._iModel = _iModel;\n        }\n        /** The Id of the [root subject element]($docs/bis/guide/references/glossary.md#subject-root) for this iModel. */\n        get rootSubjectId() { return \"0x1\"; }\n        /** Get a set of element ids that satisfy a query */\n        async queryIds(params) { return this._iModel.queryEntityIds(params); }\n        /** Get an array of [[ElementProps]] given one or more element ids.\n         * @note This method returns **all** of the properties of the element (excluding GeometryStream), which may be a very large amount of data - consider using\n         * [[IModelConnection.query]] to select only those properties of interest to limit the amount of data returned.\n         */\n        async getProps(arg) {\n            const iModel = this._iModel;\n            return iModel.isOpen ? IModelReadRpcInterface.getClientForRouting(iModel.routingContext.token).getElementProps(this._iModel.getRpcProps(), [...Id64.toIdSet(arg)]) : [];\n        }\n        /** Obtain the properties of a single element, optionally specifying specific properties to include or exclude.\n         * For example, [[getProps]] and [[queryProps]] omit the [GeometryStreamProps]($common) property of [GeometricElementProps]($common) and [GeometryPartProps]($common)\n         * because it can be quite large and is generally not useful to frontend code. The following code requests that the geometry stream be included:\n         * ```ts\n         *  const props = await iModel.elements.loadProps(elementId, { wantGeometry: true });\n         * ```\n         * @param identifier Identifies the element by its Id, federation Guid, or [Code]($common).\n         * @param options Optionally includes or excludes specific properties.\n         * @returns The properties of the requested element; or `undefined` if no element exists with the specified identifier or the iModel is not open.\n         * @throws [IModelError]($common) if the element exists but could not be loaded.\n         */\n        async loadProps(identifier, options) {\n            const imodel = this._iModel;\n            return imodel.isOpen ? IModelReadRpcInterface.getClientForRouting(imodel.routingContext.token).loadElementProps(imodel.getRpcProps(), identifier, options) : undefined;\n        }\n        /** Get an array  of [[ElementProps]] that satisfy a query\n         * @param params The query parameters. The `limit` and `offset` members should be used to page results.\n         * @throws [IModelError]($common) If the generated statement is invalid or would return too many props.\n         */\n        async queryProps(params) {\n            const iModel = this._iModel;\n            return iModel.isOpen ? IModelReadRpcInterface.getClientForRouting(iModel.routingContext.token).queryElementProps(iModel.getRpcProps(), params) : [];\n        }\n        /** Obtain the [Placement]($common)s of a set of [GeometricElement]($backend)s.\n         * @param elementIds The Ids of the elements whose placements are to be queried.\n         * @param options Options customizing how the placements are queried.\n         * @returns an array of placements, each having an additional `elementId` property identifying the element from which the placement was obtained.\n         * @note Any Id that does not identify a geometric element with a valid bounding box and origin is omitted from the returned array.\n         */\n        async getPlacements(elementIds, options) {\n            let ids;\n            if (typeof elementIds === \"string\")\n                ids = [elementIds];\n            else if (!Array.isArray(elementIds))\n                ids = Array.from(elementIds);\n            else\n                ids = elementIds;\n            if (ids.length === 0)\n                return [];\n            const select3d = `\r\n        SELECT\r\n          ECInstanceId,\r\n          Origin.x as x, Origin.y as y, Origin.z as z,\r\n          BBoxLow.x as lx, BBoxLow.y as ly, BBoxLow.z as lz,\r\n          BBoxHigh.x as hx, BBoxHigh.y as hy, BBoxHigh.z as hz,\r\n          Yaw, Pitch, Roll,\r\n          NULL as Rotation\r\n        FROM bis.GeometricElement3d\r\n        WHERE Origin IS NOT NULL AND BBoxLow IS NOT NULL AND BBoxHigh IS NOT NULL`;\n            // Note: For the UNION ALL statement, the column aliases in select2d are ignored - so they\n            // must match those in select3d.\n            const select2d = `\r\n        SELECT\r\n          ECInstanceId,\r\n          Origin.x as x, Origin.y as y, NULL as z,\r\n          BBoxLow.x as lx, BBoxLow.y as ly, NULL as lz,\r\n          BBoxHigh.x as hx, BBoxHigh.y as hy, NULL as hz,\r\n          NULL as yaw, NULL as pitch, NULL as roll,\r\n          Rotation\r\n        FROM bis.GeometricElement2d\r\n        WHERE Origin IS NOT NULL AND BBoxLow IS NOT NULL AND BBoxHigh IS NOT NULL`;\n            const idCriterion = `ECInstanceId IN (${ids.join(\",\")})`;\n            let ecsql;\n            switch (options?.type) {\n                case \"3d\":\n                    ecsql = `${select3d} AND ${idCriterion}`;\n                    break;\n                case \"2d\":\n                    ecsql = `${select2d} AND ${idCriterion}`;\n                    break;\n                default:\n                    ecsql = `\r\n            SELECT * FROM (\r\n              ${select3d}\r\n              UNION ALL\r\n              ${select2d}\r\n            ) WHERE ${idCriterion}`;\n                    break;\n            }\n            const placements = new Array();\n            for await (const queryRow of this._iModel.createQueryReader(ecsql, undefined, { rowFormat: QueryRowFormat.UseJsPropertyNames })) {\n                const row = queryRow.toRow();\n                const origin = [row.x, row.y, row.z];\n                const bbox = {\n                    low: { x: row.lx, y: row.ly, z: row.lz },\n                    high: { x: row.hx, y: row.hy, z: row.hz },\n                };\n                let placement;\n                if (undefined === row.lz)\n                    placement = Placement2d.fromJSON({ bbox, origin, angle: row.rotation });\n                else\n                    placement = Placement3d.fromJSON({ bbox, origin, angles: { yaw: row.yaw, pitch: row.pitch, roll: row.roll } });\n                const placementWithId = placement;\n                placementWithId.elementId = row.id;\n                placements.push(placementWithId);\n            }\n            return placements;\n        }\n    }\n    IModelConnection.Elements = Elements;\n    /** The collection of [[CodeSpec]] entities for an [[IModelConnection]]. */\n    class CodeSpecs {\n        /** @internal */\n        constructor(_iModel) {\n            this._iModel = _iModel;\n        }\n        /** Loads all CodeSpec from the remote IModelDb. */\n        async _loadAllCodeSpecs() {\n            if (this._loaded)\n                return;\n            this._loaded = [];\n            const codeSpecArray = await IModelReadRpcInterface.getClientForRouting(this._iModel.routingContext.token).getAllCodeSpecs(this._iModel.getRpcProps());\n            for (const codeSpec of codeSpecArray) {\n                this._loaded.push(CodeSpec.createFromJson(this._iModel, Id64.fromString(codeSpec.id), codeSpec.name, codeSpec.jsonProperties));\n            }\n        }\n        /** Look up a CodeSpec by Id.\n         * @param codeSpecId The Id of the CodeSpec to load\n         * @returns The CodeSpec with the specified Id\n         * @throws [[IModelError]] if the Id is invalid or if no CodeSpec with that Id could be found.\n         */\n        async getById(codeSpecId) {\n            if (!Id64.isValid(codeSpecId))\n                throw new IModelError(IModelStatus.InvalidId, \"Invalid codeSpecId\", () => ({ codeSpecId }));\n            await this._loadAllCodeSpecs(); // ensure all codeSpecs have been downloaded\n            const found = this._loaded.find((codeSpec) => codeSpec.id === codeSpecId);\n            if (!found)\n                throw new IModelError(IModelStatus.NotFound, \"CodeSpec not found\");\n            return found;\n        }\n        /** Look up a CodeSpec by name.\n         * @param name The name of the CodeSpec to load\n         * @returns The CodeSpec with the specified name\n         * @throws [[IModelError]] if no CodeSpec with the specified name could be found.\n         */\n        async getByName(name) {\n            await this._loadAllCodeSpecs(); // ensure all codeSpecs have been downloaded\n            const found = this._loaded.find((codeSpec) => codeSpec.name === name);\n            if (!found)\n                throw new IModelError(IModelStatus.NotFound, \"CodeSpec not found\");\n            return found;\n        }\n    }\n    IModelConnection.CodeSpecs = CodeSpecs;\n    /** The collection of views for an [[IModelConnection]]. */\n    class Views {\n        /** @internal */\n        constructor(_iModel) {\n            this._iModel = _iModel;\n        }\n        get viewStoreWriter() {\n            return this._writeViewStoreProxy ??= new Proxy(this, {\n                get(views, methodName) {\n                    const iModel = views._iModel;\n                    return async (...args) => IModelReadRpcInterface.getClientForRouting(iModel.routingContext.token).callViewStore(iModel.getRpcProps(), ViewStoreRpc.version, true, methodName, ...args);\n                },\n            });\n        }\n        get viewsStoreReader() {\n            return this._readViewStoreProxy ??= new Proxy(this, {\n                get(views, methodName) {\n                    const iModel = views._iModel;\n                    return async (...args) => IModelReadRpcInterface.getClientForRouting(iModel.routingContext.token).callViewStore(iModel.getRpcProps(), ViewStoreRpc.version, false, methodName, ...args);\n                },\n            });\n        }\n        /** Query for an array of ViewDefinitionProps\n         * @param queryParams Query parameters specifying the views to return. The `limit` and `offset` members should be used to page results.\n         * @throws [IModelError]($common) If the generated statement is invalid or would return too many props.\n         */\n        async queryProps(queryParams) {\n            const iModel = this._iModel;\n            if (iModel.isClosed)\n                return [];\n            const params = { ...queryParams }; // make a copy\n            params.from = queryParams.from || ViewState.classFullName; // use \"BisCore:ViewDefinition\" as default class name\n            params.where = queryParams.where || \"\";\n            if (queryParams.wantPrivate === undefined || !queryParams.wantPrivate) {\n                if (params.where.length > 0)\n                    params.where += \" AND \";\n                params.where += \"IsPrivate=FALSE \";\n            }\n            const viewProps = await IModelReadRpcInterface.getClientForRouting(iModel.routingContext.token).queryElementProps(iModel.getRpcProps(), params);\n            assert((viewProps.length === 0) || (\"categorySelectorId\" in viewProps[0]), \"invalid view definition\"); // spot check that the first returned element is-a ViewDefinitionProps\n            return viewProps;\n        }\n        /** Get an array of the ViewSpecs for all views in this IModel that satisfy a ViewQueryParams.\n         *\n         * This is typically used to create a list for UI.\n         *\n         * For example:\n         * ```ts\n         * [[include:IModelConnection.Views.getSpatialViewList]]\n         * ```\n         * @param queryParams The parameters for the views to find. The `limit` and `offset` members should be used to page results.\n         * @throws [IModelError]($common) If the generated statement is invalid or would return too many props.\n         */\n        async getViewList(queryParams) {\n            const views = [];\n            const viewProps = await this.queryProps(queryParams);\n            viewProps.forEach((viewProp) => {\n                views.push({ id: viewProp.id, name: viewProp.code.value, class: viewProp.classFullName });\n            });\n            return views;\n        }\n        /** Query the Id of the default view associated with this iModel. Applications can choose to use this as the default view to which to open a viewport upon startup, or the initial selection\n         * within a view selection dialog, or similar purposes.\n         * @returns the Id of the default view, or an invalid ID if no default view is defined.\n         */\n        async queryDefaultViewId() {\n            const iModel = this._iModel;\n            return iModel.isOpen ? IModelReadRpcInterface.getClientForRouting(iModel.routingContext.token).getDefaultViewId(iModel.getRpcProps()) : Id64.invalid;\n        }\n        /** Load a [[ViewState]] object from the specified [[ViewDefinition]] id. */\n        async load(viewDefinitionId) {\n            const options = {\n                displayStyle: {\n                    omitScheduleScriptElementIds: !IModelApp.tileAdmin.enableFrontendScheduleScripts,\n                    compressExcludedElementIds: true,\n                },\n            };\n            const viewProps = await IModelReadRpcInterface.getClientForRouting(this._iModel.routingContext.token).getViewStateData(this._iModel.getRpcProps(), viewDefinitionId, options);\n            const viewState = await this.convertViewStatePropsToViewState(viewProps);\n            return viewState;\n        }\n        /** Return the [[ViewState]] object associated with the [[ViewStateProps]] passed in. */\n        async convertViewStatePropsToViewState(viewProps) {\n            const className = viewProps.viewDefinitionProps.classFullName;\n            const ctor = await this._iModel.findClassFor(className, undefined);\n            if (undefined === ctor)\n                throw new IModelError(IModelStatus.WrongClass, \"Invalid ViewState class\", () => viewProps);\n            const viewState = ctor.createFromProps(viewProps, this._iModel);\n            await viewState.load(); // loads models for ModelSelector\n            return viewState;\n        }\n        /** Get a thumbnail for a view.\n         * @param viewId The id of the view of the thumbnail.\n         * @returns A Promise of the ThumbnailProps.\n         * @throws \"No content\" error if invalid thumbnail.\n         * @deprecated in 3.x use ViewStore apis\n         */\n        async getThumbnail(_viewId) {\n            // eslint-disable-next-line deprecation/deprecation\n            const val = await IModelReadRpcInterface.getClientForRouting(this._iModel.routingContext.token).getViewThumbnail(this._iModel.getRpcProps(), _viewId.toString());\n            const intValues = new Uint32Array(val.buffer, 0, 4);\n            if (intValues[1] !== ImageSourceFormat.Jpeg && intValues[1] !== ImageSourceFormat.Png)\n                throw new NoContentError();\n            return { format: intValues[1] === ImageSourceFormat.Jpeg ? \"jpeg\" : \"png\", width: intValues[2], height: intValues[3], image: new Uint8Array(val.buffer, 16, intValues[0]) };\n        }\n    }\n    IModelConnection.Views = Views;\n    /** Provides access to information about the [Category]($backend)'s stored in an [[IModelConnection]].\n     * This information is cached internally so that repeated requests need not query the backend.\n     * @see [[IModelConnection.categories]] for the categories associated with a specific iModel.\n     */\n    class Categories {\n        /** @internal */\n        constructor(iModel) {\n            this.cache = new SubCategoriesCache(iModel);\n        }\n        /** Obtain information about one or more [Category]($backend)'s. */\n        async getCategoryInfo(categoryIds) {\n            return this.cache.getCategoryInfo(categoryIds);\n        }\n        /** Obtain information about one or more [SubCategory]($backend)'s belonging to the specified [Category]($backend). */\n        async getSubCategoryInfo(args) {\n            return this.cache.getSubCategoryInfo(args.category, args.subCategories);\n        }\n    }\n    IModelConnection.Categories = Categories;\n})(IModelConnection || (IModelConnection = {}));\n//# sourceMappingURL=IModelConnection.js.map",
      "start": 1693508118998,
      "end": 1693508119216,
      "sourcemaps": null
    }
  ]
}
