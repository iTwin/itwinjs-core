{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/ModelState.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module ModelState\n */\nimport { Id64, JsonUtils } from \"@itwin/core-bentley\";\nimport { RealityDataFormat, RealityModelDisplaySettings, RelatedElement, SpatialClassifiers, } from \"@itwin/core-common\";\nimport { Point2d, Range3d } from \"@itwin/core-geometry\";\nimport { EntityState } from \"./EntityState\";\nimport { RealityDataSource } from \"./RealityDataSource\";\nimport { createOrbitGtTileTreeReference, createPrimaryTileTreeReference, createRealityTileTreeReference } from \"./tile/internal\";\n/** Represents the front-end state of a [Model]($backend).\n * @public\n * @extensions\n */\nexport class ModelState extends EntityState {\n    static get className() { return \"Model\"; }\n    constructor(props, iModel, state) {\n        super(props, iModel, state);\n        this.modeledElement = RelatedElement.fromJSON(props.modeledElement);\n        this.name = props.name ? props.name : \"\";\n        this.parentModel = Id64.fromJSON(props.parentModel); // NB! Must always match the model of the modeledElement!\n        this.isPrivate = JsonUtils.asBool(props.isPrivate);\n        this.isTemplate = JsonUtils.asBool(props.isTemplate);\n    }\n    /** Add all custom-handled properties of a Model to a json object. */\n    toJSON() {\n        const val = super.toJSON();\n        val.modeledElement = this.modeledElement;\n        val.parentModel = this.parentModel;\n        val.name = this.name;\n        if (this.isPrivate)\n            val.isPrivate = this.isPrivate;\n        if (this.isTemplate)\n            val.isTemplate = this.isTemplate;\n        return val;\n    }\n    /** Determine whether this is a GeometricModel */\n    get isGeometricModel() { return false; }\n    /** Attempts to cast this model to a geometric model. */\n    get asGeometricModel() { return undefined; }\n    /** Attempts to cast this model to a 3d geometric model. */\n    get asGeometricModel3d() { return undefined; }\n    /** Attempts to cast this model to a 2d geometric model. */\n    get asGeometricModel2d() { return undefined; }\n    /** Attempts to cast this model to a spatial model. */\n    get asSpatialModel() { return undefined; }\n    /**\n     * Return the tool tip for this model. This is called only if the hit does not return a tooltip.\n     * @internal\n     */\n    getToolTip(_hit) { return undefined; }\n}\n/** Represents the front-end state of a [GeometricModel]($backend).\n * The contents of a GeometricModelState can be rendered inside a [[Viewport]].\n * @public\n * @extensions\n */\nexport class GeometricModelState extends ModelState {\n    static get className() { return \"GeometricModel\"; }\n    constructor(props, iModel, state) {\n        super(props, iModel, state);\n        this.geometryGuid = props.geometryGuid;\n    }\n    /** @internal */\n    get asGeometricModel() { return this; }\n    /** Returns true if this is a 2d model (a [[GeometricModel2dState]]). */\n    get is2d() { return !this.is3d; }\n    /** @internal */\n    get isGeometricModel() { return true; }\n    /** @internal */\n    get treeModelId() { return this.id; }\n    /** Query for the union of the ranges of all the elements in this GeometricModel.\n     * @note This value is cached after the first time it is called.\n     * @public\n     */\n    async queryModelRange() {\n        if (undefined === this._modelRange) {\n            const ranges = await this.iModel.models.queryExtents(this.id);\n            this._modelRange = Range3d.fromJSON(ranges[0]?.extents);\n        }\n        return this._modelRange;\n    }\n    /** @internal */\n    createTileTreeReference(view) {\n        // If this is a reality model, its tile tree is obtained from reality data service URL.\n        const spatialModel = this.asSpatialModel;\n        const rdSourceKey = this.jsonProperties.rdSourceKey;\n        const getDisplaySettings = () => view.displayStyle.settings.getRealityModelDisplaySettings(this.id) ?? RealityModelDisplaySettings.defaults;\n        if (rdSourceKey) {\n            const useOrbitGtTileTreeReference = rdSourceKey.format === RealityDataFormat.OPC;\n            const treeRef = (!useOrbitGtTileTreeReference) ?\n                createRealityTileTreeReference({\n                    rdSourceKey,\n                    iModel: this.iModel,\n                    source: view,\n                    modelId: this.id,\n                    // url: tilesetUrl, // If rdSourceKey is defined, url is not used\n                    classifiers: undefined !== spatialModel ? spatialModel.classifiers : undefined,\n                    getDisplaySettings,\n                }) :\n                createOrbitGtTileTreeReference({\n                    rdSourceKey,\n                    iModel: this.iModel,\n                    source: view,\n                    modelId: this.id,\n                    // orbitGtBlob: props.orbitGtBlob!, // If rdSourceKey is defined, orbitGtBlob is not used\n                    classifiers: undefined !== spatialModel ? spatialModel.classifiers : undefined,\n                    getDisplaySettings,\n                });\n            return treeRef;\n        }\n        const orbitGtBlob = this.jsonProperties.orbitGtBlob;\n        // If this is an OrbitGt reality model, create it's reference\n        if (orbitGtBlob) {\n            let orbitGtName = \"\";\n            if (orbitGtBlob.blobFileName !== \"\") {\n                if (orbitGtBlob.blobFileName[0] === \"/\")\n                    orbitGtName = orbitGtBlob.blobFileName.substring(1);\n                else\n                    orbitGtName = orbitGtBlob.blobFileName;\n            }\n            // Create rdSourceKey if not provided\n            const rdSourceKeyOGT = RealityDataSource.createKeyFromOrbitGtBlobProps(orbitGtBlob);\n            return createOrbitGtTileTreeReference({\n                rdSourceKey: rdSourceKeyOGT,\n                iModel: this.iModel,\n                source: view,\n                modelId: this.id,\n                orbitGtBlob,\n                name: orbitGtName,\n                classifiers: undefined !== spatialModel ? spatialModel.classifiers : undefined,\n                getDisplaySettings,\n            });\n        }\n        // If this is a TileTree reality model, create it's reference\n        const tilesetUrl = this.jsonProperties.tilesetUrl;\n        if (tilesetUrl) {\n            const rdSourceKeyCS = RealityDataSource.createKeyFromUrl(tilesetUrl);\n            return createRealityTileTreeReference({\n                rdSourceKey: rdSourceKeyCS,\n                url: tilesetUrl,\n                iModel: this.iModel,\n                source: view,\n                modelId: this.id,\n                tilesetToDbTransform: this.jsonProperties.tilesetToDbTransform,\n                classifiers: undefined !== spatialModel ? spatialModel.classifiers : undefined,\n                getDisplaySettings,\n            });\n        }\n        return createPrimaryTileTreeReference(view, this);\n    }\n}\n/** Represents the front-end state of a [GeometricModel2d]($backend).\n * @public\n * @extensions\n */\nexport class GeometricModel2dState extends GeometricModelState {\n    static get className() { return \"GeometricModel2d\"; }\n    constructor(props, iModel, state) {\n        super(props, iModel, state);\n        this.globalOrigin = Point2d.fromJSON(props.globalOrigin);\n    }\n    /** @internal */\n    get is3d() { return false; }\n    /** @internal */\n    get asGeometricModel2d() { return this; }\n    toJSON() {\n        const val = super.toJSON();\n        val.globalOrigin = this.globalOrigin;\n        return val;\n    }\n}\n/** Represents the front-end state of a [GeometricModel3d]($backend).\n * @public\n * @extensions\n */\nexport class GeometricModel3dState extends GeometricModelState {\n    static get className() { return \"GeometricModel3d\"; }\n    constructor(props, iModel, state) {\n        super(props, iModel, state);\n        this.isNotSpatiallyLocated = JsonUtils.asBool(props.isNotSpatiallyLocated);\n        this.isPlanProjection = JsonUtils.asBool(props.isPlanProjection);\n    }\n    /** @internal */\n    toJSON() {\n        const val = super.toJSON();\n        if (this.isNotSpatiallyLocated)\n            val.isNotSpatiallyLocated = true;\n        if (this.isPlanProjection)\n            val.isPlanProjection = true;\n        return val;\n    }\n    /** @internal */\n    get is3d() { return true; }\n    /** @internal */\n    get asGeometricModel3d() { return this; }\n    /** If true, then the elements in this GeometricModel3dState are in real-world coordinates and will be in the spatial index. */\n    get isSpatiallyLocated() { return !this.isNotSpatiallyLocated; }\n}\n/** Represents the front-end state of a [SheetModel]($backend).\n * @public\n * @extensions\n */\nexport class SheetModelState extends GeometricModel2dState {\n    static get className() { return \"SheetModel\"; }\n}\n/** Represents the front-end state of a [SpatialModel]($backend).\n * @public\n * @extensions\n */\nexport class SpatialModelState extends GeometricModel3dState {\n    static get className() { return \"SpatialModel\"; }\n    /** @internal */\n    get asSpatialModel() { return this; }\n    constructor(props, iModel, state) {\n        super(props, iModel, state);\n        if (this.isRealityModel)\n            this.classifiers = new SpatialClassifiers(this.jsonProperties);\n    }\n    /** Return true if this is a reality model (represented by a 3d tile set). */\n    get isRealityModel() {\n        return undefined !== this.jsonProperties.tilesetUrl;\n    }\n}\n/** Represents the front-end state of a [PhysicalModel]($backend).\n * @public\n * @extensions\n */\nexport class PhysicalModelState extends SpatialModelState {\n    static get className() { return \"PhysicalModel\"; }\n}\n/** Represents the front-end state of a [SpatialLocationModel]($backend).\n * @public\n * @extensions\n */\nexport class SpatialLocationModelState extends SpatialModelState {\n    static get className() { return \"SpatialLocationModel\"; }\n}\n/** Represents the front-end state of a [DrawingModel]($backend).\n * @public\n * @extensions\n */\nexport class DrawingModelState extends GeometricModel2dState {\n    static get className() { return \"DrawingModel\"; }\n}\n/** Represents the front-end state of a [SectionDrawingModel]($backend).\n * @public\n * @extensions\n */\nexport class SectionDrawingModelState extends DrawingModelState {\n    static get className() { return \"SectionDrawingModel\"; }\n}\n//# sourceMappingURL=ModelState.js.map",
      "start": 1693508119096,
      "end": 1693508119278,
      "sourcemaps": null
    }
  ]
}
