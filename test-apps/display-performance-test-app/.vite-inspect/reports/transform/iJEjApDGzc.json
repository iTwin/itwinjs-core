{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/VisibleFeature.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Rendering\n */\nimport { assert } from \"@itwin/core-bentley\";\nimport { Pixel } from \"./Pixel\";\n/** Ensures that the iterable supplied to QueryVisibleFeaturesCallback becomes invalidated once the callback exits.\n * The iterable relies on RenderTarget state that changes from one frame to another.\n */\nclass ExpiringIterable {\n    constructor(features) {\n        this._disposed = false;\n        this._features = features;\n    }\n    dispose() {\n        this._disposed = true;\n        this._features = [];\n    }\n    [Symbol.iterator]() {\n        assert(!this._disposed, \"The iterable supplied to QueryVisibleFeaturesCallback is valid only for the duration of the callback.\");\n        return this._features[Symbol.iterator]();\n    }\n}\nfunction invokeCallback(features, callback) {\n    const iterable = new ExpiringIterable(features);\n    try {\n        callback(iterable);\n    }\n    finally {\n        iterable.dispose();\n    }\n}\n/** Features read from pixels rendered by a viewport. */\nclass ScreenFeatures {\n    constructor(pixels, rect, viewport) {\n        this._pixels = pixels;\n        this._rect = rect.clone();\n        this._rect.right = viewport.cssPixelsToDevicePixels(this._rect.right);\n        this._rect.bottom = viewport.cssPixelsToDevicePixels(this._rect.bottom);\n        this._iModel = viewport.iModel;\n    }\n    [Symbol.iterator]() {\n        function* iterator(pixels, rect, iModel) {\n            for (let x = rect.left; x < rect.right; x++) {\n                for (let y = rect.top; y < rect.bottom; y++) {\n                    const pixel = pixels.getPixel(x, y);\n                    if (pixel.feature && pixel.modelId) {\n                        yield {\n                            elementId: pixel.feature.elementId,\n                            subCategoryId: pixel.feature.subCategoryId,\n                            geometryClass: pixel.feature.geometryClass,\n                            modelId: pixel.modelId,\n                            iModel: pixel.iModel ?? iModel,\n                        };\n                    }\n                }\n            }\n        }\n        return iterator(this._pixels, this._rect, this._iModel);\n    }\n}\n/** Implementation of [[Viewport.queryVisibleFeatures]].\n * @internal\n */\nexport function queryVisibleFeatures(viewport, options, callback) {\n    assert(\"screen\" === options.source || \"tiles\" === options.source);\n    switch (options.source) {\n        case \"screen\":\n            const rect = options.rect ?? viewport.viewRect;\n            viewport.readPixels(rect, Pixel.Selector.Feature, (pixels) => invokeCallback(pixels ? new ScreenFeatures(pixels, rect, viewport) : [], callback), true !== options.includeNonLocatable);\n            break;\n        case \"tiles\":\n            viewport.target.queryVisibleTileFeatures(options, viewport.iModel, (features) => invokeCallback(features, callback));\n            break;\n        default:\n            invokeCallback([], callback);\n            break;\n    }\n}\n//# sourceMappingURL=VisibleFeature.js.map",
      "start": 1693508119627,
      "end": 1693508119710,
      "sourcemaps": null
    }
  ]
}
