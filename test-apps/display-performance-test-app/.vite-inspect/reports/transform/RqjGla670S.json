{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/glsl/Edge.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { assert } from \"@itwin/core-bentley\";\nimport { AttributeMap } from \"../AttributeMap\";\nimport { ProgramBuilder } from \"../ShaderBuilder\";\nimport { TextureUnit } from \"../RenderFlags\";\nimport { addAnimation } from \"./Animation\";\nimport { addColor } from \"./Color\";\nimport { addFrustum, addShaderFlags } from \"./Common\";\nimport { addWhiteOnWhiteReversal } from \"./Fragment\";\nimport { addAdjustWidth, addLineCode } from \"./Polyline\";\nimport { octDecodeNormal } from \"./Surface\";\nimport { addLineWeight, addModelViewMatrix, addNormalMatrix, addProjectionMatrix, addSamplePosition } from \"./Vertex\";\nimport { addModelToWindowCoordinates, addViewport } from \"./Viewport\";\nimport { addLookupTable } from \"./LookupTable\";\nimport { addRenderOrder, addRenderOrderConstants } from \"./FeatureSymbology\";\nconst computeOtherPos = `\r\n  g_otherPos = samplePosition(g_otherIndex);\r\n`;\nconst decodeEndPointAndQuadIndices = `\r\n  g_otherIndex = decodeUInt24(a_endPointAndQuadIndices.xyz);\r\n${computeOtherPos}\r\n  g_quadIndex = a_endPointAndQuadIndices.w;\r\n`;\nconst animateEndPoint = `g_otherPos.xyz += computeAnimationDisplacement(g_otherIndex, u_animDispParams.x, u_animDispParams.y, u_animDispParams.z, u_qAnimDispOrigin, u_qAnimDispScale);`;\n// a_pos is a 24-bit index into edge lookup table.\n// First six bytes of lookup table entry are the pair of 24-bit indices identifying the endpoints of the edge in the vertex table.\n// Return the 24-bit index of \"this\" vertex in the vertex table encoded in a vec3.\nconst computeIndexedQuantizedPosition = `\r\n  g_vertexId = gl_VertexID % 6;\r\n  if (g_vertexId == 0)\r\n    g_quadIndex = 0.0;\r\n  else if (g_vertexId == 2 || g_vertexId == 3)\r\n    g_quadIndex = 1.0;\r\n  else if (g_vertexId == 1 || g_vertexId == 4)\r\n    g_quadIndex = 2.0;\r\n  else\r\n    g_quadIndex = 3.0;\r\n\r\n  // The following formula computes the texel index, but suffers from precision issues for large edge indices, so we must compute using integers instead.\r\n  // float edgeBaseIndex = u_edgeParams.z * 1.5 + u_edgeParams.w * 0.25 + (edgeIndex - u_edgeParams.z) * 2.5);\r\n\r\n  float fEdgeIndex = decodeUInt24(a_pos);\r\n  g_isSilhouette = fEdgeIndex >= u_edgeParams.z;\r\n  int edgeIndex = int(fEdgeIndex);\r\n  bool isEven = 0 == (edgeIndex & 1);\r\n  float edgeBaseIndex;\r\n  if (!g_isSilhouette) {\r\n    edgeBaseIndex = float(edgeIndex + (edgeIndex / 2));\r\n  } else {\r\n    // If both pad and edgeIndex produce a remainder (0.5 for each - pad is a multiple of 2), we must add one to the index to account for it.\r\n    int shift = isEven ? 0 : 1;\r\n    int pad = int(u_edgeParams.w);\r\n    if (0 != (pad % 4)) {\r\n      isEven = !isEven;\r\n      shift = shift + 1;\r\n    }\r\n\r\n    // s = num segments p = num padding bytes i = edge index\r\n    // texel index = 1.5s + .25p + 2.5(i - s) = 1.5s + .25p + 2.5i - 2.5s = 2.5i + .25p - s = i + i + i/2 + p/4 - s\r\n    edgeBaseIndex = float(edgeIndex + edgeIndex + edgeIndex / 2 + pad / 4 - int(u_edgeParams.z) + shift / 2);\r\n  }\r\n\r\n  vec2 tc = compute_edge_coords(floor(edgeBaseIndex));\r\n  vec4 s0 = floor(TEXTURE(u_edgeLUT, tc) * 255.0 + 0.5);\r\n  tc.x += g_edge_stepX;\r\n  vec4 s1 = floor(TEXTURE(u_edgeLUT, tc) * 255.0 + 0.5);\r\n  tc.x += g_edge_stepX;\r\n  vec4 s2 = floor(TEXTURE(u_edgeLUT, tc) * 255.0 + 0.5);\r\n\r\n  vec3 i0 = isEven ? s0.xyz : vec3(s0.zw, s1.x);\r\n  vec3 i1 = isEven ? vec3(s0.w, s1.xy) : s1.yzw;\r\n  g_otherIndexIndex = g_quadIndex < 2.0 ? i1 : i0;\r\n\r\n  g_normals = isEven ? vec4(s1.zw, s2.xy) : s2;\r\n\r\n  return g_quadIndex < 2.0 ? i0 : i1;\r\n`;\nconst initializeIndexed = `\r\n  g_otherIndex = decodeUInt24(g_otherIndexIndex);\r\n${computeOtherPos}\r\n`;\n// IndexedEdgeGeometry.renderOrder returns Edge or PlanarEdge. Adjust if silhouette for output to pick buffers.\nconst computeIndexedRenderOrder = `\r\n  if (g_isSilhouette)\r\n    v_renderOrder = kRenderOrder_Edge == u_renderOrder ? kRenderOrder_Silhouette : kRenderOrder_PlanarSilhouette;\r\n  else\r\n    v_renderOrder = u_renderOrder;\r\n`;\nconst checkForSilhouetteDiscard = `\r\n  if (kFrustumType_Perspective != u_frustum.z) {\r\n    float perpTol = 4.75e-6;\r\n    return (n0.z * n1.z > perpTol);      // orthographic.\r\n  } else {\r\n    float perpTol = 2.5e-4;\r\n    vec4  viewPos = MAT_MV * rawPos;     // perspective\r\n    vec3  toEye = normalize(viewPos.xyz);\r\n    float dot0 = dot(n0, toEye);\r\n    float dot1 = dot(n1, toEye);\r\n\r\n    if (dot0 * dot1 > perpTol)\r\n      return true;\r\n\r\n    // Need to discard if either is non-silhouette.\r\n    vec4 otherPosition = g_otherPos;\r\n    viewPos = MAT_MV * otherPosition;\r\n    toEye = normalize(viewPos.xyz);\r\n    dot0 = dot(n0, toEye);\r\n    dot1 = dot(n1, toEye);\r\n\r\n    return dot0 * dot1 > perpTol;\r\n  }\r\n`;\nconst checkForSilhouetteDiscardNonIndexed = `\r\n  vec3 n0 = MAT_NORM * octDecodeNormal(a_normals.xy);\r\n  vec3 n1 = MAT_NORM * octDecodeNormal(a_normals.zw);\r\n${checkForSilhouetteDiscard}\r\n`;\nconst checkForSilhouetteDiscardIndexed = `\r\n  if (!g_isSilhouette)\r\n    return false;\r\n\r\n  vec3 n0 = MAT_NORM * octDecodeNormal(g_normals.xy);\r\n  vec3 n1 = MAT_NORM * octDecodeNormal(g_normals.zw);\r\n${checkForSilhouetteDiscard}\r\n`;\nconst computePosition = `\r\n  v_lnInfo = vec4(0.0, 0.0, 0.0, 0.0);  // init and set flag to false\r\n  vec4  other = g_otherPos;\r\n  float miterAdjust = 0.0;\r\n  float weight = computeLineWeight();\r\n\r\n  vec4 pos;\r\n  g_windowPos = modelToWindowCoordinates(rawPos, other, pos, v_eyeSpace);\r\n  if (g_windowPos.w == 0.0) // Clipped out.\r\n    return g_windowPos;\r\n\r\n  vec4 otherPos;\r\n  vec3 otherMvPos;\r\n  vec4 projOther = modelToWindowCoordinates(other, rawPos, otherPos, otherMvPos);\r\n\r\n  g_windowDir = projOther.xy - g_windowPos.xy;\r\n\r\n  adjustWidth(weight, g_windowDir, g_windowPos.xy);\r\n  g_windowDir = normalize(g_windowDir);\r\n\r\n  vec2  perp = vec2(-g_windowDir.y, g_windowDir.x);\r\n  float perpDist = weight / 2.0;\r\n  float alongDist = 0.0;\r\n\r\n  perpDist *= sign(0.5 - float(g_quadIndex == 0.0 || g_quadIndex == 3.0)); // negate for index 0 and 3\r\n  alongDist += distance(rawPos, other) * float(g_quadIndex >= 2.0); // index 2 and 3 correspond to 'far' endpoint of segment\r\n\r\n  pos.x += perp.x * perpDist * 2.0 * pos.w / u_viewport.x;\r\n  pos.y += perp.y * perpDist * 2.0 * pos.w / u_viewport.y;\r\n\r\n  lineCodeEyePos = .5 * (rawPos + other);\r\n  lineCodeDist = alongDist;\r\n\r\n  return pos;\r\n`;\nconst lineCodeArgs = \"g_windowDir, g_windowPos, 0.0\";\nconst adjustContrast = `\r\n  float bgi = u_bgIntensity;\r\n  if (bgi < 0.0)\r\n    return baseColor;\r\n\r\n  float s;\r\n  float rgbi = baseColor.r * 0.3 + baseColor.g * 0.59 + baseColor.b * 0.11;\r\n  if (rgbi > 0.81)\r\n    s = bgi > 0.57 ? 0.0 : 0.699;\r\n  else if (rgbi > 0.57)\r\n    s = bgi > 0.57 ? 0.0 : 1.0;\r\n  else\r\n    s = bgi < 0.81 ? 1.0 : 0.699;\r\n\r\n  return vec4(vec3(s), baseColor.a);\r\n`;\n/** @internal */\nexport function addEdgeContrast(vert) {\n    vert.addUniform(\"u_bgIntensity\", 2 /* VariableType.Float */, (prog) => {\n        prog.addGraphicUniform(\"u_bgIntensity\", (uniform, params) => {\n            let bgi = -1;\n            if (params.geometry.isEdge && params.target.currentEdgeSettings.wantContrastingColor(params.target.currentViewFlags.renderMode))\n                bgi = params.target.uniforms.style.backgroundIntensity;\n            uniform.setUniform1f(bgi);\n        });\n    });\n    vert.set(8 /* VertexShaderComponent.AdjustContrast */, adjustContrast);\n}\nconst edgeLutParams = new Float32Array(4);\nfunction createBase(type, instanced, isAnimated, positionType) {\n    const isInstanced = 1 /* IsInstanced.Yes */ === instanced;\n    const isSilhouette = \"Silhouette\" === type;\n    const isIndexed = \"IndexedEdge\" === type;\n    const techId = isSilhouette ? 5 /* TechniqueId.SilhouetteEdge */ : (isIndexed ? 6 /* TechniqueId.IndexedEdge */ : 4 /* TechniqueId.Edge */);\n    const attrMap = AttributeMap.findAttributeMap(techId, isInstanced);\n    const builder = new ProgramBuilder(attrMap, { positionType, instanced: isInstanced });\n    const vert = builder.vert;\n    vert.addGlobal(\"g_otherPos\", 5 /* VariableType.Vec4 */);\n    vert.addGlobal(\"g_quadIndex\", 2 /* VariableType.Float */);\n    vert.addGlobal(\"g_windowPos\", 5 /* VariableType.Vec4 */);\n    vert.addGlobal(\"g_windowDir\", 3 /* VariableType.Vec2 */);\n    vert.addGlobal(\"g_otherIndex\", 2 /* VariableType.Float */);\n    addSamplePosition(vert);\n    if (isIndexed) {\n        vert.addGlobal(\"g_vertexId\", 1 /* VariableType.Int */);\n        vert.addGlobal(\"g_otherIndexIndex\", 4 /* VariableType.Vec3 */);\n        vert.addGlobal(\"g_isSilhouette\", 0 /* VariableType.Boolean */, \"false\");\n        vert.addGlobal(\"g_normals\", 5 /* VariableType.Vec4 */);\n        const initLut = addLookupTable(vert, \"edge\", \"1.0\");\n        vert.addUniform(\"u_edgeLUT\", 8 /* VariableType.Sampler2D */, (prog) => {\n            prog.addGraphicUniform(\"u_edgeLUT\", (uniform, params) => {\n                const edge = params.geometry.asIndexedEdge;\n                assert(undefined !== edge);\n                edge.edgeLut.texture.bindSampler(uniform, TextureUnit.EdgeLUT);\n            });\n        });\n        vert.addUniform(\"u_edgeParams\", 5 /* VariableType.Vec4 */, (prog) => {\n            prog.addGraphicUniform(\"u_edgeParams\", (uniform, params) => {\n                const edge = params.geometry.asIndexedEdge;\n                assert(undefined !== edge);\n                edgeLutParams[0] = edge.edgeLut.texture.width;\n                edgeLutParams[1] = edge.edgeLut.texture.height;\n                edgeLutParams[2] = edge.edgeLut.numSegments;\n                edgeLutParams[3] = edge.edgeLut.silhouettePadding;\n                uniform.setUniform4fv(edgeLutParams);\n            });\n        });\n        vert.set(0 /* VertexShaderComponent.ComputeQuantizedPosition */, `${initLut}\\n\\n${computeIndexedQuantizedPosition}`);\n        vert.addInitializer(initializeIndexed);\n        addRenderOrder(vert);\n        addRenderOrderConstants(vert);\n        builder.addInlineComputedVarying(\"v_renderOrder\", 2 /* VariableType.Float */, computeIndexedRenderOrder);\n        builder.frag.set(20 /* FragmentShaderComponent.OverrideRenderOrder */, \"return v_renderOrder;\");\n    }\n    else {\n        vert.addInitializer(decodeEndPointAndQuadIndices);\n    }\n    if (isAnimated) {\n        addAnimation(vert, false);\n        vert.addInitializer(animateEndPoint);\n    }\n    vert.addGlobal(\"lineCodeEyePos\", 5 /* VariableType.Vec4 */);\n    vert.addGlobal(\"lineCodeDist\", 2 /* VariableType.Float */, \"0.0\");\n    addModelToWindowCoordinates(vert); // adds u_mvp, u_viewportTransformation, and sets g_eyeSpace\n    addProjectionMatrix(vert);\n    addLineCode(builder, lineCodeArgs);\n    builder.addVarying(\"v_eyeSpace\", 4 /* VariableType.Vec3 */);\n    vert.set(10 /* VertexShaderComponent.ComputePosition */, computePosition);\n    builder.addVarying(\"v_lnInfo\", 5 /* VariableType.Vec4 */);\n    addAdjustWidth(vert);\n    addViewport(vert);\n    addModelViewMatrix(vert);\n    addLineWeight(vert);\n    if (isSilhouette || isIndexed) {\n        addNormalMatrix(vert);\n        addFrustum(builder);\n        vert.addFunction(octDecodeNormal);\n        vert.set(2 /* VertexShaderComponent.CheckForEarlyDiscard */, isSilhouette ? checkForSilhouetteDiscardNonIndexed : checkForSilhouetteDiscardIndexed);\n    }\n    return builder;\n}\n/** @internal */\nexport function createEdgeBuilder(type, instanced, isAnimated, posType) {\n    const builder = createBase(type, instanced, isAnimated, posType);\n    addShaderFlags(builder);\n    addColor(builder);\n    addEdgeContrast(builder.vert);\n    addWhiteOnWhiteReversal(builder.frag);\n    return builder;\n}\n//# sourceMappingURL=Edge.js.map",
      "start": 1693508124651,
      "end": 1693508124741,
      "sourcemaps": null
    }
  ]
}
