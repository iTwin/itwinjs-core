{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/geometry3d/SortablePolygon.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\nimport { CurveChain } from \"../curve/CurveCollection\";\nimport { CurvePrimitive } from \"../curve/CurvePrimitive\";\nimport { LineString3d } from \"../curve/LineString3d\";\nimport { Loop } from \"../curve/Loop\";\nimport { ParityRegion } from \"../curve/ParityRegion\";\nimport { RegionOps } from \"../curve/RegionOps\";\nimport { UnionRegion } from \"../curve/UnionRegion\";\nimport { IndexedReadWriteXYZCollection } from \"./IndexedXYZCollection\";\nimport { PolygonOps } from \"./PolygonOps\";\n/** abstract base class for area-related queries of a loop.\n * * subclasses have particular logic for `Loop` and polygon data.\n * @internal\n */\nclass SimpleRegionCarrier {\n}\n/**\n * Implement `LoopCarrier` queries with the area as a polygon carried in an `IndexedReadWriteXYZCollection`\n */\nclass PolygonCarrier extends SimpleRegionCarrier {\n    get signedArea() { return this._signedArea; }\n    constructor(data) {\n        super();\n        this.data = data;\n        this._signedArea = PolygonOps.areaXY(data);\n    }\n    /**\n     * classify xy parts of point wrt this loop.\n     * @param xy\n     * @internal\n     */\n    classifyPointXY(xy) {\n        return PolygonOps.classifyPointInPolygonXY(xy.x, xy.y, this.data);\n    }\n    /** Return some point \"inside\"\n     * NEEDS WORK: this returns a point ON --\n     */\n    getAnyInteriorPoint() {\n        for (let childIndex = 0; childIndex < this.data.length; childIndex++) {\n            const q = this.constructInteriorPointNearEdge(childIndex, 0.2349);\n            if (q !== undefined)\n                return q;\n        }\n        return undefined;\n    }\n    grabPolygon() { return this.data; }\n    grabLoop() {\n        return Loop.createPolygon(this.data);\n    }\n    reverseForAreaSign(targetSign) {\n        if (targetSign * this._signedArea < 0.0) {\n            this.data.reverseInPlace();\n            this._signedArea *= -1.0;\n        }\n    }\n    constructInteriorPointNearEdge(edgeIndex, fractionAlong) {\n        if (edgeIndex + 1 < this.data.length) {\n            const point0 = this.data.getPoint3dAtUncheckedPointIndex(edgeIndex);\n            const point1 = this.data.getPoint3dAtUncheckedPointIndex(edgeIndex + 1);\n            const vector = point0.vectorTo(point1);\n            const point = point0.interpolate(fractionAlong, point1);\n            vector.rotate90CCWXY(vector);\n            if (vector.normalizeInPlace()) {\n                if (this._signedArea < 0)\n                    vector.scaleInPlace(-1.0);\n                const refDistance = Math.sqrt(Math.abs(this._signedArea));\n                for (let fraction = 1.0e-5; fraction < 3; fraction *= 5.0) {\n                    const candidatePoint = point.plusScaled(vector, fraction * refDistance);\n                    if (1 === this.classifyPointXY(candidatePoint))\n                        return candidatePoint;\n                }\n            }\n        }\n        return undefined;\n    }\n}\n/**\n * Implement `LoopCarrier` queries with the area as a strongly typed `Loop`\n */\nclass LoopCarrier extends SimpleRegionCarrier {\n    get signedArea() { return this._signedArea; }\n    constructor(data) {\n        super();\n        this.data = data;\n        const areaMoments = RegionOps.computeXYAreaMoments(data);\n        this._signedArea = areaMoments !== undefined ? areaMoments.quantitySum : 0.0;\n    }\n    /**\n     * classify xy parts of point wrt this loop.\n     * @param xy\n     * @internal\n     */\n    classifyPointXY(xy) {\n        return RegionOps.testPointInOnOutRegionXY(this.data, xy.x, xy.y);\n    }\n    constructInteriorPointNearChild(childIndex, fractionAlong) {\n        if (childIndex < this.data.children.length) {\n            const primitive = this.data.children[childIndex];\n            const ray = primitive.fractionToPointAndUnitTangent(fractionAlong);\n            ray.direction.rotate90CCWXY(ray.direction);\n            if (this._signedArea < 0.0)\n                ray.direction.scaleInPlace(-1.0);\n            const refDistance = Math.sqrt(Math.abs(this._signedArea));\n            for (let fraction = 1.0e-5; fraction < 3; fraction *= 5.0) {\n                const candidatePoint = ray.fractionToPoint(fraction * refDistance);\n                if (1 === this.classifyPointXY(candidatePoint))\n                    return candidatePoint;\n            }\n        }\n        return undefined;\n    }\n    /** Return some point \"inside\"\n     * NEEDS WORK: this returns a point ON --\n     */\n    getAnyInteriorPoint() {\n        for (let childIndex = 0; childIndex < this.data.children.length; childIndex++) {\n            const q = this.constructInteriorPointNearChild(childIndex, 0.2349);\n            if (q !== undefined)\n                return q;\n        }\n        return undefined;\n    }\n    grabPolygon() {\n        const strokes = this.data.cloneStroked();\n        if (strokes instanceof CurveChain) {\n            const linestring = LineString3d.create();\n            for (const child of strokes.children) {\n                if (child instanceof CurvePrimitive) {\n                    child.emitStrokes(linestring);\n                }\n            }\n            return linestring.numPoints() > 0 ? linestring.packedPoints : undefined;\n        }\n        return undefined;\n    }\n    grabLoop() {\n        return this.data;\n    }\n    reverseForAreaSign(targetSign) {\n        if (targetSign * this._signedArea < 0.0) {\n            this.data.reverseChildrenInPlace();\n            this._signedArea *= -1.0;\n        }\n    }\n}\n/**\n * A `SortablePolygon` carries a (single) loop with data useful for sorting for inner-outer structure.\n * @internal\n */\nexport class SortablePolygon {\n    /**\n     *\n     * @param loop Loop to capture.\n     */\n    constructor(loop, range) {\n        if (loop instanceof IndexedReadWriteXYZCollection)\n            this._loopCarrier = new PolygonCarrier(loop);\n        else\n            this._loopCarrier = new LoopCarrier(loop);\n        this.range = range;\n        this.sortKey = Math.abs(this._loopCarrier.signedArea);\n        this.isHole = false;\n    }\n    /** Push loop with sort data onto the array.\n     * * No action if no clear normal.\n     * * return true if pushed.\n     */\n    static pushPolygon(loops, loop) {\n        const range = loop.getRange();\n        const sortablePolygon = new SortablePolygon(loop, range);\n        if (sortablePolygon.sortKey > 0.0) {\n            loops.push(sortablePolygon);\n            return true;\n        }\n        return false;\n    }\n    /** Push loop with sort data onto the array.\n     * * No action if no clear normal.\n     * * return true if pushed.\n     */\n    static pushLoop(loops, loop) {\n        const range = loop.range();\n        const sortablePolygon = new SortablePolygon(loop, range);\n        if (sortablePolygon.sortKey > 0.0) {\n            loops.push(sortablePolygon);\n            return true;\n        }\n        return false;\n    }\n    /** Push loop with sort data onto the array.\n     * * No action if no clear normal.\n     * * return true if pushed.\n     */\n    static assignParentsAndDepth(loops) {\n        // Sort largest to smallest ...\n        loops.sort((loopA, loopB) => (loopB.sortKey - loopA.sortKey));\n        // starting with smallest loop, point each loop to smallest containing parent.\n        for (let i = loops.length; i-- > 0;) {\n            const thisLoop = loops[i];\n            const xy = thisLoop._loopCarrier.getAnyInteriorPoint();\n            if (xy !== undefined) {\n                // find smallest containing parent (search forward only to hit)\n                loops[i].parentIndex = undefined;\n                loops[i].outputSetIndex = undefined;\n                for (let j = i; j-- > 0;) {\n                    const otherLoop = loops[j];\n                    if (otherLoop.range.containsXY(xy.x, xy.y)) {\n                        if (1 === otherLoop._loopCarrier.classifyPointXY(xy)) {\n                            thisLoop.parentIndex = j;\n                            // The loops are searched from small area to larger.  Any other containing loop is larger, so otherLoop must be the smallest.\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    static assemblePolygonSet(loops) {\n        const outputSets = [];\n        // In large-to-small order:\n        // If a loop has no parent or has a \"hole\" as parent it is outer.\n        // otherwise (i.e. it has a non-hole parent) it becomes a hole in the parent.\n        for (const loopData of loops) {\n            loopData.isHole = false;\n            const parentIndex = loopData.parentIndex;\n            if (parentIndex !== undefined)\n                loopData.isHole = !loops[parentIndex].isHole;\n            if (!loopData.isHole) {\n                loopData._loopCarrier.reverseForAreaSign(1.0);\n                loopData.outputSetIndex = outputSets.length;\n                outputSets.push([]);\n                outputSets[loopData.outputSetIndex].push(loopData._loopCarrier.grabPolygon());\n            }\n            else {\n                loopData._loopCarrier.reverseForAreaSign(-1.0);\n                const outputSetIndex = loops[parentIndex].outputSetIndex;\n                outputSets[outputSetIndex].push(loopData._loopCarrier.grabPolygon());\n            }\n        }\n        return outputSets;\n    }\n    static assembleLoopSet(loops) {\n        const outputSets = [];\n        const numLoops = loops.length;\n        // In large-to-small order:\n        // If a loop has no parent or has a \"hole\" as parent it is outer.\n        // otherwise (i.e. it has a non-hole parent) it becomes a hole in the parent.\n        for (let candidateIndex = 0; candidateIndex < numLoops; candidateIndex++) {\n            const candidateData = loops[candidateIndex];\n            const parentIndex = candidateData.parentIndex;\n            candidateData.isHole = parentIndex !== undefined ? !loops[parentIndex].isHole : false;\n            if (!candidateData.isHole) {\n                candidateData._loopCarrier.reverseForAreaSign(1.0);\n                const candidateLoop = candidateData._loopCarrier.grabLoop();\n                let candidateParityRegion;\n                // find all directly contained children . . .\n                for (let childIndex = candidateIndex + 1; childIndex < numLoops; childIndex++) {\n                    const childData = loops[childIndex];\n                    if (childData.parentIndex === candidateIndex) {\n                        if (candidateParityRegion === undefined) {\n                            candidateParityRegion = ParityRegion.create();\n                            candidateParityRegion.tryAddChild(candidateLoop);\n                            childData._loopCarrier.reverseForAreaSign(-1.0);\n                            candidateParityRegion.tryAddChild(childData._loopCarrier.grabLoop());\n                        }\n                        else {\n                            childData._loopCarrier.reverseForAreaSign(-1.0);\n                            candidateParityRegion.tryAddChild(childData._loopCarrier.grabLoop());\n                        }\n                    }\n                }\n                if (candidateParityRegion !== undefined)\n                    outputSets.push(candidateParityRegion);\n                else if (candidateLoop !== undefined)\n                    outputSets.push(candidateLoop);\n            }\n        }\n        return outputSets;\n    }\n    static sortAsAnyRegion(loops) {\n        this.assignParentsAndDepth(loops);\n        const regions = this.assembleLoopSet(loops);\n        if (regions.length === 1)\n            return regions[0];\n        else {\n            const unionRegion = UnionRegion.create();\n            for (const region of regions)\n                unionRegion.tryAddChild(region);\n            return unionRegion;\n        }\n    }\n    static sortAsArrayOfArrayOfPolygons(loops) {\n        this.assignParentsAndDepth(loops);\n        return this.assemblePolygonSet(loops);\n    }\n    grabPolygon() {\n        return this._loopCarrier.grabPolygon();\n    }\n    grabLoop() {\n        return this._loopCarrier.grabLoop();\n    }\n    reverseForAreaSign(targetSign) {\n        this._loopCarrier.reverseForAreaSign(targetSign);\n    }\n    getAnyInteriorPoint() {\n        return this._loopCarrier.getAnyInteriorPoint();\n    }\n}\n//# sourceMappingURL=SortablePolygon.js.map",
      "start": 1693508124093,
      "end": 1693508124150,
      "sourcemaps": null
    }
  ]
}
