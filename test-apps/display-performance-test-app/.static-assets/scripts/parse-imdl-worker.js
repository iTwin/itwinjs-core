(()=>{"use strict";const t=!1;function e(e,i){if(t&&("boolean"!=typeof e&&(e=e()),!e))throw"string"!=typeof(i=i??"Programmer Error")&&(i=i()),new Error(`Assert: ${i}`)}function i(t,e){return t-e}function s(t,e){return t!==e?t<e?-1:1:0}function n(t,e){return t===e?0:t<e?-1:1}function r(t,e,i){return void 0===e?void 0===i?0:-1:void 0===i?1:t(e,i)}function o(t,e){return r(n,t,e)}function a(t){const e=parseInt(t,16);return Number.isNaN(e)?0:e}function c(t,e,i=!0){const s=t.charCodeAt(e);return s>=(i?48:49)&&s<=57||s>=97&&s<=102}function h(t,e,i){if(0===i)return!1;if(!c(t,e,!1))return!1;for(let s=1;s<i;s++)if(!c(t,e+s))return!1;return!0}var l,d,u,f,g,p,m,x,y,_,v,P,I,A,S,w,C,T,k,F,M,b,E,X,R,z,D,Y,N,O,B,V,L,U;function Z(t){return t}function q(t,e,i){return function(t,e){let i=0,s=t.length;for(;i<s;){const n=Math.floor((i+s)/2),r=e(t[n]);if(0===r)return{index:n,equal:!0};r<0?s=n:i=n+1}return{index:i,equal:!1}}(e,(e=>i(t,e)))}!function(t){t.getLocalId=function(t){if(g(t))return 0;const e=t.length,i=e>12?e-10:2;return a(t.slice(i))},t.getBriefcaseId=function(t){if(g(t))return 0;const e=t.length;return e<=12?0:a(t.slice(2,e-10))},t.fromJSON=function(e){return"string"==typeof e?t.fromString(e):t.invalid},t.fromString=function(e){if("string"!=typeof e)return t.invalid;if(t.isId64(e))return e;const s=(e=e.toLowerCase().trim()).length;if(s<2||"0"!==e[0]||"x"!==e[1])return t.invalid;let n=0,r=0,o=2;return s>12&&(o=s-10,r=a(e.slice(2,o))),n=a(e.slice(o)),i(n,r)};const e=["0000000000","000000000","00000000","0000000","000000","00000","0000","000","00","0",""];function i(i,s){if("number"!=typeof i||"number"!=typeof s)return t.invalid;if(0===(i=Math.floor(i)))return t.invalid;s=Math.floor(s);const n=i.toString(16);return`0x${0===s?n:s.toString(16)+(e[n.length]+n)}`}t.fromLocalAndBriefcaseIds=i;const s=[48,120,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48];function n(t){return t+(t<10?48:87)}function r(t,e,i){let s=0;for(let r=e;r<i;r++)s=(s|(n=t.charCodeAt(r))-(n>=87?87:48)<<(i-r-1<<2))>>>0;var n;return s}function o(e,i){if(0==(e>>>0)+4294967296*(255&i))return t.invalid;const r=s;let o=2;for(let t=7;t>=0;t--){const e=t<<2,s=(i&15<<e)>>>e;(o>2||0!==s)&&(r[o++]=n(s))}for(let t=7;t>=0;t--){const i=t<<2,s=(e&15<<i)>>>i;(o>2||0!==s)&&(r[o++]=n(s))}return r.length!==o&&(r.length=o),String.fromCharCode(...s)}function c(t){if(g(t))return 0;const e=t.length;return r(t,e>10?e-8:2,e)}function l(t){const e=t.length;return e<=10||g(t)?0:r(t,2,e-8)}function*d(t){if("string"==typeof t)yield t;else for(const e of t)yield e}function u(t){return 18===t.length&&t.startsWith("0xffffff")}function f(e){return t.invalid!==e&&t.isId64(e)}function g(e){return t.invalid===e}t.fromUint32Pair=o,t.fromUint32PairObject=function(t){return o(t.lower,t.upper)},t.isValidUint32Pair=function(t,e){return 0!==t||0!=(255&e)},t.getUint32Pair=function(t,e){return e||(e={lower:0,upper:0}),e.lower=c(t),e.upper=l(t),e},t.getLowerUint32=c,t.getUpperUint32=l,t.toIdSet=function(t,e=!1){if(t instanceof Set)return e?new Set(t):t;const i=new Set;return"string"==typeof t?i.add(t):Array.isArray(t)&&t.forEach((t=>{"string"==typeof t&&i.add(t)})),i},t.iterator=d,t.iterable=function(t){return{[Symbol.iterator]:()=>d(t)}},t.getFirst=function(t){return"string"==typeof t?t:Array.isArray(t)?t[0]:t.values().next().value},t.sizeOf=function(t){return"string"==typeof t?1:Array.isArray(t)?t.length:t.size},t.has=function(t,e){return"string"==typeof t?t===e:Array.isArray(t)?-1!==t.indexOf(e):t.has(e)},t.invalid="0",t.isTransient=u,t.isTransientId64=function(t){return f(t)&&u(t)},t.isId64=function(t){const e=t.length;if(0===e||18<e)return!1;if("0"!==t[0])return!1;if(1===e)return!0;if(2===e||"x"!==t[1])return!1;let i=2;if(e>12){if(i=e-10,!h(t,2,i-2))return!1;for(let s=i;s<e&&48===t.charCodeAt(s);s++)i++;if(i>=e)return!1}return h(t,i,e-i)},t.isValid=function(e){return t.invalid!==e},t.isValidId64=f,t.isInvalid=g,t.Uint32Set=class{constructor(t){this._map=new Map,void 0!==t&&this.addIds(t)}clear(){this._map.clear()}addId(e){this.add(t.getLowerUint32(e),t.getUpperUint32(e))}addIds(e){for(const i of t.iterable(e))this.addId(i)}hasId(e){return this.has(t.getLowerUint32(e),t.getUpperUint32(e))}add(t,e){let i=this._map.get(e);void 0===i&&(i=new Set,this._map.set(e,i)),i.add(t)}deleteId(e){this.delete(t.getLowerUint32(e),t.getUpperUint32(e))}deleteIds(e){for(const i of t.iterable(e))this.deleteId(i)}delete(t,e){const i=this._map.get(e);void 0!==i&&i.delete(t)}has(t,e){const i=this._map.get(e);return void 0!==i&&i.has(t)}hasPair(t){return this.has(t.lower,t.upper)}get isEmpty(){return 0===this._map.size}get size(){let t=0;for(const e of this._map)t+=e[1].size;return t}toId64Array(){const e=[];for(const i of this._map)for(const s of i[1])e.push(t.fromUint32Pair(s,i[0]));return e}toId64Set(){const e=new Set;for(const i of this._map)for(const s of i[1])e.add(t.fromUint32Pair(s,i[0]));return e}forEach(t){for(const e of this._map)for(const i of e[1])t(i,e[0])}},t.Uint32Map=class{constructor(){this._map=new Map}clear(){this._map.clear()}getById(e){return this.get(t.getLowerUint32(e),t.getUpperUint32(e))}setById(e,i){this.set(t.getLowerUint32(e),t.getUpperUint32(e),i)}set(t,e,i){let s=this._map.get(e);void 0===s&&(s=new Map,this._map.set(e,s)),s.set(t,i)}get(t,e){const i=this._map.get(e);return void 0!==i?i.get(t):void 0}get isEmpty(){return 0===this._map.size}get size(){let t=0;for(const e of this._map)t+=e[1].size;return t}forEach(t){for(const e of this._map)for(const i of e[1])t(i[0],e[0],i[1])}}}(l||(l={})),function(t){const e=new RegExp("^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$");function i(t){return e.test(t)}t.empty="00000000-0000-0000-0000-000000000000",t.isGuid=i,t.isV4Guid=function(t){return/^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-4[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$/.test(t)},t.createValue=function(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,(t=>{const e=16*Math.random()|0;return("x"===t?e:3&e|8).toString(16)}))},t.normalize=function(t){const e=t.toLowerCase().trim();if(i(e))return e;const s=e.replace(/-/g,""),n=/^([0-9a-f]{8})([0-9a-f]{4})([0-9a-f]{4})([0-9a-f]{4})([0-9a-f]{12})$/;return n.test(s)?s.replace(n,((t,e,i,s,n,r)=>`${e}-${i}-${s}-${n}-${r}`)):t}}(d||(d={})),function(t){function i(t,e){return t.length!==e.length?t.length<e.length?-1:1:t!==e?t<e?-1:1:0}function*s(t){const e=t[Symbol.iterator]();let i,s=e.next();for(;!s.done;){const t=s.value;s=e.next(),t!==i&&(i=t,yield t)}}function*n(t,s){const n=t[Symbol.iterator](),r=s[Symbol.iterator]();let o,a=n.next(),c=r.next();for(;!a.done||!c.done;){const t=a.done?void 0:a.value,s=c.done?void 0:c.value;if(e(void 0!==t||void 0!==s),void 0===t&&void 0===s)break;let h;if(void 0===t)e(void 0!==s),h=s,c=r.next();else if(void 0===s)h=t,a=n.next();else{const e=i(t,s);e<=0?(h=t,a=n.next(),0===e&&(c=r.next())):(h=s,c=r.next())}o!==h&&(o=h,yield h)}}function*r(t,e){const s=t[Symbol.iterator](),n=e[Symbol.iterator]();let r,o=s.next(),a=n.next();for(;!o.done&&!a.done;){const t=o.value;if(o=s.next(),t===r)continue;r=t;let e=a.value,c=i(t,e);for(;c>0;){if(a=n.next(),a.done)return;e=a.value,c=i(t,e)}0===c&&(yield t)}}function*o(t,e){const s=t[Symbol.iterator](),n=e[Symbol.iterator]();let r,o=s.next(),a=n.next();for(;!o.done;){const t=o.value;if(o=s.next(),t===r)continue;if(a.done){yield r=t;continue}let e=a.value,c=i(t,e);for(;c>0&&!a.done;)a=n.next(),a.done?yield r=t:(e=a.value,c=i(t,e));c<0&&(yield r=t)}}t.compare=i,t.sortArray=function(t){return t.sort(((t,e)=>i(t,e))),t},t.areEqualSets=function(t,e){const n=s(t),r=s(e);let o=n.next(),a=r.next();for(;!o.done&&!a.done;){if(0!==i(o.value,a.value))return!1;o=n.next(),a=r.next()}return!(!o.done||!a.done)},t.isEmptySet=function(t){return"string"==typeof t?""===t:!0===t[Symbol.iterator]().next().done},t.unique=function(t){return{[Symbol.iterator]:()=>s(t)}},t.uniqueIterator=s,t.union=function(t,e){return{[Symbol.iterator]:()=>n(t,e)}},t.intersection=function(t,e){return{[Symbol.iterator]:()=>r(t,e)}},t.difference=function(t,e){return{[Symbol.iterator]:()=>o(t,e)}},t.unionIterator=n,t.intersectionIterator=r,t.differenceIterator=o}(u||(u={})),function(t){t[t.Allow=0]="Allow",t[t.Retain=1]="Retain",t[t.Replace=2]="Replace"}(f||(f={})),Symbol.iterator,function(t){function i(t){return t>=48&&t<=57||t>=65&&t<=70}function s(t,i){e(i>0);const s=`+${t.toString()}`;return i<=1?s:`${s}*${i.toString(16).toUpperCase()}`}function n(t){const e="string"==typeof t?[t]:Array.from(t);return u.sortArray(e),r(e)}function r(t){return o(t)}function o(t){if("string"==typeof t)return t;let e="";const i=new a,n=new a;let r=0;const o=new a,c=new a;for(const a of t){if(!l.isValidId64(a))continue;o.setFromId(a),c.setFromDifference(o,i);const t=i.compare(o);if(0!==t){if(t>0)throw new Error("CompressedId64Set.compressArray requires a sorted array as input");i.copyFrom(o),0===r?(n.copyFrom(c),r=1):c.equals(n)?++r:(e+=s(n,r),n.copyFrom(c),r=1)}}return 0<r&&(e+=s(n,r)),e}t.compressSet=function(t){return n(t)},t.sortAndCompress=n,t.compressArray=r,t.compressIds=o;class a{static assertUint32(t){e(t>=0),e(t<a._base),e(Math.floor(t)===t)}assertConstraints(){a.assertUint32(this.lower),a.assertUint32(this.upper)}constructor(t=0,e=0){this.lower=t,this.upper=e,this.assertConstraints()}compare(t){const e=this.upper-t.upper;return 0===e?this.lower-t.lower:e}equals(t){return 0===this.compare(t)}isLessThan(t){return this.compare(t)<0}isGreaterThan(t){return this.compare(t)>0}get isZero(){return 0===this.lower&&0===this.upper}setFromDifference(t,i){e(!i.isGreaterThan(t)),this.lower=t.lower-i.lower,this.upper=t.upper-i.upper,this.lower<0&&(this.lower+=a._base,this.upper-=1)}add(t){let e=t.lower,i=t.upper;e+this.lower>=a._base&&(e-=a._base,i+=1),this.lower+=e,this.upper+=i,this.assertConstraints()}setFromId(t){l.getUint32Pair(t,this)}copyFrom(t){this.lower=t.lower,this.upper=t.upper}toString(){if(0===this.upper)return this.lower.toString(16).toUpperCase();const t=this.upper.toString(16),i=this.lower.toString(16).padStart(8,"0");return e(8===i.length),`${t}${i}`.toUpperCase()}toId64String(){return l.fromUint32Pair(this.lower,this.upper)}}function*c(t){if(0===t.length)return;if("+"!==t[0])throw new Error("Invalid CompressedId64Set");let s=1;const n=new a;function r(){let e=0,n=0;for(;s<t.length&&n<8;){++n;const r=t.charCodeAt(s);if(!i(r))break;e<<=4,e|=r>=65?r-65+10:r-48,e>>>=0,++s}return e}function o(n){let o=0,a=0;const c=s,h=r(),l=s-c;if(e(l<=8),8===l&&s+1<t.length&&i(t.charCodeAt(s+1))){const t=s,i=r(),n=s-t;e(n>0&&n<=8);const c=8-n;a=h>>>4*c,o=(i|h-(a<<4*c>>>0)<<4*n>>>0)>>>0}else o=h;n.lower=o,n.upper=a}const c=new a;for(;s<t.length;){let e=1;if(o(c),c.isZero)throw new Error("Invalid CompressedId64Set");if(s<t.length)switch(t[s++]){case"*":if(e=r(),0===e)throw new Error("Invalid CompressedId64Set");if(s!==t.length&&"+"!==t[s++])return;break;case"+":break;default:throw new Error("Invalid CompressedId64Set")}for(let t=0;t<e;t++)n.add(c),yield n.toId64String()}}function h(t){return{[Symbol.iterator]:()=>c(t)}}a._base=4294967296,t.iterator=c,t.iterable=h,t.decompressSet=function(t,e){const i=e??new Set;for(const e of h(t))i.add(e);return i},t.decompressArray=function(t,e){const i=e??[];for(const e of h(t))i.push(e);return i}}(g||(g={})),Symbol.iterator;class W{constructor(t=0,e){this._radians=t,this._degrees=e}clone(){return new W(this._radians,this._degrees)}freeze(){return Object.freeze(this)}static createDegrees(t){return new W(W.degreesToRadians(t),t)}static createRadians(t){return new W(t)}static createSmallAngle(){return new W(K.smallAngleRadians)}static createInterpolate(t,e,i){return new W(K.interpolate(t.radians,e,i.radians))}cloneScaled(t){return new W(this.radians*t)}setRadians(t){this._radians=t,this._degrees=void 0}setDegrees(t){this._radians=W.degreesToRadians(t),this._degrees=t}static create360(){return new W(2*Math.PI,360)}static createAtan2(t,e){return new W(Math.atan2(t,e))}setFrom(t){this._radians=t._radians,this._degrees=t._degrees}setFromJSON(t,e){this._radians=e||0,t&&("number"==typeof t?this.setDegrees(t):"number"==typeof t.degrees?this.setDegrees(t.degrees):"number"==typeof t._degrees?this.setDegrees(t._degrees):"number"==typeof t.radians?this.setRadians(t.radians):"number"==typeof t._radians&&this.setRadians(t._radians))}static fromJSON(t,e){const i=new W;return i.setFromJSON(t,e),i}toJSON(){return this.degrees}toJSONRadians(){return{radians:this.radians}}get radians(){return this._radians}get degrees(){return void 0!==this._degrees?this._degrees:W.radiansToDegrees(this._radians)}static degreesToRadians(t){return t*Math.PI/180}static radiansToDegrees(t){if(t<0)return-W.radiansToDegrees(-t);const e=Math.PI;return t<=.25*e?180/e*t:t<.75*e?90+(t-.5*e)/e*180:t<=1.25*e?180+(t-e)/e*180:t<=1.75*e?270+(t-1.5*e)/e*180:360+(t-2*e)/e*180}cos(){return Math.cos(this._radians)}sin(){return Math.sin(this._radians)}tan(){return Math.tan(this._radians)}static isFullCircleRadians(t){return Math.abs(t)>=K.fullCircleRadiansMinusSmallAngle}static isHalfCircleRadians(t){return Math.abs(Math.abs(t)-Math.PI)<=K.smallAngleRadians}get isFullCircle(){return W.isFullCircleRadians(this._radians)}get isHalfCircle(){return W.isHalfCircleRadians(this._radians)}static adjustDegrees0To360(t){if(t>=0){const e=360;return t<e?t:t-Math.floor(t/e)*e}return t<0?360-W.adjustDegrees0To360(-t):0}static adjustDegreesSigned180(t){if(Math.abs(t)<=180)return t;if(t>=0){const e=360;return t-(1+Math.floor((t-180)/e))*e}return t<0?-W.adjustDegreesSigned180(-t):0}static adjustRadians0To2Pi(t){if(t>=0){const e=2*Math.PI;return t<e?t:t-Math.floor(t/e)*e}return t<0?2*Math.PI-W.adjustRadians0To2Pi(-t):0}static adjustRadiansMinusPiPlusPi(t){if(Math.abs(t)<=Math.PI)return t;if(t>=0){const e=2*Math.PI;return t-(1+Math.floor((t-Math.PI)/e))*e}return t<0?-W.adjustRadiansMinusPiPlusPi(-t):0}static zero(){return new W(0)}get isExactZero(){return 0===this.radians}get isAlmostZero(){return Math.abs(this.radians)<K.smallAngleRadians}get isAlmostNorthOrSouthPole(){return W.isHalfCircleRadians(2*this.radians)}static createDegreesAdjustPositive(t){return W.createDegrees(W.adjustDegrees0To360(t))}static createDegreesAdjustSigned180(t){return W.createDegrees(W.adjustDegreesSigned180(t))}static isAlmostEqualRadiansAllowPeriodShift(t,e,i=K.smallAngleRadians){const s=Math.abs(t-e);if(s<=i)return!0;const n=2*Math.PI;if(Math.abs(s-n)<=i)return!0;const r=s-Math.round(s/n)*n;return Math.abs(r)<=i}isMagnitudeLessThanOrEqual(t){return Math.abs(this.radians)<=Math.abs(t.radians)}isAlmostEqualAllowPeriodShift(t,e=K.smallAngleRadians){return W.isAlmostEqualRadiansAllowPeriodShift(this._radians,t._radians,e)}static isAlmostEqualRadiansNoPeriodShift(t,e,i=K.smallAngleRadians){return Math.abs(t-e)<i}isAlmostEqualNoPeriodShift(t,e=K.smallAngleRadians){return W.isAlmostEqualRadiansNoPeriodShift(this._radians,t._radians,e)}isAlmostEqual(t,e=K.smallAngleRadians){return this.isAlmostEqualNoPeriodShift(t,e)}static isPerpendicularDotSet(t,e,i){return t>K.smallMetricDistanceSquared&&e>K.smallMetricDistanceSquared&&i*i<=K.smallAngleRadiansSquared*t*e}static trigValuesToHalfAngleTrigValues(t,e){const i=K.hypotenuseXY(t,e);if(i<K.smallMetricDistance)return{c:1,s:0,radians:0};{let s,n=0;const r=t/i,o=e/i;return r>=0?(s=Math.sqrt(.5*(1+r)),n=o/(2*s)):(n=o>0?Math.sqrt(.5*(1-r)):-Math.sqrt(.5*(1-r)),s=o/(2*n)),{c:s,s:n,radians:Math.atan2(n,s)}}}static cleanupTrigValue(t,e=K.smallFloatingPoint){const i=Math.abs(t);if(i<=e)return 0;let s=Math.abs(i-.5);return s<=e?t<0?-.5:.5:(s=Math.abs(i-1),s<=e?t<0?-1:1:t)}static dotProductsToHalfAngleTrigValues(t,e,i,s=!0){const n=t-e,r=2*i;return s&&Math.abs(r)<K.smallAngleRadians*(Math.abs(t)+Math.abs(e))?{c:1,s:0,radians:0}:W.trigValuesToHalfAngleTrigValues(n,r)}static radiansBetweenVectorsXYZ(t,e,i,s,n,r){const o=t*s+e*n+i*r;return Math.atan2(K.crossProductMagnitude(t,e,i,s,n,r),o)}static orientedRadiansBetweenVectorsXYZ(t,e,i,s,n,r,o,a,c,h=!1){const l=t*s+e*n+i*r,d=e*r-i*n,u=i*s-t*r,f=t*n-e*s,g=o*d+a*u+c*f,p=K.hypotenuseXYZ(d,u,f);return g<0?h?Math.PI+Math.atan2(p,-l):-Math.atan2(p,l):Math.atan2(p,l)}addMultipleOf2PiInPlace(t){void 0!==this._degrees?(this._degrees+=360*t,this._radians=W.degreesToRadians(this._degrees)):this._radians+=t*W.pi2Radians}}W.piOver12Radians=.26179938779914946,W.piOver4Radians=.7853981633974483,W.piOver2Radians=1.5707963267948966,W.piRadians=3.141592653589793,W.pi2Radians=6.283185307179586,W.degreesPerRadian=45/W.piOver4Radians,W.radiansPerDegree=W.piOver4Radians/45;class G{set(t=0,e=0){this.x=t,this.y=e}setZero(){this.x=0,this.y=0}constructor(t=0,e=0){this.x=t,this.y=e}setFrom(t){t?(this.x=t.x,this.y=t.y):(this.x=0,this.y=0)}freeze(){return Object.freeze(this)}isAlmostEqual(t,e){return K.isSameCoordinate(this.x,t.x,e)&&K.isSameCoordinate(this.y,t.y,e)}isAlmostEqualXY(t,e,i){return K.isSameCoordinate(this.x,t,i)&&K.isSameCoordinate(this.y,e,i)}toJSON(){return[this.x,this.y]}toJSONXY(){return{x:this.x,y:this.y}}setFromJSON(t){Array.isArray(t)?this.set(t[0]||0,t[1]||0):t?this.set(t.x||0,t.y||0):this.set(0,0)}distance(t){const e=t.x-this.x,i=t.y-this.y;return Math.sqrt(e*e+i*i)}distanceSquared(t){const e=t.x-this.x,i=t.y-this.y;return e*e+i*i}maxDiff(t){return Math.max(Math.abs(this.x-t.x),Math.abs(this.y-t.y))}at(t){return t<.5?this.x:this.y}setAt(t,e){t<.5?this.x=e:this.y=e}indexOfMaxAbs(){let t=0;const e=Math.abs(this.x);return Math.abs(this.y)>e&&(t=1),t}get isAlmostZero(){return K.isSmallMetricDistance(this.x)&&K.isSmallMetricDistance(this.y)}maxAbs(){return Math.max(Math.abs(this.x),Math.abs(this.y))}magnitude(){return Math.sqrt(this.x*this.x+this.y*this.y)}magnitudeSquared(){return this.x*this.x+this.y*this.y}isExactEqual(t){return this.x===t.x&&this.y===t.y}isAlmostEqualMetric(t,e=K.smallMetricDistance){return this.maxDiff(t)<=e}vectorTo(t,e){return J.create(t.x-this.x,t.y-this.y,e)}unitVectorTo(t,e){return this.vectorTo(t,e).normalize(e)}static crossProductToPoints(t,e,i){return K.crossProductXYXY(e.x-t.x,e.y-t.y,i.x-t.x,i.y-t.y)}}class H extends G{constructor(t=0,e=0){super(t,e)}clone(t){return H.create(this.x,this.y,t)}static create(t=0,e=0,i){return i?(i.x=t,i.y=e,i):new H(t,e)}static fromJSON(t){const e=new H;return e.setFromJSON(t),e}static createFrom(t,e){return t?H.create(t.x,t.y,e):H.create(0,0,e)}static createZero(t){return H.create(0,0,t)}addForwardLeft(t,e,i,s){const n=i.x,r=i.y;return H.create(this.x+t*n-e*r,this.y+t*r+e*n,s)}forwardLeftInterpolate(t,e,i){const s=i.x-this.x,n=i.y-this.y;return H.create(this.x+t*s-e*n,this.y+t*n+e*s)}interpolate(t,e,i){if(t<=.5)return H.create(this.x+t*(e.x-this.x),this.y+t*(e.y-this.y),i);const s=t-1;return H.create(e.x+s*(e.x-this.x),e.y+s*(e.y-this.y),i)}interpolateXY(t,e,i,s){return H.create(K.interpolate(this.x,t,i.x),K.interpolate(this.y,e,i.y),s)}minus(t,e){return H.create(this.x-t.x,this.y-t.y,e)}plus(t,e){return H.create(this.x+t.x,this.y+t.y,e)}plusXY(t=0,e=0,i){return H.create(this.x+t,this.y+e,i)}plusScaled(t,e,i){return H.create(this.x+t.x*e,this.y+t.y*e,i)}plus2Scaled(t,e,i,s,n){return H.create(this.x+t.x*e+i.x*s,this.y+t.y*e+i.y*s,n)}plus3Scaled(t,e,i,s,n,r,o){return H.create(this.x+t.x*e+i.x*s+n.x*r,this.y+t.y*e+i.y*s+n.y*r,o)}dotVectorsToTargets(t,e){return(t.x-this.x)*(e.x-this.x)+(t.y-this.y)*(e.y-this.y)}crossProductToPoints(t,e){const i=t.x-this.x,s=t.y-this.y,n=e.x-this.x;return i*(e.y-this.y)-s*n}fractionOfProjectionToLine(t,e,i=0){const s=t.distanceSquared(e);return s<K.smallMetricDistanceSquared?i:t.dotVectorsToTargets(e,this)/s}}class J extends G{constructor(t=0,e=0){super(t,e)}clone(t){return J.create(this.x,this.y,t)}static create(t=0,e=0,i){return i?(i.x=t,i.y=e,i):new J(t,e)}static unitX(t=1){return new J(t,0)}static unitY(t=1){return new J(0,t)}static createZero(t){return J.create(0,0,t)}static createFrom(t,e){return t instanceof Float64Array?t.length>=2?J.create(t[0],t[1]):t.length>=1?J.create(t[0],0):J.create(0,0):J.create(t.x,t.y,e)}static fromJSON(t){const e=new J;return e.setFromJSON(t),e}static createPolar(t,e){return J.create(t*e.cos(),t*e.sin())}static createStartEnd(t,e,i){return J.create(e.x-t.x,e.y-t.y,i)}static createOffsetBisector(t,e,i){let s=t.plus(e);if(s=s.normalize(),s){const e=s.dotProduct(t);return s.scale(i,s),s.safeDivideOrNull(e)}}safeDivideOrNull(t,e){if(0!==t)return this.scale(1/t,e)}normalize(t){const e=K.correctSmallFraction(this.magnitude());return t=t||new J,this.safeDivideOrNull(e,t)}fractionOfProjectionToVector(t,e){const i=t.magnitudeSquared();return i<K.smallMetricDistanceSquared?e||0:this.dotProduct(t)/i}negate(t){return(t=t||new J).x=-this.x,t.y=-this.y,t}rotate90CCWXY(t){t=t||new J;const e=this.x,i=this.y;return t.x=-i,t.y=e,t}rotate90CWXY(t){t=t||new J;const e=this.x,i=this.y;return t.x=i,t.y=-e,t}unitPerpendicularXY(t){t=t||new J;const e=this.x,i=this.y;t.x=-i,t.y=e;const s=e*e+i*i;if(0!==s){const e=1/Math.sqrt(s);t.x*=e,t.y*=e}return t}rotateXY(t,e){const i=t.sin(),s=t.cos(),n=this.x,r=this.y;return(e=e||new J).x=n*s-r*i,e.y=n*i+r*s,e}interpolate(t,e,i){if(i=i||new J,t<=.5)i.x=this.x+t*(e.x-this.x),i.y=this.y+t*(e.y-this.y);else{const s=t-1;i.x=e.x+s*(e.x-this.x),i.y=e.y+s*(e.y-this.y)}return i}plus(t,e){return(e=e||new J).x=this.x+t.x,e.y=this.y+t.y,e}minus(t,e){return(e=e||new J).x=this.x-t.x,e.y=this.y-t.y,e}plusScaled(t,e,i){return(i=i||new J).x=this.x+t.x*e,i.y=this.y+t.y*e,i}plus2Scaled(t,e,i,s,n){return(n=n||new J).x=this.x+t.x*e+i.x*s,n.y=this.y+t.y*e+i.y*s,n}plus3Scaled(t,e,i,s,n,r,o){return(o=o||new J).x=this.x+t.x*e+i.x*s+n.x*r,o.y=this.y+t.y*e+i.y*s+n.y*r,o}scale(t,e){return(e=e||new J).x=this.x*t,e.y=this.y*t,e}scaleToLength(t,e){const i=K.correctSmallFraction(this.magnitude());if(0!==i)return this.scale(t/i,e)}dotProduct(t){return this.x*t.x+this.y*t.y}dotProductStartEnd(t,e){return this.x*(e.x-t.x)+this.y*(e.y-t.y)}crossProduct(t){return this.x*t.y-this.y*t.x}radiansTo(t){return Math.atan2(this.crossProduct(t),this.dotProduct(t))}angleTo(t){return W.createRadians(this.radiansTo(t))}isParallelTo(t,e=!1,i=!1,s){const n=s?.radianSquaredTol??K.smallAngleRadiansSquared,r=s?.distanceSquaredTol??K.smallMetricDistanceSquared,o=this.magnitudeSquared(),a=t.magnitudeSquared();if(o<r||a<r)return i;if(this.dotProduct(t)<0&&!e)return!1;const c=this.crossProduct(t);return c*c<=n*o*a}isPerpendicularTo(t,e=!1,i){const s=i?.radianSquaredTol??K.smallAngleRadiansSquared,n=i?.distanceSquaredTol??K.smallMetricDistanceSquared,r=this.magnitudeSquared(),o=t.magnitudeSquared();if(r<n||o<n)return e;const a=this.dotProduct(t);return a*a<=s*r*o}}!function(t){t[t.XYZ=0]="XYZ",t[t.YZX=1]="YZX",t[t.ZXY=2]="ZXY",t[t.XZY=4]="XZY",t[t.YXZ=5]="YXZ",t[t.ZYX=6]="ZYX"}(p||(p={})),function(t){t[t.X=0]="X",t[t.Y=1]="Y",t[t.Z=2]="Z"}(m||(m={})),function(t){t[t.Top=1]="Top",t[t.Bottom=2]="Bottom",t[t.Left=3]="Left",t[t.Right=4]="Right",t[t.Front=5]="Front",t[t.Back=6]="Back",t[t.Iso=7]="Iso",t[t.RightIso=8]="RightIso"}(x||(x={})),function(t){t[t.Unit=0]="Unit",t[t.LongestRangeDirection=1]="LongestRangeDirection",t[t.NonUniformRangeContainment=2]="NonUniformRangeContainment"}(y||(y={})),function(t){t[t.Unknown=0]="Unknown",t[t.OnPolygonVertex=1]="OnPolygonVertex",t[t.OnPolygonEdgeInterior=2]="OnPolygonEdgeInterior",t[t.InsidePolygon=3]="InsidePolygon",t[t.InsidePolygonProjectsToVertex=4]="InsidePolygonProjectsToVertex",t[t.InsidePolygonProjectsToEdgeInterior=5]="InsidePolygonProjectsToEdgeInterior",t[t.OutsidePolygon=6]="OutsidePolygon",t[t.OutsidePolygonProjectsToVertex=7]="OutsidePolygonProjectsToVertex",t[t.OutsidePolygonProjectsToEdgeInterior=8]="OutsidePolygonProjectsToEdgeInterior"}(_||(_={}));class K{static isLargeCoordinateResult(t){return t>this.largeCoordinateResult||t<-this.largeCoordinateResult}static isHugeCoordinate(t){return K.isLargeCoordinateResult(t)}static isOdd(t){return 1==(1&t)}static correctSmallMetricDistance(t,e=0){return void 0===t||Math.abs(t)<K.smallMetricDistance?e:t}static correctSmallFraction(t,e=0){return void 0===t||Math.abs(t)<K.smallFraction?e:t}static inverseMetricDistance(t){return Math.abs(t)<=K.smallMetricDistance?void 0:1/t}static inverseMetricDistanceSquared(t){return Math.abs(t)<=K.smallMetricDistanceSquared?void 0:1/t}static isSameCoordinate(t,e,i=K.smallMetricDistance){let s=t-e;return s<0&&(s=-s),s<=i}static isSameCoordinateWithToleranceFactor(t,e,i){return K.isSameCoordinate(t,e,i*K.smallMetricDistance)}static isSameCoordinateXY(t,e,i,s,n=K.smallMetricDistance){let r=i-t;return r<0&&(r=-r),!(r>n)&&(r=s-e,r<0&&(r=-r),r<=n)}static isSameCoordinateSquared(t,e,i=K.smallMetricDistance){return Math.abs(Math.sqrt(t)-Math.sqrt(e))<=i}static isSamePoint3d(t,e,i=K.smallMetricDistance){return t.distance(e)<=i}static isSameXYZ(t,e,i=K.smallMetricDistance){return t.distance(e)<=i}static isSamePoint3dXY(t,e,i=K.smallMetricDistance){return t.distanceXY(e)<=i}static isSameVector3d(t,e,i=K.smallMetricDistance){return t.distance(e)<=i}static isSamePoint2d(t,e,i=K.smallMetricDistance){return t.distance(e)<=i}static isSameVector2d(t,e,i=K.smallMetricDistance){return t.distance(e)<=i}static lexicalXYLessThan(t,e){return t.x<e.x?-1:t.x>e.x?1:t.y<e.y?-1:t.y>e.y?1:0}static lexicalYXLessThan(t,e){return t.y<e.y?-1:t.y>e.y?1:t.x<e.x?-1:t.x>e.x?1:0}static lexicalXYZLessThan(t,e){return t.x<e.x?-1:t.x>e.x?1:t.y<e.y?-1:t.y>e.y?1:t.z<e.z?-1:t.z>e.z?1:0}static isSmallRelative(t){return Math.abs(t)<K.smallFraction}static isSmallAngleRadians(t){return Math.abs(t)<K.smallAngleRadians}static isAlmostEqualOptional(t,e,i){if(void 0!==t&&void 0!==e){if(Math.abs(t-e)>i)return!1}else if(void 0!==t||void 0!==e)return!1;return!0}static isAlmostEqualNumber(t,e,i=K.smallAngleRadians){const s=1+Math.abs(t)+Math.abs(e);return Math.abs(t-e)<=i*s}static isAlmostEqualXAndY(t,e,i=K.smallAngleRadians){const s=i*(1+Math.abs(t.x)+Math.abs(e.x)+Math.abs(t.y)+Math.abs(e.y));return Math.abs(t.x-e.x)<=s&&Math.abs(t.y-e.y)<=s}static isDistanceWithinTol(t,e=K.smallMetricDistance){return Math.abs(t)<=e}static isSmallMetricDistance(t){return Math.abs(t)<=K.smallMetricDistance}static isSmallMetricDistanceSquared(t){return Math.abs(t)<=K.smallMetricDistanceSquared}static cyclic3dAxis(t){if(t>=0)return t<3?t:t<6?t-3:t%3;const e=t+3;return e>=0?e:2-(-t-1)%3}static axisIndexToRightHandedAxisOrder(t){return 0===t?p.XYZ:1===t?p.YZX:2===t?p.ZXY:K.axisIndexToRightHandedAxisOrder(K.cyclic3dAxis(t))}static maxXYZ(t,e,i){let s=t;return e>s&&(s=e),i>s&&(s=i),s}static minXYZ(t,e,i){let s=t;return e<s&&(s=e),i<s&&(s=i),s}static maxXY(t,e){let i=t;return e>i&&(i=e),i}static minXY(t,e){let i=t;return e<i&&(i=e),i}static maxAbsXYZ(t,e,i){return K.maxXYZ(Math.abs(t),Math.abs(e),Math.abs(i))}static maxAbsXY(t,e){return K.maxXY(Math.abs(t),Math.abs(e))}static maxAbsDiff(t,e,i){return Math.max(Math.abs(t-e),Math.abs(t-i))}static split3WaySign(t,e,i,s){return t<0?e:t>0?s:i}static split3Way01(t,e=K.smallMetricDistance){return t>e?1:t<-e?-1:0}static square(t){return t*t}static hypotenuseXY(t,e){return Math.sqrt(t*t+e*e)}static hypotenuseSquaredXY(t,e){return t*t+e*e}static hypotenuseXYZ(t,e,i){return Math.sqrt(t*t+e*e+i*i)}static hypotenuseSquaredXYZ(t,e,i){return t*t+e*e+i*i}static hypotenuseXYZW(t,e,i,s){return Math.sqrt(t*t+e*e+i*i+s*s)}static hypotenuseSquaredXYZW(t,e,i,s){return t*t+e*e+i*i+s*s}static distanceXYXY(t,e,i,s){return K.hypotenuseXY(i-t,s-e)}static distanceXYZXYZ(t,e,i,s,n,r){return K.hypotenuseXYZ(s-t,n-e,r-i)}static tripleProduct(t,e,i,s,n,r,o,a,c){return t*(n*c-r*a)+e*(r*o-s*c)+i*(s*a-n*o)}static determinant4x4(t,e,i,s,n,r,o,a,c,h,l,d,u,f,g,p){return t*this.tripleProduct(r,o,a,h,l,d,f,g,p)-n*this.tripleProduct(e,i,s,h,l,d,f,g,p)+c*this.tripleProduct(e,i,s,r,o,a,f,g,p)-u*this.tripleProduct(e,i,s,r,o,a,h,l,d)}static tripleProductXYW(t,e,i,s,n,r){return K.tripleProduct(t.x,i.x,n.x,t.y,i.y,n.y,e,s,r)}static tripleProductPoint4dXYW(t,e,i){return K.tripleProduct(t.x,e.x,i.x,t.y,e.y,i.y,t.w,e.w,i.w)}static crossProductXYXY(t,e,i,s){return t*s-e*i}static crossProductXYZXYZ(t,e,i,s,n,r,o){return $.create(e*r-i*n,i*s-t*r,t*n-e*s,o)}static crossProductMagnitude(t,e,i,s,n,r){return K.hypotenuseXYZ(e*r-i*n,i*s-t*r,t*n-e*s)}static dotProductXYXY(t,e,i,s){return t*i+e*s}static dotProductXYZXYZ(t,e,i,s,n,r){return t*s+e*n+i*r}static meanCurvatureOfRadii(t,e){return.5*(this.safeDivideFraction(1,t,0)+this.safeDivideFraction(1,e,0))}static curvatureMagnitude(t,e,i,s,n,r){let o=e*r-i*n,a=o*o;o=i*s-t*r,a+=o*o,o=t*n-e*s,a+=o*o;const c=Math.sqrt(a),h=Math.sqrt(t*t+e*e+i*i),l=h*h*h;return l>K.smallAngleRadians*c?c/l:0}static clampToStartEnd(t,e,i){return e>i?K.clampToStartEnd(t,i,e):t<e?e:i<t?i:t}static clamp(t,e,i){return Math.max(e,Math.min(i,t))}static resolveNumber(t,e=0){return void 0!==t?t:e}static resolveValue(t,e){return void 0!==t?t:e}static resolveToUndefined(t,e){return t===e?void 0:t}static interpolate(t,e,i){return e<=.5?t+e*(i-t):i-(1-e)*(i-t)}static axisOrderToAxis(t,e){const i=t<=p.ZXY?t+e:t-p.XZY-e;return K.cyclic3dAxis(i)}static modulo(t,e){if(e<=0)return 0===e?t:-K.modulo(-t,-e);if(t>=0){if(t<e)return t;if(t<2*e)return t-e}else if((t+=e)>0)return t;return t-Math.floor(t/e)*e}static defined01(t){return void 0===t?0:1}static conditionalDivideFraction(t,e){if(Math.abs(e)*K.largeFractionResult>Math.abs(t))return t/e}static safeDivideFraction(t,e,i){const s=K.conditionalDivideFraction(t,e);return void 0!==s?s:i}static conditionalDivideCoordinate(t,e,i=K.largeCoordinateResult){if(Math.abs(e*i)>Math.abs(t))return t/e}static solveTrigForm(t,e,i){const s=e*e+i*i;let n;if(s>0){const r=1/s,o=1-t*t*r;if(o<-K.smallMetricDistanceSquared)return n;const a=-t*r,c=a*e,h=a*i;if(o<=0)n=[J.create(c,h)];else{const t=Math.sqrt(o*r);n=[J.create(c-t*i,h+t*e),J.create(c+t*i,h-t*e)]}}return n}static inverseInterpolate(t,e,i,s,n=0,r){const o=K.conditionalDivideFraction(n-e,s-e);return void 0!==o?K.interpolate(t,o,i):r}static inverseInterpolate01(t,e,i=0){return K.conditionalDivideFraction(i-t,e-t)}static isNumberArray(t,e=0){if(Array.isArray(t)&&t.length>=e){let e;for(e of t)if(!Number.isFinite(e))return!1;return!0}return!1}static isArrayOfNumberArray(t,e,i=0){if(Array.isArray(t)&&t.length>=e){let e;for(e of t)if(!K.isNumberArray(e,i))return!1;return!0}return!1}static stepCount(t,e,i=1,s=101){if(t<=0)return i;if(t>=(e=Math.abs(e)))return i;const n=Math.floor((e+.999999*t)/t);return n<i?i:n>s?s:n}static isIn01(t,e=!0){return!e||t>=0&&t<=1}static isIn01WithTolerance(t,e){return t+e>=0&&t-e<=1}static restrictToInterval(t,e,i){return e<=i?t<e?e:t>i?i:t:t<i?i:t>e?e:t}static equalStringNoCase(t,e){return t.toUpperCase()===e.toUpperCase()}static exactEqualNumberArrays(t,e){if(Array.isArray(t)&&0===t.length&&(t=void 0),Array.isArray(e)&&0===e.length&&(e=void 0),void 0===t&&void 0===e)return!0;if(Array.isArray(t)&&Array.isArray(e)){if(t.length!==e.length)return!1;for(let i=0;i<t.length;i++)if(t[i]!==e[i])return!1;return!0}return!1}static almostEqualArrays(t,e,i){if(Array.isArray(t)&&0===t.length&&(t=void 0),Array.isArray(e)&&0===e.length&&(e=void 0),void 0===t&&void 0===e)return!0;if(Array.isArray(t)&&Array.isArray(e)){if(t.length!==e.length)return!1;for(let s=0;s<t.length;s++)if(!i(t[s],e[s]))return!1;return!0}return!1}static almostEqualNumberArrays(t,e,i){if(Array.isArray(t)&&0===t.length&&(t=void 0),Array.isArray(e)&&0===e.length&&(e=void 0),void 0===t&&void 0===e)return!0;if(Array.isArray(t)&&Array.isArray(e)){if(t.length!==e.length)return!1;for(let s=0;s<t.length;s++)if(!i(t[s],e[s]))return!1;return!0}return!1}static areEqualAllowUndefined(t,e,i=!0){return void 0===t&&void 0===e?i:void 0!==t&&void 0!==e&&t===e}static cloneMembers(t){if(void 0===t)return;const e=[];for(const i of t)e.push(i.clone());return e}}K.smallMetricDistance=1e-6,K.smallMetricDistanceSquared=1e-12,K.smallAngleRadians=1e-12,K.smallAngleRadiansSquared=1e-24,K.smallAngleDegrees=57e-12,K.smallAngleSeconds=2e-7,K.smallFraction=1e-10,K.smallFloatingPoint=1e-15,K.fullCircleRadiansMinusSmallAngle=2*Math.PI-K.smallAngleRadians,K.largeFractionResult=1e10,K.largeCoordinateResult=1e13,K.hugeCoordinate=1e12,function(t){t.almostEqual=function(t,e,i){return K.isSameCoordinate(t.x,e.x,i)&&K.isSameCoordinate(t.y,e.y,i)&&K.isSameCoordinate(t.z,e.z,i)}}(v||(v={}));class j{set(t=0,e=0,i=0){this.x=t,this.y=e,this.z=i}setZero(){this.x=0,this.y=0,this.z=0}constructor(t=0,e=0,i=0){this.x=t,this.y=e,this.z=i}static isXAndY(t){return void 0!==t.x&&void 0!==t.y}static hasZ(t){return void 0!==t.z}static isXYAndZ(t){return this.isXAndY(t)&&this.hasZ(t)}static isAnyImmediatePointType(t){return Q.isXAndY(t)||K.isNumberArray(t,2)}static accessX(t,e){return void 0!==t.x?t.x:Array.isArray(t)&&t.length>0&&Number.isFinite(t[0])?t[0]:e}static accessY(t,e){return void 0!==t.y?t.y:Array.isArray(t)&&t.length>1&&Number.isFinite(t[1])?t[1]:e}static accessZ(t,e){return void 0!==t.z?t.z:Array.isArray(t)&&t.length>2&&Number.isFinite(t[2])?t[2]:e}setFrom(t){void 0===t?this.setZero():j.isXAndY(t)?(this.x=t.x,this.y=t.y,this.z=j.hasZ(t)?t.z:0):(this.x=t[0],this.y=t[1],this.z=t[2])}setFromPoint3d(t){t?(this.x=t.x,this.y=t.y,this.z=t.z):this.setZero()}setFromVector3d(t){t?(this.x=t.x,this.y=t.y,this.z=t.z):this.setZero()}isAlmostEqual(t,e){return v.almostEqual(this,t,e)}isAlmostEqualXYZ(t,e,i,s){return K.isSameCoordinate(this.x,t,s)&&K.isSameCoordinate(this.y,e,s)&&K.isSameCoordinate(this.z,i,s)}isAlmostEqualPointPlusScaledVector(t,e,i,s){return K.isSameCoordinate(this.x,t.x+e.x*i,s)&&K.isSameCoordinate(this.y,t.y+e.y*i,s)&&K.isSameCoordinate(this.z,t.z+e.z*i,s)}isAlmostEqualXY(t,e){return K.isSameCoordinate(this.x,t.x,e)&&K.isSameCoordinate(this.y,t.y,e)}toJSON(){return this.toArray()}toArray(){return[this.x,this.y,this.z]}toJSONXYZ(){return{x:this.x,y:this.y,z:this.z}}toFloat64Array(){return Float64Array.of(this.x,this.y,this.z)}setFromJSON(t){Array.isArray(t)?this.set(t[0]||0,t[1]||0,t[2]||0):t?this.set(t.x||0,t.y||0,t.z||0):this.set(0,0,0)}distance(t){const e=t.x-this.x,i=t.y-this.y,s=t.z-this.z;return Math.sqrt(e*e+i*i+s*s)}distanceSquared(t){const e=t.x-this.x,i=t.y-this.y,s=t.z-this.z;return e*e+i*i+s*s}distanceXY(t){const e=t.x-this.x,i=t.y-this.y;return Math.sqrt(e*e+i*i)}distanceSquaredXY(t){const e=t.x-this.x,i=t.y-this.y;return e*e+i*i}maxDiff(t){return Math.max(Math.abs(this.x-t.x),Math.abs(this.y-t.y),Math.abs(this.z-t.z))}at(t){return t<.5?this.x:t>1.5?this.z:this.y}setAt(t,e){t<.5?this.x=e:t>1.5?this.z=e:this.y=e}indexOfMaxAbs(){let t=0,e=Math.abs(this.x),i=Math.abs(this.y);return i>e&&(t=1,e=i),i=Math.abs(this.z),i>e&&(t=2),t}get isAlmostZero(){return K.isSmallMetricDistance(this.x)&&K.isSmallMetricDistance(this.y)&&K.isSmallMetricDistance(this.z)}get isZero(){return 0===this.x&&0===this.y&&0===this.z}maxAbs(){return Math.max(Math.abs(this.x),Math.abs(this.y),Math.abs(this.z))}magnitude(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}magnitudeSquared(){return this.x*this.x+this.y*this.y+this.z*this.z}magnitudeXY(){return Math.sqrt(this.x*this.x+this.y*this.y)}magnitudeSquaredXY(){return this.x*this.x+this.y*this.y}isExactEqual(t){return this.x===t.x&&this.y===t.y&&this.z===t.z}isAlmostEqualMetric(t){return this.maxDiff(t)<=K.smallMetricDistance}addInPlace(t){this.x+=t.x,this.y+=t.y,this.z+=t.z}subtractInPlace(t){this.x-=t.x,this.y-=t.y,this.z-=t.z}addScaledInPlace(t,e){this.x+=e*t.x,this.y+=e*t.y,this.z+=e*t.z}scaleInPlace(t){this.x*=t,this.y*=t,this.z*=t}addXYZInPlace(t=0,e=0,i=0){this.x+=t,this.y+=e,this.z+=i}cloneAsPoint3d(){return Q.create(this.x,this.y,this.z)}vectorTo(t,e){return $.create(t.x-this.x,t.y-this.y,t.z-this.z,e)}scaledVectorTo(t,e,i){return $.create(e*(t.x-this.x),e*(t.y-this.y),e*(t.z-this.z),i)}unitVectorTo(t,e){return this.vectorTo(t,e).normalize(e)}freeze(){return Object.freeze(this)}static x(t,e=0){return void 0===t?e:Array.isArray(t)?t[0]:void 0!==t.x?t.x:e}static y(t,e=0){return void 0===t?e:Array.isArray(t)?t[1]:void 0!==t.y?t.y:e}static z(t,e=0){return void 0===t?e:Array.isArray(t)?t[2]:void 0!==t.z?t.z:e}}class Q extends j{constructor(t=0,e=0,i=0){super(t,e,i)}static fromJSON(t){const e=new Q;return e.setFromJSON(t),e}clone(t){return Q.create(this.x,this.y,this.z,t)}static create(t=0,e=0,i=0,s){return s?(s.x=t,s.y=e,s.z=i,s):new Q(t,e,i)}static createFrom(t,e){if(t instanceof Float64Array){let i=0,s=0,n=0;return t.length>0&&(i=t[0]),t.length>1&&(s=t[1]),t.length>2&&(n=t[2]),Q.create(i,s,n,e)}return Q.create(t.x,t.y,j.hasZ(t)?t.z:0,e)}static createFromPacked(t,e,i){const s=3*e;if(s>=0&&s+2<t.length)return Q.create(t[s],t[s+1],t[s+2],i)}static createFromPackedXYZW(t,e,i){const s=4*e;if(s>=0&&s+3<t.length){const e=t[s+3];if(!K.isSmallMetricDistance(e)){const n=1/e;return Q.create(n*t[s],n*t[s+1],n*t[s+2],i)}}}static createArrayFromPackedXYZ(t){const e=[];for(let i=0;i+2<t.length;i+=3)e.push(new Q(t[i],t[i+1],t[i+2]));return e}static createZero(t){return Q.create(0,0,0,t)}crossProductToPoints(t,e,i){return $.createCrossProduct(t.x-this.x,t.y-this.y,t.z-this.z,e.x-this.x,e.y-this.y,e.z-this.z,i)}crossProductToPointsMagnitude(t,e){return K.crossProductMagnitude(t.x-this.x,t.y-this.y,t.z-this.z,e.x-this.x,e.y-this.y,e.z-this.z)}tripleProductToPoints(t,e,i){return K.tripleProduct(t.x-this.x,t.y-this.y,t.z-this.z,e.x-this.x,e.y-this.y,e.z-this.z,i.x-this.x,i.y-this.y,i.z-this.z)}crossProductToPointsXY(t,e){return K.crossProductXYXY(t.x-this.x,t.y-this.y,e.x-this.x,e.y-this.y)}interpolate(t,e,i){if(t<=.5)return Q.create(this.x+t*(e.x-this.x),this.y+t*(e.y-this.y),this.z+t*(e.z-this.z),i);const s=t-1;return Q.create(e.x+s*(e.x-this.x),e.y+s*(e.y-this.y),e.z+s*(e.z-this.z),i)}interpolateXYZ(t,e,i,s,n){return Q.create(K.interpolate(this.x,t,s.x),K.interpolate(this.y,e,s.y),K.interpolate(this.z,i,s.z),n)}interpolatePerpendicularXY(t,e,i,s){s=s||new Q;const n=e.minus(this);return this.interpolate(t,e,s),s.x-=i*n.y,s.y+=i*n.x,s}minus(t,e){return Q.create(this.x-t.x,this.y-t.y,this.z-t.z,e)}plus(t,e){return Q.create(this.x+t.x,this.y+t.y,this.z+t.z,e)}plusXYZ(t=0,e=0,i=0,s){return Q.create(this.x+t,this.y+e,this.z+i,s)}plusScaled(t,e,i){return Q.create(this.x+t.x*e,this.y+t.y*e,this.z+t.z*e,i)}plus2Scaled(t,e,i,s,n){return Q.create(this.x+t.x*e+i.x*s,this.y+t.y*e+i.y*s,this.z+t.z*e+i.z*s,n)}plus3Scaled(t,e,i,s,n,r,o){return Q.create(this.x+t.x*e+i.x*s+n.x*r,this.y+t.y*e+i.y*s+n.y*r,this.z+t.z*e+i.z*s+n.z*r,o)}static createScale(t,e,i){return Q.create(t.x*e,t.y*e,t.z*e,i)}static createAdd2Scaled(t,e,i,s,n){return Q.create(t.x*e+i.x*s,t.y*e+i.y*s,t.z*e+i.z*s,n)}static createAdd3Scaled(t,e,i,s,n,r,o){return Q.create(t.x*e+i.x*s+n.x*r,t.y*e+i.y*s+n.y*r,t.z*e+i.z*s+n.z*r,o)}dotVectorsToTargets(t,e){return(t.x-this.x)*(e.x-this.x)+(t.y-this.y)*(e.y-this.y)+(t.z-this.z)*(e.z-this.z)}fractionOfProjectionToLine(t,e,i=0){const s=t.distanceSquared(e);return s<K.smallMetricDistanceSquared?i:t.dotVectorsToTargets(e,this)/s}}class $ extends j{constructor(t=0,e=0,i=0){super(t,e,i)}static createArrayFromPackedXYZ(t){const e=[];for(let i=0;i+2<t.length;i+=3)e.push(new $(t[i],t[i+1],t[i+2]));return e}clone(t){return $.create(this.x,this.y,this.z,t)}static create(t=0,e=0,i=0,s){return s?(s.x=t,s.y=e,s.z=i,s):new $(t,e,i)}static createCrossProduct(t,e,i,s,n,r,o){return $.create(e*r-i*n,i*s-t*r,t*n-e*s,o)}addCrossProductToTargetsInPlace(t,e,i,s,n,r,o,a,c){const h=s-t,l=n-e,d=r-i,u=o-t,f=a-e,g=c-i;this.x+=l*g-d*f,this.y+=d*u-h*g,this.z+=h*f-l*u}static createCrossProductToPoints(t,e,i,s){return $.createCrossProduct(e.x-t.x,e.y-t.y,e.z-t.z,i.x-t.x,i.y-t.y,i.z-t.z,s)}static createUnitCrossProductToPoints(t,e,i,s){return $.createCrossProduct(e.x-t.x,e.y-t.y,e.z-t.z,i.x-t.x,i.y-t.y,i.z-t.z,s).normalize()}static createPolar(t,e,i){return $.create(t*e.cos(),t*e.sin(),i)}static createSpherical(t,e,i){const s=i.cos();return $.create(s*t*e.cos(),s*t*e.sin(),t*i.sin())}static fromJSON(t){const e=new $;return e.setFromJSON(t),e}static createFrom(t,e){if(t instanceof Float64Array){let i=0,s=0,n=0;return t.length>0&&(i=t[0]),t.length>1&&(s=t[1]),t.length>2&&(n=t[2]),$.create(i,s,n,e)}return Array.isArray(t)?$.create(t[0],t[1],t.length>2?t[2]:0):$.create(t.x,t.y,j.hasZ(t)?t.z:0,e)}static createStartEnd(t,e,i){const s=j.accessZ(t,0),n=j.accessZ(e,0)-s;return i?(i.set(e.x-t.x,e.y-t.y,n),i):new $(e.x-t.x,e.y-t.y,n)}static createStartEndXYZXYZ(t,e,i,s,n,r,o){return this.create(s-t,n-e,r-i,o)}static createRotateVectorAroundVector(t,e,i){const s=e.normalize();if(s){const e=s.crossProduct(t);let n,r;return i?(n=i.cos(),r=i.sin()):(n=0,r=1),$.createAdd3Scaled(t,n,e,r,s,s.dotProduct(t)*(1-n))}}setStartEnd(t,e){this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z}static createZero(t){return $.create(0,0,0,t)}static unitX(t=1){return new $(t,0,0)}static unitY(t=1){return new $(0,t,0)}static unitZ(t=1){return new $(0,0,t)}safeDivideOrNull(t,e){if(0!==t)return this.scale(1/t,e)}normalizeWithLength(t){const e=this.magnitude(),i=K.correctSmallFraction(e);return t=t||new $,{v:this.safeDivideOrNull(i,t),mag:e}}normalize(t){return this.normalizeWithLength(t).v}normalizeInPlace(){return void 0!==this.normalizeWithLength(this).v}static createNormalized(t=0,e=0,i=0,s){if(void 0===s?s=$.create(t,e,i):s.set(t,e,i),s.normalizeInPlace())return s}static createNormalizedStartEnd(t,e,i){if((i=$.createStartEnd(t,e,i)).normalizeInPlace())return i}fractionOfProjectionToVector(t,e=0){const i=t.magnitudeSquared();return i<K.smallMetricDistanceSquared?e:this.dotProduct(t)/i}negate(t){return(t=t||new $).x=-this.x,t.y=-this.y,t.z=-this.z,t}rotate90CCWXY(t){t=t||new $;const e=this.x,i=this.y;return t.x=-i,t.y=e,t.z=this.z,t}rotate90CWXY(t){t=t||new $;const e=this.x,i=this.y;return t.x=i,t.y=-e,t.z=this.z,t}unitPerpendicularXY(t){t=t||new $;const e=this.x,i=this.y;t.x=-i,t.y=e,t.z=0;const s=e*e+i*i;if(0!==s){const e=1/Math.sqrt(s);t.x*=e,t.y*=e}return t}rotateXY(t,e){const i=t.sin(),s=t.cos(),n=this.x,r=this.y;return(e=e||new $).x=n*s-r*i,e.y=n*i+r*s,e.z=this.z,e}rotate90Towards(t,e){const i=this.crossProduct(t).normalize();return i?i.crossProduct(this,e):void 0}rotate90Around(t,e){const i=t.normalize();return i?i.crossProduct(this).plusScaled(i,i.dotProduct(this),e):void 0}interpolate(t,e,i){if(i=i||new $,t<=.5)i.x=this.x+t*(e.x-this.x),i.y=this.y+t*(e.y-this.y),i.z=this.z+t*(e.z-this.z);else{const s=t-1;i.x=e.x+s*(e.x-this.x),i.y=e.y+s*(e.y-this.y),i.z=e.z+s*(e.z-this.z)}return i}plus(t,e){return(e=e||new $).x=this.x+t.x,e.y=this.y+t.y,e.z=this.z+t.z,e}minus(t,e){return(e=e||new $).x=this.x-t.x,e.y=this.y-t.y,e.z=this.z-t.z,e}plusScaled(t,e,i){return(i=i||new $).x=this.x+t.x*e,i.y=this.y+t.y*e,i.z=this.z+t.z*e,i}plus2Scaled(t,e,i,s,n){return(n=n||new $).x=this.x+t.x*e+i.x*s,n.y=this.y+t.y*e+i.y*s,n.z=this.z+t.z*e+i.z*s,n}plus3Scaled(t,e,i,s,n,r,o){return(o=o||new $).x=this.x+t.x*e+i.x*s+n.x*r,o.y=this.y+t.y*e+i.y*s+n.y*r,o.z=this.z+t.z*e+i.z*s+n.z*r,o}static createAdd2Scaled(t,e,i,s,n){return $.create(t.x*e+i.x*s,t.y*e+i.y*s,t.z*e+i.z*s,n)}static createAdd2ScaledXYZ(t,e,i,s,n,r,o,a,c){return $.create(t*s+n*a,e*s+r*a,i*s+o*a,c)}static createAdd3Scaled(t,e,i,s,n,r,o){return $.create(t.x*e+i.x*s+n.x*r,t.y*e+i.y*s+n.y*r,t.z*e+i.z*s+n.z*r,o)}scale(t,e){return(e=e||new $).x=this.x*t,e.y=this.y*t,e.z=this.z*t,e}scaleToLength(t,e){const i=K.correctSmallFraction(this.magnitude());if(0!==i)return this.scale(t/i,e)}unitCrossProduct(t,e){return this.crossProduct(t,e).normalize(e)}unitCrossProductWithDefault(t,e,i,s,n){const r=this.crossProduct(t,n).normalize(n);return void 0===r?$.create(e,i,s,n):r}normalizeWithDefault(t,e,i,s){return this.normalize(s)||((s=$.create(t,e,i,s)).normalizeInPlace()?s:$.create(1,0,0,s))}tryNormalizeInPlace(t=K.smallFraction){const e=this.magnitude();return!(e<t||0===e||(this.scaleInPlace(1/e),0))}sizedCrossProduct(t,e,i){if((i=this.crossProduct(t,i)).tryNormalizeInPlace())return i.scaleInPlace(e),i}crossProductMagnitudeSquared(t){const e=this.y*t.z-this.z*t.y,i=this.z*t.x-this.x*t.z,s=this.x*t.y-this.y*t.x;return e*e+i*i+s*s}crossProductMagnitude(t){return Math.sqrt(this.crossProductMagnitudeSquared(t))}dotProduct(t){return this.x*t.x+this.y*t.y+this.z*t.z}static dotProductAsXYAndZ(t,e){return t.x*e.x+t.y*e.y+t.z*e.z}dotProductStartEnd(t,e){return this.x*(e.x-t.x)+this.y*(e.y-t.y)+this.z*(e.z-t.z)}dotProductStart3dEnd4d(t,e){const i=e.w;return this.x*(e.x-t.x*i)+this.y*(e.y-t.y*i)+this.z*(e.z-t.z*i)}crossProductStartEnd(t,e,i){return $.createCrossProduct(this.x,this.y,this.z,e.x-t.x,e.y-t.y,e.z-t.z,i)}crossProductStartEndXY(t,e){return K.crossProductXYXY(this.x,this.y,e.x-t.x,e.y-t.y)}dotProductStartEndXYZ(t,e,i,s){return this.x*(e-t.x)+this.y*(i-t.y)+this.z*(s-t.z)}dotProductStartEndXY(t,e){return this.x*(e.x-t.x)+this.y*(e.y-t.y)}dotProductStartEndXYZW(t,e,i,s,n){if(K.isSmallMetricDistance(n))return 0;const r=1/n;return this.x*(r*e-t.x)+this.y*(r*i-t.y)+this.z*(r*s-t.z)}dotProductXY(t){return this.x*t.x+this.y*t.y}dotProductXYZ(t,e,i=0){return this.x*t+this.y*e+this.z*i}tripleProduct(t,e){return K.tripleProduct(this.x,this.y,this.z,t.x,t.y,t.z,e.x,e.y,e.z)}crossProductXY(t){return this.x*t.y-this.y*t.x}crossProduct(t,e){return $.createCrossProduct(this.x,this.y,this.z,t.x,t.y,t.z,e)}crossProductXYZ(t,e,i,s){return $.createCrossProduct(this.x,this.y,this.z,t,e,i,s)}radiansTo(t){return Math.atan2(this.crossProductMagnitude(t),this.dotProduct(t))}angleTo(t){return W.createRadians(this.radiansTo(t))}angleFromPerpendicular(t){return W.createAtan2(this.dotProduct(t),this.crossProductMagnitude(t))}angleToXY(t){return W.createAtan2(this.crossProductXY(t),this.dotProductXY(t))}signedRadiansTo(t,e){const i=this.crossProduct(t),s=Math.atan2(i.magnitude(),this.dotProduct(t));return e.dotProduct(i)<0?-s:s}signedAngleTo(t,e){return W.createRadians(this.signedRadiansTo(t,e))}planarRadiansTo(t,e){const i=e.dotProduct(e);if(0===i)return 0;const s=1/i,n=this.plusScaled(e,-this.dotProduct(e)*s),r=t.plusScaled(e,-t.dotProduct(e)*s);return n.signedRadiansTo(r,e)}planarAngleTo(t,e){return W.createRadians(this.planarRadiansTo(t,e))}smallerUnorientedRadiansTo(t){const e=this.dotProduct(t),i=this.crossProductMagnitude(t);return Math.atan2(Math.abs(i),Math.abs(e))}smallerUnorientedAngleTo(t){return W.createRadians(this.smallerUnorientedRadiansTo(t))}isParallelTo(t,e=!1,i=!1,s){const n=s?.radianSquaredTol??K.smallAngleRadiansSquared,r=s?.distanceSquaredTol??K.smallMetricDistanceSquared,o=this.magnitudeSquared(),a=t.magnitudeSquared();return o<r||a<r?i:!(this.dotProduct(t)<0&&!e)&&this.crossProductMagnitudeSquared(t)<=n*o*a}isPerpendicularTo(t,e=!1,i){const s=i?.radianSquaredTol??K.smallAngleRadiansSquared,n=i?.distanceSquaredTol??K.smallMetricDistanceSquared,r=this.magnitudeSquared(),o=t.magnitudeSquared();if(r<n||o<n)return e;const a=this.dotProduct(t);return a*a<=s*r*o}}class tt{isPointInPlane(t,e=K.smallMetricDistance){return Math.abs(this.altitude(t))<=e}classifyAltitude(t,e=K.smallMetricDistance){return K.split3Way01(this.altitude(t),e)}classifyAltitudeXYZ(t,e,i,s=K.smallMetricDistance){return K.split3Way01(this.altitudeXYZ(t,e,i),s)}getUnitNormal(t){return $.createNormalized(this.normalX(),this.normalY(),this.normalZ(),t)}getAnyPointOnPlane(t){return this.projectPointToPlane(Q.create(0,0,0),t)}}class et{constructor(t){this._curIndex=-1,this._collection=t}next(){return++this._curIndex>=this._collection.length?{done:!0}:{value:this._collection.getPoint3dAtUncheckedPointIndex(this._curIndex),done:!1}}[Symbol.iterator](){return this}}class it{vectorIndexXYAndZ(t,e,i){const s=this.vectorXYAndZIndex(e,t,i);return s?.negate(s)}dotProductIndexIndexIndex(t,e,i){if(t<0||t>=this.length||e<0||e>=this.length||i<0||i>=this.length)return;const s=this.getXAtUncheckedPointIndex(t),n=this.getYAtUncheckedPointIndex(t),r=this.getZAtUncheckedPointIndex(t);return(this.getXAtUncheckedPointIndex(e)-s)*(this.getXAtUncheckedPointIndex(i)-s)+(this.getYAtUncheckedPointIndex(e)-n)*(this.getYAtUncheckedPointIndex(i)-n)+(this.getZAtUncheckedPointIndex(e)-r)*(this.getZAtUncheckedPointIndex(i)-r)}dotProductIndexIndexXYAndZ(t,e,i){if(t<0||t>=this.length||e<0||e>=this.length)return;const s=this.getXAtUncheckedPointIndex(t),n=this.getYAtUncheckedPointIndex(t),r=this.getZAtUncheckedPointIndex(t);return(this.getXAtUncheckedPointIndex(e)-s)*(i.x-s)+(this.getYAtUncheckedPointIndex(e)-n)*(i.y-n)+(this.getZAtUncheckedPointIndex(e)-r)*(i.z-r)}crossProductIndexIndexXYAndZ(t,e,i,s){if(t<0||t>=this.length||e<0||e>=this.length)return;const n=this.getXAtUncheckedPointIndex(t),r=this.getYAtUncheckedPointIndex(t),o=this.getZAtUncheckedPointIndex(t);return $.createCrossProduct(this.getXAtUncheckedPointIndex(e)-n,this.getYAtUncheckedPointIndex(e)-r,this.getZAtUncheckedPointIndex(e)-o,i.x-n,i.y-r,i.z-o,s)}distanceSquaredIndexXYAndZ(t,e){if(!(t<0||t>=this.length))return K.hypotenuseSquaredXYZ(e.x-this.getXAtUncheckedPointIndex(t),e.y-this.getYAtUncheckedPointIndex(t),e.z-this.getZAtUncheckedPointIndex(t))}cyclicIndex(t){return t%this.length}getRange(){const t=ut.createNull(),e=this.length,i=Q.create();for(let s=0;s<e;s++)this.getPoint3dAtUncheckedPointIndex(s,i),t.extendPoint(i);return t}findOrderedDuplicates(t=K.smallMetricDistance){const e=t*t,i=[];if(this.length>1)for(let t=0;t<this.length-1;){let s=t+1;for(;s<this.length;++s){const n=this.distanceSquaredIndexIndex(t,s);if(!(void 0!==n&&n<e))break;i.push(s)}t=s}return i}linearCombination(t,e){const i=Math.min(this.length,t.length),s=e instanceof $?$.createZero(e):Q.createZero(e);for(let e=0;e<i;++e)s.x+=t[e]*this.getXAtUncheckedPointIndex(e),s.y+=t[e]*this.getYAtUncheckedPointIndex(e),s.z+=t[e]*this.getZAtUncheckedPointIndex(e);return s}interpolateIndexIndex(t,e,i,s){if(!(t<0||t>=this.length||i<0||i>=this.length))return Q.create(K.interpolate(this.getXAtUncheckedPointIndex(t),e,this.getXAtUncheckedPointIndex(i)),K.interpolate(this.getYAtUncheckedPointIndex(t),e,this.getYAtUncheckedPointIndex(i)),K.interpolate(this.getZAtUncheckedPointIndex(t),e,this.getZAtUncheckedPointIndex(i)),s)}get points(){return new et(this)}getArray(){const t=[];for(const e of this.points)t.push(e);return t}front(t){if(0!==this.length)return this.getPoint3dAtUncheckedPointIndex(0,t)}back(t){if(0!==this.length)return this.getPoint3dAtUncheckedPointIndex(this.length-1,t)}}class st extends it{}class nt extends st{constructor(t=8,e){super(),this._data=new Float64Array(3*t),this._xyzInUse=0,this._xyzCapacity=t,this._growthFactor=void 0!==e&&e>=1?e:1.5}copyData(t,e,i){let s=void 0!==i?3*i:0;if(s<0&&(s=0),s>=this._data.length)return{count:0,offset:0};let n=void 0!==e?3*e:t.length;return n>0&&(n>t.length&&(n=t.length),s+n>this._data.length&&(n=this._data.length-s),n%3!=0&&(n-=n%3)),n<=0?{count:0,offset:0}:(n===t.length?this._data.set(t,s):t instanceof Float64Array?this._data.set(t.subarray(0,n),s):this._data.set(t.slice(0,n),s),{count:n/3,offset:s/3})}get length(){return this._xyzInUse}set length(t){this.resize(t,!0)}get float64Length(){return 3*this._xyzInUse}float64Data(){return this._data}ensureCapacity(t,e=!0){if(t>this._xyzCapacity){e&&(t*=this._growthFactor);const i=this._data;this._data=new Float64Array(3*t),this.copyData(i,this._xyzInUse),this._xyzCapacity=t}}resize(t,e){t>=0&&t<this._xyzInUse?this._xyzInUse=t:t>this._xyzInUse&&(this.ensureCapacity(t,!1),e&&this._data.fill(0,3*this._xyzInUse),this._xyzInUse=t)}clone(t){return t?(t.length!==this.length&&t.clear(),t.resize(this.length)):t=new nt(this.length),t.copyData(this._data,this.length),t._xyzInUse=this.length,t}static create(t,e){if(e)e.clear();else{const i="number"==typeof t[0]?t.length/3:t.length;e=new nt(i)}return e.pushFrom(t),e}static createArrayOfGrowableXYZArray(t){const e=new at;return lt.streamXYZ(t,e),e.claimArrayOfGrowableXYZArray()}push(t){this.pushXYZ(t.x,t.y,t.z)}pushAll(t){this.ensureCapacity(this._xyzInUse+t.length,!1);for(const e of t)this.push(e)}pushFrom(t){if(t instanceof Q)this.pushXYZ(t.x,t.y,t.z);else if(t instanceof nt)this.pushFromGrowableXYZArray(t);else if(t instanceof H)this.pushXYZ(t.x,t.y,0);else if(K.isNumberArray(t,4)||t instanceof Float64Array){const e=Math.trunc(t.length/3);this.ensureCapacity(this._xyzInUse+e,!1),this.copyData(t,e,this._xyzInUse),this._xyzInUse+=e}else if(K.isNumberArray(t,3))this.pushXYZ(t[0],t[1],t[2]);else if(K.isNumberArray(t,2))this.pushXYZ(t[0],t[1],0);else if(Array.isArray(t))for(const e of t)this.pushFrom(e);else if(Q.isXYAndZ(t))this.pushXYZ(t.x,t.y,t.z);else if(Q.isXAndY(t))this.pushXYZ(t.x,t.y,0);else if(t instanceof it){const e=t.length;this.ensureCapacity(this._xyzInUse+e,!1);for(let i=0;i<e;i++)this.pushXYZ(t.getXAtUncheckedPointIndex(i),t.getYAtUncheckedPointIndex(i),t.getZAtUncheckedPointIndex(i))}}pushWrap(t){if(this._xyzInUse>=t){this.ensureCapacity(this._xyzInUse+t,!1);for(let e=0;e<t;e++){const t=3*e;this.pushXYZ(this._data[t],this._data[t+1],this._data[t+2])}}}pushXYZ(t,e,i){this.ensureCapacity(this._xyzInUse+1);const s=3*this._xyzInUse;this._data[s]=t,this._data[s+1]=e,this._data[s+2]=i,this._xyzInUse++}shiftForward(t){if(t<=0)return;this.ensureCapacity(this._xyzInUse+t);const e=3*t,i=3*this._xyzInUse;this._data.copyWithin(e,0,i),this._xyzInUse+=t}pushFrontXYZ(t,e,i){this.shiftForward(1),this._data[0]=t,this._data[1]=e,this._data[2]=i}pushFront(t){this.pushFrontXYZ(t.x,t.y,t.z)}moveIndexToIndex(t,e){if(this.isIndexValid(t)&&this.isIndexValid(e)){let i=3*t,s=3*e;this._data[s++]=this._data[i++],this._data[s++]=this._data[i++],this._data[s]=this._data[i]}}pop(){this._xyzInUse>0&&this._xyzInUse--}isIndexValid(t){return!(t>=this._xyzInUse||t<0)}clear(){this._xyzInUse=0}getPoint3dAtUncheckedPointIndex(t,e){const i=3*t;return Q.create(this._data[i],this._data[i+1],this._data[i+2],e)}getPoint2dAtUncheckedPointIndex(t,e){const i=3*t;return H.create(this._data[i],this._data[i+1],e)}getPoint3dAtCheckedPointIndex(t,e){if(this.isIndexValid(t)){const i=3*t;return Q.create(this._data[i],this._data[i+1],this._data[i+2],e)}}getXAtUncheckedPointIndex(t){const e=3*t;return this._data[e]}getYAtUncheckedPointIndex(t){const e=3*t;return this._data[e+1]}getZAtUncheckedPointIndex(t){const e=3*t;return this._data[e+2]}getPoint2dAtCheckedPointIndex(t,e){if(this.isIndexValid(t)){const i=3*t;return H.create(this._data[i],this._data[i+1],e)}}getVector3dAtCheckedVectorIndex(t,e){if(this.isIndexValid(t)){const i=3*t;return $.create(this._data[i],this._data[i+1],this._data[i+2],e)}}transferFromGrowableXYZArray(t,e,i){if(this.isIndexValid(t)&&e.isIndexValid(i)){const s=3*t,n=3*i;return this._data[s]=e._data[n],this._data[s+1]=e._data[n+1],this._data[s+2]=e._data[n+2],!0}return!1}pushFromGrowableXYZArray(t,e){if(void 0===e){const e=t.length;return this.ensureCapacity(this.length+e,!1),this.copyData(t._data,e,this.length),this._xyzInUse+=e,e}if(t.isIndexValid(e)){const i=3*e;return this.pushXYZ(t._data[i],t._data[i+1],t._data[i+2]),1}return 0}setAtCheckedPointIndex(t,e){if(!this.isIndexValid(t))return!1;let i=3*t;return this._data[i++]=e.x,this._data[i++]=e.y,this._data[i]=e.z,!0}setXYZAtCheckedPointIndex(t,e,i,s){if(!this.isIndexValid(t))return!1;let n=3*t;return this._data[n++]=e,this._data[n++]=i,this._data[n]=s,!0}getPoint3dArray(){const t=3*this._xyzInUse,e=[],i=this._data;for(let s=0;s<t;s+=3)e.push(Q.create(i[s],i[s+1],i[s+2]));return e}static multiplyTransformInPlace(t,e){if(Array.isArray(e))for(const i of e)i.multiplyTransformInPlace(t);else e.multiplyTransformInPlace(t)}multiplyTransformInPlace(t){const e=this._data,i=this.float64Length,s=t.matrix.coffs,n=t.origin,r=n.x,o=n.y,a=n.z;let c=0,h=0,l=0;for(let t=0;t+2<=i;t+=3)c=e[t],h=e[t+1],l=e[t+2],e[t]=s[0]*c+s[1]*h+s[2]*l+r,e[t+1]=s[3]*c+s[4]*h+s[5]*l+o,e[t+2]=s[6]*c+s[7]*h+s[8]*l+a}reverseInPlace(){const t=this.length;let e,i,s;const n=this._data;for(let r=0,o=t-1;r<o;r++,o--)e=3*r,i=3*o,s=n[e],n[e]=n[i],n[i]=s,e++,i++,s=n[e],n[e]=n[i],n[i]=s,e++,i++,s=n[e],n[e]=n[i],n[i]=s}multiplyMatrix3dInPlace(t){const e=this._data,i=this.float64Length,s=t.coffs;let n=0,r=0,o=0;for(let t=0;t+2<=i;t+=3)n=e[t],r=e[t+1],o=e[t+2],e[t]=s[0]*n+s[1]*r+s[2]*o,e[t+1]=s[3]*n+s[4]*r+s[5]*o,e[t+2]=s[6]*n+s[7]*r+s[8]*o}multiplyAndRenormalizeMatrix3dInverseTransposeInPlace(t){const e=this._data,i=this.float64Length;if(!t.computeCachedInverse(!0))return!1;const s=t.inverseCoffs,n=K.smallFloatingPoint;let r,o,a,c,h,l=0,d=0,u=0,f=0;for(let t=0;t+2<=i;t+=3)l=e[t],d=e[t+1],u=e[t+2],r=s[0]*l+s[3]*d+s[6]*u,o=s[1]*l+s[4]*d+s[7]*u,a=s[2]*l+s[5]*d+s[8]*u,h=r*r+o*o+a*a,h<n?(r=l,o=d,a=u,f++):Math.abs(h-1)>n&&(c=1/Math.sqrt(h),r*=c,o*=c,a*=c),e[t]=r,e[t+1]=o,e[t+2]=a;return 0===f}multiplyMatrix4dAndQuietRenormalizeMatrix4d(t){const e=this._data,i=this.float64Length,s=Q.create();for(let n=0;n+2<=i;n+=3)t.multiplyXYZWQuietRenormalize(e[n],e[n+1],e[n+2],1,s),e[n]=s.x,e[n+1]=s.y,e[n+2]=s.z}tryTransformInverseInPlace(t){const e=this._data,i=this.float64Length,s=t.matrix;s.computeCachedInverse(!0);const n=s.inverseCoffs;if(!n)return!1;const r=t.origin,o=r.x,a=r.y,c=r.z;let h=0,l=0,d=0;for(let t=0;t+2<i;t+=3)h=e[t]-o,l=e[t+1]-a,d=e[t+2]-c,e[t]=n[0]*h+n[1]*l+n[2]*d,e[t+1]=n[3]*h+n[4]*l+n[5]*d,e[t+2]=n[6]*h+n[7]*l+n[8]*d;return!0}extendRange(t,e){const i=this.float64Length,s=this._data;if(e)for(let n=0;n+2<i;n+=3)t.extendTransformedXYZ(e,s[n],s[n+1],s[n+2]);else for(let e=0;e+2<i;e+=3)t.extendXYZ(s[e],s[e+1],s[e+2])}getRange(t){const e=ut.createNull();return this.extendRange(e,t),e}setRange(t,e){t.setNull(),this.extendRange(t,e)}sumLengths(){let t=0;const e=3*(this._xyzInUse-1),i=this._data;for(let s=0;s<e;s+=3)t+=K.hypotenuseXYZ(i[s+3]-i[s],i[s+4]-i[s+1],i[s+5]-i[s+2]);return t}scaleInPlace(t){if(this._data){const e=this.float64Length;for(let i=0;i<e;i++)this._data[i]=this._data[i]*t}}isCloseToPlane(t,e=K.smallMetricDistance){const i=3*this._xyzInUse,s=this._data;for(let n=0;n<i;n+=3)if(Math.abs(t.altitudeXYZ(s[n],s[n+1],s[n+2]))>e)return!1;return!0}forceClosure(t=K.smallMetricDistance){const e=this.distanceIndexIndex(0,this.length-1);if(void 0===e);else if(e>t)this.pushXYZ(this._data[0],this._data[1],this._data[2]);else if(e>0){const t=this._data.length-3;for(let e=0;e<3;e++)this._data[t+e]=this._data[e]}}interpolate(t,e,i,s){if(this.isIndexValid(t)&&this.isIndexValid(i)){const n=1-e,r=this._data;return t*=3,i*=3,Q.create(n*r[t]+e*r[i],n*r[t+1]+e*r[i+1],n*r[t+2]+e*r[i+2],s)}}pushInterpolatedFromGrowableXYZArray(t,e,i,s){if(t.isIndexValid(e)&&t.isIndexValid(s)){const n=1-i,r=t._data;e*=3,s*=3,this.pushXYZ(n*r[e]+i*r[s],n*r[e+1]+i*r[s+1],n*r[e+2]+i*r[s+2])}}areaXY(){let t=0;const e=3*this._xyzInUse;if(e>6){const i=this._data[e-3],s=this._data[e-2];let n=this._data[0]-i,r=this._data[1]-s,o=0,a=0;for(let c=3;c<e;c+=3,n=o,r=a)o=this._data[c]-i,a=this._data[c+1]-s,t+=K.crossProductXYXY(n,r,o,a)}return.5*t}vectorIndexIndex(t,e,i){if(!this.isIndexValid(t)||!this.isIndexValid(e))return;const s=this._data;return t*=3,e*=3,$.create(s[e]-s[t],s[e+1]-s[t+1],s[e+2]-s[t+2],i)}vectorXYAndZIndex(t,e,i){if(this.isIndexValid(e)){const s=this._data;return e*=3,$.create(s[e]-t.x,s[e+1]-t.y,s[e+2]-t.z,i)}}crossProductIndexIndexIndex(t,e,i,s){if(this.isIndexValid(t)&&this.isIndexValid(e)&&this.isIndexValid(i)){const n=3*t,r=3*e,o=3*i,a=this._data;return K.crossProductXYZXYZ(a[r]-a[n],a[r+1]-a[n+1],a[r+2]-a[n+2],a[o]-a[n],a[o+1]-a[n+1],a[o+2]-a[n+2],s)}}evaluateUncheckedIndexDotProductXYZ(t,e,i,s){const n=3*t,r=this._data;return r[n]*e+r[n+1]*i+r[n+2]*s}evaluateUncheckedIndexPlaneAltitude(t,e){const i=3*t,s=this._data;return e.altitudeXYZ(s[i],s[i+1],s[i+2])}accumulateCrossProductIndexIndexIndex(t,e,i,s){if(this.isIndexValid(t)&&this.isIndexValid(e)&&this.isIndexValid(i)){const n=3*t,r=3*e,o=3*i,a=this._data;s.addCrossProductToTargetsInPlace(a[n],a[n+1],a[n+2],a[r],a[r+1],a[r+2],a[o],a[o+1],a[o+2])}}accumulateScaledXYZ(t,e,i){if(this.isIndexValid(t)){const s=3*t,n=this._data;i.x+=e*n[s],i.y+=e*n[s+1],i.z+=e*n[s+2]}}crossProductXYAndZIndexIndex(t,e,i,s){if(this.isIndexValid(e)&&this.isIndexValid(i)){const n=3*e,r=3*i,o=this._data;return K.crossProductXYZXYZ(o[n]-t.x,o[n+1]-t.y,o[n+2]-t.z,o[r]-t.x,o[r+1]-t.y,o[r+2]-t.z,s)}}distanceIndexToPoint(t,e){if(this.isIndexValid(t)){const i=3*t;return K.hypotenuseXYZ(e.x-this._data[i],e.y-this._data[i+1],e.z-this._data[i+2])}}distanceSquaredIndexIndex(t,e){if(this.isIndexValid(t)&&this.isIndexValid(e)){const i=3*t,s=3*e;return K.hypotenuseSquaredXYZ(this._data[s]-this._data[i],this._data[s+1]-this._data[i+1],this._data[s+2]-this._data[i+2])}}distanceIndexIndex(t,e){if(this.isIndexValid(t)&&this.isIndexValid(e)){const i=3*t,s=3*e;return K.hypotenuseXYZ(this._data[s]-this._data[i],this._data[s+1]-this._data[i+1],this._data[s+2]-this._data[i+2])}}static distanceBetweenPointsIn2Arrays(t,e,i,s){if(t.isIndexValid(e)&&i.isIndexValid(s)){const n=3*e,r=3*s;return K.hypotenuseXYZ(i._data[r]-t._data[n],i._data[r+1]-t._data[n+1],i._data[r+2]-t._data[n+2])}}static isAlmostEqual(t,e){if(t&&e){if(t.length!==e.length)return!1;for(let i=0;i<t.length;i++)if(!t.getPoint3dAtUncheckedPointIndex(i).isAlmostEqual(e.getPoint3dAtUncheckedPointIndex(i)))return!1;return!0}return!t&&!e}sortIndicesLexical(){const t=this._xyzInUse,e=new Uint32Array(t);for(let i=0;i<t;i++)e[i]=i;return e.sort(((t,e)=>this.compareLexicalBlock(t,e))),e}compareLexicalBlock(t,e){let i=0,s=0;for(let n=0;n<3;n++){if(i=this._data[3*t+n],s=this._data[3*e+n],i>s)return 1;if(i<s)return-1}return t-e}component(t,e){return this._data[3*t+e]}addSteppedPoints(t,e,i,s){const n=t._data;let r=3*e;const o=3*t.length;let a=0;for(this.ensureCapacity(this._xyzInUse+s,!1);r>=0&&r+2<o&&a<s;)this.pushXYZ(n[r],n[r+1],n[r+2]),r+=3*i,a++}static distanceRangeBetweenCorrespondingPoints(t,e){const i=t._data,s=e._data,n=Math.min(t.length,e.length);let r,o=0;const a=ft.createNull();for(;o<n;)r=3*o,a.extendX(K.hypotenuseXYZ(i[r]-s[r],i[r+1]-s[r+1],i[r+2]-s[r+2])),o++;return a}static removeClosure(t,e=K.smallMetricDistance){for(;t.length>1&&t.distanceIndexIndex(0,t.length-1)<e;)t.pop()}fillLocalXYTriangleFrame(t,e,i,s){if(this.isIndexValid(t)&&this.isIndexValid(e)&&this.isIndexValid(i)){let n=3*t;const r=this._data,o=r[n++],a=r[n++],c=r[n++];n=3*e;const h=r[n++]-o,l=r[n++]-a,d=r[n++]-c;n=3*i;const u=r[n++]-o,f=r[n++]-a,g=r[n++]-c;return(s=pt.createRowValues(h,u,0,o,l,f,0,a,d,g,1,c,s)).computeCachedInverse()?s:void 0}}mapComponent(t,e){const i=this._data.length;let s;for(let n=0;n+2<i;n+=3)s=e(this._data[n],this._data[n+1],this._data[n+2]),this._data[n+t]=s}}class rt{startChain(t,e){}handleXYZ(t,e,i){}endChain(t,e){}}class ot extends rt{handleXYZ(t,e,i){void 0!==this._x0&&this.handleXYZXYZ(this._x0,this._y0,this._z0,t,e,i),this._x0=t,this._y0=e,this._z0=i}startChain(t,e){this._x0=this._y0=this._z0=void 0}handleXYZXYZ(t,e,i,s,n,r){}}class at extends rt{startChain(t,e){this._currentData=void 0}handleXYZ(t,e,i){this._currentData||(this._currentData=new nt),this._currentData.pushXYZ(t,e,i)}endChain(t,e){void 0!==this._currentData&&(void 0===this._pointArrays&&(this._pointArrays=[]),this._pointArrays.push(this._currentData),this._currentData=void 0)}claimArrayOfGrowableXYZArray(){const t=this._pointArrays;return this._pointArrays=void 0,t}}class ct extends rt{constructor(){super(...arguments),this._range=ut.createNull()}handleXYZ(t,e,i){this._range||(this._range=ut.createNull()),this._range.extendXYZ(t,e,i)}claimResult(){const t=this._range;return this._range=void 0,t||ut.createNull()}}class ht{constructor(t){this._xyzFunction=t,this._resultStack=[],this._resultStack.push([])}startChain(t,e){this._resultStack.push([])}handleXYZ(t,e,i){this._resultStack[this._resultStack.length-1].push(this._xyzFunction(t,e,i))}endChain(t,e){const i=this._resultStack[this._resultStack.length-1];this._resultStack.pop(),this._resultStack[this._resultStack.length-1].push(i)}claimResult(){const t=this._resultStack[0];return 1===t.length?t[0]:t}}class lt{static streamXYZ(t,e){let i=0;if(Array.isArray(t))if(t.length>0&&Q.isAnyImmediatePointType(t[0])){e.startChain(t,!0);for(const s of t){const t=Q.accessX(s),n=Q.accessY(s),r=Q.accessZ(s,0);void 0!==t&&void 0!==n&&e.handleXYZ(t,n,r),i++}e.endChain(t,!0)}else{e.startChain(t,!1);for(const s of t)i+=this.streamXYZ(s,e);e.endChain(t,!1)}else if(t instanceof it){e.startChain(t,!0);const s=lt._workPoint=Q.create(0,0,0,lt._workPoint);for(let n=0;n<t.length;n++)t.getPoint3dAtCheckedPointIndex(n,s),i++,e.handleXYZ(s.x,s.y,s.z);e.endChain(t,!0)}return i}}class dt{static npcScaleFactor(t,e){return e<=t?0:1/(e-t)}static isExtremeValue(t){return Math.abs(t)>=dt._EXTREME_POSITIVE}static isExtremePoint3d(t){return dt.isExtremeValue(t.x)||dt.isExtremeValue(t.y)||dt.isExtremeValue(t.z)}static isExtremePoint2d(t){return dt.isExtremeValue(t.x)||dt.isExtremeValue(t.y)}static rangeToRangeAbsoluteDistance(t,e,i,s){return e<t||s<i?dt._EXTREME_POSITIVE:s<t?t-s:s<=e||i<=e?0:i-e}static coordinateToRangeAbsoluteDistance(t,e,i){return i<e?dt._EXTREME_POSITIVE:t<e?e-t:t>i?t-i:0}static multiplyIfPositive(t,e,i=0){return t>0?e*t:i}}dt._EXTREME_POSITIVE=1e200,dt._EXTREME_NEGATIVE=-1e200;class ut extends dt{setNull(){this.low.x=dt._EXTREME_POSITIVE,this.low.y=dt._EXTREME_POSITIVE,this.low.z=dt._EXTREME_POSITIVE,this.high.x=dt._EXTREME_NEGATIVE,this.high.y=dt._EXTREME_NEGATIVE,this.high.z=dt._EXTREME_NEGATIVE}freeze(){return this.low.freeze(),this.high.freeze(),Object.freeze(this)}static toFloat64Array(t){return Float64Array.of(t.low.x,t.low.y,t.low.z,t.high.x,t.high.y,t.high.z)}toFloat64Array(){return ut.toFloat64Array(this)}static fromFloat64Array(t){if(6!==t.length)throw new Error("invalid array");return new this(t[0],t[1],t[2],t[3],t[4],t[5])}static fromArrayBuffer(t){return this.fromFloat64Array(new Float64Array(t))}constructor(t=dt._EXTREME_POSITIVE,e=dt._EXTREME_POSITIVE,i=dt._EXTREME_POSITIVE,s=dt._EXTREME_NEGATIVE,n=dt._EXTREME_NEGATIVE,r=dt._EXTREME_NEGATIVE){super(),this.low=Q.create(t,e,i),this.high=Q.create(s,n,r)}isAlmostEqual(t,e){return this.low.isAlmostEqual(t.low,e)&&this.high.isAlmostEqual(t.high,e)||this.isNull&&t.isNull}setFrom(t){this.low.setFrom(t.low),this.high.setFrom(t.high)}static createFrom(t,e){return e?(e.setFrom(t),e):this.createXYZXYZOrCorrectToNull(t.low.x,t.low.y,t.low.z,t.high.x,t.high.y,t.high.z,e)}setFromJSON(t){if(!t)return;if(this.setNull(),Array.isArray(t)){const e=Q.create();for(const i of t)e.setFromJSON(i),this.extendPoint(e);return}const e=Q.fromJSON(t.low),i=Q.fromJSON(t.high);dt.isExtremePoint3d(e)||dt.isExtremePoint3d(i)||(this.extendPoint(e),this.extendPoint(i))}toJSON(){return{low:this.low.toJSON(),high:this.high.toJSON()}}static fromJSON(t){const e=new this;return e.setFromJSON(t),e}setDirect(t,e,i,s,n,r,o){this.low.x=t,this.low.y=e,this.low.z=i,this.high.x=s,this.high.y=n,this.high.z=r,o&&(this.low.x>this.high.x||this.low.y>this.high.y||this.low.z>this.high.z)&&this.setNull()}clone(t){return(t=t||new this.constructor).setDirect(this.low.x,this.low.y,this.low.z,this.high.x,this.high.y,this.high.z,!1),t}cloneTranslated(t,e){return e=e||new this.constructor,this.isNull||e.setDirect(this.low.x+t.x,this.low.y+t.y,this.low.z+t.z,this.high.x+t.x,this.high.y+t.y,this.high.z+t.z,!1),e}static createNull(t){return(t=t||new this).setNull(),t}extend(...t){let e;for(e of t)this.extendPoint(e)}static create(...t){const e=ut.createNull();let i;for(i of t)e.extendPoint(i);return e}static createFromVariantData(t){const e=new ct;return lt.streamXYZ(t,e),e.claimResult()}static createTransformed(t,...e){const i=this.createNull();let s;for(s of e)i.extendTransformedXYZ(t,s.x,s.y,s.z);return i}static createTransformedArray(t,e){const i=this.createNull();return i.extendArray(e,t),i}static createInverseTransformedArray(t,e){const i=this.createNull();return i.extendInverseTransformedArray(e,t),i}setXYZ(t,e,i){this.low.x=this.high.x=t,this.low.y=this.high.y=e,this.low.z=this.high.z=i}static createXYZ(t,e,i,s){return(s=s||new this).setDirect(t,e,i,t,e,i,!1),s}static createXYZXYZ(t,e,i,s,n,r,o){return(o=o||new this).setDirect(Math.min(t,s),Math.min(e,n),Math.min(i,r),Math.max(t,s),Math.max(e,n),Math.max(i,r),!1),o}static createXYZXYZOrCorrectToNull(t,e,i,s,n,r,o){return o=o||new this,t>s||e>n||i>r?this.createNull(o):(o.setDirect(Math.min(t,s),Math.min(e,n),Math.min(i,r),Math.max(t,s),Math.max(e,n),Math.max(i,r),!0),o)}static createRange2d(t,e=0,i){const s=i||new this;return s.setNull(),s.extendXYZ(t.low.x,t.low.y,e),s.extendXYZ(t.high.x,t.high.y,e),s}static createArray(t,e){let i;for(i of((e=e||new this).setNull(),t))e.extendPoint(i);return e}extendArray(t,e){if(Array.isArray(t))if(e)for(const i of t)this.extendTransformedXYZ(e,i.x,i.y,i.z);else for(const e of t)this.extendXYZ(e.x,e.y,e.z);else if(e)for(let i=0;i<t.length;i++)this.extendTransformedXYZ(e,t.getXAtUncheckedPointIndex(i),t.getYAtUncheckedPointIndex(i),t.getZAtUncheckedPointIndex(i));else for(let e=0;e<t.length;e++)this.extendXYZ(t.getXAtUncheckedPointIndex(e),t.getYAtUncheckedPointIndex(e),t.getZAtUncheckedPointIndex(e))}extendInverseTransformedArray(t,e){if(Array.isArray(t))for(const i of t)this.extendInverseTransformedXYZ(e,i.x,i.y,i.z);else for(let i=0;i<t.length;i++)this.extendInverseTransformedXYZ(e,t.getXAtUncheckedPointIndex(i),t.getYAtUncheckedPointIndex(i),t.getZAtUncheckedPointIndex(i))}extendTransformedXYZ(t,e,i,s){const n=t.origin,r=t.matrix.coffs;this.extendXYZ(n.x+r[0]*e+r[1]*i+r[2]*s,n.y+r[3]*e+r[4]*i+r[5]*s,n.z+r[6]*e+r[7]*i+r[8]*s)}extendTransformedXYZW(t,e,i,s,n){const r=t.origin,o=t.matrix.coffs;this.extendXYZW(r.x*n+o[0]*e+o[1]*i+o[2]*s,r.y*n+o[3]*e+o[4]*i+o[5]*s,r.z*n+o[6]*e+o[7]*i+o[8]*s,n)}extendInverseTransformedXYZ(t,e,i,s){const n=t.origin;if(!t.matrix.computeCachedInverse(!0))return!1;const r=t.matrix.inverseCoffs,o=e-n.x,a=i-n.y,c=s-n.z;return this.extendXYZ(r[0]*o+r[1]*a+r[2]*c,r[3]*o+r[4]*a+r[5]*c,r[6]*o+r[7]*a+r[8]*c),!0}extendTransformTransformedXYZ(t,e,i,s,n){const r=e.origin,o=e.matrix.coffs;this.extendTransformedXYZ(t,r.x+o[0]*i+o[1]*s+o[2]*n,r.y+o[3]*i+o[4]*s+o[5]*n,r.z+o[6]*i+o[7]*s+o[8]*n)}get isNull(){return this.high.x<this.low.x||this.high.y<this.low.y||this.high.z<this.low.z}static isNull(t){return t.high.x<t.low.x||t.high.y<t.low.y||t.high.z<t.low.z}get isSinglePoint(){return this.high.x===this.low.x&&this.high.y===this.low.y&&this.high.z===this.low.z}get center(){return this.low.interpolate(.5,this.high)}get xLow(){return this.low.x}get yLow(){return this.low.y}get zLow(){return this.low.z}get xHigh(){return this.high.x}get yHigh(){return this.high.y}get zHigh(){return this.high.z}xLength(){const t=this.high.x-this.low.x;return t>0?t:0}yLength(){const t=this.high.y-this.low.y;return t>0?t:0}zLength(){const t=this.high.z-this.low.z;return t>0?t:0}maxLength(){return Math.max(this.xLength(),this.yLength(),this.zLength())}diagonal(t){return this.low.vectorTo(this.high,t)}diagonalFractionToPoint(t,e){return this.low.interpolate(t,this.high,e)}fractionToPoint(t,e,i=0,s){return this.low.interpolateXYZ(t,e,i,this.high,s)}localXYZToWorld(t,e,i,s){if(!this.isNull)return this.low.interpolateXYZ(t,e,i,this.high,s)}localToWorld(t,e){return this.localXYZToWorld(t.x,t.y,t.z,e)}localToWorldArrayInPlace(t){if(this.isNull)return!1;for(const e of t)this.low.interpolateXYZ(e.x,e.y,e.z,this.high,e);return!1}worldToLocal(t,e){const i=dt.npcScaleFactor(this.low.x,this.high.x),s=dt.npcScaleFactor(this.low.y,this.high.y),n=dt.npcScaleFactor(this.low.z,this.high.z);if(0!==i&&0!==s&&0!==n)return Q.create((t.x-this.low.x)*i,(t.y-this.low.y)*s,(t.z-this.low.z)*n,e)}worldToLocalArrayInPlace(t){const e=dt.npcScaleFactor(this.low.x,this.high.x),i=dt.npcScaleFactor(this.low.y,this.high.y),s=dt.npcScaleFactor(this.low.z,this.high.z);if(0===e||0===i||0===s)return!1;for(const n of t)Q.create((n.x-this.low.x)*e,(n.y-this.low.y)*i,(n.z-this.low.z)*s,n);return!0}corners(t){return void 0!==t&&t.length>=8?(t[0].set(this.low.x,this.low.y,this.low.z),t[1].set(this.high.x,this.low.y,this.low.z),t[2].set(this.low.x,this.high.y,this.low.z),t[3].set(this.high.x,this.high.y,this.low.z),t[4].set(this.low.x,this.low.y,this.high.z),t[5].set(this.high.x,this.low.y,this.high.z),t[6].set(this.low.x,this.high.y,this.high.z),t[7].set(this.high.x,this.high.y,this.high.z),t.length=8,t):[Q.create(this.low.x,this.low.y,this.low.z),Q.create(this.high.x,this.low.y,this.low.z),Q.create(this.low.x,this.high.y,this.low.z),Q.create(this.high.x,this.high.y,this.low.z),Q.create(this.low.x,this.low.y,this.high.z),Q.create(this.high.x,this.low.y,this.high.z),Q.create(this.low.x,this.high.y,this.high.z),Q.create(this.high.x,this.high.y,this.high.z)]}static faceCornerIndices(t){return 0===t?[0,4,6,2]:1===t?[1,3,7,5]:2===t?[0,1,5,4]:3===t?[3,2,6,7]:4===t?[0,2,3,1]:[4,5,7,6]}rectangleXY(t=0,e=!0,i=!0){if(this.isNull)return;const s=[this.fractionToPoint(0,0,t),this.fractionToPoint(1,0,t),this.fractionToPoint(1,1,t),this.fractionToPoint(0,1,t)];return i&&s.push(s[0].clone()),e||s.reverse(),s}maxAbs(){return this.isNull?0:Math.max(this.low.maxAbs(),this.high.maxAbs())}get isAlmostZeroX(){return K.isSmallMetricDistance(this.xLength())}get isAlmostZeroY(){return K.isSmallMetricDistance(this.yLength())}get isAlmostZeroZ(){return K.isSmallMetricDistance(this.zLength())}containsXYZ(t,e,i){return t>=this.low.x&&e>=this.low.y&&i>=this.low.z&&t<=this.high.x&&e<=this.high.y&&i<=this.high.z}containsXY(t,e){return t>=this.low.x&&e>=this.low.y&&t<=this.high.x&&e<=this.high.y}containsPoint(t){return this.containsXYZ(t.x,t.y,t.z)}containsPointXY(t){return t.x>=this.low.x&&t.y>=this.low.y&&t.x<=this.high.x&&t.y<=this.high.y}containsRange(t){return t.low.x>=this.low.x&&t.low.y>=this.low.y&&t.low.z>=this.low.z&&t.high.x<=this.high.x&&t.high.y<=this.high.y&&t.high.z<=this.high.z}intersectsRange(t){return!(this.low.x>t.high.x||this.low.y>t.high.y||this.low.z>t.high.z||t.low.x>this.high.x||t.low.y>this.high.y||t.low.z>this.high.z)}intersectsRangeXY(t){return!(this.low.x>t.high.x||this.low.y>t.high.y||t.low.x>this.high.x||t.low.y>this.high.y)}distanceToPoint(t){return this.isNull?dt._EXTREME_POSITIVE:Math.min(K.hypotenuseXYZ(dt.coordinateToRangeAbsoluteDistance(t.x,this.low.x,this.high.x),dt.coordinateToRangeAbsoluteDistance(t.y,this.low.y,this.high.y),dt.coordinateToRangeAbsoluteDistance(t.z,this.low.z,this.high.z)),dt._EXTREME_POSITIVE)}distanceToRange(t){return Math.min(K.hypotenuseXYZ(dt.rangeToRangeAbsoluteDistance(this.low.x,this.high.x,t.low.x,t.high.x),dt.rangeToRangeAbsoluteDistance(this.low.y,this.high.y,t.low.y,t.high.y),dt.rangeToRangeAbsoluteDistance(this.low.z,this.high.z,t.low.z,t.high.z)),dt._EXTREME_POSITIVE)}extendXYZ(t,e,i){t<this.low.x&&(this.low.x=t),t>this.high.x&&(this.high.x=t),e<this.low.y&&(this.low.y=e),e>this.high.y&&(this.high.y=e),i<this.low.z&&(this.low.z=i),i>this.high.z&&(this.high.z=i)}extendInterpolated(t,e,i){if(e<.5)this.extendXYZ(t.x+e*(i.x-t.x),t.y+e*(i.y-t.y),t.z+e*(i.z-t.z));else{const s=1-e;this.extendXYZ(i.x+s*(t.x-i.x),i.y+s*(t.y-i.y),i.z+s*(t.z-i.z))}}extendXOnly(t){t<this.low.x&&(this.low.x=t),t>this.high.x&&(this.high.x=t)}extendYOnly(t){t<this.low.y&&(this.low.y=t),t>this.high.y&&(this.high.y=t)}extendZOnly(t){t<this.low.z&&(this.low.z=t),t>this.high.z&&(this.high.z=t)}extendSingleAxis(t,e){e===m.X&&this.extendXOnly(t),e===m.Y&&this.extendYOnly(t),e===m.Z&&this.extendZOnly(t)}extendXYZW(t,e,i,s){K.isSmallMetricDistance(s)||this.extendXYZ(t/s,e/s,i/s)}extendPoint(t,e){e?this.extendTransformedXYZ(e,t.x,t.y,t.z):this.extendXYZ(t.x,t.y,t.z)}extendTransformedPoint(t,e){this.extendTransformedXYZ(t,e.x,e.y,e.z)}extendRange(t){ut.isNull(t)||(this.extendXYZ(t.low.x,t.low.y,t.low.z),this.extendXYZ(t.high.x,t.high.y,t.high.z))}extendWhenLarger(t,e){ut.isNull(t)||ut.isNull(this)||(this.high.x+=dt.multiplyIfPositive(this.high.x-t.high.x,e),this.high.y+=dt.multiplyIfPositive(this.high.y-t.high.y,e),this.high.z+=dt.multiplyIfPositive(this.high.z-t.high.z,e),this.low.x-=dt.multiplyIfPositive(t.low.x-this.low.x,e),this.low.y-=dt.multiplyIfPositive(t.low.y-this.low.y,e),this.low.z-=dt.multiplyIfPositive(t.low.z-this.low.z,e))}intersect(t,e){return this.intersectsRange(t)?ut.createXYZXYZOrCorrectToNull(Math.max(this.low.x,t.low.x),Math.max(this.low.y,t.low.y),Math.max(this.low.z,t.low.z),Math.min(this.high.x,t.high.x),Math.min(this.high.y,t.high.y),Math.min(this.high.z,t.high.z),e):ut.createNull(e)}union(t,e){return this.isNull?t.clone(e):t.isNull?this.clone(e):ut.createXYZXYZOrCorrectToNull(Math.min(this.low.x,t.low.x),Math.min(this.low.y,t.low.y),Math.min(this.low.z,t.low.z),Math.max(this.high.x,t.high.x),Math.max(this.high.y,t.high.y),Math.max(this.high.z,t.high.z),e)}scaleAboutCenterInPlace(t){if(!this.isNull){t=Math.abs(t);const e=.5*(this.low.x+this.high.x),i=.5*(this.low.y+this.high.y),s=.5*(this.low.z+this.high.z);this.high.x=K.interpolate(e,t,this.high.x),this.high.y=K.interpolate(i,t,this.high.y),this.high.z=K.interpolate(s,t,this.high.z),this.low.x=K.interpolate(e,t,this.low.x),this.low.y=K.interpolate(i,t,this.low.y),this.low.z=K.interpolate(s,t,this.low.z)}}expandInPlace(t){this.setDirect(this.low.x-t,this.low.y-t,this.low.z-t,this.high.x+t,this.high.y+t,this.high.z+t,!0)}getLocalToWorldTransform(t){return pt.createOriginAndMatrix(Q.create(this.low.x,this.low.y,this.low.z),xt.createRowValues(this.high.x-this.low.x,0,0,0,this.high.y-this.low.y,0,0,0,this.high.z-this.low.z),t)}getNpcToWorldRangeTransform(t){const e=this.getLocalToWorldTransform(t),i=e.matrix;return 0===i.coffs[0]&&(i.coffs[0]=1),0===i.coffs[4]&&(i.coffs[4]=1),0===i.coffs[8]&&(i.coffs[8]=1),e}ensureMinLengths(t=.001){let e=(t-this.xLength())/2;e>0&&(this.low.x-=e,this.high.x+=e),e=(t-this.yLength())/2,e>0&&(this.low.y-=e,this.high.y+=e),e=(t-this.zLength())/2,e>0&&(this.low.z-=e,this.high.z+=e)}}class ft extends dt{setNull(){this.low=dt._EXTREME_POSITIVE,this.high=dt._EXTREME_NEGATIVE}setDirect(t,e,i=!1){this.low=t,this.high=e,i&&t>e&&this.setNull()}constructor(t=dt._EXTREME_POSITIVE,e=dt._EXTREME_NEGATIVE){super(),this.low=t,this.high=e,this.setDirect(t,e)}isAlmostEqual(t){return K.isSameCoordinate(this.low,t.low)&&K.isSameCoordinate(this.high,t.high)||this.isNull&&t.isNull}setFrom(t){this.low=t.low,this.high=t.high}setFromJSON(t){if(this.setNull(),Array.isArray(t)){let e;for(e of t)Number.isFinite(e)&&this.extendX(e)}else void 0!==t.low&&Number.isFinite(t.low)&&void 0!==t.high&&Number.isFinite(t.high)&&(this.extendX(t.low),this.extendX(t.high))}static fromJSON(t){const e=new this;return t&&e.setFromJSON(t),e}toJSON(){return this.isNull?new Array:[this.low,this.high]}clone(t){return(t=t||new this.constructor).setDirect(this.low,this.high),t}static createFrom(t,e){return(e=e||new this).setDirect(t.low,t.high),e}static createNull(t){return(t=t||new this).setNull(),t}cloneTranslated(t,e){return(e=e||this.clone()).isNull||(e.low+=t,e.high+=t),e}setX(t){this.low=this.high=t}static createX(t,e){return(e=e||new this).setDirect(t,t),e}setXXUnordered(t,e){t<=e?(this.low=t,this.high=e):(this.low=e,this.high=t)}get isExact01(){return 0===this.low&&1===this.high}static createXX(t,e,i){return(i=i||new this).setDirect(Math.min(t,e),Math.max(t,e)),i}static createXXOrCorrectToNull(t,e,i){return e<t?ft.createNull(i):((i=i||new this).setDirect(Math.min(t,e),Math.max(t,e)),i)}static createArray(t,e){let i;for(i of(e=e||new this,t))e.extendX(i);return e}extendArray(t){let e;for(e of t)this.extendX(e)}extendArraySubset(t,e,i){const s=e+i;for(let i=e;i<s;i++)this.extendX(t[i])}get isNull(){return this.high<this.low}get isSinglePoint(){return this.high===this.low}length(){const t=this.high-this.low;return t>0?t:0}fractionToPoint(t){return K.interpolate(this.low,t,this.high)}maxAbs(){return this.isNull?0:Math.max(Math.abs(this.low),Math.abs(this.high))}get isAlmostZeroLength(){return K.isSmallMetricDistance(this.length())}containsX(t){return t>=this.low&&t<=this.high}containsRange(t){return t.low>=this.low&&t.high<=this.high}intersectsRange(t){return!(this.low>t.high||t.low>this.high)}intersectRangeXXInPlace(t,e){e<t||e<this.low||t>this.high?this.setNull():(e<this.high&&(this.high=e),t>this.low&&(this.low=t))}distanceToRange(t){return dt.rangeToRangeAbsoluteDistance(this.low,this.high,t.low,t.high)}distanceToX(t){return this.isNull?dt._EXTREME_POSITIVE:dt.coordinateToRangeAbsoluteDistance(t,this.low,this.high)}extendX(t){t<this.low&&(this.low=t),t>this.high&&(this.high=t)}extendRange(t){t.isNull||(this.extendX(t.low),this.extendX(t.high))}extendLow(t){return!!(this.isNull||t<this.low)&&(this.low=t,!0)}extendHigh(t){return!!(this.isNull||t>this.high)&&(this.high=t,!0)}intersect(t,e){return this.intersectsRange(t)?ft.createXXOrCorrectToNull(Math.max(this.low,t.low),Math.min(this.high,t.high),e):ft.createNull(e)}union(t,e){return ft.createXX(Math.min(this.low,t.low),Math.max(this.high,t.high),e)}scaleAboutCenterInPlace(t){if(!this.isNull){t=Math.abs(t);const e=.5*(this.low+this.high);this.high=K.interpolate(e,t,this.high),this.low=K.interpolate(e,t,this.low)}}expandInPlace(t){this.setDirect(this.low-t,this.high+t,!0)}clipLinearMapToInterval(t,e,i,s){if(s<i||this.high<this.low)return!1;const n=K.conditionalDivideFraction(i-t,e),r=K.conditionalDivideFraction(s-t,e);return void 0===n||void 0===r?i<=t&&t<=s||(this.setNull(),!1):(n<r?(n>this.low&&(this.low=n),r<this.high&&(this.high=r)):(n<this.high&&(this.high=n),r>this.low&&(this.low=r)),!(this.high<this.low&&(this.setNull(),1)))}}class gt extends dt{setNull(){this.low.x=dt._EXTREME_POSITIVE,this.low.y=dt._EXTREME_POSITIVE,this.high.x=dt._EXTREME_NEGATIVE,this.high.y=dt._EXTREME_NEGATIVE}static toFloat64Array(t){return Float64Array.of(t.low.x,t.low.y,t.high.x,t.high.y)}toFloat64Array(){return gt.toFloat64Array(this)}static fromFloat64Array(t){if(4!==t.length)throw new Error("invalid array");return new this(t[0],t[1],t[2],t[3])}static fromArrayBuffer(t){return this.fromFloat64Array(new Float64Array(t))}constructor(t=gt._EXTREME_POSITIVE,e=gt._EXTREME_POSITIVE,i=gt._EXTREME_NEGATIVE,s=gt._EXTREME_NEGATIVE){super(),this.low=H.create(t,e),this.high=H.create(i,s)}isAlmostEqual(t){return this.low.isAlmostEqual(t.low)&&this.high.isAlmostEqual(t.high)||this.isNull&&t.isNull}setFrom(t){this.low.set(t.low.x,t.low.y),this.high.set(t.high.x,t.high.y)}static createFrom(t,e){return e?(e.setFrom(t),e):this.createXYXYOrCorrectToNull(t.low.x,t.low.y,t.high.x,t.high.y,e)}setFromJSON(t){if(this.setNull(),Array.isArray(t)){const e=H.create();for(const i of t)e.setFromJSON(i),this.extendPoint(e);return}const e=H.fromJSON(t.low),i=H.fromJSON(t.high);dt.isExtremePoint2d(e)||dt.isExtremePoint2d(i)||(this.extendPoint(e),this.extendPoint(i))}freeze(){return this.low.freeze(),this.high.freeze(),Object.freeze(this)}toJSON(){return this.isNull?[]:[this.low.toJSON(),this.high.toJSON()]}static fromJSON(t){const e=new this;return t&&e.setFromJSON(t),e}setDirect(t,e,i,s,n){this.low.x=t,this.low.y=e,this.high.x=i,this.high.y=s,n&&(this.low.x>this.high.x||this.low.y>this.high.y)&&this.setNull()}clone(t){return(t=t||new this.constructor).setDirect(this.low.x,this.low.y,this.high.x,this.high.y,!1),t}static createNull(t){return(t=t||new this).setNull(),t}setXY(t,e){this.low.x=this.high.x=t,this.low.y=this.high.y=e}static createXY(t,e,i){return(i=i||new this).setDirect(t,e,t,e,!1),i}static createXYXY(t,e,i,s,n){return(n=n||new this).setDirect(Math.min(t,i),Math.min(e,s),Math.max(t,i),Math.max(e,s),!1),n}static createXYXYXY(t,e,i,s,n,r,o){return(o=o||new this).setDirect(Math.min(t,i,n),Math.min(e,s,r),Math.max(t,i,n),Math.max(e,s,r),!1),o}static createXYXYOrCorrectToNull(t,e,i,s,n){return t>i||e>s?this.createNull(n):((n=n||new this).setDirect(Math.min(t,i),Math.min(e,s),Math.max(t,i),Math.max(e,s),!0),n)}static createArray(t,e){let i;for(i of(e=e||new this,t))e.extendPoint(i);return e}get isNull(){return this.high.x<this.low.x||this.high.y<this.low.y}static isNull(t){return t.high.x<t.low.x||t.high.y<t.low.y}get isSinglePoint(){return this.high.x===this.low.x&&this.high.y===this.low.y}get center(){return this.low.interpolate(.5,this.high)}get xLow(){return this.low.x}get yLow(){return this.low.y}get xHigh(){return this.high.x}get yHigh(){return this.high.y}xLength(){const t=this.high.x-this.low.x;return t>0?t:0}yLength(){const t=this.high.y-this.low.y;return t>0?t:0}diagonal(t){return this.low.vectorTo(this.high,t)}diagonalFractionToPoint(t,e){return this.low.interpolate(t,this.high,e)}fractionToPoint(t,e,i){return this.low.interpolateXY(t,e,this.high,i)}corners3d(t=!1,e=0){return t?[Q.create(this.low.x,this.low.y,e),Q.create(this.high.x,this.low.y,e),Q.create(this.high.x,this.high.y,e),Q.create(this.low.x,this.high.y,e),Q.create(this.low.x,this.low.y,e)]:[Q.create(this.low.x,this.low.y,e),Q.create(this.high.x,this.low.y,e),Q.create(this.low.x,this.high.y,e),Q.create(this.high.x,this.high.y,e)]}maxAbs(){return this.isNull?0:Math.max(this.low.maxAbs(),this.high.maxAbs())}get isAlmostZeroX(){return K.isSmallMetricDistance(this.xLength())}get isAlmostZeroY(){return K.isSmallMetricDistance(this.yLength())}containsXY(t,e){return t>=this.low.x&&e>=this.low.y&&t<=this.high.x&&e<=this.high.y}containsPoint(t){return this.containsXY(t.x,t.y)}containsRange(t){return t.low.x>=this.low.x&&t.low.y>=this.low.y&&t.high.x<=this.high.x&&t.high.y<=this.high.y}intersectsRange(t){return!(this.low.x>t.high.x||this.low.y>t.high.y||t.low.x>this.high.x||t.low.y>this.high.y)}distanceToPoint(t){return this.isNull?gt._EXTREME_POSITIVE:Math.min(K.hypotenuseXY(dt.coordinateToRangeAbsoluteDistance(t.x,this.low.x,this.high.x),dt.coordinateToRangeAbsoluteDistance(t.y,this.low.y,this.high.y)),gt._EXTREME_POSITIVE)}distanceToRange(t){return Math.min(K.hypotenuseXY(dt.rangeToRangeAbsoluteDistance(this.low.x,this.high.x,t.low.x,t.high.x),dt.rangeToRangeAbsoluteDistance(this.low.y,this.high.y,t.low.y,t.high.y)),gt._EXTREME_POSITIVE)}extendXY(t,e){t<this.low.x&&(this.low.x=t),t>this.high.x&&(this.high.x=t),e<this.low.y&&(this.low.y=e),e>this.high.y&&(this.high.y=e)}extendTransformedXY(t,e,i){const s=t.multiplyComponentXYZ(0,e,i,0),n=t.multiplyComponentXYZ(1,e,i,0);this.extendXY(s,n)}extendPoint(t){this.extendXY(t.x,t.y)}extendRange(t){gt.isNull(t)||(this.extendXY(t.low.x,t.low.y),this.extendXY(t.high.x,t.high.y))}intersect(t,e){return this.intersectsRange(t)?gt.createXYXY(Math.max(this.low.x,t.low.x),Math.max(this.low.y,t.low.y),Math.min(this.high.x,t.high.x),Math.min(this.high.y,t.high.y),e):gt.createNull(e)}union(t,e){return this.isNull?gt.createFrom(t,e):gt.isNull(t)?this.clone(e):gt.createXYXY(Math.min(this.low.x,t.low.x),Math.min(this.low.y,t.low.y),Math.max(this.high.x,t.high.x),Math.max(this.high.y,t.high.y),e)}scaleAboutCenterInPlace(t){if(!this.isNull){t=Math.abs(t);const e=.5*(this.low.x+this.high.x),i=.5*(this.low.y+this.high.y);this.high.x=K.interpolate(e,t,this.high.x),this.high.y=K.interpolate(i,t,this.high.y),this.low.x=K.interpolate(e,t,this.low.x),this.low.y=K.interpolate(i,t,this.low.y)}}expandInPlace(t){this.setDirect(this.low.x-t,this.low.y-t,this.high.x+t,this.high.y+t,!0)}worldToLocal(t,e){const i=dt.npcScaleFactor(this.low.x,this.high.x),s=dt.npcScaleFactor(this.low.y,this.high.y);if(0!==i&&0!==s)return H.create((t.x-this.low.x)*i,(t.y-this.low.y)*s,e)}}class pt{constructor(t,e){this._origin=t,this._matrix=e}static get identity(){return void 0===this._identity&&(this._identity=pt.createIdentity(),this._identity.freeze()),this._identity}freeze(){return this._origin.freeze(),this._matrix.freeze(),Object.freeze(this)}setFrom(t){this._origin.setFrom(t._origin),this._matrix.setFrom(t._matrix)}setIdentity(){this._origin.setZero(),this._matrix.setIdentity()}setFromJSON(t){if(t){if(t instanceof Object&&t.origin&&t.matrix)return this._origin.setFromJSON(t.origin),void this._matrix.setFromJSON(t.matrix);if(K.isArrayOfNumberArray(t,3,4)){const e=t;return this._matrix.setRowValues(e[0][0],e[0][1],e[0][2],e[1][0],e[1][1],e[1][2],e[2][0],e[2][1],e[2][2]),void this._origin.set(e[0][3],e[1][3],e[2][3])}if(K.isNumberArray(t,12)){const e=t;return this._matrix.setRowValues(e[0],e[1],e[2],e[4],e[5],e[6],e[8],e[9],e[10]),void this._origin.set(e[3],e[7],e[11])}}this.setIdentity()}isAlmostEqual(t){return this.origin.isAlmostEqual(t.origin)&&this.matrix.isAlmostEqual(t.matrix)}isAlmostEqualAllowZRotation(t){return this._origin.isAlmostEqual(t._origin)&&this._matrix.isAlmostEqualAllowZRotation(t._matrix)}toRows(){return[[this._matrix.coffs[0],this._matrix.coffs[1],this._matrix.coffs[2],this._origin.x],[this._matrix.coffs[3],this._matrix.coffs[4],this._matrix.coffs[5],this._origin.y],[this._matrix.coffs[6],this._matrix.coffs[7],this._matrix.coffs[8],this._origin.z]]}toJSON(){return this.toRows()}static fromJSON(t){const e=pt.createIdentity();return e.setFromJSON(t),e}clone(t){return t?(t._matrix.setFrom(this._matrix),t._origin.setFrom(this._origin),t):new pt(Q.createFrom(this._origin),this._matrix.clone())}cloneRigid(t=p.XYZ){const e=xt.createRigidFromMatrix3d(this.matrix,t);if(e)return new pt(this.origin.cloneAsPoint3d(),e)}static createRefs(t,e,i){return t||(t=Q.createZero()),i?(i._origin=t,i._matrix=e,i):new pt(t,e)}static createRowValues(t,e,i,s,n,r,o,a,c,h,l,d,u){return u?(u._origin.set(s,a,d),u._matrix.setRowValues(t,e,i,n,r,o,c,h,l),u):new pt(Q.create(s,a,d),xt.createRowValues(t,e,i,n,r,o,c,h,l))}static createZero(t){return pt.createRowValues(0,0,0,0,0,0,0,0,0,0,0,0,t)}static createTranslationXYZ(t=0,e=0,i=0,s){return pt.createRefs($.create(t,e,i),xt.createIdentity(),s)}static createTranslation(t,e){return pt.createRefs(t,xt.createIdentity(),e)}get matrix(){return this._matrix}get origin(){return this._origin}getOrigin(){return Q.createFrom(this._origin)}getTranslation(){return $.createFrom(this._origin)}getMatrix(){return this._matrix.clone()}get isIdentity(){return this._matrix.isIdentity&&this._origin.isAlmostZero}static createIdentity(t){return t?(t._origin.setZero(),t._matrix.setIdentity(),t):pt.createRefs(Q.createZero(),xt.createIdentity())}static createOriginAndMatrix(t,e,i){return i?(i._origin.setFromPoint3d(t),i._matrix.setFrom(e),i):pt.createRefs(t?t.cloneAsPoint3d():Q.createZero(),void 0===e?xt.createIdentity():e.clone(),i)}setOriginAndMatrixColumns(t,e,i,s){void 0!==t&&this._origin.setFrom(t),this._matrix.setColumns(e,i,s)}static createOriginAndMatrixColumns(t,e,i,s,n){return n?n.setOriginAndMatrixColumns(t,e,i,s):n=pt.createRefs($.createFrom(t),xt.createColumns(e,i,s)),n}static createRigidFromOriginAndColumns(t,e,i,s,n){const r=xt.createRigidFromColumns(e,i,s,n?n._matrix:void 0);if(r)return n?(n._origin.setFrom(t),n):((n=pt.createRefs(void 0,r))._origin.setFromPoint3d(t),n)}static createFixedPointAndMatrix(t,e,i){if(t){const s=xt.xyzMinusMatrixTimesXYZ(t,e,t);return pt.createRefs(s,e.clone(),i)}return pt.createRefs(void 0,e.clone())}static createMatrixPickupPutdown(t,e,i,s){const n=xt.xyzMinusMatrixTimesXYZ(i,t,e);return pt.createRefs(n,t.clone(),s)}static createScaleAboutPoint(t,e,i){const s=xt.createScale(e,e,e),n=xt.xyzMinusMatrixTimesXYZ(t,s,t);return pt.createRefs(n,s,i)}static createFlattenAlongVectorToPlane(t,e,i){const s=xt.createFlattenAlongVectorToPlane(t,i);if(void 0!==s)return pt.createFixedPointAndMatrix(e,s)}multiplyPoint2d(t,e){return xt.xyPlusMatrixTimesXY(this._origin,this._matrix,t,e)}multiplyPoint3d(t,e){return xt.xyzPlusMatrixTimesXYZ(this._origin,this._matrix,t,e)}multiplyXYAndZInPlace(t){return xt.xyzPlusMatrixTimesXYZInPlace(this._origin,this._matrix,t)}multiplyXYZ(t,e,i=0,s){return xt.xyzPlusMatrixTimesCoordinates(this._origin,this._matrix,t,e,i,s)}multiplyComponentXYZ(t,e,i,s=0){const n=this._matrix.coffs,r=3*t;return this.origin.at(t)+n[r]*e+n[r+1]*i+n[r+2]*s}multiplyComponentXYZW(t,e,i,s,n){const r=this._matrix.coffs,o=3*t;return this.origin.at(t)*n+r[o]*e+r[o+1]*i+r[o+2]*s}multiplyXYZW(t,e,i,s,n){return xt.xyzPlusMatrixTimesWeightedCoordinates(this._origin,this._matrix,t,e,i,s,n)}multiplyXYZWToFloat64Array(t,e,i,s,n){return xt.xyzPlusMatrixTimesWeightedCoordinatesToFloat64Array(this._origin,this._matrix,t,e,i,s,n)}multiplyXYZToFloat64Array(t,e,i,s){return xt.xyzPlusMatrixTimesCoordinatesToFloat64Array(this._origin,this._matrix,t,e,i,s)}multiplyTransposeXYZW(t,e,i,s,n){const r=this._matrix.coffs,o=this._origin;return Rt.create(t*r[0]+e*r[3]+i*r[6],t*r[1]+e*r[4]+i*r[7],t*r[2]+e*r[5]+i*r[8],t*o.x+e*o.y+i*o.z+s,n)}multiplyPoint3dArrayInPlace(t){let e;for(e of t)xt.xyzPlusMatrixTimesXYZ(this._origin,this._matrix,e,e)}multiplyPoint3dArrayArrayInPlace(t){for(const e of t)this.multiplyPoint3dArrayInPlace(e)}multiplyInversePoint3d(t,e){return this._matrix.multiplyInverseXYZAsPoint3d(t.x-this._origin.x,t.y-this._origin.y,t.z-this._origin.z,e)}multiplyInversePoint4d(t,e){const i=t.w;return this._matrix.multiplyInverseXYZW(t.x-i*this.origin.x,t.y-i*this.origin.y,t.z-i*this.origin.z,i,e)}multiplyInverseXYZ(t,e,i,s){return this._matrix.multiplyInverseXYZAsPoint3d(t-this._origin.x,e-this._origin.y,i-this._origin.z,s)}computeCachedInverse(t=!0){return this._matrix.computeCachedInverse(t)}static matchArrayLengths(t,e,i){const s=t.length,n=e.length;if(s>n)for(let t=n;t<s;t++)e.push(i());else n>s&&(e.length=s);return s}multiplyInversePoint3dArray(t,e){if(!this._matrix.computeCachedInverse(!0))return;const i=this.origin.x,s=this.origin.y,n=this.origin.z;if(e){const r=pt.matchArrayLengths(t,e,(()=>Q.createZero()));for(let o=0;o<r;o++)this._matrix.multiplyInverseXYZAsPoint3d(t[o].x-i,t[o].y-s,t[o].z-n,e[o]);return e}e=[];for(const r of t)e.push(this._matrix.multiplyInverseXYZAsPoint3d(r.x-i,r.y-s,r.z-n));return e}multiplyInversePoint3dArrayInPlace(t){if(!this._matrix.computeCachedInverse(!0))return!1;for(const e of t)this._matrix.multiplyInverseXYZAsPoint3d(e.x-this.origin.x,e.y-this.origin.y,e.z-this.origin.z,e);return!0}multiplyPoint2dArray(t,e){if(e){const i=pt.matchArrayLengths(t,e,(()=>H.createZero()));for(let s=0;s<i;s++)xt.xyPlusMatrixTimesXY(this._origin,this._matrix,t[s],e[s]);return e}e=[];for(const i of t)e.push(xt.xyPlusMatrixTimesXY(this._origin,this._matrix,i));return e}multiplyPoint3dArray(t,e){if(e){const i=pt.matchArrayLengths(t,e,(()=>Q.createZero()));for(let s=0;s<i;s++)xt.xyzPlusMatrixTimesXYZ(this._origin,this._matrix,t[s],e[s]);return e}e=[];for(const i of t)e.push(xt.xyzPlusMatrixTimesXYZ(this._origin,this._matrix,i));return e}multiplyVector(t,e){return this._matrix.multiplyVector(t,e)}multiplyVectorInPlace(t){this._matrix.multiplyVectorInPlace(t)}multiplyVectorXYZ(t,e,i,s){return this._matrix.multiplyXYZ(t,e,i,s)}setMultiplyTransformTransform(t,e){xt.xyzPlusMatrixTimesXYZ(t._origin,t._matrix,e._origin,this._origin),t._matrix.multiplyMatrixMatrix(e._matrix,this._matrix)}multiplyTransformTransform(t,e){return e?(e.setMultiplyTransformTransform(this,t),e):pt.createRefs(xt.xyzPlusMatrixTimesXYZ(this._origin,this._matrix,t._origin),this._matrix.multiplyMatrixMatrix(t._matrix))}multiplyTransformMatrix3d(t,e){return e?(this._matrix.multiplyMatrixMatrix(t,e._matrix),e._origin.setFrom(this._origin),e):pt.createRefs(this._origin.cloneAsPoint3d(),this._matrix.multiplyMatrixMatrix(t))}multiplyRange(t,e){if(t.isNull)return t.clone(e);const i=t.low.x,s=t.low.y,n=t.low.z,r=t.high.x,o=t.high.y,a=t.high.z;return(e=ut.createNull(e)).extendTransformedXYZ(this,i,s,n),e.extendTransformedXYZ(this,r,s,n),e.extendTransformedXYZ(this,i,o,n),e.extendTransformedXYZ(this,r,o,n),e.extendTransformedXYZ(this,i,s,a),e.extendTransformedXYZ(this,r,s,a),e.extendTransformedXYZ(this,i,o,a),e.extendTransformedXYZ(this,r,o,a),e}inverse(t){const e=this._matrix.inverse(t?t._matrix:void 0);if(e)return t?(e.multiplyXYZ(-this._origin.x,-this._origin.y,-this._origin.z,t._origin),t):pt.createRefs(e.multiplyXYZ(-this._origin.x,-this._origin.y,-this._origin.z),e)}static initFromRange(t,e,i,s){const n=e.minus(t);0===n.x&&(n.x=1),0===n.y&&(n.y=1),0===n.z&&(n.z=1);const r=new xt;if(i&&(xt.createScale(n.x,n.y,n.z,r),pt.createOriginAndMatrix(t,r,i)),s){const e=new Q(-t.x/n.x,-t.y/n.y,-t.z/n.z);xt.createScale(1/n.x,1/n.y,1/n.z,r),pt.createOriginAndMatrix(e,r,s)}}}class mt{static loadMatrix(t,e,i,s,n,r,o,a,c,h){t[0]=e,t[1]=i,t[2]=s,t[3]=n,t[4]=r,t[5]=o,t[6]=a,t[7]=c,t[8]=h}static multiplyMatrixMatrix(t,e,i){return i||(i=new Float64Array(9)),mt.loadMatrix(i,t[0]*e[0]+t[1]*e[3]+t[2]*e[6],t[0]*e[1]+t[1]*e[4]+t[2]*e[7],t[0]*e[2]+t[1]*e[5]+t[2]*e[8],t[3]*e[0]+t[4]*e[3]+t[5]*e[6],t[3]*e[1]+t[4]*e[4]+t[5]*e[7],t[3]*e[2]+t[4]*e[5]+t[5]*e[8],t[6]*e[0]+t[7]*e[3]+t[8]*e[6],t[6]*e[1]+t[7]*e[4]+t[8]*e[7],t[6]*e[2]+t[7]*e[5]+t[8]*e[8]),i}static multiplyMatrixMatrixTranspose(t,e,i){return i||(i=new Float64Array(9)),mt.loadMatrix(i,t[0]*e[0]+t[1]*e[1]+t[2]*e[2],t[0]*e[3]+t[1]*e[4]+t[2]*e[5],t[0]*e[6]+t[1]*e[7]+t[2]*e[8],t[3]*e[0]+t[4]*e[1]+t[5]*e[2],t[3]*e[3]+t[4]*e[4]+t[5]*e[5],t[3]*e[6]+t[4]*e[7]+t[5]*e[8],t[6]*e[0]+t[7]*e[1]+t[8]*e[2],t[6]*e[3]+t[7]*e[4]+t[8]*e[5],t[6]*e[6]+t[7]*e[7]+t[8]*e[8]),i}static multiplyMatrixTransposeMatrix(t,e,i){return i||(i=new Float64Array(9)),mt.loadMatrix(i,t[0]*e[0]+t[3]*e[3]+t[6]*e[6],t[0]*e[1]+t[3]*e[4]+t[6]*e[7],t[0]*e[2]+t[3]*e[5]+t[6]*e[8],t[1]*e[0]+t[4]*e[3]+t[7]*e[6],t[1]*e[1]+t[4]*e[4]+t[7]*e[7],t[1]*e[2]+t[4]*e[5]+t[7]*e[8],t[2]*e[0]+t[5]*e[3]+t[8]*e[6],t[2]*e[1]+t[5]*e[4]+t[8]*e[7],t[2]*e[2]+t[5]*e[5]+t[8]*e[8]),i}static transposeInPlace(t){let e=t[1];t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e}static copyTransposed(t,e){return e===t?mt.transposeInPlace(e):(e||(e=new Float64Array(9)),e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8]),e}static copy(t,e){return e!==t&&(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8]),e}}!function(t){t[t.unknown=0]="unknown",t[t.inverseStored=1]="inverseStored",t[t.singular=2]="singular"}(P||(P={}));class xt{static get identity(){return void 0===this._identity&&(this._identity=xt.createIdentity(),this._identity.freeze()),this._identity}freeze(){return this.computeCachedInverse(!0),Object.freeze(this)}constructor(t){this.coffs=t||new Float64Array(9),this.inverseCoffs=void 0,this.inverseState=P.unknown}toJSON(){return[[this.coffs[0],this.coffs[1],this.coffs[2]],[this.coffs[3],this.coffs[4],this.coffs[5]],[this.coffs[6],this.coffs[7],this.coffs[8]]]}setFromJSON(t){if(this.inverseCoffs=void 0,t)if(Array.isArray(t))if(K.isArrayOfNumberArray(t,3,3)){const e=t;this.setRowValues(e[0][0],e[0][1],e[0][2],e[1][0],e[1][1],e[1][2],e[2][0],e[2][1],e[2][2])}else if(9!==t.length)if(4!==t.length)this.setRowValues(0,0,0,0,0,0,0,0,0);else{const e=t;this.setRowValues(e[0],e[1],0,e[2],e[3],0,0,0,1)}else{const e=t;this.setRowValues(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8])}else t instanceof xt&&this.setFrom(t);else this.setRowValues(0,0,0,0,0,0,0,0,0)}static fromJSON(t){const e=xt.createIdentity();return e.setFromJSON(t),e}isAlmostEqual(t,e){return K.isDistanceWithinTol(this.maxDiff(t),e)}isAlmostEqualColumn(t,e,i){const s=K.maxAbsXYZ(this.coffs[t]-e.coffs[t],this.coffs[t+3]-e.coffs[t+3],this.coffs[t+6]-e.coffs[t+6]);return K.isDistanceWithinTol(s,i)}isAlmostEqualColumnXYZ(t,e,i,s,n){const r=K.maxAbsXYZ(this.coffs[t]-e,this.coffs[t+3]-i,this.coffs[t+6]-s);return K.isDistanceWithinTol(r,n)}isAlmostEqualAllowZRotation(t,e){if(this.isAlmostEqual(t,e))return!0;if(this.isAlmostEqualColumn(m.Z,t,e)){const i=W.radiansBetweenVectorsXYZ(this.coffs[0],this.coffs[3],this.coffs[6],t.coffs[0],t.coffs[3],t.coffs[6]),s=W.createRadians(i),n=this.columnX(),r=this.columnY(),o=this.columnZ();let a=$.createRotateVectorAroundVector(n,o,s);if(t.isAlmostEqualColumnXYZ(0,a.x,a.y,a.z,e))return a=$.createRotateVectorAroundVector(r,o,s),t.isAlmostEqualColumnXYZ(1,a.x,a.y,a.z,e)}return!1}isExactEqual(t){return 0===this.maxDiff(t)}get isXY(){return 0===this.coffs[2]&&0===this.coffs[5]&&0===this.coffs[6]&&0===this.coffs[7]&&1===this.coffs[8]}static _create(t){return t||new xt}static createRowValues(t,e,i,s,n,r,o,a,c,h){return(h=h||new xt).inverseState=P.unknown,h.coffs[0]=t,h.coffs[1]=e,h.coffs[2]=i,h.coffs[3]=s,h.coffs[4]=n,h.coffs[5]=r,h.coffs[6]=o,h.coffs[7]=a,h.coffs[8]=c,h}static createCapture(t,e){const i=new xt(t);return e?(i.inverseCoffs=e,i.inverseState=P.inverseStored):i.inverseState=P.unknown,i}static createColumnsInAxisOrder(t,e,i,s,n){return n||(n=new xt),t===p.YZX?n.setColumns(s,e,i):t===p.ZXY?n.setColumns(i,s,e):t===p.XZY?n.setColumns(e,s,i):t===p.YXZ?n.setColumns(i,e,s):t===p.ZYX?n.setColumns(s,i,e):n.setColumns(e,i,s),n}createInverseCoffsWithZeros(){this.inverseCoffs||(this.inverseState=P.unknown,this.inverseCoffs=new Float64Array(9))}setupInverseTranspose(){const t=this.coffs;this.inverseState=P.inverseStored,this.inverseCoffs=Float64Array.from([t[0],t[3],t[6],t[1],t[4],t[7],t[2],t[5],t[8]])}setRowValues(t,e,i,s,n,r,o,a,c){this.coffs[0]=t,this.coffs[1]=e,this.coffs[2]=i,this.coffs[3]=s,this.coffs[4]=n,this.coffs[5]=r,this.coffs[6]=o,this.coffs[7]=a,this.coffs[8]=c,this.inverseState=P.unknown}setIdentity(){this.setRowValues(1,0,0,0,1,0,0,0,1),this.setupInverseTranspose()}setZero(){this.setRowValues(0,0,0,0,0,0,0,0,0),this.inverseState=P.singular}setFrom(t){if(void 0!==t){if(t!==this){for(let e=0;e<9;e++)this.coffs[e]=t.coffs[e];if(t.inverseState===P.inverseStored&&void 0!==t.inverseCoffs){this.createInverseCoffsWithZeros();for(let e=0;e<9;e++)this.inverseCoffs[e]=t.inverseCoffs[e];this.inverseState=P.inverseStored}else t.inverseState!==P.inverseStored?this.inverseState=t.inverseState:this.inverseState=P.unknown}}else this.setIdentity()}clone(t){return(t=t||new xt).setFrom(this),t}static createZero(){const t=new xt;return t.inverseState=P.singular,t}static createIdentity(t){return(t=t||new xt).setIdentity(),t}static createScale(t,e,i,s){return s?s.setZero():s=new xt,s.coffs[0]=t,s.coffs[4]=e,s.coffs[8]=i,0===t||0===e||0===i?s.inverseState=P.singular:(s.inverseState=P.inverseStored,s.inverseCoffs=Float64Array.from([1/t,0,0,0,1/e,0,0,0,1/i])),s}static createUniformScale(t){return xt.createScale(t,t,t)}static createPerpendicularVectorFavorXYPlane(t,e){const i=t.magnitude()/64;return Math.abs(t.x)<i&&Math.abs(t.y)<i?$.createCrossProduct(t.x,t.y,t.z,0,-1,0,e):$.createCrossProduct(0,0,1,t.x,t.y,t.z,e)}static createPerpendicularVectorFavorPlaneContainingZ(t,e){return e=xt.createPerpendicularVectorFavorXYPlane(t,e),t.crossProduct(e,e)}static createShuffledColumns(t,e,i,s,n){const r=xt._create(n);return r.setColumn(K.axisOrderToAxis(s,0),t),r.setColumn(K.axisOrderToAxis(s,1),e),r.setColumn(K.axisOrderToAxis(s,2),i),r}static createRigidFromColumns(t,e,i,s){const n=t.normalize();if(n){const r=n.unitCrossProduct(e);if(r){const e=r.unitCrossProduct(t);if(e){const t=xt.createShuffledColumns(n,e,r,i,s);return t.setupInverseTranspose(),t}}}}static createRigidHeadsUp(t,e=p.ZXY,i){const s=xt.createPerpendicularVectorFavorXYPlane(t),n=xt.createRigidFromColumns(t,s,e,i);return n?(n.setupInverseTranspose(),n):xt.createIdentity(i)}static createRotationAroundVector(t,e,i){const s=e.cos(),n=e.sin(),r=1-s,o=t.normalize();if(o){const t=xt.createRowValues(o.x*o.x*r+s,o.x*o.y*r-n*o.z,o.x*o.z*r+n*o.y,o.y*o.x*r+n*o.z,o.y*o.y*r+s,o.y*o.z*r-n*o.x,o.z*o.x*r-n*o.y,o.z*o.y*r+n*o.x,o.z*o.z*r+s,i);return t.setupInverseTranspose(),t}}static createRotationAroundAxisIndex(t,e,i){const s=e.cos(),n=e.sin();let r;return r=t===m.X?xt.createRowValues(1,0,0,0,s,-n,0,n,s,i):t===m.Y?xt.createRowValues(s,0,n,0,1,0,-n,0,s,i):xt.createRowValues(s,-n,0,n,s,0,0,0,1,i),r.setupInverseTranspose(),r}applyGivensRowOp(t,e,i,s){let n=3*t,r=3*e;const o=n+3;for(;n<o;n++,r++){const t=this.coffs[n],e=this.coffs[r];this.coffs[n]=t*i+e*s,this.coffs[r]=-t*s+e*i}}applyGivensColumnOp(t,e,i,s){const n=t+9;for(;t<n;t+=3,e+=3){const n=this.coffs[t],r=this.coffs[e];this.coffs[t]=n*i+r*s,this.coffs[e]=-n*s+r*i}}static createColumns(t,e,i,s){return xt.createRowValues(t.x,e.x,i.x,t.y,e.y,i.y,t.z,e.z,i.z,s)}static createColumnsXYW(t,e,i,s,n,r,o){return xt.createRowValues(t.x,i.x,n.x,t.y,i.y,n.y,e,s,r,o)}static createViewedAxes(t,e,i=0,s=0){const n=t.crossProduct(e);if(n.normalizeInPlace()){const r=xt.createColumns(t,e,n);if(0!==i){let t=Math.sqrt(.5),e=i<0?-t:t;if(1!==Math.abs(i)){const s=W.degreesToRadians(45*i);t=Math.cos(s),e=Math.sin(s)}r.applyGivensColumnOp(2,0,t,e)}if(0!==s){const t=s*Math.atan(Math.sqrt(.5)),e=Math.cos(t),i=Math.sin(t);r.applyGivensColumnOp(1,2,e,-i)}return r}}static createStandardWorldToView(t,e=!1,i){switch(t){case x.Bottom:i=xt.createRowValues(1,0,0,0,-1,0,0,0,-1);break;case x.Left:i=xt.createRowValues(0,-1,0,0,0,1,-1,0,0);break;case x.Right:i=xt.createRowValues(0,1,0,0,0,1,1,0,0);break;case x.Front:i=xt.createRowValues(1,0,0,0,0,1,0,-1,0);break;case x.Back:i=xt.createRowValues(-1,0,0,0,0,1,0,1,0);break;case x.Iso:i=xt.createRowValues(.707106781186548,-.7071067811865476,0,.408248290463863,.408248290463863,.816496580927726,-.577350269189626,-.5773502691896257,.5773502691896257);break;case x.RightIso:i=xt.createRowValues(.707106781186548,.7071067811865476,0,-.408248290463863,.408248290463863,.816496580927726,.577350269189626,-.5773502691896257,.5773502691896257);break;case x.Top:default:i=xt.createIdentity(i)}return e&&i.transposeInPlace(),i}applySymmetricJacobi(t,e,i,s){const n=s.at(t,t),r=s.at(e,e),o=s.at(t,e);if(Math.abs(o)<K.smallFloatingPoint*(n+r))return 0;const a=W.trigValuesToHalfAngleTrigValues(n-r,2*o),c=a.c,h=a.s;return Math.abs(h)<2e-15?0:(s.applyGivensRowOp(t,e,c,h),s.applyGivensColumnOp(t,e,c,h),i.applyGivensColumnOp(t,e,c,h),Math.abs(o))}symmetricEigenvalues(t,e){const i=this.clone();t.setIdentity(),i.coffs[3]=i.coffs[1],i.coffs[6]=i.coffs[2],i.coffs[7]=i.coffs[5];const s=1e-12*this.sumSquares();for(let n=0;n<7;n++)if(this.applySymmetricJacobi(0,1,t,i)+this.applySymmetricJacobi(0,2,t,i)+this.applySymmetricJacobi(1,2,t,i)<s)return e.set(i.at(0,0),i.at(1,1),i.at(2,2)),!0;return!1}applyFastSymmetricJacobi(t,e,i,s){const n=4*t,r=4*e,o=3*t+e,a=3*e+t,c=3*t+i,h=3*i+t,l=3*e+i,d=3*i+e,u=this.coffs[n],f=this.coffs[r],g=this.coffs[o];if(Math.abs(g)<K.smallFloatingPoint*(u+f))return 0;const p=W.trigValuesToHalfAngleTrigValues(u-f,2*g),m=p.c,x=p.s,y=m*m,_=x*x,v=2*m*x;this.coffs[n]=y*u+v*g+_*f,this.coffs[r]=_*u-v*g+y*f,this.coffs[o]=0,this.coffs[a]=0;const P=this.coffs[c],I=this.coffs[l];return this.coffs[c]=m*P+x*I,this.coffs[l]=-x*P+m*I,this.coffs[h]=this.coffs[c],this.coffs[d]=this.coffs[l],s.applyGivensColumnOp(t,e,m,x),Math.abs(g)}fastSymmetricEigenvalues(t,e){const i=this.clone();t.setIdentity();const s=1e-12*this.sumSquares();for(let n=0;n<7;n++)if(i.applyFastSymmetricJacobi(0,1,2,t)+i.applyFastSymmetricJacobi(0,2,1,t)+i.applyFastSymmetricJacobi(1,2,0,t)<s)return e.set(i.at(0,0),i.at(1,1),i.at(2,2)),!0;return!1}getAxisAndAngleOfRotation(){const t=this.coffs[0]+this.coffs[4]+this.coffs[8],e=this.coffs[3]-this.coffs[1],i=this.coffs[7]-this.coffs[5],s=this.coffs[2]-this.coffs[6],n=(t-1)/2,r=K.hypotenuseXYZ(e,i,s)/2,o=n*n+r*r-1;if(Math.abs(o)>K.smallAngleRadians)return{axis:$.create(0,0,1),angle:W.createRadians(0),ok:!1};if(Math.abs(r)<K.smallAngleRadians){if(n>0)return{axis:$.create(0,0,1),angle:W.createRadians(0),ok:!0};const t=this.coffs[0],e=this.coffs[4],i=this.coffs[8];if(K.isAlmostEqualNumber(-1,e)&&K.isAlmostEqualNumber(-1,i))return{axis:$.create(1,0,0),angle:W.createDegrees(180),ok:!0};if(K.isAlmostEqualNumber(-1,t)&&K.isAlmostEqualNumber(-1,i))return{axis:$.create(0,1,0),angle:W.createDegrees(180),ok:!0};if(K.isAlmostEqualNumber(-1,t)&&K.isAlmostEqualNumber(-1,e))return{axis:$.create(0,0,1),angle:W.createDegrees(180),ok:!0};const s=xt.createIdentity(),r=$.create(0,0,0);if(this.fastSymmetricEigenvalues(s,r)){for(let t=0;t<2;t++){const e=r.at(t);if(K.isAlmostEqualNumber(1,e))return{axis:s.getColumn(t),angle:W.createDegrees(180),ok:!0}}return{axis:$.create(0,0,1),angle:W.createRadians(0),ok:!1}}return{axis:$.create(0,0,1),angle:W.createRadians(0),ok:!1}}const a=1/(2*r);return{axis:$.create(i*a,s*a,e*a),angle:W.createAtan2(r,n),ok:!0}}applyJacobiColumnRotation(t,e,i){const s=this.coffs[t]*this.coffs[t]+this.coffs[t+3]*this.coffs[t+3]+this.coffs[t+6]*this.coffs[t+6],n=this.coffs[e]*this.coffs[e]+this.coffs[e+3]*this.coffs[e+3]+this.coffs[e+6]*this.coffs[e+6],r=this.coffs[t]*this.coffs[e]+this.coffs[t+3]*this.coffs[e+3]+this.coffs[t+6]*this.coffs[e+6],o=W.trigValuesToHalfAngleTrigValues(s-n,2*r),a=o.c,c=o.s;return Math.abs(c)<2e-15?0:(this.applyGivensColumnOp(t,e,a,c),i.applyGivensRowOp(t,e,a,c),Math.abs(r))}factorPerpendicularColumns(t,e){t.setFrom(this),e.setIdentity();const i=1e-12*this.sumSquares();for(let s=0;s<7;s++)if(t.applyJacobiColumnRotation(0,1,e)+t.applyJacobiColumnRotation(0,2,e)+t.applyJacobiColumnRotation(1,2,e)<i)return!0;return!1}factorOrthogonalScaleOrthogonal(t,e,i){const s=xt.createZero();if(!this.factorPerpendicularColumns(s,i))return!1;const n=[];n.push(s.getColumn(0)),n.push(s.getColumn(1)),n.push(s.getColumn(2)),e.set(n[0].magnitude(),n[1].magnitude(),n[2].magnitude()),s.determinant()<0&&(e.z=-e.z);const r=K.smallFloatingPoint,o=Math.abs(e.x)<r,a=Math.abs(e.y)<r,c=Math.abs(e.z)<r;return o||a||c?o||a?o?t.setIdentity():t=xt.createRigidHeadsUp(n[0],p.XYZ,t):(n[0].scaleInPlace(1/e.x),n[1].scaleInPlace(1/e.y),n[2]=n[0].unitCrossProduct(n[1],n[2]),t.setColumns(n[0],n[1],n[2])):t=s.scaleColumns(1/e.x,1/e.y,1/e.z,t),!0}static createPartialRotationVectorToVector(t,e,i,s){let n=t.unitCrossProduct(i);return n?xt.createRotationAroundVector(n,W.createRadians(e*t.planarAngleTo(i,n).radians)):K.isSmallMetricDistance(t.magnitude())||K.isSmallMetricDistance(i.magnitude())?void 0:t.dotProduct(i)>0?xt.createIdentity(s):(n=xt.createPerpendicularVectorFavorPlaneContainingZ(t,n),xt.createRotationAroundVector(n,W.createRadians(e*Math.PI)))}static createRotationVectorToVector(t,e,i){return this.createPartialRotationVectorToVector(t,1,e,i)}static create90DegreeRotationAroundAxis(t){if(0===(t=K.cyclic3dAxis(t))){const t=xt.createRowValues(1,0,0,0,0,-1,0,1,0);return t.setupInverseTranspose(),t}if(1===t){const t=xt.createRowValues(0,0,1,0,1,0,-1,0,0);return t.setupInverseTranspose(),t}{const t=xt.createRowValues(0,-1,0,1,0,0,0,0,1);return t.setupInverseTranspose(),t}}columnX(t){return $.create(this.coffs[0],this.coffs[3],this.coffs[6],t)}columnY(t){return $.create(this.coffs[1],this.coffs[4],this.coffs[7],t)}columnZ(t){return $.create(this.coffs[2],this.coffs[5],this.coffs[8],t)}columnXMagnitudeSquared(){return K.hypotenuseSquaredXYZ(this.coffs[0],this.coffs[3],this.coffs[6])}columnYMagnitudeSquared(){return K.hypotenuseSquaredXYZ(this.coffs[1],this.coffs[4],this.coffs[7])}columnZMagnitudeSquared(){return K.hypotenuseSquaredXYZ(this.coffs[2],this.coffs[5],this.coffs[8])}columnXMagnitude(){return K.hypotenuseXYZ(this.coffs[0],this.coffs[3],this.coffs[6])}columnYMagnitude(){return K.hypotenuseXYZ(this.coffs[1],this.coffs[4],this.coffs[7])}columnZMagnitude(){return K.hypotenuseXYZ(this.coffs[2],this.coffs[5],this.coffs[8])}columnXYCrossProductMagnitude(){return K.crossProductMagnitude(this.coffs[0],this.coffs[3],this.coffs[6],this.coffs[1],this.coffs[4],this.coffs[7])}rowXMagnitude(){return K.hypotenuseXYZ(this.coffs[0],this.coffs[1],this.coffs[2])}rowYMagnitude(){return K.hypotenuseXYZ(this.coffs[3],this.coffs[4],this.coffs[5])}rowZMagnitude(){return K.hypotenuseXYZ(this.coffs[6],this.coffs[7],this.coffs[8])}columnXDotColumnY(){return this.coffs[0]*this.coffs[1]+this.coffs[3]*this.coffs[4]+this.coffs[6]*this.coffs[7]}columnXDotColumnZ(){return this.coffs[0]*this.coffs[2]+this.coffs[3]*this.coffs[5]+this.coffs[6]*this.coffs[8]}columnYDotColumnZ(){return this.coffs[1]*this.coffs[2]+this.coffs[4]*this.coffs[5]+this.coffs[7]*this.coffs[8]}columnDotXYZ(t,e,i,s){return this.coffs[t]*e+this.coffs[t+3]*i+this.coffs[t+6]*s}rowX(t){return $.create(this.coffs[0],this.coffs[1],this.coffs[2],t)}rowY(t){return $.create(this.coffs[3],this.coffs[4],this.coffs[5],t)}rowZ(t){return $.create(this.coffs[6],this.coffs[7],this.coffs[8],t)}dotColumnX(t){return t.x*this.coffs[0]+t.y*this.coffs[3]+t.z*this.coffs[6]}dotColumnY(t){return t.x*this.coffs[1]+t.y*this.coffs[4]+t.z*this.coffs[7]}dotColumnZ(t){return t.x*this.coffs[2]+t.y*this.coffs[5]+t.z*this.coffs[8]}dotRowX(t){return t.x*this.coffs[0]+t.y*this.coffs[1]+t.z*this.coffs[2]}dotRowY(t){return t.x*this.coffs[3]+t.y*this.coffs[4]+t.z*this.coffs[5]}dotRowZ(t){return t.x*this.coffs[6]+t.y*this.coffs[7]+t.z*this.coffs[8]}dotRowXXYZ(t,e,i){return t*this.coffs[0]+e*this.coffs[1]+i*this.coffs[2]}dotRowYXYZ(t,e,i){return t*this.coffs[3]+e*this.coffs[4]+i*this.coffs[5]}dotRowZXYZ(t,e,i){return t*this.coffs[6]+e*this.coffs[7]+i*this.coffs[8]}columnZCrossVector(t,e){return K.crossProductXYZXYZ(this.coffs[2],this.coffs[5],this.coffs[8],t.x,t.y,t.z,e)}setColumnsPoint4dXYZ(t,e,i){this.inverseState=P.unknown,this.setRowValues(t.x,e.x,i.x,t.y,e.y,i.y,t.z,e.z,i.z)}setColumn(t,e){const i=K.cyclic3dAxis(t);this.inverseState=P.unknown,e?(this.coffs[i]=e.x,this.coffs[i+3]=e.y,this.coffs[i+6]=e.z):(this.coffs[i]=0,this.coffs[i+3]=0,this.coffs[i+6]=0)}setColumns(t,e,i){this.setColumn(0,t),this.setColumn(1,e),this.setColumn(2,i)}setRow(t,e){const i=3*K.cyclic3dAxis(t);this.coffs[i]=e.x,this.coffs[i+1]=e.y,this.coffs[i+2]=e.z,this.inverseState=P.unknown}getColumn(t,e){const i=K.cyclic3dAxis(t);return $.create(this.coffs[i],this.coffs[i+3],this.coffs[i+6],e)}getRow(t,e){const i=3*K.cyclic3dAxis(t);return $.create(this.coffs[i],this.coffs[i+1],this.coffs[i+2],e)}static createRows(t,e,i,s){return xt.createRowValues(t.x,t.y,t.z,e.x,e.y,e.z,i.x,i.y,i.z,s)}static createDirectionalScale(t,e,i){const s=t.normalize();if(s){const t=s.x,n=s.y,r=s.z,o=e-1;return xt.createRowValues(1+o*t*t,o*t*n,o*t*r,o*n*t,1+o*n*n,o*n*r,o*r*t,o*r*n,1+o*r*r,i)}return xt.createUniformScale(e)}static createFlattenAlongVectorToPlane(t,e){const i=xt.createIdentity(),s=t.dotProduct(e),n=K.conditionalDivideCoordinate(1,-s);if(void 0!==n)return i.addScaledOuterProductInPlace(t,e,n),i}multiplyPoint(t,e){const i=t.x,s=t.y,n=t.z;return Q.create(this.coffs[0]*i+this.coffs[1]*s+this.coffs[2]*n,this.coffs[3]*i+this.coffs[4]*s+this.coffs[5]*n,this.coffs[6]*i+this.coffs[7]*s+this.coffs[8]*n,e)}multiplyVector(t,e){const i=t.x,s=t.y,n=t.z;return $.create(this.coffs[0]*i+this.coffs[1]*s+this.coffs[2]*n,this.coffs[3]*i+this.coffs[4]*s+this.coffs[5]*n,this.coffs[6]*i+this.coffs[7]*s+this.coffs[8]*n,e)}multiplyVectorArrayInPlace(t){for(const e of t)e.set(this.coffs[0]*e.x+this.coffs[1]*e.y+this.coffs[2]*e.z,this.coffs[3]*e.x+this.coffs[4]*e.y+this.coffs[5]*e.z,this.coffs[6]*e.x+this.coffs[7]*e.y+this.coffs[8]*e.z)}static xyzMinusMatrixTimesXYZ(t,e,i,s){const n=i.x,r=i.y,o=i.z;return Q.create(t.x-(e.coffs[0]*n+e.coffs[1]*r+e.coffs[2]*o),t.y-(e.coffs[3]*n+e.coffs[4]*r+e.coffs[5]*o),t.z-(e.coffs[6]*n+e.coffs[7]*r+e.coffs[8]*o),s)}static xyPlusMatrixTimesXY(t,e,i,s){const n=i.x,r=i.y;return H.create(t.x+e.coffs[0]*n+e.coffs[1]*r,t.y+e.coffs[3]*n+e.coffs[4]*r,s)}static xyzPlusMatrixTimesXYZ(t,e,i,s){const n=i.x,r=i.y,o=i.z;return Q.create(t.x+e.coffs[0]*n+e.coffs[1]*r+e.coffs[2]*o,t.y+e.coffs[3]*n+e.coffs[4]*r+e.coffs[5]*o,t.z+e.coffs[6]*n+e.coffs[7]*r+e.coffs[8]*o,s)}static xyzPlusMatrixTimesXYZInPlace(t,e,i){const s=i.x,n=i.y,r=i.z;i.x=t.x+e.coffs[0]*s+e.coffs[1]*n+e.coffs[2]*r,i.y=t.y+e.coffs[3]*s+e.coffs[4]*n+e.coffs[5]*r,i.z=t.z+e.coffs[6]*s+e.coffs[7]*n+e.coffs[8]*r}static xyzPlusMatrixTimesCoordinates(t,e,i,s,n,r){return Q.create(t.x+e.coffs[0]*i+e.coffs[1]*s+e.coffs[2]*n,t.y+e.coffs[3]*i+e.coffs[4]*s+e.coffs[5]*n,t.z+e.coffs[6]*i+e.coffs[7]*s+e.coffs[8]*n,r)}static xyzPlusMatrixTimesWeightedCoordinates(t,e,i,s,n,r,o){return Rt.create(e.coffs[0]*i+e.coffs[1]*s+e.coffs[2]*n+t.x*r,e.coffs[3]*i+e.coffs[4]*s+e.coffs[5]*n+t.y*r,e.coffs[6]*i+e.coffs[7]*s+e.coffs[8]*n+t.z*r,r,o)}static xyzPlusMatrixTimesWeightedCoordinatesToFloat64Array(t,e,i,s,n,r,o){return o||(o=new Float64Array(4)),o[0]=e.coffs[0]*i+e.coffs[1]*s+e.coffs[2]*n+t.x*r,o[1]=e.coffs[3]*i+e.coffs[4]*s+e.coffs[5]*n+t.y*r,o[2]=e.coffs[6]*i+e.coffs[7]*s+e.coffs[8]*n+t.z*r,o[3]=r,o}static xyzPlusMatrixTimesCoordinatesToFloat64Array(t,e,i,s,n,r){return r||(r=new Float64Array(3)),r[0]=e.coffs[0]*i+e.coffs[1]*s+e.coffs[2]*n+t.x,r[1]=e.coffs[3]*i+e.coffs[4]*s+e.coffs[5]*n+t.y,r[2]=e.coffs[6]*i+e.coffs[7]*s+e.coffs[8]*n+t.z,r}multiplyTransposeVector(t,e){e=e||new $;const i=t.x,s=t.y,n=t.z;return e.x=this.coffs[0]*i+this.coffs[3]*s+this.coffs[6]*n,e.y=this.coffs[1]*i+this.coffs[4]*s+this.coffs[7]*n,e.z=this.coffs[2]*i+this.coffs[5]*s+this.coffs[8]*n,e}multiplyXYZ(t,e,i,s){return(s=s||new $).x=this.coffs[0]*t+this.coffs[1]*e+this.coffs[2]*i,s.y=this.coffs[3]*t+this.coffs[4]*e+this.coffs[5]*i,s.z=this.coffs[6]*t+this.coffs[7]*e+this.coffs[8]*i,s}multiplyXYZtoXYZ(t,e){const i=t.x,s=t.y,n=t.z;return e.x=this.coffs[0]*i+this.coffs[1]*s+this.coffs[2]*n,e.y=this.coffs[3]*i+this.coffs[4]*s+this.coffs[5]*n,e.z=this.coffs[6]*i+this.coffs[7]*s+this.coffs[8]*n,e}multiplyXY(t,e,i){return(i=i||new $).x=this.coffs[0]*t+this.coffs[1]*e,i.y=this.coffs[3]*t+this.coffs[4]*e,i.z=this.coffs[6]*t+this.coffs[7]*e,i}originPlusMatrixTimesXY(t,e,i,s){return Q.create(t.x+this.coffs[0]*e+this.coffs[1]*i,t.y+this.coffs[3]*e+this.coffs[4]*i,t.z+this.coffs[6]*e+this.coffs[7]*i,s)}multiplyVectorInPlace(t){const e=t.x,i=t.y,s=t.z;t.x=this.coffs[0]*e+this.coffs[1]*i+this.coffs[2]*s,t.y=this.coffs[3]*e+this.coffs[4]*i+this.coffs[5]*s,t.z=this.coffs[6]*e+this.coffs[7]*i+this.coffs[8]*s}multiplyTransposeVectorInPlace(t){const e=t.x,i=t.y,s=t.z;t.x=this.coffs[0]*e+this.coffs[3]*i+this.coffs[6]*s,t.y=this.coffs[1]*e+this.coffs[4]*i+this.coffs[7]*s,t.z=this.coffs[2]*e+this.coffs[5]*i+this.coffs[8]*s}multiplyTransposeXYZ(t,e,i,s){return(s=s||new $).x=this.coffs[0]*t+this.coffs[3]*e+this.coffs[6]*i,s.y=this.coffs[1]*t+this.coffs[4]*e+this.coffs[7]*i,s.z=this.coffs[2]*t+this.coffs[5]*e+this.coffs[8]*i,s}multiplyInverse(t,e){if(this.computeCachedInverse(!0),this.inverseCoffs){const i=t.x,s=t.y,n=t.z;return $.create(this.inverseCoffs[0]*i+this.inverseCoffs[1]*s+this.inverseCoffs[2]*n,this.inverseCoffs[3]*i+this.inverseCoffs[4]*s+this.inverseCoffs[5]*n,this.inverseCoffs[6]*i+this.inverseCoffs[7]*s+this.inverseCoffs[8]*n,e)}}multiplyInverseTranspose(t,e){if(this.computeCachedInverse(!0),this.inverseCoffs){const i=t.x,s=t.y,n=t.z;return $.create(this.inverseCoffs[0]*i+this.inverseCoffs[3]*s+this.inverseCoffs[6]*n,this.inverseCoffs[1]*i+this.inverseCoffs[4]*s+this.inverseCoffs[7]*n,this.inverseCoffs[2]*i+this.inverseCoffs[5]*s+this.inverseCoffs[8]*n,e)}}multiplyInverseXYZAsVector3d(t,e,i,s){if(this.computeCachedInverse(!0),this.inverseCoffs)return $.create(this.inverseCoffs[0]*t+this.inverseCoffs[1]*e+this.inverseCoffs[2]*i,this.inverseCoffs[3]*t+this.inverseCoffs[4]*e+this.inverseCoffs[5]*i,this.inverseCoffs[6]*t+this.inverseCoffs[7]*e+this.inverseCoffs[8]*i,s)}multiplyInverseXYZW(t,e,i,s,n){if(this.computeCachedInverse(!0),this.inverseCoffs)return Rt.create(this.inverseCoffs[0]*t+this.inverseCoffs[1]*e+this.inverseCoffs[2]*i,this.inverseCoffs[3]*t+this.inverseCoffs[4]*e+this.inverseCoffs[5]*i,this.inverseCoffs[6]*t+this.inverseCoffs[7]*e+this.inverseCoffs[8]*i,s,n)}multiplyInverseXYZAsPoint3d(t,e,i,s){if(this.computeCachedInverse(!0),this.inverseCoffs)return Q.create(this.inverseCoffs[0]*t+this.inverseCoffs[1]*e+this.inverseCoffs[2]*i,this.inverseCoffs[3]*t+this.inverseCoffs[4]*e+this.inverseCoffs[5]*i,this.inverseCoffs[6]*t+this.inverseCoffs[7]*e+this.inverseCoffs[8]*i,s)}finishInverseCoffs(t,e,i){e&&i?(this.createInverseCoffsWithZeros(),this.inverseState=P.inverseStored,t(e,i,this.inverseCoffs)):this.inverseState=P.unknown}multiplyMatrixMatrix(t,e){return e=e||new xt,mt.multiplyMatrixMatrix(this.coffs,t.coffs,e.coffs),this.inverseState===P.inverseStored&&t.inverseState===P.inverseStored?e.finishInverseCoffs(((t,e,i)=>mt.multiplyMatrixMatrix(t,e,i)),t.inverseCoffs,this.inverseCoffs):this.inverseState===P.singular||t.inverseState===P.singular?e.inverseState=P.singular:e.inverseState=P.unknown,e}multiplyMatrixMatrixInverse(t,e){if(t.computeCachedInverse(!0))return e=e||new xt,mt.multiplyMatrixMatrix(this.coffs,t.inverseCoffs,xt._productBuffer),this.inverseState===P.inverseStored?e.finishInverseCoffs(((t,e,i)=>mt.multiplyMatrixMatrix(t,e,i)),t.coffs,this.inverseCoffs):e.inverseState=P.unknown,mt.copy(xt._productBuffer,e.coffs),e}multiplyMatrixInverseMatrix(t,e){if(this.computeCachedInverse(!0))return e=e||new xt,mt.multiplyMatrixMatrix(this.inverseCoffs,t.coffs,xt._productBuffer),t.inverseState===P.inverseStored?e.finishInverseCoffs(((t,e,i)=>mt.multiplyMatrixMatrix(t,e,i)),t.inverseCoffs,this.coffs):e.inverseState=P.unknown,mt.copy(xt._productBuffer,e.coffs),e}multiplyMatrixMatrixTranspose(t,e){return e=e||new xt,mt.multiplyMatrixMatrixTranspose(this.coffs,t.coffs,e.coffs),this.inverseState===P.inverseStored&&t.inverseState===P.inverseStored?e.finishInverseCoffs(((t,e,i)=>mt.multiplyMatrixTransposeMatrix(t,e,i)),t.inverseCoffs,this.inverseCoffs):this.inverseState===P.singular||t.inverseState===P.singular?e.inverseState=P.singular:e.inverseState=P.unknown,e}multiplyMatrixTransposeMatrix(t,e){return e=e||new xt,mt.multiplyMatrixTransposeMatrix(this.coffs,t.coffs,e.coffs),this.inverseState===P.inverseStored&&t.inverseState===P.inverseStored?e.finishInverseCoffs(((t,e,i)=>mt.multiplyMatrixMatrixTranspose(t,e,i)),t.inverseCoffs,this.inverseCoffs):this.inverseState===P.singular||t.inverseState===P.singular?e.inverseState=P.singular:e.inverseState=P.unknown,e}multiplyMatrixTransform(t,e){return e?(this.multiplyXYZtoXYZ(t.origin,e.origin),this.multiplyMatrixMatrix(t.matrix,e.matrix),e):pt.createRefs(this.multiplyXYZ(t.origin.x,t.origin.y,t.origin.z),this.multiplyMatrixMatrix(t.matrix))}transpose(t){return t||(t=new xt),mt.copyTransposed(this.coffs,t.coffs),void 0!==this.inverseCoffs?(t.inverseState=P.inverseStored,t.inverseCoffs=mt.copyTransposed(this.inverseCoffs,t.inverseCoffs)):(t.inverseState=this.inverseState,t.inverseCoffs=void 0),t}transposeInPlace(){mt.transposeInPlace(this.coffs),this.inverseCoffs&&mt.transposeInPlace(this.inverseCoffs)}inverse(t){if(this.computeCachedInverse(!0))return t===this?(mt.copy(this.coffs,xt._productBuffer),mt.copy(this.inverseCoffs,this.coffs),mt.copy(xt._productBuffer,this.inverseCoffs),t):(void 0===t&&(t=xt.createIdentity()),t.createInverseCoffsWithZeros(),mt.copy(this.coffs,t.inverseCoffs),mt.copy(this.inverseCoffs,t.coffs),t.inverseState=this.inverseState,t)}static rowColumnDot(t,e,i,s){return t[e]*i[s]+t[e+1]*i[s+3]+t[e+2]*i[s+6]}static indexedRowCrossProduct(t,e,i,s,n){s[n]=t[e+1]*t[i+2]-t[e+2]*t[i+1],s[n+3]=t[e+2]*t[i]-t[e]*t[i+2],s[n+6]=t[e]*t[i+1]-t[e+1]*t[i]}indexedColumnCrossProductInPlace(t,e,i){const s=this.coffs;s[i]=s[t+3]*s[e+6]-s[t+6]*s[e+3],s[i+3]=s[t+6]*s[e]-s[t]*s[e+6],s[i+6]=s[t]*s[e+3]-s[t+3]*s[e]}axisOrderCrossProductsInPlace(t){switch(t){case p.XYZ:this.indexedColumnCrossProductInPlace(0,1,2),this.indexedColumnCrossProductInPlace(2,0,1);break;case p.YZX:this.indexedColumnCrossProductInPlace(1,2,0),this.indexedColumnCrossProductInPlace(0,1,2);break;case p.ZXY:this.indexedColumnCrossProductInPlace(2,0,1),this.indexedColumnCrossProductInPlace(1,2,0);break;case p.XZY:this.indexedColumnCrossProductInPlace(0,2,1),this.indexedColumnCrossProductInPlace(1,0,2);break;case p.YXZ:this.indexedColumnCrossProductInPlace(1,0,2),this.indexedColumnCrossProductInPlace(2,1,0);break;case p.ZYX:this.indexedColumnCrossProductInPlace(2,1,0),this.indexedColumnCrossProductInPlace(0,2,1)}}normalizeColumnsInPlace(t){const e=this.columnXMagnitude(),i=this.columnYMagnitude(),s=this.columnZMagnitude();return t&&t.set(e,i,s),!(K.isSmallMetricDistance(e)||K.isSmallMetricDistance(i)||K.isSmallMetricDistance(s)||(this.scaleColumns(1/e,1/i,1/s,this),0))}normalizeRowsInPlace(t){const e=this.rowXMagnitude(),i=this.rowYMagnitude(),s=this.rowZMagnitude();return t&&t.set(e,i,s),!(K.isSmallMetricDistance(e)||K.isSmallMetricDistance(i)||K.isSmallMetricDistance(s)||(this.scaleRows(1/e,1/i,1/s,this),0))}isSingular(){return!this.computeCachedInverse(!0)}markSingular(){this.inverseState=P.singular}computeCachedInverse(t){if(t&&xt.useCachedInverse&&this.inverseState!==P.unknown)return xt.numUseCache++,this.inverseState===P.inverseStored;this.inverseState=P.unknown,this.createInverseCoffsWithZeros();const e=this.coffs,i=this.inverseCoffs;xt.indexedRowCrossProduct(e,3,6,i,0),xt.indexedRowCrossProduct(e,6,0,i,1),xt.indexedRowCrossProduct(e,0,3,i,2),xt.numComputeCache++;const s=xt.rowColumnDot(e,0,i,0);if(0===s)return this.inverseState=P.singular,this.inverseCoffs=void 0,!1;const n=1/s;for(let t=0;t<9;t++)i[t]*=n;return this.inverseState=P.inverseStored,!0}static flatIndexOf(t,e){return 3*K.cyclic3dAxis(t)+K.cyclic3dAxis(e)}indexedColumnWithWeight(t,e,i){return t=K.cyclic3dAxis(t),Rt.create(this.coffs[t],this.coffs[t+3],this.coffs[t+6],e,i)}at(t,e){return this.coffs[xt.flatIndexOf(t,e)]}setAt(t,e,i){this.coffs[xt.flatIndexOf(t,e)]=i,this.inverseState=P.unknown}scale(t,e){return xt.createRowValues(this.coffs[0]*t,this.coffs[1]*t,this.coffs[2]*t,this.coffs[3]*t,this.coffs[4]*t,this.coffs[5]*t,this.coffs[6]*t,this.coffs[7]*t,this.coffs[8]*t,e)}scaleColumns(t,e,i,s){return xt.createRowValues(this.coffs[0]*t,this.coffs[1]*e,this.coffs[2]*i,this.coffs[3]*t,this.coffs[4]*e,this.coffs[5]*i,this.coffs[6]*t,this.coffs[7]*e,this.coffs[8]*i,s)}scaleColumnsInPlace(t,e,i){if(this.coffs[0]*=t,this.coffs[1]*=e,this.coffs[2]*=i,this.coffs[3]*=t,this.coffs[4]*=e,this.coffs[5]*=i,this.coffs[6]*=t,this.coffs[7]*=e,this.coffs[8]*=i,this.inverseState===P.inverseStored&&void 0!==this.inverseCoffs){const s=K.conditionalDivideFraction(1,t),n=K.conditionalDivideFraction(1,e),r=K.conditionalDivideFraction(1,i);void 0!==s&&void 0!==n&&void 0!==r?(this.inverseCoffs[0]*=s,this.inverseCoffs[1]*=s,this.inverseCoffs[2]*=s,this.inverseCoffs[3]*=n,this.inverseCoffs[4]*=n,this.inverseCoffs[5]*=n,this.inverseCoffs[6]*=r,this.inverseCoffs[7]*=r,this.inverseCoffs[8]*=r):this.inverseState=P.singular}}scaleRows(t,e,i,s){return xt.createRowValues(this.coffs[0]*t,this.coffs[1]*t,this.coffs[2]*t,this.coffs[3]*e,this.coffs[4]*e,this.coffs[5]*e,this.coffs[6]*i,this.coffs[7]*i,this.coffs[8]*i,s)}scaleRowsInPlace(t,e,i){if(this.coffs[0]*=t,this.coffs[1]*=t,this.coffs[2]*=t,this.coffs[3]*=e,this.coffs[4]*=e,this.coffs[5]*=e,this.coffs[6]*=i,this.coffs[7]*=i,this.coffs[8]*=i,this.inverseState===P.inverseStored&&void 0!==this.inverseCoffs){const s=K.conditionalDivideFraction(1,t),n=K.conditionalDivideFraction(1,e),r=K.conditionalDivideFraction(1,i);void 0!==s&&void 0!==n&&void 0!==r?(this.inverseCoffs[0]*=s,this.inverseCoffs[1]*=n,this.inverseCoffs[2]*=r,this.inverseCoffs[3]*=s,this.inverseCoffs[4]*=n,this.inverseCoffs[5]*=r,this.inverseCoffs[6]*=s,this.inverseCoffs[7]*=n,this.inverseCoffs[8]*=r):this.inverseState=P.singular}}addScaledInPlace(t,e){for(let i=0;i<9;i++)this.coffs[i]+=e*t.coffs[i];this.inverseState=P.unknown}addScaledOuterProductInPlace(t,e,i){this.coffs[0]+=i*t.x*e.x,this.coffs[1]+=i*t.x*e.y,this.coffs[2]+=i*t.x*e.z,this.coffs[3]+=i*t.y*e.x,this.coffs[4]+=i*t.y*e.y,this.coffs[5]+=i*t.y*e.z,this.coffs[6]+=i*t.z*e.x,this.coffs[7]+=i*t.z*e.y,this.coffs[8]+=i*t.z*e.z,this.inverseState=P.unknown}static createRigidViewAxesZTowardsEye(t,e,i,s){s=xt.createIdentity(s);const n=K.hypotenuseXY(t,e);if(K.isSmallMetricDistance(n))i<0&&s.scaleColumnsInPlace(1,-1,-1);else{const r=t/n,o=e/n;if(s.setRowValues(-o,0,r,r,0,o,0,1,0),0!==i){const r=K.hypotenuseXYZ(t,e,i),o=i/r,a=n/r;s.applyGivensColumnOp(1,2,a,-o)}}return s}determinant(){return this.coffs[0]*this.coffs[4]*this.coffs[8]-this.coffs[0]*this.coffs[5]*this.coffs[7]-this.coffs[1]*this.coffs[3]*this.coffs[8]+this.coffs[1]*this.coffs[5]*this.coffs[6]+this.coffs[2]*this.coffs[3]*this.coffs[7]-this.coffs[2]*this.coffs[4]*this.coffs[6]}conditionNumber(){const t=Math.abs(this.determinant()),e=K.hypotenuseXYZ(this.coffs[0],this.coffs[3],this.coffs[6])+K.hypotenuseXYZ(this.coffs[1],this.coffs[4],this.coffs[7])+K.hypotenuseXYZ(this.coffs[2],this.coffs[5],this.coffs[8]);return K.safeDivideFraction(t,e,0)}sumSquares(){let t=0;for(let e=0;e<9;e++)t+=this.coffs[e]*this.coffs[e];return t}sumDiagonalSquares(){let t=0;for(let e=0;e<9;e+=4)t+=this.coffs[e]*this.coffs[e];return t}sumDiagonal(){return this.coffs[0]+this.coffs[4]+this.coffs[8]}maxAbs(){let t=0;for(let e=0;e<9;e++)t=Math.max(t,Math.abs(this.coffs[e]));return t}maxDiff(t){let e=0;for(let i=0;i<9;i++)e=Math.max(e,Math.abs(this.coffs[i]-t.coffs[i]));return e}get isIdentity(){return this.maxDiff(xt.identity)<K.smallAngleRadians}get isDiagonal(){const t=this.sumSquares(),e=this.sumDiagonalSquares(),i=Math.abs(t-e);return Math.sqrt(i)<=K.smallAngleRadians*(1+Math.sqrt(t))}sumSkewSquares(){return K.hypotenuseSquaredXYZ(this.coffs[1]-this.coffs[3],this.coffs[2]-this.coffs[6],this.coffs[5]-this.coffs[7])}isSymmetric(){const t=this.sumSkewSquares();return Math.sqrt(t)<=K.smallAngleRadians*(1+Math.sqrt(this.sumSquares()))}get hasCachedInverse(){return this.inverseState===P.inverseStored&&void 0!==this.inverseCoffs}get isUpperTriangular(){const t=this.sumSquares(),e=K.hypotenuseSquaredXYZ(this.coffs[3],this.coffs[6],this.coffs[7]);return Math.sqrt(e)<=K.smallAngleRadians*(1+Math.sqrt(t))}get isLowerTriangular(){const t=this.sumSquares(),e=K.hypotenuseSquaredXYZ(this.coffs[1],this.coffs[2],this.coffs[5]);return Math.sqrt(e)<=K.smallAngleRadians*(1+Math.sqrt(t))}sameDiagonalScale(){const t=this.sumSquares(),e=this.sumDiagonalSquares(),i=Math.abs(t-e);if(Math.sqrt(i)<=K.smallAngleRadians*(1+Math.sqrt(t))&&K.isSameCoordinate(this.coffs[0],this.coffs[4])&&K.isSameCoordinate(this.coffs[0],this.coffs[8]))return this.coffs[0]}testPerpendicularUnitRowsAndColumns(){return this.multiplyMatrixMatrixTranspose(this).isIdentity}isRigid(t=!1){return this.testPerpendicularUnitRowsAndColumns()&&(t||this.determinant()>0)}factorRigidWithSignedScale(t){const e=this.multiplyMatrixMatrixTranspose(this).sameDiagonalScale();if(void 0===e||e<=0)return;const i=this.determinant()>0?Math.sqrt(e):-Math.sqrt(e),s=1/i;return{rigidAxes:this.scaleColumns(s,s,s,t),scale:i}}get isSignedPermutation(){let t=0;for(let e=0;e<3;e++)for(let i=0;i<3;i++){const s=this.at(e,i);if(0===s);else{if(1!==s&&-1!==s)return!1;if(t++,0!==this.at(e+1,i)||0!==this.at(e+2,i)||0!==this.at(e,i+1)||0!==this.at(e,i+2))return!1}}return 3===t}makeRigid(t=p.XYZ){const e=this.maxAbs();if(K.isSmallMetricDistance(e))return!1;const i=1/e;return this.scaleColumnsInPlace(i,i,i),this.axisOrderCrossProductsInPlace(t),this.normalizeColumnsInPlace()}static createRigidFromMatrix3d(t,e=p.XYZ,i){if((i=t.clone(i)).makeRigid(e))return i}static createFromQuaternion(t){const e=t.x*t.x,i=t.y*t.y,s=t.z*t.z,n=t.w*t.w,r=e+i+s+n;if(0===r)return xt.createIdentity();{const o=1/r;return xt.createRowValues(o*(n+e-i-s),2*o*(t.w*t.z+t.x*t.y),2*o*(t.x*t.z-t.w*t.y),2*o*(t.x*t.y-t.w*t.z),o*(n-e+i-s),2*o*(t.w*t.x+t.y*t.z),2*o*(t.x*t.z+t.w*t.y),2*o*(t.y*t.z-t.w*t.x),o*(n-e-i+s))}}static computeQuatTerm(t,e,i,s){let n;return s>.5?(n=.5*Math.sqrt(s),e*t<0&&(n=-n)):n=t*i,n}toQuaternion(){const t=Rt.createZero(),e=[[this.coffs[0],this.coffs[3],this.coffs[6]],[this.coffs[1],this.coffs[4],this.coffs[7]],[this.coffs[2],this.coffs[5],this.coffs[8]]],i=e[0][0],s=e[1][1],n=e[2][2],r=[];let o;r[0]=1+i-s-n,r[1]=1-i+s-n,r[2]=1-i-s+n,r[3]=1+i+s+n;let a=0;for(let t=1;t<=3;t++)r[t]>r[a]&&(a=t);return 0===a?(t.x=.5*Math.sqrt(r[0]),o=1/(4*t.x),t.y=xt.computeQuatTerm(e[0][1]+e[1][0],t.x,o,r[1]),t.z=xt.computeQuatTerm(e[0][2]+e[2][0],t.x,o,r[2]),t.w=xt.computeQuatTerm(e[2][1]-e[1][2],t.x,o,r[3])):1===a?(t.y=.5*Math.sqrt(r[1]),o=1/(4*t.y),t.x=xt.computeQuatTerm(e[0][1]+e[1][0],t.y,o,r[0]),t.z=xt.computeQuatTerm(e[1][2]+e[2][1],t.y,o,r[2]),t.w=xt.computeQuatTerm(e[0][2]-e[2][0],t.y,o,r[3])):2===a?(t.z=.5*Math.sqrt(r[2]),o=1/(4*t.z),t.x=xt.computeQuatTerm(e[0][2]+e[2][0],t.z,o,r[0]),t.y=xt.computeQuatTerm(e[1][2]+e[2][1],t.z,o,r[1]),t.w=xt.computeQuatTerm(e[1][0]-e[0][1],t.z,o,r[3])):(t.w=.5*Math.sqrt(r[3]),o=1/(4*t.w),t.x=xt.computeQuatTerm(e[2][1]-e[1][2],t.w,o,r[0]),t.y=xt.computeQuatTerm(e[0][2]-e[2][0],t.w,o,r[1]),t.z=xt.computeQuatTerm(e[1][0]-e[0][1],t.w,o,r[2])),t}}xt.useCachedInverse=!0,xt.numUseCache=0,xt.numComputeCache=0,xt._productBuffer=new Float64Array(9);class yt extends tt{constructor(t,e){super(),this._origin=t,this._normal=e}static _create(t,e,i,s,n,r){return new yt(Q.create(t,e,i),$.create(s,n,r))}static createXYPlane(t){return t?yt._create(t.x,t.y,t.z,0,0,1):yt._create(0,0,0,0,0,1)}static createYZPlane(t){return t?yt._create(t.x,t.y,t.z,1,0,0):yt._create(0,0,0,1,0,0)}static createZXPlane(t){return t?yt._create(t.x,t.y,t.z,0,1,0):yt._create(0,0,0,0,1,0)}static create(t,e,i){if(i){if(void 0===e.normalize(i._normal))return;return t.clone(i._origin),i}const s=e.normalize();if(void 0!==s)return new yt(t.clone(),s)}static createFrom(t,e){if(t instanceof yt)return t.clone(e);if(e){if(void 0===t.getUnitNormal(e._normal))return;return t.getAnyPointOnPlane(e._origin),e}const i=t.getUnitNormal();if(void 0===i)return;const s=t.getAnyPointOnPlane();return new yt(s,i)}static createXYZUVW(t,e,i,s,n,r,o){const a=K.hypotenuseXYZ(s,n,r);if(!(a<K.smallMetricDistance))return o?(o._origin.set(t,e,i),o._normal.set(s/a,n/a,r/a),o):new yt(Q.create(t,e,i),$.create(s/a,n/a,r/a))}static createOriginAndTargetXY(t,e,i){const s=e.x-t.x,n=e.y-t.y;return this.createXYZUVW(t.x,t.y,0,n,-s,0,i)}static createXYAngle(t,e,i,s){return s?(s._origin.set(t,e,0),s._normal.set(i.cos(),i.sin(),0),s):new yt(Q.create(t,e,0),$.create(i.cos(),i.sin()))}static createPointPointVectorInPlane(t,e,i){const s=i.crossProductStartEnd(t,e);if(s.tryNormalizeInPlace())return new yt(t,s)}static createOriginAndTargets(t,e,i){const s=t.crossProductToPoints(e,i);if(s.tryNormalizeInPlace())return new yt(t,s)}static createOriginAndVectors(t,e,i){const s=e.crossProduct(i);if(s.tryNormalizeInPlace())return new yt(t,s)}isAlmostEqual(t){return this._origin.isAlmostEqual(t._origin)&&this._normal.isAlmostEqual(t._normal)}setFromJSON(t){t?(this._origin.setFromJSON(t.origin),this._normal.setFromJSON(t.normal)):(this._origin.set(0,0,0),this._normal.set(0,0,1))}toJSON(){return{origin:this._origin.toJSON(),normal:this._normal.toJSON()}}static fromJSON(t){const e=yt.createXYPlane();return e.setFromJSON(t),e}getOriginRef(){return this._origin}getNormalRef(){return this._normal}getLocalToWorld(){const t=xt.createRigidHeadsUp(this._normal,p.ZXY);return pt.createRefs(this._origin.clone(),t)}getProjectionToPlane(){const t=xt.createIdentity();return t.addScaledOuterProductInPlace(this._normal,this._normal,-1),t.markSingular(),pt.createFixedPointAndMatrix(this._origin,t)}set(t,e){this._origin.setFrom(t),this._normal.setFrom(e)}clone(t){return t?(t.set(this._origin,this._normal),t):new yt(this._origin.clone(),this._normal.clone())}cloneTransformed(t,e=!1){const i=this.clone();if(e){if(t.multiplyInversePoint3d(i._origin,i._origin),void 0!==t.matrix.multiplyTransposeVector(i._normal,i._normal)&&i._normal.normalizeInPlace())return i}else if(t.multiplyPoint3d(i._origin,i._origin),void 0!==t.matrix.multiplyInverseTranspose(i._normal,i._normal)&&i._normal.normalizeInPlace())return i}setFrom(t){this.set(t._origin,t._normal)}altitude(t){return this._normal.dotProductStartEnd(this._origin,t)}altitudeXY(t,e){return(t-this._origin.x)*this._normal.x+(e-this._origin.y)*this._normal.y}normalX(){return this._normal.x}normalY(){return this._normal.y}normalZ(){return this._normal.z}getUnitNormal(t){return this._normal.clone(t)}getAnyPointOnPlane(t){return this._origin.clone(t)}weightedAltitude(t){return this._normal.dotProductStart3dEnd4d(this._origin,t)}altitudeToPoint(t,e){return this._origin.plusScaled(this._normal,t,e)}velocityXYZ(t,e,i){return this._normal.dotProductXYZ(t,e,i)}velocity(t){return this._normal.dotProduct(t)}altitudeXYZ(t,e,i){return this._normal.dotProductStartEndXYZ(this._origin,t,e,i)}altitudeXYZW(t,e,i,s){return this._normal.dotProductStartEndXYZW(this._origin,t,e,i,s)}projectPointToPlane(t,e){return t.plusScaled(this._normal,-this._normal.dotProductStartEnd(this._origin,t),e)}isPointInPlane(t,e=K.smallMetricDistance){const i=this._normal.dotProductStartEnd(this._origin,t);return Math.abs(i)<=e}}function _t(t,e){if(t)return t.clone(e)}!function(t){t[t.isolated=0]="isolated",t[t.isolatedAtVertex=1]="isolatedAtVertex",t[t.intervalStart=10]="intervalStart",t[t.intervalInterior=11]="intervalInterior",t[t.intervalEnd=12]="intervalEnd"}(I||(I={})),function(t){t[t.error=0]="error",t[t.success=1]="success",t[t.stoppedAtBoundary=2]="stoppedAtBoundary"}(A||(A={}));class vt{constructor(){this.pointQ=Q.createZero(),this.fraction=0,this.point=Q.createZero(),this.a=0}setIntervalRole(t){this.intervalRole=t}captureFraction1Point1(t,e){this.fraction1=t,this.point1=e}get hasFraction1(){return void 0!==this.fraction1}get isIsolated(){return void 0===this.intervalRole||this.intervalRole===I.isolated||this.intervalRole===I.isolatedAtVertex}get fractionDelta(){return void 0!==this.fraction1?this.fraction1-this.fraction:0}collapseToEnd(){void 0!==this.fraction1&&(this.fraction=this.fraction1,this.fraction1=void 0),this.point1&&(this.point=this.point1,this.point1=void 0)}collapseToStart(){this.fraction1=void 0,this.point1=void 0}clone(t){return t===this||((t=t||new vt).curve=this.curve,t.fraction=this.fraction,t.fraction1=this.fraction1,t.point1=this.point1,t.point.setFromPoint3d(this.point),t.vectorInCurveLocationDetail=_t(this.vectorInCurveLocationDetail,t.vectorInCurveLocationDetail),t.a=this.a,t.curveSearchStatus=this.curveSearchStatus),t}setFP(t,e,i,s=0){this.fraction=t,this.point.setFrom(e),this.vectorInCurveLocationDetail=_t(i,this.vectorInCurveLocationDetail),this.a=s}setFR(t,e,i=0){return this.setFP(t,e.origin,e.direction,i)}setCurve(t){this.curve=t}setDistanceTo(t){this.a=this.point.distance(t)}static create(t,e){return(e=e||new vt).curve=t,e}static createCurveFractionPoint(t,e,i,s){return(s=s||new vt).curve=t,s.fraction=e,s.point.setFromPoint3d(i),s.vectorInCurveLocationDetail=void 0,s.a=0,s.curveSearchStatus=void 0,s}static createRayFractionPoint(t,e,i,s){return(s=s||new vt).fraction=e,s.ray=t,s.point.setFromPoint3d(i),s}static createCurveFractionPointDistanceCurveSearchStatus(t,e,i,s,n,r){return(r=r||new vt).curve=t,r.fraction=e,r.point.setFromPoint3d(i),r.vectorInCurveLocationDetail=void 0,r.a=s,r.curveSearchStatus=n,r}static createConditionalMoveSignedDistance(t,e,i,s,n,r){let o=n,a=A.success;return t||K.isIn01(s)||(s<0?(o=-e.curveLengthBetweenFractions(i,0),s=0,a=A.stoppedAtBoundary):s>1&&(s=1,o=e.curveLengthBetweenFractions(i,1),a=A.stoppedAtBoundary)),(r=r||new vt).curve=e,r.fraction=s,r.point=e.fractionToPoint(s,r.point),r.vectorInCurveLocationDetail=void 0,r.a=o,r.curveSearchStatus=a,r}static createCurveEvaluatedFraction(t,e,i){return(i=i||new vt).curve=t,i.fraction=e,i.point=t.fractionToPoint(e),i.vectorInCurveLocationDetail=void 0,i.curveSearchStatus=void 0,i.a=0,i}static createCurveEvaluatedFractionPointAndDerivative(t,e,i){(i=i||new vt).curve=t,i.fraction=e;const s=t.fractionToPointAndDerivative(e);return i.point=s.origin,i.vectorInCurveLocationDetail=s.direction,i.curveSearchStatus=void 0,i.a=0,i}static createCurveEvaluatedFractionFraction(t,e,i,s){return(s=s||new vt).curve=t,s.fraction=e,s.point=t.fractionToPoint(e),s.fraction1=i,s.point1=t.fractionToPoint(i),s.vectorInCurveLocationDetail=void 0,s.curveSearchStatus=void 0,s.a=0,s}static createCurveFractionPointDistance(t,e,i,s,n){return(n=n||new vt).curve=t,n.fraction=e,n.point.setFromPoint3d(i),n.vectorInCurveLocationDetail=void 0,n.a=s,n.curveSearchStatus=void 0,n}updateIfCloserCurveFractionPointDistance(t,e,i,s){return!(this.a<s||(vt.createCurveFractionPointDistance(t,e,i,s,this),0))}swapFractionsAndPoints(){if(void 0!==this.fraction1){const t=this.fraction;this.fraction=this.fraction1,this.fraction1=t}if(void 0!==this.point1){const t=this.point;this.point=this.point1,this.point1=t}}inverseInterpolateFraction(t,e=0){const i=K.inverseInterpolate01(this.fraction,this.fraction1,t);return void 0===i?e:i}static chooseSmallerA(t,e){return t?e?t.a<=e.a?t:e:t:e}}!function(t){t[t.Intersection=0]="Intersection",t[t.PerpendicularChord=1]="PerpendicularChord",t[t.CoincidentGeometry=2]="CoincidentGeometry",t[t.ParallelGeometry=3]="ParallelGeometry"}(S||(S={}));class Pt{constructor(t,e){this.detailA=t||new vt,this.detailB=e||new vt}static createCapture(t,e,i){return(i=i||new Pt).detailA=t,i.detailB=e,i}static createCaptureOptionalReverse(t,e,i,s){return(s=s||new Pt).detailA=t,s.detailB=e,s}clone(t){return(t=t||new Pt).detailA=this.detailA.clone(),t.detailB=this.detailB.clone(),t.approachType=this.approachType,t}swapDetails(){const t=this.detailA;this.detailA=this.detailB,this.detailB=t}}class It{constructor(){this.dataA=[],this.dataB=[]}}class At{get startDegrees(){return W.radiansToDegrees(this._radians0)}get endDegrees(){return W.radiansToDegrees(this._radians1)}get sweepDegrees(){return W.radiansToDegrees(this._radians1-this._radians0)}get startRadians(){return this._radians0}get endRadians(){return this._radians1}get sweepRadians(){return this._radians1-this._radians0}get startAngle(){return W.createRadians(this._radians0)}get endAngle(){return W.createRadians(this._radians1)}static create(t){return t instanceof At?t.clone():t instanceof W?new At(0,t.radians):At.create360()}constructor(t=0,e=0){this._radians0=t,this._radians1=e}setStartEndRadians(t=0,e=2*Math.PI){const i=e-t;W.isFullCircleRadians(i)&&(e=t+(i>0?2:-2)*Math.PI),this._radians0=t,this._radians1=e}setStartEndDegrees(t=0,e=360){this.setStartEndRadians(W.degreesToRadians(t),W.degreesToRadians(e))}static createStartEndRadians(t=0,e=2*Math.PI,i){return(i=i||new At).setStartEndRadians(t,e),i}cloneMinusRadians(t){return new At(this._radians0-t,this._radians1-t)}static createStartEndDegrees(t=0,e=360,i){return At.createStartEndRadians(W.degreesToRadians(t),W.degreesToRadians(e),i)}static createStartEnd(t,e,i){return(i=i||new At).setStartEndRadians(t.radians,e.radians),i}static createStartSweepRadians(t=0,e=Math.PI,i){return(i=i||new At).setStartEndRadians(t,t+e),i}static createStartSweepDegrees(t=0,e=360,i){return At.createStartEndRadians(W.degreesToRadians(t),W.degreesToRadians(t+e),i)}static createStartSweep(t,e,i){return At.createStartSweepRadians(t.radians,e.radians,i)}interpolate(t,e){return new At(K.interpolate(this._radians0,t,e._radians0),K.interpolate(this._radians1,t,e._radians1))}setFrom(t){this._radians0=t._radians0,this._radians1=t._radians1}static create360(t){return new At(t=t||0,t+2*Math.PI)}static createFullLatitude(){return At.createStartEndRadians(-.5*Math.PI,.5*Math.PI)}reverseInPlace(){const t=this._radians0;this._radians0=this._radians1,this._radians1=t}cloneComplement(t=!1,e){const i=this.sweepRadians>=0?2:-2;return t?At.createStartEndRadians(this.startRadians,this.endRadians-i*Math.PI,e):At.createStartEndRadians(this.endRadians,this.startRadians+i*Math.PI,e)}capLatitudeInPlace(){const t=.5*Math.PI;this._radians0=K.clampToStartEnd(this._radians0,-t,t),this._radians1=K.clampToStartEnd(this._radians1,-t,t)}get isCCW(){return this._radians1>=this._radians0}get isFullCircle(){return W.isFullCircleRadians(this.sweepRadians)}get isFullLatitudeSweep(){const t=.5*Math.PI;return W.isAlmostEqualRadiansNoPeriodShift(this._radians0,-t)&&W.isAlmostEqualRadiansNoPeriodShift(this._radians1,t)}clone(){return new At(this._radians0,this._radians1)}fractionToRadians(t){return t<.5?this._radians0+t*(this._radians1-this._radians0):this._radians1+(t-1)*(this._radians1-this._radians0)}fractionToAngle(t){return W.createRadians(this.fractionToRadians(t))}fractionPeriod(){return K.safeDivideFraction(2*Math.PI,Math.abs(this._radians1-this._radians0),1)}angleToUnboundedFraction(t){return K.safeDivideFraction(t.radians-this._radians0,this._radians1-this._radians0,1)}static radiansToPositivePeriodicFractionStartEnd(t,e,i,s=0){if(W.isAlmostEqualRadiansAllowPeriodShift(t,e))return 0;if(W.isAlmostEqualRadiansAllowPeriodShift(t,i))return 1;const n=i-e,r=t-e;if(n>0){const t=W.adjustRadians0To2Pi(r);return K.safeDivideFraction(t,n,s)}const o=W.adjustRadians0To2Pi(-r);return K.safeDivideFraction(o,-n,s)}radiansToPositivePeriodicFraction(t,e=0){return At.radiansToPositivePeriodicFractionStartEnd(t,this._radians0,this._radians1,e)}angleToPositivePeriodicFraction(t){return this.radiansToPositivePeriodicFraction(t.radians)}radiansArrayToPositivePeriodicFractions(t){const e=t.length;for(let i=0;i<e;i++)t.reassign(i,this.radiansToPositivePeriodicFraction(t.atUncheckedIndex(i)))}radiansToSignedPeriodicFraction(t){if(W.isAlmostEqualRadiansAllowPeriodShift(t,this._radians0))return 0;if(W.isAlmostEqualRadiansAllowPeriodShift(t,this._radians1))return 1;const e=this._radians1-this._radians0,i=t-this._radians0-.5*e;if(e>0){const t=W.adjustRadiansMinusPiPlusPi(i);return.5+K.safeDivideFraction(t,e,0)}const s=W.adjustRadiansMinusPiPlusPi(-i);return.5+K.safeDivideFraction(s,-e,0)}angleToSignedPeriodicFraction(t){return this.radiansToSignedPeriodicFraction(t.radians)}static isRadiansInStartEnd(t,e,i,s=!0){return(t-e)*(t-i)<=0||(e===i?s?W.isAlmostEqualRadiansAllowPeriodShift(t,e):W.isAlmostEqualRadiansNoPeriodShift(t,e):!!s&&this.radiansToPositivePeriodicFractionStartEnd(t,e,i,1e3)<=1)}isRadiansInSweep(t,e=!0){return At.isRadiansInStartEnd(t,this.startRadians,this.endRadians,e)}isAngleInSweep(t){return this.isRadiansInSweep(t.radians)}setFromJSON(t){t?t instanceof At?this.setFrom(t):K.isNumberArray(t.degrees,2)?this.setStartEndDegrees(t.degrees[0],t.degrees[1]):K.isNumberArray(t.radians,2)?this.setStartEndRadians(t.radians[0],t.radians[1]):K.isNumberArray(t,2)?this.setStartEndDegrees(t[0],t[1]):this.setStartEndRadians():this.setStartEndRadians()}static fromJSON(t){const e=At.create360();return e.setFromJSON(t),e}toJSON(){return[this.startDegrees,this.endDegrees]}isAlmostEqualAllowPeriodShift(t){return W.isAlmostEqualRadiansAllowPeriodShift(this._radians0,t._radians0)&&W.isAlmostEqualRadiansAllowPeriodShift(this._radians1-this._radians0,t._radians1-t._radians0)}isAlmostEqualNoPeriodShift(t){return W.isAlmostEqualRadiansNoPeriodShift(this._radians0,t._radians0)&&W.isAlmostEqualRadiansNoPeriodShift(this._radians1-this._radians0,t._radians1-t._radians0)}isAlmostEqual(t){return this.isAlmostEqualNoPeriodShift(t)}}class St{constructor(t=8,e){this._data=new Float64Array(t),this._inUse=0,this._growthFactor=void 0!==e&&e>=1?e:1.5}copyData(t,e,i){let s=i??0;if(s<0&&(s=0),s>=this._data.length)return{count:0,offset:0};let n=e??t.length;return n>0&&(n>t.length&&(n=t.length),s+n>this._data.length&&(n=this._data.length-s)),n<=0?{count:0,offset:0}:(n===t.length?this._data.set(t,s):t instanceof Float64Array?this._data.set(t.subarray(0,n),s):this._data.set(t.slice(0,n),s),{count:n,offset:s})}static create(t){const e=new St(t.length);return e.copyData(t),e._inUse=t.length,e}static compare(t,e){return t-e}clone(t=!1){const e=new St(t?this.capacity():this._inUse);return e.copyData(this._data,this._inUse),e._inUse=this._inUse,e}get length(){return this._inUse}setAtUncheckedIndex(t,e){this._data[t]=e}move(t,e){this._data[e]=this._data[t]}swap(t,e){const i=this._data[t];this._data[t]=this._data[e],this._data[e]=i}push(t){this.ensureCapacity(this._inUse+1),this._data[this._inUse]=t,this._inUse++}pushArray(t){this.ensureCapacity(this._inUse+t.length),this.copyData(t,t.length,this._inUse),this._inUse+=t.length}pushBlockCopy(t,e){t>=0&&t<this._inUse&&e>0&&t+e<=this._inUse&&(this.ensureCapacity(this._inUse+e),this._data.copyWithin(this._inUse,t,t+e),this._inUse+=e)}clear(){this._inUse=0}capacity(){return this._data.length}ensureCapacity(t,e=!0){if(t>this.capacity()){e&&(t*=this._growthFactor);const i=this._data;this._data=new Float64Array(t),this.copyData(i,this._inUse)}}resize(t,e=0){t>=0&&t<this._inUse?this._inUse=t:t>this._inUse&&(this.ensureCapacity(t,!1),this._data.fill(e,this._inUse),this._inUse=t)}pop(){this._inUse>0&&this._inUse--}atUncheckedIndex(t){return this._data[t]}front(){return this._data[0]}back(){return this._data[this._inUse-1]}reassign(t,e){this._data[t]=e}sort(t=((t,e)=>St.compare(t,e))){for(let e=0;e<this._inUse;e++)for(let i=e+1;i<this._inUse;i++){const s=this._data[e],n=this._data[i];t(s,n)>0&&(this._data[e]=n,this._data[i]=s)}}restrictToInterval(t,e){const i=this._data,s=i.length;let n=0,r=0;for(let o=0;o<s;o++)r=i[o],r>=t&&r<=e&&(i[n++]=r);this._inUse=n}compressAdjacentDuplicates(t=0){const e=this._data,i=this._inUse;if(0===i)return;let s,n=1,r=e[0];for(let o=1;o<i;o++)s=e[o],Math.abs(s-r)>t&&(e[n++]=s,r=s);this._inUse=n}}class wt{constructor(t=0,e=0,i=0){this.coffs=[t,e,i]}static solveQuadratic(t,e,i){const s=K.conditionalDivideFraction(e,t),n=K.conditionalDivideFraction(i,t);if(void 0!==s&&void 0!==n){const t=s*s-4*n;if(t>0){const e=Math.sqrt(t);return[.5*(-s-e),.5*(-s+e)]}if(t<0)return;const e=-.5*s;return[e,e]}const r=K.conditionalDivideFraction(-i,e);if(void 0!==r)return[r]}addConstant(t){this.coffs[0]+=t}addSquaredLinearTerm(t,e,i=1){this.coffs[0]+=i*(t*t),this.coffs[1]+=i*(2*t*e),this.coffs[2]+=i*(e*e)}realRoots(){const t=wt.solveQuadratic(this.coffs[2],this.coffs[1],this.coffs[0]);if(t&&t.length>1&&t[0]>t[1]){const e=t[0];t[0]=t[1],t[1]=e}return t}evaluate(t){return this.coffs[0]+t*(this.coffs[1]+t*this.coffs[2])}evaluateDerivative(t){return this.coffs[1]+2*t*this.coffs[2]}tryGetVertexFactorization(){const t=K.conditionalDivideFraction(-this.coffs[1],2*this.coffs[2]);if(void 0!==t){const e=this.evaluate(t);return{c:this.coffs[2],x0:t,y0:e}}}static fromRootsAndC2(t,e,i=1){return new wt(i*t*e,-i*(t+e),i)}}class Ct{static isZero(t){return Math.abs(t)<this._EQN_EPS}static isSmallRatio(t,e,i=1e-9,s=8e-16){return Math.abs(t)<=i||Math.abs(t)<s*Math.abs(e)}static cbrt(t){return t>0?Math.pow(t,1/3):t<0?-Math.pow(-t,1/3):0}static safeDivide(t,e,i,s=0,n){return Math.abs(i)>this._safeDivideFactor*Math.abs(e)?(t[n]=e/i,!0):(t[n]=s,!1)}static checkRootProximity(t,e){return 0===e?t.atUncheckedIndex(e)<t.atUncheckedIndex(e+1):e>0&&e+1<t.length?t.atUncheckedIndex(e)>t.atUncheckedIndex(e-1)&&t.atUncheckedIndex(e)<t.atUncheckedIndex(e+1):t.atUncheckedIndex(e)>t.atUncheckedIndex(e-1)}static newtonMethodAdjustment(t,e,i){let s=t[i],n=0;for(let r=i-1;r>=0;r--)n=s+e*n,s=t[r]+e*s;if(Math.abs(n)>=1e-14*(1+Math.abs(e)))return s/n}static improveRoots(t,e,i,s){for(let n=0;n<i.length;n++){let r=this.newtonMethodAdjustment(t,i.atUncheckedIndex(n),e);if(void 0===r||0===r)continue;const o=i.atUncheckedIndex(n);let a=0,c=0;for(;void 0!==r&&0!==r&&a<12;){if(Math.abs(r)<1e-10*(1+Math.abs(i.atUncheckedIndex(n)))){if(++c>1)break}else c=0;const h=i.atUncheckedIndex(n)-r;if(i.reassign(n,h),s&&!this.checkRootProximity(i,n)){i.reassign(n,o);break}r=this.newtonMethodAdjustment(t,i.atUncheckedIndex(n),e),a++}}}static appendSolution(t,e){void 0!==t&&e.push(t)}static append2Solutions(t,e,i){i.push(t),i.push(e)}static appendLinearRoot(t,e,i){Ct.appendSolution(K.conditionalDivideFraction(-t,e),i)}static mostDistantFromMean(t){if(!t||0===t.length)return 0;let e=0;for(let i=0;i<t.length;i++)e+=t.atUncheckedIndex(i);e/=t.length;let i=0,s=t.atUncheckedIndex(0);for(let n=0;n<t.length;n++){const r=Math.abs(t.atUncheckedIndex(n)-e);r>i&&(i=r,s=t.atUncheckedIndex(n))}return s}static appendQuadraticRoots(t,e){const i=K.conditionalDivideFraction(1,t[2]);if(!i)return void this.appendLinearRoot(t[0],t[1],e);const s=.5*t[1]*i,n=s*s-t[0]*i;if(this.isZero(n))this.appendSolution(-s,e);else if(!(n<0)&&n>0){const t=Math.sqrt(n);this.append2Solutions(t-s,-t-s,e)}}static addConstant(t,e){for(let i=0;i<e.length;i++)e.reassign(i,e.atUncheckedIndex(i)+t)}static signedCubeRoot(t){return t>=0?Math.pow(t,1/3):-Math.pow(-t,1/3)}static appendFullCubicSolutions(t,e,i,s,n){const r=(e*e-3*t*i)/(t*t*9),o=-e/(3*t),a=s+o*(i+o*(e+o*t)),c=4*t*t*r*r*r,h=a*a-c;if(h>0){const e=Math.sqrt(h),i=.5/t;n.push(o+this.signedCubeRoot(i*(-a+e))+this.signedCubeRoot(i*(-a-e)))}else if(h<0){let e=Math.sqrt(c);t<0&&(e=-e);const i=Math.acos(-a/e)/3,s=2*Math.sqrt(r),h=2*Math.PI/3;n.push(o+s*Math.cos(i)),n.push(o+s*Math.cos(i+h)),n.push(o+s*Math.cos(i-h))}else{const e=this.signedCubeRoot(.5*a/t),i=o+e;n.push(o-2*e),n.push(i),n.push(i)}}static appendCubicRoots(t,e){void 0!==K.conditionalDivideCoordinate(1,t[3])?(this.appendFullCubicSolutions(t[3],t[2],t[1],t[0],e),this.improveRoots(t,3,e,!1)):this.appendQuadraticRoots(t,e),e.sort()}static appendQuarticRoots(t,e){const i=new Float64Array(4);let s,n;const r=new Float64Array(1);if(!this.safeDivide(r,1,t[4],0,0))return void this.appendCubicRoots(t,e);const o=t[3]*r[0],a=t[2]*r[0],c=t[1]*r[0],h=-.25*o,l=o*o,d=-3/8*l+a,u=.125*l*o-.5*o*a+c,f=-3/256*l*l+1/16*l*a-1/4*o*c+t[0]*r[0],g=new St;if(this.isZero(f))return i[0]=u,i[1]=d,i[2]=0,i[3]=1,this.appendCubicRoots(i,e),e.push(0),void this.addConstant(h,e);{i[0]=.5*f*d-1/8*u*u,i[1]=-f,i[2]=-.5*d,i[3]=1,this.appendCubicRoots(i,g);const t=this.mostDistantFromMean(g);if(s=t*t-f,n=2*t-d,this.isSmallRatio(s,f))s=0;else{if(!(s>0))return;s=Math.sqrt(s)}if(this.isSmallRatio(n,d))n=0;else{if(!(n>0)){for(let t=0;t<g.length;t++)e.push(g.atUncheckedIndex(t));return}n=Math.sqrt(n)}i[0]=t-s,i[1]=u<0?-n:n,i[2]=1,this.appendQuadraticRoots(i,e),i[0]=t+s,i[1]=u<0?n:-n,i[2]=1,this.appendQuadraticRoots(i,e)}this.addConstant(h,e),e.sort(),this.improveRoots(t,4,e,!0)}static appendCosSinRadians(t,e,i,s,n){i&&i.push(t),s&&s.push(e),n&&n.push(Math.atan2(e,t))}static appendImplicitLineUnitCircleIntersections(t,e,i,s,n,r,o=1e-14){let a;const c=e*e+i*i;let h=0;if(a=o<0?0:2*o,c<=0)h=0===t?-2:-1;else{const o=-t/c,l=1-t*t/c;if(l<-a){const a=Math.sqrt(c),l=t<0?1/a:-1/a;this.appendCosSinRadians(o*e,o*i,s,n,r),this.appendCosSinRadians(e*l,i*l,s,n,r),h=0}else if(l<a){const a=Math.sqrt(c),l=t<0?1/a:-1/a;this.appendCosSinRadians(o*e,o*i,s,n,r),this.appendCosSinRadians(e*l,i*l,s,n,r),h=1}else{const t=Math.sqrt(l/c),a=o*e,d=o*i;this.appendCosSinRadians(a-t*i,d+t*e,s,n,r),this.appendCosSinRadians(a+t*i,d-t*e,s,n,r),h=2}}return h}}Ct._EQN_EPS=1e-9,Ct._safeDivideFactor=1e-14;class Tt{static degreeKnownEvaluate(t,e,i){if(e<0)return 0;let s=t[e];for(let n=e-1;n>=0;n--)s=i*s+t[n];return s}static evaluate(t,e){const i=t.length-1;return this.degreeKnownEvaluate(t,i,e)}static accumulate(t,e,i){let s=t.length-1;const n=e.length-1;for(let s=0;s<=n;s++)t[s]+=i*e[s];for(;s>=0&&0===t[s];)s--;return s}static zero(t){for(let e=0;e<t.length;e++)t[e]=0}}class kt{static solveAngles(t,e,i,s){let n,r=Math.abs(i);s.length=0;const o=this._smallAngle;for(let i=0;i<=e;i++)n=Math.abs(t[i]),n>r&&(r=n);const a=o*r;let c=e;for(;c>0&&Math.abs(t[c])<=a;)c--;const h=new St;if(-1===c);else if(0===c||(1===c?h.push(-t[0]/t[1]):2===c?Ct.appendQuadraticRoots(t,h):3===c?Ct.appendCubicRoots(t,h):4===c&&Ct.appendQuarticRoots(t,h)),h.length>0){for(let t=0;t<h.length;t++){const e=Tt.evaluate(this.S,h.atUncheckedIndex(t)),i=Tt.evaluate(this.C,h.atUncheckedIndex(t));s.push(Math.atan2(e,i))}c<e&&s.push(-.5*Math.PI)}return s.length>0}static solveUnitCircleImplicitQuadricIntersection(t,e,i,s,n,r,o){const a=new Float64Array(5);let c;Tt.zero(a),K.hypotenuseXYZ(t,e,i)>kt._coefficientRelTol*K.hypotenuseXYZ(s,n,r)?(Tt.accumulate(a,this.CW,s),Tt.accumulate(a,this.SW,n),Tt.accumulate(a,this.WW,r),Tt.accumulate(a,this.SS,i),Tt.accumulate(a,this.CC,t),Tt.accumulate(a,this.SC,e),c=4):(Tt.accumulate(a,this.C,s),Tt.accumulate(a,this.S,n),Tt.accumulate(a,this.W,r),c=2);let h=0;return h=Math.max(h,Math.abs(t),Math.abs(i),Math.abs(e),Math.abs(s),Math.abs(n),Math.abs(r)),this.solveAngles(a,c,h,o)}static solveUnitCircleEllipseIntersection(t,e,i,s,n,r,o,a){a.length=0;const c=i*i+s*s,h=2*(i*n+s*r),l=n*n+r*r,d=2*(i*t+s*e),u=2*(n*t+r*e),f=t*t+e*e-1,g=this.solveUnitCircleImplicitQuadricIntersection(c,h,l,d,u,f,o);for(const c of o){const o=Math.cos(c),h=Math.sin(c),l=t+i*o+n*h,d=e+s*o+r*h;a.push(Math.atan2(d,l))}return g}static solveUnitCircleHomogeneousEllipseIntersection(t,e,i,s,n,r,o,a,c,h,l){l.length=0;const d=s*s+n*n-r*r,u=2*(s*o+n*a-r*c),f=o*o+a*a-c*c,g=2*(s*t+n*e-r*i),p=2*(o*t+a*e-c*i),m=t*t+e*e-i*i,x=this.solveUnitCircleImplicitQuadricIntersection(d,u,f,g,p,m,h);for(const i of h){const r=Math.cos(i),c=Math.sin(i),h=t+s*r+o*c,d=e+n*r+a*c;l.push(Math.atan2(d,h))}return x}}kt._smallAngle=1e-11,kt.S=Float64Array.from([0,2,-2]),kt.C=Float64Array.from([1,-2]),kt.W=Float64Array.from([1,-2,2]),kt.CW=Float64Array.from([1,-4,6,-4]),kt.SW=Float64Array.from([0,2,-6,8,-4]),kt.SC=Float64Array.from([0,2,-6,4]),kt.SS=Float64Array.from([0,0,4,-8,4]),kt.CC=Float64Array.from([1,-4,4]),kt.WW=Float64Array.from([1,-4,8,-8,4]),kt.CCminusSS=Float64Array.from([1,-4,0,8,-4]),kt._coefficientRelTol=1e-12;class Ft{static lineSegment2dXYTransverseIntersectionUnbounded(t,e,i,s,n){const r=e.x-t.x,o=e.y-t.y,a=s.x-i.x,c=s.y-i.y,h=i.x-t.x,l=i.y-t.y,d=K.crossProductXYXY(r,o,a,c),u=K.crossProductXYXY(h,l,a,c),f=K.crossProductXYXY(r,o,h,l),g=K.conditionalDivideFraction(u,d),p=K.conditionalDivideFraction(f,d);return void 0!==g&&void 0!==p?(n.set(g,-p),!0):(n.set(0,0),!1)}static lineSegmentXYUVTransverseIntersectionUnbounded(t,e,i,s,n,r,o,a,c){const h=n-t,l=r-e,d=K.crossProductXYXY(i,s,o,a),u=K.crossProductXYXY(h,l,o,a),f=K.crossProductXYXY(i,s,h,l),g=K.conditionalDivideFraction(u,d),p=K.conditionalDivideFraction(f,d);return void 0!==g&&void 0!==p?(c.set(g,-p),!0):(c.set(0,0),!1)}static lineSegment3dXYTransverseIntersectionUnbounded(t,e,i,s,n){const r=e.x-t.x,o=e.y-t.y,a=s.x-i.x,c=s.y-i.y,h=i.x-t.x,l=i.y-t.y,d=K.crossProductXYXY(r,o,a,c),u=K.crossProductXYXY(h,l,a,c),f=K.crossProductXYXY(r,o,h,l),g=K.conditionalDivideFraction(u,d),p=K.conditionalDivideFraction(f,d);return void 0!==g&&void 0!==p?(n.set(g,-p),!0):(n.set(0,0),!1)}static lineSegment3dHXYTransverseIntersectionUnbounded(t,e,i,s,n){const r=K.tripleProduct(t.x,e.x,i.x,t.y,e.y,i.y,t.w,e.w,i.w),o=K.tripleProduct(t.x,e.x,s.x,t.y,e.y,s.y,t.w,e.w,s.w),a=K.conditionalDivideFraction(-r,o-r);if(void 0!==a){const r=K.tripleProduct(i.x,s.x,t.x,i.y,s.y,t.y,i.w,s.w,t.w),o=K.tripleProduct(i.x,s.x,e.x,i.y,s.y,e.y,i.w,s.w,e.w),c=K.conditionalDivideFraction(-r,o-r);if(void 0!==c)return J.create(c,a,n)}}static lineSegment3dHXYClosestPointUnbounded(t,e,i){const s=e.x*t.w-t.x*e.w,n=e.y*t.w-t.y*e.w,r=K.tripleProduct(t.x,-n,i.x,t.y,s,i.y,t.w,0,i.w),o=K.tripleProduct(e.x,-n,i.x,e.y,s,i.y,e.w,0,i.w);return K.conditionalDivideFraction(-r,o-r)}static lineSegment3dXYClosestPointUnbounded(t,e,i){const s=e.x-t.x,n=e.y-t.y,r=s*s+n*n,o=s*(i.x-t.x)+n*(i.y-t.y);return K.conditionalDivideFraction(o,r)}static lineSegment3dClosestPointUnbounded(t,e,i){const s=e.x-t.x,n=e.y-t.y,r=e.z-t.z,o=s*s+n*n+r*r,a=s*(i.x-t.x)+n*(i.y-t.y)+r*(i.z-t.z);return K.conditionalDivideFraction(a,o)}static lineSegment3dClosestApproachUnbounded(t,e,i,s,n){return this.ray3dXYZUVWClosestApproachUnbounded(t.x,t.y,t.z,e.x-t.x,e.y-t.y,e.z-t.z,i.x,i.y,i.z,s.x-i.x,s.y-i.y,s.z-i.z,n)}static ray3dXYZUVWClosestApproachUnbounded(t,e,i,s,n,r,o,a,c,h,l,d,u){const f=o-t,g=a-e,p=c-i,m=K.hypotenuseSquaredXYZ(s,n,r),x=K.hypotenuseSquaredXYZ(h,l,d),y=K.dotProductXYZXYZ(s,n,r,h,l,d),_=K.dotProductXYZXYZ(f,g,p,s,n,r),v=K.dotProductXYZXYZ(f,g,p,h,l,d);return Ft.linearSystem2d(m,-y,y,-x,_,v,u)}static linearSystem2d(t,e,i,s,n,r,o){const a=K.crossProductXYXY(t,i,e,s),c=K.crossProductXYXY(n,r,e,s),h=K.crossProductXYXY(t,i,n,r),l=K.conditionalDivideFraction(c,a),d=K.conditionalDivideFraction(h,a);return void 0!==l&&void 0!==d?(o.set(l,d),!0):(o.set(0,0),!1)}static linearSystem3d(t,e,i,s,n,r,o,a,c,h,l,d,u){const f=K.tripleProduct(t,s,o,e,n,a,i,r,c),g=K.tripleProduct(h,l,d,e,n,a,i,r,c),p=K.tripleProduct(t,s,o,h,l,d,i,r,c),m=K.tripleProduct(t,s,o,e,n,a,h,l,d),x=K.conditionalDivideFraction(g,f),y=K.conditionalDivideFraction(p,f),_=K.conditionalDivideFraction(m,f);if(void 0!==x&&void 0!==y&&void 0!==_)return $.create(x,y,_,u)}static intersect3Planes(t,e,i,s,n,r,o){return this.linearSystem3d(e.x,e.y,e.z,s.x,s.y,s.z,r.x,r.y,r.z,K.dotProductXYZXYZ(t.x,t.y,t.z,e.x,e.y,e.z),K.dotProductXYZXYZ(i.x,i.y,i.z,s.x,s.y,s.z),K.dotProductXYZXYZ(n.x,n.y,n.z,r.x,r.y,r.z),o)}static eliminateFromPivot(t,e,i,s){const n=t.length;let r=K.conditionalDivideFraction(i[e],t[e]);if(void 0===r)return!1;r*=s;for(let s=e+1;s<n;s++)i[s]+=r*t[s];return!0}static solveBilinearPair(t,e,i,s,n,r,o,a){const c=K.crossProductXYXY(t,n,i,o),h=K.crossProductXYXY(e,r,i,o)+K.crossProductXYXY(t,n,s,a),l=K.crossProductXYXY(e,r,s,a),d=wt.solveQuadratic(l,h,c);if(void 0===d)return;const u=[];for(const c of d){const h=K.conditionalDivideFraction(-(t+e*c),i+s*c),l=K.conditionalDivideFraction(-(n+r*c),o+a*c);void 0!==h?u.push(H.create(c,h)):void 0!==l&&u.push(H.create(c,l))}return u}}class Mt{constructor(t,e,i){this.a=t,this.cosineCoff=e,this.sineCoff=i}set(t,e,i){this.a=t,this.cosineCoff=e,this.sineCoff=i}evaluateRadians(t){return this.a+this.cosineCoff*Math.cos(t)+this.sineCoff*Math.sin(t)}range(t){const e=K.hypotenuseXY(this.cosineCoff,this.sineCoff);return ft.createXX(this.a-e,this.a+e,t)}rangeInStartEndRadians(t,e,i){if(W.isFullCircleRadians(e-t))return this.range(i);i=ft.createXX(this.evaluateRadians(t),this.evaluateRadians(e),i);const s=Math.atan2(this.sineCoff,this.cosineCoff),n=s+Math.PI;return At.isRadiansInStartEnd(s,t,e)&&i.extendX(this.evaluateRadians(s)),At.isRadiansInStartEnd(n,t,e)&&i.extendX(this.evaluateRadians(n)),i}rangeInSweep(t,e){return this.rangeInStartEndRadians(t.startRadians,t.endRadians,e)}referenceMinMaxRadians(){return Math.atan2(this.sineCoff,this.cosineCoff)}}class bt{constructor(t,e){this.origin=t,this.direction=e,this.a=void 0}static _create(t,e,i,s,n,r){return new bt(Q.create(t,e,i),$.create(s,n,r))}static createXAxis(){return bt._create(0,0,0,1,0,0)}static createYAxis(){return bt._create(0,0,0,0,1,0)}static createZAxis(){return bt._create(0,0,0,0,0,1)}static createZero(t){return t?(t.origin.setZero(),t.direction.setZero(),t):new bt(Q.createZero(),$.createZero())}isAlmostEqual(t){return this.origin.isAlmostEqual(t.origin)&&this.direction.isAlmostEqual(t.direction)}dotProductToPoint(t){return this.direction.dotProductStartEnd(this.origin,t)}pointToFraction(t){return K.safeDivideFraction(this.dotProductToPoint(t),this.direction.magnitudeSquared(),0)}projectPointToRay(t){return this.origin.plusScaled(this.direction,this.pointToFraction(t))}isAlmostEqualPointSet(t){if(!this.direction.isParallelTo(t.direction,!0))return!1;let e=this.projectPointToRay(t.origin);return!!t.origin.isAlmostEqualMetric(e)&&(e=t.projectPointToRay(this.origin),!!this.origin.isAlmostEqualMetric(e))}static create(t,e,i){return i?(i.set(t,e),i):new bt(t.clone(),e.clone())}static createWeightedDerivative(t,e,i){const s=t[3],n=e[3],r=t[0],o=t[1],a=t[2],c=e[0]*s-t[0]*n,h=e[1]*s-t[1]*n,l=e[2]*s-t[2]*n;if(K.isSmallMetricDistance(s))return;const d=1/s,u=d*d;return bt.createXYZUVW(r*d,o*d,a*d,c*u,h*u,l*u,i)}static createXYZUVW(t,e,i,s,n,r,o){return o?(o.getOriginRef().set(t,e,i),o.getDirectionRef().set(s,n,r),o):new bt(Q.create(t,e,i),$.create(s,n,r))}static createCapture(t,e){return new bt(t,e)}static createPointVectorNumber(t,e,i,s){return s?(s.origin.setFrom(t),s.direction.setFrom(e),s.a=i,s):((s=new bt(t.clone(),e.clone())).a=i,s)}static createStartEnd(t,e,i){return i?(i.origin.setFrom(t),i.direction.setStartEnd(t,e),i):new bt(t.clone(),$.createStartEnd(t,e))}getOriginRef(){return this.origin}getDirectionRef(){return this.direction}set(t,e){this.origin.setFrom(t),this.direction.setFrom(e)}clone(t){return t?(t.set(this.origin.clone(),this.direction.clone()),t):new bt(this.origin.clone(),this.direction.clone())}cloneTransformed(t,e){return bt.create(t.multiplyPoint3d(this.origin,e?.origin),t.multiplyVector(this.direction,e?.direction),e)}cloneInverseTransformed(t,e){if(t.computeCachedInverse(!0))return bt.create(t.multiplyInversePoint3d(this.origin,e?.origin),t.matrix.multiplyInverseXYZAsVector3d(this.direction.x,this.direction.y,this.direction.z,e?.direction),e)}transformInPlace(t){t.multiplyPoint3d(this.origin,this.origin),t.multiplyVector(this.direction,this.direction)}setFrom(t){this.set(t.origin,t.direction)}fractionToPoint(t,e){return this.origin.plusScaled(this.direction,t,e)}toRigidZFrame(t){const e=bt._workMatrix=xt.createRigidHeadsUp(this.direction,p.ZXY,bt._workMatrix);return pt.createOriginAndMatrix(this.origin,e,t)}setFromJSON(t){if(!t)return this.origin.set(0,0,0),void this.direction.set(0,0,1);this.origin.setFromJSON(t.origin),this.direction.setFromJSON(t.direction)}toJSON(){return{origin:this.origin.toJSON(),direction:this.direction.toJSON()}}static fromJSON(t){const e=bt.createXAxis();return e.setFromJSON(t),e}trySetDirectionMagnitudeInPlace(t=1){return this.direction.tryNormalizeInPlace()?(this.direction.scaleInPlace(t),!0):(this.direction.setZero(),this.a=0,!1)}tryNormalizeInPlaceWithAreaWeight(t){const e=K.smallMetricDistanceSquared;return this.a=t,!!(Math.abs(t)>e&&this.direction.tryNormalizeInPlace(e))||(this.direction.setZero(),this.a=0,!1)}distance(t){const e=this.direction.magnitudeSquared(),i=this.dotProductToPoint(t),s=K.inverseMetricDistanceSquared(e);return s?Math.sqrt(this.origin.distanceSquared(t)-i*i*s):Math.sqrt(this.origin.distanceSquared(t))}intersectionWithPlane(t,e){const i=$.createStartEnd(t.getOriginRef(),this.origin),s=this.direction.dotProduct(t.getNormalRef()),n=this.direction.magnitudeSquared(),r=i.dotProduct(t.getNormalRef()),o=K.conditionalDivideFraction(-r,s);if(void 0!==o)return void 0!==K.conditionalDivideFraction(n,s)?(e&&this.origin.plusScaled(this.direction,o,e),o):void 0}intersectionWithRange3d(t,e){if(t.isNull)return ft.createNull(e);const i=ft.createXX(-K.largeCoordinateResult,K.largeCoordinateResult,e);return i.clipLinearMapToInterval(this.origin.x,this.direction.x,t.low.x,t.high.x)&&i.clipLinearMapToInterval(this.origin.y,this.direction.y,t.low.y,t.high.y)&&i.clipLinearMapToInterval(this.origin.z,this.direction.z,t.low.z,t.high.z),i}intersectionWithTriangle(t,e,i,s,n,r){(void 0===s||s<0)&&(s=K.smallMetricDistance),(void 0===n||n<0)&&(n=K.smallFloatingPoint);const o=bt._workVector0=$.createStartEnd(t,e,bt._workVector0),a=bt._workVector1=$.createStartEnd(t,i,bt._workVector1),c=bt._workVector2=this.direction.crossProduct(a,bt._workVector2),h=o.dotProduct(c);if(h>=-s&&h<=s)return;const l=1/h,d=bt._workVector3=$.createStartEnd(t,this.origin,bt._workVector3);let u=l*d.dotProduct(c);if(u<0){if(!(u>-n))return;u=0}else if(u>1){if(!(u<1+n))return;u=1}const f=bt._workVector4=d.crossProduct(o,bt._workVector4);let g=l*this.direction.dotProduct(f);if(g<0){if(!(g>-n))return;g=0}else if(u+g>1){if(!(u+g<1+n))return;g=1-u}const p=l*a.dotProduct(f);return p<=s?void 0:this.origin.plusScaled(this.direction,p,r)}perpendicularPartOfVectorToTarget(t,e){const i=$.createStartEnd(this.origin,t),s=this.direction.magnitudeSquared(),n=this.direction.dotProductStartEnd(this.origin,t),r=K.safeDivideFraction(n,s,0);return i.plusScaled(this.direction,-r,e)}static closestApproachRay3dRay3d(t,e){const i=J.create();let s,n,r,o,a;Ft.ray3dXYZUVWClosestApproachUnbounded(t.origin.x,t.origin.y,t.origin.z,t.direction.x,t.direction.y,t.direction.z,e.origin.x,e.origin.y,e.origin.z,e.direction.x,e.direction.y,e.direction.z,i)?(s=i.x,n=i.y,r=t.fractionToPoint(s),o=e.fractionToPoint(n),a=r.isAlmostEqualMetric(o)?S.Intersection:S.PerpendicularChord):(n=0,s=t.pointToFraction(e.origin),r=t.fractionToPoint(s),o=e.fractionToPoint(n),a=r.isAlmostEqualMetric(o)?S.CoincidentGeometry:S.ParallelGeometry);const c=Pt.createCapture(vt.createRayFractionPoint(t,s,t.fractionToPoint(s)),vt.createRayFractionPoint(e,n,e.fractionToPoint(n)));return c.approachType=a,c}static interpolatePointAndTangent(t,e,i,s,n){n=n??bt.createZero();const r=i.x-t.x,o=i.y-t.y,a=i.z-t.z;if(n.direction.set(s*r,s*o,s*a),e<=.5)n.origin.set(t.x+e*r,t.y+e*o,t.z+e*a);else{const t=e-1;n.origin.set(i.x+t*r,i.y+t*o,i.z+t*a)}return n}}class Et extends tt{constructor(t,e,i){super(),this.origin=t,this.vectorU=e,this.vectorV=i}static createOriginAndVectors(t,e,i,s){return s?(s.origin.setFrom(t),s.vectorU.setFrom(e),s.vectorV.setFrom(i),s):new Et(t.clone(),e.clone(),i.clone())}clone(t){return void 0!==t&&t.setOriginAndVectors(this.origin,this.vectorU,this.vectorV),new Et(this.origin.clone(),this.vectorU.clone(),this.vectorV.clone())}static createFrom(t,e){if(t instanceof Et)return t.clone(e);const i=t.getUnitNormal();if(void 0===i)return;const s=t.getAnyPointOnPlane(),n=xt.createPerpendicularVectorFavorXYPlane(i);if(n.tryNormalizeInPlace()){const t=i.unitCrossProduct(n);if(void 0!==t)return new Et(s,n,t)}}static createFromTransformColumnsXYAndLengths(t,e,i,s){return s?(s.origin.setFrom(t.getOrigin()),t.matrix.columnX(s.vectorU),t.matrix.columnY(s.vectorV)):s=new Et(t.getOrigin(),t.matrix.columnX(),t.matrix.columnY()),void 0!==e&&s.vectorU.scaleToLength(e,s.vectorU),void 0!==i&&s.vectorV.scaleToLength(i,s.vectorV),s}static createCapture(t,e,i,s){return s?(s.origin=t,s.vectorU=e,s.vectorV=i,s):new Et(t,e,i)}setOriginAndVectorsXYZ(t,e,i,s,n,r,o,a,c){return this.origin.set(t,e,i),this.vectorU.set(s,n,r),this.vectorV.set(o,a,c),this}setOriginAndVectors(t,e,i){return this.origin.setFrom(t),this.vectorU.setFrom(e),this.vectorV.setFrom(i),this}static createOriginAndVectorsXYZ(t,e,i,s,n,r,o,a,c,h){return h?h.setOriginAndVectorsXYZ(t,e,i,s,n,r,o,a,c):new Et(Q.create(t,e,i),$.create(s,n,r),$.create(o,a,c))}static createOriginAndTargets(t,e,i,s){return Et.createOriginAndVectorsXYZ(t.x,t.y,t.z,e.x-t.x,e.y-t.y,e.z-t.z,i.x-t.x,i.y-t.y,i.z-t.z,s)}static createXYPlane(t){return Et.createOriginAndVectorsXYZ(0,0,0,1,0,0,0,1,0,t)}static createOriginAndVectorsArrays(t,e,i,s){return Et.createOriginAndVectorsXYZ(t[0],t[1],t[2],e[0],e[1],e[2],i[0],i[1],i[2],s)}static createOriginAndVectorsWeightedArrays(t,e,i,s){const n=t[3];if(s=Et.createXYPlane(s),K.isSmallMetricDistance(n))return s;const r=1/n,o=e[3]*r*r,a=i[3]*r*r;return s.origin.set(t[0]*r,t[1]*r,t[2]*r),$.createAdd2ScaledXYZ(e[0],e[1],e[2],r,t[0],t[1],t[2],-o,s.vectorU),$.createAdd2ScaledXYZ(i[0],i[1],i[2],r,t[0],t[1],t[2],-a,s.vectorV),s}fractionToPoint(t,e,i){return this.origin.plus2Scaled(this.vectorU,t,this.vectorV,e,i)}fractionToVector(t,e,i){return $.createAdd2Scaled(this.vectorU,t,this.vectorV,e,i)}setFromJSON(t){t&&t.origin&&t.vectorV?(this.origin.setFromJSON(t.origin),this.vectorU.setFromJSON(t.vectorU),this.vectorV.setFromJSON(t.vectorV)):(this.origin.set(0,0,0),this.vectorU.set(1,0,0),this.vectorV.set(0,1,0))}toJSON(){return{origin:this.origin.toJSON(),vectorU:this.vectorU.toJSON(),vectorV:this.vectorV.toJSON()}}static fromJSON(t){const e=Et.createXYPlane();return e.setFromJSON(t),e}isAlmostEqual(t){return this.origin.isAlmostEqual(t.origin)&&this.vectorU.isAlmostEqual(t.vectorU)&&this.vectorV.isAlmostEqual(t.vectorV)}normalizeInPlace(){const t=this.vectorU.normalizeInPlace(),e=this.vectorV.normalizeInPlace();return t&&e}getUnitNormal(t){return this.vectorU.unitCrossProduct(this.vectorV,t)}unitNormal(t){return this.vectorU.unitCrossProduct(this.vectorV,t)}getAnyPointOnPlane(t){return this.origin.clone(t)}unitNormalRay(t){Et._workVector||(Et._workVector=$.create());const e=this.vectorU.unitCrossProduct(this.vectorV,Et._workVector);if(void 0!==e)return bt.create(this.origin,e,t)}toRigidFrame(t){return pt.createRigidFromOriginAndColumns(this.origin,this.vectorU,this.vectorV,p.XYZ,t)}transformInPlace(t){t.multiplyPoint3d(this.origin,this.origin),t.multiplyVector(this.vectorU,this.vectorU),t.multiplyVector(this.vectorV,this.vectorV)}normalX(){const t=this.vectorU.unitCrossProduct(this.vectorV);return void 0!==t?t.x:0}normalY(){const t=this.vectorU.unitCrossProduct(this.vectorV);return void 0!==t?t.y:0}normalZ(){const t=this.vectorU.unitCrossProduct(this.vectorV);return void 0!==t?t.z:0}altitude(t){const e=this.vectorU.unitCrossProduct(this.vectorV);return void 0===e?0:K.dotProductXYZXYZ(t.x-this.origin.x,t.y-this.origin.y,t.z-this.origin.z,e.x,e.y,e.z)}altitudeXYZ(t,e,i){const s=this.vectorU.unitCrossProduct(this.vectorV);return void 0===s?0:K.dotProductXYZXYZ(t-this.origin.x,e-this.origin.y,i-this.origin.z,s.x,s.y,s.z)}velocity(t){const e=this.vectorU.unitCrossProduct(this.vectorV);return void 0===e?0:K.dotProductXYZXYZ(t.x,t.y,t.z,e.x,e.y,e.z)}velocityXYZ(t,e,i){const s=this.vectorU.unitCrossProduct(this.vectorV);return void 0===s?0:K.dotProductXYZXYZ(t,e,i,s.x,s.y,s.z)}weightedAltitude(t){const e=t.w;return K.tripleProduct(t.x-this.origin.x*e,t.y-this.origin.y*e,t.z-this.origin.z*e,this.vectorU.x,this.vectorU.y,this.vectorU.z,this.vectorV.x,this.vectorV.y,this.vectorV.z)}projectPointToPlane(t,e){const i=this.vectorU.unitCrossProduct(this.vectorV);if(void 0!==i){const s=i.dotProductStartEnd(this.origin,t);return t.plusScaled(i,-s,e)}const s=this.vectorU.magnitudeSquared(),n=this.vectorV.magnitudeSquared();if(s>=n){const i=this.vectorU.dotProductStartEnd(this.origin,t),n=K.conditionalDivideCoordinate(i,s,0);if(void 0!==n)return t.plusScaled(this.vectorU,n,e)}else{const i=this.vectorV.dotProductStartEnd(this.origin,t),s=K.conditionalDivideCoordinate(i,n,0);if(void 0!==s)return t.plusScaled(this.vectorV,s,e)}return this.origin.clone(e)}}function Xt(t,e,i,s,n,r){return r*(t-2*n*e-s*i)}class Rt extends tt{set(t=0,e=0,i=0,s=0){return this.xyzw[0]=t,this.xyzw[1]=e,this.xyzw[2]=i,this.xyzw[3]=s,this}setComponent(t,e){t>=0&&t<4&&(this.xyzw[t]=e)}get x(){return this.xyzw[0]}set x(t){this.xyzw[0]=t}get y(){return this.xyzw[1]}set y(t){this.xyzw[1]=t}get z(){return this.xyzw[2]}set z(t){this.xyzw[2]=t}get w(){return this.xyzw[3]}set w(t){this.xyzw[3]=t}constructor(t=0,e=0,i=0,s=0){super(),this.xyzw=new Float64Array(4),this.xyzw[0]=t,this.xyzw[1]=e,this.xyzw[2]=i,this.xyzw[3]=s}static create(t=0,e=0,i=0,s=0,n){return n?n.set(t,e,i,s):new Rt(t,e,i,s)}static createPlaneFrom(t){return new Rt(t.normalX(),t.normalY(),t.normalZ(),t.altitudeXYZ(0,0,0))}setFrom(t){return this.xyzw[0]=t.xyzw[0],this.xyzw[1]=t.xyzw[1],this.xyzw[2]=t.xyzw[2],this.xyzw[3]=t.xyzw[3],this}clone(t){return t?t.setFrom(this):new Rt(this.xyzw[0],this.xyzw[1],this.xyzw[2],this.xyzw[3])}setFromJSON(t){K.isNumberArray(t,4)?this.set(t[0],t[1],t[2],t[3]):this.set(0,0,0,0)}static fromJSON(t){const e=new Rt;return e.setFromJSON(t),e}isAlmostEqual(t){return K.isSameCoordinate(this.x,t.x)&&K.isSameCoordinate(this.y,t.y)&&K.isSameCoordinate(this.z,t.z)&&K.isSameCoordinate(this.w,t.w)}isAlmostEqualXYZW(t,e,i,s){return K.isSameCoordinate(this.x,t)&&K.isSameCoordinate(this.y,e)&&K.isSameCoordinate(this.z,i)&&K.isSameCoordinate(this.w,s)}toJSON(){return[this.xyzw[0],this.xyzw[1],this.xyzw[2],this.xyzw[3]]}distanceXYZW(t){return K.hypotenuseXYZW(t.xyzw[0]-this.xyzw[0],t.xyzw[1]-this.xyzw[1],t.xyzw[2]-this.xyzw[2],t.xyzw[3]-this.xyzw[3])}distanceSquaredXYZW(t){return K.hypotenuseSquaredXYZW(t.xyzw[0]-this.xyzw[0],t.xyzw[1]-this.xyzw[1],t.xyzw[2]-this.xyzw[2],t.xyzw[3]-this.xyzw[3])}realDistanceXY(t){const e=this.w,i=t.w;if(!K.isSmallMetricDistance(e)&&!K.isSmallMetricDistance(i))return K.hypotenuseXY(t.xyzw[0]/i-this.xyzw[0]/e,t.xyzw[1]/i-this.xyzw[1]/e)}maxDiff(t){return Math.max(Math.abs(t.xyzw[0]-this.xyzw[0]),Math.abs(t.xyzw[1]-this.xyzw[1]),Math.abs(t.xyzw[2]-this.xyzw[2]),Math.abs(t.xyzw[3]-this.xyzw[3]))}maxAbs(){return Math.max(Math.abs(this.xyzw[0]),Math.abs(this.xyzw[1]),Math.abs(this.xyzw[2]),Math.abs(this.xyzw[3]))}magnitudeXYZW(){return K.hypotenuseXYZW(this.xyzw[0],this.xyzw[1],this.xyzw[2],this.xyzw[3])}magnitudeSquaredXYZ(){return K.hypotenuseSquaredXYZ(this.xyzw[0],this.xyzw[1],this.xyzw[2])}minus(t,e){return Rt.create(this.xyzw[0]-t.xyzw[0],this.xyzw[1]-t.xyzw[1],this.xyzw[2]-t.xyzw[2],this.xyzw[3]-t.xyzw[3],e)}crossWeightedMinus(t,e){const i=this.xyzw[3],s=t.xyzw[3];return $.create(s*this.xyzw[0]-i*t.xyzw[0],s*this.xyzw[1]-i*t.xyzw[1],s*this.xyzw[2]-i*t.xyzw[2],e)}crossWeightedMinusPoint3d(t,e){const i=this.xyzw[3];return $.create(this.xyzw[0]-i*t.x,this.xyzw[1]-i*t.y,this.xyzw[2]-i*t.z,e)}plus(t,e){return Rt.create(this.xyzw[0]+t.xyzw[0],this.xyzw[1]+t.xyzw[1],this.xyzw[2]+t.xyzw[2],this.xyzw[3]+t.xyzw[3],e)}get isAlmostZero(){return K.isSmallMetricDistance(this.maxAbs())}static createZero(){return new Rt(0,0,0,0)}static createPlanePointPointZ(t,e,i){return Rt.create(t.y*e.w-t.w*e.y,t.w*e.x-t.x*e.w,0,t.x*e.y-t.y*e.x,i)}static createFromPackedXYZW(t,e=0,i){return Rt.create(t[e],t[e+1],t[e+2],t[e+3],i)}static createFromPointAndWeight(t,e){return new Rt(t.x,t.y,t.z,e)}static createFromPoint(t){if(t instanceof H)return new Rt(t.x,t.y,0,1);if(t instanceof Q)return new Rt(t.x,t.y,t.z,1);if(t instanceof Rt)return t.clone();if(Array.isArray(t)){const e=t.length>0?t[0]:0,i=t.length>1?t[1]:0,s=t.length>2?t[2]:0,n=t.length>3?t[3]:1;return new Rt(e,i,s,n)}const e=t.x,i=t.y,s=t.hasOwnProperty("z")?t.z:0,n=t.hasOwnProperty("w")?t.w:1;return new Rt(e,i,s,n)}plusScaled(t,e,i){return Rt.create(this.xyzw[0]+t.xyzw[0]*e,this.xyzw[1]+t.xyzw[1]*e,this.xyzw[2]+t.xyzw[2]*e,this.xyzw[3]+t.xyzw[3]*e,i)}interpolate(t,e,i){const s=1-t;return Rt.create(this.xyzw[0]*s+e.xyzw[0]*t,this.xyzw[1]*s+e.xyzw[1]*t,this.xyzw[2]*s+e.xyzw[2]*t,this.xyzw[3]*s+e.xyzw[3]*t,i)}plus2Scaled(t,e,i,s,n){return Rt.create(this.xyzw[0]+t.xyzw[0]*e+i.xyzw[0]*s,this.xyzw[1]+t.xyzw[1]*e+i.xyzw[1]*s,this.xyzw[2]+t.xyzw[2]*e+i.xyzw[2]*s,this.xyzw[3]+t.xyzw[3]*e+i.xyzw[3]*s,n)}plus3Scaled(t,e,i,s,n,r,o){return Rt.create(this.xyzw[0]+t.xyzw[0]*e+i.xyzw[0]*s+n.xyzw[0]*r,this.xyzw[1]+t.xyzw[1]*e+i.xyzw[1]*s+n.xyzw[1]*r,this.xyzw[2]+t.xyzw[2]*e+i.xyzw[2]*s+n.xyzw[2]*r,this.xyzw[3]+t.xyzw[3]*e+i.xyzw[3]*s+n.xyzw[3]*r,o)}static createAdd2Scaled(t,e,i,s,n){return Rt.create(t.xyzw[0]*e+i.xyzw[0]*s,t.xyzw[1]*e+i.xyzw[1]*s,t.xyzw[2]*e+i.xyzw[2]*s,t.xyzw[3]*e+i.xyzw[3]*s,n)}static createAdd3Scaled(t,e,i,s,n,r,o){return Rt.create(t.xyzw[0]*e+i.xyzw[0]*s+n.xyzw[0]*r,t.xyzw[1]*e+i.xyzw[1]*s+n.xyzw[1]*r,t.xyzw[2]*e+i.xyzw[2]*s+n.xyzw[2]*r,t.xyzw[3]*e+i.xyzw[3]*s+n.xyzw[3]*r,o)}dotVectorsToTargets(t,e){return(t.xyzw[0]-this.xyzw[0])*(e.xyzw[0]-this.xyzw[0])+(t.xyzw[1]-this.xyzw[1])*(e.xyzw[1]-this.xyzw[1])+(t.xyzw[2]-this.xyzw[2])*(e.xyzw[2]-this.xyzw[2])+(t.xyzw[3]-this.xyzw[3])*(e.xyzw[3]-this.xyzw[3])}dotProduct(t){return this.xyzw[0]*t.xyzw[0]+this.xyzw[1]*t.xyzw[1]+this.xyzw[2]*t.xyzw[2]+this.xyzw[3]*t.xyzw[3]}dotProductXYZW(t,e,i,s){return this.xyzw[0]*t+this.xyzw[1]*e+this.xyzw[2]*i+this.xyzw[3]*s}altitude(t){return this.xyzw[0]*t.x+this.xyzw[1]*t.y+this.xyzw[2]*t.z+this.xyzw[3]}altitudeXYZ(t,e,i){return this.xyzw[0]*t+this.xyzw[1]*e+this.xyzw[2]*i+this.xyzw[3]}weightedAltitude(t){return this.xyzw[0]*t.x+this.xyzw[1]*t.y+this.xyzw[2]*t.z+this.xyzw[3]*t.w}velocity(t){return this.xyzw[0]*t.x+this.xyzw[1]*t.y+this.xyzw[2]*t.z}velocityXYZ(t,e,i){return this.xyzw[0]*t+this.xyzw[1]*e+this.xyzw[2]*i}normalX(){return this.x}normalY(){return this.y}normalZ(){return this.z}static unitX(){return new Rt(1,0,0,0)}static unitY(){return new Rt(0,1,0,0)}static unitZ(){return new Rt(0,0,1,0)}static unitW(){return new Rt(0,0,0,1)}safeDivideOrNull(t,e){if(0!==t)return this.scale(1/t,e)}projectPointToPlane(t,e){const i=this.altitude(t),s=this.magnitudeSquaredXYZ(),n=K.conditionalDivideCoordinate(-i,s);return void 0===n?t.clone(e):t.plusXYZ(n*this.x,n*this.y,n*this.z,e)}scale(t,e){return(e=e||new Rt).xyzw[0]=this.xyzw[0]*t,e.xyzw[1]=this.xyzw[1]*t,e.xyzw[2]=this.xyzw[2]*t,e.xyzw[3]=this.xyzw[3]*t,e}negate(t){return(t=t||new Rt).xyzw[0]=-this.xyzw[0],t.xyzw[1]=-this.xyzw[1],t.xyzw[2]=-this.xyzw[2],t.xyzw[3]=-this.xyzw[3],t}normalizeWeight(t){const e=K.correctSmallFraction(this.xyzw[3]);return t=t||new Rt,this.safeDivideOrNull(e,t)}realPoint(t){const e=K.correctSmallFraction(this.xyzw[3]);if(0===e)return;const i=1/e;return Q.create(this.xyzw[0]*i,this.xyzw[1]*i,this.xyzw[2]*i,t)}realPointOrVector(){const t=K.correctSmallFraction(this.xyzw[3]);if(0===t)return $.create(this.x,this.y,this.z);const e=1/t;return Q.create(this.x*e,this.y*e,this.z*e)}static createRealPoint3dDefault000(t,e,i,s,n){const r=K.correctSmallFraction(s),o=0===r?0:1/r;return Q.create(t*o,e*o,i*o,n)}static createRealDerivativeRay3dDefault000(t,e,i,s,n,r,o,a,c){const h=K.correctSmallFraction(s),l=0===h?0:1/h,d=l*l;return bt.createXYZUVW(t*l,e*l,i*l,(n*s-a*t)*d,(r*s-a*e)*d,(o*s-a*i)*d,c)}static createRealDerivativePlane3dByOriginAndVectorsDefault000(t,e,i,s,n,r,o,a,c,h,l,d,u){const f=K.correctSmallFraction(s),g=0===f?0:1/f,p=g*g,m=t*g,x=e*g,y=i*g,_=(n*s-a*t)*p,v=(r*s-a*e)*p,P=(o*s-a*i)*p;return Et.createOriginAndVectorsXYZ(m,x,y,_,v,P,Xt(c,a,d,m,_,g),Xt(h,a,d,x,v,g),Xt(l,a,d,y,P,g),u)}realPointDefault000(t){const e=K.correctSmallFraction(this.xyzw[3]);if(0===e)return Q.create(0,0,0,t);t=t||new Q;const i=1/e;return Q.create(this.xyzw[0]*i,this.xyzw[1]*i,this.xyzw[2]*i,t)}normalizeXYZW(t){const e=K.correctSmallFraction(this.magnitudeXYZW());return t=t||new Rt,this.safeDivideOrNull(e,t)}static determinantIndexed3X3(t,e,i,s,n,r){return K.tripleProduct(t.xyzw[s],t.xyzw[n],t.xyzw[r],e.xyzw[s],e.xyzw[n],e.xyzw[r],i.xyzw[s],i.xyzw[n],i.xyzw[r])}static perpendicularPoint4dPlane(t,e,i){return Rt.create(Rt.determinantIndexed3X3(t,e,i,1,2,3),-Rt.determinantIndexed3X3(t,e,i,2,3,0),Rt.determinantIndexed3X3(t,e,i,3,0,1),-Rt.determinantIndexed3X3(t,e,i,0,1,2))}toPlane3dByOriginAndUnitNormal(t){return yt.createFrom(this,t)}normalizeQuaternion(){const t=Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);if(t>0){const e=1/t;this.x*=e,this.y*=e,this.z*=e,this.w*=e}return t}static interpolateQuaternions(t,e,i,s){if(s||(s=new Rt),0===e)return t;if(1===e)return i;if(.5===e)return t.plus(i,s),s.normalizeQuaternion(),s;const n=t.clone(),r=i.clone();let o=t.dotProduct(i);if(o<0&&(r.negate(r),o=-o),o>.9995)return n.interpolate(e,r,s),s.normalizeQuaternion(),s;o<-1?o=-1:o>1&&(o=1);const a=new Rt;r.plusScaled(n,-o,a),a.normalizeQuaternion();const c=Math.acos(o)*e;return Rt.createAdd2Scaled(n,Math.cos(c),a,Math.sin(c))}radiansToPoint4dXYZW(t){const e=this.magnitudeXYZW(),i=t.magnitudeXYZW(),s=this.dotProduct(t),n=K.conditionalDivideFraction(s,e*i);if(void 0!==n)return Math.acos(n)}}class zt{constructor(){this._coffs=new Float64Array(16)}setFrom(t){for(let e=0;e<16;e++)this._coffs[e]=t._coffs[e]}clone(t){if(t===this)return this;void 0===t&&(t=new zt);for(let e=0;e<16;e++)t._coffs[e]=this._coffs[e];return t}setZero(){for(let t=0;t<16;t++)this._coffs[t]=0}setIdentity(){for(let t=0;t<16;t++)this._coffs[t]=0;this._coffs[0]=this._coffs[5]=this._coffs[10]=this._coffs[15]=1}static is1000(t,e,i,s,n){return Math.abs(t-1)<=n&&Math.abs(e)<=n&&Math.abs(i)<=n&&Math.abs(s)<=n}isIdentity(t=1e-10){return zt.is1000(this._coffs[0],this._coffs[1],this._coffs[2],this._coffs[3],t)&&zt.is1000(this._coffs[5],this._coffs[6],this._coffs[7],this._coffs[4],t)&&zt.is1000(this._coffs[10],this._coffs[11],this._coffs[8],this._coffs[9],t)&&zt.is1000(this._coffs[15],this._coffs[12],this._coffs[13],this._coffs[14],t)}static createZero(t){return t?(t.setZero(),t):new zt}static createRowValues(t,e,i,s,n,r,o,a,c,h,l,d,u,f,g,p,m){return(m=m||new zt)._coffs[0]=t,m._coffs[1]=e,m._coffs[2]=i,m._coffs[3]=s,m._coffs[4]=n,m._coffs[5]=r,m._coffs[6]=o,m._coffs[7]=a,m._coffs[8]=c,m._coffs[9]=h,m._coffs[10]=l,m._coffs[11]=d,m._coffs[12]=u,m._coffs[13]=f,m._coffs[14]=g,m._coffs[15]=p,m}static createRows(t,e,i,s,n){return this.createRowValues(t.x,t.y,t.z,t.w,e.x,e.y,e.z,e.w,i.x,i.y,i.z,i.w,s.x,s.y,s.z,s.w,n)}setOriginAndVectors(t,e,i,s){this._coffs[0]=e.x,this._coffs[1]=i.x,this._coffs[2]=s.x,this._coffs[3]=t.x,this._coffs[4]=e.y,this._coffs[5]=i.y,this._coffs[6]=s.y,this._coffs[7]=t.y,this._coffs[8]=e.z,this._coffs[9]=i.z,this._coffs[10]=s.z,this._coffs[11]=t.z,this._coffs[12]=0,this._coffs[13]=0,this._coffs[14]=0,this._coffs[15]=1}static createTransform(t,e){const i=t.matrix,s=t.origin;return zt.createRowValues(i.coffs[0],i.coffs[1],i.coffs[2],s.x,i.coffs[3],i.coffs[4],i.coffs[5],s.y,i.coffs[6],i.coffs[7],i.coffs[8],s.z,0,0,0,1,e)}static createIdentity(t){return(t=zt.createZero(t))._coffs[0]=1,t._coffs[5]=1,t._coffs[10]=1,t._coffs[15]=1,t}static createTranslationXYZ(t,e,i,s){return(s=zt.createZero(s))._coffs[0]=1,s._coffs[5]=1,s._coffs[10]=1,s._coffs[15]=1,s._coffs[3]=t,s._coffs[7]=e,s._coffs[11]=i,s}plusScaled(t,e,i){i=this.clone(i);for(let s=0;s<16;s++)i._coffs[s]+=e*t._coffs[s];return i}static createTranslationAndScaleXYZ(t,e,i,s,n,r,o){return zt.createRowValues(s,0,0,t,0,n,0,e,0,0,r,i,0,0,0,1,o)}static createBoxToBox(t,e,i,s,n){const r=e.x-t.x,o=e.y-t.y,a=e.z-t.z,c=s.x-i.x,h=s.y-i.y,l=s.z-i.z,d=K.conditionalDivideFraction(c,r),u=K.conditionalDivideFraction(h,o),f=K.conditionalDivideFraction(l,a);if(void 0!==d&&void 0!==u&&void 0!==f)return zt.createTranslationAndScaleXYZ(i.x-d*t.x,i.y-u*t.y,i.z-f*t.z,d,u,f,n)}setFromJSON(t){if(K.isArrayOfNumberArray(t,4,4))for(let e=0;e<4;++e)for(let i=0;i<4;++i)this._coffs[4*e+i]=t[e][i];else this.setZero()}maxDiff(t){let e=0;for(let i=0;i<16;i++)e=Math.max(e,Math.abs(this._coffs[i]-t._coffs[i]));return e}maxAbs(){let t=0;for(let e=0;e<16;e++)t=Math.max(t,Math.abs(this._coffs[e]));return t}isAlmostEqual(t){return K.isSmallMetricDistance(this.maxDiff(t))}isExactEqual(t){return 0===this.maxDiff(t)}toJSON(){const t=[];for(let e=0;e<4;++e){const i=4*e;t.push([this._coffs[i],this._coffs[i+1],this._coffs[i+2],this._coffs[i+3]])}return t}static fromJSON(t){const e=new zt;return e.setFromJSON(t),e}getSteppedPoint(t,e,i){return Rt.create(this._coffs[t],this._coffs[t+e],this._coffs[t+2*e],this._coffs[t+3*e],i)}columnX(){return this.getSteppedPoint(0,4)}columnY(){return this.getSteppedPoint(1,4)}columnZ(){return this.getSteppedPoint(2,4)}columnW(){return this.getSteppedPoint(3,4)}rowX(){return this.getSteppedPoint(0,1)}rowY(){return this.getSteppedPoint(4,1)}rowZ(){return this.getSteppedPoint(8,1)}rowW(){return this.getSteppedPoint(12,1)}get hasPerspective(){return 0!==this._coffs[12]||0!==this._coffs[13]||0!==this._coffs[14]||1!==this._coffs[15]}diagonal(){return this.getSteppedPoint(0,5)}weight(){return this._coffs[15]}matrixPart(){return xt.createRowValues(this._coffs[0],this._coffs[1],this._coffs[2],this._coffs[4],this._coffs[5],this._coffs[6],this._coffs[8],this._coffs[9],this._coffs[10])}get asTransform(){if(!this.hasPerspective)return pt.createRowValues(this._coffs[0],this._coffs[1],this._coffs[2],this._coffs[3],this._coffs[4],this._coffs[5],this._coffs[6],this._coffs[7],this._coffs[8],this._coffs[9],this._coffs[10],this._coffs[11])}multiplyMatrixMatrix(t,e){e=e&&e!==this&&e!==t?e:new zt;for(let i=0;i<16;i+=4)for(let s=0;s<4;s++)e._coffs[i+s]=this._coffs[i]*t._coffs[s]+this._coffs[i+1]*t._coffs[s+4]+this._coffs[i+2]*t._coffs[s+8]+this._coffs[i+3]*t._coffs[s+12];return e}multiplyMatrixMatrixTranspose(t,e){e=e&&e!==this&&e!==t?e:new zt;let i=0;for(let s=0;s<16;s+=4)for(let n=0;n<16;n+=4)e._coffs[i++]=this._coffs[s]*t._coffs[n]+this._coffs[s+1]*t._coffs[n+1]+this._coffs[s+2]*t._coffs[n+2]+this._coffs[s+3]*t._coffs[n+3];return e}multiplyMatrixTransposeMatrix(t,e){e=e&&e!==this&&e!==t?e:new zt;let i=0;for(let s=0;s<4;s+=1)for(let n=0;n<4;n+=1)e._coffs[i++]=this._coffs[s]*t._coffs[n]+this._coffs[s+4]*t._coffs[n+4]+this._coffs[s+8]*t._coffs[n+8]+this._coffs[s+12]*t._coffs[n+12];return e}cloneTransposed(t){return zt.createRowValues(this._coffs[0],this._coffs[4],this._coffs[8],this._coffs[12],this._coffs[1],this._coffs[5],this._coffs[9],this._coffs[13],this._coffs[2],this._coffs[6],this._coffs[10],this._coffs[14],this._coffs[3],this._coffs[7],this._coffs[11],this._coffs[15],t)}multiplyXYZW(t,e,i,s,n){return(n=n||Rt.createZero()).set(this._coffs[0]*t+this._coffs[1]*e+this._coffs[2]*i+this._coffs[3]*s,this._coffs[4]*t+this._coffs[5]*e+this._coffs[6]*i+this._coffs[7]*s,this._coffs[8]*t+this._coffs[9]*e+this._coffs[10]*i+this._coffs[11]*s,this._coffs[12]*t+this._coffs[13]*e+this._coffs[14]*i+this._coffs[15]*s)}multiplyBlockedFloat64ArrayInPlace(t){const e=t.length;let i,s,n,r;for(let o=0;o+3<e;o+=4)i=t[o],s=t[o+1],n=t[o+2],r=t[o+3],t[o]=this._coffs[0]*i+this._coffs[1]*s+this._coffs[2]*n+this._coffs[3]*r,t[o+1]=this._coffs[4]*i+this._coffs[5]*s+this._coffs[6]*n+this._coffs[7]*r,t[o+2]=this._coffs[8]*i+this._coffs[9]*s+this._coffs[10]*n+this._coffs[11]*r,t[o+3]=this._coffs[12]*i+this._coffs[13]*s+this._coffs[14]*n+this._coffs[15]*r}multiplyPoint3d(t,e,i){return this.multiplyXYZW(t.x,t.y,t.z,e,i)}multiplyPoint3dArray(t,e,i=1){t.forEach(((t,s)=>{e[s]=this.multiplyXYZW(t.x,t.y,t.z,i,e[s])}))}multiplyTransposeXYZW(t,e,i,s,n){return(n=n||Rt.createZero()).set(this._coffs[0]*t+this._coffs[4]*e+this._coffs[8]*i+this._coffs[12]*s,this._coffs[1]*t+this._coffs[5]*e+this._coffs[9]*i+this._coffs[13]*s,this._coffs[2]*t+this._coffs[6]*e+this._coffs[10]*i+this._coffs[14]*s,this._coffs[3]*t+this._coffs[7]*e+this._coffs[11]*i+this._coffs[15]*s)}rowDotColumn(t,e,i){const s=4*t,n=i;return this._coffs[s]*e._coffs[n]+this._coffs[s+1]*e._coffs[n+4]+this._coffs[s+2]*e._coffs[n+8]+this._coffs[s+3]*e._coffs[n+12]}rowDotXYZW(t,e,i,s,n){const r=4*t;return this._coffs[r]*e+this._coffs[r+1]*i+this._coffs[r+2]*s+this._coffs[r+3]*n}rowDotRow(t,e,i){const s=4*t,n=4*i;return this._coffs[s]*e._coffs[n]+this._coffs[s+1]*e._coffs[n+1]+this._coffs[s+2]*e._coffs[n+2]+this._coffs[s+3]*e._coffs[n+3]}columnDotColumn(t,e,i){const s=t,n=i;return this._coffs[s]*e._coffs[n]+this._coffs[s+4]*e._coffs[n+4]+this._coffs[s+8]*e._coffs[n+8]+this._coffs[s+12]*e._coffs[n+12]}columnDotRow(t,e,i){const s=t,n=4*i;return this._coffs[s]*e._coffs[n]+this._coffs[s+4]*e._coffs[n+1]+this._coffs[s+8]*e._coffs[n+2]+this._coffs[s+12]*e._coffs[n+3]}atIJ(t,e){return this._coffs[4*t+e]}setAtIJ(t,e,i){this._coffs[4*t+e]=i}multiplyXYZWQuietRenormalize(t,e,i,s,n){(n=n||Q.createZero()).set(this._coffs[0]*t+this._coffs[1]*e+this._coffs[2]*i+this._coffs[3]*s,this._coffs[4]*t+this._coffs[5]*e+this._coffs[6]*i+this._coffs[7]*s,this._coffs[8]*t+this._coffs[9]*e+this._coffs[10]*i+this._coffs[11]*s);const r=this._coffs[12]*t+this._coffs[13]*e+this._coffs[14]*i+this._coffs[15]*s,o=K.conditionalDivideCoordinate(n.x,r),a=K.conditionalDivideCoordinate(n.y,r),c=K.conditionalDivideCoordinate(n.z,r);return void 0!==o&&void 0!==a&&void 0!==c&&(n.x=o,n.y=a,n.z=c),n}multiplyPoint4dArrayQuietRenormalize(t,e){t.forEach(((t,i)=>{e[i]=this.multiplyXYZWQuietRenormalize(t.x,t.y,t.z,t.w,e[i])}))}multiplyPoint4d(t,e){return this.multiplyXYZW(t.xyzw[0],t.xyzw[1],t.xyzw[2],t.xyzw[3],e)}multiplyTransposePoint4d(t,e){return this.multiplyTransposeXYZW(t.xyzw[0],t.xyzw[1],t.xyzw[2],t.xyzw[3],e)}multiplyPoint3dQuietNormalize(t,e){return this.multiplyXYZWQuietRenormalize(t.x,t.y,t.z,1,e)}multiplyPoint3dArrayQuietNormalize(t){t.forEach((t=>this.multiplyXYZWQuietRenormalize(t.x,t.y,t.z,1,t)))}addMomentsInPlace(t,e,i,s){this._coffs[0]+=t*t,this._coffs[1]+=t*e,this._coffs[2]+=t*i,this._coffs[3]+=t*s,this._coffs[4]+=e*t,this._coffs[5]+=e*e,this._coffs[6]+=e*i,this._coffs[7]+=e*s,this._coffs[8]+=i*t,this._coffs[9]+=i*e,this._coffs[10]+=i*i,this._coffs[11]+=i*s,this._coffs[12]+=s*t,this._coffs[13]+=s*e,this._coffs[14]+=s*i,this._coffs[15]+=s*s}addScaledInPlace(t,e=1){for(let i=0;i<16;i++)this._coffs[i]+=e*t._coffs[i]}rowOperation(t,e,i,s){if(0===s)return;let n=4*t+i,r=4*e+i;for(let t=i;t<4;t++,n++,r++)this._coffs[r]+=s*this._coffs[n]}determinant(){const t=this._coffs;return K.determinant4x4(t[0],t[1],t[2],t[3],t[4],t[5],t[6],t[7],t[8],t[9],t[10],t[11],t[12],t[13],t[14],t[15])}createInverse(t){let e=this.columnX().maxAbs();if(0===e)return;const i=1/e;if(e=this.columnY().maxAbs(),0===e)return;const s=1/e;if(e=this.columnZ().maxAbs(),0===e)return;const n=1/e;if(e=this.columnW().maxAbs(),0===e)return;const r=1/e,o=this.columnX(),a=this.columnY(),c=this.columnZ(),h=this.columnW();o.scale(i,o),a.scale(s,a),c.scale(n,c),h.scale(r,h);const l=Rt.perpendicularPoint4dPlane(a,c,h),d=Rt.perpendicularPoint4dPlane(o,h,c),u=Rt.perpendicularPoint4dPlane(h,o,a),f=Rt.perpendicularPoint4dPlane(c,a,o);t=zt.createRows(l,d,u,f,t);const g=l.dotProduct(o),p=d.dotProduct(a),m=u.dotProduct(c),x=f.dotProduct(h),y=t.maxAbs();if(g*p>0&&g*m>0&&g*x>0&&void 0!==K.conditionalDivideCoordinate(y,g)){const e=1/g;return t.scaleRowsInPlace(i*e,s*e,n*e,r*e),t}}rowArrays(t){return t?[[t(this._coffs[0]),t(this._coffs[1]),t(this._coffs[2]),t(this._coffs[3])],[t(this._coffs[4]),t(this._coffs[5]),t(this._coffs[6]),t(this._coffs[7])],[t(this._coffs[8]),t(this._coffs[9]),t(this._coffs[10]),t(this._coffs[11])],[t(this._coffs[12]),t(this._coffs[13]),t(this._coffs[14]),t(this._coffs[15])]]:[[this._coffs[0],this._coffs[1],this._coffs[2],this._coffs[3]],[this._coffs[4],this._coffs[5],this._coffs[6],this._coffs[7]],[this._coffs[8],this._coffs[9],this._coffs[10],this._coffs[11]],[this._coffs[12],this._coffs[13],this._coffs[14],this._coffs[15]]]}scaleRowsInPlace(t,e,i,s){for(let e=0;e<4;e++)this._coffs[e]*=t;for(let t=4;t<8;t++)this._coffs[t]*=e;for(let t=8;t<12;t++)this._coffs[t]*=i;for(let t=12;t<16;t++)this._coffs[t]*=s}addScaledOuterProductInPlace(t,e,i){let s=t.x*i;this._coffs[0]+=s*e.x,this._coffs[1]+=s*e.y,this._coffs[2]+=s*e.z,this._coffs[3]+=s*e.w,s=t.y*i,this._coffs[4]+=s*e.x,this._coffs[5]+=s*e.y,this._coffs[6]+=s*e.z,this._coffs[7]+=s*e.w,s=t.z*i,this._coffs[8]+=s*e.x,this._coffs[9]+=s*e.y,this._coffs[10]+=s*e.z,this._coffs[11]+=s*e.w,s=t.w*i,this._coffs[12]+=s*e.x,this._coffs[13]+=s*e.y,this._coffs[14]+=s*e.z,this._coffs[15]+=s*e.w}addTranslationSandwichInPlace(t,e,i,s,n){const r=t._coffs[3],o=t._coffs[7],a=t._coffs[11],c=t._coffs[12],h=t._coffs[13],l=t._coffs[14],d=t._coffs[15],u=e*d,f=i*d,g=s*d;this._coffs[0]+=n*(t._coffs[0]+e*r+c*e+e*u),this._coffs[1]+=n*(t._coffs[1]+i*r+h*e+e*f),this._coffs[2]+=n*(t._coffs[2]+s*r+l*e+e*g),this._coffs[3]+=n*(r+u),this._coffs[4]+=n*(t._coffs[4]+e*o+c*i+i*u),this._coffs[5]+=n*(t._coffs[5]+i*o+h*i+i*f),this._coffs[6]+=n*(t._coffs[6]+s*o+l*i+i*g),this._coffs[7]+=n*(o+f),this._coffs[8]+=n*(t._coffs[8]+e*a+c*s+s*u),this._coffs[9]+=n*(t._coffs[9]+i*a+h*s+s*f),this._coffs[10]+=n*(t._coffs[10]+s*a+l*s+s*g),this._coffs[11]+=n*(a+g),this._coffs[12]+=n*(c+u),this._coffs[13]+=n*(h+f),this._coffs[14]+=n*(l+g),this._coffs[15]+=n*d}multiplyTranslationSandwichInPlace(t,e,i){const s=this._coffs[3],n=this._coffs[7],r=this._coffs[11],o=this._coffs[12],a=this._coffs[13],c=this._coffs[14],h=this._coffs[15],l=t*h,d=e*h,u=i*h;this._coffs[0]+=t*s+o*t+t*l,this._coffs[1]+=e*s+a*t+t*d,this._coffs[2]+=i*s+c*t+t*u,this._coffs[3]+=l,this._coffs[4]+=t*n+o*e+e*l,this._coffs[5]+=e*n+a*e+e*d,this._coffs[6]+=i*n+c*e+e*u,this._coffs[7]+=d,this._coffs[8]+=t*r+o*i+i*l,this._coffs[9]+=e*r+a*i+i*d,this._coffs[10]+=i*r+c*i+i*u,this._coffs[11]+=u,this._coffs[12]+=l,this._coffs[13]+=d,this._coffs[14]+=u}}class Dt{constructor(t,e){this.xTest=t,this.yTest=e,this.u0=this.v0=this.u1=this.v1=0,this.numLeftCrossing=this.numRightCrossing=0,this.numHit=0}tryStartEdge(t,e,i,s){return e!==this.yTest&&(this.u0=t-this.xTest,this.v0=e-this.yTest,this.u1=i-this.xTest,this.v1=s-this.yTest,!0)}advance(t,e){const i=t-this.xTest,s=e-this.yTest,n=s*this.v1;if(n>0)return this.u0=this.u1,this.v0=this.v1,this.u1=i,this.v1=s,!0;if(n<0){const t=-this.v1/(s-this.v1),e=this.u1+t*(i-this.u1);return 0===e?(this.numHit++,!1):(e>0?this.numRightCrossing++:this.numLeftCrossing++,this.u0=this.u1,this.v0=this.v1,this.u1=i,this.v1=s,!0)}if(0===s)return 0===this.v1?i*this.u1<=0?(this.numHit++,!1):(this.u1=i,this.v1=s,!0):(this.u0=this.u1,this.v0=this.v1,this.u1=i,this.v1=s,!0);const r=this.v0*s;return this.u1>0?r<0&&this.numRightCrossing++:r<0&&this.numLeftCrossing++,this.u0=this.u1,this.v0=this.v1,this.u1=i,this.v1=s,!0}classifyCounts(){return this.numHit>0?0:1==(1&this.numLeftCrossing)?1:-1}}class Yt{constructor(t,e,i,s,n){this.numStroke=t,this.curveLength=e,this.a0=i,this.a1=s,this.componentData=n}static createWithCurvePrimitive(t,e,i,s,n,r){const o=new Yt(e,i,s,n,r);return o.primitive=t,o}static createWithComponentIndex(t=0,e=0,i=0,s=0,n=0){const r=new Yt(e,i,s,n);return r.componentIndex=t,r}static createWithCurvePrimitiveAndOptionalParent(t,e,i){const s=e?e.a1:0,n=new Yt(0,0,s,s,i);return n.primitive=t,n}addToCountAndLength(t,e){const i=this.a1+e;this.componentData&&this.componentData.push(new Yt(t,e,this.a1,i)),this.numStroke+=t,this.curveLength+=e,this.a1=i}isCompatibleComponentStructure(t,e){if(e&&this.numStroke!==t.numStroke)return!1;if(void 0===this.componentData&&void 0===t.componentData)return!0;if(this.componentData&&t.componentData){if(this.componentData.length!==t.componentData.length)return!1;const i=this.componentData.length;for(let s=0;s<i;s++)if(!this.componentData[s].isCompatibleComponentStructure(t.componentData[s],e))return!1;return!0}return!1}clone(){const t=new Yt(this.numStroke,this.curveLength,this.a0,this.a1);if(this.componentData){t.componentData=[];for(const e of this.componentData)t.componentData.push(e.clone())}return t}fractionToA(t){return K.interpolate(this.a0,t,this.a1)}}class Nt{range(t,e){e&&e.setNull();const i=e||ut.createNull();return this.extendRange(i,t),i}tryTranslateInPlace(t,e=0,i=0){return this.tryTransformInPlace(pt.createTranslationXYZ(t,e,i))}get children(){}isAlmostEqual(t){if(this.isSameGeometryClass(t)){const e=this.children,i=t.children;if(e&&i){if(e.length!==i.length)return!1;for(let t=0;t<e.length;t++)if(!e[t].isAlmostEqual(i[t]))return!1;return!0}return!e&&!i}return!1}static areAlmostEqual(t,e){return t instanceof Nt&&e instanceof Nt?t.isAlmostEqual(e):void 0===t&&void 0===e}}class Ot{static getRow(t){const e=Ot._allRows;for(0===e.length&&(e.push(new Float64Array([1])),e.push(new Float64Array([1,1])),e.push(new Float64Array([1,2,1])),e.push(new Float64Array([1,3,3,1])),e.push(new Float64Array([1,4,6,4,1])),e.push(new Float64Array([1,5,10,10,5,1])),e.push(new Float64Array([1,6,15,20,15,6,1])),e.push(new Float64Array([1,7,21,35,35,21,7,1])));e.length<=t;){const t=e.length,i=e[t-1],s=new Float64Array(t+1);s[0]=1;for(let e=1;e<t;e++)s[e]=i[e-1]+i[e];s[t]=1,e.push(s)}return e[t]}static getBezierBasisValues(t,e,i){const s=t-1,n=Ot.getRow(s);(void 0===i||i.length<t)&&(i=new Float64Array(t));for(let e=0;e<t;e++)i[e]=n[e];let r=e;for(let s=1;s<t;s++,r*=e)i[s]*=r;const o=1-e;r=o;for(let e=t-2;e>=0;e--,r*=o)i[e]*=r;return i}static getBezierBasisDerivatives(t,e,i){const s=t-1;(i=this.getBezierBasisValues(t-1,e,i))[t-1]=s*i[t-2];for(let e=t-2;e>0;e--)i[e]=s*(i[e-1]-i[e]);return i[0]=-s*i[0],i}}Ot._allRows=[];class Bt{constructor(t){if(t instanceof Float64Array)this.coffs=t.slice();else if(Array.isArray(t)){this.coffs=new Float64Array(t.length);let e=0;for(const i of t)this.coffs[e++]=i}else this.coffs=new Float64Array(t)}allocateToOrder(t){this.coffs.length!==t?this.coffs=new Float64Array(t):this.coffs.fill(0)}createPeer(){return new Lt(this.order)}get order(){return this.coffs.length}copyFrom(t){if(this.order===t.order)for(let e=0;e<this.coffs.length;e++)this.coffs[e]=t.coffs[e];else this.coffs=t.coffs.slice()}scaleInPlace(t){for(let e=0;e<this.coffs.length;e++)this.coffs[e]*=t}addInPlace(t){for(let e=0;e<this.coffs.length;e++)this.coffs[e]+=t}roots(t,e){const i=Lt.create(this);return i.addInPlace(-t),Lt.deflateRoots01(i)}filter01(t,e=!1){if(!t||!e)return t;let i=!1;for(const e of t)if(K.isIn01(e)){i=!0;break}if(i){const e=[];for(const i of t)K.isIn01(i)&&e.push(i);return e}}zero(){this.coffs.fill(0)}subdivide(t,e,i){const s=this.order;if(e.order!==s||i.order!==s)return!1;const n=1-t;i.copyFrom(this);let r=s-1;for(let o=0;o<s;o++){e.coffs[o]=i.coffs[0];for(let e=0;e<r;e++)i.coffs[e]=n*i.coffs[e]+t*i.coffs[e+1];r--}return!0}static maxAbsDiff(t,e){const i=t.order;if(e.order!==i)return;let s,n=0;for(let r=0;r<i;r++)s=Math.abs(t.coffs[r]-e.coffs[r]),s>n&&(n=s);return n}}class Vt{static accumulateScaledShiftedComponentTimesComponentDelta(t,e,i,s,n,r,o,a){const c=s-1,h=s,l=s+c-1;if(t.length!==l)return;const d=Ot.getRow(h-1),u=Ot.getRow(c-1),f=Ot.getRow(l-1);let g;for(let s=0;s<h;s++){g=n*(o+e[r+s*i])*d[s];for(let n=0,r=a;n<c;n++,r+=i)t[s+n]+=g*u[n]*(e[r+i]-e[r])/f[s+n]}}static scaledComponentSum(t,e,i,s,n,r,o,a){const c=s;if(t.length===c)for(let s=0,h=0;s<c;s++,h+=i)t[s]=r*e[h+n]+a*e[h+o]}static componentDifference(t,e,i,s,n){const r=s-1;if(t.length===r)for(let s=0,o=n;s<r;o+=i,s++)t[s]=e[o+i]-e[o]}static accumulateProduct(t,e,i,s=1){const n=e.length,r=i.length,o=n+r-1;if(t.length!==o)return;let a,c,h;const l=Ot.getRow(n-1),d=Ot.getRow(r-1),u=Ot.getRow(o-1);for(a=0;a<n;a++)for(h=s*l[a]*e[a],c=0;c<r;c++)t[a+c]+=h*d[c]*i[c]/u[a+c]}static accumulateProductWithDifferences(t,e,i,s=1){const n=e.length-1,r=i.length,o=n+r-1;if(t.length!==o)return;let a,c,h;const l=Ot.getRow(n-1),d=Ot.getRow(r-1),u=Ot.getRow(o-1);for(a=0;a<n;a++)for(h=s*l[a]*(e[a+1]-e[a]),c=0;c<r;c++)t[a+c]+=h*d[c]*i[c]/u[a+c]}static univariateDifference(t,e){const i=e.length;if(e.length+1!==i)for(let s=0;s<i;s++)e[s]=t[s+1]-t[s]}static accumulate(t,e,i){if(i.length===e)for(let s=0;s<e;s++)i[s]+=t[s]}}class Lt extends Bt{get order(){return this._order}constructor(t){super(t),this._order=super.order}allocateOrder(t){this._order!==t&&(super.allocateToOrder(t),this._order=t),this.coffs.fill(0)}clone(t=!1){if(t){const t=new Lt(this.order);return t.coffs=this.coffs.slice(0,this.order),t}const e=new Lt(this.coffs.length);return e._order=this._order,e.coffs=this.coffs.slice(),e}static create(t){const e=new Lt(t.order);return e.coffs=t.coffs.slice(),e}static createCoffs(t){return new Lt(t)}static createArraySubset(t,e,i,s){s?s.order!==i&&s.allocateToOrder(i):s=new Lt(i);for(let n=0;n<i;n++)s.coffs[n]=t[e+n];return s}static createProduct(t,e){const i=new Lt(t.order+e.order-1),s=Ot.getRow(t.order-1),n=Ot.getRow(e.order-1),r=Ot.getRow(t.order+e.order-2);for(let o=0;o<t.order;o++){const a=t.coffs[o]*s[o];for(let t=0;t<e.order;t++){const s=e.coffs[t]*n[t],c=o+t,h=r[c];i.coffs[c]+=a*s/h}}return i}addSquaredSquaredBezier(t,e){const i=t.length,s=this.order;if(2*i!==s+1)return!1;const n=Ot.getRow(i-1),r=Ot.getRow(s-1),o=this.coffs;for(let s=0;s<i;s++){const a=t[s]*n[s]*e;for(let e=0;e<i;e++){const i=t[e]*n[e],c=s+e,h=r[c];o[c]+=a*i/h}}return!0}addConstant(t){for(let e=0;e<this.coffs.length;e++)this.coffs[e]+=t}basisFunctions(t,e){this._basisValues=Ot.getBezierBasisValues(this.order,t,this._basisValues),e&&e.length===this.order||(e=new Float64Array(this.order));let i=0;for(const t of this._basisValues)e[i++]=t;return e}static sumWeightedBlocks(t,e,i,s,n){for(let t=0;t<s;t++)n[t]=0;let r,o=0;for(let a=0;a<e;a++){const e=t[a];for(r=0;r<s;r++)n[r]+=e*i[o++]}}sumBasisFunctions(t,e,i,s){const n=this._order;return s||(s=new Float64Array(n)),this._basisValues=Ot.getBezierBasisValues(this.order,t,this._basisValues),Lt.sumWeightedBlocks(this._basisValues,n,e,i,s),s}sumBasisFunctionDerivatives(t,e,i,s){const n=this._order;return s||(s=new Float64Array(i)),this._basisValues=Ot.getBezierBasisDerivatives(this.order,t,this._basisValues),Lt.sumWeightedBlocks(this._basisValues,n,e,i,s),s}evaluate(t){this._basisValues=Ot.getBezierBasisValues(this.order,t,this._basisValues);let e=0;for(let t=0;t<this.order;t++)e+=this._basisValues[t]*this.coffs[t];return e}deflateLeft(){const t=this.order,e=t-1,i=Ot.getRow(e-1),s=Ot.getRow(t-1);let n;for(let t=0;t<e;t++)n=this.coffs[t+1],this.coffs[t]=n*s[t+1]/i[t];this._order--}deflateRight(){const t=this.order,e=t-1,i=Ot.getRow(e-1),s=Ot.getRow(t-1);let n,r;for(let t=0;t<e;t++)n=this.coffs[t],r=n*s[t]/i[t],this.coffs[t]=r;this._order--}deflateRoot(t){const e=this.order,i=e-1;if(1===e)return this._order=0,this.coffs[0];if(e<1)return this._order=0,0;const s=Ot.getRow(e-1),n=Ot.getRow(i-1),r=-t,o=1-t;let a=0;if(t>.5){let t,c,h=this.coffs[0]/r;this.coffs[0]=h;for(let e=1;e<i;e++)c=this.coffs[e]*s[e],t=(c-h*o)/r,this.coffs[e]=t/n[e],h=t;a=this.coffs[e-1]-h*o}else{let t,c,h=this.coffs[e-1]/o;this.coffs[e-1]=h;for(let i=e-2;i>0;i--)c=this.coffs[i]*s[i],t=(c-h*r)/o,this.coffs[i]=t/n[i-1],h=t;a=this.coffs[0]-h*r;for(let t=0;t<i;t++)this.coffs[t]=this.coffs[t+1]}return this._order=i,a}runNewton(t,e=1e-11){const i=this.order-1;let s,n,r=0,o=t;const a=this.order,c=this.coffs,h=a-1;for(let t=0;t++<10;){Lt._basisBuffer=Ot.getBezierBasisValues(a,o,Lt._basisBuffer),s=0;for(let t=0;t<a;t++)s+=c[t]*Lt._basisBuffer[t];Lt._basisBuffer1=Ot.getBezierBasisValues(h,o,Lt._basisBuffer1),n=0;for(let t=0;t<h;t++)n+=(c[t+1]-c[t])*Lt._basisBuffer1[t];if(n*=i,Math.abs(s)>10*Math.abs(n))return;const t=s/n;if(Math.abs(t)<e){if(r++,r>=2)return o-t}else r=0;o-=t}}static deflateRoots01(t){const e=[],i=t.coffs;let s,n,r,o,a;for(;t.order>1;){const c=t.order;if(0===i[0]){t.deflateLeft(),e.push(0);continue}let h=0,l=0;for(let d=1;d<c;d++)if(s=i[d-1],n=i[d],s*n<=0&&(h++,r=-s/(n-s),o=(d-1+r)/(c-1),a=t.runNewton(o,1e-10),void 0!==a)){e.push(a),t.deflateRoot(a),l++;break}if(!l)return e}return e}}class Ut extends Bt{constructor(t=0,e=0){super(2),this.coffs[0]=t,this.coffs[1]=e}clone(){return new Ut(this.coffs[0],this.coffs[1])}static solveCoffs(t,e){return K.conditionalDivideFraction(-t,e-t)}basisFunctions(t,e){return e||(e=new Float64Array(2)),e[0]=1-t,e[1]=t,e}sumBasisFunctions(t,e,i,s){s||(s=new Float64Array(i));const n=1-t;for(let r=0;r<i;r++)s[r]=n*e[r]+t*e[r+i];return s}sumBasisFunctionDerivatives(t,e,i,s){s||(s=new Float64Array(i));for(let t=0;t<i;t++)s[t]=e[t+i]-e[t];return s}evaluate(t){return(1-t)*this.coffs[0]+t*this.coffs[1]}solve(t){const e=this.coffs[1]-this.coffs[0];return K.conditionalDivideFraction(t-this.coffs[0],e)}roots(t,e){const i=this.solve(t);if(void 0!==i)return!e||K.isIn01(i)?[i]:void 0}}class Zt{constructor(t=1e-11,e=2,i=15){this._numAccepted=0,this.numIterations=0,this._stepSizeTolerance=t,this._successiveConvergenceTarget=e,this._maxIterations=i}testConvergence(t){return Math.abs(t)<this._stepSizeTolerance?(this._numAccepted++,this._numAccepted>=this._successiveConvergenceTarget):(this._numAccepted=0,!1)}runIterations(){for(this._numAccepted=0,this.numIterations=0;this.numIterations++<this._maxIterations&&this.computeStep();){if(this.testConvergence(this.currentStepSize())&&this.applyCurrentStep(!0))return!0;this.applyCurrentStep(!1)}return!1}}class qt{}class Wt extends Zt{constructor(t){super(),this._func=t,this.derivativeH=1e-8}setX(t){return this._currentX=t,!0}getX(){return this._currentX}applyCurrentStep(){return this.setX(this._currentX-this._currentStep)}computeStep(){if(this._func.evaluate(this._currentX)){const t=this._func.currentF;if(this._func.evaluate(this._currentX+this.derivativeH)){const e=this._func.currentF,i=K.conditionalDivideFraction(t,(e-t)/this.derivativeH);if(void 0!==i)return this._currentStep=i,!0}}return!1}currentStepSize(){return Math.abs(this._currentStep/(1+Math.abs(this._currentX)))}}class Gt{constructor(){this.currentF=Et.createXYPlane()}}class Ht extends Zt{constructor(t){super(),this._func=t,this._currentStep=J.createZero(),this._currentUV=H.createZero()}setUV(t,e){return this._currentUV.set(t,e),!0}getU(){return this._currentUV.x}getV(){return this._currentUV.y}applyCurrentStep(){return this.setUV(this._currentUV.x-this._currentStep.x,this._currentUV.y-this._currentStep.y)}computeStep(){if(this._func.evaluate(this._currentUV.x,this._currentUV.y)){const t=this._func.currentF;if(Ft.linearSystem2d(t.vectorU.x,t.vectorV.x,t.vectorU.y,t.vectorV.y,t.origin.x,t.origin.y,this._currentStep))return!0}return!1}currentStepSize(){return K.maxAbsXY(this._currentStep.x/(1+Math.abs(this._currentUV.x)),this._currentStep.y/(1+Math.abs(this._currentUV.y)))}}class Jt extends qt{constructor(){super(),this._parentCurvePrimitive=void 0}startParentCurvePrimitive(t){this._parentCurvePrimitive=t}endParentCurvePrimitive(t){this._parentCurvePrimitive=void 0}}class Kt extends Jt{effectiveCurve(){return this._parentCurvePrimitive?this._parentCurvePrimitive:this._curve}get getDerivativeB(){return this._derivativeB}constructor(t,e){super(),this._fractionA=0,this._functionA=0,this._functionB=0,this._fractionB=0,this._derivativeB=0,this._numThisCurve=0,this._plane=t,this._intersections=e,this.startCurvePrimitive(void 0),this._ray=bt.createZero(),this._newtonSolver=new Wt(this)}startCurvePrimitive(t){this._curve=t,this._fractionA=0,this._numThisCurve=0,this._functionA=0}endCurvePrimitive(){}announceIntervalForUniformStepStrokes(t,e,i,s){this.startCurvePrimitive(t),e<1&&(e=1);const n=1/e;for(let r=0;r<=e;r++){const e=K.interpolate(i,r*n,s);t.fractionToPointAndDerivative(e,this._ray),this.announcePointTangent(this._ray.origin,e,this._ray.direction)}}announceSegmentInterval(t,e,i,s,n,r){const o=this._plane.altitude(e),a=this._plane.altitude(i);if(o*a>0)return;const c=Ut.solveCoffs(o,a);if(void 0!==c){const t=K.interpolate(n,c,r);this._newtonSolver.setX(t),this._newtonSolver.runIterations()&&this.announceSolutionFraction(this._newtonSolver.getX())}}announceSolutionFraction(t){const e=this.effectiveCurve();e&&(this._ray=e.fractionToPointAndDerivative(t,this._ray),this._intersections.push(vt.createCurveFractionPoint(e,t,this._ray.origin)))}evaluate(t){const e=this.effectiveCurve();return!!e&&(this.currentF=this._plane.altitude(e.fractionToPoint(t)),!0)}searchInterval(){if(!(this._functionA*this._functionB>0)&&(0===this._functionA&&this.announceSolutionFraction(this._fractionA),0===this._functionB&&this.announceSolutionFraction(this._fractionB),this._functionA*this._functionB<0)){const t=K.inverseInterpolate(this._fractionA,this._functionA,this._fractionB,this._functionB);t&&(this._newtonSolver.setX(t),this._newtonSolver.runIterations()&&this.announceSolutionFraction(this._newtonSolver.getX()))}}evaluateB(t,e,i){this._functionB=this._plane.altitude(t),this._derivativeB=this._plane.velocity(i),this._fractionB=e}announcePointTangent(t,e,i){this.evaluateB(t,e,i),this._numThisCurve++>0&&this.searchInterval(),this._functionA=this._functionB,this._fractionA=this._fractionB}}!function(t){t[t.None=0]="None",t[t.OnTangent=1]="OnTangent",t[t.OnCurve=2]="OnCurve"}(w||(w={}));class jt{static resolveVariantCurveExtendParameterToCurveExtendMode(t,e){return!1===t?w.None:!0===t?w.OnCurve:Array.isArray(t)?t[e]:t}static correctFraction(t,e){return e<0?jt.resolveVariantCurveExtendParameterToCurveExtendMode(t,0)===w.None&&(e=0):e>1&&jt.resolveVariantCurveExtendParameterToCurveExtendMode(t,1)===w.None&&(e=1),e}static resolveRadiansToSweepFraction(t,e,i){let s=i.radiansToSignedPeriodicFraction(e);if(!i.isRadiansInSweep(e)){const n=i.fractionPeriod(),r=jt.resolveVariantCurveExtendParameterToCurveExtendMode(t,0),o=jt.resolveVariantCurveExtendParameterToCurveExtendMode(t,1);r!==w.None?o!==w.None?s=i.radiansToSignedPeriodicFraction(e):s>1&&(s-=n):o!==w.None?s<0&&(s+=n):s=K.clamp(s,0,1)}return s}}class Qt extends Jt{constructor(t,e){super(),this._fractionA=0,this._functionA=0,this._functionB=0,this._fractionB=0,this._numThisCurve=0,this._spacePoint=t,this._workPoint=Q.create(),this._workRay=bt.createZero(),this._closestPoint=void 0,this._extend=e,this.startCurvePrimitive(void 0),this._newtonSolver=new Wt(this)}claimResult(){if(this._closestPoint&&(this._newtonSolver.setX(this._closestPoint.fraction),this._curve=this._closestPoint.curve,this._newtonSolver.runIterations())){let t=this._newtonSolver.getX();t=jt.correctFraction(this._extend,t),this.announceSolutionFraction(t)}return this._closestPoint}needPrimaryGeometryForStrokes(){return!0}startCurvePrimitive(t){this._curve=t,this._fractionA=0,this._numThisCurve=0,this._functionA=0}endCurvePrimitive(){}announceIntervalForUniformStepStrokes(t,e,i,s){this.startCurvePrimitive(t),this.announceSolutionFraction(0),this.announceSolutionFraction(1),e<1&&(e=1);const n=1/e;for(let r=0;r<=e;r++){const e=K.interpolate(i,r*n,s);t.fractionToPointAndDerivative(e,this._workRay),this.announceRay(e,this._workRay)}}announceCandidate(t,e,i){const s=this._spacePoint.distance(i);this._closestPoint&&s>this._closestPoint.a||(this._closestPoint=vt.createCurveFractionPoint(t,e,i,this._closestPoint),this._closestPoint.a=s,void 0!==this._parentCurvePrimitive&&(this._closestPoint.curve=this._parentCurvePrimitive))}announceSegmentInterval(t,e,i,s,n,r){let o=this._spacePoint.fractionOfProjectionToLine(e,i,0);this._extend?(0!==n&&(o=Math.max(o,0)),1!==r&&(o=Math.min(o,1))):o=K.clampToStartEnd(o,0,1),this._workPoint=e.interpolate(o,i);const a=K.interpolate(n,o,r);this.announceCandidate(t,a,this._workPoint)}searchInterval(){if(!(this._functionA*this._functionB>0)&&(0===this._functionA&&this.announceSolutionFraction(this._fractionA),0===this._functionB&&this.announceSolutionFraction(this._fractionB),this._functionA*this._functionB<0)){const t=K.inverseInterpolate(this._fractionA,this._functionA,this._fractionB,this._functionB);t&&(this._newtonSolver.setX(t),this._newtonSolver.runIterations()&&this.announceSolutionFraction(this._newtonSolver.getX()))}}evaluateB(t,e){this._functionB=e.dotProductToPoint(this._spacePoint),this._fractionB=t}announceSolutionFraction(t){this._curve&&this.announceCandidate(this._curve,t,this._curve.fractionToPoint(t))}evaluate(t){let e=this._curve;return this._parentCurvePrimitive&&(e=this._parentCurvePrimitive),!!e&&(this._workRay=e.fractionToPointAndDerivative(t,this._workRay),this.currentF=this._workRay.dotProductToPoint(this._spacePoint),!0)}announceRay(t,e){this.evaluateB(t,e),this._numThisCurve++>0&&this.searchInterval(),this._functionA=this._functionB,this._fractionA=this._fractionB}announcePointTangent(t,e,i){this._workRay.set(t,i),this.announceRay(e,this._workRay)}}class $t{static mapWeights(t,e,i,s,n,r){const o=i.length;for(let a=0;a<o;a++)n[a]=t+e*i[a],r[a]=e*s[a];return o}static setupGauss1(t,e,i,s){return $t.mapWeights(t,e-t,$t.gaussX1Interval01,$t.gaussW1Interval01,i,s)}static setupGauss2(t,e,i,s){return $t.mapWeights(t,e-t,$t.gaussX2Interval01,$t.gaussW2Interval01,i,s)}static setupGauss3(t,e,i,s){return $t.mapWeights(t,e-t,$t.gaussX3Interval01,$t.gaussW3Interval01,i,s)}static setupGauss5(t,e,i,s){return $t.mapWeights(t,e-t,$t.gaussX5Interval01,$t.gaussW5Interval01,i,s)}static setupGauss4(t,e,i,s){return $t.mapWeights(t,e-t,$t.gaussX4Interval01,$t.gaussW4Interval01,i,s)}static sum1(t,e,i,s){let n=0;for(let r=0;r<i;r++)n+=e[r]*s(t[r]);return n}static doGaussIntegral(t,e,i,s,n=5){const r=new te(n);s<1&&(s=1);const o=1/s;let a=0;for(let n=1;n<=s;n++){const c=K.interpolate(t,(n-1)*o,e),h=n===s?e:K.interpolate(t,n*o,e),l=r.mapXAndW(c,h);for(let t=0;t<l;t++)a+=r.gaussW[t]*i(r.gaussX[t])}return a}}$t.gaussX1Interval01=new Float64Array([.5]),$t.gaussW1Interval01=new Float64Array([1]),$t.gaussX2Interval01=new Float64Array([.21132486540518708,.7886751345948129]),$t.gaussW2Interval01=new Float64Array([.5,.5]),$t.gaussX3Interval01=new Float64Array([.1127016653792583,.5,.8872983346207417]),$t.gaussW3Interval01=new Float64Array([.2777777777777778,.4444444444444444,.2777777777777778]),$t.gaussX4Interval01=new Float64Array([.06943184420297371,.33000947820757187,.6699905217924281,.9305681557970262]),$t.gaussW4Interval01=new Float64Array([.17392742256872692,.3260725774312731,.3260725774312731,.17392742256872692]),$t.gaussX5Interval01=new Float64Array([.04691007703066802,.23076534494715845,.5,.7692346550528415,.9530899229693319]),$t.gaussW5Interval01=new Float64Array([.11846344252809454,.23931433524968324,.28444444444444444,.23931433524968324,.11846344252809454]);class te{mapXAndW(t,e){return this.mapXAndWFunction(t,e,this.gaussX,this.gaussW)}constructor(t){switch(this.gaussX=new Float64Array(7),this.gaussW=new Float64Array(7),(t>5||t<1)&&(t=5),t){case 1:this.mapXAndWFunction=(t,e,i,s)=>$t.setupGauss1(t,e,i,s);break;case 2:this.mapXAndWFunction=(t,e,i,s)=>$t.setupGauss2(t,e,i,s);break;case 3:this.mapXAndWFunction=(t,e,i,s)=>$t.setupGauss3(t,e,i,s);break;case 4:this.mapXAndWFunction=(t,e,i,s)=>$t.setupGauss4(t,e,i,s);break;default:this.mapXAndWFunction=(t,e,i,s)=>$t.setupGauss5(t,e,i,s)}}}class ee{tangentMagnitude(t){return this._ray=this._curve.fractionToPointAndDerivative(t,this._ray),this._ray.direction.magnitude()}get getFraction0(){return this._fraction0}get getFraction1(){return this._fraction1}getSum(){return this._summedLength}constructor(t=0,e=1,i=5){this.startCurvePrimitive(void 0),this._summedLength=0,this._ray=bt.createZero(),t<e?(this._fraction0=t,this._fraction1=e):(this._fraction0=e,this._fraction1=t),this._gaussMapper=new te(i)}startCurvePrimitive(t){this._curve=t}startParentCurvePrimitive(t){}endParentCurvePrimitive(t){}endCurvePrimitive(){}announceIntervalForUniformStepStrokes(t,e,i,s){const n=ft.createXX(i,s);if(n.intersectRangeXXInPlace(this._fraction0,this._fraction1),!n.isNull){this.startCurvePrimitive(t),e<1&&(e=1);const i=1/e;for(let t=1;t<=e;t++){const s=n.fractionToPoint((t-1)*i),r=t===e?n.high:n.fractionToPoint(t*i),o=this._gaussMapper.mapXAndW(s,r);for(let t=0;t<o;t++)this._summedLength+=this._gaussMapper.gaussW[t]*this.tangentMagnitude(this._gaussMapper.gaussX[t])}}}announceSegmentInterval(t,e,i,s,n,r){const o=e.distance(i);if(this._fraction0<=n&&r<=this._fraction1)this._summedLength+=o;else{const t=ft.createXX(n,r);t.intersectRangeXXInPlace(this._fraction0,this._fraction1),t.isNull||(this._summedLength+=o*t.length()/(r-n))}}announcePointTangent(t,e,i){}}class ie extends Nt{constructor(){super(),this.geometryCategory="curvePrimitive"}fractionToPointAndUnitTangent(t,e){const i=this.fractionToPointAndDerivative(t,e);return i.trySetDirectionMagnitudeInPlace(1),i}fractionToCurvature(t){const e=this.fractionToPointAnd2Derivatives(t),i=e.vectorU.crossProduct(e.vectorV).magnitude(),s=e.vectorU.magnitude();return K.conditionalDivideFraction(i,s*s*s)}fractionToFrenetFrame(t,e){const i=this.fractionToPointAnd2Derivatives(t);if(!i)return;let s=xt.createRigidFromColumns(i.vectorU,i.vectorV,p.XYZ);if(s)return pt.createRefs(i.origin,s,e);const n=xt.createPerpendicularVectorFavorXYPlane(i.vectorU,i.vectorV);return s=xt.createRigidFromColumns(i.vectorU,n,p.XYZ),s?pt.createRefs(i.origin,s,e):void 0}fractionToSignedXYRadiusOfCurvature(t){const e=this.fractionToPointAnd2Derivatives(t);if(!e)return 0;const i=e.vectorU.crossProductXY(e.vectorV),s=e.vectorU.magnitude();if(0===s)return 0;const n=K.conditionalDivideCoordinate(s*s*s,i);return void 0!==n?n:0}fractionAndDistanceToPointOnTangent(t,e){return this.fractionToPointAndUnitTangent(t).fractionToPoint(e)}curveLength(){const t=new ee;return this.emitStrokableParts(t),t.getSum()}curveLengthBetweenFractions(t,e){if(t===e)return 0;if(void 0!==this.getFractionToDistanceScale()){const i=this.curveLength();return Math.abs((e-t)*i)}const i=new ee(t,e);return this.emitStrokableParts(i),Math.abs(i.getSum())}rangeBetweenFractions(t,e,i){return this.rangeBetweenFractionsByClone(t,e,i)}rangeBetweenFractionsByClone(t,e,i){if(t===e)return ut.create(this.fractionToPoint(t));const s=this.clonePartialCurve(t,e);return s?s.range(i):ut.createNull()}rangeBetweenFractionsByCount(t,e,i,s,n=0){const r=ut.createNull(),o=Q.create();r.extendPoint(this.startPoint(o)),r.extendPoint(this.endPoint(o));const a=(t,e,i)=>{let n=t;for(let t=0;t<i;t++,n+=e)this.fractionToPoint(n,o),s?r.extendTransformedPoint(s,o):r.extendPoint(o)},c=i-2;if(c>0){const i=1/(c+1)*(e-t);a(t+i,i,c)}if(n>0){const i=r.clone(),s=c+1,o=.5/s*2*(e-t);a(t+.5*o,o,s),r.extendWhenLarger(i,n)}return r}curveLengthWithFixedIntervalCountQuadrature(t,e,i,s=5){if(t>e){const i=t;t=e,e=i}const n=new ee(t,e,s);return n.announceIntervalForUniformStepStrokes(this,i,t,e),Math.abs(n.getSum())}moveSignedDistanceFromFraction(t,e,i,s){if(void 0!==this.getFractionToDistanceScale()){const n=this.curveLength(),r=K.conditionalDivideFraction(e,n);return void 0===r?vt.createCurveFractionPointDistanceCurveSearchStatus(this,t,this.fractionToPoint(t),0,A.error):vt.createConditionalMoveSignedDistance(i,this,t,t+r,e,s)}return this.moveSignedDistanceFromFractionGeneric(t,e,i,s)}moveSignedDistanceFromFractionGeneric(t,i,s,n){let r;if(0===i)return vt.createCurveEvaluatedFraction(this,t,n);if(i>0){if(r=1,t>=1){const e=.9;i+=this.curveLengthBetweenFractions(e,t),t=e}}else if(r=0,t<=0){const e=.1;i-=this.curveLengthBetweenFractions(t,e),t=e}const o=this.curveLengthBetweenFractions(t,r);e(o>0);const a=Math.abs(i);if(o<a&&!s)return vt.createConditionalMoveSignedDistance(s,this,t,r,i,n);const c=K.conditionalDivideCoordinate(a,o);if(void 0===c)return(n=vt.createCurveEvaluatedFraction(this,t,n)).curveSearchStatus=A.error,n;const h=i<0?-1:1;let l=K.interpolate(t,c,r),d=t,u=0;const f=1e-12*o;let g=0;const p=bt.createXAxis();for(let t=0;t<10;t++){const t=u+(l>d?h:-h)*this.curveLengthBetweenFractions(d,l),e=a-t;if(Math.abs(e)<f){if(g++,g>1)break}else g=0;if(this.fractionToPointAndDerivative(l,p),d=l,l=d+h*e/p.direction.magnitude(),d===l){g=100;break}u=t}return g>1?vt.createConditionalMoveSignedDistance(s,this,t,l,i,n):((n=vt.createCurveEvaluatedFraction(this,t,n)).curveSearchStatus=A.error,n)}get isExtensibleFractionSpace(){return!1}closestPoint(t,e){const i=new Qt(t,e);return this.emitStrokableParts(i),i.claimResult()}announceClipIntervals(t,e){return!1}clonePartialCurve(t,e){}getFractionToDistanceScale(){}appendPlaneIntersectionPoints(t,e){const i=new Kt(t,e),s=e.length;return this.emitStrokableParts(i),e.length-s}static snapAndRestrictDetails(t,e=!0,i=!1,s=K.smallAngleRadians,n=K.smallMetricDistance){const r=t.length;let o=0;const a=Q.create(),c=Q.create();let h;for(let l=0;l<r;l++){h=void 0;const r=t[l];let d=r.fraction,u=e||K.isIn01(d);r.curve&&(r.curve.startPoint(a),r.curve.endPoint(c)),s>0&&(Math.abs(d)<s&&(d=0,u=!0,r.intervalRole=I.isolatedAtVertex,h=a),Math.abs(d-1)<s&&(d=1,u=!0,r.intervalRole=I.isolatedAtVertex,h=c,r.curve&&(h=r.curve.startPoint(c)))),n>0&&void 0!==r.curve&&(r.point.distance(a)<=n?(d=0,r.intervalRole=I.isolatedAtVertex,h=a):r.point.distance(c)<=n&&(d=1,r.intervalRole=I.isolatedAtVertex,h=c)),u&&(i&&(r.fraction=d,void 0!==h&&r.point.setFrom(h)),o<l&&(t[o]=r),o++)}o<r&&(t.length=o)}startPoint(t){return this.fractionToPoint(0,t)}endPoint(t){return this.fractionToPoint(1,t)}computeAndAttachRecursiveStrokeCounts(t,e){const i=this.computeStrokeCountForOptions(t),s=this.curveLength();ie.installStrokeCountMap(this,Yt.createWithCurvePrimitive(this,i,s,0,s),e)}addMappedStrokesToLineString3D(t,e){const i=e.numPoints();if(t.primitive&&t.primitive===this&&t.numStroke>0)for(let i=0;i<=t.numStroke;i++){const s=i/t.numStroke;e.appendFractionToPoint(this,s)}return e.numPoints()-i}static installStrokeCountMap(t,e,i){i&&i.addToCountAndLength(e.numStroke,e.curveLength),t.strokeData=e}collectCurvePrimitivesGo(t,e,i=!1){t.push(this)}collectCurvePrimitives(t,e=!1,i=!1){const s=void 0===t?[]:t;return this.collectCurvePrimitivesGo(s,e,i),s}projectedParameterRange(t,e){}}class se extends st{constructor(t){super(),this.data=t}isValidIndex(t){return t>=0&&t<this.data.length}getPoint3dAtCheckedPointIndex(t,e){if(this.isValidIndex(t)){const i=this.data[t];return Q.create(i.x,i.y,i.z,e)}}getPoint3dAtUncheckedPointIndex(t,e){const i=this.data[t];return Q.create(i.x,i.y,i.z,e)}getVector3dAtCheckedVectorIndex(t,e){if(this.isValidIndex(t)){const i=this.data[t];return $.create(i.x,i.y,i.z,e)}}getXAtUncheckedPointIndex(t){return this.data[t].x}getYAtUncheckedPointIndex(t){return this.data[t].y}getZAtUncheckedPointIndex(t){return this.data[t].z}vectorIndexIndex(t,e,i){if(this.isValidIndex(t)&&this.isValidIndex(e))return $.createStartEnd(this.data[t],this.data[e],i)}vectorXYAndZIndex(t,e,i){if(this.isValidIndex(e))return $.createStartEnd(t,this.data[e],i)}crossProductXYAndZIndexIndex(t,e,i,s){if(this.isValidIndex(e)&&this.isValidIndex(i))return $.createCrossProductToPoints(t,this.data[e],this.data[i],s)}crossProductIndexIndexIndex(t,e,i,s){if(this.isValidIndex(t)&&this.isValidIndex(e)&&this.isValidIndex(i))return $.createCrossProductToPoints(this.data[t],this.data[e],this.data[i],s)}accumulateCrossProductIndexIndexIndex(t,e,i,s){const n=this.data;this.isValidIndex(t)&&this.isValidIndex(e)&&this.isValidIndex(i)&&s.addCrossProductToTargetsInPlace(n[t].x,n[t].y,n[t].z,n[e].x,n[e].y,n[e].z,n[i].x,n[i].y,n[i].z)}accumulateScaledXYZ(t,e,i){if(this.isValidIndex(t)){const s=this.data[t];i.x+=e*s.x,i.y+=e*s.y,i.z+=e*s.z}}get length(){return this.data.length}push(t){this.data.push(t.clone())}pushXYZ(t,e,i){this.data.push(Q.create(void 0===t?0:t,void 0===e?0:e,void 0===i?0:i))}back(t){if(this.data.length>0)return this.data[this.data.length-1].clone(t)}front(t){if(this.data.length>0)return this.data[0].clone(t)}pop(){this.data.length>0&&this.data.pop()}clear(){this.data.length=0}reverseInPlace(){this.data.reverse()}distanceSquaredIndexIndex(t,e){const i=this.data.length;if(t>=0&&t<i&&e>=0&&e<i)return this.data[t].distanceSquared(this.data[e])}distanceIndexIndex(t,e){const i=this.data.length;if(t>=0&&t<i&&e>=0&&e<i)return this.data[t].distance(this.data[e])}cyclicIndex(t){return t%this.data.length}}function ne(t,e,i){if(void 0!==e){const s=e*i;if(s>=0&&s<=t)return s}return t}class re{static preciseSum(t){const e=t.length;if(0===e)return 0;let i,s,n=t[0],r=0;for(let o=1;o<e;o++)i=t[o]-r,s=n+i,r=s-n-i,n=s;return n}static isExactEqual(t,e){if(t&&e){if(t.length!==e.length)return!1;for(let i=0;i<t.length;i++)if(t[i]!==e[i])return!1;return!0}return void 0===t&&void 0===e}static isAlmostEqual(t,e,i){if(t&&e){if(t.length!==e.length)return!1;for(let s=0;s<t.length;s++)if(Math.abs(t[s]-e[s])>=i)return!1;return!0}return void 0===t&&void 0===e}static sum(t){let e=0;for(const i of t)e+=i;return e}static isCoordinateInArray(t,e){if(e)for(const i of e)if(K.isSameCoordinate(t,i))return!0;return!1}static maxAbsArray(t){const e=t.length;if(0===e)return 0;let i=Math.abs(t[0]);for(let s=1;s<e;s++){const e=Math.abs(t[s]);i<e&&(i=e)}return i}static maxAbsTwo(t,e){return(t=Math.abs(t))>(e=Math.abs(e))?t:e}static maxAbsDiff(t,e){let i=0;const s=Math.min(t.length,e.length);for(let n=0;n<s;n++)i=Math.max(i,Math.abs(t[n]-e[n]));return i}static maxAbsDiffFloat64(t,e){let i=0;const s=Math.min(t.length,e.length);for(let n=0;n<s;n++)i=Math.max(i,Math.abs(t[n]-e[n]));return i}static createArrayWithMaxStepSize(t,e,i){if(t===e)return[t];const s=e-t,n=Math.max(1,Math.floor(Math.abs(s/i))),r=[];r.push(t);for(let e=1;e<n;e++)r.push(t+e/n*s);return r.push(e),r}static create(t){const e=[];for(const i of t)e.push(i);return e}static cloneWithStartAndEndMultiplicity(t,e,i){const s=[];if(void 0===t||0===t.length)return s;let n=1;const r=t[0],o=t[t.length-1];for(;n<t.length&&t[n]===r;)n++;let a=1;const c=t.length-1;for(;c-a>=0&&t[c-a]===o;)a++;for(let t=0;t<e;t++)s.push(r);for(let e=n;e+a<t.length;e++)s.push(t[e]);for(let t=0;t<i;t++)s.push(o);return s}static linearCombination(t,e){const i=Math.min(t.length,e.length);let s=0;for(let n=0;n<i;++n)s+=e[n]*t[n];return s}static linearCombinationOfColors(t,e){const i=Math.min(t.length,e.length),s=[0,0,0,0];for(let n=0,r=0;n<4;++n,r+=8){for(let o=0;o<i;++o){const i=K.clamp(e[o],0,1),a=t[o]>>>r&255;s[n]+=i*a}s[n]=(255&Math.floor(s[n]))<<r}return s[0]|s[1]|s[2]|s[3]}}class oe{static packPointsAndWeightsToFloat64Array(t,e,i){if(Array.isArray(t)&&t[0]instanceof Q){const s=t;if(s.length!==e.length)return;i=i||new Float64Array(4*s.length);let n=0,r=0;for(r=0;r<s.length;r++)i[n++]=s[r].x,i[n++]=s[r].y,i[n++]=s[r].z,i[n++]=e[r];return i}{const s=t,n=e.length;if(s.length!==3*n)return;let r,o=0;for(i=i||new Float64Array(4*n),r=0;r<n;r++){const t=3*r;i[o++]=s[t],i[o++]=s[t+1],i[o++]=s[t+2],i[o++]=e[r]}return i}}static packToFloat64Array(t,e){e=e||new Float64Array(4*t.length);let i=0;for(const s of t)e[i++]=s.x,e[i++]=s.y,e[i++]=s.z,e[i++]=s.w;return e}static unpackToPoint4dArray(t){const e=[];for(let i=0;i+3<t.length;i+=4)e.push(Rt.create(t[i],t[i+1],t[i+2],t[i+3]));return e}static unpackFloat64ArrayToPointsAndWeights(t,e,i,s=((t,e,i)=>Q.create(t,e,i))){e.length=0,i.length=0;for(let n=0;n+3<t.length;n+=4)e.push(s(t[n],t[n+1],t[n+2])),i.push(t[n+3])}static multiplyInPlace(t,e){const i=e.length,s=oe._workPoint4d;for(let n=0;n+3<i;n+=4)t.multiplyXYZW(e[n],e[n+1],e[n+2],e[n+3],s),e[n]=s.x,e[n+1]=s.y,e[n+2]=s.z,e[n+3]=s.w}static isAlmostEqual(t,e){if(t&&e){if(t.length!==e.length)return!1;if(t instanceof Float64Array&&e instanceof Float64Array){for(let i=0;i<t.length;i++)if(!K.isSameCoordinate(t[i],e[i]))return!1}else if(Array.isArray(t)&&Array.isArray(e))for(let i=0;i<t.length;i++)if(!t[i].isAlmostEqual(e[i]))return!1;return!0}return void 0===t&&void 0===e}static isCloseToPlane(t,e,i=K.smallMetricDistance){if(Array.isArray(t)){for(const s of t)if(Math.abs(e.altitudeXYZW(s.x,s.y,s.z,s.w))>i)return!1}else if(t instanceof Float64Array){const s=t.length;for(let n=0;n+2<s;n+=4)if(Math.abs(e.altitudeXYZW(t[n],t[n+1],t[n+2],t[n+3]))>i)return!1}return!0}}oe._workPoint4d=Rt.create();class ae{static packToFloat64Array(t){const e=new Float64Array(3*t.length);let i=0;for(const s of t)e[i++]=s.x,e[i++]=s.y,e[i++]=s.z;return e}static evaluateTrilinearWeights(t,e,i,s,n,r,o){t[0]=e*s*r,t[1]=i*s*r,t[2]=e*n*r,t[3]=i*n*r,t[4]=e*s*o,t[5]=i*s*o,t[6]=e*n*o,t[7]=i*n*o}static sumWeightedX(t,e){let i=0;const s=t.length;for(let n=0;n<s;n++)i+=t[n]*e[n].x;return i}static sumWeightedY(t,e){let i=0;const s=t.length;for(let n=0;n<s;n++)i+=t[n]*e[n].y;return i}static sumWeightedZ(t,e){let i=0;const s=t.length;for(let n=0;n<s;n++)i+=t[n]*e[n].z;return i}static evaluateTrilinearPoint(t,e,i,s,n){let r;n||(n=Q.create(0,0,0)),this.evaluateTrilinearWeights(this._weightUVW,1-e,e,1-i,i,1-s,s);for(let e=0;e<8;e++)r=this._weightUVW[e],n.x+=r*t[e].x,n.y+=r*t[e].y,n.z+=r*t[e].z;return n}static evaluateTrilinearDerivativeTransform(t,e,i,s,n){return this.evaluateTrilinearWeights(this._weightUVW,1-e,e,1-i,i,1-s,s),this.evaluateTrilinearWeights(this._weightDU,-1,1,1-i,i,1-s,s),this.evaluateTrilinearWeights(this._weightDV,1-e,e,-1,1,1-s,s),this.evaluateTrilinearWeights(this._weightDW,1-e,e,1-i,i,-1,1),pt.createRowValues(this.sumWeightedX(this._weightDU,t),this.sumWeightedX(this._weightDV,t),this.sumWeightedX(this._weightDW,t),this.sumWeightedX(this._weightUVW,t),this.sumWeightedY(this._weightDU,t),this.sumWeightedY(this._weightDV,t),this.sumWeightedY(this._weightDW,t),this.sumWeightedY(this._weightUVW,t),this.sumWeightedZ(this._weightDU,t),this.sumWeightedZ(this._weightDV,t),this.sumWeightedZ(this._weightDW,t),this.sumWeightedZ(this._weightUVW,t),n)}static unpackNumbersToPoint3dArray(t){const e=[];for(let i=0;i+2<t.length;i+=3)e.push(Q.create(t[i],t[i+1],t[i+2]));return e}static unpackNumbersToNestedArrays(t,e){const i=[],s=t.length;let n=0,r=0;for(;n<s;){const o=[];for(r=n+e,r>s&&(r=s);n<r;n++)o.push(t[n]);i.push(o)}return i}static unpackNumbersToNestedArraysIJK(t,e,i){const s=[],n=t.length;let r,o=0,a=0;for(;o<n;){const c=[];for(r=o+e*i;o<r;){const i=[];for(a=o+e,a>n&&(a=n);o<a;o++)i.push(t[o]);c.push(i)}s.push(c)}return s}static multiplyInPlace(t,e){const i=Q.create(),s=e.length;for(let n=0;n+2<s;n+=3)t.multiplyXYZ(e[n],e[n+1],e[n+2],i),e[n]=i.x,e[n+1]=i.y,e[n+2]=i.z}static isAlmostEqual(t,e){if(t&&e){if(t.length!==e.length)return!1;if(t instanceof Float64Array&&e instanceof Float64Array){for(let i=0;i<t.length;i++)if(!K.isSameCoordinate(t[i],e[i]))return!1}else if(Array.isArray(t)&&Array.isArray(e))for(let i=0;i<t.length;i++)if(!t[i].isAlmostEqual(e[i]))return!1;return!0}return void 0===t&&void 0===e}static centroid(t,e){if(t instanceof it){e=Q.create(0,0,0,e);const i=Q.create();if(t.length>0){for(let s=0;s<t.length;s++)t.getPoint3dAtCheckedPointIndex(s,i),e.x+=i.x,e.y+=i.y,e.z+=i.z;e.scaleInPlace(1/t.length)}return e}const i=new se(t);return this.centroid(i)}static indexOfMostDistantPoint(t,e,i){if(0===t.length)return;let s,n=-1,r=-1;for(let o=0;o<t.length;o++)s=e.distance(t[o]),s>n&&(e.vectorTo(t[o],i),n=s,r=o);return r}static indexOfPointWithMaxCrossProductMagnitude(t,e,i,s){if(0===t.length)return;let n,r,o=-1,a=-1;for(let c=0;c<t.length;c++)r=e.vectorTo(t[c],r),n=r.crossProductMagnitude(i),n>o&&(s.setFrom(r),o=n,a=c);return a}static closestPointIndex(t,e){let i,s=-1,n=Number.MAX_VALUE;const r=e.x,o=e.y,a=e.z;for(let e=0;e<t.length;e++)i=K.distanceXYZXYZ(r,o,a,t[e].x,t[e].y,t[e].z),i<n&&(s=e,n=i);return s}static isCloseToPlane(t,e,i=K.smallMetricDistance){if(Array.isArray(t)){let s;for(s of t)if(Math.abs(e.altitude(s))>i)return!1}else if(t instanceof Float64Array){const s=t.length;for(let n=0;n+2<s;n+=3)if(Math.abs(e.altitudeXYZ(t[n],t[n+1],t[n+2]))>i)return!1}return!0}static sumEdgeLengths(t,e=!1,i){let s=0;if(Array.isArray(t)){const n=ne(t.length,i,1)-1;for(let e=0;e<n;e++)s+=t[e].distance(t[e+1]);e&&n>0&&(s+=t[0].distance(t[n]))}else if(t instanceof Float64Array){const n=ne(t.length,i,3);let r=0;for(;r+5<n;r+=3)s+=K.hypotenuseXYZ(t[r+3]-t[r],t[r+4]-t[r+1],t[r+5]-t[r+2]);e&&r>=3&&(s+=K.hypotenuseXYZ(t[0]-t[r],t[1]-t[r+1],t[2]-t[r+2]))}return s}static countNonDuplicates(t,e=K.smallMetricDistance){let i=t.length;for(;i>1&&t[0].isAlmostEqual(t[i-1],e);)i--;for(let s=0;s+1<i;s++)if(t[s].isAlmostEqual(t[s+1],e))return 0;return i}static clonePoint3dArray(t){const e=[];if(0===t.length)return e;if(t instanceof Float64Array){for(let i=0;i+2<t.length;i+=3)e.push(Q.create(t[i],t[i+1],t[i+2]));return e}for(const i of t)Array.isArray(i)?e.push(Q.create(i[0],i[1],i[2])):e.push(Q.create(i.x,i.y,i.z));return e}static clonePoint2dArray(t){return t.map((t=>H.create(t.x,t.y)))}static cloneWithMaxEdgeLength(t,e){if(0===t.length)return[];const i=[t[0]];for(let s=1;s<t.length;s++){const n=t[s-1].distance(t[s]),r=K.stepCount(e,n,1);for(let e=1;e<r;e++)i.push(t[s-1].interpolate(e/r,t[s]));i.push(t[s])}return i}static xyzToArray(t,e,i){return[t,e,i]}static cloneDeepJSONNumberArrays(t){const e=new ht(((t,e,i)=>this.xyzToArray(t,e,i)));return lt.streamXYZ(t,e),e.claimResult()}static cloneXYZPropsAsNumberArray(t){const e=[];for(const i of t)i instanceof Q?e.push([i.x,i.y,i.z]):Array.isArray(i)&&e.push([i[0],i[1],i.length>2?i[2]:0]);return e}static cloneXYZPropsAsFloat64Array(t){const e=new Float64Array(3*t.length);let i=0;for(const s of t)s instanceof Q?(e[i++]=s.x,e[i++]=s.y,e[i++]=s.z):Array.isArray(s)&&(e[i++]=s[0],e[i++]=s[1],e[i++]=s.length>2?s[2]:0);return e}static cloneDeepXYZPoint3dArrays(t){const e=new ht(((t,e,i)=>Q.create(t,e,i)));return lt.streamXYZ(t,e),e.claimResult()}static distanceIndexedPointBToSegmentAC(t,e,i,s,n){const r=$.createStartEnd(t[e],t[s]),o=$.createStartEnd(t[e],t[i]),a=r.dotProduct(r),c=r.dotProduct(o);let h=K.conditionalDivideFraction(c,a);void 0===h&&(h=0),n||(h>1&&(h=1),h<0&&(h=0));let l=o.magnitudeSquared()-h*h*a;return l<0&&(l=0),Math.sqrt(l)}static computeConvexHullXY(t,e,i,s=!1){e.length=0,i.length=0;let n=t.length;const r=t.slice(0,n);if(r.sort(((t,e)=>K.lexicalXYLessThan(t,e))),n<3){for(const t of r)e.push(t);return void(s&&r.length>0&&e.push(r[0]))}e.push(r[0]),e.push(r[1]);let o=0;for(let t=2;t<n;t++){const i=r[t];let s=e.length-1;for(;s>=1&&e[s-1].crossProductToPointsXY(e[s],i)<=0;)r[o++]=e[s],s--,e.pop();e.push(i)}const a=e.length-1;r.length=o,r.push(e[0]),r.sort(((t,e)=>K.lexicalXYLessThan(t,e))),n=r.length,e.push(r[n-1]);for(let t=n-1;t-- >0;){const s=r[t];let n=e.length-1;for(;n>a&&e[n-1].crossProductToPointsXY(e[n],s)<=0;)i.push(e[n]),n--,e.pop();t>0&&e.push(s)}s&&e.push(e[0])}static minMaxPoints(t){if(0===t.length)return;const e={minXPoint:t[0].clone(),maxXPoint:t[0].clone(),minYPoint:t[0].clone(),maxYPoint:t[0].clone()};let i;for(let s=1;s<t.length;s++)i=t[s],i.x<e.minXPoint.x&&e.minXPoint.setFromPoint3d(i),i.x>e.maxXPoint.x&&e.maxXPoint.setFromPoint3d(i),i.y<e.minYPoint.y&&e.minYPoint.setFromPoint3d(i),i.y>e.maxYPoint.y&&e.maxYPoint.setFromPoint3d(i);return e}}ae._weightUVW=new Float64Array(8),ae._weightDU=new Float64Array(8),ae._weightDV=new Float64Array(8),ae._weightDW=new Float64Array(8);class ce extends ie{dispatchToGeometryHandler(t){return this._proxyCurve.dispatchToGeometryHandler(t)}constructor(t){super(),this._proxyCurve=t}get proxyCurve(){return this._proxyCurve}computeStrokeCountForOptions(t){return this._proxyCurve.computeStrokeCountForOptions(t)}emitStrokableParts(t,e){this._proxyCurve.emitStrokableParts(t,e)}cloneTransformed(t){const e=this.clone();if(e.tryTransformInPlace(t))return e}clonePartialCurve(t,e){return this._proxyCurve.clonePartialCurve(t,e)}emitStrokes(t,e){this._proxyCurve.emitStrokes(t,e)}extendRange(t,e){this._proxyCurve.extendRange(t,e)}range(t,e){return this._proxyCurve.range(t,e)}fractionToPoint(t,e){return this._proxyCurve.fractionToPoint(t,e)}fractionToPointAndDerivative(t,e){return this._proxyCurve.fractionToPointAndDerivative(t,e)}fractionToPointAnd2Derivatives(t,e){return this._proxyCurve.fractionToPointAnd2Derivatives(t,e)}isInPlane(t){return this._proxyCurve.isInPlane(t)}quickLength(){return this._proxyCurve.quickLength()}constructOffsetXY(t){return this._proxyCurve.constructOffsetXY(t)}projectedParameterRange(t,e){return this._proxyCurve.projectedParameterRange(t,e)}}class he{static decomposeLU(t,e,i){const s=t-1,n=Math.floor(e/2);let r;for(let t=0;t<=s;t++){const o=Math.min(s,t+n);for(let s=t;s<=o;s++){r=0;for(let o=Math.max(0,s-n);o<t;o++)r+=i[t*e+o-t+n]*i[o*e+s-o+n];i[t*e+s-t+n]-=r}for(let s=t+1;s<=o;s++){r=0;for(let o=Math.max(0,s-n);o<t;o++)r+=i[s*e+o-s+n]*i[o*e+t-o+n];if(Math.abs(i[t*e+n])<1e-9)return!1;i[s*e+t-s+n]=(i[s*e+t-s+n]-r)/i[t*e+n]}}return!0}static arrayAddScaledBlock(t,e,i,s){const n=t.length;let r=n*i;for(let i=0;i<n;i++,r++)t[i]+=e[r]*s}static blockAssignBlockMinusArray(t,e,i,s,n){const r=n.length;let o=e*r,a=s*r;for(let e=0;e<r;e++,a++,o++)t[o]=i[a]-n[e]}static blockSumOfScaledBlockScaledArray(t,e,i,s,n,r,o){const a=r.length;let c=e*a,h=s*a;for(let e=0;e<a;e++,h++,c++)t[c]=i[h]*n+r[e]*o}static solveBandedSystemMultipleRHS(t,e,i,s,n){if(!this.decomposeLU(t,e,i))return;const r=t-1,o=Math.floor(e/2),a=new Float64Array(s),c=new Float64Array(s*t),h=new Float64Array(s*t);for(let t=0;t<=r;t++){a.fill(0);for(let s=Math.max(0,t-o);s<t;s++)this.arrayAddScaledBlock(a,c,s,i[t*e+s-t+o]);this.blockAssignBlockMinusArray(c,t,n,t,a)}for(let t=r;t>=0;t--){const s=K.conditionalDivideCoordinate(1,i[t*e+o]);if(void 0===s)return;a.fill(0);const n=Math.min(r,t+o);for(let s=t+1;s<=n;s++)this.arrayAddScaledBlock(a,h,s,i[t*e+s-t+o]);this.blockSumOfScaledBlockScaledArray(h,t,c,t,s,a,-s)}return h}static multiplyBandedTimesFull(t,e,i,s,n){const r=new Float64Array(n.length),o=Math.floor(e/2);let a,c,h,l;for(let d=0;d<t;d++){c=d-o,c<0&&(c=0),h=d+o+1,h>t&&(h=t),l=o+d*(e-1);for(let t=0;t<s;t++){a=0;for(let e=c;e<h;e++)a+=i[l+e]*n[e*s+t];r[d*s+t]=a}}return r}}!function(t){t[t.None=0]="None",t[t.OpenByAddingControlPoints=1]="OpenByAddingControlPoints",t[t.OpenByRemovingKnots=2]="OpenByRemovingKnots"}(C||(C={}));class le{get leftKnot(){return this._knot0}get rightKnot(){return this._knot1}get leftKnotIndex(){return this.degree-1}get rightKnotIndex(){return this.knots.length-this.degree}get wrappable(){return void 0===this._wrapMode?C.None:this._wrapMode}set wrappable(t){this._wrapMode=t}get numSpans(){return this.rightKnotIndex-this.leftKnotIndex}constructor(t,e,i){this.degree=e,this._wrapMode=i,this._knot0=0,this._knot1=1,Array.isArray(t)?(this.knots=new Float64Array(t.length),this.setKnots(t),this.setupFixedValues()):t instanceof Float64Array?(this.knots=t.slice(),this.setupFixedValues()):this.knots=new Float64Array(t)}clone(){return new le(this.knots,this.degree,this.wrappable)}setupFixedValues(){this._knot0=this.knots[this.degree-1],this._knot1=this.knots[this.knots.length-this.degree]}get knotLength01(){return this._knot1-this._knot0}testClosable(t){void 0===t&&(t=this.wrappable);const e=this.leftKnotIndex,i=this.rightKnotIndex,s=this.rightKnot-this.leftKnot,n=this.degree,r=i-e;if(t===C.OpenByAddingControlPoints){for(let t=e-n+1;t<e+n-1;t++){const e=t+r;if(!K.isSameCoordinate(this.knots[t]+s,this.knots[e]))return!1}return!0}if(t===C.OpenByRemovingKnots){const t=n-1,s=this.knots[e],r=this.knots[i];for(let n=0;n<t;n++){if(!K.isSameCoordinate(s,this.knots[e-n-1]))return!1;if(!K.isSameCoordinate(r,this.knots[i+n+1]))return!1}return!0}return!1}isAlmostEqual(t){return this.degree===t.degree&&re.isAlmostEqual(this.knots,t.knots,le.knotTolerance)}getKnotMultiplicity(t){let e=0;for(const i of this.knots)if(Math.abs(i-t)<le.knotTolerance)++e;else if(t<i)break;return e}getKnotMultiplicityAtIndex(t){let e=0;if(t>=0&&t<this.knots.length){const i=this.knots[t];++e;for(let s=t-1;s>=0;--s){const t=this.knots[s];if(Math.abs(t-i)<le.knotTolerance)++e;else if(i>t)break}for(let s=t+1;s<this.knots.length;++s){const t=this.knots[s];if(Math.abs(t-i)<le.knotTolerance)++e;else if(i<t)break}}return e}normalize(){if(this.knotLength01<le.knotTolerance)return!1;const t=1/this.knotLength01,e=this.leftKnot;for(let i=0;i<this.knots.length;++i)this.knots[i]=(this.knots[i]-e)*t;for(let t=this.rightKnotIndex-1;t>this.leftKnotIndex&&this.knots[t]===this.knots[this.rightKnotIndex];--t)this.knots[t]=1;for(let t=this.rightKnotIndex+1;t<this.knots.length&&this.knots[t]===this.knots[this.rightKnotIndex];++t)this.knots[t]=1;return this.knots[this.rightKnotIndex]=1,this.setupFixedValues(),!0}setKnots(t,e){const i=e?t.length-2:t.length;if(i!==this.knots.length&&(this.knots=new Float64Array(i)),e)for(let e=1;e+1<t.length;e++)this.knots[e-1]=t[e];else for(let e=0;e<t.length;e++)this.knots[e]=t[e];this.setupFixedValues()}setKnotsCapture(t){this.knots=t,this.setupFixedValues()}static createUniformClamped(t,e,i,s){const n=new le(t+e-1,e);let r=0;for(let t=0;t<e;t++)n.knots[r++]=i;const o=1/(t-e);for(let a=1;a+e<t;a++)n.knots[r++]=i+a*o*(s-i);for(let t=0;t<e;t++)n.knots[r++]=s;return n.setupFixedValues(),n}static createUniformWrapped(t,e,i,s){const n=new le(t+2*e-1,e),r=1/t;for(let o=1-e,a=0;o<t+e;o++,a++)n.knots[a]=K.interpolate(i,o*r,s);return n.setupFixedValues(),n}static create(t,e,i){const s=i?t.length-2:t.length,n=new le(s,e);return n.setKnots(t,i),n}grevilleKnot(t){if(t<0)return this.leftKnot;if(t>this.rightKnotIndex)return this.rightKnot;let e=0;for(let i=t;i<t+this.degree;i++)e+=this.knots[i];return e/this.degree}createBasisArray(){return new Float64Array(this.degree+1)}baseKnotFractionToKnot(t,e){const i=this.knots[t];return i+(e=K.clamp(e,0,1))*(this.knots[t+1]-i)}spanFractionToKnot(t,e){const i=this.spanIndexToLeftKnotIndex(t);return e=K.clamp(e,0,1),this.knots[i]+e*(this.knots[i+1]-this.knots[i])}spanFractionToFraction(t,e){return(this.spanFractionToKnot(t,e)-this.leftKnot)/(this.rightKnot-this.leftKnot)}fractionToKnot(t){return t=K.clamp(t,0,1),K.interpolate(this.knots[this.degree-1],t,this.knots[this.knots.length-this.degree])}evaluateBasisFunctions(t,e,i){if(i[0]=1,this.degree<1)return;const s=this.knots[t],n=this.knots[t+1];if(i[1]=(e-s)/(n-s),i[0]=1-i[1],!(this.degree<2))for(let s=1;s<this.degree;s++){let n=t-s,r=n+s+1,o=0;for(let t=0;t<=s;t++){const s=this.knots[n++],a=(e-s)/(this.knots[r++]-s),c=i[t]*a,h=i[t]*(1-a);i[t]=o+h,o=c}i[s+1]=o}}evaluateBasisFunctions1(t,e,i,s,n){if(i[0]=1,s[0]=0,this.degree<1)return;const r=this.knots[t];let o=1/(this.knots[t+1]-r);if(i[1]=(e-r)*o,i[0]=1-i[1],s[0]=-o,s[1]=o,n&&(n[0]=0,n[1]=0),!(this.degree<2))for(let r=1;r<this.degree;r++){let a=t-r,c=a+r+1,h=0,l=0,d=0;for(let t=0;t<=r;t++){const r=this.knots[a++];o=1/(this.knots[c++]-r);const u=(e-r)*o,f=1-u,g=i[t]*u,p=i[t]*f,m=s[t]*u+i[t]*o,x=s[t]*f-i[t]*o,y=2*s[t]*o;if(i[t]=h+p,s[t]=l+x,h=g,l=m,n){const e=n[t]*u+y,i=n[t]*f-y;n[t]=d+i,d=e}}i[r+1]=h,s[r+1]=l,n&&(n[r+1]=d)}}knotToLeftKnotIndex(t){for(let e=this.leftKnotIndex;e<this.rightKnotIndex;++e)if(t<this.knots[e+1])return e;for(let t=this.rightKnotIndex;t>this.leftKnotIndex;--t)if(this.knots[t]-this.knots[t-1]>=le.knotTolerance)return t-1;return this.rightKnotIndex-1}spanIndexToLeftKnotIndex(t){const e=this.degree;return t<=0?e-1:Math.min(t+e-1,this.knots.length-e-1)}spanIndexToSpanLength(t){const e=this.spanIndexToLeftKnotIndex(t);return this.knots[e+1]-this.knots[e]}isIndexOfRealSpan(t){return t>=0&&t<this.numSpans&&!K.isSmallMetricDistance(this.spanIndexToSpanLength(t))}reflectKnots(){const t=this.leftKnot,e=this.rightKnot,i=this.knots.length;for(let s=0;s<i;s++)this.knots[s]=t+(e-this.knots[s]);this.knots.reverse()}copyKnots(t){const e=this.wrappable===C.OpenByAddingControlPoints&&this.testClosable(),i=this.leftKnotIndex,s=this.rightKnotIndex,n=this.leftKnot,r=this.rightKnot-n,o=this.degree,a=[];t&&(e?a.push(this.knots[s-o]-r):a.push(this.knots[0]));for(const t of this.knots)a.push(t);return t&&(e?a.push(this.knots[i+o]+r):a.push(a[a.length-1])),a}}le.knotTolerance=1e-9;class de{static createThroughPoints(t,e){const i=t.length;if(e>i||e<2)return;const s=e-1,n=1+2*s,r=new Float64Array(n*i),o=new Float64Array(e),a=new nt,c=le.createUniformClamped(i,e-1,0,1),h=Q.create();for(let l=0;l<i;l++){const d=c.grevilleKnot(l),u=c.knotToLeftKnotIndex(d);c.evaluateBasisFunctions(u,d,o);let f=0;for(let t=1;t<e;t++)o[t]>o[f]&&(f=t);const g=s-f,p=l*n;for(let t=0;t<e;t++){const e=l-s+g+t;p+e>=0&&e<i&&(r[p+g+t]=o[t])}t instanceof it?a.push(t.getPoint3dAtUncheckedPointIndex(l,h)):a.push(t[l].clone())}const l=he.solveBandedSystemMultipleRHS(i,n,r,3,a.float64Data());return l?ze.create(l,c.knots,e):void 0}static createThroughPointsC2Cubic(t){const e=t.clone();if(!this.C2CubicFit.validateOptions(e))return;const i=this.C2CubicFit.constructPoles(e);if(void 0===i)return;const s=this.C2CubicFit.convertFitParamsToCubicKnotVector(e.knots,e.closed);if(void 0===s)return;const n=ze.create(i,s,e.order);return e.closed&&n?.setWrappable(C.OpenByAddingControlPoints),n}}!function(t){t.C2CubicFit=class{static normalizeKnots(t){if(void 0===t||t.length<2)return t=void 0,!1;const e=le.create(t,1,!1);if(!e.normalize())return t=void 0,!1;for(let i=0;i<t.length;++i)t[i]=e.knots[i];return!0}static constructChordLengthParameters(t){if(t.length<2)return;const e=[0];for(let i=1;i<t.length;++i)e[i]=e[i-1]+t[i].distance(t[i-1]);return this.normalizeKnots(e)?e:void 0}static constructUniformParameters(t){if(t<2)return;const e=le.createUniformClamped(t+2,3,0,1),i=[];for(let t=e.leftKnotIndex;t<=e.rightKnotIndex;++t)i.push(e.knots[t]);return i}static removeDuplicateFitPoints(t){void 0!==t.knots&&t.knots.length!==t.fitPoints.length&&(t.knots=void 0);const e=nt.create(t.fitPoints),i=e.findOrderedDuplicates();e.clear();for(let s=0,n=0;s<t.fitPoints.length;++s)s===i[n]?++n:e.push(t.fitPoints[s].clone());if(t.fitPoints=e.getPoint3dArray(),void 0!==t.knots){const e=[];for(let s=0,n=0;s<t.knots.length;++s)s===i[n]?++n:e.push(t.knots[s]);t.knots=e.slice()}return!0}static constructFitParametersFromPoints(t,e,i){let s;return!e&&i||(s=this.constructChordLengthParameters(t)),void 0===s&&(s=this.constructUniformParameters(t.length)),s}static constructFitParameters(t){return void 0===t.knots&&(t.knots=this.constructFitParametersFromPoints(t.fitPoints,t.isChordLenKnots,t.closed)),t.knots?.length===t.fitPoints.length}static computeAlphaBetaGamma(t,e,i,s,n,r,o,a){let c=1/(a+o+r);t[s]=r*r*c,e[s]=r*(a+o)*c,c=1/(o+r+n),e[s]+=o*(r+n)*c,i[s]=o*o*c,c=1/(o+r),t[s]*=c,e[s]*=c,i[s]*=c}static setUpSystem2Points(t,e,i){return 2===t.length&&2===e.length&&2===i.length&&(t[0]=t[1]=i[0]=i[1]=0,e[0]=e[1]=1,!0)}static setUpSystem3Points(t,e,i,s,n,r){if(void 0===s.knots)return!1;if(3!==t.length||3!==e.length||3!==i.length)return!1;if(3!==s.knots.length||3!==s.fitPoints.length)return!1;let o=0,a=0,c=0,h=0,l=0,d=0;return n?(t[0]=0,a=s.knots[1]-s.knots[0],o=s.knots[2]-s.knots[1],l=a+o,d=1/l,e[0]=(a+l)*d,i[0]=-a*d):(t[0]=i[0]=0,e[0]=1),c=s.knots[1]-s.knots[0],a=s.knots[2]-s.knots[1],d=1/(c+a),d*=d,t[1]=a*a*d,e[1]=a*c*2*d,i[1]=c*c*d,r?(c=s.knots[2]-s.knots[1],h=s.knots[1]-s.knots[0],l=h+c,d=1/l,t[2]=-c*d,e[2]=(c+l)*d,i[2]=0):(t[2]=i[2]=0,e[2]=1),!0}static setUpSystem4PointsOrMore(t,e,i,s,n,r){if(void 0===s.knots)return!1;if(t.length!==e.length||t.length!==i.length||t.length!==s.knots.length)return!1;if(s.knots.length!==s.fitPoints.length)return!1;const o=s.fitPoints.length-1,a=o-1;let c=0,h=0,l=0,d=0,u=0,f=0;s.closed?(h=s.knots[1]-s.knots[0],d=s.knots[a]-s.knots[a-1],l=s.knots[a+1]-s.knots[a],c=s.knots[2]-s.knots[1],this.computeAlphaBetaGamma(t,e,i,0,c,h,l,d),d=l,l=h,h=s.knots[2]-s.knots[1],c=s.knots[3]-s.knots[2],this.computeAlphaBetaGamma(t,e,i,1,c,h,l,d),c=l,h=s.knots[a+1]-s.knots[a],d=s.knots[a-1]-s.knots[a-2],l=s.knots[a]-s.knots[a-1],this.computeAlphaBetaGamma(t,e,i,a,c,h,l,d)):(n?(t[0]=0,h=s.knots[1]-s.knots[0],c=s.knots[2]-s.knots[1],u=h+c,f=1/u,e[0]=(h+u)*f,i[0]=-h*f):(t[0]=i[0]=0,e[0]=1),h=s.knots[2]-s.knots[1],l=s.knots[1]-s.knots[0],d=0,c=s.knots[3]-s.knots[2],this.computeAlphaBetaGamma(t,e,i,1,c,h,l,d),h=s.knots[a+1]-s.knots[a],l=s.knots[a]-s.knots[a-1],d=s.knots[a-1]-s.knots[a-2],c=0,this.computeAlphaBetaGamma(t,e,i,a,c,h,l,d),r?(l=s.knots[o]-s.knots[o-1],d=s.knots[o-1]-s.knots[o-2],u=d+l,f=1/u,t[o]=-l*f,e[o]=(l+u)*f,i[o]=0):(t[o]=i[o]=0,e[o]=1));for(let n=2;n<a;++n)h=s.knots[n+1]-s.knots[n],d=s.knots[n-1]-s.knots[n-2],l=s.knots[n]-s.knots[n-1],c=s.knots[n+2]-s.knots[n+1],this.computeAlphaBetaGamma(t,e,i,n,c,h,l,d);return!0}static setUpSystem(t,e,i,s){let n=!1,r=!1;s.isNaturalTangents&&!s.closed&&(n=void 0===s.startTangent,r=void 0===s.endTangent);let o=!1;return 2===s.fitPoints.length?o=this.setUpSystem2Points(t,e,i):3===s.fitPoints.length?o=this.setUpSystem3Points(t,e,i,s,n,r):4<=s.fitPoints.length&&(o=this.setUpSystem4PointsOrMore(t,e,i,s,n,r)),o}static setBesselEndCondition(t,e,i){if(t.length!==e.fitPoints.length+2)return!1;if(void 0===e.knots)return!1;const s=1/3,n=e.fitPoints.length-1;if(1===n)return i?t[0].interpolate(s,t[3],t[1]):t[3].interpolate(s,t[0],t[2]),!0;if(2===n){const n=(e.knots[2]-e.knots[1])/(e.knots[2]-e.knots[0]),r=1-n,o=t[2].plus2Scaled(t[0],-n*n,t[4],-r*r);return i?Q.createAdd2Scaled(o,1/(2*n),t[0],n).interpolate(s,t[0],t[1]):Q.createAdd2Scaled(o,1/(2*r),t[4],r).interpolate(s,t[4],t[3]),!0}if(i){const i=(e.knots[2]-e.knots[1])/(e.knots[2]-e.knots[0]),n=1-i,r=t[2].plus2Scaled(t[0],-i*i,t[3],-n*n);Q.createAdd2Scaled(r,1/(2*i),t[0],i).interpolate(s,t[0],t[1])}else{const i=(e.knots[n]-e.knots[n-1])/(e.knots[n]-e.knots[n-2]),r=1-i,o=t[n].plus2Scaled(t[n-1],-i*i,t[n+2],-r*r);Q.createAdd2Scaled(o,1/(2*r),t[n+2],r).interpolate(s,t[n+2],t[n+1])}return!0}static setNaturalEndCondition(t,e,i){return t.length===e.fitPoints.length+2&&(1==e.fitPoints.length-1?this.setBesselEndCondition(t,e,i):(i?t[1]=t[0]:t[t.length-2]=t[t.length-1],!0))}static setChordLengthScaledEndCondition(t,e,i){if(t.length!==e.fitPoints.length+2)return!1;const s=i?e.startTangent:e.endTangent;if(void 0===s)return!1;let n=0,r=0,o=0;const a=e.fitPoints.length-1;1===a?i?(n=0,r=1,o=3):(n=3,r=2,o=0):i?(n=0,r=1,o=2):(n=a+2,r=a+1,o=a);const c=t[o].distance(t[n]);return t[n].plusScaled(s,c/3,t[r]),!0}static setBesselLengthScaledEndCondition(t,e,i){if(t.length!==e.fitPoints.length+2)return!1;const s=i?e.startTangent:e.endTangent;if(void 0===s)return!1;if(!this.setBesselEndCondition(t,e,i))return!1;const n=e.fitPoints.length-1,r=i?0:n+2,o=i?1:n+1;return t[r].plusScaled(s,t[r].distance(t[o]),t[o]),!0}static setPhysicallyClosedEndCondition(t,e){const i=e.fitPoints.length-1;if(!e.isColinearTangents||i<=2||void 0!==e.startTangent&&void 0!==e.endTangent||e.isNaturalTangents||!t[0].isAlmostEqual(t[i+2]))return!0;if(void 0!==e.startTangent){const e=$.createStartEnd(t[1],t[0]).normalize();if(void 0!==e){const s=t[i+2].distance(t[i+1]);t[i+2].plusScaled(e,s,t[i+1])}}else if(void 0!==e.endTangent){const e=$.createStartEnd(t[i+1],t[i+2]).normalize();if(void 0!==e){const i=t[0].distance(t[1]);t[0].plusScaled(e,i,t[1])}}else{const e=$.createStartEnd(t[i+1],t[1]).normalize();if(void 0!==e){const s=t[0].distance(t[1]);t[0].plusScaled(e,s,t[1]);const n=t[i+2].distance(t[i+1]);t[i+2].plusScaled(e,-n,t[i+1])}}return!0}static setEndConditions(t,e){if(t.length!==e.fitPoints.length)return!1;const i=Q.createZero(),s=Q.createZero();t.splice(1,0,i),t.splice(t.length-1,0,s);let n=!1;return n=void 0===e.startTangent?e.isNaturalTangents?this.setNaturalEndCondition(t,e,!0):this.setBesselEndCondition(t,e,!0):e.isChordLenTangents?this.setChordLengthScaledEndCondition(t,e,!0):this.setBesselLengthScaledEndCondition(t,e,!0),n=void 0===e.endTangent?e.isNaturalTangents?this.setNaturalEndCondition(t,e,!1):this.setBesselEndCondition(t,e,!1):e.isChordLenTangents?this.setChordLengthScaledEndCondition(t,e,!1):this.setBesselLengthScaledEndCondition(t,e,!1),n&&(n=this.setPhysicallyClosedEndCondition(t,e)),n}static solveNearTridiagonal(t,e,i,s){if(e.length!==i.length||e.length!==s.length||e.length!==t.length)return;const n=[],r=t.length-1,o=t.slice(0,-1);let a=0;for(let t=1;t<r;++t){if(void 0===(a=K.conditionalDivideFraction(-e[t],i[t-1])))return;i[t]+=a*s[t-1],e[t]=a*e[t-1],o[t].addScaledInPlace(o[t-1],a)}if(void 0!==(a=K.conditionalDivideFraction(1,i[r-1]+e[r-1]))){s[r-1]*=a,o[r-1].scaleInPlace(a);for(let t=r-2;t>=0;--t){if(void 0===(a=K.conditionalDivideFraction(1,i[t])))return;Q.createScale(o[t].plus2Scaled(o[t+1],-s[t],o[r-1],-e[t]),a,o[t]),s[t]=-(s[t]*s[t+1]+e[t]*s[r-1])*a}if(void 0!==(a=K.conditionalDivideFraction(1,1+s[0]))){n.push(Q.createScale(o[0],a));for(let t=1;t<r;++t)n.push(o[t].plusScaled(n[0],-s[t]));return n}}}static validateOptions(t){if(t.order=4,t.knots=this.convertCubicKnotVectorToFitParams(t.knots,t.fitPoints.length,!0),!this.removeDuplicateFitPoints(t))return!1;let e=t.fitPoints[0].isAlmostEqual(t.fitPoints[t.fitPoints.length-1]);if(3===t.fitPoints.length&&e&&(t.fitPoints.pop(),void 0!==t.knots&&t.knots.pop(),e=t.fitPoints[0].isAlmostEqual(t.fitPoints[t.fitPoints.length-1])),t.fitPoints.length<=2){if(e)return!1;t.closed=!1}return t.closed&&(e||(t.fitPoints.push(t.fitPoints[0].clone()),void 0!==t.knots&&t.knots.push(t.knots[t.knots.length-1]+(t.knots[t.knots.length-1]-t.knots[0])/(t.knots.length-1))),t.fitPoints.length<=4&&(t.closed=!1)),!(t.fitPoints.length<2||(void 0!==t.startTangent&&(t.startTangent.isAlmostZero?t.startTangent=void 0:t.startTangent.normalizeInPlace()),void 0!==t.endTangent&&(t.endTangent.isAlmostZero?t.endTangent=void 0:t.endTangent.normalizeInPlace()),0))}static convertCubicKnotVectorToFitParams(t,e,i){let s=t?.slice();if(void 0!==s){const t=s.length-e;switch(t){case 0:break;case 4:case 6:for(let e=0;e<t/2;++e)s.pop(),s.shift();break;default:s=void 0}i&&!this.normalizeKnots(s)&&(s=void 0)}return s}static convertFitParamsToCubicKnotVector(t,e,i){const s=t?.slice();if(void 0!==s){const t=i?6:4;if(e){const e=s.length-2;for(let i=2;i<=t;i+=2)s.unshift(s[e]-1),s.push(1+s[i])}else for(let e=0;e<t/2;++e)s.unshift(0),s.push(1)}return s}static convertToJsonKnots(t){void 0!==t.knots?(t.knots=this.convertCubicKnotVectorToFitParams(t.knots,t.fitPoints.length,!1),t.knots=this.convertFitParamsToCubicKnotVector(t.knots,t.closed,!0)):(t.knots=this.constructFitParametersFromPoints(ae.clonePoint3dArray(t.fitPoints),t.isChordLenKnots,t.closed),t.knots=this.convertFitParamsToCubicKnotVector(t.knots,t.closed,!0))}static constructPoles(t){if(!this.constructFitParameters(t)||void 0===t.knots)return;const e=t.fitPoints.length,i=Array(e),s=Array(e),n=Array(e);if(!this.setUpSystem(i,s,n,t))return;let r=[];if(t.closed){if(void 0!==(r=this.solveNearTridiagonal(t.fitPoints,i,s,n))&&r.length>2){r.unshift(r.pop());for(let e=0;e<t.order-1;++e)r.push(r[e].clone())}}else{const o=t.fitPoints.slice();if(!this.setEndConditions(o,t))return;if(o.length!==e+2)return;const a=new Float64Array(3*e),c=new Float64Array(3*e);for(let t=0,r=0,h=0;t<e;++t)a[r++]=i[t],a[r++]=s[t],a[r++]=n[t],c[h++]=o[t+1].x,c[h++]=o[t+1].y,c[h++]=o[t+1].z;const h=he.solveBandedSystemMultipleRHS(e,3,a,3,c);if(void 0===h)return;r=new Float64Array(3+h.length+3);let l=0;r[l++]=t.fitPoints[0].x,r[l++]=t.fitPoints[0].y,r[l++]=t.fitPoints[0].z;for(let t=0;t<h.length;)r[l++]=h[t++];r[l++]=t.fitPoints[t.fitPoints.length-1].x,r[l++]=t.fitPoints[t.fitPoints.length-1].y,r[l++]=t.fitPoints[t.fitPoints.length-1].z}return r}}}(de||(de={}));class ue{constructor(t,e){this._fitPoints=t||[],this._knots=e}get order(){return K.resolveNumber(this._order,4)}set order(t){this._order=t}get closed(){return K.resolveValue(this._closed,!1)}set closed(t){this._closed=t}get isChordLenKnots(){return K.resolveNumber(this._isChordLenKnots,0)}set isChordLenKnots(t){this._isChordLenKnots=t}get isColinearTangents(){return K.resolveNumber(this._isColinearTangents,0)}set isColinearTangents(t){this._isColinearTangents=t}get isChordLenTangents(){return K.resolveNumber(this._isChordLenTangents,0)}set isChordLenTangents(t){this._isChordLenTangents=t}get isNaturalTangents(){return K.resolveNumber(this._isNaturalTangents,0)}set isNaturalTangents(t){this._isNaturalTangents=t}get startTangent(){return this._startTangent}set startTangent(t){this._startTangent=t}get endTangent(){return this._endTangent}set endTangent(t){this._endTangent=t}get fitPoints(){return this._fitPoints}set fitPoints(t){this._fitPoints=t}get knots(){return this._knots}set knots(t){this._knots=t}captureOptionalProps(t,e,i,s,n,r,o,a){this._order=K.resolveToUndefined(t,0),this._closed=K.resolveToUndefined(e,!1),this._isChordLenKnots=K.resolveToUndefined(i,0),this._isColinearTangents=K.resolveToUndefined(s,0),this._isChordLenTangents=K.resolveToUndefined(n,0),this._isNaturalTangents=K.resolveToUndefined(r,0),this._startTangent=o,this._endTangent=a}cloneAsInterpolationCurve3dProps(){const t={fitPoints:ae.cloneDeepJSONNumberArrays(this.fitPoints),knots:this._knots?.slice()};return void 0!==this._order&&(t.order=this._order),void 0!==this._closed&&(t.closed=this._closed),void 0!==this._isChordLenKnots&&(t.isChordLenKnots=this._isChordLenKnots),void 0!==this._isColinearTangents&&(t.isColinearTangents=this._isColinearTangents),void 0!==this._isChordLenTangents&&(t.isChordLenTangents=this._isChordLenTangents),void 0!==this._isNaturalTangents&&(t.isNaturalTangents=this._isNaturalTangents),void 0!==this._startTangent&&(t.startTangent=this._startTangent?.toArray()),void 0!==this._endTangent&&(t.endTangent=this._endTangent?.toArray()),t}clone(){const t=new ue(ae.clonePoint3dArray(this.fitPoints),this.knots?.slice());return t._order=this.order,t._closed=this.closed,t._isChordLenKnots=this.isChordLenKnots,t._isColinearTangents=this.isColinearTangents,t._isChordLenTangents=this.isChordLenTangents,t._isNaturalTangents=this.isNaturalTangents,t._startTangent=this._startTangent?.clone(),t._endTangent=this._endTangent?.clone(),t}static create(t){const e=new ue(ae.clonePoint3dArray(t.fitPoints),t.knots?.slice());return e._order=t.order,e._closed=t.closed,e._isChordLenKnots=t.isChordLenKnots,e._isColinearTangents=t.isColinearTangents,e._isChordLenTangents=t.isChordLenTangents,e._isNaturalTangents=t.isNaturalTangents,e._startTangent=t.startTangent?$.fromJSON(t.startTangent):void 0,e._endTangent=t.endTangent?$.fromJSON(t.endTangent):void 0,e}static areAlmostEqualAllow000AsUndefined(t,e){return void 0!==t&&0===t.maxAbs()&&(t=void 0),void 0!==e&&0===e.maxAbs()&&(e=void 0),void 0!==t&&void 0!==e?t.isAlmostEqual(e):void 0===t&&void 0===e}static areAlmostEqual(t,e){if(void 0===t&&void 0===e)return!0;if(void 0!==t&&void 0!==e&&K.areEqualAllowUndefined(t.order,e.order)&&K.areEqualAllowUndefined(t.closed,e.closed)&&K.areEqualAllowUndefined(t.isChordLenKnots,e.isChordLenKnots)&&K.areEqualAllowUndefined(t.isColinearTangents,e.isColinearTangents)&&K.areEqualAllowUndefined(t.isNaturalTangents,e.isNaturalTangents)&&this.areAlmostEqualAllow000AsUndefined(t.startTangent,e.startTangent)&&this.areAlmostEqualAllow000AsUndefined(t.endTangent,e.endTangent)&&K.almostEqualArrays(t.fitPoints,e.fitPoints,((t,e)=>t.isAlmostEqual(e)))){if(K.almostEqualNumberArrays(t.knots,e.knots,((t,e)=>t===e)))return!0;if(void 0===t.knots&&void 0===e.knots)return!0;let i=t.knots,s=e.knots;return void 0===t.knots?i=de.C2CubicFit.constructFitParametersFromPoints(t.fitPoints,t.isChordLenKnots,t.closed):void 0===e.knots&&(s=de.C2CubicFit.constructFitParametersFromPoints(e.fitPoints,e.isChordLenKnots,e.closed)),i=de.C2CubicFit.convertCubicKnotVectorToFitParams(i,t.fitPoints.length,!1),s=de.C2CubicFit.convertCubicKnotVectorToFitParams(s,e.fitPoints.length,!1),K.almostEqualNumberArrays(i,s,((t,e)=>K.isAlmostEqualNumber(t,e)))}return!1}reverseInPlace(){this.fitPoints.reverse(),this.knots&&this.knots.reverse();const t=this._startTangent;this._startTangent=this.endTangent,this._endTangent=t}}class fe extends ce{constructor(t,e){super(e),this.curvePrimitiveType="interpolationCurve",this._options=t}dispatchToGeometryHandler(t){let e=t.handleInterpolationCurve3d(this);return void 0===e&&(e=this._proxyCurve.dispatchToGeometryHandler(t)),e}static create(t){let e;return e=t instanceof ue?t.clone():ue.create(t),fe.createCapture(e)}static createCapture(t){const e=ze.createFromInterpolationCurve3dOptions(t);if(e)return new fe(t,e)}copyFitPointsFloat64Array(){return ae.cloneXYZPropsAsFloat64Array(this._options.fitPoints)}toJSON(){return this._options.cloneAsInterpolationCurve3dProps()}cloneProps(){return this._options.cloneAsInterpolationCurve3dProps()}get options(){return this._options}reverseInPlace(){this._proxyCurve.reverseInPlace(),this._options.reverseInPlace()}tryTransformInPlace(t){const e=this._proxyCurve.tryTransformInPlace(t);return e&&(t.multiplyPoint3dArrayInPlace(this._options.fitPoints),this._options.startTangent&&t.multiplyVectorInPlace(this._options.startTangent),this._options.endTangent&&t.multiplyVectorInPlace(this._options.endTangent)),e}clone(){return new fe(this._options.clone(),this._proxyCurve.clone())}isAlmostEqual(t){return t instanceof fe&&ue.areAlmostEqual(this._options,t._options)}isSameGeometryClass(t){return t instanceof fe}}class ge{constructor(t,e){this._p0=Q.createZero(),this._p1=Q.createZero(),this._v0=$.createZero(),this._v1=$.createZero(),this._r0=bt.createZero(),this._offsetDistance=e,this._fitOptions=new ue;const i=t.fractionToPointAndUnitTangent(0,this._r0).direction.clone(),s=t.fractionToPointAndUnitTangent(1,this._r0).direction.negate();this._fitOptions.startTangent=i,this._fitOptions.endTangent=s,(this._fitOptions.closed=t.startPoint(this._p0).isAlmostEqual(t.endPoint(this._p1))&&i.isParallelTo(s,!0))&&(this._fitOptions.isChordLenKnots=1)}pushOffsetPoint(t,e){K.isSmallMetricDistance(e.x)&&K.isSmallMetricDistance(e.y)||this._fitOptions.fitPoints.push(t.plusScaled(e.unitPerpendicularXY(this._v0),this._offsetDistance))}needPrimaryGeometryForStrokes(){return!0}startParentCurvePrimitive(t){}startCurvePrimitive(t){}endCurvePrimitive(t){}endParentCurvePrimitive(t){}announceIntervalForUniformStepStrokes(t,e,i,s){for(let n=0;n<=e;++n){const r=K.interpolate(i,n/e,s),o=t.fractionToPointAndDerivative(r,this._r0);this.pushOffsetPoint(o.origin,o.direction)}}announceSegmentInterval(t,e,i,s,n,r){if(s>0){const t=$.createStartEnd(e,i,this._v1);for(let n=0;n<=s;++n)this.pushOffsetPoint(e.interpolate(n/s,i,this._p0),t)}}announcePointTangent(t,e,i){this.pushOffsetPoint(t,i)}claimResult(){return de.createThroughPointsC2Cubic(this._fitOptions)}}class pe{handleCurveCollection(t){}handlePath(t){return this.handleCurveCollection(t)}handleLoop(t){return this.handleCurveCollection(t)}handleParityRegion(t){return this.handleCurveCollection(t)}handleUnionRegion(t){return this.handleCurveCollection(t)}handleBagOfCurves(t){return this.handleCurveCollection(t)}}class me extends pe{handleLineSegment3d(t){}handleLineString3d(t){}handleArc3d(t){}handleCurveCollection(t){}handleBSplineCurve3d(t){}handleInterpolationCurve3d(t){}handleAkimaCurve3d(t){}handleBSplineCurve3dH(t){}handleBSplineSurface3d(t){}handleCoordinateXYZ(t){}handleBSplineSurface3dH(t){}handleIndexedPolyface(t){}handleTransitionSpiral(t){}handlePath(t){}handleLoop(t){}handleParityRegion(t){}handleUnionRegion(t){}handleBagOfCurves(t){}handleSphere(t){}handleCone(t){}handleBox(t){}handleTorusPipe(t){}handleLinearSweep(t){}handleRotationalSweep(t){}handleRuledSweep(t){}handlePointString3d(t){}handleBezierCurve3d(t){}handleBezierCurve3dH(t){}}class xe extends pe{handleLineSegment3d(t){}handleLineString3d(t){}handleArc3d(t){}handleBSplineCurve3d(t){}handleInterpolationCurve3d(t){}handleAkimaCurve3d(t){}handleBSplineCurve3dH(t){}handleBSplineSurface3d(t){}handleCoordinateXYZ(t){}handleBSplineSurface3dH(t){}handleIndexedPolyface(t){}handleTransitionSpiral(t){}handleChildren(t){const e=t.children;if(e)for(const t of e)t.dispatchToGeometryHandler(this)}handleCurveCollection(t){return this.handleChildren(t)}handlePath(t){return this.handleChildren(t)}handleLoop(t){return this.handleChildren(t)}handleParityRegion(t){return this.handleChildren(t)}handleUnionRegion(t){return this.handleChildren(t)}handleBagOfCurves(t){return this.handleChildren(t)}handleSphere(t){}handleCone(t){}handleBox(t){}handleTorusPipe(t){}handleLinearSweep(t){}handleRotationalSweep(t){}handleRuledSweep(t){}handlePointString3d(t){}handleBezierCurve3d(t){}handleBezierCurve3dH(t){}}class ye{constructor(){this.shouldTriangulate=!1,this.defaultCircleStrokes=16}get needParams(){return void 0!==this._needParams&&this._needParams}set needParams(t){this._needParams=t}get needNormals(){return void 0!==this._needNormals&&this._needNormals}set needNormals(t){this._needNormals=t}get needTwoSided(){return void 0!==this._needTwoSided&&this._needTwoSided}set needTwoSided(t){this._needTwoSided=t}get hasAngleTol(){return void 0!==this.angleTol&&Math.abs(this.angleTol.radians)>0}get hasChordTol(){return void 0!==this.chordTol&&this.chordTol>0}get hasMaxEdgeLength(){return void 0!==this.maxEdgeLength&&this.maxEdgeLength>0}clone(){const t=new ye;return t.chordTol=this.chordTol,t.angleTol=this.angleTol?.clone(),t.maxEdgeLength=this.maxEdgeLength,t.needConvexFacets=this.needConvexFacets,t.minStrokesPerPrimitive=this.minStrokesPerPrimitive,t.shouldTriangulate=this.shouldTriangulate,t._needNormals=this._needNormals,t._needTwoSided=this._needTwoSided,t._needParams=this._needParams,t.needColors=this.needColors,t.defaultCircleStrokes=this.defaultCircleStrokes,t}applyMaxEdgeLength(t,e){return e=Math.abs(e),this.maxEdgeLength&&this.maxEdgeLength>0&&t*this.maxEdgeLength<e&&(t=K.stepCount(this.maxEdgeLength,e,t)),t}applyAngleTol(t,e,i){return ye.applyAngleTol(this,t,e,i)}static applyAngleTol(t,e,i,s){i=Math.abs(i);let n=s||Math.PI/8;return t&&t.angleTol&&t.angleTol.radians>0&&(n=t.angleTol.radians),e*n<i&&(e=K.stepCount(n,i,e)),e}static applyMaxEdgeLength(t,e,i){return i<0&&(i=-i),e<1&&(e=1),t&&t.maxEdgeLength&&t.maxEdgeLength*e<i&&(e=K.stepCount(t.maxEdgeLength,i,e)),e}applyTolerancesToArc(t,e=2*Math.PI){let i=1;return i=this.applyAngleTol(i,e,.25*Math.PI),i=this.applyMaxEdgeLength(i,e*t),i=this.applyChordTol(i,t,e),i=this.applyMinStrokesPerPrimitive(i),i}applyChordTol(t,e,i){if(this.chordTol&&this.chordTol>0&&this.chordTol<e){const s=this.chordTol,n=2*Math.acos(1-s/e);t=K.stepCount(n,i,t)}return t}applyChordTolToLengthAndRadians(t,e,i){if(this.chordTol&&this.chordTol>0){const s=K.conditionalDivideFraction(e,i);if(void 0!==s)return this.applyChordTol(t,s,i)}return t}applyMinStrokesPerPrimitive(t){return void 0!==this.minStrokesPerPrimitive&&Number.isFinite(this.minStrokesPerPrimitive)&&this.minStrokesPerPrimitive>t&&(t=this.minStrokesPerPrimitive),t}static createForCurves(){const t=new ye;return t.angleTol=W.createDegrees(15),t}static createForFacets(){const t=new ye;return t.angleTol=W.createDegrees(22.5),t}}class _e{constructor(t,e=180,i=90,s=!1,n=!1){this.minArcDegrees=180,this.maxChamferTurnDegrees=90,this.allowSharpestCorners=!1,this.leftOffsetDistance=0,this.preserveEllipticalArcs=!1,this.leftOffsetDistance=t,this.minArcDegrees=e,this.maxChamferTurnDegrees=i,this.preserveEllipticalArcs=s,this.allowSharpestCorners=n}clone(){return new _e(this.leftOffsetDistance,this.minArcDegrees,this.maxChamferTurnDegrees,this.preserveEllipticalArcs,this.allowSharpestCorners)}setFrom(t){this.leftOffsetDistance=t.leftOffsetDistance,this.minArcDegrees=t.minArcDegrees,this.maxChamferTurnDegrees=t.maxChamferTurnDegrees,this.preserveEllipticalArcs=t.preserveEllipticalArcs,this.allowSharpestCorners=t.allowSharpestCorners}static create(t){return t instanceof _e?t:new _e(t)}needArc(t){return Math.abs(t.degrees)>=this.minArcDegrees}numChamferPoints(t){const e=Math.abs(t.degrees);let i=120;this.allowSharpestCorners&&(i=this.maxChamferTurnDegrees);const s=K.clamp(this.maxChamferTurnDegrees,10,i);return e<=s?1:Math.ceil(e/s)}}class ve{constructor(t,e){this.jointOptions=_e.create(t),this.strokeOptions=void 0!==e?e:ye.createForCurves()}get minArcDegrees(){return this.jointOptions.minArcDegrees}set minArcDegrees(t){this.jointOptions.minArcDegrees=t}get maxChamferTurnDegrees(){return this.jointOptions.maxChamferTurnDegrees}set maxChamferTurnDegrees(t){this.jointOptions.maxChamferTurnDegrees=t}get allowSharpestCorners(){return this.jointOptions.allowSharpestCorners}set allowSharpestCorners(t){this.jointOptions.allowSharpestCorners=t}get leftOffsetDistance(){return this.jointOptions.leftOffsetDistance}set leftOffsetDistance(t){this.jointOptions.leftOffsetDistance=t}get preserveEllipticalArcs(){return this.jointOptions.preserveEllipticalArcs}set preserveEllipticalArcs(t){this.jointOptions.preserveEllipticalArcs=t}static create(t){return t instanceof ve?t:new ve(t)}static getOffsetDistance(t){return"number"==typeof t?t:t.leftOffsetDistance}clone(){return new ve(this.jointOptions.clone(),this.strokeOptions.clone())}}class Pe extends ie{isSameGeometryClass(t){return t instanceof Pe}get point0Ref(){return this._point0}get point1Ref(){return this._point1}get isExtensibleFractionSpace(){return!0}constructor(t,e){super(),this.curvePrimitiveType="lineSegment",this._point0=t,this._point1=e}setRefs(t,e){this._point0=t,this._point1=e}set(t,e){this._point0=t.clone(),this._point1=e.clone()}setFrom(t){this._point0.setFrom(t._point0),this._point1.setFrom(t._point1)}startPoint(t){return t?(t.setFrom(this._point0),t):this._point0.clone()}endPoint(t){return t?(t.setFrom(this._point1),t):this._point1.clone()}fractionToPointAndDerivative(t,e){return(e=e||bt.createZero()).direction.setStartEnd(this._point0,this._point1),this._point0.interpolate(t,this._point1,e.origin),e}fractionToPointAnd2Derivatives(t,e){return(e=e||Et.createXYPlane()).vectorU.setStartEnd(this._point0,this._point1),e.vectorV.set(0,0,0),this._point0.interpolate(t,this._point1,e.origin),e}clone(){return Pe.create(this._point0,this._point1)}cloneTransformed(t){const e=this.clone();return e.tryTransformInPlace(t),e}static create(t,e,i){return i?(i.set(t,e),i):new Pe(t.clone(),e.clone())}static createCapture(t,e){return new Pe(t,e)}static createXYXY(t,e,i,s,n=0,r){return r?(r._point0.set(t,e,n),r._point1.set(i,s,n),r):new Pe(Q.create(t,e,n),Q.create(i,s,n))}static createXYZXYZ(t,e,i,s,n,r,o){return o?(o._point0.set(t,e,i),o._point1.set(s,n,r),o):new Pe(Q.create(t,e,i),Q.create(s,n,r))}fractionToPoint(t,e){return this._point0.interpolate(t,this._point1,e)}curveLength(){return this._point0.distance(this._point1)}curveLengthBetweenFractions(t,e){return Math.abs(e-t)*this._point0.distance(this._point1)}quickLength(){return this.curveLength()}closestPoint(t,e,i){let s=t.fractionOfProjectionToLine(this._point0,this._point1,0);return s=jt.correctFraction(e,s),(i=vt.create(this,i)).fraction=s,this._point0.interpolate(s,this._point1,i.point),i.vectorInCurveLocationDetail=void 0,i.a=i.point.distance(t),i}reverseInPlace(){const t=this._point0;this._point0=this._point1,this._point1=t}tryTransformInPlace(t){return this._point0=t.multiplyPoint3d(this._point0,this._point0),this._point1=t.multiplyPoint3d(this._point1,this._point1),!0}isInPlane(t){return K.isSmallMetricDistance(t.altitude(this._point0))&&K.isSmallMetricDistance(t.altitude(this._point1))}appendPlaneIntersectionPoints(t,e){const i=t.altitude(this._point0),s=t.altitude(this._point1),n=Ut.solveCoffs(i,s);let r=0;if(void 0!==n){r++;const t=vt.createCurveFractionPoint(this,n,this.fractionToPoint(n));t.intervalRole=I.isolated,e.push(t)}return r}extendRange(t,e){e?(t.extendTransformedPoint(e,this._point0),t.extendTransformedPoint(e,this._point1)):(t.extendPoint(this._point0),t.extendPoint(this._point1))}setFromJSON(t){if(!t)return this._point0.set(0,0,0),void this._point1.set(1,0,0);t.startPoint&&t.endPoint?(this._point0.setFromJSON(t.startPoint),this._point1.setFromJSON(t.endPoint)):Array.isArray(t)&&t.length>1&&(this._point0.setFromJSON(t[0]),this._point1.setFromJSON(t[1]))}getFractionToDistanceScale(){return this.curveLength()}toJSON(){return[this._point0.toJSON(),this._point1.toJSON()]}static fromJSON(t){const e=new Pe(Q.createZero(),Q.create());return e.setFromJSON(t),e}isAlmostEqual(t){if(t instanceof Pe){const e=t;return this._point0.isAlmostEqual(e._point0)&&this._point1.isAlmostEqual(e._point1)}return!1}emitStrokes(t,e){const i=this.computeStrokeCountForOptions(e);t.appendFractionalStrokePoints(this,i,0,1)}emitStrokableParts(t,e){t.startCurvePrimitive(this);const i=this.computeStrokeCountForOptions(e);t.announceSegmentInterval(this,this._point0,this._point1,i,0,1),t.endCurvePrimitive(this)}computeStrokeCountForOptions(t){let e=1;return t&&(t.maxEdgeLength&&(e=t.applyMaxEdgeLength(e,this.curveLength())),e=t.applyMinStrokesPerPrimitive(e)),e}dispatchToGeometryHandler(t){return t.handleLineSegment3d(this)}announceClipIntervals(t,e){return t.announceClippedSegmentIntervals(0,1,this._point0,this._point1,e?(t,i)=>e(t,i,this):void 0)}clonePartialCurve(t,e){return Pe.create(this.fractionToPoint(t),this.fractionToPoint(e))}rangeBetweenFractions(t,e,i){if(!i){const i=ut.create();return i.extendInterpolated(this._point0,t,this._point1),i.extendInterpolated(this._point0,e,this._point1),i}const s=this.fractionToPoint(t),n=this.fractionToPoint(e);return i&&(i.multiplyPoint3d(s,s),i.multiplyPoint3d(n,n)),ut.create(s,n)}constructOffsetXY(t){const e=$.createStartEnd(this._point0,this._point1);if(e.normalizeInPlace()){e.rotate90CCWXY(e);const i=ve.getOffsetDistance(t);return Pe.create(this._point0.plusScaled(e,i),this._point1.plusScaled(e,i))}}projectedParameterRange(t,e){return Te.findExtremeFractionsAlongDirection(this,t,e)}}class Ie{getXAtUncheckedPointIndex(t){const e=this.getPoint2dAtCheckedPointIndex(t,Ie._workPoint);return void 0===Ie._workPoint&&(Ie._workPoint=e),e?e.x:0}getYAtUncheckedPointIndex(t){const e=this.getPoint2dAtCheckedPointIndex(t,Ie._workPoint);return void 0===Ie._workPoint&&(Ie._workPoint=e),e?e.y:0}linearCombination(t,e){const i=Math.min(this.length,t.length),s=e instanceof J?J.createZero(e):H.createZero(e);for(let e=0;e<i;++e)s.x+=t[e]*this.getXAtUncheckedPointIndex(e),s.y+=t[e]*this.getYAtUncheckedPointIndex(e);return s}}class Ae extends Ie{constructor(t=8,e){super(),this._data=new Float64Array(2*t),this._xyInUse=0,this._xyCapacity=t,this._growthFactor=void 0!==e&&e>=1?e:1.5}copyData(t,e,i){let s=void 0!==i?2*i:0;if(s<0&&(s=0),s>=this._data.length)return{count:0,offset:0};let n=void 0!==e?2*e:t.length;return n>0&&(n>t.length&&(n=t.length),s+n>this._data.length&&(n=this._data.length-s),n%2!=0&&(n-=n%2)),n<=0?{count:0,offset:0}:(n===t.length?this._data.set(t,s):t instanceof Float64Array?this._data.set(t.subarray(0,n),s):this._data.set(t.slice(0,n),s),{count:n/2,offset:s/2})}get length(){return this._xyInUse}set length(t){this.resize(t,!0)}get float64Length(){return 2*this._xyInUse}float64Data(){return this._data}ensureCapacity(t,e=!0){if(t>this._xyCapacity){e&&(t*=this._growthFactor);const i=this._data;this._data=new Float64Array(2*t),this.copyData(i,this._xyInUse),this._xyCapacity=t}}resize(t,e){t>=0&&t<this._xyInUse?this._xyInUse=t:t>this._xyInUse&&(this.ensureCapacity(t,!1),e&&this._data.fill(0,2*this._xyInUse),this._xyInUse=t)}clone(){const t=new Ae(this.length);return t.copyData(this._data,this.length),t._xyInUse=this.length,t}static create(t,e){if(e)e.clear();else{const i="number"==typeof t[0]?t.length/2:t.length;e=new Ae(i)}return e.pushFrom(t),e}static createArrayOfGrowableXYZArray(t){return nt.createArrayOfGrowableXYZArray(t)}push(t){this.pushXY(t.x,t.y)}pushAll(t){this.ensureCapacity(this._xyInUse+t.length,!1);for(const e of t)this.push(e)}pushAllXYAndZ(t){if(this.ensureCapacity(this._xyInUse+t.length,!1),t instanceof nt){const e=t.float64Data(),i=3*t.length;for(let t=0;t+2<i;t+=3)this.pushXY(e[t],e[t+1])}else for(const e of t)this.pushXY(e.x,e.y)}pushFrom(t){if(t instanceof Q)this.pushXY(t.x,t.y);else if(t instanceof nt)this.pushAllXYAndZ(t);else if(t instanceof H)this.pushXY(t.x,t.y);else if(K.isNumberArray(t,3)||t instanceof Float64Array){const e=Math.trunc(t.length/2);this.ensureCapacity(this._xyInUse+e,!1),this.copyData(t,e,this._xyInUse),this._xyInUse+=e}else if(K.isNumberArray(t,2))this.pushXY(t[0],t[1]);else if(Array.isArray(t))for(const e of t)this.pushFrom(e);else if(Q.isXAndY(t))this.pushXY(t.x,t.y);else if(t instanceof Ie){const e=t.length;this.ensureCapacity(this._xyInUse+e,!1);for(let i=0;i<e;i++)this.pushXY(t.getXAtUncheckedPointIndex(i),t.getYAtUncheckedPointIndex(i))}}pushWrap(t){if(this._xyInUse>=t){this.ensureCapacity(this._xyInUse+t,!1);for(let e=0;e<t;e++){const t=2*e;this.pushXY(this._data[t],this._data[t+1])}}}pushXY(t,e){this.ensureCapacity(this._xyInUse+1);const i=2*this._xyInUse;this._data[i]=t,this._data[i+1]=e,this._xyInUse++}pop(){this._xyInUse>0&&this._xyInUse--}isIndexValid(t){return!(t>=this._xyInUse||t<0)}clear(){this._xyInUse=0}getPoint2dAtUncheckedPointIndex(t,e){const i=2*t;return H.create(this._data[i],this._data[i+1],e)}getXAtUncheckedPointIndex(t){return this._data[2*t]}getYAtUncheckedPointIndex(t){return this._data[2*t+1]}getPoint2dArray(){const t=2*this._xyInUse,e=[],i=this._data;for(let s=0;s<t;s+=2)e.push(H.create(i[s],i[s+1]));return e}getPoint2dAtCheckedPointIndex(t,e){if(this.isIndexValid(t)){const i=2*t;return H.create(this._data[i],this._data[i+1],e)}}getVector2dAtCheckedVectorIndex(t,e){if(this.isIndexValid(t)){const i=2*t;return J.create(this._data[i],this._data[i+1],e)}}transferFromGrowableXYArray(t,e,i){if(this.isIndexValid(t)&&e.isIndexValid(i)){const s=2*t,n=2*i;return this._data[s]=e._data[n],this._data[s+1]=e._data[n+1],!0}return!1}pushFromGrowableXYArray(t,e){if(void 0===e){const e=t.length;return this.ensureCapacity(this.length+e,!1),this.copyData(t._data,e,this.length),this._xyInUse+=e,e}if(t.isIndexValid(e)){const i=2*e;return this.pushXY(t._data[i],t._data[i+1]),1}return 0}pushInterpolatedFromGrowableXYArray(t,e,i,s){if(t.isIndexValid(e)&&t.isIndexValid(s)){const n=1-i,r=t._data;e*=2,s*=2,this.pushXY(n*r[e]+i*r[s],n*r[e+1]+i*r[s+1])}}static createFromGrowableXYZArray(t,e,i){const s=t.length;if(i?(i.ensureCapacity(s,!1),i.clear()):i=new Ae(s),e){const n=t.float64Data(),r=3*s;let o,a,c;for(let t=0;t<r;t+=3)o=n[t],a=n[t+1],c=n[t+2],i.pushXY(e.multiplyComponentXYZ(0,o,a,c),e.multiplyComponentXYZ(1,o,a,c))}else i.pushAllXYAndZ(t);return i}front(t){if(0!==this._xyInUse)return this.getPoint2dAtUncheckedPointIndex(0,t)}back(t){if(!(this._xyInUse<1))return this.getPoint2dAtUncheckedPointIndex(this._xyInUse-1,t)}setAtCheckedPointIndex(t,e){if(!this.isIndexValid(t))return!1;const i=2*t;return this._data[i]=e.x,this._data[i+1]=e.y,!0}setXYAtCheckedPointIndex(t,e,i){if(!this.isIndexValid(t))return!1;const s=2*t;return this._data[s]=e,this._data[s+1]=i,!0}setXYZAtCheckedPointIndex(t,e,i){return this.setXYAtCheckedPointIndex(t,e,i)}getPoint3dArray(t=0){const e=2*this._xyInUse,i=[],s=this._data;for(let n=0;n<e;n+=2)i.push(Q.create(s[n],s[n+1],t));return i}reverseInPlace(){const t=this.length;let e,i,s;const n=this._data;for(let r=0,o=t-1;r<o;r++,o--)e=2*r,i=2*o,s=n[e],n[e]=n[i],n[i]=s,e++,i++,s=n[e],n[e]=n[i],n[i]=s}multiplyTransformInPlace(t){const e=this._data,i=this.float64Length,s=t.matrix.coffs,n=t.origin,r=n.x,o=n.y;let a=0,c=0;for(let t=0;t+1<i;t+=2)a=e[t],c=e[t+1],e[t]=s[0]*a+s[1]*c+r,e[t+1]=s[3]*a+s[4]*c+o}multiplyMatrix3dInPlace(t){const e=this._data,i=this.float64Length,s=t.coffs;let n=0,r=0;for(let t=0;t+1<i;t+=2)n=e[t],r=e[t+1],e[t]=s[0]*n+s[1]*r,e[t+1]=s[3]*n+s[4]*r}tryTransformInverseInPlace(t){const e=this._data,i=this.float64Length,s=t.matrix;s.computeCachedInverse(!0);const n=s.inverseCoffs;if(!n)return!1;const r=t.origin,o=r.x,a=r.y;let c=0,h=0;for(let t=0;t+1<i;t+=2)c=e[t]-o,h=e[t+1]-a,e[t]=n[0]*c+n[1]*h,e[t+1]=n[3]*c+n[4]*h;return!0}extendRange(t,e){const i=this.float64Length,s=this._data;if(e)for(let n=0;n+1<i;n+=2)t.extendTransformedXY(e,s[n],s[n+1]);else for(let e=0;e+1<i;e+=2)t.extendXY(s[e],s[e+1])}sumLengths(){let t=0;const e=2*(this._xyInUse-1),i=this._data;for(let s=0;s<e;s+=2)t+=K.hypotenuseXY(i[s+2]-i[s],i[s+3]-i[s+1]);return t}scaleInPlace(t){if(this._data){const e=this.float64Length;for(let i=0;i<e;i++)this._data[i]=this._data[i]*t}}interpolate(t,e,i,s){if(this.isIndexValid(t)&&this.isIndexValid(i)){const n=1-e,r=this._data;return t*=2,i*=2,H.create(n*r[t]+e*r[i],n*r[t+1]+e*r[i+1],s)}}areaXY(){let t=0;const e=2*this._xyInUse;if(e>4){const i=this._data[e-2],s=this._data[e-1];let n=this._data[0]-i,r=this._data[1]-s,o=0,a=0;for(let c=2;c<e;c+=2,n=o,r=a)o=this._data[c]-i,a=this._data[c+1]-s,t+=K.crossProductXYXY(n,r,o,a)}return.5*t}vectorIndexIndex(t,e,i){if(!this.isIndexValid(t)||!this.isIndexValid(e))return;const s=this._data;return t*=2,e*=2,J.create(s[e]-s[t],s[e+1]-s[t+1],i)}vectorXAndYIndex(t,e,i){if(this.isIndexValid(e)){const s=this._data;return e*=2,J.create(s[e]-t.x,s[e+1]-t.y,i)}}crossProductIndexIndexIndex(t,e,i){if(this.isIndexValid(t)&&this.isIndexValid(e)&&this.isIndexValid(i)){const s=2*t,n=2*e,r=2*i,o=this._data;return K.crossProductXYXY(o[n]-o[s],o[n+1]-o[s+1],o[r]-o[s],o[r+1]-o[s+1])}}crossProductXAndYIndexIndex(t,e,i){if(this.isIndexValid(e)&&this.isIndexValid(i)){const s=2*e,n=2*i,r=this._data;return K.crossProductXYXY(r[s]-t.x,r[s+1]-t.y,r[n]-t.x,r[n+1]-t.y)}}distance(t,e){if(this.isIndexValid(t)&&this.isIndexValid(e)){const i=2*t,s=2*e;return K.hypotenuseXY(this._data[s]-this._data[i],this._data[s+1]-this._data[i+1])}}distanceIndexToPoint(t,e){if(this.isIndexValid(t)){const i=2*t;return K.hypotenuseXY(e.x-this._data[i],e.y-this._data[i+1])}}static isAlmostEqual(t,e){if(t&&e){if(t.length!==e.length)return!1;for(let i=0;i<t.length;i++)if(!t.getPoint2dAtUncheckedPointIndex(i).isAlmostEqual(e.getPoint2dAtUncheckedPointIndex(i)))return!1;return!0}return!t&&!e}sortIndicesLexical(){const t=this._xyInUse,e=new Uint32Array(t);for(let i=0;i<t;i++)e[i]=i;return e.sort(((t,e)=>this.compareLexicalBlock(t,e))),e}compareLexicalBlock(t,e){let i=0,s=0;for(let n=0;n<2;n++){if(i=this._data[2*t+n],s=this._data[2*e+n],i>s)return 1;if(i<s)return-1}return t-e}component(t,e){return this._data[2*t+e]}isAlmostEqual(t,e=K.smallMetricDistance){const i=this._xyInUse;if(t._xyInUse!==i)return!1;const s=this._data,n=t._data;for(let t=0;t<2*i;t++)if(Math.abs(s[t]-n[t])>e)return!1;return!0}}function Se(t,e,i,s,n,r,o){const a=t.length;if(s>0){for(let s=i;s+1<a;s++)if(t.vectorIndexIndex(s,s+1,o),e.crossProduct(o,o),o.normalizeInPlace())return r.addScaledInPlace(o,n),!0}else{i+1>=a&&(i=a-2);for(let s=i;s>=0;s--)if(t.vectorIndexIndex(s,s+1,o),o.crossProduct(e,o),o.normalizeInPlace())return r.addScaledInPlace(o,n),!0}return!1}class we extends ie{isSameGeometryClass(t){return t instanceof we}get isExtensibleFractionSpace(){return!0}get points(){return this._points.getPoint3dArray()}get packedPoints(){return this._points}get fractions(){return this._fractions}get packedDerivatives(){return this._derivatives}get packedUVParams(){return this._uvParams}get packedSurfaceNormals(){return this._surfaceNormals}get normalIndices(){return this._normalIndices}get paramIndices(){return this._uvIndices}get pointIndices(){return this._pointIndices}constructor(t){super(),this.curvePrimitiveType="lineString",this._points=t||new nt}cloneTransformed(t){const e=this.clone();return e.tryTransformInPlace(t),e}static create(...t){const e=new we;return e.addPoints(t),e}static createCapture(t){return new we(t)}static createXY(t,e,i=!1){const s=new we,n=s._points;for(const i of t)n.pushXYZ(i.x,i.y,e);if(i&&t.length>1){const t=n.distanceIndexIndex(0,n.length-1);if(void 0!==t&&0!==t&&K.isSameCoordinate(0,t)){n.pop();const t=n.front();n.push(t)}}return s}addPoints(...t){this._points.pushFrom(t)}addSteppedPoints(t,e,i,s){this._points.addSteppedPoints(t,e,i,s)}addPoint(t){this._points.push(t)}addPointXYZ(t,e,i=0){this._points.pushXYZ(t,e,i)}addFraction(t){this._fractions||(this._fractions=new St),this._fractions.push(t)}ensureEmptyFractions(){const t=this.numPoints();return this._fractions?(this._fractions.clear(),this._fractions.ensureCapacity(t),this._fractions):(this._fractions=new St(t),this._fractions)}ensureEmptyUVParams(){const t=this.numPoints();return this._uvParams?(this._uvParams.clear(),this._uvParams.ensureCapacity(t),this._uvParams):(this._uvParams=new Ae(t),this._uvParams)}ensureEmptySurfaceNormals(){const t=this.numPoints();return this._surfaceNormals?(this._surfaceNormals.clear(),this._surfaceNormals.ensureCapacity(t),this._surfaceNormals):(this._surfaceNormals=new nt(t),this._surfaceNormals)}ensureEmptyDerivatives(){const t=this.numPoints();return this._derivatives?(this._derivatives.clear(),this._derivatives.ensureCapacity(t),this._derivatives):(this._derivatives=new nt(t),this._derivatives)}ensureEmptyNormalIndices(){const t=this.numPoints();return this._normalIndices?(this._normalIndices.clear(),this._normalIndices.ensureCapacity(t),this._normalIndices):(this._normalIndices=new St(t),this._normalIndices)}ensureEmptyUVIndices(){const t=this.numPoints();return this._uvIndices?(this._uvIndices.clear(),this._uvIndices.ensureCapacity(t),this._uvIndices):(this._uvIndices=new St(t),this._uvIndices)}ensureEmptyPointIndices(){const t=this.numPoints();return this._pointIndices?(this._pointIndices.clear(),this._pointIndices.ensureCapacity(t),this._pointIndices):(this._pointIndices=new St(t),this._pointIndices)}addUVParam(t){this._uvParams||(this._uvParams=new Ae),this._uvParams.pushXY(t.x,t.y)}addUVParamAsUV(t,e){this._uvParams||(this._uvParams=new Ae),this._uvParams.pushXY(t,e)}addDerivative(t){this._derivatives||(this._derivatives=new nt),this._derivatives.push(t)}addSurfaceNormal(t){this._surfaceNormals||(this._surfaceNormals=new nt),this._surfaceNormals.push(t)}addClosurePoint(){const t=this._points.distanceIndexIndex(0,this._points.length-1);void 0===t||K.isSameCoordinate(t,0)||this._points.pushWrap(1)}popPoint(){this._points.pop()}computeUVFromXYZTransform(t){this._uvParams=Ae.createFromGrowableXYZArray(this._points,t)}static createRectangleXY(t,e,i,s=!0){const n=we.create(),r=t.x,o=t.x+e,a=t.y,c=t.y+i,h=t.z;return n.addPointXYZ(r,a,h),n.addPointXYZ(o,a,h),n.addPointXYZ(o,c,h),n.addPointXYZ(r,c,h),s&&n.addClosurePoint(),n}static createRegularPolygonXY(t,e,i,s=!0){e<3&&(e=3);const n=we.create(),r=s?0:-1,o=Math.PI/e;let a,c,h;s||(i/=Math.cos(o));for(let s=0;s<e;s++)h=(r+2*s)*o,a=W.cleanupTrigValue(Math.cos(h)),c=W.cleanupTrigValue(Math.sin(h)),n.addPointXYZ(t.x+i*a,t.y+i*c,t.z);return n.addClosurePoint(),n}setFrom(t){this._points=t._points.clone(this._points),t._derivatives?this._derivatives=t._derivatives.clone(this._derivatives):this._derivatives=void 0,t._fractions?this._fractions=t._fractions.clone(!1):this._fractions=void 0,t._surfaceNormals?this._surfaceNormals=t._surfaceNormals.clone(this._surfaceNormals):this._surfaceNormals=void 0,t._uvParams?this._uvParams=t._uvParams.clone():this._uvParams=void 0}static createPoints(t){const e=new we;let i;for(i of t)e._points.push(i);return e}static createIndexedPoints(t,e,i=!1){const s=new we;for(const i of e)s._points.push(t[i]);return i&&e.length>1&&s._points.push(t[e[0]]),s}static createFloat64Array(t){const e=new we;for(let i=0;i+3<=t.length;i+=3)e._points.push(Q.create(t[i],t[i+1],t[i+2]));return e}clone(){const t=new we;return t.setFrom(this),t}setFromJSON(t){if(this._points.clear(),Array.isArray(t)){let e;for(e of t)this._points.push(Q.fromJSON(e))}}toJSON(){const t=[];let e=0;for(;this._points.isIndexValid(e);)t.push(this._points.getPoint3dAtUncheckedPointIndex(e).toJSON()),e++;return t}static fromJSON(t){const e=new we;return e.setFromJSON(t),e}fractionToPoint(t,e){const i=this._points.length;if(0===i)return Q.createZero();if(1===i)return Q.createFrom(this._points.getPoint3dAtUncheckedPointIndex(0),e);const s=1/(i-1);if(t<=s)return this._points.interpolate(0,t/s,1,e);if(t+s>=1)return this._points.interpolate(i-1,(1-t)/s,i-2,e);const n=Math.floor(t/s);return this._points.interpolate(n,(t-n*s)/s,n+1,e)}fractionToPointAndDerivative(t,e){e=e||bt.createZero();const i=this._points.length;if(i<=1)return e.direction.setZero(),1===i?e.origin.setFrom(this._points.getPoint3dAtUncheckedPointIndex(0)):e.origin.setZero(),e;const s=1/(i-1);if(t<=s)return e=e||bt.createZero(),this._points.interpolate(0,t/s,1,e.origin),this._points.vectorIndexIndex(0,1,e.direction),e.direction.scaleInPlace(1/s),e;if(t+s>=1)return e=e||bt.createZero(),this._points.interpolate(i-2,1-(1-t)/s,i-1,e.origin),this._points.vectorIndexIndex(i-2,i-1,e.direction),e.direction.scaleInPlace(1/s),e;e=e||bt.createZero();const n=Math.floor(t/s),r=(t-n*s)/s;return this._points.interpolate(n,r,n+1,e.origin),this._points.vectorIndexIndex(n,n+1,e.direction),e.direction.scaleInPlace(1/s),e}fractionToPointAnd2Derivatives(t,e){const i=this.fractionToPointAndDerivative(t);return Et.createCapture(i.origin,i.direction,$.createZero(),e)}segmentIndexAndLocalFractionToGlobalFraction(t,e){const i=this._points.length-1;return i<1?0:(t+e)/i}globalFractionToSegmentIndexAndLocalFraction(t){const e=this._points.length-1;if(e<1)return{index:0,fraction:0};const i=t*e;let s;return s=t<0?0:t>1?e-1:Math.floor(i),{index:s,fraction:i-s}}fractionToFrenetFrame(t,e){const i=this._points.length;if(i<=1)return 1===i?pt.createTranslation(this._points.getPoint3dAtUncheckedPointIndex(0),e):pt.createIdentity(e);if(2===i)return pt.createRefs(this._points.interpolate(0,t,1),xt.createRigidHeadsUp(this._points.vectorIndexIndex(0,1),p.XYZ));const s=i-1,n=1/s;let r=0,o=0;t<=n?(o=t/n,r=0):t+n>=1?(r=i-2,o=1-(1-t)/n):(r=Math.floor(t/n),o=t*s-r);const a=this._points.interpolate(r,o,r+1),c=this._points.vectorIndexIndex(r,r+1),h=$.create(),l=$.create();0===r?Se(this._points,c,r+1,1,1,h,l):r+2>=i?Se(this._points,c,r-1,-1,1,h,l):(Se(this._points,c,r-1,-1,1-o,h,l),Se(this._points,c,r+1,1,o,h,l));const d=xt.createRigidFromColumns(h,c,p.ZXY);return d?pt.createOriginAndMatrix(a,d,e):pt.createTranslation(a,e)}startPoint(){return 0===this._points.length?Q.createZero():this._points.getPoint3dAtUncheckedPointIndex(0)}pointAt(t,e){if(this._points.isIndexValid(t))return this._points.getPoint3dAtUncheckedPointIndex(t,e)}vectorBetween(t,e,i){return this._points.vectorIndexIndex(t,e,i)}derivativeAt(t,e){if(this._derivatives&&this._derivatives.isIndexValid(t))return this._derivatives.getVector3dAtCheckedVectorIndex(t,e)}surfaceNormalAt(t,e){if(this._surfaceNormals&&this._surfaceNormals.isIndexValid(t))return this._surfaceNormals.getVector3dAtCheckedVectorIndex(t,e)}numPoints(){return this._points.length}endPoint(){return 0===this._points.length?Q.createZero():this._points.getPoint3dAtUncheckedPointIndex(this._points.length-1)}reverseInPlace(){this._points.length>=2&&(this._points.reverseInPlace(),this._uvParams&&this._uvParams.reverseInPlace())}tryTransformInPlace(t){return this._points.multiplyTransformInPlace(t),this._derivatives&&this._derivatives.multiplyMatrix3dInPlace(t.matrix),this._surfaceNormals&&this._surfaceNormals.multiplyAndRenormalizeMatrix3dInverseTransposeInPlace(t.matrix),!0}curveLength(){return this._points.sumLengths()}curveLengthBetweenFractions(t,e){const i=this._points.length-1;if(e===t||i<1)return 0;if(e<t)return this.curveLengthBetweenFractions(e,t);const s=t*i,n=e*i,r=Math.max(1,Math.ceil(s)),o=Math.min(Math.floor(n),i-1),a=r-s,c=n-o;if(r>o)return Math.abs(n-s)*this._points.distanceIndexIndex(r-1,r);{let t=a*this._points.distanceIndexIndex(r-1,r)+c*this._points.distanceIndexIndex(o,o+1);for(let e=r;e<o;e++)t+=this._points.distanceIndexIndex(e,e+1);return t}}rangeBetweenFractions(t,e,i){const s=ut.create();if(this.points.length<1)return s;if(e<t)return this.rangeBetweenFractions(e,t,i);const n=this._points.length-1,r=t*n,o=Math.max(0,Math.floor(r)),a=r-o,c=Q.create();if(this._points.interpolate(o,a,o+1,c),s.extendPoint(c,i),e===t)return s;const h=e*n,l=Math.min(Math.floor(h),n-1),d=h-l;this._points.interpolate(l,d,l+1,c),s.extendPoint(c,i);for(let t=o+1;t<=l;t++)this._points.getPoint3dAtUncheckedPointIndex(t,c),s.extendPoint(c,i);return s}moveSignedDistanceFromFraction(t,e,i,s){const n=this._points.length-1,r=t*n;let o=K.restrictToInterval(Math.floor(r),0,n-1);const a=r-o,c=this._points.interpolate(o,a,o+1,we._workPointA),h=we._workPointB,l=new Ce(c,t,e);if(e>0){for(;o<=n;)if(o++,this._points.getPoint3dAtCheckedPointIndex(o,h),l.announcePoint(h,o/n))return vt.createCurveFractionPointDistanceCurveSearchStatus(this,l.fraction0,l.point0,e,A.success,s);return i&&l.announceExtrapolation(this._points,n-1,n,(n-1)/n,1),vt.createCurveFractionPointDistanceCurveSearchStatus(this,l.fraction0,l.point0,e,l.distanceStatus(),s)}for(a<=0&&o--;o>=0;o--)if(this._points.getPoint3dAtCheckedPointIndex(o,h),l.announcePoint(h,o/n))return vt.createCurveFractionPointDistanceCurveSearchStatus(this,l.fraction0,l.point0,e,A.success,s);return i&&l.announceExtrapolation(this._points,1,0,1/n,0),vt.createCurveFractionPointDistanceCurveSearchStatus(this,l.fraction0,l.point0,-l.distance0,l.distanceStatus(),s)}quickLength(){return this.curveLength()}quickUnitNormal(t){let e=Math.floor(this._points.length/3);if(e<1&&(e=1),(t=this._points.crossProductIndexIndexIndex(0,e,e+e))&&t.normalizeInPlace())return t}closestPoint(t,e,i){i=vt.create(this,i);const s=jt.resolveVariantCurveExtendParameterToCurveExtendMode(e,0),n=jt.resolveVariantCurveExtendParameterToCurveExtendMode(e,1),r=this._points.length;if(r>0){const e=r-1;if(i.setFP(1,this._points.getPoint3dAtUncheckedPointIndex(e),void 0),i.setDistanceTo(t),r>1){let o=0,a=0;for(let c=1;c<r;c++)o=t.fractionOfProjectionToLine(this._points.getPoint3dAtUncheckedPointIndex(c-1),this._points.getPoint3dAtUncheckedPointIndex(c)),o<0?(!s||c>1)&&(o=0):o>1&&(!n||c<e)&&(o=1),this._points.getPoint3dAtUncheckedPointIndex(c-1).interpolate(o,this._points.getPoint3dAtUncheckedPointIndex(c),i.pointQ),a=i.pointQ.distance(t),a<i.a&&i.setFP(this.segmentIndexAndLocalFractionToGlobalFraction(c-1,o),i.pointQ,void 0,a)}}return i}isInPlane(t){return this._points.isCloseToPlane(t,K.smallMetricDistance)}static pushVertexHit(t,e,i,s,n){const r=vt.createCurveFractionPoint(i,s,n);t.push(r),0===e?r.setIntervalRole(I.isolatedAtVertex):1===e?(t[t.length-2].setIntervalRole(I.intervalStart),r.setIntervalRole(I.intervalEnd)):(t[t.length-2].setIntervalRole(I.intervalInterior),r.setIntervalRole(I.intervalEnd))}appendPlaneIntersectionPoints(t,e){if(this._points.length<1)return 0;const i=e.length,s=this._points.length,n=1===s?1:s-1,r=we._workPointA,o=we._workPointB,a=we._workPointC;this._points.getPoint3dAtUncheckedPointIndex(0,r);let c=0,h=0,l=0,d=0;for(let i=0;i<this._points.length;i++,r.setFrom(o),l=c)if(this._points.getPoint3dAtUncheckedPointIndex(i,o),c=K.correctSmallMetricDistance(t.altitude(o)),0===c)we.pushVertexHit(e,h++,this,i/n,o);else if(l*c<0){d=l/(l-c),r.interpolate(d,o,a);const t=vt.createCurveFractionPoint(this,(i-1+d)/n,a);t.setIntervalRole(I.isolated),e.push(t),h=0}return e.length-i}extendRange(t,e){this._points.extendRange(t,e)}isAlmostEqual(t){return t instanceof we&&!!nt.isAlmostEqual(this._points,t._points)}appendStrokePoint(t,e){const i=this._points.length;let s=!0;const n=void 0!==e&&void 0!==this._fractions;i>0&&(n&&K.isSameCoordinate(e,this._fractions.back())&&(s=!1),t.isAlmostEqual(this._points.getPoint3dAtUncheckedPointIndex(i-1))&&(s=!1)),s&&(this._points.push(t),n&&this.addFraction(e))}removeDuplicatePoints(t=K.smallMetricDistance){const e=this._points.length;if(e<2)return;let i=1;for(let s=1;s<e;s++){const e=this._points.distanceIndexIndex(s,i-1);void 0!==e&&e>t&&(this._points.moveIndexToIndex(s,i),void 0!==this._fractions&&this._fractions.setAtUncheckedIndex(i,this._fractions.atUncheckedIndex(s)),this._derivatives&&this._derivatives.moveIndexToIndex(s,i),i++)}this._points.resize(i),this._fractions&&this._fractions.resize(i),this._derivatives&&this._derivatives.resize(i)}appendFractionToPoint(t,e){if(this._derivatives){const i=t.fractionToPointAndDerivative(e,we._workRay);this._fractions&&this._fractions.push(e),this._points.push(i.origin),this._derivatives&&this._derivatives.push(i.direction)}else{const i=t.fractionToPoint(e,we._workPointA);this._fractions&&this._fractions.push(e),this._points.push(i)}}clear(){this._points.clear(),this._fractions&&this._fractions.clear(),this._derivatives&&this._derivatives.clear()}static createForStrokes(t=0,e){const i=we.create();return t>0&&i._points.ensureCapacity(t),e&&(e.needParams&&(i._fractions=new St(t),i._uvParams=new Ae(t)),e.needNormals&&(i._derivatives=new nt(t),i._surfaceNormals=new nt(t))),i}appendFractionalStrokePoints(t,e,i=0,s=1,n=!0){let r=1,o=e-1;if(n&&(r=0,o=e),e>=1){const n=(s-i)/e;for(let e=r;e<=o;e++)this.appendFractionToPoint(t,i+e*n)}}appendInterpolatedStrokePoints(t,e,i,s){if(s&&this.appendStrokePoint(e,0),t>1){const s=1/t;for(let n=1;n<t;n++){const t=n*s;this.appendStrokePoint(e.interpolate(t,i),t)}}s&&this.appendStrokePoint(i,1)}emitStrokes(t,e){const i=this._points.length,s=we._workPointA,n=we._workPointB;if(i>0)if(e&&e.hasMaxEdgeLength){t.appendStrokePoint(this._points.getPoint3dAtUncheckedPointIndex(0));for(let r=1;r<i;r++){this._points.getPoint3dAtUncheckedPointIndex(r-1,s),this._points.getPoint3dAtUncheckedPointIndex(r,n);const i=e.applyMaxEdgeLength(1,s.distance(n));i>1&&t.appendInterpolatedStrokePoints(i,s,n,!1),t.appendStrokePoint(n)}}else for(let e=0;e<i;e++)t.appendStrokePoint(this._points.getPoint3dAtUncheckedPointIndex(e))}emitStrokableParts(t,e){const i=this._points.length;if(t.startCurvePrimitive(this),i>1){const s=1/(i-1);if(e&&e.hasMaxEdgeLength)for(let n=1;n<i;n++){const i=e.applyMaxEdgeLength(1,this._points.getPoint3dAtUncheckedPointIndex(n-1).distance(this._points.getPoint3dAtUncheckedPointIndex(n)));t.announceSegmentInterval(this,this._points.getPoint3dAtUncheckedPointIndex(n-1),this._points.getPoint3dAtUncheckedPointIndex(n),i,(n-1)*s,n*s)}else for(let e=1;e<i;e++)t.announceSegmentInterval(this,this._points.getPoint3dAtUncheckedPointIndex(e-1),this._points.getPoint3dAtUncheckedPointIndex(e),1,(e-1)*s,e*s)}t.endCurvePrimitive(this)}computeStrokeCountForOptions(t){const e=this._points.length;let i=e-1;if(t&&t.hasMaxEdgeLength){i=0;for(let s=1;s<e;s++)i+=t.applyMaxEdgeLength(1,this._points.distanceIndexIndex(s-1,s))}return i}computeAndAttachRecursiveStrokeCounts(t,e){const i=this._points.length,s=void 0!==t&&t.hasMaxEdgeLength,n=Yt.createWithCurvePrimitiveAndOptionalParent(this,e,[]);for(let e=1;e<i;e++){const i=this._points.distanceIndexIndex(e-1,e),r=s?t.applyMaxEdgeLength(1,i):1;n.addToCountAndLength(r,i)}ie.installStrokeCountMap(this,n,e)}dispatchToGeometryHandler(t){return t.handleLineString3d(this)}announceClipIntervals(t,e){const i=this._points.length;if(i<2)return!1;let s=0,n=1;const r=(t,i)=>{e&&e(K.interpolate(s,t,n),K.interpolate(s,i,n),this)},o=we._workPointA,a=we._workPointB;this._points.getPoint3dAtUncheckedPointIndex(0,o);let c=!1;for(let e=1;e<i;e++,o.setFrom(a),s=n)this._points.getPoint3dAtUncheckedPointIndex(e,a),n=e/(i-1),t.announceClippedSegmentIntervals(0,1,o,a,r)&&(c=!0);return c}addResolvedPoint(t,e,i){const s=this._points.length;if(0!==s){if(1===s)return this._points.getPoint3dAtUncheckedPointIndex(0,we._indexPoint),void i.push(we._indexPoint);t<0&&(t=0),t>s-2&&(t=s-2,e+=1),this._points.interpolate(t,e,t+1,we._indexPoint),i.push(we._indexPoint)}}clonePartialCurve(t,e){if(e<t){const i=this.clonePartialCurve(e,t);return i&&i.reverseInPlace(),i}const i=this._points.length;if(i<2)return this.clone();let s,n;i>2&&this.isPhysicallyClosed&&(t<0&&(t=0),e>1&&(e=1));const r=this.globalFractionToSegmentIndexAndLocalFraction(t),o=this.globalFractionToSegmentIndexAndLocalFraction(e);s=t<0?1:0<=t&&t<=1?K.isSmallRelative(1-r.fraction)?r.index+2:r.index+1:i,n=e<0?-1:0<=e&&e<=1?K.isSmallRelative(o.fraction)?o.index-1:o.index:i-2;const a=we.create();this.addResolvedPoint(r.index,r.fraction,a._points);for(let t=s;t<=n;t++)this._points.isIndexValid(t)&&(this._points.getPoint3dAtUncheckedPointIndex(t,we._workPointA),a._points.push(we._workPointA));return this.addResolvedPoint(o.index,o.fraction,a._points),a}getIndexedSegment(t){if(t>=0&&t+1<this._points.length)return Pe.create(this._points.getPoint3dAtCheckedPointIndex(t),this._points.getPoint3dAtCheckedPointIndex(t+1))}get isPhysicallyClosed(){return this._points.length>0&&K.isSmallMetricDistance(this._points.distanceIndexIndex(0,this._points.length-1))}addMappedStrokesToLineString3D(t,e){const i=e.numPoints(),s=void 0!==e._fractions,n=void 0!==e._derivatives,r=this._points,o=we._workPointA,a=we._workPointB,c=we._workPointC,h=r.length;if(t.primitive&&t.primitive===this&&t.componentData&&t.componentData.length+1===h){r.getPoint3dAtUncheckedPointIndex(0,o);for(let i=0;i+1<h;i++,o.setFromPoint3d(a)){r.getPoint3dAtUncheckedPointIndex(i+1,a);const h=t.componentData[i],l=h.numStroke,d=o.vectorTo(a);d.scale(l);for(let t=0;t<=l;t++){const i=t/l,r=h.fractionToA(i);e.addPoint(o.interpolate(i,a,c)),s&&e._fractions.push(r),n&&e._derivatives.push(d)}}}return e.numPoints()-i}static createArrayOfLineString3d(t){const e=new at;lt.streamXYZ(t,e);const i=e.claimArrayOfGrowableXYZArray(),s=[];if(void 0!==i)for(const t of i)s.push(we.createCapture(t));return s}collectCurvePrimitivesGo(t,e,i=!1){if(i){let e;for(let i=0;void 0!==(e=this.getIndexedSegment(i));i++)t.push(e)}else t.push(this)}constructOffsetXY(t){const e=ve.create(t),i=[];for(const t of this.collectCurvePrimitives(void 0,!0,!0)){const s=t.constructOffsetXY(e);void 0!==s&&(s instanceof ie?i.push(s):Array.isArray(s)&&s.forEach((t=>i.push(t))))}return i}projectedParameterRange(t,e){return Te.findExtremeFractionsAlongDirection(this,t,e)}}we._workPointA=Q.create(),we._workPointB=Q.create(),we._workPointC=Q.create(),we._workRay=bt.createXAxis(),we._indexPoint=Q.create();class Ce{constructor(t,e,i){this.point0=t,this.distance0=0,this.targetDistance=Math.abs(i),this.fraction0=e}distanceStatus(){return K.isSameCoordinate(this.distance0,this.targetDistance)?A.success:A.stoppedAtBoundary}announcePoint(t,e){const i=this.point0.distance(t),s=this.distance0+i;if(s<this.targetDistance&&!K.isSameCoordinate(s,this.targetDistance))return this.point0.setFromPoint3d(t),this.distance0=s,this.fraction0=e,!1;const n=this.targetDistance-this.distance0,r=K.safeDivideFraction(n,i,0);return this.point0.interpolate(r,t,this.point0),this.fraction0=K.interpolate(this.fraction0,r,e),this.distance0=this.targetDistance,!0}announceExtrapolation(t,e,i,s,n){const r=this.targetDistance-this.distance0,o=t.distanceIndexIndex(e,i);if(!o)return!1;const a=K.conditionalDivideFraction(r,o);return void 0!==a&&(t.interpolate(i,-a,e,this.point0),this.distance0=this.targetDistance,this.fraction0=K.interpolate(n,-a,s),!0)}}class Te extends xe{constructor(t){super(),this.plane=t,this.range=ft.createNull(),this.resetRange()}resetRange(){this.range.setNull()}announcePoint(t){const e=this.plane.altitude(t);this.range.extendLow(e)&&(this.lowPoint=t.clone(this.lowPoint)),this.range.extendHigh(e)&&(this.highPoint=t.clone(this.highPoint))}announcePoints(t){for(let e=0;e<t.length;e++){const i=t.evaluateUncheckedIndexPlaneAltitude(e,this.plane);this.range.extendLow(i)&&(this.lowPoint=t.getPoint3dAtUncheckedPointIndex(e,this.lowPoint)),this.range.extendHigh(i)&&(this.highPoint=t.getPoint3dAtUncheckedPointIndex(e,this.highPoint))}}static createCapture(t){return new Te(t)}handleLineSegment3d(t){this.announcePoint(t.point0Ref),this.announcePoint(t.point1Ref)}handleLineString3d(t){this.announcePoints(t.packedPoints)}initStrokeOptions(){void 0===this._strokeOptions&&(this._strokeOptions=new ye,this._strokeOptions.angleTol=W.createDegrees(1))}handleBSplineCurve3d(t){this.initStrokeOptions();const e=we.create();t.emitStrokes(e,this._strokeOptions),this.handleLineString3d(e)}handleBSplineCurve3dH(t){this.initStrokeOptions();const e=we.create();t.emitStrokes(e,this._strokeOptions),this.handleLineString3d(e)}handleArc3d(t){this._sineCosinePolynomial=t.getPlaneAltitudeSineCosinePolynomial(this.plane,this._sineCosinePolynomial);let e=this._sineCosinePolynomial.referenceMinMaxRadians();t.sweep.isRadiansInSweep(e)&&this.announcePoint(this._workPoint=t.radiansToPoint(e,this._workPoint)),e+=Math.PI,t.sweep.isRadiansInSweep(e)&&this.announcePoint(this._workPoint=t.radiansToPoint(e,this._workPoint)),this.announcePoint(this._workPoint=t.startPoint(this._workPoint)),this.announcePoint(this._workPoint=t.endPoint(this._workPoint))}static findExtremesInDirection(t,e){const i=e instanceof bt?e.origin:Q.createZero(),s=e instanceof bt?e.direction:e,n=yt.create(i,s);if(n){const e=new Te(n);if(t instanceof Nt)t.dispatchToGeometryHandler(e);else if(t instanceof nt)e.announcePoints(t);else for(const i of t)e.announcePoint(i);return e}}static findExtremePointsInDirection(t,e,i){const s=this.findExtremesInDirection(t,e);if(s&&s.highPoint&&s.lowPoint)return Pe.create(s.lowPoint,s.highPoint,i)}static findExtremeAltitudesInDirection(t,e,i){const s=this.findExtremesInDirection(t,e);if(s&&!s.range.isNull)return ft.createFrom(s.range,i)}static findExtremeFractionsAlongDirection(t,e,i){const s=this.findExtremeAltitudesInDirection(t,e,i);if(void 0!==s){const t=e instanceof $?e.magnitude():e.direction.magnitude(),i=K.conditionalDivideCoordinate(1,t);if(void 0!==i)return s.low*=i,s.high*=i,s}}}class ke{constructor(t,e){this.x0=t,this.x1=e}set(t,e){this.x0=t,this.x1=e}shift(t){this.x0+=t,this.x1+=t}static create(t=0,e=1,i){return i?(i.set(t,e),i):new ke(t,e)}setFrom(t){this.x0=t.x0,this.x1=t.x1}clone(){return new ke(this.x0,this.x1)}get isIn01(){return K.isIn01(this.x0)&&K.isIn01(this.x1)}fractionToPoint(t){return K.interpolate(this.x0,t,this.x1)}signedDelta(){return this.x1-this.x0}absoluteDelta(){return Math.abs(this.x1-this.x0)}reverseInPlace(){const t=this.x0;this.x0=this.x1,this.x1=t}reverseIfNeededForDeltaSign(t=1){t*(this.x1-this.x0)<0&&this.reverseInPlace()}isAlmostEqual(t){return K.isSameCoordinate(this.x0,t.x0)&&K.isSameCoordinate(this.x1,t.x1)}get isExact01(){return 0===this.x0&&1===this.x1}get isExact01Reversed(){return 1===this.x0&&0===this.x1}clipBy01FunctionValuesPositive(t,e){const i=e-t,s=t+this.x0*i,n=t+this.x1*i,r=n-s;if(s>0){if(n>=0)return!0;const t=-s/r;return this.x1=this.x0+t*(this.x1-this.x0),!0}if(s<0){if(n<0)return!1;const t=-s/r;return this.x0=this.x0+t*(this.x1-this.x0),!0}return n>0}clampDirectedTo01(){let t=this.x0,e=this.x1;if(e>t){if(t<0&&(t=0),e>1&&(e=1),t>=e)return!1}else if(t>1&&(t=1),e<0&&(e=0),t<=e)return!1;return this.set(t,e),!0}}class Fe{constructor(t,e){this._blockSize=t,this._order=Math.floor(e.length/t),this._packedData=e,this._basis=new Lt(this._order)}clonePolygon(t){const e=this._packedData.length;if(!t||t.length!==e)return this._packedData.slice();for(let i=0;i<e;i++)t[i]=this._packedData[i];return t}get order(){return this._order}get packedData(){return this._packedData}static create(t){if(!(t.length<1)){if(t[0]instanceof Q){const e=new Float64Array(3*t.length);let i=0;for(const s of t)e[i++]=s.x,e[i++]=s.y,e[i++]=s.z;return new Fe(3,e)}if(t[0]instanceof Rt){const e=new Float64Array(4*t.length);let i=0;for(const s of t)e[i++]=s.x,e[i++]=s.y,e[i++]=s.z,e[i++]=s.w;return new Fe(4,e)}if(t[0]instanceof H){const e=new Float64Array(2*t.length);let i=0;for(const s of t)e[i++]=s.x,e[i++]=s.y;return new Fe(2,e)}}}evaluate(t,e){return this._basis.sumBasisFunctions(t,this._packedData,this._blockSize,e)}evaluateDerivative(t,e){return this._basis.sumBasisFunctionDerivatives(t,this._packedData,this._blockSize,e)}getPolygonPoint(t,e){if(e||(e=new Float64Array(this._blockSize)),t>=0&&t<this._order){const i=this._blockSize*t;for(let t=0;t<this._blockSize;t++)e[t]=this._packedData[i+t];return e}}setPolygonPoint(t,e){if(t>=0&&t<this._order){const i=this._blockSize*t;for(let t=0;t<this._blockSize;t++)this._packedData[i+t]=e[t]}}loadSpanPoles(t,e){let i=e*this._blockSize;for(let e=0;e<this._packedData.length;e++)this._packedData[e]=t[i++]}loadSpanPolesWithWeight(t,e,i,s){let n=0;const r=this._order;let o=i*e;for(let i=0;i<r;i++){for(let i=0;i<e;i++)this._packedData[n++]=t[o++];this._packedData[n++]=s}}unpackToJsonArrays(){return ae.unpackNumbersToNestedArrays(this._packedData,this._blockSize)}isAlmostEqual(t){if(t instanceof Fe){if(this._blockSize!==t._blockSize)return!1;if(this._order!==t._order)return!1;if(this._packedData.length!==t._packedData.length)return!1;for(let e=0;e<this._packedData.length;e++)if(!K.isSameCoordinate(this._packedData[e],t._packedData[e]))return!1;return!0}return!1}reverseInPlace(){const t=this._blockSize;let e,i,s;for(e=0,i=(this._order-1)*t;e<i;e+=t,i-=t)for(let n=0;n<t;n++)s=this._packedData[e+n],this._packedData[e+n]=this._packedData[i+n],this._packedData[i+n]=s}interpolatePoleInPlace(t,e,i){let s=t*this._blockSize,n=i*this._blockSize;const r=this._packedData;for(let t=0;t<this._blockSize;t++,s++,n++)r[s]+=e*(r[n]-r[s])}saturateInPlace(t,e){const i=t.degree,s=e+i-1,n=s+1;if(e<0||e>=t.numSpans)return!1;const r=t.knots,o=r[s],a=r[n];if(this.setInterval(o,a),a<=o+le.knotTolerance)return!1;for(let t=i-1;t>0;t--){let e=s-t;if(r[e]<o){let i=n;for(let s=0;s<t;s++,e++,i++){const t=r[e],n=(o-t)/(r[i]-t);this.interpolatePoleInPlace(s,n,s+1)}}}for(let t=i-1;t>0;t--){let e=n+t;if(r[e]>a)for(let s=0;s<t;s++,e--){const t=r[e],n=(a-t)/(o-t);this.interpolatePoleInPlace(i-s,n,i-s-1)}}return!0}static saturate1dInPlace(t,e,i){const s=e.degree,n=i+s-1,r=n+1;if(i<0||i>=e.numSpans)return!1;const o=e.knots,a=o[n],c=o[r];if(c<=a+le.knotTolerance)return!1;for(let e=s-1;e>0;e--){let i=n-e;if(o[i]<a){let s=r;for(let n=0;n<e;n++,i++,s++){const e=o[i],r=(a-e)/(o[s]-e);t[n]=t[n]+r*(t[n+1]-t[n])}}}for(let e=s-1;e>0;e--){let i,n=r+e;if(o[n]>c)for(let r=0;r<e;r++,n--){const e=o[n],h=(c-e)/(a-e);i=s-r,t[i]+=h*(t[i-1]-t[i])}}return!0}subdivideInPlaceKeepLeft(t){if(K.isAlmostEqualNumber(t,1))return!0;if(K.isAlmostEqualNumber(t,0))return!1;const e=1-t,i=this.order;for(let t=1;t<i;t++)for(let s=i-1;s>=t;s--)this.interpolatePoleInPlace(s,e,s-1);return!0}subdivideInPlaceKeepRight(t){if(K.isAlmostEqualNumber(t,0))return!0;if(K.isAlmostEqualNumber(t,1))return!1;const e=this.order;for(let i=1;i<e;i++)for(let s=0;s+i<e;s++)this.interpolatePoleInPlace(s,t,s+1);return!0}subdivideToIntervalInPlace(t,e){return!K.isAlmostEqualNumber(t,e)&&(e<t?(this.subdivideToIntervalInPlace(e,t),this.reverseInPlace(),!0):(this.subdivideInPlaceKeepLeft(e),this.subdivideInPlaceKeepRight(t/e),!0))}setInterval(t,e){this.interval=ke.create(t,e,this.interval)}fractionToParentFraction(t){return this.interval?this.interval.fractionToPoint(t):t}}class Me extends ie{constructor(t,e){super(),this.curvePrimitiveType="bezierCurve",this._polygon=new Fe(t,e),this._workPoint0=Q.create(),this._workPoint1=Q.create(),this._workData0=new Float64Array(t),this._workData1=new Float64Array(t)}reverseInPlace(){this._polygon.reverseInPlace()}saturateInPlace(t,e){const i=this._polygon.saturateInPlace(t,e);return i&&this.setInterval(t.spanFractionToFraction(e,0),t.spanFractionToFraction(e,1)),i}get degree(){return this._polygon.order-1}get order(){return this._polygon.order}get numPoles(){return this._polygon.order}setInterval(t,e){this._polygon.setInterval(t,e)}fractionToParentFraction(t){return this._polygon.fractionToParentFraction(t)}emitStrokes(t,e){const i=this.computeStrokeCountForOptions(e),s=1/i;for(let e=0;e<=i;e++){const i=e*s;this.fractionToPoint(i,this._workPoint0),t.appendStrokePoint(this._workPoint0)}}emitStrokableParts(t,e){const i=this.computeStrokeCountForOptions(e);t.announceIntervalForUniformStepStrokes(this,i,0,1)}copyPolesAsJsonArray(){return this._polygon.unpackToJsonArrays()}isInPlane(t){let e=this._workPoint0;for(let i=0;;i++){if(e=this.getPolePoint3d(i,e),!e)return!0;if(!t.isPointInPlane(e))break}return!1}polygonLength(){if(!this.getPolePoint3d(0,this._workPoint0))return 0;let t=0,e=0;for(;this.getPolePoint3d(++t,this._workPoint1);)e+=this._workPoint0.distance(this._workPoint1),this._workPoint0.setFrom(this._workPoint1);return e}startPoint(){return this.getPolePoint3d(0)}endPoint(){return this.getPolePoint3d(this.order-1)}quickLength(){return this.polygonLength()}allocateAndZeroBezierWorkData(t,e,i){t>0&&(void 0!==this._workBezier&&this._workBezier.order===t?this._workBezier.zero():this._workBezier=new Lt(t)),e>0&&(void 0!==this._workCoffsA&&this._workCoffsA.length===e?this._workCoffsA.fill(0):this._workCoffsA=new Float64Array(e)),i>0&&(void 0!==this._workCoffsB&&this._workCoffsB.length===i?this._workCoffsB.fill(0):this._workCoffsB=new Float64Array(i))}computeStrokeCountForOptions(t){this.getPolePoint3d(0,this._workPoint0),this.getPolePoint3d(1,this._workPoint1);let e=1;if(this._workPoint0&&this._workPoint1){let i,s,n,r=this._workPoint1.x-this._workPoint0.x,o=this._workPoint1.y-this._workPoint0.y,a=this._workPoint1.z-this._workPoint0.z,c=0,h=K.hypotenuseXYZ(r,o,a);this._workPoint1.setFromPoint3d(this._workPoint0);let l,d=h,u=h,f=0;for(let t=2;this.getPolePoint3d(t,this._workPoint1);t++)i=this._workPoint1.x-this._workPoint0.x,s=this._workPoint1.y-this._workPoint0.y,n=this._workPoint1.z-this._workPoint0.z,l=W.radiansBetweenVectorsXYZ(r,o,a,i,s,n),c+=l,f=K.maxAbsXY(l,f),h=K.hypotenuseXYZ(i,s,n),d+=h,u=K.maxXY(u,h),r=i,o=s,a=n,this._workPoint0.setFrom(this._workPoint1);const g=u*this.degree,p=Math.sqrt(g*d);let m=f*(this.degree-1);this.degree<3&&(m*=3);const x=Math.sqrt(m*c),y=this.degree;e=ye.applyAngleTol(t,ye.applyMaxEdgeLength(t,y,p),x,.1),t&&(e=t.applyChordTolToLengthAndRadians(e,d,m))}return e}cloneTransformed(t){const e=this.clone();return e.tryTransformInPlace(t),e}constructOffsetXY(t){const e=ve.create(t),i=new ge(this,e.leftOffsetDistance);return this.emitStrokableParts(i,e.strokeOptions),i.claimResult()}clonePartialCurve(t,e){const i=this.clone();return i._polygon.subdivideToIntervalInPlace(t,e),i}projectedParameterRange(t,e){return Te.findExtremeFractionsAlongDirection(this,t,e)}}class be extends Me{isSameGeometryClass(t){return t instanceof be}tryTransformInPlace(t){const e=this._workData0;for(let i=0;i<this._polygon.order;i++)this._polygon.getPolygonPoint(i,e),t.multiplyXYZToFloat64Array(e[0],e[1],e[2],e),this._polygon.setPolygonPoint(i,e);return!0}getPolePoint3d(t,e){const i=this._polygon.getPolygonPoint(t,this._workData0);if(i)return Q.create(i[0],i[1],i[2],e)}getPolePoint4d(t,e){const i=this._polygon.getPolygonPoint(t,this._workData0);if(i)return Rt.create(i[0],i[1],i[2],1,e)}constructor(t){super(3,t),this._workRay0=bt.createXAxis(),this._workRay1=bt.createXAxis()}copyPointsAsLineString(){const t=we.create();for(let e=0;e<this._polygon.order;e++)t.addPoint(this.getPolePoint3d(e));return t}static create(t){if(t.length<1)return;const e=new Float64Array(3*t.length);if(t[0]instanceof Q){let i=0;for(const s of t)e[i++]=s.x,e[i++]=s.y,e[i++]=s.z;return new be(e)}if(t[0]instanceof H){let i=0;for(const s of t)e[i++]=s.x,e[i++]=s.y,e[i++]=0;return new be(e)}}static createOrder(t){const e=new Float64Array(3*t);return new be(e)}loadSpanPoles(t,e){this._polygon.loadSpanPoles(t,e)}clone(){return new be(this._polygon.clonePolygon())}fractionToPoint(t,e){return this._polygon.evaluate(t,this._workData0),Q.create(this._workData0[0],this._workData0[1],this._workData0[2],e)}fractionToPointAndDerivative(t,e){return this._polygon.evaluate(t,this._workData0),this._polygon.evaluateDerivative(t,this._workData1),bt.createXYZUVW(this._workData0[0],this._workData0[1],this._workData0[2],this._workData1[0],this._workData1[1],this._workData1[2],e)}fractionToPointAnd2Derivatives(t,e){const i=1/2e-8;e||(e=Et.createXYPlane());const s=this.fractionToPointAndDerivative(t,this._workRay0);e.origin.setFrom(s.origin),e.vectorU.setFrom(s.direction);const n=this.fractionToPointAndDerivative(t-1e-8,this._workRay0),r=this.fractionToPointAndDerivative(t+1e-8,this._workRay1);return $.createAdd2Scaled(n.direction,-i,r.direction,i,e.vectorV),e}isAlmostEqual(t){return t instanceof be&&this._polygon.isAlmostEqual(t._polygon)}dispatchToGeometryHandler(t){return t.handleBezierCurve3d(this)}extendRange(t,e){const i=this.order;if(e){this.allocateAndZeroBezierWorkData(i-1,i,0);const s=this._workBezier,n=this._workCoffsA;this.getPolePoint3d(0,this._workPoint0),t.extendTransformedPoint(e,this._workPoint0),this.getPolePoint3d(i-1,this._workPoint0),t.extendTransformedPoint(e,this._workPoint0);const r=this._polygon.packedData;for(let o=0;o<3;o++){for(let t=0,s=0;t<i;t++,s+=3)n[t]=e.multiplyComponentXYZ(o,r[s],r[s+1],r[s+2]);Vt.univariateDifference(n,s.coffs);const a=s.roots(0,!0);if(a&&a.length>0)for(const i of a)this.fractionToPoint(i,this._workPoint0),t.extendTransformedPoint(e,this._workPoint0)}}else{this.allocateAndZeroBezierWorkData(i-1,0,0);const e=this._workBezier;this.getPolePoint3d(0,this._workPoint0),t.extend(this._workPoint0),this.getPolePoint3d(i-1,this._workPoint0),t.extend(this._workPoint0);for(let s=0;s<3;s++){Vt.componentDifference(e.coffs,this._polygon.packedData,3,i,s);const n=e.roots(0,!0);if(n)for(const e of n)this.fractionToPoint(e,this._workPoint0),t.extend(this._workPoint0)}}}}class Ee extends Me{isSameGeometryClass(t){return t instanceof Ee}tryTransformInPlace(t){const e=this._workData0;for(let i=0;i<this._polygon.order;i++)this._polygon.getPolygonPoint(i,e),t.multiplyXYZWToFloat64Array(e[0],e[1],e[2],e[3],e),this._polygon.setPolygonPoint(i,e);return!0}tryMultiplyMatrix4dInPlace(t){t.multiplyBlockedFloat64ArrayInPlace(this._polygon.packedData)}getPolePoint4d(t,e){const i=this._polygon.getPolygonPoint(t,this._workData0);if(i)return Rt.create(i[0],i[1],i[2],i[3],e)}getPolePoint3d(t,e){const i=this._polygon.getPolygonPoint(t,this._workData0);if(i)return Q.createFromPackedXYZW(i,0,e)}isUnitWeight(t){void 0===t&&(t=K.smallAngleRadians);const e=1-t,i=1+t,s=this._polygon.packedData,n=s.length;let r;for(let t=3;t<n;t+=4)if(r=s[t],r<e||r>i)return!1;return!0}constructor(t){super(4,t),this._workRay0=bt.createXAxis(),this._workRay1=bt.createXAxis()}static create(t){if(t.length<1)return;const e=new Float64Array(4*t.length);if(t[0]instanceof Q){let i=0;for(const s of t)e[i++]=s.x,e[i++]=s.y,e[i++]=s.z,e[i++]=1;return new Ee(e)}if(t[0]instanceof Rt){let i=0;for(const s of t)e[i++]=s.x,e[i++]=s.y,e[i++]=s.z,e[i++]=s.w;return new Ee(e)}if(t[0]instanceof H){let i=0;for(const s of t)e[i++]=s.x,e[i++]=s.y,e[i++]=0,e[i++]=1;return new Ee(e)}}static createOrder(t){const e=new Float64Array(4*t);return new Ee(e)}loadSpan3dPolesWithWeight(t,e,i){this._polygon.loadSpanPolesWithWeight(t,3,e,i)}loadSpan4dPoles(t,e){this._polygon.loadSpanPoles(t,e)}clone(){return new Ee(this._polygon.clonePolygon())}fractionToPoint(t,e){return this._polygon.evaluate(t,this._workData0),(e=Q.createFromPackedXYZW(this._workData0,0,e))||Q.createZero()}fractionToPoint4d(t,e){return this._polygon.evaluate(t,this._workData0),Rt.createFromPackedXYZW(this._workData0,0,e)}fractionToPointAndDerivative(t,e){return this._polygon.evaluate(t,this._workData0),this._polygon.evaluateDerivative(t,this._workData1),(e=bt.createWeightedDerivative(this._workData0,this._workData1,e))||bt.createXAxis()}fractionToPointAnd2Derivatives(t,e){const i=1/2e-8;e||(e=Et.createXYPlane());const s=this.fractionToPointAndDerivative(t,this._workRay0);e.origin.setFrom(s.origin),e.vectorU.setFrom(s.direction);const n=this.fractionToPointAndDerivative(t-1e-8,this._workRay0),r=this.fractionToPointAndDerivative(t+1e-8,this._workRay1);return $.createAdd2Scaled(n.direction,-i,r.direction,i,e.vectorV),e}isAlmostEqual(t){return t instanceof Ee&&this._polygon.isAlmostEqual(t._polygon)}dispatchToGeometryHandler(t){return t.handleBezierCurve3dH(this)}poleProductsXYZW(t,e,i,s,n){const r=this.numPoles,o=this._polygon.packedData;for(let a=0,c=0;a<r;a++,c+=4)t[a]=e*o[c]+i*o[c+1]+s*o[c+2]+n*o[c+3]}updateClosestPointByTruePerpendicular(t,e,i=!1,s=!1){let n,r=0;if(this.isUnitWeight()){const e=2*this.order-2;this.allocateAndZeroBezierWorkData(e,0,0);const i=this._workBezier;Vt.accumulateScaledShiftedComponentTimesComponentDelta(i.coffs,this._polygon.packedData,4,this.order,1,0,-t.x,0),Vt.accumulateScaledShiftedComponentTimesComponentDelta(i.coffs,this._polygon.packedData,4,this.order,1,1,-t.y,1),Vt.accumulateScaledShiftedComponentTimesComponentDelta(i.coffs,this._polygon.packedData,4,this.order,1,2,-t.z,2),n=i.roots(0,!0)}else{const e=this.order,i=2*this.order-2,s=e+i-1;this.allocateAndZeroBezierWorkData(s,e,i);const r=this._workBezier,o=this._workCoffsA,a=this._workCoffsB,c=this._polygon.packedData;for(let i=0;i<3;i++){for(let t=0;t<o.length;t++)o[t]=0;for(let t=0;t<a.length;t++)a[t]=0;Vt.scaledComponentSum(o,c,4,e,3,t.at(i),i,-1),Vt.accumulateScaledShiftedComponentTimesComponentDelta(a,c,4,e,1,3,0,i),Vt.accumulateScaledShiftedComponentTimesComponentDelta(a,c,4,e,-1,i,0,3),Vt.accumulateProduct(r.coffs,o,a)}n=r.roots(0,!0)}if(n)for(const i of n){const s=this.fractionToPoint(i),n=s.distance(t);r+=e.updateIfCloserCurveFractionPointDistance(this,i,s,n)?1:0}return i&&(r+=this.updateDetailAtFraction(e,0,t)?1:0),s&&(r+=this.updateDetailAtFraction(e,1,t)?1:0),r>0}updateDetailAtFraction(t,e,i){const s=this.fractionToPoint(e),n=s.distance(i);return t.updateIfCloserCurveFractionPointDistance(this,e,s,n)}extendRange(t,e){const i=this.order;if(e){this.allocateAndZeroBezierWorkData(2*i-2,i,i);const s=this._workCoffsA,n=this._workCoffsB,r=this._workBezier;this.getPolePoint3d(0,this._workPoint0),t.extendTransformedPoint(e,this._workPoint0),this.getPolePoint3d(i-1,this._workPoint0),t.extendTransformedPoint(e,this._workPoint0);const o=this._polygon.packedData;let a;for(let c=0;c<3;c++){r.zero();for(let t=0,r=0;t<i;t++,r+=4)a=o[r+3],s[t]=e.multiplyComponentXYZW(c,o[r],o[r+1],o[r+2],a),n[t]=a;Vt.accumulateProductWithDifferences(r.coffs,s,n,1),Vt.accumulateProductWithDifferences(r.coffs,n,s,-1);const h=r.roots(0,!0);if(h&&h.length>0)for(const i of h)this.fractionToPoint(i,this._workPoint0),t.extendTransformedPoint(e,this._workPoint0)}}else{this.allocateAndZeroBezierWorkData(2*i-2,0,0);const e=this._workBezier,s=this._polygon.packedData;this.getPolePoint3d(0,this._workPoint0),t.extend(this._workPoint0),this.getPolePoint3d(i-1,this._workPoint0),t.extend(this._workPoint0);for(let n=0;n<3;n++){e.zero(),Vt.accumulateScaledShiftedComponentTimesComponentDelta(e.coffs,s,4,i,1,n,0,3),Vt.accumulateScaledShiftedComponentTimesComponentDelta(e.coffs,s,4,i,-1,3,0,n);const r=e.roots(0,!0);if(r)for(const e of r)this.fractionToPoint(e,this._workPoint0),t.extend(this._workPoint0)}}}}class Xe{get degree(){return this.knots.degree}get order(){return this.knots.degree+1}get numSpan(){return this.numPoles-this.knots.degree}get numPoles(){return this.packedData.length/this.poleLength}getPoint3dPole(t,e){return Q.createFromPacked(this.packedData,t,e)}constructor(t,e,i,s){this.knots=s,this.packedData=new Float64Array(t*e),this.poleLength=e,this.basisBuffer=new Float64Array(i),this.poleBuffer=new Float64Array(e),this.basisBuffer1=new Float64Array(i),this.basisBuffer2=new Float64Array(i),this.poleBuffer1=new Float64Array(e),this.poleBuffer2=new Float64Array(e)}static create(t,e,i,s){return new Xe(t,e,i,s)}spanFractionToKnot(t,e){return this.knots.spanFractionToKnot(t,e)}evaluateBasisFunctionsInSpan(t,e,i,s,n){t<0&&(t=0),t>=this.numSpan&&(t=this.numSpan-1);const r=t+this.degree-1,o=this.knots.baseKnotFractionToKnot(r,e);return s?this.knots.evaluateBasisFunctions1(r,o,i,s,n):this.knots.evaluateBasisFunctions(r,o,i)}evaluateBuffersInSpan(t,e){this.evaluateBasisFunctionsInSpan(t,e,this.basisBuffer),this.sumPoleBufferForSpan(t)}evaluateBuffersInSpan1(t,e){this.evaluateBasisFunctionsInSpan(t,e,this.basisBuffer,this.basisBuffer1),this.sumPoleBufferForSpan(t),this.sumPoleBuffer1ForSpan(t)}sumPoleBufferForSpan(t){this.poleBuffer.fill(0);let e=t*this.poleLength;for(const t of this.basisBuffer)for(let i=0;i<this.poleLength;i++)this.poleBuffer[i]+=t*this.packedData[e++]}sumPoleBuffer1ForSpan(t){this.poleBuffer1.fill(0);let e=t*this.poleLength;for(const t of this.basisBuffer1)for(let i=0;i<this.poleLength;i++)this.poleBuffer1[i]+=t*this.packedData[e++]}sumPoleBuffer2ForSpan(t){this.poleBuffer2.fill(0);let e=t*this.poleLength;for(const t of this.basisBuffer2)for(let i=0;i<this.poleLength;i++)this.poleBuffer2[i]+=t*this.packedData[e++]}evaluateBuffersAtKnot(t,e=0){const i=this.knots.knotToLeftKnotIndex(t);e<1?(this.knots.evaluateBasisFunctions(i,t,this.basisBuffer),this.sumPoleBufferForSpan(i-this.degree+1)):1===e?(this.knots.evaluateBasisFunctions1(i,t,this.basisBuffer,this.basisBuffer1),this.sumPoleBufferForSpan(i-this.degree+1),this.sumPoleBuffer1ForSpan(i-this.degree+1)):(this.knots.evaluateBasisFunctions1(i,t,this.basisBuffer,this.basisBuffer1,this.basisBuffer2),this.sumPoleBufferForSpan(i-this.degree+1),this.sumPoleBuffer1ForSpan(i-this.degree+1),this.sumPoleBuffer2ForSpan(i-this.degree+1))}reverseInPlace(){const t=this.poleLength,e=this.packedData;for(let i=0,s=t*(this.numPoles-1);i<s;i+=t,s-=t){let n=0;for(let r=0;r<t;r++)n=e[i+r],e[i+r]=e[s+r],e[s+r]=n}this.knots.reflectKnots()}testCloseablePolygon(t){void 0===t&&(t=this.knots.wrappable);const e=this.degree,i=this.poleLength,s=(this.numPoles-this.degree)*i,n=this.packedData;if(t===C.OpenByAddingControlPoints){const t=e*i;for(let e=0;e<t;e++)if(!K.isSameCoordinate(n[e],n[e+s]))return!1;return!0}return t===C.OpenByRemovingKnots}addKnot(t,e){if(t<this.knots.leftKnot||t>this.knots.rightKnot)return!1;let i=this.knots.knotToLeftKnotIndex(t);if(Math.abs(t-this.knots.knots[i])<le.knotTolerance)t=this.knots.knots[i];else if(Math.abs(t-this.knots.knots[i+1])<le.knotTolerance){if(i+=this.knots.getKnotMultiplicityAtIndex(i+1),i>this.knots.rightKnotIndex)return!0;t=this.knots.knots[i]}const s=Math.min(e,this.degree)-this.knots.getKnotMultiplicity(t);if(s<=0)return!0;let n=this.knots.knots.length;const r=new Float64Array(n+s);for(let t=0;t<n;++t)r[t]=this.knots.knots[t];let o=this.numPoles;const a=new Float64Array(this.packedData.length+s*this.poleLength);for(let t=0;t<this.packedData.length;++t)a[t]=this.packedData[t];const c=new Float64Array(this.degree*this.poleLength);for(let e=0;e<s;++e){let e=0;const s=i-this.degree+2;for(let i=s;i<s+this.degree;++i){const s=(t-r[i-1])/(r[i+this.degree-1]-r[i-1]);for(let t=i*this.poleLength;t<(i+1)*this.poleLength;++t)c[e++]=K.interpolate(a[t-this.poleLength],s,a[t])}a.copyWithin((s+this.degree)*this.poleLength,(s+this.degree-1)*this.poleLength,o*this.poleLength);let h=s*this.poleLength;for(const t of c)a[h++]=t;r.copyWithin(i+2,i+1,n),r[i+1]=t,++i,++n,++o}return this.knots.setKnotsCapture(r),this.packedData=a,!0}}class Re extends ie{set definitionData(t){this._definitionData=t}get definitionData(){return this._definitionData}constructor(t,e,i,s){super(),this.curvePrimitiveType="bsplineCurve",this._bcurve=Xe.create(e,t,i,s)}get degree(){return this._bcurve.degree}get order(){return this._bcurve.order}get numSpan(){return this._bcurve.numSpan}get numPoles(){return this._bcurve.numPoles}copyKnots(t){return this._bcurve.knots.copyKnots(t)}setWrappable(t){this._bcurve.knots.wrappable=t}fractionToPoint(t,e){return this.knotToPoint(this._bcurve.knots.fractionToKnot(t),e)}fractionToPointAndDerivative(t,e){const i=this._bcurve.knots.fractionToKnot(t);return(e=this.knotToPointAndDerivative(i,e)).direction.scaleInPlace(this._bcurve.knots.knotLength01),e}fractionToPointAnd2Derivatives(t,e){const i=this._bcurve.knots.fractionToKnot(t);e=this.knotToPointAnd2Derivatives(i,e);const s=this._bcurve.knots.knotLength01;return e.vectorU.scaleInPlace(s),e.vectorV.scaleInPlace(s*s),e}startPoint(){return this.evaluatePointInSpan(0,0)}endPoint(){return this.evaluatePointInSpan(this.numSpan-1,1)}reverseInPlace(){this._bcurve.reverseInPlace()}collectBezierSpans(t){const e=[],i=this.numSpan;for(let s=0;s<i;s++)if(this._bcurve.knots.isIndexOfRealSpan(s)){const i=this.getSaturatedBezierSpan3dOr3dH(s,t);i&&e.push(i)}return e}poleIndexToDataIndex(t){if(t>=0&&t<this.numPoles)return t*this._bcurve.poleLength}closestPoint(t,e){const i=this.fractionToPoint(0),s=vt.createCurveFractionPointDistance(this,0,i,i.distance(t));let n;const r=this.numSpan;for(let e=0;e<r;e++)this._bcurve.knots.isIndexOfRealSpan(e)&&(n=this.getSaturatedBezierSpan3dOr3dH(e,!0,n),n&&n.updateClosestPointByTruePerpendicular(t,s,!1,!0)&&(s.curve=this,s.fraction=n.fractionToParentFraction(s.fraction)));return s}cloneTransformed(t){const e=this.clone();return e.tryTransformInPlace(t),e}clonePartialCurve(t,e){const i=this.clone(),s=i._bcurve.knots.knots.length;let n=i._bcurve.knots.fractionToKnot(t),r=i._bcurve.knots.fractionToKnot(e);if(i._bcurve.addKnot(n,i.degree),i._bcurve.addKnot(r,i.degree),s===i._bcurve.knots.knots.length)return i;if(n>r){const t=n;n=r,r=t}const o=i._bcurve.knots.knotToLeftKnotIndex(n)-i.degree+1,a=o*i._bcurve.poleLength,c=i._bcurve.knots.knotToLeftKnotIndex(r);let h=c-i._bcurve.knots.getKnotMultiplicityAtIndex(c)+1;i._bcurve.knots.knots[c]<r&&(h=c+1);const l=(h+1)*i._bcurve.poleLength,d=h+i.degree;return i._bcurve.knots.setKnotsCapture(i._bcurve.knots.knots.slice(o,d)),i._bcurve.packedData=i._bcurve.packedData.slice(a,l),i.setWrappable(C.None),i}appendPlaneIntersectionPoints(t,e){const i=this.numPoles,s=this.order,n=new Float64Array(i),r=this.numSpan,o=Rt.create(),a=ft.createNull();for(let e=0;e<i;e++)n[e]=t.weightedAltitude(this.getPolePoint4d(e,o)),a.extendX(n[e]);let c,h=0,l=-1e3;if(a.containsX(0))for(let t=0;t<r;t++)if(this._bcurve.knots.isIndexOfRealSpan(t)&&(a.setNull(),a.extendArraySubset(n,t,s),a.containsX(0))){c=Lt.createArraySubset(n,t,s,c),Fe.saturate1dInPlace(c.coffs,this._bcurve.knots,t);const i=c.roots(0,!0);if(i)for(const s of i){h++;const i=this._bcurve.knots.spanFractionToFraction(t,s);if(!K.isAlmostEqualNumber(i,l)){const t=vt.createCurveEvaluatedFraction(this,i);t.intervalRole=I.isolated,e.push(t),l=i}}}return h}constructOffsetXY(t){const e=ve.create(t),i=new ge(this,e.leftOffsetDistance);return this.emitStrokableParts(i,e.strokeOptions),i.claimResult()}projectedParameterRange(t,e){return Te.findExtremeFractionsAlongDirection(this,t,e)}}class ze extends Re{initializeWorkBezier(){return void 0===this._workBezier&&(this._workBezier=be.createOrder(this.order)),this._workBezier}isSameGeometryClass(t){return t instanceof ze}tryTransformInPlace(t){return ae.multiplyInPlace(t,this._bcurve.packedData),!0}getPolePoint3d(t,e){const i=this.poleIndexToDataIndex(t);if(void 0!==i){const t=this._bcurve.packedData;return Q.create(t[i],t[i+1],t[i+2],e)}}getPolePoint4d(t,e){const i=this.poleIndexToDataIndex(t);if(void 0!==i){const t=this._bcurve.packedData;return Rt.create(t[i],t[i+1],t[i+2],1,e)}}spanFractionToKnot(t,e){return this._bcurve.spanFractionToKnot(t,e)}constructor(t,e,i){super(3,t,e,i)}copyPoints(){return ae.unpackNumbersToNestedArrays(this._bcurve.packedData,3)}copyPointsFloat64Array(){return this._bcurve.packedData.slice()}copyKnots(t){return this._bcurve.knots.copyKnots(t)}static createUniformKnots(t,e){const i=t instanceof Float64Array?t.length/3:t.length;if(e<2||i<e)return;const s=le.createUniformClamped(i,e-1,0,1),n=new ze(i,e,s);if(t instanceof Float64Array)for(let e=0;e<3*i;e++)n._bcurve.packedData[e]=t[e];else if(t instanceof nt)n._bcurve.packedData=t.float64Data().slice(0,3*i);else{let e=0;for(const i of t)n._bcurve.packedData[e++]=i.x,n._bcurve.packedData[e++]=i.y,n._bcurve.packedData[e++]=i.z}return n}static createPeriodicUniformKnots(t,e){if(e<2)return;let i=t instanceof Float64Array?t.length/3:t.length;const s=Q.createZero(),n=Q.createZero();let r=!1;do{t instanceof Float64Array?(s.set(t[0],t[1],t[2]),n.set(t[3*i-3],t[3*i-2],t[3*i-1])):t instanceof nt?(s.set(t.float64Data()[0],t.float64Data()[1],t.float64Data()[2]),n.set(t.float64Data()[3*i-3],t.float64Data()[3*i-2],t.float64Data()[3*i-1])):(s.setFromPoint3d(t[0]),n.setFromPoint3d(t[i-1])),(r=s.isAlmostEqual(n))&&--i}while(r&&i>1);if(i<e)return;const o=e-1,a=i,c=le.createUniformWrapped(a,o,0,1);c.wrappable=C.OpenByAddingControlPoints;const h=new ze(i+o,e,c);if(t instanceof Float64Array){for(let e=0;e<3*i;e++)h._bcurve.packedData[e]=t[e];for(let e=0;e<3*o;e++)h._bcurve.packedData[3*i+e]=t[e]}else if(t instanceof nt){h._bcurve.packedData=t.float64Data().slice(0,3*i);for(let e=0;e<3*o;e++)h._bcurve.packedData[3*i+e]=t.float64Data()[e]}else{let e=0;for(let s=0;s<i;s++)h._bcurve.packedData[e++]=t[s].x,h._bcurve.packedData[e++]=t[s].y,h._bcurve.packedData[e++]=t[s].z;for(let i=0;i<o;i++)h._bcurve.packedData[e++]=t[i].x,h._bcurve.packedData[e++]=t[i].y,h._bcurve.packedData[e++]=t[i].z}return h}static createFromInterpolationCurve3dOptions(t){return de.createThroughPointsC2Cubic(t)}static createFromAkimaCurve3dOptions(t){return de.createThroughPoints(t.fitPoints,4)}static create(t,e,i){if(i<2)return;let s=t.length;if(t instanceof Float64Array&&(s/=3),s<i)return;const n=e.length;let r;if(s+i===n)r=!0;else{if(s+i!==n+2)return;r=!1}const o=le.create(e,i-1,r),a=new ze(s,i,o);let c=0;if(t instanceof Float64Array)for(const e of t)a._bcurve.packedData[c++]=e;else for(const e of t)a._bcurve.packedData[c++]=e.x,a._bcurve.packedData[c++]=e.y,a._bcurve.packedData[c++]=e.z;return a}clone(){const t=this._bcurve.knots.clone(),e=new ze(this.numPoles,this.order,t);return e._bcurve.packedData=this._bcurve.packedData.slice(),e}evaluatePointInSpan(t,e){return this._bcurve.evaluateBuffersInSpan(t,e),Q.createFrom(this._bcurve.poleBuffer)}evaluatePointAndDerivativeInSpan(t,e){return this._bcurve.evaluateBuffersInSpan1(t,e),bt.createCapture(Q.createFrom(this._bcurve.poleBuffer),$.createFrom(this._bcurve.poleBuffer1))}knotToPoint(t,e){return this._bcurve.evaluateBuffersAtKnot(t),Q.createFrom(this._bcurve.poleBuffer,e)}knotToPointAndDerivative(t,e){return this._bcurve.evaluateBuffersAtKnot(t,1),e?(e.origin.setFrom(this._bcurve.poleBuffer),e.direction.setFrom(this._bcurve.poleBuffer1),e):bt.createCapture(Q.createFrom(this._bcurve.poleBuffer),$.createFrom(this._bcurve.poleBuffer1))}knotToPointAnd2Derivatives(t,e){return this._bcurve.evaluateBuffersAtKnot(t,2),Et.createOriginAndVectorsXYZ(this._bcurve.poleBuffer[0],this._bcurve.poleBuffer[1],this._bcurve.poleBuffer[2],this._bcurve.poleBuffer1[0],this._bcurve.poleBuffer1[1],this._bcurve.poleBuffer1[2],this._bcurve.poleBuffer2[0],this._bcurve.poleBuffer2[1],this._bcurve.poleBuffer2[2],e)}isAlmostEqual(t){return t instanceof ze&&this._bcurve.knots.isAlmostEqual(t._bcurve.knots)&&ae.isAlmostEqual(this._bcurve.packedData,t._bcurve.packedData)}isInPlane(t){return ae.isCloseToPlane(this._bcurve.packedData,t)}quickLength(){return ae.sumEdgeLengths(this._bcurve.packedData)}emitStrokableParts(t,e){const i=void 0!==t.announceBezierCurve,s=this.initializeWorkBezier(),n=this.numSpan;let r;for(let o=0;o<n;o++){const n=this.getSaturatedBezierSpan3dOr3dH(o,!1,s);n&&(r=n.computeStrokeCountForOptions(e),i?t.announceBezierCurve(n,r,this,o,this._bcurve.knots.spanFractionToFraction(o,0),this._bcurve.knots.spanFractionToFraction(o,1)):t.announceIntervalForUniformStepStrokes(this,r,this._bcurve.knots.spanFractionToFraction(o,0),this._bcurve.knots.spanFractionToFraction(o,1)))}}computeStrokeCountForOptions(t){const e=this.initializeWorkBezier(),i=this.numSpan;let s=0;for(let n=0;n<i;n++){const i=this.getSaturatedBezierSpan3d(n,e);i&&(s+=i.computeStrokeCountForOptions(t))}return s}computeAndAttachRecursiveStrokeCounts(t,e){const i=this.initializeWorkBezier(),s=this.numSpan,n=Yt.createWithCurvePrimitiveAndOptionalParent(this,e,[]);for(let e=0;e<s;e++)if(this.getSaturatedBezierSpan3d(e,i)){const e=i.curveLength(),s=i.computeStrokeCountForOptions(t);n.addToCountAndLength(s,e)}ie.installStrokeCountMap(this,n,e)}emitStrokes(t,e){const i=this.initializeWorkBezier(),s=this.numSpan;for(let n=0;n<s;n++){const s=this.getSaturatedBezierSpan3d(n,i);s&&s.emitStrokes(t,e)}}get isClosable(){const t=this._bcurve.knots.wrappable;return t===C.None?C.None:this._bcurve.knots.testClosable(t)&&this._bcurve.testCloseablePolygon(t)?t:C.None}getSaturatedBezierSpan3dOr3dH(t,e,i){return e?this.getSaturatedBezierSpan3dH(t,i):this.getSaturatedBezierSpan3d(t,i)}getSaturatedBezierSpan3d(t,e){if(t<0||t>=this.numSpan)return;const i=this.order;void 0!==e&&e instanceof be&&e.order===i||(e=be.createOrder(i));const s=e;return s.loadSpanPoles(this._bcurve.packedData,t),s.saturateInPlace(this._bcurve.knots,t)?e:void 0}getSaturatedBezierSpan3dH(t,e){if(t<0||t>=this.numSpan)return;const i=this.order;void 0!==e&&e instanceof Ee&&e.order===i||(e=Ee.createOrder(i));const s=e;return s.loadSpan3dPolesWithWeight(this._bcurve.packedData,t,1),s.saturateInPlace(this._bcurve.knots,t)?s:void 0}setWrappable(t){this._bcurve.knots.wrappable=t}dispatchToGeometryHandler(t){return t.handleBSplineCurve3d(this)}extendRange(t,e){const i=this._bcurve.packedData,s=i.length-2;if(e)for(let n=0;n<s;n+=3)t.extendTransformedXYZ(e,i[n],i[n+1],i[n+2]);else for(let e=0;e<s;e+=3)t.extendXYZ(i[e],i[e+1],i[e+2])}}class De extends ie{isSameGeometryClass(t){return t instanceof De}get center(){return this._center.clone()}get vector0(){return this._matrix.columnX()}get vector90(){return this._matrix.columnY()}get perpendicularVector(){return this._matrix.columnZ()}matrixClone(){return this._matrix.clone()}get matrixRef(){return this._matrix}get sweep(){return this._sweep}set sweep(t){this._sweep.setFrom(t)}get isExtensibleFractionSpace(){return!0}constructor(t,e,i){super(),this.curvePrimitiveType="arc",this._center=t,this._matrix=e,this._sweep=i}cloneTransformed(t){const e=this.clone();return e.tryTransformInPlace(t),e}setRefs(t,e,i){this._center=t,this._matrix=e,this._sweep=i}set(t,e,i){this.setRefs(t.clone(),e.clone(),i?i.clone():At.create360())}setFrom(t){this._center.setFrom(t._center),this._matrix.setFrom(t._matrix),this._sweep.setFrom(t._sweep)}clone(){return new De(this._center.clone(),this._matrix.clone(),this._sweep.clone())}static createRefs(t,e,i,s){return s?(s.setRefs(t,e,i),s):new De(t,e,i)}static createScaledXYColumns(t,e,i,s,n,r){const o=e.columnX(),a=e.columnY();return De.create(t,o.scale(i,o),a.scale(s,a),n,r)}static createCenterNormalRadius(t,e,i,s){const n=xt.createRigidHeadsUp(e);return De.createScaledXYColumns(t,n,i,i,void 0,s)}static create(t,e,i,s,n){const r=e.unitCrossProductWithDefault(i,0,0,0),o=xt.createColumns(e,i,r);return De.createRefs(void 0!==t?t.clone():Q.create(0,0,0),o,s?s.clone():At.create360(),n)}cloneAtZ(t){return void 0===t&&(t=this._center.z),De.createXYZXYZXYZ(this._center.x,this._center.y,this._center.z,this._matrix.coffs[0],this._matrix.coffs[3],0,this._matrix.coffs[1],this._matrix.coffs[4],0,this._sweep)}static createXYZXYZXYZ(t,e,i,s,n,r,o,a,c,h,l){return De.create(Q.create(t,e,i),$.create(s,n,r),$.create(o,a,c),h,l)}quickEccentricity(){const t=this._matrix.columnXMagnitude(),e=this._matrix.columnYMagnitude(),i=this._matrix.columnXYCrossProductMagnitude(),s=K.maxXY(t,e);return i/(s*s)}static createCircularStartMiddleEnd(t,e,i,s){const n=$.createStartEnd(t,e),r=$.createStartEnd(t,i),o=n.magnitude(),a=r.magnitude(),c=n.sizedCrossProduct(r,Math.sqrt(o*a));if(c){const e=Ft.linearSystem3d(c.x,c.y,c.z,n.x,n.y,n.z,r.x,r.y,r.z,0,.5*o*o,.5*a*a);if(e){const n=Q.create(t.x,t.y,t.z).plus(e),r=$.createStartEnd(n,t),o=$.createRotateVectorAroundVector(r,c,W.createDegrees(90));if(o){const t=$.createStartEnd(n,i),e=r.signedAngleTo(t,c);return e.radians<0&&e.addMultipleOf2PiInPlace(1),De.create(n,r,o,At.createStartEndRadians(0,e.radians),s)}}}return we.create(t,e,i)}getFractionToDistanceScale(){const t=this.circularRadius();if(void 0!==t)return Math.abs(t*this._sweep.sweepRadians)}fractionToPoint(t,e){const i=this._sweep.fractionToRadians(t);return this._matrix.originPlusMatrixTimesXY(this._center,Math.cos(i),Math.sin(i),e)}fractionAndRadialFractionToPoint(t,e,i){const s=this._sweep.fractionToRadians(t);return this._matrix.originPlusMatrixTimesXY(this._center,e*Math.cos(s),e*Math.sin(s),i)}fractionToPointAndDerivative(t,e){return(e=this.radiansToPointAndDerivative(this._sweep.fractionToRadians(t),e)).direction.scaleInPlace(this._sweep.sweepRadians),e}fractionToPointAnd2Derivatives(t,e){const i=this._sweep.fractionToRadians(t);e||(e=Et.createXYPlane());const s=Math.cos(i),n=Math.sin(i);this._matrix.originPlusMatrixTimesXY(this._center,s,n,e.origin);const r=this._sweep.sweepRadians;this._matrix.multiplyXY(-r*n,r*s,e.vectorU);const o=r*r;return this._matrix.multiplyXY(-o*s,-o*n,e.vectorV),e}radiansToPointAndDerivative(t,e){e=e||bt.createZero();const i=Math.cos(t),s=Math.sin(t);return this._matrix.originPlusMatrixTimesXY(this._center,i,s,e.origin),this._matrix.multiplyXY(-s,i,e.direction),e}radiansToPoint(t,e){e=e||Q.create();const i=Math.cos(t),s=Math.sin(t);return this._matrix.originPlusMatrixTimesXY(this._center,i,s,e),e}radiansToRotatedBasis(t,e){e=e||Et.createXYPlane();const i=Math.cos(t),s=Math.sin(t);return e.origin.setFromPoint3d(this.center),this._matrix.multiplyXY(i,s,e.vectorU),this._matrix.multiplyXY(-s,i,e.vectorV),e}angleToPointAndDerivative(t,e){e=e||bt.createZero();const i=t.cos(),s=t.sin();return this._matrix.originPlusMatrixTimesXY(this._center,i,s,e.origin),this._matrix.multiplyXY(-s,i,e.direction),e}startPoint(t){return this.fractionToPoint(0,t)}endPoint(t){return this.fractionToPoint(1,t)}curveLength(){return this.curveLengthBetweenFractions(0,1)}curveLengthBetweenFractions(t,e){const i=this.getFractionToDistanceScale();if(void 0!==i)return i*Math.abs(e-t);let s=t,n=e;t>e&&(s=e,n=t);const r=(n-s)*this._sweep.sweepDegrees;let o=this.quickEccentricity();o<1e-5&&(o=1e-5);let a=Math.ceil(r/(o*De.quadratureIntervalAngleDegrees));return a>400&&(a=400),a<1&&(a=1),super.curveLengthWithFixedIntervalCountQuadrature(s,n,a,De.quadratureGuassCount)}quickLength(){const t=Math.abs(this._sweep.sweepRadians);let e=Math.ceil(4*t/Math.PI);e<1&&(e=1),e<4?e+=3:e<6&&(e+=2);const i=De._workPointA,s=De._workPointB;let n=0;this.fractionToPoint(0,i);for(let t=1;t<=e;t++)this.fractionToPoint(t/e,s),n+=i.distance(s),i.setFromPoint3d(s);const r=t/e;return n*(r/(2*Math.sin(.5*r)))}moveSignedDistanceFromFraction(t,e,i,s){if(!this.isCircular)return super.moveSignedDistanceFromFractionGeneric(t,e,i,s);const n=this.curveLength(),r=K.conditionalDivideFraction(e,n);return void 0===r?vt.createCurveFractionPointDistanceCurveSearchStatus(this,t,this.fractionToPoint(t),0,A.error):vt.createConditionalMoveSignedDistance(i,this,t,t+r,e,s)}allPerpendicularAngles(t,e=!0,i=!1){const s=[],n=t.vectorTo(this.center),r=this._matrix.columnXMagnitudeSquared(),o=this._matrix.columnXDotColumnY(),a=this._matrix.columnYMagnitudeSquared();return kt.solveUnitCircleImplicitQuadricIntersection(o,a-r,-o,this._matrix.dotColumnY(n),-this._matrix.dotColumnX(n),0,s),i&&(s.push(this.sweep.startRadians),s.push(this.sweep.endRadians)),s}closestPoint(t,e,i){i=vt.create(this,i);const s=this.allPerpendicularAngles(t,!0,!0);let n=jt.resolveVariantCurveExtendParameterToCurveExtendMode(e,0),r=jt.resolveVariantCurveExtendParameterToCurveExtendMode(e,1);this._sweep.isFullCircle&&(n=w.None,r=w.None),n!==w.None&&r!==w.None&&(s.push(this._sweep.startRadians),s.push(this._sweep.endRadians));const o=bt.createZero();if(0===s.length)i.setFR(0,this.radiansToPointAndDerivative(this._sweep.startRadians,o)),i.a=t.distance(i.point);else{let n=Number.MAX_VALUE,r=0;for(const a of s){const s=jt.resolveRadiansToSweepFraction(e,a,this.sweep);void 0!==s&&(this.fractionToPointAndDerivative(s,o),r=t.distance(o.origin),r<n&&(n=r,i.setFR(s,o),i.a=r))}}return i}reverseInPlace(){this._sweep.reverseInPlace()}tryTransformInPlace(t){return this._center=t.multiplyPoint3d(this._center,this._center),this._matrix=t.matrix.multiplyMatrixMatrix(this._matrix,this._matrix),this.setVector0Vector90(this._matrix.columnX(),this._matrix.columnY()),!0}isInPlane(t){const e=t.getNormalRef();return K.isSmallMetricDistance(t.altitude(this._center))&&K.isSmallMetricDistance(this._matrix.dotColumnX(e))&&K.isSmallMetricDistance(this._matrix.dotColumnY(e))}get isCircular(){const t=this._matrix.columnXMagnitudeSquared(),e=this._matrix.columnYMagnitudeSquared(),i=this._matrix.columnXDotColumnY();return W.isPerpendicularDotSet(t,e,i)&&K.isSameCoordinateSquared(t,e)}circularRadiusXY(){const t=this._matrix.at(0,0),e=this._matrix.at(1,0),i=this._matrix.at(0,1),s=this._matrix.at(1,1),n=K.dotProductXYXY(t,e,t,e),r=K.dotProductXYXY(i,s,i,s),o=K.dotProductXYXY(t,e,i,s);if(W.isPerpendicularDotSet(n,r,o)&&K.isSameCoordinateSquared(n,r))return K.hypotenuseXY(t,e)}circularRadius(){return this.isCircular?this._matrix.columnXMagnitude():void 0}maxVectorLength(){return Math.max(this._matrix.columnXMagnitude(),this._matrix.columnYMagnitude())}appendPlaneIntersectionPoints(t,e){const i=t.altitude(this._center),s=this._matrix.coffs,n=t.velocityXYZ(s[0],s[3],s[6]),r=t.velocityXYZ(s[1],s[4],s[7]),o=K.solveTrigForm(i,n,r);let a=0;if(void 0!==o){let t;for(t of(a=o.length,o)){const i=Math.atan2(t.y,t.x),s=this._sweep.radiansToPositivePeriodicFraction(i),n=vt.createCurveFractionPoint(this,s,this.fractionToPoint(s));n.intervalRole=I.isolated,(W.isAlmostEqualRadiansAllowPeriodShift(i,this._sweep.startRadians)||W.isAlmostEqualRadiansAllowPeriodShift(i,this._sweep.endRadians))&&(n.intervalRole=I.isolatedAtVertex),e.push(n)}}return a}extendRange(t,e){this.extendRangeInSweep(t,this._sweep,e)}extendRangeInSweep(t,e,i){const s=new Mt(0,0,0),n=this._center.clone(De._workPointA),r=this._matrix.columnX(De._workVectorU),o=this._matrix.columnY(De._workVectorV);i&&(i.multiplyPoint3d(n,n),i.multiplyVector(r,r),i.multiplyVector(o,o));const a=De._workPointB,c=De._workPointC,h=ft.createNull();for(let t=0;t<3;t++)s.set(n.at(t),r.at(t),o.at(t)),s.rangeInSweep(e,h),a.setAt(t,h.low),c.setAt(t,h.high);t.extend(a),t.extend(c)}rangeBetweenFractions(t,e,i){const s=At.createStartEndRadians(this.sweep.fractionToRadians(t),this.sweep.fractionToRadians(e)),n=ut.create();return this.extendRangeInSweep(n,s,i),n}getPlaneAltitudeSineCosinePolynomial(t,e){return e||(e=new Mt(0,0,0)),e.set(t.altitude(this._center),t.velocityXYZ(this._matrix.coffs[0],this._matrix.coffs[3],this._matrix.coffs[6]),t.velocityXYZ(this._matrix.coffs[1],this._matrix.coffs[4],this._matrix.coffs[7])),e}static createUnitCircle(){return De.createRefs(Q.create(0,0,0),xt.createIdentity(),At.create360())}static createXY(t,e,i=At.create360()){return new De(t.clone(),xt.createScale(e,e,1),i)}static createXYEllipse(t,e,i,s=At.create360()){return new De(t.clone(),xt.createScale(e,i,1),s)}setVector0Vector90(t,e){this._matrix.setColumns(t,e,t.unitCrossProductWithDefault(e,0,0,0))}toScaledMatrix3d(){const t=W.dotProductsToHalfAngleTrigValues(this._matrix.columnXMagnitudeSquared(),this._matrix.columnYMagnitudeSquared(),this._matrix.columnXDotColumnY(),!0),e=this._matrix.multiplyXY(t.c,t.s),i=this._matrix.multiplyXY(-t.s,t.c);return{axes:xt.createRigidFromColumns(e,i,p.XYZ)||xt.createIdentity(),center:this._center,r0:e.magnitude(),r90:i.magnitude(),sweep:this.sweep.cloneMinusRadians(t.radians)}}toVectors(){return{center:this.center,vector0:this._matrix.columnX(),vector90:this._matrix.columnY(),sweep:this.sweep}}toTransformedVectors(t){return t?{center:t.multiplyPoint3d(this._center),vector0:t.multiplyVector(this._matrix.columnX()),vector90:t.multiplyVector(this._matrix.columnY()),sweep:this.sweep}:{center:this._center.clone(),vector0:this._matrix.columnX(),vector90:this._matrix.columnY(),sweep:this.sweep}}toTransformedPoint4d(t){return{center:t.multiplyPoint3d(this._center,1),vector0:t.multiplyPoint3d(this._matrix.columnX(),0),vector90:t.multiplyPoint3d(this._matrix.columnY(),0),sweep:this.sweep}}setFromJSON(t){if(t&&t.center&&t.vector0&&t.vector90&&t.sweep){this._center.setFromJSON(t.center);const e=$.create(),i=$.create();e.setFromJSON(t.vector0),i.setFromJSON(t.vector90),this.setVector0Vector90(e,i),this._sweep.setFromJSON(t.sweep)}else this._center.set(0,0,0),this._matrix.setFrom(xt.identity),this._sweep.setStartEndRadians()}toJSON(){return{center:this._center.toJSON(),sweep:this._sweep.toJSON(),vector0:this._matrix.columnX().toJSON(),vector90:this._matrix.columnY().toJSON()}}isAlmostEqual(t){if(t instanceof De){const e=t;return this._center.isAlmostEqual(e._center)&&this._matrix.isAlmostEqual(e._matrix)&&this._sweep.isAlmostEqualAllowPeriodShift(e._sweep)}return!1}emitStrokes(t,e){const i=this.computeStrokeCountForOptions(e);t.appendFractionalStrokePoints(this,i,0,1,!0)}emitStrokableParts(t,e){const i=this.computeStrokeCountForOptions(e);t.startCurvePrimitive(this),t.announceIntervalForUniformStepStrokes(this,i,0,1),t.endCurvePrimitive(this)}computeStrokeCountForOptions(t){let e;if(t){const i=this.maxVectorLength();e=t.applyTolerancesToArc(i,this._sweep.sweepRadians)}else e=ye.applyAngleTol(void 0,1,this._sweep.sweepRadians);return e}dispatchToGeometryHandler(t){return t.handleArc3d(this)}clonePartialCurve(t,e){if(e<t){const i=this.clonePartialCurve(e,t);return i.reverseInPlace(),i}const i=this.clone();return i.sweep.setStartEndRadians(this.sweep.fractionToRadians(t),this.sweep.fractionToRadians(e)),i}cloneInRotatedBasis(t){const e=t.cos(),i=t.sin(),s=this._matrix.multiplyXY(e,i),n=this._matrix.multiplyXY(-i,e),r=At.createStartEndRadians(this._sweep.startRadians-t.radians,this._sweep.endRadians-t.radians);return De.create(this._center.clone(),s,n,r)}announceClipIntervals(t,e){return t.announceClippedArcIntervals(this,e)}otherArcAsLocalVectors(t){const e=this._matrix.multiplyInverseXYZAsPoint3d(t.center.x-this.center.x,t.center.y-this.center.y,t.center.z-this.center.z),i=this._matrix.multiplyInverse(t.vector0),s=this._matrix.multiplyInverse(t.vector90);if(e&&i&&s)return{center:e,vector0:i,vector90:s,sweep:this.sweep.clone()}}static createFilletArc(t,e,i,s){const n=$.createStartEnd(e,t),r=$.createStartEnd(e,i),o=n.magnitude(),a=r.magnitude();if(n.normalizeInPlace()&&r.normalizeInPlace()){const t=n.plus(r);if(t.normalizeInPlace()){const i=r.minus(n),c=i.magnitude(),h=.5*c;if(!K.isSmallAngleRadians(h)){const n=h/Math.sqrt(1-h*h),r=Math.acos(h),l=s/h,d=s/n,u=d/o,f=d/a,g=e.plusScaled(t,l);return t.scaleInPlace(-s),i.scaleInPlace(s/c),{arc:De.create(g,t,i,At.createStartEndRadians(-r,r)),fraction10:u,fraction12:f,point:e.clone()}}}}return{fraction10:0,fraction12:0,point:e.clone()}}scaleAboutCenterInPlace(t){this._matrix.scaleColumnsInPlace(t,t,1)}areaToChordXY(t,e){let i=K.crossProductXYXY(this._matrix.coffs[0],this._matrix.coffs[3],this._matrix.coffs[1],this._matrix.coffs[4]);const s=this._sweep.fractionToRadians(t),n=.5*(this._sweep.fractionToRadians(e)-s);return n<0&&(i=-i),(n-Math.cos(n)*Math.sin(n))*i}constructOffsetXY(t){const e=ve.create(t);if(this.isCircular||e.preserveEllipticalArcs){const t=this.cloneAtZ(),i=t.sweep.sweepRadians*t.matrixRef.coffs[8]>=0?1:-1,s=t.matrixRef.columnXMagnitude(),n=s-i*e.leftOffsetDistance,r=this.isCircular?s:t.matrixRef.columnYMagnitude(),o=this.isCircular?n:r-i*e.leftOffsetDistance;if(!K.isSmallMetricDistance(n)&&s*n>0&&(this.isCircular||!K.isSmallMetricDistance(o)&&r*o>0)){const e=n/s,i=this.isCircular?e:o/r,a=t.matrixClone();return a.scaleColumnsInPlace(e,i,1),De.createRefs(t.center.clone(),a,t.sweep.clone())}return}const i=new ge(this,e.leftOffsetDistance);return this.emitStrokableParts(i,e.strokeOptions),i.claimResult()}projectedParameterRange(t,e){return Te.findExtremeFractionsAlongDirection(this,t,e)}}De._workPointA=Q.create(),De._workPointB=Q.create(),De._workPointC=Q.create(),De._workVectorU=$.create(),De._workVectorV=$.create(),De.quadratureGuassCount=5,De.quadratureIntervalAngleDegrees=10;class Ye{constructor(){}announceUnexpected(t,e){}announceCurvePrimitive(t,e=-1){}announcePath(t,e=-1){let i=0;for(const e of t.children)this.announceCurvePrimitive(e,i++)}announceLoop(t,e=-1){let i=0;for(const e of t.children)this.announceCurvePrimitive(e,i++)}announceParityRegion(t,e=-1){let i=0;for(const e of t.children)this.announceLoop(e,i++)}announceUnionRegion(t,e=-1){let i=0;for(const e of t.children)e.announceToCurveProcessor(this,i++)}announceBagOfCurves(t,e=-1){for(const e of t.children)e instanceof ie?this.announceCurvePrimitive(e):e.announceToCurveProcessor(this)}}class Ne extends Ye{constructor(){super(),this._stack=[]}enter(t){this._stack.push(t)}leave(){return this._stack.pop()}announceUnexpected(t,e){}announceCurvePrimitive(t,e=-1){}announcePath(t,e=-1){this.enter(t),super.announcePath(t,e),this.leave()}announceLoop(t,e=-1){this.enter(t),super.announceLoop(t,e),this.leave()}announceParityRegion(t,e=-1){this.enter(t);let i=0;for(const e of t.children)this.announceLoop(e,i++);this.leave()}announceUnionRegion(t,e=-1){this.enter(t),super.announceUnionRegion(t,e),this.leave()}announceBagOfCurves(t,e=-1){this.enter(t);let i=0;for(const e of t.children)e instanceof ie?this.announceCurvePrimitive(e,i++):e.announceToCurveProcessor(this);this.leave()}}class Oe extends Ne{constructor(t){super(),this._transform=t,this._result=void 0}static clone(t,e){const i=new Oe(e);return t.announceToCurveProcessor(i),i._result}enter(t){t instanceof qe&&super.enter(t.cloneEmptyPeer())}leave(){const t=super.leave();return t&&(0===this._stack.length?this._result=t:this._stack[this._stack.length-1].tryAddChild(t)),t}doClone(t){return this._transform?t.cloneTransformed(this._transform):t.clone()}announceCurvePrimitive(t,e){const i=this.doClone(t);if(void 0!==i&&this._stack.length>0){const t=this._stack[this._stack.length-1];if(t instanceof We||t instanceof Ge)if(Array.isArray(i))for(const e of i)t.tryAddChild(e);else t.tryAddChild(i)}}}class Be extends Oe{constructor(){super(void 0)}doClone(t){if(t instanceof we&&t.numPoints()>1){const e=t.packedPoints,i=e.length,s=[];for(let t=0;t+1<i;t++)s.push(Pe.createCapture(e.getPoint3dAtUncheckedPointIndex(t),e.getPoint3dAtUncheckedPointIndex(t+1)));return s}return t.clone()}static clone(t){const e=new Be;return t.announceToCurveProcessor(e),e._result}}class Ve extends Ne{constructor(){super(),this.numLineSegment=0,this.numLineString=0,this.numOther=0}static hasNonLinearPrimitives(t){const e=new Ve;return t.announceToCurveProcessor(e),e.numOther>0}announceCurvePrimitive(t,e){t instanceof Pe?this.numLineSegment++:t instanceof we?this.numLineString++:this.numOther++}}class Le extends Ne{constructor(){super(),this.maxGap=0}static maxGap(t){const e=new Le;return t.announceToCurveProcessor(e),e.maxGap}announceCurvePrimitive(t,e){if(this._stack.length>0){const i=this._stack[this._stack.length-1];if(i instanceof We){const s=i.cyclicCurvePrimitive(e+1);void 0!==t&&void 0!==s&&(this.maxGap=Math.max(this.maxGap,t.endPoint().distance(s.startPoint())))}}}}class Ue extends Ye{constructor(){super(),this._sum=0}static sumLengths(t){const e=new Ue;return t.announceToCurveProcessor(e),e._sum}announceCurvePrimitive(t,e){this._sum+=t.curveLength()}}class Ze extends Ye{constructor(t){super(),this.numFail=0,this.numOK=0,this.transform=t}static tryTransformInPlace(t,e){const i=new Ze(e);return t.announceToCurveProcessor(i),0===i.numFail}announceCurvePrimitive(t,e){t.tryTransformInPlace(this.transform)?this.numOK++:this.numFail++}}class qe extends Nt{constructor(){super(...arguments),this.geometryCategory="curveCollection",this.isInner=!1}sumLengths(){return Ue.sumLengths(this)}closestPoint(t){let e;if(void 0!==this.children)for(const i of this.children)if(i instanceof ie){const s=i.closestPoint(t,!1);e=vt.chooseSmallerA(e,s)}else if(i instanceof qe){const s=i.closestPoint(t);e=vt.chooseSmallerA(e,s)}return e}maxGap(){return Le.maxGap(this)}checkForNonLinearPrimitives(){return Ve.hasNonLinearPrimitives(this)}tryTransformInPlace(t){return Ze.tryTransformInPlace(this,t)}clone(){return Oe.clone(this)}cloneTransformed(t){return Oe.clone(this,t)}cloneWithExpandedLineStrings(){return Be.clone(this)}collectCurvePrimitivesGo(t,e,i=!1){if(this.children)for(const s of this.children)(s instanceof ie||s instanceof qe)&&s.collectCurvePrimitivesGo(t,e,i)}collectCurvePrimitives(t,e=!1,i=!1){const s=void 0===t?[]:t;return this.collectCurvePrimitivesGo(s,e,i),s}get isAnyRegionType(){return 2===this.dgnBoundaryType()||4===this.dgnBoundaryType()||5===this.dgnBoundaryType()}get isOpenPath(){return 1===this.dgnBoundaryType()}get isClosedPath(){return 2===this.dgnBoundaryType()}extendRange(t,e){const i=this.children;if(i)for(const s of i)s.extendRange(t,e)}static createCurveLocationDetailOnAnyCurvePrimitive(t,e=.5){if(t){if(t instanceof ie)return vt.createCurveEvaluatedFraction(t,e);if(t instanceof qe&&void 0!==t.children)for(const i of t.children){const t=this.createCurveLocationDetailOnAnyCurvePrimitive(i,e);if(t)return t}}}projectedParameterRange(t,e){return Te.findExtremeFractionsAlongDirection(this,t,e)}}class We extends qe{constructor(){super(),this._curves=[]}get children(){return this._curves}cyclicCurvePrimitive(t,e=!0){const i=this.children.length;if(0!==i){if(t>=0&&t<i)return this.children[t];if(e){const e=K.modulo(t,i);return this.children[e]}}}getPackedStrokes(t){const e=this.cloneStroked(t);if(e instanceof We){const t=e.children;if(1===t.length){const e=t[0];if(e instanceof we)return e.packedPoints}}}tryAddChild(t){return!!(t&&t instanceof ie)&&(this._curves.push(t),!0)}getChild(t){if(t<this._curves.length)return this._curves[t]}extendRange(t,e){for(const i of this._curves)i.extendRange(t,e)}reverseChildrenInPlace(){for(const t of this._curves)t.reverseInPlace();this._curves.reverse()}childIndex(t,e){for(let e=0;e<this._curves.length;e++)if(this._curves[e]===t)return e;if(e)for(let e=0;e<this._curves.length;e++){const i=this._curves[e];if(i instanceof ce&&i.proxyCurve===t)return e}}primitiveIndexAndFractionToCurveLocationDetailPointAndDerivative(t,e,i=!1,s){const n=this.cyclicCurvePrimitive(t,i);if(n)return vt.createCurveEvaluatedFractionPointAndDerivative(n,e,s)}}class Ge extends qe{isSameGeometryClass(t){return t instanceof Ge}constructor(){super(),this.curveCollectionType="bagOfCurves",this._children=[]}get children(){return this._children}static create(...t){const e=new Ge;for(const i of t)e.tryAddChild(i);return e}dgnBoundaryType(){return 0}announceToCurveProcessor(t,e=-1){return t.announceBagOfCurves(this,e)}cloneStroked(t){const e=new Ge;let i;for(i of this.children)if(i instanceof ie){const s=we.create();i.emitStrokes(s,t),s&&e.children.push(s)}else if(i instanceof qe){const s=i.cloneStroked(t);s&&e.children.push(s)}return e}cloneEmptyPeer(){return new Ge}tryAddChild(t){return t&&this._children.push(t),!0}getChild(t){if(t<this._children.length)return this._children[t]}dispatchToGeometryHandler(t){return t.handleBagOfCurves(this)}}class He{constructor(){this.consolidateLinearGeometry=!0,this.consolidateCompatibleArcs=!0,this.duplicatePointTolerance=K.smallMetricDistance,this.colinearPointTolerance=K.smallMetricDistance}}class Je{areStronglyIndependentVectors(t,e,i=K.smallAngleRadians){return void 0!==t&&void 0!==e&&t.smallerUnorientedRadiansTo(e)>i}clear(){this._origin=void 0,this._vector0=void 0,this._vector1=void 0,this._vector2=void 0}constructor(){this.clear()}getValidatedFrame(t=!1,e){if(this._origin&&this._vector0&&this._vector1){const i=(t,e)=>Je._workMatrix=xt.createRigidFromColumns(t,e,p.XYZ,Je._workMatrix);if(t){if(this._vector2){const t=i(this._vector0,this._vector1);if(t)return this._vector0.tripleProduct(this._vector1,this._vector2)<0&&t.scaleColumns(1,1,-1),pt.createOriginAndMatrix(this._origin,t,e);const s=this._vector2;this._vector1=this._vector2=void 0,this.announceVector(s)}}else{const t=i(this._vector0,this._vector1);if(t)return pt.createOriginAndMatrix(this._origin,t,e);this._vector1=this._vector2=void 0}}}applyDefaultUpVector(t){t&&this._vector0&&!this._vector1&&!t.isParallelTo(this._vector0)&&(this._vector1=t.crossProduct(this._vector0))}get hasOrigin(){return void 0!==this._origin}savedVectorCount(){return this._vector0?this._vector1?this._vector2?3:2:1:0}announcePoint(t){return this._origin?this._origin.isAlmostEqual(t)?this.savedVectorCount():this.announceVector(this._origin.vectorTo(t)):(this._origin=t.clone(),this.savedVectorCount())}announceVector(t){if(t.isAlmostZero)return this.savedVectorCount();if(!this._vector0)return this._vector0=t.clone(this._vector0),1;if(!this._vector1)return this.areStronglyIndependentVectors(t,this._vector0,1e-5)?(this._vector1=t.clone(this._vector1),2):1;if(!this._vector2){const e=this._vector0.unitCrossProduct(this._vector1);return e&&!K.isSameCoordinate(0,e.dotProduct(t))?(this._vector2=t.clone(this._vector2),3):2}return 3}announce(t){if(!(this.savedVectorCount()>1)&&void 0!==t)if(t instanceof Q)this.announcePoint(t);else if(t instanceof $)this.announceVector(t);else if(Array.isArray(t))for(const e of t){if(this.savedVectorCount()>1)break;this.announce(e)}else if(t instanceof ie)if(t instanceof Pe)this.announcePoint(t.startPoint()),this.announcePoint(t.endPoint());else if(t instanceof De){const e=t.fractionToPointAndDerivative(0);this.announcePoint(e.origin),this.announceVector(e.direction),this.announceVector(t.matrixRef.columnZCrossVector(e.direction))}else if(t instanceof we){for(const e of t.points)if(this.announcePoint(e),this.savedVectorCount()>1)break}else if(t instanceof ze){const e=Q.create();for(let i=0;this.savedVectorCount()<2&&t.getPolePoint3d(i,e)instanceof Q;i++)this.announcePoint(e)}else if(t instanceof fe){const e=Q.create();for(let i=0;this.savedVectorCount()<2&&i<t.options.fitPoints.length;i++)e.setFrom(t.options.fitPoints[i]),this.announcePoint(e)}else{const e=t.fractionToFrenetFrame(0);void 0!==e&&(this.announcePoint(e.getOrigin()),this.announceVector(e.matrix.getColumn(0)),this.announceVector(e.matrix.getColumn(1)))}else if(t instanceof qe){if(t.children)for(const e of t.children)if(this.announce(e),this.savedVectorCount()>1)break}else if(t instanceof nt){const e=Q.create();for(let i=0;this.savedVectorCount()<2&&t.getPoint3dAtCheckedPointIndex(i,e)instanceof Q;i++)this.announcePoint(e)}}static createRightHandedFrame(t,...e){let i=e.length>0&&e[e.length-1]instanceof pt?e.pop():void 0;const s=new Je;for(const n of e)if(s.announce(n),s.applyDefaultUpVector(t),i=s.getValidatedFrame(!1,i))return t&&i.matrix.dotColumnZ(t)<0&&i.matrix.scaleColumnsInPlace(1,-1,-1),i;const n=(t,e)=>t.fractionToFrenetFrame(0,e);for(const t of e){if(t instanceof ie)return n(t,i);if(t instanceof qe){const e=t.collectCurvePrimitives();for(const t of e)if(i=n(t,i))return i}}}static createRightHandedLocalToWorld(...t){return this.createRightHandedFrame(void 0,t)}static createFrameToDistantPoints(t,e){if(t.length>2){const i=t[0],s=Je._workVector0??$.create();ae.indexOfMostDistantPoint(t,t[0],s);const n=Je._workVector1??$.create();ae.indexOfPointWithMaxCrossProductMagnitude(t,i,s,n);const r=Je._workMatrix=xt.createRigidFromColumns(s,n,p.XYZ,Je._workMatrix);if(r)return pt.createOriginAndMatrix(i,r,e)}}static createFrameWithCCWPolygon(t,e){if(t.length>2){const i=gr.centroidAreaNormal(t);if(i)return i.toRigidZFrame(e)}}static createLocalToWorldTransformInRange(t,e=y.NonUniformRangeContainment,i=0,s=0,n=0,r=1,o){if(t.isNull)return pt.createIdentity(o);let a=1,c=1,h=1;e===y.LongestRangeDirection?a=c=h=K.correctSmallMetricDistance(t.maxLength(),r):e===y.NonUniformRangeContainment&&(a=K.correctSmallMetricDistance(t.xLength(),r)*K.maxAbsDiff(i,0,1),c=K.correctSmallMetricDistance(t.yLength(),r)*K.maxAbsDiff(s,0,1),h=K.correctSmallMetricDistance(t.zLength(),r)*K.maxAbsDiff(n,0,1));const l=Je._workPoint=t.fractionToPoint(i,s,n,Je._workPoint),d=Je._workMatrix=xt.createScale(a,c,h,Je._workMatrix);return pt.createOriginAndMatrix(l,d,o)}}class Ke extends We{isSameGeometryClass(t){return t instanceof Ke}constructor(){super(),this.curveCollectionType="loop",this.isInner=!1}static create(...t){const e=new Ke;for(const i of t)e.children.push(i);return e}static createArray(t){const e=new Ke;for(const i of t)e.children.push(i);return e}static createPolygon(t){const e=we.create(t);return e.addClosurePoint(),Ke.create(e)}cloneStroked(t){const e=we.create();for(const i of this.children)i.emitStrokes(e,t);return e.removeDuplicatePoints(),e.isPhysicallyClosed&&(e.popPoint(),e.addClosurePoint()),Ke.create(e)}dgnBoundaryType(){return 2}announceToCurveProcessor(t,e=-1){return t.announceLoop(this,e)}cloneEmptyPeer(){return new Ke}dispatchToGeometryHandler(t){return t.handleLoop(this)}}class je{constructor(t,e,i,s){this.loopA=t,this.curveA=e,this.loopB=i,this.curveB=s}setA(t,e){this.loopA=t,this.curveA=e}setB(t,e){this.loopB=t,this.curveB=e}}class Qe extends qe{isSameGeometryClass(t){return t instanceof Qe}get children(){return this._children}constructor(){super(),this.curveCollectionType="parityRegion",this._children=[]}addLoops(t){if(void 0===t);else if(t instanceof Ke)this.children.push(t);else if(Array.isArray(t))for(const e of t)e instanceof Ke?this.children.push(e):Array.isArray(e)&&this.addLoops(e)}static createLoops(t){if(t instanceof Ke)return t;const e=new Qe;return e.addLoops(t),e}static create(...t){const e=new Qe;for(const i of t)e.children.push(i);return e}dgnBoundaryType(){return 4}announceToCurveProcessor(t,e=-1){return t.announceParityRegion(this,e)}clone(){const t=new Qe;let e;for(e of this.children){const i=e.clone();i instanceof Ke&&t.children.push(i)}return t}cloneStroked(t){const e=new Qe;let i;for(i of this.children){const s=i.cloneStroked(t);s&&e.children.push(s)}return e}cloneEmptyPeer(){return new Qe}tryAddChild(t){return!!(t&&t instanceof Ke)&&(this._children.push(t),!0)}getChild(t){if(t<this._children.length)return this._children[t]}dispatchToGeometryHandler(t){return t.handleParityRegion(this)}}class $e{constructor(t,e,i){this._toleranceSquared=i*i,this._source=t,this._dest=e}acceptPointByIndex(t){const e=this._source.getPoint3dAtCheckedPointIndex(this._source.cyclicIndex(t));e&&this._dest.push(e)}indexOfMaxCrossProduct(t,e){let i,s,n=0;for(let r=t;r<=e;r++){const t=this._source.cyclicIndex(r),e=this._source.cyclicIndex(r+1),o=this._source.cyclicIndex(r+2);this._source.crossProductIndexIndexIndex(t,e,o,$e._vectorQ),i=$e._vectorQ.magnitudeSquared(),i>n&&(n=i,s=r)}return s}indexOfMaxDeviation(t,e){const i=this._source.cyclicIndex(t),s=this._source.cyclicIndex(e);let n,r,o,a,c,h=this._toleranceSquared;this._source.vectorIndexIndex(i,s,$e._vector01);const l=$e._vector01.magnitudeSquared();for(let d=t+1;d<e;d++)c=this._source.cyclicIndex(d),this._source.vectorIndexIndex(i,c,$e._vectorQ),r=$e._vector01.dotProduct($e._vectorQ),r<=0?o=$e._vectorQ.magnitudeSquared():r>l?(this._source.vectorIndexIndex(s,c,$e._vectorQ),o=$e._vectorQ.magnitudeSquared()):(a=r/l,o=$e._vectorQ.magnitudeSquared()-l*a*a),o>h&&(h=o,n=d);return n}recursiveCompressByChordErrorGo(t,e){if(e===t+1)return void this.acceptPointByIndex(e);const i=this.indexOfMaxDeviation(t,e);void 0===i?this.acceptPointByIndex(e):(this.recursiveCompressByChordErrorGo(t,i),this.recursiveCompressByChordErrorGo(i,e))}static compressPoint3dArrayByChordError(t,e){const i=new se(t),s=new se([]);return this.compressCollectionByChordError(i,s,e),s.data}static compressCollectionByChordError(t,e,i){e.clear();const s=t.length;if(1===s)return void e.push(t.getPoint3dAtCheckedPointIndex(0));const n=new $e(t,e,i);let r=0,o=s-1;if(s>2&&t.distanceIndexIndex(0,s-1)<=i){const t=n.indexOfMaxCrossProduct(0,s-1);void 0!==t&&(r=t+1,o=r+s)}n.acceptPointByIndex(r),n.recursiveCompressByChordErrorGo(r,o)}static compressInPlaceByShortEdgeLength(t,e){const i=t.length;if(i<2)return;let s=0,n=i-1;for(;n>0&&t.distanceIndexIndex(n-1,i-1)<e;)n--;if(0===n)return void(t.length=1);n<i-1&&t.moveIndexToIndex(i-1,n);let r=s+1;for(;r<=n;)t.distanceIndexIndex(s,r)>=e&&(t.moveIndexToIndex(r,s+1),s++),r++;t.length=s+1}static compressInPlaceBySmallTriangleArea(t,e){const i=t.length;if(i<3)return;let s=0;const n=$.create();for(let r=1;r+1<i;r++)t.crossProductIndexIndexIndex(s,r,r+1,n),.5*n.magnitude()>e&&t.moveIndexToIndex(r,++s);t.moveIndexToIndex(i-1,++s),t.length=s+1}static compressInPlaceByPerpendicularDistance(t,e,i=1.0001){const s=t.length;if(s<3)return;let n=0;const r=$e._vector01,o=$e._vectorQ;let a;const c=e*e;let h,l=1;for(;l+1<s;l++){t.vectorIndexIndex(n,l+1,r),t.vectorIndexIndex(n,l,o),h=r.magnitudeSquared();const e=K.conditionalDivideFraction(o.dotProduct(r),h);void 0!==e&&e>=0&&e<=i&&(a=$e._vectorQ.magnitudeSquared()-h*e*e,a<=c)?(t.moveIndexToIndex(l+1,++n),l+=1):t.moveIndexToIndex(l,++n)}l<s&&t.moveIndexToIndex(l,++n),t.length=n+1}static compressColinearWrapInPlace(t,e){const i=t.length-1;if(i>=3&&t[0].distance(t[i])<e){const s=i-1,n=0,r=1,o=$.createStartEnd(t[s],t[r]),a=$.createStartEnd(t[s],t[n]),c=o.dotProduct(o),h=o.dotProduct(a),l=K.conditionalDivideFraction(h,c);if(void 0!==l&&l>0&&l<1){const i=a.magnitudeSquared()-l*l*c;Math.sqrt(Math.abs(i))<e&&(t[0]=t[s],t.pop())}}}}$e._vector01=$.create(),$e._vectorQ=$.create();class ti{get quantitySum(){return this.sums.atIJ(3,3)}signFactor(t){return t*this.quantitySum>0?1:-1}setOriginIfNeeded(t){this.needOrigin&&(this.origin.setFromPoint3d(t),this.needOrigin=!1)}setOriginFromGrowableXYZArrayIfNeeded(t){this.needOrigin&&t.length>0&&(t.getPoint3dAtCheckedPointIndex(0,this.origin),this.needOrigin=!1)}setOriginXYZIfNeeded(t,e,i){this.needOrigin&&(this.origin.set(t,e,i),this.needOrigin=!1)}constructor(){this._point0=Q.create(),this._point1=Q.create(),this.origin=Q.createZero(),this.sums=zt.createZero(),this.localToWorldMap=pt.createIdentity(),this.radiusOfGyration=$.create(),this.needOrigin=!1,this.absoluteQuantity=.1,this.absoluteQuantity=void 0}static create(t,e=!1){const i=new ti;return i.needOrigin=e,t&&(i.origin.setFromPoint3d(t),i.needOrigin=!1),i}static momentTensorFromInertiaProducts(t){const e=t.sumDiagonal(),i=xt.createScale(e,e,e);return i.addScaledInPlace(t,-1),i}static sortColumnsForIncreasingMoments(t,e){const i=[t.indexedColumnWithWeight(0,e.x),t.indexedColumnWithWeight(1,e.y),t.indexedColumnWithWeight(2,e.z)].sort(((t,e)=>t.w<e.w?-1:t.w>e.w?1:0));t.setColumnsPoint4dXYZ(i[0],i[1],i[2]),t.determinant()<0&&t.scaleColumnsInPlace(-1,-1,-1),t.at(0,0)<0&&t.scaleColumnsInPlace(-1,-1,1),t.at(2,2)<0&&t.scaleColumnsInPlace(1,-1,-1),e.set(i[0].w,i[1].w,i[2].w)}static pointsToPrincipalAxes(t){const e=new ti;return 0===t.length?e:(e.clearSums(t[0]),e.accumulatePointMomentsFromOrigin(t),this.inertiaProductsToPrincipalAxes(e.origin,e.sums))}static inertiaProductsToPrincipalAxes(t,e){const i=new ti;if(i.sums.setFrom(e),i.origin.setFrom(t),!i.shiftOriginAndSumsToCentroidOfSums())return;const s=i.sums.matrixPart(),n=i.sums.weight();n<0&&s.scaleColumnsInPlace(-1,-1,-1);const r=ti.momentTensorFromInertiaProducts(s),o=$.create(),a=xt.createZero();return r.fastSymmetricEigenvalues(a,o),o.x<0?void 0:(ti.sortColumnsForIncreasingMoments(a,o),n<0&&a.scaleColumnsInPlace(1,-1,-1),i.localToWorldMap=pt.createOriginAndMatrix(i.origin,a),i.radiusOfGyration.set(Math.sqrt(Math.abs(o.x)),Math.sqrt(Math.abs(o.y)),Math.sqrt(Math.abs(o.z))),i.radiusOfGyration.scaleInPlace(1/Math.sqrt(Math.abs(n))),i.absoluteQuantity=Math.abs(n),i)}static areEquivalentPrincipalAxes(t,e){if(t&&e&&K.isSameCoordinate(t.quantitySum,e.quantitySum)&&t.localToWorldMap.getOrigin().isAlmostEqual(e.localToWorldMap.getOrigin())&&t.radiusOfGyration.isAlmostEqual(e.radiusOfGyration)){if(K.isSameCoordinate(t.radiusOfGyration.x,t.radiusOfGyration.y)){if(K.isSameCoordinate(t.radiusOfGyration.x,t.radiusOfGyration.z))return!0;const i=t.localToWorldMap.matrix.columnZ(),s=e.localToWorldMap.matrix.columnZ();return!!i.isParallelTo(s,!0)}const i=$.create(),s=$.create();for(let n=0;n<3;n++)if(t.localToWorldMap.matrix.getColumn(n,i),e.localToWorldMap.matrix.getColumn(n,s),!i.isParallelTo(s,!0))return!1;return!0}return!1}clearSums(t){this.sums.setZero(),t?this.origin.setFrom(t):this.origin.setZero()}accumulatePointMomentsFromOrigin(t){for(const e of t)this.sums.addMomentsInPlace(e.x-this.origin.x,e.y-this.origin.y,e.z-this.origin.z,1)}shiftOriginAndSumsToCentroidOfSums(){const t=this.sums.columnW().realPoint();return!!t&&(this.shiftOriginAndSumsByXYZ(t.x,t.y,t.z),!0)}shiftOriginAndSumsByXYZ(t,e,i){this.origin.addXYZInPlace(t,e,i),this.sums.multiplyTranslationSandwichInPlace(-t,-e,-i)}shiftOriginAndSumsToNewOrigin(t){this.shiftOriginAndSumsByXYZ(t.x-this.origin.x,t.y-this.origin.y,t.z-this.origin.z)}accumulateTriangleMomentsXY(t,e,i){this.setOriginXYZIfNeeded(e.x,e.y,0);const s=this.origin.x,n=this.origin.y,r=ti._vectorA=void 0!==t?Rt.create(t.x-s,t.y-n,0,1,ti._vectorA):Rt.create(this.origin.x,this.origin.y,0,1,ti._vectorA),o=ti._vectorB=Rt.create(e.x-s,e.y-n,0,1,ti._vectorB),a=ti._vectorC=Rt.create(i.x-s,i.y-n,0,1,ti._vectorC),c=K.crossProductXYXY(o.x-r.x,o.y-r.y,a.x-r.x,a.y-r.y);if(0!==c){const t=c/12,e=c/24;this.sums.addScaledOuterProductInPlace(r,r,t),this.sums.addScaledOuterProductInPlace(r,o,e),this.sums.addScaledOuterProductInPlace(r,a,e),this.sums.addScaledOuterProductInPlace(o,r,e),this.sums.addScaledOuterProductInPlace(o,o,t),this.sums.addScaledOuterProductInPlace(o,a,e),this.sums.addScaledOuterProductInPlace(a,r,e),this.sums.addScaledOuterProductInPlace(a,o,e),this.sums.addScaledOuterProductInPlace(a,a,t)}}accumulateScaledOuterProduct(t,e){this.setOriginXYZIfNeeded(t.x,t.y,0);const i=ti._vectorA=Rt.create(t.x-this.origin.x,t.y-this.origin.y,t.z-this.origin.z,1,ti._vectorA);this.sums.addScaledOuterProductInPlace(i,i,e)}accumulateLineMomentsXYZ(t,e){this.setOriginXYZIfNeeded(t.x,t.y,t.z);const i=this.origin.x,s=this.origin.y,n=this.origin.z,r=ti._vectorA=Rt.create(t.x-i,t.y-s,t.z-n,1,ti._vectorA),o=ti._vectorB=Rt.create(e.x-i,e.y-s,e.z-n,1,ti._vectorB),a=t.distance(e),c=a/3,h=a/6;this.sums.addScaledOuterProductInPlace(r,r,c),this.sums.addScaledOuterProductInPlace(r,o,h),this.sums.addScaledOuterProductInPlace(o,r,h),this.sums.addScaledOuterProductInPlace(o,o,c)}accumulateTriangleToLineStringMomentsXY(t,e){const i=e.length;if(i>1){e.getPoint3dAtUncheckedPointIndex(0,this._point0);for(let s=1;s<i;s++)e.getPoint3dAtUncheckedPointIndex(s,this._point1),this.accumulateTriangleMomentsXY(t,this._point0,this._point1),this._point0.setFromPoint3d(this._point1)}}accumulateXYProductsInCentroidalFrame(t,e,i,s,n,r,o){const a=zt.createRowValues(t,e,0,0,e,i,0,0,0,0,0,0,0,0,0,s),c=K.crossProductXYXY(r.x,o.x,r.y,o.y),h=zt.createRowValues(r.x,o.x,0,n.x-this.origin.x,r.y,o.y,0,n.y-this.origin.y,0,0,0,0,0,0,0,1),l=h.multiplyMatrixMatrix(a).multiplyMatrixMatrixTranspose(h);this.sums.addScaledInPlace(l,c)}accumulateProducts(t,e){this.setOriginIfNeeded(t.origin),this.sums.addTranslationSandwichInPlace(t.sums,this.origin.x-t.origin.x,this.origin.y-t.origin.y,this.origin.z-t.origin.z,e)}accumulateProductsFromOrigin(t,e,i){this.setOriginIfNeeded(t),this.sums.addTranslationSandwichInPlace(e,this.origin.x-t.x,this.origin.y-t.y,this.origin.z-t.z,i)}toJSON(){return{origin:this.origin,sums:this.sums.toJSON(),radiusOfGyration:this.radiusOfGyration.toJSON(),localToWorld:this.localToWorldMap.toJSON()}}}class ei extends me{constructor(t,e,i){super(),this._geometry1=i,this._fraction=e}handleLineSegment3d(t){if(this._geometry1 instanceof Pe){const e=this._geometry1;return Pe.create(t.startPoint().interpolate(this._fraction,e.startPoint()),t.endPoint().interpolate(this._fraction,e.endPoint()))}}handleLineString3d(t){if(this._geometry1 instanceof we){const e=this._geometry1;if(t.numPoints()===e.numPoints()){const i=t.numPoints(),s=we.create(),n=Q.create(),r=Q.create(),o=Q.create(),a=this._fraction;for(let c=0;c<i;c++)t.pointAt(c,r),e.pointAt(c,o),r.interpolate(a,o,n),s.addPoint(n);if(t.fractions&&e.fractions)for(let n=0;n<i;n++)s.addFraction(K.interpolate(t.fractions.atUncheckedIndex(n),a,e.fractions.atUncheckedIndex(n)));if(t.strokeData&&e.strokeData&&(s.strokeData=t.strokeData.clone()),t.packedDerivatives&&e.packedDerivatives){const n=$.create(),r=$.create();for(let o=0;o<i;o++)t.packedDerivatives.getVector3dAtCheckedVectorIndex(o,n),e.packedDerivatives.getVector3dAtCheckedVectorIndex(o,r),s.addDerivative(n.interpolate(a,r))}return s}}}handleArc3d(t){if(this._geometry1 instanceof De){const e=this._geometry1;return De.create(t.center.interpolate(this._fraction,e.center),t.vector0.interpolate(this._fraction,e.vector0),t.vector90.interpolate(this._fraction,e.vector90),t.sweep.interpolate(this._fraction,e.sweep))}}static interpolateBetween(t,e,i){const s=new ei(t,e,i);return t.dispatchToGeometryHandler(s)}}class ii{static edgeLengthRange(t){const e=ft.createNull();for(let i=1;i<t.length;i++)e.extendX(t[i-1].distance(t[i]));return e}static compressByChordError(t,e){return $e.compressPoint3dArrayByChordError(t,e)}static compressShortEdges(t,e){const i=nt.create(t);return $e.compressInPlaceByShortEdgeLength(i,e),i.getPoint3dArray()}static compressSmallTriangles(t,e){const i=nt.create(t);return $e.compressInPlaceBySmallTriangleArea(i,e),i.getPoint3dArray()}static compressByPerpendicularDistance(t,e,i=2){const s=nt.create(t);let n=s.length;for(let t=0;t<i;t++){$e.compressInPlaceByPerpendicularDistance(s,e);const t=s.length;if(t===n)break;n=t}return s.getPoint3dArray()}static squaredDistanceToInterpolatedPoint(t,e,i,s){const n=1-i,r=t.x-(n*e.x+i*s.x),o=t.y-(n*e.y+i*s.y),a=t.z-(n*e.z+i*s.z);return r*r+o*o+a*a}static isDanglerConfiguration(t,e,i,s,n){if(e<0||e>=t.length)return!1;const r=t[e],o=r.distanceSquared(s);if(o<=n)return!0;if(i<0||i>=t.length)return!1;const a=t[i],c=r.dotVectorsToTargets(a,s);if(c<=0)return!1;const h=r.distanceSquared(a);let l;if(o>=h){const t=c/o;l=this.squaredDistanceToInterpolatedPoint(a,r,t,s)}else{const t=c/h;l=this.squaredDistanceToInterpolatedPoint(s,r,t,a)}return l<n}static compressDanglers(t,e=!1,i=K.smallMetricDistance){let s=t.length;const n=i*i;if(e)for(;s>1&&t[s-1].distanceSquared(t[0])<=n;)s--;const r=[];r.push(t[0].clone());for(let e=1;e<s;e++){const i=t[e];for(;this.isDanglerConfiguration(r,r.length-1,r.length-2,i,n);)r.pop();r.push(i.clone())}if(e){let t=0,e=r.length-1;for(;e>t+2;)if(this.isDanglerConfiguration(r,t,t+1,r[e],n))t++;else{if(!this.isDanglerConfiguration(r,e,e-1,r[t],n))break;e--}e+1<r.length&&(r.length=e+1),t>0&&r.splice(0,t)}return r}static addClosurePoint(t){if(0===t.length)return;const e=t[0];if(Array.isArray(e)){for(const e of t)Array.isArray(e)&&this.addClosurePoint(e);return}const i=t[t.length-1];e instanceof Q&&i instanceof Q&&!e.isAlmostEqual(i)&&t.push(e.clone())}static removeClosurePoint(t){if(0===t.length)return;const e=t[0];if(Array.isArray(e)){for(const e of t)Array.isArray(e)&&this.removeClosurePoint(e);return}const i=t[t.length-1];e instanceof Q&&i instanceof Q&&e.isAlmostEqual(i)&&t.pop()}static createBisectorPlanesForDistinctPoints(t,e=!1){const i=ii.compressShortEdges(t,2*K.smallMetricDistance);if(i.length<2)return;const s=[],n=i[0],r=i[1],o=$.createNormalizedStartEnd(n,r),a=yt.create(n,o),c=yt.createXYPlane();s.push(a.clone());for(let t=1;t+1<i.length;t++)if($.createNormalizedStartEnd(i[t],i[t+1],o),void 0!==yt.create(i[t],o,c)){const e=a.getNormalRef().interpolate(.5,c.getNormalRef()),n=yt.create(i[t],e);void 0!==n&&s.push(n),a.setFrom(c)}s.push(yt.create(i[i.length-1],a.getNormalRef()));const h=s.length-1;if(h>0&&e){const t=s[0],e=s[h];if(K.isSamePoint3d(t.getOriginRef(),e.getOriginRef())){const i=t.getNormalRef().plus(e.getNormalRef()),n=yt.create(t.getOriginRef(),i);void 0!==n&&(s[0]=n,s[h]=yt.create(e.getOriginRef(),i))}}return s.length>1?s:void 0}}class si extends Nt{constructor(t){super(),this.geometryCategory="solid",this._capped=t}get capped(){return this._capped}set capped(t){this._capped=t}}class ni extends si{constructor(t,e,i,s){super(s),this.solidPrimitiveType="cone",this._localToWorld=t,this._radiusA=e,this._radiusB=i,this._maxRadius=Math.max(this._radiusA,this._radiusB)}clone(){return new ni(this._localToWorld.clone(),this._radiusA,this._radiusB,this.capped)}getConstructiveFrame(){return this._localToWorld.cloneRigid()}tryTransformInPlace(t){return!t.matrix.isSingular()&&(t.multiplyTransformTransform(this._localToWorld,this._localToWorld),!0)}cloneTransformed(t){const e=this.clone();return t.multiplyTransformTransform(e._localToWorld,e._localToWorld),e}static createAxisPoints(t,e,i,s,n){const r=t.vectorTo(e),o=r.magnitude();if(K.isSmallMetricDistance(o))return;if((i=K.correctSmallMetricDistance(i))*(s=K.correctSmallMetricDistance(s))<0)return;if(i+s===0)return;const a=xt.createRigidHeadsUp(r);a.scaleColumns(1,1,o,a);const c=pt.createOriginAndMatrix(t,a);return new ni(c,i,s,n)}static createBaseAndTarget(t,e,i,s,n,r,o){n=Math.abs(K.correctSmallMetricDistance(n)),r=Math.abs(K.correctSmallMetricDistance(r));const a=t.vectorTo(e),c=pt.createOriginAndMatrixColumns(t,i,s,a);return new ni(c,n,r,o)}getCenterA(){return this._localToWorld.multiplyXYZ(0,0,0)}getCenterB(){return this._localToWorld.multiplyXYZ(0,0,1)}getVectorX(){return this._localToWorld.matrix.columnX()}getVectorY(){return this._localToWorld.matrix.columnY()}getRadiusA(){return this._radiusA}getRadiusB(){return this._radiusB}getMaxRadius(){return this._maxRadius}vFractionToRadius(t){return K.interpolate(this._radiusA,t,this._radiusB)}isSameGeometryClass(t){return t instanceof ni}isAlmostEqual(t){return t instanceof ni&&this.capped===t.capped&&!!this._localToWorld.isAlmostEqualAllowZRotation(t._localToWorld)&&K.isSameCoordinate(this._radiusA,t._radiusA)&&K.isSameCoordinate(this._radiusB,t._radiusB)}dispatchToGeometryHandler(t){return t.handleCone(this)}strokeConstantVSection(t,e,i){let s=16;void 0!==e?s=e:void 0!==i&&(s=i.defaultCircleStrokes),s=K.clampToStartEnd(s,4,64);const n=this.vFractionToRadius(t),r=we.createForStrokes(e,i),o=2*Math.PI,a=o/s;let c=0;const h=r.fractions,l=r.packedDerivatives,d=r.packedUVParams,u=r.packedSurfaceNormals,f=Q.create(),g=$.create(),p=$.create(),m=$.create(),x=this._localToWorld;let y,_,v,P;for(let e=0;e<=s;e++)c=2*e<=s?e*a:(e-s)*a,v=Math.cos(c),P=Math.sin(c),y=n*v,_=n*P,x.multiplyXYZ(y,_,t,f),r.addPoint(f),h&&h.push(e/s),l&&(x.matrix.multiplyXYZ(-_*o,y*o,0,g),l.push(g)),u&&(x.matrix.multiplyXYZ(-P,v,0,g),x.matrix.multiplyXYZ(0,0,1,p),g.unitCrossProduct(p,m),u.push(m)),d&&d.pushXY(e/s,t);return r}constantVSection(t){const e=this.vFractionToRadius(t),i=this._localToWorld,s=i.multiplyXYZ(0,0,t),n=i.matrix.multiplyXYZ(e,0,0),r=i.matrix.multiplyXYZ(0,e,0);return Ke.create(De.create(s,n,r))}extendRange(t,e){const i=this.constantVSection(0),s=this.constantVSection(1);i.extendRange(t,e),s.extendRange(t,e)}uvFractionToPoint(t,e,i){const s=t*Math.PI*2,n=K.interpolate(this._radiusA,e,this._radiusB),r=Math.cos(s),o=Math.sin(s);return this._localToWorld.multiplyXYZ(n*r,n*o,e,i)}uvFractionToPointAndTangents(t,e,i){const s=t*Math.PI*2,n=K.interpolate(this._radiusA,e,this._radiusB),r=this._radiusB-this._radiusA,o=Math.cos(s),a=Math.sin(s),c=2*Math.PI;return Et.createOriginAndVectors(this._localToWorld.multiplyXYZ(n*o,n*a,e),this._localToWorld.multiplyVectorXYZ(-n*a*c,n*o*c,0),this._localToWorld.multiplyVectorXYZ(r*o,r*a,1),i)}get isClosedVolume(){return this.capped}maxIsoParametricDistance(){const t=this._localToWorld.matrix.columnX(),e=this._localToWorld.matrix.columnY(),i=this._localToWorld.matrix.columnZ(),s=t.unitCrossProduct(e),n=s.dotProduct(i),r=i.plusScaled(s,n).magnitudeXY();return J.create(2*Math.PI*Math.max(this._radiusA,this._radiusB),K.hypotenuseXY(Math.abs(this._radiusB-this._radiusA)+r,n))}}class ri{constructor(t,e=8,i){this._data=new Float64Array(e*t),this._inUse=0,this._blockSize=t>0?t:1,this._growthFactor=void 0!==i&&i>=1?i:1.5}copyData(t,e,i){let s=void 0!==i?i*this.numPerBlock:0;if(s<0&&(s=0),s>=this._data.length)return{count:0,offset:0};let n=void 0!==e?e*this.numPerBlock:t.length;return n>0&&(n>t.length&&(n=t.length),s+n>this._data.length&&(n=this._data.length-s),n%this.numPerBlock!=0&&(n-=n%this.numPerBlock)),n<=0?{count:0,offset:0}:(n===t.length?this._data.set(t,s):t instanceof Float64Array?this._data.set(t.subarray(0,n),s):this._data.set(t.slice(0,n),s),{count:n/this.numPerBlock,offset:s/this.numPerBlock})}clone(){const t=new ri(this.numPerBlock,this.numBlocks,this._growthFactor);return t.copyData(this._data,this.numBlocks),t._inUse=this.numBlocks,t}get length(){return this._inUse}get numBlocks(){return this._inUse}get numPerBlock(){return this._blockSize}getWithinBlock(t,e){return this._data[t*this._blockSize+e]}clear(){this._inUse=0}blockCapacity(){return this._data.length/this._blockSize}ensureBlockCapacity(t,e=!0){if(t>this.blockCapacity()){e&&(t*=this._growthFactor);const i=this._data;this._data=new Float64Array(t*this._blockSize),this.copyData(i,this._inUse)}}addBlock(t){const e=this.newBlockIndex();let i=t.length;i>this._blockSize&&(i=this._blockSize);for(let s=0;s<i;s++)this._data[e+s]=t[s]}newBlockIndex(){const t=this._blockSize*this._inUse;t+1>this._data.length&&this.ensureBlockCapacity(1+this._inUse),this._inUse++;for(let e=t;e<t+this._blockSize;e++)this._data[e]=0;return t}popBlock(){this._inUse>0&&this._inUse--}blockIndexToDoubleIndex(t){return this._blockSize*t}checkedComponent(t,e){if(!(t>=this._inUse||t<0||e<0||e>=this._blockSize))return this._data[this._blockSize*t+e]}component(t,e){return this._data[this._blockSize*t+e]}static compareLexicalBlock(t,e,i,s){let n=0,r=0;for(let o=0;o<e;o++){if(n=t[i+o],r=t[s+o],n>r)return 1;if(n<r)return-1}return i-s}sortIndicesLexical(t=((t,e,i,s)=>ri.compareLexicalBlock(t,e,i,s))){const e=this._inUse,i=new Uint32Array(e),s=this._data,n=this._blockSize;for(let t=0;t<e;t++)i[t]=t;return i.sort(((e,i)=>t(s,n,e*n,i*n))),i}distanceBetweenBlocks(t,e){let i=0,s=this.blockIndexToDoubleIndex(t),n=this.blockIndexToDoubleIndex(e),r=0;const o=this._data;for(let t=0;t<this._blockSize;t++)r=o[s++]-o[n++],i+=r*r;return Math.sqrt(i)}distanceBetweenSubBlocks(t,e,i,s){let n=0;const r=this.blockIndexToDoubleIndex(t),o=this.blockIndexToDoubleIndex(e);let a=0;const c=this._data;for(let t=i;t<s;t++)a=c[r+t]-c[o+t],n+=a*a;return Math.sqrt(n)}}class oi extends ri{static sortVectorComponent(t){let e=1;for(let i=1;i<t;i++)e*=oi._vectorFactor;return e}constructor(t,e,i){super(1+t+e,i),this._numExtraDataPerPoint=e,this._numCoordinatePerPoint=t}addBlock(t){const e=this.newBlockIndex()+1,i=Math.min(this.numPerBlock-1,t.length);for(let s=0;s<i;s++)this._data[e+s]=t[s]}addDirect(t,e,i,s,n){const r=this.newBlockIndex();this._data[r+1]=t,void 0!==e&&(this._data[r+2]=e),void 0!==i&&(this._data[r+3]=i),void 0!==s&&(this._data[r+4]=s),void 0!==n&&(this._data[r+5]=n)}addPoint2d(t,e,i,s){const n=this.newBlockIndex();this._data[n+1]=t.x,this._data[n+2]=t.y,void 0!==e&&(this._data[n+3]=e),void 0!==i&&(this._data[n+4]=i),void 0!==s&&(this._data[n+5]=s)}addPoint3d(t,e,i,s){const n=this.newBlockIndex();this._data[n+1]=t.x,this._data[n+2]=t.y,this._data[n+3]=t.z,void 0!==e&&(this._data[n+4]=e),void 0!==i&&(this._data[n+5]=i),void 0!==s&&(this._data[n+6]=s)}getPoint2d(t,e){const i=this.blockIndexToDoubleIndex(t);return H.create(this._data[i+1],this._data[i+2],e)}getPoint3d(t,e){const i=this.blockIndexToDoubleIndex(t);return Q.create(this._data[i+1],this._data[i+2],this._data[i+3],e)}getExtraData(t,e){const i=this.blockIndexToDoubleIndex(t);return this._data[i+1+this._numCoordinatePerPoint+e]}getData(t,e){const i=this.blockIndexToDoubleIndex(t);return this._data[i+e]}setExtraData(t,e,i){const s=this.blockIndexToDoubleIndex(t);this._data[s+1+this._numCoordinatePerPoint+e]=i}static isClusterTerminator(t){return t===oi.clusterTerminator}clusterIndicesLexical(t=K.smallMetricDistance){this.setupPrimaryClusterSort();const e=this.sortIndicesLexical(),i=new Uint32Array(2*e.length);let s=0;const n=this.numBlocks;let r=0,o=0,a=0,c=0,h=0;const l=1+this._numCoordinatePerPoint;for(c=0;c<n;c++)if(r=e[c],!oi.isClusterTerminator(r)){for(i[s++]=r,a=this.component(r,0)+t,e[c]=oi.clusterTerminator,h=c+1;h<n;h++)if(o=e[h],o!==oi.clusterTerminator){if(this.component(o,0)>=a)break;this.distanceBetweenSubBlocks(r,o,1,l)<t&&(i[s++]=o,e[h]=oi.clusterTerminator)}i[s++]=oi.clusterTerminator}return i.slice(0,s)}setupPrimaryClusterSort(){const t=this.numBlocks,e=this._numCoordinatePerPoint,i=new Float64Array(e);i[0]=1;for(let t=1;t<e;t++)i[t]=i[t-1]*oi._vectorFactor;let s=0,n=0;const r=this._data;for(let o=0;o<t;o++){s=this.blockIndexToDoubleIndex(o),n=0;for(let t=0;t<e;t++)n+=i[t]*r[s+1+t];r[s]=n}}toJSON(){const t=[];for(let e=0;e<this.numBlocks;e++){let i=this.blockIndexToDoubleIndex(e);const s=[e,this._data[i++]],n=[];for(let t=0;t<this._numCoordinatePerPoint;t++)n.push(this._data[i++]);s.push(n);for(let t=0;t<this._numExtraDataPerPoint;t++)s.push(this._data[i++]);t.push(s)}return t}createIndexBlockToClusterIndex(t){const e=this.numBlocks,i=new Uint32Array(e);i.fill(oi.clusterTerminator);let s=0;for(const n of t)n>=e?s++:i[n]=s;return i}createIndexBlockToClusterStart(t){const e=t.length,i=this.numBlocks,s=new Uint32Array(i),n=oi.clusterTerminator;s.fill(n);let r=0;for(let n=0;n<e;n++){const e=t[n];e>i?r=n+1:s[e]=r}return s}countClusters(t){let e=0;const i=oi.clusterTerminator;for(const s of t)s===i&&e++;return e}createIndexClusterToClusterStart(t){let e=this.countClusters(t);const i=new Uint32Array(e),s=oi.clusterTerminator;i.fill(s);const n=t.length;let r=0;for(let o=0;o<n;o++)t[o]===s?r=o+1:o===r&&(i[e++]=r);return i}sortSubsetsBySingleKey(t,e){const i=1+e;let s,n,r,o=0;const a=t.length;for(let e=0;e<a;e++)if(t[e]===oi.clusterTerminator){for(let a=o;a+1<e;a++){n=this.getWithinBlock(t[a],i);for(let o=a+1;o<e;o++)r=this.getWithinBlock(t[o],i),r<n&&(s=t[a],t[a]=t[o],t[o]=s,n=r)}o=e+1}}static clusterPoint3dArray(t,e=K.smallMetricDistance){const i=new oi(3,0,t.length);t.forEach((t=>{i.addDirect(t.x,t.y,t.z)}));const s=i.clusterIndicesLexical(e),n=new ci(t.length);let r=0,o=0;return s.forEach((e=>{oi.isClusterTerminator(e)?(r++,o=0):(0===o&&n.packedPoints.push(t[e].clone()),n.oldToNew[e]=r,o++)})),n}static clusterNumberArray(t,e=K.smallMetricDistance){const i=new oi(1,0,t.length);t.forEach((t=>{i.addDirect(t)}));const s=i.clusterIndicesLexical(e),n=new li(t.length);let r=0,o=0;return s.forEach((e=>{oi.isClusterTerminator(e)?(r++,o=0):(0===o&&n.packedNumbers.push(t[e]),n.oldToNew[e]=r,o++)})),n}static clusterGrowablePoint2dArray(t,e=K.smallMetricDistance){const i=new oi(2,0,t.length),s=H.create(),n=t.length;for(let e=0;e<n;e++)t.getPoint2dAtUncheckedPointIndex(e,s),i.addDirect(s.x,s.y);const r=i.clusterIndicesLexical(e),o=i.countClusters(r),a=new hi(t.length,o);let c=0,h=0;return r.forEach((e=>{oi.isClusterTerminator(e)?(c++,h=0):(0===h&&a.growablePackedPoints.pushFromGrowableXYArray(t,e),a.oldToNew[e]=c,h++)})),a}static clusterGrowablePoint3dArray(t,e=K.smallMetricDistance){const i=new oi(3,0,t.length),s=Q.create(),n=t.length;for(let e=0;e<n;e++)t.getPoint3dAtUncheckedPointIndex(e,s),i.addDirect(s.x,s.y,s.z);const r=i.clusterIndicesLexical(e),o=new ci(t.length),a=i.countClusters(r);o.growablePackedPoints=new nt(a);let c=0,h=0;return r.forEach((e=>{oi.isClusterTerminator(e)?(c++,h=0):(0===h&&o.growablePackedPoints.pushFromGrowableXYZArray(t,e),o.oldToNew[e]=c,h++)})),o}}function ai(t,e){let i=0;return t.forEach(((t,s,n)=>{t<e.length?n[s]=e[t]:i++})),0===i}oi._vectorFactor=.8732,oi.clusterTerminator=4294967295;class ci{constructor(t){this.packedPoints=[],this.oldToNew=new Uint32Array(t);for(let e=0;e<t;e++)this.oldToNew[e]=ci.invalidIndex}updateIndices(t){return ai(t,this.oldToNew)}}ci.invalidIndex=4294967295;class hi{constructor(t,e){this.growablePackedPoints=new Ae(e),this.oldToNew=new Uint32Array(t);for(let e=0;e<t;e++)this.oldToNew[e]=hi.invalidIndex}updateIndices(t){return ai(t,this.oldToNew)}}hi.invalidIndex=4294967295;class li{constructor(t){this.packedNumbers=[],this.oldToNew=new Uint32Array(t);for(let e=0;e<t;e++)this.oldToNew[e]=ci.invalidIndex}updateIndices(t){return ai(t,this.oldToNew)}}li.invalidIndex=4294967295,function(t){t[t.Scalar=0]="Scalar",t[t.Distance=1]="Distance",t[t.Vector=2]="Vector",t[t.Normal=3]="Normal"}(T||(T={}));class di{constructor(t,e){if(this.input=t,e instanceof Float64Array){this.values=[];for(const t of e)this.values.push(t)}else this.values=e}copyValues(t,e,i,s){for(let n=0;n<s;n++)this.values[e*s+n]=t.values[i*s+n]}clone(){return new di(this.input,this.values.slice())}isAlmostEqual(t,e){const i=e||1e-8;return Math.abs(this.input-t.input)<i&&re.isAlmostEqual(this.values,t.values,i)}}class ui{constructor(t,e,i,s){this.data=t,this.dataType=e,this.name=i,this.inputName=s}clone(){const t=[];for(const e of this.data)t.push(e.clone());return new ui(t,this.dataType,this.name,this.inputName)}isAlmostEqual(t,e){if(this.dataType!==t.dataType||this.name!==t.name||this.inputName!==t.inputName||this.data.length!==t.data.length)return!1;for(let i=0;i<this.data.length;i++)if(!this.data[i].isAlmostEqual(t.data[i],e))return!1;return!0}get isScalar(){return this.dataType===T.Distance||this.dataType===T.Scalar}get entriesPerValue(){return this.isScalar?1:3}get valueCount(){return 0===this.data.length?0:this.data[0].values.length/this.entriesPerValue}get scalarRange(){if(!this.isScalar)return;const t=ft.createNull();for(const e of this.data)t.extendArray(e.values);return t}computeDisplacementRange(t=1,e){if(e=ut.createNull(e),T.Vector===this.dataType)for(const i of this.data){const s=i.values;for(let i=0;i<s.length;i+=3)e.extendXYZ(s[i]*t,s[i+1]*t,s[i+2]*t)}return e}}class fi{constructor(t,e){this.channels=t,this.indices=e}clone(){const t=this.channels.map((t=>t.clone()));return new fi(t,this.indices.slice())}isAlmostEqual(t,e){if(!re.isExactEqual(this.indices,t.indices)||this.channels.length!==t.channels.length)return!1;for(let i=0;i<this.channels.length;i++)if(!this.channels[i].isAlmostEqual(t.channels[i],e))return!1;return!0}static isAlmostEqual(t,e,i){return t===e||!(!t||!e)&&t.isAlmostEqual(e,i)}createForVisitor(){const t=[];for(const e of this.channels){const i=[];for(const t of e.data)i.push(new di(t.input,[]));t.push(new ui(i,e.dataType,e.name,e.inputName))}return new fi(t,[])}tryTransformInPlace(t){let e;const i=t.matrix,s=i.determinant(),n=Math.pow(Math.abs(s),1/3)*(s>=0?1:-1);for(const t of this.channels)for(const s of t.data)switch(t.dataType){case T.Scalar:continue;case T.Distance:for(let t=0;t<s.values.length;t++)s.values[t]*=n;break;case T.Normal:if(e=e??i.inverse(),!e)return!1;gi(s.values,(t=>e.multiplyTransposeVectorInPlace(t)));break;case T.Vector:gi(s.values,(t=>i.multiplyVectorInPlace(t)))}return!0}}function gi(t,e){const i=new Q;for(let s=0;s<t.length;s+=3)i.set(t[s],t[s+1],t[s+2]),e(i),t[s]=i.x,t[s+1]=i.y,t[s+2]=i.z}!function(t){let e,i,s;!function(t){t[t.SubdivisionSurface=-1e3]="SubdivisionSurface"}(e=t.TaggedNumericTagType||(t.TaggedNumericTagType={})),function(t){t[t.ChooseBasedOnFacets=0]="ChooseBasedOnFacets",t[t.CatmullClark=1]="CatmullClark",t[t.Loop=2]="Loop",t[t.DooSabin=3]="DooSabin"}(i=t.SubdivisionMethod||(t.SubdivisionMethod={})),function(t){t[t.FixedDepth=-100]="FixedDepth",t[t.AbsoluteTolerance=-101]="AbsoluteTolerance",t[t.FractionOfRangeBoxTolerance=-102]="FractionOfRangeBoxTolerance"}(s=t.SubdivisionControlCode||(t.SubdivisionControlCode={}))}(k||(k={}));class pi{constructor(t=0,e=0,i,s){this.tagA=t,this.tagB=e,i&&(this.intData=i),s&&(this.doubleData=s)}pushIntPair(t,e){this.intData||(this.intData=[]),this.intData.push(t),this.intData.push(e)}pushIndexedDouble(t,e){this.intData||(this.intData=[]),this.doubleData||(this.doubleData=[]),this.intData.push(t),this.intData.push(this.doubleData.length),this.doubleData.push(e)}tagToInt(t,e,i,s){if(this.intData)for(let s=0;s+1<this.intData.length;s+=2)if(this.intData[s]===t)return Math.min(Math.max(this.intData[s+1],e),i);return s}tagToIndexedDouble(t,e,i,s){if(this.intData)for(let n=0;n+1<this.intData.length;n+=2)if(this.intData[n]===t)return K.clamp(this.getDoubleData(this.intData[n+1],s),e,i);return s}getDoubleData(t,e){return this.doubleData&&0<=t&&t<this.doubleData.length?this.doubleData[t]:e}isAlmostEqual(t){return void 0!==t&&this.tagA===t.tagA&&this.tagB===t.tagB&&K.exactEqualNumberArrays(this.intData,t.intData)&&K.almostEqualArrays(this.doubleData,t.doubleData,((t,e)=>K.isAlmostEqualNumber(t,e)))}static areAlmostEqual(t,e){return void 0===t&&void 0===e||void 0!==t&&void 0!==e&&t.isAlmostEqual(e)}clone(t){return t||(t=new pi(this.tagA,this.tagB)),this.intData&&(t.intData=this.intData.slice()),this.doubleData&&(t.doubleData=this.doubleData.slice()),t}}class mi{get twoSided(){return this._twoSided}set twoSided(t){this._twoSided=t}setTaggedNumericData(t){this.taggedNumericData=t}get expectedClosure(){return this._expectedClosure}set expectedClosure(t){this._expectedClosure=t}constructor(t=!1,e=!1,i=!1,s=!1){this.face=[],this.point=new nt,this.pointIndex=[],this.edgeVisible=[],t&&(this.normal=new nt,this.normalIndex=[]),e&&(this.param=new Ae,this.paramIndex=[]),i&&(this.color=[],this.colorIndex=[]),this._twoSided=s,this._expectedClosure=0}clone(){const t=new mi;return t.point=this.point.clone(),t.pointIndex=this.pointIndex.slice(),t.edgeVisible=this.edgeVisible.slice(),t.face=this.face.slice(),t.twoSided=this.twoSided,t.expectedClosure=this.expectedClosure,this.normal&&(t.normal=this.normal.clone()),this.param&&(t.param=this.param.clone()),this.color&&(t.color=this.color.slice()),this.normalIndex&&(t.normalIndex=this.normalIndex.slice()),this.paramIndex&&(t.paramIndex=this.paramIndex.slice()),this.colorIndex&&(t.colorIndex=this.colorIndex.slice()),this.auxData&&(t.auxData=this.auxData.clone()),this.taggedNumericData&&(t.taggedNumericData=this.taggedNumericData.clone()),t}isAlmostEqual(t){return!!(nt.isAlmostEqual(this.point,t.point)&&re.isExactEqual(this.pointIndex,t.pointIndex)&&nt.isAlmostEqual(this.normal,t.normal)&&re.isExactEqual(this.normalIndex,t.normalIndex)&&Ae.isAlmostEqual(this.param,t.param)&&re.isExactEqual(this.paramIndex,t.paramIndex)&&re.isExactEqual(this.color,t.color)&&re.isExactEqual(this.colorIndex,t.colorIndex)&&re.isExactEqual(this.edgeVisible,t.edgeVisible)&&fi.isAlmostEqual(this.auxData,t.auxData)&&this.twoSided===t.twoSided&&this.expectedClosure===t.expectedClosure&&pi.areAlmostEqual(this.taggedNumericData,t.taggedNumericData))}get requireNormals(){return void 0!==this.normal}get pointCount(){return this.point.length}get normalCount(){return this.normal?this.normal.length:0}get paramCount(){return this.param?this.param.length:0}get colorCount(){return this.color?this.color.length:0}get indexCount(){return this.pointIndex.length}get faceCount(){return this.face.length}getPoint(t,e){return this.point.getPoint3dAtCheckedPointIndex(t,e)}getNormal(t){return this.normal?this.normal.getVector3dAtCheckedVectorIndex(t):void 0}getParam(t){return this.param?this.param.getPoint2dAtCheckedPointIndex(t):void 0}getColor(t){return this.color?this.color[t]:0}getEdgeVisible(t){return this.edgeVisible[t]}copyPointTo(t,e){this.point.getPoint3dAtUncheckedPointIndex(t,e)}copyNormalTo(t,e){this.normal&&this.normal.getVector3dAtCheckedVectorIndex(t,e)}copyParamTo(t,e){this.param&&this.param.getPoint2dAtCheckedPointIndex(t,e)}isAlmostEqualParamIndexUV(t,e,i){return void 0!==this.param&&t>=0&&t<this.param.length&&K.isSameCoordinate(e,this.param.getXAtUncheckedPointIndex(t))&&K.isSameCoordinate(i,this.param.getYAtUncheckedPointIndex(t))}gatherIndexedData(t,e,i,s){const n=i-e,r=n+s;this.resizeAllDataArrays(r);for(let i=0;i<n;i++)this.point.transferFromGrowableXYZArray(i,t.point,t.pointIndex[e+i]);for(let t=0;t<s;t++)this.point.transferFromGrowableXYZArray(n+t,this.point,t);for(let i=0;i<n;i++)this.pointIndex[i]=t.pointIndex[e+i];for(let t=0;t<s;t++)this.pointIndex[n+t]=this.pointIndex[t];for(let i=0;i<n;i++)this.edgeVisible[i]=t.edgeVisible[e+i];for(let t=0;t<s;t++)this.edgeVisible[n+t]=this.edgeVisible[t];if(this.normal&&this.normalIndex&&t.normal&&t.normalIndex){for(let i=0;i<n;i++)this.normal.transferFromGrowableXYZArray(i,t.normal,t.normalIndex[e+i]);for(let t=0;t<s;t++)this.normal.transferFromGrowableXYZArray(n+t,this.normal,t);for(let i=0;i<n;i++)this.normalIndex[i]=t.normalIndex[e+i];for(let t=0;t<s;t++)this.normalIndex[n+t]=this.normalIndex[t]}if(this.param&&this.paramIndex&&t.param&&t.paramIndex){for(let i=0;i<n;i++)this.param.transferFromGrowableXYArray(i,t.param,t.paramIndex[e+i]);for(let t=0;t<s;t++)this.param.transferFromGrowableXYArray(n+t,this.param,t);for(let i=0;i<n;i++)this.paramIndex[i]=t.paramIndex[e+i];for(let t=0;t<s;t++)this.paramIndex[n+t]=this.paramIndex[t]}if(this.color&&this.colorIndex&&t.color&&t.colorIndex){for(let i=0;i<n;i++)this.color[i]=t.color[t.colorIndex[e+i]];for(let t=0;t<s;t++)this.color[n+t]=this.color[t];for(let i=0;i<n;i++)this.colorIndex[i]=t.colorIndex[e+i];for(let t=0;t<s;t++)this.colorIndex[n+t]=this.colorIndex[t]}if(this.auxData&&t.auxData&&this.auxData.channels.length===t.auxData.channels.length){for(let i=0;i<this.auxData.channels.length;i++){const r=this.auxData.channels[i],o=t.auxData.channels[i],a=r.entriesPerValue;if(r.data.length===o.data.length)for(let i=0;i<r.data.length;i++){const c=r.data[i],h=o.data[i];for(let i=0;i<n;i++)c.copyValues(h,i,t.auxData.indices[e+i],a);for(let e=0;e<s;e++)c.copyValues(c,t.auxData.indices[n+e],e,a)}}for(let i=0;i<n;i++)this.auxData.indices[i]=t.auxData.indices[e+i];for(let t=0;t<s;t++)this.auxData.indices[n+t]=this.auxData.indices[t]}}static trimArray(t,e){t&&e<t.length&&(t.length=e)}trimAllIndexArrays(t){if(mi.trimArray(this.pointIndex,t),mi.trimArray(this.paramIndex,t),mi.trimArray(this.normalIndex,t),mi.trimArray(this.colorIndex,t),mi.trimArray(this.edgeVisible,t),this.auxData){mi.trimArray(this.auxData.indices,t);for(const e of this.auxData.channels)for(const i of e.data)mi.trimArray(i.values,e.entriesPerValue*t)}}resizeAllDataArrays(t){if(t>this.point.length){for(;this.point.length<t;)this.point.push(Q.create());for(;this.pointIndex.length<t;)this.pointIndex.push(-1);for(;this.edgeVisible.length<t;)this.edgeVisible.push(!1);if(this.normal)for(;this.normal.length<t;)this.normal.push($.create());if(this.param)for(;this.param.length<t;)this.param.push(H.create());if(this.color)for(;this.color.length<t;)this.color.push(0);if(this.auxData)for(const e of this.auxData.channels)for(const i of e.data)for(;i.values.length<t*e.entriesPerValue;)i.values.push(0)}else if(t<this.point.length&&(this.point.resize(t),this.edgeVisible.length=t,this.pointIndex.length=t,this.normal&&this.normal.resize(t),this.param&&this.param.resize(t),this.color&&(this.color.length=t),this.auxData))for(const e of this.auxData.channels)for(const i of e.data)i.values.length=t*e.entriesPerValue}range(t,e){return(t=t||ut.createNull()).extendArray(this.point,e),t}reverseIndices(t){t&&mi.isValidFacetStartIndexArray(t)&&(mi.reverseIndices(t,this.pointIndex,!0),this.normalIndex!==this.pointIndex&&mi.reverseIndices(t,this.normalIndex,!0),this.paramIndex!==this.pointIndex&&mi.reverseIndices(t,this.paramIndex,!0),this.colorIndex!==this.pointIndex&&mi.reverseIndices(t,this.colorIndex,!0),mi.reverseIndices(t,this.edgeVisible,!1))}reverseIndicesSingleFacet(t,e){mi.reverseIndicesSingleFacet(t,e,this.pointIndex,!0),this.normalIndex!==this.pointIndex&&mi.reverseIndicesSingleFacet(t,e,this.normalIndex,!0),this.paramIndex!==this.pointIndex&&mi.reverseIndicesSingleFacet(t,e,this.paramIndex,!0),this.colorIndex!==this.pointIndex&&mi.reverseIndicesSingleFacet(t,e,this.colorIndex,!0),mi.reverseIndicesSingleFacet(t,e,this.edgeVisible,!1)}reverseNormals(){this.normal&&this.normal.scaleInPlace(-1)}tryTransformInPlace(t){return this.point.multiplyTransformInPlace(t),this.normal&&!t.matrix.isIdentity&&this.normal.multiplyAndRenormalizeMatrix3dInverseTransposeInPlace(t.matrix),void 0===this.auxData||this.auxData.tryTransformInPlace(t)}compress(){const t=oi.clusterGrowablePoint3dArray(this.point);if(this.point=t.growablePackedPoints,t.updateIndices(this.pointIndex),this.normalIndex&&this.normal){const t=oi.clusterGrowablePoint3dArray(this.normal);this.normal=t.growablePackedPoints,t.updateIndices(this.normalIndex)}if(this.paramIndex&&this.param){const t=oi.clusterGrowablePoint2dArray(this.param);this.param=t.growablePackedPoints,t.updateIndices(this.paramIndex)}if(this.colorIndex&&this.color){const t=oi.clusterNumberArray(this.color);this.color=t.packedNumbers,t.updateIndices(this.colorIndex)}}static isValidFacetStartIndexArray(t){if(0===t.length)return!1;for(let e=0;e+1<t.length;e++)if(t[e]>=t[e+1])return!1;return!0}static reverseIndices(t,e,i){if(!e||0===e.length)return!0;if(e.length>0&&t[t.length-1]===e.length){for(let s=0;s+1<t.length;s++){let n=t[s],r=t[s+1];if(i)for(;r>n+2;){r--,n++;const t=e[n];e[n]=e[r],e[r]=t}else for(;r>n+1;){r--;const t=e[n];e[n]=e[r],e[r]=t,n++}}return!0}return!1}static reverseIndicesSingleFacet(t,e,i,s){if(!i||0===i.length)return!0;if(i.length>0&&e[e.length-1]===i.length&&t>=0&&t+1<e.length){let n=e[t],r=e[t+1];if(s)for(;r>n+2;){r--,n++;const t=i[n];i[n]=i[r],i[r]=t}else for(;r>n+1;){r--;const t=i[n];i[n]=i[r],i[r]=t,n++}return!0}return!1}}mi.planarityLocalRelTol=1e-13;class xi extends mi{constructor(t,e){super(t.data.normalCount>0,t.data.paramCount>0,t.data.colorCount>0,t.twoSided),this._polyface=t,this._numWrap=e,t.data.auxData&&(this.auxData=t.data.auxData.createForVisitor()),this.reset(),this._numEdges=0,this._nextFacetIndex=0,this._currentFacetIndex=-1}clientPolyface(){return this._polyface}setNumWrap(t){this._numWrap=t}get numEdgesThisFacet(){return this._numEdges}static create(t,e){return new xi(t,e)}moveToReadIndex(t){return!!this._polyface.isValidFacetIndex(t)&&(this._currentFacetIndex=t,this._nextFacetIndex=t+1,this._numEdges=this._polyface.numEdgeInFacet(t),this.resizeAllDataArrays(this._numEdges+this._numWrap),this.gatherIndexedData(this._polyface.data,this._polyface.facetIndex0(this._currentFacetIndex),this._polyface.facetIndex1(this._currentFacetIndex),this._numWrap),!0)}moveToNextFacet(){return this._nextFacetIndex!==this._currentFacetIndex?this.moveToReadIndex(this._nextFacetIndex):(this._nextFacetIndex++,!0)}reset(){this.moveToReadIndex(0),this._nextFacetIndex=0}tryGetDistanceParameter(t,e){if(t>=this.numEdgesThisFacet)return;if(void 0===this.param||0===this._polyface.data.face.length)return;const i=this._polyface.tryGetFaceData(this._currentFacetIndex);return i?i.convertParamXYToDistance(this.param.getXAtUncheckedPointIndex(t),this.param.getYAtUncheckedPointIndex(t),e):void 0}tryGetNormalizedParameter(t,e){if(t>=this.numEdgesThisFacet)return;if(void 0===this.param||0===this._polyface.data.face.length)return;const i=this._polyface.tryGetFaceData(this._currentFacetIndex);return i?i.convertParamXYToNormalized(this.param.getXAtUncheckedPointIndex(t),this.param.getYAtUncheckedPointIndex(t),e):void 0}currentReadIndex(){return this._currentFacetIndex}clientPointIndex(t){return this.pointIndex[t]}clientParamIndex(t){return this.paramIndex?this.paramIndex[t]:-1}clientNormalIndex(t){return this.normalIndex?this.normalIndex[t]:-1}clientColorIndex(t){return this.colorIndex?this.colorIndex[t]:-1}clientAuxIndex(t){return this.auxData?this.auxData.indices[t]:-1}clearArrays(){void 0!==this.point&&(this.point.length=0),void 0!==this.param&&(this.param.length=0),void 0!==this.normal&&(this.normal.length=0),void 0!==this.color&&(this.color.length=0)}pushDataFrom(t,e){this.point.pushFromGrowableXYZArray(t.point,e),this.color&&t.color&&e<t.color.length&&this.color.push(t.color[e]),this.param&&t.param&&e<t.param.length&&this.param.pushFromGrowableXYArray(t.param,e),this.normal&&t.normal&&e<t.normal.length&&this.normal.pushFromGrowableXYZArray(t.normal,e)}pushInterpolatedDataFrom(t,e,i,s){this.point.pushInterpolatedFromGrowableXYZArray(t.point,e,i,s),this.color&&t.color&&e<t.color.length&&s<t.color.length&&this.color.push(function(t,e,i){return yi(t,e=K.clamp(e,0,1),i,0)|yi(t,e,i,8)|yi(t,e,i,16)|yi(t,e,i,24)}(t.color[e],i,t.color[s])),this.param&&t.param&&e<t.param.length&&s<t.param.length&&this.param.pushInterpolatedFromGrowableXYArray(t.param,e,i,s),this.normal&&t.normal&&e<t.normal.length&&s<t.normal.length&&this.normal.pushInterpolatedFromGrowableXYZArray(t.normal,e,i,s)}}function yi(t,e,i,s){return t=t>>>s&255,i=i>>>s&255,(255&Math.floor(t+e*(i-t)))<<s}class _i extends xi{constructor(t,e,i){super(t,i),this._parentFacetIndices=e.slice(),this._nextActiveIndex=0}static createSubsetVisitor(t,e,i){return new _i(t,e,i)}moveToReadIndex(t){return t>=0&&t<=this._parentFacetIndices.length&&(this._nextActiveIndex=t,super.moveToReadIndex(this._parentFacetIndices[t++]))}moveToNextFacet(){return!!(this._nextActiveIndex<this._parentFacetIndices.length&&this.moveToReadIndex(this._nextActiveIndex))&&(this._nextActiveIndex++,!0)}reset(){this._nextActiveIndex=0}parentFacetIndex(t){if(t>=0&&t<=this._nextActiveIndex)return this._parentFacetIndices[t]}}class vi{get paramDistanceRange(){return this._paramDistanceRange}get paramRange(){return this._paramRange}constructor(t,e){this._paramDistanceRange=t,this._paramRange=e}static createNull(){return new vi(gt.createNull(),gt.createNull())}clone(t){return t?(this._paramDistanceRange.clone(t._paramDistanceRange),this._paramRange.clone(t._paramRange),t):new vi(this._paramDistanceRange.clone(),this._paramRange.clone())}setNull(){this._paramDistanceRange.setNull(),this._paramRange.setNull()}convertParamXYToDistance(t,e,i){i=i||H.create();const s=this._paramRange.high.minus(this._paramRange.low);return i.x=0===s.x?t:this._paramDistanceRange.low.x+(t-this._paramRange.low.x)*(this._paramDistanceRange.high.x-this._paramDistanceRange.low.x)/s.x,i.y=0===s.y?e:this.paramDistanceRange.low.y+(e-this._paramRange.low.y)*(this._paramDistanceRange.high.y-this._paramDistanceRange.low.y)/s.y,i}convertParamXYToNormalized(t,e,i){i=i||H.create();const s=this._paramRange.high.minus(this._paramRange.low);return i.x=0===s.x?t:(t-this._paramRange.low.x)/s.x,i.y=0===s.y?e:(e-this._paramRange.low.y)/s.y,i}convertParamToDistance(t,e){return this.convertParamXYToDistance(t.x,t.y,e)}convertParamToNormalized(t,e){return this.convertParamXYToNormalized(t.x,t.y,e)}scaleDistances(t){this._paramDistanceRange.low.x*=t,this._paramDistanceRange.low.y*=t,this._paramDistanceRange.high.x*=t,this._paramDistanceRange.high.y*=t}setParamDistanceRangeFromNewFaceData(t,e,i){const s=H.create(),n=H.create();this.setNull();let r=0;const o=xi.create(t,0);if(!o.moveToReadIndex(e)||i<=e)return!1;do{const t=o.numEdgesThisFacet,e=o.point,i=[],a=o.param,c=[];if(!a)return!1;a.extendRange(this._paramRange);const h=J.create(),l=J.create();for(let o=0;o<t;o++){if(i[2]=o,c[2]=o,o>1){a.vectorIndexIndex(c[1],c[0],h),a.vectorIndexIndex(c[1],c[2],l);const t=e.getPoint3dAtUncheckedPointIndex(i[0]).minus(e.getPoint3dAtUncheckedPointIndex(i[1])),o=e.getPoint3dAtUncheckedPointIndex(i[1]).minus(e.getPoint3dAtUncheckedPointIndex(i[2])),d=Math.abs(h.x*l.y-l.x*h.y);if(d){const e=Q.createFrom(t);e.scaleInPlace(l.y),e.addScaledInPlace(o,-h.y);const i=Q.createFrom(o);i.scaleInPlace(h.x),i.addScaledInPlace(t,-l.x);const a=H.create(e.magnitude()/d,i.magnitude()/d);s.x+=a.x,s.y+=a.y,n.x+=a.x*a.x,n.y+=a.y*a.y,r++}}c[0]=c[1],c[1]=c[2],i[0]=i[1],i[1]=i[2]}}while(o.moveToNextFacet()&&o.currentReadIndex()<i);if(0!==r){const t=H.create(s.x/r,s.y/r),e=H.create(Math.sqrt(Math.abs(n.x/r-t.x*t.x)),Math.sqrt(Math.abs(n.y/r-t.y*t.y)));this._paramDistanceRange.low.set(0,0),this._paramDistanceRange.high.set((t.x+e.x)*(this._paramRange.high.x-this._paramRange.low.x),(t.y+e.y)*(this._paramRange.high.y-this._paramRange.low.y))}return!0}}class Pi extends Nt{constructor(t){super(),this.geometryCategory="polyface",this.data=t}get twoSided(){return this.data.twoSided}set twoSided(t){this.data.twoSided=t}get expectedClosure(){return this.data.expectedClosure}set expectedClosure(t){this.data.expectedClosure=t}static areIndicesValid(t,e,i,s,n){if(void 0===t&&void 0===s)return!0;if(!t||!s)return!1;if(e<0||e>=t.length)return!1;if(i<e||i>t.length)return!1;for(let s=e;s<i;s++)if(t[s]<0||t[s]>=n)return!1;return!0}get facetCount(){}}class Ii extends Pi{isSameGeometryClass(t){return t instanceof Ii}isAlmostEqual(t){return t instanceof Ii&&this.data.isAlmostEqual(t.data)&&re.isExactEqual(this._facetStart,t._facetStart)&&re.isExactEqual(this._facetToFaceData,t._facetToFaceData)}get isEmpty(){return 0===this.data.pointCount||0===this.data.pointIndex.length}tryTransformInPlace(t){return!!this.data.tryTransformInPlace(t)&&(t.matrix.determinant()<0&&(this.reverseIndices(),this.reverseNormals()),!0)}reverseSingleFacet(t){this.data.reverseIndicesSingleFacet(t,this._facetStart)}clone(){return new Ii(this.data.clone(),this._facetStart.slice(),this._facetToFaceData.slice())}cloneTransformed(t){const e=this.clone();return e.tryTransformInPlace(t),e}reverseIndices(){this.data.reverseIndices(this._facetStart)}reverseNormals(){this.data.reverseNormals()}tryGetFaceData(t){const e=this._facetToFaceData[t];if(!(e>=this.data.face.length))return this.data.face[e]}constructor(t,e,i){super(t),e?this._facetStart=e.slice():(this._facetStart=[],this._facetStart.push(0)),this._facetToFaceData=i?i.slice():[]}addIndexedPolyface(t,e,i){const s=t.facetCount,n=this.data.point.length,r=Q.create();for(let e=0;e<t.data.point.length;e++)t.data.point.getPoint3dAtUncheckedPointIndex(e,r),i?(i.multiplyPoint3d(r,r),this.addPoint(r)):this.addPoint(r);for(let i=0;i<s;i++){const s=t._facetStart[i],r=t._facetStart[i+1];if(e)for(let e=r;e-- >s;)this.addPointIndex(n+t.data.pointIndex[e],t.data.edgeVisible[e>s?e-1:r-1]);else for(let e=s;e<r;e++)this.addPointIndex(n+t.data.pointIndex[e],t.data.edgeVisible[e]);this.terminateFacet(!1)}if(void 0!==this.data.param&&void 0!==t.data.param&&void 0!==t.data.paramIndex){const i=this.data.param.length;this.data.param.pushFromGrowableXYArray(t.data.param);for(let n=0;n<s;n++){const s=t._facetStart[n],r=t._facetStart[n+1];if(e)for(let e=r;e-- >s;)this.addParamIndex(i+t.data.paramIndex[e]);else for(let e=s;e<r;e++)this.addParamIndex(i+t.data.paramIndex[e])}}if(void 0!==this.data.normal&&void 0!==t.data.normal&&void 0!==t.data.normalIndex){const n=this.data.normal.length;for(let s=0;s<t.data.normal.length;s++){const n=t.data.normal.getVector3dAtCheckedVectorIndex(s);i&&i.multiplyVector(n,n),e&&n.scaleInPlace(-1),this.addNormal(n)}for(let i=0;i<s;i++){const s=t._facetStart[i],r=t._facetStart[i+1];if(e)for(let e=r;e-- >s;)this.addNormalIndex(n+t.data.normalIndex[e]);else for(let e=s;e<r;e++)this.addNormalIndex(n+t.data.normalIndex[e])}}if(void 0!==this.data.color&&void 0!==t.data.color&&void 0!==t.data.colorIndex){const i=this.data.color.length;for(const e of t.data.color)this.addColor(e);for(let n=0;n<s;n++){const s=t._facetStart[n],r=t._facetStart[n+1];if(e)for(let e=r;e-- >s;)this.addColorIndex(i+t.data.colorIndex[e]);else for(let e=s;e<r;e++)this.addColorIndex(i+t.data.colorIndex[e])}}if(0!==t.data.face.length){const e=this.data.face.length;for(const e of t.data.face){const t=e.clone();this.data.face.push(t)}for(const i of t._facetToFaceData)this._facetToFaceData.push(e+i)}}get zeroTerminatedIndexCount(){return this.data.pointIndex.length+this._facetStart.length-1}static create(t=!1,e=!1,i=!1,s=!1){return new Ii(new mi(t,e,i,s))}addPoint(t,e){if(void 0!==e){const i=this.data.point.distanceIndexToPoint(e,t);if(void 0!==i&&K.isSmallMetricDistance(i))return e}return this.data.point.pushXYZ(t.x,t.y,t.z),this.data.point.length-1}addPointXYZ(t,e,i){return this.data.point.pushXYZ(t,e,i),this.data.point.length-1}addParam(t){return this.data.param||(this.data.param=new Ae),this.data.param.push(t),this.data.param.length-1}addParamUV(t,e,i,s){return this.data.param||(this.data.param=new Ae),void 0!==i&&this.data.isAlmostEqualParamIndexUV(i,t,e)?i:void 0!==s&&this.data.isAlmostEqualParamIndexUV(s,t,e)?s:(this.data.param.pushXY(t,e),this.data.param.length-1)}addNormal(t,e,i){if(void 0!==this.data.normal){let s;if(void 0!==e&&(s=this.data.normal.distanceIndexToPoint(e,t),void 0!==s&&K.isSmallMetricDistance(s)))return e;if(void 0!==i&&(s=this.data.normal.distanceIndexToPoint(i,t),void 0!==s&&K.isSmallMetricDistance(s)))return i;if(void 0!==e||void 0!==i){const e=this.data.normal.length-1;if(s=this.data.normal.distanceIndexToPoint(e,t),void 0!==s&&K.isSmallMetricDistance(s))return e}}return this.addNormalXYZ(t.x,t.y,t.z)}addNormalXYZ(t,e,i){return this.data.normal||(this.data.normal=new nt),this.data.normal.pushXYZ(t,e,i),this.data.normal.length-1}addColor(t){return this.data.color||(this.data.color=[]),this.data.color.push(t),this.data.color.length-1}addPointIndex(t,e=!0){this.data.pointIndex.push(t),this.data.edgeVisible.push(e)}addNormalIndex(t){this.data.normalIndex||(this.data.normalIndex=[]),this.data.normalIndex.push(t)}addParamIndex(t){this.data.paramIndex||(this.data.paramIndex=[]),this.data.paramIndex.push(t)}addColorIndex(t){this.data.colorIndex||(this.data.colorIndex=[]),this.data.colorIndex.push(t)}cleanupOpenFacet(){this.data.trimAllIndexArrays(this.data.pointIndex.length)}terminateFacet(t=!0){const e=this._facetStart.length-1,i=this._facetStart[e],s=this.data.pointIndex.length;if(t){const t=[];if(s<i+2&&t.push("Less than 3 indices in open facet"),this.data.normalIndex&&this.data.normalIndex.length!==s&&t.push("normalIndex count must match pointIndex count"),this.data.paramIndex&&this.data.paramIndex.length!==s&&t.push("paramIndex count must equal pointIndex count"),this.data.colorIndex&&this.data.colorIndex.length!==s&&t.push("colorIndex count must equal pointIndex count"),this.data.edgeVisible.length!==s&&t.push("visibleIndex count must equal pointIndex count"),Pi.areIndicesValid(this.data.normalIndex,i,s,this.data.normal,this.data.normal?this.data.normal.length:0)||t.push("invalid normal indices in open facet"),t.length>0)return this.cleanupOpenFacet(),t}this._facetStart.push(s)}get facetCount(){return this._facetStart.length-1}get faceCount(){return this.data.faceCount}get pointCount(){return this.data.pointCount}get colorCount(){return this.data.colorCount}get paramCount(){return this.data.paramCount}get normalCount(){return this.data.normalCount}numEdgeInFacet(t){return this.isValidFacetIndex(t)?this._facetStart[t+1]-this._facetStart[t]:0}isValidFacetIndex(t){return t>=0&&t+1<this._facetStart.length}facetIndex0(t){return this._facetStart[t]}facetIndex1(t){return this._facetStart[t+1]}createVisitor(t=0){return xi.create(this,t)}range(t,e){return this.data.range(e,t)}extendRange(t,e){this.data.range(t,e)}getFaceDataByFacetIndex(t){return this.data.face[this._facetToFaceData[t]]}setNewFaceData(t=0){const e=this._facetToFaceData.length;if(e>=this._facetStart.length)return!1;0===t&&(t=this._facetStart.length);const i=vi.createNull(),s=xi.create(this,0);if(!s.moveToReadIndex(e))return!1;const n=void 0!==this.data.param,r=i.paramRange.isNull&&n;do{r&&void 0!==s.param&&s.param.extendRange(i.paramRange)}while(s.moveToNextFacet()&&s.currentReadIndex()<t);n&&0!==this.data.param.length&&i.paramDistanceRange.isNull&&i.setParamDistanceRangeFromNewFaceData(this,e,t),this.data.face.push(i);const o=this.data.face.length-1;for(let e=this._facetToFaceData.length;e<t;e++)this._facetToFaceData.push(0===this._facetStart[e]?0:o);return!0}dispatchToGeometryHandler(t){return t.handleIndexedPolyface(this)}}class Ai extends xe{setGeometryB(t){if(this._geometryB=t,this._circularArcB=void 0,this._circularRadiusB=void 0,t instanceof De){const e=t.circularRadiusXY();void 0!==e&&(this._circularRadiusB=e,this._circularArcB=t)}}reinitialize(){this._results=[]}constructor(t){super(),this.setGeometryB(t),this._maxDistanceSquared=K.smallMetricDistanceSquared,this.reinitialize()}set maxDistanceToAccept(t){this._maxDistanceToAccept=t,void 0!==this._maxDistanceToAccept&&this._maxDistanceToAccept>0&&(this._maxDistanceSquared=this._maxDistanceToAccept*this._maxDistanceToAccept)}get maxDistanceToAccept(){return this._maxDistanceToAccept}get isMaxDistanceSet(){return void 0!==this._maxDistanceToAccept&&this._maxDistanceToAccept>0}resetGeometry(t){this.setGeometryB(t)}acceptFraction(t,e=1e-12){return!(t<-e||t>1+e)}grabPairedResults(t=!1){const e=this._results;return t&&this.reinitialize(),e}sameCurveAndFraction(t,e,i){return t===i.curve&&K.isAlmostEqualNumber(e,i.fraction)}testAndRecordPointPairApproach(t,e,i,s,n,r,o){if(i.distanceSquaredXY(r)<this._maxDistanceSquared){const a=vt.createCurveFractionPoint(t,e,i),c=vt.createCurveFractionPoint(s,n,r),h=Pt.createCapture(a,c);o&&h.swapDetails(),this._results.push(h)}}recordPointWithLocalFractions(t,e,i,s,n,r,o,a,c,h){let l,d,u,f;const g=void 0!==h&&h.detailA.hasFraction1&&h.detailB.hasFraction1;g?(l=K.interpolate(i,h.detailA.fraction,s),d=K.interpolate(o,h.detailB.fraction,a),u=K.interpolate(i,h.detailA.fraction1,s),f=K.interpolate(o,h.detailB.fraction1,a)):(l=u=K.interpolate(i,t,s),d=f=K.interpolate(o,n,a));const p=this._results.length;if(p>0&&!g){const t=this._results[p-1].detailA,i=this._results[p-1].detailB;if(c){if(this.sameCurveAndFraction(e,l,i)&&this.sameCurveAndFraction(r,d,t))return}else if(this.sameCurveAndFraction(e,l,t)&&this.sameCurveAndFraction(r,d,i))return}const m=vt.createCurveFractionPoint(e,l,e.fractionToPoint(l)),x=vt.createCurveFractionPoint(r,d,r.fractionToPoint(d));if(g)m.captureFraction1Point1(u,e.fractionToPoint(u)),x.captureFraction1Point1(f,r.fractionToPoint(f));else{if(m.point.distanceSquaredXY(x.point)>this._maxDistanceSquared)return;m.setIntervalRole(I.isolated),x.setIntervalRole(I.isolated)}c?this._results.push(new Pt(x,m)):this._results.push(new Pt(m,x))}capturePairWithLocalFractions(t,e,i,s,n,r,o,a){const c=K.interpolate(i,t.detailA.fraction,s),h=K.interpolate(r,t.detailB.fraction,o),l=this._results.length;if(l>0){const t=this._results[l-1].detailA,i=this._results[l-1].detailB;if(a){if(this.sameCurveAndFraction(e,c,i)&&this.sameCurveAndFraction(n,h,t))return}else if(this.sameCurveAndFraction(e,c,t)&&this.sameCurveAndFraction(n,h,i))return}a&&t.swapDetails(),vt.createCurveEvaluatedFraction(e,c,t.detailA),vt.createCurveEvaluatedFraction(n,h,t.detailB),t.detailA.setIntervalRole(I.isolated),t.detailB.setIntervalRole(I.isolated),this._results.push(t)}recordPairs(t,e,i,s){if(void 0!==i)for(const n of i)this.recordPointWithLocalFractions(n.detailA.fraction,t,0,1,n.detailB.fraction,e,0,1,s,n)}captureDetailPair(t,e,i){t&&e&&(i?this._results.push(Pt.createCapture(e,t)):this._results.push(Pt.createCapture(t,e)))}static updatePointToSegmentDistance(t,e,i,s,n,r,o){let a=!1;n<0?n=0:n>1&&(n=1),this._workPointB=i.interpolate(n,s,this._workPointB);const c=this._workPointB.distanceSquaredXY(e);return c<Math.min(r,o.detailA.a)&&(o.detailA.setFP(t,e,void 0,c),o.detailB.setFP(n,this._workPointB,void 0,c),a=!0),a}static segmentSegmentBoundedApproach(t,e,i,s,n){const r=e.x-t.x,o=e.y-t.y,a=s.x-i.x,c=s.y-i.y,h=i.x-t.x,l=i.y-t.y,d=s.x-t.x,u=s.y-t.y,f=i.x-e.x,g=i.y-e.y,p=K.crossProductXYXY(r,o,h,l),m=K.crossProductXYXY(r,o,d,u),x=-K.crossProductXYXY(a,c,h,l),y=-K.crossProductXYXY(a,c,f,g);if(p*m<0&&x*y<0){const n=-x/(y-x),r=-p/(m-p);return Pt.createCapture(vt.createCurveFractionPoint(void 0,n,t.interpolate(n,e)),vt.createCurveFractionPoint(void 0,r,i.interpolate(r,s)))}const _=new Pt;_.detailA.a=2*n;let v=!1;const P=K.hypotenuseSquaredXY(r,o);if(p*p<n*P){const s=K.dotProductXYXY(r,o,h,l)/P;this.updatePointToSegmentDistance(0,i,t,e,s,n,_)&&(v=!0)}if(m*m<n*P){const i=K.dotProductXYXY(r,o,d,u)/P;this.updatePointToSegmentDistance(1,s,t,e,i,n,_)&&(v=!0)}const I=K.hypotenuseSquaredXY(a,c);if(x*x<n*I){const e=-K.dotProductXYXY(a,c,h,l)/I;this.updatePointToSegmentDistance(0,t,i,s,e,n,_)&&(v=!1)}if(y*y<n*I){const t=-K.dotProductXYXY(a,c,f,g)/I;this.updatePointToSegmentDistance(1,e,i,s,t,n,_)&&(v=!1)}if(!(_.detailA.a>n))return v&&_.swapDetails(),_}testAndRecordFractionalPairApproach(t,e,i,s,n,r,o,a,c){const h=t.fractionToPoint(e),l=t.fractionToPoint(i),d=n.fractionToPoint(r),u=n.fractionToPoint(o);this.testAndRecordPointPairApproach(t,e,h,n,r,d,c),this.testAndRecordPointPairApproach(t,i,l,n,r,d,c),this.testAndRecordPointPairApproach(t,e,h,n,o,u,c),this.testAndRecordPointPairApproach(t,i,l,n,o,u,c),a&&(this.testAndRecordProjection(t,e,h,n,r,o,c),this.testAndRecordProjection(t,i,l,n,r,o,c)),s&&(this.testAndRecordProjection(n,r,d,t,e,i,!c),this.testAndRecordProjection(n,o,u,t,e,i,!c))}testAndRecordProjection(t,e,i,s,n,r,o){const a=s.closestPoint(i,!1);a&&K.restrictToInterval(a.fraction,n,r)===a.fraction&&this.testAndRecordPointPairApproach(t,e,i,s,a.fraction,a.point,o)}computeSegmentSegment3D(t,e,i,s,n,r,o,a,c,h,l){const d=Ai.segmentSegmentBoundedApproach(e,s,o,c,this._maxDistanceSquared);d&&(d.detailA.setCurve(t),d.detailB.setCurve(r),this.capturePairWithLocalFractions(d,t,i,n,r,a,h,l))}dispatchSegmentSegment(t,e,i,s,n,r,o,a,c,h,l){this.computeSegmentSegment3D(t,e,i,s,n,r,o,a,c,h,l)}dispatchSegmentArc(t,e,i,s,n,r,o){this.testAndRecordFractionalPairApproach(t,0,1,!0,r,0,1,!1,o);const a=r.toTransformedVectors(),c=e,h=s,l=K.tripleProductXYW(c,1,h,1,a.center,1),d=K.tripleProductXYW(c,1,h,1,a.vector0,0),u=K.tripleProductXYW(c,1,h,1,a.vector90,0),f=new St(2),g=new St(2),p=new St(2),m=Ct.appendImplicitLineUnitCircleIntersections(l,d,u,f,g,p);for(let e=0;e<m;e++){const s=a.center.plus2Scaled(a.vector0,f.atUncheckedIndex(e),a.vector90,g.atUncheckedIndex(e)),l=a.sweep.radiansToSignedPeriodicFraction(p.atUncheckedIndex(e)),d=Ft.lineSegment3dXYClosestPointUnbounded(c,h,s);void 0!==d&&this.acceptFraction(d)&&this.acceptFraction(l)&&this.recordPointWithLocalFractions(d,t,i,n,l,r,0,1,o)}const x=a.vector0.crossProductStartEndXY(e,s),y=a.vector90.crossProductStartEndXY(e,s),_=Math.atan2(y,x);for(const e of[_,_+Math.PI]){const s=a.center.plus2Scaled(a.vector0,Math.cos(e),a.vector90,Math.sin(e)),l=a.sweep.radiansToSignedPeriodicFraction(e),d=Ft.lineSegment3dXYClosestPointUnbounded(c,h,s);void 0!==d&&this.acceptFraction(d)&&this.acceptFraction(l)&&this.recordPointWithLocalFractions(d,t,i,n,l,r,0,1,o)}}dispatchCircularCircularOrdered(t,e,i,s,n){const r=t.center.distance(i.center),o=void 0!==this._maxDistanceToAccept?this._maxDistanceToAccept:K.smallMetricDistance;if(!(r>e+s+o||(this.testAndRecordFractionalPairApproach(t,0,1,!1,i,0,1,!1,n),K.isSmallMetricDistance(r)))){const a=$.createStartEnd(t.center,i.center);if(a.scaleInPlace(1/r),r-e-s>o);else for(const c of[-e,e])for(const e of[-s,s])if(r-c+e<o){const s=this.resolveDirectionToArcXYFraction(t,a,c);if(s){const t=this.resolveDirectionToArcXYFraction(i,a,e);t&&this.captureDetailPair(s,t,n)}}}}resolveDirectionToArcXYFraction(t,e,i){const s=i*t.matrixRef.columnDotXYZ(0,e.x,e.y,0),n=i*t.matrixRef.columnDotXYZ(1,e.x,e.y,0),r=Math.atan2(n,s),o=t.sweep.radiansToPositivePeriodicFraction(r,0);if(o<1)return vt.createCurveEvaluatedFraction(t,o)}dispatchArcArc(t,e,i){if(this._circularArcB){const s=this._circularRadiusB,n=t.circularRadiusXY();if(void 0!==n)return void(n>=s?this.dispatchCircularCircularOrdered(t,n,e,s,i):this.dispatchCircularCircularOrdered(e,s,t,n,!i))}}dispatchArcBsplineCurve3d(t,e,i){const s=we.create();e.emitStrokes(s),this.computeArcLineString(t,s,i)}dispatchBSplineCurve3dBSplineCurve3d(t,e,i){const s=we.create();t.emitStrokes(s);const n=we.create();e.emitStrokes(n),this.computeLineStringLineString(s,n,i)}dispatchLineStringBSplineCurve(t,e,i){const s=we.create();e.emitStrokes(s),this.computeLineStringLineString(t,s,i)}dispatchSegmentBsplineCurve(t,e,i){const s=we.create();e.emitStrokes(s),this.computeSegmentLineString(t,s,i)}computeSegmentLineString(t,e,i){const s=e.numPoints(),n=K.safeDivideFraction(1,s-1,0),r=t.point0Ref,o=t.point1Ref,a=Ai._workPointBB0,c=Ai._workPointBB1;for(let h=0;h<s-1;++h){const l=h*n,d=h+1===s-1?1:(h+1)*n;e.packedPoints.getPoint3dAtUncheckedPointIndex(h,a),e.packedPoints.getPoint3dAtUncheckedPointIndex(h+1,c),this.dispatchSegmentSegment(t,r,0,o,1,e,a,l,c,d,i)}}computeArcLineString(t,e,i){const s=Ai._workPointBB0,n=Ai._workPointBB1,r=e.numPoints();if(r>1){const o=1/(r-1);let a,c;a=0,e.pointAt(0,s);for(let h=1;h<r;h++,s.setFrom(n),a=c)e.pointAt(h,n),c=h*o,this.dispatchSegmentArc(e,s,a,n,c,t,!i)}}dispatchCurveChain(t,e){const i=this._geometryB;if(i&&i instanceof We){for(const s of i.children)this.resetGeometry(s),e(t);this._geometryB=i}}handleLineSegment3d(t){if(this._geometryB instanceof Pe){const e=this._geometryB;this.dispatchSegmentSegment(t,t.point0Ref,0,t.point1Ref,1,e,e.point0Ref,0,e.point1Ref,1,!1)}else this._geometryB instanceof we?this.computeSegmentLineString(t,this._geometryB,!1):this._geometryB instanceof De?this.dispatchSegmentArc(t,t.point0Ref,0,t.point1Ref,1,this._geometryB,!1):this._geometryB instanceof ze?this.dispatchSegmentBsplineCurve(t,this._geometryB,!1):this._geometryB instanceof We&&this.dispatchCurveChain(t,this.handleLineSegment3d.bind(this))}classifyBitsPointRangeXY(t,e,i){let s=0;return t<i.low.x?s=1:t>i.high.x&&(s=2),e<i.low.y?s|=4:e>i.high.y&&(s|=8),s}computeLineStringLineString(t,e,i){const s=t.range(),n=e.range();if(s.expandInPlace(this._maxDistanceToAccept),!n.intersectsRangeXY(s))return;let r,o;const a=ut.createNull(),c=Ai._workPointAA0,h=Ai._workPointAA1,l=Ai._workPointBB0,d=Ai._workPointBB1,u=t.numPoints(),f=e.numPoints();if(u>1&&f>1){t.pointAt(0,c);const s=1/(u-1),g=1/(f-1);let p,m,x,y=0;t.pointAt(0,c);for(let _=1;_<u;_++,c.setFrom(h),y=p)if(p=_*s,m=0,t.pointAt(_,h),a.setNull(),a.extendPoint(c),a.extendPoint(h),a.expandInPlace(this._maxDistanceToAccept),a.intersectsRangeXY(n)){e.pointAt(0,l),r=this.classifyBitsPointRangeXY(l.x,l.y,a);for(let s=1;s<f;s++,l.setFrom(d),m=x,r=o)e.pointAt(s,d),o=this.classifyBitsPointRangeXY(d.x,d.y,a),x=s*g,0==(r&o)&&this.dispatchSegmentSegment(t,c,y,h,p,e,l,m,d,x,i)}}}handleLineString3d(t){if(this._geometryB instanceof we){const e=this._geometryB;this.computeLineStringLineString(t,e,!1)}else this._geometryB instanceof Pe?this.computeSegmentLineString(this._geometryB,t,!0):this._geometryB instanceof De?this.computeArcLineString(this._geometryB,t,!0):this._geometryB instanceof ze?this.dispatchLineStringBSplineCurve(t,this._geometryB,!1):this._geometryB instanceof We&&this.dispatchCurveChain(t,this.handleLineString3d.bind(this))}handleArc3d(t){this._geometryB instanceof Pe?this.dispatchSegmentArc(this._geometryB,this._geometryB.point0Ref,0,this._geometryB.point1Ref,1,t,!0):this._geometryB instanceof we?this.computeArcLineString(t,this._geometryB,!1):this._geometryB instanceof De?this.dispatchArcArc(t,this._geometryB,!1):this._geometryB instanceof ze?this.dispatchArcBsplineCurve3d(t,this._geometryB,!1):this._geometryB instanceof We&&this.dispatchCurveChain(t,this.handleArc3d.bind(this))}handleBSplineCurve3d(t){this._geometryB instanceof Pe?this.dispatchSegmentBsplineCurve(this._geometryB,t,!0):this._geometryB instanceof we?this.dispatchLineStringBSplineCurve(this._geometryB,t,!0):this._geometryB instanceof De?this.dispatchArcBsplineCurve3d(this._geometryB,t,!0):this._geometryB instanceof Re?this.dispatchBSplineCurve3dBSplineCurve3d(t,this._geometryB,!1):this._geometryB instanceof We&&this.dispatchCurveChain(t,this.handleBSplineCurve3d.bind(this))}handleBSplineCurve3dH(t){}}Ai._workPointAA0=Q.create(),Ai._workPointAA1=Q.create(),Ai._workPointBB0=Q.create(),Ai._workPointBB1=Q.create(),Ai._workPointB=Q.create();class Si{get tolerance(){return this._tolerance}constructor(t=K.smallMetricDistance){this._tolerance=t}static create(t=K.smallMetricDistance){return new Si(t)}static assignDetailInterpolatedFractionsAndPoints(t,e,i,s,n,r=!1){r?(t.fraction=i,t.fraction1=e):(t.fraction=e,t.fraction1=i),t.point=s.interpolate(t.fraction,n,t.point),t.point1=s.interpolate(t.fraction1,n,t.point1)}projectPointToSegmentXY(t,e,i){this._vectorU=$.createStartEnd(e,i,this._vectorU),this._vectorV=$.createStartEnd(e,t,this._vectorV);const s=this._vectorU.dotProductXY(this._vectorU),n=this._vectorU.dotProductXY(this._vectorV),r=K.safeDivideFraction(n,s,0);return vt.createCurveFractionPoint(void 0,r,e.interpolate(r,i))}coincidentSegmentRangeXY(t,e,i,s,n=!0){const r=this.projectPointToSegmentXY(t,i,s);if(t.distanceXY(r.point)>this._tolerance)return;const o=this.projectPointToSegmentXY(e,i,s);if(e.distanceXY(o.point)>this._tolerance)return;const a=this.projectPointToSegmentXY(i,t,e);if(i.distanceXY(a.point)>this._tolerance)return;const c=this.projectPointToSegmentXY(s,t,e);if(s.distanceXY(c.point)>this._tolerance)return;if(r.fraction1=o.fraction,r.point1=o.point,a.fraction1=c.fraction,a.point1=c.point,!n)return Pt.createCapture(a,r);const h=ke.create(a.fraction,a.fraction1);if(h.clampDirectedTo01()){const n=h.x0,o=h.x1,c=a.inverseInterpolateFraction(n),l=a.inverseInterpolateFraction(o);return Si.assignDetailInterpolatedFractionsAndPoints(a,n,o,t,e,n>o),Si.assignDetailInterpolatedFractionsAndPoints(r,c,l,i,s,c>l),Pt.createCapture(a,r)}if(h.signedDelta()<0){if(a.point.isAlmostEqual(t,this.tolerance))return a.collapseToStart(),r.collapseToStart(),Pt.createCapture(a,r);if(a.point1.isAlmostEqual(e,this.tolerance))return a.collapseToEnd(),r.collapseToEnd(),Pt.createCapture(a,r)}else{if(a.point.isAlmostEqual(e,this.tolerance))return a.collapseToStart(),r.collapseToEnd(),Pt.createCapture(a,r);if(a.point1.isAlmostEqual(t,this.tolerance))return a.collapseToEnd(),r.collapseToStart(),Pt.createCapture(a,r)}}createDetailPair(t,e,i,s,n,r){const o=n-s,a=K.conditionalDivideFraction(i.x0-s,o),c=K.conditionalDivideFraction(i.x1-s,o);if(void 0!==a&&void 0!==c){const s=vt.createCurveEvaluatedFractionFraction(t,i.x0,i.x1),n=vt.createCurveEvaluatedFractionFraction(e,a,c);return r&&s.swapFractionsAndPoints(),Pt.createCapture(s,n)}}appendDetailPair(t,e){return void 0===e?t:void 0===t?[e]:(t.push(e),t)}coincidentArcIntersectionXY(t,i,s=!0){let n;if(t.center.isAlmostEqual(i.center,this.tolerance)){const s=t.matrixRef.multiplyMatrixInverseMatrix(i.matrixRef);if(s){const r=s.at(0,0),o=s.at(1,0),a=s.at(0,1),c=s.at(1,1),h=K.hypotenuseXY(r,o),l=K.hypotenuseXY(a,c),d=K.dotProductXYXY(r,o,a,c),u=K.crossProductXYXY(r,o,a,c);if(K.isAlmostEqualNumber(h,1)&&K.isAlmostEqualNumber(l,1)&&K.isAlmostEqualNumber(0,d)){const s=Math.atan2(o,r),a=u>0?1:-1,c=s+a*i.sweep.startRadians,h=s+a*i.sweep.endRadians,l=a*t.sweep.sweepRadians*i.sweep.sweepRadians<0,d=At.createStartEndRadians(c,h),f=t.sweep,g=f.fractionPeriod(),p=f.radiansToPositivePeriodicFraction(d.startRadians);e(p>=0);const m=p+d.sweepRadians/f.sweepRadians,x=(e,s)=>{const r=n?n.length:0,o=e.x0,a=e.x1;if(e.clampDirectedTo01()&&!K.isSmallRelative(e.absoluteDelta()))n=this.appendDetailPair(n,this.createDetailPair(t,i,e,o,a,l));else{const e=l?s:!s,r=this._point0=s?t.startPoint(this._point0):t.endPoint(this._point0),o=this._point1=e?i.startPoint(this._point1):i.endPoint(this._point1);if(r.isAlmostEqual(o,this.tolerance)){const a=vt.createCurveFractionPoint(t,s?0:1,r),c=vt.createCurveFractionPoint(i,e?0:1,o);n=this.appendDetailPair(n,Pt.createCapture(a,c))}}return void 0!==n&&n.length>r};x(ke.create(p,m),!1),m>=g?x(ke.create(p-g,m-g),!0):0===p&&x(ke.create(p+g,m+g),!0)}}}return n}}class wi extends Gt{constructor(t,e){super(),this._curveA=t,this._curveB=e,this._rayA=bt.createZero(),this._rayB=bt.createZero()}evaluate(t,e){return this._curveA.fractionToPointAndDerivative(t,this._rayA),this._curveB.fractionToPointAndDerivative(e,this._rayB),this.currentF.setOriginAndVectorsXYZ(this._rayB.origin.x-this._rayA.origin.x,this._rayB.origin.y-this._rayA.origin.y,0,-this._rayA.direction.x,-this._rayA.direction.y,0,this._rayB.direction.x,this._rayB.direction.y,0),!0}}class Ci extends me{reinitialize(){this._results=[]}constructor(t,e,i,s,n=K.smallMetricDistance){super(),this._extendA=e,this._geometryB=i,this._extendB=s,this._worldToLocalPerspective=void 0,this._worldToLocalAffine=void 0,void 0===t||t.isIdentity()||(this._worldToLocalAffine=t.asTransform,this._worldToLocalAffine||(this._worldToLocalPerspective=t.clone())),this._coincidentGeometryContext=Si.create(n),this.reinitialize()}resetGeometry(t,e,i){this._extendA=t,this._geometryB=e,this._extendB=i}acceptFraction(t,e,i,s=1e-12){return!(!t&&e<-s||!i&&e>1+s)}acceptFractionOnLine(t,e,i,s,n,r=K.smallMetricDistance){return!t&&e<0?K.isDistanceWithinTol(e*s.distanceXY(n),r):!(!i&&e>1)||K.isDistanceWithinTol((e-1)*s.distanceXY(n),r)}grabPairedResults(t=!1){const e=this._results;return t&&this.reinitialize(),e}sameCurveAndFraction(t,e,i){return t===i.curve&&K.isAlmostEqualNumber(e,i.fraction)}recordPointWithLocalFractions(t,e,i,s,n,r,o,a,c,h){let l,d,u,f;const g=void 0!==h&&h.detailA.hasFraction1&&h.detailB.hasFraction1;g?(l=K.interpolate(i,h.detailA.fraction,s),d=K.interpolate(o,h.detailB.fraction,a),u=K.interpolate(i,h.detailA.fraction1,s),f=K.interpolate(o,h.detailB.fraction1,a)):(l=u=K.interpolate(i,t,s),d=f=K.interpolate(o,n,a));const p=this._results.length;if(p>0&&!g){const t=this._results[p-1].detailA,i=this._results[p-1].detailB;if(c){if(this.sameCurveAndFraction(e,l,i)&&this.sameCurveAndFraction(r,d,t))return}else if(this.sameCurveAndFraction(e,l,t)&&this.sameCurveAndFraction(r,d,i))return}const m=vt.createCurveFractionPoint(e,l,e.fractionToPoint(l)),x=vt.createCurveFractionPoint(r,d,r.fractionToPoint(d));g?(m.captureFraction1Point1(u,e.fractionToPoint(u)),x.captureFraction1Point1(f,r.fractionToPoint(f))):(m.setIntervalRole(I.isolated),x.setIntervalRole(I.isolated)),c?this._results.push(new Pt(x,m)):this._results.push(new Pt(m,x))}recordPairs(t,e,i,s){if(void 0!==i)for(const n of i)this.recordPointWithLocalFractions(n.detailA.fraction,t,0,1,n.detailB.fraction,e,0,1,s,n)}computeSegmentSegment3D(t,e,i,s,n,r,o,a,c,h,l,d,u,f,g){const p=Ci._workVector2dA,m=this._coincidentGeometryContext.coincidentSegmentRangeXY(i,n,h,d);m?this.recordPointWithLocalFractions(m.detailA.fraction,t,s,r,m.detailB.fraction,a,l,u,g,m):Ft.lineSegment3dXYTransverseIntersectionUnbounded(i,n,h,d,p)&&this.acceptFractionOnLine(e,p.x,o,i,n,this._coincidentGeometryContext.tolerance)&&this.acceptFractionOnLine(c,p.y,f,h,d,this._coincidentGeometryContext.tolerance)&&this.recordPointWithLocalFractions(p.x,t,s,r,p.y,a,l,u,g)}computeSegmentSegment3DH(t,e,i,s,n,r,o,a,c,h,l,d,u,f,g){const p=Ci._workPointA0H,m=Ci._workPointA1H,x=Ci._workPointB0H,y=Ci._workPointB1H;this._worldToLocalPerspective.multiplyPoint3d(i,1,p),this._worldToLocalPerspective.multiplyPoint3d(n,1,m),this._worldToLocalPerspective.multiplyPoint3d(h,1,x),this._worldToLocalPerspective.multiplyPoint3d(d,1,y);const _=Ft.lineSegment3dHXYTransverseIntersectionUnbounded(p,m,x,y);if(void 0!==_){const i=_.x,n=_.y;this.acceptFraction(e,i,o)&&this.acceptFraction(c,n,f)&&this.recordPointWithLocalFractions(i,t,s,r,n,a,l,u,g)}}dispatchSegmentSegment(t,e,i,s,n,r,o,a,c,h,l,d,u,f,g){this._worldToLocalAffine?(Ci.setTransformedWorkPoints(this._worldToLocalAffine,i,n,h,d),this.computeSegmentSegment3D(t,e,Ci._workPointA0,s,Ci._workPointA1,r,o,a,c,Ci._workPointB0,l,Ci._workPointB1,u,f,g)):this._worldToLocalPerspective?this.computeSegmentSegment3DH(t,e,i,s,n,r,o,a,c,h,l,d,u,f,g):this.computeSegmentSegment3D(t,e,i,s,n,r,o,a,c,h,l,d,u,f,g)}dispatchSegmentArc(t,e,i,s,n,r,o,a,c,h,l){if(this._worldToLocalPerspective){const d=a.toTransformedPoint4d(this._worldToLocalPerspective),u=this._worldToLocalPerspective.multiplyPoint3d(i,1),f=this._worldToLocalPerspective.multiplyPoint3d(n,1),g=K.tripleProductPoint4dXYW(u,f,d.center),p=K.tripleProductPoint4dXYW(u,f,d.vector0),m=K.tripleProductPoint4dXYW(u,f,d.vector90),x=new St(2),y=new St(2),_=new St(2),v=Ct.appendImplicitLineUnitCircleIntersections(g,p,m,x,y,_);for(let i=0;i<v;i++){const n=d.center.plus2Scaled(d.vector0,x.atUncheckedIndex(i),d.vector90,y.atUncheckedIndex(i)),g=d.sweep.radiansToSignedPeriodicFraction(_.atUncheckedIndex(i)),p=Ft.lineSegment3dHXYClosestPointUnbounded(u,f,n);void 0!==p&&this.acceptFraction(e,p,o)&&this.acceptFraction(c,g,h)&&this.recordPointWithLocalFractions(p,t,s,r,g,a,0,1,l)}}else{const d=a.toTransformedVectors(this._worldToLocalAffine);let u=i,f=n;this._worldToLocalAffine&&(u=this._worldToLocalAffine.multiplyPoint3d(i),f=this._worldToLocalAffine.multiplyPoint3d(n));const g=K.tripleProductXYW(u,1,f,1,d.center,1),p=K.tripleProductXYW(u,1,f,1,d.vector0,0),m=K.tripleProductXYW(u,1,f,1,d.vector90,0),x=new St(2),y=new St(2),_=new St(2),v=Ct.appendImplicitLineUnitCircleIntersections(g,p,m,x,y,_),P=1e-10,I=1e-7;for(let i=0;i<v;i++){const n=d.center.plus2Scaled(d.vector0,x.atUncheckedIndex(i),d.vector90,y.atUncheckedIndex(i)),g=d.sweep.radiansToSignedPeriodicFraction(_.atUncheckedIndex(i)),p=Ft.lineSegment3dXYClosestPointUnbounded(u,f,n);void 0!==p&&this.acceptFraction(e,p,o,P)&&this.acceptFraction(c,g,h,I)&&this.recordPointWithLocalFractions(p,t,s,r,g,a,0,1,l)}}}dispatchArcArcThisOrder(t,e,i,s,n,r,o){const a=e.inverse();if(a){const e=a.multiplyMatrixMatrix(n),c=[],h=[];kt.solveUnitCircleHomogeneousEllipseIntersection(e.coffs[2],e.coffs[5],e.coffs[8],e.coffs[0],e.coffs[3],e.coffs[6],e.coffs[1],e.coffs[4],e.coffs[7],c,h);for(let e=0;e<c.length;e++){const n=t.sweep.radiansToSignedPeriodicFraction(h[e]),a=s.sweep.radiansToSignedPeriodicFraction(c[e]);this.acceptFraction(i,n,i)&&this.acceptFraction(r,a,r)&&this.recordPointWithLocalFractions(n,t,0,1,a,s,0,1,o)}}}dispatchArcArc(t,e,i,s,n){let r,o;if(this._worldToLocalPerspective){const e=t.toTransformedPoint4d(this._worldToLocalPerspective),s=i.toTransformedPoint4d(this._worldToLocalPerspective);r=xt.createColumnsXYW(e.vector0,e.vector0.w,e.vector90,e.vector90.w,e.center,e.center.w),o=xt.createColumnsXYW(s.vector0,s.vector0.w,s.vector90,e.vector90.w,s.center,s.center.w)}else{const e=t.toTransformedVectors(this._worldToLocalAffine),s=i.toTransformedVectors(this._worldToLocalAffine);r=xt.createColumnsXYW(e.vector0,0,e.vector90,0,e.center,1),o=xt.createColumnsXYW(s.vector0,0,s.vector90,0,s.center,1)}if(r.conditionNumber()>o.conditionNumber()?this.dispatchArcArcThisOrder(t,r,e,i,o,s,n):this.dispatchArcArcThisOrder(i,o,s,t,r,e,!n),this._coincidentGeometryContext)if(this._worldToLocalPerspective);else if(this._worldToLocalAffine);else{const e=this._coincidentGeometryContext.coincidentArcIntersectionXY(t,i,!0);void 0!==e&&this.recordPairs(t,i,e,n)}}dispatchArcBsplineCurve3d(t,e,i,s,n){let r;if(this._worldToLocalPerspective){const e=t.toTransformedPoint4d(this._worldToLocalPerspective);r=xt.createColumnsXYW(e.vector0,e.vector0.w,e.vector90,e.vector90.w,e.center,e.center.w)}else{const e=t.toTransformedVectors(this._worldToLocalAffine);r=xt.createColumnsXYW(e.vector0,0,e.vector90,0,e.center,1)}const o=r.inverse();if(o){const r=i.order,a=2*r-1,c=new Float64Array(r),h=new Lt(a),l=o.at(0,0),d=o.at(0,1),u=0,f=o.at(0,2),g=o.at(1,0),p=o.at(1,1),m=0,x=o.at(1,2),y=o.at(2,0),_=o.at(2,1),v=0,P=o.at(2,2);if(o){let r;for(let o=0;r=i.getSaturatedBezierSpan3dH(o,r),r;o++){this._worldToLocalPerspective?r.tryMultiplyMatrix4dInPlace(this._worldToLocalPerspective):this._worldToLocalAffine&&r.tryTransformInPlace(this._worldToLocalAffine),h.zero(),r.poleProductsXYZW(c,l,d,u,f),h.addSquaredSquaredBezier(c,1),r.poleProductsXYZW(c,g,p,m,x),h.addSquaredSquaredBezier(c,1),r.poleProductsXYZW(c,y,_,v,P),h.addSquaredSquaredBezier(c,-1);const o=h.roots(0,!0);if(o)for(const a of o){const o=r.fractionToParentFraction(a),c=r.fractionToPoint4d(a),h=c.dotProductXYZW(l,d,u,f),y=c.dotProductXYZW(g,p,m,x),_=t.sweep.radiansToSignedPeriodicFraction(Math.atan2(y,h));this.acceptFraction(e,_,e)&&this.acceptFraction(s,o,s)&&this.recordPointWithLocalFractions(_,t,0,1,o,i,0,1,n)}}}}}transformBeziers(t){if(this._worldToLocalAffine)for(const e of t)e.tryTransformInPlace(this._worldToLocalAffine);else if(this._worldToLocalPerspective)for(const e of t)e.tryMultiplyMatrix4dInPlace(this._worldToLocalPerspective)}getRanges(t){const e=[];e.length=0;for(const i of t)e.push(i.range());return e}dispatchBezierBezierStrokeFirst(t,e,i,s,n,r,o,a){this._xyzwA0||(this._xyzwA0=Rt.create()),this._xyzwA1||(this._xyzwA1=Rt.create()),this._xyzwPlane||(this._xyzwPlane=Rt.create()),this._xyzwB||(this._xyzwB=Rt.create()),t.fractionToPoint4d(0,this._xyzwA0);let c,h=0;const l=1/i;for(let r=1;r<=i;r++,h=c,this._xyzwA0.setFrom(this._xyzwA1)){c=r*l,t.fractionToPoint4d(c,this._xyzwA1),Rt.createPlanePointPointZ(this._xyzwA0,this._xyzwA1,this._xyzwPlane),s.poleProductsXYZW(o.coffs,this._xyzwPlane.x,this._xyzwPlane.y,this._xyzwPlane.z,this._xyzwPlane.w);let i=0;const d=o.roots(0,!0);if(d)for(const r of d){let o=r;s.fractionToPoint4d(o,this._xyzwB);const l=Ft.lineSegment3dHXYClosestPointUnbounded(this._xyzwA0,this._xyzwA1,this._xyzwB);if(l&&K.isIn01WithTolerance(l,1e-5)){let r=K.interpolate(h,l,c);const d=new wi(t,s),u=new Ht(d);u.setUV(r,o),u.runIterations()&&(r=u.getU(),o=u.getV());const f=t.fractionToParentFraction(r),g=s.fractionToParentFraction(o),p=t.fractionToPoint(r),m=e.fractionToPoint(f),x=s.fractionToPoint(o),y=n.fractionToPoint(g);p.isAlmostEqualXY(m)||i++,x.isAlmostEqualXY(y)||i++,i>0&&!p.isAlmostEqual(x)&&i++,i>0&&!m.isAlmostEqual(y)&&i++,this.acceptFraction(!1,f,!1)&&this.acceptFraction(!1,g,!1)&&this.recordPointWithLocalFractions(f,e,0,1,g,n,0,1,a)}}}}dispatchBSplineCurve3dBSplineCurve3d(t,e,i){const s=t.collectBezierSpans(!0),n=e.collectBezierSpans(!0),r=s.length,o=n.length;this.transformBeziers(s),this.transformBeziers(n);const a=this.getRanges(s),c=this.getRanges(n),h=t.order,l=e.order,d=new Lt(h),u=new Lt(l);for(let h=0;h<r;h++)for(let r=0;r<o;r++)if(a[h].intersectsRangeXY(c[r])){const o=s[h].computeStrokeCountForOptions(),a=n[r].computeStrokeCountForOptions();o<a?this.dispatchBezierBezierStrokeFirst(s[h],t,o,n[r],e,a,u,i):this.dispatchBezierBezierStrokeFirst(n[r],e,a,s[h],t,o,d,!i)}}projectPoint(t,e=1){return this._worldToLocalPerspective?this._worldToLocalPerspective.multiplyPoint3d(t,e):this._worldToLocalAffine?this._worldToLocalAffine.multiplyXYZW(t.x,t.y,t.z,e):Rt.createFromPointAndWeight(t,e)}mapNPCPlaneToWorld(t,e){this._worldToLocalAffine?this._worldToLocalAffine.multiplyTransposeXYZW(t.x,t.y,t.z,t.w,e):this._worldToLocalPerspective?this._worldToLocalPerspective.multiplyTransposePoint4d(t,e):t.clone(e)}dispatchSegmentBsplineCurve(t,e,i,s,n,r,o,a,c,h){const l=this.projectPoint(i),d=this.projectPoint(n),u=Rt.createPlanePointPointZ(l,d);this.mapNPCPlaneToWorld(u,u);const f=[];a.appendPlaneIntersectionPoints(u,f);for(const i of f){const n=i.fraction,u=i.point,f=this.projectPoint(u),g=Ft.lineSegment3dHXYClosestPointUnbounded(l,d,f);void 0!==g&&this.acceptFraction(e,g,o)&&this.acceptFraction(c,n,c)&&this.recordPointWithLocalFractions(g,t,s,r,n,a,0,1,h)}}dispatchLineStringBSplineCurve(t,e,i,s,n){const r=t.numPoints();if(r>1){const o=1/(r-1);let a,c;a=0;const h=Ci._workPointA0,l=Ci._workPointA1;t.pointAt(0,h);for(let d=1;d<r;d++,h.setFrom(l),a=c)t.pointAt(d,l),c=d*o,this.dispatchSegmentBsplineCurve(t,1===d&&e,h,a,l,c,d+1===r&&e,i,s,n)}}computeSegmentLineString(t,e,i,s,n){const r=t.point0Ref,o=t.point1Ref,a=Ci._workPointBB0,c=Ci._workPointBB1,h=i.numPoints();if(h>1){const l=1/(h-1);let d,u;d=0,i.pointAt(0,a);for(let f=1;f<h;f++,a.setFrom(c),d=u)i.pointAt(f,c),u=f*l,this.dispatchSegmentSegment(t,e,r,0,o,1,e,i,1===f&&s,a,d,c,u,f+1===h&&s,n)}}computeArcLineString(t,e,i,s,n){const r=Ci._workPointBB0,o=Ci._workPointBB1,a=i.numPoints();if(a>1){const c=1/(a-1);let h,l;h=0,i.pointAt(0,r);for(let d=1;d<a;d++,r.setFrom(o),h=l)i.pointAt(d,o),l=d*c,this.dispatchSegmentArc(i,1===d&&s,r,h,o,l,d+1===a&&s,t,e,e,!n)}}static setTransformedWorkPoints(t,e,i,s,n){t.multiplyPoint3d(e,this._workPointA0),t.multiplyPoint3d(i,this._workPointA1),t.multiplyPoint3d(s,this._workPointB0),t.multiplyPoint3d(n,this._workPointB1)}handleLineSegment3d(t){if(this._geometryB instanceof Pe){const e=this._geometryB;this.dispatchSegmentSegment(t,this._extendA,t.point0Ref,0,t.point1Ref,1,this._extendA,e,this._extendB,e.point0Ref,0,e.point1Ref,1,this._extendB,!1)}else this._geometryB instanceof we?this.computeSegmentLineString(t,this._extendA,this._geometryB,this._extendB,!1):this._geometryB instanceof De?this.dispatchSegmentArc(t,this._extendA,t.point0Ref,0,t.point1Ref,1,this._extendA,this._geometryB,this._extendB,this._extendB,!1):this._geometryB instanceof ze&&this.dispatchSegmentBsplineCurve(t,this._extendA,t.point0Ref,0,t.point1Ref,1,this._extendA,this._geometryB,this._extendB,!1)}handleLineString3d(t){if(this._geometryB instanceof we){const e=this._geometryB,i=Ci._workPointAA0,s=Ci._workPointAA1,n=Ci._workPointBB0,r=Ci._workPointBB1,o=t.numPoints(),a=e.numPoints();if(o>1&&a>1){t.pointAt(0,i);const c=1/(o-1),h=1/(a-1);let l,d,u,f=0;const g=this._extendA,p=this._extendB;t.pointAt(0,i);for(let m=1;m<o;m++,i.setFrom(s),f=d){d=m*c,l=0,t.pointAt(m,s),e.pointAt(0,n);for(let c=1;c<a;c++,n.setFrom(r),l=u)e.pointAt(c,r),u=c*h,this.dispatchSegmentSegment(t,1===m&&g,i,f,s,d,m+1===o&&g,e,1===c&&p,n,l,r,u,c+1===a&&p,!1)}}}else this._geometryB instanceof Pe?this.computeSegmentLineString(this._geometryB,this._extendB,t,this._extendA,!0):this._geometryB instanceof De?this.computeArcLineString(this._geometryB,this._extendB,t,this._extendA,!0):this._geometryB instanceof ze&&this.dispatchLineStringBSplineCurve(t,this._extendA,this._geometryB,this._extendB,!1)}handleArc3d(t){this._geometryB instanceof Pe?this.dispatchSegmentArc(this._geometryB,this._extendB,this._geometryB.point0Ref,0,this._geometryB.point1Ref,1,this._extendB,t,this._extendA,this._extendA,!0):this._geometryB instanceof we?this.computeArcLineString(t,this._extendA,this._geometryB,this._extendB,!1):this._geometryB instanceof De?this.dispatchArcArc(t,this._extendA,this._geometryB,this._extendB,!1):this._geometryB instanceof ze&&this.dispatchArcBsplineCurve3d(t,this._extendA,this._geometryB,this._extendB,!1)}handleBSplineCurve3d(t){this._geometryB instanceof Pe?this.dispatchSegmentBsplineCurve(this._geometryB,this._extendB,this._geometryB.point0Ref,0,this._geometryB.point1Ref,1,this._extendB,t,this._extendA,!0):this._geometryB instanceof we?this.dispatchLineStringBSplineCurve(this._geometryB,this._extendB,t,this._extendA,!0):this._geometryB instanceof De?this.dispatchArcBsplineCurve3d(this._geometryB,this._extendB,t,this._extendA,!0):this._geometryB instanceof Re&&this.dispatchBSplineCurve3dBSplineCurve3d(t,this._geometryB,!1)}handleBSplineCurve3dH(t){}}Ci._workVector2dA=J.create(),Ci._workPointA0H=Rt.create(),Ci._workPointA1H=Rt.create(),Ci._workPointB0H=Rt.create(),Ci._workPointB1H=Rt.create(),Ci._workPointAA0=Q.create(),Ci._workPointAA1=Q.create(),Ci._workPointBB0=Q.create(),Ci._workPointBB1=Q.create(),Ci._workPointA0=Q.create(),Ci._workPointA1=Q.create(),Ci._workPointB0=Q.create(),Ci._workPointB1=Q.create();class Ti extends me{reinitialize(){this._results=new It}constructor(t,e,i){super(),this._extendA=t,this._geometryB=e,this._extendB=i,this.reinitialize()}grabResults(t=!1){const e=this._results;return t&&this.reinitialize(),e}acceptFraction(t,e,i){return!(!t&&e<0||!i&&e>1)}recordPointWithLocalFractions(t,e,i,s,n,r,o,a,c){const h=K.interpolate(i,t,s),l=K.interpolate(o,n,a),d=this._results.dataA.length;if(d>0){const t=this._results.dataA[d-1].fraction,e=this._results.dataB[d-1].fraction;if(c){if(K.isAlmostEqualNumber(t,l)&&K.isAlmostEqualNumber(e,h))return}else if(K.isAlmostEqualNumber(t,h)&&K.isAlmostEqualNumber(e,l))return}const u=e.fractionToPoint(h),f=r.fractionToPoint(l);if(!u.isAlmostEqualMetric(f))return;const g=vt.createCurveFractionPoint(e,h,u);g.setIntervalRole(I.isolated);const p=vt.createCurveFractionPoint(r,l,f);p.setIntervalRole(I.isolated),c?(this._results.dataA.push(p),this._results.dataB.push(g)):(this._results.dataA.push(g),this._results.dataB.push(p))}computeSegmentSegment3D(t,e,i,s,n,r,o,a,c,h,l,d,u,f,g){const p=Ti._workVector2dA;Ft.lineSegment3dClosestApproachUnbounded(i,n,h,d,p)&&this.acceptFraction(e,p.x,o)&&this.acceptFraction(c,p.y,f)&&this.recordPointWithLocalFractions(p.x,t,s,r,p.y,a,l,u,g)}dispatchSegmentSegment(t,e,i,s,n,r,o,a,c,h,l,d,u,f,g){this.computeSegmentSegment3D(t,e,i,s,n,r,o,a,c,h,l,d,u,f,g)}createPlaneWithPreferredPerpendicular(t,e,i,s,n){i=K.restrictToInterval(Math.abs(i),0,1-K.smallFraction);const r=e.magnitudeSquared(),o=s.magnitudeSquared(),a=Math.abs(e.dotProduct(s)),c=e.unitCrossProduct(a*a<=i*i*r*o?s:n);if(c)return yt.create(t,c)}dispatchSegmentArc(t,e,i,s,n,r,o,a,c,h,l){const d=$.createStartEnd(i,n),u=this.createPlaneWithPreferredPerpendicular(i,d,.94,a.perpendicularVector,a.vector0);if(void 0!==u){const d=[];let f,g;a.appendPlaneIntersectionPoints(u,d);for(const u of d)this.acceptFraction(c,u.fraction,h)&&(f=Ft.lineSegment3dClosestPointUnbounded(i,n,u.point),void 0!==f&&(g=i.interpolate(f,n,g),g.isAlmostEqualMetric(u.point)&&this.acceptFraction(e,f,o)&&this.recordPointWithLocalFractions(f,t,s,r,u.fraction,a,0,1,l)))}}dispatchArcArcInPlane(t,e,i,s,n){const r=t.otherArcAsLocalVectors(i);if(void 0!==r){const o=[],a=[];kt.solveUnitCircleHomogeneousEllipseIntersection(r.center.x,r.center.y,1,r.vector0.x,r.vector0.y,0,r.vector90.x,r.vector90.y,0,o,a);for(let r=0;r<o.length;r++){const c=t.sweep.radiansToSignedPeriodicFraction(a[r]),h=t.sweep.radiansToSignedPeriodicFraction(o[r]);this.acceptFraction(e,c,e)&&this.acceptFraction(s,h,s)&&this.recordPointWithLocalFractions(c,t,0,1,h,i,0,1,n)}}}dispatchArcArc(t,e,i,s,n){const r=yt.create(t.center,t.perpendicularVector),o=yt.create(i.center,i.perpendicularVector);if(void 0!==r&&void 0!==o)if(r.getNormalRef().isParallelTo(o.getNormalRef()))r.isPointInPlane(o.getOriginRef())&&o.isPointInPlane(r.getOriginRef())&&this.dispatchArcArcInPlane(t,e,i,s,n);else{const a=[];i.appendPlaneIntersectionPoints(r,a);const c=[];t.appendPlaneIntersectionPoints(o,c);for(const r of a)for(const o of c)o.point.isAlmostEqual(r.point)&&this.acceptFraction(e,o.fraction,e)&&this.acceptFraction(s,r.fraction,s)&&this.recordPointWithLocalFractions(o.fraction,t,0,1,r.fraction,i,0,1,n)}}dispatchArcBsplineCurve3d(t,e,i,s,n){}dispatchBSplineCurve3dBSplineCurve3d(t,e,i){}dispatchSegmentBsplineCurve(t,e,i,s,n,r,o,a,c,h){}dispatchLineStringBSplineCurve(t,e,i,s,n){}computeSegmentLineString(t,e,i,s,n){const r=t.point0Ref,o=t.point1Ref,a=Ti._workPointBB0,c=Ti._workPointBB1,h=i.numPoints();if(h>1){const l=1/(h-1);let d,u;d=0,i.pointAt(0,a);for(let f=1;f<h;f++,a.setFrom(c),d=u)i.pointAt(f,c),u=f*l,this.dispatchSegmentSegment(t,e,r,0,o,1,e,i,1===f&&s,a,d,c,u,f+1===h&&s,n)}}computeArcLineString(t,e,i,s,n){const r=Ti._workPointBB0,o=Ti._workPointBB1,a=i.numPoints();if(a>1){const c=1/(a-1);let h,l;h=0,i.pointAt(0,r);for(let d=1;d<a;d++,r.setFrom(o),h=l)i.pointAt(d,o),l=d*c,this.dispatchSegmentArc(i,1===d&&s,r,h,o,l,d+1===a&&s,t,e,e,!n)}}handleLineSegment3d(t){if(this._geometryB instanceof Pe){const e=this._geometryB;this.dispatchSegmentSegment(t,this._extendA,t.point0Ref,0,t.point1Ref,1,this._extendA,e,this._extendB,e.point0Ref,0,e.point1Ref,1,this._extendB,!1)}else this._geometryB instanceof we?this.computeSegmentLineString(t,this._extendA,this._geometryB,this._extendB,!1):this._geometryB instanceof De?this.dispatchSegmentArc(t,this._extendA,t.point0Ref,0,t.point1Ref,1,this._extendA,this._geometryB,this._extendB,this._extendB,!1):this._geometryB instanceof ze&&this.dispatchSegmentBsplineCurve(t,this._extendA,t.point0Ref,0,t.point1Ref,1,this._extendA,this._geometryB,this._extendB,!1)}handleLineString3d(t){if(this._geometryB instanceof we){const e=this._geometryB,i=Ti._workPointAA0,s=Ti._workPointAA1,n=Ti._workPointBB0,r=Ti._workPointBB1,o=t.numPoints(),a=e.numPoints();if(o>1&&a>1){t.pointAt(0,i);const c=1/(o-1),h=1/(a-1);let l,d,u,f=0;const g=this._extendA,p=this._extendB;t.pointAt(0,i);for(let m=1;m<o;m++,i.setFrom(s),f=l){l=m*c,d=0,t.pointAt(m,s),e.pointAt(0,n);for(let c=1;c<a;c++,n.setFrom(r),d=u)e.pointAt(c,r),u=c*h,this.dispatchSegmentSegment(t,1===m&&g,i,f,s,l,m+1===o&&g,e,1===c&&p,n,d,r,u,c+1===a&&p,!1)}}}else this._geometryB instanceof Pe?this.computeSegmentLineString(this._geometryB,this._extendB,t,this._extendA,!0):this._geometryB instanceof De?this.computeArcLineString(this._geometryB,this._extendB,t,this._extendA,!0):this._geometryB instanceof ze&&this.dispatchLineStringBSplineCurve(t,this._extendA,this._geometryB,this._extendB,!1)}handleArc3d(t){this._geometryB instanceof Pe?this.dispatchSegmentArc(this._geometryB,this._extendB,this._geometryB.point0Ref,0,this._geometryB.point1Ref,1,this._extendB,t,this._extendA,this._extendA,!0):this._geometryB instanceof we?this.computeArcLineString(t,this._extendA,this._geometryB,this._extendB,!1):this._geometryB instanceof De?this.dispatchArcArc(t,this._extendA,this._geometryB,this._extendB,!1):this._geometryB instanceof ze&&this.dispatchArcBsplineCurve3d(t,this._extendA,this._geometryB,this._extendB,!1)}handleBSplineCurve3d(t){this._geometryB instanceof Pe?this.dispatchSegmentBsplineCurve(this._geometryB,this._extendB,this._geometryB.point0Ref,0,this._geometryB.point1Ref,1,this._extendB,t,this._extendA,!0):this._geometryB instanceof we?this.dispatchLineStringBSplineCurve(this._geometryB,this._extendB,t,this._extendA,!0):this._geometryB instanceof De?this.dispatchArcBsplineCurve3d(this._geometryB,this._extendB,t,this._extendA,!0):this._geometryB instanceof Re&&this.dispatchBSplineCurve3dBSplineCurve3d(t,this._geometryB,!1)}handleBSplineCurve3dH(t){}}Ti._workVector2dA=J.create(),Ti._workPointAA0=Q.create(),Ti._workPointAA1=Q.create(),Ti._workPointBB0=Q.create(),Ti._workPointBB1=Q.create();class ki{static intersectionXYPairs(t,e,i,s,n=K.smallMetricDistance){const r=new Ci(void 0,e,i,s,n);if(i instanceof ie)t.dispatchToGeometryHandler(r);else if(i instanceof qe){const e=i.collectCurvePrimitives();for(const i of e)r.resetGeometry(!1,i,!1),t.dispatchToGeometryHandler(r)}return r.grabPairedResults()}static intersectionProjectedXYPairs(t,e,i,s,n,r=K.smallMetricDistance){const o=new Ci(t,i,s,n,r);return e.dispatchToGeometryHandler(o),o.grabPairedResults()}static intersectionXYZ(t,e,i,s){const n=new Ti(e,i,s);return t.dispatchToGeometryHandler(n),n.grabResults()}static allIntersectionsAmongPrimitivesXY(t,e=K.smallMetricDistance){const i=new Ci(void 0,!1,void 0,!1,e);for(let e=0;e<t.length;e++){const s=t[e];for(let n=e+1;n<t.length;n++)i.resetGeometry(!1,t[n],!1),s.dispatchToGeometryHandler(i)}return i.grabPairedResults()}static closeApproachProjectedXYPairs(t,e,i){const s=new Ai(e);return s.maxDistanceToAccept=i,t.dispatchToGeometryHandler(s),s.grabPairedResults()}static closestApproachProjectedXYPair(t,e){const i=t.range();i.extendRange(e.range());const s=i.low.distanceXY(i.high),n=this.closeApproachProjectedXYPairs(t,e,s);if(!n.length)return;let r=0,o=2*s;for(let t=0;t<n.length;++t){const e=n[t].detailA.point.distanceXY(n[t].detailB.point);e<o&&(r=t,o=e)}return n[r]}}class Fi extends We{isSameGeometryClass(t){return t instanceof Fi}announceToCurveProcessor(t,e=-1){return t.announcePath(this,e)}constructor(){super(),this.curveCollectionType="path"}static create(...t){const e=new Fi;for(const i of t)i instanceof ie?e.children.push(i):Array.isArray(i)&&i.length>0&&i[0]instanceof Q&&e.children.push(we.create(i));return e}static createArray(t){const e=new Fi;for(const i of t)e.children.push(i);return e}cloneStroked(t){const e=we.create();for(const i of this.children)i.emitStrokes(e,t);return Fi.create(e)}dgnBoundaryType(){return 1}cloneEmptyPeer(){return new Fi}dispatchToGeometryHandler(t){return t.handlePath(this)}}class Mi{constructor(t=K.smallMetricDistance,e=K.smallMetricDistance){this._chains=[],this._gapTolerance=t,this._snapTolerance=K.smallMetricDistance,this._planeTolerance=e}findAnyChainToConnect(t,e,i=-1){for(let s=0;s<this._chains.length;s++){if(i===s)continue;const n=this._chains[s];if(this._xyzWork1=n[n.length-1].endPoint(this._xyzWork1),this._xyzWork1.isAlmostEqual(t,e))return{chainIndex:s,atEnd:!0};if(this._xyzWork1=n[0].startPoint(this._xyzWork1),this._xyzWork1.isAlmostEqual(t,e))return{chainIndex:s,atEnd:!1}}}captureCurvePrimitive(t){this._snapTolerance<this._gapTolerance&&this.attachPrimitiveToAnyChain(t,this._snapTolerance)||this.attachPrimitiveToAnyChain(t,this._gapTolerance)||this._chains.push([t])}captureCurve(t){if(t instanceof ie)this.captureCurvePrimitive(t);else if(t instanceof qe&&void 0!==t.children)for(const e of t.children)this.captureCurve(e)}static simpleEndPointMove(t,e,i){if(t instanceof Pe)return e?t.point1Ref.setFrom(i):t.point0Ref.setFrom(i),!0;if(t instanceof we&&t.numPoints()>0){const s=e?t.numPoints()-1:0;return t.packedPoints.setAtCheckedPointIndex(s,i),!0}return!1}static moveHeadOrTail(t,e,i){const s=t.endPoint(),n=e.startPoint(),r=.001*K.smallMetricDistance,o=s.distanceXY(n);if(o<r)return!1;if(o<i&&(this.simpleEndPointMove(e,!1,s)||this.simpleEndPointMove(t,!0,n)))return!0;const a=ki.intersectionXYPairs(t,!0,e,!0);for(const r of a){const o=r.detailA,a=r.detailB,c=o.point.distanceXY(s),h=a.point.distanceXY(n);if(c<5*i&&h<5*i&&t instanceof De&&e instanceof De){const i=t.sweep.fractionToRadians(o.fraction);t.sweep.setStartEndRadians(t.sweep.startRadians,i);const s=e.sweep.fractionToRadians(a.fraction);return e.sweep.setStartEndRadians(s,e.sweep.endRadians),!0}}return!1}attachPrimitiveToAnyChain(t,e){if(t){this._xyzWork0=t.startPoint(this._xyzWork0);let i=this.findAnyChainToConnect(this._xyzWork0,e);if(i){if(i.atEnd){const s=this._chains[i.chainIndex],n=s.length-1;return this._chains[i.chainIndex].push(t),Mi.moveHeadOrTail(s[n],s[n+1],this._gapTolerance),this.searchAndMergeChainIndex(i.chainIndex,e),!0}{t.reverseInPlace();const s=this._chains[i.chainIndex];return s.splice(0,0,t),Mi.moveHeadOrTail(s[0],s[1],this._gapTolerance),this.searchAndMergeChainIndex(i.chainIndex,e),!0}}if(this._xyzWork0=t.endPoint(this._xyzWork0),i=this.findAnyChainToConnect(this._xyzWork0,e),i){if(i.atEnd){t.reverseInPlace();const s=this._chains[i.chainIndex],n=s.length-1;return this._chains[i.chainIndex].push(t),Mi.moveHeadOrTail(s[n],s[n+1],this._gapTolerance),this.searchAndMergeChainIndex(i.chainIndex,e),!0}{const s=this._chains[i.chainIndex];return s.splice(0,0,t),Mi.moveHeadOrTail(s[0],s[1],this._gapTolerance),this.searchAndMergeChainIndex(i.chainIndex,e),!0}}}return!1}mergeChainsForwardForward(t,e){const i=this._chains[t],s=this._chains[e];for(const t of s)i.push(t);s.length=0;const n=this._chains.length-1;e!==n&&(this._chains[e]=this._chains[n]),this._chains.pop()}reverseChain(t){const e=this._chains[t];e.reverse();for(const t of e)t.reverseInPlace()}searchAndMergeChainIndex(t,e){const i=this._chains[t],s=i.length-1;this._xyzWork0=i[0].startPoint(this._xyzWork0);let n=this.findAnyChainToConnect(this._xyzWork0,e,t);return n?(n.atEnd||this.reverseChain(n.chainIndex),void this.mergeChainsForwardForward(n.chainIndex,t)):(this._xyzWork0=i[s].endPoint(this._xyzWork0),n=this.findAnyChainToConnect(this._xyzWork0,e,t),n?(n.atEnd&&this.reverseChain(n.chainIndex),void this.mergeChainsForwardForward(t,n.chainIndex)):void 0)}promoteArrayToCurves(t,e){if(0!==t.length){if(e){const e=t[0],i=t[t.length-1];if(Mi._staticPointA=e.startPoint(Mi._staticPointA),Mi._staticPointB=i.endPoint(Mi._staticPointB),Mi.moveHeadOrTail(i,e,this._gapTolerance)&&(Mi._staticPointA=e.startPoint(Mi._staticPointA),Mi._staticPointB=i.endPoint(Mi._staticPointB)),Mi._staticPointA.isAlmostEqual(Mi._staticPointB,this._gapTolerance)){const e=Je.createRightHandedLocalToWorld(t);if(e){const i=e.inverse();if(i){const e=rr.curveArrayRange(t,i);if(void 0!==this._planeTolerance&&e.zLength()<=this._planeTolerance)return Ke.createArray(t)}}return Fi.createArray(t)}}return 1===t.length?t[0]:Fi.createArray(t)}}chainToLineString3d(t,e){if(0===t.length)return;const i=we.create();for(const s of t)s.emitStrokes(i,e);return i.removeDuplicatePoints(this._gapTolerance),i}grabResult(t=!1){const e=this._chains;if(0===e.length)return;if(1===e.length)return this.promoteArrayToCurves(e[0],t);const i=Ge.create();for(const s of e){const e=this.promoteArrayToCurves(s,t);i.tryAddChild(e)}return i}announceChainsAsLineString3d(t,e){const i=this._chains;if(1===i.length){const s=this.chainToLineString3d(i[0],e);s&&t(s)}else if(i.length>1)for(const s of i){const i=this.chainToLineString3d(s,e);i&&t(i)}}}!function(t){t[t.Unknown=0]="Unknown",t[t.Cap=1]="Cap",t[t.Extend=2]="Extend",t[t.Trim=-1]="Trim",t[t.JustGeometry=3]="JustGeometry",t[t.Gap=4]="Gap"}(F||(F={}));class bi{constructor(t,e,i){this.curve0=t,this.curve1=e,this.swingPoint=i,this.flexure=F.Unknown}static constructArc(t,e,i){if(void 0!==e&&K.isSameCoordinate(t.origin.distance(e),i.origin.distance(e))){const s=t.direction.angleToXY(i.direction),n=$.createStartEnd(e,t.origin),r=n.rotate90CCWXY();return De.create(e,n,r,At.createStartEndRadians(0,s.radians))}}shallowExtract(){return{curve0:this.curve0,curve1:this.curve1,fraction0:this.fraction0,fraction1:this.fraction1}}static link(t,e){t.nextJoint=e,e&&(e.previousJoint=t),t.curve1&&e&&!e.curve0?e.curve0=t.curve1:!t.curve1&&e&&e.curve0&&(t.curve1=e.curve0)}nextJointFraction0(t){return this.nextJoint&&void 0!==this.nextJoint.fraction0?this.nextJoint.fraction0:t}static addStrokes(t,e){e&&e.emitStrokes(t)}static addPoint(t,e){t.packedPoints.length>0&&(t.endPoint().isAlmostEqual(e)||t.packedPoints.push(e))}static collectStrokesFromChain(t,e,i=100){let s=-2*i;bi.visitJointsOnChain(t,(t=>{if(this.addStrokes(e,t.jointCurve),t.curve1&&void 0!==t.fraction1){const i=t.fraction1,s=t.nextJointFraction0(1);let n;0===i&&1===s?n=t.curve1.clone():i<s&&(n=t.curve1.clonePartialCurve(i,s)),n&&(t.jointCurve||this.addPoint(e,n.startPoint())),this.addStrokes(e,n)}return s++<i}),i)}static collectPrimitive(t,e){if(e){if(t.length>0){const i=t[t.length-1].endPoint(),s=e.startPoint();i.isAlmostEqual(s)||t.push(Pe.create(i,s))}t.push(e)}}static adjustJointToPrimitives(t){const e=t.jointCurve;if(e instanceof we){if(t.curve0){const i=t.curve0.endPoint(),s=e.startPoint();i.isAlmostEqual(s)||e.packedPoints.setAtCheckedPointIndex(0,i)}if(t.curve1){const i=t.curve1.startPoint(),s=e.endPoint();i.isAlmostEqual(s)||e.packedPoints.setAtCheckedPointIndex(e.packedPoints.length-1,i)}}}static collectCurvesFromChain(t,e,i=100){if(void 0===t)return;let s=-2*i;bi.visitJointsOnChain(t,(t=>{if(this.adjustJointToPrimitives(t),this.collectPrimitive(e,t.jointCurve),t.curve1&&void 0!==t.fraction1){const i=t.fraction1,s=t.nextJointFraction0(1);let n;0===i&&1===s?n=t.curve1.clone():i<s&&(n=t.curve1.clonePartialCurve(i,s)),this.collectPrimitive(e,n)}return s++<i}),i)}static annotateChain(t,e,i=100){t&&bi.visitJointsOnChain(t,(t=>(t.annotateJointMode(e),!0)),i)}static visitJointsOnChain(t,e,i=100){let s=t;if(s){let n=0;for(;void 0!==s;){if(n++>=i+5)return!0;if(!e(s))return!1;if(s=s.nextJoint,s===t)break}}return!0}annotateExtension(t){if(this.curve0&&this.curve1){const e=this.curve0.fractionToPointAndDerivative(1),i=this.curve1.fractionToPointAndDerivative(0),s=bt.closestApproachRay3dRay3d(e,i);if(s.approachType===S.Intersection&&s.detailA.fraction>=0&&s.detailB.fraction<=0){this.fraction0=1,this.fraction1=0,this.flexure=F.Extend;const n=e.getDirectionRef().angleToXY(i.getDirectionRef());if(t.needArc(n)){const t=bi.constructArc(e,this.curve0.baseCurveEnd,i);if(t)return void(this.jointCurve=t)}const r=t.numChamferPoints(n);if(r<=1)return void(this.jointCurve=we.create(e.origin,s.detailA.point,i.origin));if(r>1){const t=2*r,s=n.radians/t,o=bi.constructArc(e,this.curve0.baseCurveEnd,i);if(void 0!==o){const n=1/Math.cos(s),a=we.create();this.jointCurve=a,a.addPoint(e.origin);for(let e=0;e<r;e++){const i=(1+2*e)/t;a.addPoint(o.fractionAndRadialFractionToPoint(i,n))}return void a.addPoint(i.origin)}}}this.flexure=F.Gap,this.jointCurve=Pe.create(this.curve0.fractionToPoint(1),this.curve1.fractionToPoint(0)),this.fraction0=1,this.fraction1=0}}selectIntersectionIndexByFraction(t,e,i){let s=-1,n=Number.MAX_VALUE;for(let r=0;r<i.length;r++){const o=Math.abs(i[r].detailA.fraction-t)+Math.abs(i[r].detailB.fraction-e);o<n&&(n=o,s=r)}return s}annotateJointMode(t){if(!this.curve0&&this.curve1)this.flexure=F.Cap,this.fraction1=0;else if(this.curve0&&!this.curve1)this.flexure=F.Cap,this.fraction0=1;else if(this.curve0&&this.curve1)if(this.curve0.endPoint().isAlmostEqual(this.curve1.startPoint()))this.fraction0=1,this.fraction1=0,this.flexure=F.Trim;else if(this.curve0 instanceof Pe&&this.curve1 instanceof Pe){const e=this.curve0.fractionToPointAndDerivative(0),i=this.curve1.fractionToPointAndDerivative(0),s=bt.closestApproachRay3dRay3d(e,i);s.approachType===S.Intersection&&(this.fraction0=s.detailA.fraction,this.fraction1=s.detailB.fraction,this.fraction0>=1&&this.fraction1<=0?this.annotateExtension(t):this.fraction0<1&&this.fraction1>0?this.flexure=F.Trim:this.fraction0>1&&this.fraction1>1&&(this.flexure=F.Gap,this.jointCurve=Pe.create(this.curve0.fractionToPoint(1),this.curve1.fractionToPoint(0)),this.fraction0=1,this.fraction1=0))}else{const e=ki.intersectionXYPairs(this.curve0,!1,this.curve1,!1),i=this.selectIntersectionIndexByFraction(1,0,e);i>=0?(this.flexure=F.Trim,this.fraction0=e[i].detailA.fraction,this.fraction1=e[i].detailB.fraction):this.annotateExtension(t)}}static removeDegeneratePrimitives(t,e,i){let s=t,n=0,r=0;if(s)for(;void 0!==s&&r++<i;){const i=s.nextJoint;if(s&&i&&s.previousJoint&&i.nextJoint&&void 0!==s.fraction1&&void 0!==i.fraction0){const r=s.fraction1,o=i.fraction0,a=i.fraction1,c=i.nextJoint.fraction0,h=r>=o||r>1;if(h&&(void 0!==a&&a>1||void 0!==a&&void 0!==c&&a>=c)){const t=i.nextJoint,n=new bi(s.curve0,t.curve1,void 0);bi.link(s.previousJoint,n),bi.link(n,t.nextJoint),n.annotateJointMode(e),n.previousJoint.annotateJointMode(e),n.nextJoint&&n.nextJoint.annotateJointMode(e)}else if(h){const r=new bi(s.curve0,i.curve1,void 0);if(bi.link(s.previousJoint,r),bi.link(r,i.nextJoint),r.annotateJointMode(e),r.previousJoint.annotateJointMode(e),r.nextJoint.annotateJointMode(e),n++,s===t&&(t=r),s=r,n>=1)return{newStart:t,numJointRemoved:n}}}if(s=s.nextJoint,s===t)break}return{newStart:t,numJointRemoved:n}}}class Ei{constructor(){}static createOffsetSegment(t,e,i){if($.createStartEnd(t,e,this._unitAlong),this._unitAlong.normalizeInPlace()){this._unitAlong.rotate90CCWXY(this._unitPerp);const s=Pe.create(t.plusScaled(this._unitPerp,i,this._offsetA),e.plusScaled(this._unitPerp,i,this._offsetB));return Xi.applyBasePoints(s,t.clone(),e.clone()),s}}constructPolygonWireXYOffset(t,e,i){e&&!t[0].isAlmostEqual(t[t.length-1])&&(e=!1);const s=_e.create(i),n=t.length;let r,o=Ei.createOffsetSegment(t[0],t[1],s.leftOffsetDistance),a=new bi(void 0,o,t[0]),c=a;for(let e=1;e+1<n;e++){const i=Ei.createOffsetSegment(t[e],t[e+1],s.leftOffsetDistance);r=new bi(o,i,t[e]),bi.link(c,r),c=r,o=i}e?bi.link(c,a):(r=new bi(o,void 0,t[n-1]),bi.link(c,r)),bi.annotateChain(a,s,n);for(let t=0;t++<5;){const t=bi.removeDegeneratePrimitives(a,s,n);if(a=t.newStart,0===t.numJointRemoved)break}const h=we.create();if(bi.collectStrokesFromChain(a,h,n),h.packedPoints.length>1)return h.packedPoints.front().isAlmostEqual(h.packedPoints.back())?Ke.create(h):Fi.create(h)}}Ei._unitAlong=$.create(),Ei._unitPerp=$.create(),Ei._offsetA=Q.create(),Ei._offsetB=Q.create();class Xi{constructor(){}static applyBasePoints(t,e,i){return void 0!==t&&(void 0!==e&&(t.baseCurveStart=e),void 0!==i&&(t.baseCurveEnd=i)),t}static createSingleOffsetPrimitiveXY(t,e){const i=t.constructOffsetXY(e);if(void 0!==i){if(Array.isArray(i)){const e=t.collectCurvePrimitives(void 0,!0,!0);if(e.length!==i.length)return;for(let t=0;t<e.length;++t)this.applyBasePoints(i[t],e[t].startPoint(),e[t].endPoint());return i}return this.applyBasePoints(i,t.startPoint(),t.endPoint())}}static constructCurveXYOffset(t,e){const i=t instanceof Ke,s=ve.create(e),n=[];for(const e of t.children){const t=Xi.createSingleOffsetPrimitiveXY(e,s);if(void 0===t);else if(t instanceof ie)n.push(t);else if(Array.isArray(t))for(const e of t)e instanceof ie&&n.push(e)}let r,o,a,c;for(const t of n)t&&(o=new bi(r,t,t.fractionToPoint(0)),void 0!==o&&void 0===c&&(c=o),a&&bi.link(a,o),a=o,r=t);c&&a&&t instanceof Ke&&bi.link(a,c);const h=n.length;bi.annotateChain(c,s.jointOptions,h);const l=[];return bi.collectCurvesFromChain(c,l,h),rr.createLoopPathOrBagOfCurves(l,i,!0)}}class Ri{static sumLengths(t){let e=0;if(t instanceof ie)e+=t.curveLength();else if(t instanceof qe)e+=t.sumLengths();else if(Array.isArray(t))for(const i of t)e+=this.sumLengths(i);return e}static extendRange(t,e){if(Array.isArray(e))for(const i of e)this.extendRange(t,i);else e.extendRange(t);return t}static appendXYOffsets(t,e,i){let s=0;if(t instanceof ie){const n=Xi.constructCurveXYOffset(Fi.create(t),e);n&&(s+=this.sumLengths(n),i.push(n))}else if(t instanceof Ke||t instanceof Fi){const n=Xi.constructCurveXYOffset(t,e);n&&(s+=this.sumLengths(n),i.push(n))}else if(t instanceof Ge)for(const n of t.children)s+=this.appendXYOffsets(n,e,i);else if(Array.isArray(t))for(const n of t)s+=this.appendXYOffsets(n,e,i);return s}static collectInsideAndOutsideXYOffsets(t,e,i){const s=new Mi(i);for(const e of t)s.captureCurve(e);const n=s.grabResult(!0),r=[],o=[];return Ri.appendXYOffsets(n,e,r)>Ri.appendXYOffsets(n,-e,o)?{outsideOffsets:r,insideOffsets:o,chains:n}:{insideOffsets:r,outsideOffsets:o,chains:n}}static constructCurveXYOffset(t,e){return Xi.constructCurveXYOffset(t,e)}static createSingleOffsetPrimitiveXY(t,e){return Xi.createSingleOffsetPrimitiveXY(t,e)}static collectChains(t,e=K.smallMetricDistance,i=K.smallMetricDistance){const s=new Mi(e,i);for(const e of t)s.captureCurve(e);return s.grabResult(!0)}static collectChainsAsLineString3d(t,e,i,s=K.smallMetricDistance,n=K.smallMetricDistance){const r=new Mi(s,n);for(const e of t)r.captureCurve(e);r.announceChainsAsLineString3d(e,i)}}class zi{constructor(){this.world=new Q,this.local=new Q,this.a=0,this.closestEdgeIndex=0,this.closestEdgeParam=0}invalidate(){this.world.setZero(),this.local.setZero(),this.a=0,this.closestEdgeIndex=0,this.closestEdgeParam=0}static create(t){return void 0===t?t=new zi:t.invalidate(),t}copyContentsFrom(t){this.world.setFrom(t.world),this.local.setFrom(t.local),this.a=t.a,this.closestEdgeIndex=t.closestEdgeIndex,this.closestEdgeParam=t.closestEdgeParam}get isValid(){return!this.local.isZero}get isInsideOrOn(){return this.isValid&&this.local.x>=0&&this.local.y>=0&&this.local.z>=0}get classify(){if(!this.isValid)return _.Unknown;if(this.isInsideOrOn){let t=0;return 0===Math.abs(this.local.x)&&++t,0===Math.abs(this.local.y)&&++t,0===Math.abs(this.local.z)&&++t,2===t?_.OnPolygonVertex:1===t?_.OnPolygonEdgeInterior:_.InsidePolygonProjectsToEdgeInterior}return 0===this.closestEdgeParam?_.OutsidePolygonProjectsToVertex:_.OutsidePolygonProjectsToEdgeInterior}}class Di{constructor(t,e,i){this.points=[],this.points.push(t),this.points.push(e),this.points.push(i),this.edgeLength2=[],this.edgeLength2.push(e.distanceSquared(i)),this.edgeLength2.push(t.distanceSquared(i)),this.edgeLength2.push(t.distanceSquared(e))}set(t,e,i){this.points[0].setFromPoint3d(t),this.points[1].setFromPoint3d(e),this.points[2].setFromPoint3d(i),this.edgeLength2[0]=this.points[1].distanceSquared(this.points[2]),this.edgeLength2[1]=this.points[0].distanceSquared(this.points[2]),this.edgeLength2[2]=this.points[0].distanceSquared(this.points[1])}setFrom(t){for(let e=0;e<3;++e)this.points[e].setFromPoint3d(t.points[e]),this.edgeLength2[e]=t.edgeLength2[e]}static createXYZXYZXYZ(t,e,i,s,n,r,o,a,c,h){return h?(h.points[0].set(t,e,i),h.points[1].set(s,n,r),h.points[2].set(o,a,c),h):new this(Q.create(t,e,i),Q.create(s,n,r),Q.create(o,a,c))}static create(t,e,i,s){return s?(s.set(t,e,i),s):new this(t.clone(),e.clone(),i.clone())}clone(t){return Di.create(this.points[0],this.points[1],this.points[2],t)}cloneTransformed(t,e){return Di.create(t.multiplyPoint3d(this.points[0],e?.points[0]),t.multiplyPoint3d(this.points[1],e?.points[1]),t.multiplyPoint3d(this.points[2],e?.points[2]),e)}get area(){return.5*this.points[0].crossProductToPointsMagnitude(this.points[1],this.points[2])}edgeLengthSquared(t){return this.edgeLength2[K.cyclic3dAxis(t)]}edgeLength(t){return Math.sqrt(this.edgeLengthSquared(t))}get aspectRatio(){return K.safeDivideFraction(this.area,this.edgeLengthSquared(0)+this.edgeLengthSquared(1)+this.edgeLengthSquared(2),0)}get perimeter(){return this.edgeLength(0)+this.edgeLength(1)+this.edgeLength(2)}normal(t){const e=this.points[0].crossProductToPoints(this.points[1],this.points[2],t);if(e.tryNormalizeInPlace())return e}fractionToPoint(t,e,i,s){return Q.createAdd3Scaled(this.points[0],t,this.points[1],e,this.points[2],i,s)}pointToFraction(t,e){const i=Di._workVector0=this.normal(Di._workVector0);if(void 0===i)return zi.create(e);const s=Di._workRay=bt.create(t,i,Di._workRay);return this.intersectRay3d(s,e)}static edgeOppositeVertexIndexToStartVertexIndex(t){return K.cyclic3dAxis(t+1)}static edgeStartVertexIndexToOppositeVertexIndex(t){return K.cyclic3dAxis(t-1)}static isInsideTriangle(t,e,i){return t>0&&e>0&&i>0}static isInsideOrOnTriangle(t,e,i){return t>=0&&e>=0&&i>=0}static isInRegionBeyondEdge(t,e,i){return t<0&&e>=0&&i>=0?0:t>=0&&e<0&&i>=0?1:t>=0&&e>=0&&i<0?2:-1}static isInRegionBeyondVertex(t,e,i){return e<0&&i<0?0:t<0&&i<0?1:t<0&&e<0?2:-1}static isOnVertex(t,e,i){return 1===t&&0===e&&0===i?0:0===t&&1===e&&0===i?1:0===t&&0===e&&1===i?2:-1}static isOnBoundedEdge(t,e,i){return 0===t&&e>0&&i>0?0:t>0&&0===e&&i>0?1:t>0&&e>0&&0===i?2:-1}static indexOfMinimum(t){let e=0,i=t(0);const s=t(1);return i>s&&(e=1,i=s),i>t(2)&&(e=2),e}distanceSquared(t,e,i,s,n,r){return-this.edgeLengthSquared(0)*(n-e)*(r-i)-this.edgeLengthSquared(1)*(r-i)*(s-t)-this.edgeLengthSquared(2)*(s-t)*(n-e)}closestVertexIndex(t,e,i){return Di.indexOfMinimum((s=>{const n=Di._workPoint=Q.createZero(Di._workPoint);return n.setAt(s,1),this.distanceSquared(n.x,n.y,n.z,t,e,i)}))}dotProductOfEdgeVectorsAtVertex(t){const e=K.cyclic3dAxis(t),i=K.cyclic3dAxis(e+1),s=K.cyclic3dAxis(i+1);return K.dotProductXYZXYZ(this.points[i].x-this.points[e].x,this.points[i].y-this.points[e].y,this.points[i].z-this.points[e].z,this.points[s].x-this.points[e].x,this.points[s].y-this.points[e].y,this.points[s].z-this.points[e].z)}computeProjectionToEdge(t,e){t=K.cyclic3dAxis(t);const i=K.cyclic3dAxis(t+1);return e[K.cyclic3dAxis(i+1)]+e[t]*this.dotProductOfEdgeVectorsAtVertex(i)/this.edgeLengthSquared(t)}closestPoint(t,i,s){const n=[t,i,s];let r=-1,o=0;return Di.isInsideTriangle(t,i,s)?(r=Di.indexOfMinimum((t=>n[t]*n[t]/this.edgeLengthSquared(t))),o=this.computeProjectionToEdge(r,n)):(r=Di.isInRegionBeyondVertex(t,i,s))>=0?(r=K.cyclic3dAxis(r+1),o=this.computeProjectionToEdge(r,n),(o<0||o>1)&&(r=K.cyclic3dAxis(r+1),o=this.computeProjectionToEdge(r,n),(o<0||o>1)&&(o=0,r=Di.edgeStartVertexIndexToOppositeVertexIndex(this.closestVertexIndex(t,i,s))))):(r=Di.isInRegionBeyondEdge(t,i,s))>=0?(o=this.computeProjectionToEdge(r,n),o<0?o=0:o>1&&(o=0,r=K.cyclic3dAxis(r+1))):(r=Di.isOnBoundedEdge(t,i,s))>=0?o=1-n[Di.edgeOppositeVertexIndexToStartVertexIndex(r)]:(r=Di.isOnVertex(t,i,s))>=0&&(o=0,r=Di.edgeStartVertexIndexToOppositeVertexIndex(r)),e(0===r||1===r||2===r),{closestEdgeIndex:r<0?-1:Di.edgeOppositeVertexIndexToStartVertexIndex(r),closestEdgeParam:o}}intersectRay3d(t,e){e=zi.create(e);const i=t.origin,s=t.direction,n=Di._workVector0=$.createStartEnd(this.points[0],this.points[1],Di._workVector0),r=Di._workVector1=$.createStartEnd(this.points[0],this.points[2],Di._workVector1),o=Di._workMatrix=xt.createColumns(n,r,s,Di._workMatrix),a=$.createStartEnd(this.points[0],i,Di._workVector0),c=Di._workVector1;if(void 0===o.multiplyInverse(a,c))return e;e.a=-c.z,t.fractionToPoint(e.a,e.world),e.local.set(1-c.x-c.y,c.x,c.y);const h=this.closestPoint(e.local.x,e.local.y,e.local.z);return e.closestEdgeIndex=h.closestEdgeIndex,e.closestEdgeParam=h.closestEdgeParam,e}intersectSegment(t,e,i){return Di._workRay=bt.createStartEnd(t,e,Di._workRay),this.intersectRay3d(Di._workRay,i)}snapLocationToEdge(t,e=K.smallMetricDistance,i=K.smallFloatingPoint){if(!t.isValid)return!1;if(i>0){let e=0,s=0;for(let n=0;n<3;n++){const r=Math.abs(t.local.at(n));r>0&&r<i&&(t.local.setAt(n,0),e++),s+=t.local.at(n)}if(e>0&&s>0)return t.local.scaleInPlace(1/s),1===e?(t.closestEdgeIndex=Di.edgeOppositeVertexIndexToStartVertexIndex(Di.isOnBoundedEdge(t.local.x,t.local.y,t.local.z)),t.closestEdgeParam=1-t.local.at(t.closestEdgeIndex)):(t.closestEdgeIndex=Di.isOnVertex(t.local.x,t.local.y,t.local.z),t.closestEdgeParam=0),this.fractionToPoint(t.local.x,t.local.y,t.local.z,t.world),!0}if(e>0){const i=t.closestEdgeIndex,s=(i+1)%3,n=(s+1)%3,r=Di._workPoint=this.points[i].interpolate(t.closestEdgeParam,this.points[s],Di._workPoint),o=t.world.distance(r);if(o>0&&o<e)return t.local.setAt(i,1-t.closestEdgeParam),t.local.setAt(s,t.closestEdgeParam),t.local.setAt(n,0),t.world.setFrom(r),!0}return!1}dotProductOfCrossProductsFromOrigin(t){return Di._workVector0=this.points[0].crossProductToPoints(this.points[1],this.points[2],Di._workVector0),Di._workVector1=t.points[0].crossProductToPoints(t.points[1],t.points[2],Di._workVector1),Di._workVector0.dotProduct(Di._workVector1)}centroid(t){return Q.create((this.points[0].x+this.points[1].x+this.points[2].x)/3,(this.points[0].y+this.points[1].y+this.points[2].y)/3,(this.points[0].z+this.points[1].z+this.points[2].z)/3,t)}incenter(t){const e=this.edgeLength(0),i=this.edgeLength(1),s=this.edgeLength(2),n=K.safeDivideFraction(1,e+i+s,0);return this.fractionToPoint(n*e,n*i,n*s,t)}circumcenter(t){const e=this.edgeLengthSquared(0),i=this.edgeLengthSquared(1),s=this.edgeLengthSquared(2),n=e*(i+s-e),r=i*(s+e-i),o=s*(e+i-s),a=K.safeDivideFraction(1,n+r+o,0);return this.fractionToPoint(a*n,a*r,a*o,t)}isAlmostEqual(t,e){return this.points[0].isAlmostEqual(t.points[0],e)&&this.points[1].isAlmostEqual(t.points[1],e)&&this.points[2].isAlmostEqual(t.points[2],e)}}class Yi{constructor(t=0){this._parentArray=[];for(let e=0;e<t;e++)this._parentArray.push(e)}get length(){return this._parentArray.length}isValidIndex(t){return 0<=t&&t<this._parentArray.length}addLeaf(){const t=this._parentArray.length;return this._parentArray.push(t),t}findRoot(t){if(!this.isValidIndex(t))return t;let e=t,i=this._parentArray[t];for(;i!==e;)e=i,i=this._parentArray[e];const s=e;for(e=t;e!==s;)i=this._parentArray[e],this._parentArray[e]=s,e=i;return s}mergeSubsets(t,e){if(!this.isValidIndex(t)||!this.isValidIndex(e))return t;const i=this.findRoot(t),s=this.findRoot(e);return i!==s&&(this._parentArray[i]=s),this.findRoot(t)}askParent(t){return this.isValidIndex(t)?this._parentArray[t]:t}countRoots(){let t=0;const e=this._parentArray.length;for(let i=0;i<e;i++)this._parentArray[i]===i&&t++;return t}countNonTrivialPaths(){let t=0;const e=this._parentArray.length;for(let i=0;i<e;i++){const e=this._parentArray[i];e!==i&&this._parentArray[e]!==e&&t++}return t}collectRootIndices(){const t=[],e=this._parentArray.length;for(let i=0;i<e;i++)this._parentArray[i]===i&&t.push(i);return t}}class Ni{constructor(t,e){this._originalFreeMasks=t,this._freeMasks=t,this._firstFreeMask=e}static create(t){let e=0,i=1;for(let s=0;s<32;s++){if(0!=(i&t)){e=i;break}i<<=1}if(0!==e)return new Ni(t,e)}grabMask(){let t=this._firstFreeMask;if(0===this._freeMasks)return 0;for(;!(t&this._freeMasks);)t<<=1;return this._freeMasks&=~t,t}dropMask(t){t&=this._originalFreeMasks,this._freeMasks|=t}}(L=M||(M={}))[L.EXTERIOR=1]="EXTERIOR",L[L.BOUNDARY_EDGE=2]="BOUNDARY_EDGE",L[L.PRIMARY_EDGE=4]="PRIMARY_EDGE",L[L.VISITED=16]="VISITED",L[L.TRIANGULATED_FACE=256]="TRIANGULATED_FACE",L[L.NULL_FACE=512]="NULL_FACE",L[L.NULL_MASK=0]="NULL_MASK",L[L.ALL_GRAB_DROP_MASKS=4293918720]="ALL_GRAB_DROP_MASKS",L[L.ALL_MASK=4294967295]="ALL_MASK";class Oi{get id(){return this._id}get facePredecessor(){return this._facePredecessor}get faceSuccessor(){return this._faceSuccessor}get edgeMate(){return this._edgeMate}faceStepY(t){let e=this;if(t>0)for(let i=0;i<t;i++)e=e.faceSuccessor;else if(t<0)for(let i=0;i>t;i--)e=e.facePredecessor;return e.y}static createHalfEdgePair(t){const e=new Oi,i=new Oi;return t&&(t.push(e),t.push(i)),Oi.setFaceLinks(e,i),Oi.setFaceLinks(i,e),Oi.setEdgeMates(e,i),e}static createHalfEdgePairWithCoordinates(t=0,e=0,i=0,s=0,n=0,r=0,o=0,a=0,c){const h=Oi.createHalfEdgePair(c),l=h._edgeMate;return h.x=t,h.y=e,h.z=i,h.i=s,l.x=n,l.y=r,l.z=o,l.i=a,h}static setFaceLinks(t,e){t._faceSuccessor=e,e._facePredecessor=t}static setEdgeMates(t,e){t._edgeMate=e,e._edgeMate=t}static splitEdge(t,e=0,i=0,s=0,n=0,r){const o=new Oi(e,i,s,n),a=new Oi(e,i,s,n);if(r&&(r.push(o),r.push(a)),void 0===t)o._faceSuccessor=o._facePredecessor=o,a._faceSuccessor=a._facePredecessor=a,Oi.setEdgeMates(o,a);else{const e=t._faceSuccessor,i=t._edgeMate,s=i._faceSuccessor;Oi.setFaceLinks(o,e),Oi.setFaceLinks(t,o),Oi.setFaceLinks(i,a),Oi.setFaceLinks(a,s),Oi.setEdgeMates(o,i),Oi.setEdgeMates(a,t),this.transferEdgeProperties(t,o),this.transferEdgeProperties(i,a)}return o}static splitEdgeCreateSliverFace(t,e){const i=new Oi,s=new Oi,n=t.edgeMate;return e&&(e.push(i),e.push(s)),i._faceSuccessor=i._facePredecessor=s,s._faceSuccessor=s._facePredecessor=i,Oi.setEdgeMates(i,n),Oi.setEdgeMates(s,t),i.copyDataFrom(t,!0,!0,!1,!1),s.copyDataFrom(n,!0,!0,!1,!1),i}static transferEdgeProperties(t,e){e.edgeTag=t.edgeTag;for(const i of this._edgePropertyMasks)t.getMask(i)?e.setMask(i):e.clearMask(i)}constructor(t=0,e=0,i=0,s=0){this._id=Oi._totalNodesCreated++,this.i=s,this.maskBits=0,this.x=t,this.y=e,this.z=i,this.sortAngle=void 0,this.sortData=void 0,this.edgeTag=void 0,this.faceTag=void 0,this._facePredecessor=this,this._faceSuccessor=this,this._edgeMate=this}get vertexSuccessor(){return this.facePredecessor.edgeMate}get vertexPredecessor(){return this.edgeMate.faceSuccessor}setMask(t){this.maskBits|=t}getMask(t){return this.maskBits&t}clearMask(t){this.maskBits&=~t}setMaskAroundVertex(t){let e=this;do{e.setMask(t),e=e.vertexSuccessor}while(e!==this)}setXYZAroundVertex(t,e,i){let s=this;do{s.x=t,s.y=e,s.z=i,s=s.vertexSuccessor}while(s!==this)}setMaskAroundFace(t){let e=this;do{e.setMask(t),e=e.faceSuccessor}while(e!==this)}setMaskAroundEdge(t){this.setMask(t),this.edgeMate.setMask(t)}clearMaskAroundEdge(t){this.clearMask(t),this.edgeMate.clearMask(t)}countEdgesAroundFace(){let t=0,e=this;do{t++,e=e.faceSuccessor}while(e!==this);return t}findAroundVertex(t){let e=this;do{if(e===t)return!0;e=e.vertexSuccessor}while(e!==this);return!1}findAroundFace(t){let e=this;do{if(e===t)return!0;e=e.faceSuccessor}while(e!==this);return!1}isMaskedAroundFace(t,e=!0){let i=this;if(e)do{if(!i.isMaskSet(t))return!1;i=i.faceSuccessor}while(i!==this);else do{if(i.isMaskSet(t))return!1;i=i.faceSuccessor}while(i!==this);return!0}setMaskAndEdgeTagAroundFace(t,e,i=!1){let s=this;do{if(s.setMask(t),s.edgeTag=e,i){const i=s.edgeMate;i.edgeTag=e,i.setMask(t)}s=s.faceSuccessor}while(s!==this)}countEdgesAroundVertex(){let t=0,e=this;do{t++,e=e.vertexSuccessor}while(e!==this);return t}countMaskAroundFace(t,e=!0){let i=0,s=this;if(e)do{s.isMaskSet(t)&&i++,s=s.faceSuccessor}while(s!==this);else do{s.isMaskSet(t)||i++,s=s.faceSuccessor}while(s!==this);return i}countMaskAroundVertex(t,e=!0){let i=0,s=this;if(e)do{s.isMaskSet(t)&&i++,s=s.vertexSuccessor}while(s!==this);else do{s.isMaskSet(t)||i++,s=s.vertexSuccessor}while(s!==this);return i}findMaskAroundVertex(t,e=!0){let i=this;do{if(i.isMaskSet(t)===e)return i;i=i.vertexSuccessor}while(i!==this)}findMaskAroundFace(t,e=!0){let i=this;do{if(i.isMaskSet(t)===e)return i;i=i.faceSuccessor}while(i!==this)}findMaskAroundEdge(t,e=!0){if(this.isMaskSet(t)===e)return this;const i=this.edgeMate;return i.isMaskSet(t)===e?i:void 0}testAndSetMask(t){const e=this.maskBits&t;return this.maskBits|=t,e}setXYZFrom(t){this.x=t.x,this.y=t.y,this.z=t.z}setXYZ(t){this.x=t.x,this.y=t.y,this.z=t.z}isMaskSet(t){return 0!=(this.maskBits&t)}static filterIsMaskOn(t,e){return t.isMaskSet(e)}static filterIsMaskOff(t,e){return!t.isMaskSet(e)}static createEdgeXYXY(t,e,i,s,n,r){const o=new Oi(e,i),a=new Oi(n,r);return o._faceSuccessor=o._facePredecessor=o._edgeMate=a,a._faceSuccessor=a._facePredecessor=a._edgeMate=o,o._id=t,a._id=s,o}static pinch(t,e){if(t!==e){const i=t._facePredecessor,s=e._facePredecessor;e._facePredecessor=i,t._facePredecessor=s,s._faceSuccessor=t,i._faceSuccessor=e}}yankFromVertexLoop(){const t=this.edgeMate.faceSuccessor;if(t!==this)return Oi.pinch(this,t),t}decommission(){this._facePredecessor=void 0,this._faceSuccessor=void 0,this._edgeMate=void 0}static nodeToSelf(t){return t}static nodeToId(t){return t.id}static nodeToIdString(t){return t.id.toString()}static nodeToIdMaskXY(t){return{id:t.id,mask:Oi.nodeToMaskString(t),xy:[t.x,t.y]}}static nodeToIdXYString(t){return`${t.id.toString()}+${Oi.nodeToMaskString(t)}[${t.x},${t.y}]`}static nodeToIdXYZString(t){return`[${t.id.toString()}: ${t.x},${t.y},${t.z}]`}static nodeToMaskString(t){let e="";return t.isMaskSet(M.BOUNDARY_EDGE)&&(e+="B"),t.isMaskSet(M.PRIMARY_EDGE)&&(e+="P"),t.isMaskSet(M.EXTERIOR)&&(e+="X"),t.isMaskSet(M.NULL_FACE)&&(e+="N"),e}static nodeToXY(t){return[t.x,t.y]}vectorToFaceSuccessorXY(t){return J.create(this.faceSuccessor.x-this.x,this.faceSuccessor.y-this.y,t)}vectorToFaceSuccessor(t){const e=this.faceSuccessor;return $.create(e.x-this.x,e.y-this.y,e.z-this.z,t)}vectorToFacePredecessor(t){const e=this.facePredecessor;return $.create(e.x-this.x,e.y-this.y,e.z-this.z,t)}static isNodeVisibleInSector(t,e){if(e.vertexSuccessor===e)return!0;const i=e.faceSuccessor,s=e.facePredecessor,n=this.crossProductXYToTargets(e,i,t),r=this.crossProductXYToTargets(s,e,t);if(n>0&&r>0)return!0;const o=this.crossProductXYToTargets(s,e,i);return r<=0&&n<=0?0===r&&0===n&&0===o&&(s===i&&e.vertexSuccessor!==e?t===i:Oi.dotProductNodeToNodeVectorsXY(s,e,e,t)>0):0===o&&0!==r&&0!==n?s!==i:o<0}static crossProductXYToTargets(t,e,i){return K.crossProductXYXY(e.x-t.x,e.y-t.y,i.x-t.x,i.y-t.y)}static dotProductNodeToNodeVectorsXY(t,e,i,s){return K.dotProductXYXY(e.x-t.x,e.y-t.y,s.x-i.x,s.y-i.y)}static crossProductXYAlongChain(t,e,i){return K.crossProductXYXY(e.x-t.x,e.y-t.y,i.x-e.x,i.y-e.y)}static isSectorConvex(t,e,i){const s=Oi.crossProductXYAlongChain(t,e,i);return s>0||!(s<0)&&Oi.dotProductNodeToNodeVectorsXY(t,e,e,i)>0}isSectorConvex(){return Oi.isSectorConvex(this.facePredecessor,this,this.faceSuccessor)}isFaceConvex(){let t=this;do{if(!t.isSectorConvex())return!1;t=t.faceSuccessor}while(t!==this);return!0}isolateEdge(){const t=this.edgeMate;this.yankFromVertexLoop(),t.yankFromVertexLoop()}get isIsolatedEdge(){return this===this.vertexSuccessor&&this.edgeMate===this.edgeMate.vertexSuccessor}belowYX(t){return this.y<t.y||!(this.y>t.y)&&this.x<t.x}static testNodeMaskNotExterior(t){return!t.isMaskSet(M.EXTERIOR)}static testMateMaskExterior(t){return t.edgeMate.isMaskSet(M.EXTERIOR)}static sectorSweepRadiansXYZ(t,e){const i=t.faceSuccessor,s=t.facePredecessor;return W.orientedRadiansBetweenVectorsXYZ(i.x-t.x,i.y-t.y,i.z-t.z,s.x-t.x,s.y-t.y,s.z-t.z,e.x,e.y,e.z,!0)}static testFacePositiveAreaXY(t){return t.countEdgesAroundFace()>2&&t.signedFaceArea()>0}isEqualXY(t){return this.x===t.x&&this.y===t.y}distanceXY(t){return K.distanceXYXY(this.x,this.y,t.x,t.y)}distanceXYZ(t){return K.distanceXYZXYZ(this.x,this.y,this.z,t.x,t.y,t.z)}collectAroundFace(t){const e=[];let i=this;do{e.push(t?t(i):i),i=i.faceSuccessor}while(i!==this);return e}collectMaskedEdgesAroundVertex(t,e=!0,i){void 0===i?i=[]:i.length=0;let s=this;do{s.isMaskSet(t)===e&&i.push(s),s=s.vertexSuccessor}while(s!==this);return i}collectAroundVertex(t){const e=[];let i=this;do{e.push(t?t(i):i),i=i.vertexSuccessor}while(i!==this);return e}sumAroundFace(t){let e=this,i=0;do{i+=t(e),e=e.faceSuccessor}while(e!==this);return i}sumAroundVertex(t){let e=this,i=0;do{i+=t(e),e=e.vertexSuccessor}while(e!==this);return i}clearMaskAroundFace(t){let e=this;do{e.clearMask(t),e=e.faceSuccessor}while(e!==this)}clearMaskAroundVertex(t){let e=this;do{e.clearMask(t),e=e.vertexSuccessor}while(e!==this)}signedFaceArea(){let t=0;const e=this.y;let i,s,n=0,r=0,o=this.x,a=this;do{s=a.faceSuccessor,i=s.x,r=s.y-e,t+=(o-i)*(n+r),o=i,n=r,a=s}while(a!==this);return.5*t}fractionToPoint2d(t,e){const i=this.faceSuccessor;return H.create(this.x+(i.x-this.x)*t,this.y+(i.y-this.y)*t,e)}fractionToPoint3d(t,e){const i=this.faceSuccessor;return Q.create(this.x+(i.x-this.x)*t,this.y+(i.y-this.y)*t,this.z+(i.z-this.z)*t,e)}fractionAlongAndPerpendicularToPoint2d(t,e,i){const s=this.faceSuccessor,n=s.x-this.x,r=s.y-this.y;return H.create(this.x+n*t-r*e,this.y+r*t+n*e,i)}getPoint3d(t){return Q.create(this.x,this.y,this.z,t)}getPoint2d(t){return H.create(this.x,this.y,t)}getVector3dAlongEdge(t){const e=this.faceSuccessor;return $.create(e.x-this.x,e.y-this.y,e.z-this.z,t)}getVector2dAlongEdge(t){const e=this.faceSuccessor;return J.create(e.x-this.x,e.y-this.y,t)}fractionToX(t){const e=this.faceSuccessor;return this.x+(e.x-this.x)*t}fractionToY(t){const e=this.faceSuccessor;return this.y+(e.y-this.y)*t}fractionToZ(t){const e=this.faceSuccessor;return this.z+(e.z-this.z)*t}static transverseIntersectionFractions(t,e,i){const s=t.faceSuccessor,n=e.faceSuccessor;if(i||(i=J.create()),Ft.linearSystem2d(s.x-t.x,e.x-n.x,s.y-t.y,e.y-n.y,e.x-t.x,e.y-t.y,i))return i}static horizontalScanFraction(t,e){const i=t.faceSuccessor,s=i.y-t.y;return K.isSameCoordinate(e,t.y)&&K.isSameCoordinate(e,i.y)?t:K.isSameCoordinate(s,0)?void 0:K.conditionalDivideFraction(e-t.y,s)}static horizontalScanFraction01(t,e){const i=t.faceSuccessor,s=i.y-t.y;if(K.isSameCoordinate(e,t.y)&&K.isSameCoordinate(e,i.y))return;if(K.isSameCoordinate(s,0))return;const n=K.conditionalDivideFraction(e-t.y,s);return void 0!==n&&n>=0&&n<=1?n:void 0}copyDataFrom(t,e,i,s,n){e&&(this.x=t.x,this.y=t.y,this.z=t.z),i&&(this.i=t.i),s&&(Oi.transferEdgeProperties(t,this),this.edgeTag=t.edgeTag),n&&(this.faceTag=t.faceTag)}}Oi._edgePropertyMasks=[M.BOUNDARY_EDGE,M.EXTERIOR,M.PRIMARY_EDGE,M.NULL_FACE],Oi._totalNodesCreated=0;class Bi{constructor(){this._numNodesCreated=0,this.allHalfEdges=[],this._maskManager=Ni.create(M.ALL_GRAB_DROP_MASKS)}grabMask(t=!0){const e=this._maskManager.grabMask();return t&&this.clearMask(e),e}dropMask(t){this._maskManager.dropMask(t)}createEdgeXYZXYZ(t=0,e=0,i=0,s=0,n=0,r=0,o=0,a=0){return Oi.createHalfEdgePairWithCoordinates(t,e,i,s,n,r,o,a,this.allHalfEdges)}createEdgeIdId(t=0,e=0){return Oi.createHalfEdgePairWithCoordinates(0,0,0,t,0,0,0,e,this.allHalfEdges)}createEdgeXYZHalfEdge(t=0,e=0,i=0,s=0,n,r=0){const o=Oi.createHalfEdgePairWithCoordinates(t,e,i,s,n.x,n.y,n.z,r,this.allHalfEdges),a=o.faceSuccessor;return Oi.pinch(n,a),o}createEdgeHalfEdgeHalfEdge(t,e,i,s=0){const n=Oi.createHalfEdgePairWithCoordinates(t.x,t.y,t.z,e,i.x,i.y,i.z,s,this.allHalfEdges),r=n.faceSuccessor;return Oi.pinch(t,n),Oi.pinch(i,r),n}createEdgeXYAndZ(t,e,i,s){return Oi.createHalfEdgePairWithCoordinates(t.x,t.y,t.z,e,i.x,i.y,i.z,s,this.allHalfEdges)}splitEdge(t,e=0,i=0,s=0,n=0){return Oi.splitEdge(t,e,i,s,n,this.allHalfEdges)}splitEdgeCreateSliverFace(t){return Oi.splitEdgeCreateSliverFace(t,this.allHalfEdges)}splitEdgeAtFraction(t,e){return Oi.splitEdge(t,t.fractionToX(e),t.fractionToY(e),t.fractionToZ(e),0,this.allHalfEdges)}decommission(){for(const t of this.allHalfEdges)t.decommission();this.allHalfEdges.length=0,this.allHalfEdges=void 0}addEdgeXY(t,e,i,s){const n=Oi.createEdgeXYXY(this._numNodesCreated,t,e,this._numNodesCreated+1,i,s);return this._numNodesCreated+=2,this.allHalfEdges.push(n),this.allHalfEdges.push(n.faceSuccessor),n}clearMask(t){for(const e of this.allHalfEdges)e.maskBits&=~t}setMask(t){for(const e of this.allHalfEdges)e.maskBits|=t}reverseMask(t){for(const e of this.allHalfEdges)e.maskBits^=t}countMask(t){let e=0;for(const i of this.allHalfEdges)i.isMaskSet(t)&&e++;return e}collectSegments(){const t=[];for(const e of this.allHalfEdges)e.id<e.edgeMate.id&&t.push(Pe.create(Q.create(e.x,e.y),Q.create(e.faceSuccessor.x,e.faceSuccessor.y)));return t}countVertexLoops(){this.clearMask(M.VISITED);let t=0;return this.announceVertexLoops(((e,i)=>(t++,!0))),t}countFaceLoops(){this.clearMask(M.VISITED);let t=0;return this.announceFaceLoops(((e,i)=>(t++,!0))),t}countFaceLoopsWithMaskFilter(t,e){this.clearMask(M.VISITED);let i=0;return this.announceFaceLoops(((s,n)=>(t(n,e)&&i++,!0))),i}collectFaceLoops(){const t=[];return this.announceFaceLoops(((e,i)=>(t.push(i),!0))),t}collectVertexLoops(){this.clearMask(M.VISITED);const t=[];for(const e of this.allHalfEdges)e.getMask(M.VISITED)||(t.push(e),e.setMaskAroundVertex(M.VISITED));return t}announceFaceLoops(t){this.clearMask(M.VISITED);for(const e of this.allHalfEdges)if(!e.getMask(M.VISITED)&&(e.setMaskAroundFace(M.VISITED),!t(this,e)))break}announceEdges(t){this.clearMask(M.VISITED);for(const e of this.allHalfEdges){if(e.getMask(M.VISITED))continue;const i=e.edgeMate;if(e.setMask(M.VISITED),i.setMask(M.VISITED),!t(this,e))break}}announceVertexLoops(t){this.clearMask(M.VISITED);for(const e of this.allHalfEdges)if(!e.getMask(M.VISITED)&&(e.setMaskAroundVertex(M.VISITED),!t(this,e)))break}announceNodes(t){for(const e of this.allHalfEdges)if(!t(this,e))break}countNodes(){return this.allHalfEdges.length}transformInPlace(t){for(const e of this.allHalfEdges)t.multiplyXYAndZInPlace(e)}yankAndDeleteEdges(t){const e=this.allHalfEdges.length;let i=0;for(let s=0;s<e;s++){const e=this.allHalfEdges[s];t(e)?e.isolateEdge():this.allHalfEdges[i++]=e}const s=e-i;return this.allHalfEdges.length=i,s}deleteIsolatedEdges(){const t=this.allHalfEdges.length;let e=0;for(let i=0;i<t;i++){const t=this.allHalfEdges[i];t.isIsolatedEdge||(this.allHalfEdges[e++]=t)}const i=t-e;return this.allHalfEdges.length=e,i}}class Vi{constructor(t,e=Z){this._array=[],this._compare=t,this._clone=e}get length(){return this._array.length}get isEmpty(){return 0===this.length}[Symbol.iterator](){return this._array[Symbol.iterator]()}_swap(t,e){const i=this._array[t];this._array[t]=this._array[e],this._array[e]=i}_heapify(t){let e=-1;for(;;){const i=2*(t+1),s=i-1;if(e=s<this.length&&this._compare(this._array[s],this._array[t])<0?s:t,i<this.length&&this._compare(this._array[i],this._array[e])<0&&(e=i),e===t)break;this._swap(e,t),t=e}}sort(){for(let t=Math.ceil(this.length/2);t>=0;t--)this._heapify(t)}push(t){const e=this._clone(t);let i=this.length;for(this._array.push(e);0!==i;){const t=Math.floor((i-1)/2);if(!(this._compare(this._array[i],this._array[t])<0))break;this._swap(i,t),i=t}return e}append(t){const e=this._clone(t);return this._array.push(e),e}get front(){return this._peek(0)}pop(){return this._pop(0)}clear(){this._array.length=0}_pop(t){if(t<0||t>=this.length)return;const e=this._array[t];return this._swap(t,this.length-1),this._array.length--,this._heapify(t),e}_peek(t){return t<0||t>=this.length?void 0:this._array[t]}}class Li{constructor(t=((t,e)=>vs.compareNodesYXUp(t,e))){this.priorityQueue=new Vi(t),this.activeEdges=[]}popQueueToArray(){if(this.priorityQueue.isEmpty)return;const t=this.priorityQueue.pop();return this.activeEdges.push(t),t}popArrayToArrayIndex(t){if(t<this.activeEdges.length){const e=this.activeEdges.pop();this.activeEdges[t]=e}}removeArrayMembersWithY1Below(t){let e=0;const i=this.activeEdges.length;for(let s=0;s<i;s++){const i=this.activeEdges[s];i.faceSuccessor.y>=t&&(e<s&&(this.activeEdges[e]=i),e++)}this.activeEdges.length=e}}class Ui{constructor(t){this.graph=t,this.upEdges=[],this.downEdges=[],this.bottomPeaks=[],this.topPeaks=[],this.localMin=[],this.localMax=[]}collectVerticalEventsAroundFace(t){let e,i,s,n,r=t;this.upEdges.length=0,this.downEdges.length=0,this.topPeaks.length=0,this.bottomPeaks.length=0,this.localMin.length=0,this.localMax.length=0;do{e=r.faceSuccessor,i=e.faceSuccessor,s=vs.compareNodesYXUp(r,e)<0,n=vs.compareNodesYXUp(e,i)<0,s?(this.upEdges.push(r),n||(vs.crossProductToTargets(e,r,i)<0?this.localMax.push(e):this.topPeaks.push(e))):(this.downEdges.push(r),n&&(vs.crossProductToTargets(e,r,i)>0?this.bottomPeaks.push(e):this.localMin.push(e))),r=e}while(r!==t)}collectVerticalEventFromEdgesInAndArray(t){let e,i,s,n,r;for(e of(this.upEdges.length=0,this.downEdges.length=0,this.topPeaks.length=0,this.bottomPeaks.length=0,this.localMin.length=0,this.localMax.length=0,t))i=e.faceSuccessor,s=i.faceSuccessor,n=vs.compareNodesYXUp(e,i)<0,r=vs.compareNodesYXUp(i,s)<0,n?(this.upEdges.push(e),r||(vs.crossProductToTargets(i,e,s)<0?this.localMax.push(i):this.topPeaks.push(i))):(this.downEdges.push(e),r&&(vs.crossProductToTargets(i,e,s)>0?this.bottomPeaks.push(i):this.localMin.push(i)))}swapArrays(){let t=this.downEdges;this.downEdges=this.upEdges,this.upEdges=t,t=this.localMax,this.localMax=this.localMin,this.localMin=t,t=this.topPeaks,this.topPeaks=this.bottomPeaks,this.bottomPeaks=t}findTopVisibleEdge(t,e,i){const s=t.y,n=t.x;let r,o,a=Number.MAX_SAFE_INTEGER;for(const c of e){const e=c.faceSuccessor;if(c===t||e===t)continue;if(vs.compareNodesYXUp(t,c)*vs.compareNodesYXUp(t,e)>=0)continue;const h=Oi.horizontalScanFraction01(c,s);void 0!==h&&(r=i*(c.fractionToX(h)-n),r>0&&r<a&&(o=c,a=r))}return o}highestUpPeakConnection(t,e,i){let s;for(const n of this.topPeaks){const r=n.y,o=n.x;if(!(void 0!==s&&vs.compareNodesYXUp(n,s)<0)&&vs.compareNodesYXUp(n,t)<0){if(e){const t=Oi.horizontalScanFraction01(e,r);if(void 0===t)continue;if(o<=e.fractionToX(t))continue}if(i){const t=Oi.horizontalScanFraction01(i,r);if(void 0===t)continue;if(i.fractionToX(t)<=o)continue}s=n}}return s}updateMaxNode(t,e,i){return t?e&&i(t,e)<0?e:t:e}negateXY(){for(const t of this.graph.allHalfEdges)t.x*=-1,t.y*=-1}downwardConnectionFromBottomPeak(t){let e;const i=(t,e)=>vs.compareNodesYXUp(t,e),s=this.findTopVisibleEdge(t,this.upEdges,1),n=this.findTopVisibleEdge(t,this.downEdges,-1);e=this.updateMaxNode(e,s,i),n&&(e=this.updateMaxNode(e,n.faceSuccessor,i));const r=this.highestUpPeakConnection(t,n,s);return void 0!==r&&(e=this.updateMaxNode(e,r,i)),e}findVisibleSector(t,e){let i=t;do{if(Oi.isNodeVisibleInSector(e,i))return i;i=i.vertexSuccessor}while(i!==t)}joinNodes(t,e,i){const s=this.graph.createEdgeXYZXYZ(t.x,t.y,t.z,0,e.x,e.y,e.z,0),n=this.findVisibleSector(t,e),r=this.findVisibleSector(e,t);if(void 0!==n&&void 0!==r)return Oi.pinch(n,s),Oi.pinch(r,s.edgeMate),Ui.announceEdge&&Ui.announceEdge(this.graph,t,e,i),s}runRegularization(t=!0,e=!0){if(t){this.bottomPeaks.sort(((t,e)=>vs.compareNodesYXUp(t,e)));for(const t of this.bottomPeaks){if(!vs.isDownPeak(t))continue;const e=this.downwardConnectionFromBottomPeak(t);void 0!==e&&this.joinNodes(t,e,1)}}if(e){this.negateXY(),this.swapArrays(),this.bottomPeaks.sort(((t,e)=>vs.compareNodesYXUp(t,e)));for(const t of this.bottomPeaks){if(!vs.isDownPeak(t))continue;const e=this.downwardConnectionFromBottomPeak(t);void 0!==e&&this.joinNodes(t,e,-1)}this.negateXY(),this.swapArrays()}}regularizeFace(t,e=!0,i=!0){this.collectVerticalEventsAroundFace(t),this.runRegularization(e,i)}regularizeGraph(t=!0,e=!0){this.collectVerticalEventFromEdgesInAndArray(this.graph.allHalfEdges),this.runRegularization(t,e)}static isMonotoneFace(t){let e,i=0,s=0,n=t;do{const t=n.faceSuccessor,r=t.faceSuccessor,o=vs.compareNodesYXUp(n,t),a=vs.compareNodesYXUp(t,r);o*a<=0&&(o>0&&(i++,e=t),a>0&&s++)}while((n=n.faceSuccessor)!==t);return 1===i&&1===s?e:void 0}static collectMappedFaceRepresentatives(t,e,i,s,n){s&&(s.length=0),n&&(n.length=0);const r=M.VISITED;t.clearMask(r);for(const o of t.allHalfEdges)if(!o.getMask(r)&&(o.setMaskAroundFace(r),!e||o.signedFaceArea()>0)){const t=i(o);t?s&&s.push(t):n&&n.push(o)}}}class Zi extends qe{isSameGeometryClass(t){return t instanceof Zi}get children(){return this._children}constructor(){super(),this.curveCollectionType="unionRegion",this._children=[]}static create(...t){const e=new Zi;for(const i of t)e.tryAddChild(i);return e}dgnBoundaryType(){return 5}announceToCurveProcessor(t,e=-1){return t.announceUnionRegion(this,e)}cloneStroked(t){const e=new Zi;let i;for(i of this._children){const s=i.cloneStroked(t);s&&e.children.push(s)}return e}cloneEmptyPeer(){return new Zi}tryAddChild(t){return!(!t||!(t instanceof Qe||t instanceof Ke)||(this._children.push(t),0))}getChild(t){if(t<this._children.length)return this._children[t]}dispatchToGeometryHandler(t){return t.handleUnionRegion(this)}}class qi{constructor(){this._cachedObjects=[],this.numDrop=0,this.numCreate=0,this.numReuse=0}dropToCache(t){t&&(this.numDrop++,this.clearForCache(t),this._cachedObjects.push(t))}grabFromCache(){let t=this._cachedObjects.pop();return void 0===t?(t=this.createForCache(),this.numCreate++):this.numReuse++,t}dropAllToCache(t){for(;t.length>0;)this.dropToCache(t.pop())}}class Wi extends qi{clearForCache(t){t.length=0}createForCache(){return new nt(10)}constructor(){super()}grabAndFill(t){const e=this.grabFromCache();return e.pushFrom(t),e}}class Gi{get convexSets(){return this._convexSets}constructor(){this._convexSets=[]}toJSON(){const t=[];for(const e of this._convexSets)t.push(e.toJSON());return t}static fromJSON(t,e){if((e=e||new Gi)._convexSets.length=0,!Array.isArray(t))return e;for(const i of t)e._convexSets.push(en.fromJSON(i));return e}static createEmpty(t){return t?(t._convexSets.length=0,t):new Gi}isAlmostEqual(t){if(this._convexSets.length!==t._convexSets.length)return!1;for(let e=0;e<this._convexSets.length;e++)if(!this._convexSets[e].isAlmostEqual(t._convexSets[e]))return!1;return!0}static createConvexSets(t,e){e=e||new Gi;for(const i of t)e._convexSets.push(i);return e}clone(t){(t=t||new Gi)._convexSets.length=0;for(const e of this._convexSets)t._convexSets.push(e.clone());return t}addConvexSet(t){t&&this._convexSets.push(t)}hasIntersectionWithRay(t,e){if(void 0===e){for(const e of this._convexSets)if(e.hasIntersectionWithRay(t))return!0;return!1}e.setNull();const i=ft.createNull();for(const s of this._convexSets)s.hasIntersectionWithRay(t,i)&&e.extendRange(i);return!e.isNull}isPointInside(t){for(const e of this._convexSets)if(e.isPointInside(t))return!0;return!1}isPointOnOrInside(t,e=K.smallMetricDistance){for(const i of this._convexSets)if(i.isPointOnOrInside(t,e))return!0;return!1}isSphereInside(t,e){for(const i of this._convexSets)if(i.isSphereInside(t,e))return!0;return!1}isAnyPointInOrOnFromSegment(t){for(const e of this._convexSets)if(e.announceClippedSegmentIntervals(0,1,t.point0Ref,t.point1Ref))return!0;return!1}appendIntervalsFromSegment(t,e){for(const i of this._convexSets)i.announceClippedSegmentIntervals(0,1,t.point0Ref,t.point1Ref,((t,i)=>e.push(ke.create(t,i))))}transformInPlace(t){for(const e of this._convexSets)e.transformInPlace(t)}classifyPointContainment(t,e){for(const i of this._convexSets){const s=i.classifyPointContainment(t,e);if(s!==X.StronglyOutside)return s}return X.StronglyOutside}polygonClip(t,e){e.length=0,Array.isArray(t)&&(t=nt.create(t));const i=new nt;for(const s of this._convexSets){const n=new nt;s.polygonClip(t,n,i),0!==n.length&&e.push(n)}}announceClippedSegmentIntervals(t,e,i,s,n){let r=0;for(const o of this._convexSets)o.announceClippedSegmentIntervals(t,e,i,s,n)&&r++;return r>0}announceClippedArcIntervals(t,e){const i=Gi._clipArcFractionArray;i.clear();for(const e of this._convexSets)for(const s of e.planes)s.appendIntersectionRadians(t,i);return t.sweep.radiansArrayToPositivePeriodicFractions(i),os.selectIntervals01(t,i,this,e)}computePlanePlanePlaneIntersectionsInAllConvexSets(t,e,i,s=!0){let n=0;for(const r of this._convexSets)n+=r.computePlanePlanePlaneIntersections(t,e,i,s);return n}multiplyPlanesByMatrix4d(t,e=!0,i=!0){if(e){const e=t.createInverse();return!!e&&this.multiplyPlanesByMatrix4d(e,!1,i)}for(const e of this._convexSets)e.multiplyPlanesByMatrix4d(t,!1,i);return!0}setInvisible(t){for(const e of this._convexSets)e.setInvisible(t)}addOutsideZClipSets(t,e,i){if(e){const i=en.createEmpty();i.addZClipPlanes(t,e),this._convexSets.push(i)}if(i){const e=en.createEmpty();e.addZClipPlanes(t,void 0,i),this._convexSets.push(e)}}takeConvexSets(t){let e;for(;void 0!==(e=t._convexSets.pop());)this._convexSets.push(e)}appendPolygonClip(t,e,i,s){const n=i.length,r=e.length;let o,a,c=[s.grabAndFill(t)],h=[];for(const t of this._convexSets){for(;void 0!==(a=c.pop());)t.appendPolygonClip(a,e,h,s),s.dropToCache(a);o=h,h=c,c=o}for(;void 0!==(a=c.pop());)i.push(a);i.length===n?os.restoreSingletonInPlaceOfMultipleShards(e,r,t,s):e.length===r&&os.restoreSingletonInPlaceOfMultipleShards(i,n,t,s)}}Gi._clipArcFractionArray=new St;class Hi{static advanceIntervalDifference(t,e,i,s){const n=e.length;let r=t.low,o=t.high;for(;i<n;){const t=e[i];if(t.high<r)i++;else{if(!(t.high<=o)){t.low<o&&(o=t.low);break}t.low>r&&s.push(ft.createXX(r,t.low)),r=t.high,i++}}return r<o&&s.push(ft.createXX(r,o)),s}static differenceSorted(t,e){const i=t.length,s=[];for(let n=0;n<i;n++)Hi.advanceIntervalDifference(t[n],e,0,s);return s}static advanceIntervalIntersection(t,e,i){return e.low>t.high||(e.high>=t.high?(i.push(ft.createXX(e.low,t.high)),!0):(i.push(ft.createXX(e.low,e.high)),!1))}static intersectSorted(t,e){let i=0,s=0;const n=t.length,r=e.length,o=[];for(;i<n&&s<r;){const n=t[i],r=e[s];n.low<=r.low?Hi.advanceIntervalIntersection(n,r,o)?i++:s++:Hi.advanceIntervalIntersection(r,n,o)?s++:i++}return o}static advanceIntervalUnion(t,e,i){if(i>=e.length)return!1;const s=e[i];return!(s.low>t.high||(s.high>t.high&&(t.high=s.high),0))}static unionSorted(t,e){const i=t.length,s=e.length;let n=0,r=0;const o=[];for(;n<i&&r<s;){const i=t[n],s=e[r];let a;i.low<=s.low?(a=i.clone(),n++):(a=s.clone(),r++);let c=!0;do{const i=Hi.advanceIntervalUnion(a,t,n),s=Hi.advanceIntervalUnion(a,e,r);i&&n++,s&&r++,i||s||(c=!1)}while(c);o.push(a)}for(;n<i;)o.push(t[n++]);for(;r<s;)o.push(e[r++]);return o}static paritySorted(t,e){const i=[];for(const e of t)i.push(e.clone());for(const t of e)i.push(t.clone());return i.sort(Ji),Hi.simplifySortParity(i,!0),i}static sort(t){t.sort(Ji)}static simplifySortUnion(t,e=!1){if(t.length<2)return;t.sort(Ji);let i=0;for(let e=1;e<t.length;e++)t[e].low<=t[i].high?t[e].high>t[i].high&&(t[i].high=t[e].high):(i++,t[i].setFrom(t[e]));if(t.length=i+1,e){i=-1;for(let e=0;e<t.length;e++)t[e].low<t[e].high&&i<e&&t[++i].setFrom(t[e])}}static simplifySortParity(t,e=!1){const i=[];for(const e of t)e.low!==e.high&&(i.push(e.low),i.push(e.high));const s=i.length;i.sort(((t,e)=>t<e?-1:t>e?1:0));let n,r,o=0;for(let a=0;a<s;a+=2)if(n=i[a],r=i[a+1],e){for(;a+2<s&&i[a+2]===r;)a+=2,r=i[a+1];r>n&&ft.createXX(n,r,t[o++])}else ft.createXX(n,r,t[o++]);t.length=o}static testUnion(t,e){return this.countContainingRanges(t,e)>0}static testParity(t,e){let i=!1;for(const s of t)s.containsX(e)&&(i=!i);return i}static countContainingRanges(t,e){let i=0;for(const s of t)s.containsX(e)&&i++;return i}static getBreaks(t,e,i=!1,s=!1,n=!0){e||(e=new St(2*t.length)),n&&e.clear();for(const i of t)e.push(i.low),e.push(i.high);return i&&e.sort(),s&&e.compressAdjacentDuplicates(),e}static appendFractionalPoints(t,e,i,s,n,r,o,a){const c=t.length;if(c>0){void 0!==e&&a.push(t[0].fractionToPoint(e));for(let e=0;e<c;e++)void 0===i||!s&&t[e].low===t[e].high||a.push(t[e].fractionToPoint(i)),e>1&&void 0!==n&&(r||t[e].low!==t[e].high)&&a.push(K.interpolate(t[e-1].high,n,t[e].low));void 0!==o&&a.push(t[c-1].fractionToPoint(o))}return a}static firstLowToLastHigh(t){return 0===t.length?ft.createNull():ft.createXX(t[0].low,t[t.length-1].high)}static sumLengths(t){let e=0;for(const i of t)e+=i.length();return e}static isSorted(t,e=!0){const i=t.length;if(e){for(let e=0;e+1<i;e++)if(t[e].high>=t[e+1].low)return!1}else for(let e=0;e+1<i;e++)if(t[e].high>t[e+1].low)return!1;return!0}}function Ji(t,e){return t.low<e.low?-1:t.low>e.low?1:t.high<e.high?-1:t.high>e.high?1:0}class Ki{constructor(){this.points=[],this.planes=en.createEmpty(),this.children=[],this.startIdx=-1,this.numPoints=-1}static createWithIndices(t,e,i){return(i=i||new Ki).startIdx=t,i.numPoints=e,i.children.length=0,i}static createTreeForPolygon(t,e){return(e=e||new Ki).empty(),ji.createPointsRef(t).buildHullTree(e),e}static createHullAndInletsForPolygon(t,e){return(e=e||new Ki).empty(),ji.createPointsRef(t).buildHullAndInletsForPolygon(e),e}extractLoopsGo(t){t.push(ae.clonePoint3dArray(this.points));for(const e of this.children)e.extractLoopsGo(t)}extractLoops(){const t=[];return this.extractLoopsGo(t),t}empty(){this.points.length=0,this.planes.planes.length=0,this.children.length=0,this.startIdx=-1,this.numPoints=-1}clone(t){t=t||new Ki;for(const e of this.points)t.points.push(e.clone());t.planes=en.createEmpty();for(const e of this.planes.planes)t.planes.planes.push(e.clone());for(const e of this.children)t.children.push(e.clone());return t.startIdx=this.startIdx,t.numPoints=this.numPoints,t}addEmptyChild(t,e){const i=Ki.createWithIndices(t,e);this.children.push(i)}addPlane(t){this.planes.addPlaneToConvexSet(t)}isPointOnOrInside(t){if(!this.planes.isPointOnOrInside(t,0))return!1;for(const e of this.children)if(e.isPointOnOrInside(t))return!1;return!0}captureConvexClipPlaneSetAsVoid(t){this.children.push(t)}appendCurvePrimitiveClipIntervals(t,e,i){(new Qi).appendSingleClipPrimitive(this,t,e,i)}appendCurveCollectionClipIntervals(t,e,i){(new Qi).appendCurveCollectionClip(this,t,e,i)}appendPolygonClip(t,e,i,s){const n=i.length,r=this.planes.clipInsidePushOutside(t,i,s);if(void 0===r)os.restoreSingletonInPlaceOfMultipleShards(i,n,t,s);else{let t,n,o=[r],a=[];for(const e of this.children){for(a.length=0;void 0!==(n=o.pop());)e.appendPolygonClip(n,i,a,s),s.dropToCache(n);t=a,a=o,o=t}for(;void 0!==(n=o.pop());)e.push(n)}}depth(){let t=0;for(const e of this.children)t=Math.max(t,e.depth());return 1+t}}class ji{constructor(){this._points=[],this._stack=[]}static createPointsRef(t,e){return(e=e||new ji)._points=t,gr.areaXY(t)<0&&e._points.reverse(),e._points[e._points.length-1].isAlmostEqualMetric(e._points[0])&&e._points.pop(),e}get period(){return this._points.length}indexAfter(t){return(t+1)%this._points.length}indexBefore(t){return(t+this._points.length-1)%this._points.length}pushIndex(t){this._stack.push(t)}static cross(t,e,i){return t.crossProductToPointsXY(e,i)}cyclicStackPoint(t){let e;const i=this._stack;return e=t>0?t:t+10*i.length,e%=i.length,this._points[i[e]]}signFromStackTip(t,e){const i=this.cyclicStackPoint(-2),s=this.cyclicStackPoint(-1),n=this._points[t];return e*ji.cross(i,s,n)>=0?1:-1}get indexOfMaxX(){let t=0;const e=this._points,i=this._points.length;for(let s=1;s<i;s++)e[s].x>e[t].x&&(t=s);return t}extendHullChain(t,e,i){for(;this._stack.length>1&&this.signFromStackTip(t,e)<0;)this._stack.pop();i&&this.pushIndex(t)}collectHullChain(t,e,i){if(this._stack.length=0,e>2){let s=t;for(let t=0;t<e;t++)this.extendHullChain(s,i,!0),s=this.indexAfter(s)}}collectHullPointsInArray(t,e,i,s){if(t.length=0,i>2){let s=e;for(let e=0;e<i;e++)t.push(this._points[s]),s=this.indexAfter(s)}}buildHullTreeGo(t,e,i=!0){this.collectHullChain(t.startIdx,t.numPoints,e?1:-1),t.points.length=0;const s=this._stack,n=this._points,r=s.length;for(let i=0;i<r;i++){const o=s[i];if(t.points.push(n[o]),i+1<r){let r=s[i+1];if(r===this.indexAfter(o)){const i=xr.createEdgeAndUpVector(n[o],n[r],$.create(0,0,1),W.createRadians(0));void 0!==i&&(e&&i.negateInPlace(),t.addPlane(i))}else r<o&&(r+=this.period),t.addEmptyChild(o,r-o+1)}}if(i)for(const i of t.children)this.buildHullTreeGo(i,!e);else for(const i of t.children)this.collectHullPointsInArray(i.points,i.startIdx,i.numPoints,e?-1:1);return!0}buildHullAndInletsForPolygon(t){return Ki.createWithIndices(this.indexOfMaxX,this.period+1,t),this.buildHullTreeGo(t,!0,!1)}buildHullTree(t){return Ki.createWithIndices(this.indexOfMaxX,this.period+1,t),this.buildHullTreeGo(t,!0)}}class Qi{constructor(){this._stackDepth=0,this._intervalStack=[]}setCurveRef(t){this._curve=t}popSegmentFrame(){this._stackDepth>0&&(this._topOfStack.length=0,this._stackDepth-=1)}clearSegmentStack(){for(;this._stackDepth>0;)this.popSegmentFrame()}pushEmptySegmentFrame(){for(this._stackDepth+=1;this._intervalStack.length<this._stackDepth;)this._intervalStack.push([]);this._topOfStack.length=0}get _topOfStack(){return this._intervalStack[this._stackDepth-1]}set _topOfStack(t){const e=this._stackDepth;e>0&&(this._intervalStack[e-1]=t)}stackEntry(t){return t<=this._stackDepth?this._intervalStack[this._stackDepth-1-t]:[]}isTopOfStackEmpty(){return 0===this._topOfStack.length}appendSingleClipToStack(t,e){const i=Qi._fractionIntervals;if(this._curve instanceof Pe){let i,s;return this._curve.announceClipIntervals(t,((t,e,n)=>{i=t,s=e}))&&e.push(ft.createXX(i,s)),!0}if(this._curve instanceof De){const s=this._curve;i.length=0,s.announceClipIntervals(t,((t,e,s)=>{i.push(t),i.push(e)}));for(let t=0;t<i.length;t+=2)e.push(ft.createXX(i[t],i[t+1]));return!0}if(this._curve instanceof we&&this._curve.points.length>1){const i=this._curve;let s,n;const r=i.points.length,o=1/(r-1);for(let a=0;a<r-1;a++)Pe.create(i.points[a],i.points[a+1]).announceClipIntervals(t,((t,e,i)=>{s=t,n=e}))&&e.push(ft.createXX((a+s)*o,(a+n)*o));return!0}if(this._curve instanceof ze){const s=this._curve;i.length=0,s.announceClipIntervals(t,((t,e,s)=>{i.push(t),i.push(e)}));for(let t=0;t<i.length;t+=2)e.push(ft.createXX(i[t],i[t+1]));return!0}return!1}recurse(t){if(this.pushEmptySegmentFrame(),this.appendSingleClipToStack(t.planes,this._topOfStack),Hi.sort(this._topOfStack),!this.isTopOfStackEmpty())for(const e of t.children){if(this.recurse(e),this.isTopOfStackEmpty())this.popSegmentFrame();else{const t=Hi.differenceSorted(this.stackEntry(1),this.stackEntry(0));this.popSegmentFrame(),this._topOfStack=t}if(this.isTopOfStackEmpty())break}}appendSingleClipPrimitive(t,e,i,s){if(this.setCurveRef(e),this.clearSegmentStack(),this.recurse(t),1!==this._stackDepth)return;const n=this._topOfStack;for(const t of n){const s=t.low,n=t.high,r=e.fractionToPoint(s),o=e.fractionToPoint(n);i.push(Pt.createCapture(vt.createCurveFractionPoint(e,s,r),vt.createCurveFractionPoint(e,n,o)))}this.popSegmentFrame()}appendCurveCollectionClip(t,e,i,s){for(const n of e.children)n instanceof ie?this.appendSingleClipPrimitive(t,n,i,s):n instanceof qe&&this.appendCurveCollectionClip(t,n,i,s)}}Qi._fractionIntervals=[],function(t){t[t.None=0]="None",t[t.XLow=1]="XLow",t[t.XHigh=2]="XHigh",t[t.YLow=4]="YLow",t[t.YHigh=8]="YHigh",t[t.ZLow=16]="ZLow",t[t.ZHigh=32]="ZHigh",t[t.XAndY=15]="XAndY",t[t.All=63]="All"}(b||(b={}));class $i{fetchClipPlanesRef(){return this.ensurePlaneSets(),this._clipPlanes}get invisible(){return this._invisible}constructor(t,e=!1){this._clipPlanes=t,this._invisible=e}static createCapture(t,e=!1){let i;return t instanceof Gi&&(i=t),t instanceof en&&(i=Gi.createConvexSets([t])),new $i(i,e)}toJSON(){const t={};return this._clipPlanes&&(t.clips=this._clipPlanes.toJSON()),this._invisible&&(t.invisible=!0),{planes:t}}arePlanesDefined(){return void 0!==this._clipPlanes}clone(){const t=this._clipPlanes?this._clipPlanes.clone():void 0;return new $i(t,this._invisible)}ensurePlaneSets(){}pointInside(t,e=K.smallMetricDistanceSquared){this.ensurePlaneSets();let i=!0;return this._clipPlanes&&(i=this._clipPlanes.isPointOnOrInside(t,e)),i}isPointOnOrInside(t,e=K.smallMetricDistanceSquared){this.ensurePlaneSets();let i=!0;return this._clipPlanes&&(i=this._clipPlanes.isPointOnOrInside(t,e)),i}announceClippedSegmentIntervals(t,e,i,s,n){this.ensurePlaneSets();let r=!1;return this._clipPlanes&&(r=this._clipPlanes.announceClippedSegmentIntervals(t,e,i,s,n)),r}announceClippedArcIntervals(t,e){this.ensurePlaneSets();let i=!1;return this._clipPlanes&&(i=this._clipPlanes.announceClippedArcIntervals(t,e)),i}multiplyPlanesByMatrix4d(t,e=!0,i=!0){if(e){const e=t.createInverse();return!!e&&this.multiplyPlanesByMatrix4d(e,!1,i)}return this._clipPlanes&&this._clipPlanes.multiplyPlanesByMatrix4d(t),!0}transformInPlace(t){return this._clipPlanes&&this._clipPlanes.transformInPlace(t),!0}setInvisible(t){this._invisible=t}containsZClip(){if(void 0!==this.fetchClipPlanesRef())for(const t of this._clipPlanes.convexSets)for(const e of t.planes)if(Math.abs(e.inwardNormalRef.z)>1e-6&&Math.abs(e.distance)!==Number.MAX_VALUE)return!0;return!1}classifyPointContainment(t,e){this.ensurePlaneSets();const i=this._clipPlanes;let s=X.StronglyInside;if(i&&(s=i.classifyPointContainment(t,!1)),this._invisible&&!e)switch(s){case X.StronglyInside:return X.StronglyOutside;case X.StronglyOutside:return X.StronglyInside;case X.Ambiguous:return X.Ambiguous}return s}static fromJSON(t){if(!t)return;return es.fromClipShapeJSON(t)||$i.fromJSONClipPrimitive(t)}static fromJSONClipPrimitive(t){const e=t?.planes;if(!e)return;const i=e.clips?Gi.fromJSON(e.clips):void 0,s=void 0!==e.invisible&&e.invisible;return new $i(i,s)}}class ts{constructor(t,e,i,s){this.pointA=Q.create(t.x,t.y,s),this.pointB=Q.create(e.x,e.y,s),this.normal=i}static makeUnitPerpendicularToBisector(t,e,i){let s=e.normal.minus(t.normal);if(void 0!==s.normalize(s)||(s=$.createStartEnd(t.pointA,e.pointB),void 0!==s.normalize(s)))return i&&s.scale(-1,s),s}}class es extends $i{constructor(t=[],e,i,s,n=!1,r=!1){super(void 0,r),this._isMask=!1,this._polygon=t,this.initSecondaryProps(n,e,i,s)}get invisible(){return this._invisible}get transformFromClip(){return this._transformFromClip}get transformToClip(){return this._transformToClip}get transformValid(){return void 0!==this.transformFromClip}get zLowValid(){return void 0!==this._zLow}get zHighValid(){return void 0!==this._zHigh}get transformIsValid(){return void 0!==this._transformFromClip}get zLow(){return this._zLow}get zHigh(){return this._zHigh}get polygon(){return this._polygon}get isMask(){return this._isMask}setPolygon(t){t[0].isAlmostEqual(t[t.length-1])||t.push(t[0].clone()),this._polygon=t}ensurePlaneSets(){void 0===this._clipPlanes&&(this._clipPlanes=Gi.createEmpty(),this.parseClipPlanes(this._clipPlanes),this._transformFromClip&&this._clipPlanes.transformInPlace(this._transformFromClip))}initSecondaryProps(t,e,i,s){this._isMask=t,this._zLow=e,this._zHigh=i,void 0!==s?(this._transformFromClip=s,this._transformToClip=s.inverse()):(this._transformFromClip=pt.createIdentity(),this._transformToClip=pt.createIdentity())}toJSON(){const t={points:this._polygon.map((t=>t.toJSON()))};return this.invisible&&(t.invisible=!0),this._transformFromClip&&!this._transformFromClip.isIdentity&&(t.trans=this._transformFromClip.toJSON()),this.isMask&&(t.mask=!0),void 0!==this.zLow&&this.zLow!==-Number.MAX_VALUE&&(t.zlow=this.zLow),void 0!==this.zHigh&&this.zHigh!==Number.MAX_VALUE&&(t.zhigh=this.zHigh),{shape:t}}static fromClipShapeJSON(t,e){const i=t?.shape;if(!i)return;const s=i.points?i.points.map((t=>Q.fromJSON(t))):[],n=i.trans?pt.fromJSON(i.trans):void 0,r="number"==typeof i.zlow?i.zlow:void 0,o="number"==typeof i.zhigh?i.zhigh:void 0,a="boolean"==typeof i.mask&&i.mask,c="boolean"==typeof i.invisible&&i.invisible;return es.createShape(s,r,o,n,a,c,e)}static createFrom(t,e){const i=es.createEmpty(!1,!1,void 0,e);i._invisible=t._invisible;for(const e of t._polygon)i._polygon.push(e.clone());return i._isMask=t._isMask,i._zLow=t._zLow,i._zHigh=t._zHigh,i._transformToClip=t._transformToClip?t._transformToClip.clone():void 0,i._transformFromClip=t._transformFromClip?t._transformFromClip.clone():void 0,i}static createShape(t=[],e,i,s,n=!1,r=!1,o){if(t.length<3)return;const a=t.slice(0);return a[0].isAlmostEqual(a[a.length-1])?a[0].clone(a[a.length-1]):a.push(a[0].clone()),o?(o._clipPlanes=void 0,o._invisible=r,o._polygon=a,o.initSecondaryProps(n,e,i,s),o):new es(a,e,i,s,n,r)}static createBlock(t,e,i=!1,s=!1,n,r){const o=t.low,a=t.high,c=[];for(let t=0;t<5;t++)c.push(Q.create());return c[0].x=c[3].x=c[4].x=o.x,c[1].x=c[2].x=a.x,c[0].y=c[1].y=c[4].y=o.y,c[2].y=c[3].y=a.y,es.createShape(c,b.None!==(e&b.ZLow)?o.z:void 0,b.None!==(e&b.ZHigh)?a.z:void 0,n,i,s,r)}static createEmpty(t=!1,e=!1,i,s){return s?(s._clipPlanes=void 0,s._invisible=e,s._polygon.length=0,s.initSecondaryProps(t,void 0,void 0,i),s):new es([],void 0,void 0,i,t,e)}get isValidPolygon(){return!(this._polygon.length<3||!this._polygon[0].isExactEqual(this._polygon[this._polygon.length-1]))}clone(t){return es.createFrom(this,t)}parseClipPlanes(t){const e=this._polygon;if(3===e.length&&!this._isMask&&e[0].isExactEqual(e[e.length-1]))return this.parseLinearPlanes(t,this._polygon[0],this._polygon[1]),!0;if(!this.isMask){const e=gr.testXYPolygonTurningDirections(this.polygon);if(0!==e)return this.parseConvexPolygonPlanes(t,this._polygon,e,!1),!0}return this.parsePolygonPlanes(t,this._polygon,this.isMask),!0}parseLinearPlanes(t,e,i,s){const n=e.vectorTo(i);if(0===n.magnitude())return!1;n.normalize(n);const r=en.createEmpty();if(void 0===s){const t=J.create(-n.y,n.x);r.planes.push(xr.createNormalAndPoint($.create(n.x,n.y),Q.createFrom(e),this._invisible)),r.planes.push(xr.createNormalAndPoint($.create(-n.x,-n.y),Q.createFrom(i),this._invisible)),r.planes.push(xr.createNormalAndPoint($.create(t.x,t.y),Q.createFrom(e),this._invisible)),r.planes.push(xr.createNormalAndPoint($.create(-t.x,-t.y),Q.createFrom(e),this._invisible))}else{const t=Q.create(e.x,e.y,-s),n=Q.create(i.x,i.y,-s),o=$.createFrom(n),a=o.crossProduct($.createFrom(t)).normalize();let c=$.createFrom(t).crossProduct(a).normalize();r.planes.push(xr.createNormalAndDistance(a,0,this._invisible)),r.planes.push(xr.createNormalAndDistance(c,0,this._invisible)),a.negate(),c=o.crossProduct(a).normalize(),r.planes.push(xr.createNormalAndDistance(a,0,this._invisible)),r.planes.push(xr.createNormalAndDistance(c,0,this._invisible))}return r.addZClipPlanes(this._invisible,this._zLow,this._zHigh),t.addConvexSet(r),!0}parseConvexPolygonPlanes(t,e,i,s,n){const r=[],o=i<0;for(let t=0;t<e.length-1;t++){const i=void 0===n?0:-n,s=$.createStartEnd(e[t],e[t+1]),a=s.magnitude();if(s.normalize(s),a>1e-8){const n=$.create(o?s.y:-s.y,o?-s.x:s.x);r.push(new ts(e[t],e[t+1],n,i))}}if(r.length<3)return!1;if(s){const e=r.length-1;for(let i=0;i<=e;i++){const s=r[i],n=r[i?i-1:e],a=r[i===e?0:i+1],c=en.createEmpty(),h=ts.makeUnitPerpendicularToBisector(n,s,!o),l=ts.makeUnitPerpendicularToBisector(s,a,o);h&&c.planes.push(xr.createNormalAndPoint(h,s.pointA,this._invisible,!0)),c.planes.push(xr.createNormalAndPoint(s.normal,s.pointB,this._invisible,!1)),l&&c.planes.push(xr.createNormalAndPoint(l,a.pointA,this._invisible,!0)),t.addConvexSet(c),t.addOutsideZClipSets(this._invisible,this._zLow,this._zHigh)}}else{const e=en.createEmpty();if(void 0===n)for(const t of r)e.planes.push(xr.createNormalAndPoint($.create(t.normal.x,t.normal.y),t.pointA));else if(o)for(const t of r)e.planes.push(xr.createNormalAndDistance($.createFrom(t.pointA).crossProduct($.createFrom(t.pointB)).normalize(),0));else for(const t of r)e.planes.push(xr.createNormalAndDistance($.createFrom(t.pointB).crossProduct($.createFrom(t.pointA)).normalize(),0));e.addZClipPlanes(this._invisible,this._zLow,this._zHigh),t.addConvexSet(e)}return!0}parsePolygonPlanes(t,e,i,s){const n=ii.compressDanglers(e,!0),r=(e,i)=>{if(!i.isMaskSet(M.EXTERIOR)){const e=i.collectAroundFace((t=>{if(!t.isMaskSet(M.EXTERIOR))return Q.create(t.x,t.y,0)}));e.push(e[0].clone());const n=gr.testXYPolygonTurningDirections(e);this.parseConvexPolygonPlanes(t,e,n,!1,s)}return!0};if(i){const e=ae.clonePoint3dArray(n),i=Ki.createHullAndInletsForPolygon(e).extractLoops();if(0===i.length)return!1;const o=i[0],a=gr.testXYPolygonTurningDirections(o);this.parseConvexPolygonPlanes(t,o,-a,!0,s);for(let t=1;t<i.length;t++){const e=ms.createTriangulatedGraphFromSingleLoop(i[t]);e&&(ms.flipTriangles(e),e.announceFaceLoops(r))}return!0}{const t=ms.createTriangulatedGraphFromSingleLoop(n);if(void 0===t)return!1;ms.flipTriangles(t),t.announceFaceLoops(r)}return!0}multiplyPlanesByMatrix4d(t,e=!0,i=!0){return this.ensurePlaneSets(),super.multiplyPlanesByMatrix4d(t,e,i)}transformInPlace(t){return t.isIdentity||(super.transformInPlace(t),this._transformFromClip?t.multiplyTransformTransform(this._transformFromClip,this._transformFromClip):this._transformFromClip=t.clone(),this._transformToClip=this._transformFromClip.inverse()),!0}get isXYPolygon(){return 0!==this._polygon.length&&(void 0===this._transformFromClip||this._transformFromClip.matrix.columnZ().magnitudeXY()<1e-8)}performTransformToClip(t){void 0!==this._transformToClip&&this._transformToClip.multiplyPoint3d(t,t)}performTransformFromClip(t){void 0!==this._transformFromClip&&this._transformFromClip.multiplyPoint3d(t,t)}}class is{constructor(t){this._keepInside=t,this._clippers=[],this._intervalsA=[],this._intervalsB=[]}toJSON(){const t=[];for(const e of this._clippers){const i=e;i.toJSON&&t.push(i.toJSON())}const e={};return e[this.operationName]=t,e}captureChild(t){if(Array.isArray(t))for(const e of t)this.captureChild(e);else this._clippers.push(t)}toggleResult(){return this.selectResult(!this._keepInside)}selectResult(t){const e=this._keepInside;return this._keepInside=t,e}testedAnnounceNN(t,e,i){return t<e?(i&&i(t,e),1):0}testedAnnounceNNC(t,e,i,s){return t<e?(s&&s(t,e,i),1):0}swapAB(){const t=this._intervalsA;this._intervalsA=this._intervalsB,this._intervalsB=t}announcePartsNN(t,e,i,s,n){let r=0;if(t)for(const t of e)r+=this.testedAnnounceNN(t.low,t.high,n);else{let t=i;for(const i of e)r+=this.testedAnnounceNN(t,i.low,n),t=i.high;r+=this.testedAnnounceNN(t,s,n)}return r>0}announcePartsNNC(t,e,i,s,n,r){let o=0;if(t)for(const t of e)o+=this.testedAnnounceNNC(t.low,t.high,n,r);else{let t=i;for(const i of e)o+=this.testedAnnounceNNC(t,i.low,n,r),t=i.high;o+=this.testedAnnounceNNC(t,s,n,r)}return o>0}isPointOnOrInside(t){const e=this.isPointOnOrInsideChildren(t);return this._keepInside?e:!e}announceClippedSegmentIntervals(t,e,i,s,n){this._intervalsA.length=0;const r=(t,e)=>{this._intervalsB.push(ft.createXX(t,e))};let o=0;for(const n of this._clippers)this._intervalsB.length=0,n.announceClippedSegmentIntervals(t,e,i,s,r),Hi.simplifySortUnion(this._intervalsB),0===o?this.swapAB():this._intervalsA=this.combineIntervals(this._intervalsA,this._intervalsB),o++;return this.announcePartsNN(this._keepInside,this._intervalsA,t,e,n)}announceClippedArcIntervals(t,e){this._intervalsA.length=0;const i=(t,e)=>{this._intervalsB.push(ft.createXX(t,e))};let s=0;for(const e of this._clippers)this._intervalsB.length=0,e.announceClippedArcIntervals(t,i),Hi.simplifySortUnion(this._intervalsB),0===s?this.swapAB():this._intervalsA=this.combineIntervals(this._intervalsA,this._intervalsB),s++;return this.announcePartsNNC(this._keepInside,this._intervalsA,0,1,t,e)}}class ss extends is{get operationName(){return this._keepInside?"AND":"NAND"}constructor(t){super(t)}isPointOnOrInsideChildren(t){for(const e of this._clippers)if(!e.isPointOnOrInside(t))return!1;return!0}combineIntervals(t,e){return Hi.intersectSorted(t,e)}appendPolygonClip(t,e,i,s){os.doPolygonClipSequence(t,this._clippers,this._keepInside?e:i,this._keepInside?i:e,void 0,R.passToNextStep,R.acceptOut,R.acceptIn,s)}}class ns{get clips(){return this._clips}constructor(t){this.boundingRange=ut.createNull(),this._clips=t||[]}get isValid(){return this._clips.length>0}static createEmpty(t){return t?(t._clips.length=0,t):new ns}static createCapture(t,e){return e?(e._clips=t,e):new ns(t)}static create(t,e){const i=[];for(const e of t)i.push(e.clone());return ns.createCapture(i,e)}clone(t){const e=t||new ns;e._clips.length=0;for(const t of this._clips)e._clips.push(t.clone());return e.boundingRange.setFrom(this.boundingRange),e}toJSON(){return this.isValid?this.clips.map((t=>t.toJSON())):[]}static fromJSON(t,e){if((e=e||new ns).clear(),!Array.isArray(t))return e;try{for(const i of t){const t=$i.fromJSON(i);t&&e._clips.push(t)}}catch(t){e.clear()}return e}clear(){this._clips.length=0}appendClone(t){this._clips.push(t.clone())}appendReference(t){this._clips.push(t)}appendShape(t,e,i,s,n=!1,r=!1){const o=es.createShape(t,e,i,s,n,r);return!!o&&(this._clips.push(o),!0)}pointInside(t,e=K.smallMetricDistanceSquared){return this.isPointOnOrInside(t,e)}isPointOnOrInside(t,e=K.smallMetricDistanceSquared){if(!this.boundingRange.isNull&&!this.boundingRange.containsPoint(t))return!1;for(const i of this._clips)if(!i.pointInside(t,e))return!1;return!0}ensureProxyClipNode(){if(this._clipNodeProxy)return!0;this._clipNodeProxy=new ss(!0);let t=0;for(const e of this._clips){const i=e.fetchClipPlanesRef();i&&(t++,this._clipNodeProxy.captureChild(i))}return t>0}announceClippedSegmentIntervals(t,e,i,s,n){return this.ensureProxyClipNode(),!!this._clipNodeProxy&&this._clipNodeProxy.announceClippedSegmentIntervals(t,e,i,s,n)}announceClippedArcIntervals(t,e){return this.ensureProxyClipNode(),!!this._clipNodeProxy&&this._clipNodeProxy.announceClippedArcIntervals(t,e)}appendPolygonClip(t,e,i,s){this.ensureProxyClipNode(),this._clipNodeProxy&&this._clipNodeProxy.appendPolygonClip(t,e,i,s)}transformInPlace(t){for(const e of this._clips)if(!1===e.transformInPlace(t))return!1;return this.boundingRange.isNull||t.multiplyRange(this.boundingRange,this.boundingRange),!0}extractBoundaryLoops(t,e){let i=b.None,s=-Number.MAX_VALUE,n=Number.MAX_VALUE;const r=[];let o,a=0;if(0===this._clips.length)return r;const c=pt.createIdentity();for(const e of this._clips)if(e instanceof es){if(void 0!==o&&e!==o){let t=pt.createIdentity(),i=pt.createIdentity();o.transformValid&&e.transformValid&&(t=e.transformFromClip.clone(),i=o.transformToClip.clone()),c.setFrom(i.multiplyTransformTransform(t))}if(o||(o=e),t[a]=[],void 0!==e.polygon){i=b.XAndY,e.zHighValid&&(i|=b.ZHigh,n=e.zHigh),e.zLowValid&&(i|=b.ZLow,s=e.zLow);for(const i of e.polygon)t[a].push(i.clone());c.multiplyPoint3dArray(t[a],t[a]),a++}}return r.push(i),r.push(s),r.push(n),e&&o&&e.setFrom(o.transformFromClip),r}setInvisible(t){for(const e of this._clips)e.setInvisible(t)}parseClipPlanes(){for(const t of this._clips)t.fetchClipPlanesRef()}multiplyPlanesByMatrix4d(t,e=!0,i=!0){if(e){const e=t.createInverse();return!!e&&this.multiplyPlanesByMatrix4d(e,!1,i)}for(const e of this._clips)e.multiplyPlanesByMatrix4d(t,!1,i);return!0}classifyPointContainment(t,e=!1){let i=X.Ambiguous;for(const s of this._clips){const n=s.classifyPointContainment(t,e);if(X.Ambiguous===n)return X.Ambiguous;if(X.Ambiguous===i)i=n;else if(i!==n)return X.Ambiguous}return i}classifyRangeContainment(t,e){const i=t.corners();return this.classifyPointContainment(i,e)}isAnyLineStringPointInside(t){for(const e of this._clips){const i=e.fetchClipPlanesRef();if(void 0!==i)for(let e=0;e+1<t.length;e++){const s=Pe.create(t[e],t[e+1]);if(i.isAnyPointInOrOnFromSegment(s))return!0}}return!1}sumSizes(t,e,i){let s=0;for(let n=e;n<i;n++)s+=t[n].x1-t[n].x0;return s}isLineStringCompletelyContained(t){const e=[];for(let i=0;i+1<t.length;i++){const s=Pe.create(t[i],t[i+1]);let n=0,r=0;for(const t of this._clips){const i=t.fetchClipPlanesRef();if(void 0!==i){i.appendIntervalsFromSegment(s,e);const t=e.length;if(n+=this.sumSizes(e,r,t),r=t,n>=ns._TARGET_FRACTION_SUM)break}}if(n<ns._TARGET_FRACTION_SUM)return!1}return!0}toCompactString(){function t(t){return`${t.toString()}_`}function i(i){let s=i.invisible?1:0;return s|=i.interior?2:0,`${function(t){const i=t.toString();return e(1===i.length),i}(s)}${n=i.inwardNormalRef,`${t(n.x)}${t(n.y)}${t(n.z)}`}${t(i.distance)}`;var n}function s(t){let e="";for(const s of t.planes)e=`${e}${i(s)}`;return`${e}_`}function n(t){let i=(t.invisible?1:0).toString();e(1===i.length);const n=t.fetchClipPlanesRef();if(n)for(const t of n.convexSets)i=`${i}${s(t)}`;return`${i}_`}let r="";for(const t of this.clips)r=`${r}${n(t)}`;return`${r}_`}}ns._TARGET_FRACTION_SUM=.99999999,function(t){t.fromClipVector=function(t){if(!t||!t.isValid)return;const i=t;void 0===i.clipString&&(i.clipString=t.toCompactString());const s=i;return e(void 0!==s.clipString),s}}(E||(E={}));class rs{constructor(t,e){this._positiveOffsetLeft=t,this._positiveOffsetRight=e,this._turnDegrees=60}static createUnit(t,e,i,s=!0){let n=e,r=e+1;const o=t.length-1;i?e<0?(n=o-1,r=o):e>=o&&(n=0,r=1):0===e?(n=0,r=1):r>o&&(n=o-1,r=o);const a=t.vectorIndexIndex(n,r);if(a)return s&&(a.z=0),a.normalize(a)}static createDirectedPlane(t,e,i,s,n=!1){return xr.createNormalAndPointXYZXYZ(e.x*s,e.y*s,e.z*s,t.x+i*e.x,t.y+i*e.y,t.z+i*e.z,n,n)}createChamferCut(t,e,i,s){const n=i.angleToXY(s).degrees;if(Math.abs(n)>this._turnDegrees){const r=i.interpolate(.5,s);r.rotate90CCWXY(r),r.normalizeInPlace(),n>0?t.addPlaneToConvexSet(rs.createDirectedPlane(e,r,-this._positiveOffsetRight,1,!1)):t.addPlaneToConvexSet(rs.createDirectedPlane(e,r,this._positiveOffsetLeft,-1,!1))}}createOffsetFromSegment(t,e,i,s,n){if(void 0===s)return;void 0===i&&(i=s),void 0===n&&(n=s);const r=i.interpolate(.5,s);r.normalizeInPlace();const o=s.rotate90CCWXY(),a=s.interpolate(.5,n);a.normalizeInPlace();const c=en.createEmpty();return c.addPlaneToConvexSet(rs.createDirectedPlane(t,o,this._positiveOffsetLeft,-1,!1)),c.addPlaneToConvexSet(rs.createDirectedPlane(t,o,-this._positiveOffsetRight,1,!1)),c.addPlaneToConvexSet(rs.createDirectedPlane(t,r,0,1,!0)),c.addPlaneToConvexSet(rs.createDirectedPlane(e,a,0,-1,!0)),this.createChamferCut(c,t,i,s),this.createChamferCut(c,e,s,n),c}static createClipBetweenOffsets(t,e,i,s,n){const r=new rs(e,i),o=Gi.createEmpty();if(t.length>1){const e=K.isSmallMetricDistance(t.distanceIndexIndex(0,t.length-1));for(let i=0;i+1<t.length;i++){const a=this.createUnit(t,i-1,e),c=this.createUnit(t,i,e),h=this.createUnit(t,i+1,e),l=r.createOffsetFromSegment(t.getPoint3dAtUncheckedPointIndex(i),t.getPoint3dAtUncheckedPointIndex(i+1),a,c,h);l?.addZClipPlanes(!1,s,n),l&&o.addConvexSet(l)}}else{const t=en.createEmpty();t?.addZClipPlanes(!1,s,n),t.planes.length>0&&o.addConvexSet(t)}return o}}!function(t){t[t.StronglyInside=1]="StronglyInside",t[t.Ambiguous=2]="Ambiguous",t[t.StronglyOutside=3]="StronglyOutside"}(X||(X={})),(U=R||(R={}))[U.acceptIn=1]="acceptIn",U[U.acceptOut=-1]="acceptOut",U[U.passToNextStep=0]="passToNextStep",function(t){t[t.ClipRequired=0]="ClipRequired",t[t.TrivialReject=1]="TrivialReject",t[t.TrivialAccept=2]="TrivialAccept"}(z||(z={}));class os{static selectIntervals01(t,e,i,s){e.push(0),e.push(1),e.sort();let n,r,o=e.atUncheckedIndex(0);const a=os._selectIntervals01TestPoint,c=e.length;for(let h=1;h<c;h++)if(n=e.atUncheckedIndex(h),n>o+K.smallFraction){if(r=.5*(o+n),r>=0&&r<=1&&(t.fractionToPoint(r,a),i.isPointOnOrInside(a))){if(!s)return!0;s(o,n,t)}o=n}return!1}static announceNNC(t,e,i){if(i)for(const s of t)i(s.low,s.high,e);return t.length>0}static collectClippedCurves(t,e){const i=[];return t.announceClipIntervals(e,((t,e,s)=>{if(e!==t){const n=s.clonePartialCurve(t,e);n&&i.push(n)}})),i}static clipAnyRegion(t,e){let i;const s=os._workTransform=Je.createRightHandedFrame(void 0,t,os._workTransform);if(!s)return i;const n=s?.inverse();if(!n)return i;const r=t.cloneTransformed(n);if(!r)return i;const o=os._workRange=r.range(),a=o.xLength(),c=o.yLength(),h=we.createRectangleXY(o.low,a,c,!0);h.tryTransformInPlace(s);const l=[],d=new Wi;if(e.appendPolygonClip?.(h.packedPoints,l,[],d),0===l.length)return i;for(const t of l){const e=Ke.createPolygon(t);e.tryTransformInPlace(n);const o=rr.regionBooleanXY(r,e,V.Intersection);o&&(o.tryTransformInPlace(s),i?i.tryAddChild(o)||i.children.push(...o.children):i=o instanceof Zi?o:Zi.create(o))}return i}static clipAnyCurve(t,e){if(t instanceof ie)return os.collectClippedCurves(t,e);if(t.isAnyRegionType){const i=os.clipAnyRegion(t,e);return i?[i]:[]}const i=[];if(t instanceof Fi||t instanceof Ge)for(const s of t.children){const t=os.clipAnyCurve(s,e);i.push(...t)}return i}static clipPolygonToClipShape(t,e){const i=this.clipPolygonToClipShapeReturnGrowableXYZArrays(t,e),s=[];for(const t of i)s.push(t.getPoint3dArray());return s}static clipPolygonToClipShapeReturnGrowableXYZArrays(t,e){const i=[],s=e.fetchClipPlanesRef();return s&&s.polygonClip(t,i),i}static pointSetSingleClipStatus(t,e,i){if(0===e.convexSets.length)return z.TrivialAccept;for(const s of e.convexSets){let e=!1,n=!1;for(const r of s.planes){let s=0,o=0;const a=r.distance-i,c=Q.create(),h=$.create();for(let e=0;e<t.length;e++)t.getPoint3dAtUncheckedPointIndex(e,c),h.setFrom(c),h.dotProduct(r.inwardNormalRef)>a?s++:o++;if(n=0!==o||n,0===s){e=!0;break}}if(!n)return z.TrivialAccept;if(!e)return z.ClipRequired}return z.TrivialReject}static announceLoopsOfConvexClipPlaneSetIntersectRange(t,e,i,s=!0,n=!0,r=!1){const o=new nt;if(s)if(t instanceof en)for(const s of t.planes){if(r&&s.invisible)continue;const n=s.intersectRange(e,!0),a=new nt;n&&(t.polygonClip(n,a,o,s),a.length>0&&i(a))}else if(r&&t.invisible);else{const s=t.intersectRange(e,!0);s&&i(s)}if(n){const s=e.corners();for(let e=0;e<6;e++){const n=ut.faceCornerIndices(e),r=new nt,a=we.createIndexedPoints(s,n);t instanceof en?(t.polygonClip(a.packedPoints,r,o),r.length>0&&i(r)):(t.clipConvexPolygonInPlace(a.packedPoints,o),a.packedPoints.length>0&&i(a.packedPoints))}}}static loopsOfConvexClipPlaneIntersectionWithRange(t,e,i=!0,s=!0,n=!1){const r=[];if(t instanceof Gi)for(const o of t.convexSets)this.announceLoopsOfConvexClipPlaneSetIntersectRange(o,e,(t=>{t.length>0&&r.push(Ke.createPolygon(t))}),i,s,n);else(t instanceof en||t instanceof xr)&&this.announceLoopsOfConvexClipPlaneSetIntersectRange(t,e,(t=>{t.length>0&&r.push(Ke.createPolygon(t))}),i,s,n);return r}static rangeOfConvexClipPlaneSetIntersectionWithRange(t,e){const i=ut.createNull();return this.announceLoopsOfConvexClipPlaneSetIntersectRange(t,e,(t=>{t.length>0&&i.extendArray(t)}),!0,!0,!1),i}static rangeOfClipperIntersectionWithRange(t,e,i=!0){if(void 0===t)return e.clone();if(t instanceof en)return this.rangeOfConvexClipPlaneSetIntersectionWithRange(t,e);if(t instanceof Gi){const i=ut.createNull();for(const s of t.convexSets){const t=this.rangeOfConvexClipPlaneSetIntersectionWithRange(s,e);i.extendRange(t)}return i}if(t instanceof $i)return i&&t.invisible?e.clone():this.rangeOfClipperIntersectionWithRange(t.fetchClipPlanesRef(),e);if(t instanceof ns){const s=e.clone();for(const n of t.clips)if(i&&n.invisible);else{const t=this.rangeOfClipperIntersectionWithRange(n,e,i);s.intersect(t,s)}return s}return e.clone()}static doesClipperIntersectRange(t,e,i=!0){if(void 0===t)return!0;if(t instanceof en)return this.doesConvexClipPlaneSetIntersectRange(t,e);if(t instanceof Gi){for(const i of t.convexSets)if(this.doesConvexClipPlaneSetIntersectRange(i,e))return!0;return!1}if(t instanceof $i)return!(!i||!t.invisible)||this.doesClipperIntersectRange(t.fetchClipPlanesRef(),e);if(t instanceof ns){const s=e.clone();for(const n of t.clips)if(i&&n.invisible);else{const t=this.rangeOfClipperIntersectionWithRange(n,e,i);s.intersect(t,s)}return!s.isNull}return!1}static doesConvexClipPlaneSetIntersectRange(t,e,i=!0,s=!0,n=!1){const r=new nt;if(i)for(const i of t.planes){if(n&&i.invisible)continue;const s=i.intersectRange(e,!0);if(s){const e=new nt;if(t.polygonClip(s,e,r,i),e.length>0)return!0}}if(s){const i=e.corners();for(let e=0;e<6;e++){const s=ut.faceCornerIndices(e),n=new nt,o=we.createIndexedPoints(i,s);if(t.polygonClip(o.packedPoints,n,r),n.length>0)return!0}}return!1}static doLocalRangesIntersect(t,e,i,s,n){const r=os._workTransform=s.inverse(os._workTransform);if(!r)return!1;let o=i;n&&(o=os._workRange=i.clone(os._workRange),o.expandInPlace(n));const a=r.multiplyTransformTransform(e,r),c=Rn.create();c.addTransformedRangeMesh(a,t);const h=c.claimPolyface(),l=os._workClipper=en.createConvexPolyface(h,os._workClipper).clipper;return os.doesClipperIntersectRange(l,o)}static isClipper(t){return!!(t&&t.isPointOnOrInside&&t.announceClippedSegmentIntervals&&t.announceClippedArcIntervals)}static restoreSingletonInPlaceOfMultipleShards(t,e,i,s){if(t&&t.length>e+1){for(;t.length>e;){const e=t.pop();s.dropToCache(e)}t.push(s.grabAndFill(i))}}static createXYOffsetClipFromLineString(t,e,i,s,n){return Array.isArray(t)?rs.createClipBetweenOffsets(new se(t),e,i,s,n):rs.createClipBetweenOffsets(t,e,i,s,n)}static captureOrDrop(t,e,i,s){t.length>=e?i.push(t):s.dropToCache(t)}static clipSegmentToLLeftOfLineXY(t,e,i,s,n,r=1e-14){const o=e.x-t.x,a=e.y-t.y,c=-(o*(i.y-t.y)-a*(i.x-t.x)),h=-(o*(s.y-t.y)-a*(s.x-t.x));if(!(c<r&&h<r))if(c*h>0)c>0&&n.setNull();else{if(c*h<0){const t=-c/(h-c);return c<0?n.intersectRangeXXInPlace(0,t):n.intersectRangeXXInPlace(t,1)}c>0?n.intersectRangeXXInPlace(1,1):h>0&&n.intersectRangeXXInPlace(0,0)}}static clipSegmentToCCWTriangleXY(t,e,i,s,n,r,o=1e-14){r.isNull||(this.clipSegmentToLLeftOfLineXY(t,e,s,n,r,o),r.isNull||(this.clipSegmentToLLeftOfLineXY(e,i,s,n,r,o),r.isNull||this.clipSegmentToLLeftOfLineXY(i,t,s,n,r,o)))}static clipSegmentBelowPlaneXY(t,e,i,s,n=1e-14){const r=t.altitudeXY(e.x,e.y),o=t.altitudeXY(i.x,i.y);if(!(r<n&&o<n))if(r*o>0)r>0&&s.setNull();else{if(r*o<0){const t=-r/(o-r);return r<0?s.intersectRangeXXInPlace(0,t):s.intersectRangeXXInPlace(t,1)}r>0?s.intersectRangeXXInPlace(1,1):o>0&&s.intersectRangeXXInPlace(0,0)}}static clipSegmentBelowPlanesXY(t,e,i,s,n=1e-14){const r=t.length;for(let o=0;!s.isNull&&o<r;o++)this.clipSegmentBelowPlaneXY(t[o],e,i,s,n)}static announcePolylineClip(t,e,i){for(let s=0;s+1<e.length;s++)t.announceClippedSegmentIntervals(0,1,e[s],e[s+1],((t,n)=>{i(e[s].interpolate(t,e[s+1]),e[s].interpolate(n,e[s+1]))}))}static sumPolylineClipLength(t,e){let i=0;for(let s=0;s+1<e.length;s++){const n=e[s].distance(e[s+1]);t.announceClippedSegmentIntervals(0,1,e[s],e[s+1],((t,e)=>{i+=Math.abs(e-t)*n}))}return i}static doPolygonClipSequence(t,e,i,s,n,r,o,a,c){void 0===c&&(c=new Wi);let h=[c.grabAndFill(t)],l=[];const d=[],u=[],f=i?i.length:0,g=s?s.length:0;let p;for(const t of e)if(t.appendPolygonClip){for(;void 0!==(p=h.pop());)t.appendPolygonClip(p,d,u,c),cs(r,d,i,s,l,c),cs(o,u,i,s,l,c),c.dropToCache(p);const e=h;h=l,l=e}cs(a,h,i,s,n,c),s?.length===g&&os.restoreSingletonInPlaceOfMultipleShards(i,f,t,c),i?.length===f&&os.restoreSingletonInPlaceOfMultipleShards(s,g,t,c)}static doPolygonClipParitySequence(t,e,i,s,n){void 0===n&&(n=new Wi);let r=[n.grabAndFill(t)],o=[],a=[],c=[];const h=[],l=[];let d;for(const t of e)if(t.appendPolygonClip){for(;void 0!==(d=o.pop());)t.appendPolygonClip(d,h,l,n),cs(R.acceptOut,h,a,c,void 0,n),cs(R.acceptIn,l,a,c,void 0,n),n.dropToCache(d);for(;void 0!==(d=r.pop());)t.appendPolygonClip(d,h,l,n),cs(R.acceptIn,h,a,c,void 0,n),cs(R.acceptOut,l,a,c,void 0,n),n.dropToCache(d);const e=o;o=a,a=e;const i=r;r=c,c=i}0===r.length?i?.push(n.grabAndFill(t)):0===r.length?s?.push(n.grabAndFill(t)):(as(o,i,n),as(r,s,n))}static createComplementaryClips(t){const e=t.planes,i=ft.createNull(),s=e.length,n=[];for(const t of e){const e=en.createEmpty();e.addPlaneToConvexSet(t.cloneNegated()),n.push(e)}for(let r=0;r<s;r++)for(let o=r+1;o<s;o++){const s=pn.planePlaneIntersectionRay(e[r],e[o]);if(s&&t.hasIntersectionWithRay(s,i)){const t=e[o].inwardNormalRef.minus(e[r].inwardNormalRef),i=xr.createNormalAndPoint(t,s.origin);if(i){const t=i.cloneNegated();n[r].addPlaneToConvexSet(i),n[o].addPlaneToConvexSet(t)}}}return Gi.createConvexSets(n)}}function as(t,e,i){if(void 0===e)i.dropAllToCache(t);else for(const i of t)e.push(i);t.length=0}function cs(t,e,i,s,n,r){let o;if(t===R.acceptIn?o=i:t===R.acceptOut?o=s:t===R.passToNextStep&&(o=n),void 0===o)r.dropAllToCache(e);else for(const t of e)o.push(t);e.length=0}os._selectIntervals01TestPoint=Q.create();class hs{constructor(t,e){this._graph=t,this._candidates=[],this._mask=e,this._graph.clearMask(e)}clear(){for(;void 0!==this.chooseAndRemoveAny(););}getLength(){let t=0;for(const e of this._candidates)e.isMaskSet(this._mask)&&t++;return t}getNumCandidates(){return this._candidates.length}get graph(){return this._graph}teardown(){this._graph.dropMask(this._mask),this._candidates.length=0}get mask(){return this._mask}popAndReturn(){const t=this._candidates.length;if(0===t)return;const e=this._candidates[t-1];return this._candidates.pop(),e}getAtIndex(t){if(t>=0&&t<this._candidates.length){const e=this._candidates[t];if(e.isMaskSet(this._mask))return e}}addToSet(t){return!t.isMaskSet(this._mask)&&(this._candidates.push(t),this.setMaskInScope(t),!0)}isCandidateInSet(t){return t.isMaskSet(this._mask)}removeFromSet(t){return!!t.isMaskSet(this._mask)&&(this.clearMaskInScope(t),!0)}chooseAndRemoveAny(){for(;;){const t=this.popAndReturn();if(!t)return;if(this.removeFromSet(t))return t}}[Symbol.iterator](){return new ds(this)}addAroundFace(t){let e=t;do{this.addToSet(e),e=e.faceSuccessor}while(e!==t)}addAroundVertex(t){let e=t;do{this.addToSet(e),e=e.vertexSuccessor}while(e!==t)}}class ls extends hs{constructor(t,e){super(t,e)}static create(t){const e=t.grabMask();if(e!==M.NULL_MASK)return new ls(t,e)}setMaskInScope(t){t.setMaskAroundEdge(this._mask)}clearMaskInScope(t){t.clearMaskAroundEdge(this._mask)}countHalfEdgesAroundCandidate(t){return t?2:0}}class ds{constructor(t){this._markSet=t,this._nextReadIndex=0}next(){const t=this._markSet.getNumCandidates();for(;this._nextReadIndex<t;){const t=this._markSet.getAtIndex(this._nextReadIndex++);if(void 0!==t)return{done:!1,value:t}}return{done:!0,value:void 0}}[Symbol.iterator](){return this}}class us{constructor(t,e,i,s,n,r){this._x=e,this._y=i,this._z=s,this._u=n,this._v=r,this._node=t}set(t,e,i,s,n,r){return this._x=e,this._y=i,this._z=s,this._u=n,this._v=r,this._node=t,this}setFrom(t){this._x=t.x,this._y=t.y,this._z=t.z,this._u=t.u,this._v=t.v,this._node=t.node}static createNodeAndRayOrigin(t,e,i){const s=t.x,n=t.y,r=t.z,o=s-e.origin.x,a=n-e.origin.y,c=K.dotProductXYXY(o,a,e.direction.x,e.direction.y),h=K.crossProductXYXY(e.direction.x,e.direction.y,o,a);return i?i.set(t,s,n,r,c,h):new us(t,s,n,r,c,h)}static create(t,e=0,i=0,s=0,n=0,r=0){return new us(t,e,i,s,n,r)}get node(){return this._node}get x(){return this._x}get y(){return this._y}get z(){return this._z}get u(){return this._u}get v(){return this._v}getXYZAsPoint3d(t){return Q.create(this._x,this._y,this._z,t)}getUVAsPoint2d(t){return H.create(this._u,this._v,t)}classifyU(t,e){const i=this.u-t;return Math.abs(i)<=e?0:i>=0?1:-1}classifyV(t,e){const i=t-this._v;return Math.abs(i)<=e?0:i>=0?1:-1}}!function(t){t[t.None=0]="None",t[t.Vertex=1]="Vertex",t[t.Edge=2]="Edge",t[t.Face=3]="Face",t[t.ExteriorFace=4]="ExteriorFace"}(D||(D={}));class fs{constructor(t,e,i,s,n,r,o,a,c){this._node=t,this.x=e,this.y=i,this.z=s,this._topo=n,this._edgeFraction=r,this._iTag=o,this._dTag=a,this._isExteriorTarget=c}setFrom(t){this._node=t._node,this.x=t.x,this.y=t.y,this.z=t.z,this._topo=t._topo,this._edgeFraction=t._edgeFraction,this._iTag=t._iTag,this._dTag=t._dTag}resetAsUnknown(){this._node=void 0,this._topo=D.None}static create(){return new fs(void 0,0,0,0,D.None)}getITag(){return this._iTag}setITag(t){this._iTag=t}getDTag(){return this._dTag}setDTag(t){this._dTag=t}getTopo(){return this._topo}static createEdgeAtFraction(t,e){const i=t.faceSuccessor,s=K.interpolate(t.x,e,i.x),n=K.interpolate(t.y,e,i.y),r=K.interpolate(t.z,e,i.z);return new fs(t,s,n,r,D.Edge,e)}resetAsFace(t,e){return this._topo=D.Face,t&&(this._node=t),e&&(this.x=e.x,this.y=e.y,this.z=e.z),this._isExteriorTarget=void 0,this}resetAsUndefinedWithTag(t){return this._topo=D.None,this._dTag=0,this._iTag=0,this._dTag=t,this._node=void 0,this._isExteriorTarget=void 0,this}resetAtEdgeAndFraction(t,e){this._topo=D.Edge,this._node=t;const i=t.faceSuccessor;return this._edgeFraction=e,this.x=K.interpolate(t.x,e,i.x),this.y=K.interpolate(t.y,e,i.y),this.z=K.interpolate(t.z,e,i.z),this._isExteriorTarget=void 0,this}static createVertex(t){return new fs(t,t.x,t.y,t.z,D.Vertex)}resetAsVertex(t){return this._topo=D.Vertex,this._node=t,this._edgeFraction=0,this.setXYZFromNode(t),this._isExteriorTarget=void 0,this}setIsExteriorTarget(t){this._isExteriorTarget=t}setXYZFromNode(t){this.x=t.x,this.y=t.y,this.z=t.z}get edgeFraction(){return this._edgeFraction}get isExteriorTarget(){return void 0!==this._isExteriorTarget&&this._isExteriorTarget}get isFace(){return this._topo===D.Face}get isEdge(){return this._topo===D.Edge}get isVertex(){return this._topo===D.Vertex}get isUnclassified(){return this._topo===D.None}get node(){return this._node}clonePoint(t){return Q.create(this.x,this.y,this.z,t)}isAtXY(t,e){return this._topo!==D.None&&K.isSameCoordinate(this.x,t)&&K.isSameCoordinate(this.y,e)}}!function(t){t[t.RC_NoHits=0]="RC_NoHits",t[t.RC_TargetOnVertex=1]="RC_TargetOnVertex",t[t.RC_TargetOnEdge=2]="RC_TargetOnEdge",t[t.RC_Bracket=3]="RC_Bracket",t[t.RC_TargetBefore=4]="RC_TargetBefore",t[t.RC_TargetAfter=5]="RC_TargetAfter"}(Y||(Y={}));class gs{constructor(t){this._tol=t}static create(t=K.smallMetricDistance){return new gs(t)}panic(){return fs.create()}reAimFromEdge(t,e,i){const s=t.node,n=us.createNodeAndRayOrigin(s,e),r=us.createNodeAndRayOrigin(s.edgeMate,e),o=-n.classifyV(0,this._tol),a=-r.classifyV(0,this._tol);let c;if(o*a<0)c=o>0?t.resetAsFace(n.node):t.resetAsFace(r.node);else if(0===o||0===a){const e=n.classifyU(i,this._tol),s=r.classifyU(i,this._tol);if(0===e&&0===o)c=t.resetAsVertex(n.node),c.setITag(1);else if(0===s&&0===a)c=t.resetAsVertex(r.node),c.setITag(1);else if(e*s<0){const e=(i-n.u)/(r.u-n.u);c=t.resetAtEdgeAndFraction(n.node,e),c.setITag(1)}else e<0&&s<0?c=n.u>r.u?t.resetAsVertex(n.node):t.resetAsVertex(r.node):Math.abs(n.u)<this._tol&&Math.abs(n.v)<this._tol?c=t.resetAsVertex(n.node):Math.abs(r.u)<this._tol&&Math.abs(r.v)<this._tol?c=t.resetAsVertex(r.node):(t.resetAsUnknown(),c=this.panic())}else t.resetAsUnknown(),c=this.panic();return c}reAimFromVertex(t,e,i){const s=t.node;let n,r=s;do{const s=us.createNodeAndRayOrigin(r.faceSuccessor,e),o=us.createNodeAndRayOrigin(r.facePredecessor,e),a=s.u,c=s.v,h=o.v;if(Math.abs(c)<this._tol){if(Math.abs(a-i)<this._tol)return n=t.resetAsVertex(s.node),n.setITag(1),n;if(a>i){const e=i/a;return n=t.resetAtEdgeAndFraction(r,e),n}if(Math.abs(a)<=this._tol)return n=t.resetAsVertex(r),n.setITag(1),n;if(a>this._tol)return n=t.resetAsVertex(s.node),n;if(h>this._tol)return n=t.resetAsFace(r,r),n}else if(c<-this._tol&&h>this._tol)return n=t.resetAsFace(r,r),n;r=r.vertexSuccessor}while(r!==s);return this.panic()}reAimAroundFace(t,e,i,s,n){s.resetAsUndefinedWithTag(-Number.MAX_VALUE),n.resetAsUndefinedWithTag(Number.MAX_VALUE);const r=us.createNodeAndRayOrigin(t,e);let o,a=t;do{const t=a.faceSuccessor;o=us.createNodeAndRayOrigin(t,e,o);const c=r.u,h=o.u,l=r.v,d=o.v;if(Math.abs(d)<this._tol){const e=fs.createVertex(t);if(e.setDTag(h),Math.abs(h-i)<this._tol)return n.setFrom(e),s.setFrom(e),Y.RC_TargetOnVertex;h>i&&h<n.getDTag()&&n.setFrom(e),h<i&&h>s.getDTag()&&s.setFrom(e)}else if(l*d<0){const t=-l/(d-l),e=K.interpolate(c,t,h),o=fs.createEdgeAtFraction(r.node,t);if(o.setDTag(e),Math.abs(e-i)<=this._tol)return n.setFrom(o),s.setFrom(o),Y.RC_TargetOnEdge;e>i&&e<n.getDTag()&&(n.setFrom(o),n.setITag(l>0?-1:1)),e<i&&e>s.getDTag()&&(s.setFrom(o),s.setDTag(e))}r.setFrom(o),a=a.faceSuccessor}while(a!==t);const c=n.getITag();return n.setITag(0),s.setITag(0),s.isUnclassified?n.isUnclassified?Y.RC_NoHits:Y.RC_TargetBefore:n.isUnclassified||n.isEdge&&c&&c<0?Y.RC_TargetAfter:Y.RC_Bracket}setSearchRay(t,e,i){i.origin.setFromPoint3d(t),$.createStartEnd(i.origin,e,i.direction),i.direction.z=0;const s=i.direction.magnitudeXY();return i.a=i.direction.magnitude(),i.direction.scaleInPlace(1/i.a),s>=this._tol}}class ps{constructor(t){this._graph=t,this._edgeSet=ls.create(t),this._searcher=fs.create()}static create(t){return new ps(t)}get graph(){return this._graph}retriangulateFromBaseVertex(t){const e=t.countEdgesAroundFace();if(this._edgeSet.addAroundFace(t),e<4||t.signedFaceArea()<=0)return;const i=e-3;let s=t.faceSuccessor,n=t;for(let t=0;t<i;t++)s=s.faceSuccessor,n=this._graph.createEdgeHalfEdgeHalfEdge(n,0,s,0),s=n.faceSuccessor,this._edgeSet.addToSet(n)}reset(){this._searcher=fs.create()}get currentPosition(){return this._searcher}searchForNearestEdgeOrVertex(t){const e=fs.create();e.setDTag(Number.MAX_VALUE);const i=Q.create();let s,n;for(const r of this._graph.allHalfEdges){const o=r.faceSuccessor;s=Ft.lineSegment3dXYClosestPointUnbounded(r,o,t),void 0!==s&&(s>1?(n=t.distanceXY(o),n<e.getDTag()&&(e.resetAsVertex(o),e.setDTag(n))):s<0?(n=t.distanceXY(r),n<e.getDTag()&&(e.resetAsVertex(r),e.setDTag(n))):(r.fractionToPoint3d(s,i),n=t.distanceXY(i),n<e.getDTag()&&e.resetAtEdgeAndFraction(r,s)))}return e}searchForNearestVertex(t){const e=fs.create();let i;e.setDTag(Number.MAX_VALUE);for(const s of this._graph.allHalfEdges)i=t.distanceXY(s),i<e.getDTag()&&(e.resetAsVertex(s),e.setDTag(i));return e}resetSearch(t,e){this._searcher=e>0?this.searchForNearestEdgeOrVertex(t):this.searchForNearestVertex(t)}insertAndRetriangulate(t,e){this.moveToPoint(this._searcher,t);const i=this._searcher.node;let s=!1;if(void 0===i);else if(this._searcher.isFace){if(!i.isMaskSet(M.EXTERIOR)){const e=this._graph.createEdgeXYZHalfEdge(t.x,t.y,t.z,0,i,0);this.retriangulateFromBaseVertex(e),ms.flipTrianglesInEdgeSet(this._graph,this._edgeSet),this._searcher.resetAsVertex(e)}s=!0}else if(this._searcher.isEdge){const t=this._graph.splitEdgeAtFraction(i,this._searcher.edgeFraction),e=t.vertexPredecessor;this.retriangulateFromBaseVertex(t),this.retriangulateFromBaseVertex(e),ms.flipTrianglesInEdgeSet(this._graph,this._edgeSet),this._searcher.resetAsVertex(t),s=!0}else this._searcher.isVertex?(e&&i.setXYZAroundVertex(t.x,t.y,t.z),s=!0):s=!1;return s}moveToPoint(t,e,i){const s=gs.create();if(t.setITag(0),t.isUnclassified&&(function(t,e,i,s){for(const i of t.allHalfEdges)if(!i.isMaskSet(0))return e.resetAtEdgeAndFraction(i,.5),!0}(this.graph,t),t.isUnclassified))return!1;let n=0;const r=bt.createXAxis();for(;0===t.getITag()&&n<2&&(void 0===i||i(t));){if(!s.setSearchRay(t,e,r))return!1;if(t.isFace){const i=fs.create(),o=fs.create();switch(s.reAimAroundFace(t.node,r,r.a,i,o)){case Y.RC_NoHits:t.resetAsUnknown();break;case Y.RC_TargetOnVertex:case Y.RC_TargetOnEdge:t.setFrom(i),t.setITag(1);break;case Y.RC_Bracket:t.resetAsFace(i.node,e),t.setITag(1);break;case Y.RC_TargetBefore:t.resetAsFace(t.node,e),t.setITag(1);break;case Y.RC_TargetAfter:t.node===i.node&&t.isFace&&(i.isEdge||i.isVertex)?n++:n=0,t.setFrom(i)}}else if(t.isEdge){if(s.reAimFromEdge(t,r,r.a),t.isUnclassified)break}else if(t.isVertex&&(s.reAimFromVertex(t,r,r.a),t.isUnclassified))break}return!!t.isAtXY(e.x,e.y)||n>1&&(void 0!==t.node&&t.setIsExteriorTarget(!0),!1)}}class ms{static flipEdgeBetweenTriangles(t,e,i,s,n,r){Oi.pinch(t,n),Oi.pinch(i,s),Oi.pinch(r,i),Oi.pinch(n,e),n.x=e.x,n.y=e.y,n.z=e.z,n.i=e.i,i.i=r.i,i.x=r.x,i.y=r.y,i.z=r.z}static computeInCircleDeterminantIsStrongPositive(t){const e=t.faceSuccessor,i=e.faceSuccessor;if(i.faceSuccessor!==t)return!1;const s=t.edgeMate,n=s.faceSuccessor.faceSuccessor;if(n.faceSuccessor!==s)return!1;const r=e.x-t.x,o=e.y-t.y,a=i.x-t.x,c=i.y-t.y;if(K.crossProductXYXY(r,o,a,c)<0)return!1;const h=n.x-t.x,l=n.y-t.y,d=h*h+l*l,u=a*a+c*c,f=r*r+o*o,g=K.tripleProduct(h,l,d,a,c,u,r,o,f);return!(g<0)&&g>1e-12*(Math.abs(h*c*f)+Math.abs(l*u*r)+Math.abs(d*a*o)+Math.abs(h*u*o)+Math.abs(l*a*f)+Math.abs(d*c*r))}static flipTriangles(t){const e=ls.create(t);for(const i of t.allHalfEdges)e.addToSet(i);const i=this.flipTrianglesInEdgeSet(t,e);return e.teardown(),i}static flipTrianglesInEdgeSet(t,e){const i=M.EXTERIOR|M.PRIMARY_EDGE|M.BOUNDARY_EDGE,s=10*t.allHalfEdges.length;let n,r=0,o=0;for(;void 0!==(n=e.chooseAndRemoveAny())&&(n.isMaskSet(i)||(ms.computeInCircleDeterminantIsStrongPositive(n)?(ms.flipEdgeBetweenTriangles(n.edgeMate.faceSuccessor,n.edgeMate.facePredecessor,n.edgeMate,n.faceSuccessor,n,n.facePredecessor),e.addAroundFace(n),e.addAroundFace(n.edgeMate),r++):o++,!(r+o>s))););return r}static createTriangulatedGraphFromPoints(t){if(t.length<3)return;const e=[],i=[];ae.computeConvexHullXY(t,e,i,!0);const s=new Bi,n=ps.create(s);ms.createFaceLoopFromCoordinates(s,e,!0,!0);let r=0;for(const t of i)n.insertAndRetriangulate(t,!0),r++,r>16&&(r=0);return s}static createTriangulatedGraphFromLoops(t){if(t.length<1)return;const e=M.BOUNDARY_EDGE|M.PRIMARY_EDGE,i=new Bi,s=[];let n=-1e4,r=-1;for(let o=0;o<t.length;o++){let a=ms.directCreateFaceLoopFromCoordinates(i,t[o]);if(a){a=a.faceSuccessor;const t=a.vertexSuccessor;a.setMaskAroundFace(e),t.setMaskAroundFace(e);const i=a.signedFaceArea(),c=Math.abs(i);s.push(i>=0?a:t),(0===o||c>n)&&(n=c,r=o)}}if(0===s.length)return;const o=s[r];s[r]=s[s.length-1],s.pop(),o.vertexSuccessor.setMaskAroundFace(M.EXTERIOR);for(let t=0;t<s.length;t++){const e=s[t];e.setMaskAroundFace(M.EXTERIOR),s[t]=this.getLeftmost(e.vertexSuccessor)}const a=ms.spliceLeftMostNodesOfHoles(i,o,s);return a&&ms.triangulateSingleFace(i,a)?i:void 0}static triangulateAllPositiveAreaFaces(t){const e=t.collectFaceLoops();let i=0;for(const s of e)s.countEdgesAroundFace()>3&&s.signedFaceArea()>0&&(ms.triangulateSingleFace(t,s)||i++);return 0===i}static createTriangulatedGraphFromSingleLoop(t){const e=new Bi,i=ms.createFaceLoopFromCoordinates(e,t,!0,!0);return!i||e.countNodes()<6?e:ms.triangulateSingleFace(e,i)?(ms.flipTriangles(e),e):void 0}static interiorEdgeSplit(t,e,i){let s=0,n=0,r=0;if(Array.isArray(i))s=i[0],n=i[1],r=i.length>2?i[3]:0;else{const t=i;t.hasOwnProperty("x")&&(s=t.x),t.hasOwnProperty("y")&&(n=t.y),t.hasOwnProperty("z")&&(r=t.z)}return e&&(ms.isAlmostEqualXAndYXY(e,s,n)||ms.isAlmostEqualXAndYXY(e.faceSuccessor,s,n))?e:t.splitEdge(e,s,n,r)}static directCreateFaceLoopFromCoordinates(t,e){let i;if(e instanceof it){const s=Q.create();for(let n=0;n<e.length;n++)e.getPoint3dAtCheckedPointIndex(n,s),i=ms.interiorEdgeSplit(t,i,s)}else for(const s of e)i=ms.interiorEdgeSplit(t,i,s);return i}static directCreateChainsFromCoordinates(t,e,i=0){const s=new xs(t,i);return lt.streamXYZ(e,s),s.claimSeeds()}static maskAndOrientNewFaceLoop(t,e,i,s,n){if(e){const t=(e=e.faceSuccessor).signedFaceArea(),r=e.edgeMate;s!==M.NULL_MASK&&(e.setMaskAroundFace(s),r.setMaskAroundFace(s));let o=e;i&&t<0&&(o=r);const a=o.vertexSuccessor;return n!==M.NULL_MASK&&a.setMaskAroundFace(n),o}}static createFaceLoopFromCoordinates(t,e,i,s){const n=ms.directCreateFaceLoopFromCoordinates(t,e);return ms.maskAndOrientNewFaceLoop(t,n,i,M.BOUNDARY_EDGE|M.PRIMARY_EDGE,s?M.EXTERIOR:M.NULL_MASK)}static createFaceLoopFromCoordinatesAndMasks(t,e,i,s,n){const r=ms.directCreateFaceLoopFromCoordinates(t,e);return ms.maskAndOrientNewFaceLoop(t,r,i,s,n)}static joinNeighborsOfEar(t,e){const i=t.createEdgeXYZXYZ(e.facePredecessor.x,e.facePredecessor.y,e.facePredecessor.z,e.facePredecessor.i,e.faceSuccessor.x,e.faceSuccessor.y,e.faceSuccessor.z,e.faceSuccessor.i),s=i.edgeMate;Oi.pinch(e.faceSuccessor,s),Oi.pinch(e.facePredecessor,i),e.setMaskAroundFace(M.TRIANGULATED_FACE)}static isInteriorTriangle(t){if(!t.isMaskSet(M.TRIANGULATED_FACE)||t.isMaskSet(M.EXTERIOR))return!1;const e=t.faceSuccessor;if(!e.isMaskSet(M.TRIANGULATED_FACE)||e.isMaskSet(M.EXTERIOR))return!1;const i=e.faceSuccessor;return!(!i.isMaskSet(M.TRIANGULATED_FACE)||i.isMaskSet(M.EXTERIOR))&&i.faceSuccessor===t}static doPostCutFlips(t){let e=t,i=e.facePredecessor,s=i.edgeMate;for(;ms.isInteriorTriangle(i)&&ms.isInteriorTriangle(s)&&ms.computeInCircleDeterminantIsStrongPositive(i);){const t=s.faceSuccessor;ms.flipEdgeBetweenTriangles(t,t.faceSuccessor,t.facePredecessor,e,e.facePredecessor,e.faceSuccessor),e=i,i=e.facePredecessor,s=i.edgeMate}return e}static triangulateSingleFace(t,e){if(!e)return ms.setDebugGraph(t),!1;let i,s,n,r=e.countEdgesAroundFace(),o=0;for(e.clearMaskAroundFace(M.TRIANGULATED_FACE);!e.isMaskSet(M.TRIANGULATED_FACE);){if(n=e?.facePredecessor,i=e.faceSuccessor,s=i.faceSuccessor,i===e||s===e)return!0;if(s.faceSuccessor===e)return e.setMaskAroundFace(M.TRIANGULATED_FACE),!0;if(!K.isAlmostEqualXAndY(s,n)||s.findAroundVertex(n)){if(++o>r)return ms.setDebugGraph(t),!1;ms.isEar(e)?(r--,o=0,e.faceSuccessor.faceSuccessor!==e.facePredecessor?(ms.joinNeighborsOfEar(t,e),e=(e=ms.doPostCutFlips(e)).faceSuccessor.edgeMate.faceSuccessor):(e.setMaskAroundFace(M.TRIANGULATED_FACE),e=i.faceSuccessor)):e=i}else Oi.pinch(n,s),e.setMaskAroundFace(M.TRIANGULATED_FACE),e=s}return!0}static claimDebugGraph(){const t=ms.sDebugGraph;return ms.sDebugGraph=void 0,ms.sEnableDebugGraphCapture=!1,t}static setDebugGraph(t){ms.sEnableDebugGraphCapture&&(ms.sDebugGraph=t)}static clearAndEnableDebugGraphCapture(t){ms.sEnableDebugGraphCapture=t,ms.sDebugGraph=void 0}static isEar(t){const e=t.facePredecessor,i=t,s=t.faceSuccessor,n=ms.signedTolerancedCCWTriangleArea(e,i,s);if(n<=0)return!1;const r=this._planes;if(!yt.createOriginAndTargetXY(e,i,r[0])||!yt.createOriginAndTargetXY(i,s,r[1])||!yt.createOriginAndTargetXY(s,e,r[2]))return!1;const o=this._earRange,a=this._edgeRange,c=this._edgeInterval;gt.createXYXYXY(e.x,e.y,i.x,i.y,s.x,s.y,o),o.expandInPlace(K.smallMetricDistance);let h=s;const l=1e-10*n;for(;h!==e;){const t=h.faceSuccessor;if(gt.createXYXY(h.x,h.y,t.x,t.y,a),o.intersectsRange(a)&&(ft.createXX(-1e-8,1.00000001,c),os.clipSegmentBelowPlanesXY(r,h,t,c,l),!c.isNull)){const n=h.edgeMate;if(n===e||n===i);else if(c.low>.99999999){if(!e.findAroundVertex(t)&&!i.findAroundVertex(t)&&!s.findAroundVertex(t))return!1}else{if(!(c.high<1e-8))return!1;if(!e.findAroundVertex(h)&&!i.findAroundVertex(h)&&!s.findAroundVertex(h))return!1}}h=h.faceSuccessor}return!0}static spliceLeftMostNodesOfHoles(t,e,i){i.sort(((t,e)=>ms.compareX(t,e)));let s=0;for(const n of i)ms.eliminateHole(t,n,e)||s++;return 0===s?e:void 0}static compareX(t,e){return t.x-e.x}static eliminateHole(t,e,i){const s=ms.findHoleBridge(e,i);return!!s&&void 0!==ms.splitFace(t,s,e)}static findHoleBridge(t,e){let i=e;if(!i)return;const s=t.x,n=t.y;let r,o=-1/0;do{if(n<=i.y&&n>=i.faceSuccessor.y&&i.faceSuccessor.y!==i.y){const t=i.x+(n-i.y)*(i.faceSuccessor.x-i.x)/(i.faceSuccessor.y-i.y);if(t<=s&&t>o){if(o=t,t===s){if(n===i.y)return i;if(n===i.faceSuccessor.y)return i.faceSuccessor}r=i.x<i.faceSuccessor.x?i:i.faceSuccessor}}i=i.faceSuccessor}while(i!==e);if(!r)return;if(s===o)return r.facePredecessor;const a=r,c=r.x,h=r.y;let l,d=1/0;for(i=r.faceSuccessor;i!==a;)s>=i.x&&i.x>=c&&s!==i.x&&ms.pointInTriangle(n<h?s:o,n,c,h,n<h?o:s,n,i.x,i.y)&&(l=Math.abs(n-i.y)/(s-i.x),(l<d||l===d&&i.x>r.x)&&ms.locallyInside(i,t)&&(r=i,d=l)),i=i.faceSuccessor;return r}static getLeftmost(t){let e=t,i=t;do{e.x<i.x&&(i=e),e=e.faceSuccessor}while(e!==t);return i}static pointInTriangle(t,e,i,s,n,r,o,a){return(n-o)*(e-a)-(t-o)*(r-a)>=0&&(t-o)*(s-a)-(i-o)*(e-a)>=0&&(i-o)*(r-a)-(n-o)*(s-a)>=0}static nodeInTriangle(t,e,i,s){return ms.signedTolerancedCCWTriangleArea(t,e,s)>0&&ms.signedTolerancedCCWTriangleArea(e,i,s)>0&&ms.signedTolerancedCCWTriangleArea(i,t,s)>0}static signedCWTriangleArea(t,e,i){return.5*((e.y-t.y)*(i.x-e.x)-(e.x-t.x)*(i.y-e.y))}static signedTolerancedCCWTriangleArea(t,e,i,s=1e-12){const n=e.x-t.x,r=e.y-t.y,o=i.x-t.x,a=i.y-t.y,c=.5*(n*a-r*o);return c<0?c:c<s*(n*n+r*r+(o*o+a*a))?0:c}static isAlmostEqualXAndYXY(t,e,i){return K.isAlmostEqualNumber(t.x,e)&&K.isAlmostEqualNumber(t.y,i)}static locallyInside(t,e){return ms.signedCWTriangleArea(t.facePredecessor,t,t.faceSuccessor)<0?ms.signedCWTriangleArea(t,e,t.faceSuccessor)>=0&&ms.signedCWTriangleArea(t,t.facePredecessor,e)>=0:ms.signedCWTriangleArea(t,e,t.facePredecessor)<0||ms.signedCWTriangleArea(t,t.faceSuccessor,e)<0}static splitFace(t,e,i){if(Oi.isNodeVisibleInSector(e,i)&&Oi.isNodeVisibleInSector(i,e)){const s=t.createEdgeXYZXYZ(e.x,e.y,e.z,e.i,i.x,i.y,i.z,i.i),n=s.faceSuccessor;return Oi.pinch(e,s),Oi.pinch(i,n),s}}static triangulateSingleMonotoneFace(t,e){let i,s=e.facePredecessor,n=e.faceSuccessor;for(;s!==n&&n!==e&&n.faceSuccessor!==s;){if(Oi.crossProductXYAlongChain(s,e,n)<=0)return!1;if(!e.belowYX(s))return!1;if(!e.belowYX(n))return!1;if(s.belowYX(n)){let r=s,o=e,a=n;for(;r!==a&&r.belowYX(n);){for(;a!==n&&a!==r&&a!==o&&Oi.crossProductXYAlongChain(r,o,a)>0;){if(i=ms.splitFace(t,r,a),void 0===i)return!1;r=i,o=r.faceSuccessor,a=o.faceSuccessor}a=o,o=r,r=r.facePredecessor}for(s=o,a=n,o=a.facePredecessor,r=o.facePredecessor;a.faceSuccessor!==r&&r!==s;){if(i=ms.splitFace(t,r,a),void 0===i)return!1;o=i,r=o.facePredecessor}if(a.faceSuccessor!==r){if(i=ms.splitFace(t,r,a),void 0===i)return!1;r=i}n=(e=r).faceSuccessor,s=e.facePredecessor}else{let r=s,o=e,a=n;for(;r!==a&&a.belowYX(s);){for(;r!==s&&a!==r&&a!==o&&Oi.crossProductXYAlongChain(r,o,a)>0;){if(i=ms.splitFace(t,r,a),void 0===i)return!1;r=i.facePredecessor,o=i}r=o,o=a,a=a.faceSuccessor}for(n=o,r=s,o=r.faceSuccessor,a=o.faceSuccessor;a.faceSuccessor!==r&&a!==n;){if(i=ms.splitFace(t,r,a),void 0===i)return!1;r=i,a=a.faceSuccessor}if(a.faceSuccessor!==r&&void 0===ms.splitFace(t,r,a))return!1;n=(e=n).faceSuccessor,s=e.facePredecessor}}return!0}}ms.sEnableDebugGraphCapture=!1,ms._edgeInterval=ft.createNull(),ms._earRange=gt.createNull(),ms._edgeRange=gt.createNull(),ms._planes=[yt.createXYPlane(),yt.createXYPlane(),yt.createXYPlane()];class xs extends ot{constructor(t,e){super(),this._graph=t,this._id=e}startChain(t,e){super.startChain(t,e),this._baseNode=void 0,this._nodeB=void 0}handleXYZXYZ(t,e,i,s,n,r){this._nodeC=this._graph.createEdgeXYZXYZ(t,e,i,this._id,s,n,r,this._id),void 0===this._baseNode?(this._baseNode=this._nodeC,this._nodeB=this._baseNode.faceSuccessor):(Oi.pinch(this._nodeB,this._nodeC),this._nodeB=this._nodeC.faceSuccessor)}endChain(t,e){super.endChain(t,e),void 0!==this._baseNode&&(void 0===this._seeds&&(this._seeds=[]),this._seeds.push(this._baseNode)),this._baseNode=void 0,this._nodeB=void 0,this._nodeC=void 0}claimSeeds(){return void 0===this._seeds?[]:this._seeds}}class ys{constructor(){this.numUpEdge=0,this.numIntersectionTest=0,this.numSplit=0,this.numPopOut=0,this.numA0B0=0,this.numA0B1=0}}class _s{constructor(t,e,i,s){this.index=t,this.radiusOfCurvature=e,this.node=i,this.radians=s}}class vs{static compareNodesYXUp(t,e){return t.y<e.y?-1:t.y>e.y?1:t.x<e.x?-1:t.x>e.x?1:0}static isDownPeak(t){const e=t.facePredecessor,i=t.faceSuccessor;return this.compareNodesYXUp(t,e)<0&&this.compareNodesYXUp(t,i)<0&&this.crossProductToTargets(t,e,i)>0}static crossProductToTargets(t,e,i){return K.crossProductXYXY(e.x-t.x,e.y-t.y,i.x-t.x,i.y-t.y)}static graphRange(t){const e=ut.create();for(const i of t.allHalfEdges)e.extendXYZ(i.x,i.y,i.z);return e}static segmentArrayToGraphEdges(t,e,i){const s=[];let n=0;for(const r of t){const t=e.createEdgeXYZXYZ(r.point0Ref.x,r.point0Ref.y,r.point0Ref.z,n,r.point1Ref.x,r.point1Ref.y,r.point1Ref.z,n+1),o=t.edgeMate;n+=2,t.setMaskAroundFace(i),s.push(t),s.push(o)}return s}static isolateAllEdges(t){for(const e of t.allHalfEdges){const t=e.vertexPredecessor;Oi.pinch(e,t)}}static isSectorConvexAfterEdgeRemoval(t,e,i){let s=t;do{if(s.isMaskSet(i)||s.edgeMate.isMaskSet(i))break;s=s.vertexSuccessor}while(s!==t&&s.isMaskSet(e));if(s===t)return!1;let n=t;do{if(n.isMaskSet(i)||n.edgeMate.isMaskSet(i))break;n=n.vertexPredecessor}while(n!==t&&n.isMaskSet(e));return n!==t&&Oi.isSectorConvex(s.edgeMate,t,n.faceSuccessor)}static markRemovableEdgesToExpandConvexFaces(t,e,i=M.BOUNDARY_EDGE){if(M.NULL_MASK===e)return 0;const s=t.grabMask(!0);let n=0;for(const r of t.allHalfEdges)r.isMaskSet(s)||r.isMaskSet(i)||r.edgeMate.isMaskSet(i)||this.isSectorConvexAfterEdgeRemoval(r,e,i)&&this.isSectorConvexAfterEdgeRemoval(r.edgeMate,e,i)&&(r.setMaskAroundEdge(e),++n),r.setMaskAroundEdge(s);return n}static collectRemovableEdgesToExpandConvexFaces(t,e=M.BOUNDARY_EDGE){const i=[],s=t.grabMask(!0);if(0<this.markRemovableEdgesToExpandConvexFaces(t,s,e)){const e=t.grabMask(!0);for(const n of t.allHalfEdges)n.isMaskSet(s)&&!n.isMaskSet(e)&&(n.setMaskAroundEdge(e),i.push(n));t.dropMask(e)}return t.dropMask(s),i}static expandConvexFaces(t,e=M.BOUNDARY_EDGE){const i=t.grabMask(!0),s=this.markRemovableEdgesToExpandConvexFaces(t,i,e);return s>0&&t.yankAndDeleteEdges((t=>t.getMask(i))),t.dropMask(i),s}static isEveryFaceConvex(t,e=M.EXTERIOR){const i=t.collectFaceLoops();for(const t of i)if(!t.isMaskedAroundFace(e)&&!t.isFaceConvex())return!1;return!0}}class Ps{static getCommonThetaEndIndex(t,e,i,s){let n=i+1;const r=t.getExtraData(e[i],0);for(;n<s;){const i=t.getExtraData(e[n],0);if(!W.isAlmostEqualRadiansAllowPeriodShift(r,i))return n;n++}return n}static set announceVertexNeighborhoodFunction(t){this._announceVertexNeighborhoodFunction=t}static doAnnounceVertexNeighborhood(t,e,i,s,n){if(this._announceVertexNeighborhoodFunction){const r=[];for(let o=s;o<n;o++){const s=t.getExtraData(e[o],1),n=t.getExtraData(e[o],0),a=i[s],c=this.curvatureSortKey(a);r.push(new _s(e[o],c,a,n))}this._announceVertexNeighborhoodFunction(r)}}static secondarySortAroundVertex(t,e,i,s,n){const r=[];for(let o=s;o<n;){const s=this.getCommonThetaEndIndex(t,e,o,n);if(o+1<s){r.length=0;for(let n=o;n<s;n++){const s=i[t.getExtraData(e[n],1)],o=this.curvatureSortKey(s);r.push(new _s(e[n],o,s))}r.sort(((t,e)=>t.radiusOfCurvature-e.radiusOfCurvature));for(let t=0;t<r.length;t++)e[o+t]=r[t].index}o=s}}static curvatureSortKey(t){const e=t.edgeTag;if(void 0!==e){const i=e.fraction,s=e.curve;if(s){let e=s.fractionToSignedXYRadiusOfCurvature(i);return void 0!==t.sortData&&t.sortData<0&&(e=-e),e}}return 0}static clusterAndMergeXYTheta(t,e){const i=t.allHalfEdges,s=i.length;t.clearMask(M.NULL_FACE);const n=new oi(2,2,s);for(let t=0;t<s;t++){const e=i[t],s=e.x,r=e.y;Oi.pinch(e,e.vertexSuccessor),n.addDirect(s,r,0,t)}const r=K.smallMetricDistance,o=n.clusterIndicesLexical(r);let a=0;const c=o.length;for(let t=0;t<c;t++)if(o[t]===oi.clusterTerminator){if(t>a){const e=i[n.getExtraData(o[a],1)];for(let s=a+1;s<t;s++){const t=i[n.getExtraData(o[s],1)];t.x=e.x,t.y=e.y}}a=t+1}for(const t of o)if(t!==oi.clusterTerminator){const s=i[t],r=s.faceSuccessor;let o=e;if(o){const t=s.edgeTag;(void 0===t||void 0===t.curve||t.curve instanceof Pe)&&(o=void 0)}let a=o?o(s):Math.atan2(r.y-s.y,r.x-s.x);W.isAlmostEqualRadiansAllowPeriodShift(a,-Math.PI)&&(a=Math.PI),n.setExtraData(t,0,a)}n.sortSubsetsBySingleKey(o,2);const h=[];let l,d;a=0;for(let t=0;t<c;t++)if(o[t]===oi.clusterTerminator){if(t>a){t>a+1&&this.secondarySortAroundVertex(n,o,i,a,t),this.doAnnounceVertexNeighborhood(n,o,i,a,t);const e=n.getExtraData(o[a],1);l=n.getExtraData(o[a],0);let s=i[e];for(let e=a+1;e<t;e++){const t=n.getExtraData(o[e],1);d=n.getExtraData(o[e],0);const a=i[t];if(s.isMaskSet(M.NULL_FACE)){const t=h.findIndex((t=>s===t));t>=0&&(h[t]=h[h.length-1],h.pop()),s=a,l=d}else if(a.isMaskSet(M.NULL_FACE)){const t=h.findIndex((t=>a===t));t>=0&&(h[t]=h[h.length-1],h.pop())}else{if(Oi.pinch(s,a),W.isAlmostEqualRadiansAllowPeriodShift(l,d)){const t=s.faceSuccessor,e=a.edgeMate;if(t.isEqualXY(e)){const i=this.curvatureSortKey(s),n=this.curvatureSortKey(a);K.isSameCoordinate(i,n,r)&&(Oi.pinch(t,e),s.setMask(M.NULL_FACE),e.setMask(M.NULL_FACE),h.push(e))}}s=a,l=d}}}a=t+1}}static buildVerticalSweepPriorityQueue(t){const e=new Li;for(const i of t.allHalfEdges)vs.compareNodesYXUp(i,i.faceSuccessor)<0&&e.priorityQueue.push(i);return e}static snapFractionToNode(t,e,i,s){return K.isSameCoordinate(t.x,i.x)&&K.isSameCoordinate(t.y,i.y)?s:e}static computeIntersectionFractionsOnEdges(t,e,i,s,n){const r=t.faceSuccessor,o=t.x,a=t.y,c=r.x-o,h=r.y-a,l=e.faceSuccessor,d=e.x,u=e.y,f=l.x-d,g=l.y-u;return!!Ft.lineSegmentXYUVTransverseIntersectionUnbounded(o,a,c,h,d,u,f,g,i)&&(s.x=o+i.x*c,s.y=a+i.x*h,n.x=d+i.y*f,n.y=u+i.y*g,i.x=this.snapFractionToNode(s,i.x,t,0),i.x=this.snapFractionToNode(s,i.x,r,1),i.y=this.snapFractionToNode(n,i.y,e,0),i.y=this.snapFractionToNode(n,i.y,l,1),K.isIn01(i.x)&&K.isIn01(i.y))}static splitIntersectingEdges(t){const e=new ys,i=this.buildVerticalSweepPriorityQueue(t);let s,n;const r=.99999999;let o;const a=J.create(),c=H.create(),h=H.create();let l;const d=K.smallMetricDistance;for(;void 0!==(s=i.priorityQueue.pop());){e.numUpEdge++;const u=i.activeEdges.length;for(i.removeArrayMembersWithY1Below(s.y-d),e.numPopOut+=u-i.activeEdges.length,o=0;o<i.activeEdges.length;o++)if(l=i.activeEdges[o],n=l.faceSuccessor,K.isSameCoordinateXY(s.x,s.y,l.x,l.y))e.numA0B0++;else if(K.isSameCoordinateXY(n.x,n.y,s.x,s.y))e.numA0B1++;else if(e.numIntersectionTest++,this.computeIntersectionFractionsOnEdges(s,l,a,c,h)){if(a.x>1e-8&&a.x<r){const n=t.splitEdgeAtFraction(s,a.x);i.priorityQueue.push(n),e.numSplit++}if(a.y>1e-8&&a.y<r){const s=t.splitEdgeAtFraction(l,a.y);i.priorityQueue.push(s),e.numSplit++}}i.activeEdges.push(s)}return e}static formGraphFromSegments(t){const e=new Bi;return vs.segmentArrayToGraphEdges(t,e,M.BOUNDARY_EDGE),this.splitIntersectingEdges(e),this.clusterAndMergeXYTheta(e),e}static formGraphFromChains(t,e=!0,i=M.PRIMARY_EDGE){if(t.length<1)return;const s=new Bi,n=ms.directCreateChainsFromCoordinates(s,t);for(const t of n)t.setMaskAroundFace(i);return this.splitIntersectingEdges(s),this.clusterAndMergeXYTheta(s),e&&new Ui(s).regularizeGraph(!0,!0),s}}class Is{static createPrimarySortVector(t){return void 0===t&&(t=this._defaultPrimarySortDirection.clone()),t.normalizeWithDefault(Is._defaultPrimarySortDirection.x,Is._defaultPrimarySortDirection.y,Is._defaultPrimarySortDirection.z)}constructor(t,e){this.tolerance=t,this.primarySortDirection=e}static createFromUnValidated(t){const e=new Is(K.smallMetricDistance,Is.createPrimarySortVector());return void 0!==t&&(void 0!==t.tolerance&&(e.tolerance=t.tolerance),void 0!==t.primarySortDirection&&(e.primarySortDirection=Is.createPrimarySortVector())),e}clone(){return new Is(this.tolerance,this.primarySortDirection)}}Is._defaultPrimarySortDirection=$.create(.294234298,.72391399,.45234328798);class As{constructor(t){this._graph=new Bi,this._options=t}set plane(t){this._plane=t}get plane(){return this._plane}set convexClipper(t){this._convexClipper=t}get convexClipper(){return this._convexClipper}static create(t){const e=Is.createFromUnValidated(t);return new As(e)}addSegment(t,e){this._graph.createEdgeXYZXYZ(t.x,t.y,t.z,0,e.x,e.y,e.z,0)}addLineSegment3dArray(t){for(const e of t)this.addSegment(e.point0Ref,e.point1Ref)}addSegmentsOnPlane(t,e=!1){if(!this._plane)return;const i=this._plane;let s,n=e?t.length-1:0,r=t.evaluateUncheckedIndexPlaneAltitude(n,i),o=e?0:1;for(;o<t.length;n=o++,r=s)s=t.evaluateUncheckedIndexPlaneAltitude(o,i),K.isSmallMetricDistance(r)&&K.isSmallMetricDistance(s)&&this._graph.createEdgeXYZXYZ(t.getXAtUncheckedPointIndex(n),t.getYAtUncheckedPointIndex(n),t.getZAtUncheckedPointIndex(n),0,t.getXAtUncheckedPointIndex(o),t.getYAtUncheckedPointIndex(o),t.getZAtUncheckedPointIndex(o),0)}primarySortKey(t){return this._options.primarySortDirection.dotProductXYZ(t.x,t.y,t.z)}static nodeCompareSortData(t,e){return t.sortData-e.sortData}static isIsolatedEnd(t){return t.vertexSuccessor===t}static isChainInteriorVertex(t){const e=t.vertexSuccessor;return e!==t&&e.vertexSuccessor===t}clusterAndMergeVerticesXYZ(){vs.isolateAllEdges(this._graph);for(const t of this._graph.allHalfEdges)t.sortData=this.primarySortKey(t);const t=this._graph.allHalfEdges.slice();t.sort(((t,e)=>As.nodeCompareSortData(t,e)));const e=this._options.tolerance,i=t.length;for(let s=0;s<i;s++){const n=t[s],r=n.sortData+e;if(As.isIsolatedEnd(n))for(let o=s+1;o<i;o++){const i=t[o];if(As.isIsolatedEnd(i)){if(i.sortData>r)break;n.distanceXYZ(i)<=e&&(Oi.pinch(n,i),i.setXYZFrom(n))}}}}collectMaximalLineString3dFromStartNode(t,e,i){if(!e.isMaskSet(i)){const s=we.create();for(s.addPointXYZ(e.x,e.y,e.z);e.setMask(i),e.edgeMate.setMask(i),e=e.faceSuccessor,s.addPointXYZ(e.x,e.y,e.z),!e.isMaskSet(i)&&As.isChainInteriorVertex(e););t.push(s)}}collectMaximalGrowableXYXArrayFromStartNode(t,e,i){if(!e.isMaskSet(i)){const s=new nt;for(s.pushXYZ(e.x,e.y,e.z);e.setMask(i),e.edgeMate.setMask(i),e=e.faceSuccessor,s.pushXYZ(e.x,e.y,e.z),!e.isMaskSet(i)&&As.isChainInteriorVertex(e););s.length>0&&t.push(s)}}exciseAndMarkSlingEdges(t){let e=0;for(const i of this._graph.allHalfEdges)if(i.distanceXYZ(i.edgeMate)<this._options.tolerance&&!i.isMaskSet(t)){const s=i.edgeMate;Oi.pinch(i,i.vertexPredecessor),Oi.pinch(s,s.vertexPredecessor),i.setMask(t),s.setMask(t),e++}return e}collectMaximalChains(){const t=[],e=M.VISITED;this.exciseAndMarkSlingEdges(e),this._graph.clearMask(e);for(const i of this._graph.allHalfEdges)As.isChainInteriorVertex(i)||this.collectMaximalLineString3dFromStartNode(t,i,e);for(const i of this._graph.allHalfEdges)this.collectMaximalLineString3dFromStartNode(t,i,e);return t}collectMaximalGrowableXYZArrays(){const t=[],e=M.VISITED;this.exciseAndMarkSlingEdges(e),this._graph.clearMask(e);for(const i of this._graph.allHalfEdges)As.isChainInteriorVertex(i)||this.collectMaximalGrowableXYXArrayFromStartNode(t,i,e);for(const i of this._graph.allHalfEdges)this.collectMaximalGrowableXYXArrayFromStartNode(t,i,e);return t}}class Ss{constructor(){this._unmatchedEdges=new Map,this._graph=new Bi,this._halfEdgesAroundCurrentLoop=[]}get graph(){return this._graph}indexPairToString(t,e){return`${t.toString()},${e.toString()}`}insertLoop(t,e){if(t.length>1){let i=t[t.length-1];this._halfEdgesAroundCurrentLoop.length=0;for(const s of t){const t=this.indexPairToString(i,s),n=this._unmatchedEdges.get(t);if(void 0===n){const t=this.indexPairToString(s,i),n=this._graph.createEdgeIdId(i,s);void 0!==e&&e(n),this._unmatchedEdges.set(t,n.edgeMate),this._halfEdgesAroundCurrentLoop.push(n),n.edgeMate.setMask(M.EXTERIOR)}else this._halfEdgesAroundCurrentLoop.push(n),n.clearMask(M.EXTERIOR);i=s}let s=this._halfEdgesAroundCurrentLoop[this._halfEdgesAroundCurrentLoop.length-1];for(const t of this._halfEdgesAroundCurrentLoop){const e=s.faceSuccessor;Oi.pinch(t,e),s=t}return this._halfEdgesAroundCurrentLoop[0]}}}class ws{constructor(t){this.positiveSum=this.negativeSum=0,this.numPositive=this.numNegative=this.numZero=0,this.largestPositiveValue=this.largestNegativeValue=0,t&&(this.negativeItemArray=[],this.positiveItemArray=[],this.zeroItemArray=[])}announceItem(t,e){e<0?(this.numNegative++,this.negativeSum+=e,this.negativeItemArray&&this.negativeItemArray.push(t),e<this.largestNegativeValue&&(this.largestNegativeValue=e,this.largestNegativeItem=t)):e>0?(this.numPositive++,this.positiveSum+=e,this.positiveItemArray&&this.positiveItemArray.push(t),e>this.largestPositiveValue&&(this.largestPositiveValue=e,this.largestPositiveItem=t)):(this.numZero++,this.zeroItemArray&&this.zeroItemArray.push(t))}}class Cs{constructor(t,e=!0){this._targetMask=t,this._targetValue=e}testEdge(t){return t.isMaskSet(this._targetMask)===this._targetValue}}class Ts{static pushAndMaskAllNodesInFace(t,e,i,s){s.push(t),t.collectAroundFace((t=>{t.setMask(e),i.push(t)}))}static findMinimumAreaFace(t,e){return Ts.collectFaceAreaSummary(t,!1,e).largestNegativeItem}static signedFaceArea(t){return t.signedFaceArea()}static collectFaceAreaSummary(t,e=!1,i=(t=>Ts.signedFaceArea(t))){const s=new ws(e);let n;n=t instanceof Bi?t.collectFaceLoops():t;for(const t of n){const e=i(t);s.announceItem(t,e)}return s}static isTriangulatedCCW(t,e=!0,i=0){let s;s=t instanceof Bi?t.collectFaceLoops():t;let n=0,r=0;for(const t of s){const s=t.countEdgesAroundFace();if(s>=3)if(t.signedFaceArea()>0){if(s>3&&(r++,r>i))return!1}else if(n++,n>1&&!e)return!1}return!0}static parityFloodFromSeed(t,e,i,s){const n=[];if(t.isMaskSet(e))return n;const r=s|e,o=[];for(Ts.pushAndMaskAllNodesInFace(t,r,o,n);o.length>0;){const t=o.pop(),a=t.edgeMate;if(a&&!a.isMaskSet(e)){let c=t.isMaskSet(s);i&&!i.testEdge(t)||(c=!c),Ts.pushAndMaskAllNodesInFace(a,c?r:e,o,n)}}return n}static correctParityInSingleComponent(t,e,i){const s=Ts.findMinimumAreaFace(i);if(s)if(s.isMaskSet(e));else for(const t of i)t.isMaskSet(e)?t.clearMaskAroundFace(e):t.setMaskAroundFace(e)}static correctParityInComponentArrays(t,e,i){if(e!==M.NULL_MASK)for(const s of i)Ts.correctParityInSingleComponent(t,e,s)}static collectConnectedComponentsWithExteriorParityMasks(t,e,i=M.NULL_MASK){const s=[],n=M.VISITED,r=i|n;t.clearMask(r);for(const r of t.allHalfEdges)if(!r.isMaskSet(M.VISITED)){const t=Ts.parityFloodFromSeed(r,n,e,i);s.push(t)}return Ts.correctParityInComponentArrays(t,i,s),s}static pointInOrOnFaceXY(t,e,i){const s=new Dt(e,i);let n=t,r=t.faceSuccessor;for(;!s.tryStartEdge(n.x,n.y,r.x,r.y);n=r){if(r===t)return s.classifyCounts();r=n.faceSuccessor}let o=r.faceSuccessor;for(;;){if(!s.advance(o.x,o.y))return s.classifyCounts();if(o===r)break;o=o.faceSuccessor}return s.classifyCounts()}static collectExtendedBoundaryLoopFromSeed(t,e,i,s){let n=0;for(;!t.getMask(e)&&i(t);){s(t,n++),t.setMask(e);const r=t.faceSuccessor;let o=r;for(;;){if(o.getMask(e))return;if(i(o)){t=o;break}if(o=o.vertexPredecessor,o===r)break}}}static collectExtendedBoundaryLoopsInGraph(t,e){const i=[],s=t.grabMask(!0),n=t=>0===t.getMask(e)&&0!==t.edgeMate.getMask(e),r=(t,e)=>{0===e&&i.push([]),i[i.length-1].push(t)};for(const e of t.allHalfEdges)this.collectExtendedBoundaryLoopFromSeed(e,s,n,r);return t.dropMask(s),i}}class ks{static spaceTriangleAspectRatio(t,e,i){const s=.5*t.crossProductToPoints(e,i).magnitude(),n=t.distanceSquared(e)+e.distanceSquared(i)+i.distanceSquared(t);return K.safeDivideFraction(s,n,0)}static spaceQuadDiagonalAspectRatio(t,e,i,s){const n=this.spaceTriangleAspectRatio(t,e,i),r=this.spaceTriangleAspectRatio(t,i,s);return Math.max(n,r)}static triangulateGreedyEarCut(t,e){const i=gr.areaNormal(t),s=[],n=t.slice();for(ii.removeClosurePoint(n);n.length>2;){let t,e=-1,r=0,o=n.length-2,a=n.length-1;for(t=0;t<n.length;o=a,a=t,t++){const s=this.spaceTriangleAspectRatio(n[o],n[a],n[t]);n[o].crossProductToPoints(n[a],n[t]).dotProduct(i)>0&&s>e&&(e=s,r=o)}if(e<=0)return!1;o=r,a=(o+1)%n.length,t=(a+1)%n.length;const c=[];c.push(n[o],n[a],n[t]),n.splice(a,1),s.push(c)}return e(t,s),!0}static triangulateSimplestSpaceLoopGo(t,e,i){const s=ae.countNonDuplicates(t);if(void 0!==i&&ae.sumEdgeLengths(t,!0,s)>i)return!1;if(s<3)return!1;if(3===s)return 0!==this.spaceTriangleAspectRatio(t[0],t[1],t[2])&&(e(t,[t.slice()]),!0);if(4===s){const i=this.spaceQuadDiagonalAspectRatio(t[0],t[1],t[2],t[3]),s=this.spaceQuadDiagonalAspectRatio(t[1],t[2],t[3],t[0]);return!(0===i&&0===s||(i>s?(e(t,[[t[0],t[1],t[2]],[t[2],t[3],t[0]]]),0):(e(t,[[t[0],t[1],t[3]],[t[3],t[1],t[2]]]),0)))}return this.triangulateGreedyEarCut(t,e)}static triangulateSimplestSpaceLoop(t,e,i){return t instanceof we?this.triangulateSimplestSpaceLoopGo(t.points,e,i):this.triangulateSimplestSpaceLoopGo(t,e,i)}}class Fs{constructor(t=-1,e){this._facetIndex=t,this._detail=e||zi.create()}invalidate(t=!0){this._facetIndex=-1,t&&this._detail.invalidate(),this._normal=void 0,this._param=void 0,this._color=void 0}static create(t,e,i){return void 0===i?new Fs(t,e):(i.invalidate(!1),i._facetIndex=t,void 0!==e&&i._detail.copyContentsFrom(e),i)}get facetIndex(){return this._facetIndex}get edgeCount(){return 3}get point(){return this._detail.world}get a(){return this._detail.a}get closestEdge(){return{startVertexIndex:this._detail.closestEdgeIndex,edgeParam:this._detail.closestEdgeParam}}get _isValid(){return this._facetIndex>=0}get isValid(){return this._isValid&&this._detail.isValid}get isConvex(){return!0}get isInsideOrOn(){return this._isValid&&this._detail.isInsideOrOn}get classify(){return this._detail.classify}clone(){const t=new Fs;return t.copyContentsFrom(this),t}copyContentsFrom(t){this._facetIndex=t._facetIndex,this._detail.copyContentsFrom(t._detail),this._normal=t._normal?.clone(),this._param=t._param?.clone(),this._color=t._color}getNormal(t){if(this._detail.isValid&&void 0===this._normal&&void 0!==t){this._normal=$.create();const e=[this._detail.local.x,this._detail.local.y,this._detail.local.z];t.linearCombination(e,this._normal)}return this._normal}getParam(t){if(this._detail.isValid&&void 0===this._param&&void 0!==t){this._param=H.create();const e=[this._detail.local.x,this._detail.local.y,this._detail.local.z];t.linearCombination(e,this._param)}return this._param}getColor(t){if(this._detail.isValid&&void 0===this._color&&void 0!==t){const e=[this._detail.local.x,this._detail.local.y,this._detail.local.z];this._color=re.linearCombinationOfColors(t,e)}return this._color}getBarycentricCoordinates(){return[this._detail.local.x,this._detail.local.y,this._detail.local.z]}}class Ms{constructor(t=-1,e=0,i){this._facetIndex=t,this._edgeCount=e,this._detail=i||dr.create()}invalidate(t=!0){this._facetIndex=-1,this._edgeCount=0,t&&this._detail.invalidate()}static create(t,e,i,s){return void 0===s?new Ms(t,e,i):(s.invalidate(!1),s._facetIndex=t,s._edgeCount=e,void 0!==i&&s._detail!==i&&s._detail.copyContentsFrom(i),s)}get facetIndex(){return this._facetIndex}get edgeCount(){return this._edgeCount}get point(){return this._detail.point}get a(){return this._detail.a}get closestEdge(){return{startVertexIndex:this._detail.closestEdgeIndex,edgeParam:this._detail.closestEdgeParam}}get _isValid(){return this._facetIndex>=0&&this._edgeCount>=3}get isValid(){return this._isValid&&this._detail.isValid}get isConvex(){return!1}get isInsideOrOn(){return this._isValid&&this._detail.isInsideOrOn}get classify(){return this._detail.code}clone(){const t=new Ms;return t.copyContentsFrom(this),t}copyContentsFrom(t){this._facetIndex=t._facetIndex,this._edgeCount=t._edgeCount,this._detail.copyContentsFrom(t._detail)}getNormal(){}getParam(){}getColor(){}getBarycentricCoordinates(){}}class bs extends Ms{constructor(t=-1,e=0,i){super(t,e,i)}invalidate(t=!0){super.invalidate(t),this._normal=void 0,this._param=void 0,this._color=void 0,this._barycentricCoordinates=void 0}static create(t,e,i,s){return void 0===s?new bs(t,e,i):super.create(t,e,i,s)}get isConvex(){return!0}clone(){const t=new bs;return t.copyContentsFrom(this),t}copyContentsFrom(t){super.copyContentsFrom(t),this._normal=t._normal?.clone(),this._param=t._param?.clone(),this._color=t._color,this._barycentricCoordinates=t._barycentricCoordinates?.slice()}getNormal(t,e,i=K.smallMetricDistance){if(this._detail.isValid&&void 0===this._normal&&void 0!==t){const s=this.getBarycentricCoordinates(e,i);void 0!==s&&(this._normal=$.create(),t.linearCombination(s,this._normal))}return this._normal}getParam(t,e,i=K.smallMetricDistance){if(this._detail.isValid&&void 0===this._param&&void 0!==t){const s=this.getBarycentricCoordinates(e,i);void 0!==s&&(this._param=H.create(),t.linearCombination(s,this._param))}return this._param}getColor(t,e,i=K.smallMetricDistance){if(this._detail.isValid&&void 0===this._color&&void 0!==t){const s=this.getBarycentricCoordinates(e,i);void 0!==s&&(this._color=re.linearCombinationOfColors(t,s))}return this._color}getBarycentricCoordinates(t,e=K.smallMetricDistance){return this._detail.isValid&&void 0===this._barycentricCoordinates&&void 0!==t&&(this._barycentricCoordinates=gr.convexBarycentricCoordinates(t,this._detail.point,e)),this._barycentricCoordinates}}class Es extends Float64Array{get vertexIndexA(){return this[0]}get vertexIndexB(){return this[1]}get facetIndex(){return this[2]}get isLowHigh(){return this[0]<this[1]}get lowVertexIndex(){return this[0]<this[1]?this[0]:this[1]}get highVertexIndex(){return this[0]>this[1]?this[0]:this[1]}static areDirectedPartners(t,e){return t[0]===e[1]&&t[1]===e[0]}static areUndirectedPartners(t,e){return t[0]===e[0]&&t[1]===e[1]||t[0]===e[1]&&t[1]===e[0]}static relativeOrientation(t,e){return t[0]===e[0]&&t[1]===e[1]?1:t[0]===e[1]&&t[1]===e[0]?-1:0}get isNullEdge(){return this[0]===this[1]}static lessThan(t,e){const i=t.lowVertexIndex,s=e.lowVertexIndex;if(i<s)return-1;if(s<i)return 1;const n=t.highVertexIndex,r=e.highVertexIndex;return n<r?-1:r<n?1:t.vertexIndexA-e.vertexIndexA}constructor(t,e,i){super(3),this[0]=t,this[1]=e,this[2]=i}toJSON(){return[this[0],this[1],this[2]]}static clusterToJSON(t){if(t instanceof Es)return t.toJSON();const e=[];for(const i of t)e.push(i.toJSON())}static clusterArrayToJSON(t){const e=[];for(const i of t)e.push(Es.clusterToJSON(i));return e}}class Xs{constructor(){this.edges=[]}addEdge(t,e,i){const s=new Es(t,e,i);return this.edges.push(s),s}addPath(t,e,i=!0){if(0===t.length)return;const s=t.length-1;for(let i=0;i<s;i++)this.addEdge(t[i],t[i+1],e);i&&this.addEdge(t[s],t[0],e)}sort(){this.edges.sort(((t,e)=>Es.lessThan(t,e)))}collectSortableEdgeCluster(t,e,i){if(void 0!==i&&e>t)if(e===t+1)i.push(this.edges[t]);else{const s=[];for(let i=t;i<e;i++)s.push(this.edges[i]);i.push(s)}}sortAndCollectClusters(t,e,i,s){this.sort(),t&&(t.length=0),e&&(e.length=0),i&&(i.length=0),s&&(s.length=0);const n=this.edges.length;let r;for(let o=0;o<n;o+=r){const a=this.edges[o];r=1;for(let t=o+1;t<n&&Es.areUndirectedPartners(a,this.edges[t]);t++)r++;this.edges[o].isNullEdge?this.collectSortableEdgeCluster(o,o+r,i):2===r&&Es.areDirectedPartners(a,this.edges[o+1])?this.collectSortableEdgeCluster(o,o+r,t):1===r?this.collectSortableEdgeCluster(o,o+1,e):this.collectSortableEdgeCluster(o,o+r,s)}}}class Rs{constructor(t){this.numPositive=this.numNegative=0,this.firstEdgeIndex=t}recordOrientation(t){t>0?this.numPositive++:t<0&&this.numNegative++}}class zs{constructor(t){this._workArray=[],this._visitor=t.createVisitor(1),this._edges=tn.createIndexedEdges(this._visitor),this._edgeToPartnerEdge=[],this._edgeToEdgeInComponent=[],this._facetToFirstEdgeInComponent=[],this._facetOrientation=[],this._components=[],this._mesh=t}edgeIdToFacetOrientation(t){const e=this._edges.edges[t].facetIndex;return this._facetOrientation[e]}setupUnoriented(){this._edges.sort();const t=this._edges.edges;let e=-1;const i=this._edges.edges.length;for(let t=0;t<i;t++){const i=this._edges.edges[t].facetIndex;i>e&&(e=i),this._edgeToEdgeInComponent.push(t),this._edgeToPartnerEdge.push(t)}for(let t=0;t<=e;t++)this._facetToFirstEdgeInComponent.push(-1),this._facetOrientation.push(0);for(let t=0;t<i;t++){const e=this._edges.edges[t].facetIndex,i=this._facetToFirstEdgeInComponent[e];-1===i?this._facetToFirstEdgeInComponent[e]=t:zs.swapEntries(this._edgeToEdgeInComponent,t,i)}for(let e=0;e<i;e++){let s=e+1;for(;s<i&&Es.areUndirectedPartners(t[e],t[s]);)zs.swapEntries(this._edgeToPartnerEdge,e,s),s++;if(s>e+2)return!1}return!0}recordFacetInComponent(t,e){const i=this._components[this._components.length-1];this._facetOrientation[t]=e,i.recordOrientation(e)}initializeComponent(t){const e=this._edges.edges[t].facetIndex;this._components.push(new Rs(t)),this.recordFacetInComponent(e,1)}pushFacetEdgesOnStack(t,e){zs.extractCyclicIndices(this._edgeToEdgeInComponent,t,this._workArray);for(const t of this._workArray)e.push(t)}doFlood(){const t=[],e=this._edges.edges,i=e.length,s=[];for(let n=0;n<i;n++)if(0===this.edgeIdToFacetOrientation(n)){let i;for(t.length=0,this.initializeComponent(n),this.pushFacetEdgesOnStack(n,t);void 0!==(i=t.pop());){const n=e[i].facetIndex,r=this._facetOrientation[n];zs.extractCyclicIndices(this._edgeToPartnerEdge,i,s);for(const n of s)if(n!==i){const s=e[n].facetIndex,o=this._facetOrientation[s];if(0===o){const o=Es.areDirectedPartners(e[i],e[n])?r:-r;this.recordFacetInComponent(s,o),this.pushFacetEdgesOnStack(n,t),zs.swapEntries(this._edgeToEdgeInComponent,i,n)}else if(Es.relativeOrientation(e[i],e[n])*r*o>0)return!1}}}return!0}doFacetReversals(){let t=0;for(this._visitor.reset();this._visitor.moveToNextFacet();){const e=this._visitor.currentReadIndex();this._facetOrientation[e]<0&&(t++,this._mesh.reverseSingleFacet(e))}return t}static doFixup(t){const e=new zs(t);if(!e.setupUnoriented())return!1;const i=e.doFlood();return i&&e.doFacetReversals(),i}static swapEntries(t,e,i){const s=t[e];t[e]=t[i],t[i]=s}static extractCyclicIndices(t,e,i){i.length=0;let s=e;do{i.push(s),s=t[s]}while(s!==e)}}class Ds{constructor(t,e,i){this.index=t,this.area=e,this.normal=i}addWeightedNormal(t,e){this.area+=t,this.normal.addScaledInPlace(e,t)}divideNormalByArea(){this.normal.scaleInPlace(1/this.area)}}class Ys{constructor(t,e,i){this.facetData=t,this.sectorClusterData=void 0,this.sectorIndex=e,this.vertexIndex=i}static cbSectorSort(t,e){return t.sectorIndex-e.sectorIndex}static cbVertexSort(t,e){return t.vertexIndex-e.vertexIndex}static pushToArray(t,e,i,s){t.push(new Ys(e,i,s))}}class Ns{static buildFastAverageNormals(t,e){const i=t.createVisitor(0),s=$.create(0,0,1),n=K.smallMetricDistanceSquared,r=[];let o=0,a=0;for(;i.moveToNextFacet();){const t=gr.areaNormalGo(i.point);let e=t.magnitude();e<n?(t.setFromVector3d(s),e=0):t.scaleInPlace(1/e);const c=new Ds(o++,e,t);for(let t=0;t<i.pointCount;t++)Ys.pushToArray(r,c,a++,i.clientPointIndex(t))}r.sort(((t,e)=>Ys.cbVertexSort(t,e)));const c=[];let h=e.radians;h<1e-4&&(h=1e-4);let l=0;for(let t=0;t<r.length;t++){const e=r[t],i=e.vertexIndex,s=e.facetData;if(void 0===e.sectorClusterData){const n=new Ds(l++,0,$.createZero());c.push(n),n.addWeightedNormal(1,e.facetData.normal.clone());for(let e=t;e<r.length;e++){const t=r[e];if(t.vertexIndex!==i)break;t.facetData.normal.angleTo(s.normal).radians>h||void 0===t.sectorClusterData&&(n.addWeightedNormal(1,t.facetData.normal),t.sectorClusterData=n)}}}r.sort(((t,e)=>Ys.cbSectorSort(t,e))),t.data.normalIndex=[],t.data.normal=new nt(r.length);for(const e of c)e.divideNormalByArea(),e.index=t.data.normal.length,t.data.normal.push(e.normal);for(const e of r)t.data.normalIndex.push(e.sectorClusterData.index)}static buildPerFaceNormals(t){const e=t.createVisitor(0),i=$.create(0,0,1),s=$.create(0,0,1),n=new nt(t.faceCount),r=[];for(;e.moveToNextFacet();){const t=n.length;gr.unitNormal(e.point,i)?n.push(i):n.push(s);for(let i=0;i<e.pointCount;i++)r.push(t)}t.data.normalIndex=r,t.data.normal=n}}function Os(t){return void 0!==t&&t}class Bs{constructor(){this.numActiveSectors=0,this.numInactiveSectors=0,this.averageNormal=$.create(),this.radiansSum=0,this.maxDeviationRadiansFromAverage=0}clear(){this.numActiveSectors=0,this.numInactiveSectors=0,this.averageNormal.setZero(),this.radiansSum=0,this.maxDeviationRadiansFromAverage=0}accumulateNormal(t,e,i){if(t.isMaskSet(i))this.numInactiveSectors++;else{const i=Oi.sectorSweepRadiansXYZ(t,e);this.averageNormal.addScaledInPlace(e,i),this.radiansSum+=i,this.numActiveSectors++}}finishNormalAveraging(){return!!(this.numActiveSectors>0&&this.averageNormal.normalizeInPlace())}recordDeviation(t,e){if(e){const e=this.averageNormal.radiansTo(t);this.maxDeviationRadiansFromAverage=Math.max(Math.abs(this.maxDeviationRadiansFromAverage),e)}}get maxDeviationRadians(){return this.maxDeviationRadiansFromAverage}}function Vs(t){void 0!==Zs.stringDebugFunction&&(Zs.stringDebugFunction(`    Sector xyz    ${t.xyz.x},${t.xyz.y},${t.xyz.z} `),Zs.stringDebugFunction(`           normal ${t.normal.x},${t.normal.y},${t.normal.z} `))}class Ls{constructor(t,e){this.facetIndex=t,this.facetNormal=e}}class Us{constructor(t,e){this.xyz=e,this.normal=t,this.count=0}static edgeHasLargeExteriorAngleBetweenNormals(t,e,i,s,n=.5*Math.PI){const r=t.edgeTag,o=t.edgeMate.edgeTag;if(void 0!==r&&void 0!==o){t.vectorToFaceSuccessor(e);const a=r.normal.signedRadiansTo(o.normal,e);if(K.split3WaySign(s,-1,1,1)*a>=n&&($.createAdd2Scaled(r.normal,1,o.normal,1,i),i.normalizeInPlace()))return!0}return!1}static almostEqualNormals(t,e,i=K.smallAngleRadians){return t.normal.radiansTo(e.normal)<=i}static radiansBetweenNormals(t,e){return t.normal.radiansTo(e.normal)}setOffsetPointAtDistanceAtHalfEdge(t,e){t.getPoint3d(this.xyz),this.xyz.addScaledInPlace(this.normal,e)}static setXYZAtHalfEdge(t,e){const i=t.edgeTag;void 0!==i&&void 0!==e&&i.xyz.set(e.x,e.y,e.z)}setXYAndZ(t){this.xyz.set(t.x,t.y,t.z)}static setNormalAtHalfEdge(t,e,i){const s=t.edgeTag;void 0!==s&&(s.normal.set(e.x,e.y,e.z),void 0!==i&&s.setOffsetPointAtDistanceAtHalfEdge(t,i))}static sweepRadiansAroundNormal(t,e){const i=t.edgeTag,s=t.vertexSuccessor.edgeTag;if(void 0!==i&&void 0!==s)return i.normal.planarRadiansTo(s.normal,e)}static getSectorPointAtHalfEdge(t,e,i){const s=t.edgeTag;return void 0!==s&&(void 0!==e&&e.setFromPoint3d(s.xyz),void 0!==i&&i.push(s.xyz),!0)}static pushXYZ(t,e){const i=e.edgeTag;return void 0!==i&&t.push(i.xyz),i}static accumulateScaledNormalAtHalfEdge(t,e,i){const s=t.edgeTag;void 0!==s&&i.addScaledInPlace(s.normal,e)}}class Zs{constructor(t,e,i){this._basePolyface=t,this._baseGraph=e,this._breakMaskA=e.grabMask(),this._breakMaskB=e.grabMask(),this._insideOfChamferFace=e.grabMask(),this._outsideOfChamferFace=e.grabMask(),this._insideChamferSling=e.grabMask(),this._outsideEndOfChamferFace=e.grabMask(),this._exteriorMask=M.EXTERIOR,this._offsetCoordinatesReassigned=e.grabMask(),this._smoothRadiansBetweenNormals=i.smoothSingleAngleBetweenNormals.radians,this._chamferTurnRadians=i.chamferAngleBetweenNormals.radians,this._smoothAccumulatedRadiansBetweenNormals=i.smoothAccumulatedAngleBetweenNormals.radians}get exteriorMask(){return this._exteriorMask}get breakMaskA(){return this._breakMaskA}get breakMaskB(){return this._breakMaskB}get insideOfChamferFace(){return this._insideOfChamferFace}get outsideOfChamferFace(){return this._outsideOfChamferFace}get insideChamferSling(){return this._insideChamferSling}get outsideEndOfChamferFace(){return this._outsideEndOfChamferFace}applyFaceNormalOffsetsToSectorData(t){this._baseGraph.announceNodes(((e,i)=>{const s=i.edgeTag;return void 0!==s&&s.setOffsetPointAtDistanceAtHalfEdge(i,t),!0}))}static buildOffsetMeshWithEdgeChamfers(t,e,i,s){const n=this.buildBaseGraph(t);if(void 0!==n){const r=new Zs(t,n,s);r.applyFaceNormalOffsetsToSectorData(i),void 0!==Zs.graphDebugFunction&&Zs.graphDebugFunction("BaseGraph",n,r._breakMaskA,r._breakMaskB);const o=s.outputSelector?s.outputSelector:{outputOffsetsFromFaces:!0,outputOffsetsFromEdges:!0,outputOffsetsFromVertices:!0};Os(o.outputOffsetsFromFacesBeforeChamfers)&&r.announceFacetsWithSectorCoordinatesAroundFaces(e),r.addChamferTopologyToAllEdges(s,i),r.computeOffsetFacetIntersections(i),void 0!==Zs.graphDebugFunction&&Zs.graphDebugFunction("after computeEdgeChamfers",n,r._breakMaskA,r._breakMaskB),Os(o.outputOffsetsFromFaces)&&r.announceFacetsWithSectorCoordinatesAroundFaces(e),Os(o.outputOffsetsFromEdges)&&r.announceFacetsWithSectorCoordinatesAroundEdges(e),Os(o.outputOffsetsFromVertices)&&r.announceFacetsWithSectorCoordinatesAroundVertices(e)}}announceSimpleOffsetFromFaces(t,e){const i=new nt,s=Q.create(),n=$.create(),r=t=>(t.getPoint3d(s),s.addInPlace(n),i.push(s),0);this._baseGraph.announceFaceLoops(((s,o)=>{if(!o.isMaskSet(M.EXTERIOR)){const s=o.faceTag;n.setFromVector3d(s.facetNormal.direction),n.scaleInPlace(e),i.length=0,o.sumAroundFace(r),t.addPolygonGrowableXYZArray(i)}return!0}))}announceFacetsWithSectorCoordinatesAroundFaces(t){const e=new nt,i=t=>{const i=t.edgeTag;return void 0!==i&&e.push(i.xyz),0};this._baseGraph.announceFaceLoops(((s,n)=>(n.isMaskSet(M.EXTERIOR)||(e.length=0,n.sumAroundFace(i),e.length>2&&t.addPolygonGrowableXYZArray(e)),!0)))}countBits(t){let e=0,i=t;for(;0!==i;)1&i&&e++,i>>=1;return e}announceFacetsWithSectorCoordinatesAroundEdges(t){const e=new nt,i=K.smallMetricDistance,s=this._exteriorMask|this._outsideEndOfChamferFace|this._outsideOfChamferFace|this._insideOfChamferFace|this._insideChamferSling;this._baseGraph.announceEdges(((n,r)=>{if(void 0!==r.findMaskAroundEdge(this._exteriorMask))return!0;if(r.isMaskSet(s))return!0;{const n=r.faceSuccessor,o=r.edgeMate;if(!o.isMaskSet(s)){const s=o.faceSuccessor;e.clear(),Us.getSectorPointAtHalfEdge(r,void 0,e),Us.getSectorPointAtHalfEdge(n,void 0,e),Us.getSectorPointAtHalfEdge(o,void 0,e),Us.getSectorPointAtHalfEdge(s,void 0,e),$e.compressInPlaceByShortEdgeLength(e,i),e.length>2&&t.addPolygonGrowableXYZArray(e)}}return!0}))}getCoordinateString(t,e=!0,i=!1){return e?i?`${Oi.nodeToIdXYZString(t)} ==> ${Oi.nodeToIdXYZString(t.faceSuccessor)}`:`${Oi.nodeToIdXYZString(t)}`:i?`==> ${Oi.nodeToIdXYZString(t.faceSuccessor)}`:""}inspectMasks(t,e=!0,i=!1){return"[".concat(t.id.toString(),t.isMaskSet(this._exteriorMask)?"X":"",t.isMaskSet(this.breakMaskA)?"A":"",t.isMaskSet(this.breakMaskB)?"B":"",t.isMaskSet(this.insideChamferSling)?"(sling)":"",t.isMaskSet(this.insideOfChamferFace)?"(in chamfer)":"",t.isMaskSet(this.outsideEndOfChamferFace)?"(@sling)":"",t.isMaskSet(this.outsideOfChamferFace)?"(@chamfer)":"",this.getCoordinateString(t,e,i),"]")}announceFacetsWithSectorCoordinatesAroundVertices(t){const e=new nt,i=K.smallMetricDistance;this._baseGraph.announceVertexLoops(((s,n)=>(n.findMaskAroundVertex(this._exteriorMask)||(e.length=0,n.sumAroundVertex((t=>(t.isMaskSet(this._insideChamferSling)||Us.getSectorPointAtHalfEdge(t,void 0,e),0))),$e.compressInPlaceByShortEdgeLength(e,i),e.length>2&&t.addPolygonGrowableXYZArray(e)),!0)))}static buildBaseGraph(t){const e=new Ss,i=t.createVisitor(),s=Q.create(),n=Q.create();for(i.reset();i.moveToNextFacet();){const r=gr.centroidAreaNormal(i.point);if(void 0!==r){const o=e.insertLoop(i.pointIndex,(e=>{const i=e.edgeMate;t.data.getPoint(e.i,s),e.setXYZ(s),t.data.getPoint(i.i,n),i.setXYZ(n)})),a=new Ls(i.currentReadIndex(),r);void 0!==o&&o.sumAroundFace((t=>(t.faceTag=a,t.edgeTag=new Us(r.direction.clone(),t.getPoint3d()),0)))}}return e.graph}setOffsetAtDistanceAroundVertex(t,e,i=!1){t.sumAroundVertex((s=>{const n=s.edgeTag;return void 0!==n&&(i&&this.isInsideChamferOrSling(t)||n.setOffsetPointAtDistanceAtHalfEdge(s,e)),0}))}setOffsetXYAndZAroundVertex(t,e){t.sumAroundVertex((t=>{const i=t.edgeTag;return void 0!==i&&(i.setXYAndZ(e),t.setMask(this._offsetCoordinatesReassigned)),0}))}announceNodeAndSectorPropertiesInSmoothSector(t,e){let i=0;for(let s=t;;s=s.vertexSuccessor){const n=s.edgeTag;if(void 0!==n&&(e(s,n),i++),s.isMaskSet(this._breakMaskB))return i;if(s.isMaskSet(this._exteriorMask))return i;if(s===t&&0===i)return i}}computeAverageNormalAndMaxDeviationAroundVertex(t,e){e.clear();const i=this._exteriorMask|this._insideChamferSling;if(t.sumAroundVertex((t=>{const s=t.edgeTag;return s&&e.accumulateNormal(t,s.normal,i),0})),e.finishNormalAveraging())return t.sumAroundVertex((t=>{const s=t.edgeTag;return s&&e.recordDeviation(s.normal,!t.isMaskSet(i)),0})),e.maxDeviationRadians}assignOffsetByAverageNormalAroundVertex(t,e,i,s){const n=this.computeAverageNormalAndMaxDeviationAroundVertex(t,i);return Zs.stringDebugFunction&&(Zs.stringDebugFunction(`XYZ ${Oi.nodeToIdXYZString(t)} Average Normal ${i.averageNormal.toJSON()}`),Zs.stringDebugFunction(`           angle ratio ${i.radiansSum/(2*Math.PI)}   maxDeviation ${i.maxDeviationRadiansFromAverage}`)),void 0!==n&&n<=e&&(t.sumAroundVertex((t=>(Us.setNormalAtHalfEdge(t,i.averageNormal,s),0))),!0)}markBreakEdgesAndSaveAverageNormalsAroundVertex(t){t.clearMaskAroundVertex(this._breakMaskA),t.clearMaskAroundVertex(this._breakMaskB);const e=this._smoothRadiansBetweenNormals,i=this._smoothAccumulatedRadiansBetweenNormals;let s=0,n=t,r=0;do{const t=n.edgeMate,i=t.faceSuccessor;n.isMaskSet(this._exteriorMask)?t.isMaskSet(this._exteriorMask)||(i.setMask(this._breakMaskB),s++):n.isMaskSet(this._outsideOfChamferFace)?n.setMask(this._breakMaskA):n.isMaskSet(this._outsideEndOfChamferFace)?(n.setMask(this._breakMaskA),n.setMask(this._breakMaskB)):n.isMaskSet(this._insideChamferSling)||(n.isMaskSet(this._insideOfChamferFace)?(n.setMask(this._breakMaskA),n.setMask(this._breakMaskB),i.setMask(this._breakMaskB)):t.isMaskSet(this._exteriorMask)?(s++,n.setMask(this._breakMaskA)):Us.almostEqualNormals(n.edgeTag,i.edgeTag,e)?r++:(n.setMask(this._breakMaskA),s++,i.setMask(this._breakMaskB))),n=n.vertexSuccessor}while(n!==t);void 0!==Zs.stringDebugFunction&&Zs.stringDebugFunction(`   numSkip   ${r} `),0===s&&(t.setMask(this._breakMaskA),t.vertexPredecessor.setMask(this._breakMaskB),s=1);const o=n.findMaskAroundVertex(this._breakMaskA);if(void 0!==o){n=o;do{if(n.isMaskSet(this._breakMaskA)&&!n.isMaskSet(this._breakMaskB)){let t=0;do{const e=n.vertexSuccessor;t+=Us.radiansBetweenNormals(n.edgeTag,e.edgeTag),t>i&&(n.setMask(this._breakMaskB),e.setMask(this._breakMaskA),s++,t=0),n=e}while(!n.isMaskSet(this._breakMaskB))}else n=n.vertexSuccessor}while(n!==o)}if(s>0&&void 0!==o){n=o;const t=$.create(),e=$.create(),i=$.create();t.setZero();do{if(n.isMaskSet(this._breakMaskA)&&!n.isMaskSet(this._breakMaskB)){let s=n;for(t.setZero();;){s.vectorToFaceSuccessor(e),s.vectorToFacePredecessor(i);let n=e.signedRadiansTo(i,s.faceTag.facetNormal.direction);if(n<0&&(n+=2*Math.PI),Us.accumulateScaledNormalAtHalfEdge(s,n,t),s.isMaskSet(this._breakMaskB))break;s=s.vertexSuccessor}if(t.normalizeInPlace())for(s=n;Us.setNormalAtHalfEdge(s,t),!s.isMaskSet(this._breakMaskB);)s=s.vertexSuccessor}n=n.vertexSuccessor}while(n!==o)}}compute3SectorIntersection(t,e,i,s){const n=t.edgeTag,r=e.edgeTag,o=i.edgeTag;return Ft.intersect3Planes(n.xyz,n.normal,r.xyz,r.normal,o.xyz,o.normal,s)}compute3SectorIntersectionDebug(t,e,i,s){const n=t.edgeTag,r=e.edgeTag,o=i.edgeTag;if(void 0!==Zs.stringDebugFunction){Zs.stringDebugFunction(`compute3${this.inspectMasks(t)}${this.inspectMasks(e)}${this.inspectMasks(i)} `);for(const t of[n,r,o])Vs(t)}const a=Ft.intersect3Planes(n.xyz,n.normal,r.xyz,r.normal,o.xyz,o.normal,s);return void 0!==Zs.stringDebugFunction&&(void 0===a?Zs.stringDebugFunction(" NO INTERSECTION"):Zs.stringDebugFunction(` ComputedVector ${a.x},${a.y},${a.z} `)),a}compute2SectorIntersection(t,e,i){const s=t.edgeTag,n=e.edgeTag,r=s.normal.crossProduct(n.normal);return Ft.intersect3Planes(s.xyz,s.normal,n.xyz,n.normal,n.xyz,r,i)}addChamferTopologyToAllEdges(t,e){const i=[],s=t.chamferAngleBetweenNormals.radians,n=Q.create(),r=$.create(),o=$.create(),a=$.create();this._baseGraph.announceEdges(((t,n)=>!Us.edgeHasLargeExteriorAngleBetweenNormals(n,r,a,e,s)||(i.push(n),!0)));for(const t of i)if(Us.edgeHasLargeExteriorAngleBetweenNormals(t,r,a,s)){const i=this._baseGraph.splitEdgeCreateSliverFace(t),s=i.facePredecessor,c=i.getPoint3d();c.addScaledInPlace(a,e);const h=bt.createCapture(c,a.clone()),l=new Ls(-1,h);let d=-1;for(const t of[i,s]){r.scale(d,o),t.getPoint3d(n),t.setMask(this._insideOfChamferFace),t.edgeMate.setMask(this._outsideOfChamferFace),t.faceTag=l;const e=this._baseGraph.splitEdge(void 0,n.x,n.y,n.z,t.i),i=e.edgeMate;e.setMask(this._outsideEndOfChamferFace),e.faceTag=l,i.setMask(this._insideChamferSling),Oi.pinch(t,e);const s=bt.create(n,o),h=new Ls(-1,s);i.faceTag=h,t.edgeTag=new Us(a.clone(),c.clone()),e.edgeTag=new Us(a.clone(),c.clone()),i.edgeTag=new Us(o.clone(),n.clone());const u=this.compute3SectorIntersection(t,t.edgeMate,i),f=this.compute3SectorIntersection(e,e.vertexSuccessor,i);Us.setXYZAtHalfEdge(t,u),Us.setXYZAtHalfEdge(e,f),d*=-1}}}computeOffsetFacetIntersections(t){void 0!==Zs.stringDebugFunction&&Zs.stringDebugFunction("*****                                 recompute intersections");const e=[],i=Q.create(),s=Q.create(),n=2*t,r=new Bs,o=W.degreesToRadians(25);this._baseGraph.announceVertexLoops(((a,c)=>{let h=c.findMaskAroundVertex(this._outsideEndOfChamferFace);if(void 0===h&&(h=c.findMaskAroundVertex(this._breakMaskA)),void 0===h&&(h=c),void 0!==Zs.stringDebugFunction&&(Zs.stringDebugFunction(""),Zs.stringDebugFunction(` VERTEX LOOP   ${h.getPoint3d().toJSON()} `),h.sumAroundVertex((t=>(Zs.stringDebugFunction(this.inspectMasks(t,!1,!0)),0)))),this.assignOffsetByAverageNormalAroundVertex(h,o,r,t))return!0;if(this.markBreakEdgesAndSaveAverageNormalsAroundVertex(h),this.setOffsetAtDistanceAroundVertex(h,t,!0),h.collectMaskedEdgesAroundVertex(this._breakMaskA,!0,e),void 0!==Zs.stringDebugFunction){Zs.stringDebugFunction(` BREAK EDGES from ${this.inspectMasks(h,!0,!1)}`);for(const t of e)Zs.stringDebugFunction(this.inspectMasks(t,!1,!0))}if(e.length<=1);else if(2===e.length){const t=this.compute2SectorIntersection(e[0],e[1]);void 0!==t&&this.setOffsetXYAndZAroundVertex(h,t)}else if(3===e.length){void 0!==Zs.stringDebugFunction&&Zs.stringDebugFunction(` Vertex Update just ${e.length} `);const t=this.compute3SectorIntersection(e[0],e[1],e[2]);void 0!==t&&this.setOffsetXYAndZAroundVertex(h,t)}else{void 0!==Zs.stringDebugFunction&&Zs.stringDebugFunction(` Vertex Update breakEdges ${e.length} `),h.getPoint3d(i);for(let t=0;t<e.length;t++){const i=t,s=(i+1)%e.length,n=(s+1)%e.length;if(e[i].isMaskSet(this._outsideEndOfChamferFace)&&e[s].isMaskSet(this._outsideOfChamferFace)&&e[n].isMaskSet(this._insideOfChamferFace)){void 0!==Zs.stringDebugFunction&&Zs.stringDebugFunction(`    ChamferChamfer Fixup ${this.inspectMasks(e[i])} ${this.inspectMasks(e[s])} ${this.inspectMasks(e[n])} `);const r=this.compute3SectorIntersection(e[i],e[s],e[n]);if(void 0!==r){for(const t of[i,s,n])this.announceNodeAndSectorPropertiesInSmoothSector(e[t],((t,e)=>{e.setXYAndZ(r),t.setMask(this._offsetCoordinatesReassigned)}));t+=2}}}for(let t=0;t<e.length;t++){const i=t,n=(i+1)%e.length;this.isInsideSling(e[i],e[n])||(!this.isOffsetAssigned(e[i])&&e[n].isMaskSet(this.insideOfChamferFace)?this.transferXYZFromNodeToSmoothSector(e[n],e[i],"push left from chamfer",s):!this.isOffsetAssigned(e[n])&&e[i].isMaskSet(this.outsideEndOfChamferFace)&&this.transferXYZFromNodeToSmoothSector(e[i],e[n],"push right from chamfer",s))}for(let t=0;t<e.length;t++){const s=t,r=(s+1)%e.length,o=(r+1)%e.length;if(this.isInsideSling(e[s],e[r],e[o]))continue;if(this.isOffsetAssigned(e[r]))continue;void 0!==Zs.stringDebugFunction&&Zs.stringDebugFunction(`    Intersection Fixup ${this.inspectMasks(e[s])} ${this.inspectMasks(e[r])} ${this.inspectMasks(e[o])} `);const a=this.compute3SectorIntersection(e[s],e[r],e[o]);void 0!==a&&i.distance(a)<n&&this.announceNodeAndSectorPropertiesInSmoothSector(e[r],((t,e)=>{e.setXYAndZ(a),t.setMask(this._offsetCoordinatesReassigned)}))}}if(void 0!==Zs.stringDebugFunction){const t=h.countMaskAroundVertex(this._offsetCoordinatesReassigned,!1),e=`   **** Vertex offset mask counts(TRUE ${h.countMaskAroundVertex(this._offsetCoordinatesReassigned,!0)})(FALSE ${t})`;Zs.stringDebugFunction(e)}return!0}))}isInsideSling(t,e,i){return t.isMaskSet(this._insideChamferSling)||void 0!==e&&e.isMaskSet(this._insideChamferSling)||void 0!==i&&i.isMaskSet(this._insideChamferSling)}isInsideChamferOrSling(t){return t.isMaskSet(this._insideChamferSling)||t.isMaskSet(this._insideOfChamferFace)||t.isMaskSet(this._outsideEndOfChamferFace)}isOffsetAssigned(t,e,i){return t.isMaskSet(this._offsetCoordinatesReassigned)||void 0!==e&&e.isMaskSet(this._offsetCoordinatesReassigned)||void 0!==i&&i.isMaskSet(this._offsetCoordinatesReassigned)}transferXYZFromNodeToSmoothSector(t,e,i,s){void 0!==Zs.stringDebugFunction&&Zs.stringDebugFunction(`    ${i} ${this.inspectMasks(t)} to ${this.inspectMasks(e)}} `),Us.getSectorPointAtHalfEdge(t,s,void 0),this.announceNodeAndSectorPropertiesInSmoothSector(e,((t,e)=>{e.setXYAndZ(s),t.setMask(this._offsetCoordinatesReassigned)}))}}class qs{constructor(t){this._segmentPoint0=Q.create(),this._segmentPoint1=Q.create(),this._localSegmentPoint0=Q.create(),this._localSegmentPoint1=Q.create(),this._clipFractions=ke.create(0,1),this._localFrame=pt.createIdentity(),this._polygonRange=ut.create(),this._spacePoints=t,this._spacePointsRange=new ut,t.setRange(this._spacePointsRange),this._numSpacePoints=this._spacePoints.length}static create(t){if(t.length>1)return new qs(t.clone())}projectToPolygon(t,e,i,s){t.setRange(this._polygonRange);let n=0;if(!this._polygonRange.intersectsRangeXY(this._spacePointsRange))return n;for(let r=1;r+1<t.length;r++){n++;const o=t.fillLocalXYTriangleFrame(0,r,r+1,this._localFrame);if(o)for(let t=1;t<this._numSpacePoints;t++)if(n++,this._spacePoints.getPoint3dAtCheckedPointIndex(t-1,this._segmentPoint0),this._spacePoints.getPoint3dAtCheckedPointIndex(t,this._segmentPoint1),o.multiplyInversePoint3d(this._segmentPoint0,this._localSegmentPoint0),o.multiplyInversePoint3d(this._segmentPoint1,this._localSegmentPoint1),this._clipFractions.set(0,1),this._clipFractions.clipBy01FunctionValuesPositive(this._localSegmentPoint0.x,this._localSegmentPoint1.x)&&this._clipFractions.clipBy01FunctionValuesPositive(this._localSegmentPoint0.y,this._localSegmentPoint1.y)&&this._clipFractions.clipBy01FunctionValuesPositive(1-this._localSegmentPoint0.x-this._localSegmentPoint0.y,1-this._localSegmentPoint1.x-this._localSegmentPoint1.y)){n++;const r=this._localSegmentPoint0.interpolate(this._clipFractions.x0,this._localSegmentPoint1),o=this._localSegmentPoint0.interpolate(this._clipFractions.x1,this._localSegmentPoint1),a=this._localFrame.multiplyPoint3d(r),c=this._localFrame.multiplyPoint3d(o),h=this._localFrame.multiplyXYZ(r.x,r.y,0),l=this._localFrame.multiplyXYZ(o.x,o.y,0),d=K.inverseInterpolate01(this._localSegmentPoint0.z,this._localSegmentPoint1.z);if(void 0!==d&&d>this._clipFractions.x0&&d<this._clipFractions.x1){n++;const r=this._segmentPoint0.interpolate(d,this._segmentPoint1),o=r.clone();e(this._spacePoints,t-1,i,s,[a,r,h],2,1),e(this._spacePoints,t-1,i,s,[c,o,l],1,2)}else this._localSegmentPoint0.z>0?e(this._spacePoints,t-1,i,s,[a,c,l,h],3,2):e(this._spacePoints,t-1,i,s,[c,a,h,l],2,3)}}return n}}class Ws{constructor(t,e){this.edgePlane=t,this.clip=e,this._crossingPoints=[]}static createPointPointSweep(t,e,i){const s=$.createStartEnd(t,e),n=s.fractionOfProjectionToVector(i),r=s.plusScaled(i,-n),o=xr.createNormalAndPoint(r,t),a=xr.createNormalAndPoint(r,e),c=xr.createOriginAndVectors(t,s,i);if(void 0!==o&&void 0!==a&&void 0!==c){a.negateInPlace();const t=en.createPlanes([o,a]);return new Ws(c,t)}}processPolygon(t,e){this._crossingPoints.length=0,Array.isArray(t)?mr.polygonPlaneCrossings(this.edgePlane,t,this._crossingPoints):pr.polygonPlaneCrossings(this.edgePlane,t,this._crossingPoints),2===this._crossingPoints.length&&this.clip.announceClippedSegmentIntervals(0,1,this._crossingPoints[0],this._crossingPoints[1],((t,i)=>{e(this._crossingPoints[0].interpolate(t,this._crossingPoints[1]),this._crossingPoints[0].interpolate(i,this._crossingPoints[1]))}))}}class Gs{constructor(t,e){this._edgeClippers=t,void 0!==e&&(this._localToWorld=e.localToWorld,this._worldToLocal=e.worldToLocal,this._localRange=e.localRange)}static create(t,e){if(void 0===e&&(e=$.create(0,0,1)),t.length>1){const i=Q.createZero(),s=Q.createZero(),n=[];t.getPoint3dAtUncheckedPointIndex(0,i);let r=xt.createRigidHeadsUp(e);void 0===r&&(r=xt.createIdentity());const o=pt.createOriginAndMatrix(i,r),a=o.inverse(),c=t.getRange(a);for(let r=1;r<t.length;r++){t.getPoint3dAtUncheckedPointIndex(r,s);const o=Ws.createPointPointSweep(i,s,e);void 0!==o&&(i.setFrom(s),n.push(o))}return new Gs(n,{localToWorld:o,worldToLocal:a,localRange:c})}}processPolygon(t,e){if(void 0===this._worldToLocal||void 0===this._localRange||ut.createTransformedArray(this._worldToLocal,t).intersectsRangeXY(this._localRange))for(const i of this._edgeClippers)i.processPolygon(t,e)}}class Hs{constructor(t,e,i){this._range=t,this._numXEdge=Math.max(e,1),this._numYEdge=Math.max(i,1),this._data=[];for(let t=0;t<i;t++){const t=[];for(let i=0;i<e;i++)t.push(void 0);this._data.push(t)}}get numXEdge(){return this._numXEdge}get numYEdge(){return this._numYEdge}xIndex(t){const e=(t-this._range.low.x)/(this._range.high.x-this._range.low.x),i=Math.floor(e*this._numXEdge);return i<0?0:i>this._numXEdge-1?this._numXEdge-1:i}yIndex(t){const e=(t-this._range.low.y)/(this._range.high.y-this._range.low.y),i=Math.floor(e*this._numYEdge);return i<0?0:i>this._numYEdge-1?this._numYEdge-1:i}static createWithEstimatedCounts(t,e,i){if(t.low.x>=t.high.x||t.low.y>=t.high.y)return;const s=gt.createXYXY(t.low.x,t.low.y,t.high.x,t.high.y),n=s.xLength(),r=s.yLength();let o,a;return r>n?(a=Math.ceil(Math.sqrt(r*e/(i*n))),o=Math.ceil(e/a)):(o=Math.ceil(Math.sqrt(n*e/(i*r))),a=Math.ceil(e/(o*i))),new Hs(s,o,a)}addDataAtXY(t,e,i){const s=this.xIndex(t),n=this.yIndex(e);let r=this._data[n][s];r||(r=[],this._data[n][s]=r),r.push(i)}getDataAtXY(t,e){const i=this.xIndex(t),s=this.yIndex(e);return this._data[s][i]}getDataAtIndex(t,e){if(!(t<0||t>=this._numXEdge||e<0||e>=this._numYEdge))return this._data[e][t]}isValidIndex(t,e){return!(t<0||t>=this._numXEdge||e<0||e>=this._numYEdge)}}class Js{get indexGrid(){return this._buckets}constructor(t,e){this._points=t,this._buckets=e}static create(t,e){const i=t.length;if(t.length<1)return;const s=t.getRange();s.expandInPlace(1e3*K.smallMetricDistance);const n=Hs.createWithEstimatedCounts(s,t.length,e);if(void 0===n)return;const r=new Js(t,n),o=Q.create();for(let e=0;e<i;e++)t.getPoint3dAtUncheckedPointIndex(e,o),n.addDataAtXY(o.x,o.y,e);return r}announcePointsInRange(t,e){const i=this._buckets.xIndex(t.low.x),s=this._buckets.xIndex(t.high.x),n=this._buckets.yIndex(t.low.y),r=this._buckets.yIndex(t.high.y),o=this._points.length;for(let a=i;a<=s;a++)for(let i=n;i<=r;i++){const s=this._buckets.getDataAtIndex(a,i);if(void 0!==s)for(const i of s)if(i<o){const s=this._points.getXAtUncheckedPointIndex(i),n=this._points.getYAtUncheckedPointIndex(i),r=this._points.getZAtUncheckedPointIndex(i);if(t.containsXY(s,n)&&!e(i,s,n,r))return}}}}class Ks{constructor(t=0){this._minMax=ft.createNull(),this._count=this._sumX=this._sumXX=0,this._origin=t}get count(){return this._count}get mean(){return this._count>0?this._sumX/this._count:0}get meanSquare(){return this._count>0?this._sumXX/this._count:0}get minMax(){return this._minMax.clone()}get standardDeviation(){if(this._count<1)return 0;const t=this.mean,e=this._sumXX,i=this._sumX;return Math.sqrt((e-2*t*i+this._count*t*t)/this._count)}clearSums(){this._count=this._sumX=this._sumXX=0,this._minMax.setNull()}get origin(){return this._origin}setOrigin(t){this._origin=t}shiftOriginAndSums(t){const e=t-this._origin;this._origin=t,this._sumXX=this._sumXX-2*e*this._sumX+this._count*e*e,this._sumX=this._sumX-this._count*e,this._minMax.cloneTranslated(-e,this._minMax)}accumulate(t){t-=this._origin,this._count+=1,this._sumX+=t,this._sumXX+=t*t,this._minMax.extendX(t)}accumulateArray(t){for(const e of t)this.accumulate(e)}clone(t){return t||(t=new Ks),this._minMax.clone(t._minMax),t._count=this._count,t._origin=this._origin,t._sumX=this._sumX,t._sumXX=this._sumXX,t}isAlmostEqual(t){return K.isAlmostEqualNumber(this._sumX,t._sumX)&&K.isAlmostEqualNumber(this._sumXX,t._sumXX)&&K.isAlmostEqualNumber(this._origin,t._origin)&&this._count===t._count&&this._minMax.isAlmostEqual(t._minMax)}}class js{constructor(){this.range=ut.createNull(),this.xSums=new Ks,this.ySums=new Ks,this.zSums=new Ks,this._workRange=ut.createNull()}accumulateGrowableXYZArrayRange(t){t.setRange(this._workRange),this.range.extendRange(this._workRange),this.xSums.accumulate(this._workRange.xLength()),this.ySums.accumulate(this._workRange.yLength()),this.zSums.accumulate(this._workRange.zLength())}}class Qs{constructor(t,e,i,s,n,r){this.vectorToEye=t,this.sideAngle=e,this.assembleChains=i,this.collectOnForwardFacets=s,this.collectOnSideFacets=n,this.collectOnRearFacets=r}static create(t,e,i,s,n,r){return new Qs(void 0===t?$.unitZ():t.clone(),void 0===e?W.createRadians(K.smallAngleRadians):e.clone(),K.resolveValue(i,!0),K.resolveValue(s,!0),K.resolveValue(n,!0),K.resolveValue(r,!0))}get collectAll(){return!0===this.collectOnForwardFacets&&!0===this.collectOnRearFacets&&!0===this.collectOnRearFacets}collectFromThisFacetNormal(t){return void 0!==t&&(t.angleFromPerpendicular(this.vectorToEye).isMagnitudeLessThanOrEqual(this.sideAngle)?this.collectOnSideFacets:t.dotProduct(this.vectorToEye)>0?this.collectOnForwardFacets:this.collectOnRearFacets)}}class $s{constructor(t=W.createDegrees(25),e=W.createDegrees(60),i=W.createDegrees(90)){this.smoothSingleAngleBetweenNormals=t.clone(),this.smoothAccumulatedAngleBetweenNormals=e.clone(),this.chamferAngleBetweenNormals=i.clone()}static create(t=W.createDegrees(25),e=W.createDegrees(60),i=W.createDegrees(120)){const s=t.clone(),n=e.clone(),r=i.clone();return s.degrees<1&&n.setDegrees(1),n.degrees<1&&n.setDegrees(1),n.degrees<15&&n.setDegrees(15),new $s(s,n,r)}}!function(t){t[t.SelectNone=0]="SelectNone",t[t.SelectAny=1]="SelectAny",t[t.SelectAll=2]="SelectAll",t[t.SelectOneByParity=3]="SelectOneByParity"}(N||(N={}));class tn{static visitorToLoop(t){const e=we.createPoints(t.point.getPoint3dArray());return Ke.create(e)}static indexedPolyfaceToLoops(t){const e=Ge.create(),i=t.createVisitor(1);for(;i.moveToNextFacet();){const t=tn.visitorToLoop(i);e.tryAddChild(t)}return e}static sumFacetAreas(t,e){let i=0;if(void 0!==t){if(t instanceof Pi)return tn.sumFacetAreas(t.createVisitor(1),e);let s;for(void 0!==e&&(s=e.normalize()),t.reset();t.moveToNextFacet();){const e=gr.areaNormal(t.point.getPoint3dArray());let n=e.magnitude();if(void 0!==s){const t=K.conditionalDivideCoordinate(1,n);void 0!==t&&(n*=e.dotProduct(s)*t)}i+=n}}return i}static sumTetrahedralVolumes(t,e){let i=0;if(t instanceof Pi)return tn.sumTetrahedralVolumes(t.createVisitor(0),e);let s=e;const n=Q.create(),r=Q.create(),o=Q.create();for(t.reset();t.moveToNextFacet();){void 0===s&&(s=t.point.getPoint3dAtUncheckedPointIndex(0)),t.point.getPoint3dAtUncheckedPointIndex(0,n);for(let e=1;e+1<t.point.length;e++)t.point.getPoint3dAtUncheckedPointIndex(e,r),t.point.getPoint3dAtUncheckedPointIndex(e+1,o),i+=s.tripleProductToPoints(n,r,o)}return i/6}static sumVolumeBetweenFacetsAndPlane(t,e){if(t instanceof Pi)return tn.sumVolumeBetweenFacetsAndPlane(t.createVisitor(0),e);const i=Q.create(),s=Q.create(),n=Q.create(),r=$.create(),o=e.getNormalRef();let a,c,h,l,d,u=0;const f=ti.create(void 0,!0),g=ti.create(void 0,!0),p=zt.createZero(),m=e.getProjectionToPlane();for(t.reset();t.moveToNextFacet();){t.point.getPoint3dAtUncheckedPointIndex(0,i),a=e.altitude(i),d=0;for(let f=1;f+1<t.point.length;f++)t.point.getPoint3dAtUncheckedPointIndex(f,s),t.point.getPoint3dAtUncheckedPointIndex(f+1,n),i.crossProductToPoints(s,n,r),c=e.altitude(s),h=e.altitude(n),l=o.dotProduct(r),d+=l,u+=l*(a+c+h);p.setZero(),t.point.multiplyTransformInPlace(m),gr.addSecondMomentAreaProducts(t.point,i,p),d>0?f.accumulateProductsFromOrigin(i,p,1):g.accumulateProductsFromOrigin(i,p,1)}return f.shiftOriginAndSumsToCentroidOfSums(),g.shiftOriginAndSumsToCentroidOfSums(),{volume:u/6,positiveProjectedFacetAreaMoments:ti.inertiaProductsToPrincipalAxes(f.origin,f.sums),negativeProjectedFacetAreaMoments:ti.inertiaProductsToPrincipalAxes(g.origin,g.sums)}}static sumFacetSecondAreaMomentProducts(t,e){if(t instanceof Pi)return tn.sumFacetSecondAreaMomentProducts(t.createVisitor(0),e);const i=zt.createZero();for(t.reset();t.moveToNextFacet();)gr.addSecondMomentAreaProducts(t.point,e,i);return i}static sumFacetSecondVolumeMomentProducts(t,e){if(t instanceof Pi)return tn.sumFacetSecondVolumeMomentProducts(t.createVisitor(0),e);const i=zt.createZero();for(t.reset();t.moveToNextFacet();)gr.addSecondMomentVolumeProducts(t.point,e,i);return i}static computePrincipalAreaMoments(t){const e=t.data.getPoint(0);if(!e)return;const i=tn.sumFacetSecondAreaMomentProducts(t,e);return ti.inertiaProductsToPrincipalAxes(e,i)}static computePrincipalVolumeMoments(t){const e=t.data.getPoint(0);if(!e)return;const i=tn.sumFacetSecondVolumeMomentProducts(t,e);return ti.inertiaProductsToPrincipalAxes(e,i)}static isConvexByDihedralAngleCount(t,e=!1){return this.dihedralAngleSummary(t,e)>0}static dihedralAngleSummary(t,e=!1){const i=new Xs,s=t.createVisitor(1);s.reset();const n=[];let r=0;for(;s.moveToNextFacet();){const t=s.pointCount-1,e=gr.centroidAreaNormal(s.point);if(void 0===e)return 0;n.push(e);for(let e=0;e<t;e++)i.addEdge(s.clientPointIndex(e),s.clientPointIndex(e+1),r);r++}const o=[],a=[];if(i.sortAndCollectClusters(a,e?void 0:o,void 0,o),o.length>0)return 0;let c=0,h=0,l=0;const d=$.create();for(const e of a){const i=e[0],s=e[1];if(i instanceof Es&&s instanceof Es&&t.data.point.vectorIndexIndex(i.vertexIndexA,i.vertexIndexB,d)){const t=n[i.facetIndex].direction.signedAngleTo(n[s.facetIndex].direction,d);t.isAlmostZero?h++:t.radians>0?c++:l++}}return c>0&&0===l?1:l>0&&0===c?-1:h>0&&0===c&&0===l?1:0}static isPolyfaceClosedByEdgePairing(t){return this.isPolyfaceManifold(t,!1)}static isPolyfaceManifold(t,e=!1){const i=new Xs,s=t.createVisitor(1);for(s.reset();s.moveToNextFacet();){const t=s.pointCount-1;for(let e=0;e<t;e++)i.addEdge(s.clientPointIndex(e),s.clientPointIndex(e+1),s.currentReadIndex())}const n=[];return i.sortAndCollectClusters(void 0,e?void 0:n,void 0,n),0===n.length}static boundaryEdges(t,e=!0,i=!0,s=!0){const n=new Ge;if(tn.announceBoundaryEdges(t,((t,e,i,s,r)=>{n.tryAddChild(Pe.create(t,e))}),e,i,s),0!==n.children.length)return n}static announceBoundaryEdges(t,e,i=!0,s=!0,n=!0){if(void 0===t)return;const r=new Xs,o=t instanceof Pi?t.createVisitor(1):t;for(o.setNumWrap(1),o.reset();o.moveToNextFacet();){const t=o.pointCount-1;for(let e=0;e<t;e++)r.addEdge(o.clientPointIndex(e),o.clientPointIndex(e+1),o.currentReadIndex())}const a=[],c=[],h=[];r.sortAndCollectClusters(void 0,a,h,c);const l=[];if(i&&a.length>0&&l.push(a),s&&c.length>0&&l.push(c),n&&h.length>0&&l.push(h),0===l.length)return;const d=o.clientPolyface();for(const t of l)for(const i of t){const t=i instanceof Es?i:i[0],s=t.vertexIndexA,n=t.vertexIndexB,r=d.data.getPoint(s),a=d.data.getPoint(n);r&&a&&e(r,a,s,n,o.currentReadIndex())}}static announceSweepLinestringToConvexPolyfaceXY(t,e,i){const s=qs.create(t);if(s){const t=e.createVisitor(0);for(t.reset();t.moveToNextFacet();)s.projectToPolygon(t.point,i,e,t.currentReadIndex())}}static async continueAnnounceSweepLinestringToConvexPolyfaceXY(t,e,i){let s=0;for(;s<this.asyncWorkLimit&&e.moveToNextFacet();)s+=t.projectToPolygon(e.point,i,e.clientPolyface(),e.currentReadIndex());return s}static setAsyncWorkLimit(t){const e=this._asyncWorkLimit;return this._asyncWorkLimit=t,e}static get asyncWorkLimit(){return this._asyncWorkLimit}static async asyncAnnounceSweepLinestringToConvexPolyfaceXY(t,e,i){const s=qs.create(t);this.awaitBlockCount=0;let n=0;if(s){const t=e.createVisitor(0);let r;for(;0<(r=await Promise.resolve(tn.continueAnnounceSweepLinestringToConvexPolyfaceXY(s,t,i)));)n+=r,this.awaitBlockCount++}return n}static partitionFacetIndicesByVertexConnectedComponent(t){if(t instanceof Pi)return this.partitionFacetIndicesByVertexConnectedComponent(t.createVisitor(0));const e=new Yi(this.visitorClientPointCount(t));for(t.reset();t.moveToNextFacet();){const i=t.pointIndex[0];for(const s of t.pointIndex)e.mergeSubsets(i,s)}const i=e.collectRootIndices(),s=[],n=i.length;for(let t=0;t<n;t++)s.push([]);for(t.reset();t.moveToNextFacet();){const r=t.pointIndex[0],o=e.findRoot(r);for(let e=0;e<n;e++)if(i[e]===o){s[e].push(t.currentReadIndex());break}}return s}static partitionFacetIndicesByVisibilityVector(t,e,i){if(t instanceof Pi)return this.partitionFacetIndicesByVisibilityVector(t.createVisitor(0),e,i);const s=[];for(let t=0;t<3;t++)s.push([]);const n=s[0],r=s[1],o=s[2],a=Math.max(i.radians,1e-8);for(t.reset();t.moveToNextFacet();){const i=gr.areaNormalGo(t.point),s=t.currentReadIndex();if(i){const t=i.angleFromPerpendicular(e);Math.abs(t.radians)<a?o.push(s):i.dotProduct(e)<0?r.push(s):n.push(s)}}return s}static boundaryOfVisibleSubset(t,e,i,s=W.createDegrees(.001)){const n=this.partitionFacetIndicesByVisibilityVector(t,i,s);if(0===n[e].length)return;const r=_i.createSubsetVisitor(t,n[e],1);return this.boundaryEdges(r,!0,!1,!1)}static announceBoundaryChainsAsLineString3d(t,e){const i=new Mi(K.smallMetricDistance,1e3);tn.announceBoundaryEdges(t,((t,e,s,n)=>i.captureCurve(Pe.create(t,e))),!0,!1,!1),i.announceChainsAsLineString3d(e)}static cloneWithMaximalPlanarFacets(t){if(t instanceof Pi)return this.cloneWithMaximalPlanarFacets(t.createVisitor(0));const e=tn.visitorClientFacetCount(t),i=tn.collectEdgesByDihedralAngle(t),s=tn.partitionFacetIndicesBySortableEdgeClusters(i,e),n=Rn.create(),r=t,o=[];for(const t of s)1===t.length?r.moveToReadIndex(t[0])&&n.addFacetFromVisitor(r):o.push(t);const a=tn.clonePartitions(t,o);for(const t of a){const e=[],i=[];tn.announceBoundaryEdges(t,((t,s,n,r)=>{e.push(Pe.create(t,s)),i.push([t.clone(),s.clone()])}));const s=Ri.collectChains(e,1e-4,1e-4);if(s){const t=new Je;t.announce(s);const e=t.getValidatedFrame(!1);if(void 0!==e){const t=e.inverse();if(void 0!==t){t.multiplyPoint3dArrayArrayInPlace(i);const s=Ps.formGraphFromChains(i,!0,M.BOUNDARY_EDGE);if(s){Ts.collectConnectedComponentsWithExteriorParityMasks(s,new Cs(M.BOUNDARY_EDGE),M.EXTERIOR);const t=Rn.graphToPolyface(s);n.addIndexedPolyface(t,!1,e)}}}}}return n.claimPolyface(!0)}static fillSimpleHoles(t,e,i){if(t instanceof Pi)return this.fillSimpleHoles(t.createVisitor(0),e,i);const s=Rn.create(),n=[];tn.announceBoundaryChainsAsLineString3d(t,(t=>{t.reverseInPlace(),n.push(t)}));for(const t of n){const n=t.points;let r=!1;t.isPhysicallyClosed?(void 0!==e.maxEdgesAroundHole&&n.length>e.maxEdgesAroundHole||void 0!==e.maxPerimeter&&ae.sumEdgeLengths(n,!1)>e.maxPerimeter||void 0!==e.upVector&&gr.sumTriangleAreasPerpendicularToUpVector(n,e.upVector)<=0)&&(r=!0):r=!0,!r&&ks.triangulateSimplestSpaceLoop(n,((t,e)=>{for(const t of e)s.addPolygon(t)}))||(r=!0),r&&void 0!==i&&i.push(t)}if(void 0!==e.includeOriginalMesh&&e.includeOriginalMesh)for(t.reset();t.moveToNextFacet();)s.addFacetFromVisitor(t);return s.claimPolyface(!0)}static clonePartitions(t,e){if(t instanceof Pi)return this.clonePartitions(t.createVisitor(0),e);t.setNumWrap(0);const i=[],s=ye.createForFacets();s.needNormals=void 0!==t.normal,s.needParams=void 0!==t.param,s.needColors=void 0!==t.color,s.needTwoSided=t.twoSided;for(const n of e){const e=Rn.create(s);t.reset();for(const i of n)t.moveToReadIndex(i),e.addFacetFromVisitor(t);i.push(e.claimPolyface(!0))}return i}static cloneFiltered(t,e){if(t instanceof Pi)return this.cloneFiltered(t.createVisitor(0),e);t.setNumWrap(0);const i=ye.createForFacets();i.needNormals=void 0!==t.normal,i.needParams=void 0!==t.param,i.needColors=void 0!==t.color,i.needTwoSided=t.twoSided;const s=Rn.create(i);for(t.reset();t.moveToNextFacet();)e(t)&&s.addFacetFromVisitor(t);return s.claimPolyface(!0)}static visitorClientPointCount(t){const e=t.clientPolyface();if(void 0!==e)return e.data.point.length;t.reset();let i=-1;for(;t.moveToNextFacet();)for(const e of t.pointIndex)e>i&&(i=e);return i+1}static visitorClientFacetCount(t){const e=t.clientPolyface();if(void 0!==e&&void 0!==e.facetCount)return e.facetCount;let i=0;for(t.reset();t.moveToNextFacet();)++i;return i}static partitionFacetIndicesBySortableEdgeClusters(t,e){const i=new Yi(e);for(const e of t)if(e instanceof Es);else{const t=e[0];for(let s=1;s<e.length;s++)i.mergeSubsets(t.facetIndex,e[s].facetIndex)}const s=i.collectRootIndices(),n=[],r=s.length;for(let t=0;t<r;t++)n.push([]);for(let t=0;t<e;t++){const e=i.findRoot(t);for(let i=0;i<r;i++)if(s[i]===e){n[i].push(t);break}}return n}static partitionFacetIndicesByEdgeConnectedComponent(t,e=!1){if(t instanceof Pi)return this.partitionFacetIndicesByEdgeConnectedComponent(t.createVisitor(0),e);t.setNumWrap(1);const i=new Xs;t.reset();let s=0;for(;t.moveToNextFacet();){const n=t.pointCount-1;s++;for(let s=0;s<n;s++)e&&t.edgeVisible[s]||i.addEdge(t.clientPointIndex(s),t.clientPointIndex(s+1),t.currentReadIndex())}const n=[];return i.sortAndCollectClusters(n,n,n,n),this.partitionFacetIndicesBySortableEdgeClusters(n,s)}static sweepLineStringToFacetsXYReturnSweptFacets(t,e){const i=Rn.create();return this.announceSweepLinestringToConvexPolyfaceXY(t,e,((t,e,s,n,r)=>{4===r.length?i.addQuadFacet(r):3===r.length&&i.addTriangleFacet(r)})),i.claimPolyface(!0)}static sweepLinestringToFacetsXYreturnSweptFacets(t,e){return this.sweepLineStringToFacetsXYReturnSweptFacets(t,e)}static sweepLineStringToFacets(t,e,i){let s,n=[];void 0===i&&(i=Qs.create($.unitZ(),W.createRadians(K.smallAngleRadians),!0,!0,!0,!0)),i.assembleChains&&(s=As.create());const r=Gs.create(t,i.vectorToEye);if(r){let t;t=e instanceof Pi?e.createVisitor(0):e;const o=$.createZero();for(t.reset();t.moveToNextFacet();)i.collectFromThisFacetNormal(gr.areaNormalGo(t.point,o))&&r.processPolygon(t.point.getArray(),((t,e)=>{void 0!==s?s.addSegment(t,e):n.push(Pe.create(t,e))}));void 0!==s&&(s.clusterAndMergeVerticesXYZ(),n=s.collectMaximalChains())}return n}static sweepLineStringToFacetsXY(t,e,i){const s=As.create(),n=$.create(0,0,1),r=ut.create();let o,a;o=e instanceof Pi?e.createVisitor(0):e,a=Array.isArray(t)?new se(t):t;for(let t=1;t<a.length;t++){const e=a.getPoint3dAtUncheckedPointIndex(t-1),c=a.getPoint3dAtUncheckedPointIndex(t),h=Ws.createPointPointSweep(e,c,n);void 0!==h&&(ut.createNull(r),r.extendPoint(e),r.extendPoint(c),i.searchRange2d(r,((t,e)=>(o.moveToReadIndex(e)&&h.processPolygon(o.point,((t,e)=>s.addSegment(t,e))),!0))))}return s.clusterAndMergeVerticesXYZ(),s.collectMaximalChains()}static sweepLinestringToFacetsXYReturnLines(t,e){const i=Qs.create($.unitZ(),W.createSmallAngle(),!1,!0,!0,!0);return tn.sweepLineStringToFacets(t,e,i)}static sweepLinestringToFacetsXYReturnChains(t,e){const i=Qs.create($.unitZ(),W.createSmallAngle(),!0,!0,!0,!0);return tn.sweepLineStringToFacets(t,e,i)}static async asyncSweepLinestringToFacetsXYReturnChains(t,e){const i=As.create();return await Promise.resolve(this.asyncAnnounceSweepLinestringToConvexPolyfaceXY(t,e,((t,e,s,n,r,o,a)=>{i.addSegment(r[o],r[a])}))),i.clusterAndMergeVerticesXYZ(),i.collectMaximalChains()}static collectRangeLengthData(t){if(t instanceof Pi)return this.collectRangeLengthData(t.createVisitor(0));const e=new js;for(t.reset();t.moveToNextFacet();)e.accumulateGrowableXYZArrayRange(t.point);return e}static cloneWithTVertexFixup(t){const e=t.createVisitor(1),i=t.createVisitor(0),s=Js.create(t.data.point,30),n=Rn.create(),r=ut.createNull(),o=Q.create(),a=Q.create(),c=Q.create(),h=Pe.create(o,a);for(e.reset();e.moveToNextFacet();){i.clearArrays();for(let n=0;n+1<e.point.length;n++){let l;if(e.point.getPoint3dAtUncheckedPointIndex(n,o),e.point.getPoint3dAtUncheckedPointIndex(n+1,a),i.pushDataFrom(e,n),r.setNull(),Pe.create(o,a,h),r.extend(o),r.extend(a),s.announcePointsInRange(r,((e,i,s,n)=>{t.data.point.getPoint3dAtUncheckedPointIndex(e,c);const r=h.closestPoint(c,!1);return void 0!==r&&r.fraction>=0&&r.fraction<1&&!r.point.isAlmostEqual(o)&&!r.point.isAlmostEqual(a)&&c.isAlmostEqual(r.point)&&(void 0===l&&(l=[]),r.a=e,l.push(r)),!0})),void 0!==l){l.sort(((t,e)=>t.fraction-e.fraction));for(const t of l)i.pushInterpolatedDataFrom(e,n,t.fraction,n+1)}}n.addFacetFromGrowableArrays(i.point,i.normal,i.param,i.color,i.edgeVisible)}return n.claimPolyface()}static compareFacetIndexAndVertexIndices(t,e){if(t.length!==e.length)return t.length-e.length;for(let i=1;i<t.length;i++)if(t[i]!==e[i])return t[i]-e[i];return 0}static collectDuplicateFacetIndices(t,e=!1){const i=[];return this.announceDuplicateFacetIndices(t,(t=>{(e||t.length>1)&&i.push(t.slice())})),i}static announceDuplicateFacetIndices(t,e){const i=t.createVisitor(0),s=[];for(i.reset();i.moveToNextFacet();){const t=[i.currentReadIndex()],e=i.pointIndex,n=e.length;let r=0;for(let t=1;t<i.pointIndex.length;t++)e[t]<e[r]&&(r=t);if(e[(r+1)%n]<e[(r+n-1)%n])for(let i=0;i<n;i++)t.push(e[(r+i)%n]);else for(let i=0;i<n;i++)t.push(e[(r+n-i)%n]);s.push(t)}let n,r;s.sort(((t,e)=>this.compareFacetIndexAndVertexIndices(t,e)));const o=s.length,a=[];for(n=0;n<o;n=r){for(r=n+1,a.length=0,a.push(s[n][0]);r<o&&0===this.compareFacetIndexAndVertexIndices(s[n],s[r]);)a.push(s[r][0]),r++;e(a)}}static cloneByFacetDuplication(t,e,i){const s=Rn.create(),n=t.createVisitor(0);return this.announceDuplicateFacetIndices(t,(t=>{let r=0;1===t.length?e&&(r=1):t.length>1&&(i===N.SelectAny?r=1:i===N.SelectAll?r=t.length:i===N.SelectOneByParity&&(r=1==(1&t.length)?1:0));for(let e=0;e<r;e++)n.moveToReadIndex(t[e]),s.addFacetFromVisitor(n)})),s.claimPolyface()}static cloneWithColinearEdgeFixup(t){const e=t.createVisitor(2),i=t.createVisitor(0),s=Rn.create(),n=$.create(),r=$.create(),o=t.data.point.length,a=new Int32Array(o);for(e.reset();e.moveToNextFacet();)for(let t=0;t+2<e.point.length;t++){e.point.vectorIndexIndex(t,t+1,n),e.point.vectorIndexIndex(t+1,t+2,r);const i=e.clientPointIndex(t+1);a[i]>=0&&(n.angleTo(r).isAlmostZero?a[i]++:a[i]=-1)}for(e.reset();e.moveToNextFacet();){i.clearArrays();for(let t=0;t+2<e.point.length;t++)a[e.clientPointIndex(t)]<0&&i.pushDataFrom(e,t);i.point.length>2&&s.addFacetFromGrowableArrays(i.point,i.normal,i.param,i.color,i.edgeVisible)}return s.claimPolyface()}static setEdgeVisibility(t,e,i){for(const s of e)if(s instanceof Es)this.setSingleEdgeVisibility(t,s.facetIndex,s.vertexIndexA,i);else if(Array.isArray(s))for(const e of s)this.setSingleEdgeVisibility(t,e.facetIndex,e.vertexIndexA,i)}static setSingleEdgeVisibility(t,e,i,s){const n=t.data,r=t.facetIndex0(e),o=t.facetIndex1(e);for(let t=r;t<o;t++)n.pointIndex[t]===i&&(n.edgeVisible[t]=s)}static getSingleEdgeVisibility(t,e,i){const s=t.data,n=t.facetIndex0(e),r=t.facetIndex1(e);for(let t=n;t<r;t++)if(s.pointIndex[t]===i)return s.edgeVisible[t]}static createIndexedEdges(t){if(t instanceof Pi)return this.createIndexedEdges(t.createVisitor(1));const e=new Xs;for(t.reset();t.moveToNextFacet();){const i=t.pointCount-1;for(let s=0;s<i;s++)e.addEdge(t.clientPointIndex(s),t.clientPointIndex(s+1),t.currentReadIndex())}return e}static collectEdgesByDihedralAngle(t,e,i=!1){if(t instanceof Pi)return this.collectEdgesByDihedralAngle(t.createVisitor(1),e,i);t.setNumWrap(1);const s=[];this.createIndexedEdges(t).sortAndCollectClusters(s),(void 0===e||e.radians<0)&&(e=W.createRadians(K.smallAngleRadians));const n=[],r=$.create(),o=$.create();for(const a of s)if(Array.isArray(a)&&2===a.length){const s=a[0],c=a[1];if(void 0!==tn.computeFacetUnitNormal(t,s.facetIndex,r)&&void 0!==tn.computeFacetUnitNormal(t,c.facetIndex,o)){const t=r.smallerUnorientedAngleTo(o);i?t.radians>e.radians&&n.push(a):t.radians<=e.radians&&n.push(a)}}return n}static markPairedEdgesInvisible(t,e){const i=t.createVisitor(1),s=[],n=[];if(this.createIndexedEdges(i).sortAndCollectClusters(s,n,n,n),this.markAllEdgeVisibility(t,!1),this.setEdgeVisibility(t,n,!0),void 0!==e){const n=$.create(),r=$.create();for(const o of s)if(Array.isArray(o)&&2===o.length){const s=o[0],a=o[1];void 0!==tn.computeFacetUnitNormal(i,s.facetIndex,n)&&void 0!==tn.computeFacetUnitNormal(i,a.facetIndex,r)&&n.smallerUnorientedAngleTo(r).radians>e.radians&&(this.setSingleEdgeVisibility(t,s.facetIndex,s.vertexIndexA,!0),this.setSingleEdgeVisibility(t,a.facetIndex,a.vertexIndexA,!0))}}}static computeFacetUnitNormal(t,e,i){if(i||(i=$.create()),t.moveToReadIndex(e)&&gr.unitNormal(t.point,i))return i}static markAllEdgeVisibility(t,e){const i=t.data;for(let t=0;t<i.edgeVisible.length;t++)i.edgeVisible[t]=e}static convertToHalfEdgeGraph(t){const e=new Ss,i=t.createVisitor(0);for(i.reset();i.moveToNextFacet();)e.insertLoop(i.pointIndex);const s=e.graph,n=Q.create();return s.announceNodes(((e,i)=>{const s=i.i;return t.data.getPoint(s,n),i.setXYZ(n),!0})),s}static reorientVertexOrderAroundFacetsForConsistentOrientation(t){return zs.doFixup(t)}static buildPerFaceNormals(t){Ns.buildPerFaceNormals(t)}static buildAverageNormals(t,e=W.createDegrees(31)){Ns.buildFastAverageNormals(t,e)}static cloneOffset(t,e,i=$s.create()){const s=ye.createForFacets(),n=Rn.create(s);return Zs.buildOffsetMeshWithEdgeChamfers(t,n,e,i),n.claimPolyface()}static intersectRay3d(t,e,i){if(t instanceof Pi)return tn.intersectRay3d(t.createVisitor(0),e,i);let s;for(t.setNumWrap(0);t.moveToNextFacet();){const n=t.pointCount,r=t.point;if(3===n){const n=this._workTriangle=Di.create(r.getPoint3dAtUncheckedPointIndex(0),r.getPoint3dAtUncheckedPointIndex(1),r.getPoint3dAtUncheckedPointIndex(2),this._workTriangle),o=this._workTriDetail=n.intersectRay3d(e,this._workTriDetail);n.snapLocationToEdge(o,i?.distanceTolerance,i?.parameterTolerance),s=this._workFacetDetail3=Fs.create(t.currentReadIndex(),o,this._workFacetDetail3)}else{const o=this._workPolyDetail=gr.intersectRay3d(r,e,i?.distanceTolerance,this._workPolyDetail);s=gr.isConvex(r)?this._workFacetDetailC=bs.create(t.currentReadIndex(),n,o,this._workFacetDetailC):this._workFacetDetailNC=Ms.create(t.currentReadIndex(),n,o,this._workFacetDetailNC)}if(s.isInsideOrOn){if(i?.needNormal&&t.normal&&s.getNormal(t.normal,r,i?.distanceTolerance),i?.needParam&&t.param&&s.getParam(t.param,r,i?.distanceTolerance),i?.needColor&&t.color&&s.getColor(t.color,r,i?.distanceTolerance),i?.needBarycentricCoordinates&&s.getBarycentricCoordinates(r,i?.distanceTolerance),i?.acceptIntersection&&!i.acceptIntersection(s,t))continue;return s}}}}tn._asyncWorkLimit=1e6,tn.awaitBlockCount=0;class en{constructor(t){this._planes=t||[]}toJSON(){const t=[];for(const e of this._planes)t.push(e.toJSON());return t}static fromJSON(t,e){if((e=e||new en)._planes.length=0,!Array.isArray(t))return e;for(const i of t){const t=xr.fromJSON(i);t&&e._planes.push(t)}return e}isAlmostEqual(t){if(this._planes.length!==t._planes.length)return!1;for(let e=0;e<this._planes.length;e++)if(!this._planes[e].isAlmostEqual(t._planes[e]))return!1;return!0}static createPlanes(t,e){e=e||new en;for(const i of t)if(i instanceof xr)e._planes.push(i);else if(i instanceof yt){const t=xr.createPlane(i);e._planes.push(t)}return e}static createRange3dPlanes(t,e=!0,i=!0,s=!0,n=!0,r=!0,o=!0){const a=en.createEmpty();return e&&a.planes.push(xr.createNormalAndPointXYZXYZ(1,0,0,t.low.x,0,0)),i&&a.planes.push(xr.createNormalAndPointXYZXYZ(-1,0,0,t.high.x,0,0)),s&&a.planes.push(xr.createNormalAndPointXYZXYZ(0,1,0,0,t.low.y,0)),n&&a.planes.push(xr.createNormalAndPointXYZXYZ(0,-1,0,0,t.high.y,0)),r&&a.planes.push(xr.createNormalAndPointXYZXYZ(0,0,1,0,0,t.low.z)),o&&a.planes.push(xr.createNormalAndPointXYZXYZ(0,0,-1,0,0,t.high.z)),a}static createEmpty(t){return t?(t._planes.length=0,t):new en}negateAllPlanes(){for(const t of this._planes)t.negateInPlace()}static createXYBox(t,e,i,s,n){(n=n||new en)._planes.length=0;const r=xr.createNormalAndDistance($.create(-1,0,0),-i,!1,!0),o=xr.createNormalAndDistance($.create(1,0,0),t,!1,!0),a=xr.createNormalAndDistance($.create(0,-1,0),-s,!1,!0),c=xr.createNormalAndDistance($.create(0,1,0),e,!1,!0);return r&&o&&a&&c&&n._planes.push(r,o,a,c),n}static createXYPolyLine(t,e,i,s){(s=s||new en)._planes.length=0;for(let n=0;n+1<t.length;n++){const r=$.createStartEnd(t[n],t[n+1]).unitPerpendicularXY();if(r.z=0,i||r.scaleInPlace(-1),r.normalize()){const i=void 0!==e&&e[n],o=xr.createNormalAndPoint(r,t[n],i,i);o&&s._planes.push(o)}}return s}static createXYPolyLineInsideLeft(t,e){(e=e||new en)._planes.length=0;for(let i=0;i+1<t.length;i++){const s=$.createStartEnd(t[i],t[i+1]).unitPerpendicularXY();if(s.z=0,s.normalize()){const n=xr.createNormalAndPoint(s,t[i],!1,!1);n&&e._planes.push(n)}}return e}static setPlaneAndXYLoopCCW(t,e,i){const s=t.length-1,n=t.length;let r,o,a,c,h=t.getXAtUncheckedPointIndex(s),l=t.getYAtUncheckedPointIndex(s);i._planes.length=0;const d=t.getZAtUncheckedPointIndex(s),u=t.crossProductIndexIndexIndex(0,2,1);if(xr.createNormalAndPointXYZXYZ(u.x,u.y,u.z,h,l,d,!1,!1,e),u.normalizeInPlace())for(let e=0;e<n;e++,h=r,l=o){r=t.getXAtUncheckedPointIndex(e),o=t.getYAtUncheckedPointIndex(e),a=-(o-l),c=r-h;const s=xr.createNormalAndPointXYZXYZ(a,c,0,r,o,d);s&&i._planes.push(s)}}clone(t){(t=t||new en)._planes.length=0;for(const e of this._planes)t._planes.push(e.clone());return t}get planes(){return this._planes}hasIntersectionWithRay(t,e,i=K.smallMetricDistance){let s=-K.largeCoordinateResult,n=K.largeCoordinateResult;e&&e.setNull();for(const e of this._planes){const r=e.velocity(t.direction),o=e.altitude(t.origin);if(Math.abs(r)<=1e-13){if(o<-i)return!1}else{const t=-o/r;r<0?t<n&&(n=t):t>s&&(s=t)}}return!(n<s||(e&&(e.extendX(s),e.extendX(n)),0))}multiplyPlanesByMatrix4d(t,e=!0,i=!0){if(e){const e=t.createInverse();return!!e&&this.multiplyPlanesByMatrix4d(e,!1,i)}for(const e of this._planes)e.multiplyPlaneByMatrix4d(t,!1,i);return!0}isPointInside(t){for(const e of this._planes)if(!e.isPointInside(t))return!1;return!0}isPointOnOrInside(t,e=K.smallMetricDistance){const i=Math.abs(e);for(const s of this._planes)if(!s.isPointOnOrInside(t,s.interior?i:e))return!1;return!0}isSphereInside(t,e){const i=Math.abs(e)+K.smallMetricDistance;for(const e of this._planes)if(!e.isPointOnOrInside(t,i))return!1;return!0}announceClippedSegmentIntervals(t,e,i,s,n){let r;if(e<t)return!1;for(const n of this._planes){const o=-n.altitude(i),a=-n.altitude(s);if(r=K.conditionalDivideFraction(-o,a-o),void 0===r){if(o>0)return!1}else if(a>o){if(r<t)return!1;r<e&&(e=r)}else if(o>a){if(r>e)return!1;r>t&&(t=r)}else if(o>0)return!1}return e>=t&&(n&&n(t,e),!0)}announceClippedArcIntervals(t,e){const i=en._clipArcFractionArray;i.clear();for(const e of this.planes)e.appendIntersectionRadians(t,i);return t.sweep.radiansArrayToPositivePeriodicFractions(i),os.selectIntervals01(t,i,this,e)}clipUnboundedSegment(t,e,i){return this.announceClippedSegmentIntervals(-Number.MAX_VALUE,Number.MAX_VALUE,t,e,i)}transformInPlace(t){for(const e of this._planes)e.transformInPlace(t)}clipConvexPolygonInPlace(t,e,i=K.smallMetricDistance){for(const s of this._planes)if(s.clipConvexPolygonInPlace(t,e,!0,i),t.length<3)return}clipInsidePushOutside(t,e,i){const s=ft.createNull();let n=i.grabFromCache(),r=i.grabFromCache(),o=i.grabFromCache();o.pushFrom(t);for(const t of this._planes)if(pr.splitConvexPolygonInsideOutsidePlane(t,o,n,r,s),r.length>0){if(e&&os.captureOrDrop(r,3,e,i),r=i.grabFromCache(),0===n.length){o.length=0;break}i.dropToCache(o),o=n,n=i.grabFromCache()}if(i.dropToCache(n),i.dropToCache(r),o.length>0)return o;i.dropToCache(o)}classifyPointContainment(t,e){let i=!0;const s=e?1e-8:-1e-8;for(const e of this._planes){let n=0;for(const r of t)e.altitude(r)<(e.interior?1e-8:s)&&(n++,i=!1);if(n===t.length)return X.StronglyOutside}return i?X.StronglyInside:X.Ambiguous}static createSweptPolyline(t,e,i){const s=en.createEmpty();let n=!1;t.length>3&&t[0].isAlmostEqual(t[t.length-1])&&gr.areaNormal(t).dotProduct(e)>0&&(n=!0);for(let r=0;r+1<t.length;r++)if(n){const n=xr.createEdgeAndUpVector(t[r+1],t[r],e,i);if(!n)return;s.addPlaneToConvexSet(n)}else{const n=xr.createEdgeAndUpVector(t[r],t[r+1],e,i);if(!n)return;s.addPlaneToConvexSet(n)}return s}addPlaneToConvexSet(t){t instanceof xr?this._planes.push(t):t instanceof yt&&this._planes.push(xr.createPlane(t))}clipPointsOnOrInside(t,e,i){e.length=0,i.length=0;for(const s of t)this.isPointOnOrInside(s,0)?e.push(s):i.push(s)}polygonClip(t,e,i,s){t instanceof nt?t.clone(e):nt.create(t,e);for(const t of this._planes)if(s!==t){if(0===e.length)break;t.clipConvexPolygonInPlace(e,i)}}reloadSweptPolygon(t,e,i){this._planes.length=0;const s=t.length;if(s<=2)return 0;const n=gr.areaNormal(t),r=e.dotProduct(n)>0,o=r?1:s-1;for(let i=0;i<s;i++){const n=(i+o)%s,r=t[i],a=t[n];if(r.isAlmostEqual(a))continue;const c=$.createStartEnd(r,a),h=$.createCrossProduct(e.x,e.y,e.z,c.x,c.y,c.z).normalize();let l;if(h){l=h.dotProduct(r);const t=xr.createNormalAndDistance(h,l,!1,!1);t&&this._planes.push(t)}}if(0!==i){let s=n.normalize();if(s){e.dotProduct(s)*i<0&&(s=s.negate());const n=t[0],r=s.dotProduct(n),o=xr.createNormalAndDistance(s,r,!1,!1);o&&this._planes.push(o)}}return r?1:-1}computePlanePlanePlaneIntersections(t,e,i,s=!0){const n=xt.createIdentity(),r=this._planes,o=r.length;let a=0;for(let c=0;c<o;c++)for(let h=c+1;h<o;h++)for(let l=h+1;l<o;l++)if(xt.createRowValues(r[c].inwardNormalRef.x,r[c].inwardNormalRef.y,r[c].inwardNormalRef.z,r[h].inwardNormalRef.x,r[h].inwardNormalRef.y,r[h].inwardNormalRef.z,r[l].inwardNormalRef.x,r[l].inwardNormalRef.y,r[l].inwardNormalRef.z,n),n.computeCachedInverse(!1)){const o=n.multiplyInverseXYZAsPoint3d(r[c].distance,r[h].distance,r[l].distance);s&&!this.isPointOnOrInside(o,K.smallMetricDistance)||(a++,i&&i.multiplyPoint3d(o,o),t&&t.push(o),e&&e.extendPoint(o))}return a}setInvisible(t){for(const e of this._planes)e.setInvisible(t)}addZClipPlanes(t,e,i){void 0!==e&&this._planes.push(xr.createNormalAndDistance($.create(0,0,1),e,t)),void 0!==i&&this._planes.push(xr.createNormalAndDistance($.create(0,0,-1),-i,t))}appendPolygonClip(t,e,i,s){const n=this.clipInsidePushOutside(t,i,s);n&&e.push(n)}static createConvexPolyface(t,e){e=this.createEmpty(e);let i,s,n=0;if(t instanceof Pi?(i=t,s=t.createVisitor(0)):(i=t.clientPolyface(),s=t),i&&s){tn.isPolyfaceClosedByEdgePairing(i)&&(n=tn.sumTetrahedralVolumes(s));const t=n>0?-1:1,r=$.create(),o=yt.createXYPlane();for(s.reset();s.moveToNextFacet();)void 0!==gr.areaNormalGo(s.point,r)&&(r.scaleInPlace(t),void 0!==yt.create(s.point.front(),r,o)&&e.addPlaneToConvexSet(o))}return{clipper:e,volume:n}}}en.hugeVal=1e37,en._clipArcFractionArray=new St;class sn{constructor(t,e,i){if(t instanceof ie){const e=t;(t=t.startPoint().isAlmostEqual(t.endPoint())?new Ke:new Fi).tryAddChild(e)}this.curves=t,this.localToWorld=e,this.axis=i}static createForLinearSweep(t,e){const i=Je.createRightHandedFrame(e,t);if(i)return new sn(t,i,void 0)}static createForPolygon(t,e){const i=Je.createRightHandedFrame(e,t);if(i){void 0!==e&&i.matrix.dotColumnZ(e)&&i.matrix.scaleColumnsInPlace(1,-1,-1);const s=we.createArrayOfLineString3d(t),n=[];for(const t of s)t.addClosurePoint(),n.push(Ke.create(t));if(1===n.length)return new sn(n[0],i,void 0);if(n.length>1)return new sn(Qe.createLoops(n),i,void 0)}}static createForRotation(t,e){const i=Je.createRightHandedFrame(void 0,t,e);if(i)return new sn(t,i,e.clone())}getCurves(){return this.curves}tryTransformInPlace(t){if(this.curves.tryTransformInPlace(t)){this.axis&&this.axis.transformInPlace(t);const e=void 0!==this.axis?Je.createRightHandedFrame(void 0,this.curves,this.axis):Je.createRightHandedFrame(void 0,this.curves);if(e)return this.localToWorld.setFrom(e),!0}return!1}clone(){return new sn(this.curves.clone(),this.localToWorld.clone(),this.axis)}cloneTransformed(t){const e=this.clone();if(e.tryTransformInPlace(t))return e}isAlmostEqual(t){return t instanceof sn&&this.curves.isAlmostEqual(t.curves)&&this.localToWorld.isAlmostEqual(t.localToWorld)}get xyStrokes(){return this._xyStrokes}buildFacets(t){if(!this._facets)if(this.curves instanceof Ke){if(this._xyStrokes=this.curves.cloneStroked(t),this._xyStrokes instanceof Ke&&1===this._xyStrokes.children.length){const e=this._xyStrokes.children[0].points;this.localToWorld.multiplyInversePoint3dArrayInPlace(e),gr.sumTriangleAreasXY(e)<0&&e.reverse();const i=ms.createTriangulatedGraphFromSingleLoop(e);if(i){ms.flipTriangles(i);const e=Rn.graphToPolyface(i,t);this._facets=e,this._facets.tryTransformInPlace(this.localToWorld)}else{const t=rr.polygonXYAreaUnionLoopsToPolyface(e,[],!0);t&&(this._facets=t,this._facets.tryTransformInPlace(this.localToWorld))}}}else if(this.curves instanceof Qe&&(this._xyStrokes=this.curves.cloneStroked(t),this._xyStrokes instanceof Qe)){const e=this.localToWorld.inverse();this._xyStrokes.tryTransformInPlace(e);const i=[];for(const t of this._xyStrokes.children){const e=t.children;if(1===e.length){const t=e[0];t instanceof we&&i.push(t.packedPoints)}}const s=i.length,n=ms.createTriangulatedGraphFromLoops(i);if(n&&Ts.isTriangulatedCCW(n,!0,s-1)){ms.flipTriangles(n);const e=Rn.graphToPolyface(n,t);this._facets=e,this._facets.tryTransformInPlace(this.localToWorld)}else{const t=rr.polygonXYAreaUnionLoopsToPolyface(i,[],!0);t&&(this._facets=t,this._facets.tryTransformInPlace(this.localToWorld))}}}purgeFacets(){this._facets=void 0}emitFacets(t,e,i){this.buildFacets(t.options),this._facets&&t.addIndexedPolyface(this._facets,e,i)}announceFacets(t,e){this.buildFacets(e),this._facets&&t(this._facets)}sweepToUnionOfConvexClipPlaneSets(t,e=!1,i=!1){const s=Rn.create();t||(e=i=!1),this.buildFacets(s.options),void 0===t&&(t=this.localToWorld.matrix.columnZ());const n=this.localToWorld.matrix.columnZ(),r=this._facets,o=Q.create(),a=Q.create();if(r){const s=this.localToWorld.getOrigin(),c=s.plus(t),h=n.clone(),l=n.negate(),d=Gi.createEmpty(),u=r.createVisitor(1);for(u.reset();u.moveToNextFacet();){const n=u.point.length-1,r=en.createEmpty();for(let e=0;e<n;e++){u.point.getPoint3dAtUncheckedPointIndex(e,o),u.point.getPoint3dAtUncheckedPointIndex(e+1,a);const i=xr.createEdgeAndUpVector(a,o,t),s=u.edgeVisible[e];i?.setFlags(!s,!s),r.addPlaneToConvexSet(i)}e&&r.addPlaneToConvexSet(xr.createNormalAndPoint(h,s)),i&&r.addPlaneToConvexSet(xr.createNormalAndPoint(l,c)),d.addConvexSet(r)}return d}}}class nn extends si{constructor(t,e){super(e),this.solidPrimitiveType="ruledSweep",this._contours=t}static create(t,e){const i=[];for(const e of t){const t=sn.createForLinearSweep(e);if(void 0===t)return;i.push(t)}return new nn(i,e)}sweepContoursRef(){return this._contours}cloneSweepContours(){const t=[];for(const e of this._contours)t.push(e.clone());return t}cloneContours(){const t=[];for(const e of this._contours)t.push(e.curves.clone());return t}clone(){return new nn(this.cloneSweepContours(),this.capped)}tryTransformInPlace(t){if(t.matrix.isSingular())return!1;for(const e of this._contours)e.tryTransformInPlace(t);return!0}cloneTransformed(t){const e=this.clone();return e.tryTransformInPlace(t),e}getConstructiveFrame(){if(0!==this._contours.length)return this._contours[0].localToWorld.cloneRigid()}isSameGeometryClass(t){return t instanceof nn}isAlmostEqual(t){if(t instanceof nn){if(this.capped!==t.capped)return!1;if(this._contours.length!==t._contours.length)return!1;for(let e=0;e<this._contours.length;e++)if(!this._contours[e].isAlmostEqual(t._contours[e]))return!1;return!0}return!1}dispatchToGeometryHandler(t){return t.handleRuledSweep(this)}constantVSection(t){const e=this._contours.length;if(e<2)return;const i=t*e;let s=0;s=t>=1?e-1:Math.floor(i),s+1>=e&&(s=e-2);const n=s+1,r=K.clampToStartEnd(i-s,0,1);return nn.mutatePartners(this._contours[s].curves,this._contours[n].curves,((t,e)=>{const i=ei.interpolateBetween(t,r,e);if(i instanceof ie)return i}))}extendRange(t,e){for(const i of this._contours)i.curves.extendRange(t,e)}static mutatePartners(t,e,i){if(t.isSameGeometryClass(e)){if(t instanceof We&&e instanceof We){const s=t,n=e,r=s.cloneEmptyPeer(),o=s.children,a=n.children;if(o.length!==a.length)return;for(let t=0;t<o.length;t++){const e=i(o[t],a[t]);if(!e)return;r.children.push(e)}return r}if(t instanceof qe&&e instanceof qe){const s=t.cloneEmptyPeer(),n=t.children,r=e.children,o=s.children;if(void 0===n||void 0===r||void 0===o||n.length!==r.length)return;for(let t=0;t<n.length;t++){const e=n[t],s=r[t];if(e instanceof ie&&s instanceof ie){const t=i(e,s);if(!t)return;o.push(t)}else if(e instanceof qe&&s instanceof qe){const t=this.mutatePartners(e,s,i);if(!t)return;t instanceof qe&&o.push(t)}}return s}}}get isClosedVolume(){const t=this._contours.length;return t>1&&(this.capped||this._contours[0].isAlmostEqual(this._contours[t-1]))}}class rn extends si{constructor(t,e,i,s,n){super(n),this.solidPrimitiveType="torusPipe",this._localToWorld=t,this._radiusA=e,this._radiusB=i,this._sweep=s,this._isReversed=!1}clone(){const t=new rn(this._localToWorld.clone(),this._radiusA,this._radiusB,this._sweep.clone(),this.capped);return t._isReversed=this._isReversed,t}tryTransformInPlace(t){return!t.matrix.isSingular()&&(t.multiplyTransformTransform(this._localToWorld,this._localToWorld),!0)}cloneTransformed(t){const e=this.clone();if(e.tryTransformInPlace(t))return e}static createInFrame(t,e,i,s,n){if((e=Math.abs(K.correctSmallMetricDistance(e)))<(i=Math.abs(K.correctSmallMetricDistance(i))))return;if(0===e)return;if(0===i)return;if(s.isAlmostZero)return;let r=1,o=1,a=!1;t.matrix.determinant()<0&&(o*=-1);const c=s.clone();s.radians<0&&(c.setRadians(-s.radians),o*=-1,r*=-1,a=!0);const h=t.clone();h.matrix.scaleColumnsInPlace(1,r,o);const l=new rn(h,e,i,c,n);return l._isReversed=a,l}static createDgnTorusPipe(t,e,i,s,n,r,o){const a=e.unitCrossProductWithDefault(i,0,0,1),c=pt.createOriginAndMatrixColumns(t,e,i,a);return rn.createInFrame(c,s,n,r,o)}static createAlongArc(t,e,i){W.isAlmostEqualRadiansAllowPeriodShift(0,t.sweep.startRadians)||(t=t.cloneInRotatedBasis(t.sweep.startAngle));const s=t.sweep.sweepRadians,n=t.toScaledMatrix3d(),r=pt.createOriginAndMatrix(n.center,n.axes);return rn.createInFrame(r,n.r0,e,W.createRadians(s),i)}getConstructiveFrame(){return this._localToWorld.cloneRigid()}cloneCenter(){return this._localToWorld.getOrigin()}cloneVectorX(){const t=this._localToWorld.matrix.columnX();return t.normalizeWithDefault(1,0,0,t)}cloneVectorY(){const t=this._localToWorld.matrix.columnY();return t.normalizeWithDefault(0,1,0,t)}cloneVectorZ(){const t=this._localToWorld.matrix.columnZ();return t.normalizeWithDefault(0,0,1,t)}getMajorRadius(){return this._radiusA*this._localToWorld.matrix.columnXMagnitude()}getMinorRadius(){return this._radiusB*this._localToWorld.matrix.columnZMagnitude()}getSweepAngle(){return this._sweep.clone()}getIsReversed(){return this._isReversed}getThetaFraction(){return this._sweep.radians/(2*Math.PI)}cloneLocalToWorld(){return this._localToWorld.clone()}isSameGeometryClass(t){return t instanceof rn}isAlmostEqual(t){return!!(t instanceof rn&&(this._sweep.isFullCircle||this.capped===t.capped)&&this.cloneCenter().isAlmostEqual(t.cloneCenter())&&this.cloneVectorX().isAlmostEqual(t.cloneVectorX())&&this.cloneVectorY().isAlmostEqual(t.cloneVectorY())&&this.cloneVectorZ().isAlmostEqual(t.cloneVectorZ())&&K.isSameCoordinate(this.getMinorRadius(),t.getMinorRadius())&&K.isSameCoordinate(this.getMajorRadius(),t.getMajorRadius())&&this.getSweepAngle().isAlmostEqualNoPeriodShift(t.getSweepAngle()))}vFractionToRadians(t){return this._sweep.radians*t}dispatchToGeometryHandler(t){return t.handleTorusPipe(this)}constantVSection(t){const e=this.vFractionToRadians(t),i=Math.cos(e),s=Math.sin(e),n=this._radiusA,r=this._radiusB,o=this._localToWorld.multiplyXYZ(n*i,n*s,0),a=this._localToWorld.multiplyVectorXYZ(r*i,r*s,0),c=this._localToWorld.multiplyVectorXYZ(0,0,r);return Ke.create(De.create(o,a,c))}constantUSection(t){const e=this._sweep.radians,i=2*t*Math.PI,s=this._radiusA,n=this._radiusB,r=this._localToWorld.matrix,o=this._localToWorld.multiplyXYZ(0,0,n*Math.sin(i)),a=s+n*Math.cos(i),c=r.multiplyXYZ(a,0,0),h=r.multiplyXYZ(0,a,0);return Fi.create(De.create(o,c,h,At.createStartEndRadians(0,e)))}extendRange(t,e){const i=this._sweep.radians,s=this._radiusA,n=this._radiusB,r=this._localToWorld,o=Math.ceil(i/(Math.PI/16));let a=0,c=0,h=0,l=0,d=0,u=0,f=0,g=0,p=0;const m=i/o;for(let i=0;i<=o;i++)if(l=i*m,d=Math.cos(l),u=Math.sin(l),0===i||i===o?(a=-Math.PI,c=2*Math.PI/16,h=16):(a=-.5*Math.PI,c=Math.PI/16,h=31),e)for(p=0;p<=h;p++)g=a+p*c,f=s+n*Math.cos(g),t.extendTransformTransformedXYZ(e,r,d*f,u*f,Math.sin(g)*n);else for(p=0;p<=h;p++)g=a+p*c,f=s+n*Math.cos(g),t.extendTransformedXYZ(r,d*f,u*f,Math.sin(g)*n)}uvFractionToPoint(t,e,i){const s=e*this._sweep.radians,n=t*Math.PI*2,r=Math.cos(s),o=Math.sin(s),a=this._radiusA,c=this._radiusB,h=a+Math.cos(n)*c;return this._localToWorld.multiplyXYZ(h*r,h*o,c*Math.sin(n),i)}uvFractionToPointAndTangents(t,e,i){const s=e*this._sweep.radians,n=t*Math.PI*2,r=this._sweep.radians,o=2*Math.PI,a=Math.cos(s),c=Math.sin(s),h=Math.sin(n),l=Math.cos(n),d=this._radiusA,u=this._radiusB,f=d+Math.cos(n)*u,g=u*h,p=u*l;return Et.createOriginAndVectors(this._localToWorld.multiplyXYZ(a*f,c*f,g),this._localToWorld.multiplyVectorXYZ(-a*g*o,-c*g*o,p*o),this._localToWorld.multiplyVectorXYZ(-f*c*r,f*a*r,0),i)}maxIsoParametricDistance(){const t=Math.abs(this.getMajorRadius()),e=Math.abs(this.getMinorRadius());return J.create(e*Math.PI*2,(t+e)*this._sweep.radians)}get isClosedVolume(){return this.capped||this._sweep.isFullCircle}}class on extends ie{get activeFractionInterval(){return this._activeFractionInterval}get localToWorld(){return this._localToWorld}constructor(t,e,i,s){super(),this._spiralType=t||"unknownSpiralType",this._designProperties=s,this._localToWorld=e,this._activeFractionInterval=i||ke.create(0,1)}get spiralType(){return this._spiralType}static radiusToCurvature(t){return 0===t?0:1/t}static curvatureToRadius(t){return Math.abs(t)<K.smallAngleRadians?0:1/t}clonePartialCurve(t,e){const i=this.clone(),s=this._activeFractionInterval.fractionToPoint(t),n=this._activeFractionInterval.fractionToPoint(e);return i._activeFractionInterval.set(s,n),i.refreshComputedProperties(),i}cloneTransformed(t){const e=this.clone();return e.tryTransformInPlace(t),e}static averageCurvature(t){return.5*(on.radiusToCurvature(t.x0)+on.radiusToCurvature(t.x1))}static averageCurvatureR0R1(t,e){return.5*(on.radiusToCurvature(t)+on.radiusToCurvature(e))}static interpolateCurvatureR0R1(t,e,i){return K.interpolate(on.radiusToCurvature(t),e,on.radiusToCurvature(i))}static radiusRadiusSweepRadiansToArcLength(t,e,i){return Math.abs(i/on.averageCurvatureR0R1(t,e))}static radiusRadiusLengthToSweepRadians(t,e,i){return on.averageCurvatureR0R1(t,e)*i}static radius0LengthSweepRadiansToRadius1(t,e,i){return on.curvatureToRadius(2*i/e-on.radiusToCurvature(t))}static radius1LengthSweepRadiansToRadius0(t,e,i){return on.curvatureToRadius(2*i/e-on.radiusToCurvature(t))}get designProperties(){return this._designProperties}applyRigidPartOfTransform(t){const e=t.matrix.factorRigidWithSignedScale();if(void 0!==e){const i=t.multiplyTransformTransform(this.localToWorld),s=e.rigidAxes.multiplyMatrixMatrix(this.localToWorld.matrix);return this._localToWorld=pt.createOriginAndMatrix(i.origin,s),this.designProperties&&this.designProperties.applyScaleFactor(e.scale),e}}constructOffsetXY(t){const e=ve.create(t),i=new ge(this,e.leftOffsetDistance);return this.emitStrokableParts(i,e.strokeOptions),i.claimResult()}extendRange(t,e){const i=this.rangeBetweenFractions(0,1,e);t.extendRange(i)}rangeBetweenFractions(t,e,i){const s=this.activeStrokes;if(void 0===s)return ut.createNull();let n=Math.ceil(s.numPoints()*Math.abs(e-t));return n=K.clamp(5,n,30),this.rangeBetweenFractionsByCount(t,e,n,i,.5)}projectedParameterRange(t,e){return Te.findExtremeFractionsAlongDirection(this,t,e)}}class an{constructor(){}static findEvaluator(t){return"clothoid"===t?this._clothoidEvaluator?this._clothoidEvaluator:this._clothoidEvaluator=new cn:"bloss"===t?this._blossEvaluator?this._blossEvaluator:this._blossEvaluator=new hn:"biquadratic"===t?this._biquadraticEvaluator?this._biquadraticEvaluator:this._biquadraticEvaluator=new ln:"sine"===t?this._sineEvaluator?this._sineEvaluator:this._sineEvaluator=new dn:"cosine"===t?this._cosineEvaluator?this._cosineEvaluator:this._cosineEvaluator=new un:void 0}}class cn extends an{constructor(){super()}fractionToCurvatureFraction(t){return t}fractionToCurvatureFractionDerivative(t){return 1}fractionToArea(t){return t*t*.5}}class hn extends an{constructor(){super()}fractionToCurvatureFraction(t){return t*t*(3-2*t)}fractionToCurvatureFractionDerivative(t){return 6*t*(1-t)}fractionToArea(t){return t*t*t*(1-.5*t)}}class ln extends an{constructor(){super()}integratedBasis(t){return t*t*t*(2/3)}basis(t){return 2*t*t}basisDerivative(t){return 4*t}fractionToCurvatureFraction(t){return t<=.5?this.basis(t):1-this.basis(1-t)}fractionToCurvatureFractionDerivative(t){return t<.5?this.basisDerivative(t):this.basisDerivative(1-t)}fractionToArea(t){if(t<=.5)return this.integratedBasis(t);const e=1-t;return.5-e+this.integratedBasis(e)}}class dn extends an{constructor(){super()}fractionToCurvatureFraction(t){const e=2*Math.PI;return t-Math.sin(t*e)/e}fractionToCurvatureFractionDerivative(t){const e=2*Math.PI;return 1-Math.cos(t*e)}fractionToArea(t){const e=2*Math.PI;return.5*t*t+(Math.cos(t*e)-1)/(e*e)}}class un extends an{constructor(){super()}fractionToCurvatureFraction(t){const e=Math.PI;return.5*(1-Math.cos(t*e))}fractionToCurvatureFractionDerivative(t){const e=Math.PI;return.5*e*Math.sin(t*e)}fractionToArea(t){const e=Math.PI;return.5*t-.5*Math.sin(t*e)/e}}class fn{constructor(t,e,i,s,n){this.radius0=t,this.radius1=e,this.bearing0=i,this.bearing1=s,this.curveLength=n}numDefinedProperties(){return K.defined01(this.radius0)+K.defined01(this.radius1)+K.defined01(this.bearing0)+K.defined01(this.bearing1)+K.defined01(this.curveLength)}clone(){return new fn(this.radius0,this.radius1,void 0===this.bearing0?void 0:this.bearing0.clone(),void 0===this.bearing1?void 0:this.bearing1.clone(),this.curveLength)}getIsValidCompleteSet(){if(void 0!==this.curveLength&&void 0!==this.bearing0&&void 0!==this.bearing1&&void 0!==this.radius0&&void 0!==this.radius1){const t=on.radiusRadiusSweepRadiansToArcLength(this.radius0,this.radius1,this.bearing1.radians-this.bearing0.radians);return K.isSameCoordinate(this.curveLength,t)}return!1}tryResolveAnySingleUnknown(){if(this.getIsValidCompleteSet())return!0;if(this.bearing0&&this.bearing1){const t=this.bearing1.radians-this.bearing0.radians;return void 0===this.curveLength&&void 0!==this.radius0&&void 0!==this.radius1?(this.curveLength=on.radiusRadiusSweepRadiansToArcLength(this.radius0,this.radius1,t),!0):void 0!==this.curveLength&&void 0===this.radius0&&void 0!==this.radius1?(this.radius0=on.radius1LengthSweepRadiansToRadius0(this.radius1,this.curveLength,t),!0):void 0!==this.curveLength&&void 0!==this.radius0&&void 0===this.radius1&&(this.radius1=on.radius0LengthSweepRadiansToRadius1(this.radius0,this.curveLength,t),!0)}return void 0!==this.curveLength&&void 0!==this.radius0&&void 0!==this.radius1&&(this.bearing0?(this.bearing1=W.createRadians(this.bearing0.radians+on.radiusRadiusLengthToSweepRadians(this.radius0,this.radius1,this.curveLength)),!0):!!this.bearing1&&(this.bearing0=W.createRadians(this.bearing1.radians-on.radiusRadiusLengthToSweepRadians(this.radius0,this.radius1,this.curveLength)),!0))}almostEqualCoordinate(t,e){return void 0===t&&void 0===e||void 0!==t&&void 0!==e&&K.isSameCoordinate(t,e)}almostEqualBearing(t,e){return void 0===t&&void 0===e||void 0!==t&&void 0!==e&&t.isAlmostEqualNoPeriodShift(e)}isAlmostEqual(t){return!!(t&&this.almostEqualCoordinate(this.radius0,t.radius0)&&this.almostEqualCoordinate(this.radius1,t.radius1)&&this.almostEqualBearing(this.bearing0,t.bearing0)&&this.almostEqualBearing(this.bearing1,t.bearing1)&&this.almostEqualCoordinate(this.curveLength,t.curveLength))}applyScaleFactor(t){void 0!==this.radius0&&(this.radius0*=t),void 0!==this.radius1&&(this.radius1*=t),void 0!==this.curveLength&&(this.curveLength*=t)}static areAlmostEqual(t,e){return void 0===t?void 0===e:t.isAlmostEqual(e)}}class gn extends on{get activeStrokes(){return void 0!==this._activeStrokes?this._activeStrokes:this._globalStrokes}constructor(t,e,i,s,n,r,o,a){super(t,r,n,a),this.curvePrimitiveType="transitionSpiral",this._evaluator=e,this.radius01=i,this.bearing01=s,this._arcLength01=o,this._globalStrokes=we.create(),this._curvature01=ke.create(0,1),this.refreshComputedProperties()}globalFractionToBearingRadians(t){const e=this._evaluator.fractionToArea(t),i=this._arcLength01;return this.bearing01.startRadians+e*i*this._curvature01.signedDelta()+t*this._curvature01.x0*i}globalFractionToCurvature(t){const e=this._evaluator.fractionToCurvatureFraction(t);return this._curvature01.fractionToPoint(e)}fractionToBearingRadians(t){const e=this.activeFractionInterval.fractionToPoint(t);return this.bearing01.startRadians+e*this._arcLength01*(this._curvature01.x0+.5*e*(this._curvature01.x1-this._curvature01.x0))}fractionToCurvature(t){return this._curvature01.fractionToPoint(this.activeFractionInterval.fractionToPoint(t))}static initWorkSpace(){gn._gaussFraction=new Float64Array(5),gn._gaussWeight=new Float64Array(5),gn._gaussMapper=(t,e,i,s)=>$t.setupGauss5(t,e,i,s)}fullSpiralIncrementalIntegral(t,e,i,s){const n=gn._gaussFraction,r=gn._gaussWeight,o=gn._gaussMapper(e,i,n,r),a=this._arcLength01;let c=0,h=0,l=0;for(let t=0;t<o;t++){const e=this.globalFractionToBearingRadians(n[t]);c=r[t]*a,h+=c*Math.cos(e),l+=c*Math.sin(e)}s?xt.xyzPlusMatrixTimesXYZ(t,this.localToWorld.matrix,{x:h,y:l,z:0},t):t.addXYZInPlace(h,l,0)}refreshComputedProperties(){this._curvature01=ke.create(on.radiusToCurvature(this.radius01.x0),on.radiusToCurvature(this.radius01.x1)),this._globalStrokes.clear();const t=Q.create();this._globalStrokes.appendStrokePoint(t);const e=1/16;for(let i=1;i<=16;i++){const s=(i-1)*e,n=i*e;this.fullSpiralIncrementalIntegral(t,s,n,!1),this._globalStrokes.appendStrokePoint(t)}if(this._globalStrokes.tryTransformInPlace(this.localToWorld),!this.activeFractionInterval.isExact01){void 0===this._activeStrokes&&(this._activeStrokes=we.create()),this._activeStrokes.clear();for(let t=0;t<=16;t++){const i=t*e;this._activeStrokes.addPoint(this.fractionToPoint(i))}}}static createRadiusRadiusBearingBearing(t,e,i,s,n){const r=on.radiusRadiusSweepRadiansToArcLength(t.x0,t.x1,e.sweepRadians);void 0===n&&(n="clothoid");const o=an.findEvaluator(n);if(o)return new gn(n,o,t.clone(),e.clone(),i.clone(),s.clone(),r,new fn(t.x0,t.x1,e.startAngle.clone(),e.endAngle.clone(),void 0))}static createFrom4OutOf5(t,e,i,s,n,r,o,a){void 0===t&&(t="clothoid");const c=an.findEvaluator(t);if(!c)return;const h=new fn(e,i,s,n,r),l=h.clone();return h.tryResolveAnySingleUnknown()?(void 0===o&&(o=ke.create(0,1)),new gn(t,c,ke.create(h.radius0,h.radius1),At.createStartEnd(h.bearing0,h.bearing1),o?o.clone():ke.create(0,1),a,h.curveLength,l)):void 0}setFrom(t){return this.localToWorld.setFrom(t.localToWorld),this.radius01.setFrom(t.radius01),this._curvature01.setFrom(t._curvature01),this.bearing01.setFrom(t.bearing01),this.localToWorld.setFrom(t.localToWorld),this.activeFractionInterval.setFrom(t.activeFractionInterval),this._arcLength01=t._arcLength01,this}clone(){return new gn(this._spiralType,this._evaluator,this.radius01.clone(),this.bearing01.clone(),this.activeFractionInterval.clone(),this.localToWorld.clone(),this._arcLength01,this._designProperties?.clone())}tryTransformInPlace(t){const e=this.applyRigidPartOfTransform(t);return void 0!==e&&(this._curvature01.x0/=e.scale,this._curvature01.x1/=e.scale,this.radius01.x0*=e.scale,this.radius01.x1*=e.scale,this._arcLength01*=e.scale),this.refreshComputedProperties(),!0}startPoint(){return this.activeStrokes.startPoint()}endPoint(){return this.activeStrokes.endPoint()}isInPlane(t){return t.isPointInPlane(this.localToWorld.origin)&&K.isSameCoordinate(0,this.localToWorld.matrix.dotColumnX(t.getNormalRef()))&&K.isSameCoordinate(0,this.localToWorld.matrix.dotColumnY(t.getNormalRef()))}quickLength(){return this.curveLength()}curveLength(){return this._arcLength01*this._activeFractionInterval.absoluteDelta()}curveLengthBetweenFractions(t,e){return this._arcLength01*(this._activeFractionInterval.absoluteDelta()*Math.abs(e-t))}isSameGeometryClass(t){return t instanceof on}emitStrokes(t,e){this.activeStrokes.emitStrokes(t,e)}emitStrokableParts(t,e){const i=this.computeStrokeCountForOptions(e);t.startParentCurvePrimitive(this);const s=this.activeStrokes;(void 0===t.needPrimaryGeometryForStrokes||!t.needPrimaryGeometryForStrokes())&&i<=s.numPoints()?this.activeStrokes.emitStrokableParts(t,e):t.announceIntervalForUniformStepStrokes(this,i,0,1),t.endParentCurvePrimitive(this)}computeStrokeCountForOptions(t){let e;if(t){const i=Math.min(Math.abs(this.radius01.x0),Math.abs(this.radius01.x1));e=t.applyTolerancesToArc(i,this.bearing01.sweepRadians),e=t.applyMaxEdgeLength(e,this.curveLength()),e=t.applyMinStrokesPerPrimitive(e)}else e=ye.applyAngleTol(void 0,4,this.bearing01.sweepRadians);return e}reverseInPlace(){this.activeFractionInterval.reverseInPlace(),void 0===this._activeStrokes&&(this._activeStrokes=this._globalStrokes.clone()),this._activeStrokes.reverseInPlace()}fractionToPoint(t,e){const i=this.activeFractionInterval.fractionToPoint(t),s=this._globalStrokes.packedPoints.length-1;if(t>1){e=this._globalStrokes.packedPoints.back(e);const t=1/s;let n=1,r=n+t;for(;r<i;)this.fullSpiralIncrementalIntegral(e,n,r,!0),n=r,r+=t;this.fullSpiralIncrementalIntegral(e,n,i,!0)}else if(t<0){e=this._globalStrokes.packedPoints.front(e);const t=1/s;let n=0,r=n-t;for(;r>i;)this.fullSpiralIncrementalIntegral(e,n,r,!0),n=r,r-=t;this.fullSpiralIncrementalIntegral(e,n,i,!0)}else{const t=K.clampToStartEnd(i,0,1),n=Math.trunc(t*s),r=n/s;e=this._globalStrokes.packedPoints.getPoint3dAtUncheckedPointIndex(n,e),this.fullSpiralIncrementalIntegral(e,r,i,!0)}return e}fractionToPointAndDerivative(t,e){const i=this.activeFractionInterval.fractionToPoint(t);e=e||bt.createZero(),this.fractionToPoint(t,e.origin);const s=this.globalFractionToBearingRadians(i),n=this._arcLength01*this.activeFractionInterval.signedDelta();return this.localToWorld.matrix.multiplyXY(n*Math.cos(s),n*Math.sin(s),e.direction),e}fractionToFrenetFrame(t,e){const i=this.activeFractionInterval.fractionToPoint(t);(e=e||pt.createIdentity()).origin.setFrom(this.fractionToPoint(t)),xt.createRigidFromMatrix3d(this.localToWorld.matrix,p.XYZ,e.matrix);const s=this.globalFractionToBearingRadians(i),n=Math.cos(s),r=Math.sin(s);return e.matrix.applyGivensColumnOp(0,1,n,r),e}fractionToPointAnd2Derivatives(t,e){const i=this.activeFractionInterval.fractionToPoint(t),s=this.fractionToPoint(t),n=this.globalFractionToBearingRadians(i),r=Math.cos(n),o=Math.sin(n),a=this.activeFractionInterval.signedDelta(),c=a,h=c*a,l=this.localToWorld.matrix.multiplyXY(c*r,c*o),d=this.localToWorld.matrix.multiplyXY(-h*o,h*r);return d.scaleInPlace(this.globalFractionToCurvature(i)),Et.createCapture(s,l,d,e)}dispatchToGeometryHandler(t){return t.handleTransitionSpiral(this)}isAlmostEqual(t){return t instanceof gn&&this.radius01.isAlmostEqual(t.radius01)&&this.bearing01.isAlmostEqualAllowPeriodShift(t.bearing01)&&this.localToWorld.isAlmostEqual(t.localToWorld)&&K.isSameCoordinate(this._arcLength01,t._arcLength01)&&this.activeFractionInterval.isAlmostEqual(t.activeFractionInterval)&&this._curvature01.isAlmostEqual(t._curvature01)}}gn.defaultSpiralType="clothoid",gn.initWorkSpace(),function(t){t[t.Sections=0]="Sections",t[t.AlsoRuledSweep=1]="AlsoRuledSweep",t[t.AlsoMesh=2]="AlsoMesh"}(O||(O={}));class pn{static addPartialSegment(t,e,i,s,n,r){(e||r>n)&&(void 0===i||void 0===s||K.isAlmostEqualNumber(n,r)||t.tryAddChild(Pe.create(i.interpolate(n,s),i.interpolate(r,s))))}static createArcPointTangentPoint(t,e,i){const s=$.createStartEnd(t,i),n=xt.createRigidFromColumns(e,s,p.XYZ);if(void 0!==n){const i=s.dotProduct(s),r=n.dotColumnY(s),o=K.conditionalDivideCoordinate(i,2*r);if(void 0!==o){const i=n.columnY();i.scaleInPlace(-o);const r=n.columnX();r.scaleInPlace(o);const a=i.plus(s);let c=i.angleTo(a).radians;e.dotProduct(a)<0&&(c=2*Math.PI-c);const h=t.plusScaled(i,-1);return De.create(h,i,r,At.createStartEndRadians(0,c))}}}static createFilletsInLineString(t,e,i=!0){if(Array.isArray(t))return this.createFilletsInLineString(new se(t),e,i);if(t instanceof we)return this.createFilletsInLineString(t.packedPoints,e,i);const s=t.length;if(s<=1)return;const n=t.getPoint3dAtCheckedPointIndex(0),r=t.getPoint3dAtCheckedPointIndex(1),o=[];o.push({fraction10:0,fraction12:0,point:n.clone()});for(let i=1;i+1<s;i++){const s=t.getPoint3dAtCheckedPointIndex(i+1);let a=0;Array.isArray(e)?i<e.length&&(a=e[i]):Number.isFinite(e)&&(a=e),0!==a?o.push(De.createFilletArc(n,r,s,a)):o.push({fraction10:0,fraction12:0,point:r.clone()}),n.setFromPoint3d(r),r.setFromPoint3d(s)}if(o.push({fraction10:0,fraction12:0,point:r.clone()}),!i)for(let t=1;t+1<s;t++){const e=o[t];(e.fraction10>1||e.fraction12>1||1-e.fraction10<o[t-1].fraction12||e.fraction12>1-o[t+1].fraction10)&&(e.fraction10=0,e.fraction12=0,o[t].arc=void 0)}const a=Fi.create();this.addPartialSegment(a,i,o[0].point,o[1].point,o[0].fraction12,1-o[1].fraction10);for(let e=1;e+1<t.length;e++){const t=o[e],s=o[e+1];a.tryAddChild(t.arc),this.addPartialSegment(a,i,t.point,s.point,t.fraction12,1-s.fraction10)}return a}static createRectangleXY(t,e,i,s,n=0,r){let o=K.correctSmallMetricDistance(r);const a=Math.min(t,i),c=Math.max(t,i),h=Math.min(e,s),l=Math.max(e,s);if(o=Math.min(Math.abs(o),.5*(c-a),.5*(l-h)),0===o)return Ke.createPolygon([Q.create(a,h,n),Q.create(c,h,n),Q.create(c,l,n),Q.create(a,l,n),Q.create(a,h,n)]);{const t=$.create(o,0,0),e=$.create(0,o,0),i=a+o,s=h+o,r=c-o,d=l-o,u=[Q.create(r,d,n),Q.create(i,d,n),Q.create(i,s,n),Q.create(r,s,n)],f=Ke.create();for(let i=0;i<4;i++){const s=u[i],n=u[(i+1)%4],r=$.createStartEnd(s,n),o=De.create(s,t,e,At.createStartEndDegrees(0,90));f.tryAddChild(o);const a=o.endPoint();r.isAlmostZero||f.tryAddChild(Pe.create(a,a.plus(r))),t.rotate90CCWXY(t),e.rotate90CCWXY(e)}return f}}static appendToArcInPlace(t,e,i=!1){if(t.center.isAlmostEqual(e.center)){const s=K.split3WaySign(t.sweep.sweepRadians*e.sweep.sweepRadians,-1,0,1),n=t.angleToPointAndDerivative(t.sweep.fractionToAngle(1));t.sweep.sweepRadians<0&&n.direction.scaleInPlace(-1);const r=e.angleToPointAndDerivative(e.sweep.fractionToAngle(0));if(e.sweep.sweepRadians<0&&r.direction.scaleInPlace(-1),n.isAlmostEqual(r))return t.sweep.setStartEndRadians(t.sweep.startRadians,t.sweep.startRadians+t.sweep.sweepRadians+s*e.sweep.sweepRadians),!0;if(i&&(r.direction.scaleInPlace(-1),n.isAlmostEqual(r)))return t.sweep.setStartEndRadians(t.sweep.startRadians,t.sweep.startRadians+t.sweep.sweepRadians-s*e.sweep.sweepRadians),!0}return!1}static assembleArcChainOnEllipsoid(t,e,i=.5){const s=Fi.create();for(let n=0;n+1<e.length;n++){const r=t.sectionArcWithIntermediateNormal(e[n].toAngles(),i,e[n+1].toAngles());s.tryAddChild(r)}return s}static appendGeometryQueryArray(t,e){if(t instanceof Nt)e.push(t);else if(Array.isArray(t))for(const i of t)this.appendGeometryQueryArray(i,e)}static createPipeSegments(t,e){if(t instanceof Pe)return ni.createAxisPoints(t.startPoint(),t.endPoint(),e,e,!1);if(t instanceof De)return rn.createAlongArc(t,e,!1);if(t instanceof ie){const i=Rn.create();return i.addMiteredPipes(t,e),i.claimPolyface()}if(t instanceof We){const i=[];for(const s of t.children){const t=this.createPipeSegments(s,e);this.appendGeometryQueryArray(t,i)}return i}}static createMiteredPipeSections(t,e){const i=[];if(t.length<2)return[];const s=$.create(),n=$.create(),r=$.create(),o=Q.create();let a;if(t.vectorIndexIndex(0,1,r),t.getPoint3dAtUncheckedPointIndex(0,o),e instanceof De)a=e.clone(),a.center.setFrom(o),s.setFrom(e.vector0),n.setFrom(e.vector90);else{if("number"!=typeof e&&!Q.isXAndY(e))return[];{const t="number"==typeof e?e:e.x,i="number"==typeof e?e:e.y,c=xt.createRigidHeadsUp(r,p.ZXY);c.columnX(s).scaleInPlace(t),c.columnY(n).scaleInPlace(i),a=De.create(o,s,n,At.create360())}}i.push(a);const c=$.create(),h=$.create();for(let e=1;e<t.length;e++)c.setFromVector3d(r),t.getPoint3dAtUncheckedPointIndex(e,o),e+1<t.length?t.vectorIndexIndex(e,e+1,r):r.setFromVector3d(c),c.normalizeInPlace()&&r.normalizeInPlace()&&(c.interpolate(.5,r,h),mn(s,c,h,s),mn(n,c,h,n),i.push(De.create(o,s,n,At.create360())));return i}static createMiteredSweepSections(t,e,i){const s={sections:[],planes:[]},n=ii.createBisectorPlanesForDistinctPoints(t,i.wrapIfPhysicallyClosed);if(void 0!==n&&n.length>1){const t=function(t,e,i,n){const r=$.createStartEnd(t.getOriginRef(),e.getOriginRef()),o=pt.createFlattenAlongVectorToPlane(r,i.getOriginRef(),i.getNormalRef());if(void 0===o)return n;const a=n.cloneTransformed(o);return void 0===a?n:(s.planes.push(i),s.sections.push(a),a)};let r=t(n[0],n[1],n[0],e);for(let e=1;e<n.length;e++)r=t(n[e-1],n[e],n[e],r);if(i.outputSelect){const t=nn.create(s.sections,i.capped??!1);if(t&&(s.ruledSweep=t,O.AlsoMesh===i.outputSelect)){const e=Rn.create(i.strokeOptions);e.addRuledSweep(t),s.mesh=e.claimPolyface()}}return s}}static createArcPointTangentRadius(t,e,i,s,n){void 0===s&&(s=$.unitZ());const r=s.unitCrossProduct(e);if(void 0===r)return;const o=t.plusScaled(r,i);r.scaleInPlace(-i);const a=e.scaleToLength(Math.abs(i));return De.create(o,r,a,At.create(n))}static createLineSpiralSpiralLine(t,e,i,s){const n=$.createStartEnd(e,i),r=$.createStartEnd(i,s),o=n.magnitude(),a=Math.atan2(n.y,n.x),c=n.angleToXY(r),h=.5*c.radians,l=a+c.radians,d=xt.createRotationAroundAxisIndex(m.Z,W.createRadians(a)),u=pt.createRefs(e.clone(),d),f=gn.createFrom4OutOf5(t,0,void 0,W.createRadians(0),W.createRadians(h),o,void 0,u);if(f){const r=a+h,c=$.createPolar(1,W.createRadians(r)),d=c.dotProductStartEnd(e,i)/c.dotProductStartEnd(e,f.endPoint()),g=gn.createFrom4OutOf5(t,0,void 0,W.createRadians(0),W.createRadians(h),o*d,void 0,u),p=n.magnitude(),x=$.createStartEnd(i,s);x.scaleToLength(p,x);const y=i.plus(x),_=xt.createRotationAroundAxisIndex(m.Z,W.createRadians(l+Math.PI)),v=pt.createRefs(y,_),P=gn.createFrom4OutOf5(t,0,-g.radius01.x1,W.zero(),void 0,g.curveLength(),ke.create(1,0),v);return[g,P]}}static createLineSpiralSpiralLineWithSpiralLength(t,e,i,s,n){const r=$.createStartEnd(e,i),o=$.createStartEnd(i,s),a=Math.atan2(r.y,r.x),c=r.angleToXY(o),h=.5*c.radians,l=.5*(Math.PI-c.radians),d=Math.atan2(-o.y,-o.x),u=gn.createFrom4OutOf5(t,0,void 0,W.zero(),W.createRadians(h),n,void 0,pt.createIdentity());if(u){const r=u.fractionToPoint(1),o=e.distance(i),c=s.distance(i),f=r.y/Math.tan(l),g=K.conditionalDivideFraction(o-f-r.x,o),p=K.conditionalDivideFraction(c-f-r.x,c);if(void 0!==g&&void 0!==p){const r=xt.createRotationAroundAxisIndex(m.Z,W.createRadians(a)),o=e.interpolate(g,i),c=pt.createRefs(o,r),l=gn.createFrom4OutOf5(t,0,void 0,W.zero(),W.createRadians(h),n,void 0,c),u=xt.createRotationAroundAxisIndex(m.Z,W.createRadians(d)),f=s.interpolate(p,i),x=pt.createRefs(f,u);return[l,gn.createFrom4OutOf5(t,0,void 0,W.zero(),W.createRadians(-h),n,void 0,x)]}}}static createLineSpiralArcSpiralLine(t,e,i,s,n,r,o){const a=$.createStartEnd(e,i);a.z=0;const c=$.createStartEnd(s,i);c.z=0;const h=a.normalize(),l=c.normalize();if(void 0===h||void 0===l)return;const d=h.unitPerpendicularXY(),u=l.unitPerpendicularXY(),f=a.angleToXY(c),g=K.split3WaySign(f.radians,1,-1,-1),p=-g,m=g*Math.abs(o),x=p*Math.abs(o),y=gn.createFrom4OutOf5(t,0,m,W.zero(),void 0,n,void 0,pt.createIdentity()),_=gn.createFrom4OutOf5(t,0,x,W.zero(),void 0,r,void 0,pt.createIdentity()),v=y.fractionToPointAndUnitTangent(1),P=_.fractionToPointAndUnitTangent(1),I=v.origin.x-m*v.direction.y,A=v.origin.y+m*v.direction.x,S=P.origin.x-x*P.direction.y,w=P.origin.y+x*P.direction.x,C=$.createAdd2Scaled(h,I,d,A),T=$.createAdd2Scaled(l,S,u,w),k=J.create();if(Ft.linearSystem2d(h.x,-l.x,h.y,-l.y,T.x-C.x,T.y-C.y,k)){const t=i.plusScaled(h,k.x),e=i.plusScaled(l,k.y),s=pt.createOriginAndMatrixColumns(t,h,d,$.unitZ()),n=pt.createOriginAndMatrixColumns(e,l,u,$.unitZ());y.tryTransformInPlace(s),_.tryTransformInPlace(n);const r=y.fractionToPointAndUnitTangent(1),o=_.fractionToPointAndUnitTangent(1);o.direction.scaleInPlace(-1);const a=r.direction.angleToXY(o.direction);return m<0&&a.setRadians(-a.radians),[y,pn.createArcPointTangentRadius(r.origin,r.direction,m,void 0,a),_]}}static planePlaneIntersectionRay(t,e){const i=t.altitudeXYZ(0,0,0),s=e.altitudeXYZ(0,0,0),n=t.normalX(),r=t.normalY(),o=t.normalZ(),a=e.normalX(),c=e.normalY(),h=e.normalZ(),l=K.crossProductXYXY(r,o,c,h),d=K.crossProductXYXY(o,n,h,a),u=K.crossProductXYXY(n,r,a,c),f=Ft.linearSystem3d(n,r,o,a,c,h,l,d,u,-i,-s,0);if(void 0!==f)return bt.createXYZUVW(f.x,f.y,f.z,l,d,u)}}function mn(t,e,i,s){const n=t.dotProduct(i),r=e.dotProduct(i),o=K.safeDivideFraction(n,r,0);return t.plusScaled(e,-o,s)}class xn extends xe{constructor(t){super(),this._localPoint=Q.create(),this._worldPoint=Q.create(),this._perpVector=$.createZero(),this._maxDistance=0,this._localToWorld=t.toRigidZFrame()}announcePoint(t){this._localToWorld.multiplyInversePoint3d(t,this._localPoint);const e=this._localPoint.magnitudeXY();e>=this._maxDistance&&(this._maxDistance=e,this._perpVector.setFromPoint3d(this._localPoint),this._perpVector.z=0,this._localToWorld.matrix.multiplyXY(this._localPoint.x,this._localPoint.y,this._perpVector))}handleLineSegment3d(t){this.announcePoint(t.startPoint(this._worldPoint)),this.announcePoint(t.endPoint(this._worldPoint))}handleLineString3d(t){for(let e=0;e<t.numPoints();e++)t.pointAt(e,this._worldPoint),this.announcePoint(this._worldPoint)}handleArc3d(t){const e=ye.applyAngleTol(void 0,3,t.sweep.sweepRadians,.1),i=1/e;for(let s=0;s<=e;s++)t.fractionToPoint(s*i,this._worldPoint),this.announcePoint(this._worldPoint)}static computeMaxVectorFromRay(t,e){const i=new xn(t);return e.dispatchToGeometryHandler(i),i._perpVector.clone()}static buildRotationalNormalsInLineStrings(t,e,i){if(t instanceof we){const s=t.packedPoints,n=t.packedDerivatives,r=t.ensureEmptySurfaceNormals();if(n&&r){const n=$.create(),o=$.create(),a=Q.create(),c=s.length;for(let h=0;h<c;h++)s.getPoint3dAtUncheckedPointIndex(h,a),e.perpendicularPartOfVectorToTarget(a,n),n.isAlmostZero?e.direction.crossProduct(i,o):e.direction.crossProduct(n,o),t.packedDerivatives.getVector3dAtCheckedVectorIndex(h,n),n.crossProduct(o,o),o.normalizeInPlace(),r.push(o)}}else if(t.children){const s=t.children;for(const t of s)this.buildRotationalNormalsInLineStrings(t,e,i)}}}class yn{startSweeps(t,e,i){return!0}endSweeps(t,e,i){return!0}}class _n extends yn{constructor(){super(),this.myMap=Yt.createWithComponentIndex()}startPass(t){return 0===t?(this.myMap.numStroke=0,!0):1===t}visit(t,e){return 0===t?(e.numStroke>this.myMap.numStroke&&(this.myMap.numStroke=e.numStroke),!0):1===t&&(e.numStroke=this.myMap.numStroke,!0)}endPass(t){return!0}}class vn extends yn{constructor(){super(),this.maxCurveLength=0}startPass(t){return 0===t?(this.maxCurveLength=0,!0):1===t}visit(t,e){return 0===t?(this.maxCurveLength=K.maxXY(e.curveLength,this.maxCurveLength),!0):1===t&&(e.a0=0,e.a1=this.maxCurveLength,!0)}endPass(t){return!0}}class Pn{constructor(t,e){this.parent=t,this.maps=[],this.options=e}static createForCurveChain(t,e){const i=new Pn(t,e);i.parent=t;for(const s of t.children)s.computeAndAttachRecursiveStrokeCounts(e),s.strokeData&&i.maps.push(s.strokeData);return i}getStrokes(){const t=we.create();this.options&&(this.options.needNormals||this.options.needParams)&&(t.ensureEmptyFractions(),t.ensureEmptyDerivatives(),t.ensureEmptyUVParams());for(const e of this.maps)e.primitive&&e.primitive.addMappedStrokesToLineString3D(e,t);return t}static applySummed01LimitsWithinArray(t,e){let i=e;for(const e of t)e.a0+=i,e.componentData?e.a1=this.applySummed01LimitsWithinArray(e.componentData,e.a0):e.a1+=i,i=e.a1;return i}applySummed01Limits(t){return Pn.applySummed01LimitsWithinArray(this.maps,t)}}class In{constructor(t){this.parent=t,this.chains=[]}static createForParityRegionOrChain(t,e){const i=new In(t);if(t instanceof Qe)for(const s of t.children){const t=Pn.createForCurveChain(s,e);i.chains.push(t)}else t instanceof We&&i.chains.push(Pn.createForCurveChain(t,e));return i}static areSectionsCompatible(t,e){if(t.length<2)return!0;const i=t[0].chains.length;for(let s=1;s<t.length;s++){if(t[s].chains.length!==i)return!1;for(let i=0;i<t[0].chains.length;i++){const n=t[0].chains[i].maps.length;if(t[s].chains[i].maps.length!==n)return!1;for(let r=0;r<n;r++)if(!t[0].chains[i].maps[r].isCompatibleComponentStructure(t[s].chains[i].maps[r],e))return!1}}return!0}static remapa0a1WithinEachChain(t){for(const e of t)for(const t of e.chains)t.applySummed01Limits(0)}static applyMultipassVisitorCallbackNoComponents(t,e,i,s,n){const r=t.length;if(!n.startSweeps(e,i,s))return!1;if(void 0===s)for(let s=0;n.startPass(s);s++){for(let o=0;o<r;o++)if(!n.visit(s,t[o].chains[e].maps[i]))return!1;if(!n.endPass(s))return!1}else for(let o=0;n.startPass(o);o++){for(let a=0;a<r;a++)if(!n.visit(o,t[a].chains[e].maps[i].componentData[s]))return!1;if(!n.endPass(o))return!1}return!!n.endSweeps(e,i,s)}static runMultiPassVisitorAtCorrespondingPrimitives(t,e){const i=t[0].chains.length;for(let s=0;s<i;s++){const i=t[0].chains[s].maps.length;for(let n=0;n<i;n++)if(t[0].chains[s].maps[n].componentData){const i=t[0].chains[s].maps[n].componentData.length;for(let r=0;r<i;r++)if(!this.applyMultipassVisitorCallbackNoComponents(t,s,n,r,e))return!1}else if(!this.applyMultipassVisitorCallbackNoComponents(t,s,n,void 0,e))return!1}return!0}static enforceStrokeCountCompatibility(t){if(t.length<2)return!0;if(!In.areSectionsCompatible(t,!1))return!1;const e=new _n;return this.runMultiPassVisitorAtCorrespondingPrimitives(t,e),!0}static enforceCompatibleDistanceSums(t){if(t.length<2)return!0;if(!In.areSectionsCompatible(t,!1))return!1;const e=new vn;return this.runMultiPassVisitorAtCorrespondingPrimitives(t,e),this.remapa0a1WithinEachChain(t),!0}getStrokes(){if(1===this.chains.length)return this.chains[0].getStrokes();{const t=Qe.create();for(const e of this.chains){const i=e.getStrokes();i instanceof we&&t.tryAddChild(Ke.create(i))}return t}}static extendDistanceRangeBetweenStrokes(t,e,i){if(t instanceof we){if(e instanceof we&&t.numPoints()===e.numPoints()){const s=t.numPoints(),n=Q.create(),r=Q.create(),o=t.packedPoints,a=e.packedPoints;for(let t=0;t<s;t++)o.getPoint3dAtCheckedPointIndex(t,n),a.getPoint3dAtCheckedPointIndex(t,r),i.extendX(n.distance(r));return!0}}else if(t instanceof Qe){if(e instanceof Qe){const s=t.children,n=e.children,r=s.length;if(r===n.length){for(let t=0;t<r;t++)if(!this.extendDistanceRangeBetweenStrokes(s[t],n[t],i))return!1;return!0}}}else if(t instanceof We&&e instanceof We){const s=t.children,n=e.children,r=s.length;if(r===n.length){for(let t=0;t<r;t++)if(!this.extendDistanceRangeBetweenStrokes(s[t],n[t],i))return!1;return!0}}return!1}}class An{constructor(t,e,i){this.surface=t,this.point=i||Q.createZero(),this.uv=e||H.createZero(),this.a=0}static createSurfaceUVPoint(t,e,i){const s=new An(t);return e&&s.uv.setFrom(e),s.point.setFromPoint3d(i),s}static createSurfaceUVNumbersPoint(t,e,i,s){const n=new An(t);return n.uv.x=e,n.uv.y=i,n.point.setFromPoint3d(s),n}}class Sn{constructor(t,e){this.curveDetail=t,this.surfaceDetail=e}}class wn{constructor(t,e,i,s){this.point00=t,this.point10=e,this.point01=i,this.point11=s}static create(t,e,i,s){return new wn(t.clone(),e.clone(),i.clone(),s.clone())}static createXYZ(t,e,i,s,n,r,o,a,c,h,l,d){return new wn(Q.create(t,e,i),Q.create(s,n,r),Q.create(o,a,c),Q.create(h,l,d))}clone(){return new wn(this.point00.clone(),this.point10.clone(),this.point01.clone(),this.point11.clone())}isAlmostEqual(t){return this.point00.isAlmostEqual(t.point00)&&this.point10.isAlmostEqual(t.point10)&&this.point01.isAlmostEqual(t.point01)&&this.point11.isAlmostEqual(t.point11)}tryTransformInPlace(t){return t.multiplyPoint3d(this.point00,this.point00),t.multiplyPoint3d(this.point10,this.point10),t.multiplyPoint3d(this.point01,this.point01),t.multiplyPoint3d(this.point11,this.point11),!0}cloneTransformed(t){const e=this.clone();return e.tryTransformInPlace(t),e}extendRange(t,e){e?(t.extendTransformedPoint(e,this.point00),t.extendTransformedPoint(e,this.point10),t.extendTransformedPoint(e,this.point01),t.extendTransformedPoint(e,this.point11)):(t.extendPoint(this.point00),t.extendPoint(this.point10),t.extendPoint(this.point01),t.extendPoint(this.point11))}uvFractionToPoint(t,e,i){const s=(1-t)*(1-e),n=t*(1-e),r=(1-t)*e,o=t*e;return Q.create(s*this.point00.x+n*this.point10.x+r*this.point01.x+o*this.point11.x,s*this.point00.y+n*this.point10.y+r*this.point01.y+o*this.point11.y,s*this.point00.z+n*this.point10.z+r*this.point01.z+o*this.point11.z,i)}uvFractionToPointAndTangents(t,e,i){const s=1-t,n=1-e,r=s*n,o=t*n,a=s*e,c=t*e;return Et.createOriginAndVectorsXYZ(r*this.point00.x+o*this.point10.x+a*this.point01.x+c*this.point11.x,r*this.point00.y+o*this.point10.y+a*this.point01.y+c*this.point11.y,r*this.point00.z+o*this.point10.z+a*this.point01.z+c*this.point11.z,n*(this.point10.x-this.point00.x)+e*(this.point11.x-this.point01.x),n*(this.point10.y-this.point00.y)+e*(this.point11.y-this.point01.y),n*(this.point10.z-this.point00.z)+e*(this.point11.z-this.point01.z),s*(this.point01.x-this.point00.x)+t*(this.point11.x-this.point10.x),s*(this.point01.y-this.point00.y)+t*(this.point11.y-this.point10.y),s*(this.point01.z-this.point00.z)+t*(this.point11.z-this.point10.z),i)}static conditionalPivot(t,e,i,s){if(Math.abs(e[s][t])>Math.abs(e[i][t])){const t=e[i];e[i]=e[s],e[s]=t}}intersectRay(t){const e=this.point10.minus(this.point00),i=this.point01.minus(this.point00),s=this.point11.minus(this.point10);s.subtractInPlace(i);const n=[new Float64Array([-t.direction.x,this.point00.x-t.origin.x,e.x,i.x,s.x]),new Float64Array([-t.direction.y,this.point00.y-t.origin.y,e.y,i.y,s.y]),new Float64Array([-t.direction.z,this.point00.z-t.origin.z,e.z,i.z,s.z])];wn.conditionalPivot(0,n,0,1),wn.conditionalPivot(0,n,0,2),Ft.eliminateFromPivot(n[0],0,n[1],-1),Ft.eliminateFromPivot(n[0],0,n[2],-1);const r=Ft.solveBilinearPair(n[1][1],n[1][2],n[1][3],n[1][4],n[2][1],n[2][2],n[2][3],n[2][4]);if(r){const e=[];for(const i of r){const s=-(n[0][1]+n[0][2]*i.x+(n[0][3]+n[0][4]*i.x)*i.y)/n[0][0],r=t.fractionToPoint(s);e.push(new Sn(vt.createRayFractionPoint(t,s,r),An.createSurfaceUVPoint(this,i,r)))}return e}}maxUEdgeLength(){return K.maxXY(this.point00.distance(this.point10),this.point01.distance(this.point11))}maxVEdgeLength(){return K.maxXY(this.point00.distance(this.point01),this.point10.distance(this.point11))}}class Cn{static sampledRangeOfOffsetPatch(t,e,i,s){const n=ut.createNull(),r=1/(i=Math.ceil(K.clamp(i,2,500))),o=1/(s=Math.ceil(K.clamp(s,2,500))),a=Q.create(),c=Et.createXYPlane();let h,l;for(let d=0;d<=s;d++){l=d*o;for(let s=0;s<=i;s++)if(h=s*r,void 0!==e){t.uvFractionToPointAndTangents(h,l,c);const i=c.unitNormal();void 0!==i&&(c.origin.addScaledInPlace(i,e),n.extend(c.origin))}else t.uvFractionToPoint(h,l,a),n.extendXYZ(a.x,a.y,a.z)}return n}static sampledRangeOfOffsetEllipsoidPatch(t,e,i){const s=ye.applyAngleTol(i,2,t.latitudeSweep.sweepRadians,W.degreesToRadians(5)),n=ye.applyAngleTol(i,2,t.longitudeSweep.sweepRadians,W.degreesToRadians(5));return this.sampledRangeOfOffsetPatch(t,e,s,n)}constructor(){}static createLinestringOnUVLine(t,e,i,s,n,r,o=!1,a=!1){const c=we.create(),h=Q.create();let l,d,u;const f=r+1;for(let g=0;g<f;g++)l=g/r,d=K.interpolate(e,l,s),u=K.interpolate(i,l,n),t.uvFractionToPoint(d,u,h),c.addPoint(h),o&&c.addUVParamAsUV(d,u),a&&c.addFraction(l);return c}}class Tn{static pointsClone(){const t=[];for(const e of this.points)t.push(e.clone());return t}}Tn.points=[Q.create(0,0,0),Q.create(1,0,0),Q.create(0,1,0),Q.create(1,1,0),Q.create(0,0,1),Q.create(1,0,1),Q.create(0,1,1),Q.create(1,1,1)],Tn.primaryCapId=-1,Tn.cornerIndexCCW=[[1,0,2,3],[4,5,7,6],[0,1,5,4],[1,3,7,5],[3,2,6,7],[2,0,4,6]],Tn.partnerFace=[[5,4,3,2],[2,3,4,5],[0,3,1,5],[0,4,1,2],[0,5,1,3],[0,2,1,4]],Tn.faceId=[[Tn.primaryCapId,0],[Tn.primaryCapId,1],[0,0],[0,1],[0,2],[0,3]],Tn.faceDirections=[[[0,1,2],[-1,1,-1]],[[0,1,2],[1,1,1]],[[0,2,1],[1,-1,1]],[[1,2,0],[1,1,1]],[[0,2,1],[-1,1,1]],[[1,2,0],[-1,1,-1]]],Tn.axisEdgeVertex=[[[0,1],[2,3],[4,5],[6,7]],[[0,2],[1,3],[4,6],[5,7]],[[0,4],[1,5],[2,6],[3,7]]];class kn{constructor(t,e,i){this.points=t,this.begin=e,this.end=i}static createComplete(t){return new this(t,0,t.length)}static createBeginEnd(t,e,i){return new this(t,e,i)}static createBeginLength(t,e,i){return new this(t,e,e+i)}advanceBegin(){return this.begin++,this.begin<this.end}advanceEnd(){return this.end++,this.end>this.points.length&&(this.end=this.points.length),this.begin<this.end}localIndexToParentIndex(t){if(t>=0){const e=this.begin+t;if(e<this.points.length)return e}}get isValidSubset(){return 0===this.length||void 0!==this.localIndexToParentIndex(0)&&void 0!==this.localIndexToParentIndex(this.length-1)}restrictEnd(){this.end>this.points.length&&(this.end=this.points.length)}get isNonEmpty(){return this.begin<this.end}advanceToTail(t){return this.begin=t.end-1,this.isNonEmpty}advanceToHead(t){return this.begin=t.begin,this.isNonEmpty}setFrom(t,e,i){this.points=t.points,this.begin=void 0===e?t.begin:e,this.end=void 0===i?t.end:i,this.restrictEnd()}get length(){return this.end>this.begin?this.end-this.begin:0}get isSingleton(){return this.begin+1===this.end}}class Fn extends kn{}class Mn extends Di{constructor(t,e,i,s,n,r){super(t,e,i),this._isValid=r,this._quality=n,this.id=s}setFrom(t){return super.setFrom(t),this._isValid=t._isValid,this._quality=t._quality,this.id=t.id,this}static createFromIndexedXYZ(t,e,i,s,n,r,o,a){a||(a=new Mn(Q.create(),Q.create(),Q.create(),o,0,!1)),a.id=o;let c=0;return void 0!==t.getPoint3dAtCheckedPointIndex(e,a.points[0])&&c++,void 0!==i.getPoint3dAtCheckedPointIndex(s,a.points[1])&&c++,void 0!==n.getPoint3dAtCheckedPointIndex(r,a.points[2])&&c++,3===c?a.updateAspectRatio():a.markInvalid(),a}get isValid(){return this._isValid}markInvalid(t){this._isValid=!1,void 0!==t&&(this._quality=t)}updateAspectRatio(){this._quality=super.aspectRatio,this._isValid=this._quality>0}clone(t){return t?t.setFrom(this):new Mn(this.points[0].clone(),this.points[1].clone(),this.points[2].clone(),this.id,this._quality,this._isValid)}static copyWithLowerQuality(t,e,i){if(i=t.clone(i),e.isValid){const s=t.dotProductOfCrossProductsFromOrigin(e);i._quality=K.minXY(t.aspectRatio,e.aspectRatio),s<0&&(i._quality-=1)}return i}static updateIfOtherHasHigherQuality(t,e){e.isValid&&e._quality>t._quality&&t.setFrom(e)}}class bn{constructor(t){this._turnRadians=t,this._xyzA=Q.create(),this._xyzB=Q.create(),this._forwardA=$.create(),this._forwardB=$.create(),this._vector1=$.create(),this._crossA=$.create(),this._crossB=$.create()}isForwardVector(t,e,i){if(t.dotProduct(e)<=0)return!1;const s=t.angleFromPerpendicular(i);return!(Math.abs(s.radians)>this._turnRadians)}isPlanarBase(t,e,i,s,n,r,o,a,c,h){return e+1<t.length&&s+1<i.length&&(t.getPoint3dAtUncheckedPointIndex(e,n),i.getPoint3dAtUncheckedPointIndex(s,a),t.vectorXYAndZIndex(n,e+1,o),i.vectorXYAndZIndex(a,s+1,h),$.createStartEnd(n,a,this._vector1),this._vector1.crossProduct(o,r),this._vector1.crossProduct(h,c),!n.isAlmostEqual(a)&&r.angleTo(c).radians<this._turnRadians)}advanceToPlanarLimit(t,e,i,s,n,r,o,a){for(e.setFrom(t,t.begin,i);e.end<t.end&&(e.points.vectorXYAndZIndex(s,e.end,this._vector1),this.isForwardVector(this._vector1,r,n))&&this.isForwardVector(this._vector1,a,o)&&(!(e.end>0)||(e.points.vectorIndexIndex(e.end-1,e.end,this._vector1),this.isForwardVector(this._vector1,r,n)));)e.end++}addGreedy(t,e,i,s=!1){for(t.restrictEnd(),e.restrictEnd();t.length>1&&e.length>1;)if(this._triangleA1=Mn.createFromIndexedXYZ(t.points,t.begin,t.points,t.begin+1,e.points,e.begin,1,this._triangleA1),this._triangleA2=Mn.createFromIndexedXYZ(t.points,t.begin+1,t.points,t.begin+2,e.points,e.begin,2,this._triangleA2),this._triangleA3=Mn.createFromIndexedXYZ(t.points,t.begin,t.points,t.begin+1,e.points,e.begin+1,3,this._triangleA3),this._triangleB1=Mn.createFromIndexedXYZ(e.points,e.begin+1,e.points,e.begin,t.points,t.begin,-1,this._triangleB1),this._triangleB2=Mn.createFromIndexedXYZ(e.points,e.begin+2,e.points,e.begin+1,t.points,t.begin,-2,this._triangleB2),this._triangleB3=Mn.createFromIndexedXYZ(e.points,e.begin+1,e.points,e.begin,t.points,t.begin+1,-3,this._triangleB3),this._bestTriangle=Mn.copyWithLowerQuality(this._triangleA1,this._triangleB3,this._bestTriangle),this._workTriangle=Mn.copyWithLowerQuality(this._triangleB1,this._triangleA3,this._workTriangle),Mn.updateIfOtherHasHigherQuality(this._bestTriangle,this._workTriangle),this._bestTriangle.id>0){if(t.advanceBegin(),i(this._bestTriangle),s)return}else if(e.advanceBegin(),i(this._bestTriangle),s)return;if(t.isSingleton)for(;e.length>=2;)this._workTriangle=Mn.createFromIndexedXYZ(e.points,e.begin+1,e.points,e.begin,t.points,t.begin,0,this._workTriangle),i(this._workTriangle),e.advanceBegin();if(e.isSingleton)for(;t.length>=2;)this._workTriangle=Mn.createFromIndexedXYZ(t.points,t.begin,t.points,t.begin+1,e.points,e.begin,0,this._workTriangle),i(this._workTriangle),t.advanceBegin()}emitTriangles(t,e,i){this.emitTrianglesGo(En(t),En(e),i)}emitTrianglesGo(t,e,i){const s=Fn.createComplete(t),n=Fn.createComplete(e),r=Fn.createComplete(t),o=Fn.createComplete(e);for(;s.length>0&&n.length>0&&(s.length>1||n.length>1);)this.isPlanarBase(t,s.begin,e,n.begin,this._xyzA,this._crossA,this._forwardA,this._xyzB,this._crossB,this._forwardB)?(this.advanceToPlanarLimit(s,r,s.begin+1,this._xyzA,this._crossA,this._forwardA,this._crossB,this._forwardB),this.advanceToPlanarLimit(n,o,n.begin+1,this._xyzB,this._crossB,this._forwardB,this._crossA,this._forwardA),this.addGreedy(r,o,i),s.advanceToTail(r),n.advanceToTail(o)):this.isPlanarBase(t,s.begin+1,e,n.begin,this._xyzA,this._crossA,this._forwardA,this._xyzB,this._crossB,this._forwardB)?(r.setFrom(s,s.begin,s.begin+2),o.setFrom(n,n.begin,n.begin+1),this.addGreedy(r,o,i),s.advanceToTail(r),n.advanceToTail(o)):this.isPlanarBase(t,s.begin,e,n.begin+1,this._xyzA,this._crossA,this._forwardA,this._xyzB,this._crossB,this._forwardB)?(r.setFrom(s,s.begin,s.begin+1),o.setFrom(n,n.begin,n.begin+2),this.addGreedy(r,o,i),s.advanceToTail(r),n.advanceToTail(o)):s.length>1&&n.length>1?(r.setFrom(s,s.begin,s.begin+2),o.setFrom(n,n.begin,n.begin+2),this.addGreedy(r,o,i,!0),s.advanceToHead(r),n.advanceToHead(o)):s.length>1?(r.setFrom(s,s.begin,s.begin+2),o.setFrom(n),this.addGreedy(r,o,i),s.advanceToTail(r),n.advanceToTail(o)):n.length>1&&(r.setFrom(s),o.setFrom(n,n.begin,n.begin+2),this.addGreedy(r,o,i),s.advanceToTail(r),n.advanceToTail(o));this.addGreedy(s,n,i)}static createContext(t=this.defaultNearColinearAngle){return new bn(t.radians)}}function En(t,e=K.smallMetricDistance){let i=!1;const s=t.length;for(let n=0;n+1<s;n++)if(t.distanceIndexIndex(n,n+1)<=e){i=!0;break}if(!i)return t;const n=new nt(s);n.pushXYZ(t.getXAtUncheckedPointIndex(0),t.getYAtUncheckedPointIndex(0),t.getZAtUncheckedPointIndex(0));let r=0;for(let i=1;i<s;i++)t.distanceIndexIndex(r,i)>e&&(n.pushXYZ(t.getXAtUncheckedPointIndex(i),t.getYAtUncheckedPointIndex(i),t.getZAtUncheckedPointIndex(i)),r=i);return t.distanceIndexIndex(0,s-1)<=e&&(n.pop(),n.pushFromGrowableXYZArray(n,0)),n}bn.defaultNearColinearAngle=W.createDegrees(15);class Xn{constructor(t=!1,e=!1,i=!1){this.xyz=Q.create(),this.normalIndex=-1,this.uvIndex=-1,this.xyzIndex=-1,t&&(this.normal=$.create()),e&&(this.uv=H.create(),this.uvIndex=-1),i&&(this.sectionDerivative=$.create())}copyContentsFrom(t){this.xyz.setFromPoint3d(t.xyz),this.xyzIndex=t.xyzIndex,this.normal&&this.normal.setFromVector3d(t.normal),this.normalIndex=t.normalIndex,this.uv&&this.uv.setFrom(t.uv),this.uvIndex=t.uvIndex,this.sectionDerivative&&this.sectionDerivative.setFrom(t.sectionDerivative)}loadIndexedPointAndDerivativeCoordinatesFromPackedArrays(t,e,i,s,n){e.getPoint3dAtCheckedPointIndex(t,this.xyz),s&&void 0!==n&&(this.uv=H.create(s.atUncheckedIndex(t),n)),this.xyzIndex=-1,this.normalIndex=-1,this.uvIndex=-1,void 0!==this.sectionDerivative&&void 0!==i&&i.getVector3dAtCheckedVectorIndex(t,this.sectionDerivative)}static suppressSmallUnitVectorComponents(t){const e=K.smallFloatingPoint;Math.abs(t.x)<e&&(t.x=0),Math.abs(t.y)<e&&(t.y=0),Math.abs(t.z)<e&&(t.z=0)}static computeNormalsAlongRuleLine(t,e){if(t.sectionDerivative&&e.sectionDerivative){const i=Xn._edgeVector;$.createStartEnd(t.xyz,e.xyz,i),t.sectionDerivative.crossProduct(i,t.normal),e.sectionDerivative.crossProduct(i,e.normal),t.normal.normalizeInPlace(),e.normal.normalizeInPlace(),Xn.suppressSmallUnitVectorComponents(t.normal),Xn.suppressSmallUnitVectorComponents(e.normal)}}}Xn._edgeVector=$.create();class Rn extends me{get options(){return this._options}get reversedFlag(){return this._reversed}claimPolyface(t=!0){return t&&this._polyface.data.compress(),this._polyface}toggleReversedFacetFlag(){this._reversed=!this._reversed}constructor(t){super(),this._options=t||ye.createForFacets(),this._polyface=Ii.create(this._options.needNormals,this._options.needParams,this._options.needColors,this._options.needTwoSided),this._reversed=!1}static create(t){return new Rn(t)}addTransformedUnitBox(t){this.addTransformedRangeMesh(t,ut.createXYZXYZ(0,0,0,1,1,1))}addTransformedRangeMesh(t,e,i){const s=this._polyface.data.pointCount,n=e.corners();for(const e of n)this._polyface.addPoint(t.multiplyPoint3d(e));let r=0;for(const t of Tn.cornerIndexCCW){if(!i||r<i.length&&i[r]){const e=t.map((t=>t+s));this._reversed&&e.reverse(),this._options.shouldTriangulate?(this.addIndexedTrianglePointIndexes(e[0],e[1],e[2],!1),this.addIndexedTrianglePointIndexes(e[0],e[2],e[3],!1)):this.addIndexedQuadPointIndexes(e[0],e[1],e[3],e[2],!1),this._polyface.terminateFacet()}r++}}addTriangleFan(t,e,i){const s=e.numPoints();if(s>2){i&&this.toggleReversedFacetFlag();const n=this.addPoint(t);let r=this.findOrAddPointInLineString(e,0),o=0;for(let t=1;t<s;t++)o=this.findOrAddPointInLineString(e,t),this.addIndexedTrianglePointIndexes(n,r,o),r=o;i&&this.toggleReversedFacetFlag()}}addTrianglesInUncheckedConvexPolygon(t,e){const i=t.numPoints();if(i>2){let s,n;e&&this.toggleReversedFacetFlag(),this._options.needNormals&&(s=t.quickUnitNormal(Rn._workVectorFindOrAdd),e&&s.scaleInPlace(-1),n=this._polyface.addNormal(s));const r=this._options.needParams?t.packedUVParams:void 0;let o=-1,a=-1,c=-1;r&&(o=this.addParamInGrowableXYArray(r,0),a=this.addParamInGrowableXYArray(r,1));const h=this.findOrAddPointInLineString(t,0);let l=this.findOrAddPointInLineString(t,1),d=0,u=i;t.isPhysicallyClosed&&u--;for(let e=2;e<u;e++,l=d,a=c)d=this.findOrAddPointInLineString(t,e),this.addIndexedTrianglePointIndexes(h,l,d,!1),void 0!==n&&this.addIndexedTriangleNormalIndexes(n,n,n),r&&(c=this.addParamInGrowableXYArray(r,e),this.addIndexedTriangleParamIndexes(o,a,c)),this._polyface.terminateFacet();e&&this.toggleReversedFacetFlag()}}addPoint(t){return this._polyface.addPoint(t)}findOrAddPoint(t){return this.addPoint(t)}addParamXY(t,e){return this._polyface.addParamUV(t,e)}findOrAddParamXY(t,e){return this.addParamXY(t,e)}findOrAddPointInLineString(t,e,i,s){const n=t.pointAt(e,Rn._workPointFindOrAddA);if(n)return i&&i.multiplyPoint3d(n,n),this._polyface.addPoint(n,s)}findOrAddPointInGrowableXYZArray(t,e,i,s){const n=t.getPoint3dAtCheckedPointIndex(e,Rn._workPointFindOrAddA);if(n)return i&&i.multiplyPoint3d(n,n),this._polyface.addPoint(n,s)}findOrAddNormalInGrowableXYZArray(t,e,i,s){const n=t.getVector3dAtCheckedVectorIndex(e,Rn._workVectorFindOrAdd);if(n)return i&&i.multiplyVector(n,n),this._polyface.addNormal(n,s)}addParamInGrowableXYArray(t,e){if(!t)return;const i=t.getPoint2dAtCheckedPointIndex(e,Rn._workUVFindOrAdd);return i?this._polyface.addParam(i):void 0}findOrAddParamInGrowableXYArray(t,e){return this.addParamInGrowableXYArray(t,e)}findOrAddParamInLineString(t,e,i,s,n){const r=t.fractions&&e<t.fractions.length?t.fractions.atUncheckedIndex(e):e/t.points.length;return this._polyface.addParamUV(r,i,s,n)}findOrAddNormalInLineString(t,e,i,s,n){const r=t.packedSurfaceNormals;if(r){const t=r.getVector3dAtCheckedVectorIndex(e,Rn._workVectorFindOrAdd);if(t)return i&&i.multiplyVector(t,t),this._polyface.addNormal(t,s,n)}}addPointXYZ(t,e,i){return this._polyface.addPointXYZ(t,e,i)}findOrAddPointXYZ(t,e,i){return this.addPointXYZ(t,e,i)}getUVTransformForTriangleFacet(t,e,i){const s=t.vectorTo(e),n=t.vectorTo(i),r=xt.createRigidFromColumns(s,n,p.XYZ);return pt.createOriginAndMatrix(t,r).inverse()}getNormalForTriangularFacet(t,e,i){const s=t.vectorTo(e),n=t.vectorTo(i);let r=s.crossProduct(n).normalize();return r=r||$.create(),r}addQuadFacet(t,e,i,s){t instanceof nt&&(t=t.getPoint3dArray());const n=this.options.needParams,r=this.options.needNormals,o=this.options.needColors;let a,c,h,l,d,u,f,g,p,m,x,y,_,v,P,I;if(n)if(void 0!==e&&e.length>3)a=e[0],c=e[1],h=e[2],l=e[3];else{const e=this.getUVTransformForTriangleFacet(t[0],t[1],t[2]);void 0===e?a=c=h=l=H.createZero():(a=H.createFrom(e.multiplyPoint3d(t[0])),c=H.createFrom(e.multiplyPoint3d(t[1])),h=H.createFrom(e.multiplyPoint3d(t[2])),l=H.createFrom(e.multiplyPoint3d(t[3])))}if(r&&(void 0!==i&&i.length>3?(d=i[0],u=i[1],f=i[2],g=i[3]):(d=this.getNormalForTriangularFacet(t[0],t[1],t[2]),u=this.getNormalForTriangularFacet(t[0],t[1],t[2]),f=this.getNormalForTriangularFacet(t[0],t[1],t[2]),g=this.getNormalForTriangularFacet(t[0],t[1],t[2]))),o&&void 0!==s&&s.length>3&&(p=s[0],m=s[1],x=s[2],y=s[3]),this._options.shouldTriangulate){const e=t[0].vectorTo(t[2]),i=t[1].vectorTo(t[3]);e.magnitude()>=i.magnitude()?(this.addTriangleFacet([t[0],t[1],t[2]],n?[a,c,h]:void 0,r?[d,u,f]:void 0,o?[p,m,x]:void 0),this.addTriangleFacet([t[0],t[2],t[3]],n?[a,h,l]:void 0,r?[d,f,g]:void 0,o?[p,x,y]:void 0)):(this.addTriangleFacet([t[0],t[1],t[3]],n?[a,c,l]:void 0,r?[d,u,g]:void 0,o?[p,m,y]:void 0),this.addTriangleFacet([t[1],t[2],t[3]],n?[c,h,l]:void 0,r?[u,f,g]:void 0,o?[m,x,y]:void 0))}else n&&(_=this._polyface.addParam(a),v=this._polyface.addParam(c),P=this._polyface.addParam(h),I=this._polyface.addParam(l),this.addIndexedQuadParamIndexes(_,v,I,P)),r&&(_=this._polyface.addNormal(d),v=this._polyface.addNormal(u),P=this._polyface.addNormal(f),I=this._polyface.addNormal(g),this.addIndexedQuadNormalIndexes(_,v,I,P)),o&&(_=this._polyface.addColor(p),v=this._polyface.addColor(m),P=this._polyface.addColor(x),I=this._polyface.addColor(y),this.addIndexedQuadColorIndexes(_,v,I,P)),_=this.addPoint(t[0]),v=this.addPoint(t[1]),P=this.addPoint(t[2]),I=this.addPoint(t[3]),this.addIndexedQuadPointIndexes(_,v,I,P)}addIndexedQuadPointIndexes(t,e,i,s,n=!0){this._reversed?(this._polyface.addPointIndex(t),this._polyface.addPointIndex(i),this._polyface.addPointIndex(s),this._polyface.addPointIndex(e)):(this._polyface.addPointIndex(t),this._polyface.addPointIndex(e),this._polyface.addPointIndex(s),this._polyface.addPointIndex(i)),n&&this._polyface.terminateFacet()}addIndexedQuadParamIndexes(t,e,i,s){this._reversed?(this._polyface.addParamIndex(t),this._polyface.addParamIndex(i),this._polyface.addParamIndex(s),this._polyface.addParamIndex(e)):(this._polyface.addParamIndex(t),this._polyface.addParamIndex(e),this._polyface.addParamIndex(s),this._polyface.addParamIndex(i))}addIndexedQuadNormalIndexes(t,e,i,s){this._reversed?(this._polyface.addNormalIndex(t),this._polyface.addNormalIndex(i),this._polyface.addNormalIndex(s),this._polyface.addNormalIndex(e)):(this._polyface.addNormalIndex(t),this._polyface.addNormalIndex(e),this._polyface.addNormalIndex(s),this._polyface.addNormalIndex(i))}addIndexedQuadColorIndexes(t,e,i,s){this._reversed?(this._polyface.addColorIndex(t),this._polyface.addColorIndex(i),this._polyface.addColorIndex(s),this._polyface.addColorIndex(e)):(this._polyface.addColorIndex(t),this._polyface.addColorIndex(e),this._polyface.addColorIndex(s),this._polyface.addColorIndex(i))}addTriangleFacet(t,e,i,s){if(t.length<3)return;let n,r,o,a,c,h;if(t instanceof nt?(a=t.getPoint3dAtCheckedPointIndex(0),c=t.getPoint3dAtCheckedPointIndex(1),h=t.getPoint3dAtCheckedPointIndex(2)):(a=t[0],c=t[1],h=t[2]),this._options.needParams){if(e&&e.length>=3)n=this._polyface.addParam(e[0]),r=this._polyface.addParam(e[1]),o=this._polyface.addParam(e[2]);else{const t=this.getUVTransformForTriangleFacet(a,c,h);n=this._polyface.addParam(H.createFrom(t?t.multiplyPoint3d(a):void 0)),r=this._polyface.addParam(H.createFrom(t?t.multiplyPoint3d(c):void 0)),o=this._polyface.addParam(H.createFrom(t?t.multiplyPoint3d(c):void 0))}this.addIndexedTriangleParamIndexes(n,r,o)}if(this._options.needNormals){if(void 0!==i&&i.length>2)n=this._polyface.addNormal(i[0]),r=this._polyface.addNormal(i[1]),o=this._polyface.addNormal(i[2]);else{const t=this.getNormalForTriangularFacet(a,c,h);n=this._polyface.addNormal(t),r=this._polyface.addNormal(t),o=this._polyface.addNormal(t)}this.addIndexedTriangleNormalIndexes(n,r,o)}this._options.needColors&&void 0!==s&&s.length>2&&(n=this._polyface.addColor(s[0]),r=this._polyface.addColor(s[1]),o=this._polyface.addColor(s[2]),this.addIndexedTriangleColorIndexes(n,r,o)),n=this.addPoint(a),r=this.addPoint(c),o=this.addPoint(h),this.addIndexedTrianglePointIndexes(n,r,o)}addIndexedTrianglePointIndexes(t,e,i,s=!0){this._reversed?(this._polyface.addPointIndex(t),this._polyface.addPointIndex(i),this._polyface.addPointIndex(e)):(this._polyface.addPointIndex(t),this._polyface.addPointIndex(e),this._polyface.addPointIndex(i)),s&&this._polyface.terminateFacet()}addIndexedTriangleParamIndexes(t,e,i){this._reversed?(this._polyface.addParamIndex(t),this._polyface.addParamIndex(i),this._polyface.addParamIndex(e)):(this._polyface.addParamIndex(t),this._polyface.addParamIndex(e),this._polyface.addParamIndex(i))}addIndexedTriangleNormalIndexes(t,e,i){this._reversed?(this._polyface.addNormalIndex(t),this._polyface.addNormalIndex(i),this._polyface.addNormalIndex(e)):(this._polyface.addNormalIndex(t),this._polyface.addNormalIndex(e),this._polyface.addNormalIndex(i))}addIndexedTriangleColorIndexes(t,e,i){this._reversed?(this._polyface.addColorIndex(t),this._polyface.addColorIndex(i),this._polyface.addColorIndex(e)):(this._polyface.addColorIndex(t),this._polyface.addColorIndex(e),this._polyface.addColorIndex(i))}setSectorIndices(t){t.xyzIndex=this.addPoint(t.xyz),t.normal&&(t.normalIndex=this._polyface.addNormal(t.normal)),t.uv&&(t.uvIndex=this._polyface.addParam(t.uv))}addSectorTriangle(t,e,i){t.xyz.isAlmostEqual(e.xyz)||e.xyz.isAlmostEqual(i.xyz)||i.xyz.isAlmostEqual(t.xyz)||(this._options.needNormals&&this.addIndexedTriangleNormalIndexes(t.normalIndex,e.normalIndex,i.normalIndex),this._options.needParams&&this.addIndexedTriangleParamIndexes(t.uvIndex,e.uvIndex,i.uvIndex),this.addIndexedTrianglePointIndexes(t.xyzIndex,e.xyzIndex,i.xyzIndex),this._polyface.terminateFacet())}addSectorQuadA01B01(t,e,i,s){t.xyz.isAlmostEqual(e.xyz)&&i.xyz.isAlmostEqual(s.xyz)||(this._options.shouldTriangulate?(this.addSectorTriangle(t,e,s),this.addSectorTriangle(s,i,t)):(this._options.needNormals&&this.addIndexedQuadNormalIndexes(t.normalIndex,e.normalIndex,i.normalIndex,s.normalIndex),this._options.needParams&&this.addIndexedQuadParamIndexes(t.uvIndex,e.uvIndex,i.uvIndex,s.uvIndex),this.addIndexedQuadPointIndexes(t.xyzIndex,e.xyzIndex,i.xyzIndex,s.xyzIndex),this._polyface.terminateFacet()))}addBetweenLineStringsWithRuleEdgeNormals(t,e,i,s,n=!1){const r=t.packedPoints,o=i.packedPoints,a=t.packedDerivatives,c=i.packedDerivatives,h=t.fractions,l=i.fractions,d=this._options.needNormals,u=this._options.needParams,f=new Xn(d,u,d),g=new Xn(d,u,d),p=new Xn(d,u,d),m=new Xn(d,u,d),x=new Xn(d,u,d),y=new Xn(d,u,d),_=r.length;if(!(_<2||_!==o.length)){f.loadIndexedPointAndDerivativeCoordinatesFromPackedArrays(0,r,a,h,e),p.loadIndexedPointAndDerivativeCoordinatesFromPackedArrays(0,o,c,l,s),d&&Xn.computeNormalsAlongRuleLine(f,p),this.setSectorIndices(f),this.setSectorIndices(p),x.copyContentsFrom(f),y.copyContentsFrom(p);for(let t=1;t<_;t++)g.loadIndexedPointAndDerivativeCoordinatesFromPackedArrays(t,r,a,h,e),m.loadIndexedPointAndDerivativeCoordinatesFromPackedArrays(t,o,a,l,s),Xn.computeNormalsAlongRuleLine(g,m),this.setSectorIndices(g),this.setSectorIndices(m),this.addSectorQuadA01B01(f,g,p,m),f.copyContentsFrom(g),p.copyContentsFrom(m);n&&this.addSectorQuadA01B01(f,x,p,y)}}addBetweenLineStringsWithStoredIndices(t,e){const i=t.pointIndices,s=e.pointIndices;let n=t.normalIndices,r=e.normalIndices;this._options.needNormals||(n=void 0,r=void 0);let o=t.paramIndices,a=e.paramIndices;this._options.needParams||(o=void 0,a=void 0);const c=i.length;for(let t=1;t<c;t++)this.options.shouldTriangulate?(Dn(i.atUncheckedIndex(t-1),i.atUncheckedIndex(t),s.atUncheckedIndex(t))&&(this.addIndexedTrianglePointIndexes(i.atUncheckedIndex(t-1),i.atUncheckedIndex(t),s.atUncheckedIndex(t)),n&&r&&this.addIndexedTriangleNormalIndexes(n.atUncheckedIndex(t-1),n.atUncheckedIndex(t),r.atUncheckedIndex(t-1)),o&&a&&this.addIndexedTriangleParamIndexes(o.atUncheckedIndex(t-1),o.atUncheckedIndex(t),a.atUncheckedIndex(t-1))),Dn(s.atUncheckedIndex(t),s.atUncheckedIndex(t-1),i.atUncheckedIndex(t-1))&&(this.addIndexedTrianglePointIndexes(i.atUncheckedIndex(t-1),s.atUncheckedIndex(t),s.atUncheckedIndex(t-1)),n&&r&&this.addIndexedTriangleNormalIndexes(n.atUncheckedIndex(t-1),r.atUncheckedIndex(t),r.atUncheckedIndex(t-1)),o&&a&&this.addIndexedTriangleParamIndexes(o.atUncheckedIndex(t-1),a.atUncheckedIndex(t),a.atUncheckedIndex(t-1)))):(i.atUncheckedIndex(t-1)===i.atUncheckedIndex(t)&&s.atUncheckedIndex(t-1)===s.atUncheckedIndex(t)||(this.addIndexedQuadPointIndexes(i.atUncheckedIndex(t-1),i.atUncheckedIndex(t),s.atUncheckedIndex(t-1),s.atUncheckedIndex(t)),n&&r&&this.addIndexedQuadNormalIndexes(n.atUncheckedIndex(t-1),n.atUncheckedIndex(t),r.atUncheckedIndex(t-1),r.atUncheckedIndex(t)),o&&a&&this.addIndexedQuadParamIndexes(o.atUncheckedIndex(t-1),o.atUncheckedIndex(t),a.atUncheckedIndex(t-1),a.atUncheckedIndex(t))),this._polyface.terminateFacet())}addBetweenTransformedLineStrings(t,e,i,s=!1){if(t instanceof we){const n=t.points.length;let r=this.findOrAddPointInLineString(t,0,e),o=this.findOrAddPointInLineString(t,0,i);const a=r,c=o;let h=0,l=0;for(let s=1;s<n;s++)h=this.findOrAddPointInLineString(t,s,e),l=this.findOrAddPointInLineString(t,s,i),this.addIndexedQuadPointIndexes(r,h,o,l),r=h,o=l;s&&this.addIndexedQuadPointIndexes(r,a,o,c)}else{const s=t.children;if(s)for(const t of s)this.addBetweenTransformedLineStrings(t,e,i)}}addBetweenStrokeSetPair(t,e,i,s){if(t instanceof we&&i instanceof we)this.addBetweenLineStringsWithRuleEdgeNormals(t,e,i,s,!1);else if(t instanceof Qe&&i instanceof Qe){if(t.children.length===i.children.length)for(let n=0;n<t.children.length;n++)this.addBetweenStrokeSetPair(t.children[n],e,i.children[n],s)}else if(t instanceof We&&i instanceof We){const n=t.children,r=i.children;if(n.length===r.length)for(let t=0;t<n.length;t++){const i=n[t],o=r[t];i instanceof we&&o instanceof we&&this.addBetweenLineStringsWithRuleEdgeNormals(i,e,o,s)}}}addCone(t){let e=16;this._options&&(e=this._options.applyTolerancesToArc(t.getMaxRadius()));let i=1;const s=t.strokeConstantVSection(0,e,this._options),n=t.strokeConstantVSection(1,e,this._options);if(this._options){const t=nt.distanceRangeBetweenCorrespondingPoints(s.packedPoints,n.packedPoints);i=this._options.applyMaxEdgeLength(1,t.low)}const r=t.maxIsoParametricDistance();this.addUVGridBody(t,e,i,ke.create(0,r.x),ke.create(0,r.y)),this.endFace(),t.capped&&(K.isSmallMetricDistance(t.getRadiusA())||(this.addTrianglesInUncheckedConvexPolygon(s,!0),this.endFace()),K.isSmallMetricDistance(t.getRadiusB())||(this.addTrianglesInUncheckedConvexPolygon(n,!1),this.endFace()))}addTorusPipe(t,e,i){const s=t.getThetaFraction(),n=K.clamp(K.resolveNumber(e,8),4,64),r=K.clamp(K.resolveNumber(i,Math.ceil(16*s)),2,64);this.toggleReversedFacetFlag();const o=t.maxIsoParametricDistance();if(this.addUVGridBody(t,n,r,ke.create(0,o.x),ke.create(0,o.y)),this.toggleReversedFacetFlag(),t.capped&&s<1){const e=t.getConstructiveFrame(),i=t.getMinorRadius(),s=t.getMajorRadius(),r=2*i,o=s-i,a=s+i,c=-i,h=pt.createRowValues(r,0,0,o,0,0,-1,0,0,r,0,c),l=e.multiplyTransformTransform(h).inverse();if(l){const e=Cn.createLinestringOnUVLine(t,0,0,1,0,n,!1,!0);e.computeUVFromXYZTransform(l),this.addTrianglesInUncheckedConvexPolygon(e,!1)}const d=t.getSweepAngle().radians,u=Math.cos(d),f=Math.sin(d),g=pt.createRowValues(-u*r,0,-f,a*u,-f*r,0,u,a*f,0,r,0,c),p=e.multiplyTransformTransform(g).inverse();if(p){const e=Cn.createLinestringOnUVLine(t,1,1,0,1,n,!1,!0);e.computeUVFromXYZTransform(p),this.addTrianglesInUncheckedConvexPolygon(e,!1)}}}addLinearSweepLineStringsXYZOnly(t,e){if(t instanceof we){let i=Q.create(),s=Q.create(),n=0,r=0,o=0,a=0;const c=t.numPoints();for(let h=0;h<c;h++)i=t.pointAt(h,i),s=i.plus(e,s),r=this.addPoint(i),a=this.addPoint(s),h>0&&this.addIndexedQuadPointIndexes(n,r,o,a),n=r,o=a}else if(t instanceof We)for(const i of t.children)this.addLinearSweepLineStringsXYZOnly(i,e)}addRotationalSweep(t){const e=t.getCurves(),i=In.createForParityRegionOrChain(e,this._options).getStrokes(),s=t.cloneAxisRay(),n=xn.computeMaxVectorFromRay(s,i),r=s.direction.crossProduct(n);this._options.needNormals&&xn.buildRotationalNormalsInLineStrings(i,s,r);const o=n.magnitude(),a=Math.abs(o*t.getSweep().radians);let c=ye.applyAngleTol(this._options,1,t.getSweep().radians,void 0);c=ye.applyMaxEdgeLength(this._options,c,a);for(let e=1;e<=c;e++){const s=t.getFractionalRotationTransform((e-1)/c),n=t.getFractionalRotationTransform(e/c);this.addBetweenRotatedStrokeSets(i,s,e-1,n,e)}if(t.capped){const e=t.getSweepContourRef();e.purgeFacets(),e.emitFacets(this,!0,void 0),e.emitFacets(this,!1,t.getFractionalRotationTransform(1))}}addTriangulatedRegion(t){if(t instanceof Zi)for(const e of t.children)this.addTriangulatedRegion(e);const e=sn.createForLinearSweep(t);e&&e.emitFacets(this,this.reversedFlag,void 0)}applyStrokeCountsToCurvePrimitives(t){const e=this._options;if(t instanceof ie)t.computeStrokeCountForOptions(e);else if(t instanceof qe){const e=t.children;if(e)for(const t of e)this.applyStrokeCountsToCurvePrimitives(t)}}addBetweenStrokeSetsWithRuledNormals(t,e,i){const s=[t],n=[0];for(let r=1;r<i;r++){const o=r/i,a=ei.interpolateBetween(t,r/i,e);s.push(a),n.push(o)}s.push(e),n.push(1);for(let t=0;t<i;t++)this.addBetweenStrokeSetPair(s[t],n[t],s[t+1],n[t+1])}createIndicesInLineString(t,e,i){const s=t.numPoints();{const e=t.ensureEmptyPointIndices(),n=this.findOrAddPointInLineString(t,0,i);if(e.push(n),s>1){let r,o=n;for(let n=1;n+1<s;n++)r=this.findOrAddPointInLineString(t,n,i,o),e.push(r),o=r;r=this.findOrAddPointInLineString(t,s-1,i,n),e.push(r)}}if(this._options.needNormals&&void 0!==t.packedSurfaceNormals){const e=t.ensureEmptyNormalIndices(),n=this.findOrAddNormalInLineString(t,0,i);e.push(n);let r,o=n;if(s>1){for(let n=1;n+1<s;n++)r=this.findOrAddNormalInLineString(t,n,i,o),e.push(r),o=r;r=this.findOrAddNormalInLineString(t,s-1,i,n,o),e.push(r)}}if(this._options.needParams&&void 0!==t.packedUVParams){const i=t.ensureEmptyUVIndices(),n=this.findOrAddParamInLineString(t,0,e);i.push(n);let r,o=n;if(s>1){for(let n=1;n+1<s;n++)r=this.findOrAddParamInLineString(t,n,e,o),i.push(r),o=r;r=this.findOrAddParamInLineString(t,s-1,e,o,n),i.push(r)}}}addBetweenRotatedStrokeSets(t,e,i,s,n){if(t instanceof we){const r=t.cloneTransformed(e);this.createIndicesInLineString(r,i);const o=t.cloneTransformed(s);this.createIndicesInLineString(o,n),this.addBetweenLineStringsWithStoredIndices(r,o)}else if(t instanceof Qe)for(let r=0;r<t.children.length;r++)this.addBetweenRotatedStrokeSets(t.children[r],e,i,s,n);else if(t instanceof We){const r=t.children;for(let t=0;t<r.length;t++){const o=r[t];o instanceof we&&this.addBetweenRotatedStrokeSets(o,e,i,s,n)}}}addLinearSweep(t){const e=t.getCurvesRef(),i=In.createForParityRegionOrChain(e,this._options).getStrokes(),s=t.cloneSweepVector(),n=pt.createTranslation(s),r=i.cloneTransformed(n),o=this._options.applyMaxEdgeLength(1,s.magnitude());if(this.addBetweenStrokeSetsWithRuledNormals(i,r,o),t.capped&&e.isAnyRegionType){const e=t.getSweepContourRef();e.purgeFacets(),e.emitFacets(this,!0,void 0),e.emitFacets(this,!1,n)}}addRuledSweep(t){const e=t.sweepContoursRef();let i,s;const n=[];for(let t=0;t<e.length;t++)n.push(In.createForParityRegionOrChain(e[t].curves,this._options));if(In.enforceStrokeCountCompatibility(n)){In.enforceCompatibleDistanceSums(n);for(let t=0;t<e.length;t++){if(s=n[t].getStrokes(),s||(s=e[t].curves.cloneStroked()),t>0&&i&&s){const t=ft.createNull();if(In.extendDistanceRangeBetweenStrokes(i,s,t)&&!t.isNull){const e=this._options.applyMaxEdgeLength(1,t.high);this.addBetweenStrokeSetsWithRuledNormals(i,s,e)}}i=s}}return t.capped&&e[0].curves.isAnyRegionType&&(e[0].purgeFacets(),e[0].emitFacets(this,!0,void 0),e[e.length-1].purgeFacets(),e[e.length-1].emitFacets(this,!1,void 0)),!0}addSphere(t,e){let i=e||this.options.applyTolerancesToArc(t.maxAxisRadius());K.isOdd(i)&&(i+=1);const s=K.clampToStartEnd(Math.abs(i*t.latitudeSweepFraction),1,Math.ceil(.5*i)),n=t.strokeConstantVSection(0,i,this._options);t.capped&&!K.isSmallMetricDistance(n.quickLength())&&(this.addTrianglesInUncheckedConvexPolygon(n,!0),this.endFace());const r=t.maxIsoParametricDistance();this.addUVGridBody(t,i,s,ke.create(0,r.x),ke.create(0,r.y)),this.endFace();const o=t.strokeConstantVSection(1,i,this._options);t.capped&&!K.isSmallMetricDistance(o.quickLength())&&(this.addTrianglesInUncheckedConvexPolygon(o,!1),this.endFace())}addBox(t){const e=t.getCorners(),i=K.maxXY(t.getBaseX(),t.getBaseX()),s=K.maxXY(t.getBaseY(),t.getTopY());let n=0;for(let t=0;t<4;t++)n=K.maxXY(n,e[t].distance(e[t+4]));const r=this._options.applyMaxEdgeLength(1,i),o=this._options.applyMaxEdgeLength(1,s),a=this._options.applyMaxEdgeLength(1,n),c=ke.create(0,i),h=ke.create(0,n);this.addUVGridBody(wn.create(e[0],e[1],e[4],e[5]),r,a,c,h),c.shift(i),this.addUVGridBody(wn.create(e[1],e[3],e[5],e[7]),o,a,c,h),c.shift(s),this.addUVGridBody(wn.create(e[3],e[2],e[7],e[6]),r,a,c,h),c.shift(i),this.addUVGridBody(wn.create(e[2],e[0],e[6],e[4]),o,a,c,h),this.endFace(),t.capped&&(c.set(0,i),h.set(0,s),this.addUVGridBody(wn.create(e[4],e[5],e[6],e[7]),r,o,c,h),this.endFace(),c.set(0,i),h.set(0,s),this.addUVGridBody(wn.create(e[2],e[3],e[0],e[1]),r,o,c,h),this.endFace())}addPolygon(t,e){for(void 0===e&&(e=t.length);e>1&&t[e-1].isAlmostEqual(t[0]);)e--;let i=0;if(this._reversed)for(let s=e;--s>=0;)i=this.addPoint(t[s]),this._polyface.addPointIndex(i);else for(let s=0;s<e;s++)i=this.addPoint(t[s]),this._polyface.addPointIndex(i);this._polyface.terminateFacet()}addPolygonGrowableXYZArray(t){let e=t.length;for(;e>2&&K.isSmallMetricDistance(t.distanceIndexIndex(0,e-1));)e--;for(;e>2&&K.isSmallMetricDistance(t.distanceIndexIndex(e-2,e-1));)e--;if(3===e){const i=t.crossProductIndexIndexIndex(0,1,2).magnitude(),s=t.distanceIndexIndex(0,1)+t.distanceIndexIndex(0,2)+t.distanceIndexIndex(1,2);i<K.smallMetricDistance*s&&(e=0)}if(e>2){let i=0;if(this._reversed)for(let s=e;--s>=0;)i=this.findOrAddPointInGrowableXYZArray(t,s),this._polyface.addPointIndex(i);else for(let s=0;s<e;s++)i=this.findOrAddPointInGrowableXYZArray(t,s),this._polyface.addPointIndex(i);this._polyface.terminateFacet()}}addFacetFromGrowableArrays(t,e,i,s,n){let r=t.length;for(;r>1&&K.isSmallMetricDistance(t.distanceIndexIndex(0,r-1));)r--;let o=0;if(e&&e.length<r&&(e=void 0),i&&i.length<r&&(i=void 0),s&&s.length<r&&(s=void 0),n&&n.length<r&&(n=void 0),this._reversed)for(let n=r;--n>=0;)o=this.findOrAddPointInGrowableXYZArray(t,n),this._polyface.addPointIndex(o),e&&(o=this.findOrAddNormalInGrowableXYZArray(e,n),this._polyface.addNormalIndex(o)),i&&(o=this.addParamInGrowableXYArray(i,n),this._polyface.addParamIndex(o)),s&&(o=this._polyface.addColor(s[n]),this._polyface.addColorIndex(o));else for(let a=0;a<r;a++)o=this.findOrAddPointInGrowableXYZArray(t,a),this._polyface.addPointIndex(o,!n||n[a]),e&&(o=this.findOrAddNormalInGrowableXYZArray(e,a),this._polyface.addNormalIndex(o)),i&&(o=this.addParamInGrowableXYArray(i,a),this._polyface.addParamIndex(o)),s&&(o=this._polyface.addColor(s[a]),this._polyface.addColorIndex(o));this._polyface.terminateFacet()}addFacetFromVisitor(t){this.addFacetFromGrowableArrays(t.point,t.normal,t.param,t.color,t.edgeVisible)}addIndexedPolyface(t,e,i){this._polyface.addIndexedPolyface(t,e,i)}endFace(){return this._polyface.setNewFaceData()}handleCone(t){return this.addCone(t)}handleTorusPipe(t){return this.addTorusPipe(t)}handleSphere(t){return this.addSphere(t)}handleBox(t){return this.addBox(t)}handleLinearSweep(t){return this.addLinearSweep(t)}handleRotationalSweep(t){return this.addRotationalSweep(t)}handleRuledSweep(t){return this.addRuledSweep(t)}handleLoop(t){return this.addTriangulatedRegion(t)}handleParityRegion(t){return this.addTriangulatedRegion(t)}handleUnionRegion(t){return this.addTriangulatedRegion(t)}addGeometryQuery(t){t.dispatchToGeometryHandler(this)}addGraph(t,e,i=(t=>Oi.testNodeMaskNotExterior(t)),s=(t=>Oi.testMateMaskExterior(t))){let n=0;const r=this._options.needNormals;let o=0;r&&(o=this._polyface.addNormalXYZ(0,0,1)),t.announceFaceLoops(((t,a)=>{if(i(a)&&a.countEdgesAroundFace()>2){let t=a;do{n=this.addPointXYZ(t.x,t.y,t.z),this._polyface.addPointIndex(n,void 0===s||s(t)),e&&(n=this.addParamXY(t.x,t.y),this._polyface.addParamIndex(n)),r&&this._polyface.addNormalIndex(o),t=t.faceSuccessor}while(t!==a);this._polyface.terminateFacet()}return!0}))}addGraphFaces(t,e){let i=0;for(const t of e){let e=t;do{i=this.addPointXYZ(e.x,e.y,e.z),this._polyface.addPointIndex(i),e=e.faceSuccessor}while(e!==t);this._polyface.terminateFacet()}}static graphToPolyface(t,e,i=(t=>Oi.testNodeMaskNotExterior(t))){const s=Rn.create(e);return s.addGraph(t,s.options.needParams,i),s.endFace(),s.claimPolyface()}static graphFacesToPolyface(t,e){const i=Rn.create();return i.addGraphFaces(t,e),i.endFace(),i.claimPolyface()}static polygonToTriangulatedPolyface(t,e){if(e||(e=Je.createFrameWithCCWPolygon(t)),e){const i=e.multiplyInversePoint3dArray(t);gr.areaXY(i)<0&&i.reverse();const s=ms.createTriangulatedGraphFromSingleLoop(i);if(s){const t=this.graphToPolyface(s);return t.tryTransformInPlace(e),t}}}addCoordinateFacets(t,e,i,s=!1){for(let s=0;s<t.length;s++){const n=e?e[s]:void 0,r=i?i[s]:void 0;3===t[s].length?this.addTriangleFacet(t[s],n,r):4===t[s].length&&this.addQuadFacet(t[s],n,r)}s&&this.endFace()}addUVGridBody(t,e,i,s,n){let r,o,a,c,h=new St(e),l=new St(e);const d=this._reversed,u=this.options.needNormals;u&&(a=new St(e),c=new St(e));const f=this.options.needParams;let g;f&&(r=new St(e),o=new St(e)),h.ensureCapacity(e),l.ensureCapacity(e);const p=H.create(),m=$.create(),x=1/e,y=1/i,_=Et.createXYPlane();for(let v=0;v<=i;v++){l.clear(),u&&c.clear(),f&&o.clear();for(let i=0;i<=e;i++){const e=i*x,r=v*y;t.uvFractionToPointAndTangents(e,r,_),l.push(this._polyface.addPoint(_.origin)),u&&(_.vectorU.crossProduct(_.vectorV,m),m.normalizeInPlace(),d&&m.scaleInPlace(-1),c.push(this._polyface.addNormal(m))),f&&o.push(this._polyface.addParam(H.create(s?s.fractionToPoint(e):e,n?n.fractionToPoint(r):r,p)))}if(v>0)for(let t=0;t<e;t++)this._options.shouldTriangulate?(this.addIndexedTrianglePointIndexes(h.atUncheckedIndex(t),h.atUncheckedIndex(t+1),l.atUncheckedIndex(t),!1),u&&this.addIndexedTriangleNormalIndexes(a.atUncheckedIndex(t),a.atUncheckedIndex(t+1),c.atUncheckedIndex(t)),f&&this.addIndexedTriangleParamIndexes(r.atUncheckedIndex(t),r.atUncheckedIndex(t+1),o.atUncheckedIndex(t)),this._polyface.terminateFacet(),this.addIndexedTrianglePointIndexes(l.atUncheckedIndex(t),h.atUncheckedIndex(t+1),l.atUncheckedIndex(t+1),!1),u&&this.addIndexedTriangleNormalIndexes(c.atUncheckedIndex(t),a.atUncheckedIndex(t+1),c.atUncheckedIndex(t+1)),f&&this.addIndexedTriangleParamIndexes(o.atUncheckedIndex(t),r.atUncheckedIndex(t+1),o.atUncheckedIndex(t+1)),this._polyface.terminateFacet()):(this.addIndexedQuadPointIndexes(h.atUncheckedIndex(t),h.atUncheckedIndex(t+1),l.atUncheckedIndex(t),l.atUncheckedIndex(t+1),!1),u&&this.addIndexedQuadNormalIndexes(a.atUncheckedIndex(t),a.atUncheckedIndex(t+1),c.atUncheckedIndex(t),c.atUncheckedIndex(t+1)),f&&this.addIndexedQuadParamIndexes(r.atUncheckedIndex(t),r.atUncheckedIndex(t+1),o.atUncheckedIndex(t),o.atUncheckedIndex(t+1)),this._polyface.terminateFacet());g=l,l=h,h=g,f&&(g=o,o=r,r=g),u&&(g=c,c=a,a=g)}h.clear(),l.clear()}static pointsToTriangulatedPolyface(t){const e=ms.createTriangulatedGraphFromPoints(t);if(e)return Rn.graphToPolyface(e)}addGreedyTriangulationBetweenLineStrings(t,e){bn.createContext().emitTriangles(zn(t),zn(e),(t=>{this.addTriangleFacet(t.points)}))}addMiteredPipesFromPoints(t,e,i=12){const s=pn.createMiteredPipeSections(t,e),n=Q.create(),r=Q.create(),o=Q.create(),a=Q.create();i<3&&(i=3);const c=1/i;for(let t=1;t<s.length;t++){const e=s[t-1],h=s[t];e.fractionToPoint(0,n),h.fractionToPoint(0,o);for(let t=1;t<=i;t++,n.setFromPoint3d(r),o.setFromPoint3d(a)){const i=t*c;e.fractionToPoint(i,r),h.fractionToPoint(i,a),this.addQuadFacet([n,o,a,r])}}}addMiteredPipes(t,e,i=12){if(Array.isArray(t))this.addMiteredPipesFromPoints(new se(t),e,i);else if(t instanceof nt)this.addMiteredPipesFromPoints(t,e,i);else if(t instanceof it)this.addMiteredPipesFromPoints(t,e,i);else if(t instanceof we)this.addMiteredPipesFromPoints(t.packedPoints,e,i);else if(t instanceof Nt){const s=we.create();t.emitStrokes(s,this._options),this.addMiteredPipesFromPoints(s.packedPoints,e,i)}}getEdgeIndices(t){let e=-1,i=-1;for(let s=this._polyface.facetIndex0(t.facetIndex);s<this._polyface.facetIndex1(t.facetIndex);++s)t.vertexIndexA===this._polyface.data.pointIndex[s]?e=s:t.vertexIndexB===this._polyface.data.pointIndex[s]&&(i=s);return e<0||i<0?void 0:{edgeIndexA:e,edgeIndexB:i}}addSweptFace(t,e){const i=this.getEdgeIndices(t);if(void 0===i)return!1;const s=e+t.facetIndex;if(!this._polyface.isValidFacetIndex(s))return!1;const n=this._polyface.numEdgeInFacet(t.facetIndex);if(n!==this._polyface.numEdgeInFacet(s))return!1;const r=this._polyface.facetIndex0(t.facetIndex),o=this._polyface.facetIndex0(s),a=n-1-(i.edgeIndexA-r),c=n-1-(i.edgeIndexB-r),h=[i.edgeIndexB,i.edgeIndexA,o+a,o+c],l=[];let d;void 0!==this.options.needColors&&void 0!==this._polyface.data.color&&void 0!==this._polyface.data.colorIndex&&(d=[]);for(let t=0;t<4;++t){const e=this._polyface.data.getPoint(this._polyface.data.pointIndex[h[t]]);if(void 0===e)return!1;if(l.push(e),void 0!==d){const e=this._polyface.data.getColor(this._polyface.data.colorIndex[h[t]]);if(void 0===e)return!1;d.push(e)}}return this.addQuadFacet(l,void 0,void 0,d),!0}addSweptIndexedPolyface(t,e,i=!1){let s=!0;const n=tn.sumFacetAreas(t,e);K.isAlmostEqualNumber(0,n)&&(s=!1);const r=tn.partitionFacetIndicesByVisibilityVector(t,e,W.createDegrees(.001)),o=r[0].length,a=r[1].length;r[2].length>0&&(s=!1),o>0&&a>0&&(s=!1);const c=o>0,h=this._polyface.facetCount;this.addIndexedPolyface(t,c);const l=this._polyface.facetCount;this.addIndexedPolyface(t,!c,pt.createTranslation(e));const d=l-h,u=Array.from({length:d},((t,e)=>h+e)),f=_i.createSubsetVisitor(this._polyface,u,1),g=[];tn.createIndexedEdges(f).sortAndCollectClusters(void 0,g,void 0,void 0);const p=this._options.shouldTriangulate;this._options.shouldTriangulate=i;for(const t of g)if(t instanceof Es)this.addSweptFace(t,d);else if(Array.isArray(t))for(const e of t)this.addSweptFace(e,d);return this._options.shouldTriangulate=p,s}}function zn(t){return Array.isArray(t)?new se(t):t instanceof we?t.packedPoints:t}function Dn(t,e,i){return t!==e&&e!==i&&i!==t}Rn._workPointFindOrAddA=Q.create(),Rn._workVectorFindOrAdd=$.create(),Rn._workUVFindOrAdd=H.create();class Yn{constructor(t=5){this._activeMomentData=ti.create(),this._activeMomentData.needOrigin=!0,this._gaussMapper=new te(t)}get momentData(){return this._activeMomentData}startParentCurvePrimitive(t){}startCurvePrimitive(t){}endCurvePrimitive(t){}endParentCurvePrimitive(t){}announceIntervalForUniformStepStrokes(t,e,i,s){this.startCurvePrimitive(t),e<1&&(e=1);const n=1/e;let r,o;for(let a=1;a<=e;a++){const c=K.interpolate(i,(a-1)*n,s),h=a===e?s:K.interpolate(i,a*n,s),l=this._gaussMapper.mapXAndW(c,h);for(let e=0;e<l;e++){o=this._gaussMapper.gaussX[e];const i=t.fractionToPointAndDerivative(o);r=this._gaussMapper.gaussW[e]*i.direction.magnitude(),this._activeMomentData.accumulateScaledOuterProduct(i.origin,r)}}}announceSegmentInterval(t,e,i,s,n,r){this._activeMomentData.accumulateLineMomentsXYZ(e,i)}announcePointTangent(t,e,i){}visitLeaves(t){if(t instanceof ie)t.emitStrokableParts(this);else if(t instanceof qe&&void 0!==t.children)for(const e of t.children)this.visitLeaves(e)}}class Nn{pushNewChain(t){const e=[];t&&e.push(t),this._chains.push(e)}findOrCreateTailChain(){return 0===this._chains.length&&this.pushNewChain(),this._chains[this._chains.length-1]}findAnyChainToConnect(t){for(let e=0;e<this._chains.length;e++){const i=this._chains[e];if(this._xyzWork1=i[i.length-1].endPoint(this._xyzWork1),this._xyzWork1.isAlmostEqual(t))return{chainIndex:e,atEnd:!0};if(this._xyzWork1=i[0].startPoint(this._xyzWork1),this._xyzWork1.isAlmostEqual(t))return{chainIndex:e,atEnd:!1}}}constructor(t){this._chains=[],this._makeClones=t}announceCurvePrimitive(t,e=!1){if(t){if(this._makeClones){const e=t.clone();if(!(e&&e instanceof ie))return;this.transferMarkup(t,e),t=e}if(e){this._xyzWork0=t.startPoint(this._xyzWork0);let e=this.findAnyChainToConnect(this._xyzWork0);e?e.atEnd?this._chains[e.chainIndex].push(t):(t.reverseInPlace(),this._chains[e.chainIndex].splice(0,0,t)):(this._xyzWork0=t.endPoint(this._xyzWork0),e=this.findAnyChainToConnect(this._xyzWork0),e?e.atEnd?(t.reverseInPlace(),this._chains[e.chainIndex].push(t)):this._chains[e.chainIndex].splice(0,0,t):this._chains.push([t]))}else{const e=this.findOrCreateTailChain();0!==e.length&&Nn.needBreakBetweenPrimitives(e[e.length-1],t)?this.pushNewChain(t):e.push(t)}}}transferMarkup(t,e){t&&e&&(e.startCut=t.startCut,e.endCut=t.endCut)}promoteArrayToCurves(t,e){if(0!==t.length)return e&&(Nn._staticPointA=t[0].startPoint(Nn._staticPointA),Nn._staticPointB=t[t.length-1].endPoint(Nn._staticPointB),Nn._staticPointA.isAlmostEqual(Nn._staticPointB))?Ke.createArray(t):1===t.length?t[0]:Fi.createArray(t)}grabResult(t=!1){const e=this._chains;if(0===e.length)return;if(1===e.length)return this.promoteArrayToCurves(e[0],t);const i=Ge.create();for(const s of e){const e=this.promoteArrayToCurves(s,t);i.tryAddChild(e)}return i}static needBreakBetweenPrimitives(t,e,i=!1){return void 0===t||void 0===e||void 0!==t.endCut||void 0!==e.startCut||(Nn._staticPointA=t.endPoint(Nn._staticPointA),Nn._staticPointB=e.startPoint(Nn._staticPointB),i?!Nn._staticPointA.isAlmostEqualXY(Nn._staticPointB):!Nn._staticPointA.isAlmostEqual(Nn._staticPointB))}}class On extends me{constructor(t){super(),this._options=t||new He}handleCurveChain(t){const e=t.children.length,i=[];let s=0;for(let n=0;n<e;){const r=t.children[n];if(this._options.consolidateLinearGeometry&&(r instanceof Pe||r instanceof we)){i.length=0;let o=n;for(;o<t.children.length;o++){const e=t.children[o];if(e instanceof Pe)i.push(e.startPoint()),i.push(e.endPoint());else{if(!(e instanceof we))break;{const t=e.packedPoints;for(let e=0;e<t.length;e++)i.push(t.getPoint3dAtUncheckedPointIndex(e))}}}if(i.length>1){const r=this._options.colinearPointTolerance,a=ii.compressShortEdges(i,r),c=ii.compressByPerpendicularDistance(a,r);0===n&&o===e&&$e.compressColinearWrapInPlace(c,r),c.length<2?t.children[s++]=we.create(c[0]):2===c.length?t.children[s++]=Pe.create(c[0],c[1]):t.children[s++]=we.createPoints(c)}else t.children[s++]=r;n=o}else if(this._options.consolidateCompatibleArcs&&r instanceof De){for(;++n<t.children.length;){const e=t.children[n];if(!(e instanceof De))break;if(!pn.appendToArcInPlace(r,e))break}t.children[s++]=r}else t.children[s++]=r,n++}t.children.length=s}handlePath(t){return this.handleCurveChain(t)}handleLoop(t){return this.handleCurveChain(t)}handleParityRegion(t){for(const e of t.children)e.dispatchToGeometryHandler(this)}handleUnionRegion(t){for(const e of t.children)e.dispatchToGeometryHandler(this)}}class Bn{constructor(t,e){this.fraction=t,this.otherCurveDetail=e}setFrom(t,e){e&&this.isSameFraction(t)&&(this.otherCurveDetail=t.otherCurveDetail?t.otherCurveDetail:this.otherCurveDetail),this.fraction=t.fraction}isSameFraction(t){return K.isSmallAngleRadians(this.fraction-t.fraction)}set(t,e){this.fraction=t,this.otherCurveDetail=e}}class Vn{static hasInteriorDetailAIntersections(t,e=K.smallAngleRadians){if(0===t.length)return!1;for(const i of t)if(i.detailA.fraction>e||i.detailA.fraction<1-e)return!0;return!1}collectFragmentAndAdvanceCut(t,e,i,s){if(!e.isSameFraction(i)){const n=t.clonePartialCurve(e.fraction,i.fraction);void 0!==n&&(n.startCut=e.otherCurveDetail,n.endCut=i.otherCurveDetail,s.push(n))}e.setFrom(i,!0)}collectSinglePrimitiveFragments(t,e,i){if(void 0===e||!Vn.hasInteriorDetailAIntersections(e))return void i.push(t.clone());e.sort(((t,e)=>t.detailA.fraction-e.detailA.fraction));const s=new Bn(0,void 0),n=new Bn(1,void 0);for(const r of e)n.set(r.detailA.fraction,r.detailB),this.collectFragmentAndAdvanceCut(t,s,n,i);n.set(1,void 0),this.collectFragmentAndAdvanceCut(t,s,n,i)}static cloneCurvesWithXYSplits(t,e){const i=new Vn;if(t instanceof ie){const s=[],n=ki.intersectionXYPairs(t,!1,e,!1);return i.collectSinglePrimitiveFragments(t,n,s),1===s.length?s[0]:Fi.createArray(s)}if(t instanceof We){const s=[];for(const n of t.children){const t=ki.intersectionXYPairs(n,!1,e,!1);i.collectSinglePrimitiveFragments(n,t,s)}return Fi.createArray(s)}}}class Ln{static testPointInOnOutLoopXY(t,e,i){let s;const n=Q.create(e,i);for(let r=0;Math.abs(r)<6;r=-1.2313*(r+.3212897)){s=yt.createXYAngle(e,i,W.createRadians(r));const o=s.getNormalRef(),a=[];for(const e of t.children)e instanceof ie&&e.appendPlaneIntersectionPoints(s,a);ie.snapAndRestrictDetails(a,!1,!0);let c,h,l=0,d=0,u=0;for(const t of a){if(t.intervalRole!==I.isolated&&void 0!==t.intervalRole&&u++,c=t.point.x-e,h=t.point.y-i,K.isSameCoordinateXY(c,h,0,0))return 0;const s=K.crossProductXYXY(o.x,o.y,c,h);if(n.isAlmostEqualXY(t.point))return 0;s<0?l++:s>0&&d++}if(0!==u)continue;const f=1&l;if(f===(1&d))return 1===f?1:-1}return-1}static testPointInOnOutParityRegionXY(t,e,i){let s=-1;for(const n of t.children)if(n instanceof Ke){const t=this.testPointInOnOutLoopXY(n,e,i);if(0===t)return 0;t>0&&(s=-s)}return s}static testPointInOnOutUnionRegionXY(t,e,i){for(const s of t.children){const t=this.testPointInOnOutRegionXY(s,e,i);if(t>=0)return t}return-1}static testPointInOnOutRegionXY(t,e,i){return t instanceof Ke?this.testPointInOnOutLoopXY(t,e,i):t instanceof Qe?this.testPointInOnOutParityRegionXY(t,e,i):t instanceof Zi?this.testPointInOnOutUnionRegionXY(t,e,i):-1}}class Un{constructor(){this.primitiveToPair=new Map,this.primitiveToIndex=new Map,this._numIndexedPrimitives=0}assignPrimitiveIndex(t){void 0!==t&&void 0===this.primitiveToIndex.get(t)&&this.primitiveToIndex.set(t,this._numIndexedPrimitives++)}insertPrimitiveToPair(t,e){if(t){const i=this.primitiveToPair.get(t);this.assignPrimitiveIndex(t),i?i.push(e):this.primitiveToPair.set(t,[e])}}insertPair(t){const e=t.detailA.curve;e&&this.insertPrimitiveToPair(e,t);const i=t.detailB.curve;i&&this.insertPrimitiveToPair(i,t)}splitAndAppendMissingClosedPrimitives(t,e=K.smallMetricDistance){for(const i of t){let t=!1;if(i instanceof De?t=i.sweep.isFullCircle:i instanceof Pe||i instanceof we||(t=i.startPoint().isAlmostEqualXY(i.endPoint(),e)),t&&!this.primitiveToPair.has(i)){const t=i.clonePartialCurve(0,.5),e=i.clonePartialCurve(.5,1);t&&e&&(this.insertPair(Pt.createCapture(vt.createCurveEvaluatedFraction(t,0),vt.createCurveEvaluatedFraction(e,1))),this.insertPair(Pt.createCapture(vt.createCurveEvaluatedFraction(t,1),vt.createCurveEvaluatedFraction(e,0))))}}}}class Zn{static assembleHalfEdgeGraph(t,e,i=K.smallMetricDistance){const s=new Un;for(const t of e)s.insertPair(t);t.length>s.primitiveToPair.size&&s.splitAndAppendMissingClosedPrimitives(t,i);const n=new Bi;for(const t of s.primitiveToPair.entries()){const e=t[0],s=t[1].reduce(((t,i)=>{if(!i.detailA.hasFraction1)return[...t,i];const s=Gn(i,e),n=vt.createCurveFractionPoint(e,s.fraction,s.point),r=vt.createCurveFractionPoint(e,s.fraction1,s.point1);return[...t,Pt.createCapture(n,n),Pt.createCapture(r,r)]}),[]);s.sort(((t,i)=>Wn(t,e)-Wn(i,e)));let r={point:e.startPoint(),fraction:0};for(const t of s){const s=Gn(t,e),o=K.restrictToInterval(s.fraction,0,1);r=this.addHalfEdge(n,e,r.point,r.fraction,s.point,o,i)}this.addHalfEdge(n,e,r.point,r.fraction,e.endPoint(),1,i)}return Ps.clusterAndMergeXYTheta(n,(t=>t.sortAngle)),n}static addHalfEdge(t,e,i,s,n,r,o=K.smallMetricDistance){if(i.isAlmostEqualXY(n,o))return{point:i,fraction:s};const a=t.createEdgeXYAndZ(i,0,n,0),c=vt.createCurveEvaluatedFractionFraction(e,s,r),h=a.edgeMate;return a.edgeTag=c,a.sortData=1,h.edgeTag=c,h.sortData=-1,a.sortAngle=qn(e,s,!1),h.sortAngle=qn(e,r,!0),{point:n,fraction:r}}static collectSignedLoop(t,e,i=1e-10,s){let n=s?0:rr.computeXYArea(t);return void 0===n&&(n=0),Math.abs(n)<i&&(n=0),t.computedAreaInPlanarSubdivision=n,n>0?e.positiveAreaLoops.push(t):n<0?e.negativeAreaLoops.push(t):e.slivers.push(t),n}static createLoopInFace(t,e){let i=t;const s=Ke.create();do{const t=i.edgeTag;if(t){let n;n=i.sortData>0?t.curve.clonePartialCurve(t.fraction,t.fraction1):t.curve.clonePartialCurve(t.fraction1,t.fraction),n&&(void 0!==e&&e(i,n,s),s.tryAddChild(n))}i=i.faceSuccessor}while(i!==t);return s}static isNullFace(t){const e=t.faceSuccessor.faceSuccessor===t;let i=!1;if(e){const e=Ps.curvatureSortKey(t),s=Ps.curvatureSortKey(t.faceSuccessor.edgeMate);K.isSameCoordinate(e,s)||(i=!0)}return e&&!i}static nonNullEdgeMate(t,e){if(this.isNullFace(e))return;let i=e.edgeMate;for(;this.isNullFace(i);)if(i=i.faceSuccessor.edgeMate,i===e)return;return i}static collectSignedLoopSetsInHalfEdgeGraph(t,e=1e-10){const i=Ts.collectConnectedComponentsWithExteriorParityMasks(t,void 0),s=[],n=new Map;for(const r of i){const i={positiveAreaLoops:[],negativeAreaLoops:[],slivers:[]},o=[];for(const s of r){const r=this.isNullFace(s),a=this.createLoopInFace(s,((e,i,s)=>{if(!r){const r=this.nonNullEdgeMate(t,e);if(void 0!==r){const t=n.get(r);if(void 0===t){const t=new je(s,i,void 0,void 0);n.set(e,t)}else t instanceof je&&(t.setB(s,i),o.push(t),n.delete(r))}}}));this.collectSignedLoop(a,i,e,r)}i.edges=o,s.push(i),n.clear()}return s}}function qn(t,e,i){const s=t.fractionToPointAndDerivative(e),n=i?-1:1;return Math.atan2(n*s.direction.y,n*s.direction.x)}function Wn(t,e){return t.detailA.curve===e?t.detailA.fraction:t.detailB.curve===e?t.detailB.fraction:void 0}function Gn(t,e){return t.detailA.curve===e?t.detailA:t.detailB.curve===e?t.detailB:void 0}class Hn extends me{constructor(){super(...arguments),this._point0=Q.create(),this._point1=Q.create()}handleArc3d(t){const e=this._activeMomentData,i=t.sweep.sweepRadians,s=.5*i;let n=Math.sin(s),r=Math.cos(s),o=Math.sin(i);W.isFullCircleRadians(i)&&(n=0,r=-1,o=0);const a=2*n*n*n*r/(s-n*r),c=n*n*n,h=.5*(i-o),l=.25*h*(1+a)-c*c*4/(9*h),d=.25*h*(1-a/3),u=4*n*n*n/(3*(i-o)),f=t.sweep.fractionToRadians(.5),g=t.radiansToRotatedBasis(f),p=g.origin.plusScaled(g.vectorU,u);e.accumulateXYProductsInCentroidalFrame(l,0,d,h,p,g.vectorU,g.vectorV);const m=t.fractionToPoint(0),x=t.fractionToPoint(1);e.accumulateTriangleMomentsXY(void 0,m,x)}handleLineString3d(t){this._activeMomentData.accumulateTriangleToLineStringMomentsXY(void 0,t.packedPoints)}handleLineSegment3d(t){const e=this._activeMomentData;t.startPoint(this._point0),t.endPoint(this._point1),e.accumulateTriangleMomentsXY(void 0,this._point0,this._point1)}handleLoop(t){const e=this._activeMomentData=ti.create();e.needOrigin=!1;for(const e of t.children)e.dispatchToGeometryHandler(this);return this._activeMomentData=void 0,e}handleParityRegion(t){const e=[];let i,s=0;for(const n of t.children)if(n instanceof Ke){const t=this.handleLoop(n);if(t){e.push(t);const n=Math.abs(t.quantitySum);n>s&&(s=n,i=t)}}if(i){const t=ti.create(),s=i.signFactor(1);t.accumulateProducts(i,s);for(const s of e)if(s!==i){const e=s.signFactor(-1);t.accumulateProducts(s,e)}return t}}handleUnionRegion(t){const e=ti.create();for(const i of t.children){const t=i.dispatchToGeometryHandler(this);if(t){const i=t.signFactor(1);e.accumulateProducts(t,i)}}return e}getStrokeOptions(){if(this._strokeOptions)return this._strokeOptions;const t=ye.createForCurves();return t.angleTol=W.createDegrees(5),this._strokeOptions=t,t}handleCurvePrimitive(t){const e=we.create(),i=this.getStrokeOptions();t.emitStrokes(e,i),this.handleLineString3d(e)}handleBSplineCurve3d(t){return this.handleCurvePrimitive(t)}handleBSplineCurve3dH(t){return this.handleCurvePrimitive(t)}handleTransitionSpiral(t){return this.handleCurvePrimitive(t)}}class Jn{startComponent(t){return!0}finishComponent(t){return!0}enterFace(t,e){return!0}leaveFace(t,e){return!0}}class Kn extends Jn{constructor(t,e){super(),this._inComponent=[!1,!1,!1],this._exteriorMask=e,this._faceSelectFunction=t}startComponent(t){return t.setMaskAroundFace(this._exteriorMask),!0}enterFace(t,e){const i=e.edgeTag;return 1!==e.edgeTag&&2!==e.edgeTag||(this._inComponent[i]=!this._inComponent[i]),this._faceSelectFunction(this._inComponent[1],this._inComponent[2])||e.setMaskAroundFace(this._exteriorMask),!0}leaveFace(t,e){const i=e.edgeTag;return 1!==e.edgeTag&&2!==e.edgeTag||(this._inComponent[i]=!this._inComponent[i]),!0}}class jn{static faceToFaceSearchFromOuterLoop(t,e,i,s,n){if(e.isMaskSet(i))return;if(!n.startComponent(e))return;const r=[];e.setMaskAroundFace(i);let o=e;do{let t=o,e=o.edgeMate;if(!e.isMaskSet(i)){r.push(o),r.push(e);let a=e.faceSuccessor;if(e.setMaskAroundFace(i),t=e,n.enterFace(r,e))for(;;){if(e=a.edgeMate,!e.isMaskSet(i)){if(e.setMaskAroundFace(i),!n.enterFace(r,e))return;r.push(a),r.push(e),a=e,t=e}if(a.setMask(s),a=a.faceSuccessor,a===t){if(n.leaveFace(r,a),r.length<=2)break;r.pop(),a=r[r.length-1],r.pop(),t=r[r.length-1]}if(a.isMaskSet(s))return}}o=o.faceSuccessor}while(o!==e);n.finishComponent(e)}static doPolygonBoolean(t,e,i,s){const n=new Bi,r=M.BOUNDARY_EDGE|M.PRIMARY_EDGE,o=rr.addLoopsWithEdgeTagToGraph(n,t,r,1),a=rr.addLoopsWithEdgeTagToGraph(n,e,r,2);if(s&&s("unmerged loops",n,"U"),o||a){Ps.splitIntersectingEdges(n),s&&s("After splitIntersectingEdges",n,"S"),Ps.clusterAndMergeXYTheta(n),s&&s("After clusterAndMergeXYTheta",n,"M"),new Ui(n).regularizeGraph(!0,!0),s&&s("After regularize",n,"MR");const t=Ts.findMinimumAreaFace(n);if(void 0===t)return;const e=M.EXTERIOR,r=n.grabMask(),o=n.grabMask(),a=e|r|o;n.clearMask(a);const c=new Kn(i,e);return this.faceToFaceSearchFromOuterLoop(n,t,r,o,c),s&&s("After faceToFaceSearchFromOuterLoop",n,"MRX"),n.dropMask(r),n.dropMask(o),n}}static doBinaryBooleanBetweenMultiLoopInputs(t,e,i,s,n,r){const o=new Bi,a=M.BOUNDARY_EDGE|M.PRIMARY_EDGE,c=tr.create(e,n);c.graph=o,c.faceAreaFunction=t=>Ts.signedFaceArea(t);for(const e of t)if(e.length>2){const t=new Qn(e,c.groupA);rr.addLoopsWithEdgeTagToGraph(o,e,a,t)}for(const t of s)if(t.length>2){const e=new Qn(t,c.groupB);rr.addLoopsWithEdgeTagToGraph(o,t,a,e)}return Ps.splitIntersectingEdges(o),Ps.clusterAndMergeXYTheta(o),new Ui(o).regularizeGraph(!0,!0),c.runClassificationSweep(i),r&&c.unmaskMaskedNullFaces(M.EXTERIOR),o}}!function(t){t[t.Union=0]="Union",t[t.Parity=1]="Parity",t[t.Intersection=2]="Intersection",t[t.NonBounding=-1]="NonBounding"}(B||(B={}));class Qn{constructor(t,e){this.region=t,this.parentGroup=e,this.sweepState=0}clearState(){this.sweepState=0}}class $n{constructor(t,e){this.members=[],this.parent=t,this.groupOpType=e,this._numIn=0}clearState(){for(const t of this.members)t.clearState();this._numIn=0}range(){const t=ut.createNull();for(const e of this.members)if(e.region instanceof Nt)e.region.extendRange(t);else{const i=ut.createFromVariantData(e.region);t.extendRange(i)}return t}getInOut(){return this.groupOpType===B.Union?this._numIn>0:this.groupOpType===B.Parity?K.isOdd(this._numIn):this.groupOpType===B.Intersection&&this._numIn===this.members.length}addMember(t,e=!1){if(t instanceof Ke||t instanceof Qe){const e=t.clone();rr.consolidateAdjacentPrimitives(e),this.members.push(new Qn(e,this))}else if(t instanceof Zi)for(const e of t.children)this.addMember(e);else if(Array.isArray(t))for(const e of t)this.addMember(e);else e&&t instanceof Pe&&this.members.push(new Qn(t,this))}recordMemberStateChange(t,e){const i=K.isOdd(t),s=K.isOdd(e);!i&&s?this._numIn++:i&&!s&&this._numIn--}}class tr{constructor(t,e){this.groupA=new $n(this,t),this.groupB=new $n(this,e),this.extraGeometry=new $n(this,B.NonBounding),this.binaryOp=V.Union}static create(t,e){return new tr(t,e)}addMembers(t,e){this.groupA.addMember(t),this.groupB.addMember(e),this.addConnectives()}addConnectives(){const t=this.groupA.range(),e=this.groupB.range(),i=t.union(e),s=rr.computeXYAreaTolerance(i);let n=.1;this._workSegment=Te.findExtremePointsInDirection(i.corners(),tr._bridgeDirection,this._workSegment),this._workSegment&&(n*=this._workSegment.point0Ref.distanceXY(this._workSegment.point1Ref));const r=[],o=t=>{const e=rr.computeXYArea(t);void 0===e||Math.abs(e)<s||(this._workSegment=Te.findExtremePointsInDirection(t,tr._bridgeDirection,this._workSegment),this._workSegment&&r.push(this._workSegment.point1Ref))};for(const t of[this.groupA.members,this.groupB.members])for(const e of t)if(e.region instanceof Ke)o(e.region);else if(e.region instanceof Qe)for(const t of e.region.children)o(t);const a=bt.createZero();for(const t of r){const e=n+bt.create(t,tr._bridgeDirection,a).intersectionWithRange3d(i).high,s=Q.createAdd2Scaled(t,1,tr._bridgeDirection,e),r=Pe.createXYXY(t.x,t.y,s.x,s.y);this.extraGeometry.addMember(r,!0)}}annotateAndMergeCurvesInGraph(t=K.smallMetricDistance){const e=[];for(const t of[this.groupA,this.groupB,this.extraGeometry])for(const i of t.members){let t=e.length;if(i.region instanceof Nt)for(rr.collectCurvePrimitives(i.region,e,!0,!0);t<e.length;t++)e[t].parent=i}const i=ki.allIntersectionsAmongPrimitivesXY(e,t),s=Zn.assembleHalfEdgeGraph(e,i,t);this.graph=s,this.faceAreaFunction=ir}runClassificationSweep(t,e){this._announceFaceFunction=e,this.binaryOp=t,this.graph.clearMask(M.EXTERIOR);for(const t of[this.groupA,this.groupB])t.clearState();const i=this.graph.grabMask(),s=this.graph.grabMask(),n=nr.create(this.graph);for(const t of n.components){const e=Ts.findMinimumAreaFace(t.faces,this.faceAreaFunction);if(e){const t=M.EXTERIOR|i|s;this.graph.clearMask(t),jn.faceToFaceSearchFromOuterLoop(this.graph,e,i,s,this)}}this.graph.dropMask(i),this.graph.dropMask(s)}unmaskMaskedNullFaces(t){for(const e of this.graph.allHalfEdges){const i=e.faceSuccessor;i.faceSuccessor===e&&e.getMask(t)&&i.getMask(t)&&(e.edgeMate.getMask(t)&&i.edgeMate.getMask(t)||(e.clearMask(t),i.clearMask(t)))}}getInOut(){return this.binaryOp===V.Union?this.groupA.getInOut()||this.groupB.getInOut():this.binaryOp===V.Intersection?this.groupA.getInOut()&&this.groupB.getInOut():this.binaryOp===V.AMinusB?this.groupA.getInOut()&&!this.groupB.getInOut():this.binaryOp===V.BMinusA?!this.groupA.getInOut()&&this.groupB.getInOut():this.binaryOp===V.Parity&&this.groupA.getInOut()!==this.groupB.getInOut()}recordTransitionAcrossEdge(t,e){const i=t=>{if(t.parentGroup.groupOpType===B.NonBounding)return t;if(0!==e){const i=t.sweepState;t.sweepState+=e,t.parentGroup.recordMemberStateChange(i,t.sweepState)}return t},s=t.edgeTag;if(s instanceof Qn)return i(s);if(s instanceof vt){const t=s.curve.parent;if(t instanceof Qn)return i(t)}}startComponent(t){return t.setMaskAroundFace(M.EXTERIOR),this._announceFaceFunction&&this._announceFaceFunction(this.graph,t,-1,ir(t)),!0}finishComponent(t){return!0}enterFace(t,e){this.recordTransitionAcrossEdge(e,1);const i=this.getInOut();return i||e.setMaskAroundFace(M.EXTERIOR),this._announceFaceFunction&&this._announceFaceFunction(this.graph,e,i?1:0,ir(e)),!0}leaveFace(t,e){return this.recordTransitionAcrossEdge(e,-1),!0}}function er(t,e,i,s){let n;n=t&&t.point1?-(t.point1.x-t.point.x)*(.5*(t.point.y+t.point1.y)-s.y):-(i.x-e.x)*(.5*(e.y+i.y)-s.y);let r=0;return t&&t.curve&&t.hasFraction1&&(t.curve instanceof Pe||t.curve instanceof De&&(r=t.curve.areaToChordXY(t.fraction,t.fraction1))),n+r}function ir(t){let e=0,i=t;do{e+=i.sortData*er(i.edgeTag,i,i.faceSuccessor,t)}while((i=i.faceSuccessor)!==t);return e}tr._bridgeDirection=$.createNormalized(1,-.12328974132467);class sr{constructor(t){this.faces=t,this.range=gt.createNull(),this.faceAreas=[]}buildFaceData(t,e){const i=e=>(t?t(e,this.range):this.range.extendXY(e.x,e.y),0);this.range.setNull();for(const t of this.faces)t.sumAroundFace(i);this.faceAreas.length=0,e||(e=t=>Ts.signedFaceArea(t));for(const t of this.faces)this.faceAreas.push(e(t))}}class nr{constructor(t){this.graph=t,this.components=[]}static create(t,e){const i=new nr(t),s=Ts.collectConnectedComponentsWithExteriorParityMasks(t,void 0);for(const t of s){const s=new sr(t);s.buildFaceData(e,ir),i.components.push(s)}return i}}!function(t){t[t.Union=0]="Union",t[t.Parity=1]="Parity",t[t.Intersection=2]="Intersection",t[t.AMinusB=3]="AMinusB",t[t.BMinusA=4]="BMinusA"}(V||(V={}));class rr{static computeXYAreaMoments(t){const e=new Hn,i=t.dispatchToGeometryHandler(e);if(i instanceof ti)return i.shiftOriginAndSumsToCentroidOfSums(),i}static computeXYAreaTolerance(t,e=K.smallMetricDistance){const i=.5*e;return i*(t.xLength()+t.yLength()+i)}static computeXYArea(t){const e=new Hn,i=t.dispatchToGeometryHandler(e);if(i instanceof ti)return i.quantitySum}static computeXYZWireMomentSums(t){const e=new Yn;e.visitLeaves(t);const i=e.momentData;return i.shiftOriginAndSumsToCentroidOfSums(),i}static addLoopsToGraph(t,e,i){if(e instanceof Ke){const s=e.getPackedStrokes();s&&this.addLoopsToGraph(t,s,i)}else if(e instanceof Qe)for(const s of e.children){const e=s.getPackedStrokes();e&&this.addLoopsToGraph(t,e,i)}else if(e instanceof it){const s=ms.directCreateFaceLoopFromCoordinates(t,e);void 0!==s&&i(t,s)}else if(Array.isArray(e)&&e.length>0)if(Q.isAnyImmediatePointType(e[0])){const s=ms.directCreateFaceLoopFromCoordinates(t,e);void 0!==s&&i(t,s)}else if(e[0]instanceof it)for(const s of e){const e=ms.directCreateFaceLoopFromCoordinates(t,s);void 0!==e&&i(t,e)}else for(const s of e)Array.isArray(s)&&this.addLoopsToGraph(t,s,i)}static addLoopsWithEdgeTagToGraph(t,e,i,s){const n=[];if(this.addLoopsToGraph(t,e,((t,e)=>{e&&(n.push(e),e.setMaskAndEdgeTagAroundFace(i,s,!0))})),n.length>0)return n}static finishGraphToPolyface(t,e){if(t)return e&&(ms.triangulateAllPositiveAreaFaces(t),ms.flipTriangles(t)),Rn.graphToPolyface(t)}static polygonXYAreaIntersectLoopsToPolyface(t,e,i=!1){const s=jn.doPolygonBoolean(t,e,((t,e)=>t&&e),this._graphCheckPointFunction);return this.finishGraphToPolyface(s,i)}static polygonXYAreaUnionLoopsToPolyface(t,e,i=!1){const s=jn.doPolygonBoolean(t,e,((t,e)=>t||e),this._graphCheckPointFunction);return this.finishGraphToPolyface(s,i)}static polygonXYAreaDifferenceLoopsToPolyface(t,e,i=!1){const s=jn.doPolygonBoolean(t,e,((t,e)=>t&&!e),this._graphCheckPointFunction);return this.finishGraphToPolyface(s,i)}static regionBooleanXY(t,e,i,s=K.smallMetricDistance){const n=Zi.create(),r=tr.create(B.Union,B.Union);r.addMembers(t,e),r.annotateAndMergeCurvesInGraph(s);const o=r.groupA.range().union(r.groupB.range()),a=this.computeXYAreaTolerance(o,s);return r.runClassificationSweep(i,((t,e,i,s)=>{if(!(e.countEdgesAroundFace()<2||Math.abs(s)<a||1!==i)){const t=Zn.createLoopInFace(e);t&&n.tryAddChild(t)}})),n}static polygonBooleanXYToPolyface(t,e,i,s=!1){const n=jn.doBinaryBooleanBetweenMultiLoopInputs(t,B.Union,e,i,B.Union,!0);return this.finishGraphToPolyface(n,s)}static polygonBooleanXYToLoops(t,e,i){const s=jn.doBinaryBooleanBetweenMultiLoopInputs(t,B.Union,e,i,B.Union,!0);if(!s)return;const n=Ts.collectExtendedBoundaryLoopsInGraph(s,M.EXTERIOR),r=[];for(const t of n){const e=new nt;for(const i of t)e.pushXYZ(i.x,i.y,i.z);e.pushWrap(1);const i=Ke.create();i.tryAddChild(we.createCapture(e)),r.push(i)}return rr.sortOuterAndHoleLoopsXY(r)}static constructPolygonWireXYOffset(t,e,i){return(new Ei).constructPolygonWireXYOffset(t,e,i)}static constructCurveXYOffset(t,e){const i=ve.create(e);return Ri.constructCurveXYOffset(t,i)}static testPointInOnOutRegionXY(t,e,i){return Ln.testPointInOnOutRegionXY(t,e,i)}static createLoopPathOrBagOfCurves(t,e=!0,i=!1){const s=t.length;if(0===s)return;let n,r=0,o=!1;e&&(r=K.maxXY(r,t[0].startPoint().distance(t[s-1].endPoint())));for(let e=0;e+1<s;e++)r=K.maxXY(r,t[e].endPoint().distance(t[e+1].startPoint()));K.isSmallMetricDistance(r)?(n=e?Ke.create():Fi.create(),o=!0):n=Ge.create();for(const e of t)n.tryAddChild(e);return o&&i&&rr.consolidateAdjacentPrimitives(n),n}static setCheckPointFunction(t){this._graphCheckPointFunction=t}static cloneCurvesWithXYSplits(t,e){return Vn.cloneCurvesWithXYSplits(t,e)}static splitToPathsBetweenBreaks(t,e){if(void 0===t)return;if(t instanceof ie)return t;const i=t.collectCurvePrimitives(),s=new Nn(e);for(const t of i)s.announceCurvePrimitive(t);return s.grabResult()}static collectInsideAndOutsideOffsets(t,e,i){return Ri.collectInsideAndOutsideXYOffsets(t,e,i)}static collectChains(t,e=K.smallMetricDistance){return Ri.collectChains(t,e)}static splitPathsByRegionInOnOutXY(t,e){const i={insideParts:[],outsideParts:[],coincidentParts:[]},s=rr.cloneCurvesWithXYSplits(t,e),n=rr.splitToPathsBetweenBreaks(s,!0);if(n instanceof qe)for(const t of n.children){const s=qe.createCurveLocationDetailOnAnyCurvePrimitive(t);s&&or(t,rr.testPointInOnOutRegionXY(e,s.point.x,s.point.y),i.outsideParts,i.coincidentParts,i.insideParts)}else if(n instanceof ie){const t=qe.createCurveLocationDetailOnAnyCurvePrimitive(n);t&&or(n,rr.testPointInOnOutRegionXY(e,t.point.x,t.point.y),i.outsideParts,i.coincidentParts,i.insideParts)}return i}static rectangleEdgeTransform(t,e=!0){if(t instanceof we)return this.rectangleEdgeTransform(t.packedPoints);if(t instanceof it){let i;if(e&&5===t.length){if(!K.isSmallMetricDistance(t.distanceIndexIndex(0,4)))return;i=t}else if(e||4!==t.length){if(t.length<(e?5:4))return;if(i=nt.create(t),$e.compressInPlaceByShortEdgeLength(i,K.smallMetricDistance),i.length<(e?5:4))return}else i=t;const s=i.vectorIndexIndex(0,1),n=i.vectorIndexIndex(0,3),r=i.vectorIndexIndex(1,2),o=s.crossProduct(n);if(o.normalizeInPlace()&&r.isAlmostEqual(n)&&s.isPerpendicularTo(n))return pt.createOriginAndMatrixColumns(i.getPoint3dAtUncheckedPointIndex(0),s,n,o)}else{if(Array.isArray(t))return this.rectangleEdgeTransform(new se(t),e);if(t instanceof Ke&&1===t.children.length&&t.children[0]instanceof we)return this.rectangleEdgeTransform(t.children[0].packedPoints,!0);if(t instanceof Fi&&1===t.children.length&&t.children[0]instanceof we)return this.rectangleEdgeTransform(t.children[0].packedPoints,e);if(t instanceof We&&!t.checkForNonLinearPrimitives()){const e=t.getPackedStrokes();if(e)return this.rectangleEdgeTransform(e)}}}static consolidateAdjacentPrimitives(t,e){const i=new On(e);t.dispatchToGeometryHandler(i)}static sortOuterAndHoleLoopsXY(t){const e=[];for(const i of t)if(i instanceof Ke)lr.pushLoop(e,i);else if(i instanceof it){const t=Ke.createPolygon(i);lr.pushLoop(e,t)}return lr.sortAsAnyRegion(e)}static constructAllXYRegionLoops(t,e=K.smallMetricDistance){const i=rr.collectCurvePrimitives(t,void 0,!0,!0),s=this.curveArrayRange(i),n=this.computeXYAreaTolerance(s,e),r=ki.allIntersectionsAmongPrimitivesXY(i,e),o=Zn.assembleHalfEdgeGraph(i,r,e);return Zn.collectSignedLoopSetsInHalfEdgeGraph(o,n)}static collectCurvePrimitives(t,e,i=!1,s=!1){const n=void 0===e?[]:e;if(t instanceof ie)t.collectCurvePrimitives(n,i,s);else if(t instanceof qe)t.collectCurvePrimitives(n,i,s);else if(Array.isArray(t))for(const e of t)this.collectCurvePrimitives(e,n,i,s);return n}static expandLineStrings(t){const e=[];for(const i of t)if(i instanceof we)for(let t=0;t+1<i.packedPoints.length;t++){const s=i.getIndexedSegment(t);void 0!==s&&e.push(s)}else e.push(i);return e}static curveArrayRange(t,e){const i=ut.create();if(t instanceof Nt)t.extendRange(i,e);else if(Array.isArray(t))for(const s of t)s instanceof Nt?s.extendRange(i,e):s instanceof Q?i.extendPoint(s,e):s instanceof nt?i.extendRange(s.getRange(e)):Array.isArray(s)&&i.extendRange(this.curveArrayRange(s,e));return i}}function or(t,e,i,s,n){e>0?n.push(t):e<0?i.push(t):s.push(t)}class ar{}class cr extends ar{get signedArea(){return this._signedArea}constructor(t){super(),this.data=t,this._signedArea=gr.areaXY(t)}classifyPointXY(t){return gr.classifyPointInPolygonXY(t.x,t.y,this.data)}getAnyInteriorPoint(){for(let t=0;t<this.data.length;t++){const e=this.constructInteriorPointNearEdge(t,.2349);if(void 0!==e)return e}}grabPolygon(){return this.data}grabLoop(){return Ke.createPolygon(this.data)}reverseForAreaSign(t){t*this._signedArea<0&&(this.data.reverseInPlace(),this._signedArea*=-1)}constructInteriorPointNearEdge(t,e){if(t+1<this.data.length){const i=this.data.getPoint3dAtUncheckedPointIndex(t),s=this.data.getPoint3dAtUncheckedPointIndex(t+1),n=i.vectorTo(s),r=i.interpolate(e,s);if(n.rotate90CCWXY(n),n.normalizeInPlace()){this._signedArea<0&&n.scaleInPlace(-1);const t=Math.sqrt(Math.abs(this._signedArea));for(let e=1e-5;e<3;e*=5){const i=r.plusScaled(n,e*t);if(1===this.classifyPointXY(i))return i}}}}}class hr extends ar{get signedArea(){return this._signedArea}constructor(t){super(),this.data=t;const e=rr.computeXYAreaMoments(t);this._signedArea=void 0!==e?e.quantitySum:0}classifyPointXY(t){return rr.testPointInOnOutRegionXY(this.data,t.x,t.y)}constructInteriorPointNearChild(t,e){if(t<this.data.children.length){const i=this.data.children[t].fractionToPointAndUnitTangent(e);i.direction.rotate90CCWXY(i.direction),this._signedArea<0&&i.direction.scaleInPlace(-1);const s=Math.sqrt(Math.abs(this._signedArea));for(let t=1e-5;t<3;t*=5){const e=i.fractionToPoint(t*s);if(1===this.classifyPointXY(e))return e}}}getAnyInteriorPoint(){for(let t=0;t<this.data.children.length;t++){const e=this.constructInteriorPointNearChild(t,.2349);if(void 0!==e)return e}}grabPolygon(){const t=this.data.cloneStroked();if(t instanceof We){const e=we.create();for(const i of t.children)i instanceof ie&&i.emitStrokes(e);return e.numPoints()>0?e.packedPoints:void 0}}grabLoop(){return this.data}reverseForAreaSign(t){t*this._signedArea<0&&(this.data.reverseChildrenInPlace(),this._signedArea*=-1)}}class lr{constructor(t,e){this._loopCarrier=t instanceof st?new cr(t):new hr(t),this.range=e,this.sortKey=Math.abs(this._loopCarrier.signedArea),this.isHole=!1}static pushPolygon(t,e){const i=e.getRange(),s=new lr(e,i);return s.sortKey>0&&(t.push(s),!0)}static pushLoop(t,e){const i=e.range(),s=new lr(e,i);return s.sortKey>0&&(t.push(s),!0)}static assignParentsAndDepth(t){t.sort(((t,e)=>e.sortKey-t.sortKey));for(let e=t.length;e-- >0;){const i=t[e],s=i._loopCarrier.getAnyInteriorPoint();if(void 0!==s){t[e].parentIndex=void 0,t[e].outputSetIndex=void 0;for(let n=e;n-- >0;){const e=t[n];if(e.range.containsXY(s.x,s.y)&&1===e._loopCarrier.classifyPointXY(s)){i.parentIndex=n;break}}}}}static assemblePolygonSet(t){const e=[];for(const i of t){i.isHole=!1;const s=i.parentIndex;void 0!==s&&(i.isHole=!t[s].isHole),i.isHole?(i._loopCarrier.reverseForAreaSign(-1),e[t[s].outputSetIndex].push(i._loopCarrier.grabPolygon())):(i._loopCarrier.reverseForAreaSign(1),i.outputSetIndex=e.length,e.push([]),e[i.outputSetIndex].push(i._loopCarrier.grabPolygon()))}return e}static assembleLoopSet(t){const e=[],i=t.length;for(let s=0;s<i;s++){const n=t[s],r=n.parentIndex;if(n.isHole=void 0!==r&&!t[r].isHole,!n.isHole){n._loopCarrier.reverseForAreaSign(1);const r=n._loopCarrier.grabLoop();let o;for(let e=s+1;e<i;e++){const i=t[e];i.parentIndex===s&&(void 0===o?(o=Qe.create(),o.tryAddChild(r),i._loopCarrier.reverseForAreaSign(-1),o.tryAddChild(i._loopCarrier.grabLoop())):(i._loopCarrier.reverseForAreaSign(-1),o.tryAddChild(i._loopCarrier.grabLoop())))}void 0!==o?e.push(o):void 0!==r&&e.push(r)}}return e}static sortAsAnyRegion(t){this.assignParentsAndDepth(t);const e=this.assembleLoopSet(t);if(1===e.length)return e[0];{const t=Zi.create();for(const i of e)t.tryAddChild(i);return t}}static sortAsArrayOfArrayOfPolygons(t){return this.assignParentsAndDepth(t),this.assemblePolygonSet(t)}grabPolygon(){return this._loopCarrier.grabPolygon()}grabLoop(){return this._loopCarrier.grabLoop()}reverseForAreaSign(t){this._loopCarrier.reverseForAreaSign(t)}getAnyInteriorPoint(){return this._loopCarrier.getAnyInteriorPoint()}}class dr{constructor(){this.point=new Q,this.a=0,this.v=new $,this.code=_.Unknown,this.closestEdgeIndex=0,this.closestEdgeParam=0}invalidate(){this.point.setZero(),this.a=0,this.v.setZero(),this.code=_.Unknown,this.closestEdgeIndex=0,this.closestEdgeParam=0}static create(t){return void 0===t?t=new dr:t.invalidate(),t}copyContentsFrom(t){this.point.setFrom(t.point),this.a=t.a,this.v.setFrom(t.v),this.code=t.code,this.closestEdgeIndex=t.closestEdgeIndex,this.closestEdgeParam=t.closestEdgeParam}get isValid(){return this.code!==_.Unknown}get isInsideOrOn(){return this.code===_.InsidePolygon||this.code===_.OnPolygonVertex||this.code===_.OnPolygonEdgeInterior||this.code===_.InsidePolygonProjectsToVertex||this.code===_.InsidePolygonProjectsToEdgeInterior}}class ur{constructor(t){this.xyz=t,this.edge=void 0,this.sortCoordinate0=this.sortCoordinate1=0,this.sortDelta=0,this.isNotch=!1}static createCaptureWithReturnEdge(t){const e=new ur(t);return t.length>=2&&(e.edge=bt.createStartEnd(t.front(),t.back())),e}setSortCoordinates(t){this.sortDelta=this.edge.direction.dotProduct(t.direction);const e=t.dotProductToPoint(this.edge.origin);this.sortDelta>=0?(this.sortCoordinate0=e,this.sortCoordinate1=e+this.sortDelta):(this.sortCoordinate0=e+this.sortDelta,this.sortCoordinate1=e)}containsSortLimits(t){return t.sortCoordinate0>=this.sortCoordinate1||t.sortCoordinate0<=this.sortCoordinate0||t.sortCoordinate1<=this.sortCoordinate0||t.sortCoordinate1>=this.sortCoordinate1?0:this.sortDelta*t.sortDelta>0?1:-1}absorb(t){this.xyz.pushFromGrowableXYZArray(t.xyz),this.sortCoordinate0=t.sortCoordinate1}static sortFunction(t,e){return t.sortCoordinate0-e.sortCoordinate0>0?1:-1}front(t){return this.xyz.front(t)}back(t){return this.xyz.back(t)}}class fr{constructor(){this.inputLoops=[],this.outputLoops=[]}mostDistantPoint(t,e,i){let s,n=-1;i.setZero();for(const r of this.inputLoops)r.front(e),s=e.distanceSquared(t),s>n&&(n=s,i.setFromPoint3d(e)),r.back(e),s=e.distanceSquared(t),s>n&&(n=s,i.setFromPoint3d(e))}sortInputs(){if(this.inputLoops.length>0&&this.inputLoops[0].xyz.length>0){const t=this.inputLoops[0].xyz.front(),e=Q.create(),i=Q.create();this.mostDistantPoint(t,e,i),this.mostDistantPoint(i,e,t);const s=bt.createStartEnd(t,i);s.direction.normalizeInPlace();for(const t of this.inputLoops)t.setSortCoordinates(s);this.inputLoops.sort(((t,e)=>ur.sortFunction(t,e)))}}sortAndMergeLoops(){this.sortInputs();const t=this.inputLoops,e=this.outputLoops,i=[];e.length=0;for(const s of t){for(s.isNotch=!1;i.length>0;){const t=i[i.length-1],n=t.containsSortLimits(s);if(0!==n){if(1===n){s.isNotch=!1;break}t.absorb(s),s.isNotch=!0;break}t.isNotch||e.push(t),i.pop()}i.push(s)}for(const t of i)t.isNotch||e.push(t)}}class gr{static sumTriangleAreas(t){let e=0;const i=t.length;if(Array.isArray(t)){if(i>=3){const s=t[0],n=s.vectorTo(t[1]);let r=$.create();for(let o=2;o<i;o++)r=s.vectorTo(t[o],r),e+=n.crossProductMagnitude(r),n.setFrom(r)}return.5*e}const s=$.create();for(let n=2;n<i;n++)t.crossProductIndexIndexIndex(0,n-1,n,s),e+=s.magnitude();return.5*e}static sumTriangleAreasPerpendicularToUpVector(t,e){let i=e.magnitude();i<K.smallMetricDistance&&(e=$.create(0,0,1),i=1);let s=0;const n=t.length;if(Array.isArray(t)){if(n>=3){const i=t[0],r=i.vectorTo(t[1]);let o=$.create();for(let a=2;a<n;a++)o=i.vectorTo(t[a],o),s+=r.tripleProduct(o,e),r.setFrom(o)}return.5*s/i}const r=$.create();for(let i=2;i<n;i++)t.crossProductIndexIndexIndex(0,i-1,i,r),s+=r.dotProduct(e);return.5*s/i}static sumTriangleAreasXY(t){let e=0;const i=t.length;if(i>=3){const s=t[0],n=s.vectorTo(t[1]);let r=$.create();for(let o=2;o<i;o++)r=s.vectorTo(t[o],r),e+=n.crossProductXY(r),n.setFrom(r)}return e*=.5,e}static areaNormalGo(t,e){e?e.setZero():e=new $;const i=t.length;if(3===i)t.crossProductIndexIndexIndex(0,1,2,e);else if(i>3)for(let s=2;s<i;s++)t.accumulateCrossProductIndexIndexIndex(0,s-1,s,e);return e.scaleInPlace(.5),e.isZero?void 0:e}static areaNormal(t,e){return e||(e=$.create()),gr.areaNormalGo(new se(t),e),e}static area(t){return gr.areaNormal(t).magnitude()}static areaXY(t){let e=0;if(t instanceof it){if(t.length>2){const i=t.getXAtUncheckedPointIndex(0),s=t.getYAtUncheckedPointIndex(0);let n,r,o=t.getXAtUncheckedPointIndex(1)-i,a=t.getYAtUncheckedPointIndex(1)-s;for(let c=1;c+1<t.length;c++,o=n,a=r)n=t.getXAtUncheckedPointIndex(c)-i,r=t.getYAtUncheckedPointIndex(c)-s,e+=K.crossProductXYXY(o,a,n,r)}}else for(let i=1;i+1<t.length;i++)e+=t[0].crossProductToPointsXY(t[i],t[i+1]);return.5*e}static sumAreaXY(t){let e=0;for(const i of t)e+=this.areaXY(i);return e}static centroidAreaNormal(t){if(Array.isArray(t)){const e=new se(t);return this.centroidAreaNormal(e)}const e=t.length;if(3===e){const e=t.crossProductIndexIndexIndex(0,1,2),i=.5*e.magnitude(),s=t.getPoint3dAtCheckedPointIndex(0);t.accumulateScaledXYZ(1,1,s),t.accumulateScaledXYZ(2,1,s),s.scaleInPlace(1/3);const n=bt.createCapture(s,e);return n.tryNormalizeInPlaceWithAreaWeight(i)?n:void 0}if(e>=3){const i=$.createZero();for(let s=2;s<e;s++)t.accumulateCrossProductIndexIndexIndex(0,s-1,s,i);i.normalizeInPlace();const s=t.getPoint3dAtCheckedPointIndex(0),n=$.create(),r=$.create();t.vectorXYAndZIndex(s,1,n);let o=$.create();const a=$.createZero(),c=$.createZero();let h;for(let l=2;l<e;l++){t.vectorXYAndZIndex(s,l,r),o=n.crossProduct(r,o),h=i.dotProduct(o),c.addInPlace(o);const e=h/6;a.plus2Scaled(n,e,r,e,a),n.setFrom(r)}const l=.5*c.magnitude(),d=K.conditionalDivideFraction(1,l);if(void 0!==d){const t=bt.createCapture(s.plusScaled(a,d),c);return t.tryNormalizeInPlaceWithAreaWeight(l),t}}}static centroidAndAreaXY(t,e){let i=0;if(e.set(0,0),t.length<3)return;const s=t[0];let n=J.create(0,0),r=0;for(let e=1;e+1<t.length;e++){const i=s.vectorTo(t[e]),o=s.vectorTo(t[e+1]),a=i.crossProduct(o);n=n.plus(i.plus(o).scale(a)),r+=a}i=.5*r;const o=K.conditionalDivideFraction(1,6*i);if(void 0!==o)return e.setFrom(s.plusScaled(n,o)),i;e.setFrom(s)}static unitNormal(t,e){e.setZero();let i=t.length;return i>1&&t.getPoint3dAtUncheckedPointIndex(0).isExactEqual(t.getPoint3dAtUncheckedPointIndex(i-1))&&--i,3===i?(t.crossProductIndexIndexIndex(0,1,2,e),e.normalizeInPlace()):4===i?(t.vectorIndexIndex(0,2,gr._vector0),t.vectorIndexIndex(1,3,gr._vector1),gr._vector0.crossProduct(gr._vector1,e),e.normalizeInPlace()):(gr.areaNormalGo(t,e),e.normalizeInPlace())}static addSecondMomentAreaProducts(t,e,i){this.addSecondMomentTransformedProducts(gr._triangleMomentWeights,t,e,2,i)}static addSecondMomentVolumeProducts(t,e,i){this.addSecondMomentTransformedProducts(gr._tetrahedralMomentWeights,t,e,3,i)}static addSecondMomentTransformedProducts(t,e,i,s,n){const r=gr._normal;if(gr.unitNormal(e,r)){const o=gr._vector0,a=gr._vector1,c=gr._vector2,h=gr._matrixA,l=gr._matrixB,d=gr._matrixC,u=e.vectorXYAndZIndex(i,0,gr._vectorOrigin),f=e.length;let g=0;for(let p=2;p<f;p++)2===s?(e.vectorIndexIndex(0,p-1,o),e.vectorIndexIndex(0,p,a),g=r.tripleProduct(o,a),h.setOriginAndVectors(u,o,a,r),h.multiplyMatrixMatrix(t,l),l.multiplyMatrixMatrixTranspose(h,d),n.addScaledInPlace(d,g)):3===s&&(e.vectorXYAndZIndex(i,0,o),e.vectorXYAndZIndex(i,p-1,a),e.vectorXYAndZIndex(i,p,c),g=o.tripleProduct(a,c),h.setOriginAndVectors(i,o,a,c),h.multiplyMatrixMatrix(t,l),l.multiplyMatrixMatrixTranspose(h,d),n.addScaledInPlace(d,g))}}static testXYPolygonTurningDirections(t){let e=t.length,i=e-1;for(;i>1&&t[i].x===t[0].x&&t[i].y===t[0].y;)e=i--;if(e>2){let s=H.create(t[i].x-t[i-1].x,t[i].y-t[i-1].y);const n=H.create(t[0].x-t[i].x,t[0].y-t[i].y),r=s.x*n.y-s.y*n.x;for(let i=1;i<e;i++)if(s=n.clone(),H.create(t[i].x-t[i-1].x,t[i].y-t[i-1].y,n),(s.x*n.y-s.y*n.x)*r<=0)return 0;return r>0?1:-1}return 0}static isConvex(t){if(!(t instanceof it))return this.isConvex(new se(t));let e=t.length;e>1&&t.getPoint3dAtUncheckedPointIndex(0).isExactEqual(t.getPoint3dAtUncheckedPointIndex(e-1))&&--e;const i=$.create();if(!this.unitNormal(t,i))return!1;let s=0,n=0;const r=this._vector0;let o=$.createStartEnd(t.getPoint3dAtUncheckedPointIndex(e-1),t.getPoint3dAtUncheckedPointIndex(0),this._vector1);for(let a=1;a<=e;a++){r.setFromVector3d(o),o=$.createStartEnd(t.getPoint3dAtUncheckedPointIndex(a-1),t.getPoint3dAtUncheckedPointIndex(a%e),o);const c=i.tripleProduct(r,o);c>=0?s+=c:n+=c}return Math.abs(n)<K.smallMetricDistanceSquared*s}static classifyPointInPolygon(t,e,i){const s=new Dt(t,e);let n=0;const r=i.length;let o,a=-1;for(n=0;n<r;n++)if(o=n+1,o>=r&&(o=0),s.tryStartEdge(i[n].x,i[n].y,i[o].x,i[o].y)){a=o;break}if(!(a<0)){for(let t=1;t<=r;t++)if(o=a+t,o>=r&&(o-=r),!s.advance(i[o].x,i[o].y))return s.classifyCounts();return s.classifyCounts()}}static classifyPointInPolygonXY(t,e,i){const s=new Dt(t,e);let n=0;const r=i.length;let o,a=-1;for(n=0;n<r;n++)if(o=n+1,o>=r&&(o=0),s.tryStartEdge(i.getXAtUncheckedPointIndex(n),i.getYAtUncheckedPointIndex(n),i.getXAtUncheckedPointIndex(o),i.getYAtUncheckedPointIndex(o))){a=o;break}if(!(a<0)){for(let t=1;t<=r;t++)if(o=a+t,o>=r&&(o-=r),!s.advance(i.getXAtUncheckedPointIndex(o),i.getYAtUncheckedPointIndex(o)))return s.classifyCounts();return s.classifyCounts()}}static orientLoopsCCWForOutwardNormalInPlace(t,e){if(t instanceof it)return this.orientLoopsCCWForOutwardNormalInPlace([t],e);const i=[],s=$.create();let n=0;for(const r of t)if(this.unitNormal(r,s)){const t=s.dotProduct(e);i.push(t),t<=0&&r.reverseInPlace(),n++}else i.push(0);return n}static sortOuterAndHoleLoopsXY(t){const e=[];for(const i of t)lr.pushPolygon(e,i);return lr.sortAsArrayOfArrayOfPolygons(e)}static sortOuterAndHoleLoops(t,e){const i=Je.createRightHandedFrame(e,t),s=i?.inverse(),n=[];if(void 0!==s)for(const e of t){const t=new nt(e.length);for(const i of e.points)t.push(s.multiplyPoint3d(i));n.push(t)}const r=gr.sortOuterAndHoleLoopsXY(n),o=[];if(void 0!==i)for(const t of r){const e=[];for(const s of t){const t=new nt(s.length);for(const e of s.points)t.push(i.multiplyPoint3d(e));e.push(t)}o.push(e)}return o}static closestPointOnBoundary(t,e,i=K.smallMetricDistance,s){if(!(t instanceof it))return this.closestPointOnBoundary(new se(t),e,i,s);const n=i*i;let r=t.length;for(;r>1&&!(t.distanceSquaredIndexIndex(0,r-1)>n);)--r;if(s=dr.create(s),0===r)return s;if(1===r)return t.getPoint3dAtUncheckedPointIndex(0,s.point),s.a=s.point.distance(e),s.v.setZero(),s.code=_.OnPolygonVertex,s.closestEdgeIndex=0,s.closestEdgeParam=0,s;let o=r-1,a=K.largeCoordinateResult;for(let i=0;i<r;++i){let c=i+1;c===r&&(c=0);const h=t.distanceSquaredIndexIndex(i,c);if(h<=n)continue;const l=t.distanceSquaredIndexXYAndZ(i,e),d=t.dotProductIndexIndexXYAndZ(i,c,e)/h;if(d<=0){const r=l;if(r<=n)return t.getPoint3dAtUncheckedPointIndex(i,s.point),s.a=Math.sqrt(r),s.v.setZero(),s.code=_.OnPolygonVertex,s.closestEdgeIndex=i,s.closestEdgeParam=0,s;r<a&&t.dotProductIndexIndexXYAndZ(i,o,e)<=0&&(t.getPoint3dAtUncheckedPointIndex(i,s.point),s.a=Math.sqrt(r),t.crossProductIndexIndexIndex(i,o,c,s.v),s.code=_.OnPolygonVertex,s.closestEdgeIndex=i,s.closestEdgeParam=0,a=r)}else if(d<=1){const r=l-d*d*h;if(r<=n){const e=l;if(d<=.5&&e<=n)return t.getPoint3dAtUncheckedPointIndex(i,s.point),s.a=Math.sqrt(e),s.v.setZero(),s.code=_.OnPolygonVertex,s.closestEdgeIndex=i,s.closestEdgeParam=0,s;const o=r+(1-d)*(1-d)*h;return d>.5&&o<=n?(t.getPoint3dAtUncheckedPointIndex(c,s.point),s.a=Math.sqrt(o),s.v.setZero(),s.code=_.OnPolygonVertex,s.closestEdgeIndex=c,s.closestEdgeParam=0,s):(t.interpolateIndexIndex(i,d,c,s.point),s.a=Math.sqrt(r),s.v.setZero(),s.code=_.OnPolygonEdgeInterior,s.closestEdgeIndex=i,s.closestEdgeParam=d,s)}r<a&&(t.interpolateIndexIndex(i,d,c,s.point),s.a=Math.sqrt(r),t.crossProductIndexIndexXYAndZ(i,c,e,s.v),s.code=_.OnPolygonEdgeInterior,s.closestEdgeIndex=i,s.closestEdgeParam=d,a=r)}o=i}return s}static intersectRay3d(t,e,i=K.smallMetricDistance,s){if(!(t instanceof it))return this.intersectRay3d(new se(t),e,i,s);if(!this.unitNormal(t,this._normal))return dr.create(s);this._workPlane=yt.createXYZUVW(t.getXAtUncheckedPointIndex(0),t.getYAtUncheckedPointIndex(0),t.getZAtUncheckedPointIndex(0),this._normal.x,this._normal.y,this._normal.z,this._workPlane);const n=Q.createZero(this._workXYZ),r=e.intersectionWithPlane(this._workPlane,n);if(void 0===r)return dr.create(s);if((s=this.closestPointOnBoundary(t,n,i,s)).isValid){s.point.setFrom(n),s.a=r;const t=s.v.dotProduct(this._normal);0===t||(_.OnPolygonVertex===s.code?s.code=t>0?_.InsidePolygonProjectsToVertex:_.OutsidePolygonProjectsToVertex:_.OnPolygonEdgeInterior===s.code&&(s.code=t>0?_.InsidePolygonProjectsToEdgeInterior:_.OutsidePolygonProjectsToEdgeInterior))}return s}static intersectSegment(t,e,i,s=K.smallMetricDistance,n){return this._workRay=bt.createStartEnd(e,i,this._workRay),this.intersectRay3d(t,this._workRay,s,n)}static computeEdgeDataXY(t,e,i,s,n=K.smallMetricDistance,r){const o=e%t.length,a=(o+1)%t.length;t.vectorIndexIndex(o,a,s).unitPerpendicularXY(s).negate(s);const c=t.getXAtUncheckedPointIndex(o)-i.x,h=t.getYAtUncheckedPointIndex(o)-i.y;let l=K.dotProductXYXY(c,h,s.x,s.y);const d=K.crossProductXYXY(c,h,s.x,s.y),u=K.distanceXYXY(t.getXAtUncheckedPointIndex(o),t.getYAtUncheckedPointIndex(o),t.getXAtUncheckedPointIndex(a),t.getYAtUncheckedPointIndex(a));let f=K.safeDivideFraction(d,u,0);return K.isSameCoordinate(0,l,n)&&(l=0),K.isSameCoordinate(0,f,n)?f=0:K.isSameCoordinate(1,f,n)&&(f=1),H.create(l,f,r)}static convexBarycentricCoordinatesOnEdge(t,e,i,s,n,r,o,a){const c=!i.isZero&&0===s.x&&K.isIn01(s.y),h=!r.isZero&&0===o.x&&K.isIn01(o.y);if(c&&h)return a.fill(0),a[n]=1,a;const l=t.length;if(c){a.fill(0);const t=e,i=n,r=s.y;return a[t]=1-r,a[i]=r,a}if(h){a.fill(0);const t=n,e=(n+1)%l,i=o.y;return a[t]=1-i,a[e]=i,a}}static convexBarycentricCoordinates(t,i,s=K.smallMetricDistance){if(Array.isArray(t))return this.convexBarycentricCoordinates(new se(t),i);let n=t.length;for(;n>1&&t.getPoint3dAtUncheckedPointIndex(0).isExactEqual(t.getPoint3dAtUncheckedPointIndex(n-1));)--n;if(n<3||!gr.unitNormal(t,this._normal))return;const r=this._workMatrix3d=xt.createRigidHeadsUp(this._normal,p.ZXY,this._workMatrix3d),o=new nt(n);for(let e=0;e<n;++e)o.push(r.multiplyInverseXYZAsPoint3d(t.getXAtUncheckedPointIndex(e),t.getYAtUncheckedPointIndex(e),t.getZAtUncheckedPointIndex(e),this._workXYZ));const a=this._workXYZ=r.multiplyInverseXYZAsPoint3d(i.x,i.y,i.z,this._workXYZ);let c=n-1;const h=this._vector0,l=this._workXY0=this.computeEdgeDataXY(o,c,a,h,s,this._workXY0);if(l.x<0)return;const d=$.createFrom(h,this._vector1),u=this._workXY1=H.createFrom(l,this._workXY1),f=Array(t.length).fill(0),g=s>0?1/(s*s):K.largeCoordinateResult;let m=0;for(let t=0;t<n;++t){const i=$.createFrom(h,this._vector2),r=this._workXY2=t<n-1?this.computeEdgeDataXY(o,t,a,i,s,this._workXY2):H.createFrom(l,this._workXY2);if(r.x<0)return;if(void 0!==this.convexBarycentricCoordinatesOnEdge(o,c,d,u,t,i,r,f))return f;if(0===i.x&&0===i.y)continue;if(0===u.x||0===r.x)continue;const p=Math.abs(d.crossProductXY(i)),x=K.conditionalDivideCoordinate(p,u.x*r.x,g);if(void 0===x)return void e(!1);f[t]=x,m+=x,d.setFrom(i),u.setFrom(r),c=t}const x=K.conditionalDivideCoordinate(1,m);if(void 0!==x){for(let t=0;t<n;++t)f[t]*=x;return f}e(!1)}}gr._triangleMomentWeights=zt.createRowValues(2/24,1/24,0,4/24,1/24,2/24,0,4/24,0,0,0,0,4/24,4/24,0,.5),gr._tetrahedralMomentWeights=zt.createRowValues(1/60,1/120,1/120,1/24,1/120,1/60,1/120,1/24,1/120,1/120,1/60,1/24,1/24,1/24,1/24,1/6),gr._vector0=$.create(),gr._vector1=$.create(),gr._vector2=$.create(),gr._vectorOrigin=$.create(),gr._normal=$.create(),gr._matrixA=zt.createIdentity(),gr._matrixB=zt.createIdentity(),gr._matrixC=zt.createIdentity();class pr{static splitConvexPolygonInsideOutsidePlane(t,e,i,s,n){const r=pr._xyz0Work,o=pr._xyz1Work,a=pr._xyz2Work,c=e.length;if(i.clear(),s.clear(),c>2){e.back(r),n.setNull();let h=t.altitude(r);n.extendX(h);for(let l=0;l<c;l++){e.getPoint3dAtUncheckedPointIndex(l,o);const c=t.altitude(o);n.extendX(c);let d=!1;if(h*c<0){const t=-h/(c-h);t>1-1e-8&&c>=0?d=!0:(r.interpolate(t,o,a),i.push(a),s.push(a))}(c>=0||d)&&i.push(o),(c<=0||d)&&s.push(o),r.setFromPoint3d(o),h=c}}}static clipConvexPolygonInPlace(t,e,i,s=!0,n=K.smallMetricDistance){i.clear();const r=s?1:-1,o=e.length;let a=0;const c=-n;let h=0;if(e.length>1){let s,l=e.length-1,d=r*e.evaluateUncheckedIndexPlaneAltitude(l,t);Math.abs(d)<n&&(d=0);for(let u=0;u<o;d=s,l=u++){if(s=r*e.evaluateUncheckedIndexPlaneAltitude(u,t),Math.abs(s)<n&&(s=0),s<0&&a++,d*s<0){const t=-d/(s-d);t>1-1e-8&&s>=0||(i.pushInterpolatedFromGrowableXYZArray(e,l,t,u),s>0&&h++)}s>=c&&(i.pushFromGrowableXYZArray(e,u),d<-c&&h++),l=u,d=s}}return i.length<=2?e.clear():a>0&&(e.clear(),e.pushFromGrowableXYZArray(i)),i.clear(),h}static polygonPlaneCrossings(t,e,i){if(i.length=0,e.length>=2){const s=this._xyz0Work;e.getPoint3dAtUncheckedPointIndex(e.length-1,s);let n=t.altitude(s);const r=this._xyz1Work;for(let o=0;o<e.length;o++){e.getPoint3dAtUncheckedPointIndex(o,r);const a=t.altitude(r);if(n*a<0){const t=-n/(a-n);i.push(s.interpolate(t,r))}0===a&&i.push(r.clone()),s.setFromPoint3d(r),n=a}}}static gatherCutLoopsFromPlaneClip(t,e,i=3,s=K.smallMetricDistance){const n=new fr;let r=0;const o=e.length;for(;r<o;r++){const i=e.evaluateUncheckedIndexPlaneAltitude(r,t);if(Math.abs(i)<=s)break}if(r===o)return n;let a=r;for(;a<o;){const c=new nt;c.pushFromGrowableXYZArray(e,a);let h=a+1;for(;h<o;){c.pushFromGrowableXYZArray(e,h);const i=e.evaluateUncheckedIndexPlaneAltitude(h,t);if(Math.abs(i)<=s)break;h++}if(h===o)for(let t=0;t<=r;t++)c.pushFromGrowableXYZArray(e,t);c.length>=i&&n.inputLoops.push(ur.createCaptureWithReturnEdge(c)),a=h}return n}static reorderCutLoops(t){if(1!==t.inputLoops.length){if(2===t.inputLoops.length){if(t.inputLoops[0].edge.direction.dotProduct(t.inputLoops[1].edge.direction)>0)return t.outputLoops.push(t.inputLoops[0]),void t.outputLoops.push(t.inputLoops[1]);const e=t.inputLoops[1].xyz;return t.inputLoops[0].xyz.pushFromGrowableXYZArray(e),void t.outputLoops.push(t.inputLoops[0])}t.sortAndMergeLoops()}}static intersectRangeConvexPolygonInPlace(t,e){if(t.isNull)return;const i=new nt,s=Rt.create();return s.set(0,0,-1,t.high.z),this.clipConvexPolygonInPlace(s,e,i,!0),0!==e.length&&(s.set(0,0,1,-t.low.z),this.clipConvexPolygonInPlace(s,e,i,!0),0!==e.length&&(s.set(0,-1,0,t.high.y),this.clipConvexPolygonInPlace(s,e,i,!0),0!==e.length&&(s.set(0,1,0,-t.low.y),this.clipConvexPolygonInPlace(s,e,i,!0),0!==e.length&&(s.set(-1,0,0,t.high.x),this.clipConvexPolygonInPlace(s,e,i,!0),0!==e.length&&(s.set(1,0,0,-t.low.x),this.clipConvexPolygonInPlace(s,e,i,!0),0!==e.length)))))?e:void 0}}pr._xyz0Work=Q.create(),pr._xyz1Work=Q.create(),pr._xyz2Work=Q.create();class mr{static convexPolygonSplitInsideOutsidePlane(t,e,i,s,n){const r=new se(e),o=new se(i),a=new se(s);pr.splitConvexPolygonInsideOutsidePlane(t,r,o,a,n)}static polygonPlaneCrossings(t,e,i){const s=new se(e);return pr.polygonPlaneCrossings(t,s,i)}static convexPolygonClipInPlace(t,e,i,s=K.smallMetricDistance){void 0===i&&(i=[]),i.length=0;let n=0;const r=-s;if(e.length>2){let s=e[e.length-1],o=t.altitude(s);for(const a of e){const e=t.altitude(a);if(e<0&&n++,o*e<0){const t=-o/(e-o);t>1-1e-8&&e>=0||i.push(s.interpolate(t,a))}e>=r&&i.push(a),s=Q.createFrom(a),o=e}}if(i.length<=2)e.length=0;else if(n>0){e.length=0;for(const t of i)e.push(t);i.length=0}}}mr._xyz0Work=Q.create();class xr extends tt{constructor(t,e,i,s){super(),this._invisible=i,this._interior=s,this._inwardNormal=t,this._distanceFromOrigin=e}isAlmostEqual(t){return K.isSameCoordinate(this._distanceFromOrigin,t._distanceFromOrigin)&&this._inwardNormal.isAlmostEqual(t._inwardNormal)&&this._interior===t._interior&&this._invisible===t._invisible}clone(){return new xr(this._inwardNormal.clone(),this._distanceFromOrigin,this._invisible,this._interior)}cloneNegated(){const t=new xr(this._inwardNormal.clone(),this._distanceFromOrigin,this._invisible,this._interior);return t.negateInPlace(),t}static createPlane(t,e=!1,i=!1,s){const n=t.getNormalRef().dotProduct(t.getOriginRef());return s?(s._invisible=e,s._interior=i,s._inwardNormal=t.getNormalRef().clone(),s._distanceFromOrigin=n,s):new xr(t.getNormalRef().clone(),n,e,i)}static createNormalAndDistance(t,e,i=!1,s=!1,n){const r=t.normalize();if(r)return n&&(n._invisible=i,n._interior=s,n._inwardNormal=r,n._distanceFromOrigin=e),new xr(r,e,i,s)}static createNormalAndPoint(t,e,i=!1,s=!1,n){const r=t.normalize();if(r){const t=r.dotProduct(e);return n&&(n._invisible=i,n._interior=s,n._inwardNormal=r,n._distanceFromOrigin=t),new xr(r,t,i,s)}}static createOriginAndVectors(t,e,i,s=!1,n=!1,r){const o=i.crossProduct(e);return this.createNormalAndPoint(o,t,s,n,r)}static createNormalAndPointXYZXYZ(t,e,i,s,n,r,o=!1,a=!1,c){const h=K.hypotenuseXYZ(t,e,i),l=K.conditionalDivideFraction(1,h);if(void 0!==l){if(c)return c._inwardNormal.set(t*l,e*l,i*l),c._distanceFromOrigin=c._inwardNormal.dotProductXYZ(s,n,r),c._invisible=o,c._interior=a,c;const h=$.create(t*l,e*l,i*l);return new xr(h,h.dotProductXYZ(s,n,r),o,a)}}toJSON(){const t={normal:this.inwardNormalRef.toJSON(),dist:this.distance};return this.interior&&(t.interior=!0),this.invisible&&(t.invisible=!0),t}static fromJSON(t,e){return t&&t.normal&&void 0!==t.dist&&Number.isFinite(t.dist)?xr.createNormalAndDistance($.fromJSON(t.normal),t.dist,!!t.invisible,!!t.interior):xr.createNormalAndDistance($.unitZ(),0,!1,!1,e)}setFlags(t,e){this._invisible=t,this._interior=e}get distance(){return this._distanceFromOrigin}get inwardNormalRef(){return this._inwardNormal}get interior(){return this._interior}get invisible(){return this._invisible}static createEdgeAndUpVector(t,e,i,s,n){const r=$.createFrom(e.minus(t));let o=i.crossProduct(r).normalize();if(o){if(void 0!==s&&!s.isAlmostZero){const t=$.createRotateVectorAroundVector(o,r,s);t&&(o=t.clone())}return o.negate(o),xr.createNormalAndPoint(o,t,!1,!1,n)}}static createEdgeXY(t,e,i){const s=$.create(t.y-e.y,e.x-t.x);if(s.normalizeInPlace())return xr.createNormalAndPoint(s,t,!1,!1,i)}getPlane3d(){const t=this._distanceFromOrigin;return yt.create(Q.create(this._inwardNormal.x*t,this._inwardNormal.y*t,this._inwardNormal.z*t),this._inwardNormal)}getPlane4d(){return Rt.create(this._inwardNormal.x,this._inwardNormal.y,this._inwardNormal.z,-this._distanceFromOrigin)}setPlane4d(t){const e=Math.sqrt(t.x*t.x+t.y*t.y+t.z*t.z),i=0===e?1:1/e;this._inwardNormal.x=i*t.x,this._inwardNormal.y=i*t.y,this._inwardNormal.z=i*t.z,this._distanceFromOrigin=-i*t.w}weightedAltitude(t){return t.x*this._inwardNormal.x+t.y*this._inwardNormal.y+t.z*this._inwardNormal.z-t.w*this._distanceFromOrigin}altitude(t){return t.x*this._inwardNormal.x+t.y*this._inwardNormal.y+t.z*this._inwardNormal.z-this._distanceFromOrigin}altitudeXYZ(t,e,i){return t*this._inwardNormal.x+e*this._inwardNormal.y+i*this._inwardNormal.z-this._distanceFromOrigin}normalX(){return this._inwardNormal.x}normalY(){return this._inwardNormal.y}normalZ(){return this._inwardNormal.z}velocity(t){return t.x*this._inwardNormal.x+t.y*this._inwardNormal.y+t.z*this._inwardNormal.z}velocityXYZ(t,e,i){return t*this._inwardNormal.x+e*this._inwardNormal.y+i*this._inwardNormal.z}dotProductPlaneNormalPoint(t){return t.x*this._inwardNormal.x+t.y*this._inwardNormal.y+t.z*this._inwardNormal.z}isPointOnOrInside(t,e=K.smallMetricDistance){let i=this.altitude(t);return e&&(i+=e),i>=0}isPointInside(t,e=K.smallMetricDistance){let i=this.altitude(t);return e&&(i-=e),i>0}isPointOn(t,e=K.smallMetricDistance){return Math.abs(this.altitude(t))<=e}appendIntersectionRadians(t,e){const i=t.toVectors(),s=this.altitude(t.center),n=this.velocity(i.vector0),r=this.velocity(i.vector90);Ct.appendImplicitLineUnitCircleIntersections(s,n,r,void 0,void 0,e)}announceClippedArcIntervals(t,e){const i=xr._clipArcFractionArray;return i.clear(),this.appendIntersectionRadians(t,i),t.sweep.radiansArrayToPositivePeriodicFractions(i),os.selectIntervals01(t,i,this,e)}getBoundedSegmentSimpleIntersection(t,e){const i=this.altitude(t),s=this.altitude(e);if(!(i*s>0||0===i&&0===s))return-i/(s-i)}transformInPlace(t){const e=this.getPlane3d(),i=t.matrix,s=t.multiplyPoint3d(e.getOriginRef()),n=i.multiplyInverseTranspose(e.getNormalRef());if(!n)return!1;e.set(s,n);const r=e.getNormalRef().normalize();return!!r&&(this._inwardNormal=r,this._distanceFromOrigin=this._inwardNormal.dotProduct(e.getOriginRef()),!0)}setInvisible(t){this._invisible=t}negateInPlace(){this._inwardNormal=this._inwardNormal.negate(),this._distanceFromOrigin=-this._distanceFromOrigin}offsetDistance(t){this._distanceFromOrigin+=t}clipConvexPolygonInPlace(t,e,i=!0,s=K.smallMetricDistance){return pr.clipConvexPolygonInPlace(this,t,e,i,s)}multiplyPlaneByMatrix4d(t,e=!0,i=!0){const s=this.getPlane4d();if(e){const e=t.createInverse();return!!e&&this.multiplyPlaneByMatrix4d(e,!1,i)}return i?t.multiplyTransposePoint4d(s,s):t.multiplyPoint4d(s,s),this.setPlane4d(s),!0}announceClippedSegmentIntervals(t,e,i,s,n){if(e<t)return!1;const r=-this.altitude(i),o=-this.altitude(s)-r,a=K.conditionalDivideFraction(-r,o);return void 0===a?r<=0&&(n&&n(t,e),!0):(o>0?a<e&&(e=a):a>t&&(t=a),!(e<t||(n&&n(t,e),0)))}getFrame(){const t=this._distanceFromOrigin,e=Q.create(this._inwardNormal.x*t,this._inwardNormal.y*t,this._inwardNormal.z*t),i=xt.createRigidHeadsUp(this._inwardNormal,p.ZXY);return pt.createOriginAndMatrix(e,i)}intersectRange(t,e=!1){if(t.isNull)return;const i=t.corners(),s=this.getFrame();s.multiplyInversePoint3dArrayInPlace(i);const n=ut.createArray(i);if(n.low.z*n.high.z>0)return;const r=new nt;return r.pushXYZ(n.low.x,n.low.y,0),r.pushXYZ(n.high.x,n.low.y,0),r.pushXYZ(n.high.x,n.high.y,0),r.pushXYZ(n.low.x,n.high.y,0),r.multiplyTransformInPlace(s),pr.intersectRangeConvexPolygonInPlace(t,r),0!==r.length?(e&&r.pushWrap(1),r):void 0}appendPolygonClip(t,e,i,s){const n=ft.createNull(),r=s.grabFromCache(),o=s.grabFromCache();pr.splitConvexPolygonInsideOutsidePlane(this,t,r,o,n),os.captureOrDrop(r,3,e,s),os.captureOrDrop(o,3,i,s)}projectPointToPlane(t,e){const i=-this.altitude(t);return t.plusXYZ(i*this._inwardNormal.x,i*this._inwardNormal.y,i*this._inwardNormal.z,e)}}xr._clipArcFractionArray=new St;const yr={aliceBlue:16775408,amber:49151,antiqueWhite:14150650,aqua:16776960,aquamarine:13959039,azure:16777200,beige:14480885,bisque:12903679,black:0,blanchedAlmond:13495295,blue:16711680,blueViolet:14822282,brown:2763429,burlyWood:8894686,cadetBlue:10526303,chartreuse:65407,chocolate:1993170,coral:5275647,cornflowerBlue:15570276,cornSilk:14481663,crimson:3937500,cyan:16776960,darkBlue:9109504,darkBrown:2179941,darkCyan:9145088,darkGoldenrod:755384,darkGray:11119017,darkGreen:25600,darkGrey:11119017,darkKhaki:7059389,darkMagenta:9109643,darkOliveGreen:3107669,darkOrange:36095,darkOrchid:13382297,darkRed:139,darkSalmon:8034025,darkSeagreen:9419919,darkSlateBlue:9125192,darkSlateGray:5197615,darkSlateGrey:5197615,darkTurquoise:13749760,darkViolet:13828244,deepPink:9639167,deepSkyBlue:16760576,dimGray:6908265,dimGrey:6908265,dodgerBlue:16748574,fireBrick:2237106,floralWhite:15792895,forestGreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostWhite:16775416,gold:55295,goldenrod:2139610,gray:8421504,green:32768,greenYellow:3145645,grey:8421504,honeydew:15794160,hotPink:11823615,indianRed:6053069,indigo:8519755,ivory:15794175,khaki:9234160,lavender:16443110,lavenderBlush:16118015,lawnGreen:64636,lemonChiffon:13499135,lightBlue:15128749,lightCoral:8421616,lightCyan:16777184,lightGoldenrodYellow:13826810,lightGray:13882323,lightGreen:9498256,lightGrey:13882323,lightPink:12695295,lightSalmon:8036607,lightSeagreen:11186720,lightSkyBlue:16436871,lightSlateGray:10061943,lightSlateGrey:10061943,lightSteelBlue:14599344,lightyellow:14745599,lime:65280,limeGreen:3329330,linen:15134970,magenta:16711935,maroon:128,mediumAquamarine:11193702,mediumBlue:13434880,mediumOrchid:13850042,mediumPurple:14381203,mediumSeaGreen:7451452,mediumSlateBlue:15624315,mediumSpringGreen:10156544,mediumTurquoise:13422920,mediumVioletRed:8721863,midnightBlue:7346457,mintCream:16449525,mistyRose:14804223,moccasin:11920639,navajoWhite:11394815,navy:8388608,oldLace:15136253,olive:32896,oliveDrab:2330219,orange:42495,orangeRed:17919,orchid:14053594,paleGoldenrod:11200750,paleGreen:10025880,paleTurquoise:15658671,paleVioletRed:9662683,papayaWhip:14020607,peachPuff:12180223,peru:4163021,pink:13353215,plum:14524637,powderBlue:15130800,purple:8388736,rebeccaPurple:10040166,red:255,rosyBrown:9408444,royalBlue:14772545,saddleBrown:1262987,salmon:7504122,sandyBrown:6333684,seaGreen:5737262,seaShell:15660543,sienna:2970272,silver:12632256,skyBlue:15453831,slateBlue:13458026,slateGray:9470064,slateGrey:9470064,snow:16448255,springGreen:8388352,steelBlue:11829830,tan:9221330,teal:8421376,thistle:14204888,tomato:4678655,turquoise:13688896,violet:15631086,wheat:11788021,white:16777215,whiteSmoke:16119285,yellow:65535,yellowGreen:3329434};class _r{constructor(t=0,e=0,i=0){this.h=t,this.s=e,this.l=i}clone(t,e,i){return new _r(t??this.h,e??this.s,i??this.l)}toColorDef(t=0){return Sr.fromHSL(this.h,this.s,this.l,t)}static fromColorDef(t){return t.toHSL()}}var vr;!function(t){t[t.VISIBILITY_GOAL=40]="VISIBILITY_GOAL",t[t.HSV_SATURATION_WEIGHT=4]="HSV_SATURATION_WEIGHT",t[t.HSV_VALUE_WEIGHT=2]="HSV_VALUE_WEIGHT"}(vr||(vr={}));class Pr{constructor(t=0,e=0,i=0){this.h=t,this.s=e,this.v=i}clone(t,e,i){return new Pr(t??this.h,e??this.s,i??this.v)}toColorDef(t=0){return Sr.fromHSV(this,t)}static fromColorDef(t){return t.toHSV()}adjusted(t,e){let i;if(t){if(i=e*vr.HSV_VALUE_WEIGHT,this.v>=i)return new Pr(this.h,this.s,this.v-i);i-=this.v;const t=Math.min(this.s+i,100);return new Pr(this.h,t,0)}if(i=e*vr.HSV_SATURATION_WEIGHT,this.s>=i)return new Pr(this.h,this.s-i,this.v);i-=this.s;const s=Math.min(this.v+i,100);return new Pr(this.h,0,s)}}const Ir=new Uint8Array(4),Ar=new Uint32Array(Ir.buffer);class Sr{constructor(t){Ar[0]=t,this._tbgr=Ar[0]}static create(t){return this.fromTbgr(this.computeTbgr(t))}static computeTbgr(t){switch(typeof t){case"number":return t;case"string":return this.computeTbgrFromString(t);default:return 0}}toJSON(){return this._tbgr}static fromJSON(t){return this.create(t)}static from(t,e,i,s){return this.fromTbgr(this.computeTbgrFromComponents(t,e,i,s))}static computeTbgrFromComponents(t,e,i,s){return Ir[0]=t,Ir[1]=e,Ir[2]=i,Ir[3]=s||0,Ar[0]}static fromTbgr(t){switch(t){case yr.black:return this.black;case yr.white:return this.white;case yr.red:return this.red;case yr.green:return this.green;case yr.blue:return this.blue;default:return new Sr(t)}}static fromAbgr(t){return this.fromTbgr(this.getAbgr(t))}static fromString(t){return this.fromTbgr(this.computeTbgrFromString(t))}static isValidColor(t){return"number"==typeof t?t>=0&&t<=4294967295&&Math.floor(t)===t:void 0!==this.tryComputeTbgrFromString(t)}static computeTbgrFromString(t){return this.tryComputeTbgrFromString(t)??0}static tryComputeTbgrFromString(t){if("string"!=typeof t)return;t=t.toLowerCase();let e=/^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t);if(e){let t;const i=e[1],s=e[2],n=t=>"%"===t[t.length-1],r=t=>{const e=parseFloat(t);return 255*K.clamp(n(t)?e/100:e,0,1)},o=t=>{const e=n(t)?parseFloat(t)/100*255:parseInt(t,10);return K.clamp(e,0,255)};switch(i){case"rgb":case"rgba":if(t=/^(\d+%*)\s*[, ]\s*(\d+%*)\s*[, ]\s*(\d+%*)\s*([,\/]\s*([0-9]*\.?[0-9]+%*)\s*)?$/.exec(s),t)return this.computeTbgrFromComponents(o(t[1]),o(t[2]),o(t[3]),"string"==typeof t[5]?255-r(t[5]):0);break;case"hsl":case"hsla":if(t=/^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(s),t){const e=parseFloat(t[1])/360,i=parseInt(t[2],10)/100,s=parseInt(t[3],10)/100,n="string"==typeof t[5]?255-r(t[5]):0;return this.computeTbgrFromHSL(e,i,s,n)}}}else if(e=/^\#([a-f0-9]+)$/.exec(t)){const t=e[1],i=t.length;if(3===i)return this.computeTbgrFromComponents(parseInt(t.charAt(0)+t.charAt(0),16),parseInt(t.charAt(1)+t.charAt(1),16),parseInt(t.charAt(2)+t.charAt(2),16),0);if(6===i)return this.computeTbgrFromComponents(parseInt(t.charAt(0)+t.charAt(1),16),parseInt(t.charAt(2)+t.charAt(3),16),parseInt(t.charAt(4)+t.charAt(5),16),0)}if(t&&t.length>0)for(const[e,i]of Object.entries(yr))if(e.toLowerCase()===t)return i}get colors(){return Sr.getColors(this._tbgr)}static getColors(t){return Ar[0]=t,{b:Ir[2],g:Ir[1],r:Ir[0],t:Ir[3]}}get tbgr(){return this._tbgr}getAbgr(){return Sr.getAbgr(this._tbgr)}static getAbgr(t){return Ar[0]=t,Ir[3]=255-Ir[3],Ar[0]}getRgb(){return Sr.getRgb(this._tbgr)}static getRgb(t){return Ar[0]=t,(Ir[0]<<16)+(Ir[1]<<8)+Ir[2]}withAlpha(t){const e=Sr.withAlpha(this._tbgr,t);return e===this._tbgr?this:Sr.fromTbgr(e)}static withAlpha(t,e){return Ar[0]=t,Ir[3]=255-(0|e),Ar[0]}getAlpha(){return Sr.getAlpha(this._tbgr)}static getAlpha(t){return Ar[0]=t,255-Ir[3]}get isOpaque(){return Sr.isOpaque(this._tbgr)}static isOpaque(t){return 255===this.getAlpha(t)}getTransparency(){return Sr.getTransparency(this._tbgr)}static getTransparency(t){return Ar[0]=t,Ir[3]}withTransparency(t){const e=Sr.withTransparency(this._tbgr,t);return e===this._tbgr?this:Sr.fromTbgr(e)}static withTransparency(t,e){return this.withAlpha(t,255-e)}get name(){return Sr.getName(this.tbgr)}static getName(t){for(const[e,i]of Object.entries(yr))if(i===t)return e}toHexString(){return Sr.toHexString(this.tbgr)}static toHexString(t){return`#${`000000${this.getRgb(t).toString(16)}`.slice(-6)}`}static getColorsString(t){const e=this.getColors(t);return`${e.r},${e.g},${e.b}`}toRgbString(){return Sr.toRgbString(this.tbgr)}static toRgbString(t){return`rgb(${this.getColorsString(t)})`}toRgbaString(){return Sr.toRgbaString(this.tbgr)}static toRgbaString(t){return`rgba(${this.getColorsString(t)},${this.getAlpha(t)/255})`}lerp(t,e){return Sr.fromTbgr(Sr.lerp(this.tbgr,t.tbgr,e))}static lerp(t,e,i){const s=this.getColors(t),n=this.getColors(e);return s.r+=(n.r-s.r)*i,s.g+=(n.g-s.g)*i,s.b+=(n.b-s.b)*i,this.computeTbgrFromComponents(s.r,s.g,s.b,s.t)}inverse(){return Sr.fromTbgr(Sr.inverse(this.tbgr))}static inverse(t){const e=this.getColors(t);return this.computeTbgrFromComponents(255-e.r,255-e.g,255-e.b)}static fromHSL(t,e,i,s=0){return this.fromTbgr(this.computeTbgrFromHSL(t,e,i,s))}static computeTbgrFromHSL(t,e,i,s=0){const n=(t,e,i)=>Math.round(255*((t,e,i)=>(i<0&&(i+=1),i>1&&(i-=1),i<1/6?t+6*(e-t)*i:i<.5?e:i<2/3?t+6*(e-t)*(2/3-i):t))(t,e,i));if(t=(t%1+1)%1,e=K.clamp(e,0,1),i=K.clamp(i,0,1),0===e)return i*=255,this.computeTbgrFromComponents(i,i,i,s);const r=i<=.5?i*(1+e):i+e-i*e,o=2*i-r;return this.computeTbgrFromComponents(n(o,r,t+1/3),n(o,r,t),n(o,r,t-1/3),s)}toHSL(){const t=this.colors;t.r/=255,t.g/=255,t.b/=255;const e=Math.max(t.r,t.g,t.b),i=Math.min(t.r,t.g,t.b);let s,n=0;const r=(i+e)/2;if(i===e)s=0;else{const o=e-i;switch(s=r<=.5?o/(e+i):o/(2-e-i),e){case t.r:n=(t.g-t.b)/o+(t.g<t.b?6:0);break;case t.g:n=(t.b-t.r)/o+2;break;case t.b:n=(t.r-t.g)/o+4}n/=6}return new _r(n,s,r)}toHSV(){const{r:t,g:e,b:i}=this.colors;let s=t<e?t:e;i<s&&(s=i);let n=t>e?t:e;i>n&&(n=i);const r=Math.floor(n/255*100+.5),o=n-s,a=0!==n?Math.floor(o/n*100+.5):0;let c=0;if(a){const s=(n-t)/o,r=(n-e)/o,a=(n-i)/o;let h;h=t===n?a-r:e===n?2+s-a:4+r-s,h*=60,h<0&&(h+=360),c=Math.floor(h+.5),c>=360&&(c=0)}else c=0;return new Pr(c,a,r)}static fromHSV(t,e=0){if(!t.s||-1===t.h){const e=255&Math.floor(255*t.v/100+.5+3e-14);return Sr.from(e,e,e,0)}let i=t.h,s=t.s,n=t.v;360===i&&(i=0),i/=60;const r=Math.floor(i),o=i-r;n/=100,s/=100;const a=255&Math.floor(n*(1-s)*255+.5),c=255&Math.floor(n*(1-s*o)*255+.5),h=255&Math.floor(n*(1-s*(1-o))*255+.5),l=255&Math.floor(255*n+.5);let d=0,u=0,f=0;switch(r){case 0:d=l,f=h,u=a;break;case 1:d=c,f=l,u=a;break;case 2:d=a,f=l,u=h;break;case 3:d=a,f=c,u=l;break;case 4:d=h,f=a,u=l;break;case 5:d=l,f=a,u=c}return Sr.from(d,f,u,e)}visibilityCheck(t){const e=this.colors,i=t.colors;return.3*Math.abs(e.r-i.r)+.59*Math.abs(e.g-i.g)+.11*Math.abs(e.b-i.b)}adjustedForContrast(t,e){const i=this.visibilityCheck(t);if(vr.VISIBILITY_GOAL<=i)return void 0!==e?this.withAlpha(e):this;const s=Math.floor((vr.VISIBILITY_GOAL-i)/255*100);let n=this.toHSV(),r=n.clone();n=n.adjusted(!0,s),r=r.adjusted(!1,s),void 0===e&&(e=this.getAlpha());const o=Sr.fromHSV(n).withAlpha(e),a=Sr.fromHSV(r).withAlpha(e);return a.getRgb()===t.getRgb()?o:o.getRgb()===t.getRgb()||a.visibilityCheck(t)>=o.visibilityCheck(t)?a:o}equals(t){return this._tbgr===t._tbgr}}Sr.black=new Sr(yr.black),Sr.white=new Sr(yr.white),Sr.red=new Sr(yr.red),Sr.green=new Sr(yr.green),Sr.blue=new Sr(yr.blue);class wr{constructor(t,e,i){this.r=t,this.g=e,this.b=i,this.r=Math.max(0,Math.min(this.r,255)),this.g=Math.max(0,Math.min(this.g,255)),this.b=Math.max(0,Math.min(this.b,255))}static fromColorDef(t){const e=t.colors;return new wr(e.r,e.g,e.b)}toColorDef(t=0){return Sr.from(this.r,this.g,this.b,t)}toJSON(){return{r:this.r,g:this.g,b:this.b}}static fromJSON(t){let e=255,i=255,s=255;return void 0!==t&&("number"==typeof t.r&&(e=t.r),"number"==typeof t.g&&(i=t.g),"number"==typeof t.b&&(s=t.b)),new wr(e,i,s)}equals(t){return this.r===t.r&&this.g===t.g&&this.b===t.b}compareTo(t){return i(this.r,t.r)||i(this.g,t.g)||i(this.b,t.b)}toHexString(){return this.toColorDef().toHexString()}}class Cr{constructor(t,e){this.value=t,this.index=e}}class Tr{constructor(t,e=Number.MAX_SAFE_INTEGER,i=Z){this._array=[],this._compareValues=t,this._clone=i,this._maximumSize=e}get length(){return this._array.length}get isFull(){return this.length>=this._maximumSize}get isEmpty(){return 0===this.length}clear(){this._array=[]}insert(t,e){const i=this.lowerBound(t);if(i.equal)return this._array[i.index].index;if(this.isFull)return-1;const s=new Cr(this._clone(t),this._array.length);return void 0!==e&&e(s.value),this._array.splice(i.index,0,s),s.index}indexOf(t){const e=this.lowerBound(t);return e.equal?this._array[e.index].index:-1}lowerBound(t){return q(t,this._array,((t,e)=>this._compareValues(t,e.value)))}toArray(){const t=[];for(const e of this._array)t[e.index]=e.value;return t}}var kr,Fr,Mr,br,Er,Xr;!function(t){t[t.Never=0]="Never",t[t.ByView=1]="ByView",t[t.Always=2]="Always",t[t.Blanking=3]="Blanking"}(kr||(kr={})),function(t){t[t.None=0]="None",t[t.Solid=1]="Solid",t[t.Outline=2]="Outline"}(Fr||(Fr={})),function(t){t[t.Primary=0]="Primary",t[t.Construction=1]="Construction",t[t.Dimension=2]="Dimension",t[t.Pattern=3]="Pattern"}(Mr||(Mr={}));class Rr{constructor(t=l.invalid,e=l.invalid,i=Mr.Primary){this.elementId=t,this.subCategoryId=e,this.geometryClass=i}get isDefined(){return!l.isInvalid(this.elementId)||!l.isInvalid(this.subCategoryId)||this.geometryClass!==Mr.Primary}get isUndefined(){return!this.isDefined}equals(t){return 0===this.compare(t)}compare(t){if(this===t)return 0;let e=i(this.geometryClass,t.geometryClass);return 0===e&&(e=n(this.elementId,t.elementId),0===e&&(e=n(this.subCategoryId,t.subCategoryId))),e}}!function(t){t.create=function(){return{modelId:l.invalid,elementId:l.invalid,subCategoryId:l.invalid,geometryClass:Mr.Primary}},t.isDefined=function(t){return!l.isInvalid(t.modelId)||!l.isInvalid(t.elementId)||!l.isInvalid(t.subCategoryId)||t.geometryClass!==Mr.Primary},t.unpack=function(t,e,i){return e.modelId=i??l.fromUint32PairObject(t.modelId),e.elementId=l.fromUint32PairObject(t.elementId),e.subCategoryId=l.fromUint32PairObject(t.subCategoryId),e.geometryClass=t.geometryClass,e}}(br||(br={})),function(t){function e(){const t={upper:0,lower:0};return{modelId:{...t},elementId:{...t},subCategoryId:{...t},geometryClass:Mr.Primary,animationNodeId:0}}t.create=e,t.createWithIndex=function(){const t=e();return t.index=0,t}}(Er||(Er={})),function(t){t[t.Primary=0]="Primary",t[t.VolumeClassifier=1]="VolumeClassifier",t[t.PlanarClassifier=2]="PlanarClassifier"}(Xr||(Xr={}));class zr extends Tr{constructor(t,e=l.invalid,i=Xr.Primary){super(((t,e)=>t.compare(e)),t),this.modelId=e,this.type=i}get maxFeatures(){return this._maximumSize}get anyDefined(){return this.length>1||1===this.length&&this._array[0].value.isDefined}get isUniform(){return 1===this.length}get uniform(){return 1===this.length?this._array[0].value:void 0}get isVolumeClassifier(){return Xr.VolumeClassifier===this.type}get isPlanarClassifier(){return Xr.PlanarClassifier===this.type}findFeature(t){for(const e of this._array)if(e.index===t)return e.value}insertWithIndex(t,i){const s=this.lowerBound(t);e(!s.equal),e(!this.isFull);const n=new Cr(t,i);this._array.splice(s.index,0,n)}getArray(){return this._array}pack(){return Nr.pack(this)}}const Dr=Er.create();function Yr(t,i,s){let n;e(s>0);const r=Er.createWithIndex();for(const o of t.iterable(r)){const r=i(o);if(e(r<=s),0!==r){if(!n){const e=t.numFeatures;n=s<256?new Uint8Array(e):s<65536?new Uint16Array(e):new Uint32Array(e)}n[o.index]=r}}return n}class Nr{get byteLength(){return this._data.byteLength}constructor(t,i,s,n,r){switch(this._data=t,this.batchModelId=i,this.batchModelIdPair=l.getUint32Pair(i),this.numFeatures=s,this.type=n,this.animationNodeIds=r,this.numFeatures){case 0:this.anyDefined=!1;break;case 1:this.anyDefined=br.isDefined(this.getFeature(0,br.create()));break;default:this.anyDefined=!0}e(this._data.length>=this._subCategoriesOffset),e(void 0===this.animationNodeIds||this.animationNodeIds.length===this.numFeatures)}static pack(t){const i=new Map;for(const e of t.getArray())void 0===i.get(e.value.subCategoryId.toString())&&i.set(e.value.subCategoryId,i.size);const s=3*t.length,n=s+2*i.size,r=new Uint32Array(n);for(const s of t.getArray()){const t=s.value,n=3*s.index;let o=i.get(t.subCategoryId);e(void 0!==o),o|=t.geometryClass<<24,r[n+0]=l.getLowerUint32(t.elementId),r[n+1]=l.getUpperUint32(t.elementId),r[n+2]=o}return i.forEach(((t,e,i)=>{const n=s+2*t;r[n+0]=l.getLowerUint32(e),r[n+1]=l.getUpperUint32(e)})),new Nr(r,t.modelId,t.length,t.type)}getFeature(t,e){const i=this.getPackedFeature(t,Dr);return br.unpack(i,e,this.batchModelId)}findFeature(t,e){return t<this.numFeatures?this.getFeature(t,e):void 0}getElementIdPair(t,i){i=i??{lower:0,upper:0},e(t<this.numFeatures);const s=3*t;return i.lower=this._data[s],i.upper=this._data[s+1],i}getSubCategoryIdPair(t){const e=3*t;let i=this._data[e+2];return i=(16777215&i)>>>0,i=2*i+this._subCategoriesOffset,{lower:this._data[i],upper:this._data[i+1]}}getAnimationNodeId(t){return void 0!==this.animationNodeIds&&t<this.numFeatures?this.animationNodeIds[t]:0}getPackedFeature(t,i){e(t<this.numFeatures);const s=3*t;i.elementId.lower=this._data[s],i.elementId.upper=this._data[s+1];const n=this._data[s+2];i.geometryClass=n>>>24&255;let r=(16777215&n)>>>0;return r=2*r+this._subCategoriesOffset,i.subCategoryId.lower=this._data[r],i.subCategoryId.upper=this._data[r+1],i.animationNodeId=this.getAnimationNodeId(t),i.modelId.lower=this.batchModelIdPair.lower,i.modelId.upper=this.batchModelIdPair.upper,i}findElementId(t){return t>=this.numFeatures?void 0:this.readId(3*t)}get isUniform(){return 1===this.numFeatures}getUniform(t){return this.isUniform?this.getFeature(0,t):void 0}get isVolumeClassifier(){return Xr.VolumeClassifier===this.type}get isPlanarClassifier(){return Xr.VolumeClassifier===this.type}get isClassifier(){return this.isVolumeClassifier||this.isPlanarClassifier}unpack(){const t=new zr(this.numFeatures,this.batchModelId),e=br.create();for(let i=0;i<this.numFeatures;i++)this.getFeature(i,e),t.insertWithIndex(new Rr(e.elementId,e.subCategoryId,e.geometryClass),i);return t}populateAnimationNodeIds(t,i){e(void 0===this.animationNodeIds),this.animationNodeIds=Yr(this,t,i)}*iterator(t){for(let e=0;e<this.numFeatures;e++)this.getPackedFeature(e,t),t.index=e,yield t}iterable(t){return{[Symbol.iterator]:()=>this.iterator(t)}}get _subCategoriesOffset(){return 3*this.numFeatures}readId(t){return l.fromUint32Pair(this._data[t],this._data[t+1])}}const Or={lastFeatureIndex:-1,idLower:-1,idUpper:-1};class Br{constructor(t){this._data=t,e(this._data.length%3==0)}get length(){return this._data.length/3}get byteLength(){return this._data.byteLength}getLastFeatureIndex(t){return this._data[3*t]}getEntry(t,e){if(t>=this.length)return e.idLower=e.idUpper=0,e.lastFeatureIndex=Number.MAX_SAFE_INTEGER,e;const i=3*t;return e.lastFeatureIndex=this._data[i+0],e.idLower=this._data[i+1],e.idUpper=this._data[i+2],e}getModelIdPair(t,e){e?e.lower=e.upper=0:e={lower:0,upper:0};let i=0;const s=this.length;let n=s;for(;n>0;){const e=Math.floor(n/2),s=i+e;t>this.getLastFeatureIndex(s)?(i=s+1,n-=e+1):n=e}return i<s&&(e.lower=this._data[3*i+1],e.upper=this._data[3*i+2]),e}}class Vr{constructor(t,e){this._features=t,this._models=e}static create(t,e,i,s,n){const r=3*i+2*n,o=t.subarray(0,r),a=new Nr(o,e,i,s),c=t.subarray(r),h=new Br(c);return new Vr(a,h)}get batchModelId(){return this._features.batchModelId}get batchModelIdPair(){return this._features.batchModelIdPair}get numFeatures(){return this._features.numFeatures}get type(){return this._features.type}get animationNodeIds(){return this._features.animationNodeIds}set animationNodeIds(t){this._features.animationNodeIds=t}get byteLength(){return this._features.byteLength+this._models.byteLength}getPackedFeature(t,e){return this._features.getPackedFeature(t,e),this._models.getModelIdPair(t,e.modelId),e}getFeature(t,e){const i=this.getPackedFeature(t,Dr);return br.unpack(i,e)}findFeature(t,e){return t<this.numFeatures?this.getFeature(t,e):void 0}getElementIdPair(t,e){return this._features.getElementIdPair(t,e)}findElementId(t){return this._features.findElementId(t)}*iterator(t){let e=0;const i=this._models.getEntry(e,Or);for(let s=0;s<this.numFeatures;s++)s>i.lastFeatureIndex&&this._models.getEntry(++e,i),this._features.getPackedFeature(s,t),t.modelId.lower=i.idLower,t.modelId.upper=i.idUpper,t.index=s,yield t}iterable(t){return{[Symbol.iterator]:()=>this.iterator(t)}}getAnimationNodeId(t){return this._features.getAnimationNodeId(t)}populateAnimationNodeIds(t,e){this._features.animationNodeIds=Yr(this,t,e)}}function Lr(t,e){if(t.clear(),"string"==typeof e)t.addId(e);else for(const i of e)t.addId(i)}class Ur{static fromJSON(t){return void 0!==t&&(void 0!==t.rgb||void 0!==t.weight||void 0!==t.transparency||void 0!==t.linePixels||t.ignoresMaterial||t.nonLocatable||t.emphasized)?new Ur(t):this.defaults}static fromRgb(t){return this.fromJSON({rgb:wr.fromColorDef(t)})}static fromRgba(t,e=!1){return this.fromJSON({rgb:wr.fromColorDef(t),transparency:t.colors.t/255,viewDependentTransparency:!!e||void 0})}static fromTransparency(t,e=!1){return this.fromJSON({transparency:t,viewDependentTransparency:!!e||void 0})}static fromSubCategoryOverride(t){const e=void 0!==t.color?wr.fromColorDef(t.color):void 0,i=t.transparency,s=t.weight,n=!(void 0===t.material||!l.isValid(t.material))||void 0;return this.fromJSON({rgb:e,transparency:i,weight:s,ignoresMaterial:n,viewDependentTransparency:!0})}get matchesDefaults(){return this.equals(Ur.defaults)}get overridesRgb(){return void 0!==this.rgb}get overridesTransparency(){return void 0!==this.transparency}get overridesLinePixels(){return void 0!==this.linePixels}get overridesWeight(){return void 0!==this.weight}get overridesSymbology(){return this.overridesRgb||this.overridesTransparency||this.overridesWeight||this.overridesLinePixels||!!this.ignoresMaterial||this.emphasized||this.overridesNonLocatable}get overridesNonLocatable(){return void 0!==this.nonLocatable}get isFullyTransparent(){return void 0!==this.transparency&&this.transparency>=1}get anyOverridden(){return this.overridesSymbology||this.overridesNonLocatable}equals(t){return this===t||this.rgbIsEqual(t.rgb)&&this.weight===t.weight&&this.transparencyIsEqual(t.transparency)&&this.linePixels===t.linePixels&&this.ignoresMaterial===t.ignoresMaterial&&this.nonLocatable===t.nonLocatable&&this.emphasized===t.emphasized&&this.viewDependentTransparency===t.viewDependentTransparency}toJSON(){const t={};return this.rgb&&(t.rgb=this.rgb.toJSON()),void 0!==this.weight&&(t.weight=this.weight),void 0!==this.transparency&&(t.transparency=this.transparency,this.viewDependentTransparency&&(t.viewDependentTransparency=!0)),void 0!==this.linePixels&&(t.linePixels=this.linePixels),!0===this.ignoresMaterial&&(t.ignoresMaterial=!0),!0===this.nonLocatable&&(t.nonLocatable=!0),!0===this.emphasized&&(t.emphasized=!0),t}cloneProps(t){return{...this.toJSON(),...t}}clone(t){return Ur.fromJSON(this.cloneProps(t))}extendAppearance(t){if(!this.overridesSymbology)return t;const e=t.toJSON();return void 0===e.rgb&&(e.rgb=this.rgb),void 0===e.transparency&&(e.transparency=this.transparency),void 0===e.linePixels&&(e.linePixels=this.linePixels),void 0===e.weight&&(e.weight=this.weight),void 0===e.ignoresMaterial&&this.ignoresMaterial&&(e.ignoresMaterial=!0),void 0===e.nonLocatable&&this.nonLocatable&&(e.nonLocatable=!0),void 0===e.emphasized&&this.emphasized&&(e.emphasized=!0),void 0!==e.transparency&&this.viewDependentTransparency&&(e.viewDependentTransparency=!0),Ur.fromJSON(e)}constructor(t){if(this.rgb=void 0!==t.rgb?wr.fromJSON(t.rgb):void 0,this.weight=t.weight,this.transparency=t.transparency,this.linePixels=t.linePixels,this.ignoresMaterial=t.ignoresMaterial,this.nonLocatable=t.nonLocatable,this.emphasized=t.emphasized,void 0!==this.weight&&(this.weight=Math.max(1,Math.min(this.weight,32))),void 0!==this.transparency){t.viewDependentTransparency&&(this.viewDependentTransparency=!0),this.transparency=Math.max(0,Math.min(this.transparency,1));const e=1e-4;1-this.transparency<e?this.transparency=1:this.transparency<e&&(this.transparency=0)}}rgbIsEqual(t){return void 0===this.rgb?void 0===t:void 0!==t&&this.rgb.equals(t)}transparencyIsEqual(t){return void 0===this.transparency?void 0===t:void 0!==t&&Math.floor(255*this.transparency)===Math.floor(255*t)}}Ur.defaults=new Ur({});const Zr={elementId:{lower:0,upper:0},animationNodeId:0};class qr{ignoreAnimationOverrides(t){this._ignoreAnimationOverrides.push(t)}get defaultOverrides(){return this._defaultOverrides}get lineWeights(){return this._lineWeights}get neverDrawn(){return this._neverDrawn}get alwaysDrawn(){return this._alwaysDrawn}isNeverDrawn(t,e,i){return!!this._neverDrawn.has(t,e)||this.neverDrawnAnimationNodes.has(i)}isAlwaysDrawn(t,e){return this._alwaysDrawn.has(t,e)}isSubCategoryVisible(t,e){return this._visibleSubCategories.has(t,e)}isSubCategoryVisibleInModel(t,e,i,s){if(this.ignoreSubCategory)return!0;let n=this.isSubCategoryVisible(t,e);const r=this._modelSubCategoryOverrides.get(i,s);return void 0!==r&&r.has(t,e)&&(n=!n),n}getModelOverrides(t,e){return this._modelOverrides.get(t,e)}getElementAnimationOverrides(t,e,i){if(0===this.animationNodeOverrides.size)return;const s=this.animationNodeOverrides.get(i);if(!s||0===i||0===this._ignoreAnimationOverrides.length)return s;const n=Zr;return n.elementId.lower=t,n.elementId.upper=e,n.animationNodeId=i,this._ignoreAnimationOverrides.some((t=>t(n)))?void 0:s}getElementOverrides(t,e,i){const s=this._elementOverrides.get(t,e),n=this.getElementAnimationOverrides(t,e,i);return s?n?n.extendAppearance(s):s:n}getSubCategoryOverrides(t,e){return this._subCategoryOverrides.get(t,e)}setVisibleSubCategory(t){this._visibleSubCategories.addId(t)}setNeverDrawn(t){this._neverDrawn.addId(t)}setAlwaysDrawn(t){this._alwaysDrawn.addId(t)}setAnimationNodeNeverDrawn(t){this.neverDrawnAnimationNodes.add(t)}setNeverDrawnSet(t){Lr(this._neverDrawn,t)}setAlwaysDrawnSet(t,e,i=!0){Lr(this._alwaysDrawn,t),this.isAlwaysDrawnExclusive=e,this.alwaysDrawnIgnoresSubCategory=i}getFeatureAppearance(t,e,i=Xr.Primary,s=0){return this.getAppearance(l.getLowerUint32(t.elementId),l.getUpperUint32(t.elementId),l.getLowerUint32(t.subCategoryId),l.getUpperUint32(t.subCategoryId),t.geometryClass,l.getLowerUint32(e),l.getUpperUint32(e),i,s)}getAppearance(t,e,i,s,n,r,o,a,c){if(Xr.VolumeClassifier===a||Xr.PlanarClassifier===a)return this.getClassifierAppearance(t,e,i,s,r,o,c);let h=this._lineWeights?Ur.defaults:qr._weight1Appearance;const d=this.getModelOverrides(r,o);void 0!==d&&(h=d.extendAppearance(h));let u,f,g=!1;if(l.isValidUint32Pair(t,e)){if(this.isNeverDrawn(t,e,c))return;if(g=this.isAlwaysDrawn(t,e),!g&&this.isAlwaysDrawnExclusive)return;u=this.getElementOverrides(t,e,c),void 0!==u&&(h=void 0!==d?u.extendAppearance(h):u)}if(!this.ignoreSubCategory&&l.isValidUint32Pair(i,s)){if(!(g&&this.alwaysDrawnIgnoresSubCategory||this.isSubCategoryVisibleInModel(i,s,r,o)))return;f=this.getSubCategoryOverrides(i,s),void 0!==f&&(h=f.extendAppearance(h))}void 0===u&&void 0===d&&void 0===f&&(h=this._defaultOverrides.extendAppearance(h));let p=g||this.isClassVisible(n);return p&&h.isFullyTransparent&&(p=!1),p?h:void 0}getClassifierAppearance(t,e,i,s,n,r,o){let a=Ur.defaults;const c=this.getModelOverrides(n,r);void 0!==c&&(a=c.extendAppearance(a));const h=this.getElementOverrides(t,e,o);if(void 0!==h&&(a=void 0!==c?h.extendAppearance(a):h),!this.ignoreSubCategory&&l.isValidUint32Pair(i,s)){const t=this.getSubCategoryOverrides(i,s);void 0!==t&&(a=t.extendAppearance(a))}return void 0===h&&void 0===c&&(a=this._defaultOverrides.extendAppearance(a)),a}isClassVisible(t){switch(t){case Mr.Construction:return this._constructions;case Mr.Dimension:return this._dimensions;case Mr.Pattern:return this._patterns;default:return!0}}override(t){let i,s;void 0!==t.elementId?(i=t.elementId,s=this._elementOverrides):void 0!==t.modelId?(i=t.modelId,s=this._modelOverrides):(i=t.subCategoryId,s=this._subCategoryOverrides);let n=t.appearance;const r=l.getLowerUint32(i),o=l.getUpperUint32(i);if(void 0!==t.elementId&&this.isNeverDrawn(r,o,0))return;const a="replace"===t.onConflict?void 0:s.get(r,o);if(a)switch(e("replace"!==t.onConflict),t.onConflict){case"skip":return;case"extend":n=n.extendAppearance(a);break;default:n=a.extendAppearance(n)}s.set(r,o,n)}overrideModel(t,e,i=!0){this.override({modelId:t,appearance:e,onConflict:i?"replace":"skip"})}overrideSubCategory(t,e,i=!0){this.override({subCategoryId:t,appearance:e,onConflict:i?"replace":"skip"})}overrideElement(t,e,i=!0){this.override({elementId:t,appearance:e,onConflict:i?"replace":"skip"})}overrideAnimationNode(t,e){this.animationNodeOverrides.set(t,e)}setDefaultOverrides(t,e=!0){!e&&t.overridesSymbology||(this._defaultOverrides=t)}getSubCategoryPriority(t,e){return this._subCategoryPriorities.get(t,e)??0}constructor(){this._ignoreAnimationOverrides=[],this._neverDrawn=new l.Uint32Set,this._alwaysDrawn=new l.Uint32Set,this.isAlwaysDrawnExclusive=!1,this.alwaysDrawnIgnoresSubCategory=!0,this.ignoreSubCategory=!1,this._defaultOverrides=Ur.defaults,this._constructions=!1,this._dimensions=!1,this._patterns=!1,this._lineWeights=!0,this._modelOverrides=new l.Uint32Map,this._elementOverrides=new l.Uint32Map,this._subCategoryOverrides=new l.Uint32Map,this._visibleSubCategories=new l.Uint32Set,this._subCategoryPriorities=new l.Uint32Map,this._modelSubCategoryOverrides=new l.Uint32Map,this.neverDrawnAnimationNodes=new Set,this.animationNodeOverrides=new Map}isSubCategoryIdVisible(t){return this.isSubCategoryVisible(l.getLowerUint32(t),l.getUpperUint32(t))}getModelOverridesById(t){return this.getModelOverrides(l.getLowerUint32(t),l.getUpperUint32(t))}getElementOverridesById(t){return this.getElementOverrides(l.getLowerUint32(t),l.getUpperUint32(t),0)}getSubCategoryOverridesById(t){return this.getSubCategoryOverrides(l.getLowerUint32(t),l.getUpperUint32(t))}isFeatureVisible(t){const{elementId:e,subCategoryId:i,geometryClass:s}=t,n=l.isInvalid(e)?void 0:l.getUint32Pair(e);if(void 0!==n&&this.isNeverDrawn(n.lower,n.upper,0))return!1;const r=void 0!==n&&this.isAlwaysDrawn(n.lower,n.upper);return r||this.isAlwaysDrawnExclusive?r:!!this.isSubCategoryIdVisible(i)&&this.isClassVisible(s)}}var Wr;function Gr(t,e,i){return t+i*(e-t)}function Hr(t,e){return i(t.x,e.x)||i(t.y,e.y)||i(t.z,e.z)}qr._weight1Appearance=Ur.fromJSON({weight:1}),function(t){t.supplement=function(t){return{getFeatureAppearance:(e,i,s,n,r,o,a,c,h,l)=>{const d=e.getAppearance(i,s,n,r,o,a,c,h,l);return d?t(d):d}}},t.chain=function(t,e){return t===e?t:{getFeatureAppearance:(i,s,n,r,o,a,c,h,l,d)=>e.getFeatureAppearance(function(t,e){return{getAppearance:(i,s,n,r,o,a,c,h,l)=>e.getFeatureAppearance(t,i,s,n,r,o,a,c,h,l)}}(i,t),s,n,r,o,a,c,h,l,d)}}}(Wr||(Wr={}));const Jr=new $,Kr=new $;function jr(t,e){return i(t.low,e.low)||i(t.high,e.high)}var Qr,$r,to;function eo(t){const e=new Set,i=t=>{t&&e.add(t.buffer)};i(t.binaryData),i(t.featureTable.data),i(t.featureTable.animationNodeIds);const s=t=>{if("pattern"!==t.type)switch(i(t.params.vertices.data),"instances"===t.modifier?.type&&(i(t.modifier.transforms),i(t.modifier.featureIds),i(t.modifier.symbologyOverrides)),t.type){case"point":i(t.params.indices);break;case"polyline":i(t.params.polyline.indices),i(t.params.polyline.prevIndices),i(t.params.polyline.nextIndicesAndParams);break;case"mesh":i(t.params.surface.indices);const e=t.params.edges;e&&(i(e.segments?.indices),i(e.segments?.endPointAndQuadIndices),i(e.silhouettes?.indices),i(e.silhouettes?.endPointAndQuadIndices),i(e.silhouettes?.normalPairs),i(e.polylines?.indices),i(e.polylines?.prevIndices),i(e.polylines?.nextIndicesAndParams),i(e.indexed?.indices),i(e.indexed?.edges.data))}else i(t.params.xyOffsets)};for(const e of t.nodes)for(const t of e.primitives)s(t);for(const e of t.patterns.values())for(const t of e)s(t);return Array.from(e)}!function(t){let a;!function(t){t[t.Step=1]="Step",t[t.Linear=2]="Linear"}(a=t.Interpolation||(t.Interpolation={}));class c{constructor(t){this.time=t.time,this.interpolation=t.interpolation===a.Linear?t.interpolation:a.Step}toJSON(){const t={time:this.time};return this.interpolation===a.Linear&&(t.interpolation=this.interpolation),t}compareTo(t){return i(this.interpolation,t.interpolation)||i(this.time,t.time)}equals(t){return 0===this.compareTo(t)}}t.TimelineEntry=c;class h extends c{constructor(t){super(t),"number"!=typeof t.value?this.value=100:this.value=Math.max(0,Math.min(100,t.value))}toJSON(){const t=super.toJSON();return 100!==this.value&&(t.value=this.value),t}compareTo(t){return e(t instanceof h),super.compareTo(t)||i(this.value,t.value)}}t.VisibilityEntry=h;class d extends c{constructor(t){super(t),t.value&&(this.value=new wr(t.value.red,t.value.green,t.value.blue))}toJSON(){const t=super.toJSON();return this.value&&(t.value={red:this.value.r,green:this.value.g,blue:this.value.b}),t}compareTo(t){return e(t instanceof d),super.compareTo(t)||r(((t,e)=>t.compareTo(e)),this.value,t.value)}}t.ColorEntry=d;class f{constructor(t,e,i){this.position=t,this.pivot=e,this.orientation=i}static fromJSON(t){return t.pivot&&t.position&&t.orientation?new f($.fromJSON(t.position),$.fromJSON(t.pivot),Rt.fromJSON(t.orientation)):void 0}toJSON(){return{position:[this.position.x,this.position.y,this.position.z],pivot:[this.pivot.x,this.pivot.y,this.pivot.z],orientation:[this.orientation.x,this.orientation.y,this.orientation.z,this.orientation.w]}}compareTo(t){return Hr(this.pivot,t.pivot)||Hr(this.position,t.position)||(e=this.orientation,s=t.orientation,i(e.x,s.x)||i(e.y,s.y)||i(e.z,s.z)||i(e.w,s.w));var e,s}equals(t){return this.pivot.isAlmostEqual(t.pivot)&&this.position.isAlmostEqual(t.position)&&this.orientation.isAlmostEqual(t.orientation)}}t.TransformComponents=f;class p extends c{constructor(t){super(t),this.value=t.value?pt.fromJSON(t.value.transform):pt.identity,t.value&&(this.components=f.fromJSON(t.value))}toJSON(){const t=super.toJSON();return this.components?(t.value=this.components.toJSON(),t.value.transform=this.value.toRows()):t.value={transform:this.value.toRows()},t}compareTo(t){e(t instanceof p);const i=super.compareTo(t);return 0!==i?i:this.components||t.components?this.components&&t.components?this.components.compareTo(t.components):this.components?1:-1:Hr(this.value.origin,t.value.origin)||(s=this.value.matrix,n=t.value.matrix,Hr(s.columnX(Jr),n.columnX(Kr))||Hr(s.columnY(Jr),n.columnY(Kr))||Hr(s.columnZ(Jr),n.columnZ(Kr)));var s,n}}t.TransformEntry=p;class m{constructor(t){this.position=Q.fromJSON(t.position),this.direction=Q.fromJSON(t.direction),this.hidden=!0===t.hidden,this.visible=!0===t.visible}toJSON(){const t={position:[this.position.x,this.position.y,this.position.z],direction:[this.direction.x,this.direction.y,this.direction.z]};return this.visible&&(t.visible=!0),this.hidden&&(t.hidden=!0),t}compareTo(t){return Hr(this.position,t.position)||Hr(this.direction,t.direction)||s(this.visible,t.visible)||s(this.hidden,t.hidden)}equals(t){return 0===this.compareTo(t)}}t.CuttingPlane=m;class x extends c{constructor(t){super(t),t.value&&(this.value=new m(t.value))}toJSON(){const t=super.toJSON();return this.value&&(t.value=this.value.toJSON()),t}compareTo(t){return e(t instanceof x),super.compareTo(t)||r(((t,e)=>t.compareTo(e)),this.value,t.value)}}t.CuttingPlaneEntry=x;class y{constructor(t=0,e=0,i=0){this.init(t,e,i)}init(t=0,e=0,i=0){this.lowerIndex=t,this.upperIndex=e,this.fraction=i}}t.Interval=y;class _{constructor(t,e){this.duration=ft.createNull(),this._entries=t.map((t=>{const i=new e(t);return this.duration.extendX(i.time),i}))}get length(){return this._entries.length}[Symbol.iterator](){return this._entries[Symbol.iterator]()}getEntry(t){return this._entries[t]}getValue(t){return this.getEntry(t)?.value}toJSON(){return this._entries.map((t=>t.toJSON()))}compareTo(t){let e=i(this._entries.length,t._entries.length)||jr(this.duration,t.duration);if(0===e)for(let i=0;i<this.length&&0===(e=this._entries[i].compareTo(t._entries[i]));i++);return e}equals(t){return 0===this.compareTo(t)}findInterval(t,e){if(0===this.length)return;if(e=e??new y,t<this._entries[0].time)return e.init(0,0,0),e;const i=this.length-1;if(t>=this._entries[i].time)return e.init(i,i,0),e;for(let s=0;s<i;s++){const i=this._entries[s].time,n=this._entries[s+1].time;if(i<=t&&n>=t){let r;return r=a.Linear===this._entries[s].interpolation?(t-i)/(n-i):0,e.init(s,s+1,r),e}}}}t.TimelineEntryList=_;const v=new y;class P extends _{getValue(t){return super.getValue(t)??100}}t.VisibilityTimelineEntries=P;class I extends _{getValue(t){return super.getValue(t)??pt.identity}}t.TransformTimelineEntries=I;class A{constructor(t){this.duration=ft.createNull(),t.visibilityTimeline&&(this.visibility=new P(t.visibilityTimeline,h),this.duration.extendRange(this.visibility.duration)),t.colorTimeline&&(this.color=new _(t.colorTimeline,d),this.duration.extendRange(this.color.duration)),t.transformTimeline&&(this.transform=new I(t.transformTimeline,p),this.duration.extendRange(this.transform.duration)),t.cuttingPlaneTimeline&&(this.cuttingPlane=new _(t.cuttingPlaneTimeline,x),this.duration.extendRange(this.cuttingPlane.duration))}toJSON(){return{visibilityTimeline:this.visibility?.toJSON(),colorTimeline:this.color?.toJSON(),transformTimeline:this.transform?.toJSON(),cuttingPlaneTimeline:this.cuttingPlane?.toJSON()}}compareTo(t){const e=jr(this.duration,t.duration);return 0!==e?e:!!this.visibility!=!!t.visibility?this.visibility?1:-1:!!this.color!=!!t.color?this.color?1:-1:!!this.transform!=!!t.transform?this.transform?1:-1:!!this.cuttingPlane!=!!t.cuttingPlane?this.cuttingPlane?1:-1:r(((t,e)=>t.compareTo(e)),this.visibility,t.visibility)||r(((t,e)=>t.compareTo(e)),this.color,t.color)||r(((t,e)=>t.compareTo(e)),this.transform,t.transform)||r(((t,e)=>t.compareTo(e)),this.cuttingPlane,t.cuttingPlane)}equals(t){return 0===this.compareTo(t)}getVisibility(t){let e;if(!this.visibility||!(e=this.visibility.findInterval(t,v)))return 100;let i=this.visibility.getValue(e.lowerIndex)??100;return e.fraction>0&&(i=Gr(i,this.visibility.getValue(e.upperIndex)??100,e.fraction)),i}getColor(t){let e;if(!this.color||!(e=this.color.findInterval(t,v)))return;const i=this.color.getValue(e.lowerIndex);if(i&&e.fraction>0){const t=this.color.getValue(e.upperIndex);if(t)return function(t,e,i){return new wr(Gr(t.r,e.r,i),Gr(t.g,e.g,i),Gr(t.b,e.b,i))}(i,t,e.fraction)}return i}getAnimationTransform(t){let e;if(!this.transform||!(e=this.transform.findInterval(t,v)))return pt.identity;let i=this.transform.getValue(e.lowerIndex);if(e.fraction>0){const t=this.transform.getEntry(e.lowerIndex)?.components,s=this.transform.getEntry(e.upperIndex)?.components;if(t&&s){const n=Rt.interpolateQuaternions(t.orientation,e.fraction,s.orientation),r=xt.createFromQuaternion(n),o=pt.createTranslation(t.pivot),a=pt.createTranslation(t.position.interpolate(e.fraction,s.position)).multiplyTransformMatrix3d(r);a.multiplyTransformTransform(o,a),i=a}else{const t=this.transform.getValue(e.upperIndex),s=i.matrix.inverse()?.toQuaternion(),n=t.matrix.inverse()?.toQuaternion();if(s&&n){const r=Rt.interpolateQuaternions(s,e.fraction,n),o=xt.createFromQuaternion(r),a=$.createFrom(i.origin),c=$.createFrom(t.origin);i=pt.createRefs(a.interpolate(e.fraction,c),o)}}}return i}getCuttingPlane(t){let e;if(!this.cuttingPlane||!(e=this.cuttingPlane.findInterval(t,v)))return;const i=this.cuttingPlane.getValue(e.lowerIndex);if(!i)return;const s=Q.createFrom(i.position),n=$.createFrom(i.direction),r=e.fraction>0?this.cuttingPlane.getValue(e.upperIndex):void 0;if(r)s.interpolate(e.fraction,r.position,s),n.interpolate(e.fraction,r.direction,n);else if(i.hidden||i.visible)return;return n.negate(n),n.normalizeInPlace(),yt.create(s,n)}getClipVector(t){const e=this.getCuttingPlane(t);if(!e)return;const i=xr.createPlane(e),s=Gi.createConvexSets([en.createPlanes([i])]),n=$i.createCapture(s);return ns.createCapture([n])}getFeatureAppearance(t,e){const i=t<100?1-t/100:void 0,s=this.getColor(e);return void 0!==s||void 0!==i?Ur.fromJSON({rgb:s,transparency:i}):void 0}}t.Timeline=A;class S extends A{constructor(t){super(t),this.batchId=t.batchId,this._elementIds=t.elementIds}static fromJSON(t){return new S(t??{elementIds:[],batchId:0})}toJSON(){return{...super.toJSON(),batchId:this.batchId,elementIds:this._elementIds}}get containsElementIds(){return this._elementIds.length>0}compareElementIds(t){if(typeof this._elementIds==typeof t._elementIds){const s=i(this._elementIds.length,t._elementIds.length);if(0!==s)return s;if("string"==typeof this._elementIds)return e("string"==typeof t._elementIds),n(this._elementIds,t._elementIds)}const r=this.elementIds[Symbol.iterator](),o=t.elementIds[Symbol.iterator]();for(;;){const t=r.next(),e=o.next();if(t.done!==e.done)return s(!!t.done,!!e.done);if(t.done)return 0;const i=n(t.value,e.value);if(0!==i)return i}}compareTo(t){return e(t instanceof S),i(this.batchId,t.batchId)||this.compareElementIds(t)||super.compareTo(t)}static getElementIds(t){return"string"==typeof t?g.iterable(t):Array.isArray(t)?t:[]}get elementIds(){return S.getElementIds(this._elementIds)}get containsFeatureOverrides(){return void 0!==this.visibility||void 0!==this.color}get requiresBatching(){return!!this.cuttingPlane||0!==this.batchId&&(void 0!==this.color||void 0!==this.visibility)}get containsTransform(){return void 0!==this.transform}addSymbologyOverrides(t,i){e(0!==this.batchId);const s=this.getVisibility(i);if(s<=0)return void t.setAnimationNodeNeverDrawn(this.batchId);const n=this.getFeatureAppearance(s,i);n&&t.overrideAnimationNode(this.batchId,n)}}t.ElementTimeline=S;class w extends A{constructor(t){super(t),this._cachedComparisons=new WeakMap,this.modelId=t.modelId,this.realityModelUrl=t.realityModelUrl,this.containsModelClipping=void 0!==this.cuttingPlane;let e=void 0!==this.visibility||void 0!==this.color,i=!1,s=!1;const n=[],r=[];let o=!1;for(const a of t.elementTimelines){const t=S.fromJSON(a);r.push(t),this.duration.extendRange(t.duration),t.containsTransform&&(s=!0,t.batchId&&n.push(t.batchId)),e||=t.containsFeatureOverrides,i||=t.requiresBatching,o=o||t.containsElementIds}this.elementTimelines=r,this.transformBatchIds=n,this.omitsElementIds=r.length>0&&!o,this.containsFeatureOverrides=e,this.requiresBatching=i,this.containsTransform=s}static fromJSON(t){return new w(t??{elementTimelines:[],modelId:l.invalid})}toJSON(){return{...super.toJSON(),modelId:this.modelId,realityModelUrl:this.realityModelUrl,elementTimelines:this.elementTimelines.map((t=>t.toJSON()))}}compareTo(t){if(this===t)return 0;const r=this._cachedComparisons.get(t);if(void 0!==r)return r;e(t instanceof w);let a=n(this.modelId,t.modelId)||o(this.realityModelUrl,t.realityModelUrl)||i(this.elementTimelines.length,t.elementTimelines.length)||s(this.containsFeatureOverrides,t.containsFeatureOverrides)||s(this.containsModelClipping,t.containsModelClipping)||s(this.containsTransform,t.containsTransform)||super.compareTo(t);if(0===a)for(let e=0;e<this.elementTimelines.length&&0===(a=this.elementTimelines[e].compareTo(t.elementTimelines[e]));e++);return this._cachedComparisons.set(t,a),t._cachedComparisons.set(this,-a),a}findByBatchId(t){return this.elementTimelines.find((e=>e.batchId===t))}addSymbologyOverrides(t,e){const i=this.getFeatureAppearance(this.getVisibility(e),e);i&&t.override({modelId:this.modelId,appearance:i});for(const i of this.elementTimelines)i.addSymbologyOverrides(t,e)}getTransform(t,e){return this.findByBatchId(t)?.getAnimationTransform(e)}get maxBatchId(){if(void 0===this._maxBatchId){this._maxBatchId=0;for(const t of this.elementTimelines)this._maxBatchId=Math.max(this._maxBatchId,t.batchId)}return this._maxBatchId}getTimelineForElement(t,e){if(!this._idPairToElementTimeline){this._idPairToElementTimeline=new l.Uint32Map;for(const t of this.elementTimelines)for(const e of t.elementIds)this._idPairToElementTimeline.setById(e,t)}return this._idPairToElementTimeline.get(t,e)}get discreteBatchIds(){if(!this._discreteBatchIds){this._discreteBatchIds=new Set(this.transformBatchIds);for(const t of this.elementTimelines)t.containsTransform||void 0===t.cuttingPlane||this._discreteBatchIds.add(t.batchId)}return this._discreteBatchIds}getBatchIdForFeature(t){e(l.fromUint32PairObject(t.modelId)===this.modelId);const i=this.getTimelineForElement(t.elementId.lower,t.elementId.upper);return i?.batchId??0}}t.ModelTimeline=w;class C{compareTo(t){if(this===t)return 0;const e=this._cachedComparisons.get(t);if(void 0!==e)return e;let n=i(this.modelTimelines.length,t.modelTimelines.length)||s(this.containsModelClipping,t.containsModelClipping)||s(this.requiresBatching,t.requiresBatching)||s(this.containsTransform,t.containsTransform)||s(this.containsFeatureOverrides,t.containsFeatureOverrides)||jr(this.duration,t.duration);if(0===n)for(let e=0;e<this.modelTimelines.length&&0===(n=this.modelTimelines[e].compareTo(t.modelTimelines[e]));e++);return this._cachedComparisons.set(t,n),t._cachedComparisons.set(this,-n),n}equals(t){return 0===this.compareTo(t)}constructor(t){this._cachedComparisons=new WeakMap,this.duration=ft.createNull();const e=new Set,i=[];let s=!1,n=!1,r=!1,o=!1;for(const a of t){const t=w.fromJSON(a);i.push(t),this.duration.extendRange(t.duration),s||=t.containsModelClipping,n||=t.requiresBatching,r||=t.containsTransform,o||=t.containsFeatureOverrides;for(const i of t.transformBatchIds)e.add(i)}this.modelTimelines=i,this.containsModelClipping=s,this.containsTransform=r,this.requiresBatching=n||this.containsTransform,this.containsFeatureOverrides=o,this.transformBatchIds=e}static fromJSON(t){if(Array.isArray(t)&&0!==t.length)return new C(t)}toJSON(){return this.modelTimelines.map((t=>t.toJSON()))}find(t){return this.modelTimelines.find((e=>e.modelId===t))}getTransformBatchIds(t){return this.find(t)?.transformBatchIds}getTransform(t,e,i){return this.find(t)?.getTransform(e,i)}addSymbologyOverrides(t,e){for(const i of this.modelTimelines)i.addSymbologyOverrides(t,e)}discloseIds(t){for(const e of this.modelTimelines){t.addModel(e.modelId);for(const i of e.elementTimelines)for(const e of i.elementIds)t.addElement(e)}}modelRequiresBatching(t){return this.requiresBatching&&this.modelTimelines.some((e=>e.modelId===t&&e.requiresBatching))}get discreteBatchIds(){if(this._discreteBatchIds)return this._discreteBatchIds;this._discreteBatchIds=new Set;for(const t of this.modelTimelines)for(const e of t.discreteBatchIds)this._discreteBatchIds.add(e);return this._discreteBatchIds}getBatchIdForFeature(t){let e;const i=this._lastFeatureModelTimeline;if(i&&i.idLower===t.modelId.lower&&i.idUpper===t.modelId.upper)e=i.timeline;else{const i=l.fromUint32PairObject(t.modelId);e=this.find(i),this._lastFeatureModelTimeline={timeline:e,idLower:t.modelId.lower,idUpper:t.modelId.upper}}return e?.getBatchIdForFeature(t)??0}get maxBatchId(){return this._maxBatchId??(this._maxBatchId=this.modelTimelines.reduce(((t,e)=>Math.max(t,e.maxBatchId)),0))}}t.Script=C,t.ScriptReference=class{constructor(t,i){"string"==typeof t?(e(i instanceof C),this.sourceId=t,this.script=i):(e(void 0===i),this.script=t,this.sourceId=l.invalid)}};class T{addVisibility(t,e,i=a.Linear){this.visibility||(this.visibility=[]),this.visibility.push({time:t,value:e,interpolation:i})}addColor(t,e,i=a.Linear){this.color||(this.color=[]);const s=e instanceof wr?{red:e.r,green:e.g,blue:e.b}:e;this.color.push({time:t,value:s,interpolation:i})}addCuttingPlane(t,e,i=a.Linear){let s;this.cuttingPlane||(this.cuttingPlane=[]),e&&(s={position:[e.position.x,e.position.y,e.position.z],direction:[e.direction.x,e.direction.y,e.direction.z]},e.visible&&(s.visible=!0),e.hidden&&(s.hidden=!0)),this.cuttingPlane.push({time:t,value:s,interpolation:i})}addTransform(t,e,i,s=a.Linear){this.transform||(this.transform=[]);const n={transform:e?.toRows()};i&&(n.pivot=[i.pivot.x,i.pivot.y,i.pivot.z],n.orientation=i.orientation.toJSON(),n.position=[i.position.x,i.position.y,i.position.z]),this.transform.push({time:t,value:n,interpolation:s})}finish(){const t={};return this.visibility?.length&&(t.visibilityTimeline=this.visibility),this.color?.length&&(t.colorTimeline=this.color),this.transform?.length&&(t.transformTimeline=this.transform),this.cuttingPlane?.length&&(t.cuttingPlaneTimeline=this.cuttingPlane),t}}t.TimelineBuilder=T;class k extends T{constructor(t,e){super(),this.batchId=t,this.elementIds=e}finish(){const t=super.finish();return t.batchId=this.batchId,t.elementIds=this.elementIds,t}}t.ElementTimelineBuilder=k;class F extends T{constructor(t,e){super(),this._elements=[],this.modelId=t,this._obtainNextBatchId=e}addElementTimeline(t){const e=this._obtainNextBatchId();let i;if("string"==typeof t&&l.isValidId64(t)&&(t=[t]),"string"==typeof t)i=t;else{const e=Array.from(t);u.sortArray(e),i=g.compressIds(e)}const s=new k(e,i);return this._elements.push(s),s}finish(){const t=super.finish();return t.modelId=this.modelId,void 0!==this.realityModelUrl&&(t.realityModelUrl=this.realityModelUrl),t.elementTimelines=this._elements.map((t=>t.finish())),t}}t.ModelTimelineBuilder=F,t.ScriptBuilder=class{constructor(){this._nextBatchId=1,this._models=[]}addModelTimeline(t){const e=new F(t,(()=>this._nextBatchId++));return this._models.push(e),e}finish(){return this._models.map((t=>t.finish()))}}}(Qr||(Qr={})),function(t){function e(t){return"object"==typeof t&&0===Object.keys(t).length}function i(t){return void 0===t||e(t)}function s(t){return null==t}t.asBool=function(t,e=!1){return s(t)?e:!!t},t.asInt=function(t,e=0){return"number"==typeof t?Math.trunc(t):e},t.asDouble=function(t,e=0){return"number"==typeof t?t:e},t.asString=function(t,e=""){return s(t)?e:t.toString()},t.asArray=function(t){return Array.isArray(t)?t:void 0},t.asObject=function(t){return"object"==typeof t?t:void 0},t.setOrRemoveNumber=function(t,e,i,s){i===s?delete t[e]:t[e]=i},t.setOrRemoveBoolean=function(t,e,i,s){i===s?delete t[e]:t[e]=i},t.isEmptyObject=e,t.isEmptyObjectOrUndefined=i,t.isNonEmptyObject=function(t){return!i(t)},t.toObject=function t(e){if("boolean"==typeof e||"number"==typeof e||"string"==typeof e)return e;if("object"!=typeof e)return;if(void 0!==e.toJSON)return t(e.toJSON());if(Array.isArray(e)){const i=new Array(e.length);return e.forEach(((e,s)=>i[s]=t(e))),i}const i={};return Object.getOwnPropertyNames(e).forEach((s=>{const n=t(e[s]);void 0!==n&&(i[s]=n)})),i}}($r||($r={}));class io{constructor(t,e){this._curPos=0,void 0!==e?(this._view=new DataView(t,e.byteOffset,e.byteLength),this._byteOffset=e.byteOffset):(this._view=new DataView(t),this._byteOffset=0)}static fromUint8Array(t){const{byteOffset:e,byteLength:i}=t;return new io(t.buffer,{byteOffset:e,byteLength:i})}static fromArrayBuffer(t,e){return new io(t,e)}get length(){return this._view.byteLength}get remainingLength(){return this.length-this.curPos}get isPastTheEnd(){return this.curPos>this.length}get isAtTheEnd(){return this.curPos===this.length}get curPos(){return this._curPos}set curPos(t){this._curPos=t,e(!this.isPastTheEnd)}advance(t){return this.curPos=this.curPos+t,!this.isPastTheEnd}rewind(t){return!(this.curPos-t<0||(this.curPos=this.curPos-t,0))}reset(){this.curPos=0}readUint8(){return this.read(1,(t=>t.getUint8(this.curPos)))}readUint16(){return this.read(2,(t=>t.getUint16(this.curPos,!0)))}readUint32(){return this.read(4,(t=>t.getUint32(this.curPos,!0)))}readInt32(){return this.read(4,(t=>t.getInt32(this.curPos,!0)))}readFloat32(){return this.read(4,(t=>t.getFloat32(this.curPos,!0)))}readFloat64(){return this.read(8,(t=>t.getFloat64(this.curPos,!0)))}readId64(){return l.fromUint32Pair(this.readUint32(),this.readUint32())}readUint24(){return this.readUint8()|this.readUint8()<<8|this.readUint8()<<16}get nextUint8(){return this.readUint8()}get nextUint16(){return this.readUint16()}get nextUint32(){return this.readUint32()}get nextInt32(){return this.readInt32()}get nextFloat32(){return this.readFloat32()}get nextFloat64(){return this.readFloat64()}get nextId64(){return this.readId64()}get nextUint24(){return this.readUint24()}nextBytes(t){const e=new Uint8Array(this.arrayBuffer,this.curPos+this._byteOffset,t);return this.advance(t),e}readBytes(t,e){return new Uint8Array(this.arrayBuffer,t+this._byteOffset,e)}nextUint32s(t){const e=4*t,i=new Uint32Array(this.arrayBuffer,this.curPos+this._byteOffset,t);return this.advance(e),i}get arrayBuffer(){return this._view.buffer}read(t,e){const i=e(this._view);return this.advance(t),i}}!function(t){function e(t,e,i){return e<=t&&t<=i}t.decodeWithFromCharCode=function(t){let i="";const s=function(t){let i=0,s=0,n=0,r=128,o=191;const a=[],c=t.length;for(let h=0;h<c;h++){const c=t[h];if(0===n){if(e(c,0,127)){a.push(c);continue}if(e(c,194,223)){n=1,i=31&c;continue}if(e(c,224,239)){224===c?r=160:237===c&&(o=159),n=2,i=15&c;continue}if(e(c,240,244)){240===c?r=144:244===c&&(o=143),n=3,i=7&c;continue}return}e(c,r,o)?(r=128,o=191,i=i<<6|63&c,++s,s===n&&(a.push(i),i=n=s=0)):(i=n=s=0,r=128,o=191,--h)}return a}(t);if(void 0!==s){for(let t of s)t<=65535?i+=String.fromCharCode(t):(t-=65536,i+=String.fromCharCode(55296+(t>>10),56320+(1023&t)));return i}}}(to||(to={}));let so=!0;var no,ro,oo,ao,co,ho,lo,uo,fo,go,po,mo,xo,yo,_o,vo,Po,Io,Ao,So,wo,Co;(oo=no||(no={}))[oo.Unknown=0]="Unknown",oo[oo.B3dm=1835283298]="B3dm",oo[oo.Gltf=1179937895]="Gltf",oo[oo.Pnts=1937010288]="Pnts",oo[oo.IModel=1818512745]="IModel",oo[oo.Cmpt=1953525091]="Cmpt",oo[oo.I3dm=1835283305]="I3dm",oo[oo.A3x=5780289]="A3x",function(t){t[t.Success=0]="Success",t[t.InvalidTileData=1]="InvalidTileData",t[t.InvalidHeader=2]="InvalidHeader",t[t.InvalidBatchTable=3]="InvalidBatchTable",t[t.InvalidScene=4]="InvalidScene",t[t.InvalidFeatureTable=5]="InvalidFeatureTable",t[t.NewerMajorVersion=6]="NewerMajorVersion",t[t.Canceled=7]="Canceled"}(ro||(ro={}));class To{constructor(t){this._format=function(t){const e=t;return function(t){switch(t){case no.Unknown:case no.B3dm:case no.Gltf:case no.IModel:case no.Pnts:case no.Cmpt:case no.I3dm:case no.A3x:return!0;default:return!1}}(e)?e:no.Unknown}(t.readUint32()),this.version=t.readUint32()}get format(){return this._format}invalidate(){this._format=no.Unknown}}function ko(t,e){const i=t.readFloat64(),s=t.readFloat64(),n=t.readFloat64();return void 0===e?new Q(i,s,n):(e.set(i,s,n),e)}!function(t){t[t.Version1=1]="Version1",t[t.Version2=2]="Version2",t[t.CurrentVersion=1]="CurrentVersion",t[t.Gltf1SceneFormat=0]="Gltf1SceneFormat"}(ao||(ao={})),function(t){t[t.JSON=1313821514]="JSON",t[t.Binary=5130562]="Binary"}(co||(co={}));class Fo{get isTileSection(){return Fo.Type.TileSection===this.type}get isGlyph(){return Fo.Type.Glyph===this.type}get isSkyBox(){return Fo.Type.SkyBox===this.type}constructor(t){this.type=t}}!function(t){let e;!function(t){t[t.Normal=0]="Normal",t[t.Glyph=1]="Glyph",t[t.TileSection=2]="TileSection",t[t.SkyBox=3]="SkyBox",t[t.FilteredTileSection=4]="FilteredTileSection",t[t.ThematicGradient=5]="ThematicGradient"}(e=t.Type||(t.Type={})),t.Params=class{constructor(e,i=t.Type.Normal,s=!1){this.key=e,this.type=i,this.isOwned=s}get isTileSection(){return t.Type.TileSection===this.type}get isGlyph(){return t.Type.Glyph===this.type}get isSkyBox(){return t.Type.SkyBox===this.type}}}(Fo||(Fo={}));class Mo{constructor(t){this.key=t.key,this.textureMapping=t.textureMapping}get hasTexture(){return void 0!==this.textureMapping?.texture}}!function(t){class e{constructor(t){this.diffuse=.6,this.specular=.4,this.specularExponent=13.5,this.reflect=0,this.refract=1,this.ambient=.3,this.shadows=!0,this.key=t}get alpha(){return this._alpha}set alpha(t){var e;this._alpha=void 0!==t?(e=t,Math.max(0,Math.min(1,e))):void 0}static fromColors(t,i,s,n,r,o){const a=new e;return a.key=t,a.diffuseColor=i,a.specularColor=s,a.emissiveColor=n,a.reflectColor=r,a.textureMapping=o,a}}e.defaults=new e,t.Params=e}(Mo||(Mo={})),Object.freeze(Mo.Params.defaults),function(t){function e(e,i=t.rangeScale16){return e>=0&&e<i+1}function i(e,i,s,n=t.rangeScale16){return Math.floor(Math.max(0,Math.min(n,.5+(e-i)*s)))}t.rangeScale16=65535,t.rangeScale8=255,t.computeScale=function(e,i=t.rangeScale16){return 0===e?e:i/e},t.isInRange=e,t.quantize=i,t.isQuantizable=function(s,n,r,o=t.rangeScale16){return e(i(s,n,r,o))},t.unquantize=function(t,e,i){return 0===i?e:e+t/i},t.isQuantized=function(t){return e(t)&&t===Math.floor(t)}}(ho||(ho={}));class bo{constructor(t=0,e=0,i=0,s=0){this.origin=new H,this.scale=new H,this.setFrom(t,e,i,s)}setFrom(t,e,i,s){this.origin.x=t,this.origin.y=e,this.scale.x=i,this.scale.y=s}copyFrom(t){this.setFrom(t.origin.x,t.origin.y,t.scale.x,t.scale.y)}clone(t){const e=void 0!==t?t:new bo;return e.copyFrom(this),e}setFromRange(t,e=ho.rangeScale16){t.isNull?this.origin.x=this.origin.y=this.scale.x=this.scale.y=0:this.setFrom(t.low.x,t.low.y,ho.computeScale(t.high.x-t.low.x,e),ho.computeScale(t.high.y-t.low.y,e))}static fromRange(t,e,i=ho.rangeScale16){const s=void 0!==e?e:new bo;return s.setFromRange(t,i),s}unquantize(t,e,i){return(i=i??new H).x=ho.unquantize(t,this.origin.x,this.scale.x),i.y=ho.unquantize(e,this.origin.y,this.scale.y),i}static fromNormalizedRange(t=ho.rangeScale16){return bo.fromRange(gt.createArray([H.create(-1,-1),H.create(1,1)]),void 0,t)}static fromZeroToOne(t=ho.rangeScale16){return bo.fromRange(gt.createArray([H.create(0,0),H.create(1,1)]),void 0,t)}static fromOriginAndScale(t,e,i,s){return new bo(t,e,i,s)}get rangeDiagonal(){return J.createFrom({x:0===this.scale.x?0:ho.rangeScale16/this.scale.x,y:0===this.scale.y?0:ho.rangeScale16/this.scale.y})}isQuantizable(t){return ho.isQuantizable(t.x,this.origin.x,this.scale.x)&&ho.isQuantizable(t.y,this.origin.y,this.scale.y)}toJSON(){return{origin:{x:this.origin.x,y:this.origin.y},scale:{x:this.scale.x,y:this.scale.y}}}static fromJSON(t){return this.fromOriginAndScale(t.origin.x,t.origin.y,t.scale.x,t.scale.y)}}class Eo{get x(){return this._x}set x(t){e(ho.isQuantized(t)),this._x=t}get y(){return this._y}set y(t){e(ho.isQuantized(t)),this._y=t}constructor(){this._x=0,this._y=0}init(t,e){this.x=ho.quantize(t.x,e.origin.x,e.scale.x),this.y=ho.quantize(t.y,e.origin.y,e.scale.y)}static create(t,e){const i=new Eo;return i.init(t,e),i}copyFrom(t){this.x=t.x,this.y=t.y}clone(t){const e=void 0!==t?t:new Eo;return e.copyFrom(this),e}setFromScalars(t,e){this.x=t,this.y=e}static fromScalars(t,e){const i=new Eo;return i.setFromScalars(t,e),i}unquantize(t,e){const i=void 0!==e?e:new H;return i.x=ho.unquantize(this.x,t.origin.x,t.scale.x),i.y=ho.unquantize(this.y,t.origin.y,t.scale.y),i}}!function(t){const e=new Eo;function i(t,e,i){const s=2*e,n=t[s+0],r=t[s+1];if(void 0===n||void 0===r)throw new Error("Index out of range");return(i=i??new Eo).setFromScalars(n,r),i}t.getQPoint=i,t.unquantizePoint=function(t,s,n){return i(t.points,s,e).unquantize(t.params,n)}}(lo||(lo={}));class Xo{constructor(t=0,e=0,i=0,s=0,n=0,r=0){this.origin=new Q,this.scale=new Q,this.setFrom(t,e,i,s,n,r)}setFrom(t,e,i,s,n,r){this.origin.x=t,this.origin.y=e,this.origin.z=i,this.scale.x=s,this.scale.y=n,this.scale.z=r}copyFrom(t){this.setFrom(t.origin.x,t.origin.y,t.origin.z,t.scale.x,t.scale.y,t.scale.z)}clone(t){const e=void 0!==t?t:new Xo;return e.copyFrom(this),e}setFromOriginAndScale(t,e){this.setFrom(t.x,t.y,t.z,e.x,e.y,e.z)}setFromRange(t,e=ho.rangeScale16){t.isNull?(this.origin.x=this.origin.y=this.origin.z=0,this.scale.x=this.scale.y=this.scale.z=0):this.setFrom(t.low.x,t.low.y,t.low.z,ho.computeScale(t.high.x-t.low.x,e),ho.computeScale(t.high.y-t.low.y,e),ho.computeScale(t.high.z-t.low.z,e))}unquantize(t,e,i,s){const n=void 0!==s?s:new Q;return n.x=ho.unquantize(t,this.origin.x,this.scale.x),n.y=ho.unquantize(e,this.origin.y,this.scale.y),n.z=ho.unquantize(i,this.origin.z,this.scale.z),n}static fromRange(t,e,i=ho.rangeScale16){const s=void 0!==e?e:new Xo;return s.setFromRange(t,i),s}static fromOriginAndScale(t,e,i){const s=void 0!==i?i:new Xo;return s.setFromOriginAndScale(t,e),s}static fromNormalizedRange(t=ho.rangeScale16){return Xo.fromRange(ut.createArray([Q.create(-1,-1,-1),Q.create(1,1,1)]),void 0,t)}static fromZeroToOne(t=ho.rangeScale16){return Xo.fromRange(ut.createArray([Q.create(0,0,0),Q.create(1,1,1)]),void 0,t)}get rangeDiagonal(){return $.createFrom({x:0===this.scale.x?0:ho.rangeScale16/this.scale.x,y:0===this.scale.y?0:ho.rangeScale16/this.scale.y,z:0===this.scale.z?0:ho.rangeScale16/this.scale.z})}isQuantizable(t){return ho.isQuantizable(t.x,this.origin.x,this.scale.x)&&ho.isQuantizable(t.y,this.origin.y,this.scale.y)&&ho.isQuantizable(t.z,this.origin.z,this.scale.z)}computeRange(t){const e=ut.createNull(t);return e.extendPoint(this.origin),e.extendPoint(this.origin.plus(this.rangeDiagonal)),e}toJSON(){return{origin:{x:this.origin.x,y:this.origin.y,z:this.origin.z},scale:{x:this.scale.x,y:this.scale.y,z:this.scale.z}}}static fromJSON(t,e){return this.fromOriginAndScale(Q.fromJSON(t.origin),Q.fromJSON(t.scale),e)}}class Ro{get x(){return this._x}set x(t){e(ho.isQuantized(t)),this._x=t}get y(){return this._y}set y(t){e(ho.isQuantized(t)),this._y=t}get z(){return this._z}set z(t){e(ho.isQuantized(t)),this._z=t}constructor(){this._x=0,this._y=0,this._z=0}init(t,e){this.x=ho.quantize(t.x,e.origin.x,e.scale.x),this.y=ho.quantize(t.y,e.origin.y,e.scale.y),this.z=ho.quantize(t.z,e.origin.z,e.scale.z)}static create(t,e){const i=new Ro;return i.init(t,e),i}copyFrom(t){this.x=t.x,this.y=t.y,this.z=t.z}clone(t){const e=void 0!==t?t:new Ro;return e.copyFrom(this),e}setFromScalars(t,e,i){this.x=t,this.y=e,this.z=i}static fromScalars(t,e,i,s){const n=void 0===s?new Ro:s;return n.setFromScalars(t,e,i),n}unquantize(t,e){const i=void 0!==e?e:new Q;return i.x=ho.unquantize(this.x,t.origin.x,t.scale.x),i.y=ho.unquantize(this.y,t.origin.y,t.scale.y),i.z=ho.unquantize(this.z,t.origin.z,t.scale.z),i}equals(t){return this.x===t.x&&this.y===t.y&&this.z===t.z}compare(t){let e=this.x-t.x;return 0===e&&(e=this.y-t.y,0===e&&(e=this.z-t.z)),e}}!function(t){const e=new Ro;function i(t,e,i){const s=3*e,n=t[s+0],r=t[s+1],o=t[s+2];if(void 0===n||void 0===r||void 0===o)throw new Error("Index out of range");return(i=i??new Ro).setFromScalars(n,r,o),i}t.getQPoint=i,t.unquantizePoint=function(t,s,n){return i(t.points,s,e).unquantize(t.params,n)}}(uo||(uo={})),Symbol.iterator,function(t){t[t.None=0]="None",t[t.ContainsCurves=1]="ContainsCurves",t[t.Incomplete=4]="Incomplete",t[t.DisallowMagnification=8]="DisallowMagnification",t[t.MultiModelFeatureTable=16]="MultiModelFeatureTable"}(fo||(fo={})),function(t){t[t.Major=32]="Major",t[t.Minor=0]="Minor",t[t.Combined=2097152]="Combined"}(go||(go={}));class zo extends To{get versionMajor(){return this.version>>>16}get versionMinor(){return(65535&this.version)>>>0}get isValid(){return no.IModel===this.format}get isReadableVersion(){return this.versionMajor<=go.Major}constructor(t){super(t),this.headerLength=t.readUint32(),this.flags=t.readUint32(),this.contentRange=new ut,ko(t,this.contentRange.low),ko(t,this.contentRange.high),this.tolerance=t.readFloat64(),this.numElementsIncluded=t.readUint32(),this.numElementsExcluded=t.readUint32(),this.tileLength=t.readUint32(),this.emptySubRanges=this.versionMajor>=2?t.readUint32():0;const i=this.headerLength-t.curPos;e(i>=0),t.advance(i),t.isPastTheEnd&&this.invalidate()}}class Do{static readFrom(t){const e=t.readUint32(),i=t.readUint32(),s=t.readUint32();return t.isPastTheEnd?void 0:new Do(e,i,s)}constructor(t,e,i){this.length=t,this.numSubCategories=e,this.count=i}}Do.sizeInBytes=12,function(t){t[t.Normal=0]="Normal",t[t.Edge=1]="Edge",t[t.Outline=2]="Outline"}(po||(po={}));class Yo{constructor(t,e){this.texture=t,this.params=e}computeUVParams(t,e){return this.params.computeUVParams(t,e)}}!function(t){let e;!function(t){t[t.None=-1]="None",t[t.Parametric=0]="Parametric",t[t.ElevationDrape=1]="ElevationDrape",t[t.Planar=2]="Planar",t[t.DirectionalDrape=3]="DirectionalDrape",t[t.Cubic=4]="Cubic",t[t.Spherical=5]="Spherical",t[t.Cylindrical=6]="Cylindrical",t[t.Solid=7]="Solid",t[t.FrontProject=8]="FrontProject"}(e=t.Mode||(t.Mode={}));class i{constructor(t=1,e=0,i=0,s=0,n=1,r=0){const o=new Q(i,r,0),a=xt.createRowValues(t,e,0,s,n,0,0,0,1);this.transform=pt.createRefs(o,a)}}i.identity=new i,t.Trans2x3=i,t.Params=class{constructor(t){this.textureMatrix=t?.textureMat2x3??i.identity,this.weight=t?.textureWeight??1,this.mode=t?.mapMode??e.Parametric,this.worldMapping=t?.worldMapping??!1,this.useConstantLod=t?.useConstantLod??!1,this.constantLodParams={repetitions:t?.constantLodProps?.repetitions??1,offset:t?.constantLodProps?.offset??{x:0,y:0},minDistClamp:t?.constantLodProps?.minDistClamp??1,maxDistClamp:t?.constantLodProps?.maxDistClamp??4294967296}}computeUVParams(e,i){switch(this.mode){default:case t.Mode.Parametric:return this.computeParametricUVParams(e,this.textureMatrix.transform,!this.worldMapping);case t.Mode.Planar:{const t=e.normalIndex;if(!t)return;return this.worldMapping&&(void 0===e.normalIndex||t[0]===t[1]&&t[0]===t[2])?this.computePlanarUVParams(e,this.textureMatrix.transform):this.computeParametricUVParams(e,this.textureMatrix.transform,!this.worldMapping)}case t.Mode.ElevationDrape:return this.computeElevationDrapeUVParams(e,this.textureMatrix.transform,i)}}computeParametricUVParams(t,e,i){const s=[];for(let n=0;n<t.numEdgesThisFacet;n++){let r=H.create();!i&&t.tryGetDistanceParameter(n,r)||t.tryGetNormalizedParameter(n,r)||(r=t.getParam(n)),s.push(e.multiplyPoint2d(r))}return s}computePlanarUVParams(t,e){const i=[],s=t.point;let n;if(n=void 0===t.normal?s.getPoint3dAtUncheckedPointIndex(0).crossProductToPoints(s.getPoint3dAtUncheckedPointIndex(1),s.getPoint3dAtUncheckedPointIndex(2)):t.normal.getVector3dAtCheckedVectorIndex(0),!n.normalize(n))return;n.scale(-1,n);const r=$.create(n.y,-n.x,0),o=r.magnitude();r.normalize(r),o<.001&&(n.set(0,0,-1),r.set(1,0,0));const a=r.crossProduct(n).normalize();if(!a)return;const c=t.numEdgesThisFacet;for(let t=0;t<c;t++){const n=$.createFrom(s.getPoint3dAtUncheckedPointIndex(t));i.push(H.create(n.dotProduct(r),n.dotProduct(a))),e.multiplyPoint2d(i[t],i[t])}return i}computeElevationDrapeUVParams(t,e,i){const s=[],n=t.numEdgesThisFacet;for(let r=0;r<n;r++){const n=t.point.getPoint3dAtUncheckedPointIndex(r);void 0!==i&&i.multiplyPoint3d(n,n),s.push(H.createFrom(n)),e.multiplyPoint2d(s[r],s[r])}return s}}}(Yo||(Yo={})),Object.freeze(Yo.Trans2x3.identity),(Co=mo||(mo={}))[Co.Solid=0]="Solid",Co[Co.Code0=0]="Code0",Co[Co.Code1=2155905152]="Code1",Co[Co.Code2=4177066232]="Code2",Co[Co.Code3=4292935648]="Code3",Co[Co.Code4=4262526480]="Code4",Co[Co.Code5=3772834016]="Code5",Co[Co.Code6=4169726088]="Code6",Co[Co.Code7=4279828248]="Code7",Co[Co.HiddenLine=3435973836]="HiddenLine",Co[Co.Invisible=1]="Invisible",Co[Co.Invalid=-1]="Invalid",function(t){t[t.None=0]="None",t[t.ByView=1]="ByView",t[t.Always=2]="Always",t[t.Behind=4]="Behind",t[t.Blanking=6]="Blanking",t[t.Background=8]="Background"}(xo||(xo={})),function(t){t[t.Rgba=0]="Rgba",t[t.Rgb=2]="Rgb",t[t.Alpha=5]="Alpha"}(yo||(yo={}));class No{get numBytesPerPixel(){return No.getNumBytesPerPixel(this.format)}static getNumBytesPerPixel(t){switch(t){case yo.Alpha:return 1;case yo.Rgb:return 3;default:return 4}}get height(){return No.computeHeight(this.data,this.format,this.width)}static create(t,e,i){if(!this.isValidData(t,e,i))throw new Error("The number of bytes supplied for ImageBuffer do not match its width and format.");return new No(t,e,i)}static isValidData(t,e,i){const s=this.computeHeight(t,e,i);return i>0&&s>0&&Math.floor(i)===i&&Math.floor(s)===s}static computeHeight(t,e,i){return t.length/(i*this.getNumBytesPerPixel(e))}constructor(t,e,i){this.data=t,this.format=e,this.width=i}}!function(t){t[t.Jpeg=0]="Jpeg",t[t.Png=2]="Png",t[t.Svg=3]="Svg"}(_o||(_o={})),function(t){t[t.Smooth=0]="Smooth",t[t.Stepped=1]="Stepped",t[t.SteppedWithDelimiter=2]="SteppedWithDelimiter",t[t.IsoLines=3]="IsoLines"}(vo||(vo={})),function(t){t[t.BlueRed=0]="BlueRed",t[t.RedBlue=1]="RedBlue",t[t.Monochrome=2]="Monochrome",t[t.Topographic=3]="Topographic",t[t.SeaMountain=4]="SeaMountain",t[t.Custom=5]="Custom"}(Po||(Po={}));class Oo{static get margin(){return.001}static get contentRange(){return 1-2*Oo.margin}static get contentMax(){return 1-Oo.margin}equals(t){if(this.mode!==t.mode)return!1;if(this.stepCount!==t.stepCount)return!1;if(!this.marginColor.equals(t.marginColor))return!1;if(this.colorScheme!==t.colorScheme)return!1;if(this.customKeys.length!==t.customKeys.length)return!1;if(this.colorMix!==t.colorMix)return!1;for(let e=0;e<this.customKeys.length;e++)if(!Ao.keyColorEquals(this.customKeys[e],t.customKeys[e]))return!1;return!0}static compare(t,e){let s=0;if(0!==(s=i(t.mode,e.mode)))return s;if(0!==(s=i(t.stepCount,e.stepCount)))return s;if(0!==(s=i(t.marginColor.tbgr,e.marginColor.tbgr)))return s;if(0!==(s=i(t.colorScheme,e.colorScheme)))return s;if(0!==(s=i(t.colorMix,e.colorMix)))return s;if(0!==(s=i(t.customKeys.length,e.customKeys.length)))return s;for(let n=0;n<t.customKeys.length;n++)if(0!==(s=i(t.customKeys[n].color.tbgr,e.customKeys[n].color.tbgr)))return s;return s}constructor(t){if(this.customKeys=[],void 0===t)this.mode=vo.Smooth,this.stepCount=10,this.marginColor=Sr.fromJSON(),this.colorScheme=Po.BlueRed,this.colorMix=0;else{if(this.mode=void 0!==t.mode&&null!==t.mode?t.mode:vo.Smooth,(this.mode<vo.Smooth||this.mode>vo.IsoLines)&&(this.mode=vo.Smooth),this.stepCount="number"==typeof t.stepCount?t.stepCount:10,this.stepCount<2&&(this.stepCount=2),this.marginColor=Sr.fromJSON(t.marginColor),this.colorScheme=void 0!==t.colorScheme&&null!==t.colorScheme?t.colorScheme:Po.BlueRed,(this.colorScheme<Po.BlueRed||this.colorScheme>Po.Custom)&&(this.colorScheme=Po.BlueRed),void 0!==t.customKeys&&null!==t.customKeys&&t.customKeys.forEach((t=>this.customKeys.push(new Ao.KeyColor(t)))),this.colorScheme===Po.Custom&&this.customKeys.length<2){this.customKeys=[];for(const t of Oo._defaultCustomKeys)this.customKeys.push(new Ao.KeyColor({value:t[0],color:Sr.computeTbgrFromComponents(t[1],t[3],t[2])}))}this.colorMix=t.colorMix??0}}static fromJSON(t){return t?new Oo(t):this.defaults}toJSON(){const t={};vo.Smooth!==this.mode&&(t.mode=this.mode),10!==this.stepCount&&(t.stepCount=this.stepCount);const e=this.marginColor.toJSON();return 0!==e&&(t.marginColor=e),Po.BlueRed!==this.colorScheme&&(t.colorScheme=this.colorScheme),0!==this.colorMix&&(t.colorMix=this.colorMix),this.customKeys.length>0&&(t.customKeys=this.customKeys.map((t=>({value:t.value,color:t.color.toJSON()})))),t}clone(t){if(void 0===t)return Oo.fromJSON(this.toJSON());const e={mode:void 0!==t.mode?t.mode:this.mode,stepCount:void 0!==t.stepCount?t.stepCount:this.stepCount,marginColor:void 0!==t.marginColor?t.marginColor:this.marginColor.tbgr,colorScheme:void 0!==t.colorScheme?t.colorScheme:this.colorScheme,customKeys:void 0!==t.customKeys?t.customKeys:this.customKeys.map((t=>({value:t.value,color:t.color.tbgr}))),colorMix:void 0!==t.colorMix?t.colorMix:this.colorMix};return Oo.fromJSON(e)}}Oo.defaults=new Oo({}),Oo._defaultCustomKeys=[[0,255,255,255],[1,0,0,0]],function(t){t[t.Height=0]="Height",t[t.InverseDistanceWeightedSensors=1]="InverseDistanceWeightedSensors",t[t.Slope=2]="Slope",t[t.HillShade=3]="HillShade"}(Io||(Io={})),function(t){let i,s;!function(t){t[t.None=0]="None",t[t.Invert=1]="Invert",t[t.Outline=2]="Outline"}(i=t.Flags||(t.Flags={})),function(t){t[t.None=0]="None",t[t.Linear=1]="Linear",t[t.Curved=2]="Curved",t[t.Cylindrical=3]="Cylindrical",t[t.Spherical=4]="Spherical",t[t.Hemispherical=5]="Hemispherical",t[t.Thematic=6]="Thematic"}(s=t.Mode||(t.Mode={}));class n{constructor(t){this.value=t.value,this.color=Sr.fromJSON(t.color)}}t.KeyColor=n,t.keyColorEquals=function(t,e){return t.value===e.value&&t.color.equals(e.color)};class r{constructor(){this.mode=s.None,this.flags=i.None,this.shift=0,this.keys=[]}static fromJSON(t){const e=new r;return t?(e.mode=t.mode,e.flags=void 0===t.flags?i.None:t.flags,e.angle=t.angle?W.fromJSON(t.angle):void 0,e.tint=t.tint,e.shift=t.shift?t.shift:0,t.keys.forEach((t=>e.keys.push(new n(t)))),e.thematicSettings=void 0===t.thematicSettings?void 0:Oo.fromJSON(t.thematicSettings),e):e}static createThematic(i){const o=new r;if(o.mode=s.Thematic,o.thematicSettings=i,i.colorScheme<Po.Custom)for(const e of t.Symb._fixedSchemeKeys[i.colorScheme])o.keys.push(new n({value:e[0],color:Sr.computeTbgrFromComponents(e[1],e[3],e[2])}));else if(e(i.customKeys.length>1,"Custom thematic mode requires at least two keys to be defined"),i.customKeys.length>1)i.customKeys.forEach((t=>o.keys.push(t)));else for(const e of t.Symb._fixedCustomKeys)o.keys.push(new n({value:e[0],color:Sr.from(e[1],e[3],e[2]).toJSON()}));return o}toJSON(){return{...this,thematicSettings:this.thematicSettings?.toJSON(),keys:this.keys.map((t=>({value:t.value,color:t.color.toJSON()})))}}clone(){return r.fromJSON(this.toJSON())}equals(t){return 0===r.compareSymb(this,t)}static compareSymb(t,e){if(t===e)return 0;if(t.mode!==e.mode)return t.mode-e.mode;if(t.flags!==e.flags)return void 0===t.flags?-1:void 0===e.flags?1:t.flags-e.flags;if(t.tint!==e.tint)return void 0===t.tint?-1:void 0===e.tint?1:t.tint-e.tint;if(t.shift!==e.shift)return void 0===t.shift?-1:void 0===e.shift?1:t.shift-e.shift;if(void 0===t.angle!=(void 0===e.angle))return void 0===t.angle?-1:1;if(t.angle&&!t.angle.isAlmostEqualNoPeriodShift(e.angle))return t.angle.radians-e.angle.radians;if(t.keys.length!==e.keys.length)return t.keys.length-e.keys.length;for(let i=0;i<t.keys.length;i++){if(t.keys[i].value!==e.keys[i].value)return t.keys[i].value-e.keys[i].value;if(!t.keys[i].color.equals(e.keys[i].color))return t.keys[i].color.tbgr-e.keys[i].color.tbgr}if(t.thematicSettings!==e.thematicSettings){if(void 0===t.thematicSettings)return-1;if(void 0===e.thematicSettings)return 1;{const i=Oo.compare(t.thematicSettings,e.thematicSettings);if(0!==i)return i}}return 0}compare(e){return t.Symb.compareSymb(this,e)}roundToByte(t){return 255&Math.min(t+.5,255)}mapColor(t){t<0?t=0:t>1&&(t=1),0!=(this.flags&i.Invert)&&(t=1-t);let e,s,n,r=0;if(this.keys.length<=2)s=1-t,n=t;else{for(;r<this.keys.length-2&&t>this.keys[r+1].value;)r++;e=this.keys[r+1].value-this.keys[r].value,n=e<1e-4?0:(t-this.keys[r].value)/e,s=1-n}const o=this.keys[r].color,a=this.keys[r+1].color,c=o.colors,h=a.colors,l=s*c.r+n*h.r,d=s*c.g+n*h.g,u=s*c.b+n*h.b,f=s*c.t+n*h.t;return Sr.from(this.roundToByte(l),this.roundToByte(d),this.roundToByte(u),this.roundToByte(f))}get hasTranslucency(){for(const t of this.keys)if(!t.color.isOpaque)return!0;return!1}get isOutlined(){return 0!=(this.flags&i.Outline)}getThematicImageForRenderer(t){e(s.Thematic===this.mode,"getThematicImageForRenderer only is used for thematic display.");let i=this.thematicSettings;void 0===i&&(i=Oo.defaults);const n=Math.min(i.stepCount,t),r=vo.Smooth===i.mode?t:n,o=new Uint8Array(1*r*4);let a=o.length-1;function c(t){o[a--]=t.getAlpha(),o[a--]=t.colors.b,o[a--]=t.colors.g,o[a--]=t.colors.r}switch(i.mode){case vo.Smooth:for(let t=0;t<r;t++){const e=1-t/r;c(this.mapColor(e))}break;case vo.SteppedWithDelimiter:case vo.IsoLines:case vo.Stepped:e(i.stepCount>1,"Step count must be at least two to generate renderer gradient for thematic display");for(let t=0;t<r;t++){const e=1-t/(r-1);c(this.mapColor(e))}}e(-1===a);const h=No.create(o,yo.Rgba,1);return e(void 0!==h),h}getImage(t,e){return this.mode===s.Thematic&&(t=1),this.produceImage({width:t,height:e,includeThematicMargin:!0})}produceImage(t){const{width:i,height:n,includeThematicMargin:r}={...t},o=void 0===this.angle?0:this.angle.radians,a=Math.cos(o),c=Math.sin(o),h=new Uint8Array(i*n*4);let l=h.length-1;const d=Math.min(1,Math.abs(this.shift));switch(this.mode){case s.Linear:case s.Cylindrical:{const t=.5-.25*d*a,e=.5-.25*d*c;let r,o,u=r=0;for(let i=0;i<2;i++)for(let s=0;s<2;s++)o=(s-t)*a+(i-e)*c,o<u&&(u=o),o>r&&(r=o);for(let d=0;d<n;d++){const f=d/n-e;for(let e=0;e<i;e++){let n;o=(e/i-t)*a+f*c,n=this.mode===s.Linear?o>0?.5+.5*o/r:.5-.5*o/u:o>0?Math.sin(Math.PI/2*(1-o/r)):Math.sin(Math.PI/2*(1-o/u));const d=this.mapColor(n);h[l--]=d.getAlpha(),h[l--]=d.colors.b,h[l--]=d.colors.g,h[l--]=d.colors.r}}break}case s.Curved:{const t=.5+.5*c-.25*d*a,e=.5-.5*a-.25*d*c;for(let s=0;s<n;s++){const r=s/n-e;for(let e=0;e<i;e++){const s=e/i-t,n=.8*(s*a+r*c),o=r*a-s*c,d=Math.sin(Math.PI/2*(1-Math.sqrt(n*n+o*o))),u=this.mapColor(d);h[l--]=u.getAlpha(),h[l--]=u.colors.b,h[l--]=u.colors.g,h[l--]=u.colors.r}}break}case s.Spherical:{const t=.5+.125*Math.sin(2*o),e=.5*d*(a+c)*t,s=.5*d*(c-a)*t;for(let r=0;r<n;r++){const o=s+r/n-.5;for(let s=0;s<i;s++){const n=e+s/i-.5,r=Math.sin(Math.PI/2*(1-Math.sqrt(n*n+o*o)/t)),a=this.mapColor(r);h[l--]=a.getAlpha(),h[l--]=a.colors.b,h[l--]=a.colors.g,h[l--]=a.colors.r}}break}case s.Hemispherical:{const t=.5+.5*c-.5*d*a,e=.5-.5*a-.5*d*c;for(let s=0;s<n;s++){const r=s/n-e;for(let e=0;e<i;e++){const s=e/i-t,n=Math.sin(Math.PI/2*(1-Math.sqrt(s*s+r*r))),o=this.mapColor(n);h[l--]=o.getAlpha(),h[l--]=o.colors.b,h[l--]=o.colors.g,h[l--]=o.colors.r}}break}case s.Thematic:{const t=this.thematicSettings??Oo.defaults;for(let e=0;e<n;e++){let s,o=1-e/n;if(r&&(o<Oo.margin||o>Oo.contentMax))s=t.marginColor;else switch(o=(o-Oo.margin)/Oo.contentRange,t.mode){case vo.SteppedWithDelimiter:case vo.IsoLines:case vo.Stepped:if(t.stepCount>1){const e=Math.floor(o*t.stepCount-1e-5)/(t.stepCount-1);s=this.mapColor(e)}break;case vo.Smooth:s=this.mapColor(o)}for(let t=0;t<i;t++)h[l--]=s.getAlpha(),h[l--]=s.colors.b,h[l--]=s.colors.g,h[l--]=s.colors.r}}}e(-1===l);const u=No.create(h,yo.Rgba,i);return e(void 0!==u),u}}r._fixedSchemeKeys=[[[0,0,255,0],[.25,0,255,255],[.5,0,0,255],[.75,255,0,255],[1,255,0,0]],[[0,255,0,0],[.25,255,0,255],[.5,0,0,255],[.75,0,255,255],[1,0,255,0]],[[0,0,0,0],[1,255,255,255]],[[0,152,148,188],[.5,204,160,204],[1,152,72,128]],[[0,0,255,0],[.2,72,96,160],[.4,152,96,160],[.6,128,32,104],[.7,148,180,128],[1,240,240,240]]],r._fixedCustomKeys=[[0,255,0,0],[1,0,255,0]],t.Symb=r}(Ao||(Ao={})),function(t){t[t.Mesh=0]="Mesh",t[t.Polyline=1]="Polyline",t[t.Point=2]="Point"}(So||(So={})),function(t){t[t.Unlit=0]="Unlit",t[t.Lit=1]="Lit",t[t.Textured=2]="Textured",t[t.TexturedLit=3]="TexturedLit",t[t.VolumeClassifier=4]="VolumeClassifier"}(wo||(wo={}));class Bo{constructor(t,i,s,n=0,r=mo.Solid,o=xo.None,a,c,h=!1,l){this.type=Bo.Type.Mesh,this.type=t,this.material=a,this.gradient=c,this.lineColor=Bo.adjustTransparency(i),this.fillColor=Bo.adjustTransparency(s),this.width=n,this.linePixels=r,this.fillFlags=o,this.ignoreLighting=h,this._textureMapping=l,e(void 0===a||void 0===l)}static createForType(t,e,i,s=!1){const n=Bo.adjustTransparency(e.lineColor);switch(t){case Bo.Type.Mesh:{let r;if(void 0!==e.gradient&&void 0!==i){const t=i(e.gradient);void 0!==t&&(r=new Yo(t,new Yo.Params))}return new Bo(t,n,Bo.adjustTransparency(e.fillColor),e.rasterWidth,e.linePixels,e.fillFlags,e.material,e.gradient,s,r)}case Bo.Type.Linear:return new Bo(t,n,n,e.rasterWidth,e.linePixels);default:return new Bo(t,n,n,0,mo.Solid,xo.Always,void 0,void 0,!0)}}static createForMesh(t,e,i){return Bo.createForType(Bo.Type.Mesh,t,i,e)}static createForLinear(t){return Bo.createForType(Bo.Type.Linear,t)}static createForText(t){return Bo.createForType(Bo.Type.Text,t)}get regionEdgeType(){return this.hasBlankingFill?Bo.RegionEdgeType.None:void 0!==this.gradient&&void 0!==this.gradient.flags?0!=(this.gradient.flags&Ao.Flags.Outline)||xo.None===(this.fillFlags&xo.Always)?Bo.RegionEdgeType.Outline:Bo.RegionEdgeType.None:this.fillColor.equals(this.lineColor)?Bo.RegionEdgeType.Default:Bo.RegionEdgeType.Outline}get wantRegionOutline(){return Bo.RegionEdgeType.Outline===this.regionEdgeType}get hasBlankingFill(){return xo.Blanking===(this.fillFlags&xo.Blanking)}get hasFillTransparency(){return 255!==this.fillColor.getAlpha()}get hasLineTransparency(){return 255!==this.lineColor.getAlpha()}get textureMapping(){return void 0!==this.material?this.material.textureMapping:this._textureMapping}get isTextured(){return void 0!==this.textureMapping}equals(t,e=Bo.ComparePurpose.Strict){return Bo.ComparePurpose.Merge===e?0===this.compareForMerge(t):t===this||this.type===t.type&&this.ignoreLighting===t.ignoreLighting&&this.width===t.width&&this.linePixels===t.linePixels&&this.fillFlags===t.fillFlags&&this.wantRegionOutline===t.wantRegionOutline&&this.material===t.material&&this.textureMapping===t.textureMapping&&!!this.fillColor.equals(t.fillColor)&&!!this.lineColor.equals(t.lineColor)}compareForMerge(t){if(t===this)return 0;let e=i(this.type,t.type);return 0===e&&(e=s(this.ignoreLighting,t.ignoreLighting),0===e&&(e=i(this.width,t.width),0===e&&(e=i(this.linePixels,t.linePixels),0===e&&(e=i(this.fillFlags,t.fillFlags),0===e&&(e=s(this.wantRegionOutline,t.wantRegionOutline),0===e&&(e=s(this.hasFillTransparency,t.hasFillTransparency),0===e&&(e=s(this.hasLineTransparency,t.hasLineTransparency),0===e&&(e=function(t,e){return r(((t,e)=>t===e?0:o(t.key,e.key)),t,e)}(this.material,t.material),0===e&&void 0===this.material&&this.isTextured&&(this.textureMapping,t.textureMapping,e=0))))))))),e}static adjustTransparency(t){return t.colors.t<Bo.minTransparency?t.withTransparency(0):t}}Bo.minTransparency=15,function(t){let e,i,s;!function(t){t[t.Mesh=0]="Mesh",t[t.Linear=1]="Linear",t[t.Text=2]="Text"}(e=t.Type||(t.Type={})),function(t){t[t.None=0]="None",t[t.Default=1]="Default",t[t.Outline=2]="Outline"}(i=t.RegionEdgeType||(t.RegionEdgeType={})),function(t){t[t.Merge=0]="Merge",t[t.Strict=1]="Strict"}(s=t.ComparePurpose||(t.ComparePurpose={}))}(Bo||(Bo={}));const Vo=new Uint16Array(1);function Lo(t){return Uo(.5+255*(.5*function(t,e,i){return t<-1?-1:t>1?1:t}(t)+.5))}function Uo(t){return Vo[0]=t,Vo[0]}function Zo(t){return t<0?-1:1}class qo{constructor(t){this.value=Uo(t)}static encode(t){return this.encodeXYZ(t.x,t.y,t.z)}static encodeXYZ(t,e,i){const s=Math.abs(t)+Math.abs(e)+Math.abs(i);let n=t/s,r=e/s;if(i<0){const t=n,e=r;n=(1-Math.abs(e))*Zo(t),r=(1-Math.abs(t))*Zo(e)}return Lo(r)<<8|Lo(n)}static fromVector(t){return new qo(this.encode(t))}decode(){return qo.decodeValue(this.value)}static decodeValue(t,e){let i=255&t,s=t>>8;i=i/255*2-1,s=s/255*2-1;const n=1-(Math.abs(i)+Math.abs(s));let r;if(void 0===e?r=new $(i,s,n):(r=e,r.x=i,r.y=s,r.z=n),r.z<0){const t=r.x,e=r.y;r.x=(1-Math.abs(e))*Zo(t),r.y=(1-Math.abs(t))*Zo(e)}return r.normalizeInPlace(),r}}function Wo(t,i,s,n){const r=t*i+s;if(r<n)return{width:r,height:1};let o=Math.ceil(Math.sqrt(r));const a=o%i;0!==a&&(o+=i-a);let c=Math.ceil(r/o);return o*c<r&&++c,e(c<=n),e(o<=n),e(o*c>=r),e(Math.floor(c)===c),e(Math.floor(o)===o),e(0==o%i),{width:o,height:c}}class Go{constructor(t){this.name=t.name,this.inputs=t.inputs,this.indices=t.indices}toJSON(){return{name:this.name,inputs:this.inputs,indices:this.indices}}}class Ho extends Go{constructor(t){super(t),this.qOrigin=Float32Array.from(t.qOrigin),this.qScale=Float32Array.from(t.qScale)}toJSON(){return{...super.toJSON(),qOrigin:Array.from(this.qOrigin),qScale:Array.from(this.qScale)}}}class Jo extends Go{constructor(t){super(t),this.qOrigin=t.qOrigin[0],this.qScale=t.qScale[0]}toJSON(){return{...super.toJSON(),qOrigin:[this.qOrigin],qScale:[this.qScale]}}}class Ko{constructor(t,e,i,s){this.data=t.data,this.width=t.width,this.height=t.height,this.numVertices=t.count,this.numBytesPerVertex=t.numBytesPerVertex,this.displacements=e,this.normals=i,this.params=s}static fromJSON(t){let e,i,s;if(void 0!==t.displacements&&0<t.displacements.length){e=[];for(const i of t.displacements)e.push(new Ho(i))}if(void 0!==t.normals&&0<t.normals.length){i=[];for(const e of t.normals)i.push(new Go(e))}if(void 0!==t.params&&0<t.params.length){s=[];for(const e of t.params)s.push(new Jo(e))}return void 0!==e||void 0!==i||void 0!==s?new Ko(t,e,i,s):void 0}toJSON(){return{data:this.data,width:this.width,height:this.height,count:this.numVertices,numBytesPerVertex:this.numBytesPerVertex,displacements:this.displacements?.map((t=>t.toJSON())),normals:this.normals?.map((t=>t.toJSON())),params:this.params?.map((t=>t.toJSON()))}}static fromChannels(t,e,i){return Qo.buildAuxChannelTable(t,e,i)}}function jo(t){return 0!==t&&(t=1/t),t}class Qo{constructor(t,e){this._props=t,this._numBytesPerVertex=e,this._view=new DataView(t.data.buffer)}static buildAuxChannelTable(t,i,s){const n=t.reduce(((t,e)=>t+$o(e)),0);if(!n)return;const r=Math.floor((n+3)/4),o=4*r-n;let a;e(0===o||2===o),a=0!==o?Wo(Math.floor((i+1)/2),n/2,0,s):Wo(i,r,0,s);const c={data:new Uint8Array(a.width*a.height*4),width:a.width,height:a.height,count:i,numBytesPerVertex:n};return new Qo(c,n).build(t),Ko.fromJSON(c)}build(t){let e=0;for(const i of t)T.Normal===i.dataType?this.addNormals(i,e):T.Vector===i.dataType?this.addDisplacements(i,e):this.addParams(i,e),e+=$o(i)}addNormals(t,e){const i=[],s=[],n=new $;for(let r=0;r<t.data.length;r++){let o=e+2*r;s.push(o/2);const a=t.data[r];i.push(a.input);for(let t=0;t<a.values.length;t+=3){n.x=a.values[t],n.y=a.values[t+1],n.z=a.values[t+2],n.normalizeInPlace();const e=qo.encode(n);this._view.setUint16(o,e,!0),o+=this._numBytesPerVertex}}(this._props.normals??(this._props.normals=[])).push({name:t.name??"",inputs:i,indices:s})}addParams(t,e){const i=[],s=[],n=ft.createNull();for(const e of t.data)i.push(e.input),n.extendArray(e.values);const r=ho.computeScale(n.high-n.low);for(let i=0;i<t.data.length;i++){let o=e+2*i;s.push(o/2);for(const e of t.data[i].values){const t=ho.quantize(e,n.low,r);this._view.setUint16(o,t,!0),o+=this._numBytesPerVertex}}(this._props.params??(this._props.params=[])).push({inputs:i,indices:s,name:t.name??"",qOrigin:[n.low],qScale:[jo(r)]})}addDisplacements(t,e){const i=[],s=[],n=new Q,r=ut.createNull();for(const e of t.data){i.push(e.input);for(let t=0;t<e.values.length;t+=3)n.set(e.values[t],e.values[t+1],e.values[t+2]),r.extend(n)}const o=Xo.fromRange(r),a=new Ro;for(let i=0;i<t.data.length;i++){let r=e+6*i;s.push(r/2);const c=t.data[i];for(let t=0;t<c.values.length;t+=3)n.set(c.values[t],c.values[t+1],c.values[t+2]),a.init(n,o),this._view.setUint16(r+0,a.x,!0),this._view.setUint16(r+2,a.y,!0),this._view.setUint16(r+4,a.z,!0),r+=this._numBytesPerVertex}(this._props.displacements??(this._props.displacements=[])).push({inputs:i,indices:s,name:t.name??"",qOrigin:o.origin.toArray(),qScale:o.scale.toArray().map((t=>jo(t)))})}}function $o(t){const e=t.data.length;switch(t.dataType){case T.Vector:return 6*e;case T.Normal:case T.Distance:case T.Scalar:return 2*e}}class ta{constructor(t,e){this._constructor=t,this._data=new t(e?.initialCapacity??0),this.growthFactor=Math.max(1,e?.growthFactor??1.5),this._length=0}get length(){return this._length}get capacity(){return this._data.length}at(t){t<0&&(t=this.length-t);const i=this._data[t];return e(void 0!==i,"index out of bounds"),i}ensureCapacity(t){if(this.capacity>=t)return this.capacity;e(this.growthFactor>=1),t=Math.ceil(t*this.growthFactor);const i=this._data;return this._data=new this._constructor(t),this._data.set(i,0),e(this.capacity===t),this.capacity}push(t){this.ensureCapacity(this.length+1),this._data[this.length]=t,++this._length}append(t){const e=this.length+t.length;this.ensureCapacity(e),this._data.set(t,this.length),this._length=e}toTypedArray(t=!1){if(t)return this._data;const i=this._data.subarray(0,this.length);return e(i instanceof this._constructor),e(i.buffer===this._data.buffer),i}}class ea extends ta{constructor(t){super(Uint8Array,t)}}class ia extends ta{constructor(t){super(Uint32Array,t)}toUint8Array(t=!1){return t?new Uint8Array(this._data.buffer):new Uint8Array(this._data.buffer,0,4*this.length)}}function sa(t,e,i){let s=Math.ceil(1.5*t+2.5*e);const n=6*t;let r=0,o=s,a=1;if(s>=i){o=Math.ceil(Math.sqrt(s));const i=o%15;0!==i&&(o+=15-i),e>0&&t>0&&(r=(60-n%60)%10,s+=Math.ceil(r/4)),a=Math.ceil(s/o),o*a<s&&a++}return{width:o,height:a,silhouettePadding:r,silhouetteStartByteIndex:n}}class na{constructor(t){this.data=t,e(0==this.data.length%3)}get length(){return this.data.length/3}static fromArray(t){const e=new Uint8Array(3*t.length);for(let i=0;i<t.length;i++)this.encodeIndex(t[i],e,3*i);return new na(e)}static encodeIndex(t,i,s){e(s+2<i.length),i[s+0]=255&t,i[s+1]=(65280&t)>>8,i[s+2]=(16711680&t)>>16}setNthIndex(t,e){na.encodeIndex(e,this.data,3*t)}decodeIndex(t){e(t<this.length);const i=3*t;return this.data[i]|this.data[i+1]<<8|this.data[i+2]<<16}decodeIndices(){const t=[];for(let e=0;e<this.length;e++)t.push(this.decodeIndex(e));return t}[Symbol.iterator](){return function*(t){for(let e=0;e<t.length;e++)yield t.decodeIndex(e)}(this)}}class ra{constructor(t=3){this._index32=new Uint32Array(1),this._index8=new Uint8Array(this._index32.buffer,0,3),this._builder=new ea({initialCapacity:3*t})}get numIndices(){return e(this._builder.length%3==0),this._builder.length/3}push(t){this._index32[0]=t,this._builder.append(this._index8)}toVertexIndices(){return new na(this._builder.toTypedArray())}}class oa{constructor(t){this._source=t,this._builder=new ia({initialCapacity:3*t.numRgbaPerVertex})}get length(){return e(this._builder.length%this.vertexSize==0),this._builder.length/this.vertexSize}get vertexSize(){return this._source.numRgbaPerVertex}push(t){e(t.length===this.vertexSize),this._builder.append(t)}buildVertexTable(t,i,s){const n=this._source;e(void 0!==(i=i??n.uniformColor));const r=i instanceof Uint32Array?i.length:0,o=s instanceof Uint32Array?s.length:0,a=Wo(this.length,this.vertexSize,r+o,t);let c=this._builder.toTypedArray();if(a.width*a.height>c.length){const t=c;c=new Uint32Array(a.width*a.height),c.set(t,0)}let h=this.vertexSize*this.length;return i instanceof Uint32Array&&(c.set(i,h),h+=i.length),s instanceof Uint32Array&&c.set(s,h),{data:new Uint8Array(c.buffer,c.byteOffset,c.byteLength),usesUnquantizedPositions:n.usesUnquantizedPositions,qparams:n.qparams,width:a.width,height:a.height,hasTranslucency:n.hasTranslucency,uniformColor:i instanceof Sr?i:void 0,featureIndexType:n.featureIndexType,uniformFeatureID:n.uniformFeatureID,numVertices:this.length,numRgbaPerVertex:n.numRgbaPerVertex,uvParams:n.uvParams}}}class aa{constructor(t){this._remappedIndices=new Map,this.colors=[],this._32=new Uint32Array(1),this._16=new Uint16Array(this._32.buffer),this._colorTable=t}remap(t,e){const i=e?4:1,s=e?0:1;this._32[0]=t[i];const n=this._16[s];let r=this._remappedIndices.get(n);if(void 0===r){r=this.colors.length,this._remappedIndices.set(n,r);const t=this._colorTable[n];this.colors.push(t)}this._16[s]=r,t[i]=this._32[0]}buildColorTable(){return e(this.colors.length>0),this.colors.length>1?new Uint32Array(this.colors):Sr.fromAbgr(this.colors[0])}}class ca{constructor(t,e){this._remappedIndices=new Map,this.materials=[],this._32=new Uint32Array(1),this._8=new Uint8Array(this._32.buffer),this._atlasTable=t,this._createMaterial=e}remap(t,e){const i=e?3:2;this._32[0]=t[i];const s=this._8[3];let n=this._remappedIndices.get(s);if(void 0===n){n=this.materials.length/4,this._remappedIndices.set(s,n);let t=4*s;this.materials.push(this._atlasTable[t++]),this.materials.push(this._atlasTable[t++]),this.materials.push(this._atlasTable[t++]),this.materials.push(this._atlasTable[t])}this._8[3]=n,t[i]=this._32[0]}unpackFloat(t){this._32[0]=t;const e=this._32[0],i=(e>>>24)/2;let s=Math.floor(i),n=2*(i-s);return n=-(2*n-1),s-=38,n*(16777215&e)/16777216*Math.pow(10,s)}materialFromAtlasEntry(t){const e=0!=(16777216&t[1]),i={alpha:0!=(33554432&t[1])?(t[0]>>>24)/255:void 0,diffuse:{color:e?Sr.fromTbgr(16777215&t[0]):void 0,weight:(t[1]>>>8)/255},specular:{color:Sr.fromTbgr(t[2]),weight:(t[1]>>>16&255)/255,exponent:this.unpackFloat(t[3])}};return void 0===(s=this._createMaterial(i))?void 0:{isAtlas:!1,material:s};var s}buildAtlasTable(){e(this.materials.length>0);const t=new Uint32Array(this.materials);return this.materials.length>4?t:this.materialFromAtlasEntry(t)}}class ha{constructor(t,e){if(this.remappedIndices=new Map,this.indices=new ra,this.vertices=new oa(t),void 0===t.uniformColor&&(this.colors=new aa(new Uint32Array(t.data.buffer,t.data.byteOffset+4*t.numVertices*t.numRgbaPerVertex))),e){const i=4*(t.numVertices*t.numRgbaPerVertex+e.offset);this.atlas=new ca(new Uint32Array(t.data.buffer,t.data.byteOffset+i),e.createMaterial)}this.usesUnquantizedPositions=t.usesUnquantizedPositions}addVertex(t,e){let i=this.remappedIndices.get(t);void 0===i&&(i=this.vertices.length,this.remappedIndices.set(t,i),this.colors?.remap(e,this.usesUnquantizedPositions),this.atlas?.remap(e,this.usesUnquantizedPositions),this.vertices.push(e)),this.indices.push(i)}buildOutput(t){const e=this.atlas?.buildAtlasTable(),i=e instanceof Uint32Array?void 0:e;return{indices:this.indices.toVertexIndices(),vertices:this.vertices.buildVertexTable(t,this.colors?.buildColorTable(),e),material:i}}}class la{constructor(t,e){this._nodes=new Map,this._input=t,this._computeNodeId=e}static split(t,e){const i=new la(t,e);return i.split(),i._nodes}split(){const t={featureIndex:-1,node:void 0},e=this._input.vertices.numRgbaPerVertex,i=new Uint32Array(e),s=new Uint32Array(this._input.vertices.data.buffer,this._input.vertices.data.byteOffset,this._input.vertices.numVertices*e);for(const n of this._input.indices){const r=n*e;for(let t=0;t<i.length;t++)i[t]=s[r+t];const o=16777215&i[2];if(t.featureIndex!==o){t.featureIndex=o;const e=this._computeNodeId(o);let i=this._nodes.get(e);void 0===i&&this._nodes.set(e,i=new ha(this._input.vertices,this._input.atlasInfo)),t.node=i}t.node.addVertex(n,i)}}}function da(t){const e=la.split({indices:t.params.indices,vertices:t.params.vertices,featureTable:t.featureTable},t.computeNodeId),i=new Map;for(const[s,n]of e){const{vertices:e,indices:r}=n.buildOutput(t.maxDimension);i.set(s,{vertices:e,indices:r,weight:t.params.weight})}return i}class ua{constructor(){this.indices=new ra,this.prevIndices=new ra,this.nextIndicesAndParams=new ia}}function fa(t,i,s){for(const[e,n]of s){const s=n.remappedIndices.get(i);if(void 0!==s)return t.index=s,t.node=n,t.id=e,!0}return e(!1),!1}function ga(t,i,s,n){const r=i[t];if(!r)return;const o=new Uint32Array(r.endPointAndQuadIndices.buffer,r.endPointAndQuadIndices.byteOffset,r.endPointAndQuadIndices.length/4);let a;"silhouettes"===t&&(e(void 0!==i.silhouettes),a=new Uint32Array(i.silhouettes.normalPairs.buffer,i.silhouettes.normalPairs.byteOffset,i.silhouettes.normalPairs.length/4));let c=0;const h={};for(const i of r.indices){if(fa(h,i,s)){let i=o[c];const s=(16777215&i)>>>0,r=h.node.remappedIndices.get(s);e(void 0!==r),i=4278190080&i|r;let l=n.get(h.id);l||n.set(h.id,l={}),a?(l.silhouettes||(l.silhouettes={indices:new ra,endPointAndQuadIndices:new ia,normalPairs:new ia}),l.silhouettes.normalPairs.push(a[c])):l.segments||(l.segments={indices:new ra,endPointAndQuadIndices:new ia});const d=l[t];e(void 0!==d),d.indices.push(h.index),d.endPointAndQuadIndices.push(i)}++c}}function pa(t){const i=new Map,s=t.params.surface.material,n=void 0!==s&&s.isAtlas?s.vertexTableOffset:void 0,r=n?{offset:n,createMaterial:t.createMaterial}:void 0,o=la.split({indices:t.params.surface.indices,vertices:t.params.vertices,featureTable:t.featureTable,atlasInfo:r},t.computeNodeId),a=t.params.edges?function(t,i,s){const n=new Map;ga("segments",t,i,n),ga("silhouettes",t,i,n),t.polylines&&function(t,i,s){const n=new Uint32Array(t.nextIndicesAndParams.buffer,t.nextIndicesAndParams.byteOffset,t.nextIndicesAndParams.length/4),r=t.prevIndices[Symbol.iterator]();let o=0;const a={};for(const c of t.indices){if(fa(a,c,i)){const t=r.next().value;e(void 0!==t);const i=a.node.remappedIndices.get(t);e(void 0!==i);let c=n[o];const h=(16777215&c)>>>0,l=a.node.remappedIndices.get(h);e(void 0!==l),c=4278190080&c|l;let d=s.get(a.id);d||s.set(a.id,d={}),d.polylines||(d.polylines=new ua),d.polylines.indices.push(a.index),d.polylines.prevIndices.push(i),d.polylines.nextIndicesAndParams.push(c)}++o}}(t.polylines,i,n),t.indexed&&function(t,i,s){const n=t.edges.data,r=t.edges.numSegments,o=6*r+t.edges.silhouettePadding;function a(t){return[n[t+0]|n[t+1]<<8|n[t+2]<<16,n[t+3]|n[t+4]<<8|n[t+5]<<16]}function c(t){return[n[t+0]|n[t+1]<<8|n[t+2]<<16,n[t+3]|n[t+4]<<8|n[t+5]<<16,n[t+6]|n[t+7]<<8,n[t+8]|n[t+9]<<8]}function h(t,e,i,s,n){t.silhouettes.push(255&e),t.silhouettes.push((65280&e)>>>8),t.silhouettes.push((16711680&e)>>>16),t.silhouettes.push(255&i),t.silhouettes.push((65280&i)>>>8),t.silhouettes.push((16711680&i)>>>16),t.silhouettes.push(255&s),t.silhouettes.push((65280&s)>>>8),t.silhouettes.push(255&n),t.silhouettes.push((65280&n)>>>8)}let l=0;for(const e of t.indices)l=Math.max(e,l);const d={};let u=0,f=0,g=0,p=0;for(let t=0,n=0;t<=l;++t)if(t<r?([u,f]=a(n),n+=6):(n=o+10*(t-r),[u,f,g,p]=c(n)),fa(d,u,i)){let i=s.get(d.id);if(i||s.set(d.id,i={}),i.indexed||(i.indexed={edges:new ea,silhouettes:new ea}),t<r){const t=d.node.remappedIndices.get(u);e(void 0!==t);const s=d.node.remappedIndices.get(f);e(void 0!==s),x=t,y=s,(m=i.indexed).edges.push(255&x),m.edges.push((65280&x)>>>8),m.edges.push((16711680&x)>>>16),m.edges.push(255&y),m.edges.push((65280&y)>>>8),m.edges.push((16711680&y)>>>16)}else{const t=d.node.remappedIndices.get(u);e(void 0!==t);const s=d.node.remappedIndices.get(f);e(void 0!==s),h(i.indexed,t,s,g,p)}}var m,x,y}(t.indexed,i,n);const r=new Map;for(const[e,i]of n){if(!i.segments&&!i.silhouettes&&!i.indexed)continue;let n={},o={};if(i.indexed){const t=i.indexed.edges.length/6,e=i.indexed.silhouettes.length/10,{width:r,height:a,silhouettePadding:c,silhouetteStartByteIndex:h}=sa(t,e,s),l=new Uint8Array(r*a*4);l.set(i.indexed.edges.toTypedArray(),0),e>0&&l.set(i.indexed.silhouettes.toTypedArray(),h+c);const d=t+e;o=new na(new Uint8Array(6*d*3));for(let t=0;t<d;t++)for(let e=0;e<6;e++)o.setNthIndex(6*t+e,t);n={data:l,width:r,height:a,numSegments:t,silhouettePadding:c}}r.set(e,{weight:t.weight,linePixels:t.linePixels,segments:i.segments?{indices:i.segments.indices.toVertexIndices(),endPointAndQuadIndices:i.segments.endPointAndQuadIndices.toUint8Array()}:void 0,silhouettes:i.silhouettes?{indices:i.silhouettes.indices.toVertexIndices(),endPointAndQuadIndices:i.silhouettes.endPointAndQuadIndices.toUint8Array(),normalPairs:i.silhouettes.normalPairs.toUint8Array()}:void 0,polylines:i.polylines?{indices:i.polylines.indices.toVertexIndices(),prevIndices:i.polylines.prevIndices.toVertexIndices(),nextIndicesAndParams:i.polylines.nextIndicesAndParams.toUint8Array()}:void 0,indexed:i.indexed?{indices:o,edges:n}:void 0})}return r}(t.params.edges,o,t.maxDimension):void 0;for(const[e,s]of o){const{vertices:n,indices:r,material:o}=s.buildOutput(t.maxDimension),c={vertices:n,surface:{type:t.params.surface.type,indices:r,fillFlags:t.params.surface.fillFlags,hasBakedLighting:t.params.surface.hasBakedLighting,textureMapping:t.params.surface.textureMapping,material:void 0!==o?o:t.params.surface.material},edges:a?.get(e),isPlanar:t.params.isPlanar,auxChannels:t.params.auxChannels};i.set(e,c)}return i}function ma(t){const i=la.split({indices:t.params.polyline.indices,vertices:t.params.vertices,featureTable:t.featureTable},t.computeNodeId),s=t.params.polyline,n=new Uint32Array(s.nextIndicesAndParams.buffer,s.nextIndicesAndParams.byteOffset,s.nextIndicesAndParams.length/4);let r=0;const o={};for(const t of s.prevIndices){if(fa(o,t,i)){const t=o.node;t.prevIndices?e(void 0!==t.nextIndicesAndParams):(e(void 0===t.nextIndicesAndParams),t.prevIndices=new ra(t.indices.numIndices),t.nextIndicesAndParams=new ia({initialCapacity:t.indices.numIndices})),t.prevIndices.push(o.index);let i=n[r];const s=(16777215&i)>>>0,a=o.node.remappedIndices.get(s);e(void 0!==a),i=4278190080&i|a,t.nextIndicesAndParams.push(i)}++r}const a=new Map;for(const[s,n]of i){e(void 0!==n.prevIndices&&void 0!==n.nextIndicesAndParams);const{vertices:i,indices:r}=n.buildOutput(t.maxDimension),o={...t.params,vertices:i,polyline:{indices:r,prevIndices:n.prevIndices.toVertexIndices(),nextIndicesAndParams:n.nextIndicesAndParams.toUint8Array()}};a.set(s,o)}return a}var xa,ya;function _a(t,e,i){t[e+0]=255&i,t[e+1]=(65280&i)>>>8,t[e+2]=(16711680&i)>>>16}!function(t){t[t.Untransformed=4294967295]="Untransformed"}(xa||(xa={})),function(t){t[t.Hidden=0]="Hidden",t[t.Silhouette=1]="Silhouette",t[t.Visible=2]="Visible"}(ya||(ya={}));class va extends To{get isValid(){return no.Gltf===this.format}constructor(t){super(t),this.scenePosition=0,this.sceneStrLength=0,this.binaryPosition=0,this.gltfLength=t.readUint32(),this.sceneStrLength=t.readUint32();const e=t.readUint32();if(this.version===ao.Version2&&e===ao.Gltf1SceneFormat&&(this.version=ao.Version1),this.version===ao.Version1){const i=e;if(ao.Gltf1SceneFormat!==i)return void this.invalidate();this.scenePosition=t.curPos,this.binaryPosition=t.curPos+this.sceneStrLength}else if(this.version===ao.Version2){const i=e;this.scenePosition=t.curPos,t.curPos=t.curPos+this.sceneStrLength;const s=t.readUint32(),n=t.readUint32();if(co.JSON!==i||co.Binary!==n||0===s)return void this.invalidate();this.binaryPosition=t.curPos}else this.invalidate()}}const Pa=/Node_(.*)/;function Ia(t){const i=t.match(Pa);if(e(!!i&&2===i.length),!i||2!==i.length)return 0;const s=Number.parseInt(i[1],10);return e(!Number.isNaN(s)),Number.isNaN(s)?0:s}class Aa extends Fo{constructor(t){super(t)}dispose(){}get bytesUsed(){return 0}}class Sa extends Aa{constructor(t,e){super(e),this._name=t}toImdl(){return this._name}}class wa extends Aa{constructor(t){super(Fo.Type.Normal),this._gradient=t}toImdl(){return this._gradient}}class Ca extends Mo{toImdl(){return{isAtlas:!1,material:this.key??this.materialParams}}constructor(t,e){super(t),this.materialParams=e??{alpha:t.alpha,diffuse:{color:t.diffuseColor?.toJSON(),weight:t.diffuse},specular:{color:t.specularColor?.toJSON(),weight:t.specular,exponent:t.specularExponent}}}static create(t){const e=new Mo.Params;return e.alpha=t.alpha,t.diffuse&&(void 0!==t.diffuse.weight&&(e.diffuse=t.diffuse?.weight),t.diffuse?.color&&(e.diffuseColor=t.diffuse.color instanceof Sr?t.diffuse.color:wr.fromJSON(t.diffuse.color).toColorDef())),t.specular&&(void 0!==t.specular.weight&&(e.specular=t.specular.weight),void 0!==t.specular.exponent&&(e.specularExponent=t.specular.exponent),t.specular.color&&(e.specularColor=t.specular.color instanceof Sr?t.specular.color:wr.fromJSON(t.specular.color).toColorDef())),new Ca(e)}}function Ta(t){return{...t,uniformColor:void 0!==t.uniformColor?Sr.fromJSON(t.uniformColor):void 0,qparams:Xo.fromJSON(t.qparams),uvParams:t.uvParams?bo.fromJSON(t.uvParams):void 0}}function ka(t){return{...t,uniformColor:t.uniformColor?.toJSON(),qparams:t.qparams.toJSON(),uvParams:t.uvParams?.toJSON()}}function Fa(t){return{...t,segments:t.segments?{...t.segments,indices:t.segments.indices.data}:void 0,silhouettes:t.silhouettes?{...t.silhouettes,indices:t.silhouettes.indices.data}:void 0,polylines:t.polylines?{...t.polylines,indices:t.polylines.indices.data,prevIndices:t.polylines.prevIndices.data}:void 0,indexed:t.indexed?{indices:t.indexed.indices.data,edges:t.indexed.edges}:void 0}}class Ma{constructor(t,e,i,s,n){this._patterns=new Map,this._document=t,this._binaryData=e,this._options=i,this._featureTableInfo=s,this._stream=n,this._timeline=i.timeline}parse(){const t=this.parseFeatureTable();if(!t)return ro.InvalidFeatureTable;const e=this._document.rtcCenter?{x:this._document.rtcCenter[0]??0,y:this._document.rtcCenter[1]??0,z:this._document.rtcCenter[2]??0}:void 0;return{featureTable:t,nodes:this.parseNodes(t),rtcCenter:e,binaryData:this._binaryData,json:this._document,patterns:this._patterns}}parseFeatureTable(){this._stream.curPos=this._featureTableInfo.startPos;const t=Do.readFrom(this._stream);if(!t||0!=t.length%4)return;const e=(t.length-Do.sizeInBytes)/4,i=new Uint32Array(this._stream.nextUint32s(e));if(this._stream.isPastTheEnd)return;let s;if(this._featureTableInfo.multiModel)s={multiModel:!0,data:i,numFeatures:t.count,numSubCategories:t.numSubCategories};else{let e;const n=this._document.animationNodes;if(void 0!==n){const t=$r.asInt(n.bytesPerId),i=$r.asString(n.bufferView),s=this._document.bufferViews[i];if(void 0!==s){const i=$r.asInt(s.byteOffset),n=$r.asInt(s.byteLength),r=this._binaryData.subarray(i,i+n);switch(t){case 1:e=new Uint8Array(r);break;case 2:e=Uint16Array.from(new Uint16Array(r.buffer,r.byteOffset,r.byteLength/2));break;case 4:e=Uint32Array.from(new Uint32Array(r.buffer,r.byteOffset,r.byteLength/4))}}}s={multiModel:!1,data:i,numFeatures:t.count,animationNodeIds:e}}return this._stream.curPos=this._featureTableInfo.startPos+t.length,s}parseNodes(t){const i=[],s=this._document.nodes,n=this._document.meshes;if(void 0===s.Node_Root)return i;for(const r of Object.keys(s)){const s=this._document.nodes[r];e(void 0!==s);const o=n[s],a=o?.primitives;if(!a)continue;const c=o.layer;"Node_Root"===r?this._timeline?this.parseAnimationBranches(i,o,t,this._timeline):this._options.createUntransformedRootNode?i.push({animationNodeId:xa.Untransformed,primitives:this.parseNodePrimitives(a)}):i.push({primitives:this.parseNodePrimitives(a)}):void 0===c?i.push({animationNodeId:Ia(r),animationId:`${this._options.batchModelId}_${r}`,primitives:this.parseNodePrimitives(a)}):i.push({layerId:c,primitives:this.parseNodePrimitives(a)})}return i}parseAnimationBranches(t,i,s,n){const r=i.primitives;if(!r)return;const o=new Map,a=e=>{let i=o.get(e);return i||(i={animationNodeId:e,animationId:`${this._options.batchModelId}_Node_${e}`,primitives:[]},o.set(e,i),t.push(i)),i};e(void 0===s.animationNodeIds);const c=function(t,e){const i=t.multiModel?Vr.create(t.data,e,t.numFeatures,Xr.Primary,t.numSubCategories):new Nr(t.data,e,t.numFeatures,Xr.Primary);return i.animationNodeIds=t.animationNodeIds,i}(s,this._options.batchModelId);c.populateAnimationNodeIds((t=>n.getBatchIdForFeature(t)),n.maxBatchId),s.animationNodeIds=c.animationNodeIds;const h=n.discreteBatchIds,l={maxDimension:this._options.maxVertexTableSize,computeNodeId:t=>{const e=c.getAnimationNodeId(t);return 0!==e&&h.has(e)?e:0},featureTable:c},d=t=>{if(!t)return;if(t.isAtlas)return t;const e="string"==typeof t.material?this.materialFromJson(t.material):Ca.create(function(t){const e={alpha:t.alpha};return t.diffuse&&(e.diffuse={weight:t.diffuse.weight,color:void 0!==t.diffuse.color?Sr.fromJSON(t.diffuse.color):void 0}),t.specular&&(e.specular={weight:t.specular.weight,exponent:t.specular.exponent,color:void 0!==t.specular.color?Sr.fromJSON(t.specular.color):void 0}),e}(t.material));return e?{isAtlas:!1,material:e}:void 0};for(const t of r){const i=this.parseNodePrimitive(t);if(i)switch(i.type){case"pattern":a(xa.Untransformed).primitives.push(i);break;case"mesh":{const t=i.params,s=t.surface.textureMapping,n={vertices:Ta(i.params.vertices),surface:{...i.params.surface,indices:new na(i.params.surface.indices),material:d(t.surface.material),textureMapping:s?{alwaysDisplayed:s.alwaysDisplayed,texture:"string"==typeof s.texture?new Sa(s.texture,Fo.Type.Normal):new wa(s.texture)}:void 0},edges:i.params.edges?(u=i.params.edges,{...u,segments:u.segments?{...u.segments,indices:new na(u.segments.indices)}:void 0,silhouettes:u.silhouettes?{...u.silhouettes,indices:new na(u.silhouettes.indices)}:void 0,polylines:u.polylines?{...u.polylines,indices:new na(u.polylines.indices),prevIndices:new na(u.polylines.prevIndices)}:void 0,indexed:u.indexed?{indices:new na(u.indexed.indices),edges:u.indexed.edges}:void 0}):void 0,isPlanar:i.params.isPlanar,auxChannels:i.params.auxChannels?Ko.fromJSON(i.params.auxChannels):void 0},r=pa({...l,params:n,createMaterial:t=>Ca.create(t)});for(const[t,i]of r){let s;i.surface.material&&(i.surface.material.isAtlas?s=i.surface.material:(e(i.surface.material.material instanceof Ca),s=i.surface.material.material.toImdl())),e(void 0===i.surface.textureMapping||i.surface.textureMapping.texture instanceof Aa),a(t).primitives.push({type:"mesh",params:{vertices:ka(i.vertices),surface:{...i.surface,indices:i.surface.indices.data,material:s,textureMapping:i.surface.textureMapping?.texture instanceof Aa?{texture:i.surface.textureMapping.texture.toImdl(),alwaysDisplayed:i.surface.textureMapping.alwaysDisplayed}:void 0},edges:i.edges?Fa(i.edges):void 0,isPlanar:i.isPlanar,auxChannels:i.auxChannels?.toJSON()}})}break}case"point":{const t={vertices:Ta(i.params.vertices),indices:new na(i.params.indices),weight:i.params.weight},e=da({...l,params:t});for(const[t,i]of e)a(t).primitives.push({type:"point",params:{vertices:ka(i.vertices),indices:i.indices.data,weight:i.weight}});break}case"polyline":{const t={...i.params,vertices:Ta(i.params.vertices),polyline:{indices:new na(i.params.polyline.indices),prevIndices:new na(i.params.polyline.prevIndices),nextIndicesAndParams:i.params.polyline.nextIndicesAndParams}},e=ma({...l,params:t});for(const[t,i]of e)a(t).primitives.push({type:"polyline",params:{...i,vertices:ka(i.vertices),polyline:{indices:i.polyline.indices.data,prevIndices:i.polyline.prevIndices.data,nextIndicesAndParams:i.polyline.nextIndicesAndParams}}});break}}}var u}parseTesselatedPolyline(t){const e=this.findBuffer(t.indices),i=this.findBuffer(t.prevIndices),s=this.findBuffer(t.nextIndicesAndParams);return e&&i&&s?{indices:e,prevIndices:i,nextIndicesAndParams:s}:void 0}parseSegmentEdges(t){const e=this.findBuffer(t.indices),i=this.findBuffer(t.endPointAndQuadIndices);return e&&i?{indices:e,endPointAndQuadIndices:i}:void 0}parseSilhouetteEdges(t){const e=this.parseSegmentEdges(t),i=this.findBuffer(t.normalPairs);return e&&i?{...e,normalPairs:i}:void 0}parseIndexedEdges(t){const e=this.findBuffer(t.indices),i=this.findBuffer(t.edges);if(e&&i)return{indices:e,edges:{data:i,width:t.width,height:t.height,silhouettePadding:t.silhouettePadding,numSegments:t.numSegments}}}parseCompactEdges(t,i){const s=this.findBuffer(t.visibility);if(!s)return;const n=void 0!==t.normalPairs?this.findBuffer(t.normalPairs):void 0;return function(t){const i=t.normalPairs?.length??0,s=t.numVisibleEdges+i;if(s<=0)return;const n=new na(new Uint8Array(6*s*3));for(let t=0;t<s;t++)for(let e=0;e<6;e++)n.setNthIndex(6*t+e,t);const{width:r,height:o,silhouettePadding:a,silhouetteStartByteIndex:c}=sa(t.numVisibleEdges,i,t.maxEdgeTableDimension),h=new Uint8Array(r*o*4);let l=0,d=0;for(const i of function*(t,i,s){let n=0,r=0,o=0;const a={index0:0,index1:1};for(let c=0;c<i.length;c++){const h=t[r]>>n&3;n+=2,8===n&&(n=0,r++),ya.Hidden!==h&&(a.index0=i.decodeIndex(c),a.index1=i.decodeIndex(c%3==2?c-2:c+1),ya.Silhouette===h?(e(void 0!==s),a.normals=s[o++]):a.normals=void 0,yield a)}}(t.visibility,t.vertexIndices,t.normalPairs))if(void 0===i.normals){const t=6*l++;_a(h,t,i.index0),_a(h,t+3,i.index1)}else{const t=c+a+10*d++;_a(h,t,i.index0),_a(h,t+3,i.index1),h[t+6]=255&i.normals,h[t+7]=(65280&i.normals)>>>8,h[t+8]=(16711680&i.normals)>>>16,h[t+9]=(4278190080&i.normals)>>>24}return{indices:n.data,edges:{data:h,width:r,height:o,numSegments:t.numVisibleEdges,silhouettePadding:a}}}({numVisibleEdges:t.numVisible,visibility:s,vertexIndices:i,normalPairs:n?new Uint32Array(n.buffer,n.byteOffset,n.byteLength/4):void 0,maxEdgeTableDimension:this._options.maxVertexTableSize})}parseEdges(t,e,i){if(!t)return;const s=t.segments?this.parseSegmentEdges(t.segments):void 0,n=t.silhouettes?this.parseSilhouetteEdges(t.silhouettes):void 0,r=t.polylines?this.parseTesselatedPolyline(t.polylines):void 0;let o=t.indexed?this.parseIndexedEdges(t.indexed):void 0;return!o&&t.compact&&(o=this.parseCompactEdges(t.compact,new na(i))),s||n||o||r?{segments:s,silhouettes:n,polylines:r,indexed:o,weight:e.width,linePixels:e.linePixels}:void 0}getPattern(t){let e=this._patterns.get(t);if(!e){const i=this._document.patternSymbols[t];e=i?this.parsePrimitives(i.primitives):[],this._patterns.set(t,e)}return e.length>0?e:void 0}parseAreaPattern(t){const e=this.getPattern(t.symbolName);if(!e||0===e.length)return;const i=this.findBuffer(t.xyOffsets);return i?{type:"pattern",params:{...t,xyOffsets:new Float32Array(i.buffer,i.byteOffset,i.byteLength/4)}}:void 0}parseNodePrimitives(t){const e=[];for(const i of t){const t=this.parseNodePrimitive(i);t&&e.push(t)}return e}parseNodePrimitive(t){return"areaPattern"===t.type?this.parseAreaPattern(t):this.parsePrimitive(t)}parsePrimitives(t){const e=[];for(const i of t){const t=this.parsePrimitive(i);t&&e.push(t)}return e}parsePrimitive(t){let e=this.parseInstances(t);if(!e&&t.viewIndependentOrigin){const i=Q.fromJSON(t.viewIndependentOrigin);e={type:"viewIndependentOrigin",origin:{x:i.x,y:i.y,z:i.z}}}const i=t.material??"",s=i.length?$r.asObject(this._document.materials[i]):void 0,n=s?this.parseDisplayParams(s):void 0;if(!n)return;const r=this.parseVertexTable(t);if(!r)return;let o;const a=!this._options.is3d||$r.asBool(t.isPlanar);switch(t.type){case So.Mesh:{const e=this.parseSurface(t,n);e&&(o={type:"mesh",params:{vertices:r,surface:e,isPlanar:a,auxChannels:this.parseAuxChannelTable(t),edges:this.parseEdges(t.edges,n,e.indices)}});break}case So.Polyline:{const e=this.parseTesselatedPolyline(t);if(e){let t=po.Normal;Bo.RegionEdgeType.Outline===n.regionEdgeType&&(t=!n.gradient||n.gradient.isOutlined?po.Edge:po.Outline),o={type:"polyline",params:{vertices:r,polyline:e,isPlanar:a,type:t,weight:n.width,linePixels:n.linePixels}}}break}case So.Point:{const e=this.findBuffer(t.indices),i=n.width;e&&(o={type:"point",params:{vertices:r,indices:e,weight:i}});break}}return o&&(o.modifier=e),o}parseSurface(t,i){const s=t.surface;if(!s)return;const n=this.findBuffer(s.indices);if(!n)return;const r=s.type;if(!function(t){switch(t){case wo.Unlit:case wo.Lit:case wo.Textured:case wo.TexturedLit:case wo.VolumeClassifier:return!0;default:return!1}}(r))return;const o=i.textureMapping?.texture;let a;const c=t.vertices.materialAtlas,h=t.vertices.numColors;let l;return c&&void 0!==h?a={isAtlas:!0,hasTranslucency:$r.asBool(c.hasTranslucency),overridesAlpha:$r.asBool(c.overridesAlpha,!1),vertexTableOffset:$r.asInt(h),numMaterials:$r.asInt(c.numMaterials)}:i.material&&(e(i.material instanceof Ca),a=i.material.toImdl()),o&&(e(o instanceof Aa),l={texture:o.toImdl(),alwaysDisplayed:$r.asBool(s.alwaysDisplayTexture)}),{type:r,indices:n,fillFlags:i.fillFlags,hasBakedLighting:!1,material:a,textureMapping:l}}parseAuxChannelTable(t){const e=t.auxChannels;if(void 0===e)return;const i=this.findBuffer($r.asString(e.bufferView));return void 0!==i?{data:i,width:e.width,height:e.height,count:e.count,numBytesPerVertex:e.numBytesPerVertex,displacements:e.displacements,normals:e.normals,params:e.params}:void 0}parseVertexTable(t){const e=t.vertices;if(!e)return;const i=this.findBuffer($r.asString(e.bufferView));if(!i)return;const s=void 0!==e.featureID?$r.asInt(e.featureID):void 0,n=$r.asArray(e.params.decodedMin),r=$r.asArray(e.params.decodedMax);if(void 0===n||void 0===r)return;const o=Xo.fromRange(ut.create(Q.create(n[0],n[1],n[2]),Q.create(r[0],r[1],r[2]))),a=void 0!==e.uniformColor?Sr.fromJSON(e.uniformColor):void 0;let c;if(So.Mesh===t.type&&t.surface&&t.surface.uvParams){const e=t.surface.uvParams.decodedMin,i=t.surface.uvParams.decodedMax,s=new gt(e[0],e[1],i[0],i[1]);c=bo.fromRange(s)}return{data:i,usesUnquantizedPositions:!0===e.usesUnquantizedPositions,qparams:o.toJSON(),width:e.width,height:e.height,hasTranslucency:e.hasTranslucency,uniformColor:a?.toJSON(),featureIndexType:e.featureIndexType,uniformFeatureID:s,numVertices:e.count,numRgbaPerVertex:e.numRgbaPerVertex,uvParams:c?.toJSON()}}parseInstances(t){const i=t.instances;if(!i)return;const s=$r.asInt(i.count,0);if(s<=0)return;const n=$r.asArray(i.transformCenter);if(void 0===n||3!==n.length)return;const r=Q.create(n[0],n[1],n[2]),o=this.findBuffer($r.asString(i.featureIds));if(void 0===o)return;const a=this.findBuffer($r.asString(i.transforms));if(void 0===a)return;const c=a.byteLength/4;e(Math.floor(c)===c),e(0==c%12);const h=new Float32Array(a.buffer,a.byteOffset,c);let l;return void 0!==i.symbologyOverrides&&(l=this.findBuffer($r.asString(i.symbologyOverrides))),{type:"instances",count:s,transforms:h,transformCenter:r,featureIds:o,symbologyOverrides:l}}findBuffer(t){if("string"!=typeof t||0===t.length)return;const e=this._document.bufferViews[t];if(void 0===e)return;const i=$r.asInt(e.byteOffset),s=$r.asInt(e.byteLength);return 0!==s?this._binaryData.subarray(i,i+s):void 0}colorDefFromMaterialJson(t){return void 0!==t?Sr.from(255*t[0]+.5,255*t[1]+.5,255*t[2]+.5):void 0}materialFromJson(t){const e=this._document.renderMaterials[t];if(!e)return;const i=new Mo.Params(t);return i.diffuseColor=this.colorDefFromMaterialJson(e.diffuseColor),void 0!==e.diffuse&&(i.diffuse=$r.asDouble(e.diffuse)),i.specularColor=this.colorDefFromMaterialJson(e.specularColor),void 0!==e.specular&&(i.specular=$r.asDouble(e.specular)),i.reflectColor=this.colorDefFromMaterialJson(e.reflectColor),void 0!==e.reflect&&(i.reflect=$r.asDouble(e.reflect)),void 0!==e.specularExponent&&(i.specularExponent=e.specularExponent),void 0!==e.transparency&&(i.alpha=1-e.transparency),i.refract=$r.asDouble(e.refract),i.shadows=$r.asBool(e.shadows),i.ambient=$r.asDouble(e.ambient),void 0!==e.textureMapping&&(i.textureMapping=this.textureMappingFromJson(e.textureMapping.texture)),new Ca(i)}parseNamedTexture(t,e){const i=$r.asBool(t.isGlyph)?Fo.Type.Glyph:$r.asBool(t.isTileSection)?Fo.Type.TileSection:Fo.Type.Normal;return new Sa(e,i)}parseConstantLodProps(t){if(void 0!==t)return{repetitions:$r.asDouble(t.repetitions,1),offset:{x:t.offset?$r.asDouble(t.offset[0]):0,y:t.offset?$r.asDouble(t.offset[1]):0},minDistClamp:$r.asDouble(t.minDistClamp,1),maxDistClamp:$r.asDouble(t.maxDistClamp,4294967296)}}textureMappingFromJson(t){if(!t)return;const e=$r.asString(t.name),i=0!==e.length?this._document.namedTextures[e]:void 0,s=i?this.parseNamedTexture(i,e):void 0;if(!s)return;const n=t.params,r=n.transform,o={textureMat2x3:new Yo.Trans2x3(r[0][0],r[0][1],r[0][2],r[1][0],r[1][1],r[1][2]),textureWeight:$r.asDouble(n.weight,1),mapMode:$r.asInt(n.mode),worldMapping:$r.asBool(n.worldMapping),useConstantLod:$r.asBool(n.useConstantLod),constantLodProps:this.parseConstantLodProps(n.constantLodParams)},a=new Yo(s,new Yo.Params(o)),c=t.normalMapParams;if(c){const t=$r.asString(c.textureName),e=t.length>0?this._document.namedTextures[t]:void 0,i=e?this.parseNamedTexture(e,t):void 0;i&&(a.normalMapParams={normalMap:i,greenUp:$r.asBool(c.greenUp),scale:$r.asDouble(c.scale,1),useConstantLod:$r.asBool(c.useConstantLod)})}return a}parseDisplayParams(t){const i=$r.asInt(t.type,Bo.Type.Mesh),s=Sr.create($r.asInt(t.lineColor)),n=Sr.create($r.asInt(t.fillColor)),r=$r.asInt(t.lineWidth),o=$r.asInt(t.linePixels,mo.Solid),a=$r.asInt(t.fillFlags,xo.None),c=$r.asBool(t.ignoreLighting),h=t.materialId,l=void 0!==h?this.materialFromJson(h):void 0;let d,u;if(!l){const i=t.texture;if(d=void 0!==i?this.textureMappingFromJson(i):void 0,void 0===d){const i=t.gradient;if(u=void 0!==i?Ao.Symb.fromJSON(i):void 0,u){e(void 0!==i);const t=new wa(i);d=new Yo(t,new Yo.Params({textureMat2x3:new Yo.Trans2x3(0,1,0,1,0,0)}))}}}return new Bo(i,s,n,r,o,a,l,u,c,d)}}let ba;var Ea;Ea={parse:t=>{const e=function(t){const e=io.fromUint8Array(t.data),i=new zo(e);if(!i.isValid)return ro.InvalidHeader;if(!i.isReadableVersion)return ro.NewerMajorVersion;const s=e.curPos,n=Do.readFrom(e);if(!n)return ro.InvalidFeatureTable;e.curPos=s+n.length;const r=new va(e);if(!r.isValid)return ro.InvalidTileData;e.curPos=r.scenePosition;const o=function(t){let e;if(so)try{e=new TextDecoder("utf-8")}catch(t){so=!1}return void 0!==e?e.decode(t):function(t){return to.decodeWithFromCharCode(t)}(t)}(e.nextBytes(r.sceneStrLength));if(!o)return ro.InvalidScene;try{const n=JSON.parse(o),a={scene:$r.asString(n.scene),scenes:$r.asArray(n.scenes),animationNodes:$r.asObject(n.animationNodes),bufferViews:$r.asObject(n.bufferViews)??{},meshes:$r.asObject(n.meshes),nodes:$r.asObject(n.nodes)??{},materials:$r.asObject(n.materials)??{},renderMaterials:$r.asObject(n.renderMaterials)??{},namedTextures:$r.asObject(n.namedTextures)??{},patternSymbols:$r.asObject(n.patternSymbols)??{},rtcCenter:$r.asArray(n.rtcCenter)};if(!a.meshes)return ro.InvalidTileData;const c=new Uint8Array(e.arrayBuffer,r.binaryPosition),h={startPos:s,multiModel:0!=(i.flags&fo.MultiModelFeatureTable)};return new Ma(a,c,t,h,e).parse()}catch(t){return ro.InvalidTileData}}({...t,data:t.data,timeline:ba});return"number"==typeof e?e:{result:e,transfer:eo(e)}},setTimeline:t=>{e(void 0===ba,"setTimeline must be called only once"),ba=Array.isArray(t)?Qr.Script.fromJSON(t):Qr.ModelTimeline.fromJSON(t)}},onmessage=t=>{const i=t.data,s=i.msgId;try{e("object"==typeof i&&"operation"in i&&"payload"in i&&"msgId"in i);const t=Ea[i.operation];e("function"==typeof t);const n=t(i.payload);"object"==typeof n&&"transfer"in n?postMessage({result:n.result,msgId:s},{transfer:n.transfer}):postMessage({result:n,msgId:s})}catch(t){const e=t instanceof Error?t:new Error("Unknown worker error");postMessage({error:e,msgId:s})}}})();