{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/topology/SpaceTriangulation.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Topology\n */\nimport { LineString3d } from \"../curve/LineString3d\";\nimport { Geometry } from \"../Geometry\";\nimport { Point3dArray } from \"../geometry3d/PointHelpers\";\nimport { PolygonOps } from \"../geometry3d/PolygonOps\";\nimport { PolylineOps } from \"../geometry3d/PolylineOps\";\n/**\n * Class with static methods to triangulate various forms of possibly non-planar polygons.\n * @public\n */\nexport class SpacePolygonTriangulation {\n    /**\n     * * Return a number which is:\n     *   * 0 for collapsed (zero area) triangle\n     *   * positive for non-zero area\n     *   * larger is \"better\"\n     * * Specifically, return (if well defined) the area divided by summed squares of edge lengths.\n     * @param point0\n     * @param point1\n     * @param point2\n     */\n    static spaceTriangleAspectRatio(point0, point1, point2) {\n        const crossProduct = point0.crossProductToPoints(point1, point2);\n        const area = 0.5 * crossProduct.magnitude();\n        const summedEdgeSquares = point0.distanceSquared(point1) + point1.distanceSquared(point2) + point2.distanceSquared(point0);\n        return Geometry.safeDivideFraction(area, summedEdgeSquares, 0.0);\n    }\n    /**\n     * * Treat a space quad as two triangles with interior diagonal from point0 to point2\n     * * Return the smaller of the aspect ratios of the two triangles.\n     * * The quad edges proceed in the order [point0, point1, point2, point3]\n     * @param point0 first point of quad\n     * @param point1 second point of quad (diagonally opposite of point3)\n     * @param point2 third point (diagonally opposite point0)\n     * @param point3 fourth point\n     */\n    static spaceQuadDiagonalAspectRatio(point0, point1, point2, point3) {\n        const q012 = this.spaceTriangleAspectRatio(point0, point1, point2);\n        const q023 = this.spaceTriangleAspectRatio(point0, point2, point3);\n        return Math.max(q012, q023);\n    }\n    /** \"Triangulate\" by cutting of the ear with best aspect ratio.  Reject if successive normals have negative dot product with PolygonOps.AreaNormal */\n    static triangulateGreedyEarCut(points, announceLoopAndTriangles) {\n        const normalA = PolygonOps.areaNormal(points);\n        const triangles = [];\n        const myPoints = points.slice();\n        PolylineOps.removeClosurePoint(myPoints);\n        // first pass deals with entire array.\n        // each pass lops off one point.\n        for (; myPoints.length > 2;) {\n            // Find the ear candidate whose cross product vector has largest dot product (large area, best alignment with overall).\n            let bestRatio = -1.0;\n            let bestRatioIndex0 = 0;\n            let i0 = myPoints.length - 2;\n            let i1 = myPoints.length - 1;\n            let i2;\n            for (i2 = 0; i2 < myPoints.length; i0 = i1, i1 = i2, i2++) {\n                const ratio = this.spaceTriangleAspectRatio(myPoints[i0], myPoints[i1], myPoints[i2]);\n                const normalB = myPoints[i0].crossProductToPoints(myPoints[i1], myPoints[i2]);\n                if (normalB.dotProduct(normalA) > 0 && ratio > bestRatio) {\n                    bestRatio = ratio;\n                    bestRatioIndex0 = i0;\n                }\n            }\n            if (bestRatio <= 0.0)\n                return false;\n            // add the ear to the result\n            i0 = bestRatioIndex0;\n            i1 = (i0 + 1) % myPoints.length;\n            i2 = (i1 + 1) % myPoints.length;\n            const t = [];\n            t.push(myPoints[i0], myPoints[i1], myPoints[i2]);\n            // remove the middle point\n            myPoints.splice(i1, 1);\n            triangles.push(t);\n        }\n        announceLoopAndTriangles(points, triangles);\n        return true;\n    }\n    static triangulateSimplestSpaceLoopGo(points, announceLoopAndTriangles, maxPerimeter) {\n        const n = Point3dArray.countNonDuplicates(points);\n        if (maxPerimeter !== undefined && Point3dArray.sumEdgeLengths(points, true, n) > maxPerimeter)\n            return false;\n        if (n < 3)\n            return false;\n        if (n === 3) {\n            if (this.spaceTriangleAspectRatio(points[0], points[1], points[2]) === 0)\n                return false;\n            // already a triangle . . .\n            announceLoopAndTriangles(points, [points.slice()]);\n            return true;\n        }\n        if (n === 4) {\n            const d02 = this.spaceQuadDiagonalAspectRatio(points[0], points[1], points[2], points[3]);\n            const d13 = this.spaceQuadDiagonalAspectRatio(points[1], points[2], points[3], points[0]);\n            if (d02 === 0.0 && d13 === 0.0)\n                return false;\n            // announce the two triangles with better aspect ratios ....\n            if (d02 > d13) {\n                announceLoopAndTriangles(points, [[points[0], points[1], points[2]], [points[2], points[3], points[0]]]);\n                return true;\n            }\n            else {\n                announceLoopAndTriangles(points, [[points[0], points[1], points[3]], [points[3], points[1], points[2]]]);\n                return true;\n            }\n        }\n        return this.triangulateGreedyEarCut(points, announceLoopAndTriangles);\n    }\n    /**\n     * * Emit triangles for a (possibly non-planar) loop for various simple cases:\n     *    * only 3 points: just emit that triangle.\n     *    * only 4 points: split across a diagonal, choosing the one with better aspect ratios of its two triangles.\n     * * BUT\n     *    * do not complete the triangulation if perimeter is larger than maxPerimeter (i.e. only consider small areas)\n     * * Hence it is expected that the caller will use this as the first attempt, possibly followed by calls to other more adventurous methods.\n     */\n    static triangulateSimplestSpaceLoop(loop, announceLoopAndTriangles, maxPerimeter) {\n        if (loop instanceof LineString3d)\n            return this.triangulateSimplestSpaceLoopGo(loop.points, announceLoopAndTriangles, maxPerimeter);\n        // (array case by exhaustion)\n        return this.triangulateSimplestSpaceLoopGo(loop, announceLoopAndTriangles, maxPerimeter);\n    }\n}\n//# sourceMappingURL=SpaceTriangulation.js.map",
      "start": 1693508124008,
      "end": 1693508124173,
      "sourcemaps": null
    }
  ]
}
