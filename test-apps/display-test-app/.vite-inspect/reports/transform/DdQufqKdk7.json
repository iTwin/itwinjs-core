{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/bentley/lib/esm/StringUtils.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Utils\n */\n// TextDecoder is not supported on all platforms - this is an alternative for utf-8.\n// From https://github.com/AnalyticalGraphicsInc/cesium/blob/master/Source/Core/getStringFromTypedArray.js\n// which is itself inspired by https://github.com/inexorabletash/text-encoding\n/** @internal */\nvar Utf8ToString;\n(function (Utf8ToString) {\n    function inRange(a, min, max) {\n        return min <= a && a <= max;\n    }\n    function utf8Handler(bytes) {\n        let codePoint = 0;\n        let bytesSeen = 0;\n        let bytesNeeded = 0;\n        let lowerBoundary = 0x80;\n        let upperBoundary = 0xbf;\n        const codePoints = [];\n        const length = bytes.length;\n        for (let i = 0; i < length; i++) {\n            const currentByte = bytes[i];\n            // If bytesNeeded = 0, then we are starting a new character\n            if (0 === bytesNeeded) {\n                // 1 byte ascii character\n                if (inRange(currentByte, 0x00, 0x7f)) {\n                    // return a code point whose value is byte.\n                    codePoints.push(currentByte);\n                    continue;\n                }\n                // 2 byte character\n                if (inRange(currentByte, 0xc2, 0xdf)) {\n                    bytesNeeded = 1;\n                    codePoint = currentByte & 0x1f;\n                    continue;\n                }\n                // 3 byte character\n                if (inRange(currentByte, 0xe0, 0xef)) {\n                    if (0xe0 === currentByte)\n                        lowerBoundary = 0xa0;\n                    else if (0xed === currentByte)\n                        upperBoundary = 0x9f;\n                    bytesNeeded = 2;\n                    codePoint = currentByte & 0xf;\n                    continue;\n                }\n                // 4 byte character\n                if (inRange(currentByte, 0xf0, 0xf4)) {\n                    if (0xf0 === currentByte)\n                        lowerBoundary = 0x90;\n                    else if (0xf4 === currentByte)\n                        upperBoundary = 0x8f;\n                    bytesNeeded = 3;\n                    codePoint = currentByte & 0x7;\n                    continue;\n                }\n                // invalid utf-8\n                return undefined;\n            }\n            // out of range so ignore the first part(s) of the character and continue with this byte on its own\n            if (!inRange(currentByte, lowerBoundary, upperBoundary)) {\n                codePoint = bytesNeeded = bytesSeen = 0;\n                lowerBoundary = 0x80;\n                upperBoundary = 0xbf;\n                --i;\n                continue;\n            }\n            // set appropriate boundaries since we've now checked byte 2 of a potential longer character\n            lowerBoundary = 0x80;\n            upperBoundary = 0xbf;\n            // add byte to code point\n            codePoint = (codePoint << 6) | (currentByte & 0x3f);\n            // We have the correct number of bytes, so push and reset for next character\n            ++bytesSeen;\n            if (bytesSeen === bytesNeeded) {\n                codePoints.push(codePoint);\n                codePoint = bytesNeeded = bytesSeen = 0;\n            }\n        }\n        return codePoints;\n    }\n    function decodeWithFromCharCode(view) {\n        let result = \"\";\n        const codePoints = utf8Handler(view);\n        if (undefined === codePoints)\n            return undefined;\n        for (let cp of codePoints) {\n            if (cp <= 0xffff) {\n                result += String.fromCharCode(cp);\n            }\n            else {\n                cp -= 0x10000;\n                result += String.fromCharCode((cp >> 10) + 0xd800, (cp & 0x3ff) + 0xdc00);\n            }\n        }\n        return result;\n    }\n    Utf8ToString.decodeWithFromCharCode = decodeWithFromCharCode;\n})(Utf8ToString || (Utf8ToString = {}));\n/** Exposed only for testing the fall-back used when TextDecoder is unsupported.\n * @internal\n */\nexport function utf8ToStringPolyfill(utf8) {\n    return Utf8ToString.decodeWithFromCharCode(utf8);\n}\n// TextDecoder unsupported in Edge at time of writing.\nlet textDecoderSupported = true;\n/** Given an array of bytes containing a utf-8 string, convert to a string.\n * @param utf8: An array of utf-8 characters as a byte array\n * @returns An equivalent string, or undefined if the array does not contain a valid utf-8 string.\n * @note This function uses Javascript's TextDecoder if supported by the browser; otherwise, it\n * falls back to a less efficient polyfill.\n * @public\n */\nexport function utf8ToString(utf8) {\n    let decoder;\n    if (textDecoderSupported) {\n        try {\n            decoder = new TextDecoder(\"utf-8\");\n        }\n        catch (_ex) {\n            textDecoderSupported = false;\n        }\n    }\n    if (undefined !== decoder)\n        return decoder.decode(utf8);\n    else\n        return utf8ToStringPolyfill(utf8);\n}\n/** Given a base-64-encoded string, decode it into an array of bytes.\n * @param base64 The base-64-encoded string.\n * @returns the decoded byte array.\n * @throws DOMException if the length of the input string is not a multiple of 4.\n * @public\n */\nexport function base64StringToUint8Array(base64) {\n    return new Uint8Array(atob(base64).split(\"\").map((c) => c.charCodeAt(0))); // eslint-disable-line deprecation/deprecation\n}\n//# sourceMappingURL=StringUtils.js.map",
      "start": 1693508120621,
      "end": 1693508120687,
      "sourcemaps": null
    }
  ]
}
