{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend-devtools/lib/esm/tools/MapLayerTool.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\nimport { BaseMapLayerSettings, ColorDef, ModelMapLayerSettings } from \"@itwin/core-common\";\nimport { IModelApp, MapLayerSource, MapLayerSources, MapLayerSourceStatus, NotifyMessageDetails, OutputMessagePriority, Tool, WmsUtilities } from \"@itwin/core-frontend\";\nimport { parseBoolean } from \"./parseBoolean\";\nimport { parseToggle } from \"./parseToggle\";\n/** Base class for attaching map layer tool. */\nclass AttachMapLayerBaseTool extends Tool {\n    constructor(_isBackground = true, _isBase = false) {\n        super();\n        this._isBackground = _isBackground;\n        this._isBase = _isBase;\n    }\n    doAttach(source) {\n        const vp = IModelApp.viewManager.selectedView;\n        if (vp === undefined || source === undefined)\n            return;\n        source.validateSource().then((validation) => {\n            if (validation.status === MapLayerSourceStatus.Valid || validation.status === MapLayerSourceStatus.RequireAuth) {\n                if (this._isBase) {\n                    vp.displayStyle.backgroundMapBase = BaseMapLayerSettings.fromJSON({ ...source, subLayers: validation.subLayers });\n                    vp.invalidateRenderPlan();\n                }\n                else {\n                    const settings = source.toLayerSettings(validation.subLayers);\n                    if (settings) {\n                        // Need to specify index in mapLayerIndex, so just use -1 to attach layer at the bottom\n                        // Previously, this was done within attachMapLayer if index was undefined.\n                        vp.displayStyle.attachMapLayer({ settings, mapLayerIndex: { isOverlay: !this._isBackground, index: -1 } });\n                    }\n                }\n                if (validation.status === MapLayerSourceStatus.Valid) {\n                    vp.invalidateRenderPlan();\n                    const msg = IModelApp.localization.getLocalizedString(\"FrontendDevTools:tools.AttachMapLayerTool.Messages.MapLayerAttached\", { sourceName: source.name });\n                    IModelApp.notifications.outputMessage(new NotifyMessageDetails(OutputMessagePriority.Info, msg));\n                }\n                else if (validation.status === MapLayerSourceStatus.RequireAuth) {\n                    const msg = IModelApp.localization.getLocalizedString(\"FrontendDevTools:tools.AttachMapLayerTool.Messages.MapLayerAttachedRequiresAuth\", { sourceName: source.name });\n                    IModelApp.notifications.outputMessage(new NotifyMessageDetails(OutputMessagePriority.Warning, msg));\n                }\n            }\n            else if (validation.status === MapLayerSourceStatus.IncompatibleFormat) {\n                const msg = IModelApp.localization.getLocalizedString(\"FrontendDevTools:tools.AttachMapLayerTool.Messages.MapLayersIncompatibleFormat\", { sourceName: source.name });\n                IModelApp.notifications.outputMessage(new NotifyMessageDetails(OutputMessagePriority.Error, msg));\n            }\n            else {\n                const msg = IModelApp.localization.getLocalizedString(\"FrontendDevTools:tools.AttachMapLayerTool.Messages.MapLayerValidationFailed\", { sourceName: source.name });\n                IModelApp.notifications.outputMessage(new NotifyMessageDetails(OutputMessagePriority.Error, msg));\n            }\n        }).catch((error) => {\n            const msg = IModelApp.localization.getLocalizedString(\"FrontendDevTools:tools.AttachMapLayerTool.Messages.MapLayerAttachError\", { error, sourceName: source.name });\n            IModelApp.notifications.outputMessage(new NotifyMessageDetails(OutputMessagePriority.Error, msg));\n        });\n    }\n}\n/** Attach a map layer from URL base class. A layer is attached for each unique model in the selection\n * @beta\n */\nclass AttachModelMapLayerTool extends Tool {\n    static get minArgs() { return 0; }\n    static get maxArgs() { return 1; }\n    constructor(_formatId) {\n        super();\n        this._formatId = _formatId;\n    }\n    async run(nameIn) {\n        const vp = IModelApp.viewManager.selectedView;\n        if (!vp)\n            return false;\n        const iModel = vp.iModel;\n        const elements = await iModel.elements.getProps(iModel.selectionSet.elements);\n        const modelIds = new Set();\n        for (const element of elements)\n            modelIds.add(element.model);\n        for (const modelId of modelIds) {\n            const modelProps = await iModel.models.getProps(modelId);\n            const modelName = modelProps[0].name ? modelProps[0].name : modelId;\n            const name = nameIn ? (modelIds.size > 1 ? `${nameIn}: ${modelName}` : nameIn) : modelName;\n            const settings = ModelMapLayerSettings.fromJSON({ name, modelId });\n            vp.displayStyle.attachMapLayer({ settings, mapLayerIndex: { isOverlay: false, index: -1 } });\n        }\n        return true;\n    }\n    async parseAndRun(...args) {\n        return this.run(args[0]);\n    }\n    async onRestartTool() {\n    }\n}\nAttachModelMapLayerTool.toolId = \"AttachModelMapLayerTool\";\nexport { AttachModelMapLayerTool };\n/** Attach a map layer from URL base class. */\nclass AttachMapLayerByURLBaseTool extends AttachMapLayerBaseTool {\n    static get minArgs() { return 1; }\n    static get maxArgs() { return 4; }\n    constructor(_formatId) {\n        super();\n        this._formatId = _formatId;\n    }\n    async run(url, name, userName, password) {\n        const source = MapLayerSource.fromJSON({ url, name: (name ? name : url), formatId: this._formatId });\n        if (source) {\n            source.userName = userName;\n            source.password = password;\n        }\n        this.doAttach(source);\n        return true;\n    }\n    async parseAndRun(...args) {\n        return this.run(args[0], args[1], args[2], args[3]);\n    }\n}\n/** This tool attaches a WMS map layer from a given URL.\n * @beta\n */\nclass AttachWmsMapLayerByUrlTool extends AttachMapLayerByURLBaseTool {\n    constructor() { super(\"WMS\"); }\n    /** This method runs the tool, attaching a WMS map layer from a given URL.\n     * @param args contains url, name, userName, password in array order\n     */\n    async parseAndRun(...args) {\n        return this.run(WmsUtilities.getBaseUrl(args[0]), args[1], args[2], args[3]);\n    }\n}\nAttachWmsMapLayerByUrlTool.toolId = \"AttachWmsMapLayerTool\";\nexport { AttachWmsMapLayerByUrlTool };\n/** This tool attaches a WMTS map layer from a given URL.\n * @beta\n */\nclass AttachWmtsMapLayerByUrlTool extends AttachMapLayerByURLBaseTool {\n    constructor() { super(\"WMTS\"); }\n    /** This method runs the tool, attaching a WMTS map layer from a given URL.\n     * @param args contains url, name, userName, password in array order\n     */\n    async parseAndRun(...args) {\n        return this.run(WmsUtilities.getBaseUrl(args[0]), args[1], args[2], args[3]);\n    }\n}\nAttachWmtsMapLayerByUrlTool.toolId = \"AttachWmtsMapLayerTool\";\nexport { AttachWmtsMapLayerByUrlTool };\n/** This tool attaches an ArcGIS map layer from a given URL.\n * @beta\n */\nclass AttachArcGISMapLayerByUrlTool extends AttachMapLayerByURLBaseTool {\n    constructor() { super(\"ArcGIS\"); }\n}\nAttachArcGISMapLayerByUrlTool.toolId = \"AttachArcGISMapLayerTool\";\nexport { AttachArcGISMapLayerByUrlTool };\n/** This tool attaches an ArcGIS map layer from a given URL.\n * @beta\n */\nclass AttachArcGISFeatureMapLayerByUrlTool extends AttachMapLayerByURLBaseTool {\n    constructor() { super(\"ArcGISFeature\"); }\n}\nAttachArcGISFeatureMapLayerByUrlTool.toolId = \"AttachArcGISFeatureMapLayerTool\";\nexport { AttachArcGISFeatureMapLayerByUrlTool };\n/** This tool attaches a map layer from a given tile URL.\n * @beta\n */\nclass AttachTileURLMapLayerByUrlTool extends AttachMapLayerByURLBaseTool {\n    constructor() { super(\"TileURL\"); }\n}\nAttachTileURLMapLayerByUrlTool.toolId = \"AttachTileURLMapLayerTool\";\nexport { AttachTileURLMapLayerByUrlTool };\n/** This tool add a Map Layer from a specified name (look up in MapLayerSources.json).\n * @beta\n */\nclass AttachMapLayerTool extends AttachMapLayerBaseTool {\n    static get minArgs() { return 1; }\n    static get maxArgs() { return 1; }\n    /** This method runs the tool, adding a map layer from a specified name in MayLayerSources.json.\n     * @param name the name of the map layer to add\n     */\n    async run(name) {\n        const vp = IModelApp.viewManager.selectedView;\n        if (vp === undefined)\n            return false;\n        MapLayerSources.create().then((sources) => {\n            if (sources !== undefined) {\n                const source = sources.findByName(name, this._isBase);\n                if (source !== undefined)\n                    this.doAttach(source);\n            }\n        }).catch((_err) => { });\n        return true;\n    }\n    /** Executes this tool's run method with args[0] containing `name`.\n     * @see [[run]]\n     */\n    async parseAndRun(...args) {\n        return this.run(args[0]);\n    }\n}\nAttachMapLayerTool.toolId = \"AttachMapLayerTool\";\nexport { AttachMapLayerTool };\n/** This tool attaches a Overlay map layer.\n * @beta\n */\nclass AttachMapOverlayTool extends AttachMapLayerTool {\n    constructor() {\n        super();\n        this._isBackground = false;\n    }\n}\nAttachMapOverlayTool.toolId = \"AttachMapOverlayTool\";\nexport { AttachMapOverlayTool };\n/** Sets map layer base tool.\n * @beta\n */\nclass SetMapBaseTool extends AttachMapLayerTool {\n    constructor() {\n        super();\n        this._isBase = true;\n    }\n}\nSetMapBaseTool.toolId = \"SetMapBaseTool\";\nexport { SetMapBaseTool };\n/** Detach Map Layers Tool.\n * @beta\n */\nclass DetachMapLayersTool extends Tool {\n    static get minArgs() { return 0; }\n    static get maxArgs() { return 0; }\n    async parseAndRun(..._args) {\n        return this.run();\n    }\n    async run() {\n        const vp = IModelApp.viewManager.selectedView;\n        if (vp === undefined)\n            return false;\n        vp.displayStyle.detachMapLayerByIndex({ index: -1, isOverlay: true });\n        vp.displayStyle.detachMapLayerByIndex({ index: -1, isOverlay: false });\n        vp.invalidateRenderPlan();\n        return true;\n    }\n}\nDetachMapLayersTool.toolId = \"DetachMapLayersTool\";\nexport { DetachMapLayersTool };\nfunction parseLayerIndex(args) {\n    const layerIndex = args.length > 1 ? parseInt(args[1], 10) : 0;\n    return isNaN(layerIndex) ? 0 : layerIndex;\n}\n/** This tool sets the visibility of the map layer.\n * @beta\n */\nclass MapLayerVisibilityTool extends Tool {\n    static get minArgs() { return 1; }\n    static get maxArgs() { return 2; }\n    /** This method runs the tool, setting the visibility of a map layer.\n     * @param layerIndex the index of the layer to change\n     * @param visible a boolean that should be true if the layer should be visible\n     */\n    async run(layerIndex, enable) {\n        const vp = IModelApp.viewManager.selectedView;\n        if (undefined === vp || !vp.view.isSpatialView())\n            return false;\n        const mapLayer = vp.displayStyle.mapLayerAtIndex({ index: layerIndex, isOverlay: false });\n        if (undefined === mapLayer)\n            return false;\n        const visible = (enable === undefined) ? !mapLayer.visible : enable;\n        vp.displayStyle.changeMapLayerProps({ visible }, { index: layerIndex, isOverlay: false });\n        vp.invalidateRenderPlan();\n        return true;\n    }\n    /** Executes this tool's run method with args[0] containing `enable` and args[1] containing `layerIndex`.\n     * @see [[run]]\n     */\n    async parseAndRun(...args) {\n        const enable = parseToggle(args[0]);\n        const layerIndex = parseLayerIndex(args);\n        if (typeof enable !== \"string\")\n            await this.run(layerIndex, enable);\n        return true;\n    }\n}\nMapLayerVisibilityTool.toolId = \"SetMapLayerVisibility\";\nexport { MapLayerVisibilityTool };\n/** This tool reorders map layers.\n * @beta\n */\nclass ReorderMapLayers extends Tool {\n    static get minArgs() { return 0; }\n    static get maxArgs() { return 2; }\n    /** This method runs the tool, reordering the map layers.\n     * @param from a numeric value specifying the layer index that is being moved\n     * @param from a numeric value specifying the layer index to move that layer to\n     */\n    async run(from, to) {\n        const vp = IModelApp.viewManager.selectedView;\n        if (undefined === vp || !vp.view.isSpatialView())\n            return false;\n        vp.displayStyle.moveMapLayerToIndex(isNaN(from) ? 0 : from, isNaN(to) ? vp.displayStyle.settings.mapImagery.backgroundLayers.length : to, false);\n        vp.invalidateRenderPlan();\n        return true;\n    }\n    /** Executes this tool's run method with args[0] containing `from` and args[1] containing `to`.\n     * @see [[run]]\n     */\n    async parseAndRun(...args) {\n        const from = parseInt(args[0], 10);\n        const to = parseInt(args[1], 10);\n        await this.run(from, to);\n        return true;\n    }\n}\nReorderMapLayers.toolId = \"ReorderMapLayers\";\nexport { ReorderMapLayers };\n/** This tool sets the transparency of a map layer.\n * @beta\n */\nclass MapLayerTransparencyTool extends Tool {\n    static get minArgs() { return 1; }\n    static get maxArgs() { return 2; }\n    /** This method runs the tool, setting the transparency of a map layer.\n     * @param layerIndex the index of the layer to change\n     * @param transparency a numeric value in the range 0.0 (fully opaque) to 1.0 (fully transparent)\n     */\n    async run(layerIndex, transparency) {\n        const vp = IModelApp.viewManager.selectedView;\n        if (undefined === vp || !vp.view.isSpatialView())\n            return false;\n        vp.displayStyle.changeMapLayerProps({ transparency }, { index: layerIndex, isOverlay: false });\n        vp.invalidateRenderPlan();\n        return true;\n    }\n    /** Executes this tool's run method with args[0] containing `transparency` and args[1] containing `layerIndex`.\n     * @see [[run]]\n     */\n    async parseAndRun(...args) {\n        const transparency = parseFloat(args[0]);\n        const layerIndex = parseLayerIndex(args);\n        if (transparency >= 0 && transparency <= 1)\n            await this.run(layerIndex, transparency);\n        return true;\n    }\n}\nMapLayerTransparencyTool.toolId = \"SetMapLayerTransparency\";\nexport { MapLayerTransparencyTool };\n/** This tool sets the visibility of the map sublayer.\n * @beta\n */\nclass MapLayerSubLayerVisibilityTool extends Tool {\n    static get minArgs() { return 1; }\n    static get maxArgs() { return 2; }\n    /** This method runs the tool, setting the visibility of a map sublayer.\n     * @param layerIndex the index of the layer to change\n     * @param visible a boolean that should be true if the sublayer should be visible\n     */\n    async run(layerIndex, visible) {\n        const vp = IModelApp.viewManager.selectedView;\n        if (undefined === vp || !vp.view.isSpatialView())\n            return false;\n        vp.displayStyle.changeMapSubLayerProps({ visible }, -1, { index: layerIndex, isOverlay: false });\n        vp.invalidateRenderPlan();\n        return true;\n    }\n    /** Executes this tool's run method with args[0] containing `transparency` and args[1] containing `layerIndex`.\n     * @see [[run]]\n     */\n    async parseAndRun(...args) {\n        const on = args[0] !== \"off\";\n        const layerIndex = parseLayerIndex(args);\n        await this.run(layerIndex, on);\n        return true;\n    }\n}\nMapLayerSubLayerVisibilityTool.toolId = \"SetMapSubLayerVisibility\";\nexport { MapLayerSubLayerVisibilityTool };\n/** This tool changes the viewport so it is zoomed to the range of a map layer.\n * @beta\n */\nclass MapLayerZoomTool extends Tool {\n    static get minArgs() { return 0; }\n    static get maxArgs() { return 1; }\n    /** This method runs the tool, changing the viewport so it is zoomed to the range of a map layer.\n     * @param layerIndex the index of the layer whose range to zoom to\n     */\n    async run(layerIndex) {\n        const vp = IModelApp.viewManager.selectedView;\n        if (undefined === vp || !vp.view.isSpatialView())\n            return false;\n        vp.viewMapLayerRange({ index: layerIndex, isOverlay: false }, vp).then(() => { }).catch(() => { });\n        return true;\n    }\n    /** Executes this tool's run method with args[0] containing `layerIndex`.\n     * @see [[run]]\n     */\n    async parseAndRun(...args) {\n        const layerIndex = parseLayerIndex(args);\n        await this.run(layerIndex);\n        return true;\n    }\n}\nMapLayerZoomTool.toolId = \"MapLayerZoom\";\nexport { MapLayerZoomTool };\n/** This tool toggles whether to apply terrain heights to the map.\n * @beta\n */\nclass ToggleTerrainTool extends Tool {\n    static get minArgs() { return 0; }\n    static get maxArgs() { return 1; }\n    /** This method runs the tool, changing whether to apply terrain heights to the map.\n     * @param enable whether or not to enable terrain heights on the map\n     */\n    async run(enable) {\n        const vp = IModelApp.viewManager.selectedView;\n        if (undefined === vp || !vp.view.isSpatialView())\n            return false;\n        const applyTerrain = (enable === undefined) ? !vp.displayStyle.backgroundMapSettings.applyTerrain : enable;\n        vp.displayStyle.changeBackgroundMapProps({ applyTerrain });\n        vp.invalidateRenderPlan();\n        return true;\n    }\n    /** Executes this tool's run method with args[0] containing `enable`.\n     * @see [[run]]\n     */\n    async parseAndRun(...args) {\n        const enable = parseToggle(args[0]);\n        if (typeof enable !== \"string\")\n            await this.run(enable);\n        return true;\n    }\n}\nToggleTerrainTool.toolId = \"ToggleTerrain\";\nexport { ToggleTerrainTool };\n/** This tool changes the color of the base map.\n * @beta\n */\nclass MapBaseColorTool extends Tool {\n    static get minArgs() { return 3; }\n    static get maxArgs() { return 3; }\n    /** This method runs the tool, changing the color of the base map.\n     * @param color the color for the base map\n     */\n    async run(color) {\n        const vp = IModelApp.viewManager.selectedView;\n        if (undefined === vp || !vp.view.isSpatialView())\n            return false;\n        const curTransparency = vp.displayStyle.backgroundMapBase instanceof ColorDef ? vp.displayStyle.backgroundMapBase.getTransparency() : 0;\n        vp.displayStyle.backgroundMapBase = color.withTransparency(curTransparency);\n        vp.invalidateRenderPlan();\n        return true;\n    }\n    /** Executes this tool's run method with args[0] containing a 0 to 255 red component, args[1] containing a 0 to 255 green component, and args[2] containing a 0 to 255 blue component.\n     * These rgb values will be used to construct the `color` parameter passed to this tool's run method.\n     * @see [[run]]\n     */\n    async parseAndRun(...args) {\n        const red = parseFloat(args[0]), green = parseFloat(args[1]), blue = parseFloat(args[2]);\n        return (isNaN(red) || red < 0 || red > 255 || isNaN(green) || green < 0 || green > 255 || isNaN(blue) || blue < 0 || blue > 255) ? false : this.run(ColorDef.from(red, green, blue));\n    }\n}\nMapBaseColorTool.toolId = \"SetMapBaseColorTool\";\nexport { MapBaseColorTool };\n/** This tool changes the transparency of the base map.\n * @beta\n */\nclass MapBaseTransparencyTool extends Tool {\n    static get minArgs() { return 1; }\n    static get maxArgs() { return 1; }\n    /** This method runs the tool, changing the transparency of the base map.\n     * @param transparency a numeric value in range 0.0 to 1.0 whether 0.0 means fully opaque and 1.0 means fully transparent\n     */\n    async run(transparency) {\n        const vp = IModelApp.viewManager.selectedView;\n        if (undefined === vp || !vp.view.isSpatialView())\n            return false;\n        vp.displayStyle.changeBaseMapTransparency(transparency);\n        vp.invalidateRenderPlan();\n        return true;\n    }\n    /** Executes this tool's run method with args[0] containing `transparency`.\n     * @see [[run]]\n     */\n    async parseAndRun(...args) {\n        const transparency = parseFloat(args[0]);\n        return (isNaN(transparency) || transparency < 0 || transparency > 1) ? false : this.run(transparency);\n    }\n}\nMapBaseTransparencyTool.toolId = \"SetMapBaseTransparencyTool\";\nexport { MapBaseTransparencyTool };\n/** This tool changes the visibility of the base map.\n * @beta\n */\nclass MapBaseVisibilityTool extends Tool {\n    static get minArgs() { return 1; }\n    static get maxArgs() { return 1; }\n    /** This method runs the tool, changing the visibility of the base map.\n     * @param visible a boolean which specifies whether or not to make the base map visible\n     */\n    async run(visible) {\n        const vp = IModelApp.viewManager.selectedView;\n        if (undefined === vp || !vp.view.isSpatialView() || vp.displayStyle.backgroundMapBase instanceof ColorDef)\n            return false;\n        vp.displayStyle.backgroundMapBase = vp.displayStyle.backgroundMapBase.clone({ visible });\n        vp.invalidateRenderPlan();\n        return true;\n    }\n    /** Executes this tool's run method with args[0] containing `visible`.\n     * @see [[run]]\n     */\n    async parseAndRun(...args) {\n        const visible = parseBoolean(args[0]);\n        return (visible !== undefined ? this.run(visible) : false);\n    }\n}\nMapBaseVisibilityTool.toolId = \"SetMapBaseVisibilityTool\";\nexport { MapBaseVisibilityTool };\n//# sourceMappingURL=MapLayerTool.js.map",
      "start": 1693508122651,
      "end": 1693508122754,
      "sourcemaps": null
    }
  ]
}
