{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/solid/SweepContour.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Solid\n */\nimport { ClipPlane } from \"../clipping/ClipPlane\";\nimport { ConvexClipPlaneSet } from \"../clipping/ConvexClipPlaneSet\";\nimport { UnionOfConvexClipPlaneSets } from \"../clipping/UnionOfConvexClipPlaneSets\";\nimport { CurvePrimitive } from \"../curve/CurvePrimitive\";\nimport { LineString3d } from \"../curve/LineString3d\";\nimport { Loop } from \"../curve/Loop\";\nimport { ParityRegion } from \"../curve/ParityRegion\";\nimport { Path } from \"../curve/Path\";\nimport { RegionOps } from \"../curve/RegionOps\";\nimport { FrameBuilder } from \"../geometry3d/FrameBuilder\";\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\nimport { PolygonOps } from \"../geometry3d/PolygonOps\";\nimport { PolyfaceBuilder } from \"../polyface/PolyfaceBuilder\";\nimport { HalfEdgeGraphSearch } from \"../topology/HalfEdgeGraphSearch\";\nimport { Triangulator } from \"../topology/Triangulation\";\n/**\n * Sweepable contour with Transform for local to world interaction.\n * * The surface/solid classes `LinearSweep`, `RotationalSweep`, `RuledSweep` use this for their swept contours.\n * @public\n */\nexport class SweepContour {\n    constructor(contour, map, axis) {\n        if (contour instanceof CurvePrimitive) {\n            // this.curves is a CurveCollection (not AnyCurve) so that contour type determines closure.\n            // This is the only time we detect CurvePrimitive closure and wrap as a relevant CurveChain.\n            const primitive = contour;\n            contour = contour.startPoint().isAlmostEqual(contour.endPoint()) ? new Loop() : new Path();\n            contour.tryAddChild(primitive);\n        }\n        this.curves = contour;\n        this.localToWorld = map;\n        this.axis = axis;\n    }\n    /** Create for linear sweep.\n     * * The optional default normal may be useful for guiding coordinate frame setup.\n     * * the contour is CAPTURED.\n     */\n    static createForLinearSweep(contour, defaultNormal) {\n        const localToWorld = FrameBuilder.createRightHandedFrame(defaultNormal, contour);\n        if (localToWorld) {\n            return new SweepContour(contour, localToWorld, undefined);\n        }\n        return undefined;\n    }\n    /** Create for linear sweep.\n     * * The optional default normal may be useful for guiding coordinate frame setup.\n     * * the points are captured into linestrings and Loops as needed.\n     */\n    static createForPolygon(points, defaultNormal) {\n        const localToWorld = FrameBuilder.createRightHandedFrame(defaultNormal, points);\n        if (localToWorld) {\n            if (defaultNormal !== undefined) {\n                if (localToWorld.matrix.dotColumnZ(defaultNormal))\n                    localToWorld.matrix.scaleColumnsInPlace(1.0, -1.0, -1.0);\n            }\n            const linestrings = LineString3d.createArrayOfLineString3d(points);\n            const loops = [];\n            for (const ls of linestrings) {\n                ls.addClosurePoint();\n                loops.push(Loop.create(ls));\n            }\n            if (loops.length === 1) {\n                return new SweepContour(loops[0], localToWorld, undefined);\n            }\n            else if (loops.length > 1) {\n                return new SweepContour(ParityRegion.createLoops(loops), localToWorld, undefined);\n            }\n        }\n        return undefined;\n    }\n    /** Create for rotational sweep.\n     * * The axis ray is retained.\n     * * the contour is CAPTURED.\n     */\n    static createForRotation(contour, axis) {\n        // createRightHandedFrame -- the axis is a last-gasp resolver for in-plane vectors.\n        const localToWorld = FrameBuilder.createRightHandedFrame(undefined, contour, axis);\n        if (localToWorld) {\n            return new SweepContour(contour, localToWorld, axis.clone());\n        }\n        return undefined;\n    }\n    /** Return (Reference to) the curves */\n    getCurves() { return this.curves; }\n    /** Apply `transform` to the curves, axis.\n     * * The local to world frame is reconstructed for the transformed curves.\n     */\n    tryTransformInPlace(transform) {\n        if (this.curves.tryTransformInPlace(transform)) {\n            if (this.axis)\n                this.axis.transformInPlace(transform);\n            const localToWorld = this.axis !== undefined\n                ? FrameBuilder.createRightHandedFrame(undefined, this.curves, this.axis)\n                : FrameBuilder.createRightHandedFrame(undefined, this.curves);\n            if (localToWorld) {\n                this.localToWorld.setFrom(localToWorld);\n                return true;\n            }\n        }\n        return false;\n    }\n    /** Return a deep clone. */\n    clone() {\n        return new SweepContour(this.curves.clone(), this.localToWorld.clone(), this.axis);\n    }\n    /** Return a transformed clone. */\n    cloneTransformed(transform) {\n        const newContour = this.clone();\n        if (newContour.tryTransformInPlace(transform))\n            return newContour;\n        return undefined;\n    }\n    /** Test for near equality of cures and local frame. */\n    isAlmostEqual(other) {\n        if (other instanceof SweepContour) {\n            return this.curves.isAlmostEqual(other.curves) && this.localToWorld.isAlmostEqual(other.localToWorld);\n        }\n        return false;\n    }\n    get xyStrokes() { return this._xyStrokes; }\n    /**\n     * build the (cached) internal facets.\n     * @param options options for stroking the curves.\n     */\n    buildFacets(options) {\n        if (!this._facets) {\n            if (this.curves instanceof Loop) {\n                this._xyStrokes = this.curves.cloneStroked(options);\n                if (this._xyStrokes instanceof Loop && this._xyStrokes.children.length === 1) {\n                    const children = this._xyStrokes.children;\n                    const linestring = children[0];\n                    const points = linestring.points;\n                    this.localToWorld.multiplyInversePoint3dArrayInPlace(points);\n                    if (PolygonOps.sumTriangleAreasXY(points) < 0)\n                        points.reverse();\n                    const graph = Triangulator.createTriangulatedGraphFromSingleLoop(points);\n                    if (graph) {\n                        Triangulator.flipTriangles(graph);\n                        const unflippedPoly = PolyfaceBuilder.graphToPolyface(graph, options);\n                        this._facets = unflippedPoly;\n                        this._facets.tryTransformInPlace(this.localToWorld);\n                    }\n                    else { // earcut failed (e.g., on a split washer polygon, where the bridge edge is traversed twice)\n                        const polyface = RegionOps.polygonXYAreaUnionLoopsToPolyface(points, [], true);\n                        if (polyface) {\n                            this._facets = polyface;\n                            this._facets.tryTransformInPlace(this.localToWorld);\n                        }\n                    }\n                }\n            }\n            else if (this.curves instanceof ParityRegion) {\n                this._xyStrokes = this.curves.cloneStroked(options);\n                if (this._xyStrokes instanceof (ParityRegion)) {\n                    const worldToLocal = this.localToWorld.inverse();\n                    this._xyStrokes.tryTransformInPlace(worldToLocal);\n                    const strokes = [];\n                    for (const childLoop of this._xyStrokes.children) {\n                        const loopCurves = childLoop.children;\n                        if (loopCurves.length === 1) {\n                            const c = loopCurves[0];\n                            if (c instanceof LineString3d)\n                                strokes.push(c.packedPoints);\n                        }\n                    }\n                    const numLoops = strokes.length;\n                    /** Try the earcut algorithm first -- lots less machinery, but can't handle any form of overlap */\n                    const graph = Triangulator.createTriangulatedGraphFromLoops(strokes);\n                    if (graph && HalfEdgeGraphSearch.isTriangulatedCCW(graph, true, numLoops - 1)) {\n                        Triangulator.flipTriangles(graph);\n                        const unflippedPoly = PolyfaceBuilder.graphToPolyface(graph, options);\n                        this._facets = unflippedPoly;\n                        this._facets.tryTransformInPlace(this.localToWorld);\n                    }\n                    else {\n                        // earcut failed. Restart with full merge and parity analysis.\n                        const polyface = RegionOps.polygonXYAreaUnionLoopsToPolyface(strokes, [], true);\n                        if (polyface) {\n                            this._facets = polyface;\n                            this._facets.tryTransformInPlace(this.localToWorld);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    /** delete existing facets.\n     * * This protects against PolyfaceBuilder reusing facets constructed with different options settings.\n     */\n    purgeFacets() {\n        this._facets = undefined;\n    }\n    /** Emit facets to a builder.\n     * This method may cache and reuse facets over multiple calls.\n     */\n    emitFacets(builder, reverse, transform) {\n        this.buildFacets(builder.options);\n        if (this._facets)\n            builder.addIndexedPolyface(this._facets, reverse, transform);\n    }\n    /** Emit facets to a function\n     * This method may cache and reuse facets over multiple calls.\n     */\n    announceFacets(announce, options) {\n        this.buildFacets(options);\n        if (this._facets)\n            announce(this._facets);\n    }\n    /**\n     * Triangulate the region.\n     * Create a UnionOfConvexClipPlaneSets that clips to the swept region.\n     * * If sweepVector is not given, the sweep direction is perpendicular to the plane of the contour.\n     * * If sweepVector is given, it is the sweep direction and does not have to be perpendicular to the contour.\n     * * cap0 and cap1 indicate construction of clip planes parallel to the contour plane.\n     * * If cap1 is true, the cap plane is at `anyPointOnPlane + sweepVector`.  That is, the sweep vector indicates both direction and distance.\n     * * caps are NOT created of sweepVector is not given.\n     */\n    sweepToUnionOfConvexClipPlaneSets(sweepVector, cap0 = false, cap1 = false) {\n        const builder = PolyfaceBuilder.create();\n        // It's a trip around the barn, but it's easy to make a polyface and scan it . . .\n        if (!sweepVector)\n            cap0 = cap1 = false;\n        this.buildFacets(builder.options);\n        if (sweepVector === undefined)\n            sweepVector = this.localToWorld.matrix.columnZ();\n        const zVector = this.localToWorld.matrix.columnZ();\n        const facets = this._facets;\n        const point0 = Point3d.create();\n        const point1 = Point3d.create();\n        if (facets) {\n            const plane0Origin = this.localToWorld.getOrigin();\n            const plane1Origin = plane0Origin.plus(sweepVector);\n            const inwardNormal0 = zVector.clone();\n            const inwardNormal1 = zVector.negate();\n            const result = UnionOfConvexClipPlaneSets.createEmpty();\n            const visitor = facets.createVisitor(1);\n            for (visitor.reset(); visitor.moveToNextFacet();) {\n                const numEdges = visitor.point.length - 1;\n                const clipper = ConvexClipPlaneSet.createEmpty();\n                for (let i = 0; i < numEdges; i++) {\n                    visitor.point.getPoint3dAtUncheckedPointIndex(i, point0);\n                    visitor.point.getPoint3dAtUncheckedPointIndex(i + 1, point1);\n                    const plane = ClipPlane.createEdgeAndUpVector(point1, point0, sweepVector);\n                    const visible = visitor.edgeVisible[i];\n                    plane?.setFlags(!visible, !visible);\n                    clipper.addPlaneToConvexSet(plane);\n                }\n                if (cap0)\n                    clipper.addPlaneToConvexSet(ClipPlane.createNormalAndPoint(inwardNormal0, plane0Origin));\n                if (cap1)\n                    clipper.addPlaneToConvexSet(ClipPlane.createNormalAndPoint(inwardNormal1, plane1Origin));\n                result.addConvexSet(clipper);\n            }\n            return result;\n        }\n        return undefined;\n    }\n}\n//# sourceMappingURL=SweepContour.js.map",
      "start": 1693508123806,
      "end": 1693508123928,
      "sourcemaps": null
    }
  ]
}
