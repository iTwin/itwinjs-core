{
  "resolvedId": "D:/hub2023A/itwinjs-core/test-apps/display-test-app/src/frontend/AnalysisStyleExample.ts",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\r\n* See LICENSE.md in the project root for license terms and full copyright notice.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\nimport { assert } from \"@itwin/core-bentley\";\r\nimport { Angle, AuxChannel, AuxChannelData, AuxChannelDataType, IModelJson, Point3d, Polyface, PolyfaceAuxData, PolyfaceBuilder, StrokeOptions, Transform } from \"@itwin/core-geometry\";\r\nimport {\r\n  AnalysisStyle, AnalysisStyleProps, ColorByName, ColorDef, RenderMode, SkyBox, ThematicGradientColorScheme, ThematicGradientMode, ThematicGradientSettingsProps,\r\n} from \"@itwin/core-common\";\r\nimport {\r\n  DecorateContext, GraphicType, IModelApp, RenderGraphicOwner, StandardViewId, Viewport,\r\n} from \"@itwin/core-frontend\";\r\nimport { Viewer } from \"./Viewer\";\r\n\r\ntype AnalysisMeshType = \"Cantilever\" | \"Flat with waves\";\r\n\r\ninterface AnalysisMesh {\r\n  readonly type: AnalysisMeshType;\r\n  readonly polyface: Polyface;\r\n  readonly styles: Map<string, AnalysisStyle | undefined>;\r\n}\r\n\r\nfunction populateAnalysisStyles(mesh: AnalysisMesh, displacementScale: number): void {\r\n  const auxdata = mesh.polyface.data.auxData;\r\n  if (!auxdata)\r\n    return;\r\n\r\n  mesh.styles.set(\"None\", undefined);\r\n  for (const channel of auxdata.channels) {\r\n    if (undefined === channel.name || !channel.isScalar)\r\n      continue;\r\n\r\n    const displacementChannel = auxdata.channels.find((x) => x.inputName === channel.inputName && x.dataType === AuxChannelDataType.Vector);\r\n    const thematicSettings: ThematicGradientSettingsProps = {};\r\n    if (channel.name.endsWith(\"Height\")) {\r\n      thematicSettings.colorScheme = ThematicGradientColorScheme.SeaMountain;\r\n      thematicSettings.mode = ThematicGradientMode.SteppedWithDelimiter;\r\n    }\r\n\r\n    assert(undefined !== channel.scalarRange);\r\n    const props: AnalysisStyleProps = {\r\n      scalar: {\r\n        channelName: channel.name,\r\n        range: channel.scalarRange,\r\n        thematicSettings,\r\n      },\r\n    };\r\n\r\n    let name = channel.name;\r\n    if (undefined !== displacementChannel?.name) {\r\n      props.displacement = { channelName: displacementChannel.name, scale: displacementScale };\r\n      const exaggeration = 1 !== displacementScale ? \"\" : ` X ${displacementScale}`;\r\n      name = `${name} and ${displacementChannel.name}${exaggeration}`;\r\n    }\r\n\r\n    mesh.styles.set(name, AnalysisStyle.fromJSON(props));\r\n  }\r\n}\r\n\r\nasync function createCantilever(): Promise<Polyface> {\r\n  const { cantileverJsonString } = await import(\"./Cantilever\");\r\n  const polyface = IModelJson.Reader.parse(\r\n    JSON.parse(cantileverJsonString),\r\n  ) as Polyface;\r\n  assert(polyface instanceof Polyface);\r\n\r\n  const transform = Transform.createScaleAboutPoint(new Point3d(), 30);\r\n  polyface.tryTransformInPlace(transform);\r\n\r\n  return polyface;\r\n}\r\n\r\n/** Demonstrate the addition of analytical data to a polyface.\r\n * This is a purely fictional example intended to demonstrate concepts of [[PolyfaceAuxData]] concepts only.\r\n * Create a polyface representing a flat mesh with superimposed waves and associated [[PolyfaceAuxData]]  to display displacement, height and slope data.\r\n * A vector [[AuxChannel]] is created to represent displacement and two scalar [[AuxChannel]] are created to represent height and slope.\r\n * Note that data between inputs are interpolated so motion will still remain relatively smooth even with only three inputs in the radial waves.\r\n */\r\nfunction createFlatMeshWithWaves(): Polyface {\r\n  const options = StrokeOptions.createForFacets();\r\n  options.shouldTriangulate = true;\r\n  const builder = PolyfaceBuilder.create(options);\r\n  const nDimensions = 100;\r\n  const spacing = 1.0;\r\n\r\n  /* Create a simple flat mesh with 10,000 points (100x100) */\r\n  for (let iRow = 0; iRow < nDimensions - 1; iRow++) {\r\n    for (let iColumn = 0; iColumn < nDimensions - 1; iColumn++) {\r\n      const quad = [\r\n        Point3d.create(iRow * spacing, iColumn * spacing, 0.0),\r\n        Point3d.create((iRow + 1) * spacing, iColumn * spacing, 0.0),\r\n        Point3d.create((iRow + 1) * spacing, (iColumn + 1) * spacing, 0.0),\r\n        Point3d.create(iRow * spacing, (iColumn + 1) * spacing),\r\n      ];\r\n      builder.addQuadFacet(quad);\r\n    }\r\n  }\r\n\r\n  const polyface = builder.claimPolyface();\r\n  const zeroScalarData = [], zeroDisplacementData = [], radialHeightData = [], radialSlopeData = [], radialDisplacementData = [];\r\n  const radius = nDimensions * spacing / 2.0;\r\n  const center = new Point3d(radius, radius, 0.0);\r\n  const maxHeight = radius / 4.0;\r\n  const auxChannels = [];\r\n\r\n  /** Create a radial wave - start and return to zero  */\r\n  for (let i = 0; i < polyface.data.point.length; i++) {\r\n    const angle = Angle.pi2Radians * polyface.data.point.distanceIndexToPoint(i, center)! / radius;\r\n    const height = maxHeight * Math.sin(angle);\r\n    const slope = Math.abs(Math.cos(angle));\r\n\r\n    zeroScalarData.push(0.0);\r\n    zeroDisplacementData.push(0.0);\r\n    zeroDisplacementData.push(0.0);\r\n    zeroDisplacementData.push(0.0);\r\n\r\n    radialHeightData.push(height);\r\n    radialSlopeData.push(slope);\r\n    radialDisplacementData.push(0.0);\r\n    radialDisplacementData.push(0.0);\r\n    radialDisplacementData.push(height);\r\n  }\r\n\r\n  // Static Channels.\r\n  auxChannels.push(new AuxChannel([new AuxChannelData(0.0, radialDisplacementData)], AuxChannelDataType.Vector, \"Static Radial Displacement\", \"Radial: Static\"));\r\n  auxChannels.push(new AuxChannel([new AuxChannelData(1.0, radialHeightData)], AuxChannelDataType.Distance, \"Static Radial Height\", \"Radial: Static\"));\r\n  auxChannels.push(new AuxChannel([new AuxChannelData(1.0, radialSlopeData)], AuxChannelDataType.Scalar, \"Static Radial Slope\", \"Radial: Static\"));\r\n\r\n  // Animated Channels.\r\n  const radialDisplacementDataVector = [new AuxChannelData(0.0, zeroDisplacementData), new AuxChannelData(1.0, radialDisplacementData), new AuxChannelData(2.0, zeroDisplacementData)];\r\n  const radialHeightDataVector = [new AuxChannelData(0.0, zeroScalarData), new AuxChannelData(1.0, radialHeightData), new AuxChannelData(2.0, zeroScalarData)];\r\n  const radialSlopeDataVector = [new AuxChannelData(0.0, zeroScalarData), new AuxChannelData(1.0, radialSlopeData), new AuxChannelData(2.0, zeroScalarData)];\r\n\r\n  auxChannels.push(new AuxChannel(radialDisplacementDataVector, AuxChannelDataType.Vector, \"Animated Radial Displacement\", \"Radial: Time\"));\r\n  auxChannels.push(new AuxChannel(radialHeightDataVector, AuxChannelDataType.Distance, \"Animated Radial Height\", \"Radial: Time\"));\r\n  auxChannels.push(new AuxChannel(radialSlopeDataVector, AuxChannelDataType.Scalar, \"Animated Radial Slope\", \"Radial: Time\"));\r\n\r\n  /** Create linear waves -- 10 separate frames.  */\r\n  const waveHeight = radius / 20.0;\r\n  const waveLength = radius / 2.0;\r\n  const frameCount = 10;\r\n  const linearDisplacementDataVector = [], linearHeightDataVector = [], linearSlopeDataVector = [];\r\n\r\n  for (let i = 0; i < frameCount; i++) {\r\n    const fraction = i / (frameCount - 1);\r\n    const waveCenter = waveLength * fraction;\r\n    const linearHeightData = [], linearSlopeData = [], linearDisplacementData = [];\r\n\r\n    for (let j = 0; j < polyface.data.point.length; j++) {\r\n      const point = polyface.data.point.getPoint3dAtUncheckedPointIndex(j);\r\n      const theta = Angle.pi2Radians * (point.x - waveCenter) / waveLength;\r\n      const height = waveHeight * Math.sin(theta);\r\n      const slope = Math.abs(Math.cos(theta));\r\n\r\n      linearHeightData.push(height);\r\n      linearSlopeData.push(slope);\r\n      linearDisplacementData.push(0.0);\r\n      linearDisplacementData.push(0.0);\r\n      linearDisplacementData.push(height);\r\n    }\r\n    linearDisplacementDataVector.push(new AuxChannelData(i, linearDisplacementData));\r\n    linearHeightDataVector.push(new AuxChannelData(i, linearHeightData));\r\n    linearSlopeDataVector.push(new AuxChannelData(i, linearSlopeData));\r\n  }\r\n  auxChannels.push(new AuxChannel(linearDisplacementDataVector, AuxChannelDataType.Vector, \"Linear Displacement\", \"Linear: Time\"));\r\n  auxChannels.push(new AuxChannel(linearHeightDataVector, AuxChannelDataType.Distance, \"Linear Height\", \"Linear: Time\"));\r\n  auxChannels.push(new AuxChannel(linearSlopeDataVector, AuxChannelDataType.Scalar, \"Linear Slope\", \"Linear: Time\"));\r\n\r\n  polyface.data.auxData = new PolyfaceAuxData(auxChannels, polyface.data.pointIndex);\r\n  return polyface;\r\n}\r\n\r\nasync function createMesh(type: AnalysisMeshType, displacementScale = 1): Promise<AnalysisMesh> {\r\n  const polyface = \"Flat with waves\" === type ? createFlatMeshWithWaves() : await createCantilever();\r\n  const styles = new Map<string, AnalysisStyle | undefined>();\r\n  const mesh = { type, polyface, styles };\r\n  populateAnalysisStyles(mesh, displacementScale);\r\n  return mesh;\r\n}\r\n\r\nclass AnalysisDecorator {\r\n  public readonly mesh: AnalysisMesh;\r\n  private readonly _viewport: Viewport;\r\n  private readonly _id: string;\r\n  private _graphic?: RenderGraphicOwner;\r\n  private _dispose?: () => void;\r\n\r\n  public constructor(viewport: Viewport, mesh: AnalysisMesh) {\r\n    this._viewport = viewport;\r\n    this.mesh = mesh;\r\n    this._id = viewport.iModel.transientIds.getNext();\r\n\r\n    const removeDisposalListener = viewport.onDisposed.addOnce(() => this.dispose());\r\n    const removeAnalysisStyleListener = viewport.addOnAnalysisStyleChangedListener(() => {\r\n      this._graphic?.disposeGraphic();\r\n      this._graphic = undefined;\r\n    });\r\n\r\n    this._dispose = () => {\r\n      removeAnalysisStyleListener();\r\n      removeDisposalListener();\r\n    };\r\n\r\n    IModelApp.viewManager.addDecorator(this);\r\n  }\r\n\r\n  public dispose(): void {\r\n    if (!this._dispose) {\r\n      assert(undefined === this._graphic);\r\n      return;\r\n    }\r\n\r\n    this._graphic?.disposeGraphic();\r\n    this._graphic = undefined;\r\n    this._dispose();\r\n    this._dispose = undefined;\r\n    IModelApp.viewManager.dropDecorator(this);\r\n  }\r\n\r\n  public decorate(context: DecorateContext): void {\r\n    if (context.viewport !== this._viewport)\r\n      return;\r\n\r\n    if (!this._graphic) {\r\n      const builder = context.createGraphicBuilder(GraphicType.Scene, undefined, this._id);\r\n      const color = ColorDef.fromTbgr(ColorByName.darkSlateBlue);\r\n      builder.setSymbology(color, color, 1);\r\n      builder.addPolyface(this.mesh.polyface, false);\r\n      this._graphic = IModelApp.renderSystem.createGraphicOwner(builder.finish());\r\n    }\r\n\r\n    context.addDecoration(GraphicType.Scene, this._graphic);\r\n  }\r\n}\r\n\r\nexport async function openAnalysisStyleExample(viewer: Viewer): Promise<void> {\r\n  const meshes = await Promise.all([createMesh(\"Cantilever\", 100), createMesh(\"Flat with waves\")]);\r\n  let decorator = new AnalysisDecorator(viewer.viewport, meshes[0]);\r\n\r\n  const meshPicker = document.createElement(\"select\");\r\n  meshPicker.className = \"viewList\";\r\n  viewer.toolBar.element.appendChild(meshPicker);\r\n  for (const mesh of meshes) {\r\n    const option = document.createElement(\"option\");\r\n    option.innerText = mesh.type;\r\n    option.value = mesh.type;\r\n    meshPicker.appendChild(option);\r\n  }\r\n\r\n  meshPicker.selectedIndex = 0;\r\n  meshPicker.onchange = () => {\r\n    const type = meshPicker.value as AnalysisMeshType;\r\n    if (type !== decorator.mesh.type) {\r\n      decorator.dispose();\r\n      decorator = new AnalysisDecorator(viewer.viewport, meshes[meshPicker.selectedIndex]);\r\n      populateStylePicker();\r\n    }\r\n  };\r\n\r\n  const stylePicker = document.createElement(\"select\");\r\n  stylePicker.className = \"viewList\";\r\n  viewer.toolBar.element.appendChild(stylePicker);\r\n  stylePicker.onchange = () => {\r\n    viewer.viewport.displayStyle.settings.analysisStyle = decorator.mesh.styles.get(stylePicker.value);\r\n  };\r\n\r\n  function populateStylePicker(): void {\r\n    while (stylePicker.firstChild)\r\n      stylePicker.removeChild(stylePicker.firstChild);\r\n\r\n    for (const name of decorator.mesh.styles.keys()) {\r\n      const option = document.createElement(\"option\");\r\n      option.innerText = option.value = name;\r\n      stylePicker.appendChild(option);\r\n    }\r\n\r\n    viewer.viewport.displayStyle.settings.analysisStyle = undefined;\r\n  }\r\n\r\n  populateStylePicker();\r\n\r\n  assert(viewer.viewport.view.is3d());\r\n  viewer.viewport.setStandardRotation(StandardViewId.Iso);\r\n  viewer.viewport.zoomToVolume(viewer.viewport.iModel.projectExtents);\r\n\r\n  viewer.viewport.viewFlags = viewer.viewport.viewFlags.withRenderMode(RenderMode.SolidFill);\r\n\r\n  const settings = viewer.viewport.view.getDisplayStyle3d().settings;\r\n  settings.environment = settings.environment.clone({\r\n    displaySky: true,\r\n    sky: SkyBox.fromJSON({ twoColor: true, nadirColor: 0xdfefff, zenithColor: 0xffefdf }),\r\n  });\r\n}\r\n",
      "start": 1693508121256,
      "end": 1693508121434,
      "sourcemaps": null
    },
    {
      "name": "vite:esbuild",
      "result": "\"use strict\";\nimport { assert } from \"@itwin/core-bentley\";\nimport { Angle, AuxChannel, AuxChannelData, AuxChannelDataType, IModelJson, Point3d, Polyface, PolyfaceAuxData, PolyfaceBuilder, StrokeOptions, Transform } from \"@itwin/core-geometry\";\nimport {\n  AnalysisStyle,\n  ColorByName,\n  ColorDef,\n  RenderMode,\n  SkyBox,\n  ThematicGradientColorScheme,\n  ThematicGradientMode\n} from \"@itwin/core-common\";\nimport {\n  GraphicType,\n  IModelApp,\n  StandardViewId\n} from \"@itwin/core-frontend\";\nfunction populateAnalysisStyles(mesh, displacementScale) {\n  const auxdata = mesh.polyface.data.auxData;\n  if (!auxdata)\n    return;\n  mesh.styles.set(\"None\", void 0);\n  for (const channel of auxdata.channels) {\n    if (void 0 === channel.name || !channel.isScalar)\n      continue;\n    const displacementChannel = auxdata.channels.find((x) => x.inputName === channel.inputName && x.dataType === AuxChannelDataType.Vector);\n    const thematicSettings = {};\n    if (channel.name.endsWith(\"Height\")) {\n      thematicSettings.colorScheme = ThematicGradientColorScheme.SeaMountain;\n      thematicSettings.mode = ThematicGradientMode.SteppedWithDelimiter;\n    }\n    assert(void 0 !== channel.scalarRange);\n    const props = {\n      scalar: {\n        channelName: channel.name,\n        range: channel.scalarRange,\n        thematicSettings\n      }\n    };\n    let name = channel.name;\n    if (void 0 !== displacementChannel?.name) {\n      props.displacement = { channelName: displacementChannel.name, scale: displacementScale };\n      const exaggeration = 1 !== displacementScale ? \"\" : ` X ${displacementScale}`;\n      name = `${name} and ${displacementChannel.name}${exaggeration}`;\n    }\n    mesh.styles.set(name, AnalysisStyle.fromJSON(props));\n  }\n}\nasync function createCantilever() {\n  const { cantileverJsonString } = await import(\"./Cantilever\");\n  const polyface = IModelJson.Reader.parse(\n    JSON.parse(cantileverJsonString)\n  );\n  assert(polyface instanceof Polyface);\n  const transform = Transform.createScaleAboutPoint(new Point3d(), 30);\n  polyface.tryTransformInPlace(transform);\n  return polyface;\n}\nfunction createFlatMeshWithWaves() {\n  const options = StrokeOptions.createForFacets();\n  options.shouldTriangulate = true;\n  const builder = PolyfaceBuilder.create(options);\n  const nDimensions = 100;\n  const spacing = 1;\n  for (let iRow = 0; iRow < nDimensions - 1; iRow++) {\n    for (let iColumn = 0; iColumn < nDimensions - 1; iColumn++) {\n      const quad = [\n        Point3d.create(iRow * spacing, iColumn * spacing, 0),\n        Point3d.create((iRow + 1) * spacing, iColumn * spacing, 0),\n        Point3d.create((iRow + 1) * spacing, (iColumn + 1) * spacing, 0),\n        Point3d.create(iRow * spacing, (iColumn + 1) * spacing)\n      ];\n      builder.addQuadFacet(quad);\n    }\n  }\n  const polyface = builder.claimPolyface();\n  const zeroScalarData = [], zeroDisplacementData = [], radialHeightData = [], radialSlopeData = [], radialDisplacementData = [];\n  const radius = nDimensions * spacing / 2;\n  const center = new Point3d(radius, radius, 0);\n  const maxHeight = radius / 4;\n  const auxChannels = [];\n  for (let i = 0; i < polyface.data.point.length; i++) {\n    const angle = Angle.pi2Radians * polyface.data.point.distanceIndexToPoint(i, center) / radius;\n    const height = maxHeight * Math.sin(angle);\n    const slope = Math.abs(Math.cos(angle));\n    zeroScalarData.push(0);\n    zeroDisplacementData.push(0);\n    zeroDisplacementData.push(0);\n    zeroDisplacementData.push(0);\n    radialHeightData.push(height);\n    radialSlopeData.push(slope);\n    radialDisplacementData.push(0);\n    radialDisplacementData.push(0);\n    radialDisplacementData.push(height);\n  }\n  auxChannels.push(new AuxChannel([new AuxChannelData(0, radialDisplacementData)], AuxChannelDataType.Vector, \"Static Radial Displacement\", \"Radial: Static\"));\n  auxChannels.push(new AuxChannel([new AuxChannelData(1, radialHeightData)], AuxChannelDataType.Distance, \"Static Radial Height\", \"Radial: Static\"));\n  auxChannels.push(new AuxChannel([new AuxChannelData(1, radialSlopeData)], AuxChannelDataType.Scalar, \"Static Radial Slope\", \"Radial: Static\"));\n  const radialDisplacementDataVector = [new AuxChannelData(0, zeroDisplacementData), new AuxChannelData(1, radialDisplacementData), new AuxChannelData(2, zeroDisplacementData)];\n  const radialHeightDataVector = [new AuxChannelData(0, zeroScalarData), new AuxChannelData(1, radialHeightData), new AuxChannelData(2, zeroScalarData)];\n  const radialSlopeDataVector = [new AuxChannelData(0, zeroScalarData), new AuxChannelData(1, radialSlopeData), new AuxChannelData(2, zeroScalarData)];\n  auxChannels.push(new AuxChannel(radialDisplacementDataVector, AuxChannelDataType.Vector, \"Animated Radial Displacement\", \"Radial: Time\"));\n  auxChannels.push(new AuxChannel(radialHeightDataVector, AuxChannelDataType.Distance, \"Animated Radial Height\", \"Radial: Time\"));\n  auxChannels.push(new AuxChannel(radialSlopeDataVector, AuxChannelDataType.Scalar, \"Animated Radial Slope\", \"Radial: Time\"));\n  const waveHeight = radius / 20;\n  const waveLength = radius / 2;\n  const frameCount = 10;\n  const linearDisplacementDataVector = [], linearHeightDataVector = [], linearSlopeDataVector = [];\n  for (let i = 0; i < frameCount; i++) {\n    const fraction = i / (frameCount - 1);\n    const waveCenter = waveLength * fraction;\n    const linearHeightData = [], linearSlopeData = [], linearDisplacementData = [];\n    for (let j = 0; j < polyface.data.point.length; j++) {\n      const point = polyface.data.point.getPoint3dAtUncheckedPointIndex(j);\n      const theta = Angle.pi2Radians * (point.x - waveCenter) / waveLength;\n      const height = waveHeight * Math.sin(theta);\n      const slope = Math.abs(Math.cos(theta));\n      linearHeightData.push(height);\n      linearSlopeData.push(slope);\n      linearDisplacementData.push(0);\n      linearDisplacementData.push(0);\n      linearDisplacementData.push(height);\n    }\n    linearDisplacementDataVector.push(new AuxChannelData(i, linearDisplacementData));\n    linearHeightDataVector.push(new AuxChannelData(i, linearHeightData));\n    linearSlopeDataVector.push(new AuxChannelData(i, linearSlopeData));\n  }\n  auxChannels.push(new AuxChannel(linearDisplacementDataVector, AuxChannelDataType.Vector, \"Linear Displacement\", \"Linear: Time\"));\n  auxChannels.push(new AuxChannel(linearHeightDataVector, AuxChannelDataType.Distance, \"Linear Height\", \"Linear: Time\"));\n  auxChannels.push(new AuxChannel(linearSlopeDataVector, AuxChannelDataType.Scalar, \"Linear Slope\", \"Linear: Time\"));\n  polyface.data.auxData = new PolyfaceAuxData(auxChannels, polyface.data.pointIndex);\n  return polyface;\n}\nasync function createMesh(type, displacementScale = 1) {\n  const polyface = \"Flat with waves\" === type ? createFlatMeshWithWaves() : await createCantilever();\n  const styles = /* @__PURE__ */ new Map();\n  const mesh = { type, polyface, styles };\n  populateAnalysisStyles(mesh, displacementScale);\n  return mesh;\n}\nclass AnalysisDecorator {\n  constructor(viewport, mesh) {\n    this._viewport = viewport;\n    this.mesh = mesh;\n    this._id = viewport.iModel.transientIds.getNext();\n    const removeDisposalListener = viewport.onDisposed.addOnce(() => this.dispose());\n    const removeAnalysisStyleListener = viewport.addOnAnalysisStyleChangedListener(() => {\n      this._graphic?.disposeGraphic();\n      this._graphic = void 0;\n    });\n    this._dispose = () => {\n      removeAnalysisStyleListener();\n      removeDisposalListener();\n    };\n    IModelApp.viewManager.addDecorator(this);\n  }\n  dispose() {\n    if (!this._dispose) {\n      assert(void 0 === this._graphic);\n      return;\n    }\n    this._graphic?.disposeGraphic();\n    this._graphic = void 0;\n    this._dispose();\n    this._dispose = void 0;\n    IModelApp.viewManager.dropDecorator(this);\n  }\n  decorate(context) {\n    if (context.viewport !== this._viewport)\n      return;\n    if (!this._graphic) {\n      const builder = context.createGraphicBuilder(GraphicType.Scene, void 0, this._id);\n      const color = ColorDef.fromTbgr(ColorByName.darkSlateBlue);\n      builder.setSymbology(color, color, 1);\n      builder.addPolyface(this.mesh.polyface, false);\n      this._graphic = IModelApp.renderSystem.createGraphicOwner(builder.finish());\n    }\n    context.addDecoration(GraphicType.Scene, this._graphic);\n  }\n}\nexport async function openAnalysisStyleExample(viewer) {\n  const meshes = await Promise.all([createMesh(\"Cantilever\", 100), createMesh(\"Flat with waves\")]);\n  let decorator = new AnalysisDecorator(viewer.viewport, meshes[0]);\n  const meshPicker = document.createElement(\"select\");\n  meshPicker.className = \"viewList\";\n  viewer.toolBar.element.appendChild(meshPicker);\n  for (const mesh of meshes) {\n    const option = document.createElement(\"option\");\n    option.innerText = mesh.type;\n    option.value = mesh.type;\n    meshPicker.appendChild(option);\n  }\n  meshPicker.selectedIndex = 0;\n  meshPicker.onchange = () => {\n    const type = meshPicker.value;\n    if (type !== decorator.mesh.type) {\n      decorator.dispose();\n      decorator = new AnalysisDecorator(viewer.viewport, meshes[meshPicker.selectedIndex]);\n      populateStylePicker();\n    }\n  };\n  const stylePicker = document.createElement(\"select\");\n  stylePicker.className = \"viewList\";\n  viewer.toolBar.element.appendChild(stylePicker);\n  stylePicker.onchange = () => {\n    viewer.viewport.displayStyle.settings.analysisStyle = decorator.mesh.styles.get(stylePicker.value);\n  };\n  function populateStylePicker() {\n    while (stylePicker.firstChild)\n      stylePicker.removeChild(stylePicker.firstChild);\n    for (const name of decorator.mesh.styles.keys()) {\n      const option = document.createElement(\"option\");\n      option.innerText = option.value = name;\n      stylePicker.appendChild(option);\n    }\n    viewer.viewport.displayStyle.settings.analysisStyle = void 0;\n  }\n  populateStylePicker();\n  assert(viewer.viewport.view.is3d());\n  viewer.viewport.setStandardRotation(StandardViewId.Iso);\n  viewer.viewport.zoomToVolume(viewer.viewport.iModel.projectExtents);\n  viewer.viewport.viewFlags = viewer.viewport.viewFlags.withRenderMode(RenderMode.SolidFill);\n  const settings = viewer.viewport.view.getDisplayStyle3d().settings;\n  settings.environment = settings.environment.clone({\n    displaySky: true,\n    sky: SkyBox.fromJSON({ twoColor: true, nadirColor: 14675967, zenithColor: 16773087 })\n  });\n}\n",
      "start": 1693508121435,
      "end": 1693508121720,
      "order": "normal",
      "sourcemaps": {
        "version": 3,
        "sources": [
          "D:/hub2023A/itwinjs-core/test-apps/display-test-app/src/frontend/AnalysisStyleExample.ts"
        ],
        "sourcesContent": [
          "/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\r\n* See LICENSE.md in the project root for license terms and full copyright notice.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\nimport { assert } from \"@itwin/core-bentley\";\r\nimport { Angle, AuxChannel, AuxChannelData, AuxChannelDataType, IModelJson, Point3d, Polyface, PolyfaceAuxData, PolyfaceBuilder, StrokeOptions, Transform } from \"@itwin/core-geometry\";\r\nimport {\r\n  AnalysisStyle, AnalysisStyleProps, ColorByName, ColorDef, RenderMode, SkyBox, ThematicGradientColorScheme, ThematicGradientMode, ThematicGradientSettingsProps,\r\n} from \"@itwin/core-common\";\r\nimport {\r\n  DecorateContext, GraphicType, IModelApp, RenderGraphicOwner, StandardViewId, Viewport,\r\n} from \"@itwin/core-frontend\";\r\nimport { Viewer } from \"./Viewer\";\r\n\r\ntype AnalysisMeshType = \"Cantilever\" | \"Flat with waves\";\r\n\r\ninterface AnalysisMesh {\r\n  readonly type: AnalysisMeshType;\r\n  readonly polyface: Polyface;\r\n  readonly styles: Map<string, AnalysisStyle | undefined>;\r\n}\r\n\r\nfunction populateAnalysisStyles(mesh: AnalysisMesh, displacementScale: number): void {\r\n  const auxdata = mesh.polyface.data.auxData;\r\n  if (!auxdata)\r\n    return;\r\n\r\n  mesh.styles.set(\"None\", undefined);\r\n  for (const channel of auxdata.channels) {\r\n    if (undefined === channel.name || !channel.isScalar)\r\n      continue;\r\n\r\n    const displacementChannel = auxdata.channels.find((x) => x.inputName === channel.inputName && x.dataType === AuxChannelDataType.Vector);\r\n    const thematicSettings: ThematicGradientSettingsProps = {};\r\n    if (channel.name.endsWith(\"Height\")) {\r\n      thematicSettings.colorScheme = ThematicGradientColorScheme.SeaMountain;\r\n      thematicSettings.mode = ThematicGradientMode.SteppedWithDelimiter;\r\n    }\r\n\r\n    assert(undefined !== channel.scalarRange);\r\n    const props: AnalysisStyleProps = {\r\n      scalar: {\r\n        channelName: channel.name,\r\n        range: channel.scalarRange,\r\n        thematicSettings,\r\n      },\r\n    };\r\n\r\n    let name = channel.name;\r\n    if (undefined !== displacementChannel?.name) {\r\n      props.displacement = { channelName: displacementChannel.name, scale: displacementScale };\r\n      const exaggeration = 1 !== displacementScale ? \"\" : ` X ${displacementScale}`;\r\n      name = `${name} and ${displacementChannel.name}${exaggeration}`;\r\n    }\r\n\r\n    mesh.styles.set(name, AnalysisStyle.fromJSON(props));\r\n  }\r\n}\r\n\r\nasync function createCantilever(): Promise<Polyface> {\r\n  const { cantileverJsonString } = await import(\"./Cantilever\");\r\n  const polyface = IModelJson.Reader.parse(\r\n    JSON.parse(cantileverJsonString),\r\n  ) as Polyface;\r\n  assert(polyface instanceof Polyface);\r\n\r\n  const transform = Transform.createScaleAboutPoint(new Point3d(), 30);\r\n  polyface.tryTransformInPlace(transform);\r\n\r\n  return polyface;\r\n}\r\n\r\n/** Demonstrate the addition of analytical data to a polyface.\r\n * This is a purely fictional example intended to demonstrate concepts of [[PolyfaceAuxData]] concepts only.\r\n * Create a polyface representing a flat mesh with superimposed waves and associated [[PolyfaceAuxData]]  to display displacement, height and slope data.\r\n * A vector [[AuxChannel]] is created to represent displacement and two scalar [[AuxChannel]] are created to represent height and slope.\r\n * Note that data between inputs are interpolated so motion will still remain relatively smooth even with only three inputs in the radial waves.\r\n */\r\nfunction createFlatMeshWithWaves(): Polyface {\r\n  const options = StrokeOptions.createForFacets();\r\n  options.shouldTriangulate = true;\r\n  const builder = PolyfaceBuilder.create(options);\r\n  const nDimensions = 100;\r\n  const spacing = 1.0;\r\n\r\n  /* Create a simple flat mesh with 10,000 points (100x100) */\r\n  for (let iRow = 0; iRow < nDimensions - 1; iRow++) {\r\n    for (let iColumn = 0; iColumn < nDimensions - 1; iColumn++) {\r\n      const quad = [\r\n        Point3d.create(iRow * spacing, iColumn * spacing, 0.0),\r\n        Point3d.create((iRow + 1) * spacing, iColumn * spacing, 0.0),\r\n        Point3d.create((iRow + 1) * spacing, (iColumn + 1) * spacing, 0.0),\r\n        Point3d.create(iRow * spacing, (iColumn + 1) * spacing),\r\n      ];\r\n      builder.addQuadFacet(quad);\r\n    }\r\n  }\r\n\r\n  const polyface = builder.claimPolyface();\r\n  const zeroScalarData = [], zeroDisplacementData = [], radialHeightData = [], radialSlopeData = [], radialDisplacementData = [];\r\n  const radius = nDimensions * spacing / 2.0;\r\n  const center = new Point3d(radius, radius, 0.0);\r\n  const maxHeight = radius / 4.0;\r\n  const auxChannels = [];\r\n\r\n  /** Create a radial wave - start and return to zero  */\r\n  for (let i = 0; i < polyface.data.point.length; i++) {\r\n    const angle = Angle.pi2Radians * polyface.data.point.distanceIndexToPoint(i, center)! / radius;\r\n    const height = maxHeight * Math.sin(angle);\r\n    const slope = Math.abs(Math.cos(angle));\r\n\r\n    zeroScalarData.push(0.0);\r\n    zeroDisplacementData.push(0.0);\r\n    zeroDisplacementData.push(0.0);\r\n    zeroDisplacementData.push(0.0);\r\n\r\n    radialHeightData.push(height);\r\n    radialSlopeData.push(slope);\r\n    radialDisplacementData.push(0.0);\r\n    radialDisplacementData.push(0.0);\r\n    radialDisplacementData.push(height);\r\n  }\r\n\r\n  // Static Channels.\r\n  auxChannels.push(new AuxChannel([new AuxChannelData(0.0, radialDisplacementData)], AuxChannelDataType.Vector, \"Static Radial Displacement\", \"Radial: Static\"));\r\n  auxChannels.push(new AuxChannel([new AuxChannelData(1.0, radialHeightData)], AuxChannelDataType.Distance, \"Static Radial Height\", \"Radial: Static\"));\r\n  auxChannels.push(new AuxChannel([new AuxChannelData(1.0, radialSlopeData)], AuxChannelDataType.Scalar, \"Static Radial Slope\", \"Radial: Static\"));\r\n\r\n  // Animated Channels.\r\n  const radialDisplacementDataVector = [new AuxChannelData(0.0, zeroDisplacementData), new AuxChannelData(1.0, radialDisplacementData), new AuxChannelData(2.0, zeroDisplacementData)];\r\n  const radialHeightDataVector = [new AuxChannelData(0.0, zeroScalarData), new AuxChannelData(1.0, radialHeightData), new AuxChannelData(2.0, zeroScalarData)];\r\n  const radialSlopeDataVector = [new AuxChannelData(0.0, zeroScalarData), new AuxChannelData(1.0, radialSlopeData), new AuxChannelData(2.0, zeroScalarData)];\r\n\r\n  auxChannels.push(new AuxChannel(radialDisplacementDataVector, AuxChannelDataType.Vector, \"Animated Radial Displacement\", \"Radial: Time\"));\r\n  auxChannels.push(new AuxChannel(radialHeightDataVector, AuxChannelDataType.Distance, \"Animated Radial Height\", \"Radial: Time\"));\r\n  auxChannels.push(new AuxChannel(radialSlopeDataVector, AuxChannelDataType.Scalar, \"Animated Radial Slope\", \"Radial: Time\"));\r\n\r\n  /** Create linear waves -- 10 separate frames.  */\r\n  const waveHeight = radius / 20.0;\r\n  const waveLength = radius / 2.0;\r\n  const frameCount = 10;\r\n  const linearDisplacementDataVector = [], linearHeightDataVector = [], linearSlopeDataVector = [];\r\n\r\n  for (let i = 0; i < frameCount; i++) {\r\n    const fraction = i / (frameCount - 1);\r\n    const waveCenter = waveLength * fraction;\r\n    const linearHeightData = [], linearSlopeData = [], linearDisplacementData = [];\r\n\r\n    for (let j = 0; j < polyface.data.point.length; j++) {\r\n      const point = polyface.data.point.getPoint3dAtUncheckedPointIndex(j);\r\n      const theta = Angle.pi2Radians * (point.x - waveCenter) / waveLength;\r\n      const height = waveHeight * Math.sin(theta);\r\n      const slope = Math.abs(Math.cos(theta));\r\n\r\n      linearHeightData.push(height);\r\n      linearSlopeData.push(slope);\r\n      linearDisplacementData.push(0.0);\r\n      linearDisplacementData.push(0.0);\r\n      linearDisplacementData.push(height);\r\n    }\r\n    linearDisplacementDataVector.push(new AuxChannelData(i, linearDisplacementData));\r\n    linearHeightDataVector.push(new AuxChannelData(i, linearHeightData));\r\n    linearSlopeDataVector.push(new AuxChannelData(i, linearSlopeData));\r\n  }\r\n  auxChannels.push(new AuxChannel(linearDisplacementDataVector, AuxChannelDataType.Vector, \"Linear Displacement\", \"Linear: Time\"));\r\n  auxChannels.push(new AuxChannel(linearHeightDataVector, AuxChannelDataType.Distance, \"Linear Height\", \"Linear: Time\"));\r\n  auxChannels.push(new AuxChannel(linearSlopeDataVector, AuxChannelDataType.Scalar, \"Linear Slope\", \"Linear: Time\"));\r\n\r\n  polyface.data.auxData = new PolyfaceAuxData(auxChannels, polyface.data.pointIndex);\r\n  return polyface;\r\n}\r\n\r\nasync function createMesh(type: AnalysisMeshType, displacementScale = 1): Promise<AnalysisMesh> {\r\n  const polyface = \"Flat with waves\" === type ? createFlatMeshWithWaves() : await createCantilever();\r\n  const styles = new Map<string, AnalysisStyle | undefined>();\r\n  const mesh = { type, polyface, styles };\r\n  populateAnalysisStyles(mesh, displacementScale);\r\n  return mesh;\r\n}\r\n\r\nclass AnalysisDecorator {\r\n  public readonly mesh: AnalysisMesh;\r\n  private readonly _viewport: Viewport;\r\n  private readonly _id: string;\r\n  private _graphic?: RenderGraphicOwner;\r\n  private _dispose?: () => void;\r\n\r\n  public constructor(viewport: Viewport, mesh: AnalysisMesh) {\r\n    this._viewport = viewport;\r\n    this.mesh = mesh;\r\n    this._id = viewport.iModel.transientIds.getNext();\r\n\r\n    const removeDisposalListener = viewport.onDisposed.addOnce(() => this.dispose());\r\n    const removeAnalysisStyleListener = viewport.addOnAnalysisStyleChangedListener(() => {\r\n      this._graphic?.disposeGraphic();\r\n      this._graphic = undefined;\r\n    });\r\n\r\n    this._dispose = () => {\r\n      removeAnalysisStyleListener();\r\n      removeDisposalListener();\r\n    };\r\n\r\n    IModelApp.viewManager.addDecorator(this);\r\n  }\r\n\r\n  public dispose(): void {\r\n    if (!this._dispose) {\r\n      assert(undefined === this._graphic);\r\n      return;\r\n    }\r\n\r\n    this._graphic?.disposeGraphic();\r\n    this._graphic = undefined;\r\n    this._dispose();\r\n    this._dispose = undefined;\r\n    IModelApp.viewManager.dropDecorator(this);\r\n  }\r\n\r\n  public decorate(context: DecorateContext): void {\r\n    if (context.viewport !== this._viewport)\r\n      return;\r\n\r\n    if (!this._graphic) {\r\n      const builder = context.createGraphicBuilder(GraphicType.Scene, undefined, this._id);\r\n      const color = ColorDef.fromTbgr(ColorByName.darkSlateBlue);\r\n      builder.setSymbology(color, color, 1);\r\n      builder.addPolyface(this.mesh.polyface, false);\r\n      this._graphic = IModelApp.renderSystem.createGraphicOwner(builder.finish());\r\n    }\r\n\r\n    context.addDecoration(GraphicType.Scene, this._graphic);\r\n  }\r\n}\r\n\r\nexport async function openAnalysisStyleExample(viewer: Viewer): Promise<void> {\r\n  const meshes = await Promise.all([createMesh(\"Cantilever\", 100), createMesh(\"Flat with waves\")]);\r\n  let decorator = new AnalysisDecorator(viewer.viewport, meshes[0]);\r\n\r\n  const meshPicker = document.createElement(\"select\");\r\n  meshPicker.className = \"viewList\";\r\n  viewer.toolBar.element.appendChild(meshPicker);\r\n  for (const mesh of meshes) {\r\n    const option = document.createElement(\"option\");\r\n    option.innerText = mesh.type;\r\n    option.value = mesh.type;\r\n    meshPicker.appendChild(option);\r\n  }\r\n\r\n  meshPicker.selectedIndex = 0;\r\n  meshPicker.onchange = () => {\r\n    const type = meshPicker.value as AnalysisMeshType;\r\n    if (type !== decorator.mesh.type) {\r\n      decorator.dispose();\r\n      decorator = new AnalysisDecorator(viewer.viewport, meshes[meshPicker.selectedIndex]);\r\n      populateStylePicker();\r\n    }\r\n  };\r\n\r\n  const stylePicker = document.createElement(\"select\");\r\n  stylePicker.className = \"viewList\";\r\n  viewer.toolBar.element.appendChild(stylePicker);\r\n  stylePicker.onchange = () => {\r\n    viewer.viewport.displayStyle.settings.analysisStyle = decorator.mesh.styles.get(stylePicker.value);\r\n  };\r\n\r\n  function populateStylePicker(): void {\r\n    while (stylePicker.firstChild)\r\n      stylePicker.removeChild(stylePicker.firstChild);\r\n\r\n    for (const name of decorator.mesh.styles.keys()) {\r\n      const option = document.createElement(\"option\");\r\n      option.innerText = option.value = name;\r\n      stylePicker.appendChild(option);\r\n    }\r\n\r\n    viewer.viewport.displayStyle.settings.analysisStyle = undefined;\r\n  }\r\n\r\n  populateStylePicker();\r\n\r\n  assert(viewer.viewport.view.is3d());\r\n  viewer.viewport.setStandardRotation(StandardViewId.Iso);\r\n  viewer.viewport.zoomToVolume(viewer.viewport.iModel.projectExtents);\r\n\r\n  viewer.viewport.viewFlags = viewer.viewport.viewFlags.withRenderMode(RenderMode.SolidFill);\r\n\r\n  const settings = viewer.viewport.view.getDisplayStyle3d().settings;\r\n  settings.environment = settings.environment.clone({\r\n    displaySky: true,\r\n    sky: SkyBox.fromJSON({ twoColor: true, nadirColor: 0xdfefff, zenithColor: 0xffefdf }),\r\n  });\r\n}\r\n"
        ],
        "mappings": "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",
        "names": []
      }
    },
    {
      "name": "vite:build-import-analysis",
      "result": "import { __vitePreload } from \"\u0000vite/preload-helper\";\"use strict\";\nimport { assert } from \"@itwin/core-bentley\";\nimport { Angle, AuxChannel, AuxChannelData, AuxChannelDataType, IModelJson, Point3d, Polyface, PolyfaceAuxData, PolyfaceBuilder, StrokeOptions, Transform } from \"@itwin/core-geometry\";\nimport {\n  AnalysisStyle,\n  ColorByName,\n  ColorDef,\n  RenderMode,\n  SkyBox,\n  ThematicGradientColorScheme,\n  ThematicGradientMode\n} from \"@itwin/core-common\";\nimport {\n  GraphicType,\n  IModelApp,\n  StandardViewId\n} from \"@itwin/core-frontend\";\nfunction populateAnalysisStyles(mesh, displacementScale) {\n  const auxdata = mesh.polyface.data.auxData;\n  if (!auxdata)\n    return;\n  mesh.styles.set(\"None\", void 0);\n  for (const channel of auxdata.channels) {\n    if (void 0 === channel.name || !channel.isScalar)\n      continue;\n    const displacementChannel = auxdata.channels.find((x) => x.inputName === channel.inputName && x.dataType === AuxChannelDataType.Vector);\n    const thematicSettings = {};\n    if (channel.name.endsWith(\"Height\")) {\n      thematicSettings.colorScheme = ThematicGradientColorScheme.SeaMountain;\n      thematicSettings.mode = ThematicGradientMode.SteppedWithDelimiter;\n    }\n    assert(void 0 !== channel.scalarRange);\n    const props = {\n      scalar: {\n        channelName: channel.name,\n        range: channel.scalarRange,\n        thematicSettings\n      }\n    };\n    let name = channel.name;\n    if (void 0 !== displacementChannel?.name) {\n      props.displacement = { channelName: displacementChannel.name, scale: displacementScale };\n      const exaggeration = 1 !== displacementScale ? \"\" : ` X ${displacementScale}`;\n      name = `${name} and ${displacementChannel.name}${exaggeration}`;\n    }\n    mesh.styles.set(name, AnalysisStyle.fromJSON(props));\n  }\n}\nasync function createCantilever() {\n  const { cantileverJsonString } = await __vitePreload(() => import(\"./Cantilever\"),__VITE_IS_MODERN__?\"__VITE_PRELOAD__\":void 0);\n  const polyface = IModelJson.Reader.parse(\n    JSON.parse(cantileverJsonString)\n  );\n  assert(polyface instanceof Polyface);\n  const transform = Transform.createScaleAboutPoint(new Point3d(), 30);\n  polyface.tryTransformInPlace(transform);\n  return polyface;\n}\nfunction createFlatMeshWithWaves() {\n  const options = StrokeOptions.createForFacets();\n  options.shouldTriangulate = true;\n  const builder = PolyfaceBuilder.create(options);\n  const nDimensions = 100;\n  const spacing = 1;\n  for (let iRow = 0; iRow < nDimensions - 1; iRow++) {\n    for (let iColumn = 0; iColumn < nDimensions - 1; iColumn++) {\n      const quad = [\n        Point3d.create(iRow * spacing, iColumn * spacing, 0),\n        Point3d.create((iRow + 1) * spacing, iColumn * spacing, 0),\n        Point3d.create((iRow + 1) * spacing, (iColumn + 1) * spacing, 0),\n        Point3d.create(iRow * spacing, (iColumn + 1) * spacing)\n      ];\n      builder.addQuadFacet(quad);\n    }\n  }\n  const polyface = builder.claimPolyface();\n  const zeroScalarData = [], zeroDisplacementData = [], radialHeightData = [], radialSlopeData = [], radialDisplacementData = [];\n  const radius = nDimensions * spacing / 2;\n  const center = new Point3d(radius, radius, 0);\n  const maxHeight = radius / 4;\n  const auxChannels = [];\n  for (let i = 0; i < polyface.data.point.length; i++) {\n    const angle = Angle.pi2Radians * polyface.data.point.distanceIndexToPoint(i, center) / radius;\n    const height = maxHeight * Math.sin(angle);\n    const slope = Math.abs(Math.cos(angle));\n    zeroScalarData.push(0);\n    zeroDisplacementData.push(0);\n    zeroDisplacementData.push(0);\n    zeroDisplacementData.push(0);\n    radialHeightData.push(height);\n    radialSlopeData.push(slope);\n    radialDisplacementData.push(0);\n    radialDisplacementData.push(0);\n    radialDisplacementData.push(height);\n  }\n  auxChannels.push(new AuxChannel([new AuxChannelData(0, radialDisplacementData)], AuxChannelDataType.Vector, \"Static Radial Displacement\", \"Radial: Static\"));\n  auxChannels.push(new AuxChannel([new AuxChannelData(1, radialHeightData)], AuxChannelDataType.Distance, \"Static Radial Height\", \"Radial: Static\"));\n  auxChannels.push(new AuxChannel([new AuxChannelData(1, radialSlopeData)], AuxChannelDataType.Scalar, \"Static Radial Slope\", \"Radial: Static\"));\n  const radialDisplacementDataVector = [new AuxChannelData(0, zeroDisplacementData), new AuxChannelData(1, radialDisplacementData), new AuxChannelData(2, zeroDisplacementData)];\n  const radialHeightDataVector = [new AuxChannelData(0, zeroScalarData), new AuxChannelData(1, radialHeightData), new AuxChannelData(2, zeroScalarData)];\n  const radialSlopeDataVector = [new AuxChannelData(0, zeroScalarData), new AuxChannelData(1, radialSlopeData), new AuxChannelData(2, zeroScalarData)];\n  auxChannels.push(new AuxChannel(radialDisplacementDataVector, AuxChannelDataType.Vector, \"Animated Radial Displacement\", \"Radial: Time\"));\n  auxChannels.push(new AuxChannel(radialHeightDataVector, AuxChannelDataType.Distance, \"Animated Radial Height\", \"Radial: Time\"));\n  auxChannels.push(new AuxChannel(radialSlopeDataVector, AuxChannelDataType.Scalar, \"Animated Radial Slope\", \"Radial: Time\"));\n  const waveHeight = radius / 20;\n  const waveLength = radius / 2;\n  const frameCount = 10;\n  const linearDisplacementDataVector = [], linearHeightDataVector = [], linearSlopeDataVector = [];\n  for (let i = 0; i < frameCount; i++) {\n    const fraction = i / (frameCount - 1);\n    const waveCenter = waveLength * fraction;\n    const linearHeightData = [], linearSlopeData = [], linearDisplacementData = [];\n    for (let j = 0; j < polyface.data.point.length; j++) {\n      const point = polyface.data.point.getPoint3dAtUncheckedPointIndex(j);\n      const theta = Angle.pi2Radians * (point.x - waveCenter) / waveLength;\n      const height = waveHeight * Math.sin(theta);\n      const slope = Math.abs(Math.cos(theta));\n      linearHeightData.push(height);\n      linearSlopeData.push(slope);\n      linearDisplacementData.push(0);\n      linearDisplacementData.push(0);\n      linearDisplacementData.push(height);\n    }\n    linearDisplacementDataVector.push(new AuxChannelData(i, linearDisplacementData));\n    linearHeightDataVector.push(new AuxChannelData(i, linearHeightData));\n    linearSlopeDataVector.push(new AuxChannelData(i, linearSlopeData));\n  }\n  auxChannels.push(new AuxChannel(linearDisplacementDataVector, AuxChannelDataType.Vector, \"Linear Displacement\", \"Linear: Time\"));\n  auxChannels.push(new AuxChannel(linearHeightDataVector, AuxChannelDataType.Distance, \"Linear Height\", \"Linear: Time\"));\n  auxChannels.push(new AuxChannel(linearSlopeDataVector, AuxChannelDataType.Scalar, \"Linear Slope\", \"Linear: Time\"));\n  polyface.data.auxData = new PolyfaceAuxData(auxChannels, polyface.data.pointIndex);\n  return polyface;\n}\nasync function createMesh(type, displacementScale = 1) {\n  const polyface = \"Flat with waves\" === type ? createFlatMeshWithWaves() : await createCantilever();\n  const styles = /* @__PURE__ */ new Map();\n  const mesh = { type, polyface, styles };\n  populateAnalysisStyles(mesh, displacementScale);\n  return mesh;\n}\nclass AnalysisDecorator {\n  constructor(viewport, mesh) {\n    this._viewport = viewport;\n    this.mesh = mesh;\n    this._id = viewport.iModel.transientIds.getNext();\n    const removeDisposalListener = viewport.onDisposed.addOnce(() => this.dispose());\n    const removeAnalysisStyleListener = viewport.addOnAnalysisStyleChangedListener(() => {\n      this._graphic?.disposeGraphic();\n      this._graphic = void 0;\n    });\n    this._dispose = () => {\n      removeAnalysisStyleListener();\n      removeDisposalListener();\n    };\n    IModelApp.viewManager.addDecorator(this);\n  }\n  dispose() {\n    if (!this._dispose) {\n      assert(void 0 === this._graphic);\n      return;\n    }\n    this._graphic?.disposeGraphic();\n    this._graphic = void 0;\n    this._dispose();\n    this._dispose = void 0;\n    IModelApp.viewManager.dropDecorator(this);\n  }\n  decorate(context) {\n    if (context.viewport !== this._viewport)\n      return;\n    if (!this._graphic) {\n      const builder = context.createGraphicBuilder(GraphicType.Scene, void 0, this._id);\n      const color = ColorDef.fromTbgr(ColorByName.darkSlateBlue);\n      builder.setSymbology(color, color, 1);\n      builder.addPolyface(this.mesh.polyface, false);\n      this._graphic = IModelApp.renderSystem.createGraphicOwner(builder.finish());\n    }\n    context.addDecoration(GraphicType.Scene, this._graphic);\n  }\n}\nexport async function openAnalysisStyleExample(viewer) {\n  const meshes = await Promise.all([createMesh(\"Cantilever\", 100), createMesh(\"Flat with waves\")]);\n  let decorator = new AnalysisDecorator(viewer.viewport, meshes[0]);\n  const meshPicker = document.createElement(\"select\");\n  meshPicker.className = \"viewList\";\n  viewer.toolBar.element.appendChild(meshPicker);\n  for (const mesh of meshes) {\n    const option = document.createElement(\"option\");\n    option.innerText = mesh.type;\n    option.value = mesh.type;\n    meshPicker.appendChild(option);\n  }\n  meshPicker.selectedIndex = 0;\n  meshPicker.onchange = () => {\n    const type = meshPicker.value;\n    if (type !== decorator.mesh.type) {\n      decorator.dispose();\n      decorator = new AnalysisDecorator(viewer.viewport, meshes[meshPicker.selectedIndex]);\n      populateStylePicker();\n    }\n  };\n  const stylePicker = document.createElement(\"select\");\n  stylePicker.className = \"viewList\";\n  viewer.toolBar.element.appendChild(stylePicker);\n  stylePicker.onchange = () => {\n    viewer.viewport.displayStyle.settings.analysisStyle = decorator.mesh.styles.get(stylePicker.value);\n  };\n  function populateStylePicker() {\n    while (stylePicker.firstChild)\n      stylePicker.removeChild(stylePicker.firstChild);\n    for (const name of decorator.mesh.styles.keys()) {\n      const option = document.createElement(\"option\");\n      option.innerText = option.value = name;\n      stylePicker.appendChild(option);\n    }\n    viewer.viewport.displayStyle.settings.analysisStyle = void 0;\n  }\n  populateStylePicker();\n  assert(viewer.viewport.view.is3d());\n  viewer.viewport.setStandardRotation(StandardViewId.Iso);\n  viewer.viewport.zoomToVolume(viewer.viewport.iModel.projectExtents);\n  viewer.viewport.viewFlags = viewer.viewport.viewFlags.withRenderMode(RenderMode.SolidFill);\n  const settings = viewer.viewport.view.getDisplayStyle3d().settings;\n  settings.environment = settings.environment.clone({\n    displaySky: true,\n    sky: SkyBox.fromJSON({ twoColor: true, nadirColor: 14675967, zenithColor: 16773087 })\n  });\n}\n",
      "start": 1693508121722,
      "end": 1693508121722,
      "order": "normal",
      "sourcemaps": null
    }
  ]
}
