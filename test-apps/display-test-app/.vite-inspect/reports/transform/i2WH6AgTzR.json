{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/numerics/TriDiagonalSystem.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Numerics\n */\nimport { Geometry } from \"../Geometry\";\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\n// Enumerated type lies outside of TriDiagonalSystem, as TSLint prevented declaration within class\nvar DataState;\n(function (DataState) {\n    DataState[DataState[\"RawMatrix\"] = 0] = \"RawMatrix\";\n    DataState[DataState[\"FactorOK\"] = 1] = \"FactorOK\";\n    DataState[DataState[\"FactorFailed\"] = 2] = \"FactorFailed\";\n})(DataState || (DataState = {}));\n/**\n * Linear system operations on a matrix with data only on the diagonal and its immediate left and right neighbors\n * @internal\n */\nexport class TriDiagonalSystem {\n    constructor(n) {\n        this._aLeft = new Float64Array(n);\n        this._aDiag = new Float64Array(n);\n        this._aRight = new Float64Array(n);\n        this._b = new Float64Array(n);\n        this._x = new Float64Array(n);\n        this.reset();\n    }\n    /** Reset to RawMatrix state with all coefficients zero */\n    reset() {\n        this._dataState = DataState.RawMatrix;\n        const n = this._aDiag.length;\n        for (let i = 0; i < n; i++) {\n            this._aLeft[i] = this._aRight[i] = this._aDiag[i] = this._b[i] = this._x[i] = 0.0;\n        }\n    }\n    /** Install data in a row of the matrix */\n    setRow(row, left, diag, right) {\n        this._aLeft[row] = left;\n        this._aDiag[row] = diag;\n        this._aRight[row] = right;\n    }\n    /** Add to row of matrix */\n    addToRow(row, left, diag, right) {\n        this._aLeft[row] += left;\n        this._aDiag[row] += diag;\n        this._aRight[row] += right;\n    }\n    /** Install data in the right side (B) vector */\n    setB(row, bb) {\n        this._b[row] = bb;\n    }\n    /** Add to an entry in the right side (B) vector */\n    addToB(row, bb) {\n        this._b[row] += bb;\n    }\n    /** Access data from the right side (B) vector */\n    getB(row) {\n        return this._b[row];\n    }\n    /** Install data in the solution (X) vector */\n    setX(row, xx) {\n        this._x[row] = xx;\n    }\n    /** Access data from the solution (X) vector */\n    getX(row) {\n        return this._x[row];\n    }\n    /** Get method for matrix and vector order */\n    order() {\n        return this._aDiag.length;\n    }\n    /** Compute product of AX and save as B */\n    multiplyAX() {\n        if (this._dataState === DataState.FactorFailed) {\n            return false;\n        }\n        else if (this._dataState === DataState.FactorOK) {\n            const n = this._aDiag.length;\n            const nm1 = n - 1;\n            for (let i = 0; i < nm1; i++) {\n                this._b[i] = this._aDiag[i] * this._x[i] + this._aRight[i] * this._x[i + 1];\n            }\n            this._b[nm1] = this._aDiag[nm1] * this._x[nm1];\n            for (let i = nm1; i > 0; i--) {\n                this._b[i] += this._aLeft[i] * this._b[i - 1];\n            }\n            return true;\n        }\n        else {\n            const n = this._aDiag.length;\n            const nm1 = n - 1;\n            this._b[0] = this._aDiag[0] * this._x[0] + this._aRight[0] * this._x[1];\n            let i;\n            for (i = 1; i < nm1; i++) {\n                this._b[i] = this._aLeft[i] * this._x[i - 1] + this._aDiag[i] * this._x[i] + this._aRight[i] * this._x[i + 1];\n            }\n            this._b[nm1] = this._aLeft[nm1] * this._x[n - 2] + this._aDiag[i] * this._x[nm1];\n            return true;\n        }\n    }\n    /** Compute product of AX and save as B */\n    multiplyAXPoints(pointX, pointB) {\n        pointB.length = 0;\n        while (pointB.length < pointX.length)\n            pointB.push(Point3d.create());\n        pointB.length = pointX.length;\n        if (this._dataState === DataState.FactorFailed) {\n            return false;\n        }\n        else if (this._dataState === DataState.FactorOK) {\n            const n = this._aDiag.length;\n            const nm1 = n - 1;\n            for (let i = 0; i < nm1; i++) {\n                Point3d.createAdd2Scaled(pointX[i], this._aDiag[i], pointX[i + 1], this._aRight[i], pointB[i]);\n            }\n            Point3d.createScale(pointX[nm1], this._aDiag[nm1], pointB[nm1]);\n            for (let i = nm1; i > 0; i--) {\n                pointB[i].plusScaled(pointB[i - 1], this._aLeft[i], pointB[i]);\n            }\n            return true;\n        }\n        else {\n            const n = this._aDiag.length;\n            const nm1 = n - 1;\n            Point3d.createAdd2Scaled(pointX[0], this._aDiag[0], pointX[1], this._aRight[0], pointB[0]);\n            let i;\n            for (i = 1; i < nm1; i++) {\n                Point3d.createAdd3Scaled(pointX[i - 1], this._aLeft[i], pointX[i], this._aDiag[i], pointX[i + 1], this._aRight[i], pointB[i]);\n            }\n            Point3d.createAdd2Scaled(pointX[n - 2], this._aLeft[nm1], pointX[nm1], this._aDiag[nm1], pointB[nm1]);\n            return true;\n        }\n    }\n    /** Multiply the stored factors together to return to plain matrix form */\n    defactor() {\n        if (this._dataState === DataState.RawMatrix) {\n            return true;\n        }\n        if (this._dataState === DataState.FactorFailed) {\n            return false;\n        }\n        const n = this._aDiag.length;\n        const nm1 = n - 1;\n        for (let i = nm1; i > 0; i--) {\n            this._aDiag[i] += this._aLeft[i] * this._aRight[i - 1];\n            this._aLeft[i] *= this._aDiag[i - 1];\n        }\n        this._dataState = DataState.RawMatrix;\n        return true;\n    }\n    /** Factor the tridiagonal matrix to LU parts. b, x, not altered */\n    factor() {\n        if (this._dataState === DataState.FactorOK) {\n            return true;\n        }\n        if (this._dataState !== DataState.RawMatrix) {\n            return false;\n        }\n        this._dataState = DataState.FactorFailed;\n        const n1 = this._aDiag.length - 1; // Last pivot index\n        // Eliminate in subdiagonal.\n        for (let i = 0; i < n1; i++) {\n            const r = Geometry.conditionalDivideFraction(this._aLeft[i + 1], this._aDiag[i]);\n            if (r === undefined)\n                return false;\n            this._aLeft[i + 1] = r;\n            this._aDiag[i + 1] -= r * this._aRight[i];\n        }\n        this._dataState = DataState.FactorOK;\n        return true;\n    }\n    /** Solve AX=B. A is left in factored state. B unchanged. */\n    factorAndBackSubstitute() {\n        const n = this._aDiag.length;\n        const n1 = n - 1;\n        if (!this.factor())\n            return false;\n        // Apply L inverse to B, same sequence as was done to A:\n        for (let i = 0; i < n; i++) {\n            this._x[i] = this._b[i];\n        }\n        for (let i = 1; i < n; i++) {\n            this._x[i] -= this._aLeft[i] * this._x[i - 1];\n        }\n        // Print (\"LU  L Inverse B B\");\n        // overwrite X with solution of U * X = L inverse B, where RHS is already in X...\n        // All diagonals are known to be nonzero. Really.  Really???\n        this._x[n1] /= this._aDiag[n1];\n        for (let i = n1 - 1; i >= 0; i--) {\n            this._x[i] = (this._x[i] - this._aRight[i] * this._x[i + 1]) / this._aDiag[i];\n        }\n        return true;\n    }\n    /** Solve AX=B. A is left in factored state. B unchanged. vectorB and vectorX may be the same array */\n    factorAndBackSubstitutePointArrays(vectorB, vectorX) {\n        const n = this._aDiag.length;\n        if (vectorB.length < n)\n            return false;\n        while (vectorX.length < n)\n            vectorX.push(Point3d.create(0, 0, 0));\n        vectorX.length = n;\n        const n1 = n - 1;\n        if (!this.factor())\n            return false;\n        // Apply L inverse to B, same sequence as was done to A:\n        if (vectorB !== vectorX) {\n            for (let i = 0; i < n; i++) {\n                vectorX[i].setFrom(vectorB[i]);\n            }\n        }\n        let a;\n        let b;\n        for (let i = 1; i < n; i++) {\n            a = this._aLeft[i];\n            vectorX[i].x -= a * vectorX[i - 1].x;\n            vectorX[i].y -= a * vectorX[i - 1].y;\n            vectorX[i].z -= a * vectorX[i - 1].z;\n        }\n        // Print (\"LU  L inverse B\");\n        // overwrite X with solution of U * X = L inverse B, where RHS is already in X...\n        // All diagonals are known to be nonzero. Really.  Really???\n        b = 1.0 / this._aDiag[n1];\n        vectorX[n1].x *= b;\n        vectorX[n1].y *= b;\n        vectorX[n1].z *= b;\n        for (let i = n1 - 1; i >= 0; i--) {\n            a = this._aRight[i];\n            b = 1.0 / this._aDiag[i];\n            vectorX[i].x = (vectorX[i].x - a * vectorX[i + 1].x) * b;\n            vectorX[i].y = (vectorX[i].y - a * vectorX[i + 1].y) * b;\n            vectorX[i].z = (vectorX[i].z - a * vectorX[i + 1].z) * b;\n        }\n        return true;\n    }\n    /** Allocate a complete copy */\n    copy() {\n        const n = this._aDiag.length;\n        const B = new TriDiagonalSystem(n);\n        for (let i = 0; i < n; i++) {\n            B._aLeft[i] = this._aLeft[i];\n            B._aDiag[i] = this._aDiag[i];\n            B._aRight[i] = this._aRight[i];\n            B._x[i] = this._x[i];\n            B._b[i] = this._b[i];\n        }\n        B._dataState = this._dataState;\n        return B;\n    }\n    /** return an array form that may be useful for display ... */\n    flatten() {\n        const n = this._aDiag.length;\n        const data = [];\n        for (let i = 0; i < n; i++) {\n            data.push([i, [this._aLeft[i], this._aDiag[i], this._aRight[i]], this._x[i], this._b[i]]);\n        }\n        return data;\n    }\n    /** return an array form that may be useful for display ... */\n    flattenWithPoints(xyzB) {\n        const n = this._aDiag.length;\n        const data = [];\n        for (let i = 0; i < n; i++) {\n            data.push([i, [this._aLeft[i], this._aDiag[i], this._aRight[i]], this._x[i], xyzB[i].toJSON()]);\n        }\n        return data;\n    }\n}\n//# sourceMappingURL=TriDiagonalSystem.js.map",
      "start": 1693508123491,
      "end": 1693508123672,
      "sourcemaps": null
    }
  ]
}
