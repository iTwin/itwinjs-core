{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/common/lib/esm/ConcurrentQuery.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module iModels\n */\nimport { BentleyError, CompressedId64Set, DbResult, Id64, OrderedId64Iterable } from \"@itwin/core-bentley\";\nimport { Point2d, Point3d } from \"@itwin/core-geometry\";\nimport { Base64 } from \"js-base64\";\n/**\n * Specifies the format of the rows returned by the `query` and `restartQuery` methods of\n * [IModelConnection]($frontend), [IModelDb]($backend), and [ECDb]($backend).\n *\n * @public\n * @extensions\n */\nexport var QueryRowFormat;\n(function (QueryRowFormat) {\n    /** Each row is an object in which each non-null column value can be accessed by its name as defined in the ECSql.\n     * Null values are omitted.\n     */\n    QueryRowFormat[QueryRowFormat[\"UseECSqlPropertyNames\"] = 0] = \"UseECSqlPropertyNames\";\n    /** Each row is an array of values accessed by an index corresponding to the property's position in the ECSql SELECT statement.\n     * Null values are included if they are followed by a non-null column, but trailing null values at the end of the array are omitted.\n     */\n    QueryRowFormat[QueryRowFormat[\"UseECSqlPropertyIndexes\"] = 1] = \"UseECSqlPropertyIndexes\";\n    /** Each row is an object in which each non-null column value can be accessed by a [remapped property name]($docs/learning/ECSqlRowFormat.md).\n     * This format is backwards-compatible with the format produced by iTwin.js 2.x. Null values are omitted.\n     */\n    QueryRowFormat[QueryRowFormat[\"UseJsPropertyNames\"] = 2] = \"UseJsPropertyNames\";\n})(QueryRowFormat || (QueryRowFormat = {}));\n/** @public */\nexport class QueryOptionsBuilder {\n    constructor(_options = {}) {\n        this._options = _options;\n    }\n    getOptions() { return this._options; }\n    /**\n     * @internal\n     * Allow to set priority of query. Query will be inserted int queue base on priority value. This value will be ignored if concurrent query is configured with ignored priority is true.\n     * @param val integer value which can be negative as well. By default its zero.\n     * @returns @type QueryOptionsBuilder for fluent interface.\n     */\n    setPriority(val) {\n        this._options.priority = val;\n        return this;\n    }\n    /**\n     * Allow to set restart token. If restart token is set then any other query(s) in queue with same token is cancelled if its not already executed.\n     * @param val A string token identifying a use case in which previous query with same token is cancelled.\n     * @returns @type QueryOptionsBuilder for fluent interface.\n     */\n    setRestartToken(val) {\n        this._options.restartToken = val;\n        return this;\n    }\n    /**\n     * Allow to set quota restriction for query. Its a hint and may be overriden or ignored by concurrent query manager.\n     * @param val @type QueryQuota Specify time and memory that can be used by a query.\n     * @returns @type QueryOptionsBuilder for fluent interface.\n     */\n    setQuota(val) {\n        this._options.quota = val;\n        return this;\n    }\n    /**\n     * Force a query to be executed synchronously against primary connection. This option is ignored if provided by frontend.\n     * @param val A boolean value to force use primary connection on main thread to execute query.\n     * @returns @type QueryOptionsBuilder for fluent interface.\n     */\n    setUsePrimaryConnection(val) {\n        this._options.usePrimaryConn = val;\n        return this;\n    }\n    /**\n     * By default all blobs are abbreviated to save memory and network bandwidth. If set to false, all blob data will be returned by query as is.\n     * Use @type BlobReader to access blob data more efficiently.\n     * @param val A boolean value, if set to false will return complete blob type property data. This could cost time and network bandwidth.\n     * @returns @type QueryOptionsBuilder for fluent interface.\n     */\n    setAbbreviateBlobs(val) {\n        this._options.abbreviateBlobs = val;\n        return this;\n    }\n    /**\n     * When query fail to prepare it will log error. This setting will suppress log errors in case where query come from user typing it and its expected to fail often.\n     * @param val A boolean value, if set to true, any error logging will be suppressed.\n     * @returns @type QueryOptionsBuilder for fluent interface.\n     */\n    setSuppressLogErrors(val) {\n        this._options.suppressLogErrors = val;\n        return this;\n    }\n    /**\n     * If set ECClassId, SourceECClassId and TargetECClassId system properties will return qualified name of class instead of a @typedef Id64String.\n     * @param val A boolean value.\n     * @returns @type QueryOptionsBuilder for fluent interface.\n     */\n    setConvertClassIdsToNames(val) {\n        this._options.convertClassIdsToClassNames = val;\n        return this;\n    }\n    /**\n     * Specify limit for query. Limit determine number of rows and offset in result-set.\n     * @param val Specify count and offset from within the result-set of a ECSQL query.\n     * @returns @type QueryOptionsBuilder for fluent interface.\n     */\n    setLimit(val) {\n        this._options.limit = val;\n        return this;\n    }\n    /**\n     * Specify row format returned by concurrent query manager.\n     * @param val @enum QueryRowFormat specifying format for result.\n     * @returns @type QueryOptionsBuilder for fluent interface.\n     */\n    setRowFormat(val) {\n        this._options.rowFormat = val;\n        return this;\n    }\n    /**\n     * @internal\n     * Defers execution of query in queue by specified milliseconds. This parameter is ignored by default unless concurrent query is configure to not ignore it.\n     * @param val Number of milliseconds.\n     * @returns @type QueryOptionsBuilder for fluent interface.\n     */\n    setDelay(val) {\n        this._options.delay = val;\n        return this;\n    }\n}\n/** @beta */\nexport class BlobOptionsBuilder {\n    constructor(_options = {}) {\n        this._options = _options;\n    }\n    getOptions() { return this._options; }\n    /**\n     * @internal\n     * Allow to set priority of blob request. Blob request will be inserted int queue base on priority value. This value will be ignored if concurrent query is configured with ignored priority is true.\n     * @param val integer value which can be negative as well. By default its zero.\n     * @returns @type BlobOptionsBuilder for fluent interface.\n     */\n    setPriority(val) {\n        this._options.priority = val;\n        return this;\n    }\n    /**\n     * Allow to set restart token. If restart token is set then any other blob request in queue with same token is cancelled if its not already executed.\n     * @param val A string token identifying a use case in which previous blob request with same token is cancelled.\n     * @returns @type BlobOptionsBuilder for fluent interface.\n     */\n    setRestartToken(val) {\n        this._options.restartToken = val;\n        return this;\n    }\n    /**\n     * Allow to set quota restriction for blob request. Its a hint and may be overriden or ignored by concurrent query manager.\n     * @param val @type QueryQuota Specify time and memory that can be used by a query.\n     * @returns @type BlobOptionsBuilder for fluent interface.\n     */\n    setQuota(val) {\n        this._options.quota = val;\n        return this;\n    }\n    /**\n     * Force a blob request to be executed synchronously against primary connection. This option is ignored if provided by frontend.\n     * @param val A boolean value to force use primary connection on main thread to execute blob request.\n     * @returns @type BlobOptionsBuilder for fluent interface.\n     */\n    setUsePrimaryConnection(val) {\n        this._options.usePrimaryConn = val;\n        return this;\n    }\n    /**\n     * Specify range with in the blob that need to be returned.\n     * @param val Specify offset and count of bytes that need to be returned.\n     * @returns @type BlobOptionsBuilder for fluent interface.\n     */\n    setRange(val) {\n        this._options.range = val;\n        return this;\n    }\n    /**\n     * @internal\n     * Defers execution of blob request in queue by specified milliseconds. This parameter is ignored by default unless concurrent query is configure to not ignore it.\n     * @param val Number of milliseconds.\n     * @returns @type BlobOptionsBuilder for fluent interface.\n     */\n    setDelay(val) {\n        this._options.delay = val;\n        return this;\n    }\n}\n/** @internal */\nvar QueryParamType;\n(function (QueryParamType) {\n    QueryParamType[QueryParamType[\"Boolean\"] = 0] = \"Boolean\";\n    QueryParamType[QueryParamType[\"Double\"] = 1] = \"Double\";\n    QueryParamType[QueryParamType[\"Id\"] = 2] = \"Id\";\n    QueryParamType[QueryParamType[\"IdSet\"] = 3] = \"IdSet\";\n    QueryParamType[QueryParamType[\"Integer\"] = 4] = \"Integer\";\n    QueryParamType[QueryParamType[\"Long\"] = 5] = \"Long\";\n    QueryParamType[QueryParamType[\"Null\"] = 6] = \"Null\";\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    QueryParamType[QueryParamType[\"Point2d\"] = 7] = \"Point2d\";\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    QueryParamType[QueryParamType[\"Point3d\"] = 8] = \"Point3d\";\n    QueryParamType[QueryParamType[\"String\"] = 9] = \"String\";\n    QueryParamType[QueryParamType[\"Blob\"] = 10] = \"Blob\";\n    QueryParamType[QueryParamType[\"Struct\"] = 11] = \"Struct\";\n})(QueryParamType || (QueryParamType = {}));\n/**\n * Bind values to an ECSQL query.\n *\n * All binding class methods accept an `indexOrName` parameter as a `string | number` type and a value to bind to it.\n * A binding must be mapped either by a positional index or a string/name. See the examples below.\n *\n * @example\n * Parameter By Index:\n * ```sql\n * SELECT a, v FROM test.Foo WHERE a=? AND b=?\n * ```\n * The first `?` is index 1 and the second `?` is index 2. The parameter index starts with 1 and not 0.\n *\n * @example\n * Parameter By Name:\n * ```sql\n * SELECT a, v FROM test.Foo WHERE a=:name_a AND b=:name_b\n * ```\n * Using \"name_a\" as the `indexOrName` will bind the provided value to `name_a` in the query. And the same goes for\n * using \"name_b\" and the `name_b` binding respectively.\n *\n * @see\n * - [ECSQL Parameters]($docs/learning/ECSQL.md#ecsql-parameters)\n * - [ECSQL Parameter Types]($docs/learning/ECSQLParameterTypes)\n * - [ECSQL Code Examples]($docs/learning/backend/ECSQLCodeExamples#parameter-bindings)\n *\n * @public\n */\nexport class QueryBinder {\n    constructor() {\n        this._args = {};\n    }\n    verify(indexOrName) {\n        if (typeof indexOrName === \"number\") {\n            if (indexOrName < 1)\n                throw new Error(\"expect index to be >= 1\");\n        }\n        if (typeof indexOrName === \"string\") {\n            if (!/^[a-zA-Z_]+\\w*$/i.test(indexOrName)) {\n                throw new Error(\"expect named parameter to meet identifier specification\");\n            }\n        }\n    }\n    /**\n     * Bind boolean value to ECSQL statement.\n     * @param indexOrName Specify parameter index or its name used in ECSQL statement.\n     * @param val Boolean value to bind to ECSQL statement.\n     * @returns @type QueryBinder to allow fluent interface.\n     */\n    bindBoolean(indexOrName, val) {\n        this.verify(indexOrName);\n        const name = String(indexOrName);\n        Object.defineProperty(this._args, name, {\n            enumerable: true,\n            value: {\n                type: QueryParamType.Boolean,\n                value: val,\n            },\n        });\n        return this;\n    }\n    /**\n     * Bind blob value to ECSQL statement.\n     * @param indexOrName Specify parameter index or its name used in ECSQL statement.\n     * @param val Blob value to bind to ECSQL statement.\n     * @returns @type QueryBinder to allow fluent interface.\n     */\n    bindBlob(indexOrName, val) {\n        this.verify(indexOrName);\n        const name = String(indexOrName);\n        const base64 = Base64.fromUint8Array(val);\n        Object.defineProperty(this._args, name, {\n            enumerable: true, value: {\n                type: QueryParamType.Blob,\n                value: base64,\n            },\n        });\n        return this;\n    }\n    /**\n     * Bind double value to ECSQL statement.\n     * @param indexOrName Specify parameter index or its name used in ECSQL statement.\n     * @param val Double value to bind to ECSQL statement.\n     * @returns @type QueryBinder to allow fluent interface.\n     */\n    bindDouble(indexOrName, val) {\n        this.verify(indexOrName);\n        const name = String(indexOrName);\n        Object.defineProperty(this._args, name, {\n            enumerable: true, value: {\n                type: QueryParamType.Double,\n                value: val,\n            },\n        });\n        return this;\n    }\n    /**\n     * Bind @typedef Id64String value to ECSQL statement.\n     * @param indexOrName Specify parameter index or its name used in ECSQL statement.\n     * @param val @typedef Id64String value to bind to ECSQL statement.\n     * @returns @type QueryBinder to allow fluent interface.\n     */\n    bindId(indexOrName, val) {\n        this.verify(indexOrName);\n        const name = String(indexOrName);\n        Object.defineProperty(this._args, name, {\n            enumerable: true, value: {\n                type: QueryParamType.Id,\n                value: val,\n            },\n        });\n        return this;\n    }\n    /**\n     * Bind @type OrderedId64Iterable to ECSQL statement.\n     * @param indexOrName Specify parameter index or its name used in ECSQL statement.\n     * @param val @type OrderedId64Iterable value to bind to ECSQL statement.\n     * @returns @type QueryBinder to allow fluent interface.\n     */\n    bindIdSet(indexOrName, val) {\n        this.verify(indexOrName);\n        const name = String(indexOrName);\n        OrderedId64Iterable.uniqueIterator(val);\n        Object.defineProperty(this._args, name, {\n            enumerable: true, value: {\n                type: QueryParamType.IdSet,\n                value: CompressedId64Set.sortAndCompress(OrderedId64Iterable.uniqueIterator(val)),\n            },\n        });\n        return this;\n    }\n    /**\n     * Bind integer to ECSQL statement.\n     * @param indexOrName Specify parameter index or its name used in ECSQL statement.\n     * @param val Integer value to bind to ECSQL statement.\n     * @returns @type QueryBinder to allow fluent interface.\n     */\n    bindInt(indexOrName, val) {\n        this.verify(indexOrName);\n        const name = String(indexOrName);\n        Object.defineProperty(this._args, name, {\n            enumerable: true, value: {\n                type: QueryParamType.Integer,\n                value: val,\n            },\n        });\n        return this;\n    }\n    /**\n     * Bind struct to ECSQL statement. Struct specified as object.\n     * @param indexOrName Specify parameter index or its name used in ECSQL statement.\n     * @param val struct value to bind to ECSQL statement.\n     * @returns @type QueryBinder to allow fluent interface.\n     */\n    bindStruct(indexOrName, val) {\n        this.verify(indexOrName);\n        const name = String(indexOrName);\n        Object.defineProperty(this._args, name, {\n            enumerable: true, value: {\n                type: QueryParamType.Struct,\n                value: val,\n            },\n        });\n        return this;\n    }\n    /**\n     * Bind long to ECSQL statement.\n     * @param indexOrName Specify parameter index or its name used in ECSQL statement.\n     * @param val Long value to bind to ECSQL statement.\n     * @returns @type QueryBinder to allow fluent interface.\n     */\n    bindLong(indexOrName, val) {\n        this.verify(indexOrName);\n        const name = String(indexOrName);\n        Object.defineProperty(this._args, name, {\n            enumerable: true, value: {\n                type: QueryParamType.Long,\n                value: val,\n            },\n        });\n        return this;\n    }\n    /**\n     * Bind string to ECSQL statement.\n     * @param indexOrName Specify parameter index or its name used in ECSQL statement.\n     * @param val String value to bind to ECSQL statement.\n     * @returns @type QueryBinder to allow fluent interface.\n     */\n    bindString(indexOrName, val) {\n        this.verify(indexOrName);\n        const name = String(indexOrName);\n        Object.defineProperty(this._args, name, {\n            enumerable: true, value: {\n                type: QueryParamType.String,\n                value: val,\n            },\n        });\n        return this;\n    }\n    /**\n     * Bind null to ECSQL statement.\n     * @param indexOrName Specify parameter index or its name used in ECSQL statement.\n     * @returns @type QueryBinder to allow fluent interface.\n     */\n    bindNull(indexOrName) {\n        this.verify(indexOrName);\n        const name = String(indexOrName);\n        Object.defineProperty(this._args, name, {\n            enumerable: true, value: {\n                type: QueryParamType.Null,\n                value: null,\n            },\n        });\n        return this;\n    }\n    /**\n     * Bind @type Point2d to ECSQL statement.\n     * @param indexOrName Specify parameter index or its name used in ECSQL statement.\n     * @param val @type Point2d  value to bind to ECSQL statement.\n     * @returns @type QueryBinder to allow fluent interface.\n     */\n    bindPoint2d(indexOrName, val) {\n        this.verify(indexOrName);\n        const name = String(indexOrName);\n        Object.defineProperty(this._args, name, {\n            enumerable: true, value: {\n                type: QueryParamType.Point2d,\n                value: val,\n            },\n        });\n        return this;\n    }\n    /**\n     * Bind @type Point3d to ECSQL statement.\n     * @param indexOrName Specify parameter index or its name used in ECSQL statement.\n     * @param val @type Point3d  value to bind to ECSQL statement.\n     * @returns @type QueryBinder to allow fluent interface.\n     */\n    bindPoint3d(indexOrName, val) {\n        this.verify(indexOrName);\n        const name = String(indexOrName);\n        Object.defineProperty(this._args, name, {\n            enumerable: true, value: {\n                type: QueryParamType.Point3d,\n                value: val,\n            },\n        });\n        return this;\n    }\n    static bind(params, nameOrId, val) {\n        if (typeof val === \"boolean\") {\n            params.bindBoolean(nameOrId, val);\n        }\n        else if (typeof val === \"number\") {\n            params.bindDouble(nameOrId, val);\n        }\n        else if (typeof val === \"string\") {\n            params.bindString(nameOrId, val);\n        }\n        else if (val instanceof Uint8Array) {\n            params.bindBlob(nameOrId, val);\n        }\n        else if (val instanceof Point2d) {\n            params.bindPoint2d(nameOrId, val);\n        }\n        else if (val instanceof Point3d) {\n            params.bindPoint3d(nameOrId, val);\n        }\n        else if (val instanceof Array && val.length > 0 && typeof val[0] === \"string\" && Id64.isValidId64(val[0])) {\n            params.bindIdSet(nameOrId, val);\n        }\n        else if (typeof val === \"object\" && !Array.isArray(val)) {\n            params.bindStruct(nameOrId, val);\n        }\n        else if (typeof val === \"undefined\" || val === null) {\n            params.bindNull(nameOrId);\n        }\n        else {\n            throw new Error(\"unsupported type\");\n        }\n    }\n    /**\n     * Allow bulk bind either parameters by index as value array or by parameter names as object.\n     * @param args if array of values is provided then array index is used as index. If object is provided then object property name is used as parameter name of reach value.\n     * @returns @type QueryBinder to allow fluent interface.\n     */\n    static from(args) {\n        const params = new QueryBinder();\n        if (typeof args === \"undefined\")\n            return params;\n        if (Array.isArray(args)) {\n            let i = 1;\n            for (const val of args) {\n                this.bind(params, i++, val);\n            }\n        }\n        else {\n            for (const prop of Object.getOwnPropertyNames(args)) {\n                this.bind(params, prop, args[prop]);\n            }\n        }\n        return params;\n    }\n    serialize() {\n        return this._args;\n    }\n}\n/** @internal */\nexport var DbRequestKind;\n(function (DbRequestKind) {\n    DbRequestKind[DbRequestKind[\"BlobIO\"] = 0] = \"BlobIO\";\n    DbRequestKind[DbRequestKind[\"ECSql\"] = 1] = \"ECSql\";\n})(DbRequestKind || (DbRequestKind = {}));\n/** @internal */\nexport var DbResponseKind;\n(function (DbResponseKind) {\n    DbResponseKind[DbResponseKind[\"BlobIO\"] = 0] = \"BlobIO\";\n    DbResponseKind[DbResponseKind[\"ECSql\"] = 1] = \"ECSql\";\n    DbResponseKind[DbResponseKind[\"NoResult\"] = 2] = \"NoResult\";\n})(DbResponseKind || (DbResponseKind = {}));\n/** @internal */\nexport var DbResponseStatus;\n(function (DbResponseStatus) {\n    DbResponseStatus[DbResponseStatus[\"Done\"] = 1] = \"Done\";\n    DbResponseStatus[DbResponseStatus[\"Cancel\"] = 2] = \"Cancel\";\n    DbResponseStatus[DbResponseStatus[\"Partial\"] = 3] = \"Partial\";\n    DbResponseStatus[DbResponseStatus[\"Timeout\"] = 4] = \"Timeout\";\n    DbResponseStatus[DbResponseStatus[\"QueueFull\"] = 5] = \"QueueFull\";\n    DbResponseStatus[DbResponseStatus[\"Error\"] = 100] = \"Error\";\n    DbResponseStatus[DbResponseStatus[\"Error_ECSql_PreparedFailed\"] = 101] = \"Error_ECSql_PreparedFailed\";\n    DbResponseStatus[DbResponseStatus[\"Error_ECSql_StepFailed\"] = 102] = \"Error_ECSql_StepFailed\";\n    DbResponseStatus[DbResponseStatus[\"Error_ECSql_RowToJsonFailed\"] = 103] = \"Error_ECSql_RowToJsonFailed\";\n    DbResponseStatus[DbResponseStatus[\"Error_ECSql_BindingFailed\"] = 104] = \"Error_ECSql_BindingFailed\";\n    DbResponseStatus[DbResponseStatus[\"Error_BlobIO_OpenFailed\"] = 105] = \"Error_BlobIO_OpenFailed\";\n    DbResponseStatus[DbResponseStatus[\"Error_BlobIO_OutOfRange\"] = 106] = \"Error_BlobIO_OutOfRange\";\n})(DbResponseStatus || (DbResponseStatus = {}));\n/** @internal */\nexport var DbValueFormat;\n(function (DbValueFormat) {\n    DbValueFormat[DbValueFormat[\"ECSqlNames\"] = 0] = \"ECSqlNames\";\n    DbValueFormat[DbValueFormat[\"JsNames\"] = 1] = \"JsNames\";\n})(DbValueFormat || (DbValueFormat = {}));\n/** @public */\nexport class DbQueryError extends BentleyError {\n    constructor(response, request, rc) {\n        super(rc ?? DbResult.BE_SQLITE_ERROR, response.error, { response, request });\n        this.response = response;\n        this.request = request;\n    }\n    static throwIfError(response, request) {\n        if (response.status >= DbResponseStatus.Error) {\n            throw new DbQueryError(response, request);\n        }\n        if (response.status === DbResponseStatus.Cancel) {\n            throw new DbQueryError(response, request, DbResult.BE_SQLITE_INTERRUPT);\n        }\n    }\n}\n//# sourceMappingURL=ConcurrentQuery.js.map",
      "start": 1693508120921,
      "end": 1693508120965,
      "sourcemaps": null
    }
  ]
}
