{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend-devtools/lib/esm/effects/Explosion.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Effects\n */\nimport { Point3d, Range1d, Vector3d } from \"@itwin/core-geometry\";\nimport { TextureTransparency } from \"@itwin/core-common\";\nimport { GraphicType, imageElementFromUrl, IModelApp, ParticleCollectionBuilder, Tool, } from \"@itwin/core-frontend\";\nimport { randomFloat, randomFloatInRange, randomIntegerInRange, randomPositionInRange } from \"./Random\";\n/** Represents one particle in the system. */\nclass Particle {\n    get x() { return this.position.x; }\n    get y() { return this.position.y; }\n    get z() { return this.position.z; }\n    constructor(position, velocity, lifetime, size) {\n        /** Current age in seconds, incremented each frame. */\n        this.age = 0;\n        /** Particle transparency in [0..255]. */\n        this.transparency = 0;\n        this.position = position;\n        this.velocity = velocity;\n        this.lifetime = lifetime;\n        this.size = size;\n    }\n    get isExpired() { return this.age >= this.lifetime; }\n}\n/** Emits particles in a sphere with its center at the origin.\n * Each particle is emitted from the center of the sphere with random velocity toward the surface of the sphere.\n */\nclass ParticleEmitter {\n    constructor() {\n        /** Range from which each particle's initial speed in meters per second will be selected. */\n        this.speedRange = Range1d.createXX(1, 2);\n        /** Range from which each particle's lifetime in seconds will be selected. */\n        this.lifetimeRange = Range1d.createXX(5, 10);\n        /** Range from which each particle's size in meters will be selected. */\n        this.sizeRange = Range1d.createXX(0.2, 1.0);\n        /** Range from which the number of particles emitted will be selected. */\n        this.numParticlesRange = Range1d.createXX(1600, 2200);\n    }\n    /** Emit an explosion of particles from the center of the sphere. */\n    emit() {\n        const particles = [];\n        const numParticles = randomIntegerInRange(this.numParticlesRange);\n        for (let i = 0; i < numParticles; i++) {\n            const velocity = new Vector3d(randomFloat(-1.0, 1.0), randomFloat(-1.0, 1.0), randomFloat(-1.0, 1.0));\n            velocity.normalizeInPlace();\n            velocity.scaleInPlace(randomFloatInRange(this.speedRange));\n            const lifetime = randomFloatInRange(this.lifetimeRange);\n            const size = randomFloatInRange(this.sizeRange);\n            particles.push(new Particle(new Point3d(0, 0, 0), velocity, lifetime, size));\n        }\n        return particles;\n    }\n}\nclass ParticleSystem {\n    constructor(texture, iModel, numEmissions) {\n        this._emitter = new ParticleEmitter();\n        this._particles = [];\n        this._scratchVector3d = new Vector3d();\n        /** Acceleration in Z applied to particles, in meters per second squared. */\n        this.gravity = -3;\n        this._texture = texture;\n        this._pickableId = iModel.transientIds.getNext();\n        this._numEmissions = numEmissions;\n        this._lastUpdateTime = Date.now();\n        this._origin = randomPositionInRange(iModel.projectExtents);\n        this._dispose = iModel.onClose.addListener(() => this.dispose());\n    }\n    dispose() {\n        if (this._dispose) {\n            this._dispose();\n            this._dispose = undefined;\n        }\n        IModelApp.viewManager.dropDecorator(this);\n        this._texture.dispose();\n    }\n    update() {\n        const now = Date.now();\n        let deltaMillis = now - this._lastUpdateTime;\n        deltaMillis = Math.min(100, deltaMillis);\n        this._lastUpdateTime = now;\n        let numParticles = this._particles.length;\n        if (numParticles === 0) {\n            this._numEmissions--;\n            if (this._numEmissions < 0)\n                this.dispose();\n            else\n                this._particles = this._emitter.emit();\n            return;\n        }\n        const elapsedSeconds = deltaMillis / 1000;\n        for (let i = 0; i < numParticles; i++) {\n            const particle = this._particles[i];\n            this.updateParticle(particle, elapsedSeconds);\n            if (particle.isExpired) {\n                this._particles[i] = this._particles[numParticles - 1];\n                --i;\n                --numParticles;\n            }\n        }\n        this._particles.length = numParticles;\n    }\n    updateParticle(particle, elapsedSeconds) {\n        const velocity = particle.velocity.clone(this._scratchVector3d);\n        velocity.scale(elapsedSeconds, velocity);\n        velocity.z += elapsedSeconds * this.gravity;\n        particle.position.addInPlace(velocity);\n        particle.transparency = 255 * (particle.age / particle.lifetime);\n        particle.age += elapsedSeconds;\n    }\n    decorate(context) {\n        if (!context.viewport.view.isSpatialView())\n            return;\n        this.update();\n        const builder = ParticleCollectionBuilder.create({\n            viewport: context.viewport,\n            texture: this._texture,\n            size: (this._emitter.sizeRange.high - this._emitter.sizeRange.low) / 2,\n            transparency: 0,\n            origin: this._origin,\n            pickableId: this._pickableId,\n        });\n        for (const particle of this._particles)\n            builder.addParticle(particle);\n        const graphic = builder.finish();\n        if (graphic) {\n            context.addDecoration(GraphicType.WorldDecoration, graphic);\n            context.viewport.onRender.addOnce((vp) => vp.invalidateDecorations());\n        }\n    }\n    testDecorationHit(id) {\n        return id === this._pickableId;\n    }\n    async getDecorationToolTip(_hit) {\n        return \"Explosion effect\";\n    }\n    static async addDecorator(iModel) {\n        // Note: The decorator takes ownership of the texture, and disposes of it when the decorator is disposed.\n        const image = await imageElementFromUrl(`${IModelApp.publicPath}sprites/particle_explosion.png`);\n        const texture = IModelApp.renderSystem.createTexture({\n            ownership: \"external\",\n            image: { source: image, transparency: TextureTransparency.Mixed },\n        });\n        if (texture)\n            IModelApp.viewManager.addDecorator(new ParticleSystem(texture, iModel, randomIntegerInRange(this.numEmissionsRange)));\n    }\n}\nParticleSystem.numEmissionsRange = Range1d.createXX(1, 5);\n/** This tool applies an explosion particle effect used for testing [ParticleCollectionBuilder]($frontend).\n * @beta\n */\nclass ExplosionEffect extends Tool {\n    /** This method runs the tool, applying an explosion particle effect. */\n    async run() {\n        const vp = IModelApp.viewManager.selectedView;\n        if (vp)\n            await ParticleSystem.addDecorator(vp.iModel);\n        return true;\n    }\n}\nExplosionEffect.toolId = \"ExplosionEffect\";\nexport { ExplosionEffect };\n//# sourceMappingURL=Explosion.js.map",
      "start": 1693508122582,
      "end": 1693508122685,
      "sourcemaps": null
    }
  ]
}
