{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/geometry3d/Transform.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module CartesianGeometry\n */\nimport { AxisOrder, Geometry } from \"../Geometry\";\nimport { Point4d } from \"../geometry4d/Point4d\";\nimport { Matrix3d } from \"./Matrix3d\";\nimport { Point2d } from \"./Point2dVector2d\";\nimport { Point3d, Vector3d } from \"./Point3dVector3d\";\nimport { Range3d } from \"./Range\";\n/**\n * A Transform consists of an origin and a Matrix3d. This describes a coordinate frame with this origin, with\n * the columns of the Matrix3d being the local x,y,z axis directions.\n * * The math for a Transform `T` consisting of a Matrix3d `M` and a Point3d `o` on a Vector3d `p` is: `Tp = M*p + o`.\n * In other words, `T` is a combination of two operations on `p`: the action of matrix multiplication, followed by a\n * translation. `Origin` is a traditional term for `o`, because `T` can be interpreted as a change of basis from the\n * global axes centered at the global origin, to a new set of axes specified by matrix M columns centered at `o`.\n * * Beware that for common transformations (e.g. scale about point, rotate around an axis) the `fixed point` that\n * is used when describing the transform is NOT the `origin` stored in the transform. Setup methods (e.g\n * createFixedPointAndMatrix, createScaleAboutPoint) take care of determining the appropriate origin coordinates.\n * * If `T` is a translation, no point is fixed by `T`.\n * * If `T` is the identity, all points are fixed by `T`.\n * * If `T` is a scale about a point, one point is fixed by `T`.\n * * If `T` is a rotation about an axis, a line is fixed by `T`.\n * * If `T` is a projection to the plane, a plane is fixed by `T`.\n * @public\n */\nexport class Transform {\n    // Constructor accepts and uses pointer to content (no copy is done here).\n    constructor(origin, matrix) {\n        this._origin = origin;\n        this._matrix = matrix;\n    }\n    /** The identity Transform. Value is frozen and cannot be modified. */\n    static get identity() {\n        if (undefined === this._identity) {\n            this._identity = Transform.createIdentity();\n            this._identity.freeze();\n        }\n        return this._identity;\n    }\n    /** Freeze this instance (and its members) so it is read-only */\n    freeze() {\n        this._origin.freeze();\n        this._matrix.freeze();\n        return Object.freeze(this);\n    }\n    /**\n     * Copy contents from other Transform into this Transform\n     * @param other source transform\n     */\n    setFrom(other) {\n        this._origin.setFrom(other._origin);\n        this._matrix.setFrom(other._matrix);\n    }\n    /** Set this Transform to be an identity. */\n    setIdentity() {\n        this._origin.setZero();\n        this._matrix.setIdentity();\n    }\n    /**\n     * Set this Transform instance from flexible inputs:\n     * * Any object (such as another Transform or TransformProps) that has `origin` and `matrix` members\n     * accepted by `Point3d.setFromJSON` and `Matrix3d.setFromJSON`\n     * * An array of 3 number arrays, each with 4 entries which are rows in a 3x4 matrix.\n     * * An array of 12 numbers, each block of 4 entries as a row 3x4 matrix.\n     * * If no input is provided, the identity Transform is returned.\n     */\n    setFromJSON(json) {\n        if (json) {\n            if (json instanceof Object && json.origin && json.matrix) {\n                this._origin.setFromJSON(json.origin);\n                this._matrix.setFromJSON(json.matrix);\n                return;\n            }\n            if (Geometry.isArrayOfNumberArray(json, 3, 4)) {\n                const data = json;\n                this._matrix.setRowValues(data[0][0], data[0][1], data[0][2], data[1][0], data[1][1], data[1][2], data[2][0], data[2][1], data[2][2]);\n                this._origin.set(data[0][3], data[1][3], data[2][3]);\n                return;\n            }\n            if (Geometry.isNumberArray(json, 12)) {\n                const data = json;\n                this._matrix.setRowValues(data[0], data[1], data[2], data[4], data[5], data[6], data[8], data[9], data[10]);\n                this._origin.set(data[3], data[7], data[11]);\n                return;\n            }\n        }\n        this.setIdentity();\n    }\n    /**\n     * Test for near equality with `other` Transform. Comparison uses the `isAlmostEqual` methods on the `origin` and\n     * `matrix` parts.\n     * @param other Transform to compare to.\n     */\n    isAlmostEqual(other) {\n        return this.origin.isAlmostEqual(other.origin) && this.matrix.isAlmostEqual(other.matrix);\n    }\n    /**\n     * Test for near equality with `other` Transform. Comparison uses the `isAlmostEqual` methods on the `origin` part\n     * and the `isAlmostEqualAllowZRotation` method on the `matrix` part.\n     * @param other Transform to compare to.\n     */\n    isAlmostEqualAllowZRotation(other) {\n        return this._origin.isAlmostEqual(other._origin) && this._matrix.isAlmostEqualAllowZRotation(other._matrix);\n    }\n    /**\n     * Return a 3 by 4 matrix containing the rows of this Transform.\n     * * The transform's origin coordinates are the last entries of the 3 json arrays\n     */\n    toRows() {\n        return [\n            [this._matrix.coffs[0], this._matrix.coffs[1], this._matrix.coffs[2], this._origin.x],\n            [this._matrix.coffs[3], this._matrix.coffs[4], this._matrix.coffs[5], this._origin.y],\n            [this._matrix.coffs[6], this._matrix.coffs[7], this._matrix.coffs[8], this._origin.z],\n        ];\n    }\n    /**\n     * Return a 3 by 4 matrix containing the rows of this Transform.\n     * * The transform's origin coordinates are the last entries of the 3 json arrays\n    */\n    toJSON() {\n        return this.toRows();\n    }\n    /** Return a new Transform initialized by `Transform.setFromJSON` */\n    static fromJSON(json) {\n        const result = Transform.createIdentity();\n        result.setFromJSON(json);\n        return result;\n    }\n    /** Copy the contents of `this` transform into a new Transform (or to the result, if specified). */\n    clone(result) {\n        if (result) {\n            result._matrix.setFrom(this._matrix);\n            result._origin.setFrom(this._origin);\n            return result;\n        }\n        return new Transform(Point3d.createFrom(this._origin), this._matrix.clone());\n    }\n    /**\n     * Return a modified copy of `this` Transform so that its `matrix` part is rigid (`origin` part is untouched).\n     * * @see [[Matrix3d.axisOrderCrossProductsInPlace]] documentation for details of how the matrix is modified to rigid.\n     */\n    cloneRigid(axisOrder = AxisOrder.XYZ) {\n        const modifiedMatrix = Matrix3d.createRigidFromMatrix3d(this.matrix, axisOrder);\n        if (!modifiedMatrix)\n            return undefined;\n        return new Transform(this.origin.cloneAsPoint3d(), modifiedMatrix);\n    }\n    /** Create a Transform with the given `origin` and `matrix`. Inputs are captured, not cloned. */\n    static createRefs(origin, matrix, result) {\n        if (!origin)\n            origin = Point3d.createZero();\n        if (result) {\n            result._origin = origin;\n            result._matrix = matrix;\n            return result;\n        }\n        return new Transform(origin, matrix);\n    }\n    /** Create a Transform with complete contents given. `q` inputs make the matrix and `a` inputs make the origin */\n    static createRowValues(qxx, qxy, qxz, ax, qyx, qyy, qyz, ay, qzx, qzy, qzz, az, result) {\n        if (result) {\n            result._origin.set(ax, ay, az);\n            result._matrix.setRowValues(qxx, qxy, qxz, qyx, qyy, qyz, qzx, qzy, qzz);\n            return result;\n        }\n        return new Transform(Point3d.create(ax, ay, az), Matrix3d.createRowValues(qxx, qxy, qxz, qyx, qyy, qyz, qzx, qzy, qzz));\n    }\n    /** Create a Transform with all zeros */\n    static createZero(result) {\n        return Transform.createRowValues(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, result);\n    }\n    /**\n     * Create a Transform with translation provided by x,y,z parts.\n     * * Translation Transform maps any vector `v` to `v + p` where `p = (x,y,z)`\n     * * Visualization can be found at https://www.itwinjs.org/sandbox/SaeedTorabi/CubeTransform\n     * @param x x part of translation\n     * @param y y part of translation\n     * @param z z part of translation\n     * @param result optional pre-allocated Transform\n     * @returns new or updated transform\n     */\n    static createTranslationXYZ(x = 0, y = 0, z = 0, result) {\n        return Transform.createRefs(Vector3d.create(x, y, z), Matrix3d.createIdentity(), result);\n    }\n    /**\n     * Create a Transform with specified `translation` part.\n     * * Translation Transform maps any vector `v` to `v + translation`\n     * * Visualization can be found at https://www.itwinjs.org/sandbox/SaeedTorabi/CubeTransform\n     * @param translation x,y,z parts of the translation\n     * @param result optional pre-allocated Transform\n     * @returns new or updated transform\n     */\n    static createTranslation(translation, result) {\n        return Transform.createRefs(translation, Matrix3d.createIdentity(), result);\n    }\n    /** Return a reference (and NOT a copy) to the `matrix` part of the Transform. */\n    get matrix() {\n        return this._matrix;\n    }\n    /** Return a reference (and NOT a copy) to the `origin` part of the Transform. */\n    get origin() {\n        return this._origin;\n    }\n    /** return a (clone of) the `origin` part of the Transform, as a `Point3d` */\n    getOrigin() {\n        return Point3d.createFrom(this._origin);\n    }\n    /** return a (clone of) the `origin` part of the Transform, as a `Vector3d` */\n    getTranslation() {\n        return Vector3d.createFrom(this._origin);\n    }\n    /** return a (clone of) the `matrix` part of the Transform, as a `Matrix3d` */\n    getMatrix() {\n        return this._matrix.clone();\n    }\n    /** test if the transform has `origin` = (0,0,0) and identity `matrix` */\n    get isIdentity() {\n        return this._matrix.isIdentity && this._origin.isAlmostZero;\n    }\n    /** Create an identity transform */\n    static createIdentity(result) {\n        if (result) {\n            result._origin.setZero();\n            result._matrix.setIdentity();\n            return result;\n        }\n        return Transform.createRefs(Point3d.createZero(), Matrix3d.createIdentity());\n    }\n    /**\n     * Create a Transform using the given `origin` and `matrix`.\n     * * This is a the appropriate construction when the columns of the matrix are coordinate axes of a\n     * local-to-world mapping.\n     * * This function is a closely related to `createFixedPointAndMatrix` whose point input is the fixed point\n     * of the world-to-world transformation.\n     * * If origin is `undefined`, (0,0,0) is used. If matrix is `undefined` the identity matrix is used.\n     */\n    static createOriginAndMatrix(origin, matrix, result) {\n        if (result) {\n            result._origin.setFromPoint3d(origin);\n            result._matrix.setFrom(matrix);\n            return result;\n        }\n        return Transform.createRefs(origin ? origin.cloneAsPoint3d() : Point3d.createZero(), matrix === undefined ? Matrix3d.createIdentity() : matrix.clone(), result);\n    }\n    /** Create a Transform using the given `origin` and columns of the `matrix`. If `undefined` zero is used. */\n    setOriginAndMatrixColumns(origin, vectorX, vectorY, vectorZ) {\n        if (origin !== undefined)\n            this._origin.setFrom(origin);\n        this._matrix.setColumns(vectorX, vectorY, vectorZ);\n    }\n    /** Create a Transform using the given `origin` and columns of the `matrix` */\n    static createOriginAndMatrixColumns(origin, vectorX, vectorY, vectorZ, result) {\n        if (result)\n            result.setOriginAndMatrixColumns(origin, vectorX, vectorY, vectorZ);\n        else\n            result = Transform.createRefs(Vector3d.createFrom(origin), Matrix3d.createColumns(vectorX, vectorY, vectorZ));\n        return result;\n    }\n    /**\n     * Create a Transform such that its `matrix` part is rigid.\n     * @see [[Matrix3d.createRigidFromColumns]] for details of how the matrix is created to be rigid.\n     */\n    static createRigidFromOriginAndColumns(origin, vectorX, vectorY, axisOrder, result) {\n        const matrix = Matrix3d.createRigidFromColumns(vectorX, vectorY, axisOrder, result ? result._matrix : undefined);\n        if (!matrix)\n            return undefined;\n        if (result) {\n            // result._matrix was already modified to become rigid via createRigidFromColumns\n            result._origin.setFrom(origin);\n            return result;\n        }\n        /**\n         * We don't want to pass \"origin\" to createRefs because createRefs does not clone \"origin\". That means if \"origin\"\n         * is changed via Transform at any point, the initial \"origin\" passed by the user is also changed. To avoid that,\n         * we pass \"undefined\" to createRefs so that it allocates a new point which then we set it to the \"origin\" which\n         * is passed by user in the next line.\n         */\n        result = Transform.createRefs(undefined, matrix);\n        result._origin.setFromPoint3d(origin);\n        return result;\n    }\n    /**\n     * Create a Transform with the specified `matrix`. Compute an `origin` (different from the given `fixedPoint`)\n     * so that the `fixedPoint` maps back to itself. The returned Transform, transforms a point `p` to `M*p + (f - M*f)`\n     * where `f` is the fixedPoint (i.e., `Tp = M*(p-f) + f`).\n     */\n    static createFixedPointAndMatrix(fixedPoint, matrix, result) {\n        if (fixedPoint) {\n            /**\n             * if f is a fixed point, then Tf = M*f + o = f where M is the matrix and o is the origin.\n             * we define the origin o = f - M*f. Therefore, Tf = Mf + o = M*f + (f - M*f) = f.\n             */\n            const origin = Matrix3d.xyzMinusMatrixTimesXYZ(fixedPoint, matrix, fixedPoint);\n            return Transform.createRefs(origin, matrix.clone(), result);\n        }\n        return Transform.createRefs(undefined, matrix.clone());\n    }\n    /**\n     * Create a transform with the specified `matrix` and points `a` and `b`. The returned Transform maps\n     * point `p` to `M*(p-a) + b` (i.e., `Tp = M*(p-a) + b`), so maps `a` to 'b'.\n     */\n    static createMatrixPickupPutdown(matrix, a, b, result) {\n        // we define the origin o = b - M*a so Tp = M*p + o = M*p + (b - M*a) = M*(p-a) + b\n        const origin = Matrix3d.xyzMinusMatrixTimesXYZ(b, matrix, a);\n        return Transform.createRefs(origin, matrix.clone(), result);\n    }\n    /**\n     * Create a Transform which leaves the fixedPoint unchanged and scales everything else around it by\n     * a single scale factor. The returned Transform maps a point `p` to `M*p + (f - M*f)`\n     * where `f` is the fixedPoint and M is the scale matrix (i.e., `Tp = M*(p-f) + f`).\n     * * Visualization can be found at https://www.itwinjs.org/sandbox/SaeedTorabi/CubeTransform\n     */\n    static createScaleAboutPoint(fixedPoint, scale, result) {\n        const matrix = Matrix3d.createScale(scale, scale, scale);\n        /**\n         * if f is a fixed point, then Tf = M*f + o = f where M is the matrix and o is the origin.\n         * we define the origin o = f - M*f. Therefore, Tf = M*f + o = M*f + (f - M*f) = f.\n         */\n        const origin = Matrix3d.xyzMinusMatrixTimesXYZ(fixedPoint, matrix, fixedPoint);\n        return Transform.createRefs(origin, matrix, result);\n    }\n    /**\n     * Return a transformation which flattens space onto a plane, sweeping along a direction which may be different from the plane normal.\n     * @param sweepVector vector for the sweep direction\n     * @param planePoint any point on the plane\n     * @param planeNormal vector normal to the plane.\n     */\n    static createFlattenAlongVectorToPlane(sweepVector, planePoint, planeNormal) {\n        const matrix = Matrix3d.createFlattenAlongVectorToPlane(sweepVector, planeNormal);\n        if (matrix === undefined)\n            return undefined;\n        return Transform.createFixedPointAndMatrix(planePoint, matrix);\n    }\n    /**\n     * Transform the input 2d point (using `Tp = M*p + o`).\n     * Return as a new point or in the pre-allocated result (if result is given).\n     */\n    multiplyPoint2d(point, result) {\n        return Matrix3d.xyPlusMatrixTimesXY(this._origin, this._matrix, point, result);\n    }\n    /**\n     * Transform the input 3d point (using `Tp = M*p + o`).\n     * Return as a new point or in the pre-allocated result (if result is given).\n     */\n    multiplyPoint3d(point, result) {\n        // Tx = Mx + o so we return Mx + o\n        return Matrix3d.xyzPlusMatrixTimesXYZ(this._origin, this._matrix, point, result);\n    }\n    /**\n     * Transform the input 3d point in place (using `Tp = M*p + o`).\n     * Return as a new point or in the pre-allocated result (if result is given).\n     */\n    multiplyXYAndZInPlace(point) {\n        return Matrix3d.xyzPlusMatrixTimesXYZInPlace(this._origin, this._matrix, point);\n    }\n    /**\n     * Transform the input 3d point (using `Tp = M*p + o`).\n     * Return as a new point or in the pre-allocated result (if result is given).\n     */\n    multiplyXYZ(x, y, z = 0, result) {\n        // Tx = Mx + o so we return Mx + o\n        return Matrix3d.xyzPlusMatrixTimesCoordinates(this._origin, this._matrix, x, y, z, result);\n    }\n    /**\n     * Multiply a specific row (component) of the 3x4 instance times (x,y,z,1). Return the result.\n     */\n    multiplyComponentXYZ(componentIndex, x, y, z = 0) {\n        const coffs = this._matrix.coffs;\n        const idx = 3 * componentIndex;\n        return this.origin.at(componentIndex) + (coffs[idx] * x) + (coffs[idx + 1] * y) + (coffs[idx + 2] * z);\n    }\n    /**\n     * Multiply a specific row (component) of the 3x4 instance times (x,y,z,w). Return the result.\n     */\n    multiplyComponentXYZW(componentIndex, x, y, z, w) {\n        const coffs = this._matrix.coffs;\n        const idx = 3 * componentIndex;\n        return (this.origin.at(componentIndex) * w) + (coffs[idx] * x) + (coffs[idx + 1] * y) + (coffs[idx + 2] * z);\n    }\n    /**\n     * Transform the homogeneous point. Return as a new `Point4d`, or in the pre-allocated result (if result is given).\n     * * If `p = (x,y,z)` then this method computes `Tp = M*p + o*w` and returns the `Point4d` formed by `Tp` in the\n     * first three coordinates, and `w` in the fourth.\n     * * Logically, this is multiplication by the 4x4 matrix formed from the 3x4 instance augmented with fourth row 0001.\n     */\n    multiplyXYZW(x, y, z, w, result) {\n        return Matrix3d.xyzPlusMatrixTimesWeightedCoordinates(this._origin, this._matrix, x, y, z, w, result);\n    }\n    /**\n     * Transform the homogeneous point. Return as new `Float64Array` with size 4, or in the pre-allocated result (if\n     * result is given).\n     * * If `p = (x,y,z)` then this method computes `Tp = M*p + o*w` and returns the `Float64Array` formed by `Tp`\n     * in the first 3 numbers of the array and `w` as the fourth.\n     * * Logically, this is multiplication by the 4x4 matrix formed from the 3x4 instance augmented with fourth row 0001.\n     */\n    multiplyXYZWToFloat64Array(x, y, z, w, result) {\n        return Matrix3d.xyzPlusMatrixTimesWeightedCoordinatesToFloat64Array(this._origin, this._matrix, x, y, z, w, result);\n    }\n    /**\n     * * Transform the point. Return as new `Float64Array` with size 3, or in the pre-allocated result (if result is given).\n     * * If `p = (x,y,z)` then this method computes `Tp = M*p + o` and returns it as the first 3 elements of the array.\n     */\n    multiplyXYZToFloat64Array(x, y, z, result) {\n        return Matrix3d.xyzPlusMatrixTimesCoordinatesToFloat64Array(this._origin, this._matrix, x, y, z, result);\n    }\n    /**\n     * Multiply the homogeneous point by the transpose of `this` Transform. Return as a new `Point4d` or in the\n     * pre-allocated result (if result is given).\n     * * If `p = (x,y,z)` then this method computes `M^t*p` and returns it in the first three coordinates of the `Point4d`,\n     * and `o*p + w` in the fourth.\n     * * Logically, this is multiplication by the transpose of the 4x4 matrix formed from the 3x4 instance augmented with\n     * fourth row 0001.\n     */\n    multiplyTransposeXYZW(x, y, z, w, result) {\n        const coffs = this._matrix.coffs;\n        const origin = this._origin;\n        return Point4d.create((x * coffs[0]) + (y * coffs[3]) + (z * coffs[6]), (x * coffs[1]) + (y * coffs[4]) + (z * coffs[7]), (x * coffs[2]) + (y * coffs[5]) + (z * coffs[8]), (x * origin.x) + (y * origin.y) + (z * origin.z) + w, result);\n    }\n    /** For each point in the array, replace point by the transformed point (using `Tp = M*p + o`) */\n    multiplyPoint3dArrayInPlace(points) {\n        let point;\n        for (point of points)\n            Matrix3d.xyzPlusMatrixTimesXYZ(this._origin, this._matrix, point, point);\n    }\n    /** For each point in the 2d array, replace point by the transformed point (using `Tp = M*p + o`) */\n    multiplyPoint3dArrayArrayInPlace(chains) {\n        for (const chain of chains)\n            this.multiplyPoint3dArrayInPlace(chain);\n    }\n    /**\n     * Multiply the point by the inverse Transform.\n     * * If for a point `p` we have `Tp = M*p + o = q`, then `p = MInverse*(q - o) = TInverse q` so `TInverse`\n     * Transform has matrix part `MInverse` and origin part `-MInverse*o`.\n     * * Return as a new point or in the optional `result`.\n     * * Returns `undefined` if the `matrix` part if this Transform is singular.\n     */\n    multiplyInversePoint3d(point, result) {\n        return this._matrix.multiplyInverseXYZAsPoint3d(point.x - this._origin.x, point.y - this._origin.y, point.z - this._origin.z, result);\n    }\n    /**\n     * Multiply the homogenous point by the inverse Transform.\n     * * If for a point `p` we have `Tp = M*p + o = q`, then `p = MInverse*(q - o) = TInverse q` so `TInverse` Transform\n     * has matrix part `MInverse` and origin part `-MInverse*o`.\n     * * This method computes `TInverse p = MInverse*p - w*MInverse*o` and returns the `Point4d` formed by `TInverse*p`\n     * in the first three coordinates, and `w` in the fourth.\n     * * Logically, this is multiplication by the inverse of the 4x4 matrix formed from the 3x4 instance augmented with\n     * fourth row 0001. This is equivalent to the 4x4 matrix formed in similar fashion from the inverse of this instance.\n     * * Return as a new point or in the optional `result`.\n     * * Returns `undefined` if the `matrix` part if this Transform is singular.\n     */\n    multiplyInversePoint4d(weightedPoint, result) {\n        const w = weightedPoint.w;\n        return this._matrix.multiplyInverseXYZW(weightedPoint.x - w * this.origin.x, weightedPoint.y - w * this.origin.y, weightedPoint.z - w * this.origin.z, w, result);\n    }\n    /**\n     * Multiply the point by the inverse Transform.\n     * * If for a point `p` we have `Tp = M*p + o = q`, then `p = MInverse*(q - o) = TInverse q` so `TInverse` Transform\n     * has matrix part `MInverse` and origin part `-MInverse*o`.\n     * * Return as a new point or in the optional `result`.\n     * * Returns `undefined` if the `matrix` part if this Transform is singular.\n     */\n    multiplyInverseXYZ(x, y, z, result) {\n        return this._matrix.multiplyInverseXYZAsPoint3d(x - this._origin.x, y - this._origin.y, z - this._origin.z, result);\n    }\n    /**\n     * * Compute (if needed) the inverse of the `matrix` part of the Transform, thereby ensuring inverse\n     * operations can complete.\n     * @param useCached If true, accept prior cached inverse if available.\n     * @returns `true` if matrix inverse completes, `false` otherwise.\n     */\n    computeCachedInverse(useCached = true) {\n        return this._matrix.computeCachedInverse(useCached);\n    }\n    /**\n     * Match the length of destination array with the length of source array\n     * * If destination has more elements than source, remove the extra elements.\n     * * If destination has fewer elements than source, use `constructionFunction` to create new elements.\n     * *\n     * @param source the source array\n     * @param dest the destination array\n     * @param constructionFunction function to call to create new elements.\n     */\n    static matchArrayLengths(source, dest, constructionFunction) {\n        const numSource = source.length;\n        const numDest = dest.length;\n        if (numSource > numDest) {\n            for (let i = numDest; i < numSource; i++) {\n                dest.push(constructionFunction());\n            }\n        }\n        else if (numDest > numSource) {\n            dest.length = numSource;\n        }\n        return numSource;\n    }\n    /**\n     * Multiply each point in the array by the inverse of `this` Transform.\n     * * For a transform `T = [M o]` the inverse transform `T' = [M' -M'o]` exists if and only if `M` has an inverse\n     * `M'`. Indeed, for any point `p`, we have `T'Tp = T'(Mp + o) = M'(Mp + o) - M'o = M'Mp + M'o - M'o = p.`\n     * * If `result` is given, resize it to match the input `points` array and update it with original points `p[]`.\n     * * If `result` is not given, return a new array.\n     * * Returns `undefined` if the `matrix` part if this Transform is singular.\n     */\n    multiplyInversePoint3dArray(points, result) {\n        if (!this._matrix.computeCachedInverse(true))\n            return undefined;\n        const originX = this.origin.x;\n        const originY = this.origin.y;\n        const originZ = this.origin.z;\n        if (result) {\n            const n = Transform.matchArrayLengths(points, result, () => Point3d.createZero());\n            for (let i = 0; i < n; i++)\n                this._matrix.multiplyInverseXYZAsPoint3d(points[i].x - originX, points[i].y - originY, points[i].z - originZ, result[i]);\n            return result;\n        }\n        result = [];\n        for (const point of points)\n            result.push(this._matrix.multiplyInverseXYZAsPoint3d(point.x - originX, point.y - originY, point.z - originZ));\n        return result;\n    }\n    /**\n     * Multiply each point in the array by the inverse of `this` Transform in place.\n     * * For a transform `T = [M o]` the inverse transform `T' = [M' -M'o]` exists if and only if `M` has an inverse\n     * `M'`. Indeed, for any point `p`, we have `T'Tp = T'(Mp + o) = M'(Mp + o) - M'o = M'Mp + M'o - M'o = p.`\n     * * Returns `true` if the `matrix` part if this Transform is invertible and `false` if singular.\n     */\n    multiplyInversePoint3dArrayInPlace(points) {\n        if (!this._matrix.computeCachedInverse(true))\n            return false;\n        for (const point of points)\n            this._matrix.multiplyInverseXYZAsPoint3d(point.x - this.origin.x, point.y - this.origin.y, point.z - this.origin.z, point);\n        return true;\n    }\n    /**\n     * Transform the input 2d point array (using `Tp = M*p + o`).\n     * * If `result` is given, resize it to match the input `points` array and update it with transformed points.\n     * * If `result` is not given, return a new array.\n     */\n    multiplyPoint2dArray(points, result) {\n        if (result) {\n            const n = Transform.matchArrayLengths(points, result, () => Point2d.createZero());\n            for (let i = 0; i < n; i++)\n                Matrix3d.xyPlusMatrixTimesXY(this._origin, this._matrix, points[i], result[i]);\n            return result;\n        }\n        result = [];\n        for (const p of points)\n            result.push(Matrix3d.xyPlusMatrixTimesXY(this._origin, this._matrix, p));\n        return result;\n    }\n    /**\n     * Transform the input 3d point array (using `Tp = M*p + o`).\n     * * If `result` is given, resize it to match the input `points` array and update it with transformed points.\n     * * If `result` is not given, return a new array.\n     */\n    multiplyPoint3dArray(points, result) {\n        if (result) {\n            const n = Transform.matchArrayLengths(points, result, () => Point3d.createZero());\n            for (let i = 0; i < n; i++)\n                Matrix3d.xyzPlusMatrixTimesXYZ(this._origin, this._matrix, points[i], result[i]);\n            return result;\n        }\n        result = [];\n        for (const p of points)\n            result.push(Matrix3d.xyzPlusMatrixTimesXYZ(this._origin, this._matrix, p));\n        return result;\n    }\n    /**\n     * Multiply the vector by the `matrix` part of the Transform.\n     * * The `origin` part of Transform is not used.\n     * * If `result` is given, update it with the multiplication. Otherwise, create a new Vector3d.\n     */\n    multiplyVector(vector, result) {\n        return this._matrix.multiplyVector(vector, result);\n    }\n    /**\n     * Multiply the vector by the `matrix` part of the Transform in place.\n     * * The `origin` part of Transform is not used.\n     */\n    multiplyVectorInPlace(vector) {\n        this._matrix.multiplyVectorInPlace(vector);\n    }\n    /**\n     * Multiply the vector (x,y,z) by the `matrix` part of the Transform.\n     * * The `origin` part of Transform is not used.\n     * * If `result` is given, update it with the multiplication. Otherwise, create a new Vector3d.\n     */\n    multiplyVectorXYZ(x, y, z, result) {\n        return this._matrix.multiplyXYZ(x, y, z, result);\n    }\n    /**\n     * Calculate `transformA * transformB` and store it into the calling instance (`this`).\n     * * **Note:** If `transformA = [A   a]` and `transformB = [B   b]` then `transformA * transformB` is defined as\n     * `[A*B   Ab+a]`.\n     * * @see [[multiplyTransformTransform]] documentation for math details.\n     * @param transformA first operand\n     * @param transformB second operand\n     */\n    setMultiplyTransformTransform(transformA, transformB) {\n        Matrix3d.xyzPlusMatrixTimesXYZ(transformA._origin, transformA._matrix, transformB._origin, this._origin);\n        transformA._matrix.multiplyMatrixMatrix(transformB._matrix, this._matrix);\n    }\n    /**\n     * Multiply `this` Transform times `other` Transform.\n     * * **Note:** If `this = [A   a]` and `other = [B   b]` then `this * other` is defined as [A*B   Ab+a] because:\n     * ```\n     * equation\n     * \\begin{matrix}\n     *    \\text{this Transform with matrix part }\\bold{A}\\text{ and origin part }\\bold{a} & \\blockTransform{A}{a}\\\\\n     *    \\text{other Transform with matrix part }\\bold{B}\\text{ and origin part }\\bold{b} & \\blockTransform{B}{b} \\\\\n     * \\text{product}& \\blockTransform{A}{a}\\blockTransform{B}{b}=\\blockTransform{AB}{Ab + a}\n     * \\end{matrix}\n     * ```\n     * @param other the 'other` Transform to be multiplied to `this` Transform.\n     * @param result optional preallocated `result` to reuse.\n     */\n    multiplyTransformTransform(other, result) {\n        if (!result)\n            return Transform.createRefs(Matrix3d.xyzPlusMatrixTimesXYZ(this._origin, this._matrix, other._origin), this._matrix.multiplyMatrixMatrix(other._matrix));\n        result.setMultiplyTransformTransform(this, other);\n        return result;\n    }\n    /**\n     * Multiply `this` Transform times `other` Matrix3d (considered to be a Transform with 0 `origin`).\n     * * **Note:** If `this = [A   a]` and `other = [B   0]`, then `this * other` is defined as [A*B   a] because:\n     * ```\n     * equation\n     * \\begin{matrix}\n     *    \\text{this Transform with matrix part }\\bold{A}\\text{ and origin part }\\bold{a} & \\blockTransform{A}{a}\\\\\n     *    \\text{other matrix }\\bold{B}\\text{ promoted to block Transform} & \\blockTransform{B}{0} \\\\\n     * \\text{product}& \\blockTransform{A}{a}\\blockTransform{B}{0}=\\blockTransform{AB}{a}\n     * \\end{matrix}\n     * ```\n     * @param other the `other` Matrix3d to be multiplied to `this` Transform.\n     * @param result optional preallocated `result` to reuse.\n     */\n    multiplyTransformMatrix3d(other, result) {\n        if (!result)\n            return Transform.createRefs(this._origin.cloneAsPoint3d(), this._matrix.multiplyMatrixMatrix(other));\n        this._matrix.multiplyMatrixMatrix(other, result._matrix);\n        result._origin.setFrom(this._origin);\n        return result;\n    }\n    /**\n     * Return the range of the transformed corners.\n     * * The 8 corners are transformed individually.\n     * * **Note:** Suppose you have a geometry, a range box around that geometry, and your Transform is a rotation.\n     * If you rotate the range box and recompute a new range box around the rotated range box, then the new range\n     * box will have a larger volume than the original range box. However, if you rotate the geometry itself and\n     * then recompute the range box, it will be a tighter range box around the rotated geometry. `multiplyRange`\n     * function creates the larger range box because it only has access to the range box and not the geometry itself.\n     */\n    multiplyRange(range, result) {\n        if (range.isNull)\n            return range.clone(result);\n        const lowX = range.low.x;\n        const lowY = range.low.y;\n        const lowZ = range.low.z;\n        const highX = range.high.x;\n        const highY = range.high.y;\n        const highZ = range.high.z;\n        result = Range3d.createNull(result);\n        result.extendTransformedXYZ(this, lowX, lowY, lowZ);\n        result.extendTransformedXYZ(this, highX, lowY, lowZ);\n        result.extendTransformedXYZ(this, lowX, highY, lowZ);\n        result.extendTransformedXYZ(this, highX, highY, lowZ);\n        result.extendTransformedXYZ(this, lowX, lowY, highZ);\n        result.extendTransformedXYZ(this, highX, lowY, highZ);\n        result.extendTransformedXYZ(this, lowX, highY, highZ);\n        result.extendTransformedXYZ(this, highX, highY, highZ);\n        return result;\n    }\n    /**\n     * Return a Transform which is the inverse of `this` Transform.\n     * * If `transform = [M   o]` then `transformInverse = [MInverse   -MInverse*o]`\n     * * Return `undefined` if this Transform's matrix is singular.\n     */\n    inverse(result) {\n        const matrixInverse = this._matrix.inverse(result ? result._matrix : undefined);\n        if (!matrixInverse)\n            return undefined;\n        if (result) {\n            // result._matrix is already defined\n            matrixInverse.multiplyXYZ(-this._origin.x, -this._origin.y, -this._origin.z, result._origin);\n            return result;\n        }\n        return Transform.createRefs(matrixInverse.multiplyXYZ(-this._origin.x, -this._origin.y, -this._origin.z), matrixInverse);\n    }\n    /**\n     * Initialize 2 Transforms that map between the unit box (specified by 000 and 111) and the range box specified\n     * by the input points.\n     * @param min the min corner of the range box\n     * @param max the max corner of the range box\n     * @param npcToGlobal maps NPC coordinates into range box coordinates. Specifically, maps 000 to `min` and maps\n     * 111 to `max`. This Transform is the inverse of `globalToNpc`. Object created by caller, re-initialized here.\n     * @param globalToNpc maps range box coordinates into NPC coordinates. Specifically, maps `min` to 000 and maps\n     * `max` to 111. This Transform is the inverse of `npcToGlobal`. Object created by caller, re-initialized here.\n     * * NPC stands for `Normalized Projection Coordinate`\n     */\n    static initFromRange(min, max, npcToGlobal, globalToNpc) {\n        const diag = max.minus(min);\n        if (diag.x === 0.0)\n            diag.x = 1.0;\n        if (diag.y === 0.0)\n            diag.y = 1.0;\n        if (diag.z === 0.0)\n            diag.z = 1.0;\n        const rMatrix = new Matrix3d();\n        /**\n         *               [diag.x    0       0      min.x]\n         * npcToGlobal = [  0     diag.y    0      min.y]\n         *               [  0       0     diag.y   min.z]\n         *\n         * npcToGlobal * 0 = min\n         * npcToGlobal * 1 = diag + min = max\n         */\n        if (npcToGlobal) {\n            Matrix3d.createScale(diag.x, diag.y, diag.z, rMatrix);\n            Transform.createOriginAndMatrix(min, rMatrix, npcToGlobal);\n        }\n        /**\n         *               [1/diag.x      0         0      -min.x/diag.x]\n         * globalToNpc = [  0       1/diag.y      0      -min.y/diag.y]\n         *               [  0         0       1/diag.y   -min.z/diag.z]\n         *\n         * globalToNpc * min = min/diag - min/diag = 0\n         * globalToNpc * max = max/diag - min/diag = diag/diag = 1\n         */\n        if (globalToNpc) {\n            const origin = new Point3d(-min.x / diag.x, -min.y / diag.y, -min.z / diag.z);\n            Matrix3d.createScale(1.0 / diag.x, 1.0 / diag.y, 1.0 / diag.z, rMatrix);\n            Transform.createOriginAndMatrix(origin, rMatrix, globalToNpc);\n        }\n    }\n}\n//# sourceMappingURL=Transform.js.map",
      "start": 1693508123263,
      "end": 1693508123461,
      "sourcemaps": null
    }
  ]
}
