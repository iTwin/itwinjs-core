{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/geometry3d/Point3dVector3d.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module CartesianGeometry\n */\nimport { Geometry } from \"../Geometry\";\nimport { Angle } from \"./Angle\";\nimport { XYAndZ } from \"./XYZProps\";\n// cspell:words CWXY CCWXY arctan Rodrigues\n/**\n * * `XYZ` is a minimal object containing x,y,z and operations that are meaningful without change in both\n * point and vector.\n *  * `XYZ` is not instantiable.\n *  * The derived (instantiable) classes are\n *    * `Point3d`\n *    * `Vector3d`\n * @public\n */\nexport class XYZ {\n    /**\n     * Set the x,y,z  parts.\n     * @param x (optional) x part\n     * @param y (optional) y part\n     * @param z (optional) z part\n     */\n    set(x = 0, y = 0, z = 0) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    /** Set the x,y,z parts to zero. */\n    setZero() {\n        this.x = 0;\n        this.y = 0;\n        this.z = 0;\n    }\n    constructor(x = 0, y = 0, z = 0) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    /** Type guard for XAndY.\n     * @note this will return true for an XYAndZ. If you wish to distinguish between the two, call isXYAndZ first.\n     */\n    static isXAndY(arg) {\n        return arg.x !== undefined && arg.y !== undefined;\n    }\n    /** Type guard to determine whether an object has a member called \"z\" */\n    static hasZ(arg) {\n        return arg.z !== undefined;\n    }\n    /** Type guard for XYAndZ.  */\n    static isXYAndZ(arg) {\n        return this.isXAndY(arg) && this.hasZ(arg);\n    }\n    /**\n     * Test if arg is any of:\n     * * XAndY\n     * * XYAndZ\n     * * [number,number]\n     * * [number,number,number]\n     */\n    static isAnyImmediatePointType(arg) {\n        return Point3d.isXAndY(arg) || Geometry.isNumberArray(arg, 2);\n    }\n    /**\n     * Look for (in order) an x coordinate present as:\n     * * arg.x\n     * * arg[0]\n     */\n    static accessX(arg, defaultValue) {\n        if (arg.x !== undefined)\n            return arg.x;\n        if (Array.isArray(arg) && arg.length > 0 && Number.isFinite(arg[0]))\n            return arg[0];\n        return defaultValue;\n    }\n    /**\n     * Look for (in order) an x coordinate present as:\n     * * arg.y\n     * * arg[1]\n     */\n    static accessY(arg, defaultValue) {\n        if (arg.y !== undefined)\n            return arg.y;\n        if (Array.isArray(arg) && arg.length > 1 && Number.isFinite(arg[1]))\n            return arg[1];\n        return defaultValue;\n    }\n    /**\n     * Look for (in order) an x coordinate present as:\n     * * arg.z\n     * * arg[2]\n     */\n    static accessZ(arg, defaultValue) {\n        if (arg.z !== undefined)\n            return arg.z;\n        if (Array.isArray(arg) && arg.length > 2 && Number.isFinite(arg[2]))\n            return arg[2];\n        return defaultValue;\n    }\n    /**\n     * Set the x,y,z parts from one of these input types\n     *\n     * * XYZ -- copy the x,y,z parts\n     * * Float64Array -- Copy from indices 0,1,2 to x,y,z\n     * * XY -- copy the x, y parts and set z=0\n     */\n    setFrom(other) {\n        if (other === undefined) {\n            this.setZero();\n        }\n        else if (XYZ.isXAndY(other)) {\n            this.x = other.x;\n            this.y = other.y;\n            this.z = XYZ.hasZ(other) ? other.z : 0;\n        }\n        else {\n            this.x = other[0];\n            this.y = other[1];\n            this.z = other[2];\n        }\n    }\n    /**\n     * Set the x,y,z parts from a Point3d.\n     * This is the same effect as `setFrom(other)` with no pretesting of variant input type\n     * * Set to zeros if `other` is undefined.\n     */\n    setFromPoint3d(other) {\n        if (other) {\n            this.x = other.x;\n            this.y = other.y;\n            this.z = other.z;\n        }\n        else {\n            this.setZero();\n        }\n    }\n    /**\n     * Set the x,y,z parts from a Vector3d\n     * This is the same effect as `setFrom(other)` with no pretesting of variant input type\n     * * Set to zeros if `other` is undefined.\n     */\n    setFromVector3d(other) {\n        if (other) {\n            this.x = other.x;\n            this.y = other.y;\n            this.z = other.z;\n        }\n        else {\n            this.setZero();\n        }\n    }\n    /**\n     * Returns true if this and other have equal x,y,z parts within Geometry.smallMetricDistance.\n     * @param other The other XYAndZ to compare\n     * @param tol The tolerance for the comparison. If undefined, use [[Geometry.smallMetricDistance]]\n     */\n    isAlmostEqual(other, tol) {\n        return XYAndZ.almostEqual(this, other, tol);\n    }\n    /** Return true if this and other have equal x,y,z parts within Geometry.smallMetricDistance. */\n    isAlmostEqualXYZ(x, y, z, tol) {\n        return Geometry.isSameCoordinate(this.x, x, tol)\n            && Geometry.isSameCoordinate(this.y, y, tol)\n            && Geometry.isSameCoordinate(this.z, z, tol);\n    }\n    /**\n     * Return true if this and {other + vector*scale} have equal x,y,z parts within Geometry.smallMetricDistance.\n     * * this method is useful in testing \"point on ray\" without explicitly constructing the projection point\n    */\n    isAlmostEqualPointPlusScaledVector(other, vector, scale, tol) {\n        return Geometry.isSameCoordinate(this.x, other.x + vector.x * scale, tol)\n            && Geometry.isSameCoordinate(this.y, other.y + vector.y * scale, tol)\n            && Geometry.isSameCoordinate(this.z, other.z + vector.z * scale, tol);\n    }\n    /** Return true if this and other have equal x,y parts within Geometry.smallMetricDistance. */\n    isAlmostEqualXY(other, tol) {\n        return Geometry.isSameCoordinate(this.x, other.x, tol)\n            && Geometry.isSameCoordinate(this.y, other.y, tol);\n    }\n    /** Return a JSON object as array `[x,y,z]` */\n    toJSON() {\n        return this.toArray();\n    }\n    /** Return as an array `[x,y,z]` */\n    toArray() {\n        return [this.x, this.y, this.z];\n    }\n    /** Return a JSON object as key value pairs `{x: value, y: value, z: value}` */\n    toJSONXYZ() {\n        return { x: this.x, y: this.y, z: this.z };\n    }\n    /** Pack the x,y,z values in a Float64Array. */\n    toFloat64Array() {\n        return Float64Array.of(this.x, this.y, this.z);\n    }\n    /**\n     * Set the x,y,z properties from one of several json forms:\n     *\n     * *  array of numbers: [x,y,z]\n     * *  object with x,y, and (optional) z as numeric properties {x: xValue, y: yValue, z: zValue}\n     */\n    setFromJSON(json) {\n        if (Array.isArray(json)) {\n            this.set(json[0] || 0, json[1] || 0, json[2] || 0);\n            return;\n        }\n        if (json) {\n            this.set(json.x || 0, json.y || 0, json.z || 0);\n            return;\n        }\n        this.set(0, 0, 0);\n    }\n    /** Return the distance from this point to other */\n    distance(other) {\n        const xDist = other.x - this.x;\n        const yDist = other.y - this.y;\n        const zDist = other.z - this.z;\n        return (Math.sqrt(xDist * xDist + yDist * yDist + zDist * zDist));\n    }\n    /** Return squared distance from this point to other */\n    distanceSquared(other) {\n        const xDist = other.x - this.x;\n        const yDist = other.y - this.y;\n        const zDist = other.z - this.z;\n        return (xDist * xDist + yDist * yDist + zDist * zDist);\n    }\n    /** Return the XY distance from this point to other */\n    distanceXY(other) {\n        const xDist = other.x - this.x;\n        const yDist = other.y - this.y;\n        return (Math.sqrt(xDist * xDist + yDist * yDist));\n    }\n    /** Return squared XY distance from this point to other */\n    distanceSquaredXY(other) {\n        const xDist = other.x - this.x;\n        const yDist = other.y - this.y;\n        return (xDist * xDist + yDist * yDist);\n    }\n    /** Return the largest absolute distance between corresponding components */\n    maxDiff(other) {\n        return Math.max(Math.abs(this.x - other.x), Math.abs(this.y - other.y), Math.abs(this.z - other.z));\n    }\n    /** Return the x,y, z component corresponding to 0,1,2 */\n    at(index) {\n        if (index < 0.5)\n            return this.x;\n        if (index > 1.5)\n            return this.z;\n        return this.y;\n    }\n    /** Set value at index 0 or 1 or 2 */\n    setAt(index, value) {\n        if (index < 0.5)\n            this.x = value;\n        else if (index > 1.5)\n            this.z = value;\n        else\n            this.y = value;\n    }\n    /** Return the index (0,1,2) of the x,y,z component with largest absolute value */\n    indexOfMaxAbs() {\n        let index = 0;\n        let a = Math.abs(this.x);\n        let b = Math.abs(this.y);\n        if (b > a) {\n            index = 1;\n            a = b;\n        }\n        b = Math.abs(this.z);\n        if (b > a) {\n            index = 2;\n        }\n        return index;\n    }\n    /** Return true if the x,y,z components are all nearly zero to tolerance Geometry.smallMetricDistance */\n    get isAlmostZero() {\n        return Geometry.isSmallMetricDistance(this.x) &&\n            Geometry.isSmallMetricDistance(this.y) &&\n            Geometry.isSmallMetricDistance(this.z);\n    }\n    /** Return true if the x,y,z components are all exactly zero */\n    get isZero() {\n        return this.x === 0.0 && this.y === 0.0 && this.z === 0.0;\n    }\n    /** Return the largest absolute value of any component */\n    maxAbs() {\n        return Math.max(Math.abs(this.x), Math.abs(this.y), Math.abs(this.z));\n    }\n    /** Return the sqrt of the sum of squared x,y,z parts */\n    magnitude() {\n        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n    }\n    /** Return the sum of squared x,y,z parts */\n    magnitudeSquared() {\n        return this.x * this.x + this.y * this.y + this.z * this.z;\n    }\n    /** Return sqrt of the sum of squared x,y parts */\n    magnitudeXY() {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    }\n    /** Return the sum of squared x,y parts */\n    magnitudeSquaredXY() {\n        return this.x * this.x + this.y * this.y;\n    }\n    /** Exact equality test. */\n    isExactEqual(other) {\n        return this.x === other.x && this.y === other.y && this.z === other.z;\n    }\n    /** Equality test with Geometry.smallMetricDistance tolerance */\n    isAlmostEqualMetric(other) {\n        return this.maxDiff(other) <= Geometry.smallMetricDistance;\n    }\n    /** Add x,y,z from other in place. */\n    addInPlace(other) {\n        this.x += other.x;\n        this.y += other.y;\n        this.z += other.z;\n    }\n    /** Add x,y,z from other in place. */\n    subtractInPlace(other) {\n        this.x -= other.x;\n        this.y -= other.y;\n        this.z -= other.z;\n    }\n    /** Add (in place) the scaled x,y,z of other */\n    addScaledInPlace(other, scale) {\n        this.x += scale * other.x;\n        this.y += scale * other.y;\n        this.z += scale * other.z;\n    }\n    /** Multiply the x, y, z parts by scale. */\n    scaleInPlace(scale) {\n        this.x *= scale;\n        this.y *= scale;\n        this.z *= scale;\n    }\n    /** Add to x, y, z parts */\n    addXYZInPlace(dx = 0.0, dy = 0.0, dz = 0.0) {\n        this.x += dx;\n        this.y += dy;\n        this.z += dz;\n    }\n    /** Clone strongly typed as Point3d */\n    cloneAsPoint3d() {\n        return Point3d.create(this.x, this.y, this.z);\n    }\n    /** Return a (full length) vector from this point to other */\n    vectorTo(other, result) {\n        return Vector3d.create(other.x - this.x, other.y - this.y, other.z - this.z, result);\n    }\n    /** Return a multiple of a the (full length) vector from this point to other */\n    scaledVectorTo(other, scale, result) {\n        return Vector3d.create(scale * (other.x - this.x), scale * (other.y - this.y), scale * (other.z - this.z), result);\n    }\n    /**\n     * Return a unit vector from this vector to other. Return a 000 vector if the input is too small to normalize.\n     * @param other target of created vector.\n     * @param result optional result vector.\n     */\n    unitVectorTo(target, result) {\n        return this.vectorTo(target, result).normalize(result);\n    }\n    /** Freeze this XYZ */\n    freeze() {\n        return Object.freeze(this);\n    }\n    /** Access x part of XYZProps (which may be .x or [0]) */\n    static x(xyz, defaultValue = 0) {\n        if (xyz === undefined)\n            return defaultValue;\n        if (Array.isArray(xyz))\n            return xyz[0];\n        if (xyz.x !== undefined)\n            return xyz.x;\n        return defaultValue;\n    }\n    /** Access x part of XYZProps (which may be .x or [0]) */\n    static y(xyz, defaultValue = 0) {\n        if (xyz === undefined)\n            return defaultValue;\n        if (Array.isArray(xyz))\n            return xyz[1];\n        if (xyz.y !== undefined)\n            return xyz.y;\n        return defaultValue;\n    }\n    /** Access x part of XYZProps (which may be .x or [0]) */\n    static z(xyz, defaultValue = 0) {\n        if (xyz === undefined)\n            return defaultValue;\n        if (Array.isArray(xyz))\n            return xyz[2];\n        if (xyz.z !== undefined)\n            return xyz.z;\n        return defaultValue;\n    }\n}\n/** 3D point with `x`,`y`,`z` as properties\n * @public\n */\nexport class Point3d extends XYZ {\n    /** Constructor for Point3d */\n    constructor(x = 0, y = 0, z = 0) {\n        super(x, y, z);\n    }\n    /**\n     * Convert json to Point3d.  Accepted forms are:\n     * * `[1,2,3]` --- array of numbers\n     * *  array of numbers: [x,y,z]\n     * *  object with x,y, and (optional) z as numeric properties {x: xValue, y: yValue, z: zValue}\n     * @param json json value.\n     */\n    static fromJSON(json) {\n        const val = new Point3d();\n        val.setFromJSON(json);\n        return val;\n    }\n    /** Return a new Point3d with the same coordinates */\n    clone(result) {\n        return Point3d.create(this.x, this.y, this.z, result);\n    }\n    /**\n     * Create a new Point3d with given coordinates\n     * @param x x part\n     * @param y y part\n     * @param z z part\n     */\n    static create(x = 0, y = 0, z = 0, result) {\n        if (result) {\n            result.x = x;\n            result.y = y;\n            result.z = z;\n            return result;\n        }\n        return new Point3d(x, y, z);\n    }\n    /** Copy contents from another Point3d, Point2d, Vector2d, or Vector3d */\n    static createFrom(data, result) {\n        if (data instanceof Float64Array) {\n            let x = 0;\n            let y = 0;\n            let z = 0;\n            if (data.length > 0)\n                x = data[0];\n            if (data.length > 1)\n                y = data[1];\n            if (data.length > 2)\n                z = data[2];\n            return Point3d.create(x, y, z, result);\n        }\n        return Point3d.create(data.x, data.y, XYZ.hasZ(data) ? data.z : 0, result);\n    }\n    /**\n     * Copy x,y,z from\n     * @param xyzData flat array of xyzxyz for multiple points\n     * @param pointIndex index of point to extract.   This index is multiplied by 3 to obtain starting index in the array.\n     * @param result optional result point.\n     */\n    static createFromPacked(xyzData, pointIndex, result) {\n        const indexX = pointIndex * 3;\n        if (indexX >= 0 && indexX + 2 < xyzData.length)\n            return Point3d.create(xyzData[indexX], xyzData[indexX + 1], xyzData[indexX + 2], result);\n        return undefined;\n    }\n    /**\n     * Copy and unweight xyzw.\n     * @param xyzData flat array of x,y,z,w,x,y,z,w for multiple points\n     * @param pointIndex index of point to extract. This index is multiplied by 4 to obtain starting index in the array.\n     * @param result optional result point.\n     */\n    static createFromPackedXYZW(xyzData, pointIndex, result) {\n        const indexX = pointIndex * 4;\n        if (indexX >= 0 && indexX + 3 < xyzData.length) {\n            const w = xyzData[indexX + 3];\n            if (!Geometry.isSmallMetricDistance(w)) {\n                const divW = 1.0 / w;\n                return Point3d.create(divW * xyzData[indexX], divW * xyzData[indexX + 1], divW * xyzData[indexX + 2], result);\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Return an array of points constructed from groups of 3 entries in a Float64Array.\n     * Any incomplete group at the tail of the array is ignored.\n     */\n    static createArrayFromPackedXYZ(data) {\n        const result = [];\n        for (let i = 0; i + 2 < data.length; i += 3)\n            result.push(new Point3d(data[i], data[i + 1], data[i + 2]));\n        return result;\n    }\n    /** Create a new point with 000 xyz */\n    static createZero(result) {\n        return Point3d.create(0, 0, 0, result);\n    }\n    /**\n     * Return the cross product of the vectors from this to pointA and pointB\n     * *  the result is a vector\n     * *  the result is perpendicular to both vectors, with right hand orientation\n     * *  the magnitude of the vector is twice the area of the triangle.\n     */\n    crossProductToPoints(pointA, pointB, result) {\n        return Vector3d.createCrossProduct(pointA.x - this.x, pointA.y - this.y, pointA.z - this.z, pointB.x - this.x, pointB.y - this.y, pointB.z - this.z, result);\n    }\n    /** Return the magnitude of the cross product of the vectors from this to pointA and pointB */\n    crossProductToPointsMagnitude(pointA, pointB) {\n        return Geometry.crossProductMagnitude(pointA.x - this.x, pointA.y - this.y, pointA.z - this.z, pointB.x - this.x, pointB.y - this.y, pointB.z - this.z);\n    }\n    /**\n     * Return the triple product of the vectors from this to pointA, pointB, pointC\n     * * This is a scalar (number)\n     * * This is 6 times the (signed) volume of the tetrahedron on the 4 points.\n     */\n    tripleProductToPoints(pointA, pointB, pointC) {\n        return Geometry.tripleProduct(pointA.x - this.x, pointA.y - this.y, pointA.z - this.z, pointB.x - this.x, pointB.y - this.y, pointB.z - this.z, pointC.x - this.x, pointC.y - this.y, pointC.z - this.z);\n    }\n    /**\n     * Return the cross product of the vectors from this to pointA and pointB\n     * *  the result is a scalar\n     * *  the magnitude of the vector is twice the signed area of the triangle.\n     * *  this is positive for counter-clockwise order of the points, negative for clockwise.\n     */\n    crossProductToPointsXY(pointA, pointB) {\n        return Geometry.crossProductXYXY(pointA.x - this.x, pointA.y - this.y, pointB.x - this.x, pointB.y - this.y);\n    }\n    /**\n     * Return a point interpolated between `this` point and the `other` point.\n     * * Fraction specifies where the interpolated point is located on the line passing `this` and `other`.\n     */\n    interpolate(fraction, other, result) {\n        if (fraction <= 0.5)\n            return Point3d.create(this.x + fraction * (other.x - this.x), this.y + fraction * (other.y - this.y), this.z + fraction * (other.z - this.z), result);\n        const t = fraction - 1.0;\n        return Point3d.create(other.x + t * (other.x - this.x), other.y + t * (other.y - this.y), other.z + t * (other.z - this.z), result);\n    }\n    /** Return a point with independent x,y,z fractional interpolation. */\n    interpolateXYZ(fractionX, fractionY, fractionZ, other, result) {\n        return Point3d.create(Geometry.interpolate(this.x, fractionX, other.x), Geometry.interpolate(this.y, fractionY, other.y), Geometry.interpolate(this.z, fractionZ, other.z), result);\n    }\n    /** Interpolate between points, then add a shift in the xy plane by a fraction of the XY projection perpendicular. */\n    interpolatePerpendicularXY(fraction, pointB, fractionXYPerp, result) {\n        result = result ? result : new Point3d();\n        const vector = pointB.minus(this);\n        this.interpolate(fraction, pointB, result);\n        result.x -= fractionXYPerp * vector.y;\n        result.y += fractionXYPerp * vector.x;\n        return result;\n    }\n    /** Return point minus vector */\n    minus(vector, result) {\n        return Point3d.create(this.x - vector.x, this.y - vector.y, this.z - vector.z, result);\n    }\n    /** Return point plus vector */\n    plus(vector, result) {\n        return Point3d.create(this.x + vector.x, this.y + vector.y, this.z + vector.z, result);\n    }\n    /** Return point plus vector */\n    plusXYZ(dx = 0, dy = 0, dz = 0, result) {\n        return Point3d.create(this.x + dx, this.y + dy, this.z + dz, result);\n    }\n    /** Return point + vector * scalar */\n    plusScaled(vector, scaleFactor, result) {\n        return Point3d.create(this.x + vector.x * scaleFactor, this.y + vector.y * scaleFactor, this.z + vector.z * scaleFactor, result);\n    }\n    /** Return point + vectorA * scalarA + vectorB * scalarB */\n    plus2Scaled(vectorA, scalarA, vectorB, scalarB, result) {\n        return Point3d.create(this.x + vectorA.x * scalarA + vectorB.x * scalarB, this.y + vectorA.y * scalarA + vectorB.y * scalarB, this.z + vectorA.z * scalarA + vectorB.z * scalarB, result);\n    }\n    /** Return point + vectorA * scalarA + vectorB * scalarB + vectorC * scalarC */\n    plus3Scaled(vectorA, scalarA, vectorB, scalarB, vectorC, scalarC, result) {\n        return Point3d.create(this.x + vectorA.x * scalarA + vectorB.x * scalarB + vectorC.x * scalarC, this.y + vectorA.y * scalarA + vectorB.y * scalarB + vectorC.y * scalarC, this.z + vectorA.z * scalarA + vectorB.z * scalarB + vectorC.z * scalarC, result);\n    }\n    /**\n     * Return a point that is scaled from the source point.\n     * @param source existing point\n     * @param scale scale factor to apply to its x,y,z parts\n     * @param result optional point to receive coordinates\n     */\n    static createScale(source, scale, result) {\n        return Point3d.create(source.x * scale, source.y * scale, source.z * scale, result);\n    }\n    /**\n     * Create a point that is a linear combination (weighted sum) of 2 input points.\n     * @param pointA first input point\n     * @param scaleA scale factor for pointA\n     * @param pointB second input point\n     * @param scaleB scale factor for pointB\n     */\n    static createAdd2Scaled(pointA, scaleA, pointB, scaleB, result) {\n        return Point3d.create(pointA.x * scaleA + pointB.x * scaleB, pointA.y * scaleA + pointB.y * scaleB, pointA.z * scaleA + pointB.z * scaleB, result);\n    }\n    /** Create a point that is a linear combination (weighted sum) of 3 input points.\n     * @param pointA first input point\n     * @param scaleA scale factor for pointA\n     * @param pointB second input point\n     * @param scaleB scale factor for pointB\n     * @param pointC third input point.\n     * @param scaleC scale factor for pointC\n     */\n    static createAdd3Scaled(pointA, scaleA, pointB, scaleB, pointC, scaleC, result) {\n        return Point3d.create(pointA.x * scaleA + pointB.x * scaleB + pointC.x * scaleC, pointA.y * scaleA + pointB.y * scaleB + pointC.y * scaleC, pointA.z * scaleA + pointB.z * scaleB + pointC.z * scaleC, result);\n    }\n    /**\n     * Return the dot product of vectors from this to pointA and this to pointB.\n     * @param targetA target point for first vector\n     * @param targetB target point for second vector\n     */\n    dotVectorsToTargets(targetA, targetB) {\n        return (targetA.x - this.x) * (targetB.x - this.x) +\n            (targetA.y - this.y) * (targetB.y - this.y) +\n            (targetA.z - this.z) * (targetB.z - this.z);\n    }\n    /** Return the fractional projection of this onto a line between points. */\n    fractionOfProjectionToLine(startPoint, endPoint, defaultFraction = 0) {\n        const denominator = startPoint.distanceSquared(endPoint);\n        if (denominator < Geometry.smallMetricDistanceSquared)\n            return defaultFraction;\n        return startPoint.dotVectorsToTargets(endPoint, this) / denominator;\n    }\n}\n/**\n * 3D vector with `x`,`y`,`z` as properties\n * @public\n */\nexport class Vector3d extends XYZ {\n    constructor(x = 0, y = 0, z = 0) {\n        super(x, y, z);\n    }\n    /**\n     * Return an array of vectors constructed from groups of 3 entries in a Float64Array.\n     * Any incomplete group at the tail of the array is ignored.\n     */\n    static createArrayFromPackedXYZ(data) {\n        const result = [];\n        for (let i = 0; i + 2 < data.length; i += 3)\n            result.push(new Vector3d(data[i], data[i + 1], data[i + 2]));\n        return result;\n    }\n    /**\n     * Copy xyz from this instance to a new (or optionally reused) Vector3d\n     * @param result optional instance to reuse.\n     */\n    clone(result) {\n        return Vector3d.create(this.x, this.y, this.z, result);\n    }\n    /**\n     * Return a Vector3d (new or reused from optional result)\n     * @param x x component\n     * @param y y component\n     * @param z z component\n     * @param result optional instance to reuse\n     */\n    static create(x = 0, y = 0, z = 0, result) {\n        if (result) {\n            result.x = x;\n            result.y = y;\n            result.z = z;\n            return result;\n        }\n        return new Vector3d(x, y, z);\n    }\n    /**\n     * Create a vector which is cross product of two vectors supplied as separate arguments\n     * @param ux x coordinate of vector u\n     * @param uy y coordinate of vector u\n     * @param uz z coordinate of vector u\n     * @param vx x coordinate of vector v\n     * @param vy y coordinate of vector v\n     * @param vz z coordinate of vector v\n     * @param result optional result vector.\n     */\n    static createCrossProduct(ux, uy, uz, vx, vy, vz, result) {\n        return Vector3d.create(uy * vz - uz * vy, uz * vx - ux * vz, ux * vy - uy * vx, result);\n    }\n    /**\n     * Accumulate a vector which is cross product vectors from origin (ax,ay,az) to targets (bx,by,bz) and (cx,cy,cz)\n     * @param ax x coordinate of origin\n     * @param ay y coordinate of origin\n     * @param az z coordinate of origin\n     * @param bx x coordinate of target point b\n     * @param by y coordinate of target point b\n     * @param bz z coordinate of target point b\n     * @param cx x coordinate of target point c\n     * @param cy y coordinate of target point c\n     * @param cz z coordinate of target point c\n     */\n    addCrossProductToTargetsInPlace(ax, ay, az, bx, by, bz, cx, cy, cz) {\n        const ux = bx - ax;\n        const uy = by - ay;\n        const uz = bz - az;\n        const vx = cx - ax;\n        const vy = cy - ay;\n        const vz = cz - az;\n        this.x += uy * vz - uz * vy;\n        this.y += uz * vx - ux * vz;\n        this.z += ux * vy - uy * vx;\n    }\n    /**\n     * Return the cross product of the vectors from origin to pointA and pointB.\n     * * the result is a vector\n     * * the result is perpendicular to both vectors, with right hand orientation\n     * * the magnitude of the vector is twice the area of the triangle.\n     */\n    static createCrossProductToPoints(origin, pointA, pointB, result) {\n        return Vector3d.createCrossProduct(pointA.x - origin.x, pointA.y - origin.y, pointA.z - origin.z, pointB.x - origin.x, pointB.y - origin.y, pointB.z - origin.z, result);\n    }\n    /**\n     * Return the NORMALIZED cross product of the vectors from origin to pointA and pointB, or undefined\n     *\n     * * the result is a vector\n     * * the result is perpendicular to both vectors, with right hand orientation\n     * * the magnitude of the vector is twice the area of the triangle.\n     */\n    static createUnitCrossProductToPoints(origin, pointA, pointB, result) {\n        const vector = Vector3d.createCrossProduct(pointA.x - origin.x, pointA.y - origin.y, pointA.z - origin.z, pointB.x - origin.x, pointB.y - origin.y, pointB.z - origin.z, result);\n        return vector.normalize();\n    }\n    /**\n     * Return a vector defined by polar coordinates distance and angle from x axis\n     * @param r distance measured from origin\n     * @param theta angle from x axis to the vector (in xy plane)\n     * @param z optional z coordinate\n     */\n    static createPolar(r, theta, z) {\n        return Vector3d.create(r * theta.cos(), r * theta.sin(), z);\n    }\n    /**\n     * Return a vector defined in spherical coordinates.\n     * @param r sphere radius\n     * @param theta angle in xy plane\n     * @param phi angle from xy plane to the vector\n     */\n    static createSpherical(r, theta, phi) {\n        const cosPhi = phi.cos();\n        return Vector3d.create(cosPhi * r * theta.cos(), cosPhi * r * theta.sin(), r * phi.sin());\n    }\n    /**\n     * Convert json to Vector3d.  Accepted forms are:\n     * * `[1,2,3]` --- array of numbers\n     * *  array of numbers: [x,y,z]\n     * *  object with x,y, and (optional) z as numeric properties {x: xValue, y: yValue, z: zValue}\n     * @param json json value.\n     */\n    static fromJSON(json) {\n        const val = new Vector3d();\n        val.setFromJSON(json);\n        return val;\n    }\n    /** Copy contents from another Point3d, Point2d, Vector2d, or Vector3d */\n    static createFrom(data, result) {\n        if (data instanceof Float64Array) {\n            let x = 0;\n            let y = 0;\n            let z = 0;\n            if (data.length > 0)\n                x = data[0];\n            if (data.length > 1)\n                y = data[1];\n            if (data.length > 2)\n                z = data[2];\n            return Vector3d.create(x, y, z, result);\n        }\n        else if (Array.isArray(data)) {\n            return Vector3d.create(data[0], data[1], data.length > 2 ? data[2] : 0);\n        }\n        return Vector3d.create(data.x, data.y, XYZ.hasZ(data) ? data.z : 0.0, result);\n    }\n    /**\n     * Return a vector defined by start and end points (end - start).\n     * @param start start point for vector.\n     * @param end end point for vector.\n     * @param result optional result.\n     */\n    static createStartEnd(start, end, result) {\n        const zStart = XYZ.accessZ(start, 0.0);\n        const zEnd = XYZ.accessZ(end, 0.0);\n        const dz = zEnd - zStart;\n        if (result) {\n            result.set(end.x - start.x, end.y - start.y, dz);\n            return result;\n        }\n        return new Vector3d(end.x - start.x, end.y - start.y, dz);\n    }\n    /**\n     * Return a vector (optionally in preallocated result, otherwise newly created) from [x0,y0,z0] to [x1,y1,z1]\n     * @param x0 start point x coordinate.\n     * @param y0 start point y coordinate.\n     * @param z0 start point z coordinate.\n     * @param x1 end point x coordinate.\n     * @param y1 end point y coordinate.\n     * @param z1 end point z coordinate.\n     * @param result optional result vector.\n     */\n    static createStartEndXYZXYZ(x0, y0, z0, x1, y1, z1, result) {\n        return this.create(x1 - x0, y1 - y0, z1 - z0, result);\n    }\n    /**\n     * Return a vector which is the input `vector` rotated by `angle` around the `axis` vector.\n     * @param vector initial vector.\n     * @param axis axis of rotation.\n     * @param angle angle of rotation.  If undefined, 90 degrees is implied.\n     * @param result optional result vector\n     * @returns undefined if axis has no length.\n     */\n    static createRotateVectorAroundVector(vector, axis, angle) {\n        // Rodriguez formula, https://en.wikipedia.org/wiki/Rodrigues'_rotation_formula\n        const unitAxis = axis.normalize();\n        if (unitAxis) {\n            const xProduct = unitAxis.crossProduct(vector);\n            let c, s;\n            if (angle) {\n                c = angle.cos();\n                s = angle.sin();\n            }\n            else {\n                c = 0.0;\n                s = 1.0;\n            }\n            return Vector3d.createAdd3Scaled(vector, c, xProduct, s, unitAxis, unitAxis.dotProduct(vector) * (1.0 - c));\n        }\n        return undefined;\n    }\n    /**\n     * Set (replace) xyz components so they are a vector from point0 to point1\n     * @param point0 start point of computed vector.\n     * @param point1 end point of computed vector.\n     */\n    setStartEnd(point0, point1) {\n        this.x = point1.x - point0.x;\n        this.y = point1.y - point0.y;\n        this.z = point1.z - point0.z;\n    }\n    /** Return a vector with 000 xyz parts. */\n    static createZero(result) {\n        return Vector3d.create(0, 0, 0, result);\n    }\n    /** Return a unit X vector optionally multiplied by a scale  */\n    static unitX(scale = 1) {\n        return new Vector3d(scale, 0, 0);\n    }\n    /** Return a unit Y vector optionally multiplied by a scale  */\n    static unitY(scale = 1) {\n        return new Vector3d(0, scale, 0);\n    }\n    /** Return a unit Z vector optionally multiplied by a scale  */\n    static unitZ(scale = 1) {\n        return new Vector3d(0, 0, scale);\n    }\n    /**\n     * Scale the instance by 1.0/`denominator`.\n     * @param denominator number by which to divide the coordinates of this instance\n     * @param result optional pre-allocated object to return\n     * @return scaled vector, or undefined if `denominator` is exactly zero (in which case instance is untouched).\n    */\n    safeDivideOrNull(denominator, result) {\n        if (denominator !== 0.0) {\n            return this.scale(1.0 / denominator, result);\n        }\n        return undefined;\n    }\n    /**\n     * Return a normalized instance and instance length.\n     * @param result optional pre-allocated object to return as `v` property\n     * @returns object containing the properties:\n     *  * `v`: unit vector in the direction of the instance, or undefined if `mag` is near zero\n     *  * `mag`: length of the instance prior to normalization\n     */\n    normalizeWithLength(result) {\n        const originalMagnitude = this.magnitude();\n        const correctedMagnitude = Geometry.correctSmallFraction(originalMagnitude);\n        result = result ? result : new Vector3d();\n        return { v: this.safeDivideOrNull(correctedMagnitude, result), mag: originalMagnitude };\n    }\n    /**\n     * Return a unit vector parallel with this. Return undefined if this.magnitude is near zero.\n     * @param result optional result.\n     */\n    normalize(result) {\n        return this.normalizeWithLength(result).v;\n    }\n    /**\n     * If this vector has nonzero length, divide by the length to change to a unit vector.\n     * @returns true if normalization was successful\n     */\n    normalizeInPlace() {\n        return this.normalizeWithLength(this).v !== undefined;\n    }\n    /**\n     * Create a normalized vector from the inputs.\n     * @param result optional result\n     * @returns undefined if and only if normalization fails\n    */\n    static createNormalized(x = 0, y = 0, z = 0, result) {\n        if (undefined === result)\n            result = Vector3d.create(x, y, z);\n        else\n            result.set(x, y, z);\n        if (result.normalizeInPlace())\n            return result;\n        return undefined;\n    }\n    /**\n     * Create a normalized vector from startPoint to endPoint\n     * @param startPoint start point of vector\n     * @param endPoint end point of vector\n     * @param result optional result\n     * @returns undefined if and only if normalization fails.\n    */\n    static createNormalizedStartEnd(startPoint, endPoint, result) {\n        result = Vector3d.createStartEnd(startPoint, endPoint, result);\n        if (result.normalizeInPlace())\n            return result;\n        return undefined;\n    }\n    /**\n     * Return fractional length of the projection of the instance onto the target vector.\n     * * To find the projection vector, scale the target vector by the return value.\n     * * Math details can be found at docs/learning/geometry/PointVector.md\n     * * Visualization can be found at https://www.itwinjs.org/sandbox/SaeedTorabi/ProjectVectorOnVector\n     * and https://www.itwinjs.org/sandbox/SaeedTorabi/ProjectVectorOnPlane\n     * @param target the target vector\n     * @param defaultFraction the returned value in case the magnitude of `target` is too small\n     * @returns the signed length of the projection divided by the length of `target`\n     * */\n    fractionOfProjectionToVector(target, defaultFraction = 0) {\n        /*\n         * Projection vector is ((this.target)/||target||)(target/||target||) = ((this.target)/||target||^2)target\n         * This function returns (this.target)/||target||^2\n         */\n        const denominator = target.magnitudeSquared();\n        if (denominator < Geometry.smallMetricDistanceSquared)\n            return defaultFraction;\n        const numerator = this.dotProduct(target);\n        return numerator / denominator;\n    }\n    /**\n     * Return a new vector with components negated from the calling instance.\n     * @param result optional result vector.\n     */\n    negate(result) {\n        result = result ? result : new Vector3d();\n        result.x = -this.x;\n        result.y = -this.y;\n        result.z = -this.z;\n        return result;\n    }\n    /** Return a vector same length as this but rotate 90 degrees CCW */\n    rotate90CCWXY(result) {\n        result = result ? result : new Vector3d();\n        // save x,y to allow aliasing (\"this\" can be passed to the function as \"result\")\n        const xx = this.x;\n        const yy = this.y;\n        result.x = -yy;\n        result.y = xx;\n        result.z = this.z;\n        return result;\n    }\n    /** Return a vector same length as this but rotated 90 degrees clockwise */\n    rotate90CWXY(result) {\n        result = result ? result : new Vector3d();\n        // save x,y to allow aliasing (\"this\" can be passed to the function as \"result\")\n        const xx = this.x;\n        const yy = this.y;\n        result.x = yy;\n        result.y = -xx;\n        result.z = this.z;\n        return result;\n    }\n    /**\n     * Return a vector which is in the xy plane, perpendicular to the xy part of this vector, and of unit length.\n     * * If the xy part is 00, the return is the rotated (but not normalized) xy parts of this vector.\n     * @param result optional preallocated result.\n     */\n    unitPerpendicularXY(result) {\n        result = result ? result : new Vector3d();\n        const xx = this.x;\n        const yy = this.y;\n        // save x,y to allow aliasing (\"this\" can be passed to the function as \"result\")\n        result.x = -yy;\n        result.y = xx;\n        result.z = 0.0;\n        const d2 = xx * xx + yy * yy;\n        if (d2 !== 0.0) {\n            const a = 1.0 / Math.sqrt(d2);\n            result.x *= a;\n            result.y *= a;\n        }\n        return result;\n    }\n    /**\n     * Rotate the xy parts of this vector around the z axis.\n     * * z is taken unchanged to the result.\n     * @param angle angle to rotate\n     * @param result optional preallocated result\n     */\n    rotateXY(angle, result) {\n        const s = angle.sin();\n        const c = angle.cos();\n        const xx = this.x;\n        const yy = this.y;\n        result = result ? result : new Vector3d();\n        result.x = xx * c - yy * s;\n        result.y = xx * s + yy * c;\n        result.z = this.z;\n        return result;\n    }\n    /**\n     * Return a (new or optionally preallocated) vector that is rotated 90 degrees in\n     * the plane of this vector and the target vector.\n     * @param target Second vector which defines the plane of rotation.\n     * @param result optional preallocated vector for result.\n     * @returns rotated vector, or undefined if the cross product of this and\n     *          the the target cannot be normalized (i.e. if the target and this are colinear)\n     */\n    rotate90Towards(target, result) {\n        const normal = this.crossProduct(target).normalize();\n        return normal ? normal.crossProduct(this, result) : undefined;\n    }\n    /**\n     * Rotate this vector 90 degrees around an axis vector.\n     * * Note that simple cross is in the plane perpendicular to axis -- it loses the part\n     * of \"this\" that is along the axis. The unit and scale is supposed to fix that.\n     * This matches with Rodrigues' rotation formula because cos(theta) = 0 and sin(theta) = 1\n     * @returns the (new or optionally reused result) rotated vector, or undefined if the axis\n     * vector cannot be normalized.\n     */\n    rotate90Around(axis, result) {\n        const unitNormal = axis.normalize();\n        return unitNormal ? unitNormal.crossProduct(this).plusScaled(unitNormal, unitNormal.dotProduct(this), result) : undefined;\n    }\n    /**\n     * Return a vector computed at fractional position between this vector and vectorB\n     * @param fraction fractional position.  0 is at `this`.  1 is at `vectorB`.\n     *                 True fractions are \"between\", negatives are \"before this\", beyond 1 is \"beyond vectorB\".\n     * @param vectorB second vector\n     * @param result optional preallocated result.\n     */\n    interpolate(fraction, vectorB, result) {\n        result = result ? result : new Vector3d();\n        /*\n         * For best last-bit behavior, if fraction is below 0.5, use this as base point.\n         * If above 0.5, use vectorB as base point.\n         */\n        if (fraction <= 0.5) {\n            result.x = this.x + fraction * (vectorB.x - this.x);\n            result.y = this.y + fraction * (vectorB.y - this.y);\n            result.z = this.z + fraction * (vectorB.z - this.z);\n        }\n        else {\n            const t = fraction - 1.0;\n            result.x = vectorB.x + t * (vectorB.x - this.x);\n            result.y = vectorB.y + t * (vectorB.y - this.y);\n            result.z = vectorB.z + t * (vectorB.z - this.z);\n        }\n        return result;\n    }\n    /**\n     * Return the vector sum `this - vector`\n     * @param vector right side of addition.\n     * @param result optional preallocated result.\n     */\n    plus(vector, result) {\n        result = result ? result : new Vector3d();\n        result.x = this.x + vector.x;\n        result.y = this.y + vector.y;\n        result.z = this.z + vector.z;\n        return result;\n    }\n    /**\n     * Return the vector difference `this - vector`\n     * @param vector right side of subtraction.\n     * @param result optional preallocated result.\n     */\n    minus(vector, result) {\n        result = result ? result : new Vector3d();\n        result.x = this.x - vector.x;\n        result.y = this.y - vector.y;\n        result.z = this.z - vector.z;\n        return result;\n    }\n    /** Return vector + vector * scalar */\n    plusScaled(vector, scaleFactor, result) {\n        result = result ? result : new Vector3d();\n        result.x = this.x + vector.x * scaleFactor;\n        result.y = this.y + vector.y * scaleFactor;\n        result.z = this.z + vector.z * scaleFactor;\n        return result;\n    }\n    /** Return the (strongly typed Vector3d) `this Vector3d + vectorA * scalarA + vectorB * scalarB` */\n    plus2Scaled(vectorA, scalarA, vectorB, scalarB, result) {\n        result = result ? result : new Vector3d();\n        result.x = this.x + vectorA.x * scalarA + vectorB.x * scalarB;\n        result.y = this.y + vectorA.y * scalarA + vectorB.y * scalarB;\n        result.z = this.z + vectorA.z * scalarA + vectorB.z * scalarB;\n        return result;\n    }\n    /** Return the (strongly typed Vector3d) `thisVector3d + vectorA * scalarA + vectorB * scalarB + vectorC * scalarC` */\n    plus3Scaled(vectorA, scalarA, vectorB, scalarB, vectorC, scalarC, result) {\n        result = result ? result : new Vector3d();\n        result.x = this.x + vectorA.x * scalarA + vectorB.x * scalarB + vectorC.x * scalarC;\n        result.y = this.y + vectorA.y * scalarA + vectorB.y * scalarB + vectorC.y * scalarC;\n        result.z = this.z + vectorA.z * scalarA + vectorB.z * scalarB + vectorC.z * scalarC;\n        return result;\n    }\n    /** Return the (strongly typed Vector3d) `thisVector3d + vectorA * scalarA + vectorB * scalarB` */\n    static createAdd2Scaled(vectorA, scaleA, vectorB, scaleB, result) {\n        return Vector3d.create(vectorA.x * scaleA + vectorB.x * scaleB, vectorA.y * scaleA + vectorB.y * scaleB, vectorA.z * scaleA + vectorB.z * scaleB, result);\n    }\n    /**\n     * Return the (strongly typed Vector3d) `thisVector3d + vectorA * scalarA + vectorB * scalarB`\n     * with all components presented as numbers\n     */\n    static createAdd2ScaledXYZ(ax, ay, az, scaleA, bx, by, bz, scaleB, result) {\n        return Vector3d.create(ax * scaleA + bx * scaleB, ay * scaleA + by * scaleB, az * scaleA + bz * scaleB, result);\n    }\n    /** Return the (strongly typed Vector3d) `thisVector3d + vectorA * scaleA + vectorB * scaleB + vectorC * scaleC` */\n    static createAdd3Scaled(vectorA, scaleA, vectorB, scaleB, vectorC, scaleC, result) {\n        return Vector3d.create(vectorA.x * scaleA + vectorB.x * scaleB + vectorC.x * scaleC, vectorA.y * scaleA + vectorB.y * scaleB + vectorC.y * scaleC, vectorA.z * scaleA + vectorB.z * scaleB + vectorC.z * scaleC, result);\n    }\n    /** Return vector * scalar */\n    scale(scale, result) {\n        result = result ? result : new Vector3d();\n        result.x = this.x * scale;\n        result.y = this.y * scale;\n        result.z = this.z * scale;\n        return result;\n    }\n    /**\n     * Return a (optionally new or reused) vector in the direction of `this` but with specified length.\n     * @param length desired length of vector\n     * @param result optional preallocated result\n     */\n    scaleToLength(length, result) {\n        const mag = Geometry.correctSmallFraction(this.magnitude());\n        if (mag === 0)\n            return undefined;\n        return this.scale(length / mag, result);\n    }\n    /**\n     * Compute the cross product of this vector with `vectorB`.   Immediately pass it to `normalize`.\n     * @param vectorB second vector for cross product.\n     * @returns see `Vector3d` method `normalize()` for error condition.\n     */\n    unitCrossProduct(vectorB, result) {\n        return this.crossProduct(vectorB, result).normalize(result);\n    }\n    /**\n     * Compute the cross product of this vector with `vectorB`.   Normalize it, using given xyz as\n     * default if length is zero.\n     * @param vectorB second vector of cross product\n     * @param x x value for default result\n     * @param y y value for default result\n     * @param z z value for default result\n     * @param result optional pre-allocated result.\n     */\n    unitCrossProductWithDefault(vectorB, x, y, z, result) {\n        const unit = this.crossProduct(vectorB, result).normalize(result);\n        if (unit === undefined)\n            return Vector3d.create(x, y, z, result);\n        return unit;\n    }\n    /**\n     * Normalize this vector, using given xyz as default if length is zero.\n     * * if this instance and x,y,z are both 000, return unit x vector.\n     * @param x x value for default result\n     * @param y y value for default result\n     * @param z z value for default result\n     * @param result optional pre-allocated result.\n     */\n    normalizeWithDefault(x, y, z, result) {\n        const unit = this.normalize(result);\n        if (unit)\n            return unit;\n        // try back to x,y,z\n        result = Vector3d.create(x, y, z, result);\n        if (result.normalizeInPlace())\n            return result;\n        return Vector3d.create(1, 0, 0, result);\n    }\n    /**\n     * Try to normalize (divide by magnitude), storing the result in place.\n     * @param smallestMagnitude smallest magnitude allowed as divisor.\n     * @returns false if magnitude is too small.  In this case the vector is unchanged.\n     */\n    tryNormalizeInPlace(smallestMagnitude = Geometry.smallFraction) {\n        const a = this.magnitude();\n        if (a < smallestMagnitude || a === 0.0)\n            return false;\n        this.scaleInPlace(1.0 / a);\n        return true;\n    }\n    /**\n     * Compute cross product with `vectorB`\n     * * cross product vector will have the given length.\n     * @param vectorB second vector for cross product.\n     * @param productLength desired length of result vector.\n     * @param result optional preallocated vector\n     * @return undefined if the cross product is near zero length.\n     */\n    sizedCrossProduct(vectorB, productLength, result) {\n        result = this.crossProduct(vectorB, result);\n        if (result.tryNormalizeInPlace()) {\n            result.scaleInPlace(productLength);\n            return result;\n        }\n        return undefined;\n    }\n    /**\n     * Compute the squared magnitude of a cross product (without allocating a temporary vector object)\n     * @param vectorB second vector of cross product\n     * @returns the squared magnitude of the cross product of this instance with vectorB.\n     */\n    crossProductMagnitudeSquared(vectorB) {\n        const xx = this.y * vectorB.z - this.z * vectorB.y;\n        const yy = this.z * vectorB.x - this.x * vectorB.z;\n        const zz = this.x * vectorB.y - this.y * vectorB.x;\n        return xx * xx + yy * yy + zz * zz;\n    }\n    /**\n     * Compute the  magnitude of a cross product (without allocating a temporary vector object)\n     * @param vectorB second vector of cross product\n     * @returns the  magnitude of the cross product of this instance with vectorB.\n     */\n    crossProductMagnitude(vectorB) {\n        return Math.sqrt(this.crossProductMagnitudeSquared(vectorB));\n    }\n    /**\n     * Return the dot product of this vector with vectorB.\n     * @param vectorB second vector of cross product\n     * @returns the dot product of this instance with vectorB\n     */\n    dotProduct(vectorB) {\n        return this.x * vectorB.x + this.y * vectorB.y + this.z * vectorB.z;\n    }\n    /**\n     * Return the dot product of the xyz components of two inputs that are XYAndZ but otherwise not explicitly Vector3d\n     * @param targetA target point for first vector\n     * @param targetB target point for second vector\n     */\n    static dotProductAsXYAndZ(dataA, dataB) {\n        return dataA.x * dataB.x + dataA.y * dataB.y + dataA.z * dataB.z;\n    }\n    /**\n     * Returns the dot product of this vector with the with vector from pointA to pointB\n     * @param pointA start point of second vector of dot product\n     * @param pointB end point of second vector of dot product\n     */\n    dotProductStartEnd(pointA, pointB) {\n        return this.x * (pointB.x - pointA.x)\n            + this.y * (pointB.y - pointA.y)\n            + this.z * (pointB.z - pointA.z);\n    }\n    /**\n     * Returns the dot product with vector (pointB - pointA * pointB.w)\n     * * That is, pointA is weighted to weight of pointB.\n     * * If pointB.w is zero, the homogeneous pointB is a simple vector\n     * * If pointB.w is nonzero, the vector \"from A to B\" is not physical length.\n     */\n    dotProductStart3dEnd4d(pointA, pointB) {\n        const w = pointB.w;\n        return this.x * (pointB.x - pointA.x * w)\n            + this.y * (pointB.y - pointA.y * w)\n            + this.z * (pointB.z - pointA.z * w);\n    }\n    /** Cross product with vector from pointA to pointB */\n    crossProductStartEnd(pointA, pointB, result) {\n        return Vector3d.createCrossProduct(this.x, this.y, this.z, pointB.x - pointA.x, pointB.y - pointA.y, pointB.z - pointA.z, result);\n    }\n    /** Cross product (xy parts only) with vector from pointA to pointB */\n    crossProductStartEndXY(pointA, pointB) {\n        return Geometry.crossProductXYXY(this.x, this.y, pointB.x - pointA.x, pointB.y - pointA.y);\n    }\n    /** Dot product with vector from pointA to pointB, with pointB given as x,y,z */\n    dotProductStartEndXYZ(pointA, x, y, z) {\n        return this.x * (x - pointA.x)\n            + this.y * (y - pointA.y)\n            + this.z * (z - pointA.z);\n    }\n    /** Dot product with vector from pointA to pointB, using only xy parts */\n    dotProductStartEndXY(pointA, pointB) {\n        return this.x * (pointB.x - pointA.x)\n            + this.y * (pointB.y - pointA.y);\n    }\n    /**\n     * Dot product with vector from pointA to pointB, with pointB given as (weighted) wx,wy,wz,w\n     * * We need to unweight pointB (which is a homogeneous point) to be able to participate in the\n     * vector dot product\n     * * if the weight is near zero metric, the return is zero.\n     */\n    dotProductStartEndXYZW(pointA, wx, wy, wz, w) {\n        if (Geometry.isSmallMetricDistance(w))\n            return 0.0;\n        const dw = 1.0 / w;\n        return this.x * (dw * wx - pointA.x)\n            + this.y * (dw * wy - pointA.y)\n            + this.z * (dw * wz - pointA.z);\n    }\n    /** Return the dot product of the instance and vectorB, using only the x and y parts. */\n    dotProductXY(vectorB) {\n        return this.x * vectorB.x + this.y * vectorB.y;\n    }\n    /**\n     * Dot product with vector (x,y,z)\n     * @param x x component for dot product\n     * @param y y component for dot product\n     * @param z z component for dot product\n     */\n    dotProductXYZ(x, y, z = 0) {\n        return this.x * x + this.y * y + this.z * z;\n    }\n    /** Return the triple product of the instance, vectorB, and vectorC  */\n    tripleProduct(vectorB, vectorC) {\n        return Geometry.tripleProduct(this.x, this.y, this.z, vectorB.x, vectorB.y, vectorB.z, vectorC.x, vectorC.y, vectorC.z);\n    }\n    /** Return the cross product of the instance and vectorB, using only the x and y parts. */\n    crossProductXY(vectorB) {\n        return this.x * vectorB.y - this.y * vectorB.x;\n    }\n    /**\n     * Return the cross product of this vector and vectorB.\n     * * Visualization can be found at https://www.itwinjs.org/sandbox/SaeedTorabi/CrossProduct\n     * @param vectorB second vector of cross product\n     * @param result optional preallocated result.\n     */\n    crossProduct(vectorB, result) {\n        return Vector3d.createCrossProduct(this.x, this.y, this.z, vectorB.x, vectorB.y, vectorB.z, result);\n    }\n    /**\n     * Return cross product of `this` with the vector `(x, y, z)`\n     * @param x x component of second vector\n     * @param y y component of second vector\n     * @param z z component of second vector\n     * @param result computed cross product (new Vector3d).\n     */\n    crossProductXYZ(x, y, z, result) {\n        return Vector3d.createCrossProduct(this.x, this.y, this.z, x, y, z, result);\n    }\n    /**\n     * Return the angle in radians (not as strongly typed Angle) from this vector to vectorB.\n     * * The returned angle is between 0 and `Math.PI`.\n     * * The returned angle is measured in the plane containing the two vectors.\n     * * Use `planarRadiansTo` and `signedRadiansTo` to return an angle measured in a specific plane.\n     * @param vectorB target vector.\n     */\n    radiansTo(vectorB) {\n        // ||axb|| = ||a|| ||b|| |sin(t)| and a.b = ||a|| ||b|| cos(t) ==>\n        // ||axb|| / a.b = sin(t)/cos(t) = tan(t) ==> t = arctan(||axb|| / a.b).\n        return Math.atan2(this.crossProductMagnitude(vectorB), this.dotProduct(vectorB));\n    }\n    /**\n     * Return the (strongly-typed) angle from this vector to vectorB.\n     * * The returned angle is between 0 and 180 degrees.\n     * * The returned angle is measured in the plane containing the two vectors.\n     * * Use `planarAngleTo` and `signedAngleTo` to return an angle measured in a specific plane.\n     * @param vectorB target vector.\n     */\n    angleTo(vectorB) {\n        return Angle.createRadians(this.radiansTo(vectorB));\n    }\n    /**\n     * Return the (strongly-typed) angle from this vector to the plane perpendicular to planeNormal.\n     * * The returned angle is between -90 and 90 degrees.\n     * * The returned angle is measured in the plane containing the two vectors.\n     * * The function returns PI/2 - angleTo(planeNormal).\n     * @param planeNormal a normal vector to the plane.\n     */\n    angleFromPerpendicular(planeNormal) {\n        return Angle.createAtan2(this.dotProduct(planeNormal), this.crossProductMagnitude(planeNormal));\n    }\n    /**\n     * Return the (strongly-typed) angle from this vector to vectorB, using only the xy parts.\n     * * The returned angle is between -180 and 180 degrees.\n     * * Use `planarAngleTo` and `signedAngleTo` to return an angle measured in a specific plane.\n     * @param vectorB target vector.\n     */\n    angleToXY(vectorB) {\n        return Angle.createAtan2(this.crossProductXY(vectorB), this.dotProductXY(vectorB));\n    }\n    /**\n     * Return the angle in radians (not as strongly-typed Angle) from this vector to vectorB, measured\n     * in their containing plane whose normal lies in the same half-space as vectorW.\n     * * The returned angle is between `-Math.PI` and `Math.PI`.\n     * * If the cross product of this vector and vectorB lies on the same side of the plane as vectorW,\n     * this function returns `radiansTo(vectorB)`; otherwise, it returns `-radiansTo(vectorB)`.\n     * * `vectorW` does not have to be perpendicular to the plane.\n     * * Use `planarRadiansTo` to measure the angle between vectors that are projected to another plane.\n     * @param vectorB target vector.\n     * @param vectorW determines the side of the plane in which the returned angle is measured\n     */\n    signedRadiansTo(vectorB, vectorW) {\n        const p = this.crossProduct(vectorB);\n        const theta = Math.atan2(p.magnitude(), this.dotProduct(vectorB));\n        if (vectorW.dotProduct(p) < 0.0)\n            return -theta;\n        else\n            return theta;\n    }\n    /**\n     * Return the (strongly-typed) angle from this vector to vectorB, measured\n     * in their containing plane whose normal lies in the same half-space as vectorW.\n     * * The returned angle is between -180 and 180 degrees.\n     * * If the cross product of this vector and vectorB lies on the same side of the plane as vectorW,\n     * this function returns `angleTo(vectorB)`; otherwise, it returns `-angleTo(vectorB)`.\n     * * `vectorW` does not have to be perpendicular to the plane.\n     * * Use `planarAngleTo` to measure the angle between vectors that are projected to another plane.\n     * @param vectorB target vector.\n     * @param vectorW determines the side of the plane in which the returned angle is measured\n     */\n    signedAngleTo(vectorB, vectorW) {\n        return Angle.createRadians(this.signedRadiansTo(vectorB, vectorW));\n    }\n    /**\n     * Return the angle in radians (not as strongly-typed Angle) from this vector to vectorB,\n     * measured between their projections to the plane with the given normal.\n     * * The returned angle is between `-Math.PI` and `Math.PI`.\n     * @param vectorB target vector\n     * @param planeNormal the normal vector to the plane.\n     */\n    planarRadiansTo(vectorB, planeNormal) {\n        const square = planeNormal.dotProduct(planeNormal);\n        if (square === 0.0)\n            return 0.0;\n        const factor = 1.0 / square;\n        /*\n         * projection of vector 'v' on normal 'n' is given by vProj = [dot(v,n)/||n||^2]*n\n         * and projection of 'v' on the plane is given by 'v - vProj'\n        */\n        const thisProj = this.plusScaled(planeNormal, -this.dotProduct(planeNormal) * factor);\n        const vectorBProj = vectorB.plusScaled(planeNormal, -vectorB.dotProduct(planeNormal) * factor);\n        return thisProj.signedRadiansTo(vectorBProj, planeNormal);\n    }\n    /**\n     * Return the (strongly-type) angle from this vector to vectorB,\n     * measured between their projections to the plane with the given normal.\n     * * The returned angle is between -180 and 180 degrees.\n     * @param vectorB target vector.\n     * @param planeNormal the normal vector to the plane.\n     */\n    planarAngleTo(vectorB, planeNormal) {\n        return Angle.createRadians(this.planarRadiansTo(vectorB, planeNormal));\n    }\n    /**\n     * Return the smallest angle (in radians) from the (bidirectional) line containing `this`\n     * to the (bidirectional) line containing `vectorB`\n     */\n    smallerUnorientedRadiansTo(vectorB) {\n        const c = this.dotProduct(vectorB);\n        const s = this.crossProductMagnitude(vectorB);\n        return Math.atan2(Math.abs(s), Math.abs(c));\n    }\n    /**\n     * Return the smallest (strongly typed) angle from the (bidirectional) line containing `this`\n     * to the (bidirectional) line containing `vectorB`\n     */\n    smallerUnorientedAngleTo(vectorB) {\n        return Angle.createRadians(this.smallerUnorientedRadiansTo(vectorB));\n    }\n    /**\n     * Test if this vector is parallel to other.\n     * * The input tolerances in `options`, if given, are considered to be squared for efficiency's sake,\n     * so if you have a distance or angle tolerance t, you should pass in t * t.\n     * @param other second vector in comparison\n     * @param oppositeIsParallel whether to consider diametrically opposed vectors as parallel\n     * @param returnValueIfAnInputIsZeroLength if either vector is near zero length, return this value.\n     * @param options optional radian and distance tolerances.\n     */\n    isParallelTo(other, oppositeIsParallel = false, returnValueIfAnInputIsZeroLength = false, options) {\n        const radianSquaredTol = options?.radianSquaredTol ?? Geometry.smallAngleRadiansSquared;\n        const distanceSquaredTol = options?.distanceSquaredTol ?? Geometry.smallMetricDistanceSquared;\n        const a2 = this.magnitudeSquared();\n        const b2 = other.magnitudeSquared();\n        if (a2 < distanceSquaredTol || b2 < distanceSquaredTol)\n            return returnValueIfAnInputIsZeroLength;\n        const dot = this.dotProduct(other);\n        if (dot < 0.0 && !oppositeIsParallel)\n            return false;\n        const cross2 = this.crossProductMagnitudeSquared(other);\n        /* a2,b2,cross2 are squared lengths of respective vectors */\n        /* cross2 = sin^2(theta) * a2 * b2 */\n        /* For small theta, sin^2(theta)~~theta^2 */\n        return cross2 <= radianSquaredTol * a2 * b2;\n    }\n    /**\n     * Test if this vector is perpendicular to other.\n     * * The input tolerances in `options`, if given, are considered to be squared for efficiency's sake,\n     * so if you have a distance or angle tolerance t, you should pass in t * t.\n     * @param other second vector in comparison\n     * @param returnValueIfAnInputIsZeroLength if either vector is near zero length, return this value.\n     * @param options optional radian and distance tolerances.\n     */\n    isPerpendicularTo(other, returnValueIfAnInputIsZeroLength = false, options) {\n        const radianSquaredTol = options?.radianSquaredTol ?? Geometry.smallAngleRadiansSquared;\n        const distanceSquaredTol = options?.distanceSquaredTol ?? Geometry.smallMetricDistanceSquared;\n        const aa = this.magnitudeSquared();\n        const bb = other.magnitudeSquared();\n        if (aa < distanceSquaredTol || bb < distanceSquaredTol)\n            return returnValueIfAnInputIsZeroLength;\n        const ab = this.dotProduct(other);\n        return ab * ab <= radianSquaredTol * aa * bb;\n    }\n}\n//# sourceMappingURL=Point3dVector3d.js.map",
      "start": 1693508123200,
      "end": 1693508123353,
      "sourcemaps": null
    }
  ]
}
