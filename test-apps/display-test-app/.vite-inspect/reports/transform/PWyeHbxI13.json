{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/polyface/Polyface.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Polyface\n */\n/* eslint-disable @typescript-eslint/naming-convention, no-empty */\nimport { GeometryQuery } from \"../curve/GeometryQuery\";\nimport { Geometry } from \"../Geometry\";\nimport { GrowableXYArray } from \"../geometry3d/GrowableXYArray\";\nimport { GrowableXYZArray } from \"../geometry3d/GrowableXYZArray\";\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\nimport { NumberArray } from \"../geometry3d/PointHelpers\";\nimport { FacetFaceData } from \"./FacetFaceData\";\nimport { IndexedPolyfaceVisitor } from \"./IndexedPolyfaceVisitor\";\nimport { PolyfaceData } from \"./PolyfaceData\";\n/**\n * A Polyface is an abstract mesh structure (of unspecified implementation) that provides a PolyfaceVisitor\n * to iterate over its facets.\n * @public\n */\nexport class Polyface extends GeometryQuery {\n    constructor(data) {\n        super();\n        /** String name for schema properties */\n        this.geometryCategory = \"polyface\";\n        this.data = data;\n    }\n    /** Flag indicating if the mesh display must assume both sides are visible. */\n    get twoSided() { return this.data.twoSided; }\n    set twoSided(value) { this.data.twoSided = value; }\n    /** Flag indicating if the mesh closure is unknown (0), open sheet (1), closed (2) */\n    get expectedClosure() { return this.data.expectedClosure; }\n    set expectedClosure(value) { this.data.expectedClosure = value; }\n    /**\n       * Check validity of indices into a data array.\n       * * It is valid to have  both indices and data undefined.\n       * * It is NOT valid for just one to be defined.\n       * * Index values at indices[indexPositionA <= i < indexPositionB] must be valid indices to the data array.\n       * @param indices array of indices.\n       * @param indexPositionA first index to test\n       * @param indexPositionB one past final index to test\n       * @param data data array\n       * @param dataLength length of data array\n       */\n    static areIndicesValid(indices, indexPositionA, indexPositionB, data, dataLength) {\n        if (indices === undefined && data === undefined)\n            return true;\n        if (!indices || !data)\n            return false;\n        if (indexPositionA < 0 || indexPositionA >= indices.length)\n            return false;\n        if (indexPositionB < indexPositionA || indexPositionB > indices.length)\n            return false;\n        for (let i = indexPositionA; i < indexPositionB; i++)\n            if (indices[i] < 0 || indices[i] >= dataLength)\n                return false;\n        return true;\n    }\n    /**\n     * Returns the number of facets of this polyface. Subclasses should override.\n     */\n    get facetCount() {\n        return undefined;\n    }\n}\n/**\n * An `IndexedPolyface` is a set of facets which can have normal, param, and color arrays with independent point, normal, param, and color indices.\n * @public\n */\nexport class IndexedPolyface extends Polyface {\n    /** Test if other is an instance of `IndexedPolyface` */\n    isSameGeometryClass(other) { return other instanceof IndexedPolyface; }\n    /** Tests for equivalence between two IndexedPolyfaces. */\n    isAlmostEqual(other) {\n        if (other instanceof IndexedPolyface) {\n            return this.data.isAlmostEqual(other.data) && NumberArray.isExactEqual(this._facetStart, other._facetStart) &&\n                NumberArray.isExactEqual(this._facetToFaceData, other._facetToFaceData);\n        }\n        return false;\n    }\n    /**\n     * Returns true if either the point array or the point index array is empty.\n     */\n    get isEmpty() { return this.data.pointCount === 0 || this.data.pointIndex.length === 0; }\n    /**\n     * * apply the transform to points\n     * * apply the (inverse transpose of) the matrix part to normals\n     * * If determinant is negative, also\n     *   * negate normals\n     *   * reverse index order around each facet.\n     * @param transform\n     */\n    tryTransformInPlace(transform) {\n        if (!this.data.tryTransformInPlace(transform))\n            return false;\n        const determinant = transform.matrix.determinant();\n        if (determinant < 0) {\n            this.reverseIndices();\n            this.reverseNormals();\n        }\n        return true;\n    }\n    /** Reverse indices for a single facet. */\n    reverseSingleFacet(facetId) {\n        this.data.reverseIndicesSingleFacet(facetId, this._facetStart);\n    }\n    /** Return a deep clone. */\n    clone() {\n        const result = new IndexedPolyface(this.data.clone(), this._facetStart.slice(), this._facetToFaceData.slice());\n        return result;\n    }\n    /** Return a deep clone with transformed points and normals */\n    cloneTransformed(transform) {\n        const result = this.clone();\n        result.tryTransformInPlace(transform);\n        return result;\n    }\n    /** Reverse the order of indices around all facets. */\n    reverseIndices() { this.data.reverseIndices(this._facetStart); }\n    /** Reverse the direction of all normal vectors. */\n    reverseNormals() { this.data.reverseNormals(); }\n    /** return face data using a facet index. This is the REFERENCE to the FacetFaceData, not a copy. Returns undefined if none found. */\n    tryGetFaceData(i) {\n        const faceIndex = this._facetToFaceData[i];\n        if (faceIndex >= this.data.face.length)\n            return undefined;\n        return this.data.face[faceIndex];\n    }\n    /**\n     * Constructor for a new polyface.\n     * @param data PolyfaceData arrays to capture.\n     * @param facetStart optional array of facet start indices (e.g. known during clone)\n     * @param facetToFacetData optional array of face identifiers (e.g. known during clone)\n     */\n    constructor(data, facetStart, facetToFaceData) {\n        super(data);\n        if (facetStart)\n            this._facetStart = facetStart.slice();\n        else {\n            this._facetStart = [];\n            this._facetStart.push(0);\n        }\n        if (facetToFaceData)\n            this._facetToFaceData = facetToFaceData.slice();\n        else\n            this._facetToFaceData = [];\n    }\n    /**\n     * * Add facets from source to this polyface.\n     * * Optionally reverse facet indices as per PolyfaceData.reverseIndicesSingleFacet() with preserveStart = false, and invert source normals.\n     * * Optionally apply a transform to points and normals.\n     * * Will only copy param, normal, color, and face data if we are already tracking them AND/OR the source contains them.\n     */\n    addIndexedPolyface(source, reversed, transform) {\n        const numSourceFacets = source.facetCount;\n        // Add point, point index, and edge visibility data\n        // Note: there is no need to build an intermediate index map since all points are added\n        const startOfNewPoints = this.data.point.length;\n        const xyz = Point3d.create();\n        for (let i = 0; i < source.data.point.length; i++) {\n            source.data.point.getPoint3dAtUncheckedPointIndex(i, xyz);\n            if (transform) {\n                transform.multiplyPoint3d(xyz, xyz);\n                this.addPoint(xyz);\n            }\n            else\n                this.addPoint(xyz);\n        }\n        for (let i = 0; i < numSourceFacets; i++) {\n            const i0 = source._facetStart[i];\n            const i1 = source._facetStart[i + 1];\n            if (reversed) {\n                for (let j = i1; j-- > i0;) { // visibility is transferred from far vertex, e.g., -abc-d => dc-b-a\n                    this.addPointIndex(startOfNewPoints + source.data.pointIndex[j], source.data.edgeVisible[j > i0 ? j - 1 : i1 - 1]);\n                }\n            }\n            else {\n                for (let j = i0; j < i1; j++) {\n                    this.addPointIndex(startOfNewPoints + source.data.pointIndex[j], source.data.edgeVisible[j]);\n                }\n            }\n            this.terminateFacet(false);\n        }\n        // Add param and param index data\n        if (undefined !== this.data.param && undefined !== source.data.param && undefined !== source.data.paramIndex) {\n            const startOfNewParams = this.data.param.length;\n            this.data.param.pushFromGrowableXYArray(source.data.param);\n            for (let i = 0; i < numSourceFacets; i++) { // Expect facet start and ends for points to match normals\n                const i0 = source._facetStart[i];\n                const i1 = source._facetStart[i + 1];\n                if (reversed) {\n                    for (let j = i1; j-- > i0;)\n                        this.addParamIndex(startOfNewParams + source.data.paramIndex[j]);\n                }\n                else {\n                    for (let j = i0; j < i1; j++)\n                        this.addParamIndex(startOfNewParams + source.data.paramIndex[j]);\n                }\n            }\n        }\n        // Add normal and normal index data\n        if (undefined !== this.data.normal && undefined !== source.data.normal && undefined !== source.data.normalIndex) {\n            const startOfNewNormals = this.data.normal.length;\n            for (let i = 0; i < source.data.normal.length; i++) {\n                const sourceNormal = source.data.normal.getVector3dAtCheckedVectorIndex(i);\n                if (transform)\n                    transform.multiplyVector(sourceNormal, sourceNormal);\n                if (reversed)\n                    sourceNormal.scaleInPlace(-1.0);\n                this.addNormal(sourceNormal);\n            }\n            for (let i = 0; i < numSourceFacets; i++) { // Expect facet start and ends for points to match normals\n                const i0 = source._facetStart[i];\n                const i1 = source._facetStart[i + 1];\n                if (reversed) {\n                    for (let j = i1; j-- > i0;)\n                        this.addNormalIndex(startOfNewNormals + source.data.normalIndex[j]);\n                }\n                else {\n                    for (let j = i0; j < i1; j++)\n                        this.addNormalIndex(startOfNewNormals + source.data.normalIndex[j]);\n                }\n            }\n        }\n        // Add color and color index data\n        if (undefined !== this.data.color && undefined !== source.data.color && undefined !== source.data.colorIndex) {\n            const startOfNewColors = this.data.color.length;\n            for (const sourceColor of source.data.color)\n                this.addColor(sourceColor);\n            for (let i = 0; i < numSourceFacets; i++) { // Expect facet start and ends for points to match colors\n                const i0 = source._facetStart[i];\n                const i1 = source._facetStart[i + 1];\n                if (reversed) {\n                    for (let j = i1; j-- > i0;)\n                        this.addColorIndex(startOfNewColors + source.data.colorIndex[j]);\n                }\n                else {\n                    for (let j = i0; j < i1; j++)\n                        this.addColorIndex(startOfNewColors + source.data.colorIndex[j]);\n                }\n            }\n        }\n        // Add face and facetToFace index data\n        if (source.data.face.length !== 0) {\n            const startOfNewFaceData = this.data.face.length;\n            for (const face of source.data.face) {\n                const sourceFaceData = face.clone();\n                this.data.face.push(sourceFaceData);\n            }\n            for (const facetToFaceIdx of source._facetToFaceData) {\n                this._facetToFaceData.push(startOfNewFaceData + facetToFaceIdx);\n            }\n        }\n    }\n    /** Return the total number of param indices in zero-terminated style, which includes\n     * * all the indices in the packed zero-based table\n     * * one additional index for the zero-terminator of each facet.\n     * @note Note that all index arrays (point, normal, param, color) have the same counts, so there\n     * is not a separate query for each of them.\n     */\n    get zeroTerminatedIndexCount() { return this.data.pointIndex.length + this._facetStart.length - 1; }\n    /** Create an empty facet set, with coordinate and index data to be supplied later.\n     * @param needNormals true if normals will be constructed\n     * @param needParams true if uv parameters will be constructed\n     * @param needColors true if colors will e constructed.\n     */\n    static create(needNormals = false, needParams = false, needColors = false, twoSided = false) {\n        return new IndexedPolyface(new PolyfaceData(needNormals, needParams, needColors, twoSided));\n    }\n    /** add (a clone of ) a point. return its 0 based index.\n     * @param point point coordinates\n     * @param priorIndex optional index of prior point to check for repeated coordinates\n     * @returns Returns the zero-based index of the added or reused point.\n     */\n    addPoint(point, priorIndex) {\n        if (priorIndex !== undefined) {\n            const distance = this.data.point.distanceIndexToPoint(priorIndex, point);\n            if (distance !== undefined && Geometry.isSmallMetricDistance(distance))\n                return priorIndex;\n        }\n        this.data.point.pushXYZ(point.x, point.y, point.z);\n        return this.data.point.length - 1;\n    }\n    /** add a point.\n     * @returns Returns the zero-based index of the added point.\n     */\n    addPointXYZ(x, y, z) { this.data.point.pushXYZ(x, y, z); return this.data.point.length - 1; }\n    /** Add a uv param.\n     * @returns 0-based index of the added param.\n     */\n    addParam(param) {\n        if (!this.data.param)\n            this.data.param = new GrowableXYArray();\n        this.data.param.push(param);\n        return this.data.param.length - 1;\n    }\n    /** Add a uv parameter to the parameter array.\n     * @param priorIndexA first index to check for possible duplicate value.\n     * @param priorIndexB second index to check for possible duplicate value.\n     * @returns 0-based index of the added or reused param.\n     */\n    addParamUV(u, v, priorIndexA, priorIndexB) {\n        if (!this.data.param)\n            this.data.param = new GrowableXYArray();\n        if (priorIndexA !== undefined && this.data.isAlmostEqualParamIndexUV(priorIndexA, u, v))\n            return priorIndexA;\n        if (priorIndexB !== undefined && this.data.isAlmostEqualParamIndexUV(priorIndexB, u, v))\n            return priorIndexB;\n        this.data.param.pushXY(u, v);\n        return this.data.param.length - 1;\n    }\n    /** Add a normal vector\n     * @param priorIndexA first index to check for possible duplicate value.\n     * @param priorIndexB second index to check for possible duplicate value.\n     * @returns 0-based index of the added or reused normal.\n     */\n    addNormal(normal, priorIndexA, priorIndexB) {\n        if (this.data.normal !== undefined) {\n            let distance;\n            if (priorIndexA !== undefined) {\n                distance = this.data.normal.distanceIndexToPoint(priorIndexA, normal);\n                if (distance !== undefined && Geometry.isSmallMetricDistance(distance))\n                    return priorIndexA;\n            }\n            if (priorIndexB !== undefined) {\n                distance = this.data.normal.distanceIndexToPoint(priorIndexB, normal);\n                if (distance !== undefined && Geometry.isSmallMetricDistance(distance))\n                    return priorIndexB;\n            }\n            // Note: Do NOT attempt to chain to tail if no prior indices given.\n            // But if they are, look also to the tail.\n            if (priorIndexA !== undefined || priorIndexB !== undefined) {\n                const tailIndex = this.data.normal.length - 1;\n                distance = this.data.normal.distanceIndexToPoint(tailIndex, normal);\n                if (distance !== undefined && Geometry.isSmallMetricDistance(distance))\n                    return tailIndex;\n            }\n        }\n        return this.addNormalXYZ(normal.x, normal.y, normal.z);\n    }\n    /** Add a normal vector given by direct coordinates\n     * @returns 0-based index of the added or reused param.\n     */\n    addNormalXYZ(x, y, z) {\n        if (!this.data.normal)\n            this.data.normal = new GrowableXYZArray();\n        this.data.normal.pushXYZ(x, y, z);\n        return this.data.normal.length - 1;\n    }\n    /** Add a color\n     * @returns 0-based index of the added or reused color.\n     */\n    addColor(color) {\n        if (!this.data.color)\n            this.data.color = [];\n        this.data.color.push(color);\n        return this.data.color.length - 1;\n    }\n    /** Add a point index with edge visibility flag. */\n    addPointIndex(index, visible = true) { this.data.pointIndex.push(index); this.data.edgeVisible.push(visible); }\n    /** Add a normal index */\n    addNormalIndex(index) {\n        if (!this.data.normalIndex)\n            this.data.normalIndex = [];\n        this.data.normalIndex.push(index);\n    }\n    /** Add a param index */\n    addParamIndex(index) {\n        if (!this.data.paramIndex)\n            this.data.paramIndex = [];\n        this.data.paramIndex.push(index);\n    }\n    /** Add a color index */\n    addColorIndex(index) {\n        if (!this.data.colorIndex)\n            this.data.colorIndex = [];\n        this.data.colorIndex.push(index);\n    }\n    /** clean up the open facet.  return the returnValue (so caller can easily return cleanupOpenFacet(\"message\")) */\n    cleanupOpenFacet() {\n        this.data.trimAllIndexArrays(this.data.pointIndex.length);\n    }\n    /** announce the end of construction of a facet.\n     *\n     * * The \"open\" facet is checked for:\n     *\n     * **  Same number of indices among all active index arrays --  point, normal, param, color\n     * **  All indices are within bounds of the respective data arrays.\n     * *  in error cases, all index arrays are trimmed back to the size when previous facet was terminated.\n     * *  \"undefined\" return is normal.   Any other return is a description of an error.\n     */\n    terminateFacet(validateAllIndices = true) {\n        const numFacets = this._facetStart.length - 1;\n        const lengthA = this._facetStart[numFacets]; // number of indices in accepted facets\n        const lengthB = this.data.pointIndex.length; // number of indices including the open facet\n        if (validateAllIndices) {\n            const messages = [];\n            if (lengthB < lengthA + 2)\n                messages.push(\"Less than 3 indices in open facet\");\n            if (this.data.normalIndex && this.data.normalIndex.length !== lengthB)\n                messages.push(\"normalIndex count must match pointIndex count\");\n            if (this.data.paramIndex && this.data.paramIndex.length !== lengthB)\n                messages.push(\"paramIndex count must equal pointIndex count\");\n            if (this.data.colorIndex && this.data.colorIndex.length !== lengthB)\n                messages.push(\"colorIndex count must equal pointIndex count\");\n            if (this.data.edgeVisible.length !== lengthB)\n                messages.push(\"visibleIndex count must equal pointIndex count\");\n            if (!Polyface.areIndicesValid(this.data.normalIndex, lengthA, lengthB, this.data.normal, this.data.normal ? this.data.normal.length : 0))\n                messages.push(\"invalid normal indices in open facet\");\n            if (messages.length > 0) {\n                this.cleanupOpenFacet();\n                return messages;\n            }\n        }\n        // appending to facetStart accepts the facet !!!\n        this._facetStart.push(lengthB);\n        return undefined;\n    }\n    /**\n     * All terminated facets added since the declaration of the previous face\n     * will be grouped into a new face with their own 2D range.\n     */\n    /** (read-only property) number of facets */\n    get facetCount() { return this._facetStart.length - 1; }\n    /** (read-only property) number of faces */\n    get faceCount() { return this.data.faceCount; }\n    /** (read-only property) number of points */\n    get pointCount() { return this.data.pointCount; }\n    /** (read-only property) number of colors */\n    get colorCount() { return this.data.colorCount; }\n    /** (read-only property) number of parameters */\n    get paramCount() { return this.data.paramCount; }\n    /** (read-only property) number of normals */\n    get normalCount() { return this.data.normalCount; }\n    /** Return the number of edges in a particular facet. */\n    numEdgeInFacet(facetIndex) {\n        if (this.isValidFacetIndex(facetIndex))\n            return this._facetStart[facetIndex + 1] - this._facetStart[facetIndex];\n        return 0;\n    }\n    /** test if `index` is a valid facet index. */\n    isValidFacetIndex(index) { return index >= 0 && index + 1 < this._facetStart.length; }\n    /** ASSUME valid facet index . .. return its start index in index arrays. */\n    facetIndex0(index) { return this._facetStart[index]; }\n    /** ASSUME valid facet index . .. return its end index in index arrays. */\n    facetIndex1(index) { return this._facetStart[index + 1]; }\n    /** create a visitor for this polyface */\n    createVisitor(numWrap = 0) { return IndexedPolyfaceVisitor.create(this, numWrap); }\n    /** Return the range of (optionally transformed) points in this mesh. */\n    range(transform, result) { return this.data.range(result, transform); }\n    /** Extend `range` with coordinates from this mesh */\n    extendRange(range, transform) { this.data.range(range, transform); }\n    /** Given the index of a facet, return the data pertaining to the face it is a part of. */\n    getFaceDataByFacetIndex(facetIndex) {\n        return this.data.face[this._facetToFaceData[facetIndex]];\n    }\n    /**\n     * All terminated facets since the last face declaration will be mapped to a single new FacetFaceData object\n     * using facetToFaceData[]. FacetFaceData holds the 2D range of the face. Returns true if successful, false otherwise.\n     */\n    setNewFaceData(endFacetIndex = 0) {\n        const facetStart = this._facetToFaceData.length;\n        if (facetStart >= this._facetStart.length)\n            return false;\n        if (0 === endFacetIndex) // The default for endFacetIndex is really the last facet\n            endFacetIndex = this._facetStart.length; // Last facetStart index corresponds to the next facet if we were to create one\n        const faceData = FacetFaceData.createNull();\n        const visitor = IndexedPolyfaceVisitor.create(this, 0);\n        if (!visitor.moveToReadIndex(facetStart)) { // Move visitor to first facet of new face\n            return false;\n        }\n        // If parameter range is provided (by the polyface planeSet clipper) then use it\n        const paramDefined = this.data.param !== undefined;\n        const setParamRange = faceData.paramRange.isNull && paramDefined;\n        do {\n            if (setParamRange && visitor.param !== undefined)\n                visitor.param.extendRange(faceData.paramRange);\n        } while (visitor.moveToNextFacet() && visitor.currentReadIndex() < endFacetIndex);\n        if (paramDefined && !(this.data.param.length === 0) && faceData.paramDistanceRange.isNull)\n            faceData.setParamDistanceRangeFromNewFaceData(this, facetStart, endFacetIndex);\n        this.data.face.push(faceData);\n        const faceDataIndex = this.data.face.length - 1;\n        for (let i = this._facetToFaceData.length; i < endFacetIndex; i++)\n            this._facetToFaceData.push(0 === this._facetStart[i] ? 0 : faceDataIndex);\n        return true;\n    }\n    /** Second step of double dispatch:  call `handler.handleIndexedPolyface(this)` */\n    dispatchToGeometryHandler(handler) {\n        return handler.handleIndexedPolyface(this);\n    }\n}\n//# sourceMappingURL=Polyface.js.map",
      "start": 1693508123903,
      "end": 1693508124077,
      "sourcemaps": null
    }
  ]
}
