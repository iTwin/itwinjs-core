{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/numerics/UnionFind.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/**\n * Implement the classic UnionFind algorithm, viz https://en.wikipedia.org/wiki/Disjoint-set_data_structure\n * * Each of the entities being merged exists as an entry in an array.\n * * The index in the array is the (only!) identification of the entity.\n * * The array entry is the index of a parent in the merge process.\n * * New entries are created as singletons pointing to themselves.\n * * Merge (i,j) merges the collections containing entries (i) and (j) into a single collection.\n * * The merge process updates the indices \"above\" (i) and (j)\n * * The whole process is extraordinarily efficient regardless of the order that the (i,j) merges are announced.\n * @internal\n */\nexport class UnionFindContext {\n    /** Create a set initialized with numLeaf singleton subsets */\n    constructor(numLeaf = 0) {\n        this._parentArray = [];\n        for (let i = 0; i < numLeaf; i++)\n            this._parentArray.push(i);\n    }\n    /** Return the number of leaves. */\n    get length() { return this._parentArray.length; }\n    /** test if index is within the valid index range. */\n    isValidIndex(index) {\n        return 0 <= index && index < this._parentArray.length;\n    }\n    /** Return the index of a new singleton set */\n    addLeaf() {\n        const index = this._parentArray.length;\n        this._parentArray.push(index);\n        return index;\n    }\n    /**\n     * * follow links to parent\n     * * after finding the parent, repeat the search and reset parents along the way.\n     * * If index is invalid, return index unchanged.\n     * @param index start of search\n     */\n    findRoot(index) {\n        if (!this.isValidIndex(index))\n            return index;\n        let currentIndex = index;\n        let nextIndex = this._parentArray[index];\n        while (nextIndex !== currentIndex) {\n            currentIndex = nextIndex;\n            nextIndex = this._parentArray[currentIndex];\n        }\n        const rootIndex = currentIndex;\n        // sweep up again and shorten the paths.\n        currentIndex = index;\n        while (currentIndex !== rootIndex) {\n            nextIndex = this._parentArray[currentIndex];\n            this._parentArray[currentIndex] = rootIndex;\n            currentIndex = nextIndex;\n        }\n        return rootIndex;\n    }\n    /** Merge the subsets containing index (i) and (j)\n     * * Look up the root of each.\n     * * Fix up the path to the root so it points to the root.\n     * * Return the root index of the merged set.\n     * * If either index is invalid return index i with no changes.\n     */\n    mergeSubsets(i, j) {\n        if (!this.isValidIndex(i) || !this.isValidIndex(j))\n            return i;\n        const rootIndexI = this.findRoot(i);\n        const rootIndexJ = this.findRoot(j);\n        if (rootIndexI !== rootIndexJ)\n            this._parentArray[rootIndexI] = rootIndexJ;\n        // cleanup a little more ...\n        return this.findRoot(i);\n    }\n    /** Return the immediate parent of index (i), with no fixups\n     * * If index is invalid, return it.\n     */\n    askParent(index) {\n        if (!this.isValidIndex(index))\n            return index;\n        return this._parentArray[index];\n    }\n    /** Return the number of entries which are their own parent. */\n    countRoots() {\n        let numRoot = 0;\n        const numLeaf = this._parentArray.length;\n        for (let i = 0; i < numLeaf; i++)\n            if (this._parentArray[i] === i)\n                numRoot++;\n        return numRoot;\n    }\n    /** Return the number of entries whose parent is not a root. */\n    countNonTrivialPaths() {\n        let numLong = 0;\n        const numLeaf = this._parentArray.length;\n        for (let i = 0; i < numLeaf; i++) {\n            const j = this._parentArray[i];\n            if (j !== i && this._parentArray[j] !== j)\n                numLong++;\n        }\n        return numLong;\n    }\n    /** Return an array of all root indices.\n     * * This array is sorted.\n     */\n    collectRootIndices() {\n        const roots = [];\n        const numLeaf = this._parentArray.length;\n        for (let i = 0; i < numLeaf; i++) {\n            if (this._parentArray[i] === i)\n                roots.push(i);\n        }\n        return roots;\n    }\n}\n//# sourceMappingURL=UnionFind.js.map",
      "start": 1693508125483,
      "end": 1693508125583,
      "sourcemaps": null
    }
  ]
}
