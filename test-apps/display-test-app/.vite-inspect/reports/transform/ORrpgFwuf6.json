{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/common/lib/esm/rpc/core/RpcConfiguration.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "var _a;\nimport { RpcManager } from \"../../RpcManager\";\nimport { RpcControlChannel } from \"./RpcControl\";\nimport { RpcProtocol } from \"./RpcProtocol\";\nimport { INSTANCE } from \"./RpcRegistry\";\nimport { RpcRequest } from \"./RpcRequest\";\nimport { RpcRoutingToken } from \"./RpcRoutingToken\";\n/** @internal */\nexport var RpcRoutingMap;\n(function (RpcRoutingMap) {\n    function create() {\n        const configurations = new Map();\n        return Object.assign((routing) => configurations.get(routing.id)(), { configurations });\n    }\n    RpcRoutingMap.create = create;\n})(RpcRoutingMap || (RpcRoutingMap = {}));\n/** A RpcConfiguration specifies how calls on an RPC interface will be marshalled, plus other operating parameters.\n * RpcConfiguration is the base class for specific configurations.\n * @beta\n */\nclass RpcConfiguration {\n    constructor() {\n        /** @internal */\n        this.attached = [];\n        /** @internal */\n        this.allowAttachedInterfaces = true;\n        /** The target interval (in milliseconds) between connection attempts for pending RPC operation requests. */\n        this.pendingOperationRetryInterval = 10000;\n        /** The maximum number of transient faults permitted before request failure. */\n        this.transientFaultLimit = 4;\n        /** @internal */\n        this.routing = RpcRoutingToken.default;\n        /** The control channel for the configuration.\n         * @internal\n         */\n        this.controlChannel = RpcControlChannel.obtain(this);\n    }\n    /** @internal Sets the configuration supplier for an RPC interface class. */\n    static assign(definition, supplier) {\n        const map = definition.prototype.configurationSupplier;\n        if (!map || typeof (map.configurations) === \"undefined\") {\n            definition.prototype.configurationSupplier = supplier;\n        }\n        else {\n            map.configurations.set(RpcRoutingToken.default.id, supplier);\n        }\n    }\n    /** Sets the configuration supplier for an RPC interface class for a given routing. */\n    static assignWithRouting(definition, routing, configuration) {\n        if (!definition.prototype.configurationSupplier) {\n            RpcConfiguration.assign(definition, RpcRoutingMap.create());\n        }\n        let map = definition.prototype.configurationSupplier;\n        if (typeof (map.configurations) === \"undefined\") {\n            const existing = map;\n            map = RpcRoutingMap.create();\n            RpcConfiguration.assign(definition, map);\n            map.configurations.set(RpcRoutingToken.default.id, existing);\n        }\n        const supplier = () => configuration;\n        map.configurations.set(routing.id, supplier);\n    }\n    /** Obtains the instance of an RPC configuration class. */\n    static obtain(configurationConstructor) {\n        let instance = configurationConstructor[INSTANCE];\n        if (!instance)\n            instance = configurationConstructor[INSTANCE] = new configurationConstructor();\n        return instance;\n    }\n    /** @internal */\n    get attachedInterfaces() { return this.attached; }\n    /** @internal */\n    attach(definition) {\n        if (!this.allowAttachedInterfaces) {\n            return;\n        }\n        if (this.interfaces().indexOf(definition) !== -1 || this.attached.indexOf(definition) !== -1) {\n            return;\n        }\n        this.attached.push(definition);\n        RpcConfiguration.assign(definition, () => this.constructor);\n        RpcManager.initializeInterface(definition);\n    }\n    /** Initializes the RPC interfaces managed by the configuration. */\n    static initializeInterfaces(configuration) {\n        configuration.interfaces().forEach((definition) => RpcManager.initializeInterface(definition));\n    }\n    /** @internal */\n    static supply(definition) {\n        return RpcConfiguration.obtain(definition.configurationSupplier ? definition.configurationSupplier(definition.routing) : RpcDefaultConfiguration);\n    }\n    /** @internal */\n    onRpcClientInitialized(definition, client) {\n        this.protocol.onRpcClientInitialized(definition, client);\n    }\n    /** @internal */\n    onRpcImplInitialized(definition, impl) {\n        this.protocol.onRpcImplInitialized(definition, impl);\n    }\n    /** @internal */\n    onRpcClientTerminated(definition, client) {\n        this.protocol.onRpcClientTerminated(definition, client);\n    }\n    /** @internal */\n    onRpcImplTerminated(definition, impl) {\n        this.protocol.onRpcImplTerminated(definition, impl);\n    }\n}\n_a = RpcConfiguration;\n/** Whether development mode is enabled.\n * @note This parameter determines whether developer convenience features like backend stack traces are available.\n */\nRpcConfiguration.developmentMode = false;\n/** Whether frontend checks that are relevant in a cloud-hosted routing scenario are disabled. */\nRpcConfiguration.disableRoutingValidation = false;\n/** Whether strict mode is enabled.\n * This parameter determines system behaviors relating to strict checking:\n * - Whether an error is thrown if the type marshaling system encounters an unregistered type (only in strict mode).\n */\nRpcConfiguration.strictMode = false;\n/**\n * Whether to throw an error when the IModelRpcProps in the operation parameter list differs from the token in the URL.\n * @note By default, a warning is logged and the operation is allowed to proceed.\n * @note The parameter token is always replaced by the url token (unless RpcOperationPolicy.allowTokenMismatch is set).\n */\nRpcConfiguration.throwOnTokenMismatch = false;\n/** @internal Enables passing of application-specific context with each RPC request. */\nRpcConfiguration.requestContext = {\n    getId: (_request) => \"\",\n    serialize: async (request) => ({\n        id: request.id,\n        applicationId: \"\",\n        applicationVersion: \"\",\n        sessionId: \"\",\n        authorization: \"\",\n    }),\n};\nexport { RpcConfiguration };\n/** A default configuration that can be used for basic testing within a library.\n * @internal\n */\nexport class RpcDefaultConfiguration extends RpcConfiguration {\n    constructor() {\n        super(...arguments);\n        this.interfaces = () => [];\n        this.protocol = new RpcDirectProtocol(this);\n    }\n}\n/** A default protocol that can be used for basic testing within a library.\n * @internal\n */\nexport class RpcDirectProtocol extends RpcProtocol {\n    constructor() {\n        super(...arguments);\n        this.requestType = RpcDirectRequest;\n    }\n}\n/** A default request type that can be used for basic testing within a library.\n * @internal\n */\nexport class RpcDirectRequest extends RpcRequest {\n    constructor() {\n        super(...arguments);\n        this.headers = new Map();\n        this.fulfillment = undefined;\n    }\n    async send() {\n        const request = await this.protocol.serialize(this);\n        return new Promise(async (resolve, reject) => {\n            try {\n                this.fulfillment = await this.protocol.fulfill(request);\n                resolve(this.fulfillment.status);\n            }\n            catch (err) {\n                reject(err);\n            }\n        });\n    }\n    setHeader(name, value) {\n        this.headers.set(name, value);\n    }\n    async load() {\n        return this.fulfillment.result;\n    }\n}\n//# sourceMappingURL=RpcConfiguration.js.map",
      "start": 1693508121039,
      "end": 1693508121101,
      "sourcemaps": null
    }
  ]
}
