{
  "resolvedId": "D:/hub2023A/itwinjs-core/common/temp/node_modules/.pnpm/@loaders.gl+schema@3.4.7/node_modules/@loaders.gl/schema/dist/esm/lib/schema/impl/type.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nlet _Symbol$toStringTag, _Symbol$toStringTag2, _Symbol$toStringTag3, _Symbol$toStringTag4, _Symbol$toStringTag5, _Symbol$toStringTag6, _Symbol$toStringTag7, _Symbol$toStringTag8;\nimport { Type } from './enum';\nexport { Type } from './enum';\nexport class DataType {\n  static isNull(x) {\n    return x && x.typeId === Type.Null;\n  }\n  static isInt(x) {\n    return x && x.typeId === Type.Int;\n  }\n  static isFloat(x) {\n    return x && x.typeId === Type.Float;\n  }\n  static isBinary(x) {\n    return x && x.typeId === Type.Binary;\n  }\n  static isUtf8(x) {\n    return x && x.typeId === Type.Utf8;\n  }\n  static isBool(x) {\n    return x && x.typeId === Type.Bool;\n  }\n  static isDecimal(x) {\n    return x && x.typeId === Type.Decimal;\n  }\n  static isDate(x) {\n    return x && x.typeId === Type.Date;\n  }\n  static isTime(x) {\n    return x && x.typeId === Type.Time;\n  }\n  static isTimestamp(x) {\n    return x && x.typeId === Type.Timestamp;\n  }\n  static isInterval(x) {\n    return x && x.typeId === Type.Interval;\n  }\n  static isList(x) {\n    return x && x.typeId === Type.List;\n  }\n  static isStruct(x) {\n    return x && x.typeId === Type.Struct;\n  }\n  static isUnion(x) {\n    return x && x.typeId === Type.Union;\n  }\n  static isFixedSizeBinary(x) {\n    return x && x.typeId === Type.FixedSizeBinary;\n  }\n  static isFixedSizeList(x) {\n    return x && x.typeId === Type.FixedSizeList;\n  }\n  static isMap(x) {\n    return x && x.typeId === Type.Map;\n  }\n  static isDictionary(x) {\n    return x && x.typeId === Type.Dictionary;\n  }\n  get typeId() {\n    return Type.NONE;\n  }\n  compareTo(other) {\n    return this === other;\n  }\n}\nexport class Null extends DataType {\n  get typeId() {\n    return Type.Null;\n  }\n  get [Symbol.toStringTag]() {\n    return 'Null';\n  }\n  toString() {\n    return 'Null';\n  }\n}\nexport class Bool extends DataType {\n  get typeId() {\n    return Type.Bool;\n  }\n  get [Symbol.toStringTag]() {\n    return 'Bool';\n  }\n  toString() {\n    return 'Bool';\n  }\n}\n_Symbol$toStringTag = Symbol.toStringTag;\nexport class Int extends DataType {\n  constructor(isSigned, bitWidth) {\n    super();\n    _defineProperty(this, \"isSigned\", void 0);\n    _defineProperty(this, \"bitWidth\", void 0);\n    this.isSigned = isSigned;\n    this.bitWidth = bitWidth;\n  }\n  get typeId() {\n    return Type.Int;\n  }\n  get [_Symbol$toStringTag]() {\n    return 'Int';\n  }\n  toString() {\n    return \"\".concat(this.isSigned ? 'I' : 'Ui', \"nt\").concat(this.bitWidth);\n  }\n}\nexport class Int8 extends Int {\n  constructor() {\n    super(true, 8);\n  }\n}\nexport class Int16 extends Int {\n  constructor() {\n    super(true, 16);\n  }\n}\nexport class Int32 extends Int {\n  constructor() {\n    super(true, 32);\n  }\n}\nexport class Int64 extends Int {\n  constructor() {\n    super(true, 64);\n  }\n}\nexport class Uint8 extends Int {\n  constructor() {\n    super(false, 8);\n  }\n}\nexport class Uint16 extends Int {\n  constructor() {\n    super(false, 16);\n  }\n}\nexport class Uint32 extends Int {\n  constructor() {\n    super(false, 32);\n  }\n}\nexport class Uint64 extends Int {\n  constructor() {\n    super(false, 64);\n  }\n}\nconst Precision = {\n  HALF: 16,\n  SINGLE: 32,\n  DOUBLE: 64\n};\n_Symbol$toStringTag2 = Symbol.toStringTag;\nexport class Float extends DataType {\n  constructor(precision) {\n    super();\n    _defineProperty(this, \"precision\", void 0);\n    this.precision = precision;\n  }\n  get typeId() {\n    return Type.Float;\n  }\n  get [_Symbol$toStringTag2]() {\n    return 'Float';\n  }\n  toString() {\n    return \"Float\".concat(this.precision);\n  }\n}\nexport class Float16 extends Float {\n  constructor() {\n    super(Precision.HALF);\n  }\n}\nexport class Float32 extends Float {\n  constructor() {\n    super(Precision.SINGLE);\n  }\n}\nexport class Float64 extends Float {\n  constructor() {\n    super(Precision.DOUBLE);\n  }\n}\nexport class Binary extends DataType {\n  constructor() {\n    super();\n  }\n  get typeId() {\n    return Type.Binary;\n  }\n  toString() {\n    return 'Binary';\n  }\n  get [Symbol.toStringTag]() {\n    return 'Binary';\n  }\n}\nexport class Utf8 extends DataType {\n  get typeId() {\n    return Type.Utf8;\n  }\n  get [Symbol.toStringTag]() {\n    return 'Utf8';\n  }\n  toString() {\n    return 'Utf8';\n  }\n}\nconst DateUnit = {\n  DAY: 0,\n  MILLISECOND: 1\n};\n_Symbol$toStringTag3 = Symbol.toStringTag;\nexport class Date extends DataType {\n  constructor(unit) {\n    super();\n    _defineProperty(this, \"unit\", void 0);\n    this.unit = unit;\n  }\n  get typeId() {\n    return Type.Date;\n  }\n  get [_Symbol$toStringTag3]() {\n    return 'Date';\n  }\n  toString() {\n    return \"Date\".concat((this.unit + 1) * 32, \"<\").concat(DateUnit[this.unit], \">\");\n  }\n}\nexport class DateDay extends Date {\n  constructor() {\n    super(DateUnit.DAY);\n  }\n}\nexport class DateMillisecond extends Date {\n  constructor() {\n    super(DateUnit.MILLISECOND);\n  }\n}\nconst TimeUnit = {\n  SECOND: 1,\n  MILLISECOND: 1e3,\n  MICROSECOND: 1e6,\n  NANOSECOND: 1e9\n};\n_Symbol$toStringTag4 = Symbol.toStringTag;\nexport class Time extends DataType {\n  constructor(unit, bitWidth) {\n    super();\n    _defineProperty(this, \"unit\", void 0);\n    _defineProperty(this, \"bitWidth\", void 0);\n    this.unit = unit;\n    this.bitWidth = bitWidth;\n  }\n  get typeId() {\n    return Type.Time;\n  }\n  toString() {\n    return \"Time\".concat(this.bitWidth, \"<\").concat(TimeUnit[this.unit], \">\");\n  }\n  get [_Symbol$toStringTag4]() {\n    return 'Time';\n  }\n}\nexport class TimeSecond extends Time {\n  constructor() {\n    super(TimeUnit.SECOND, 32);\n  }\n}\nexport class TimeMillisecond extends Time {\n  constructor() {\n    super(TimeUnit.MILLISECOND, 32);\n  }\n}\n_Symbol$toStringTag5 = Symbol.toStringTag;\nexport class Timestamp extends DataType {\n  constructor(unit) {\n    let timezone = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    super();\n    _defineProperty(this, \"unit\", void 0);\n    _defineProperty(this, \"timezone\", void 0);\n    this.unit = unit;\n    this.timezone = timezone;\n  }\n  get typeId() {\n    return Type.Timestamp;\n  }\n  get [_Symbol$toStringTag5]() {\n    return 'Timestamp';\n  }\n  toString() {\n    return \"Timestamp<\".concat(TimeUnit[this.unit]).concat(this.timezone ? \", \".concat(this.timezone) : '', \">\");\n  }\n}\nexport class TimestampSecond extends Timestamp {\n  constructor() {\n    let timezone = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    super(TimeUnit.SECOND, timezone);\n  }\n}\nexport class TimestampMillisecond extends Timestamp {\n  constructor() {\n    let timezone = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    super(TimeUnit.MILLISECOND, timezone);\n  }\n}\nexport class TimestampMicrosecond extends Timestamp {\n  constructor() {\n    let timezone = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    super(TimeUnit.MICROSECOND, timezone);\n  }\n}\nexport class TimestampNanosecond extends Timestamp {\n  constructor() {\n    let timezone = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    super(TimeUnit.NANOSECOND, timezone);\n  }\n}\nconst IntervalUnit = {\n  DAY_TIME: 0,\n  YEAR_MONTH: 1\n};\n_Symbol$toStringTag6 = Symbol.toStringTag;\nexport class Interval extends DataType {\n  constructor(unit) {\n    super();\n    _defineProperty(this, \"unit\", void 0);\n    this.unit = unit;\n  }\n  get typeId() {\n    return Type.Interval;\n  }\n  get [_Symbol$toStringTag6]() {\n    return 'Interval';\n  }\n  toString() {\n    return \"Interval<\".concat(IntervalUnit[this.unit], \">\");\n  }\n}\nexport class IntervalDayTime extends Interval {\n  constructor() {\n    super(IntervalUnit.DAY_TIME);\n  }\n}\nexport class IntervalYearMonth extends Interval {\n  constructor() {\n    super(IntervalUnit.YEAR_MONTH);\n  }\n}\n_Symbol$toStringTag7 = Symbol.toStringTag;\nexport class FixedSizeList extends DataType {\n  constructor(listSize, child) {\n    super();\n    _defineProperty(this, \"listSize\", void 0);\n    _defineProperty(this, \"children\", void 0);\n    this.listSize = listSize;\n    this.children = [child];\n  }\n  get typeId() {\n    return Type.FixedSizeList;\n  }\n  get valueType() {\n    return this.children[0].type;\n  }\n  get valueField() {\n    return this.children[0];\n  }\n  get [_Symbol$toStringTag7]() {\n    return 'FixedSizeList';\n  }\n  toString() {\n    return \"FixedSizeList[\".concat(this.listSize, \"]<\").concat(this.valueType, \">\");\n  }\n}\n_Symbol$toStringTag8 = Symbol.toStringTag;\nexport class Struct extends DataType {\n  constructor(children) {\n    super();\n    _defineProperty(this, \"children\", void 0);\n    this.children = children;\n  }\n  get typeId() {\n    return Type.Struct;\n  }\n  toString() {\n    return \"Struct<{\".concat(this.children.map(f => \"\".concat(f.name, \":\").concat(f.type)).join(', '), \"}>\");\n  }\n  get [_Symbol$toStringTag8]() {\n    return 'Struct';\n  }\n}\n//# sourceMappingURL=type.js.map",
      "start": 1693508127176,
      "end": 1693508127224,
      "sourcemaps": null
    }
  ]
}
