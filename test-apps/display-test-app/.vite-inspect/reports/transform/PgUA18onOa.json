{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/geometry3d/OrderedRotationAngles.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module CartesianGeometry\n */\nimport { AxisOrder, Geometry } from \"../Geometry\";\nimport { Angle } from \"./Angle\";\nimport { Matrix3d } from \"./Matrix3d\";\n/* cspell:word cxcz, cxsz, cxcy, cxsy, sxcz, sxsz, sxcy, sxsy, cycz, cysz, sycz, sysz */\n/**\n * Represents a non-trivial rotation using three simple axis rotation angles and an order in which to apply them.\n * * This class accommodates application-specific interpretation of \"multiplying 3 rotation matrices\" with regard to\n *   * Whether a \"vector\" is a \"row\" or a \"column\"\n *   * The order in which the X,Y,Z rotations are applied.\n * * This class bakes in angle rotation directions via create functions (i.e., createRadians, createDegrees, and\n * createAngles) so you can define each of the 3 rotations to be clockwise or counterclockwise. The default\n * rotation is counterclockwise.\n * * Within the imodel geometry library, the preferred rotation order is encapsulated in `YawPitchRollAngles`.\n * @alpha\n */\nclass OrderedRotationAngles {\n    /** constructor */\n    constructor(x, y, z, axisOrder) {\n        this._x = x;\n        this._y = y;\n        this._z = z;\n        this._order = axisOrder;\n    }\n    /** (Property accessor) Return the `AxisOrder` controlling matrix multiplication order. */\n    get order() {\n        return this._order;\n    }\n    /** (Property accessor) Return the strongly typed angle of rotation around x. */\n    get xAngle() {\n        return this._x.clone();\n    }\n    /** (Property accessor) Return the strongly typed angle of rotation around y. */\n    get yAngle() {\n        return this._y.clone();\n    }\n    /** (Property accessor) Return the strongly typed angle of rotation around z. */\n    get zAngle() {\n        return this._z.clone();\n    }\n    /** (Property accessor) Return the angle of rotation around x, in degrees */\n    get xDegrees() {\n        return this._x.degrees;\n    }\n    /** (Property accessor) Return the angle of rotation around y, in degrees */\n    get xRadians() {\n        return this._x.radians;\n    }\n    /** (Property accessor) Return the angle of rotation around z, in degrees */\n    get yDegrees() {\n        return this._y.degrees;\n    }\n    /** (Property accessor) Return the angle of rotation around x, in radians */\n    get yRadians() {\n        return this._y.radians;\n    }\n    /** (Property accessor) Return the angle of rotation around y, in radians */\n    get zDegrees() {\n        return this._z.degrees;\n    }\n    /** (Property accessor) Return the angle of rotation around z, in radians */\n    get zRadians() {\n        return this._z.radians;\n    }\n    /** The flag controlling whether vectors are treated as rows or as columns */\n    static get treatVectorsAsColumns() {\n        return OrderedRotationAngles._sTreatVectorsAsColumns;\n    }\n    static set treatVectorsAsColumns(value) {\n        OrderedRotationAngles._sTreatVectorsAsColumns = value;\n    }\n    /**\n     * Create an OrderedRotationAngles from three angles (in radians), an ordering in which to apply them when\n     * rotating, and a flag triple controlling whether direction of x,y,z is clockwise or counterclockwise.\n     * @param xRadians rotation around x\n     * @param yRadians rotation around y\n     * @param zRadians rotation around z\n     * @param order left to right order of axis names identifies the order that rotations are applied.\n     * For example XYZ means to rotate around x axis first, then y axis, and finally Z axis.\n     * * Note that rotation order is reverse of rotation matrix multiplication so for XYZ the rotation\n     * matrix multiplication would be zRot*yRot*xRot\n     * * Visualization can be found at https://www.itwinjs.org/sandbox/SaeedTorabi/CubeRotationAroundStandardAxes\n     * @param xyzRotationIsClockwise the flags controlling whether direction of x,y,z is clockwise or counterclockwise.\n     * rotation direction of x,y,z: true ---> clockwise - false ---> counterclockwise.\n     * * if xyzRotationIsClockwise is undefined it's set to [false, false, false].\n     * @param result caller-allocated OrderedRotationAngles\n     */\n    static createRadians(xRadians, yRadians, zRadians, order, xyzRotationIsClockwise, result) {\n        if (!xyzRotationIsClockwise) {\n            xyzRotationIsClockwise = [false, false, false];\n        }\n        const xRadian = xyzRotationIsClockwise[0] ? -xRadians : xRadians;\n        const yRadian = xyzRotationIsClockwise[1] ? -yRadians : yRadians;\n        const zRadian = xyzRotationIsClockwise[2] ? -zRadians : zRadians;\n        if (result) {\n            result._x.setRadians(xRadian);\n            result._y.setRadians(yRadian);\n            result._z.setRadians(zRadian);\n            result._order = order;\n            return result;\n        }\n        return new OrderedRotationAngles(Angle.createRadians(xRadian), Angle.createRadians(yRadian), Angle.createRadians(zRadian), order);\n    }\n    /**\n     * Create an OrderedRotationAngles from three angles (in degrees) and an ordering in which to apply\n     * them when rotating.\n     * @param xDegrees rotation around x\n     * @param yDegrees rotation around y\n     * @param zDegrees rotation around z\n     * @param order left to right order of axis names identifies the order that rotations are applied.\n     * For example XYZ means to rotate around x axis first, then y axis, and finally Z axis.\n     * * Note that rotation order is reverse of rotation matrix multiplication so for XYZ the rotation\n     * matrix multiplication would be zRot*yRot*xRot\n     * @param xyzRotationIsClockwise the flags controlling whether direction of x,y,z is clockwise or counterclockwise.\n     * rotation direction of x,y,z: true ---> clockwise - false ---> counterclockwise.\n     * * if xyzRotationIsClockwise is undefined it's set to [false, false, false].\n     * @param result caller-allocated OrderedRotationAngles\n     */\n    static createDegrees(xDegrees, yDegrees, zDegrees, order, xyzRotationIsClockwise, result) {\n        return OrderedRotationAngles.createRadians(Angle.degreesToRadians(xDegrees), Angle.degreesToRadians(yDegrees), Angle.degreesToRadians(zDegrees), order, xyzRotationIsClockwise, result);\n    }\n    /**\n     * Create an OrderedRotationAngles from three angles, an ordering in which to apply them when rotating,\n     * and a flag triple controlling whether direction of x,y,z is clockwise or counterclockwise.\n     * @param xRotation rotation around x\n     * @param yRotation rotation around y\n     * @param zRotation rotation around z\n     * @param order left to right order of axis names identifies the order that rotations are applied\n     * For example XYZ means to rotate around x axis first, then y axis, and finally Z axis.\n     * * Note that rotation order is reverse of rotation matrix multiplication so for XYZ the rotation\n     * matrix multiplication would be zRot*yRot*xRot\n     * @param xyzRotationIsClockwise the flags controlling whether direction of x,y,z is clockwise or counterclockwise.\n     * rotation direction of x,y,z: true ---> clockwise - false ---> counterclockwise.\n     * * if xyzRotationIsClockwise is undefined it's set to [false, false, false].\n     * @param result caller-allocated OrderedRotationAngles\n     */\n    static createAngles(xRotation, yRotation, zRotation, order, xyzRotationIsClockwise, result) {\n        return OrderedRotationAngles.createRadians(xRotation.radians, yRotation.radians, zRotation.radians, order, xyzRotationIsClockwise, result);\n    }\n    /**\n     * Create an OrderedRotationAngles from a 3x3 rotational matrix, given the ordering of axis rotations\n     * that the matrix derives from.\n     * * This function creates an OrderedRotationAngles with default angle rotation directions, i.e.,\n     * it assumes all x, y, and z rotations are counterclockwise.\n     * * In the failure case the method's return value is `undefined`.\n     * * In the failure case, if the optional result was supplied, that result will nonetheless be filled with\n     * a set of angles.\n     */\n    static createFromMatrix3d(matrix, order, result) {\n        // treat vector as columns\n        let m11 = matrix.coffs[0], m12 = matrix.coffs[1], m13 = matrix.coffs[2];\n        let m21 = matrix.coffs[3], m22 = matrix.coffs[4], m23 = matrix.coffs[5];\n        let m31 = matrix.coffs[6], m32 = matrix.coffs[7], m33 = matrix.coffs[8];\n        // treat vector as rows\n        if (!OrderedRotationAngles.treatVectorsAsColumns) {\n            m11 = matrix.coffs[0], m12 = matrix.coffs[3], m13 = matrix.coffs[6];\n            m21 = matrix.coffs[1], m22 = matrix.coffs[4], m23 = matrix.coffs[7];\n            m31 = matrix.coffs[2], m32 = matrix.coffs[5], m33 = matrix.coffs[8];\n        }\n        let xRad;\n        let yRad;\n        let zRad;\n        switch (order) {\n            case AxisOrder.XYZ: {\n                yRad = Math.asin(Math.max(-1, Math.min(1, -m31))); // limit asin domain to [-1,1]\n                if (Math.abs(m31) < 0.99999) {\n                    xRad = Math.atan2(m32, m33);\n                    zRad = Math.atan2(m21, m11);\n                }\n                else {\n                    /**\n                     * If Math.abs(m31) = 1 then yRad = +-90 degrees and therefore, we have a gimbal lock.\n                     * This means xRad and zRad can be anything as long as their sum xRad + zRad is constant.\n                     * so we can pick zRad = 0 and calculate xRad (or pick xRad = 0 and calculate zRad).\n                     * Therefore, rotation matrix becomes\n                     *        Matrix3d.createRowValues(\n                     *             0, +-sx, +-cx,\n                     *             0, cx, -sx,\n                     *             -+1, 0, 0\n                     *        );\n                     * Math details can be found\n                     * https://en.wikipedia.org/wiki/Gimbal_lock#Loss_of_a_degree_of_freedom_with_Euler_angles\n                     */\n                    xRad = Math.atan2(-m23, m22);\n                    zRad = 0;\n                }\n                break;\n            }\n            case AxisOrder.YXZ: {\n                xRad = Math.asin(Math.max(-1, Math.min(1, m32))); // limit asin domain to [-1,1]\n                if (Math.abs(m32) < 0.99999) {\n                    yRad = Math.atan2(-m31, m33);\n                    zRad = Math.atan2(-m12, m22);\n                }\n                else {\n                    yRad = Math.atan2(m13, m11);\n                    zRad = 0;\n                }\n                break;\n            }\n            case AxisOrder.ZXY: {\n                xRad = Math.asin(Math.max(-1, Math.min(1, -m23))); // limit asin domain to [-1,1]\n                if (Math.abs(m23) < 0.99999) {\n                    yRad = Math.atan2(m13, m33);\n                    zRad = Math.atan2(m21, m22);\n                }\n                else {\n                    yRad = 0;\n                    zRad = Math.atan2(-m12, m11);\n                }\n                break;\n            }\n            case AxisOrder.ZYX: {\n                yRad = Math.asin(Math.max(-1, Math.min(1, m13))); // limit asin domain to [-1,1]\n                if (Math.abs(m13) < 0.99999) {\n                    xRad = Math.atan2(-m23, m33);\n                    zRad = Math.atan2(-m12, m11);\n                }\n                else {\n                    xRad = 0;\n                    zRad = Math.atan2(m21, m22);\n                }\n                break;\n            }\n            case AxisOrder.YZX: {\n                zRad = Math.asin(Math.max(-1, Math.min(1, -m12))); // limit asin domain to [-1,1]\n                if (Math.abs(m12) < 0.99999) {\n                    xRad = Math.atan2(m32, m22);\n                    yRad = Math.atan2(m13, m11);\n                }\n                else {\n                    xRad = 0;\n                    yRad = Math.atan2(-m31, m33);\n                }\n                break;\n            }\n            case AxisOrder.XZY: {\n                zRad = Math.asin(Math.max(-1, Math.min(1, m21))); // limit asin domain to [-1,1]\n                if (Math.abs(m21) < 0.99999) {\n                    xRad = Math.atan2(-m23, m22);\n                    yRad = Math.atan2(-m31, m11);\n                }\n                else {\n                    xRad = Math.atan2(m32, m33);\n                    yRad = 0;\n                }\n                break;\n            }\n            default: {\n                xRad = yRad = zRad = 0;\n            }\n        }\n        const xyzRotationIsClockwise = [false, false, false];\n        const angles = OrderedRotationAngles.createRadians(xRad, yRad, zRad, order, xyzRotationIsClockwise, result);\n        // sanity check\n        const matrix1 = angles.toMatrix3d();\n        /**\n         * Below tolerance loosened to allow sanity check to pass for\n         *\n         * OrderedRotationAngles.createFromMatrix3d(\n         *       OrderedRotationAngles.createDegrees(0, 89.999, 0.001, AxisOrder.XYZ).toMatrix3d(),\n         *       AxisOrder.XYZ\n         * );\n         *\n         * with treatVectorsAsColumns = true.\n         */\n        return (matrix.maxDiff(matrix1) < 10 * Geometry.smallFraction) ? angles : undefined;\n    }\n    /**\n     * Create a 3x3 rotational matrix from this OrderedRotationAngles.\n     ** math details can be found at docs/learning/geometry/Angle.md\n     **/\n    toMatrix3d(result) {\n        const rot = (result !== undefined) ? result : new Matrix3d();\n        const axisOrder = this.order;\n        const x = this.xAngle, y = this.yAngle, z = this.zAngle;\n        const cx = x.cos(), sx = x.sin();\n        const cy = y.cos(), sy = y.sin();\n        const cz = z.cos(), sz = z.sin();\n        const cxcz = cx * cz, cxsz = cx * sz, cxcy = cx * cy, cxsy = cx * sy;\n        const sxcz = sx * cz, sxsz = sx * sz, sxcy = sx * cy, sxsy = sx * sy;\n        const cycz = cy * cz, cysz = cy * sz, sycz = sy * cz, sysz = sy * sz;\n        // the rotation matrix we build below is created using column-based base rotation matrixes\n        if (axisOrder === AxisOrder.XYZ) {\n            rot.setRowValues(cy * cz, sxcz * sy - cxsz, cxcz * sy + sxsz, cy * sz, cxcz + sxsz * sy, cxsz * sy - sxcz, -sy, sx * cy, cx * cy);\n        }\n        else if (axisOrder === AxisOrder.YXZ) {\n            rot.setRowValues(cycz - sysz * sx, -cx * sz, cysz * sx + sycz, sycz * sx + cysz, cx * cz, sysz - cycz * sx, -cx * sy, sx, cx * cy);\n        }\n        else if (axisOrder === AxisOrder.ZXY) {\n            rot.setRowValues(cycz + sysz * sx, sycz * sx - cysz, cx * sy, cx * sz, cx * cz, -sx, cysz * sx - sycz, cycz * sx + sysz, cx * cy);\n        }\n        else if (axisOrder === AxisOrder.ZYX) {\n            rot.setRowValues(cy * cz, -cy * sz, sy, sxcz * sy + cxsz, cxcz - sxsz * sy, -sx * cy, sxsz - cxcz * sy, sxcz + cxsz * sy, cx * cy);\n        }\n        else if (axisOrder === AxisOrder.YZX) {\n            rot.setRowValues(cy * cz, -sz, sy * cz, sxsy + cxcy * sz, cx * cz, cxsy * sz - sxcy, sxcy * sz - cxsy, sx * cz, cxcy + sxsy * sz);\n        }\n        else if (axisOrder === AxisOrder.XZY) {\n            rot.setRowValues(cy * cz, sxsy - cxcy * sz, cxsy + sxcy * sz, sz, cx * cz, -sx * cz, -sy * cz, sxcy + cxsy * sz, cxcy - sxsy * sz);\n        }\n        else {\n            rot.setIdentity();\n        }\n        // if we need row-based rotation matrix, we transpose the rotation matrix\n        if (!OrderedRotationAngles.treatVectorsAsColumns)\n            rot.transposeInPlace();\n        return rot;\n    }\n}\n/** treat vectors as matrix columns */\nOrderedRotationAngles._sTreatVectorsAsColumns = false;\nexport { OrderedRotationAngles };\n//# sourceMappingURL=OrderedRotationAngles.js.map",
      "start": 1693508123161,
      "end": 1693508123291,
      "sourcemaps": null
    }
  ]
}
