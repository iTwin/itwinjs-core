{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/common/lib/esm/AnalysisStyle.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module DisplayStyles\n */\nimport { Range1d } from \"@itwin/core-geometry\";\nimport { ThematicGradientSettings } from \"./ThematicDisplay\";\nimport { Gradient } from \"./Gradient\";\n/** Describes how an [[AnalysisStyle]] deforms a [Polyface]($core-geometry) by applying translation to its vertices.\n * @see [[AnalysisStyle.displacement]].\n * @public\n */\nexport class AnalysisStyleDisplacement {\n    /** @internal */\n    constructor(channelName, scale = 1) {\n        this.channelName = channelName;\n        this.scale = scale;\n    }\n    /** Create from JSON representation. */\n    static fromJSON(props) {\n        return new this(props.channelName, props.scale);\n    }\n    /** Convert to JSON representation. */\n    toJSON() {\n        const props = { channelName: this.channelName };\n        if (this.scale !== 1)\n            props.scale = this.scale;\n        return props;\n    }\n    /** Return true if `this` is equivalent to `other`. */\n    equals(other) {\n        return this.channelName === other.channelName && this.scale === other.scale;\n    }\n}\n/** Describes how an [[AnalysisStyle]] recolors [Polyface]($core-geometry) vertices by mapping values of type\n * [AuxChannelDataType.Scalar]($core-geometry) or [AuxChannelDataType.Distance]($core-geometry) supplied\n * by an [AuxChannel]($core-geometry) to colors supplied by a [[Gradient]] image.\n * @see [[AnalysisStyle.thematic]].\n * @public\n */\nexport class AnalysisStyleThematic {\n    /** @internal */\n    constructor(props) {\n        this.channelName = props.channelName;\n        this.range = Range1d.fromJSON(props.range);\n        this.thematicSettings = ThematicGradientSettings.fromJSON(props.thematicSettings);\n    }\n    /** Create from JSON representation. */\n    static fromJSON(props) {\n        return new this(props);\n    }\n    /** Convert to JSON representation. */\n    toJSON() {\n        const props = {\n            channelName: this.channelName,\n            range: this.range.toJSON(),\n        };\n        if (!this.thematicSettings.equals(ThematicGradientSettings.defaults))\n            props.thematicSettings = this.thematicSettings.toJSON();\n        return props;\n    }\n    /** The gradient computed from [[thematicSettings]]. */\n    get gradient() {\n        if (!this._gradient)\n            this._gradient = Gradient.Symb.createThematic(this.thematicSettings);\n        return this._gradient;\n    }\n    /** Return true if `this` is equivalent to `other`. */\n    equals(other) {\n        return this.channelName === other.channelName && this.range.isAlmostEqual(other.range) && this.thematicSettings.equals(other.thematicSettings);\n    }\n}\nfunction tryConvertLegacyProps(input) {\n    if (input.displacement || input.scalar)\n        return input;\n    const legacy = input;\n    if (undefined === legacy.displacementChannelName && undefined === legacy.scalarChannelName)\n        return input;\n    const output = {\n        normalChannelName: input.normalChannelName,\n    };\n    if (undefined !== legacy.displacementChannelName) {\n        output.displacement = {\n            channelName: legacy.displacementChannelName,\n            scale: legacy.displacementScale,\n        };\n    }\n    if (undefined !== legacy.scalarChannelName && undefined !== legacy.scalarRange) {\n        output.scalar = {\n            channelName: legacy.scalarChannelName,\n            range: legacy.scalarRange,\n            thematicSettings: legacy.scalarThematicSettings,\n        };\n    }\n    return output;\n}\n/** As part of a [[DisplayStyleSettings]], describes how to animate meshes in the view that have been augmented with\n * [PolyfaceAuxData]($core-geometry). The style specifies which channels to use, and can deform the meshes by\n * translating vertices and/or recolor vertices using [[ThematicDisplay]].\n * @see [[DisplayStyleSettings.analysisStyle]] to define the analysis style for a [DisplayStyle]($backend).\n * @see [[DisplayStyleSettings.analysisFraction]] to control playback of the animation.\n * @public\n */\nclass AnalysisStyle {\n    /** Create an analysis style from its JSON representation.\n     * @note AnalysisStyle is an immutable type - use [[clone]] to produce a modified copy.\n     */\n    static fromJSON(props) {\n        if (!props)\n            return this.defaults;\n        props = tryConvertLegacyProps(props);\n        if (!props.displacement && !props.scalar && undefined === props.normalChannelName)\n            return this.defaults;\n        return new AnalysisStyle(props);\n    }\n    /** @internal */\n    constructor(props) {\n        this.normalChannelName = props.normalChannelName;\n        if (props.displacement)\n            this.displacement = AnalysisStyleDisplacement.fromJSON(props.displacement);\n        if (props.scalar)\n            this.thematic = AnalysisStyleThematic.fromJSON(props.scalar);\n    }\n    /** Convert this style to its JSON representation. */\n    toJSON() {\n        const props = {};\n        if (this === AnalysisStyle.defaults)\n            return props;\n        if (this.displacement)\n            props.displacement = this.displacement.toJSON();\n        if (this.thematic)\n            props.scalar = this.thematic.toJSON();\n        if (undefined !== this.normalChannelName)\n            props.normalChannelName = this.normalChannelName;\n        return props;\n    }\n    /** Produce a copy of this style identical except for properties explicitly specified by `changedProps`. */\n    clone(changedProps) {\n        return AnalysisStyle.fromJSON({\n            ...this.toJSON(),\n            ...changedProps,\n        });\n    }\n    /** Return true if this style is equivalent to `other`. */\n    equals(other) {\n        if (this.normalChannelName !== other.normalChannelName)\n            return false;\n        if ((undefined === this.displacement) !== (undefined === other.displacement))\n            return false;\n        else if (this.displacement && !this.displacement.equals(other.displacement))\n            return false;\n        if ((undefined === this.thematic) !== (undefined === other.thematic))\n            return false;\n        return undefined === this.thematic || this.thematic.equals(other.thematic);\n    }\n}\nAnalysisStyle.defaults = new AnalysisStyle({});\nexport { AnalysisStyle };\n//# sourceMappingURL=AnalysisStyle.js.map",
      "start": 1693508120651,
      "end": 1693508120708,
      "sourcemaps": null
    }
  ]
}
