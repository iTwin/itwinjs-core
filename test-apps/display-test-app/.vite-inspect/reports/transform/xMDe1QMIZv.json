{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/common/lib/esm/tile/TileMetadata.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tile\n */\nimport { assert, compareBooleans, compareBooleansOrUndefined, compareNumbers, compareStrings, compareStringsOrUndefined, Id64, } from \"@itwin/core-bentley\";\nimport { Range3d, Vector3d } from \"@itwin/core-geometry\";\nimport { BatchType } from \"../FeatureTable\";\nimport { CurrentImdlVersion, FeatureTableHeader, ImdlFlags, ImdlHeader } from \"./IModelTileIO\";\nimport { TileReadError, TileReadStatus } from \"./TileIO\";\n// cspell:ignore imdl mult bitfield\n// NB: These constants correspond to those defined in Tile.cpp.\nvar Constants;\n(function (Constants) {\n    Constants.minToleranceRatioMultiplier = 2;\n})(Constants || (Constants = {}));\nfunction compareEdgeOptions(a, b) {\n    if (typeof a !== typeof b)\n        return a ? 1 : -1;\n    if (typeof a === \"boolean\") {\n        assert(typeof b === \"boolean\");\n        return compareBooleans(a, b);\n    }\n    assert(typeof b === \"object\");\n    let cmp = compareStrings(a.type, b.type);\n    if (0 === cmp)\n        cmp = compareBooleans(a.smooth, b.smooth);\n    return cmp;\n}\n/** @internal */\nexport var TileOptions;\n(function (TileOptions) {\n    /** Given the string representation of an [[IModelTileTreeId]] and the contentId of a [Tile]($frontend) belonging to that [TileTree]($frontend),\n     * compute the [[TileOptions]] that were used to generate the Ids.\n     * @throws Error if `treeId` or `contentId` are not valid Ids.\n     * @note `treeId` and `contentId` are assumed to be valid Ids. They are not fully parsed and validated - only the information required by this function is extracted.\n     * @note `treeId` and `contentId` are assumed to have been produced for version 4 or later of the iMdl tile format.\n     */\n    function fromTreeIdAndContentId(treeId, contentId) {\n        const tree = treeFlagsAndFormatVersionFromId(treeId);\n        const contentFlags = contentFlagsFromId(contentId);\n        const edgeOptions = edgeOptionsFromTreeId(treeId);\n        return {\n            maximumMajorTileFormatVersion: tree.version,\n            enableInstancing: 0 !== (contentFlags & ContentFlags.AllowInstancing),\n            enableImprovedElision: 0 !== (contentFlags & ContentFlags.ImprovedElision),\n            ignoreAreaPatterns: 0 !== (contentFlags & ContentFlags.IgnoreAreaPatterns),\n            enableExternalTextures: 0 !== (contentFlags & ContentFlags.ExternalTextures),\n            useProjectExtents: 0 !== (tree.flags & TreeFlags.UseProjectExtents),\n            optimizeBRepProcessing: 0 !== (tree.flags & TreeFlags.OptimizeBRepProcessing),\n            useLargerTiles: 0 !== (tree.flags & TreeFlags.UseLargerTiles),\n            disableMagnification: false,\n            alwaysSubdivideIncompleteTiles: false,\n            edgeOptions,\n        };\n    }\n    TileOptions.fromTreeIdAndContentId = fromTreeIdAndContentId;\n})(TileOptions || (TileOptions = {}));\nclass Parser {\n    constructor(input) {\n        this.curPos = 0;\n        this.input = input;\n    }\n    parse(contentId) {\n        this.require(this.input.length > 0);\n        // Skip version and flags, they're handled by TileOptions.fromTreeIdAndContentId\n        while (this.curPos < this.input.length && this.cur() !== \"-\")\n            this.advance();\n        this.eat(\"-\");\n        this.require(this.curPos < this.input.length);\n        const classifier = this.cur() === \"C\" ? this.parseClassifier() : undefined;\n        const animationId = this.parseAnimation();\n        const primary = classifier ? undefined : this.parsePrimary();\n        this.require((undefined === classifier) !== (undefined === primary));\n        const modelId = this.input.substring(this.curPos);\n        this.require(Id64.isId64(modelId));\n        const { flags: treeFlags } = treeFlagsAndFormatVersionFromId(this.input);\n        const options = TileOptions.fromTreeIdAndContentId(this.input, contentId);\n        let parsedContentId;\n        try {\n            parsedContentId = ContentIdProvider.create(true, options).specFromId(contentId);\n        }\n        catch (e) {\n            this.reject(\"Invalid content Id\");\n        }\n        if (Object.keys(parsedContentId).some((key) => parsedContentId.hasOwnProperty(key) && typeof parsedContentId[key] === \"number\" && !Number.isFinite(parsedContentId[key])))\n            throw new Error(\"Invalid content Id\");\n        let treeId;\n        if (classifier) {\n            treeId = { ...classifier, animationId };\n        }\n        else {\n            assert(undefined !== primary);\n            const enforceDisplayPriority = (treeFlags & TreeFlags.EnforceDisplayPriority) !== 0 ? true : undefined;\n            treeId = { ...primary, animationId, type: BatchType.Primary, enforceDisplayPriority };\n        }\n        return {\n            contentId: parsedContentId,\n            modelId,\n            options,\n            treeId,\n        };\n    }\n    cur() {\n        this.require(this.curPos < this.input.length);\n        return this.input[this.curPos];\n    }\n    advance() {\n        this.require(this.curPos < this.input.length);\n        ++this.curPos;\n    }\n    eat(expectedChar) {\n        this.require(this.cur() === expectedChar);\n        this.advance();\n    }\n    reject(message = \"Invalid tree Id\") {\n        throw new Error(message);\n    }\n    require(condition, message = \"Invalid tree Id\") {\n        if (!condition)\n            this.reject(message);\n    }\n    parseClassifier() {\n        this.eat(\"C\");\n        let type = BatchType.VolumeClassifier;\n        if (this.cur() === \"P\") {\n            type = BatchType.PlanarClassifier;\n            this.advance();\n        }\n        this.eat(\":\");\n        // C: or CP: is always folowed by expansion then an underscore.\n        let expansionStr = \"\";\n        while (this.curPos < this.input.length && (this.cur() >= \"0\" && this.cur() <= \"9\" || this.cur() === \".\")) {\n            expansionStr += this.cur();\n            this.advance();\n        }\n        this.eat(\"_\");\n        const expansion = Number.parseFloat(expansionStr);\n        this.require(!Number.isNaN(expansion));\n        return { type, expansion };\n    }\n    parseAnimation() {\n        if (this.cur() !== \"A\")\n            return undefined;\n        this.eat(\"A\");\n        this.eat(\":\");\n        const termPos = this.input.indexOf(\"_\", this.curPos);\n        this.require(termPos > this.curPos);\n        const animationId = this.input.substring(this.curPos, termPos);\n        this.require(Id64.isId64(animationId));\n        this.curPos = termPos + 1; // Skip \"_\"\n        return animationId;\n    }\n    parsePrimary() {\n        const edges = this.parseEdges();\n        const sectionCut = this.parseSectionCut();\n        return { edges, sectionCut };\n    }\n    parseEdges() {\n        if (\"E\" !== this.cur())\n            return { type: \"non-indexed\", smooth: false };\n        this.eat(\"E\");\n        this.eat(\":\");\n        const flag = this.cur();\n        this.eat(flag);\n        this.eat(\"_\");\n        return \"0\" === flag ? false : edgeOptionsFromFlag(flag);\n    }\n    parseSectionCut() {\n        if (\"S\" !== this.cur())\n            return undefined;\n        this.eat(\"S\");\n        const termPos = this.input.indexOf(\"s\", this.curPos);\n        this.require(termPos > this.curPos);\n        const sectionCut = this.input.substring(this.curPos, termPos);\n        this.curPos = termPos + 1; // Skip \"_\";\n        return sectionCut;\n    }\n}\n/** @internal */\nexport function parseTileTreeIdAndContentId(treeId, contentId) {\n    const parser = new Parser(treeId);\n    return parser.parse(contentId);\n}\n/** @internal */\nexport const defaultTileOptions = Object.freeze({\n    maximumMajorTileFormatVersion: CurrentImdlVersion.Major,\n    enableInstancing: true,\n    enableImprovedElision: true,\n    ignoreAreaPatterns: false,\n    enableExternalTextures: true,\n    useProjectExtents: true,\n    optimizeBRepProcessing: true,\n    useLargerTiles: true,\n    disableMagnification: false,\n    alwaysSubdivideIncompleteTiles: false,\n    edgeOptions: {\n        type: \"compact\",\n        smooth: true,\n    },\n});\nfunction contentFlagsFromId(id) {\n    if (0 === id.length || \"-\" !== id[0])\n        throw new Error(\"Invalid content Id\");\n    // V4: -flags-d-i-j-k-m - version in tree Id\n    const end = id.indexOf(\"-\", 1);\n    if (-1 !== end) {\n        const flags = Number.parseInt(id.substring(1, end), 16);\n        if (!Number.isNaN(flags))\n            return flags;\n    }\n    throw new Error(\"Invalid content Id\");\n}\nfunction treeFlagsAndFormatVersionFromId(id) {\n    if (0 === id.length)\n        throw new Error(\"Invalid tree Id\");\n    let parts = id.split(\"-\");\n    if (parts.length > 0) {\n        parts = parts[0].split(\"_\");\n        if (parts.length === 2) {\n            const version = Number.parseInt(parts[0], 16);\n            const flags = Number.parseInt(parts[1], 16);\n            if (!Number.isNaN(version) || !Number.isNaN(flags))\n                return { version, flags };\n        }\n    }\n    throw new Error(\"Invalid tree Id\");\n}\nfunction edgeOptionsFromTreeId(id) {\n    const pos = id.indexOf(\"E:\");\n    if (pos <= 0)\n        return { type: \"non-indexed\", smooth: false };\n    return edgeOptionsFromFlag(id[pos + 2]);\n}\nfunction edgeOptionsFromFlag(flag) {\n    if (\"0\" === flag)\n        return defaultTileOptions.edgeOptions;\n    const smooth = flag !== \"2\" && flag !== \"5\";\n    let type;\n    switch (flag) {\n        case \"2\":\n        case \"4\":\n            type = \"indexed\";\n            break;\n        case \"3\":\n            type = \"non-indexed\";\n            break;\n        case \"5\":\n        case \"6\":\n            type = \"compact\";\n            break;\n        default:\n            throw new Error(\"Invalid tree Id\");\n    }\n    return { type, smooth };\n}\nfunction edgeOptionsToString(options) {\n    if (!options)\n        return \"E:0_\";\n    switch (options.type) {\n        case \"non-indexed\": return options.smooth ? \"E:3_\" : \"\";\n        case \"indexed\": return options.smooth ? \"E:4_\" : \"E:2_\";\n        case \"compact\": return options.smooth ? \"E:6_\" : \"E:5_\";\n        default: throw new Error(\"Invalid tree Id\");\n    }\n}\n/** @internal */\nexport function getMaximumMajorTileFormatVersion(maxMajorVersion, formatVersion) {\n    // The `formatVersion` input is from the backend, telling us precisely the maximum major+minor version it can produce.\n    // Ensure we do not request tiles of a newer major version than backend can supply or it can read; and also limit major version\n    // to that optionally configured by the app.\n    let majorVersion = maxMajorVersion;\n    if (undefined !== formatVersion)\n        majorVersion = Math.min((formatVersion >>> 0x10), majorVersion);\n    // Version number less than 1 is invalid - ignore\n    majorVersion = Math.max(majorVersion, 1);\n    // Version number greater than current known version ignored\n    majorVersion = Math.min(majorVersion, CurrentImdlVersion.Major);\n    // Version numbers are integers - round down\n    return Math.max(Math.floor(majorVersion), 1);\n}\n/** Flags controlling the structure of a tile tree. The flags are part of the tile tree's Id.\n * @alpha\n */\nexport var TreeFlags;\n(function (TreeFlags) {\n    TreeFlags[TreeFlags[\"None\"] = 0] = \"None\";\n    TreeFlags[TreeFlags[\"UseProjectExtents\"] = 1] = \"UseProjectExtents\";\n    TreeFlags[TreeFlags[\"EnforceDisplayPriority\"] = 2] = \"EnforceDisplayPriority\";\n    TreeFlags[TreeFlags[\"OptimizeBRepProcessing\"] = 4] = \"OptimizeBRepProcessing\";\n    TreeFlags[TreeFlags[\"UseLargerTiles\"] = 8] = \"UseLargerTiles\";\n})(TreeFlags || (TreeFlags = {}));\nfunction animationIdToString(animationId) {\n    return `A:${animationId}_`;\n}\n/** Convert a tile tree Id to its string representation.\n * @internal\n */\nexport function iModelTileTreeIdToString(modelId, treeId, options) {\n    let idStr = \"\";\n    let flags = options.useProjectExtents ? TreeFlags.UseProjectExtents : TreeFlags.None;\n    if (options.optimizeBRepProcessing)\n        flags |= TreeFlags.OptimizeBRepProcessing;\n    if (options.useLargerTiles)\n        flags |= TreeFlags.UseLargerTiles;\n    if (BatchType.Primary === treeId.type) {\n        if (undefined !== treeId.animationId)\n            idStr = `${idStr}${animationIdToString(treeId.animationId)}`;\n        else if (treeId.enforceDisplayPriority) // animation and priority are currently mutually exclusive\n            flags |= TreeFlags.EnforceDisplayPriority;\n        const edges = edgeOptionsToString(treeId.edges);\n        const sectionCut = treeId.sectionCut ? `S${treeId.sectionCut}s` : \"\";\n        idStr = `${idStr}${edges}${sectionCut}`;\n    }\n    else {\n        const typeStr = BatchType.PlanarClassifier === treeId.type ? \"CP\" : \"C\";\n        idStr = `${idStr + typeStr}:${treeId.expansion.toFixed(6)}_`;\n        if (BatchType.VolumeClassifier === treeId.type)\n            flags |= TreeFlags.UseProjectExtents;\n        if (undefined !== treeId.animationId)\n            idStr = `${idStr}${animationIdToString(treeId.animationId)}`;\n    }\n    const version = getMaximumMajorTileFormatVersion(options.maximumMajorTileFormatVersion);\n    if (version >= 4) {\n        const prefix = `${version.toString(16)}_${flags.toString(16)}-`;\n        idStr = prefix + idStr;\n    }\n    return idStr + modelId;\n}\n/** Ordinal comparison of two tile tree Ids, e.g., for use in sorted containers.\n * @internal\n */\nexport function compareIModelTileTreeIds(lhs, rhs) {\n    let cmp = compareNumbers(lhs.type, rhs.type);\n    if (0 === cmp)\n        cmp = compareStringsOrUndefined(lhs.animationId, rhs.animationId);\n    if (0 !== cmp)\n        return cmp;\n    // NB: The redundant checks on BatchType below are to satisfy compiler.\n    assert(lhs.type === rhs.type);\n    if (BatchType.Primary === lhs.type && BatchType.Primary === rhs.type) {\n        cmp = compareEdgeOptions(lhs.edges, rhs.edges);\n        if (0 === cmp) {\n            cmp = compareBooleansOrUndefined(lhs.enforceDisplayPriority, rhs.enforceDisplayPriority);\n            if (0 === cmp)\n                cmp = compareStringsOrUndefined(lhs.sectionCut, rhs.sectionCut);\n        }\n    }\n    else if (BatchType.Primary !== lhs.type && BatchType.Primary !== rhs.type) {\n        cmp = compareNumbers(lhs.expansion, rhs.expansion);\n    }\n    return cmp;\n}\n/** Flags controlling how tile content is produced. The flags are part of the ContentId.\n * @alpha\n */\nexport var ContentFlags;\n(function (ContentFlags) {\n    ContentFlags[ContentFlags[\"None\"] = 0] = \"None\";\n    ContentFlags[ContentFlags[\"AllowInstancing\"] = 1] = \"AllowInstancing\";\n    ContentFlags[ContentFlags[\"ImprovedElision\"] = 2] = \"ImprovedElision\";\n    ContentFlags[ContentFlags[\"IgnoreAreaPatterns\"] = 4] = \"IgnoreAreaPatterns\";\n    ContentFlags[ContentFlags[\"ExternalTextures\"] = 8] = \"ExternalTextures\";\n})(ContentFlags || (ContentFlags = {}));\n/** Contains logic for working with tile content Ids according to a specific content Id scheme. Which scheme is used depends on\n * the major version of the tile format.\n * @internal\n */\nexport class ContentIdProvider {\n    constructor(formatVersion, contentFlags) {\n        this.majorFormatVersion = formatVersion;\n        this.contentFlags = contentFlags;\n    }\n    get rootContentId() {\n        return this.computeId(0, 0, 0, 0, 1);\n    }\n    idFromParentAndMultiplier(parentId, multiplier) {\n        const lastSepPos = parentId.lastIndexOf(this._separator);\n        assert(-1 !== lastSepPos);\n        return parentId.substring(0, lastSepPos + 1) + multiplier.toString(16);\n    }\n    specFromId(id) {\n        const parts = id.split(this._separator);\n        const len = parts.length;\n        assert(len >= 5);\n        return {\n            depth: parseInt(parts[len - 5], 16),\n            i: parseInt(parts[len - 4], 16),\n            j: parseInt(parts[len - 3], 16),\n            k: parseInt(parts[len - 2], 16),\n            multiplier: parseInt(parts[len - 1], 16),\n        };\n    }\n    idFromSpec(spec) {\n        return this.computeId(spec.depth, spec.i, spec.j, spec.k, spec.multiplier);\n    }\n    join(depth, i, j, k, mult) {\n        const sep = this._separator;\n        return depth.toString(16) + sep + i.toString(16) + sep + j.toString(16) + sep + k.toString(16) + sep + mult.toString(16);\n    }\n    /** formatVersion is the maximum major version supported by the back-end supplying the tile tree.\n     * Must ensure front-end does not request tiles of a format the back-end cannot supply, and back-end does\n     * not supply tiles of a format the front-end doesn't recognize.\n     */\n    static create(allowInstancing, options, formatVersion) {\n        const majorVersion = getMaximumMajorTileFormatVersion(options.maximumMajorTileFormatVersion, formatVersion);\n        assert(majorVersion > 0);\n        assert(Math.floor(majorVersion) === majorVersion);\n        switch (majorVersion) {\n            case 0:\n            case 1:\n                return new ContentIdV1Provider(majorVersion);\n            case 2:\n            case 3:\n                return new ContentIdV2Provider(majorVersion, allowInstancing, options);\n            default:\n                return new ContentIdV4Provider(allowInstancing, options, majorVersion);\n        }\n    }\n}\n/** The original (major version 1) tile format used a content Id scheme of the format\n * `depth/i/j/k/multiplier`.\n * @internal\n */\nclass ContentIdV1Provider extends ContentIdProvider {\n    constructor(majorVersion) {\n        super(majorVersion, ContentFlags.None);\n    }\n    get _separator() { return \"/\"; }\n    computeId(depth, i, j, k, mult) {\n        return this.join(depth, i, j, k, mult);\n    }\n}\n/** Tile formats 2 and 3 use a content Id scheme encoding styling flags and the major format version\n * into the content Id, of the format `_majorVersion_flags_depth_i_j_k_multiplier`.\n * @internal\n */\nclass ContentIdV2Provider extends ContentIdProvider {\n    constructor(majorVersion, allowInstancing, options) {\n        const flags = (allowInstancing && options.enableInstancing) ? ContentFlags.AllowInstancing : ContentFlags.None;\n        super(majorVersion, flags);\n        this._prefix = this._separator + majorVersion.toString(16) + this._separator + flags.toString(16) + this._separator;\n    }\n    get _separator() { return \"_\"; }\n    computeId(depth, i, j, k, mult) {\n        return this._prefix + this.join(depth, i, j, k, mult);\n    }\n}\n/** Tile formats 4+ encode styling flags but not major format version. (The version is specified by the tile tree's Id).\n * Format: `-flags-depth-i-j-k-multiplier`.\n * @internal\n */\nclass ContentIdV4Provider extends ContentIdProvider {\n    constructor(allowInstancing, options, majorVersion) {\n        let flags = (allowInstancing && options.enableInstancing) ? ContentFlags.AllowInstancing : ContentFlags.None;\n        if (options.enableImprovedElision)\n            flags = flags | ContentFlags.ImprovedElision;\n        if (options.ignoreAreaPatterns)\n            flags = flags | ContentFlags.IgnoreAreaPatterns;\n        if (options.enableExternalTextures)\n            flags = flags | ContentFlags.ExternalTextures;\n        super(majorVersion, flags);\n        this._prefix = this._separator + flags.toString(16) + this._separator;\n    }\n    get _separator() { return \"-\"; }\n    computeId(depth, i, j, k, mult) {\n        return this._prefix + this.join(depth, i, j, k, mult);\n    }\n}\n/** @internal */\nexport function bisectTileRange3d(range, takeUpper) {\n    const diag = range.diagonal();\n    const pt = takeUpper ? range.high : range.low;\n    if (diag.x > diag.y && diag.x > diag.z)\n        pt.x = (range.low.x + range.high.x) / 2.0;\n    else if (diag.y > diag.z)\n        pt.y = (range.low.y + range.high.y) / 2.0;\n    else\n        pt.z = (range.low.z + range.high.z) / 2.0;\n}\n/** @internal */\nexport function bisectTileRange2d(range, takeUpper) {\n    const diag = range.diagonal();\n    const pt = takeUpper ? range.high : range.low;\n    if (diag.x > diag.y)\n        pt.x = (range.low.x + range.high.x) / 2.0;\n    else\n        pt.y = (range.low.y + range.high.y) / 2.0;\n}\n/** Given a description of a tile, compute the ranges which would result from sub-dividing its range into 4 or 8 sub-volumes.\n * @internal\n */\nexport function computeChildTileRanges(tile, root) {\n    const emptyMask = tile.emptySubRangeMask;\n    const is2d = root.is2d;\n    const bisectRange = is2d ? bisectTileRange2d : bisectTileRange3d;\n    const ranges = [];\n    for (let i = 0; i < 2; i++) {\n        for (let j = 0; j < 2; j++) {\n            for (let k = 0; k < (is2d ? 1 : 2); k++) {\n                const emptyBit = 1 << (i + j * 2 + k * 4);\n                const isEmpty = 0 !== (emptyMask & emptyBit);\n                const range = tile.range.clone();\n                bisectRange(range, 0 === i);\n                bisectRange(range, 0 === j);\n                if (!is2d)\n                    bisectRange(range, 0 === k);\n                ranges.push({ range, isEmpty });\n            }\n        }\n    }\n    return ranges;\n}\n/** Given a description of the parent tile, obtain the properties of its child tiles, and the number of empty children.\n * @internal\n */\nexport function computeChildTileProps(parent, idProvider, root) {\n    let numEmpty = 0;\n    const children = [];\n    // Leaf nodes have no children\n    if (parent.isLeaf)\n        return { children, numEmpty };\n    // One child, same volume as parent, but higher-resolution.\n    if (undefined !== parent.sizeMultiplier) {\n        const sizeMultiplier = parent.sizeMultiplier * 2;\n        const contentId = idProvider.idFromParentAndMultiplier(parent.contentId, sizeMultiplier);\n        children.push({\n            contentId,\n            range: parent.range,\n            contentRange: parent.contentRange,\n            sizeMultiplier,\n            isLeaf: false,\n            maximumSize: root.tileScreenSize,\n        });\n        return { children, numEmpty };\n    }\n    // Sub-divide parent's range into 4 (for 2d trees) or 8 (for 3d trees) child tiles.\n    const parentSpec = idProvider.specFromId(parent.contentId);\n    const childSpec = { ...parentSpec };\n    childSpec.depth = parentSpec.depth + 1;\n    // This mask is a bitfield in which an 'on' bit indicates sub-volume containing no geometry.\n    // Don't bother creating children or requesting content for such empty volumes.\n    const emptyMask = parent.emptySubRangeMask;\n    // Spatial tree range == project extents; content range == model range.\n    // Trivially reject children whose ranges are entirely outside model range.\n    let treeContentRange = root.contentRange;\n    if (undefined !== treeContentRange && treeContentRange.containsRange(parent.range)) {\n        // Parent is wholly within model range - don't bother testing child ranges against it.\n        treeContentRange = undefined;\n    }\n    const is2d = root.is2d;\n    const bisectRange = is2d ? bisectTileRange2d : bisectTileRange3d;\n    for (let i = 0; i < 2; i++) {\n        for (let j = 0; j < 2; j++) {\n            for (let k = 0; k < (is2d ? 1 : 2); k++) {\n                const emptyBit = 1 << (i + j * 2 + k * 4);\n                if (0 !== (emptyMask & emptyBit)) {\n                    // volume is known to contain no geometry.\n                    ++numEmpty;\n                    continue;\n                }\n                const range = parent.range.clone();\n                bisectRange(range, 0 === i);\n                bisectRange(range, 0 === j);\n                if (!is2d)\n                    bisectRange(range, 0 === k);\n                if (undefined !== treeContentRange && !range.intersectsRange(treeContentRange)) {\n                    // volume is within project extents but entirely outside model range\n                    ++numEmpty;\n                    continue;\n                }\n                childSpec.i = parentSpec.i * 2 + i;\n                childSpec.j = parentSpec.j * 2 + j;\n                childSpec.k = parentSpec.k * 2 + k;\n                const childId = idProvider.idFromSpec(childSpec);\n                children.push({ contentId: childId, range, maximumSize: root.tileScreenSize });\n            }\n        }\n    }\n    return { children, numEmpty };\n}\n/** Deserializes tile content metadata.\n * @throws [[TileReadError]]\n * @internal\n * @deprecated in 4.0. Use decodeTileContentDescription. I think tile agents (or their tests) are using this function.\n */\nexport function readTileContentDescription(stream, sizeMultiplier, is2d, options, isVolumeClassifier) {\n    return decodeTileContentDescription({ stream, sizeMultiplier, is2d, options, isVolumeClassifier });\n}\n/** @internal */\nexport function decodeTileContentDescription(args) {\n    const { stream, options } = args;\n    const isVolumeClassifier = args.isVolumeClassifier ?? false;\n    stream.reset();\n    const header = new ImdlHeader(stream);\n    if (!header.isValid)\n        throw new TileReadError(TileReadStatus.InvalidHeader);\n    else if (!header.isReadableVersion)\n        throw new TileReadError(TileReadStatus.NewerMajorVersion);\n    // Skip the feature table.\n    const featureTableStartPos = stream.curPos;\n    const ftHeader = FeatureTableHeader.readFrom(stream);\n    if (undefined === ftHeader)\n        throw new TileReadError(TileReadStatus.InvalidFeatureTable);\n    stream.curPos = featureTableStartPos + ftHeader.length;\n    let sizeMultiplier = args.sizeMultiplier;\n    let isLeaf = args.isLeaf;\n    if (undefined === isLeaf) {\n        // Determine subdivision based on header data.\n        const completeTile = 0 === (header.flags & ImdlFlags.Incomplete);\n        const emptyTile = completeTile && 0 === header.numElementsIncluded && 0 === header.numElementsExcluded;\n        isLeaf = (emptyTile || isVolumeClassifier); // Current classifier algorithm supports only a single tile.\n        if (!isLeaf) {\n            // Non-spatial (2d) models are of arbitrary scale and contain geometry like line work and especially text which\n            // can be adversely affected by quantization issues when zooming in closely.\n            const maxLeafTolerance = 1.0;\n            // Must sub-divide if tile explicitly specifies...\n            let canSkipSubdivision = 0 === (header.flags & ImdlFlags.DisallowMagnification);\n            // ...or in 2d, or if app explicitly disabled magnification, or tolerance large enough to risk quantization error...\n            canSkipSubdivision = canSkipSubdivision && !args.is2d && !options.disableMagnification && header.tolerance <= maxLeafTolerance;\n            // ...or app specifies incomplete tiles must always be sub-divided.\n            canSkipSubdivision = canSkipSubdivision && (completeTile || !options.alwaysSubdivideIncompleteTiles);\n            if (canSkipSubdivision) {\n                const minElementsPerTile = 100;\n                if (completeTile && 0 === header.numElementsExcluded && header.numElementsIncluded <= minElementsPerTile) {\n                    const containsCurves = 0 !== (header.flags & ImdlFlags.ContainsCurves);\n                    if (!containsCurves)\n                        isLeaf = true;\n                    else if (undefined === sizeMultiplier)\n                        sizeMultiplier = 1.0;\n                }\n                else if (undefined === sizeMultiplier && header.numElementsIncluded + header.numElementsExcluded <= minElementsPerTile) {\n                    sizeMultiplier = 1.0;\n                }\n            }\n        }\n    }\n    return {\n        featureTableStartPos,\n        contentRange: header.contentRange,\n        isLeaf,\n        sizeMultiplier,\n        emptySubRangeMask: header.emptySubRanges,\n    };\n}\nconst scratchRangeDiagonal = new Vector3d();\n/** Compute the chord tolerance for the specified tile of the given range with the specified size multiplier.\n * @internal\n */\nexport function computeTileChordTolerance(tile, is3d, tileScreenSize) {\n    if (tile.range.isNull)\n        return 0;\n    const diagonal = tile.range.diagonal(scratchRangeDiagonal);\n    const diagDist = is3d ? diagonal.magnitude() : diagonal.magnitudeXY();\n    const mult = Math.max(tile.sizeMultiplier ?? 1, 1);\n    return diagDist / (tileScreenSize * Constants.minToleranceRatioMultiplier * Math.max(1, mult));\n}\n/** Deserializes tile metadata.\n * @internal\n */\nexport class TileMetadataReader {\n    constructor(type, is2d, options) {\n        this._is2d = is2d;\n        this._isVolumeClassifier = BatchType.VolumeClassifier === type;\n        this._options = options;\n    }\n    /** Produce metadata from the specified tile content.\n     * @throws [[TileReadError]]\n     */\n    read(stream, props) {\n        const content = decodeTileContentDescription({\n            stream,\n            sizeMultiplier: props.sizeMultiplier,\n            is2d: this._is2d,\n            options: this._options,\n            isVolumeClassifier: this._isVolumeClassifier,\n        });\n        return {\n            contentRange: content.contentRange,\n            isLeaf: content.isLeaf,\n            sizeMultiplier: content.sizeMultiplier,\n            emptySubRangeMask: content.emptySubRangeMask,\n            range: Range3d.fromJSON(props.range),\n            contentId: props.contentId,\n        };\n    }\n}\n//# sourceMappingURL=TileMetadata.js.map",
      "start": 1693508121115,
      "end": 1693508121178,
      "sourcemaps": null
    }
  ]
}
