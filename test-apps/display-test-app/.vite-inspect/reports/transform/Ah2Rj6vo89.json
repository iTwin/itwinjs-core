{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/orbitgt/lib/esm/spatial/ecrs/projection/KrovakObliqueConformalConic.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module OrbitGT\n */\nimport { OperationMethod } from \"../OperationMethod\";\n/**\n * Class KrovakObliqueConformalConic defines the Krovak Oblique Conformal Conic projection as used in the Czech Republic and Slovakia.\n *\n * The 'source' CRS is the geographic CRS.\n * The 'target' CRS is the projected CRS.\n *\n * Based on the following document:\n *\n * Coordinate Conversions and Transformations including Formulas\n * Guidance Note Number 7, part 2 (version 6.18.3)\n * Revised January 2009\n * Available at: http://www.epsg.org/\n *\n * Formulas: see 1.3.2 \"Krovak Oblique Conformal Conic\"\n *\n * NOTE: the X axis runs north to south and the Y axis runs east to west. This differs from most other projections.\n *\n * @version 1.0 October 2009\n */\n/** @internal */\nclass KrovakObliqueConformalConic extends OperationMethod {\n    /**\n       * Create a new projection.\n       * @param parameters the values of the parameters.\n       */\n    constructor(parameters) {\n        super(KrovakObliqueConformalConic.METHOD_CODE, \"Krovak Oblique Conic Conformal\", parameters);\n        /* Store the parameters */\n        this._latC = parameters.getValue(8811);\n        this._lonO = parameters.getValue(8833);\n        this._aziC = parameters.getValue(1036); // Parameter 8813 has been changed to 1036 for method 9819 in EPSG version 7.7. updated on 31/08/2017.\n        this._latP = parameters.getValue(8818);\n        this._kP = parameters.getValue(8819);\n        this._FE = parameters.getValue(8806);\n        this._FN = parameters.getValue(8807);\n    }\n    /**\n       * Get the square of a number.\n       */\n    static sqr(v) {\n        return (v * v);\n    }\n    /**\n       * OperationMethod method.\n       * @see OperationMethod#initialize\n       */\n    initialize(operation) {\n        /* Prepare the parameters */\n        const ellipsoid = operation.getSourceCRS().getEllipsoid();\n        const a = ellipsoid.getA();\n        const e = ellipsoid.getE();\n        const e2 = e * e;\n        this._A = a * Math.sqrt(1.0 - e2) / (1.0 - KrovakObliqueConformalConic.sqr(e * Math.sin(this._latC)));\n        this._B = Math.sqrt(1.0 + e2 * Math.pow(Math.cos(this._latC), 4) / (1.0 - e2));\n        this._gO = Math.asin(Math.sin(this._latC) / this._B);\n        this._tO = Math.tan(Math.PI / 4 + this._gO / 2) * Math.pow((1 + e * Math.sin(this._latC)) / (1 - e * Math.sin(this._latC)), e * this._B / 2) / Math.pow(Math.tan(Math.PI / 4 + this._latC / 2), this._B);\n        this._n = Math.sin(this._latP);\n        this._rO = this._kP * this._A / Math.tan(this._latP);\n    }\n    /**\n       * OperationMethod interface method.\n       * @see OperationMethod#forward\n       */\n    forward(sourceCRS, source, targetCRS, target) {\n        /* Get the parameters */\n        const lon = source.getX();\n        const lat = source.getY();\n        /* Calculate easting and northing */\n        const e = sourceCRS.getEllipsoid().getE();\n        const U = 2 * (Math.atan(this._tO * Math.pow(Math.tan(lat / 2 + Math.PI / 4), this._B) / Math.pow((1 + e * Math.sin(lat)) / (1 - e * Math.sin(lat)), e * this._B / 2)) - Math.PI / 4);\n        const V = this._B * (this._lonO - lon);\n        const S = Math.asin(Math.cos(this._aziC) * Math.sin(U) + Math.sin(this._aziC) * Math.cos(U) * Math.cos(V));\n        const D = Math.asin(Math.cos(U) * Math.sin(V) / Math.cos(S));\n        const theta = this._n * D;\n        const r = this._rO * Math.pow(Math.tan(Math.PI / 4 + this._latP / 2), this._n) / Math.pow(Math.tan(S / 2 + Math.PI / 4), this._n);\n        const E = this._FE + r * Math.cos(theta);\n        const N = this._FN + r * Math.sin(theta);\n        /* Save the position */\n        target.setX(E);\n        target.setY(N);\n        target.setZ(source.getZ()); // Keep the Z value\n    }\n    /**\n       * OperationMethod interface method.\n       * @see OperationMethod#reverse\n       */\n    reverse(sourceCRS, source, targetCRS, target) {\n        /* Get the easting and northing */\n        const E = target.getX();\n        const N = target.getY();\n        /* Get the ellipsoid parameters */\n        const e = sourceCRS.getEllipsoid().getE();\n        /* Calculate longitude and latitude */\n        const r = Math.sqrt(KrovakObliqueConformalConic.sqr(E - this._FE) + KrovakObliqueConformalConic.sqr(N - this._FN));\n        const theta = Math.atan2((N - this._FN), (E - this._FE));\n        const D = theta / Math.sin(this._latP);\n        const S = 2 * (Math.atan(Math.pow(this._rO / r, 1 / this._n) * Math.tan(Math.PI / 4 + this._latP / 2)) - Math.PI / 4);\n        const U = Math.asin(Math.cos(this._aziC) * Math.sin(S) - Math.sin(this._aziC) * Math.cos(S) * Math.cos(D));\n        const V = Math.asin(Math.cos(S) * Math.sin(D) / Math.cos(U));\n        /* Iterate */\n        let lat = U;\n        for (let i = 1; i < 5; i++) {\n            lat = 2 * (Math.atan(Math.pow(this._tO, -1 / this._B) * Math.pow(Math.tan(U / 2 + Math.PI / 4), 1 / this._B) * Math.pow((1 + e * Math.sin(lat)) / (1 - e * Math.sin(lat)), e / 2)) - Math.PI / 4);\n        }\n        const lon = this._lonO - V / this._B;\n        /* Save the position */\n        source.setX(lon);\n        source.setY(lat);\n        source.setZ(target.getZ()); // Keep the Z value\n    }\n}\n/** The code of this method */\nKrovakObliqueConformalConic.METHOD_CODE = 9819;\nexport { KrovakObliqueConformalConic };\n//# sourceMappingURL=KrovakObliqueConformalConic.js.map",
      "start": 1693508127368,
      "end": 1693508127411,
      "sourcemaps": null
    }
  ]
}
