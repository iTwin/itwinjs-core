{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tile/IModelTileRequestChannels.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tiles\n */\nimport { assert, compareStrings, SortedArray } from \"@itwin/core-bentley\";\nimport { IModelApp } from \"../IModelApp\";\nimport { IpcApp } from \"../IpcApp\";\nimport { IModelTile, TileRequestChannel } from \"./internal\";\n/** Handles requests to the cloud storage tile cache, if one is configured. If a tile's content is not found in the cache, subsequent requests for the same tile will\n * use the IModelTileChannel instead.\n */\nclass CloudStorageCacheChannel extends TileRequestChannel {\n    async requestContent(tile) {\n        assert(tile instanceof IModelTile);\n        return IModelApp.tileAdmin.requestCachedTileContent(tile);\n    }\n    onNoContent(request) {\n        assert(request.tile instanceof IModelTile);\n        request.tile.requestChannel = IModelApp.tileAdmin.channels.iModelChannels.rpc;\n        ++this._statistics.totalCacheMisses;\n        return true;\n    }\n}\n/** For an [[IpcApp]], allows backend tile generation requests in progress to be canceled. */\nclass IModelTileChannel extends TileRequestChannel {\n    constructor() {\n        super(...arguments);\n        this._canceled = new Map();\n    }\n    onActiveRequestCanceled(request) {\n        const tree = request.tile.tree;\n        let entry = this._canceled.get(tree.iModel);\n        if (!entry)\n            this._canceled.set(tree.iModel, entry = new Map());\n        let ids = entry.get(tree.id);\n        if (!ids)\n            entry.set(tree.id, ids = new Set());\n        ids.add(request.tile.contentId);\n    }\n    processCancellations() {\n        for (const [imodel, entries] of this._canceled) {\n            const treeContentIds = [];\n            for (const [treeId, tileIds] of entries) {\n                const contentIds = Array.from(tileIds);\n                treeContentIds.push({ treeId, contentIds });\n                this._statistics.totalAbortedRequests += contentIds.length;\n            }\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            IpcApp.appFunctionIpc.cancelTileContentRequests(imodel.getRpcProps(), treeContentIds);\n        }\n        this._canceled.clear();\n    }\n    onIModelClosed(imodel) {\n        this._canceled.delete(imodel);\n    }\n}\n/** If TileAdmin.Props.cacheTileMetadata is true, then this is the first channel through which we request content for an IModelTile.\n * It serves a niche purpose: a tile pre-generation agent that wants to ensure that every tile selected during interaction with the application\n * has its tile generated and cached in cloud storage. This agent might request thousands of tiles in sequence, causing a given tile to be discarded\n * and reloaded many times. To avoid pointlessly reloading tiles whose contents have already been generated, this channel caches the metadata for each tile;\n * on subsequent requests for the same tile, it produces the metadata and an empty RenderGraphic.\n */\nclass IModelTileMetadataCacheChannel extends TileRequestChannel {\n    constructor() {\n        super(\"itwinjs-imodel-metadata-cache\", 100);\n        this._cacheByIModel = new Map();\n    }\n    onNoContent(request) {\n        assert(request.tile instanceof IModelTile);\n        const channels = IModelApp.tileAdmin.channels.iModelChannels;\n        request.tile.requestChannel = channels.cloudStorage ?? channels.rpc;\n        return true;\n    }\n    async requestContent(tile) {\n        assert(tile instanceof IModelTile);\n        const content = this.getCachedContent(tile);\n        return content ? { content } : undefined;\n    }\n    getCachedContent(tile) {\n        const cached = this._cacheByIModel.get(tile.iModel)?.get(tile.tree)?.findEquivalent((x) => compareStrings(x.contentId, tile.contentId));\n        if (!cached)\n            return undefined;\n        const content = {\n            ...cached,\n            graphic: cached.hasGraphic ? IModelApp.renderSystem.createGraphicList([]) : undefined,\n            contentRange: cached.contentRange?.clone(),\n        };\n        return content;\n    }\n    onIModelClosed(imodel) {\n        this._cacheByIModel.delete(imodel);\n    }\n    registerChannel(channel) {\n        channel.contentCallback = (tile, content) => this.cache(tile, content);\n    }\n    cache(tile, content) {\n        assert(tile instanceof IModelTile);\n        let trees = this._cacheByIModel.get(tile.iModel);\n        if (!trees)\n            this._cacheByIModel.set(tile.iModel, trees = new Map());\n        let list = trees.get(tile.tree);\n        if (!list)\n            trees.set(tile.tree, list = new SortedArray((lhs, rhs) => compareStrings(lhs.contentId, rhs.contentId)));\n        assert(undefined === list.findEquivalent((x) => compareStrings(x.contentId, tile.contentId)));\n        list.insert({\n            contentId: tile.contentId,\n            hasGraphic: undefined !== content.graphic,\n            contentRange: content.contentRange?.clone(),\n            isLeaf: content.isLeaf,\n            sizeMultiplier: content.sizeMultiplier,\n            emptySubRangeMask: content.emptySubRangeMask,\n        });\n    }\n}\n/** TileRequestChannels used for requesting content for IModelTiles.\n * @internal\n */\nexport class IModelTileRequestChannels {\n    constructor(args) {\n        const channelName = \"itwinjs-tile-rpc\";\n        this.rpc = args.usesHttp ? new TileRequestChannel(channelName, args.concurrency) : new IModelTileChannel(channelName, args.concurrency);\n        if (args.cacheMetadata) {\n            this._contentCache = new IModelTileMetadataCacheChannel();\n            this._contentCache.registerChannel(this.rpc);\n        }\n        this._cloudStorage = new CloudStorageCacheChannel(\"itwinjs-cloud-cache\", args.cacheConcurrency);\n        this._contentCache?.registerChannel(this._cloudStorage);\n    }\n    get cloudStorage() {\n        return this._cloudStorage;\n    }\n    [Symbol.iterator]() {\n        const channels = [this.rpc];\n        if (this._cloudStorage)\n            channels.push(this._cloudStorage);\n        if (this._contentCache)\n            channels.push(this._contentCache);\n        return channels[Symbol.iterator]();\n    }\n    setRpcConcurrency(concurrency) {\n        this.rpc.concurrency = concurrency;\n    }\n    getChannelForTile(tile) {\n        return tile.requestChannel || this._contentCache || this._cloudStorage || this.rpc;\n    }\n    /** Strictly for tests. */\n    getCachedContent(tile) {\n        return this._contentCache?.getCachedContent(tile);\n    }\n}\n//# sourceMappingURL=IModelTileRequestChannels.js.map",
      "start": 1693508121694,
      "end": 1693508121811,
      "sourcemaps": null
    }
  ]
}
