{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/orbitgt/lib/esm/spatial/crs/CRSManager.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module OrbitGT\n */\nimport { Strings } from \"../../system/runtime/Strings\";\nimport { Coordinate } from \"../geom/Coordinate\";\nimport { Transform } from \"../geom/Transform\";\n/**\n * Class CRSManager defines the main access point to the CRS transformation engine.\n */\n/** @internal */\nclass CRSManager {\n    /**\n     * Allow no instances, all methods are static.\n     */\n    constructor() {\n    }\n    /**\n     * Prepare a CRS for making transforms in a certain area.\n     * @param crs the CRS to prepare.\n     * @param area the area to prepare for (can be invalid to prepare only for the crs).\n     */\n    static async prepareForArea(crs, area) {\n        if (CRSManager.ENGINE == null)\n            return area;\n        return CRSManager.ENGINE.prepareForArea(crs, area);\n    }\n    /**\n     * Transform a coordinate from one CRS to another.\n     * @param point the point coordinate.\n     * @param sourceCRS the source CRS.\n     * @param targetCRS the target CRS.\n     * @return the transformed coordinate.\n     */\n    static transformPoint(point, sourceCRS, targetCRS) {\n        if (CRSManager.ENGINE == null)\n            return point;\n        return CRSManager.ENGINE.transformPoint(point, sourceCRS, targetCRS);\n    }\n    /**\n     * Transform spatial bounds from one CRS to another.\n     * @param point the point coordinate.\n     * @param sourceCRS the source CRS.\n     * @param targetCRS the target CRS.\n     * @return the transformed bounds.\n     */\n    static transformBounds(bounds, sourceCRS, targetCRS) {\n        if (CRSManager.ENGINE == null)\n            return bounds;\n        return CRSManager.ENGINE.transformBounds(bounds, sourceCRS, targetCRS);\n    }\n    /**\n     * Create an approximate 3D transformation from a source to a target CRS.\n     * @param sourceCRS the source CRS.\n     * @param sourcePoint the origin point in the source CRS.\n     * @param targetCRS the target CRS.\n     * @return the transform.\n     */\n    static createTransform(sourceCRS, sourcePoint, targetCRS) {\n        /* Check */\n        let transform = new Transform();\n        if (CRSManager.ENGINE == null)\n            return transform;\n        if (sourceCRS == null)\n            return transform;\n        if (targetCRS == null)\n            return transform;\n        if (sourcePoint == null)\n            return transform;\n        /* Same? */\n        if (Strings.equals(targetCRS, sourceCRS))\n            return transform;\n        /* Transform X and Y at 100 meter distance (assume Z is metric) */\n        let sizeXY = 100.0;\n        if (CRSManager.ENGINE.isGeographicCRS(sourceCRS))\n            sizeXY = (sizeXY / 40000000.0 * 360.0);\n        let sizeZ = 100.0;\n        /* Create the frame */\n        let p0 = sourcePoint.copy();\n        let pX = p0.copy();\n        pX.add0(new Coordinate(sizeXY, 0.0, 0.0));\n        let pY = p0.copy();\n        pY.add0(new Coordinate(0.0, sizeXY, 0.0));\n        let pZ = p0.copy();\n        pZ.add0(new Coordinate(0.0, 0.0, sizeZ));\n        /* Transform the frame */\n        p0 = CRSManager.ENGINE.transformPoint(p0, sourceCRS, targetCRS);\n        pX = CRSManager.ENGINE.transformPoint(pX, sourceCRS, targetCRS);\n        pY = CRSManager.ENGINE.transformPoint(pY, sourceCRS, targetCRS);\n        pZ = CRSManager.ENGINE.transformPoint(pZ, sourceCRS, targetCRS);\n        /* Get the columns */\n        let colX = pX.subtract(p0).scale(1.0 / sizeXY);\n        let colY = pY.subtract(p0).scale(1.0 / sizeXY);\n        let colZ = pZ.subtract(p0).scale(1.0 / sizeZ);\n        /* Create the transform */\n        transform = Transform.createWithColumns(colX, colY, colZ, p0);\n        transform.translate(-sourcePoint.getX(), -sourcePoint.getY(), -sourcePoint.getZ());\n        return transform;\n    }\n}\n/** The main instance of the CRS engine. This needs to be set by the application on startup. */\nCRSManager.ENGINE = null;\nexport { CRSManager };\n//# sourceMappingURL=CRSManager.js.map",
      "start": 1693508126054,
      "end": 1693508126221,
      "sourcemaps": null
    }
  ]
}
