{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/SolarShadowMap.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { assert, dispose } from \"@itwin/core-bentley\";\nimport { ClipUtilities, ConvexClipPlaneSet, Geometry, Map4d, Matrix3d, Matrix4d, Point3d, Range3d, Transform, Vector3d } from \"@itwin/core-geometry\";\nimport { Frustum, FrustumPlanes, RenderMode, RenderTexture, TextureTransparency, ViewFlags, } from \"@itwin/core-common\";\nimport { RenderType } from \"@itwin/webgl-compatibility\";\nimport { TileDrawArgs, TileVisibility } from \"../../tile/internal\";\nimport { BatchState } from \"./BatchState\";\nimport { EVSMGeometry } from \"./CachedGeometry\";\nimport { FrameBuffer } from \"./FrameBuffer\";\nimport { GL } from \"./GL\";\nimport { RenderCommands } from \"./RenderCommands\";\nimport { TextureUnit } from \"./RenderFlags\";\nimport { RenderState } from \"./RenderState\";\nimport { getDrawParams } from \"./ScratchDrawParams\";\nimport { System } from \"./System\";\nimport { Texture, TextureHandle } from \"./Texture\";\nfunction createDrawArgs(sceneContext, solarShadowMap, tree, frustumPlanes, processTiles) {\n    class SolarShadowMapDrawArgs extends TileDrawArgs {\n        constructor(_mapFrustumPlanes, _shadowMap, args, process) {\n            super(args);\n            this._mapFrustumPlanes = _mapFrustumPlanes;\n            this._shadowMap = _shadowMap;\n            this._processTiles = process;\n        }\n        // The solar shadow projection is parallel - which can cause excessive tile selection if it is along an axis of an unbounded tile\n        // tree such as the OSM buildings.  Rev limit the selection here.\n        get maxRealityTreeSelectionCount() { return 500; }\n        processSelectedTiles(tiles) {\n            this._processTiles(tiles);\n        }\n        get frustumPlanes() {\n            if (true === this._useViewportMap)\n                return super.frustumPlanes;\n            else\n                return this._mapFrustumPlanes;\n        }\n        get worldToViewMap() {\n            if (true === this._useViewportMap)\n                return super.worldToViewMap;\n            else\n                return this._shadowMap.worldToViewMap;\n        }\n        drawGraphics() {\n            const graphics = this.produceGraphics();\n            if (graphics)\n                this._shadowMap.addGraphic(graphics);\n        }\n        getPixelSize(tile) {\n            // For tiles that are part of the scene, size them based on the viewport frustum so that shadow map uses same resolution tiles as scene\n            // - otherwise artifacts like shadow acne may result.\n            // For tiles that are NOT part of the scene, size them based on the shadow frustum, not the viewport frustum\n            // - otherwise excessive numbers of excessively detailed may be requested for the shadow map.\n            if (undefined === this._useViewportMap) {\n                this._useViewportMap = true;\n                const vis = tile.computeVisibility(this);\n                this._useViewportMap = TileVisibility.OutsideFrustum !== vis;\n            }\n            const size = super.getPixelSize(tile);\n            this._useViewportMap = undefined;\n            return size;\n        }\n        static create(context, shadowMap, tileTree, planes, process) {\n            const args = tileTree.createDrawArgs(context);\n            return undefined !== args ? new SolarShadowMapDrawArgs(planes, shadowMap, args, process) : undefined;\n        }\n    }\n    return SolarShadowMapDrawArgs.create(sceneContext, solarShadowMap, tree, frustumPlanes, processTiles);\n}\nconst shadowMapWidth = 4096; // size of original depth buffer map\nconst shadowMapHeight = shadowMapWidth; // TBD - Adjust for aspect ratio.\nconst evsmWidth = shadowMapWidth / 2; // EVSM buffer is 1/2 size each direction\nconst evsmHeight = shadowMapHeight / 2;\nconst postProjectionMatrixNpc = Matrix4d.createRowValues(/* Row 1 */ 0, 1, 0, 0, /* Row 1 */ 0, 0, 1, 0, /* Row 3 */ 1, 0, 0, 0, /* Row 4 */ 0, 0, 0, 1);\n// Bundles up the disposable, create-once-and-reuse members of a SolarShadowMap.\nclass Bundle {\n    constructor(depthTexture, shadowMapTexture, fbo, fboSM, evsmGeom, renderCommands) {\n        this.depthTexture = depthTexture;\n        this.shadowMapTexture = shadowMapTexture;\n        this.fbo = fbo;\n        this.fboSM = fboSM;\n        this.evsmGeom = evsmGeom;\n        this.renderCommands = renderCommands;\n    }\n    static create(target, stack, batch) {\n        const depthTextureHandle = System.instance.createDepthBuffer(shadowMapWidth, shadowMapHeight);\n        if (undefined === depthTextureHandle)\n            return undefined;\n        let pixelDataType = GL.Texture.DataType.Float;\n        switch (System.instance.maxRenderType) {\n            case RenderType.TextureFloat:\n                break;\n            case RenderType.TextureHalfFloat:\n                pixelDataType = System.instance.context.HALF_FLOAT;\n                break;\n            /* falls through */\n            default:\n                return undefined;\n        }\n        const colorTextures = [];\n        const fbo = FrameBuffer.create(colorTextures, depthTextureHandle);\n        if (undefined === fbo)\n            return undefined;\n        // shadowMap texture is 1/4 size the depth texture (and averaged down when converting)\n        const shadowMapTextureHandle = TextureHandle.createForAttachment(evsmWidth, evsmHeight, GL.Texture.Format.Rgba, pixelDataType);\n        if (undefined === shadowMapTextureHandle)\n            return undefined;\n        const fboSM = FrameBuffer.create([shadowMapTextureHandle]);\n        if (undefined === fboSM)\n            return undefined;\n        const depthTexture = new Texture({ ownership: \"external\", type: RenderTexture.Type.TileSection, handle: depthTextureHandle, transparency: TextureTransparency.Opaque });\n        const evsmGeom = EVSMGeometry.createGeometry(depthTexture.texture.getHandle(), shadowMapWidth, shadowMapHeight);\n        if (undefined === evsmGeom)\n            return undefined;\n        const shadowMapTexture = new Texture({ type: RenderTexture.Type.Normal, ownership: \"external\", handle: shadowMapTextureHandle, transparency: TextureTransparency.Opaque });\n        const renderCommands = new RenderCommands(target, stack, batch);\n        return new Bundle(depthTexture, shadowMapTexture, fbo, fboSM, evsmGeom, renderCommands);\n    }\n    get isDisposed() {\n        return this.depthTexture.isDisposed\n            && this.shadowMapTexture.isDisposed\n            && this.fbo.isDisposed\n            && this.fboSM.isDisposed\n            && this.evsmGeom.isDisposed;\n    }\n    dispose() {\n        dispose(this.depthTexture);\n        dispose(this.shadowMapTexture);\n        dispose(this.fbo);\n        dispose(this.fboSM);\n        dispose(this.evsmGeom);\n    }\n}\n/** Describes the set of parameters which, when they change, require us to recreate the shadow map. */\nclass ShadowMapParams {\n    constructor(viewFrustum, direction, settings) {\n        this.direction = new Vector3d();\n        this.viewFrustum = new Frustum();\n        direction.clone(this.direction);\n        this.viewFrustum.setFrom(viewFrustum);\n        this.settings = settings;\n    }\n    update(viewFrustum, direction, settings) {\n        this.settings = settings;\n        this.viewFrustum.setFrom(viewFrustum);\n        direction.clone(this.direction);\n    }\n}\nconst defaultSunDirection = Vector3d.create(-1, -1, -1).normalize();\nconst scratchFrustum = new Frustum();\nconst scratchFrustumPlanes = FrustumPlanes.createEmpty();\nexport class SolarShadowMap {\n    getBundle(target) {\n        if (undefined === this._bundle) {\n            this._bundle = Bundle.create(target, target.uniforms.branch.stack, this._batchState);\n            assert(undefined !== this._bundle);\n        }\n        return this._bundle;\n    }\n    get isReady() { return this._isReady; }\n    get isDrawing() { return this._isDrawing; }\n    get isEnabled() { return this._enabled; }\n    get projectionMatrix() { return this._projectionMatrix; }\n    get depthTexture() { return undefined !== this._bundle ? this._bundle.depthTexture : undefined; }\n    get shadowMapTexture() { return undefined !== this._bundle ? this._bundle.shadowMapTexture : undefined; }\n    get settings() { return undefined !== this._params ? this._params.settings : undefined; }\n    get direction() { return undefined !== this._params ? this._params.direction : undefined; }\n    get frustum() { return this._shadowFrustum; }\n    get worldToViewMap() { return this._worldToViewMap; }\n    addGraphic(graphic) { this._graphics.push(graphic); }\n    constructor(target) {\n        this._projectionMatrix = Matrix4d.createIdentity();\n        this._graphics = [];\n        this._shadowFrustum = new Frustum();\n        this._isReady = false;\n        this._isDrawing = false;\n        this._enabled = false;\n        this._scratchRange = Range3d.createNull();\n        this._scratchTransform = Transform.createIdentity();\n        this._scratchViewFlags = new ViewFlags();\n        this._worldToViewMap = Map4d.createIdentity();\n        this._target = target;\n        this._renderState = new RenderState();\n        this._renderState.flags.depthMask = true;\n        this._renderState.flags.blend = false;\n        this._renderState.flags.depthTest = true;\n        this._noZRenderState = new RenderState();\n        this._noZRenderState.flags.depthMask = false;\n        this._batchState = new BatchState(target.uniforms.branch.stack);\n    }\n    disable() {\n        this._enabled = this._isReady = false;\n        this._bundle = dispose(this._bundle);\n        this.clearGraphics(true);\n        this._target.uniforms.shadow.update();\n    }\n    collectStatistics(stats) {\n        const bundle = this._bundle;\n        if (undefined !== bundle)\n            stats.addShadowMap(bundle.depthTexture.bytesUsed + bundle.shadowMapTexture.bytesUsed);\n    }\n    get isDisposed() { return undefined === this._bundle && 0 === this._graphics.length; }\n    dispose() {\n        this._bundle = dispose(this._bundle);\n        this.clearGraphics(true);\n    }\n    clearGraphics(notify) {\n        for (const graphic of this._graphics)\n            graphic.dispose();\n        this._graphics.length = 0;\n        if (notify)\n            this.notifyGraphicsChanged();\n    }\n    notifyGraphicsChanged() {\n        if (undefined !== this.onGraphicsChanged)\n            this.onGraphicsChanged(this._graphics);\n    }\n    update(context) {\n        this._isReady = false;\n        this.clearGraphics(false);\n        if (undefined === context || !context.viewport.view.isSpatialView()) {\n            this.disable();\n            this.notifyGraphicsChanged();\n            return;\n        }\n        const view = context.viewport.view;\n        const style = view.getDisplayStyle3d();\n        const sunDirection = style.sunDirection ?? defaultSunDirection;\n        const minimumHorizonDirection = -.01;\n        if (sunDirection.z > minimumHorizonDirection) {\n            this.notifyGraphicsChanged();\n            return;\n        }\n        this._enabled = true;\n        const viewFrustum = context.viewingSpace.getFrustum();\n        const settings = style.settings.solarShadows;\n        if (undefined === this._params)\n            this._params = new ShadowMapParams(viewFrustum, sunDirection, settings);\n        else\n            this._params.update(viewFrustum, sunDirection, settings);\n        const iModel = view.iModel;\n        const worldToMapTransform = Transform.createRefs(Point3d.createZero(), Matrix3d.createRigidHeadsUp(this._params.direction.negate()).inverse());\n        const worldToMap = Matrix4d.createTransform(worldToMapTransform);\n        const mapToWorld = worldToMap.createInverse();\n        // Start with entire project.\n        const shadowRange = worldToMapTransform.multiplyRange(iModel.projectExtents);\n        // Limit the map to only displayed models.\n        const viewTileRange = Range3d.createNull();\n        view.forEachTileTreeRef((ref) => {\n            if (ref.castsShadows) {\n                if (ref.isGlobal) {\n                    // A shadow-casting tile tree that spans the globe. Limit its range to the viewed extents.\n                    for (const p3 of viewFrustum.points) {\n                        const p4 = worldToMap.multiplyPoint3d(p3, 1);\n                        if (p4.w > 0.0001)\n                            viewTileRange.extendXYZW(p4.x, p4.y, p4.z, p4.w);\n                        else\n                            viewTileRange.high.z = Math.max(1.0, viewTileRange.high.z); // behind eye plane.\n                    }\n                }\n                else {\n                    ref.accumulateTransformedRange(viewTileRange, worldToMap, undefined);\n                }\n            }\n        });\n        if (!viewTileRange.isNull)\n            viewTileRange.clone(shadowRange);\n        // Expand shadow range to include both the shadowers and shadowed portion of background map.\n        scratchFrustum.initFromRange(shadowRange);\n        mapToWorld.multiplyPoint3dArrayQuietNormalize(scratchFrustum.points); // This frustum represents the shadwowing geometry.  Intersect it with background geometry and expand the range depth to include that intersection.\n        const backgroundMapGeometry = context.viewport.view.displayStyle.getBackgroundMapGeometry();\n        if (undefined !== backgroundMapGeometry) {\n            const backgroundDepthRange = backgroundMapGeometry.getFrustumIntersectionDepthRange(this._shadowFrustum, iModel.projectExtents);\n            if (!backgroundDepthRange.isNull)\n                shadowRange.low.z = Math.min(shadowRange.low.z, backgroundDepthRange.low);\n        }\n        this._params.viewFrustum.transformBy(worldToMapTransform, scratchFrustum);\n        scratchFrustumPlanes.init(scratchFrustum);\n        const viewIntersectShadowRange = Range3d.createNull();\n        const viewClipPlanes = ConvexClipPlaneSet.createPlanes(scratchFrustumPlanes.planes);\n        ClipUtilities.announceLoopsOfConvexClipPlaneSetIntersectRange(viewClipPlanes, shadowRange, (points) => {\n            for (const point of points.getPoint3dArray())\n                viewIntersectShadowRange.extendPoint(point);\n        });\n        if (viewIntersectShadowRange.isNull) {\n            this.notifyGraphicsChanged();\n            return;\n        }\n        viewIntersectShadowRange.high.z = shadowRange.high.z; // We need to include shadowing geometry that may be outside view (along the solar axis).\n        this._shadowFrustum.initFromRange(viewIntersectShadowRange);\n        mapToWorld.multiplyPoint3dArrayQuietNormalize(this._shadowFrustum.points);\n        const tileRange = Range3d.createNull();\n        scratchFrustumPlanes.init(this._shadowFrustum);\n        view.forEachTileTreeRef(((ref) => {\n            if (!ref.castsShadows)\n                return;\n            const drawArgs = createDrawArgs(context, this, ref, scratchFrustumPlanes, (tiles) => {\n                for (const tile of tiles)\n                    tileRange.extendRange(tileToMapTransform.multiplyRange(tile.range, this._scratchRange));\n            });\n            if (undefined === drawArgs)\n                return;\n            const tileToMapTransform = worldToMapTransform.multiplyTransformTransform(drawArgs.location, this._scratchTransform);\n            drawArgs.tree.draw(drawArgs);\n        }));\n        if (tileRange.isNull) {\n            this.clearGraphics(true);\n        }\n        else if (this._graphics.length > 0) {\n            // Avoid an uninvertible matrix on empty range...\n            if (Geometry.isAlmostEqualNumber(shadowRange.low.x, shadowRange.high.x) ||\n                Geometry.isAlmostEqualNumber(shadowRange.low.y, shadowRange.high.y) ||\n                Geometry.isAlmostEqualNumber(shadowRange.low.z, shadowRange.high.z)) {\n                this.clearGraphics(true);\n                return;\n            }\n            const frustumMap = this._shadowFrustum.toMap4d();\n            if (undefined === frustumMap) {\n                this.clearGraphics(true);\n                assert(false);\n                return;\n            }\n            this._projectionMatrix = frustumMap.transform0.clone();\n            const worldToNpc = postProjectionMatrixNpc.multiplyMatrixMatrix(this._projectionMatrix);\n            const npcToView = Map4d.createBoxMap(Point3d.create(0, 0, 0), Point3d.create(1, 1, 1), Point3d.create(0, 0, 0), Point3d.create(shadowMapWidth, shadowMapHeight, 1));\n            const npcToWorld = worldToNpc.createInverse();\n            if (undefined === npcToWorld) {\n                this.clearGraphics(true);\n                return;\n            }\n            const worldToNpcMap = Map4d.createRefs(worldToNpc, npcToWorld);\n            this._worldToViewMap = npcToView.multiplyMapMap(worldToNpcMap);\n        }\n        this._target.uniforms.shadow.update();\n        this.notifyGraphicsChanged();\n    }\n    draw(target) {\n        assert(this.isEnabled);\n        if (this.isReady || 0 === this._graphics.length)\n            return;\n        const bundle = this.getBundle(target);\n        if (undefined === bundle)\n            return;\n        this._isDrawing = true;\n        const prevState = System.instance.currentRenderState.clone();\n        const gl = System.instance.context;\n        gl.viewport(0, 0, shadowMapWidth, shadowMapHeight);\n        // NB: textures and materials are needed because their transparencies affect whether or not a surface casts shadows\n        const viewFlags = target.currentViewFlags.copy({\n            renderMode: RenderMode.SmoothShade,\n            wiremesh: false,\n            transparency: false,\n            lighting: false,\n            shadows: false,\n            monochrome: false,\n            ambientOcclusion: false,\n            visibleEdges: false,\n            hiddenEdges: false,\n        });\n        System.instance.applyRenderState(this._renderState);\n        const prevPlan = target.plan;\n        target.changeFrustum(this._shadowFrustum, this._shadowFrustum.getFraction(), true);\n        target.uniforms.branch.changeRenderPlan(viewFlags, target.plan.is3d, target.plan.hline);\n        const renderCommands = bundle.renderCommands;\n        renderCommands.reset(target, target.uniforms.branch.stack, this._batchState);\n        renderCommands.addGraphics(this._graphics);\n        System.instance.frameBufferStack.execute(bundle.fbo, true, false, () => {\n            System.instance.context.clearDepth(1.0);\n            System.instance.context.clear(GL.BufferBit.Depth);\n            target.techniques.execute(target, renderCommands.getCommands(3 /* RenderPass.OpaquePlanar */), 19 /* RenderPass.PlanarClassification */); // Draw these with RenderPass.PlanarClassification (rather than Opaque...) so that the pick ordering is avoided.\n            target.techniques.execute(target, renderCommands.getCommands(5 /* RenderPass.OpaqueGeneral */), 19 /* RenderPass.PlanarClassification */); // Draw these with RenderPass.PlanarClassification (rather than Opaque...) so that the pick ordering is avoided.\n        });\n        // copy depth buffer to EVSM shadow buffer and average down for AA effect\n        gl.viewport(0, 0, evsmWidth, evsmHeight);\n        System.instance.frameBufferStack.execute(bundle.fboSM, true, false, () => {\n            System.instance.applyRenderState(this._noZRenderState);\n            const params = getDrawParams(target, bundle.evsmGeom);\n            target.techniques.draw(params);\n        });\n        // mipmap resulting EVSM texture and set filtering options\n        System.instance.activateTexture2d(TextureUnit.ShadowMap, bundle.shadowMapTexture.texture.getHandle());\n        gl.generateMipmap(gl.TEXTURE_2D);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n        System.instance.setMaxAnisotropy(undefined);\n        // target.recordPerformanceMetric(\"Compute EVSM\");\n        this._batchState.reset(); // Reset the batch Ids...\n        target.changeRenderPlan(prevPlan);\n        System.instance.applyRenderState(prevState);\n        System.instance.context.viewport(0, 0, target.viewRect.width, target.viewRect.height); // Restore viewport\n        this.clearGraphics(false);\n        this._isDrawing = false;\n        this._isReady = true;\n    }\n}\n//# sourceMappingURL=SolarShadowMap.js.map",
      "start": 1693508124720,
      "end": 1693508124906,
      "sourcemaps": null
    }
  ]
}
