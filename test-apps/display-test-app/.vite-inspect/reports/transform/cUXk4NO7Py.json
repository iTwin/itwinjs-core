{
  "resolvedId": "D:/hub2023A/itwinjs-core/test-apps/display-test-app/src/frontend/TerrainDrapeTool.ts",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\r\n* See LICENSE.md in the project root for license terms and full copyright notice.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\nimport { ConvexClipPlaneSet, CurvePrimitive, GrowableXYZArray, LineString3d, Point3d, PolyfaceQuery, Range3d, SweepLineStringToFacetsOptions, Transform, Vector3d } from \"@itwin/core-geometry\";\r\nimport { ColorDef, LinePixels } from \"@itwin/core-common\";\r\nimport {\r\n  BeButtonEvent, CollectTileStatus, DecorateContext, DisclosedTileTreeSet, EventHandled, GeometryTileTreeReference, GraphicType, HitDetail, IModelApp,\r\n  LocateFilterStatus, LocateResponse, PrimitiveTool, Tile, TileGeometryCollector, TileUser, Viewport,\r\n} from \"@itwin/core-frontend\";\r\n\r\n/** A TileGeometryCollector that restricts collection to tiles that overlap a line string. */\r\nclass DrapeLineStringCollector extends TileGeometryCollector {\r\n  constructor(user: TileUser, chordTolerance: number, range: Range3d, transform: Transform, private _points: GrowableXYZArray) {\r\n    super({ user, chordTolerance, range, transform });\r\n  }\r\n\r\n  public override collectTile(tile: Tile): CollectTileStatus {\r\n    let status = super.collectTile(tile);\r\n    if (\"reject\" !== status && !this.rangeOverlapsLineString(tile.range))\r\n      status = \"reject\";\r\n\r\n    return status;\r\n  }\r\n\r\n  private rangeOverlapsLineString(range: Range3d) {\r\n    let inside = false;\r\n    const clipper = ConvexClipPlaneSet.createRange3dPlanes(range, true, true, true, true, false, false);\r\n    if (this._options.transform)\r\n      clipper.transformInPlace(this._options.transform);\r\n\r\n    for (let i = 0; i < this._points.length - 1 && !inside; i++)\r\n      inside = clipper.announceClippedSegmentIntervals(0, 1, this._points.getPoint3dAtUncheckedPointIndex(i), this._points.getPoint3dAtUncheckedPointIndex(i + 1));\r\n\r\n    return inside;\r\n  }\r\n}\r\n\r\nclass TerrainDraper implements TileUser {\r\n  public readonly tileUserId: number;\r\n\r\n  public constructor(public readonly viewport: Viewport, public readonly treeRef: GeometryTileTreeReference) {\r\n    this.tileUserId = TileUser.generateId();\r\n    IModelApp.tileAdmin.registerUser(this);\r\n  }\r\n\r\n  public dispose(): void {\r\n    IModelApp.tileAdmin.forgetUser(this);\r\n  }\r\n\r\n  public get iModel() { return this.viewport.iModel; }\r\n\r\n  public onRequestStateChanged() {\r\n    this.viewport.invalidateDecorations();\r\n  }\r\n\r\n  public discloseTileTrees(trees: DisclosedTileTreeSet) {\r\n    trees.disclose(this.treeRef);\r\n  }\r\n\r\n  public drapeLineString(outStrings: CurvePrimitive[], inPoints: GrowableXYZArray, tolerance: number, maxDistance = 1.0E5): \"loading\" | \"complete\" {\r\n    const tree = this.treeRef.treeOwner.load();\r\n    if (!tree)\r\n      return \"loading\";\r\n\r\n    const range = Range3d.createNull();\r\n    range.extendArray(inPoints);\r\n    range.extendZOnly(-maxDistance);  // Expand - but not so much that we get opposite side of globe.\r\n    range.extendZOnly(maxDistance);\r\n\r\n    const collector = new DrapeLineStringCollector(this, tolerance, range, tree.iModelTransform, inPoints);\r\n    this.treeRef.collectTileGeometry(collector);\r\n    collector.requestMissingTiles();\r\n\r\n    for (const polyface of collector.polyfaces)\r\n      outStrings.push(...PolyfaceQuery.sweepLineStringToFacets(inPoints, polyface,\r\n        SweepLineStringToFacetsOptions.create(Vector3d.unitZ(), undefined, true, true, true, true)));\r\n\r\n    return collector.isAllGeometryLoaded ? \"complete\" : \"loading\";\r\n  }\r\n}\r\n\r\n/** Demonstrates draping line strings on terrain meshes.  The terrain can be defined by map terrain (from Cesium World Terrain) or a reality model.\r\n */\r\nexport class TerrainDrapeTool extends PrimitiveTool {\r\n  private _drapePoints = new GrowableXYZArray();\r\n  private _drapedStrings?: LineString3d[];\r\n  private _motionPoint?: Point3d;\r\n  private _draper?: TerrainDraper;\r\n  public static override toolId = \"TerrainDrape\";\r\n\r\n  public override requireWriteableTarget(): boolean {\r\n    return false;\r\n  }\r\n\r\n  public override async onPostInstall() {\r\n    await super.onPostInstall();\r\n    this.setupAndPromptForNextAction();\r\n  }\r\n\r\n  public override async onCleanup() {\r\n    this.disposeDraper();\r\n  }\r\n\r\n  private disposeDraper(): void {\r\n    this._draper?.dispose();\r\n    this._draper = undefined;\r\n  }\r\n\r\n  public override async onUnsuspend(): Promise<void> {\r\n    this.showPrompt();\r\n  }\r\n\r\n  public createDecorations(context: DecorateContext, _suspend: boolean): void {\r\n    if (!this._draper)\r\n      return;\r\n\r\n    if (this._drapePoints.length > 1) {\r\n      const builder = context.createGraphicBuilder(GraphicType.WorldDecoration);\r\n      builder.setSymbology(ColorDef.red, ColorDef.red, 5);\r\n\r\n      let loading = false;\r\n      if (!this._drapedStrings) {\r\n        this._drapedStrings = [];\r\n        const drapeRange = Range3d.createNull();\r\n        drapeRange.extendArray(this._drapePoints);\r\n\r\n        const tolerance = drapeRange.diagonal().magnitude() / 5000;\r\n        loading = \"loading\" === this._draper.drapeLineString(this._drapedStrings, this._drapePoints, tolerance);\r\n      }\r\n\r\n      for (const lineString of this._drapedStrings)\r\n        builder.addLineString(lineString.points);\r\n\r\n      if (loading)\r\n        this._drapedStrings = undefined;\r\n\r\n      context.addDecorationFromBuilder(builder);\r\n    }\r\n\r\n    if (this._motionPoint) {\r\n      const builder = context.createGraphicBuilder(GraphicType.WorldOverlay);\r\n      builder.setSymbology(ColorDef.white, ColorDef.white, 1, LinePixels.Code0);\r\n      builder.addLineString([this._drapePoints.getPoint3dAtUncheckedPointIndex(this._drapePoints.length - 1), this._motionPoint]);\r\n      context.addDecorationFromBuilder(builder);\r\n    }\r\n  }\r\n\r\n  public override decorate(context: DecorateContext): void {\r\n    this.createDecorations(context, false);\r\n  }\r\n\r\n  public override decorateSuspended(context: DecorateContext): void {\r\n    this.createDecorations(context, true);\r\n  }\r\n\r\n  private setupAndPromptForNextAction(): void {\r\n    this.initLocateElements(undefined === this._draper);\r\n    IModelApp.locateManager.options.allowDecorations = true;    // So we can select \"contextual\" reality models.\r\n    this.showPrompt();\r\n  }\r\n\r\n  private showPrompt(): void {\r\n    IModelApp.notifications.outputPromptByKey(`SVTTools:tools.TerrainDrape.Prompts.${undefined === this._draper ? \"SelectDrapeRealityModel\" : \"EnterDrapePoint\"}`);\r\n  }\r\n\r\n  private getGeometryTreeRef(vp: Viewport, modelId: string): GeometryTileTreeReference | undefined {\r\n    let treeRef: GeometryTileTreeReference | undefined;\r\n    vp.forEachTileTreeRef((ref) => {\r\n      if (!treeRef) {\r\n        const tree = ref.treeOwner.load();\r\n        if (tree?.modelId === modelId)\r\n          treeRef = ref.createGeometryTreeReference();\r\n      }\r\n    });\r\n\r\n    return treeRef;\r\n  }\r\n\r\n  public override async filterHit(hit: HitDetail, _out?: LocateResponse): Promise<LocateFilterStatus> {\r\n    if (undefined !== this._draper)\r\n      return LocateFilterStatus.Accept;\r\n\r\n    if (!hit.modelId)\r\n      return LocateFilterStatus.Reject;\r\n\r\n    return this.getGeometryTreeRef(hit.viewport, hit.modelId) ? LocateFilterStatus.Accept : LocateFilterStatus.Reject;\r\n  }\r\n\r\n  public override async onMouseMotion(ev: BeButtonEvent): Promise<void> {\r\n    this._motionPoint = ev.point;\r\n    if (ev.viewport)\r\n      ev.viewport.invalidateDecorations();\r\n  }\r\n\r\n  public override async onResetButtonUp(ev: BeButtonEvent): Promise<EventHandled> {\r\n    this._drapedStrings = undefined;\r\n    if (this._drapePoints.length)\r\n      this._drapePoints.pop();\r\n    else\r\n      this.disposeDraper();\r\n\r\n    if (ev.viewport)\r\n      ev.viewport.invalidateDecorations();\r\n\r\n    this.setupAndPromptForNextAction();\r\n    return EventHandled.No;\r\n  }\r\n\r\n  public override async onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled> {\r\n    this._motionPoint = undefined;\r\n    const hit = await IModelApp.locateManager.doLocate(new LocateResponse(), true, ev.point, ev.viewport, ev.inputSource);\r\n    if (undefined === this._draper) {\r\n      if (hit?.modelId) {\r\n        this._drapePoints.push(hit.hitPoint);\r\n        const drapeTreeRef = this.getGeometryTreeRef(hit.viewport, hit.modelId);\r\n        if (drapeTreeRef)\r\n          this._draper = new TerrainDraper(hit.viewport, drapeTreeRef);\r\n      }\r\n    } else {\r\n      this._drapePoints.push(hit ? hit.hitPoint : ev.point);\r\n    }\r\n\r\n    this._drapedStrings = undefined;\r\n    this.setupAndPromptForNextAction();\r\n    return EventHandled.No;\r\n  }\r\n\r\n  public override async onRestartTool(): Promise<void> {\r\n    const tool = new TerrainDrapeTool();\r\n    if (!await tool.run())\r\n      await this.exitTool();\r\n  }\r\n\r\n  public override async parseAndRun(..._args: string[]): Promise<boolean> {\r\n    return this.run();\r\n  }\r\n}\r\n",
      "start": 1693508121254,
      "end": 1693508121325,
      "sourcemaps": null
    },
    {
      "name": "vite:esbuild",
      "result": "\"use strict\";\nimport { ConvexClipPlaneSet, GrowableXYZArray, PolyfaceQuery, Range3d, SweepLineStringToFacetsOptions, Vector3d } from \"@itwin/core-geometry\";\nimport { ColorDef, LinePixels } from \"@itwin/core-common\";\nimport {\n  EventHandled,\n  GraphicType,\n  IModelApp,\n  LocateFilterStatus,\n  LocateResponse,\n  PrimitiveTool,\n  TileGeometryCollector,\n  TileUser\n} from \"@itwin/core-frontend\";\nclass DrapeLineStringCollector extends TileGeometryCollector {\n  constructor(user, chordTolerance, range, transform, _points) {\n    super({ user, chordTolerance, range, transform });\n    this._points = _points;\n  }\n  collectTile(tile) {\n    let status = super.collectTile(tile);\n    if (\"reject\" !== status && !this.rangeOverlapsLineString(tile.range))\n      status = \"reject\";\n    return status;\n  }\n  rangeOverlapsLineString(range) {\n    let inside = false;\n    const clipper = ConvexClipPlaneSet.createRange3dPlanes(range, true, true, true, true, false, false);\n    if (this._options.transform)\n      clipper.transformInPlace(this._options.transform);\n    for (let i = 0; i < this._points.length - 1 && !inside; i++)\n      inside = clipper.announceClippedSegmentIntervals(0, 1, this._points.getPoint3dAtUncheckedPointIndex(i), this._points.getPoint3dAtUncheckedPointIndex(i + 1));\n    return inside;\n  }\n}\nclass TerrainDraper {\n  constructor(viewport, treeRef) {\n    this.viewport = viewport;\n    this.treeRef = treeRef;\n    this.tileUserId = TileUser.generateId();\n    IModelApp.tileAdmin.registerUser(this);\n  }\n  dispose() {\n    IModelApp.tileAdmin.forgetUser(this);\n  }\n  get iModel() {\n    return this.viewport.iModel;\n  }\n  onRequestStateChanged() {\n    this.viewport.invalidateDecorations();\n  }\n  discloseTileTrees(trees) {\n    trees.disclose(this.treeRef);\n  }\n  drapeLineString(outStrings, inPoints, tolerance, maxDistance = 1e5) {\n    const tree = this.treeRef.treeOwner.load();\n    if (!tree)\n      return \"loading\";\n    const range = Range3d.createNull();\n    range.extendArray(inPoints);\n    range.extendZOnly(-maxDistance);\n    range.extendZOnly(maxDistance);\n    const collector = new DrapeLineStringCollector(this, tolerance, range, tree.iModelTransform, inPoints);\n    this.treeRef.collectTileGeometry(collector);\n    collector.requestMissingTiles();\n    for (const polyface of collector.polyfaces)\n      outStrings.push(...PolyfaceQuery.sweepLineStringToFacets(\n        inPoints,\n        polyface,\n        SweepLineStringToFacetsOptions.create(Vector3d.unitZ(), void 0, true, true, true, true)\n      ));\n    return collector.isAllGeometryLoaded ? \"complete\" : \"loading\";\n  }\n}\nconst _TerrainDrapeTool = class _TerrainDrapeTool extends PrimitiveTool {\n  constructor() {\n    super(...arguments);\n    this._drapePoints = new GrowableXYZArray();\n  }\n  requireWriteableTarget() {\n    return false;\n  }\n  async onPostInstall() {\n    await super.onPostInstall();\n    this.setupAndPromptForNextAction();\n  }\n  async onCleanup() {\n    this.disposeDraper();\n  }\n  disposeDraper() {\n    this._draper?.dispose();\n    this._draper = void 0;\n  }\n  async onUnsuspend() {\n    this.showPrompt();\n  }\n  createDecorations(context, _suspend) {\n    if (!this._draper)\n      return;\n    if (this._drapePoints.length > 1) {\n      const builder = context.createGraphicBuilder(GraphicType.WorldDecoration);\n      builder.setSymbology(ColorDef.red, ColorDef.red, 5);\n      let loading = false;\n      if (!this._drapedStrings) {\n        this._drapedStrings = [];\n        const drapeRange = Range3d.createNull();\n        drapeRange.extendArray(this._drapePoints);\n        const tolerance = drapeRange.diagonal().magnitude() / 5e3;\n        loading = \"loading\" === this._draper.drapeLineString(this._drapedStrings, this._drapePoints, tolerance);\n      }\n      for (const lineString of this._drapedStrings)\n        builder.addLineString(lineString.points);\n      if (loading)\n        this._drapedStrings = void 0;\n      context.addDecorationFromBuilder(builder);\n    }\n    if (this._motionPoint) {\n      const builder = context.createGraphicBuilder(GraphicType.WorldOverlay);\n      builder.setSymbology(ColorDef.white, ColorDef.white, 1, LinePixels.Code0);\n      builder.addLineString([this._drapePoints.getPoint3dAtUncheckedPointIndex(this._drapePoints.length - 1), this._motionPoint]);\n      context.addDecorationFromBuilder(builder);\n    }\n  }\n  decorate(context) {\n    this.createDecorations(context, false);\n  }\n  decorateSuspended(context) {\n    this.createDecorations(context, true);\n  }\n  setupAndPromptForNextAction() {\n    this.initLocateElements(void 0 === this._draper);\n    IModelApp.locateManager.options.allowDecorations = true;\n    this.showPrompt();\n  }\n  showPrompt() {\n    IModelApp.notifications.outputPromptByKey(`SVTTools:tools.TerrainDrape.Prompts.${void 0 === this._draper ? \"SelectDrapeRealityModel\" : \"EnterDrapePoint\"}`);\n  }\n  getGeometryTreeRef(vp, modelId) {\n    let treeRef;\n    vp.forEachTileTreeRef((ref) => {\n      if (!treeRef) {\n        const tree = ref.treeOwner.load();\n        if (tree?.modelId === modelId)\n          treeRef = ref.createGeometryTreeReference();\n      }\n    });\n    return treeRef;\n  }\n  async filterHit(hit, _out) {\n    if (void 0 !== this._draper)\n      return LocateFilterStatus.Accept;\n    if (!hit.modelId)\n      return LocateFilterStatus.Reject;\n    return this.getGeometryTreeRef(hit.viewport, hit.modelId) ? LocateFilterStatus.Accept : LocateFilterStatus.Reject;\n  }\n  async onMouseMotion(ev) {\n    this._motionPoint = ev.point;\n    if (ev.viewport)\n      ev.viewport.invalidateDecorations();\n  }\n  async onResetButtonUp(ev) {\n    this._drapedStrings = void 0;\n    if (this._drapePoints.length)\n      this._drapePoints.pop();\n    else\n      this.disposeDraper();\n    if (ev.viewport)\n      ev.viewport.invalidateDecorations();\n    this.setupAndPromptForNextAction();\n    return EventHandled.No;\n  }\n  async onDataButtonDown(ev) {\n    this._motionPoint = void 0;\n    const hit = await IModelApp.locateManager.doLocate(new LocateResponse(), true, ev.point, ev.viewport, ev.inputSource);\n    if (void 0 === this._draper) {\n      if (hit?.modelId) {\n        this._drapePoints.push(hit.hitPoint);\n        const drapeTreeRef = this.getGeometryTreeRef(hit.viewport, hit.modelId);\n        if (drapeTreeRef)\n          this._draper = new TerrainDraper(hit.viewport, drapeTreeRef);\n      }\n    } else {\n      this._drapePoints.push(hit ? hit.hitPoint : ev.point);\n    }\n    this._drapedStrings = void 0;\n    this.setupAndPromptForNextAction();\n    return EventHandled.No;\n  }\n  async onRestartTool() {\n    const tool = new _TerrainDrapeTool();\n    if (!await tool.run())\n      await this.exitTool();\n  }\n  async parseAndRun(..._args) {\n    return this.run();\n  }\n};\n_TerrainDrapeTool.toolId = \"TerrainDrape\";\nexport let TerrainDrapeTool = _TerrainDrapeTool;\n",
      "start": 1693508121325,
      "end": 1693508121469,
      "order": "normal",
      "sourcemaps": {
        "version": 3,
        "sources": [
          "D:/hub2023A/itwinjs-core/test-apps/display-test-app/src/frontend/TerrainDrapeTool.ts"
        ],
        "sourcesContent": [
          "/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\r\n* See LICENSE.md in the project root for license terms and full copyright notice.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\nimport { ConvexClipPlaneSet, CurvePrimitive, GrowableXYZArray, LineString3d, Point3d, PolyfaceQuery, Range3d, SweepLineStringToFacetsOptions, Transform, Vector3d } from \"@itwin/core-geometry\";\r\nimport { ColorDef, LinePixels } from \"@itwin/core-common\";\r\nimport {\r\n  BeButtonEvent, CollectTileStatus, DecorateContext, DisclosedTileTreeSet, EventHandled, GeometryTileTreeReference, GraphicType, HitDetail, IModelApp,\r\n  LocateFilterStatus, LocateResponse, PrimitiveTool, Tile, TileGeometryCollector, TileUser, Viewport,\r\n} from \"@itwin/core-frontend\";\r\n\r\n/** A TileGeometryCollector that restricts collection to tiles that overlap a line string. */\r\nclass DrapeLineStringCollector extends TileGeometryCollector {\r\n  constructor(user: TileUser, chordTolerance: number, range: Range3d, transform: Transform, private _points: GrowableXYZArray) {\r\n    super({ user, chordTolerance, range, transform });\r\n  }\r\n\r\n  public override collectTile(tile: Tile): CollectTileStatus {\r\n    let status = super.collectTile(tile);\r\n    if (\"reject\" !== status && !this.rangeOverlapsLineString(tile.range))\r\n      status = \"reject\";\r\n\r\n    return status;\r\n  }\r\n\r\n  private rangeOverlapsLineString(range: Range3d) {\r\n    let inside = false;\r\n    const clipper = ConvexClipPlaneSet.createRange3dPlanes(range, true, true, true, true, false, false);\r\n    if (this._options.transform)\r\n      clipper.transformInPlace(this._options.transform);\r\n\r\n    for (let i = 0; i < this._points.length - 1 && !inside; i++)\r\n      inside = clipper.announceClippedSegmentIntervals(0, 1, this._points.getPoint3dAtUncheckedPointIndex(i), this._points.getPoint3dAtUncheckedPointIndex(i + 1));\r\n\r\n    return inside;\r\n  }\r\n}\r\n\r\nclass TerrainDraper implements TileUser {\r\n  public readonly tileUserId: number;\r\n\r\n  public constructor(public readonly viewport: Viewport, public readonly treeRef: GeometryTileTreeReference) {\r\n    this.tileUserId = TileUser.generateId();\r\n    IModelApp.tileAdmin.registerUser(this);\r\n  }\r\n\r\n  public dispose(): void {\r\n    IModelApp.tileAdmin.forgetUser(this);\r\n  }\r\n\r\n  public get iModel() { return this.viewport.iModel; }\r\n\r\n  public onRequestStateChanged() {\r\n    this.viewport.invalidateDecorations();\r\n  }\r\n\r\n  public discloseTileTrees(trees: DisclosedTileTreeSet) {\r\n    trees.disclose(this.treeRef);\r\n  }\r\n\r\n  public drapeLineString(outStrings: CurvePrimitive[], inPoints: GrowableXYZArray, tolerance: number, maxDistance = 1.0E5): \"loading\" | \"complete\" {\r\n    const tree = this.treeRef.treeOwner.load();\r\n    if (!tree)\r\n      return \"loading\";\r\n\r\n    const range = Range3d.createNull();\r\n    range.extendArray(inPoints);\r\n    range.extendZOnly(-maxDistance);  // Expand - but not so much that we get opposite side of globe.\r\n    range.extendZOnly(maxDistance);\r\n\r\n    const collector = new DrapeLineStringCollector(this, tolerance, range, tree.iModelTransform, inPoints);\r\n    this.treeRef.collectTileGeometry(collector);\r\n    collector.requestMissingTiles();\r\n\r\n    for (const polyface of collector.polyfaces)\r\n      outStrings.push(...PolyfaceQuery.sweepLineStringToFacets(inPoints, polyface,\r\n        SweepLineStringToFacetsOptions.create(Vector3d.unitZ(), undefined, true, true, true, true)));\r\n\r\n    return collector.isAllGeometryLoaded ? \"complete\" : \"loading\";\r\n  }\r\n}\r\n\r\n/** Demonstrates draping line strings on terrain meshes.  The terrain can be defined by map terrain (from Cesium World Terrain) or a reality model.\r\n */\r\nexport class TerrainDrapeTool extends PrimitiveTool {\r\n  private _drapePoints = new GrowableXYZArray();\r\n  private _drapedStrings?: LineString3d[];\r\n  private _motionPoint?: Point3d;\r\n  private _draper?: TerrainDraper;\r\n  public static override toolId = \"TerrainDrape\";\r\n\r\n  public override requireWriteableTarget(): boolean {\r\n    return false;\r\n  }\r\n\r\n  public override async onPostInstall() {\r\n    await super.onPostInstall();\r\n    this.setupAndPromptForNextAction();\r\n  }\r\n\r\n  public override async onCleanup() {\r\n    this.disposeDraper();\r\n  }\r\n\r\n  private disposeDraper(): void {\r\n    this._draper?.dispose();\r\n    this._draper = undefined;\r\n  }\r\n\r\n  public override async onUnsuspend(): Promise<void> {\r\n    this.showPrompt();\r\n  }\r\n\r\n  public createDecorations(context: DecorateContext, _suspend: boolean): void {\r\n    if (!this._draper)\r\n      return;\r\n\r\n    if (this._drapePoints.length > 1) {\r\n      const builder = context.createGraphicBuilder(GraphicType.WorldDecoration);\r\n      builder.setSymbology(ColorDef.red, ColorDef.red, 5);\r\n\r\n      let loading = false;\r\n      if (!this._drapedStrings) {\r\n        this._drapedStrings = [];\r\n        const drapeRange = Range3d.createNull();\r\n        drapeRange.extendArray(this._drapePoints);\r\n\r\n        const tolerance = drapeRange.diagonal().magnitude() / 5000;\r\n        loading = \"loading\" === this._draper.drapeLineString(this._drapedStrings, this._drapePoints, tolerance);\r\n      }\r\n\r\n      for (const lineString of this._drapedStrings)\r\n        builder.addLineString(lineString.points);\r\n\r\n      if (loading)\r\n        this._drapedStrings = undefined;\r\n\r\n      context.addDecorationFromBuilder(builder);\r\n    }\r\n\r\n    if (this._motionPoint) {\r\n      const builder = context.createGraphicBuilder(GraphicType.WorldOverlay);\r\n      builder.setSymbology(ColorDef.white, ColorDef.white, 1, LinePixels.Code0);\r\n      builder.addLineString([this._drapePoints.getPoint3dAtUncheckedPointIndex(this._drapePoints.length - 1), this._motionPoint]);\r\n      context.addDecorationFromBuilder(builder);\r\n    }\r\n  }\r\n\r\n  public override decorate(context: DecorateContext): void {\r\n    this.createDecorations(context, false);\r\n  }\r\n\r\n  public override decorateSuspended(context: DecorateContext): void {\r\n    this.createDecorations(context, true);\r\n  }\r\n\r\n  private setupAndPromptForNextAction(): void {\r\n    this.initLocateElements(undefined === this._draper);\r\n    IModelApp.locateManager.options.allowDecorations = true;    // So we can select \"contextual\" reality models.\r\n    this.showPrompt();\r\n  }\r\n\r\n  private showPrompt(): void {\r\n    IModelApp.notifications.outputPromptByKey(`SVTTools:tools.TerrainDrape.Prompts.${undefined === this._draper ? \"SelectDrapeRealityModel\" : \"EnterDrapePoint\"}`);\r\n  }\r\n\r\n  private getGeometryTreeRef(vp: Viewport, modelId: string): GeometryTileTreeReference | undefined {\r\n    let treeRef: GeometryTileTreeReference | undefined;\r\n    vp.forEachTileTreeRef((ref) => {\r\n      if (!treeRef) {\r\n        const tree = ref.treeOwner.load();\r\n        if (tree?.modelId === modelId)\r\n          treeRef = ref.createGeometryTreeReference();\r\n      }\r\n    });\r\n\r\n    return treeRef;\r\n  }\r\n\r\n  public override async filterHit(hit: HitDetail, _out?: LocateResponse): Promise<LocateFilterStatus> {\r\n    if (undefined !== this._draper)\r\n      return LocateFilterStatus.Accept;\r\n\r\n    if (!hit.modelId)\r\n      return LocateFilterStatus.Reject;\r\n\r\n    return this.getGeometryTreeRef(hit.viewport, hit.modelId) ? LocateFilterStatus.Accept : LocateFilterStatus.Reject;\r\n  }\r\n\r\n  public override async onMouseMotion(ev: BeButtonEvent): Promise<void> {\r\n    this._motionPoint = ev.point;\r\n    if (ev.viewport)\r\n      ev.viewport.invalidateDecorations();\r\n  }\r\n\r\n  public override async onResetButtonUp(ev: BeButtonEvent): Promise<EventHandled> {\r\n    this._drapedStrings = undefined;\r\n    if (this._drapePoints.length)\r\n      this._drapePoints.pop();\r\n    else\r\n      this.disposeDraper();\r\n\r\n    if (ev.viewport)\r\n      ev.viewport.invalidateDecorations();\r\n\r\n    this.setupAndPromptForNextAction();\r\n    return EventHandled.No;\r\n  }\r\n\r\n  public override async onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled> {\r\n    this._motionPoint = undefined;\r\n    const hit = await IModelApp.locateManager.doLocate(new LocateResponse(), true, ev.point, ev.viewport, ev.inputSource);\r\n    if (undefined === this._draper) {\r\n      if (hit?.modelId) {\r\n        this._drapePoints.push(hit.hitPoint);\r\n        const drapeTreeRef = this.getGeometryTreeRef(hit.viewport, hit.modelId);\r\n        if (drapeTreeRef)\r\n          this._draper = new TerrainDraper(hit.viewport, drapeTreeRef);\r\n      }\r\n    } else {\r\n      this._drapePoints.push(hit ? hit.hitPoint : ev.point);\r\n    }\r\n\r\n    this._drapedStrings = undefined;\r\n    this.setupAndPromptForNextAction();\r\n    return EventHandled.No;\r\n  }\r\n\r\n  public override async onRestartTool(): Promise<void> {\r\n    const tool = new TerrainDrapeTool();\r\n    if (!await tool.run())\r\n      await this.exitTool();\r\n  }\r\n\r\n  public override async parseAndRun(..._args: string[]): Promise<boolean> {\r\n    return this.run();\r\n  }\r\n}\r\n"
        ],
        "mappings": "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",
        "names": []
      }
    }
  ]
}
