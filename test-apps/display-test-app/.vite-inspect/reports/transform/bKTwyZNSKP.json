{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/common/ViewRect.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Views\n */\n/** A rectangle in unsigned integer view coordinates with (0,0) corresponding to the top-left corner of the view.\n * Increasing **x** moves from left to right, and increasing **y** moves from top to bottom.\n * [[left]], [[top]], [[right]], and [[bottom]] are required to be non-negative integers; any negative inputs are treated as\n * zero and any non-integer inputs are rounded down to the nearest integer.\n * @public\n * @extensions\n */\nexport class ViewRect {\n    _set(key, value) {\n        this[key] = Math.max(0, Math.floor(value));\n    }\n    /** Construct a new ViewRect. */\n    constructor(left = 0, top = 0, right = 0, bottom = 0) { this.init(left, top, right, bottom); }\n    /** The leftmost side of this ViewRect. */\n    get left() { return this._left; }\n    set left(val) { this._set(\"_left\", val); }\n    /** The topmost side of this ViewRect. */\n    get top() { return this._top; }\n    set top(val) { this._set(\"_top\", val); }\n    /** The rightmost side of this ViewRect. */\n    get right() { return this._right; }\n    set right(val) { this._set(\"_right\", val); }\n    /** The bottommost side of this ViewRect. */\n    get bottom() { return this._bottom; }\n    set bottom(val) { this._set(\"_bottom\", val); }\n    /** True if this ViewRect has an area <= 0. */\n    get isNull() { return this.right <= this.left || this.bottom <= this.top; }\n    /** True if `!isNull` */\n    get isValid() { return !this.isNull; }\n    /** The width (right-left) of this ViewRect. */\n    get width() { return this.right - this.left; }\n    set width(width) { this.right = this.left + width; }\n    /** The height (bottom-top) of this ViewRect. */\n    get height() { return this.bottom - this.top; }\n    set height(height) { this.bottom = this.top + height; }\n    /** The aspect ratio (width/height) of this ViewRect. */\n    get aspect() { return this.isNull ? 1.0 : this.width / this.height; }\n    /** The area (width*height) of this ViewRect. */\n    get area() { return this.isNull ? 0 : this.width * this.height; }\n    /** Initialize this ViewRect from its left/top/right/bottom parameters. */\n    init(left, top, right, bottom) {\n        this.left = left;\n        this.bottom = bottom, this.right = right;\n        this.top = top;\n    }\n    /** Initialize this ViewRect from two points.\n     * @param topLeft The top-left corner.\n     * @param bottomRight The bottom-right corner.\n     */\n    initFromPoints(topLeft, bottomRight) { this.init(topLeft.x, topLeft.y, bottomRight.x, bottomRight.y); }\n    /** Initialize this ViewRect from a range.\n     * @param input The Range to use. `input.low` defines the top-left and `input.high` defines the bottom-right.\n     */\n    initFromRange(input) { this.initFromPoints(input.low, input.high); }\n    /** Return true is this ViewRect is exactly equal to another ViewRect.\n     * @param other The other ViewRect to compare\n     */\n    equals(other) { return this.left === other.left && this.right === other.right && this.bottom === other.bottom && this.top === other.top; }\n    /** Initialize this ViewRect from another ViewRect. */\n    setFrom(other) { this.init(other.left, other.top, other.right, other.bottom); }\n    /** Duplicate this ViewRect.\n     * @param result Optional ViewRect for result. If undefined, a new ViewRect is created.\n     */\n    clone(result) {\n        if (undefined !== result) {\n            result.setFrom(this);\n            return result;\n        }\n        return new ViewRect(this.left, this.top, this.right, this.bottom);\n    }\n    extend(other) {\n        if (this.left > other.left)\n            this.left = other.left;\n        if (this.top > other.top)\n            this.top = other.top;\n        if (this.right < other.right)\n            this.right = other.right;\n        if (this.bottom < other.bottom)\n            this.bottom = other.bottom;\n    }\n    /** Inset this ViewRect by values in the x and y directions. Positive values make the ViewRect smaller, and negative values will make it larger.\n     * @param deltaX The distance to inset the ViewRect in the x direction.\n     * @param deltaY The distance to inset the ViewRect in the y direction.\n     */\n    inset(deltaX, deltaY) {\n        deltaX = Math.floor(deltaX);\n        deltaY = Math.floor(deltaY);\n        if (this.width - 2 * deltaX <= 0 || this.height - 2 * deltaY <= 0) {\n            this.init(0, 0, 0, 0);\n            return;\n        }\n        this._left += deltaX;\n        this._right -= deltaX;\n        this._top += deltaY;\n        this._bottom -= deltaY;\n    }\n    /** Inset this ViewRect by the same value in all directions.\n     * @param offset The distance to inset this ViewRect. Positive values will make this ViewRect smaller and negative values will make it larger.\n     * @note The inset operation can cause a previously valid ViewRect to become invalid.\n     */\n    insetUniform(offset) { this.inset(offset, offset); }\n    /** Scale this ViewRect about its center by the supplied scale factors. */\n    scaleAboutCenter(xScale, yScale) {\n        const w = this.width;\n        const h = this.height;\n        const xDelta = (w - (w * xScale)) * 0.5;\n        const yDelta = (h - (h * yScale)) * 0.5;\n        this.inset(xDelta, yDelta);\n    }\n    /** Inset this ViewRect by a percentage of its current width.\n     * @param percent The percentage of this ViewRect's width to inset in all directions.\n     * @note The ViewRect will become smaller (or larger, if percent is negative) by `percent * width * 2` in each direction, since each side is moved by that distance.\n     * @see [[inset]]\n     */\n    insetByPercent(percent) { this.insetUniform(this.width * percent); }\n    /** Determine if this ViewRect is entirely contained within the bounds of another ViewRect. */\n    isContained(other) { return this.left >= other.left && this.right <= other.right && this.bottom <= other.bottom && this.top >= other.top; }\n    /** Return true if the supplied point is contained in this ViewRect.\n     * @param point The point to test.\n     * @note if the point is exactly on the left or top edges, this method returns true. If the point is exactly on the right or bottom edge, it returns false.\n     */\n    containsPoint(point) { return point.x >= this.left && point.x < this.right && point.y >= this.top && point.y < this.bottom; }\n    /** Determine whether this ViewRect overlaps another. */\n    overlaps(other) { return this.left <= other.right && this.top <= other.bottom && this.right >= other.left && this.bottom >= other.top; }\n    /** Return a ViewRect that is the overlap (intersection) of this ViewRect and another ViewRect.\n     * If the two ViewRects are equal, their value is the result. Otherwise, the result will always be smaller than either of them.\n     */\n    computeOverlap(other, out) {\n        const maxOrgX = Math.max(this.left, other.left);\n        const maxOrgY = Math.max(this.top, other.top);\n        const minCrnX = Math.min(this.right, other.right);\n        const minCrnY = Math.min(this.bottom, other.bottom);\n        if (maxOrgX > minCrnX || maxOrgY > minCrnY)\n            return undefined;\n        const result = undefined !== out ? out : new ViewRect();\n        result.left = maxOrgX;\n        result.right = minCrnX;\n        result.top = maxOrgY;\n        result.bottom = minCrnY;\n        return result;\n    }\n}\n//# sourceMappingURL=ViewRect.js.map",
      "start": 1693508119104,
      "end": 1693508119323,
      "sourcemaps": null
    }
  ]
}
