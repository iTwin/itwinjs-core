{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/ScreenSpaceEffect.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { assert, dispose } from \"@itwin/core-bentley\";\nimport { UniformType, VaryingType, } from \"../ScreenSpaceEffectBuilder\";\nimport { RenderState } from \"./RenderState\";\nimport { SingleTexturedViewportQuadGeometry, ViewportQuadGeometry } from \"./CachedGeometry\";\nimport { FrameBuffer } from \"./FrameBuffer\";\nimport { getDrawParams } from \"./ScratchDrawParams\";\nimport { SingularTechnique } from \"./Technique\";\nimport { System } from \"./System\";\nimport { createScreenSpaceEffectProgramBuilder } from \"./glsl/ScreenSpaceEffect\";\nfunction getUniformVariableType(type) {\n    switch (type) {\n        case UniformType.Bool: return 0 /* VariableType.Boolean */;\n        case UniformType.Int: return 1 /* VariableType.Int */;\n        case UniformType.Float: return 2 /* VariableType.Float */;\n        case UniformType.Vec2: return 3 /* VariableType.Vec2 */;\n        case UniformType.Vec3: return 4 /* VariableType.Vec3 */;\n        case UniformType.Vec4: return 5 /* VariableType.Vec4 */;\n    }\n}\nfunction getVaryingVariableType(type) {\n    switch (type) {\n        case VaryingType.Float: return 2 /* VariableType.Float */;\n        case VaryingType.Vec2: return 3 /* VariableType.Vec2 */;\n        case VaryingType.Vec3: return 4 /* VariableType.Vec3 */;\n        case VaryingType.Vec4: return 5 /* VariableType.Vec4 */;\n    }\n}\nclass Builder {\n    constructor(params) {\n        this._name = params.name;\n        this._builder = createScreenSpaceEffectProgramBuilder(params);\n        this._builder.setDebugDescription(`Screen-space: ${this._name}`);\n        this._shiftsPixels = undefined !== params.source.sampleSourcePixel;\n    }\n    get isWebGL2() {\n        return true;\n    }\n    addUniform(params) {\n        const name = params.name;\n        const type = getUniformVariableType(params.type);\n        const bind = params.bind;\n        this._builder.addUniform(name, type, (prog) => {\n            prog.addProgramUniform(name, (uniform, progParams) => {\n                bind(uniform, progParams.target.screenSpaceEffectContext);\n            });\n        });\n    }\n    addUniformArray(params) {\n        const { name, bind, length } = { ...params };\n        const type = getUniformVariableType(params.type);\n        this._builder.addUniformArray(name, type, length, (prog) => {\n            prog.addProgramUniform(name, (uniform, progParams) => {\n                bind(uniform, progParams.target.screenSpaceEffectContext);\n            });\n        });\n    }\n    addVarying(name, type) {\n        this._builder.addVarying(name, getVaryingVariableType(type));\n    }\n    finish() {\n        const program = this._builder.buildProgram(System.instance.context);\n        // NB: compile() will throw with WebGL error log if compile/link fails.\n        if (0 /* CompileStatus.Success */ !== program.compile())\n            throw new Error(`Failed to produce shader program for screen-space effect \"${this._name}\"`);\n        const technique = new SingularTechnique(program);\n        const techniqueId = System.instance.techniques.addDynamicTechnique(technique, this._name);\n        const effect = new ScreenSpaceEffect(techniqueId, this._name, this._shiftsPixels, this.shouldApply);\n        System.instance.screenSpaceEffects.add(effect);\n    }\n}\nclass ScreenSpaceEffect {\n    constructor(techniqueId, name, shiftsPixels, shouldApply) {\n        this.techniqueId = techniqueId;\n        this.name = name;\n        this._shouldApply = shouldApply;\n        this._shiftsPixels = shiftsPixels;\n    }\n    shouldApply(target) {\n        // Effects only apply during readPixels() if they move pixels around (we need to move pixels in the pick buffers correspondingly).\n        if (target.isReadPixelsInProgress && !this._shiftsPixels)\n            return false;\n        return undefined === this._shouldApply || this._shouldApply(target.screenSpaceEffectContext);\n    }\n}\nclass ScreenSpaceGeometry extends ViewportQuadGeometry {\n    setTechniqueId(id) {\n        this._techniqueId = id;\n    }\n}\n/** @internal */\nexport class ScreenSpaceEffects {\n    constructor() {\n        this._effects = new Map();\n        this._workingArray = [];\n        // We will change the geometry's TechniqueId before applying each technique.\n        const effectGeometry = ScreenSpaceGeometry.create(-1 /* TechniqueId.Invalid */);\n        assert(effectGeometry instanceof ScreenSpaceGeometry);\n        this._effectGeometry = effectGeometry;\n        // NB: We'll replace the texture each time we draw.\n        const copyGeometry = SingleTexturedViewportQuadGeometry.createGeometry(System.instance.lineCodeTexture.getHandle(), 18 /* TechniqueId.CopyColor */);\n        assert(undefined !== copyGeometry);\n        this._copyGeometry = copyGeometry;\n    }\n    dispose() {\n        dispose(this._effectGeometry);\n        dispose(this._copyGeometry);\n    }\n    add(effect) {\n        if (undefined !== this._effects.get(effect.name))\n            throw new Error(`Screen-space effect \"${effect.name}\" is already registered.`);\n        this._effects.set(effect.name, effect);\n    }\n    /** Return true if any effects should be applied to this Target. */\n    shouldApply(target) {\n        return this.getApplicableEffects(target).length > 0;\n    }\n    getApplicableEffects(target) {\n        const effects = this._workingArray;\n        effects.length = 0;\n        const names = target.screenSpaceEffects;\n        for (const name of names) {\n            const effect = this._effects.get(name);\n            if (effect && effect.shouldApply(target))\n                effects.push(effect);\n        }\n        return effects;\n    }\n    /** Apply screen-space effects to the Target's rendered image. */\n    apply(target) {\n        if (0 === this._effects.size)\n            return;\n        const effects = this.getApplicableEffects(target);\n        if (0 === effects.length)\n            return;\n        if (target.isReadPixelsInProgress) {\n            this.applyForReadPixels(effects, target);\n            return;\n        }\n        const system = System.instance;\n        system.applyRenderState(RenderState.defaults);\n        const copyFbo = target.compositor.screenSpaceEffectFbo;\n        for (const effect of effects) {\n            // Copy the rendered image to texture as input to the effect shader.\n            this._copyGeometry.texture = system.frameBufferStack.currentColorBuffer.getHandle();\n            system.frameBufferStack.execute(copyFbo, true, false, () => {\n                const copyParams = getDrawParams(target, this._copyGeometry);\n                system.techniques.draw(copyParams);\n            });\n            // Run the effect shader with a copy of the current image as input.\n            this._effectGeometry.setTechniqueId(effect.techniqueId);\n            const params = getDrawParams(target, this._effectGeometry);\n            system.techniques.draw(params);\n        }\n    }\n    applyForReadPixels(effects, target) {\n        const system = System.instance;\n        system.applyRenderState(RenderState.defaults);\n        // ###TODO: We could use MRT if available here rather than two passes.\n        const copyFbo = target.compositor.screenSpaceEffectFbo;\n        for (const effect of effects) {\n            this._effectGeometry.setTechniqueId(effect.techniqueId);\n            for (let i = 0; i <= 1; i++) {\n                // Copy the pick buffer as input to the effect shader.\n                const buffer = 0 === i ? target.compositor.featureIds : target.compositor.depthAndOrder;\n                this._copyGeometry.texture = buffer.getHandle();\n                system.frameBufferStack.execute(copyFbo, true, false, () => {\n                    const copyParams = getDrawParams(target, this._copyGeometry);\n                    system.techniques.draw(copyParams);\n                });\n                // Run the effect shader with a copy of the current pick buffer to output to pick buffer.\n                // ###TODO: Avoid frequent framebuffer allocation.\n                const effectFbo = FrameBuffer.create([buffer]);\n                assert(undefined !== effectFbo);\n                system.frameBufferStack.execute(effectFbo, true, false, () => {\n                    const effectParams = getDrawParams(target, this._effectGeometry);\n                    system.techniques.draw(effectParams);\n                });\n                effectFbo.dispose();\n            }\n        }\n    }\n}\nexport function createScreenSpaceEffectBuilder(params) {\n    return new Builder(params);\n}\n//# sourceMappingURL=ScreenSpaceEffect.js.map",
      "start": 1693508124546,
      "end": 1693508124655,
      "sourcemaps": null
    }
  ]
}
