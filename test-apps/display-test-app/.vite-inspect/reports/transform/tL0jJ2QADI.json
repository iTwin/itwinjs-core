{
  "resolvedId": "D:/hub2023A/itwinjs-core/common/temp/node_modules/.pnpm/@svgdotjs+svg.js@3.0.13/node_modules/@svgdotjs/svg.js/src/animation/Runner.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import { Controller, Ease, Stepper } from './Controller.js'\nimport { extend, register } from '../utils/adopter.js'\nimport { from, to } from '../modules/core/gradiented.js'\nimport { getOrigin } from '../utils/utils.js'\nimport { noop, timeline } from '../modules/core/defaults.js'\nimport { registerMethods } from '../utils/methods.js'\nimport { rx, ry } from '../modules/core/circled.js'\nimport Animator from './Animator.js'\nimport Box from '../types/Box.js'\nimport EventTarget from '../types/EventTarget.js'\nimport Matrix from '../types/Matrix.js'\nimport Morphable, { TransformBag } from './Morphable.js'\nimport Point from '../types/Point.js'\nimport SVGNumber from '../types/SVGNumber.js'\nimport Timeline from './Timeline.js'\n\r\nexport default class Runner extends EventTarget {\r\n  constructor (options) {\r\n    super()\r\n\r\n    // Store a unique id on the runner, so that we can identify it later\r\n    this.id = Runner.id++\r\n\r\n    // Ensure a default value\r\n    options = options == null\r\n      ? timeline.duration\r\n      : options\r\n\r\n    // Ensure that we get a controller\r\n    options = typeof options === 'function'\r\n      ? new Controller(options)\r\n      : options\r\n\r\n    // Declare all of the variables\r\n    this._element = null\r\n    this._timeline = null\r\n    this.done = false\r\n    this._queue = []\r\n\r\n    // Work out the stepper and the duration\r\n    this._duration = typeof options === 'number' && options\r\n    this._isDeclarative = options instanceof Controller\r\n    this._stepper = this._isDeclarative ? options : new Ease()\r\n\r\n    // We copy the current values from the timeline because they can change\r\n    this._history = {}\r\n\r\n    // Store the state of the runner\r\n    this.enabled = true\r\n    this._time = 0\r\n    this._lastTime = 0\r\n\r\n    // At creation, the runner is in reseted state\r\n    this._reseted = true\r\n\r\n    // Save transforms applied to this runner\r\n    this.transforms = new Matrix()\r\n    this.transformId = 1\r\n\r\n    // Looping variables\r\n    this._haveReversed = false\r\n    this._reverse = false\r\n    this._loopsDone = 0\r\n    this._swing = false\r\n    this._wait = 0\r\n    this._times = 1\r\n\r\n    this._frameId = null\r\n\r\n    // Stores how long a runner is stored after beeing done\r\n    this._persist = this._isDeclarative ? true : null\r\n  }\r\n\r\n  /*\r\n  Runner Definitions\r\n  ==================\r\n  These methods help us define the runtime behaviour of the Runner or they\r\n  help us make new runners from the current runner\r\n  */\r\n\r\n  element (element) {\r\n    if (element == null) return this._element\r\n    this._element = element\r\n    element._prepareRunner()\r\n    return this\r\n  }\r\n\r\n  timeline (timeline) {\r\n    // check explicitly for undefined so we can set the timeline to null\r\n    if (typeof timeline === 'undefined') return this._timeline\r\n    this._timeline = timeline\r\n    return this\r\n  }\r\n\r\n  animate (duration, delay, when) {\r\n    var o = Runner.sanitise(duration, delay, when)\r\n    var runner = new Runner(o.duration)\r\n    if (this._timeline) runner.timeline(this._timeline)\r\n    if (this._element) runner.element(this._element)\r\n    return runner.loop(o).schedule(delay, when)\r\n  }\r\n\r\n  schedule (timeline, delay, when) {\r\n    // The user doesn't need to pass a timeline if we already have one\r\n    if (!(timeline instanceof Timeline)) {\r\n      when = delay\r\n      delay = timeline\r\n      timeline = this.timeline()\r\n    }\r\n\r\n    // If there is no timeline, yell at the user...\r\n    if (!timeline) {\r\n      throw Error('Runner cannot be scheduled without timeline')\r\n    }\r\n\r\n    // Schedule the runner on the timeline provided\r\n    timeline.schedule(this, delay, when)\r\n    return this\r\n  }\r\n\r\n  unschedule () {\r\n    var timeline = this.timeline()\r\n    timeline && timeline.unschedule(this)\r\n    return this\r\n  }\r\n\r\n  loop (times, swing, wait) {\r\n    // Deal with the user passing in an object\r\n    if (typeof times === 'object') {\r\n      swing = times.swing\r\n      wait = times.wait\r\n      times = times.times\r\n    }\r\n\r\n    // Sanitise the values and store them\r\n    this._times = times || Infinity\r\n    this._swing = swing || false\r\n    this._wait = wait || 0\r\n\r\n    // Allow true to be passed\r\n    if (this._times === true) { this._times = Infinity }\r\n\r\n    return this\r\n  }\r\n\r\n  delay (delay) {\r\n    return this.animate(0, delay)\r\n  }\r\n\r\n  /*\r\n  Basic Functionality\r\n  ===================\r\n  These methods allow us to attach basic functions to the runner directly\r\n  */\r\n\r\n  queue (initFn, runFn, retargetFn, isTransform) {\r\n    this._queue.push({\r\n      initialiser: initFn || noop,\r\n      runner: runFn || noop,\r\n      retarget: retargetFn,\r\n      isTransform: isTransform,\r\n      initialised: false,\r\n      finished: false\r\n    })\r\n    var timeline = this.timeline()\r\n    timeline && this.timeline()._continue()\r\n    return this\r\n  }\r\n\r\n  during (fn) {\r\n    return this.queue(null, fn)\r\n  }\r\n\r\n  after (fn) {\r\n    return this.on('finished', fn)\r\n  }\r\n\r\n  /*\r\n  Runner animation methods\r\n  ========================\r\n  Control how the animation plays\r\n  */\r\n\r\n  time (time) {\r\n    if (time == null) {\r\n      return this._time\r\n    }\r\n    let dt = time - this._time\r\n    this.step(dt)\r\n    return this\r\n  }\r\n\r\n  duration () {\r\n    return this._times * (this._wait + this._duration) - this._wait\r\n  }\r\n\r\n  loops (p) {\r\n    var loopDuration = this._duration + this._wait\r\n    if (p == null) {\r\n      var loopsDone = Math.floor(this._time / loopDuration)\r\n      var relativeTime = (this._time - loopsDone * loopDuration)\r\n      var position = relativeTime / this._duration\r\n      return Math.min(loopsDone + position, this._times)\r\n    }\r\n    var whole = Math.floor(p)\r\n    var partial = p % 1\r\n    var time = loopDuration * whole + this._duration * partial\r\n    return this.time(time)\r\n  }\r\n\r\n  persist (dtOrForever) {\r\n    if (dtOrForever == null) return this._persist\r\n    this._persist = dtOrForever\r\n    return this\r\n  }\r\n\r\n  position (p) {\r\n    // Get all of the variables we need\r\n    var x = this._time\r\n    var d = this._duration\r\n    var w = this._wait\r\n    var t = this._times\r\n    var s = this._swing\r\n    var r = this._reverse\r\n    var position\r\n\r\n    if (p == null) {\r\n      /*\r\n      This function converts a time to a position in the range [0, 1]\r\n      The full explanation can be found in this desmos demonstration\r\n        https://www.desmos.com/calculator/u4fbavgche\r\n      The logic is slightly simplified here because we can use booleans\r\n      */\r\n\r\n      // Figure out the value without thinking about the start or end time\r\n      const f = function (x) {\r\n        var swinging = s * Math.floor(x % (2 * (w + d)) / (w + d))\r\n        var backwards = (swinging && !r) || (!swinging && r)\r\n        var uncliped = Math.pow(-1, backwards) * (x % (w + d)) / d + backwards\r\n        var clipped = Math.max(Math.min(uncliped, 1), 0)\r\n        return clipped\r\n      }\r\n\r\n      // Figure out the value by incorporating the start time\r\n      var endTime = t * (w + d) - w\r\n      position = x <= 0 ? Math.round(f(1e-5))\r\n        : x < endTime ? f(x)\r\n        : Math.round(f(endTime - 1e-5))\r\n      return position\r\n    }\r\n\r\n    // Work out the loops done and add the position to the loops done\r\n    var loopsDone = Math.floor(this.loops())\r\n    var swingForward = s && (loopsDone % 2 === 0)\r\n    var forwards = (swingForward && !r) || (r && swingForward)\r\n    position = loopsDone + (forwards ? p : 1 - p)\r\n    return this.loops(position)\r\n  }\r\n\r\n  progress (p) {\r\n    if (p == null) {\r\n      return Math.min(1, this._time / this.duration())\r\n    }\r\n    return this.time(p * this.duration())\r\n  }\r\n\r\n  step (dt) {\r\n    // If we are inactive, this stepper just gets skipped\r\n    if (!this.enabled) return this\r\n\r\n    // Update the time and get the new position\r\n    dt = dt == null ? 16 : dt\r\n    this._time += dt\r\n    var position = this.position()\r\n\r\n    // Figure out if we need to run the stepper in this frame\r\n    var running = this._lastPosition !== position && this._time >= 0\r\n    this._lastPosition = position\r\n\r\n    // Figure out if we just started\r\n    var duration = this.duration()\r\n    var justStarted = this._lastTime <= 0 && this._time > 0\r\n    var justFinished = this._lastTime < duration && this._time >= duration\r\n\r\n    this._lastTime = this._time\r\n    if (justStarted) {\r\n      this.fire('start', this)\r\n    }\r\n\r\n    // Work out if the runner is finished set the done flag here so animations\r\n    // know, that they are running in the last step (this is good for\r\n    // transformations which can be merged)\r\n    var declarative = this._isDeclarative\r\n    this.done = !declarative && !justFinished && this._time >= duration\r\n\r\n    // Runner is running. So its not in reseted state anymore\r\n    this._reseted = false\r\n\r\n    // Call initialise and the run function\r\n    if (running || declarative) {\r\n      this._initialise(running)\r\n\r\n      // clear the transforms on this runner so they dont get added again and again\r\n      this.transforms = new Matrix()\r\n      var converged = this._run(declarative ? dt : position)\r\n\r\n      this.fire('step', this)\r\n    }\r\n    // correct the done flag here\r\n    // declaritive animations itself know when they converged\r\n    this.done = this.done || (converged && declarative)\r\n    if (justFinished) {\r\n      this.fire('finished', this)\r\n    }\r\n    return this\r\n  }\r\n\r\n  reset () {\r\n    if (this._reseted) return this\r\n    this.time(0)\r\n    this._reseted = true\r\n    return this\r\n  }\r\n\r\n  finish () {\r\n    return this.step(Infinity)\r\n  }\r\n\r\n  reverse (reverse) {\r\n    this._reverse = reverse == null ? !this._reverse : reverse\r\n    return this\r\n  }\r\n\r\n  ease (fn) {\r\n    this._stepper = new Ease(fn)\r\n    return this\r\n  }\r\n\r\n  active (enabled) {\r\n    if (enabled == null) return this.enabled\r\n    this.enabled = enabled\r\n    return this\r\n  }\r\n\r\n  /*\r\n  Private Methods\r\n  ===============\r\n  Methods that shouldn't be used externally\r\n  */\r\n\r\n  // Save a morpher to the morpher list so that we can retarget it later\r\n  _rememberMorpher (method, morpher) {\r\n    this._history[method] = {\r\n      morpher: morpher,\r\n      caller: this._queue[this._queue.length - 1]\r\n    }\r\n\r\n    // We have to resume the timeline in case a controller\r\n    // is already done without beeing ever run\r\n    // This can happen when e.g. this is done:\r\n    //    anim = el.animate(new SVG.Spring)\r\n    // and later\r\n    //    anim.move(...)\r\n    if (this._isDeclarative) {\r\n      var timeline = this.timeline()\r\n      timeline && timeline.play()\r\n    }\r\n  }\r\n\r\n  // Try to set the target for a morpher if the morpher exists, otherwise\r\n  // do nothing and return false\r\n  _tryRetarget (method, target, extra) {\r\n    if (this._history[method]) {\r\n      // if the last method wasnt even initialised, throw it away\r\n      if (!this._history[method].caller.initialised) {\r\n        let index = this._queue.indexOf(this._history[method].caller)\r\n        this._queue.splice(index, 1)\r\n        return false\r\n      }\r\n\r\n      // for the case of transformations, we use the special retarget function\r\n      // which has access to the outer scope\r\n      if (this._history[method].caller.retarget) {\r\n        this._history[method].caller.retarget(target, extra)\r\n        // for everything else a simple morpher change is sufficient\r\n      } else {\r\n        this._history[method].morpher.to(target)\r\n      }\r\n\r\n      this._history[method].caller.finished = false\r\n      var timeline = this.timeline()\r\n      timeline && timeline.play()\r\n      return true\r\n    }\r\n    return false\r\n  }\r\n\r\n  // Run each initialise function in the runner if required\r\n  _initialise (running) {\r\n    // If we aren't running, we shouldn't initialise when not declarative\r\n    if (!running && !this._isDeclarative) return\r\n\r\n    // Loop through all of the initialisers\r\n    for (var i = 0, len = this._queue.length; i < len; ++i) {\r\n      // Get the current initialiser\r\n      var current = this._queue[i]\r\n\r\n      // Determine whether we need to initialise\r\n      var needsIt = this._isDeclarative || (!current.initialised && running)\r\n      running = !current.finished\r\n\r\n      // Call the initialiser if we need to\r\n      if (needsIt && running) {\r\n        current.initialiser.call(this)\r\n        current.initialised = true\r\n      }\r\n    }\r\n  }\r\n\r\n  // Run each run function for the position or dt given\r\n  _run (positionOrDt) {\r\n    // Run all of the _queue directly\r\n    var allfinished = true\r\n    for (var i = 0, len = this._queue.length; i < len; ++i) {\r\n      // Get the current function to run\r\n      var current = this._queue[i]\r\n\r\n      // Run the function if its not finished, we keep track of the finished\r\n      // flag for the sake of declarative _queue\r\n      var converged = current.runner.call(this, positionOrDt)\r\n      current.finished = current.finished || (converged === true)\r\n      allfinished = allfinished && current.finished\r\n    }\r\n\r\n    // We report when all of the constructors are finished\r\n    return allfinished\r\n  }\r\n\r\n  addTransform (transform, index) {\r\n    this.transforms.lmultiplyO(transform)\r\n    return this\r\n  }\r\n\r\n  clearTransform () {\r\n    this.transforms = new Matrix()\r\n    return this\r\n  }\r\n\r\n  // TODO: Keep track of all transformations so that deletion is faster\r\n  clearTransformsFromQueue () {\r\n    if (!this.done || !this._timeline || !this._timeline._runnerIds.includes(this.id)) {\r\n      this._queue = this._queue.filter((item) => {\r\n        return !item.isTransform\r\n      })\r\n    }\r\n  }\r\n\r\n  static sanitise (duration, delay, when) {\r\n    // Initialise the default parameters\r\n    var times = 1\r\n    var swing = false\r\n    var wait = 0\r\n    duration = duration || timeline.duration\r\n    delay = delay || timeline.delay\r\n    when = when || 'last'\r\n\r\n    // If we have an object, unpack the values\r\n    if (typeof duration === 'object' && !(duration instanceof Stepper)) {\r\n      delay = duration.delay || delay\r\n      when = duration.when || when\r\n      swing = duration.swing || swing\r\n      times = duration.times || times\r\n      wait = duration.wait || wait\r\n      duration = duration.duration || timeline.duration\r\n    }\r\n\r\n    return {\r\n      duration: duration,\r\n      delay: delay,\r\n      swing: swing,\r\n      times: times,\r\n      wait: wait,\r\n      when: when\r\n    }\r\n  }\r\n}\r\n\r\nRunner.id = 0\r\n\r\nclass FakeRunner {\r\n  constructor (transforms = new Matrix(), id = -1, done = true) {\r\n    this.transforms = transforms\r\n    this.id = id\r\n    this.done = done\r\n  }\r\n\r\n  clearTransformsFromQueue () { }\r\n}\r\n\r\nextend([ Runner, FakeRunner ], {\r\n  mergeWith (runner) {\r\n    return new FakeRunner(\r\n      runner.transforms.lmultiply(this.transforms),\r\n      runner.id\r\n    )\r\n  }\r\n})\r\n\r\n// FakeRunner.emptyRunner = new FakeRunner()\r\n\r\nconst lmultiply = (last, curr) => last.lmultiplyO(curr)\r\nconst getRunnerTransform = (runner) => runner.transforms\r\n\r\nfunction mergeTransforms () {\r\n  // Find the matrix to apply to the element and apply it\r\n  let runners = this._transformationRunners.runners\r\n  let netTransform = runners\r\n    .map(getRunnerTransform)\r\n    .reduce(lmultiply, new Matrix())\r\n\r\n  this.transform(netTransform)\r\n\r\n  this._transformationRunners.merge()\r\n\r\n  if (this._transformationRunners.length() === 1) {\r\n    this._frameId = null\r\n  }\r\n}\r\n\r\nclass RunnerArray {\r\n  constructor () {\r\n    this.runners = []\r\n    this.ids = []\r\n  }\r\n\r\n  add (runner) {\r\n    if (this.runners.includes(runner)) return\r\n    let id = runner.id + 1\r\n\r\n    this.runners.push(runner)\r\n    this.ids.push(id)\r\n\r\n    return this\r\n  }\r\n\r\n  getByID (id) {\r\n    return this.runners[this.ids.indexOf(id + 1)]\r\n  }\r\n\r\n  remove (id) {\r\n    let index = this.ids.indexOf(id + 1)\r\n    this.ids.splice(index, 1)\r\n    this.runners.splice(index, 1)\r\n    return this\r\n  }\r\n\r\n  merge () {\r\n    let lastRunner = null\r\n    this.runners.forEach((runner, i) => {\r\n\r\n      const condition = lastRunner\r\n        && runner.done && lastRunner.done\r\n        // don't merge runner when persisted on timeline\r\n        && (!runner._timeline || !runner._timeline._runnerIds.includes(runner.id))\r\n        && (!lastRunner._timeline || !lastRunner._timeline._runnerIds.includes(lastRunner.id))\r\n\r\n      if (condition) {\r\n        // the +1 happens in the function\r\n        this.remove(runner.id)\r\n        this.edit(lastRunner.id, runner.mergeWith(lastRunner))\r\n      }\r\n\r\n      lastRunner = runner\r\n    })\r\n\r\n    return this\r\n  }\r\n\r\n  edit (id, newRunner) {\r\n    let index = this.ids.indexOf(id + 1)\r\n    this.ids.splice(index, 1, id + 1)\r\n    this.runners.splice(index, 1, newRunner)\r\n    return this\r\n  }\r\n\r\n  length () {\r\n    return this.ids.length\r\n  }\r\n\r\n  clearBefore (id) {\r\n    let deleteCnt = this.ids.indexOf(id + 1) || 1\r\n    this.ids.splice(0, deleteCnt, 0)\r\n    this.runners.splice(0, deleteCnt, new FakeRunner())\r\n      .forEach((r) => r.clearTransformsFromQueue())\r\n    return this\r\n  }\r\n}\r\n\r\nregisterMethods({\r\n  Element: {\r\n    animate (duration, delay, when) {\r\n      var o = Runner.sanitise(duration, delay, when)\r\n      var timeline = this.timeline()\r\n      return new Runner(o.duration)\r\n        .loop(o)\r\n        .element(this)\r\n        .timeline(timeline.play())\r\n        .schedule(delay, when)\r\n    },\r\n\r\n    delay (by, when) {\r\n      return this.animate(0, by, when)\r\n    },\r\n\r\n    // this function searches for all runners on the element and deletes the ones\r\n    // which run before the current one. This is because absolute transformations\r\n    // overwfrite anything anyway so there is no need to waste time computing\r\n    // other runners\r\n    _clearTransformRunnersBefore (currentRunner) {\r\n      this._transformationRunners.clearBefore(currentRunner.id)\r\n    },\r\n\r\n    _currentTransform (current) {\r\n      return this._transformationRunners.runners\r\n        // we need the equal sign here to make sure, that also transformations\r\n        // on the same runner which execute before the current transformation are\r\n        // taken into account\r\n        .filter((runner) => runner.id <= current.id)\r\n        .map(getRunnerTransform)\r\n        .reduce(lmultiply, new Matrix())\r\n    },\r\n\r\n    _addRunner (runner) {\r\n      this._transformationRunners.add(runner)\r\n\r\n      // Make sure that the runner merge is executed at the very end of\r\n      // all Animator functions. Thats why we use immediate here to execute\r\n      // the merge right after all frames are run\r\n      Animator.cancelImmediate(this._frameId)\r\n      this._frameId = Animator.immediate(mergeTransforms.bind(this))\r\n    },\r\n\r\n    _prepareRunner () {\r\n      if (this._frameId == null) {\r\n        this._transformationRunners = new RunnerArray()\r\n          .add(new FakeRunner(new Matrix(this)))\r\n      }\r\n    }\r\n  }\r\n})\r\n\r\nextend(Runner, {\r\n  attr (a, v) {\r\n    return this.styleAttr('attr', a, v)\r\n  },\r\n\r\n  // Add animatable styles\r\n  css (s, v) {\r\n    return this.styleAttr('css', s, v)\r\n  },\r\n\r\n  styleAttr (type, name, val) {\r\n    // apply attributes individually\r\n    if (typeof name === 'object') {\r\n      for (var key in name) {\r\n        this.styleAttr(type, key, name[key])\r\n      }\r\n      return this\r\n    }\r\n\r\n    var morpher = new Morphable(this._stepper).to(val)\r\n\r\n    this.queue(function () {\r\n      morpher = morpher.from(this.element()[type](name))\r\n    }, function (pos) {\r\n      this.element()[type](name, morpher.at(pos))\r\n      return morpher.done()\r\n    })\r\n\r\n    return this\r\n  },\r\n\r\n  zoom (level, point) {\r\n    if (this._tryRetarget('zoom', to, point)) return this\r\n\r\n    var morpher = new Morphable(this._stepper).to(new SVGNumber(level))\r\n\r\n    this.queue(function () {\r\n      morpher = morpher.from(this.element().zoom())\r\n    }, function (pos) {\r\n      this.element().zoom(morpher.at(pos), point)\r\n      return morpher.done()\r\n    }, function (newLevel, newPoint) {\r\n      point = newPoint\r\n      morpher.to(newLevel)\r\n    })\r\n\r\n    this._rememberMorpher('zoom', morpher)\r\n    return this\r\n  },\r\n\r\n  /**\r\n   ** absolute transformations\r\n   **/\r\n\r\n  //\r\n  // M v -----|-----(D M v = F v)------|----->  T v\r\n  //\r\n  // 1. define the final state (T) and decompose it (once)\r\n  //    t = [tx, ty, the, lam, sy, sx]\r\n  // 2. on every frame: pull the current state of all previous transforms\r\n  //    (M - m can change)\r\n  //   and then write this as m = [tx0, ty0, the0, lam0, sy0, sx0]\r\n  // 3. Find the interpolated matrix F(pos) = m + pos * (t - m)\r\n  //   - Note F(0) = M\r\n  //   - Note F(1) = T\r\n  // 4. Now you get the delta matrix as a result: D = F * inv(M)\r\n\r\n  transform (transforms, relative, affine) {\r\n    // If we have a declarative function, we should retarget it if possible\r\n    relative = transforms.relative || relative\r\n    if (this._isDeclarative && !relative && this._tryRetarget('transform', transforms)) {\r\n      return this\r\n    }\r\n\r\n    // Parse the parameters\r\n    var isMatrix = Matrix.isMatrixLike(transforms)\r\n    affine = transforms.affine != null\r\n      ? transforms.affine\r\n      : (affine != null ? affine : !isMatrix)\r\n\r\n    // Create a morepher and set its type\r\n    const morpher = new Morphable(this._stepper)\r\n      .type(affine ? TransformBag : Matrix)\r\n\r\n    let origin\r\n    let element\r\n    let current\r\n    let currentAngle\r\n    let startTransform\r\n\r\n    function setup () {\r\n      // make sure element and origin is defined\r\n      element = element || this.element()\r\n      origin = origin || getOrigin(transforms, element)\r\n\r\n      startTransform = new Matrix(relative ? undefined : element)\r\n\r\n      // add the runner to the element so it can merge transformations\r\n      element._addRunner(this)\r\n\r\n      // Deactivate all transforms that have run so far if we are absolute\r\n      if (!relative) {\r\n        element._clearTransformRunnersBefore(this)\r\n      }\r\n    }\r\n\r\n    function run (pos) {\r\n      // clear all other transforms before this in case something is saved\r\n      // on this runner. We are absolute. We dont need these!\r\n      if (!relative) this.clearTransform()\r\n\r\n      let { x, y } = new Point(origin).transform(element._currentTransform(this))\r\n\r\n      let target = new Matrix({ ...transforms, origin: [ x, y ] })\r\n      let start = this._isDeclarative && current\r\n        ? current\r\n        : startTransform\r\n\r\n      if (affine) {\r\n        target = target.decompose(x, y)\r\n        start = start.decompose(x, y)\r\n\r\n        // Get the current and target angle as it was set\r\n        const rTarget = target.rotate\r\n        const rCurrent = start.rotate\r\n\r\n        // Figure out the shortest path to rotate directly\r\n        const possibilities = [ rTarget - 360, rTarget, rTarget + 360 ]\r\n        const distances = possibilities.map(a => Math.abs(a - rCurrent))\r\n        const shortest = Math.min(...distances)\r\n        const index = distances.indexOf(shortest)\r\n        target.rotate = possibilities[index]\r\n      }\r\n\r\n      if (relative) {\r\n        // we have to be careful here not to overwrite the rotation\r\n        // with the rotate method of Matrix\r\n        if (!isMatrix) {\r\n          target.rotate = transforms.rotate || 0\r\n        }\r\n        if (this._isDeclarative && currentAngle) {\r\n          start.rotate = currentAngle\r\n        }\r\n      }\r\n\r\n      morpher.from(start)\r\n      morpher.to(target)\r\n\r\n      let affineParameters = morpher.at(pos)\r\n      currentAngle = affineParameters.rotate\r\n      current = new Matrix(affineParameters)\r\n\r\n      this.addTransform(current)\r\n      element._addRunner(this)\r\n      return morpher.done()\r\n    }\r\n\r\n    function retarget (newTransforms) {\r\n      // only get a new origin if it changed since the last call\r\n      if (\r\n        (newTransforms.origin || 'center').toString()\r\n        !== (transforms.origin || 'center').toString()\r\n      ) {\r\n        origin = getOrigin(transforms, element)\r\n      }\r\n\r\n      // overwrite the old transformations with the new ones\r\n      transforms = { ...newTransforms, origin }\r\n    }\r\n\r\n    this.queue(setup, run, retarget, true)\r\n    this._isDeclarative && this._rememberMorpher('transform', morpher)\r\n    return this\r\n  },\r\n\r\n  // Animatable x-axis\r\n  x (x, relative) {\r\n    return this._queueNumber('x', x)\r\n  },\r\n\r\n  // Animatable y-axis\r\n  y (y) {\r\n    return this._queueNumber('y', y)\r\n  },\r\n\r\n  dx (x) {\r\n    return this._queueNumberDelta('x', x)\r\n  },\r\n\r\n  dy (y) {\r\n    return this._queueNumberDelta('y', y)\r\n  },\r\n\r\n  _queueNumberDelta (method, to) {\r\n    to = new SVGNumber(to)\r\n\r\n    // Try to change the target if we have this method already registerd\r\n    if (this._tryRetarget(method, to)) return this\r\n\r\n    // Make a morpher and queue the animation\r\n    var morpher = new Morphable(this._stepper).to(to)\r\n    var from = null\r\n    this.queue(function () {\r\n      from = this.element()[method]()\r\n      morpher.from(from)\r\n      morpher.to(from + to)\r\n    }, function (pos) {\r\n      this.element()[method](morpher.at(pos))\r\n      return morpher.done()\r\n    }, function (newTo) {\r\n      morpher.to(from + new SVGNumber(newTo))\r\n    })\r\n\r\n    // Register the morpher so that if it is changed again, we can retarget it\r\n    this._rememberMorpher(method, morpher)\r\n    return this\r\n  },\r\n\r\n  _queueObject (method, to) {\r\n    // Try to change the target if we have this method already registerd\r\n    if (this._tryRetarget(method, to)) return this\r\n\r\n    // Make a morpher and queue the animation\r\n    var morpher = new Morphable(this._stepper).to(to)\r\n    this.queue(function () {\r\n      morpher.from(this.element()[method]())\r\n    }, function (pos) {\r\n      this.element()[method](morpher.at(pos))\r\n      return morpher.done()\r\n    })\r\n\r\n    // Register the morpher so that if it is changed again, we can retarget it\r\n    this._rememberMorpher(method, morpher)\r\n    return this\r\n  },\r\n\r\n  _queueNumber (method, value) {\r\n    return this._queueObject(method, new SVGNumber(value))\r\n  },\r\n\r\n  // Animatable center x-axis\r\n  cx (x) {\r\n    return this._queueNumber('cx', x)\r\n  },\r\n\r\n  // Animatable center y-axis\r\n  cy (y) {\r\n    return this._queueNumber('cy', y)\r\n  },\r\n\r\n  // Add animatable move\r\n  move (x, y) {\r\n    return this.x(x).y(y)\r\n  },\r\n\r\n  // Add animatable center\r\n  center (x, y) {\r\n    return this.cx(x).cy(y)\r\n  },\r\n\r\n  // Add animatable size\r\n  size (width, height) {\r\n    // animate bbox based size for all other elements\r\n    var box\r\n\r\n    if (!width || !height) {\r\n      box = this._element.bbox()\r\n    }\r\n\r\n    if (!width) {\r\n      width = box.width / box.height * height\r\n    }\r\n\r\n    if (!height) {\r\n      height = box.height / box.width * width\r\n    }\r\n\r\n    return this\r\n      .width(width)\r\n      .height(height)\r\n  },\r\n\r\n  // Add animatable width\r\n  width (width) {\r\n    return this._queueNumber('width', width)\r\n  },\r\n\r\n  // Add animatable height\r\n  height (height) {\r\n    return this._queueNumber('height', height)\r\n  },\r\n\r\n  // Add animatable plot\r\n  plot (a, b, c, d) {\r\n    // Lines can be plotted with 4 arguments\r\n    if (arguments.length === 4) {\r\n      return this.plot([ a, b, c, d ])\r\n    }\r\n\r\n    if (this._tryRetarget('plot', a)) return this\r\n\r\n    var morpher = new Morphable(this._stepper)\r\n      .type(this._element.MorphArray).to(a)\r\n\r\n    this.queue(function () {\r\n      morpher.from(this._element.array())\r\n    }, function (pos) {\r\n      this._element.plot(morpher.at(pos))\r\n      return morpher.done()\r\n    })\r\n\r\n    this._rememberMorpher('plot', morpher)\r\n    return this\r\n  },\r\n\r\n  // Add leading method\r\n  leading (value) {\r\n    return this._queueNumber('leading', value)\r\n  },\r\n\r\n  // Add animatable viewbox\r\n  viewbox (x, y, width, height) {\r\n    return this._queueObject('viewbox', new Box(x, y, width, height))\r\n  },\r\n\r\n  update (o) {\r\n    if (typeof o !== 'object') {\r\n      return this.update({\r\n        offset: arguments[0],\r\n        color: arguments[1],\r\n        opacity: arguments[2]\r\n      })\r\n    }\r\n\r\n    if (o.opacity != null) this.attr('stop-opacity', o.opacity)\r\n    if (o.color != null) this.attr('stop-color', o.color)\r\n    if (o.offset != null) this.attr('offset', o.offset)\r\n\r\n    return this\r\n  }\r\n})\r\n\r\nextend(Runner, { rx, ry, from, to })\r\nregister(Runner, 'Runner')\r\n",
      "start": 1693508127052,
      "end": 1693508127130,
      "sourcemaps": null
    }
  ]
}
