{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/topology/RegularizeFace.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Topology\n */\nimport { HalfEdge, HalfEdgeMask } from \"./Graph\";\nimport { HalfEdgeGraphOps } from \"./Merging\";\n/**\n * * Context for regularizing single faces.\n * @internal\n */\nexport class RegularizationContext {\n    constructor(graph) {\n        this.graph = graph;\n        this.upEdges = [];\n        this.downEdges = [];\n        this.bottomPeaks = [];\n        this.topPeaks = [];\n        this.localMin = [];\n        this.localMax = [];\n    }\n    /**\n     * Collect (and classify) all the edges around a single face.\n     * * The various arrays are collected: upEdges, downEdges, topPeaks, bottomPeaks, upChains, downChains\n     * @param faceSeed face to examine\n     */\n    collectVerticalEventsAroundFace(faceSeed) {\n        let nodeA = faceSeed;\n        let nodeB;\n        let nodeC;\n        let abUp;\n        let bcUp;\n        this.upEdges.length = 0;\n        this.downEdges.length = 0;\n        this.topPeaks.length = 0;\n        this.bottomPeaks.length = 0;\n        this.localMin.length = 0;\n        this.localMax.length = 0;\n        do {\n            nodeB = nodeA.faceSuccessor;\n            nodeC = nodeB.faceSuccessor;\n            abUp = HalfEdgeGraphOps.compareNodesYXUp(nodeA, nodeB) < 0;\n            bcUp = HalfEdgeGraphOps.compareNodesYXUp(nodeB, nodeC) < 0;\n            if (abUp) {\n                this.upEdges.push(nodeA);\n                if (!bcUp) {\n                    if (HalfEdgeGraphOps.crossProductToTargets(nodeB, nodeA, nodeC) < 0)\n                        this.localMax.push(nodeB);\n                    else\n                        this.topPeaks.push(nodeB);\n                }\n            }\n            else { // ab is DOWN\n                this.downEdges.push(nodeA);\n                if (bcUp) {\n                    if (HalfEdgeGraphOps.crossProductToTargets(nodeB, nodeA, nodeC) > 0)\n                        this.bottomPeaks.push(nodeB);\n                    else\n                        this.localMin.push(nodeB);\n                }\n            }\n            nodeA = nodeB;\n        } while (nodeA !== faceSeed);\n    }\n    /**\n     * Collect (and classify) all the edges in an array.\n     * * The various arrays are collected: upEdges, downEdges, topPeaks, bottomPeaks, upChains, downChains\n     * @param candidateEdges array of edges.\n     */\n    collectVerticalEventFromEdgesInAndArray(candidateEdges) {\n        let nodeA;\n        let nodeB;\n        let nodeC;\n        let abUp;\n        let bcUp;\n        this.upEdges.length = 0;\n        this.downEdges.length = 0;\n        this.topPeaks.length = 0;\n        this.bottomPeaks.length = 0;\n        this.localMin.length = 0;\n        this.localMax.length = 0;\n        for (nodeA of candidateEdges) {\n            nodeB = nodeA.faceSuccessor;\n            nodeC = nodeB.faceSuccessor;\n            abUp = HalfEdgeGraphOps.compareNodesYXUp(nodeA, nodeB) < 0;\n            bcUp = HalfEdgeGraphOps.compareNodesYXUp(nodeB, nodeC) < 0;\n            if (abUp) {\n                this.upEdges.push(nodeA);\n                if (!bcUp) {\n                    if (HalfEdgeGraphOps.crossProductToTargets(nodeB, nodeA, nodeC) < 0)\n                        this.localMax.push(nodeB);\n                    else\n                        this.topPeaks.push(nodeB);\n                }\n            }\n            else { // ab is DOWN\n                this.downEdges.push(nodeA);\n                if (bcUp) {\n                    if (HalfEdgeGraphOps.crossProductToTargets(nodeB, nodeA, nodeC) > 0)\n                        this.bottomPeaks.push(nodeB);\n                    else\n                        this.localMin.push(nodeB);\n                }\n            }\n        }\n    }\n    swapArrays() {\n        let save = this.downEdges;\n        this.downEdges = this.upEdges;\n        this.upEdges = save;\n        save = this.localMax;\n        this.localMax = this.localMin;\n        this.localMin = save;\n        save = this.topPeaks;\n        this.topPeaks = this.bottomPeaks;\n        this.bottomPeaks = save;\n    }\n    /**\n     * Find the edge (among candidates) which is first struck by a \"rightward\" scan from node\n     * * comparisonFunction determines scan sense\n     *   * HalfEdge.compareNodeYXTheta is an upward scan.\n     *   * HalfEdge.compareNodeYXThetaDownward is a downward scan.\n     * @param node\n     * @param candidates Array of nodes to search\n     * @param nodeComparisonFunction function for lexical comparison.\n     */\n    findTopVisibleEdge(node, candidates, directionSign) {\n        const y0 = node.y;\n        const x0 = node.x;\n        let dx;\n        let distanceRight = Number.MAX_SAFE_INTEGER;\n        let result;\n        for (const rightBase of candidates) {\n            const rightTop = rightBase.faceSuccessor;\n            if (rightBase === node || rightTop === node)\n                continue;\n            // for horizontal edge cases -- require edges ends to have strict sign change (no zeros!!)\n            const cRight = HalfEdgeGraphOps.compareNodesYXUp(node, rightBase);\n            const cTop = HalfEdgeGraphOps.compareNodesYXUp(node, rightTop);\n            // GeometryCoreTestIO.consoleLog(node.id, rightBase.id, rightTop.id, cRight, cTop);\n            if (cRight * cTop >= 0)\n                continue;\n            const fraction = HalfEdge.horizontalScanFraction01(rightBase, y0);\n            if (fraction !== undefined) {\n                dx = directionSign * (rightBase.fractionToX(fraction) - x0);\n                if (dx > 0 && dx < distanceRight) {\n                    result = rightBase;\n                    distanceRight = dx;\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     *\n     * @param downPeak a \"bottom\" node where the interior CCW loop has a local min\n     * @param downEdgeStart (optional) node at the start (heading downwards!) of an edge that brackets downPeak on the left.\n     * @param upEdgeStart  (optional) node at the start (heading up!) of the edge that brackets downPeak on the right.\n     */\n    highestUpPeakConnection(downPeak, downEdgeStart, upEdgeStart) {\n        let highestPeak;\n        for (const upPeak of this.topPeaks) {\n            const y0 = upPeak.y;\n            const x0 = upPeak.x;\n            // is upPeak higher than prior upPeak?\n            if (highestPeak !== undefined && HalfEdgeGraphOps.compareNodesYXUp(upPeak, highestPeak) < 0)\n                continue;\n            // is upPeak BELOW downPeak, ABOVE both limit edges lower node, and between limit edge interiors.\n            if (HalfEdgeGraphOps.compareNodesYXUp(upPeak, downPeak) < 0) {\n                if (downEdgeStart) {\n                    const fraction = HalfEdge.horizontalScanFraction01(downEdgeStart, y0);\n                    if (fraction === undefined)\n                        continue;\n                    if (x0 <= downEdgeStart.fractionToX(fraction))\n                        continue;\n                }\n                if (upEdgeStart) {\n                    const fraction = HalfEdge.horizontalScanFraction01(upEdgeStart, y0);\n                    if (fraction === undefined)\n                        continue;\n                    if (upEdgeStart.fractionToX(fraction) <= x0)\n                        continue;\n                }\n                highestPeak = upPeak;\n            }\n        }\n        return highestPeak;\n    }\n    updateMaxNode(maxNode, candidate, compare) {\n        if (!maxNode)\n            return candidate;\n        if (!candidate)\n            return maxNode;\n        // both are defined .. look for positive compare ...\n        if (compare(maxNode, candidate) < 0)\n            return candidate;\n        return maxNode;\n    }\n    negateXY() {\n        for (const node of this.graph.allHalfEdges) {\n            node.x *= -1;\n            node.y *= -1;\n        }\n    }\n    downwardConnectionFromBottomPeak(node) {\n        let connectTo;\n        const upFunction = (a, b) => HalfEdgeGraphOps.compareNodesYXUp(a, b);\n        const upEdgeBase = this.findTopVisibleEdge(node, this.upEdges, 1.0);\n        const downEdgeBase = this.findTopVisibleEdge(node, this.downEdges, -1.0);\n        connectTo = this.updateMaxNode(connectTo, upEdgeBase, upFunction);\n        if (downEdgeBase)\n            connectTo = this.updateMaxNode(connectTo, downEdgeBase.faceSuccessor, upFunction);\n        const upPeakConnection = this.highestUpPeakConnection(node, downEdgeBase, upEdgeBase);\n        if (upPeakConnection !== undefined)\n            connectTo = this.updateMaxNode(connectTo, upPeakConnection, upFunction);\n        return connectTo;\n    }\n    /** Search around the vertex of nodeA for a nodeA1 such that nodeB is visible in the sector at nodeA1 */\n    findVisibleSector(nodeA, nodeB) {\n        let nodeA1 = nodeA;\n        do {\n            if (HalfEdge.isNodeVisibleInSector(nodeB, nodeA1))\n                return nodeA1;\n            nodeA1 = nodeA1.vertexSuccessor;\n        } while (nodeA1 !== nodeA);\n        return undefined;\n    }\n    /**\n     * Create an edge from (some node around the vertex of) nodeA to (some node around the vertex of) nodeB.\n     * * looking around the vertex for alternate insertion corrects cusp insertion errors.\n     * @param nodeA\n     * @param nodeB\n     */\n    joinNodes(nodeA, nodeB, direction) {\n        const nodeC = this.graph.createEdgeXYZXYZ(nodeA.x, nodeA.y, nodeA.z, 0, nodeB.x, nodeB.y, nodeB.z, 0);\n        const nodeA1 = this.findVisibleSector(nodeA, nodeB);\n        const nodeB1 = this.findVisibleSector(nodeB, nodeA);\n        if (nodeA1 !== undefined && nodeB1 !== undefined) {\n            HalfEdge.pinch(nodeA1, nodeC);\n            HalfEdge.pinch(nodeB1, nodeC.edgeMate);\n            if (RegularizationContext.announceEdge)\n                RegularizationContext.announceEdge(this.graph, nodeA, nodeB, direction);\n            return nodeC;\n        }\n        return undefined;\n    }\n    /**\n     * Regularize a single face.\n     * * Insert edge from any downward interior vertex to something lower\n     * * Insert an edge from each upward interior vertex to something higher.\n     * * The face is split into smaller faces\n     * * Each final face has at most one \"min\" and one \"max\", and is easy to triangulate with a bottom to top sweep.\n     * * Normal usage is to sweep in both directions, i.e. use the default (true,true) for the upSweep and downSweep parameters.\n     * @param faceSeed any representative half edge on the face\n     * @param upSweep true to do the upward sweep.\n     * @param downSweep true to do the downward sweep.\n     */\n    runRegularization(upSweep = true, downSweep = true) {\n        if (upSweep) {\n            this.bottomPeaks.sort((a, b) => HalfEdgeGraphOps.compareNodesYXUp(a, b));\n            for (const bottomPeak of this.bottomPeaks) {\n                // GeometryCoreTestIO.consoleLog(\"SEARCH\", bottomPeak.id, [bottomPeak.x, bottomPeak.y]);\n                if (!HalfEdgeGraphOps.isDownPeak(bottomPeak))\n                    continue;\n                const target = this.downwardConnectionFromBottomPeak(bottomPeak);\n                if (target !== undefined) {\n                    // GeometryCoreTestIO.consoleLog(\"join\", bottomPeak.id, [bottomPeak.x, bottomPeak.y], target.id, [target.x, target.y]);\n                    this.joinNodes(bottomPeak, target, 1);\n                }\n            }\n        }\n        if (downSweep) {\n            // flip the whole graph (ouch)\n            this.negateXY();\n            // swap the various p and down seeds ....\n            this.swapArrays();\n            this.bottomPeaks.sort((a, b) => HalfEdgeGraphOps.compareNodesYXUp(a, b));\n            for (const bottomPeak of this.bottomPeaks) {\n                if (!HalfEdgeGraphOps.isDownPeak(bottomPeak))\n                    continue;\n                const target = this.downwardConnectionFromBottomPeak(bottomPeak);\n                if (target !== undefined) {\n                    this.joinNodes(bottomPeak, target, -1);\n                }\n            }\n            this.negateXY();\n            this.swapArrays();\n        }\n    }\n    /**\n     * Regularize a single face.\n     * * Insert edge from any downward interior vertex to something lower\n     * * Insert an edge from each upward interior vertex to something higher.\n     * * The face is split into smaller faces\n     * * Each final face has at most one \"min\" and one \"max\", and is easy to triangulate with a bottom to top sweep.\n     * * Normal usage is to sweep in both directions, i.e. use the default (true,true) for the upSweep and downSweep parameters.\n     * @param faceSeed any representative half edge on the face\n     * @param upSweep true to do the upward sweep.\n     * @param downSweep true to do the downward sweep.\n     */\n    regularizeFace(faceSeed, upSweep = true, downSweep = true) {\n        this.collectVerticalEventsAroundFace(faceSeed);\n        this.runRegularization(upSweep, downSweep);\n    }\n    regularizeGraph(upSweep = true, downSweep = true) {\n        this.collectVerticalEventFromEdgesInAndArray(this.graph.allHalfEdges);\n        this.runRegularization(upSweep, downSweep);\n    }\n    /** test if a single face is monotone;  if so, return its (single) min */\n    static isMonotoneFace(seed) {\n        let numMin = 0;\n        let numMax = 0;\n        let nodeMin;\n        let nodeA = seed;\n        do {\n            const nodeB = nodeA.faceSuccessor;\n            const nodeC = nodeB.faceSuccessor;\n            const ab = HalfEdgeGraphOps.compareNodesYXUp(nodeA, nodeB);\n            const bc = HalfEdgeGraphOps.compareNodesYXUp(nodeB, nodeC);\n            if (ab * bc <= 0) {\n                if (ab > 0) {\n                    numMin++;\n                    nodeMin = nodeB;\n                }\n                if (bc > 0) {\n                    numMax++;\n                }\n            }\n        } while ((nodeA = nodeA.faceSuccessor) !== seed);\n        return numMin === 1 && numMax === 1 ? nodeMin : undefined;\n    }\n    /** Return faces filtered by area and test function.\n     * * find one arbitrary representative of each face\n     * * offer the candidate to the mutate function.\n     * * collect results\n     * @param mappedSeeds when filter returns a HalfEdge, collect it here\n     * @param unmappedSeeds when filter does not return a half edge, collect the candidate.\n     */\n    static collectMappedFaceRepresentatives(graph, positiveAreaOnly, mutate, mappedEdges, unMappedSeeds) {\n        if (mappedEdges)\n            mappedEdges.length = 0;\n        if (unMappedSeeds)\n            unMappedSeeds.length = 0;\n        const mask = HalfEdgeMask.VISITED;\n        graph.clearMask(mask);\n        for (const seed of graph.allHalfEdges) {\n            if (!seed.getMask(mask)) {\n                seed.setMaskAroundFace(mask);\n                if (!positiveAreaOnly || seed.signedFaceArea() > 0) {\n                    const edge = mutate(seed);\n                    if (edge) {\n                        if (mappedEdges)\n                            mappedEdges.push(edge);\n                    }\n                    else {\n                        if (unMappedSeeds)\n                            unMappedSeeds.push(seed);\n                    }\n                }\n            }\n        }\n    }\n}\n//# sourceMappingURL=RegularizeFace.js.map",
      "start": 1693508126354,
      "end": 1693508126421,
      "sourcemaps": null
    }
  ]
}
