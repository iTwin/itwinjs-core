{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/bentley/lib/esm/TupleKeyedMap.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Collections\n */\n/** A map similar to the standard JavaScript Map collection except that the keys must be a tuple\n * (javascript array), and two keys are considered equal if their elements in order are strict-equal,\n * and the tuples have the same amount of elements\n *\n * This means you can use array literals to key data in Maps that would otherwise be reference-compared\n * if using JavaScript's built in Map\n *\n * Note that JavaScript's Map type, unlike this one that uses strict equality, uses instead\n * SameValueZero equality comparison\n * @see https://262.ecma-international.org/6.0/#sec-samevaluezero\n *\n * ```js\n * const map = new TupleKeyedMap([[1,\"y\"], \"value\"]);\n * const value = map.get([1, \"y\"]); // a normal map would identify these keys as different because they are independent objects\n * ```\n *\n * It is implemented by each index of the tuple key being used as a singular key into a submap\n * @note this only implements a subset of the Map interface\n * @public\n */\nexport class TupleKeyedMap {\n    // argument types match those of Map\n    constructor(entries) {\n        this._map = new Map();\n        this._size = 0;\n        if (entries)\n            for (const [k, v] of entries) {\n                this.set(k, v);\n            }\n    }\n    clear() {\n        return this._map.clear();\n    }\n    makeKeyError() {\n        return Error(\"A Bad key was used, it didn't match the key type of the the map.\");\n    }\n    get(key) {\n        let cursor = this._map;\n        for (const subkey of key) {\n            if (!(cursor instanceof Map))\n                throw this.makeKeyError();\n            cursor = cursor.get(subkey);\n            if (cursor === undefined)\n                return undefined;\n        }\n        if (cursor instanceof Map)\n            throw this.makeKeyError();\n        return cursor;\n    }\n    has(key) {\n        return this.get(key) !== undefined;\n    }\n    set(key, value) {\n        let cursor = this._map;\n        for (let i = 0; i < key.length - 1; ++i) {\n            const subkey = key[i];\n            let next = cursor.get(subkey);\n            if (next === undefined) {\n                next = new Map();\n                cursor.set(subkey, next);\n            }\n            cursor = next;\n        }\n        const finalSubkey = key[key.length - 1];\n        if (!(cursor instanceof Map))\n            throw this.makeKeyError();\n        cursor.set(finalSubkey, value);\n        this._size++;\n        return this;\n    }\n    *[Symbol.iterator]() {\n        function* impl(map, keyPrefix) {\n            for (const [k, v] of map) {\n                const nextKey = [...keyPrefix, k];\n                if (v instanceof Map) {\n                    yield* impl(v, nextKey);\n                }\n                else {\n                    yield [nextKey, v];\n                }\n            }\n        }\n        yield* impl(this._map, []);\n    }\n    get size() {\n        return this._size;\n    }\n    get [Symbol.toStringTag]() {\n        return this.constructor.name;\n    }\n}\n//# sourceMappingURL=TupleKeyedMap.js.map",
      "start": 1693508120627,
      "end": 1693508120693,
      "sourcemaps": null
    }
  ]
}
