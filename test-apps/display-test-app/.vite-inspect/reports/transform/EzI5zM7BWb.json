{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tile/map/ImageryProviders/BingImageryProvider.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tiles\n */\nimport { assert, BentleyError, IModelStatus } from \"@itwin/core-bentley\";\nimport { request } from \"../../../request/Request\";\nimport { IModelApp } from \"../../../IModelApp\";\nimport { MapLayerImageryProvider, MapTile, QuadId, WebMercatorTilingScheme, } from \"../../internal\";\n/** Represents one range of geography and tile zoom levels for a bing data provider\n * @internal\n */\nclass Coverage {\n    constructor(_lowerLeftLatitude, _lowerLeftLongitude, _upperRightLatitude, _upperRightLongitude, _minimumZoomLevel, _maximumZoomLevel) {\n        this._lowerLeftLatitude = _lowerLeftLatitude;\n        this._lowerLeftLongitude = _lowerLeftLongitude;\n        this._upperRightLatitude = _upperRightLatitude;\n        this._upperRightLongitude = _upperRightLongitude;\n        this._minimumZoomLevel = _minimumZoomLevel;\n        this._maximumZoomLevel = _maximumZoomLevel;\n    }\n    overlaps(quadId, tilingScheme) {\n        const range = quadId.getLatLongRangeDegrees(tilingScheme);\n        if (quadId.level < this._minimumZoomLevel)\n            return false;\n        if (quadId.level > this._maximumZoomLevel)\n            return false;\n        if (range.low.x > this._upperRightLongitude)\n            return false;\n        if (range.low.y > this._upperRightLatitude)\n            return false;\n        if (range.high.x < this._lowerLeftLongitude)\n            return false;\n        if (range.high.y < this._lowerLeftLatitude)\n            return false;\n        return true;\n    }\n}\n/** Represents the copyright message and an array of coverage data for one of bing's data providers (HERE for example).\n * @internal\n */\nclass BingAttribution {\n    constructor(copyrightMessage, _coverages) {\n        this.copyrightMessage = copyrightMessage;\n        this._coverages = _coverages;\n    }\n    matchesTile(tile, tilingScheme) {\n        const quadId = QuadId.createFromContentId(tile.contentId);\n        for (const coverage of this._coverages) {\n            if (coverage.overlaps(quadId, tilingScheme))\n                return true;\n        }\n        return false;\n    }\n}\n// in deployed applications, we can only make https requests, but the Bing Maps metadata request returns templates with \"http:\".\n// This function fixes those.\nfunction replaceHttpWithHttps(originalUrl) {\n    return originalUrl.startsWith(\"http:\") ? \"https:\".concat(originalUrl.slice(5)) : originalUrl;\n}\n/** @internal */\nexport class BingMapsImageryLayerProvider extends MapLayerImageryProvider {\n    constructor(settings) {\n        super(settings, true);\n        this._urlBase = settings.url;\n        this._zoomMax = 0;\n        this._tileHeight = this._tileWidth = 0;\n        this._mapTilingScheme = new WebMercatorTilingScheme();\n    }\n    get tileWidth() { return this._tileWidth; }\n    get tileHeight() { return this._tileHeight; }\n    tileXYToQuadKey(tileX, tileY, zoomLevel) {\n        // from C# example in bing documentation https://msdn.microsoft.com/en-us/library/bb259689.aspx\n        let quadKey = \"\";\n        // Root tile is not displayable. Returns 0 for _GetMaximumSize(). Should not end up here.\n        assert(0 !== zoomLevel);\n        for (let i = zoomLevel; i > 0; i--) {\n            let digit = 0x30; // '0'\n            const mask = 1 << (i - 1);\n            if ((tileX & mask) !== 0) {\n                digit++;\n            }\n            if ((tileY & mask) !== 0) {\n                digit++;\n                digit++;\n            }\n            quadKey = quadKey.concat(String.fromCharCode(digit));\n        }\n        return quadKey;\n    }\n    // construct the Url from the desired Tile\n    async constructUrl(row, column, zoomLevel) {\n        // From the tile, get a \"quadKey\" the Microsoft way.\n        const quadKey = this.tileXYToQuadKey(column, row, zoomLevel);\n        const subdomain = this._urlSubdomains[(row + column) % this._urlSubdomains.length];\n        // from the template url, construct the tile url.\n        let url = this._urlTemplate.replace(\"{subdomain}\", subdomain);\n        url = url.replace(\"{quadkey}\", quadKey);\n        return url;\n    }\n    // gets the attributions that match the tile set.\n    getMatchingAttributions(tiles) {\n        const matchingAttributions = new Array();\n        if (!this._attributions || !tiles)\n            return matchingAttributions;\n        const unmatchedSet = this._attributions.slice();\n        for (const tile of tiles) {\n            if (tile instanceof MapTile)\n                // compare to the set of Bing attributions that we have not yet matched.\n                for (let iAttr = 0; iAttr < unmatchedSet.length; iAttr++) {\n                    const attribution = unmatchedSet[iAttr];\n                    if (attribution && attribution.matchesTile(tile, this._mapTilingScheme)) {\n                        matchingAttributions.push(attribution);\n                        delete unmatchedSet[iAttr];\n                    }\n                }\n        }\n        return matchingAttributions;\n    }\n    addLogoCards(cards, vp) {\n        const tiles = IModelApp.tileAdmin.getTilesForUser(vp)?.selected;\n        const matchingAttributions = this.getMatchingAttributions(tiles);\n        const copyrights = [];\n        for (const match of matchingAttributions)\n            copyrights.push(match.copyrightMessage);\n        let copyrightMsg = \"\";\n        for (let i = 0; i < copyrights.length; ++i) {\n            if (i > 0)\n                copyrightMsg += \"<br>\";\n            copyrightMsg += copyrights[i];\n        }\n        cards.appendChild(IModelApp.makeLogoCard({ iconSrc: `${IModelApp.publicPath}images/bing.svg`, heading: \"Microsoft Bing\", notice: copyrightMsg }));\n    }\n    // initializes the BingImageryProvider by reading the templateUrl, logo image, and attribution list.\n    async initialize() {\n        // get the template url\n        const bingRequestUrl = this._urlBase.replace(\"{bingKey}\", this._settings.accessKey ? this._settings.accessKey.value : \"\");\n        try {\n            const bingResponseProps = await request(bingRequestUrl, \"json\");\n            const thisResourceSetProps = bingResponseProps.resourceSets[0];\n            const thisResourceProps = thisResourceSetProps.resources[0];\n            this._zoomMax = thisResourceProps.zoomMax;\n            this._tileHeight = thisResourceProps.imageHeight;\n            this._tileWidth = thisResourceProps.imageWidth;\n            this._urlTemplate = replaceHttpWithHttps(thisResourceProps.imageUrl.replace(\"{culture}\", \"en-US\")); // NEEDSWORK - get locale from somewhere.\n            this._urlSubdomains = thisResourceProps.imageUrlSubdomains;\n            // read the list of Bing's data suppliers and the range of data they provide. Used in calculation of copyright message.\n            this.readAttributions(thisResourceProps.imageryProviders);\n            // Bing sometimes provides tiles that have nothing but a camera icon in the middle of them when you ask\n            // for tiles at zoom levels where they don't have data. Their application stops you from zooming in when that's the\n            // case, but we can't stop - the user might want to look at design data a closer zoom. So we intentionally load such\n            // a tile, and then compare other tiles to it, rejecting them if they match.\n            this.loadTile(0, 0, this._zoomMax - 1).then((tileData) => {\n                if (tileData !== undefined)\n                    this._missingTileData = tileData.data;\n            });\n        }\n        catch (error) {\n            throw new BentleyError(IModelStatus.BadModel, \"Error in Bing Server communications\");\n        }\n    }\n    // reads the list of Bing data providers and the map range for which they each provide data.\n    readAttributions(attributionProps) {\n        for (const thisAttributionProps of attributionProps) {\n            const copyrightMessage = thisAttributionProps.attribution;\n            const coverages = new Array();\n            for (const thisCoverageProps of thisAttributionProps.coverageAreas) {\n                const thisCoverage = new Coverage(thisCoverageProps.bbox[0], thisCoverageProps.bbox[1], thisCoverageProps.bbox[2], thisCoverageProps.bbox[3], thisCoverageProps.zoomMin, thisCoverageProps.zoomMax);\n                coverages.push(thisCoverage);\n            }\n            const thisAttribution = new BingAttribution(copyrightMessage, coverages);\n            if (!this._attributions)\n                this._attributions = new Array();\n            this._attributions.push(thisAttribution);\n        }\n    }\n}\n//# sourceMappingURL=BingImageryProvider.js.map",
      "start": 1693508121947,
      "end": 1693508122044,
      "sourcemaps": null
    }
  ]
}
