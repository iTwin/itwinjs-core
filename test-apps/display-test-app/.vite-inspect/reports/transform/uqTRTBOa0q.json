{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend-devtools/lib/esm/tools/ViewportTools.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tools\n */\nimport { BeDuration } from \"@itwin/core-bentley\";\nimport { ColorDef, Hilite } from \"@itwin/core-common\";\nimport { DrawingViewState, FlashMode, FlashSettings, IModelApp, TileBoundingBoxes, Tool, } from \"@itwin/core-frontend\";\nimport { parseArgs } from \"./parseArgs\";\nimport { parseToggle } from \"./parseToggle\";\n/** Base class for a tool that toggles some aspect of a Viewport.\n * @beta\n */\nexport class ViewportToggleTool extends Tool {\n    static get minArgs() { return 0; }\n    static get maxArgs() { return 1; }\n    async run(enable) {\n        const vp = IModelApp.viewManager.selectedView;\n        if (undefined !== vp)\n            await this.toggle(vp, enable);\n        return true;\n    }\n    async parseAndRun(...args) {\n        const enable = parseToggle(args[0]);\n        if (typeof enable !== \"string\")\n            await this.run(enable);\n        return true;\n    }\n}\n/** Freeze or unfreeze the scene for the selected viewport. While the scene is frozen, no new tiles will be selected for drawing within the viewport.\n * @beta\n */\nclass FreezeSceneTool extends ViewportToggleTool {\n    async toggle(vp, enable) {\n        if (undefined === enable || enable !== vp.freezeScene)\n            vp.freezeScene = !vp.freezeScene;\n        return Promise.resolve();\n    }\n}\nFreezeSceneTool.toolId = \"FreezeScene\";\nexport { FreezeSceneTool };\nconst boundingVolumeNames = [\n    \"none\",\n    \"volume\",\n    \"content\",\n    \"both\",\n    \"children\",\n    \"sphere\",\n    \"solid\",\n];\n/** Set the tile bounding volume decorations to display in the selected viewport.\n * Omitting the argument turns on Volume bounding boxes if bounding boxes are currently off; otherwise, toggles them off.\n * Allowed inputs are \"none\", \"volume\", \"content\", \"both\" (volume and content), \"children\", and \"sphere\".\n * @beta\n */\nclass ShowTileVolumesTool extends Tool {\n    static get minArgs() { return 0; }\n    static get maxArgs() { return 1; }\n    async run(boxes) {\n        const vp = IModelApp.viewManager.selectedView;\n        if (undefined === vp)\n            return true;\n        if (undefined === boxes)\n            boxes = TileBoundingBoxes.None === vp.debugBoundingBoxes ? TileBoundingBoxes.Volume : TileBoundingBoxes.None;\n        vp.debugBoundingBoxes = boxes;\n        return true;\n    }\n    async parseAndRun(...args) {\n        let boxes;\n        if (0 !== args.length) {\n            const arg = args[0].toLowerCase();\n            for (let i = 0; i < boundingVolumeNames.length; i++) {\n                if (arg === boundingVolumeNames[i]) {\n                    boxes = i;\n                    break;\n                }\n            }\n            if (undefined === boxes)\n                return true;\n        }\n        return this.run(boxes);\n    }\n}\nShowTileVolumesTool.toolId = \"ShowTileVolumes\";\nexport { ShowTileVolumesTool };\n/** Sets or unsets or flips the deactivated state of one or more tile tree references within the selected viewport.\n * Deactivated tile tree references are omitted from the scene.\n * This is useful for isolating particular tile trees or tiles for debugging.\n * @beta\n */\nclass ToggleTileTreeReferencesTool extends Tool {\n    static get minArgs() { return 1; }\n    static get maxArgs() { return 3; }\n    async parseAndRun(...args) {\n        const which = args[0].toLowerCase();\n        switch (which) {\n            case \"all\":\n            case \"animated\":\n            case \"primary\":\n            case \"section\":\n                this._which = which;\n                break;\n            default:\n                this._which = which.split(\",\").map((x) => Number.parseInt(x, 10)).filter((x) => !Number.isNaN(x));\n        }\n        let modelIds = args[2];\n        let deactivate = parseToggle(args[1]);\n        if (typeof deactivate !== \"string\") {\n            if (typeof deactivate === \"boolean\")\n                deactivate = !deactivate;\n            this._deactivate = deactivate;\n        }\n        else {\n            modelIds = args[1];\n        }\n        if (modelIds)\n            this._modelIds = modelIds.toLowerCase().split(\",\");\n        return this.run();\n    }\n    async run() {\n        const vp = IModelApp.viewManager.selectedView;\n        if (!vp || !this._which || !vp.view.isSpatialView())\n            return false;\n        vp.view.setTileTreeReferencesDeactivated(this._modelIds, this._deactivate, this._which);\n        vp.invalidateScene();\n        return true;\n    }\n}\nToggleTileTreeReferencesTool.toolId = \"ToggleTileTreeReferences\";\nexport { ToggleTileTreeReferencesTool };\n/** This tool sets the aspect ratio skew for the selected viewport.\n * @beta\n */\nclass SetAspectRatioSkewTool extends Tool {\n    static get minArgs() { return 0; }\n    static get maxArgs() { return 1; }\n    /** This method runs the tool, setting the aspect ratio skew for the selected viewport.\n     * @param skew the aspect ratio (x/y) skew value; 1.0 or undefined removes any skew\n     */\n    async run(skew) {\n        if (undefined === skew)\n            skew = 1.0;\n        const vp = IModelApp.viewManager.selectedView;\n        if (undefined !== vp) {\n            vp.view.setAspectRatioSkew(skew);\n            vp.synchWithView();\n        }\n        return true;\n    }\n    /** Executes this tool's run method.\n     * @param args the first entry of this array contains the `skew` argument\n     * @see [[run]]\n     */\n    async parseAndRun(...args) {\n        const skew = args.length > 0 ? parseFloat(args[0]) : 1.0;\n        return !Number.isNaN(skew) && this.run(skew);\n    }\n}\nSetAspectRatioSkewTool.toolId = \"SetAspectRatioSkew\";\nexport { SetAspectRatioSkewTool };\n/** Changes the [ModelSubCategoryHiliteMode]($frontend) for the [HiliteSet]($frontend) associated with the selected Viewport.\n * @beta\n */\nclass ChangeHiliteModeTool extends Tool {\n    static get minArgs() { return 1; }\n    static get maxArgs() { return 1; }\n    async run(mode) {\n        const hilites = IModelApp.viewManager.selectedView?.iModel.hilited;\n        if (!hilites)\n            return false;\n        if (mode === \"union\" || mode === \"intersection\")\n            hilites.modelSubCategoryMode = mode;\n        return true;\n    }\n    async parseAndRun(...args) {\n        return this.run(args[0]);\n    }\n}\nChangeHiliteModeTool.toolId = \"ChangeHiliteMode\";\nexport { ChangeHiliteModeTool };\n/** Changes the selected viewport's hilite or emphasis settings.\n * @beta\n */\nexport class ChangeHiliteTool extends Tool {\n    static get minArgs() { return 0; }\n    static get maxArgs() { return 6; }\n    async run(settings) {\n        const vp = IModelApp.viewManager.selectedView;\n        if (undefined !== vp)\n            this.apply(vp, settings);\n        return true;\n    }\n    async parseAndRun(...inputArgs) {\n        if (0 === inputArgs.length)\n            return this.run();\n        const vp = IModelApp.viewManager.selectedView;\n        if (undefined === vp)\n            return true;\n        const cur = this.getCurrentSettings(vp);\n        const colors = cur.color.colors;\n        let visible = cur.visibleRatio;\n        let hidden = cur.hiddenRatio;\n        let silhouette = cur.silhouette;\n        const args = parseArgs(inputArgs);\n        const parseColorComponent = (c) => {\n            const num = args.getInteger(c);\n            if (undefined !== num)\n                colors[c] = Math.floor(Math.max(0, Math.min(255, num)));\n        };\n        parseColorComponent(\"r\");\n        parseColorComponent(\"g\");\n        parseColorComponent(\"b\");\n        const silhouetteArg = args.getInteger(\"s\");\n        if (undefined !== silhouetteArg && silhouetteArg >= Hilite.Silhouette.None && silhouetteArg <= Hilite.Silhouette.Thick)\n            silhouette = silhouetteArg;\n        const v = args.getFloat(\"v\");\n        if (undefined !== v && v >= 0 && v <= 1)\n            visible = v;\n        const h = args.getFloat(\"h\");\n        if (undefined !== h && h >= 0 && h <= 1)\n            hidden = h;\n        if (undefined === silhouette)\n            silhouette = cur.silhouette;\n        if (undefined === visible)\n            visible = cur.visibleRatio;\n        if (undefined === hidden)\n            hidden = cur.hiddenRatio;\n        const settings = {\n            color: ColorDef.from(colors.r, colors.g, colors.b),\n            silhouette,\n            visibleRatio: visible,\n            hiddenRatio: hidden,\n        };\n        return this.run(settings);\n    }\n}\n/** Changes the selected viewport's hilite settings, or resets to defaults.\n * @beta\n */\nclass ChangeHiliteSettingsTool extends ChangeHiliteTool {\n    getCurrentSettings(vp) { return vp.hilite; }\n    apply(vp, settings) {\n        vp.hilite = undefined !== settings ? settings : new Hilite.Settings();\n    }\n}\nChangeHiliteSettingsTool.toolId = \"ChangeHiliteSettings\";\nexport { ChangeHiliteSettingsTool };\n/** Changes the selected viewport's emphasis settings.\n * @beta\n */\nclass ChangeEmphasisSettingsTool extends ChangeHiliteTool {\n    getCurrentSettings(vp) { return vp.emphasisSettings; }\n    apply(vp, settings) {\n        if (undefined !== settings)\n            vp.emphasisSettings = settings;\n    }\n}\nChangeEmphasisSettingsTool.toolId = \"ChangeEmphasisSettings\";\nexport { ChangeEmphasisSettingsTool };\n/** Changes the [FlashSettings]($frontend) for the selected [Viewport]($frontend).\n * @beta\n */\nclass ChangeFlashSettingsTool extends Tool {\n    static get minArgs() { return 0; }\n    static get maxArgs() { return 3; }\n    async run(settings) {\n        const vp = IModelApp.viewManager.selectedView;\n        if (vp)\n            vp.flashSettings = settings ?? new FlashSettings();\n        return true;\n    }\n    async parseAndRun(...inputArgs) {\n        const vp = IModelApp.viewManager.selectedView;\n        if (!vp)\n            return true;\n        if (1 === inputArgs.length && \"default\" === inputArgs[0].toLowerCase())\n            return this.run();\n        const options = {};\n        const args = parseArgs(inputArgs);\n        const intensity = args.getFloat(\"i\");\n        if (undefined !== intensity)\n            options.maxIntensity = intensity;\n        const mode = args.get(\"m\");\n        if (mode) {\n            switch (mode[0].toLowerCase()) {\n                case \"b\":\n                    options.litMode = FlashMode.Brighten;\n                    break;\n                case \"h\":\n                    options.litMode = FlashMode.Hilite;\n                    break;\n                default:\n                    return false;\n            }\n        }\n        const duration = args.getFloat(\"d\");\n        if (undefined !== duration)\n            options.duration = BeDuration.fromSeconds(duration);\n        return this.run(vp.flashSettings.clone(options));\n    }\n}\nChangeFlashSettingsTool.toolId = \"ChangeFlashSettings\";\nexport { ChangeFlashSettingsTool };\n/** Enables or disables fade-out transparency mode for the selected viewport.\n * @beta\n */\nclass FadeOutTool extends ViewportToggleTool {\n    async toggle(vp, enable) {\n        if (undefined === enable || enable !== vp.isFadeOutActive)\n            vp.isFadeOutActive = !vp.isFadeOutActive;\n        return Promise.resolve();\n    }\n}\nFadeOutTool.toolId = \"FadeOut\";\nexport { FadeOutTool };\n/** Sets the default tile size modifier used for all viewports that don't explicitly override it.\n * @beta\n */\nclass DefaultTileSizeModifierTool extends Tool {\n    static get minArgs() { return 1; }\n    static get maxArgs() { return 1; }\n    /** This method runs the tool, setting the default tile size modifier used for all viewports that don't explicitly override it.\n     * @param modifier the tile size modifier to use; if undefined, do not set modifier\n     */\n    async run(modifier) {\n        if (undefined !== modifier)\n            IModelApp.tileAdmin.defaultTileSizeModifier = modifier;\n        return true;\n    }\n    /** Executes this tool's run method with args[0] containing `modifier`.\n     * @see [[run]]\n     */\n    async parseAndRun(...args) {\n        return this.run(Number.parseFloat(args[0]));\n    }\n}\nDefaultTileSizeModifierTool.toolId = \"DefaultTileSizeMod\";\nexport { DefaultTileSizeModifierTool };\n/** Sets or clears the tile size modifier override for the selected viewport.\n * @beta\n */\nclass ViewportTileSizeModifierTool extends Tool {\n    static get minArgs() { return 1; }\n    static get maxArgs() { return 1; }\n    /** This method runs the tool, setting the tile size modifier used for the selected viewport.\n     * @param modifier the tile size modifier to use; if undefined, reset the modifier\n     */\n    async run(modifier) {\n        const vp = IModelApp.viewManager.selectedView;\n        if (undefined !== vp)\n            vp.setTileSizeModifier(modifier);\n        return true;\n    }\n    /** Executes this tool's run method with args[0] containing the `modifier` argument or the string \"reset\" in order to reset the modifier.\n     * @see [[run]]\n     */\n    async parseAndRun(...args) {\n        const arg = args[0].toLowerCase();\n        const modifier = \"reset\" === arg ? undefined : Number.parseFloat(args[0]);\n        return this.run(modifier);\n    }\n}\nViewportTileSizeModifierTool.toolId = \"ViewportTileSizeMod\";\nexport { ViewportTileSizeModifierTool };\n/** This tool adds a reality model to the viewport.\n * @beta\n */\nclass ViewportAddRealityModel extends Tool {\n    static get minArgs() { return 1; }\n    static get maxArgs() { return 1; }\n    /** This method runs the tool, adding a reality model to the viewport\n     * @param url the URL which points to the reality model tileset\n     */\n    async run(url) {\n        const vp = IModelApp.viewManager.selectedView;\n        if (undefined !== vp)\n            vp.displayStyle.attachRealityModel({ tilesetUrl: url });\n        return true;\n    }\n    /** Executes this tool's run method with args[0] containing the `url` argument.\n     * @see [[run]]\n     */\n    async parseAndRun(...args) {\n        return this.run(args[0]);\n    }\n}\nViewportAddRealityModel.toolId = \"ViewportAddRealityModel\";\nexport { ViewportAddRealityModel };\n/** Changes the `allow3dManipulations` flag for the selected viewport if the viewport is displaying a `ViewState3d`.\n * @beta\n */\nclass Toggle3dManipulationsTool extends ViewportToggleTool {\n    async toggle(vp, allow) {\n        if (!vp.view.is3d())\n            return Promise.resolve();\n        if (undefined === allow)\n            allow = !vp.view.allow3dManipulations();\n        if (allow !== vp.view.allow3dManipulations()) {\n            vp.view.setAllow3dManipulations(allow);\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            IModelApp.toolAdmin.startDefaultTool();\n        }\n        return Promise.resolve();\n    }\n}\nToggle3dManipulationsTool.toolId = \"Toggle3dManipulations\";\nexport { Toggle3dManipulationsTool };\n/** Toggles display of view attachments in sheet views.\n * @beta\n */\nclass ToggleViewAttachmentsTool extends ViewportToggleTool {\n    async toggle(vp, enable) {\n        if (undefined === enable || enable !== vp.wantViewAttachments)\n            vp.wantViewAttachments = !vp.wantViewAttachments;\n        return Promise.resolve();\n    }\n}\nToggleViewAttachmentsTool.toolId = \"ToggleViewAttachments\";\nexport { ToggleViewAttachmentsTool };\n/** Toggle display of view attachment boundaries in sheet views.\n * @beta\n */\nclass ToggleViewAttachmentBoundariesTool extends ViewportToggleTool {\n    async toggle(vp, enable) {\n        if (undefined === enable || enable !== vp.wantViewAttachmentBoundaries)\n            vp.wantViewAttachmentBoundaries = !vp.wantViewAttachmentBoundaries;\n        return Promise.resolve();\n    }\n}\nToggleViewAttachmentBoundariesTool.toolId = \"ToggleViewAttachmentBoundaries\";\nexport { ToggleViewAttachmentBoundariesTool };\n/** Toggle display of view attachment clip shapes in sheet views.\n * @beta\n */\nclass ToggleViewAttachmentClipShapesTool extends ViewportToggleTool {\n    async toggle(vp, enable) {\n        if (undefined === enable || enable !== vp.wantViewAttachmentClipShapes)\n            vp.wantViewAttachmentClipShapes = !vp.wantViewAttachmentClipShapes;\n        return Promise.resolve();\n    }\n}\nToggleViewAttachmentClipShapesTool.toolId = \"ToggleViewAttachmentClipShapes\";\nexport { ToggleViewAttachmentClipShapesTool };\n/** Toggles display of 2d graphics in a [DrawingViewState]($frontend). This setting affects all drawing views until it is reset.\n * @beta\n */\nclass ToggleDrawingGraphicsTool extends ViewportToggleTool {\n    async toggle(vp, enable) {\n        if (undefined === enable || enable !== DrawingViewState.hideDrawingGraphics) {\n            DrawingViewState.hideDrawingGraphics = !DrawingViewState.hideDrawingGraphics;\n            vp.invalidateScene();\n        }\n        return Promise.resolve();\n    }\n}\nToggleDrawingGraphicsTool.toolId = \"ToggleDrawingGraphics\";\nexport { ToggleDrawingGraphicsTool };\n/** Toggles whether a [SectionDrawing]($backend)'s spatial view is always displayed along with the 2d graphics by a [DrawingViewState]($frontend), even\n * if it otherwise would not be. This setting affects all section drawing views until it is reset.\n * @beta\n */\nclass ToggleSectionDrawingSpatialViewTool extends ViewportToggleTool {\n    async toggle(vp, enable) {\n        if (undefined === enable || enable !== DrawingViewState.alwaysDisplaySpatialView) {\n            DrawingViewState.alwaysDisplaySpatialView = !DrawingViewState.alwaysDisplaySpatialView;\n            if (vp.view instanceof DrawingViewState) {\n                // Force the view to update its section drawing attachment.\n                const view = vp.view.clone();\n                await view.changeViewedModel(view.baseModelId);\n                await view.load();\n                vp.changeView(view);\n            }\n        }\n    }\n}\nToggleSectionDrawingSpatialViewTool.toolId = \"ToggleSectionDrawingSpatialView\";\nexport { ToggleSectionDrawingSpatialViewTool };\n/** Change the camera settings of the selected viewport.\n * @beta\n */\nclass ChangeCameraTool extends Tool {\n    static get minArgs() { return 1; }\n    static get maxArgs() { return 2; }\n    async run(camera) {\n        const vp = IModelApp.viewManager.selectedView;\n        if (camera && vp && vp.view.is3d()) {\n            const view = vp.view.clone();\n            view.camera.setFrom(camera);\n            vp.changeView(view);\n        }\n        return true;\n    }\n    async parseAndRun(...inArgs) {\n        const vp = IModelApp.viewManager.selectedView;\n        if (!vp || !vp.view.is3d())\n            return false;\n        const camera = vp.view.camera.clone();\n        const args = parseArgs(inArgs);\n        const lens = args.getFloat(\"l\");\n        if (undefined !== lens)\n            camera.lens.setDegrees(lens);\n        const focusDist = args.getFloat(\"d\");\n        if (undefined !== focusDist)\n            camera.focusDist = focusDist;\n        return this.run(camera);\n    }\n}\nChangeCameraTool.toolId = \"ChangeCamera\";\nexport { ChangeCameraTool };\n//# sourceMappingURL=ViewportTools.js.map",
      "start": 1693508122765,
      "end": 1693508122861,
      "sourcemaps": null
    }
  ]
}
