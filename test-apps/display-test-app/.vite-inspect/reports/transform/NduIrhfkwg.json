{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/common/lib/esm/geometry/Projection.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Geometry\n */\n// cspell:ignore Albers, Krovak, OSTN, Cassini, Grinten, Mollweide, Eckert, Homolosine, Carree, Winkel, Tripel, Polyconic\nimport { Geometry } from \"@itwin/core-geometry\";\n/** The equations are:\n *  X1 = a1*X + a2*Y + TranslationX\n *  Y1 = b1*X + b2*Y + translationY\n *  An affine representing no transformation will have: a1 = 1.0, a2 = 0.0, b1 = 0.0, b2 = 1.0.\n *  @public\n */\nexport class AffineTransform {\n    constructor(data) {\n        if (data) {\n            this.translationX = data.translationX;\n            this.translationY = data.translationY;\n            this.a1 = data.a1;\n            this.b1 = data.b1;\n            this.a2 = data.a2;\n            this.b2 = data.b2;\n        }\n    }\n    /** Creates an Affine Transform from JSON representation.\n     * @public */\n    static fromJSON(data) {\n        return new AffineTransform(data);\n    }\n    /** Creates a JSON from the Affine Transform definition\n     * @public */\n    toJSON() {\n        return { translationX: this.translationX, a1: this.a1, a2: this.a2, translationY: this.translationY, b1: this.b1, b2: this.b2 };\n    }\n    /** Compares two Affine Transforms. It applies a minuscule tolerance for number compares\n     *  @public */\n    equals(other) {\n        return (Math.abs(this.translationX - other.translationX) < Geometry.smallMetricDistance &&\n            Math.abs(this.translationY - other.translationY) < Geometry.smallMetricDistance &&\n            Math.abs(this.a1 - other.a1) < Geometry.smallFraction &&\n            Math.abs(this.b1 - other.b1) < Geometry.smallFraction &&\n            Math.abs(this.a2 - other.a2) < Geometry.smallFraction &&\n            Math.abs(this.b2 - other.b2) < Geometry.smallFraction);\n    }\n}\n/** This class encapsulates the projection of the CRS. The projection relies on a projection method and a set\n *  of projection parameters specific to projection method selected to flatten the surface of the model of the Earth\n *  defines as a geodetic ellipsoid. The flattening and the distortion angular, linear, scale from the process varies between methods.\n *  Refer to appropriate external documentation for details.\n *  @note Various property sets are required for specific projection methods. The current class implementation does not enforce\n *        these rules yet and it is possible to define or not define any property regardless the method used.\n *  @public\n */\nexport class Projection {\n    constructor(_data) {\n        if (_data) {\n            this.method = _data.method;\n            this.falseEasting = _data.falseEasting;\n            this.falseNorthing = _data.falseNorthing;\n            this.centralMeridian = _data.centralMeridian;\n            this.latitudeOfOrigin = _data.latitudeOfOrigin;\n            this.longitudeOfOrigin = _data.longitudeOfOrigin;\n            this.scaleFactor = _data.scaleFactor;\n            this.elevationAboveGeoid = _data.elevationAboveGeoid;\n            this.geoidSeparation = _data.geoidSeparation;\n            this.affine = _data.affine ? AffineTransform.fromJSON(_data.affine) : undefined;\n            this.standardParallel = _data.standardParallel;\n            this.standardParallel1 = _data.standardParallel1;\n            this.standardParallel2 = _data.standardParallel2;\n            this.zoneNumber = _data.zoneNumber;\n            this.hemisphere = _data.hemisphere;\n            this.centralPointLongitude = _data.centralPointLongitude;\n            this.centralPointLatitude = _data.centralPointLatitude;\n            this.point1Longitude = _data.point1Longitude;\n            this.point1Latitude = _data.point1Latitude;\n            this.point2Longitude = _data.point2Longitude;\n            this.point2Latitude = _data.point2Latitude;\n            this.danishSystem34Region = _data.danishSystem34Region;\n            this.azimuth = _data.azimuth;\n        }\n    }\n    /** Creates a Projection from JSON representation.\n     * @public */\n    static fromJSON(data) {\n        return new Projection(data);\n    }\n    /** Creates a JSON from the Projection definition\n     * @public */\n    toJSON() {\n        const data = { method: this.method };\n        data.falseEasting = this.falseEasting;\n        data.falseNorthing = this.falseNorthing;\n        data.centralMeridian = this.centralMeridian;\n        data.latitudeOfOrigin = this.latitudeOfOrigin;\n        data.longitudeOfOrigin = this.longitudeOfOrigin;\n        data.scaleFactor = this.scaleFactor;\n        data.elevationAboveGeoid = this.elevationAboveGeoid;\n        data.geoidSeparation = this.geoidSeparation;\n        data.affine = this.affine ? this.affine.toJSON() : undefined;\n        data.standardParallel = this.standardParallel;\n        data.standardParallel1 = this.standardParallel1;\n        data.standardParallel2 = this.standardParallel2;\n        data.zoneNumber = this.zoneNumber;\n        data.hemisphere = this.hemisphere;\n        data.centralPointLongitude = this.centralPointLongitude;\n        data.centralPointLatitude = this.centralPointLatitude;\n        data.point1Longitude = this.point1Longitude;\n        data.point1Latitude = this.point1Latitude;\n        data.point2Longitude = this.point2Longitude;\n        data.point2Latitude = this.point2Latitude;\n        data.danishSystem34Region = this.danishSystem34Region;\n        data.azimuth = this.azimuth;\n        return data;\n    }\n    /** Compares two projections. It is a strict compare operation as descriptive data is compared\n     * but a minuscule tolerance is applied to number compares.\n     *  @public */\n    equals(other) {\n        if (this.method !== other.method ||\n            this.zoneNumber !== other.zoneNumber ||\n            this.hemisphere !== other.hemisphere ||\n            this.danishSystem34Region !== other.danishSystem34Region)\n            return false;\n        // Note that even though falseEasting, falseNorthing, elevationAboveGeoid and geoidSeparation are expressed\n        // in the units of the projection which can be foot or US survey foot, they are still within the same order\n        // of size that Geometry.smallMetricDistance can be used effectively.\n        if (!Geometry.isAlmostEqualOptional(this.falseEasting, other.falseEasting, Geometry.smallMetricDistance) ||\n            !Geometry.isAlmostEqualOptional(this.falseNorthing, other.falseNorthing, Geometry.smallMetricDistance) ||\n            !Geometry.isAlmostEqualOptional(this.centralMeridian, other.centralMeridian, Geometry.smallAngleDegrees) ||\n            !Geometry.isAlmostEqualOptional(this.latitudeOfOrigin, other.latitudeOfOrigin, Geometry.smallAngleDegrees) ||\n            !Geometry.isAlmostEqualOptional(this.longitudeOfOrigin, other.longitudeOfOrigin, Geometry.smallAngleDegrees) ||\n            !Geometry.isAlmostEqualOptional(this.scaleFactor, other.scaleFactor, Geometry.smallFraction) ||\n            !Geometry.isAlmostEqualOptional(this.elevationAboveGeoid, other.elevationAboveGeoid, Geometry.smallMetricDistance) ||\n            !Geometry.isAlmostEqualOptional(this.geoidSeparation, other.geoidSeparation, Geometry.smallMetricDistance) ||\n            !Geometry.isAlmostEqualOptional(this.standardParallel, other.standardParallel, Geometry.smallAngleDegrees) ||\n            !Geometry.isAlmostEqualOptional(this.standardParallel1, other.standardParallel1, Geometry.smallAngleDegrees) ||\n            !Geometry.isAlmostEqualOptional(this.standardParallel2, other.standardParallel2, Geometry.smallAngleDegrees) ||\n            !Geometry.isAlmostEqualOptional(this.centralPointLongitude, other.centralPointLongitude, Geometry.smallAngleDegrees) ||\n            !Geometry.isAlmostEqualOptional(this.centralPointLatitude, other.centralPointLatitude, Geometry.smallAngleDegrees) ||\n            !Geometry.isAlmostEqualOptional(this.point1Longitude, other.point1Longitude, Geometry.smallAngleDegrees) ||\n            !Geometry.isAlmostEqualOptional(this.point1Latitude, other.point1Latitude, Geometry.smallAngleDegrees) ||\n            !Geometry.isAlmostEqualOptional(this.point2Longitude, other.point2Longitude, Geometry.smallAngleDegrees) ||\n            !Geometry.isAlmostEqualOptional(this.point2Latitude, other.point2Latitude, Geometry.smallAngleDegrees) ||\n            !Geometry.isAlmostEqualOptional(this.azimuth, other.azimuth, Geometry.smallAngleDegrees))\n            return false;\n        if (this.affine && other.affine) {\n            if (!this.affine.equals(other.affine))\n                return false;\n        }\n        else {\n            if (this.affine || other.affine)\n                return false;\n        }\n        return true;\n    }\n}\n/** A 2D cartographic point in degrees\n *  @public\n */\nexport class Carto2DDegrees {\n    /** Returns or sets the latitude in degrees. When setting the provided number must be between or equal from -90 to 90. */\n    get latitude() { return this._latitude; }\n    set latitude(newLatitude) {\n        if ((newLatitude <= 90.0) && (newLatitude >= -90.0))\n            this._latitude = newLatitude;\n    }\n    constructor(data) {\n        this.latitude = 0.0; /* make sure latitude is init even if invalid latitude provided */\n        if (data) {\n            this.latitude = data.latitude;\n            this.longitude = data.longitude;\n        }\n    }\n    /** Creates a Carto2DDegrees object from JSON representation.\n     * @public */\n    static fromJSON(data) {\n        return new Carto2DDegrees(data);\n    }\n    /** Creates a JSON from the Carto2DDegrees definition\n     * @public */\n    toJSON() {\n        return { latitude: this.latitude, longitude: this.longitude };\n    }\n    /** Compares two Carto2DDegrees object. It applies a minuscule tolerance to compares.\n     *  @public */\n    equals(other) {\n        return (Math.abs(this.latitude - other.latitude) < Geometry.smallAngleDegrees &&\n            Math.abs(this.longitude - other.longitude) < Geometry.smallAngleDegrees);\n    }\n}\n//# sourceMappingURL=Projection.js.map",
      "start": 1693508120783,
      "end": 1693508120894,
      "sourcemaps": null
    }
  ]
}
