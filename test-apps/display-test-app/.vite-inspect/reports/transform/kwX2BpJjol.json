{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tile/map/ImageryTileTree.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tiles\n */\nimport { assert, compareBooleans, compareNumbers, compareStrings, compareStringsOrUndefined, dispose, Logger } from \"@itwin/core-bentley\";\nimport { Angle, Range3d, Transform } from \"@itwin/core-geometry\";\nimport { ImageSource, RenderTexture } from \"@itwin/core-common\";\nimport { IModelApp } from \"../../IModelApp\";\nimport { MapCartoRectangle, MapLayerTileTreeReference, MapTileTreeScaleRangeVisibility, QuadId, RealityTile, RealityTileLoader, RealityTileTree, TileLoadPriority, TileTreeLoadStatus, } from \"../internal\";\nconst loggerCategory = \"ImageryMapTileTree\";\n/** @internal */\nexport class ImageryMapTile extends RealityTile {\n    constructor(params, imageryTree, quadId, rectangle) {\n        super(params, imageryTree);\n        this.imageryTree = imageryTree;\n        this.quadId = quadId;\n        this.rectangle = rectangle;\n        this._mapTileUsageCount = 0;\n        this._outOfLodRange = this.depth < imageryTree.minDepth;\n    }\n    get texture() { return this._texture; }\n    get tilingScheme() { return this.imageryTree.tilingScheme; }\n    get isDisplayable() { return (this.depth > 1) && super.isDisplayable; }\n    get isOutOfLodRange() { return this._outOfLodRange; }\n    setContent(content) {\n        this._texture = content.imageryTexture; // No dispose - textures may be shared by terrain tiles so let garbage collector dispose them.\n        if (undefined === content.imageryTexture)\n            this.parent.setLeaf(); // Avoid traversing bing branches after no graphics is found.\n        this.setIsReady();\n    }\n    selectCartoDrapeTiles(drapeTiles, highResolutionReplacementTiles, rectangleToDrape, drapePixelSize, args) {\n        // Base draping overlap on width rather than height so that tiling schemes with multiple root nodes overlay correctly.\n        const isSmallerThanDrape = (this.rectangle.xLength() / this.maximumSize) < drapePixelSize;\n        if ((this.isLeaf) // Include leaves so tiles get stretched past max LOD levels. (Only for base imagery layer)\n            || isSmallerThanDrape\n            || this._anyChildNotFound) {\n            if (this.isOutOfLodRange) {\n                drapeTiles.push(this);\n                this.setIsReady();\n            }\n            else if (this.isLeaf && !isSmallerThanDrape && !this._anyChildNotFound) {\n                // These tiles are selected because we are beyond the max LOD of the tile tree,\n                // might be used to display \"stretched\" tiles instead of having blank.\n                highResolutionReplacementTiles.push(this);\n            }\n            else {\n                drapeTiles.push(this);\n            }\n            return TileTreeLoadStatus.Loaded;\n        }\n        let status = this.loadChildren();\n        if (TileTreeLoadStatus.Loading === status) {\n            args.markChildrenLoading();\n        }\n        else if (TileTreeLoadStatus.Loaded === status) {\n            if (undefined !== this.children) {\n                for (const child of this.children) {\n                    const mapChild = child;\n                    if (mapChild.rectangle.intersectsRange(rectangleToDrape))\n                        status = mapChild.selectCartoDrapeTiles(drapeTiles, highResolutionReplacementTiles, rectangleToDrape, drapePixelSize, args);\n                    if (TileTreeLoadStatus.Loaded !== status)\n                        break;\n                }\n            }\n        }\n        return status;\n    }\n    markMapTileUsage() {\n        this._mapTileUsageCount++;\n    }\n    releaseMapTileUsage() {\n        assert(!this._texture || this._mapTileUsageCount > 0);\n        if (this._mapTileUsageCount)\n            this._mapTileUsageCount--;\n    }\n    /** @internal */\n    setLeaf() {\n        // Don't potentially re-request the children later.\n        this.disposeChildren();\n        this._isLeaf = true;\n        this._childrenLoadStatus = TileTreeLoadStatus.Loaded;\n    }\n    _loadChildren(resolve, _reject) {\n        const imageryTree = this.imageryTree;\n        const resolveChildren = (childIds) => {\n            const children = new Array();\n            const childrenAreLeaves = (this.depth + 1) === imageryTree.maxDepth;\n            // If children depth is lower than min LOD, mark them as disabled.\n            // This is important: if those tiles are requested and the server refuse to serve them,\n            // they will be marked as not found and their descendant will never be displayed.\n            childIds.forEach((quadId) => {\n                const rectangle = imageryTree.tilingScheme.tileXYToRectangle(quadId.column, quadId.row, quadId.level);\n                const range = Range3d.createXYZXYZ(rectangle.low.x, rectangle.low.x, 0, rectangle.high.x, rectangle.high.y, 0);\n                const maximumSize = imageryTree.imageryLoader.maximumScreenSize;\n                const tile = new ImageryMapTile({ parent: this, isLeaf: childrenAreLeaves, contentId: quadId.contentId, range, maximumSize }, imageryTree, quadId, rectangle);\n                children.push(tile);\n            });\n            resolve(children);\n        };\n        imageryTree.imageryLoader.generateChildIds(this, resolveChildren);\n    }\n    _collectStatistics(stats) {\n        super._collectStatistics(stats);\n        if (this._texture)\n            stats.addTexture(this._texture.bytesUsed);\n    }\n    freeMemory() {\n        // ###TODO MapTiles and ImageryMapTiles share resources and don't currently interact well with TileAdmin.freeMemory(). Opt out for now.\n    }\n    disposeContents() {\n        if (0 === this._mapTileUsageCount) {\n            super.disposeContents();\n            this.disposeTexture();\n        }\n    }\n    disposeTexture() {\n        this._texture = dispose(this._texture);\n    }\n    dispose() {\n        this._mapTileUsageCount = 0;\n        super.dispose();\n    }\n}\n/** Object that holds various state values for an ImageryTileTree\n * @internal */\nexport class ImageryTileTreeState {\n    constructor() {\n        this._scaleRangeVis = MapTileTreeScaleRangeVisibility.Unknown;\n    }\n    /** Get the scale range visibility of the imagery tile tree.\n     * @returns the scale range visibility of the imagery tile tree.\n     */\n    getScaleRangeVisibility() { return this._scaleRangeVis; }\n    /** Makes a deep copy of the current object.\n     */\n    clone() {\n        const clone = new ImageryTileTreeState();\n        clone._scaleRangeVis = this._scaleRangeVis;\n        return clone;\n    }\n    /** Reset the scale range visibility of imagery tile tree (i.e. unknown)\n     */\n    reset() {\n        this._scaleRangeVis = MapTileTreeScaleRangeVisibility.Unknown;\n    }\n    /** Sets the scale range visibility of the current imagery tile tree.\n     * The state will be derived based on the previous visibility values:\n     * Initial state: 'Unknown'\n     * The first call will set the state to either: 'Visible' or 'Hidden'.\n     * If subsequent visibility values are not consistent with the first visibility state, the state become 'Partial',\n     * meaning the imagery tree currently contains a mixed of tiles being in range and out of range.\n     */\n    setScaleRangeVisibility(visible) {\n        if (this._scaleRangeVis === MapTileTreeScaleRangeVisibility.Unknown) {\n            this._scaleRangeVis = (visible ? MapTileTreeScaleRangeVisibility.Visible : MapTileTreeScaleRangeVisibility.Hidden);\n        }\n        else if ((visible && this._scaleRangeVis === MapTileTreeScaleRangeVisibility.Hidden) || (!visible && this._scaleRangeVis === MapTileTreeScaleRangeVisibility.Visible)) {\n            this._scaleRangeVis = MapTileTreeScaleRangeVisibility.Partial;\n        }\n    }\n}\n/** @internal */\nclass ImageryMapTileTree extends RealityTileTree {\n    constructor(params, _imageryLoader) {\n        super(params);\n        this._imageryLoader = _imageryLoader;\n        const rootQuadId = new QuadId(_imageryLoader.imageryProvider.tilingScheme.rootLevel, 0, 0);\n        this._rootTile = new ImageryMapTile(params.rootTile, this, rootQuadId, this.getTileRectangle(rootQuadId));\n    }\n    get tilingScheme() { return this._imageryLoader.imageryProvider.tilingScheme; }\n    addLogoCards(cards, vp) {\n        this._imageryLoader.addLogoCards(cards, vp);\n    }\n    getTileRectangle(quadId) {\n        return this.tilingScheme.tileXYToRectangle(quadId.column, quadId.row, quadId.level);\n    }\n    get imageryLoader() { return this._imageryLoader; }\n    get is3d() {\n        assert(false);\n        return false;\n    }\n    get viewFlagOverrides() {\n        assert(false);\n        return {};\n    }\n    get isContentUnbounded() {\n        assert(false);\n        return true;\n    }\n    _selectTiles(_args) {\n        assert(false);\n        return [];\n    }\n    draw(_args) { assert(false); }\n    selectCartoDrapeTiles(drapeTiles, highResolutionReplacementTiles, tileToDrape, args) {\n        const drapeRectangle = tileToDrape.rectangle.clone(ImageryMapTileTree._scratchDrapeRectangle);\n        // Base draping overlap on width rather than height so that tiling schemes with multiple root nodes overlay correctly.\n        const drapePixelSize = 1.05 * tileToDrape.rectangle.xLength() / tileToDrape.maximumSize;\n        drapeRectangle.scaleAboutCenterInPlace(ImageryMapTileTree._drapeIntersectionScale); // Contract slightly to avoid draping adjacent or slivers.\n        return this.rootTile.selectCartoDrapeTiles(drapeTiles, highResolutionReplacementTiles, drapeRectangle, drapePixelSize, args);\n    }\n    cartoRectangleFromQuadId(quadId) { return this.tilingScheme.tileXYToRectangle(quadId.column, quadId.row, quadId.level); }\n}\nImageryMapTileTree._scratchDrapeRectangle = MapCartoRectangle.createZero();\nImageryMapTileTree._drapeIntersectionScale = 1.0 - 1.0E-5;\nexport { ImageryMapTileTree };\nclass ImageryTileLoader extends RealityTileLoader {\n    constructor(_imageryProvider, _iModel) {\n        super();\n        this._imageryProvider = _imageryProvider;\n        this._iModel = _iModel;\n    }\n    computeTilePriority(tile) {\n        return 25 * (this._imageryProvider.usesCachedTiles ? 2 : 1) - tile.depth; // Always cached first then descending by depth (high resolution/front first)\n    } // Prioritized fast, cached tiles first.\n    get maxDepth() { return this._imageryProvider.maximumZoomLevel; }\n    get minDepth() { return this._imageryProvider.minimumZoomLevel; }\n    get priority() { return TileLoadPriority.Map; }\n    addLogoCards(cards, vp) {\n        this._imageryProvider.addLogoCards(cards, vp);\n    }\n    get maximumScreenSize() { return this._imageryProvider.maximumScreenSize; }\n    get imageryProvider() { return this._imageryProvider; }\n    async getToolTip(strings, quadId, carto, tree) { await this._imageryProvider.getToolTip(strings, quadId, carto, tree); }\n    async getMapFeatureInfo(featureInfos, quadId, carto, tree, hit) {\n        await this._imageryProvider.getFeatureInfo(featureInfos, quadId, carto, tree, hit);\n    }\n    generateChildIds(tile, resolveChildren) { return this._imageryProvider.generateChildIds(tile, resolveChildren); }\n    /** Load this tile's children, possibly asynchronously. Pass them to `resolve`, or an error to `reject`. */\n    async loadChildren(_tile) {\n        assert(false);\n        return undefined;\n    }\n    async requestTileContent(tile, _isCanceled) {\n        const quadId = QuadId.createFromContentId(tile.contentId);\n        return this._imageryProvider.loadTile(quadId.row, quadId.column, quadId.level);\n    }\n    getRequestChannel(_tile) {\n        // ###TODO use hostname from url - but so many layers to go through to get that...\n        return IModelApp.tileAdmin.channels.getForHttp(\"itwinjs-imagery\");\n    }\n    async loadTileContent(tile, data, system) {\n        assert(data instanceof ImageSource);\n        assert(tile instanceof ImageryMapTile);\n        const content = {};\n        const texture = await this.loadTextureImage(data, system);\n        if (undefined === texture)\n            return content;\n        content.imageryTexture = texture;\n        return content;\n    }\n    async loadTextureImage(source, system) {\n        try {\n            return await system.createTextureFromSource({\n                type: RenderTexture.Type.FilteredTileSection,\n                source,\n            });\n        }\n        catch {\n            return undefined;\n        }\n    }\n}\n/** Supplies a TileTree that can load and draw tiles based on our imagery provider.\n * The TileTree is uniquely identified by its imagery type.\n */\nclass ImageryMapLayerTreeSupplier {\n    /** Return a numeric value indicating how two tree IDs are ordered relative to one another.\n     * This allows the ID to serve as a lookup key to find the corresponding TileTree.\n     */\n    compareTileTreeIds(lhs, rhs) {\n        let cmp = compareStrings(lhs.settings.formatId, rhs.settings.formatId);\n        if (0 === cmp) {\n            cmp = compareStrings(lhs.settings.url, rhs.settings.url);\n            if (0 === cmp) {\n                cmp = compareStringsOrUndefined(lhs.settings.userName, rhs.settings.userName);\n                if (0 === cmp) {\n                    cmp = compareStringsOrUndefined(lhs.settings.password, rhs.settings.password);\n                    if (0 === cmp) {\n                        cmp = compareBooleans(lhs.settings.transparentBackground, rhs.settings.transparentBackground);\n                        if (0 === cmp) {\n                            cmp = compareNumbers(lhs.settings.subLayers.length, rhs.settings.subLayers.length);\n                            if (0 === cmp) {\n                                for (let i = 0; i < lhs.settings.subLayers.length && 0 === cmp; i++) {\n                                    cmp = compareStrings(lhs.settings.subLayers[i].name, rhs.settings.subLayers[i].name);\n                                    if (0 === cmp) {\n                                        cmp = compareBooleans(lhs.settings.subLayers[i].visible, rhs.settings.subLayers[i].visible);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return cmp;\n    }\n    /** The first time a tree of a particular imagery type is requested, this function creates it. */\n    async createTileTree(id, iModel) {\n        const imageryProvider = IModelApp.mapLayerFormatRegistry.createImageryProvider(id.settings);\n        if (undefined === imageryProvider) {\n            Logger.logError(loggerCategory, `Failed to create imagery provider for format '${id.settings.formatId}'`);\n            return undefined;\n        }\n        try {\n            await imageryProvider.initialize();\n        }\n        catch (e) {\n            Logger.logError(loggerCategory, `Could not initialize imagery provider for map layer '${id.settings.name}' : ${e}`);\n            throw e;\n        }\n        const modelId = iModel.transientIds.getNext();\n        const tilingScheme = imageryProvider.tilingScheme;\n        const rootLevel = (1 === tilingScheme.numberOfLevelZeroTilesX && 1 === tilingScheme.numberOfLevelZeroTilesY) ? 0 : -1;\n        const rootTileId = new QuadId(rootLevel, 0, 0).contentId;\n        const rootRange = Range3d.createXYZXYZ(-Angle.piRadians, -Angle.piOver2Radians, 0, Angle.piRadians, Angle.piOver2Radians, 0);\n        const rootTileProps = { contentId: rootTileId, range: rootRange, maximumSize: 0 };\n        const loader = new ImageryTileLoader(imageryProvider, iModel);\n        const treeProps = { rootTile: rootTileProps, id: modelId, modelId, iModel, location: Transform.createIdentity(), priority: TileLoadPriority.Map, loader, gcsConverterAvailable: false };\n        return new ImageryMapTileTree(treeProps, loader);\n    }\n}\nconst imageryTreeSupplier = new ImageryMapLayerTreeSupplier();\n/** A reference to one of our tile trees. The specific TileTree drawn may change when the desired imagery type or target iModel changes.\n * @internal\n */\nexport class ImageryMapLayerTreeReference extends MapLayerTileTreeReference {\n    constructor(layerSettings, layerIndex, iModel) {\n        super(layerSettings, layerIndex, iModel);\n    }\n    get castsShadows() { return false; }\n    /** Return the owner of the TileTree to draw. */\n    get treeOwner() {\n        return this.iModel.tiles.getTileTreeOwner({ settings: this._layerSettings }, imageryTreeSupplier);\n    }\n    resetTreeOwner() {\n        return this.iModel.tiles.resetTileTreeOwner({ settings: this._layerSettings }, imageryTreeSupplier);\n    }\n    get imageryProvider() {\n        const tree = this.treeOwner.load();\n        if (!tree || !(tree instanceof ImageryMapTileTree))\n            return undefined;\n        return tree.imageryLoader.imageryProvider;\n    }\n}\n//# sourceMappingURL=ImageryTileTree.js.map",
      "start": 1693508122076,
      "end": 1693508122280,
      "sourcemaps": null
    }
  ]
}
