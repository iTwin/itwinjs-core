{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/TargetUniforms.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { Vector3d } from \"@itwin/core-geometry\";\nimport { BatchUniforms } from \"./BatchUniforms\";\nimport { BranchUniforms } from \"./BranchUniforms\";\nimport { FrustumUniforms } from \"./FrustumUniforms\";\nimport { HiliteUniforms } from \"./HiliteUniforms\";\nimport { LightingUniforms } from \"./LightingUniforms\";\nimport { ShadowUniforms } from \"./ShadowUniforms\";\nimport { StyleUniforms } from \"./StyleUniforms\";\nimport { desync, sync } from \"./Sync\";\nimport { ThematicUniforms } from \"./ThematicUniforms\";\nimport { ViewRectUniforms } from \"./ViewRectUniforms\";\nimport { RealityModelUniforms } from \"./RealityModelUniforms\";\nimport { AtmosphereUniforms } from \"./AtmosphereUniforms\";\nclass PixelWidthFactor {\n    constructor() {\n        /** The pixel width factor depends on both the frustum and the view rect. It also depends on the frustum scale associated with the current Branch. */\n        this._rectSync = {};\n        this._frustumSync = {};\n        this._branchSync = {};\n        this._factor = 0;\n        this.syncKey = 0;\n    }\n    bind(uniform, uniforms) {\n        if (!sync(uniforms.frustum, this._frustumSync) || !sync(uniforms.viewRect, this._rectSync) || !sync(uniforms.branch, this._branchSync))\n            this.compute(uniforms.frustum, uniforms.viewRect.width, uniforms.viewRect.height, uniforms.branch.top.frustumScale);\n        if (!sync(this, uniform))\n            uniform.setUniform1f(this._factor);\n    }\n    compute(frustumUniforms, width, height, scale) {\n        desync(this);\n        const frustumPlanes = frustumUniforms.planes;\n        const top = frustumPlanes[0];\n        const bottom = frustumPlanes[1];\n        const left = frustumPlanes[2];\n        const right = frustumPlanes[3];\n        let halfPixelWidth;\n        let halfPixelHeight;\n        const frustum = frustumUniforms.frustum;\n        if (2 /* FrustumUniformType.Perspective */ === frustumUniforms.type) {\n            const inverseNear = 1.0 / frustum[0];\n            const tanTheta = top * inverseNear;\n            halfPixelHeight = scale.x * tanTheta / height;\n            halfPixelWidth = scale.y * tanTheta / width;\n        }\n        else {\n            halfPixelWidth = scale.x * 0.5 * (right - left) / width;\n            halfPixelHeight = scale.y * 0.5 * (top - bottom) / height;\n        }\n        this._factor = Math.sqrt(halfPixelWidth * halfPixelWidth + halfPixelHeight * halfPixelHeight);\n    }\n}\n// Direction in view space used if solar shadows are disabled and LightSettings.useSolarLighting is false.\nconst defaultSunDirectionView = new Vector3d(0.272166, 0.680414, 0.680414);\nclass SunDirection {\n    constructor() {\n        this.syncKey = 0;\n        this._haveWorldDir = false;\n        this._worldDir = Vector3d.unitZ();\n        this._viewDir = defaultSunDirectionView.clone();\n        this._viewDir32 = new Float32Array(3);\n        this._updated = true;\n    }\n    update(sunDir) {\n        const haveWorldDir = undefined !== sunDir;\n        if (haveWorldDir !== this._haveWorldDir || (sunDir && !sunDir.isExactEqual(this._worldDir))) {\n            this._updated = true;\n            desync(this);\n            this._haveWorldDir = haveWorldDir;\n            if (sunDir) {\n                sunDir.clone(this._worldDir);\n                this._worldDir.normalizeInPlace();\n            }\n        }\n    }\n    bind(uniform, uniforms) {\n        if (!sync(uniforms.frustum, this) || this._updated) {\n            if (this._haveWorldDir) {\n                uniforms.frustum.viewMatrix.multiplyVector(this._worldDir, this._viewDir);\n                this._viewDir.negate(this._viewDir);\n            }\n            else {\n                defaultSunDirectionView.clone(this._viewDir);\n            }\n            this._viewDir.normalizeInPlace();\n            this._viewDir32[0] = this._viewDir.x;\n            this._viewDir32[1] = this._viewDir.y;\n            this._viewDir32[2] = this._viewDir.z;\n            desync(this);\n            this._updated = false;\n        }\n        if (!sync(this, uniform))\n            uniform.setUniform3fv(this._viewDir32);\n    }\n}\n/** Holds state for commonly-used uniforms to avoid unnecessary recomputation, owned by a Target.\n * DO NOT directly modify exposed members of the objects exposed by this class. Use their APIs.\n * e.g., code like `target.uniforms.frustum.projectionMatrix.setFrom(someOtherMatrix)` or `target.uniforms.branch.top.setViewFlags(blah)` will cause bugs.\n * @internal\n */\nexport class TargetUniforms {\n    constructor(target) {\n        this.viewRect = new ViewRectUniforms();\n        this.hilite = new HiliteUniforms();\n        this.style = new StyleUniforms();\n        this.lights = new LightingUniforms();\n        this.thematic = new ThematicUniforms();\n        this.realityModel = new RealityModelUniforms();\n        this.atmosphere = new AtmosphereUniforms();\n        this._pixelWidthFactor = new PixelWidthFactor();\n        this._sunDirection = new SunDirection();\n        this.frustum = new FrustumUniforms();\n        this.branch = new BranchUniforms(target);\n        this.batch = new BatchUniforms(target, this.branch.createBatchState());\n        this.shadow = new ShadowUniforms(target);\n    }\n    getProjectionMatrix(forViewCoords) {\n        return forViewCoords ? this.viewRect.projectionMatrix : this.frustum.projectionMatrix;\n    }\n    getProjectionMatrix32(forViewCoords) {\n        return forViewCoords ? this.viewRect.projectionMatrix32 : this.frustum.projectionMatrix32;\n    }\n    bindProjectionMatrix(uniform, forViewCoords) {\n        if (forViewCoords)\n            this.viewRect.bindProjectionMatrix(uniform);\n        else\n            this.frustum.bindProjectionMatrix(uniform);\n    }\n    bindPixelWidthFactor(uniform) {\n        this._pixelWidthFactor.bind(uniform, this);\n    }\n    bindSunDirection(uniform) {\n        this._sunDirection.bind(uniform, this);\n    }\n    updateRenderPlan(plan) {\n        this.style.update(plan);\n        this.hilite.update(plan.hiliteSettings, plan.emphasisSettings);\n        let sunDir;\n        if (plan.lights) {\n            this.lights.update(plan.lights);\n            const useSunDir = plan.viewFlags.shadows || plan.lights.solar.alwaysEnabled;\n            if (useSunDir)\n                sunDir = plan.lights.solar.direction;\n        }\n        this._sunDirection.update(sunDir);\n    }\n}\n//# sourceMappingURL=TargetUniforms.js.map",
      "start": 1693508122296,
      "end": 1693508122486,
      "sourcemaps": null
    }
  ]
}
