{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/numerics/Newton.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Numerics\n */\nimport { Geometry } from \"../Geometry\";\nimport { Plane3dByOriginAndVectors } from \"../geometry3d/Plane3dByOriginAndVectors\";\nimport { Point2d, Vector2d } from \"../geometry3d/Point2dVector2d\";\nimport { SmallSystem } from \"./Polynomials\";\n// cspell:word currentdFdX\n/** base class for Newton iterations in various dimensions.\n * Dimension-specific classes carry all dimension-related data and answer generalized queries\n * from this base class.\n * @internal\n */\nexport class AbstractNewtonIterator {\n    /**\n     * @param stepSizeTarget tolerance to consider a single step converged.\n     * This number should be \"moderately\" strict.   Because 2 successive convergences are required,\n     * it is expected that a first \"accept\" for (say) 10 to 14 digit step will be followed by another\n     * iteration.   A well behaved newton would then hypothetically double the number of digits to\n     * 20 to 28.  Since the IEEE double only carries 16 digits, this second-convergence step will\n     * typically achieve full precision.\n     * @param successiveConvergenceTarget number of successive convergences required for acceptance.\n     * @param maxIterations max number of iterations.   A typical newton step converges in 3 to 6 iterations.\n     *     Allow 15 to 20 to catch difficult cases.\n     */\n    constructor(stepSizeTolerance = 1.0e-11, successiveConvergenceTarget = 2, maxIterations = 15) {\n        /** Number of consecutive steps which passed convergence condition */\n        this._numAccepted = 0;\n        /** number of iterations (incremented at each step) */\n        this.numIterations = 0;\n        this._stepSizeTolerance = stepSizeTolerance;\n        this._successiveConvergenceTarget = successiveConvergenceTarget;\n        this._maxIterations = maxIterations;\n    }\n    /**\n     * Test if a step is converged.\n     * * Convergence is accepted with enough (_successiveConvergenceTarget) small steps (according to _stepSizeTolerance) occur in succession.\n     * @param delta step size as reported by currentStepSize\n     */\n    testConvergence(delta) {\n        if (Math.abs(delta) < this._stepSizeTolerance) {\n            this._numAccepted++;\n            return this._numAccepted >= this._successiveConvergenceTarget;\n        }\n        this._numAccepted = 0;\n        return false;\n    }\n    /**\n     * Run iterations, calling various methods from base and derived classes:\n     * * computeStep -- typically evaluate derivatives and solve linear system.\n     * * currentStepSize -- return numeric measure of the step just computed by computeStep\n     * * testConvergence -- test if the step from currentStepSize (along with recent steps) is converged.\n     * * applyCurrentStep -- apply the step to the independent variables\n     */\n    runIterations() {\n        this._numAccepted = 0;\n        this.numIterations = 0;\n        while (this.numIterations++ < this._maxIterations && this.computeStep()) {\n            if (this.testConvergence(this.currentStepSize())\n                && this.applyCurrentStep(true)) {\n                return true;\n            }\n            this.applyCurrentStep(false);\n        }\n        return false;\n    }\n}\n/** object to evaluate a newton function.  The object must retain most-recent function and derivative\n * values for immediate query.\n * @internal\n */\nexport class NewtonEvaluatorRtoRD {\n}\n/**\n * Newton iterator for use when both function and derivative can be evaluated.\n * @internal\n */\nexport class Newton1dUnbounded extends AbstractNewtonIterator {\n    /**\n     * Constructor for 1D newton iteration with approximate derivatives.\n     * @param func function that returns both function and derivative.\n     */\n    constructor(func) {\n        super();\n        this._func = func;\n        this.setTarget(0);\n    }\n    /** Set the independent variable */\n    setX(x) { this._currentX = x; return true; }\n    /** Get the independent variable */\n    getX() { return this._currentX; }\n    /** Set the target function value */\n    setTarget(y) { this._target = y; }\n    /** move the current X by the just-computed step */\n    applyCurrentStep() { return this.setX(this._currentX - this._currentStep); }\n    /** Compute the univariate newton step. */\n    computeStep() {\n        if (this._func.evaluate(this._currentX)) {\n            const dx = Geometry.conditionalDivideFraction(this._func.currentF - this._target, this._func.currentdFdX);\n            if (dx !== undefined) {\n                this._currentStep = dx;\n                return true;\n            }\n        }\n        return false;\n    }\n    /** Return the current step size as a relative number. */\n    currentStepSize() {\n        return Math.abs(this._currentStep / (1.0 + Math.abs(this._currentX)));\n    }\n}\n/** object to evaluate a newton function (without derivative).  The object must retain most-recent function value.\n * @internal\n */\nexport class NewtonEvaluatorRtoR {\n}\n/** Newton iteration for a univariate function, using approximate derivatives.\n * @internal\n */\nexport class Newton1dUnboundedApproximateDerivative extends AbstractNewtonIterator {\n    /**\n     * Constructor for 1D newton iteration with approximate derivatives.\n     * @param func function that returns both function and derivative.\n     */\n    constructor(func) {\n        super();\n        this._func = func;\n        this.derivativeH = 1.0e-8;\n    }\n    /** Set the x (independent, iterated) value */\n    setX(x) { this._currentX = x; return true; }\n    /** Get the independent variable */\n    getX() { return this._currentX; }\n    /** move the current X by the just-computed step */\n    applyCurrentStep() { return this.setX(this._currentX - this._currentStep); }\n    /** Univariate newton step computed with APPROXIMATE derivative. */\n    computeStep() {\n        if (this._func.evaluate(this._currentX)) {\n            const fA = this._func.currentF;\n            if (this._func.evaluate(this._currentX + this.derivativeH)) {\n                const fB = this._func.currentF;\n                const dx = Geometry.conditionalDivideFraction(fA, (fB - fA) / this.derivativeH);\n                if (dx !== undefined) {\n                    this._currentStep = dx;\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    /** Return the current step size as a relative number. */\n    currentStepSize() {\n        return Math.abs(this._currentStep / (1.0 + Math.abs(this._currentX)));\n    }\n}\n/** object to evaluate a 2-parameter newton function (with derivatives!!).\n * @internal\n */\nexport class NewtonEvaluatorRRtoRRD {\n    /**\n     * constructor.\n     * * This creates a currentF object to (repeatedly) receive function and derivatives.\n     */\n    constructor() {\n        this.currentF = Plane3dByOriginAndVectors.createXYPlane();\n    }\n}\n/**\n * Implement evaluation steps for newton iteration in 2 dimensions, using caller supplied NewtonEvaluatorRRtoRRD object.\n * @internal\n */\nexport class Newton2dUnboundedWithDerivative extends AbstractNewtonIterator {\n    constructor(func) {\n        super();\n        this._func = func;\n        this._currentStep = Vector2d.createZero();\n        this._currentUV = Point2d.createZero();\n    }\n    /** Set the current uv coordinates for current iteration */\n    setUV(x, y) { this._currentUV.set(x, y); return true; }\n    /** Get the current u coordinate */\n    getU() { return this._currentUV.x; }\n    /** Get the current v coordinate */\n    getV() { return this._currentUV.y; }\n    /** Move the currentUV coordinate by currentStep. */\n    applyCurrentStep() { return this.setUV(this._currentUV.x - this._currentStep.x, this._currentUV.y - this._currentStep.y); }\n    /** Evaluate the functions and derivatives at this._currentUV\n     * Invert the jacobian and compute the this._currentStep.\n     */\n    computeStep() {\n        if (this._func.evaluate(this._currentUV.x, this._currentUV.y)) {\n            const fA = this._func.currentF;\n            if (SmallSystem.linearSystem2d(fA.vectorU.x, fA.vectorV.x, fA.vectorU.y, fA.vectorV.y, fA.origin.x, fA.origin.y, this._currentStep))\n                return true;\n        }\n        return false;\n    }\n    /**\n     * Return the largest relative step of the x,y, components of the current step.\n     */\n    currentStepSize() {\n        return Geometry.maxAbsXY(this._currentStep.x / (1.0 + Math.abs(this._currentUV.x)), this._currentStep.y / (1.0 + Math.abs(this._currentUV.y)));\n    }\n}\n/**\n * SimpleNewton has static methods for newton methods with evaluated functions presented as immediate arguments (not function object)\n * @internal\n */\nexport class SimpleNewton {\n    /** Run a one-dimensional newton iteration with separate functions for function and derivative.\n     * * completion is at 2 (TWO) successive passes at (absoluteTolerance + relTol * abs (x)), where relTol is chosen internally.\n     * * absoluteTolerance is usually aggressively tight -- should come into play only for x near zero.\n     * * The relTol is fluffy (for instance around 1e-11) but in properly converging cases the extra pass after first success\n     *    normally moves to full machine precision.\n     * * This is an open-loop newton -- it just runs, and returns undefined if anything bad happens.\n     */\n    static runNewton1D(x, func, derivative, absoluteTolerance = Geometry.smallFloatingPoint) {\n        let numConverged = 0;\n        let tolerance;\n        const relTol = 1.0e-11;\n        for (let iteration = 0; iteration < 20; iteration++) {\n            const f = func(x);\n            const df = derivative(x);\n            if (f !== undefined && df !== undefined) {\n                const dx = Geometry.conditionalDivideCoordinate(f, df);\n                if (dx === undefined)\n                    return undefined;\n                x -= dx;\n                tolerance = absoluteTolerance + Math.abs(x) * relTol;\n                if (Math.abs(dx) < tolerance) {\n                    numConverged++;\n                    if (dx === 0.0 || numConverged > 1) // bypass convergence count on true 0 dx !\n                        return x;\n                }\n                else {\n                    numConverged = 0;\n                }\n            }\n        }\n        return undefined;\n    }\n}\n//# sourceMappingURL=Newton.js.map",
      "start": 1693508123461,
      "end": 1693508123622,
      "sourcemaps": null
    }
  ]
}
