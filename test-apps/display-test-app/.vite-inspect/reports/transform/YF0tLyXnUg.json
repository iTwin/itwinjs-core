{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/common/lib/esm/QPoint.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Geometry\n */\nimport { assert, Uint16ArrayBuilder } from \"@itwin/core-bentley\";\nimport { Point2d, Point3d, Range2d, Range3d, Vector2d, Vector3d, } from \"@itwin/core-geometry\";\n/**\n * Provides facilities for quantizing floating point values within a specified range into 16-bit unsigned integers.\n * This is a lossy compression technique.\n * Given a floating point range [min, max], a floating point value `x` within that range is quantized by subtracting\n * `min`, scaling the result according to `max`, and truncating the result to an integer.\n * Therefore min quantizes to 0, max to 0xffff, (min+max)/2 to 0x7fff, and so on.\n * These routines are chiefly used by classes like [[QPoint2d]] and [[QPoint3d]] to reduce the space required to store\n * coordinate values for [RenderGraphic]($frontend)s.\n * @public\n * @extensions\n */\nexport var Quantization;\n(function (Quantization) {\n    Quantization.rangeScale16 = 0xffff;\n    Quantization.rangeScale8 = 0xff;\n    /** Compute the scale factor required to quantize `extent` to `rangeScale` discrete values. */\n    function computeScale(extent, rangeScale = Quantization.rangeScale16) {\n        return 0.0 === extent ? extent : rangeScale / extent;\n    }\n    Quantization.computeScale = computeScale;\n    /** @internal */\n    function isInRange(qpos, rangeScale = Quantization.rangeScale16) {\n        return qpos >= 0.0 && qpos < rangeScale + 1.0;\n    }\n    Quantization.isInRange = isInRange;\n    /** Return `pos` quantized to the range [`origin`, `origin + rangeScale`].\n     * @see [[Quantization.unquantize]] for the inverse operation.\n     */\n    function quantize(pos, origin, scale, rangeScale = Quantization.rangeScale16) {\n        return Math.floor(Math.max(0.0, Math.min(rangeScale, 0.5 + (pos - origin) * scale)));\n    }\n    Quantization.quantize = quantize;\n    /** @internal */\n    function isQuantizable(pos, origin, scale, rangeScale = Quantization.rangeScale16) {\n        return isInRange(quantize(pos, origin, scale, rangeScale));\n    }\n    Quantization.isQuantizable = isQuantizable;\n    /** Give `qpos` quantized to the range [`origin`, `origin + rangeScale`], return the unquantized value.\n     * @see [[Quantization.quantize]] for the inverse operation.\n     */\n    function unquantize(qpos, origin, scale) {\n        return 0.0 === scale ? origin : origin + qpos / scale;\n    }\n    Quantization.unquantize = unquantize;\n    /** @internal */\n    function isQuantized(qpos) {\n        return isInRange(qpos) && qpos === Math.floor(qpos);\n    }\n    Quantization.isQuantized = isQuantized;\n})(Quantization || (Quantization = {}));\n/** Parameters used for [[Quantization]] of 2d points such that the `x` and `y` components are each quantized to 16-bit unsigned integers.\n * @see [[QPoint2d]] for the quantized representation of a [Point2d]($core-geometry).\n * @see [[QPoint2dList]] for a list of [[QPoint2d]]s quantized using a [[QParams2d]].\n * @public\n * @extensions\n */\nexport class QParams2d {\n    constructor(ox = 0, oy = 0, sx = 0, sy = 0) {\n        /** The origin of the quantization range. */\n        this.origin = new Point2d();\n        /** The scale applied to coordinates to quantize them. */\n        this.scale = new Point2d();\n        this.setFrom(ox, oy, sx, sy);\n    }\n    setFrom(ox, oy, sx, sy) {\n        this.origin.x = ox;\n        this.origin.y = oy;\n        this.scale.x = sx;\n        this.scale.y = sy;\n    }\n    /** Set [[origin]] and [[scale]] from `src`. */\n    copyFrom(src) {\n        this.setFrom(src.origin.x, src.origin.y, src.scale.x, src.scale.y);\n    }\n    /** Create a copy of these params.\n     * @param out If supplied, these QParams2d will be modified and returned; otherwise a new QParams2d object will be created and returned.\n     */\n    clone(out) {\n        const result = undefined !== out ? out : new QParams2d();\n        result.copyFrom(this);\n        return result;\n    }\n    /** Initialize these parameters to support quantization of values within the specified range. */\n    setFromRange(range, rangeScale = Quantization.rangeScale16) {\n        if (!range.isNull) {\n            this.setFrom(range.low.x, range.low.y, Quantization.computeScale(range.high.x - range.low.x, rangeScale), Quantization.computeScale(range.high.y - range.low.y, rangeScale));\n        }\n        else {\n            this.origin.x = this.origin.y = this.scale.x = this.scale.y = 0;\n        }\n    }\n    /** Create parameters to support quantization of values within the specified range. */\n    static fromRange(range, out, rangeScale = Quantization.rangeScale16) {\n        const params = undefined !== out ? out : new QParams2d();\n        params.setFromRange(range, rangeScale);\n        return params;\n    }\n    /** Return the unquantized point for the input `x` and `y` components. If `out` is supplied, it will be modified to hold the result and returned. */\n    unquantize(x, y, out) {\n        out = out ?? new Point2d();\n        out.x = Quantization.unquantize(x, this.origin.x, this.scale.x);\n        out.y = Quantization.unquantize(y, this.origin.y, this.scale.y);\n        return out;\n    }\n    /** Creates parameters supporting quantization of values within the range [-1.0, 1.0], appropriate for normalized 2d vectors. */\n    static fromNormalizedRange(rangeScale = Quantization.rangeScale16) {\n        return QParams2d.fromRange(Range2d.createArray([Point2d.create(-1, -1), Point2d.create(1, 1)]), undefined, rangeScale);\n    }\n    /** Create parameters supporting quantization of values within the range [0.0, 1.0]. */\n    static fromZeroToOne(rangeScale = Quantization.rangeScale16) {\n        return QParams2d.fromRange(Range2d.createArray([Point2d.create(0, 0), Point2d.create(1, 1)]), undefined, rangeScale);\n    }\n    /** Create parameters from origin and scale components */\n    static fromOriginAndScale(originX, originY, scaleX, scaleY) {\n        return new QParams2d(originX, originY, scaleX, scaleY);\n    }\n    /** @internal */\n    get rangeDiagonal() {\n        return Vector2d.createFrom({ x: 0 === this.scale.x ? 0 : Quantization.rangeScale16 / this.scale.x, y: 0 === this.scale.y ? 0 : Quantization.rangeScale16 / this.scale.y });\n    }\n    /** Return true if the point point is quantizable using these parameters. */\n    isQuantizable(point) {\n        return Quantization.isQuantizable(point.x, this.origin.x, this.scale.x) && Quantization.isQuantizable(point.y, this.origin.y, this.scale.y);\n    }\n    /** @alpha */\n    toJSON() {\n        return {\n            origin: { x: this.origin.x, y: this.origin.y },\n            scale: { x: this.scale.x, y: this.scale.y },\n        };\n    }\n    /** @alpha */\n    static fromJSON(src) {\n        return this.fromOriginAndScale(src.origin.x, src.origin.y, src.scale.x, src.scale.y);\n    }\n}\n/** Represents a [Point2d]($core-geometry) compressed such that each component `x` and `y` is quantized to the 16-bit integer range [0, 0xffff].\n * These are primarily used to reduce the space required for coordinates used by [RenderGraphic]($frontend)s.\n * @see [[QParams2d]] to define quantization parameters for a range of points.\n * @see [[QPoint2dList]] for a list of points all quantized to the same range.\n * @public\n * @extensions\n */\nexport class QPoint2d {\n    /** The quantized x component. */\n    get x() { return this._x; }\n    set x(x) {\n        assert(Quantization.isQuantized(x));\n        this._x = x;\n    }\n    /** The quantized y component. */\n    get y() { return this._y; }\n    set y(y) {\n        assert(Quantization.isQuantized(y));\n        this._y = y;\n    }\n    /** Construct with `x` and `y` initialized to zero. */\n    constructor() {\n        this._x = 0;\n        this._y = 0;\n    }\n    /** Initialize this point by quantizing the supplied { x, y } using the specified params */\n    init(pos, params) {\n        this.x = Quantization.quantize(pos.x, params.origin.x, params.scale.x);\n        this.y = Quantization.quantize(pos.y, params.origin.y, params.scale.y);\n    }\n    /** Create a quantized point from the supplied Point2d using the specified params */\n    static create(pos, params) {\n        const qpt = new QPoint2d();\n        qpt.init(pos, params);\n        return qpt;\n    }\n    /** Initialize `x` and `y` from `src`. */\n    copyFrom(src) {\n        this.x = src.x;\n        this.y = src.y;\n    }\n    /** Create a copy of this point.\n     * @param out If supplied, it will be modified in-place and returned; otherwise a new QPoint2d will be allocated and returned.\n     */\n    clone(out) {\n        const result = undefined !== out ? out : new QPoint2d();\n        result.copyFrom(this);\n        return result;\n    }\n    /**\n     * Set the x and y components directly.\n     * @param x Must be an integer in the range [0, 0xffff]\n     * @param y Must be an integer in the range [0, 0xffff]\n     */\n    setFromScalars(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    /**\n     * Create a QPoint2d directly from x and y components.\n     * @param x Must be an integer in the range [0, 0xffff]\n     * @param y Must be an integer in the range [0, 0xffff]\n     */\n    static fromScalars(x, y) {\n        const pt = new QPoint2d();\n        pt.setFromScalars(x, y);\n        return pt;\n    }\n    /** Return a Point2d unquantized according to the supplied `params`. If `out` is supplied, it will be modified in-place and returned. */\n    unquantize(params, out) {\n        const pt = undefined !== out ? out : new Point2d();\n        pt.x = Quantization.unquantize(this.x, params.origin.x, params.scale.x);\n        pt.y = Quantization.unquantize(this.y, params.origin.y, params.scale.y);\n        return pt;\n    }\n}\n/** @public\n * @extensions\n */\nexport var QPoint2dBuffer;\n(function (QPoint2dBuffer) {\n    const scratchQPoint2d = new QPoint2d();\n    /** Extracts the point at the specified index from a buffer.\n     * @param points The buffer in which each consecutive pair of integers is a 2d quantized point.\n     * @param pointIndex The index of the point to extract, ranging from zero to one less than the number of points in the buffer.\n     * @param result If supplied, a preallocated [[QPoint2d]] to initialize with the result and return.\n     * @returns The point at `pointIndex`.\n     * @throws Error if `pointIndex` is out of bounds.\n     */\n    function getQPoint(points, pointIndex, result) {\n        const index = pointIndex * 2;\n        const x = points[index + 0];\n        const y = points[index + 1];\n        if (undefined === x || undefined === y)\n            throw new Error(\"Index out of range\");\n        result = result ?? new QPoint2d();\n        result.setFromScalars(x, y);\n        return result;\n    }\n    QPoint2dBuffer.getQPoint = getQPoint;\n    /** Extracts and unquantizes the point at the specified index from a buffer.\n     * @param buffer The array of points and the quantization parameters.\n     * @param The index of the point to extract, ranging from zero to one less than the number of points in the buffer.\n     * @param result If supplied, a preallocated [Point2d]($core-geometry) to initialize with the result and return.\n     * @returns The point at `pointIndex`.\n     * @throws Error if `pointIndex` is out of bounds.\n     */\n    function unquantizePoint(buffer, pointIndex, result) {\n        const qpt = getQPoint(buffer.points, pointIndex, scratchQPoint2d);\n        return qpt.unquantize(buffer.params, result);\n    }\n    QPoint2dBuffer.unquantizePoint = unquantizePoint;\n})(QPoint2dBuffer || (QPoint2dBuffer = {}));\n/** A list of [[QPoint2d]]s all quantized to the same range.\n * @public\n * @extensions\n */\nexport class QPoint2dList {\n    /** The list of quantized points. */\n    get list() {\n        return this._list;\n    }\n    /** Construct an empty list set up to use the supplied quantization parameters. */\n    constructor(params) {\n        this._list = new Array();\n        this.params = params.clone();\n    }\n    /** Removes all points from the list. */\n    clear() {\n        this._list.length = 0;\n    }\n    /** Removes all points from the list and change the quantization parameters. */\n    reset(params) {\n        this.clear();\n        this.params.copyFrom(params);\n    }\n    /** Quantizes the supplied Point2d to this list's range and appends it to the list. */\n    add(pt) {\n        this._list.push(QPoint2d.create(pt, this.params));\n    }\n    /** Adds a previously-quantized point to this list. */\n    push(qpt) {\n        this._list.push(qpt.clone());\n    }\n    /** The number of points in the list. */\n    get length() {\n        return this._list.length;\n    }\n    /** Returns the unquantized value of the point at the specified index in the list. */\n    unquantize(index, out) {\n        assert(index < this.length);\n        if (index < this.length) {\n            return this._list[index].unquantize(this.params, out);\n        }\n        else {\n            return undefined !== out ? out : new Point2d();\n        }\n    }\n    /** Changes the quantization parameters and requantizes all points in the list to the new range.\n     * @note The loss of precision is compounded each time the points are requantized to a new range.\n     */\n    requantize(params) {\n        for (let i = 0; i < this.length; i++) {\n            const pt = this.unquantize(i);\n            this._list[i].init(pt, params);\n        }\n        this.params.copyFrom(params);\n    }\n    /** Extracts the current contents of the list as a Uint16Array such that the first element of the array corresponds to the first point's `x` component,\n     * the second to the first point's `y` component, and so on.\n     */\n    toTypedArray() {\n        const array = new Uint16Array(this.length * 2);\n        const pts = this._list;\n        for (let i = 0; i < this.length; i++) {\n            const pt = pts[i];\n            array[i * 2] = pt.x;\n            array[i * 2 + 1] = pt.y;\n        }\n        return array;\n    }\n    /**  Create from a Uint16Array laid out such that `array[0]` corresponds to the first point's `x` component, `array[1]` to the first point's `y` component, and so on. */\n    fromTypedArray(range, array) {\n        this.params.setFromRange(range);\n        this._list.length = array.length / 2;\n        for (let i = 0, j = 0; i < this.list.length; i++)\n            this._list[i] = QPoint2d.fromScalars(array[j++], array[j++]);\n    }\n    /** Construct a QPoint2dList containing all points in the supplied list, quantized to the range of those points. */\n    static fromPoints(points, out) {\n        let qPoints;\n        const qParams = QParams2d.fromRange(Range2d.createArray(points));\n        if (out) {\n            qPoints = out;\n            qPoints.reset(qParams);\n        }\n        else {\n            qPoints = new QPoint2dList(qParams);\n        }\n        for (const point of points)\n            qPoints.add(point);\n        return qPoints;\n    }\n}\n/** Parameters used for [[Quantization]] of 3d points such that the `x`, `y`, and `z` components are each quantized to 16-bit unsigned integers.\n * @see [[QPoint3d]] for the quantized representation of a [Point3d]($core-geometry).\n * @see [[QPoint3dList]] for a list of [[QPoint3d]]s quantized using a [[QParams3d]].\n * @public\n * @extensions\n */\nexport class QParams3d {\n    constructor(ox = 0, oy = 0, oz = 0, sx = 0, sy = 0, sz = 0) {\n        /** The origin of the quantization range. */\n        this.origin = new Point3d();\n        /** The scale applied to coordinates to quantize them. */\n        this.scale = new Point3d();\n        this.setFrom(ox, oy, oz, sx, sy, sz);\n    }\n    setFrom(ox, oy, oz, sx, sy, sz) {\n        this.origin.x = ox;\n        this.origin.y = oy;\n        this.origin.z = oz;\n        this.scale.x = sx;\n        this.scale.y = sy;\n        this.scale.z = sz;\n    }\n    /** Set `x`, `y`, and `z` from `src. */\n    copyFrom(src) {\n        this.setFrom(src.origin.x, src.origin.y, src.origin.z, src.scale.x, src.scale.y, src.scale.z);\n    }\n    /** Create a copy of these parameters.\n     * @param out If supplied, it will be modified in-place and returned instead of allocating a new QParams3d.\n     */\n    clone(out) {\n        const result = undefined !== out ? out : new QParams3d();\n        result.copyFrom(this);\n        return result;\n    }\n    /** Initialize from origin and scale */\n    setFromOriginAndScale(origin, scale) {\n        this.setFrom(origin.x, origin.y, origin.z, scale.x, scale.y, scale.z);\n    }\n    /** Initialize these parameters to support quantization of values within the specified range. */\n    setFromRange(range, rangeScale = Quantization.rangeScale16) {\n        if (!range.isNull) {\n            this.setFrom(range.low.x, range.low.y, range.low.z, Quantization.computeScale(range.high.x - range.low.x, rangeScale), Quantization.computeScale(range.high.y - range.low.y, rangeScale), Quantization.computeScale(range.high.z - range.low.z, rangeScale));\n        }\n        else {\n            this.origin.x = this.origin.y = this.origin.z = 0;\n            this.scale.x = this.scale.y = this.scale.z = 0;\n        }\n    }\n    /** Return the unquantized point for the input components.\n     * @param out If supplied, it will be modified in-place and returned instead of allocating a new Point3d.\n     */\n    unquantize(x, y, z, out) {\n        const pt = undefined !== out ? out : new Point3d();\n        pt.x = Quantization.unquantize(x, this.origin.x, this.scale.x);\n        pt.y = Quantization.unquantize(y, this.origin.y, this.scale.y);\n        pt.z = Quantization.unquantize(z, this.origin.z, this.scale.z);\n        return pt;\n    }\n    /** Creates parameters to support quantization of values within the specified range.\n     * If `out` is supplied, it will be modified in-place and returned instead of allocating a new QParams3d.\n     */\n    static fromRange(range, out, rangeScale = Quantization.rangeScale16) {\n        const params = undefined !== out ? out : new QParams3d();\n        params.setFromRange(range, rangeScale);\n        return params;\n    }\n    /** Creates parameters supporting quantization of values within the range [-1.0, 1.0].\n     * If `out` is supplied, it will be modified in-place and returned instead of allocating a new QParams3d.\n     */\n    static fromOriginAndScale(origin, scale, out) {\n        const params = undefined !== out ? out : new QParams3d();\n        params.setFromOriginAndScale(origin, scale);\n        return params;\n    }\n    /** Creates parameters supporting quantization of values within the range [-1.0, 1.0]. */\n    static fromNormalizedRange(rangeScale = Quantization.rangeScale16) {\n        return QParams3d.fromRange(Range3d.createArray([Point3d.create(-1, -1, -1), Point3d.create(1, 1, 1)]), undefined, rangeScale);\n    }\n    /** Creates parameters supporting quantization of values within the range [0.0, 1.0]. */\n    static fromZeroToOne(rangeScale = Quantization.rangeScale16) {\n        return QParams3d.fromRange(Range3d.createArray([Point3d.create(0, 0, 0), Point3d.create(1, 1, 1)]), undefined, rangeScale);\n    }\n    /** @internal */\n    get rangeDiagonal() {\n        return Vector3d.createFrom({\n            x: this.scale.x === 0 ? 0 : Quantization.rangeScale16 / this.scale.x,\n            y: this.scale.y === 0 ? 0 : Quantization.rangeScale16 / this.scale.y,\n            z: this.scale.z === 0 ? 0 : Quantization.rangeScale16 / this.scale.z,\n        });\n    }\n    /** Return true if the point point is quantizable using these parameters. */\n    isQuantizable(point) {\n        return Quantization.isQuantizable(point.x, this.origin.x, this.scale.x) && Quantization.isQuantizable(point.y, this.origin.y, this.scale.y) && Quantization.isQuantizable(point.z, this.origin.z, this.scale.z);\n    }\n    /** Compute the range to which these parameters quantize. */\n    computeRange(out) {\n        const range = Range3d.createNull(out);\n        range.extendPoint(this.origin);\n        range.extendPoint(this.origin.plus(this.rangeDiagonal));\n        return range;\n    }\n    /** @alpha */\n    toJSON() {\n        return {\n            origin: { x: this.origin.x, y: this.origin.y, z: this.origin.z },\n            scale: { x: this.scale.x, y: this.scale.y, z: this.scale.z },\n        };\n    }\n    /** @alpha */\n    static fromJSON(src, out) {\n        return this.fromOriginAndScale(Point3d.fromJSON(src.origin), Point3d.fromJSON(src.scale), out);\n    }\n}\n/** Represents a [Point3d]($core-geometry) compressed such that each component `x`, `y`, and `z` is quantized to the 16-bit integer range [0, 0xffff].\n * These are primarily used to reduce the space required for coordinates used by [RenderGraphic]($frontend)s.\n * @see [[QParams3d]] to define quantization parameters for a range of points.\n * @see [[QPoint3dList]] for a list of points all quantized to the same range.\n * @public\n * @extensions\n */\nexport class QPoint3d {\n    /** The quantized x component. */\n    get x() { return this._x; }\n    set x(x) {\n        assert(Quantization.isQuantized(x));\n        this._x = x;\n    }\n    /** The quantized y component. */\n    get y() { return this._y; }\n    set y(y) {\n        assert(Quantization.isQuantized(y));\n        this._y = y;\n    }\n    /** The quantized z component. */\n    get z() { return this._z; }\n    set z(z) {\n        assert(Quantization.isQuantized(z));\n        this._z = z;\n    }\n    /** Construct with all components initialized to zero. */\n    constructor() {\n        this._x = 0;\n        this._y = 0;\n        this._z = 0;\n    }\n    /** Initialize this point by quantizing the supplied { x, y, z } using the specified params */\n    init(pos, params) {\n        this.x = Quantization.quantize(pos.x, params.origin.x, params.scale.x);\n        this.y = Quantization.quantize(pos.y, params.origin.y, params.scale.y);\n        this.z = Quantization.quantize(pos.z, params.origin.z, params.scale.z);\n    }\n    /** Creates a quantized point from the supplied Point3d using the specified params */\n    static create(pos, params) {\n        const qpt = new QPoint3d();\n        qpt.init(pos, params);\n        return qpt;\n    }\n    /** Set this points components from `src`. */\n    copyFrom(src) {\n        this.x = src.x;\n        this.y = src.y;\n        this.z = src.z;\n    }\n    /** Create a copy of this point.\n     * @param out If supplied, it will be modified in-place instead of allocating a new QPoint3d.\n     */\n    clone(out) {\n        const result = undefined !== out ? out : new QPoint3d();\n        result.copyFrom(this);\n        return result;\n    }\n    /**\n     * Sets the x, y, and z components directly.\n     * @param x Must be an integer in the range [0, 0xffff]\n     * @param y Must be an integer in the range [0, 0xffff]\n     * @param z Must be an integer in the range [0, 0xffff]\n     */\n    setFromScalars(x, y, z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    /**\n     * Creates a QPoint3d directly from x, y, and z components.\n     * @param x Must be an integer in the range [0, 0xffff]\n     * @param y Must be an integer in the range [0, 0xffff]\n     * @param z Must be an integer in the range [0, 0xffff]\n     * @param out If supplied, it will be modified in-place instead of allocating a new QPoint3d.\n     */\n    static fromScalars(x, y, z, out) {\n        const pt = undefined === out ? new QPoint3d() : out;\n        pt.setFromScalars(x, y, z);\n        return pt;\n    }\n    /** Returns a Point3d unquantized according to the supplied params.\n     * If `out` is supplied, it will be modified in-place instead of allocating a new Point3d.\n     */\n    unquantize(params, out) {\n        const pt = undefined !== out ? out : new Point3d();\n        pt.x = Quantization.unquantize(this.x, params.origin.x, params.scale.x);\n        pt.y = Quantization.unquantize(this.y, params.origin.y, params.scale.y);\n        pt.z = Quantization.unquantize(this.z, params.origin.z, params.scale.z);\n        return pt;\n    }\n    /** Return true if this point's components are identical to the other point's components. */\n    equals(other) {\n        return this.x === other.x && this.y === other.y && this.z === other.z;\n    }\n    /** Perform ordinal comparison to another point. The function returns:\n     *  - Zero if this point is identical to `rhs`; or\n     *  - A number less than zero if this point is ordered before `rhs`; or\n     *  - A number greater than zero if this point is ordered after `rhs`.\n     * @see [OrderedComparator]($core-bentley).\n     */\n    compare(rhs) {\n        let diff = this.x - rhs.x;\n        if (0 === diff) {\n            diff = this.y - rhs.y;\n            if (0 === diff) {\n                diff = this.z - rhs.z;\n            }\n        }\n        return diff;\n    }\n}\n/** @public\n * @extensions\n */\nexport var QPoint3dBuffer;\n(function (QPoint3dBuffer) {\n    const scratchQPoint3d = new QPoint3d();\n    /** Extracts the point at the specified index from a buffer.\n     * @param points The buffer in which each consecutive pair of integers is a 3d quantized point.\n     * @param pointIndex The index of the point to extract, ranging from zero to one less than the number of points in the buffer.\n     * @param result If supplied, a preallocated [[QPoint3d]] to initialize with the result and return.\n     * @returns The point at `pointIndex`.\n     * @throws Error if `pointIndex` is out of bounds.\n     */\n    function getQPoint(points, pointIndex, result) {\n        const index = pointIndex * 3;\n        const x = points[index + 0];\n        const y = points[index + 1];\n        const z = points[index + 2];\n        if (undefined === x || undefined === y || undefined === z)\n            throw new Error(\"Index out of range\");\n        result = result ?? new QPoint3d();\n        result.setFromScalars(x, y, z);\n        return result;\n    }\n    QPoint3dBuffer.getQPoint = getQPoint;\n    /** Extracts and unquantizes the point at the specified index from a buffer.\n     * @param buffer The array of points and the quantization parameters.\n     * @param buffer The index of the point to extract, ranging from zero to one less than the number of points in the buffer.\n     * @param result If supplied, a preallocated [Point3d]($core-geometry) to initialize with the result and return.\n     * @returns The point at `pointIndex`.\n     * @throws Error if `pointIndex` is out of bounds.\n     */\n    function unquantizePoint(buffer, pointIndex, result) {\n        const qpt = getQPoint(buffer.points, pointIndex, scratchQPoint3d);\n        return qpt.unquantize(buffer.params, result);\n    }\n    QPoint3dBuffer.unquantizePoint = unquantizePoint;\n})(QPoint3dBuffer || (QPoint3dBuffer = {}));\n/** A list of [[QPoint3d]]s all quantized to the same range.\n * @public\n * @extensions\n */\nexport class QPoint3dList {\n    /** The list of quantized points. */\n    get list() {\n        return this._list;\n    }\n    /** Construct an empty list set up to quantize to the supplied range.\n     * @param params The quantization parameters. If omitted, a null range will be used.\n     */\n    constructor(params) {\n        this._list = [];\n        this.params = params ? params.clone() : QParams3d.fromRange(Range3d.createNull());\n    }\n    /** Construct a QPoint3dList containing all points in the supplied list, quantized to the range of those points.\n     * @param points The points to quantize and add to the list.\n     * @param out If supplied, it will be cleared, its parameters recomputed, and the points will be added to it; otherwise, a new QPoint3dList will be created and returned.\n     */\n    static fromPoints(points, out) {\n        let qPoints;\n        const qParams = QParams3d.fromRange(Range3d.createArray(points));\n        if (out) {\n            qPoints = out;\n            qPoints.reset(qParams);\n        }\n        else {\n            qPoints = new QPoint3dList(qParams);\n        }\n        for (const point of points)\n            qPoints.add(point);\n        return qPoints;\n    }\n    /** Removes all points from the list. */\n    clear() {\n        this._list.length = 0;\n    }\n    /** Clears out the contents of the list and changes the quantization parameters. */\n    reset(params) {\n        this.clear();\n        this.params.copyFrom(params);\n    }\n    /** Quantizes the supplied Point3d to this list's range and appends it to the list. */\n    add(pt) {\n        this._list.push(QPoint3d.create(pt, this.params));\n    }\n    /** Adds a previously-quantized point to this list. */\n    push(qpt) {\n        this._list.push(qpt.clone());\n    }\n    /** The number of points in the list. */\n    get length() {\n        return this._list.length;\n    }\n    /** Returns the unquantized value of the point at the specified index in the list. */\n    unquantize(index, out) {\n        assert(index < this.length);\n        if (index < this.length) {\n            return this._list[index].unquantize(this.params, out);\n        }\n        else {\n            return undefined !== out ? out : new Point3d();\n        }\n    }\n    /** Changes the quantization parameters and requantizes all points in the list to the new range.\n     * @note The loss of precision is compounded each time the points are requantized to a new range.\n     */\n    requantize(params) {\n        for (let i = 0; i < this.length; i++) {\n            const pt = this.unquantize(i);\n            this._list[i].init(pt, params);\n        }\n        this.params.copyFrom(params);\n    }\n    /** Extracts the current contents of the list as a Uint16Array such that the first 3 elements contain the first point's x, y, and z components,\n     * the second three elements contain the second point's components, and so on.\n     */\n    toTypedArray() {\n        const array = new Uint16Array(this.length * 3);\n        const pts = this._list;\n        for (let i = 0; i < this.length; i++) {\n            const pt = pts[i];\n            array[i * 3 + 0] = pt.x;\n            array[i * 3 + 1] = pt.y;\n            array[i * 3 + 2] = pt.z;\n        }\n        return array;\n    }\n    /** Reinitialize from a Uint16Array in which the first three elements specify the x, y, and z components of the first point, the second three elements specify the components\n     * of the second point, and so on.\n     */\n    fromTypedArray(range, array) {\n        this.params.setFromRange(range);\n        this._list.length = array.length / 3;\n        for (let i = 0, j = 0; i < this.list.length; i++)\n            this._list[i] = QPoint3d.fromScalars(array[j++], array[j++], array[j++]);\n    }\n    /** Construct a list containing all points in the supplied list, quantized using the supplied parameters. */\n    static createFrom(points, params) {\n        const list = new QPoint3dList(params);\n        for (const point of points)\n            list.add(point);\n        return list;\n    }\n    /** An iterator over the points in the list. */\n    [Symbol.iterator]() {\n        return this.list[Symbol.iterator]();\n    }\n}\n/** Constructs a [[QPoint2dBuffer]] using a [Uint16ArrayBuilder]($bentley).\n * @public\n * @extensions\n */\nexport class QPoint2dBufferBuilder {\n    /** Construct a new buffer with a [[length]] of zero. */\n    constructor(options) {\n        this._scratchQPoint2d = new QPoint2d();\n        this.params = QParams2d.fromRange(options.range);\n        const initialCapacity = options.initialCapacity ?? 0;\n        this.buffer = new Uint16ArrayBuilder({\n            growthFactor: options.growthFactor,\n            initialCapacity: 2 * initialCapacity,\n        });\n    }\n    /** Append a point with the specified quantized coordinates. */\n    pushXY(x, y) {\n        this.buffer.push(x);\n        this.buffer.push(y);\n    }\n    /** Append a point with the specified quantized coordinates. */\n    push(pt) {\n        this.pushXY(pt.x, pt.y);\n    }\n    /** The number of points currently in the [[buffer]]. */\n    get length() {\n        const len = this.buffer.length;\n        assert(len % 2 === 0);\n        return len / 2;\n    }\n    /** Returns the quantized point at the specified index in [[buffer]].\n     * @param pointIndex The index of the point of interest, ranging from zero to one minus the number of points currently in the [[buffer]].\n     * @param result If supplied, a [[QPoint2d]] to initialize with the result and return.\n     * @returns The quantized point at the specified index in [[buffer]].\n     * @throws Error if `pointIndex` is out of bounds.\n     */\n    get(pointIndex, result) {\n        return QPoint2dBuffer.getQPoint(this.buffer.toTypedArray(), pointIndex, result);\n    }\n    /** Returns the unquantized point at the specified index in [[buffer]].\n     * @param pointIndex The index of the point of interest, ranging from zero to one minus the number of points currently in the [[buffer]].\n     * @param result If supplied, a [Point2d]($core-geometry) to initialize with the result and return.\n     * @returns The unquantized point at the specified index in [[buffer]].\n     * @throws Error if `pointIndex` is out of bounds.\n     */\n    unquantize(pointIndex, result) {\n        return this.get(pointIndex, this._scratchQPoint2d).unquantize(this.params, result);\n    }\n    /** Obtain a [[QPoint2dBuffer]] containing all of the points that have been appended by this builder. */\n    finish() {\n        return {\n            params: this.params,\n            points: this.buffer.toTypedArray(),\n        };\n    }\n}\n/** Constructs a [[QPoint3dBuffer]] using a [Uint16ArrayBuilder]($bentley).\n * @public\n * @extensions\n */\nexport class QPoint3dBufferBuilder {\n    /** Construct a new buffer with a [[length]] of zero. */\n    constructor(options) {\n        this._scratchQPoint3d = new QPoint3d();\n        this.params = QParams3d.fromRange(options.range);\n        const initialCapacity = options.initialCapacity ?? 0;\n        this.buffer = new Uint16ArrayBuilder({\n            growthFactor: options.growthFactor,\n            initialCapacity: 3 * initialCapacity,\n        });\n    }\n    /** Append a point with the specified quantized coordinates. */\n    pushXYZ(x, y, z) {\n        this.buffer.push(x);\n        this.buffer.push(y);\n        this.buffer.push(z);\n    }\n    /** Append a point with the specified quantized coordinates. */\n    push(pt) {\n        this.pushXYZ(pt.x, pt.y, pt.z);\n    }\n    /** The number of points currently in the [[buffer]]. */\n    get length() {\n        const len = this.buffer.length;\n        assert(len % 3 === 0);\n        return len / 3;\n    }\n    /** Returns the quantized point at the specified index in [[buffer]].\n     * @param pointIndex The index of the point of interest, ranging from zero to one minus the number of points currently in the [[buffer]].\n     * @param result If supplied, a [[QPoint3d]] to initialize with the result and return.\n     * @returns The quantized point at the specified index in [[buffer]].\n     * @throws Error if `pointIndex` is out of bounds.\n     */\n    get(pointIndex, result) {\n        return QPoint3dBuffer.getQPoint(this.buffer.toTypedArray(), pointIndex, result);\n    }\n    /** Returns the unquantized point at the specified index in [[buffer]].\n     * @param pointIndex The index of the point of interest, ranging from zero to one minus the number of points currently in the [[buffer]].\n     * @param result If supplied, a [Point3d]($core-geometry) to initialize with the result and return.\n     * @returns The unquantized point at the specified index in [[buffer]].\n     * @throws Error if `pointIndex` is out of bounds.\n     */\n    unquantize(pointIndex, result) {\n        return this.get(pointIndex, this._scratchQPoint3d).unquantize(this.params, result);\n    }\n    /** Obtain a [[QPoint3dBuffer]] containing all of the points that have been appended by this builder. */\n    finish() {\n        return {\n            params: this.params,\n            points: this.buffer.toTypedArray(),\n        };\n    }\n}\n//# sourceMappingURL=QPoint.js.map",
      "start": 1693508120933,
      "end": 1693508120979,
      "sourcemaps": null
    }
  ]
}
