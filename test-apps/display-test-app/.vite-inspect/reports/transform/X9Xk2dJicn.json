{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/PerformanceMetrics.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { BeTimePoint, StopWatch } from \"@itwin/core-bentley\";\nimport { System } from \"./System\";\n/** @internal */\nexport class PerformanceMetrics {\n    constructor(gatherGlFinish = false, gatherCurPerformanceMetrics = false, gpuResults) {\n        this._beginTimePoints = []; // stack of time points\n        this._operationNames = []; // stack of operation names\n        this._allTimePoints1 = []; // queue 1 of data needed to make frameTimings; use 2 copies for double buffering\n        this._allTimePoints2 = []; // queue 2 of data needed to make frameTimings; use 2 copies for double buffering\n        this._updateallTimePoints1 = true; // determine which buffer to use for the frame timings; used for double buffering the frame timings\n        this.frameTimings = new Map();\n        this.gatherGlFinish = false; // Set to true if gathering data for display-performance-test-app\n        this.gatherCurPerformanceMetrics = false; // Set to true if gathering data for Profile GPU\n        this.curSpfTimeIndex = 0;\n        this.spfTimes = [];\n        this.spfSum = 0;\n        this.fpsTimer = new StopWatch(undefined, true);\n        this.fpsTimerStart = 0;\n        this.gatherGlFinish = gatherGlFinish;\n        this.gatherCurPerformanceMetrics = gatherCurPerformanceMetrics;\n        if (gpuResults)\n            System.instance.debugControl.resultsCallback = gpuResults;\n    }\n    beginFrame(sceneTime = 0) {\n        this._beginTimePoints = [];\n        this._operationNames = [];\n        this.frameTimings = new Map();\n        this.frameTimings.set(\"Scene Time\", sceneTime);\n        this._operationNames.push(\"Total Time\");\n        this._operationNames.push(\"CPU Total Time\");\n        const now = BeTimePoint.now();\n        this._beginTimePoints.push(now); // this first time point used to calculate total time at the end\n        this._beginTimePoints.push(now); // this second time point used to calculate total cpu time at the end\n    }\n    beginOperation(operationName) {\n        this._operationNames.push(operationName);\n        this._beginTimePoints.push(BeTimePoint.now());\n    }\n    endOperation() {\n        const endTimePoint = BeTimePoint.now();\n        const beginTimePoint = this._beginTimePoints.length > 0 ? this._beginTimePoints.pop() : endTimePoint;\n        const operationName = this._operationNames.pop();\n        if (operationName) { // Add data to queue now, calculate time later; helps eliminate time spent timing things in 'Total Time'\n            if (this._updateallTimePoints1) // Push to currently active allTimePoints buffer\n                this._allTimePoints1.push({ begin: beginTimePoint, end: endTimePoint, name: operationName });\n            else\n                this._allTimePoints2.push({ begin: beginTimePoint, end: endTimePoint, name: operationName });\n        }\n    }\n    endFrame() {\n        this.endOperation();\n        // Use double buffering here to ensure that we grab a COMPLETE set of timings from a SINGLE run when grabbing timing data while continuously rendering\n        this._updateallTimePoints1 = !this._updateallTimePoints1; // Switch to other allTimePoints buffer\n        if (this._updateallTimePoints1) { // Get data from the old buffer that was just completed\n            this._allTimePoints2.forEach((record) => this.frameTimings.set(record.name, record.end.milliseconds - record.begin.milliseconds));\n            this._allTimePoints2 = []; // Reset to empty\n        }\n        else {\n            this._allTimePoints1.forEach((record) => this.frameTimings.set(record.name, record.end.milliseconds - record.begin.milliseconds));\n            this._allTimePoints1 = []; // Reset to empty\n        }\n        this._beginTimePoints = []; // This should be back to [] at this point\n        this._operationNames = []; // This should be back to [] at this point\n    }\n    completeFrameTimings(fbo) {\n        if (this.gatherCurPerformanceMetrics) {\n            const fpsTimerElapsed = this.fpsTimer.currentSeconds - this.fpsTimerStart;\n            if (this.spfTimes[this.curSpfTimeIndex])\n                this.spfSum -= this.spfTimes[this.curSpfTimeIndex];\n            this.spfSum += fpsTimerElapsed;\n            this.spfTimes[this.curSpfTimeIndex] = fpsTimerElapsed;\n            this.curSpfTimeIndex++;\n            if (this.curSpfTimeIndex >= 50)\n                this.curSpfTimeIndex = 0;\n            this.fpsTimerStart = this.fpsTimer.currentSeconds;\n        }\n        const system = System.instance;\n        if (this.gatherGlFinish && !system.isGLTimerSupported) {\n            this.beginOperation(\"Finish GPU Queue\");\n            // Ensure all previously queued webgl commands are finished by reading back one pixel since gl.Finish didn't work\n            const bytes = new Uint8Array(4);\n            const gl = system.context;\n            system.frameBufferStack.execute(fbo, true, false, () => {\n                gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, bytes);\n            });\n            this.endOperation();\n        }\n        this.endFrame();\n    }\n}\n//# sourceMappingURL=PerformanceMetrics.js.map",
      "start": 1693508119990,
      "end": 1693508120097,
      "sourcemaps": null
    }
  ]
}
