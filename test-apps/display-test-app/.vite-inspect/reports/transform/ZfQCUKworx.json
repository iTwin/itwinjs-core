{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tile/map/ImageryProviders/ArcGISImageryProvider.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tiles\n */\nimport { ArcGisErrorCode, ArcGisUtilities, MapLayerImageryProvider, MapLayerImageryProviderStatus } from \"../../internal\";\nimport { IModelApp } from \"../../../IModelApp\";\nimport { NotifyMessageDetails, OutputMessagePriority } from \"../../../NotificationManager\";\n/** Base class for ArcGIS map-layer imagery providers.\n *\n * The initial purpose of this class is to offer shared methods\n * to query ArcGIS services and apply the appropriate security token.\n * @see [[ArcGISMapLayerImageryProvider]]\n * @internal\n */\nexport class ArcGISImageryProvider extends MapLayerImageryProvider {\n    get supportsMapFeatureInfo() { return this._querySupported; }\n    constructor(settings, usesCachedTiles) {\n        super(settings, usesCachedTiles);\n        /** Flag indicating if access token should be added to request.\n        * @note We assume a service to require access token for the entire viewing session.\n        */\n        this._accessTokenRequired = false;\n        this._querySupported = false;\n        this._accessClient = IModelApp.mapLayerFormatRegistry?.getAccessClient(settings.formatId);\n    }\n    /** Updates the accessClient token state whenever the status of the provider change.\n     *  @internal\n     * */\n    onStatusUpdated(status) {\n        if (status === MapLayerImageryProviderStatus.RequireAuth) {\n            // Invalidate the token, so a new one get generated\n            if (this._accessClient?.invalidateToken !== undefined && this._lastAccessToken !== undefined) {\n                this._accessClient.invalidateToken(this._lastAccessToken);\n            }\n            // Make sure we don't re-use this token again (i.e force login process)\n            this._lastAccessToken = undefined;\n        }\n    }\n    /**\n     * Fetch an ArcGIS service metadata, and returns its JSON representation.\n     * This wrapper maintains token state and should be used instead of the the ArcGisUtilities version.\n    */\n    async getServiceJson() {\n        let metadata;\n        try {\n            metadata = await ArcGisUtilities.getServiceJson(this._settings.url, this._settings.formatId, this._settings.userName, this._settings.password);\n        }\n        catch (_e) {\n        }\n        if (metadata && metadata.accessTokenRequired) {\n            const accessClient = IModelApp.mapLayerFormatRegistry.getAccessClient(this._settings.formatId);\n            if (accessClient) {\n                try {\n                    // Keep track of last used access token, so we can invalidate it later when an errors occurs\n                    const accessToken = await accessClient.getAccessToken({ mapLayerUrl: new URL(this._settings.url) });\n                    this._lastAccessToken = accessToken;\n                }\n                catch {\n                }\n            }\n            // By turning this ON, tiles requests will include security token\n            this._accessTokenRequired = metadata.accessTokenRequired;\n        }\n        return metadata;\n    }\n    /**\n     * Make a request to an ArcGIS service using the provided URL and init parameters.\n     * @param url URL to query\n     * @param options Custom settings to apply to the request.\n     * Refer to fetch API for more details (https://developer.mozilla.org/en-US/docs/Web/API/fetch)\n     */\n    async fetch(url, options) {\n        let errorCode;\n        const urlObj = new URL(url);\n        if (this._accessTokenRequired && this._accessClient) {\n            this._lastAccessToken = await ArcGisUtilities.appendSecurityToken(urlObj, this._accessClient, {\n                mapLayerUrl: new URL(this._settings.url),\n                userName: this._settings.userName,\n                password: this._settings.password\n            });\n        }\n        let response = await fetch(urlObj.toString(), options);\n        if ((this._lastAccessToken && response.status === 400)\n            || response.headers.get(\"content-type\")?.toLowerCase().includes(\"htm\")) {\n            // For some reasons when we make a request with the fetch() api and there is a token error\n            // we receive a status 400 instead of proper json response. (i.e doing the same request in the browser gives a different response)\n            // For some other request, we also seen error message  in html.\n            // When it occurs, we fall back to root service request so we get a proper JSON response with error code.\n            const tmpUrl = new URL(this._settings.url);\n            if (this._lastAccessToken && this._accessTokenRequired)\n                tmpUrl.searchParams.append(\"token\", this._lastAccessToken.token);\n            tmpUrl.searchParams.append(\"f\", \"json\");\n            response = await fetch(tmpUrl.toString(), options);\n        }\n        errorCode = await ArcGisUtilities.checkForResponseErrorCode(response);\n        if (errorCode !== undefined &&\n            (errorCode === ArcGisErrorCode.TokenRequired || errorCode === ArcGisErrorCode.InvalidToken)) {\n            if (this._settings.userName && this._settings.userName.length > 0 && this._lastAccessToken) {\n                // **** Legacy token ONLY ***\n                // Token might have expired, make a second attempt by forcing new token.\n                if (this._accessClient?.invalidateToken !== undefined && this._lastAccessToken !== undefined)\n                    this._accessClient.invalidateToken(this._lastAccessToken);\n                const urlObj2 = new URL(url);\n                if (this._accessClient) {\n                    try {\n                        this._lastAccessToken = await ArcGisUtilities.appendSecurityToken(urlObj, this._accessClient, { mapLayerUrl: urlObj, userName: this._settings.userName, password: this._settings.password });\n                    }\n                    catch {\n                    }\n                }\n                // Make a second attempt with refreshed token\n                response = await fetch(urlObj2.toString(), options);\n                errorCode = await ArcGisUtilities.checkForResponseErrorCode(response);\n            }\n            if (errorCode === ArcGisErrorCode.TokenRequired || errorCode === ArcGisErrorCode.InvalidToken) {\n                // Looks like the initially generated token has expired.\n                if (this.status === MapLayerImageryProviderStatus.Valid) {\n                    // Only report new status change to avoid spamming the UI\n                    this.setStatus(MapLayerImageryProviderStatus.RequireAuth);\n                    this.onStatusChanged.raiseEvent(this);\n                    const msg = IModelApp.localization.getLocalizedString(\"iModelJs:MapLayers.Messages.FetchTooltipTokenError\", { layerName: this._settings.name });\n                    IModelApp.notifications.outputMessage(new NotifyMessageDetails(OutputMessagePriority.Warning, msg));\n                }\n            }\n        }\n        return response;\n    }\n}\n//# sourceMappingURL=ArcGISImageryProvider.js.map",
      "start": 1693508121828,
      "end": 1693508122022,
      "sourcemaps": null
    }
  ]
}
