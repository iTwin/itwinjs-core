{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/bspline/BSpline1dNd.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Bspline\n */\n// import { Point2d } from \"../Geometry2d\";\nimport { Geometry } from \"../Geometry\";\n/* eslint-disable @typescript-eslint/naming-convention, no-empty */\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\nimport { BSplineWrapMode, KnotVector } from \"./KnotVector\";\n/** Bspline knots and poles for 1d-to-Nd.\n * * The \"pole\" (aka control point) of this class is a block of `poleLength` numbers.\n * * Derived classes (not this class) assign meaning such as x,y,z,w.\n * * for instance, an instance of this class with `poleLength===3` does not know if its poles are x,y,z or weighted 2D x,y,w\n * @public\n */\nexport class BSpline1dNd {\n    /** (property accessor) Return the degree of the polynomials. */\n    get degree() { return this.knots.degree; }\n    /** (property accessor) Return the number of order (one more than degree) of the polynomials */\n    get order() { return this.knots.degree + 1; }\n    /** (property accessor) Return the number of bezier spans (including null spans at multiple knots)*/\n    get numSpan() { return this.numPoles - this.knots.degree; }\n    /** (property accessor)  Return the number of poles*/\n    get numPoles() { return this.packedData.length / this.poleLength; }\n    /** copy 3 values of pole `i` into a point.\n     * * The calling class is responsible for knowing if this is an appropriate access to the blocked data.\n     */\n    getPoint3dPole(i, result) { return Point3d.createFromPacked(this.packedData, i, result); }\n    /**\n     * initialize arrays for given spline dimensions.\n     * @param numPoles number of poles\n     * @param poleLength number of coordinates per pole (e.g.. 3 for 3D unweighted, 4 for 3d weighted, 2 for 2d unweighted, 3 for 2d weighted)\n     * @param order number of poles in support for a section of the bspline\n     * @param knots KnotVector.  This is captured, not cloned.\n     */\n    constructor(numPoles, poleLength, order, knots) {\n        this.knots = knots;\n        this.packedData = new Float64Array(numPoles * poleLength);\n        this.poleLength = poleLength;\n        this.basisBuffer = new Float64Array(order);\n        this.poleBuffer = new Float64Array(poleLength);\n        this.basisBuffer1 = new Float64Array(order);\n        this.basisBuffer2 = new Float64Array(order);\n        this.poleBuffer1 = new Float64Array(poleLength);\n        this.poleBuffer2 = new Float64Array(poleLength);\n    }\n    /**\n     * create a 1Bspline1dNd`\n     * @param numPoles number of poles\n     * @param poleLength number of coordinates per pole (e.g.. 3 for 3D unweighted, 4 for 3d weighted, 2 for 2d unweighted, 3 for 2d weighted)\n     * @param order number of poles in support for a section of the bspline\n     * @param knots KnotVector.  This is captured, not cloned.\n     */\n    static create(numPoles, poleLength, order, knots) {\n        return new BSpline1dNd(numPoles, poleLength, order, knots);\n    }\n    /** Map a span index and local fraction to knot value. */\n    spanFractionToKnot(span, localFraction) {\n        return this.knots.spanFractionToKnot(span, localFraction);\n    }\n    /** Evaluate the `order` basis functions (and optionally one or two derivatives) at a given fractional position within indexed span. */\n    evaluateBasisFunctionsInSpan(spanIndex, spanFraction, f, df, ddf) {\n        if (spanIndex < 0)\n            spanIndex = 0;\n        if (spanIndex >= this.numSpan)\n            spanIndex = this.numSpan - 1;\n        const knotIndex0 = spanIndex + this.degree - 1;\n        const globalKnot = this.knots.baseKnotFractionToKnot(knotIndex0, spanFraction);\n        return df ?\n            this.knots.evaluateBasisFunctions1(knotIndex0, globalKnot, f, df, ddf) :\n            this.knots.evaluateBasisFunctions(knotIndex0, globalKnot, f);\n    }\n    /**\n     * * Evaluate the basis functions at spanIndex and fraction.\n     *   * Evaluations are stored in the preallocated `this.basisBuffer`\n     * * Immediately do the summations of the basis values times the respective control points\n     *   * Summations are stored in the preallocated `this.poleBuffer`\n     * */\n    evaluateBuffersInSpan(spanIndex, spanFraction) {\n        this.evaluateBasisFunctionsInSpan(spanIndex, spanFraction, this.basisBuffer);\n        this.sumPoleBufferForSpan(spanIndex);\n    }\n    /**\n     * * Evaluate the basis functions and one derivative at spanIndex and fraction.\n     *   * Evaluations are stored in the preallocated `this.basisBuffer`\n     * * Immediately do the summations of the basis values times the respective control points\n     *   * Summations are stored in the preallocated `this.poleBuffer` and `this.poleBuffer1`\n     * */\n    evaluateBuffersInSpan1(spanIndex, spanFraction) {\n        this.evaluateBasisFunctionsInSpan(spanIndex, spanFraction, this.basisBuffer, this.basisBuffer1);\n        this.sumPoleBufferForSpan(spanIndex);\n        this.sumPoleBuffer1ForSpan(spanIndex);\n    }\n    /** sum poles in `poleBuffer` at span `spanIndex` by the weights in the `basisBuffer` */\n    sumPoleBufferForSpan(spanIndex) {\n        this.poleBuffer.fill(0);\n        let k = spanIndex * this.poleLength;\n        for (const f of this.basisBuffer) {\n            for (let j = 0; j < this.poleLength; j++) {\n                this.poleBuffer[j] += f * this.packedData[k++];\n            }\n        }\n    }\n    /** sum poles in `poleBuffer1` at span `spanIndex` by the weights in the `basisBuffer1`, i.e. form first derivatives */\n    sumPoleBuffer1ForSpan(spanIndex) {\n        this.poleBuffer1.fill(0);\n        let k = spanIndex * this.poleLength;\n        for (const f of this.basisBuffer1) {\n            for (let j = 0; j < this.poleLength; j++) {\n                this.poleBuffer1[j] += f * this.packedData[k++];\n            }\n        }\n    }\n    /** sum poles in `poleBuffer2` at span `spanIndex` by the weights in the `basisBuffer2`, i.e. form second derivatives */\n    sumPoleBuffer2ForSpan(spanIndex) {\n        this.poleBuffer2.fill(0);\n        let k = spanIndex * this.poleLength;\n        for (const f of this.basisBuffer2) {\n            for (let j = 0; j < this.poleLength; j++) {\n                this.poleBuffer2[j] += f * this.packedData[k++];\n            }\n        }\n    }\n    /** Evaluate the function values and 1 or 2 derivatives into `this.poleBuffer`, `this.poleBuffer1` and `this.poleBuffer2` */\n    evaluateBuffersAtKnot(u, numDerivative = 0) {\n        const knotIndex0 = this.knots.knotToLeftKnotIndex(u);\n        if (numDerivative < 1) {\n            this.knots.evaluateBasisFunctions(knotIndex0, u, this.basisBuffer);\n            this.sumPoleBufferForSpan(knotIndex0 - this.degree + 1);\n        }\n        else if (numDerivative === 1) {\n            this.knots.evaluateBasisFunctions1(knotIndex0, u, this.basisBuffer, this.basisBuffer1);\n            this.sumPoleBufferForSpan(knotIndex0 - this.degree + 1);\n            this.sumPoleBuffer1ForSpan(knotIndex0 - this.degree + 1);\n        }\n        else {\n            this.knots.evaluateBasisFunctions1(knotIndex0, u, this.basisBuffer, this.basisBuffer1, this.basisBuffer2);\n            this.sumPoleBufferForSpan(knotIndex0 - this.degree + 1);\n            this.sumPoleBuffer1ForSpan(knotIndex0 - this.degree + 1);\n            this.sumPoleBuffer2ForSpan(knotIndex0 - this.degree + 1);\n        }\n    }\n    /**\n     * Reverse the (blocked) poles (in `this.packedData` in place.\n     */\n    reverseInPlace() {\n        // reverse poles in blocks ...\n        const b = this.poleLength;\n        const data = this.packedData;\n        for (let i0 = 0, j0 = b * (this.numPoles - 1); i0 < j0; i0 += b, j0 -= b) {\n            let t = 0;\n            for (let i = 0; i < b; i++) {\n                t = data[i0 + i];\n                data[i0 + i] = data[j0 + i];\n                data[j0 + i] = t;\n            }\n        }\n        this.knots.reflectKnots();\n    }\n    /**\n     * Test if the leading and trailing polygon coordinates are replicated in the manner of a \"closed\" bspline polygon which has been expanded\n     * to act as a normal bspline.\n     * @returns true if `degree` leading and trailing polygon blocks match\n     */\n    testCloseablePolygon(mode) {\n        if (mode === undefined)\n            mode = this.knots.wrappable;\n        const degree = this.degree;\n        const blockSize = this.poleLength;\n        const indexDelta = (this.numPoles - this.degree) * blockSize;\n        const data = this.packedData;\n        if (mode === BSplineWrapMode.OpenByAddingControlPoints) {\n            // expect {degree} matched points.\n            const numValuesToTest = degree * blockSize;\n            for (let i0 = 0; i0 < numValuesToTest; i0++) {\n                if (!Geometry.isSameCoordinate(data[i0], data[i0 + indexDelta]))\n                    return false;\n            }\n            return true;\n        }\n        if (mode === BSplineWrapMode.OpenByRemovingKnots) {\n            // no pole conditions are applied.\n            return true;\n        }\n        return false;\n    }\n    /** Insert knot and resulting pole into the instance, optionally multiple times.\n     * @param knot the knot to be inserted (may already exist in the KnotVector)\n     * @param totalMultiplicity the total multiplicity of the knot on return\n     */\n    addKnot(knot, totalMultiplicity) {\n        if (knot < this.knots.leftKnot || knot > this.knots.rightKnot)\n            return false; // invalid input\n        let iLeftKnot = this.knots.knotToLeftKnotIndex(knot);\n        // snap input if too close to an existing knot\n        if (Math.abs(knot - this.knots.knots[iLeftKnot]) < KnotVector.knotTolerance) {\n            knot = this.knots.knots[iLeftKnot]; // snap to left knot of bracket\n        }\n        else if (Math.abs(knot - this.knots.knots[iLeftKnot + 1]) < KnotVector.knotTolerance) {\n            iLeftKnot += this.knots.getKnotMultiplicityAtIndex(iLeftKnot + 1);\n            if (iLeftKnot > this.knots.rightKnotIndex)\n                return true; // nothing to do\n            knot = this.knots.knots[iLeftKnot]; // snap to left knot of next bracket\n        }\n        const numKnotsToAdd = Math.min(totalMultiplicity, this.degree) - this.knots.getKnotMultiplicity(knot);\n        if (numKnotsToAdd <= 0)\n            return true; // nothing to do\n        // working arrays and pole buffer\n        let currKnotCount = this.knots.knots.length;\n        const newKnots = new Float64Array(currKnotCount + numKnotsToAdd);\n        for (let i = 0; i < currKnotCount; ++i)\n            newKnots[i] = this.knots.knots[i];\n        let currPoleCount = this.numPoles;\n        const newPackedData = new Float64Array(this.packedData.length + (numKnotsToAdd * this.poleLength));\n        for (let i = 0; i < this.packedData.length; ++i)\n            newPackedData[i] = this.packedData[i];\n        const dataBuf = new Float64Array(this.degree * this.poleLength); // holds degree poles\n        // each iteration adds one knot and one pole to the working arrays (cf. Farin 4e)\n        for (let iter = 0; iter < numKnotsToAdd; ++iter) {\n            // fill the buffer with new poles obtained from control polygon corner cutting\n            let iBuf = 0;\n            const iStart = iLeftKnot - this.degree + 2;\n            for (let i = iStart; i < iStart + this.degree; ++i) {\n                const fraction = (knot - newKnots[i - 1]) / (newKnots[i + this.degree - 1] - newKnots[i - 1]);\n                for (let j = i * this.poleLength; j < (i + 1) * this.poleLength; ++j) {\n                    dataBuf[iBuf++] = Geometry.interpolate(newPackedData[j - this.poleLength], fraction, newPackedData[j]);\n                }\n            }\n            // overwrite degree-1 poles with degree new poles, shifting tail to the right by one\n            newPackedData.copyWithin((iStart + this.degree) * this.poleLength, (iStart + this.degree - 1) * this.poleLength, currPoleCount * this.poleLength);\n            let iData = iStart * this.poleLength;\n            for (const d of dataBuf)\n                newPackedData[iData++] = d; // overwrite degree new poles\n            // add the knot to newKnots in position, shifting tail to the right by one\n            newKnots.copyWithin(iLeftKnot + 2, iLeftKnot + 1, currKnotCount);\n            newKnots[iLeftKnot + 1] = knot;\n            ++iLeftKnot;\n            ++currKnotCount;\n            ++currPoleCount;\n        }\n        this.knots.setKnotsCapture(newKnots);\n        this.packedData = newPackedData;\n        return true;\n    }\n}\n//# sourceMappingURL=BSpline1dNd.js.map",
      "start": 1693508123859,
      "end": 1693508124021,
      "sourcemaps": null
    }
  ]
}
