{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/curve/spiral/XYCurveEvaluator.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Curve\n */\nimport { Geometry } from \"../../Geometry\";\nimport { Plane3dByOriginAndVectors } from \"../../geometry3d/Plane3dByOriginAndVectors\";\nimport { Point3d } from \"../../geometry3d/Point3dVector3d\";\nimport { Ray3d } from \"../../geometry3d/Ray3d\";\nimport { Quadrature } from \"../../numerics/Quadrature\";\nimport { SimpleNewton } from \"../../numerics/Newton\";\n/**\n * XYCurveEvaluator is an abstract with methods for evaluating X and Y parts of a curve parameterized by a fraction.\n * * The required methods call for independent X and Y evaluation.\n * * Base class methods package those (multiple) calls into point, ray, and plane structures.\n *    * A implementation that has evaluation substantial cost that can be shared among x,y parts or between\n *       primary functions and derivatives might choose to implement the point and derivative methods directly.\n * @internal\n */\nexport class XYCurveEvaluator {\n    /** Evaluate both X and Y at fractional coordinate, return bundled as a point. */\n    fractionToPoint(fraction, result) {\n        return Point3d.create(this.fractionToX(fraction), this.fractionToY(fraction), 0.0, result);\n    }\n    /** Evaluate both X and Y and their first derivatives at fractional coordinate, return bundled as origin and (non-unit) direction vector. */\n    fractionToPointAndDerivative(fraction, result) {\n        return Ray3d.createXYZUVW(this.fractionToX(fraction), this.fractionToY(fraction), 0.0, this.fractionToDX(fraction), this.fractionToDY(fraction), 0, result);\n    }\n    /** Evaluate both X and Y and their second derivatives at fractional coordinate, return bundled as origin and (non-unit) vectorU an vectorV. */\n    fractionToPointAnd2Derivatives(fraction, result) {\n        return Plane3dByOriginAndVectors.createOriginAndVectorsXYZ(this.fractionToX(fraction), this.fractionToY(fraction), 0.0, this.fractionToDX(fraction), this.fractionToDY(fraction), 0, this.fractionToDDX(fraction), this.fractionToDDY(fraction), 0, result);\n    }\n    /**\n     * Return the magnitude of the tangent vector at fraction.\n     * @param fraction fractional position along the curve\n     */\n    fractionToTangentMagnitude(fraction) {\n        const u = this.fractionToDX(fraction);\n        const v = this.fractionToDY(fraction);\n        return Geometry.hypotenuseXY(u, v);\n    }\n    static initWorkSpace() {\n        XYCurveEvaluator._gaussX = new Float64Array(5);\n        XYCurveEvaluator._gaussWeight = new Float64Array(5);\n        XYCurveEvaluator._gaussMapper = (xA, xB, xMapped, wMapped) => Quadrature.setupGauss5(xA, xB, xMapped, wMapped);\n    }\n    /**\n     * Integrate between nominal fractions with default gauss rule.\n     * * The caller is expected to choose nearby fractions so that the single gauss interval accuracy is good.\n     * @param fraction0\n     * @param fraction1\n     */\n    integrateDistanceBetweenFractions(fraction0, fraction1) {\n        const gaussX = XYCurveEvaluator._gaussX;\n        const gaussWeight = XYCurveEvaluator._gaussWeight;\n        const numEval = XYCurveEvaluator._gaussMapper(fraction0, fraction1, gaussX, gaussWeight);\n        let sum = 0;\n        for (let k = 0; k < numEval; k++) {\n            sum += gaussWeight[k] * this.fractionToTangentMagnitude(gaussX[k]);\n        }\n        return sum;\n    }\n    /**\n     * Inverse integrated distance\n     * @param fraction0 start of fraction interval\n     * @param fraction1 end of fraction interval\n     * @param distance0 distance at start\n     * @param distance1 distance at end\n     * @param targetDistance intermediate distance.\n     */\n    inverseDistanceFraction(fraction0, fraction1, distance0, distance1, targetDistance) {\n        const startFraction = Geometry.inverseInterpolate(fraction0, distance0, fraction1, distance1, targetDistance);\n        if (startFraction !== undefined) {\n            return SimpleNewton.runNewton1D(startFraction, (fraction) => {\n                const d = this.integrateDistanceBetweenFractions(fraction0, fraction);\n                return distance0 + d - targetDistance;\n            }, (fraction) => this.fractionToTangentMagnitude(fraction));\n        }\n        return undefined;\n    }\n    /**\n     *\n     * @param fraction fractional position along x axis\n     * @param xy xy coordinates of point on the curve\n     * @param d1xy\n     * @param d2xy\n     * @param d3xy\n     */\n    fractionToPointAnd3Derivatives(fraction, xy, d1xy, d2xy, d3xy) {\n        xy.set(this.fractionToX(fraction), this.fractionToY(fraction), 0);\n        if (d1xy)\n            d1xy.set(this.fractionToDX(fraction), this.fractionToDY(fraction), 0);\n        if (d2xy)\n            d2xy.set(this.fractionToDDX(fraction), this.fractionToDDY(fraction), 0);\n        if (d3xy)\n            d3xy.set(this.fractionToD3X(fraction), this.fractionToD3Y(fraction), 0);\n    }\n}\n// at load time, initialize gauss quadrature workspace\nXYCurveEvaluator.initWorkSpace();\n//# sourceMappingURL=XYCurveEvaluator.js.map",
      "start": 1693508126356,
      "end": 1693508126425,
      "sourcemaps": null
    }
  ]
}
