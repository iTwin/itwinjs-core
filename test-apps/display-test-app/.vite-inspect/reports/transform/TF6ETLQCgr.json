{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/quantity/lib/esm/Formatter/FormatterSpec.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Quantity\n */\nimport { Formatter } from \"./Formatter\";\n// cSpell:ignore ZERONORMALIZED, nosign, onlynegative, signalways, negativeparentheses\n// cSpell:ignore trailzeroes, keepsinglezero, zeroempty, keepdecimalpoint, applyrounding, fractiondash, showunitlabel, prependunitlabel, exponentonlynegative\n/** A class that contains both formatting information and the conversion factors necessary to convert from an input unit to the units specified in the format.\n * Once created the FormatterSpec will be able to format quantity values with synchronous calls.\n * @beta\n */\nexport class FormatterSpec {\n    /** Constructor\n     *  @param name     The name of a format specification.\n     *  @param format   Defines the output format for the quantity value.\n     *  @param conversions An array of conversion factors necessary to convert from an input unit to the units specified in the format.\n     *  @param persistenceUnit The unit the magnitude value is input.\n     */\n    constructor(name, format, conversions, persistenceUnit) {\n        this._conversions = []; // max four entries\n        if (!persistenceUnit) {\n            if (format.units) {\n                const [props] = format.units[0];\n                persistenceUnit = props;\n            }\n            else {\n                throw new Error(\"Formatter Spec needs persistence unit to be specified\");\n            }\n        }\n        this._name = name;\n        this._format = format;\n        this._persistenceUnit = persistenceUnit;\n        if (conversions)\n            this._conversions = conversions;\n    }\n    get name() { return this._name; }\n    /** Returns an array of UnitConversionSpecs, one for each unit that is to be shown in the formatted quantity string. */\n    get unitConversions() { return this._conversions; }\n    get format() { return this._format; }\n    get persistenceUnit() { return this._persistenceUnit; }\n    /** Get an array of UnitConversionSpecs, one for each unit that is to be shown in the formatted quantity string. */\n    static async getUnitConversions(format, unitsProvider, inputUnit) {\n        const conversions = [];\n        let persistenceUnit = inputUnit;\n        if (!persistenceUnit) {\n            if (format.units) {\n                const [props] = format.units[0];\n                persistenceUnit = props;\n            }\n            else {\n                throw new Error(\"Formatter Spec needs persistence unit to be specified\");\n            }\n        }\n        if (format.units) {\n            let convertFromUnit = inputUnit;\n            for (const unit of format.units) {\n                let unitConversion;\n                if (convertFromUnit) {\n                    unitConversion = await unitsProvider.getConversion(convertFromUnit, unit[0]);\n                }\n                else {\n                    unitConversion = { factor: 1.0, offset: 0.0 };\n                }\n                const unitLabel = (unit[1] && unit[1].length > 0) ? unit[1] : unit[0].label;\n                const spec = ({ name: unit[0].name, label: unitLabel, conversion: unitConversion, system: unit[0].system });\n                conversions.push(spec);\n                convertFromUnit = unit[0];\n            }\n        }\n        else {\n            // if format is only numeric and a input unit is defined set spec to use the input unit as the format unit\n            if (inputUnit) {\n                const spec = { name: inputUnit.name, label: inputUnit.label, system: inputUnit.system, conversion: { factor: 1.0, offset: 0.0 } };\n                conversions.push(spec);\n            }\n        }\n        return conversions;\n    }\n    /** Static async method to create a FormatSpec given the format and unit of the quantity that will be passed to the Formatter. The input unit will\n     * be used to generate conversion information for each unit specified in the Format. This method is async due to the fact that the units provider must make\n     * async calls to lookup unit definitions.\n     *  @param name     The name of a format specification.\n     *  @param unitsProvider The units provider is used to look up unit definitions and provide conversion information for converting between units.\n     *  @param inputUnit The unit the value to be formatted. This unit is often referred to as persistence unit.\n     */\n    static async create(name, format, unitsProvider, inputUnit) {\n        const conversions = await FormatterSpec.getUnitConversions(format, unitsProvider, inputUnit);\n        return new FormatterSpec(name, format, conversions, inputUnit);\n    }\n    /** Format a quantity value. */\n    applyFormatting(magnitude) {\n        return Formatter.formatQuantity(magnitude, this);\n    }\n}\n//# sourceMappingURL=FormatterSpec.js.map",
      "start": 1693508124160,
      "end": 1693508124392,
      "sourcemaps": null
    }
  ]
}
