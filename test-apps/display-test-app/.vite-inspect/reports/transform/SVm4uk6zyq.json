{
  "resolvedId": "D:/hub2023A/itwinjs-core/ui/appui-abstract/lib/esm/appui-abstract/toolbars/ToolbarItemsManager.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Toolbar\n */\nimport { BeEvent } from \"@itwin/core-bentley\";\nimport { ConditionalBooleanValue } from \"../items/ConditionalBooleanValue\";\nimport { ConditionalStringValue } from \"../items/ConditionalStringValue\";\nimport { ToolbarItemUtilities } from \"./ToolbarItem\";\nconst isInstance = (args) => {\n    return !Array.isArray(args);\n};\n/**\n * Controls status bar items.\n * @internal\n */\nexport class ToolbarItemsManager {\n    constructor(items) {\n        this._items = [];\n        /** Event raised when Toolbar items are changed.\n         * @internal\n         */\n        this.onItemsChanged = new BeEvent();\n        if (items)\n            this.loadItemsInternal(items, true, false);\n    }\n    loadItemsInternal(items, processConditions, sendItemChanged) {\n        if (processConditions && items) {\n            const eventIds = ToolbarItemsManager.getSyncIdsOfInterest(items);\n            if (0 !== eventIds.length) {\n                const { itemsUpdated, updatedItems } = this.internalRefreshAffectedItems(items, new Set(eventIds));\n                // istanbul ignore else\n                if (itemsUpdated)\n                    items = updatedItems;\n            }\n        }\n        this._items = items;\n        if (sendItemChanged)\n            this.onItemsChanged.raiseEvent({ items });\n    }\n    /** load items but do not fire onItemsChanged\n     * @internal\n     */\n    loadItems(items) {\n        this.loadItemsInternal(items, true, false);\n    }\n    /** Get an array of the Toolbar items  */\n    get items() {\n        return this._items;\n    }\n    set items(items) {\n        // istanbul ignore else\n        if (items !== this._items)\n            this.loadItemsInternal(items, true, true);\n    }\n    add(itemOrItems) {\n        let itemsToAdd;\n        if (isInstance(itemOrItems))\n            itemsToAdd = [itemOrItems];\n        else {\n            itemsToAdd = itemOrItems.filter((itemToAdd, index) => itemOrItems.findIndex((item) => item.id === itemToAdd.id) === index);\n        }\n        itemsToAdd = itemsToAdd.filter((itemToAdd) => this._items.find((item) => item.id === itemToAdd.id) === undefined);\n        if (itemsToAdd.length === 0)\n            return;\n        const items = [\n            ...this._items,\n            ...itemsToAdd,\n        ];\n        this.items = items;\n    }\n    /** Remove Toolbar items based on id */\n    remove(itemIdOrItemIds) {\n        const items = this._items.filter((item) => {\n            return isInstance(itemIdOrItemIds) ? item.id !== itemIdOrItemIds : !itemIdOrItemIds.find((itemId) => itemId === item.id);\n        });\n        this.items = items;\n    }\n    /** @internal */\n    removeAll() {\n        this._items = [];\n    }\n    static gatherSyncIds(eventIds, items) {\n        for (const item of items) {\n            for (const [, entry] of Object.entries(item)) {\n                if (entry instanceof ConditionalBooleanValue) {\n                    entry.syncEventIds.forEach((eventId) => eventIds.add(eventId.toLowerCase()));\n                }\n                else /* istanbul ignore else */ if (entry instanceof ConditionalStringValue) {\n                    entry.syncEventIds.forEach((eventId) => eventIds.add(eventId.toLowerCase()));\n                }\n            }\n            // istanbul ignore else\n            if (ToolbarItemUtilities.isGroupButton(item)) {\n                this.gatherSyncIds(eventIds, item.items);\n            }\n        }\n    }\n    static getSyncIdsOfInterest(items) {\n        const eventIds = new Set();\n        this.gatherSyncIds(eventIds, items);\n        return [...eventIds.values()];\n    }\n    static refreshChildItems(parentItem, eventIds) {\n        const updatedItems = [];\n        let itemsUpdated = false;\n        for (const item of parentItem.items) {\n            const updatedItem = { ...item };\n            if (ToolbarItemUtilities.isGroupButton(updatedItem)) {\n                const { childrenUpdated, childItems } = this.refreshChildItems(updatedItem, eventIds);\n                // istanbul ignore else\n                if (childrenUpdated) {\n                    updatedItem.items = childItems;\n                    itemsUpdated = true;\n                }\n            }\n            for (const [, entry] of Object.entries(updatedItem)) {\n                if (entry instanceof ConditionalBooleanValue) {\n                    // istanbul ignore else\n                    if (ConditionalBooleanValue.refreshValue(entry, eventIds))\n                        itemsUpdated = true;\n                }\n                else /* istanbul ignore else */ if (entry instanceof ConditionalStringValue) {\n                    // istanbul ignore else\n                    if (ConditionalStringValue.refreshValue(entry, eventIds))\n                        itemsUpdated = true;\n                }\n            }\n            updatedItems.push(updatedItem);\n        }\n        return { childrenUpdated: itemsUpdated, childItems: updatedItems };\n    }\n    internalRefreshAffectedItems(items, eventIds) {\n        // istanbul ignore next\n        if (0 === eventIds.size)\n            return { itemsUpdated: false, updatedItems: [] };\n        let updateRequired = false;\n        const newItems = [];\n        for (const item of items) {\n            const updatedItem = { ...item };\n            if (ToolbarItemUtilities.isGroupButton(updatedItem)) {\n                const { childrenUpdated, childItems } = ToolbarItemsManager.refreshChildItems(updatedItem, eventIds);\n                // istanbul ignore else\n                if (childrenUpdated) {\n                    updatedItem.items = childItems;\n                    updateRequired = true;\n                }\n            }\n            for (const [, entry] of Object.entries(updatedItem)) {\n                if (entry instanceof ConditionalBooleanValue) {\n                    // istanbul ignore else\n                    if (ConditionalBooleanValue.refreshValue(entry, eventIds))\n                        updateRequired = true;\n                }\n                else /* istanbul ignore else */ if (entry instanceof ConditionalStringValue) {\n                    // istanbul ignore else\n                    if (ConditionalStringValue.refreshValue(entry, eventIds))\n                        updateRequired = true;\n                }\n            }\n            newItems.push(updatedItem);\n        }\n        return { itemsUpdated: updateRequired, updatedItems: newItems };\n    }\n    refreshAffectedItems(eventIds) {\n        // istanbul ignore next\n        if (0 === eventIds.size)\n            return;\n        const { itemsUpdated, updatedItems } = this.internalRefreshAffectedItems(this.items, eventIds);\n        // istanbul ignore else\n        if (itemsUpdated)\n            this.loadItemsInternal(updatedItems, false, true);\n    }\n    static isActiveToolIdRefreshRequiredForChildren(children, toolId) {\n        for (const item of children) {\n            if (ToolbarItemUtilities.isGroupButton(item)) {\n                if (this.isActiveToolIdRefreshRequiredForChildren(item.items, toolId))\n                    return true;\n            }\n            else {\n                const isActive = !!item.isActive;\n                if ((isActive && item.id !== toolId) || (!isActive && item.id === toolId))\n                    return true;\n            }\n        }\n        return false;\n    }\n    isActiveToolIdRefreshRequired(toolId) {\n        for (const item of this.items) {\n            if (ToolbarItemUtilities.isGroupButton(item)) {\n                if (ToolbarItemsManager.isActiveToolIdRefreshRequiredForChildren(item.items, toolId))\n                    return true;\n            }\n            else {\n                const isActive = !!item.isActive;\n                if ((isActive && item.id !== toolId) || (!isActive && item.id === toolId))\n                    return true;\n            }\n        }\n        return false;\n    }\n    static refreshActiveToolIdInChildItems(parentItem, toolId) {\n        const newChildren = [];\n        for (const item of parentItem.items) {\n            const updatedItem = { ...item };\n            if (ToolbarItemUtilities.isGroupButton(updatedItem)) {\n                updatedItem.items = ToolbarItemsManager.refreshActiveToolIdInChildItems(updatedItem, toolId);\n            }\n            updatedItem.isActive = (updatedItem.id === toolId);\n            newChildren.push(updatedItem);\n        }\n        return newChildren;\n    }\n    setActiveToolId(toolId) {\n        // first see if any updates are really necessary\n        if (!this.isActiveToolIdRefreshRequired(toolId))\n            return;\n        const newItems = [];\n        for (const item of this.items) {\n            const updatedItem = { ...item };\n            if (ToolbarItemUtilities.isGroupButton(updatedItem)) {\n                updatedItem.items = ToolbarItemsManager.refreshActiveToolIdInChildItems(updatedItem, toolId);\n            }\n            updatedItem.isActive = (updatedItem.id === toolId);\n            newItems.push(updatedItem);\n        }\n        this.items = newItems;\n    }\n}\n//# sourceMappingURL=ToolbarItemsManager.js.map",
      "start": 1693508124487,
      "end": 1693508124523,
      "sourcemaps": null
    }
  ]
}
