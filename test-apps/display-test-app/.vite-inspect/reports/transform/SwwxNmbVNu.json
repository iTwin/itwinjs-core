{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/bentley/lib/esm/OrderedId64Iterable.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Ids\n */\nimport { assert } from \"./Assert\";\n/** A collection of **valid** [[Id64String]]s sorted in ascending order by the unsigned 64-bit integer value of the Ids.\n * This ordering is a requirement for several groups of APIs including [[CompressedId64Set]].\n * When used as input to a function, duplicate Ids are ignored; when returned as a function output, no duplicates are present.\n * @see [[CompressedId64Set]] for a compact string representation of such an ordered collection.\n * @see [[OrderedId64Iterable.compare]] for a function that compares Ids based on this criterion.\n * @see [[OrderedId64Array]] for a mutable implementation.\n * @public\n */\nexport var OrderedId64Iterable;\n(function (OrderedId64Iterable) {\n    /** An ordered comparison of [[Id64String]]s suitable for use with sorting routines like\n     * [Array.sort](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort) and sorted containers\n     * like [[SortedArray]] and [[Dictionary]]. The comparison compares the 64-bit numerical values of the two Ids, returning a negative number if lhs < rhs,\n     * a positive number if lhs > rhs, or zero if lhs == rhs.\n     * The default string comparison is fine (and more efficient) when numerical ordering is not required; use this instead if you want e.g., \"0x100\" to be greater than \"0xf\".\n     * @see [[OrderedId64Iterable.sortArray]] for a convenient way to sort an array of Id64Strings.\n     */\n    function compare(lhs, rhs) {\n        if (lhs.length !== rhs.length)\n            return lhs.length < rhs.length ? -1 : 1;\n        // This is faster than localeCompare(). Unclear why there is no string.compare() - would be generally useful in\n        // array sort functions...\n        if (lhs !== rhs)\n            return lhs < rhs ? -1 : 1;\n        return 0;\n    }\n    OrderedId64Iterable.compare = compare;\n    /** Sort an array of [[Id64String]]s **in-place** in ascending order by their 64-bit numerical values.\n     * @see [[OrderedId64Iterable.compare]] for the comparison routine used.\n     * @returns the input array.\n     * @note This function returns its input for consistency with Javascript's\n     * [Array.sort](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort) method.\n     * It **does not** create a **new** array.\n     */\n    function sortArray(ids) {\n        ids.sort((x, y) => compare(x, y));\n        return ids;\n    }\n    OrderedId64Iterable.sortArray = sortArray;\n    /** Given two ordered collections of [[Id64String]]s, determine whether they are identical sets. Duplicate Ids are ignored.\n     * @note If the inputs are not ordered as required by [[OrderedId64Iterable]], the results are unpredictable.\n     */\n    function areEqualSets(ids1, ids2) {\n        const leftIter = uniqueIterator(ids1);\n        const rightIter = uniqueIterator(ids2);\n        let leftState = leftIter.next();\n        let rightState = rightIter.next();\n        while (!leftState.done && !rightState.done) {\n            const left = leftState.value;\n            const right = rightState.value;\n            if (0 !== compare(left, right))\n                return false;\n            leftState = leftIter.next();\n            rightState = rightIter.next();\n        }\n        if (leftState.done && rightState.done)\n            return true;\n        return false;\n    }\n    OrderedId64Iterable.areEqualSets = areEqualSets;\n    /** Given an ordered collection of [[Id64String]]s, determine if it contains any Ids.\n     * @param ids A well-formed, ordered collection of zero or more valid Ids.\n     * @returns true if the input represents an empty set of Ids. The result is unspecified if the input does not meet the criteria for the input type.\n     */\n    function isEmptySet(ids) {\n        if (typeof ids === \"string\")\n            return \"\" === ids;\n        return true === ids[Symbol.iterator]().next().done;\n    }\n    OrderedId64Iterable.isEmptySet = isEmptySet;\n    /** Given an ordered collection of [[Id64String]]s possibly containing duplicates, produce an ordered collection containing no duplicates.\n     * @note If the inputs are not ordered as required by [[OrderedId64Iterable]], the results are unpredictable.\n     */\n    function unique(ids) {\n        return { [Symbol.iterator]: () => uniqueIterator(ids) };\n    }\n    OrderedId64Iterable.unique = unique;\n    /** Given an ordered collection of [[Id64String]]s possibly containing duplicates, produce an ordered iterator over the distinct Ids, eliminating duplicates.\n     * @note If the inputs are not ordered as required by [[OrderedId64Iterable]], the results are unpredictable.\n     */\n    function* uniqueIterator(ids) {\n        const iter = ids[Symbol.iterator]();\n        let state = iter.next();\n        let prev;\n        while (!state.done) {\n            const id = state.value;\n            state = iter.next();\n            if (id !== prev) {\n                prev = id;\n                yield id;\n            }\n        }\n    }\n    OrderedId64Iterable.uniqueIterator = uniqueIterator;\n    /** Given two ordered collections of [[Id64String]]s, produce a collection representing their union - i.e., the Ids that are present in either or both collections.\n     * @note If the inputs are not ordered as required by [[OrderedId64Iterable]], the results are unpredictable.\n     */\n    function union(ids1, ids2) {\n        return { [Symbol.iterator]: () => unionIterator(ids1, ids2) };\n    }\n    OrderedId64Iterable.union = union;\n    /** Given two ordered collections of [[Id64String]]s, produce an iterator representing their intersection - i.e., the Ids that are present in both collections.\n     * @note If the inputs are not ordered as required by [[OrderedId64Iterable]], the results are unpredictable.\n     */\n    function intersection(ids1, ids2) {\n        return { [Symbol.iterator]: () => intersectionIterator(ids1, ids2) };\n    }\n    OrderedId64Iterable.intersection = intersection;\n    /** Given two ordered collections of [[Id64String]]s, produce an iterator representing their difference - i.e., the Ids that are present in `ids1` but not present in `ids2`.\n     * @note If the inputs are not ordered as required by [[OrderedId64Iterable]], the results are unpredictable.\n     */\n    function difference(ids1, ids2) {\n        return { [Symbol.iterator]: () => differenceIterator(ids1, ids2) };\n    }\n    OrderedId64Iterable.difference = difference;\n    /** Given two ordered collections of [[Id64String]]s, produce an iterator representing their union - i.e., the Ids that are present in either or both collections.\n     * @note If the inputs are not ordered as required by [[OrderedId64Iterable]], the results are unpredictable.\n     */\n    function* unionIterator(ids1, ids2) {\n        const leftIter = ids1[Symbol.iterator]();\n        const rightIter = ids2[Symbol.iterator]();\n        let leftState = leftIter.next();\n        let rightState = rightIter.next();\n        let prev;\n        while (!leftState.done || !rightState.done) {\n            const left = leftState.done ? undefined : leftState.value;\n            const right = rightState.done ? undefined : rightState.value;\n            assert(undefined !== left || undefined !== right);\n            if (undefined === left && undefined === right)\n                break;\n            let next;\n            if (undefined === left) {\n                assert(undefined !== right);\n                next = right;\n                rightState = rightIter.next();\n            }\n            else if (undefined === right) {\n                next = left;\n                leftState = leftIter.next();\n            }\n            else {\n                const cmp = compare(left, right);\n                if (cmp <= 0) {\n                    next = left;\n                    leftState = leftIter.next();\n                    if (0 === cmp)\n                        rightState = rightIter.next();\n                }\n                else {\n                    next = right;\n                    rightState = rightIter.next();\n                }\n            }\n            if (prev === next)\n                continue;\n            prev = next;\n            yield next;\n        }\n    }\n    OrderedId64Iterable.unionIterator = unionIterator;\n    /** Given two ordered collections of [[Id64String]]s, produce an iterator representing their intersection - i.e., the Ids that are present in both collections.\n     * @note If the inputs are not ordered as required by [[OrderedId64Iterable]], the results are unpredictable.\n     */\n    function* intersectionIterator(ids1, ids2) {\n        const leftIter = ids1[Symbol.iterator]();\n        const rightIter = ids2[Symbol.iterator]();\n        let leftState = leftIter.next();\n        let rightState = rightIter.next();\n        let prev;\n        while (!leftState.done && !rightState.done) {\n            const left = leftState.value;\n            leftState = leftIter.next();\n            if (left === prev)\n                continue;\n            prev = left;\n            let right = rightState.value;\n            let cmp = compare(left, right);\n            while (cmp > 0) {\n                rightState = rightIter.next();\n                if (rightState.done)\n                    return;\n                right = rightState.value;\n                cmp = compare(left, right);\n            }\n            if (0 === cmp)\n                yield left;\n        }\n    }\n    OrderedId64Iterable.intersectionIterator = intersectionIterator;\n    /** Given two ordered collections of [[Id64String]]s, produce an iterator representing their difference - i.e., the Ids that are present in `ids1` but not present in `ids2`.\n     * @note If the inputs are not ordered as required by [[OrderedId64Iterable]], the results are unpredictable.\n     */\n    function* differenceIterator(ids1, ids2) {\n        const leftIter = ids1[Symbol.iterator]();\n        const rightIter = ids2[Symbol.iterator]();\n        let leftState = leftIter.next();\n        let rightState = rightIter.next();\n        let prev;\n        while (!leftState.done) {\n            const left = leftState.value;\n            leftState = leftIter.next();\n            if (left === prev)\n                continue;\n            else if (rightState.done) {\n                yield prev = left;\n                continue;\n            }\n            let right = rightState.value;\n            let cmp = compare(left, right);\n            while (cmp > 0 && !rightState.done) {\n                rightState = rightIter.next();\n                if (rightState.done) {\n                    yield prev = left;\n                    continue;\n                }\n                right = rightState.value;\n                cmp = compare(left, right);\n            }\n            if (cmp < 0)\n                yield prev = left;\n        }\n    }\n    OrderedId64Iterable.differenceIterator = differenceIterator;\n})(OrderedId64Iterable || (OrderedId64Iterable = {}));\n//# sourceMappingURL=OrderedId64Iterable.js.map",
      "start": 1693508120598,
      "end": 1693508120660,
      "sourcemaps": null
    }
  ]
}
