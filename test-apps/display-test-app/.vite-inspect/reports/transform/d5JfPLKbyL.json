{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/polyface/FacetOrientation.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Polyface\n */\nimport { SortableEdge } from \"./IndexedEdgeMatcher\";\nimport { PolyfaceQuery } from \"./PolyfaceQuery\";\nclass OrientedComponentData {\n    constructor(firstEdgeIndex) {\n        this.numPositive = this.numNegative = 0;\n        this.firstEdgeIndex = firstEdgeIndex;\n    }\n    // announce a new facet orientation.\n    recordOrientation(orientation) {\n        if (orientation > 0)\n            this.numPositive++;\n        else if (orientation < 0)\n            this.numNegative++;\n    }\n}\nexport class FacetOrientationFixup {\n    constructor(mesh) {\n        this._workArray = [];\n        this._visitor = mesh.createVisitor(1);\n        this._edges = PolyfaceQuery.createIndexedEdges(this._visitor);\n        this._edgeToPartnerEdge = [];\n        this._edgeToEdgeInComponent = [];\n        this._facetToFirstEdgeInComponent = [];\n        this._facetOrientation = [];\n        this._components = [];\n        this._mesh = mesh;\n    }\n    edgeIdToFacetOrientation(edgeId) {\n        const facetIndex = this._edges.edges[edgeId].facetIndex;\n        return this._facetOrientation[facetIndex];\n    }\n    /**\n     * RETURN FALSE IF ANY EDGE HAS 3 ORE MORE FACETS\n     */\n    setupUnoriented() {\n        this._edges.sort();\n        const edgeArray = this._edges.edges;\n        // make each edge a singleton with itself as successor . .\n        let maxFacetIndex = -1;\n        const numEdges = this._edges.edges.length;\n        for (let i = 0; i < numEdges; i++) {\n            const facetIndex = this._edges.edges[i].facetIndex;\n            if (facetIndex > maxFacetIndex)\n                maxFacetIndex = facetIndex;\n            this._edgeToEdgeInComponent.push(i);\n            this._edgeToPartnerEdge.push(i);\n        }\n        for (let i = 0; i <= maxFacetIndex; i++) {\n            this._facetToFirstEdgeInComponent.push(-1);\n            this._facetOrientation.push(0);\n        }\n        // make each edge part of a component for only its own facet\n        // (This component exists only ephemerally -- it is not referenced by true component)\n        // (swapping entries in the cyclic loops merges loops.)\n        for (let i = 0; i < numEdges; i++) {\n            const facetIndex = this._edges.edges[i].facetIndex;\n            const j = this._facetToFirstEdgeInComponent[facetIndex];\n            if (j === -1)\n                this._facetToFirstEdgeInComponent[facetIndex] = i;\n            else {\n                FacetOrientationFixup.swapEntries(this._edgeToEdgeInComponent, i, j);\n            }\n        }\n        // make contiguous partner edges cycles in edgeToPartnerEdge.\n        // edge i is initially always a singleton.\n        for (let edgeIndex0 = 0; edgeIndex0 < numEdges; edgeIndex0++) {\n            let edgeIndex1 = edgeIndex0 + 1;\n            while (edgeIndex1 < numEdges && SortableEdge.areUndirectedPartners(edgeArray[edgeIndex0], edgeArray[edgeIndex1])) {\n                // splice the loops ...\n                FacetOrientationFixup.swapEntries(this._edgeToPartnerEdge, edgeIndex0, edgeIndex1);\n                edgeIndex1++;\n            }\n            // BUT .. everything else will fail if more than 2 anywhere .....\n            if (edgeIndex1 > edgeIndex0 + 2)\n                return false;\n        }\n        return true;\n    }\n    recordFacetInComponent(facetIndex, orientation) {\n        const componentData = this._components[this._components.length - 1];\n        this._facetOrientation[facetIndex] = orientation;\n        componentData.recordOrientation(orientation);\n    }\n    initializeComponent(edgeIndex) {\n        const facetIndex = this._edges.edges[edgeIndex].facetIndex;\n        this._components.push(new OrientedComponentData(edgeIndex));\n        this.recordFacetInComponent(facetIndex, 1);\n    }\n    pushFacetEdgesOnStack(seedEdge, stack) {\n        FacetOrientationFixup.extractCyclicIndices(this._edgeToEdgeInComponent, seedEdge, this._workArray);\n        for (const edgeIndex of this._workArray) {\n            stack.push(edgeIndex);\n        }\n    }\n    /**\n     * * Run flood search from every possible seed, assigning positive and negative orientations\n     * * Halt and return false if flood detects Klein bottle effects.\n     * @return true if flood\n     */\n    doFlood() {\n        // Finally time for flood search.\n        const edgeStack = [];\n        const edgeArray = this._edges.edges;\n        const numEdges = edgeArray.length;\n        const neighborEdges = [];\n        for (let seedEdgeIndex = 0; seedEdgeIndex < numEdges; seedEdgeIndex++) {\n            if (this.edgeIdToFacetOrientation(seedEdgeIndex) === 0) {\n                edgeStack.length = 0;\n                this.initializeComponent(seedEdgeIndex);\n                this.pushFacetEdgesOnStack(seedEdgeIndex, edgeStack);\n                // An edge on the stack is part of the current component.\n                // Its partners may or may not have been visited.\n                let baseEdgeIndex;\n                while (undefined !== (baseEdgeIndex = edgeStack.pop())) {\n                    const baseFacet = edgeArray[baseEdgeIndex].facetIndex;\n                    const baseOrientation = this._facetOrientation[baseFacet];\n                    FacetOrientationFixup.extractCyclicIndices(this._edgeToPartnerEdge, baseEdgeIndex, neighborEdges);\n                    for (const neighborEdgeIndex of neighborEdges) {\n                        if (neighborEdgeIndex !== baseEdgeIndex) {\n                            const neighborFacet = edgeArray[neighborEdgeIndex].facetIndex;\n                            const neighborOrientation = this._facetOrientation[neighborFacet];\n                            if (neighborOrientation === 0) {\n                                // first visit to this facet !\n                                // orientations of baseEdge and neighborEdge tell us how to orient it.\n                                const newOrientation = SortableEdge.areDirectedPartners(edgeArray[baseEdgeIndex], edgeArray[neighborEdgeIndex]) ? baseOrientation : -baseOrientation;\n                                this.recordFacetInComponent(neighborFacet, newOrientation);\n                                this.pushFacetEdgesOnStack(neighborEdgeIndex, edgeStack);\n                                FacetOrientationFixup.swapEntries(this._edgeToEdgeInComponent, baseEdgeIndex, neighborEdgeIndex);\n                            }\n                            else {\n                                // looking across to an already-visited facet ..\n                                const edgeOrientation = SortableEdge.relativeOrientation(edgeArray[baseEdgeIndex], edgeArray[neighborEdgeIndex]);\n                                if (edgeOrientation * baseOrientation * neighborOrientation > 0)\n                                    return false;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        // fall through when floods have completed in all components, with no Klein bottle effects\n        return true;\n    }\n    doFacetReversals() {\n        let numReverse = 0;\n        for (this._visitor.reset(); this._visitor.moveToNextFacet();) {\n            const facetIndex = this._visitor.currentReadIndex();\n            if (this._facetOrientation[facetIndex] < 0) {\n                numReverse++;\n                this._mesh.reverseSingleFacet(facetIndex);\n            }\n        }\n        return numReverse;\n    }\n    static doFixup(mesh) {\n        const context = new FacetOrientationFixup(mesh);\n        if (!context.setupUnoriented())\n            return false;\n        const ok = context.doFlood();\n        if (ok)\n            context.doFacetReversals();\n        return ok;\n    }\n    /** swap entries at indices in a number array.\n     * * indices are not checked for validity.\n     */\n    static swapEntries(data, i, j) {\n        const q = data[i];\n        data[i] = data[j];\n        data[j] = q;\n    }\n    /**\n     *\n     * @param data an array of cyclically linked loops.\n     */\n    static extractCyclicIndices(data, index0, loopIndices) {\n        loopIndices.length = 0;\n        let i = index0;\n        do {\n            loopIndices.push(i);\n            i = data[i];\n        } while (i !== index0);\n    }\n}\n//# sourceMappingURL=FacetOrientation.js.map",
      "start": 1693508125502,
      "end": 1693508125603,
      "sourcemaps": null
    }
  ]
}
