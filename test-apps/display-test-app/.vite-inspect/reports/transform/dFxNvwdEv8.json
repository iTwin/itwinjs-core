{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/curve/internalContexts/ClosestPointStrokeHandler.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Curve\n */\nimport { Geometry } from \"../../Geometry\";\nimport { Point3d } from \"../../geometry3d/Point3dVector3d\";\nimport { Ray3d } from \"../../geometry3d/Ray3d\";\nimport { Newton1dUnboundedApproximateDerivative } from \"../../numerics/Newton\";\nimport { CurveExtendOptions } from \"../CurveExtendMode\";\nimport { CurveLocationDetail } from \"../CurveLocationDetail\";\nimport { NewtonRtoRStrokeHandler } from \"./NewtonRtoRStrokeHandler\";\n/**\n * Context for searching for the closest point to a CurvePrimitive.\n * @internal\n */\nexport class ClosestPointStrokeHandler extends NewtonRtoRStrokeHandler {\n    constructor(spacePoint, extend) {\n        super();\n        this._fractionA = 0;\n        this._functionA = 0;\n        this._functionB = 0;\n        this._fractionB = 0;\n        this._numThisCurve = 0;\n        this._spacePoint = spacePoint;\n        this._workPoint = Point3d.create();\n        this._workRay = Ray3d.createZero();\n        this._closestPoint = undefined;\n        this._extend = extend;\n        this.startCurvePrimitive(undefined);\n        this._newtonSolver = new Newton1dUnboundedApproximateDerivative(this);\n    }\n    claimResult() {\n        if (this._closestPoint) {\n            this._newtonSolver.setX(this._closestPoint.fraction);\n            this._curve = this._closestPoint.curve;\n            if (this._newtonSolver.runIterations()) {\n                let fraction = this._newtonSolver.getX();\n                fraction = CurveExtendOptions.correctFraction(this._extend, fraction);\n                this.announceSolutionFraction(fraction);\n            }\n        }\n        return this._closestPoint;\n    }\n    needPrimaryGeometryForStrokes() {\n        return true;\n    }\n    startCurvePrimitive(curve) {\n        this._curve = curve;\n        this._fractionA = 0.0;\n        this._numThisCurve = 0;\n        this._functionA = 0.0;\n    }\n    endCurvePrimitive() {\n    }\n    announceIntervalForUniformStepStrokes(cp, numStrokes, fraction0, fraction1) {\n        this.startCurvePrimitive(cp);\n        this.announceSolutionFraction(0.0); // test start point as closest\n        this.announceSolutionFraction(1.0); // test end point as closest\n        if (numStrokes < 1)\n            numStrokes = 1;\n        const df = 1.0 / numStrokes;\n        for (let i = 0; i <= numStrokes; i++) {\n            const fraction = Geometry.interpolate(fraction0, i * df, fraction1);\n            cp.fractionToPointAndDerivative(fraction, this._workRay);\n            this.announceRay(fraction, this._workRay);\n        }\n    }\n    announceCandidate(cp, fraction, point) {\n        const distance = this._spacePoint.distance(point);\n        if (this._closestPoint && distance > this._closestPoint.a)\n            return;\n        this._closestPoint = CurveLocationDetail.createCurveFractionPoint(cp, fraction, point, this._closestPoint);\n        this._closestPoint.a = distance;\n        if (this._parentCurvePrimitive !== undefined)\n            this._closestPoint.curve = this._parentCurvePrimitive;\n    }\n    announceSegmentInterval(cp, point0, point1, _numStrokes, fraction0, fraction1) {\n        let localFraction = this._spacePoint.fractionOfProjectionToLine(point0, point1, 0.0);\n        // only consider extending the segment if the immediate caller says we are at endpoints ...\n        if (!this._extend)\n            localFraction = Geometry.clampToStartEnd(localFraction, 0.0, 1.0);\n        else {\n            if (fraction0 !== 0.0)\n                localFraction = Math.max(localFraction, 0.0);\n            if (fraction1 !== 1.0)\n                localFraction = Math.min(localFraction, 1.0);\n        }\n        this._workPoint = point0.interpolate(localFraction, point1);\n        const globalFraction = Geometry.interpolate(fraction0, localFraction, fraction1);\n        this.announceCandidate(cp, globalFraction, this._workPoint);\n    }\n    searchInterval() {\n        if (this._functionA * this._functionB > 0)\n            return;\n        if (this._functionA === 0)\n            this.announceSolutionFraction(this._fractionA);\n        if (this._functionB === 0)\n            this.announceSolutionFraction(this._fractionB);\n        if (this._functionA * this._functionB < 0) {\n            const fraction = Geometry.inverseInterpolate(this._fractionA, this._functionA, this._fractionB, this._functionB);\n            if (fraction) {\n                this._newtonSolver.setX(fraction);\n                if (this._newtonSolver.runIterations())\n                    this.announceSolutionFraction(this._newtonSolver.getX());\n            }\n        }\n    }\n    evaluateB(fractionB, dataB) {\n        this._functionB = dataB.dotProductToPoint(this._spacePoint);\n        this._fractionB = fractionB;\n    }\n    announceSolutionFraction(fraction) {\n        if (this._curve)\n            this.announceCandidate(this._curve, fraction, this._curve.fractionToPoint(fraction));\n    }\n    evaluate(fraction) {\n        let curve = this._curve;\n        if (this._parentCurvePrimitive)\n            curve = this._parentCurvePrimitive;\n        if (curve) {\n            this._workRay = curve.fractionToPointAndDerivative(fraction, this._workRay);\n            this.currentF = this._workRay.dotProductToPoint(this._spacePoint);\n            return true;\n        }\n        return false;\n    }\n    announceRay(fraction, data) {\n        this.evaluateB(fraction, data);\n        if (this._numThisCurve++ > 0)\n            this.searchInterval();\n        this._functionA = this._functionB;\n        this._fractionA = this._fractionB;\n    }\n    announcePointTangent(point, fraction, tangent) {\n        this._workRay.set(point, tangent);\n        this.announceRay(fraction, this._workRay);\n    }\n}\n//# sourceMappingURL=ClosestPointStrokeHandler.js.map",
      "start": 1693508125334,
      "end": 1693508125455,
      "sourcemaps": null
    }
  ]
}
