{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/TechniqueFlags.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { RenderMode } from \"@itwin/core-common\";\n/** Flags used to control which shader program is used by a rendering Technique.\n * @internal\n */\nclass TechniqueFlags {\n    constructor(translucent = false) {\n        this.numClipPlanes = 0;\n        this.featureMode = 0 /* FeatureMode.None */;\n        this.isEdgeTestNeeded = 0 /* IsEdgeTestNeeded.No */;\n        this.isAnimated = 0 /* IsAnimated.No */;\n        this.isInstanced = 0 /* IsInstanced.No */;\n        this.isClassified = 0 /* IsClassified.No */;\n        this.isShadowable = 0 /* IsShadowable.No */;\n        this.isThematic = 0 /* IsThematic.No */;\n        this.isWiremesh = 0 /* IsWiremesh.No */;\n        this.positionType = \"quantized\";\n        this.enableAtmosphere = 0 /* EnableAtmosphere.No */;\n        this._isHilite = false;\n        this.isTranslucent = translucent;\n    }\n    get hasClip() {\n        return this.numClipPlanes > 0;\n    }\n    get usesQuantizedPositions() {\n        return \"quantized\" === this.positionType;\n    }\n    init(target, pass, instanced, animated = 0 /* IsAnimated.No */, classified = 0 /* IsClassified.No */, shadowable = 0 /* IsShadowable.No */, thematic = 0 /* IsThematic.No */, wiremesh = 0 /* IsWiremesh.No */, posType = \"quantized\", enableAtmosphere = 0 /* EnableAtmosphere.No */) {\n        const clipStack = target.uniforms.branch.clipStack;\n        const numClipPlanes = clipStack.hasClip ? clipStack.textureHeight : 0;\n        this.positionType = posType;\n        if (10 /* RenderPass.Hilite */ === pass || 16 /* RenderPass.HiliteClassification */ === pass || 18 /* RenderPass.HilitePlanarClassification */ === pass) {\n            const isClassified = (classified === 1 /* IsClassified.Yes */ && 18 /* RenderPass.HilitePlanarClassification */ === pass) ? 1 /* IsClassified.Yes */ : 0 /* IsClassified.No */;\n            this.initForHilite(numClipPlanes, instanced, isClassified, posType);\n        }\n        else {\n            this._isHilite = false;\n            this.isTranslucent = 8 /* RenderPass.Translucent */ === pass;\n            this.numClipPlanes = numClipPlanes;\n            this.isAnimated = animated;\n            this.isInstanced = instanced;\n            this.isClassified = classified;\n            this.isShadowable = shadowable;\n            this.isThematic = thematic;\n            this.isWiremesh = wiremesh;\n            this.enableAtmosphere = enableAtmosphere;\n            this.featureMode = target.uniforms.batch.featureMode;\n            // Determine if we should use the shaders which support discarding surfaces in favor of their edges (and discarding non-planar surfaces in favor of coincident planar surfaces).\n            // These are only useful if the geometry defines feature Ids.\n            // In 3d, if we're only displaying surfaces or edges, not both, don't bother, unless forceSurfaceDiscard is true.\n            this.isEdgeTestNeeded = this.hasFeatures ? (this.isClassified ? 0 /* IsEdgeTestNeeded.No */ : 1 /* IsEdgeTestNeeded.Yes */) : 0 /* IsEdgeTestNeeded.No */;\n            if (!target.currentViewFlags.forceSurfaceDiscard && target.is3d && !target.isReadPixelsInProgress && this.isEdgeTestNeeded) {\n                switch (target.currentViewFlags.renderMode) {\n                    case RenderMode.Wireframe:\n                        // We're only displaying edges (ignoring filled planar regions)\n                        this.isEdgeTestNeeded = 0 /* IsEdgeTestNeeded.No */;\n                        break;\n                    case RenderMode.SmoothShade:\n                        if (!target.currentViewFlags.visibleEdges && !target.wantAmbientOcclusion && pass !== 19 /* RenderPass.PlanarClassification */) {\n                            // We're only displaying surfaces (ignoring filled planar regions).\n                            // NB: Filled text (blanking region) is handled by adjusting the depth in the surface vertex shader.\n                            this.isEdgeTestNeeded = 0 /* IsEdgeTestNeeded.No */;\n                        }\n                        break;\n                    default:\n                        // SolidFill and HiddenLine always display edges and surfaces.\n                        break;\n                }\n            }\n        }\n    }\n    reset(mode, instanced = 0 /* IsInstanced.No */, shadowable, thematic, posType) {\n        this._isHilite = false;\n        this.featureMode = mode;\n        this.isTranslucent = false;\n        this.isEdgeTestNeeded = 0 /* IsEdgeTestNeeded.No */;\n        this.isAnimated = 0 /* IsAnimated.No */;\n        this.isClassified = 0 /* IsClassified.No */;\n        this.isInstanced = instanced;\n        this.isShadowable = shadowable;\n        this.isThematic = thematic;\n        this.isWiremesh = 0 /* IsWiremesh.No */;\n        this.positionType = posType;\n        this.enableAtmosphere = 0 /* EnableAtmosphere.No */;\n        this.numClipPlanes = 0;\n    }\n    get hasFeatures() { return 0 /* FeatureMode.None */ !== this.featureMode; }\n    setAnimated(animated) { this.isAnimated = animated ? 1 /* IsAnimated.Yes */ : 0 /* IsAnimated.No */; }\n    setInstanced(instanced) { this.isInstanced = instanced ? 1 /* IsInstanced.Yes */ : 0 /* IsInstanced.No */; }\n    setClassified(classified) {\n        this.isClassified = classified ? 1 /* IsClassified.Yes */ : 0 /* IsClassified.No */;\n    }\n    get isHilite() { return this._isHilite; }\n    initForHilite(numClipPlanes, instanced, classified, posType) {\n        this.featureMode = classified ? 0 /* FeatureMode.None */ : 2 /* FeatureMode.Overrides */;\n        this._isHilite = true;\n        this.isTranslucent = false;\n        this.isEdgeTestNeeded = 0 /* IsEdgeTestNeeded.No */;\n        this.isAnimated = 0 /* IsAnimated.No */;\n        this.isInstanced = instanced;\n        this.isClassified = classified;\n        this.numClipPlanes = numClipPlanes;\n        this.positionType = posType;\n    }\n    equals(other) {\n        return this.numClipPlanes === other.numClipPlanes\n            && this.featureMode === other.featureMode\n            && this.isTranslucent === other.isTranslucent\n            && this.isEdgeTestNeeded === other.isEdgeTestNeeded\n            && this.isAnimated === other.isAnimated\n            && this.isInstanced === other.isInstanced\n            && this.isClassified === other.isClassified\n            && this.isShadowable === other.isShadowable\n            && this.isThematic === other.isThematic\n            && this.isWiremesh === other.isWiremesh\n            && this.positionType === other.positionType\n            && this.enableAtmosphere === other.enableAtmosphere\n            && this.isHilite === other.isHilite;\n    }\n    buildDescription() {\n        const parts = [this.isTranslucent ? \"Translucent\" : \"Opaque\"];\n        if (this.isInstanced)\n            parts.push(\"Instanced\");\n        if (this.isEdgeTestNeeded)\n            parts.push(\"EdgeTestNeeded\");\n        if (this.isAnimated)\n            parts.push(\"Animated\");\n        if (this.isHilite)\n            parts.push(\"Hilite\");\n        if (this.isClassified)\n            parts.push(\"Classified\");\n        if (this.hasClip)\n            parts.push(\"Clip\");\n        if (this.isShadowable)\n            parts.push(\"Shadowable\");\n        if (this.isThematic)\n            parts.push(\"Thematic\");\n        if (this.hasFeatures)\n            parts.push(1 /* FeatureMode.Pick */ === this.featureMode ? \"Pick\" : \"Overrides\");\n        if (this.isWiremesh)\n            parts.push(\"Wiremesh\");\n        if (this.positionType === \"unquantized\")\n            parts.push(\"Unquantized\");\n        if (this.enableAtmosphere)\n            parts.push(\"EnableAtmosphere\");\n        return parts.join(\"-\");\n    }\n    static fromDescription(description) {\n        const flags = new TechniqueFlags(false);\n        const parts = description.split(\"-\");\n        for (const part of parts) {\n            switch (part) {\n                case \"Translucent\":\n                    flags.isTranslucent = true;\n                    break;\n                case \"Instanced\":\n                    flags.isInstanced = 1 /* IsInstanced.Yes */;\n                    break;\n                case \"EdgeTestNeeded\":\n                    flags.isEdgeTestNeeded = 1 /* IsEdgeTestNeeded.Yes */;\n                    break;\n                case \"Animated\":\n                    flags.isAnimated = 1 /* IsAnimated.Yes */;\n                    break;\n                case \"Hilite\":\n                    flags._isHilite = true;\n                    break;\n                case \"Classified\":\n                    flags.isClassified = 1 /* IsClassified.Yes */;\n                    break;\n                case \"Clip\":\n                    flags.numClipPlanes = 1;\n                    break;\n                case \"Shadowable\":\n                    flags.isShadowable = 1 /* IsShadowable.Yes */;\n                    break;\n                case \"Thematic\":\n                    flags.isThematic = 1 /* IsThematic.Yes */;\n                    break;\n                case \"Wiremesh\":\n                    flags.isWiremesh = 1 /* IsWiremesh.Yes */;\n                    break;\n                case \"Unquantized\":\n                    flags.positionType = \"unquantized\";\n                    break;\n                case \"EnableAtmosphere\":\n                    flags.enableAtmosphere = 1 /* EnableAtmosphere.Yes */;\n                    break;\n                case \"Pick\":\n                    flags.featureMode = 1 /* FeatureMode.Pick */;\n                    break;\n                case \"Overrides\":\n                    flags.featureMode = 2 /* FeatureMode.Overrides */;\n                    break;\n            }\n        }\n        return flags;\n    }\n}\nTechniqueFlags.defaults = new TechniqueFlags();\nexport { TechniqueFlags };\n//# sourceMappingURL=TechniqueFlags.js.map",
      "start": 1693508124719,
      "end": 1693508124877,
      "sourcemaps": null
    }
  ]
}
