{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/common/lib/esm/geometry/Cartographic.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Geometry\n */\nimport { Angle, Constant, Point3d, Range1d, Range2d, Vector3d } from \"@itwin/core-geometry\";\nimport { assert } from \"@itwin/core-bentley\";\n/** A position on the earth defined by longitude, latitude, and height above the [WGS84](https://en.wikipedia.org/wiki/World_Geodetic_System) ellipsoid.\n * @public\n */\nclass Cartographic {\n    /**\n     * @param longitude longitude, in radians.\n     * @param latitude latitude, in radians.\n     * @param height The height, in meters, above the ellipsoid.\n     */\n    constructor(longitude = 0, latitude = 0, height = 0) {\n        this.longitude = longitude;\n        this.latitude = latitude;\n        this.height = height;\n    }\n    /** Create a Cartographic object with longitude, latitude, and height of zero. */\n    static createZero() {\n        return new Cartographic(0, 0, 0);\n    }\n    /** Create a new Cartographic from longitude and latitude specified in radians.\n     * @param args an object containing a longitude, latitude, and an optional height property. The longitude and latitude properties are numbers specified in radians. The height property, if specified, is a number which contains the height in meters above the ellipsoid; if undefined, this height will default to zero.\n     * @param result The object onto which to store the result.\n     */\n    static fromRadians(args, result) {\n        if (!result)\n            return new Cartographic(args.longitude, args.latitude, args.height);\n        result.longitude = args.longitude;\n        result.latitude = args.latitude;\n        result.height = args.height !== undefined ? args.height : 0;\n        return result;\n    }\n    /** Create a JSON representation of a Cartographic object. */\n    toJSON() {\n        return {\n            latitude: this.latitude,\n            longitude: this.longitude,\n            height: this.height,\n        };\n    }\n    /** Freeze this Cartographic */\n    freeze() {\n        return Object.freeze(this);\n    }\n    /** longitude, in degrees */\n    get longitudeDegrees() {\n        return Angle.radiansToDegrees(this.longitude);\n    }\n    /** latitude, in degrees */\n    get latitudeDegrees() {\n        return Angle.radiansToDegrees(this.latitude);\n    }\n    /** return the geocentric latitude angle for the input geodetic latitude angle (both in radians).\n     * @param geodeticLatitude geodetic latitude angle in radians\n     */\n    static geocentricLatitudeFromGeodeticLatitude(geodeticLatitude) {\n        return Math.atan(Cartographic._oneMinusF * Cartographic._oneMinusF * Math.tan(geodeticLatitude));\n    }\n    /** return the parametric latitude angle for the input geodetic latitude angle (both in radians).  The parametric latitude\n     * is appropriate for input to the Ellipsoid methods.\n     * @param geodeticLatitude geodetic latitude angle in radians\n     */\n    static parametricLatitudeFromGeodeticLatitude(geodeticLatitude) {\n        return Math.atan(Cartographic._oneMinusF * Cartographic._oneMinusF * Cartographic._equatorOverPolar * Math.tan(geodeticLatitude));\n    }\n    /** Create a new Cartographic from longitude and latitude specified in degrees. The values in the resulting object will be in radians.\n     * @param args an object containing a longitude, latitude, and an optional height property. The longitude and latitude properties are numbers specified in degrees. The height property, if specified, is a number which contains the height in meters above the ellipsoid; if undefined, this height will default to zero.\n     * @param result The object onto which to store the result.\n     */\n    static fromDegrees(args, result) {\n        return Cartographic.fromRadians({ longitude: Angle.degreesToRadians(args.longitude), latitude: Angle.degreesToRadians(args.latitude), height: args.height }, result);\n    }\n    /** Create a new Cartographic from longitude and latitude in [Angle]($geometry)s. The values in the resulting object will be in radians.\n     * @param args an object containing a longitude, latitude, and an optional height property. The longitude and latitude properties are Angle objects. The height property, if specified, is a number which contains the height in meters above the ellipsoid; if undefined, this height will default to zero.\n     * @param result The object into which to store the result (optional)\n     */\n    static fromAngles(args, result) {\n        return Cartographic.fromRadians({ longitude: args.longitude.radians, latitude: args.latitude.radians, height: args.height }, result);\n    }\n    /** Creates a new Cartographic from an [ECEF](https://en.wikipedia.org/wiki/ECEF) position.\n     * @param cartesian The position, in ECEF, to convert to cartographic representation.\n     * @param [result] The object onto which to store the result.\n     * @returns The modified result parameter, new Cartographic instance if none was provided, or undefined if the cartesian is at the center of the ellipsoid.\n     */\n    static fromEcef(cartesian, result) {\n        const oneOverRadiiSquared = Cartographic._wgs84OneOverRadiiSquared;\n        const p = Cartographic.scalePointToGeodeticSurface(cartesian, Cartographic._cartesianToCartographicP);\n        if (!p)\n            return undefined;\n        const n = Cartographic._cartesianToCartographicN;\n        Cartographic.multiplyComponents(p, oneOverRadiiSquared, n);\n        Cartographic.normalize(n, n);\n        const h = p.vectorTo(cartesian, Cartographic._cartesianToCartographicH);\n        const longitude = Math.atan2(n.y, n.x);\n        const latitude = Math.asin(n.z);\n        const height = Math.sign(h.dotProduct(cartesian)) * h.magnitude();\n        if (!result)\n            return new Cartographic(longitude, latitude, height);\n        result.longitude = longitude;\n        result.latitude = latitude;\n        result.height = height;\n        return result;\n    }\n    /** Scale point to geodetic surface\n     * @param point in ECEF to scale to the surface\n     * @param [result] The object onto which to store the result.\n     * @returns a point on the geodetic surface\n     */\n    static scalePointToGeodeticSurface(point, result) {\n        const oneOverRadii = Cartographic._wgs84OneOverRadii;\n        const oneOverRadiiSquared = Cartographic._wgs84OneOverRadiiSquared;\n        const centerToleranceSquared = Cartographic._wgs84CenterToleranceSquared;\n        return Cartographic._scaleToGeodeticSurface(point, oneOverRadii, oneOverRadiiSquared, centerToleranceSquared, result);\n    }\n    /** Duplicates a Cartographic. */\n    clone(result) {\n        if (!result)\n            return new Cartographic(this.longitude, this.latitude, this.height);\n        result.longitude = this.longitude;\n        result.latitude = this.latitude;\n        result.height = this.height;\n        return result;\n    }\n    /** Return true if this Cartographic is the same as right */\n    equals(right) {\n        return (this === right) ||\n            ((this.longitude === right.longitude) &&\n                (this.latitude === right.latitude) &&\n                (this.height === right.height));\n    }\n    /** Compares this Cartographic component-wise and returns true if they are within the provided epsilon, */\n    equalsEpsilon(right, epsilon) {\n        return (this === right) ||\n            ((Math.abs(this.longitude - right.longitude) <= epsilon) &&\n                (Math.abs(this.latitude - right.latitude) <= epsilon) &&\n                (Math.abs(this.height - right.height) <= epsilon));\n    }\n    static normalize(cartesian, result) {\n        const magnitude = cartesian.magnitude();\n        result.x = cartesian.x / magnitude;\n        result.y = cartesian.y / magnitude;\n        result.z = cartesian.z / magnitude;\n    }\n    static multiplyComponents(left, right, result) {\n        result.x = left.x * right.x;\n        result.y = left.y * right.y;\n        result.z = left.z * right.z;\n    }\n    static scalePoint(cartesian, scalar, result) {\n        result.x = cartesian.x * scalar;\n        result.y = cartesian.y * scalar;\n        result.z = cartesian.z * scalar;\n    }\n    static addPoints(left, right, result) {\n        result.x = left.x + right.x;\n        result.y = left.y + right.y;\n        result.z = left.z + right.z;\n    }\n    /** Create a string representing this cartographic in the format '(longitude, latitude, height)'. */\n    toString() { return `(${this.longitude}, ${this.latitude}, ${this.height})`; }\n    static _scaleToGeodeticSurface(cartesian, oneOverRadii, oneOverRadiiSquared, centerToleranceSquared, result) {\n        const positionX = cartesian.x;\n        const positionY = cartesian.y;\n        const positionZ = cartesian.z;\n        const oneOverRadiiX = oneOverRadii.x;\n        const oneOverRadiiY = oneOverRadii.y;\n        const oneOverRadiiZ = oneOverRadii.z;\n        const x2 = positionX * positionX * oneOverRadiiX * oneOverRadiiX;\n        const y2 = positionY * positionY * oneOverRadiiY * oneOverRadiiY;\n        const z2 = positionZ * positionZ * oneOverRadiiZ * oneOverRadiiZ;\n        // Compute the squared ellipsoid norm.\n        const squaredNorm = x2 + y2 + z2;\n        const ratio = Math.sqrt(1.0 / squaredNorm);\n        // As an initial approximation, assume that the radial intersection is the projection point.\n        const intersection = Cartographic._scaleToGeodeticSurfaceIntersection;\n        Cartographic.scalePoint(cartesian, ratio, intersection);\n        // If the position is near the center, the iteration will not converge.\n        if (squaredNorm < centerToleranceSquared) {\n            return !isFinite(ratio) ? undefined : Point3d.createFrom(intersection, result);\n        }\n        const oneOverRadiiSquaredX = oneOverRadiiSquared.x;\n        const oneOverRadiiSquaredY = oneOverRadiiSquared.y;\n        const oneOverRadiiSquaredZ = oneOverRadiiSquared.z;\n        // Use the gradient at the intersection point in place of the true unit normal.\n        // The difference in magnitude will be absorbed in the multiplier.\n        const gradient = Cartographic._scaleToGeodeticSurfaceGradient;\n        gradient.x = intersection.x * oneOverRadiiSquaredX * 2.0;\n        gradient.y = intersection.y * oneOverRadiiSquaredY * 2.0;\n        gradient.z = intersection.z * oneOverRadiiSquaredZ * 2.0;\n        // Compute the initial guess at the normal vector multiplier, lambda.\n        let lambda = (1.0 - ratio) * cartesian.magnitude() / (0.5 * gradient.magnitude());\n        let correction = 0.0;\n        let func;\n        let denominator;\n        let xMultiplier;\n        let yMultiplier;\n        let zMultiplier;\n        let xMultiplier2;\n        let yMultiplier2;\n        let zMultiplier2;\n        let xMultiplier3;\n        let yMultiplier3;\n        let zMultiplier3;\n        do {\n            lambda -= correction;\n            xMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredX);\n            yMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredY);\n            zMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredZ);\n            xMultiplier2 = xMultiplier * xMultiplier;\n            yMultiplier2 = yMultiplier * yMultiplier;\n            zMultiplier2 = zMultiplier * zMultiplier;\n            xMultiplier3 = xMultiplier2 * xMultiplier;\n            yMultiplier3 = yMultiplier2 * yMultiplier;\n            zMultiplier3 = zMultiplier2 * zMultiplier;\n            func = x2 * xMultiplier2 + y2 * yMultiplier2 + z2 * zMultiplier2 - 1.0;\n            // \"denominator\" here refers to the use of this expression in the velocity and acceleration\n            // computations in the sections to follow.\n            denominator = x2 * xMultiplier3 * oneOverRadiiSquaredX + y2 * yMultiplier3 * oneOverRadiiSquaredY + z2 * zMultiplier3 * oneOverRadiiSquaredZ;\n            const derivative = -2.0 * denominator;\n            correction = func / derivative;\n        } while (Math.abs(func) > 0.01);\n        if (!result)\n            return new Point3d(positionX * xMultiplier, positionY * yMultiplier, positionZ * zMultiplier);\n        result.x = positionX * xMultiplier;\n        result.y = positionY * yMultiplier;\n        result.z = positionZ * zMultiplier;\n        return result;\n    }\n    /** Return an ECEF point from a Cartographic point */\n    toEcef(result) {\n        const cosLatitude = Math.cos(this.latitude);\n        const scratchN = Cartographic._scratchN;\n        const scratchK = Cartographic._scratchK;\n        scratchN.x = cosLatitude * Math.cos(this.longitude);\n        scratchN.y = cosLatitude * Math.sin(this.longitude);\n        scratchN.z = Math.sin(this.latitude);\n        Cartographic.normalize(scratchN, scratchN);\n        Cartographic.multiplyComponents(Cartographic._wgs84RadiiSquared, scratchN, scratchK);\n        const gamma = Math.sqrt(scratchN.dotProduct(scratchK));\n        Cartographic.scalePoint(scratchK, 1.0 / gamma, scratchK);\n        Cartographic.scalePoint(scratchN, this.height, scratchN);\n        result = result ? result : new Point3d();\n        Cartographic.addPoints(scratchK, scratchN, result);\n        return result;\n    }\n}\nCartographic._oneMinusF = 1 - (Constant.earthRadiusWGS84.equator - Constant.earthRadiusWGS84.polar) / Constant.earthRadiusWGS84.equator;\nCartographic._equatorOverPolar = Constant.earthRadiusWGS84.equator / Constant.earthRadiusWGS84.polar;\nCartographic._cartesianToCartographicN = new Point3d();\nCartographic._cartesianToCartographicP = new Point3d();\nCartographic._cartesianToCartographicH = new Vector3d();\nCartographic._wgs84OneOverRadii = new Point3d(1.0 / 6378137.0, 1.0 / 6378137.0, 1.0 / 6356752.3142451793);\nCartographic._wgs84OneOverRadiiSquared = new Point3d(1.0 / (6378137.0 * 6378137.0), 1.0 / (6378137.0 * 6378137.0), 1.0 / (6356752.3142451793 * 6356752.3142451793));\nCartographic._wgs84RadiiSquared = new Point3d(6378137.0 * 6378137.0, 6378137.0 * 6378137.0, 6356752.3142451793 * 6356752.3142451793);\nCartographic._wgs84CenterToleranceSquared = 0.1;\nCartographic._scratchN = new Vector3d();\nCartographic._scratchK = new Vector3d();\nCartographic._scaleToGeodeticSurfaceIntersection = new Point3d();\nCartographic._scaleToGeodeticSurfaceGradient = new Point3d();\nexport { Cartographic };\n/** A cartographic range representing a rectangular region if low longitude/latitude > high then area crossing seam is indicated.\n * @public\n */\nexport class CartographicRange {\n    constructor(spatialRange, spatialToEcef) {\n        this._ranges = [];\n        // These following are used to preserve the min/max latitude and longitudes.\n        // The longitudes are raw values and may cross over the -PI or 2PI boundaries.\n        this._minLongitude = 0;\n        this._maxLongitude = 0;\n        this._minLatitude = 0;\n        this._maxLatitude = 0;\n        // Compute 8 corners in spatial coordinate system before converting to ECEF\n        // We want a box oriented in the spatial coordinate system and not in the ECEF coordinate system\n        const spatialCorners = spatialRange.corners();\n        const ecefCorners = spatialToEcef.multiplyPoint3dArray(spatialCorners);\n        let low, high;\n        for (const ecefCorner of ecefCorners) {\n            const geoPt = Cartographic.fromEcef(ecefCorner);\n            if (!geoPt)\n                continue;\n            if (undefined === low || undefined === high) {\n                low = geoPt;\n                high = geoPt.clone();\n                continue;\n            }\n            low.latitude = Math.min(low.latitude, geoPt.latitude);\n            low.longitude = Math.min(low.longitude, geoPt.longitude);\n            high.latitude = Math.max(high.latitude, geoPt.latitude);\n            high.longitude = Math.max(high.longitude, geoPt.longitude);\n        }\n        if (!low || !high) {\n            assert(false);\n            return;\n        }\n        const longitudeRanges = [];\n        this._minLongitude = Math.min(low.longitude, high.longitude), this._maxLongitude = Math.max(low.longitude, high.longitude);\n        if (this._maxLongitude - this._minLongitude > Angle.piRadians) {\n            longitudeRanges.push(Range1d.createXX(0.0, this._minLongitude));\n            longitudeRanges.push(Range1d.createXX(this._maxLongitude, Angle.pi2Radians));\n        }\n        else {\n            longitudeRanges.push(Range1d.createXX(this._minLongitude, this._maxLongitude));\n        }\n        for (const longitudeRange of longitudeRanges) {\n            this._minLatitude = Math.min(low.latitude, high.latitude), this._maxLatitude = Math.max(low.latitude, high.latitude);\n            if (this._maxLatitude - this._minLatitude > Angle.piOver2Radians) {\n                this._ranges.push(Range2d.createXYXY(longitudeRange.low, 0.0, longitudeRange.high, this._minLatitude));\n                this._ranges.push(Range2d.createXYXY(longitudeRange.low, this._maxLatitude, longitudeRange.high, Angle.piRadians));\n            }\n            else {\n                this._ranges.push(Range2d.createXYXY(longitudeRange.low, this._minLatitude, longitudeRange.high, this._maxLatitude));\n            }\n        }\n    }\n    intersectsRange(other) {\n        for (const range of this._ranges)\n            for (const otherRange of other._ranges)\n                if (range.intersectsRange(otherRange))\n                    return true;\n        return false;\n    }\n    /** This method returns the raw latitude / longitude for the range in a Range2d object.\n     * The X value represents the longitude and the Y value the latitudes.\n     * Y values are kept between -PI and +PI while\n     * longitude values can be expressed in any range between -2PI to +2PI\n     * given the minimum longitude is always smaller numerically than the maximum longitude.\n     * Note that usually the longitudes are usually by convention in the range of -PI to PI except\n     * for ranges that overlap the -PI/+PI frontier in which case either representation is acceptable.\n     */\n    getLongitudeLatitudeBoundingBox() {\n        return Range2d.createXYXY(this._minLongitude, this._minLatitude, this._maxLongitude, this._maxLatitude);\n    }\n}\n//# sourceMappingURL=Cartographic.js.map",
      "start": 1693508120756,
      "end": 1693508120816,
      "sourcemaps": null
    }
  ]
}
