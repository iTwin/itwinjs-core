{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/polyface/multiclip/SweepLineStringToFacetContext.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Polyface\n */\nimport { Transform } from \"../../geometry3d/Transform\";\nimport { Point3d, Vector3d } from \"../../geometry3d/Point3dVector3d\";\nimport { Segment1d } from \"../../geometry3d/Segment1d\";\nimport { Range3d } from \"../../geometry3d/Range\";\nimport { Geometry } from \"../../Geometry\";\nimport { ClipPlane } from \"../../clipping/ClipPlane\";\nimport { ConvexClipPlaneSet } from \"../../clipping/ConvexClipPlaneSet\";\nimport { IndexedXYZCollectionPolygonOps, Point3dArrayPolygonOps } from \"../../geometry3d/PolygonOps\";\nimport { Matrix3d } from \"../../geometry3d/Matrix3d\";\nexport class SweepLineStringToFacetContext {\n    constructor(spacePoints) {\n        // temporaries reused over multiple calls to process a single facet . ..\n        this._segmentPoint0 = Point3d.create();\n        this._segmentPoint1 = Point3d.create();\n        this._localSegmentPoint0 = Point3d.create();\n        this._localSegmentPoint1 = Point3d.create();\n        this._clipFractions = Segment1d.create(0, 1);\n        this._localFrame = Transform.createIdentity();\n        this._polygonRange = Range3d.create();\n        this._spacePoints = spacePoints;\n        this._spacePointsRange = new Range3d();\n        spacePoints.setRange(this._spacePointsRange);\n        this._numSpacePoints = this._spacePoints.length;\n    }\n    static create(xyz) {\n        if (xyz.length > 1) {\n            return new SweepLineStringToFacetContext(xyz.clone());\n        }\n        return undefined;\n    }\n    /** process a single polygon.\n     * @returns number crudely indicating how much work was done.\n     */\n    projectToPolygon(polygon, announce, polyface, readIndex) {\n        polygon.setRange(this._polygonRange);\n        let workCounter = 0;\n        if (!this._polygonRange.intersectsRangeXY(this._spacePointsRange))\n            return workCounter;\n        // numTest++;\n        // For each triangle within the facet ...\n        // remark: this loop only runs once in triangle mesh, twice in quads ...\n        for (let k1 = 1; k1 + 1 < polygon.length; k1++) {\n            workCounter++;\n            const frame = polygon.fillLocalXYTriangleFrame(0, k1, k1 + 1, this._localFrame);\n            if (frame) {\n                // For each stroke of the linestring ...\n                for (let i1 = 1; i1 < this._numSpacePoints; i1++) {\n                    workCounter++;\n                    this._spacePoints.getPoint3dAtCheckedPointIndex(i1 - 1, this._segmentPoint0);\n                    this._spacePoints.getPoint3dAtCheckedPointIndex(i1, this._segmentPoint1);\n                    frame.multiplyInversePoint3d(this._segmentPoint0, this._localSegmentPoint0);\n                    frame.multiplyInversePoint3d(this._segmentPoint1, this._localSegmentPoint1);\n                    this._clipFractions.set(0, 1);\n                    /** (x,y,1-x-y) are barycentric coordinates in the triangle !!! */\n                    if (this._clipFractions.clipBy01FunctionValuesPositive(this._localSegmentPoint0.x, this._localSegmentPoint1.x)\n                        && this._clipFractions.clipBy01FunctionValuesPositive(this._localSegmentPoint0.y, this._localSegmentPoint1.y)\n                        && this._clipFractions.clipBy01FunctionValuesPositive(1 - this._localSegmentPoint0.x - this._localSegmentPoint0.y, 1 - this._localSegmentPoint1.x - this._localSegmentPoint1.y)) {\n                        /* project the local segment point to the plane. */\n                        workCounter++;\n                        const localClippedPointA = this._localSegmentPoint0.interpolate(this._clipFractions.x0, this._localSegmentPoint1);\n                        const localClippedPointB = this._localSegmentPoint0.interpolate(this._clipFractions.x1, this._localSegmentPoint1);\n                        const worldClippedPointA = this._localFrame.multiplyPoint3d(localClippedPointA);\n                        const worldClippedPointB = this._localFrame.multiplyPoint3d(localClippedPointB);\n                        const planePointA = this._localFrame.multiplyXYZ(localClippedPointA.x, localClippedPointA.y, 0.0);\n                        const planePointB = this._localFrame.multiplyXYZ(localClippedPointB.x, localClippedPointB.y, 0.0);\n                        const splitParameter = Geometry.inverseInterpolate01(this._localSegmentPoint0.z, this._localSegmentPoint1.z);\n                        // emit 1 or 2 panels, oriented so panel normal is always to the left of the line.\n                        if (splitParameter !== undefined && splitParameter > this._clipFractions.x0 && splitParameter < this._clipFractions.x1) {\n                            workCounter++;\n                            const piercePointX = this._segmentPoint0.interpolate(splitParameter, this._segmentPoint1);\n                            const piercePointY = piercePointX.clone(); // so points are distinct for the two triangle announcements.\n                            announce(this._spacePoints, i1 - 1, polyface, readIndex, [worldClippedPointA, piercePointX, planePointA], 2, 1);\n                            announce(this._spacePoints, i1 - 1, polyface, readIndex, [worldClippedPointB, piercePointY, planePointB], 1, 2);\n                        }\n                        else if (this._localSegmentPoint0.z > 0) { // segment is entirely above\n                            announce(this._spacePoints, i1 - 1, polyface, readIndex, [worldClippedPointA, worldClippedPointB, planePointB, planePointA], 3, 2);\n                        }\n                        else // segment is entirely under\n                            announce(this._spacePoints, i1 - 1, polyface, readIndex, [worldClippedPointB, worldClippedPointA, planePointA, planePointB], 2, 3);\n                    }\n                }\n            }\n        }\n        return workCounter;\n    }\n}\n/**\n * Context for sweeping a line segment onto a convex polygon.\n * @internal\n */\nexport class EdgeClipData {\n    /** CAPTURE the planes */\n    constructor(edgePlane, clip) {\n        this.edgePlane = edgePlane;\n        this.clip = clip;\n        this._crossingPoints = [];\n    }\n    /** create object from segment and sweep. Inputs are not captured. */\n    static createPointPointSweep(pointA, pointB, sweep) {\n        const edgeVector = Vector3d.createStartEnd(pointA, pointB);\n        const fraction = edgeVector.fractionOfProjectionToVector(sweep);\n        // The unbounded plane of the swept edge will intersect facets in lines that may extend beyond the swept bounded line.\n        // That linework will be clipped between two facing planes with normal along the perpendicular dropped from the edge vector to the sweep vector.\n        const clipNormal = edgeVector.plusScaled(sweep, -fraction);\n        const planeA = ClipPlane.createNormalAndPoint(clipNormal, pointA);\n        const planeB = ClipPlane.createNormalAndPoint(clipNormal, pointB);\n        const edgePlane = ClipPlane.createOriginAndVectors(pointA, edgeVector, sweep);\n        if (planeA !== undefined && planeB !== undefined && edgePlane !== undefined) {\n            planeB.negateInPlace();\n            const clipper = ConvexClipPlaneSet.createPlanes([planeA, planeB]);\n            return new EdgeClipData(edgePlane, clipper);\n        }\n        return undefined;\n    }\n    /** Intersect this edge plane with the given convex polygon and announce the intersection segment to the callback. */\n    processPolygon(polygon, announceEdge) {\n        this._crossingPoints.length = 0;\n        if (Array.isArray(polygon))\n            Point3dArrayPolygonOps.polygonPlaneCrossings(this.edgePlane, polygon, this._crossingPoints);\n        else\n            IndexedXYZCollectionPolygonOps.polygonPlaneCrossings(this.edgePlane, polygon, this._crossingPoints);\n        if (this._crossingPoints.length === 2) {\n            // use the end planes to clip the [0,1] swept edge to [f0,f1]\n            this.clip.announceClippedSegmentIntervals(0, 1, this._crossingPoints[0], this._crossingPoints[1], (f0, f1) => {\n                announceEdge(this._crossingPoints[0].interpolate(f0, this._crossingPoints[1]), this._crossingPoints[0].interpolate(f1, this._crossingPoints[1]));\n            });\n        }\n    }\n}\n/**\n * Context for sweeping a line string onto a convex polygon.\n * @internal\n */\nexport class ClipSweptLineStringContext {\n    constructor(edgeData, localData) {\n        this._edgeClippers = edgeData;\n        if (localData !== undefined) {\n            this._localToWorld = localData.localToWorld;\n            this._worldToLocal = localData.worldToLocal;\n            this._localRange = localData.localRange;\n        }\n    }\n    static create(xyz, sweepVector) {\n        if (sweepVector === undefined)\n            sweepVector = Vector3d.create(0, 0, 1);\n        if (xyz.length > 1) {\n            const point = Point3d.createZero();\n            const newPoint = Point3d.createZero();\n            const edgeData = [];\n            xyz.getPoint3dAtUncheckedPointIndex(0, point);\n            let localToWorldMatrix = Matrix3d.createRigidHeadsUp(sweepVector);\n            if (localToWorldMatrix === undefined)\n                localToWorldMatrix = Matrix3d.createIdentity();\n            const localToWorld = Transform.createOriginAndMatrix(point, localToWorldMatrix);\n            const worldToLocal = localToWorld.inverse();\n            const localRange = xyz.getRange(worldToLocal);\n            for (let i = 1; i < xyz.length; i++) {\n                xyz.getPoint3dAtUncheckedPointIndex(i, newPoint);\n                const clipper = EdgeClipData.createPointPointSweep(point, newPoint, sweepVector);\n                if (clipper !== undefined) {\n                    point.setFrom(newPoint);\n                    edgeData.push(clipper);\n                }\n            }\n            return new ClipSweptLineStringContext(edgeData, { localToWorld, worldToLocal, localRange });\n        }\n        return undefined;\n    }\n    /**\n     * Intersect a polygon with each of the edgeClippers.\n     * * If transforms and local range are defined, test the polygon's local range to see if it offers a quick exit.\n     */\n    processPolygon(polygon, announceEdge) {\n        if (this._worldToLocal !== undefined && this._localRange !== undefined) {\n            const polygonRange = Range3d.createTransformedArray(this._worldToLocal, polygon);\n            if (!polygonRange.intersectsRangeXY(this._localRange))\n                return;\n        }\n        for (const clipper of this._edgeClippers) {\n            clipper.processPolygon(polygon, announceEdge);\n        }\n    }\n}\n//# sourceMappingURL=SweepLineStringToFacetContext.js.map",
      "start": 1693508125529,
      "end": 1693508125610,
      "sourcemaps": null
    }
  ]
}
