{
  "resolvedId": "D:/hub2023A/itwinjs-core/common/temp/node_modules/.pnpm/vhacd-js@0.0.1/node_modules/vhacd-js/lib/vhacd.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import instantiateModule from \"../lib/vhacd-wasm.js\";\nimport { VHACD } from \"./vhacd-wasm-api.js\";\nexport var ConvexMeshDecomposition;\n(function (ConvexMeshDecomposition) {\n    let vhacd;\n    /** Create a ConvexMeshDecomposition. */\n    async function create() {\n        if (!vhacd)\n            vhacd = await instantiateModule();\n        return {\n            computeConvexHulls: (mesh, options) => computeConvexHulls(vhacd, mesh, options),\n        };\n    }\n    ConvexMeshDecomposition.create = create;\n})(ConvexMeshDecomposition || (ConvexMeshDecomposition = {}));\nfunction populateParameters(params, opts) {\n    const numericKeys = [\"maxHulls\", \"voxelResolution\", \"minVolumePercentError\", \"maxRecursionDepth\", \"maxVerticesPerHull\", \"minEdgeLength\"];\n    for (const key of numericKeys) {\n        const opt = opts[key];\n        if (undefined !== opt)\n            params[key] = opt;\n    }\n    if (undefined !== opts.shrinkWrap)\n        params.shrinkWrap = opts.shrinkWrap;\n    if (undefined !== opts.findBestPlane)\n        params.findBestPlane = opts.findBestPlane;\n    switch (opts.fillMode) {\n        case \"flood\":\n            params.fillMode = VHACD.FillMode.Flood;\n            break;\n        case \"surface\":\n            params.fillMode = VHACD.FillMode.Surface;\n            break;\n        case \"raycast\":\n            params.fillMode = VHACD.FillMode.Raycast;\n            break;\n    }\n}\nfunction computeConvexHulls(vhacd, mesh, opts) {\n    if (mesh.positions.length < 9 || mesh.indices.length < 3)\n        return [];\n    if (mesh.positions.length % 3 !== 0)\n        throw new Error(\"3 coordinates required per vertex\");\n    if (mesh.indices.length % 3 !== 0)\n        throw new Error(\"Triangles required.\");\n    const params = new vhacd.Parameters();\n    if (opts)\n        populateParameters(params, opts);\n    let messages = VHACD.MessageType.None;\n    switch (opts === null || opts === void 0 ? void 0 : opts.messages) {\n        case \"all\":\n            messages = VHACD.MessageType.All;\n            break;\n        case \"log\":\n            messages = VHACD.MessageType.Log;\n            break;\n        case \"progress\":\n            messages = VHACD.MessageType.Progress;\n            break;\n    }\n    let pPoints = 0;\n    let pTriangles = 0;\n    let decomposer;\n    try {\n        // Allocate everything first, in case memory grows.\n        pPoints = vhacd._malloc(8 * mesh.positions.length);\n        pTriangles = vhacd._malloc(4 * mesh.indices.length);\n        // Initialize memory.\n        vhacd.HEAPF64.set(mesh.positions, pPoints / 8);\n        vhacd.HEAPU32.set(mesh.indices, pTriangles / 4);\n        decomposer = new vhacd.MeshDecomposer(params, messages);\n        const hulls = decomposer.compute(pPoints, mesh.positions.length / 3, pTriangles, mesh.indices.length / 3);\n        const meshes = [];\n        const nHulls = hulls.size();\n        for (let i = 0; i < nHulls; i++) {\n            const hull = hulls.get(i);\n            const pts = hull.getPoints() / 8;\n            const tris = hull.getTriangles() / 4;\n            const mesh = {\n                positions: vhacd.HEAPF64.slice(pts, pts + hull.numPoints * 3),\n                indices: vhacd.HEAPU32.slice(tris, tris + hull.numTriangles * 3),\n            };\n            // console.log({ positions: Array.from(mesh.positions), indices: Array.from(mesh.indices) });\n            meshes.push(mesh);\n        }\n        return meshes;\n    }\n    finally {\n        vhacd._free(pPoints);\n        vhacd._free(pTriangles);\n        decomposer === null || decomposer === void 0 ? void 0 : decomposer.dispose();\n    }\n}\n//# sourceMappingURL=vhacd.js.map",
      "start": 1693508124058,
      "end": 1693508124353,
      "sourcemaps": null
    }
  ]
}
