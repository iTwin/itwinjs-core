{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/polyface/multiclip/GriddedRaggedRange2dSet.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module RangeSearch\n */\nimport { Range2d } from \"../../geometry3d/Range\";\nimport { LinearSearchRange2dArray } from \"./LinearSearchRange2dArray\";\n/**\n * A GriddedRaggedRange2dSet is:\n * * A doubly dimensioned array of Range2dSearchInterface.\n * * Each entry represents a block in a uniform grid within the master range.\n * * Member ranges are noted in the grid block containing the range's lower left corner.\n * * Member ranges larger than twice the grid size are rejected by the insert method.\n * * Hence a search involving a point in grid block (i,j) must examine ranges in grid blocks left and below, i.e. (i-1,j-1), (i-1,j), (i,j-1)\n * @public\n */\nexport class GriddedRaggedRange2dSet {\n    constructor(range, numXEdge, numYEdge) {\n        this._range = range;\n        this._numXEdge = numXEdge;\n        this._numYEdge = numYEdge;\n        this._rangesInBlock = [];\n        for (let j = 0; j < this._numYEdge; j++) {\n            const thisRow = [];\n            for (let i = 0; i < this._numXEdge; i++) {\n                thisRow.push(undefined);\n            }\n            this._rangesInBlock.push(thisRow);\n        }\n    }\n    /**\n     * Create an (empty) set of ranges.\n     * @param range master range\n     * @param numXEdge size of grid in x direction\n     * @param numYEdge size of grid in y direction\n     */\n    static create(range, numXEdge, numYEdge) {\n        if (numXEdge < 1 || numYEdge < 1 || range.isNull || range.isSinglePoint)\n            return undefined;\n        return new GriddedRaggedRange2dSet(range.clone(), numXEdge, numYEdge);\n    }\n    xIndex(x) {\n        const fraction = (x - this._range.low.x) / (this._range.high.x - this._range.low.x);\n        return Math.floor(fraction * this._numXEdge);\n    }\n    yIndex(y) {\n        const fraction = (y - this._range.low.y) / (this._range.high.y - this._range.low.y);\n        return Math.floor(fraction * this._numXEdge);\n    }\n    getBlock(i, j) {\n        if (i >= 0 && i < this._numXEdge && j >= 0 && j < this._numYEdge) {\n            if (!this._rangesInBlock[j][i])\n                this._rangesInBlock[j][i] = new LinearSearchRange2dArray();\n            return this._rangesInBlock[j][i];\n        }\n        return undefined;\n    }\n    /** If possible, insert a range into the set.\n     * * Decline to insert (and return false) if:\n     *    * range is null\n     *    * range is not completely contained in the overall range of this set\n     *    * range x or y extent is larger than 2 grid blocks\n     */\n    conditionalInsert(range, tag) {\n        if (Range2d.isNull(range))\n            return false;\n        if (!this._range.containsRange(range))\n            return false;\n        const xIndex0 = this.xIndex(range.low.x);\n        const xIndex1 = this.xIndex(range.high.x);\n        const yIndex0 = this.yIndex(range.low.y);\n        const yIndex1 = this.yIndex(range.high.y);\n        if (!(xIndex0 === xIndex1 || xIndex0 + 1 === xIndex1))\n            return false;\n        if (!(yIndex0 === yIndex1 || yIndex0 + 1 === yIndex1))\n            return false;\n        const rangesInBlock = this.getBlock(xIndex0, yIndex0);\n        if (rangesInBlock) {\n            rangesInBlock.addRange(range, tag);\n            return true;\n        }\n        return false;\n    }\n    /** Add a range to the search set. */\n    addRange(range, tag) {\n        this.conditionalInsert(range, tag);\n    }\n    /**\n     * * Search a single block\n     * * Pass each range and tag to handler\n     * * and return false if bad cell or if handler returns false.\n     * @param testRange search range.\n     * @param handler function to receive range and tag hits.\n     * @return false if search terminated by handler.  Return true if no handler returned false.\n     */\n    searchXYInIndexedBlock(i, j, x, y, handler) {\n        const rangesInBlock = this.getBlock(i, j);\n        if (!rangesInBlock)\n            return true;\n        return rangesInBlock.searchXY(x, y, handler);\n    }\n    /**\n     * * Search a single block\n     * * Pass each range and tag to handler\n     * * and return false if bad cell or if handler returns false.\n     * @param testRange search range.\n     * @param handler function to receive range and tag hits.\n     * @return false if search terminated by handler.  Return true if no handler returned false.\n     */\n    searchRange2dInIndexedBlock(i, j, testRange, handler) {\n        const rangesInBlock = this.getBlock(i, j);\n        if (!rangesInBlock)\n            return true;\n        return rangesInBlock.searchRange2d(testRange, handler);\n    }\n    /**\n     * * Search for ranges containing testRange\n     * * Pass each range and tag to handler\n     * * terminate search if handler returns false.\n     * @param testRange search range.\n     * @param handler function to receive range and tag hits.\n     * @return false if search terminated by handler.  Return true if no handler returned false.\n     */\n    searchXY(x, y, handler) {\n        const i = this.xIndex(x);\n        const j = this.yIndex(y);\n        return this.searchXYInIndexedBlock(i, j, x, y, handler)\n            && this.searchXYInIndexedBlock(i - 1, j, x, y, handler)\n            && this.searchXYInIndexedBlock(i, j - 1, x, y, handler)\n            && this.searchXYInIndexedBlock(i - 1, j - 1, x, y, handler);\n    }\n    /**\n     * * Search for ranges overlapping testRange\n     * * Pass each range and tag to handler\n     * * terminate search if handler returns false.\n     * @param testRange search range.\n     * @param handler function to receive range and tag hits.\n     * @return false if search terminated by handler.  Return true if no handler returned false.\n     */\n    searchRange2d(testRange, handler) {\n        const xIndex0 = this.xIndex(testRange.low.x) - 1;\n        const xIndex1 = this.xIndex(testRange.high.x);\n        const yIndex0 = this.yIndex(testRange.low.y) - 1;\n        const yIndex1 = this.yIndex(testRange.high.y);\n        for (let i = xIndex0; i <= xIndex1; i++) {\n            for (let j = yIndex0; j <= yIndex1; j++) {\n                if (!this.searchRange2dInIndexedBlock(i, j, testRange, handler))\n                    return false;\n            }\n        }\n        return true;\n    }\n    /** Return the overall range of all members. */\n    totalRange(result) {\n        if (result)\n            result.setNull();\n        else\n            result = Range2d.createNull();\n        this.visitChildren(0, (_depth, child) => {\n            const childRange = GriddedRaggedRange2dSet._workRange = child.totalRange(GriddedRaggedRange2dSet._workRange);\n            result.extendRange(childRange);\n        });\n        return result;\n    }\n    /** Call the handler on each defined block in the grid. */\n    visitChildren(initialDepth, handler) {\n        for (const row of this._rangesInBlock) {\n            for (const block of row) {\n                if (block)\n                    handler(initialDepth, block);\n            }\n        }\n    }\n}\n//# sourceMappingURL=GriddedRaggedRange2dSet.js.map",
      "start": 1693508123920,
      "end": 1693508124074,
      "sourcemaps": null
    }
  ]
}
