{
  "resolvedId": "D:/hub2023A/itwinjs-core/editor/frontend/lib/esm/CreateElementTool.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Editing\n */\nimport { Id64, IModelStatus } from \"@itwin/core-bentley\";\nimport { Constant, Point3d, Vector3d } from \"@itwin/core-geometry\";\nimport { IModelError, isPlacement3dProps } from \"@itwin/core-common\";\nimport { CoordSystem, CoreTools, EventHandled, GraphicBranch, IModelApp, PrimitiveTool, readElementGraphics, ToolAssistance, ToolAssistanceImage, ToolAssistanceInputMethod } from \"@itwin/core-frontend\";\nfunction computeChordToleranceFromPointAndRadius(vp, center, radius) {\n    if (vp.view.is3d() && vp.view.isCameraOn) {\n        const nearFrontCenter = vp.getFrustum(CoordSystem.World).frontCenter;\n        const toFront = Vector3d.createStartEnd(center, nearFrontCenter);\n        const viewZ = vp.rotation.rowZ();\n        // If the sphere overlaps the near front plane just use near front point. This also handles behind eye conditions.\n        if (viewZ.dotProduct(toFront) < radius) {\n            center = nearFrontCenter;\n        }\n        else {\n            // Find point on sphere closest to eye.\n            const toEye = center.unitVectorTo(vp.view.camera.eye);\n            // Only if not already behind the eye.\n            if (toEye) {\n                toEye.scaleInPlace(radius);\n                center.addInPlace(toEye);\n            }\n        }\n    }\n    const viewPt = vp.worldToViewMap.transform0.multiplyPoint3dQuietNormalize(center);\n    const viewPt2 = new Point3d(viewPt.x + 1.0, viewPt.y, viewPt.z);\n    const pixelSize = vp.worldToViewMap.transform1.multiplyPoint3dQuietNormalize(viewPt).distance(vp.worldToViewMap.transform1.multiplyPoint3dQuietNormalize(viewPt2));\n    // Return size of a physical pixel in meters.\n    return (0.0 !== pixelSize ? vp.target.adjustPixelSizeForLOD(pixelSize) : 0.001);\n}\n/** Calculate a view based chord tolerance for facetting curved geometry given a world coordinate and optional radius.\n * @beta\n */\nexport function computeChordToleranceFromPoint(vp, pt, radius) {\n    return computeChordToleranceFromPointAndRadius(vp, pt, radius ? radius : Constant.oneCentimeter);\n}\n/** Calculate a view based chord tolerance for facetting curved geometry given a world coordinate range box.\n * @beta\n */\nexport function computeChordToleranceFromRange(vp, range) {\n    return computeChordToleranceFromPointAndRadius(vp, range.center, 0.5 * range.low.distance(range.high));\n}\n/** A class for creating and managing a RenderGraphic for the purpose of interactive tool dynamics.\n * @beta\n */\nexport class DynamicGraphicsProvider {\n    constructor(iModel, prefix) {\n        /** Chord tolerance to use to stroke the element's geometry in meters */\n        this.chordTolerance = 0.001;\n        this.iModel = iModel;\n        this.prefix = prefix;\n    }\n    getRequestId(id) { return `${this.prefix}-${id}`; }\n    getToleranceLog10() { return Math.floor(Math.log10(this.chordTolerance)); }\n    async createRequest(categoryId, placement, geometry) {\n        let graphicData;\n        let is3d;\n        if (is3d = isPlacement3dProps(placement)) {\n            const requestProps = {\n                id: this.getRequestId(this.elementId ? this.elementId : Id64.invalid),\n                elementId: this.elementId,\n                modelId: this.modelId,\n                toleranceLog10: this.getToleranceLog10(),\n                type: \"3d\",\n                placement,\n                categoryId,\n                geometry,\n            };\n            graphicData = await IModelApp.tileAdmin.requestElementGraphics(this.iModel, requestProps);\n            is3d = true;\n        }\n        else {\n            const requestProps = {\n                id: this.getRequestId(this.elementId ? this.elementId : Id64.invalid),\n                elementId: this.elementId,\n                modelId: this.modelId,\n                toleranceLog10: this.getToleranceLog10(),\n                type: \"2d\",\n                placement,\n                categoryId,\n                geometry,\n            };\n            graphicData = await IModelApp.tileAdmin.requestElementGraphics(this.iModel, requestProps);\n        }\n        if (undefined === graphicData)\n            return;\n        const graphic = await readElementGraphics(graphicData, this.iModel, this.modelId ? this.modelId : Id64.invalid, is3d, { noFlash: true, noHilite: true });\n        if (undefined === graphic)\n            return;\n        return IModelApp.renderSystem.createGraphicOwner(graphic);\n    }\n    /** Call to request a RenderGraphic for the supplied geometry and placement.\n     * @see [[cleanupGraphic]] Must be called when the tool exits.\n     */\n    async createGraphic(categoryId, placement, geometry) {\n        try {\n            const graphic = await this.createRequest(categoryId, placement, geometry);\n            this.cleanupGraphic();\n            return (undefined !== (this.graphic = graphic));\n        }\n        catch {\n            return false;\n        }\n    }\n    /** Call to request a RenderGraphic for the supplied geometry and trigger a dynamic update upon fulfillment.\n     * @note May be useful to update a dynamic preview outside of normal button and motion events, ex. modifier key change.\n     * @see [[cleanupGraphic]] Must be called when the tool exits.\n     */\n    createGraphicAndUpdateDynamics(ev, categoryId, placement, geometry) {\n        const promise = this._graphicPromise = this.createGraphic(categoryId, placement, geometry);\n        promise.then(() => {\n            if (promise !== this._graphicPromise)\n                return; // abandoned this request...\n            IModelApp.toolAdmin.updateDynamics(ev);\n        }).catch((_) => { });\n    }\n    /** Call to dispose of [[RenderGraphic]] held by [[RenderGraphicOwner]].\n     * @note Must be called when the tool exits to avoid leaks of graphics memory or other webgl resources.\n     */\n    cleanupGraphic() {\n        if (undefined === this.graphic)\n            return;\n        this.graphic.disposeGraphic();\n        this.graphic = undefined;\n    }\n    addGraphic(context, transform) {\n        if (undefined === this.graphic)\n            return;\n        if (undefined === transform) {\n            context.addGraphic(this.graphic);\n            return;\n        }\n        const branch = new GraphicBranch(false);\n        branch.add(this.graphic);\n        const branchGraphic = context.createBranch(branch, transform);\n        context.addGraphic(branchGraphic);\n    }\n}\n/** Placement tool base class for creating new elements.\n * @beta\n */\nexport class CreateElementTool extends PrimitiveTool {\n    get targetCategory() {\n        const category = this.briefcase?.editorToolSettings.category;\n        if (undefined === category)\n            throw new IModelError(IModelStatus.InvalidCategory, \"\");\n        return category;\n    }\n    get targetModelId() {\n        const model = this.briefcase?.editorToolSettings.model;\n        if (undefined === model)\n            throw new IModelError(IModelStatus.BadModel, \"\");\n        return model;\n    }\n    isCompatibleViewport(vp, isSelectedViewChange) {\n        if (!vp?.iModel.isBriefcaseConnection())\n            return false;\n        return undefined !== vp.iModel.editorToolSettings.model && super.isCompatibleViewport(vp, isSelectedViewChange);\n    }\n    /** Whether [[setupAndPromptForNextAction]] should call [[AccuSnap.enableSnap]] for current tool phase.\n     * @return true to enable snapping to elements.\n     */\n    get wantAccuSnap() { return false; }\n    /** Whether to automatically start element dynamics on button event.\n     * @return true if tool will implement [[InteractiveTool.onDynamicFrame]] to show element dynamics.\n     */\n    get wantDynamics() { return false; }\n    /** Whether tool is ready to insert the new element.\n     * @return true to call [[createElement]].\n     */\n    isComplete(_ev) { return false; }\n    /** Orchestrates advancing the internal state of the tool on a data button event.\n     * - Gather input: Initiates element dynamics and accepts additional points as required.\n     * - Complete operation: Create new element, restart or exit tool.\n     * @returns EventHandled.Yes if onReinitialize was called to restart or exit tool.\n     */\n    async processDataButton(ev) {\n        if (this.isComplete(ev)) {\n            await this.createElement();\n            await this.onReinitialize();\n            return EventHandled.Yes;\n        }\n        this.setupAndPromptForNextAction();\n        if (!this.isDynamicsStarted && this.wantDynamics)\n            this.beginDynamics();\n        return EventHandled.No;\n    }\n    async onDataButtonDown(ev) {\n        return this.processDataButton(ev);\n    }\n    async onResetButtonUp(_ev) {\n        await this.onReinitialize();\n        return EventHandled.No;\n    }\n    /** Setup initial tool state, prompts, etc. */\n    async onPostInstall() {\n        await super.onPostInstall();\n        this.setupAndPromptForNextAction();\n    }\n    /** Restore tool assistance after no longer being suspended by either a [[ViewTool]] or [[InputCollector]]. */\n    async onUnsuspend() {\n        this.provideToolAssistance();\n    }\n    /** Setup auto-locate, AccuSnap, AccuDraw, and supply tool assistance. */\n    setupAndPromptForNextAction() {\n        IModelApp.accuSnap.enableSnap(this.wantAccuSnap);\n        this.provideToolAssistance();\n    }\n    /** Sub-classes should override to provide tool specific instructions. */\n    provideToolAssistance(mainInstrText, additionalInstr) {\n        const mainMsg = \"ElementSet.Prompts.IdentifyPoint\";\n        const leftMsg = \"ElementSet.Inputs.AcceptPoint\";\n        const rightMsg = \"ElementSet.Inputs.Cancel\";\n        const mouseInstructions = [];\n        const touchInstructions = [];\n        if (!ToolAssistance.createTouchCursorInstructions(touchInstructions))\n            touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.OneTouchTap, CoreTools.translate(leftMsg), false, ToolAssistanceInputMethod.Touch));\n        mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.LeftClick, CoreTools.translate(leftMsg), false, ToolAssistanceInputMethod.Mouse));\n        touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.TwoTouchTap, CoreTools.translate(rightMsg), false, ToolAssistanceInputMethod.Touch));\n        mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.RightClick, CoreTools.translate(rightMsg), false, ToolAssistanceInputMethod.Mouse));\n        if (undefined !== additionalInstr) {\n            for (const instr of additionalInstr) {\n                if (ToolAssistanceInputMethod.Touch === instr.inputMethod)\n                    touchInstructions.push(instr);\n                else\n                    mouseInstructions.push(instr);\n            }\n        }\n        const sections = [];\n        sections.push(ToolAssistance.createSection(mouseInstructions, ToolAssistance.inputsLabel));\n        sections.push(ToolAssistance.createSection(touchInstructions, ToolAssistance.inputsLabel));\n        const mainInstruction = ToolAssistance.createInstruction(this.iconSpec, undefined !== mainInstrText ? mainInstrText : CoreTools.translate(mainMsg));\n        const instructions = ToolAssistance.createInstructions(mainInstruction, sections);\n        IModelApp.notifications.setToolAssistance(instructions);\n    }\n}\n/** Placement tool base class for creating new elements that use dynamics to show intermediate results.\n * @beta\n */\nexport class CreateElementWithDynamicsTool extends CreateElementTool {\n    get wantAccuSnap() { return true; }\n    get wantDynamics() { return true; }\n    clearGraphics() {\n        if (undefined === this._graphicsProvider)\n            return;\n        this._graphicsProvider.cleanupGraphic();\n        this._graphicsProvider = undefined;\n    }\n    async createGraphics(ev) {\n        if (!await this.updateDynamicData(ev))\n            return;\n        const placement = this.getPlacementProps();\n        if (undefined === placement)\n            return;\n        const geometry = this.getGeometryProps(placement);\n        if (undefined === geometry)\n            return;\n        if (undefined === this._graphicsProvider)\n            this._graphicsProvider = new DynamicGraphicsProvider(this.iModel, this.toolId);\n        // Set chord tolerance for curved surfaces...\n        if (ev.viewport)\n            this._graphicsProvider.chordTolerance = computeChordToleranceFromPoint(ev.viewport, ev.point);\n        await this._graphicsProvider.createGraphic(this.targetCategory, placement, geometry);\n    }\n    onDynamicFrame(_ev, context) {\n        if (undefined !== this._graphicsProvider)\n            this._graphicsProvider.addGraphic(context);\n    }\n    async onMouseMotion(ev) {\n        return this.createGraphics(ev);\n    }\n    async doCreateElement(_props, _data) { }\n    async updateElementData(_ev, _isDynamics) { }\n    async updateDynamicData(ev) {\n        if (!IModelApp.viewManager.inDynamicsMode)\n            return false; // Don't need to create graphic if dynamics aren't yet active...\n        await this.updateElementData(ev, true);\n        return true;\n    }\n    async createElement() {\n        const placement = this.getPlacementProps();\n        if (undefined === placement)\n            return;\n        const geometry = this.getGeometryProps(placement);\n        if (undefined === geometry)\n            return;\n        const elemProps = this.getElementProps(placement);\n        if (undefined === elemProps)\n            return;\n        let data;\n        if (\"flatbuffer\" === geometry.format) {\n            data = { entryArray: geometry.data };\n            delete elemProps.geom; // Leave unchanged until replaced by flatbuffer geometry...\n        }\n        else {\n            elemProps.geom = geometry.data;\n        }\n        return this.doCreateElement(elemProps, data);\n    }\n    setupAccuDraw() { }\n    setupAndPromptForNextAction() {\n        this.setupAccuDraw();\n        super.setupAndPromptForNextAction();\n    }\n    async acceptPoint(ev) {\n        await this.updateElementData(ev, false);\n        return true;\n    }\n    async onDataButtonDown(ev) {\n        if (!await this.acceptPoint(ev))\n            return EventHandled.Yes;\n        return super.onDataButtonDown(ev);\n    }\n    async cancelPoint(_ev) { return true; }\n    async onResetButtonUp(ev) {\n        if (!await this.cancelPoint(ev))\n            return EventHandled.Yes;\n        return super.onResetButtonUp(ev);\n    }\n    async onCleanup() {\n        this.clearGraphics();\n        return super.onCleanup();\n    }\n}\n//# sourceMappingURL=CreateElementTool.js.map",
      "start": 1693508122880,
      "end": 1693508122988,
      "sourcemaps": null
    }
  ]
}
