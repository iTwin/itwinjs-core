{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/clipping/UnionOfConvexClipPlaneSets.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module CartesianGeometry\n */\nimport { Geometry } from \"../Geometry\";\nimport { GrowableFloat64Array } from \"../geometry3d/GrowableFloat64Array\";\nimport { GrowableXYZArray } from \"../geometry3d/GrowableXYZArray\";\nimport { Range1d } from \"../geometry3d/Range\";\nimport { Segment1d } from \"../geometry3d/Segment1d\";\nimport { ClipPlaneContainment, ClipUtilities } from \"./ClipUtils\";\nimport { ConvexClipPlaneSet } from \"./ConvexClipPlaneSet\";\n/**\n * A collection of ConvexClipPlaneSets.\n * * A point is \"in\" the clip plane set if it is \"in\" one or more of  the ConvexClipPlaneSet\n * * Hence the boolean logic is that the ClipPlaneSet is a UNION of its constituents.\n * @public\n */\nclass UnionOfConvexClipPlaneSets {\n    /** (property accessor)  Return the (reference to the) array of `ConvexClipPlaneSet` */\n    get convexSets() {\n        return this._convexSets;\n    }\n    constructor() {\n        this._convexSets = [];\n    }\n    /** Return an array with the `toJSON` form of each `ConvexClipPlaneSet` */\n    toJSON() {\n        const val = [];\n        for (const convex of this._convexSets)\n            val.push(convex.toJSON());\n        return val;\n    }\n    /** Convert json `UnionOfConvexClipPlaneSets`, using `setFromJSON`. */\n    static fromJSON(json, result) {\n        result = result ? result : new UnionOfConvexClipPlaneSets();\n        result._convexSets.length = 0;\n        if (!Array.isArray(json))\n            return result;\n        for (const thisJson of json)\n            result._convexSets.push(ConvexClipPlaneSet.fromJSON(thisJson));\n        return result;\n    }\n    /** Create a `UnionOfConvexClipPlaneSets` with no members. */\n    static createEmpty(result) {\n        if (result) {\n            result._convexSets.length = 0;\n            return result;\n        }\n        return new UnionOfConvexClipPlaneSets();\n    }\n    /**\n     * Return true if all member convex sets are almostEqual to corresponding members of other. This includes\n     * identical order in array.\n     * @param other clip plane to compare.\n     */\n    isAlmostEqual(other) {\n        if (this._convexSets.length !== other._convexSets.length)\n            return false;\n        for (let i = 0; i < this._convexSets.length; i++)\n            if (!this._convexSets[i].isAlmostEqual(other._convexSets[i]))\n                return false;\n        return true;\n    }\n    /** Create a `UnionOfConvexClipPlaneSets` with given `ConvexClipPlaneSet` members. */\n    static createConvexSets(convexSets, result) {\n        result = result ? result : new UnionOfConvexClipPlaneSets();\n        for (const set of convexSets)\n            result._convexSets.push(set);\n        return result;\n    }\n    /** Return a deep copy. */\n    clone(result) {\n        result = result ? result : new UnionOfConvexClipPlaneSets();\n        result._convexSets.length = 0;\n        for (const convexSet of this._convexSets)\n            result._convexSets.push(convexSet.clone());\n        return result;\n    }\n    /**\n     * Append `toAdd` to the array of `ConvexClipPlaneSet`.\n     * * undefined toAdd is ignored.\n     */\n    addConvexSet(toAdd) {\n        if (toAdd)\n            this._convexSets.push(toAdd);\n    }\n    /**\n     * Test if there is any intersection with a ray defined by origin and direction.\n     * * Optionally record the range (null or otherwise) in caller-allocated result.\n     * * If the ray is unbounded inside the clip, result can contain positive or negative\n     * \"Geometry.largeCoordinateResult\" values.\n     * * If no result is provide, there are no object allocations.\n     * @param maximalRange optional Range1d to receive parameters along the ray.\n     */\n    hasIntersectionWithRay(ray, maximalRange) {\n        if (maximalRange === undefined) {\n            // if complete result is not requested, return after any hit.\n            for (const planeSet of this._convexSets) {\n                if (planeSet.hasIntersectionWithRay(ray))\n                    return true;\n            }\n            return false;\n        }\n        maximalRange.setNull();\n        const rangeA = Range1d.createNull();\n        for (const planeSet of this._convexSets) {\n            if (planeSet.hasIntersectionWithRay(ray, rangeA))\n                maximalRange.extendRange(rangeA);\n        }\n        return !maximalRange.isNull;\n    }\n    /**\n     * Return true if true is returned for any contained convex set returns true for\n     * `convexSet.isPointInside (point, tolerance)`.\n     */\n    isPointInside(point) {\n        for (const convexSet of this._convexSets) {\n            if (convexSet.isPointInside(point)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Return true if true is returned for any contained convex set returns true for\n     * `convexSet.isPointOnOrInside (point, tolerance)`.\n     */\n    isPointOnOrInside(point, tolerance = Geometry.smallMetricDistance) {\n        for (const convexSet of this._convexSets) {\n            if (convexSet.isPointOnOrInside(point, tolerance))\n                return true;\n        }\n        return false;\n    }\n    /**\n     * Return true if true is returned for any contained convex set returns true for\n     * `convexSet.isSphereOnOrInside (point, tolerance)`.\n     */\n    isSphereInside(point, radius) {\n        for (const convexSet of this._convexSets) {\n            if (convexSet.isSphereInside(point, radius))\n                return true;\n        }\n        return false;\n    }\n    /** Test if any part of a line segment is within the volume. */\n    isAnyPointInOrOnFromSegment(segment) {\n        for (const convexSet of this._convexSets) {\n            if (convexSet.announceClippedSegmentIntervals(0.0, 1.0, segment.point0Ref, segment.point1Ref))\n                return true;\n        }\n        return false;\n    }\n    // Intervals must be Segment1d array, as there may be multiple intervals along segment that pass through set regions,\n    // and so splitting the intervals into segments aids in better organization\n    /** Returns the fractions of the segment that pass through the set region, as 1 dimensional pieces. */\n    appendIntervalsFromSegment(segment, intervals) {\n        for (const convexSet of this._convexSets) {\n            convexSet.announceClippedSegmentIntervals(0.0, 1.0, segment.point0Ref, segment.point1Ref, (fraction0, fraction1) => intervals.push(Segment1d.create(fraction0, fraction1)));\n        }\n    }\n    /** Apply `transform` to all the ConvexClipPlaneSet's. */\n    transformInPlace(transform) {\n        for (const convexSet of this._convexSets) {\n            convexSet.transformInPlace(transform);\n        }\n    }\n    /** Returns 1, 2, or 3 based on whether point is strongly inside, ambiguous, or strongly outside respectively. */\n    classifyPointContainment(points, onIsOutside) {\n        for (const convexSet of this._convexSets) {\n            const thisStatus = convexSet.classifyPointContainment(points, onIsOutside);\n            if (thisStatus !== ClipPlaneContainment.StronglyOutside)\n                return thisStatus;\n        }\n        return ClipPlaneContainment.StronglyOutside;\n    }\n    /**\n     * Clip a polygon using this ClipPlaneSet, returning new polygon boundaries. Note that each polygon may lie\n     * next to the previous, or be disconnected.\n     */\n    polygonClip(input, output) {\n        output.length = 0;\n        if (Array.isArray(input))\n            input = GrowableXYZArray.create(input);\n        const work = new GrowableXYZArray();\n        for (const convexSet of this._convexSets) {\n            const convexSetOutput = new GrowableXYZArray();\n            convexSet.polygonClip(input, convexSetOutput, work);\n            if (convexSetOutput.length !== 0)\n                output.push(convexSetOutput);\n        }\n    }\n    /**\n     * Announce clipSegment() for each convexSet in this ClipPlaneSet.\n     * * all clipPlaneSets are inspected.\n     * * announced intervals are for each individual clipPlaneSet -- adjacent intervals are not consolidated.\n     * @param f0 active interval start.\n     * @param f1 active interval end.\n     * @param pointA line segment start.\n     * @param pointB line segment end.\n     * @param announce function to announce interval.\n     * @returns Return true if any announcements are made.\n     */\n    announceClippedSegmentIntervals(f0, f1, pointA, pointB, announce) {\n        let numAnnounce = 0;\n        for (const convexSet of this._convexSets) {\n            if (convexSet.announceClippedSegmentIntervals(f0, f1, pointA, pointB, announce))\n                numAnnounce++;\n        }\n        return numAnnounce > 0;\n    }\n    /**\n     * Find parts of an arc that are inside any member clipper.\n     * Announce each with `announce(startFraction, endFraction, this)`\n     */\n    announceClippedArcIntervals(arc, announce) {\n        const breaks = UnionOfConvexClipPlaneSets._clipArcFractionArray;\n        breaks.clear();\n        for (const convexSet of this._convexSets) {\n            for (const clipPlane of convexSet.planes) {\n                clipPlane.appendIntersectionRadians(arc, breaks);\n            }\n        }\n        arc.sweep.radiansArrayToPositivePeriodicFractions(breaks);\n        return ClipUtilities.selectIntervals01(arc, breaks, this, announce);\n    }\n    /**\n     * Collect the output from computePlanePlanePlaneIntersections in all the contained convex sets.\n     * @param transform (optional) transform to apply to the points.\n     * @param points (optional) array to which computed points are to be added.\n     * @param range (optional) range to be extended by the computed points.\n     * @param transform (optional) transform to apply to the accepted points.\n     * @param testContainment if true, test each point to see if it is within the convex set (send false if confident\n     * that the convex set is rectilinear set such as a slab. Send true if chiseled corners are possible).\n     * @returns number of points.\n     */\n    computePlanePlanePlaneIntersectionsInAllConvexSets(points, rangeToExtend, transform, testContainment = true) {\n        let n = 0;\n        for (const convexSet of this._convexSets) {\n            n += convexSet.computePlanePlanePlaneIntersections(points, rangeToExtend, transform, testContainment);\n        }\n        return n;\n    }\n    /**\n     * Multiply all ClipPlanes DPoint4d by matrix.\n     * @param matrix matrix to apply.\n     * @param invert if true, use in verse of the matrix.\n     * @param transpose if true, use the transpose of the matrix (or inverse, per invert parameter).\n     * * Note that if matrixA is applied to all of space, the matrix to send to this method to get a corresponding effect\n     * on the plane is the inverse transpose of matrixA.\n     * * Callers that will apply the same matrix to many planes should pre-invert the matrix for efficiency.\n     * * Both params default to true to get the full effect of transforming space.\n     * @param matrix matrix to apply\n     */\n    multiplyPlanesByMatrix4d(matrix, invert = true, transpose = true) {\n        if (invert) { // form inverse once here, reuse for all planes\n            const inverse = matrix.createInverse();\n            if (!inverse)\n                return false;\n            return this.multiplyPlanesByMatrix4d(inverse, false, transpose);\n        }\n        // (no inversion -- no failures possible)\n        for (const convexSet of this._convexSets) {\n            convexSet.multiplyPlanesByMatrix4d(matrix, false, transpose);\n        }\n        return true;\n    }\n    /** Recursively call `setInvisible` on all member convex sets. */\n    setInvisible(invisible) {\n        for (const convexSet of this._convexSets) {\n            convexSet.setInvisible(invisible);\n        }\n    }\n    /** add convex sets that accept points below `zLow` and above `zHigh` */\n    addOutsideZClipSets(invisible, zLow, zHigh) {\n        if (zLow) {\n            const convexSet = ConvexClipPlaneSet.createEmpty();\n            convexSet.addZClipPlanes(invisible, zLow);\n            this._convexSets.push(convexSet);\n        }\n        if (zHigh) {\n            const convexSet = ConvexClipPlaneSet.createEmpty();\n            convexSet.addZClipPlanes(invisible, undefined, zHigh);\n            this._convexSets.push(convexSet);\n        }\n    }\n    /** Move convex sets from source.*/\n    takeConvexSets(source) {\n        let convexSet;\n        while ((undefined !== (convexSet = source._convexSets.pop()))) {\n            this._convexSets.push(convexSet);\n        }\n    }\n    /**\n     * Implement appendPolygonClip, as defined in interface PolygonClipper.\n     * @param xyz convex polygon. This is not changed.\n     * @param insideFragments Array to receive \"inside\" fragments. Each fragment is a GrowableXYZArray grabbed from\n     * the cache. This is NOT cleared.\n     * @param outsideFragments Array to receive \"outside\" fragments. Each fragment is a GrowableXYZArray grabbed from\n     * the cache. This is NOT cleared.\n     * @param arrayCache cache for reusable GrowableXYZArray.\n     */\n    appendPolygonClip(xyz, insideFragments, outsideFragments, arrayCache) {\n        const oldOutsideCount = outsideFragments.length;\n        const oldInsideCount = insideFragments.length;\n        let carryForwardA = [arrayCache.grabAndFill(xyz)];\n        let carryForwardB = [];\n        let tempAB;\n        let shard;\n        // At each convex set, carryForwardA is all the fragments that have been outside all previous convex sets.\n        // Clip each such fragment to the current set, sending the outside parts to carryForwardB, which will got to the next clipper\n        // The final surviving carryForward really is out.\n        for (const c of this._convexSets) {\n            while (undefined !== (shard = carryForwardA.pop())) {\n                c.appendPolygonClip(shard, insideFragments, carryForwardB, arrayCache);\n                arrayCache.dropToCache(shard);\n            }\n            tempAB = carryForwardB;\n            carryForwardB = carryForwardA; // and that is empty\n            carryForwardA = tempAB;\n        }\n        while (undefined !== (shard = carryForwardA.pop())) {\n            outsideFragments.push(shard);\n        }\n        if (outsideFragments.length === oldOutsideCount)\n            ClipUtilities.restoreSingletonInPlaceOfMultipleShards(insideFragments, oldInsideCount, xyz, arrayCache);\n        else if (insideFragments.length === oldInsideCount)\n            ClipUtilities.restoreSingletonInPlaceOfMultipleShards(outsideFragments, oldOutsideCount, xyz, arrayCache);\n    }\n}\nUnionOfConvexClipPlaneSets._clipArcFractionArray = new GrowableFloat64Array();\nexport { UnionOfConvexClipPlaneSets };\n/* FUNCTIONS SKIPPED DUE TO BSPLINES, VU, OR NON-USAGE IN NATIVE CODE----------------------------------------------------------------\n\nInvolves vu: skipping for now...\n  public fromSweptPolygon(points: Point3d[], directions: Vector3d[]): ClipPlaneSet;\n  public parseConcavePolygonPlanes(...)\n\nUses bsplines... skipping for now:\n  public appendIntervalsClipPlaneSetFromCurve();\n\nUses bsplines... skipping for now:\n  public isAnyPointInOrOnFrom();\n\nSkipped fromSweptPolygon(...), which is overloaded function from first, due to presence of vu\n  public fromSweptPolygon(points: Point3d[], directions: Vector3d[], shapes: Point3d[])\n*/\n//# sourceMappingURL=UnionOfConvexClipPlaneSets.js.map",
      "start": 1693508123345,
      "end": 1693508123501,
      "sourcemaps": null
    }
  ]
}
