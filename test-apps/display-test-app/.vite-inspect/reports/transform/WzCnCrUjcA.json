{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/geometry3d/PolylineOps.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module CartesianGeometry\n */\nimport { Geometry } from \"../Geometry\";\nimport { GrowableXYZArray } from \"./GrowableXYZArray\";\nimport { Plane3dByOriginAndUnitNormal } from \"./Plane3dByOriginAndUnitNormal\";\nimport { Point3d, Vector3d } from \"./Point3dVector3d\";\nimport { PolylineCompressionContext } from \"./PolylineCompressionByEdgeOffset\";\nimport { Range1d } from \"./Range\";\n// cspell:word Puecker\n/**\n * PolylineOps is a collection of static methods operating on polylines.\n * @public\n */\nexport class PolylineOps {\n    /**\n     * Return a Range1d with the shortest and longest edge lengths of the polyline.\n     * @param points points to examine.\n     */\n    static edgeLengthRange(points) {\n        const range = Range1d.createNull();\n        for (let i = 1; i < points.length; i++) {\n            range.extendX(points[i - 1].distance(points[i]));\n        }\n        return range;\n    }\n    /**\n     * Return a simplified subset of given points.\n     * * Points are removed by the Douglas-Puecker algorithm, viz https://en.wikipedia.org/wiki/Ramer–Douglas–Peucker_algorithm\n     * * This is a global search, with multiple passes over the data.\n     * @param source\n     * @param chordTolerance\n     */\n    static compressByChordError(source, chordTolerance) {\n        return PolylineCompressionContext.compressPoint3dArrayByChordError(source, chordTolerance);\n    }\n    /**\n     * Return a simplified subset of given points, omitting points if very close to their neighbors.\n     * * This is a local search, with a single pass over the data.\n     * @param source input points\n     * @param maxEdgeLength\n     */\n    static compressShortEdges(source, maxEdgeLength) {\n        const dest = GrowableXYZArray.create(source);\n        PolylineCompressionContext.compressInPlaceByShortEdgeLength(dest, maxEdgeLength);\n        return dest.getPoint3dArray();\n    }\n    /**\n     * Return a simplified subset of given points, omitting points of the triangle with adjacent points is small.\n     * * This is a local search, with a single pass over the data.\n     * @param source input points\n     * @param maxEdgeLength\n     */\n    static compressSmallTriangles(source, maxTriangleArea) {\n        const dest = GrowableXYZArray.create(source);\n        PolylineCompressionContext.compressInPlaceBySmallTriangleArea(dest, maxTriangleArea);\n        return dest.getPoint3dArray();\n    }\n    /**\n     * Return a simplified subset of given points, omitting points if close to the edge between neighboring points before and after\n     * * This is a local search, with a single pass over the data for each pass.\n     * @param source input points\n     * @param maxDistance omit points if this close to edge between points before and after\n     * @param numPass max number of times to run the filter.  numPass=2 is observed to behave well.\n     *\n     */\n    static compressByPerpendicularDistance(source, maxDistance, numPass = 2) {\n        const dest = GrowableXYZArray.create(source);\n        let num0 = dest.length;\n        for (let pass = 0; pass < numPass; pass++) {\n            PolylineCompressionContext.compressInPlaceByPerpendicularDistance(dest, maxDistance);\n            const num1 = dest.length;\n            if (num1 === num0)\n                break;\n            num0 = num1;\n        }\n        return dest.getPoint3dArray();\n    }\n    static squaredDistanceToInterpolatedPoint(pointQ, point0, fraction, point1) {\n        const g = 1.0 - fraction;\n        const dx = pointQ.x - (g * point0.x + fraction * point1.x);\n        const dy = pointQ.y - (g * point0.y + fraction * point1.y);\n        const dz = pointQ.z - (g * point0.z + fraction * point1.z);\n        return dx * dx + dy * dy + dz * dz;\n    }\n    /**\n     * test if either\n     *   * points[indexA] matches pointQ\n     *   * line from points[indexA] to points[indexB] overlaps points[indexA] to pointQ\n     * @param points\n     * @param pointQ\n     * @param tolerance\n     */\n    static isDanglerConfiguration(points, indexA, indexB, pointQ, squaredDistanceTolerance) {\n        if (indexA < 0 || indexA >= points.length)\n            return false;\n        const pointA = points[indexA];\n        // simple point match ...\n        const d2Q = pointA.distanceSquared(pointQ);\n        if (d2Q <= squaredDistanceTolerance)\n            return true;\n        if (indexB < 0 || indexB >= points.length)\n            return false;\n        const pointB = points[indexB];\n        // The expensive test .. does newPoint double back to an interior or extrapolation of the final dest segment?\n        //\n        // or pointQ\n        const dot = pointA.dotVectorsToTargets(pointB, pointQ);\n        // simple case -- pointB..pointA..pointQ continues forward\n        if (dot <= 0.0)\n            return false;\n        const d2B = pointA.distanceSquared(pointB);\n        let distanceSquared;\n        if (d2Q >= d2B) {\n            //                        pointB----------------------------------->>>>>>> pointA\n            //          pointQ<<<<---------------------------------------------------------\n            const fraction = dot / d2Q; // safe to divide because of earlier d2Q test.\n            distanceSquared = this.squaredDistanceToInterpolatedPoint(pointB, pointA, fraction, pointQ);\n        }\n        else {\n            //           pointB----------------------------------->>>>>>> pointA\n            //                         pointQ<<<<----------------------\n            const fraction = dot / d2B;\n            distanceSquared = this.squaredDistanceToInterpolatedPoint(pointQ, pointA, fraction, pointB);\n        }\n        return distanceSquared < squaredDistanceTolerance;\n    }\n    /**\n       * Return a simplified subset of given points, omitting points on \"danglers\" that depart and return on a single path.\n       * @param source input points\n       * @param closed if true, an edge returning to point 0 is implied even if final point does not match.\n       * @param tolerance tolerance for near-zero distance.\n       */\n    static compressDanglers(source, closed = false, tolerance = Geometry.smallMetricDistance) {\n        let n = source.length;\n        const squaredDistanceTolerance = tolerance * tolerance;\n        if (closed)\n            while (n > 1 && source[n - 1].distanceSquared(source[0]) <= squaredDistanceTolerance)\n                n--;\n        const dest = [];\n        dest.push(source[0].clone());\n        for (let i = 1; i < n; i++) {\n            const newPoint = source[i];\n            while (this.isDanglerConfiguration(dest, dest.length - 1, dest.length - 2, newPoint, squaredDistanceTolerance))\n                dest.pop();\n            dest.push(newPoint.clone());\n        }\n        if (closed) {\n            // No purge moving backwards.   Last point\n            let leftIndex = 0;\n            let rightIndex = dest.length - 1;\n            while (rightIndex > leftIndex + 2) {\n                if (this.isDanglerConfiguration(dest, leftIndex, leftIndex + 1, dest[rightIndex], squaredDistanceTolerance)) {\n                    leftIndex++;\n                }\n                else if (this.isDanglerConfiguration(dest, rightIndex, rightIndex - 1, dest[leftIndex], squaredDistanceTolerance)) {\n                    rightIndex--;\n                }\n                else {\n                    break;\n                }\n            }\n            if (rightIndex + 1 < dest.length)\n                dest.length = rightIndex + 1;\n            if (leftIndex > 0) {\n                dest.splice(0, leftIndex);\n            }\n        }\n        return dest;\n    }\n    /**\n     * Add closure points to a polyline or array of polylines\n     * @param data points.\n     */\n    static addClosurePoint(data) {\n        if (data.length === 0)\n            return;\n        const q0 = data[0];\n        if (Array.isArray(q0)) {\n            for (const child of data) {\n                if (Array.isArray(child))\n                    this.addClosurePoint(child);\n            }\n            return;\n        }\n        const q1 = data[data.length - 1];\n        if (q0 instanceof Point3d && q1 instanceof Point3d && !q0.isAlmostEqual(q1)) {\n            data.push(q0.clone());\n        }\n    }\n    /**\n     * Remove closure points a polyline or array of polylines\n     * @param data points.\n     */\n    static removeClosurePoint(data) {\n        if (data.length === 0)\n            return;\n        const q0 = data[0];\n        if (Array.isArray(q0)) {\n            for (const child of data) {\n                if (Array.isArray(child))\n                    this.removeClosurePoint(child);\n            }\n            return;\n        }\n        const q1 = data[data.length - 1];\n        if (q0 instanceof Point3d && q1 instanceof Point3d && q0.isAlmostEqual(q1)) {\n            data.pop();\n        }\n    }\n    /** Create an array of planes.\n     * * First plane has origin at first centerline point, with unit normal directed at the next point.\n     * * Intermediate planes have origin at intermediate points, with unit normals computed from the average of unit vectors along the incoming and outgoing segments.\n     * * Last plane has origin at last centerline point, with unit normal directed from previous point.\n     * * All sets of adjacent coincident points are reduced to a single point.\n     *    * Hence the output array may have fewer points than the centerline.\n     * * If there are one or fewer distinct input points, the return is undefined\n     * @param centerline points to reside in output planes\n     * @param wrapIfPhysicallyClosed if true and the first and last centerline points are the same, then the first and last output planes are averaged and equated (cloned).\n     */\n    static createBisectorPlanesForDistinctPoints(centerline, wrapIfPhysicallyClosed = false) {\n        const packedPoints = PolylineOps.compressShortEdges(centerline, 2.0 * Geometry.smallMetricDistance); // double the tolerance to ensure normalized vectors exist.\n        if (packedPoints.length < 2)\n            return undefined;\n        const bisectorPlanes = [];\n        const point0 = packedPoints[0];\n        const point1 = packedPoints[1];\n        const unit01 = Vector3d.createNormalizedStartEnd(point0, point1);\n        const perpendicular0 = Plane3dByOriginAndUnitNormal.create(point0, unit01);\n        const perpendicular1 = Plane3dByOriginAndUnitNormal.createXYPlane();\n        // FIRST point gets simple perpendicular\n        bisectorPlanes.push(perpendicular0.clone());\n        // Each intermediate point gets average of adjacent perpendiculars\n        for (let i = 1; i + 1 < packedPoints.length; i++) {\n            Vector3d.createNormalizedStartEnd(packedPoints[i], packedPoints[i + 1], unit01);\n            // remark: the prior pack should ensure the normalization is ok.  But if it fails, we ignore this point...\n            if (undefined !== Plane3dByOriginAndUnitNormal.create(packedPoints[i], unit01, perpendicular1)) {\n                const newBisectorNormal = perpendicular0.getNormalRef().interpolate(0.5, perpendicular1.getNormalRef());\n                const newBisectorPlane = Plane3dByOriginAndUnitNormal.create(packedPoints[i], newBisectorNormal);\n                if (undefined !== newBisectorPlane)\n                    bisectorPlanes.push(newBisectorPlane);\n                perpendicular0.setFrom(perpendicular1);\n            }\n        }\n        // LAST point gets simple perpendicular inherited from last pass\n        bisectorPlanes.push(Plane3dByOriginAndUnitNormal.create(packedPoints[packedPoints.length - 1], perpendicular0.getNormalRef()));\n        // reset end planes to their average plane, but leave them alone if the closure point is a cusp\n        const lastIndex = bisectorPlanes.length - 1;\n        if (lastIndex > 0 && wrapIfPhysicallyClosed) {\n            const firstPlane = bisectorPlanes[0];\n            const lastPlane = bisectorPlanes[lastIndex];\n            if (Geometry.isSamePoint3d(firstPlane.getOriginRef(), lastPlane.getOriginRef())) {\n                const newBisectorNormal = firstPlane.getNormalRef().plus(lastPlane.getNormalRef()); // could be zero vector at a cusp\n                const newBisectorPlane = Plane3dByOriginAndUnitNormal.create(firstPlane.getOriginRef(), newBisectorNormal);\n                if (undefined !== newBisectorPlane) {\n                    bisectorPlanes[0] = newBisectorPlane;\n                    bisectorPlanes[lastIndex] = Plane3dByOriginAndUnitNormal.create(lastPlane.getOriginRef(), newBisectorNormal);\n                }\n            }\n        }\n        return bisectorPlanes.length > 1 ? bisectorPlanes : undefined;\n    }\n}\n//# sourceMappingURL=PolylineOps.js.map",
      "start": 1693508123237,
      "end": 1693508123388,
      "sourcemaps": null
    }
  ]
}
