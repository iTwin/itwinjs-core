{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/bspline/KnotVector.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Bspline\n */\nimport { Geometry } from \"../Geometry\";\nimport { NumberArray } from \"../geometry3d/PointHelpers\";\n/**\n * Enumeration of the possible ways of converting a \"periodic\" knot vector to an open knot vector.\n * None (0) ==> no wrap possible\n * OpenByAddingControlPoints (1)  ==> wrapped by adding poles\n * OpenByRemovingKnots (2)  ==> wrapped by deleting extreme knots.\n * @public\n */\nexport var BSplineWrapMode;\n(function (BSplineWrapMode) {\n    /** No conversion to periodic */\n    BSplineWrapMode[BSplineWrapMode[\"None\"] = 0] = \"None\";\n    /** Convert to periodic by removing control points.  This is typical for closed bcurve constructed by control points with maximum continuity.\n     * * Knots stay the same in open and periodic form.\n     * * Periodic form omits {degree} control points.\n     */\n    BSplineWrapMode[BSplineWrapMode[\"OpenByAddingControlPoints\"] = 1] = \"OpenByAddingControlPoints\";\n    /** Convert to periodic by adding special knots.  This is typical of closed bcurve constructed as exact circular or elliptic arc\n     * * 2 knots on each end are omitted in open form\n     * * poles stay the same.\n     */\n    BSplineWrapMode[BSplineWrapMode[\"OpenByRemovingKnots\"] = 2] = \"OpenByRemovingKnots\";\n})(BSplineWrapMode || (BSplineWrapMode = {}));\n/**\n * Array of non-decreasing numbers acting as a knot array for bsplines.\n *\n * * Essential identity: numKnots = numPoles + order - 2 = numPoles + degree - 1\n * * Various bspline libraries have confusion over how many \"end knots\" are needed. \"Many\" libraries (including MicroStation)\n *     incorrectly demand \"order\" knots at each end for clamping.   But only \"order - 1\" are really needed.\n * * This class uses the \"order-1\" convention.\n * * This class provides queries to convert among spanIndex and knotIndex\n * * A span is a single interval of the knots.\n * * The left knot of span {k} is knot {k+degree-1}\n * * This class provides queries to convert among spanFraction, fraction of knot range, and knot\n * * core computations (evaluateBasisFunctions) have leftKnotIndex and global knot value as inputs.  Callers need to\n * know their primary values (global knot, spanFraction).\n * @public\n */\nclass KnotVector {\n    /** Return the leftmost knot value (of the active interval, ignoring unclamped leading knots)*/\n    get leftKnot() { return this._knot0; }\n    /** Return the rightmost knot value (of the active interval, ignoring unclamped leading knots)*/\n    get rightKnot() { return this._knot1; }\n    /** Return the index of the leftmost knot of the active interval */\n    get leftKnotIndex() { return this.degree - 1; }\n    /** Return the index of the rightmost knot of the active interval */\n    get rightKnotIndex() { return this.knots.length - this.degree; }\n    /** Whether the bspline was created by adding poles into \"closed\" structure. This is used by serialize/deserialize to mark knotVector's that were converted from periodic style. */\n    get wrappable() { return this._wrapMode === undefined ? BSplineWrapMode.None : this._wrapMode; }\n    set wrappable(value) { this._wrapMode = value; }\n    /** Return the number of bezier spans.  Note that this includes zero-length spans if there are repeated knots. */\n    get numSpans() { return this.rightKnotIndex - this.leftKnotIndex; }\n    /**\n     *\n     * * If knots is a number array or Float64Array, the those values become the local knot array.\n     * * If knots is a simple number, the local knot array is allocated to that size but left as zeros.\n     * @param knots\n     * @param degree\n     */\n    constructor(knots, degree, wrapMode) {\n        this.degree = degree;\n        this._wrapMode = wrapMode;\n        // default values to satisfy compiler -- real values hapn setupFixedValues or final else defers to user\n        this._knot0 = 0.0;\n        this._knot1 = 1.0;\n        // satisfy the initialize checker ..\n        if (Array.isArray(knots)) { // remark:  This ctor is private.  The callers (as of April 2019) do not use this path.\n            this.knots = new Float64Array(knots.length);\n            this.setKnots(knots);\n            this.setupFixedValues();\n        }\n        else if (knots instanceof Float64Array) {\n            this.knots = knots.slice();\n            this.setupFixedValues();\n        }\n        else { // caller is responsible for filling array separately ...\n            this.knots = new Float64Array(knots);\n        }\n    }\n    /** copy degree and knots to a new KnotVector. */\n    clone() { return new KnotVector(this.knots, this.degree, this.wrappable); }\n    setupFixedValues() {\n        // These should be read-only . ..\n        this._knot0 = this.knots[this.degree - 1];\n        this._knot1 = this.knots[this.knots.length - this.degree];\n    }\n    /** Return the total knot distance from beginning to end. */\n    get knotLength01() { return this._knot1 - this._knot0; }\n    /**\n     * Returns true if all numeric values have wraparound conditions for \"closed\" knotVector with specified wrap mode\n     * @param mode optional test mode.  If undefined, use the this.wrappable.\n     */\n    testClosable(mode) {\n        if (mode === undefined)\n            mode = this.wrappable;\n        const leftKnotIndex = this.leftKnotIndex;\n        const rightKnotIndex = this.rightKnotIndex;\n        const period = this.rightKnot - this.leftKnot;\n        const degree = this.degree;\n        const indexDelta = rightKnotIndex - leftKnotIndex;\n        // maximum continuity mode .  . .\n        if (mode === BSplineWrapMode.OpenByAddingControlPoints) {\n            for (let k0 = leftKnotIndex - degree + 1; k0 < leftKnotIndex + degree - 1; k0++) {\n                const k1 = k0 + indexDelta;\n                if (!Geometry.isSameCoordinate(this.knots[k0] + period, this.knots[k1]))\n                    return false;\n            }\n            return true;\n        }\n        // arc mode ...\n        if (mode === BSplineWrapMode.OpenByRemovingKnots) {\n            // we expect {degree} replicated knots at each end . . .\n            const numRepeated = degree - 1;\n            const leftKnot = this.knots[leftKnotIndex];\n            const rightKnot = this.knots[rightKnotIndex];\n            for (let i = 0; i < numRepeated; i++) {\n                if (!Geometry.isSameCoordinate(leftKnot, this.knots[leftKnotIndex - i - 1]))\n                    return false;\n                if (!Geometry.isSameCoordinate(rightKnot, this.knots[rightKnotIndex + i + 1]))\n                    return false;\n            }\n            return true;\n        }\n        return false;\n    }\n    /** Test matching degree and knot values */\n    isAlmostEqual(other) {\n        if (this.degree !== other.degree)\n            return false;\n        return NumberArray.isAlmostEqual(this.knots, other.knots, KnotVector.knotTolerance);\n    }\n    /** Compute the multiplicity of the input knot, or zero if not a knot. */\n    getKnotMultiplicity(knot) {\n        let m = 0;\n        for (const k of this.knots) {\n            if (Math.abs(k - knot) < KnotVector.knotTolerance)\n                ++m;\n            else if (knot < k)\n                break;\n        }\n        return m;\n    }\n    /** Compute the multiplicity of the knot at the given index. */\n    getKnotMultiplicityAtIndex(knotIndex) {\n        let m = 0;\n        if (knotIndex >= 0 && knotIndex < this.knots.length) {\n            const knot = this.knots[knotIndex];\n            ++m; // count this knot\n            for (let i = knotIndex - 1; i >= 0; --i) {\n                const k = this.knots[i];\n                if (Math.abs(k - knot) < KnotVector.knotTolerance)\n                    ++m; // found multiple to left of knot\n                else if (knot > k)\n                    break;\n            }\n            for (let i = knotIndex + 1; i < this.knots.length; ++i) {\n                const k = this.knots[i];\n                if (Math.abs(k - knot) < KnotVector.knotTolerance)\n                    ++m; // found multiple to right of knot\n                else if (knot < k)\n                    break;\n            }\n        }\n        return m;\n    }\n    /** Transform knots to span [0,1].\n     * @returns false if and only if this.knotLength01 is trivial\n     */\n    normalize() {\n        if (this.knotLength01 < KnotVector.knotTolerance)\n            return false;\n        const divisor = 1.0 / this.knotLength01;\n        const leftKnot = this.leftKnot;\n        for (let i = 0; i < this.knots.length; ++i)\n            this.knots[i] = (this.knots[i] - leftKnot) * divisor;\n        // explicitly set rightKnot and its multiples to 1.0 to avoid round-off\n        for (let i = this.rightKnotIndex - 1; i > this.leftKnotIndex && (this.knots[i] === this.knots[this.rightKnotIndex]); --i)\n            this.knots[i] = 1.0;\n        for (let i = this.rightKnotIndex + 1; i < this.knots.length && (this.knots[i] === this.knots[this.rightKnotIndex]); ++i)\n            this.knots[i] = 1.0;\n        this.knots[this.rightKnotIndex] = 1.0;\n        this.setupFixedValues();\n        return true;\n    }\n    /** install knot values from an array, optionally ignoring first and last.\n     */\n    setKnots(knots, skipFirstAndLast) {\n        const numAllocate = skipFirstAndLast ? knots.length - 2 : knots.length;\n        if (numAllocate !== this.knots.length)\n            this.knots = new Float64Array(numAllocate);\n        if (skipFirstAndLast) {\n            for (let i = 1; i + 1 < knots.length; i++)\n                this.knots[i - 1] = knots[i];\n        }\n        else {\n            for (let i = 0; i < knots.length; i++)\n                this.knots[i] = knots[i];\n        }\n        this.setupFixedValues();\n    }\n    /** install knot values from an array, optionally ignoring first and last. */\n    setKnotsCapture(knots) {\n        this.knots = knots;\n        this.setupFixedValues();\n    }\n    /**\n     * Create knot vector with {degree-1} replicated knots at start and end, and uniform knots between.\n     * @param numPoles Number of poles\n     * @param degree degree of polynomial\n     * @param a0 left knot value for active interval\n     * @param a1 right knot value for active interval\n     */\n    static createUniformClamped(numPoles, degree, a0, a1) {\n        const knots = new KnotVector(numPoles + degree - 1, degree);\n        let k = 0;\n        for (let m = 0; m < degree; m++)\n            knots.knots[k++] = a0;\n        const du = 1.0 / (numPoles - degree);\n        for (let i = 1; i + degree < numPoles; i++)\n            knots.knots[k++] = a0 + i * du * (a1 - a0);\n        for (let m = 0; m < degree; m++)\n            knots.knots[k++] = a1;\n        knots.setupFixedValues();\n        return knots;\n    }\n    /**\n     * Create knot vector with wraparound knots at start and end, and uniform knots between.\n     * @param  numInterval number of intervals in knot space.  (NOT POLE COUNT)\n     * @param degree degree of polynomial\n     * @param a0 left knot value for active interval\n     * @param a1 right knot value for active interval\n     */\n    static createUniformWrapped(numInterval, degree, a0, a1) {\n        const knots = new KnotVector(numInterval + 2 * degree - 1, degree);\n        const du = 1.0 / numInterval;\n        for (let i = 1 - degree, k = 0; i < numInterval + degree; i++, k++) {\n            knots.knots[k] = Geometry.interpolate(a0, i * du, a1);\n        }\n        knots.setupFixedValues();\n        return knots;\n    }\n    /**\n     * Create knot vector with given knot values and degree.\n     * @param knotArray knot values\n     * @param degree degree of polynomial\n     * @param skipFirstAndLast true to skip copying the first and last knot values.\n     */\n    static create(knotArray, degree, skipFirstAndLast) {\n        const numAllocate = skipFirstAndLast ? knotArray.length - 2 : knotArray.length;\n        const knots = new KnotVector(numAllocate, degree);\n        knots.setKnots(knotArray, skipFirstAndLast);\n        return knots;\n    }\n    /**\n     * Return the average of degree consecutive knots beginning at knotIndex.\n     */\n    grevilleKnot(knotIndex) {\n        if (knotIndex < 0)\n            return this.leftKnot;\n        if (knotIndex > this.rightKnotIndex)\n            return this.rightKnot;\n        let sum = 0.0;\n        for (let i = knotIndex; i < knotIndex + this.degree; i++)\n            sum += this.knots[i];\n        return sum / this.degree;\n    }\n    /** Return an array sized for a set of the basis function values. */\n    createBasisArray() { return new Float64Array(this.degree + 1); }\n    /** Convert localFraction within the interval following an indexed knot to a knot value. */\n    baseKnotFractionToKnot(knotIndex0, localFraction) {\n        const knot0 = this.knots[knotIndex0];\n        localFraction = Geometry.clamp(localFraction, 0, 1);\n        return knot0 + localFraction * (this.knots[knotIndex0 + 1] - knot0);\n    }\n    /** Convert localFraction within an indexed bezier span to a knot value. */\n    spanFractionToKnot(spanIndex, localFraction) {\n        const k = this.spanIndexToLeftKnotIndex(spanIndex);\n        localFraction = Geometry.clamp(localFraction, 0, 1);\n        return this.knots[k] + localFraction * (this.knots[k + 1] - this.knots[k]);\n    }\n    /** Convert localFraction within an indexed bezier span to fraction of active knot range. */\n    spanFractionToFraction(spanIndex, localFraction) {\n        const knot = this.spanFractionToKnot(spanIndex, localFraction);\n        return (knot - this.leftKnot) / (this.rightKnot - this.leftKnot);\n    }\n    /** Return fraction of active knot range to knot value. */\n    fractionToKnot(fraction) {\n        fraction = Geometry.clamp(fraction, 0, 1); // B-splines are not extendable\n        return Geometry.interpolate(this.knots[this.degree - 1], fraction, this.knots[this.knots.length - this.degree]);\n    }\n    /**\n     * Evaluate basis functions f[] at knot value u.\n     *\n     * @param u knot value for evaluation\n     * @param f array of order basis function values\n     */\n    evaluateBasisFunctions(knotIndex0, u, f) {\n        f[0] = 1.0;\n        if (this.degree < 1)\n            return;\n        // direct compute for linear part ...\n        const u0 = this.knots[knotIndex0];\n        const u1 = this.knots[knotIndex0 + 1];\n        f[1] = (u - u0) / (u1 - u0);\n        f[0] = 1.0 - f[1];\n        if (this.degree < 2)\n            return;\n        for (let depth = 1; depth < this.degree; depth++) {\n            let kLeft = knotIndex0 - depth;\n            let kRight = kLeft + depth + 1;\n            let gCarry = 0.0;\n            for (let step = 0; step <= depth; step++) {\n                const tLeft = this.knots[kLeft++];\n                const tRight = this.knots[kRight++];\n                const fraction = (u - tLeft) / (tRight - tLeft);\n                const g1 = f[step] * fraction;\n                const g0 = f[step] * (1.0 - fraction);\n                f[step] = gCarry + g0;\n                gCarry = g1;\n            }\n            f[depth + 1] = gCarry;\n        }\n    }\n    /**\n     * Evaluate basis functions f[], derivatives df[], and optional second derivatives ddf[] at knot value u.\n     *\n     * @param u knot value for evaluation\n     * @param f array of order basis function values\n     * @param df array of order basis derivative values\n     * @param ddf array of order basis second derivative values\n     */\n    evaluateBasisFunctions1(knotIndex0, u, f, df, ddf) {\n        f[0] = 1.0;\n        df[0] = 0.0;\n        if (this.degree < 1)\n            return;\n        // direct compute for linear part ...\n        const u0 = this.knots[knotIndex0];\n        const u1 = this.knots[knotIndex0 + 1];\n        // ah = 1/(u1-u0)      is the derivative of fraction0\n        // (-ah) is the derivative of fraction1.\n        let ah = 1.0 / (u1 - u0);\n        f[1] = (u - u0) * ah;\n        f[0] = 1.0 - f[1];\n        df[0] = -ah;\n        df[1] = ah;\n        if (ddf) { // first derivative started constant, second derivative started zero.\n            ddf[0] = 0.0;\n            ddf[1] = 0.0;\n        }\n        if (this.degree < 2)\n            return;\n        for (let depth = 1; depth < this.degree; depth++) {\n            let kLeft = knotIndex0 - depth;\n            let kRight = kLeft + depth + 1;\n            let gCarry = 0.0;\n            let dgCarry = 0.0;\n            let ddgCarry = 0.0;\n            // f, df, ddf, are each row vectors with product of `step` linear terms.\n            // f is multiplied on the right by matrix V.  Each row has 2 nonzero entries (which sum to 1)  (0,0,1-fraction, fraction,0,0,0)\n            //    Each row of the derivative dV is two entries (0,0, -1/h, 1/h,0,0,0)\n            // Hence fnew = f * V\n            //      dfnew = df * V + f * dV\n            //      ddfnew = ddf * V + df*dV + df * dV + f * ddV\n            // but ddV is zero so\n            //      ddfnew = ddf * V + 2 * df * dV\n            for (let step = 0; step <= depth; step++) {\n                const tLeft = this.knots[kLeft++];\n                const tRight = this.knots[kRight++];\n                ah = 1.0 / (tRight - tLeft);\n                const fraction = (u - tLeft) * ah;\n                const fraction1 = 1.0 - fraction;\n                const g1 = f[step] * fraction;\n                const g0 = f[step] * fraction1;\n                const dg1 = df[step] * fraction + f[step] * ah;\n                const dg0 = df[step] * fraction1 - f[step] * ah;\n                const dfSave = 2.0 * df[step] * ah;\n                f[step] = gCarry + g0;\n                df[step] = dgCarry + dg0;\n                gCarry = g1;\n                dgCarry = dg1;\n                if (ddf) { // do the backward reference to df before rewriting df !!!\n                    const ddg1 = ddf[step] * fraction + dfSave;\n                    const ddg0 = ddf[step] * fraction1 - dfSave;\n                    ddf[step] = ddgCarry + ddg0;\n                    ddgCarry = ddg1;\n                }\n            }\n            f[depth + 1] = gCarry;\n            df[depth + 1] = dgCarry;\n            if (ddf)\n                ddf[depth + 1] = ddgCarry;\n        }\n    }\n    /** Find the knot span bracketing knots[i] <= u < knots[i+1] and return i.\n     * * If u has no such bracket, return the smaller index of the closest nontrivial bracket.\n     * @param u value to bracket\n     */\n    knotToLeftKnotIndex(u) {\n        for (let i = this.leftKnotIndex; i < this.rightKnotIndex; ++i) {\n            if (u < this.knots[i + 1])\n                return i;\n        }\n        // for u >= rightKnot, return left index of last nontrivial span\n        for (let i = this.rightKnotIndex; i > this.leftKnotIndex; --i) {\n            if (this.knots[i] - this.knots[i - 1] >= KnotVector.knotTolerance)\n                return i - 1;\n        }\n        return this.rightKnotIndex - 1; // shouldn't get here\n    }\n    /**\n     * Given a span index, return the index of the knot at its left.\n     * @param spanIndex index of span\n     */\n    spanIndexToLeftKnotIndex(spanIndex) {\n        const d = this.degree;\n        if (spanIndex <= 0.0)\n            return d - 1;\n        return Math.min(spanIndex + d - 1, this.knots.length - d - 1);\n    }\n    /** Return the knot interval length of indexed bezier span. */\n    spanIndexToSpanLength(spanIndex) {\n        const k = this.spanIndexToLeftKnotIndex(spanIndex);\n        return this.knots[k + 1] - this.knots[k];\n    }\n    /**\n     * Given a span index, test if it is within range and has nonzero length.\n     * * note that a false return does not imply there are no more spans.  This may be a double knot (zero length span) followed by more real spans\n     * @param spanIndex index of span to test.\n     */\n    isIndexOfRealSpan(spanIndex) {\n        if (spanIndex >= 0 && spanIndex < this.numSpans)\n            return !Geometry.isSmallMetricDistance(this.spanIndexToSpanLength(spanIndex));\n        return false;\n    }\n    /** Reflect all knots so `leftKnot` and `rightKnot` are maintained but interval lengths reverse. */\n    reflectKnots() {\n        const a = this.leftKnot;\n        const b = this.rightKnot;\n        const numKnots = this.knots.length;\n        for (let i = 0; i < numKnots; i++)\n            this.knots[i] = a + (b - this.knots[i]);\n        this.knots.reverse();\n    }\n    /**\n     * return a simple array form of the knots.  optionally replicate the first and last\n     * in classic over-clamped manner\n     */\n    copyKnots(includeExtraEndKnot) {\n        const wrap = this.wrappable === BSplineWrapMode.OpenByAddingControlPoints && this.testClosable();\n        const leftIndex = this.leftKnotIndex;\n        const rightIndex = this.rightKnotIndex;\n        const a0 = this.leftKnot;\n        const a1 = this.rightKnot;\n        const delta = a1 - a0;\n        const degree = this.degree;\n        const values = [];\n        if (includeExtraEndKnot) {\n            if (wrap) {\n                values.push(this.knots[rightIndex - degree] - delta);\n            }\n            else {\n                values.push(this.knots[0]);\n            }\n        }\n        for (const u of this.knots)\n            values.push(u);\n        if (includeExtraEndKnot) {\n            if (wrap) {\n                values.push(this.knots[leftIndex + degree] + delta);\n            }\n            else\n                values.push(values[values.length - 1]);\n        }\n        return values;\n    }\n}\n/** tolerance for considering two knots to be the same. */\nKnotVector.knotTolerance = 1.0e-9;\nexport { KnotVector };\n//# sourceMappingURL=KnotVector.js.map",
      "start": 1693508123880,
      "end": 1693508124051,
      "sourcemaps": null
    }
  ]
}
