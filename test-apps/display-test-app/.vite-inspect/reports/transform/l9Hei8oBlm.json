{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/primitives/geometry/GeometryPrimitives.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Rendering\n */\nimport { assert } from \"@itwin/core-bentley\";\nimport { PolyfaceBuilder, PolyfaceQuery, StrokeOptions, SweepContour, } from \"@itwin/core-geometry\";\nimport { DisplayParams } from \"../../../common/render/primitives/DisplayParams\";\nimport { PolyfacePrimitive, PolyfacePrimitiveList } from \"../Polyface\";\nimport { StrokesPrimitive, StrokesPrimitiveList, StrokesPrimitivePointList, StrokesPrimitivePointLists } from \"../Strokes\";\n/** @internal */\nexport class Geometry {\n    constructor(transform, tileRange, displayParams, feature) {\n        this.transform = transform;\n        this.tileRange = tileRange;\n        this.displayParams = displayParams;\n        this.feature = feature;\n    }\n    static createFromPointString(pts, tf, tileRange, params, feature) {\n        return new PrimitivePointStringGeometry(pts, tf, tileRange, params, feature);\n    }\n    static createFromLineString(pts, tf, tileRange, params, feature) {\n        return new PrimitiveLineStringGeometry(pts, tf, tileRange, params, feature);\n    }\n    static createFromLoop(loop, tf, tileRange, params, disjoint, feature) {\n        return new PrimitiveLoopGeometry(loop, tf, tileRange, params, disjoint, feature);\n    }\n    static createFromSolidPrimitive(primitive, tf, tileRange, params, feature) {\n        return new SolidPrimitiveGeometry(primitive, tf, tileRange, params, feature);\n    }\n    static createFromPath(path, tf, tileRange, params, disjoint, feature) {\n        return new PrimitivePathGeometry(path, tf, tileRange, params, disjoint, feature);\n    }\n    static createFromPolyface(ipf, tf, tileRange, params, feature) {\n        return new PrimitivePolyfaceGeometry(ipf, tf, tileRange, params, feature);\n    }\n    getPolyfaces(tolerance) {\n        const facetOptions = StrokeOptions.createForFacets();\n        facetOptions.chordTol = tolerance;\n        if (this.displayParams.isTextured)\n            facetOptions.needParams = true;\n        if (!this.displayParams.ignoreLighting) // ###TODO don't generate normals for 2d views.\n            facetOptions.needNormals = true;\n        return this._getPolyfaces(facetOptions);\n    }\n    getStrokes(tolerance) {\n        const strokeOptions = StrokeOptions.createForCurves();\n        strokeOptions.chordTol = tolerance;\n        return this._getStrokes(strokeOptions);\n    }\n    get hasTexture() { return this.displayParams.isTextured; }\n    doDecimate() { return false; }\n    doVertexCluster() { return true; }\n    part() { return undefined; }\n}\n/** @internal */\nexport class PrimitivePathGeometry extends Geometry {\n    constructor(path, tf, range, params, isDisjoint, feature) {\n        super(tf, range, params, feature);\n        this.path = path;\n        this.isDisjoint = isDisjoint;\n    }\n    _getPolyfaces(_facetOptions) { return undefined; }\n    _getStrokes(facetOptions) {\n        return PrimitivePathGeometry.getStrokesForLoopOrPath(this.path, facetOptions, this.displayParams, this.isDisjoint, this.transform);\n    }\n    static getStrokesForLoopOrPath(loopOrPath, facetOptions, params, isDisjoint, transform) {\n        const strksList = new StrokesPrimitiveList();\n        if (!loopOrPath.isAnyRegionType || params.wantRegionOutline) {\n            const strksPts = new StrokesPrimitivePointLists();\n            PrimitivePathGeometry.collectCurveStrokes(strksPts, loopOrPath, facetOptions, transform);\n            if (strksPts.length > 0) {\n                const isPlanar = loopOrPath.isAnyRegionType;\n                assert(isPlanar === params.wantRegionOutline);\n                const strksPrim = StrokesPrimitive.create(params, isDisjoint, isPlanar);\n                strksPrim.strokes = strksPts;\n                strksList.push(strksPrim);\n            }\n        }\n        return strksList;\n    }\n    static collectCurveStrokes(strksPts, loopOrPath, facetOptions, trans) {\n        const strokes = loopOrPath.getPackedStrokes(facetOptions);\n        if (undefined !== strokes) {\n            const pts = strokes.getPoint3dArray();\n            trans.multiplyPoint3dArrayInPlace(pts);\n            strksPts.push(new StrokesPrimitivePointList(pts));\n        }\n    }\n}\n/** @internal */\nexport class PrimitivePointStringGeometry extends Geometry {\n    constructor(pts, tf, range, params, feature) {\n        super(tf, range, params, feature);\n        this.pts = pts;\n    }\n    _getPolyfaces(_facetOptions) {\n        return undefined;\n    }\n    _getStrokes(_facetOptions) {\n        const strksList = new StrokesPrimitiveList();\n        const strksPts = new StrokesPrimitivePointLists(new StrokesPrimitivePointList(this.pts));\n        const strksPrim = StrokesPrimitive.create(this.displayParams, true, false);\n        strksPrim.strokes = strksPts;\n        strksPrim.transform(this.transform);\n        strksList.push(strksPrim);\n        return strksList;\n    }\n}\n/** @internal */\nexport class PrimitiveLineStringGeometry extends Geometry {\n    constructor(pts, tf, range, params, feature) {\n        super(tf, range, params, feature);\n        this.pts = pts;\n    }\n    _getPolyfaces(_facetOptions) {\n        return undefined;\n    }\n    _getStrokes(_facetOptions) {\n        const strksList = new StrokesPrimitiveList();\n        const strksPts = new StrokesPrimitivePointLists(new StrokesPrimitivePointList(this.pts));\n        const strksPrim = StrokesPrimitive.create(this.displayParams, false, false);\n        strksPrim.strokes = strksPts;\n        strksPrim.transform(this.transform);\n        strksList.push(strksPrim);\n        return strksList;\n    }\n}\n/** @internal */\nexport class PrimitiveLoopGeometry extends Geometry {\n    constructor(loop, tf, range, params, isDisjoint, feature) {\n        super(tf, range, params, feature);\n        this.loop = loop;\n        this.isDisjoint = isDisjoint;\n    }\n    _getPolyfaces(facetOptions) {\n        if (!this.loop.isAnyRegionType) {\n            return undefined;\n        }\n        // The following is good for single loop things according to Earlin.\n        const contour = SweepContour.createForLinearSweep(this.loop);\n        if (contour !== undefined) {\n            const pfBuilder = PolyfaceBuilder.create(facetOptions);\n            contour.emitFacets(pfBuilder, false, this.transform); // build facets and emit them to the builder\n            const polyface = pfBuilder.claimPolyface();\n            const wantEdges = DisplayParams.RegionEdgeType.Default === this.displayParams.regionEdgeType;\n            const isPlanar = true;\n            return new PolyfacePrimitiveList(PolyfacePrimitive.create(this.displayParams, polyface, wantEdges, isPlanar));\n        } // ###TODO: this approach might not work with holes\n        return undefined;\n    }\n    _getStrokes(facetOptions) {\n        return PrimitivePathGeometry.getStrokesForLoopOrPath(this.loop, facetOptions, this.displayParams, this.isDisjoint, this.transform);\n    }\n}\n/** @internal */\nexport class PrimitivePolyfaceGeometry extends Geometry {\n    constructor(polyface, tf, range, params, feature) {\n        super(tf, range, params, feature);\n        this.polyface = tf.isIdentity ? polyface : polyface.cloneTransformed(tf);\n    }\n    _getPolyfaces(facetOptions) {\n        if (!this.hasTexture) {\n            if (this.polyface.data.param)\n                this.polyface.data.param.clear();\n            if (this.polyface.data.paramIndex)\n                this.polyface.data.paramIndex = [];\n        }\n        if (!facetOptions.needNormals) {\n            if (this.polyface.data.normal)\n                this.polyface.data.normal.clear();\n            if (this.polyface.data.normalIndex)\n                this.polyface.data.normalIndex = [];\n        }\n        else if (!this.polyface.data.normal || 0 === this.polyface.data.normal.length) {\n            PolyfaceQuery.buildAverageNormals(this.polyface);\n        }\n        return new PolyfacePrimitiveList(PolyfacePrimitive.create(this.displayParams, this.polyface));\n    }\n    _getStrokes(_facetOptions) { return undefined; }\n}\nclass SolidPrimitiveGeometry extends Geometry {\n    constructor(primitive, tf, range, params, feature) {\n        super(tf, range, params, feature);\n        const xformPrim = tf.isIdentity ? primitive : primitive.cloneTransformed(tf);\n        this._primitive = xformPrim !== undefined ? xformPrim : primitive;\n    }\n    _getStrokes() { return undefined; }\n    _getPolyfaces(opts) {\n        const builder = PolyfaceBuilder.create(opts);\n        builder.addGeometryQuery(this._primitive);\n        return new PolyfacePrimitiveList(PolyfacePrimitive.create(this.displayParams, builder.claimPolyface()));\n    }\n}\n//# sourceMappingURL=GeometryPrimitives.js.map",
      "start": 1693508119966,
      "end": 1693508120051,
      "sourcemaps": null
    }
  ]
}
