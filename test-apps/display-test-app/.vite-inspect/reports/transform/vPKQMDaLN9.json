{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/topology/HalfEdgeGraphFromIndexedLoopsContext.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\nimport { HalfEdge, HalfEdgeGraph, HalfEdgeMask } from \"./Graph\";\n/** @packageDocumentation\n * @module Topology\n */\n/**\n * Context for building a half edge graph from loops defined only by indices.\n * * Direct use case:\n *   * Create the context.\n *   * Repeatedly call insertLoop(indicesAroundLoop) to announce various loops.\n *   * Finish by accessing the graph property.\n * @internal\n */\nexport class HalfEdgeGraphFromIndexedLoopsContext {\n    constructor() {\n        this._unmatchedEdges = new Map();\n        this._graph = new HalfEdgeGraph();\n        this._halfEdgesAroundCurrentLoop = [];\n    }\n    get graph() { return this._graph; }\n    indexPairToString(index0, index1) {\n        return `${index0.toString()},${index1.toString()}`;\n    }\n    /** Create a loop with specified indices at its vertices.\n     * * For an edge with index pair [indexA, indexB]:\n     *   * if [indexB, indexA] has never appeared, a HalfEdge mated pair is created.\n     *      * One of that mated pair becomes a HalfEdge in this loop.\n     *      * The other is \"unmatched\"\n     *      * When announceMatedHalfEdges(halfEdge) is called:\n     *         * halfEdge and its mate are \"new\"\n     *         * all coordinates are zeros.\n     *         * each contains (as its halfEdge.id property) one index of the [indexA,indexB] pair.\n     *         * those coordinates and indices will never be referenced again by this construction sequence -- the caller is free to mutate them as needed.\n     *   * if [indexB, indexA] appeared previously (and its outer HalfEdge was left \"unmatched\"),\n     *              the \"unmatched\" HalfEdge is used in the loop being constructed.\n     * @param indices Array of indices around the edge.  This is accessed cyclically.\n     * @param announceMatedHalfEdges optional function to be called as mated pairs are created. At the call,\n     *     the given HalfEdge and its mate will have a pair of successive indices from the array.\n     */\n    insertLoop(indices, announceMatedHalfEdges) {\n        const n = indices.length;\n        if (n > 1) {\n            let index0 = indices[indices.length - 1];\n            this._halfEdgesAroundCurrentLoop.length = 0;\n            for (const index1 of indices) {\n                const insideString = this.indexPairToString(index0, index1);\n                const halfEdgePreviouslyConstructedFromOppositeSide = this._unmatchedEdges.get(insideString);\n                if (halfEdgePreviouslyConstructedFromOppositeSide === undefined) {\n                    // This is the first appearance of this edge in either direction.\n                    const outsideString = this.indexPairToString(index1, index0); // string referencing the \"other\" side of the new edge.\n                    const newHalfEdgeAroundLoop = this._graph.createEdgeIdId(index0, index1);\n                    if (announceMatedHalfEdges !== undefined)\n                        announceMatedHalfEdges(newHalfEdgeAroundLoop);\n                    this._unmatchedEdges.set(outsideString, newHalfEdgeAroundLoop.edgeMate);\n                    this._halfEdgesAroundCurrentLoop.push(newHalfEdgeAroundLoop);\n                    newHalfEdgeAroundLoop.edgeMate.setMask(HalfEdgeMask.EXTERIOR);\n                }\n                else {\n                    this._halfEdgesAroundCurrentLoop.push(halfEdgePreviouslyConstructedFromOppositeSide);\n                    halfEdgePreviouslyConstructedFromOppositeSide.clearMask(HalfEdgeMask.EXTERIOR);\n                }\n                index0 = index1;\n            }\n            let halfEdgeA = this._halfEdgesAroundCurrentLoop[this._halfEdgesAroundCurrentLoop.length - 1];\n            for (const halfEdgeB of this._halfEdgesAroundCurrentLoop) {\n                const halfEdgeC = halfEdgeA.faceSuccessor;\n                HalfEdge.pinch(halfEdgeB, halfEdgeC);\n                halfEdgeA = halfEdgeB;\n            }\n            return this._halfEdgesAroundCurrentLoop[0];\n        }\n        return undefined;\n    }\n}\n//# sourceMappingURL=HalfEdgeGraphFromIndexedLoopsContext.js.map",
      "start": 1693508125486,
      "end": 1693508125586,
      "sourcemaps": null
    }
  ]
}
