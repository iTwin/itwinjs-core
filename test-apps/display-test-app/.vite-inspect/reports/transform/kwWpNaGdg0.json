{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tools/PrimitiveTool.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tools\n */\nimport { assert } from \"@itwin/core-bentley\";\nimport { IModelApp } from \"../IModelApp\";\nimport { NotifyMessageDetails, OutputMessagePriority } from \"../NotificationManager\";\nimport { AccuDrawShortcuts } from \"./AccuDrawTool\";\nimport { BeButton, CoordinateLockOverrides, CoreTools, InteractiveTool } from \"./Tool\";\n/** The PrimitiveTool class can be used to implement tools to create or modify geometric elements.\n * @see [Writing a PrimitiveTool]($docs/learning/frontend/primitivetools.md)\n * @public\n * @extensions\n */\nexport class PrimitiveTool extends InteractiveTool {\n    constructor() {\n        super(...arguments);\n        this.targetIsLocked = false; // If target model is known, set this to true in constructor and override getTargetModel.\n    }\n    get targetModelId() { return this._targetModelId; }\n    set targetModelId(v) { this._targetModelId = v; }\n    /** Get the iModel on which this tool operates.\n     * @note The iModel is obtained from [[targetView]], so should only be invoked if the tool installed successfully.\n     */\n    get iModel() {\n        assert(undefined !== this.targetView);\n        return this.targetView.view.iModel;\n    }\n    /** Get the briefcase on which this tool operates, if the tool has successfully installed and the target [[iModel]] is a briefcase. */\n    get briefcase() {\n        const iModel = this.targetView?.view.iModel;\n        return iModel?.isBriefcaseConnection() ? iModel : undefined;\n    }\n    /**\n     * Establish this tool as the active PrimitiveTool.\n     * @return true if this tool was installed (though it may have exited too)\n     * @note If you override this method you **must** call `super.run` and return false if it returns false.\n     */\n    async run(..._args) {\n        const { toolAdmin, viewManager } = IModelApp;\n        if (!this.isCompatibleViewport(viewManager.selectedView, false) || !await toolAdmin.onInstallTool(this))\n            return false;\n        await toolAdmin.startPrimitiveTool(this);\n        await toolAdmin.onPostInstallTool(this);\n        return true;\n    }\n    /** Determine whether the supplied Viewport is compatible with this tool.\n     * @param vp the Viewport to check\n     */\n    isCompatibleViewport(vp, isSelectedViewChange) {\n        if (undefined === vp)\n            return false; // No views are open...\n        const view = vp.view;\n        const iModel = view.iModel;\n        if (this.requireWriteableTarget() && iModel.isReadonly)\n            return false; // this Tool can't be used when iModel is read only.\n        if (undefined === this.targetView || (!this.targetIsLocked && isSelectedViewChange))\n            this.targetView = vp; // Update target to new view if undefined or still free to change.\n        if (undefined === this.targetModelId && (!this.targetIsLocked || vp === this.targetView))\n            return true; // Accept if this view is current target or any type of model/view is still ok as target is still free to change.\n        if (iModel !== this.iModel)\n            return false; // Once a ViewState has been established, only accept viewport showing the same iModel.\n        if (this.targetModelId)\n            return view.viewsModel(this.targetModelId); // If a specific target model is specified, only allow view that shows it.\n        if (view.isSpatialView() && this.targetView.view.isSpatialView())\n            return true; // No specific target, two spatial views are considered compatible.\n        let allowView = false;\n        view.forEachModel((model) => {\n            if (!allowView && this.targetView.view.viewsModel(model.id))\n                allowView = true;\n        });\n        return allowView; // Accept if this view shares a model in common with target.\n    }\n    /**\n     * Checks that the adjusted point from the supplied button event is within the project extents for spatial views. The range of physical geometry\n     * should always be fully inside the project extents. Only checking the adjusted point won't absolutely guarantee that a tool doesn't create/move geometry\n     * outside the project extents, but it will be sufficient to handle most cases and provide good feedback to the user.\n     * @return true if ev is acceptable.\n     */\n    isValidLocation(ev, isButtonEvent) {\n        const vp = ev.viewport;\n        if (undefined === vp)\n            return false;\n        if (isButtonEvent && BeButton.Data !== ev.button)\n            return true;\n        const view = vp.view;\n        if (!view.isSpatialView())\n            return true;\n        // NOTE: If points aren't being adjusted then the tool shouldn't be creating geometry currently (ex. locating elements) and we shouldn't filter point...\n        if (0 !== (IModelApp.toolAdmin.toolState.coordLockOvr & CoordinateLockOverrides.ACS))\n            return true;\n        // We know the tool isn't doing a locate, we don't know what it will do with this point. Minimize erroneous filtering by restricting the check to when AccuSnap is tool enable (not user enabled)...\n        if (!IModelApp.accuSnap.isSnapEnabled)\n            return true;\n        const extents = view.iModel.projectExtents;\n        if (extents.containsPoint(ev.point))\n            return true;\n        if (isButtonEvent && ev.isDown)\n            IModelApp.notifications.outputMessage(new NotifyMessageDetails(OutputMessagePriority.Error, CoreTools.translate(\"ElementSet.Error.ProjectExtents\")));\n        return false;\n    }\n    /** Called on data button down event to lock the tool to its current target model. */\n    autoLockTarget() {\n        if (undefined === this.targetView)\n            return;\n        this.targetIsLocked = true;\n    }\n    /**  Returns the prompt based on the tool's current state. */\n    getPrompt() { return \"\"; }\n    /** Called from isCompatibleViewport to check for a read only iModel, which is not a valid target for tools that create or modify elements. */\n    requireWriteableTarget() { return true; }\n    /**\n     * Called when active view changes. Tool may choose to restart or exit based on current view type.\n     * @param _previous The previously active view.\n     * @param current The new active view.\n     */\n    async onSelectedViewportChanged(_previous, current) {\n        if (this.isCompatibleViewport(current, true))\n            return;\n        return this.onRestartTool();\n    }\n    /**\n     * Called to reset tool to initial state. PrimitiveTool implements this method to call onRestartTool.\n     */\n    async onReinitialize() { return this.onRestartTool(); }\n    async exitTool() { return IModelApp.toolAdmin.startDefaultTool(); }\n    /**\n     * Called to reverse to a previous tool state (ex. undo last data button).\n     * @return false to instead reverse the most recent transaction.\n     */\n    async onUndoPreviousStep() { return false; }\n    /** @internal */\n    async undoPreviousStep() {\n        if (!await this.onUndoPreviousStep())\n            return false;\n        AccuDrawShortcuts.processPendingHints(); // Process pending hints from onUndoPreviousStep before calling updateDynamics...\n        IModelApp.viewManager.invalidateDecorationsAllViews();\n        IModelApp.toolAdmin.updateDynamics(undefined, undefined, true); // Don't wait for motion to update dynamics...\n        return true;\n    }\n    /**\n     * Called to reinstate to a previous tool state (ex. redo last data button).\n     * @return false to instead reinstate the most recent transaction.\n     */\n    async onRedoPreviousStep() { return false; }\n    /** @internal */\n    async redoPreviousStep() {\n        if (!await this.onRedoPreviousStep())\n            return false;\n        AccuDrawShortcuts.processPendingHints(); // Process pending hints from onRedoPreviousStep before calling updateDynamics...\n        IModelApp.viewManager.invalidateDecorationsAllViews();\n        IModelApp.toolAdmin.updateDynamics(undefined, undefined, true); // Don't wait for motion to update dynamics...\n        return true;\n    }\n    /** If this tool is editing a briefcase, commits any elements that the tool has changed, supplying the tool name as the undo string. */\n    async saveChanges() {\n        if (this.iModel.isBriefcaseConnection())\n            return this.iModel.saveChanges(this.toolId);\n    }\n}\n//# sourceMappingURL=PrimitiveTool.js.map",
      "start": 1693508120024,
      "end": 1693508120303,
      "sourcemaps": null
    }
  ]
}
