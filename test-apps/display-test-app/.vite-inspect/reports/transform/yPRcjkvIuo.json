{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/primitives/VertexTableBuilder.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Rendering\n */\nimport { assert } from \"@itwin/core-bentley\";\nimport { Point2d, Range2d } from \"@itwin/core-geometry\";\nimport { ColorDef, FeatureIndexType, FillFlags, QParams2d, QParams3d, QPoint2d, QPoint3dList, } from \"@itwin/core-common\";\nimport { AuxChannelTable } from \"../../common/render/primitives/AuxChannelTable\";\nimport { computeDimensions } from \"../../common/render/primitives/VertexTable\";\nimport { createSurfaceMaterial, SurfaceType } from \"../../common/render/primitives/SurfaceParams\";\nimport { VertexIndices } from \"../../common/render/primitives/VertexIndices\";\nimport { createEdgeParams } from \"./EdgeParams\";\n/** @internal */\nexport function createMeshParams(args, maxDimension) {\n    const builder = createMeshBuilder(args);\n    const vertices = builder.build(args.colors, args.features, maxDimension);\n    const surfaceIndices = VertexIndices.fromArray(args.vertIndices);\n    const surface = {\n        type: builder.type,\n        indices: surfaceIndices,\n        fillFlags: args.fillFlags ?? FillFlags.ByView,\n        hasBakedLighting: true === args.hasBakedLighting,\n        textureMapping: undefined !== args.textureMapping ? { texture: args.textureMapping.texture, alwaysDisplayed: false } : undefined,\n        material: createSurfaceMaterial(args.material),\n    };\n    const channels = undefined !== args.auxChannels ? AuxChannelTable.fromChannels(args.auxChannels, vertices.numVertices, maxDimension) : undefined;\n    const edges = createEdgeParams(args);\n    return {\n        vertices,\n        surface,\n        edges,\n        isPlanar: !!args.isPlanar,\n        auxChannels: channels,\n    };\n}\n/** Builds a VertexTable from some data type supplying the vertex data.\n * @internal\n */\nexport class VertexTableBuilder {\n    constructor() {\n        this._curIndex = 0;\n    }\n    get uvParams() { return undefined; }\n    appendColorTable(colorIndex) {\n        if (undefined !== colorIndex.nonUniform) {\n            for (const color of colorIndex.nonUniform.colors) {\n                this.appendColor(color);\n            }\n        }\n    }\n    advance(nBytes) {\n        this._curIndex += nBytes;\n        assert(this._curIndex <= this.data.length);\n    }\n    append8(val) {\n        assert(0 <= val);\n        assert(val <= 0xff);\n        assert(val === Math.floor(val));\n        this.data[this._curIndex] = val;\n        this.advance(1);\n    }\n    append16(val) {\n        this.append8(val & 0x00ff);\n        this.append8(val >>> 8);\n    }\n    append32(val) {\n        this.append16(val & 0x0000ffff);\n        this.append16(val >>> 16);\n    }\n    appendColor(tbgr) {\n        const colors = ColorDef.getColors(tbgr);\n        // invert transparency => alpha\n        colors.t = 255 - colors.t;\n        // premultiply alpha...\n        switch (colors.t) {\n            case 0:\n                colors.r = colors.g = colors.b = 0;\n                break;\n            case 255:\n                break;\n            default: {\n                const f = colors.t / 255.0;\n                colors.r = Math.floor(colors.r * f + 0.5);\n                colors.g = Math.floor(colors.g * f + 0.5);\n                colors.b = Math.floor(colors.b * f + 0.5);\n                break;\n            }\n        }\n        // Store 32-bit value in little-endian order (red first)\n        this.append8(colors.r);\n        this.append8(colors.g);\n        this.append8(colors.b);\n        this.append8(colors.t);\n    }\n    build(colorIndex, featureIndex, maxDimension) {\n        const { numVertices, numRgbaPerVertex } = this;\n        const numColors = colorIndex.isUniform ? 0 : colorIndex.numColors;\n        const dimensions = computeDimensions(numVertices, numRgbaPerVertex, numColors, maxDimension);\n        assert(0 === dimensions.width % numRgbaPerVertex || (0 < numColors && 1 === dimensions.height));\n        const data = new Uint8Array(dimensions.width * dimensions.height * 4);\n        this.data = data;\n        for (let i = 0; i < numVertices; i++)\n            this.appendVertex(i);\n        this.appendColorTable(colorIndex);\n        this.data = undefined;\n        return {\n            data,\n            qparams: this.qparams,\n            usesUnquantizedPositions: this.usesUnquantizedPositions,\n            width: dimensions.width,\n            height: dimensions.height,\n            hasTranslucency: colorIndex.hasAlpha,\n            uniformColor: colorIndex.uniform,\n            numVertices,\n            numRgbaPerVertex,\n            uvParams: this.uvParams,\n            featureIndexType: featureIndex.type,\n            uniformFeatureID: featureIndex.type === FeatureIndexType.Uniform ? featureIndex.featureID : undefined,\n        };\n    }\n    static buildFromPolylines(args, maxDimension) {\n        const polylines = args.polylines;\n        if (polylines.length === 0)\n            return undefined;\n        const builder = createPolylineBuilder(args);\n        return builder.build(args.colors, args.features, maxDimension);\n    }\n}\nvar Quantized;\n(function (Quantized) {\n    /**\n     * Supplies vertex data from a PolylineArgs or MeshArgs. Each vertex consists of 12 bytes:\n     *  pos.x           00\n     *  pos.y           02\n     *  pos.z           04\n     *  colorIndex      06\n     *  featureIndex    08 (24 bits)\n     *  materialIndex   0B (for meshes that use a material atlas; otherwise unused). NOTE: Currently front-end code does not produce material atlases.\n     */\n    class SimpleBuilder extends VertexTableBuilder {\n        constructor(args) {\n            super();\n            this._qpoints = args.points;\n            this.args = args;\n            assert(undefined !== this.args.points);\n        }\n        get numVertices() { return this.args.points.length; }\n        get numRgbaPerVertex() { return 3; }\n        get usesUnquantizedPositions() { return false; }\n        get qparams() {\n            return this._qpoints.params;\n        }\n        appendVertex(vertIndex) {\n            this.appendPosition(vertIndex);\n            this.appendColorIndex(vertIndex);\n            this.appendFeatureIndex(vertIndex);\n        }\n        appendPosition(vertIndex) {\n            this.append16(this._qpoints.list[vertIndex].x);\n            this.append16(this._qpoints.list[vertIndex].y);\n            this.append16(this._qpoints.list[vertIndex].z);\n        }\n        appendColorIndex(vertIndex) {\n            if (undefined !== this.args.colors.nonUniform) {\n                this.append16(this.args.colors.nonUniform.indices[vertIndex]);\n            }\n            else {\n                this.advance(2);\n            }\n        }\n        appendFeatureIndex(vertIndex) {\n            if (undefined !== this.args.features.featureIDs) {\n                this.append32(this.args.features.featureIDs[vertIndex]);\n            }\n            else {\n                this.advance(4);\n            }\n        }\n    }\n    Quantized.SimpleBuilder = SimpleBuilder;\n    /** Supplies vertex data from a MeshArgs. */\n    class MeshBuilder extends SimpleBuilder {\n        constructor(args, type) {\n            super(args);\n            this.type = type;\n        }\n        static create(args) {\n            if (args.isVolumeClassifier)\n                return new MeshBuilder(args, SurfaceType.VolumeClassifier);\n            const isLit = undefined !== args.normals && 0 < args.normals.length;\n            const isTextured = undefined !== args.textureMapping;\n            let uvParams;\n            if (args.textureMapping) {\n                const uvRange = Range2d.createNull();\n                const fpts = args.textureMapping.uvParams;\n                const pt2d = new Point2d();\n                if (undefined !== fpts && fpts.length > 0)\n                    for (let i = 0; i < args.points.length; i++)\n                        uvRange.extendPoint(Point2d.create(fpts[i].x, fpts[i].y, pt2d));\n                uvParams = QParams2d.fromRange(uvRange);\n            }\n            if (isLit)\n                return isTextured ? new TexturedLitMeshBuilder(args, uvParams) : new LitMeshBuilder(args);\n            else\n                return isTextured ? new TexturedMeshBuilder(args, uvParams) : new MeshBuilder(args, SurfaceType.Unlit);\n        }\n    }\n    Quantized.MeshBuilder = MeshBuilder;\n    /** Supplies vertex data from a MeshArgs where each vertex consists of 16 bytes.\n     * In addition to the SimpleBuilder data, the final 4 bytes hold the quantized UV params\n     * The color index is left uninitialized as it is unused.\n     */\n    class TexturedMeshBuilder extends MeshBuilder {\n        constructor(args, qparams, type = SurfaceType.Textured) {\n            super(args, type);\n            this._qpoint = new QPoint2d();\n            this._qparams = qparams;\n            assert(undefined !== args.textureMapping);\n        }\n        get numRgbaPerVertex() { return 4; }\n        get uvParams() { return this._qparams; }\n        appendVertex(vertIndex) {\n            this.appendPosition(vertIndex);\n            this.appendNormal(vertIndex);\n            this.appendFeatureIndex(vertIndex);\n            this.appendUVParams(vertIndex);\n        }\n        appendNormal(_vertIndex) { this.advance(2); } // no normal for unlit meshes\n        appendUVParams(vertIndex) {\n            this._qpoint.init(this.args.textureMapping.uvParams[vertIndex], this._qparams);\n            this.append16(this._qpoint.x);\n            this.append16(this._qpoint.y);\n        }\n    }\n    /** As with TexturedMeshBuilder, but the color index is replaced with the oct-encoded normal value. */\n    class TexturedLitMeshBuilder extends TexturedMeshBuilder {\n        constructor(args, qparams) {\n            super(args, qparams, SurfaceType.TexturedLit);\n            assert(undefined !== args.normals);\n        }\n        appendNormal(vertIndex) { this.append16(this.args.normals[vertIndex].value); }\n    }\n    /** 16 bytes. The last 2 bytes are unused; the 2 immediately preceding it hold the oct-encoded normal value. */\n    class LitMeshBuilder extends MeshBuilder {\n        constructor(args) {\n            super(args, SurfaceType.Lit);\n            assert(undefined !== args.normals);\n        }\n        get numRgbaPerVertex() { return 4; }\n        appendVertex(vertIndex) {\n            super.appendVertex(vertIndex);\n            this.append16(this.args.normals[vertIndex].value);\n            this.advance(2); // 2 unused bytes\n        }\n    }\n})(Quantized || (Quantized = {}));\n/** Builders in this namespace store vertex positions as 32-bit floats instead of quantizing to 16-bit unsigned integers.\n * This is preferred for decoration graphics, which might contain ranges of positions that exceed the limits for quantization; if quantized,\n * they could produce visual artifacts.\n * Each builder produces a VertexTable that starts with the following layout:\n *  pos.x:        00\n *  pos.y:        04\n *  pos.z:        08\n *  featureIndex: 0C\n *  materialIndex:0F (NOTE: frontend code currently doesn't produce material atlases, so this is always zero).\n * Followed (by default) by:\n *  colorIndex:   10\n *  unused:       12\n * Subclasses may add 4 more bytes and/or overwrite the final 4 bytes above.\n */\nvar Unquantized;\n(function (Unquantized) {\n    const u32Array = new Uint32Array(1);\n    const f32Array = new Float32Array(u32Array.buffer);\n    // colorIndex:  10\n    // unused:      12\n    class SimpleBuilder extends VertexTableBuilder {\n        constructor(args) {\n            super();\n            assert(!(args.points instanceof QPoint3dList));\n            this._qparams3d = QParams3d.fromRange(args.points.range);\n            this.args = args;\n            this._points = args.points;\n        }\n        get numVertices() { return this._points.length; }\n        get numRgbaPerVertex() { return 5; }\n        get usesUnquantizedPositions() { return true; }\n        get qparams() { return this._qparams3d; }\n        appendVertex(vertIndex) {\n            this.appendTransposePosAndFeatureNdx(vertIndex);\n            this.appendColorIndex(vertIndex);\n        }\n        appendFloat32(val) {\n            f32Array[0] = val;\n            this.append32(u32Array[0]);\n        }\n        convertFloat32(val) {\n            f32Array[0] = val;\n            return u32Array[0];\n        }\n        appendTransposePosAndFeatureNdx(vertIndex) {\n            // transpose position xyz vals into [0].xyz - [3].xyz, and add feature index at .w\n            // this is to order things to let shader code access much more efficiently\n            const pt = this._points[vertIndex];\n            const x = this.convertFloat32(pt.x);\n            const y = this.convertFloat32(pt.y);\n            const z = this.convertFloat32(pt.z);\n            const featID = (this.args.features.featureIDs) ? this.args.features.featureIDs[vertIndex] : 0;\n            this.append8(x & 0x000000ff);\n            this.append8(y & 0x000000ff);\n            this.append8(z & 0x000000ff);\n            this.append8(featID & 0x000000ff);\n            this.append8((x >>> 8) & 0x000000ff);\n            this.append8((y >>> 8) & 0x000000ff);\n            this.append8((z >>> 8) & 0x000000ff);\n            this.append8((featID >>> 8) & 0x000000ff);\n            this.append8((x >>> 16) & 0x000000ff);\n            this.append8((y >>> 16) & 0x000000ff);\n            this.append8((z >>> 16) & 0x000000ff);\n            this.append8((featID >>> 16) & 0x000000ff);\n            this.append8(x >>> 24);\n            this.append8(y >>> 24);\n            this.append8(z >>> 24);\n            this.append8(featID >>> 24);\n        }\n        appendPosition(vertIndex) {\n            const pt = this._points[vertIndex];\n            this.appendFloat32(pt.x);\n            this.appendFloat32(pt.y);\n            this.appendFloat32(pt.z);\n        }\n        appendFeatureIndex(vertIndex) {\n            if (this.args.features.featureIDs)\n                this.append32(this.args.features.featureIDs[vertIndex]);\n            else\n                this.advance(4);\n        }\n        _appendColorIndex(vertIndex) {\n            if (undefined !== this.args.colors.nonUniform)\n                this.append16(this.args.colors.nonUniform.indices[vertIndex]);\n            else\n                this.advance(2);\n        }\n        appendColorIndex(vertIndex) {\n            this._appendColorIndex(vertIndex);\n            this.advance(2);\n        }\n    }\n    Unquantized.SimpleBuilder = SimpleBuilder;\n    class MeshBuilder extends SimpleBuilder {\n        constructor(args, type) {\n            super(args);\n            this.type = type;\n        }\n        static create(args) {\n            if (args.isVolumeClassifier)\n                return new MeshBuilder(args, SurfaceType.VolumeClassifier);\n            const isLit = undefined !== args.normals && 0 < args.normals.length;\n            const isTextured = undefined !== args.textureMapping;\n            let uvParams;\n            if (args.textureMapping) {\n                const uvRange = Range2d.createNull();\n                const fpts = args.textureMapping.uvParams;\n                const pt2d = new Point2d();\n                if (undefined !== fpts && fpts.length > 0)\n                    for (let i = 0; i < args.points.length; i++)\n                        uvRange.extendPoint(Point2d.create(fpts[i].x, fpts[i].y, pt2d));\n                uvParams = QParams2d.fromRange(uvRange);\n            }\n            if (isLit)\n                return isTextured ? new TexturedLitMeshBuilder(args, uvParams) : new LitMeshBuilder(args);\n            else\n                return isTextured ? new TexturedMeshBuilder(args, uvParams) : new MeshBuilder(args, SurfaceType.Unlit);\n        }\n    }\n    Unquantized.MeshBuilder = MeshBuilder;\n    // u: 10\n    // v: 12\n    class TexturedMeshBuilder extends MeshBuilder {\n        constructor(args, qparams, type = SurfaceType.Textured) {\n            super(args, type);\n            this._qpoint = new QPoint2d();\n            this._qparams = qparams;\n            assert(undefined !== args.textureMapping);\n        }\n        get uvParams() { return this._qparams; }\n        appendVertex(vertIndex) {\n            super.appendVertex(vertIndex);\n            this._qpoint.init(this.args.textureMapping.uvParams[vertIndex], this._qparams);\n            this.append16(this._qpoint.x);\n            this.append16(this._qpoint.y);\n        }\n        appendColorIndex() { }\n    }\n    // u: 10\n    // v: 12\n    // normal: 14\n    // unused: 16\n    class TexturedLitMeshBuilder extends TexturedMeshBuilder {\n        constructor(args, qparams) {\n            super(args, qparams, SurfaceType.TexturedLit);\n            assert(undefined !== args.normals);\n        }\n        get numRgbaPerVertex() { return 6; }\n        appendVertex(vertIndex) {\n            super.appendVertex(vertIndex);\n            this.append16(this.args.normals[vertIndex].value);\n            this.advance(2);\n        }\n    }\n    // color: 10\n    // normal: 12\n    class LitMeshBuilder extends MeshBuilder {\n        constructor(args) {\n            super(args, SurfaceType.Lit);\n            assert(undefined !== args.normals);\n        }\n        appendColorIndex(vertIndex) {\n            super._appendColorIndex(vertIndex);\n        }\n        appendVertex(vertIndex) {\n            super.appendVertex(vertIndex);\n            this.append16(this.args.normals[vertIndex].value);\n        }\n    }\n})(Unquantized || (Unquantized = {}));\nfunction createMeshBuilder(args) {\n    if (args.points instanceof QPoint3dList)\n        return Quantized.MeshBuilder.create(args);\n    else\n        return Unquantized.MeshBuilder.create(args);\n}\nfunction createPolylineBuilder(args) {\n    if (args.points instanceof QPoint3dList)\n        return new Quantized.SimpleBuilder(args);\n    else\n        return new Unquantized.SimpleBuilder(args);\n}\n//# sourceMappingURL=VertexTableBuilder.js.map",
      "start": 1693508119952,
      "end": 1693508120025,
      "sourcemaps": null
    }
  ]
}
