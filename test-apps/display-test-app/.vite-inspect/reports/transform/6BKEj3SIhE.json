{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/MockRender.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Utils\n */\nimport { dispose } from \"@itwin/core-bentley\";\nimport { EmptyLocalization } from \"@itwin/core-common\";\nimport { IModelApp } from \"../IModelApp\";\nimport { ViewRect } from \"../common/ViewRect\";\nimport { PrimitiveBuilder } from \"./primitives/geometry/GeometryListBuilder\";\nimport { RenderGraphic } from \"./RenderGraphic\";\nimport { RenderSystem } from \"./RenderSystem\";\nimport { RenderTarget } from \"./RenderTarget\";\n/** Contains extensible mock implementations of the various components of a RenderSystem, intended for use in tests.\n * Use these for tests instead of the default RenderSystem wherever possible because:\n *  (1) Electron has a bug on Windows in which it fails to obtain a WebGLRenderingContext when running inside a VM (e.g., during CI job); and\n *  (2) To decouple the logic which uses aspects of the RenderSystem from the full implementation.\n * Any and all of these types can be extended for the purposes of specific tests.\n * To use this:\n *  (1) If overriding anything in the implementation supplied herein, pass a SystemFactory function to MockRender.App.systemFactory.\n *  (2) Call MockRender.App.startup() instead of IModelApp.startup() before tests begin.\n *  (3) Likewise call MockRender.App.shutdown() when finished. This resets the SystemFactory to its default.\n * @note The APIs within this namespace are intended *strictly* for use with unit tests.\n * @internal\n */\nexport var MockRender;\n(function (MockRender) {\n    /** @internal */\n    class Target extends RenderTarget {\n        constructor(_system) {\n            super();\n            this._system = _system;\n        }\n        get renderSystem() { return this._system; }\n        get wantInvertBlackBackground() { return false; }\n        get analysisFraction() { return 0; }\n        set analysisFraction(_fraction) { }\n        changeScene(_scene) { }\n        changeDynamics(_dynamics) { }\n        changeDecorations(_decs) { }\n        changeRenderPlan(_plan) { }\n        drawFrame(_sceneTime) { }\n        updateViewRect() { return false; }\n        readPixels(_rect, _selector, receiver, _excludeNonLocatable) { receiver(undefined); }\n        get screenSpaceEffects() { return []; }\n        set screenSpaceEffects(_effects) { }\n    }\n    MockRender.Target = Target;\n    /** @internal */\n    class OnScreenTarget extends Target {\n        constructor(system, _canvas) {\n            super(system);\n            this._canvas = _canvas;\n        }\n        get viewRect() { return new ViewRect(0, 0, this._canvas.clientWidth, this._canvas.clientHeight); }\n        setViewRect(_rect, _temp) { }\n    }\n    MockRender.OnScreenTarget = OnScreenTarget;\n    /** @internal */\n    class OffScreenTarget extends Target {\n        constructor(system, _viewRect) {\n            super(system);\n            this._viewRect = _viewRect;\n        }\n        get viewRect() { return this._viewRect; }\n        setViewRect(rect, _temp) { this._viewRect.setFrom(rect); }\n    }\n    MockRender.OffScreenTarget = OffScreenTarget;\n    /** @internal */\n    class Builder extends PrimitiveBuilder {\n        constructor(system, options) {\n            super(system, options);\n        }\n    }\n    MockRender.Builder = Builder;\n    class Graphic extends RenderGraphic {\n        constructor() { super(); }\n        dispose() { }\n        collectStatistics(_stats) { }\n    }\n    MockRender.Graphic = Graphic;\n    class List extends Graphic {\n        constructor(graphics) {\n            super();\n            this.graphics = graphics;\n        }\n        dispose() {\n            for (const graphic of this.graphics)\n                dispose(graphic);\n            this.graphics.length = 0;\n        }\n    }\n    MockRender.List = List;\n    class Branch extends Graphic {\n        constructor(branch, transform, options) {\n            super();\n            this.branch = branch;\n            this.transform = transform;\n            this.options = options;\n        }\n        dispose() { this.branch.dispose(); }\n    }\n    MockRender.Branch = Branch;\n    class Batch extends Graphic {\n        constructor(graphic, featureTable, range) {\n            super();\n            this.graphic = graphic;\n            this.featureTable = featureTable;\n            this.range = range;\n        }\n        dispose() {\n            dispose(this.graphic);\n        }\n    }\n    MockRender.Batch = Batch;\n    /** @internal */\n    class Geometry {\n        dispose() { }\n        collectStatistics() { }\n    }\n    MockRender.Geometry = Geometry;\n    /** @internal */\n    class AreaPattern {\n        dispose() { }\n        collectStatistics() { }\n    }\n    MockRender.AreaPattern = AreaPattern;\n    class System extends RenderSystem {\n        get isValid() { return true; }\n        dispose() { }\n        get maxTextureSize() { return 4096; }\n        constructor() { super(); }\n        /** @internal */\n        doIdleWork() { return false; }\n        /** @internal */\n        createTarget(canvas) { return new OnScreenTarget(this, canvas); }\n        /** @internal */\n        createOffscreenTarget(rect) { return new OffScreenTarget(this, rect); }\n        createGraphic(options) {\n            return new Builder(this, options);\n        }\n        createGraphicList(primitives) { return new List(primitives); }\n        createGraphicBranch(branch, transform, options) { return new Branch(branch, transform, options); }\n        createBatch(graphic, features, range) { return new Batch(graphic, features, range); }\n        /** @internal */\n        createMesh(_params) { return new Graphic(); }\n        /** @internal */\n        createPolyline(_params) { return new Graphic(); }\n        /** @internal */\n        createPointString(_params) { return new Graphic(); }\n        /** @internal */\n        createPointCloud(_args, _imodel) { return new Graphic(); }\n        createRenderGraphic() { return new Graphic(); }\n        /** @internal */\n        createMeshGeometry() { return new Geometry(); }\n        /** @internal */\n        createPolylineGeometry() { return new Geometry(); }\n        /** @internal */\n        createPointStringGeometry() { return new Geometry(); }\n        /** @internal */\n        createAreaPattern() { return new AreaPattern(); }\n    }\n    MockRender.System = System;\n    /** An implementation of IModelApp which uses a MockRender.System by default. */\n    class App {\n        static async startup(opts) {\n            opts = opts ? opts : {};\n            opts.renderSys = this.systemFactory();\n            opts.localization = opts.localization ?? new EmptyLocalization();\n            await IModelApp.startup(opts);\n        }\n        static async shutdown() {\n            this.systemFactory = () => App.createDefaultRenderSystem();\n            await IModelApp.shutdown();\n        }\n        static createDefaultRenderSystem() { return new System(); }\n    }\n    App.systemFactory = () => App.createDefaultRenderSystem();\n    MockRender.App = App;\n})(MockRender || (MockRender = {}));\n//# sourceMappingURL=MockRender.js.map",
      "start": 1693508119864,
      "end": 1693508119924,
      "sourcemaps": null
    }
  ]
}
