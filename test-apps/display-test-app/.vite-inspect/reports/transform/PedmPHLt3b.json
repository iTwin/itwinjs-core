{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tile/map/WmtsCapabilities.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Views\n */\nimport { Point2d, Range2d } from \"@itwin/core-geometry\";\nimport { request } from \"../../request/Request\";\nimport { MapCartoRectangle, WmsUtilities } from \"../internal\"; // WmsUtilities needed for getBaseUrl\nvar OwsConstants;\n(function (OwsConstants) {\n    OwsConstants[\"ABSTRACT_XMLTAG\"] = \"ows:Abstract\";\n    OwsConstants[\"ACCESSCONSTRAINTS_XMLTAG\"] = \"ows:AccessConstraints\";\n    OwsConstants[\"ALLOWEDVALUES_XMLTAG\"] = \"ows:AllowedValues\";\n    OwsConstants[\"BOUNDINGBOX_XMLTAG\"] = \"ows:BoundingBox\";\n    OwsConstants[\"CONSTRAINT_XMLTAG\"] = \"ows:Constraint\";\n    OwsConstants[\"DCP_XMLTAG\"] = \"ows:DCP\";\n    OwsConstants[\"FEES_XMLTAG\"] = \"ows:Fees\";\n    OwsConstants[\"GET_XMLTAG\"] = \"ows:Get\";\n    OwsConstants[\"HTTP_XMLTAG\"] = \"ows:HTTP\";\n    OwsConstants[\"IDENTIFIER_XMLTAG\"] = \"ows:Identifier\";\n    OwsConstants[\"KEYWORDS_XMLTAG\"] = \"ows:Keywords\";\n    OwsConstants[\"KEYWORD_XMLTAG\"] = \"ows:Keyword\";\n    OwsConstants[\"LOWERCORNER_XMLTAG\"] = \"ows:LowerCorner\";\n    OwsConstants[\"OPERATION_XMLTAG\"] = \"ows:Operation\";\n    OwsConstants[\"OPERATIONSMETADATA_XMLTAG\"] = \"ows:OperationsMetadata\";\n    OwsConstants[\"POST_XMLTAG\"] = \"ows:Post\";\n    OwsConstants[\"SERVICEIDENTIFICATION_XMLTAG\"] = \"ows:ServiceIdentification\";\n    OwsConstants[\"SERVICETYPE_XMLTAG\"] = \"ows:ServiceType\";\n    OwsConstants[\"SERVICETYPEVERSION_XMLTAG\"] = \"ows:ServiceTypeVersion\";\n    OwsConstants[\"SUPPORTEDCRS_XMLTAG\"] = \"ows:SupportedCRS\";\n    OwsConstants[\"TITLE_XMLTAG\"] = \"ows:Title\";\n    OwsConstants[\"UPPERCORNER_XMLTAG\"] = \"ows:UpperCorner\";\n    OwsConstants[\"VALUE_XMLTAG\"] = \"ows:Value\";\n    OwsConstants[\"WGS84BOUNDINGBOX_XMLTAG\"] = \"ows:WGS84BoundingBox\";\n})(OwsConstants || (OwsConstants = {}));\nvar XmlConstants;\n(function (XmlConstants) {\n    // Operations names\n    XmlConstants[\"GETCAPABILITIES\"] = \"GetCapabilities\";\n    XmlConstants[\"GETTILE\"] = \"GetTile\";\n    XmlConstants[\"GETFEATUREINFO\"] = \"GetFeatureInfo\";\n    XmlConstants[\"MATRIXWIDTH_XMLTAG\"] = \"MatrixWidth\";\n    XmlConstants[\"MATRIXHEIGHT_XMLTAG\"] = \"MatrixHeight\";\n    XmlConstants[\"SCALEDENOMINATOR_XMLTAG\"] = \"ScaleDenominator\";\n    XmlConstants[\"TILEHEIGHT_XMLTAG\"] = \"TileHeight\";\n    XmlConstants[\"TILEMATRIX_XMLTAG\"] = \"TileMatrix\";\n    XmlConstants[\"TILEMATRIXSETLINK_XMLTAG\"] = \"TileMatrixSetLink\";\n    XmlConstants[\"TILEWIDTH_XMLTAG\"] = \"TileWidth\";\n    XmlConstants[\"TOPLEFTCORNER_XMLTAG\"] = \"TopLeftCorner\";\n    XmlConstants[\"WELLKNOWNSCALESET_XMLTAG\"] = \"WellKnownScaleSet\";\n    XmlConstants[\"CONSTRAINT_NAME_FILTER\"] = \"Encoding\";\n    XmlConstants[\"STYLE_ISDEFAULT\"] = \"IsDefault\";\n    XmlConstants[\"XLINK_HREF\"] = \"xlink:href\";\n})(XmlConstants || (XmlConstants = {}));\n/** @internal\n*/\nexport var WmtsConstants;\n(function (WmtsConstants) {\n    WmtsConstants[WmtsConstants[\"GOOGLEMAPS_LEVEL0_SCALE_DENOM\"] = 559082264.0287178] = \"GOOGLEMAPS_LEVEL0_SCALE_DENOM\";\n    WmtsConstants[\"GOOGLEMAPS_COMPATIBLE_WELLKNOWNNAME\"] = \"googlemapscompatible\";\n})(WmtsConstants || (WmtsConstants = {}));\n/**\n * fetch XML from HTTP request\n * @param url server URL to address the request\n * @internal\n */\nasync function getXml(url, credentials) {\n    const options = {\n        timeout: 20000,\n        retryCount: 2,\n        auth: credentials,\n    };\n    return request(url, \"text\", options);\n}\n/**\n * Utility function to extract an element' text content\n * @return An element's text content, default to provided defaultTest value if no text is available.\n * @param url server URL to address the request\n * @internal\n */\nconst getElementTextContent = (elem, qualifiedName, defaultText) => {\n    const tmpElem = elem.getElementsByTagName(qualifiedName);\n    if (tmpElem.length > 0) {\n        return tmpElem[0].textContent ?? defaultText;\n    }\n    else\n        return defaultText;\n};\n/** Encapsulation of the capabilities for an WMTS server\n * @internal\n */\nexport var WmtsCapability;\n(function (WmtsCapability) {\n    class ServiceIdentification {\n        constructor(elem) {\n            this.abstract = getElementTextContent(elem, OwsConstants.ABSTRACT_XMLTAG);\n            this.serviceType = getElementTextContent(elem, OwsConstants.SERVICETYPE_XMLTAG);\n            this.serviceTypeVersion = getElementTextContent(elem, OwsConstants.SERVICETYPEVERSION_XMLTAG);\n            this.title = getElementTextContent(elem, OwsConstants.TITLE_XMLTAG);\n            const keywords = elem.getElementsByTagName(OwsConstants.KEYWORDS_XMLTAG);\n            if (keywords.length > 0) {\n                const keyword = keywords[0].getElementsByTagName(OwsConstants.KEYWORD_XMLTAG);\n                this.keywords = [];\n                for (const keyworkElem of keyword) {\n                    const keyWordText = keyworkElem.textContent;\n                    if (keyWordText)\n                        this.keywords.push(keyWordText);\n                }\n            }\n            this.accessConstraints = getElementTextContent(elem, OwsConstants.ACCESSCONSTRAINTS_XMLTAG);\n            this.fees = getElementTextContent(elem, OwsConstants.FEES_XMLTAG);\n        }\n    }\n    WmtsCapability.ServiceIdentification = ServiceIdentification;\n    class OperationMetadata {\n        get getCapabilities() { return this._getCapabilities; }\n        get getFeatureInfo() { return this._getFeatureInfo; }\n        get getTile() { return this._getTile; }\n        readOperation(op) {\n            const nameAttr = op.attributes.getNamedItem(\"name\");\n            if (!nameAttr)\n                return;\n            if (nameAttr.textContent === XmlConstants.GETCAPABILITIES) {\n                this._getCapabilities = new Operation(op);\n            }\n            else if (nameAttr.textContent === XmlConstants.GETTILE) {\n                this._getTile = new Operation(op);\n            }\n            else if (nameAttr.textContent === XmlConstants.GETFEATUREINFO) {\n                this._getFeatureInfo = new Operation(op);\n            }\n        }\n        constructor(elem) {\n            const operation = elem.getElementsByTagName(OwsConstants.OPERATION_XMLTAG);\n            if (operation.length > 0) {\n                for (const op of operation) {\n                    this.readOperation(op);\n                }\n            }\n        }\n    }\n    WmtsCapability.OperationMetadata = OperationMetadata;\n    class HttpDcp {\n        constructor(elem) {\n            const url = elem.getAttribute(XmlConstants.XLINK_HREF);\n            if (url)\n                this.url = url ?? \"\";\n            const constraint = elem.getElementsByTagName(OwsConstants.CONSTRAINT_XMLTAG);\n            if (constraint.length > 0) {\n                this.constraintName = constraint[0].getAttribute(\"name\") ?? \"\";\n                if (this.constraintName?.endsWith(XmlConstants.CONSTRAINT_NAME_FILTER)) {\n                    const allowedValues = constraint[0].getElementsByTagName(OwsConstants.ALLOWEDVALUES_XMLTAG);\n                    if (allowedValues.length > 0) {\n                        this.encoding = getElementTextContent(allowedValues[0], OwsConstants.VALUE_XMLTAG);\n                    }\n                }\n            }\n        }\n    }\n    WmtsCapability.HttpDcp = HttpDcp;\n    class Operation {\n        get getDcpHttp() { return this._getDcpHttp; }\n        get postDcpHttp() { return this._postDcpHttp; }\n        constructor(elem) {\n            const name = elem.getAttribute(\"name\");\n            if (name)\n                this.name = name;\n            const dcp = elem.getElementsByTagName(OwsConstants.DCP_XMLTAG);\n            if (!dcp || dcp.length === 0)\n                return;\n            const dcpHttp = dcp[0].getElementsByTagName(OwsConstants.HTTP_XMLTAG);\n            if (!dcpHttp || dcpHttp.length === 0)\n                return;\n            const get = dcpHttp[0].getElementsByTagName(OwsConstants.GET_XMLTAG);\n            if (get.length > 0) {\n                this._getDcpHttp = [];\n                for (const getItem of get) {\n                    this._getDcpHttp?.push(new HttpDcp(getItem));\n                }\n            }\n            const post = dcpHttp[0].getElementsByTagName(OwsConstants.POST_XMLTAG);\n            if (post.length > 0) {\n                this._postDcpHttp = [];\n                for (const postItem of post) {\n                    this._postDcpHttp?.push(new HttpDcp(postItem));\n                }\n            }\n        }\n    }\n    WmtsCapability.Operation = Operation;\n    class Contents {\n        constructor(elem) {\n            this.layers = [];\n            this.tileMatrixSets = [];\n            // Layers\n            const layer = elem.getElementsByTagName(\"Layer\");\n            if (layer) {\n                for (const layerElem of layer)\n                    this.layers.push(new Layer(layerElem));\n            }\n            // TileMatrixSet\n            const tms = elem.querySelectorAll(\"Contents > TileMatrixSet\");\n            if (tms) {\n                for (const tmsElem of tms)\n                    this.tileMatrixSets.push(new TileMatrixSet(tmsElem));\n            }\n        }\n        getGoogleMapsCompatibleTileMatrixSet() {\n            const googleMapsTms = [];\n            this.tileMatrixSets.forEach((tms) => {\n                if (tms.wellKnownScaleSet?.toLowerCase().includes(WmtsConstants.GOOGLEMAPS_COMPATIBLE_WELLKNOWNNAME))\n                    googleMapsTms.push(tms);\n                // In case wellKnownScaleSet was not been set properly, infer from scaleDenominator\n                // Note: some servers are quite inaccurate in their scale values, hence I used a delta value of 1.\n                else if (tms.tileMatrix.length > 0\n                    && Math.abs(tms.tileMatrix[0].scaleDenominator - WmtsConstants.GOOGLEMAPS_LEVEL0_SCALE_DENOM) < 1\n                    && (tms.supportedCrs.includes(\"3857\") || tms.supportedCrs.includes(\"900913\")))\n                    googleMapsTms.push(tms);\n            });\n            return googleMapsTms;\n        }\n        getEpsg4326CompatibleTileMatrixSet() {\n            return this.tileMatrixSets.filter((tms) => tms.supportedCrs.includes(\"4326\"));\n        }\n    }\n    WmtsCapability.Contents = Contents;\n    class Style {\n        // TODO: LegendURL\n        constructor(elem) {\n            this.isDefault = false;\n            if (!elem)\n                return;\n            const isDefault = elem.getAttribute(\"isDefault\");\n            if (isDefault)\n                this.isDefault = isDefault.toLowerCase() === \"true\";\n            this.title = getElementTextContent(elem, OwsConstants.TITLE_XMLTAG);\n            this.identifier = getElementTextContent(elem, OwsConstants.IDENTIFIER_XMLTAG);\n        }\n    }\n    WmtsCapability.Style = Style;\n    class BoundingBox {\n        constructor(elem) {\n            this.crs = elem.getAttribute(\"crs\") ?? undefined;\n            const lowerCorner = getElementTextContent(elem, OwsConstants.LOWERCORNER_XMLTAG);\n            const upperCorner = getElementTextContent(elem, OwsConstants.UPPERCORNER_XMLTAG);\n            if (lowerCorner && upperCorner) {\n                const lowerCornerArray = lowerCorner?.split(\" \").map((x) => +x);\n                const upperCornerArray = upperCorner?.split(\" \").map((x) => +x);\n                if (lowerCornerArray && lowerCornerArray.length === 2 && upperCornerArray && upperCornerArray.length === 2)\n                    this.range = Range2d.createXYXY(lowerCornerArray[0], lowerCornerArray[1], upperCornerArray[0], upperCornerArray[1]);\n            }\n        }\n    }\n    WmtsCapability.BoundingBox = BoundingBox;\n    class TileMatrixSetLimits {\n        constructor(elem) {\n            this.tileMatrix = getElementTextContent(elem, \"TileMatrix\");\n            const minTileRow = getElementTextContent(elem, \"MinTileRow\");\n            const maxTileRow = getElementTextContent(elem, \"MaxTileRow\");\n            const minTileCol = getElementTextContent(elem, \"MinTileCol\");\n            const maxTileCol = getElementTextContent(elem, \"MaxTileCol\");\n            if (minTileRow !== undefined && maxTileRow !== undefined && minTileCol !== undefined && maxTileCol)\n                this.limits = Range2d.createXYXY(Number(minTileCol), Number(minTileRow), Number(maxTileCol), Number(maxTileRow));\n        }\n    }\n    WmtsCapability.TileMatrixSetLimits = TileMatrixSetLimits;\n    class TileMatrixSetLink {\n        constructor(elem) {\n            this.tileMatrixSetLimits = new Array();\n            this.tileMatrixSet = getElementTextContent(elem, \"TileMatrixSet\", \"\");\n            const tileMatrixLimitsRoot = elem.getElementsByTagName(\"TileMatrixSetLimits\");\n            if (tileMatrixLimitsRoot.length > 0) {\n                const tileMatrixLimits = tileMatrixLimitsRoot[0].getElementsByTagName(\"TileMatrixSetLimits\");\n                for (const tmsl of tileMatrixLimits) {\n                    this.tileMatrixSetLimits.push(new TileMatrixSetLimits(tmsl));\n                }\n            }\n        }\n    }\n    WmtsCapability.TileMatrixSetLink = TileMatrixSetLink;\n    class TileMatrixSet {\n        constructor(elem) {\n            this.tileMatrix = [];\n            const identifier = getElementTextContent(elem, OwsConstants.IDENTIFIER_XMLTAG);\n            if (identifier)\n                this.identifier = identifier;\n            else\n                throw new Error(\"No Identifier found.\");\n            this.title = getElementTextContent(elem, OwsConstants.TITLE_XMLTAG);\n            this.abstract = getElementTextContent(elem, OwsConstants.ABSTRACT_XMLTAG);\n            const supportedCrs = getElementTextContent(elem, OwsConstants.SUPPORTEDCRS_XMLTAG);\n            if (supportedCrs)\n                this.supportedCrs = supportedCrs;\n            else\n                throw new Error(\"No supported CRS found.\");\n            this.wellKnownScaleSet = getElementTextContent(elem, XmlConstants.WELLKNOWNSCALESET_XMLTAG, \"\");\n            // TileMatrix:\n            // TileMatrix is mandatory on TileMatrixSet, if it doesn't exists, something is OFF with the capability.\n            const tileMatrix = elem.getElementsByTagName(XmlConstants.TILEMATRIX_XMLTAG);\n            if (tileMatrix.length === 0)\n                throw new Error(\"No matrix set link found for WMTS layer\");\n            for (const tm of tileMatrix) {\n                this.tileMatrix.push(new TileMatrix(tm));\n            }\n        }\n    }\n    WmtsCapability.TileMatrixSet = TileMatrixSet;\n    class TileMatrix {\n        constructor(elem) {\n            const identifier = getElementTextContent(elem, OwsConstants.IDENTIFIER_XMLTAG, \"\");\n            if (identifier)\n                this.identifier = identifier;\n            else\n                throw new Error(\"No Identifier found.\");\n            this.title = getElementTextContent(elem, OwsConstants.TITLE_XMLTAG);\n            this.abstract = getElementTextContent(elem, OwsConstants.ABSTRACT_XMLTAG);\n            // Scale denominator\n            const scaleDenom = getElementTextContent(elem, XmlConstants.SCALEDENOMINATOR_XMLTAG, \"\");\n            if (!scaleDenom)\n                throw new Error(\"No scale denominator found on TileMatrix.\");\n            this.scaleDenominator = +scaleDenom;\n            // Top left corner\n            const topLeftCorner = getElementTextContent(elem, XmlConstants.TOPLEFTCORNER_XMLTAG, \"\")?.split(\" \").map((x) => +x);\n            if (topLeftCorner?.length !== 2)\n                throw new Error(\"No TopLeftCorner found on TileMatrix.\");\n            this.topLeftCorner = Point2d.create(topLeftCorner[0], topLeftCorner[1]);\n            // Tile Width\n            const tileWidth = getElementTextContent(elem, XmlConstants.TILEWIDTH_XMLTAG);\n            if (!tileWidth)\n                throw new Error(\"No tile width found on TileMatrix.\");\n            this.tileWidth = +tileWidth;\n            // Tile Height\n            const tileHeight = getElementTextContent(elem, XmlConstants.TILEHEIGHT_XMLTAG);\n            if (!tileHeight)\n                throw new Error(\"No tile height found on TileMatrix.\");\n            this.tileHeight = +tileHeight;\n            // Matrix Width\n            const matrixWidth = getElementTextContent(elem, XmlConstants.MATRIXWIDTH_XMLTAG);\n            if (!matrixWidth)\n                throw new Error(\"No tile width found on TileMatrix.\");\n            this.matrixWidth = +matrixWidth;\n            // Matrix Height\n            const matrixHeight = getElementTextContent(elem, XmlConstants.MATRIXHEIGHT_XMLTAG);\n            if (!matrixHeight)\n                throw new Error(\"No tile height found on TileMatrix.\");\n            this.matrixHeight = +matrixHeight;\n        }\n    }\n    WmtsCapability.TileMatrix = TileMatrix;\n    class Layer {\n        constructor(elem) {\n            this.styles = [];\n            this.tileMatrixSetLinks = [];\n            const identifier = getElementTextContent(elem, OwsConstants.IDENTIFIER_XMLTAG, \"\");\n            if (identifier)\n                this.identifier = identifier;\n            else\n                throw new Error(\"No Identifier found.\");\n            this.title = getElementTextContent(elem, OwsConstants.TITLE_XMLTAG);\n            this.format = getElementTextContent(elem, \"Format\");\n            // BoundingBox\n            const boundingBox = elem.getElementsByTagName(OwsConstants.BOUNDINGBOX_XMLTAG);\n            if (boundingBox.length > 0)\n                this.boundingBox = new BoundingBox(boundingBox[0]);\n            let lowerCornerArray, upperCornerArray;\n            const bbox = elem.getElementsByTagName(OwsConstants.WGS84BOUNDINGBOX_XMLTAG);\n            if (bbox.length > 0) {\n                lowerCornerArray = getElementTextContent(bbox[0], OwsConstants.LOWERCORNER_XMLTAG)?.split(\" \").map((x) => +x);\n                upperCornerArray = getElementTextContent(bbox[0], OwsConstants.UPPERCORNER_XMLTAG)?.split(\" \").map((x) => +x);\n            }\n            if (lowerCornerArray?.length === 2 && upperCornerArray?.length === 2)\n                this.wsg84BoundingBox = MapCartoRectangle.fromDegrees(lowerCornerArray[0], lowerCornerArray[1], upperCornerArray[0], upperCornerArray[1]);\n            // If we could not initialized WSG84 bounding box, attempt to initialized it from Bounding Box\n            if (!this.wsg84BoundingBox && (this.boundingBox?.crs?.includes(\"EPSG:4326\") || this.boundingBox?.crs?.includes(\"CRS:84\"))) {\n                const range = this.boundingBox.range;\n                if (range)\n                    this.wsg84BoundingBox = MapCartoRectangle.fromDegrees(range.low.x, range.low.y, range.high.x, range.high.y);\n                else\n                    this.wsg84BoundingBox = MapCartoRectangle.createMaximum();\n            }\n            // Style\n            const style = elem.getElementsByTagName(\"Style\");\n            if (style.length > 0) {\n                for (const styleElem of style)\n                    this.styles.push(new Style(styleElem));\n            }\n            // TileMatrixSetLink\n            // TileMatrixSetLink is mandatory on Layer, if it doesn't exists, something is OFF with the capability.\n            const tileMatrixSetLink = elem.getElementsByTagName(XmlConstants.TILEMATRIXSETLINK_XMLTAG);\n            if (tileMatrixSetLink.length === 0)\n                throw new Error(\"No matrix set link found for WMTS layer\");\n            for (const tmsl of tileMatrixSetLink)\n                this.tileMatrixSetLinks.push(new TileMatrixSetLink(tmsl));\n        }\n    }\n    WmtsCapability.Layer = Layer;\n})(WmtsCapability || (WmtsCapability = {}));\n/** @internal */\nclass WmtsCapabilities {\n    constructor(xmlDoc) {\n        const capabilities = xmlDoc.getElementsByTagName(\"Capabilities\");\n        if (capabilities.length !== 0) {\n            const capability = capabilities[0];\n            this.version = capability.getAttribute(\"version\") ?? undefined;\n            // Service Identification\n            const serviceIdentification = capability.getElementsByTagName(OwsConstants.SERVICEIDENTIFICATION_XMLTAG);\n            if (serviceIdentification.length > 0)\n                this.serviceIdentification = new WmtsCapability.ServiceIdentification(serviceIdentification[0]);\n            // Operations metadata\n            const operationsMetadata = capability.getElementsByTagName(OwsConstants.OPERATIONSMETADATA_XMLTAG);\n            if (operationsMetadata.length > 0)\n                this.operationsMetadata = new WmtsCapability.OperationMetadata(operationsMetadata[0]);\n            // Contents\n            const content = capability.getElementsByTagName(\"Contents\");\n            if (content.length > 0)\n                this.contents = new WmtsCapability.Contents(content[0]);\n        }\n    }\n    static createFromXml(xmlCapabilities) {\n        const parser = new DOMParser();\n        const xmlDoc = parser.parseFromString(xmlCapabilities, \"text/xml\");\n        return new WmtsCapabilities(xmlDoc);\n    }\n    static async create(url, credentials, ignoreCache) {\n        if (!ignoreCache) {\n            const cached = WmtsCapabilities._capabilitiesCache.get(url);\n            if (cached !== undefined)\n                return cached;\n        }\n        const xmlCapabilities = await getXml(`${WmsUtilities.getBaseUrl(url)}?request=GetCapabilities&service=WMTS`, credentials);\n        if (!xmlCapabilities)\n            return undefined;\n        const capabilities = WmtsCapabilities.createFromXml(xmlCapabilities);\n        if (capabilities)\n            WmtsCapabilities._capabilitiesCache.set(url, capabilities);\n        return capabilities;\n    }\n}\nWmtsCapabilities._capabilitiesCache = new Map();\nexport { WmtsCapabilities };\n//# sourceMappingURL=WmtsCapabilities.js.map",
      "start": 1693508121809,
      "end": 1693508121997,
      "sourcemaps": null
    }
  ]
}
