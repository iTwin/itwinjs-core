{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/orbitgt/lib/esm/system/storage/PageCachedFile.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module OrbitGT\n */\nimport { ABuffer } from \"../buffer/ABuffer\";\nimport { AList } from \"../collection/AList\";\nimport { StringMap } from \"../collection/StringMap\";\nimport { ALong } from \"../runtime/ALong\";\nimport { ASystem } from \"../runtime/ASystem\";\nimport { Message } from \"../runtime/Message\";\nimport { CacheList } from \"./CacheList\";\nimport { FileContent } from \"./FileContent\";\nimport { FileRange } from \"./FileRange\";\nimport { FileStorage } from \"./FileStorage\";\n/**\n * Class PageCachedFile defines a paged content cache of a single file.\n */\n/** @internal */\nexport class PageCachedFile extends FileStorage {\n    /**\n     * Create a new cached file.\n     * @param fileStorage the underlying file storage.\n     * @param fileName the name of the file to cache.\n     * @param fileSize the length of the file to cache.\n     * @param pageSize the byte size of a cache page (common sizes are 32768, 65536, 131072 or 262144).\n     * @param maxPageCount the maximum number of pages to cache (the oldest pages are purged when the cache is full).\n     */\n    constructor(fileStorage, fileName, fileSize, pageSize, maxPageCount) {\n        super();\n        this._fileStorage = fileStorage;\n        this._fileName = fileName;\n        this._fileSize = fileSize;\n        this._pageSize = pageSize;\n        this._pageCount = fileSize.subInt(1).divInt(this._pageSize).addInt(1).toInt();\n        this._contentCache = new CacheList(maxPageCount);\n        this._requestCount = 0;\n        this._requestSize = 0;\n    }\n    /**\n     * FileStorage method.\n     */\n    close() {\n        this._fileStorage.close(); // deep close\n    }\n    /**\n     * FileStorage method.\n     */\n    async getFileLength(fileName) {\n        return this._fileSize;\n    }\n    /**\n     * FileStorage method.\n     */\n    async readFileParts(fileName, ranges) {\n        /* Define the set of pages we need to fulfill the request */\n        const pageMap = new StringMap();\n        /* Create a list of missing pages */\n        const missingPages = new AList();\n        const missingKeys = new AList();\n        for (let r = 0; r < ranges.size(); r++) {\n            /* Scan the needed pages of the next range */\n            const range = ranges.get(r);\n            const page0 = range.offset.divInt(this._pageSize).toInt();\n            const page1 = range.offset.addInt(range.size - 1).divInt(this._pageSize).toInt() + 1; // exclusive\n            for (let i = page0; i < page1; i++) {\n                /* Try to get the page from the cache */\n                const pageKey = (`${i}`);\n                const page = this._contentCache.findEntry(pageKey);\n                if (page == null) {\n                    /* Do not request the same page twice */\n                    if (missingKeys.contains(pageKey) == false) {\n                        /* Add a request to read the missing page */\n                        const pageOffset0 = ALong.fromInt(this._pageSize).mulInt(i);\n                        const pageOffset1 = ALong.min(pageOffset0.addInt(this._pageSize), this._fileSize);\n                        const pageSize = pageOffset1.sub(pageOffset0).toInt();\n                        missingPages.add(new FileRange(pageOffset0, pageSize));\n                        missingKeys.add(pageKey);\n                    }\n                }\n                else {\n                    /* Keep */\n                    pageMap.set(pageKey, page);\n                }\n            }\n        }\n        /* Do we have to load missing pages? */\n        if (missingPages.size() > 0) {\n            /* Load all missing pages with one call to the storage */\n            Message.log(`Requesting ${missingPages.size()} missing cache pages for '${this._fileName}'`);\n            const loadedPages = await this._fileStorage.readFileParts(fileName, missingPages);\n            /* Add to the cache for reuse */\n            for (let i = 0; i < loadedPages.size(); i++) {\n                const pageKey = missingKeys.get(i);\n                const pageContent = loadedPages.get(i);\n                this._contentCache.addEntry(pageKey, pageContent.content);\n                pageMap.set(pageKey, pageContent.content);\n            }\n        }\n        /* Create the responses from the cached content */\n        const responseList = new AList();\n        for (let r = 0; r < ranges.size(); r++) {\n            /* Create the response for the next range */\n            const range = ranges.get(r);\n            const rangeExtent = range.offset.addInt(range.size);\n            const response = new ABuffer(range.size);\n            let responseOffset = 0;\n            this._requestCount++;\n            this._requestSize += range.size;\n            /* Scan the needed pages */\n            const page0 = range.offset.divInt(this._pageSize).toInt();\n            const page1 = range.offset.addInt(range.size - 1).divInt(this._pageSize).toInt() + 1; // exclusive\n            for (let i = page0; i < page1; i++) {\n                /* Get the next page from the cache */\n                const pageKey = (`${i}`);\n                const page = pageMap.get(pageKey);\n                ASystem.assertNot(page == null, `Missing cache page ${pageKey}`);\n                /* Get the extent of the page */\n                const pageOffset0 = ALong.fromInt(this._pageSize).mulInt(i);\n                const pageOffset1 = ALong.min(pageOffset0.addInt(this._pageSize), this._fileSize);\n                /* Copy the overlapping part of the page to the response */\n                const currentOffset = range.offset.addInt(responseOffset);\n                const copyOffset = currentOffset.sub(pageOffset0).toInt();\n                const copySize = ALong.min(pageOffset1, rangeExtent).sub(currentOffset).toInt();\n                ABuffer.arrayCopy(page, copyOffset, response, responseOffset, copySize);\n                responseOffset += copySize;\n            }\n            /* Add the response to the list */\n            ASystem.assertNot(responseOffset != range.size, `Expected ${range.size} response size, not ${responseOffset}`);\n            responseList.add(new FileContent(range.offset, response));\n        }\n        return responseList;\n    }\n    /**\n     * FileStorage method.\n     */\n    async readFilePart(fileName, offset, size) {\n        const ranges = new AList();\n        ranges.add(new FileRange(offset, size));\n        const reponses = await this.readFileParts(fileName, ranges);\n        const reponse = reponses.get(0);\n        return reponse.content;\n    }\n    /**\n     * FileStorage method.\n     */\n    printStatistics(clear) {\n        Message.log(`Page cache of file '${this._fileName}':`);\n        Message.log(`Request count is ${this._requestCount}`);\n        Message.log(`Request size is ${this._requestSize}`);\n        Message.log(`Cache hit count is ${this._contentCache.hitCount}`);\n        Message.log(`Cache miss count is ${this._contentCache.missCount}`);\n        if (clear)\n            this._contentCache.hitCount = 0;\n        if (clear)\n            this._contentCache.missCount = 0;\n        this._fileStorage.printStatistics(clear);\n    }\n}\n//# sourceMappingURL=PageCachedFile.js.map",
      "start": 1693508126093,
      "end": 1693508126240,
      "sourcemaps": null
    }
  ]
}
