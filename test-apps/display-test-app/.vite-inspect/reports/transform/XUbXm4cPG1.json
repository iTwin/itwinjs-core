{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/polyface/multiclip/BuildAverageNormalsContext.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Polyface\n */\nimport { Vector3d } from \"../../geometry3d/Point3dVector3d\";\nimport { PolygonOps } from \"../../geometry3d/PolygonOps\";\nimport { Geometry } from \"../../Geometry\";\nimport { GrowableXYZArray } from \"../../geometry3d/GrowableXYZArray\";\n/**\n * Normal vector with area (or other numeric) and source index\n * @internal\n */\nclass IndexedAreaAndNormal {\n    constructor(index, area, normal) {\n        this.index = index;\n        this.area = area;\n        this.normal = normal;\n    }\n    addWeightedNormal(weight, normal) {\n        this.area += weight;\n        this.normal.addScaledInPlace(normal, weight);\n    }\n    divideNormalByArea() {\n        this.normal.scaleInPlace(1.0 / this.area);\n    }\n}\n/**\n * index data for a single sector of some facet.\n * @internal\n */\nclass SectorData {\n    constructor(facetData, sectorIndex, vertexIndex) {\n        this.facetData = facetData;\n        this.sectorClusterData = undefined;\n        this.sectorIndex = sectorIndex;\n        this.vertexIndex = vertexIndex;\n    }\n    static cbSectorSort(left, right) { return left.sectorIndex - right.sectorIndex; }\n    static cbVertexSort(left, right) { return left.vertexIndex - right.vertexIndex; }\n    static pushToArray(data, facetData, sectorIndex, vertexIndex) {\n        data.push(new SectorData(facetData, sectorIndex, vertexIndex));\n    }\n}\n/**\n * Helper context for normal averaging.\n * All methods are static.\n * @internal\n */\nexport class BuildAverageNormalsContext {\n    /**\n     * * At each vertex of the mesh\n     *   * Find clusters of almost parallel normals\n     *   * Compute simple average of those normals\n     *   * Index to the averages\n     * * For typical meshes, this correctly clusters adjacent normals.\n     * * One cam imagine a vertex with multiple \"smooth cone-like\" sets of incident facets such that averaging occurs among two nonadjacent cones.  But this does not seem to be a problem in practice.\n     * @param polyface polyface to update.\n     * @param toleranceAngle averaging is done between normals up to this angle.\n     */\n    static buildFastAverageNormals(polyface, toleranceAngle) {\n        // We ASSUME that the visitor order matches index order in polyface.data .....\n        const visitor = polyface.createVisitor(0);\n        const defaultNormal = Vector3d.create(0, 0, 1);\n        const smallArea = Geometry.smallMetricDistanceSquared; // I DO NOT LIKE THIS TOLERANCE\n        const sectors = [];\n        let facetIndex = 0;\n        let sectorIndex = 0;\n        // create one IndexedAreaNormal structure for each facet.\n        // At each sector of each face, notate (a) IndexedAreaNormal of the facet, (b) the sector index, (c) the point index.\n        while (visitor.moveToNextFacet()) {\n            const facetNormal = PolygonOps.areaNormalGo(visitor.point);\n            let area = facetNormal.magnitude();\n            if (area < smallArea) {\n                facetNormal.setFromVector3d(defaultNormal);\n                area = 0.0;\n            }\n            else {\n                facetNormal.scaleInPlace(1.0 / area);\n            }\n            const facetData = new IndexedAreaAndNormal(facetIndex++, area, facetNormal);\n            for (let i = 0; i < visitor.pointCount; i++) {\n                SectorData.pushToArray(sectors, facetData, sectorIndex++, visitor.clientPointIndex(i));\n            }\n        }\n        // Sort by the vertex index so all the sectors around each vertex are clustered . .\n        sectors.sort((left, right) => SectorData.cbVertexSort(left, right));\n        // Walk the sectors around each vertex .  ..\n        // For each unassigned sector\n        //     walk to further sectors of the same vertex with near-parallel normals, accumulating average normal.\n        //     notate all sectors in the cluster with the averaged-normal structure.\n        const clusters = [];\n        let toleranceRadians = toleranceAngle.radians;\n        if (toleranceRadians < 0.0001)\n            toleranceRadians = 0.0001;\n        let clusterIndex = 0;\n        for (let baseSectorIndex = 0; baseSectorIndex < sectors.length; baseSectorIndex++) {\n            const baseData = sectors[baseSectorIndex];\n            const vertexIndex = baseData.vertexIndex;\n            const baseFacetData = baseData.facetData;\n            if (baseData.sectorClusterData === undefined) {\n                const clusterNormal = new IndexedAreaAndNormal(clusterIndex++, 0.0, Vector3d.createZero());\n                clusters.push(clusterNormal);\n                // Accumulate with equal weights . . .\n                clusterNormal.addWeightedNormal(1.0, baseData.facetData.normal.clone());\n                for (let candidateSectorIndex = baseSectorIndex; candidateSectorIndex < sectors.length; candidateSectorIndex++) {\n                    const candidateSector = sectors[candidateSectorIndex];\n                    if (candidateSector.vertexIndex !== vertexIndex)\n                        break;\n                    if (candidateSector.facetData.normal.angleTo(baseFacetData.normal).radians > toleranceRadians)\n                        continue;\n                    if (candidateSector.sectorClusterData === undefined) {\n                        clusterNormal.addWeightedNormal(1.0, candidateSector.facetData.normal);\n                        candidateSector.sectorClusterData = clusterNormal;\n                    }\n                }\n            }\n        }\n        // Resort by original sector index.\n        sectors.sort((left, right) => SectorData.cbSectorSort(left, right));\n        // normalize the sums and emplace in the facets  . . .\n        polyface.data.normalIndex = [];\n        polyface.data.normal = new GrowableXYZArray(sectors.length);\n        for (const cluster of clusters) {\n            cluster.divideNormalByArea();\n            cluster.index = polyface.data.normal.length;\n            polyface.data.normal.push(cluster.normal);\n        }\n        // emplace the indices\n        for (const sector of sectors) {\n            polyface.data.normalIndex.push(sector.sectorClusterData.index);\n        }\n    }\n    /**\n     * Set up indexed normals with one normal in the plane of each facet of the mesh.\n     * @param polyface mesh to modify\n     */\n    static buildPerFaceNormals(polyface) {\n        const visitor = polyface.createVisitor(0);\n        const facetNormal = Vector3d.create(0, 0, 1);\n        const defaultNormal = Vector3d.create(0, 0, 1);\n        // polyface.data.clearNormals();\n        const newNormals = new GrowableXYZArray(polyface.faceCount);\n        const newIndices = [];\n        while (visitor.moveToNextFacet()) {\n            const thisNormalIndex = newNormals.length;\n            if (PolygonOps.unitNormal(visitor.point, facetNormal))\n                newNormals.push(facetNormal);\n            else\n                newNormals.push(defaultNormal);\n            for (let i = 0; i < visitor.pointCount; i++)\n                newIndices.push(thisNormalIndex);\n        }\n        polyface.data.normalIndex = newIndices;\n        polyface.data.normal = newNormals;\n    }\n}\n//# sourceMappingURL=BuildAverageNormalsContext.js.map",
      "start": 1693508125506,
      "end": 1693508125606,
      "sourcemaps": null
    }
  ]
}
