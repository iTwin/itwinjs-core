{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/geometry3d/Range.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module CartesianGeometry\n */\nimport { AxisIndex, Geometry } from \"../Geometry\";\nimport { Matrix3d } from \"./Matrix3d\";\nimport { Point2d } from \"./Point2dVector2d\";\nimport { Point3d } from \"./Point3dVector3d\";\nimport { PointStreamRangeCollector, VariantPointDataStream } from \"./PointStreaming\";\nimport { Transform } from \"./Transform\";\n// allow _EXTREME_POSITIVE and _EXTREME_NEGATIVE\n/* eslint-disable @typescript-eslint/naming-convention */\n/**\n * Base class for Range1d, Range2d, Range3d.\n * @public\n */\nclass RangeBase {\n    /** Return 0 if high<= low, otherwise `1/(high-low)` for use in fractionalizing */\n    static npcScaleFactor(low, high) {\n        return (high <= low) ? 0.0 : 1.0 / (high - low);\n    }\n    /** Return true if x is outside the range `[_EXTREME_NEGATIVE, _EXTREME_POSITIVE]' */\n    static isExtremeValue(x) {\n        return Math.abs(x) >= RangeBase._EXTREME_POSITIVE;\n    }\n    /** Return true if any x or y or z is outside the range `[_EXTREME_NEGATIVE, _EXTREME_POSITIVE]' */\n    static isExtremePoint3d(xyz) {\n        return RangeBase.isExtremeValue(xyz.x) || RangeBase.isExtremeValue(xyz.y) || RangeBase.isExtremeValue(xyz.z);\n    }\n    /** Return true if either of x,y is outside the range `[_EXTREME_NEGATIVE, _EXTREME_POSITIVE]' */\n    static isExtremePoint2d(xy) {\n        return RangeBase.isExtremeValue(xy.x) || RangeBase.isExtremeValue(xy.y);\n    }\n    /**\n     * Return the min absolute distance from any point of `[lowA,highA]' to any point of `[lowB,highB]'.\n     * * Both low,high pairs have order expectations:  The condition `high < low` means null interval.\n     * * If there is interval overlap, the distance is zero.\n     * @param lowA low of interval A\n     * @param highA high of interval A\n     * @param lowB low of interval B\n     * @param highB high of interval B\n     */\n    static rangeToRangeAbsoluteDistance(lowA, highA, lowB, highB) {\n        if (highA < lowA)\n            return RangeBase._EXTREME_POSITIVE;\n        if (highB < lowB)\n            return RangeBase._EXTREME_POSITIVE;\n        if (highB < lowA)\n            return lowA - highB;\n        if (highB <= highA)\n            return 0.0;\n        if (lowB <= highA)\n            return 0.0;\n        return lowB - highA;\n    }\n    /**\n     * Given a coordinate and pair of range limits, return the smallest distance to the range.\n     * * This is zero for any point inside the range\n     * * This is _EXTREME_POSITIVE if the range limits are inverted\n     * * Otherwise (i.e. x is outside a finite range) the distance to the near endpoint.\n     */\n    static coordinateToRangeAbsoluteDistance(x, low, high) {\n        if (high < low)\n            return RangeBase._EXTREME_POSITIVE;\n        if (x < low)\n            return low - x;\n        if (x > high)\n            return x - high;\n        return 0.0;\n    }\n    /**\n     * If a > 0, return (extrapolationFactor * a); otherwise return defaultValue\n     * @param q\n     * @param factor multiplier for positive q values.\n     */\n    static multiplyIfPositive(q, factor, defaultValue = 0.0) {\n        return q > 0 ? factor * q : defaultValue;\n    }\n}\n/** Number considered impossibly large possibly for a coordinate in a range. */\nRangeBase._EXTREME_POSITIVE = 1.0e200;\n/** Number considered to be impossibly negative for a coordinate in a range. */\nRangeBase._EXTREME_NEGATIVE = -1.0e200;\nexport { RangeBase };\n/**\n * Axis aligned range in 3D.\n * * member `low` contains minimum coordinate of range box\n * * member  `high` contains maximum coordinate of range box\n * * The range is considered null (empty) if any low member is larger than its high counterpart.\n * @public\n */\nexport class Range3d extends RangeBase {\n    /** Set this transform to values that indicate it has no geometric contents. */\n    setNull() {\n        this.low.x = RangeBase._EXTREME_POSITIVE;\n        this.low.y = RangeBase._EXTREME_POSITIVE;\n        this.low.z = RangeBase._EXTREME_POSITIVE;\n        this.high.x = RangeBase._EXTREME_NEGATIVE;\n        this.high.y = RangeBase._EXTREME_NEGATIVE;\n        this.high.z = RangeBase._EXTREME_NEGATIVE;\n    }\n    /** Freeze this instance (and its members) so it is read-only */\n    freeze() {\n        this.low.freeze();\n        this.high.freeze();\n        return Object.freeze(this);\n    }\n    /** Flatten the low and high coordinates of any json object with low.x .. high.z into an array of 6 doubles */\n    static toFloat64Array(val) {\n        return Float64Array.of(val.low.x, val.low.y, val.low.z, val.high.x, val.high.y, val.high.z);\n    }\n    /** Flatten the low and high coordinates of this into an array of 6 doubles */\n    toFloat64Array() {\n        return Range3d.toFloat64Array(this);\n    }\n    /**\n     * Construct a Range3d from an array of double-precision values\n     * @param f64 the array, which should contain exactly 6 values in this order: lowX, lowY, lowZ, highX, highY, highZ\n     * @return a new Range3d object\n     */\n    static fromFloat64Array(f64) {\n        if (f64.length !== 6)\n            throw new Error(\"invalid array\");\n        return new this(f64[0], f64[1], f64[2], f64[3], f64[4], f64[5]);\n    }\n    /**\n     * Construct a Range3d from an un-typed array. This mostly useful when interpreting ECSQL query results of\n     * the 'blob' type, where you know that that result is a Range3d.\n     * @param buffer untyped array\n     * @return a new Range3d object\n     */\n    static fromArrayBuffer(buffer) {\n        return this.fromFloat64Array(new Float64Array(buffer));\n    }\n    // explicit ctor - no enforcement of value relationships\n    constructor(lowX = RangeBase._EXTREME_POSITIVE, lowY = RangeBase._EXTREME_POSITIVE, lowZ = RangeBase._EXTREME_POSITIVE, highX = RangeBase._EXTREME_NEGATIVE, highY = RangeBase._EXTREME_NEGATIVE, highZ = RangeBase._EXTREME_NEGATIVE) {\n        super();\n        this.low = Point3d.create(lowX, lowY, lowZ);\n        this.high = Point3d.create(highX, highY, highZ);\n    }\n    /** Returns true if this and other have equal low and high parts, or both are null ranges. */\n    isAlmostEqual(other, tol) {\n        return (this.low.isAlmostEqual(other.low, tol) && this.high.isAlmostEqual(other.high, tol))\n            || (this.isNull && other.isNull);\n    }\n    /** Copy low and high values from other. */\n    setFrom(other) {\n        this.low.setFrom(other.low);\n        this.high.setFrom(other.high);\n    }\n    /** Return a new Range3d copied from a range or derived type */\n    static createFrom(other, result) {\n        if (result) {\n            result.setFrom(other);\n            return result;\n        }\n        return this.createXYZXYZOrCorrectToNull(other.low.x, other.low.y, other.low.z, other.high.x, other.high.y, other.high.z, result);\n    }\n    /**\n     * Set this range (in place) from json such as\n     * * key-value pairs: `{low:[1,2,3], high:[4,5,6]}`\n     * * array of points: `[[1,2,3],[9,3,4],[-2,1,3] ...]`\n     * * Lowest level points can be `[1,2,3]` or `{x:1,y:2,z:3}`\n     */\n    setFromJSON(json) {\n        if (!json)\n            return;\n        this.setNull();\n        if (Array.isArray(json)) {\n            const point = Point3d.create();\n            for (const value of json) {\n                point.setFromJSON(value);\n                this.extendPoint(point);\n            }\n            return;\n        }\n        const low = Point3d.fromJSON(json.low);\n        const high = Point3d.fromJSON(json.high);\n        if (!RangeBase.isExtremePoint3d(low) && !RangeBase.isExtremePoint3d(high)) {\n            this.extendPoint(low);\n            this.extendPoint(high);\n        }\n    }\n    /**\n     * Return a JSON object `{low: ... , high: ...}`\n     * with points formatted by `Point3d.toJSON()`\n     */\n    toJSON() {\n        return { low: this.low.toJSON(), high: this.high.toJSON() };\n    }\n    /** Use `setFromJSON` to parse `json` into a new Range3d instance. */\n    static fromJSON(json) {\n        const result = new this();\n        result.setFromJSON(json);\n        return result;\n    }\n    // internal use only -- directly set all coordinates, test only if directed.\n    setDirect(xA, yA, zA, xB, yB, zB, correctToNull) {\n        this.low.x = xA;\n        this.low.y = yA;\n        this.low.z = zA;\n        this.high.x = xB;\n        this.high.y = yB;\n        this.high.z = zB;\n        if (correctToNull) {\n            if (this.low.x > this.high.x\n                || this.low.y > this.high.y\n                || this.low.z > this.high.z)\n                this.setNull();\n        }\n    }\n    /** Return a copy */\n    clone(result) {\n        result = result ? result : new this.constructor();\n        result.setDirect(this.low.x, this.low.y, this.low.z, this.high.x, this.high.y, this.high.z, false);\n        return result;\n    }\n    /**\n     * Return a copy, translated by adding `shift` components in all directions.\n     * * The translate of a null range is also a null range.\n     */\n    cloneTranslated(shift, result) {\n        result = result ? result : new this.constructor();\n        if (!this.isNull)\n            result.setDirect(this.low.x + shift.x, this.low.y + shift.y, this.low.z + shift.z, this.high.x + shift.x, this.high.y + shift.y, this.high.z + shift.z, false);\n        return result;\n    }\n    /** Return a range initialized to have no content. */\n    static createNull(result) {\n        result = result ? result : new this();\n        result.setNull();\n        return result;\n    }\n    /** Extend (modify in place) so that the range is large enough to include the supplied points. */\n    extend(...point) {\n        let p;\n        for (p of point)\n            this.extendPoint(p);\n    }\n    /** Return a range large enough to include the supplied points. If no points are given, the range is a null range */\n    static create(...point) {\n        const result = Range3d.createNull();\n        let p;\n        for (p of point)\n            result.extendPoint(p);\n        return result;\n    }\n    /** Create a range from freely structured MultiLineStringDataVariant. */\n    static createFromVariantData(data) {\n        const collector = new PointStreamRangeCollector();\n        VariantPointDataStream.streamXYZ(data, collector);\n        return collector.claimResult();\n    }\n    /** Create a Range3d enclosing the transformed points. */\n    static createTransformed(transform, ...point) {\n        const result = this.createNull();\n        let p;\n        for (p of point)\n            result.extendTransformedXYZ(transform, p.x, p.y, p.z);\n        return result;\n    }\n    /** Create a Range3d enclosing the transformed points. */\n    static createTransformedArray(transform, points) {\n        const result = this.createNull();\n        result.extendArray(points, transform);\n        return result;\n    }\n    /** Create a Range3d enclosing the points after inverse transform. */\n    static createInverseTransformedArray(transform, points) {\n        const result = this.createNull();\n        result.extendInverseTransformedArray(points, transform);\n        return result;\n    }\n    /** Set the range to be a single point supplied as x,y,z values */\n    setXYZ(x, y, z) {\n        this.low.x = this.high.x = x;\n        this.low.y = this.high.y = y;\n        this.low.z = this.high.z = z;\n    }\n    /** Create a single point range */\n    static createXYZ(x, y, z, result) {\n        result = result ? result : new this();\n        result.setDirect(x, y, z, x, y, z, false);\n        return result;\n    }\n    /** Create a box with 2 pairs of xyz candidates. Theses are compared and shuffled as needed for the box. */\n    static createXYZXYZ(xA, yA, zA, xB, yB, zB, result) {\n        result = result ? result : new this();\n        result.setDirect(Math.min(xA, xB), Math.min(yA, yB), Math.min(zA, zB), Math.max(xA, xB), Math.max(yA, yB), Math.max(zA, zB), false);\n        return result;\n    }\n    /** Create a box with 2 pairs of xyz candidates. If any direction has order flip, create null. */\n    static createXYZXYZOrCorrectToNull(xA, yA, zA, xB, yB, zB, result) {\n        result = result ? result : new this();\n        if (xA > xB || yA > yB || zA > zB)\n            return this.createNull(result);\n        result.setDirect(Math.min(xA, xB), Math.min(yA, yB), Math.min(zA, zB), Math.max(xA, xB), Math.max(yA, yB), Math.max(zA, zB), true);\n        return result;\n    }\n    /** Creates a 3d range from a 2d range's low and high members, setting the corresponding z values to the value given. */\n    static createRange2d(range, z = 0, result) {\n        const retVal = result ? result : new this();\n        retVal.setNull();\n        retVal.extendXYZ(range.low.x, range.low.y, z);\n        retVal.extendXYZ(range.high.x, range.high.y, z);\n        return retVal;\n    }\n    /** Create a range around an array of points. */\n    static createArray(points, result) {\n        result = result ? result : new this();\n        result.setNull();\n        let point;\n        for (point of points)\n            result.extendPoint(point);\n        return result;\n    }\n    /** Extend a range around an array of points (optionally transformed) */\n    extendArray(points, transform) {\n        if (Array.isArray(points))\n            if (transform)\n                for (const point of points)\n                    this.extendTransformedXYZ(transform, point.x, point.y, point.z);\n            else\n                for (const point of points)\n                    this.extendXYZ(point.x, point.y, point.z);\n        else // growable array -- this should be implemented without point extraction !!!\n         if (transform)\n            for (let i = 0; i < points.length; i++)\n                this.extendTransformedXYZ(transform, points.getXAtUncheckedPointIndex(i), points.getYAtUncheckedPointIndex(i), points.getZAtUncheckedPointIndex(i));\n        else\n            for (let i = 0; i < points.length; i++)\n                this.extendXYZ(points.getXAtUncheckedPointIndex(i), points.getYAtUncheckedPointIndex(i), points.getZAtUncheckedPointIndex(i));\n    }\n    /** Extend a range around an array of points (optionally transformed) */\n    extendInverseTransformedArray(points, transform) {\n        if (Array.isArray(points))\n            for (const point of points)\n                this.extendInverseTransformedXYZ(transform, point.x, point.y, point.z);\n        else // growable array -- this should be implemented without point extraction !!!\n            for (let i = 0; i < points.length; i++)\n                this.extendInverseTransformedXYZ(transform, points.getXAtUncheckedPointIndex(i), points.getYAtUncheckedPointIndex(i), points.getZAtUncheckedPointIndex(i));\n    }\n    /** Multiply the point x,y,z by transform and use the coordinate to extend this range. */\n    extendTransformedXYZ(transform, x, y, z) {\n        const origin = transform.origin;\n        const coffs = transform.matrix.coffs;\n        this.extendXYZ(origin.x + coffs[0] * x + coffs[1] * y + coffs[2] * z, origin.y + coffs[3] * x + coffs[4] * y + coffs[5] * z, origin.z + coffs[6] * x + coffs[7] * y + coffs[8] * z);\n    }\n    /** Multiply the point x,y,z,w by transform and use the coordinate to extend this range. */\n    extendTransformedXYZW(transform, x, y, z, w) {\n        const origin = transform.origin;\n        const coffs = transform.matrix.coffs;\n        this.extendXYZW(origin.x * w + coffs[0] * x + coffs[1] * y + coffs[2] * z, origin.y * w + coffs[3] * x + coffs[4] * y + coffs[5] * z, origin.z * w + coffs[6] * x + coffs[7] * y + coffs[8] * z, w);\n    }\n    /** Multiply the point x,y,z by the inverse of the transform and use the coordinate to extend this range. */\n    extendInverseTransformedXYZ(transform, x, y, z) {\n        const origin = transform.origin;\n        if (!transform.matrix.computeCachedInverse(true))\n            return false;\n        const coffs = transform.matrix.inverseCoffs;\n        const xx = x - origin.x;\n        const yy = y - origin.y;\n        const zz = z - origin.z;\n        this.extendXYZ(coffs[0] * xx + coffs[1] * yy + coffs[2] * zz, coffs[3] * xx + coffs[4] * yy + coffs[5] * zz, coffs[6] * xx + coffs[7] * yy + coffs[8] * zz);\n        return true;\n    }\n    /** Extend the range by the two transforms applied to xyz */\n    extendTransformTransformedXYZ(transformA, transformB, x, y, z) {\n        const origin = transformB.origin;\n        const coffs = transformB.matrix.coffs;\n        this.extendTransformedXYZ(transformA, origin.x + coffs[0] * x + coffs[1] * y + coffs[2] * z, origin.y + coffs[3] * x + coffs[4] * y + coffs[5] * z, origin.z + coffs[6] * x + coffs[7] * y + coffs[8] * z);\n    }\n    /** Test if the box has high<low for any of x,y,z, condition. Note that a range around a single point is NOT null. */\n    get isNull() {\n        return this.high.x < this.low.x\n            || this.high.y < this.low.y\n            || this.high.z < this.low.z;\n    }\n    /** Test if  data has high<low for any of x,y,z, condition. Note that a range around a single point is NOT null. */\n    static isNull(data) {\n        return data.high.x < data.low.x\n            || data.high.y < data.low.y\n            || data.high.z < data.low.z;\n    }\n    /** Test of the range contains a single point. */\n    get isSinglePoint() {\n        return this.high.x === this.low.x\n            && this.high.y === this.low.y\n            && this.high.z === this.low.z;\n    }\n    /** Return the midpoint of the diagonal.  No test for null range. */\n    get center() {\n        return this.low.interpolate(.5, this.high);\n    }\n    /** Return the low x coordinate */\n    get xLow() {\n        return this.low.x;\n    }\n    /** Return the low y coordinate */\n    get yLow() {\n        return this.low.y;\n    }\n    /** Return the low z coordinate */\n    get zLow() {\n        return this.low.z;\n    }\n    /** Return the high x coordinate */\n    get xHigh() {\n        return this.high.x;\n    }\n    /** Return the high y coordinate */\n    get yHigh() {\n        return this.high.y;\n    }\n    /** Return the high z coordinate */\n    get zHigh() {\n        return this.high.z;\n    }\n    /**  Return the length of the box in the x direction */\n    xLength() {\n        const a = this.high.x - this.low.x;\n        return a > 0.0 ? a : 0.0;\n    }\n    /**  Return the length of the box in the y direction */\n    yLength() {\n        const a = this.high.y - this.low.y;\n        return a > 0.0 ? a : 0.0;\n    }\n    /**  Return the length of the box in the z direction */\n    zLength() {\n        const a = this.high.z - this.low.z;\n        return a > 0.0 ? a : 0.0;\n    }\n    /**  Return the largest of the x,y, z lengths of the range. */\n    maxLength() {\n        return Math.max(this.xLength(), this.yLength(), this.zLength());\n    }\n    /**\n     * Return the diagonal vector. There is no check for isNull -- if the range isNull(), the vector will have very\n     * large negative coordinates.\n     */\n    diagonal(result) {\n        return this.low.vectorTo(this.high, result);\n    }\n    /**\n     * Return the diagonal vector. There is no check for isNull -- if the range isNull(), the vector will have very\n     * large negative coordinates.\n     */\n    diagonalFractionToPoint(fraction, result) {\n        return this.low.interpolate(fraction, this.high, result);\n    }\n    /** Return a point given by fractional positions on the XYZ axes. This is done with no check for isNull !!! */\n    fractionToPoint(fractionX, fractionY, fractionZ = 0, result) {\n        return this.low.interpolateXYZ(fractionX, fractionY, fractionZ, this.high, result);\n    }\n    /**\n     * Return a point given by fractional positions on the XYZ axes.\n     *  Returns undefined if the range is null.\n     */\n    localXYZToWorld(fractionX, fractionY, fractionZ, result) {\n        if (this.isNull)\n            return undefined;\n        return this.low.interpolateXYZ(fractionX, fractionY, fractionZ, this.high, result);\n    }\n    /**\n     * Return a point given by fractional positions on the XYZ axes.\n     * * Returns undefined if the range is null.\n     */\n    localToWorld(xyz, result) {\n        return this.localXYZToWorld(xyz.x, xyz.y, xyz.z, result);\n    }\n    /**\n     * Replace fractional coordinates by world coordinates.\n     * @returns false if null range.\n     */\n    localToWorldArrayInPlace(points) {\n        if (this.isNull)\n            return false;\n        for (const p of points)\n            this.low.interpolateXYZ(p.x, p.y, p.z, this.high, p);\n        return false;\n    }\n    /**\n     * Return fractional coordinates of point within the range.\n     * * returns undefined if the range is null.\n     * * returns undefined if any direction (x,y,z) has zero length\n     */\n    worldToLocal(point, result) {\n        const ax = RangeBase.npcScaleFactor(this.low.x, this.high.x);\n        const ay = RangeBase.npcScaleFactor(this.low.y, this.high.y);\n        const az = RangeBase.npcScaleFactor(this.low.z, this.high.z);\n        if (ax === 0.0 || ay === 0.0 || az === 0.0)\n            return undefined;\n        return Point3d.create((point.x - this.low.x) * ax, (point.y - this.low.y) * ay, (point.z - this.low.z) * az, result);\n    }\n    /**\n     * Return fractional coordinates of point within the range.\n     * * returns undefined if the range is null.\n     * * returns undefined if any direction (x,y,z) has zero length\n     */\n    worldToLocalArrayInPlace(point) {\n        const ax = RangeBase.npcScaleFactor(this.low.x, this.high.x);\n        const ay = RangeBase.npcScaleFactor(this.low.y, this.high.y);\n        const az = RangeBase.npcScaleFactor(this.low.z, this.high.z);\n        if (ax === 0.0 || ay === 0.0 || az === 0.0)\n            return false;\n        for (const p of point)\n            Point3d.create((p.x - this.low.x) * ax, (p.y - this.low.y) * ay, (p.z - this.low.z) * az, p);\n        return true;\n    }\n    /**\n     * Return an array with the 8 corners on order wth \"x varies fastest, then y, then z\"\n     * * points preallocated in `result` are reused if result.length >= 8.\n     * * in reuse case, result.length is trimmed to 8\n     */\n    corners(result) {\n        if (result !== undefined && result.length >= 8) {\n            result[0].set(this.low.x, this.low.y, this.low.z);\n            result[1].set(this.high.x, this.low.y, this.low.z);\n            result[2].set(this.low.x, this.high.y, this.low.z);\n            result[3].set(this.high.x, this.high.y, this.low.z);\n            result[4].set(this.low.x, this.low.y, this.high.z);\n            result[5].set(this.high.x, this.low.y, this.high.z);\n            result[6].set(this.low.x, this.high.y, this.high.z);\n            result[7].set(this.high.x, this.high.y, this.high.z);\n            result.length = 8;\n            return result;\n        }\n        return [\n            Point3d.create(this.low.x, this.low.y, this.low.z),\n            Point3d.create(this.high.x, this.low.y, this.low.z),\n            Point3d.create(this.low.x, this.high.y, this.low.z),\n            Point3d.create(this.high.x, this.high.y, this.low.z),\n            Point3d.create(this.low.x, this.low.y, this.high.z),\n            Point3d.create(this.high.x, this.low.y, this.high.z),\n            Point3d.create(this.low.x, this.high.y, this.high.z),\n            Point3d.create(this.high.x, this.high.y, this.high.z),\n        ];\n    }\n    /**\n     * Return an array with indices of the corners of a face\n     * * face 0 has negative x normal\n     * * face 1 has positive x normal\n     * * face 2 has negative y normal\n     * * face 3 has positive y normal\n     * * face 4 has negative z normal\n     * * face 5 has positive z normal\n     * * Any other value returns face 5\n     * * faces are CCW as viewed from outside.\n     */\n    static faceCornerIndices(index) {\n        if (index === 0)\n            return [0, 4, 6, 2];\n        if (index === 1)\n            return [1, 3, 7, 5];\n        if (index === 2)\n            return [0, 1, 5, 4];\n        if (index === 3)\n            return [3, 2, 6, 7];\n        if (index === 4)\n            return [0, 2, 3, 1];\n        return [4, 5, 7, 6];\n    }\n    /**\n     * Return a rectangle that is the cross section as viewed from above (z direction) and at zFraction\n     * @param zFraction plane altitude within the 0..1 z fraction range\n     * @param upwardNormal true for CCW as viewed from above\n     * @param addClosure true to add closure edge back to the start\n     * @returns\n     */\n    rectangleXY(zFraction = 0.0, upwardNormal = true, addClosure = true) {\n        if (this.isNull)\n            return undefined;\n        const points = [\n            this.fractionToPoint(0, 0, zFraction),\n            this.fractionToPoint(1, 0, zFraction),\n            this.fractionToPoint(1, 1, zFraction),\n            this.fractionToPoint(0, 1, zFraction),\n        ];\n        if (addClosure)\n            points.push(points[0].clone());\n        if (!upwardNormal)\n            points.reverse();\n        return points;\n    }\n    /** Return the largest absolute value among any coordinates in the box corners. */\n    maxAbs() {\n        if (this.isNull)\n            return 0.0;\n        return Math.max(this.low.maxAbs(), this.high.maxAbs());\n    }\n    /** Returns true if the x direction size is nearly zero */\n    get isAlmostZeroX() {\n        return Geometry.isSmallMetricDistance(this.xLength());\n    }\n    /** Returns true if the y direction size is nearly zero */\n    get isAlmostZeroY() {\n        return Geometry.isSmallMetricDistance(this.yLength());\n    }\n    /** Returns true if the z direction size is nearly zero */\n    get isAlmostZeroZ() {\n        return Geometry.isSmallMetricDistance(this.zLength());\n    }\n    /** Test if a point given as x,y,z is within the range. */\n    containsXYZ(x, y, z) {\n        return x >= this.low.x\n            && y >= this.low.y\n            && z >= this.low.z\n            && x <= this.high.x\n            && y <= this.high.y\n            && z <= this.high.z;\n    }\n    /** Test if a point given as x,y is within the range (ignoring z of range). */\n    containsXY(x, y) {\n        return x >= this.low.x\n            && y >= this.low.y\n            && x <= this.high.x\n            && y <= this.high.y;\n    }\n    /** Test if a point is within the range. */\n    containsPoint(point) {\n        return this.containsXYZ(point.x, point.y, point.z);\n    }\n    /** Test if the x,y coordinates of a point are within the range. */\n    containsPointXY(point) {\n        return point.x >= this.low.x\n            && point.y >= this.low.y\n            && point.x <= this.high.x\n            && point.y <= this.high.y;\n    }\n    /** Test of other range is within this range */\n    containsRange(other) {\n        return other.low.x >= this.low.x\n            && other.low.y >= this.low.y\n            && other.low.z >= this.low.z\n            && other.high.x <= this.high.x\n            && other.high.y <= this.high.y\n            && other.high.z <= this.high.z;\n    }\n    /** Test if there is any intersection with other range */\n    intersectsRange(other) {\n        return !(this.low.x > other.high.x\n            || this.low.y > other.high.y\n            || this.low.z > other.high.z\n            || other.low.x > this.high.x\n            || other.low.y > this.high.y\n            || other.low.z > this.high.z);\n    }\n    /** Test if there is any intersection with other range, ignoring z. */\n    intersectsRangeXY(other) {\n        return !(this.low.x > other.high.x\n            || this.low.y > other.high.y\n            || other.low.x > this.high.x\n            || other.low.y > this.high.y);\n    }\n    /** Return 0 if the point is within the range, otherwise the distance to the closest face or corner */\n    distanceToPoint(point) {\n        if (this.isNull)\n            return RangeBase._EXTREME_POSITIVE;\n        return Math.min(Geometry.hypotenuseXYZ(RangeBase.coordinateToRangeAbsoluteDistance(point.x, this.low.x, this.high.x), RangeBase.coordinateToRangeAbsoluteDistance(point.y, this.low.y, this.high.y), RangeBase.coordinateToRangeAbsoluteDistance(point.z, this.low.z, this.high.z)), RangeBase._EXTREME_POSITIVE);\n    }\n    /** Returns 0 if the ranges have any overlap, otherwise the shortest absolute distance from one to the other. */\n    distanceToRange(other) {\n        return Math.min(Geometry.hypotenuseXYZ(RangeBase.rangeToRangeAbsoluteDistance(this.low.x, this.high.x, other.low.x, other.high.x), RangeBase.rangeToRangeAbsoluteDistance(this.low.y, this.high.y, other.low.y, other.high.y), RangeBase.rangeToRangeAbsoluteDistance(this.low.z, this.high.z, other.low.z, other.high.z)), RangeBase._EXTREME_POSITIVE);\n    }\n    /** Expand this range by distances a (possibly signed) in all directions */\n    extendXYZ(x, y, z) {\n        if (x < this.low.x)\n            this.low.x = x;\n        if (x > this.high.x)\n            this.high.x = x;\n        if (y < this.low.y)\n            this.low.y = y;\n        if (y > this.high.y)\n            this.high.y = y;\n        if (z < this.low.z)\n            this.low.z = z;\n        if (z > this.high.z)\n            this.high.z = z;\n    }\n    /** Expand this range by a point interpolated between given points. */\n    extendInterpolated(xyz0, fraction, xyz1) {\n        if (fraction < 0.5) {\n            this.extendXYZ(xyz0.x + fraction * (xyz1.x - xyz0.x), xyz0.y + fraction * (xyz1.y - xyz0.y), xyz0.z + fraction * (xyz1.z - xyz0.z));\n        }\n        else {\n            // use reversed formulas for best accuracy at fraction=1.0\n            const g = 1.0 - fraction;\n            this.extendXYZ(xyz1.x + g * (xyz0.x - xyz1.x), xyz1.y + g * (xyz0.y - xyz1.y), xyz1.z + g * (xyz0.z - xyz1.z));\n        }\n    }\n    /** Expand this range by distances a in only the x direction.  */\n    extendXOnly(x) {\n        if (x < this.low.x)\n            this.low.x = x;\n        if (x > this.high.x)\n            this.high.x = x;\n    }\n    /** Expand this range by distances a in only the x direction.  */\n    extendYOnly(y) {\n        if (y < this.low.y)\n            this.low.y = y;\n        if (y > this.high.y)\n            this.high.y = y;\n    }\n    /** Expand this range by distances a in only the x direction.  */\n    extendZOnly(z) {\n        if (z < this.low.z)\n            this.low.z = z;\n        if (z > this.high.z)\n            this.high.z = z;\n    }\n    /** Expand one component of this range  */\n    extendSingleAxis(a, axisIndex) {\n        if (axisIndex === AxisIndex.X)\n            this.extendXOnly(a);\n        if (axisIndex === AxisIndex.Y)\n            this.extendYOnly(a);\n        if (axisIndex === AxisIndex.Z)\n            this.extendZOnly(a);\n    }\n    /** Expand this range by distances a (weighted and possibly signed) in all directions */\n    extendXYZW(x, y, z, w) {\n        if (!Geometry.isSmallMetricDistance(w))\n            this.extendXYZ(x / w, y / w, z / w);\n    }\n    /** Expand this range to include a point. */\n    extendPoint(point, transform) {\n        if (transform) {\n            this.extendTransformedXYZ(transform, point.x, point.y, point.z);\n        }\n        else {\n            this.extendXYZ(point.x, point.y, point.z);\n        }\n    }\n    /** Expand this range to include a transformed point. */\n    extendTransformedPoint(transform, point) {\n        this.extendTransformedXYZ(transform, point.x, point.y, point.z);\n    }\n    /** Expand this range to include a range. */\n    extendRange(other) {\n        if (!Range3d.isNull(other)) {\n            this.extendXYZ(other.low.x, other.low.y, other.low.z);\n            this.extendXYZ(other.high.x, other.high.y, other.high.z);\n        }\n    }\n    /**\n     * In each direction look at the difference between this range limit and that of interiorRange.\n     * * If this range is larger, expand it by extrapolationFactor.\n     */\n    extendWhenLarger(other, extrapolationFactor) {\n        if (!Range3d.isNull(other) && !Range3d.isNull(this)) {\n            this.high.x += RangeBase.multiplyIfPositive(this.high.x - other.high.x, extrapolationFactor);\n            this.high.y += RangeBase.multiplyIfPositive(this.high.y - other.high.y, extrapolationFactor);\n            this.high.z += RangeBase.multiplyIfPositive(this.high.z - other.high.z, extrapolationFactor);\n            this.low.x -= RangeBase.multiplyIfPositive(other.low.x - this.low.x, extrapolationFactor);\n            this.low.y -= RangeBase.multiplyIfPositive(other.low.y - this.low.y, extrapolationFactor);\n            this.low.z -= RangeBase.multiplyIfPositive(other.low.z - this.low.z, extrapolationFactor);\n        }\n    }\n    /** Return the intersection of ranges. */\n    intersect(other, result) {\n        if (!this.intersectsRange(other))\n            return Range3d.createNull(result);\n        return Range3d.createXYZXYZOrCorrectToNull(Math.max(this.low.x, other.low.x), Math.max(this.low.y, other.low.y), Math.max(this.low.z, other.low.z), Math.min(this.high.x, other.high.x), Math.min(this.high.y, other.high.y), Math.min(this.high.z, other.high.z), result);\n    }\n    /** Return the union of ranges. */\n    union(other, result) {\n        if (this.isNull)\n            return other.clone(result);\n        if (other.isNull)\n            return this.clone(result);\n        // we trust null ranges have EXTREME values, so a null in either input leads to expected results.\n        return Range3d.createXYZXYZOrCorrectToNull(Math.min(this.low.x, other.low.x), Math.min(this.low.y, other.low.y), Math.min(this.low.z, other.low.z), Math.max(this.high.x, other.high.x), Math.max(this.high.y, other.high.y), Math.max(this.high.z, other.high.z), result);\n    }\n    /**\n     * Move low and high points by scaleFactor around the center point.\n     * @param scaleFactor scale factor applied to low, high distance from center.\n     */\n    scaleAboutCenterInPlace(scaleFactor) {\n        if (!this.isNull) {\n            scaleFactor = Math.abs(scaleFactor);\n            // do the scalar stuff to avoid making a temporary object ....\n            const xMid = 0.5 * (this.low.x + this.high.x);\n            const yMid = 0.5 * (this.low.y + this.high.y);\n            const zMid = 0.5 * (this.low.z + this.high.z);\n            this.high.x = Geometry.interpolate(xMid, scaleFactor, this.high.x);\n            this.high.y = Geometry.interpolate(yMid, scaleFactor, this.high.y);\n            this.high.z = Geometry.interpolate(zMid, scaleFactor, this.high.z);\n            this.low.x = Geometry.interpolate(xMid, scaleFactor, this.low.x);\n            this.low.y = Geometry.interpolate(yMid, scaleFactor, this.low.y);\n            this.low.z = Geometry.interpolate(zMid, scaleFactor, this.low.z);\n        }\n    }\n    /**\n     * Move all limits by a fixed amount.\n     * * positive delta expands the range size\n     * * negative delta reduces the range size\n     * * if any dimension reduces below zero size, the whole range becomes null\n     * @param delta shift to apply.\n     */\n    expandInPlace(delta) {\n        this.setDirect(this.low.x - delta, this.low.y - delta, this.low.z - delta, this.high.x + delta, this.high.y + delta, this.high.z + delta, true);\n    }\n    /** Create a local to world transform from this range. */\n    getLocalToWorldTransform(result) {\n        return Transform.createOriginAndMatrix(Point3d.create(this.low.x, this.low.y, this.low.z), Matrix3d.createRowValues(this.high.x - this.low.x, 0, 0, 0, this.high.y - this.low.y, 0, 0, 0, this.high.z - this.low.z), result);\n    }\n    /**\n     * Creates an NPC to world transformation to go from 000...111 to the globally aligned cube with diagonally\n     * opposite corners that are the\n     * min and max of this range. The diagonal component for any degenerate direction is 1.\n     */\n    getNpcToWorldRangeTransform(result) {\n        const transform = this.getLocalToWorldTransform(result);\n        const matrix = transform.matrix;\n        if (matrix.coffs[0] === 0)\n            matrix.coffs[0] = 1;\n        if (matrix.coffs[4] === 0)\n            matrix.coffs[4] = 1;\n        if (matrix.coffs[8] === 0)\n            matrix.coffs[8] = 1;\n        return transform;\n    }\n    /**\n     * Ensure that the length of each dimension of this AxisAlignedBox3d is at least a minimum size. If not, expand\n     * to minimum about the center.\n     * @param min The minimum length for each dimension.\n     */\n    ensureMinLengths(min = .001) {\n        let size = (min - this.xLength()) / 2.0;\n        if (size > 0) {\n            this.low.x -= size;\n            this.high.x += size;\n        }\n        size = (min - this.yLength()) / 2.0;\n        if (size > 0) {\n            this.low.y -= size;\n            this.high.y += size;\n        }\n        size = (min - this.zLength()) / 2.0;\n        if (size > 0) {\n            this.low.z -= size;\n            this.high.z += size;\n        }\n    }\n}\n/**\n * Range on a 1d axis\n * * `low` and `high` members are always non-null objects\n * * having `low > high` indicates an empty range.\n * * the range contains x values for which `low <= x <= high`\n * @public\n */\nexport class Range1d extends RangeBase {\n    /** Reset the low and high to null range state. */\n    setNull() {\n        this.low = RangeBase._EXTREME_POSITIVE;\n        this.high = RangeBase._EXTREME_NEGATIVE;\n    }\n    // internal use only -- directly set all coordinates, test only if directed.\n    setDirect(low, high, correctToNull = false) {\n        this.low = low;\n        this.high = high;\n        if (correctToNull && low > high)\n            this.setNull();\n    }\n    // explicit ctor - no enforcement of value relationships\n    constructor(low = RangeBase._EXTREME_POSITIVE, high = RangeBase._EXTREME_NEGATIVE) {\n        super();\n        this.low = low;\n        this.high = high; // duplicates set_direct, but compiler is not convinced they are set.\n        this.setDirect(low, high);\n    }\n    /** Returns true if this and other have equal low and high parts, or both are null ranges. */\n    isAlmostEqual(other) {\n        return (Geometry.isSameCoordinate(this.low, other.low) && Geometry.isSameCoordinate(this.high, other.high))\n            || (this.isNull && other.isNull);\n    }\n    /** Copy contents from other Range1d. */\n    setFrom(other) {\n        this.low = other.low;\n        this.high = other.high;\n    }\n    /**\n     * Convert from a JSON object of one of these forms:\n     * *  Any array of numbers: `[value,value, value]`\n     * *  An object with low and high as properties: `{low:lowValue, high: highValue}`\n     */\n    setFromJSON(json) {\n        this.setNull();\n        if (Array.isArray(json)) {\n            let value;\n            for (value of json) {\n                if (Number.isFinite(value))\n                    this.extendX(value);\n            }\n        }\n        else if (json.low !== undefined && Number.isFinite(json.low) && json.high !== undefined && Number.isFinite(json.high)) {\n            this.extendX(json.low);\n            this.extendX(json.high);\n        }\n    }\n    /** Use `setFromJSON` to parse `json` into a new Range1d instance. */\n    static fromJSON(json) {\n        const result = new this();\n        if (json)\n            result.setFromJSON(json);\n        return result;\n    }\n    /**\n     * Convert to a JSON object of form\n     * ```\n     *    [lowValue,highValue]\n     * ```\n     */\n    toJSON() {\n        if (this.isNull)\n            return new Array();\n        else\n            return [this.low, this.high];\n    }\n    /**\n     * Return a new Range1d with contents of this.\n     * @param result optional result.\n     */\n    clone(result) {\n        result = result ? result : new this.constructor();\n        result.setDirect(this.low, this.high);\n        return result;\n    }\n    /**\n     * Return a new Range1d with contents of this.\n     * @param result optional result.\n     */\n    static createFrom(other, result) {\n        result = result ? result : new this();\n        result.setDirect(other.low, other.high);\n        return result;\n    }\n    /**\n     * Create a range with no content.\n     * @param result optional result.\n     */\n    static createNull(result) {\n        result = result ? result : new this();\n        result.setNull();\n        return result;\n    }\n    /**\n     * Create a range with `delta` added to low and high\n     * * If `this` is a null range, return a null range.\n     */\n    cloneTranslated(delta, result) {\n        result = result ? result : this.clone();\n        if (!result.isNull) {\n            result.low += delta;\n            result.high += delta;\n        }\n        return result;\n    }\n    /**\n     * Set this range to be a single value.\n     * @param x value to use as both low and high.\n     */\n    setX(x) {\n        this.low = this.high = x;\n    }\n    /** Create a single point box */\n    static createX(x, result) {\n        result = result ? result : new this();\n        result.setDirect(x, x);\n        return result;\n    }\n    /**\n     * Set this range to (min(x0,x1), max(x0,x1))\n     * @param x0 first value\n     * @param x1 second value\n     */\n    setXXUnordered(x0, x1) {\n        if (x0 <= x1) {\n            this.low = x0;\n            this.high = x1;\n        }\n        else {\n            this.low = x1;\n            this.high = x0;\n        }\n    }\n    /** Check if low is 0 and high is 1 */\n    get isExact01() {\n        return this.low === 0.0 && this.high === 1.0;\n    }\n    /**\n     * Create a box from two values. Values are reversed if needed\n     * @param xA first value\n     * @param xB second value\n     */\n    static createXX(xA, xB, result) {\n        result = result ? result : new this();\n        result.setDirect(Math.min(xA, xB), Math.max(xA, xB));\n        return result;\n    }\n    /**\n     * Create a box from two values, but null range if the values are reversed\n     * @param xA first value\n     * @param xB second value\n     */\n    static createXXOrCorrectToNull(xA, xB, result) {\n        if (xB < xA)\n            return Range1d.createNull(result);\n        result = result ? result : new this();\n        result.setDirect(Math.min(xA, xB), Math.max(xA, xB));\n        return result;\n    }\n    /**\n     * Create a range containing all the values in an array.\n     * @param values array of points to be contained in the range.\n     * @param result optional result.\n     */\n    static createArray(values, result) {\n        result = result ? result : new this();\n        let x;\n        for (x of values)\n            result.extendX(x);\n        return result;\n    }\n    /** Extend to include an array of values */\n    extendArray(values) {\n        let x;\n        for (x of values)\n            this.extendX(x);\n    }\n    /**\n     * Extend to include `values` at indices `beginIndex <= i < endIndex]`\n     * @param values array of values\n     * @param beginIndex first index to include\n     * @param numValue number of values to access\n     */\n    extendArraySubset(values, beginIndex, numValue) {\n        const endIndex = beginIndex + numValue;\n        for (let i = beginIndex; i < endIndex; i++)\n            this.extendX(values[i]);\n    }\n    /** Test if the box has high<low Note that a range around a single point is NOT null. */\n    get isNull() {\n        return this.high < this.low;\n    }\n    /** Test of the range contains a single point. */\n    get isSinglePoint() {\n        return this.high === this.low;\n    }\n    /** Return the length of the range in the x direction */\n    length() {\n        const a = this.high - this.low;\n        return a > 0.0 ? a : 0.0;\n    }\n    /** Return a point given by fractional positions within the range. This is done with no check for isNull !!! */\n    fractionToPoint(fraction) {\n        return Geometry.interpolate(this.low, fraction, this.high);\n    }\n    /** Return the largest absolute value among the box limits. */\n    maxAbs() {\n        if (this.isNull)\n            return 0.0;\n        return Math.max(Math.abs(this.low), Math.abs(this.high));\n    }\n    /** Test if the x direction size is nearly zero */\n    get isAlmostZeroLength() {\n        return Geometry.isSmallMetricDistance(this.length());\n    }\n    /** Test if a number is within the range. */\n    containsX(x) {\n        return x >= this.low\n            && x <= this.high;\n    }\n    /** Test of other range is within this range */\n    containsRange(other) {\n        return other.low >= this.low\n            && other.high <= this.high;\n    }\n    /** Test if there is any intersection with other range */\n    intersectsRange(other) {\n        return !(this.low > other.high || other.low > this.high);\n    }\n    /**\n     * Intersect this range with a range defined by parameters x0 and x1\n     * * For x1 > x0, that range is null, and the intersection is null.\n     * * For x0 <= x1, the input is a non-null range.\n     * * The intersection range replaces the contents of this.\n     */\n    intersectRangeXXInPlace(x0, x1) {\n        if (x1 < x0 || x1 < this.low || x0 > this.high) {\n            this.setNull();\n        }\n        else {\n            if (x1 < this.high)\n                this.high = x1;\n            if (x0 > this.low)\n                this.low = x0;\n        }\n    }\n    /** Returns 0 if the ranges have any overlap, otherwise the shortest absolute distance from one to the other. */\n    distanceToRange(other) {\n        return RangeBase.rangeToRangeAbsoluteDistance(this.low, this.high, other.low, other.high);\n    }\n    /** Return 0 if the point is within the range, otherwise the (unsigned) distance to the closest face or corner */\n    distanceToX(x) {\n        if (this.isNull)\n            return RangeBase._EXTREME_POSITIVE;\n        return RangeBase.coordinateToRangeAbsoluteDistance(x, this.low, this.high);\n    }\n    /** Expand this range by a single coordinate */\n    extendX(x) {\n        if (x < this.low)\n            this.low = x;\n        if (x > this.high)\n            this.high = x;\n    }\n    /** Expand this range to include a range. */\n    extendRange(other) {\n        if (!other.isNull) {\n            this.extendX(other.low);\n            this.extendX(other.high);\n        }\n    }\n    /** Extend only the low limit to x.  Return true if the low limit is changed. */\n    extendLow(x) {\n        if (this.isNull || x < this.low) {\n            this.low = x;\n            return true;\n        }\n        return false;\n    }\n    /** Extend only the high limit to x.  Return true if the high limit is changed. */\n    extendHigh(x) {\n        if (this.isNull || x > this.high) {\n            this.high = x;\n            return true;\n        }\n        return false;\n    }\n    /** Return the intersection of ranges. */\n    intersect(other, result) {\n        if (!this.intersectsRange(other))\n            return Range1d.createNull(result);\n        return Range1d.createXXOrCorrectToNull(Math.max(this.low, other.low), Math.min(this.high, other.high), result);\n    }\n    /** Return the union of ranges. */\n    union(other, result) {\n        // we trust null ranges have EXTREME values, so a null in either input leads to expected results.\n        return Range1d.createXX(Math.min(this.low, other.low), Math.max(this.high, other.high), result);\n    }\n    /**\n     * Move low and high points by scaleFactor around the center point.\n     * @param scaleFactor scale factor applied to low, high distance from center.\n     */\n    scaleAboutCenterInPlace(scaleFactor) {\n        if (!this.isNull) {\n            scaleFactor = Math.abs(scaleFactor);\n            // do the scalar stuff to avoid making a temporary object ....\n            const xMid = 0.5 * (this.low + this.high);\n            this.high = Geometry.interpolate(xMid, scaleFactor, this.high);\n            this.low = Geometry.interpolate(xMid, scaleFactor, this.low);\n        }\n    }\n    /**\n     * Move all limits by a fixed amount.\n     * * positive delta expands the range size\n     * * negative delta reduces the range size\n     * * if any dimension reduces below zero size, the whole range becomes null\n     * @param delta shift to apply.\n     */\n    expandInPlace(delta) {\n        this.setDirect(this.low - delta, this.high + delta, true);\n    }\n    /**\n     * Clip this range to a linear half space condition\n     * * if `limitA > limitB` the limit space is empty\n     *   * make this range null\n     *   * return false;\n     * * otherwise (i.e `limitA <= limitB`)\n     *   * solve `a + u * f = limitA' and `a + u * f = limitA`\n     *   * if unable to solve (i.e. u near zero), `a` alone determines whether to (a) leave this interval unchanged or\n     * (b) reduce to nothing.\n     *   * the `f` values are an interval in the space of this `Range1d`\n     *   * restrict the range to that interval (i.e intersect existing (low,high) with the fraction interval.\n     *   * return true if the range is non-null after the clip.\n     * @param a constant of linear map\n     * @param u coefficient of linear map\n     * @param limitA crossing value, assumed in range relation with limitB\n     * @param limitB crossing value, assumed in range relation with limitB\n     * @param limitIsHigh true if the limit is an upper limit on mapped values.\n     */\n    clipLinearMapToInterval(a, u, limitA, limitB) {\n        // f = (limit - a) / u\n        if (limitB < limitA || this.high < this.low)\n            return false;\n        const fractionA = Geometry.conditionalDivideFraction(limitA - a, u);\n        const fractionB = Geometry.conditionalDivideFraction(limitB - a, u);\n        // single point case\n        if (fractionA === undefined || fractionB === undefined) {\n            if (limitA <= a && a <= limitB)\n                return true;\n            this.setNull();\n            return false;\n        }\n        if (fractionA < fractionB) {\n            if (fractionA > this.low)\n                this.low = fractionA;\n            if (fractionB < this.high)\n                this.high = fractionB;\n        }\n        else {\n            if (fractionA < this.high)\n                this.high = fractionA;\n            if (fractionB > this.low)\n                this.low = fractionB;\n        }\n        if (this.high < this.low) {\n            this.setNull();\n            return false;\n        }\n        return true;\n    }\n}\n/**\n * Range box in xy plane\n * @public\n */\nexport class Range2d extends RangeBase {\n    /** Reset the low and high to null range state. */\n    setNull() {\n        this.low.x = RangeBase._EXTREME_POSITIVE;\n        this.low.y = RangeBase._EXTREME_POSITIVE;\n        this.high.x = RangeBase._EXTREME_NEGATIVE;\n        this.high.y = RangeBase._EXTREME_NEGATIVE;\n    }\n    /** Flatten the low and high coordinates of any json object with low.x .. high.y into an array of 4 doubles */\n    static toFloat64Array(val) {\n        return Float64Array.of(val.low.x, val.low.y, val.high.x, val.high.y);\n    }\n    /** Flatten the low and high coordinates of this instance into an array of 4 doubles */\n    toFloat64Array() {\n        return Range2d.toFloat64Array(this);\n    }\n    /**\n     * Construct a Range2d from an array of double-precision values\n     * @param f64 the array, which should contain exactly 4 values in this order: lowX, lowY, highX, highY\n     * @return a new Range2d object\n     */\n    static fromFloat64Array(f64) {\n        if (f64.length !== 4)\n            throw new Error(\"invalid array\");\n        return new this(f64[0], f64[1], f64[2], f64[3]);\n    }\n    /**\n     * Construct a Range2d from an un-typed array. This mostly useful when interpreting ECSQL query results of\n     * the 'blob' type, where you know that that result is a Range3d.\n     * @param buffer untyped array\n     * @return a new Range2d object\n     */\n    static fromArrayBuffer(buffer) {\n        return this.fromFloat64Array(new Float64Array(buffer));\n    }\n    // explicit constructor - no enforcement of value relationships\n    constructor(lowX = Range2d._EXTREME_POSITIVE, lowY = Range2d._EXTREME_POSITIVE, highX = Range2d._EXTREME_NEGATIVE, highY = Range2d._EXTREME_NEGATIVE) {\n        super();\n        this.low = Point2d.create(lowX, lowY);\n        this.high = Point2d.create(highX, highY);\n    }\n    /** Returns true if this and other have equal low and high parts, or both are null ranges. */\n    isAlmostEqual(other) {\n        return (this.low.isAlmostEqual(other.low) && this.high.isAlmostEqual(other.high))\n            || (this.isNull && other.isNull);\n    }\n    /** Copy all content from any `other` that has low and high xy data. */\n    setFrom(other) {\n        this.low.set(other.low.x, other.low.y);\n        this.high.set(other.high.x, other.high.y);\n    }\n    /** Create a new Range2d from any `other` that has low and high xy data. */\n    static createFrom(other, result) {\n        if (result) {\n            result.setFrom(other);\n            return result;\n        }\n        return this.createXYXYOrCorrectToNull(other.low.x, other.low.y, other.high.x, other.high.y, result);\n    }\n    /** Treat any array of numbers as numbers to be inserted !!! */\n    setFromJSON(json) {\n        this.setNull();\n        if (Array.isArray(json)) {\n            const point = Point2d.create();\n            for (const value of json) {\n                point.setFromJSON(value);\n                this.extendPoint(point);\n            }\n            return;\n        }\n        const low = Point2d.fromJSON(json.low);\n        const high = Point2d.fromJSON(json.high);\n        if (!RangeBase.isExtremePoint2d(low) && !RangeBase.isExtremePoint2d(high)) {\n            this.extendPoint(low);\n            this.extendPoint(high);\n        }\n    }\n    /** Freeze this instance (and its members) so it is read-only */\n    freeze() {\n        this.low.freeze();\n        this.high.freeze();\n        return Object.freeze(this);\n    }\n    /** Return json array with two points as produced by `Point2d.toJSON` */\n    toJSON() {\n        return this.isNull ? [] : [this.low.toJSON(), this.high.toJSON()];\n    }\n    /** Use `setFromJSON` to parse `json` into a new Range2d instance. */\n    static fromJSON(json) {\n        const result = new this();\n        if (json)\n            result.setFromJSON(json);\n        return result;\n    }\n    // internal use only -- directly set all coordinates, without tests.\n    setDirect(xA, yA, xB, yB, correctToNull) {\n        this.low.x = xA;\n        this.low.y = yA;\n        this.high.x = xB;\n        this.high.y = yB;\n        if (correctToNull) {\n            if (this.low.x > this.high.x || this.low.y > this.high.y)\n                this.setNull();\n        }\n    }\n    /** Return a clone of this range (or copy to optional result) */\n    clone(result) {\n        result = result ? result : new this.constructor();\n        result.setDirect(this.low.x, this.low.y, this.high.x, this.high.y, false);\n        return result;\n    }\n    /** Create a range with no content. */\n    static createNull(result) {\n        result = result ? result : new this();\n        result.setNull();\n        return result;\n    }\n    /** Set low and hight to a single xy value. */\n    setXY(x, y) {\n        this.low.x = this.high.x = x;\n        this.low.y = this.high.y = y;\n    }\n    /** Create a single point box */\n    static createXY(x, y, result) {\n        result = result ? result : new this();\n        result.setDirect(x, y, x, y, false);\n        return result;\n    }\n    /** Create a box with 2 pairs of xy candidates. Theses are compared and shuffled as needed for the box. */\n    static createXYXY(xA, yA, xB, yB, result) {\n        result = result ? result : new this();\n        result.setDirect(Math.min(xA, xB), Math.min(yA, yB), Math.max(xA, xB), Math.max(yA, yB), false);\n        return result;\n    }\n    /** Create a box with 3 pairs of xy candidates. Theses are compared and shuffled as needed for the box. */\n    static createXYXYXY(xA, yA, xB, yB, xC, yC, result) {\n        result = result ? result : new this();\n        result.setDirect(Math.min(xA, xB, xC), Math.min(yA, yB, yC), Math.max(xA, xB, xC), Math.max(yA, yB, yC), false);\n        return result;\n    }\n    /** Create a box with 2 pairs of xy candidates. If any direction has order flip, create null. */\n    static createXYXYOrCorrectToNull(xA, yA, xB, yB, result) {\n        if (xA > xB || yA > yB)\n            return this.createNull(result);\n        result = result ? result : new this();\n        result.setDirect(Math.min(xA, xB), Math.min(yA, yB), Math.max(xA, xB), Math.max(yA, yB), true);\n        return result;\n    }\n    /** Create a range around an array of points. */\n    static createArray(points, result) {\n        result = result ? result : new this();\n        let point;\n        for (point of points)\n            result.extendPoint(point);\n        return result;\n    }\n    /** Test if the box has high<low for any of x,y, condition. Note that a range around a single point is NOT null. */\n    get isNull() {\n        return this.high.x < this.low.x\n            || this.high.y < this.low.y;\n    }\n    /**\n     * Test if the box has high strictly less than low for any of x,y, condition. Note that a range around a\n     * single point is NOT null.\n     */\n    static isNull(range) {\n        return range.high.x < range.low.x\n            || range.high.y < range.low.y;\n    }\n    /** Test of the range contains a single point. */\n    get isSinglePoint() {\n        return this.high.x === this.low.x\n            && this.high.y === this.low.y;\n    }\n    /** Return the midpoint of the diagonal.  No test for null range. */\n    get center() {\n        return this.low.interpolate(.5, this.high);\n    }\n    /** Return the low x coordinate */\n    get xLow() {\n        return this.low.x;\n    }\n    /** Return the low y coordinate */\n    get yLow() {\n        return this.low.y;\n    }\n    /** Return the high x coordinate */\n    get xHigh() {\n        return this.high.x;\n    }\n    /** Return the high y coordinate */\n    get yHigh() {\n        return this.high.y;\n    }\n    /** Length of the box in the x direction */\n    xLength() {\n        const a = this.high.x - this.low.x;\n        return a > 0.0 ? a : 0.0;\n    }\n    /** Length of the box in the y direction */\n    yLength() {\n        const a = this.high.y - this.low.y;\n        return a > 0.0 ? a : 0.0;\n    }\n    /**\n     * Return the diagonal vector. There is no check for isNull -- if the range isNull(), the vector will have very\n     * large negative coordinates.\n     */\n    diagonal(result) {\n        return this.low.vectorTo(this.high, result);\n    }\n    /**\n     * Return the point at the specified fraction along the diagonal vector. There is no check for isNull -- if the\n     * range isNull(), the vector will have very large negative coordinates.\n     */\n    diagonalFractionToPoint(fraction, result) {\n        return this.low.interpolate(fraction, this.high, result);\n    }\n    /** Return a point given by fractional positions on the XY axes. This is done with no check for isNull !!! */\n    fractionToPoint(fractionX, fractionY, result) {\n        return this.low.interpolateXY(fractionX, fractionY, this.high, result);\n    }\n    /**\n     * Return an array with the 4 corners.\n     * * if asLoop is false, 4 corners are \"x varies fastest, then y\"\n     * * if asLoop is true, 5 corners are in CCW order WITH CLOSURE\n     */\n    corners3d(asLoop = false, z = 0) {\n        if (asLoop)\n            return [\n                Point3d.create(this.low.x, this.low.y, z),\n                Point3d.create(this.high.x, this.low.y, z),\n                Point3d.create(this.high.x, this.high.y, z),\n                Point3d.create(this.low.x, this.high.y, z),\n                Point3d.create(this.low.x, this.low.y, z),\n            ];\n        return [\n            Point3d.create(this.low.x, this.low.y, z),\n            Point3d.create(this.high.x, this.low.y, z),\n            Point3d.create(this.low.x, this.high.y, z),\n            Point3d.create(this.high.x, this.high.y, z),\n        ];\n    }\n    /** Largest absolute value among any coordinates in the box corners. */\n    maxAbs() {\n        if (this.isNull)\n            return 0.0;\n        return Math.max(this.low.maxAbs(), this.high.maxAbs());\n    }\n    /** Test if the x direction size is nearly zero */\n    get isAlmostZeroX() {\n        return Geometry.isSmallMetricDistance(this.xLength());\n    }\n    /** Test if the y direction size is nearly zero */\n    get isAlmostZeroY() {\n        return Geometry.isSmallMetricDistance(this.yLength());\n    }\n    /** Test if a point given as x,y is within the range */\n    containsXY(x, y) {\n        return x >= this.low.x\n            && y >= this.low.y\n            && x <= this.high.x\n            && y <= this.high.y;\n    }\n    /** Test if a point is within the range. */\n    containsPoint(point) {\n        return this.containsXY(point.x, point.y);\n    }\n    /** Test of other range is within this range */\n    containsRange(other) {\n        return other.low.x >= this.low.x\n            && other.low.y >= this.low.y\n            && other.high.x <= this.high.x\n            && other.high.y <= this.high.y;\n    }\n    /** Test if there is any intersection with other range */\n    intersectsRange(other) {\n        return !(this.low.x > other.high.x\n            || this.low.y > other.high.y\n            || other.low.x > this.high.x\n            || other.low.y > this.high.y);\n    }\n    /** Return 0 if the point is within the range, otherwise the distance to the closest face or corner */\n    distanceToPoint(point) {\n        if (this.isNull)\n            return Range2d._EXTREME_POSITIVE;\n        return Math.min(Geometry.hypotenuseXY(RangeBase.coordinateToRangeAbsoluteDistance(point.x, this.low.x, this.high.x), RangeBase.coordinateToRangeAbsoluteDistance(point.y, this.low.y, this.high.y)), Range2d._EXTREME_POSITIVE);\n    }\n    /** Return 0 if the point is within the range, otherwise the distance to the closest face or corner */\n    distanceToRange(other) {\n        return Math.min(Geometry.hypotenuseXY(RangeBase.rangeToRangeAbsoluteDistance(this.low.x, this.high.x, other.low.x, other.high.x), RangeBase.rangeToRangeAbsoluteDistance(this.low.y, this.high.y, other.low.y, other.high.y)), Range2d._EXTREME_POSITIVE);\n    }\n    /** Expand this range to include a point given by x,y */\n    extendXY(x, y) {\n        if (x < this.low.x)\n            this.low.x = x;\n        if (x > this.high.x)\n            this.high.x = x;\n        if (y < this.low.y)\n            this.low.y = y;\n        if (y > this.high.y)\n            this.high.y = y;\n    }\n    /** Expand this range to include a point given by x,y */\n    extendTransformedXY(transform, x, y) {\n        const x1 = transform.multiplyComponentXYZ(0, x, y, 0);\n        const y1 = transform.multiplyComponentXYZ(1, x, y, 0);\n        this.extendXY(x1, y1);\n    }\n    /** Expand this range to include a point. */\n    extendPoint(point) {\n        this.extendXY(point.x, point.y);\n    }\n    /** Expand this range to include a range. */\n    extendRange(other) {\n        if (!Range2d.isNull(other)) {\n            this.extendXY(other.low.x, other.low.y);\n            this.extendXY(other.high.x, other.high.y);\n        }\n    }\n    /** Return the intersection of ranges. */\n    intersect(other, result) {\n        if (!this.intersectsRange(other))\n            return Range2d.createNull(result);\n        return Range2d.createXYXY(Math.max(this.low.x, other.low.x), Math.max(this.low.y, other.low.y), Math.min(this.high.x, other.high.x), Math.min(this.high.y, other.high.y), result);\n    }\n    /** Return the union of ranges. */\n    union(other, result) {\n        if (this.isNull)\n            return Range2d.createFrom(other, result);\n        if (Range2d.isNull(other))\n            return this.clone(result);\n        // we trust null ranges have EXTREME values, so a null in either input leads to expected results.\n        return Range2d.createXYXY(Math.min(this.low.x, other.low.x), Math.min(this.low.y, other.low.y), Math.max(this.high.x, other.high.x), Math.max(this.high.y, other.high.y), result);\n    }\n    /**\n     * Move low and high points by scaleFactor around the center point.\n     * @param scaleFactor scale factor applied to low, high distance from center.\n     */\n    scaleAboutCenterInPlace(scaleFactor) {\n        if (!this.isNull) {\n            scaleFactor = Math.abs(scaleFactor);\n            // do the scalar stuff to avoid making a temporary object ....\n            const xMid = 0.5 * (this.low.x + this.high.x);\n            const yMid = 0.5 * (this.low.y + this.high.y);\n            this.high.x = Geometry.interpolate(xMid, scaleFactor, this.high.x);\n            this.high.y = Geometry.interpolate(yMid, scaleFactor, this.high.y);\n            this.low.x = Geometry.interpolate(xMid, scaleFactor, this.low.x);\n            this.low.y = Geometry.interpolate(yMid, scaleFactor, this.low.y);\n        }\n    }\n    /**\n     * Move all limits by a fixed amount.\n     * * positive delta expands the range size\n     * * negative delta reduces the range size\n     * * if any dimension reduces below zero size, the whole range becomes null\n     * @param delta shift to apply.\n     */\n    expandInPlace(delta) {\n        this.setDirect(this.low.x - delta, this.low.y - delta, this.high.x + delta, this.high.y + delta, true);\n    }\n    /**\n     * Return fractional coordinates of point within the range.\n     * * returns undefined if the range is null.\n     * * returns undefined if any direction (x,y) has zero length\n     */\n    worldToLocal(point, result) {\n        const ax = RangeBase.npcScaleFactor(this.low.x, this.high.x);\n        const ay = RangeBase.npcScaleFactor(this.low.y, this.high.y);\n        if (ax === 0.0 || ay === 0.0)\n            return undefined;\n        return Point2d.create((point.x - this.low.x) * ax, (point.y - this.low.y) * ay, result);\n    }\n}\n//# sourceMappingURL=Range.js.map",
      "start": 1693508123249,
      "end": 1693508123422,
      "sourcemaps": null
    }
  ]
}
