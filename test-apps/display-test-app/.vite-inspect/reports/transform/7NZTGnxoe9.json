{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/SceneCompositor.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { assert, dispose } from \"@itwin/core-bentley\";\nimport { Transform, Vector2d, Vector3d } from \"@itwin/core-geometry\";\nimport { ModelFeature, RenderMode, SpatialClassifierInsideDisplay, SpatialClassifierOutsideDisplay, } from \"@itwin/core-common\";\nimport { RenderType } from \"@itwin/webgl-compatibility\";\nimport { Pixel } from \"../Pixel\";\nimport { BranchState } from \"./BranchState\";\nimport { AmbientOcclusionGeometry, BlurGeometry, BlurType, BoundaryType, CompositeGeometry, CopyPickBufferGeometry, SingleTexturedViewportQuadGeometry, ViewportQuadGeometry, VolumeClassifierGeometry, } from \"./CachedGeometry\";\nimport { Debug } from \"./Diagnostics\";\nimport { extractFlashedVolumeClassifierCommands, extractHilitedVolumeClassifierCommands } from \"./DrawCommand\";\nimport { FrameBuffer } from \"./FrameBuffer\";\nimport { GL } from \"./GL\";\nimport { IModelFrameLifecycle } from \"./IModelFrameLifecycle\";\nimport { Matrix4 } from \"./Matrix\";\nimport { TextureUnit } from \"./RenderFlags\";\nimport { RenderState } from \"./RenderState\";\nimport { getDrawParams } from \"./ScratchDrawParams\";\nimport { SolarShadowMap } from \"./SolarShadowMap\";\nimport { System } from \"./System\";\nimport { TextureHandle } from \"./Texture\";\nimport { RenderBufferMultiSample } from \"./RenderBuffer\";\nimport { EDLMode, EyeDomeLighting } from \"./EDL\";\nexport function collectTextureStatistics(texture, stats) {\n    if (undefined !== texture)\n        stats.addTextureAttachment(texture.bytesUsed);\n}\nfunction collectMsBufferStatistics(msBuff, stats) {\n    if (undefined !== msBuff)\n        stats.addTextureAttachment(msBuff.bytesUsed);\n}\n// Maintains the textures used by a SceneCompositor. The textures are reallocated when the dimensions of the viewport change.\nclass Textures {\n    get isDisposed() {\n        return undefined === this.accumulation\n            && undefined === this.revealage\n            && undefined === this.color\n            && undefined === this.featureId\n            && undefined === this.depthAndOrder\n            && undefined === this.depthAndOrderHidden\n            && undefined === this.hilite\n            && undefined === this.occlusion\n            && undefined === this.occlusionBlur\n            && undefined === this.volClassBlend\n            && undefined === this.colorMsBuff\n            && undefined === this.featureIdMsBuff\n            && undefined === this.featureIdMsBuffHidden\n            && undefined === this.depthAndOrderMsBuff\n            && undefined === this.depthAndOrderMsBuffHidden\n            && undefined === this.hiliteMsBuff\n            && undefined === this.volClassBlendMsBuff;\n    }\n    dispose() {\n        this.accumulation = dispose(this.accumulation);\n        this.revealage = dispose(this.revealage);\n        this.color = dispose(this.color);\n        this.featureId = dispose(this.featureId);\n        this.depthAndOrder = dispose(this.depthAndOrder);\n        this.depthAndOrderHidden = dispose(this.depthAndOrderHidden);\n        this.hilite = dispose(this.hilite);\n        this.occlusion = dispose(this.occlusion);\n        this.occlusionBlur = dispose(this.occlusionBlur);\n        this.colorMsBuff = dispose(this.colorMsBuff);\n        this.featureIdMsBuff = dispose(this.featureIdMsBuff);\n        this.featureIdMsBuffHidden = dispose(this.featureIdMsBuffHidden);\n        this.depthAndOrderMsBuff = dispose(this.depthAndOrderMsBuff);\n        this.depthAndOrderMsBuffHidden = dispose(this.depthAndOrderMsBuffHidden);\n        this.hiliteMsBuff = dispose(this.hiliteMsBuff);\n        this.volClassBlend = dispose(this.volClassBlend);\n        this.volClassBlendMsBuff = dispose(this.volClassBlendMsBuff);\n    }\n    collectStatistics(stats) {\n        collectTextureStatistics(this.accumulation, stats);\n        collectTextureStatistics(this.revealage, stats);\n        collectTextureStatistics(this.color, stats);\n        collectTextureStatistics(this.featureId, stats);\n        collectTextureStatistics(this.depthAndOrder, stats);\n        collectTextureStatistics(this.depthAndOrderHidden, stats);\n        collectTextureStatistics(this.hilite, stats);\n        collectTextureStatistics(this.occlusion, stats);\n        collectTextureStatistics(this.occlusionBlur, stats);\n        collectTextureStatistics(this.volClassBlend, stats);\n        collectMsBufferStatistics(this.colorMsBuff, stats);\n        collectMsBufferStatistics(this.featureIdMsBuff, stats);\n        collectMsBufferStatistics(this.featureIdMsBuffHidden, stats);\n        collectMsBufferStatistics(this.depthAndOrderMsBuff, stats);\n        collectMsBufferStatistics(this.depthAndOrderMsBuffHidden, stats);\n        collectMsBufferStatistics(this.hiliteMsBuff, stats);\n        collectMsBufferStatistics(this.volClassBlendMsBuff, stats);\n    }\n    init(width, height, numSamples) {\n        assert(undefined === this.accumulation);\n        let pixelDataType = GL.Texture.DataType.UnsignedByte;\n        switch (System.instance.maxRenderType) {\n            case RenderType.TextureFloat: {\n                pixelDataType = GL.Texture.DataType.Float;\n                break;\n            }\n            case RenderType.TextureHalfFloat: {\n                pixelDataType = System.instance.context.HALF_FLOAT;\n                break;\n            }\n            /* falls through */\n            case RenderType.TextureUnsignedByte: {\n                break;\n            }\n        }\n        // NB: Both of these must be of the same type, because they are borrowed by pingpong and bound to the same frame buffer.\n        this.accumulation = TextureHandle.createForAttachment(width, height, GL.Texture.Format.Rgba, pixelDataType);\n        this.revealage = TextureHandle.createForAttachment(width, height, GL.Texture.Format.Rgba, pixelDataType);\n        // Hilite texture is a simple on-off, but the smallest texture format WebGL allows us to use as output is RGBA with a byte per component.\n        this.hilite = TextureHandle.createForAttachment(width, height, GL.Texture.Format.Rgba, GL.Texture.DataType.UnsignedByte);\n        this.color = TextureHandle.createForAttachment(width, height, GL.Texture.Format.Rgba, GL.Texture.DataType.UnsignedByte);\n        this.featureId = TextureHandle.createForAttachment(width, height, GL.Texture.Format.Rgba, GL.Texture.DataType.UnsignedByte);\n        this.depthAndOrder = TextureHandle.createForAttachment(width, height, GL.Texture.Format.Rgba, GL.Texture.DataType.UnsignedByte);\n        let rVal = undefined !== this.accumulation\n            && undefined !== this.revealage\n            && undefined !== this.color\n            && undefined !== this.featureId\n            && undefined !== this.depthAndOrder\n            && undefined !== this.hilite;\n        if (rVal && numSamples > 1) {\n            rVal = this.enableMultiSampling(width, height, numSamples);\n        }\n        return rVal;\n    }\n    enableOcclusion(width, height, numSamples) {\n        assert(undefined === this.occlusion && undefined === this.occlusionBlur);\n        this.occlusion = TextureHandle.createForAttachment(width, height, GL.Texture.Format.Rgba, GL.Texture.DataType.UnsignedByte);\n        this.occlusionBlur = TextureHandle.createForAttachment(width, height, GL.Texture.Format.Rgba, GL.Texture.DataType.UnsignedByte);\n        let rVal = undefined !== this.occlusion && undefined !== this.occlusionBlur;\n        if (numSamples > 1) {\n            // If multisampling then we need a texture for storing depth and order for hidden edges.\n            this.depthAndOrderHidden = TextureHandle.createForAttachment(width, height, GL.Texture.Format.Rgba, GL.Texture.DataType.UnsignedByte);\n            rVal = rVal && undefined !== this.depthAndOrderHidden;\n        }\n        return rVal;\n    }\n    disableOcclusion() {\n        assert(undefined !== this.occlusion && undefined !== this.occlusionBlur);\n        this.occlusion = dispose(this.occlusion);\n        this.occlusionBlur = dispose(this.occlusionBlur);\n        this.depthAndOrderHidden = dispose(this.depthAndOrderHidden);\n    }\n    enableVolumeClassifier(width, height, numSamples) {\n        assert(undefined === this.volClassBlend);\n        this.volClassBlend = TextureHandle.createForAttachment(width, height, GL.Texture.Format.Rgba, GL.Texture.DataType.UnsignedByte);\n        let rVal = undefined !== this.volClassBlend;\n        if (rVal && undefined !== numSamples && numSamples > 1) {\n            this.volClassBlendMsBuff = RenderBufferMultiSample.create(width, height, WebGL2RenderingContext.RGBA8, numSamples);\n            rVal = undefined !== this.volClassBlendMsBuff;\n        }\n        return rVal;\n    }\n    disableVolumeClassifier() {\n        this.volClassBlend = dispose(this.volClassBlend);\n        this.volClassBlendMsBuff = dispose(this.volClassBlendMsBuff);\n    }\n    enableMultiSampling(width, height, numSamples) {\n        this.colorMsBuff = RenderBufferMultiSample.create(width, height, WebGL2RenderingContext.RGBA8, numSamples);\n        this.featureIdMsBuff = RenderBufferMultiSample.create(width, height, WebGL2RenderingContext.RGBA8, numSamples);\n        this.featureIdMsBuffHidden = RenderBufferMultiSample.create(width, height, WebGL2RenderingContext.RGBA8, numSamples);\n        this.depthAndOrderMsBuff = RenderBufferMultiSample.create(width, height, WebGL2RenderingContext.RGBA8, numSamples);\n        this.depthAndOrderMsBuffHidden = RenderBufferMultiSample.create(width, height, WebGL2RenderingContext.RGBA8, numSamples);\n        this.hiliteMsBuff = RenderBufferMultiSample.create(width, height, WebGL2RenderingContext.RGBA8, numSamples);\n        return undefined !== this.colorMsBuff\n            && undefined !== this.featureIdMsBuff\n            && undefined !== this.featureIdMsBuffHidden\n            && undefined !== this.depthAndOrderMsBuff\n            && undefined !== this.depthAndOrderMsBuffHidden\n            && undefined !== this.hiliteMsBuff;\n    }\n    disableMultiSampling() {\n        this.colorMsBuff = dispose(this.colorMsBuff);\n        this.featureIdMsBuff = dispose(this.featureIdMsBuff);\n        this.featureIdMsBuffHidden = dispose(this.featureIdMsBuffHidden);\n        this.depthAndOrderMsBuff = dispose(this.depthAndOrderMsBuff);\n        this.depthAndOrderMsBuffHidden = dispose(this.depthAndOrderMsBuffHidden);\n        this.hiliteMsBuff = dispose(this.hiliteMsBuff);\n        return true;\n    }\n}\n// Maintains the framebuffers used by a SceneCompositor. The color attachments are supplied by a Textures object.\nclass FrameBuffers {\n    init(textures, depth, depthMS) {\n        if (!this.initPotentialMSFbos(textures, depth, depthMS))\n            return false;\n        this.depthAndOrder = FrameBuffer.create([textures.depthAndOrder], depth);\n        this.hilite = FrameBuffer.create([textures.hilite], depth);\n        this.hiliteUsingStencil = FrameBuffer.create([textures.hilite], depth);\n        if (!this.depthAndOrder || !this.hilite || !this.hiliteUsingStencil)\n            return false;\n        assert(undefined === this.opaqueAll);\n        if (!this.initPotentialMSMRTFbos(textures, depth, depthMS))\n            return false;\n        assert(undefined !== textures.accumulation && undefined !== textures.revealage);\n        const colors = [textures.accumulation, textures.revealage];\n        this.translucent = FrameBuffer.create(colors, depth);\n        this.clearTranslucent = FrameBuffer.create(colors);\n        // We borrow the SceneCompositor's accum and revealage textures for the surface pass.\n        // First we render edges, writing to our textures.\n        // Then we copy our textures to borrowed textures.\n        // Finally we render surfaces, writing to our textures and reading from borrowed textures.\n        assert(undefined !== textures.accumulation && undefined !== textures.revealage);\n        const pingPong = [textures.accumulation, textures.revealage];\n        this.pingPong = FrameBuffer.create(pingPong);\n        return undefined !== this.translucent\n            && undefined !== this.clearTranslucent\n            && undefined !== this.pingPong;\n    }\n    initPotentialMSFbos(textures, depth, depthMS) {\n        const boundColor = System.instance.frameBufferStack.currentColorBuffer;\n        assert(undefined !== boundColor && undefined !== textures.color);\n        if (undefined === depthMS) {\n            this.opaqueColor = FrameBuffer.create([boundColor], depth);\n            this.opaqueAndCompositeColor = FrameBuffer.create([textures.color], depth);\n        }\n        else {\n            assert(undefined !== textures.colorMsBuff);\n            this.opaqueColor = FrameBuffer.create([boundColor], depth, [textures.colorMsBuff], [GL.MultiSampling.Filter.Linear], depthMS);\n            this.opaqueAndCompositeColor = FrameBuffer.create([textures.color], depth, [textures.colorMsBuff], [GL.MultiSampling.Filter.Linear], depthMS);\n        }\n        return undefined !== this.opaqueColor\n            && undefined !== this.opaqueAndCompositeColor;\n    }\n    initPotentialMSMRTFbos(textures, depth, depthMs) {\n        const boundColor = System.instance.frameBufferStack.currentColorBuffer;\n        assert(undefined !== boundColor && undefined !== textures.color && undefined !== textures.featureId && undefined !== textures.depthAndOrder && undefined !== textures.accumulation && undefined !== textures.revealage);\n        const colorAndPick = [boundColor, textures.featureId, textures.depthAndOrder];\n        if (undefined === depthMs) {\n            this.opaqueAll = FrameBuffer.create(colorAndPick, depth);\n            colorAndPick[0] = textures.color;\n            this.opaqueAndCompositeAll = FrameBuffer.create(colorAndPick, depth);\n        }\n        else {\n            assert(undefined !== textures.colorMsBuff && undefined !== textures.featureIdMsBuff && undefined !== textures.featureIdMsBuffHidden && undefined !== textures.depthAndOrderMsBuff && undefined !== textures.depthAndOrderMsBuffHidden);\n            const colorAndPickMsBuffs = [textures.colorMsBuff, textures.featureIdMsBuff, textures.depthAndOrderMsBuff];\n            const colorAndPickFilters = [GL.MultiSampling.Filter.Linear, GL.MultiSampling.Filter.Nearest, GL.MultiSampling.Filter.Nearest];\n            this.opaqueAll = FrameBuffer.create(colorAndPick, depth, colorAndPickMsBuffs, colorAndPickFilters, depthMs);\n            colorAndPick[0] = textures.color;\n            this.opaqueAndCompositeAll = FrameBuffer.create(colorAndPick, depth, colorAndPickMsBuffs, colorAndPickFilters, depthMs);\n        }\n        return undefined !== this.opaqueAll\n            && undefined !== this.opaqueAndCompositeAll;\n    }\n    enableOcclusion(textures, depth, depthMs) {\n        assert(undefined !== textures.occlusion && undefined !== textures.occlusionBlur);\n        this.occlusion = FrameBuffer.create([textures.occlusion]);\n        this.occlusionBlur = FrameBuffer.create([textures.occlusionBlur]);\n        let rVal = undefined !== this.occlusion && undefined !== this.occlusionBlur;\n        if (undefined === depthMs) {\n            // If not using multisampling then we can use the accumulation and revealage textures for the hidden pick buffers,\n            assert(undefined !== textures.color && undefined !== textures.accumulation && undefined !== textures.revealage);\n            const colorAndPick = [textures.color, textures.accumulation, textures.revealage];\n            this.opaqueAndCompositeAllHidden = FrameBuffer.create(colorAndPick, depth);\n            rVal = rVal && undefined !== this.opaqueAndCompositeAllHidden;\n        }\n        else {\n            // If multisampling then we cannot use the revealage texture for depthAndOrder for the hidden edges since it is of the wrong type for blitting,\n            // so instead use a special depthAndOrderHidden texture just for this purpose.\n            // The featureId texture is not needed for hidden edges, so the accumulation texture can be used for it if we don't blit from the multisample bufffer into it.\n            assert(undefined !== textures.color && undefined !== textures.accumulation && undefined !== textures.depthAndOrderHidden);\n            assert(undefined !== textures.colorMsBuff && undefined !== textures.featureIdMsBuffHidden && undefined !== textures.depthAndOrderMsBuffHidden);\n            const colorAndPick = [textures.color, textures.accumulation, textures.depthAndOrderHidden];\n            const colorAndPickMsBuffs = [textures.colorMsBuff, textures.featureIdMsBuffHidden, textures.depthAndOrderMsBuffHidden];\n            const colorAndPickFilters = [GL.MultiSampling.Filter.Linear, GL.MultiSampling.Filter.Nearest, GL.MultiSampling.Filter.Nearest];\n            this.opaqueAndCompositeAllHidden = FrameBuffer.create(colorAndPick, depth, colorAndPickMsBuffs, colorAndPickFilters, depthMs);\n            // We will also need a frame buffer for copying the real pick data buffers into these hidden edge pick data buffers.\n            const pingPong = [textures.accumulation, textures.depthAndOrderHidden];\n            const pingPongMSBuffs = [textures.featureIdMsBuffHidden, textures.depthAndOrderMsBuffHidden];\n            const pingPongFilters = [GL.MultiSampling.Filter.Nearest, GL.MultiSampling.Filter.Nearest];\n            this.pingPongMS = FrameBuffer.create(pingPong, depth, pingPongMSBuffs, pingPongFilters, depthMs);\n            rVal = rVal && undefined !== this.opaqueAndCompositeAllHidden && (undefined === depthMs || undefined !== this.pingPongMS);\n        }\n        return rVal;\n    }\n    disableOcclusion() {\n        if (undefined !== this.occlusion) {\n            this.occlusion = dispose(this.occlusion);\n            this.occlusionBlur = dispose(this.occlusionBlur);\n        }\n        this.opaqueAndCompositeAllHidden = dispose(this.opaqueAndCompositeAllHidden);\n        this.pingPongMS = dispose(this.pingPongMS);\n    }\n    enableVolumeClassifier(textures, depth, volClassDepth, depthMS, volClassDepthMS) {\n        const boundColor = System.instance.frameBufferStack.currentColorBuffer;\n        if (undefined === boundColor)\n            return;\n        if (undefined === this.stencilSet) {\n            if (undefined !== depthMS) { // if multisampling use the multisampled depth everywhere\n                this.stencilSet = FrameBuffer.create([], depth, [], [], depthMS);\n                this.altZOnly = FrameBuffer.create([], volClassDepth, [], [], volClassDepthMS);\n                this.volClassCreateBlend = FrameBuffer.create([textures.volClassBlend], depth, [textures.volClassBlendMsBuff], [GL.MultiSampling.Filter.Nearest], depthMS);\n                this.volClassCreateBlendAltZ = FrameBuffer.create([textures.volClassBlend], volClassDepth, [textures.volClassBlendMsBuff], [GL.MultiSampling.Filter.Nearest], volClassDepthMS);\n            }\n            else if (undefined !== volClassDepth) {\n                this.stencilSet = FrameBuffer.create([], depth);\n                this.altZOnly = FrameBuffer.create([], volClassDepth);\n                this.volClassCreateBlend = FrameBuffer.create([textures.volClassBlend], depth);\n                this.volClassCreateBlendAltZ = FrameBuffer.create([textures.volClassBlend], volClassDepth);\n            }\n        }\n        if (undefined !== this.opaqueAll && undefined !== this.opaqueAndCompositeAll) {\n            if (undefined !== volClassDepth) {\n                let ids = [this.opaqueAll.getColor(0), this.opaqueAll.getColor(1)];\n                this.idsAndZ = FrameBuffer.create(ids, depth);\n                this.idsAndAltZ = FrameBuffer.create(ids, volClassDepth);\n                ids = [this.opaqueAndCompositeAll.getColor(0), this.opaqueAndCompositeAll.getColor(1)];\n                this.idsAndZComposite = FrameBuffer.create(ids, depth);\n                this.idsAndAltZComposite = FrameBuffer.create(ids, volClassDepth);\n            }\n        }\n    }\n    disableVolumeClassifier() {\n        if (undefined !== this.stencilSet) {\n            this.stencilSet = dispose(this.stencilSet);\n            this.altZOnly = dispose(this.altZOnly);\n            this.volClassCreateBlend = dispose(this.volClassCreateBlend);\n            this.volClassCreateBlendAltZ = dispose(this.volClassCreateBlendAltZ);\n        }\n        if (undefined !== this.idsAndZ) {\n            this.idsAndZ = dispose(this.idsAndZ);\n            this.idsAndAltZ = dispose(this.idsAndAltZ);\n            this.idsAndZComposite = dispose(this.idsAndZComposite);\n            this.idsAndAltZComposite = dispose(this.idsAndAltZComposite);\n        }\n    }\n    enableMultiSampling(textures, depth, depthMS) {\n        this.opaqueColor = dispose(this.opaqueColor);\n        this.opaqueAndCompositeColor = dispose(this.opaqueAndCompositeColor);\n        let rVal = this.initPotentialMSFbos(textures, depth, depthMS);\n        this.opaqueAll = dispose(this.opaqueAll);\n        this.opaqueAndCompositeAll = dispose(this.opaqueAndCompositeAll);\n        rVal = this.initPotentialMSMRTFbos(textures, depth, depthMS);\n        return rVal;\n    }\n    disableMultiSampling(textures, depth) {\n        this.opaqueAll = dispose(this.opaqueAll);\n        this.opaqueAndCompositeAll = dispose(this.opaqueAndCompositeAll);\n        if (!this.initPotentialMSMRTFbos(textures, depth, undefined))\n            return false;\n        this.opaqueColor = dispose(this.opaqueColor);\n        this.opaqueAndCompositeColor = dispose(this.opaqueAndCompositeColor);\n        return this.initPotentialMSFbos(textures, depth, undefined);\n    }\n    get isDisposed() {\n        return undefined === this.opaqueColor && undefined === this.opaqueAndCompositeColor && undefined === this.depthAndOrder\n            && undefined === this.hilite && undefined === this.hiliteUsingStencil && undefined === this.occlusion\n            && undefined === this.occlusionBlur && undefined === this.stencilSet && undefined === this.altZOnly\n            && undefined === this.volClassCreateBlend && undefined === this.volClassCreateBlendAltZ && undefined === this.opaqueAll\n            && undefined === this.opaqueAndCompositeAll && undefined === this.opaqueAndCompositeAllHidden && undefined === this.pingPong\n            && undefined === this.pingPongMS && undefined === this.translucent && undefined === this.clearTranslucent\n            && undefined === this.idsAndZ && undefined === this.idsAndAltZ && undefined === this.idsAndZComposite\n            && undefined === this.idsAndAltZComposite && undefined === this.edlDrawCol;\n    }\n    dispose() {\n        this.opaqueColor = dispose(this.opaqueColor);\n        this.opaqueAndCompositeColor = dispose(this.opaqueAndCompositeColor);\n        this.depthAndOrder = dispose(this.depthAndOrder);\n        this.hilite = dispose(this.hilite);\n        this.hiliteUsingStencil = dispose(this.hiliteUsingStencil);\n        this.occlusion = dispose(this.occlusion);\n        this.occlusionBlur = dispose(this.occlusionBlur);\n        this.stencilSet = dispose(this.stencilSet);\n        this.altZOnly = dispose(this.altZOnly);\n        this.volClassCreateBlend = dispose(this.volClassCreateBlend);\n        this.volClassCreateBlendAltZ = dispose(this.volClassCreateBlendAltZ);\n        this.opaqueAll = dispose(this.opaqueAll);\n        this.opaqueAndCompositeAll = dispose(this.opaqueAndCompositeAll);\n        this.opaqueAndCompositeAll = dispose(this.opaqueAndCompositeAllHidden);\n        this.pingPong = dispose(this.pingPong);\n        this.pingPongMS = dispose(this.pingPongMS);\n        this.translucent = dispose(this.translucent);\n        this.clearTranslucent = dispose(this.clearTranslucent);\n        this.idsAndZ = dispose(this.idsAndZ);\n        this.idsAndAltZ = dispose(this.idsAndAltZ);\n        this.idsAndZComposite = dispose(this.idsAndZComposite);\n        this.idsAndAltZComposite = dispose(this.idsAndAltZComposite);\n        this.edlDrawCol = dispose(this.edlDrawCol);\n    }\n}\nexport function collectGeometryStatistics(geom, stats) {\n    if (undefined !== geom)\n        geom.collectStatistics(stats);\n}\n// Maintains the geometry used to execute screenspace operations for a SceneCompositor.\nclass Geometry {\n    collectStatistics(stats) {\n        collectGeometryStatistics(this.composite, stats);\n        collectGeometryStatistics(this.volClassColorStencil, stats);\n        collectGeometryStatistics(this.volClassCopyZ, stats);\n        collectGeometryStatistics(this.volClassSetBlend, stats);\n        collectGeometryStatistics(this.volClassBlend, stats);\n        collectGeometryStatistics(this.occlusion, stats);\n        collectGeometryStatistics(this.occlusionXBlur, stats);\n        collectGeometryStatistics(this.occlusionYBlur, stats);\n        collectGeometryStatistics(this.copyPickBuffers, stats);\n        collectGeometryStatistics(this.clearTranslucent, stats);\n        collectGeometryStatistics(this.clearPickAndColor, stats);\n    }\n    init(textures) {\n        assert(undefined === this.composite);\n        this.composite = CompositeGeometry.createGeometry(textures.color.getHandle(), textures.accumulation.getHandle(), textures.revealage.getHandle(), textures.hilite.getHandle());\n        if (undefined === this.composite)\n            return false;\n        assert(undefined === this.copyPickBuffers);\n        this.copyPickBuffers = CopyPickBufferGeometry.createGeometry(textures.featureId.getHandle(), textures.depthAndOrder.getHandle());\n        this.clearTranslucent = ViewportQuadGeometry.create(16 /* TechniqueId.OITClearTranslucent */);\n        this.clearPickAndColor = ViewportQuadGeometry.create(21 /* TechniqueId.ClearPickAndColor */);\n        return undefined !== this.copyPickBuffers && undefined !== this.clearTranslucent && undefined !== this.clearPickAndColor;\n    }\n    enableOcclusion(textures, depth) {\n        assert(undefined !== textures.occlusion && undefined !== textures.occlusionBlur && undefined !== textures.depthAndOrder && undefined !== textures.occlusionBlur);\n        this.composite.occlusion = textures.occlusion.getHandle();\n        this.occlusion = AmbientOcclusionGeometry.createGeometry(textures.depthAndOrder.getHandle(), depth.getHandle());\n        this.occlusionXBlur = BlurGeometry.createGeometry(textures.occlusion.getHandle(), textures.depthAndOrder.getHandle(), undefined, new Vector2d(1.0, 0.0), BlurType.NoTest);\n        const depthAndOrderHidden = (undefined === textures.depthAndOrderHidden ? textures.revealage?.getHandle() : textures.depthAndOrderHidden.getHandle());\n        this.occlusionYBlur = BlurGeometry.createGeometry(textures.occlusionBlur.getHandle(), textures.depthAndOrder.getHandle(), depthAndOrderHidden, new Vector2d(0.0, 1.0), BlurType.TestOrder);\n    }\n    disableOcclusion() {\n        this.composite.occlusion = undefined;\n        this.occlusion = dispose(this.occlusion);\n        this.occlusionXBlur = dispose(this.occlusionXBlur);\n        this.occlusionYBlur = dispose(this.occlusionYBlur);\n    }\n    enableVolumeClassifier(textures, depth) {\n        assert(undefined === this.volClassColorStencil && undefined === this.volClassCopyZ && undefined === this.volClassSetBlend && undefined === this.volClassBlend);\n        this.volClassColorStencil = ViewportQuadGeometry.create(20 /* TechniqueId.VolClassColorUsingStencil */);\n        this.volClassCopyZ = SingleTexturedViewportQuadGeometry.createGeometry(depth.getHandle(), 31 /* TechniqueId.VolClassCopyZ */);\n        this.volClassSetBlend = VolumeClassifierGeometry.createVCGeometry(depth.getHandle());\n        this.volClassBlend = SingleTexturedViewportQuadGeometry.createGeometry(textures.volClassBlend.getHandle(), 33 /* TechniqueId.VolClassBlend */);\n        return undefined !== this.volClassColorStencil && undefined !== this.volClassCopyZ && undefined !== this.volClassSetBlend && undefined !== this.volClassBlend;\n    }\n    disableVolumeClassifier() {\n        if (undefined !== this.volClassColorStencil) {\n            this.volClassColorStencil = dispose(this.volClassColorStencil);\n            this.volClassCopyZ = dispose(this.volClassCopyZ);\n            this.volClassSetBlend = dispose(this.volClassSetBlend);\n            this.volClassBlend = dispose(this.volClassBlend);\n        }\n    }\n    get isDisposed() {\n        return undefined === this.composite && undefined === this.occlusion && undefined === this.occlusionXBlur\n            && undefined === this.occlusionYBlur && undefined === this.volClassColorStencil && undefined === this.volClassCopyZ\n            && undefined === this.volClassSetBlend && undefined === this.volClassBlend && undefined === this.copyPickBuffers\n            && undefined === this.clearTranslucent && undefined === this.clearPickAndColor;\n    }\n    dispose() {\n        this.composite = dispose(this.composite);\n        this.occlusion = dispose(this.occlusion);\n        this.occlusionXBlur = dispose(this.occlusionXBlur);\n        this.occlusionYBlur = dispose(this.occlusionYBlur);\n        this.disableVolumeClassifier();\n        this.copyPickBuffers = dispose(this.copyPickBuffers);\n        this.clearTranslucent = dispose(this.clearTranslucent);\n        this.clearPickAndColor = dispose(this.clearPickAndColor);\n    }\n}\n// Represents a view of data read from a region of the frame buffer.\nclass PixelBuffer {\n    get _numPixels() { return this._rect.width * this._rect.height; }\n    getPixelIndex(x, y) {\n        if (x < this._rect.left || y < this._rect.top)\n            return this._numPixels;\n        x -= this._rect.left;\n        y -= this._rect.top;\n        if (x >= this._rect.width || y >= this._rect.height)\n            return this._numPixels;\n        // NB: View coords have origin at top-left; GL at bottom-left. So our rows are upside-down.\n        y = this._rect.height - 1 - y;\n        return y * this._rect.width + x;\n    }\n    getPixel32(data, pixelIndex) {\n        return pixelIndex < data.length ? data[pixelIndex] : undefined;\n    }\n    getFeature(pixelIndex, result) {\n        const featureId = this.getFeatureId(pixelIndex);\n        return undefined !== featureId ? this._batchState.getFeature(featureId, result) : undefined;\n    }\n    getFeatureId(pixelIndex) {\n        return undefined !== this._featureId ? this.getPixel32(this._featureId, pixelIndex) : undefined;\n    }\n    getBatchInfo(pixelIndex) {\n        const featureId = this.getFeatureId(pixelIndex);\n        if (undefined !== featureId) {\n            const batch = this._batchState.find(featureId);\n            if (undefined !== batch)\n                return { featureTable: batch.featureTable, iModel: batch.batchIModel, tileId: batch.tileId, viewAttachmentId: batch.viewAttachmentId };\n        }\n        return undefined;\n    }\n    decodeDepthRgba(depthAndOrder) {\n        this._scratchUint32Array[0] = depthAndOrder;\n        const bytes = this._scratchUint8Array;\n        const fpt = Vector3d.create(bytes[1] / 255.0, bytes[2] / 255.0, bytes[3] / 255.0, this._scratchVector3d);\n        let depth = fpt.dotProduct(this._mult);\n        assert(0.0 <= depth);\n        assert(1.01 >= depth); // rounding error...\n        depth = Math.min(1.0, depth);\n        depth = Math.max(0.0, depth);\n        return depth;\n    }\n    decodeRenderOrderRgba(depthAndOrder) {\n        this._scratchUint32Array[0] = depthAndOrder;\n        const encByte = this._scratchUint8Array[0];\n        const enc = encByte / 255.0;\n        const dec = Math.floor(16.0 * enc + 0.5);\n        return dec;\n    }\n    getPixel(x, y) {\n        const px = this._invalidPixelData;\n        const index = this.getPixelIndex(x, y);\n        if (index >= this._numPixels)\n            return px;\n        // Initialize to the defaults...\n        let distanceFraction = px.distanceFraction;\n        let geometryType = px.type;\n        let planarity = px.planarity;\n        const haveFeatureIds = Pixel.Selector.None !== (this._selector & Pixel.Selector.Feature);\n        const feature = haveFeatureIds ? this.getFeature(index, this._scratchModelFeature) : undefined;\n        const batchInfo = haveFeatureIds ? this.getBatchInfo(index) : undefined;\n        if (Pixel.Selector.None !== (this._selector & Pixel.Selector.GeometryAndDistance) && undefined !== this._depthAndOrder) {\n            const depthAndOrder = this.getPixel32(this._depthAndOrder, index);\n            if (undefined !== depthAndOrder) {\n                distanceFraction = this.decodeDepthRgba(depthAndOrder);\n                const orderWithPlanarBit = this.decodeRenderOrderRgba(depthAndOrder);\n                const order = orderWithPlanarBit & ~8 /* RenderOrder.PlanarBit */;\n                planarity = (orderWithPlanarBit === order) ? Pixel.Planarity.NonPlanar : Pixel.Planarity.Planar;\n                switch (order) {\n                    case 0 /* RenderOrder.None */:\n                        geometryType = Pixel.GeometryType.None;\n                        planarity = Pixel.Planarity.None;\n                        break;\n                    case 1 /* RenderOrder.Background */:\n                    case 2 /* RenderOrder.BlankingRegion */:\n                    case 4 /* RenderOrder.LitSurface */:\n                    case 3 /* RenderOrder.UnlitSurface */:\n                        geometryType = Pixel.GeometryType.Surface;\n                        break;\n                    case 5 /* RenderOrder.Linear */:\n                        geometryType = Pixel.GeometryType.Linear;\n                        break;\n                    case 6 /* RenderOrder.Edge */:\n                        geometryType = Pixel.GeometryType.Edge;\n                        break;\n                    case 7 /* RenderOrder.Silhouette */:\n                        geometryType = Pixel.GeometryType.Silhouette;\n                        break;\n                    default:\n                        // ###TODO: may run into issues with point clouds - they are not written correctly in C++.\n                        assert(false, \"Invalid render order\");\n                        geometryType = Pixel.GeometryType.None;\n                        planarity = Pixel.Planarity.None;\n                        break;\n                }\n            }\n        }\n        let featureTable, iModel, tileId, viewAttachmentId;\n        if (undefined !== batchInfo) {\n            featureTable = batchInfo.featureTable;\n            iModel = batchInfo.iModel;\n            tileId = batchInfo.tileId;\n            viewAttachmentId = batchInfo.viewAttachmentId;\n        }\n        return new Pixel.Data({\n            feature,\n            distanceFraction,\n            type: geometryType,\n            planarity,\n            batchType: featureTable?.type,\n            iModel,\n            tileId,\n            viewAttachmentId,\n        });\n    }\n    constructor(rect, selector, compositor) {\n        this._scratchModelFeature = ModelFeature.create();\n        this._scratchUint32Array = new Uint32Array(1);\n        this._scratchUint8Array = new Uint8Array(this._scratchUint32Array.buffer);\n        this._scratchVector3d = new Vector3d();\n        this._mult = new Vector3d(1.0, 1.0 / 255.0, 1.0 / 65025.0);\n        this._invalidPixelData = new Pixel.Data();\n        this._rect = rect.clone();\n        this._selector = selector;\n        this._batchState = compositor.target.uniforms.batch.state;\n        if (Pixel.Selector.None !== (selector & Pixel.Selector.GeometryAndDistance)) {\n            const depthAndOrderBytes = compositor.readDepthAndOrder(rect);\n            if (undefined !== depthAndOrderBytes)\n                this._depthAndOrder = new Uint32Array(depthAndOrderBytes.buffer);\n            else\n                this._selector &= ~Pixel.Selector.GeometryAndDistance;\n        }\n        if (Pixel.Selector.None !== (selector & Pixel.Selector.Feature)) {\n            const features = compositor.readFeatureIds(rect);\n            if (undefined !== features)\n                this._featureId = new Uint32Array(features.buffer);\n            else\n                this._selector &= ~Pixel.Selector.Feature;\n        }\n    }\n    get isEmpty() { return Pixel.Selector.None === this._selector; }\n    static create(rect, selector, compositor) {\n        const pdb = new PixelBuffer(rect, selector, compositor);\n        return pdb.isEmpty ? undefined : pdb;\n    }\n}\n/** Orchestrates rendering of the scene on behalf of a Target.\n * This base class exists only so we don't have to export all the types of the shared Compositor members like Textures, FrameBuffers, etc.\n * @internal\n */\nexport class SceneCompositor {\n    get needHiddenEdges() { return this._needHiddenEdges; }\n    constructor(target) {\n        this.target = target;\n        this.solarShadowMap = new SolarShadowMap(target);\n        this.eyeDomeLighting = new EyeDomeLighting(target);\n        this._needHiddenEdges = false;\n    }\n    static create(target) {\n        return new Compositor(target);\n    }\n}\n// This describes what types of primitives a compositor should draw. See the `drawPrimitive` method of Compositor.\nvar PrimitiveDrawState;\n(function (PrimitiveDrawState) {\n    PrimitiveDrawState[PrimitiveDrawState[\"Both\"] = 0] = \"Both\";\n    PrimitiveDrawState[PrimitiveDrawState[\"Pickable\"] = 1] = \"Pickable\";\n    PrimitiveDrawState[PrimitiveDrawState[\"NonPickable\"] = 2] = \"NonPickable\";\n})(PrimitiveDrawState || (PrimitiveDrawState = {}));\n// The actual base class. Specializations are provided based on whether or not multiple render targets are supported.\nclass Compositor extends SceneCompositor {\n    forceBufferChange() { this._width = this._height = -1; }\n    get featureIds() { return this.getSamplerTexture(this._readPickDataFromPingPong ? 0 : 1); }\n    get depthAndOrder() { return this.getSamplerTexture(this._readPickDataFromPingPong ? 1 : 2); }\n    get _samplerFbo() { return this._readPickDataFromPingPong ? this._fbos.pingPong : this._fbos.opaqueAll; }\n    getSamplerTexture(index) { return this._samplerFbo.getColor(index); }\n    drawPrimitive(primitive, exec, outputsToPick) {\n        if ((outputsToPick && this._primitiveDrawState !== PrimitiveDrawState.NonPickable) ||\n            (!outputsToPick && this._primitiveDrawState !== PrimitiveDrawState.Pickable))\n            primitive.draw(exec);\n    }\n    clearOpaque(needComposite) {\n        const fbo = needComposite ? this._fbos.opaqueAndCompositeAll : this._fbos.opaqueAll;\n        const system = System.instance;\n        system.frameBufferStack.execute(fbo, true, this.useMsBuffers, () => {\n            // Clear pick data buffers to 0's and color buffer to background color\n            // (0,0,0,0) in elementID0 and ElementID1 buffers indicates invalid element id\n            // (0,0,0,0) in DepthAndOrder buffer indicates render order 0 and encoded depth of 0 (= far plane)\n            system.applyRenderState(this._noDepthMaskRenderState);\n            const params = getDrawParams(this.target, this._geom.clearPickAndColor);\n            this.target.techniques.draw(params);\n            // Clear depth buffer\n            system.applyRenderState(RenderState.defaults); // depthMask == true.\n            system.context.clearDepth(1.0);\n            system.context.clear(GL.BufferBit.Depth);\n        });\n    }\n    renderLayers(commands, needComposite, pass) {\n        const fbo = (needComposite ? this._fbos.opaqueAndCompositeAll : this._fbos.opaqueAll);\n        const useMsBuffers = 1 /* RenderPass.OpaqueLayers */ === pass && fbo.isMultisampled && this.useMsBuffers;\n        this._readPickDataFromPingPong = !useMsBuffers;\n        System.instance.frameBufferStack.execute(fbo, true, useMsBuffers, () => {\n            this.drawPass(commands, pass, true);\n        });\n        this._readPickDataFromPingPong = false;\n    }\n    renderOpaque(commands, compositeFlags, renderForReadPixels) {\n        if (0 /* CompositeFlags.None */ !== (compositeFlags & 4 /* CompositeFlags.AmbientOcclusion */) && !renderForReadPixels) {\n            this.renderOpaqueAO(commands);\n            return;\n        }\n        const needComposite = 0 /* CompositeFlags.None */ !== compositeFlags;\n        const fbStack = System.instance.frameBufferStack;\n        // Output the first 2 passes to color and pick data buffers. (All 3 in the case of rendering for readPixels() or ambient occlusion).\n        let fbo = (needComposite ? this._fbos.opaqueAndCompositeAll : this._fbos.opaqueAll);\n        const useMsBuffers = fbo.isMultisampled && this.useMsBuffers;\n        this._readPickDataFromPingPong = !useMsBuffers; // if multisampling then can read pick textures directly.\n        fbStack.execute(fbo, true, useMsBuffers, () => {\n            this.drawPass(commands, 2 /* RenderPass.OpaqueLinear */);\n            this.drawPass(commands, 3 /* RenderPass.OpaquePlanar */, true);\n            if (renderForReadPixels) {\n                this.drawPass(commands, 4 /* RenderPass.PointClouds */, true); // don't need EDL for this\n                this.drawPass(commands, 5 /* RenderPass.OpaqueGeneral */, true);\n                if (useMsBuffers)\n                    fbo.blitMsBuffersToTextures(true);\n            }\n        });\n        this._readPickDataFromPingPong = false;\n        // The general pass (and following) will not bother to write to pick buffers and so can read from the actual pick buffers.\n        if (!renderForReadPixels) {\n            fbo = (needComposite ? this._fbos.opaqueAndCompositeColor : this._fbos.opaqueColor);\n            fbStack.execute(fbo, true, useMsBuffers, () => {\n                this.drawPass(commands, 5 /* RenderPass.OpaqueGeneral */, false);\n                this.drawPass(commands, 9 /* RenderPass.HiddenEdge */, false);\n            });\n            // assume we are done with MS at this point, so update the non-MS buffers\n            if (useMsBuffers)\n                fbo.blitMsBuffersToTextures(needComposite);\n        }\n    }\n    renderOpaqueAO(commands) {\n        const fbStack = System.instance.frameBufferStack;\n        const haveHiddenEdges = 0 !== commands.getCommands(9 /* RenderPass.HiddenEdge */).length;\n        // Output the linear, planar, and pickable surfaces to color and pick data buffers.\n        let fbo = this._fbos.opaqueAndCompositeAll;\n        const useMsBuffers = fbo.isMultisampled && this.useMsBuffers;\n        this._readPickDataFromPingPong = !useMsBuffers; // if multisampling then can read pick textures directly.\n        fbStack.execute(fbo, true, useMsBuffers, () => {\n            this.drawPass(commands, 2 /* RenderPass.OpaqueLinear */);\n            this.drawPass(commands, 3 /* RenderPass.OpaquePlanar */, true);\n            this._primitiveDrawState = PrimitiveDrawState.Pickable;\n            this.drawPass(commands, 5 /* RenderPass.OpaqueGeneral */, true);\n            this._primitiveDrawState = PrimitiveDrawState.Both;\n            if (useMsBuffers)\n                fbo.blitMsBuffersToTextures(true);\n        });\n        this._readPickDataFromPingPong = false;\n        // Output the non-pickable surfaces and hidden edges to just the color buffer.\n        fbo = this._fbos.opaqueAndCompositeColor;\n        fbStack.execute(fbo, true, useMsBuffers, () => {\n            this._primitiveDrawState = PrimitiveDrawState.NonPickable;\n            this.drawPass(commands, 5 /* RenderPass.OpaqueGeneral */, false);\n            if (haveHiddenEdges)\n                this.drawPass(commands, 9 /* RenderPass.HiddenEdge */, false);\n            this._primitiveDrawState = PrimitiveDrawState.Both;\n        });\n        if (useMsBuffers)\n            fbo.blitMsBuffersToTextures(true);\n        // If there are no hidden edges, then we're done & can run the AO passes using the normal depthAndOrder texture.\n        if (haveHiddenEdges) {\n            // AO needs the pick data (orderAndDepth) for the hidden edges.  We don't want it in with the other pick data though since they are not pickable, so we will use other textures.\n            // If not multisampling we will re-use the ping-pong/transparency textures since we are done with ping-ponging at this point and transparency happens later.\n            // If multisampling then we will use the accumulation texture for featureIDs and a special texture for depthAndOrder since the revealage texture is not the right type for multisampling.\n            // First we will need to copy what's in the pick buffers so far into the hidden pick buffers.\n            System.instance.applyRenderState(this._noDepthMaskRenderState);\n            fbo = (useMsBuffers ? this._fbos.pingPongMS : this._fbos.pingPong);\n            fbStack.execute(fbo, true, useMsBuffers, () => {\n                const params = getDrawParams(this.target, this._geom.copyPickBuffers);\n                this.target.techniques.draw(params);\n            });\n            if (useMsBuffers)\n                fbo.blitMsBuffersToTextures(false, 1); // only want to blit the depth/order target\n            // Now draw the hidden edges, using an fbo which places their depth/order into the hidden pick buffers.\n            // Since we are not writing to the actual pick buffers we let this._readPickDataFromPingPong remain false.\n            fbo = this._fbos.opaqueAndCompositeAllHidden;\n            this._primitiveDrawState = PrimitiveDrawState.Pickable;\n            fbStack.execute(fbo, true, useMsBuffers, () => {\n                this.drawPass(commands, 9 /* RenderPass.HiddenEdge */, false);\n            });\n            this._primitiveDrawState = PrimitiveDrawState.Both;\n            if (useMsBuffers) {\n                // Only want to blit the color and depth/order targets as the featureId target is not blit-able and will generate a GL error.\n                fbo.blitMsBuffersToTextures(false, 0);\n                fbo.blitMsBuffersToTextures(false, 2);\n            }\n            this._needHiddenEdges = false;\n        }\n        this._needHiddenEdges = haveHiddenEdges; // this will cause the alternate renderAndOrder texture with the hidden edges to be read for the 2nd AO blur pass.\n        this.renderAmbientOcclusion();\n        this._needHiddenEdges = false;\n    }\n    renderPointClouds(commands, compositeFlags) {\n        const is3d = 2 /* FrustumUniformType.Perspective */ === this.target.uniforms.frustum.type;\n        // separate individual point clouds and get their point cloud settings\n        const pointClouds = [];\n        let pcs;\n        const cmds = commands.getCommands(4 /* RenderPass.PointClouds */);\n        let curPC;\n        let pushDepth = 0;\n        for (const cmd of cmds) {\n            if (\"pushBranch\" === cmd.opcode) { // should be first command\n                ++pushDepth;\n                if (pushDepth === 1) {\n                    pcs = cmd.branch.branch.realityModelDisplaySettings?.pointCloud;\n                    this.target.uniforms.realityModel.pointCloud.updateRange(cmd.branch.branch.realityModelRange, this.target, cmd.branch.localToWorldTransform, is3d);\n                    pointClouds.push(curPC = { pcs, cmds: [cmd] });\n                }\n                else {\n                    assert(undefined !== curPC);\n                    curPC.cmds.push(cmd);\n                }\n            }\n            else {\n                if (\"popBranch\" === cmd.opcode)\n                    --pushDepth;\n                assert(undefined !== curPC);\n                curPC.cmds.push(cmd);\n            }\n        }\n        const needComposite = 0 /* CompositeFlags.None */ !== compositeFlags;\n        const fbo = (needComposite ? this._fbos.opaqueAndCompositeColor : this._fbos.opaqueColor);\n        const useMsBuffers = fbo.isMultisampled && this.useMsBuffers;\n        const system = System.instance;\n        const fbStack = system.frameBufferStack;\n        this._readPickDataFromPingPong = false;\n        for (const pc of pointClouds) {\n            pcs = pc.pcs;\n            let edlOn = pcs?.edlMode !== \"off\" && is3d;\n            if (edlOn) {\n                if (undefined === this._textures.hilite)\n                    edlOn = false;\n                else {\n                    // create fbo on fly if not present, or has changed (from MS)\n                    // ###TODO consider not drawing point clouds to MS buffers, at least if EDL, it isn't worth the overhead.\n                    //         would have to blit depth before draw, use depth for draw, then run shader to copy depth back to MSAA\n                    //         at end, wherever color buf changed (test alpha, else discard)\n                    //         this would also simplify this code considerably\n                    let drawColBufs;\n                    if (undefined !== this._fbos.edlDrawCol)\n                        drawColBufs = this._fbos.edlDrawCol.getColorTargets(useMsBuffers, 0);\n                    if (undefined === this._fbos.edlDrawCol || this._textures.hilite !== drawColBufs?.tex || this._textures.hiliteMsBuff !== drawColBufs.msBuf) {\n                        this._fbos.edlDrawCol = dispose(this._fbos.edlDrawCol);\n                        const filters = [GL.MultiSampling.Filter.Linear];\n                        if (useMsBuffers)\n                            this._fbos.edlDrawCol = FrameBuffer.create([this._textures.hilite], this._depth, useMsBuffers && this._textures.hiliteMsBuff ? [this._textures.hiliteMsBuff] : undefined, filters, this._depthMS);\n                        else\n                            this._fbos.edlDrawCol = FrameBuffer.create([this._textures.hilite], this._depth);\n                    }\n                    if (undefined === this._fbos.edlDrawCol)\n                        edlOn = false;\n                    else { // can draw EDL\n                        // first draw pointcloud to borrowed hilite texture(MS) and regular depth(MS) buffers\n                        fbStack.execute(this._fbos.edlDrawCol, true, useMsBuffers, () => {\n                            system.context.clearColor(0, 0, 0, 0);\n                            system.context.clear(GL.BufferBit.Color);\n                            system.applyRenderState(this.getRenderState(4 /* RenderPass.PointClouds */));\n                            this.target.techniques.execute(this.target, pc.cmds, 4 /* RenderPass.PointClouds */);\n                        });\n                        if (useMsBuffers)\n                            this._fbos.edlDrawCol.blitMsBuffersToTextures(true, 0); // need to read the non-MS depth and hilite buffers\n                        // next process buffers to generate EDL (depth buffer is passed during init)\n                        this.target.beginPerfMetricRecord(\"Calc EDL\"); // ### todo keep? (probably)\n                        const sts = this.eyeDomeLighting.draw({\n                            edlMode: pc.pcs?.edlMode === \"full\" ? EDLMode.Full : EDLMode.On,\n                            edlFilter: !!pcs?.edlFilter,\n                            useMsBuffers,\n                            inputTex: this._textures.hilite,\n                            curFbo: fbo,\n                        });\n                        this.target.endPerfMetricRecord();\n                        if (!sts) {\n                            edlOn = false;\n                        }\n                    }\n                }\n            }\n            if (!edlOn) {\n                // draw the regular way\n                fbStack.execute(fbo, true, useMsBuffers, () => {\n                    system.applyRenderState(this.getRenderState(4 /* RenderPass.PointClouds */));\n                    this.target.techniques.execute(this.target, pc.cmds, 4 /* RenderPass.PointClouds */);\n                });\n            }\n        }\n    }\n    renderForVolumeClassification(commands, compositeFlags, renderForReadPixels) {\n        const needComposite = 0 /* CompositeFlags.None */ !== compositeFlags;\n        const needAO = 0 /* CompositeFlags.None */ !== (compositeFlags & 4 /* CompositeFlags.AmbientOcclusion */);\n        const fbStack = System.instance.frameBufferStack;\n        if (renderForReadPixels || needAO) {\n            this._readPickDataFromPingPong = true;\n            fbStack.execute(needComposite ? this._fbos.opaqueAndCompositeAll : this._fbos.opaqueAll, true, this.useMsBuffers, () => {\n                this.drawPass(commands, 5 /* RenderPass.OpaqueGeneral */, true, 20 /* RenderPass.VolumeClassifiedRealityData */);\n            });\n        }\n        else {\n            this._readPickDataFromPingPong = false;\n            fbStack.execute(needComposite ? this._fbos.opaqueAndCompositeColor : this._fbos.opaqueColor, true, this.useMsBuffers, () => {\n                this.drawPass(commands, 5 /* RenderPass.OpaqueGeneral */, false, 20 /* RenderPass.VolumeClassifiedRealityData */);\n            });\n        }\n    }\n    renderIndexedClassifierForReadPixels(cmds, state, renderForIntersectingVolumes, needComposite) {\n        this._readPickDataFromPingPong = true;\n        const fbo = (renderForIntersectingVolumes ? (needComposite ? this._fbos.idsAndZComposite : this._fbos.idsAndZ)\n            : (needComposite ? this._fbos.idsAndAltZComposite : this._fbos.idsAndAltZ));\n        System.instance.frameBufferStack.execute(fbo, true, false, () => {\n            System.instance.applyRenderState(state);\n            this.target.techniques.execute(this.target, cmds, 5 /* RenderPass.OpaqueGeneral */);\n        });\n        this._readPickDataFromPingPong = false;\n    }\n    clearTranslucent() {\n        System.instance.applyRenderState(this._noDepthMaskRenderState);\n        System.instance.frameBufferStack.execute(this._fbos.clearTranslucent, true, false, () => {\n            const params = getDrawParams(this.target, this._geom.clearTranslucent);\n            this.target.techniques.draw(params);\n        });\n    }\n    renderTranslucent(commands) {\n        System.instance.frameBufferStack.execute(this._fbos.translucent, true, false, () => {\n            this.drawPass(commands, 8 /* RenderPass.Translucent */);\n        });\n    }\n    getBackgroundFbo(needComposite) {\n        return needComposite ? this._fbos.opaqueAndCompositeColor : this._fbos.opaqueColor;\n    }\n    pingPong() {\n        if (this._fbos.opaqueAll.isMultisampled && this.useMsBuffers) {\n            // If we are multisampling we can just blit the FeatureId and DepthAndOrder MS buffers to their textures.\n            this._fbos.opaqueAll.blitMsBuffersToTextures(false, 1);\n            this._fbos.opaqueAll.blitMsBuffersToTextures(false, 2);\n        }\n        else {\n            System.instance.applyRenderState(this._noDepthMaskRenderState);\n            System.instance.frameBufferStack.execute(this._fbos.pingPong, true, this.useMsBuffers, () => {\n                const params = getDrawParams(this.target, this._geom.copyPickBuffers);\n                this.target.techniques.draw(params);\n            });\n        }\n    }\n    get antialiasSamples() { return this._antialiasSamples; }\n    get useMsBuffers() { return this._antialiasSamples > 1 && !this.target.isReadPixelsInProgress; }\n    enableVolumeClassifierFbos(textures, depth, volClassDepth, depthMS, volClassDepthMS) {\n        this._fbos.enableVolumeClassifier(textures, depth, volClassDepth, depthMS, volClassDepthMS);\n    }\n    disableVolumeClassifierFbos() {\n        this._fbos.disableVolumeClassifier();\n    }\n    /** This function generates a texture that contains ambient occlusion information to be applied later. */\n    renderAmbientOcclusion() {\n        const system = System.instance;\n        // Render unblurred ambient occlusion based on depth buffer\n        let fbo = this._fbos.occlusion;\n        this.target.beginPerfMetricRecord(\"Compute AO\");\n        system.frameBufferStack.execute(fbo, true, false, () => {\n            System.instance.applyRenderState(RenderState.defaults);\n            const params = getDrawParams(this.target, this._geom.occlusion);\n            this.target.techniques.draw(params);\n        });\n        this.target.endPerfMetricRecord();\n        // Render the X-blurred ambient occlusion based on unblurred ambient occlusion\n        fbo = this._fbos.occlusionBlur;\n        this.target.beginPerfMetricRecord(\"Blur AO X\");\n        system.frameBufferStack.execute(fbo, true, false, () => {\n            System.instance.applyRenderState(RenderState.defaults);\n            const params = getDrawParams(this.target, this._geom.occlusionXBlur);\n            this.target.techniques.draw(params);\n        });\n        this.target.endPerfMetricRecord();\n        // Render the Y-blurred ambient occlusion based on X-blurred ambient occlusion (render into original occlusion framebuffer)\n        fbo = this._fbos.occlusion;\n        this.target.beginPerfMetricRecord(\"Blur AO Y\");\n        system.frameBufferStack.execute(fbo, true, false, () => {\n            System.instance.applyRenderState(RenderState.defaults);\n            const params = getDrawParams(this.target, this._geom.occlusionYBlur);\n            this.target.techniques.draw(params);\n        });\n        this.target.endPerfMetricRecord();\n    }\n    constructor(target) {\n        super(target);\n        this._width = -1;\n        this._height = -1;\n        this._includeOcclusion = false;\n        this._textures = new Textures();\n        this._readPickDataFromPingPong = true;\n        this._opaqueRenderState = new RenderState();\n        this._layerRenderState = new RenderState();\n        this._translucentRenderState = new RenderState();\n        this._hiliteRenderState = new RenderState();\n        this._noDepthMaskRenderState = new RenderState();\n        this._backgroundMapRenderState = new RenderState();\n        this._pointCloudRenderState = new RenderState();\n        this._debugStencil = 0; // 0 to draw stencil volumes normally, 1 to draw as opaque, 2 to draw blended\n        this._haveVolumeClassifier = false;\n        this._antialiasSamples = 1;\n        this._viewProjectionMatrix = new Matrix4();\n        this._primitiveDrawState = PrimitiveDrawState.Both; // used by drawPrimitive to decide whether a primitive needs to be drawn.\n        this._fbos = new FrameBuffers();\n        this._geom = new Geometry();\n        this._opaqueRenderState.flags.depthTest = true;\n        this._pointCloudRenderState.flags.depthTest = true;\n        this._translucentRenderState.flags.depthMask = false;\n        this._translucentRenderState.flags.blend = this._translucentRenderState.flags.depthTest = true;\n        this._translucentRenderState.blend.setBlendFuncSeparate(GL.BlendFactor.One, GL.BlendFactor.Zero, GL.BlendFactor.One, GL.BlendFactor.OneMinusSrcAlpha);\n        this._hiliteRenderState.flags.depthMask = false;\n        this._hiliteRenderState.flags.blend = true;\n        this._hiliteRenderState.blend.functionDestRgb = GL.BlendFactor.One;\n        this._hiliteRenderState.blend.functionDestAlpha = GL.BlendFactor.One;\n        this._noDepthMaskRenderState.flags.depthMask = false;\n        // Background map supports transparency, even when depth is off, which is mostly useless but should blend with background color / skybox.\n        this._backgroundMapRenderState.flags.depthMask = false;\n        this._backgroundMapRenderState.flags.blend = true;\n        this._backgroundMapRenderState.blend.setBlendFunc(GL.BlendFactor.One, GL.BlendFactor.OneMinusSrcAlpha);\n        // Can't write depth without enabling depth test - so make depth test always pass\n        this._layerRenderState.flags.depthTest = true;\n        this._layerRenderState.depthFunc = GL.DepthFunc.Always;\n        this._layerRenderState.blend.setBlendFunc(GL.BlendFactor.One, GL.BlendFactor.OneMinusSrcAlpha);\n    }\n    collectStatistics(stats) {\n        if (undefined !== this._depth)\n            stats.addTextureAttachment(this._depth.bytesUsed);\n        if (undefined !== this._depthMS)\n            stats.addTextureAttachment(this._depthMS.bytesUsed);\n        this._textures.collectStatistics(stats);\n        this._geom.collectStatistics(stats);\n    }\n    preDraw() {\n        const rect = this.target.viewRect;\n        const width = rect.width;\n        const height = rect.height;\n        const includeOcclusion = this.target.wantAmbientOcclusion;\n        const wantVolumeClassifier = (undefined !== this.target.activeVolumeClassifierProps);\n        let wantAntialiasSamples = this.target.antialiasSamples <= 1 ? 1 : this.target.antialiasSamples;\n        if (wantAntialiasSamples > System.instance.maxAntialiasSamples)\n            wantAntialiasSamples = System.instance.maxAntialiasSamples;\n        const changeAntialiasSamples = (this._antialiasSamples > 1 && wantAntialiasSamples > 1 && this._antialiasSamples !== wantAntialiasSamples);\n        // If not yet initialized, or dimensions changed, or antialiasing changed the number of samples, initialize.\n        if (undefined === this._textures.accumulation || width !== this._width || height !== this._height || changeAntialiasSamples) {\n            this._width = width;\n            this._height = height;\n            this._antialiasSamples = wantAntialiasSamples;\n            // init() first calls dispose(), which releases all of our fbos, textures, etc, and resets the _includeOcclusion flag.\n            if (!this.init()) {\n                assert(false, \"Failed to initialize scene compositor\");\n                return false;\n            }\n        }\n        else if (this._antialiasSamples !== wantAntialiasSamples) {\n            // Turn on or off multisampling.  Rather than just re-initializing, we can save the\n            // non multisampled textures & FBOs and just try to add or delete the multisampled ones.\n            this._antialiasSamples = wantAntialiasSamples;\n            if (wantVolumeClassifier && this._haveVolumeClassifier) {\n                // Multisampling and volume classification buffers are somewhat co-dependent so if volume classification is on\n                // and is staying on, just disable volume classifiers and let them get re-enabled later.\n                this.disableVolumeClassifierFbos();\n                this._geom.disableVolumeClassifier();\n                this._textures.disableVolumeClassifier();\n                if (undefined !== this._vcAltDepthStencil) {\n                    this._vcAltDepthStencil.dispose();\n                    this._vcAltDepthStencil = undefined;\n                }\n                this._haveVolumeClassifier = false;\n            }\n            if (includeOcclusion && this._includeOcclusion) {\n                // Multisampling and AO buffers are also somewhat co-dependent, so if AO is on\n                // and is staying on, just disable AO and let it get re-enabled later.\n                this._geom.disableOcclusion();\n                this._fbos.disableOcclusion();\n                this._textures.disableOcclusion();\n                this._includeOcclusion = false;\n            }\n            if (this._antialiasSamples > 1) {\n                if (!this.enableMultiSampling()) {\n                    assert(false, \"Failed to initialize multisampling buffers\");\n                    return false;\n                }\n            }\n            else {\n                if (!this.disableMultiSampling()) {\n                    assert(false, \"Failed to initialize multisampling buffers\");\n                    return false;\n                }\n            }\n        }\n        // Allocate or free ambient occlusion-related resources if necessary\n        if (includeOcclusion !== this._includeOcclusion) {\n            this._includeOcclusion = includeOcclusion;\n            if (includeOcclusion) {\n                if (!this._textures.enableOcclusion(width, height, this._antialiasSamples)) {\n                    assert(false, \"Failed to initialize occlusion textures\");\n                    return false;\n                }\n                if (!this._fbos.enableOcclusion(this._textures, this._depth, this._depthMS)) {\n                    assert(false, \"Failed to initialize occlusion frame buffers\");\n                    return false;\n                }\n                this._geom.enableOcclusion(this._textures, this._depth);\n            }\n            else {\n                this._geom.disableOcclusion();\n                this._fbos.disableOcclusion();\n                this._textures.disableOcclusion();\n            }\n        }\n        // Allocate or free volume classifier-related resources if necessary.\n        if (wantVolumeClassifier !== this._haveVolumeClassifier) {\n            if (wantVolumeClassifier) {\n                this._vcAltDepthStencil = System.instance.createDepthBuffer(width, height);\n                if (undefined !== this._depthMS)\n                    this._vcAltDepthStencilMS = System.instance.createDepthBuffer(width, height, this._antialiasSamples);\n                if (undefined === this._vcAltDepthStencil || (undefined !== this._depthMS && undefined === this._vcAltDepthStencilMS))\n                    return false;\n                if (!this._textures.enableVolumeClassifier(width, height, this._antialiasSamples))\n                    return false;\n                if (!this._geom.enableVolumeClassifier(this._textures, this._depth))\n                    return false;\n                this.enableVolumeClassifierFbos(this._textures, this._depth, this._vcAltDepthStencil, this._depthMS, this._vcAltDepthStencilMS);\n                this._haveVolumeClassifier = true;\n            }\n            else {\n                this.disableVolumeClassifierFbos();\n                this._geom.disableVolumeClassifier();\n                this._textures.disableVolumeClassifier();\n                if (undefined !== this._vcAltDepthStencil) {\n                    this._vcAltDepthStencil.dispose();\n                    this._vcAltDepthStencil = undefined;\n                }\n                this._haveVolumeClassifier = false;\n            }\n        }\n        return true;\n    }\n    draw(commands) {\n        if (!this.preDraw())\n            return;\n        const compositeFlags = commands.compositeFlags;\n        const needComposite = 0 /* CompositeFlags.None */ !== compositeFlags;\n        // Clear output targets\n        this.target.frameStatsCollector.beginTime(\"opaqueTime\");\n        this.target.beginPerfMetricRecord(\"Clear Opaque\");\n        this.clearOpaque(needComposite);\n        this.target.endPerfMetricRecord();\n        this.target.frameStatsCollector.endTime(\"opaqueTime\");\n        this.target.frameStatsCollector.beginTime(\"backgroundTime\"); // includes skybox\n        // Render the background\n        this.target.beginPerfMetricRecord(\"Render Background\");\n        this.renderBackground(commands, needComposite);\n        this.target.endPerfMetricRecord();\n        // Render the sky box\n        this.target.beginPerfMetricRecord(\"Render Skybox\");\n        this.renderSkyBox(commands, needComposite);\n        this.target.endPerfMetricRecord();\n        // Render the background map graphics\n        this.target.beginPerfMetricRecord(\"Render Background Map\");\n        this.renderBackgroundMap(commands, needComposite);\n        this.target.endPerfMetricRecord();\n        this.target.frameStatsCollector.endTime(\"backgroundTime\");\n        // Enable clipping\n        this.target.beginPerfMetricRecord(\"Enable Clipping\");\n        this.target.pushViewClip();\n        this.target.endPerfMetricRecord();\n        // Render volume classification first so that we only classify the reality data\n        this.target.frameStatsCollector.beginTime(\"classifiersTime\");\n        this.target.beginPerfMetricRecord(\"Render VolumeClassification\");\n        this.renderVolumeClassification(commands, compositeFlags, false);\n        this.target.endPerfMetricRecord();\n        this.target.frameStatsCollector.endTime(\"classifiersTime\");\n        this.target.frameStatsCollector.beginTime(\"opaqueTime\");\n        // Render layers\n        this.target.beginPerfMetricRecord(\"Render Opaque Layers\");\n        this.renderLayers(commands, needComposite, 1 /* RenderPass.OpaqueLayers */);\n        this.target.endPerfMetricRecord();\n        // Render opaque geometry\n        this.target.frameStatsCollector.beginTime(\"onRenderOpaqueTime\");\n        IModelFrameLifecycle.onRenderOpaque.raiseEvent({\n            commands,\n            needComposite,\n            compositeFlags,\n            fbo: this.getBackgroundFbo(needComposite),\n            frameBufferStack: System.instance.frameBufferStack,\n        });\n        this.target.frameStatsCollector.endTime(\"onRenderOpaqueTime\");\n        // Render point cloud geometry with possible EDL\n        this.target.beginPerfMetricRecord(\"Render PointClouds\");\n        this.renderPointClouds(commands, compositeFlags);\n        this.target.endPerfMetricRecord();\n        // Render opaque geometry\n        this.target.beginPerfMetricRecord(\"Render Opaque\");\n        this.renderOpaque(commands, compositeFlags, false);\n        this.target.endPerfMetricRecord();\n        this.target.frameStatsCollector.endTime(\"opaqueTime\");\n        this.target.frameStatsCollector.beginTime(\"translucentTime\");\n        // Render translucent layers\n        this.target.beginPerfMetricRecord(\"Render Translucent Layers\");\n        this.renderLayers(commands, needComposite, 7 /* RenderPass.TranslucentLayers */);\n        this.target.endPerfMetricRecord();\n        if (needComposite) {\n            this._geom.composite.update(compositeFlags);\n            this.target.beginPerfMetricRecord(\"Render Translucent\");\n            this.clearTranslucent();\n            this.renderTranslucent(commands);\n            this.target.endPerfMetricRecord();\n            this.target.frameStatsCollector.endTime(\"translucentTime\");\n            this.target.beginPerfMetricRecord(\"Render Hilite\");\n            this.renderHilite(commands);\n            this.target.endPerfMetricRecord();\n            this.target.beginPerfMetricRecord(\"Composite\");\n            this.composite();\n            this.target.endPerfMetricRecord();\n        }\n        else\n            this.target.frameStatsCollector.endTime(\"translucentTime\");\n        // Render overlay Layers\n        this.target.frameStatsCollector.beginTime(\"overlaysTime\");\n        this.target.beginPerfMetricRecord(\"Render Overlay Layers\");\n        this.renderLayers(commands, false, 11 /* RenderPass.OverlayLayers */);\n        this.target.endPerfMetricRecord();\n        this.target.frameStatsCollector.endTime(\"overlaysTime\");\n        this.target.popViewClip();\n    }\n    get fullHeight() { return this.target.viewRect.height; }\n    drawForReadPixels(commands, sceneOverlays, worldOverlayDecorations, viewOverlayDecorations) {\n        this.target.beginPerfMetricRecord(\"Render Background\", true);\n        if (!this.preDraw()) {\n            this.target.endPerfMetricRecord(true); // End Render Background record if returning\n            assert(false);\n            return;\n        }\n        this.clearOpaque(false);\n        this.target.endPerfMetricRecord(true);\n        // On entry the RenderCommands has been initialized for all scene graphics and pickable decorations with the exception of world overlays.\n        // It's possible we have no pickable scene graphics or decorations, but do have pickable world overlays.\n        const haveRenderCommands = !commands.isEmpty;\n        if (haveRenderCommands) {\n            this.target.beginPerfMetricRecord(\"Enable Clipping\", true);\n            this.target.pushViewClip();\n            this.target.endPerfMetricRecord(true);\n            this.target.beginPerfMetricRecord(\"Render VolumeClassification\", true);\n            this.renderVolumeClassification(commands, 0 /* CompositeFlags.None */, true);\n            this.target.endPerfMetricRecord(true);\n            // RenderPass.BackgroundMap is used only when depth is turned off for the map.\n            // Ensure it draws before any opaque geometry (including layers), without depth.\n            this.target.beginPerfMetricRecord(\"Render background map\", true);\n            this.target.drawingBackgroundForReadPixels = true;\n            this.renderLayers(commands, false, 15 /* RenderPass.BackgroundMap */);\n            this.target.drawingBackgroundForReadPixels = false;\n            this.target.endPerfMetricRecord(true);\n            this.target.beginPerfMetricRecord(\"Render Opaque Layers\", true);\n            this.renderLayers(commands, false, 1 /* RenderPass.OpaqueLayers */);\n            this.target.endPerfMetricRecord(true);\n            // PointClouds are rendered in Opaque pass for readPixels\n            this.target.beginPerfMetricRecord(\"Render Opaque\", true);\n            this.renderOpaque(commands, 0 /* CompositeFlags.None */, true);\n            this.target.endPerfMetricRecord(true);\n            this.target.beginPerfMetricRecord(\"Render Translucent Layers\", true);\n            this.renderLayers(commands, false, 7 /* RenderPass.TranslucentLayers */);\n            this.target.endPerfMetricRecord(true);\n            this.target.beginPerfMetricRecord(\"Render Overlay Layers\", true);\n            this.renderLayers(commands, false, 11 /* RenderPass.OverlayLayers */);\n            this.target.endPerfMetricRecord(true);\n            this.target.popViewClip();\n        }\n        if (!sceneOverlays.length && !worldOverlayDecorations?.length && !viewOverlayDecorations?.length)\n            return;\n        // Now populate the opaque passes with any pickable world overlays\n        this.target.beginPerfMetricRecord(\"Overlay Draws\", true);\n        commands.initForPickOverlays(sceneOverlays, worldOverlayDecorations, viewOverlayDecorations);\n        if (commands.isEmpty) {\n            this.target.endPerfMetricRecord(true); // End Overlay Draws record if returning\n            return;\n        }\n        // Clear the depth buffer so that overlay decorations win the depth test.\n        // (If *only* overlays exist, then clearOpaque() above already took care of this).\n        if (haveRenderCommands) {\n            const system = System.instance;\n            system.frameBufferStack.execute(this._fbos.opaqueColor, true, this.useMsBuffers, () => {\n                system.applyRenderState(RenderState.defaults);\n                system.context.clearDepth(1.0);\n                system.context.clear(GL.BufferBit.Depth);\n            });\n        }\n        // Render overlays as opaque into the pick buffers. Make sure we use the decoration state (to ignore symbology overrides, esp. the non-locatable flag).\n        const decState = this.target.decorationsState;\n        const vf = decState.viewFlags;\n        if (vf.transparency)\n            decState.viewFlags = vf.copy({ transparency: false });\n        this.renderOpaque(commands, 0 /* CompositeFlags.None */, true);\n        this.target.endPerfMetricRecord();\n        decState.viewFlags = vf;\n    }\n    readPixels(rect, selector) {\n        return PixelBuffer.create(rect, selector, this);\n    }\n    readDepthAndOrder(rect) { return this.readFrameBuffer(rect, this._fbos.depthAndOrder); }\n    readFeatureIds(rect) {\n        const tex = this._textures.featureId;\n        if (undefined === tex)\n            return undefined;\n        const fbo = FrameBuffer.create([tex]);\n        const result = this.readFrameBuffer(rect, fbo);\n        dispose(fbo);\n        return result;\n    }\n    updateSolarShadows(context) {\n        this.solarShadowMap.update(context);\n    }\n    get screenSpaceEffectFbo() {\n        assert(undefined !== this._fbos.hilite);\n        return this._fbos.hilite;\n    }\n    readFrameBuffer(rect, fbo) {\n        if (undefined === fbo || !Debug.isValidFrameBuffer)\n            return undefined;\n        // NB: ViewRect origin at top-left; GL origin at bottom-left\n        const bottom = this.fullHeight - rect.bottom;\n        const gl = System.instance.context;\n        const bytes = new Uint8Array(rect.width * rect.height * 4);\n        let result = bytes;\n        System.instance.frameBufferStack.execute(fbo, true, false, () => {\n            try {\n                gl.readPixels(rect.left, bottom, rect.width, rect.height, gl.RGBA, gl.UNSIGNED_BYTE, bytes);\n            }\n            catch (e) {\n                result = undefined;\n            }\n        });\n        return result;\n    }\n    get isDisposed() {\n        return undefined === this._depth\n            && undefined === this._vcAltDepthStencil\n            && !this._includeOcclusion\n            && this._textures.isDisposed\n            && this._fbos.isDisposed\n            && this._geom.isDisposed\n            && !this._haveVolumeClassifier\n            && this.solarShadowMap.isDisposed\n            && this.eyeDomeLighting.isDisposed;\n    }\n    dispose() {\n        this.reset();\n        dispose(this.solarShadowMap);\n        dispose(this.eyeDomeLighting);\n    }\n    // Resets anything that depends on the dimensions of the render target.\n    // Does *not* dispose the solar shadow map.\n    reset() {\n        this._depth = dispose(this._depth);\n        this._depthMS = dispose(this._depthMS);\n        this._vcAltDepthStencil = dispose(this._vcAltDepthStencil);\n        this._includeOcclusion = false;\n        dispose(this._textures);\n        dispose(this._fbos);\n        dispose(this._geom);\n        this._haveVolumeClassifier = false;\n        this.eyeDomeLighting.reset();\n    }\n    init() {\n        this.reset();\n        this._depth = System.instance.createDepthBuffer(this._width, this._height, 1);\n        if (this._antialiasSamples > 1)\n            this._depthMS = System.instance.createDepthBuffer(this._width, this._height, this._antialiasSamples);\n        else\n            this._depthMS = undefined;\n        if (this._depth !== undefined) {\n            return this._textures.init(this._width, this._height, this._antialiasSamples)\n                && this._fbos.init(this._textures, this._depth, this._depthMS)\n                && this._geom.init(this._textures)\n                && this.eyeDomeLighting.init(this._width, this._height, this._depth);\n        }\n        return false;\n    }\n    enableMultiSampling() {\n        // Assume that non-multisampled stuff is already allocated.  Just need to add multisampled textures, buffers, & geometry.\n        assert(undefined === this._depthMS && undefined !== this._depth);\n        this._depthMS = System.instance.createDepthBuffer(this._width, this._height, this._antialiasSamples);\n        if (undefined === this._depthMS)\n            return false;\n        if (!this._textures.enableMultiSampling(this._width, this._height, this._antialiasSamples))\n            return false;\n        assert(undefined !== this._depth && undefined !== this._depthMS);\n        return this._fbos.enableMultiSampling(this._textures, this._depth, this._depthMS);\n    }\n    disableMultiSampling() {\n        assert(undefined !== this._depth);\n        if (!this._fbos.disableMultiSampling(this._textures, this._depth))\n            return false;\n        // Want to disable multisampling without deleting & reallocating other stuff.\n        this._depthMS = dispose(this._depthMS);\n        assert(undefined !== this._depth);\n        return this._textures.disableMultiSampling();\n    }\n    renderBackgroundMap(commands, needComposite) {\n        const cmds = commands.getCommands(15 /* RenderPass.BackgroundMap */);\n        if (0 === cmds.length) {\n            return;\n        }\n        const fbStack = System.instance.frameBufferStack;\n        const fbo = this.getBackgroundFbo(needComposite);\n        fbStack.execute(fbo, true, this.useMsBuffers, () => {\n            System.instance.applyRenderState(this.getRenderState(15 /* RenderPass.BackgroundMap */));\n            this.target.techniques.execute(this.target, cmds, 15 /* RenderPass.BackgroundMap */);\n        });\n    }\n    renderSkyBox(commands, needComposite) {\n        const cmds = commands.getCommands(14 /* RenderPass.SkyBox */);\n        if (0 === cmds.length) {\n            return;\n        }\n        const fbStack = System.instance.frameBufferStack;\n        const fbo = this.getBackgroundFbo(needComposite);\n        fbStack.execute(fbo, true, this.useMsBuffers, () => {\n            System.instance.applyRenderState(this.getRenderState(14 /* RenderPass.SkyBox */));\n            this.target.techniques.execute(this.target, cmds, 14 /* RenderPass.SkyBox */);\n        });\n    }\n    renderBackground(commands, needComposite) {\n        const cmds = commands.getCommands(0 /* RenderPass.Background */);\n        if (0 === cmds.length)\n            return;\n        const fbStack = System.instance.frameBufferStack;\n        const fbo = this.getBackgroundFbo(needComposite);\n        fbStack.execute(fbo, true, this.useMsBuffers, () => {\n            System.instance.applyRenderState(this.getRenderState(0 /* RenderPass.Background */));\n            this.target.techniques.execute(this.target, cmds, 0 /* RenderPass.Background */);\n        });\n    }\n    createVolumeClassifierStates() {\n        // If we have already created a branch state for use in rendering the volume classifiers we must at least swap out its symbology overrides for the current one.\n        if (undefined !== this._vcBranchState) {\n            this._vcBranchState.symbologyOverrides = this.target.uniforms.branch.top.symbologyOverrides;\n            return;\n        }\n        // Create a BranchState and several RenderStates to use when drawing the classifier volumes.\n        // The BranchState needs to be created every time in case the symbology overrides changes.\n        // It is based off of the current state, but turns off unnecessary and unwanted options, lighting being the most important.\n        const top = this.target.uniforms.branch.top;\n        const viewFlags = top.viewFlags.copy({\n            renderMode: RenderMode.SmoothShade,\n            wiremesh: false,\n            lighting: false,\n            forceSurfaceDiscard: false,\n            hiddenEdges: false,\n            visibleEdges: false,\n            materials: false,\n            textures: false,\n            transparency: false,\n        });\n        this._vcBranchState = new BranchState({\n            symbologyOverrides: top.symbologyOverrides,\n            viewFlags,\n            transform: Transform.createIdentity(),\n            clipVolume: top.clipVolume,\n            planarClassifier: top.planarClassifier,\n            iModel: top.iModel,\n            is3d: top.is3d,\n            edgeSettings: top.edgeSettings,\n        });\n        this._vcSetStencilRenderState = new RenderState();\n        this._vcCopyZRenderState = new RenderState();\n        this._vcColorRenderState = new RenderState();\n        this._vcBlendRenderState = new RenderState();\n        this._vcPickDataRenderState = new RenderState();\n        this._vcCopyZRenderState.flags.depthTest = true;\n        this._vcCopyZRenderState.flags.depthMask = true;\n        this._vcCopyZRenderState.depthFunc = GL.DepthFunc.Always;\n        this._vcCopyZRenderState.flags.colorWrite = true;\n        this._vcCopyZRenderState.flags.stencilTest = true;\n        this._vcCopyZRenderState.stencil.frontFunction.function = GL.StencilFunction.Always;\n        this._vcCopyZRenderState.stencil.frontOperation.fail = GL.StencilOperation.Zero;\n        this._vcCopyZRenderState.stencil.frontOperation.zFail = GL.StencilOperation.Zero;\n        this._vcCopyZRenderState.stencil.frontOperation.zPass = GL.StencilOperation.Zero;\n        this._vcCopyZRenderState.stencil.backFunction.function = GL.StencilFunction.Always;\n        this._vcCopyZRenderState.stencil.backOperation.fail = GL.StencilOperation.Zero;\n        this._vcCopyZRenderState.stencil.backOperation.zFail = GL.StencilOperation.Zero;\n        this._vcCopyZRenderState.stencil.backOperation.zPass = GL.StencilOperation.Zero;\n        this._vcSetStencilRenderState.flags.depthTest = true;\n        this._vcSetStencilRenderState.flags.depthMask = false;\n        this._vcSetStencilRenderState.flags.colorWrite = false;\n        this._vcSetStencilRenderState.flags.stencilTest = true;\n        this._vcSetStencilRenderState.depthFunc = GL.DepthFunc.LessOrEqual;\n        this._vcSetStencilRenderState.stencil.frontFunction.function = GL.StencilFunction.Always;\n        this._vcSetStencilRenderState.stencil.frontOperation.zFail = GL.StencilOperation.IncrWrap;\n        this._vcSetStencilRenderState.stencil.backFunction.function = GL.StencilFunction.Always;\n        this._vcSetStencilRenderState.stencil.backOperation.zFail = GL.StencilOperation.DecrWrap;\n        this._vcPickDataRenderState.flags.depthTest = false;\n        this._vcPickDataRenderState.flags.depthMask = false;\n        this._vcPickDataRenderState.flags.colorWrite = true;\n        this._vcPickDataRenderState.flags.stencilTest = true;\n        this._vcPickDataRenderState.flags.cull = true;\n        this._vcPickDataRenderState.cullFace = GL.CullFace.Front;\n        this._vcPickDataRenderState.stencil.backFunction.function = GL.StencilFunction.NotEqual;\n        this._vcPickDataRenderState.stencil.backOperation.zPass = GL.StencilOperation.Zero; // this will clear the stencil\n        // Let all of the operations remain at Keep so that the stencil will remain in tact for the subsequent blend draw to the color buffer.\n        this._vcColorRenderState.flags.depthTest = false;\n        this._vcColorRenderState.flags.depthMask = false;\n        this._vcColorRenderState.flags.colorWrite = true;\n        this._vcColorRenderState.flags.stencilTest = true;\n        this._vcColorRenderState.cullFace = GL.CullFace.Front;\n        this._vcColorRenderState.stencil.frontFunction.function = GL.StencilFunction.NotEqual;\n        this._vcColorRenderState.stencil.frontOperation.fail = GL.StencilOperation.Zero;\n        this._vcColorRenderState.stencil.frontOperation.zFail = GL.StencilOperation.Zero;\n        this._vcColorRenderState.stencil.frontOperation.zPass = GL.StencilOperation.Zero; // this will clear the stencil\n        this._vcColorRenderState.stencil.backFunction.function = GL.StencilFunction.NotEqual;\n        this._vcColorRenderState.stencil.backOperation.fail = GL.StencilOperation.Zero;\n        this._vcColorRenderState.stencil.backOperation.zFail = GL.StencilOperation.Zero;\n        this._vcColorRenderState.stencil.backOperation.zPass = GL.StencilOperation.Zero; // this will clear the stencil\n        this._vcColorRenderState.flags.blend = true; // blend func and color will be set before using\n        this._vcBlendRenderState.flags.depthTest = false;\n        this._vcBlendRenderState.flags.depthMask = false;\n        this._vcBlendRenderState.flags.colorWrite = true;\n        this._vcBlendRenderState.flags.stencilTest = false;\n        this._vcBlendRenderState.flags.blend = true;\n        this._vcBlendRenderState.blend.setBlendFuncSeparate(GL.BlendFactor.SrcAlpha, GL.BlendFactor.Zero, GL.BlendFactor.OneMinusSrcAlpha, GL.BlendFactor.One);\n        if (this._debugStencil > 0) {\n            this._vcDebugRenderState = new RenderState();\n            this._vcDebugRenderState.flags.depthTest = true;\n            this._vcDebugRenderState.flags.blend = true;\n            this._vcDebugRenderState.blend.setBlendFunc(GL.BlendFactor.OneMinusConstColor, GL.BlendFactor.ConstColor);\n            this._vcDebugRenderState.blend.color = [0.67, 0.67, 0.67, 1.0];\n        }\n    }\n    setAllStencilOps(state, op) {\n        state.stencil.frontOperation.fail = op;\n        state.stencil.frontOperation.zFail = op;\n        state.stencil.frontOperation.zPass = op;\n        state.stencil.backOperation.fail = op;\n        state.stencil.backOperation.zFail = op;\n        state.stencil.backOperation.zPass = op;\n    }\n    renderIndexedVolumeClassifier(cmdsByIndex, needComposite) {\n        // Set the stencil for the given classifier stencil volume.\n        System.instance.frameBufferStack.execute(this._fbos.stencilSet, false, this.useMsBuffers, () => {\n            this.target.pushState(this._vcBranchState);\n            System.instance.applyRenderState(this._vcSetStencilRenderState);\n            this.target.techniques.executeForIndexedClassifier(this.target, cmdsByIndex, 6 /* RenderPass.Classification */);\n            this.target.popBranch();\n        });\n        // Process the stencil for the pick data.\n        this.renderIndexedClassifierForReadPixels(cmdsByIndex, this._vcPickDataRenderState, true, needComposite);\n    }\n    renderVolumeClassification(commands, compositeFlags, renderForReadPixels) {\n        // Sometimes we need to render the classifier stencil volumes one at a time, if so draw them from the cmdsByIndex list\n        const cmds = commands.getCommands(6 /* RenderPass.Classification */);\n        const cmdsByIndex = commands.getCommands(17 /* RenderPass.ClassificationByIndex */);\n        let numCmdsPerClassifier = 0;\n        for (const cmd of cmdsByIndex) { // Figure out how many commands there are per index/primitive\n            numCmdsPerClassifier++;\n            if (\"drawPrimitive\" === cmd.opcode) {\n                numCmdsPerClassifier += numCmdsPerClassifier - 1;\n                break;\n            }\n        }\n        const cmdsForVC = commands.getCommands(20 /* RenderPass.VolumeClassifiedRealityData */);\n        if (!this.target.activeVolumeClassifierProps || (renderForReadPixels && 0 === cmds.length) || 0 === cmdsForVC.length)\n            return;\n        let outsideFlags = this.target.activeVolumeClassifierProps.flags.outside;\n        let insideFlags = this.target.activeVolumeClassifierProps.flags.inside;\n        if (this.target.wantThematicDisplay) {\n            if (outsideFlags !== SpatialClassifierOutsideDisplay.Off)\n                outsideFlags = SpatialClassifierOutsideDisplay.On;\n            if (insideFlags !== SpatialClassifierInsideDisplay.Off)\n                insideFlags = SpatialClassifierInsideDisplay.On;\n        }\n        // Render the geometry which we are going to classify.\n        this.renderForVolumeClassification(commands, compositeFlags, renderForReadPixels);\n        this.createVolumeClassifierStates();\n        const fbStack = System.instance.frameBufferStack;\n        const needComposite = 0 /* CompositeFlags.None */ !== compositeFlags;\n        const fboColorAndZ = this.getBackgroundFbo(needComposite);\n        if (this._debugStencil > 0) {\n            fbStack.execute(fboColorAndZ, true, this.useMsBuffers, () => {\n                if (1 === this._debugStencil) {\n                    System.instance.applyRenderState(this.getRenderState(5 /* RenderPass.OpaqueGeneral */));\n                    this.target.techniques.execute(this.target, cmds, 5 /* RenderPass.OpaqueGeneral */);\n                }\n                else {\n                    this.target.pushState(this._vcBranchState);\n                    System.instance.applyRenderState(this._vcDebugRenderState);\n                    this.target.techniques.execute(this.target, cmds, 6 /* RenderPass.Classification */);\n                    this.target.popBranch();\n                }\n            });\n            return;\n        }\n        if (undefined === this._fbos.altZOnly || undefined === this._fbos.stencilSet)\n            return;\n        if (renderForReadPixels && this.target.vcSupportIntersectingVolumes) {\n            // Clear the stencil.\n            fbStack.execute(this._fbos.stencilSet, false, this.useMsBuffers, () => {\n                System.instance.context.clearStencil(0);\n                System.instance.context.clear(GL.BufferBit.Stencil);\n            });\n            if (this._antialiasSamples > 1 && undefined !== this._depthMS && this.useMsBuffers)\n                this._fbos.stencilSet.blitMsBuffersToTextures(true, -1); // make sure that the Z buffer that we are about to read has been blitted\n            for (let i = 0; i < cmdsByIndex.length; i += numCmdsPerClassifier)\n                this.renderIndexedVolumeClassifier(cmdsByIndex.slice(i, i + numCmdsPerClassifier), needComposite);\n            return;\n        }\n        const needOutsideDraw = SpatialClassifierOutsideDisplay.On !== outsideFlags;\n        const needInsideDraw = SpatialClassifierInsideDisplay.On !== insideFlags;\n        const doColorByElement = SpatialClassifierInsideDisplay.ElementColor === insideFlags || renderForReadPixels;\n        const doColorByElementForIntersectingVolumes = this.target.vcSupportIntersectingVolumes;\n        const needAltZ = (doColorByElement && !doColorByElementForIntersectingVolumes) || needOutsideDraw;\n        let zOnlyFbo = this._fbos.stencilSet;\n        let volClassBlendFbo = this._fbos.volClassCreateBlend;\n        let volClassBlendReadZTexture = this._vcAltDepthStencil.getHandle();\n        let volClassBlendReadZTextureFbo = this._fbos.altZOnly;\n        if (!needAltZ) {\n            // Initialize the blend texture and the stencil.\n            assert(undefined !== volClassBlendFbo);\n            fbStack.execute(volClassBlendFbo, true, this.useMsBuffers, () => {\n                System.instance.context.clearColor(0.0, 0.0, 0.0, 0.0);\n                System.instance.context.clearStencil(0);\n                System.instance.context.clear(GL.BufferBit.Color | GL.BufferBit.Stencil);\n            });\n        }\n        else {\n            // If we are doing color-by-element for the inside do not care about intersecting volumes or we need to color the outside\n            // then we need to copy the Z buffer and set up a different zbuffer/stencil to render in.\n            zOnlyFbo = this._fbos.altZOnly;\n            volClassBlendFbo = this._fbos.volClassCreateBlendAltZ;\n            assert(undefined !== volClassBlendFbo);\n            volClassBlendReadZTexture = this._depth.getHandle();\n            volClassBlendReadZTextureFbo = this._fbos.stencilSet;\n            if (this._antialiasSamples > 1 && undefined !== this._depthMS && this.useMsBuffers)\n                volClassBlendReadZTextureFbo.blitMsBuffersToTextures(true, -1); // make sure that the Z buffer that we are about to read has been blitted\n            // Copy the current Z into the Alt-Z.  At the same time go ahead and clear the stencil and the blend texture.\n            fbStack.execute(volClassBlendFbo, true, this.useMsBuffers, () => {\n                this.target.pushState(this.target.decorationsState);\n                System.instance.applyRenderState(this._vcCopyZRenderState);\n                this.target.techniques.draw(getDrawParams(this.target, this._geom.volClassCopyZ)); // This method uses the EXT_frag_depth extension\n                System.instance.bindTexture2d(TextureUnit.Zero, undefined);\n                this.target.popBranch();\n            });\n        }\n        if (renderForReadPixels) {\n            // Set the stencil for all of the classifier volumes.\n            System.instance.frameBufferStack.execute(this._fbos.altZOnly, false, this.useMsBuffers, () => {\n                this.target.pushState(this._vcBranchState);\n                System.instance.applyRenderState(this._vcSetStencilRenderState);\n                this.target.techniques.execute(this.target, cmds, 6 /* RenderPass.Classification */);\n                // After we create the stencil we need to clear the Z for the next step (so also must turn on z writing temporarily).\n                this._vcSetStencilRenderState.flags.depthMask = true;\n                System.instance.applyRenderState(this._vcSetStencilRenderState);\n                System.instance.context.clearDepth(1.0);\n                System.instance.context.clear(GL.BufferBit.Depth);\n                this._vcSetStencilRenderState.flags.depthMask = false;\n                this.target.popBranch();\n                System.instance.bindTexture2d(TextureUnit.Two, undefined);\n                System.instance.bindTexture2d(TextureUnit.Five, undefined);\n            });\n            this.target.pushState(this._vcBranchState);\n            this._vcColorRenderState.flags.depthTest = true;\n            this._vcColorRenderState.flags.depthMask = true;\n            this._vcColorRenderState.flags.cull = true;\n            this._vcColorRenderState.flags.blend = false;\n            this.setAllStencilOps(this._vcColorRenderState, GL.StencilOperation.Keep); // don't clear the stencil so that all classifiers behind reality mesh will still draw\n            this.target.activeVolumeClassifierTexture = this._geom.volClassCopyZ.texture;\n            if (this._antialiasSamples > 1 && undefined !== this._depthMS && this.useMsBuffers)\n                this._fbos.stencilSet.blitMsBuffersToTextures(true, -1); // make sure that the Z buffer that we are about to read has been blitted\n            this.renderIndexedClassifierForReadPixels(cmds, this._vcColorRenderState, false, needComposite);\n            this.target.activeVolumeClassifierTexture = undefined;\n            this._vcColorRenderState.flags.depthTest = false;\n            this._vcColorRenderState.flags.depthMask = false;\n            this._vcColorRenderState.flags.cull = false;\n            this._vcColorRenderState.flags.blend = true;\n            this.setAllStencilOps(this._vcColorRenderState, GL.StencilOperation.Zero);\n            System.instance.context.clearStencil(0); // must clear stencil afterwards since we had to draw with stencil set to KEEP\n            System.instance.context.clear(GL.BufferBit.Stencil);\n            this.target.popBranch();\n            System.instance.bindTexture2d(TextureUnit.PlanarClassification, undefined);\n            return;\n        }\n        if ((needOutsideDraw && cmds.length > 0) || (needInsideDraw && !(doColorByElement && doColorByElementForIntersectingVolumes))) {\n            // Set the stencil using all of the volume classifiers.  This will be used to do the outside and/or the inside if they need to be done.\n            // If we are not modifying the outside and the inside is using color-by-element for intersecting volumes, then the stencil will get set later.\n            fbStack.execute(zOnlyFbo, false, this.useMsBuffers, () => {\n                this.target.pushState(this._vcBranchState);\n                System.instance.applyRenderState(this._vcSetStencilRenderState);\n                this.target.techniques.execute(this.target, cmds, 6 /* RenderPass.Classification */);\n                this.target.popBranch();\n                System.instance.bindTexture2d(TextureUnit.Two, undefined);\n                System.instance.bindTexture2d(TextureUnit.Five, undefined);\n            });\n        }\n        if (needOutsideDraw) {\n            if (this._antialiasSamples > 1 && undefined !== this._depthMS && this.useMsBuffers)\n                volClassBlendReadZTextureFbo.blitMsBuffersToTextures(true, -1); // make sure that the Z buffer that we are about to read has been blitted\n            fbStack.execute(volClassBlendFbo, false, this.useMsBuffers, () => {\n                this._geom.volClassSetBlend.boundaryType = BoundaryType.Outside;\n                this._geom.volClassSetBlend.texture = volClassBlendReadZTexture;\n                this.target.pushState(this.target.decorationsState);\n                this._vcColorRenderState.flags.blend = false;\n                this._vcColorRenderState.stencil.frontFunction.function = GL.StencilFunction.Equal; // temp swap the functions so we get what is not set in the stencil\n                this._vcColorRenderState.stencil.backFunction.function = GL.StencilFunction.Equal;\n                if (needInsideDraw)\n                    this.setAllStencilOps(this._vcColorRenderState, GL.StencilOperation.Keep); // don't clear the stencil since we'll use it again\n                System.instance.applyRenderState(this._vcColorRenderState);\n                const params = getDrawParams(this.target, this._geom.volClassSetBlend);\n                this.target.techniques.draw(params);\n                this._vcColorRenderState.flags.blend = true;\n                this._vcColorRenderState.stencil.frontFunction.function = GL.StencilFunction.NotEqual;\n                this._vcColorRenderState.stencil.backFunction.function = GL.StencilFunction.NotEqual;\n                if (needInsideDraw)\n                    this.setAllStencilOps(this._vcColorRenderState, GL.StencilOperation.Zero);\n                this.target.popBranch();\n                System.instance.bindTexture2d(TextureUnit.Zero, undefined); // unbind the depth buffer that we used as a texture as we'll need it as an output later\n            });\n        }\n        if (needInsideDraw) {\n            if (!doColorByElement) {\n                // In this case our stencil is already set and it is all getting colored the same, so we can just draw with a viewport quad to color it.\n                if (this._antialiasSamples > 1 && undefined !== this._depthMS && this.useMsBuffers)\n                    volClassBlendReadZTextureFbo.blitMsBuffersToTextures(true, -1); // make sure that the Z buffer that we are about to read has been blitted\n                fbStack.execute(volClassBlendFbo, false, this.useMsBuffers, () => {\n                    this._geom.volClassSetBlend.boundaryType = BoundaryType.Inside;\n                    this._geom.volClassSetBlend.texture = volClassBlendReadZTexture;\n                    this.target.pushState(this.target.decorationsState);\n                    this._vcColorRenderState.flags.blend = false;\n                    System.instance.applyRenderState(this._vcColorRenderState);\n                    const params = getDrawParams(this.target, this._geom.volClassSetBlend);\n                    this.target.techniques.draw(params);\n                    this._vcColorRenderState.flags.blend = true;\n                    this.target.popBranch();\n                    System.instance.bindTexture2d(TextureUnit.Zero, undefined);\n                });\n            }\n            else if (doColorByElementForIntersectingVolumes) {\n                // If we have intersecting classifier volumes, then we must stencil them individually to get their colors in the blend texture.\n                for (let i = 0; i < cmdsByIndex.length; i += numCmdsPerClassifier) {\n                    const nxtCmds = cmdsByIndex.slice(i, i + numCmdsPerClassifier);\n                    // Set the stencil for this one classifier.\n                    fbStack.execute(zOnlyFbo, false, this.useMsBuffers, () => {\n                        this.target.pushState(this._vcBranchState);\n                        System.instance.applyRenderState(this._vcSetStencilRenderState);\n                        this.target.techniques.execute(this.target, nxtCmds, 6 /* RenderPass.Classification */);\n                        this.target.popBranch();\n                    });\n                    // Process the stencil. Just render the volume normally (us opaque pass), but use blending to modify the source alpha that gets written to the blend texture.\n                    fbStack.execute(volClassBlendFbo, true, this.useMsBuffers, () => {\n                        this.target.pushState(this._vcBranchState);\n                        this._vcColorRenderState.blend.color = [1.0, 1.0, 1.0, 0.35];\n                        this._vcColorRenderState.blend.setBlendFuncSeparate(GL.BlendFactor.One, GL.BlendFactor.ConstAlpha, GL.BlendFactor.Zero, GL.BlendFactor.Zero);\n                        this._vcColorRenderState.flags.cull = true;\n                        System.instance.applyRenderState(this._vcColorRenderState);\n                        this.target.activeVolumeClassifierTexture = undefined; // make sure this texture is undefined so we do not use the planar classification shader\n                        this.target.techniques.execute(this.target, nxtCmds, 5 /* RenderPass.OpaqueGeneral */);\n                        this._vcColorRenderState.flags.cull = false;\n                        this.target.popBranch();\n                    });\n                }\n            }\n            else {\n                if (this._antialiasSamples > 1 && undefined !== this._depthMS && this.useMsBuffers)\n                    this._fbos.stencilSet.blitMsBuffersToTextures(true, -1); // make sure that the Z buffer that we are about to read has been blitted\n                fbStack.execute(volClassBlendFbo, false, this.useMsBuffers, () => {\n                    // For coloring the inside by element color we will draw the inside using the the classifiers themselves.\n                    // To do this we need to first clear our Alt-Z.  The shader will then test and write Z and will discard\n                    // anything that is in front of the reality model by reading the Z texture from the standard Z buffer (which has the reality mesh Z's in it).\n                    // What we end up with is the closest volume behind the terrain which works if the classifier volumes do not intersect.\n                    // Since we need the blend texture to have alpha in it, we will use blending just to modify the alpha that gets written.\n                    this.target.pushState(this._vcBranchState);\n                    this._vcColorRenderState.blend.color = [1.0, 1.0, 1.0, 0.35];\n                    this._vcColorRenderState.blend.setBlendFuncSeparate(GL.BlendFactor.One, GL.BlendFactor.ConstAlpha, GL.BlendFactor.Zero, GL.BlendFactor.Zero);\n                    this._vcColorRenderState.flags.depthTest = true;\n                    this._vcColorRenderState.flags.depthMask = true;\n                    this._vcColorRenderState.flags.cull = true;\n                    this.setAllStencilOps(this._vcColorRenderState, GL.StencilOperation.Keep); // don't clear the stencil so that all classifiers behind reality mesh will still draw\n                    System.instance.applyRenderState(this._vcColorRenderState);\n                    System.instance.context.clearDepth(1.0);\n                    System.instance.context.clear(GL.BufferBit.Depth);\n                    this.target.activeVolumeClassifierTexture = this._geom.volClassCopyZ.texture;\n                    this.target.techniques.execute(this.target, cmds, 5 /* RenderPass.OpaqueGeneral */);\n                    this.target.activeVolumeClassifierTexture = undefined;\n                    this._vcColorRenderState.flags.depthTest = false;\n                    this._vcColorRenderState.flags.depthMask = false;\n                    this._vcColorRenderState.flags.cull = false;\n                    this.setAllStencilOps(this._vcColorRenderState, GL.StencilOperation.Zero);\n                    System.instance.context.clearStencil(0); // must clear stencil afterwards since we had to draw with stencil set to KEEP\n                    System.instance.context.clear(GL.BufferBit.Stencil);\n                    this.target.popBranch();\n                    System.instance.bindTexture2d(TextureUnit.PlanarClassification, undefined);\n                });\n            }\n        }\n        // Handle the selected classifier volumes.  Note though that if color-by-element is being used, then the selected volumes are already hilited\n        // and this stage can be skipped.  In order for this to work the list of commands needs to get reduced to only the ones which draw hilited volumes.\n        // We cannot use the hillite shader to draw them since it doesn't handle logZ properly (it doesn't need to since it is only used elsewhere when Z write is turned off)\n        // and we don't really want another whole set of hilite shaders just for this.\n        const cmdsSelected = extractHilitedVolumeClassifierCommands(this.target.hilites, commands.getCommands(16 /* RenderPass.HiliteClassification */));\n        commands.replaceCommands(16 /* RenderPass.HiliteClassification */, cmdsSelected); // replace the hilite command list for use in hilite pass as well.\n        // if (cmdsSelected.length > 0 && insideFlags !== this.target.activeVolumeClassifierProps!.flags.selected) {\n        if (!doColorByElement && cmdsSelected.length > 0 && insideFlags !== SpatialClassifierInsideDisplay.Hilite) { // assume selected ones are always hilited\n            // Set the stencil using just the hilited volume classifiers.\n            fbStack.execute(this._fbos.stencilSet, false, this.useMsBuffers, () => {\n                this.target.pushState(this._vcBranchState);\n                System.instance.applyRenderState(this._vcSetStencilRenderState);\n                if (needAltZ) {\n                    // If we are using the alternate Z then the stencil that goes with the original Z has not been cleared yet, so clear it here.\n                    System.instance.context.clearStencil(0);\n                    System.instance.context.clear(GL.BufferBit.Stencil);\n                }\n                this.target.techniques.execute(this.target, cmdsSelected, 6 /* RenderPass.Classification */);\n                this.target.popBranch();\n            });\n            if (this._antialiasSamples > 1 && undefined !== this._depthMS && this.useMsBuffers)\n                this._fbos.altZOnly.blitMsBuffersToTextures(true, -1); // make sure that the Z buffer that we are about to read has been blitted\n            fbStack.execute(this._fbos.volClassCreateBlend, false, this.useMsBuffers, () => {\n                this._geom.volClassSetBlend.boundaryType = BoundaryType.Selected;\n                this._geom.volClassSetBlend.texture = this._vcAltDepthStencil.getHandle(); // need to attach the alt depth instead of the real one since it is bound to the frame buffer\n                this.target.pushState(this.target.decorationsState);\n                this._vcColorRenderState.flags.blend = false;\n                System.instance.applyRenderState(this._vcColorRenderState);\n                const params = getDrawParams(this.target, this._geom.volClassSetBlend);\n                this.target.techniques.draw(params);\n                this._vcColorRenderState.flags.blend = true;\n                this.target.popBranch();\n                System.instance.bindTexture2d(TextureUnit.Zero, undefined);\n            });\n        }\n        // Now modify the color of the reality mesh by using the blend texture to blend with it.\n        if (this._antialiasSamples > 1 && undefined !== this._depthMS && this.useMsBuffers) {\n            volClassBlendFbo.blitMsBuffersToTextures(false); // make sure the volClassBlend texture that we are about to read has been blitted\n        }\n        fbStack.execute(fboColorAndZ, false, this.useMsBuffers, () => {\n            this.target.pushState(this.target.decorationsState);\n            this._vcBlendRenderState.blend.setBlendFuncSeparate(GL.BlendFactor.SrcAlpha, GL.BlendFactor.Zero, GL.BlendFactor.OneMinusSrcAlpha, GL.BlendFactor.One);\n            System.instance.applyRenderState(this._vcBlendRenderState);\n            const params = getDrawParams(this.target, this._geom.volClassBlend);\n            this.target.techniques.draw(params);\n            this.target.popBranch();\n            System.instance.bindTexture2d(TextureUnit.Zero, undefined);\n        });\n        // Process the flashed classifier if there is one.\n        // Like the selected volumes, we do not need to do this step if we used by-element-color since the flashing is included in the element color.\n        const flashedClassifierCmds = extractFlashedVolumeClassifierCommands(this.target.flashedId, cmdsByIndex, numCmdsPerClassifier);\n        if (undefined !== flashedClassifierCmds && !doColorByElement) {\n            // Set the stencil for this one classifier.\n            fbStack.execute(this._fbos.stencilSet, false, this.useMsBuffers, () => {\n                this.target.pushState(this._vcBranchState);\n                System.instance.applyRenderState(this._vcSetStencilRenderState);\n                this.target.techniques.executeForIndexedClassifier(this.target, flashedClassifierCmds, 5 /* RenderPass.OpaqueGeneral */);\n                this.target.popBranch();\n            });\n            // Process the stencil to flash the contents.\n            fbStack.execute(fboColorAndZ, true, this.useMsBuffers, () => {\n                this.target.pushState(this.target.decorationsState);\n                this._vcColorRenderState.blend.color = [1.0, 1.0, 1.0, this.target.flashIntensity * 0.2];\n                this._vcColorRenderState.blend.setBlendFuncSeparate(GL.BlendFactor.ConstAlpha, GL.BlendFactor.Zero, GL.BlendFactor.One, GL.BlendFactor.One);\n                System.instance.applyRenderState(this._vcColorRenderState);\n                const params = getDrawParams(this.target, this._geom.volClassColorStencil);\n                this.target.techniques.draw(params);\n                this.target.popBranch();\n            });\n        }\n    }\n    renderHilite(commands) {\n        const system = System.instance;\n        system.frameBufferStack.execute(this._fbos.hilite, true, false, () => {\n            // Clear the hilite buffer.\n            system.context.clearColor(0, 0, 0, 0);\n            system.context.clear(GL.BufferBit.Color);\n            // Draw the normal hilite geometry.\n            this.drawPass(commands, 10 /* RenderPass.Hilite */);\n        });\n        // Process planar classifiers\n        const planarClassifierCmds = commands.getCommands(18 /* RenderPass.HilitePlanarClassification */);\n        if (0 !== planarClassifierCmds.length) {\n            system.frameBufferStack.execute(this._fbos.hiliteUsingStencil, true, false, () => {\n                system.applyRenderState(this._opaqueRenderState);\n                this.target.techniques.execute(this.target, planarClassifierCmds, 18 /* RenderPass.HilitePlanarClassification */);\n            });\n        }\n        // Process the volume classifiers.\n        const vcHiliteCmds = commands.getCommands(16 /* RenderPass.HiliteClassification */);\n        if (0 !== vcHiliteCmds.length && undefined !== this._vcBranchState) {\n            // Set the stencil for the given classifier stencil volume.\n            system.frameBufferStack.execute(this._fbos.stencilSet, false, false, () => {\n                this.target.pushState(this._vcBranchState);\n                system.applyRenderState(this._vcSetStencilRenderState);\n                this.target.techniques.execute(this.target, vcHiliteCmds, 10 /* RenderPass.Hilite */);\n                this.target.popBranch();\n            });\n            // Process the stencil for the hilite data.\n            system.frameBufferStack.execute(this._fbos.hiliteUsingStencil, true, false, () => {\n                system.applyRenderState(this._vcPickDataRenderState);\n                this.target.techniques.execute(this.target, vcHiliteCmds, 10 /* RenderPass.Hilite */);\n            });\n        }\n    }\n    composite() {\n        System.instance.applyRenderState(RenderState.defaults);\n        const params = getDrawParams(this.target, this._geom.composite);\n        this.target.techniques.draw(params);\n    }\n    getRenderState(pass) {\n        switch (pass) {\n            case 1 /* RenderPass.OpaqueLayers */:\n            case 7 /* RenderPass.TranslucentLayers */:\n            case 11 /* RenderPass.OverlayLayers */:\n                // NB: During pick, we don't want blending - it will mess up our pick buffer data and we don't care about the color data.\n                // During normal draw, we don't use the pick buffers for anything, and we want color blending.\n                // (We get away with this because surfaces always draw before their edges, and we're not depth-testing, so edges always draw atop surfaces without pick buffer testing).\n                this._layerRenderState.flags.blend = !this.target.isReadPixelsInProgress;\n                // Transparent non-overlay Layers are drawn between opaque and translucent passes. Test depth, don't write it, so that they blend with opaque.\n                this._layerRenderState.flags.depthMask = 7 /* RenderPass.TranslucentLayers */ !== pass;\n                this._layerRenderState.depthFunc = (7 /* RenderPass.TranslucentLayers */ === pass) ? GL.DepthFunc.Default : GL.DepthFunc.Always;\n                return this._layerRenderState;\n            case 2 /* RenderPass.OpaqueLinear */:\n            case 3 /* RenderPass.OpaquePlanar */:\n            case 5 /* RenderPass.OpaqueGeneral */:\n            case 18 /* RenderPass.HilitePlanarClassification */:\n                return this._opaqueRenderState;\n            case 8 /* RenderPass.Translucent */:\n                return this._translucentRenderState;\n            case 10 /* RenderPass.Hilite */:\n                return this._hiliteRenderState;\n            case 15 /* RenderPass.BackgroundMap */:\n                return this._backgroundMapRenderState;\n            case 4 /* RenderPass.PointClouds */:\n                return this._pointCloudRenderState;\n            default:\n                return this._noDepthMaskRenderState;\n        }\n    }\n    drawPass(commands, pass, pingPong = false, cmdPass = 255 /* RenderPass.None */) {\n        const cmds = commands.getCommands(255 /* RenderPass.None */ !== cmdPass ? cmdPass : pass);\n        if (0 === cmds.length) {\n            return;\n        }\n        else if (pingPong) {\n            this.pingPong();\n        }\n        System.instance.applyRenderState(this.getRenderState(pass));\n        this.target.techniques.execute(this.target, cmds, pass);\n    }\n}\n//# sourceMappingURL=SceneCompositor.js.map",
      "start": 1693508122254,
      "end": 1693508122418,
      "sourcemaps": null
    }
  ]
}
