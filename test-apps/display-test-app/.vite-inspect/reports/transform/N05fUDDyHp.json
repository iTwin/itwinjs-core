{
  "resolvedId": "D:/hub2023A/itwinjs-core/extensions/map-layers-formats/lib/esm/Tools/MapFeatureInfoTool.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module MapLayersFormats\n */\nimport { EventHandled, IModelApp, LocateFilterStatus, LocateResponse, PrimitiveTool, } from \"@itwin/core-frontend\";\nimport { BeEvent } from \"@itwin/core-bentley\";\nimport { ImageMapLayerSettings } from \"@itwin/core-common\";\nimport { MapFeatureInfoDecorator } from \"./MapFeatureInfoDecorator\";\n/** Tools that allow extracting feature information from map-layers.\n * Simulate feature highlight by drawing overlay decorations.  It also\n * fire an event that provide further feature information meant to be displayed in a UI / Widget.\n * @see [[MapFeatureInfoToolData]]\n * @beta\n */\nclass MapFeatureInfoTool extends PrimitiveTool {\n    constructor() {\n        super(...arguments);\n        this.onInfoReady = new BeEvent();\n        this._decorator = new MapFeatureInfoDecorator();\n        this._layerSettingsCache = new Map();\n        this._detachListeners = [];\n    }\n    requireWriteableTarget() {\n        return false;\n    }\n    async onPostInstall() {\n        await super.onPostInstall();\n        this.initLocateElements();\n        IModelApp.locateManager.options.allowDecorations = true;\n        this._layerSettingsCache.clear();\n        // Listen of display style configuration changes, that we don't have to restart the tool to be up to date.\n        const vp = this.targetView;\n        if (vp) {\n            this._detachListeners.push(vp.onChangeView.addListener((_vp, _previous) => {\n                this._layerSettingsCache.clear();\n            }));\n            this._detachListeners.push(vp.displayStyle.settings.onMapImageryChanged.addListener((_newImagery) => {\n                this._layerSettingsCache.clear();\n            }));\n        }\n        IModelApp.viewManager.addDecorator(this._decorator);\n    }\n    async onCleanup() {\n        this._detachListeners.forEach((f) => f());\n        this._detachListeners.length = 0;\n        IModelApp.viewManager.dropDecorator(this._decorator);\n    }\n    /** @internal */\n    getMapLayerInfoFromHit(hit) {\n        let mapLayerFromHit = [];\n        const fromCache = this._layerSettingsCache.get(hit.sourceId);\n        if (fromCache) {\n            mapLayerFromHit = fromCache;\n        }\n        else if (this.targetView) {\n            mapLayerFromHit = this.targetView?.mapLayerFromHit(hit).filter(((info) => info.settings instanceof ImageMapLayerSettings && info.provider?.supportsMapFeatureInfo));\n            this._layerSettingsCache.set(hit.sourceId, mapLayerFromHit);\n        }\n        return mapLayerFromHit;\n    }\n    async getToolTip(hit) {\n        const infos = this.getMapLayerInfoFromHit(hit);\n        if (infos.length > 0) {\n            const names = infos.map((info) => info.settings.name);\n            return `Layer${names.length > 1 ? \"s\" : \"\"}: ${names.join(\", \")}`;\n        }\n        return \"\";\n    }\n    async filterHit(hit, _out) {\n        return this.getMapLayerInfoFromHit(hit).length > 0 ? LocateFilterStatus.Accept : LocateFilterStatus.Reject;\n    }\n    async onDataButtonDown(ev) {\n        const hit = await IModelApp.locateManager.doLocate(new LocateResponse(), true, ev.point, ev.viewport, ev.inputSource);\n        if (hit !== undefined) {\n            let mapInfo;\n            if (this.getMapLayerInfoFromHit(hit).length > 0) {\n                IModelApp.toolAdmin.setCursor(\"wait\");\n                try {\n                    mapInfo = await hit.viewport.getMapFeatureInfo(hit);\n                    if (mapInfo) {\n                        this._decorator.setState({ hit, mapInfo });\n                    }\n                }\n                finally {\n                    IModelApp.toolAdmin.setCursor(undefined);\n                }\n            }\n            this.onInfoReady.raiseEvent({ hit, mapInfo });\n            return EventHandled.Yes;\n        }\n        return EventHandled.No;\n    }\n    async onResetButtonUp(_ev) {\n        /* Common reset behavior for primitive tools is calling onReinitialize to restart or exitTool to terminate. */\n        await this.onReinitialize();\n        return EventHandled.No;\n    }\n    async onRestartTool() {\n        const tool = new MapFeatureInfoTool();\n        if (!(await tool.run()))\n            return this.exitTool();\n    }\n}\nMapFeatureInfoTool.toolId = \"MapFeatureInfoTool\";\nMapFeatureInfoTool.iconSpec = \"icon-map\";\nexport { MapFeatureInfoTool };\n//# sourceMappingURL=MapFeatureInfoTool.js.map",
      "start": 1693508122972,
      "end": 1693508123176,
      "sourcemaps": null
    }
  ]
}
