{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tile/map/MapLayerSources.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module MapLayers\n */\nimport { compareStrings } from \"@itwin/core-bentley\";\nimport { BackgroundMapProvider, BackgroundMapType, BaseMapLayerSettings, ImageMapLayerSettings, } from \"@itwin/core-common\";\nimport { Point2d } from \"@itwin/core-geometry\";\nimport { IModelApp } from \"../../IModelApp\";\nimport { request } from \"../../request/Request\";\nimport { ArcGisUtilities, MapCartoRectangle } from \"../internal\";\n/** Values for return codes from [[MapLayerSource.validateSource]]\n * @public\n */\nexport var MapLayerSourceStatus;\n(function (MapLayerSourceStatus) {\n    /** Layer source is valid */\n    MapLayerSourceStatus[MapLayerSourceStatus[\"Valid\"] = 0] = \"Valid\";\n    /** Authorization has failed when accessing this layer source. */\n    MapLayerSourceStatus[MapLayerSourceStatus[\"InvalidCredentials\"] = 1] = \"InvalidCredentials\";\n    /** Provided format id could not be resolved in [[MapLayerFormatRegistry]] */\n    MapLayerSourceStatus[MapLayerSourceStatus[\"InvalidFormat\"] = 2] = \"InvalidFormat\";\n    /** The tiling schema of the source is not supported */\n    MapLayerSourceStatus[MapLayerSourceStatus[\"InvalidTileTree\"] = 3] = \"InvalidTileTree\";\n    /** Could not not connect to remote server using the provided URL.*/\n    MapLayerSourceStatus[MapLayerSourceStatus[\"InvalidUrl\"] = 4] = \"InvalidUrl\";\n    /** Authorization is required to access this map layer source. */\n    MapLayerSourceStatus[MapLayerSourceStatus[\"RequireAuth\"] = 5] = \"RequireAuth\";\n    /** Map-layer coordinate system is not supported */\n    MapLayerSourceStatus[MapLayerSourceStatus[\"InvalidCoordinateSystem\"] = 6] = \"InvalidCoordinateSystem\";\n    /** Format is not compatible with the URL provided.\n     */\n    MapLayerSourceStatus[MapLayerSourceStatus[\"IncompatibleFormat\"] = 7] = \"IncompatibleFormat\";\n})(MapLayerSourceStatus || (MapLayerSourceStatus = {}));\n/** A source for map layers. These may be catalogued for convenient use by users or applications.\n * @public\n */\nexport class MapLayerSource {\n    constructor(formatId = \"WMS\", name, url, baseMap = false, transparentBackground = true) {\n        this.baseMap = false;\n        this.formatId = formatId;\n        this.name = name;\n        this.url = url;\n        this.baseMap = baseMap;\n        this.transparentBackground = transparentBackground;\n    }\n    static fromJSON(json) {\n        if (json === undefined)\n            return undefined;\n        return new MapLayerSource(json.formatId, json.name, json.url, json.baseMap, json.transparentBackground);\n    }\n    async validateSource(ignoreCache) {\n        return IModelApp.mapLayerFormatRegistry.validateSource(this.formatId, this.url, this.userName, this.password, ignoreCache);\n    }\n    /** @internal*/\n    static fromBackgroundMapProps(props) {\n        const provider = BackgroundMapProvider.fromBackgroundMapProps(props);\n        const layerSettings = BaseMapLayerSettings.fromProvider(provider);\n        if (undefined !== layerSettings) {\n            const source = MapLayerSource.fromJSON(layerSettings);\n            if (source) {\n                source.baseMap = true;\n                return source;\n            }\n        }\n        return undefined;\n    }\n    toJSON() {\n        return { url: this.url, name: this.name, formatId: this.formatId, transparentBackground: this.transparentBackground };\n    }\n    toLayerSettings(subLayers) {\n        // When MapLayerSetting is created from a MapLayerSource, sub-layers and credentials need to be set separately.\n        const layerSettings = ImageMapLayerSettings.fromJSON({ ...this, subLayers });\n        if (this.userName !== undefined || this.password !== undefined) {\n            layerSettings?.setCredentials(this.userName, this.password);\n        }\n        return layerSettings;\n    }\n    getCredentials() {\n        return this.userName && this.password ? { user: this.userName, password: this.password } : undefined;\n    }\n}\n/** A collection of [[MapLayerSource]] objects.\n * @beta\n */\nexport class MapLayerSources {\n    constructor(_sources) {\n        this._sources = _sources;\n    }\n    static getInstance() { return MapLayerSources._instance; }\n    findByName(name, baseMap = false) {\n        const nameTest = name.toLowerCase();\n        for (const source of this._sources)\n            if (source.baseMap === baseMap && source.name.toLowerCase().indexOf(nameTest) !== -1)\n                return source;\n        return undefined;\n    }\n    get layers() {\n        const layers = new Array();\n        this._sources.forEach((source) => {\n            if (!source.baseMap)\n                layers.push(source);\n        });\n        return layers;\n    }\n    get allSource() { return this._sources; }\n    get bases() {\n        const layers = new Array();\n        this._sources.forEach((source) => {\n            if (source.baseMap)\n                layers.push(source);\n        });\n        return layers;\n    }\n    static getBingMapLayerSource() {\n        const mapLayerSources = [];\n        mapLayerSources.push(MapLayerSource.fromBackgroundMapProps({ providerName: \"BingProvider\", providerData: { mapType: BackgroundMapType.Street } }));\n        mapLayerSources.push(MapLayerSource.fromBackgroundMapProps({ providerName: \"BingProvider\", providerData: { mapType: BackgroundMapType.Aerial } }));\n        mapLayerSources.push(MapLayerSource.fromBackgroundMapProps({ providerName: \"BingProvider\", providerData: { mapType: BackgroundMapType.Hybrid } }));\n        return mapLayerSources;\n    }\n    static getMapBoxLayerSource() {\n        const mapLayerSources = [];\n        mapLayerSources.push(MapLayerSource.fromBackgroundMapProps({ providerName: \"MapBoxProvider\", providerData: { mapType: BackgroundMapType.Street } }));\n        mapLayerSources.push(MapLayerSource.fromBackgroundMapProps({ providerName: \"MapBoxProvider\", providerData: { mapType: BackgroundMapType.Aerial } }));\n        mapLayerSources.push(MapLayerSource.fromBackgroundMapProps({ providerName: \"MapBoxProvider\", providerData: { mapType: BackgroundMapType.Hybrid } }));\n        return mapLayerSources;\n    }\n    static async create(iModel, queryForPublicSources = false, addMapBoxSources = false) {\n        if (!queryForPublicSources && MapLayerSources._instance)\n            return MapLayerSources._instance;\n        if (!iModel)\n            iModel = IModelApp.viewManager.selectedView ? IModelApp.viewManager.selectedView.iModel : undefined;\n        let sourceRange = MapCartoRectangle.createMaximum();\n        if (iModel) {\n            const projectCenter = iModel.projectExtents.localXYZToWorld(.5, .5, .5);\n            const cartoCenter = iModel.spatialToCartographicFromEcef(projectCenter);\n            const globeRange = MapCartoRectangle.createMaximum();\n            const nearDelta = Point2d.create(globeRange.xLength() / 100, globeRange.yLength() / 100);\n            sourceRange = MapCartoRectangle.fromRadians(cartoCenter.longitude - nearDelta.x, cartoCenter.latitude - nearDelta.y, cartoCenter.longitude + nearDelta.x, cartoCenter.latitude + nearDelta.y);\n        }\n        const sources = new Array();\n        const urlSet = new Set();\n        const addSource = ((source) => {\n            if (!urlSet.has(source.url)) {\n                sources.push(source);\n                urlSet.add(source.url);\n            }\n        });\n        this.getBingMapLayerSource().forEach((source) => {\n            addSource(source);\n        });\n        if (addMapBoxSources) {\n            this.getMapBoxLayerSource().forEach((source) => {\n                addSource(source);\n            });\n        }\n        if (queryForPublicSources) {\n            const sourcesJson = await request(`${IModelApp.publicPath}assets/MapLayerSources.json`, \"json\");\n            for (const sourceJson of sourcesJson) {\n                const source = MapLayerSource.fromJSON(sourceJson);\n                if (source)\n                    addSource(source);\n            }\n            (await ArcGisUtilities.getSourcesFromQuery(sourceRange)).forEach((queriedSource) => addSource(queriedSource));\n        }\n        sources.sort((a, b) => compareStrings(a.name.toLowerCase(), b.name.toLowerCase()));\n        const mapLayerSources = new MapLayerSources(sources);\n        MapLayerSources._instance = mapLayerSources;\n        return mapLayerSources;\n    }\n    static async addSourceToMapLayerSources(mapLayerSource) {\n        if (!MapLayerSources._instance || !mapLayerSource) {\n            return undefined;\n        }\n        MapLayerSources._instance._sources = MapLayerSources._instance._sources.filter((source) => {\n            return !(source.name === mapLayerSource.name || source.url === mapLayerSource.url);\n        });\n        MapLayerSources._instance._sources.push(mapLayerSource);\n        MapLayerSources._instance._sources.sort((a, b) => compareStrings(a.name.toLowerCase(), b.name.toLowerCase()));\n        return MapLayerSources._instance;\n    }\n    static removeLayerByName(name) {\n        if (!MapLayerSources._instance) {\n            return false;\n        }\n        // For now we only rely on the name\n        const lengthBeforeRemove = MapLayerSources._instance._sources.length;\n        MapLayerSources._instance._sources = MapLayerSources._instance._sources.filter((source) => {\n            return (source.name !== name);\n        });\n        return (lengthBeforeRemove !== MapLayerSources._instance._sources.length);\n    }\n}\n//# sourceMappingURL=MapLayerSources.js.map",
      "start": 1693508122079,
      "end": 1693508122288,
      "sourcemaps": null
    }
  ]
}
