{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/curve/spiral/TransitionSpiral3d.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Curve\n */\nimport { Geometry } from \"../../Geometry\";\nimport { Range3d } from \"../../geometry3d/Range\";\nimport { Segment1d } from \"../../geometry3d/Segment1d\";\nimport { Transform } from \"../../geometry3d/Transform\";\nimport { CurvePrimitive } from \"../CurvePrimitive\";\nimport { CurveOffsetXYHandler } from \"../internalContexts/CurveOffsetXYHandler\";\nimport { PlaneAltitudeRangeContext } from \"../internalContexts/PlaneAltitudeRangeContext\";\nimport { OffsetOptions } from \"../OffsetOptions\";\n/**\n * TransitionSpiral3d is a base class for multiple variants of spirals.\n * * The menagerie of spiral types have 2 broad categories:\n *   * IntegratedSpiral3d -- a spiral whose direct function for curvature versus distance must be integrated to determine x,y\n *     * The IntegratedSpiral3d types are enumerated in `IntegratedSpiralTypes`\n *   * DirectSpiral3d -- a spiral implemented with direct calculation of x,y from fractional position along the spiral.\n *     * The direct spiral types are enumerated in the `DirectSpiralType`\n * * The method set for CurvePrimitive support includes a `handleTransitionSpiral(g: TransitionSpiral3d)` which receives all the spiral types.\n * * The spiral class may impose expectations that its inflection is at the origin, with tangent along the x axis.\n *   * This is generally necessary for direct spirals.\n *   * This is not necessary for integrated spirals.\n * @public\n */\nexport class TransitionSpiral3d extends CurvePrimitive {\n    /** Return (reference to) the active portion of the reference spiral. */\n    get activeFractionInterval() { return this._activeFractionInterval; }\n    /** (reference to) placement transform. */\n    get localToWorld() { return this._localToWorld; }\n    constructor(spiralType, localToWorld, activeFractionInterval, designProperties) {\n        super();\n        this._spiralType = spiralType ? spiralType : \"unknownSpiralType\";\n        this._designProperties = designProperties;\n        this._localToWorld = localToWorld;\n        this._activeFractionInterval = activeFractionInterval ? activeFractionInterval : Segment1d.create(0, 1);\n    }\n    get spiralType() { return this._spiralType; }\n    /** Return 1/r with convention that if true zero is given as radius it represents infinite radius (0 curvature, straight line) */\n    static radiusToCurvature(radius) { return (radius === 0.0) ? 0.0 : 1.0 / radius; }\n    /** Return 1/k with convention that if near-zero is given as curvature, its infinite radius is returned as 0 */\n    static curvatureToRadius(curvature) {\n        if (Math.abs(curvature) < Geometry.smallAngleRadians)\n            return 0.0;\n        return 1.0 / curvature;\n    }\n    /** Return (if possible) a spiral which is a portion of this curve. */\n    clonePartialCurve(fractionA, fractionB) {\n        const spiralB = this.clone();\n        const globalFractionA = this._activeFractionInterval.fractionToPoint(fractionA);\n        const globalFractionB = this._activeFractionInterval.fractionToPoint(fractionB);\n        spiralB._activeFractionInterval.set(globalFractionA, globalFractionB);\n        spiralB.refreshComputedProperties();\n        return spiralB;\n    }\n    /** Clone with a transform applied  */\n    cloneTransformed(transform) {\n        const result = this.clone();\n        result.tryTransformInPlace(transform); // ok, we're confident it will always work.\n        return result;\n    }\n    /** Return the average of the start and end curvatures. */\n    static averageCurvature(radiusLimits) {\n        return 0.5 * (TransitionSpiral3d.radiusToCurvature(radiusLimits.x0) + TransitionSpiral3d.radiusToCurvature(radiusLimits.x1));\n    }\n    /**\n     * Given two radii (or zeros for 0 curvature) return the average curvature\n     * @param r0 start radius, or 0 for line\n     * @param r1 end radius, or 0 for line\n     */\n    static averageCurvatureR0R1(r0, r1) {\n        return 0.5 * (TransitionSpiral3d.radiusToCurvature(r0) + TransitionSpiral3d.radiusToCurvature(r1));\n    }\n    /**\n     * Given two radii (or zeros for 0 curvature) return the average curvature\n     * @param r0 start radius, or 0 for line\n     * @param r1 end radius, or 0 for line\n     */\n    static interpolateCurvatureR0R1(r0, fraction, r1) {\n        return Geometry.interpolate(TransitionSpiral3d.radiusToCurvature(r0), fraction, TransitionSpiral3d.radiusToCurvature(r1));\n    }\n    /** Return the arc length of a transition spiral with given sweep and radius pair. */\n    static radiusRadiusSweepRadiansToArcLength(radius0, radius1, sweepRadians) {\n        return Math.abs(sweepRadians / TransitionSpiral3d.averageCurvatureR0R1(radius0, radius1));\n    }\n    /** Return the turn angle for spiral of given length between two radii */\n    static radiusRadiusLengthToSweepRadians(radius0, radius1, arcLength) {\n        return TransitionSpiral3d.averageCurvatureR0R1(radius0, radius1) * arcLength;\n    }\n    /** Return the end radius for spiral of given start radius, length, and turn angle. */\n    static radius0LengthSweepRadiansToRadius1(radius0, arcLength, sweepRadians) {\n        return TransitionSpiral3d.curvatureToRadius((2.0 * sweepRadians / arcLength) - TransitionSpiral3d.radiusToCurvature(radius0));\n    }\n    /** Return the start radius for spiral of given end radius, length, and turn angle. */\n    static radius1LengthSweepRadiansToRadius0(radius1, arcLength, sweepRadians) {\n        return TransitionSpiral3d.curvatureToRadius((2.0 * sweepRadians / arcLength) - TransitionSpiral3d.radiusToCurvature(radius1));\n    }\n    /** Return the original defining properties (if any) saved by the constructor. */\n    get designProperties() { return this._designProperties; }\n    /**\n     * * If transformA is rigid with uniform scale, apply the rigid part of transformA to the localToWorld transform and return the scale and rigid separation.\n     * * If not rigid, do nothing and return undefined.\n     * * Also apply the scale factor to the designProperties.\n     * @param transformA\n     */\n    applyRigidPartOfTransform(transformA) {\n        const rigidData = transformA.matrix.factorRigidWithSignedScale();\n        if (rigidData !== undefined) {\n            // [sQ a][R b] = [sQ*R sQb+a]\n            // but we save it as [Q*R sQb+a] with spiral data scaled by s.\n            const transformC0 = transformA.multiplyTransformTransform(this.localToWorld);\n            // BUT pull the scale part out of the matrix ...\n            const matrixC = rigidData.rigidAxes.multiplyMatrixMatrix(this.localToWorld.matrix);\n            this._localToWorld = Transform.createOriginAndMatrix(transformC0.origin, matrixC);\n            if (this.designProperties)\n                this.designProperties.applyScaleFactor(rigidData.scale);\n            return rigidData;\n        }\n        return undefined;\n    }\n    /**\n     * Construct an offset of the instance curve as viewed in the xy-plane (ignoring z).\n     * * No attempt is made to join the offsets of smaller constituent primitives. To construct a fully joined offset\n     *   for an aggregate instance (e.g., LineString3d, CurveChainWithDistanceIndex), use RegionOps.constructCurveXYOffset() instead.\n     * @param offsetDistanceOrOptions offset distance (positive to left of the instance curve), or options object\n     */\n    constructOffsetXY(offsetDistanceOrOptions) {\n        const options = OffsetOptions.create(offsetDistanceOrOptions);\n        const handler = new CurveOffsetXYHandler(this, options.leftOffsetDistance);\n        this.emitStrokableParts(handler, options.strokeOptions);\n        return handler.claimResult();\n    }\n    /** extend the range by the strokes of the spiral */\n    extendRange(rangeToExtend, transform) {\n        const myRange = this.rangeBetweenFractions(0.0, 1.0, transform);\n        rangeToExtend.extendRange(myRange);\n    }\n    /** return the range of spiral between fractions of the activeStrokes.\n     * * Use activeStrokes point count times interval factor for initial evaluation count, but do at least 5\n     */\n    rangeBetweenFractions(fractionA, fractionB, transform) {\n        const strokes = this.activeStrokes;\n        if (undefined === strokes)\n            return Range3d.createNull();\n        let count = Math.ceil(strokes.numPoints() * Math.abs(fractionB - fractionA));\n        count = Geometry.clamp(5, count, 30);\n        return this.rangeBetweenFractionsByCount(fractionA, fractionB, count, transform, 0.5);\n    }\n    /** Project instance geometry (via dispatch) onto the given ray, and return the extreme fractional parameters of projection.\n     * @param ray ray onto which the instance is projected. A `Vector3d` is treated as a `Ray3d` with zero origin.\n     * @param lowHigh optional receiver for output\n     * @returns range of fractional projection parameters onto the ray, where 0.0 is start of the ray and 1.0 is the end of the ray.\n     */\n    projectedParameterRange(ray, lowHigh) {\n        return PlaneAltitudeRangeContext.findExtremeFractionsAlongDirection(this, ray, lowHigh);\n    }\n}\n//# sourceMappingURL=TransitionSpiral3d.js.map",
      "start": 1693508123714,
      "end": 1693508123845,
      "sourcemaps": null
    }
  ]
}
