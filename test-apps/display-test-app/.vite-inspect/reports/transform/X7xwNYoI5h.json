{
  "resolvedId": "D:/hub2023A/itwinjs-core/test-apps/display-test-app/src/frontend/DrawingAidTestTool.ts",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\r\n* See LICENSE.md in the project root for license terms and full copyright notice.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\nimport { IModelJson as GeomJson, LineString3d, Point3d, Vector3d } from \"@itwin/core-geometry\";\r\nimport { ColorDef, GeometryStreamProps } from \"@itwin/core-common\";\r\nimport {\r\n  AccuDrawHintBuilder, BeButtonEvent, DecorateContext, DynamicsContext, EventHandled, GraphicType, HitDetail, IModelApp, PrimitiveTool, SnapStatus,\r\n} from \"@itwin/core-frontend\";\r\n\r\nexport class DrawingAidTestTool extends PrimitiveTool {\r\n  public static override toolId = \"DrawingAidTest.Points\";\r\n  public readonly points: Point3d[] = [];\r\n  protected _snapGeomId?: string;\r\n\r\n  public override requireWriteableTarget(): boolean { return false; }\r\n  public override async onPostInstall() {\r\n    await super.onPostInstall();\r\n    this.setupAndPromptForNextAction();\r\n  }\r\n\r\n  public setupAndPromptForNextAction(): void {\r\n    IModelApp.accuSnap.enableSnap(true);\r\n\r\n    if (0 === this.points.length)\r\n      return;\r\n\r\n    const hints = new AccuDrawHintBuilder();\r\n    hints.enableSmartRotation = true;\r\n\r\n    if (this.points.length > 1 && !(this.points[this.points.length - 1].isAlmostEqual(this.points[this.points.length - 2])))\r\n      hints.setXAxis(Vector3d.createStartEnd(this.points[this.points.length - 2], this.points[this.points.length - 1])); // Rotate AccuDraw to last segment...\r\n\r\n    hints.setOrigin(this.points[this.points.length - 1]);\r\n    hints.sendHints();\r\n  }\r\n\r\n  public override testDecorationHit(id: string): boolean { return id === this._snapGeomId; }\r\n\r\n  public override getDecorationGeometry(_hit: HitDetail): GeometryStreamProps | undefined {\r\n    if (this.points.length < 2)\r\n      return undefined;\r\n\r\n    const geomData = GeomJson.Writer.toIModelJson(LineString3d.create(this.points));\r\n    return (undefined === geomData ? undefined : [geomData]);\r\n  }\r\n\r\n  public override decorate(context: DecorateContext): void {\r\n    if (this.points.length < 2)\r\n      return;\r\n\r\n    if (undefined === this._snapGeomId)\r\n      this._snapGeomId = this.iModel.transientIds.getNext();\r\n\r\n    const builder = context.createGraphicBuilder(GraphicType.WorldDecoration, undefined, this._snapGeomId);\r\n\r\n    builder.setSymbology(context.viewport.getContrastToBackgroundColor(), ColorDef.black, 1);\r\n    builder.addLineString(this.points);\r\n\r\n    context.addDecorationFromBuilder(builder);\r\n  }\r\n\r\n  public override onDynamicFrame(ev: BeButtonEvent, context: DynamicsContext): void {\r\n    if (this.points.length < 1)\r\n      return;\r\n\r\n    const builder = context.createSceneGraphicBuilder();\r\n\r\n    builder.setSymbology(context.viewport.getContrastToBackgroundColor(), ColorDef.black, 1);\r\n    builder.addLineString([this.points[this.points.length - 1], ev.point]); // Only draw current segment in dynamics, accepted segments are drawn as pickable decorations...\r\n\r\n    context.addGraphic(builder.finish());\r\n  }\r\n\r\n  public override async onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled> {\r\n    this.points.push(ev.point.clone());\r\n    this.setupAndPromptForNextAction();\r\n\r\n    if (!this.isDynamicsStarted)\r\n      this.beginDynamics();\r\n\r\n    return EventHandled.No;\r\n  }\r\n\r\n  public override async onResetButtonUp(_ev: BeButtonEvent): Promise<EventHandled> {\r\n    if (undefined !== IModelApp.accuSnap.currHit) {\r\n      const status = await IModelApp.accuSnap.resetButton(); // TESTING ONLY - NOT NORMAL TOOL OPERATION - Exercise AccuSnap hit cycling...only restart when no current hit or not hot snap on next hit...\r\n      if (SnapStatus.Success === status)\r\n        return EventHandled.No;\r\n    }\r\n    await this.onReinitialize();\r\n    return EventHandled.No;\r\n  }\r\n\r\n  public override async onUndoPreviousStep(): Promise<boolean> {\r\n    if (0 === this.points.length)\r\n      return false;\r\n\r\n    this.points.pop();\r\n    if (0 === this.points.length)\r\n      await this.onReinitialize();\r\n    else\r\n      this.setupAndPromptForNextAction();\r\n    return true;\r\n  }\r\n\r\n  public async onRestartTool() {\r\n    const tool = new DrawingAidTestTool();\r\n    if (!await tool.run())\r\n      return this.exitTool();\r\n  }\r\n}\r\n",
      "start": 1693508121191,
      "end": 1693508121254,
      "sourcemaps": null
    },
    {
      "name": "vite:esbuild",
      "result": "\"use strict\";\nimport { IModelJson as GeomJson, LineString3d, Vector3d } from \"@itwin/core-geometry\";\nimport { ColorDef } from \"@itwin/core-common\";\nimport {\n  AccuDrawHintBuilder,\n  EventHandled,\n  GraphicType,\n  IModelApp,\n  PrimitiveTool,\n  SnapStatus\n} from \"@itwin/core-frontend\";\nconst _DrawingAidTestTool = class _DrawingAidTestTool extends PrimitiveTool {\n  constructor() {\n    super(...arguments);\n    this.points = [];\n  }\n  requireWriteableTarget() {\n    return false;\n  }\n  async onPostInstall() {\n    await super.onPostInstall();\n    this.setupAndPromptForNextAction();\n  }\n  setupAndPromptForNextAction() {\n    IModelApp.accuSnap.enableSnap(true);\n    if (0 === this.points.length)\n      return;\n    const hints = new AccuDrawHintBuilder();\n    hints.enableSmartRotation = true;\n    if (this.points.length > 1 && !this.points[this.points.length - 1].isAlmostEqual(this.points[this.points.length - 2]))\n      hints.setXAxis(Vector3d.createStartEnd(this.points[this.points.length - 2], this.points[this.points.length - 1]));\n    hints.setOrigin(this.points[this.points.length - 1]);\n    hints.sendHints();\n  }\n  testDecorationHit(id) {\n    return id === this._snapGeomId;\n  }\n  getDecorationGeometry(_hit) {\n    if (this.points.length < 2)\n      return void 0;\n    const geomData = GeomJson.Writer.toIModelJson(LineString3d.create(this.points));\n    return void 0 === geomData ? void 0 : [geomData];\n  }\n  decorate(context) {\n    if (this.points.length < 2)\n      return;\n    if (void 0 === this._snapGeomId)\n      this._snapGeomId = this.iModel.transientIds.getNext();\n    const builder = context.createGraphicBuilder(GraphicType.WorldDecoration, void 0, this._snapGeomId);\n    builder.setSymbology(context.viewport.getContrastToBackgroundColor(), ColorDef.black, 1);\n    builder.addLineString(this.points);\n    context.addDecorationFromBuilder(builder);\n  }\n  onDynamicFrame(ev, context) {\n    if (this.points.length < 1)\n      return;\n    const builder = context.createSceneGraphicBuilder();\n    builder.setSymbology(context.viewport.getContrastToBackgroundColor(), ColorDef.black, 1);\n    builder.addLineString([this.points[this.points.length - 1], ev.point]);\n    context.addGraphic(builder.finish());\n  }\n  async onDataButtonDown(ev) {\n    this.points.push(ev.point.clone());\n    this.setupAndPromptForNextAction();\n    if (!this.isDynamicsStarted)\n      this.beginDynamics();\n    return EventHandled.No;\n  }\n  async onResetButtonUp(_ev) {\n    if (void 0 !== IModelApp.accuSnap.currHit) {\n      const status = await IModelApp.accuSnap.resetButton();\n      if (SnapStatus.Success === status)\n        return EventHandled.No;\n    }\n    await this.onReinitialize();\n    return EventHandled.No;\n  }\n  async onUndoPreviousStep() {\n    if (0 === this.points.length)\n      return false;\n    this.points.pop();\n    if (0 === this.points.length)\n      await this.onReinitialize();\n    else\n      this.setupAndPromptForNextAction();\n    return true;\n  }\n  async onRestartTool() {\n    const tool = new _DrawingAidTestTool();\n    if (!await tool.run())\n      return this.exitTool();\n  }\n};\n_DrawingAidTestTool.toolId = \"DrawingAidTest.Points\";\nexport let DrawingAidTestTool = _DrawingAidTestTool;\n",
      "start": 1693508121254,
      "end": 1693508121398,
      "order": "normal",
      "sourcemaps": {
        "version": 3,
        "sources": [
          "D:/hub2023A/itwinjs-core/test-apps/display-test-app/src/frontend/DrawingAidTestTool.ts"
        ],
        "sourcesContent": [
          "/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\r\n* See LICENSE.md in the project root for license terms and full copyright notice.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\nimport { IModelJson as GeomJson, LineString3d, Point3d, Vector3d } from \"@itwin/core-geometry\";\r\nimport { ColorDef, GeometryStreamProps } from \"@itwin/core-common\";\r\nimport {\r\n  AccuDrawHintBuilder, BeButtonEvent, DecorateContext, DynamicsContext, EventHandled, GraphicType, HitDetail, IModelApp, PrimitiveTool, SnapStatus,\r\n} from \"@itwin/core-frontend\";\r\n\r\nexport class DrawingAidTestTool extends PrimitiveTool {\r\n  public static override toolId = \"DrawingAidTest.Points\";\r\n  public readonly points: Point3d[] = [];\r\n  protected _snapGeomId?: string;\r\n\r\n  public override requireWriteableTarget(): boolean { return false; }\r\n  public override async onPostInstall() {\r\n    await super.onPostInstall();\r\n    this.setupAndPromptForNextAction();\r\n  }\r\n\r\n  public setupAndPromptForNextAction(): void {\r\n    IModelApp.accuSnap.enableSnap(true);\r\n\r\n    if (0 === this.points.length)\r\n      return;\r\n\r\n    const hints = new AccuDrawHintBuilder();\r\n    hints.enableSmartRotation = true;\r\n\r\n    if (this.points.length > 1 && !(this.points[this.points.length - 1].isAlmostEqual(this.points[this.points.length - 2])))\r\n      hints.setXAxis(Vector3d.createStartEnd(this.points[this.points.length - 2], this.points[this.points.length - 1])); // Rotate AccuDraw to last segment...\r\n\r\n    hints.setOrigin(this.points[this.points.length - 1]);\r\n    hints.sendHints();\r\n  }\r\n\r\n  public override testDecorationHit(id: string): boolean { return id === this._snapGeomId; }\r\n\r\n  public override getDecorationGeometry(_hit: HitDetail): GeometryStreamProps | undefined {\r\n    if (this.points.length < 2)\r\n      return undefined;\r\n\r\n    const geomData = GeomJson.Writer.toIModelJson(LineString3d.create(this.points));\r\n    return (undefined === geomData ? undefined : [geomData]);\r\n  }\r\n\r\n  public override decorate(context: DecorateContext): void {\r\n    if (this.points.length < 2)\r\n      return;\r\n\r\n    if (undefined === this._snapGeomId)\r\n      this._snapGeomId = this.iModel.transientIds.getNext();\r\n\r\n    const builder = context.createGraphicBuilder(GraphicType.WorldDecoration, undefined, this._snapGeomId);\r\n\r\n    builder.setSymbology(context.viewport.getContrastToBackgroundColor(), ColorDef.black, 1);\r\n    builder.addLineString(this.points);\r\n\r\n    context.addDecorationFromBuilder(builder);\r\n  }\r\n\r\n  public override onDynamicFrame(ev: BeButtonEvent, context: DynamicsContext): void {\r\n    if (this.points.length < 1)\r\n      return;\r\n\r\n    const builder = context.createSceneGraphicBuilder();\r\n\r\n    builder.setSymbology(context.viewport.getContrastToBackgroundColor(), ColorDef.black, 1);\r\n    builder.addLineString([this.points[this.points.length - 1], ev.point]); // Only draw current segment in dynamics, accepted segments are drawn as pickable decorations...\r\n\r\n    context.addGraphic(builder.finish());\r\n  }\r\n\r\n  public override async onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled> {\r\n    this.points.push(ev.point.clone());\r\n    this.setupAndPromptForNextAction();\r\n\r\n    if (!this.isDynamicsStarted)\r\n      this.beginDynamics();\r\n\r\n    return EventHandled.No;\r\n  }\r\n\r\n  public override async onResetButtonUp(_ev: BeButtonEvent): Promise<EventHandled> {\r\n    if (undefined !== IModelApp.accuSnap.currHit) {\r\n      const status = await IModelApp.accuSnap.resetButton(); // TESTING ONLY - NOT NORMAL TOOL OPERATION - Exercise AccuSnap hit cycling...only restart when no current hit or not hot snap on next hit...\r\n      if (SnapStatus.Success === status)\r\n        return EventHandled.No;\r\n    }\r\n    await this.onReinitialize();\r\n    return EventHandled.No;\r\n  }\r\n\r\n  public override async onUndoPreviousStep(): Promise<boolean> {\r\n    if (0 === this.points.length)\r\n      return false;\r\n\r\n    this.points.pop();\r\n    if (0 === this.points.length)\r\n      await this.onReinitialize();\r\n    else\r\n      this.setupAndPromptForNextAction();\r\n    return true;\r\n  }\r\n\r\n  public async onRestartTool() {\r\n    const tool = new DrawingAidTestTool();\r\n    if (!await tool.run())\r\n      return this.exitTool();\r\n  }\r\n}\r\n"
        ],
        "mappings": "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",
        "names": []
      }
    }
  ]
}
