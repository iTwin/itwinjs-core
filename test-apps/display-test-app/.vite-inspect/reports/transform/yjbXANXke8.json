{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/clipping/AlternatingConvexClipTree.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module CartesianGeometry\n */\nimport { BSplineCurve3d } from \"../bspline/BSplineCurve\";\nimport { Arc3d } from \"../curve/Arc3d\";\nimport { CurveCollection } from \"../curve/CurveCollection\";\nimport { CurveLocationDetail, CurveLocationDetailPair } from \"../curve/CurveLocationDetail\";\nimport { CurvePrimitive } from \"../curve/CurvePrimitive\";\nimport { LineSegment3d } from \"../curve/LineSegment3d\";\nimport { LineString3d } from \"../curve/LineString3d\";\nimport { Angle } from \"../geometry3d/Angle\";\nimport { Vector3d } from \"../geometry3d/Point3dVector3d\";\nimport { Point3dArray } from \"../geometry3d/PointHelpers\";\nimport { PolygonOps } from \"../geometry3d/PolygonOps\";\nimport { Range1d } from \"../geometry3d/Range\";\nimport { Range1dArray } from \"../numerics/Range1dArray\";\nimport { ClipPlane } from \"./ClipPlane\";\nimport { ClipUtilities } from \"./ClipUtils\";\nimport { ConvexClipPlaneSet } from \"./ConvexClipPlaneSet\";\n/**\n * An AlternatingConvexClipTreeNode is a node in a tree structure in which\n *   <ul>\n *   <li>Each node contains a ConvexClipPlaneSet.\n *   <li>Each node contains an array of children which are also AlternatingConvexClipTreeNode.\n *   <li>The rule for an in/out decision is that a point is IN the subtree under a node if\n *   <ul>\n *   <li>It is IN the node's ConvexClipPlaneSet.\n *   <li>It is NOT IN any of the children.\n *   </ul>\n *   <li>Applying \"NOT IN any of the children\" locally to children at each level means that the ConvexClipPlaneSet\n *       at adjacent levels flip between being positive areas and holes.\n *   <li>Use an AlternatingConvexClipTreeNodeBuilder to construct the tree from a polygon.\n *   <li>It is possible for the root clip plane set to be empty.  An empty clip plane set returns \"true\"\n *         for all point tests, so the meaning is just that holes are to be subtracted from the rest\n *         of space.\n *   <li>Although the interpretation of in/out alternates with tree levels, the ConvexClipPlaneSets\n *         at each level are all \"enclosing\" planes in the usual way.\n *   </ul>\n */\nexport class AlternatingCCTreeNode {\n    constructor() {\n        this.points = [];\n        this.planes = ConvexClipPlaneSet.createEmpty();\n        this.children = [];\n        this.startIdx = -1; // Start index into the master array (not the local points array)\n        this.numPoints = -1; // Number of points used in the master array\n    }\n    /** Initialize this node with index data referencing the parent polygon. */\n    static createWithIndices(index0, numPoints, result) {\n        result = result ? result : new AlternatingCCTreeNode();\n        result.startIdx = index0;\n        result.numPoints = numPoints;\n        result.children.length = 0;\n        return result;\n    }\n    /**\n     * <ul>\n     * <li>Build the tree for a polygon.\n     * <li>Caller creates the root node with empty constructor AlternatingConvexClipTreeNode.\n     * </ul>\n     */\n    static createTreeForPolygon(points, result) {\n        result = result ? result : new AlternatingCCTreeNode();\n        result.empty();\n        const builder = AlternatingCCTreeBuilder.createPointsRef(points);\n        builder.buildHullTree(result); // <-- Currently ALWAYS returns true\n        return result;\n    }\n    /** Build the outer convex hull with inlets as first level children. */\n    static createHullAndInletsForPolygon(points, result) {\n        result = result ? result : new AlternatingCCTreeNode();\n        result.empty();\n        const builder = AlternatingCCTreeBuilder.createPointsRef(points);\n        builder.buildHullAndInletsForPolygon(result); // <-- Currently ALWAYS returns true\n        return result;\n    }\n    extractLoopsGo(loops) {\n        loops.push(Point3dArray.clonePoint3dArray(this.points));\n        for (const c of this.children)\n            c.extractLoopsGo(loops);\n    }\n    /**\n     * Return an array with all the loops in the tree.\n     * This loses the alternating structure of the tree, but the collection still matches well-formed polygons by\n     * parity rules.\n     */\n    extractLoops() {\n        const loops = [];\n        this.extractLoopsGo(loops);\n        return loops;\n    }\n    /** Resets this AlternatingConvexClipTreeNode to a newly-created state. */\n    empty() {\n        this.points.length = 0;\n        this.planes.planes.length = 0;\n        this.children.length = 0;\n        this.startIdx = -1;\n        this.numPoints = -1;\n    }\n    /** Creates a deep copy of this node (expensive - copies Geometry, and is recursive for children array). */\n    clone(result) {\n        result = result ? result : new AlternatingCCTreeNode();\n        for (const point of this.points)\n            result.points.push(point.clone());\n        result.planes = ConvexClipPlaneSet.createEmpty();\n        for (const plane of this.planes.planes)\n            result.planes.planes.push(plane.clone());\n        for (const node of this.children)\n            result.children.push(node.clone());\n        result.startIdx = this.startIdx;\n        result.numPoints = this.numPoints;\n        return result;\n    }\n    /** Add a new child that has an empty plane set and given indices. */\n    addEmptyChild(index0, numPoints) {\n        const newNode = AlternatingCCTreeNode.createWithIndices(index0, numPoints);\n        this.children.push(newNode);\n    }\n    /** Add a plane to the ConvexClipPlaneSet. */\n    addPlane(plane) {\n        this.planes.addPlaneToConvexSet(plane);\n    }\n    /** Search with alternating in and out semantics. */\n    isPointOnOrInside(point) {\n        const inRoot = this.planes.isPointOnOrInside(point, 0.0);\n        if (!inRoot)\n            return false;\n        for (const child of this.children) {\n            if (child.isPointOnOrInside(point))\n                return false;\n        }\n        return true;\n    }\n    /**\n     * Add an AlternatingConvexClipTreeNode as a child of this one -- i.e. a hole.\n     * * The child pointer is pushed directly to the tree -- not cloned.\n     */\n    captureConvexClipPlaneSetAsVoid(child) {\n        this.children.push(child);\n    }\n    /** Append start-end positions for curve intervals classified as inside or outside. */\n    appendCurvePrimitiveClipIntervals(curve, insideIntervals, outsideIntervals) {\n        const clipper = new AlternatingCCTreeNodeCurveClipper();\n        clipper.appendSingleClipPrimitive(this, curve, insideIntervals, outsideIntervals);\n    }\n    /** Append start-end positions for curve intervals classified as inside or outside. */\n    appendCurveCollectionClipIntervals(curves, insideIntervals, outsideIntervals) {\n        const clipper = new AlternatingCCTreeNodeCurveClipper();\n        clipper.appendCurveCollectionClip(this, curves, insideIntervals, outsideIntervals);\n    }\n    /**\n     * @param xyz input polygon. This is not changed.\n     * @param insideFragments Array to receive \"inside\" fragments. Each fragment is a GrowableXYZArray grabbed from\n     * the cache. This is NOT cleared.\n     * @param outsideFragments Array to receive \"outside\" fragments. Each fragment is a GrowableXYZArray grabbed\n     * from the cache. This is NOT cleared.\n     * @param arrayCache cache for reusable GrowableXYZArray.\n     */\n    appendPolygonClip(xyz, insideFragments, outsideFragments, arrayCache) {\n        // At first level ..\n        // newInside is subject to re-clip by children.\n        // outside is definitively outside\n        const oldOutsideCount = outsideFragments.length;\n        const newInside = this.planes.clipInsidePushOutside(xyz, outsideFragments, arrayCache);\n        if (newInside === undefined) {\n            ClipUtilities.restoreSingletonInPlaceOfMultipleShards(outsideFragments, oldOutsideCount, xyz, arrayCache);\n        }\n        else {\n            let carryForwardA = [newInside];\n            let carryForwardB = [];\n            let tempAB;\n            let shard;\n            for (const c of this.children) {\n                carryForwardB.length = 0;\n                while (undefined !== (shard = carryForwardA.pop())) {\n                    // Anything inside this child is truly outside  ...\n                    c.appendPolygonClip(shard, outsideFragments, carryForwardB, arrayCache);\n                    arrayCache.dropToCache(shard);\n                }\n                tempAB = carryForwardB;\n                carryForwardB = carryForwardA; // and that is empty\n                carryForwardA = tempAB;\n            }\n            while (undefined !== (shard = carryForwardA.pop())) {\n                insideFragments.push(shard);\n            }\n        }\n    }\n    depth() {\n        const myDepth = 1;\n        let maxChildDepth = 0;\n        for (const c of this.children) {\n            maxChildDepth = Math.max(maxChildDepth, c.depth());\n        }\n        return myDepth + maxChildDepth;\n    }\n}\n/**\n *  Context structure for building an AlternatingConvexClipTreeNode from a polygon.\n *  <ul>\n *  <li> The polygon is copied to the local m_points structure.\n *  <li> During construction, m_stack contains indices of a sequence of points with uniform concavity.\n *  </ul>\n */\nexport class AlternatingCCTreeBuilder {\n    constructor() {\n        this._points = [];\n        this._stack = [];\n    }\n    static createPointsRef(points, result) {\n        result = result ? result : new AlternatingCCTreeBuilder();\n        result._points = points;\n        if (PolygonOps.areaXY(points) < 0.0)\n            result._points.reverse();\n        if (result._points[result._points.length - 1].isAlmostEqualMetric(result._points[0]))\n            result._points.pop();\n        return result;\n    }\n    get period() {\n        return this._points.length;\n    }\n    indexAfter(i) {\n        return (i + 1) % this._points.length;\n    }\n    indexBefore(i) {\n        return (i + this._points.length - 1) % this._points.length;\n    }\n    pushIndex(primaryPointIndex) {\n        this._stack.push(primaryPointIndex);\n    }\n    static cross(pointA, pointB, pointC) {\n        return pointA.crossProductToPointsXY(pointB, pointC);\n    }\n    /*\n      public isInsideTurn(pointA: Point3d, pointB: Point3d, pointC: Point3d, sign: number) {\n        return sign * AlternatingCCTreeBuilder.cross(pointA, pointB, pointC) > 0;\n      }\n    */\n    cyclicStackPoint(cyclicIndex) {\n        let stackIndex;\n        const stack = this._stack;\n        if (cyclicIndex > 0)\n            stackIndex = cyclicIndex;\n        else\n            stackIndex = cyclicIndex + 10 * stack.length;\n        stackIndex = stackIndex % stack.length;\n        return this._points[stack[stackIndex]];\n    }\n    signFromStackTip(pointIndex, sign) {\n        const pointA = this.cyclicStackPoint(-2);\n        const pointB = this.cyclicStackPoint(-1);\n        const pointC = this._points[pointIndex];\n        return sign * AlternatingCCTreeBuilder.cross(pointA, pointB, pointC) >= 0.0 ? 1 : -1;\n    }\n    /*\n     * Test of xyz is in the convex region bounded by stack points:\n     * <ul>\n     *   <li>polygon[i0]..polygon[i1]\n     *   <li>polygon[j0]..polygon[j1]\n     *   <li>polygon[i0]..polygon[i1]\n     * </ul>\n     * with \"inside\" controlled by sign multiplier.\n    public isConvexContinuation(point: Point3d, i0: number, i1: number, j0: number, j1: number, sign: number): boolean {\n      const points = this.points;\n      const stack = this.stack;\n      return this.isInsideTurn(points[stack[i0]], points[stack[i1]], point, sign)\n          && this.isInsideTurn(points[stack[i0]], points[stack[j0]], point, sign)\n          && this.isInsideTurn(points[stack[j1]], points[stack[i1]], point, sign);\n    }\n     */\n    get indexOfMaxX() {\n        let k = 0;\n        const points = this._points;\n        const nPoints = this._points.length;\n        for (let i = 1; i < nPoints; i++) {\n            if (points[i].x > points[k].x)\n                k = i;\n        }\n        return k;\n    }\n    /** Pop from the stack until the sign condition is satisfied */\n    extendHullChain(k, sign, pushAfterPops) {\n        while (this._stack.length > 1 && this.signFromStackTip(k, sign) < 0.0)\n            this._stack.pop();\n        if (pushAfterPops)\n            this.pushIndex(k);\n    }\n    collectHullChain(kStart, numK, sign) {\n        this._stack.length = 0;\n        if (numK > 2) {\n            let k = kStart;\n            for (let i = 0; i < numK; i++) {\n                this.extendHullChain(k, sign, true);\n                k = this.indexAfter(k);\n            }\n        }\n    }\n    collectHullPointsInArray(points, kStart, numK, _sign) {\n        points.length = 0;\n        if (numK > 2) {\n            let k = kStart;\n            for (let i = 0; i < numK; i++) {\n                points.push(this._points[k]);\n                k = this.indexAfter(k);\n            }\n        }\n    }\n    buildHullTreeGo(root, isPositiveArea, recurseToChildren = true) {\n        this.collectHullChain(root.startIdx, root.numPoints, isPositiveArea ? 1.0 : -1.0);\n        root.points.length = 0;\n        const stack = this._stack;\n        const points = this._points;\n        const stackLen = stack.length;\n        for (let i = 0; i < stackLen; i++) {\n            const k0 = stack[i];\n            root.points.push(points[k0]);\n            if (i + 1 < stackLen) {\n                let k1 = stack[i + 1];\n                if (k1 === this.indexAfter(k0)) {\n                    // two original points in sequence -- need a clip plane right here!!!\n                    const plane = ClipPlane.createEdgeAndUpVector(points[k0], points[k1], Vector3d.create(0, 0, 1), Angle.createRadians(0));\n                    if (plane !== undefined) {\n                        if (isPositiveArea)\n                            plane.negateInPlace();\n                        root.addPlane(plane);\n                    }\n                }\n                else {\n                    if (k1 < k0)\n                        k1 += this.period;\n                    root.addEmptyChild(k0, k1 - k0 + 1);\n                }\n            }\n        }\n        if (recurseToChildren) {\n            for (const child of root.children)\n                this.buildHullTreeGo(child, !isPositiveArea);\n        }\n        else {\n            for (const child of root.children)\n                this.collectHullPointsInArray(child.points, child.startIdx, child.numPoints, isPositiveArea ? -1.0 : 1.0);\n        }\n        return true; // Are there failure modes? What happens with crossing data?..\n    }\n    /**\n     * <ul>\n     * <li> Input a ClipTreeRoot that has start and count data\n     * <li> Build the hull for that data range\n     * <li> Store the hull points in the root\n     * <li> Add children with start and count data\n     * <li> Recursively move to children\n     * </ul>\n     */\n    buildHullAndInletsForPolygon(root) {\n        AlternatingCCTreeNode.createWithIndices(this.indexOfMaxX, this.period + 1, root);\n        return this.buildHullTreeGo(root, true, false);\n    }\n    /**\n     * <ul>\n     * <li> Input a ClipTreeRoot that has start and count data\n     * <li> Build the hull for that data range\n     * <li> Store the hull points in the root\n     * <li> Add children with start and count data\n     * <li> Recursively move to children\n     * </ul>\n     */\n    buildHullTree(root) {\n        AlternatingCCTreeNode.createWithIndices(this.indexOfMaxX, this.period + 1, root);\n        return this.buildHullTreeGo(root, true);\n    }\n}\nclass AlternatingCCTreeNodeCurveClipper {\n    constructor() {\n        this._stackDepth = 0;\n        this._intervalStack = [];\n    }\n    setCurveRef(curve) { this._curve = curve; }\n    popSegmentFrame() {\n        if (this._stackDepth > 0) {\n            this._topOfStack.length = 0; // formality.\n            this._stackDepth -= 1;\n        }\n    }\n    clearSegmentStack() {\n        while (this._stackDepth > 0)\n            this.popSegmentFrame(); // and that will reduce stack depth\n    }\n    pushEmptySegmentFrame() {\n        this._stackDepth += 1;\n        while (this._intervalStack.length < this._stackDepth)\n            this._intervalStack.push([]);\n        this._topOfStack.length = 0;\n    }\n    get _topOfStack() { return this._intervalStack[this._stackDepth - 1]; }\n    // set the top of the stack (as defined by stackDepth -- not array length)\n    set _topOfStack(value) {\n        const n = this._stackDepth;\n        if (n > 0)\n            this._intervalStack[n - 1] = value;\n    }\n    /** Access entry [topOfStack() - numSkip] */\n    stackEntry(numSkip) {\n        if (numSkip <= this._stackDepth)\n            return this._intervalStack[this._stackDepth - 1 - numSkip];\n        else\n            return [];\n    }\n    isTopOfStackEmpty() {\n        return this._topOfStack.length === 0;\n    }\n    appendSingleClipToStack(planes, insideSegments) {\n        const fractionIntervals = AlternatingCCTreeNodeCurveClipper._fractionIntervals;\n        if (this._curve instanceof LineSegment3d) {\n            const segment = this._curve;\n            let f0;\n            let f1;\n            if (segment.announceClipIntervals(planes, (a0, a1, _cp) => { f0 = a0; f1 = a1; })) {\n                insideSegments.push(Range1d.createXX(f0, f1));\n            }\n            return true;\n        }\n        else if (this._curve instanceof Arc3d) {\n            const arc = this._curve;\n            fractionIntervals.length = 0;\n            arc.announceClipIntervals(planes, (a0, a1, _cp) => {\n                fractionIntervals.push(a0);\n                fractionIntervals.push(a1);\n            });\n            for (let i = 0; i < fractionIntervals.length; i += 2)\n                insideSegments.push(Range1d.createXX(fractionIntervals[i], fractionIntervals[i + 1]));\n            return true;\n        }\n        else if (this._curve instanceof LineString3d && (this._curve).points.length > 1) {\n            const linestring = this._curve;\n            let f0;\n            let f1;\n            const nPoints = linestring.points.length;\n            const df = 1.0 / (nPoints - 1);\n            for (let i = 0; i < nPoints - 1; i++) {\n                const segment = LineSegment3d.create(linestring.points[i], linestring.points[i + 1]);\n                if (segment.announceClipIntervals(planes, (a0, a1, _cp) => { f0 = a0; f1 = a1; })) {\n                    insideSegments.push(Range1d.createXX((i + f0) * df, (i + f1) * df));\n                }\n            }\n            return true;\n        }\n        else if (this._curve instanceof BSplineCurve3d) {\n            const bcurve = this._curve;\n            fractionIntervals.length = 0;\n            bcurve.announceClipIntervals(planes, (a0, a1, _cp) => {\n                fractionIntervals.push(a0);\n                fractionIntervals.push(a1);\n            });\n            for (let i = 0; i < fractionIntervals.length; i += 2)\n                insideSegments.push(Range1d.createXX(fractionIntervals[i], fractionIntervals[i + 1]));\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Run one level of recursion. On return, the stack is one level deeper than at entry and the new top of the stack\n     * has clip for this node (expensive -- must clone items of arrays during \"swaps\").\n     */\n    recurse(node) {\n        this.pushEmptySegmentFrame();\n        this.appendSingleClipToStack(node.planes, this._topOfStack);\n        Range1dArray.sort(this._topOfStack);\n        if (this.isTopOfStackEmpty())\n            return;\n        for (const child of node.children) {\n            this.recurse(child);\n            if (!this.isTopOfStackEmpty()) {\n                const ranges = Range1dArray.differenceSorted(this.stackEntry(1), this.stackEntry(0));\n                this.popSegmentFrame();\n                this._topOfStack = ranges;\n            }\n            else {\n                this.popSegmentFrame();\n            }\n            if (this.isTopOfStackEmpty())\n                break;\n        }\n    }\n    /**\n     * Modifies the insideIntervals array given in place.\n     * Note: curve given is passed by reference and stored.\n     */\n    appendSingleClipPrimitive(root, curve, insideIntervals, _outsideIntervals) {\n        this.setCurveRef(curve);\n        this.clearSegmentStack();\n        this.recurse(root);\n        if (this._stackDepth !== 1)\n            return;\n        const intervals = this._topOfStack;\n        for (const interval of intervals) {\n            const f0 = interval.low;\n            const f1 = interval.high;\n            const xyz0 = curve.fractionToPoint(f0);\n            const xyz1 = curve.fractionToPoint(f1);\n            insideIntervals.push(CurveLocationDetailPair.createCapture(CurveLocationDetail.createCurveFractionPoint(curve, f0, xyz0), CurveLocationDetail.createCurveFractionPoint(curve, f1, xyz1)));\n        }\n        this.popSegmentFrame();\n    }\n    /**\n     * Modifies the insideIntervals array given in place.\n     * Note: curve given is passed by reference and stored.\n     */\n    appendCurveCollectionClip(root, curve, insideIntervals, outsideIntervals) {\n        for (const cp of curve.children) {\n            if (cp instanceof CurvePrimitive)\n                this.appendSingleClipPrimitive(root, cp, insideIntervals, outsideIntervals);\n            else if (cp instanceof CurveCollection)\n                this.appendCurveCollectionClip(root, cp, insideIntervals, outsideIntervals);\n        }\n    }\n}\n// Is re-used by method calls\nAlternatingCCTreeNodeCurveClipper._fractionIntervals = [];\nexport { AlternatingCCTreeNodeCurveClipper };\n//# sourceMappingURL=AlternatingConvexClipTree.js.map",
      "start": 1693508125184,
      "end": 1693508125346,
      "sourcemaps": null
    }
  ]
}
