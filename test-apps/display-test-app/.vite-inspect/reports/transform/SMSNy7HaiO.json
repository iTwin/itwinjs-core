{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/geometry4d/Matrix4d.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Numerics\n */\nimport { Geometry } from \"../Geometry\";\nimport { Matrix3d } from \"../geometry3d/Matrix3d\";\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\nimport { Transform } from \"../geometry3d/Transform\";\nimport { Point4d } from \"./Point4d\";\n/**\n * * A Matrix4d is a matrix with 4 rows and 4 columns.\n * * The 4 rows may be described as the x,y,z,w rows.\n * * The 4 columns may be described as the x,y,z,w columns.\n * * The matrix is physically stored as a Float64Array with 16 numbers.\n * * The layout in the Float64Array is \"by row\"\n *   * indices 0,1,2,3 are the \"x row\".   They may be called the xx,xy,xz,xw entries\n *   * indices 4,5,6,7 are the \"y row\"    They may be called the yx,yy,yz,yw entries\n *   * indices 8,9,10,11 are the \"z row\"  They may be called the zx,zy,zz,zw entries\n *   * indices 12,13,14,15 are the \"w row\".  They may be called the wx,wy,wz,ww entries\n * * If \"w row\" contains numeric values 0,0,0,1, the Matrix4d is equivalent to a Transform with\n *  * The upper right 3x3 matrix (entries 0,1,2,4,5,6,8,9,10) are the 3x3 matrix part of the transform\n *  * The far right column entries xw,yw,zw are the \"origin\" (sometimes called \"translation\") part of the transform.\n * @public\n */\nexport class Matrix4d {\n    constructor() { this._coffs = new Float64Array(16); }\n    /** Copy matrix entries from `other` */\n    setFrom(other) {\n        for (let i = 0; i < 16; i++)\n            this._coffs[i] = other._coffs[i];\n    }\n    /** Return a deep clone. */\n    clone(result) {\n        if (result === this)\n            return this;\n        if (result === undefined)\n            result = new Matrix4d();\n        for (let i = 0; i < 16; i++)\n            result._coffs[i] = this._coffs[i];\n        return result;\n    }\n    /** zero this matrix4d in place. */\n    setZero() {\n        for (let i = 0; i < 16; i++)\n            this._coffs[i] = 0;\n    }\n    /** set to identity. */\n    setIdentity() {\n        for (let i = 0; i < 16; i++)\n            this._coffs[i] = 0;\n        this._coffs[0] = this._coffs[5] = this._coffs[10] = this._coffs[15] = 1.0;\n    }\n    static is1000(a, b, c, d, tol) {\n        return Math.abs(a - 1.0) <= tol\n            && Math.abs(b) <= tol\n            && Math.abs(c) <= tol\n            && Math.abs(d) <= tol;\n    }\n    /** set to identity. */\n    isIdentity(tol = 1.0e-10) {\n        return Matrix4d.is1000(this._coffs[0], this._coffs[1], this._coffs[2], this._coffs[3], tol)\n            && Matrix4d.is1000(this._coffs[5], this._coffs[6], this._coffs[7], this._coffs[4], tol)\n            && Matrix4d.is1000(this._coffs[10], this._coffs[11], this._coffs[8], this._coffs[9], tol)\n            && Matrix4d.is1000(this._coffs[15], this._coffs[12], this._coffs[13], this._coffs[14], tol);\n    }\n    /** create a Matrix4d filled with zeros. */\n    static createZero(result) {\n        if (result) {\n            result.setZero();\n            return result;\n        }\n        return new Matrix4d(); // this is zero.\n    }\n    /** create a Matrix4d with values supplied \"across the rows\" */\n    static createRowValues(cxx, cxy, cxz, cxw, cyx, cyy, cyz, cyw, czx, czy, czz, czw, cwx, cwy, cwz, cww, result) {\n        result = result ? result : new Matrix4d();\n        result._coffs[0] = cxx;\n        result._coffs[1] = cxy;\n        result._coffs[2] = cxz;\n        result._coffs[3] = cxw;\n        result._coffs[4] = cyx;\n        result._coffs[5] = cyy;\n        result._coffs[6] = cyz;\n        result._coffs[7] = cyw;\n        result._coffs[8] = czx;\n        result._coffs[9] = czy;\n        result._coffs[10] = czz;\n        result._coffs[11] = czw;\n        result._coffs[12] = cwx;\n        result._coffs[13] = cwy;\n        result._coffs[14] = cwz;\n        result._coffs[15] = cww;\n        return result;\n    }\n    /** Create a `Matrix4d` from 16 values appearing as `Point4d` for each row. */\n    static createRows(rowX, rowY, rowZ, rowW, result) {\n        return this.createRowValues(rowX.x, rowX.y, rowX.z, rowX.w, rowY.x, rowY.y, rowY.z, rowY.w, rowZ.x, rowZ.y, rowZ.z, rowZ.w, rowW.x, rowW.y, rowW.z, rowW.w, result);\n    }\n    /** directly set columns from typical 3d data:\n     *\n     * * vectorX, vectorY, vectorZ as columns 0,1,2, with weight0.\n     * * origin as column3, with weight 1\n     */\n    setOriginAndVectors(origin, vectorX, vectorY, vectorZ) {\n        this._coffs[0] = vectorX.x;\n        this._coffs[1] = vectorY.x;\n        this._coffs[2] = vectorZ.x;\n        this._coffs[3] = origin.x;\n        this._coffs[4] = vectorX.y;\n        this._coffs[5] = vectorY.y;\n        this._coffs[6] = vectorZ.y;\n        this._coffs[7] = origin.y;\n        this._coffs[8] = vectorX.z;\n        this._coffs[9] = vectorY.z;\n        this._coffs[10] = vectorZ.z;\n        this._coffs[11] = origin.z;\n        this._coffs[12] = 0.0;\n        this._coffs[13] = 0.0;\n        this._coffs[14] = 0.0;\n        this._coffs[15] = 1.0;\n    }\n    /** promote a transform to full Matrix4d (with 0001 in final row) */\n    static createTransform(source, result) {\n        const matrix = source.matrix;\n        const point = source.origin;\n        return Matrix4d.createRowValues(matrix.coffs[0], matrix.coffs[1], matrix.coffs[2], point.x, matrix.coffs[3], matrix.coffs[4], matrix.coffs[5], point.y, matrix.coffs[6], matrix.coffs[7], matrix.coffs[8], point.z, 0, 0, 0, 1, result);\n    }\n    /** return an identity matrix. */\n    static createIdentity(result) {\n        result = Matrix4d.createZero(result);\n        result._coffs[0] = 1.0;\n        result._coffs[5] = 1.0;\n        result._coffs[10] = 1.0;\n        result._coffs[15] = 1.0;\n        return result;\n    }\n    /** return matrix with translation directly inserted (along with 1 on diagonal) */\n    static createTranslationXYZ(x, y, z, result) {\n        result = Matrix4d.createZero(result);\n        result._coffs[0] = 1.0;\n        result._coffs[5] = 1.0;\n        result._coffs[10] = 1.0;\n        result._coffs[15] = 1.0;\n        result._coffs[3] = x;\n        result._coffs[7] = y;\n        result._coffs[11] = z;\n        return result;\n    }\n    /** return this matrix plus scale times matrixB. */\n    plusScaled(matrixB, scale, result) {\n        // If result is undefined, a real clone is created.\n        // If result is \"this\" we get the pointer to this right back.\n        // If result is other, \"this\" coffs are copied.\n        // Then we can add matrixB.  (Which we assume is different from this?)\n        result = this.clone(result);\n        for (let i = 0; i < 16; i++)\n            result._coffs[i] += scale * matrixB._coffs[i];\n        return result;\n    }\n    /**\n     * Create a Matrix4d with translation and scaling values directly inserted (along with 1 as final diagonal entry)\n     * @param tx x entry for translation column\n     * @param ty y entry for translation column\n     * @param tz z entry for translation column\n     * @param scaleX x diagonal entry\n     * @param scaleY y diagonal entry\n     * @param scaleZ z diagonal entry\n     * @param result optional result.\n     */\n    static createTranslationAndScaleXYZ(tx, ty, tz, scaleX, scaleY, scaleZ, result) {\n        return Matrix4d.createRowValues(scaleX, 0, 0, tx, 0, scaleY, 0, ty, 0, 0, scaleZ, tz, 0, 0, 0, 1, result);\n    }\n    /**\n     * Create a mapping the scales and translates (no rotation) from box A to boxB\n     * @param lowA low point of box A\n     * @param highA high point of box A\n     * @param lowB low point of box B\n     * @param highB high point of box B\n     */\n    static createBoxToBox(lowA, highA, lowB, highB, result) {\n        const ax = highA.x - lowA.x;\n        const ay = highA.y - lowA.y;\n        const az = highA.z - lowA.z;\n        const bx = highB.x - lowB.x;\n        const by = highB.y - lowB.y;\n        const bz = highB.z - lowB.z;\n        const abx = Geometry.conditionalDivideFraction(bx, ax);\n        const aby = Geometry.conditionalDivideFraction(by, ay);\n        const abz = Geometry.conditionalDivideFraction(bz, az);\n        if (abx !== undefined && aby !== undefined && abz !== undefined) {\n            return Matrix4d.createTranslationAndScaleXYZ(lowB.x - abx * lowA.x, lowB.y - aby * lowA.y, lowB.z - abz * lowA.z, abx, aby, abz, result);\n        }\n        return undefined;\n    }\n    /** Set from nested array json e.g. `[[1,2,3,4],[0,1,2,4],[0,2,5,1],[0,0,1,2]]` */\n    setFromJSON(json) {\n        if (Geometry.isArrayOfNumberArray(json, 4, 4))\n            for (let i = 0; i < 4; ++i) {\n                for (let j = 0; j < 4; ++j)\n                    this._coffs[i * 4 + j] = json[i][j];\n            }\n        else\n            this.setZero();\n    }\n    /**\n     * Return the largest (absolute) difference between this and other Matrix4d.\n     * @param other matrix to compare to\n     */\n    maxDiff(other) {\n        let a = 0.0;\n        for (let i = 0; i < 16; i++)\n            a = Math.max(a, Math.abs(this._coffs[i] - other._coffs[i]));\n        return a;\n    }\n    /**\n     * Return the largest absolute value in the Matrix4d\n     */\n    maxAbs() {\n        let a = 0.0;\n        for (let i = 0; i < 16; i++)\n            a = Math.max(a, Math.abs(this._coffs[i]));\n        return a;\n    }\n    /** Test for near-equality with `other` */\n    isAlmostEqual(other) {\n        return Geometry.isSmallMetricDistance(this.maxDiff(other));\n    }\n    /** Test for exact (bitwise) equality with other. */\n    isExactEqual(other) { return this.maxDiff(other) === 0.0; }\n    /**\n     * Convert an Matrix4d to a Matrix4dProps.\n     */\n    toJSON() {\n        const value = [];\n        for (let i = 0; i < 4; ++i) {\n            const row = i * 4;\n            value.push([this._coffs[row], this._coffs[row + 1], this._coffs[row + 2], this._coffs[row + 3]]);\n        }\n        return value;\n    }\n    /** Create from nested array json e.g. `[[1,2,3,4],[0,1,2,4],[0,2,5,1],[0,0,1,2]]` */\n    static fromJSON(json) {\n        const result = new Matrix4d();\n        result.setFromJSON(json);\n        return result;\n    }\n    /**\n     * Return a point with entries from positions [i0, i0+step, i0+2*step, i0+3*step].\n     * * There are no tests for index going out of the 0..15 range.\n     * * Usual uses are:\n     * * * i0 at left of row (0,4,8,12), step = 1 to extract a row.\n     * * * i0 at top of row (0,1,2,3), step = 4 to extract a column\n     * * * i0 = 0, step = 5 to extract the diagonal\n     * @returns a Point4d with 4 entries taken from positions at steps in the flat 16-member array.\n     * @param i0 start index (for 16 member array)\n     * @param step step between members\n     * @param result optional preallocated point.\n     */\n    getSteppedPoint(i0, step, result) {\n        return Point4d.create(this._coffs[i0], this._coffs[i0 + step], this._coffs[i0 + 2 * step], this._coffs[i0 + 3 * step], result);\n    }\n    /** Return column 0 as Point4d. */\n    columnX() { return this.getSteppedPoint(0, 4); }\n    /** Return column 1 as Point4d. */\n    columnY() { return this.getSteppedPoint(1, 4); }\n    /** Return column 2 as Point4d. */\n    columnZ() { return this.getSteppedPoint(2, 4); }\n    /** Return column 3 as Point4d. */\n    columnW() { return this.getSteppedPoint(3, 4); }\n    /** Return row 0 as Point4d. */\n    rowX() { return this.getSteppedPoint(0, 1); }\n    /** Return row 1 as Point4d. */\n    rowY() { return this.getSteppedPoint(4, 1); }\n    /** Return row 2 as Point4d. */\n    rowZ() { return this.getSteppedPoint(8, 1); }\n    /** Return row 3 as Point4d. */\n    rowW() { return this.getSteppedPoint(12, 1); }\n    /**\n     * Returns true if the w row has content other than [0,0,0,1]\n     */\n    get hasPerspective() {\n        return this._coffs[12] !== 0.0\n            || this._coffs[13] !== 0.0\n            || this._coffs[14] !== 0.0\n            || this._coffs[15] !== 1.0;\n    }\n    /**\n     * Return a Point4d with the diagonal entries of the matrix\n     */\n    diagonal() { return this.getSteppedPoint(0, 5); }\n    /** return the weight component of this matrix */\n    weight() { return this._coffs[15]; }\n    /** return the leading 3x3 matrix part of this matrix */\n    matrixPart() {\n        return Matrix3d.createRowValues(this._coffs[0], this._coffs[1], this._coffs[2], this._coffs[4], this._coffs[5], this._coffs[6], this._coffs[8], this._coffs[9], this._coffs[10]);\n    }\n    /**\n     * Return the (affine, non-perspective) Transform with the upper 3 rows of this matrix\n     * @return undefined if this Matrix4d has perspective effects in the w row.\n     */\n    get asTransform() {\n        if (this.hasPerspective)\n            return undefined;\n        return Transform.createRowValues(this._coffs[0], this._coffs[1], this._coffs[2], this._coffs[3], this._coffs[4], this._coffs[5], this._coffs[6], this._coffs[7], this._coffs[8], this._coffs[9], this._coffs[10], this._coffs[11]);\n    }\n    /** multiply this * other. */\n    multiplyMatrixMatrix(other, result) {\n        result = (result && result !== this && result !== other) ? result : new Matrix4d();\n        for (let i0 = 0; i0 < 16; i0 += 4) {\n            for (let k = 0; k < 4; k++)\n                result._coffs[i0 + k] =\n                    this._coffs[i0] * other._coffs[k] +\n                        this._coffs[i0 + 1] * other._coffs[k + 4] +\n                        this._coffs[i0 + 2] * other._coffs[k + 8] +\n                        this._coffs[i0 + 3] * other._coffs[k + 12];\n        }\n        return result;\n    }\n    /** multiply this * transpose(other). */\n    multiplyMatrixMatrixTranspose(other, result) {\n        result = (result && result !== this && result !== other) ? result : new Matrix4d();\n        let j = 0;\n        for (let i0 = 0; i0 < 16; i0 += 4) {\n            for (let k = 0; k < 16; k += 4)\n                result._coffs[j++] =\n                    this._coffs[i0] * other._coffs[k] +\n                        this._coffs[i0 + 1] * other._coffs[k + 1] +\n                        this._coffs[i0 + 2] * other._coffs[k + 2] +\n                        this._coffs[i0 + 3] * other._coffs[k + 3];\n        }\n        return result;\n    }\n    /** multiply transpose (this) * other. */\n    multiplyMatrixTransposeMatrix(other, result) {\n        result = (result && result !== this && result !== other) ? result : new Matrix4d();\n        let j = 0;\n        for (let i0 = 0; i0 < 4; i0 += 1) {\n            for (let k0 = 0; k0 < 4; k0 += 1)\n                result._coffs[j++] =\n                    this._coffs[i0] * other._coffs[k0] +\n                        this._coffs[i0 + 4] * other._coffs[k0 + 4] +\n                        this._coffs[i0 + 8] * other._coffs[k0 + 8] +\n                        this._coffs[i0 + 12] * other._coffs[k0 + 12];\n        }\n        return result;\n    }\n    /** Return a transposed matrix. */\n    cloneTransposed(result) {\n        return Matrix4d.createRowValues(this._coffs[0], this._coffs[4], this._coffs[8], this._coffs[12], this._coffs[1], this._coffs[5], this._coffs[9], this._coffs[13], this._coffs[2], this._coffs[6], this._coffs[10], this._coffs[14], this._coffs[3], this._coffs[7], this._coffs[11], this._coffs[15], result);\n    }\n    /** multiply matrix times column [x,y,z,w].  return as Point4d.   (And the returned value is NOT normalized down to unit w) */\n    multiplyXYZW(x, y, z, w, result) {\n        result = result ? result : Point4d.createZero();\n        return result.set(this._coffs[0] * x + this._coffs[1] * y + this._coffs[2] * z + this._coffs[3] * w, this._coffs[4] * x + this._coffs[5] * y + this._coffs[6] * z + this._coffs[7] * w, this._coffs[8] * x + this._coffs[9] * y + this._coffs[10] * z + this._coffs[11] * w, this._coffs[12] * x + this._coffs[13] * y + this._coffs[14] * z + this._coffs[15] * w);\n    }\n    /** multiply matrix times column vectors [x,y,z,w] where [x,y,z,w] appear in blocks in an array.\n     * replace the xyzw in the block\n     */\n    multiplyBlockedFloat64ArrayInPlace(data) {\n        const n = data.length;\n        let x, y, z, w;\n        for (let i = 0; i + 3 < n; i += 4) {\n            x = data[i];\n            y = data[i + 1];\n            z = data[i + 2];\n            w = data[i + 3];\n            data[i] = this._coffs[0] * x + this._coffs[1] * y + this._coffs[2] * z + this._coffs[3] * w;\n            data[i + 1] = this._coffs[4] * x + this._coffs[5] * y + this._coffs[6] * z + this._coffs[7] * w;\n            data[i + 2] = this._coffs[8] * x + this._coffs[9] * y + this._coffs[10] * z + this._coffs[11] * w;\n            data[i + 3] = this._coffs[12] * x + this._coffs[13] * y + this._coffs[14] * z + this._coffs[15] * w;\n        }\n    }\n    /** multiply matrix times XYAndZ  and w. return as Point4d  (And the returned value is NOT normalized down to unit w) */\n    multiplyPoint3d(pt, w, result) {\n        return this.multiplyXYZW(pt.x, pt.y, pt.z, w, result);\n    }\n    /** multiply matrix times and array  of XYAndZ. return as array of Point4d  (And the returned value is NOT normalized down to unit w) */\n    multiplyPoint3dArray(pts, results, w = 1.0) {\n        pts.forEach((pt, i) => { results[i] = this.multiplyXYZW(pt.x, pt.y, pt.z, w, results[i]); });\n    }\n    /** multiply [x,y,z,w] times matrix.  return as Point4d.   (And the returned value is NOT normalized down to unit w) */\n    multiplyTransposeXYZW(x, y, z, w, result) {\n        result = result ? result : Point4d.createZero();\n        return result.set(this._coffs[0] * x + this._coffs[4] * y + this._coffs[8] * z + this._coffs[12] * w, this._coffs[1] * x + this._coffs[5] * y + this._coffs[9] * z + this._coffs[13] * w, this._coffs[2] * x + this._coffs[6] * y + this._coffs[10] * z + this._coffs[14] * w, this._coffs[3] * x + this._coffs[7] * y + this._coffs[11] * z + this._coffs[15] * w);\n    }\n    /** Returns dot product of row rowIndex of this with column columnIndex of other.\n     */\n    rowDotColumn(rowIndex, other, columnIndex) {\n        const i = rowIndex * 4;\n        const j = columnIndex;\n        return this._coffs[i] * other._coffs[j]\n            + this._coffs[i + 1] * other._coffs[j + 4]\n            + this._coffs[i + 2] * other._coffs[j + 8]\n            + this._coffs[i + 3] * other._coffs[j + 12];\n    }\n    /** Returns dot product of row rowIndex of this with [x y z w]\n     */\n    rowDotXYZW(rowIndex, x, y, z, w) {\n        const i = rowIndex * 4;\n        return this._coffs[i] * x\n            + this._coffs[i + 1] * y\n            + this._coffs[i + 2] * z\n            + this._coffs[i + 3] * w;\n    }\n    /** Returns dot product of row rowIndexThis of this with row rowIndexOther of other.\n     */\n    rowDotRow(rowIndexThis, other, rowIndexOther) {\n        const i = rowIndexThis * 4;\n        const j = rowIndexOther * 4;\n        return this._coffs[i] * other._coffs[j]\n            + this._coffs[i + 1] * other._coffs[j + 1]\n            + this._coffs[i + 2] * other._coffs[j + 2]\n            + this._coffs[i + 3] * other._coffs[j + 3];\n    }\n    /** Returns dot product of row rowIndexThis of this with row rowIndexOther of other.\n     */\n    columnDotColumn(columnIndexThis, other, columnIndexOther) {\n        const i = columnIndexThis;\n        const j = columnIndexOther;\n        return this._coffs[i] * other._coffs[j]\n            + this._coffs[i + 4] * other._coffs[j + 4]\n            + this._coffs[i + 8] * other._coffs[j + 8]\n            + this._coffs[i + 12] * other._coffs[j + 12];\n    }\n    /** Returns dot product of column columnIndexThis of this with row rowIndexOther other.\n     */\n    columnDotRow(columnIndexThis, other, rowIndexOther) {\n        const i = columnIndexThis;\n        const j = 4 * rowIndexOther;\n        return this._coffs[i] * other._coffs[j]\n            + this._coffs[i + 4] * other._coffs[j + 1]\n            + this._coffs[i + 8] * other._coffs[j + 2]\n            + this._coffs[i + 12] * other._coffs[j + 3];\n    }\n    /** Return a matrix entry by row and column index.\n     */\n    atIJ(rowIndex, columnIndex) {\n        return this._coffs[rowIndex * 4 + columnIndex];\n    }\n    /** Set a matrix entry by row and column index.\n     */\n    setAtIJ(rowIndex, columnIndex, value) {\n        this._coffs[rowIndex * 4 + columnIndex] = value;\n    }\n    /** multiply matrix * [x,y,z,w]. immediately renormalize to return in a Point3d.\n     * If zero weight appears in the result (i.e. input is on eyeplane) leave the mapped xyz untouched.\n     */\n    multiplyXYZWQuietRenormalize(x, y, z, w, result) {\n        result = result ? result : Point3d.createZero();\n        result.set(this._coffs[0] * x + this._coffs[1] * y + this._coffs[2] * z + this._coffs[3] * w, this._coffs[4] * x + this._coffs[5] * y + this._coffs[6] * z + this._coffs[7] * w, this._coffs[8] * x + this._coffs[9] * y + this._coffs[10] * z + this._coffs[11] * w);\n        const w1 = this._coffs[12] * x + this._coffs[13] * y + this._coffs[14] * z + this._coffs[15] * w;\n        const qx = Geometry.conditionalDivideCoordinate(result.x, w1);\n        const qy = Geometry.conditionalDivideCoordinate(result.y, w1);\n        const qz = Geometry.conditionalDivideCoordinate(result.z, w1);\n        if (qx !== undefined && qy !== undefined && qz !== undefined) {\n            result.x = qx;\n            result.y = qy;\n            result.z = qz;\n        }\n        return result;\n    }\n    /** multiply matrix * an array of Point4d. immediately renormalize to return in an array of Point3d. */\n    multiplyPoint4dArrayQuietRenormalize(pts, results) {\n        pts.forEach((pt, i) => { results[i] = this.multiplyXYZWQuietRenormalize(pt.x, pt.y, pt.z, pt.w, results[i]); });\n    }\n    /** multiply a Point4d, return with the optional result convention. */\n    multiplyPoint4d(point, result) {\n        return this.multiplyXYZW(point.xyzw[0], point.xyzw[1], point.xyzw[2], point.xyzw[3], result);\n    }\n    /** multiply a Point4d, return with the optional result convention. */\n    multiplyTransposePoint4d(point, result) {\n        return this.multiplyTransposeXYZW(point.xyzw[0], point.xyzw[1], point.xyzw[2], point.xyzw[3], result);\n    }\n    /** multiply matrix * point. This produces a weighted xyzw.\n     * Immediately renormalize back to xyz and return (with optional result convention).\n     * If zero weight appears in the result (i.e. input is on eyeplane)leave the mapped xyz untouched.\n     */\n    multiplyPoint3dQuietNormalize(point, result) {\n        return this.multiplyXYZWQuietRenormalize(point.x, point.y, point.z, 1.0, result);\n    }\n    /** multiply each matrix * points[i].   This produces a weighted xyzw.\n     * Immediately renormalize back to xyz and replace the original point.\n     * If zero weight appears in the result (i.e. input is on eyeplane)leave the mapped xyz untouched.\n     */\n    multiplyPoint3dArrayQuietNormalize(points) {\n        points.forEach((point) => this.multiplyXYZWQuietRenormalize(point.x, point.y, point.z, 1.0, point));\n    }\n    /**\n     * Add the product terms [xx,xy,xz,xw, yx, yy, yz, yw, zx, zy, zz, zs, wx, wy, wz, ww] to respective entries in the matrix\n     * @param x x component for products\n     * @param y y component for products\n     * @param z z component for products\n     * @param w w component for products\n     */\n    addMomentsInPlace(x, y, z, w) {\n        this._coffs[0] += x * x;\n        this._coffs[1] += x * y;\n        this._coffs[2] += x * z;\n        this._coffs[3] += x * w;\n        this._coffs[4] += y * x;\n        this._coffs[5] += y * y;\n        this._coffs[6] += y * z;\n        this._coffs[7] += y * w;\n        this._coffs[8] += z * x;\n        this._coffs[9] += z * y;\n        this._coffs[10] += z * z;\n        this._coffs[11] += z * w;\n        this._coffs[12] += w * x;\n        this._coffs[13] += w * y;\n        this._coffs[14] += w * z;\n        this._coffs[15] += w * w;\n    }\n    /** accumulate all coefficients of other to this. */\n    addScaledInPlace(other, scale = 1.0) {\n        for (let i = 0; i < 16; i++)\n            this._coffs[i] += scale * other._coffs[i];\n    }\n    /**\n     * Add scale times rowA to rowB.\n     * @param rowIndexA row that is not modified\n     * @param rowIndexB row that is modified.\n     * @param firstColumnIndex first column modified.  All from there to the right are updated\n     * @param scale scale\n     */\n    rowOperation(rowIndexA, rowIndexB, firstColumnIndex, scale) {\n        if (scale === 0.0)\n            return;\n        let iA = rowIndexA * 4 + firstColumnIndex;\n        let iB = rowIndexB * 4 + firstColumnIndex;\n        for (let i = firstColumnIndex; i < 4; i++, iA++, iB++)\n            this._coffs[iB] += scale * this._coffs[iA];\n    }\n    /** Return the determinant of the matrix. */\n    determinant() {\n        const c = this._coffs;\n        return Geometry.determinant4x4(c[0], c[1], c[2], c[3], c[4], c[5], c[6], c[7], c[8], c[9], c[10], c[11], c[12], c[13], c[14], c[15]);\n    }\n    /** Compute an inverse matrix.\n     * * This uses direct formulas with various determinants.\n     * * If result is given, it is ALWAYS filled with values \"prior to dividing by the determinant\".\n     * *\n     * @returns undefined if dividing by the determinant looks unsafe.\n     */\n    createInverse(result) {\n        // dividing each column by its maxAbs is more robust than dividing them by this.maxAbs()\n        let maxAbs0 = this.columnX().maxAbs();\n        if (maxAbs0 === 0.0)\n            return undefined;\n        const divMaxAbsA = 1.0 / maxAbs0;\n        maxAbs0 = this.columnY().maxAbs();\n        if (maxAbs0 === 0.0)\n            return undefined;\n        const divMaxAbsB = 1.0 / maxAbs0;\n        maxAbs0 = this.columnZ().maxAbs();\n        if (maxAbs0 === 0.0)\n            return undefined;\n        const divMaxAbsC = 1.0 / maxAbs0;\n        maxAbs0 = this.columnW().maxAbs();\n        if (maxAbs0 === 0.0)\n            return undefined;\n        const divMaxAbsD = 1.0 / maxAbs0;\n        const columnA = this.columnX();\n        const columnB = this.columnY();\n        const columnC = this.columnZ();\n        const columnD = this.columnW();\n        columnA.scale(divMaxAbsA, columnA);\n        columnB.scale(divMaxAbsB, columnB);\n        columnC.scale(divMaxAbsC, columnC);\n        columnD.scale(divMaxAbsD, columnD);\n        const rowBCD = Point4d.perpendicularPoint4dPlane(columnB, columnC, columnD);\n        const rowCDA = Point4d.perpendicularPoint4dPlane(columnA, columnD, columnC); // order for negation !\n        const rowDAB = Point4d.perpendicularPoint4dPlane(columnD, columnA, columnB);\n        const rowABC = Point4d.perpendicularPoint4dPlane(columnC, columnB, columnA); // order for negation !\n        // The matrix is singular if the determinant is zero.\n        // But what is the proper tolerance for zero?\n        // The row values are generally cubes of entries. And the typical perspective matrix\n        //    has very different magnitudes in various parts.  So a typical cube size is really hard.\n        // Compute 4 different determinants.  They should match.\n        // If they are near zero, maybe a sign change is a red flag for singular case.\n        // (And there's a lot less work to do that than was done to make the rows)\n        result = Matrix4d.createRows(rowBCD, rowCDA, rowDAB, rowABC, result);\n        const determinantA = rowBCD.dotProduct(columnA);\n        const determinantB = rowCDA.dotProduct(columnB);\n        const determinantC = rowDAB.dotProduct(columnC);\n        const determinantD = rowABC.dotProduct(columnD);\n        const maxAbs1 = result.maxAbs();\n        if (determinantA * determinantB > 0.0\n            && determinantA * determinantC > 0.0\n            && determinantA * determinantD > 0.0) {\n            const divisionTest = Geometry.conditionalDivideCoordinate(maxAbs1, determinantA);\n            if (divisionTest !== undefined) {\n                const divDet = 1.0 / determinantA;\n                result.scaleRowsInPlace(divMaxAbsA * divDet, divMaxAbsB * divDet, divMaxAbsC * divDet, divMaxAbsD * divDet);\n                return result;\n            }\n        }\n        else {\n            return undefined; // this is a useful spot to break to see if the 4 determinant test is effective.\n        }\n        return undefined;\n    }\n    /** Returns an array-of-arrays of the matrix rows, optionally passing each value through a function.\n     * @param f optional function to provide alternate values for each entry (e.g. force fuzz to zero.)\n     */\n    rowArrays(f) {\n        if (f)\n            return [\n                [f(this._coffs[0]), f(this._coffs[1]), f(this._coffs[2]), f(this._coffs[3])],\n                [f(this._coffs[4]), f(this._coffs[5]), f(this._coffs[6]), f(this._coffs[7])],\n                [f(this._coffs[8]), f(this._coffs[9]), f(this._coffs[10]), f(this._coffs[11])],\n                [f(this._coffs[12]), f(this._coffs[13]), f(this._coffs[14]), f(this._coffs[15])]\n            ];\n        else\n            return [\n                [this._coffs[0], this._coffs[1], this._coffs[2], this._coffs[3]],\n                [this._coffs[4], this._coffs[5], this._coffs[6], this._coffs[7]],\n                [this._coffs[8], this._coffs[9], this._coffs[10], this._coffs[11]],\n                [this._coffs[12], this._coffs[13], this._coffs[14], this._coffs[15]]\n            ];\n    }\n    /**\n     * Scale each row by respective scale factors.\n     * @param ax scale factor for row 0\n     * @param ay scale factor for row 1\n     * @param az scale factor for row 2\n     * @param aw scale factor for row 3\n     */\n    scaleRowsInPlace(ax, ay, az, aw) {\n        for (let i = 0; i < 4; i++)\n            this._coffs[i] *= ax;\n        for (let i = 4; i < 8; i++)\n            this._coffs[i] *= ay;\n        for (let i = 8; i < 12; i++)\n            this._coffs[i] *= az;\n        for (let i = 12; i < 16; i++)\n            this._coffs[i] *= aw;\n    }\n    /**\n     * add an outer product (single column times single row times scale factor) to this matrix.\n     * @param vectorU column vector\n     * @param vectorV row vector\n     * @param scale scale factor\n     */\n    addScaledOuterProductInPlace(vectorU, vectorV, scale) {\n        let a = vectorU.x * scale;\n        this._coffs[0] += a * vectorV.x;\n        this._coffs[1] += a * vectorV.y;\n        this._coffs[2] += a * vectorV.z;\n        this._coffs[3] += a * vectorV.w;\n        a = vectorU.y * scale;\n        this._coffs[4] += a * vectorV.x;\n        this._coffs[5] += a * vectorV.y;\n        this._coffs[6] += a * vectorV.z;\n        this._coffs[7] += a * vectorV.w;\n        a = vectorU.z * scale;\n        this._coffs[8] += a * vectorV.x;\n        this._coffs[9] += a * vectorV.y;\n        this._coffs[10] += a * vectorV.z;\n        this._coffs[11] += a * vectorV.w;\n        a = vectorU.w * scale;\n        this._coffs[12] += a * vectorV.x;\n        this._coffs[13] += a * vectorV.y;\n        this._coffs[14] += a * vectorV.z;\n        this._coffs[15] += a * vectorV.w;\n    }\n    /**\n     * ADD (n place) scale*A*B*AT where\n     * * A is a pure translation with final column [x,y,z,1]\n     * * B is the given `matrixB`\n     * * AT is the transpose of A.\n     * * scale is a multiplier.\n     * @param matrixB the middle matrix.\n     * @param ax x part of translation\n     * @param ay y part of translation\n     * @param az z part of translation\n     * @param scale scale factor for entire product\n     */\n    addTranslationSandwichInPlace(matrixB, ax, ay, az, scale) {\n        const bx = matrixB._coffs[3];\n        const by = matrixB._coffs[7];\n        const bz = matrixB._coffs[11];\n        // matrixB can be non-symmetric!!\n        const cx = matrixB._coffs[12];\n        const cy = matrixB._coffs[13];\n        const cz = matrixB._coffs[14];\n        const beta = matrixB._coffs[15];\n        const axBeta = ax * beta;\n        const ayBeta = ay * beta;\n        const azBeta = az * beta;\n        this._coffs[0] += scale * (matrixB._coffs[0] + ax * bx + cx * ax + ax * axBeta);\n        this._coffs[1] += scale * (matrixB._coffs[1] + ay * bx + cy * ax + ax * ayBeta);\n        this._coffs[2] += scale * (matrixB._coffs[2] + az * bx + cz * ax + ax * azBeta);\n        this._coffs[3] += scale * (bx + axBeta);\n        this._coffs[4] += scale * (matrixB._coffs[4] + ax * by + cx * ay + ay * axBeta);\n        this._coffs[5] += scale * (matrixB._coffs[5] + ay * by + cy * ay + ay * ayBeta);\n        this._coffs[6] += scale * (matrixB._coffs[6] + az * by + cz * ay + ay * azBeta);\n        this._coffs[7] += scale * (by + ayBeta);\n        this._coffs[8] += scale * (matrixB._coffs[8] + ax * bz + cx * az + az * axBeta);\n        this._coffs[9] += scale * (matrixB._coffs[9] + ay * bz + cy * az + az * ayBeta);\n        this._coffs[10] += scale * (matrixB._coffs[10] + az * bz + cz * az + az * azBeta);\n        this._coffs[11] += scale * (bz + azBeta);\n        this._coffs[12] += scale * (cx + axBeta);\n        this._coffs[13] += scale * (cy + ayBeta);\n        this._coffs[14] += scale * (cz + azBeta);\n        this._coffs[15] += scale * beta;\n    }\n    /**\n     * Multiply and replace contents of this matrix by A*this*AT where\n     * * A is a pure translation with final column [x,y,z,1]\n     * * this is this matrix.\n     * * AT is the transpose of A.\n     * * scale is a multiplier.\n     * @param matrixB the middle matrix.\n     * @param ax x part of translation\n     * @param ay y part of translation\n     * @param az z part of translation\n     * @param scale scale factor for entire product\n     */\n    multiplyTranslationSandwichInPlace(ax, ay, az) {\n        const bx = this._coffs[3];\n        const by = this._coffs[7];\n        const bz = this._coffs[11];\n        // matrixB can be non-symmetric!!\n        const cx = this._coffs[12];\n        const cy = this._coffs[13];\n        const cz = this._coffs[14];\n        const beta = this._coffs[15];\n        const axBeta = ax * beta;\n        const ayBeta = ay * beta;\n        const azBeta = az * beta;\n        this._coffs[0] += (ax * bx + cx * ax + ax * axBeta);\n        this._coffs[1] += (ay * bx + cy * ax + ax * ayBeta);\n        this._coffs[2] += (az * bx + cz * ax + ax * azBeta);\n        this._coffs[3] += axBeta;\n        this._coffs[4] += (ax * by + cx * ay + ay * axBeta);\n        this._coffs[5] += (ay * by + cy * ay + ay * ayBeta);\n        this._coffs[6] += (az * by + cz * ay + ay * azBeta);\n        this._coffs[7] += ayBeta;\n        this._coffs[8] += (ax * bz + cx * az + az * axBeta);\n        this._coffs[9] += (ay * bz + cy * az + az * ayBeta);\n        this._coffs[10] += (az * bz + cz * az + az * azBeta);\n        this._coffs[11] += azBeta;\n        this._coffs[12] += axBeta;\n        this._coffs[13] += ayBeta;\n        this._coffs[14] += azBeta;\n        // coffs[15] is unchanged !!!\n    }\n}\n//# sourceMappingURL=Matrix4d.js.map",
      "start": 1693508123423,
      "end": 1693508123574,
      "sourcemaps": null
    }
  ]
}
