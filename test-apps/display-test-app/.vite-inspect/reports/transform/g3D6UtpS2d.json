{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/serialization/BGFBReader.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Serialization\n */\nimport { flatbuffers } from \"flatbuffers\";\nimport { BGFBAccessors } from \"./BGFBAccessors\";\nimport { LineSegment3d } from \"../curve/LineSegment3d\";\nimport { Arc3d } from \"../curve/Arc3d\";\nimport { AngleSweep } from \"../geometry3d/AngleSweep\";\nimport { LineString3d } from \"../curve/LineString3d\";\nimport { IndexedPolyface } from \"../polyface/Polyface\";\nimport { BagOfCurves } from \"../curve/CurveCollection\";\nimport { Loop } from \"../curve/Loop\";\nimport { Path } from \"../curve/Path\";\nimport { UnionRegion } from \"../curve/UnionRegion\";\nimport { ParityRegion } from \"../curve/ParityRegion\";\nimport { BSplineCurve3dH } from \"../bspline/BSplineCurve3dH\";\nimport { BSplineCurve3d } from \"../bspline/BSplineCurve\";\nimport { Box } from \"../solid/Box\";\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\nimport { Transform } from \"../geometry3d/Transform\";\nimport { Sphere } from \"../solid/Sphere\";\nimport { Cone } from \"../solid/Cone\";\nimport { TorusPipe } from \"../solid/TorusPipe\";\nimport { Angle } from \"../geometry3d/Angle\";\nimport { LinearSweep } from \"../solid/LinearSweep\";\nimport { RotationalSweep } from \"../solid/RotationalSweep\";\nimport { Ray3d } from \"../geometry3d/Ray3d\";\nimport { RuledSweep } from \"../solid/RuledSweep\";\nimport { GeometryQuery } from \"../curve/GeometryQuery\";\nimport { BSplineSurface3d, BSplineSurface3dH } from \"../bspline/BSplineSurface\";\nimport { PointString3d } from \"../curve/PointString3d\";\nimport { AuxChannel, AuxChannelData, PolyfaceAuxData } from \"../polyface/AuxData\";\nimport { TransitionSpiral3d } from \"../curve/spiral/TransitionSpiral3d\";\nimport { Geometry } from \"../Geometry\";\nimport { Segment1d } from \"../geometry3d/Segment1d\";\nimport { IntegratedSpiral3d } from \"../curve/spiral/IntegratedSpiral3d\";\nimport { DirectSpiral3d } from \"../curve/spiral/DirectSpiral3d\";\nimport { TaggedNumericData } from \"../polyface/TaggedNumericData\";\nimport { InterpolationCurve3d, InterpolationCurve3dOptions } from \"../bspline/InterpolationCurve3d\";\nimport { NumberArray, Point3dArray } from \"../geometry3d/PointHelpers\";\nimport { AkimaCurve3d, AkimaCurve3dOptions } from \"../bspline/AkimaCurve3d\";\n/** * Context to write to a flatbuffer blob.\n *  * This class is internal.\n *  * Public access is through BentleyGeometryFlatBuffer.geometryToBytes()\n * @internal\n */\nexport class BGFBReader {\n    constructor() {\n    }\n    /**\n     * Extract a bspline surface\n     * @param variant read position in the flat buffer.\n     */\n    readBSplineSurfaceFromVariant(variantHeader) {\n        const geometryType = variantHeader.geometryType();\n        if (geometryType === BGFBAccessors.VariantGeometryUnion.tagBsplineSurface) {\n            const bsurfHeader = variantHeader.geometry(new BGFBAccessors.BsplineSurface());\n            if (bsurfHeader !== null) {\n                const orderU = bsurfHeader.orderU();\n                const orderV = bsurfHeader.orderV();\n                const numPolesU = bsurfHeader.numPolesU();\n                const numPolesV = bsurfHeader.numPolesV();\n                const xyzArray = bsurfHeader.polesArray();\n                const knotArrayU = bsurfHeader.knotsUArray();\n                const knotArrayV = bsurfHeader.knotsVArray();\n                const weightArray = bsurfHeader.weightsArray();\n                // const closed = header.closed();\n                if (xyzArray !== null && knotArrayU !== null && knotArrayV !== null)\n                    if (weightArray === null) {\n                        return BSplineSurface3d.create(xyzArray, numPolesU, orderU, knotArrayU, numPolesV, orderV, knotArrayV);\n                    }\n                    else {\n                        return BSplineSurface3dH.create(xyzArray, weightArray, numPolesU, orderU, knotArrayU, numPolesV, orderV, knotArrayV);\n                    }\n            }\n        }\n        return undefined;\n    }\n    /**\n    * Extract an interpolating curve\n    * @param variant read position in the flat buffer.\n    */\n    readInterpolationCurve3d(header) {\n        const xyzArray = header.fitPointsArray();\n        if (xyzArray instanceof Float64Array) {\n            const knots = header.knotsArray();\n            const options = new InterpolationCurve3dOptions(Point3dArray.clonePoint3dArray(xyzArray), knots ? NumberArray.create(knots) : undefined);\n            const startTangent = header.startTangent();\n            const endTangent = header.endTangent();\n            options.captureOptionalProps(header.order(), header.closed(), header.isChordLenKnots(), header.isColinearTangents(), header.isChordLenTangents(), header.isNaturalTangents(), startTangent !== null ? Vector3d.create(startTangent.x(), startTangent.y(), startTangent.z()) : undefined, endTangent !== null ? Vector3d.create(endTangent.x(), endTangent.y(), endTangent.z()) : undefined);\n            return InterpolationCurve3d.createCapture(options);\n        }\n        return undefined;\n    }\n    /**\n     * Extract an akima curve\n     * @param variant read position in the flat buffer.\n     */\n    readAkimaCurve3d(header) {\n        const xyzArray = header.pointsArray();\n        if (xyzArray instanceof Float64Array) {\n            const options = new AkimaCurve3dOptions(Point3dArray.clonePoint3dArray(xyzArray));\n            return AkimaCurve3d.createCapture(options);\n        }\n        return undefined;\n    }\n    /**\n       * Extract a bspline curve\n       * @param variant read position in the flat buffer.\n       */\n    readBSplineCurve(header) {\n        const order = header.order();\n        const xyzArray = header.polesArray();\n        const knots = header.knotsArray();\n        const weightsArray = header.weightsArray();\n        // const closed = header.closed();\n        if (xyzArray !== null && knots !== null)\n            if (weightsArray === null) {\n                return BSplineCurve3d.create(xyzArray, knots, order);\n            }\n            else {\n                return BSplineCurve3dH.create({ xyz: xyzArray, weights: weightsArray }, knots, order);\n            }\n        return undefined;\n    }\n    /**\n     * Extract a bspline curve\n     * @param variant read position in the flat buffer.\n     */\n    readTransitionSpiral(header) {\n        const detailHeader = header.detail();\n        if (detailHeader) {\n            const directDetailHeader = header.directDetail();\n            const _extraDataArray = header.extraDataArray();\n            const spiralTypeName = DgnSpiralTypeQueries.typeCodeToString(detailHeader.spiralType());\n            const curvature0 = detailHeader.curvature0();\n            const curvature1 = detailHeader.curvature1();\n            const bearing0Radians = detailHeader.bearing0Radians();\n            const bearing1Radians = detailHeader.bearing1Radians();\n            const fbTransform = detailHeader.transform();\n            const localToWorld = fbTransform ? Transform.createRowValues(fbTransform.axx(), fbTransform.axy(), fbTransform.axz(), fbTransform.axw(), fbTransform.ayx(), fbTransform.ayy(), fbTransform.ayz(), fbTransform.ayw(), fbTransform.azx(), fbTransform.azy(), fbTransform.azz(), fbTransform.azw()) :\n                Transform.createIdentity();\n            const activeFractionInterval = Segment1d.create(detailHeader.fractionA(), detailHeader.fractionB());\n            if (!directDetailHeader) {\n                const integratedSpiral = IntegratedSpiral3d.createRadiusRadiusBearingBearing(Segment1d.create(IntegratedSpiral3d.curvatureToRadius(curvature0), IntegratedSpiral3d.curvatureToRadius(curvature1)), AngleSweep.createStartEndRadians(bearing0Radians, bearing1Radians), activeFractionInterval, localToWorld, spiralTypeName);\n                if (integratedSpiral)\n                    return integratedSpiral;\n                const radius0 = TransitionSpiral3d.curvatureToRadius(curvature0);\n                const radius1 = TransitionSpiral3d.curvatureToRadius(curvature1);\n                const arcLength = TransitionSpiral3d.radiusRadiusSweepRadiansToArcLength(radius0, radius1, bearing1Radians - bearing0Radians);\n                const directSpiral = DirectSpiral3d.createFromLengthAndRadius(spiralTypeName, radius0, radius1, Angle.createRadians(bearing0Radians), Angle.createRadians(bearing1Radians), arcLength, activeFractionInterval, localToWorld);\n                if (directSpiral)\n                    return directSpiral;\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Extract a curve primitive\n     * @param variant read position in the flat buffer.\n     */\n    readCurvePrimitiveFromVariant(variant) {\n        const geometryType = variant.geometryType();\n        if (geometryType === BGFBAccessors.VariantGeometryUnion.tagLineSegment) {\n            const offsetToLineSegment = variant.geometry(new BGFBAccessors.LineSegment());\n            const offsetToCoordinates = offsetToLineSegment.segment();\n            return LineSegment3d.createXYZXYZ(offsetToCoordinates.point0X(), offsetToCoordinates.point0Y(), offsetToCoordinates.point0Z(), offsetToCoordinates.point1X(), offsetToCoordinates.point1Y(), offsetToCoordinates.point1Z());\n        }\n        else if (geometryType === BGFBAccessors.VariantGeometryUnion.tagEllipticArc) {\n            const offsetToEllipticArc = variant.geometry(new BGFBAccessors.EllipticArc());\n            const offsetToCoordinates = offsetToEllipticArc.arc();\n            return Arc3d.createXYZXYZXYZ(offsetToCoordinates.centerX(), offsetToCoordinates.centerY(), offsetToCoordinates.centerZ(), offsetToCoordinates.vector0X(), offsetToCoordinates.vector0Y(), offsetToCoordinates.vector0Z(), offsetToCoordinates.vector90X(), offsetToCoordinates.vector90Y(), offsetToCoordinates.vector90Z(), AngleSweep.createStartSweepRadians(offsetToCoordinates.startRadians(), offsetToCoordinates?.sweepRadians()));\n        }\n        else if (geometryType === BGFBAccessors.VariantGeometryUnion.tagLineString) {\n            const offsetToLineString = variant.geometry(new BGFBAccessors.LineString());\n            const numCoordinates = offsetToLineString.pointsLength();\n            const result = LineString3d.create();\n            for (let i = 0; i + 2 < numCoordinates; i += 3) {\n                result.packedPoints.pushXYZ(offsetToLineString.points(i), offsetToLineString.points(i + 1), offsetToLineString.points(i + 2));\n            }\n            return result;\n        }\n        else if (geometryType === BGFBAccessors.VariantGeometryUnion.tagBsplineCurve) {\n            const offsetToBCurve = variant.geometry(new BGFBAccessors.BsplineCurve());\n            if (offsetToBCurve !== null)\n                return this.readBSplineCurve(offsetToBCurve);\n        }\n        else if (geometryType === BGFBAccessors.VariantGeometryUnion.tagTransitionSpiral) {\n            const offsetToTransitionSpiralTable = variant.geometry(new BGFBAccessors.TransitionSpiral());\n            if (offsetToTransitionSpiralTable !== null)\n                return this.readTransitionSpiral(offsetToTransitionSpiralTable);\n        }\n        else if (geometryType === BGFBAccessors.VariantGeometryUnion.tagInterpolationCurve) {\n            const offsetToInterpolationCurveTable = variant.geometry(new BGFBAccessors.InterpolationCurve());\n            if (offsetToInterpolationCurveTable !== null)\n                return this.readInterpolationCurve3d(offsetToInterpolationCurveTable);\n        }\n        else if (geometryType === BGFBAccessors.VariantGeometryUnion.tagAkimaCurve) {\n            const offsetToAkimaCurveTable = variant.geometry(new BGFBAccessors.AkimaCurve());\n            if (offsetToAkimaCurveTable !== null)\n                return this.readAkimaCurve3d(offsetToAkimaCurveTable);\n        }\n        return undefined;\n    }\n    /**\n     * Extract a curve primitive\n     * @param variant read position in the flat buffer.\n     */\n    readPointStringFromVariant(variant) {\n        const geometryType = variant.geometryType();\n        if (geometryType === BGFBAccessors.VariantGeometryUnion.tagPointString) {\n            const offsetToLineString = variant.geometry(new BGFBAccessors.PointString());\n            const numCoordinates = offsetToLineString.pointsLength();\n            const result = PointString3d.create();\n            for (let i = 0; i + 2 < numCoordinates; i += 3) {\n                result.points.push(Point3d.create(offsetToLineString.points(i), offsetToLineString.points(i + 1), offsetToLineString.points(i + 2)));\n            }\n            return result;\n        }\n        return undefined;\n    }\n    /**\n   * Extract auxData for a mesh\n   * @param variant read position in the flat buffer.\n   */\n    readPolyfaceAuxChannelData(channelDataHeader) {\n        if (channelDataHeader !== null) {\n            const input = channelDataHeader.input();\n            const values = channelDataHeader.valuesArray();\n            if (values !== null)\n                return new AuxChannelData(input, values);\n        }\n        return undefined;\n    }\n    /**\n   * Extract auxData for a mesh\n   * @param variant read position in the flat buffer.\n   */\n    readPolyfaceAuxChannel(channelHeader) {\n        if (channelHeader) {\n            const dataType = channelHeader.dataType();\n            const dataLength = channelHeader.dataLength();\n            const channelDataArray = [];\n            const name = channelHeader.name();\n            const inputName = channelHeader.inputName();\n            for (let i = 0; i < dataLength; i++) {\n                const channelData = this.readPolyfaceAuxChannelData(channelHeader.data(i));\n                if (channelData)\n                    channelDataArray.push(channelData);\n            }\n            return new AuxChannel(channelDataArray, dataType, name ? name : undefined, inputName ? inputName : undefined);\n        }\n        return undefined;\n    }\n    /**\n   * Extract auxData for a mesh\n   * @param variant read position in the flat buffer.\n   */\n    readPolyfaceAuxData(auxDataHeader) {\n        if (auxDataHeader) {\n            const channelsLength = auxDataHeader.channelsLength();\n            const indicesArray = auxDataHeader.indicesArray();\n            const indices = [];\n            const channels = [];\n            if (null !== indicesArray) {\n                for (const i of indicesArray)\n                    indices.push(i);\n            }\n            if (0 !== channelsLength) {\n                for (let i = 0; i < channelsLength; i++) {\n                    const channelHeader = auxDataHeader.channels(i);\n                    const channelContent = this.readPolyfaceAuxChannel(channelHeader);\n                    if (channelContent)\n                        channels.push(channelContent);\n                }\n            }\n            return new PolyfaceAuxData(channels, indices);\n        }\n        return undefined;\n    }\n    /**\n   * Extract auxData for a mesh\n   * @param variant read position in the flat buffer.\n   */\n    readTaggedNumericData(accessor) {\n        if (accessor) {\n            const taggedNumericData = new TaggedNumericData(accessor.tagA(), accessor.tagB());\n            const intDataArray = nullToUndefined(accessor.intDataArray());\n            const doubleDataArray = nullToUndefined(accessor.doubleDataArray());\n            if (intDataArray) {\n                taggedNumericData.intData = [];\n                for (const c of intDataArray)\n                    taggedNumericData.intData.push(c);\n            }\n            if (doubleDataArray) {\n                taggedNumericData.doubleData = [];\n                for (const c of doubleDataArray)\n                    taggedNumericData.doubleData.push(c);\n            }\n            return taggedNumericData;\n        }\n        return undefined;\n    }\n    /**\n   * Extract a mesh\n   * @param variant read position in the flat buffer.\n   */\n    readPolyfaceFromVariant(variant) {\n        const geometryType = variant.geometryType();\n        if (geometryType === BGFBAccessors.VariantGeometryUnion.tagPolyface) {\n            const polyfaceHeader = variant.geometry(new BGFBAccessors.Polyface());\n            if (polyfaceHeader) {\n                const twoSided = polyfaceHeader.twoSided();\n                const expectedClosure = polyfaceHeader.expectedClosure();\n                const meshStyle = polyfaceHeader.meshStyle();\n                const numPerFace = polyfaceHeader.numPerFace();\n                const pointF64 = nullToUndefined(polyfaceHeader.pointArray());\n                const paramF64 = nullToUndefined(polyfaceHeader.paramArray());\n                const normalF64 = nullToUndefined(polyfaceHeader.normalArray());\n                const intColorU32 = nullToUndefined(polyfaceHeader.intColorArray());\n                const pointIndexI32 = nullToUndefined(polyfaceHeader.pointIndexArray());\n                const paramIndexI32 = nullToUndefined(polyfaceHeader.paramIndexArray());\n                const normalIndexI32 = nullToUndefined(polyfaceHeader.normalIndexArray());\n                const colorIndexI32 = nullToUndefined(polyfaceHeader.colorIndexArray());\n                const taggedNumericDataOffset = polyfaceHeader.taggedNumericData();\n                if (meshStyle === 1 && pointF64 && pointIndexI32) {\n                    const polyface = IndexedPolyface.create(normalF64 !== undefined, paramF64 !== undefined, intColorU32 !== undefined, twoSided);\n                    polyface.expectedClosure = expectedClosure;\n                    for (let i = 0; i + 2 < pointF64?.length; i += 3)\n                        polyface.data.point.pushXYZ(pointF64[i], pointF64[i + 1], pointF64[i + 2]);\n                    if (paramF64) {\n                        for (let i = 0; i + 1 < paramF64?.length; i += 2)\n                            polyface.data.param.pushXY(paramF64[i], paramF64[i + 1]);\n                    }\n                    if (normalF64) {\n                        for (let i = 0; i + 2 < normalF64?.length; i += 3)\n                            polyface.data.normal.pushXYZ(normalF64[i], normalF64[i + 1], normalF64[i + 2]);\n                    }\n                    if (intColorU32) {\n                        for (const c of intColorU32)\n                            polyface.data.color.push(c);\n                    }\n                    // The flatbuffer data is one based.\n                    // If numPerFace is less than 2, facets are variable size and zero terminated\n                    // If numPerFace is 2 or more, indices are blocked\n                    const numIndex = pointIndexI32.length;\n                    const addIndicesInBlock = (k0, k1) => {\n                        for (let k = k0; k < k1; k++) {\n                            const q = pointIndexI32[k];\n                            polyface.addPointIndex(Math.abs(q) - 1, q > 0);\n                            if (normalF64 && normalIndexI32) {\n                                polyface.addNormalIndex(Math.abs(normalIndexI32[k]) - 1);\n                            }\n                            if (paramF64 && paramIndexI32) {\n                                polyface.addParamIndex(Math.abs(paramIndexI32[k]) - 1);\n                            }\n                            if (intColorU32 && colorIndexI32) {\n                                polyface.addColorIndex(Math.abs(colorIndexI32[k]) - 1);\n                            }\n                        }\n                    };\n                    if (numPerFace > 1) {\n                        for (let i0 = 0; i0 + numPerFace <= numIndex; i0 += numPerFace) {\n                            addIndicesInBlock(i0, i0 + numPerFace);\n                            polyface.terminateFacet(true);\n                        }\n                    }\n                    else {\n                        let i0 = 0;\n                        for (let i1 = i0; i1 < numIndex; i1++) {\n                            if (pointIndexI32[i1] === 0) {\n                                addIndicesInBlock(i0, i1);\n                                polyface.terminateFacet(true);\n                                i0 = i1 + 1;\n                            }\n                        }\n                    }\n                    polyface.data.auxData = this.readPolyfaceAuxData(polyfaceHeader.auxData());\n                    if (taggedNumericDataOffset) {\n                        const taggedNumericDataAccessor = nullToUndefined(taggedNumericDataOffset);\n                        if (taggedNumericDataAccessor !== undefined) {\n                            const taggedNumericData = this.readTaggedNumericData(taggedNumericDataAccessor);\n                            if (taggedNumericData !== undefined)\n                                polyface.data.setTaggedNumericData(taggedNumericData);\n                        }\n                    }\n                    return polyface;\n                }\n            }\n        }\n        return undefined;\n    }\n    readCurveCollectionFromCurveVectorTable(cvTable) {\n        const numChildren = cvTable.curvesLength();\n        const collectionType = cvTable.type();\n        const collection = createTypedCurveCollection(collectionType);\n        for (let i = 0; i < numChildren; i++) {\n            const childOffset = cvTable.curves(i);\n            if (childOffset !== null) {\n                const child = this.readCurvePrimitiveFromVariant(childOffset);\n                if (child)\n                    collection.tryAddChild(child);\n                else {\n                    const childCollection = this.readCurveCollectionFromVariantGeometry(childOffset);\n                    if (childCollection)\n                        collection.tryAddChild(childCollection);\n                }\n            }\n        }\n        return collection;\n    }\n    /**\n   * Extract a curve collection\n   * @param variant read position in the flat buffer.\n   */\n    readCurveCollectionFromVariantGeometry(variant) {\n        const geometryType = variant.geometryType();\n        if (geometryType === BGFBAccessors.VariantGeometryUnion.tagCurveVector) {\n            const cvTable = variant.geometry(new BGFBAccessors.CurveVector());\n            return this.readCurveCollectionFromCurveVectorTable(cvTable);\n        }\n        return undefined;\n    }\n    /**\n   * Extract a curve collection\n   * @param variant read position in the flat buffer.\n   */\n    readSolidPrimitiveFromVariant(variant) {\n        const geometryType = variant.geometryType();\n        if (geometryType === BGFBAccessors.VariantGeometryUnion.tagDgnBox) {\n            const header = variant.geometry(new BGFBAccessors.DgnBox());\n            const detail = header.detail();\n            return Box.createDgnBox(Point3d.create(detail.baseOriginX(), detail.baseOriginY(), detail.baseOriginZ()), Vector3d.create(detail.vectorXX(), detail.vectorXY(), detail.vectorXZ()), Vector3d.create(detail.vectorYX(), detail.vectorYY(), detail.vectorYZ()), Point3d.create(detail.topOriginX(), detail.topOriginY(), detail.topOriginZ()), detail.baseX(), detail.baseY(), detail.topX(), detail.topY(), detail.capped());\n        }\n        if (geometryType === BGFBAccessors.VariantGeometryUnion.tagDgnSphere) {\n            const header = variant.geometry(new BGFBAccessors.DgnSphere());\n            const detail = header.detail();\n            const lToWDetail = detail.localToWorld();\n            const localToWorld = Transform.createRowValues(lToWDetail.axx(), lToWDetail.axy(), lToWDetail.axz(), lToWDetail.axw(), lToWDetail.ayx(), lToWDetail.ayy(), lToWDetail.ayz(), lToWDetail.ayw(), lToWDetail.azx(), lToWDetail.azy(), lToWDetail.azz(), lToWDetail.azw());\n            return Sphere.createEllipsoid(localToWorld, AngleSweep.createStartSweepRadians(detail.startLatitudeRadians(), detail.latitudeSweepRadians()), detail.capped());\n        }\n        if (geometryType === BGFBAccessors.VariantGeometryUnion.tagDgnCone) {\n            const header = variant.geometry(new BGFBAccessors.DgnCone());\n            const detail = header.detail();\n            const centerA = Point3d.create(detail.centerAX(), detail.centerAY(), detail.centerAZ());\n            const centerB = Point3d.create(detail.centerBX(), detail.centerBY(), detail.centerBZ());\n            const vector0 = Vector3d.create(detail.vector0X(), detail.vector0Y(), detail.vector0Z());\n            const vector90 = Vector3d.create(detail.vector90X(), detail.vector90Y(), detail.vector90Z());\n            const radiusA = detail.radiusA();\n            const radiusB = detail.radiusB();\n            return Cone.createBaseAndTarget(centerA, centerB, vector0, vector90, radiusA, radiusB, detail.capped());\n        }\n        if (geometryType === BGFBAccessors.VariantGeometryUnion.tagDgnTorusPipe) {\n            const header = variant.geometry(new BGFBAccessors.DgnTorusPipe());\n            const detail = header.detail();\n            const center = Point3d.create(detail.centerX(), detail.centerY(), detail.centerZ());\n            const vectorX = Vector3d.create(detail.vectorXX(), detail.vectorXY(), detail.vectorXZ());\n            const vectorY = Vector3d.create(detail.vectorYX(), detail.vectorYY(), detail.vectorYZ());\n            const sweepRadians = detail.sweepRadians();\n            const majorRadius = detail.majorRadius();\n            const minorRadius = detail.minorRadius();\n            return TorusPipe.createDgnTorusPipe(center, vectorX, vectorY, majorRadius, minorRadius, Angle.createRadians(sweepRadians), detail.capped());\n        }\n        if (geometryType === BGFBAccessors.VariantGeometryUnion.tagDgnExtrusion) {\n            const header = variant.geometry(new BGFBAccessors.DgnExtrusion());\n            const dVector = new BGFBAccessors.DVector3d();\n            header.extrusionVector(dVector);\n            const extrusionVector = Vector3d.create(dVector.x(), dVector.y(), dVector.z());\n            const baseCurve = header.baseCurve();\n            if (baseCurve !== null) {\n                const contour = this.readCurveCollectionFromCurveVectorTable(baseCurve);\n                return LinearSweep.create(contour, extrusionVector, header.capped());\n            }\n        }\n        if (geometryType === BGFBAccessors.VariantGeometryUnion.tagDgnRotationalSweep) {\n            const header = variant.geometry(new BGFBAccessors.DgnRotationalSweep());\n            const dAxis = new BGFBAccessors.DRay3d();\n            header.axis(dAxis);\n            const axis = Ray3d.createXYZUVW(dAxis.x(), dAxis.y(), dAxis.z(), dAxis.ux(), dAxis.uy(), dAxis.uz());\n            const sweepAngle = Angle.createRadians(header.sweepRadians());\n            // const numVRules = header.numVRules();\n            const baseCurve = header.baseCurve();\n            if (baseCurve !== null) {\n                const contour = this.readCurveCollectionFromCurveVectorTable(baseCurve);\n                return RotationalSweep.create(contour, axis, sweepAngle, header.capped());\n            }\n        }\n        if (geometryType === BGFBAccessors.VariantGeometryUnion.tagDgnRuledSweep) {\n            const header = variant.geometry(new BGFBAccessors.DgnRuledSweep());\n            const numCurves = header.curvesLength();\n            const contours = [];\n            for (let i = 0; i < numCurves; i++) {\n                const contourTable = header.curves(i);\n                if (contourTable) {\n                    const contour = this.readCurveCollectionFromCurveVectorTable(contourTable);\n                    if (contour)\n                        contours.push(contour);\n                }\n            }\n            if (contours.length > 0) {\n                return RuledSweep.create(contours, header.capped());\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Extract any geometry type or array of geometry.\n     * @param variant read position in the flat buffer.\n     */\n    readGeometryQueryFromVariant(variant) {\n        const rootType = variant.geometryType();\n        switch (rootType) {\n            case BGFBAccessors.VariantGeometryUnion.tagLineSegment:\n            case BGFBAccessors.VariantGeometryUnion.tagLineString:\n            case BGFBAccessors.VariantGeometryUnion.tagEllipticArc:\n            case BGFBAccessors.VariantGeometryUnion.tagBsplineCurve:\n            case BGFBAccessors.VariantGeometryUnion.tagTransitionSpiral:\n            case BGFBAccessors.VariantGeometryUnion.tagInterpolationCurve:\n            case BGFBAccessors.VariantGeometryUnion.tagAkimaCurve:\n                {\n                    return this.readCurvePrimitiveFromVariant(variant);\n                }\n            case BGFBAccessors.VariantGeometryUnion.tagCurveVector:\n                {\n                    return this.readCurveCollectionFromVariantGeometry(variant);\n                }\n            case BGFBAccessors.VariantGeometryUnion.tagPolyface:\n                {\n                    return this.readPolyfaceFromVariant(variant);\n                }\n            case BGFBAccessors.VariantGeometryUnion.tagDgnBox:\n            case BGFBAccessors.VariantGeometryUnion.tagDgnCone:\n            case BGFBAccessors.VariantGeometryUnion.tagDgnTorusPipe:\n            case BGFBAccessors.VariantGeometryUnion.tagDgnSphere:\n            case BGFBAccessors.VariantGeometryUnion.tagDgnExtrusion:\n            case BGFBAccessors.VariantGeometryUnion.tagDgnRotationalSweep:\n            case BGFBAccessors.VariantGeometryUnion.tagDgnRuledSweep:\n                {\n                    return this.readSolidPrimitiveFromVariant(variant);\n                }\n            case BGFBAccessors.VariantGeometryUnion.tagVectorOfVariantGeometry:\n                {\n                    const geometry = [];\n                    const offsetToVectorOfVariantGeometry = variant.geometry(new BGFBAccessors.VectorOfVariantGeometry());\n                    for (let i = 0; i < offsetToVectorOfVariantGeometry.membersLength(); i++) {\n                        const child = offsetToVectorOfVariantGeometry.members(i);\n                        if (child !== null) {\n                            const childGeometry = this.readGeometryQueryFromVariant(child);\n                            if (childGeometry instanceof GeometryQuery) {\n                                geometry.push(childGeometry);\n                            }\n                            else if (Array.isArray(childGeometry)) {\n                                geometry.push(...childGeometry);\n                            }\n                        }\n                    }\n                    return geometry;\n                }\n            case BGFBAccessors.VariantGeometryUnion.tagBsplineSurface: {\n                return this.readBSplineSurfaceFromVariant(variant);\n            }\n            case BGFBAccessors.VariantGeometryUnion.tagPointString:\n                {\n                    return this.readPointStringFromVariant(variant);\n                }\n        }\n        return undefined;\n    }\n    /**\n     * Deserialize bytes from a flatbuffer.\n     * @param justTheBytes FlatBuffer bytes as created by BGFBWriter.createFlatBuffer (g);\n     */\n    static bytesToGeometry(theBytes, signature) {\n        const newByteBuffer = new flatbuffers.ByteBuffer(theBytes);\n        if (signature) {\n            if (theBytes.length < signature.length)\n                return undefined;\n            for (let i = 0; i < signature.length; i++)\n                if (theBytes[i] !== signature[i])\n                    return undefined;\n            newByteBuffer.setPosition(signature.length);\n        }\n        const root = BGFBAccessors.VariantGeometry.getRootAsVariantGeometry(newByteBuffer);\n        const reader = new BGFBReader();\n        return reader.readGeometryQueryFromVariant(root);\n    }\n}\n/**\n * if data is \"null\" (the deprecated javascript idiom!) return undefined.  Otherwise return the data as its own type.\n * @param data\n */\nfunction nullToUndefined(data) {\n    if (data === null)\n        return undefined;\n    return data;\n}\nfunction createTypedCurveCollection(collectionType) {\n    if (collectionType === 1)\n        return new Path();\n    if (collectionType === 2 || collectionType === 3)\n        return new Loop();\n    if (collectionType === 4)\n        return new ParityRegion();\n    if (collectionType === 5)\n        return new UnionRegion();\n    return new BagOfCurves();\n}\n/**\n * mappings between typescript spiral type strings and native integers.\n * @internal\n */\nclass DgnSpiralTypeQueries {\n    /** Convert native integer type (e.g. from flatbuffer) to typescript string */\n    static typeCodeToString(typeCode) {\n        for (const entry of DgnSpiralTypeQueries.spiralTypeCodeMap) {\n            if (entry[0] === typeCode)\n                return entry[1];\n        }\n        return undefined;\n    }\n    /** Convert typescript string to native integer type */\n    static stringToTypeCode(s, defaultToClothoid = true) {\n        for (const entry of DgnSpiralTypeQueries.spiralTypeCodeMap) {\n            if (Geometry.equalStringNoCase(s, entry[1]))\n                return entry[0];\n        }\n        return defaultToClothoid ? 10 : undefined;\n    }\n    /** Ask if the indicated type code is a \"direct\" spiral */\n    static isDirectSpiralType(typeCode) {\n        return typeCode >= 50;\n    }\n}\n// remark: this is the full list based on native DSpiral2dBase.h.\n//   This does not guarantee all types are supported.\nDgnSpiralTypeQueries.spiralTypeCodeMap = [\n    [10, \"clothoid\"],\n    [11, \"bloss\"],\n    [12, \"biquadratic\"],\n    [13, \"cosine\"],\n    [14, \"sine\"],\n    [15, \"Viennese\"],\n    [16, \"weightedViennese\"],\n    [50, \"WesternAustralian\"],\n    [51, \"Czech\"],\n    [52, \"AustralianRailCorp\"],\n    [53, \"Italian\"],\n    [54, \"PolishCubic\"],\n    [55, \"Arema\"],\n    [56, \"MXCubicAlongArc\"],\n    [57, \"MXCubicAlongTangent\"],\n    [58, \"ChineseCubic\"],\n    [60, \"HalfCosine\"],\n    [61, \"JapaneseCubic\"],\n];\nexport { DgnSpiralTypeQueries };\n//# sourceMappingURL=BGFBReader.js.map",
      "start": 1693508125548,
      "end": 1693508125651,
      "sourcemaps": null
    }
  ]
}
