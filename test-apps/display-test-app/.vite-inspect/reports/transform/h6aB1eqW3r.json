{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/solid/LinearSweep.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\nimport { LineString3d } from \"../curve/LineString3d\";\nimport { Loop } from \"../curve/Loop\";\nimport { Path } from \"../curve/Path\";\nimport { Vector3d } from \"../geometry3d/Point3dVector3d\";\nimport { PolygonOps } from \"../geometry3d/PolygonOps\";\nimport { Transform } from \"../geometry3d/Transform\";\nimport { SolidPrimitive } from \"./SolidPrimitive\";\nimport { SweepContour } from \"./SweepContour\";\n/**\n * A LinearSweep is a `SolidPrimitive` defined by\n * * A set of curves (any Loop, Path, or parityRegion)\n * * A sweep vector\n * If the object is \"capped\", the curves must be planar.\n * @public\n */\nexport class LinearSweep extends SolidPrimitive {\n    constructor(contour, direction, capped) {\n        super(capped);\n        /** String name for schema properties */\n        this.solidPrimitiveType = \"linearSweep\";\n        this._contour = contour;\n        this._direction = direction;\n    }\n    /**\n     * Create a sweep of a starting contour.\n     * @param contour contour to be swept\n     * @param direction sweep vector.  The contour is swept the full length of the vector.\n     * @param capped true to include end caps\n     */\n    static create(contour, direction, capped) {\n        const sweepable = SweepContour.createForLinearSweep(contour, direction);\n        if (!sweepable)\n            return undefined;\n        return new LinearSweep(sweepable, direction, capped);\n    }\n    /** Create a z-direction sweep of the polyline or polygon given as xy linestring values.\n     * * If not capped, the xyPoints array is always used unchanged.\n     * * If capped but the xyPoints array does not close, exact closure will be enforced by one of these:\n     * * * If the final point is almost equal to the first, it is replaced by the exact first point.\n     * * * if the final point is not close to the first an extra point is added.\n     * * If capped, the point order will be reversed if necessary to produce positive volume.\n     * @param xyPoints array of xy coordinates\n     * @param z z value to be used for all coordinates\n     * @param zSweep the sweep distance in the z direction.\n     * @param capped true if caps are to be added.\n     */\n    static createZSweep(xyPoints, z, zSweep, capped) {\n        const xyz = LineString3d.createXY(xyPoints, z, capped);\n        if (capped) {\n            xyz.addClosurePoint();\n            const area = PolygonOps.areaXY(xyz.points);\n            if (area * zSweep < 0.0)\n                xyz.points.reverse();\n        }\n        const contour = capped ? Loop.create(xyz) : Path.create(xyz);\n        return LinearSweep.create(contour, Vector3d.create(0, 0, zSweep), capped);\n    }\n    /** get a reference to the swept curves */\n    getCurvesRef() { return this._contour.curves; }\n    /** Get a reference to the `SweepContour` carrying the plane of the curves */\n    getSweepContourRef() { return this._contour; }\n    /** return a clone of the sweep vector */\n    cloneSweepVector() { return this._direction.clone(); }\n    /** Test if `other` is also an instance of `LinearSweep` */\n    isSameGeometryClass(other) { return other instanceof LinearSweep; }\n    /** Return a deep clone */\n    clone() {\n        return new LinearSweep(this._contour.clone(), this._direction.clone(), this.capped);\n    }\n    /** apply a transform to the curves and sweep vector */\n    tryTransformInPlace(transform) {\n        if (transform.matrix.isSingular())\n            return false;\n        if (this._contour.tryTransformInPlace(transform)) {\n            transform.multiplyVector(this._direction, this._direction);\n            return true;\n        }\n        return false;\n    }\n    /** Return a coordinate frame (right handed unit vectors)\n     * * origin on base contour\n     * * x, y directions from base contour.\n     * * z direction perpendicular\n     */\n    getConstructiveFrame() {\n        return this._contour.localToWorld.cloneRigid();\n    }\n    /** Return a transformed clone */\n    cloneTransformed(transform) {\n        const result = this.clone();\n        result.tryTransformInPlace(transform);\n        return result;\n    }\n    /** Test for near-equality of coordinates in `other` */\n    isAlmostEqual(other) {\n        if (other instanceof LinearSweep) {\n            return this._contour.isAlmostEqual(other._contour)\n                && this._direction.isAlmostEqual(other._direction)\n                && this.capped === other.capped;\n        }\n        return false;\n    }\n    /** Invoke strongly typed `handler.handleLinearSweep(this)` */\n    dispatchToGeometryHandler(handler) {\n        return handler.handleLinearSweep(this);\n    }\n    /**\n     * Return the curves at a fraction along the sweep direction.\n     * @param vFraction fractional position along the sweep direction\n     */\n    constantVSection(vFraction) {\n        const section = this._contour.curves.clone();\n        if (section && vFraction !== 0.0)\n            section.tryTransformInPlace(Transform.createTranslation(this._direction.scale(vFraction)));\n        return section;\n    }\n    /** Extend `rangeToExtend` to include this geometry. */\n    extendRange(rangeToExtend, transform) {\n        const contourRange = this._contour.curves.range(transform);\n        rangeToExtend.extendRange(contourRange);\n        if (transform) {\n            const transformedDirection = transform.multiplyVector(this._direction);\n            contourRange.low.addInPlace(transformedDirection);\n            contourRange.high.addInPlace(transformedDirection);\n        }\n        else {\n            contourRange.low.addInPlace(this._direction);\n            contourRange.high.addInPlace(this._direction);\n        }\n        rangeToExtend.extendRange(contourRange);\n    }\n    /**\n     * @return true if this is a closed volume.\n     */\n    get isClosedVolume() {\n        return this.capped && this._contour.curves.isAnyRegionType;\n    }\n}\n//# sourceMappingURL=LinearSweep.js.map",
      "start": 1693508123760,
      "end": 1693508123884,
      "sourcemaps": null
    }
  ]
}
