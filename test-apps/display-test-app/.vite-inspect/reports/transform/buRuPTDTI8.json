{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend-devtools/lib/esm/effects/LensDistortion.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Effects\n */\nimport { assert } from \"@itwin/core-bentley\";\nimport { Tool, UniformType, VaryingType } from \"@itwin/core-frontend\";\nimport { AddEffectTool, refreshViewportsForEffect } from \"./EffectTools\";\nimport { parseArgs } from \"../tools/parseArgs\";\n/** Adds a screen-space effect to the selected [[Viewport]] to simulate the lens distortion produced by real-world cameras with very wide fields of view.\n * Based on https://www.decarpentier.nl/lens-distortion\n * The effect is improved considerably by enabling anti-aliasing (e.g., via [RenderSystem.Options.antialiasSamples]($frontend) at startup, or using the `fdt aasamples` key-in`).\n * @note Because this effect applies a non-linear transform to each pixel, operations like snapping to geometry will not work properly. Element locate will work however - @see [ScreenSpaceEffectSource.sampleSourcePixel]($frontend).\n * @beta\n */\nclass LensDistortionEffect extends AddEffectTool {\n    get effectName() { return \"lensdistortion\"; }\n    get textureCoordFromPosition() { return true; }\n    get source() {\n        return {\n            vertex: `\r\n        void effectMain(vec4 position) {\r\n          vec2 uv = textureCoordFromPosition(position);\r\n          float scaledHeight = strength * height;\r\n          float cylAspectRatio = aspectRatio * cylindricalRatio;\r\n          float aspectDiagSq = aspectRatio * aspectRatio + 1.0;\r\n          float diagSq = scaledHeight * scaledHeight * aspectDiagSq;\r\n          vec2 signedUV = (2.0 * uv + vec2(-1.0, -1.0));\r\n\r\n          float z = 0.5 * sqrt(diagSq + 1.0) + 0.5;\r\n          float ny = (z - 1.0) / (cylAspectRatio * cylAspectRatio + 1.0);\r\n\r\n          vUVDot = sqrt(ny) * vec2(cylAspectRatio, 1.0) * signedUV;\r\n          vUV = vec3(0.5, 0.5, 1.0) * z + vec3(-0.5, -0.5, 0.0);\r\n          vUV.xy += uv;\r\n        }`,\n            // We simply shift pixels - we don't alter their colors.\n            fragment: `\r\n        vec4 effectMain() {\r\n          return sampleSourcePixel();\r\n        }`,\n            // Because we're moving pixels around, we must tell the render system where the source pixel was originally located - otherwise\n            // element locate will not work correctly.\n            sampleSourcePixel: `\r\n        vec3 uv = dot(vUVDot, vUVDot) * vec3(-0.5, -0.5, -1.0) + vUV;\r\n        return TEXTURE_PROJ(u_diffuse, uv);\r\n      `,\n        };\n    }\n    defineEffect(builder) {\n        // Lens distortion is only applicable to views with the camera enabled.\n        builder.shouldApply = (context) => context.viewport.isCameraOn;\n        builder.addVarying(\"vUV\", VaryingType.Vec3);\n        builder.addVarying(\"vUVDot\", VaryingType.Vec2);\n        builder.addUniform({\n            name: \"strength\",\n            type: UniformType.Float,\n            bind: (uniform) => uniform.setUniform1f(LensDistortionConfig.strength),\n        });\n        builder.addUniform({\n            name: \"cylindricalRatio\",\n            type: UniformType.Float,\n            bind: (uniform) => uniform.setUniform1f(LensDistortionConfig.cylindricalRatio),\n        });\n        builder.addUniform({\n            name: \"aspectRatio\",\n            type: UniformType.Float,\n            bind: (uniform, context) => uniform.setUniform1f(context.viewport.viewRect.aspect),\n        });\n        builder.addUniform({\n            name: \"height\",\n            type: UniformType.Float,\n            bind: (uniform, context) => {\n                assert(context.viewport.view.is3d() && context.viewport.view.isCameraOn);\n                const fov = context.viewport.view.camera.lens.radians;\n                const height = Math.tan(fov / 2) / context.viewport.viewRect.aspect;\n                uniform.setUniform1f(height);\n            },\n        });\n    }\n}\nLensDistortionEffect.toolId = \"LensDistortionEffect\";\nexport { LensDistortionEffect };\n/** Configures the [[LensDistortionEffect]].\n * @beta\n */\nclass LensDistortionConfig extends Tool {\n    static get minArgs() { return 0; }\n    static get maxArgs() { return 2; }\n    async run(strength, ratio) {\n        LensDistortionConfig.strength = strength ?? 0.5;\n        LensDistortionConfig.cylindricalRatio = ratio ?? 0.5;\n        refreshViewportsForEffect(\"fdt lensdistortion\");\n        return true;\n    }\n    async parseAndRun(...input) {\n        const args = parseArgs(input);\n        return this.run(args.getFloat(\"s\"), args.getFloat(\"r\"));\n    }\n}\nLensDistortionConfig.toolId = \"LensDistortionConfig\";\nLensDistortionConfig.strength = 0.5;\nLensDistortionConfig.cylindricalRatio = 0.5;\nexport { LensDistortionConfig };\n//# sourceMappingURL=LensDistortion.js.map",
      "start": 1693508122592,
      "end": 1693508122699,
      "sourcemaps": null
    }
  ]
}
