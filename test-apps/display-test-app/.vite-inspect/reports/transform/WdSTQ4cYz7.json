{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/numerics/Range1dArray.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Numerics\n */\nimport { Geometry } from \"../Geometry\";\nimport { GrowableFloat64Array } from \"../geometry3d/GrowableFloat64Array\";\nimport { Range1d } from \"../geometry3d/Range\";\n/**\n * A Range1d array is a set of intervals, such as occur when a line is clipped to a (nonconvex) polygon\n * @internal\n */\nexport class Range1dArray {\n    /** Internal step: Caller supplies rangeA = interval from left operand of set difference {A - B}\n     *  ib = lowest possible index of overlapping interval of {B}\n     *  Output live parts of rangeA, advancing B over intervals that do not extend beyond {rangeA}\n     *  iB is advanced to the first interval whose high is to the right of {rangeA.high}\n     */\n    static advanceIntervalDifference(rangeA, dataB, iB, retVal) {\n        const nB = dataB.length;\n        let low = rangeA.low;\n        let high = rangeA.high;\n        while (iB < nB) {\n            const rangeB = dataB[iB];\n            if (rangeB.high < low) {\n                iB++;\n            }\n            else if (rangeB.high <= high) {\n                if (rangeB.low > low)\n                    retVal.push(Range1d.createXX(low, rangeB.low));\n                low = rangeB.high;\n                iB++;\n            }\n            else {\n                // B ends beyond rangeA...\n                if (rangeB.low < high)\n                    high = rangeB.low;\n                break;\n            }\n        }\n        if (low < high)\n            retVal.push(Range1d.createXX(low, high));\n        return retVal;\n    }\n    /** Intersect intervals in two pre-sorted sets. Output may NOT be the same as either input. */\n    static differenceSorted(dataA, dataB) {\n        const nA = dataA.length;\n        const iB = 0;\n        const retVal = [];\n        for (let iA = 0; iA < nA; iA++) {\n            Range1dArray.advanceIntervalDifference(dataA[iA], dataB, iB, retVal);\n        }\n        return retVal;\n    }\n    /** Internal step: Caller ensures rangeA is the \"lower\" interval.\n     *  Look rangeB to decide (a) what output interval to create and (b) which read index to advance.\n     *  Returns true or false to indicate whether the value associated with rangeA or rangeB should be incremented after this function returns\n     */\n    static advanceIntervalIntersection(rangeA, rangeB, retVal) {\n        if (rangeB.low > rangeA.high) {\n            return true;\n        }\n        else if (rangeB.high >= rangeA.high) {\n            retVal.push(Range1d.createXX(rangeB.low, rangeA.high));\n            return true;\n        }\n        else {\n            retVal.push(Range1d.createXX(rangeB.low, rangeB.high));\n            return false;\n        }\n    }\n    /** Boolean intersection among the (presorted) input ranges */\n    static intersectSorted(dataA, dataB) {\n        let iA = 0;\n        let iB = 0;\n        const nA = dataA.length;\n        const nB = dataB.length;\n        const retVal = [];\n        while (iA < nA && iB < nB) {\n            const rangeA = dataA[iA];\n            const rangeB = dataB[iB];\n            if (rangeA.low <= rangeB.low) {\n                if (Range1dArray.advanceIntervalIntersection(rangeA, rangeB, retVal))\n                    iA++;\n                else\n                    iB++;\n            }\n            else {\n                if (Range1dArray.advanceIntervalIntersection(rangeB, rangeA, retVal))\n                    iB++;\n                else\n                    iA++;\n            }\n        }\n        return retVal;\n    }\n    /** Internal step: Read an interval from the array.\n     *  If it overlaps the work interval, advance the work interval, and return true to notify caller to increment read index.\n     */\n    static advanceIntervalUnion(workRange, source, readIndex) {\n        if (readIndex >= source.length)\n            return false;\n        const candidate = source[readIndex];\n        if (candidate.low > workRange.high)\n            return false;\n        if (candidate.high > workRange.high)\n            workRange.high = candidate.high;\n        return true;\n    }\n    /** Boolean union among the (presorted) input ranges */\n    static unionSorted(dataA, dataB) {\n        const nA = dataA.length;\n        const nB = dataB.length;\n        let iA = 0;\n        let iB = 0;\n        const retVal = [];\n        while (iA < nA && iB < nB) {\n            const rangeA = dataA[iA];\n            const rangeB = dataB[iB];\n            let workRange;\n            // Pull from the lower of rangeA and rangeB. This always advances exactly one of the indices -- progress towards getting out.\n            if (rangeA.low <= rangeB.low) {\n                workRange = rangeA.clone();\n                iA++;\n            }\n            else {\n                workRange = rangeB.clone();\n                iB++;\n            }\n            let toLoop = true;\n            do {\n                const resultA = Range1dArray.advanceIntervalUnion(workRange, dataA, iA);\n                const resultB = Range1dArray.advanceIntervalUnion(workRange, dataB, iB);\n                if (resultA)\n                    iA++;\n                if (resultB)\n                    iB++;\n                if (!(resultA || resultB))\n                    toLoop = false;\n            } while (toLoop);\n            retVal.push(workRange);\n        }\n        while (iA < nA)\n            retVal.push(dataA[iA++]);\n        while (iB < nB)\n            retVal.push(dataB[iB++]);\n        return retVal;\n    }\n    /** Boolean parity among the (presorted) input ranges */\n    static paritySorted(dataA, dataB) {\n        // Combine the two arrays, and then perform a simplification using simplifySortParity function\n        const retVal = [];\n        for (const range of dataA)\n            retVal.push(range.clone());\n        for (const range of dataB)\n            retVal.push(range.clone());\n        // Sort the array\n        retVal.sort(compareRange1dLexicalLowHigh);\n        Range1dArray.simplifySortParity(retVal, true);\n        return retVal;\n    }\n    /** Uses the Range1d specific compare function `compareRange1dLexicalLowHigh` for sorting the array of ranges */\n    static sort(data) {\n        data.sort(compareRange1dLexicalLowHigh);\n    }\n    /** Cleans up the array, compressing any overlapping ranges. If removeZeroLengthRanges is set to true, will also remove any Ranges in the form (x, x) */\n    static simplifySortUnion(data, removeZeroLengthRanges = false) {\n        if (data.length < 2)\n            return;\n        data.sort(compareRange1dLexicalLowHigh);\n        let currentIndex = 0; // last accepted interval\n        for (let i = 1; i < data.length; i++) {\n            if (data[i].low <= data[currentIndex].high) {\n                // extend the current range\n                if (data[i].high > data[currentIndex].high)\n                    data[currentIndex].high = data[i].high;\n            }\n            else {\n                // data[i] is a new entry.\n                currentIndex++;\n                data[currentIndex].setFrom(data[i]);\n            }\n        }\n        data.length = currentIndex + 1;\n        if (removeZeroLengthRanges) {\n            currentIndex = -1;\n            for (let i = 0; i < data.length; i++) {\n                if (data[i].low < data[i].high) {\n                    if (currentIndex < i)\n                        data[++currentIndex].setFrom(data[i]);\n                }\n            }\n        }\n    }\n    /** Apply parity logic among ranges which are not pre-sorted. */\n    static simplifySortParity(data, removeZeroLengthRanges = false) {\n        const numData = [];\n        for (const range of data) {\n            if (range.low !== range.high) {\n                numData.push(range.low);\n                numData.push(range.high);\n            }\n        }\n        const n = numData.length;\n        numData.sort((a, b) => {\n            if (a < b)\n                return -1;\n            if (a > b)\n                return 1;\n            return 0;\n        });\n        let currIdx = 0;\n        let x0;\n        let x1;\n        for (let i = 0; i < n; i += 2) {\n            x0 = numData[i];\n            x1 = numData[i + 1];\n            if (!removeZeroLengthRanges) {\n                Range1d.createXX(x0, x1, data[currIdx++]);\n            }\n            else {\n                // coalesce intervals that share end and start:\n                while (i + 2 < n && numData[i + 2] === x1) {\n                    i += 2;\n                    x1 = numData[i + 1];\n                }\n                if (x1 > x0)\n                    Range1d.createXX(x0, x1, data[currIdx++]);\n            }\n        }\n        data.length = currIdx;\n    }\n    /** test if value is \"in\" by union rules.\n     * * This considers all intervals-- i.e. does not expect or take advantage of sorting.\n     */\n    static testUnion(data, value) {\n        return this.countContainingRanges(data, value) > 0;\n    }\n    /** test if value is \"in\" by parity rules.\n     * * This considers all intervals-- i.e. does not expect or take advantage of sorting.\n     */\n    static testParity(data, value) {\n        let inside = false;\n        for (const range of data) {\n            if (range.containsX(value))\n                inside = !inside;\n        }\n        return inside;\n    }\n    /** linear search to count number of intervals which contain `value`.\n     */\n    static countContainingRanges(data, value) {\n        let n = 0;\n        for (const range of data) {\n            if (range.containsX(value))\n                n++;\n        }\n        return n;\n    }\n    /** return an array with all the low and high values of all the ranges.\n     * @param data array of ranges.\n     * @param sort optionally request immediate sort.\n     * @param compress optionally request removal of duplicates.\n     */\n    static getBreaks(data, result, sort = false, compress = false, clear = true) {\n        if (!result)\n            result = new GrowableFloat64Array(2 * data.length);\n        if (clear)\n            result.clear();\n        for (const range of data) {\n            result.push(range.low);\n            result.push(range.high);\n        }\n        if (sort)\n            result.sort();\n        if (compress)\n            result.compressAdjacentDuplicates();\n        return result;\n    }\n    /**  evaluate a point at an array of given fraction values\n     * @param data array of ranges.\n     * @param initialRangeFraction fraction coordinate applied only to first range. (typically negative)\n     * @param rangeFraction fraction within each range.\n     * @param includeDegenerateRange if false, skip rangeFraction for 0-length ranges.\n     * @param gapFraction fraction within interval from each range high to successor low\n     * @param includeDegenerateGap if false, skip rangeFraction for 0-length gaps.\n     * @param finalRangeFraction fraction coordinate applied only to last range (typically an extrapolation above)\n     * @param result array to receive values\n     */\n    static appendFractionalPoints(data, initialRangeFraction, rangeFraction, includeDegenerateRange, gapFraction, includeDegenerateGap, finalRangeFraction, result) {\n        const numRange = data.length;\n        if (numRange > 0) {\n            if (undefined !== initialRangeFraction)\n                result.push(data[0].fractionToPoint(initialRangeFraction));\n            for (let i = 0; i < numRange; i++) {\n                if (rangeFraction !== undefined && (includeDegenerateRange || data[i].low !== data[i].high))\n                    result.push(data[i].fractionToPoint(rangeFraction));\n                if (i > 1 && gapFraction !== undefined && (includeDegenerateGap || data[i].low !== data[i].high))\n                    result.push(Geometry.interpolate(data[i - 1].high, gapFraction, data[i].low));\n            }\n            if (undefined !== finalRangeFraction)\n                result.push(data[numRange - 1].fractionToPoint(finalRangeFraction));\n        }\n        return result;\n    }\n    /** Return a single range constructed with the low of range 0 and high of final range in the set.  */\n    static firstLowToLastHigh(data) {\n        if (data.length === 0)\n            return Range1d.createNull();\n        return Range1d.createXX(data[0].low, data[data.length - 1].high);\n    }\n    /** sum the lengths of all ranges */\n    static sumLengths(data) {\n        let sum = 0.0;\n        for (const range of data) {\n            sum += range.length();\n        }\n        return sum;\n    }\n    /**\n     * Test if the low,high values are sorted with no overlap.\n     * @param data array of ranges.\n     * @param strict if true, consider exact high-to-low match as overlap.\n     */\n    static isSorted(data, strict = true) {\n        const n = data.length;\n        if (strict) {\n            for (let i = 0; i + 1 < n; i++) {\n                if (data[i].high >= data[i + 1].low)\n                    return false;\n            }\n        }\n        else {\n            for (let i = 0; i + 1 < n; i++) {\n                if (data[i].high > data[i + 1].low)\n                    return false;\n            }\n        }\n        return true;\n    }\n}\n/** Checks low's first, then high's\n * @internal\n */\nexport function compareRange1dLexicalLowHigh(a, b) {\n    if (a.low < b.low)\n        return -1;\n    if (a.low > b.low)\n        return 1;\n    if (a.high < b.high)\n        return -1;\n    if (a.high > b.high)\n        return 1;\n    return 0;\n}\n//# sourceMappingURL=Range1dArray.js.map",
      "start": 1693508123488,
      "end": 1693508123667,
      "sourcemaps": null
    }
  ]
}
