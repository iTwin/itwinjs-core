{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/curve/internalContexts/ChainCollectorContext.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\nimport { BagOfCurves } from \"../CurveCollection\";\nimport { CurvePrimitive } from \"../CurvePrimitive\";\nimport { Loop } from \"../Loop\";\nimport { Path } from \"../Path\";\n/**\n * Manage a growing array of arrays of curve primitives that are to be joined \"head to tail\" in paths.\n * * The caller makes a sequence of calls to announce individual primitives.\n *    * The collector has 2 use cases in mind, controlled by `searchAllPaths` flag on `chainCollectorContext.announceCurvePrimitive`\n *    * (a) \"simple chains\" -- the caller has the curve primitives in order and just needs to have them monitored for coordinate breaks that indicate transition to a new chain.\n *        * The collector needs to watch for connection to the most recent path but not search for prior paths to join to instead.\n *    * (b)  \"mixed\" primitives -- primitive order is NOT significant for chain assembly.\n *        * The collector needs to search all prior paths at both start and end, and consider connection to both the start and end of each new primitive.\n * * The per-curve announcement is\n *    * chainCollector.announceCurvePrimitive (curve, searchAllPaths).\n * * When all curves have been announced, the call to grab the paths option\n *    * formLoopsIfClosed\n *       * If true, convert closed paths to `Loop`, open paths to `Path`\n *       * If false, convert all paths (open or not) to `Path`\n * * Usage pattern is\n *   * initialization: `context = new ChainCollectorContext (makeClones: boolean)`\n *   * many times: `   context.announceCurvePrimitive (primitive, searchAllPaths)`\n *   * end:        ` result = context.grabResults (formLoopsIfClosed)`\n * @internal\n */\nexport class ChainCollectorContext {\n    /**\n     * Push a new chain with an optional first primitive.\n     */\n    pushNewChain(primitive) {\n        const chain = [];\n        if (primitive)\n            chain.push(primitive);\n        this._chains.push(chain);\n    }\n    findOrCreateTailChain() {\n        if (this._chains.length === 0)\n            this.pushNewChain();\n        return this._chains[this._chains.length - 1];\n    }\n    findAnyChainToConnect(xyz) {\n        for (let chainIndexA = 0; chainIndexA < this._chains.length; chainIndexA++) {\n            const path = this._chains[chainIndexA];\n            this._xyzWork1 = path[path.length - 1].endPoint(this._xyzWork1);\n            if (this._xyzWork1.isAlmostEqual(xyz))\n                return { chainIndex: chainIndexA, atEnd: true };\n            this._xyzWork1 = path[0].startPoint(this._xyzWork1);\n            if (this._xyzWork1.isAlmostEqual(xyz))\n                return { chainIndex: chainIndexA, atEnd: false };\n        }\n        return undefined;\n    }\n    /** Initialize with an empty array of chains.\n     * @param makeClones if true, all CurvePrimitives sent to `announceCurvePrimitive` is immediately cloned.  If false, the reference to the original curve is maintained.\n     */\n    constructor(makeClones) {\n        this._chains = [];\n        this._makeClones = makeClones;\n    }\n    /** Announce a curve primitive\n     * * searchAllChains controls the extent of search for connecting points.\n     *   * false ==> only consider connection to most recent chain.\n     *   * true ==> search for any connection, reversing direction as needed.\n     * * Otherwise start a new chain.\n     */\n    announceCurvePrimitive(candidate, searchAllChains = false) {\n        if (candidate) {\n            if (this._makeClones) {\n                const candidate1 = candidate.clone();\n                if (!candidate1 || !(candidate1 instanceof CurvePrimitive))\n                    return;\n                this.transferMarkup(candidate, candidate1);\n                candidate = candidate1;\n            }\n            if (!searchAllChains) {\n                const activeChain = this.findOrCreateTailChain();\n                if (activeChain.length === 0 || !ChainCollectorContext.needBreakBetweenPrimitives(activeChain[activeChain.length - 1], candidate))\n                    activeChain.push(candidate);\n                else\n                    this.pushNewChain(candidate);\n            }\n            else {\n                this._xyzWork0 = candidate.startPoint(this._xyzWork0);\n                let connect = this.findAnyChainToConnect(this._xyzWork0);\n                if (connect) {\n                    if (connect.atEnd) {\n                        this._chains[connect.chainIndex].push(candidate);\n                    }\n                    else {\n                        candidate.reverseInPlace();\n                        this._chains[connect.chainIndex].splice(0, 0, candidate);\n                    }\n                }\n                else {\n                    this._xyzWork0 = candidate.endPoint(this._xyzWork0);\n                    connect = this.findAnyChainToConnect(this._xyzWork0);\n                    if (connect) { // START of new primitive ..\n                        if (connect.atEnd) {\n                            candidate.reverseInPlace();\n                            this._chains[connect.chainIndex].push(candidate);\n                        }\n                        else {\n                            this._chains[connect.chainIndex].splice(0, 0, candidate);\n                        }\n                    }\n                    else {\n                        this._chains.push([candidate]);\n                    }\n                }\n            }\n        }\n    }\n    /** Transfer markup (e.g. startCut, endCut) from source to destination */\n    transferMarkup(source, dest) {\n        if (source && dest) {\n            dest.startCut = source.startCut;\n            dest.endCut = source.endCut;\n        }\n    }\n    /** turn an array of curve primitives into the simplest possible strongly typed curve structure.\n     * * The input array is assumed to be connected appropriately to act as the curves of a Path.\n     * * When a path is created the curves array is CAPTURED.\n     */\n    promoteArrayToCurves(curves, makeLoopIfClosed) {\n        if (curves.length === 0)\n            return undefined;\n        if (makeLoopIfClosed) {\n            ChainCollectorContext._staticPointA = curves[0].startPoint(ChainCollectorContext._staticPointA);\n            ChainCollectorContext._staticPointB = curves[curves.length - 1].endPoint(ChainCollectorContext._staticPointB);\n            if (ChainCollectorContext._staticPointA.isAlmostEqual(ChainCollectorContext._staticPointB))\n                return Loop.createArray(curves);\n        }\n        if (curves.length === 1)\n            return curves[0];\n        return Path.createArray(curves);\n    }\n    /** Return the collected results, structured as the simplest possible type. */\n    grabResult(makeLoopIfClosed = false) {\n        const chains = this._chains;\n        if (chains.length === 0)\n            return undefined;\n        if (chains.length === 1)\n            return this.promoteArrayToCurves(chains[0], makeLoopIfClosed);\n        const bag = BagOfCurves.create();\n        for (const chain of chains) {\n            const q = this.promoteArrayToCurves(chain, makeLoopIfClosed);\n            bag.tryAddChild(q);\n        }\n        return bag;\n    }\n    /** test if there is a break between primitiveA and primitiveB, due to any condition such as\n     * * primitiveA.endCut\n     * * primitiveB.startCut\n     * * physical gap between primitives.\n     */\n    static needBreakBetweenPrimitives(primitiveA, primitiveB, isXYOnly = false) {\n        if (primitiveA === undefined)\n            return true;\n        if (primitiveB === undefined)\n            return true;\n        if (primitiveA.endCut !== undefined)\n            return true;\n        if (primitiveB.startCut !== undefined)\n            return true;\n        ChainCollectorContext._staticPointA = primitiveA.endPoint(ChainCollectorContext._staticPointA);\n        ChainCollectorContext._staticPointB = primitiveB.startPoint(ChainCollectorContext._staticPointB);\n        return isXYOnly\n            ? !ChainCollectorContext._staticPointA.isAlmostEqualXY(ChainCollectorContext._staticPointB)\n            : !ChainCollectorContext._staticPointA.isAlmostEqual(ChainCollectorContext._staticPointB);\n    }\n}\n//# sourceMappingURL=ChainCollectorContext.js.map",
      "start": 1693508125347,
      "end": 1693508125467,
      "sourcemaps": null
    }
  ]
}
