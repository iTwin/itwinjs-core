{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tools/ClipViewTool.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tools\n */\nimport { BeEvent, Id64 } from \"@itwin/core-bentley\";\nimport { AxisOrder, ClipMaskXYZRangePlanes, ClipPlane, ClipPrimitive, ClipShape, ClipUtilities, ClipVector, ConvexClipPlaneSet, FrameBuilder, Geometry, GrowableXYZArray, LineString3d, Loop, Matrix3d, Path, Plane3dByOriginAndUnitNormal, Point3d, PolygonOps, PolylineOps, Range1d, Range3d, Ray3d, Transform, Vector3d, } from \"@itwin/core-geometry\";\nimport { ClipStyle, ColorDef, LinePixels, Placement2d } from \"@itwin/core-common\";\nimport { AccuDrawHintBuilder, ContextRotationId } from \"../AccuDraw\";\nimport { CoordSystem } from \"../CoordSystem\";\nimport { LocateResponse } from \"../ElementLocateManager\";\nimport { IModelApp } from \"../IModelApp\";\nimport { GraphicType } from \"../render/GraphicBuilder\";\nimport { EditManipulator } from \"./EditManipulator\";\nimport { PrimitiveTool } from \"./PrimitiveTool\";\nimport { BeButtonEvent, CoordinateLockOverrides, CoreTools, EventHandled } from \"./Tool\";\nimport { ToolAssistance, ToolAssistanceImage, ToolAssistanceInputMethod } from \"./ToolAssistance\";\n/** A tool to define a clip volume for a view\n * @public @extensions\n */\nclass ViewClipTool extends PrimitiveTool {\n    constructor(_clipEventHandler) {\n        super();\n        this._clipEventHandler = _clipEventHandler;\n    }\n    /** @internal */\n    static enumAsOrientationMessage(str) { return CoreTools.translate(`Settings.Orientation.${str}`); }\n    /** @internal */\n    requireWriteableTarget() { return false; }\n    /** @internal */\n    isCompatibleViewport(vp, isSelectedViewChange) { return (super.isCompatibleViewport(vp, isSelectedViewChange) && undefined !== vp && vp.view.allow3dManipulations()); }\n    /** @internal */\n    async onPostInstall() {\n        await super.onPostInstall();\n        this.setupAndPromptForNextAction();\n    }\n    /** @internal */\n    async onUnsuspend() { this.showPrompt(); }\n    /** @internal */\n    async onRestartTool() { return this.exitTool(); }\n    /** @internal */\n    showPrompt() { }\n    /** @internal */\n    setupAndPromptForNextAction() { this.showPrompt(); }\n    /** @internal */\n    async onResetButtonUp(_ev) {\n        await this.onReinitialize();\n        return EventHandled.No;\n    }\n    /** @internal */\n    static getPlaneInwardNormal(orientation, viewport) {\n        const matrix = AccuDrawHintBuilder.getContextRotation(orientation, viewport);\n        if (undefined === matrix)\n            return undefined;\n        return matrix.getColumn(2).negate();\n    }\n    static enableClipVolume(viewport) {\n        if (viewport.viewFlags.clipVolume)\n            return false;\n        viewport.viewFlags = viewport.viewFlags.with(\"clipVolume\", true);\n        return true;\n    }\n    static setViewClip(viewport, clip) {\n        viewport.view.setViewClip(clip);\n        viewport.setupFromView();\n        return true;\n    }\n    static doClipToConvexClipPlaneSet(viewport, planes) {\n        const prim = ClipPrimitive.createCapture(planes);\n        const clip = ClipVector.createEmpty();\n        clip.appendReference(prim);\n        return this.setViewClip(viewport, clip);\n    }\n    static doClipToPlane(viewport, origin, normal, clearExistingPlanes) {\n        const plane = Plane3dByOriginAndUnitNormal.create(origin, normal);\n        if (undefined === plane)\n            return false;\n        let planeSet;\n        if (!clearExistingPlanes) {\n            const existingClip = viewport.view.getViewClip();\n            if (undefined !== existingClip && 1 === existingClip.clips.length) {\n                const existingPrim = existingClip.clips[0];\n                if (!(existingPrim instanceof ClipShape)) {\n                    const existingPlaneSets = existingPrim.fetchClipPlanesRef();\n                    if (undefined !== existingPlaneSets && 1 === existingPlaneSets.convexSets.length)\n                        planeSet = existingPlaneSets.convexSets[0];\n                }\n            }\n        }\n        if (undefined === planeSet)\n            planeSet = ConvexClipPlaneSet.createEmpty();\n        planeSet.addPlaneToConvexSet(ClipPlane.createPlane(plane));\n        return this.doClipToConvexClipPlaneSet(viewport, planeSet);\n    }\n    static doClipToShape(viewport, xyPoints, transform, zLow, zHigh) {\n        const clip = ClipVector.createEmpty();\n        clip.appendShape(xyPoints, zLow, zHigh, transform);\n        return this.setViewClip(viewport, clip);\n    }\n    static doClipToRange(viewport, range, transform) {\n        if (range.isNull || range.isAlmostZeroX || range.isAlmostZeroY)\n            return false;\n        const clip = ClipVector.createEmpty();\n        const block = ClipShape.createBlock(range, range.isAlmostZeroZ ? ClipMaskXYZRangePlanes.XAndY : ClipMaskXYZRangePlanes.All, false, false, transform);\n        clip.appendReference(block);\n        return this.setViewClip(viewport, clip);\n    }\n    static doClipClear(viewport) {\n        if (!ViewClipTool.hasClip(viewport))\n            return false;\n        return this.setViewClip(viewport);\n    }\n    /** @internal */\n    static getClipRayTransformed(origin, direction, transform) {\n        const facePt = origin.clone();\n        const faceDir = direction.clone();\n        if (undefined !== transform) {\n            transform.multiplyPoint3d(facePt, facePt);\n            transform.multiplyVector(faceDir, faceDir);\n            faceDir.normalizeInPlace();\n        }\n        return Ray3d.createCapture(facePt, faceDir);\n    }\n    /** @internal */\n    static getOffsetValueTransformed(offset, transform) {\n        if (undefined === transform)\n            return offset;\n        const lengthVec = Vector3d.create(offset);\n        transform.multiplyVector(lengthVec, lengthVec);\n        const localOffset = lengthVec.magnitude();\n        return (offset < 0 ? -localOffset : localOffset);\n    }\n    /** @internal */\n    static addClipPlanesLoops(builder, loops, outline) {\n        for (const geom of loops) {\n            if (!(geom instanceof Loop))\n                continue;\n            if (outline)\n                builder.addPath(Path.createArray(geom.children));\n            else\n                builder.addLoop(geom);\n        }\n    }\n    /** @internal */\n    static addClipShape(builder, shape, extents) {\n        const shapePtsLo = ViewClipTool.getClipShapePoints(shape, extents.low);\n        const shapePtsHi = ViewClipTool.getClipShapePoints(shape, extents.high);\n        for (let i = 0; i < shapePtsLo.length; i++)\n            builder.addLineString([shapePtsLo[i].clone(), shapePtsHi[i].clone()]);\n        builder.addLineString(shapePtsLo);\n        builder.addLineString(shapePtsHi);\n    }\n    /** @internal */\n    static drawClip(context, clip, viewExtents, options) {\n        const clipShape = ViewClipTool.isSingleClipShape(clip);\n        const clipPlanes = (undefined === clipShape ? ViewClipTool.isSingleConvexClipPlaneSet(clip) : undefined);\n        if (undefined === clipShape && undefined === clipPlanes)\n            return;\n        const viewRange = (viewExtents ? viewExtents : context.viewport.computeViewRange());\n        const clipPlanesLoops = (undefined !== clipPlanes ? ClipUtilities.loopsOfConvexClipPlaneIntersectionWithRange(clipPlanes, viewRange) : undefined);\n        if (undefined === clipShape && (undefined === clipPlanesLoops || 0 === clipPlanesLoops.length))\n            return;\n        const color = (options && options.color ? options.color : EditManipulator.HandleUtils.adjustForBackgroundColor(ColorDef.white, context.viewport));\n        const builderVis = context.createGraphicBuilder(GraphicType.WorldDecoration, clipShape ? clipShape.transformFromClip : undefined, (options ? options.id : undefined));\n        const builderHid = context.createGraphicBuilder(GraphicType.WorldOverlay, clipShape ? clipShape.transformFromClip : undefined);\n        builderVis.setSymbology(color, ColorDef.black, (options && options.visibleWidth ? options.visibleWidth : 3));\n        builderHid.setSymbology(color, ColorDef.black, (options && options.hiddenWidth ? options.hiddenWidth : 1), (options && options.hiddenStyle ? options.hiddenStyle : LinePixels.Code2));\n        if (undefined !== clipPlanesLoops) {\n            ViewClipTool.addClipPlanesLoops(builderVis, clipPlanesLoops, true);\n            ViewClipTool.addClipPlanesLoops(builderHid, clipPlanesLoops, true);\n            if (options && options.fillClipPlanes) {\n                const fill = (options.fill ? options.fill : EditManipulator.HandleUtils.adjustForBackgroundColor(ColorDef.from(0, 255, 255, 225), context.viewport));\n                const builderFill = context.createGraphicBuilder(GraphicType.WorldDecoration);\n                builderFill.setSymbology(fill, fill, 0);\n                ViewClipTool.addClipPlanesLoops(builderFill, (options.hasPrimaryPlane ? [clipPlanesLoops[0]] : clipPlanesLoops), false);\n                context.addDecorationFromBuilder(builderFill);\n            }\n        }\n        else if (undefined !== clipShape) {\n            const clipExtents = ViewClipTool.getClipShapeExtents(clipShape, viewRange);\n            ViewClipTool.addClipShape(builderVis, clipShape, clipExtents);\n            ViewClipTool.addClipShape(builderHid, clipShape, clipExtents);\n        }\n        context.addDecorationFromBuilder(builderVis);\n        context.addDecorationFromBuilder(builderHid);\n    }\n    static isHilited(vp, id) {\n        return (undefined !== id ? vp.iModel.hilited.elements.has(Id64.getLowerUint32(id), Id64.getUpperUint32(id)) : false);\n    }\n    static isFlashed(vp, id) {\n        return (undefined !== id ? vp.lastFlashedElementId === id : false);\n    }\n    static drawClipShape(context, shape, extents, color, weight, id) {\n        const builder = context.createGraphicBuilder(GraphicType.WorldDecoration, shape.transformFromClip, id); // Use WorldDecoration not WorldOverlay to make sure handles have priority...\n        builder.setSymbology(color, ColorDef.black, weight);\n        ViewClipTool.addClipShape(builder, shape, extents);\n        context.addDecorationFromBuilder(builder);\n        // NOTE: We want to display hidden edges when clip decoration isn't hilited (not selected or drawn in dynamics).\n        // This isn't required and is messy looking when the clip is being drawn hilited.\n        // If the clip decoration is being flashed, draw using the hilite color to match the pickable world decoration display.\n        if (!this.isHilited(context.viewport, id)) {\n            const builderHid = context.createGraphicBuilder(GraphicType.WorldOverlay, shape.transformFromClip);\n            builderHid.setSymbology(this.isFlashed(context.viewport, id) ? context.viewport.hilite.color : color, ColorDef.black, 1, LinePixels.Code2);\n            ViewClipTool.addClipShape(builderHid, shape, extents);\n            context.addDecorationFromBuilder(builderHid);\n        }\n    }\n    /** @internal */\n    static getClipShapePoints(shape, z) {\n        const points = [];\n        for (const pt of shape.polygon)\n            points.push(Point3d.create(pt.x, pt.y, z));\n        return points;\n    }\n    /** @internal */\n    static getClipShapeExtents(shape, viewRange) {\n        let zLow = shape.zLow;\n        let zHigh = shape.zHigh;\n        if (undefined === zLow || undefined === zHigh) {\n            const zVec = Vector3d.unitZ();\n            const origin = shape.polygon[0];\n            const corners = viewRange.corners();\n            if (undefined !== shape.transformToClip)\n                shape.transformToClip.multiplyPoint3dArrayInPlace(corners);\n            for (const corner of corners) {\n                const delta = Vector3d.createStartEnd(origin, corner);\n                const projection = delta.dotProduct(zVec);\n                if (undefined === shape.zLow && (undefined === zLow || projection < zLow))\n                    zLow = projection;\n                if (undefined === shape.zHigh && (undefined === zHigh || projection > zHigh))\n                    zHigh = projection;\n            }\n        }\n        return Range1d.createXX(zLow, zHigh);\n    }\n    /** @internal */\n    static isSingleClipShape(clip) {\n        if (1 !== clip.clips.length)\n            return undefined;\n        const prim = clip.clips[0];\n        if (!(prim instanceof ClipShape))\n            return undefined;\n        if (!prim.isValidPolygon)\n            return undefined;\n        return prim;\n    }\n    static drawClipPlanesLoops(context, loops, color, weight, dashed, fill, id) {\n        if (loops.length < 1)\n            return;\n        const builderEdge = context.createGraphicBuilder(GraphicType.WorldDecoration, undefined, id); // Use WorldDecoration not WorldOverlay to make sure handles have priority...\n        builderEdge.setSymbology(color, ColorDef.black, weight, dashed ? LinePixels.Code2 : undefined);\n        ViewClipTool.addClipPlanesLoops(builderEdge, loops, true);\n        context.addDecorationFromBuilder(builderEdge);\n        // NOTE: We want to display hidden edges when clip decoration isn't hilited (not selected or drawn in dynamics).\n        // This isn't required and is messy looking when the clip is being drawn hilited.\n        // If the clip decoration is being flashed, draw using the hilite color to match the pickable world decoration display.\n        if (!this.isHilited(context.viewport, id)) {\n            const builderEdgeHid = context.createGraphicBuilder(GraphicType.WorldOverlay);\n            builderEdgeHid.setSymbology(this.isFlashed(context.viewport, id) ? context.viewport.hilite.color : color, ColorDef.black, 1, LinePixels.Code2);\n            ViewClipTool.addClipPlanesLoops(builderEdgeHid, loops, true);\n            context.addDecorationFromBuilder(builderEdgeHid);\n        }\n        if (undefined === fill)\n            return;\n        const builderFace = context.createGraphicBuilder(GraphicType.WorldDecoration, undefined);\n        builderFace.setSymbology(fill, fill, 0);\n        ViewClipTool.addClipPlanesLoops(builderFace, loops, false);\n        context.addDecorationFromBuilder(builderFace);\n    }\n    /** @internal */\n    static isSingleConvexClipPlaneSet(clip) {\n        if (1 !== clip.clips.length)\n            return undefined;\n        const prim = clip.clips[0];\n        if (prim instanceof ClipShape)\n            return undefined;\n        const planeSets = prim.fetchClipPlanesRef();\n        return (undefined !== planeSets && 1 === planeSets.convexSets.length) ? planeSets.convexSets[0] : undefined;\n    }\n    /** @internal */\n    static isSingleClipPlane(clip) {\n        const clipPlanes = ViewClipTool.isSingleConvexClipPlaneSet(clip);\n        if (undefined === clipPlanes || 1 !== clipPlanes.planes.length)\n            return undefined;\n        return clipPlanes.planes[0];\n    }\n    static areClipsEqual(clipA, clipB) {\n        if (clipA === clipB)\n            return true;\n        if (clipA.clips.length !== clipB.clips.length)\n            return false;\n        for (let iPrim = 0; iPrim < clipA.clips.length; iPrim++) {\n            const primA = clipA.clips[iPrim];\n            const primB = clipB.clips[iPrim];\n            const planesA = primA.fetchClipPlanesRef();\n            const planesB = primB.fetchClipPlanesRef();\n            if (undefined !== planesA && undefined !== planesB) {\n                if (planesA.convexSets.length !== planesB.convexSets.length)\n                    return false;\n                for (let iPlane = 0; iPlane < planesA.convexSets.length; iPlane++) {\n                    const planeSetA = planesA.convexSets[iPlane];\n                    const planeSetB = planesB.convexSets[iPlane];\n                    if (planeSetA.planes.length !== planeSetB.planes.length)\n                        return false;\n                    for (let iClipPlane = 0; iClipPlane < planeSetA.planes.length; iClipPlane++) {\n                        const planeA = planeSetA.planes[iClipPlane];\n                        const planeB = planeSetB.planes[iClipPlane];\n                        if (!planeA.isAlmostEqual(planeB))\n                            return false;\n                    }\n                }\n            }\n            else if (undefined === planesA && undefined === planesB) {\n                continue;\n            }\n            else {\n                return false;\n            }\n        }\n        return true;\n    }\n    static hasClip(viewport) {\n        return (undefined !== viewport.view.getViewClip());\n    }\n}\n/** @internal */\nViewClipTool._orientationName = \"enumAsOrientation\";\n/** @internal */\nViewClipTool._getEnumAsOrientationDescription = () => {\n    return {\n        name: ViewClipTool._orientationName,\n        displayLabel: CoreTools.translate(\"Settings.Orientation.Label\"),\n        typename: \"enum\",\n        enum: {\n            choices: [\n                { label: ViewClipTool.enumAsOrientationMessage(\"Top\"), value: ContextRotationId.Top },\n                { label: ViewClipTool.enumAsOrientationMessage(\"Front\"), value: ContextRotationId.Front },\n                { label: ViewClipTool.enumAsOrientationMessage(\"Left\"), value: ContextRotationId.Left },\n                { label: ViewClipTool.enumAsOrientationMessage(\"Bottom\"), value: ContextRotationId.Bottom },\n                { label: ViewClipTool.enumAsOrientationMessage(\"Back\"), value: ContextRotationId.Back },\n                { label: ViewClipTool.enumAsOrientationMessage(\"Right\"), value: ContextRotationId.Right },\n                { label: ViewClipTool.enumAsOrientationMessage(\"View\"), value: ContextRotationId.View },\n                { label: ViewClipTool.enumAsOrientationMessage(\"Face\"), value: ContextRotationId.Face },\n            ],\n        },\n    };\n};\nexport { ViewClipTool };\n/** A tool to remove a clip volume for a view\n * @public @extensions\n */\nclass ViewClipClearTool extends ViewClipTool {\n    /** @internal */\n    isCompatibleViewport(vp, isSelectedViewChange) { return (super.isCompatibleViewport(vp, isSelectedViewChange) && undefined !== vp && ViewClipTool.hasClip(vp)); }\n    /** @internal */\n    showPrompt() {\n        const mainInstruction = ToolAssistance.createInstruction(this.iconSpec, CoreTools.translate(\"ViewClip.Clear.Prompts.FirstPoint\"));\n        IModelApp.notifications.setToolAssistance(ToolAssistance.createInstructions(mainInstruction));\n    }\n    async doClipClear(viewport) {\n        if (!ViewClipTool.doClipClear(viewport))\n            return false;\n        if (undefined !== this._clipEventHandler)\n            this._clipEventHandler.onClearClip(viewport);\n        await this.onReinitialize();\n        return true;\n    }\n    /** @internal */\n    async onPostInstall() {\n        await super.onPostInstall();\n        if (undefined !== this.targetView)\n            await this.doClipClear(this.targetView);\n    }\n    /** @internal */\n    async onDataButtonDown(_ev) {\n        if (undefined === this.targetView)\n            return EventHandled.No;\n        return await this.doClipClear(this.targetView) ? EventHandled.Yes : EventHandled.No;\n    }\n}\nViewClipClearTool.toolId = \"ViewClip.Clear\";\nViewClipClearTool.iconSpec = \"icon-section-tool\";\nexport { ViewClipClearTool };\n/** A tool to define a clip volume for a view by specifying a plane\n * @public\n */\nclass ViewClipByPlaneTool extends ViewClipTool {\n    constructor(clipEventHandler, _clearExistingPlanes = false) {\n        super(clipEventHandler);\n        this._clearExistingPlanes = _clearExistingPlanes;\n        /** @internal */\n        this._orientationValue = { value: ContextRotationId.Face };\n    }\n    /** @internal */\n    get orientation() { return this._orientationValue.value; }\n    set orientation(option) { this._orientationValue.value = option; }\n    /** @internal */\n    supplyToolSettingsProperties() {\n        const initialValue = IModelApp.toolAdmin.toolSettingsState.getInitialToolSettingValue(this.toolId, ViewClipTool._orientationName);\n        initialValue && (this._orientationValue = initialValue);\n        const toolSettings = new Array();\n        const settingsItem = { value: this._orientationValue, property: ViewClipTool._getEnumAsOrientationDescription(), editorPosition: { rowPriority: 0, columnIndex: 2 } };\n        toolSettings.push(settingsItem);\n        return toolSettings;\n    }\n    /** @internal */\n    async applyToolSettingPropertyChange(updatedValue) {\n        if (updatedValue.propertyName === ViewClipTool._orientationName) {\n            this._orientationValue = updatedValue.value;\n            if (this._orientationValue) {\n                IModelApp.toolAdmin.toolSettingsState.saveToolSettingProperty(this.toolId, { propertyName: ViewClipTool._orientationName, value: this._orientationValue });\n                return true;\n            }\n        }\n        return false;\n    }\n    /** @internal */\n    showPrompt() {\n        const mainInstruction = ToolAssistance.createInstruction(this.iconSpec, CoreTools.translate(\"ViewClip.ByPlane.Prompts.FirstPoint\"));\n        const mouseInstructions = [];\n        const touchInstructions = [];\n        if (!ToolAssistance.createTouchCursorInstructions(touchInstructions))\n            touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.OneTouchTap, CoreTools.translate(\"ElementSet.Inputs.AcceptPoint\"), false, ToolAssistanceInputMethod.Touch));\n        mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.LeftClick, CoreTools.translate(\"ElementSet.Inputs.AcceptPoint\"), false, ToolAssistanceInputMethod.Mouse));\n        touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.TwoTouchTap, CoreTools.translate(\"ElementSet.Inputs.Exit\"), false, ToolAssistanceInputMethod.Touch));\n        mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.RightClick, CoreTools.translate(\"ElementSet.Inputs.Exit\"), false, ToolAssistanceInputMethod.Mouse));\n        const sections = [];\n        sections.push(ToolAssistance.createSection(mouseInstructions, ToolAssistance.inputsLabel));\n        sections.push(ToolAssistance.createSection(touchInstructions, ToolAssistance.inputsLabel));\n        const instructions = ToolAssistance.createInstructions(mainInstruction, sections);\n        IModelApp.notifications.setToolAssistance(instructions);\n    }\n    /** @internal */\n    setupAndPromptForNextAction() {\n        IModelApp.accuSnap.enableSnap(true);\n        super.setupAndPromptForNextAction();\n    }\n    /** @internal */\n    async onDataButtonDown(ev) {\n        if (undefined === this.targetView)\n            return EventHandled.No;\n        const normal = ViewClipTool.getPlaneInwardNormal(this.orientation, this.targetView);\n        if (undefined === normal)\n            return EventHandled.No;\n        ViewClipTool.enableClipVolume(this.targetView);\n        if (!ViewClipTool.doClipToPlane(this.targetView, ev.point, normal, this._clearExistingPlanes))\n            return EventHandled.No;\n        if (undefined !== this._clipEventHandler)\n            this._clipEventHandler.onNewClipPlane(this.targetView);\n        await this.onReinitialize();\n        return EventHandled.Yes;\n    }\n}\nViewClipByPlaneTool.toolId = \"ViewClip.ByPlane\";\nViewClipByPlaneTool.iconSpec = \"icon-section-plane\";\nexport { ViewClipByPlaneTool };\n/** A tool to define a clip volume for a view by specifying a shape\n * @public\n */\nclass ViewClipByShapeTool extends ViewClipTool {\n    constructor() {\n        super(...arguments);\n        /** @internal */\n        this._orientationValue = { value: ContextRotationId.Top };\n        /** @internal */\n        this._points = [];\n    }\n    /** @internal */\n    get orientation() { return this._orientationValue.value; }\n    set orientation(option) { this._orientationValue.value = option; }\n    /** @internal */\n    supplyToolSettingsProperties() {\n        const initialValue = IModelApp.toolAdmin.toolSettingsState.getInitialToolSettingValue(this.toolId, ViewClipTool._orientationName);\n        initialValue && (this._orientationValue = initialValue);\n        const toolSettings = new Array();\n        toolSettings.push({ value: this._orientationValue, property: ViewClipTool._getEnumAsOrientationDescription(), editorPosition: { rowPriority: 0, columnIndex: 2 } });\n        return toolSettings;\n    }\n    /** @internal */\n    async applyToolSettingPropertyChange(updatedValue) {\n        if (updatedValue.propertyName === ViewClipTool._orientationName) {\n            this._orientationValue = updatedValue.value;\n            if (!this._orientationValue)\n                return false;\n            this._points.length = 0;\n            this._matrix = undefined;\n            AccuDrawHintBuilder.deactivate();\n            this.setupAndPromptForNextAction();\n            IModelApp.toolAdmin.toolSettingsState.saveToolSettingProperty(this.toolId, { propertyName: ViewClipTool._orientationName, value: this._orientationValue });\n            return true;\n        }\n        return false;\n    }\n    /** @internal */\n    showPrompt() {\n        let mainMsg = \"ViewClip.ByShape.Prompts.\";\n        switch (this._points.length) {\n            case 0:\n                mainMsg += \"FirstPoint\";\n                break;\n            case 1:\n                mainMsg += \"SecondPoint\";\n                break;\n            case 2:\n                mainMsg += \"ThirdPoint\";\n                break;\n            default:\n                mainMsg += \"NextPoint\";\n                break;\n        }\n        const mainInstruction = ToolAssistance.createInstruction(this.iconSpec, CoreTools.translate(mainMsg));\n        const mouseInstructions = [];\n        const touchInstructions = [];\n        if (!ToolAssistance.createTouchCursorInstructions(touchInstructions))\n            touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.OneTouchTap, CoreTools.translate(\"ElementSet.Inputs.AcceptPoint\"), false, ToolAssistanceInputMethod.Touch));\n        mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.LeftClick, CoreTools.translate(\"ElementSet.Inputs.AcceptPoint\"), false, ToolAssistanceInputMethod.Mouse));\n        touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.TwoTouchTap, CoreTools.translate(\"ElementSet.Inputs.Exit\"), false, ToolAssistanceInputMethod.Touch));\n        mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.RightClick, CoreTools.translate(\"ElementSet.Inputs.Exit\"), false, ToolAssistanceInputMethod.Mouse));\n        if (this._points.length > 1)\n            mouseInstructions.push(ToolAssistance.createModifierKeyInstruction(ToolAssistance.ctrlKey, ToolAssistanceImage.LeftClick, CoreTools.translate(\"ElementSet.Inputs.AdditionalPoint\"), false, ToolAssistanceInputMethod.Mouse));\n        if (0 !== this._points.length)\n            mouseInstructions.push(ToolAssistance.createKeyboardInstruction(ToolAssistance.createKeyboardInfo([ToolAssistance.ctrlKey, \"Z\"]), CoreTools.translate(\"ElementSet.Inputs.UndoLastPoint\"), false, ToolAssistanceInputMethod.Mouse));\n        const sections = [];\n        sections.push(ToolAssistance.createSection(mouseInstructions, ToolAssistance.inputsLabel));\n        sections.push(ToolAssistance.createSection(touchInstructions, ToolAssistance.inputsLabel));\n        const instructions = ToolAssistance.createInstructions(mainInstruction, sections);\n        IModelApp.notifications.setToolAssistance(instructions);\n    }\n    /** @internal */\n    setupAndPromptForNextAction() {\n        IModelApp.accuSnap.enableSnap(true);\n        super.setupAndPromptForNextAction();\n        if (0 === this._points.length)\n            return;\n        if (undefined === this._matrix)\n            return;\n        const hints = new AccuDrawHintBuilder();\n        hints.setOrigin(this._points[this._points.length - 1]);\n        if (1 === this._points.length) {\n            hints.setMatrix(this._matrix);\n            hints.setModeRectangular();\n        }\n        else if (this._points.length > 1 && !(this._points[this._points.length - 1].isAlmostEqual(this._points[this._points.length - 2]))) {\n            const xVec = Vector3d.createStartEnd(this._points[this._points.length - 2], this._points[this._points.length - 1]);\n            const zVec = this._matrix.getColumn(2);\n            const matrix = Matrix3d.createRigidFromColumns(xVec, zVec, AxisOrder.XZY);\n            if (undefined !== matrix)\n                hints.setMatrix(matrix); // Rotate AccuDraw x axis to last segment preserving current up vector...\n        }\n        hints.setLockZ = true;\n        hints.sendHints();\n    }\n    getClipPoints(ev) {\n        const points = [];\n        if (undefined === this.targetView || this._points.length < 1)\n            return points;\n        for (const pt of this._points)\n            points.push(pt.clone());\n        if (undefined === this._matrix)\n            return points;\n        const normal = this._matrix.getColumn(2);\n        let currentPt = AccuDrawHintBuilder.projectPointToPlaneInView(ev.point, points[0], normal, ev.viewport, true);\n        if (undefined === currentPt)\n            currentPt = ev.point.clone();\n        if (2 === points.length && !ev.isControlKey) {\n            const xDir = Vector3d.createStartEnd(points[0], points[1]);\n            const xLen = xDir.magnitude();\n            xDir.normalizeInPlace();\n            const yDir = xDir.crossProduct(normal);\n            yDir.normalizeInPlace();\n            const cornerPt = AccuDrawHintBuilder.projectPointToLineInView(currentPt, points[1], yDir, ev.viewport, true);\n            if (undefined !== cornerPt) {\n                points.push(cornerPt);\n                cornerPt.plusScaled(xDir, -xLen, currentPt);\n            }\n        }\n        points.push(currentPt);\n        if (points.length > 2)\n            points.push(points[0].clone());\n        return points;\n    }\n    /** @internal */\n    isValidLocation(ev, isButtonEvent) {\n        return (this._points.length > 0 ? true : super.isValidLocation(ev, isButtonEvent));\n    }\n    /** @internal */\n    decorate(context) {\n        if (context.viewport !== this.targetView)\n            return;\n        const ev = new BeButtonEvent();\n        IModelApp.toolAdmin.fillEventFromCursorLocation(ev);\n        if (undefined === ev.viewport)\n            return;\n        const points = this.getClipPoints(ev);\n        if (points.length < 2)\n            return;\n        const builderAccVis = context.createGraphicBuilder(GraphicType.WorldDecoration);\n        const builderAccHid = context.createGraphicBuilder(GraphicType.WorldOverlay);\n        const colorAccVis = EditManipulator.HandleUtils.adjustForBackgroundColor(ColorDef.white, context.viewport);\n        const colorAccHid = colorAccVis.withAlpha(100);\n        const fillAccVis = context.viewport.hilite.color.withAlpha(25);\n        builderAccVis.setSymbology(colorAccVis, fillAccVis, 3);\n        builderAccHid.setSymbology(colorAccHid, fillAccVis, 1, LinePixels.Code2);\n        if (points.length > 2)\n            builderAccHid.addShape(points);\n        builderAccVis.addLineString(points);\n        builderAccHid.addLineString(points);\n        context.addDecorationFromBuilder(builderAccVis);\n        context.addDecorationFromBuilder(builderAccHid);\n    }\n    /** @internal */\n    async onMouseMotion(ev) {\n        if (this._points.length > 0 && undefined !== ev.viewport)\n            ev.viewport.invalidateDecorations();\n    }\n    /** @internal */\n    async onDataButtonDown(ev) {\n        if (undefined === this.targetView)\n            return EventHandled.No;\n        if (this._points.length > 1 && !ev.isControlKey) {\n            const points = this.getClipPoints(ev);\n            if (points.length < 3)\n                return EventHandled.No;\n            const transform = Transform.createOriginAndMatrix(points[0], this._matrix);\n            transform.multiplyInversePoint3dArrayInPlace(points);\n            ViewClipTool.enableClipVolume(this.targetView);\n            if (!ViewClipTool.doClipToShape(this.targetView, points, transform, this._zLow, this._zHigh))\n                return EventHandled.No;\n            if (undefined !== this._clipEventHandler)\n                this._clipEventHandler.onNewClip(this.targetView);\n            await this.onReinitialize();\n            return EventHandled.Yes;\n        }\n        if (undefined === this._matrix && undefined === (this._matrix = AccuDrawHintBuilder.getContextRotation(this.orientation, this.targetView)))\n            return EventHandled.No;\n        const currPt = ev.point.clone();\n        if (this._points.length > 0) {\n            const planePt = AccuDrawHintBuilder.projectPointToPlaneInView(currPt, this._points[0], this._matrix.getColumn(2), ev.viewport, true);\n            if (undefined !== planePt)\n                currPt.setFrom(planePt);\n        }\n        this._points.push(currPt);\n        this.setupAndPromptForNextAction();\n        return EventHandled.No;\n    }\n    /** @internal */\n    async onUndoPreviousStep() {\n        if (0 === this._points.length)\n            return false;\n        this._points.pop();\n        this.setupAndPromptForNextAction();\n        return true;\n    }\n}\nViewClipByShapeTool.toolId = \"ViewClip.ByShape\";\nViewClipByShapeTool.iconSpec = \"icon-section-shape\";\nexport { ViewClipByShapeTool };\n/** A tool to define a clip volume for a view by specifying range corners\n * @public\n */\nclass ViewClipByRangeTool extends ViewClipTool {\n    /** @internal */\n    showPrompt() {\n        const mainInstruction = ToolAssistance.createInstruction(this.iconSpec, CoreTools.translate(undefined === this._corner ? \"ViewClip.ByRange.Prompts.FirstPoint\" : \"ViewClip.ByRange.Prompts.NextPoint\"));\n        const mouseInstructions = [];\n        const touchInstructions = [];\n        if (!ToolAssistance.createTouchCursorInstructions(touchInstructions))\n            touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.OneTouchTap, CoreTools.translate(\"ElementSet.Inputs.AcceptPoint\"), false, ToolAssistanceInputMethod.Touch));\n        mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.LeftClick, CoreTools.translate(\"ElementSet.Inputs.AcceptPoint\"), false, ToolAssistanceInputMethod.Mouse));\n        touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.TwoTouchTap, CoreTools.translate(\"ElementSet.Inputs.Exit\"), false, ToolAssistanceInputMethod.Touch));\n        mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.RightClick, CoreTools.translate(\"ElementSet.Inputs.Exit\"), false, ToolAssistanceInputMethod.Mouse));\n        if (undefined !== this._corner)\n            mouseInstructions.push(ToolAssistance.createKeyboardInstruction(ToolAssistance.createKeyboardInfo([ToolAssistance.ctrlKey, \"Z\"]), CoreTools.translate(\"ElementSet.Inputs.UndoLastPoint\"), false, ToolAssistanceInputMethod.Mouse));\n        const sections = [];\n        sections.push(ToolAssistance.createSection(mouseInstructions, ToolAssistance.inputsLabel));\n        sections.push(ToolAssistance.createSection(touchInstructions, ToolAssistance.inputsLabel));\n        const instructions = ToolAssistance.createInstructions(mainInstruction, sections);\n        IModelApp.notifications.setToolAssistance(instructions);\n    }\n    /** @internal */\n    setupAndPromptForNextAction() {\n        IModelApp.accuSnap.enableSnap(true);\n        super.setupAndPromptForNextAction();\n    }\n    getClipRange(range, transform, ev) {\n        if (undefined === this.targetView || undefined === this._corner)\n            return false;\n        // Creating clip aligned with ACS when ACS context lock is enabled...\n        const matrix = AccuDrawHintBuilder.getContextRotation(ContextRotationId.Top, this.targetView);\n        Transform.createOriginAndMatrix(this._corner, matrix, transform);\n        const pt1 = transform.multiplyInversePoint3d(this._corner);\n        const pt2 = transform.multiplyInversePoint3d(ev.point);\n        if (undefined === pt1 || undefined === pt2)\n            return false;\n        range.setFrom(Range3d.create(pt1, pt2));\n        return true;\n    }\n    /** @internal */\n    decorate(context) {\n        if (context.viewport !== this.targetView || undefined === this._corner)\n            return;\n        const ev = new BeButtonEvent();\n        IModelApp.toolAdmin.fillEventFromCursorLocation(ev);\n        if (undefined === ev.viewport)\n            return;\n        const range = Range3d.create();\n        const transform = Transform.createIdentity();\n        if (!this.getClipRange(range, transform, ev))\n            return;\n        const builderAccVis = context.createGraphicBuilder(GraphicType.WorldDecoration, transform);\n        const builderAccHid = context.createGraphicBuilder(GraphicType.WorldOverlay, transform);\n        const colorAccVis = EditManipulator.HandleUtils.adjustForBackgroundColor(ColorDef.white, context.viewport);\n        const colorAccHid = colorAccVis.withAlpha(100);\n        builderAccVis.setSymbology(colorAccVis, ColorDef.black, 3);\n        builderAccHid.setSymbology(colorAccHid, ColorDef.black, 1, LinePixels.Code2);\n        builderAccVis.addRangeBox(range);\n        builderAccHid.addRangeBox(range);\n        context.addDecorationFromBuilder(builderAccVis);\n        context.addDecorationFromBuilder(builderAccHid);\n    }\n    /** @internal */\n    async onMouseMotion(ev) {\n        if (undefined !== this._corner && undefined !== ev.viewport)\n            ev.viewport.invalidateDecorations();\n    }\n    /** @internal */\n    async onDataButtonDown(ev) {\n        if (undefined === this.targetView)\n            return EventHandled.No;\n        if (undefined !== this._corner) {\n            const range = Range3d.create();\n            const transform = Transform.createIdentity();\n            if (!this.getClipRange(range, transform, ev))\n                return EventHandled.No;\n            ViewClipTool.enableClipVolume(this.targetView);\n            if (!ViewClipTool.doClipToRange(this.targetView, range, transform))\n                return EventHandled.No;\n            if (undefined !== this._clipEventHandler)\n                this._clipEventHandler.onNewClip(this.targetView);\n            await this.onReinitialize();\n            return EventHandled.Yes;\n        }\n        this._corner = ev.point.clone();\n        this.setupAndPromptForNextAction();\n        return EventHandled.No;\n    }\n    /** @internal */\n    async onUndoPreviousStep() {\n        if (undefined === this._corner)\n            return false;\n        this._corner = undefined;\n        this.setupAndPromptForNextAction();\n        return true;\n    }\n}\nViewClipByRangeTool.toolId = \"ViewClip.ByRange\";\nViewClipByRangeTool.iconSpec = \"icon-section-range\";\nexport { ViewClipByRangeTool };\n/** A tool to define a clip volume for a view using the element aligned box or axis aligned box.\n * @public\n */\nclass ViewClipByElementTool extends ViewClipTool {\n    constructor(clipEventHandler, _alwaysUseRange = false) {\n        super(clipEventHandler);\n        this._alwaysUseRange = _alwaysUseRange;\n    }\n    /** @internal */\n    showPrompt() {\n        const mainInstruction = ToolAssistance.createInstruction(this.iconSpec, CoreTools.translate(\"ViewClip.ByElement.Prompts.FirstPoint\"));\n        const mouseInstructions = [];\n        const touchInstructions = [];\n        touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.OneTouchTap, CoreTools.translate(\"ElementSet.Inputs.AcceptElement\"), false, ToolAssistanceInputMethod.Touch));\n        mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.LeftClick, CoreTools.translate(\"ElementSet.Inputs.AcceptElement\"), false, ToolAssistanceInputMethod.Mouse));\n        touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.TwoTouchTap, CoreTools.translate(\"ElementSet.Inputs.Exit\"), false, ToolAssistanceInputMethod.Touch));\n        mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.RightClick, CoreTools.translate(\"ElementSet.Inputs.Exit\"), false, ToolAssistanceInputMethod.Mouse));\n        const sections = [];\n        sections.push(ToolAssistance.createSection(mouseInstructions, ToolAssistance.inputsLabel));\n        sections.push(ToolAssistance.createSection(touchInstructions, ToolAssistance.inputsLabel));\n        const instructions = ToolAssistance.createInstructions(mainInstruction, sections);\n        IModelApp.notifications.setToolAssistance(instructions);\n    }\n    /** @internal */\n    async onPostInstall() {\n        await super.onPostInstall();\n        if (undefined !== this.targetView && this.targetView.iModel.selectionSet.isActive) {\n            let useSelection = true;\n            this.targetView.iModel.selectionSet.elements.forEach((val) => {\n                if (Id64.isInvalid(val) || Id64.isTransient(val))\n                    useSelection = false;\n            });\n            if (useSelection) {\n                await this.doClipToSelectedElements(this.targetView);\n                return;\n            }\n        }\n        this.initLocateElements(true, false, \"default\", CoordinateLockOverrides.All);\n    }\n    /** @internal */\n    async doClipToSelectedElements(viewport) {\n        if (await this.doClipToElements(viewport, viewport.iModel.selectionSet.elements, this._alwaysUseRange))\n            return true;\n        await this.exitTool();\n        return false;\n    }\n    async doClipToElements(viewport, ids, alwaysUseRange = false, modelId) {\n        try {\n            const placements = await viewport.iModel.elements.getPlacements(ids, { type: viewport.view.is3d() ? \"3d\" : \"2d\" });\n            if (0 === placements.length)\n                return false;\n            const displayTransform = modelId && 1 === placements.length ? viewport.view.computeDisplayTransform({ modelId, elementId: placements[0].elementId }) : undefined;\n            const range = new Range3d();\n            const transform = Transform.createIdentity();\n            if (!alwaysUseRange && 1 === placements.length) {\n                const placement = placements[0];\n                range.setFrom(placement instanceof Placement2d ? Range3d.createRange2d(placement.bbox, 0) : placement.bbox);\n                transform.setFrom(placement.transform); // Use ElementAlignedBox for single selection...\n                displayTransform?.multiplyTransformTransform(transform, transform);\n            }\n            else {\n                for (const placement of placements)\n                    range.extendRange(placement.calculateRange());\n                if (displayTransform)\n                    transform.setFrom(displayTransform);\n            }\n            if (range.isNull)\n                return false;\n            range.scaleAboutCenterInPlace(1.001); // pad range slightly...\n            if (range.isAlmostZeroX || range.isAlmostZeroY) {\n                if (range.isAlmostZeroZ)\n                    return false;\n                // Invalid XY range for clip, see if XZ or YZ can be used instead...\n                const canUseXZ = !range.isAlmostZeroX;\n                const canUseYZ = !canUseXZ && !range.isAlmostZeroY;\n                if (!canUseXZ && !canUseYZ)\n                    return false;\n                const zDir = canUseXZ ? Vector3d.unitY() : Vector3d.unitX();\n                const indices = Range3d.faceCornerIndices(canUseXZ ? 3 : 1);\n                const corners = range.corners();\n                const points = [];\n                for (const index of indices)\n                    points.push(corners[index]);\n                transform.multiplyPoint3dArrayInPlace(points);\n                transform.multiplyVector(zDir, zDir);\n                transform.setFrom(Transform.createOriginAndMatrix(points[0], Matrix3d.createRigidHeadsUp(zDir)));\n                transform.multiplyInversePoint3dArrayInPlace(points);\n                ViewClipTool.enableClipVolume(viewport);\n                if (!ViewClipTool.doClipToShape(viewport, points, transform))\n                    return false;\n                if (undefined !== this._clipEventHandler)\n                    this._clipEventHandler.onNewClip(viewport);\n                await this.onReinitialize();\n                return true;\n            }\n            ViewClipTool.enableClipVolume(viewport);\n            if (!ViewClipTool.doClipToRange(viewport, range, transform))\n                return false;\n            if (undefined !== this._clipEventHandler)\n                this._clipEventHandler.onNewClip(viewport);\n            await this.onReinitialize();\n            return true;\n        }\n        catch {\n            return false;\n        }\n    }\n    /** @internal */\n    async onDataButtonDown(ev) {\n        if (undefined === this.targetView)\n            return EventHandled.No;\n        const hit = await IModelApp.locateManager.doLocate(new LocateResponse(), true, ev.point, ev.viewport, ev.inputSource);\n        if (undefined === hit || !hit.isElementHit)\n            return EventHandled.No;\n        return await this.doClipToElements(this.targetView, hit.sourceId, this._alwaysUseRange, hit.modelId) ? EventHandled.Yes : EventHandled.No;\n    }\n}\nViewClipByElementTool.toolId = \"ViewClip.ByElement\";\nViewClipByElementTool.iconSpec = \"icon-section-element\";\nexport { ViewClipByElementTool };\n/** @internal Interactive tool base class to modify a view's clip */\nexport class ViewClipModifyTool extends EditManipulator.HandleTool {\n    constructor(manipulator, clip, vp, hitId, ids, controls) {\n        super(manipulator);\n        this._restoreClip = true;\n        this._currentDistance = 0.0;\n        this._anchorIndex = ids.indexOf(hitId);\n        this._ids = ids;\n        this._controls = controls;\n        this._clipView = vp;\n        this._clip = clip;\n        this._viewRange = vp.computeViewRange();\n        // Don't request section-cut graphics while the user is modifying the clip. We'll restore this when the tool exits.\n        this._clipStyle = vp.clipStyle;\n        if (this._clipStyle.produceCutGeometry) {\n            vp.clipStyle = ClipStyle.fromJSON({\n                ...this._clipStyle.toJSON(),\n                produceCutGeometry: false,\n            });\n        }\n    }\n    get wantAccuSnap() { return false; }\n    init() {\n        super.init();\n        AccuDrawHintBuilder.deactivate();\n    }\n    getOffsetValue(ev, transformFromClip) {\n        if (-1 === this._anchorIndex || undefined === ev.viewport || ev.viewport !== this._clipView)\n            return undefined;\n        // NOTE: Use AccuDraw z instead of view z if AccuDraw is explicitly enabled...\n        const anchorRay = ViewClipTool.getClipRayTransformed(this._controls[this._anchorIndex].origin, this._controls[this._anchorIndex].direction, transformFromClip);\n        const projectedPt = AccuDrawHintBuilder.projectPointToLineInView(ev.point, anchorRay.origin, anchorRay.direction, ev.viewport, true);\n        if (undefined === projectedPt)\n            return undefined;\n        const offsetVec = Vector3d.createStartEnd(anchorRay.origin, projectedPt);\n        let offset = offsetVec.normalizeWithLength(offsetVec).mag;\n        if (offset < Geometry.smallMetricDistance)\n            return undefined;\n        if (offsetVec.dotProduct(anchorRay.direction) < 0.0)\n            offset *= -1.0;\n        this._currentDistance = offset;\n        return offset;\n    }\n    drawAnchorOffset(context, color, weight, transformFromClip) {\n        if (-1 === this._anchorIndex || Math.abs(this._currentDistance) < Geometry.smallMetricDistance)\n            return;\n        const anchorRay = ViewClipTool.getClipRayTransformed(this._controls[this._anchorIndex].origin, this._controls[this._anchorIndex].direction, transformFromClip);\n        anchorRay.direction.scaleToLength(this._currentDistance, anchorRay.direction);\n        const pt1 = anchorRay.fractionToPoint(0.0);\n        const pt2 = anchorRay.fractionToPoint(1.0);\n        const builder = context.createGraphicBuilder(GraphicType.ViewOverlay);\n        context.viewport.worldToView(pt1, pt1);\n        pt1.z = 0.0;\n        context.viewport.worldToView(pt2, pt2);\n        pt2.z = 0.0;\n        builder.setSymbology(color, ColorDef.black, weight, LinePixels.Code5);\n        builder.addLineString([pt1, pt2]);\n        builder.setSymbology(color, ColorDef.black, weight + 7);\n        builder.addPointString([pt1, pt2]);\n        context.addDecorationFromBuilder(builder);\n    }\n    decorate(context) {\n        if (-1 === this._anchorIndex || context.viewport !== this._clipView)\n            return;\n        this.drawViewClip(context);\n    }\n    async onMouseMotion(ev) {\n        if (!this.updateViewClip(ev, false))\n            return;\n        this._clipView.invalidateDecorations();\n    }\n    accept(ev) {\n        if (!this.updateViewClip(ev, true))\n            return false;\n        this._restoreClip = false;\n        return true;\n    }\n    async onCleanup() {\n        if (this._restoreClip && ViewClipTool.hasClip(this._clipView))\n            ViewClipTool.setViewClip(this._clipView, this._clip);\n        this._clipView.clipStyle = this._clipStyle;\n    }\n}\n/** @internal Interactive tool to modify a view's clip defined by a ClipShape */\nexport class ViewClipShapeModifyTool extends ViewClipModifyTool {\n    updateViewClip(ev, _isAccept) {\n        const clipShape = ViewClipTool.isSingleClipShape(this._clip);\n        if (undefined === clipShape)\n            return false;\n        const offset = this.getOffsetValue(ev, clipShape.transformFromClip);\n        if (undefined === offset)\n            return false;\n        const offsetAll = ev.isShiftKey;\n        const localOffset = ViewClipTool.getOffsetValueTransformed(offset, clipShape.transformToClip);\n        const shapePts = ViewClipTool.getClipShapePoints(clipShape, 0.0);\n        const adjustedPts = [];\n        for (let i = 0; i < shapePts.length; i++) {\n            const prevFace = (0 === i ? shapePts.length - 2 : i - 1);\n            const nextFace = (shapePts.length - 1 === i ? 0 : i);\n            const prevSelected = offsetAll || (prevFace === this._anchorIndex || this.manipulator.iModel.selectionSet.has(this._ids[prevFace]));\n            const nextSelected = offsetAll || (nextFace === this._anchorIndex || this.manipulator.iModel.selectionSet.has(this._ids[nextFace]));\n            if (prevSelected && nextSelected) {\n                const prevPt = shapePts[i].plusScaled(this._controls[prevFace].direction, localOffset);\n                const nextPt = shapePts[i].plusScaled(this._controls[nextFace].direction, localOffset);\n                const prevRay = Ray3d.create(prevPt, Vector3d.createStartEnd(shapePts[i === 0 ? shapePts.length - 2 : i - 1], shapePts[i]));\n                const nextPlane = Plane3dByOriginAndUnitNormal.create(nextPt, this._controls[nextFace].direction);\n                if (undefined === nextPlane || undefined === prevRay.intersectionWithPlane(nextPlane, prevPt))\n                    return false;\n                adjustedPts[i] = prevPt;\n            }\n            else if (prevSelected) {\n                adjustedPts[i] = shapePts[i].plusScaled(this._controls[prevFace].direction, localOffset);\n            }\n            else if (nextSelected) {\n                adjustedPts[i] = shapePts[i].plusScaled(this._controls[nextFace].direction, localOffset);\n            }\n            else {\n                adjustedPts[i] = shapePts[i];\n            }\n        }\n        let zLow = clipShape.zLow;\n        let zHigh = clipShape.zHigh;\n        const zLowIndex = this._controls.length - 2;\n        const zHighIndex = this._controls.length - 1;\n        const zLowSelected = offsetAll || (zLowIndex === this._anchorIndex || this.manipulator.iModel.selectionSet.has(this._ids[zLowIndex]));\n        const zHighSelected = offsetAll || (zHighIndex === this._anchorIndex || this.manipulator.iModel.selectionSet.has(this._ids[zHighIndex]));\n        if (zLowSelected || zHighSelected) {\n            const clipExtents = ViewClipTool.getClipShapeExtents(clipShape, this._viewRange);\n            if (zLowSelected)\n                zLow = clipExtents.low - localOffset;\n            if (zHighSelected)\n                zHigh = clipExtents.high + localOffset;\n            const realZLow = (undefined === zLow ? clipExtents.low : zLow);\n            const realZHigh = (undefined === zHigh ? clipExtents.high : zHigh);\n            if (realZLow > realZHigh) {\n                zLow = realZHigh;\n                zHigh = realZLow;\n            }\n        }\n        return ViewClipTool.doClipToShape(this._clipView, adjustedPts, clipShape.transformFromClip, zLow, zHigh);\n    }\n    drawViewClip(context) {\n        const clip = this._clipView.view.getViewClip();\n        if (undefined === clip)\n            return;\n        const clipShape = ViewClipTool.isSingleClipShape(clip);\n        if (undefined === clipShape)\n            return;\n        const clipExtents = ViewClipTool.getClipShapeExtents(clipShape, this._viewRange);\n        const color = EditManipulator.HandleUtils.adjustForBackgroundColor(ColorDef.white, context.viewport);\n        ViewClipTool.drawClipShape(context, clipShape, clipExtents, color, 1);\n        this.drawAnchorOffset(context, color, 1, clipShape.transformFromClip);\n    }\n}\n/** @internal Interactive tool to modify a view's clip defined by a ConvexClipPlaneSet */\nexport class ViewClipPlanesModifyTool extends ViewClipModifyTool {\n    updateViewClip(ev, _isAccept) {\n        const offset = this.getOffsetValue(ev);\n        if (undefined === offset)\n            return false;\n        const offsetAll = ev.isShiftKey;\n        const planeSet = ConvexClipPlaneSet.createEmpty();\n        for (let i = 0; i < this._controls.length; i++) {\n            const selected = offsetAll || (i === this._anchorIndex || this.manipulator.iModel.selectionSet.has(this._ids[i]));\n            const origin = this._controls[i].origin.clone();\n            const direction = this._controls[i].direction;\n            if (selected)\n                origin.plusScaled(direction, offset, origin);\n            planeSet.addPlaneToConvexSet(ClipPlane.createNormalAndPoint(direction.negate(), origin));\n        }\n        return ViewClipTool.doClipToConvexClipPlaneSet(this._clipView, planeSet);\n    }\n    drawViewClip(context) {\n        const clip = this._clipView.view.getViewClip();\n        if (undefined === clip)\n            return;\n        const clipPlanes = ViewClipTool.isSingleConvexClipPlaneSet(clip);\n        if (undefined === clipPlanes)\n            return;\n        const clipPlanesLoops = ClipUtilities.loopsOfConvexClipPlaneIntersectionWithRange(clipPlanes, this._viewRange, true, false, true);\n        if (undefined === clipPlanesLoops)\n            return;\n        const color = EditManipulator.HandleUtils.adjustForBackgroundColor(ColorDef.white, context.viewport);\n        ViewClipTool.drawClipPlanesLoops(context, clipPlanesLoops, color, 1);\n        this.drawAnchorOffset(context, color, 1);\n    }\n}\n/** @internal Modify handle data to modify a view's clip */\nexport class ViewClipControlArrow {\n    constructor(origin, direction, sizeInches, fill, outline, name) {\n        this.origin = origin;\n        this.direction = direction;\n        this.sizeInches = sizeInches;\n        this.fill = fill;\n        this.outline = outline;\n        this.name = name;\n    }\n}\n/** A pickable decoration managed by ViewClipDecorationProvider used to visualize a view's clip and present modification handles.\n * This class is public to facilitate customization of view clip events by type or selected controls.\n * @see [[ViewClipDecorationProvider]]\n * @public\n * @extensions\n */\nexport class ViewClipDecoration extends EditManipulator.HandleProvider {\n    constructor(_clipView, _clipEventHandler) {\n        super(_clipView.iModel);\n        this._clipView = _clipView;\n        this._clipEventHandler = _clipEventHandler;\n        /** @internal */\n        this._controlIds = [];\n        /** @internal */\n        this._controls = [];\n        /** @internal */\n        this._suspendDecorator = false;\n        if (!this.getClipData())\n            return;\n        this._clipId = this.iModel.transientIds.getNext();\n        this.updateDecorationListener(true);\n        this._removeViewCloseListener = IModelApp.viewManager.onViewClose.addListener(this.onViewClose, this); // eslint-disable-line @typescript-eslint/unbound-method\n        if (undefined !== this._clipEventHandler && this._clipEventHandler.selectOnCreate())\n            this.iModel.selectionSet.replace(this._clipId);\n    }\n    get clipId() { return this._clipId; }\n    get clipShape() { return this._clipShape; }\n    get clipPlaneSet() { return this._clipPlanes; }\n    getControlIndex(id) { return this._controlIds.indexOf(id); }\n    stop() {\n        const selectedId = (undefined !== this._clipId && this.iModel.selectionSet.has(this._clipId)) ? this._clipId : undefined;\n        this._clipId = undefined; // Invalidate id so that decorator will be dropped...\n        super.stop();\n        if (undefined !== selectedId)\n            this.iModel.selectionSet.remove(selectedId); // Don't leave decorator id in selection set...\n        if (undefined !== this._removeViewCloseListener) {\n            this._removeViewCloseListener();\n            this._removeViewCloseListener = undefined;\n        }\n    }\n    onViewClose(vp) {\n        if (this._clipView === vp)\n            ViewClipDecoration.clear();\n    }\n    getClipData() {\n        this._clip = this._clipShape = this._clipShapeExtents = this._clipPlanes = this._clipPlanesLoops = this._clipPlanesLoopsNoncontributing = undefined;\n        let clip = this._clipView.view.getViewClip();\n        if (undefined === clip)\n            return false;\n        let clipShape = ViewClipTool.isSingleClipShape(clip);\n        if (undefined !== clipShape) {\n            if (clipShape.polygon.length > 5) {\n                const compressed = PolylineOps.compressByChordError(clipShape.polygon, 1.0e-5);\n                if (compressed.length < clipShape.polygon.length) {\n                    clip = clip.clone();\n                    clipShape = ViewClipTool.isSingleClipShape(clip);\n                    clipShape.setPolygon(compressed);\n                    this._clipView.view.setViewClip(clip);\n                }\n            }\n            this._clipShapeExtents = ViewClipTool.getClipShapeExtents(clipShape, this._clipView.computeViewRange());\n            this._clipShape = clipShape;\n        }\n        else {\n            const clipPlanes = ViewClipTool.isSingleConvexClipPlaneSet(clip);\n            if (undefined === clipPlanes || clipPlanes.planes.length > 12) {\n                // Show visual representation for ClipVectors that are not supported for modification...\n                const viewRange = this._clipView.computeViewRange();\n                for (const primitive of clip.clips) {\n                    const union = primitive.fetchClipPlanesRef();\n                    if (undefined === union)\n                        continue;\n                    for (const convexSet of union.convexSets) {\n                        const convexSetLoops = ClipUtilities.loopsOfConvexClipPlaneIntersectionWithRange(convexSet, viewRange, true, false, true);\n                        if (undefined === convexSetLoops)\n                            continue;\n                        if (undefined === this._clipPlanesLoops)\n                            this._clipPlanesLoops = convexSetLoops;\n                        else\n                            this._clipPlanesLoops.push(...convexSetLoops);\n                    }\n                }\n                if (undefined === this._clipPlanesLoops)\n                    return false;\n                this._clip = clip;\n                return true;\n            }\n            const clipPlanesLoops = ClipUtilities.loopsOfConvexClipPlaneIntersectionWithRange(clipPlanes, this._clipView.computeViewRange(), true, false, true);\n            if (undefined !== clipPlanesLoops && clipPlanesLoops.length > clipPlanes.planes.length)\n                return false;\n            this._clipPlanesLoops = clipPlanesLoops;\n            this._clipPlanes = clipPlanes;\n        }\n        this._clip = clip;\n        return true;\n    }\n    ensureNumControls(numReqControls) {\n        const numCurrent = this._controlIds.length;\n        if (numCurrent < numReqControls) {\n            const transientIds = this.iModel.transientIds;\n            for (let i = numCurrent; i < numReqControls; i++)\n                this._controlIds[i] = transientIds.getNext();\n        }\n        else if (numCurrent > numReqControls) {\n            this._controlIds.length = numReqControls;\n        }\n    }\n    createClipShapeControls() {\n        if (undefined === this._clipShape || undefined === this._clipShapeExtents)\n            return false;\n        const shapePtsLo = ViewClipTool.getClipShapePoints(this._clipShape, this._clipShapeExtents.low);\n        const shapePtsHi = ViewClipTool.getClipShapePoints(this._clipShape, this._clipShapeExtents.high);\n        const shapeArea = PolygonOps.centroidAreaNormal(shapePtsLo);\n        if (undefined === shapeArea)\n            return false;\n        const numControls = shapePtsLo.length + 1; // Number of edge midpoints plus zLow and zHigh...\n        this.ensureNumControls(numControls);\n        for (let i = 0; i < numControls - 2; i++) {\n            const midPtLo = shapePtsLo[i].interpolate(0.5, shapePtsLo[i + 1]);\n            const midPtHi = shapePtsHi[i].interpolate(0.5, shapePtsHi[i + 1]);\n            const faceCenter = midPtLo.interpolate(0.5, midPtHi);\n            const edgeTangent = Vector3d.createStartEnd(shapePtsLo[i], shapePtsLo[i + 1]);\n            const faceNormal = edgeTangent.crossProduct(shapeArea.direction);\n            faceNormal.normalizeInPlace();\n            this._controls[i] = new ViewClipControlArrow(faceCenter, faceNormal, shapePtsLo.length > 5 ? 0.5 : 0.75);\n        }\n        const zFillColor = ColorDef.from(150, 150, 250);\n        this._controls[numControls - 2] = new ViewClipControlArrow(shapeArea.origin, Vector3d.unitZ(-1.0), 0.75, zFillColor, undefined, \"zLow\");\n        this._controls[numControls - 1] = new ViewClipControlArrow(shapeArea.origin.plusScaled(Vector3d.unitZ(), shapePtsLo[0].distance(shapePtsHi[0])), Vector3d.unitZ(), 0.75, zFillColor, undefined, \"zHigh\");\n        return true;\n    }\n    getLoopCentroidAreaNormal(geom) {\n        if (!(geom instanceof Loop) || geom.children.length > 1)\n            return undefined;\n        const child = geom.getChild(0);\n        if (!(child instanceof LineString3d))\n            return undefined;\n        return PolygonOps.centroidAreaNormal(child.points);\n    }\n    createClipPlanesControls() {\n        if (undefined === this._clipPlanes)\n            return false;\n        const loopData = [];\n        if (undefined !== this._clipPlanesLoops) {\n            for (const geom of this._clipPlanesLoops) {\n                const loopArea = this.getLoopCentroidAreaNormal(geom);\n                if (undefined !== loopArea)\n                    loopData.push(loopArea);\n            }\n        }\n        const numControls = this._clipPlanes.planes.length;\n        this.ensureNumControls(numControls);\n        let viewRange;\n        let iLoop = 0;\n        for (let i = 0; i < this._clipPlanes.planes.length; i++) {\n            const plane = this._clipPlanes.planes[i].getPlane3d();\n            if (iLoop < loopData.length) {\n                if (Math.abs(loopData[iLoop].direction.dotProduct(plane.getNormalRef())) > 0.9999 && plane.isPointInPlane(loopData[iLoop].origin)) {\n                    const outwardNormal = loopData[iLoop].direction.negate();\n                    this._controls[i] = new ViewClipControlArrow(loopData[iLoop].origin, outwardNormal, 0.75);\n                    iLoop++;\n                    continue;\n                }\n            }\n            if (undefined === viewRange)\n                viewRange = this._clipView.computeViewRange();\n            const defaultOrigin = plane.projectPointToPlane(viewRange.center);\n            const defaultOutwardNormal = plane.getNormalRef().negate();\n            const expandedRange = viewRange.clone();\n            expandedRange.extend(defaultOrigin);\n            const nonContribLoops = ClipUtilities.loopsOfConvexClipPlaneIntersectionWithRange(ConvexClipPlaneSet.createPlanes([this._clipPlanes.planes[i]]), expandedRange, true, false, true);\n            const nonContribColor = ColorDef.from(250, 100, 100);\n            if (undefined !== nonContribLoops && nonContribLoops.length > 0) {\n                if (undefined === this._clipPlanesLoopsNoncontributing)\n                    this._clipPlanesLoopsNoncontributing = nonContribLoops;\n                else\n                    this._clipPlanesLoopsNoncontributing = this._clipPlanesLoopsNoncontributing.concat(nonContribLoops);\n                const loopArea = this.getLoopCentroidAreaNormal(nonContribLoops[0]);\n                if (undefined !== loopArea) {\n                    const outwardNormal = loopArea.direction.negate();\n                    this._controls[i] = new ViewClipControlArrow(loopArea.origin, outwardNormal, 0.5, nonContribColor);\n                    continue;\n                }\n            }\n            this._controls[i] = new ViewClipControlArrow(defaultOrigin, defaultOutwardNormal, 0.5, nonContribColor); // Just show arrow for right-click menu options...\n        }\n        return true;\n    }\n    async createControls() {\n        // Always update to current view clip to handle post-modify, etc.\n        if (undefined === this._clipId || !this.getClipData())\n            return false;\n        // Show controls if only range box and it's controls are selected, selection set doesn't include any other elements...\n        let showControls = false;\n        if (this.iModel.selectionSet.size <= this._controlIds.length + 1 && this.iModel.selectionSet.has(this._clipId)) {\n            showControls = true;\n            if (this.iModel.selectionSet.size > 1) {\n                this.iModel.selectionSet.elements.forEach((val) => {\n                    if (this._clipId !== val && !this._controlIds.includes(val))\n                        showControls = false;\n                });\n            }\n        }\n        if (!showControls) {\n            if (undefined !== this._clipEventHandler && this._clipEventHandler.clearOnDeselect())\n                ViewClipDecoration.clear();\n            return false;\n        }\n        if (undefined !== this._clipShape)\n            return this.createClipShapeControls();\n        else if (undefined !== this._clipPlanes)\n            return this.createClipPlanesControls();\n        return false;\n    }\n    clearControls() {\n        this.iModel.selectionSet.remove(this._controlIds); // Remove any selected controls as they won't continue to be displayed...\n        super.clearControls();\n    }\n    async modifyControls(hit, _ev) {\n        if (undefined === this._clip || hit.sourceId === this._clipId)\n            return false;\n        const saveQualifiers = IModelApp.toolAdmin.currentInputState.qualifiers;\n        if (undefined !== this._clipShape) {\n            const clipShapeModifyTool = new ViewClipShapeModifyTool(this, this._clip, this._clipView, hit.sourceId, this._controlIds, this._controls);\n            this._suspendDecorator = await clipShapeModifyTool.run();\n        }\n        else if (undefined !== this._clipPlanes) {\n            const clipPlanesModifyTool = new ViewClipPlanesModifyTool(this, this._clip, this._clipView, hit.sourceId, this._controlIds, this._controls);\n            this._suspendDecorator = await clipPlanesModifyTool.run();\n        }\n        if (this._suspendDecorator)\n            IModelApp.toolAdmin.currentInputState.qualifiers = saveQualifiers; // onInstallTool cleared qualifiers, preserve for \"modify all\" behavior when shift was held and drag started...\n        return this._suspendDecorator;\n    }\n    doClipPlaneNegate(index) {\n        if (undefined === this._clipPlanes)\n            return false;\n        if (index < 0 || index >= this._clipPlanes.planes.length)\n            return false;\n        const planeSet = ConvexClipPlaneSet.createEmpty();\n        for (let i = 0; i < this._clipPlanes.planes.length; i++) {\n            const plane = (i === index ? this._clipPlanes.planes[i].cloneNegated() : this._clipPlanes.planes[i]);\n            planeSet.addPlaneToConvexSet(plane);\n        }\n        if (!ViewClipTool.doClipToConvexClipPlaneSet(this._clipView, planeSet))\n            return false;\n        this.onManipulatorEvent(EditManipulator.EventType.Accept);\n        return true;\n    }\n    doClipPlaneClear(index) {\n        if (undefined === this._clipPlanes)\n            return false;\n        if (index < 0 || index >= this._clipPlanes.planes.length)\n            return false;\n        if (1 === this._clipPlanes.planes.length) {\n            if (!ViewClipTool.doClipClear(this._clipView))\n                return false;\n            if (undefined !== this._clipEventHandler)\n                this._clipEventHandler.onClearClip(this._clipView);\n            ViewClipDecoration.clear();\n            return true;\n        }\n        const planeSet = ConvexClipPlaneSet.createEmpty();\n        for (let i = 0; i < this._clipPlanes.planes.length; i++) {\n            if (i === index)\n                continue;\n            const plane = this._clipPlanes.planes[i];\n            planeSet.addPlaneToConvexSet(plane);\n        }\n        if (!ViewClipTool.doClipToConvexClipPlaneSet(this._clipView, planeSet))\n            return false;\n        this.onManipulatorEvent(EditManipulator.EventType.Accept);\n        return true;\n    }\n    getClipShapeFaceLoops() {\n        if (undefined === this._clipShape || undefined === this._clipShapeExtents)\n            return undefined;\n        const shapePtsLo = ViewClipTool.getClipShapePoints(this._clipShape, this._clipShapeExtents.low);\n        const shapePtsHi = ViewClipTool.getClipShapePoints(this._clipShape, this._clipShapeExtents.high);\n        if (undefined !== this._clipShape.transformFromClip) {\n            this._clipShape.transformFromClip.multiplyPoint3dArrayInPlace(shapePtsLo);\n            this._clipShape.transformFromClip.multiplyPoint3dArrayInPlace(shapePtsHi);\n        }\n        const cap0 = Loop.createPolygon(shapePtsLo);\n        const cap1 = Loop.createPolygon(shapePtsHi);\n        const faces = [];\n        faces.push(cap0);\n        faces.push(cap1);\n        for (let i = 0; i < shapePtsLo.length; i++) {\n            const next = (i === shapePtsLo.length - 1 ? 0 : i + 1);\n            const side = Loop.createPolygon([shapePtsLo[i].clone(), shapePtsLo[next].clone(), shapePtsHi[next].clone(), shapePtsHi[i].clone()]);\n            faces.push(side);\n        }\n        return faces;\n    }\n    getMatchingLoop(loops, ray) {\n        for (const geom of loops) {\n            const loopArea = this.getLoopCentroidAreaNormal(geom);\n            if (undefined === loopArea)\n                continue;\n            if (!loopArea.direction.isParallelTo(ray.direction, true)) // don't assume outward normal for clip plane loops...\n                continue;\n            const plane = Plane3dByOriginAndUnitNormal.create(loopArea.origin, loopArea.direction);\n            if (undefined === plane || !plane.isPointInPlane(ray.origin))\n                continue;\n            return geom;\n        }\n        return undefined;\n    }\n    getLoopPreferredX(loop, outwardNormal) {\n        const localToWorld = FrameBuilder.createRightHandedFrame(undefined, loop);\n        if (undefined === localToWorld)\n            return undefined;\n        let vectorX;\n        const dirX = localToWorld.matrix.getColumn(0);\n        const dirY = localToWorld.matrix.getColumn(1);\n        const dirZ = localToWorld.matrix.getColumn(2);\n        const unitX = Vector3d.unitX();\n        const unitZ = Vector3d.unitZ();\n        if (dirZ.isParallelTo(unitZ, true)) {\n            // For clip in xy plane, choose direction closest to world x...\n            vectorX = Math.abs(dirX.dotProduct(unitX)) > Math.abs(dirY.dotProduct(unitX)) ? dirX : dirY;\n            if (vectorX.dotProduct(unitX) < 0.0)\n                vectorX.negate(vectorX); // prefer positive x...\n        }\n        else {\n            // For clip in arbitrary plane, choose direction closest to being in xy plane...\n            let vectorY;\n            const crossX = outwardNormal.unitCrossProduct(dirY);\n            const crossY = outwardNormal.unitCrossProduct(dirX);\n            if (crossX && crossY) {\n                if (Math.abs(crossY.dotProduct(unitZ)) > Math.abs(crossX.dotProduct(unitZ))) {\n                    vectorX = dirX;\n                    vectorY = crossY;\n                }\n                else {\n                    vectorX = dirY;\n                    vectorY = crossX;\n                }\n            }\n            else {\n                vectorX = crossX ? dirY : dirX;\n            }\n            if (vectorY && vectorY.dotProduct(unitZ) < 0.0)\n                vectorX.negate(vectorX); // prefer positive z...\n        }\n        return vectorX;\n    }\n    doClipPlaneOrientView(index) {\n        if (index < 0 || index >= this._controlIds.length)\n            return false;\n        const vp = this._clipView;\n        const anchorRay = ViewClipTool.getClipRayTransformed(this._controls[index].origin, this._controls[index].direction, undefined !== this._clipShape ? this._clipShape.transformFromClip : undefined);\n        // Try to align x direction with clip plane loop...\n        const loops = (undefined !== this._clipPlanesLoops ? this._clipPlanesLoops : this.getClipShapeFaceLoops());\n        const loop = (loops ? (1 === loops.length ? loops[0] : this.getMatchingLoop(loops, anchorRay)) : undefined);\n        const vectorX = (loop ? this.getLoopPreferredX(loop, anchorRay.direction) : undefined);\n        const matrix = Matrix3d.createIdentity();\n        if (undefined === vectorX || undefined === Matrix3d.createRigidFromColumns(anchorRay.direction, vectorX, AxisOrder.ZXY, matrix))\n            Matrix3d.createRigidHeadsUp(anchorRay.direction, AxisOrder.ZXY, matrix);\n        const targetMatrix = matrix.multiplyMatrixMatrix(vp.rotation);\n        const rotateTransform = Transform.createFixedPointAndMatrix(anchorRay.origin, targetMatrix);\n        const newFrustum = vp.getFrustum();\n        newFrustum.multiply(rotateTransform);\n        vp.view.setupFromFrustum(newFrustum);\n        vp.synchWithView();\n        vp.animateFrustumChange();\n        return true;\n    }\n    getWorldUpPlane(viewport) {\n        const matrix = AccuDrawHintBuilder.getContextRotation(ContextRotationId.Top, viewport);\n        if (undefined === matrix)\n            return undefined;\n        const worldUp = matrix.getColumn(2);\n        const planePt = (viewport.isContextRotationRequired ? viewport.getAuxCoordOrigin() : (viewport.view.isSpatialView() ? viewport.view.iModel.globalOrigin : Point3d.createZero()));\n        return Plane3dByOriginAndUnitNormal.create(planePt, worldUp);\n    }\n    isAlignedToWorldUpPlane(plane, transformFromClip) {\n        const normal = (undefined !== transformFromClip ? transformFromClip.multiplyVector(Vector3d.unitZ()) : Vector3d.unitZ());\n        return plane.getNormalRef().isParallelTo(normal, true);\n    }\n    isClipShapeAlignedWithWorldUp(extents) {\n        if (undefined === this._clipShape || undefined === this._clipShapeExtents)\n            return false;\n        const plane = this.getWorldUpPlane(this._clipView);\n        if (undefined === plane || !this.isAlignedToWorldUpPlane(plane, this._clipShape.transformFromClip))\n            return false;\n        if (undefined === extents)\n            return true;\n        const zLow = Point3d.create(0.0, 0.0, this._clipShapeExtents.low);\n        const zHigh = Point3d.create(0.0, 0.0, this._clipShapeExtents.high);\n        if (undefined !== this._clipShape.transformFromClip) {\n            this._clipShape.transformFromClip.multiplyPoint3d(zLow, zLow);\n            this._clipShape.transformFromClip.multiplyPoint3d(zHigh, zHigh);\n        }\n        const lowDir = Vector3d.createStartEnd(plane.projectPointToPlane(zLow), zLow);\n        const highDir = Vector3d.createStartEnd(plane.projectPointToPlane(zHigh), zHigh);\n        let zLowWorld = lowDir.magnitude();\n        let zHighWorld = highDir.magnitude();\n        if (lowDir.dotProduct(plane.getNormalRef()) < 0.0)\n            zLowWorld = -zLowWorld;\n        if (highDir.dotProduct(plane.getNormalRef()) < 0.0)\n            zHighWorld = -zHighWorld;\n        Range1d.createXX(zLowWorld, zHighWorld, extents);\n        return true;\n    }\n    doClipShapeSetZExtents(extents) {\n        if (extents.low > extents.high)\n            return false;\n        if (undefined === this._clipShape)\n            return false;\n        const plane = this.getWorldUpPlane(this._clipView);\n        if (undefined === plane || !this.isAlignedToWorldUpPlane(plane, this._clipShape.transformFromClip))\n            return false;\n        const zLow = plane.getOriginRef().plusScaled(plane.getNormalRef(), extents.low);\n        const zHigh = plane.getOriginRef().plusScaled(plane.getNormalRef(), extents.high);\n        if (undefined !== this._clipShape.transformToClip) {\n            this._clipShape.transformToClip.multiplyPoint3d(zLow, zLow);\n            this._clipShape.transformToClip.multiplyPoint3d(zHigh, zHigh);\n        }\n        const reversed = (zLow.z > zHigh.z);\n        const shape = ClipShape.createFrom(this._clipShape);\n        shape.initSecondaryProps(shape.isMask, reversed ? zHigh.z : zLow.z, reversed ? zLow.z : zHigh.z, this._clipShape.transformFromClip);\n        const clip = ClipVector.createEmpty();\n        clip.appendReference(shape);\n        if (!ViewClipTool.setViewClip(this._clipView, clip))\n            return false;\n        this.onManipulatorEvent(EditManipulator.EventType.Accept);\n        return true;\n    }\n    async onRightClick(hit, ev) {\n        if (undefined === this._clipEventHandler)\n            return EventHandled.No;\n        return (this._clipEventHandler.onRightClick(hit, ev) ? EventHandled.Yes : EventHandled.No);\n    }\n    async onTouchTap(hit, ev) { return (hit.sourceId === this._clipId ? EventHandled.No : super.onTouchTap(hit, ev)); }\n    onManipulatorEvent(eventType) {\n        this._suspendDecorator = false;\n        super.onManipulatorEvent(eventType);\n        if (EditManipulator.EventType.Accept === eventType && undefined !== this._clipEventHandler)\n            this._clipEventHandler.onModifyClip(this._clipView);\n    }\n    testDecorationHit(id) { return (id === this._clipId || this._controlIds.includes(id)); }\n    async getDecorationToolTip(hit) {\n        if (hit.sourceId === this._clipId)\n            return CoreTools.translate(\"ViewClip.Message.Clip\");\n        return CoreTools.translate(\"ViewClip.Message.ModifyClip\");\n    }\n    updateDecorationListener(_add) { super.updateDecorationListener(undefined !== this._clipId); } // Decorator isn't just for resize controls...\n    decorate(context) {\n        if (this._suspendDecorator)\n            return;\n        if (undefined === this._clipId || undefined === this._clip)\n            return;\n        const vp = context.viewport;\n        if (this._clipView !== vp)\n            return;\n        if (undefined !== this._clipShape) {\n            ViewClipTool.drawClipShape(context, this._clipShape, this._clipShapeExtents, EditManipulator.HandleUtils.adjustForBackgroundColor(ColorDef.white, vp), 3, this._clipId);\n        }\n        else if (undefined !== this._clipPlanes) {\n            if (undefined !== this._clipPlanesLoops)\n                ViewClipTool.drawClipPlanesLoops(context, this._clipPlanesLoops, EditManipulator.HandleUtils.adjustForBackgroundColor(ColorDef.white, vp), 3, false, EditManipulator.HandleUtils.adjustForBackgroundColor(ColorDef.from(0, 255, 255, 225), vp), this._clipId);\n            if (undefined !== this._clipPlanesLoopsNoncontributing)\n                ViewClipTool.drawClipPlanesLoops(context, this._clipPlanesLoopsNoncontributing, EditManipulator.HandleUtils.adjustForBackgroundColor(ColorDef.red, vp), 1, true);\n        }\n        else if (undefined !== this._clipPlanesLoops) {\n            ViewClipTool.drawClipPlanesLoops(context, this._clipPlanesLoops, EditManipulator.HandleUtils.adjustForBackgroundColor(ColorDef.white, vp), 3, false, EditManipulator.HandleUtils.adjustForBackgroundColor(ColorDef.from(0, 255, 255, 225), vp), this._clipId);\n        }\n        if (!this._isActive)\n            return;\n        const outlineColor = EditManipulator.HandleUtils.adjustForBackgroundColor(ColorDef.from(0, 0, 0, 50), vp);\n        const fillVisColor = EditManipulator.HandleUtils.adjustForBackgroundColor(ColorDef.from(150, 250, 200, 175), vp);\n        const fillHidColor = fillVisColor.withAlpha(225);\n        const fillSelColor = fillVisColor.inverse().withAlpha(75);\n        const shapePts = EditManipulator.HandleUtils.getArrowShape(0.0, 0.15, 0.55, 1.0, 0.3, 0.5, 0.1);\n        for (let iFace = 0; iFace < this._controlIds.length; iFace++) {\n            const sizeInches = this._controls[iFace].sizeInches;\n            if (0.0 === sizeInches)\n                continue;\n            // For single plane clip, choose location for handle that's visible in the current view...\n            if (1 === this._controls.length && undefined !== this._clipPlanes && undefined !== this._clipPlanesLoops && this._clipPlanesLoops.length > 0) {\n                if (!vp.isPointVisibleXY(this._controls[iFace].origin, CoordSystem.World, 0.05)) {\n                    const geom = this._clipPlanesLoops[0];\n                    if (geom instanceof Loop && geom.children.length > 0) {\n                        const child = geom.getChild(0);\n                        if (child instanceof LineString3d) {\n                            const work = new GrowableXYZArray();\n                            const finalPoints = new GrowableXYZArray();\n                            const lineString = child.points;\n                            const convexSet = vp.getFrustum().getRangePlanes(false, false, 0);\n                            convexSet.polygonClip(lineString, finalPoints, work);\n                            if (finalPoints.length > 0) {\n                                const loopArea = PolygonOps.centroidAreaNormal(finalPoints.getPoint3dArray());\n                                if (undefined !== loopArea) {\n                                    if (undefined === this._controls[iFace].floatingOrigin)\n                                        this._controls[iFace].floatingOrigin = this._controls[iFace].origin.clone();\n                                    this._controls[iFace].origin.setFrom(loopArea.origin);\n                                }\n                            }\n                        }\n                    }\n                }\n                else if (undefined !== this._controls[iFace].floatingOrigin && vp.isPointVisibleXY(this._controls[iFace].floatingOrigin, CoordSystem.World, 0.1)) {\n                    this._controls[iFace].origin.setFrom(this._controls[iFace].floatingOrigin);\n                    this._controls[iFace].floatingOrigin = undefined;\n                }\n            }\n            const anchorRay = ViewClipTool.getClipRayTransformed(this._controls[iFace].origin, this._controls[iFace].direction, undefined !== this._clipShape ? this._clipShape.transformFromClip : undefined);\n            const transform = EditManipulator.HandleUtils.getArrowTransform(vp, anchorRay.origin, anchorRay.direction, sizeInches);\n            if (undefined === transform)\n                continue;\n            // deep copy because we're using a builder transform w/addLineString...\n            const visPts = shapePts.map((pt) => pt.clone());\n            const hidPts = shapePts.map((pt) => pt.clone());\n            const arrowVisBuilder = context.createGraphicBuilder(GraphicType.WorldOverlay, transform, this._controlIds[iFace]);\n            const arrowHidBuilder = context.createGraphicBuilder(GraphicType.WorldDecoration, transform);\n            const isSelected = this.iModel.selectionSet.has(this._controlIds[iFace]);\n            let outlineColorOvr = this._controls[iFace].outline;\n            if (undefined !== outlineColorOvr) {\n                outlineColorOvr = EditManipulator.HandleUtils.adjustForBackgroundColor(outlineColorOvr, vp);\n                outlineColorOvr = outlineColorOvr.withAlpha(outlineColor.getAlpha());\n            }\n            else {\n                outlineColorOvr = outlineColor;\n            }\n            let fillVisColorOvr = this._controls[iFace].fill;\n            let fillHidColorOvr = fillHidColor;\n            let fillSelColorOvr = fillSelColor;\n            if (undefined !== fillVisColorOvr) {\n                fillVisColorOvr = EditManipulator.HandleUtils.adjustForBackgroundColor(fillVisColorOvr, vp);\n                fillVisColorOvr = fillVisColorOvr.withAlpha(fillVisColor.getAlpha());\n                fillHidColorOvr = fillVisColorOvr.withAlpha(fillHidColor.getAlpha());\n                fillSelColorOvr = fillVisColorOvr.inverse().withAlpha(fillSelColor.getAlpha());\n            }\n            else {\n                fillVisColorOvr = fillVisColor;\n            }\n            arrowVisBuilder.setSymbology(outlineColorOvr, outlineColorOvr, isSelected ? 4 : 2);\n            arrowVisBuilder.addLineString(visPts);\n            arrowVisBuilder.setBlankingFill(isSelected ? fillSelColorOvr : fillVisColorOvr);\n            arrowVisBuilder.addShape(visPts);\n            context.addDecorationFromBuilder(arrowVisBuilder);\n            arrowHidBuilder.setSymbology(fillHidColorOvr, fillHidColorOvr, 1);\n            arrowHidBuilder.addShape(hidPts);\n            context.addDecorationFromBuilder(arrowHidBuilder);\n        }\n    }\n    static get(vp) {\n        if (undefined === ViewClipDecoration._decorator || vp !== ViewClipDecoration._decorator._clipView)\n            return undefined;\n        return ViewClipDecoration._decorator;\n    }\n    static create(vp, clipEventHandler) {\n        if (undefined !== ViewClipDecoration._decorator)\n            ViewClipDecoration.clear();\n        if (!ViewClipTool.hasClip(vp))\n            return undefined;\n        ViewClipDecoration._decorator = new ViewClipDecoration(vp, clipEventHandler);\n        return ViewClipDecoration._decorator.clipId;\n    }\n    static clear() {\n        if (undefined === ViewClipDecoration._decorator)\n            return;\n        ViewClipDecoration._decorator.stop();\n        ViewClipDecoration._decorator = undefined;\n    }\n    static async toggle(vp, clipEventHandler) {\n        let clipId;\n        if (undefined === ViewClipDecoration._decorator)\n            clipId = ViewClipDecoration.create(vp, clipEventHandler);\n        else\n            ViewClipDecoration.clear();\n        await IModelApp.toolAdmin.startDefaultTool();\n        return clipId;\n    }\n}\n/** Event types for ViewClipDecorationProvider.onActiveClipChanged \\\n * @public\n * @extensions\n */\nexport var ClipEventType;\n(function (ClipEventType) {\n    ClipEventType[ClipEventType[\"New\"] = 0] = \"New\";\n    ClipEventType[ClipEventType[\"NewPlane\"] = 1] = \"NewPlane\";\n    ClipEventType[ClipEventType[\"Modify\"] = 2] = \"Modify\";\n    ClipEventType[ClipEventType[\"Clear\"] = 3] = \"Clear\";\n})(ClipEventType || (ClipEventType = {}));\n/** An implementation of ViewClipEventHandler that responds to new clips by presenting clip modification handles\n * @public @extensions\n */\nexport class ViewClipDecorationProvider {\n    constructor() {\n        this.selectDecorationOnCreate = true;\n        this.clearDecorationOnDeselect = true;\n        /** Called when the active clip for a view is changed */\n        this.onActiveClipChanged = new BeEvent();\n        /** Called on a right click over the clip geometry or clip modify handle. ViewClipDecoration provides methods for the following possible menu actions:\n         * For ClipPlanes (undefined !== clipPlaneSet): Flip (doClipPlaneNegate), Clear (doClipPlaneClear), and Orient View (doClipPlaneOrientView)\n         * For ClipShapes (undefined === clipPlaneSet): Orient View (doClipPlaneOrientView) and input fields to set world zLow/zHigh (doClipShapeSetZExtents provided isClipShapeAlignedWithWorldUp returns true)\n         */\n        this.onActiveClipRightClick = new BeEvent();\n    }\n    selectOnCreate() { return this.selectDecorationOnCreate; }\n    clearOnDeselect() { return this.clearDecorationOnDeselect; }\n    onNewClip(viewport) {\n        ViewClipDecoration.create(viewport, this);\n        this.onActiveClipChanged.raiseEvent(viewport, ClipEventType.New, this);\n    }\n    onNewClipPlane(viewport) {\n        ViewClipDecoration.create(viewport, this);\n        this.onActiveClipChanged.raiseEvent(viewport, ClipEventType.NewPlane, this);\n    }\n    onModifyClip(viewport) {\n        this.onActiveClipChanged.raiseEvent(viewport, ClipEventType.Modify, this);\n    }\n    onClearClip(viewport) {\n        ViewClipDecoration.clear();\n        this.onActiveClipChanged.raiseEvent(viewport, ClipEventType.Clear, this);\n    }\n    onRightClick(hit, ev) {\n        const decoration = (undefined !== ev.viewport ? ViewClipDecoration.get(ev.viewport) : undefined);\n        if (undefined === decoration)\n            return false;\n        if (0 === this.onActiveClipRightClick.numberOfListeners)\n            return decoration.doClipPlaneNegate(decoration.getControlIndex(hit.sourceId));\n        this.onActiveClipRightClick.raiseEvent(hit, ev, this);\n        return true;\n    }\n    showDecoration(vp) { ViewClipDecoration.create(vp, this); }\n    hideDecoration() { ViewClipDecoration.clear(); }\n    async toggleDecoration(vp) { return ViewClipDecoration.toggle(vp, this); }\n    isDecorationActive(vp) { return (undefined !== ViewClipDecoration.get(vp)); }\n    static create() {\n        if (undefined === ViewClipDecorationProvider._provider) {\n            ViewClipDecoration.clear();\n            ViewClipDecorationProvider._provider = new ViewClipDecorationProvider();\n        }\n        return ViewClipDecorationProvider._provider;\n    }\n    static clear() {\n        if (undefined === ViewClipDecorationProvider._provider)\n            return;\n        ViewClipDecoration.clear();\n        ViewClipDecorationProvider._provider = undefined;\n    }\n}\n//# sourceMappingURL=ClipViewTool.js.map",
      "start": 1693508119997,
      "end": 1693508120214,
      "sourcemaps": null
    }
  ]
}
