{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/common/lib/esm/geometry/CoordinateReferenceSystem.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Geometry\n */\n// cspell:ignore NAVD, NGVD, NSRS, Helmert\nimport { GeodeticDatum } from \"./GeodeticDatum\";\nimport { GeodeticEllipsoid } from \"./GeodeticEllipsoid\";\nimport { Carto2DDegrees, Projection } from \"./Projection\";\nimport { AdditionalTransform } from \"./AdditionalTransform\";\n/** The extent in latitude, longitude bounds where a horizontal CRS is applicable\n *  @public\n */\nexport class HorizontalCRSExtent {\n    constructor(data) {\n        if (data) {\n            this.southWest = Carto2DDegrees.fromJSON(data.southWest);\n            this.northEast = Carto2DDegrees.fromJSON(data.northEast);\n            if (this.northEast.latitude < this.southWest.latitude)\n                this.northEast.latitude = this.southWest.latitude;\n        }\n        else {\n            this.southWest = new Carto2DDegrees();\n            this.northEast = new Carto2DDegrees();\n        }\n    }\n    /** Creates an extent object from JSON representation.\n     * @public */\n    static fromJSON(data) {\n        return new HorizontalCRSExtent(data);\n    }\n    /** Creates a JSON from the Extent definition\n     * @public */\n    toJSON() {\n        return { southWest: this.southWest.toJSON(), northEast: this.northEast.toJSON() };\n    }\n    /** Compares two Extents. It applies a minuscule tolerance to comparing numbers.\n     *  @public */\n    equals(other) {\n        return this.southWest.equals(other.southWest) && this.northEast.equals(other.northEast);\n    }\n}\n/** Horizontal Geographic Coordinate reference System implementation.\n *  An horizontal CRS defines the portion which is horizontal to the Earth surface (within the deformation brought by the projection process).\n *  There are two major classes of Horizontal Coordinate Reference Systems:\n *  - The projected CRS which rely on a projection to flatten the coordinate system space into axises using linear\n *    units (meter, US Survey Feet, ...) relative to some origin.\n *  - The non projected CRS (also named geographic CRS by EPSG nomenclature) that does\n *    not require a projection (projection method = None) and horizontal coordinates are expressed\n *    as longitude and latitude (see [[Cartographic]])\n *  Horizontal Coordinate Systems rely on a projection to flatten the surface of an ellipsoid (see [[GeodeticEllipsoid]]) which is\n *  the mathematical model of the Earth surface.\n *  Explanations in more details of the various concepts can be obtained from other sources including the page on the subject\n *  on itwinJS.org (see https://www.itwinjs.org/learning/geolocation/?term=coordinate+system).\n *  A few details are still required to grasp the model. Geographic Coordinate Reference Systems rely on the concept of geodetic datums\n *  (see [[GeodeticDatum]]) to convert latitude/longitude from one frame of reference to another. Such geodetic datum will bind the ellipsoid\n *  and possibly define transformation steps required to convert from the currently used geodetic datum to the common datum WGS84\n *  used for worldwide data (such as most popular imagery data sources). If there are no rules established to convert to WGS84\n *  or if those rules are secret then the horizontal CRS can be datum-less and must make direct use of the ellipsoid\n *  to define the earth surface.\n *  For this purpose either the geodetic datum must be specified using either datumId or datum properties or both. If\n *  both these values are undefined then it is possible to define the ellipsoid using properties ellipsoidId or ellipsoid or both.\n *  These two pairs of properties are mutually exclusive with datum related properties having precedence. If a datum or datumId is set then\n *  ellipsoid properties will automatically be undefined. If datumId or datum is defined then attempts to set ellipsoidId or ellipsoid\n *  will fail silently, the values remaining undefined. The ellipsoidId will not be a repeat of the ellipsoidId property part of the\n *  geodetic datum definition.\n *  @public\n */\nexport class HorizontalCRS {\n    constructor(_data) {\n        this.deprecated = false;\n        if (_data) {\n            this.id = _data.id;\n            this.description = _data.description;\n            this.source = _data.source;\n            this.deprecated = _data.deprecated ?? false;\n            this.epsg = _data.epsg;\n            this.datumId = _data.datumId;\n            this.datum = _data.datum ? GeodeticDatum.fromJSON(_data.datum) : undefined;\n            if (!this.datumId && !this.datum) {\n                this.ellipsoidId = _data.ellipsoidId;\n                this.ellipsoid = _data.ellipsoid ? GeodeticEllipsoid.fromJSON(_data.ellipsoid) : undefined;\n            }\n            this.unit = _data.unit;\n            this.projection = _data.projection ? Projection.fromJSON(_data.projection) : undefined;\n            this.extent = _data.extent ? HorizontalCRSExtent.fromJSON(_data.extent) : undefined;\n        }\n    }\n    /** Creates an Horizontal CRS from JSON representation.\n     * @public */\n    static fromJSON(data) {\n        return new HorizontalCRS(data);\n    }\n    /** Creates a JSON from the Horizontal CRS definition\n     * @public */\n    toJSON() {\n        const data = {};\n        data.id = this.id;\n        data.description = this.description;\n        data.source = this.source;\n        /* We prefer to use the default undef instead of false value for deprecated in Json */\n        if (this.deprecated)\n            data.deprecated = true;\n        data.epsg = this.epsg;\n        data.datumId = this.datumId;\n        if (this.datum)\n            data.datum = this.datum.toJSON();\n        data.ellipsoidId = this.ellipsoidId;\n        if (this.ellipsoid)\n            data.ellipsoid = this.ellipsoid.toJSON();\n        data.unit = this.unit;\n        if (this.projection)\n            data.projection = this.projection.toJSON();\n        if (this.extent)\n            data.extent = this.extent.toJSON();\n        return data;\n    }\n    /** Compares two horizontal CRS. It is not an equivalence test as descriptive properties are also compared\n     * but number compares are applied a minuscule tolerance.\n     *  @public */\n    equals(other) {\n        if (this.id !== other.id ||\n            this.description !== other.description ||\n            this.source !== other.source ||\n            this.deprecated !== other.deprecated ||\n            this.epsg !== other.epsg ||\n            this.datumId !== other.datumId ||\n            this.ellipsoidId !== other.ellipsoidId ||\n            this.unit !== other.unit)\n            return false;\n        if ((this.datum === undefined) !== (other.datum === undefined))\n            return false;\n        if (this.datum && !this.datum.equals(other.datum))\n            return false;\n        if ((this.ellipsoid === undefined) !== (other.ellipsoid === undefined))\n            return false;\n        if (this.ellipsoid && !this.ellipsoid.equals(other.ellipsoid))\n            return false;\n        if ((this.projection === undefined) !== (other.projection === undefined))\n            return false;\n        if (this.projection && !this.projection.equals(other.projection))\n            return false;\n        if ((this.extent === undefined) !== (other.extent === undefined))\n            return false;\n        if (this.extent && !this.extent.equals(other.extent))\n            return false;\n        return true;\n    }\n}\n/** Vertical Coordinate reference System implementation.\n *  The VerticalCRS contains currently a single identifier property of string type. Although\n *  we currently only support five distinct key values \"GEOID\", \"ELLIPSOID\", \"NAVD88\", \"NGVD29\" and \"LOCAL_ELLIPSOID\"\n *  we expect to support a broader set in the future including, eventually, user defined vertical CRS\n *  which will require additional parameters to be added.\n *  @public\n*/\nexport class VerticalCRS {\n    constructor(data) {\n        this.id = \"GEOID\";\n        if (data)\n            this.id = data.id;\n    }\n    /** Creates a Vertical CRS from JSON representation.\n     * @public */\n    static fromJSON(data) {\n        return new VerticalCRS(data);\n    }\n    /** Creates a JSON from the Vertical CRS definition\n     * @public */\n    toJSON() {\n        return { id: this.id };\n    }\n    /** Compares two vertical CRS.\n     *  @public */\n    equals(other) {\n        return (this.id === other.id);\n    }\n}\n/** Geographic Coordinate Reference System implementation. This is the class that indicates the definition of a Geographic\n *  coordinate reference system comprised of three components: Horizontal and Vertical and an optional additional transform.\n *  The vertical component (see [[VerticalCRS]]) is the simplest portion containing a simple identifier as a string.\n *  The optional additional transform of which, currently, only the type Helmert 2D with Z offset [[Helmert2DWithZOffset]] is supported\n *  defines a transformation of x,y, and z cartesian coordinate of the projection to the final\n *  Geographic Coordinate Reference System cartesian coordinates.\n *  The horizontal component contains a list of identification and documentation properties as well as\n *  defining details possibly including the projection with method and parameters, the definition of the datum, ellipsoid, extent and so on.\n *  The principle of describing a Geographic CRS is that the definition may be incomplete. The whole set of classes related to geographic\n *  coordinate reference system classes ([[GeodeticEllipsoid]], [[GeodeticDatum]], [[Projection]], [[GeodeticTransform]], ...) are designed\n *  so that they can be parsed from incomplete JSON fragments, or produce incomplete JSON fragments such as would be\n *  generated from a request to a REST API to a server when select OData clauses are used.\n *  Often GeographicCRS would knowingly be created incomplete but with sufficient information to perform conversion from some\n *  reprojection engine (the present set of classes do not provide any GeographicCRS conversion).\n *  For example the following definitions are quite sufficient to request conversion to or from by a reprojection engine:\n *  { horizontalCRS: {id: \"LL84\"}, verticalCRS: {id:\"GEOID\"}\n *  or\n *  { horizontalCRS: {datumId: \"WGS84\", projection: {method: \"None\"}}, verticalCRS: \"ELLIPSOID\"}\n *  The reprojection engine will use the engine internal dictionary to obtain the details if it can.\n *  Some definitions will originate from other sources (a parsed WKT for example) and the reprojection engine will require\n *  all mathematical and operational details to perform any conversion (descriptive information are ignored in the conversion process).\n *  @note see important detailed explanation in the [[HorizontalCRS]], [[VerticalCRS]] and [[AdditionalTransform]] documentation.\n *  @note Earth Centered, Earth Fixed coordinate system (ECEF) is a full 3D cartesian system that unambiguously\n *        expressed coordinates relative to the Earth Center. Since there is no horizontal portion independent from\n *        the vertical portion this system cannot be represented by a GeographicCRS and remains a separate concept.\n *  @public\n*/\nexport class GeographicCRS {\n    constructor(data) {\n        if (data) {\n            this.horizontalCRS = data.horizontalCRS ? HorizontalCRS.fromJSON(data.horizontalCRS) : undefined;\n            this.verticalCRS = data.verticalCRS ? VerticalCRS.fromJSON(data.verticalCRS) : undefined;\n            this.additionalTransform = data.additionalTransform ? AdditionalTransform.fromJSON(data.additionalTransform) : undefined;\n        }\n    }\n    /** Creates a Geographic CRS from JSON representation.\n     * @public */\n    static fromJSON(data) {\n        return new GeographicCRS(data);\n    }\n    /** Creates a JSON from the Geographic CRS definition\n     * @public */\n    toJSON() {\n        const data = {};\n        if (this.horizontalCRS)\n            data.horizontalCRS = this.horizontalCRS.toJSON();\n        if (this.verticalCRS)\n            data.verticalCRS = this.verticalCRS.toJSON();\n        if (this.additionalTransform)\n            data.additionalTransform = this.additionalTransform.toJSON();\n        return data;\n    }\n    /** Compares two Geographic CRS. It is a strict compare operation not an equivalence test though\n     * number compares are applied a minuscule tolerance.\n     * It takes into account descriptive properties not only mathematical definition properties.\n     * @public\n     */\n    equals(other) {\n        if ((this.horizontalCRS === undefined) !== (other.horizontalCRS === undefined))\n            return false;\n        if (this.horizontalCRS && !this.horizontalCRS.equals(other.horizontalCRS))\n            return false;\n        if ((this.verticalCRS === undefined) !== (other.verticalCRS === undefined))\n            return false;\n        if (this.verticalCRS && !this.verticalCRS.equals(other.verticalCRS))\n            return false;\n        if ((this.additionalTransform === undefined) !== (other.additionalTransform === undefined))\n            return false;\n        if (this.additionalTransform && !this.additionalTransform.equals(other.additionalTransform))\n            return false;\n        return true;\n    }\n}\n//# sourceMappingURL=CoordinateReferenceSystem.js.map",
      "start": 1693508120771,
      "end": 1693508120827,
      "sourcemaps": null
    }
  ]
}
