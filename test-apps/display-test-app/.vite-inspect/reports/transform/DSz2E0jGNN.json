{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/common/lib/esm/FeatureTable.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Rendering\n */\nimport { assert, compareNumbers, compareStrings, Id64, IndexedValue, IndexMap, } from \"@itwin/core-bentley\";\nimport { GeometryClass } from \"./GeometryParams\";\n/** Describes a discrete entity within a batched [RenderGraphic]($frontend) that can be\n * grouped with other such entities in a [[FeatureTable]].\n * Features roughly correlate to elements: a [Tile]($frontend)'s graphics combines geometry from every\n * [GeometricElement]($backend) that intersects the tile's volume, so each element produces at least one feature.\n * However, an element's geometry stream can contain geometry belonging to multiple different combinations of [SubCategory]($backend) and\n * [[GeometryClass]], so an individual element may produce more than one feature.\n * @see [[FeatureOverrides]] for customizing the appearance of individual features.\n * @public\n */\nexport class Feature {\n    constructor(elementId = Id64.invalid, subCategoryId = Id64.invalid, geometryClass = GeometryClass.Primary) {\n        this.elementId = elementId;\n        this.subCategoryId = subCategoryId;\n        this.geometryClass = geometryClass;\n    }\n    get isDefined() { return !Id64.isInvalid(this.elementId) || !Id64.isInvalid(this.subCategoryId) || this.geometryClass !== GeometryClass.Primary; }\n    get isUndefined() { return !this.isDefined; }\n    /** Returns true if this feature is equivalent to the supplied feature. */\n    equals(other) { return 0 === this.compare(other); }\n    /** Performs ordinal comparison of this feature with another.\n     * @param rhs The feature to compare with.\n     * @returns zero if the features are equivalent, a negative value if this feature compares as \"less than\" `rhs`, or a positive value if this feature compares \"greater than\" `rhs`.\n     */\n    compare(rhs) {\n        if (this === rhs)\n            return 0;\n        let cmp = compareNumbers(this.geometryClass, rhs.geometryClass);\n        if (0 === cmp) {\n            cmp = compareStrings(this.elementId, rhs.elementId);\n            if (0 === cmp) {\n                cmp = compareStrings(this.subCategoryId, rhs.subCategoryId);\n            }\n        }\n        return cmp;\n    }\n}\n/** @public */\nexport var ModelFeature;\n(function (ModelFeature) {\n    /** Create a ModelFeature of [[GeometryClass.Primary]] with all invalid Ids.\n     * This is primarily useful for creating a `result` argument for [[RenderFeatureTable.findFeature]] and [[RenderFeatureTable.getFeature]].\n     */\n    function create() {\n        return {\n            modelId: Id64.invalid,\n            elementId: Id64.invalid,\n            subCategoryId: Id64.invalid,\n            geometryClass: GeometryClass.Primary,\n        };\n    }\n    ModelFeature.create = create;\n    /** Returns `true` if any of `feature`'s properties differ from the defaults (invalid Ids and [[GeometryClass.Primary]]). */\n    function isDefined(feature) {\n        return !Id64.isInvalid(feature.modelId) || !Id64.isInvalid(feature.elementId) || !Id64.isInvalid(feature.subCategoryId) || feature.geometryClass !== GeometryClass.Primary;\n    }\n    ModelFeature.isDefined = isDefined;\n    /** @alpha */\n    function unpack(packed, result, unpackedModelId) {\n        result.modelId = unpackedModelId ?? Id64.fromUint32PairObject(packed.modelId);\n        result.elementId = Id64.fromUint32PairObject(packed.elementId);\n        result.subCategoryId = Id64.fromUint32PairObject(packed.subCategoryId);\n        result.geometryClass = packed.geometryClass;\n        return result;\n    }\n    ModelFeature.unpack = unpack;\n})(ModelFeature || (ModelFeature = {}));\n/** @public */\nexport var PackedFeature;\n(function (PackedFeature) {\n    /** Create a PackedFeature of [[GeometryClass.Primary]] with all invalid Ids.\n     * This is primarily useful for creating a `result` argument for [[RenderFeatureTable.getPackedFeature]].\n     */\n    function create() {\n        const pair = { upper: 0, lower: 0 };\n        return {\n            modelId: { ...pair },\n            elementId: { ...pair },\n            subCategoryId: { ...pair },\n            geometryClass: GeometryClass.Primary,\n            animationNodeId: 0,\n        };\n    }\n    PackedFeature.create = create;\n    /** Create a PackedFeatureWithIndex of [[GeometryClass.Primary]] with all invalid Ids and an index of zero.\n     * This is primarily useful for creating a reusable `output` argument for [[RenderFeatureTable.iterable]].\n     */\n    function createWithIndex() {\n        const result = create();\n        result.index = 0;\n        return result;\n    }\n    PackedFeature.createWithIndex = createWithIndex;\n})(PackedFeature || (PackedFeature = {}));\n/** Describes the type of a 'batch' of graphics representing multiple [[Feature]]s.\n * The most commonly-encountered batches are Tiles, which can be of either Primary or\n * Classifier type.\n * @public\n * @extensions\n */\nexport var BatchType;\n(function (BatchType) {\n    /** This batch contains graphics derived from a model's visible geometry. */\n    BatchType[BatchType[\"Primary\"] = 0] = \"Primary\";\n    /**\n     * This batch contains color volumes which are used to classify a model's visible geometry.\n     * The graphics themselves are not rendered to the screen; instead they are rendered to the stencil buffer\n     * to resymbolize the primary geometry.\n     */\n    BatchType[BatchType[\"VolumeClassifier\"] = 1] = \"VolumeClassifier\";\n    /**\n     * This batch contains planar graphics which are used to classify a model's visible geometry.\n     * The graphics themselves are not rendered to the screen; instead they are rendered to a texture buffer\n     * to resymbolize the primary geometry.\n     */\n    BatchType[BatchType[\"PlanarClassifier\"] = 2] = \"PlanarClassifier\";\n})(BatchType || (BatchType = {}));\n/** Defines a look-up table for [[Feature]]s within a batched [RenderGraphic]($frontend). Consecutive 32-bit\n * indices are assigned to each unique Feature. Primitives within the RenderGraphic can\n * use per-vertex indices to specify the distribution of Features within the primitive. The appearance of individual\n * features can be customized using [[FeatureOverrides]]. Typically a [Tile]($frontend) will contain a feature table\n * identifying the elements whose geometry appears within that tile.\n * @see [[FeatureOverrides]] for customizing the appearance of individual features.\n * @public\n */\nexport class FeatureTable extends IndexMap {\n    /** Construct an empty FeatureTable. */\n    constructor(maxFeatures, modelId = Id64.invalid, type = BatchType.Primary) {\n        super((lhs, rhs) => lhs.compare(rhs), maxFeatures);\n        this.modelId = modelId;\n        this.type = type;\n    }\n    /** Returns the maximum number of [[Feature]]s this FeatureTable can contain. */\n    get maxFeatures() { return this._maximumSize; }\n    /** @internal */\n    get anyDefined() { return this.length > 1 || (1 === this.length && this._array[0].value.isDefined); }\n    /** Returns true if this FeatureTable contains exactly one [[Feature]]. */\n    get isUniform() { return 1 === this.length; }\n    /** If this FeatureTable contains exactly one [[Feature]], returns that Feature; otherwise returns undefined. */\n    get uniform() { return 1 === this.length ? this._array[0].value : undefined; }\n    /** Returns true if this FeatureTable is associated with [[BatchType.VolumeClassifier]] geometry. */\n    get isVolumeClassifier() { return BatchType.VolumeClassifier === this.type; }\n    /** Returns true if this FeatureTable is associated with [[BatchType.PlanarClassifier]] geometry. */\n    get isPlanarClassifier() { return BatchType.PlanarClassifier === this.type; }\n    /** Returns the Feature corresponding to the specified index, or undefined if the index is not present. */\n    findFeature(index) {\n        for (const entry of this._array)\n            if (entry.index === index)\n                return entry.value;\n        return undefined;\n    }\n    /** @internal */\n    insertWithIndex(feature, index) {\n        const bound = this.lowerBound(feature);\n        assert(!bound.equal);\n        assert(!this.isFull);\n        const entry = new IndexedValue(feature, index);\n        this._array.splice(bound.index, 0, entry);\n    }\n    /** @internal */\n    getArray() { return this._array; }\n    /** Convert this feature table to a representation that can be supplied to [RenderSystem.createBatch]($frontend). */\n    pack() {\n        return PackedFeatureTable.pack(this);\n    }\n}\nconst scratchPackedFeature = PackedFeature.create();\nfunction populateAnimationNodeIds(table, computeNodeId, maxNodeId) {\n    assert(maxNodeId > 0);\n    let nodeIds;\n    const outputFeature = PackedFeature.createWithIndex();\n    for (const feature of table.iterable(outputFeature)) {\n        const nodeId = computeNodeId(feature);\n        assert(nodeId <= maxNodeId);\n        if (0 !== nodeId) {\n            if (!nodeIds) {\n                const size = table.numFeatures;\n                nodeIds = maxNodeId < 0x100 ? new Uint8Array(size) : (maxNodeId < 0x10000 ? new Uint16Array(size) : new Uint32Array(size));\n            }\n            nodeIds[feature.index] = nodeId;\n        }\n    }\n    return nodeIds;\n}\n/**\n * An immutable, packed representation of a [[FeatureTable]]. The features are packed into a single array of 32-bit integer values,\n * wherein each feature occupies 3 32-bit integers.\n * @internal\n */\nexport class PackedFeatureTable {\n    get byteLength() { return this._data.byteLength; }\n    /** Construct a PackedFeatureTable from the packed binary data.\n     * This is used internally when deserializing Tiles in iMdl format.\n     * @internal\n     */\n    constructor(data, modelId, numFeatures, type, animationNodeIds) {\n        this._data = data;\n        this.batchModelId = modelId;\n        this.batchModelIdPair = Id64.getUint32Pair(modelId);\n        this.numFeatures = numFeatures;\n        this.type = type;\n        this.animationNodeIds = animationNodeIds;\n        switch (this.numFeatures) {\n            case 0:\n                this.anyDefined = false;\n                break;\n            case 1:\n                this.anyDefined = ModelFeature.isDefined(this.getFeature(0, ModelFeature.create()));\n                break;\n            default:\n                this.anyDefined = true;\n                break;\n        }\n        assert(this._data.length >= this._subCategoriesOffset);\n        assert(undefined === this.animationNodeIds || this.animationNodeIds.length === this.numFeatures);\n    }\n    /** Create a packed feature table from a [[FeatureTable]]. */\n    static pack(featureTable) {\n        // We must determine how many subcategories we have ahead of time to compute the size of the Uint32Array, as\n        // the array cannot be resized after it is created.\n        // We are not too worried about this as FeatureTables created on the front-end will contain few if any features; those obtained from the\n        // back-end arrive within tiles already in the packed format.\n        const subcategories = new Map();\n        for (const iv of featureTable.getArray()) {\n            const found = subcategories.get(iv.value.subCategoryId.toString());\n            if (undefined === found)\n                subcategories.set(iv.value.subCategoryId, subcategories.size);\n        }\n        // We need 3 32-bit integers per feature, plus 2 32-bit integers per subcategory.\n        const subCategoriesOffset = 3 * featureTable.length;\n        const nUint32s = subCategoriesOffset + 2 * subcategories.size;\n        const uint32s = new Uint32Array(nUint32s);\n        for (const iv of featureTable.getArray()) {\n            const feature = iv.value;\n            const index = iv.index * 3;\n            let subCategoryIndex = subcategories.get(feature.subCategoryId);\n            assert(undefined !== subCategoryIndex); // we inserted it above...\n            subCategoryIndex |= (feature.geometryClass << 24);\n            uint32s[index + 0] = Id64.getLowerUint32(feature.elementId);\n            uint32s[index + 1] = Id64.getUpperUint32(feature.elementId);\n            uint32s[index + 2] = subCategoryIndex;\n        }\n        subcategories.forEach((index, id, _map) => {\n            const index32 = subCategoriesOffset + 2 * index;\n            uint32s[index32 + 0] = Id64.getLowerUint32(id);\n            uint32s[index32 + 1] = Id64.getUpperUint32(id);\n        });\n        return new PackedFeatureTable(uint32s, featureTable.modelId, featureTable.length, featureTable.type);\n    }\n    /** Retrieve the Feature associated with the specified index. */\n    getFeature(featureIndex, result) {\n        const packed = this.getPackedFeature(featureIndex, scratchPackedFeature);\n        return ModelFeature.unpack(packed, result, this.batchModelId);\n    }\n    /** Returns the Feature associated with the specified index, or undefined if the index is out of range. */\n    findFeature(featureIndex, result) {\n        return featureIndex < this.numFeatures ? this.getFeature(featureIndex, result) : undefined;\n    }\n    /** @internal */\n    getElementIdPair(featureIndex, out) {\n        out = out ?? { lower: 0, upper: 0 };\n        assert(featureIndex < this.numFeatures);\n        const offset = 3 * featureIndex;\n        out.lower = this._data[offset];\n        out.upper = this._data[offset + 1];\n        return out;\n    }\n    /** @internal */\n    getSubCategoryIdPair(featureIndex) {\n        const index = 3 * featureIndex;\n        let subCatIndex = this._data[index + 2];\n        subCatIndex = (subCatIndex & 0x00ffffff) >>> 0;\n        subCatIndex = subCatIndex * 2 + this._subCategoriesOffset;\n        return { lower: this._data[subCatIndex], upper: this._data[subCatIndex + 1] };\n    }\n    /** @internal */\n    getAnimationNodeId(featureIndex) {\n        return undefined !== this.animationNodeIds && featureIndex < this.numFeatures ? this.animationNodeIds[featureIndex] : 0;\n    }\n    /** @internal */\n    getPackedFeature(featureIndex, result) {\n        assert(featureIndex < this.numFeatures);\n        const index32 = 3 * featureIndex;\n        result.elementId.lower = this._data[index32];\n        result.elementId.upper = this._data[index32 + 1];\n        const subCatIndexAndClass = this._data[index32 + 2];\n        result.geometryClass = (subCatIndexAndClass >>> 24) & 0xff;\n        let subCatIndex = (subCatIndexAndClass & 0x00ffffff) >>> 0;\n        subCatIndex = subCatIndex * 2 + this._subCategoriesOffset;\n        result.subCategoryId.lower = this._data[subCatIndex];\n        result.subCategoryId.upper = this._data[subCatIndex + 1];\n        result.animationNodeId = this.getAnimationNodeId(featureIndex);\n        result.modelId.lower = this.batchModelIdPair.lower;\n        result.modelId.upper = this.batchModelIdPair.upper;\n        return result;\n    }\n    /** Returns the element ID of the Feature associated with the specified index, or undefined if the index is out of range. */\n    findElementId(featureIndex) {\n        if (featureIndex >= this.numFeatures)\n            return undefined;\n        else\n            return this.readId(3 * featureIndex);\n    }\n    /** Return true if this table contains exactly 1 feature. */\n    get isUniform() { return 1 === this.numFeatures; }\n    /** If this table contains exactly 1 feature, return it. */\n    getUniform(result) {\n        return this.isUniform ? this.getFeature(0, result) : undefined;\n    }\n    get isVolumeClassifier() { return BatchType.VolumeClassifier === this.type; }\n    get isPlanarClassifier() { return BatchType.VolumeClassifier === this.type; }\n    get isClassifier() { return this.isVolumeClassifier || this.isPlanarClassifier; }\n    /** Unpack the features into a [[FeatureTable]]. */\n    unpack() {\n        const table = new FeatureTable(this.numFeatures, this.batchModelId);\n        const feature = ModelFeature.create();\n        for (let i = 0; i < this.numFeatures; i++) {\n            this.getFeature(i, feature);\n            table.insertWithIndex(new Feature(feature.elementId, feature.subCategoryId, feature.geometryClass), i);\n        }\n        return table;\n    }\n    populateAnimationNodeIds(computeNodeId, maxNodeId) {\n        assert(undefined === this.animationNodeIds);\n        this.animationNodeIds = populateAnimationNodeIds(this, computeNodeId, maxNodeId);\n    }\n    *iterator(output) {\n        for (let i = 0; i < this.numFeatures; i++) {\n            this.getPackedFeature(i, output);\n            output.index = i;\n            yield output;\n        }\n    }\n    iterable(output) {\n        return {\n            [Symbol.iterator]: () => this.iterator(output),\n        };\n    }\n    get _subCategoriesOffset() { return this.numFeatures * 3; }\n    readId(offset32) {\n        return Id64.fromUint32Pair(this._data[offset32], this._data[offset32 + 1]);\n    }\n}\nconst scratchPackedFeatureModelEntry = { lastFeatureIndex: -1, idLower: -1, idUpper: -1 };\n/** A table of model Ids associated with a [[MultiModelPackedFeatureTable]].\n * The feature indices in the packed feature table are grouped together by model, such that the first N features belong to model 1, the next M features to model 2, and so on.\n * The model table itself consists of one entry per model, where each entry looks like:\n *  indexOfLastFeatureInModel: u32\n *  modelId: u64\n * The modelId associated with a feature can therefore be derived by finding the entry in the model table with the highest indexOfLastFeatureInModel no greater than the feature index.\n * This lookup can be optimized using binary search.\n * Moreover, while iterating the feature table in sequence, the model table can be iterated in parallel so that no per-feature lookup of model Id is required.\n * @internal\n */\nexport class PackedFeatureModelTable {\n    constructor(data) {\n        this._data = data;\n        assert(this._data.length % 3 === 0);\n    }\n    /** The number of models in the table. */\n    get length() {\n        return this._data.length / 3;\n    }\n    get byteLength() {\n        return this._data.byteLength;\n    }\n    getLastFeatureIndex(modelIndex) {\n        return this._data[modelIndex * 3];\n    }\n    getEntry(modelIndex, result) {\n        if (modelIndex >= this.length) {\n            result.idLower = result.idUpper = 0;\n            result.lastFeatureIndex = Number.MAX_SAFE_INTEGER;\n            return result;\n        }\n        const index = modelIndex * 3;\n        result.lastFeatureIndex = this._data[index + 0];\n        result.idLower = this._data[index + 1];\n        result.idUpper = this._data[index + 2];\n        return result;\n    }\n    /** Get the Id of the model associated with the specified feature, or an invalid Id if the feature is not associated with any model. */\n    getModelIdPair(featureIndex, result) {\n        if (!result)\n            result = { lower: 0, upper: 0 };\n        else\n            result.lower = result.upper = 0;\n        let first = 0;\n        const last = this.length;\n        let count = last;\n        while (count > 0) {\n            const step = Math.floor(count / 2);\n            const mid = first + step;\n            const lastFeatureIndex = this.getLastFeatureIndex(mid);\n            if (featureIndex > lastFeatureIndex) {\n                first = mid + 1;\n                count -= step + 1;\n            }\n            else {\n                count = step;\n            }\n        }\n        if (first < last) {\n            result.lower = this._data[first * 3 + 1];\n            result.upper = this._data[first * 3 + 2];\n        }\n        return result;\n    }\n}\n/** A PackedFeatureTable with a PackedFeatureModelTable appended to it, capable of storing features belonging to more than one model.\n * @internal\n */\nexport class MultiModelPackedFeatureTable {\n    constructor(features, models) {\n        this._features = features;\n        this._models = models;\n    }\n    static create(data, batchModelId, numFeatures, type, numSubCategories) {\n        const modelTableOffset = 3 * numFeatures + 2 * numSubCategories;\n        const featureData = data.subarray(0, modelTableOffset);\n        const features = new PackedFeatureTable(featureData, batchModelId, numFeatures, type);\n        const modelData = data.subarray(modelTableOffset);\n        const models = new PackedFeatureModelTable(modelData);\n        return new MultiModelPackedFeatureTable(features, models);\n    }\n    get batchModelId() { return this._features.batchModelId; }\n    get batchModelIdPair() { return this._features.batchModelIdPair; }\n    get numFeatures() { return this._features.numFeatures; }\n    get type() { return this._features.type; }\n    get animationNodeIds() { return this._features.animationNodeIds; }\n    set animationNodeIds(ids) { this._features.animationNodeIds = ids; }\n    get byteLength() {\n        return this._features.byteLength + this._models.byteLength;\n    }\n    getPackedFeature(featureIndex, result) {\n        this._features.getPackedFeature(featureIndex, result);\n        this._models.getModelIdPair(featureIndex, result.modelId);\n        return result;\n    }\n    getFeature(featureIndex, result) {\n        const packed = this.getPackedFeature(featureIndex, scratchPackedFeature);\n        return ModelFeature.unpack(packed, result);\n    }\n    findFeature(featureIndex, result) {\n        return featureIndex < this.numFeatures ? this.getFeature(featureIndex, result) : undefined;\n    }\n    getElementIdPair(featureIndex, out) {\n        return this._features.getElementIdPair(featureIndex, out);\n    }\n    findElementId(featureIndex) {\n        return this._features.findElementId(featureIndex);\n    }\n    *iterator(output) {\n        // Rather than perform a binary search on the model table to find each feature's model Id, traverse the model table in parallel with the feature table.\n        let modelIndex = 0;\n        const modelEntry = this._models.getEntry(modelIndex, scratchPackedFeatureModelEntry);\n        for (let featureIndex = 0; featureIndex < this.numFeatures; featureIndex++) {\n            if (featureIndex > modelEntry.lastFeatureIndex)\n                this._models.getEntry(++modelIndex, modelEntry);\n            this._features.getPackedFeature(featureIndex, output);\n            output.modelId.lower = modelEntry.idLower;\n            output.modelId.upper = modelEntry.idUpper;\n            output.index = featureIndex;\n            yield output;\n        }\n    }\n    iterable(output) {\n        return {\n            [Symbol.iterator]: () => this.iterator(output),\n        };\n    }\n    getAnimationNodeId(featureIndex) {\n        return this._features.getAnimationNodeId(featureIndex);\n    }\n    populateAnimationNodeIds(computeNodeId, maxNodeId) {\n        this._features.animationNodeIds = populateAnimationNodeIds(this, computeNodeId, maxNodeId);\n    }\n}\n//# sourceMappingURL=FeatureTable.js.map",
      "start": 1693508120729,
      "end": 1693508120799,
      "sourcemaps": null
    }
  ]
}
