{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/bspline/AkimaCurve3d.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Bspline\n */\nimport { Geometry } from \"../Geometry\";\nimport { Point3dArray } from \"../geometry3d/PointHelpers\";\nimport { ProxyCurve } from \"../curve/ProxyCurve\";\nimport { BSplineCurve3d } from \"./BSplineCurve\";\n/**\n * fitPoints and end condition data for [[AkimaCurve3d]]\n * * This is a \"typed object\" version of the serializer-friendly [[AkimaCurve3dProps]]\n * * Typical use cases rarely require all parameters, so the constructor does not itemize them as parameters.\n * @public\n */\nexport class AkimaCurve3dOptions {\n    /**\n     *\n     * @param fitPoints points to CAPTURE\n     * @param knots array to CAPTURE\n     */\n    constructor(fitPoints) {\n        this.fitPoints = fitPoints ? fitPoints : [];\n    }\n    /** Points that the curve must pass through.\n     * First and last 2 points are \"beyond the end\" for control of end slope.\n    fitPoints: Point3d[];\n   \n   /** Clone with strongly typed members reduced to simple json. */\n    cloneAsAkimaCurve3dProps() {\n        const props = {\n            fitPoints: Point3dArray.cloneDeepJSONNumberArrays(this.fitPoints),\n        };\n        return props;\n    }\n    /** Clone with strongly typed members reduced to simple json. */\n    clone() {\n        const clone = new AkimaCurve3dOptions(Point3dArray.clonePoint3dArray(this.fitPoints));\n        return clone;\n    }\n    /** Clone with strongly typed members reduced to simple json. */\n    static create(source) {\n        const result = new AkimaCurve3dOptions(Point3dArray.clonePoint3dArray(source.fitPoints));\n        return result;\n    }\n    static areAlmostEqual(dataA, dataB) {\n        if (dataA === undefined && dataB === undefined)\n            return true;\n        if (dataA !== undefined && dataB !== undefined) {\n            return Geometry.almostEqualArrays(dataA.fitPoints, dataB.fitPoints, (a, b) => a.isAlmostEqual(b));\n        }\n        return false;\n    }\n}\n/**\n * Interpolating curve.\n * * Derive from [[ProxyCurve]]\n * * Use a [[BSplineCurve3d]] as the proxy\n * *\n * @public\n */\nexport class AkimaCurve3d extends ProxyCurve {\n    /**\n     * CAPTURE properties and proxy curve.\n     */\n    constructor(properties, proxyCurve) {\n        super(proxyCurve);\n        this.curvePrimitiveType = \"interpolationCurve\";\n        this._options = properties;\n    }\n    dispatchToGeometryHandler(handler) {\n        return handler.handleAkimaCurve3d(this);\n    }\n    /**\n     * Create an [[AkimaCurve3d]] based on points, knots, and other properties in the [[AkimaCurve3dProps]] or [[AkimaCurve3dOptions]].\n     * * This saves a COPY OF the options or props.\n     * * Use createCapture () if the options or props can be used without copy\n     */\n    static create(options) {\n        let optionsCopy;\n        if (options instanceof AkimaCurve3dOptions) {\n            optionsCopy = options.clone();\n        }\n        else {\n            optionsCopy = AkimaCurve3dOptions.create(options);\n        }\n        return AkimaCurve3d.createCapture(optionsCopy);\n    }\n    static createCapture(options) {\n        const proxyCurve = BSplineCurve3d.createFromAkimaCurve3dOptions(options);\n        if (proxyCurve)\n            return new AkimaCurve3d(options, proxyCurve);\n        return undefined;\n    }\n    /** Return a (copy of) the defining points, packed as a Float64Array */\n    copyFitPointsFloat64Array() {\n        return Point3dArray.cloneXYZPropsAsFloat64Array(this._options.fitPoints);\n    }\n    /**\n     * Return json key-value pairs for for this [[AkimaCurve3d]].\n     * @returns\n     */\n    toJSON() {\n        return this._options.cloneAsAkimaCurve3dProps();\n    }\n    /** Clone the [[AkimaCurve3dProps]] object in this [[AkimaCurve3dProps]] */\n    cloneProps() {\n        return this._options.cloneAsAkimaCurve3dProps();\n    }\n    /**\n     * Reverse the curve direction.\n     * * This updates both the defining properties and the proxy bspline.\n     */\n    reverseInPlace() {\n        this._proxyCurve.reverseInPlace();\n        this._options.fitPoints.reverse();\n    }\n    /**\n     * Transform this [[AkimaCurve3d]] and its defining data in place\n     */\n    tryTransformInPlace(transform) {\n        const proxyOk = this._proxyCurve.tryTransformInPlace(transform);\n        if (proxyOk) {\n            transform.multiplyPoint3dArray(this._options.fitPoints);\n        }\n        return proxyOk;\n    }\n    /** Return a deep clone */\n    clone() {\n        return new AkimaCurve3d(this._options.clone(), this._proxyCurve.clone());\n    }\n    /** Test if `other` is also an [[AkimaCurve3d]] */\n    isSameGeometryClass(other) { return other instanceof AkimaCurve3d; }\n    isAlmostEqual(other) {\n        if (other instanceof AkimaCurve3d) {\n            return AkimaCurve3dOptions.areAlmostEqual(this._options, other._options);\n        }\n        return false;\n    }\n}\n//# sourceMappingURL=AkimaCurve3d.js.map",
      "start": 1693508123811,
      "end": 1693508123937,
      "sourcemaps": null
    }
  ]
}
