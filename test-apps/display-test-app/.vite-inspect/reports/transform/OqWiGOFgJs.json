{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/curve/ConstructCurveBetweenCurves.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Curve\n */\nimport { Geometry } from \"../Geometry\";\nimport { NullGeometryHandler } from \"../geometry3d/GeometryHandler\";\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\nimport { Arc3d } from \"./Arc3d\";\nimport { LineSegment3d } from \"./LineSegment3d\";\nimport { LineString3d } from \"./LineString3d\";\n/**\n * Context for constructing a curve that is interpolated between two other curves.\n * * The only callable method is the static `InterpolateBetween`.\n * * Other methods are called only by `dispatchToGeometryHandler`\n * @public\n */\nexport class ConstructCurveBetweenCurves extends NullGeometryHandler {\n    constructor(_geometry0, _fraction, _geometry1) {\n        super();\n        // this.geometry0 = _geometry0;   <-- Never used\n        this._geometry1 = _geometry1;\n        this._fraction = _fraction;\n    }\n    /**\n     * * To be directly called only by double dispatcher\n     * * Assumes this.geometry1 was set by calling context.\n     * * Construct the interpolated curve between this.geometry1 and the supplied segment0.\n     */\n    handleLineSegment3d(segment0) {\n        if (this._geometry1 instanceof LineSegment3d) {\n            const segment1 = this._geometry1;\n            return LineSegment3d.create(segment0.startPoint().interpolate(this._fraction, segment1.startPoint()), segment0.endPoint().interpolate(this._fraction, segment1.endPoint()));\n        }\n        return undefined;\n    }\n    /**\n     * * To be directly called only by double dispatcher\n     * * Assumes this.geometry1 was set by calling context.\n     * * Construct the interpolated curve between this.geometry1 and the supplied ls0.\n     */\n    handleLineString3d(ls0) {\n        if (this._geometry1 instanceof LineString3d) {\n            const ls1 = this._geometry1;\n            if (ls0.numPoints() === ls1.numPoints()) {\n                const numPoints = ls0.numPoints();\n                const ls = LineString3d.create();\n                const workPoint = Point3d.create();\n                const workPoint0 = Point3d.create();\n                const workPoint1 = Point3d.create();\n                const fraction = this._fraction;\n                for (let i = 0; i < numPoints; i++) {\n                    ls0.pointAt(i, workPoint0);\n                    ls1.pointAt(i, workPoint1);\n                    workPoint0.interpolate(fraction, workPoint1, workPoint);\n                    ls.addPoint(workPoint);\n                }\n                if (ls0.fractions && ls1.fractions) {\n                    for (let i = 0; i < numPoints; i++) {\n                        ls.addFraction(Geometry.interpolate(ls0.fractions.atUncheckedIndex(i), fraction, ls1.fractions.atUncheckedIndex(i)));\n                    }\n                }\n                if (ls0.strokeData && ls1.strokeData) {\n                    // Policy: simple clone of stroke count map from ls0.\n                    // The curveLength will not match.\n                    // But we expect to be called at a time compatible count and a0,a1 are the important thing.\n                    ls.strokeData = ls0.strokeData.clone();\n                }\n                if (ls0.packedDerivatives && ls1.packedDerivatives) {\n                    const workVector0 = Vector3d.create();\n                    const workVector1 = Vector3d.create();\n                    for (let i = 0; i < numPoints; i++) {\n                        ls0.packedDerivatives.getVector3dAtCheckedVectorIndex(i, workVector0);\n                        ls1.packedDerivatives.getVector3dAtCheckedVectorIndex(i, workVector1);\n                        ls.addDerivative(workVector0.interpolate(fraction, workVector1));\n                    }\n                }\n                return ls;\n            }\n        }\n        return undefined;\n    }\n    /**\n     * * To be directly called only by double dispatcher\n     * * Assumes this.geometry1 was set by calling context.\n     * * Construct the interpolated curve between this.geometry1 and the supplied arc0.\n     */\n    handleArc3d(arc0) {\n        if (this._geometry1 instanceof Arc3d) {\n            const arc1 = this._geometry1;\n            return Arc3d.create(arc0.center.interpolate(this._fraction, arc1.center), arc0.vector0.interpolate(this._fraction, arc1.vector0), arc0.vector90.interpolate(this._fraction, arc1.vector90), arc0.sweep.interpolate(this._fraction, arc1.sweep));\n        }\n        return undefined;\n    }\n    /**\n     * Construct a geometry item which is fractionally interpolated between two others.\n     * * The construction is only supported between certain types:\n     * * * LineSegment3d+LineSegment3d -- endpoints are interpolated\n     * * * LineString3d+LineString3d with matching counts.  Each point is interpolated.\n     * * * Arc3d+Arc3d -- center, vector0, vector90, and limit angles of the sweep are interpolated.\n     * @param geometry0 geometry \"at fraction 0\"\n     * @param fraction  fractional position\n     * @param geometry1 geometry \"at fraction 1\"\n     */\n    static interpolateBetween(geometry0, fraction, geometry1) {\n        const handler = new ConstructCurveBetweenCurves(geometry0, fraction, geometry1);\n        return geometry0.dispatchToGeometryHandler(handler);\n    }\n}\n//# sourceMappingURL=ConstructCurveBetweenCurves.js.map",
      "start": 1693508123507,
      "end": 1693508123676,
      "sourcemaps": null
    }
  ]
}
