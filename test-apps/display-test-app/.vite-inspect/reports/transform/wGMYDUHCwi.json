{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/markup/lib/esm/Undo.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module MarkupTools\n */\nimport { assert } from \"@itwin/core-bentley\";\nimport { MarkupApp } from \"./Markup\";\n/* @internal */\nclass UndoAction {\n    constructor(cmdName) {\n        this.cmdName = cmdName;\n        this.cmdId = 0;\n    }\n}\n/** created when a new element is added to the markup\n * @internal\n */\nclass AddAction extends UndoAction {\n    constructor(cmdName, _elem) {\n        super(cmdName);\n        this._elem = _elem;\n        this._parent = _elem.parent();\n        assert(this._parent !== undefined);\n        this._index = _elem.position();\n    }\n    reinstate() { this._parent.add(this._elem, this._index); }\n    reverse() {\n        MarkupApp.markup.selected.drop(this._elem);\n        this._elem.remove();\n    }\n}\n/** created when an existing element is deleted from the markup\n * @internal\n */\nclass DeleteAction extends UndoAction {\n    constructor(cmdName, _elem) {\n        super(cmdName);\n        this._elem = _elem;\n        this._parent = _elem.parent();\n        assert(this._parent !== undefined);\n        this._index = _elem.position();\n    }\n    reverse() { this._parent.add(this._elem, this._index); }\n    reinstate() {\n        MarkupApp.markup.selected.drop(this._elem);\n        this._elem.remove();\n    }\n}\n/** created when an existing element's position is moved in the display order. This can also include re-parenting\n * @internal\n */\nclass RepositionAction extends UndoAction {\n    constructor(cmdName, _elem, _oldIndex, _oldParent) {\n        super(cmdName);\n        this._elem = _elem;\n        this._oldIndex = _oldIndex;\n        this._oldParent = _oldParent;\n        this._newParent = _elem.parent();\n        assert(this._newParent !== undefined);\n        this._newIndex = _elem.position();\n    }\n    reinstate() {\n        this._newParent.add(this._elem, this._newIndex);\n    }\n    reverse() {\n        this._oldParent.add(this._elem, this._oldIndex);\n        if (this._elem.inSelection)\n            MarkupApp.markup.selected.drop(this._elem);\n    }\n}\n/** created when an existing element's properties are modified.\n * @internal\n */\nclass ModifyAction extends UndoAction {\n    constructor(cmdName, _newElem, _oldElement) {\n        super(cmdName);\n        this._newElem = _newElem;\n        this._oldElement = _oldElement;\n        assert(_newElem !== undefined && _oldElement !== undefined);\n        MarkupApp.markup.selected.replace(_oldElement, _newElem);\n    }\n    reinstate() {\n        this._oldElement.replace(this._newElem);\n        MarkupApp.markup.selected.replace(this._oldElement, this._newElem);\n    }\n    reverse() {\n        this._newElem.replace(this._oldElement);\n        MarkupApp.markup.selected.replace(this._newElem, this._oldElement);\n    }\n}\n/** Stores the sequence of operations performed on a Markup. Facilitates undo/redo of the operations.\n * @public\n */\nexport class UndoManager {\n    constructor() {\n        this._currentCmd = 0;\n        this._grouped = 0;\n        this._stack = [];\n        this._currentPos = 0;\n        this._cmdName = \"\";\n    }\n    addAction(action) {\n        this._stack.length = this._currentPos;\n        action.cmdId = this._currentCmd;\n        this._stack.push(action);\n        this._currentPos = this.size;\n    }\n    /** @internal */\n    get size() { return this._stack.length; }\n    startCommand() {\n        if (0 === this._grouped)\n            ++this._currentCmd;\n    }\n    startGroup() {\n        this.startCommand();\n        ++this._grouped;\n    }\n    endGroup() { --this._grouped; }\n    /** Perform a series of changes to markup elements that should all be reversed as a single operation.\n     * @param fn the function that performs the changes to the elements. It must call the onXXX methods of this class to store\n     * the operations in the undo buffer.\n     * @note all of the onXXX methods of this class should *only* be called from within the callback function of this method.\n     */\n    performOperation(cmdName, fn) {\n        this._cmdName = cmdName;\n        this.startGroup();\n        fn();\n        this.endGroup();\n    }\n    /** call this from within a [[performOperation]] function *after* an element has been added to a markup */\n    onAdded(elem) { this.addAction(new AddAction(this._cmdName, elem)); }\n    /** call this from within a [[performOperation]] function *before* an element is about to be deleted from a markup */\n    onDelete(elem) { this.addAction(new DeleteAction(this._cmdName, elem)); }\n    /** call this from within a [[performOperation]] function *after* an element has been moved in display order in a markup */\n    onRepositioned(elem, oldIndex, oldParent) { this.addAction(new RepositionAction(this._cmdName, elem, oldIndex, oldParent)); }\n    /** call this from within a [[performOperation]] function *after* an element has been modified in a markup */\n    onModified(newElem, oldElem) { this.addAction(new ModifyAction(this._cmdName, newElem, oldElem)); }\n    /** determine whether there are any un-reversed operations */\n    get undoPossible() { return this._currentPos > 0; }\n    /** determine whether there are any reversed operations */\n    get redoPossible() { return this._currentPos < this.size; }\n    /** the name of the operation that can be undone (or undefined) */\n    get undoString() { return this.undoPossible ? this._stack[this._currentPos - 1].cmdName : undefined; }\n    /** the name of the operation that can be redone (or undefined) */\n    get redoString() { return this.redoPossible ? this._stack[this._currentPos].cmdName : undefined; }\n    /** reverse the most recent operation, if any */\n    doUndo() {\n        if (this._currentPos === 0)\n            return; // no operations have been performed\n        const cmdId = this._stack[this._currentPos - 1].cmdId;\n        while (this._currentPos > 0 && cmdId === this._stack[this._currentPos - 1].cmdId)\n            this._stack[--this._currentPos].reverse();\n    }\n    /** reinstate the most recently reversed operation, if any */\n    doRedo() {\n        if (this._currentPos === this.size)\n            return; // no operations have been reversed.\n        const cmdId = this._stack[this._currentPos].cmdId;\n        while (this._currentPos < this.size && cmdId === this._stack[this._currentPos].cmdId)\n            this._stack[this._currentPos++].reinstate();\n    }\n}\n//# sourceMappingURL=Undo.js.map",
      "start": 1693508125580,
      "end": 1693508125763,
      "sourcemaps": null
    }
  ]
}
