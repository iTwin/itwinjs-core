{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/orbitgt/lib/esm/pointcloud/format/opc/TileRecord.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module OrbitGT\n */\nimport { LittleEndian } from \"../../../system/buffer/LittleEndian\";\nimport { Numbers } from \"../../../system/runtime/Numbers\";\nimport { GridIndex } from \"../../model/GridIndex\";\nimport { TileIndex } from \"../../model/TileIndex\";\n/**\n * Class TileRecord defines a tile index record.\n *\n * @version 1.0 January 2014\n */\n/** @internal */\nclass TileRecord {\n    /**\n     * No instances.\n     */\n    constructor() {\n    }\n    /**\n     * Check if this tile has a certain index.\n     * @param tileX the tile x index.\n     * @param tileY the tile y index.\n     * @param tileZ the tile Z index.\n     * @return true if the tile has the index.\n     */\n    static isTile(tile, tileX, tileY, tileZ) {\n        return (tileX == tile.gridIndex.x && tileY == tile.gridIndex.y && tileZ == tile.gridIndex.z);\n    }\n    /**\n     * Check if this tile is located after a certain index.\n     * @param tileX the tile x index.\n     * @param tileY the tile y index.\n     * @param tileZ the tile Z index.\n     * @return true if the tile is after the index.\n     */\n    static isAfterTile(tile, tileX, tileY, tileZ) {\n        if (tile.gridIndex.x < tileX)\n            return false;\n        if (tile.gridIndex.x > tileX)\n            return true;\n        if (tile.gridIndex.y < tileY)\n            return false;\n        if (tile.gridIndex.y > tileY)\n            return true;\n        if (tile.gridIndex.z < tileZ)\n            return false;\n        if (tile.gridIndex.z > tileZ)\n            return true;\n        return false;\n    }\n    /**\n     * Check if this tile is located before a certain index.\n     * @param tileX the tile x index.\n     * @param tileY the tile y index.\n     * @param tileZ the tile Z index.\n     * @return true if the tile is before the index.\n     */\n    static isBeforeTile(tile, tileX, tileY, tileZ) {\n        if (tile.gridIndex.x < tileX)\n            return true;\n        if (tile.gridIndex.x > tileX)\n            return false;\n        if (tile.gridIndex.y < tileY)\n            return true;\n        if (tile.gridIndex.y > tileY)\n            return false;\n        if (tile.gridIndex.z < tileZ)\n            return true;\n        if (tile.gridIndex.z > tileZ)\n            return false;\n        return false;\n    }\n    /**\n     * Write a record.\n     * @param output the output stream.\n     */\n    static write(tile, output) {\n        let tileX = tile.gridIndex.x;\n        let tileY = tile.gridIndex.y;\n        let tileZ = tile.gridIndex.z;\n        LittleEndian.writeStreamInt(output, tileX);\n        LittleEndian.writeStreamInt(output, tileY);\n        LittleEndian.writeStreamInt(output, tileZ);\n        LittleEndian.writeStreamInt(output, tile.pointCount);\n    }\n    /**\n     * Read a record.\n     * @param tileGrid the grid.\n     * @param stream the data stream from the file.\n     * @param tileIndex the index of the tile.\n     * @param pointIndex the index of the first point in the tile.\n     * @return the requested record.\n     */\n    static readNew(level, tileGrid, stream, tileIndex, pointIndex) {\n        /* Read the record */\n        let tileX = LittleEndian.readStreamInt(stream);\n        let tileY = LittleEndian.readStreamInt(stream);\n        let tileZ = LittleEndian.readStreamInt(stream);\n        let pointCount = LittleEndian.readStreamInt(stream);\n        /* Create the record */\n        return new TileIndex(level, tileIndex, new GridIndex(tileX, tileY, tileZ), pointIndex, pointCount);\n    }\n    /**\n     * Read a record.\n     * @param in the input stream.\n     * @param tileIndex the index of the tile.\n     * @param pointIndex the index of the first point in the tile.\n     */\n    static read(tile, level, blockIndex, stream, tileIndex, pointIndex) {\n        tile.level = level;\n        tile.index = tileIndex;\n        tile.gridIndex.x = LittleEndian.readStreamInt(stream);\n        tile.gridIndex.y = LittleEndian.readStreamInt(stream);\n        tile.gridIndex.z = LittleEndian.readStreamInt(stream);\n        tile.pointCount = LittleEndian.readStreamInt(stream);\n        tile.pointIndex = pointIndex;\n    }\n    /**\n     * Get the squared distance to a grid cell.\n     * @param reference the reference point.\n     * @return the squared distance.\n     */\n    static distanceSq(tile, reference) {\n        let dx = (tile.gridIndex.x - reference.x);\n        let dy = (tile.gridIndex.y - reference.y);\n        let dz = (tile.gridIndex.z - reference.z);\n        return (dx * dx) + (dy * dy) + (dz * dz);\n    }\n    /**\n     * Get a next-level index.\n     * @param index the index at the current level.\n     * @return the next-level index.\n     */\n    static getNextLevelIndex1(index) {\n        if (index < 0)\n            return Numbers.divInt(index - 1, 2);\n        return Numbers.divInt(index, 2);\n    }\n    /**\n     * Get a next-level index.\n     * @param index the index at the current level.\n     * @return the next-level index.\n     */\n    static getNextLevelIndex(index) {\n        let nextX = TileRecord.getNextLevelIndex1(index.x);\n        let nextY = TileRecord.getNextLevelIndex1(index.y);\n        let nextZ = TileRecord.getNextLevelIndex1(index.z);\n        return new GridIndex(nextX, nextY, nextZ);\n    }\n}\n/** The size of the record in the file */\nTileRecord.RECORD_SIZE = 16;\nexport { TileRecord };\n//# sourceMappingURL=TileRecord.js.map",
      "start": 1693508127336,
      "end": 1693508127385,
      "sourcemaps": null
    }
  ]
}
