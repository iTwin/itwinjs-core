{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/curve/Query/StrokeCountChain.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Curve\n */\nimport { Geometry } from \"../../Geometry\";\nimport { Point3d } from \"../../geometry3d/Point3dVector3d\";\nimport { CurveChain } from \"../CurveCollection\";\nimport { LineString3d } from \"../LineString3d\";\nimport { Loop } from \"../Loop\";\nimport { ParityRegion } from \"../ParityRegion\";\nimport { StrokeCountMap } from \"./StrokeCountMap\";\n// cspell:word remapa\n/**\n * abstract methods for callbacks during sweeps of collections of StrokeCount Structures.\n * * A set of StrokeCountMaps are to be visited multiple times.\n * * The logic that controls the sweep is as below.\n * * The callback object controls the number of sweeps and can adapt its action to the respective sweeps.\n * * Note that a \"false\" from cb.startPass() terminates passes for this chainIndex and primitiveIndex, but all others exit the whole sequence.\n * * This logic occurs 2 or three levels deep\n *   * outer level is \"chains\".   Simple swept path or loops have only one outer; parity regions have one outer per loop of the parity region\n *   * second level is primitive within chain.\n *     * If the primitives in a set are \"single component\", second level is lowest.\n *        * startSweep() and endSweep() calls are two parameters, with undefined componentIndex\n *     * If the primitives in a set are multi-component, there is a third level looping through corresponding components.\n * `\n *    if (!cb.startSweeps (chainIndex, primitiveIndex, componentIndex))\n *      return false;\n *    for (let pass = 0;cb.startPass (pass); pass++){\n *      for (each map in working set)\n *            if (!cb.visit (pass, map)) return false;\n *       if (!cb.endPass ()) return false;\n *        }\n *      }\n * if (!cb.endSweeps (chainIndex, primitiveIndex, componentIndex)) return false;\n * return true;\n * `\n * @internal\n */\nexport class StrokeCountMapMultipassVisitor {\n    /**\n     * called to announce the beginning of one or more sweeps through related StrokeCountMap's\n     * @param chainIndex index of loop or path within the various contours.\n     * @param primitiveIndex index of primitive within the loop or path.\n     * @param componentIndex optional component index.\n     * @returns the number of sweeps to perform.\n     */\n    startSweeps(_chainIndex, _primitiveIndex, _componentIndex) { return true; }\n    /**\n     * announce the end of handling for particular chainIndex and primitiveIndex;\n     * @return true to continue outer loops.\n     */\n    endSweeps(_chainIndex, _primitiveIndex, _componentIndex) { return true; }\n}\n/**\n * * pass 1: determine max numStroke\n * * pass 2: impose max numStroke\n * @internal\n */\nexport class StrokeCountMapVisitorApplyMaxCount extends StrokeCountMapMultipassVisitor {\n    constructor() {\n        super();\n        this.myMap = StrokeCountMap.createWithComponentIndex();\n    }\n    /** set up for a pass through corresponding maps. */\n    startPass(pass) {\n        if (pass === 0) {\n            this.myMap.numStroke = 0;\n            return true;\n        }\n        else if (pass === 1) {\n            // nothing to change == numStroke will be applied to each primitive.\n            return true;\n        }\n        // all other pass numbers are rejected ...\n        return false;\n    }\n    /** visit one of the set of corresponding maps. */\n    visit(pass, map) {\n        if (pass === 0) {\n            if (map.numStroke > this.myMap.numStroke)\n                this.myMap.numStroke = map.numStroke;\n            return true;\n        }\n        else if (pass === 1) {\n            // apply the max from prior pass\n            map.numStroke = this.myMap.numStroke;\n            return true;\n        }\n        // no other pass values should happen -- canceled by startPass.\n        return false;\n    }\n    endPass(_pass) { return true; }\n}\n/**\n * * pass 1: determine max curveLength among maps presented.\n * * pass 2: set the a0 and a1 values to 0 and that max distance\n * @internal\n */\nexport class StrokeCountMapVisitorApplyMaxCurveLength extends StrokeCountMapMultipassVisitor {\n    constructor() {\n        super();\n        this.maxCurveLength = 0.0;\n    }\n    /** set up for a pass through corresponding maps. */\n    startPass(pass) {\n        if (pass === 0) {\n            this.maxCurveLength = 0;\n            return true;\n        }\n        else if (pass === 1) {\n            // nothing to change == numStroke will be applied to each primitive.\n            return true;\n        }\n        // all other pass numbers are rejected ...\n        return false;\n    }\n    /** visit one of the set of corresponding maps. */\n    visit(pass, map) {\n        if (pass === 0) {\n            this.maxCurveLength = Geometry.maxXY(map.curveLength, this.maxCurveLength);\n            return true;\n        }\n        else if (pass === 1) {\n            // apply the max from prior pass\n            map.a0 = 0.0;\n            map.a1 = this.maxCurveLength;\n            return true;\n        }\n        // no other pass values should happen -- canceled by startPass.\n        return false;\n    }\n    endPass(_pass) { return true; }\n}\n/**\n * class `StrokeCountChain` contains:\n * * `maps` = an array of `StrokeCountMap`\n * * `parent` = parent CurveCollection.\n *\n * An instance is normally created with either a `Path` or `Loop` as the parent.\n */\nexport class StrokeCountChain {\n    constructor(parent, options) {\n        this.parent = parent;\n        this.maps = [];\n        this.options = options;\n    }\n    static createForCurveChain(chain, options) {\n        const result = new StrokeCountChain(chain, options);\n        result.parent = chain;\n        // A chain can only contain primitives !!!!\n        for (const p of chain.children) {\n            p.computeAndAttachRecursiveStrokeCounts(options);\n            if (p.strokeData)\n                result.maps.push(p.strokeData);\n        }\n        return result;\n    }\n    getStrokes() {\n        const ls = LineString3d.create();\n        if (this.options) {\n            if (this.options.needNormals || this.options.needParams) {\n                ls.ensureEmptyFractions();\n                ls.ensureEmptyDerivatives();\n                ls.ensureEmptyUVParams();\n            }\n        }\n        for (const m of this.maps) {\n            if (m.primitive)\n                m.primitive.addMappedStrokesToLineString3D(m, ls);\n        }\n        return ls;\n    }\n    /** internal form of  */\n    static applySummed01LimitsWithinArray(maps, incomingSum) {\n        let movingSum = incomingSum;\n        for (const m of maps) {\n            m.a0 += movingSum;\n            if (m.componentData) {\n                m.a1 = this.applySummed01LimitsWithinArray(m.componentData, m.a0);\n            }\n            else {\n                m.a1 += movingSum;\n            }\n            movingSum = m.a1;\n        }\n        return movingSum;\n    }\n    /**\n     * walk the maps in the array.\n     * * in maps with no component data\n     *   * increment map.a0 and map.a1 by the incoming distance a0\n     * * in maps with component data:\n     *   * recurse through the component array.\n     *   * increment map.a0 by the incoming a0.\n     *   * returned a1 from the componentData array becomes a1\n     * @returns upper value of a1 in final map.\n     * @param maps\n     * @param incomingSum lower value to add to a0 for first map.\n     */\n    applySummed01Limits(incomingSum) {\n        return StrokeCountChain.applySummed01LimitsWithinArray(this.maps, incomingSum);\n    }\n}\n/**\n * class `StrokeCountSection`\\\n * * contains an array of `StrokeCountChain`.\n * * Hence it is the internal node level of a (1-level-deep) tree of `StrokeCountChain`\n * @internal\n */\nexport class StrokeCountSection {\n    constructor(parent) { this.parent = parent; this.chains = []; }\n    /**\n     * construct array of arrays of `StrokeCountMap`s\n     * @param parent\n     */\n    static createForParityRegionOrChain(parent, options) {\n        const result = new StrokeCountSection(parent);\n        if (parent instanceof ParityRegion) {\n            for (const child of parent.children) {\n                const p = StrokeCountChain.createForCurveChain(child, options);\n                result.chains.push(p);\n            }\n        }\n        else if (parent instanceof CurveChain) {\n            result.chains.push(StrokeCountChain.createForCurveChain(parent, options));\n        }\n        return result;\n    }\n    /** test if all sections have the same structure. */\n    static areSectionsCompatible(sections, enforceCounts) {\n        if (sections.length < 2)\n            return true; // hm.. don't know if that is useful, but nothing to check here.\n        const numChains = sections[0].chains.length;\n        for (let i = 1; i < sections.length; i++) {\n            // first level: must match number of paths or loops\n            if (sections[i].chains.length !== numChains)\n                return false;\n            // second level: must have same number of primitives in each path or loop\n            for (let j = 0; j < sections[0].chains.length; j++) {\n                const numPrimitive = sections[0].chains[j].maps.length;\n                if (sections[i].chains[j].maps.length !== numPrimitive)\n                    return false;\n                for (let k = 0; k < numPrimitive; k++) {\n                    if (!sections[0].chains[j].maps[k].isCompatibleComponentStructure(sections[i].chains[j].maps[k], enforceCounts))\n                        return false;\n                }\n            }\n        }\n        return true;\n    }\n    /** Within each section, sweep accumulate curveLength field, recording entry and exit sum in each map.\n     * * In expected use, (a0,a1) are (0,a) where a is the (previously computed) max length among corresponding maps up and down the section arrays.\n     */\n    static remapa0a1WithinEachChain(sections) {\n        for (const section of sections) {\n            for (const chain of section.chains) {\n                chain.applySummed01Limits(0.0);\n            }\n        }\n    }\n    static applyMultipassVisitorCallbackNoComponents(sections, chainIndex, primitiveIndex, componentIndex, callback) {\n        const numSection = sections.length;\n        if (!callback.startSweeps(chainIndex, primitiveIndex, componentIndex))\n            return false;\n        if (componentIndex === undefined) {\n            // there are corresponding primitives directly at the section, chain, primitive index:\n            for (let pass = 0;; pass++) {\n                if (!callback.startPass(pass))\n                    break;\n                for (let sectionIndex = 0; sectionIndex < numSection; sectionIndex++)\n                    if (!callback.visit(pass, sections[sectionIndex].chains[chainIndex].maps[primitiveIndex]))\n                        return false;\n                if (!callback.endPass(pass))\n                    return false;\n            }\n        }\n        else {\n            // there are corresponding primitives at the section, chain, primitive,componentIndex\n            // there are corresponding primitives directly at the section, chain, primitive index:\n            for (let pass = 0;; pass++) {\n                if (!callback.startPass(pass))\n                    break;\n                for (let sectionIndex = 0; sectionIndex < numSection; sectionIndex++)\n                    if (!callback.visit(pass, sections[sectionIndex].chains[chainIndex].maps[primitiveIndex].componentData[componentIndex]))\n                        return false;\n                if (!callback.endPass(pass))\n                    return false;\n            }\n        }\n        if (!callback.endSweeps(chainIndex, primitiveIndex, componentIndex))\n            return false;\n        return true;\n    }\n    /**\n     * Walk through the sections, emitting callbacks delimiting groups of corresponding primitives.\n     * @param sections array of sections (possibly a single path or loop at each section, or possibly a set of parity loops.)\n     * @param callback object to be notified during the traversal\n     */\n    static runMultiPassVisitorAtCorrespondingPrimitives(sections, callback) {\n        const numChainPerSection = sections[0].chains.length;\n        for (let chainIndex = 0; chainIndex < numChainPerSection; chainIndex++) {\n            const numPrimitive = sections[0].chains[chainIndex].maps.length;\n            for (let primitiveIndex = 0; primitiveIndex < numPrimitive; primitiveIndex++) {\n                if (sections[0].chains[chainIndex].maps[primitiveIndex].componentData) {\n                    const numComponent = sections[0].chains[chainIndex].maps[primitiveIndex].componentData.length;\n                    for (let i = 0; i < numComponent; i++)\n                        if (!this.applyMultipassVisitorCallbackNoComponents(sections, chainIndex, primitiveIndex, i, callback))\n                            return false;\n                }\n                else {\n                    if (!this.applyMultipassVisitorCallbackNoComponents(sections, chainIndex, primitiveIndex, undefined, callback))\n                        return false;\n                }\n            }\n        }\n        return true;\n    }\n    /**\n     * * Confirm that all sections in the array have the same structure.\n     * * Within each corresponding set of entries, apply the max count to all.\n     * @param sections array of per-section stroke count entries\n     */\n    static enforceStrokeCountCompatibility(sections) {\n        if (sections.length < 2)\n            return true;\n        if (!StrokeCountSection.areSectionsCompatible(sections, false))\n            return false;\n        const visitor = new StrokeCountMapVisitorApplyMaxCount();\n        this.runMultiPassVisitorAtCorrespondingPrimitives(sections, visitor);\n        return true;\n    }\n    /**\n     * * Confirm that all sections in the array have the same structure.\n     * * Within each corresponding set of entries up and down the sections, set curveLength as the maximum of the respective curve lengths.\n     * * Along each section, sum curveLengths (which were just reset) to get consistent along-chain parameters\n     * @param sections array of per-section stroke count entries\n     */\n    static enforceCompatibleDistanceSums(sections) {\n        if (sections.length < 2)\n            return true;\n        if (!StrokeCountSection.areSectionsCompatible(sections, false))\n            return false;\n        const visitor = new StrokeCountMapVisitorApplyMaxCurveLength();\n        this.runMultiPassVisitorAtCorrespondingPrimitives(sections, visitor);\n        this.remapa0a1WithinEachChain(sections);\n        return true;\n    }\n    /**\n     * Return stroked form of the section.\n     */\n    getStrokes() {\n        if (this.chains.length === 1) {\n            return this.chains[0].getStrokes();\n        }\n        else {\n            const region = ParityRegion.create();\n            for (const c of this.chains) {\n                const strokes = c.getStrokes();\n                if (strokes instanceof LineString3d)\n                    region.tryAddChild(Loop.create(strokes));\n            }\n            return region;\n        }\n    }\n    /**\n     * Given two compatible stroke sets (as returned by getStrokes) extend a range\n     * with the distances between corresponding points.\n     * * Each set of strokes may be:\n     *   * linestring\n     *   * ParityRegion\n     *   * CurveChain (Loop or Path)\n     * @param strokeA first set of strokes\n     * @param strokeB second set of strokes\n     * @param rangeToExtend caller-allocated range to be extended.\n     * @returns true if structures are compatible.\n     */\n    static extendDistanceRangeBetweenStrokes(strokeA, strokeB, rangeToExtend) {\n        if (strokeA instanceof LineString3d) {\n            if (strokeB instanceof LineString3d) {\n                if (strokeA.numPoints() === strokeB.numPoints()) {\n                    const n = strokeA.numPoints();\n                    const pointA = Point3d.create();\n                    const pointB = Point3d.create();\n                    const allPointA = strokeA.packedPoints;\n                    const allPointB = strokeB.packedPoints;\n                    for (let i = 0; i < n; i++) {\n                        allPointA.getPoint3dAtCheckedPointIndex(i, pointA);\n                        allPointB.getPoint3dAtCheckedPointIndex(i, pointB);\n                        rangeToExtend.extendX(pointA.distance(pointB));\n                    }\n                    return true;\n                }\n            }\n        }\n        else if (strokeA instanceof ParityRegion) {\n            if (strokeB instanceof ParityRegion) {\n                const childrenA = strokeA.children;\n                const childrenB = strokeB.children;\n                const n = childrenA.length;\n                if (n === childrenB.length) {\n                    for (let i = 0; i < n; i++) {\n                        if (!this.extendDistanceRangeBetweenStrokes(childrenA[i], childrenB[i], rangeToExtend))\n                            return false;\n                    }\n                    return true;\n                }\n            }\n        }\n        else if (strokeA instanceof CurveChain) {\n            if (strokeB instanceof CurveChain) {\n                const childrenA = strokeA.children;\n                const childrenB = strokeB.children;\n                const n = childrenA.length;\n                if (n === childrenB.length) {\n                    for (let i = 0; i < n; i++) {\n                        if (!this.extendDistanceRangeBetweenStrokes(childrenA[i], childrenB[i], rangeToExtend))\n                            return false;\n                    }\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n//# sourceMappingURL=StrokeCountChain.js.map",
      "start": 1693508125461,
      "end": 1693508125574,
      "sourcemaps": null
    }
  ]
}
