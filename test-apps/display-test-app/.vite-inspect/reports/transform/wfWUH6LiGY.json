{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend-devtools/lib/esm/widgets/KeyinField.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Widgets\n */\nimport { IModelApp, MessageBoxIconType, MessageBoxType, ParseAndRunResult } from \"@itwin/core-frontend\";\nimport { createButton } from \"../ui/Button\";\nimport { appendDataListEntries, createDataList } from \"../ui/DataList\";\nimport { createTextBox } from \"../ui/TextBox\";\nfunction keyinsToDataListEntries(keyins) {\n    const entries = [];\n    for (const keyin of keyins) {\n        entries.push({ value: keyin });\n    }\n    return entries;\n}\n/** Controls whether localized and/or non-localized key-in strings appear in a KeyinField's auto-completion list.\n * @beta\n */\nexport var KeyinFieldLocalization;\n(function (KeyinFieldLocalization) {\n    /** Include only non-localized key-in strings. */\n    KeyinFieldLocalization[KeyinFieldLocalization[\"NonLocalized\"] = 0] = \"NonLocalized\";\n    /** Include only localized key-in strings. */\n    KeyinFieldLocalization[KeyinFieldLocalization[\"Localized\"] = 1] = \"Localized\";\n    /** Include localized and non-localized strings for each key-in. */\n    KeyinFieldLocalization[KeyinFieldLocalization[\"Both\"] = 2] = \"Both\";\n})(KeyinFieldLocalization || (KeyinFieldLocalization = {}));\n/** A textbox allowing input of key-ins (localized tool names) combined with a drop-down that lists all registered key-ins, filtered by substring match on the current input.\n * Press `enter` or click the Enter button to run the key-in.\n * @beta\n */\nexport class KeyinField {\n    constructor(props) {\n        this._historyLength = 0;\n        this._localization = props.localization ?? KeyinFieldLocalization.NonLocalized;\n        this.keyins = this.findKeyins();\n        const autoCompleteListId = `${props.baseId}_autoComplete`;\n        this.autoCompleteList = createDataList({\n            parent: props.parent,\n            entries: keyinsToDataListEntries(this.keyins),\n            id: autoCompleteListId,\n            inline: true,\n        });\n        this.textBox = createTextBox({\n            label: props.wantLabel ? \"Key-in: \" : undefined,\n            id: `${props.baseId}_textBox`,\n            parent: props.parent,\n            handler: () => this.selectAll(),\n            keypresshandler: async (_tb, ev) => { await this.handleKeyPress(ev); },\n            focushandler: (_tb) => { this.respondToKeyinFocus(); },\n            tooltip: \"Type the key-in text here\",\n            inline: true,\n            list: autoCompleteListId,\n        });\n        if (props.wantButton) {\n            createButton({\n                handler: async (_bt) => { await this.submitKeyin(); },\n                parent: props.parent,\n                value: \"Enter\",\n                inline: true,\n                tooltip: \"Click here to execute the key-in\",\n            });\n        }\n        if (undefined !== props.historyLength && props.historyLength > 0) {\n            this.textBox.textbox.onkeydown = (ev) => this.handleKeyDown(ev); // eslint-disable-line @typescript-eslint/promise-function-async\n            this._historyLength = props.historyLength;\n            this._history = [];\n        }\n    }\n    focus() { this.textBox.textbox.focus(); }\n    loseFocus() { this.textBox.textbox.blur(); }\n    selectAll() {\n        this.textBox.textbox.setSelectionRange(0, this.textBox.textbox.value.length);\n    }\n    async handleKeyPress(ev) {\n        ev.stopPropagation();\n        if (\"Enter\" === ev.key)\n            await this.submitKeyin();\n    }\n    async handleKeyDown(ev) {\n        ev.stopPropagation();\n        if (undefined === this._history || 0 === this._history.length)\n            return;\n        // NB: History list is ordered by most to least recent so moving \"backwards\" means incrementing the index.\n        const direction = ev.key === \"ArrowDown\" ? 1 : (ev.key === \"ArrowUp\" ? 1 : 0);\n        if (0 === direction)\n            return;\n        ev.preventDefault();\n        ev.stopPropagation();\n        if (this._historyIndex === undefined) {\n            if (direction < 0)\n                return;\n            else\n                this._historyIndex = -1;\n        }\n        const newIndex = this._historyIndex + direction;\n        if (newIndex >= 0 && newIndex < this._history.length) {\n            this._historyIndex = newIndex;\n            if (this._historyIndex >= 0)\n                this.textBox.textbox.value = this._history[newIndex];\n        }\n    }\n    resetHistoryIndex() {\n        this._historyIndex = undefined;\n    }\n    pushHistory(keyin) {\n        if (undefined === this._history)\n            return;\n        this.textBox.textbox.value = \"\";\n        this.resetHistoryIndex();\n        if (this._history.length === 0 || keyin.toLowerCase() !== this._history[0].toLowerCase()) {\n            this._history.unshift(keyin);\n            if (this._history.length > this._historyLength)\n                this._history.pop();\n        }\n    }\n    async submitKeyin() {\n        this.selectAll();\n        const textBox = this.textBox.textbox;\n        const input = textBox.value;\n        this.pushHistory(input);\n        let message;\n        try {\n            switch (await IModelApp.tools.parseAndRun(input)) {\n                case ParseAndRunResult.ToolNotFound:\n                    message = `Cannot find a key-in that matches: ${input}`;\n                    break;\n                case ParseAndRunResult.BadArgumentCount:\n                    message = \"Incorrect number of arguments\";\n                    break;\n                case ParseAndRunResult.FailedToRun:\n                    message = \"Key-in failed to run\";\n                    break;\n            }\n        }\n        catch (ex) {\n            message = `Key-in produced exception: ${ex}`;\n        }\n        if (undefined !== message)\n            await IModelApp.notifications.openMessageBox(MessageBoxType.MediumAlert, message, MessageBoxIconType.Warning);\n    }\n    respondToKeyinFocus() {\n        this.resetHistoryIndex();\n        // Handle case in which new tools were registered since we last populated the auto-complete list.\n        // This can occur e.g. as a result of loading a extension, or deferred initialization of a package like markup.\n        const keyins = this.findKeyins();\n        if (keyins.length > this.keyins.length) {\n            const newKeyins = [];\n            for (const keyin of keyins)\n                if (!this.keyins.includes(keyin)) {\n                    newKeyins.push(keyin);\n                    this.keyins.push(keyin);\n                }\n            if (newKeyins.length > 0)\n                appendDataListEntries(this.autoCompleteList, keyinsToDataListEntries(newKeyins));\n        }\n    }\n    findKeyins() {\n        const keyins = [];\n        const tools = IModelApp.tools.getToolList();\n        for (const tool of tools) {\n            switch (this._localization) {\n                case KeyinFieldLocalization.Localized:\n                    keyins.push(tool.keyin);\n                    break;\n                case KeyinFieldLocalization.Both:\n                    keyins.push(tool.keyin);\n                    if (tool.keyin === tool.englishKeyin)\n                        break;\n                /* falls through */\n                default:\n                case KeyinFieldLocalization.NonLocalized:\n                    keyins.push(tool.englishKeyin);\n                    break;\n            }\n        }\n        return keyins;\n    }\n}\n//# sourceMappingURL=KeyinField.js.map",
      "start": 1693508122834,
      "end": 1693508122901,
      "sourcemaps": null
    }
  ]
}
