{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/SelectionSet.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module SelectionSet\n */\nimport { BeEvent, Id64 } from \"@itwin/core-bentley\";\nimport { IModelApp } from \"./IModelApp\";\n/** Identifies the type of changes made to the [[SelectionSet]] to produce a [[SelectionSetEvent]].\n * @public\n * @extensions\n */\nexport var SelectionSetEventType;\n(function (SelectionSetEventType) {\n    /** Elements have been added to the set. */\n    SelectionSetEventType[SelectionSetEventType[\"Add\"] = 0] = \"Add\";\n    /** Elements have been removed from the set. */\n    SelectionSetEventType[SelectionSetEventType[\"Remove\"] = 1] = \"Remove\";\n    /** Some elements have been added to the set and others have been removed. */\n    SelectionSetEventType[SelectionSetEventType[\"Replace\"] = 2] = \"Replace\";\n    /** All elements are about to be removed from the set. */\n    SelectionSetEventType[SelectionSetEventType[\"Clear\"] = 3] = \"Clear\";\n})(SelectionSetEventType || (SelectionSetEventType = {}));\n/** Tracks a set of hilited entities. When the set changes, notifies ViewManager so that symbology overrides can be updated in active Viewports.\n * @internal\n */\nclass HilitedIds extends Id64.Uint32Set {\n    constructor(iModel) {\n        super();\n        this._changing = false;\n        this._iModel = iModel;\n    }\n    add(low, high) {\n        super.add(low, high);\n        this.onChanged();\n    }\n    delete(low, high) {\n        super.delete(low, high);\n        this.onChanged();\n    }\n    clear() {\n        super.clear();\n        this.onChanged();\n    }\n    addIds(ids) {\n        this.change(() => super.addIds(ids));\n    }\n    deleteIds(ids) {\n        this.change(() => super.deleteIds(ids));\n    }\n    onChanged() {\n        if (!this._changing)\n            IModelApp.viewManager.onSelectionSetChanged(this._iModel);\n    }\n    change(func) {\n        const changing = this._changing;\n        this._changing = false;\n        func();\n        this._changing = changing;\n        this.onChanged();\n    }\n}\n/** Keeps the set of hilited elements in sync with the selection set.\n * @internal\n */\nclass HilitedElementIds extends HilitedIds {\n    constructor(iModel, syncWithSelectionSet = true) {\n        super(iModel);\n        this.wantSyncWithSelectionSet = syncWithSelectionSet;\n    }\n    get wantSyncWithSelectionSet() { return undefined !== this._removeListener; }\n    set wantSyncWithSelectionSet(want) {\n        if (want === this.wantSyncWithSelectionSet)\n            return;\n        if (want) {\n            const set = this._iModel.selectionSet;\n            this._removeListener = set.onChanged.addListener((ev) => this.change(() => this.processSelectionSetEvent(ev)));\n            this.processSelectionSetEvent({\n                set,\n                type: SelectionSetEventType.Add,\n                added: set.elements,\n            });\n        }\n        else {\n            this._removeListener();\n            this._removeListener = undefined;\n        }\n    }\n    processSelectionSetEvent(ev) {\n        if (SelectionSetEventType.Add !== ev.type)\n            this.deleteIds(ev.removed);\n        if (ev.type === SelectionSetEventType.Add || ev.type === SelectionSetEventType.Replace)\n            this.addIds(ev.added);\n    }\n}\n/** A set of *hilited* elements for an [[IModelConnection]], by element id.\n * Hilited elements are displayed with a customizable hilite effect within a [[Viewport]].\n * The set exposes 3 types of elements in 3 separate collections: [GeometricElement]($backend), [GeometricModel]($backend), and [SubCategory]($backend).\n * The [[models]] and [[subcategories]] can be hilited independently or as an intersection of the two sets, as specified by [[modelSubCategoryMode]].\n *\n * Technically, the hilite effect is applied to [Feature]($common)s, not [Element]($backend)s. An element's geometry stream can contain multiple\n * features belonging to different subcategories.\n *\n * Because Javascript lacks efficient support for 64-bit integers, the Ids are stored as pairs of 32-bit integers via [Id64.Uint32Set]($bentley).\n *\n * @note Typically, elements are hilited by virtue of their presence in the IModelConnection's [[SelectionSet]]. The HiliteSet allows additional\n * elements to be displayed with the hilite effect without adding them to the [[SelectionSet]]. If you add elements to the HiliteSet directly, you\n * are also responsible for removing them as appropriate.\n * @see [[IModelConnection.hilited]] for the HiliteSet associated with an iModel.\n * @see [Hilite.Settings]($common) for customization of the hilite effect.\n * @public\n * @extensions\n */\nexport class HiliteSet {\n    /** The set of hilited elements. */\n    get elements() { return this._elements; }\n    /** Controls how the sets of hilited [[models]] and [[subcategories]] interact with one another.\n     * By default they are treated as a union: a [Feature]($common) is hilited if either its model **or** its subcategory is hilited.\n     * This can be changed to an intersection such that a [Feature]($common) is hilited only if both its model **and** subcategory are hilited.\n     * @note The sets of hilited models and subcategories are independent of the set of hilited [[elements]] - an element whose Id is present in\n     * [[elements]] is always hilited regardless of its model or subcategories.\n     */\n    get modelSubCategoryMode() {\n        return this._mode;\n    }\n    set modelSubCategoryMode(mode) {\n        if (mode === this._mode)\n            return;\n        this.onModelSubCategoryModeChanged.raiseEvent(mode);\n        this._mode = mode;\n    }\n    /** Construct a HiliteSet\n     * @param iModel The iModel containing the entities to be hilited.\n     * @param syncWithSelectionSet If true, the contents of the `elements` set will be synchronized with those in the `iModel`'s [[SelectionSet]].\n     */\n    constructor(iModel, syncWithSelectionSet = true) {\n        this.iModel = iModel;\n        this._mode = \"union\";\n        /** Event raised just before changing the value of [[modelSubCategoryMode]]. */\n        this.onModelSubCategoryModeChanged = new BeEvent();\n        this._elements = new HilitedElementIds(iModel, syncWithSelectionSet);\n        this.subcategories = new HilitedIds(iModel);\n        this.models = new HilitedIds(iModel);\n    }\n    /** Control whether the hilited elements will be synchronized with the contents of the [[SelectionSet]].\n     * By default they are synchronized. Applications that override this take responsibility for managing the set of hilited entities.\n     * When turning synchronization off, the contents of the HiliteSet will remain unchanged.\n     * When turning synchronization on, the current contents of the HiliteSet will be preserved, and the contents of the selection set will be added to them.\n     */\n    get wantSyncWithSelectionSet() { return this._elements.wantSyncWithSelectionSet; }\n    set wantSyncWithSelectionSet(want) { this._elements.wantSyncWithSelectionSet = want; }\n    /** Remove all elements from the hilited set. */\n    clear() {\n        this.elements.clear();\n        this.subcategories.clear();\n        this.models.clear();\n    }\n    /** Returns true if nothing is hilited. */\n    get isEmpty() { return this.elements.isEmpty && this.subcategories.isEmpty && this.models.isEmpty; }\n    /** Toggle the hilited state of one or more elements.\n     * @param arg the ID(s) of the elements whose state is to be toggled.\n     * @param onOff True to add the elements to the hilited set, false to remove them.\n     */\n    setHilite(arg, onOff) {\n        const oldSize = this.elements.size;\n        for (const id of Id64.iterable(arg)) {\n            if (onOff)\n                this.elements.addId(id);\n            else\n                this.elements.deleteId(id);\n        }\n        if (oldSize !== this.elements.size)\n            IModelApp.viewManager.onSelectionSetChanged(this.iModel);\n    }\n}\n/** A set of *currently selected* elements for an IModelConnection.\n * Selected elements are displayed with a customizable hilite effect within a [[Viewport]].\n * @see [Hilite.Settings]($common) for customization of the hilite effect.\n * @public\n * @extensions\n */\nexport class SelectionSet {\n    /** The IDs of the selected elements.\n     * @note Do not modify this set directly. Instead, use methods like [[SelectionSet.add]].\n     */\n    get elements() { return this._elements; }\n    constructor(iModel) {\n        this.iModel = iModel;\n        this._elements = new Set();\n        /** Called whenever elements are added or removed from this SelectionSet */\n        this.onChanged = new BeEvent();\n    }\n    sendChangedEvent(ev) {\n        IModelApp.viewManager.onSelectionSetChanged(this.iModel);\n        this.onChanged.raiseEvent(ev);\n    }\n    /** Get the number of entries in this selection set. */\n    get size() { return this.elements.size; }\n    /** Check whether there are any selected elements. */\n    get isActive() { return this.size !== 0; }\n    /** Return true if elemId is in this SelectionSet.\n     * @see [[isSelected]]\n     */\n    has(elemId) { return !!elemId && this.elements.has(elemId); }\n    /** Query whether an Id is in the selection set.\n     * @see [[has]]\n     */\n    isSelected(elemId) { return !!elemId && this.elements.has(elemId); }\n    /** Clear current selection set.\n     * @note raises the [[onChanged]] event with [[SelectionSetEventType.Clear]].\n     */\n    emptyAll() {\n        if (!this.isActive)\n            return;\n        const removed = this._elements;\n        this._elements = new Set();\n        this.sendChangedEvent({ set: this, type: SelectionSetEventType.Clear, removed });\n    }\n    /**\n     * Add one or more Ids to the current selection set.\n     * @param elem The set of Ids to add.\n     * @returns true if any elements were added.\n     */\n    add(elem) {\n        return this._add(elem);\n    }\n    _add(elem, sendEvent = true) {\n        const oldSize = this.elements.size;\n        for (const id of Id64.iterable(elem))\n            this.elements.add(id);\n        const changed = oldSize !== this.elements.size;\n        if (sendEvent && changed)\n            this.sendChangedEvent({ type: SelectionSetEventType.Add, set: this, added: elem });\n        return changed;\n    }\n    /**\n     * Remove one or more Ids from the current selection set.\n     * @param elem The set of Ids to remove.\n     * @returns true if any elements were removed.\n     */\n    remove(elem) {\n        return this._remove(elem);\n    }\n    _remove(elem, sendEvent = true) {\n        const oldSize = this.elements.size;\n        for (const id of Id64.iterable(elem))\n            this.elements.delete(id);\n        const changed = oldSize !== this.elements.size;\n        if (sendEvent && changed)\n            this.sendChangedEvent({ type: SelectionSetEventType.Remove, set: this, removed: elem });\n        return changed;\n    }\n    /**\n     * Add one set of Ids, and remove another set of Ids. Any Ids that are in both sets are removed.\n     * @returns True if any Ids were either added or removed.\n     */\n    addAndRemove(adds, removes) {\n        const added = this._add(adds, false);\n        const removed = this._remove(removes, false);\n        if (added && removed)\n            this.sendChangedEvent({ type: SelectionSetEventType.Replace, set: this, added: adds, removed: removes });\n        else if (added)\n            this.sendChangedEvent({ type: SelectionSetEventType.Add, set: this, added: adds });\n        else if (removed)\n            this.sendChangedEvent({ type: SelectionSetEventType.Remove, set: this, removed: removes });\n        return (added || removed);\n    }\n    /** Invert the state of a set of Ids in the SelectionSet */\n    invert(elem) {\n        const elementsToAdd = new Set();\n        const elementsToRemove = new Set();\n        for (const id of Id64.iterable(elem)) {\n            if (this.elements.has(id))\n                elementsToRemove.add(id);\n            else\n                elementsToAdd.add(id);\n        }\n        return this.addAndRemove(elementsToAdd, elementsToRemove);\n    }\n    /** Change selection set to be the supplied set of Ids. */\n    replace(elem) {\n        if (areEqual(this.elements, elem))\n            return;\n        const removed = this._elements;\n        this._elements = new Set();\n        this._add(elem, false);\n        if (0 < removed.size) {\n            for (const id of Id64.iterable(elem)) {\n                if (removed.has(id))\n                    removed.delete(id);\n            }\n        }\n        this.sendChangedEvent({ type: SelectionSetEventType.Replace, set: this, added: elem, removed });\n    }\n}\nfunction areEqual(lhs, rhs) {\n    // Size is unreliable if input can contain duplicates...\n    if (Array.isArray(rhs))\n        rhs = Id64.toIdSet(rhs);\n    if (lhs.size !== Id64.sizeOf(rhs))\n        return false;\n    for (const id of Id64.iterable(rhs))\n        if (!lhs.has(id))\n            return false;\n    return true;\n}\n//# sourceMappingURL=SelectionSet.js.map",
      "start": 1693508119446,
      "end": 1693508119592,
      "sourcemaps": null
    }
  ]
}
