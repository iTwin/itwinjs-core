{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/PlanarTextureProjection.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Rendering\n */\nimport { Frustum, FrustumPlanes, Npc, RenderMode } from \"@itwin/core-common\";\nimport { ClipUtilities, ConvexClipPlaneSet, Map4d, Matrix3d, Matrix4d, Plane3dByOriginAndUnitNormal, Point3d, Range2d, Range3d, Ray3d, Transform, } from \"@itwin/core-geometry\";\nimport { ApproximateTerrainHeights } from \"../../ApproximateTerrainHeights\";\nimport { RenderState } from \"./RenderState\";\nconst scratchRange = Range3d.createNull();\nconst scratchMap4d = Map4d.createIdentity();\nconst scratchMatrix4d = Matrix4d.createIdentity();\nclass PlanarTextureProjection {\n    static computePlanarTextureProjection(texturePlane, sceneContext, target, drapeRefs, viewState, textureWidth, textureHeight, _heightRange) {\n        const textureZ = texturePlane.getNormalRef();\n        const viewingSpace = sceneContext.viewingSpace;\n        const viewX = viewingSpace.rotation.rowX();\n        const viewZ = viewingSpace.rotation.rowZ();\n        const minCrossMagnitude = 1.0E-4;\n        if (viewZ === undefined)\n            return {}; // View without depth?....\n        let textureX = viewZ.crossProduct(textureZ);\n        let textureY;\n        if (textureX.magnitude() < minCrossMagnitude) {\n            textureY = viewX.crossProduct(textureZ);\n            textureX = textureY.crossProduct(textureZ).normalize();\n        }\n        else {\n            textureX.normalizeInPlace();\n            textureY = textureZ.crossProduct(textureX).normalize();\n        }\n        const frustumX = textureZ, frustumY = textureX, frustumZ = textureY;\n        const textureMatrix = Matrix3d.createRows(frustumX, frustumY, frustumZ);\n        const textureTransform = Transform.createRefs(Point3d.createZero(), textureMatrix);\n        const viewFrustum = viewingSpace.getFrustum().transformBy(textureTransform);\n        const viewPlanes = FrustumPlanes.fromFrustum(viewFrustum);\n        const viewClipPlanes = ConvexClipPlaneSet.createPlanes(viewPlanes.planes);\n        let textureRange = Range3d.createNull();\n        const tileToTexture = textureTransform.multiplyTransformTransform(target.location);\n        for (const tile of target.tiles) {\n            textureRange.extendRange(tileToTexture.multiplyRange(tile.range, scratchRange));\n        }\n        if (textureRange.isNull)\n            return {};\n        textureRange = ClipUtilities.rangeOfClipperIntersectionWithRange(viewClipPlanes, textureRange);\n        const drapeRange = Range3d.createNull();\n        for (const drapeRef of drapeRefs) {\n            const drapeTree = drapeRef.treeOwner.tileTree;\n            if (!drapeTree)\n                return {};\n            if (drapeTree.isContentUnbounded) {\n                let heightRange = viewingSpace.getTerrainHeightRange();\n                if (!heightRange)\n                    heightRange = ApproximateTerrainHeights.instance.globalHeightRange;\n                textureRange.low.x = Math.min(textureRange.low.x, heightRange.low);\n                textureRange.high.x = Math.max(textureRange.high.x, heightRange.high);\n            }\n            else {\n                const contentRange = textureTransform.multiplyRange(drapeRef.computeWorldContentRange());\n                if (!contentRange.isNull)\n                    drapeRange.extendRange(contentRange);\n            }\n        }\n        if (!drapeRange.isNull) {\n            // Union of height\n            textureRange.low.x = Math.min(textureRange.low.x, drapeRange.low.x);\n            textureRange.high.x = Math.max(textureRange.high.x, drapeRange.high.x);\n            // Intersection of texture extents.\n            textureRange.low.y = Math.max(textureRange.low.y, drapeRange.low.y);\n            textureRange.high.y = Math.min(textureRange.high.y, drapeRange.high.y);\n            textureRange.low.z = Math.max(textureRange.low.z, drapeRange.low.z);\n            textureRange.high.z = Math.min(textureRange.high.z, drapeRange.high.z);\n        }\n        const epsilon = .01;\n        textureRange.low.x -= epsilon;\n        textureRange.high.x += epsilon;\n        const textureFrustum = Frustum.fromRange(textureRange);\n        const debugFrustum = textureFrustum.clone();\n        textureTransform.multiplyInversePoint3dArray(debugFrustum.points, debugFrustum.points);\n        if (viewState.isCameraOn) {\n            const eyeHeight = (textureRange.low.x + textureRange.high.x) / 2.0;\n            const eyePlane = Plane3dByOriginAndUnitNormal.create(Point3d.createScale(textureZ, eyeHeight), textureZ); // Centered in range - parallel to texture.\n            const projectionRay = Ray3d.create(viewState.getEyePoint(), viewZ.crossProduct(textureX).normalize());\n            let projectionDistance = projectionRay.intersectionWithPlane(eyePlane);\n            const minNearToFarRatio = .01; // Smaller value allows texture projection to conform tightly to view frustum.\n            if (undefined !== projectionDistance) {\n                projectionDistance = Math.max(.1, projectionDistance);\n                const eyePoint = textureTransform.multiplyPoint3d(projectionRay.fractionToPoint(projectionDistance));\n                let near = eyePoint.z - textureRange.high.z;\n                let far = eyePoint.z - textureRange.low.z;\n                if (near / far < minNearToFarRatio) {\n                    // If the near-far ratio is less than minimum move the camera back.\n                    far = (textureRange.high.z - textureRange.low.z) / (1.0 - minNearToFarRatio);\n                    near = far * minNearToFarRatio;\n                    eyePoint.z = near + textureRange.high.z;\n                }\n                const farRange = Range2d.createNull();\n                const nearRange = Range2d.createNull();\n                // Create a frustum that includes the entire view frustum and all Z values.\n                nearRange.low.x = textureRange.low.x;\n                nearRange.high.x = textureRange.high.x;\n                farRange.low.x = eyePoint.x + far / near * (textureRange.low.x - eyePoint.x);\n                farRange.high.x = eyePoint.x + far / near * (textureRange.high.x - eyePoint.x);\n                ClipUtilities.announceLoopsOfConvexClipPlaneSetIntersectRange(viewClipPlanes, textureRange, (points) => {\n                    points.getPoint3dArray().forEach((rangePoint) => {\n                        const farScale = far / (eyePoint.z - rangePoint.z);\n                        const nearScale = near / (eyePoint.z - rangePoint.z);\n                        const nearY = eyePoint.y + nearScale * (rangePoint.y - eyePoint.y);\n                        const farY = eyePoint.y + farScale * (rangePoint.y - eyePoint.y);\n                        nearRange.low.y = Math.min(nearRange.low.y, nearY);\n                        nearRange.high.y = Math.max(nearRange.high.y, nearY);\n                        farRange.low.y = Math.min(farRange.low.y, farY);\n                        farRange.high.y = Math.max(farRange.high.y, farY);\n                    });\n                });\n                textureFrustum.points[Npc._000].set(farRange.low.x, farRange.low.y, eyePoint.z - far);\n                textureFrustum.points[Npc._100].set(farRange.high.x, farRange.low.y, eyePoint.z - far);\n                textureFrustum.points[Npc._010].set(farRange.low.x, farRange.high.y, eyePoint.z - far);\n                textureFrustum.points[Npc._110].set(farRange.high.x, farRange.high.y, eyePoint.z - far);\n                textureFrustum.points[Npc._001].set(nearRange.low.x, nearRange.low.y, eyePoint.z - near);\n                textureFrustum.points[Npc._101].set(nearRange.high.x, nearRange.low.y, eyePoint.z - near);\n                textureFrustum.points[Npc._011].set(nearRange.low.x, nearRange.high.y, eyePoint.z - near);\n                textureFrustum.points[Npc._111].set(nearRange.high.x, nearRange.high.y, eyePoint.z - near);\n            }\n        }\n        textureMatrix.transposeInPlace();\n        textureMatrix.multiplyVectorArrayInPlace(textureFrustum.points);\n        const frustumMap = textureFrustum.toMap4d();\n        if (undefined === frustumMap) {\n            return {};\n        }\n        const worldToNpc = PlanarTextureProjection._postProjectionMatrixNpc.multiplyMatrixMatrix(frustumMap.transform0);\n        const npcToView = Map4d.createBoxMap(Point3d.create(0, 0, 0), Point3d.create(1, 1, 1), Point3d.create(0, 0, 0), Point3d.create(textureWidth, textureHeight, 1), scratchMap4d);\n        const npcToWorld = worldToNpc.createInverse(scratchMatrix4d);\n        if (undefined === npcToWorld) {\n            return {};\n        }\n        const worldToNpcMap = Map4d.createRefs(worldToNpc, npcToWorld);\n        const worldToViewMap = npcToView.multiplyMapMap(worldToNpcMap);\n        return { textureFrustum, projectionMatrix: worldToNpc, worldToViewMap, debugFrustum };\n    }\n    static getTextureDrawingParams(target) {\n        const state = new RenderState();\n        state.flags.depthMask = false;\n        state.flags.blend = false;\n        state.flags.depthTest = false;\n        const viewFlags = target.currentViewFlags.copy({\n            renderMode: RenderMode.SmoothShade,\n            wiremesh: false,\n            transparency: false,\n            textures: false,\n            lighting: false,\n            shadows: false,\n            monochrome: false,\n            materials: false,\n            ambientOcclusion: false,\n            visibleEdges: false,\n            hiddenEdges: false,\n        });\n        return { state, viewFlags };\n    }\n}\nPlanarTextureProjection._postProjectionMatrixNpc = Matrix4d.createRowValues(/* Row 1 */ 0, 1, 0, 0, /* Row 1 */ 0, 0, 1, 0, /* Row 3 */ 1, 0, 0, 0, /* Row 4 */ 0, 0, 0, 1);\nexport { PlanarTextureProjection };\n//# sourceMappingURL=PlanarTextureProjection.js.map",
      "start": 1693508124719,
      "end": 1693508124939,
      "sourcemaps": null
    }
  ]
}
