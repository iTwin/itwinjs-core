{
  "resolvedId": "D:/hub2023A/itwinjs-core/common/temp/node_modules/.pnpm/@itwin+browser-authorization@1.0.1_67wltvhdskk2oee2c3z2o4tfly/node_modules/@itwin/browser-authorization/lib/esm/Client.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\r\n* See LICENSE.md in the project root for license terms and full copyright notice.\r\n*--------------------------------------------------------------------------------------------*/\r\nimport { UserManager, WebStorageStateStore } from \"oidc-client-ts\";\r\nimport { BeEvent, Logger, UnexpectedErrors } from \"@itwin/core-bentley\";\r\nimport { BrowserAuthorizationLogger } from \"./Logger\";\r\nimport { BrowserAuthorizationLoggerCategory } from \"./LoggerCategory\";\r\nimport { getImsAuthority } from \"./utils\";\r\n/** BrowserAuthorization type guard.\r\n * @beta\r\n */\r\nexport const isBrowserAuthorizationClient = (client) => {\r\n    return client !== undefined && client.signIn !== undefined && client.signOut !== undefined;\r\n};\r\n/**\r\n * @beta\r\n */\r\nexport class BrowserAuthorizationClient {\r\n    constructor(configuration) {\r\n        this.onAccessTokenChanged = new BeEvent();\r\n        this._accessToken = \"\";\r\n        this._onUserStateChanged = (user) => {\r\n            this.initAccessToken(user);\r\n            try {\r\n                this.onAccessTokenChanged.raiseEvent(this._accessToken);\r\n            }\r\n            catch (err) {\r\n                Logger.logError(BrowserAuthorizationLoggerCategory.Authorization, \"Error thrown when handing BrowserAuthorizationClient.onUserStateChanged event\", () => ({ message: err.message }));\r\n            }\r\n        };\r\n        /**\r\n         * Raised when a user session has been established (or re-established).\r\n         * This can happen on startup, after token refresh or token callback.\r\n         */\r\n        this._onUserLoaded = (user) => {\r\n            this._onUserStateChanged(user);\r\n        };\r\n        /**\r\n         * Raised when a user session has been terminated.\r\n         */\r\n        this._onUserUnloaded = () => {\r\n            this._onUserStateChanged(undefined);\r\n        };\r\n        /**\r\n         * Raised prior to the access token expiring\r\n         */\r\n        this._onAccessTokenExpiring = async () => {\r\n        };\r\n        /**\r\n         * Raised after the access token has expired.\r\n         */\r\n        this._onAccessTokenExpired = () => {\r\n            this._onUserStateChanged(undefined);\r\n        };\r\n        /**\r\n         * Raised when the automatic silent renew has failed.\r\n         */\r\n        this._onSilentRenewError = () => {\r\n        };\r\n        /**\r\n         * Raised when the user's sign-in status at the OP has changed.\r\n         */\r\n        this._onUserSignedOut = () => {\r\n            this._onUserStateChanged(undefined);\r\n        };\r\n        BrowserAuthorizationLogger.initializeLogger();\r\n        this._basicSettings = {\r\n            ...configuration,\r\n            authority: configuration.authority ?? getImsAuthority(),\r\n        };\r\n    }\r\n    get isAuthorized() {\r\n        return this.hasSignedIn;\r\n    }\r\n    get hasExpired() {\r\n        if (this._expiresAt)\r\n            return this._expiresAt.getTime() - Date.now() <= 1 * 60 * 1000; // Consider 1 minute before expiry as expired;\r\n        return !this._accessToken;\r\n    }\r\n    get hasSignedIn() {\r\n        return !!this._accessToken;\r\n    }\r\n    get authorityUrl() {\r\n        return this._advancedSettings?.authority ?? this._basicSettings.authority;\r\n    }\r\n    async getUserManager() {\r\n        if (this._userManager) {\r\n            return this._userManager;\r\n        }\r\n        const settings = await this.getUserManagerSettings(this._basicSettings, this._advancedSettings);\r\n        this._userManager = this.createUserManager(settings);\r\n        return this._userManager;\r\n    }\r\n    /**\r\n     * Merges the basic and advanced settings into a single configuration object consumable by the internal userManager.\r\n     * @param basicSettings\r\n     * @param advancedSettings\r\n     * @returns a promise resolving to UserManagerSettings\r\n     */\r\n    async getUserManagerSettings(basicSettings, advancedSettings) {\r\n        let userManagerSettings = {\r\n            authority: this.authorityUrl,\r\n            redirect_uri: basicSettings.redirectUri,\r\n            client_id: basicSettings.clientId,\r\n            scope: basicSettings.scope,\r\n            post_logout_redirect_uri: basicSettings.postSignoutRedirectUri,\r\n            response_type: basicSettings.responseType,\r\n            automaticSilentRenew: true,\r\n            silent_redirect_uri: basicSettings.silentRedirectUri,\r\n            userStore: new WebStorageStateStore({ store: window.localStorage }),\r\n            prompt: basicSettings.prompt,\r\n            response_mode: basicSettings.responseMode, // eslint-disable-line @typescript-eslint/naming-convention\r\n        };\r\n        if (advancedSettings) {\r\n            userManagerSettings = { ...userManagerSettings, ...advancedSettings };\r\n        }\r\n        return userManagerSettings;\r\n    }\r\n    /**\r\n     * Creates the internal user manager and binds all relevant events to their respective callback function.\r\n     * @param settings\r\n     */\r\n    createUserManager(settings) {\r\n        const userManager = new UserManager(settings);\r\n        userManager.events.addUserLoaded(this._onUserLoaded);\r\n        userManager.events.addUserUnloaded(this._onUserUnloaded);\r\n        userManager.events.addAccessTokenExpiring(this._onAccessTokenExpiring);\r\n        userManager.events.addAccessTokenExpired(this._onAccessTokenExpired);\r\n        userManager.events.addSilentRenewError(this._onSilentRenewError);\r\n        userManager.events.addUserSignedOut(this._onUserSignedOut);\r\n        return userManager;\r\n    }\r\n    /**\r\n     * Alias for signInRedirect\r\n     */\r\n    async signIn() {\r\n        return this.signInRedirect();\r\n    }\r\n    /**\r\n     * Attempts a sign-in via redirection with the authorization provider.\r\n     * If possible, a non-interactive signin will be attempted first.\r\n     * If successful, the returned promise will be resolved.\r\n     * Otherwise, an attempt to redirect the browser will proceed.\r\n     * If an error prevents the redirection from occurring, the returned promise will be rejected with the responsible error.\r\n     * Otherwise, the browser's window will be redirected away from the current page, effectively ending execution here.\r\n     * @param successRedirectUrl - (optional) path to redirect to after a successful authorization\r\n     * @param args (optional) additional BrowserAuthorizationClientRequestOptions passed to signIn methods\r\n     */\r\n    async signInRedirect(successRedirectUrl, args) {\r\n        const user = await this.nonInteractiveSignIn(args);\r\n        if (user) {\r\n            return;\r\n        }\r\n        const userManager = await this.getUserManager();\r\n        const state = {\r\n            successRedirectUrl: successRedirectUrl || window.location.href,\r\n        };\r\n        const redirectArgs = { state, ...args };\r\n        await userManager.signinRedirect(redirectArgs); // This call changes the window's URL, which effectively ends execution here unless an exception is thrown.\r\n    }\r\n    /**\r\n     * Attempts a sign-in via popup with the authorization provider\r\n     * @param args - @see BrowserAuthorizationClientRequestOptions\r\n     */\r\n    async signInPopup(args) {\r\n        let user = await this.nonInteractiveSignIn(args);\r\n        if (user) {\r\n            return;\r\n        }\r\n        const userManager = await this.getUserManager();\r\n        user = await userManager.signinPopup(args);\r\n        if (!user || user.expired)\r\n            throw new Error(\"Expected userManager.signinPopup to always resolve to an authorized user\");\r\n        return;\r\n    }\r\n    /**\r\n     * Attempts a silent sign in with the authorization provider\r\n     * @throws [Error] If the silent sign in fails\r\n     */\r\n    async signInSilent() {\r\n        const user = await this.nonInteractiveSignIn();\r\n        if (user === undefined || user.expired)\r\n            throw new Error(\"Authorization error: Silent sign-in failed\");\r\n    }\r\n    /**\r\n     * Attempts a non-interactive signIn\r\n     * - tries to load the user from storage\r\n     * - tries to silently sign-in the user\r\n     */\r\n    async nonInteractiveSignIn(args) {\r\n        const userManager = await this.getUserManager();\r\n        const settingsPromptRequired = userManager.settings.prompt !== undefined && userManager.settings.prompt !== \"none\";\r\n        const argsPromptRequired = args?.prompt !== undefined && args.prompt !== \"none\";\r\n        if (settingsPromptRequired || argsPromptRequired) { // No need to even try a silent sign in if we know the prompt will force its failure.\r\n            return undefined;\r\n        }\r\n        let user = await this.loadUser();\r\n        if (user) {\r\n            return user;\r\n        }\r\n        // Attempt a silent sign-in\r\n        try {\r\n            user = await userManager.signinSilent() ?? undefined; // calls events\r\n            return user;\r\n        }\r\n        catch (err) {\r\n            return undefined;\r\n        }\r\n    }\r\n    /**\r\n     * Gets the user from storage\r\n     * @return User found in storage.\r\n     * - Resolves to undefined if no user was found.\r\n     * - Returned user may have expired - so it's up to the caller to check the expired state\r\n     */\r\n    async loadUser() {\r\n        const userManager = await this.getUserManager();\r\n        const user = await userManager.getUser();\r\n        if (user && !user.expired) {\r\n            this._onUserLoaded(user); // Call only because getUser() doesn't call any events\r\n            return user;\r\n        }\r\n        return undefined;\r\n    }\r\n    initAccessToken(user) {\r\n        if (!user) {\r\n            this._accessToken = \"\";\r\n            return;\r\n        }\r\n        this._accessToken = `Bearer ${user.access_token}`;\r\n        this._expiresAt = user.expires_at ? new Date(user.expires_at * 1000) : undefined;\r\n    }\r\n    /**\r\n     * Alias for signOutRedirect\r\n     */\r\n    async signOut() {\r\n        await this.signOutRedirect();\r\n    }\r\n    async signOutRedirect() {\r\n        const userManager = await this.getUserManager();\r\n        await userManager.signoutRedirect();\r\n    }\r\n    async signOutPopup() {\r\n        const userManager = await this.getUserManager();\r\n        await userManager.signoutPopup();\r\n    }\r\n    /**\r\n     * Returns a promise that resolves to the AccessToken of the currently authorized user.\r\n     * The token is refreshed as necessary.\r\n     * @throws [Error] If signIn() was not called, or there was an authorization error.\r\n     * @returns an AccessToken\r\n     */\r\n    async getAccessToken() {\r\n        if (this._accessToken)\r\n            return this._accessToken;\r\n        throw new Error(\"Authorization error: Not signed in.\");\r\n    }\r\n    /**\r\n     * Checks the current local user session against that of the identity provider.\r\n     * If the session is no longer valid, the local user is removed from storage.\r\n     * @returns true if the local session is still active with the provider, false otherwise.\r\n     */\r\n    async checkSessionStatus() {\r\n        const userManager = await this.getUserManager();\r\n        try {\r\n            await userManager.querySessionStatus();\r\n        }\r\n        catch (err) { // Access token is no longer valid in this session\r\n            await userManager.removeUser();\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    /** Disposes the resources held by this client */\r\n    dispose() {\r\n        if (this._userManager) {\r\n            this._userManager.events.removeUserLoaded(this._onUserLoaded);\r\n            this._userManager.events.removeAccessTokenExpiring(this._onAccessTokenExpiring);\r\n            this._userManager.events.removeAccessTokenExpired(this._onAccessTokenExpired);\r\n            this._userManager.events.removeUserUnloaded(this._onUserUnloaded);\r\n            this._userManager.events.removeSilentRenewError(this._onSilentRenewError);\r\n            this._userManager.events.removeUserSignedOut(this._onUserSignedOut);\r\n        }\r\n    }\r\n    /**\r\n     * @internal\r\n     * Allows for advanced options to be supplied to the underlying UserManager.\r\n     * This function should be called directly after object construction.\r\n     * Any settings supplied via this method will override the corresponding settings supplied via the constructor.\r\n     * @throws if called after the internal UserManager has already been created.\r\n     */\r\n    setAdvancedSettings(settings) {\r\n        if (this._userManager) {\r\n            throw new Error(\"Cannot supply advanced settings to BrowserAuthorizationClient after the underlying UserManager has already been created.\");\r\n        }\r\n        this._advancedSettings = settings;\r\n    }\r\n    /**\r\n     * Attempts to process a callback response in the current URL.\r\n     * When called successfully within an iframe or popup, the host frame will automatically be destroyed.\r\n     * @param responseMode - Defines how OIDC auth reponse parameters are encoded.\r\n     * @throws [[Error]] when this attempt fails for any reason.\r\n     */\r\n    async handleSigninCallbackInternal(responseMode) {\r\n        const userManager = await this.getUserManager();\r\n        // oidc-client-js uses an over-eager regex to parse the url, which may match values from the hash string when targeting the query string (and vice-versa)\r\n        // To ensure that this mismatching doesn't occur, we strip the unnecessary portion away here first.\r\n        const urlSuffix = responseMode === \"query\"\r\n            ? window.location.search\r\n            : window.location.hash;\r\n        const url = `${window.location.origin}${window.location.pathname}${urlSuffix}`;\r\n        const user = await userManager.signinCallback(url); // For silent or popup callbacks, execution effectively ends here, since the context will be destroyed.\r\n        if (!user || user.expired)\r\n            throw new Error(\"Authorization error: userManager.signinRedirectCallback does not resolve to authorized user\");\r\n        if (user.state) {\r\n            const state = user.state;\r\n            if (state.successRedirectUrl) { // Special case for signin via redirect used to return to the original location\r\n                window.location.replace(state.successRedirectUrl);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Attempts to parse an OIDC token from the current window URL\r\n     * When called within an iframe or popup, the host frame will automatically be destroyed before the promise resolves.\r\n     */\r\n    async handleSigninCallback() {\r\n        const url = new URL(this._basicSettings.redirectUri);\r\n        if (url.pathname !== window.location.pathname)\r\n            return;\r\n        let errorMessage = \"\";\r\n        try {\r\n            await this.handleSigninCallbackInternal(\"fragment\");\r\n            return;\r\n        }\r\n        catch (err) {\r\n            errorMessage += `${err.message}\\n`;\r\n        }\r\n        try {\r\n            await this.handleSigninCallbackInternal(\"query\");\r\n            return;\r\n        }\r\n        catch (err) {\r\n            errorMessage += `${err.message}\\n`;\r\n        }\r\n        if (window.self !== window.top) { // simply destroy the window if a failure is detected in an iframe.\r\n            window.close();\r\n            return;\r\n        }\r\n        errorMessage = `SigninCallback error - failed to process signin request in callback using all known modes of token delivery: ${errorMessage}`;\r\n        UnexpectedErrors.handle(new Error(errorMessage));\r\n    }\r\n    /**\r\n     * Configuration-less sign in callback. Useful for when a client instance with configuration is not present\r\n     * on the page or route where the callback is needed to finish the authentication process. Pulls configuration\r\n     * from localStorage.\r\n     *\r\n     * @param store - A Storage object such as sessionStorage which stores configuration. Defaults to localStorage\r\n     * which is also the default stateStore for this library. These stores should match.\r\n     */\r\n    static async handleSignInCallback(store = window.localStorage) {\r\n        const staticClient = new BrowserAuthorizationClient({});\r\n        this.loadSettingsFromStorage(staticClient, store);\r\n        await staticClient.handleSigninCallback();\r\n    }\r\n    static loadSettingsFromStorage(client, store) {\r\n        const url = new URL(window.location.href);\r\n        const nonce = url.searchParams.get(\"state\");\r\n        const storageEntry = store.getItem(`oidc.${nonce}`);\r\n        if (!storageEntry)\r\n            throw new Error(\"Could not load oidc settings from local storage. Ensure the client is configured properly\");\r\n        const storageObject = JSON.parse(storageEntry);\r\n        const transformed = {\r\n            ...storageObject,\r\n            clientId: storageObject.client_id,\r\n            redirectUri: storageObject.redirect_uri,\r\n            authority: storageObject.authority,\r\n        };\r\n        client._basicSettings = transformed;\r\n    }\r\n}\r\n//# sourceMappingURL=Client.js.map",
      "start": 1693508122405,
      "end": 1693508122591,
      "sourcemaps": null
    }
  ]
}
