{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/SubCategoriesCache.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\nimport { assert, CompressedId64Set, Id64, OrderedId64Iterable } from \"@itwin/core-bentley\";\nimport { SubCategoryAppearance } from \"@itwin/core-common\";\nconst invalidCategoryIdEntry = new Set();\n/** A cache of information about the subcategories contained within an [[IModelConnection]]. It is populated on demand.\n * @internal\n */\nexport class SubCategoriesCache {\n    constructor(imodel) {\n        this._byCategoryId = new Map();\n        this._appearances = new Map();\n        this._imodel = imodel;\n    }\n    /** Get the Ids of all subcategories belonging to the category with the specified Id, or undefined if no such information is present. */\n    getSubCategories(categoryId) { return this._byCategoryId.get(categoryId); }\n    /** Get the base appearance of the subcategory with the specified Id, or undefined if no such information is present. */\n    getSubCategoryAppearance(subCategoryId) { return this._appearances.get(subCategoryId.toString()); }\n    /** Request that the subcategory information for all of the specified categories is loaded.\n     * If all such information has already been loaded, returns undefined.\n     * Otherwise, dispatches an asynchronous request to load those categories which are not already loaded and returns a cancellable request object\n     * containing the corresponding promise and the set of categories still to be loaded.\n     */\n    load(categoryIds) {\n        const missing = this.getMissing(categoryIds);\n        if (undefined === missing)\n            return undefined;\n        const request = new SubCategoriesCache.Request(missing, this._imodel);\n        const promise = request.dispatch().then((result) => {\n            if (undefined !== result)\n                this.processResults(result, missing);\n            return !request.wasCanceled;\n        });\n        return {\n            missingCategoryIds: missing,\n            promise,\n            cancel: () => request.cancel(),\n        };\n    }\n    /** Given categoryIds, return which of these are not cached. */\n    getMissing(categoryIds) {\n        let missing;\n        for (const catId of Id64.iterable(categoryIds)) {\n            if (undefined === this._byCategoryId.get(catId)) {\n                if (undefined === missing)\n                    missing = new Set();\n                missing.add(catId);\n            }\n        }\n        return missing;\n    }\n    clear() {\n        this._byCategoryId.clear();\n        this._appearances.clear();\n    }\n    onIModelConnectionClose() {\n        this.clear();\n    }\n    static createSubCategoryAppearance(json) {\n        let props;\n        if (\"string\" === typeof json && 0 < json.length)\n            props = JSON.parse(json);\n        return new SubCategoryAppearance(props);\n    }\n    processResults(result, missing) {\n        for (const row of result)\n            this.add(row.parentId, row.id, SubCategoriesCache.createSubCategoryAppearance(row.appearance));\n        // Ensure that any category Ids which returned no results (e.g., non-existent category, invalid Id, etc) are still recorded so they are not repeatedly re-requested\n        for (const id of missing)\n            if (undefined === this._byCategoryId.get(id))\n                this._byCategoryId.set(id, invalidCategoryIdEntry);\n    }\n    /** Exposed strictly for tests.\n     * @internal\n     */\n    add(categoryId, subCategoryId, appearance) {\n        let set = this._byCategoryId.get(categoryId);\n        if (undefined === set)\n            this._byCategoryId.set(categoryId, set = new Set());\n        set.add(subCategoryId);\n        this._appearances.set(subCategoryId, appearance);\n    }\n    async getCategoryInfo(inputCategoryIds) {\n        // Eliminate duplicates...\n        const categoryIds = new Set(typeof inputCategoryIds === \"string\" ? [inputCategoryIds] : inputCategoryIds);\n        const req = this.load(categoryIds);\n        if (req)\n            await req.promise;\n        const map = new Map();\n        for (const categoryId of categoryIds) {\n            const subCategoryIds = this._byCategoryId.get(categoryId);\n            if (!subCategoryIds)\n                continue;\n            const subCategories = this.mapSubCategoryInfos(categoryId, subCategoryIds);\n            map.set(categoryId, { id: categoryId, subCategories });\n        }\n        return map;\n    }\n    async getSubCategoryInfo(categoryId, inputSubCategoryIds) {\n        // Eliminate duplicates...\n        const subCategoryIds = new Set(typeof inputSubCategoryIds === \"string\" ? [inputSubCategoryIds] : inputSubCategoryIds);\n        const req = this.load(categoryId);\n        if (req)\n            await req.promise;\n        return this.mapSubCategoryInfos(categoryId, subCategoryIds);\n    }\n    mapSubCategoryInfos(categoryId, subCategoryIds) {\n        const map = new Map();\n        for (const id of subCategoryIds) {\n            const appearance = this._appearances.get(id);\n            if (appearance)\n                map.set(id, { id, categoryId, appearance });\n        }\n        return map;\n    }\n}\n/** This namespace and the types within it are exported strictly for use in tests.\n * @internal\n */\n(function (SubCategoriesCache) {\n    class Request {\n        get wasCanceled() { return this._canceled || this._imodel.isClosed; }\n        constructor(categoryIds, imodel, maxCategoriesPerQuery = 200) {\n            this._categoryIds = [];\n            this._result = [];\n            this._canceled = false;\n            this._curCategoryIdsIndex = 0;\n            this._imodel = imodel;\n            const catIds = [...categoryIds];\n            OrderedId64Iterable.sortArray(catIds); // sort categories, so that given the same set of categoryIds we will always create the same batches.\n            while (catIds.length !== 0) {\n                const end = (catIds.length > maxCategoriesPerQuery) ? maxCategoriesPerQuery : catIds.length;\n                const compressedIds = CompressedId64Set.compressArray(catIds.splice(0, end));\n                this._categoryIds.push(compressedIds);\n            }\n        }\n        cancel() { this._canceled = true; }\n        async dispatch() {\n            if (this.wasCanceled || this._curCategoryIdsIndex >= this._categoryIds.length) // handle case of empty category Id set...\n                return undefined;\n            try {\n                const catIds = this._categoryIds[this._curCategoryIdsIndex];\n                const result = await this._imodel.querySubCategories(catIds);\n                this._result.push(...result);\n                if (this.wasCanceled)\n                    return undefined;\n            }\n            catch {\n                // ###TODO: detect cases in which retry is warranted\n                // Note that currently, if we succeed in obtaining some pages of results and fail to retrieve another page, we will end up processing the\n                // incomplete results. Since we're not retrying, that's the best we can do.\n            }\n            // Finished with current batch of categoryIds. Dispatch the next batch if one exists.\n            if (++this._curCategoryIdsIndex < this._categoryIds.length) {\n                if (this.wasCanceled)\n                    return undefined;\n                else\n                    return this.dispatch();\n            }\n            // Even if we were canceled, we've retrieved all the rows. Might as well process them to prevent another request for some of the same rows from being enqueued.\n            return this._result;\n        }\n    }\n    SubCategoriesCache.Request = Request;\n    class QueueEntry {\n        constructor(categoryIds, func) {\n            this.categoryIds = categoryIds;\n            this.funcs = [func];\n        }\n    }\n    SubCategoriesCache.QueueEntry = QueueEntry;\n    /** A \"queue\" of SubCategoriesRequests, which consists of between 0 and 2 entries. Each entry specifies the set of category IDs to be loaded and a list of functions to be executed\n     * when loading is completed. This is used to enforce ordering of operations upon subcategories despite the need to asynchronously load them. It incidentally also provides an\n     * opportunity to reduce the number of backend requests by batching consecutive requests.\n     * Chiefly used by [[Viewport]].\n     * @internal\n     */\n    class Queue {\n        constructor() {\n            this._disposed = false;\n        }\n        /** Push a request onto the queue. The requested categories will be loaded if necessary, and then\n         * the supplied function will be invoked. Any previously-pushed requests are guaranteed to be processed before this one.\n         */\n        push(cache, categoryIds, func) {\n            if (this._disposed)\n                return;\n            else if (undefined === this._current)\n                this.pushCurrent(cache, categoryIds, func);\n            else\n                this.pushNext(categoryIds, func);\n        }\n        /** Cancel all requests and empty the queue. */\n        dispose() {\n            if (undefined !== this._request) {\n                assert(undefined !== this._current);\n                this._request.cancel();\n                this._request = undefined;\n            }\n            this._current = this._next = undefined;\n            this._disposed = true;\n        }\n        get isEmpty() {\n            return undefined === this._current && undefined === this._next;\n        }\n        pushCurrent(cache, categoryIds, func) {\n            assert(undefined === this._next);\n            assert(undefined === this._current);\n            assert(undefined === this._request);\n            this._request = cache.load(categoryIds);\n            if (undefined === this._request) {\n                // All requested categories are already loaded.\n                func();\n                return;\n            }\n            else {\n                // We need to load the requested categories before invoking the function.\n                this.processCurrent(cache, new QueueEntry(Id64.toIdSet(categoryIds, true), func));\n            }\n        }\n        processCurrent(cache, entry) {\n            assert(undefined !== this._request);\n            assert(undefined === this._current);\n            assert(undefined === this._next);\n            this._current = entry;\n            this._request.promise.then((completed) => {\n                if (this._disposed)\n                    return;\n                // Invoke all the functions which were awaiting this set of IModelConnection.Categories.\n                assert(undefined !== this._current);\n                if (completed)\n                    for (const func of this._current.funcs)\n                        func();\n                this._request = undefined;\n                this._current = undefined;\n                // If we have more requests, process them.\n                const next = this._next;\n                this._next = undefined;\n                if (undefined !== next) {\n                    this._request = cache.load(next.categoryIds);\n                    if (undefined === this._request) {\n                        // All categories loaded.\n                        for (const func of next.funcs)\n                            func();\n                    }\n                    else {\n                        // We need to load the requested categories before invoking the pending functions.\n                        this.processCurrent(cache, next);\n                    }\n                }\n            });\n        }\n        pushNext(categoryIds, func) {\n            assert(undefined !== this._current);\n            assert(undefined !== this._request);\n            if (undefined === this._next) {\n                // We have a request currently in process and none pending.\n                // We could potentially determine that this request doesn't require any categories that are not already loaded or being loaded by the current request.\n                // But we will find that out (synchronously) when current request completes, unless more requests come in. Probably not worth it.\n                this._next = new QueueEntry(Id64.toIdSet(categoryIds, true), func);\n            }\n            else {\n                // We have a request currently in process, and one or more pending. Append this one to the pending.\n                this._next.funcs.push(func);\n                for (const categoryId of Id64.iterable(categoryIds))\n                    this._next.categoryIds.add(categoryId);\n            }\n        }\n    }\n    SubCategoriesCache.Queue = Queue;\n})(SubCategoriesCache || (SubCategoriesCache = {}));\n//# sourceMappingURL=SubCategoriesCache.js.map",
      "start": 1693508119505,
      "end": 1693508119648,
      "sourcemaps": null
    }
  ]
}
