{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/geometry3d/GrowableXYArray.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module ArraysAndInterfaces\n */\nimport { Geometry } from \"../Geometry\";\nimport { GrowableXYZArray } from \"./GrowableXYZArray\";\nimport { IndexedXYCollection } from \"./IndexedXYCollection\";\nimport { Point2d, Vector2d } from \"./Point2dVector2d\";\nimport { Point3d } from \"./Point3dVector3d\";\n/** `GrowableXYArray` manages a (possibly growing) Float64Array to pack xy coordinates.\n * @public\n */\nexport class GrowableXYArray extends IndexedXYCollection {\n    /** Construct a new GrowablePoint2d array.\n     * @param numPoints initial capacity in xy tuples (default 8)\n     * @param growthFactor used by ensureCapacity to expand requested reallocation size (default 1.5)\n     */\n    constructor(numPoints = 8, growthFactor) {\n        super();\n        this._data = new Float64Array(numPoints * 2); // 2 values per point\n        this._xyInUse = 0;\n        this._xyCapacity = numPoints;\n        this._growthFactor = (undefined !== growthFactor && growthFactor >= 1.0) ? growthFactor : 1.5;\n    }\n    /** Copy xy points from source array. Does not reallocate or change active point count.\n     * @param source array to copy from\n     * @param sourceCount copy the first sourceCount points; all points if undefined\n     * @param destOffset copy to instance array starting at this point index; zero if undefined\n     * @return count and offset of points copied\n     */\n    copyData(source, sourceCount, destOffset) {\n        // validate inputs and convert from points to entries\n        let myOffset = (undefined !== destOffset) ? destOffset * 2 : 0;\n        if (myOffset < 0)\n            myOffset = 0;\n        if (myOffset >= this._data.length)\n            return { count: 0, offset: 0 };\n        let myCount = (undefined !== sourceCount) ? sourceCount * 2 : source.length;\n        if (myCount > 0) {\n            if (myCount > source.length)\n                myCount = source.length;\n            if (myOffset + myCount > this._data.length)\n                myCount = this._data.length - myOffset;\n            if (myCount % 2 !== 0)\n                myCount -= myCount % 2;\n        }\n        if (myCount <= 0)\n            return { count: 0, offset: 0 };\n        if (myCount === source.length)\n            this._data.set(source, myOffset);\n        else if (source instanceof Float64Array)\n            this._data.set(source.subarray(0, myCount), myOffset);\n        else\n            this._data.set(source.slice(0, myCount), myOffset);\n        return { count: myCount / 2, offset: myOffset / 2 };\n    }\n    /** The number of points in use. When the length is increased, the array is padded with zeroes. */\n    get length() { return this._xyInUse; }\n    set length(newLength) { this.resize(newLength, true); }\n    /** Return the number of float64 in use. */\n    get float64Length() { return this._xyInUse * 2; }\n    /** Return the raw packed data.\n     * * Note that the length of the returned Float64Array is a count of doubles, and includes the excess capacity\n     */\n    float64Data() { return this._data; }\n    /** If necessary, increase the capacity to a new pointCount.  Current coordinates and point count (length) are unchanged. */\n    ensureCapacity(pointCapacity, applyGrowthFactor = true) {\n        if (pointCapacity > this._xyCapacity) {\n            if (applyGrowthFactor)\n                pointCapacity *= this._growthFactor;\n            const prevData = this._data;\n            this._data = new Float64Array(pointCapacity * 2);\n            this.copyData(prevData, this._xyInUse);\n            this._xyCapacity = pointCapacity;\n        }\n    }\n    /**\n     * * If pointCount is less than current length, just reset current length to pointCount, effectively trimming active points but preserving original capacity.\n     * * If pointCount is greater than current length, reallocate to exactly pointCount, copy existing points, and optionally pad excess with zero.\n     * @param pointCount new number of active points in array\n     * @param padWithZero when increasing point count, whether to zero out new points (default false)\n     */\n    resize(pointCount, padWithZero) {\n        if (pointCount >= 0 && pointCount < this._xyInUse)\n            this._xyInUse = pointCount;\n        else if (pointCount > this._xyInUse) {\n            this.ensureCapacity(pointCount, false);\n            if (padWithZero ?? false)\n                this._data.fill(0, this._xyInUse * 2);\n            this._xyInUse = pointCount;\n        }\n    }\n    /**\n     * Make a copy of the (active) points in this array.\n     * (The clone does NOT get excess capacity)\n     */\n    clone() {\n        const newPoints = new GrowableXYArray(this.length);\n        newPoints.copyData(this._data, this.length);\n        newPoints._xyInUse = this.length;\n        return newPoints;\n    }\n    /** Create an array populated from\n     * Valid inputs are:\n     * * Point2d\n     * * Point3d\n     * * An array of 2 doubles\n     * * An array of 3 doubles\n     * * A GrowableXYZArray\n     * * A GrowableXYArray\n     * * Any json object satisfying Point3d.isXAndY\n     * * A Float64Array of doubles, interpreted as xyxy\n     * * An array of any of the above\n     */\n    static create(data, result) {\n        if (result) {\n            result.clear();\n        }\n        else {\n            const pointCount = typeof data[0] === \"number\" ? data.length / 2 : data.length;\n            result = new GrowableXYArray(pointCount);\n        }\n        result.pushFrom(data);\n        return result;\n    }\n    /** Restructure MultiLineStringDataVariant as array of GrowableXYZArray\n     * @deprecated in 4.x. Moved to GrowableXYZArray class.\n     */\n    static createArrayOfGrowableXYZArray(data) {\n        return GrowableXYZArray.createArrayOfGrowableXYZArray(data);\n    }\n    /** push a point to the end of the array */\n    push(toPush) {\n        this.pushXY(toPush.x, toPush.y);\n    }\n    /** push all points of an array */\n    pushAll(points) {\n        this.ensureCapacity(this._xyInUse + points.length, false);\n        for (const p of points)\n            this.push(p);\n    }\n    /** push all points of an array */\n    pushAllXYAndZ(points) {\n        this.ensureCapacity(this._xyInUse + points.length, false);\n        if (points instanceof GrowableXYZArray) {\n            const xyzBuffer = points.float64Data();\n            const n = points.length * 3;\n            for (let i = 0; i + 2 < n; i += 3)\n                this.pushXY(xyzBuffer[i], xyzBuffer[i + 1]);\n        }\n        else {\n            for (const p of points)\n                this.pushXY(p.x, p.y);\n        }\n    }\n    /** Push points from variant sources.\n     * Valid inputs are:\n     * * Point2d\n     * * Point3d\n     * * An array of 2 doubles\n     * * A GrowableXYArray\n     * * A GrowableXYZArray\n     * * Any json object satisfying Point3d.isXAndY\n     * * A Float64Array of doubles, interpreted as xyxy\n     * * An array of any of the above\n     */\n    pushFrom(p) {\n        if (p instanceof Point3d) {\n            this.pushXY(p.x, p.y);\n        }\n        else if (p instanceof GrowableXYZArray) {\n            this.pushAllXYAndZ(p);\n        }\n        else if (p instanceof Point2d) {\n            this.pushXY(p.x, p.y);\n        }\n        else if (Geometry.isNumberArray(p, 3) || p instanceof Float64Array) {\n            const xyToAdd = Math.trunc(p.length / 2);\n            this.ensureCapacity(this._xyInUse + xyToAdd, false);\n            this.copyData(p, xyToAdd, this._xyInUse);\n            this._xyInUse += xyToAdd;\n        }\n        else if (Geometry.isNumberArray(p, 2)) {\n            this.pushXY(p[0], p[1]);\n        }\n        else if (Array.isArray(p)) {\n            // direct recursion re-wraps p and goes infinite. Unroll here.\n            for (const q of p)\n                this.pushFrom(q);\n        }\n        else if (Point3d.isXAndY(p)) {\n            this.pushXY(p.x, p.y);\n        }\n        else if (p instanceof IndexedXYCollection) {\n            const n = p.length;\n            this.ensureCapacity(this._xyInUse + n, false);\n            for (let i = 0; i < n; i++)\n                this.pushXY(p.getXAtUncheckedPointIndex(i), p.getYAtUncheckedPointIndex(i));\n        }\n    }\n    /**\n     * Replicate numWrap xy values from the front of the array as new values at the end.\n     * @param numWrap number of xy values to replicate\n     */\n    pushWrap(numWrap) {\n        if (this._xyInUse >= numWrap) {\n            this.ensureCapacity(this._xyInUse + numWrap, false);\n            for (let i = 0; i < numWrap; i++) {\n                const k = 2 * i;\n                this.pushXY(this._data[k], this._data[k + 1]);\n            }\n        }\n    }\n    /** push a point given by x,y coordinates */\n    pushXY(x, y) {\n        this.ensureCapacity(this._xyInUse + 1);\n        const index = this._xyInUse * 2;\n        this._data[index] = x;\n        this._data[index + 1] = y;\n        this._xyInUse++;\n    }\n    /** Remove one point from the back.\n     * * NOTE that (in the manner of std::vector native) this is \"just\" removing the point -- no point is NOT returned.\n     * * Use `back ()` to get the last x,y assembled into a `Point2d `\n     */\n    pop() {\n        if (this._xyInUse > 0)\n            this._xyInUse--;\n    }\n    /**\n     * Test if index is valid for an xy (point or vector) within this array\n     * @param index xy index to test.\n     */\n    isIndexValid(index) {\n        if (index >= this._xyInUse || index < 0)\n            return false;\n        return true;\n    }\n    /**\n     * Clear all xy data, but leave capacity unchanged.\n     */\n    clear() {\n        this._xyInUse = 0;\n    }\n    /**\n     * Get a point by index, strongly typed as a Point2d.  This is unchecked.  Use atPoint2dIndex to have validity test.\n     * @param pointIndex index to access\n     * @param result optional result\n     */\n    getPoint2dAtUncheckedPointIndex(pointIndex, result) {\n        const index = 2 * pointIndex;\n        return Point2d.create(this._data[index], this._data[index + 1], result);\n    }\n    /**\n     * Get x coordinate by point index, with no index checking\n     * @param pointIndex index to access\n     */\n    getXAtUncheckedPointIndex(pointIndex) {\n        return this._data[2 * pointIndex];\n    }\n    /**\n     * Get y coordinate by point index, with no index checking\n     * @param pointIndex index to access\n     */\n    getYAtUncheckedPointIndex(pointIndex) {\n        return this._data[2 * pointIndex + 1];\n    }\n    /**\n     * Gather all points as a Point2d[]\n     */\n    getPoint2dArray() {\n        const n = 2 * this._xyInUse;\n        const result = [];\n        const data = this._data;\n        for (let i = 0; i < n; i += 2)\n            result.push(Point2d.create(data[i], data[i + 1]));\n        return result;\n    }\n    /** copy xy into strongly typed Point2d */\n    getPoint2dAtCheckedPointIndex(pointIndex, result) {\n        if (this.isIndexValid(pointIndex)) {\n            const index = 2 * pointIndex;\n            return Point2d.create(this._data[index], this._data[index + 1], result);\n        }\n        return undefined;\n    }\n    /** copy xy into strongly typed Vector2d */\n    getVector2dAtCheckedVectorIndex(vectorIndex, result) {\n        if (this.isIndexValid(vectorIndex)) {\n            const index = 2 * vectorIndex;\n            return Vector2d.create(this._data[index], this._data[index + 1], result);\n        }\n        return undefined;\n    }\n    /**\n     * Read coordinates from source array, place them at index within this array.\n     * @param destIndex point index where coordinates are to be placed in this array\n     * @param source source array\n     * @param sourceIndex point index in source array\n     * @returns true if destIndex and sourceIndex are both valid.\n     */\n    transferFromGrowableXYArray(destIndex, source, sourceIndex) {\n        if (this.isIndexValid(destIndex) && source.isIndexValid(sourceIndex)) {\n            const i = destIndex * 2;\n            const j = sourceIndex * 2;\n            this._data[i] = source._data[j];\n            this._data[i + 1] = source._data[j + 1];\n            return true;\n        }\n        return false;\n    }\n    /**\n     * push coordinates from the source array to the end of this array.\n     * @param source source array\n     * @param sourceIndex xy index within the source.  If undefined, push entire contents of source\n     * @returns number of points pushed.\n     */\n    pushFromGrowableXYArray(source, sourceIndex) {\n        // full array push  . . .\n        if (sourceIndex === undefined) {\n            const numXYAdd = source.length;\n            this.ensureCapacity(this.length + numXYAdd, false);\n            this.copyData(source._data, numXYAdd, this.length);\n            this._xyInUse += numXYAdd;\n            return numXYAdd;\n        }\n        // single point push . . .\n        if (source.isIndexValid(sourceIndex)) {\n            const j = sourceIndex * 2;\n            this.pushXY(source._data[j], source._data[j + 1]);\n            return 1;\n        }\n        return 0;\n    }\n    /**\n     * * Compute a point at fractional coordinate between points i and j of source\n     * * push onto this array.\n     */\n    pushInterpolatedFromGrowableXYArray(source, i, fraction, j) {\n        if (source.isIndexValid(i) && source.isIndexValid(j)) {\n            const fraction0 = 1.0 - fraction;\n            const data = source._data;\n            i = 2 * i;\n            j = 2 * j;\n            this.pushXY(fraction0 * data[i] + fraction * data[j], fraction0 * data[i + 1] + fraction * data[j + 1]);\n        }\n    }\n    /**\n     * Create an array of xy points from source xyz points.\n     * @param source source array of xyz\n     * @param transform optional transform to apply to xyz points.\n     * @param dest optional result.\n     */\n    static createFromGrowableXYZArray(source, transform, dest) {\n        const numPoints = source.length;\n        if (!dest)\n            dest = new GrowableXYArray(numPoints);\n        else {\n            dest.ensureCapacity(numPoints, false);\n            dest.clear();\n        }\n        if (transform) {\n            const packedXYZ = source.float64Data();\n            const nDouble = 3 * numPoints;\n            let x, y, z;\n            for (let i = 0; i < nDouble; i += 3) {\n                x = packedXYZ[i];\n                y = packedXYZ[i + 1];\n                z = packedXYZ[i + 2];\n                dest.pushXY(transform.multiplyComponentXYZ(0, x, y, z), transform.multiplyComponentXYZ(1, x, y, z));\n            }\n        }\n        else {\n            dest.pushAllXYAndZ(source);\n        }\n        return dest;\n    }\n    /**\n     * Return the first point, or undefined if the array is empty.\n     */\n    front(result) {\n        if (this._xyInUse === 0)\n            return undefined;\n        return this.getPoint2dAtUncheckedPointIndex(0, result);\n    }\n    /**\n     * Return the last point, or undefined if the array is empty.\n     */\n    back(result) {\n        if (this._xyInUse < 1)\n            return undefined;\n        return this.getPoint2dAtUncheckedPointIndex(this._xyInUse - 1, result);\n    }\n    /**\n     * Set the coordinates of a single point.\n     * @param pointIndex index of point to set\n     * @param value coordinates to set\n     */\n    setAtCheckedPointIndex(pointIndex, value) {\n        if (!this.isIndexValid(pointIndex))\n            return false;\n        const index = pointIndex * 2;\n        this._data[index] = value.x;\n        this._data[index + 1] = value.y;\n        return true;\n    }\n    /**\n     * Set the coordinates of a single point given as coordinates.\n     * @param pointIndex index of point to set\n     * @param x x coordinate\n     * @param y y coordinate\n     */\n    setXYAtCheckedPointIndex(pointIndex, x, y) {\n        if (!this.isIndexValid(pointIndex))\n            return false;\n        const index = pointIndex * 2;\n        this._data[index] = x;\n        this._data[index + 1] = y;\n        return true;\n    }\n    /**\n     * Set the coordinates of a single point given as coordinates.\n     * @deprecated in 3.x. Use setXYAtCheckedPointIndex instead\n     */\n    setXYZAtCheckedPointIndex(pointIndex, x, y) {\n        return this.setXYAtCheckedPointIndex(pointIndex, x, y);\n    }\n    /**\n     * Copy all points into a simple array of Point3d with given z.\n     */\n    getPoint3dArray(z = 0) {\n        const n = 2 * this._xyInUse;\n        const result = [];\n        const data = this._data;\n        for (let i = 0; i < n; i += 2)\n            result.push(Point3d.create(data[i], data[i + 1], z));\n        return result;\n    }\n    /** reverse the order of points. */\n    reverseInPlace() {\n        const n = this.length;\n        let j0, j1;\n        let a;\n        const data = this._data;\n        for (let i0 = 0, i1 = n - 1; i0 < i1; i0++, i1--) {\n            j0 = 2 * i0;\n            j1 = 2 * i1;\n            a = data[j0];\n            data[j0] = data[j1];\n            data[j1] = a;\n            j0++;\n            j1++;\n            a = data[j0];\n            data[j0] = data[j1];\n            data[j1] = a;\n        }\n    }\n    /** multiply each point by the transform, replace values. */\n    multiplyTransformInPlace(transform) {\n        const data = this._data;\n        const nDouble = this.float64Length;\n        const coffs = transform.matrix.coffs;\n        const origin = transform.origin;\n        const x0 = origin.x;\n        const y0 = origin.y;\n        let x = 0;\n        let y = 0;\n        for (let i = 0; i + 1 < nDouble; i += 2) {\n            x = data[i];\n            y = data[i + 1];\n            data[i] = coffs[0] * x + coffs[1] * y + x0;\n            data[i + 1] = coffs[3] * x + coffs[4] * y + y0;\n        }\n    }\n    /** multiply each xy (as a vector) by matrix, replace values. */\n    multiplyMatrix3dInPlace(matrix) {\n        const data = this._data;\n        const nDouble = this.float64Length;\n        const coffs = matrix.coffs;\n        let x = 0;\n        let y = 0;\n        for (let i = 0; i + 1 < nDouble; i += 2) {\n            x = data[i];\n            y = data[i + 1];\n            data[i] = coffs[0] * x + coffs[1] * y;\n            data[i + 1] = coffs[3] * x + coffs[4] * y;\n        }\n    }\n    /** multiply each point by the transform, replace values. */\n    tryTransformInverseInPlace(transform) {\n        const data = this._data;\n        const nDouble = this.float64Length;\n        const matrix = transform.matrix;\n        matrix.computeCachedInverse(true);\n        const coffs = matrix.inverseCoffs;\n        if (!coffs)\n            return false;\n        const origin = transform.origin;\n        const x0 = origin.x;\n        const y0 = origin.y;\n        let x = 0;\n        let y = 0;\n        for (let i = 0; i + 1 < nDouble; i += 2) {\n            x = data[i] - x0;\n            y = data[i + 1] - y0;\n            data[i] = coffs[0] * x + coffs[1] * y;\n            data[i + 1] = coffs[3] * x + coffs[4] * y;\n        }\n        return true;\n    }\n    /** Extend a `Range2d`, optionally transforming the points. */\n    extendRange(rangeToExtend, transform) {\n        const numDouble = this.float64Length;\n        const data = this._data;\n        if (transform) {\n            for (let i = 0; i + 1 < numDouble; i += 2)\n                rangeToExtend.extendTransformedXY(transform, data[i], data[i + 1]);\n        }\n        else {\n            for (let i = 0; i + 1 < numDouble; i += 2)\n                rangeToExtend.extendXY(data[i], data[i + 1]);\n        }\n    }\n    /** sum the lengths of segments between points. */\n    sumLengths() {\n        let sum = 0.0;\n        const n = 2 * (this._xyInUse - 1); // Length already takes into account what specifically is in use\n        const data = this._data;\n        for (let i = 0; i < n; i += 2)\n            sum += Geometry.hypotenuseXY(data[i + 2] - data[i], data[i + 3] - data[i + 1]);\n        return sum;\n    }\n    /**\n     * Multiply each x,y by the scale factor.\n     * @param factor\n     */\n    scaleInPlace(factor) {\n        if (this._data) {\n            const numFloat = this.float64Length;\n            for (let i = 0; i < numFloat; i++)\n                this._data[i] = this._data[i] * factor;\n        }\n    }\n    /** Compute a point at fractional coordinate between points i and j */\n    interpolate(i, fraction, j, result) {\n        if (this.isIndexValid(i) && this.isIndexValid(j)) {\n            const fraction0 = 1.0 - fraction;\n            const data = this._data;\n            i = 2 * i;\n            j = 2 * j;\n            return Point2d.create(fraction0 * data[i] + fraction * data[j], fraction0 * data[i + 1] + fraction * data[j + 1], result);\n        }\n        return undefined;\n    }\n    /** Sum the signed areas of the projection to xy plane */\n    areaXY() {\n        let area = 0.0;\n        const n = 2 * this._xyInUse; // float count !!\n        if (n > 4) {\n            const x0 = this._data[n - 2];\n            const y0 = this._data[n - 1];\n            let dx1 = this._data[0] - x0;\n            let dy1 = this._data[1] - y0;\n            let dx2 = 0;\n            let dy2 = 0;\n            for (let i = 2; i < n; i += 2, dx1 = dx2, dy1 = dy2) {\n                dx2 = this._data[i] - x0;\n                dy2 = this._data[i + 1] - y0;\n                area += Geometry.crossProductXYXY(dx1, dy1, dx2, dy2);\n            }\n        }\n        return 0.5 * area;\n    }\n    /** Compute a vector from index origin i to indexed target j  */\n    vectorIndexIndex(i, j, result) {\n        if (!this.isIndexValid(i) || !this.isIndexValid(j))\n            return undefined;\n        const data = this._data;\n        i = 2 * i;\n        j = 2 * j;\n        return Vector2d.create(data[j] - data[i], data[j + 1] - data[i + 1], result);\n    }\n    /** Compute a vector from origin to indexed target j */\n    vectorXAndYIndex(origin, j, result) {\n        if (this.isIndexValid(j)) {\n            const data = this._data;\n            j = 2 * j;\n            return Vector2d.create(data[j] - origin.x, data[j + 1] - origin.y, result);\n        }\n        return undefined;\n    }\n    /** Compute the cross product of vectors from from indexed origin to indexed targets i and j */\n    crossProductIndexIndexIndex(originIndex, targetAIndex, targetBIndex) {\n        if (this.isIndexValid(originIndex) && this.isIndexValid(targetAIndex) && this.isIndexValid(targetBIndex)) {\n            const i = originIndex * 2;\n            const j = targetAIndex * 2;\n            const k = targetBIndex * 2;\n            const data = this._data;\n            return Geometry.crossProductXYXY(data[j] - data[i], data[j + 1] - data[i + 1], data[k] - data[i], data[k + 1] - data[i + 1]);\n        }\n        return undefined;\n    }\n    /** Compute the cross product of vectors from from origin to indexed targets i and j */\n    crossProductXAndYIndexIndex(origin, targetAIndex, targetBIndex) {\n        if (this.isIndexValid(targetAIndex) && this.isIndexValid(targetBIndex)) {\n            const j = targetAIndex * 2;\n            const k = targetBIndex * 2;\n            const data = this._data;\n            return Geometry.crossProductXYXY(data[j] - origin.x, data[j + 1] - origin.y, data[k] - origin.x, data[k + 1] - origin.y);\n        }\n        return undefined;\n    }\n    /** Return the distance between two points in the array. */\n    distance(i, j) {\n        if (this.isIndexValid(i) && this.isIndexValid(j)) {\n            const i0 = 2 * i;\n            const j0 = 2 * j;\n            return Geometry.hypotenuseXY(this._data[j0] - this._data[i0], this._data[j0 + 1] - this._data[i0 + 1]);\n        }\n        return undefined;\n    }\n    /** Return the distance between an array point and the input point. */\n    distanceIndexToPoint(i, spacePoint) {\n        if (this.isIndexValid(i)) {\n            const i0 = 2 * i;\n            return Geometry.hypotenuseXY(spacePoint.x - this._data[i0], spacePoint.y - this._data[i0 + 1]);\n        }\n        return undefined;\n    }\n    /** Test for nearly equal arrays. */\n    static isAlmostEqual(dataA, dataB) {\n        if (dataA && dataB) {\n            if (dataA.length !== dataB.length)\n                return false;\n            for (let i = 0; i < dataA.length; i++)\n                if (!dataA.getPoint2dAtUncheckedPointIndex(i).isAlmostEqual(dataB.getPoint2dAtUncheckedPointIndex(i)))\n                    return false;\n            return true;\n        }\n        // if both are null it is equal, otherwise unequal\n        return (!dataA && !dataB);\n    }\n    /** Return an array of block indices sorted per compareLexicalBlock function */\n    sortIndicesLexical() {\n        const n = this._xyInUse;\n        // let numCompare = 0;\n        const result = new Uint32Array(n);\n        for (let i = 0; i < n; i++)\n            result[i] = i;\n        result.sort((blockIndexA, blockIndexB) => {\n            // numCompare++;\n            return this.compareLexicalBlock(blockIndexA, blockIndexB);\n        });\n        // console.log (n, numCompare);\n        return result;\n    }\n    /** compare two blocks in simple lexical order. */\n    compareLexicalBlock(ia, ib) {\n        let ax = 0;\n        let bx = 0;\n        for (let i = 0; i < 2; i++) {\n            ax = this._data[ia * 2 + i];\n            bx = this._data[ib * 2 + i];\n            if (ax > bx)\n                return 1;\n            if (ax < bx)\n                return -1;\n        }\n        return ia - ib; // so original order is maintained among duplicates !!!!\n    }\n    /** Access a single double at offset within a block.  This has no index checking. */\n    component(pointIndex, componentIndex) {\n        return this._data[2 * pointIndex + componentIndex];\n    }\n    /** Toleranced equality test */\n    isAlmostEqual(other, tolerance = Geometry.smallMetricDistance) {\n        const numXY = this._xyInUse;\n        if (other._xyInUse !== numXY)\n            return false;\n        const dataA = this._data;\n        const dataB = other._data;\n        for (let i = 0; i < 2 * numXY; i++) {\n            if (Math.abs(dataA[i] - dataB[i]) > tolerance)\n                return false;\n        }\n        return true;\n    }\n}\n//# sourceMappingURL=GrowableXYArray.js.map",
      "start": 1693508123065,
      "end": 1693508123262,
      "sourcemaps": null
    }
  ]
}
