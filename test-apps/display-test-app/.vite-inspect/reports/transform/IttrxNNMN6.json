{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend-devtools/lib/esm/tools/FrustumDecoration.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tools\n */\nimport { Point3d } from \"@itwin/core-geometry\";\nimport { ColorByName, ColorDef, LinePixels, Npc } from \"@itwin/core-common\";\nimport { CoordSystem, GraphicType, IModelApp, Tool, } from \"@itwin/core-frontend\";\nimport { parseToggle } from \"./parseToggle\";\n/**\n * Decorates the viewport with a graphical depiction of a Frustum.\n * This is obviously only useful when drawn inside a viewport using a *different* Frustum.\n * Options for doing so include:\n *  - Having more than one viewport, and drawing the frustum of one viewport inside the other viewports; and\n *  - Allowing the user to take a snapshot of the current frustum, then navigate the view to inspect it within the same viewport.\n */\nclass FrustumDecoration {\n    constructor(vp, view, _options) {\n        this._options = _options;\n        this._worldFrustum = vp.getFrustum(CoordSystem.World, false);\n        this._adjustedWorldFrustum = vp.getFrustum(CoordSystem.World, true);\n        this._preloadFrustum = vp.viewingSpace.getPreloadFrustum();\n        this._npcFrustum = vp.getFrustum(CoordSystem.Npc, true);\n        this._worldToNpcMap = vp.viewingSpace.worldToNpcMap.clone();\n        this._eyePoint = view.camera.getEyePoint().clone();\n        this._focalPlane = vp.worldToNpc(view.getTargetPoint()).z;\n        this._isCameraOn = vp.isCameraOn;\n    }\n    static create(vp, options) {\n        const view = vp.view.isSpatialView() ? vp.view : undefined;\n        return undefined !== view ? new FrustumDecoration(vp, view, options) : undefined;\n    }\n    decorate(context) {\n        const builder = context.createGraphicBuilder(GraphicType.WorldDecoration);\n        if (this._isCameraOn)\n            FrustumDecoration.drawEyePositionAndFocalPlane(builder, this._npcFrustum, this._worldToNpcMap, this._eyePoint, this._focalPlane, context.viewport);\n        FrustumDecoration.drawFrustumBox(builder, this._worldFrustum, false, context.viewport); // show original frustum...\n        FrustumDecoration.drawFrustumBox(builder, this._adjustedWorldFrustum, true, context.viewport); // show adjusted frustum...\n        const options = this._options;\n        if (options !== undefined) {\n            if (options.showPreloadFrustum)\n                FrustumDecoration.drawPreloadFrustum(builder, this._preloadFrustum);\n            if (options?.showBackgroundIntersections) {\n                const backgroundMapGeometry = context.viewport.view.displayStyle.getBackgroundMapGeometry();\n                if (backgroundMapGeometry)\n                    backgroundMapGeometry.addFrustumDecorations(builder, this._adjustedWorldFrustum);\n            }\n        }\n        context.addDecorationFromBuilder(builder);\n    }\n    static drawPreloadFrustum(builder, frustum) {\n        const preloadColor = ColorDef.create(ColorByName.coral);\n        builder.setSymbology(preloadColor, preloadColor, 1, LinePixels.Code2);\n        builder.addFrustum(frustum);\n    }\n    static drawFrustumBox(builder, frustum, adjustedBox, vp) {\n        const backPts = this.getPlanePts(frustum.points, false); // back plane\n        const frontPts = this.getPlanePts(frustum.points, true); // front plane\n        const bgColor = vp.view.backgroundColor;\n        const backAndBottomColor = ColorDef.red.adjustedForContrast(bgColor);\n        const frontAndTopLeftColor = ColorDef.blue.adjustedForContrast(bgColor);\n        const frontAndTopRightColor = ColorDef.green.adjustedForContrast(bgColor);\n        const edgeWeight = adjustedBox ? 2 : 1;\n        const edgeStyle = adjustedBox ? LinePixels.Solid : LinePixels.Code2;\n        // Back plane\n        builder.setSymbology(backAndBottomColor, ColorDef.black, edgeWeight, edgeStyle);\n        builder.addLineString(backPts);\n        // Front plane\n        builder.setSymbology(frontAndTopLeftColor, ColorDef.black, edgeWeight, edgeStyle);\n        builder.addLineString(frontPts);\n        // Bottom edge\n        builder.setSymbology(backAndBottomColor, ColorDef.black, edgeWeight, edgeStyle);\n        builder.addLineString(this.getEdgePts(backPts, frontPts, 0));\n        builder.addLineString(this.getEdgePts(backPts, frontPts, 1));\n        // Top edge\n        builder.setSymbology(frontAndTopRightColor, ColorDef.black, edgeWeight, edgeStyle);\n        builder.addLineString(this.getEdgePts(backPts, frontPts, 2));\n        builder.setSymbology(frontAndTopLeftColor, ColorDef.black, edgeWeight, edgeStyle);\n        builder.addLineString(this.getEdgePts(backPts, frontPts, 3));\n    }\n    static getEdgePts(startPts, endPts, index) {\n        return [\n            startPts[index],\n            endPts[index],\n        ];\n    }\n    static getPlanePts(frustPts, front) {\n        const baseIndex = front ? Npc._001 : Npc._000;\n        const planePts = [\n            frustPts[baseIndex + Npc._000],\n            frustPts[baseIndex + Npc._100],\n            frustPts[baseIndex + Npc._110],\n            frustPts[baseIndex + Npc._010],\n        ];\n        planePts.push(planePts[0]);\n        return planePts;\n    }\n    static drawEyePositionAndFocalPlane(builder, npcFrustum, worldToNpcMap, eyePoint, focusPlaneNpc, vp) {\n        // Eye position...\n        const contrastColor = vp.getContrastToBackgroundColor();\n        builder.setSymbology(contrastColor, ColorDef.black, 8);\n        builder.addPointString([eyePoint]);\n        // Focal plane...\n        const focalPtsNpc = FrustumDecoration.getPlanePts(npcFrustum.points, false);\n        const focalPtsWorld = [];\n        for (const npcPt of focalPtsNpc)\n            focalPtsWorld.push(Point3d.create(npcPt.x, npcPt.y, focusPlaneNpc));\n        worldToNpcMap.transform1.multiplyPoint3dArrayQuietNormalize(focalPtsWorld);\n        const bgColor = vp.view.backgroundColor;\n        const focalPlaneColor = ColorDef.green.adjustedForContrast(bgColor);\n        const focalTransColor = focalPlaneColor.withTransparency(100);\n        builder.setSymbology(focalPlaneColor, focalTransColor, 2);\n        builder.addLineString(focalPtsWorld);\n        builder.addShape(focalPtsWorld);\n    }\n}\n/**\n * Decorates the viewport with a graphical depiction of a Frustum.\n * This is obviously only useful when drawn inside a viewport using a *different* Frustum.\n * Options for doing so include:\n *  - Having more than one viewport, and drawing the frustum of one viewport inside the other viewports; and\n *  - Allowing the user to take a snapshot of the current frustum, then navigate the view to inspect it within the same viewport.\n *  @beta\n */\nexport class FrustumDecorator {\n    constructor(vp, options) {\n        /** This will allow the render system to cache and reuse the decorations created by this decorator's decorate() method. */\n        this.useCachedDecorations = true;\n        this._decoration = FrustumDecoration.create(vp, options);\n    }\n    decorate(context) {\n        if (undefined !== this._decoration)\n            this._decoration.decorate(context);\n    }\n    /** Add the decoration to the specified viewport. */\n    static enable(vp, options) {\n        FrustumDecorator.disable();\n        FrustumDecorator._instance = new FrustumDecorator(vp, options);\n        IModelApp.viewManager.addDecorator(FrustumDecorator._instance);\n    }\n    /** Remove the decoration from the specified viewport. */\n    static disable() {\n        const instance = FrustumDecorator._instance;\n        if (undefined !== instance) {\n            IModelApp.viewManager.dropDecorator(instance);\n            FrustumDecorator._instance = undefined;\n        }\n    }\n    static get isEnabled() { return undefined !== FrustumDecorator._instance; }\n}\n/** Enable (\"ON\"), disable (\"OFF\"), or toggle (\"TOGGLE\" or omitted) the [[FrustumDecorator]].\n * @beta\n */\nclass ToggleFrustumSnapshotTool extends Tool {\n    static get minArgs() { return 0; }\n    static get maxArgs() { return 2; }\n    async run(enable, showPreloadFrustum, showBackgroundIntersections) {\n        const vp = IModelApp.viewManager.selectedView;\n        if (undefined === vp)\n            return true;\n        if (undefined === enable)\n            enable = !FrustumDecorator.isEnabled;\n        if (enable !== FrustumDecorator.isEnabled) {\n            if (enable) {\n                FrustumDecorator.enable(vp, { showPreloadFrustum, showBackgroundIntersections });\n                vp.onChangeView.addOnce(() => FrustumDecorator.disable());\n            }\n            else {\n                FrustumDecorator.disable();\n            }\n        }\n        return true;\n    }\n    async parseAndRun(...args) {\n        let showPreload, showBackgroundIntersections, enable;\n        for (const arg of args) {\n            if (arg === \"preload\")\n                showPreload = true;\n            else if (arg === \"background\")\n                showBackgroundIntersections = true;\n            else\n                enable = parseToggle(arg);\n        }\n        if (typeof enable !== \"string\")\n            await this.run(enable, showPreload, showBackgroundIntersections);\n        return true;\n    }\n}\nToggleFrustumSnapshotTool.toolId = \"ToggleFrustumSnapshot\";\nexport { ToggleFrustumSnapshotTool };\n/**\n * Decorates the viewport with a graphical depiction of a Frustum from the currently selected viewport.\n * Only useful when more than one spatial viewport is open.\n */\nclass SelectedViewFrustumDecoration {\n    constructor(vp, _options) {\n        this._options = _options;\n        /** This will allow the render system to cache and reuse the decorations created by this decorator's decorate() method. */\n        this.useCachedDecorations = true;\n        this._targetVp = vp;\n        this._removeDecorationListener = IModelApp.viewManager.addDecorator(this);\n        this._removeViewChangedListener = vp.onViewChanged.addListener(this.onViewChanged, this); // eslint-disable-line @typescript-eslint/unbound-method\n        IModelApp.viewManager.invalidateCachedDecorationsAllViews(this);\n    }\n    stop() {\n        if (this._removeDecorationListener) {\n            this._removeDecorationListener();\n            this._removeDecorationListener = undefined;\n        }\n        if (this._removeViewChangedListener) {\n            this._removeViewChangedListener();\n            this._removeViewChangedListener = undefined;\n        }\n        IModelApp.viewManager.invalidateCachedDecorationsAllViews(this);\n    }\n    onViewChanged(targetVp) {\n        if (targetVp !== this._targetVp)\n            return;\n        const decorator = SelectedViewFrustumDecoration._decorator;\n        if (undefined !== decorator) {\n            for (const vp of IModelApp.viewManager) {\n                if (vp !== this._targetVp)\n                    vp.invalidateCachedDecorations(decorator);\n            }\n        }\n    }\n    decorate(context) {\n        const vp = context.viewport;\n        if (!this._targetVp.view.isSpatialView() || vp === this._targetVp || !vp.view.isSpatialView())\n            return;\n        const builder = context.createGraphicBuilder(GraphicType.WorldDecoration);\n        if (this._targetVp.isCameraOn) {\n            const npcFrustum = this._targetVp.getFrustum(CoordSystem.Npc, true);\n            const focalPlane = this._targetVp.worldToNpc(this._targetVp.view.getTargetPoint()).z;\n            FrustumDecoration.drawEyePositionAndFocalPlane(builder, npcFrustum, this._targetVp.viewingSpace.worldToNpcMap, this._targetVp.view.camera.getEyePoint(), focalPlane, context.viewport);\n        }\n        const worldFrustum = this._targetVp.getFrustum(CoordSystem.World, false);\n        const adjustedWorldFrustum = this._targetVp.getFrustum(CoordSystem.World, true);\n        FrustumDecoration.drawFrustumBox(builder, worldFrustum, false, context.viewport); // show original frustum...\n        FrustumDecoration.drawFrustumBox(builder, adjustedWorldFrustum, true, context.viewport); // show adjusted frustum...\n        if (this._options && this._options.showPreloadFrustum)\n            FrustumDecoration.drawPreloadFrustum(builder, context.viewport.viewingSpace.getPreloadFrustum());\n        context.addDecorationFromBuilder(builder);\n    }\n    // Returns true if decoration becomes enabled.\n    static toggle(vp, enabled) {\n        if (undefined !== enabled) {\n            const alreadyEnabled = undefined !== SelectedViewFrustumDecoration._decorator;\n            if (enabled === alreadyEnabled)\n                return alreadyEnabled;\n        }\n        if (undefined === SelectedViewFrustumDecoration._decorator) {\n            SelectedViewFrustumDecoration._decorator = new SelectedViewFrustumDecoration(vp);\n            return true;\n        }\n        else {\n            SelectedViewFrustumDecoration._decorator.stop();\n            SelectedViewFrustumDecoration._decorator = undefined;\n            return false;\n        }\n    }\n}\n/** Enable (\"ON\"), disable (\"OFF\"), or toggle (\"TOGGLE\" or omitted) the selected view frustum decoration.\n * @beta\n */\nclass ToggleSelectedViewFrustumTool extends Tool {\n    static get minArgs() { return 0; }\n    static get maxArgs() { return 1; }\n    async run(enable) {\n        const vp = IModelApp.viewManager.selectedView;\n        if (undefined === vp || !vp.view.isSpatialView())\n            return false;\n        if (SelectedViewFrustumDecoration.toggle(vp, enable)) {\n            const remove = vp.onChangeView.addListener((_vp, prev) => {\n                if (!prev.hasSameCoordinates(vp.view)) {\n                    SelectedViewFrustumDecoration.toggle(vp, false);\n                    remove();\n                }\n            });\n        }\n        return true;\n    }\n    async parseAndRun(...args) {\n        const enable = parseToggle(args[0]);\n        if (typeof enable !== \"string\")\n            await this.run(enable);\n        return true;\n    }\n}\nToggleSelectedViewFrustumTool.toolId = \"ToggleSelectedViewFrustum\";\nexport { ToggleSelectedViewFrustumTool };\nclass ShadowFrustumDecoration {\n    constructor(vp) {\n        /** This will allow the render system to cache and reuse the decorations created by this decorator's decorate() method. */\n        this.useCachedDecorations = true;\n        this._targetVp = vp;\n        const removeDecorator = IModelApp.viewManager.addDecorator(this);\n        const removeOnRender = vp.onRender.addListener((_) => this.onRender());\n        this._cleanup = () => {\n            removeDecorator();\n            removeOnRender();\n        };\n        IModelApp.viewManager.invalidateCachedDecorationsAllViews(this);\n    }\n    stop() {\n        if (undefined !== this._cleanup) {\n            this._cleanup();\n            this._cleanup = undefined;\n        }\n        IModelApp.viewManager.invalidateCachedDecorationsAllViews(this);\n    }\n    onRender() {\n        const decorator = ShadowFrustumDecoration._instance;\n        if (undefined !== decorator) {\n            for (const vp of IModelApp.viewManager) {\n                if (vp !== this._targetVp)\n                    vp.invalidateCachedDecorations(decorator);\n            }\n        }\n    }\n    decorate(context) {\n        const frustum = this._targetVp.target.debugControl.shadowFrustum;\n        if (undefined === frustum)\n            return;\n        const thisVp = context.viewport;\n        if (thisVp === this._targetVp || !thisVp.view.isSpatialView())\n            return;\n        const builder = context.createGraphicBuilder(GraphicType.WorldDecoration);\n        FrustumDecoration.drawFrustumBox(builder, frustum, false, thisVp);\n        context.addDecorationFromBuilder(builder);\n    }\n    static toggle(vp, enabled) {\n        const instance = ShadowFrustumDecoration._instance;\n        if (undefined !== enabled) {\n            const alreadyEnabled = undefined !== instance;\n            if (enabled === alreadyEnabled)\n                return;\n        }\n        if (undefined === instance) {\n            ShadowFrustumDecoration._instance = new ShadowFrustumDecoration(vp);\n        }\n        else {\n            instance.stop();\n            ShadowFrustumDecoration._instance = undefined;\n        }\n    }\n}\n/** Toggle visualization of the selected viewport's shadow frustum in all other viewports.\n * @beta\n */\nclass ToggleShadowFrustumTool extends Tool {\n    static get minArgs() { return 0; }\n    static get maxArgs() { return 1; }\n    async run(enable) {\n        const vp = IModelApp.viewManager.selectedView;\n        if (undefined !== vp && vp.view.isSpatialView())\n            ShadowFrustumDecoration.toggle(vp, enable);\n        return true;\n    }\n    async parseAndRun(...args) {\n        const enable = parseToggle(args[0]);\n        if (typeof enable !== \"string\")\n            await this.run(enable);\n        return true;\n    }\n}\nToggleShadowFrustumTool.toolId = \"ToggleShadowFrustum\";\nexport { ToggleShadowFrustumTool };\n//# sourceMappingURL=FrustumDecoration.js.map",
      "start": 1693508122641,
      "end": 1693508122741,
      "sourcemaps": null
    }
  ]
}
