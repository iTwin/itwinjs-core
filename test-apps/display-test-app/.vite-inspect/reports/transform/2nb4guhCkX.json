{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/solid/Cone.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Solid\n */\nimport { Arc3d } from \"../curve/Arc3d\";\nimport { LineString3d } from \"../curve/LineString3d\";\nimport { Loop } from \"../curve/Loop\";\nimport { Geometry } from \"../Geometry\";\nimport { Matrix3d } from \"../geometry3d/Matrix3d\";\nimport { Plane3dByOriginAndVectors } from \"../geometry3d/Plane3dByOriginAndVectors\";\nimport { Vector2d } from \"../geometry3d/Point2dVector2d\";\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\nimport { Transform } from \"../geometry3d/Transform\";\nimport { SolidPrimitive } from \"./SolidPrimitive\";\n/**\n * A cone with axis along the z axis of a (possibly skewed) local coordinate system.\n *\n * * In local coordinates, the sections at z=0 and z=1 are circles of radius r0 and r1.\n * * Either one individually  may be zero, but they may not both be zero.\n * * The stored matrix has unit vectors in the xy columns, and full-length z column.\n * @public\n */\nexport class Cone extends SolidPrimitive {\n    constructor(map, radiusA, radiusB, capped) {\n        super(capped);\n        /** String name for schema properties */\n        this.solidPrimitiveType = \"cone\";\n        this._localToWorld = map;\n        this._radiusA = radiusA;\n        this._radiusB = radiusB;\n        this._maxRadius = Math.max(this._radiusA, this._radiusB); // um... should resolve elliptical sections\n    }\n    /** Return a clone of this Cone. */\n    clone() {\n        return new Cone(this._localToWorld.clone(), this._radiusA, this._radiusB, this.capped);\n    }\n    /** Return a coordinate frame (right handed unit vectors)\n     * * origin at center of the base circle.\n     * * base circle in the xy plane\n     * * z axis by right hand rule.\n     */\n    getConstructiveFrame() {\n        return this._localToWorld.cloneRigid();\n    }\n    /** Apply the transform to this cone's locla to world coordinates.\n     * * Note that the radii are not changed.  Scaling is absorbed into the frame.\n     * * This fails if the transformation is singular.\n     */\n    tryTransformInPlace(transform) {\n        if (transform.matrix.isSingular())\n            return false;\n        transform.multiplyTransformTransform(this._localToWorld, this._localToWorld);\n        return true;\n    }\n    /**\n     * Create a clone and immediately transform the clone.\n     */\n    cloneTransformed(transform) {\n        const result = this.clone();\n        transform.multiplyTransformTransform(result._localToWorld, result._localToWorld);\n        return result;\n    }\n    /** create a cylinder or cone from two endpoints and their radii.   The circular cross sections are perpendicular to the axis line\n     * from start to end point.\n     * * both radii must be of the same sign.\n     * * negative radius is accepted to create interior surface.    Downstream effects of that combined with capping may be a problem.\n     */\n    static createAxisPoints(centerA, centerB, radiusA, radiusB, capped) {\n        const zDirection = centerA.vectorTo(centerB);\n        const a = zDirection.magnitude();\n        if (Geometry.isSmallMetricDistance(a))\n            return undefined;\n        // force near-zero radii to true zero\n        radiusA = Geometry.correctSmallMetricDistance(radiusA);\n        radiusB = Geometry.correctSmallMetricDistance(radiusB);\n        // cone tip may not be \"within\" the z range.\n        if (radiusA * radiusB < 0.0)\n            return undefined;\n        // at least one must be nonzero.\n        if (radiusA + radiusB === 0.0)\n            return undefined;\n        const matrix = Matrix3d.createRigidHeadsUp(zDirection);\n        matrix.scaleColumns(1.0, 1.0, a, matrix);\n        const localToWorld = Transform.createOriginAndMatrix(centerA, matrix);\n        return new Cone(localToWorld, radiusA, radiusB, capped);\n    }\n    /** create a cylinder or cone from axis start and end with cross section defined by vectors that do not need to be perpendicular to each other or\n     * to the axis.\n     */\n    static createBaseAndTarget(centerA, centerB, vectorX, vectorY, radiusA, radiusB, capped) {\n        radiusA = Math.abs(Geometry.correctSmallMetricDistance(radiusA));\n        radiusB = Math.abs(Geometry.correctSmallMetricDistance(radiusB));\n        const vectorZ = centerA.vectorTo(centerB);\n        const localToWorld = Transform.createOriginAndMatrixColumns(centerA, vectorX, vectorY, vectorZ);\n        return new Cone(localToWorld, radiusA, radiusB, capped);\n    }\n    /** (Property accessor) Return the center point at the base plane */\n    getCenterA() { return this._localToWorld.multiplyXYZ(0, 0, 0); }\n    /** (Property accessor) */\n    getCenterB() { return this._localToWorld.multiplyXYZ(0, 0, 1); }\n    /** (Property accessor) Return the x vector in the local frame */\n    getVectorX() { return this._localToWorld.matrix.columnX(); }\n    /** (Property accessor) Return the y vector in the local frame */\n    getVectorY() { return this._localToWorld.matrix.columnY(); }\n    /** (Property accessor) return the radius at the base plane */\n    getRadiusA() { return this._radiusA; }\n    /** (Property accessor) return the radius at the top plane */\n    getRadiusB() { return this._radiusB; }\n    /** (Property accessor) return the larger of the base and top plane radii */\n    getMaxRadius() { return this._maxRadius; }\n    /** (Property accessor) return the radius at fraction `v` along the axis */\n    vFractionToRadius(v) { return Geometry.interpolate(this._radiusA, v, this._radiusB); }\n    /** (Property accessor) test if `other` is an instance of `Cone` */\n    isSameGeometryClass(other) { return other instanceof Cone; }\n    /** (Property accessor) Test for nearly equal coordinate data. */\n    isAlmostEqual(other) {\n        if (other instanceof Cone) {\n            if (this.capped !== other.capped)\n                return false;\n            if (!this._localToWorld.isAlmostEqualAllowZRotation(other._localToWorld))\n                return false;\n            return Geometry.isSameCoordinate(this._radiusA, other._radiusA)\n                && Geometry.isSameCoordinate(this._radiusB, other._radiusB);\n        }\n        return false;\n    }\n    /** Second step of double dispatch:   call `handler.handleCone(this)` */\n    dispatchToGeometryHandler(handler) {\n        return handler.handleCone(this);\n    }\n    /**\n     *  return strokes for a cross-section (elliptic arc) at specified fraction v along the axis.\n     * * fixedStrokeCount takes priority over stroke options.\n     * * The linestring is created by LineString3d.createForStrokes (fixedStrokeCount, options), which sets up property according to the options:\n     *   * optional fractions member\n     *   * optional uvParams.  uvParams are installed as full-scale distance parameters.\n     *   * optional derivatives.\n     * @param v fractional position along the cone axis\n     * @param fixedStrokeCount optional stroke count.\n     * @param options optional stroke options.\n     */\n    strokeConstantVSection(v, fixedStrokeCount, options) {\n        let strokeCount = 16;\n        if (fixedStrokeCount !== undefined)\n            strokeCount = fixedStrokeCount;\n        else if (options !== undefined)\n            strokeCount = options.defaultCircleStrokes; // NEEDS WORK -- get circle stroke count with this.maxRadius !!!\n        else {\n            // accept the local default\n        }\n        strokeCount = Geometry.clampToStartEnd(strokeCount, 4, 64);\n        const r = this.vFractionToRadius(v);\n        const result = LineString3d.createForStrokes(fixedStrokeCount, options);\n        const twoPi = Math.PI * 2.0;\n        const deltaRadians = twoPi / strokeCount;\n        let radians = 0;\n        const fractions = result.fractions; // possibly undefined !!!\n        const derivatives = result.packedDerivatives; // possibly undefined !!!\n        const uvParams = result.packedUVParams; // possibly undefined !!\n        const surfaceNormals = result.packedSurfaceNormals;\n        const xyz = Point3d.create();\n        const dXdu = Vector3d.create();\n        const dXdv = Vector3d.create();\n        const normal = Vector3d.create();\n        const transform = this._localToWorld;\n        let rc, rs, cc, ss;\n        for (let i = 0; i <= strokeCount; i++) {\n            if (i * 2 <= strokeCount)\n                radians = i * deltaRadians;\n            else\n                radians = (i - strokeCount) * deltaRadians;\n            cc = Math.cos(radians);\n            ss = Math.sin(radians);\n            rc = r * cc;\n            rs = r * ss;\n            transform.multiplyXYZ(rc, rs, v, xyz);\n            result.addPoint(xyz);\n            if (fractions)\n                fractions.push(i / strokeCount);\n            if (derivatives) {\n                transform.matrix.multiplyXYZ(-rs * twoPi, rc * twoPi, 0.0, dXdu);\n                derivatives.push(dXdu);\n            }\n            if (surfaceNormals) {\n                // the along-hoop vector does not need to be scaled by radius -- just need the direction for a cross product.\n                transform.matrix.multiplyXYZ(-ss, cc, 0.0, dXdu);\n                transform.matrix.multiplyXYZ(0, 0, 1, dXdv);\n                dXdu.unitCrossProduct(dXdv, normal);\n                surfaceNormals.push(normal);\n            }\n            if (uvParams) {\n                uvParams.pushXY(i / strokeCount, v);\n            }\n        }\n        return result;\n    }\n    /**\n     * Return the Arc3d section at vFraction\n     * @param vFraction fractional position along the sweep direction\n     */\n    constantVSection(vFraction) {\n        const r = this.vFractionToRadius(vFraction);\n        const transform = this._localToWorld;\n        const center = transform.multiplyXYZ(0, 0, vFraction);\n        const vector0 = transform.matrix.multiplyXYZ(r, 0, 0);\n        const vector90 = transform.matrix.multiplyXYZ(0, r, 0);\n        return Loop.create(Arc3d.create(center, vector0, vector90));\n    }\n    /** Extend `rangeToExtend` so it includes this `Cone` instance. */\n    extendRange(rangeToExtend, transform) {\n        const arc0 = this.constantVSection(0.0);\n        const arc1 = this.constantVSection(1.0);\n        arc0.extendRange(rangeToExtend, transform);\n        arc1.extendRange(rangeToExtend, transform);\n    }\n    /** Evaluate a point on the Cone surfaces, with\n     * * v = 0 is the base plane.\n     * * v = 1 is the top plane\n     * * u = 0 to u = 1 wraps the angular range.\n     */\n    uvFractionToPoint(uFraction, vFraction, result) {\n        const theta = uFraction * Math.PI * 2.0;\n        const r = Geometry.interpolate(this._radiusA, vFraction, this._radiusB);\n        const cosTheta = Math.cos(theta);\n        const sinTheta = Math.sin(theta);\n        return this._localToWorld.multiplyXYZ(r * cosTheta, r * sinTheta, vFraction, result);\n    }\n    /** Evaluate a point tangent plane on the Cone surfaces, with\n     * * v = 0 is the base plane.\n     * * v = 1 is the top plane\n     * * u = 0 to u = 1 wraps the angular range.\n     */\n    uvFractionToPointAndTangents(uFraction, vFraction, result) {\n        const theta = uFraction * Math.PI * 2.0;\n        const r = Geometry.interpolate(this._radiusA, vFraction, this._radiusB);\n        const drdv = this._radiusB - this._radiusA;\n        const cosTheta = Math.cos(theta);\n        const sinTheta = Math.sin(theta);\n        const fTheta = 2.0 * Math.PI;\n        return Plane3dByOriginAndVectors.createOriginAndVectors(this._localToWorld.multiplyXYZ(r * cosTheta, r * sinTheta, vFraction), this._localToWorld.multiplyVectorXYZ(-r * sinTheta * fTheta, r * cosTheta * fTheta, 0), this._localToWorld.multiplyVectorXYZ(drdv * cosTheta, drdv * sinTheta, 1.0), result);\n    }\n    /**\n     * @return true if this is a closed volume.\n     */\n    get isClosedVolume() {\n        return this.capped;\n    }\n    /**\n     * Directional distance query\n     * * u direction is around longitude circle at maximum distance from axis.\n     * * v direction is on a line of longitude between the latitude limits.\n     */\n    maxIsoParametricDistance() {\n        const vectorX = this._localToWorld.matrix.columnX();\n        const vectorY = this._localToWorld.matrix.columnY();\n        const columnZ = this._localToWorld.matrix.columnZ();\n        const xyNormal = vectorX.unitCrossProduct(vectorY);\n        const hZ = xyNormal.dotProduct(columnZ);\n        const zSkewVector = columnZ.plusScaled(xyNormal, hZ);\n        const zSkewDistance = zSkewVector.magnitudeXY();\n        return Vector2d.create(Math.PI * 2 * Math.max(this._radiusA, this._radiusB), Geometry.hypotenuseXY(Math.abs(this._radiusB - this._radiusA) + zSkewDistance, hZ));\n    }\n}\n//# sourceMappingURL=Cone.js.map",
      "start": 1693508123757,
      "end": 1693508123889,
      "sourcemaps": null
    }
  ]
}
