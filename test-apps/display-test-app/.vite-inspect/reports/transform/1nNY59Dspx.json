{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/markup/lib/esm/SelectTool.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module MarkupTools\n */\nimport { BeEvent } from \"@itwin/core-bentley\";\nimport { Point2d, Point3d, Vector2d } from \"@itwin/core-geometry\";\nimport { BeButton, BeButtonEvent, BeModifierKeys, CoreTools, EventHandled, IModelApp, InputSource, ToolAssistance, ToolAssistanceImage, ToolAssistanceInputMethod, } from \"@itwin/core-frontend\";\nimport { G, Line, Text as MarkupText, Matrix, Point } from \"@svgdotjs/svg.js\";\nimport { MarkupApp } from \"./Markup\";\nimport { MarkupTool } from \"./MarkupTool\";\nimport { EditTextTool } from \"./TextEdit\";\n// cspell:ignore lmultiply untransform unFlash multiselect\n/** Classes added to HTMLElements so they can be customized in CSS by applications.\n * A \"modify handle\" is a visible position on the screen that provides UI to modify a MarkupElement.\n * @public\n */\nexport class ModifyHandle {\n    constructor(handles) {\n        this.handles = handles;\n    }\n    async onClick(_ev) { }\n    /** the mouse just went down on this handle, begin modification. */\n    startDrag(_ev, makeCopy = false) {\n        this.vbToStartTrn = this.handles.vbToBoxTrn.clone(); // save the starting vp -> element box transform\n        this.startModify(makeCopy);\n    }\n    startModify(makeCopy) {\n        const handles = this.handles;\n        const el = handles.el;\n        const cloned = handles.el = el.cloneMarkup(); // make a clone of this element\n        if (makeCopy) {\n            el.after(cloned);\n        }\n        else {\n            cloned.originalEl = el; // save original for undo\n            el.replace(cloned); // put it into the DOM in place of the original\n        }\n    }\n    setMouseHandler(target) {\n        const node = target.node;\n        node.addEventListener(\"mousedown\", (event) => {\n            const ev = event;\n            if (0 === ev.button && undefined === this.handles.active)\n                this.handles.active = this;\n        });\n        node.addEventListener(\"touchstart\", () => {\n            if (undefined === this.handles.active)\n                this.handles.active = this;\n        });\n    }\n    addTouchPadding(visible, handles) {\n        if (InputSource.Touch !== IModelApp.toolAdmin.currentInputState.inputSource)\n            return visible;\n        const padding = visible.cloneMarkup().scale(3).attr(\"opacity\", 0);\n        const g = handles.group.group();\n        padding.addTo(g);\n        visible.addTo(g);\n        return g;\n    }\n}\n/** A ModifyHandle that changes the size of the element\n * @public\n */\nclass StretchHandle extends ModifyHandle {\n    constructor(handles, xy, cursor) {\n        super(handles);\n        this.posNpc = new Point2d(xy[0], xy[1]);\n        const props = MarkupApp.props.handles;\n        this._circle = handles.group.circle(props.size).addClass(MarkupApp.stretchHandleClass).attr(props.stretch).attr(\"cursor\", `${cursor}-resize`); // the visible \"circle\" for this handle\n        this._circle = this.addTouchPadding(this._circle, handles);\n        this.setMouseHandler(this._circle);\n    }\n    setPosition() {\n        const pt = this.handles.npcToVb(this.posNpc); // convert to viewbox coords\n        this._circle.center(pt.x, pt.y);\n    }\n    startDrag(_ev) {\n        const handles = this.handles;\n        this.startCtm = handles.el.screenCTM().lmultiplyO(MarkupApp.screenToVbMtx());\n        this.startBox = handles.el.bbox(); // save starting size so we can preserve aspect ratio\n        this.startPos = handles.npcToBox(this.posNpc);\n        this.opposite = handles.npcToBox({ x: 1 - this.posNpc.x, y: 1 - this.posNpc.y });\n        super.startDrag(_ev);\n    }\n    /** perform the stretch. Always stretch element with anchor at the opposite corner of the one being moved. */\n    modify(ev) {\n        const evPt = MarkupApp.convertVpToVb(ev.viewPoint); // get cursor location in viewbox coords\n        const diff = this.startPos.vectorTo(this.vbToStartTrn.multiplyPoint2d(evPt)); // movement of cursor from start, in viewbox coords\n        const diag = this.startPos.vectorTo(this.opposite).normalize(); // vector from opposite corner to this handle\n        let diagVec = diag.scaleToLength(diff.dotProduct(diag)); // projected distance along diagonal\n        if (diagVec === undefined)\n            diagVec = Vector2d.createZero();\n        // if the shift key is down, don't preserve aspect ratio\n        const adjusted = ev.isShiftKey ? { x: diff.x, y: diff.y } : { x: diagVec.x, y: diagVec.y };\n        let { x, y, h, w } = this.startBox;\n        if (this.posNpc.x === 0) {\n            x += adjusted.x; // left edge\n            w -= adjusted.x;\n        }\n        else if (this.posNpc.x === 1) {\n            w += adjusted.x; // right edge\n        }\n        if (this.posNpc.y === 0) {\n            y += adjusted.y; // top edge\n            h -= adjusted.y;\n        }\n        else if (this.posNpc.y === 1) {\n            h += adjusted.y; // bottom edge\n        }\n        const mtx = this.startCtm.inverse().scaleO(this.startBox.w / w, this.startBox.h / h, this.opposite.x, this.opposite.y).inverseO();\n        const minSize = 10;\n        if (w > minSize && h > minSize) // don't let element get too small\n            this.handles.el.markupStretch(w, h, x, y, mtx);\n    }\n}\n/** A ModifyHandle to rotate an element\n * @public\n */\nclass RotateHandle extends ModifyHandle {\n    constructor(handles) {\n        super(handles);\n        this.handles = handles;\n        const props = MarkupApp.props.handles;\n        this._line = handles.group.line(0, 0, 1, 1).attr(props.rotateLine).addClass(MarkupApp.rotateLineClass);\n        this._circle = handles.group.circle(props.size * 1.25).attr(props.rotate).addClass(MarkupApp.rotateHandleClass);\n        this._circle = this.addTouchPadding(this._circle, handles);\n        this.setMouseHandler(this._circle);\n    }\n    get centerVb() { return this.handles.npcToVb({ x: .5, y: .5 }); }\n    get anchorVb() { return this.handles.npcToVb({ x: .5, y: 0 }); }\n    setPosition() {\n        const anchor = this.anchorVb;\n        const dir = this.centerVb.vectorTo(anchor).normalize();\n        const loc = this.location = anchor.plusScaled(dir, MarkupApp.props.handles.size * 3);\n        this._line.plot(anchor.x, anchor.y, loc.x, loc.y);\n        this._circle.center(loc.x, loc.y);\n    }\n    modify(ev) {\n        const centerVp = this.centerVb;\n        const currDir = centerVp.vectorTo(MarkupApp.convertVpToVb(ev.viewPoint));\n        const dir = centerVp.vectorTo(this.location);\n        this.handles.el.rotate(dir.angleTo(currDir).degrees);\n    }\n}\n/** A VertexHandle to move a point on a line\n * @public\n */\nclass VertexHandle extends ModifyHandle {\n    constructor(handles, index) {\n        super(handles);\n        this.handles = handles;\n        const props = MarkupApp.props.handles;\n        this._circle = handles.group.circle(props.size).attr(props.vertex).addClass(MarkupApp.vertexHandleClass);\n        this._x = `x${index + 1}`;\n        this._y = `y${index + 1}`;\n        this._circle = this.addTouchPadding(this._circle, handles);\n        this.setMouseHandler(this._circle);\n    }\n    setPosition() {\n        let point = new Point(this.handles.el.attr(this._x), this.handles.el.attr(this._y));\n        const matrix = this.handles.el.screenCTM().lmultiplyO(MarkupApp.screenToVbMtx());\n        point = point.transform(matrix);\n        this._circle.center(point.x, point.y);\n    }\n    modify(ev) {\n        let point = new Point(ev.viewPoint.x, ev.viewPoint.y);\n        const matrix = this.handles.el.screenCTM().inverseO().multiplyO(MarkupApp.getVpToScreenMtx());\n        point = point.transform(matrix);\n        const el = this.handles.el;\n        el.attr(this._x, point.x);\n        el.attr(this._y, point.y);\n    }\n}\n/** A handle that moves (translates) an element.\n * @public\n */\nclass MoveHandle extends ModifyHandle {\n    constructor(handles, showBBox) {\n        super(handles);\n        this.handles = handles;\n        const props = MarkupApp.props.handles;\n        const clone = this.handles.el.cloneMarkup();\n        clone.css(props.move);\n        clone.forElementsOfGroup((child) => child.css(props.move));\n        if (showBBox) {\n            this._outline = handles.group.polygon().attr(props.moveOutline);\n            const rect = this.handles.el.getOutline().attr(props.move).attr({ fill: \"none\" });\n            const group = handles.group.group();\n            group.add(this._outline);\n            group.add(rect);\n            group.add(clone);\n            this._shape = group;\n        }\n        else {\n            clone.addTo(handles.group);\n            this._shape = clone;\n        }\n        this._shape.addClass(MarkupApp.moveHandleClass);\n        this.setMouseHandler(this._shape);\n    }\n    async onClick(_ev) {\n        const el = this.handles.el;\n        // eslint-disable-next-line deprecation/deprecation\n        if (el instanceof MarkupText || (el instanceof G && el.node.className.baseVal === MarkupApp.boxedTextClass)) // if they click on the move handle of a text element, start the text editor\n            await new EditTextTool(el).run();\n    }\n    /** draw the outline of the element's bbox (in viewbox coordinates) */\n    setPosition() {\n        if (undefined !== this._outline) {\n            const pts = [new Point2d(0, 0), new Point2d(0, 1), new Point2d(1, 1), new Point2d(1, 0)];\n            this._outline.plot(this.handles.npcToVbArray(pts).map((pt) => [pt.x, pt.y]));\n        }\n    }\n    startDrag(ev) {\n        super.startDrag(ev, ev.isShiftKey);\n        this._lastPos = MarkupApp.convertVpToVb(ev.viewPoint); // save stating position in viewbox coordinates\n    }\n    modify(ev) {\n        const evPt = MarkupApp.convertVpToVb(ev.viewPoint);\n        const dist = evPt.minus(this._lastPos);\n        this._lastPos = evPt;\n        this.handles.el.translate(dist.x, dist.y); // move the element\n    }\n}\n/** The set of ModifyHandles active. Only applies if there is a single element selected.\n * @public\n */\nexport class Handles {\n    constructor(ss, el) {\n        this.ss = ss;\n        this.el = el;\n        this.handles = [];\n        this.dragging = false;\n        this.group = ss.svg.group();\n        if (el instanceof Line) {\n            this.handles.push(new MoveHandle(this, false));\n            this.handles.push(new VertexHandle(this, 0));\n            this.handles.push(new VertexHandle(this, 1));\n            this.draw(); // show starting state\n            return;\n        }\n        // move box is in the back\n        this.handles.push(new MoveHandle(this, true));\n        // then rotate handle\n        this.handles.push(new RotateHandle(this));\n        // then add all the stretch handles\n        const pts = [[0, 0], [0, .5], [0, 1], [.5, 1], [1, 1], [1, .5], [1, 0], [.5, 0]];\n        const cursors = [\"nw\", \"w\", \"sw\", \"s\", \"se\", \"e\", \"ne\", \"n\"];\n        const order = [7, 3, 1, 5, 2, 6, 0, 4];\n        const angle = el.screenCTM().decompose().rotate || 0;\n        const start = Math.round(-angle / 45); // so that we rotate the cursors for rotated elements\n        order.forEach((index) => this.handles.push(new StretchHandle(this, pts[index], cursors[(index + start + 8) % 8])));\n        this.draw(); // show starting state\n    }\n    npcToBox(p) {\n        const pt = this.npcToVb(p);\n        return this.vbToBox(pt, pt);\n    }\n    npcToVb(p, result) { return this.npcToVbTrn.multiplyPoint2d(p, result); }\n    vbToBox(p, result) { return this.vbToBoxTrn.multiplyPoint2d(p, result); }\n    npcToVbArray(pts) {\n        pts.forEach((pt) => this.npcToVb(pt, pt));\n        return pts;\n    }\n    draw() {\n        const el = this.el;\n        const bb = el.bbox();\n        const ctm = el.screenCTM().lmultiplyO(MarkupApp.screenToVbMtx());\n        this.vbToBoxTrn = ctm.inverse().toIModelTransform();\n        this.npcToVbTrn = new Matrix().scaleO(bb.w, bb.h).translateO(bb.x, bb.y).lmultiplyO(ctm).toIModelTransform();\n        this.handles.forEach((h) => h.setPosition());\n    }\n    remove() {\n        if (this.dragging)\n            this.cancelDrag();\n        this.group.remove();\n    }\n    startDrag(ev) {\n        if (this.active) {\n            this.active.startDrag(ev);\n            this.dragging = true;\n            MarkupApp.markup.disablePick();\n            IModelApp.toolAdmin.setCursor(IModelApp.viewManager.dynamicsCursor);\n        }\n        return EventHandled.Yes;\n    }\n    drag(ev) {\n        if (this.dragging) {\n            this.active.modify(ev);\n            this.draw();\n        }\n    }\n    /** complete the modification for the active handle. */\n    endDrag(undo) {\n        undo.performOperation(MarkupApp.getActionName(\"modify\"), () => {\n            const el = this.el;\n            const original = el.originalEl; // save original element\n            if (original === undefined) {\n                this.ss.emptyAll();\n                this.ss.add(el);\n                undo.onAdded(el);\n            }\n            else {\n                el.originalEl = undefined; // clear original element\n                undo.onModified(el, original);\n            }\n        });\n        this.draw();\n        this.dragging = false;\n        this.active = undefined;\n        MarkupApp.markup.enablePick();\n        return EventHandled.Yes;\n    }\n    /** called when the reset button is pressed. */\n    cancelDrag() {\n        if (!this.dragging)\n            return;\n        const el = this.el;\n        const original = el.originalEl;\n        if (original) {\n            el.replace(original);\n            this.el = original;\n        }\n        this.draw();\n        this.active = undefined;\n        MarkupApp.markup.enablePick();\n    }\n}\n/** The set of currently selected SVG elements. When elements are added to the set, they are hilited.\n * @public\n */\nexport class MarkupSelected {\n    get size() { return this.elements.size; }\n    get isEmpty() { return this.size === 0; }\n    has(el) { return this.elements.has(el); }\n    emptyAll() {\n        this.clearEditors();\n        if (this.isEmpty)\n            return; // Don't send onChanged if already empty.\n        this.elements.forEach((el) => el.unHilite());\n        this.elements.clear();\n        this.onChanged.raiseEvent(this);\n    }\n    restart(el) {\n        this.emptyAll();\n        if (el)\n            this.add(el);\n    }\n    constructor(svg) {\n        this.svg = svg;\n        this.elements = new Set();\n        /** Called whenever elements are added or removed from this SelectionSet */\n        this.onChanged = new BeEvent();\n    }\n    clearEditors() {\n        if (this.handles) {\n            this.handles.remove();\n            this.handles = undefined;\n        }\n    }\n    sizeChanged() {\n        this.clearEditors();\n        if (this.elements.size === 1)\n            this.handles = new Handles(this, this.elements.values().next().value);\n        this.onChanged.raiseEvent(this);\n    }\n    /** Add a new element to the SS */\n    add(el) {\n        this.elements.add(el);\n        el.hilite();\n        this.sizeChanged();\n    }\n    /** Remove an element from the selection set and unhilite it.\n     * @returns true if the element was in the SS and was removed.\n     */\n    drop(el) {\n        el.unHilite();\n        return this.elements.delete(el) ? (this.sizeChanged(), true) : false;\n    }\n    /** Replace an entry in the selection set with a different element. */\n    replace(oldEl, newEl) {\n        if (this.drop(oldEl))\n            this.add(newEl);\n    }\n    deleteAll(undo) {\n        undo.performOperation(MarkupApp.getActionName(\"delete\"), () => this.elements.forEach((el) => {\n            undo.onDelete(el);\n            el.remove();\n        }));\n        this.emptyAll();\n    }\n    groupAll(undo) {\n        if (this.size < 2)\n            return;\n        const first = this.elements.values().next().value;\n        const parent = first.parent();\n        const group = parent.group();\n        const ordered = [];\n        this.elements.forEach((el) => ordered.push(el));\n        ordered.sort((lhs, rhs) => parent.index(lhs) - parent.index(rhs)); // Preserve relative z ordering\n        undo.performOperation(MarkupApp.getActionName(\"group\"), () => {\n            ordered.forEach((el) => {\n                const oldParent = el.parent();\n                const oldPos = el.position();\n                el.unHilite();\n                undo.onRepositioned(el.addTo(group), oldPos, oldParent);\n            }), undo.onAdded(group);\n        });\n        this.restart(group);\n    }\n    ungroupAll(undo) {\n        const groups = new Set();\n        this.elements.forEach((el) => {\n            if (el instanceof G)\n                groups.add(el);\n        });\n        if (0 === groups.size)\n            return;\n        undo.performOperation(MarkupApp.getActionName(\"ungroup\"), () => {\n            groups.forEach((g) => {\n                g.unHilite();\n                this.elements.delete(g);\n                undo.onDelete(g);\n                g.each((index, children) => {\n                    const child = children[index];\n                    const oldPos = child.position();\n                    child.toParent(g.parent());\n                    undo.onRepositioned(child, oldPos, g);\n                }, false);\n                g.untransform(); // Don't want undo of ungroup to push the current group transform...\n                g.remove();\n            });\n        });\n        this.sizeChanged();\n    }\n    /** Move all of the entries to a new position in the DOM via a callback. */\n    reposition(cmdName, undo, fn) {\n        undo.performOperation(cmdName, () => this.elements.forEach((el) => {\n            const oldParent = el.parent();\n            const oldPos = el.position();\n            fn(el);\n            undo.onRepositioned(el, oldPos, oldParent);\n        }));\n        this.sizeChanged();\n    }\n}\n/** Provides UI for selection, delete, move, copy, bring-to-front, send-to-back, etc. for Markup SVG elements\n * @public\n */\nclass SelectTool extends MarkupTool {\n    constructor() {\n        super(...arguments);\n        this._dragging = [];\n        this._isBoxSelect = false;\n    }\n    get flashedElement() { return this._flashedElement; }\n    set flashedElement(el) {\n        if (el === this._flashedElement)\n            return;\n        if (undefined !== this._flashedElement)\n            this._flashedElement.unFlash();\n        if (undefined !== el)\n            el.flash();\n        this._flashedElement = el;\n    }\n    unflashSelected() {\n        if (undefined !== this._flashedElement && this.markup.selected.has(this._flashedElement))\n            this.flashedElement = undefined;\n    }\n    initSelect() {\n        this.markup.setCursor(\"default\");\n        this.markup.enablePick();\n        this.flashedElement = undefined;\n        this.boxSelectInit();\n    }\n    clearSelect() {\n        this.cancelDrag();\n        this.markup.selected.emptyAll();\n    }\n    async onCleanup() { this.clearSelect(); }\n    async onPostInstall() {\n        this.initSelect();\n        return super.onPostInstall();\n    }\n    async onRestartTool() { this.initSelect(); }\n    showPrompt() {\n        const mainInstruction = ToolAssistance.createInstruction(this.iconSpec, IModelApp.localization.getLocalizedString(`${MarkupTool.toolKey}Select.Prompts.IdentifyMarkup`));\n        const mouseInstructions = [];\n        const touchInstructions = [];\n        const acceptMsg = IModelApp.localization.getLocalizedString(`${MarkupTool.toolKey}Select.Prompts.AcceptMarkup`);\n        touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.OneTouchTap, acceptMsg, false, ToolAssistanceInputMethod.Touch));\n        mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.LeftClick, acceptMsg, false, ToolAssistanceInputMethod.Mouse));\n        touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.OneTouchDrag, CoreTools.translate(\"ElementSet.Inputs.BoxCorners\"), false, ToolAssistanceInputMethod.Touch));\n        mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.LeftClickDrag, CoreTools.translate(\"ElementSet.Inputs.BoxCorners\"), false, ToolAssistanceInputMethod.Mouse));\n        mouseInstructions.push(ToolAssistance.createModifierKeyInstruction(ToolAssistance.shiftKey, ToolAssistanceImage.LeftClickDrag, CoreTools.translate(\"ElementSet.Inputs.OverlapSelection\"), false, ToolAssistanceInputMethod.Mouse));\n        mouseInstructions.push(ToolAssistance.createModifierKeyInstruction(ToolAssistance.ctrlKey, ToolAssistanceImage.LeftClick, CoreTools.translate(\"ElementSet.Inputs.InvertSelection\"), false, ToolAssistanceInputMethod.Mouse));\n        mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.CursorClick, CoreTools.translate(\"ElementSet.Inputs.ClearSelection\"), false, ToolAssistanceInputMethod.Mouse));\n        const sections = [];\n        sections.push(ToolAssistance.createSection(mouseInstructions, ToolAssistance.inputsLabel));\n        sections.push(ToolAssistance.createSection(touchInstructions, ToolAssistance.inputsLabel));\n        const instructions = ToolAssistance.createInstructions(mainInstruction, sections);\n        IModelApp.notifications.setToolAssistance(instructions);\n    }\n    /** When we start a drag operation, we add a new set of elements to the DOM and start modifying them.\n     * If we cancel the operation, we need remove them from the DOM.\n     */\n    cancelDrag() {\n        this._dragging.forEach((el) => el.remove()); // remove temporary elements from DOM\n        this._dragging.length = 0;\n        this.boxSelectInit();\n    }\n    async onResetButtonUp(_ev) {\n        const selected = this.markup.selected;\n        const handles = selected.handles;\n        if (handles && handles.dragging)\n            handles.cancelDrag();\n        this.cancelDrag();\n        selected.sizeChanged();\n        return EventHandled.Yes;\n    }\n    /** Called when there is a mouse \"click\" (down+up without any motion) */\n    async onDataButtonUp(ev) {\n        const markup = this.markup;\n        const selected = markup.selected;\n        const handles = selected.handles;\n        if (handles) {\n            if (handles.dragging)\n                return handles.endDrag(markup.undo);\n            if (handles.active) { // clicked on a handle\n                if (ev.isControlKey)\n                    selected.drop(handles.el);\n                else\n                    await handles.active.onClick(ev);\n                handles.active = undefined;\n                return EventHandled.Yes;\n            }\n        }\n        const el = this.flashedElement = this.pickElement(ev.viewPoint);\n        if (ev.isControlKey) {\n            if (el && selected.drop(el))\n                return EventHandled.Yes;\n        }\n        else {\n            selected.emptyAll();\n        }\n        if (el !== undefined)\n            selected.add(el);\n        return EventHandled.Yes;\n    }\n    async onTouchTap(ev) {\n        // Allow tap with a second touch point to multiselect (similar functionality to control being held with mouse click).\n        if (ev.isSingleTap && 2 === ev.touchEvent.touches.length) {\n            const el = this.flashedElement = this.pickElement(ev.viewPoint);\n            if (el) {\n                const selected = this.markup.selected;\n                if (!selected.drop(el))\n                    selected.add(el);\n                return EventHandled.Yes;\n            }\n        }\n        return super.onTouchTap(ev);\n    }\n    boxSelectInit() {\n        this._isBoxSelect = false;\n        this.markup.svgDynamics.clear();\n    }\n    boxSelectStart(ev) {\n        if (!ev.isControlKey)\n            this.markup.selected.emptyAll();\n        this._anchorPt = MarkupApp.convertVpToVb(ev.viewPoint);\n        this._isBoxSelect = true;\n        return true;\n    }\n    boxSelect(ev, isDynamics) {\n        if (!this._isBoxSelect)\n            return false;\n        const start = this._anchorPt;\n        const end = MarkupApp.convertVpToVb(ev.viewPoint);\n        const vec = start.vectorTo(end);\n        const width = Math.abs(vec.x);\n        const height = Math.abs(vec.y);\n        if (width < 1 || height < 1)\n            return true;\n        const rightToLeft = (start.x > end.x);\n        const overlapMode = (ev.isShiftKey ? !rightToLeft : rightToLeft); // Shift inverts inside/overlap selection...\n        const offset = Point3d.create(vec.x < 0 ? end.x : start.x, vec.y < 0 ? end.y : start.y); // define location by corner points...\n        this.markup.svgDynamics.clear();\n        this.markup.svgDynamics.rect(width, height).move(offset.x, offset.y).css({ \"stroke-width\": 1, \"stroke\": \"black\", \"stroke-opacity\": 0.5, \"fill\": \"lightBlue\", \"fill-opacity\": 0.2 });\n        const selectBox = this.markup.svgDynamics.rect(width, height).move(offset.x, offset.y).css({ \"stroke-width\": 1, \"stroke\": \"white\", \"stroke-opacity\": 1.0, \"stroke-dasharray\": overlapMode ? \"5\" : \"2\", \"fill\": \"none\" });\n        const outlinesG = isDynamics ? this.markup.svgDynamics.group() : undefined;\n        const selectRect = selectBox.node.getBoundingClientRect();\n        this.markup.svgMarkup.forElementsOfGroup((child) => {\n            const childRect = child.node.getBoundingClientRect();\n            const inside = (childRect.left >= selectRect.left && childRect.top >= selectRect.top && childRect.right <= selectRect.right && childRect.bottom <= selectRect.bottom);\n            const overlap = !inside && (childRect.left < selectRect.right && childRect.right > selectRect.left && childRect.bottom > selectRect.top && childRect.top < selectRect.bottom);\n            const accept = inside || (overlap && overlapMode);\n            if (undefined !== outlinesG) {\n                if (inside || overlap) {\n                    const outline = child.getOutline().attr(MarkupApp.props.handles.moveOutline).addTo(outlinesG);\n                    if (accept)\n                        outline.attr({ \"fill\": MarkupApp.props.hilite.flash, \"fill-opacity\": 0.2 });\n                }\n            }\n            else if (accept) {\n                this.markup.selected.add(child);\n            }\n        });\n        if (!isDynamics)\n            this.boxSelectInit();\n        return true;\n    }\n    /** called when the mouse moves while the data button is down. */\n    async onMouseStartDrag(ev) {\n        if (BeButton.Data !== ev.button)\n            return EventHandled.No;\n        const markup = this.markup;\n        const selected = markup.selected;\n        const handles = selected.handles;\n        if (handles && handles.active) {\n            this.flashedElement = undefined; // make sure there are no elements flashed while dragging\n            return handles.startDrag(ev);\n        }\n        const flashed = this.flashedElement = this.pickElement(ev.viewPoint);\n        if (undefined === flashed)\n            return this.boxSelectStart(ev) ? EventHandled.Yes : EventHandled.No;\n        if (!selected.has(flashed))\n            selected.restart(flashed); // we clicked on an element not in the selection set, replace current selection with just this element\n        selected.clearEditors();\n        this._anchorPt = MarkupApp.convertVpToVb(ev.viewPoint); // save the starting point. This is the point where the \"down\" occurred.\n        this.cancelDrag();\n        selected.elements.forEach((el) => {\n            const cloned = el.cloneMarkup(); // make a clone of this element\n            el.after(cloned); // put it into the DOM after its original\n            cloned.originalEl = el; // save original element so we can remove it if this is a \"move\" command\n            this._dragging.push(cloned); // add to dragging set\n        });\n        return EventHandled.Yes;\n    }\n    /** Called whenever the mouse moves while this tool is active. */\n    async onMouseMotion(ev) {\n        const markup = this.markup;\n        const handles = markup.selected.handles;\n        if (handles && handles.dragging) {\n            this.receivedDownEvent = true; // necessary to tell ToolAdmin to send us the button up event\n            return handles.drag(ev); // drag the handle\n        }\n        if (this._dragging.length === 0) {\n            if (this.boxSelect(ev, true))\n                return;\n            if (InputSource.Touch !== ev.inputSource)\n                this.flashedElement = this.pickElement(ev.viewPoint); // if we're not dragging, try to find an element under the cursor\n            return;\n        }\n        // we have a set of elements being dragged. NOTE: coordinates are viewbox\n        const vbPt = MarkupApp.convertVpToVb(ev.viewPoint);\n        const delta = vbPt.minus(this._anchorPt);\n        this._dragging.forEach((el) => el.translate(delta.x, delta.y));\n        this._anchorPt = vbPt; // translate moves from last mouse location\n    }\n    /** Called when the mouse goes up after dragging. */\n    async onMouseEndDrag(ev) {\n        const markup = this.markup;\n        const selected = markup.selected;\n        const handles = selected.handles;\n        if (handles && handles.dragging) // if we have handles up, and if they're in the \"dragging\" state, send the event to them\n            return handles.endDrag(markup.undo);\n        if (this._dragging.length === 0)\n            return this.boxSelect(ev, false) ? EventHandled.Yes : EventHandled.No;\n        // NOTE: all units should be in viewbox coordinates\n        const delta = MarkupApp.convertVpToVb(ev.viewPoint).minus(this._anchorPt);\n        const undo = markup.undo;\n        if (ev.isShiftKey) // shift key means \"add to existing,\" otherwise new selection replaces old\n            selected.emptyAll();\n        // move or copy all of the elements in dragged set\n        undo.performOperation(MarkupApp.getActionName(\"copy\"), () => this._dragging.forEach((el) => {\n            el.translate(delta.x, delta.y); // move to final location\n            const original = el.originalEl; // save original element\n            el.originalEl = undefined; // clear original element\n            if (ev.isShiftKey) {\n                selected.add(el);\n                undo.onAdded(el); // shift key means copy element\n            }\n            else {\n                original.replace(el);\n                undo.onModified(el, original);\n            }\n        }));\n        this._dragging.length = 0; // empty dragging set\n        selected.sizeChanged(); // notify that size of selection set changed\n        return EventHandled.Yes;\n    }\n    /** called when a modifier key is pressed or released. Updates stretch handles, if present */\n    async onModifierKeyTransition(_wentDown, modifier, _event) {\n        if (modifier !== BeModifierKeys.Shift) // we only care about the shift key\n            return EventHandled.No;\n        const selected = this.markup.selected;\n        const handles = selected.handles;\n        if (undefined === handles || !handles.dragging) // and only if we're currently dragging\n            return EventHandled.No;\n        const ev = new BeButtonEvent(); // we need to simulate a mouse motion by sending a drag event at the last cursor position\n        IModelApp.toolAdmin.fillEventFromCursorLocation(ev);\n        return (undefined === ev.viewport) ? EventHandled.No : (handles.drag(ev), EventHandled.Yes);\n    }\n    /** called whenever a key is pressed while this tool is active. */\n    async onKeyTransition(wentDown, key) {\n        if (!wentDown)\n            return EventHandled.No;\n        const markup = this.markup;\n        switch (key.key.toLowerCase()) {\n            case \"delete\": // delete key or backspace = delete current selection set\n            case \"backspace\":\n                this.unflashSelected();\n                markup.deleteSelected();\n                return EventHandled.Yes;\n            case \"escape\": // esc = cancel current operation\n                await this.exitTool();\n                return EventHandled.Yes;\n            case \"b\": // alt-shift-b = send to back\n                return (key.altKey && key.shiftKey) ? (markup.sendToBack(), EventHandled.Yes) : EventHandled.No;\n            case \"f\": // alt-shift-f = bring to front\n                return (key.altKey && key.shiftKey) ? (markup.bringToFront(), EventHandled.Yes) : EventHandled.No;\n            case \"g\": // ctrl-g = create group\n                return (key.ctrlKey) ? (this.unflashSelected(), markup.groupSelected(), EventHandled.Yes) : EventHandled.No;\n            case \"u\": // ctrl-u = ungroup\n                return (key.ctrlKey) ? (this.unflashSelected(), markup.ungroupSelected(), EventHandled.Yes) : EventHandled.No;\n        }\n        return EventHandled.No;\n    }\n}\nSelectTool.toolId = \"Markup.Select\";\nSelectTool.iconSpec = \"icon-cursor\";\nexport { SelectTool };\n//# sourceMappingURL=SelectTool.js.map",
      "start": 1693508125568,
      "end": 1693508125735,
      "sourcemaps": null
    }
  ]
}
