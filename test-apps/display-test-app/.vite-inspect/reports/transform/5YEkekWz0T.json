{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/CheckpointConnection.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module IModelConnection\n */\nimport { BentleyError, BentleyStatus, Logger } from \"@itwin/core-bentley\";\nimport { IModelError, IModelReadRpcInterface, IModelVersion, RpcManager, RpcOperation, RpcRequest, RpcRequestEvent, } from \"@itwin/core-common\";\nimport { FrontendLoggerCategory } from \"./common/FrontendLoggerCategory\";\nimport { IModelApp } from \"./IModelApp\";\nimport { IModelConnection } from \"./IModelConnection\";\nimport { IModelRoutingContext } from \"./IModelRoutingContext\";\nconst loggerCategory = FrontendLoggerCategory.IModelConnection;\n/**\n * An IModelConnection to a checkpoint of an iModel, hosted on a remote backend over RPC.\n * Due to the nature of RPC requests, the backend servicing this connection may change over time, and there may even be more than one backend\n * at servicing requests at the same time. For this reason, this type of connection may only be used with Checkpoint iModels that are\n * guaranteed to be the same on every backend. Obviously Checkpoint iModels only allow readonly access.\n * @public\n */\nexport class CheckpointConnection extends IModelConnection {\n    constructor() {\n        super(...arguments);\n        this._reopenConnectionHandler = async (request, response, resubmit, reject) => {\n            if (!response.hasOwnProperty(\"isIModelNotFoundResponse\"))\n                return;\n            const iModelRpcProps = request.parameters[0];\n            if (this._fileKey !== iModelRpcProps.key)\n                return; // The handler is called for a different connection than this\n            Logger.logTrace(loggerCategory, \"Attempting to reopen connection\", () => iModelRpcProps);\n            try {\n                const openResponse = await CheckpointConnection.callOpen(iModelRpcProps, this.routingContext);\n                // The new/reopened connection may have a new rpcKey and/or changesetId, but the other IModelRpcTokenProps should be the same\n                this._fileKey = openResponse.key;\n                this.changeset = openResponse.changeset;\n            }\n            catch (error) {\n                reject(BentleyError.getErrorMessage(error));\n            }\n            finally {\n            }\n            Logger.logTrace(loggerCategory, \"Resubmitting original request after reopening connection\", iModelRpcProps);\n            request.parameters[0] = this.getRpcProps(); // Modify the token of the original request before resubmitting it.\n            resubmit();\n        };\n    }\n    /** The Guid that identifies the iTwin that owns this iModel. */\n    get iTwinId() { return super.iTwinId; }\n    /** The Guid that identifies this iModel. */\n    get iModelId() { return super.iModelId; }\n    /** Returns `true` if [[close]] has already been called. */\n    get isClosed() { return this._isClosed ? true : false; }\n    /** Type guard for instanceof [[CheckpointConnection]] */\n    isCheckpointConnection() { return true; }\n    /**\n     * Open a readonly IModelConnection to an iModel over RPC.\n     */\n    static async openRemote(iTwinId, iModelId, version = IModelVersion.latest()) {\n        const routingContext = IModelRoutingContext.current || IModelRoutingContext.default;\n        const accessToken = await IModelApp.getAccessToken();\n        if (undefined === IModelApp.hubAccess)\n            throw new Error(\"Missing an implementation of FrontendHubAccess on IModelApp, it is required to open a remote iModel Connection. Please provide an implementation to the IModelApp.startup using IModelAppOptions.hubAccess.\");\n        const changeset = await IModelApp.hubAccess.getChangesetFromVersion({ accessToken, iModelId, version });\n        const iModelRpcProps = { iTwinId, iModelId, changeset };\n        const openResponse = await this.callOpen(iModelRpcProps, routingContext);\n        const connection = new this(openResponse);\n        RpcManager.setIModel(connection);\n        connection.routingContext = routingContext;\n        RpcRequest.notFoundHandlers.addListener(connection._reopenConnectionHandler);\n        IModelConnection.onOpen.raiseEvent(connection);\n        return connection;\n    }\n    static async callOpen(iModelToken, routingContext) {\n        // Try opening the iModel repeatedly accommodating any pending responses from the backend.\n        // Waits for an increasing amount of time (but within a range) before checking on the pending request again.\n        const connectionRetryIntervalRange = { min: 100, max: 5000 }; // in milliseconds\n        let connectionRetryInterval = Math.min(connectionRetryIntervalRange.min, IModelConnection.connectionTimeout);\n        const openForReadOperation = RpcOperation.lookup(IModelReadRpcInterface, \"getConnectionProps\");\n        if (!openForReadOperation)\n            throw new IModelError(BentleyStatus.ERROR, \"IModelReadRpcInterface.getConnectionProps() is not available\");\n        openForReadOperation.policy.retryInterval = () => connectionRetryInterval;\n        Logger.logTrace(loggerCategory, `IModelConnection.open`, iModelToken);\n        const startTime = Date.now();\n        const removeListener = RpcRequest.events.addListener((type, request) => {\n            if (type !== RpcRequestEvent.PendingUpdateReceived) // eslint-disable-line deprecation/deprecation\n                return;\n            if (!(openForReadOperation && request.operation === openForReadOperation))\n                return;\n            Logger.logTrace(loggerCategory, \"Received pending open notification in IModelConnection.open\", iModelToken);\n            const connectionTimeElapsed = Date.now() - startTime;\n            if (connectionTimeElapsed > IModelConnection.connectionTimeout) {\n                Logger.logError(loggerCategory, `Timed out opening connection in IModelConnection.open (took longer than ${IModelConnection.connectionTimeout} milliseconds)`, iModelToken);\n                throw new IModelError(BentleyStatus.ERROR, \"Opening a connection was timed out\"); // NEEDS_WORK: More specific error status\n            }\n            connectionRetryInterval = Math.min(connectionRetryIntervalRange.max, connectionRetryInterval * 2, IModelConnection.connectionTimeout - connectionTimeElapsed);\n            if (request.retryInterval !== connectionRetryInterval) {\n                request.retryInterval = connectionRetryInterval;\n                Logger.logTrace(loggerCategory, `Adjusted open connection retry interval to ${request.retryInterval} milliseconds in IModelConnection.open`, iModelToken);\n            }\n        });\n        const openPromise = IModelReadRpcInterface.getClientForRouting(routingContext.token).getConnectionProps(iModelToken);\n        let openResponse;\n        try {\n            openResponse = await openPromise;\n        }\n        finally {\n            Logger.logTrace(loggerCategory, \"Completed open request in IModelConnection.open\", iModelToken);\n            removeListener();\n        }\n        return openResponse;\n    }\n    /** Close this CheckpointConnection */\n    async close() {\n        if (this.isClosed)\n            return;\n        this.beforeClose();\n        RpcRequest.notFoundHandlers.removeListener(this._reopenConnectionHandler);\n        this._isClosed = true;\n    }\n}\n//# sourceMappingURL=CheckpointConnection.js.map",
      "start": 1693508118477,
      "end": 1693508119081,
      "sourcemaps": null
    }
  ]
}
