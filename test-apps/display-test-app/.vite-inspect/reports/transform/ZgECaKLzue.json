{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tools/Tool.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tools\n */\nimport { assert } from \"@itwin/core-bentley\";\nimport { IModelError } from \"@itwin/core-common\";\nimport { Point2d, Point3d, PolygonOps } from \"@itwin/core-geometry\";\nimport { LocateFilterStatus } from \"../ElementLocateManager\";\nimport { FuzzySearch } from \"../FuzzySearch\";\nimport { IModelApp } from \"../IModelApp\";\n/**\n * @public\n * @extensions\n */\nexport var BeButton;\n(function (BeButton) {\n    BeButton[BeButton[\"Data\"] = 0] = \"Data\";\n    BeButton[BeButton[\"Reset\"] = 1] = \"Reset\";\n    BeButton[BeButton[\"Middle\"] = 2] = \"Middle\";\n})(BeButton || (BeButton = {}));\n/**\n * @public\n * @extensions\n */\nexport var CoordinateLockOverrides;\n(function (CoordinateLockOverrides) {\n    CoordinateLockOverrides[CoordinateLockOverrides[\"None\"] = 0] = \"None\";\n    CoordinateLockOverrides[CoordinateLockOverrides[\"ACS\"] = 2] = \"ACS\";\n    CoordinateLockOverrides[CoordinateLockOverrides[\"Grid\"] = 4] = \"Grid\";\n    CoordinateLockOverrides[CoordinateLockOverrides[\"All\"] = 65535] = \"All\";\n})(CoordinateLockOverrides || (CoordinateLockOverrides = {}));\n/** The *source* that generated an event.\n * @public\n * @extensions\n */\nexport var InputSource;\n(function (InputSource) {\n    /** Source not defined */\n    InputSource[InputSource[\"Unknown\"] = 0] = \"Unknown\";\n    /** From a mouse or other pointing device */\n    InputSource[InputSource[\"Mouse\"] = 1] = \"Mouse\";\n    /** From a touch screen */\n    InputSource[InputSource[\"Touch\"] = 2] = \"Touch\";\n})(InputSource || (InputSource = {}));\n/** The *source* that generated a coordinate.\n * @public\n * @extensions\n */\nexport var CoordSource;\n(function (CoordSource) {\n    /** Event was created by an action from the user */\n    CoordSource[CoordSource[\"User\"] = 0] = \"User\";\n    /** Event was created by a program or by a precision keyin */\n    CoordSource[CoordSource[\"Precision\"] = 1] = \"Precision\";\n    /** Event was created by a tentative point */\n    CoordSource[CoordSource[\"TentativePoint\"] = 2] = \"TentativePoint\";\n    /** Event was created by snapping to an element */\n    CoordSource[CoordSource[\"ElemSnap\"] = 3] = \"ElemSnap\";\n})(CoordSource || (CoordSource = {}));\n/** Numeric mask for a set of modifier keys (control, shift, and alt).\n * @public\n * @extensions\n */\nexport var BeModifierKeys;\n(function (BeModifierKeys) {\n    BeModifierKeys[BeModifierKeys[\"None\"] = 0] = \"None\";\n    BeModifierKeys[BeModifierKeys[\"Control\"] = 1] = \"Control\";\n    BeModifierKeys[BeModifierKeys[\"Shift\"] = 2] = \"Shift\";\n    BeModifierKeys[BeModifierKeys[\"Alt\"] = 4] = \"Alt\";\n})(BeModifierKeys || (BeModifierKeys = {}));\n/**\n * @public\n * @extensions\n */\nexport class BeButtonState {\n    constructor() {\n        this._downUorPt = new Point3d();\n        this._downRawPt = new Point3d();\n        this.downTime = 0;\n        this.isDown = false;\n        this.isDoubleClick = false;\n        this.isDragging = false;\n        this.inputSource = InputSource.Unknown;\n    }\n    get downRawPt() { return this._downRawPt; }\n    set downRawPt(pt) { this._downRawPt.setFrom(pt); }\n    get downUorPt() { return this._downUorPt; }\n    set downUorPt(pt) { this._downUorPt.setFrom(pt); }\n    init(downUorPt, downRawPt, downTime, isDown, isDoubleClick, isDragging, source) {\n        this.downUorPt = downUorPt;\n        this.downRawPt = downRawPt;\n        this.downTime = downTime;\n        this.isDown = isDown;\n        this.isDoubleClick = isDoubleClick;\n        this.isDragging = isDragging;\n        this.inputSource = source;\n    }\n}\n/** Object sent to Tools that holds information about button/touch/wheel events.\n * @public\n * @extensions\n */\nexport class BeButtonEvent {\n    constructor(props) {\n        this._point = new Point3d();\n        this._rawPoint = new Point3d();\n        this._viewPoint = new Point3d();\n        /** How the coordinate values were generated (either from an action by the user or from a program.) */\n        this.coordsFrom = CoordSource.User;\n        /** The keyboard modifiers that were pressed when the event was generated. */\n        this.keyModifiers = BeModifierKeys.None;\n        /** If true, this event was generated from a mouse-down transition, false from a button-up transition. */\n        this.isDown = false;\n        /** If true, this is the second down in a rapid double-click of the same button. */\n        this.isDoubleClick = false;\n        /** If true, this event was created by pressing, holding, and then moving a mouse button. */\n        this.isDragging = false;\n        /** The mouse button that created this event. */\n        this.button = BeButton.Data;\n        /** Whether this event came from a pointing device (e.g. mouse) or a touch device. */\n        this.inputSource = InputSource.Unknown;\n        if (props)\n            this.init(props);\n    }\n    /** Determine whether this BeButtonEvent has valid data.\n     * @note BeButtonEvents may be constructed as \"blank\", and are not considered to hold valid data unless the [[viewport]] member is defined.\n     */\n    get isValid() { return this.viewport !== undefined; }\n    /** The point for this event, in world coordinates.\n     * @note these coordinates may have been *adjusted* for some reason (e.g. snapping, locks, etc.) from the [[rawPoint]].\n     */\n    get point() { return this._point; }\n    set point(pt) { this._point.setFrom(pt); }\n    /** The *raw* (unadjusted) point for this event, in world coordinates. */\n    get rawPoint() { return this._rawPoint; }\n    set rawPoint(pt) { this._rawPoint.setFrom(pt); }\n    /** The point, in screen coordinates for this event.\n     * @note generally the z value is not useful, but some 3d pointing devices do supply it.\n     */\n    get viewPoint() { return this._viewPoint; }\n    set viewPoint(pt) { this._viewPoint.setFrom(pt); }\n    /** The difference in screen coordinates from previous motion event\n     * @internal\n     */\n    get movement() { return this._movement; }\n    set movement(mov) { this._movement = mov; }\n    /** Mark this BeButtonEvent as invalid. Can only become valid again by calling [[init]] */\n    invalidate() { this.viewport = undefined; }\n    /** Initialize the values of this BeButtonEvent. */\n    init(props) {\n        if (undefined !== props.point)\n            this.point = props.point;\n        if (undefined !== props.rawPoint)\n            this.rawPoint = props.rawPoint;\n        if (undefined !== props.viewPoint)\n            this.viewPoint = props.viewPoint;\n        if (undefined !== props.viewport)\n            this.viewport = props.viewport;\n        if (undefined !== props.coordsFrom)\n            this.coordsFrom = props.coordsFrom;\n        if (undefined !== props.keyModifiers)\n            this.keyModifiers = props.keyModifiers;\n        if (undefined !== props.isDown)\n            this.isDown = props.isDown;\n        if (undefined !== props.isDoubleClick)\n            this.isDoubleClick = props.isDoubleClick;\n        if (undefined !== props.isDragging)\n            this.isDragging = props.isDragging;\n        if (undefined !== props.button)\n            this.button = props.button;\n        if (undefined !== props.inputSource)\n            this.inputSource = props.inputSource;\n    }\n    /** Determine whether the control key was pressed  */\n    get isControlKey() { return 0 !== (this.keyModifiers & BeModifierKeys.Control); }\n    /** Determine whether the shift key was pressed  */\n    get isShiftKey() { return 0 !== (this.keyModifiers & BeModifierKeys.Shift); }\n    /** Determine whether the alt key was pressed  */\n    get isAltKey() { return 0 !== (this.keyModifiers & BeModifierKeys.Alt); }\n    /** Copy the values from another BeButtonEvent into this BeButtonEvent */\n    setFrom(src) {\n        this.point = src.point;\n        this.rawPoint = src.rawPoint;\n        this.viewPoint = src.viewPoint;\n        this.viewport = src.viewport;\n        this.coordsFrom = src.coordsFrom;\n        this.keyModifiers = src.keyModifiers;\n        this.isDown = src.isDown;\n        this.isDoubleClick = src.isDoubleClick;\n        this.isDragging = src.isDragging;\n        this.button = src.button;\n        this.inputSource = src.inputSource;\n        return this;\n    }\n    /** Make a copy of this BeButtonEvent. */\n    clone() { return new this.constructor(this); }\n}\n/** A ButtonEvent generated by touch input.\n * @public\n * @extensions\n */\nexport class BeTouchEvent extends BeButtonEvent {\n    get touchCount() { return this.touchEvent.targetTouches.length; }\n    get isSingleTouch() { return 1 === this.touchCount; }\n    get isTwoFingerTouch() { return 2 === this.touchCount; }\n    get isSingleTap() { return 1 === this.tapCount && 1 === this.touchCount; }\n    get isDoubleTap() { return 2 === this.tapCount && 1 === this.touchCount; }\n    get isTwoFingerTap() { return 1 === this.tapCount && 2 === this.touchCount; }\n    constructor(props) {\n        super(props);\n        this.tapCount = 0;\n        this.touchEvent = props.touchEvent;\n    }\n    setFrom(src) {\n        super.setFrom(src);\n        this.touchEvent = src.touchEvent;\n        this.tapCount = src.tapCount;\n        return this;\n    }\n    static getTouchPosition(touch, vp) {\n        const rect = vp.getClientRect();\n        return Point2d.createFrom({ x: touch.clientX - rect.left, y: touch.clientY - rect.top });\n    }\n    static getTouchListCentroid(list, vp) {\n        switch (list.length) {\n            case 0: {\n                return undefined;\n            }\n            case 1: {\n                return this.getTouchPosition(list[0], vp);\n            }\n            case 2: {\n                return this.getTouchPosition(list[0], vp).interpolate(0.5, this.getTouchPosition(list[1], vp));\n            }\n            default: {\n                const points = [];\n                // eslint-disable-next-line @typescript-eslint/prefer-for-of\n                for (let i = 0; i < list.length; i++) {\n                    points.push(this.getTouchPosition(list[i], vp));\n                }\n                const centroid = Point2d.createZero();\n                PolygonOps.centroidAndAreaXY(points, centroid);\n                return centroid;\n            }\n        }\n    }\n    static findTouchById(list, id) {\n        // eslint-disable-next-line @typescript-eslint/prefer-for-of\n        for (let i = 0; i < list.length; i++) {\n            if (id === list[i].identifier)\n                return list[i];\n        }\n        return undefined;\n    }\n}\n/** A BeButtonEvent generated by movement of a mouse wheel.\n * @note wheel events include mouse location.\n * @public\n * @extensions\n */\nexport class BeWheelEvent extends BeButtonEvent {\n    constructor(props) {\n        super(props);\n        this.wheelDelta = (props && props.wheelDelta !== undefined) ? props.wheelDelta : 0;\n        this.time = (props && props.time) ? props.time : Date.now();\n    }\n    setFrom(src) {\n        super.setFrom(src);\n        this.wheelDelta = src.wheelDelta;\n        this.time = src.time;\n        return this;\n    }\n}\n/** A Tool that performs an action. It has a *toolId* that uniquely identifies it, so it can be found via a lookup in the [[ToolRegistry]].\n * Every time a tools run, a new instance of (a subclass of) this class is created and its [[run]] method is invoked.\n * @see [[InteractiveTool]] for a base Tool class to handle user input events from a Viewport.\n * @see [Tools]($docs/learning/frontend/tools.md)\n * @public\n * @extensions\n */\nclass Tool {\n    /** @internal */\n    get ctor() { return this.constructor; }\n    constructor(..._args) { }\n    /** The minimum number of arguments allowed by [[parseAndRun]]. If subclasses override [[parseAndRun]], they should also\n     * override this method to indicate the minimum number of arguments their implementation expects. UI controls can use\n     * this information to ensure the tool has enough information to execute.\n     */\n    static get minArgs() { return 0; }\n    /** The maximum number of arguments allowed by [[parseAndRun]], or undefined if there is no maximum.\n     * If subclasses override [[parseAndRun]], they should also override this method to indicate the maximum\n     * number of arguments their implementation expects.\n     */\n    static get maxArgs() { return 0; }\n    /**\n     * Register this Tool class with the [[ToolRegistry]].\n     * @param namespace optional namespace to supply to [[ToolRegistry.register]]. If undefined, use namespace from superclass.\n     */\n    static register(namespace) {\n        IModelApp.tools.register(this, namespace);\n    }\n    static getLocalizedKey(name) {\n        const key = `tools.${this.toolId}.${name}`;\n        const val = IModelApp.localization.getLocalizedString(key, { ns: this.namespace });\n        return key === val ? undefined : val; // if translation for key doesn't exist, `translate` returns the key as the result\n    }\n    /**\n     * Get the localized keyin string for this Tool class. This returns the value of \"tools.\" + this.toolId + \".keyin\" from\n     * its registered Namespace (e.g. \"en/MyApp.json\").\n     */\n    static get keyin() {\n        const keyin = this.getLocalizedKey(\"keyin\");\n        return (undefined !== keyin) ? keyin : \"\"; // default to empty string\n    }\n    /**\n     * Get the English keyin string for this Tool class. This returns the value of \"tools.\" + this.toolId + \".keyin\" from\n     * its registered Namespace (e.g. \"en/MyApp.json\").\n     */\n    static get englishKeyin() {\n        const key = `tools.${this.toolId}.keyin`;\n        const val = IModelApp.localization.getEnglishString(this.namespace, key);\n        return val !== key ? val : \"\"; // default to empty string\n    }\n    /**\n     * Get the localized flyover for this Tool class. This returns the value of \"tools.\" + this.toolId + \".flyover\" from\n     * its registered Namespace (e.g. \"en/MyApp.json\"). If that key is not in the localization namespace,\n     * [[keyin]] is returned.\n     */\n    static get flyover() {\n        const flyover = this.getLocalizedKey(\"flyover\");\n        return (undefined !== flyover) ? flyover : this.keyin; // default to keyin\n    }\n    /**\n     * Get the localized description for this Tool class. This returns the value of \"tools.\" + this.toolId + \".description\" from\n     * its registered Namespace (e.g. \"en/MyApp.json\"). If that key is not in the localization namespace,\n     * [[flyover]] is returned.\n     */\n    static get description() {\n        const description = this.getLocalizedKey(\"description\");\n        return (undefined !== description) ? description : this.flyover; // default to flyover\n    }\n    /**\n     * Get the toolId string for this Tool class. This string is used to identify the Tool in the ToolRegistry and is used to localize\n     * the keyin, description, etc. from the current locale.\n     */\n    get toolId() { return this.ctor.toolId; }\n    /** Get the localized keyin string from this Tool's class\n     * @see `static get keyin()`\n     */\n    get keyin() { return this.ctor.keyin; }\n    /** Get the localized flyover string from this Tool's class\n     * @see `static get flyover()`\n     */\n    get flyover() { return this.ctor.flyover; }\n    /** Get the localized description string from this Tool's class\n     * @see `static get description()`\n     */\n    get description() { return this.ctor.description; }\n    /** Get the iconSpec from this Tool's class.\n     * @see `static iconSpec`\n     */\n    get iconSpec() { return this.ctor.iconSpec; }\n    /**\n     * Run this instance of a Tool. Subclasses should override to perform some action.\n     * @returns `true` if the tool executed successfully.\n     */\n    async run(..._args) { return true; }\n    /** Run this instance of a tool using a series of string arguments. Override this method to parse the arguments, and if they're\n     * acceptable, execute your [[run]] method. If the arguments aren't valid, return `false`.\n     * @note if you override this method, you must also override the static [[minArgs]] and [[maxArgs]] getters.\n     * @note Generally, implementers of this method are **not** expected to call `super.parseAndRun(...)`. Instead, call your\n     * [[run]] method with the appropriate (parsed) arguments directly.\n     */\n    async parseAndRun(..._args) {\n        return this.run();\n    }\n}\n/** If true, this Tool will not appear in the list from [[ToolRegistry.getToolList]]. This should be overridden in subclasses to hide them. */\nTool.hidden = false;\n/** The unique string that identifies this tool. This must be overridden in every subclass. */\nTool.toolId = \"\";\n/** The icon for this Tool. This may be overridden in subclasses to provide a tool icon.\n * The value is the name of an icon WebFont entry, or if specifying an SVG symbol, use `svg:` prefix.\n */\nTool.iconSpec = \"\";\nexport { Tool };\n/**\n * @public\n * @extensions\n */\nexport var EventHandled;\n(function (EventHandled) {\n    EventHandled[EventHandled[\"No\"] = 0] = \"No\";\n    EventHandled[EventHandled[\"Yes\"] = 1] = \"Yes\";\n})(EventHandled || (EventHandled = {}));\n/** A Tool that may be installed, via [[ToolAdmin]], to handle user input. The ToolAdmin manages the currently installed ViewingTool, PrimitiveTool,\n * InputCollector, and IdleTool. Each must derive from this class and there may only be one of each type installed at a time.\n * @public\n * @extensions\n */\nexport class InteractiveTool extends Tool {\n    constructor() {\n        super(...arguments);\n        /** Used to avoid sending tools up events for which they did not receive the down event. */\n        this.receivedDownEvent = false;\n    }\n    /** Override to execute additional logic when tool is installed. Return false to prevent this tool from becoming active */\n    async onInstall() { return true; }\n    /** Override to execute additional logic after tool becomes active */\n    async onPostInstall() { }\n    /** Override Call to reset tool to initial state */\n    async onReinitialize() { }\n    /** Invoked when the tool becomes no longer active, to perform additional cleanup logic */\n    async onCleanup() { }\n    /** Notification of a ViewTool or InputCollector starting and this tool is being suspended.\n     * @note Applies only to PrimitiveTool and InputCollector, a ViewTool can't be suspended.\n     */\n    async onSuspend() { }\n    /** Notification of a ViewTool or InputCollector exiting and this tool is being unsuspended.\n     *  @note Applies only to PrimitiveTool and InputCollector, a ViewTool can't be suspended.\n     */\n    async onUnsuspend() { }\n    /** Called to support operations on pickable decorations, like snapping. */\n    testDecorationHit(_id) { return false; }\n    /** Called to allow snapping to pickable decoration geometry.\n     * @note Snap geometry can be different from decoration geometry (ex. center point of a + symbol). Valid decoration geometry for snapping should be \"stable\" and not change based on the current cursor location.\n     */\n    getDecorationGeometry(_hit) { return undefined; }\n    /**\n     * Called to allow an active tool to display non-element decorations in overlay mode.\n     * This method is NOT called while the tool is suspended by a viewing tool or input collector.\n     */\n    decorate(_context) { }\n    /**\n     * Called to allow a suspended tool to display non-element decorations in overlay mode.\n     * This method is ONLY called when the tool is suspended by a viewing tool or input collector.\n     * @note Applies only to PrimitiveTool and InputCollector, a ViewTool can't be suspended.\n     */\n    decorateSuspended(_context) { }\n    /** Invoked when the reset button is pressed.\n     * @return No by default. Sub-classes may ascribe special meaning to this status.\n     * @note To support right-press menus, a tool should put its reset event processing in onResetButtonUp instead of onResetButtonDown.\n     */\n    async onResetButtonDown(_ev) { return EventHandled.No; }\n    /** Invoked when the reset button is released.\n     * @return No by default. Sub-classes may ascribe special meaning to this status.\n     */\n    async onResetButtonUp(_ev) { return EventHandled.No; }\n    /** Invoked when the data button is pressed.\n     * @return No by default. Sub-classes may ascribe special meaning to this status.\n     */\n    async onDataButtonDown(_ev) { return EventHandled.No; }\n    /** Invoked when the data button is released.\n     * @return No by default. Sub-classes may ascribe special meaning to this status.\n     */\n    async onDataButtonUp(_ev) { return EventHandled.No; }\n    /** Invoked when the middle mouse button is pressed.\n     * @return Yes if event completely handled by tool and event should not be passed on to the IdleTool.\n     */\n    async onMiddleButtonDown(_ev) { return EventHandled.No; }\n    /** Invoked when the middle mouse button is released.\n     * @return Yes if event completely handled by tool and event should not be passed on to the IdleTool.\n     */\n    async onMiddleButtonUp(_ev) { return EventHandled.No; }\n    /** Invoked when the cursor is moving */\n    async onMouseMotion(_ev) { }\n    /** Invoked when the cursor begins moving while a button is depressed.\n     * @return Yes if event completely handled by tool and event should not be passed on to the IdleTool.\n     */\n    async onMouseStartDrag(_ev) { return EventHandled.No; }\n    /** Invoked when the button is released after onMouseStartDrag.\n     * @note default placement tool behavior is to treat press, drag, and release of data button the same as click, click by calling onDataButtonDown.\n     * @return Yes if event completely handled by tool and event should not be passed on to the IdleTool.\n     */\n    async onMouseEndDrag(ev) {\n        if (BeButton.Data !== ev.button)\n            return EventHandled.No;\n        if (ev.isDown)\n            return this.onDataButtonDown(ev);\n        const downEv = ev.clone();\n        downEv.isDown = true;\n        return this.onDataButtonDown(downEv);\n    }\n    /** Invoked when the mouse wheel moves.\n     * @return Yes if event completely handled by tool and event should not be passed on to the IdleTool.\n     */\n    async onMouseWheel(_ev) { return EventHandled.No; }\n    /** Called when Control, Shift, or Alt modifier keys are pressed or released.\n     * @param _wentDown up or down key event\n     * @param _modifier The modifier key mask\n     * @param _event The event that caused this call\n     * @return Yes to refresh view decorations or update dynamics.\n     */\n    async onModifierKeyTransition(_wentDown, _modifier, _event) { return EventHandled.No; }\n    /** Called when any key is pressed or released.\n     * @param _wentDown up or down key event\n     * @param _keyEvent The KeyboardEvent\n     * @return Yes to prevent further processing of this event\n     * @see [[onModifierKeyTransition]]\n     */\n    async onKeyTransition(_wentDown, _keyEvent) { return EventHandled.No; }\n    /** Called when user adds a touch point by placing a finger or stylus on the surface. */\n    async onTouchStart(_ev) { }\n    /** Called when user removes a touch point by lifting a finger or stylus from the surface. */\n    async onTouchEnd(_ev) { }\n    /** Called when the last touch point is removed from the surface completing the current gesture. This is a convenience event sent following onTouchEnd when no target touch points remain on the surface. */\n    async onTouchComplete(_ev) { }\n    /** Called when a touch point is interrupted in some way and needs to be dropped from the list of target touches. */\n    async onTouchCancel(_ev) { }\n    /** Called when a touch point moves along the surface. */\n    async onTouchMove(_ev) { }\n    /** Called after at least one touch point has moved for an appreciable time and distance along the surface to not be considered a tap.\n     * @param _ev The event that caused this call\n     * @param _startEv The event from the last call to onTouchStart\n     * @return Yes if event completely handled by tool and event should not be passed on to the IdleTool.\n     */\n    async onTouchMoveStart(_ev, _startEv) { return EventHandled.No; }\n    /** Called when touch point(s) are added and removed from a surface within a small time window without any touch point moving.\n     * @param _ev The event that caused this call\n     * @return Yes if event completely handled by tool and event should not be passed on to the IdleTool.\n     * @note A double or triple tap event will not be preceded by a single tap event.\n     */\n    async onTouchTap(_ev) { return EventHandled.No; }\n    isCompatibleViewport(_vp, _isSelectedViewChange) { return true; }\n    isValidLocation(_ev, _isButtonEvent) { return true; }\n    /**\n     * Called when active view changes. Tool may choose to restart or exit based on current view type.\n     * @param previous The previously active view.\n     * @param current The new active view.\n     */\n    onSelectedViewportChanged(_previous, _current) { }\n    /**\n     * Invoked before the locate tooltip is displayed to retrieve the information about the located element. Allows the tool to override the toolTip.\n     * @param hit The HitDetail whose info is needed.\n     * @return A Promise for the HTMLElement or string to describe the hit.\n     * @note If you override this method, you may decide whether to call your superclass' implementation or not (it is not required).\n     */\n    async getToolTip(_hit) { return _hit.getToolTip(); }\n    /** Convenience method to check whether control key is currently down without needing a button event. */\n    get isControlDown() { return IModelApp.toolAdmin.currentInputState.isControlDown; }\n    /** Fill the supplied button event from the current cursor location.   */\n    getCurrentButtonEvent(ev) { IModelApp.toolAdmin.fillEventFromCursorLocation(ev); }\n    /** Call to find out if dynamics are currently active. */\n    get isDynamicsStarted() { return IModelApp.viewManager.inDynamicsMode; }\n    /** Call to initialize dynamics mode. While dynamics are active onDynamicFrame will be called. Dynamics are typically only used by a PrimitiveTool that creates or modifies geometric elements. */\n    beginDynamics() { IModelApp.toolAdmin.beginDynamics(); }\n    /** Call to terminate dynamics mode. */\n    endDynamics() { IModelApp.toolAdmin.endDynamics(); }\n    /** Called to allow Tool to display dynamic elements. */\n    onDynamicFrame(_ev, _context) { }\n    /** Invoked to allow tools to filter which elements can be located.\n     * @return Reject if hit is unacceptable for this tool (fill out response with explanation, if it is defined)\n     */\n    async filterHit(_hit, _out) { return LocateFilterStatus.Accept; }\n    /** Helper method to keep the view cursor, display of locate circle, and coordinate lock overrides consistent with [[AccuSnap.isLocateEnabled]] and [[AccuSnap.isSnapEnabled]].\n     * @param enableLocate Value to pass to [[AccuSnap.enableLocate]]. Tools that locate elements should always pass true to give the user feedback regarding the element at the current cursor location.\n     * @param enableSnap Optional value to pass to [[AccuSnap.enableSnap]]. Tools that don't care about the element pick location should not pass true. Default is false.\n     * @note User must also have snapping enabled [[AccuSnap.isSnapEnabledByUser]], otherwise [[TentativePoint]] is used to snap.\n     * @param cursor Optional tool specific cursor override. Default is either cross or dynamics cursor depending on whether dynamics are currently active.\n     * @param coordLockOvr Optional tool specific coordinate lock overrides. A tool that only identifies elements and does not use [[BeButtonEvent.point]] can set ToolState.coordLockOvr to CoordinateLockOverrides.ACS\n     * or CoordinateLockOverrides.All, otherwise locate is affected by the input point being first projected to the ACS plane. A tool that will use [[BeButtonEvent.point]], especially those that call [[AccuSnap.enableSnap]]\n     * should honor all locks and leave ToolState.coordLockOvr set to CoordinateLockOverrides.None, the default for ViewTool and PrimitiveTool.\n     */\n    changeLocateState(enableLocate, enableSnap, cursor, coordLockOvr) {\n        const { toolAdmin, viewManager, accuSnap } = IModelApp;\n        if (undefined !== cursor) {\n            toolAdmin.setCursor(cursor);\n            toolAdmin.setLocateCircleOn(enableLocate);\n            viewManager.invalidateDecorationsAllViews();\n        }\n        else {\n            toolAdmin.setLocateCursor(enableLocate);\n        }\n        // Always set the one that is true first, otherwise AccuSnap will clear the TouchCursor.\n        if (enableLocate) {\n            accuSnap.enableLocate(true);\n            accuSnap.enableSnap(true === enableSnap);\n        }\n        else {\n            accuSnap.enableSnap(true === enableSnap);\n            accuSnap.enableLocate(false);\n        }\n        if (undefined !== coordLockOvr) {\n            toolAdmin.toolState.coordLockOvr = coordLockOvr;\n        }\n        else {\n            if (enableLocate && !accuSnap.isSnapEnabled)\n                toolAdmin.toolState.coordLockOvr |= CoordinateLockOverrides.ACS;\n            else\n                toolAdmin.toolState.coordLockOvr &= ~CoordinateLockOverrides.ACS;\n        }\n    }\n    /** Helper method for tools that need to locate existing elements.\n     * Initializes [[ElementLocateManager]], changes the view cursor to locate, enables display of the locate circle, and sets the appropriate coordinate lock overrides.\n     * @see [[changeLocateState]]\n     */\n    initLocateElements(enableLocate = true, enableSnap, cursor, coordLockOvr) {\n        IModelApp.locateManager.initToolLocate();\n        this.changeLocateState(enableLocate, enableSnap, cursor, coordLockOvr);\n    }\n    /** @internal */\n    restoreToolSettingPropertyValue(property) {\n        const itemValue = IModelApp.toolAdmin.toolSettingsState.getInitialToolSettingValue(this.toolId, property.name);\n        if (undefined === itemValue?.value)\n            return false;\n        property.dialogItemValue = itemValue;\n        return true;\n    }\n    /** @internal */\n    saveToolSettingPropertyValue(property, itemValue) {\n        if (undefined === itemValue.value)\n            return false;\n        property.value = itemValue.value;\n        IModelApp.toolAdmin.toolSettingsState.saveToolSettingProperty(this.toolId, property.item);\n        return true;\n    }\n    /** @internal */\n    syncToolSettingPropertyValue(property, isDisabled) {\n        if (undefined !== isDisabled)\n            property.isDisabled = isDisabled;\n        this.syncToolSettingsProperties([property.syncItem]);\n    }\n    /** @internal */\n    getToolSettingPropertyByName(propertyName) {\n        const foundProperty = this.toolSettingProperties?.get(propertyName);\n        if (foundProperty)\n            return foundProperty;\n        throw new Error(`property not found: ${propertyName}`);\n    }\n    /** Override to return the property that is disabled/enabled if the supplied property is a lock property.\n     * @see [[changeToolSettingPropertyValue]]\n     * @public\n     */\n    getToolSettingPropertyLocked(_property) {\n        return undefined;\n    }\n    /** Helper method for responding to a tool setting property value change by updating saved settings.\n     * @see [[applyToolSettingPropertyChange]]\n     * @see [[getToolSettingPropertyLocked]] to return the corresponding locked property, if any.\n     * @public\n     */\n    changeToolSettingPropertyValue(syncItem) {\n        const property = this.getToolSettingPropertyByName(syncItem.propertyName);\n        if (!this.saveToolSettingPropertyValue(property, syncItem.value))\n            return false;\n        const lockedProperty = this.getToolSettingPropertyLocked(property);\n        if (undefined !== lockedProperty)\n            this.syncToolSettingPropertyValue(lockedProperty, !property.value);\n        return true;\n    }\n    /** Helper method to establish initial values for tool setting properties from saved settings.\n     * @see [[supplyToolSettingsProperties]]\n     * @public\n     */\n    initializeToolSettingPropertyValues(properties) {\n        if (undefined !== this.toolSettingProperties)\n            return;\n        this.toolSettingProperties = new Map();\n        for (const property of properties) {\n            this.toolSettingProperties.set(property.name, property);\n            this.restoreToolSettingPropertyValue(property);\n        }\n    }\n    /** Used to supply list of properties that can be used to generate ToolSettings. If undefined is returned then no ToolSettings will be displayed.\n     * @see [[initializeToolSettingPropertyValues]]\n     * @public\n     */\n    supplyToolSettingsProperties() { return undefined; }\n    /** Used to receive property changes from UI. Return false if there was an error applying updatedValue.\n     * @see [[changeToolSettingPropertyValue]]\n     * @public\n     */\n    async applyToolSettingPropertyChange(_updatedValue) { return true; }\n    /** Called by tool to synchronize the UI with property changes made by tool. This is typically used to provide user feedback during tool dynamics.\n     * If the syncData contains a quantity value and if the displayValue is not defined, the displayValue will be generated in the UI layer before displaying the value.\n     * @public\n     */\n    syncToolSettingsProperties(syncData) {\n        IModelApp.toolAdmin.syncToolSettingsProperties(this.toolId, syncData);\n    }\n    /** Called by tool to inform UI to reload ToolSettings with new set of properties. This allows properties to be added or removed from ToolSetting\n     * component as tool processing progresses.\n     * @public\n     */\n    reloadToolSettingsProperties() {\n        IModelApp.toolAdmin.reloadToolSettingsProperties();\n    }\n    /** Used to \"bump\" the value of a tool setting. To \"bump\" a setting means to toggle a boolean value or cycle through enum values.\n     * If no `settingIndex` param is specified, the first setting is bumped.\n     * Return true if the setting was successfully bumped.\n     * @public\n     */\n    async bumpToolSetting(_settingIndex) { return false; }\n}\n/** The InputCollector class can be used to implement a command for gathering input\n * (ex. get a distance by snapping to 2 points) without affecting the state of the active primitive tool.\n * An InputCollector will suspend the active PrimitiveTool and can be suspended by a ViewTool.\n * @public\n * @extensions\n */\nexport class InputCollector extends InteractiveTool {\n    async run(..._args) {\n        const toolAdmin = IModelApp.toolAdmin;\n        // An input collector can only suspend a primitive tool, don't install if a viewing tool is active...\n        if (undefined !== toolAdmin.viewTool || !await toolAdmin.onInstallTool(this))\n            return false;\n        await toolAdmin.startInputCollector(this);\n        await toolAdmin.onPostInstallTool(this);\n        return true;\n    }\n    async exitTool() {\n        return IModelApp.toolAdmin.exitInputCollector();\n    }\n    async onResetButtonUp(_ev) {\n        await this.exitTool();\n        return EventHandled.Yes;\n    }\n}\n/** The result type of [[ToolRegistry.parseAndRun]].\n * @public\n * @extensions\n */\nexport var ParseAndRunResult;\n(function (ParseAndRunResult) {\n    /** The tool's `parseAndRun` method was invoked and returned `true`. */\n    ParseAndRunResult[ParseAndRunResult[\"Success\"] = 0] = \"Success\";\n    /** No tool matching the toolId in the keyin is registered. */\n    ParseAndRunResult[ParseAndRunResult[\"ToolNotFound\"] = 1] = \"ToolNotFound\";\n    /** The number of arguments supplied does not meet the constraints of the Tool. @see [[Tool.minArgs]] and [[Tool.maxArgs]]. */\n    ParseAndRunResult[ParseAndRunResult[\"BadArgumentCount\"] = 2] = \"BadArgumentCount\";\n    /** The tool's `parseAndRun` method returned `false`. */\n    ParseAndRunResult[ParseAndRunResult[\"FailedToRun\"] = 3] = \"FailedToRun\";\n    /** An opening double-quote character was not paired with a closing double-quote character. */\n    ParseAndRunResult[ParseAndRunResult[\"MismatchedQuotes\"] = 4] = \"MismatchedQuotes\";\n})(ParseAndRunResult || (ParseAndRunResult = {}));\n/** Possible errors resulting from [[ToolRegistry.parseKeyin]].\n * @public\n * @extensions\n */\nexport var KeyinParseError;\n(function (KeyinParseError) {\n    /** No registered tool matching the keyin was found. */\n    KeyinParseError[KeyinParseError[\"ToolNotFound\"] = 1] = \"ToolNotFound\";\n    /** The opening double-quote of an argument was not terminated with a closing double-quote. */\n    KeyinParseError[KeyinParseError[\"MismatchedQuotes\"] = 4] = \"MismatchedQuotes\";\n})(KeyinParseError || (KeyinParseError = {}));\n/** The ToolRegistry holds a mapping between toolIds and their corresponding [[Tool]] class. This provides the mechanism to\n * find Tools by their toolId, and also a way to iterate over the set of Tools available.\n * @public\n */\nexport class ToolRegistry {\n    constructor() {\n        this.tools = new Map();\n    }\n    shutdown() {\n        this.tools.clear();\n        this._keyinList = undefined;\n    }\n    /**\n     * Un-register a previously registered Tool class.\n     * @param toolId the toolId of a previously registered tool to unRegister.\n     */\n    unRegister(toolId) {\n        this.tools.delete(toolId);\n        this._keyinList = undefined;\n    }\n    /**\n     * Register a Tool class. This establishes a connection between the toolId of the class and the class itself.\n     * @param toolClass the subclass of Tool to register.\n     * @param namespace the namespace for the localized strings for this tool. If undefined, use namespace from superclass.\n     */\n    register(toolClass, namespace) {\n        if (namespace) // namespace is optional because it can come from superclass\n            toolClass.namespace = namespace;\n        if (toolClass.toolId.length === 0)\n            return; // must be an abstract class, ignore it\n        if (!toolClass.namespace)\n            throw new IModelError(-1, \"Tools must have a namespace\");\n        this.tools.set(toolClass.toolId, toolClass);\n        this._keyinList = undefined; // throw away the current keyinList so we'll produce a new one next time we're asked.\n    }\n    /**\n     * Register all the Tool classes found in a module.\n     * @param modelObj the module to search for subclasses of Tool.\n     */\n    registerModule(moduleObj, namespace) {\n        for (const thisMember in moduleObj) { // eslint-disable-line guard-for-in\n            const thisTool = moduleObj[thisMember];\n            if (thisTool.prototype instanceof Tool) {\n                this.register(thisTool, namespace);\n            }\n        }\n    }\n    /** Look up a tool by toolId */\n    find(toolId) {\n        return this.tools.get(toolId);\n    }\n    /**\n     * Look up a tool by toolId and, if found, create an instance with the supplied arguments.\n     * @param toolId the toolId of the tool\n     * @param args arguments to pass to the constructor.\n     * @returns an instance of the registered Tool class, or undefined if toolId is not registered.\n     */\n    create(toolId, ...args) {\n        const toolClass = this.find(toolId);\n        return toolClass ? new toolClass(...args) : undefined;\n    }\n    /**\n     * Look up a tool by toolId and, if found, create an instance with the supplied arguments and run it.\n     * @param toolId toolId of the immediate tool\n     * @param args arguments to pass to the constructor, and to run.\n     * @return true if the tool was found and successfully run.\n     */\n    async run(toolId, ...args) {\n        const tool = this.create(toolId, ...args);\n        return tool !== undefined && tool.run(...args);\n    }\n    /**\n     * Split key-in into and array of string arguments. Handles embedded quoted strings.\n     * @param keyin keyin string to process\n     * #return an Array of string argument\n     */\n    tokenize(keyin) {\n        const isWhitespace = (char) => \"\" === char.trim();\n        const tokens = [];\n        let index = 0;\n        let firstQuotedIndex;\n        while (index < keyin.length) {\n            // Looking for beginning of next token.\n            const ch = keyin[index];\n            if (isWhitespace(ch)) {\n                ++index;\n                continue;\n            }\n            if ('\"' !== ch) {\n                // Unquoted token.\n                let endIndex = keyin.length;\n                for (let i = index + 1; i < keyin.length; i++) {\n                    if (isWhitespace(keyin[i])) {\n                        endIndex = i;\n                        break;\n                    }\n                }\n                tokens.push(keyin.substring(index, endIndex));\n                index = endIndex;\n                continue;\n            }\n            // Quoted argument.\n            if (undefined === firstQuotedIndex)\n                firstQuotedIndex = tokens.length;\n            let endQuoteIndex;\n            let searchIndex = index + 1;\n            let anyEmbeddedQuotes = false;\n            while (searchIndex < keyin.length) {\n                searchIndex = keyin.indexOf('\"', searchIndex);\n                if (-1 === searchIndex)\n                    break;\n                // A literal \" is embedded as \"\"\n                if (searchIndex + 1 > keyin.length || keyin[searchIndex + 1] !== '\"') {\n                    endQuoteIndex = searchIndex;\n                    break;\n                }\n                anyEmbeddedQuotes = true;\n                searchIndex = searchIndex + 2;\n            }\n            if (undefined === endQuoteIndex) {\n                return { tokens, mismatchedQuotes: true };\n            }\n            else {\n                let token = keyin.substring(index + 1, endQuoteIndex);\n                if (anyEmbeddedQuotes) {\n                    const regex = /\"\"/g;\n                    token = token.replace(regex, '\"');\n                }\n                tokens.push(token);\n                index = endQuoteIndex + 1;\n            }\n        }\n        return { tokens, firstQuotedIndex };\n    }\n    /** Given a string consisting of a toolId followed by any number of arguments, locate the corresponding Tool and parse the arguments.\n     * Tokens are delimited by whitespace.\n     * The Tool is determined by finding the longest string of unquoted tokens starting at the beginning of the key-in string that matches a registered Tool's\n     * `keyin` or `englishKeyin`.\n     * Tokens following the Tool's keyin are parsed as arguments.\n     * Arguments may be quoted using \"double quotes\". The opening quote must be preceded by whitespace. Examples, assuming the tool Id is `my keyin`:\n     *  - `my keyin \"abc\" \"def\"` => two arguments: `abc` and `def`\n     *  - `my keyin abc\"def\"` => one argument: `abc\"def\"`\n     * A literal double-quote character can be embedded in a quoted argument as follows:\n     *  - `my keyin \"abc\"\"def\"` => one argument: `abc\"def`.\n     * @param keyin A string consisting of a toolId followed by any number of arguments. The arguments are separated by whitespace.\n     * @returns The tool, if found, along with an array of parsed arguments.\n     * @public\n     */\n    parseKeyin(keyin) {\n        const tools = this.getToolList();\n        let tool;\n        const args = [];\n        const findTool = (lowerKeyin) => tools.find((x) => x.keyin.toLowerCase() === lowerKeyin || x.englishKeyin.toLowerCase() === lowerKeyin);\n        // try the trivial, common case first\n        tool = findTool(keyin.toLowerCase());\n        if (undefined !== tool)\n            return { ok: true, tool, args };\n        // Tokenize to separate keyin from arguments\n        // ###TODO there's actually nothing that prevents a Tool from including leading/trailing spaces in its keyin, or sequences of more than one space...we will fail to find such tools if they exist...\n        const split = this.tokenize(keyin);\n        const tokens = split.tokens;\n        if (split.mismatchedQuotes)\n            return { ok: false, error: KeyinParseError.MismatchedQuotes };\n        else if (tokens.length <= 1)\n            return { ok: false, error: KeyinParseError.ToolNotFound };\n        // Find the longest starting substring that matches a tool's keyin.\n        const maxIndex = undefined !== split.firstQuotedIndex ? split.firstQuotedIndex - 1 : tokens.length - 2;\n        for (let i = maxIndex; i >= 0; i--) {\n            let substr = tokens[0];\n            for (let j = 1; j <= i; j++) {\n                substr += \" \";\n                substr += tokens[j];\n            }\n            tool = findTool(substr.toLowerCase());\n            if (undefined !== tool) {\n                // Any subsequent tokens are arguments.\n                for (let k = i + 1; k < tokens.length; k++)\n                    args.push(tokens[k]);\n                break;\n            }\n        }\n        return tool ? { ok: true, tool, args } : { ok: false, error: KeyinParseError.ToolNotFound };\n    }\n    /** Get a list of Tools currently registered, excluding hidden tools */\n    getToolList() {\n        if (this._keyinList === undefined) {\n            this._keyinList = [];\n            this.tools.forEach((thisTool) => {\n                if (!thisTool.hidden)\n                    this._keyinList.push(thisTool);\n            });\n        }\n        return this._keyinList;\n    }\n    /** Given a string consisting of a toolId followed by any number of arguments, parse the keyin string and invoke the corresponding tool's `parseAndRun` method.\n     * @param keyin A string consisting of a toolId followed by any number of arguments.\n     * @returns A status indicating whether the keyin was successfully parsed and executed.\n     * @see [[parseKeyin]] to parse the keyin string and for a detailed description of the syntax.\n     * @throws any Error thrown by the tool's `parseAndRun` method.\n     * @public\n     */\n    async parseAndRun(keyin) {\n        const parsed = this.parseKeyin(keyin);\n        if (!parsed.ok) {\n            switch (parsed.error) {\n                case KeyinParseError.MismatchedQuotes: return ParseAndRunResult.MismatchedQuotes;\n                case KeyinParseError.ToolNotFound: return ParseAndRunResult.ToolNotFound;\n            }\n        }\n        assert(parsed.ok); // exhaustive switch above...\n        const maxArgs = parsed.tool.maxArgs;\n        if (parsed.args.length < parsed.tool.minArgs || (undefined !== maxArgs && parsed.args.length > maxArgs))\n            return ParseAndRunResult.BadArgumentCount;\n        const tool = new parsed.tool();\n        return await tool.parseAndRun(...parsed.args) ? ParseAndRunResult.Success : ParseAndRunResult.FailedToRun;\n    }\n    /**\n     * Find a tool by its localized keyin using a FuzzySearch\n     * @param keyin the localized keyin string of the Tool.\n     * @note Make sure the i18n resources are all loaded (e.g. `await IModelApp.i81n.waitForAllRead()`) before calling this method.\n     * @public\n     */\n    findPartialMatches(keyin) {\n        return new FuzzySearch().search(this.getToolList(), [\"keyin\"], keyin.toLowerCase());\n    }\n    /**\n     * Find a tool by its localized keyin.\n     * @param keyin the localized keyin string of the Tool.\n     * @returns the Tool class, if an exact match is found, otherwise returns undefined.\n     * @note Make sure the i18n resources are all loaded (e.g. `await IModelApp.i81n.waitForAllRead()`) before calling this method.\n     * @public\n     */\n    findExactMatch(keyin) {\n        keyin = keyin.toLowerCase();\n        return this.getToolList().find((thisTool) => thisTool.keyin.toLowerCase() === keyin);\n    }\n}\n/** @internal */\nclass CoreTools {\n    static translate(prompt) { return IModelApp.localization.getLocalizedString(this.tools + prompt); }\n    static outputPromptByKey(key) { return IModelApp.notifications.outputPromptByKey(this.tools + key); }\n}\nCoreTools.namespace = \"CoreTools\";\nCoreTools.tools = \"CoreTools:tools.\";\nexport { CoreTools };\n//# sourceMappingURL=Tool.js.map",
      "start": 1693508120037,
      "end": 1693508120366,
      "sourcemaps": null
    }
  ]
}
