{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/glsl/Common.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { RenderType } from \"@itwin/webgl-compatibility\";\nimport { System } from \"../System\";\nimport { addModelViewMatrix } from \"./Vertex\";\n// These are not used anywhere currently, but will leave them here commented out in case we want them later.\n// const chooseFloatWithBitFlag2 = `\n// float chooseFloatWithBitFlag(float f1, float f2, uint flags, uint n) { return 0u != (flags & n) ? f2 : f1; }\n// `;\nconst chooseVec2With2BitFlags = `\r\nvec2 chooseVec2With2BitFlags(vec2 v1, vec2 v2, uint flags, uint n1, uint n2) { return 0u != (flags & (n1 | n2)) ? v2 : v1; }\r\n`;\nconst chooseVec3WithBitFlag = `\r\nvec3 chooseVec3WithBitFlag(vec3 v1, vec3 v2, uint flags, uint n) { return 0u != (flags & n) ? v2 : v1; }\r\n`;\n/** @internal */\nexport function addChooseVec2WithBitFlagsFunction(shader) {\n    shader.addFunction(extractNthBit);\n    shader.addFunction(chooseVec2With2BitFlags);\n}\n/** @internal */\nexport function addChooseVec3WithBitFlagFunction(shader) {\n    shader.addFunction(extractNthBit);\n    shader.addFunction(chooseVec3WithBitFlag);\n}\nfunction addShaderFlagsConstants(shader) {\n    shader.addConstant(\"kShaderBit_Monochrome\", 1 /* VariableType.Int */, \"0\");\n    shader.addConstant(\"kShaderBit_NonUniformColor\", 1 /* VariableType.Int */, \"1\");\n    shader.addConstant(\"kShaderBit_OITFlatAlphaWeight\", 1 /* VariableType.Int */, \"2\");\n    shader.addConstant(\"kShaderBit_OITScaleOutput\", 1 /* VariableType.Int */, \"3\");\n    shader.addConstant(\"kShaderBit_IgnoreNonLocatable\", 1 /* VariableType.Int */, \"4\");\n}\nconst shaderFlagArray = new Int32Array(5);\nconst kShaderBitMonochrome = 0;\nconst kShaderBitNonUniformColor = 1;\nconst kShaderBitOITFlatAlphaWeight = 2;\nconst kShaderBitOITScaleOutput = 3;\nconst kShaderBitIgnoreNonLocatable = 4;\nfunction setShaderFlags(uniform, params) {\n    const monochrome = params.target.currentViewFlags.monochrome && params.geometry.wantMonochrome(params.target);\n    shaderFlagArray[kShaderBitMonochrome] = monochrome ? 1 : 0;\n    shaderFlagArray[kShaderBitNonUniformColor] = 0;\n    shaderFlagArray[kShaderBitOITFlatAlphaWeight] = 0;\n    shaderFlagArray[kShaderBitOITScaleOutput] = 0;\n    shaderFlagArray[kShaderBitIgnoreNonLocatable] = 0;\n    const geom = params.geometry.asLUT;\n    if (undefined !== geom) {\n        // Could also be RealityMeshGeometry, so only detect non-uniform color if explicitly LUTGeometry.\n        const color = geom.getColor(params.target);\n        if (color.isNonUniform)\n            shaderFlagArray[kShaderBitNonUniformColor] = 1;\n    }\n    // Certain textures render in the translucent pass but we actually want to maintain true opacity for opaque pixels.\n    // For these, use a constant Z to calculate alpha weight.  Otherwise, the opaque things in the texture are weighted by their Z due\n    // to the nature of the OIT algorithm.  In this case, we set OITFlatAlphaWeight.\n    // Since RGBA8 rendering is very low precision, if we are using that kind of output, we also want to flatten alpha weight.\n    // Otherwise, the very tiny Z range makes things fade to black as the precision limit is encountered.  This workaround disregards Z\n    // in calculating the color, so it means that transparency is less accurate based on Z-ordering, but it is the best we can do with\n    // this algorithm on low-end hardware.\n    // Finally, the application can put the viewport into \"fadeout mode\", which explicitly enables flat alpha weight in order to de-emphasize transparent geometry.\n    const maxRenderType = System.instance.maxRenderType;\n    let flatAlphaWeight = RenderType.TextureUnsignedByte === maxRenderType || params.target.isFadeOutActive;\n    if (!flatAlphaWeight) {\n        const surface = params.geometry.asSurface;\n        flatAlphaWeight = undefined !== surface && (surface.isGlyph || surface.isTileSection);\n    }\n    if (flatAlphaWeight)\n        shaderFlagArray[kShaderBitOITFlatAlphaWeight] = 1;\n    // If Cesium-style transparency is being used with non-float texture targets, we must scale the output in the shaders to 0-1 range.\n    // Otherwise, it will get implicitly clamped to that range and we'll lose any semblance our desired precision (even though it is low).\n    if (maxRenderType < RenderType.TextureHalfFloat)\n        shaderFlagArray[kShaderBitOITScaleOutput] = 1;\n    if (!params.target.drawNonLocatable)\n        shaderFlagArray[kShaderBitIgnoreNonLocatable] = 1;\n    uniform.setUniform1iv(shaderFlagArray);\n}\n/** @internal */\nexport function addShaderFlags(builder) {\n    addShaderFlagsConstants(builder.vert);\n    addShaderFlagsConstants(builder.frag);\n    builder.addUniformArray(\"u_shaderFlags\", 0 /* VariableType.Boolean */, 5, (prog) => {\n        prog.addGraphicUniform(\"u_shaderFlags\", (uniform, params) => setShaderFlags(uniform, params));\n    });\n}\n/** @internal */\nexport function addFrustum(builder) {\n    builder.addUniform(\"u_frustum\", 4 /* VariableType.Vec3 */, (prog) => {\n        prog.addProgramUniform(\"u_frustum\", (uniform, params) => {\n            uniform.setUniform3fv(params.target.uniforms.frustum.frustum);\n        });\n    });\n    builder.addGlobal(\"kFrustumType_Ortho2d\", 2 /* VariableType.Float */, 3 /* ShaderType.Both */, \"0.0\", true);\n    builder.addGlobal(\"kFrustumType_Ortho3d\", 2 /* VariableType.Float */, 3 /* ShaderType.Both */, \"1.0\", true);\n    builder.addGlobal(\"kFrustumType_Perspective\", 2 /* VariableType.Float */, 3 /* ShaderType.Both */, \"2.0\", true);\n}\nconst computeEyeSpace = \"v_eyeSpace = (MAT_MV * rawPosition).rgb;\";\n/** @internal */\nexport function addEyeSpace(builder) {\n    addModelViewMatrix(builder.vert);\n    builder.addInlineComputedVarying(\"v_eyeSpace\", 4 /* VariableType.Vec3 */, computeEyeSpace);\n}\n/** @internal */\nexport const addUInt32s = `\r\nvec4 addUInt32s(vec4 a, vec4 b) {\r\n  vec4 c = a + b;\r\n  if (c.x > 255.0) { c.x -= 256.0; c.y += 1.0; }\r\n  if (c.y > 255.0) { c.y -= 256.0; c.z += 1.0; }\r\n  if (c.z > 255.0) { c.z -= 256.0; c.w += 1.0; }\r\n  return c;\r\n}\r\n`;\n/** Expects flags in range [0...256] with no fraction; and bit is [0..31] with no fraction.\n * Return true if bit `n` is set in `flags`.\n */\nconst nthBitSet = `\r\nbool nthBitSet(float flags, uint n) { return 0u != (uint(flags) & n); }\r\n`;\n/** @internal */\nconst extractNthBit = `\r\nfloat extractNthBit(float flags, uint n) { return 0u != (uint(flags) & n) ? 1.0 : 0.0; }\r\n`;\n/** @internal */\nexport function addExtractNthBit(shader) {\n    shader.addFunction(nthBitSet);\n    shader.addFunction(extractNthBit);\n}\n//# sourceMappingURL=Common.js.map",
      "start": 1693508125849,
      "end": 1693508125940,
      "sourcemaps": null
    }
  ]
}
