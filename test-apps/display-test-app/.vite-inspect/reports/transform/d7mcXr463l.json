{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/Viewport.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Views\n */\nimport { asInstanceOf, assert, BeDuration, BeEvent, BeTimePoint, dispose, Id64, isInstanceOf, StopWatch, } from \"@itwin/core-bentley\";\nimport { Angle, AngleSweep, Arc3d, Geometry, Matrix3d, Plane3dByOriginAndUnitNormal, Point2d, Point3d, Range1d, Range3d, Ray3d, Transform, Vector3d, } from \"@itwin/core-geometry\";\nimport { Camera, CartographicRange, ColorDef, Easing, Frustum, GlobeMode, GridOrientationType, Hilite, Interpolation, isPlacement2dProps, ModelMapLayerSettings, Npc, NpcCenter, Placement2d, Placement3d, SubCategoryAppearance, } from \"@itwin/core-common\";\nimport { ChangeFlag, MutableChangeFlags } from \"./ChangeFlags\";\nimport { CoordSystem } from \"./CoordSystem\";\nimport { DecorationsCache } from \"./DecorationsCache\";\nimport { ElementPicker, LocateOptions } from \"./ElementLocateManager\";\nimport { FrustumAnimator } from \"./FrustumAnimator\";\nimport { GlobeAnimator } from \"./GlobeAnimator\";\nimport { SnapDetail } from \"./HitDetail\";\nimport { IModelApp } from \"./IModelApp\";\nimport { linePlaneIntersect } from \"./LinePlaneIntersect\";\nimport { PerModelCategoryVisibility } from \"./PerModelCategoryVisibility\";\nimport { Decorations } from \"./render/Decorations\";\nimport { FeatureSymbology } from \"./render/FeatureSymbology\";\nimport { FrameStatsCollector } from \"./render/FrameStats\";\nimport { GraphicType } from \"./render/GraphicBuilder\";\nimport { AnimationBranchStates } from \"./render/GraphicBranch\";\nimport { Pixel } from \"./render/Pixel\";\nimport { createRenderPlanFromViewport } from \"./render/RenderPlan\";\nimport { StandardView } from \"./StandardView\";\nimport { SubCategoriesCache } from \"./SubCategoriesCache\";\nimport { DisclosedTileTreeSet, MapCartoRectangle, MapTiledGraphicsProvider, MapTileTreeScaleRangeVisibility, TileBoundingBoxes, TiledGraphicsProvider, TileTreeLoadStatus, TileUser, } from \"./tile/internal\";\nimport { EventController } from \"./tools/EventController\";\nimport { ToolSettings } from \"./tools/ToolSettings\";\nimport { DecorateContext, SceneContext } from \"./ViewContext\";\nimport { viewGlobalLocation, ViewGlobalLocationConstants } from \"./ViewGlobalLocation\";\nimport { ViewingSpace } from \"./ViewingSpace\";\nimport { ViewRect } from \"./common/ViewRect\";\nimport { ViewStatus } from \"./ViewStatus\";\nimport { queryVisibleFeatures } from \"./render/VisibleFeature\";\nimport { FlashSettings } from \"./FlashSettings\";\nimport { GeometricModelState } from \"./ModelState\";\n/** Source of depth point returned by [[Viewport.pickDepthPoint]].\n * @public\n */\nexport var DepthPointSource;\n(function (DepthPointSource) {\n    /** Depth point from geometry within specified radius of pick point */\n    DepthPointSource[DepthPointSource[\"Geometry\"] = 0] = \"Geometry\";\n    /** Depth point from reality model within specified radius of pick point */\n    DepthPointSource[DepthPointSource[\"Model\"] = 1] = \"Model\";\n    /** Depth point from ray projection to background map plane */\n    DepthPointSource[DepthPointSource[\"BackgroundMap\"] = 2] = \"BackgroundMap\";\n    /** Depth point from ray projection to ground plane */\n    DepthPointSource[DepthPointSource[\"GroundPlane\"] = 3] = \"GroundPlane\";\n    /** Depth point from ray projection to grid plane */\n    DepthPointSource[DepthPointSource[\"Grid\"] = 4] = \"Grid\";\n    /** Depth point from ray projection to acs plane */\n    DepthPointSource[DepthPointSource[\"ACS\"] = 5] = \"ACS\";\n    /** Depth point from plane passing through view target point */\n    DepthPointSource[DepthPointSource[\"TargetPoint\"] = 6] = \"TargetPoint\";\n    /** Depth point from map/terrain within specified radius of pick point */\n    DepthPointSource[DepthPointSource[\"Map\"] = 7] = \"Map\";\n})(DepthPointSource || (DepthPointSource = {}));\n/** Describes an undo or redo event for a [[Viewport]].\n * @see [[Viewport.onViewUndoRedo]].\n * @public\n */\nexport var ViewUndoEvent;\n(function (ViewUndoEvent) {\n    ViewUndoEvent[ViewUndoEvent[\"Undo\"] = 0] = \"Undo\";\n    ViewUndoEvent[ViewUndoEvent[\"Redo\"] = 1] = \"Redo\";\n})(ViewUndoEvent || (ViewUndoEvent = {}));\n/** @internal */\nexport const ELEMENT_MARKED_FOR_REMOVAL = Symbol.for(\"@bentley/imodeljs/Viewport/__element_marked_for_removal__\");\n/** A Viewport renders the contents of one or more [GeometricModel]($backend)s onto an `HTMLCanvasElement`.\n *\n * It holds a [[ViewState]] object that defines its viewing parameters; the ViewState in turn defines the [[DisplayStyleState]],\n * [[CategorySelectorState]], and - for [[SpatialViewState]]s - the [[ModelSelectorState]]. While a ViewState is being displayed by a Viewport,\n * it is considered to be \"attached\" to that viewport; it remains attached until the Viewport is disposed of or becomes attached to a different ViewState.\n * While the ViewState is attached to a Viewport, any changes made to the ViewState or its display style or category/model selectors will be automatically\n * reflected in the Viewport. A ViewState can be attached to no more than one Viewport at a time.\n *\n * As changes to ViewState are made, Viewports also hold a stack of *previous copies* of it, to allow\n * for undo/redo (i.e. *View Previous* and *View Next*) of viewing tools.\n *\n * Changes to a Viewport's state can be monitored by attaching an event listener to a variety of specific events. Most such events are\n * triggered only once per frame, just before the Viewport's contents are rendered. For example, if the following sequence of events occurs:\n *\n *   * First frame is rendered\n *   * ViewFlags are modified\n *   * ViewFlags are modified again\n *   * Second frame is rendered\n *\n * The [[Viewport.onDisplayStyleChanged]] event will be invoked exactly once, when the second frame is rendered.\n *\n * @see [[ScreenViewport]] for a viewport that can render onto the screen.\n * @see [[OffScreenViewport]] for a viewport that can render into an off-screen buffer.\n * @public\n * @extensions\n */\nclass Viewport {\n    /** @internal */\n    get sceneValid() { return this._sceneValid; }\n    /** @internal */\n    get renderPlanValid() { return this._renderPlanValid; }\n    /** @internal */\n    setRenderPlanValid() { this._renderPlanValid = true; }\n    /** @internal */\n    get controllerValid() { return this._controllerValid; }\n    /** @internal */\n    get analysisFractionValid() { return this._analysisFractionValid; }\n    /** @internal */\n    get timePointValid() { return this._timePointValid; }\n    /** Strictly for tests. @internal */\n    setAllValid() {\n        this._sceneValid = this._decorationsValid = this._renderPlanValid = this._controllerValid = this._redrawPending\n            = this._analysisFractionValid = this._timePointValid = true;\n    }\n    /** Mark the current set of decorations invalid, so that they will be recreated on the next render frame.\n     * This can be useful, for example, if an external event causes one or more current decorations to become invalid and you wish to force\n     * them to be recreated to show the changes.\n     * @note On the next frame, the `decorate` method of all [[ViewManager.decorators]] will be called. There is no way (or need) to\n     * invalidate individual decorations.\n     */\n    invalidateDecorations() {\n        this._decorationsValid = false;\n        IModelApp.requestNextAnimation();\n    }\n    /** Mark the viewport's scene as having changed, so that the next call to [[renderFrame]] will recreate it.\n     * This method is not typically invoked directly - the scene is automatically invalidated in response to events such as moving the viewing frustum,\n     * changing the set of viewed models, new tiles being loaded, etc.\n     */\n    invalidateScene() {\n        this._sceneValid = false;\n        this._timePointValid = false;\n        this.invalidateDecorations();\n    }\n    /** Mark the viewport's \"render plan\" as having changed, so that the next call to [[renderFrame]] will recreate it.\n     * This method is not typically invoked directly - the render plan is automatically invalidated in response to events such as changing aspects\n     * of the viewport's [[displayStyle]].\n     */\n    invalidateRenderPlan() {\n        this._renderPlanValid = false;\n        this.invalidateScene();\n    }\n    /** Mark the viewport's [[ViewState]] as having changed, so that the next call to [[renderFrame]] will invoke [[setupFromView]] to synchronize with the view.\n     * This method is not typically invoked directly - the controller is automatically invalidated in response to events such as a call to [[changeView]].\n     */\n    invalidateController() {\n        this._controllerValid = this._analysisFractionValid = false;\n        this.invalidateRenderPlan();\n    }\n    /** @internal */\n    setValidScene() {\n        this._sceneValid = true;\n    }\n    /** Request that the Viewport redraw its contents on the next frame. This is useful when some state outside of the Viewport's control but affecting its display has changed.\n     * For example, if the parameters affecting a screen-space effect applied to this Viewport are modified, the Viewport's contents should be redrawn to reflect the change.\n     * @note This does not necessarily cause the viewport to recreate its scene, decorations, or anything else - it only guarantees that the contents will be repainted.\n     */\n    requestRedraw() {\n        this._redrawPending = true;\n        IModelApp.requestNextAnimation();\n    }\n    /** The Id of the most recently flashed element, if any. */\n    get lastFlashedElementId() {\n        return this._lastFlashedElem;\n    }\n    /** For debug purposes, controls whether or not view attachments are displayed in sheet views.\n     * @internal\n     */\n    get wantViewAttachments() { return this._wantViewAttachments; }\n    set wantViewAttachments(want) {\n        if (want !== this._wantViewAttachments) {\n            this._wantViewAttachments = want;\n            this.invalidateScene();\n        }\n    }\n    /** For debug purposes, controls whether or not the boundary of each view attachment is displayed in a sheet view.\n     * @internal\n     */\n    get wantViewAttachmentBoundaries() { return this._wantViewAttachmentBoundaries; }\n    set wantViewAttachmentBoundaries(want) {\n        if (want !== this._wantViewAttachmentBoundaries) {\n            this._wantViewAttachmentBoundaries = want;\n            this.invalidateScene();\n        }\n    }\n    /** For debug purposes, controls whether or not graphics representing the clipping shapes of each view attachment are displayed in a sheet view.\n     * @internal\n     */\n    get wantViewAttachmentClipShapes() { return this._wantViewAttachmentClipShapes; }\n    set wantViewAttachmentClipShapes(want) {\n        if (want !== this._wantViewAttachmentClipShapes) {\n            this._wantViewAttachmentClipShapes = want;\n            this.invalidateScene();\n        }\n    }\n    /** See [DisplayStyle3dSettings.lights]($common) */\n    get lightSettings() {\n        return this.displayStyle.is3d() ? this.displayStyle.settings.lights : undefined;\n    }\n    setLightSettings(settings) {\n        if (this.displayStyle.is3d())\n            this.displayStyle.settings.lights = settings;\n    }\n    /** See [DisplayStyle3dSettings.solarShadows]($common) */\n    get solarShadowSettings() {\n        return this.view.displayStyle.is3d() ? this.view.displayStyle.settings.solarShadows : undefined;\n    }\n    setSolarShadowSettings(settings) {\n        if (this.view.displayStyle.is3d())\n            this.view.displayStyle.solarShadows = settings;\n    }\n    /** @public */\n    get viewingSpace() { return this._viewingSpace; }\n    /** This viewport's rotation matrix. */\n    get rotation() { return this._viewingSpace.rotation; }\n    /** The vector between the opposite corners of this viewport's extents. */\n    get viewDelta() { return this._viewingSpace.viewDelta; }\n    /** Provides conversions between world and view coordinates. */\n    get worldToViewMap() { return this._viewingSpace.worldToViewMap; }\n    /** Provides conversions between world and Npc (non-dimensional perspective) coordinates. */\n    get worldToNpcMap() { return this._viewingSpace.worldToNpcMap; }\n    /** @internal */\n    get frustFraction() { return this._viewingSpace.frustFraction; }\n    /** See [DisplayStyleSettings.analysisFraction]($common). */\n    get analysisFraction() {\n        return this.displayStyle.settings.analysisFraction;\n    }\n    set analysisFraction(fraction) {\n        this.displayStyle.settings.analysisFraction = fraction;\n    }\n    /** See [DisplayStyleSettings.timePoint]($common) */\n    get timePoint() {\n        return this.displayStyle.settings.timePoint;\n    }\n    set timePoint(time) {\n        this.displayStyle.settings.timePoint = time;\n    }\n    /** @internal */\n    get isAspectRatioLocked() { return false; }\n    /** @internal */\n    get target() {\n        assert(undefined !== this._target, \"Accessing RenderTarget of a disposed Viewport\");\n        return this._target;\n    }\n    /** Returns true if this Viewport's [[dispose]] method has been invoked. It is an error to attempt to interact with a disposed Viewport.\n     * Typically a [[ScreenViewport]] becomes disposed as a result of a call to [[ViewManager.dropViewport]], often indirectly through the unmounting of a nine-zone UI's [[ViewportComponent]] when, e.g., switching front-stages.\n     * @public\n     */\n    get isDisposed() {\n        return undefined === this._target;\n    }\n    /** The settings that control how elements are hilited in this Viewport. */\n    get hilite() { return this._hilite; }\n    set hilite(hilite) {\n        this._hilite = hilite;\n        this.invalidateRenderPlan();\n    }\n    /** The settings that control how emphasized elements are displayed in this Viewport. The default settings apply a thick black silhouette to the emphasized elements.\n     * @see [FeatureAppearance.emphasized]($common).\n     */\n    get emphasisSettings() { return this._emphasis; }\n    set emphasisSettings(settings) {\n        this._emphasis = settings;\n        this.invalidateRenderPlan();\n    }\n    /** The settings that control how elements are flashed in this viewport. */\n    get flashSettings() {\n        return this._flash;\n    }\n    set flashSettings(settings) {\n        this._flash = settings;\n        this.invalidateRenderPlan();\n    }\n    /** Determine whether the Grid display is currently enabled in this Viewport.\n     * @return true if the grid display is on.\n     */\n    get isGridOn() { return this.viewFlags.grid; }\n    /** Flags controlling aspects of how the contents of this viewport are rendered.\n     * @see [DisplayStyleSettings.viewFlags]($common).\n     */\n    get viewFlags() { return this.view.viewFlags; }\n    set viewFlags(viewFlags) {\n        this.view.displayStyle.viewFlags = viewFlags;\n    }\n    /** See [[ViewState.displayStyle]] */\n    get displayStyle() { return this.view.displayStyle; }\n    set displayStyle(style) {\n        this.view.displayStyle = style;\n    }\n    /** Selectively override aspects of this viewport's display style.\n     * @see [DisplayStyleSettings.applyOverrides]($common)\n     */\n    overrideDisplayStyle(overrides) {\n        this.displayStyle.settings.applyOverrides(overrides);\n    }\n    /** See [DisplayStyleSettings.clipStyle]($common) */\n    get clipStyle() { return this.displayStyle.settings.clipStyle; }\n    set clipStyle(style) {\n        this.displayStyle.settings.clipStyle = style;\n    }\n    /** Sets the number of [MSAA]($docs/learning/display/MSAA.md) samples for this viewport.\n     * The number of samples is a power of two. Values of 1 or less indicates anti-aliasing should be disabled. Non-power-of-two values are rounded\n     * down to the nearest power of two. The maximum number of samples supported depends upon the client's graphics hardware capabilities. Higher values produce\n     * a higher-quality image but also may also reduce framerate.\n     * @see [[ViewManager.setAntialiasingAllViews]] to adjust the number of samples for all viewports.\n     */\n    get antialiasSamples() {\n        return undefined !== this._target ? this._target.antialiasSamples : 1;\n    }\n    set antialiasSamples(numSamples) {\n        if (undefined !== this._target) {\n            this._target.antialiasSamples = numSamples;\n            this.invalidateRenderPlan();\n        }\n    }\n    /** return true if viewing globe (globeMode is 3D and eye location is far above globe\n     * @alpha\n     */\n    get viewingGlobe() {\n        const view = this.view;\n        if (!view.is3d())\n            return false;\n        return this.displayStyle.globeMode === GlobeMode.Ellipsoid && view.isGlobalView;\n    }\n    /** Remove any [[SubCategoryOverride]] for the specified subcategory.\n     * @param id The Id of the subcategory.\n     * @see [[overrideSubCategory]]\n     */\n    dropSubCategoryOverride(id) {\n        this.view.displayStyle.dropSubCategoryOverride(id);\n    }\n    /** Override the symbology of geometry belonging to a specific subcategory when rendered within this viewport.\n     * @param id The Id of the subcategory.\n     * @param ovr The symbology overrides to apply to all geometry belonging to the specified subcategory.\n     * @see [[dropSubCategoryOverride]]\n     */\n    overrideSubCategory(id, ovr) {\n        this.view.displayStyle.overrideSubCategory(id, ovr);\n    }\n    /** Query the symbology overrides applied to geometry belonging to a specific subcategory when rendered within this viewport.\n     * @param id The Id of the subcategory.\n     * @return The symbology overrides applied to all geometry belonging to the specified subcategory, or undefined if no such overrides exist.\n     * @see [[overrideSubCategory]]\n     */\n    getSubCategoryOverride(id) {\n        return this.view.displayStyle.getSubCategoryOverride(id);\n    }\n    /** Query the symbology with which geometry belonging to a specific subcategory is rendered within this viewport.\n     * Every [[SubCategory]] defines a base symbology independent of any [[Viewport]].\n     * If a [[SubCategoryOverride]] has been applied to the subcategory within the context of this [[Viewport]], it will be applied to the subcategory's base symbology.\n     * @param id The Id of the subcategory.\n     * @return The symbology of the subcategory within this viewport, including any overrides.\n     * @see [[overrideSubCategory]]\n     */\n    getSubCategoryAppearance(id) {\n        const app = this.iModel.subcategories.getSubCategoryAppearance(id);\n        if (undefined === app)\n            return SubCategoryAppearance.defaults;\n        const ovr = this.getSubCategoryOverride(id);\n        return undefined !== ovr ? ovr.override(app) : app;\n    }\n    /** Determine whether geometry belonging to a specific SubCategory is visible in this viewport, assuming the containing Category is displayed.\n     * @param id The Id of the subcategory\n     * @returns true if the subcategory is visible in this viewport.\n     * @note Because this function does not know the Id of the containing Category, it does not check if the Category is enabled for display. The caller should check that separately if he knows the Id of the Category.\n     */\n    isSubCategoryVisible(id) { return this.view.isSubCategoryVisible(id); }\n    /** Override the appearance of a model when rendered within this viewport.\n     * @param id The Id of the model.\n     * @param ovr The symbology overrides to apply to all geometry belonging to the specified subcategory.\n     * @see [DisplayStyleSettings.overrideModelAppearance]($common)\n     */\n    overrideModelAppearance(id, ovr) {\n        this.view.displayStyle.settings.overrideModelAppearance(id, ovr);\n    }\n    /** Remove any model appearance override for the specified model.\n     * @param id The Id of the model.\n     * @see [DisplayStyleSettings.dropModelAppearanceOverride]($common)\n     */\n    dropModelAppearanceOverride(id) {\n        this.view.displayStyle.settings.dropModelAppearanceOverride(id);\n    }\n    /** Some changes may or may not require us to invalidate the scene.\n     * Specifically, when shadows are enabled or we are displaying view attachments, the following changes may affect the visibility or transparency of elements or features:\n     * - Viewed categories and subcategories;\n     * - Always/never drawn elements\n     * - Symbology overrides.\n     */\n    maybeInvalidateScene() {\n        // When shadows are being displayed and the set of displayed categories changes, we must invalidate the scene so that shadows will be regenerated.\n        // Same occurs when changing feature symbology overrides (e.g., always/never-drawn element sets, transparency override)\n        if (!this._sceneValid)\n            return;\n        if (this.view.displayStyle.wantShadows || this.view.isSheetView())\n            this.invalidateScene();\n    }\n    /** Enable or disable display of elements belonging to a set of categories specified by Id.\n     * Visibility of individual subcategories belonging to a category can be controlled separately through the use of [[SubCategoryOverride]]s.\n     * By default, enabling display of a category does not affect display of subcategories thereof which have been overridden to be invisible.\n     * @param categories The Id(s) of the categories to which the change should be applied. No other categories will be affected.\n     * @param display Whether or not elements on the specified categories should be displayed in the viewport.\n     * @param enableAllSubCategories Specifies that when enabling display for a category, all of its subcategories should also be displayed even if they are overridden to be invisible.\n     */\n    changeCategoryDisplay(categories, display, enableAllSubCategories = false) {\n        if (!display) {\n            this.view.categorySelector.dropCategories(categories);\n            return;\n        }\n        this.view.categorySelector.addCategories(categories);\n        const categoryIds = Id64.toIdSet(categories);\n        this.updateSubCategories(categoryIds, enableAllSubCategories);\n    }\n    updateSubCategories(categoryIds, enableAllSubCategories) {\n        this.subcategories.push(this.iModel.subcategories, categoryIds, () => {\n            if (enableAllSubCategories)\n                this.enableAllSubCategories(categoryIds);\n            this._changeFlags.setViewedCategories();\n        });\n    }\n    enableAllSubCategories(categoryIds) {\n        if (this.displayStyle.enableAllLoadedSubCategories(categoryIds))\n            this.maybeInvalidateScene();\n    }\n    /** @internal */\n    getSubCategories(categoryId) { return this.iModel.subcategories.getSubCategories(categoryId); }\n    /** Change the visibility of geometry belonging to the specified subcategory when displayed in this viewport.\n     * @param subCategoryId The Id of the subcategory\n     * @param display: True to make geometry belonging to the subcategory visible within this viewport, false to make it invisible.\n     */\n    changeSubCategoryDisplay(subCategoryId, display) {\n        if (this.displayStyle.setSubCategoryVisible(subCategoryId, display))\n            this.maybeInvalidateScene();\n    }\n    /** The settings controlling how a background map is displayed within a view.\n     * @see [[ViewFlags.backgroundMap]] for toggling display of the map on or off.\n     * @see [DisplayStyleSettings.backgroundMap]($common)\n     */\n    get backgroundMapSettings() { return this.displayStyle.backgroundMapSettings; }\n    set backgroundMapSettings(settings) {\n        this.displayStyle.backgroundMapSettings = settings;\n    }\n    /** See [[DisplayStyleState.changeBackgroundMapProps]] */\n    changeBackgroundMapProps(props) {\n        this.displayStyle.changeBackgroundMapProps(props);\n    }\n    /** See [[DisplayStyleState.changeBackgroundMapProvider]] */\n    changeBackgroundMapProvider(props) {\n        this.displayStyle.changeBackgroundMapProvider(props);\n    }\n    /** @internal */\n    get backgroundMap() { return this._mapTiledGraphicsProvider?.backgroundMap; }\n    /** @internal */\n    get overlayMap() { return this._mapTiledGraphicsProvider?.overlayMap; }\n    /** @internal */\n    get backgroundDrapeMap() { return this._mapTiledGraphicsProvider?.backgroundDrapeMap; }\n    /** Return the imagery provider for the provided map-layer index.\n     * @param mapLayerIndex the [[MapLayerIndex]] of the map layer.\n     * @beta\n     */\n    getMapLayerImageryProvider(mapLayerIndex) { return this._mapTiledGraphicsProvider?.getMapLayerImageryProvider(mapLayerIndex); }\n    /** Return the map-layer scale range visibility for the provided map-layer index.\n     * @param mapLayerIndex the [[MapLayerIndex]] of the map layer.\n     * @see [[DisplayStyleState.mapLayerAtIndex]].\n     * @beta\n     */\n    getMapLayerScaleRangeVisibility(mapLayerIndex) {\n        const treeRef = (mapLayerIndex.isOverlay ? this._mapTiledGraphicsProvider?.overlayMap : this._mapTiledGraphicsProvider?.backgroundMap);\n        if (treeRef) {\n            return treeRef.getMapLayerScaleRangeVisibility(mapLayerIndex.index);\n        }\n        return MapTileTreeScaleRangeVisibility.Unknown;\n    }\n    /** Return a list of map-layers indexes matching a given  MapTile tree Id and a layer imagery tree id.\n     * Note: A imagery tree can be shared for multiple map-layers.\n     * @internal\n     */\n    getMapLayerIndexesFromIds(mapTreeId, layerTreeId) {\n        if (this._mapTiledGraphicsProvider)\n            return this._mapTiledGraphicsProvider?.getMapLayerIndexesFromIds(mapTreeId, layerTreeId);\n        return [];\n    }\n    /** Returns the cartographic range of a map layer.\n     * @param mapLayerIndex the [[MapLayerIndex]] of the map layer.\n     */\n    async getMapLayerRange(mapLayerIndex) {\n        const mapLayerSettings = this.view.displayStyle.mapLayerAtIndex(mapLayerIndex);\n        if (undefined === mapLayerSettings)\n            return undefined;\n        if (mapLayerSettings instanceof ModelMapLayerSettings) {\n            const ecefTransform = this.iModel.ecefLocation?.getTransform();\n            if (!ecefTransform)\n                return undefined;\n            const model = this.iModel.models.getLoaded(mapLayerSettings.modelId);\n            if (!model || !(model instanceof GeometricModelState))\n                return undefined;\n            const modelRange = await model.queryModelRange();\n            const cartoRange = new CartographicRange(modelRange, ecefTransform).getLongitudeLatitudeBoundingBox();\n            return MapCartoRectangle.fromRadians(cartoRange.low.x, cartoRange.low.y, cartoRange.high.x, cartoRange.high.y);\n        }\n        const imageryProvider = this.getMapLayerImageryProvider(mapLayerIndex);\n        if (undefined === imageryProvider)\n            return undefined;\n        const tileTreeRef = mapLayerIndex.isOverlay ? this.overlayMap : this.backgroundMap;\n        const imageryTreeRef = tileTreeRef?.getLayerImageryTreeRef(mapLayerIndex.index);\n        if (imageryTreeRef?.treeOwner.loadStatus === TileTreeLoadStatus.Loaded) {\n            return imageryProvider.cartoRange;\n        }\n        else {\n            return undefined;\n        }\n    }\n    /** Changes viewport to include range of a map layer.\n     * @param mapLayerIndex the [[MapLayerIndex]] of the map layer.\n     * @param vp the viewport.\n     */\n    async viewMapLayerRange(mapLayerIndex, vp) {\n        const range = await this.getMapLayerRange(mapLayerIndex);\n        if (!range)\n            return false;\n        if (range.xLength() > 1.5 * Angle.piRadians)\n            viewGlobalLocation(vp, true, ViewGlobalLocationConstants.satelliteHeightAboveEarthInMeters, undefined, undefined);\n        else\n            viewGlobalLocation(vp, true, undefined, undefined, range.globalLocation);\n        return true;\n    }\n    /** Fully reset a map-layer tile tree; by calling this, the map-layer will to go through initialize process again, and all previously fetched tile will be lost.\n     * @beta\n     */\n    resetMapLayer(mapLayerIndex) { this._mapTiledGraphicsProvider?.resetMapLayer(mapLayerIndex); }\n    /** Returns true if this Viewport is currently displaying the model with the specified Id. */\n    viewsModel(modelId) { return this.view.viewsModel(modelId); }\n    /** Attempt to change the 2d Model this Viewport is displaying, if its ViewState is a ViewState2d.\n     * @param baseModelId The Id of the new 2d Model to be displayed.\n     * @param options options that determine how the new view is displayed\n     * @note This function *only works* if the viewport is viewing a [[ViewState2d]], otherwise it does nothing. Also note that\n     * the Model of baseModelId should be the same type (Drawing or Sheet) as the current view.\n     * @note this method clones the current ViewState2d and sets its baseModelId to the supplied value. The DisplayStyle and CategorySelector remain unchanged.\n     */\n    async changeViewedModel2d(baseModelId, options) {\n        if (!this.view.is2d())\n            return;\n        // Clone the current ViewState, change its baseModelId, and ensure the new model is loaded.\n        const newView = this.view.clone(); // start by cloning the current ViewState\n        await newView.changeViewedModel(baseModelId);\n        this.changeView(newView, options); // switch this viewport to use new ViewState2d\n        if (options && options.doFit) { // optionally fit view to the extents of the new model\n            const range = await this.iModel.models.queryExtents([baseModelId]);\n            this.zoomToVolume(Range3d.fromJSON(range[0]?.extents), options);\n        }\n    }\n    /** Attempt to replace the set of models currently viewed by this viewport, if it is displaying a SpatialView\n     * @param modelIds The Ids of the models to be displayed.\n     * @returns false if this Viewport is not viewing a [[SpatialViewState]]\n     * @note This function *only works* if the viewport is viewing a [[SpatialViewState]], otherwise it does nothing.\n     * @note This function *does not load* any models. If any of the supplied `modelIds` refers to a model that has not been loaded, no graphics will be loaded+displayed in the viewport for that model.\n     * @see [[replaceViewedModels]] for a similar function that also ensures the requested models are loaded.\n     */\n    changeViewedModels(modelIds) {\n        if (!this.view.isSpatialView())\n            return false;\n        this.view.modelSelector.models.clear();\n        this.view.modelSelector.addModels(modelIds);\n        return true;\n    }\n    /** Attempt to replace the set of models currently viewed by this viewport, if it is displaying a SpatialView\n     * @param modelIds The Ids of the models to be displayed.\n     * @note This function *only works* if the viewport is viewing a [[SpatialViewState]], otherwise it does nothing.\n     * @note If any of the requested models is not yet loaded this function will asynchronously load them before updating the set of displayed models.\n     */\n    async replaceViewedModels(modelIds) {\n        if (this.view.isSpatialView()) {\n            this.view.modelSelector.models.clear();\n            return this.addViewedModels(modelIds);\n        }\n    }\n    /** Add or remove a set of models from those models currently displayed in this viewport.\n     * @param modelIds The Ids of the models to add or remove.\n     * @param display Whether or not to display the specified models in the viewport.\n     * @returns false if this Viewport is not viewing a [[SpatialViewState]]\n     * @note This function *only works* if the viewport is viewing a [[SpatialViewState]], otherwise it does nothing.\n     * @note This function *does not load* any models. If `display` is `true` and any of the supplied `models` refers to a model that has not been loaded, no graphics will be loaded+displayed in the viewport for that model.\n     * @see [[addViewedModels]] for a similar function that also ensures the requested models are loaded.\n     */\n    changeModelDisplay(models, display) {\n        if (!this.view.isSpatialView())\n            return false;\n        if (display)\n            this.view.modelSelector.addModels(models);\n        else\n            this.view.modelSelector.dropModels(models);\n        return true;\n    }\n    /** Adds a set of models to the set of those currently displayed in this viewport.\n     * @param modelIds The Ids of the models to add or remove.\n     * @param display Whether or not to display the specified models in the viewport.\n     * @note This function *only works* if the viewport is viewing a [[SpatialViewState]], otherwise it does nothing.\n     * @note If any of the requested models is not yet loaded this function will asynchronously load them before updating the set of displayed models.\n     */\n    async addViewedModels(models) {\n        // NB: We want the model selector to update immediately, to avoid callers repeatedly requesting we load+display the same models while we are already loading them.\n        // This will also trigger scene invalidation and changed events.\n        if (!this.changeModelDisplay(models, true))\n            return; // means it's a 2d model - this function can do nothing useful in 2d.\n        const unloaded = this.iModel.models.filterLoaded(models);\n        if (undefined === unloaded)\n            return;\n        // Need to redraw once models are available. Don't want to trigger events again.\n        await this.iModel.models.load(models);\n        this.invalidateScene();\n        assert(this.view.isSpatialView());\n        this.view.markModelSelectorChanged();\n    }\n    /** Determines what type (if any) of debug graphics will be displayed to visualize [[Tile]] volumes. Chiefly for debugging.\n     * @see [[TileBoundingBoxes]]\n     */\n    get debugBoundingBoxes() { return this._debugBoundingBoxes; }\n    set debugBoundingBoxes(boxes) {\n        if (boxes !== this.debugBoundingBoxes) {\n            this._debugBoundingBoxes = boxes;\n            this.invalidateScene();\n        }\n    }\n    /** When true, the scene will never be recreated. Chiefly for debugging purposes.\n     * @internal\n     */\n    get freezeScene() { return this._freezeScene; }\n    set freezeScene(freeze) {\n        if (freeze !== this._freezeScene) {\n            this._freezeScene = freeze;\n            if (!freeze)\n                this.invalidateScene();\n        }\n    }\n    /** The iModel of this Viewport */\n    get iModel() { return this.view.iModel; }\n    /** @internal */\n    get isPointAdjustmentRequired() { return this.view.is3d(); }\n    /** @internal */\n    get isSnapAdjustmentRequired() { return IModelApp.toolAdmin.acsPlaneSnapLock && this.view.is3d(); }\n    /** @internal */\n    get isContextRotationRequired() { return IModelApp.toolAdmin.acsContextLock; }\n    /** Enables or disables \"fade-out\" mode. When this mode is enabled, transparent graphics are rendered with a flat alpha weight,\n     * causing them to appear de-emphasized. This is typically used in contexts in which a handful of elements are to be emphasized in the view,\n     * while the rest of the graphics are drawn transparently.\n     */\n    get isFadeOutActive() { return this._fadeOutActive; }\n    set isFadeOutActive(active) {\n        if (active !== this._fadeOutActive) {\n            this._fadeOutActive = active;\n            this.invalidateRenderPlan();\n        }\n    }\n    /** Obtain a tooltip from the map layer or reality model, if any, identified by the specified [[HitDetail]]. */\n    async getToolTip(hit) {\n        const promises = new Array();\n        if (this.displayStyle) {\n            this.displayStyle.forEachTileTreeRef(async (tree) => {\n                promises.push(tree.getToolTip(hit).catch(() => undefined));\n            });\n        }\n        this.forEachMapTreeRef(async (tree) => promises.push(tree.getToolTip(hit)));\n        const results = await Promise.all(promises);\n        for (const result of results)\n            if (result !== undefined)\n                return result;\n        return \"\";\n    }\n    /** @beta */\n    async getMapFeatureInfo(hit) {\n        const promises = new Array();\n        // Execute 'getMapFeatureInfo' on every tree, and make sure to handle exception for each call,\n        // so that we get still get results even though a tree has failed.\n        this.forEachMapTreeRef(async (tree) => promises.push(tree.getMapFeatureInfo(hit).catch(() => undefined)));\n        const featureInfo = {};\n        const worldPoint = hit.hitPoint.clone();\n        const backgroundMapGeometry = hit.viewport.displayStyle.getBackgroundMapGeometry();\n        if (undefined !== backgroundMapGeometry) {\n            featureInfo.hitPoint = (await backgroundMapGeometry.dbToCartographicFromGcs([worldPoint]))[0];\n        }\n        const results = await Promise.all(promises);\n        for (const result of results)\n            if (result !== undefined) {\n                if (featureInfo.layerInfos === undefined) {\n                    featureInfo.layerInfos = [];\n                }\n                featureInfo.layerInfos.push(...result);\n            }\n        return featureInfo;\n    }\n    /** A function invoked once, after the constructor, to initialize the viewport's state.\n     * Subclasses can use this perform additional initialization, as the viewport's constructor is not directly invokable.\n     */\n    initialize() {\n    }\n    /** @internal */\n    constructor(target) {\n        /** Event called whenever this viewport is synchronized with its [[ViewState]].\n         * @note This event is invoked *very* frequently. To avoid negatively impacting performance, consider using one of the more specific Viewport events;\n         * otherwise, avoid performing excessive computations in response to this event.\n         * @see [[onViewportChanged]] for receiving events at more regular intervals with more specific information about what changed.\n         * @see [[onChangeView]] for an event raised specifically when a different [[ViewState]] becomes associated with the viewport.\n         */\n        this.onViewChanged = new BeEvent();\n        /** Event called after reversing the most recent change to the Viewport from the undo stack or reapplying the\n         * most recently undone change to the Viewport from the redo stack.\n         */\n        this.onViewUndoRedo = new BeEvent();\n        /** Event called on the next frame after this viewport's set of always-drawn elements changes. */\n        this.onAlwaysDrawnChanged = new BeEvent();\n        /** Event called on the next frame after this viewport's set of never-drawn elements changes. */\n        this.onNeverDrawnChanged = new BeEvent();\n        /** Event called on the next frame after this viewport's [[DisplayStyleState]] or its members change.\n         * Aspects of the display style include [ViewFlags]($common), [SubCategoryOverride]($common)s, and [[Environment]] settings.\n         */\n        this.onDisplayStyleChanged = new BeEvent();\n        /** Event called on the next frame after this viewport's set of displayed categories changes. */\n        this.onViewedCategoriesChanged = new BeEvent();\n        /** Event called on the next frame after this viewport's set of [[PerModelCategoryVisibility.Overrides]] changes. */\n        this.onViewedCategoriesPerModelChanged = new BeEvent();\n        /** Event called on the next frame after this viewport's set of displayed models changes. */\n        this.onViewedModelsChanged = new BeEvent();\n        /** Event called on the next frame after this viewport's [[FeatureOverrideProvider]] changes,\n         * or the internal state of the provider changes such that the overrides needed to be recomputed.\n         */\n        this.onFeatureOverrideProviderChanged = new BeEvent();\n        /** Event called on the next frame after this viewport's [[FeatureSymbology.Overrides]] change. */\n        this.onFeatureOverridesChanged = new BeEvent();\n        /** Event called on the next frame after any of the viewport's [[ChangeFlags]] changes. */\n        this.onViewportChanged = new BeEvent();\n        /** Event invoked immediately when [[changeView]] is called to replace the current [[ViewState]] with a different one. */\n        this.onChangeView = new BeEvent();\n        /** Event invoked immediately when the viewport is disposed.\n         * @see [[Viewport.dispose]].\n         */\n        this.onDisposed = new BeEvent();\n        /** Event invoked after [[renderFrame]] detects that the dimensions of the viewport's [[ViewRect]] have changed.\n         */\n        this.onResized = new BeEvent();\n        /** Event dispatched immediately after [[flashedId]] changes, supplying the Ids of the previously and/or currently-flashed objects.\n         * @note Attempting to assign to [[flashedId]] from within the event callback will produce an exception.\n         */\n        this.onFlashedIdChanged = new BeEvent();\n        /** Event indicating when a map-layer scale range visibility change for the current viewport scale.\n       * @beta\n       */\n        this.onMapLayerScaleRangeVisibilityChanged = new BeEvent();\n        /** @internal */\n        this._hasMissingTiles = false;\n        /** A function executed by `setView()` when `this._view` changes. */\n        this._detachFromView = [];\n        this._detachFromDisplayStyle = [];\n        this._doContinuousRendering = false;\n        /** @internal */\n        this._inViewChangedEvent = false;\n        /** If false, indicates that [[Decorations]] should be recreated when rendering the next frame.\n         * @note prefer to invoke [[invalidateDecorations]] rather than directly assigning to this property.\n         */\n        this._decorationsValid = false;\n        /** @internal */\n        this._sceneValid = false;\n        /** @internal */\n        this._renderPlanValid = false;\n        /** @internal */\n        this._controllerValid = false;\n        this._redrawPending = false;\n        this._analysisFractionValid = false;\n        this._timePointValid = false;\n        /** @internal */\n        this._changeFlags = new MutableChangeFlags();\n        this._selectionSetDirty = true;\n        /** @internal */\n        this.subcategories = new SubCategoriesCache.Queue();\n        /** Current flash intensity from [0..this.flashSettings.maxIntensity] */\n        this._flashIntensity = 0;\n        this._wantViewAttachments = true;\n        this._wantViewAttachmentBoundaries = false;\n        this._wantViewAttachmentClipShapes = false;\n        this._debugBoundingBoxes = TileBoundingBoxes.None;\n        this._freezeScene = false;\n        this._fadeOutActive = false;\n        this._alwaysDrawnExclusive = false;\n        this._featureOverrideProviders = [];\n        this._tiledGraphicsProviders = new Set();\n        this._hilite = new Hilite.Settings();\n        this._emphasis = new Hilite.Settings(ColorDef.black, 0, 0, Hilite.Silhouette.Thick);\n        this._flash = new FlashSettings();\n        /** @internal */\n        this._viewRange = new ViewRect();\n        /** If this event has one or more listeners, collection of timing statistics related to rendering frames is enabled. Frame statistics will be received by the listeners whenever a frame is finished rendering.\n         * @note The timing data collected using this event only collects the amount of time spent on the CPU. Due to performance considerations, time spent on the GPU is not collected. Therefore, these statistics are not a direct mapping to user experience.\n         * @note In order to avoid interfering with the rendering loop, take care to avoid performing any intensive tasks in your event listeners.\n         * @see [[FrameStats]]\n         * @alpha\n         */\n        this.onFrameStats = new BeEvent();\n        this._frameStatsCollector = new FrameStatsCollector(this.onFrameStats);\n        this._assigningFlashedId = false;\n        /** Called when the visible contents of the viewport are redrawn.\n         * @note Due to the frequency of this event, avoid performing expensive work inside event listeners.\n         */\n        this.onRender = new BeEvent();\n        this._target = target;\n        target.assignFrameStatsCollector(this._frameStatsCollector);\n        this._viewportId = TileUser.generateId();\n        this._perModelCategoryVisibility = PerModelCategoryVisibility.createOverrides(this);\n        IModelApp.tileAdmin.registerUser(this);\n    }\n    dispose() {\n        if (this.isDisposed)\n            return;\n        this._target = dispose(this._target);\n        this.subcategories.dispose();\n        IModelApp.tileAdmin.forgetUser(this);\n        this.onDisposed.raiseEvent(this);\n        this.detachFromView();\n    }\n    setView(view) {\n        if (view === this._view)\n            return;\n        if (this._mapTiledGraphicsProvider)\n            this._mapTiledGraphicsProvider.setView(view);\n        this.detachFromView();\n        this._view = view;\n        this.attachToView();\n    }\n    /** @internal Invoked when the viewport becomes associated with a new ViewState to register event listeners with the view\n     * and allow the ViewState to set up internal state that is only relevant when associated with a Viewport.\n     * Also invoked after changing OffScreenViewport.drawingToSheetTransform.\n     * @internal\n     */\n    attachToView() {\n        this.registerDisplayStyleListeners(this.view.displayStyle);\n        this.registerViewListeners();\n        this.view.attachToViewport(this);\n        this._mapTiledGraphicsProvider = new MapTiledGraphicsProvider(this.viewportId, this.displayStyle);\n    }\n    registerViewListeners() {\n        const view = this.view;\n        const removals = this._detachFromView;\n        // When we detach from the view, also unregister display style listeners.\n        removals.push(() => this.detachFromDisplayStyle());\n        removals.push(view.onModelDisplayTransformProviderChanged.addListener(() => this.invalidateScene()));\n        removals.push(view.details.onClipVectorChanged.addListener(() => this.invalidateRenderPlan()));\n        removals.push(view.onViewedCategoriesChanged.addListener(() => {\n            this._changeFlags.setViewedCategories();\n            this.maybeInvalidateScene();\n        }));\n        removals.push(view.onDisplayStyleChanged.addListener((newStyle) => {\n            this._changeFlags.setDisplayStyle();\n            this.setFeatureOverrideProviderChanged();\n            this.invalidateRenderPlan();\n            this.detachFromDisplayStyle();\n            this._mapTiledGraphicsProvider = new MapTiledGraphicsProvider(this.viewportId, newStyle);\n            this.registerDisplayStyleListeners(newStyle);\n        }));\n        if (view.isSpatialView()) {\n            removals.push(view.onViewedModelsChanged.addListener(() => {\n                this._changeFlags.setViewedModels();\n                this.invalidateScene();\n            }));\n            removals.push(view.details.onModelClipGroupsChanged.addListener(() => {\n                this.invalidateScene();\n            }));\n            // If a map elevation request is required (only in cases where terrain is not geodetic)\n            // then the completion of the request will require synching with the view so that the\n            // frustum depth is recalculated correctly.  Register this for removal when the view is detached.\n            removals.push(this.iModel.onMapElevationLoaded.addListener((_iModel) => {\n                this.synchWithView();\n            }));\n        }\n    }\n    registerDisplayStyleListeners(style) {\n        const settings = style.settings;\n        const removals = this._detachFromDisplayStyle;\n        const displayStyleChanged = () => {\n            this.invalidateRenderPlan();\n            this._changeFlags.setDisplayStyle();\n        };\n        const styleAndOverridesChanged = () => {\n            displayStyleChanged();\n            this.setFeatureOverrideProviderChanged();\n        };\n        removals.push(settings.onSubCategoryOverridesChanged.addListener(styleAndOverridesChanged));\n        removals.push(settings.onModelAppearanceOverrideChanged.addListener(styleAndOverridesChanged));\n        removals.push(settings.onBackgroundColorChanged.addListener(displayStyleChanged));\n        removals.push(settings.onMonochromeColorChanged.addListener(displayStyleChanged));\n        removals.push(settings.onMonochromeModeChanged.addListener(displayStyleChanged));\n        removals.push(settings.onClipStyleChanged.addListener(styleAndOverridesChanged));\n        removals.push(settings.onPlanarClipMaskChanged.addListener(displayStyleChanged));\n        removals.push(settings.onWhiteOnWhiteReversalChanged.addListener(displayStyleChanged));\n        removals.push(settings.contextRealityModels.onPlanarClipMaskChanged.addListener(displayStyleChanged));\n        removals.push(settings.contextRealityModels.onAppearanceOverridesChanged.addListener(displayStyleChanged));\n        removals.push(settings.contextRealityModels.onDisplaySettingsChanged.addListener(displayStyleChanged));\n        removals.push(settings.onRealityModelDisplaySettingsChanged.addListener(displayStyleChanged));\n        removals.push(settings.contextRealityModels.onChanged.addListener(displayStyleChanged));\n        removals.push(style.onOSMBuildingDisplayChanged.addListener(() => {\n            displayStyleChanged();\n            this.synchWithView({ noSaveInUndo: true }); // May change frustum depth.\n        }));\n        const analysisChanged = () => {\n            this._changeFlags.setDisplayStyle();\n            this._analysisFractionValid = false;\n            IModelApp.requestNextAnimation();\n        };\n        const analysisStyleChanged = () => {\n            this.invalidateRenderPlan();\n            analysisChanged();\n        };\n        removals.push(settings.onAnalysisFractionChanged.addListener(analysisChanged));\n        removals.push(settings.onAnalysisStyleChanged.addListener(analysisStyleChanged));\n        const scheduleChanged = () => {\n            this._timePointValid = false;\n            this._changeFlags.setDisplayStyle();\n            this.setFeatureOverrideProviderChanged();\n            IModelApp.requestNextAnimation();\n        };\n        const scriptChanged = () => {\n            scheduleChanged();\n            this.invalidateScene();\n        };\n        removals.push(settings.onTimePointChanged.addListener(scheduleChanged));\n        removals.push(style.onScheduleScriptChanged.addListener(scriptChanged));\n        removals.push(settings.onViewFlagsChanged.addListener((vf) => {\n            if (vf.backgroundMap !== this.viewFlags.backgroundMap)\n                this.invalidateController();\n            else\n                this.invalidateRenderPlan();\n            this._changeFlags.setDisplayStyle();\n        }));\n        // ###TODO detach/attach reality model\n        // ###TODO reality model appearance overrides\n        // ###TODO OSM Building display\n        const mapChanged = () => {\n            this.invalidateController();\n            this._changeFlags.setDisplayStyle();\n        };\n        removals.push(settings.onBackgroundMapChanged.addListener(mapChanged));\n        removals.push(settings.onMapImageryChanged.addListener(mapChanged));\n        removals.push(settings.onExcludedElementsChanged.addListener(() => {\n            this._changeFlags.setDisplayStyle();\n            this.maybeInvalidateScene();\n            this.setFeatureOverrideProviderChanged();\n        }));\n        if (settings.is3d()) {\n            removals.push(settings.onLightsChanged.addListener(displayStyleChanged));\n            removals.push(settings.onSolarShadowsChanged.addListener(displayStyleChanged));\n            removals.push(settings.onThematicChanged.addListener(displayStyleChanged));\n            removals.push(settings.onHiddenLineSettingsChanged.addListener(displayStyleChanged));\n            removals.push(settings.onAmbientOcclusionSettingsChanged.addListener(displayStyleChanged));\n            removals.push(settings.onEnvironmentChanged.addListener(displayStyleChanged));\n            removals.push(settings.onPlanProjectionSettingsChanged.addListener(displayStyleChanged));\n        }\n    }\n    /** @internal Invoked when the viewport becomes associated with a new ViewState to unregister event listeners for\n     * the previous ViewState and allow the previous ViewState to clean up any internal state that is only relevant while\n     * associated with a Viewport.\n     * Also invoked after changing OffScreenViewport.drawingToSheetTransform.\n     * @internal\n     */\n    detachFromView() {\n        this._detachFromView.forEach((f) => f());\n        this._detachFromView.length = 0;\n        if (this._view)\n            this._view.detachFromViewport();\n    }\n    detachFromDisplayStyle() {\n        this._detachFromDisplayStyle.forEach((f) => f());\n        this._detachFromDisplayStyle.length = 0;\n        if (this._mapTiledGraphicsProvider) {\n            this._mapTiledGraphicsProvider.detachFromDisplayStyle();\n            this._mapTiledGraphicsProvider = undefined;\n        }\n    }\n    /** Enables or disables continuous rendering. Ideally, during each render frame a Viewport will do as little work as possible.\n     * To make that possible, the viewport keeps track of what has changed about its internal state from one frame to the next.\n     * For example, if the view frustum has not changed since the previous frame, it is likely that the viewport does not need to be\n     * re-rendered at all.\n     *\n     * In some circumstances, it is desirable to bypass the logic that limits the amount of work performed each frame. A primary example\n     * is a viewport that has some animations applied to it, or when diagnostic information like frames-per-second is being monitored.\n     *\n     * @note An application which enables continuous rendering should disable it as soon as it is no longer needed.\n     */\n    get continuousRendering() { return this._doContinuousRendering; }\n    set continuousRendering(contRend) {\n        if (contRend !== this._doContinuousRendering) {\n            this._doContinuousRendering = contRend;\n            if (contRend)\n                IModelApp.requestNextAnimation();\n        }\n    }\n    /** A unique integer Id assigned to this Viewport upon construction.\n     * It can be useful for comparing and sorting Viewport objects inside of collections like [SortedArray]($core-bentley).\n     */\n    get viewportId() {\n        return this._viewportId;\n    }\n    /** The ViewState for this Viewport */\n    get view() {\n        return this._view;\n    }\n    /** @internal */\n    get pixelsPerInch() {\n        // ###TODO? This is apparently unobtainable information in a browser...\n        return 96;\n    }\n    /** @internal */\n    get backgroundMapGeometry() { return this.view.displayStyle.getBackgroundMapGeometry(); }\n    /** Ids of a set of elements which should not be rendered within this view.\n     * @note Do not modify this set directly - use [[setNeverDrawn]] or [[clearNeverDrawn]] instead.\n     * @note This set takes precedence over the [[alwaysDrawn]] set - if an element is present in both sets, it is never drawn.\n     */\n    get neverDrawn() { return this._neverDrawn; }\n    /** Ids of a set of elements which should always be rendered within this view, regardless of category and subcategory visibility.\n     * If the [[isAlwaysDrawnExclusive]] flag is also set, *only* those elements in this set will be drawn.\n     * @note Do not modify this set directly - use [[setAlwaysDrawn]] or [[clearAlwaysDrawn]] instead.\n     * @note The [[neverDrawn]] set takes precedence - if an element is present in both sets, it is never drawn.\n     */\n    get alwaysDrawn() { return this._alwaysDrawn; }\n    /** Clear the set of always-drawn elements.\n     * @see [[alwaysDrawn]]\n     */\n    clearAlwaysDrawn() {\n        if ((undefined !== this.alwaysDrawn && 0 < this.alwaysDrawn.size) || this._alwaysDrawnExclusive) {\n            if (undefined !== this.alwaysDrawn)\n                this.alwaysDrawn.clear();\n            this._alwaysDrawnExclusive = false;\n            this._changeFlags.setAlwaysDrawn();\n            this.maybeInvalidateScene();\n        }\n    }\n    /** Clear the set of never-drawn elements.\n     * @see [[neverDrawn]]\n     */\n    clearNeverDrawn() {\n        if (undefined !== this.neverDrawn && 0 < this.neverDrawn.size) {\n            this.neverDrawn.clear();\n            this._changeFlags.setNeverDrawn();\n            this.maybeInvalidateScene();\n        }\n    }\n    /** Specify the Ids of a set of elements which should never be rendered within this view.\n     * @see [[neverDrawn]].\n     */\n    setNeverDrawn(ids) {\n        this._neverDrawn = ids;\n        this._changeFlags.setNeverDrawn();\n        this.maybeInvalidateScene();\n    }\n    /** Specify the Ids of a set of elements which should always be rendered within this view, regardless of category and subcategory visibility.\n     * @param ids The Ids of the elements to always draw.\n     * @param exclusive If true, *only* the specified elements will be drawn.\n     * @see [[alwaysDrawn]]\n     * @see [[isAlwaysDrawnExclusive]]\n     */\n    setAlwaysDrawn(ids, exclusive = false) {\n        this._alwaysDrawn = ids;\n        this._alwaysDrawnExclusive = exclusive;\n        this._changeFlags.setAlwaysDrawn();\n        this.maybeInvalidateScene();\n    }\n    /** Returns true if the set of elements in the [[alwaysDrawn]] set are the *only* elements rendered within this view. */\n    get isAlwaysDrawnExclusive() { return this._alwaysDrawnExclusive; }\n    /** Allows visibility of categories within this viewport to be overridden on a per-model basis. */\n    get perModelCategoryVisibility() { return this._perModelCategoryVisibility; }\n    /** Adds visibility overrides for any subcategories whose visibility differs from that defined by the view's\n     * category selector in the context of specific models.\n     * @internal\n     */\n    addModelSubCategoryVisibilityOverrides(fs, ovrs) {\n        this._perModelCategoryVisibility.addOverrides(fs, ovrs);\n    }\n    /** Add a [[FeatureOverrideProvider]] to customize the appearance of [[Feature]]s within the viewport.\n     * The provider will be invoked whenever the overrides are determined to need updating.\n     * The overrides can be explicitly marked as needing a refresh by calling [[Viewport.setFeatureOverrideProviderChanged]]. This is typically called when\n     * the internal state of the provider changes such that the computed overrides must also change.\n     * @note A Viewport can have any number of FeatureOverrideProviders. No attempt is made to resolve conflicts between two different providers overriding the same Feature.\n     * @param provider The provider to register.\n     * @returns true if the provider was registered, or false if the provider was already registered.\n     * @see [[dropFeatureOverrideProvider]] to remove the provider.\n     * @see [[findFeatureOverrideProvider]] to find an existing provider.\n     * @see [[FeatureSymbology.Overrides]].\n     */\n    addFeatureOverrideProvider(provider) {\n        if (this._featureOverrideProviders.includes(provider))\n            return false;\n        this._featureOverrideProviders.push(provider);\n        this.setFeatureOverrideProviderChanged();\n        return true;\n    }\n    /** Removes the specified FeatureOverrideProvider from the viewport.\n     * @param provider The provider to drop.\n     * @returns true if the provider was dropped, or false if it was not registered.\n     * @see [[addFeatureOverrideProvider]].\n     */\n    dropFeatureOverrideProvider(provider) {\n        const index = this._featureOverrideProviders.indexOf(provider);\n        if (-1 === index)\n            return false;\n        this._featureOverrideProviders.splice(index, 1);\n        this.setFeatureOverrideProviderChanged();\n        return true;\n    }\n    /** Locate the first registered FeatureOverrideProvider matching the supplied criterion.\n     * @param predicate A function that will be invoked for each provider currently registered with the viewport, returning true to accept the provider.\n     * @returns The first registered provider that matches the predicate, or undefined if no providers match the predicate.\n     * @see [[findFeatureOverrideProviderOfType]] to locate a provider of a specific class.\n     * @see [[addFeatureOverrideProvider]] to register a provider.\n     */\n    findFeatureOverrideProvider(predicate) {\n        for (const provider of this._featureOverrideProviders)\n            if (predicate(provider))\n                return provider;\n        return undefined;\n    }\n    /** The list of [[FeatureOverrideProvider]]s registered with this viewport.\n     * @see [[addFeatureOverrideProvider]] to register a new provider.\n     * @see [[dropFeatureOverrideProvider]] to unregister a provider.\n     * @see [[findFeatureOverrideProvider]] or [[findFeatureOverrideProviderOfType]] to find a registered provider.\n     */\n    get featureOverrideProviders() {\n        return this._featureOverrideProviders;\n    }\n    /** Locate the first registered FeatureOverrideProvider of the specified class. For example, to locate a registered [[EmphasizeElements]] provider:\n     * ```ts\n     * const provider: EmphasizeElements = viewport.findFeatureOverrideProviderOfType<EmphasizeElements>(EmphasizeElements);\n     * ```\n     * @see [[findFeatureOverrideProvider]] to locate a registered provider matching any arbitrary criterion.\n     */\n    findFeatureOverrideProviderOfType(type) {\n        const provider = this.findFeatureOverrideProvider((x) => isInstanceOf(x, type));\n        return asInstanceOf(provider, type);\n    }\n    /** @internal */\n    addFeatureOverrides(ovrs) {\n        for (const provider of this._featureOverrideProviders)\n            provider.addFeatureOverrides(ovrs, this);\n    }\n    /** Notifies this viewport that the internal state of its [[FeatureOverrideProvider]] has changed such that its\n     * [[FeatureSymbology.Overrides]] should be recomputed.\n     */\n    setFeatureOverrideProviderChanged() {\n        this._changeFlags.setFeatureOverrideProvider();\n        this.maybeInvalidateScene();\n    }\n    /** Notifies this viewport that a change in application state requires its [[FeatureSymbology.Overrides]] to be recomputed.\n     * @note The viewport monitors various events to automatically detect when the overrides should be recomputed. This method\n     * is only needed for changes that are not observable by the viewport itself.\n     */\n    invalidateSymbologyOverrides() {\n        this.setFeatureOverrideProviderChanged();\n    }\n    /** The [[TiledGraphicsProvider]]s currently registered with this viewport.\n     * @see [[addTiledGraphicsProvider]].\n     */\n    get tiledGraphicsProviders() {\n        return this._tiledGraphicsProviders;\n    }\n    /** @internal */\n    forEachTiledGraphicsProvider(func) {\n        for (const provider of this._tiledGraphicsProviders)\n            func(provider);\n    }\n    /** @internal */\n    forEachTiledGraphicsProviderTree(func) {\n        for (const provider of this._tiledGraphicsProviders)\n            provider.forEachTileTreeRef(this, (ref) => func(ref));\n    }\n    /** Apply a function to every tile tree reference associated with the map layers displayed by this viewport. */\n    forEachMapTreeRef(func) {\n        if (this._mapTiledGraphicsProvider)\n            this._mapTiledGraphicsProvider.forEachTileTreeRef(this, (ref) => func(ref));\n    }\n    /** Apply a function to every [[TileTreeReference]] displayed by this viewport. */\n    forEachTileTreeRef(func) {\n        this.view.forEachTileTreeRef(func);\n        this.forEachTiledGraphicsProviderTree(func);\n        this.forEachMapTreeRef(func);\n    }\n    /**\n     * Returns true if all [[TileTree]]s required by this viewport have been loaded.\n     */\n    get areAllTileTreesLoaded() {\n        if (!this.view.areAllTileTreesLoaded)\n            return false;\n        if (this._mapTiledGraphicsProvider && !TiledGraphicsProvider.isLoadingComplete(this._mapTiledGraphicsProvider, this))\n            return false;\n        for (const provider of this._tiledGraphicsProviders)\n            if (!TiledGraphicsProvider.isLoadingComplete(provider, this))\n                return false;\n        return true;\n    }\n    /** Disclose *all* TileTrees currently in use by this Viewport. This set may include trees not reported by [[forEachTileTreeRef]] - e.g., those used by view attachments, map-draped terrain, etc.\n     * @internal\n     */\n    discloseTileTrees(trees) {\n        this.forEachTiledGraphicsProviderTree((ref) => trees.disclose(ref));\n        this.forEachMapTreeRef((ref) => trees.disclose(ref));\n        trees.disclose(this.view);\n    }\n    /** Register a provider of tile graphics to be drawn in this viewport.\n     * @see [[dropTiledGraphicsProvider]]\n     */\n    addTiledGraphicsProvider(provider) {\n        this._tiledGraphicsProviders.add(provider);\n        this.invalidateScene();\n    }\n    /** Remove a previously-registered provider of tile graphics.\n     * @see [[addTiledGraphicsProvider]]\n     */\n    dropTiledGraphicsProvider(provider) {\n        this._tiledGraphicsProviders.delete(provider);\n        this.invalidateScene();\n    }\n    /** Returns true if the specified provider has been registered with this viewport via [[addTiledGraphicsProvider]]. */\n    hasTiledGraphicsProvider(provider) {\n        return this._tiledGraphicsProviders.has(provider);\n    }\n    /** @internal */\n    mapLayerFromHit(hit) {\n        return undefined === hit.modelId ? [] : this.mapLayerFromIds(hit.modelId, hit.sourceId);\n    }\n    /** @internal */\n    mapLayerFromIds(mapTreeId, layerTreeId) {\n        return this._mapTiledGraphicsProvider === undefined ? [] : this._mapTiledGraphicsProvider.mapLayerFromIds(mapTreeId, layerTreeId);\n    }\n    /** @internal */\n    getTerrainHeightRange() {\n        const heightRange = Range1d.createNull();\n        this.forEachTileTreeRef((ref) => ref.getTerrainHeight(heightRange));\n        return heightRange;\n    }\n    /** @internal */\n    setViewedCategoriesPerModelChanged() {\n        this._changeFlags.setViewedCategoriesPerModel();\n    }\n    /** @internal */\n    markSelectionSetDirty() { this._selectionSetDirty = true; }\n    /** True if this is a 3d view with the camera turned on. */\n    get isCameraOn() {\n        return this.view.is3d() && this.view.isCameraOn;\n    }\n    /** @internal */\n    changeDynamics(dynamics) {\n        this.target.changeDynamics(dynamics);\n        this.invalidateDecorations();\n    }\n    /** The Id of the currently-flashed object.\n     * The \"flashed\" visual effect is typically applied to the object in the viewport currently under the mouse cursor, to indicate\n     * it is ready to be interacted with by a tool. [[ToolAdmin]] is responsible for updating it when the mouse cursor moves.\n     * The object is usually an [Element]($backend) but could also be a [Model]($backend) or pickable decoration produced by a [[Decorator]].\n     * The setter ignores any string that is not a well-formed [Id64String]($core-bentley). Passing [Id64.invalid]($core-bentley) to the\n     * setter is equivalent to passing `undefined` - both mean \"nothing is flashed\".\n     * @throws Error if an attempt is made to change this property from within an [[onFlashedIdChanged]] event callback.\n     * @see [[onFlashedIdChanged]] to be notified when the flashed object changes.\n     * @see [[flashSettings]] to customize the visual effect.\n     */\n    get flashedId() {\n        return this._flashedElem;\n    }\n    set flashedId(id) {\n        if (this._assigningFlashedId)\n            throw new Error(\"Cannot assign to Viewport.flashedId from within an onFlashedIdChanged event callback.\");\n        if (id === Id64.invalid)\n            id = undefined;\n        const previous = this._flashedElem;\n        if (id === previous || (undefined !== id && !Id64.isId64(id)))\n            return;\n        this._lastFlashedElem = this._flashedElem;\n        this._flashedElem = id;\n        this._assigningFlashedId = true;\n        try {\n            // The comparison `id !== previous` above ensures the following assertion, but the compiler doesn't recognize it.\n            assert(undefined !== id || undefined !== previous);\n            this.onFlashedIdChanged.raiseEvent(this, { current: id, previous });\n        }\n        finally {\n            this._assigningFlashedId = false;\n        }\n    }\n    get auxCoordSystem() { return this.view.auxiliaryCoordinateSystem; }\n    getAuxCoordRotation(result) { return this.auxCoordSystem.getRotation(result); }\n    getAuxCoordOrigin(result) { return this.auxCoordSystem.getOrigin(result); }\n    /** The number of outstanding requests for tiles to be displayed in this viewport.\n     * @see Viewport.numSelectedTiles\n     */\n    get numRequestedTiles() { return IModelApp.tileAdmin.getNumRequestsForUser(this); }\n    /** The number of tiles selected for display in the view as of the most recently-drawn frame.\n     * The tiles selected may not meet the desired level-of-detail for the view, instead being temporarily drawn while\n     * tiles of more appropriate level-of-detail are loaded asynchronously.\n     * @see Viewport.numRequestedTiles\n     * @see Viewport.numReadyTiles\n     */\n    get numSelectedTiles() {\n        const tiles = IModelApp.tileAdmin.getTilesForUser(this);\n        return undefined !== tiles ? tiles.selected.size + tiles.external.selected : 0;\n    }\n    /** The number of tiles which were ready and met the desired level-of-detail for display in the view as of the most recently-drawn frame.\n     * These tiles may *not* have been selected because some other (probably sibling) tiles were *not* ready for display.\n     * This is a useful metric for determining how \"complete\" the view is - e.g., one indicator of progress toward view completion can be expressed as:\n     * `  (numReadyTiles) / (numReadyTiles + numRequestedTiles)`\n     * @see Viewport.numSelectedTiles\n     * @see Viewport.numRequestedTiles\n     */\n    get numReadyTiles() {\n        const tiles = IModelApp.tileAdmin.getTilesForUser(this);\n        return undefined !== tiles ? tiles.ready.size + tiles.external.ready : 0;\n    }\n    /** @internal */\n    toViewOrientation(from, to) { this._viewingSpace.toViewOrientation(from, to); }\n    /** @internal */\n    fromViewOrientation(from, to) { this._viewingSpace.fromViewOrientation(from, to); }\n    /** Change the ViewState of this Viewport\n     * @param view a fully loaded (see discussion at [[ViewState.load]] ) ViewState\n     * @param _opts options for how the view change operation should work\n     */\n    changeView(view, _opts) {\n        const prevView = this.view;\n        this.updateChangeFlags(view);\n        this.doSetupFromView(view);\n        this.invalidateController();\n        this.target.reset();\n        if (undefined !== prevView && prevView !== view) {\n            this.onChangeView.raiseEvent(this, prevView);\n            this._changeFlags.setViewState();\n        }\n    }\n    /** Determine whether the supplied point is visible in the viewport rectangle.\n     * @param point the point to test\n     * @param coordSys the coordinate system of the specified point\n     * @param borderPaddingFactor optional border for testing with inset view rectangle.\n     */\n    isPointVisibleXY(point, coordSys = CoordSystem.World, borderPaddingFactor = 0.0) {\n        let testPtView = point;\n        switch (coordSys) {\n            case CoordSystem.Npc:\n                testPtView = this.npcToView(point);\n                break;\n            case CoordSystem.World:\n                testPtView = this.worldToView(point);\n                break;\n        }\n        const frustum = this.getFrustum(CoordSystem.View);\n        const screenRangeX = frustum.points[Npc._000].distance(frustum.points[Npc._100]);\n        const screenRangeY = frustum.points[Npc._000].distance(frustum.points[Npc._010]);\n        const xBorder = screenRangeX * borderPaddingFactor;\n        const yBorder = screenRangeY * borderPaddingFactor;\n        return (!(testPtView.x < xBorder || testPtView.x > (screenRangeX - xBorder) || testPtView.y < yBorder || testPtView.y > (screenRangeY - yBorder)));\n    }\n    /** Computes the range of npc depth values for a region of the screen\n     * @param rect the rectangle to test. If undefined, test entire view\n     * @param result optional DepthRangeNpc to store the result\n     * @returns the minimum and maximum depth values within the region, or undefined.\n     */\n    determineVisibleDepthRange(rect, result) {\n        if (result) { // Null result if given\n            result.minimum = 1;\n            result.maximum = 0;\n        }\n        // Default to a (0, 0, 0) to (1, 1, 1) range if no range was provided\n        rect = (rect && rect.isValid) ? rect : this.viewRect;\n        // Determine the screen rectangle in which to query visible depth min + max\n        const readRect = rect.computeOverlap(this.viewRect);\n        if (undefined === readRect)\n            return undefined;\n        let retVal;\n        this.readPixels(readRect, Pixel.Selector.GeometryAndDistance, (pixels) => {\n            if (!pixels)\n                return;\n            readRect.left = this.cssPixelsToDevicePixels(readRect.left);\n            readRect.right = this.cssPixelsToDevicePixels(readRect.right);\n            readRect.bottom = this.cssPixelsToDevicePixels(readRect.bottom);\n            readRect.top = this.cssPixelsToDevicePixels(readRect.top);\n            let maximum = 0;\n            let minimum = 1;\n            const frac = this._viewingSpace.frustFraction;\n            for (let x = readRect.left; x < readRect.right; ++x) {\n                for (let y = readRect.top; y < readRect.bottom; ++y) {\n                    let npcZ = pixels.getPixel(x, y).distanceFraction;\n                    if (npcZ <= 0.0)\n                        continue;\n                    if (frac < 1.0)\n                        npcZ *= frac / (1.0 + npcZ * (frac - 1.0));\n                    minimum = Math.min(minimum, npcZ);\n                    maximum = Math.max(maximum, npcZ);\n                }\n            }\n            if (maximum <= 0)\n                return;\n            if (undefined === result) {\n                result = { minimum, maximum };\n            }\n            else {\n                result.minimum = minimum;\n                result.maximum = maximum;\n            }\n            retVal = result;\n        });\n        return retVal;\n    }\n    /** Turn the camera off it is currently on.\n     * @see [[turnCameraOn]] to turn the camera on.\n     */\n    turnCameraOff() {\n        if (this.view.is3d() && this.view.isCameraOn) {\n            this.view.turnCameraOff();\n            this.setupFromView();\n        }\n    }\n    /** Turn the camera on if it is currently off. If the camera is already on, adjust it to use the supplied lens angle.\n     * @param lensAngle The lens angle for the camera. If undefined, use view.camera.lens.\n     * @note This method will fail if the ViewState is not 3d.\n     * @see [[turnCameraOff]] to turn the camera off.\n     */\n    turnCameraOn(lensAngle) {\n        const view = this.view;\n        if (!view.is3d() || !view.supportsCamera())\n            return ViewStatus.InvalidViewport;\n        if (!lensAngle)\n            lensAngle = view.camera.lens;\n        Camera.validateLensAngle(lensAngle);\n        let status;\n        if (view.isCameraOn) {\n            status = view.lookAt({ eyePoint: view.getEyePoint(), targetPoint: view.getTargetPoint(), upVector: view.getYVector(), lensAngle });\n        }\n        else {\n            // We need to figure out a new camera target. To do that, we need to know where the geometry is in the view.\n            // We use the depth of the center of the view for that.\n            let depthRange = this.determineVisibleDepthRange();\n            if (undefined === depthRange || Geometry.isAlmostEqualNumber(depthRange.minimum, depthRange.maximum))\n                depthRange = { minimum: 0, maximum: 1 };\n            const middle = depthRange.minimum + ((depthRange.maximum - depthRange.minimum) / 2.0);\n            const corners = [\n                new Point3d(0.0, 0.0, middle),\n                new Point3d(1.0, 1.0, middle),\n                new Point3d(0.0, 0.0, depthRange.maximum),\n                new Point3d(1.0, 1.0, depthRange.maximum), // upper right at closest\n            ];\n            this.npcToWorldArray(corners);\n            const eyePoint = corners[2].interpolate(0.5, corners[3]); // middle of closest plane\n            const targetPoint = corners[0].interpolate(0.5, corners[1]); // middle of halfway plane\n            const backDistance = eyePoint.distance(targetPoint) * 2.0;\n            const frontDistance = view.minimumFrontDistance();\n            status = view.lookAt({ eyePoint, targetPoint, upVector: view.getYVector(), lensAngle, frontDistance, backDistance });\n        }\n        if (ViewStatus.Success === status)\n            this.setupFromView();\n        return status;\n    }\n    /** Orient this viewport to one of the [[StandardView]] rotations. */\n    setStandardRotation(id) {\n        this.view.setStandardRotation(id);\n        this.setupFromView();\n    }\n    doSetupFromView(view) {\n        if (this._inViewChangedEvent)\n            return ViewStatus.Success; // ignore echos\n        if (!this.isAspectRatioLocked)\n            view.fixAspectRatio(this.viewRect.aspect);\n        this.setView(view);\n        const viewSpace = ViewingSpace.createFromViewport(this);\n        if (undefined === viewSpace)\n            return ViewStatus.InvalidViewport;\n        this._viewingSpace = viewSpace;\n        this.invalidateRenderPlan();\n        this._controllerValid = true;\n        this._inViewChangedEvent = true;\n        this.onViewChanged.raiseEvent(this);\n        this._inViewChangedEvent = false;\n        return ViewStatus.Success;\n    }\n    /** Establish the parameters of this Viewport from the current information in its ViewState */\n    setupFromView(pose) {\n        if (undefined !== pose)\n            this.view.applyPose(pose);\n        return this.doSetupFromView(this.view);\n    }\n    /** Call [[setupFromView]] on this Viewport and then apply optional behavior.\n     * @param options _options for behavior of view change. If undefined, all options have their default values (see [[ViewChangeOptions]] for details.)\n     */\n    synchWithView(_options) { this.setupFromView(); }\n    /** Convert an array of points from CoordSystem.View to CoordSystem.Npc */\n    viewToNpcArray(pts) { this._viewingSpace.viewToNpcArray(pts); }\n    /** Convert an array of points from CoordSystem.Npc to CoordSystem.View */\n    npcToViewArray(pts) { this._viewingSpace.npcToViewArray(pts); }\n    /** Convert a point from CoordSystem.View to CoordSystem.Npc\n     * @param pt the point to convert\n     * @param out optional location for result. If undefined, a new Point3d is created.\n     */\n    viewToNpc(pt, out) { return this._viewingSpace.viewToNpc(pt, out); }\n    /** Convert a point from CoordSystem.Npc to CoordSystem.View\n     * @param pt the point to convert\n     * @param out optional location for result. If undefined, a new Point3d is created.\n     */\n    npcToView(pt, out) { return this._viewingSpace.npcToView(pt, out); }\n    /** Convert an array of points from CoordSystem.World to CoordSystem.Npc */\n    worldToNpcArray(pts) { this._viewingSpace.worldToNpcArray(pts); }\n    /** Convert an array of points from CoordSystem.Npc to CoordSystem.World */\n    npcToWorldArray(pts) { this._viewingSpace.npcToWorldArray(pts); }\n    /** Convert an array of points from CoordSystem.World to CoordSystem.View */\n    worldToViewArray(pts) { this._viewingSpace.worldToViewArray(pts); }\n    /** Convert an array of points from CoordSystem.World to CoordSystem.View, as Point4ds */\n    worldToView4dArray(worldPts, viewPts) { this._viewingSpace.worldToView4dArray(worldPts, viewPts); }\n    /** Convert an array of points from CoordSystem.View to CoordSystem.World */\n    viewToWorldArray(pts) { this._viewingSpace.viewToWorldArray(pts); }\n    /** Convert an array of points from CoordSystem.View as Point4ds to CoordSystem.World */\n    view4dToWorldArray(viewPts, worldPts) { this._viewingSpace.view4dToWorldArray(viewPts, worldPts); }\n    /** Convert a point from CoordSystem.World to CoordSystem.Npc\n     * @param pt the point to convert\n     * @param out optional location for result. If undefined, a new Point3d is created.\n     */\n    worldToNpc(pt, out) { return this._viewingSpace.worldToNpc(pt, out); }\n    /** Convert a point from CoordSystem.Npc to CoordSystem.World\n     * @param pt the point to convert\n     * @param out optional location for result. If undefined, a new Point3d is created.\n     */\n    npcToWorld(pt, out) { return this._viewingSpace.npcToWorld(pt, out); }\n    /** Convert a point from CoordSystem.World to CoordSystem.View\n     * @param pt the point to convert\n     * @param out optional location for result. If undefined, a new Point3d is created.\n     */\n    worldToView(input, out) { return this._viewingSpace.worldToView(input, out); }\n    /** Convert a point from CoordSystem.World to CoordSystem.View as Point4d\n     * @param input the point to convert\n     * @param out optional location for result. If undefined, a new Point4d is created.\n     */\n    worldToView4d(input, out) { return this._viewingSpace.worldToView4d(input, out); }\n    /** Convert a point from CoordSystem.View to CoordSystem.World\n     * @param pt the point to convert\n     * @param out optional location for result. If undefined, a new Point3d is created.\n     */\n    viewToWorld(input, out) { return this._viewingSpace.viewToWorld(input, out); }\n    /** Convert a point from CoordSystem.View as a Point4d to CoordSystem.View\n     * @param input the point to convert\n     * @param out optional location for result. If undefined, a new Point3d is created.\n     */\n    view4dToWorld(input, out) { return this._viewingSpace.view4dToWorld(input, out); }\n    /** Converts inches to pixels based on screen DPI.\n     * @Note this information may not be accurate in some browsers.\n     * @param inches the number of inches to convert\n     * @returns the corresponding number of pixels\n     */\n    pixelsFromInches(inches) { return inches * this.pixelsPerInch; }\n    /** Get an 8-point Frustum corresponding to the 8 corners of the Viewport in the specified coordinate system.\n     *\n     * There are two sets of corners that may be of interest.\n     * The \"adjusted\" box is the one that is computed by examining the \"viewed extents\" and moving\n     * the front and back planes to enclose everything in the view.\n     * The \"unadjusted\" box is the one that is stored in the ViewState.\n     * @param sys Coordinate system for points\n     * @param adjustedBox If true, retrieve the adjusted box. Otherwise retrieve the box that came from the view definition.\n     * @param box optional Frustum for return value\n     * @return the view frustum\n     * @note The \"adjusted\" box may be either larger or smaller than the \"unadjusted\" box.\n     */\n    getFrustum(sys = CoordSystem.World, adjustedBox = true, box) { return this._viewingSpace.getFrustum(sys, adjustedBox, box); }\n    /** Get a copy of the current (unadjusted) frustum of this viewport, in world coordinates. */\n    getWorldFrustum(box) { return this.getFrustum(CoordSystem.World, false, box); }\n    /** Scroll the view by a given number of pixels.\n     * @param screenDist distance to scroll, in pixels\n     */\n    scroll(screenDist, options) {\n        const view = this.view;\n        if (!view)\n            return;\n        const distXYZ = new Point3d(screenDist.x, screenDist.y, 0);\n        if (view.is3d() && view.isCameraOn) {\n            const frust = this.getFrustum(CoordSystem.View, false);\n            frust.translate(distXYZ);\n            this.viewToWorldArray(frust.points);\n            view.setupFromFrustum(frust);\n            view.centerEyePoint();\n        }\n        else {\n            const pts = [new Point3d(), distXYZ];\n            this.viewToWorldArray(pts);\n            const dist = pts[1].minus(pts[0]);\n            view.setOrigin(view.getOrigin().plus(dist));\n        }\n        this.synchWithView(options);\n    }\n    /** Zoom the view by a scale factor, placing the new center at the given point (world coordinates).\n     * @param newCenter The new center point of the view, in world coordinates. If undefined, use current center.\n     * @param factor the zoom factor.\n     * @param options options for behavior of view change\n     */\n    zoom(newCenter, factor, options) {\n        const view = this.view;\n        if (undefined === view)\n            return ViewStatus.InvalidViewport;\n        if (view.is3d() && view.isCameraOn) {\n            const eyePoint = view.getEyePoint().clone();\n            const targetPoint = view.getTargetPoint();\n            if (newCenter) {\n                const dir = eyePoint.vectorTo(targetPoint);\n                newCenter.plusScaled(dir, -0.5, eyePoint);\n                newCenter.plusScaled(dir, 0.5, targetPoint);\n            }\n            const transform = Transform.createFixedPointAndMatrix(targetPoint, Matrix3d.createScale(factor, factor, factor));\n            const zDir = view.getZVector();\n            transform.multiplyPoint3d(eyePoint, eyePoint);\n            targetPoint.setFrom(eyePoint.plusScaled(zDir, zDir.dotProduct(eyePoint.vectorTo(targetPoint))));\n            const status = view.lookAt({ eyePoint, targetPoint, upVector: view.getYVector(), lensAngle: view.camera.lens });\n            if (ViewStatus.Success !== status)\n                return status;\n        }\n        else {\n            // for non-camera views, do the zooming by adjusting the origin and delta directly so there can be no\n            // chance of the rotation changing due to numerical precision errors calculating it from the frustum corners.\n            const delta = view.getExtents().scale(factor);\n            const rot = view.getRotation();\n            const center = rot.multiplyVector(newCenter ? newCenter : view.getCenter());\n            // fix for min/max delta\n            const stat = view.adjustViewDelta(delta, center, rot, this.viewRect.aspect, options);\n            if (ViewStatus.Success !== stat)\n                return stat;\n            if (!view.allow3dManipulations())\n                center.z = 0.0;\n            view.setOrigin(rot.multiplyTransposeVector(delta.scale(.5).vectorTo(center)));\n            view.setExtents(delta);\n        }\n        this.synchWithView(options);\n        return ViewStatus.Success;\n    }\n    /** See [[zoomToPlacements]]. */\n    zoomToPlacementProps(placementProps, options) {\n        const placements = placementProps.map((props) => isPlacement2dProps(props) ? Placement2d.fromJSON(props) : Placement3d.fromJSON(props));\n        this.zoomToPlacements(placements, options);\n    }\n    /** Zoom the view in or out to a fit to the tightest volume enclosing a given set of placements, optionally also changing the view rotation.\n     * @param placements The array of placements. The view will zoom to fit the union of the placements.\n     * @param options Options controlling how the view change works and whether to change view rotation.\n     * @note any invalid placements are ignored. If no valid placements are supplied, this function does nothing.\n     * @see [[zoomToElements]] to zoom to a set of elements.\n     * @see [[IModelConnection.Elements.getPlacements]] to obtain the placements for a set of elements.\n     */\n    zoomToPlacements(placements, options) {\n        placements = placements.filter((x) => x.isValid);\n        if (placements.length === 0)\n            return;\n        const view = this.view;\n        if (undefined !== options) {\n            if (undefined !== options.standardViewId) {\n                view.setStandardRotation(options.standardViewId);\n            }\n            else if (undefined !== options.placementRelativeId) {\n                const viewRotation = StandardView.getStandardRotation(options.placementRelativeId).clone();\n                viewRotation.multiplyMatrixMatrixTranspose(placements[0].transform.matrix, viewRotation);\n                view.setRotation(viewRotation);\n            }\n            else if (undefined !== options.viewRotation) {\n                view.setRotation(options.viewRotation);\n            }\n        }\n        const viewTransform = Transform.createOriginAndMatrix(undefined, view.getRotation());\n        const frust = new Frustum();\n        const viewRange = new Range3d();\n        for (const placement of placements)\n            viewRange.extendArray(placement.getWorldCorners(frust).points, viewTransform);\n        const ignoreError = {\n            ...options,\n            onExtentsError: () => ViewStatus.Success,\n        };\n        view.lookAtViewAlignedVolume(viewRange, this.viewRect.aspect, ignoreError);\n        this.synchWithView(options);\n    }\n    /** Zoom the view to a show the tightest box around a given set of ElementProps. Optionally, change view rotation.\n     * @param props element props. Will zoom to the union of the placements.\n     * @param options options that control how the view change works and whether to change view rotation.\n     * @note Do not query for ElementProps just to zoom to their placements - [[zoomToElements]] is much more efficient because it queries only for the placement properties.\n     */\n    zoomToElementProps(elementProps, options) {\n        if (elementProps.length === 0)\n            return;\n        const placementProps = [];\n        for (const props of elementProps) {\n            const placement = props.placement;\n            if (placement !== undefined && this.view.viewsModel(props.model))\n                placementProps.push(placement);\n        }\n        this.zoomToPlacementProps(placementProps, options);\n    }\n    /** Zoom the view to a show the tightest box around a given set of elements. Optionally, change view rotation.\n     * @param ids the element id(s) to include. Will zoom to the union of the placements.\n     * @param options options that control how the view change works and whether to change view rotation.\n     */\n    async zoomToElements(ids, options) {\n        const placements = await this.iModel.elements.getPlacements(ids, { type: this.view.is3d() ? \"3d\" : \"2d\" });\n        this.zoomToPlacements(placements, options);\n    }\n    /** Zoom the view to a volume of space in world coordinates.\n     * @param volume The low and high corners, in world coordinates.\n     * @param options options that control how the view change works\n     */\n    zoomToVolume(volume, options) {\n        this.view.lookAtVolume(volume, this.viewRect.aspect, options);\n        this.synchWithView(options);\n    }\n    /** Shortcut to call view.setupFromFrustum and then [[setupFromView]]\n     * @param inFrustum the new viewing frustum\n     * @returns true if both steps were successful\n     */\n    setupViewFromFrustum(inFrustum) {\n        const validSize = this.view.setupFromFrustum(inFrustum);\n        // note: always call setupFromView, even if setupFromFrustum failed\n        return (ViewStatus.Success === this.setupFromView() && ViewStatus.Success === validSize);\n    }\n    /** Compute the range of all geometry to be displayed in this viewport. */\n    computeViewRange() {\n        const fitRange = this.view.computeFitRange();\n        this.forEachTiledGraphicsProviderTree((ref) => {\n            ref.unionFitRange(fitRange);\n        });\n        return fitRange;\n    }\n    /** Set or clear the animator for this Viewport.\n     * @param animator The new animator for this Viewport, or undefined to remove current animator.\n     * @note current animator's `interrupt` method will be called (if it has not completed yet)\n     * @public\n     */\n    setAnimator(animator) {\n        this._animator?.interrupt();\n        this._animator = animator;\n        // Immediately invoke the animator to set up the initial frustum.\n        // This is important for TwoWayViewportSync; otherwise, the synced viewport will have its frustum set to the final frustum,\n        // producing a flicker to that frustum during the first frame of animation.\n        this.animate();\n    }\n    /** Replace this viewport's [[ViewState]] **without** triggering events like [[onChangeView]].\n     * This is chiefly useful when you are synchronizing the states of two or more viewports, as in [[TwoWayViewportSync]], to avoid triggering unwanted \"echo\"\n     * events during synchronization.\n     * In all other scenarios, [[changeView]] is the correct method to use.\n     */\n    applyViewState(val) {\n        this.updateChangeFlags(val);\n        this.setView(val);\n        this._viewingSpace.view = val;\n        this.synchWithView({ noSaveInUndo: true });\n    }\n    /** Invoked from finishUndoRedo, applyViewState, and changeView to potentially recompute change flags based on differences between current and new ViewState. */\n    updateChangeFlags(newView) {\n        // Before the first call to changeView, this.view is undefined because we have no frustum. Our API pretends it is never undefined.\n        const oldView = undefined !== this.viewingSpace ? this.view : undefined;\n        if (undefined === oldView || oldView === newView)\n            return;\n        const flags = this._changeFlags;\n        if (!flags.displayStyle && !oldView.displayStyle.equalState(newView.displayStyle))\n            flags.setDisplayStyle();\n        if (!flags.viewedCategories && !oldView.categorySelector.equalState(newView.categorySelector))\n            flags.setViewedCategories();\n        if (!flags.neverDrawn) {\n            if (oldView.displayStyle.settings.compressedExcludedElementIds !== newView.displayStyle.settings.compressedExcludedElementIds)\n                flags.setNeverDrawn();\n        }\n        if (flags.viewedModels)\n            return;\n        if (oldView.is2d() && newView.is2d()) {\n            if (oldView.baseModelId !== newView.baseModelId)\n                flags.setViewedModels();\n        }\n        else if (oldView.isSpatialView() && newView.isSpatialView()) {\n            if (!oldView.modelSelector.equalState(newView.modelSelector))\n                flags.setViewedModels();\n        }\n        else {\n            // switched between 2d and 3d view.\n            flags.setViewedModels();\n        }\n    }\n    static roundGrid(num, units) {\n        const sign = ((num * units) < 0.0) ? -1.0 : 1.0;\n        num = (num * sign) / units + 0.5;\n        return units * sign * Math.floor(num);\n    }\n    getGridOrientation(origin, rMatrix) {\n        if (this.view.isSpatialView())\n            origin.setFrom(this.iModel.globalOrigin);\n        switch (this.view.getGridOrientation()) {\n            case GridOrientationType.View: {\n                const center = this.view.getCenter();\n                this.toViewOrientation(center);\n                this.toViewOrientation(origin);\n                origin.z = center.z;\n                this.fromViewOrientation(origin);\n                break;\n            }\n            case GridOrientationType.WorldXY:\n                break;\n            case GridOrientationType.WorldYZ: {\n                Matrix3d.createRows(rMatrix.getRow(1), rMatrix.getRow(2), rMatrix.getRow(0), rMatrix);\n                break;\n            }\n            case GridOrientationType.WorldXZ: {\n                Matrix3d.createRows(rMatrix.getRow(0), rMatrix.getRow(2), rMatrix.getRow(1), rMatrix);\n                break;\n            }\n        }\n    }\n    pointToStandardGrid(point, rMatrix, origin) {\n        const planeNormal = rMatrix.getRow(2);\n        let eyeVec;\n        if (this.view.is3d() && this.view.isCameraOn)\n            eyeVec = this.view.camera.eye.vectorTo(point);\n        else\n            eyeVec = this._viewingSpace.rotation.getRow(2);\n        eyeVec.normalizeInPlace();\n        linePlaneIntersect(point, point, eyeVec, origin, planeNormal, false);\n        // // get origin and point in view coordinate system\n        const pointView = point.clone();\n        const originView = origin.clone();\n        this.toViewOrientation(pointView);\n        this.toViewOrientation(originView);\n        // subtract off the origin\n        pointView.y -= originView.y;\n        pointView.x -= originView.x;\n        // round off the remainder to the grid distances\n        const gridSpacing = this.view.getGridSpacing();\n        pointView.x = Viewport.roundGrid(pointView.x, gridSpacing.x);\n        pointView.y = Viewport.roundGrid(pointView.y, gridSpacing.y);\n        // add the origin back in\n        pointView.x += originView.x;\n        pointView.y += originView.y;\n        // go back to root coordinate system\n        this.fromViewOrientation(pointView);\n        point.setFrom(pointView);\n    }\n    /** @internal */\n    pointToGrid(point) {\n        if (GridOrientationType.AuxCoord === this.view.getGridOrientation()) {\n            this.pointToStandardGrid(point, this.getAuxCoordRotation(), this.getAuxCoordOrigin());\n            return;\n        }\n        const origin = new Point3d();\n        const rMatrix = Matrix3d.createIdentity();\n        this.getGridOrientation(origin, rMatrix);\n        this.pointToStandardGrid(point, rMatrix, origin);\n    }\n    /** Get the width of a pixel (a unit vector in the x direction in view coordinates) at a given point in world coordinates, returning the result in meters (world units).\n     *\n     * This is most useful to determine how large something is in a view. In particular, in a perspective view\n     * the result of this method will be a larger number for points closer to the back of the view Frustum (that is,\n     * one pixel of the view represents more spatial area at the back of the Frustum than the front.)\n     * @param point The point to test, in World coordinates. If undefined, the center of the view in NPC space is used.\n     * @returns The width of a view pixel at the supplied world point, in meters.\n     * @note A \"pixel\" refers to a logical (CSS) pixel, not a device pixel.\n     */\n    getPixelSizeAtPoint(point) {\n        if (point === undefined)\n            point = this.npcToWorld(NpcCenter); // if undefined, use center of view\n        const worldPts = [];\n        const viewPts = [];\n        viewPts[0] = this.worldToView4d(point);\n        viewPts[1] = viewPts[0].clone();\n        viewPts[1].x += viewPts[1].w; // form a vector one pixel wide in x direction.\n        this.view4dToWorldArray(viewPts, worldPts);\n        return worldPts[0].distance(worldPts[1]);\n    }\n    get _wantInvertBlackAndWhite() {\n        const bgColor = this.view.backgroundColor.colors;\n        return ((bgColor.r + bgColor.g + bgColor.b) > (255 * 3) / 2);\n    }\n    /** Get a color that will contrast to the current background color of this Viewport. Either Black or White depending on which will have the most contrast. */\n    getContrastToBackgroundColor() {\n        return this._wantInvertBlackAndWhite ? ColorDef.black : ColorDef.white; // should we use black or white?\n    }\n    processFlash() {\n        let needsFlashUpdate = false;\n        if (this.flashedId !== this._lastFlashedElem) {\n            this._flashIntensity = 0.0;\n            this._flashUpdateTime = BeTimePoint.now();\n            this._lastFlashedElem = this.flashedId; // flashing has begun; this is now the previous flash\n            needsFlashUpdate = this.flashedId === undefined; // notify render thread that flash has been turned off (signified by undefined elem)\n        }\n        if (this.flashedId !== undefined && this._flashIntensity < this.flashSettings.maxIntensity) {\n            assert(undefined !== this._flashUpdateTime);\n            const flashDuration = this.flashSettings.duration;\n            const flashElapsed = BeTimePoint.now().milliseconds - this._flashUpdateTime.milliseconds;\n            this._flashIntensity = Math.min(flashElapsed, flashDuration.milliseconds) / flashDuration.milliseconds;\n            this._flashIntensity = Math.min(this._flashIntensity, this.flashSettings.maxIntensity);\n            needsFlashUpdate = true;\n        }\n        return needsFlashUpdate;\n    }\n    /** Create a context appropriate for producing the scene to be rendered by this viewport, e.g., by [[createScene]]. */\n    createSceneContext() {\n        return new SceneContext(this);\n    }\n    /** Populate the context with the scene to be rendered by this viewport.\n     * @note This method is not typically invoked directly - [[renderFrame]] invokes it as needed to recreate the scene.\n     */\n    createScene(context) {\n        this.view.createScene(context);\n        if (this._mapTiledGraphicsProvider)\n            TiledGraphicsProvider.addToScene(this._mapTiledGraphicsProvider, context);\n        for (const provider of this._tiledGraphicsProviders)\n            TiledGraphicsProvider.addToScene(provider, context);\n    }\n    /** @internal */\n    validateRenderPlan() {\n        this.target.changeRenderPlan(createRenderPlanFromViewport(this));\n        this._renderPlanValid = true;\n    }\n    animate() {\n        if (this._animator?.animate())\n            this._animator = undefined; // animation completed.\n    }\n    /** Renders the contents of this viewport. This method performs only as much work as necessary based on what has changed since\n     * the last frame. If nothing has changed since the last frame, nothing is rendered.\n     * @note This method should almost never be invoked directly - it is invoked on your behalf by [[ViewManager]]'s render loop.\n     */\n    renderFrame() {\n        this._frameStatsCollector.beginFrame();\n        const changeFlags = this._changeFlags;\n        if (changeFlags.hasChanges)\n            this._changeFlags = new MutableChangeFlags(ChangeFlag.None);\n        const view = this.view;\n        const target = this.target;\n        // Start timer for tile loading time\n        const timer = new StopWatch(undefined, true);\n        this._frameStatsCollector.beginTime(\"totalSceneTime\");\n        this._frameStatsCollector.beginTime(\"animationTime\");\n        // if any animation is active, perform it now\n        this.animate();\n        this._frameStatsCollector.endTime(\"animationTime\");\n        let isRedrawNeeded = this._redrawPending || this._doContinuousRendering;\n        this._redrawPending = false;\n        const resized = target.updateViewRect();\n        if (resized) {\n            target.onResized();\n            this.invalidateController();\n        }\n        if (!this._controllerValid)\n            this.setupFromView();\n        if (this._selectionSetDirty) {\n            target.setHiliteSet(view.iModel.hilited);\n            this._selectionSetDirty = false;\n            isRedrawNeeded = true;\n        }\n        let overridesNeeded = changeFlags.areFeatureOverridesDirty;\n        if (!this._analysisFractionValid) {\n            this._analysisFractionValid = isRedrawNeeded = true;\n            target.analysisFraction = this.displayStyle.settings.analysisFraction;\n        }\n        if (!this._timePointValid) {\n            isRedrawNeeded = true;\n            const scheduleScript = view.displayStyle.scheduleScript;\n            if (scheduleScript) {\n                target.animationBranches = AnimationBranchStates.fromScript(scheduleScript, this.timePoint ?? scheduleScript.duration.low);\n                if (scheduleScript.containsFeatureOverrides)\n                    overridesNeeded = true;\n                if (scheduleScript.containsTransform && !this._freezeScene)\n                    this.invalidateScene();\n            }\n            this._timePointValid = true;\n        }\n        if (overridesNeeded) {\n            const ovr = new FeatureSymbology.Overrides(this);\n            target.overrideFeatureSymbology(ovr);\n            isRedrawNeeded = true;\n        }\n        if (!this._sceneValid) {\n            if (!this._freezeScene) {\n                this._frameStatsCollector.beginTime(\"createChangeSceneTime\");\n                IModelApp.tileAdmin.clearTilesForUser(this);\n                IModelApp.tileAdmin.clearUsageForUser(this);\n                const context = this.createSceneContext();\n                this.createScene(context);\n                context.requestMissingTiles();\n                this._hasMissingTiles = context.hasMissingTiles || context.missingTiles.size > 0;\n                target.changeScene(context.scene);\n                isRedrawNeeded = true;\n                this._frameStatsCollector.endTime(\"createChangeSceneTime\");\n            }\n            this._sceneValid = true;\n        }\n        if (!this._renderPlanValid) {\n            this._frameStatsCollector.beginTime(\"validateRenderPlanTime\");\n            this.validateRenderPlan();\n            this._frameStatsCollector.endTime(\"validateRenderPlanTime\");\n            isRedrawNeeded = true;\n        }\n        if (!this._decorationsValid) {\n            this._frameStatsCollector.beginTime(\"decorationsTime\");\n            const decorations = new Decorations();\n            this.addDecorations(decorations);\n            target.changeDecorations(decorations);\n            this._decorationsValid = true;\n            isRedrawNeeded = true;\n            this._frameStatsCollector.endTime(\"decorationsTime\");\n        }\n        let requestNextAnimation = false;\n        if (this.processFlash()) {\n            target.setFlashed(undefined !== this.flashedId ? this.flashedId : Id64.invalid, this._flashIntensity);\n            isRedrawNeeded = true;\n            requestNextAnimation = undefined !== this.flashedId;\n        }\n        this._frameStatsCollector.beginTime(\"onBeforeRenderTime\");\n        target.onBeforeRender(this, (redraw) => {\n            isRedrawNeeded = isRedrawNeeded || redraw;\n        });\n        this._frameStatsCollector.endTime(\"onBeforeRenderTime\");\n        this._frameStatsCollector.endTime(\"totalSceneTime\");\n        timer.stop();\n        if (isRedrawNeeded) {\n            target.drawFrame(timer.elapsed.milliseconds);\n            this.onRender.raiseEvent(this);\n        }\n        this._frameStatsCollector.endFrame(isRedrawNeeded);\n        // Dispatch change events after timer has stopped and update has finished.\n        if (resized)\n            this.onResized.raiseEvent(this);\n        if (changeFlags.hasChanges) {\n            this.onViewportChanged.raiseEvent(this, changeFlags);\n            if (changeFlags.displayStyle)\n                this.onDisplayStyleChanged.raiseEvent(this);\n            if (changeFlags.viewedModels)\n                this.onViewedModelsChanged.raiseEvent(this);\n            if (changeFlags.areFeatureOverridesDirty) {\n                this.onFeatureOverridesChanged.raiseEvent(this);\n                if (changeFlags.alwaysDrawn)\n                    this.onAlwaysDrawnChanged.raiseEvent(this);\n                if (changeFlags.neverDrawn)\n                    this.onNeverDrawnChanged.raiseEvent(this);\n                if (changeFlags.viewedCategories)\n                    this.onViewedCategoriesChanged.raiseEvent(this);\n                if (changeFlags.viewedCategoriesPerModel)\n                    this.onViewedCategoriesPerModelChanged.raiseEvent(this);\n                if (changeFlags.featureOverrideProvider)\n                    this.onFeatureOverrideProviderChanged.raiseEvent(this);\n            }\n        }\n        if (requestNextAnimation || undefined !== this._animator || this.continuousRendering)\n            IModelApp.requestNextAnimation();\n    }\n    /** Populate a set of decoration graphics to be displayed in this viewport.\n     * This base implementation produces no graphics.\n     */\n    addDecorations(_decorations) { }\n    /** Read selected data about each pixel within a rectangular region of this Viewport.\n     * @param rect The area of the viewport's contents to read. The origin specifies the upper-left corner. Must lie entirely within the viewport's dimensions. This input viewport is specified using CSS pixels not device pixels.\n     * @param selector Specifies which aspect(s) of data to read.\n     * @param receiver A function accepting a [[Pixel.Buffer]] object from which the selected data can be retrieved, or receiving undefined if the viewport has been disposed, the rect is out of bounds, or some other error. The pixels received will be device pixels, not CSS pixels. See [[Viewport.devicePixelRatio]] and [[Viewport.cssPixelsToDevicePixels]].\n     * @param excludeNonLocatable If true, geometry with the \"non-locatable\" flag set will not be drawn.\n     * @note The [[Pixel.Buffer]] supplied to the `receiver` function becomes invalid once that function exits. Do not store a reference to it.\n     */\n    readPixels(rect, selector, receiver, excludeNonLocatable = false) {\n        const viewRect = this.viewRect;\n        if (this.isDisposed || rect.isNull || !rect.isContained(viewRect))\n            receiver(undefined);\n        else\n            this.target.readPixels(rect, selector, receiver, excludeNonLocatable);\n    }\n    /** @internal */\n    isPixelSelectable(pixel) {\n        if (undefined === pixel.modelId || undefined === pixel.elementId)\n            return false;\n        if (pixel.modelId === pixel.elementId)\n            return false; // Reality Models not selectable\n        return (0 === this.mapLayerFromIds(pixel.modelId, pixel.elementId).length); // Maps no selectable.\n    }\n    /** Read the current image from this viewport from the rendering system. If a \"null\" rectangle is supplied (@see [[ViewRect.isNull]]), the entire view is captured.\n     * @param rect The area of the view to read. The origin of a viewRect must specify the upper left corner.\n     * @param targetSize The size of the image to be returned. The size can be larger or smaller than the original view.\n     * @param flipVertically If true, the image is flipped along the x-axis.\n     * @returns The contents of the viewport within the specified rectangle as a bitmap image, or undefined if the image could not be read.\n     * @note By default the image is returned with the coordinate (0,0) referring to the bottom-most pixel. Pass `true` for `flipVertically` to flip it along the x-axis.\n     * @deprecated in 3.x. Use readImageBuffer.\n     */\n    readImage(rect = new ViewRect(1, 1, 0, 0), targetSize = Point2d.createZero(), flipVertically = false) {\n        // eslint-disable-next-line deprecation/deprecation\n        return this.target.readImage(rect, targetSize, flipVertically);\n    }\n    /** Capture the image currently rendered in this viewport, or a subset thereof.\n     * @param args Describes the region to capture and optional resizing. By default the entire image is captured with no resizing.\n     * @returns The image, or `undefined` if the specified capture rect is not fully contained in [[viewRect], a 2d context could not be obtained, or the resultant image consists entirely\n     * of 100% transparent background pixels.\n     */\n    readImageBuffer(args) {\n        return this.target.readImageBuffer(args);\n    }\n    /** Reads the current image from this viewport into an HTMLCanvasElement with a Canvas2dRenderingContext such that additional 2d graphics can be drawn onto it.\n     * @see [[readImageBuffer]] to obtain the image as an array of RGBA pixels.\n     */\n    readImageToCanvas() {\n        return this.target.readImageToCanvas();\n    }\n    /** Used internally by `waitForSceneCompletion`.\n     * @internal\n     */\n    hasAdditionalTiles() {\n        const tilesThisVp = IModelApp.tileAdmin.getTilesForUser(this);\n        const ext = tilesThisVp?.external;\n        if ((ext?.requested ?? 0) > 0)\n            return true;\n        // ViewAttachments and 3d section drawing attachments render to separate off-screen viewports - check those too.\n        for (const vp of this.view.secondaryViewports) {\n            if (vp.numRequestedTiles > 0) {\n                return true;\n            }\n            const tiles = IModelApp.tileAdmin.getTilesForUser(vp);\n            if (tiles && tiles.external.requested > 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /** Returns a Promise that resolves after the contents of this viewport are fully loaded and rendered.\n     * This can be useful, for example, when you want to capture an image of the viewport's contents, as in the following code:\n     * ```ts\n     *  async function captureImage(vp: Viewport): Promise<ImageBuffer | undefined> {\n     *    await vp.waitForSceneCompletion();\n     *    return vp.readImageBuffer();\n     *  }\n     * ```\n     */\n    async waitForSceneCompletion() {\n        const system = this.target.renderSystem;\n        let haveNewTiles = true;\n        let haveExternalTexRequests = true;\n        while ((haveNewTiles || haveExternalTexRequests) && !this.isDisposed) {\n            // Since this viewport is not being managed by the ViewManager, we must first manually invalidate the scene and re-render the frame each tick of the tile-wait loop.\n            this.invalidateScene();\n            this.renderFrame();\n            haveExternalTexRequests = system.hasExternalTextureRequests;\n            haveNewTiles = !this.areAllTileTreesLoaded || this._hasMissingTiles;\n            if (!haveNewTiles)\n                haveNewTiles = this.hasAdditionalTiles();\n            // Since the viewport is not being managed by the ViewManager, we must manually pump the TileAdmin to initiate further tile requests each tick of the tile-wait loop.\n            if (haveNewTiles)\n                IModelApp.tileAdmin.process();\n            await BeDuration.wait(100);\n        }\n    }\n    /** Get the point at the specified x and y location in the pixel buffer in npc coordinates.\n     * @see [[getPixelDataWorldPoint]] to obtain the point in [[CoordSystem.World]].\n     */\n    getPixelDataNpcPoint(pixels, x, y, out) {\n        const z = pixels.getPixel(x, y).distanceFraction;\n        if (z <= 0.0)\n            return undefined;\n        const viewSpace = this._viewingSpace;\n        const result = undefined !== out ? out : new Point3d();\n        const viewRect = this.viewRect.clone();\n        viewRect.left = this.cssPixelsToDevicePixels(viewRect.left);\n        viewRect.right = this.cssPixelsToDevicePixels(viewRect.right);\n        viewRect.bottom = this.cssPixelsToDevicePixels(viewRect.bottom);\n        viewRect.top = this.cssPixelsToDevicePixels(viewRect.top);\n        result.x = (x + 0.5 - viewRect.left) / viewRect.width;\n        result.y = 1.0 - (y + 0.5 - viewRect.top) / viewRect.height;\n        if (viewSpace.frustFraction < 1.0)\n            result.z = z * viewSpace.frustFraction / (1.0 + z * (viewSpace.frustFraction - 1.0)); // correct to npc if camera on.\n        else\n            result.z = z;\n        return result;\n    }\n    /** Get the point at the specified x and y location in the pixel buffer in world coordinates.\n     * @see [[getPixelDataNpcPoint]] to obtain the point in [[CoordSystem.Npc]].\n     */\n    getPixelDataWorldPoint(args) {\n        const { pixels, x, y, out, preserveModelDisplayTransforms } = args;\n        const npc = this.getPixelDataNpcPoint(pixels, x, y, out);\n        if (undefined !== npc) {\n            this.npcToWorld(npc, npc);\n            // If this is a plan projection model, invert the elevation applied to its display transform.\n            // Likewise, if it is a hit on a model with a display transform, reverse the display transform.\n            if (!preserveModelDisplayTransforms) {\n                const pixel = pixels.getPixel(x, y);\n                const modelId = pixel.modelId;\n                if (undefined !== modelId) {\n                    const transform = this.view.computeDisplayTransform({\n                        modelId,\n                        elementId: pixel.feature?.elementId,\n                        viewAttachmentId: pixel.viewAttachmentId,\n                    });\n                    transform?.multiplyInversePoint3d(npc, npc);\n                }\n            }\n        }\n        return npc;\n    }\n    /** Query which [Feature]($common)s are currently visible within the viewport.\n     * @param options Specifies how to query.\n     * @param callback Callback to invoke with the results.\n     * @note This function may be slow, especially if the features are being queried from screen pixels. Avoid calling it repeatedly in rapid succession.\n     */\n    queryVisibleFeatures(options, callback) {\n        return queryVisibleFeatures(this, options, callback);\n    }\n    /** Record graphics memory consumed by this viewport. */\n    collectStatistics(stats) {\n        const trees = new DisclosedTileTreeSet();\n        this.discloseTileTrees(trees);\n        for (const tree of trees)\n            tree.collectStatistics(stats);\n        this.view.collectNonTileTreeStatistics(stats);\n    }\n    /** Intended strictly as a temporary solution for interactive editing applications, until official support for such apps is implemented.\n     * Invalidates tile trees for all specified models (or all viewed models, if none specified), causing subsequent requests for tiles to make new requests to back-end for updated tiles.\n     * @internal\n     */\n    refreshForModifiedModels(modelIds) {\n        if (this.view.refreshForModifiedModels(modelIds))\n            this.invalidateScene();\n    }\n    /** A multiplier applied to the size in pixels of a [[Tile]] during tile selection for this viewport. Defaults to [[TileAdmin.defaultTileSizeModifier]] but can be overridden per-viewport.\n     * A value greater than 1.0 causes lower-resolution tiles to be selected; a value less than 1.0 causes higher-resolution tiles to be selected.\n     * This can allow an application to sacrifice quality for performance or vice-versa.\n     * @alpha\n     */\n    get tileSizeModifier() {\n        return undefined !== this._tileSizeModifier ? this._tileSizeModifier : IModelApp.tileAdmin.defaultTileSizeModifier;\n    }\n    /** Controls this Viewport's [[tileSizeModifier]].\n     * @param modifier If defined, overrides [[TileAdmin.defaultTileSizeModifier]]; otherwise, resets it to that default. Must be greater than zero.\n     * @alpha\n     */\n    setTileSizeModifier(modifier) {\n        if (modifier === this._tileSizeModifier)\n            return;\n        if (undefined !== modifier && (Number.isNaN(modifier) || modifier <= 0))\n            return;\n        this._tileSizeModifier = modifier;\n        this.invalidateScene();\n    }\n    /** The device pixel ratio used by this Viewport. This value is *not* necessarily equal to `window.devicePixelRatio`.\n     * See: https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio\n     */\n    get devicePixelRatio() {\n        return this.target.devicePixelRatio;\n    }\n    /** Convert a number in CSS pixels to device pixels using this Viewport's device pixel ratio.\n     * See: https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio\n     * @param num The number in CSS pixels to scale\n     * @returns The resulting number in device pixels\n     */\n    cssPixelsToDevicePixels(cssPixels) {\n        return this.target.cssPixelsToDevicePixels(cssPixels);\n    }\n    /** See [[ViewState.setModelDisplayTransformProvider]]\n     * @internal\n     */\n    setModelDisplayTransformProvider(provider) {\n        this.view.modelDisplayTransformProvider = provider;\n    }\n    /** An ordered list of names of screen-space post-processing effects to be applied to the image rendered by the Viewport.\n     * The effects are applied to the image in the order in which they appear in the list. Any names not corresponding to a registered effect are ignored.\n     * This may have no effect if the Viewport's [[RenderTarget]] does not support screen-space effects.\n     * @see [[RenderSystem.createScreenSpaceEffectBuilder]] to create and register new effects.\n     * @public\n     */\n    get screenSpaceEffects() {\n        return this.target.screenSpaceEffects;\n    }\n    set screenSpaceEffects(effects) {\n        this.target.screenSpaceEffects = effects;\n        this.requestRedraw();\n    }\n    /** Append a screen-space effect to the list of effects applied to this Viewport.\n     * @see [[Viewport.screenSpaceEffects]].\n     * @public\n     */\n    addScreenSpaceEffect(effectName) {\n        this.screenSpaceEffects = [...this.screenSpaceEffects, effectName];\n    }\n    /** Remove all screen-space effects from this Viewport.\n     * @see [[Viewport.screenSpaceEffects]].\n     * @public\n     */\n    removeScreenSpaceEffects() {\n        this.screenSpaceEffects = [];\n    }\n    /** Add an event listener to be invoked whenever the [AnalysisStyle]($common) associated with this viewport changes.\n     * The analysis style may change for any of several reasons:\n     *  - When the viewport's associated [DisplayStyleSettings.analysisStyle]($common).\n     *  - When the viewport's associated [[ViewState.displayStyle]] changes.\n     *  - When the viewport's associated [[ViewState]] changes via [[changeView]].\n     * @param listener Callback accepting the new analysis style, or undefined if there is no analysis style.\n     * @returns A function that can be invoked to remove the event listener.\n     */\n    addOnAnalysisStyleChangedListener(listener) {\n        const addSettingsListener = (style) => style.settings.onAnalysisStyleChanged.addListener(listener);\n        let removeSettingsListener = addSettingsListener(this.displayStyle);\n        const addStyleListener = (view) => view.onDisplayStyleChanged.addListener((style) => {\n            listener(style.settings.analysisStyle);\n            removeSettingsListener();\n            removeSettingsListener = addSettingsListener(view.displayStyle);\n        });\n        const removeStyleListener = addStyleListener(this.view);\n        const removeViewListener = this.onChangeView.addListener((vp) => {\n            listener(vp.view.displayStyle.settings.analysisStyle);\n            removeStyleListener();\n            addStyleListener(vp.view);\n        });\n        return () => {\n            removeSettingsListener();\n            removeStyleListener();\n            removeViewListener();\n        };\n    }\n    /** TileUser implementation @internal */\n    get tileUserId() {\n        return this.viewportId;\n    }\n    /** TileUser implementation @internal */\n    onRequestStateChanged() {\n        this.invalidateScene();\n    }\n    /** @internal See [[OffScreenViewport.drawingToSheetTransform */\n    get drawingToSheetTransform() { return undefined; }\n    set drawingToSheetTransform(_) { assert(false, \"drawingToSheetTransform is only relevant for OffScreenViewport\"); }\n}\n/** Don't allow entries in the view undo buffer unless they're separated by more than this amount of time. */\nViewport.undoDelay = BeDuration.fromSeconds(.5);\nexport { Viewport };\n/** An interactive Viewport that exists within an HTMLDivElement. ScreenViewports can receive HTML events.\n * To render the contents of a ScreenViewport, it must be added to the [[ViewManager]] via ViewManager.addViewport().\n * Every frame, the ViewManager will update the Viewport's state and re-render its contents if anything has changed.\n * To halt this loop, use ViewManager.dropViewport() to remove the viewport from the ViewManager.\n *\n * A ScreenViewport internally owns significant WebGL resources which must be explicitly disposed of when the viewport is no longer needed.\n * This is achieved by invoking the viewport's dispose() method. ViewManager.dropViewport() invokes dispose() on the viewport by default.\n *\n * The lifetime of a ScreenViewport typically follows a pattern:\n * ```\n *  1. Application creates the viewport via ScreenViewport.create()\n *  2. The viewport is added to the render loop via ViewManager.addViewport()\n *  3. When the application is finished with the viewport, it removes it from the render loop and disposes of it via ViewManager.dropViewport().\n * ```\n *\n * In some cases it may be useful to temporarily suspend a viewport's render loop. In this case the lifetime of the viewport proceeds as follows:\n * ```\n *  1. Application creates the viewport via ScreenViewport.create()\n *  2. The viewport is added to the render loop via ViewManager.addViewport()\n *  3. At some point the render loop is suspended via ViewManager.dropViewport(viewport, false), indicating the viewport should not be disposed.\n *  4. Optionally, resume rendering by returning to step 2.\n *  5. When the application is finished with the viewport:\n *    5a. If it is currently registered with the ViewManager, it is dropped and disposed of via ViewManager.dropViewport()\n *    5b. Otherwise, it is disposed of by invoking its dispose() method directly.\n * ```\n *\n * @see [[ScreenViewport.create]] to create a ScreenViewport.\n * @public\n * @extensions\n */\nclass ScreenViewport extends Viewport {\n    /** Create a new ScreenViewport that shows a View of an iModel into an HTMLDivElement. This method will create a new HTMLCanvasElement as a child of the supplied parentDiv.\n     * It also creates two new child HTMLDivElements: one of class \"overlay-decorators\" for HTML overlay decorators, and one of class\n     * \"overlay-tooltip\" for ToolTips. All the new child HTMLElements are the same size as the parentDiv.\n     * @param parentDiv The HTMLDivElement to contain the ScreenViewport. The element must have non-zero width and height.\n     * @param view The ViewState for the ScreenViewport.\n     * @note After creating a new ScreenViewport, you must call [[ViewManager.addViewport]] for it to become \"live\". You must also ensure you dispose of it properly.\n     * @throws Error if `parentDiv` has zero width or height.\n     */\n    static create(parentDiv, view) {\n        if (0 === parentDiv.clientWidth || 0 === parentDiv.clientHeight)\n            throw new Error(\"viewport cannot be created from a div with zero width or height\");\n        const canvas = document.createElement(\"canvas\");\n        const vp = new this(canvas, parentDiv, IModelApp.renderSystem.createTarget(canvas));\n        vp.initialize();\n        vp.changeView(view);\n        return vp;\n    }\n    /** @internal */\n    dispose() {\n        super.dispose();\n        this._decorationCache.clear();\n    }\n    /** @internal */\n    invalidateScene() {\n        super.invalidateScene();\n        // When the scene is invalidated, so are all cached decorations - they will be regenerated.\n        this._decorationCache.clear();\n    }\n    /** Forces removal of a specific decorator's cached decorations from this viewport, if they exist.\n     * This will force those decorations to be regenerated.\n     * @see [[ViewportDecorator.useCachedDecorations]].\n     */\n    invalidateCachedDecorations(decorator) {\n        this._decorationCache.delete(decorator);\n        // Always invalidate decorations. Decorator may have no cached decorations currently, but wants them created.\n        this.invalidateDecorations();\n    }\n    /** @internal */\n    static markAllChildrenForRemoval(el) {\n        for (const child of el.children)\n            child[ELEMENT_MARKED_FOR_REMOVAL] = true;\n    }\n    /** @internal */\n    static removeMarkedChildren(el) {\n        for (const child of [...el.children]) // spread to duplicate the HTMLCollection which is invalidated by removals\n            if (child[ELEMENT_MARKED_FOR_REMOVAL])\n                el.removeChild(child);\n    }\n    /** Remove all of the children of an HTMLDivElement.\n     * @internal\n     */\n    static removeAllChildren(el) {\n        while (el.lastChild)\n            el.removeChild(el.lastChild);\n    }\n    /** set Div style to absolute, {0,0,100%,100%}\n     * @internal\n     */\n    static setToParentSize(div) {\n        const style = div.style;\n        style.position = \"absolute\";\n        style.top = style.left = \"0\";\n        style.height = style.width = \"100%\";\n    }\n    /**  add a child element to this.vpDiv and set its size and position the same as the parent.  */\n    addChildDiv(parent, element, zIndex) {\n        ScreenViewport.setToParentSize(element);\n        element.style.zIndex = zIndex.toString();\n        parent.appendChild(element);\n    }\n    /** Add a new `HTMLDivElement` as a child of this viewport's div.\n     * @param className The CSS class name to apply to the div.\n     * @param overflowHidden Whether to set `div.style.overflow` to \"hidden\" instead of \"visible\".\n     * @param z The Z index of the div relative to its sibling `HTMLElement`s.\n     * @returns the new div.\n     */\n    addNewDiv(className, overflowHidden, z) {\n        const div = document.createElement(\"div\");\n        div.className = className;\n        div.style.pointerEvents = \"none\";\n        div.style.overflow = overflowHidden ? \"hidden\" : \"visible\";\n        this.addChildDiv(this.vpDiv, div, z);\n        return div;\n    }\n    /** The HTMLImageElement of the iTwin.js logo displayed in this ScreenViewport. */\n    get logo() { return this._logo; }\n    /** @internal */\n    addLogo() {\n        const logo = this._logo = IModelApp.makeHTMLElement(\"img\", { parent: this.vpDiv, className: \"imodeljs-icon\" });\n        logo.src = `${IModelApp.publicPath}images/imodeljs-icon.svg`;\n        logo.alt = \"\";\n        const showLogos = (ev) => {\n            const aboutBox = IModelApp.makeModalDiv({ autoClose: true, width: 460, closeBox: true, rootDiv: this.vpDiv.ownerDocument.body }).modal;\n            aboutBox.className += \" imodeljs-about\"; // only added so the CSS knows this is the about dialog\n            const logos = IModelApp.makeHTMLElement(\"table\", { parent: aboutBox, className: \"logo-cards\" });\n            if (undefined !== IModelApp.applicationLogoCard)\n                logos.appendChild(IModelApp.applicationLogoCard());\n            logos.appendChild(IModelApp.makeIModelJsLogoCard());\n            this.forEachTileTreeRef((ref) => ref.addLogoCards(logos, this));\n            ev.stopPropagation();\n        };\n        logo.onclick = showLogos;\n        logo.addEventListener(\"touchstart\", showLogos);\n        logo.onmousemove = logo.onmousedown = logo.onmouseup = (ev) => ev.stopPropagation();\n    }\n    /** @internal */\n    constructor(canvas, parentDiv, target) {\n        super(target);\n        /** The number of entries in the view undo/redo buffer. */\n        this.maxUndoSteps = 20;\n        this._forwardStack = [];\n        this._backStack = [];\n        this._decorationCache = new DecorationsCache();\n        /** @internal */\n        this.picker = new ElementPicker(); // Picker used in pickDepthPoint below so it hangs around and can be queried later.\n        this.canvas = canvas;\n        this.parentDiv = parentDiv;\n        // first remove all children of the parent Div\n        ScreenViewport.removeAllChildren(parentDiv);\n        const div = this.vpDiv = IModelApp.makeHTMLElement(\"div\", { className: \"imodeljs-vp\" });\n        this.addChildDiv(this.parentDiv, div, 0);\n        this.addChildDiv(this.vpDiv, canvas, 10);\n        this.target.updateViewRect();\n        // SEE: decorationDiv doc comment\n        // eslint-disable-next-line deprecation/deprecation\n        this.decorationDiv = this.addNewDiv(\"overlay-decorators\", true, 30);\n        this.toolTipDiv = this.addNewDiv(\"overlay-tooltip\", true, 40);\n        this.setCursor();\n        this.addLogo();\n    }\n    /** Open the toolTip window in this ScreenViewport with the supplied message and location. The tooltip will be a child of [[ScreenViewport.toolTipDiv]].\n     * @param message The message to display\n     * @param location The position of the toolTip, in view coordinates. If undefined, use center of view.\n     * @param options the ToolTip options\n     * @note There is only one ToolTip window, so calling this method more than once will move the toolTip and show the second message.\n     */\n    openToolTip(message, location, options) {\n        IModelApp.notifications.openToolTip(this.toolTipDiv, message, location, options);\n    }\n    /** @internal */\n    mousePosFromEvent(ev) {\n        const rect = this.getClientRect();\n        return { x: ev.clientX - rect.left, y: ev.clientY - rect.top };\n    }\n    /** @internal */\n    mouseMovementFromEvent(ev) {\n        return { x: ev.movementX, y: ev.movementY };\n    }\n    /** Set the event controller for this Viewport. Destroys previous controller, if one was defined.\n     * @deprecated in 3.x. this was intended for internal use only.\n     */\n    setEventController(controller) {\n        if (this._evController)\n            this._evController.destroy();\n        this._evController = controller;\n    }\n    /** Invoked by ViewManager.addViewport.\n     * @internal\n     */\n    onViewManagerAdd() {\n        this.onViewManagerDrop();\n        this._evController = new EventController(this);\n        this._resizeObserver = new ResizeObserver(() => {\n            this.requestRedraw();\n        });\n        this._resizeObserver.observe(this.canvas);\n    }\n    /** Invoked by ViewManager.dropViewport.\n     * @internal\n     */\n    onViewManagerDrop() {\n        this._evController?.destroy();\n        this._resizeObserver?.disconnect();\n        this._evController = this._resizeObserver = undefined;\n    }\n    /** Find a point on geometry visible in this Viewport, within a radius of supplied pick point.\n     * @param pickPoint Point to search about, in world coordinates\n     * @param radius Radius, in pixels, of the circular area to search.\n     * @param allowNonLocatable If true, include geometry with non-locatable flag set.\n     * @param out Optional Point3d to hold the result. If undefined, a new Point3d is returned.\n     * @returns The point, in world coordinates, on the element closest to `pickPoint`, or undefined if no elements within `radius`.\n     */\n    pickNearestVisibleGeometry(pickPoint, radius, allowNonLocatable = true, out) {\n        const depthResult = this.pickDepthPoint(pickPoint, radius, { excludeNonLocatable: !allowNonLocatable });\n        let isValidDepth = false;\n        switch (depthResult.source) {\n            case DepthPointSource.Geometry:\n            case DepthPointSource.Model:\n            case DepthPointSource.Map:\n                isValidDepth = true;\n                break;\n            case DepthPointSource.BackgroundMap:\n            case DepthPointSource.GroundPlane:\n            case DepthPointSource.Grid:\n            case DepthPointSource.ACS:\n                const npcPt = this.worldToNpc(depthResult.plane.getOriginRef());\n                isValidDepth = !(npcPt.z < 0.0 || npcPt.z > 1.0);\n                break;\n        }\n        if (!isValidDepth)\n            return undefined;\n        const result = undefined !== out ? out : new Point3d();\n        result.setFrom(depthResult.plane.getOriginRef());\n        return result;\n    }\n    /** Find a point on geometry visible in this Viewport, within a radius of supplied pick point.\n     * If no geometry is selected, return the point projected to the most appropriate reference plane.\n     * @param pickPoint Point to search about, in world coordinates\n     * @param radius Radius, in pixels, of the circular area to search.\n     * @param options Optional settings to control what can be selected.\n     * @returns A plane with origin from closest geometry point or reference plane projection and the source of the depth point.\n     * @note The result plane normal is valid when the source is not geometry or a reality model.\n     */\n    pickDepthPoint(pickPoint, radius, options) {\n        if (!this.view.is3d())\n            return { plane: Plane3dByOriginAndUnitNormal.createXYPlane(pickPoint), source: DepthPointSource.ACS };\n        if (undefined === radius)\n            radius = this.pixelsFromInches(ToolSettings.viewToolPickRadiusInches);\n        this.picker.empty();\n        const locateOpts = new LocateOptions();\n        locateOpts.allowNonLocatable = (undefined === options || !options.excludeNonLocatable);\n        locateOpts.allowDecorations = (undefined === options || !options.excludeDecorations);\n        locateOpts.allowExternalIModels = (undefined === options || !options.excludeExternalIModels);\n        locateOpts.preserveModelDisplayTransforms = true;\n        if (0 !== this.picker.doPick(this, pickPoint, radius, locateOpts)) {\n            const hitDetail = this.picker.getHit(0);\n            const hitPoint = hitDetail.getPoint();\n            if (hitDetail.isModelHit)\n                return { plane: Plane3dByOriginAndUnitNormal.create(hitPoint, this.view.getUpVector(hitPoint)), source: DepthPointSource.Model, sourceId: hitDetail.sourceId };\n            else if (hitDetail.isMapHit)\n                return { plane: Plane3dByOriginAndUnitNormal.create(hitPoint, this.view.getUpVector(hitPoint)), source: DepthPointSource.Map, sourceId: hitDetail.sourceId };\n            return { plane: Plane3dByOriginAndUnitNormal.create(hitPoint, this.view.getZVector()), source: DepthPointSource.Geometry, sourceId: hitDetail.sourceId };\n        }\n        const eyePoint = this.worldToViewMap.transform1.columnZ();\n        const direction = Vector3d.createFrom(eyePoint);\n        const aa = Geometry.conditionalDivideFraction(1, eyePoint.w);\n        if (aa !== undefined) {\n            const xyzEye = direction.scale(aa);\n            direction.setFrom(pickPoint.vectorTo(xyzEye));\n        }\n        direction.scaleToLength(-1.0, direction);\n        const boresiteIntersectRay = Ray3d.create(pickPoint, direction);\n        const projectedPt = Point3d.createZero();\n        const backgroundMapGeometry = this.backgroundMapGeometry;\n        if (undefined !== backgroundMapGeometry) {\n            const intersect = backgroundMapGeometry.getRayIntersection(boresiteIntersectRay, false);\n            if (undefined !== intersect) {\n                const npcPt = this.worldToNpc(intersect.origin);\n                if (npcPt.z < 1) // Only if in front of eye.\n                    return { plane: Plane3dByOriginAndUnitNormal.create(intersect.origin, intersect.direction), source: DepthPointSource.BackgroundMap };\n            }\n        }\n        // returns true if there's an intersection that isn't behind the front plane\n        const boresiteIntersect = (plane) => {\n            const dist = boresiteIntersectRay.intersectionWithPlane(plane, projectedPt);\n            if (undefined === dist)\n                return false;\n            const npcPt = this.worldToNpc(projectedPt);\n            return npcPt.z < 1.0;\n        };\n        if (this.view.getDisplayStyle3d().environment.displayGround) {\n            const groundPlane = Plane3dByOriginAndUnitNormal.create(Point3d.create(0, 0, this.view.getGroundElevation()), Vector3d.unitZ());\n            if (undefined !== groundPlane && boresiteIntersect(groundPlane))\n                return { plane: Plane3dByOriginAndUnitNormal.create(projectedPt, groundPlane.getNormalRef()), source: DepthPointSource.GroundPlane };\n        }\n        const acsPlane = Plane3dByOriginAndUnitNormal.create(this.getAuxCoordOrigin(), this.getAuxCoordRotation().getRow(2));\n        if (undefined !== acsPlane && boresiteIntersect(acsPlane))\n            return { plane: Plane3dByOriginAndUnitNormal.create(projectedPt, acsPlane.getNormalRef()), source: (this.isGridOn && GridOrientationType.AuxCoord === this.view.getGridOrientation() ? DepthPointSource.Grid : DepthPointSource.ACS) };\n        const targetPointNpc = this.worldToNpc(this.view.getTargetPoint());\n        if (targetPointNpc.z < 0.0 || targetPointNpc.z > 1.0)\n            targetPointNpc.z = 0.5;\n        this.worldToNpc(pickPoint, projectedPt);\n        projectedPt.z = targetPointNpc.z;\n        this.npcToWorld(projectedPt, projectedPt);\n        return { plane: Plane3dByOriginAndUnitNormal.create(projectedPt, this.view.getZVector()), source: DepthPointSource.TargetPoint };\n    }\n    /** Queue an animation that interpolates between this viewport's previous [Frustum]($common) and its current frustum.\n     * This function is typically called by [ViewTool]($frontend)s after modifying the viewport's [ViewState]($frontend), to smoothly transition to the new view;\n     * as opposed to calling [[synchWithView]] which immediately transitions to the new view. It uses [[FrustumAnimator]] to perform the animation.\n     * @public\n     */\n    animateFrustumChange(options) {\n        if (this._lastPose && this._currentBaseline)\n            this.setAnimator(new FrustumAnimator(options ? options : {}, this, this._lastPose, this.view.savePose()));\n    }\n    /** Animate the view frustum from a starting frustum to the current view frustum. In other words,\n     * save a starting frustum (presumably what the user is currently looking at), then adjust the view to\n     * a different location and call synchWithView, then call this method. After the animation the viewport\n     * frustum will be restored to its current location.\n     * @internal\n     */\n    animateToCurrent(_start, options) {\n        options = options ? options : {};\n        this.animateFrustumChange(/* start, this.getFrustum(), */ options);\n    }\n    /** Animate the view frustum to a destination location the earth from the current frustum. */\n    async animateFlyoverToGlobalLocation(destination) {\n        const animator = await GlobeAnimator.create(this, destination);\n        this.setAnimator(animator);\n    }\n    /** @internal */\n    pickCanvasDecoration(pt) { return this.target.pickOverlayDecoration(pt); }\n    /** Get the DOMRect of the canvas for this Viewport. */\n    getClientRect() { return this.canvas.getBoundingClientRect(); }\n    /** The ViewRect for this ScreenViewport. Left and top will be 0, right will be the width, and bottom will be the height.\n     * @note Do not modify the ViewRect's properties.\n     */\n    get viewRect() {\n        this._viewRange.init(0, 0, this.canvas.clientWidth, this.canvas.clientHeight);\n        return this._viewRange;\n    }\n    /** Populate a set of decoration graphics to be displayed in this viewport. */\n    addDecorations(decorations) {\n        // SEE: decorationDiv doc comment\n        // eslint-disable-next-line deprecation/deprecation\n        ScreenViewport.markAllChildrenForRemoval(this.decorationDiv);\n        const context = new DecorateContext(this, decorations, this._decorationCache);\n        try {\n            // It is an error to try to remove cached decorations while we are decorating.\n            // Some naughty decorators unwittingly do so by e.g. invalidating the scene in their decorate method.\n            this._decorationCache.prohibitRemoval = true;\n            context.addFromDecorator(this.view);\n            this.forEachTiledGraphicsProviderTree((ref) => context.addFromDecorator(ref));\n            for (const decorator of IModelApp.viewManager.decorators)\n                context.addFromDecorator(decorator);\n            // eslint-disable-next-line deprecation/deprecation\n            ScreenViewport.removeMarkedChildren(this.decorationDiv);\n        }\n        finally {\n            this._decorationCache.prohibitRemoval = false;\n        }\n    }\n    /** Change the cursor for this Viewport */\n    setCursor(cursor = \"default\") {\n        this.canvas.style.cursor = cursor;\n    }\n    /** See [[Viewport.synchWithView]]. */\n    synchWithView(options) {\n        options = options ?? {};\n        if (this.view.is3d() && options?.globalAlignment)\n            this.view.alignToGlobe(options.globalAlignment.target, options.globalAlignment.transition);\n        super.synchWithView(options);\n        if (true !== options.noSaveInUndo)\n            this.saveViewUndo();\n        if (true === options.animateFrustumChange)\n            this.animateFrustumChange(options);\n    }\n    /** @internal */\n    validateRenderPlan() {\n        super.validateRenderPlan();\n        this._lastPose = this.view.savePose();\n    }\n    /** Change the ViewState of this Viewport\n     * @param view a fully loaded (see discussion at [[ViewState.load]] ) ViewState\n     * @param opts options for how the view change operation should work\n     */\n    changeView(view, opts) {\n        if (view === this.view) // nothing to do\n            return;\n        this.setAnimator(undefined); // make sure we clear any active animators before we change views.\n        opts = opts ?? { animationTime: ScreenViewport.animation.time.slow.milliseconds };\n        // determined whether we can animate this ViewState change\n        const doAnimate = this.view && this.view.hasSameCoordinates(view) && false !== opts.animateFrustumChange;\n        if (!doAnimate)\n            this.clearViewUndo(); // if we can animate, don't throw out view undo.\n        super.changeView(view, opts);\n        this.saveViewUndo();\n        if (doAnimate)\n            this.animateFrustumChange(opts);\n    }\n    /** A point in world coordinates describing an appropriate default point for a [[ViewTool]] when no more specific point is provided by the user.\n     * This point is generally managed and used by [[ViewManip]].\n     */\n    get viewCmdTargetCenter() { return this._viewCmdTargetCenter; }\n    set viewCmdTargetCenter(center) { this._viewCmdTargetCenter = center ? center.clone() : undefined; }\n    /** True if an undoable viewing operation exists on the stack */\n    get isUndoPossible() { return 0 < this._backStack.length; }\n    /** True if a redoable viewing operation exists on the stack */\n    get isRedoPossible() { return 0 < this._forwardStack.length; }\n    /** Clear the undo buffers of this Viewport. This resets the undo stack. */\n    clearViewUndo() {\n        this._currentBaseline = undefined;\n        this._forwardStack.length = 0;\n        this._backStack.length = 0;\n        this._lastPose = undefined;\n    }\n    /** Saves the current state of this viewport's [[ViewState]] in the undo stack, such that it can be restored by a call to [[ScreenViewport.doUndo]]. */\n    saveViewUndo() {\n        if (this._inViewChangedEvent) // echo from a view changed event.\n            return;\n        // the first time we're called we need to establish the baseline\n        if (!this._currentBaseline)\n            this._currentBaseline = this.view.savePose();\n        if (this._currentBaseline.equalState(this.view))\n            return; // nothing changed, we're done\n        const backStack = this._backStack;\n        if (backStack.length >= this.maxUndoSteps) // don't save more than max\n            backStack.shift(); // remove the oldest entry\n        /** Sometimes we get requests to save undo entries from rapid viewing operations (e.g. mouse wheel rolls). To avoid lots of\n         * little useless intermediate view undo steps that mean nothing, if we get a call to this within a minimum time (1/2 second by default)\n         * we don't add a new entry to the view undo buffer.\n         */\n        const now = BeTimePoint.now();\n        if (Viewport.undoDelay.isZero || backStack.length < 1 || backStack[backStack.length - 1].undoTime.plus(Viewport.undoDelay).before(now)) {\n            this._currentBaseline.undoTime = now; // save time we put this entry in undo buffer\n            this._backStack.push(this._currentBaseline); // save previous state\n            this._forwardStack.length = 0; // not possible to do redo after this\n        }\n        this._currentBaseline = this.view.savePose();\n    }\n    /** Reverses the most recent change to the Viewport from the undo stack. */\n    doUndo(animationTime) {\n        if (0 === this._backStack.length || this._currentBaseline === undefined)\n            return;\n        this._forwardStack.push(this._currentBaseline);\n        this._currentBaseline = this._backStack.pop();\n        this.view.applyPose(this._currentBaseline);\n        this.finishUndoRedo(animationTime);\n        this.onViewUndoRedo.raiseEvent(this, ViewUndoEvent.Undo);\n    }\n    /** Re-applies the most recently un-done change to the Viewport from the redo stack. */\n    doRedo(animationTime) {\n        if (0 === this._forwardStack.length || this._currentBaseline === undefined)\n            return;\n        this._backStack.push(this._currentBaseline);\n        this._currentBaseline = this._forwardStack.pop();\n        this.view.applyPose(this._currentBaseline);\n        this.finishUndoRedo(animationTime);\n        this.onViewUndoRedo.raiseEvent(this, ViewUndoEvent.Redo);\n    }\n    /** @internal */\n    finishUndoRedo(duration) {\n        this.updateChangeFlags(this.view);\n        this.setupFromView();\n        if (undefined !== duration)\n            this.animateFrustumChange({ animationTime: duration.milliseconds });\n    }\n    /** Clear the view undo buffer and establish the current ViewState as the new baseline. */\n    resetUndo() {\n        this.clearViewUndo();\n        this.saveViewUndo(); // Set up new baseline state\n    }\n    /** Show the surface normal for geometry under the cursor when snapping. */\n    static drawLocateHitDetail(context, aperture, hit) {\n        if (!context.viewport.view.is3d())\n            return; // Not valuable feedback in 2d...\n        if (!(hit instanceof SnapDetail) || !hit.normal || hit.isPointAdjusted)\n            return; // AccuSnap will flash edge/segment geometry if not a surface hit or snap location has been adjusted...\n        const builder = context.createGraphicBuilder(GraphicType.WorldOverlay);\n        const color = context.viewport.hilite.color.inverse().withTransparency(100); // Invert hilite color for good contrast\n        const colorFill = color.withTransparency(200);\n        builder.setSymbology(color, colorFill, 1);\n        const skew = context.viewport.view.getAspectRatioSkew();\n        const radius = (2.5 * aperture) * context.viewport.getPixelSizeAtPoint(hit.snapPoint);\n        const rMatrix = Matrix3d.createRigidHeadsUp(hit.normal);\n        const ellipse = Arc3d.createScaledXYColumns(hit.snapPoint, rMatrix, radius, radius / skew, AngleSweep.create360());\n        builder.addArc(ellipse, true, true);\n        builder.addArc(ellipse, false, false);\n        const lengthX = (0.6 * radius);\n        const lengthY = lengthX / skew;\n        const normal = Vector3d.create();\n        ellipse.vector0.normalize(normal);\n        const pt1 = hit.snapPoint.plusScaled(normal, lengthX);\n        const pt2 = hit.snapPoint.plusScaled(normal, -lengthX);\n        builder.addLineString([pt1, pt2]);\n        ellipse.vector90.normalize(normal);\n        const pt3 = hit.snapPoint.plusScaled(normal, lengthY);\n        const pt4 = hit.snapPoint.plusScaled(normal, -lengthY);\n        builder.addLineString([pt3, pt4]);\n        context.addDecorationFromBuilder(builder);\n    }\n    /** @internal */\n    drawLocateCursor(context, viewPt, aperture, isLocateCircleOn, hit) {\n        if (hit)\n            ScreenViewport.drawLocateHitDetail(context, aperture, hit);\n        if (isLocateCircleOn) {\n            // draw a filled and outlined circle to represent the size of the location aperture in the current view.\n            const radius = Math.floor(aperture * 0.5) + 0.5;\n            const position = viewPt.clone();\n            position.x = Math.floor(position.x) + 0.5;\n            position.y = Math.floor(position.y) + 0.5;\n            const drawDecoration = (ctx) => {\n                ctx.beginPath();\n                ctx.strokeStyle = \"rgba(255,255,255,.4)\";\n                ctx.fillStyle = \"rgba(255,255,255,.2)\";\n                ctx.arc(0, 0, radius, 0, 2 * Math.PI);\n                ctx.fill();\n                ctx.stroke();\n                ctx.beginPath();\n                ctx.strokeStyle = \"rgba(0,0,0,.8)\";\n                ctx.lineWidth = 1;\n                ctx.arc(0, 0, radius + 1, 0, 2 * Math.PI);\n                ctx.stroke();\n            };\n            context.addCanvasDecoration({ position, drawDecoration }, true);\n        }\n    }\n    /** By default, a Viewport's webgl content is rendered to an off-screen canvas owned by the RenderSystem, then the resultant image is copied to the 2d rendering context\n     * belonging to the Viewport's own canvas. However, on non-chromium-based browsers this copying incurs a significant performance penalty. So, when only one Viewport\n     * needs to be drawn, we can switch to rendering the webgl content directly to the screen to improve performance in those browsers.\n     * ViewManager takes care of toggling this behavior.\n     * @internal\n     */\n    get rendersToScreen() { return undefined !== this._webglCanvas; }\n    set rendersToScreen(toScreen) {\n        if (toScreen === this.rendersToScreen)\n            return;\n        // Returns a webgl canvas if we're rendering webgl directly to the screen.\n        const webglCanvas = this.target.setRenderToScreen(toScreen);\n        if (undefined === webglCanvas) {\n            assert(undefined !== this._webglCanvas); // see getter...\n            this.vpDiv.removeChild(this._webglCanvas);\n            this._webglCanvas = undefined;\n        }\n        else {\n            assert(undefined === this._webglCanvas); // see getter...\n            this._webglCanvas = webglCanvas;\n            this.addChildDiv(this.vpDiv, webglCanvas, 5);\n            /** We really want this WebGL canvas' zIndex to be lower than this.canvas, but if we do that, browsers can decide to\n             * not update the WebGL canvas contents once it is re-added to the parent div after dropping other viewports.\n             * The offending element is the 2d canvas sitting on top of the WebGL canvas. We need to clear the 2d canvas' contents\n             * in order to ensure browsers allow the underlying WebGL canvas to update. If a decorator is present, the 2d canvas\n             * is cleared during the frame render process by virtue of updating the decorator. For the non-decorator case, and for\n             * iOS, we must make sure we still clear the 2d canvas, done here. iOS appears to need this clear even when decorators\n             * clear the canvas later in the frame render process.\n             */\n            _clear2dCanvas(this.canvas);\n        }\n        const resized = this.target.updateViewRect();\n        if (resized) {\n            this.target.onResized();\n            this.invalidateController();\n        }\n        this.invalidateRenderPlan();\n    }\n    /** Overrides [[Viewport.waitForSceneCompletion]] to allow the render loop to load graphics until the scene is complete. */\n    async waitForSceneCompletion() {\n        if (!IModelApp.viewManager.hasViewport(this))\n            return super.waitForSceneCompletion();\n        const system = this.target.renderSystem;\n        // Let the ViewManager/TileAdmin initiate all further requests for tiles until no more requests are pending.\n        // We will latch onto the onRender event in order to know when tile requests are finished and the promise is fulfilled.\n        const promise = new Promise((resolve, _reject) => {\n            const removeOnRender = this.onRender.addListener(() => {\n                const removeOnViewClose = IModelApp.viewManager.onViewClose.addListener((vp) => {\n                    if (vp === this) {\n                        removeOnViewClose();\n                        removeOnRender();\n                        resolve();\n                        return;\n                    }\n                });\n                if (this.isDisposed) {\n                    removeOnViewClose();\n                    removeOnRender();\n                    resolve();\n                    return;\n                }\n                let haveNewTiles = !this.areAllTileTreesLoaded || this._hasMissingTiles;\n                if (!haveNewTiles)\n                    haveNewTiles = this.hasAdditionalTiles();\n                if (!haveNewTiles && !system.hasExternalTextureRequests) {\n                    removeOnViewClose();\n                    removeOnRender();\n                    resolve();\n                    return;\n                }\n            });\n        });\n        // Must first wait to ensure all tile trees are loaded -- tile requests will not happen before then; it may look like we have no requests pending, but in reality no requests even began.\n        while (!this.areAllTileTreesLoaded) {\n            await BeDuration.wait(100);\n        }\n        // After all tile trees have loaded, kick off an initial request for tiles.\n        this.invalidateScene();\n        this.renderFrame();\n        return promise;\n    }\n}\n/** Settings that may be adjusted to control the way animations are applied to a [[ScreenViewport]] by methods like\n * [[changeView]] and [[synchWithView].\n */\nScreenViewport.animation = {\n    /** Duration of animations of viewing operations. */\n    time: {\n        fast: BeDuration.fromSeconds(.5),\n        normal: BeDuration.fromSeconds(1.0),\n        slow: BeDuration.fromSeconds(1.25),\n        /** Duration used when zooming with the mouse wheel. */\n        wheel: BeDuration.fromSeconds(.5),\n    },\n    /** The easing function to use for view animations. */\n    easing: Easing.Cubic.Out,\n    /** Pertains to view transitions that move far distances, but maintain the same view direction.\n     * In that case we zoom out, move the camera, and zoom back in rather than transitioning linearly to\n     * provide context for the starting and ending positions. These settings control how and when that happens.\n     */\n    zoomOut: {\n        /** Whether to allow zooming out. If you don't want it, set this to false. */\n        enable: true,\n        /** The interpolation function used for camera height and position over the zoomOut operation. */\n        interpolation: Interpolation.Bezier,\n        /** Array of fractional height the camera rises over the animation. Height is interpolated over the array during the duration of the zoom operation.\n         * At 1.0 it will be high enough that both are visible if the camera were centered between then.\n         * Must start and end at 0.\n         */\n        heights: [0, 1.5, 2.0, 1.8, 1.5, 1.2, 1, 0],\n        /** Array of fractional positions of the camera from starting to ending location when zooming.\n         * Position is interpolated from the array using the interpolation function over the duration of the zoom operation (see tween.ts)\n         * Must start at 0 and end at 1.\n         */\n        positions: [0, 0, .1, .3, .5, .8, 1],\n        /** Zoom out/in only if the beginning and ending view's range, each expanded by this factor, overlap. */\n        margin: 2.5,\n        /** Multiply the duration of the animation by this factor when performing a zoom out. */\n        durationFactor: 1.5,\n    },\n};\nexport { ScreenViewport };\nfunction _clear2dCanvas(canvas) {\n    const ctx = canvas.getContext(\"2d\", { alpha: true });\n    ctx.save();\n    ctx.setTransform(1, 0, 0, 1, 0, 0); // revert any previous devicePixelRatio scale for clearRect() call below.\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.restore();\n}\n/** A viewport that draws to an offscreen buffer instead of to the screen. An offscreen viewport is never added to the [[ViewManager]], therefore does not participate in\n * the render loop. Its dimensions are specified directly instead of being derived from an HTMLCanvasElement, and its renderFrame function must be manually invoked.\n * Offscreen viewports can be useful for, e.g., producing an image from the contents of a view (see [[Viewport.readImageBuffer]] and [[Viewport.readImageToCanvas]])\n * without drawing to the screen.\n * @see [[OffScreenViewport.create]] to create an off-screen viewport.\n * @public\n * @extensions\n */\nexport class OffScreenViewport extends Viewport {\n    /** @internal */\n    constructor(target) {\n        super(target);\n        this._isAspectRatioLocked = false;\n    }\n    /** A bit of a hack to work around our ill-advised decision to always expect a RenderClipVolume to be defined in world coordinates.\n     * When we attach a section drawing to a sheet view, and the section drawing has a spatial view attached to *it*, the spatial view's clip\n     * is transformed into drawing space - but when we display it we need to transform it into world (sheet) coordinates.\n     * Fixing the actual problem (clips should always be defined in the coordinate space of the graphic branch containing them) would be quite error-prone\n     * and likely to break existing code -- so instead the SheetViewState specifies this transform to be consumed by DrawingViewState.attachToViewport.\n     * @internal\n     */\n    get drawingToSheetTransform() {\n        return this._drawingToSheetTransform;\n    }\n    set drawingToSheetTransform(transform) {\n        this.detachFromView();\n        this._drawingToSheetTransform = transform;\n        this.attachToView();\n    }\n    static create(options) {\n        return this.createViewport(options.view, IModelApp.renderSystem.createOffscreenTarget(options.viewRect), options.lockAspectRatio);\n    }\n    /** @internal because RenderTarget is internal */\n    static createViewport(view, target, lockAspectRatio = false) {\n        const vp = new this(target);\n        vp._isAspectRatioLocked = lockAspectRatio;\n        vp.changeView(view);\n        vp._decorationsValid = true;\n        vp.initialize();\n        return vp;\n    }\n    /** @internal */\n    get isAspectRatioLocked() {\n        return this._isAspectRatioLocked;\n    }\n    /** Get the rectangle of this Viewport in [[CoordSystem.View]] coordinates.\n     * @note Do not modify the ViewRect's properties.\n     */\n    get viewRect() {\n        return this.target.viewRect;\n    }\n    /** Change the dimensions of the viewport. */\n    setRect(rect) {\n        this.target.setViewRect(rect, false);\n        this.changeView(this.view);\n    }\n}\n//# sourceMappingURL=Viewport.js.map",
      "start": 1693508119580,
      "end": 1693508119743,
      "sourcemaps": null
    }
  ]
}
