{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/orbitgt/lib/esm/spatial/ecrs/transformation/PositionVector.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module OrbitGT\n */\nimport { OperationMethod } from \"../OperationMethod\";\nimport { ParameterValue } from \"../ParameterValue\";\nimport { ParameterValueList } from \"../ParameterValueList\";\n/**\n * Class PositionVector defines a Position Vector 7-parameter transformation (see Guidance Note 2.4.3.2.1).\n *\n * NOTE: this method is also known as \"Bursa-Wolf\".\n *\n * Based on the following document:\n *\n * Coordinate Conversions and Transformations including Formulas\n * Guidance Note Number 7, part 2\n * Revised May 2005\n * Available at: http://www.epsg.org/\n *\n * Used in Europe. To convert to \"Coordinate Frame Rotation\" inverse the sign of the three rotations.\n *\n * @version 1.0 July 2005\n */\n/** @internal */\nclass PositionVector extends OperationMethod {\n    /**\n     * Create a new transformation.\n     * @param parameters the values of the parameters.\n     */\n    constructor(parameters) {\n        super(PositionVector.METHOD_CODE, \"Position Vector 7-param. transformation\", parameters);\n        /* Store the parameters */\n        this._dX = parameters.getValue(8605);\n        this._dY = parameters.getValue(8606);\n        this._dZ = parameters.getValue(8607);\n        this._rX = parameters.getValue(8608);\n        this._rY = parameters.getValue(8609);\n        this._rZ = parameters.getValue(8610);\n        this._dS = parameters.getValue(8611);\n    }\n    /**\n     * Create a new transformation.\n     * @param dX the translation vector x.\n     * @param dY the translation vector y.\n     * @param dZ the translation vector z.\n     * @param rX the first rotation (radians).\n     * @param rY the second rotation (radians).\n     * @param rZ the third rotation (radians).\n     * @param dS the scale factor (offset from 1.0) (normal units, not ppm).\n     * @return the new transformation.\n     */\n    static create(dX, dY, dZ, rX, rY, rZ, dS) {\n        let parameters = new ParameterValueList();\n        parameters.add(new ParameterValue(8605, dX, null));\n        parameters.add(new ParameterValue(8606, dY, null));\n        parameters.add(new ParameterValue(8607, dZ, null));\n        parameters.add(new ParameterValue(8608, rX, null));\n        parameters.add(new ParameterValue(8609, rY, null));\n        parameters.add(new ParameterValue(8610, rZ, null));\n        parameters.add(new ParameterValue(8611, dS, null));\n        return new PositionVector(parameters);\n    }\n    /**\n     * Get the 7 parameters of the method.\n     * @return the parameters of the method {dX,dY,dZ,rX,rY,rZ,dS} in units {meter,meter,meter, radian,radian,radian, scale_offset-1}.\n     */\n    getParameters() {\n        let parameters = new Float64Array(7);\n        parameters[0] = this._dX;\n        parameters[1] = this._dY;\n        parameters[2] = this._dZ;\n        parameters[3] = this._rX;\n        parameters[4] = this._rY;\n        parameters[5] = this._rZ;\n        parameters[6] = this._dS;\n        return parameters;\n    }\n    /**\n     * Make a forward transformation.\n     * @param source the source coordinate (the coordinate to transform).\n     * @param target the target coordinate (holds the result).\n     */\n    transformForward(source, target) {\n        let x = source.getX();\n        let y = source.getY();\n        let z = source.getZ();\n        let m = (1.0 + this._dS);\n        target.setX(m * (1.0 * x - this._rZ * y + this._rY * z) + this._dX);\n        target.setY(m * (this._rZ * x + 1.0 * y - this._rX * z) + this._dY);\n        target.setZ(m * (-this._rY * x + this._rX * y + 1.0 * z) + this._dZ);\n    }\n    /**\n     * Make a reverse transformation.\n     * @param source the source coordinate (holds the result).\n     * @param target the target coordinate (the coordinate to transform).\n     */\n    transformReverse(source, target) {\n        this.createInverse().transformForward(target, source);\n    }\n    /**\n     * OperationMethod interface method.\n     * @see OperationMethod#forward\n     */\n    forward(sourceCRS, source, targetCRS, target) {\n        this.transformForward(source, target);\n    }\n    /**\n     * OperationMethod interface method.\n     * @see OperationMethod#reverse\n     */\n    reverse(sourceCRS, source, targetCRS, target) {\n        this.transformReverse(source, target);\n    }\n    /**\n     * Create an inverse transformation.\n     * @return the inverse transformation.\n     */\n    createInverse() {\n        return PositionVector.create(-this._dX, -this._dY, -this._dZ, -this._rX, -this._rY, -this._rZ, -this._dS);\n    }\n}\n/** The code of this method */\nPositionVector.METHOD_CODE = 9606;\nexport { PositionVector };\n//# sourceMappingURL=PositionVector.js.map",
      "start": 1693508127380,
      "end": 1693508127457,
      "sourcemaps": null
    }
  ]
}
