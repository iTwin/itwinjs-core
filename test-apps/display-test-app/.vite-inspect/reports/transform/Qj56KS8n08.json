{
  "resolvedId": "D:/hub2023A/itwinjs-core/test-apps/display-test-app/src/frontend/BingTerrainProvider.ts",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\r\n* See LICENSE.md in the project root for license terms and full copyright notice.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\nimport { assert, Uint16ArrayBuilder } from \"@itwin/core-bentley\";\r\nimport { Point2d, Point3d, Range1d, Vector3d } from \"@itwin/core-geometry\";\r\nimport { OctEncodedNormal } from \"@itwin/core-common\";\r\nimport {\r\n  BingElevationProvider, GeographicTilingScheme, IModelApp, MapTileProjection, ReadMeshArgs, RealityMeshParams, RealityMeshParamsBuilder,\r\n  RealityMeshParamsBuilderOptions, RequestMeshDataArgs, TerrainMeshProvider, TerrainMeshProviderOptions, TerrainProvider,\r\n} from \"@itwin/core-frontend\";\r\n\r\n// The number of elevation values per row/column within each tile.\r\nconst size = 16;\r\n// The number of quads per row/column within each tile.\r\nconst sizeM1 = size - 1;\r\n\r\n/** An example TerrainMeshProvider that obtains elevation data from [Bing](https://docs.microsoft.com/en-us/bingmaps/rest-services/elevations/get-elevations).\r\n * This example is not intended for production use. Its primary purpose is to present a clear example of how to implement a custom TerrainMeshProvider.\r\n * The code is written to favor readability over efficiency.\r\n * The 3d terrain produced is less accurate than that available from services like [Cesium World Terrain](https://cesium.com/platform/cesium-ion/content/cesium-world-terrain/).\r\n * This provider requires a valid Bing Maps API key to be supplied via `IModelAppOptions.mapLayerOptions.BingMaps` to `IModelApp.startup`.\r\n *\r\n * For each tile, the provider obtains a 16x16 equally-spaced grid of elevation values. Each group of four adjacent elevations is converted into pair\r\n * of triangles (a quad).\r\n */\r\nexport class BingTerrainMeshProvider extends TerrainMeshProvider {\r\n  /** Provides elevation data. */\r\n  private readonly _provider: BingElevationProvider;\r\n  /** Scale factor applied to elevations, from `TerrainSettings.exaggeration`. */\r\n  private readonly _exaggeration: number;\r\n  /** If true, generate per-vertex normal vectors. */\r\n  private readonly _wantNormals: boolean;\r\n  /** If true, generate skirts around the edges of each tile. */\r\n  private readonly _wantSkirts: boolean;\r\n  public readonly tilingScheme = new GeographicTilingScheme(1, 1);\r\n\r\n  public constructor(options: TerrainMeshProviderOptions) {\r\n    super();\r\n    this._provider = new BingElevationProvider();\r\n    this._exaggeration = options.exaggeration;\r\n    this._wantNormals = options.wantNormals;\r\n    this._wantSkirts = options.wantSkirts;\r\n  }\r\n\r\n  /** Return elevation values in a 16x16 grid. */\r\n  public override async requestMeshData(args: RequestMeshDataArgs): Promise<number[] | undefined> {\r\n    const latLongRange = args.tile.quadId.getLatLongRangeDegrees(this.tilingScheme);\r\n\r\n    // Latitudes outside the range [-85, 85] produce HTTP 400 per the Bing API docs - clamp to that range.\r\n    latLongRange.low.y = Math.max(-85, latLongRange.low.y);\r\n    latLongRange.high.y = Math.min(85, latLongRange.high.y);\r\n\r\n    // Longitudes outside the range [0, 180) produce HTTP 500. Bing API docs don't mention this, but it seems like\r\n    // it would be a client error (400), not server error (500).\r\n    // Wrap them.\r\n    if (latLongRange.high.x >= 180)\r\n      latLongRange.high.x = latLongRange.high.x - 360;\r\n\r\n    const heights = await this._provider.getHeights(latLongRange);\r\n    return heights?.length === 16 * 16 ? heights : undefined;\r\n  }\r\n\r\n  /** Produce a 3d terrain mesh from the elevation values obtained by `requestMeshData`. */\r\n  public override async readMesh(args: ReadMeshArgs): Promise<RealityMeshParams | undefined> {\r\n    const heights = args.data as number[];\r\n    assert(heights.length === size * size);\r\n\r\n    // Make skirts 1/20th the width of the tile.\r\n    const skirtHeight = this._wantSkirts ? args.tile.range.xLength() / 20 : 0;\r\n\r\n    // Determine the minimum and maximum height values, scaled by the terrain exaggeration factor.\r\n    const heightRange = Range1d.createArray(heights);\r\n    heightRange.low -= skirtHeight;\r\n    heightRange.low *= this._exaggeration;\r\n    heightRange.high *= this._exaggeration;\r\n\r\n    // Update the height range stored on the MapTile.\r\n    args.tile.adjustHeights(heightRange.low, heightRange.high);\r\n\r\n    // Skirts add 16 new vertices along each edge.\r\n    const numSkirtVertices = this._wantSkirts ? size * 4 : 0;\r\n    // Skirts add 15 new quads along each edge.\r\n    const numSkirtIndices = this._wantSkirts ? sizeM1 * sizeM1 * 4 * 3 * 2 : 0;\r\n\r\n    // Given a 2d point in tile coordinates and an elevation, the projection can produce a 3d point in space.\r\n    const projection = args.tile.getProjection(heightRange);\r\n\r\n    // Options for creating the terrain mesh.\r\n    const initialVertexCapacity = size * size + numSkirtVertices;\r\n    const options: RealityMeshParamsBuilderOptions = {\r\n      // A range encompassing all possible 3d points in the mesh.\r\n      positionRange: projection.localRange,\r\n      // The exact number of vertices we will need - preallocated to avoid reallocating as we populate the array.\r\n      initialVertexCapacity,\r\n      // The exact number of vertex indices we will need - preallocated to avoid reallocating as we populate the array.\r\n      initialIndexCapacity: sizeM1 * sizeM1 * 3 * 2 + numSkirtIndices,\r\n      // We will compute the normals after computing the positions, if needed.\r\n      wantNormals: false,\r\n    };\r\n\r\n    const builder = new RealityMeshParamsBuilder(options);\r\n\r\n    // Holds the texture coordinates for the current vertex.\r\n    const uv = new Point2d();\r\n    // Holds the 3d position of the current vertex.\r\n    const position = new Point3d();\r\n\r\n    // For each elevation in the grid, add a vertex to the builder.\r\n    const delta = 1 / sizeM1;\r\n    for (let row = 0, v = 0; row < size; row++, v += delta) {\r\n      for (let col = 0, u = 0; col < size; col++, u += delta) {\r\n        const height = heights[(sizeM1 - row) * size + col];\r\n        projection.getPoint(u, 1 - v, height * this._exaggeration, position);\r\n        uv.set(u, 1 - v);\r\n        builder.addUnquantizedVertex(position, uv);\r\n      }\r\n    }\r\n\r\n    if (this._wantNormals)\r\n      this.addNormals(builder, initialVertexCapacity);\r\n\r\n    // Define the triangles for each quad.\r\n    for (let row = 0; row < sizeM1; row++) {\r\n      const rowIndex = row * size;\r\n      const nextRowIndex = rowIndex + size;\r\n      for (let col = 0; col < sizeM1; col++) {\r\n        const q0 = rowIndex + col;\r\n        const q1 = q0 + 1;\r\n        const q3 = nextRowIndex + col;\r\n        const q2 = q3 + 1;\r\n\r\n        builder.addTriangle(q0, q1, q2);\r\n        builder.addTriangle(q0, q2, q3);\r\n      }\r\n    }\r\n\r\n    if (this._wantSkirts)\r\n      this.addSkirts(builder, heights, skirtHeight, projection);\r\n\r\n    assert(builder.positions.length === options.initialVertexCapacity);\r\n    assert(builder.uvs.length === options.initialVertexCapacity);\r\n    assert(undefined === builder.normals || builder.normals.capacity === options.initialVertexCapacity);\r\n    assert(builder.positions.length === builder.uvs.length);\r\n    assert(undefined === builder.normals || builder.normals.length === builder.positions.length);\r\n    assert(builder.indices.capacity === options.initialIndexCapacity);\r\n\r\n    // Extract the completed 3d mesh.\r\n    return builder.finish();\r\n  }\r\n\r\n  // Compute a normal vector for each vertex.\r\n  private addNormals(builder: RealityMeshParamsBuilder, numVertices: number): void {\r\n    const scratchP0 = new Point3d();\r\n    const scratchP1 = new Point3d();\r\n    const scratchP2 = new Point3d();\r\n    const scratchFaceNormal = new Vector3d();\r\n\r\n    // Compute the vector perpendicular to one triangle, and add it to the accumulated vertex normal.\r\n    // sum: The accumulated vertex normal thus far.\r\n    // p0: The position of the vertex whose normal vector is being computed.\r\n    // r1, c1: The (x, y) offset of the second triangle vertex, relative to p0 - either 0, -1, or 1.\r\n    // r2, c2: The (x, y) offset of the third triangle vertex, relative to p0 - either 0, -1, or 1.\r\n    const addNormal = (sum: Vector3d, p0: Point3d, r1: number, c1: number, r2: number, c2: number): void => {\r\n      if (r1 < 0 || c1 < 0 || r2 < 0 || c2 < 0 || r1 >= size || c1 >= size || r2 >= size || c2 >= size) {\r\n        // At least one of the adjacent points is outside the boundaries of the tile. We have no elevation data for points outside the tile.\r\n        // Note: to properly compute normals for vertices on the edges of the tile, requestMeshData would need to request additional elevations\r\n        // for points adjacent to the tile. For simplicity, we simply ignore their contribution to the vertex normal.\r\n        return;\r\n      }\r\n\r\n      // Look up the positions of the other two triangle vertices.\r\n      const p1 = builder.positions.unquantize(r1 * size + c1, scratchP1);\r\n      const p2 = builder.positions.unquantize(r2 * size + c2, scratchP2);\r\n\r\n      // Compute the normalized vector perpendicular to the triangle.\r\n      const faceNormal = Vector3d.createCrossProductToPoints(p0, p1, p2, scratchFaceNormal);\r\n      faceNormal.normalizeInPlace();\r\n\r\n      // Add this triangle's normal vector to the vertex normal.\r\n      sum.plus(faceNormal, sum);\r\n      sum.normalizeInPlace();\r\n    };\r\n\r\n    // Allocate all of the normal vectors we need.\r\n    builder.normals = new Uint16ArrayBuilder({ initialCapacity: numVertices });\r\n\r\n    // Compute the normal vector for each vertex in the mesh.\r\n    const vertexNormal = Vector3d.createZero();\r\n    for (let row = 0; row < size; row++) {\r\n      for (let col = 0; col < size; col++) {\r\n        Vector3d.createZero(vertexNormal);\r\n        const p0 = builder.positions.unquantize(row * size + col, scratchP0);\r\n        // This could be made more efficient with a loop that retains the output of the previous iteration,\r\n        // but less readable.\r\n        addNormal(vertexNormal, p0, row+0, col+1, row+1, col+1);\r\n        addNormal(vertexNormal, p0, row+1, col+1, row+1, col+0);\r\n        addNormal(vertexNormal, p0, row+1, col+0, row+1, col-1);\r\n        addNormal(vertexNormal, p0, row+1, col-1, row+0, col-1);\r\n        addNormal(vertexNormal, p0, row+0, col-1, row-1, col-1);\r\n        addNormal(vertexNormal, p0, row-1, col-1, row-1, col+0);\r\n        addNormal(vertexNormal, p0, row-1, col+0, row-1, col+1);\r\n        addNormal(vertexNormal, p0, row-1, col+1, row+0, col+1);\r\n\r\n        vertexNormal.normalizeInPlace();\r\n        builder.normals.push(OctEncodedNormal.encode(vertexNormal));\r\n      }\r\n    }\r\n  }\r\n\r\n  // Generate \"skirts\" around the edge of the mesh, hanging straight down from the existing triangles.\r\n  // Note: if we angled the skirts outward slightly, they would do a better job of hiding seams, particularly when\r\n  // looking directly down at the map.\r\n  private addSkirts(builder: RealityMeshParamsBuilder, heights: number[], skirtHeight: number, projection: MapTileProjection): void {\r\n    // The normal vector for the skirt vertices does not matter - use a zero vector.\r\n    const skirtNormal = this._wantNormals ? new Vector3d() : undefined;\r\n    const uv = new Point2d();\r\n    const position = new Point3d();\r\n    const delta = 1 / sizeM1;\r\n\r\n    for (let c = 0; c < size; c++) {\r\n      // top row\r\n      let height = heights[sizeM1 * size + c];\r\n      const u = c * delta;\r\n      projection.getPoint(u, 1, (height - skirtHeight) * this._exaggeration, position);\r\n      uv.set(u, 1);\r\n      const topIndex = builder.addUnquantizedVertex(position, uv, skirtNormal);\r\n\r\n      // bottom row\r\n      height = heights[c];\r\n      projection.getPoint(u, 0, (height - skirtHeight) * this._exaggeration, position);\r\n      uv.set(u, 0);\r\n      const bottomIndex = builder.addUnquantizedVertex(position, uv, skirtNormal);\r\n\r\n      // left side\r\n      height = heights[(sizeM1 - c) * size];\r\n      projection.getPoint(0, 1 - u, (height - skirtHeight) * this._exaggeration, position);\r\n      uv.set(0, 1 - u);\r\n      const leftIndex = builder.addUnquantizedVertex(position, uv, skirtNormal);\r\n\r\n      // right side\r\n      height = heights[(sizeM1 - c) * size + sizeM1];\r\n      projection.getPoint(1, 1 - u, (height - skirtHeight) * this._exaggeration, position);\r\n      uv.set(1, 1 - u);\r\n      const rightIndex = builder.addUnquantizedVertex(position, uv, skirtNormal);\r\n\r\n      if (c === sizeM1) {\r\n        // We have added all 16 vertices and all 15 quads along each edge\r\n        break;\r\n      }\r\n\r\n      // top row\r\n      builder.addTriangle(c, c + 1, topIndex + 4);\r\n      builder.addTriangle(c, topIndex + 4, topIndex);\r\n\r\n      // bottom row\r\n      const row = size * sizeM1;\r\n      builder.addTriangle(row + c, row + c + 1, bottomIndex + 4);\r\n      builder.addTriangle(row + c, bottomIndex + 4, bottomIndex);\r\n\r\n      // left side\r\n      const left = c * size;\r\n      builder.addTriangle(left, left + size, leftIndex + 4);\r\n      builder.addTriangle(left, leftIndex + 4, leftIndex);\r\n\r\n      // right side\r\n      const right = c * size + sizeM1;\r\n      builder.addTriangle(right, right +size, rightIndex + 4);\r\n      builder.addTriangle(right, rightIndex + 4, rightIndex);\r\n    }\r\n  }\r\n\r\n  public override get maxDepth(): number {\r\n    return 22;\r\n  }\r\n\r\n  // Register the terrain provider, just after calling `IModelApp.startup`\r\n  public static register(): void {\r\n    // The name of our provider. It must be unique! It will be stored in `TerrainSettings.providerName`.\r\n    const providerName = \"DtaBingTerrain\";\r\n\r\n    // Our provider.\r\n    const provider: TerrainProvider = {\r\n      createTerrainMeshProvider: async (options: TerrainMeshProviderOptions) => {\r\n        return Promise.resolve(new BingTerrainMeshProvider(options));\r\n      },\r\n    };\r\n\r\n    IModelApp.terrainProviderRegistry.register(providerName, provider);\r\n  }\r\n}\r\n",
      "start": 1693508121255,
      "end": 1693508121324,
      "sourcemaps": null
    },
    {
      "name": "vite:esbuild",
      "result": "\"use strict\";\nimport { assert, Uint16ArrayBuilder } from \"@itwin/core-bentley\";\nimport { Point2d, Point3d, Range1d, Vector3d } from \"@itwin/core-geometry\";\nimport { OctEncodedNormal } from \"@itwin/core-common\";\nimport {\n  BingElevationProvider,\n  GeographicTilingScheme,\n  IModelApp,\n  RealityMeshParamsBuilder,\n  TerrainMeshProvider\n} from \"@itwin/core-frontend\";\nconst size = 16;\nconst sizeM1 = size - 1;\nexport class BingTerrainMeshProvider extends TerrainMeshProvider {\n  constructor(options) {\n    super();\n    this.tilingScheme = new GeographicTilingScheme(1, 1);\n    this._provider = new BingElevationProvider();\n    this._exaggeration = options.exaggeration;\n    this._wantNormals = options.wantNormals;\n    this._wantSkirts = options.wantSkirts;\n  }\n  /** Return elevation values in a 16x16 grid. */\n  async requestMeshData(args) {\n    const latLongRange = args.tile.quadId.getLatLongRangeDegrees(this.tilingScheme);\n    latLongRange.low.y = Math.max(-85, latLongRange.low.y);\n    latLongRange.high.y = Math.min(85, latLongRange.high.y);\n    if (latLongRange.high.x >= 180)\n      latLongRange.high.x = latLongRange.high.x - 360;\n    const heights = await this._provider.getHeights(latLongRange);\n    return heights?.length === 16 * 16 ? heights : void 0;\n  }\n  /** Produce a 3d terrain mesh from the elevation values obtained by `requestMeshData`. */\n  async readMesh(args) {\n    const heights = args.data;\n    assert(heights.length === size * size);\n    const skirtHeight = this._wantSkirts ? args.tile.range.xLength() / 20 : 0;\n    const heightRange = Range1d.createArray(heights);\n    heightRange.low -= skirtHeight;\n    heightRange.low *= this._exaggeration;\n    heightRange.high *= this._exaggeration;\n    args.tile.adjustHeights(heightRange.low, heightRange.high);\n    const numSkirtVertices = this._wantSkirts ? size * 4 : 0;\n    const numSkirtIndices = this._wantSkirts ? sizeM1 * sizeM1 * 4 * 3 * 2 : 0;\n    const projection = args.tile.getProjection(heightRange);\n    const initialVertexCapacity = size * size + numSkirtVertices;\n    const options = {\n      // A range encompassing all possible 3d points in the mesh.\n      positionRange: projection.localRange,\n      // The exact number of vertices we will need - preallocated to avoid reallocating as we populate the array.\n      initialVertexCapacity,\n      // The exact number of vertex indices we will need - preallocated to avoid reallocating as we populate the array.\n      initialIndexCapacity: sizeM1 * sizeM1 * 3 * 2 + numSkirtIndices,\n      // We will compute the normals after computing the positions, if needed.\n      wantNormals: false\n    };\n    const builder = new RealityMeshParamsBuilder(options);\n    const uv = new Point2d();\n    const position = new Point3d();\n    const delta = 1 / sizeM1;\n    for (let row = 0, v = 0; row < size; row++, v += delta) {\n      for (let col = 0, u = 0; col < size; col++, u += delta) {\n        const height = heights[(sizeM1 - row) * size + col];\n        projection.getPoint(u, 1 - v, height * this._exaggeration, position);\n        uv.set(u, 1 - v);\n        builder.addUnquantizedVertex(position, uv);\n      }\n    }\n    if (this._wantNormals)\n      this.addNormals(builder, initialVertexCapacity);\n    for (let row = 0; row < sizeM1; row++) {\n      const rowIndex = row * size;\n      const nextRowIndex = rowIndex + size;\n      for (let col = 0; col < sizeM1; col++) {\n        const q0 = rowIndex + col;\n        const q1 = q0 + 1;\n        const q3 = nextRowIndex + col;\n        const q2 = q3 + 1;\n        builder.addTriangle(q0, q1, q2);\n        builder.addTriangle(q0, q2, q3);\n      }\n    }\n    if (this._wantSkirts)\n      this.addSkirts(builder, heights, skirtHeight, projection);\n    assert(builder.positions.length === options.initialVertexCapacity);\n    assert(builder.uvs.length === options.initialVertexCapacity);\n    assert(void 0 === builder.normals || builder.normals.capacity === options.initialVertexCapacity);\n    assert(builder.positions.length === builder.uvs.length);\n    assert(void 0 === builder.normals || builder.normals.length === builder.positions.length);\n    assert(builder.indices.capacity === options.initialIndexCapacity);\n    return builder.finish();\n  }\n  // Compute a normal vector for each vertex.\n  addNormals(builder, numVertices) {\n    const scratchP0 = new Point3d();\n    const scratchP1 = new Point3d();\n    const scratchP2 = new Point3d();\n    const scratchFaceNormal = new Vector3d();\n    const addNormal = (sum, p0, r1, c1, r2, c2) => {\n      if (r1 < 0 || c1 < 0 || r2 < 0 || c2 < 0 || r1 >= size || c1 >= size || r2 >= size || c2 >= size) {\n        return;\n      }\n      const p1 = builder.positions.unquantize(r1 * size + c1, scratchP1);\n      const p2 = builder.positions.unquantize(r2 * size + c2, scratchP2);\n      const faceNormal = Vector3d.createCrossProductToPoints(p0, p1, p2, scratchFaceNormal);\n      faceNormal.normalizeInPlace();\n      sum.plus(faceNormal, sum);\n      sum.normalizeInPlace();\n    };\n    builder.normals = new Uint16ArrayBuilder({ initialCapacity: numVertices });\n    const vertexNormal = Vector3d.createZero();\n    for (let row = 0; row < size; row++) {\n      for (let col = 0; col < size; col++) {\n        Vector3d.createZero(vertexNormal);\n        const p0 = builder.positions.unquantize(row * size + col, scratchP0);\n        addNormal(vertexNormal, p0, row + 0, col + 1, row + 1, col + 1);\n        addNormal(vertexNormal, p0, row + 1, col + 1, row + 1, col + 0);\n        addNormal(vertexNormal, p0, row + 1, col + 0, row + 1, col - 1);\n        addNormal(vertexNormal, p0, row + 1, col - 1, row + 0, col - 1);\n        addNormal(vertexNormal, p0, row + 0, col - 1, row - 1, col - 1);\n        addNormal(vertexNormal, p0, row - 1, col - 1, row - 1, col + 0);\n        addNormal(vertexNormal, p0, row - 1, col + 0, row - 1, col + 1);\n        addNormal(vertexNormal, p0, row - 1, col + 1, row + 0, col + 1);\n        vertexNormal.normalizeInPlace();\n        builder.normals.push(OctEncodedNormal.encode(vertexNormal));\n      }\n    }\n  }\n  // Generate \"skirts\" around the edge of the mesh, hanging straight down from the existing triangles.\n  // Note: if we angled the skirts outward slightly, they would do a better job of hiding seams, particularly when\n  // looking directly down at the map.\n  addSkirts(builder, heights, skirtHeight, projection) {\n    const skirtNormal = this._wantNormals ? new Vector3d() : void 0;\n    const uv = new Point2d();\n    const position = new Point3d();\n    const delta = 1 / sizeM1;\n    for (let c = 0; c < size; c++) {\n      let height = heights[sizeM1 * size + c];\n      const u = c * delta;\n      projection.getPoint(u, 1, (height - skirtHeight) * this._exaggeration, position);\n      uv.set(u, 1);\n      const topIndex = builder.addUnquantizedVertex(position, uv, skirtNormal);\n      height = heights[c];\n      projection.getPoint(u, 0, (height - skirtHeight) * this._exaggeration, position);\n      uv.set(u, 0);\n      const bottomIndex = builder.addUnquantizedVertex(position, uv, skirtNormal);\n      height = heights[(sizeM1 - c) * size];\n      projection.getPoint(0, 1 - u, (height - skirtHeight) * this._exaggeration, position);\n      uv.set(0, 1 - u);\n      const leftIndex = builder.addUnquantizedVertex(position, uv, skirtNormal);\n      height = heights[(sizeM1 - c) * size + sizeM1];\n      projection.getPoint(1, 1 - u, (height - skirtHeight) * this._exaggeration, position);\n      uv.set(1, 1 - u);\n      const rightIndex = builder.addUnquantizedVertex(position, uv, skirtNormal);\n      if (c === sizeM1) {\n        break;\n      }\n      builder.addTriangle(c, c + 1, topIndex + 4);\n      builder.addTriangle(c, topIndex + 4, topIndex);\n      const row = size * sizeM1;\n      builder.addTriangle(row + c, row + c + 1, bottomIndex + 4);\n      builder.addTriangle(row + c, bottomIndex + 4, bottomIndex);\n      const left = c * size;\n      builder.addTriangle(left, left + size, leftIndex + 4);\n      builder.addTriangle(left, leftIndex + 4, leftIndex);\n      const right = c * size + sizeM1;\n      builder.addTriangle(right, right + size, rightIndex + 4);\n      builder.addTriangle(right, rightIndex + 4, rightIndex);\n    }\n  }\n  get maxDepth() {\n    return 22;\n  }\n  // Register the terrain provider, just after calling `IModelApp.startup`\n  static register() {\n    const providerName = \"DtaBingTerrain\";\n    const provider = {\n      createTerrainMeshProvider: async (options) => {\n        return Promise.resolve(new BingTerrainMeshProvider(options));\n      }\n    };\n    IModelApp.terrainProviderRegistry.register(providerName, provider);\n  }\n}\n",
      "start": 1693508121324,
      "end": 1693508121653,
      "order": "normal",
      "sourcemaps": {
        "version": 3,
        "sources": [
          "D:/hub2023A/itwinjs-core/test-apps/display-test-app/src/frontend/BingTerrainProvider.ts"
        ],
        "sourcesContent": [
          "/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\r\n* See LICENSE.md in the project root for license terms and full copyright notice.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\nimport { assert, Uint16ArrayBuilder } from \"@itwin/core-bentley\";\r\nimport { Point2d, Point3d, Range1d, Vector3d } from \"@itwin/core-geometry\";\r\nimport { OctEncodedNormal } from \"@itwin/core-common\";\r\nimport {\r\n  BingElevationProvider, GeographicTilingScheme, IModelApp, MapTileProjection, ReadMeshArgs, RealityMeshParams, RealityMeshParamsBuilder,\r\n  RealityMeshParamsBuilderOptions, RequestMeshDataArgs, TerrainMeshProvider, TerrainMeshProviderOptions, TerrainProvider,\r\n} from \"@itwin/core-frontend\";\r\n\r\n// The number of elevation values per row/column within each tile.\r\nconst size = 16;\r\n// The number of quads per row/column within each tile.\r\nconst sizeM1 = size - 1;\r\n\r\n/** An example TerrainMeshProvider that obtains elevation data from [Bing](https://docs.microsoft.com/en-us/bingmaps/rest-services/elevations/get-elevations).\r\n * This example is not intended for production use. Its primary purpose is to present a clear example of how to implement a custom TerrainMeshProvider.\r\n * The code is written to favor readability over efficiency.\r\n * The 3d terrain produced is less accurate than that available from services like [Cesium World Terrain](https://cesium.com/platform/cesium-ion/content/cesium-world-terrain/).\r\n * This provider requires a valid Bing Maps API key to be supplied via `IModelAppOptions.mapLayerOptions.BingMaps` to `IModelApp.startup`.\r\n *\r\n * For each tile, the provider obtains a 16x16 equally-spaced grid of elevation values. Each group of four adjacent elevations is converted into pair\r\n * of triangles (a quad).\r\n */\r\nexport class BingTerrainMeshProvider extends TerrainMeshProvider {\r\n  /** Provides elevation data. */\r\n  private readonly _provider: BingElevationProvider;\r\n  /** Scale factor applied to elevations, from `TerrainSettings.exaggeration`. */\r\n  private readonly _exaggeration: number;\r\n  /** If true, generate per-vertex normal vectors. */\r\n  private readonly _wantNormals: boolean;\r\n  /** If true, generate skirts around the edges of each tile. */\r\n  private readonly _wantSkirts: boolean;\r\n  public readonly tilingScheme = new GeographicTilingScheme(1, 1);\r\n\r\n  public constructor(options: TerrainMeshProviderOptions) {\r\n    super();\r\n    this._provider = new BingElevationProvider();\r\n    this._exaggeration = options.exaggeration;\r\n    this._wantNormals = options.wantNormals;\r\n    this._wantSkirts = options.wantSkirts;\r\n  }\r\n\r\n  /** Return elevation values in a 16x16 grid. */\r\n  public override async requestMeshData(args: RequestMeshDataArgs): Promise<number[] | undefined> {\r\n    const latLongRange = args.tile.quadId.getLatLongRangeDegrees(this.tilingScheme);\r\n\r\n    // Latitudes outside the range [-85, 85] produce HTTP 400 per the Bing API docs - clamp to that range.\r\n    latLongRange.low.y = Math.max(-85, latLongRange.low.y);\r\n    latLongRange.high.y = Math.min(85, latLongRange.high.y);\r\n\r\n    // Longitudes outside the range [0, 180) produce HTTP 500. Bing API docs don't mention this, but it seems like\r\n    // it would be a client error (400), not server error (500).\r\n    // Wrap them.\r\n    if (latLongRange.high.x >= 180)\r\n      latLongRange.high.x = latLongRange.high.x - 360;\r\n\r\n    const heights = await this._provider.getHeights(latLongRange);\r\n    return heights?.length === 16 * 16 ? heights : undefined;\r\n  }\r\n\r\n  /** Produce a 3d terrain mesh from the elevation values obtained by `requestMeshData`. */\r\n  public override async readMesh(args: ReadMeshArgs): Promise<RealityMeshParams | undefined> {\r\n    const heights = args.data as number[];\r\n    assert(heights.length === size * size);\r\n\r\n    // Make skirts 1/20th the width of the tile.\r\n    const skirtHeight = this._wantSkirts ? args.tile.range.xLength() / 20 : 0;\r\n\r\n    // Determine the minimum and maximum height values, scaled by the terrain exaggeration factor.\r\n    const heightRange = Range1d.createArray(heights);\r\n    heightRange.low -= skirtHeight;\r\n    heightRange.low *= this._exaggeration;\r\n    heightRange.high *= this._exaggeration;\r\n\r\n    // Update the height range stored on the MapTile.\r\n    args.tile.adjustHeights(heightRange.low, heightRange.high);\r\n\r\n    // Skirts add 16 new vertices along each edge.\r\n    const numSkirtVertices = this._wantSkirts ? size * 4 : 0;\r\n    // Skirts add 15 new quads along each edge.\r\n    const numSkirtIndices = this._wantSkirts ? sizeM1 * sizeM1 * 4 * 3 * 2 : 0;\r\n\r\n    // Given a 2d point in tile coordinates and an elevation, the projection can produce a 3d point in space.\r\n    const projection = args.tile.getProjection(heightRange);\r\n\r\n    // Options for creating the terrain mesh.\r\n    const initialVertexCapacity = size * size + numSkirtVertices;\r\n    const options: RealityMeshParamsBuilderOptions = {\r\n      // A range encompassing all possible 3d points in the mesh.\r\n      positionRange: projection.localRange,\r\n      // The exact number of vertices we will need - preallocated to avoid reallocating as we populate the array.\r\n      initialVertexCapacity,\r\n      // The exact number of vertex indices we will need - preallocated to avoid reallocating as we populate the array.\r\n      initialIndexCapacity: sizeM1 * sizeM1 * 3 * 2 + numSkirtIndices,\r\n      // We will compute the normals after computing the positions, if needed.\r\n      wantNormals: false,\r\n    };\r\n\r\n    const builder = new RealityMeshParamsBuilder(options);\r\n\r\n    // Holds the texture coordinates for the current vertex.\r\n    const uv = new Point2d();\r\n    // Holds the 3d position of the current vertex.\r\n    const position = new Point3d();\r\n\r\n    // For each elevation in the grid, add a vertex to the builder.\r\n    const delta = 1 / sizeM1;\r\n    for (let row = 0, v = 0; row < size; row++, v += delta) {\r\n      for (let col = 0, u = 0; col < size; col++, u += delta) {\r\n        const height = heights[(sizeM1 - row) * size + col];\r\n        projection.getPoint(u, 1 - v, height * this._exaggeration, position);\r\n        uv.set(u, 1 - v);\r\n        builder.addUnquantizedVertex(position, uv);\r\n      }\r\n    }\r\n\r\n    if (this._wantNormals)\r\n      this.addNormals(builder, initialVertexCapacity);\r\n\r\n    // Define the triangles for each quad.\r\n    for (let row = 0; row < sizeM1; row++) {\r\n      const rowIndex = row * size;\r\n      const nextRowIndex = rowIndex + size;\r\n      for (let col = 0; col < sizeM1; col++) {\r\n        const q0 = rowIndex + col;\r\n        const q1 = q0 + 1;\r\n        const q3 = nextRowIndex + col;\r\n        const q2 = q3 + 1;\r\n\r\n        builder.addTriangle(q0, q1, q2);\r\n        builder.addTriangle(q0, q2, q3);\r\n      }\r\n    }\r\n\r\n    if (this._wantSkirts)\r\n      this.addSkirts(builder, heights, skirtHeight, projection);\r\n\r\n    assert(builder.positions.length === options.initialVertexCapacity);\r\n    assert(builder.uvs.length === options.initialVertexCapacity);\r\n    assert(undefined === builder.normals || builder.normals.capacity === options.initialVertexCapacity);\r\n    assert(builder.positions.length === builder.uvs.length);\r\n    assert(undefined === builder.normals || builder.normals.length === builder.positions.length);\r\n    assert(builder.indices.capacity === options.initialIndexCapacity);\r\n\r\n    // Extract the completed 3d mesh.\r\n    return builder.finish();\r\n  }\r\n\r\n  // Compute a normal vector for each vertex.\r\n  private addNormals(builder: RealityMeshParamsBuilder, numVertices: number): void {\r\n    const scratchP0 = new Point3d();\r\n    const scratchP1 = new Point3d();\r\n    const scratchP2 = new Point3d();\r\n    const scratchFaceNormal = new Vector3d();\r\n\r\n    // Compute the vector perpendicular to one triangle, and add it to the accumulated vertex normal.\r\n    // sum: The accumulated vertex normal thus far.\r\n    // p0: The position of the vertex whose normal vector is being computed.\r\n    // r1, c1: The (x, y) offset of the second triangle vertex, relative to p0 - either 0, -1, or 1.\r\n    // r2, c2: The (x, y) offset of the third triangle vertex, relative to p0 - either 0, -1, or 1.\r\n    const addNormal = (sum: Vector3d, p0: Point3d, r1: number, c1: number, r2: number, c2: number): void => {\r\n      if (r1 < 0 || c1 < 0 || r2 < 0 || c2 < 0 || r1 >= size || c1 >= size || r2 >= size || c2 >= size) {\r\n        // At least one of the adjacent points is outside the boundaries of the tile. We have no elevation data for points outside the tile.\r\n        // Note: to properly compute normals for vertices on the edges of the tile, requestMeshData would need to request additional elevations\r\n        // for points adjacent to the tile. For simplicity, we simply ignore their contribution to the vertex normal.\r\n        return;\r\n      }\r\n\r\n      // Look up the positions of the other two triangle vertices.\r\n      const p1 = builder.positions.unquantize(r1 * size + c1, scratchP1);\r\n      const p2 = builder.positions.unquantize(r2 * size + c2, scratchP2);\r\n\r\n      // Compute the normalized vector perpendicular to the triangle.\r\n      const faceNormal = Vector3d.createCrossProductToPoints(p0, p1, p2, scratchFaceNormal);\r\n      faceNormal.normalizeInPlace();\r\n\r\n      // Add this triangle's normal vector to the vertex normal.\r\n      sum.plus(faceNormal, sum);\r\n      sum.normalizeInPlace();\r\n    };\r\n\r\n    // Allocate all of the normal vectors we need.\r\n    builder.normals = new Uint16ArrayBuilder({ initialCapacity: numVertices });\r\n\r\n    // Compute the normal vector for each vertex in the mesh.\r\n    const vertexNormal = Vector3d.createZero();\r\n    for (let row = 0; row < size; row++) {\r\n      for (let col = 0; col < size; col++) {\r\n        Vector3d.createZero(vertexNormal);\r\n        const p0 = builder.positions.unquantize(row * size + col, scratchP0);\r\n        // This could be made more efficient with a loop that retains the output of the previous iteration,\r\n        // but less readable.\r\n        addNormal(vertexNormal, p0, row+0, col+1, row+1, col+1);\r\n        addNormal(vertexNormal, p0, row+1, col+1, row+1, col+0);\r\n        addNormal(vertexNormal, p0, row+1, col+0, row+1, col-1);\r\n        addNormal(vertexNormal, p0, row+1, col-1, row+0, col-1);\r\n        addNormal(vertexNormal, p0, row+0, col-1, row-1, col-1);\r\n        addNormal(vertexNormal, p0, row-1, col-1, row-1, col+0);\r\n        addNormal(vertexNormal, p0, row-1, col+0, row-1, col+1);\r\n        addNormal(vertexNormal, p0, row-1, col+1, row+0, col+1);\r\n\r\n        vertexNormal.normalizeInPlace();\r\n        builder.normals.push(OctEncodedNormal.encode(vertexNormal));\r\n      }\r\n    }\r\n  }\r\n\r\n  // Generate \"skirts\" around the edge of the mesh, hanging straight down from the existing triangles.\r\n  // Note: if we angled the skirts outward slightly, they would do a better job of hiding seams, particularly when\r\n  // looking directly down at the map.\r\n  private addSkirts(builder: RealityMeshParamsBuilder, heights: number[], skirtHeight: number, projection: MapTileProjection): void {\r\n    // The normal vector for the skirt vertices does not matter - use a zero vector.\r\n    const skirtNormal = this._wantNormals ? new Vector3d() : undefined;\r\n    const uv = new Point2d();\r\n    const position = new Point3d();\r\n    const delta = 1 / sizeM1;\r\n\r\n    for (let c = 0; c < size; c++) {\r\n      // top row\r\n      let height = heights[sizeM1 * size + c];\r\n      const u = c * delta;\r\n      projection.getPoint(u, 1, (height - skirtHeight) * this._exaggeration, position);\r\n      uv.set(u, 1);\r\n      const topIndex = builder.addUnquantizedVertex(position, uv, skirtNormal);\r\n\r\n      // bottom row\r\n      height = heights[c];\r\n      projection.getPoint(u, 0, (height - skirtHeight) * this._exaggeration, position);\r\n      uv.set(u, 0);\r\n      const bottomIndex = builder.addUnquantizedVertex(position, uv, skirtNormal);\r\n\r\n      // left side\r\n      height = heights[(sizeM1 - c) * size];\r\n      projection.getPoint(0, 1 - u, (height - skirtHeight) * this._exaggeration, position);\r\n      uv.set(0, 1 - u);\r\n      const leftIndex = builder.addUnquantizedVertex(position, uv, skirtNormal);\r\n\r\n      // right side\r\n      height = heights[(sizeM1 - c) * size + sizeM1];\r\n      projection.getPoint(1, 1 - u, (height - skirtHeight) * this._exaggeration, position);\r\n      uv.set(1, 1 - u);\r\n      const rightIndex = builder.addUnquantizedVertex(position, uv, skirtNormal);\r\n\r\n      if (c === sizeM1) {\r\n        // We have added all 16 vertices and all 15 quads along each edge\r\n        break;\r\n      }\r\n\r\n      // top row\r\n      builder.addTriangle(c, c + 1, topIndex + 4);\r\n      builder.addTriangle(c, topIndex + 4, topIndex);\r\n\r\n      // bottom row\r\n      const row = size * sizeM1;\r\n      builder.addTriangle(row + c, row + c + 1, bottomIndex + 4);\r\n      builder.addTriangle(row + c, bottomIndex + 4, bottomIndex);\r\n\r\n      // left side\r\n      const left = c * size;\r\n      builder.addTriangle(left, left + size, leftIndex + 4);\r\n      builder.addTriangle(left, leftIndex + 4, leftIndex);\r\n\r\n      // right side\r\n      const right = c * size + sizeM1;\r\n      builder.addTriangle(right, right +size, rightIndex + 4);\r\n      builder.addTriangle(right, rightIndex + 4, rightIndex);\r\n    }\r\n  }\r\n\r\n  public override get maxDepth(): number {\r\n    return 22;\r\n  }\r\n\r\n  // Register the terrain provider, just after calling `IModelApp.startup`\r\n  public static register(): void {\r\n    // The name of our provider. It must be unique! It will be stored in `TerrainSettings.providerName`.\r\n    const providerName = \"DtaBingTerrain\";\r\n\r\n    // Our provider.\r\n    const provider: TerrainProvider = {\r\n      createTerrainMeshProvider: async (options: TerrainMeshProviderOptions) => {\r\n        return Promise.resolve(new BingTerrainMeshProvider(options));\r\n      },\r\n    };\r\n\r\n    IModelApp.terrainProviderRegistry.register(providerName, provider);\r\n  }\r\n}\r\n"
        ],
        "mappings": "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",
        "names": []
      }
    }
  ]
}
