{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/glsl/Lighting.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { addFrustum } from \"./Common\";\nconst computeDirectionalLighting = `\r\nvoid computeDirectionalLight (inout float diffuse, inout float specular, vec3 normal, vec3 toEye, vec3 lightDir, float lightIntensity, float specularExponent) {\r\n  diffuse += lightIntensity * max(dot(normal, lightDir), 0.0);\r\n  vec3 toReflectedLight = normalize(reflect(lightDir, normal));\r\n  float specularDot = max(dot(toReflectedLight, toEye), 0.0001);\r\n  // NB: If specularDot and specularExponent are both zero, 0^0 done below can return NaN.  Must make sure specularDot is larger than zero (hence 0.0001 or greater, as ensured above).\r\n  specular += lightIntensity * pow(specularDot, specularExponent);\r\n}\r\n`;\n// mat_weights: x=diffuse y=specular\nconst applyLighting = `\r\n  if (baseColor.a <= 0.0 || !u_surfaceFlags[kSurfaceBitIndex_ApplyLighting])\r\n    return baseColor;\r\n\r\n  // Extract surface properties\r\n  vec3 rgb = baseColor.rgb;\r\n  vec3 toEye = kFrustumType_Perspective == u_frustum.z ? normalize(v_eyeSpace.xyz) : vec3(0.0, 0.0, -1.0);\r\n\r\n  // Extract material properties\r\n  float diffuseWeight = mat_weights.x;\r\n  float specularWeight = mat_weights.y * u_lightSettings[13];\r\n  float specularExponent = mat_specular.a;\r\n  vec3 specularColor = mat_specular.rgb;\r\n  const float ambientWeight = 1.0; // Ignore MicroStation's ambient weights - usually bogus.\r\n\r\n  // Compute directional lights\r\n  const vec3 portraitDir = vec3(-0.7071, 0.0, 0.7071);\r\n  float portraitIntensity = u_lightSettings[12];\r\n  float sunIntensity = u_lightSettings[0];\r\n\r\n  float directionalDiffuseIntensity = 0.0;\r\n  float directionalSpecularIntensity = 0.0;\r\n  computeDirectionalLight(directionalDiffuseIntensity, directionalSpecularIntensity, g_normal, toEye, u_sunDir, sunIntensity, specularExponent);\r\n  computeDirectionalLight(directionalDiffuseIntensity, directionalSpecularIntensity, g_normal ,toEye, portraitDir, portraitIntensity, specularExponent);\r\n\r\n  const float directionalFudge = 0.92; // leftover from old lighting implementation\r\n  vec3 diffuseAccum = directionalDiffuseIntensity * diffuseWeight * rgb * directionalFudge; // directional light is white.\r\n  vec3 specularAccum = directionalSpecularIntensity * specularWeight * specularColor;\r\n\r\n  // Compute ambient light\r\n  float ambientIntensity = u_lightSettings[4];\r\n  vec3 ambientColor = vec3(u_lightSettings[1], u_lightSettings[2], u_lightSettings[3]);\r\n  if (ambientColor.r + ambientColor.g + ambientColor.b == 0.0)\r\n    ambientColor = rgb;\r\n\r\n  diffuseAccum += ambientIntensity * ambientWeight * ambientColor;\r\n\r\n  // Compute hemisphere lights\r\n  vec3 ground = vec3(u_lightSettings[5], u_lightSettings[6], u_lightSettings[7]);\r\n  vec3 sky = vec3(u_lightSettings[8], u_lightSettings[9], u_lightSettings[10]);\r\n  float hemiIntensity = u_lightSettings[11];\r\n\r\n  //  diffuse\r\n  float hemiDot = dot(g_normal, u_upVector);\r\n  float hemiDiffuseWeight = 0.5 * hemiDot + 0.5;\r\n  vec3 hemiColor = mix(ground, sky, hemiDiffuseWeight);\r\n  diffuseAccum += hemiIntensity * hemiColor * rgb;\r\n\r\n  //  sky specular\r\n  vec3 reflectSky = normalize(reflect(u_upVector, g_normal));\r\n  float skyDot = max(dot(reflectSky, toEye), 0.0001);\r\n  float hemiSpecWeight = hemiIntensity * pow(skyDot, specularExponent);\r\n\r\n  //  ground specular\r\n  vec3 reflectGround = normalize(reflect(-u_upVector, g_normal));\r\n  float groundDot = max(dot(reflectGround, toEye), 0.0001);\r\n  hemiSpecWeight += hemiIntensity * pow(groundDot, specularExponent);\r\n\r\n  specularAccum += hemiSpecWeight * specularColor * hemiColor;\r\n\r\n  vec3 litColor = diffuseAccum + specularAccum;\r\n\r\n  // Apply fresnel reflection.\r\n  float fresnelIntensity = u_lightSettings[15];\r\n  if (0.0 != fresnelIntensity) {\r\n    float fresnel = -dot(toEye, g_normal);\r\n    if (fresnelIntensity < 0.0) {\r\n      fresnelIntensity = abs(fresnelIntensity);\r\n      fresnel = 1.0 - fresnel;\r\n    }\r\n\r\n    fresnel = clamp(1.0 - fresnel, 0.0, 1.0);\r\n    litColor = litColor * (1.0 + fresnelIntensity * fresnel);\r\n  }\r\n\r\n  // Clamp while preserving hue.\r\n  float maxIntensity = max(litColor.r, max(litColor.g, litColor.b));\r\n  float numCel = u_lightSettings[14];\r\n  if (numCel > 0.0)\r\n    baseColor.rgb = baseColor.rgb * ceil(maxIntensity * numCel) / numCel;\r\n  else\r\n    baseColor.rgb = litColor / max(1.0, maxIntensity);\r\n\r\n  return baseColor;\r\n`;\n/** NB: addMaterial() sets up the mat_* variables used by applyLighting.\n * @internal\n */\nexport function addLighting(builder) {\n    addFrustum(builder);\n    const frag = builder.frag;\n    frag.addFunction(computeDirectionalLighting);\n    frag.set(8 /* FragmentShaderComponent.ApplyLighting */, applyLighting);\n    frag.addUniform(\"u_sunDir\", 4 /* VariableType.Vec3 */, (prog) => {\n        prog.addProgramUniform(\"u_sunDir\", (uniform, params) => {\n            params.target.uniforms.bindSunDirection(uniform);\n        });\n    }, 3 /* VariablePrecision.High */);\n    frag.addUniform(\"u_lightSettings[16]\", 2 /* VariableType.Float */, (prog) => {\n        prog.addProgramUniform(\"u_lightSettings[0]\", (uniform, params) => {\n            params.target.uniforms.lights.bind(uniform);\n        });\n    });\n    frag.addUniform(\"u_upVector\", 4 /* VariableType.Vec3 */, (prog) => {\n        prog.addProgramUniform(\"u_upVector\", (uniform, params) => {\n            params.target.uniforms.frustum.bindUpVector(uniform);\n        });\n    });\n}\n//# sourceMappingURL=Lighting.js.map",
      "start": 1693508126523,
      "end": 1693508126616,
      "sourcemaps": null
    }
  ]
}
