{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/numerics/Polynomials.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Numerics\n */\nimport { Geometry } from \"../Geometry\";\nimport { Angle } from \"../geometry3d/Angle\";\nimport { AngleSweep } from \"../geometry3d/AngleSweep\";\nimport { GrowableFloat64Array } from \"../geometry3d/GrowableFloat64Array\";\nimport { LongitudeLatitudeNumber } from \"../geometry3d/LongitudeLatitudeAltitude\";\nimport { Point2d, Vector2d } from \"../geometry3d/Point2dVector2d\";\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\nimport { Range1d, Range3d } from \"../geometry3d/Range\";\n// cspell:word Cardano\n// cspell:word CCminusSS\n/* eslint-disable @typescript-eslint/naming-convention */\n/**\n * degree 2 (quadratic) polynomial in for y = c0 + c1*x + c2*x^2\n * @internal\n */\nexport class Degree2PowerPolynomial {\n    constructor(c0 = 0, c1 = 0, c2 = 0) {\n        this.coffs = [c0, c1, c2];\n    }\n    /**\n     * * Return 2 duplicate roots in double root case.\n     * * The solutions are always in algebraic order.\n     * @returns 0, 1, or 2 solutions of the usual quadratic (a*x*x + b * x + c = 0)\n     */\n    static solveQuadratic(a, b, c) {\n        const b1 = Geometry.conditionalDivideFraction(b, a);\n        const c1 = Geometry.conditionalDivideFraction(c, a);\n        if (b1 !== undefined && c1 !== undefined) {\n            // now solving xx + b1*x + c1 = 0 -- i.e. implied \"a\" coefficient is 1 . .\n            const q = b1 * b1 - 4 * c1;\n            if (q > 0) {\n                const e = Math.sqrt(q);\n                // e is positive, so this sorts algebraically\n                return [0.5 * (-b1 - e), 0.5 * (-b1 + e)];\n            }\n            if (q < 0)\n                return undefined;\n            const root = -0.5 * b1;\n            return [root, root];\n        }\n        // \"divide by a\" failed.  solve bx + c = 0\n        const x = Geometry.conditionalDivideFraction(-c, b);\n        if (x !== undefined)\n            return [x];\n        return undefined;\n    }\n    /** Add `a` to the constant term. */\n    addConstant(a) {\n        this.coffs[0] += a;\n    }\n    /** Add  `s * (a + b*x)^2` to the quadratic coefficients */\n    addSquaredLinearTerm(a, b, s = 1) {\n        this.coffs[0] += s * (a * a);\n        this.coffs[1] += s * (2.0 * a * b);\n        this.coffs[2] += s * (b * b);\n    }\n    /** Return the real roots of this polynomial */\n    realRoots() {\n        const ss = Degree2PowerPolynomial.solveQuadratic(this.coffs[2], this.coffs[1], this.coffs[0]);\n        if (ss && ss.length > 1) {\n            if (ss[0] > ss[1]) {\n                const temp = ss[0];\n                ss[0] = ss[1];\n                ss[1] = temp;\n            }\n        }\n        return ss;\n    }\n    /** Evaluate the quadratic at x. */\n    evaluate(x) {\n        return this.coffs[0] + x * (this.coffs[1] + x * this.coffs[2]);\n    }\n    /**\n     * Evaluate the bezier function at a parameter value.  (i.e. sum the basis functions times coefficients)\n     * @param u parameter for evaluation\n     */\n    evaluateDerivative(x) {\n        return this.coffs[1] + 2 * x * this.coffs[2];\n    }\n    /** Factor the polynomial in to the form `y0 + c * (x-x0)^2)`, i.e. complete the square. */\n    tryGetVertexFactorization() {\n        const x = Geometry.conditionalDivideFraction(-this.coffs[1], 2.0 * this.coffs[2]);\n        if (x !== undefined) {\n            const y = this.evaluate(x);\n            return { c: this.coffs[2], x0: x, y0: y };\n        }\n        return undefined;\n    }\n    /** Construct a quadratic from input form `c2 * (x-root0) * (x-root1)` */\n    static fromRootsAndC2(root0, root1, c2 = 1) {\n        return new Degree2PowerPolynomial(c2 * root0 * root1, -c2 * (root0 + root1), c2);\n    }\n}\n/**\n * degree 3 (cubic) polynomial in for y = c0 + c1*x + c2*x^2 + c3*x^3\n * @internal\n */\nexport class Degree3PowerPolynomial {\n    constructor(c0 = 0, c1 = 0, c2 = 0, c3 = 1) {\n        this.coffs = [c0, c1, c2, c3];\n    }\n    /** Add `a` to the constant term. */\n    addConstant(a) {\n        this.coffs[0] += a;\n    }\n    /** Add `s * (a + b*x)^2` to the cubic */\n    addSquaredLinearTerm(a, b, s = 1) {\n        this.coffs[0] += s * (a * a);\n        this.coffs[1] += s * (2.0 * a * b);\n        this.coffs[2] += s * (b * b);\n    }\n    /**\n     * Evaluate the polynomial at x\n     * @param u parameter for evaluation\n     */\n    evaluate(x) {\n        return this.coffs[0] + x * (this.coffs[1] + x * (this.coffs[2] + x * this.coffs[3]));\n    }\n    /**\n     * Evaluate the polynomial derivative\n     * @param u parameter for evaluation\n     */\n    evaluateDerivative(x) {\n        return this.coffs[1] + x * (2.0 * this.coffs[2] + x * 3.0 * this.coffs[3]);\n    }\n    /** Construct a cubic from the form `c3 * (x-root0) * (x - root1) * (x- root2)` */\n    static fromRootsAndC3(root0, root1, root2, c3 = 1.0) {\n        return new Degree3PowerPolynomial(-c3 * root0 * root1 * root2, c3 * (root0 * root1 + root1 * root2 + root0 * root2), -c3 * (root0 + root1 + root2), c3);\n    }\n}\n/**\n * degree 4 (quartic) polynomial in for y = c0 + c1*x + c2*x^2 + c4*x^4\n * @internal\n */\nexport class Degree4PowerPolynomial {\n    constructor(c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0) {\n        this.coffs = [c0, c1, c2, c3, c4];\n    }\n    /** Add `a` to the constant term. */\n    addConstant(a) {\n        this.coffs[0] += a;\n    }\n    /**\n     * Evaluate the polynomial\n     * @param x x coordinate for evaluation\n     */\n    evaluate(x) {\n        return this.coffs[0] + x * (this.coffs[1] + x * (this.coffs[2] + x * (this.coffs[3] + x * this.coffs[4])));\n    }\n    /**\n     * Evaluate the derivative\n     * @param x x coordinate for evaluation\n     */\n    evaluateDerivative(x) {\n        return (this.coffs[1] + x * (2.0 * this.coffs[2] + x * (3.0 * this.coffs[3] + x * 4.0 * this.coffs[4])));\n    }\n    /** Construct a quartic from the form `c3 * (x-root0) * (x - root1) * (x- root2) * (x-root3)` */\n    static fromRootsAndC4(root0, root1, root2, root3, c4 = 1) {\n        return new Degree4PowerPolynomial(c4 * (root0 * root1 * root2 * root3), -c4 * (root0 * root1 * root2 + root0 * root1 * root3 + root0 * root2 * root3 + root1 * root2 * root3), c4 * (root0 * root1 + root0 * root2 + root0 * root3 + root1 * root2 + root1 * root3 + root2 * root3), -c4 * (root0 + root1 + root2 + root3), c4);\n    }\n}\n/**\n * polynomial services for an implicit torus with\n * * z axis is \"through the donut hole\"\n * * `majorRadius` is the radius of the circle \"around the z axis\"\n * * `minorRadius` is the radius of circles around the major circle\n * * for simple xyz the implicit form is\n *   * `(x^2+y^2+z^2+(R^2-r^2))^2 = 4 R^2(x^2+y^2)`\n * * In weighted form\n *   * `(x^2+y^2+z^2+(R^2-r^2)w^2)^2 = 4 R^2 w^2 (x^2+y^2)`\n * @internal\n */\nexport class TorusImplicit {\n    constructor(majorRadius, minorRadius) {\n        this.majorRadius = majorRadius;\n        this.minorRadius = minorRadius;\n    }\n    /** Return sum of (absolute) major and minor radii, which is (half) the box size in x and y directions */\n    boxSize() {\n        return (Math.abs(this.majorRadius) + Math.abs(this.minorRadius));\n    }\n    /** Return scale factor appropriate to control the magnitude of the implicit function. */\n    implicitFunctionScale() {\n        const a = this.boxSize();\n        if (a === 0.0)\n            return 1.0;\n        return 1.0 / (a * a * a * a);\n    }\n    /**\n     * At space point (x,y,z) evaluate the implicit form of the torus (See `ImplicitTorus`)\n     */\n    evaluateImplicitFunctionXYZ(x, y, z) {\n        const rho2 = x * x + y * y;\n        const z2 = z * z;\n        const R2 = this.majorRadius * this.majorRadius;\n        const r2 = this.minorRadius * this.minorRadius;\n        const f = rho2 + z2 + (R2 - r2);\n        const g = 4.0 * R2 * rho2;\n        return (f * f - g) * this.implicitFunctionScale();\n    }\n    /** Evaluate the implicit function at a point. */\n    evaluateImplicitFunctionPoint(xyz) {\n        return this.evaluateImplicitFunctionXYZ(xyz.x, xyz.y, xyz.z);\n    }\n    /** Evaluate the implicit function at homogeneous coordinates */\n    evaluateImplicitFunctionXYZW(x, y, z, w) {\n        const rho2 = x * x + y * y;\n        const z2 = z * z;\n        const w2 = w * w;\n        const R2 = this.majorRadius * this.majorRadius;\n        const r2 = this.minorRadius * this.minorRadius;\n        const f = rho2 + z2 + w2 * (R2 - r2);\n        const g = w2 * 4.0 * R2 * rho2;\n        return (f * f - g) * this.implicitFunctionScale();\n    }\n    /** Evaluate the surface point at angles (in radians) on the major and minor circles. */\n    evaluateThetaPhi(thetaRadians, phiRadians) {\n        const c = Math.cos(thetaRadians);\n        const s = Math.sin(thetaRadians);\n        // theta=0 point\n        const x0 = this.majorRadius + this.minorRadius * Math.cos(phiRadians);\n        const z0 = this.minorRadius * Math.sin(phiRadians);\n        return Point3d.create(c * x0, s * x0, z0);\n    }\n    /** Evaluate partial derivatives at angles (int radians) on major and minor circles. */\n    evaluateDerivativesThetaPhi(thetaRadians, phiRadians, dxdTheta, dxdPhi) {\n        const cTheta = Math.cos(thetaRadians);\n        const sTheta = Math.sin(thetaRadians);\n        const bx = this.minorRadius * Math.cos(phiRadians);\n        const bz = this.minorRadius * Math.sin(phiRadians);\n        const x0 = this.majorRadius + bx;\n        Vector3d.create(-x0 * sTheta, x0 * cTheta, 0.0, dxdTheta);\n        Vector3d.create(-cTheta * bz, -sTheta * bz, bx, dxdPhi);\n    }\n    /** Evaluate space point at major and minor angles (in radians) and distance from major hoop. */\n    evaluateThetaPhiDistance(thetaRadians, phiRadians, distance) {\n        const c = Math.cos(thetaRadians);\n        const s = Math.sin(thetaRadians);\n        // theta=0 point\n        const x0 = this.majorRadius + distance * Math.cos(phiRadians);\n        const z0 = distance * Math.sin(phiRadians);\n        return Point3d.create(c * x0, s * x0, z0);\n    }\n    /** Given an xyz coordinate in the local system of the toroid, compute the torus parametrization\n     * * theta = angular coordinate in xy plane\n     * * phi = angular coordinate in minor circle.\n     * * distance = distance from major circle\n     * * rho = distance from origin to xy part of the input.\n     * @param xyz space point in local coordinates.\n     * @return object with properties theta, phi, distance, rho\n     */\n    xyzToThetaPhiDistance(xyz) {\n        const rho = xyz.magnitudeXY();\n        const majorRadiusFactor = Geometry.conditionalDivideFraction(this.majorRadius, rho);\n        let safeMajor;\n        let majorCirclePoint;\n        if (majorRadiusFactor) {\n            safeMajor = true;\n            majorCirclePoint = Point3d.create(majorRadiusFactor * xyz.x, majorRadiusFactor * xyz.y, 0.0);\n        }\n        else {\n            safeMajor = false;\n            majorCirclePoint = Point3d.create(xyz.x, xyz.y, 0.0);\n        }\n        const theta = safeMajor ? Math.atan2(xyz.y, xyz.x) : 0.0;\n        const vectorFromMajorCircle = Vector3d.createStartEnd(majorCirclePoint, xyz);\n        const distance = vectorFromMajorCircle.magnitude();\n        const dRho = rho - this.majorRadius;\n        let safePhi;\n        let phi;\n        if (xyz.z === 0.0 && dRho === 0.0) {\n            phi = 0.0;\n            safePhi = false;\n        }\n        else {\n            phi = Math.atan2(xyz.z, dRho);\n            safePhi = true;\n        }\n        return { theta, phi, distance, rho, safePhi: safeMajor && safePhi };\n    }\n}\n/**\n * evaluation methods for an implicit sphere\n * * xyz function `x*x + y*y + z*z - r*r = 0`.\n * * xyzw function `x*x + y*y + z*z - r*r*w*w = 0`.\n * @internal\n */\nexport class SphereImplicit {\n    constructor(r) { this.radius = r; }\n    /** Evaluate the implicit function at coordinates x,y,z */\n    evaluateImplicitFunction(x, y, z) {\n        return x * x + y * y + z * z - this.radius * this.radius;\n    }\n    /** Evaluate the implicit function at homogeneous coordinates x,y,z,w */\n    evaluateImplicitFunctionXYZW(wx, wy, wz, w) {\n        return (wx * wx + wy * wy + wz * wz) - this.radius * this.radius * w * w;\n    }\n    /** Given an xyz coordinate in the local system of the toroid, compute the sphere parametrization\n     * * theta = angular coordinate in xy plane\n     * * phi = rotation from xy plane towards z axis.\n     * @param xyz space point in local coordinates.\n     * @return object with properties thetaRadians, phi, r\n     */\n    xyzToThetaPhiR(xyz) {\n        const rhoSquared = xyz.x * xyz.x + xyz.y * xyz.y;\n        const rho = Math.sqrt(rhoSquared);\n        const r = Math.sqrt(rhoSquared + xyz.z * xyz.z);\n        let theta;\n        let phi;\n        let valid;\n        if (r === 0.0) {\n            theta = phi = 0.0;\n            valid = false;\n        }\n        else {\n            phi = Math.atan2(xyz.z, rho); // At least one of these is nonzero\n            if (rhoSquared !== 0.0) {\n                theta = Math.atan2(xyz.y, xyz.x);\n                valid = true;\n            }\n            else {\n                theta = 0.0;\n                valid = false;\n            }\n        }\n        return { thetaRadians: (theta), phiRadians: (phi), r, valid };\n    }\n    /** Return the range of a uv-aligned patch of the sphere. */\n    static patchRangeStartEndRadians(center, radius, theta0Radians, theta1Radians, phi0Radians, phi1Radians, result) {\n        const thetaSweep = AngleSweep.createStartEndRadians(theta0Radians, theta1Radians);\n        const phiSweep = AngleSweep.createStartEndRadians(phi0Radians, phi1Radians);\n        const range = Range3d.createNull(result);\n        const xyz = Point3d.create();\n        if (thetaSweep.isFullCircle && phiSweep.isFullLatitudeSweep) {\n            // full sphere, no trimming -- build directly\n            range.extendPoint(center);\n            range.expandInPlace(Math.abs(radius));\n        }\n        else {\n            const sphere = new SphereImplicit(radius);\n            // construct range for ORIGIN CENTERED sphere ...\n            const pi = Math.PI;\n            const piOver2 = 0.5 * Math.PI;\n            let phi, theta;\n            // 6 candidate interior extreme points on equator and 0, 90 degree meridians\n            for (const thetaPhi of [\n                [0.0, 0.0],\n                [pi, 0.0],\n                [piOver2, 0.0],\n                [-piOver2, 0.0],\n                [theta0Radians, piOver2],\n                [theta0Radians, -piOver2]\n            ]) {\n                theta = thetaPhi[0];\n                phi = thetaPhi[1];\n                if (thetaSweep.isRadiansInSweep(theta) && phiSweep.isRadiansInSweep(phi))\n                    range.extendPoint(sphere.evaluateThetaPhi(theta, phi, xyz));\n            }\n            // 4 boundary curves, each with 3 components ...\n            // BUT: phi should not extend beyond poles. Hence z extremes on constant theta curve will never be different from z of constant phi curve or of poles as tested above.\n            const axisRange = Range1d.createNull();\n            const cosPhi0 = Math.cos(phi0Radians);\n            const cosPhi1 = Math.cos(phi1Radians);\n            const sinPhi0 = Math.sin(phi0Radians);\n            const sinPhi1 = Math.sin(phi1Radians);\n            const trigForm = new SineCosinePolynomial(0, 0, 0);\n            // constant phi curves at phi0 and phi1\n            for (const cosPhi of [cosPhi0, cosPhi1]) {\n                trigForm.set(0, cosPhi * radius, 0);\n                trigForm.rangeInSweep(thetaSweep, axisRange);\n                range.extendXOnly(axisRange.low);\n                range.extendXOnly(axisRange.high);\n                trigForm.set(0, 0, cosPhi * radius);\n                trigForm.rangeInSweep(thetaSweep, axisRange);\n                range.extendYOnly(axisRange.low);\n                range.extendYOnly(axisRange.high);\n            }\n            range.extendZOnly(sinPhi0 * radius);\n            range.extendZOnly(sinPhi1 * radius);\n            // constant theta curves as theta0 and theta1:\n            for (const thetaRadians of [theta0Radians, theta1Radians]) {\n                const cosThetaR = Math.cos(thetaRadians) * radius;\n                const sinThetaR = Math.sin(thetaRadians) * radius;\n                trigForm.set(0, cosThetaR, 0);\n                trigForm.rangeInSweep(phiSweep, axisRange);\n                range.extendXOnly(axisRange.low);\n                range.extendXOnly(axisRange.high);\n                trigForm.set(0, sinThetaR, 0);\n                trigForm.rangeInSweep(phiSweep, axisRange);\n                range.extendYOnly(axisRange.low);\n                range.extendYOnly(axisRange.high);\n            }\n            range.cloneTranslated(center, range);\n        }\n        return range;\n    }\n    /** Compute intersections with a ray.\n     * * Return the number of intersections\n     * * Fill any combinations of arrays of\n     *    * rayFractions = fractions along the ray\n     *    * xyz = xyz intersection coordinates points in space\n     *    * thetaPhiRadians = sphere longitude and latitude in radians.\n     * * For each optional array, caller must of course initialize an array (usually empty)\n     */\n    static intersectSphereRay(center, radius, ray, rayFractions, xyz, thetaPhiRadians) {\n        const vx = ray.origin.x - center.x;\n        const vy = ray.origin.y - center.y;\n        const vz = ray.origin.z - center.z;\n        const ux = ray.direction.x;\n        const uy = ray.direction.y;\n        const uz = ray.direction.z;\n        const a0 = Geometry.hypotenuseSquaredXYZ(vx, vy, vz) - radius * radius;\n        const a1 = 2.0 * Geometry.dotProductXYZXYZ(ux, uy, uz, vx, vy, vz);\n        const a2 = Geometry.hypotenuseSquaredXYZ(ux, uy, uz);\n        const parameters = Degree2PowerPolynomial.solveQuadratic(a2, a1, a0);\n        if (rayFractions !== undefined)\n            rayFractions.length = 0;\n        if (xyz !== undefined)\n            xyz.length = 0;\n        if (thetaPhiRadians !== undefined)\n            thetaPhiRadians.length = 0;\n        if (parameters === undefined) {\n            return 0;\n        }\n        const sphere = new SphereImplicit(radius);\n        if (rayFractions !== undefined)\n            for (const f of parameters)\n                rayFractions.push(f);\n        if (xyz !== undefined || thetaPhiRadians !== undefined) {\n            for (const f of parameters) {\n                const point = ray.fractionToPoint(f);\n                if (xyz !== undefined)\n                    xyz.push(point);\n                if (thetaPhiRadians !== undefined) {\n                    const data = sphere.xyzToThetaPhiR(point);\n                    thetaPhiRadians.push(LongitudeLatitudeNumber.createRadians(data.thetaRadians, data.phiRadians));\n                }\n            }\n        }\n        return parameters.length;\n    }\n    // public intersectRay(ray: Ray3d, maxHit: number): {rayFractions: number, points: Point3d} {\n    //   const q = new Degree2PowerPolynomial();\n    //   // Ray is (origin.x + s * direction.x, etc)\n    //   // squared distance from origin is (origin.x + s*direction.x)^2 + etc\n    //   // sphere radius in local system is 1.\n    //   q.addSquaredLinearTerm(ray.origin.x, ray.direction.x);\n    //   q.addSquaredLinearTerm(ray.origin.y, ray.direction.y);\n    //   q.addSquaredLinearTerm(ray.origin.z, ray.direction.z);\n    //   q.addConstant(-this.radius * this.radius);\n    //   let ss = [];\n    //   let n = q.realRoots(ss);\n    //   if (n > maxHit)\n    //     n = maxHit;\n    //   let rayFractions;\n    //   let points;\n    //   for (let i = 0; i < n; i++) {\n    //     rayFractions[i] = ss[i];\n    //     points[i] = Point3d. // What is the equivalent of FromSumOf in TS?\n    //   }\n    /** Compute the point on a sphere at angular coordinates.\n     * @param thetaRadians latitude angle\n     * @param phiRadians longitude angle\n     */\n    evaluateThetaPhi(thetaRadians, phiRadians, result) {\n        const rc = this.radius * Math.cos(thetaRadians);\n        const rs = this.radius * Math.sin(thetaRadians);\n        const cosPhi = Math.cos(phiRadians);\n        const sinPhi = Math.sin(phiRadians);\n        return Point3d.create(rc * cosPhi, rs * cosPhi, this.radius * sinPhi, result);\n    }\n    /**\n     * * convert radians to xyz on unit sphere\n     * * Note that there is no radius used -- implicitly radius is 1\n     * * Evaluation is always to a preallocated xyz.\n     */\n    static radiansToUnitSphereXYZ(thetaRadians, phiRadians, xyz) {\n        const cosTheta = Math.cos(thetaRadians);\n        const sinTheta = Math.sin(thetaRadians);\n        const cosPhi = Math.cos(phiRadians);\n        const sinPhi = Math.sin(phiRadians);\n        xyz.x = cosTheta * cosPhi;\n        xyz.y = sinTheta * cosPhi;\n        xyz.z = sinPhi;\n    }\n    /** Compute the derivatives with respect to spherical angles.\n     * @param thetaRadians latitude angle\n     * @param phiRadians longitude angle\n     */\n    evaluateDerivativesThetaPhi(thetaRadians, phiRadians, dxdTheta, dxdPhi) {\n        const rc = this.radius * Math.cos(thetaRadians);\n        const rs = this.radius * Math.sin(thetaRadians);\n        const cosPhi = Math.cos(phiRadians);\n        const sinPhi = Math.sin(phiRadians);\n        Vector3d.create(-rs * cosPhi, rc * cosPhi, 0.0, dxdTheta);\n        Vector3d.create(-rc * sinPhi, -rs * sinPhi, this.radius * cosPhi, dxdPhi);\n    }\n}\n/** AnalyticRoots has static methods for solving quadratic, cubic, and quartic equations.\n * @internal\n *\n */\nclass AnalyticRoots {\n    /** Absolute zero test with a tolerance that has worked well for the analytic root use case . . . */\n    static isZero(x) {\n        return Math.abs(x) < this._EQN_EPS;\n    }\n    /** Without actually doing a division, test if (x/y) is small.\n     * @param x numerator\n     * @param y denominator\n     * @param absTol absolute tolerance\n     * @param relTol relative tolerance\n     */\n    static isSmallRatio(x, y, absTol = 1.0e-9, relTol = 8.0e-16) {\n        return Math.abs(x) <= absTol || Math.abs(x) < relTol * Math.abs(y);\n    }\n    /** Return the (real, signed) principal cube root of x */\n    static cbrt(x) {\n        return ((x) > 0.0\n            ? Math.pow((x), 1.0 / 3.0)\n            : ((x) < 0.0\n                ? -Math.pow(-(x), 1.0 / 3.0)\n                : 0.0));\n    }\n    /**\n     * Try to divide `numerator/denominator` and place the result (or defaultValue) in `values[offset]`\n     * @param values array of values.  `values[offset]` will be replaced.\n     * @param numerator numerator for division.\n     * @param denominator denominator for division.\n     * @param defaultValue value to save if denominator is too small to divide.\n     * @param offset index of value to replace.\n     */\n    static safeDivide(values, numerator, denominator, defaultValue = 0.0, offset) {\n        if (Math.abs(denominator) > (this._safeDivideFactor * Math.abs(numerator))) {\n            values[offset] = numerator / denominator;\n            return true;\n        }\n        values[offset] = defaultValue;\n        return false;\n    }\n    // Used in NewtonMethod for testing if a root has been adjusted past its bounding region\n    static checkRootProximity(roots, i) {\n        if (i === 0) { // Case 1: Beginning Root (check root following it)\n            return roots.atUncheckedIndex(i) < roots.atUncheckedIndex(i + 1);\n        }\n        else if (i > 0 && i + 1 < roots.length) { // Case 2: Middle Root (check roots before and after)\n            return (roots.atUncheckedIndex(i) > roots.atUncheckedIndex(i - 1)) && (roots.atUncheckedIndex(i) < roots.atUncheckedIndex(i + 1));\n        }\n        else { // Case 3: End root (check preceding root)\n            return (roots.atUncheckedIndex(i) > roots.atUncheckedIndex(i - 1));\n        }\n    }\n    static newtonMethodAdjustment(coffs, root, degree) {\n        let p = coffs[degree];\n        let q = 0.0;\n        for (let i = degree - 1; i >= 0; i--) {\n            q = p + root * q;\n            p = coffs[i] + root * p;\n        }\n        if (Math.abs(q) >= 1.0e-14 * (1.0 + Math.abs(root))) {\n            return p / q;\n        }\n        return undefined;\n    }\n    static improveRoots(coffs, degree, roots, restrictOrderChanges) {\n        const relTol = 1.0e-10;\n        // Loop through each root\n        for (let i = 0; i < roots.length; i++) {\n            let dx = this.newtonMethodAdjustment(coffs, roots.atUncheckedIndex(i), degree);\n            if (dx === undefined || dx === 0.0)\n                continue; // skip if newton step had divide by zero.\n            const originalValue = roots.atUncheckedIndex(i);\n            let counter = 0;\n            let convergenceCounter = 0;\n            // Loop through applying changes to found root until dx is diminished or counter is hit\n            while (dx !== undefined && dx !== 0.0 && (counter < 12)) {\n                // consider it converged if two successive iterations satisfy the (not too demanding) tolerance.\n                if (Math.abs(dx) < relTol * (1.0 + Math.abs(roots.atUncheckedIndex(i)))) {\n                    if (++convergenceCounter > 1)\n                        break;\n                }\n                else {\n                    convergenceCounter = 0;\n                }\n                const rootDX = roots.atUncheckedIndex(i) - dx;\n                roots.reassign(i, rootDX);\n                // If root is thrown past one of its neighboring roots, unstable condition is assumed.. revert\n                // to originally found root\n                if (restrictOrderChanges && !this.checkRootProximity(roots, i)) {\n                    roots.reassign(i, originalValue);\n                    break;\n                }\n                dx = this.newtonMethodAdjustment(coffs, roots.atUncheckedIndex(i), degree);\n                counter++;\n            }\n        }\n    }\n    /**\n     * Append (if defined) value to results.\n     * @param value optional value to append\n     * @param results growing array\n     */\n    static appendSolution(value, results) {\n        if (value !== undefined) {\n            results.push(value);\n        }\n    }\n    /**\n     * Append 2 solutions -- note that both are required args, no option of omitting as in single solution case\n     * @param value1\n     * @param value2\n     * @param results\n     */\n    static append2Solutions(valueA, valueB, results) {\n        results.push(valueA);\n        results.push(valueB);\n    }\n    /**\n     * If `co/c1` is a safe division, append it to the values array.\n     * @param c0 numerator\n     * @param c1 denominator\n     * @param values array to expand\n     */\n    static appendLinearRoot(c0, c1, values) {\n        AnalyticRoots.appendSolution(Geometry.conditionalDivideFraction(-c0, c1), values);\n    }\n    /**\n     * * Compute the mean of all the entries in `data`\n     * * Return the data value that is farthest away\n     */\n    static mostDistantFromMean(data) {\n        if (!data || data.length === 0)\n            return 0;\n        let a = 0.0; // to become the sum and finally the average.\n        for (let i = 0; i < data.length; i++)\n            a += data.atUncheckedIndex(i);\n        a /= data.length;\n        let dMax = 0.0;\n        let result = data.atUncheckedIndex(0);\n        for (let i = 0; i < data.length; i++) {\n            const d = Math.abs(data.atUncheckedIndex(i) - a);\n            if (d > dMax) {\n                dMax = d;\n                result = data.atUncheckedIndex(i);\n            }\n        }\n        return result;\n    }\n    /**\n     * Append 0, 1, or 2 solutions of a quadratic to the values array.\n     * @param c array of coefficients for quadratic `c[0] + c[1] * x + c[2] * x*x`\n     * @param values array to be expanded.\n     */\n    static appendQuadraticRoots(c, values) {\n        // Normal form: x^2 + 2px + q = 0\n        const divFactor = Geometry.conditionalDivideFraction(1.0, c[2]);\n        if (!divFactor) {\n            this.appendLinearRoot(c[0], c[1], values);\n            return;\n        }\n        const p = 0.5 * c[1] * divFactor;\n        const q = c[0] * divFactor;\n        const D = p * p - q;\n        if (this.isZero(D)) {\n            this.appendSolution(-p, values);\n            return;\n        }\n        else if (D < 0) {\n            return;\n        }\n        else if (D > 0) {\n            const sqrt_D = Math.sqrt(D);\n            this.append2Solutions(sqrt_D - p, -sqrt_D - p, values);\n            return;\n        }\n        return;\n    }\n    /** Add `a` to the constant term. */\n    static addConstant(value, data) {\n        for (let i = 0; i < data.length; i++)\n            data.reassign(i, data.atUncheckedIndex(i) + value);\n    }\n    static signedCubeRoot(y) {\n        if (y >= 0.0)\n            return Math.pow(y, 1.0 / 3.0);\n        return -Math.pow(-y, 1.0 / 3.0);\n    }\n    /**\n     * RWD Nickalls Cubic solution\n     * The Mathematical Gazette (1993) (vol 77) pp 354-359\n     * * ASSUME a is nonzero.\n     */\n    // Solve full cubic ASSUMING a3 is nonzero.\n    static appendFullCubicSolutions(a, b, c, d, result) {\n        const q = b * b - 3.0 * a * c;\n        const aa = a * a;\n        const delta2 = q / (9.0 * aa);\n        const xN = -b / (3.0 * a);\n        const yN = d + xN * (c + xN * (b + xN * a));\n        const yN2 = yN * yN;\n        const h2 = 4.0 * a * a * delta2 * delta2 * delta2;\n        const discriminant = yN2 - h2;\n        if (discriminant > 0) {\n            // 1 real root\n            const r = Math.sqrt(discriminant);\n            const f = 0.5 / a;\n            result.push(xN + this.signedCubeRoot(f * (-yN + r)) + this.signedCubeRoot(f * (-yN - r)));\n        }\n        else if (discriminant < 0) {\n            // 3 real roots\n            let h = Math.sqrt(h2);\n            // I don't see comment in Nickalls about sign of h -- but this sign change is needed ...\n            if (a < 0)\n                h = -h;\n            // sign of h?\n            const thetaRadians = Math.acos(-yN / h) / 3.0;\n            const g = 2.0 * Math.sqrt(delta2);\n            const shift = 2.0 * Math.PI / 3.0;\n            result.push(xN + g * Math.cos(thetaRadians));\n            result.push(xN + g * Math.cos(thetaRadians + shift));\n            result.push(xN + g * Math.cos(thetaRadians - shift));\n        }\n        else {\n            // NOTE: The double-root case is not toleranced.\n            // double root + single root\n            const delta = this.signedCubeRoot(0.5 * yN / a);\n            const minMaxRoot = xN + delta;\n            result.push(xN - 2 * delta);\n            result.push(minMaxRoot);\n            result.push(minMaxRoot);\n        }\n    }\n    /* return roots of a cubic c0 + c1 *x + c2 * x^2 + c2 * x3.\n     * In the usual case where c0 is non-zero, there are either 1 or 3 roots.\n     * But if c0 is zero the (0, 1, or 2) roots of the lower order equation\n     */\n    /*\n    private static _appendCubicRootsUnsorted(c: Float64Array | number[], results: GrowableFloat64Array) {\n      let sq_A: number;\n      let p: number;\n      let q: number;\n  \n      // normal form: x^3 + Ax^2 + Bx + C = 0\n  \n      const scaleFactor = Geometry.conditionalDivideFraction(1.0, c[3]);\n      if (!scaleFactor) {\n        this.appendQuadraticRoots(c, results);\n        return;\n      }\n      // It is a real cubic.  There MUST be at least one real solution . . .\n      const A: number = c[2] * scaleFactor;\n      const B: number = c[1] * scaleFactor;\n      const C: number = c[0] * scaleFactor;\n  \n      //  substitute x = y - A/3 to eliminate quadric term:\n      //    f = y^3 +3py + 2q = 0\n      //    f' = 3y^2 + p\n      //        local min/max at Y = +-sqrt (-p)\n      //        f(+Y) = -p sqrt(-p) + 3p sqrt (-p) + 2q = 2 p sqrt (-p) + 2q\n      sq_A = A * A;\n      p = (3.0 * B - sq_A) / 9.0;\n      q = 1.0 / 2 * (2.0 / 27 * A * sq_A - 1.0 / 3 * A * B + C);\n  \n      // Use Cardano formula\n      const cb_p: number = p * p * p;\n      const D: number = q * q + cb_p;\n      const origin = A / (-3.0);\n      if (D >= 0.0 && this.isZero(D)) {\n        if (this.isZero(q)) {\n          // One triple solution\n          results.push(origin);\n          results.push(origin);\n          results.push(origin);\n          return;\n        } else {\n          // One single and one double solution\n          const u = this.cbrt(-q);\n          if (u < 0) {\n            results.push(origin + 2 * u);\n            results.push(origin - u);\n            results.push(origin - u);\n            return;\n          } else {\n            results.push(origin - u);\n            results.push(origin - u);\n            results.push(origin + 2 * u);\n            return;\n          }\n        }\n      } else if (D <= 0) {      // three real solutions\n        const phi = 1.0 / 3 * Math.acos(-q / Math.sqrt(-cb_p));\n        const t = 2 * Math.sqrt(-p);\n        results.push(origin + t * Math.cos(phi));\n        results.push(origin - t * Math.cos(phi + Math.PI / 3));\n        results.push(origin - t * Math.cos(phi - Math.PI / 3));\n        this.improveRoots(c, 3, results, false);\n  \n        return;\n      } else {    // One real solution\n        const sqrt_D = Math.sqrt(D);\n        const u = this.cbrt(sqrt_D - q);\n        const v = -(this.cbrt(sqrt_D + q));\n        results.push(origin + u + v);\n        this.improveRoots(c, 3, results, false);\n        return;\n      }\n    }\n    */\n    /** Compute roots of cubic 'c[0] + c[1] * x + c[2] * x^2 + c[3] * x^3 */\n    static appendCubicRoots(c, results) {\n        if (Geometry.conditionalDivideCoordinate(1.0, c[3]) !== undefined) {\n            this.appendFullCubicSolutions(c[3], c[2], c[1], c[0], results);\n            // EDL April 5, 2020 replace classic GraphicsGems solver by RWDNickalls.\n            // Don't know if improveRoots is needed.\n            // Breaks in AnalyticRoots.test.ts checkQuartic suggest it indeed converts many e-16 errors to zero.\n            //  e-13 cases are unaffected\n            this.improveRoots(c, 3, results, false);\n        }\n        else {\n            this.appendQuadraticRoots(c, results);\n        }\n        // this.appendCubicRootsUnsorted(c, results);\n        results.sort();\n    }\n    /** Compute roots of quartic 'c[0] + c[1] * x + c[2] * x^2 + c[3] * x^3 + c[4] * x^4 */\n    static appendQuarticRoots(c, results) {\n        const coffs = new Float64Array(4); // at various times .. coefficients of quadratic an cubic intermediates.\n        let u;\n        let v;\n        // normal form: x^4 + Ax^3 + Bx^2 + Cx + D = 0\n        const coffScale = new Float64Array(1);\n        if (!this.safeDivide(coffScale, 1.0, c[4], 0.0, 0)) {\n            this.appendCubicRoots(c, results);\n            return;\n        }\n        const A = c[3] * coffScale[0];\n        const B = c[2] * coffScale[0];\n        const C = c[1] * coffScale[0];\n        const D = c[0] * coffScale[0];\n        const origin = -0.25 * A;\n        /*  substitute x = y - A/4 to eliminate cubic term:\n            x^4 + px^2 + qx + r = 0 */\n        const sq_A = A * A;\n        const p = -3.0 / 8 * sq_A + B;\n        const q = 0.125 * sq_A * A - 0.5 * A * B + C;\n        const r = -3.0 / 256 * sq_A * sq_A + 1.0 / 16 * sq_A * B - 1.0 / 4 * A * C + D;\n        const tempStack = new GrowableFloat64Array();\n        if (this.isZero(r)) {\n            // no absolute term: y(y^3 + py + q) = 0\n            coffs[0] = q;\n            coffs[1] = p;\n            coffs[2] = 0;\n            coffs[3] = 1;\n            this.appendCubicRoots(coffs, results);\n            results.push(0); // APPLY ORIGIN ....\n            this.addConstant(origin, results);\n            return;\n        }\n        else {\n            // Solve the resolvent cubic\n            coffs[0] = 1.0 / 2 * r * p - 1.0 / 8 * q * q;\n            coffs[1] = -r;\n            coffs[2] = -1.0 / 2 * p;\n            coffs[3] = 1;\n            this.appendCubicRoots(coffs, tempStack);\n            const z = this.mostDistantFromMean(tempStack);\n            // ... to build two quadric equations\n            u = z * z - r;\n            v = 2 * z - p;\n            if (this.isSmallRatio(u, r)) {\n                u = 0;\n            }\n            else if (u > 0) {\n                u = Math.sqrt(u);\n            }\n            else {\n                return;\n            }\n            if (this.isSmallRatio(v, p)) {\n                v = 0;\n            }\n            else if (v > 0) {\n                v = Math.sqrt(v);\n            }\n            else {\n                for (let i = 0; i < tempStack.length; i++) {\n                    results.push(tempStack.atUncheckedIndex(i));\n                }\n                return;\n            }\n            coffs[0] = z - u;\n            coffs[1] = ((q < 0) ? (-v) : (v));\n            coffs[2] = 1;\n            this.appendQuadraticRoots(coffs, results);\n            coffs[0] = z + u;\n            coffs[1] = ((q < 0) ? (v) : (-v));\n            coffs[2] = 1;\n            this.appendQuadraticRoots(coffs, results);\n        }\n        // substitute\n        this.addConstant(origin, results);\n        results.sort();\n        this.improveRoots(c, 4, results, true);\n        return;\n    }\n    static appendCosSinRadians(c, s, cosValues, sinValues, radiansValues) {\n        if (cosValues)\n            cosValues.push(c);\n        if (sinValues)\n            sinValues.push(s);\n        if (radiansValues)\n            radiansValues.push(Math.atan2(s, c));\n    }\n    /**\n     * * Solve the simultaneous equations in variables`c` and`s`:\n     *   * A line: `alpha + beta*c + gamma*s = 0`\n     *   * The unit circle `c*c + s*s = 1`\n     * * Solution values are returned as 0, 1, or 2(c, s) pairs\n     * * Return value indicates one of these solution states:\n     *   * -2 -- all coefficients identically 0.   The entire c, s plane-- and therefore the entire unit circle-- is a solution.\n     *   * -1 -- beta, gamma are zero, alpha is not.There is no line defined.There are no solutions.\n     *   * 0 -- the line is well defined, but passes completely outside the unit circle.\n     *     * In this case, (c1, s1) is the circle point closest to the line and(c2, s2) is the line point closest to the circle.\n     * * 1 -- the line is tangent to the unit circle.\n     *   * Tangency is determined by tolerances, which calls a \"close approach\" point a tangency.\n     *    * (c1, s1) is the closest circle point\n     *    * (c2, s2) is the line point.\n     * * 2 -- two simple intersections.\n     * @param alpha constant coefficient on line\n     * @param beta x cosine coefficient on line\n     * @param gamma y sine coefficient on line\n     * @param relTol relative tolerance for tangencies\n     * @param cosValues (caller allocated) array to receive solution `c` values\n     * @param sinValues (caller allocated) array to receive solution `s` values\n     * @param radiansValues (caller allocated) array to receive solution radians values.\n     */\n    static appendImplicitLineUnitCircleIntersections(alpha, beta, gamma, cosValues, sinValues, radiansValues, relTol = 1.0e-14) {\n        let twoTol;\n        const delta2 = beta * beta + gamma * gamma;\n        const alpha2 = alpha * alpha;\n        let solutionType = 0;\n        if (relTol < 0.0) {\n            twoTol = 0.0;\n        }\n        else {\n            twoTol = 2.0 * relTol;\n        }\n        if (delta2 <= 0.0) {\n            solutionType = (alpha === 0) ? -2 : -1;\n        }\n        else {\n            const lambda = -alpha / delta2;\n            const a2 = alpha2 / delta2;\n            const D2 = 1.0 - a2;\n            if (D2 < -twoTol) {\n                const delta = Math.sqrt(delta2);\n                const iota = (alpha < 0) ? (1.0 / delta) : (-1.0 / delta);\n                this.appendCosSinRadians(lambda * beta, lambda * gamma, cosValues, sinValues, radiansValues);\n                this.appendCosSinRadians(beta * iota, gamma * iota, cosValues, sinValues, radiansValues);\n                solutionType = 0;\n            }\n            else if (D2 < twoTol) {\n                const delta = Math.sqrt(delta2);\n                const iota = (alpha < 0) ? (1.0 / delta) : (-1.0 / delta);\n                this.appendCosSinRadians(lambda * beta, lambda * gamma, cosValues, sinValues, radiansValues);\n                this.appendCosSinRadians(beta * iota, gamma * iota, cosValues, sinValues, radiansValues);\n                solutionType = 1;\n            }\n            else {\n                const mu = Math.sqrt(D2 / delta2);\n                /* c0,s0 = closest approach of line to origin */\n                const c0 = lambda * beta;\n                const s0 = lambda * gamma;\n                this.appendCosSinRadians(c0 - mu * gamma, s0 + mu * beta, cosValues, sinValues, radiansValues);\n                this.appendCosSinRadians(c0 + mu * gamma, s0 - mu * beta, cosValues, sinValues, radiansValues);\n                solutionType = 2;\n            }\n        }\n        return solutionType;\n    }\n}\nAnalyticRoots._EQN_EPS = 1.0e-9;\nAnalyticRoots._safeDivideFactor = 1.0e-14;\nexport { AnalyticRoots };\n/**\n * Manipulations of polynomials with where `coff[i]` multiplies x^i\n * @internal\n */\nexport class PowerPolynomial {\n    /** Evaluate a standard basis polynomial at `x`, with `degree` possibly less than `coff.length` */\n    static degreeKnownEvaluate(coff, degree, x) {\n        if (degree < 0) {\n            return 0.0;\n        }\n        let p = coff[degree];\n        for (let i = degree - 1; i >= 0; i--)\n            p = x * p + coff[i];\n        return p;\n    }\n    /** Evaluate the standard basis polynomial of degree `coff.length` at `x` */\n    static evaluate(coff, x) {\n        const degree = coff.length - 1;\n        return this.degreeKnownEvaluate(coff, degree, x);\n    }\n    /**\n     * * Accumulate Q*scale into P. Both are treated as full degree.\n     * * (Expect Address exceptions if P is smaller than Q)\n     * * Returns degree of result as determined by comparing trailing coefficients to zero\n     */\n    static accumulate(coffP, coffQ, scaleQ) {\n        let degreeP = coffP.length - 1;\n        const degreeQ = coffQ.length - 1;\n        for (let i = 0; i <= degreeQ; i++) {\n            coffP[i] += scaleQ * coffQ[i];\n        }\n        while (degreeP >= 0 && coffP[degreeP] === 0.0) {\n            degreeP--;\n        }\n        return degreeP;\n    }\n    /** Zero all coefficients */\n    static zero(coff) {\n        for (let i = 0; i < coff.length; i++) {\n            coff[i] = 0.0;\n        }\n    }\n}\n/**\n * manipulation of polynomials with powers of sine and cosine\n * @internal\n */\nclass TrigPolynomial {\n    /**\n     *  Solve a polynomial created from trigonometric condition using\n     * Trig.S, Trig.C, Trig.W.  Solution logic includes inferring angular roots\n     * corresponding zero leading coefficients (roots at infinity)\n     * @param coff Coefficients\n     * @param nominalDegree degree of the polynomial under most complex\n     *     root case.  If there are any zero coefficients up to this degree, a single root\n     *     \"at infinity\" is recorded as its corresponding angular parameter at negative pi/2\n     * @param referenceCoefficient A number which represents the size of coefficients\n     *     at various stages of computation.  A small fraction of this will be used as a zero\n     *     tolerance\n     * @param angles Roots are placed here. Assumed preallocated with adequate size.\n     * @param numRoots Number of roots  .  Zero roots is possible. (Passed as array of size\n     * one to pass-by-reference)\n     * Returns false if equation is all zeros.   This usually means any angle is a solution.\n     */\n    static solveAngles(coff, nominalDegree, referenceCoefficient, radians) {\n        let maxCoff = Math.abs(referenceCoefficient);\n        let a;\n        radians.length = 0;\n        const relTol = this._smallAngle;\n        for (let i = 0; i <= nominalDegree; i++) {\n            a = Math.abs(coff[i]);\n            if (a > maxCoff) {\n                maxCoff = a;\n            }\n        }\n        const coffTol = relTol * maxCoff;\n        let degree = nominalDegree;\n        while (degree > 0 && (Math.abs(coff[degree]) <= coffTol)) {\n            degree--;\n        }\n        // let status = false;\n        const roots = new GrowableFloat64Array();\n        if (degree === -1) {\n            // Umm.   Dunno.   Nothing there.\n            // status = false;\n        }\n        else {\n            // status = true;\n            if (degree === 0) {\n                // p(t) is a nonzero constant\n                // No roots, but not degenerate.\n                // status = true;\n            }\n            else if (degree === 1) {\n                // p(t) = coff[1] * t + coff[0]\n                roots.push(-coff[0] / coff[1]);\n            }\n            else if (degree === 2) {\n                AnalyticRoots.appendQuadraticRoots(coff, roots);\n            }\n            else if (degree === 3) {\n                AnalyticRoots.appendCubicRoots(coff, roots);\n            }\n            else if (degree === 4) {\n                AnalyticRoots.appendQuarticRoots(coff, roots);\n            }\n            else {\n                // TODO: WILL WORK WITH BEZIER SOLVER\n                // status = false;\n            }\n            if (roots.length > 0) {\n                // Each solution t represents an angle with\n                //  Math.Cos(theta)=C(t)/W(t),  ,sin(theta)=S(t)/W(t)\n                // Division by W has no effect on Atan2 calculations, so we just compute S(t),C(t)\n                for (let i = 0; i < roots.length; i++) {\n                    const ss = PowerPolynomial.evaluate(this.S, roots.atUncheckedIndex(i));\n                    const cc = PowerPolynomial.evaluate(this.C, roots.atUncheckedIndex(i));\n                    radians.push(Math.atan2(ss, cc));\n                }\n                // Each leading zero at the front of the coefficients corresponds to a root at -PI/2.\n                // Only make one entry....\n                // for (int i = degree; i < nominalDegree; i++)\n                if (degree < nominalDegree) {\n                    radians.push(-0.5 * Math.PI);\n                }\n            }\n        }\n        return radians.length > 0;\n    }\n    /**\n     * Compute intersections of unit circle `x^2 + y^2 = 1` with general quadric\n     * `axx * x^2 + axy * x * y + ayy * y^2 + ax * x + ay * y + a1 = 0`\n     * Solutions are returned as angles. Sine and Cosine of the angles are the x, y results.\n     * @param axx  Coefficient of x^2\n     * @param axy  Coefficient of xy\n     * @param ayy  Coefficient of y^2\n     * @param ax  Coefficient of x\n     * @param ay  Coefficient of y\n     * @param a1  Constant coefficient\n     * @param radians  solution angles\n     * @param numAngle  number of solution angles(Passed as array to make changes to reference)\n     */\n    static solveUnitCircleImplicitQuadricIntersection(axx, axy, ayy, ax, ay, a1, radians) {\n        const Coffs = new Float64Array(5);\n        PowerPolynomial.zero(Coffs);\n        let degree;\n        if (Geometry.hypotenuseXYZ(axx, axy, ayy) > TrigPolynomial._coefficientRelTol * Geometry.hypotenuseXYZ(ax, ay, a1)) {\n            PowerPolynomial.accumulate(Coffs, this.CW, ax);\n            PowerPolynomial.accumulate(Coffs, this.SW, ay);\n            PowerPolynomial.accumulate(Coffs, this.WW, a1);\n            PowerPolynomial.accumulate(Coffs, this.SS, ayy);\n            PowerPolynomial.accumulate(Coffs, this.CC, axx);\n            PowerPolynomial.accumulate(Coffs, this.SC, axy);\n            degree = 4;\n        }\n        else {\n            PowerPolynomial.accumulate(Coffs, this.C, ax);\n            PowerPolynomial.accumulate(Coffs, this.S, ay);\n            PowerPolynomial.accumulate(Coffs, this.W, a1);\n            degree = 2;\n        }\n        let maxCoff = 0.0;\n        maxCoff = Math.max(maxCoff, Math.abs(axx), Math.abs(ayy), Math.abs(axy), Math.abs(ax), Math.abs(ay), Math.abs(a1));\n        const b = this.solveAngles(Coffs, degree, maxCoff, radians);\n        /*\n        for (const theta of angles) {\n          const c = theta.cos();\n          const s = theta.sin();\n          GeometryCoreTestIO.consoleLog({\n            angle: theta, co: c, si: s,\n            f: axx * c * c + axy * c * s + ayy * s * s + ax * c + ay * s + a1});\n      } */\n        return b;\n    }\n    /**\n     * Compute intersections of unit circle x^2 + y 2 = 1 with the ellipse\n     *         (x,y) = (cx + ux Math.Cos + vx sin, cy + uy Math.Cos + vy sin)\n     * Solutions are returned as angles in the ellipse space.\n     * @param cx center x\n     * @param cy center y\n     * @param ux 0 degree vector x\n     * @param uy 0 degree vector y\n     * @param vx 90 degree vector x\n     * @param vy 90 degree vector y\n     * @param ellipseRadians solution angles in ellipse parameter space\n     * @param circleRadians solution angles in circle parameter space\n     */\n    static solveUnitCircleEllipseIntersection(cx, cy, ux, uy, vx, vy, ellipseRadians, circleRadians) {\n        circleRadians.length = 0;\n        const acc = ux * ux + uy * uy;\n        const acs = 2.0 * (ux * vx + uy * vy);\n        const ass = vx * vx + vy * vy;\n        const ac = 2.0 * (ux * cx + uy * cy);\n        const asi = 2.0 * (vx * cx + vy * cy);\n        const a = cx * cx + cy * cy - 1.0;\n        const status = this.solveUnitCircleImplicitQuadricIntersection(acc, acs, ass, ac, asi, a, ellipseRadians);\n        for (const radians of ellipseRadians) {\n            const cc = Math.cos(radians);\n            const ss = Math.sin(radians);\n            const x = cx + ux * cc + vx * ss;\n            const y = cy + uy * cc + vy * ss;\n            circleRadians.push(Math.atan2(y, x));\n        }\n        return status;\n    }\n    /**\n     * Compute intersections of unit circle x^2 + y^2 = w^2 with the ellipse\n     *         (x,y) = (cx + ux Math.Cos + vx sin, cy + uy Math.Cos + vy sin)/ (cw + uw Math.Cos + vw * Math.Sin)\n     * Solutions are returned as angles in the ellipse space.\n     * @param cx center x\n     * @param cy center y\n     * @param cw center w\n     * @param ux 0 degree vector x\n     * @param uy 0 degree vector y\n     * @param uw 0 degree vector w\n     * @param vx 90 degree vector x\n     * @param vy 90 degree vector y\n     * @param vw 90 degree vector w\n     * @param ellipseRadians solution angles in ellipse parameter space\n     * @param circleRadians solution angles in circle parameter space\n     */\n    static solveUnitCircleHomogeneousEllipseIntersection(cx, cy, cw, ux, uy, uw, vx, vy, vw, ellipseRadians, circleRadians) {\n        circleRadians.length = 0;\n        const acc = ux * ux + uy * uy - uw * uw;\n        const acs = 2.0 * (ux * vx + uy * vy - uw * vw);\n        const ass = vx * vx + vy * vy - vw * vw;\n        const ac = 2.0 * (ux * cx + uy * cy - uw * cw);\n        const asi = 2.0 * (vx * cx + vy * cy - vw * cw);\n        const a = cx * cx + cy * cy - cw * cw;\n        const status = this.solveUnitCircleImplicitQuadricIntersection(acc, acs, ass, ac, asi, a, ellipseRadians);\n        for (const radians of ellipseRadians) {\n            const cc = Math.cos(radians);\n            const ss = Math.sin(radians);\n            const x = cx + ux * cc + vx * ss;\n            const y = cy + uy * cc + vy * ss;\n            circleRadians.push(Math.atan2(y, x));\n        }\n        return status;\n    }\n}\n// tolerance for small angle decision.\nTrigPolynomial._smallAngle = 1.0e-11;\n/** Standard Basis coefficients for rational sine numerator. */\nTrigPolynomial.S = Float64Array.from([0.0, 2.0, -2.0]);\n/** Standard Basis coefficients for rational cosine numerator. */\nTrigPolynomial.C = Float64Array.from([1.0, -2.0]);\n/** Standard Basis coefficients for rational denominator. */\nTrigPolynomial.W = Float64Array.from([1.0, -2.0, 2.0]);\n/** Standard Basis coefficients for cosine*weight numerator */\nTrigPolynomial.CW = Float64Array.from([1.0, -4.0, 6.0, -4.0]);\n/** Standard Basis coefficients for sine*weight numerator */\nTrigPolynomial.SW = Float64Array.from([0.0, 2.0, -6.0, 8.0, -4.0]);\n/** Standard Basis coefficients for sine*cosine numerator */\nTrigPolynomial.SC = Float64Array.from([0.0, 2.0, -6.0, 4.0]);\n/** Standard Basis coefficients for sine^2 numerator */\nTrigPolynomial.SS = Float64Array.from([0.0, 0.0, 4.0, -8.0, 4.0]);\n/** Standard Basis coefficients for cosine^2 numerator */\nTrigPolynomial.CC = Float64Array.from([1.0, -4.0, 4.0]);\n/** Standard Basis coefficients for weight^2 */\nTrigPolynomial.WW = Float64Array.from([1.0, -4.0, 8.0, -8.0, 4.0]);\n/** Standard Basis coefficients for (Math.Cos^2 - sine^2) numerator */\nTrigPolynomial.CCminusSS = Float64Array.from([1.0, -4.0, 0.0, 8.0, -4.0]);\nTrigPolynomial._coefficientRelTol = 1.0e-12;\nexport { TrigPolynomial };\n/**\n * static methods for commonly appearing sets of equations in 2 or 3 variables\n * @public\n */\nexport class SmallSystem {\n    /**\n     * Return true if lines (a0,a1) to (b0, b1) have a simple intersection.\n     * Return the fractional (not xy) coordinates in result.x, result.y\n     * @param a0 start point of line a\n     * @param a1  end point of line a\n     * @param b0  start point of line b\n     * @param b1 end point of line b\n     * @param result point to receive fractional coordinates of intersection.   result.x is fraction on line a. result.y is fraction on line b.\n     */\n    static lineSegment2dXYTransverseIntersectionUnbounded(a0, a1, b0, b1, result) {\n        const ux = a1.x - a0.x;\n        const uy = a1.y - a0.y;\n        const vx = b1.x - b0.x;\n        const vy = b1.y - b0.y;\n        const cx = b0.x - a0.x;\n        const cy = b0.y - a0.y;\n        const uv = Geometry.crossProductXYXY(ux, uy, vx, vy);\n        const cv = Geometry.crossProductXYXY(cx, cy, vx, vy);\n        const cu = Geometry.crossProductXYXY(ux, uy, cx, cy);\n        const s = Geometry.conditionalDivideFraction(cv, uv);\n        const t = Geometry.conditionalDivideFraction(cu, uv);\n        if (s !== undefined && t !== undefined) {\n            result.set(s, -t);\n            return true;\n        }\n        result.set(0, 0);\n        return false;\n    }\n    /**\n     * * (ax0,ay0) to (ax0+ux,ay0+uy) are line A.\n     * * (bx0,by0) to (bx0+vx,by0+vy) are lineB.\n     * * Return true if the lines have a simple intersection.\n     * * Return the fractional (not xy) coordinates in result.x, result.y\n     * @param result point to receive fractional coordinates of intersection.   result.x is fraction on line a. result.y is fraction on line b.\n     */\n    static lineSegmentXYUVTransverseIntersectionUnbounded(ax0, ay0, ux, uy, bx0, by0, vx, vy, result) {\n        const cx = bx0 - ax0;\n        const cy = by0 - ay0;\n        const uv = Geometry.crossProductXYXY(ux, uy, vx, vy);\n        const cv = Geometry.crossProductXYXY(cx, cy, vx, vy);\n        const cu = Geometry.crossProductXYXY(ux, uy, cx, cy);\n        const s = Geometry.conditionalDivideFraction(cv, uv);\n        const t = Geometry.conditionalDivideFraction(cu, uv);\n        if (s !== undefined && t !== undefined) {\n            result.set(s, -t);\n            return true;\n        }\n        result.set(0, 0);\n        return false;\n    }\n    /**\n     * Return true if lines (a0,a1) to (b0, b1) have a simple intersection using only xy parts\n     * Return the fractional (not xy) coordinates in result.x, result.y\n     * @param a0 start point of line a\n     * @param a1  end point of line a\n     * @param b0  start point of line b\n     * @param b1 end point of line b\n     * @param result point to receive fractional coordinates of intersection.   result.x is fraction on line a. result.y is fraction on line b.\n     */\n    static lineSegment3dXYTransverseIntersectionUnbounded(a0, a1, b0, b1, result) {\n        const ux = a1.x - a0.x;\n        const uy = a1.y - a0.y;\n        const vx = b1.x - b0.x;\n        const vy = b1.y - b0.y;\n        const cx = b0.x - a0.x;\n        const cy = b0.y - a0.y;\n        const uv = Geometry.crossProductXYXY(ux, uy, vx, vy);\n        const cv = Geometry.crossProductXYXY(cx, cy, vx, vy);\n        const cu = Geometry.crossProductXYXY(ux, uy, cx, cy);\n        const s = Geometry.conditionalDivideFraction(cv, uv);\n        const t = Geometry.conditionalDivideFraction(cu, uv);\n        if (s !== undefined && t !== undefined) {\n            result.set(s, -t);\n            return true;\n        }\n        result.set(0, 0);\n        return false;\n    }\n    /**\n     * Return true if lines (a0,a1) to (b0, b1) have a simple intersection using only xy parts of WEIGHTED 4D Points\n     * Return the fractional (not xy) coordinates in result.x, result.y\n     * @param hA0 homogeneous start point of line a\n     * @param hA1 homogeneous end point of line a\n     * @param hB0 homogeneous start point of line b\n     * @param hB1 homogeneous end point of line b\n     * @param result point to receive fractional coordinates of intersection.   result.x is fraction on line a. result.y is fraction on line b.\n     */\n    static lineSegment3dHXYTransverseIntersectionUnbounded(hA0, hA1, hB0, hB1, result) {\n        // Considering only x,y,w parts....\n        // Point Q along B is (in full homogeneous)  `(1-lambda) B0 + lambda 1`\n        // PointQ is colinear with A0,A1 when the determinant det (A0,A1,Q) is zero.  (Each column takes xyw parts)\n        const alpha0 = Geometry.tripleProduct(hA0.x, hA1.x, hB0.x, hA0.y, hA1.y, hB0.y, hA0.w, hA1.w, hB0.w);\n        const alpha1 = Geometry.tripleProduct(hA0.x, hA1.x, hB1.x, hA0.y, hA1.y, hB1.y, hA0.w, hA1.w, hB1.w);\n        const fractionB = Geometry.conditionalDivideFraction(-alpha0, alpha1 - alpha0);\n        if (fractionB !== undefined) {\n            const beta0 = Geometry.tripleProduct(hB0.x, hB1.x, hA0.x, hB0.y, hB1.y, hA0.y, hB0.w, hB1.w, hA0.w);\n            const beta1 = Geometry.tripleProduct(hB0.x, hB1.x, hA1.x, hB0.y, hB1.y, hA1.y, hB0.w, hB1.w, hA1.w);\n            const fractionA = Geometry.conditionalDivideFraction(-beta0, beta1 - beta0);\n            if (fractionA !== undefined)\n                return Vector2d.create(fractionA, fractionB, result);\n        }\n        return undefined;\n    }\n    /**\n     * Return the line fraction at which the (homogeneous) line is closest to a space point as viewed in xy only.\n     * @param hA0 homogeneous start point of line a\n     * @param hA1 homogeneous end point of line a\n     * @param spacePoint homogeneous point in space\n     */\n    static lineSegment3dHXYClosestPointUnbounded(hA0, hA1, spacePoint) {\n        // Considering only x,y,w parts....\n        // weighted difference of (A1 w0 - A0 w1) is (cartesian) tangent vector along the line as viewed.\n        // The perpendicular (pure vector) W = (-y,x) flip is the direction of projection\n        // Point Q along A is (in full homogeneous)  `(1-lambda) A0 + lambda 1 A1`\n        // PointQ is colinear with spacePoint and and W when the xyw homogeneous determinant | Q W spacePoint | is zero.\n        const tx = hA1.x * hA0.w - hA0.x * hA1.w;\n        const ty = hA1.y * hA0.w - hA0.y * hA1.w;\n        const det0 = Geometry.tripleProduct(hA0.x, -ty, spacePoint.x, hA0.y, tx, spacePoint.y, hA0.w, 0, spacePoint.w);\n        const det1 = Geometry.tripleProduct(hA1.x, -ty, spacePoint.x, hA1.y, tx, spacePoint.y, hA1.w, 0, spacePoint.w);\n        return Geometry.conditionalDivideFraction(-det0, det1 - det0);\n    }\n    /**\n     * Return the line fraction at which the line is closest to a space point as viewed in xy only.\n     * @param pointA0 start point\n     * @param pointA1 end point\n     * @param spacePoint homogeneous point in space\n     */\n    static lineSegment3dXYClosestPointUnbounded(pointA0, pointA1, spacePoint) {\n        // Considering only x,y parts....\n        const ux = pointA1.x - pointA0.x;\n        const uy = pointA1.y - pointA0.y;\n        const uu = ux * ux + uy * uy;\n        const vx = spacePoint.x - pointA0.x;\n        const vy = spacePoint.y - pointA0.y;\n        const uv = ux * vx + uy * vy;\n        return Geometry.conditionalDivideFraction(uv, uu);\n    }\n    /**\n     * Return the line fraction at which the line is closest to a space point\n     * @param pointA0 start point\n     * @param pointA1 end point\n     * @param spacePoint homogeneous point in space\n     */\n    static lineSegment3dClosestPointUnbounded(pointA0, pointA1, spacePoint) {\n        const ux = pointA1.x - pointA0.x;\n        const uy = pointA1.y - pointA0.y;\n        const uz = pointA1.z - pointA0.z;\n        const uu = ux * ux + uy * uy + uz * uz;\n        const vx = spacePoint.x - pointA0.x;\n        const vy = spacePoint.y - pointA0.y;\n        const vz = spacePoint.z - pointA0.z;\n        const uv = ux * vx + uy * vy + uz * vz;\n        return Geometry.conditionalDivideFraction(uv, uu);\n    }\n    /**\n     * Return true if lines (a0,a1) to (b0, b1) have closest approach (go by each other) in 3d\n     * Return the fractional (not xy) coordinates in result.x, result.y\n     * @param a0 start point of line a\n     * @param a1  end point of line a\n     * @param b0  start point of line b\n     * @param b1 end point of line b\n     * @param result point to receive fractional coordinates of intersection.   result.x is fraction on line a. result.y is fraction on line b.\n     */\n    static lineSegment3dClosestApproachUnbounded(a0, a1, b0, b1, result) {\n        return this.ray3dXYZUVWClosestApproachUnbounded(a0.x, a0.y, a0.z, a1.x - a0.x, a1.y - a0.y, a1.z - a0.z, b0.x, b0.y, b0.z, b1.x - b0.x, b1.y - b0.y, b1.z - b0.z, result);\n    }\n    /**\n     * Return true if lines (a0,a1) to (b0, b1) have closest approach (go by each other) in 3d\n     * Return the fractional (not xy) coordinates as x and y parts of a Point2d.\n     * @param result point to receive fractional coordinates of intersection.   result.x is fraction on line a. result.y is fraction on line b.\n     */\n    static ray3dXYZUVWClosestApproachUnbounded(ax, ay, az, au, av, aw, bx, by, bz, bu, bv, bw, result) {\n        const cx = bx - ax;\n        const cy = by - ay;\n        const cz = bz - az;\n        const uu = Geometry.hypotenuseSquaredXYZ(au, av, aw);\n        const vv = Geometry.hypotenuseSquaredXYZ(bu, bv, bw);\n        const uv = Geometry.dotProductXYZXYZ(au, av, aw, bu, bv, bw);\n        const cu = Geometry.dotProductXYZXYZ(cx, cy, cz, au, av, aw);\n        const cv = Geometry.dotProductXYZXYZ(cx, cy, cz, bu, bv, bw);\n        return SmallSystem.linearSystem2d(uu, -uv, uv, -vv, cu, cv, result);\n    }\n    /**\n     * Solve the pair of linear equations\n     * * `ux * x + vx + y = cx`\n     * * `uy * x + vy * y = cy`\n     * @param ux xx coefficient\n     * @param vx xy coefficient\n     * @param uy yx coefficient\n     * @param vy yy coefficient\n     * @param cx x right hand side\n     * @param cy y right hand side\n     * @param result (x,y) solution.  (MUST be preallocated by caller)\n     */\n    static linearSystem2d(ux, vx, // first row of matrix\n    uy, vy, // second row of matrix\n    cx, cy, // right side\n    result) {\n        const uv = Geometry.crossProductXYXY(ux, uy, vx, vy);\n        const cv = Geometry.crossProductXYXY(cx, cy, vx, vy);\n        const cu = Geometry.crossProductXYXY(ux, uy, cx, cy);\n        const s = Geometry.conditionalDivideFraction(cv, uv);\n        const t = Geometry.conditionalDivideFraction(cu, uv);\n        if (s !== undefined && t !== undefined) {\n            result.set(s, t);\n            return true;\n        }\n        result.set(0, 0);\n        return false;\n    }\n    /**\n     * Solve a linear system\n     * * x equation: `ux *u * vx * v + wx * w = cx`\n     * * y equation: `uy *u * vy * v + wy * w = cy`\n     * * z equation: `uz *u * vz * v + wz * w = cz`\n     * @param axx row 0, column 0 coefficient\n     * @param axy row 0, column 1 coefficient\n     * @param axz row 0, column 1 coefficient\n     * @param ayx row 1, column 0 coefficient\n     * @param ayy row 1, column 1 coefficient\n     * @param ayz row 1, column 2 coefficient\n     * @param azx row 2, column 0 coefficient\n     * @param azy row 2, column 1 coefficient\n     * @param azz row 2, column 2 coefficient\n     * @param cx right hand side row 0 coefficient\n     * @param cy right hand side row 1 coefficient\n     * @param cz right hand side row 2 coefficient\n     * @param result optional result.\n     */\n    static linearSystem3d(axx, axy, axz, // first row of matrix\n    ayx, ayy, ayz, // second row of matrix\n    azx, azy, azz, // second row of matrix\n    cx, cy, cz, // right side\n    result) {\n        // determinants of various combinations of columns ...\n        const detXYZ = Geometry.tripleProduct(axx, ayx, azx, axy, ayy, azy, axz, ayz, azz);\n        const detCYZ = Geometry.tripleProduct(cx, cy, cz, axy, ayy, azy, axz, ayz, azz);\n        const detXCZ = Geometry.tripleProduct(axx, ayx, azx, cx, cy, cz, axz, ayz, azz);\n        const detXYC = Geometry.tripleProduct(axx, ayx, azx, axy, ayy, azy, cx, cy, cz);\n        const s = Geometry.conditionalDivideFraction(detCYZ, detXYZ);\n        const t = Geometry.conditionalDivideFraction(detXCZ, detXYZ);\n        const u = Geometry.conditionalDivideFraction(detXYC, detXYZ);\n        if (s !== undefined && t !== undefined && u !== undefined) {\n            return Vector3d.create(s, t, u, result);\n        }\n        return undefined;\n    }\n    /**\n     * Compute the intersection of three planes.\n     * @param xyzA point on the first plane\n     * @param normalA normal of the first plane\n     * @param xyzB point on the second plane\n     * @param normalB normal of the second plane\n     * @param xyzC point on the third plane\n     * @param normalC normal of the third plane\n     * @param result optional result\n     * @returns intersection point of the three planes (as a Vector3d), or undefined if at least two planes are parallel.\n     */\n    static intersect3Planes(xyzA, normalA, xyzB, normalB, xyzC, normalC, result) {\n        return this.linearSystem3d(normalA.x, normalA.y, normalA.z, normalB.x, normalB.y, normalB.z, normalC.x, normalC.y, normalC.z, Geometry.dotProductXYZXYZ(xyzA.x, xyzA.y, xyzA.z, normalA.x, normalA.y, normalA.z), Geometry.dotProductXYZXYZ(xyzB.x, xyzB.y, xyzB.z, normalB.x, normalB.y, normalB.z), Geometry.dotProductXYZXYZ(xyzC.x, xyzC.y, xyzC.z, normalC.x, normalC.y, normalC.z), result);\n    }\n    /**\n     * * in rowB, replace `rowB[j] += a * rowB[pivot] * rowA[j] / rowA[pivot]` for `j>pivot`\n     * @param rowA row that does not change\n     * @param pivotIndex index of pivot (divisor) in rowA.\n     * @param rowB row where elimination occurs.\n     */\n    static eliminateFromPivot(rowA, pivotIndex, rowB, a) {\n        const n = rowA.length;\n        let q = Geometry.conditionalDivideFraction(rowB[pivotIndex], rowA[pivotIndex]);\n        if (q === undefined)\n            return false;\n        q *= a;\n        for (let j = pivotIndex + 1; j < n; j++)\n            rowB[j] += q * rowA[j];\n        return true;\n    }\n    /**\n     * Solve a pair of bilinear equations\n     * * First equation: `a0 + b0 * u + c0 * v + d0 * u * v = 0`\n     * * Second equation: `a0 + b0 * u + c0 * v + d0 * u * v = 0`\n     */\n    static solveBilinearPair(a0, b0, c0, d0, a1, b1, c1, d1) {\n        // constant linear, and quadratic coefficients for c0 + c1 * u + c2 * u*u = 0\n        const e0 = Geometry.crossProductXYXY(a0, a1, c0, c1);\n        const e1 = Geometry.crossProductXYXY(b0, b1, c0, c1) + Geometry.crossProductXYXY(a0, a1, d0, d1);\n        const e2 = Geometry.crossProductXYXY(b0, b1, d0, d1);\n        const uRoots = Degree2PowerPolynomial.solveQuadratic(e2, e1, e0);\n        if (uRoots === undefined)\n            return undefined;\n        const uv = [];\n        for (const u of uRoots) {\n            const v0 = Geometry.conditionalDivideFraction(-(a0 + b0 * u), c0 + d0 * u);\n            const v1 = Geometry.conditionalDivideFraction(-(a1 + b1 * u), c1 + d1 * u);\n            if (v0 !== undefined)\n                uv.push(Point2d.create(u, v0));\n            else if (v1 !== undefined)\n                uv.push(Point2d.create(u, v1));\n        }\n        return uv;\n    }\n}\n/**\n * * bilinear expression\n * * `f(u,v) = a + b * u * c * v + d * u * v`\n * @internal\n */\nexport class BilinearPolynomial {\n    /**\n     *\n     * @param a constant coefficient\n     * @param b `u` coefficient\n     * @param c `v` coefficient\n     * @param d `u*v` coefficient\n     */\n    constructor(a, b, c, d) {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n    }\n    /**\n     * Evaluate the bilinear expression at u,v\n     */\n    evaluate(u, v) {\n        return this.a + this.b * u + v * (this.c + this.d * u);\n    }\n    /** Create a bilinear polynomial z=f(u,v) given z values at 00, 10, 01, 11.\n     */\n    static createUnitSquareValues(f00, f10, f01, f11) {\n        return new BilinearPolynomial(f00, f10, f10, f11 - f10 - f01);\n    }\n    /**\n     * Solve the simultaneous equations\n     * * `p(u,v) = pValue`\n     * * `q(u,v) = qValue`\n     * @param p\n     * @param pValue\n     * @param q\n     * @param qValue\n     */\n    static solvePair(p, pValue, q, qValue) {\n        return SmallSystem.solveBilinearPair(p.a - pValue, p.b, p.c, p.d, q.a - qValue, q.b, q.c, q.d);\n    }\n}\n/**\n * * trigonometric expresses `f(theta) = a + cosineCoff * cos(theta) + sineCoff * sin(theta)`\n * @internal\n */\nexport class SineCosinePolynomial {\n    /**\n     *\n     * @param a constant coefficient\n     * @param cosineCoff `cos(theta)` coefficient\n     * @param sinCoff `sin(theta)` coefficient\n     */\n    constructor(a, cosCoff, sinCoff) {\n        this.a = a;\n        this.cosineCoff = cosCoff;\n        this.sineCoff = sinCoff;\n    }\n    /** set all coefficients */\n    set(a, cosCoff, sinCoff) {\n        this.a = a;\n        this.cosineCoff = cosCoff;\n        this.sineCoff = sinCoff;\n    }\n    /** Return the function value at given angle in radians */\n    evaluateRadians(theta) {\n        return this.a + this.cosineCoff * Math.cos(theta) + this.sineCoff * Math.sin(theta);\n    }\n    /** Return the range of function values over the entire angle range. */\n    range(result) {\n        const q = Geometry.hypotenuseXY(this.cosineCoff, this.sineCoff);\n        return Range1d.createXX(this.a - q, this.a + q, result);\n    }\n    /** Return the min and max values of the function over theta range from radians0 to radians1  inclusive. */\n    rangeInStartEndRadians(radians0, radians1, result) {\n        if (Angle.isFullCircleRadians(radians1 - radians0))\n            return this.range(result);\n        result = Range1d.createXX(this.evaluateRadians(radians0), this.evaluateRadians(radians1), result);\n        // angles of min and max ...\n        // angles for min and max of the sine wave . ..\n        const alphaA = Math.atan2(this.sineCoff, this.cosineCoff);\n        const alphaB = alphaA + Math.PI;\n        if (AngleSweep.isRadiansInStartEnd(alphaA, radians0, radians1))\n            result.extendX(this.evaluateRadians(alphaA));\n        if (AngleSweep.isRadiansInStartEnd(alphaB, radians0, radians1))\n            result.extendX(this.evaluateRadians(alphaB));\n        return result;\n    }\n    /** Return the min and max values of the function over theta range from radians0 to radians1  inclusive. */\n    rangeInSweep(sweep, result) {\n        return this.rangeInStartEndRadians(sweep.startRadians, sweep.endRadians, result);\n    }\n    /**\n     * Return a representative angle (in radians) for min and max values.\n     * * The radians value is atan2(sineCoff, cosineCoff)\n     * * Hence the candidates for min and max of the function are at this value and this value plus PI\n     */\n    referenceMinMaxRadians() {\n        return Math.atan2(this.sineCoff, this.cosineCoff);\n    }\n}\n/**\n * Support for an implicit linear equation (half space)\n * f(x,y) = a0 + x * ax + y * ay\n * @internal\n */\nexport class ImplicitLineXY {\n    /** construct the ImplicitLineXY from coefficients */\n    constructor(a, ax, ay) {\n        this.a = a;\n        this.ax = ax;\n        this.ay = ay;\n    }\n    /** Compute 2 points of a line segment with\n     * * the segment is on the zero-line of this ImplicitLineXY\n     * * the start and endpoints are distance `b` from the projection of the origin onto the ImplicitLineXY\n     * @returns undefined if ax,ay are both zero.   Otherwise the two points of the segment.\n     */\n    convertToSegmentPoints(b) {\n        const q = Math.sqrt(this.ax * this.ax + this.ay * this.ay);\n        const alpha = Geometry.conditionalDivideCoordinate(1.0, q, 1.0e10);\n        if (alpha === undefined)\n            return undefined;\n        const ux = alpha * this.ax;\n        const uy = alpha * this.ay;\n        const px = -alpha * ux;\n        const py = -alpha * uy;\n        return [Point3d.create(px - b * uy, py + b * ux), Point3d.create(px + b * uy, py - b * ux)];\n    }\n    /**\n     * Evaluate the half-space function at an xy point\n     * @param xy xy values for evaluation\n     * @returns evaluation.\n     */\n    evaluatePoint(xy) {\n        return this.a + xy.x * this.ax + xy.y * this.ay;\n    }\n    /**\n     * add scale * (a,ax,ay) to the respective coefficients.\n     */\n    addScaledCoefficientsInPlace(a, ax, ay, scale) {\n        this.a += scale * a;\n        this.ax += scale * ax;\n        this.ay += scale * ay;\n    }\n}\n//# sourceMappingURL=Polynomials.js.map",
      "start": 1693508123480,
      "end": 1693508123633,
      "sourcemaps": null
    }
  ]
}
