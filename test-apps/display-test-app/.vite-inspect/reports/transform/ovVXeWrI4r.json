{
  "resolvedId": "D:/hub2023A/itwinjs-core/ui/appui-abstract/lib/esm/appui-abstract/utils/filter/filters.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Utilities\n */\nimport { LRUCache } from \"./map\";\nimport * as strings from \"./strings\";\n// Combined filters\n/**\n * @returns A filter which combines the provided set\n * of filters with an or. The *first* filters that\n * matches defined the return value of the returned\n * filter.\n * @internal\n */\nexport function or(...filter) {\n    return function (word, wordToMatchAgainst) {\n        for (let i = 0, len = filter.length; i < len; i++) {\n            const match = filter[i](word, wordToMatchAgainst);\n            if (match) {\n                return match;\n            }\n        }\n        return null;\n    };\n}\n// Prefix\n/** @internal */\nexport const matchesStrictPrefix = _matchesPrefix.bind(undefined, false);\n/** @internal */\nexport const matchesPrefix = _matchesPrefix.bind(undefined, true);\nfunction _matchesPrefix(ignoreCase, word, wordToMatchAgainst) {\n    if (!wordToMatchAgainst || wordToMatchAgainst.length < word.length) {\n        return null;\n    }\n    let matches;\n    if (ignoreCase) {\n        matches = strings.startsWithIgnoreCase(wordToMatchAgainst, word);\n    }\n    else {\n        matches = wordToMatchAgainst.indexOf(word) === 0;\n    }\n    if (!matches) {\n        return null;\n    }\n    return word.length > 0 ? [{ start: 0, end: word.length }] : [];\n}\n// Contiguous Substring\n/** @internal */\nexport function matchesContiguousSubString(word, wordToMatchAgainst) {\n    const index = wordToMatchAgainst.toLowerCase().indexOf(word.toLowerCase());\n    if (index === -1) {\n        return null;\n    }\n    return [{ start: index, end: index + word.length }];\n}\n// Substring\n/**\n * Return case insensitive substring matches\n * @param word filter string\n * @param wordToMatchAgainst string to test\n * @internal\n */\nexport function matchesSubString(word, wordToMatchAgainst) {\n    return _matchesSubString(word.toLowerCase(), wordToMatchAgainst.toLowerCase(), 0, 0);\n}\nfunction _matchesSubString(word, wordToMatchAgainst, i, j) {\n    if (i === word.length) {\n        return [];\n    }\n    else if (j === wordToMatchAgainst.length) {\n        return null;\n    }\n    else {\n        if (word[i] === wordToMatchAgainst[j]) {\n            let result = null;\n            if (result = _matchesSubString(word, wordToMatchAgainst, i + 1, j + 1)) {\n                return join({ start: j, end: j + 1 }, result);\n            }\n            return null;\n        }\n        return _matchesSubString(word, wordToMatchAgainst, i, j + 1);\n    }\n}\n// CamelCase\nfunction isLower(code) {\n    return 97 /* CharCode.a */ <= code && code <= 122 /* CharCode.z */;\n}\nfunction isUpper(code) {\n    return 65 /* CharCode.A */ <= code && code <= 90 /* CharCode.Z */;\n}\nfunction isNumber(code) {\n    return 48 /* CharCode.Digit0 */ <= code && code <= 57 /* CharCode.Digit9 */;\n}\nfunction isWhitespace(code) {\n    return (code === 32 /* CharCode.Space */\n        || code === 9 /* CharCode.Tab */\n        || code === 10 /* CharCode.LineFeed */\n        || code === 13 /* CharCode.CarriageReturn */);\n}\nconst wordSeparators = new Set();\n'`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?'\n    .split(\"\")\n    .forEach((s) => wordSeparators.add(s.charCodeAt(0)));\nfunction isWordSeparator(code) {\n    return isWhitespace(code) || wordSeparators.has(code);\n}\nfunction charactersMatch(codeA, codeB) {\n    return (codeA === codeB) || (isWordSeparator(codeA) && isWordSeparator(codeB));\n}\nfunction isAlphanumeric(code) {\n    return isLower(code) || isUpper(code) || isNumber(code);\n}\nfunction join(head, tail) {\n    if (tail.length === 0) {\n        tail = [head];\n    }\n    else if (head.end === tail[0].start) {\n        tail[0].start = head.start;\n    }\n    else {\n        tail.unshift(head);\n    }\n    return tail;\n}\nfunction nextAnchor(camelCaseWord, start) {\n    for (let i = start; i < camelCaseWord.length; i++) {\n        const c = camelCaseWord.charCodeAt(i);\n        if (isUpper(c) || isNumber(c) || (i > 0 && !isAlphanumeric(camelCaseWord.charCodeAt(i - 1)))) {\n            return i;\n        }\n    }\n    return camelCaseWord.length;\n}\nfunction _matchesCamelCase(word, camelCaseWord, i, j) {\n    if (i === word.length) {\n        return [];\n    }\n    else if (j === camelCaseWord.length) {\n        return null;\n    }\n    else if (word[i] !== camelCaseWord[j].toLowerCase()) {\n        return null;\n    }\n    else {\n        let result = null;\n        let nextUpperIndex = j + 1;\n        result = _matchesCamelCase(word, camelCaseWord, i + 1, j + 1);\n        while (!result && (nextUpperIndex = nextAnchor(camelCaseWord, nextUpperIndex)) < camelCaseWord.length) {\n            result = _matchesCamelCase(word, camelCaseWord, i + 1, nextUpperIndex);\n            nextUpperIndex++;\n        }\n        return result === null ? null : join({ start: j, end: j + 1 }, result);\n    }\n}\n// Heuristic to avoid computing camel case matcher for words that don't\n// look like camelCaseWords.\nfunction analyzeCamelCaseWord(word) {\n    let upper = 0, lower = 0, alpha = 0, numeric = 0, code = 0;\n    for (let i = 0; i < word.length; i++) {\n        code = word.charCodeAt(i);\n        if (isUpper(code)) {\n            upper++;\n        }\n        if (isLower(code)) {\n            lower++;\n        }\n        if (isAlphanumeric(code)) {\n            alpha++;\n        }\n        if (isNumber(code)) {\n            numeric++;\n        }\n    }\n    const upperPercent = upper / word.length;\n    const lowerPercent = lower / word.length;\n    const alphaPercent = alpha / word.length;\n    const numericPercent = numeric / word.length;\n    return { upperPercent, lowerPercent, alphaPercent, numericPercent };\n}\nfunction isUpperCaseWord(analysis) {\n    const { upperPercent, lowerPercent } = analysis;\n    return lowerPercent === 0 && upperPercent > 0.6;\n}\nfunction isCamelCaseWord(analysis) {\n    const { upperPercent, lowerPercent, alphaPercent, numericPercent } = analysis;\n    return lowerPercent > 0.2 && upperPercent < 0.8 && alphaPercent > 0.6 && numericPercent < 0.2;\n}\n// Heuristic to avoid computing camel case matcher for words that don't\n// look like camel case patterns.\nfunction isCamelCasePattern(word) {\n    let upper = 0, lower = 0, code = 0, whitespace = 0;\n    for (let i = 0; i < word.length; i++) {\n        code = word.charCodeAt(i);\n        if (isUpper(code)) {\n            upper++;\n        }\n        if (isLower(code)) {\n            lower++;\n        }\n        if (isWhitespace(code)) {\n            whitespace++;\n        }\n    }\n    if ((upper === 0 || lower === 0) && whitespace === 0) {\n        return word.length <= 30;\n    }\n    else {\n        return upper <= 5;\n    }\n}\n/**\n * Return matches treating \"camelCase\" words separately. For example the filter string \"gp\" would return two matches in string \"Git Pull\".\n * @param word filter string\n * @param wordToMatchAgainst string to test\n * @internal\n */\nexport function matchesCamelCase(word, camelCaseWord) {\n    if (!camelCaseWord) {\n        return null;\n    }\n    camelCaseWord = camelCaseWord.trim();\n    if (camelCaseWord.length === 0) {\n        return null;\n    }\n    if (!isCamelCasePattern(camelCaseWord)) {\n        return null;\n    }\n    if (camelCaseWord.length > 60) {\n        return null;\n    }\n    const analysis = analyzeCamelCaseWord(camelCaseWord);\n    if (!isCamelCaseWord(analysis)) {\n        // istanbul ignore next\n        if (!isUpperCaseWord(analysis)) {\n            return null;\n        }\n        camelCaseWord = camelCaseWord.toLowerCase();\n    }\n    let result = null;\n    let i = 0;\n    word = word.toLowerCase();\n    while (i < camelCaseWord.length && (result = _matchesCamelCase(word, camelCaseWord, 0, i)) === null) {\n        i = nextAnchor(camelCaseWord, i + 1);\n    }\n    return result;\n}\n/**\n * Matches beginning of words supporting non-ASCII languages.\n * @param word Filter string\n * @param target String being searched\n * @param contiguous - If true the filter string must be found \"contiguous\" in the searched string (E.g. \"pul\" will match \"Git: Pull\").\n * Otherwise also matches sub string of the word with beginnings of the words in the target (e.g. \"gp\" or \"g p\" will match \"Git: Pull\").\n * Useful in cases where the target is words (e.g. command labels)\n * @internal\n */\nexport function matchesWords(word, target, contiguous = false) {\n    if (!target || target.length === 0) {\n        return null;\n    }\n    let result = null;\n    let i = 0;\n    word = word.toLowerCase();\n    target = target.toLowerCase();\n    while (i < target.length && (result = _matchesWords(word, target, 0, i, contiguous)) === null) {\n        i = nextWord(target, i + 1);\n    }\n    return result;\n}\nfunction _matchesWords(word, target, i, j, contiguous) {\n    if (i === word.length) {\n        return [];\n    }\n    else if (j === target.length) {\n        return null;\n    }\n    else if (!charactersMatch(word.charCodeAt(i), target.charCodeAt(j))) {\n        return null;\n    }\n    else {\n        let result = null;\n        let nextWordIndex = j + 1;\n        result = _matchesWords(word, target, i + 1, j + 1, contiguous);\n        // istanbul ignore else\n        if (!contiguous) {\n            while (!result && (nextWordIndex = nextWord(target, nextWordIndex)) < target.length) {\n                result = _matchesWords(word, target, i + 1, nextWordIndex, contiguous);\n                nextWordIndex++;\n            }\n        }\n        return result === null ? null : join({ start: j, end: j + 1 }, result);\n    }\n}\nfunction nextWord(word, start) {\n    for (let i = start; i < word.length; i++) {\n        if (isWordSeparator(word.charCodeAt(i)) ||\n            (i > 0 && isWordSeparator(word.charCodeAt(i - 1)))) {\n            return i;\n        }\n    }\n    return word.length;\n}\n// Fuzzy\nconst fuzzyContiguousFilter = or(matchesPrefix, matchesCamelCase, matchesContiguousSubString);\nconst fuzzySeparateFilter = or(matchesPrefix, matchesCamelCase, matchesSubString);\nconst fuzzyRegExpCache = new LRUCache(10000); // bounded to 10000 elements\n/**\n * Match pattern against word in a fuzzy way. This will only return a single match.\n * @internal\n */\nexport function matchesFuzzy(word, wordToMatchAgainst, enableSeparateSubstringMatching = false) {\n    // istanbul ignore next\n    if (typeof word !== \"string\" || typeof wordToMatchAgainst !== \"string\") {\n        return null; // return early for invalid input\n    }\n    // Form RegExp for wildcard matches\n    let regexp = fuzzyRegExpCache.get(word);\n    if (!regexp) {\n        regexp = new RegExp(strings.convertSimple2RegExpPattern(word), \"i\");\n        fuzzyRegExpCache.set(word, regexp);\n    }\n    // RegExp Filter\n    const match = regexp.exec(wordToMatchAgainst);\n    if (match) {\n        return [{ start: match.index, end: match.index + match[0].length }];\n    }\n    // Default Filter\n    return enableSeparateSubstringMatching ? /* istanbul ignore next */ fuzzySeparateFilter(word, wordToMatchAgainst) : fuzzyContiguousFilter(word, wordToMatchAgainst);\n}\n/**\n * Match pattern against word in a fuzzy way. As in IntelliSense and faster and more\n * powerful than `matchesFuzzy`. This will only return a single match.\n * @internal\n */\nexport function matchesFuzzy2(pattern, word) {\n    const score = fuzzyScore(pattern, pattern.toLowerCase(), 0, word, word.toLowerCase(), 0, true);\n    return score ? createMatches(score) : null;\n}\n// #region --- fuzzyScore ---\n/**\n * @internal\n */\nexport function createMatches(score) {\n    // istanbul ignore next\n    if (typeof score === \"undefined\") {\n        return [];\n    }\n    const matches = score[1].toString(2);\n    const wordStart = score[2];\n    const res = [];\n    for (let pos = wordStart; pos < _maxLen; pos++) {\n        if (matches[matches.length - (pos + 1)] === \"1\") {\n            const last = res[res.length - 1];\n            if (last && last.end === pos) {\n                last.end = pos + 1;\n            }\n            else {\n                res.push({ start: pos, end: pos + 1 });\n            }\n        }\n    }\n    return res;\n}\nconst _maxLen = 128;\nfunction initTable() {\n    const table = [];\n    const row = [0];\n    for (let i = 1; i <= _maxLen; i++) {\n        row.push(-i);\n    }\n    for (let i = 0; i <= _maxLen; i++) {\n        const thisRow = row.slice(0);\n        thisRow[0] = -i;\n        table.push(thisRow);\n    }\n    return table;\n}\nconst _table = initTable();\nconst _scores = initTable();\n// eslint-disable-next-line @typescript-eslint/consistent-type-assertions\nconst _arrows = initTable();\nconst _debug = false;\nfunction isSeparatorAtPos(value, index) {\n    if (index < 0 || index >= value.length) {\n        return false;\n    }\n    const code = value.charCodeAt(index);\n    switch (code) {\n        case 95 /* CharCode.Underline */:\n        case 45 /* CharCode.Dash */:\n        case 46 /* CharCode.Period */:\n        case 32 /* CharCode.Space */:\n        case 47 /* CharCode.Slash */:\n        case 92 /* CharCode.Backslash */:\n        case 39 /* CharCode.SingleQuote */:\n        case 34 /* CharCode.DoubleQuote */:\n        case 58 /* CharCode.Colon */:\n        case 36 /* CharCode.DollarSign */:\n            return true;\n        default:\n            return false;\n    }\n}\nfunction isWhitespaceAtPos(value, index) {\n    if (index < 0 || index >= value.length) {\n        return false;\n    }\n    const code = value.charCodeAt(index);\n    switch (code) {\n        // istanbul ignore next\n        case 32 /* CharCode.Space */:\n        case 9 /* CharCode.Tab */:\n            return true;\n        default:\n            return false;\n    }\n}\nfunction isUpperCaseAtPos(pos, word, wordLow) {\n    return word[pos] !== wordLow[pos];\n}\n/** @internal */\nexport function isPatternInWord(patternLow, patternPos, patternLen, wordLow, wordPos, wordLen) {\n    while (patternPos < patternLen && wordPos < wordLen) {\n        if (patternLow[patternPos] === wordLow[wordPos]) {\n            patternPos += 1;\n        }\n        wordPos += 1;\n    }\n    return patternPos === patternLen; // pattern must be exhausted\n}\n/** @internal */\nexport var FuzzyScore;\n(function (FuzzyScore) {\n    /**\n    * No matches and value `-100`\n    * @internal\n    */\n    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n    FuzzyScore.Default = Object.freeze([-100, 0, 0]);\n    // istanbul ignore next\n    /** @internal */\n    function isDefault(score) {\n        return !score || (score[0] === -100 && score[1] === 0 && score[2] === 0);\n    }\n    FuzzyScore.isDefault = isDefault;\n})(FuzzyScore || (FuzzyScore = {}));\n/** @internal */\nexport function fuzzyScore(pattern, patternLow, patternStart, word, wordLow, wordStart, firstMatchCanBeWeak) {\n    // istanbul ignore next\n    const patternLen = pattern.length > _maxLen ? _maxLen : pattern.length;\n    const wordLen = word.length > _maxLen ? _maxLen : word.length;\n    if (patternStart >= patternLen || wordStart >= wordLen || (patternLen - patternStart) > (wordLen - wordStart)) {\n        return undefined;\n    }\n    // Run a simple check if the characters of pattern occur\n    // (in order) at all in word. If that isn't the case we\n    // stop because no match will be possible\n    if (!isPatternInWord(patternLow, patternStart, patternLen, wordLow, wordStart, wordLen)) {\n        return undefined;\n    }\n    let row = 1;\n    let column = 1;\n    let patternPos = patternStart;\n    let wordPos = wordStart;\n    let hasStrongFirstMatch = false;\n    // There will be a match, fill in tables\n    for (row = 1, patternPos = patternStart; patternPos < patternLen; row++, patternPos++) {\n        for (column = 1, wordPos = wordStart; wordPos < wordLen; column++, wordPos++) {\n            const score = _doScore(pattern, patternLow, patternPos, patternStart, word, wordLow, wordPos);\n            if (patternPos === patternStart && score > 1) {\n                hasStrongFirstMatch = true;\n            }\n            _scores[row][column] = score;\n            const diag = _table[row - 1][column - 1] + (score > 1 ? 1 : score);\n            const top = _table[row - 1][column] + -1;\n            const left = _table[row][column - 1] + -1;\n            if (left >= top) {\n                // left or diag\n                if (left > diag) {\n                    _table[row][column] = left;\n                    _arrows[row][column] = 4 /* Arrow.Left */;\n                }\n                else if (left === diag) {\n                    _table[row][column] = left;\n                    _arrows[row][column] = 4 /* Arrow.Left */ | 2 /* Arrow.Diag */;\n                }\n                else {\n                    _table[row][column] = diag;\n                    _arrows[row][column] = 2 /* Arrow.Diag */;\n                }\n            }\n            else {\n                // top or diag\n                if (top > diag) {\n                    _table[row][column] = top;\n                    _arrows[row][column] = 1 /* Arrow.Top */;\n                }\n                else if (top === diag) {\n                    _table[row][column] = top;\n                    _arrows[row][column] = 1 /* Arrow.Top */ | 2 /* Arrow.Diag */;\n                }\n                else {\n                    _table[row][column] = diag;\n                    _arrows[row][column] = 2 /* Arrow.Diag */;\n                }\n            }\n        }\n    }\n    if (!hasStrongFirstMatch && !firstMatchCanBeWeak) {\n        return undefined;\n    }\n    _matchesCount = 0;\n    _topScore = -100;\n    _wordStart = wordStart;\n    _firstMatchCanBeWeak = firstMatchCanBeWeak;\n    _findAllMatches2(row - 1, column - 1, patternLen === wordLen ? 1 : 0, 0, false);\n    if (_matchesCount === 0) {\n        return undefined;\n    }\n    return [_topScore, _topMatch2, wordStart];\n}\nfunction _doScore(pattern, patternLow, patternPos, patternStart, word, wordLow, wordPos) {\n    if (patternLow[patternPos] !== wordLow[wordPos]) {\n        return -1;\n    }\n    if (wordPos === (patternPos - patternStart)) {\n        // common prefix: `foobar <-> foobaz`\n        //                            ^^^^^\n        if (pattern[patternPos] === word[wordPos]) {\n            return 7;\n        }\n        else {\n            return 5;\n        }\n    }\n    else if (isUpperCaseAtPos(wordPos, word, wordLow) && (wordPos === 0 || !isUpperCaseAtPos(wordPos - 1, word, wordLow))) {\n        // hitting upper-case: `foo <-> forOthers`\n        //                              ^^ ^\n        if (pattern[patternPos] === word[wordPos]) {\n            return 7;\n        }\n        else {\n            return 5;\n        }\n    }\n    else if (isSeparatorAtPos(wordLow, wordPos) && (wordPos === 0 || !isSeparatorAtPos(wordLow, wordPos - 1))) {\n        // hitting a separator: `. <-> foo.bar`\n        //                                ^\n        return 5;\n    }\n    else if (isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1)) {\n        // post separator: `foo <-> bar_foo`\n        //                              ^^^\n        return 5;\n    }\n    else {\n        return 1;\n    }\n}\nlet _matchesCount = 0;\nlet _topMatch2 = 0;\nlet _topScore = 0;\nlet _wordStart = 0;\nlet _firstMatchCanBeWeak = false;\nfunction _findAllMatches2(row, column, total, matches, lastMatched) {\n    if (_matchesCount >= 10 || total < -25) {\n        // stop when having already 10 results, or\n        // when a potential alignment as already 5 gaps\n        return;\n    }\n    let simpleMatchCount = 0;\n    while (row > 0 && column > 0) {\n        const score = _scores[row][column];\n        const arrow = _arrows[row][column];\n        if (arrow === 4 /* Arrow.Left */) {\n            // left -> no match, skip a word character\n            column -= 1;\n            if (lastMatched) {\n                total -= 5; // new gap penalty\n            }\n            else if (matches !== 0) {\n                total -= 1; // gap penalty after first match\n            }\n            lastMatched = false;\n            simpleMatchCount = 0;\n        }\n        else {\n            /* istanbul ignore else */\n            if (arrow & 2 /* Arrow.Diag */) {\n                if (arrow & 4 /* Arrow.Left */) {\n                    // left\n                    _findAllMatches2(row, column - 1, matches !== 0 ? total - 1 : total, // gap penalty after first match\n                    matches, lastMatched);\n                }\n                // diag\n                total += score;\n                row -= 1;\n                column -= 1;\n                lastMatched = true;\n                // match -> set a 1 at the word pos\n                matches += 2 ** (column + _wordStart);\n                // count simple matches and boost a row of\n                // simple matches when they yield in a\n                // strong match.\n                if (score === 1) {\n                    simpleMatchCount += 1;\n                    if (row === 0 && !_firstMatchCanBeWeak) {\n                        // when the first match is a weak\n                        // match we discard it\n                        return undefined;\n                    }\n                }\n                else {\n                    // boost\n                    total += 1 + (simpleMatchCount * (score - 1));\n                    simpleMatchCount = 0;\n                }\n            }\n            else {\n                // istanbul ignore next\n                return undefined;\n            }\n        }\n    }\n    total -= column >= 3 ? 9 : column * 3; // late start penalty\n    // dynamically keep track of the current top score\n    // and insert the current best score at head, the rest at tail\n    _matchesCount += 1;\n    if (total > _topScore) {\n        _topScore = total;\n        _topMatch2 = matches;\n    }\n}\n// #endregion\n// #region --- graceful ---\n/** @internal */\nexport function fuzzyScoreGracefulAggressive(pattern, lowPattern, patternPos, word, lowWord, wordPos, firstMatchCanBeWeak) {\n    return fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, true, firstMatchCanBeWeak);\n}\n/** @internal */\nexport function fuzzyScoreGraceful(pattern, lowPattern, patternPos, word, lowWord, wordPos, firstMatchCanBeWeak) {\n    return fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, false, firstMatchCanBeWeak);\n}\nfunction fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, aggressive, firstMatchCanBeWeak) {\n    let top = fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, firstMatchCanBeWeak);\n    if (top && !aggressive) {\n        // when using the original pattern yield a result we`\n        // return it unless we are aggressive and try to find\n        // a better alignment, e.g. `cno` -> `^co^ns^ole` or `^c^o^nsole`.\n        return top;\n    }\n    // istanbul ignore else\n    if (pattern.length >= 3) {\n        // When the pattern is long enough then try a few (max 7)\n        // permutations of the pattern to find a better match. The\n        // permutations only swap neighbouring characters, e.g\n        // `cnoso` becomes `conso`, `cnsoo`, `cnoos`.\n        const tries = Math.min(7, pattern.length - 1);\n        for (let movingPatternPos = patternPos + 1; movingPatternPos < tries; movingPatternPos++) {\n            const newPattern = nextTypoPermutation(pattern, movingPatternPos);\n            // istanbul ignore else\n            if (newPattern) {\n                const candidate = fuzzyScore(newPattern, newPattern.toLowerCase(), patternPos, word, lowWord, wordPos, firstMatchCanBeWeak);\n                if (candidate) {\n                    candidate[0] -= 3; // permutation penalty\n                    // istanbul ignore else\n                    if (!top || candidate[0] > top[0]) {\n                        top = candidate;\n                    }\n                }\n            }\n        }\n    }\n    return top;\n}\nfunction nextTypoPermutation(pattern, patternPos) {\n    // istanbul ignore next\n    if (patternPos + 1 >= pattern.length) {\n        return undefined;\n    }\n    const swap1 = pattern[patternPos];\n    const swap2 = pattern[patternPos + 1];\n    // istanbul ignore next\n    if (swap1 === swap2) {\n        return undefined;\n    }\n    return pattern.slice(0, patternPos)\n        + swap2\n        + swap1\n        + pattern.slice(patternPos + 2);\n}\n// #endregion\n//# sourceMappingURL=filters.js.map",
      "start": 1693508124502,
      "end": 1693508124533,
      "sourcemaps": null
    }
  ]
}
