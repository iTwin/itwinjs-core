{
  "resolvedId": "D:/hub2023A/itwinjs-core/test-apps/display-test-app/src/frontend/openIModel.ts",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\r\n* See LICENSE.md in the project root for license terms and full copyright notice.\r\n*--------------------------------------------------------------------------------------------*/\r\nimport { BentleyError, GuidString, IModelStatus, ProcessDetector } from \"@itwin/core-bentley\";\r\nimport { BriefcaseDownloader, IModelError, LocalBriefcaseProps, SyncMode } from \"@itwin/core-common\";\r\nimport { BriefcaseConnection, DownloadBriefcaseOptions, IModelConnection, NativeApp, SnapshotConnection } from \"@itwin/core-frontend\";\r\nimport { getConfigurationBoolean } from \"./DisplayTestApp\";\r\n\r\nexport interface OpenFileIModelProps {\r\n  fileName: string;\r\n  iModelId?: undefined;\r\n  iTwinId?: undefined;\r\n  writable: boolean;\r\n}\r\n\r\nexport interface OpenHubIModelProps {\r\n  fileName?: undefined;\r\n  iModelId: GuidString;\r\n  iTwinId: GuidString;\r\n  writable: boolean;\r\n}\r\n\r\nexport type OpenIModelProps = OpenFileIModelProps | OpenHubIModelProps;\r\n\r\nasync function downloadIModel(iModelId: GuidString, iTwinId: GuidString): Promise<LocalBriefcaseProps> {\r\n  if (!ProcessDetector.isNativeAppFrontend) {\r\n    throw new Error(\"Download requires native app (Electron, iOS, or Android)\");\r\n  }\r\n  const opts: DownloadBriefcaseOptions = { syncMode: SyncMode.PullOnly };\r\n  let downloader: BriefcaseDownloader | undefined;\r\n  try {\r\n    downloader = await NativeApp.requestDownloadBriefcase(iTwinId, iModelId, opts, undefined);\r\n\r\n    // Wait for the download to complete.\r\n    await downloader.downloadPromise;\r\n    const localBriefcases = await NativeApp.getCachedBriefcases(iModelId);\r\n    if (localBriefcases.length === 0) {\r\n      // This should never happen, since we just downloaded it, but check, just in case.\r\n      throw new Error(\"Error downloading iModel.\");\r\n    }\r\n    return localBriefcases[0];\r\n  } catch (error) {\r\n    if (error instanceof BentleyError) {\r\n      if (error.errorNumber === IModelStatus.FileAlreadyExists) {\r\n        // When a download is canceled, the partial briefcase file does not get deleted, which causes\r\n        // any subsequent download attempt to fail with this error number. If that happens, delete the\r\n        // briefcase and try again.\r\n        // When syncMode is SyncMode.PullOnly (which is what we use), briefcaseId is ALWAYS 0, so try\r\n        // to delete the existing file using that briefcaseId.\r\n        const filename = await NativeApp.getBriefcaseFileName({ iModelId, briefcaseId: 0 });\r\n        await NativeApp.deleteBriefcase(filename);\r\n        return downloadIModel(iModelId, iTwinId);\r\n      }\r\n    }\r\n    throw error;\r\n  }\r\n}\r\n\r\nexport async function openIModel(props: OpenIModelProps): Promise<IModelConnection> {\r\n  const { fileName, writable } = props;\r\n  if (fileName !== undefined) {\r\n    return openIModelFile(fileName, writable);\r\n  } else {\r\n    // Since fileName is required to be defined in OpenFileIModelProps, the fact that it is\r\n    // undefined means that props must be of type OpenHubIModelProps, (which the compiler knows).\r\n    const { iModelId, iTwinId } = props;\r\n    return openHubIModel(iModelId, iTwinId, writable);\r\n  }\r\n}\r\n\r\nasync function openIModelFile(fileName: string, writable: boolean): Promise<IModelConnection> {\r\n  try {\r\n    return await BriefcaseConnection.openFile({ fileName, readonly: !writable, key: fileName });\r\n  } catch (err) {\r\n    if (writable && err instanceof IModelError && err.errorNumber === IModelStatus.ReadOnly)\r\n      return SnapshotConnection.openFile(fileName);\r\n    else\r\n      throw err;\r\n  }\r\n}\r\n\r\nasync function openHubIModel(iModelId: GuidString, iTwinId: GuidString, writable: boolean): Promise<IModelConnection> {\r\n  const localBriefcases = await NativeApp.getCachedBriefcases(iModelId);\r\n  if (localBriefcases.length > 0) {\r\n    const fileName = await NativeApp.getBriefcaseFileName({ iModelId, briefcaseId: 0 });\r\n    if (getConfigurationBoolean(\"ignoreCache\")) {\r\n      await NativeApp.deleteBriefcase(fileName);\r\n    } else {\r\n      return openIModel({ fileName, writable });\r\n    }\r\n  }\r\n  const briefcaseProps = await downloadIModel(iModelId, iTwinId);\r\n  return openIModelFile(briefcaseProps.fileName, writable);\r\n}\r\n",
      "start": 1693508118379,
      "end": 1693508118557,
      "sourcemaps": null
    },
    {
      "name": "vite:esbuild",
      "result": "\"use strict\";\nimport { BentleyError, IModelStatus, ProcessDetector } from \"@itwin/core-bentley\";\nimport { IModelError, SyncMode } from \"@itwin/core-common\";\nimport { BriefcaseConnection, NativeApp, SnapshotConnection } from \"@itwin/core-frontend\";\nimport { getConfigurationBoolean } from \"./DisplayTestApp\";\nasync function downloadIModel(iModelId, iTwinId) {\n  if (!ProcessDetector.isNativeAppFrontend) {\n    throw new Error(\"Download requires native app (Electron, iOS, or Android)\");\n  }\n  const opts = { syncMode: SyncMode.PullOnly };\n  let downloader;\n  try {\n    downloader = await NativeApp.requestDownloadBriefcase(iTwinId, iModelId, opts, void 0);\n    await downloader.downloadPromise;\n    const localBriefcases = await NativeApp.getCachedBriefcases(iModelId);\n    if (localBriefcases.length === 0) {\n      throw new Error(\"Error downloading iModel.\");\n    }\n    return localBriefcases[0];\n  } catch (error) {\n    if (error instanceof BentleyError) {\n      if (error.errorNumber === IModelStatus.FileAlreadyExists) {\n        const filename = await NativeApp.getBriefcaseFileName({ iModelId, briefcaseId: 0 });\n        await NativeApp.deleteBriefcase(filename);\n        return downloadIModel(iModelId, iTwinId);\n      }\n    }\n    throw error;\n  }\n}\nexport async function openIModel(props) {\n  const { fileName, writable } = props;\n  if (fileName !== void 0) {\n    return openIModelFile(fileName, writable);\n  } else {\n    const { iModelId, iTwinId } = props;\n    return openHubIModel(iModelId, iTwinId, writable);\n  }\n}\nasync function openIModelFile(fileName, writable) {\n  try {\n    return await BriefcaseConnection.openFile({ fileName, readonly: !writable, key: fileName });\n  } catch (err) {\n    if (writable && err instanceof IModelError && err.errorNumber === IModelStatus.ReadOnly)\n      return SnapshotConnection.openFile(fileName);\n    else\n      throw err;\n  }\n}\nasync function openHubIModel(iModelId, iTwinId, writable) {\n  const localBriefcases = await NativeApp.getCachedBriefcases(iModelId);\n  if (localBriefcases.length > 0) {\n    const fileName = await NativeApp.getBriefcaseFileName({ iModelId, briefcaseId: 0 });\n    if (getConfigurationBoolean(\"ignoreCache\")) {\n      await NativeApp.deleteBriefcase(fileName);\n    } else {\n      return openIModel({ fileName, writable });\n    }\n  }\n  const briefcaseProps = await downloadIModel(iModelId, iTwinId);\n  return openIModelFile(briefcaseProps.fileName, writable);\n}\n",
      "start": 1693508118557,
      "end": 1693508118676,
      "order": "normal",
      "sourcemaps": {
        "version": 3,
        "sources": [
          "D:/hub2023A/itwinjs-core/test-apps/display-test-app/src/frontend/openIModel.ts"
        ],
        "sourcesContent": [
          "/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\r\n* See LICENSE.md in the project root for license terms and full copyright notice.\r\n*--------------------------------------------------------------------------------------------*/\r\nimport { BentleyError, GuidString, IModelStatus, ProcessDetector } from \"@itwin/core-bentley\";\r\nimport { BriefcaseDownloader, IModelError, LocalBriefcaseProps, SyncMode } from \"@itwin/core-common\";\r\nimport { BriefcaseConnection, DownloadBriefcaseOptions, IModelConnection, NativeApp, SnapshotConnection } from \"@itwin/core-frontend\";\r\nimport { getConfigurationBoolean } from \"./DisplayTestApp\";\r\n\r\nexport interface OpenFileIModelProps {\r\n  fileName: string;\r\n  iModelId?: undefined;\r\n  iTwinId?: undefined;\r\n  writable: boolean;\r\n}\r\n\r\nexport interface OpenHubIModelProps {\r\n  fileName?: undefined;\r\n  iModelId: GuidString;\r\n  iTwinId: GuidString;\r\n  writable: boolean;\r\n}\r\n\r\nexport type OpenIModelProps = OpenFileIModelProps | OpenHubIModelProps;\r\n\r\nasync function downloadIModel(iModelId: GuidString, iTwinId: GuidString): Promise<LocalBriefcaseProps> {\r\n  if (!ProcessDetector.isNativeAppFrontend) {\r\n    throw new Error(\"Download requires native app (Electron, iOS, or Android)\");\r\n  }\r\n  const opts: DownloadBriefcaseOptions = { syncMode: SyncMode.PullOnly };\r\n  let downloader: BriefcaseDownloader | undefined;\r\n  try {\r\n    downloader = await NativeApp.requestDownloadBriefcase(iTwinId, iModelId, opts, undefined);\r\n\r\n    // Wait for the download to complete.\r\n    await downloader.downloadPromise;\r\n    const localBriefcases = await NativeApp.getCachedBriefcases(iModelId);\r\n    if (localBriefcases.length === 0) {\r\n      // This should never happen, since we just downloaded it, but check, just in case.\r\n      throw new Error(\"Error downloading iModel.\");\r\n    }\r\n    return localBriefcases[0];\r\n  } catch (error) {\r\n    if (error instanceof BentleyError) {\r\n      if (error.errorNumber === IModelStatus.FileAlreadyExists) {\r\n        // When a download is canceled, the partial briefcase file does not get deleted, which causes\r\n        // any subsequent download attempt to fail with this error number. If that happens, delete the\r\n        // briefcase and try again.\r\n        // When syncMode is SyncMode.PullOnly (which is what we use), briefcaseId is ALWAYS 0, so try\r\n        // to delete the existing file using that briefcaseId.\r\n        const filename = await NativeApp.getBriefcaseFileName({ iModelId, briefcaseId: 0 });\r\n        await NativeApp.deleteBriefcase(filename);\r\n        return downloadIModel(iModelId, iTwinId);\r\n      }\r\n    }\r\n    throw error;\r\n  }\r\n}\r\n\r\nexport async function openIModel(props: OpenIModelProps): Promise<IModelConnection> {\r\n  const { fileName, writable } = props;\r\n  if (fileName !== undefined) {\r\n    return openIModelFile(fileName, writable);\r\n  } else {\r\n    // Since fileName is required to be defined in OpenFileIModelProps, the fact that it is\r\n    // undefined means that props must be of type OpenHubIModelProps, (which the compiler knows).\r\n    const { iModelId, iTwinId } = props;\r\n    return openHubIModel(iModelId, iTwinId, writable);\r\n  }\r\n}\r\n\r\nasync function openIModelFile(fileName: string, writable: boolean): Promise<IModelConnection> {\r\n  try {\r\n    return await BriefcaseConnection.openFile({ fileName, readonly: !writable, key: fileName });\r\n  } catch (err) {\r\n    if (writable && err instanceof IModelError && err.errorNumber === IModelStatus.ReadOnly)\r\n      return SnapshotConnection.openFile(fileName);\r\n    else\r\n      throw err;\r\n  }\r\n}\r\n\r\nasync function openHubIModel(iModelId: GuidString, iTwinId: GuidString, writable: boolean): Promise<IModelConnection> {\r\n  const localBriefcases = await NativeApp.getCachedBriefcases(iModelId);\r\n  if (localBriefcases.length > 0) {\r\n    const fileName = await NativeApp.getBriefcaseFileName({ iModelId, briefcaseId: 0 });\r\n    if (getConfigurationBoolean(\"ignoreCache\")) {\r\n      await NativeApp.deleteBriefcase(fileName);\r\n    } else {\r\n      return openIModel({ fileName, writable });\r\n    }\r\n  }\r\n  const briefcaseProps = await downloadIModel(iModelId, iTwinId);\r\n  return openIModelFile(briefcaseProps.fileName, writable);\r\n}\r\n"
        ],
        "mappings": ";AAIA,SAAS,cAA0B,cAAc,uBAAuB;AACxE,SAA8B,aAAkC,gBAAgB;AAChF,SAAS,qBAAiE,WAAW,0BAA0B;AAC/G,SAAS,+BAA+B;AAkBxC,eAAe,eAAe,UAAsB,SAAmD;AACrG,MAAI,CAAC,gBAAgB,qBAAqB;AACxC,UAAM,IAAI,MAAM,0DAA0D;AAAA,EAC5E;AACA,QAAM,OAAiC,EAAE,UAAU,SAAS,SAAS;AACrE,MAAI;AACJ,MAAI;AACF,iBAAa,MAAM,UAAU,yBAAyB,SAAS,UAAU,MAAM,MAAS;AAGxF,UAAM,WAAW;AACjB,UAAM,kBAAkB,MAAM,UAAU,oBAAoB,QAAQ;AACpE,QAAI,gBAAgB,WAAW,GAAG;AAEhC,YAAM,IAAI,MAAM,2BAA2B;AAAA,IAC7C;AACA,WAAO,gBAAgB,CAAC;AAAA,EAC1B,SAAS,OAAO;AACd,QAAI,iBAAiB,cAAc;AACjC,UAAI,MAAM,gBAAgB,aAAa,mBAAmB;AAMxD,cAAM,WAAW,MAAM,UAAU,qBAAqB,EAAE,UAAU,aAAa,EAAE,CAAC;AAClF,cAAM,UAAU,gBAAgB,QAAQ;AACxC,eAAO,eAAe,UAAU,OAAO;AAAA,MACzC;AAAA,IACF;AACA,UAAM;AAAA,EACR;AACF;AAEA,sBAAsB,WAAW,OAAmD;AAClF,QAAM,EAAE,UAAU,SAAS,IAAI;AAC/B,MAAI,aAAa,QAAW;AAC1B,WAAO,eAAe,UAAU,QAAQ;AAAA,EAC1C,OAAO;AAGL,UAAM,EAAE,UAAU,QAAQ,IAAI;AAC9B,WAAO,cAAc,UAAU,SAAS,QAAQ;AAAA,EAClD;AACF;AAEA,eAAe,eAAe,UAAkB,UAA8C;AAC5F,MAAI;AACF,WAAO,MAAM,oBAAoB,SAAS,EAAE,UAAU,UAAU,CAAC,UAAU,KAAK,SAAS,CAAC;AAAA,EAC5F,SAAS,KAAK;AACZ,QAAI,YAAY,eAAe,eAAe,IAAI,gBAAgB,aAAa;AAC7E,aAAO,mBAAmB,SAAS,QAAQ;AAAA;AAE3C,YAAM;AAAA,EACV;AACF;AAEA,eAAe,cAAc,UAAsB,SAAqB,UAA8C;AACpH,QAAM,kBAAkB,MAAM,UAAU,oBAAoB,QAAQ;AACpE,MAAI,gBAAgB,SAAS,GAAG;AAC9B,UAAM,WAAW,MAAM,UAAU,qBAAqB,EAAE,UAAU,aAAa,EAAE,CAAC;AAClF,QAAI,wBAAwB,aAAa,GAAG;AAC1C,YAAM,UAAU,gBAAgB,QAAQ;AAAA,IAC1C,OAAO;AACL,aAAO,WAAW,EAAE,UAAU,SAAS,CAAC;AAAA,IAC1C;AAAA,EACF;AACA,QAAM,iBAAiB,MAAM,eAAe,UAAU,OAAO;AAC7D,SAAO,eAAe,eAAe,UAAU,QAAQ;AACzD;",
        "names": []
      }
    }
  ]
}
