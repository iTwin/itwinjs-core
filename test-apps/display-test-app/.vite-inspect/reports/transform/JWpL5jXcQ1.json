{
  "resolvedId": "D:/hub2023A/itwinjs-core/test-apps/display-test-app/src/frontend/EditingTools.ts",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\r\n* See LICENSE.md in the project root for license terms and full copyright notice.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\nimport { assert, Id64String } from \"@itwin/core-bentley\";\r\nimport {\r\n  Code, ColorDef, ElementGeometry, GeometryPartProps, GeometryStreamBuilder, GeometryStreamProps, IModel, PhysicalElementProps,\r\n} from \"@itwin/core-common\";\r\nimport {\r\n  AccuDrawHintBuilder, BeButtonEvent, CoreTools, DecorateContext, DynamicsContext, EventHandled, GraphicType, HitDetail, IModelApp,\r\n  NotifyMessageDetails, OutputMessagePriority, Tool, ToolAssistance, ToolAssistanceImage, ToolAssistanceInputMethod, ToolAssistanceInstruction,\r\n  ToolAssistanceSection,\r\n} from \"@itwin/core-frontend\";\r\nimport { IModelJson, LineString3d, Point3d, Sphere, Vector3d, YawPitchRollAngles } from \"@itwin/core-geometry\";\r\nimport { editorBuiltInCmdIds } from \"@itwin/editor-common\";\r\nimport { basicManipulationIpc, CreateElementTool, EditTools } from \"@itwin/editor-frontend\";\r\nimport { setTitle } from \"./Title\";\r\n\r\n// Simple tools for testing interactive editing. They require the iModel to have been opened in read-write mode.\r\n\r\n/** If an editing scope is currently in progress, end it; otherwise, begin a new one. */\r\nexport class EditingScopeTool extends Tool {\r\n  public static override toolId = \"EditingSession\";\r\n  public static override get minArgs() { return 0; }\r\n  public static override get maxArgs() { return 0; }\r\n\r\n  public override async run(): Promise<boolean> {\r\n    await this._run();\r\n    return true;\r\n  }\r\n\r\n  private async _run(): Promise<void> {\r\n    const imodel = IModelApp.viewManager.selectedView?.iModel;\r\n    if (!imodel || !imodel.isBriefcaseConnection())\r\n      return;\r\n\r\n    const scope = imodel.editingScope;\r\n    if (scope)\r\n      await scope.exit();\r\n    else\r\n      await imodel.enterEditingScope();\r\n\r\n    setTitle(imodel);\r\n  }\r\n}\r\n\r\n/** Places a line string. Uses model and category from [[BriefcaseConnection.editorToolSettings]]. */\r\nexport class PlaceLineStringTool extends CreateElementTool {\r\n  public static override toolId = \"PlaceLineString\";\r\n  private readonly _points: Point3d[] = [];\r\n  private _snapGeomId?: Id64String;\r\n  private _testGeomJson = false;\r\n  private _testGeomParts = false;\r\n  protected _startedCmd?: string;\r\n\r\n  protected override get wantAccuSnap(): boolean { return true; }\r\n  protected override get wantDynamics(): boolean { return true; }\r\n\r\n  protected async startCommand(): Promise<string> {\r\n    if (undefined !== this._startedCmd)\r\n      return this._startedCmd;\r\n    return EditTools.startCommand<string>({ commandId: editorBuiltInCmdIds.cmdBasicManipulation, iModelKey: this.iModel.key });\r\n  }\r\n\r\n  protected override setupAndPromptForNextAction(): void {\r\n    const nPts = this._points.length;\r\n\r\n    if (0 !== nPts) {\r\n      const hints = new AccuDrawHintBuilder();\r\n      hints.enableSmartRotation = true;\r\n\r\n      if (nPts > 1 && !this._points[nPts - 1].isAlmostEqual(this._points[nPts - 2]))\r\n        hints.setXAxis(Vector3d.createStartEnd(this._points[nPts - 2], this._points[nPts - 1])); // Rotate AccuDraw to last segment.\r\n\r\n      hints.setOrigin(this._points[nPts - 1]);\r\n      hints.sendHints();\r\n    }\r\n\r\n    super.setupAndPromptForNextAction();\r\n  }\r\n\r\n  protected override provideToolAssistance(_mainInstrText?: string, _additionalInstr?: ToolAssistanceInstruction[]): void {\r\n    const nPts = this._points.length;\r\n    const mainMsg = 0 === nPts ? \"ElementSet.Prompts.StartPoint\" : (1 === nPts ? \"ElementSet.Prompts.EndPoint\" : \"ElementSet.Inputs.AdditionalPoint\");\r\n    const leftMsg = \"ElementSet.Inputs.AcceptPoint\";\r\n    const rightMsg = nPts > 1 ? \"ElementSet.Inputs.Complete\" : \"ElementSet.Inputs.Cancel\";\r\n\r\n    const mouseInstructions: ToolAssistanceInstruction[] = [];\r\n    const touchInstructions: ToolAssistanceInstruction[] = [];\r\n\r\n    if (!ToolAssistance.createTouchCursorInstructions(touchInstructions))\r\n      touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.OneTouchTap, CoreTools.translate(leftMsg), false, ToolAssistanceInputMethod.Touch));\r\n    mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.LeftClick, CoreTools.translate(leftMsg), false, ToolAssistanceInputMethod.Mouse));\r\n\r\n    touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.TwoTouchTap, CoreTools.translate(rightMsg), false, ToolAssistanceInputMethod.Touch));\r\n    mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.RightClick, CoreTools.translate(rightMsg), false, ToolAssistanceInputMethod.Mouse));\r\n\r\n    const sections: ToolAssistanceSection[] = [];\r\n    sections.push(ToolAssistance.createSection(mouseInstructions, ToolAssistance.inputsLabel));\r\n    sections.push(ToolAssistance.createSection(touchInstructions, ToolAssistance.inputsLabel));\r\n\r\n    const mainInstruction = ToolAssistance.createInstruction(this.iconSpec, CoreTools.translate(mainMsg));\r\n    const instructions = ToolAssistance.createInstructions(mainInstruction, sections);\r\n    IModelApp.notifications.setToolAssistance(instructions);\r\n  }\r\n\r\n  public override testDecorationHit(id: Id64String): boolean {\r\n    return id === this._snapGeomId;\r\n  }\r\n\r\n  public override getDecorationGeometry(_hit: HitDetail): GeometryStreamProps | undefined {\r\n    if (this._points.length < 2)\r\n      return undefined;\r\n\r\n    const geom = IModelJson.Writer.toIModelJson(LineString3d.create(this._points));\r\n    return geom ? [geom] : undefined;\r\n  }\r\n\r\n  public override decorate(context: DecorateContext): void {\r\n    if (this._points.length < 2)\r\n      return;\r\n\r\n    if (undefined === this._snapGeomId)\r\n      this._snapGeomId = this.iModel.transientIds.getNext();\r\n\r\n    const builder = context.createGraphicBuilder(GraphicType.WorldDecoration, undefined, this._snapGeomId);\r\n    builder.setSymbology(context.viewport.getContrastToBackgroundColor(), ColorDef.black, 1);\r\n    builder.addLineString(this._points);\r\n    context.addDecorationFromBuilder(builder);\r\n  }\r\n\r\n  public override onDynamicFrame(ev: BeButtonEvent, context: DynamicsContext): void {\r\n    if (this._points.length < 1)\r\n      return;\r\n\r\n    // Only draw current segment in dynamics - accepted segments are drawn as pickable decorations.\r\n    const builder = context.createSceneGraphicBuilder();\r\n    builder.setSymbology(context.viewport.getContrastToBackgroundColor(), ColorDef.black, 1);\r\n    builder.addLineString([this._points[this._points.length - 1].clone(), ev.point.clone()]);\r\n    context.addGraphic(builder.finish());\r\n  }\r\n\r\n  public override async onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled> {\r\n    this._points.push(ev.point.clone());\r\n    return super.onDataButtonDown(ev);\r\n  }\r\n\r\n  protected async createElement(): Promise<void> {\r\n    const vp = this.targetView;\r\n    assert(undefined !== vp);\r\n    assert(2 <= this._points.length);\r\n\r\n    const model = this.targetModelId;\r\n    const category = this.targetCategory;\r\n\r\n    const origin = this._points[0];\r\n    const angles = new YawPitchRollAngles();\r\n\r\n    const matrix = AccuDrawHintBuilder.getCurrentRotation(vp, true, true);\r\n    ElementGeometry.Builder.placementAnglesFromPoints(this._points, matrix?.getColumn(2), angles);\r\n\r\n    try {\r\n      this._startedCmd = await this.startCommand();\r\n\r\n      if (this._testGeomJson) {\r\n        const builder = new GeometryStreamBuilder();\r\n        const primitive = LineString3d.create(this._points);\r\n\r\n        builder.setLocalToWorld3d(origin, angles); // Establish world to local transform...\r\n        if (!builder.appendGeometry(primitive))\r\n          return;\r\n\r\n        if (this._testGeomParts) {\r\n          const partBuilder = new GeometryStreamBuilder();\r\n          const sphere = Sphere.createCenterRadius(Point3d.createZero(), this._points[0].distance(this._points[1]) * 0.05);\r\n\r\n          if (!partBuilder.appendGeometry(sphere))\r\n            return;\r\n\r\n          const partProps: GeometryPartProps = { classFullName: \"BisCore:GeometryPart\", model: IModel.dictionaryId, code: Code.createEmpty(), geom: partBuilder.geometryStream };\r\n          const partId = await basicManipulationIpc.insertGeometryPart(partProps);\r\n\r\n          for (const pt of this._points) {\r\n            if (!builder.appendGeometryPart3d(partId, pt))\r\n              return;\r\n          }\r\n        }\r\n\r\n        const elemProps: PhysicalElementProps = { classFullName: \"Generic:PhysicalObject\", model, category, code: Code.createEmpty(), placement: { origin, angles }, geom: builder.geometryStream };\r\n        await basicManipulationIpc.insertGeometricElement(elemProps);\r\n        await this.saveChanges();\r\n      } else {\r\n        const builder = new ElementGeometry.Builder();\r\n        const primitive = LineString3d.create(this._points);\r\n\r\n        builder.setLocalToWorld3d(origin, angles); // Establish world to local transform...\r\n        if (!builder.appendGeometryQuery(primitive))\r\n          return;\r\n\r\n        if (this._testGeomParts) {\r\n          const partBuilder = new ElementGeometry.Builder();\r\n          const sphere = Sphere.createCenterRadius(Point3d.createZero(), this._points[0].distance(this._points[1]) * 0.05);\r\n\r\n          if (!partBuilder.appendGeometryQuery(sphere))\r\n            return;\r\n\r\n          const partProps: GeometryPartProps = { classFullName: \"BisCore:GeometryPart\", model: IModel.dictionaryId, code: Code.createEmpty() };\r\n          const partId = await basicManipulationIpc.insertGeometryPart(partProps, { entryArray: partBuilder.entries });\r\n\r\n          for (const pt of this._points) {\r\n            if (!builder.appendGeometryPart3d(partId, pt))\r\n              return;\r\n          }\r\n        }\r\n\r\n        const elemProps: PhysicalElementProps = { classFullName: \"Generic:PhysicalObject\", model, category, code: Code.createEmpty(), placement: { origin, angles } };\r\n        await basicManipulationIpc.insertGeometricElement(elemProps, { entryArray: builder.entries });\r\n        await this.saveChanges();\r\n      }\r\n    } catch (err: any) {\r\n      IModelApp.notifications.outputMessage(new NotifyMessageDetails(OutputMessagePriority.Error, err.toString()));\r\n    }\r\n  }\r\n\r\n  public override async onResetButtonUp(_ev: BeButtonEvent): Promise<EventHandled> {\r\n    // Accept on reset if we have at least 2 points, starting another tool will reject accepted segments...\r\n    if (this._points.length >= 2)\r\n      await this.createElement();\r\n\r\n    await this.onReinitialize();\r\n    return EventHandled.No;\r\n  }\r\n\r\n  public override async onUndoPreviousStep(): Promise<boolean> {\r\n    if (0 === this._points.length)\r\n      return false;\r\n\r\n    this._points.pop();\r\n    if (0 === this._points.length)\r\n      await this.onReinitialize();\r\n    else\r\n      this.setupAndPromptForNextAction();\r\n\r\n    return true;\r\n  }\r\n\r\n  public async onRestartTool() {\r\n    const tool = new PlaceLineStringTool();\r\n    if (!await tool.run())\r\n      return this.exitTool();\r\n  }\r\n}\r\n",
      "start": 1693508121191,
      "end": 1693508121254,
      "sourcemaps": null
    },
    {
      "name": "vite:esbuild",
      "result": "\"use strict\";\nimport { assert } from \"@itwin/core-bentley\";\nimport {\n  Code,\n  ColorDef,\n  ElementGeometry,\n  GeometryStreamBuilder,\n  IModel\n} from \"@itwin/core-common\";\nimport {\n  AccuDrawHintBuilder,\n  CoreTools,\n  EventHandled,\n  GraphicType,\n  IModelApp,\n  NotifyMessageDetails,\n  OutputMessagePriority,\n  Tool,\n  ToolAssistance,\n  ToolAssistanceImage,\n  ToolAssistanceInputMethod\n} from \"@itwin/core-frontend\";\nimport { IModelJson, LineString3d, Point3d, Sphere, Vector3d, YawPitchRollAngles } from \"@itwin/core-geometry\";\nimport { editorBuiltInCmdIds } from \"@itwin/editor-common\";\nimport { basicManipulationIpc, CreateElementTool, EditTools } from \"@itwin/editor-frontend\";\nimport { setTitle } from \"./Title\";\nexport class EditingScopeTool extends Tool {\n  static get minArgs() {\n    return 0;\n  }\n  static get maxArgs() {\n    return 0;\n  }\n  async run() {\n    await this._run();\n    return true;\n  }\n  async _run() {\n    const imodel = IModelApp.viewManager.selectedView?.iModel;\n    if (!imodel || !imodel.isBriefcaseConnection())\n      return;\n    const scope = imodel.editingScope;\n    if (scope)\n      await scope.exit();\n    else\n      await imodel.enterEditingScope();\n    setTitle(imodel);\n  }\n}\nEditingScopeTool.toolId = \"EditingSession\";\nconst _PlaceLineStringTool = class _PlaceLineStringTool extends CreateElementTool {\n  constructor() {\n    super(...arguments);\n    this._points = [];\n    this._testGeomJson = false;\n    this._testGeomParts = false;\n  }\n  get wantAccuSnap() {\n    return true;\n  }\n  get wantDynamics() {\n    return true;\n  }\n  async startCommand() {\n    if (void 0 !== this._startedCmd)\n      return this._startedCmd;\n    return EditTools.startCommand({ commandId: editorBuiltInCmdIds.cmdBasicManipulation, iModelKey: this.iModel.key });\n  }\n  setupAndPromptForNextAction() {\n    const nPts = this._points.length;\n    if (0 !== nPts) {\n      const hints = new AccuDrawHintBuilder();\n      hints.enableSmartRotation = true;\n      if (nPts > 1 && !this._points[nPts - 1].isAlmostEqual(this._points[nPts - 2]))\n        hints.setXAxis(Vector3d.createStartEnd(this._points[nPts - 2], this._points[nPts - 1]));\n      hints.setOrigin(this._points[nPts - 1]);\n      hints.sendHints();\n    }\n    super.setupAndPromptForNextAction();\n  }\n  provideToolAssistance(_mainInstrText, _additionalInstr) {\n    const nPts = this._points.length;\n    const mainMsg = 0 === nPts ? \"ElementSet.Prompts.StartPoint\" : 1 === nPts ? \"ElementSet.Prompts.EndPoint\" : \"ElementSet.Inputs.AdditionalPoint\";\n    const leftMsg = \"ElementSet.Inputs.AcceptPoint\";\n    const rightMsg = nPts > 1 ? \"ElementSet.Inputs.Complete\" : \"ElementSet.Inputs.Cancel\";\n    const mouseInstructions = [];\n    const touchInstructions = [];\n    if (!ToolAssistance.createTouchCursorInstructions(touchInstructions))\n      touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.OneTouchTap, CoreTools.translate(leftMsg), false, ToolAssistanceInputMethod.Touch));\n    mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.LeftClick, CoreTools.translate(leftMsg), false, ToolAssistanceInputMethod.Mouse));\n    touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.TwoTouchTap, CoreTools.translate(rightMsg), false, ToolAssistanceInputMethod.Touch));\n    mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.RightClick, CoreTools.translate(rightMsg), false, ToolAssistanceInputMethod.Mouse));\n    const sections = [];\n    sections.push(ToolAssistance.createSection(mouseInstructions, ToolAssistance.inputsLabel));\n    sections.push(ToolAssistance.createSection(touchInstructions, ToolAssistance.inputsLabel));\n    const mainInstruction = ToolAssistance.createInstruction(this.iconSpec, CoreTools.translate(mainMsg));\n    const instructions = ToolAssistance.createInstructions(mainInstruction, sections);\n    IModelApp.notifications.setToolAssistance(instructions);\n  }\n  testDecorationHit(id) {\n    return id === this._snapGeomId;\n  }\n  getDecorationGeometry(_hit) {\n    if (this._points.length < 2)\n      return void 0;\n    const geom = IModelJson.Writer.toIModelJson(LineString3d.create(this._points));\n    return geom ? [geom] : void 0;\n  }\n  decorate(context) {\n    if (this._points.length < 2)\n      return;\n    if (void 0 === this._snapGeomId)\n      this._snapGeomId = this.iModel.transientIds.getNext();\n    const builder = context.createGraphicBuilder(GraphicType.WorldDecoration, void 0, this._snapGeomId);\n    builder.setSymbology(context.viewport.getContrastToBackgroundColor(), ColorDef.black, 1);\n    builder.addLineString(this._points);\n    context.addDecorationFromBuilder(builder);\n  }\n  onDynamicFrame(ev, context) {\n    if (this._points.length < 1)\n      return;\n    const builder = context.createSceneGraphicBuilder();\n    builder.setSymbology(context.viewport.getContrastToBackgroundColor(), ColorDef.black, 1);\n    builder.addLineString([this._points[this._points.length - 1].clone(), ev.point.clone()]);\n    context.addGraphic(builder.finish());\n  }\n  async onDataButtonDown(ev) {\n    this._points.push(ev.point.clone());\n    return super.onDataButtonDown(ev);\n  }\n  async createElement() {\n    const vp = this.targetView;\n    assert(void 0 !== vp);\n    assert(2 <= this._points.length);\n    const model = this.targetModelId;\n    const category = this.targetCategory;\n    const origin = this._points[0];\n    const angles = new YawPitchRollAngles();\n    const matrix = AccuDrawHintBuilder.getCurrentRotation(vp, true, true);\n    ElementGeometry.Builder.placementAnglesFromPoints(this._points, matrix?.getColumn(2), angles);\n    try {\n      this._startedCmd = await this.startCommand();\n      if (this._testGeomJson) {\n        const builder = new GeometryStreamBuilder();\n        const primitive = LineString3d.create(this._points);\n        builder.setLocalToWorld3d(origin, angles);\n        if (!builder.appendGeometry(primitive))\n          return;\n        if (this._testGeomParts) {\n          const partBuilder = new GeometryStreamBuilder();\n          const sphere = Sphere.createCenterRadius(Point3d.createZero(), this._points[0].distance(this._points[1]) * 0.05);\n          if (!partBuilder.appendGeometry(sphere))\n            return;\n          const partProps = { classFullName: \"BisCore:GeometryPart\", model: IModel.dictionaryId, code: Code.createEmpty(), geom: partBuilder.geometryStream };\n          const partId = await basicManipulationIpc.insertGeometryPart(partProps);\n          for (const pt of this._points) {\n            if (!builder.appendGeometryPart3d(partId, pt))\n              return;\n          }\n        }\n        const elemProps = { classFullName: \"Generic:PhysicalObject\", model, category, code: Code.createEmpty(), placement: { origin, angles }, geom: builder.geometryStream };\n        await basicManipulationIpc.insertGeometricElement(elemProps);\n        await this.saveChanges();\n      } else {\n        const builder = new ElementGeometry.Builder();\n        const primitive = LineString3d.create(this._points);\n        builder.setLocalToWorld3d(origin, angles);\n        if (!builder.appendGeometryQuery(primitive))\n          return;\n        if (this._testGeomParts) {\n          const partBuilder = new ElementGeometry.Builder();\n          const sphere = Sphere.createCenterRadius(Point3d.createZero(), this._points[0].distance(this._points[1]) * 0.05);\n          if (!partBuilder.appendGeometryQuery(sphere))\n            return;\n          const partProps = { classFullName: \"BisCore:GeometryPart\", model: IModel.dictionaryId, code: Code.createEmpty() };\n          const partId = await basicManipulationIpc.insertGeometryPart(partProps, { entryArray: partBuilder.entries });\n          for (const pt of this._points) {\n            if (!builder.appendGeometryPart3d(partId, pt))\n              return;\n          }\n        }\n        const elemProps = { classFullName: \"Generic:PhysicalObject\", model, category, code: Code.createEmpty(), placement: { origin, angles } };\n        await basicManipulationIpc.insertGeometricElement(elemProps, { entryArray: builder.entries });\n        await this.saveChanges();\n      }\n    } catch (err) {\n      IModelApp.notifications.outputMessage(new NotifyMessageDetails(OutputMessagePriority.Error, err.toString()));\n    }\n  }\n  async onResetButtonUp(_ev) {\n    if (this._points.length >= 2)\n      await this.createElement();\n    await this.onReinitialize();\n    return EventHandled.No;\n  }\n  async onUndoPreviousStep() {\n    if (0 === this._points.length)\n      return false;\n    this._points.pop();\n    if (0 === this._points.length)\n      await this.onReinitialize();\n    else\n      this.setupAndPromptForNextAction();\n    return true;\n  }\n  async onRestartTool() {\n    const tool = new _PlaceLineStringTool();\n    if (!await tool.run())\n      return this.exitTool();\n  }\n};\n_PlaceLineStringTool.toolId = \"PlaceLineString\";\nexport let PlaceLineStringTool = _PlaceLineStringTool;\n",
      "start": 1693508121254,
      "end": 1693508121455,
      "order": "normal",
      "sourcemaps": {
        "version": 3,
        "sources": [
          "D:/hub2023A/itwinjs-core/test-apps/display-test-app/src/frontend/EditingTools.ts"
        ],
        "sourcesContent": [
          "/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\r\n* See LICENSE.md in the project root for license terms and full copyright notice.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\nimport { assert, Id64String } from \"@itwin/core-bentley\";\r\nimport {\r\n  Code, ColorDef, ElementGeometry, GeometryPartProps, GeometryStreamBuilder, GeometryStreamProps, IModel, PhysicalElementProps,\r\n} from \"@itwin/core-common\";\r\nimport {\r\n  AccuDrawHintBuilder, BeButtonEvent, CoreTools, DecorateContext, DynamicsContext, EventHandled, GraphicType, HitDetail, IModelApp,\r\n  NotifyMessageDetails, OutputMessagePriority, Tool, ToolAssistance, ToolAssistanceImage, ToolAssistanceInputMethod, ToolAssistanceInstruction,\r\n  ToolAssistanceSection,\r\n} from \"@itwin/core-frontend\";\r\nimport { IModelJson, LineString3d, Point3d, Sphere, Vector3d, YawPitchRollAngles } from \"@itwin/core-geometry\";\r\nimport { editorBuiltInCmdIds } from \"@itwin/editor-common\";\r\nimport { basicManipulationIpc, CreateElementTool, EditTools } from \"@itwin/editor-frontend\";\r\nimport { setTitle } from \"./Title\";\r\n\r\n// Simple tools for testing interactive editing. They require the iModel to have been opened in read-write mode.\r\n\r\n/** If an editing scope is currently in progress, end it; otherwise, begin a new one. */\r\nexport class EditingScopeTool extends Tool {\r\n  public static override toolId = \"EditingSession\";\r\n  public static override get minArgs() { return 0; }\r\n  public static override get maxArgs() { return 0; }\r\n\r\n  public override async run(): Promise<boolean> {\r\n    await this._run();\r\n    return true;\r\n  }\r\n\r\n  private async _run(): Promise<void> {\r\n    const imodel = IModelApp.viewManager.selectedView?.iModel;\r\n    if (!imodel || !imodel.isBriefcaseConnection())\r\n      return;\r\n\r\n    const scope = imodel.editingScope;\r\n    if (scope)\r\n      await scope.exit();\r\n    else\r\n      await imodel.enterEditingScope();\r\n\r\n    setTitle(imodel);\r\n  }\r\n}\r\n\r\n/** Places a line string. Uses model and category from [[BriefcaseConnection.editorToolSettings]]. */\r\nexport class PlaceLineStringTool extends CreateElementTool {\r\n  public static override toolId = \"PlaceLineString\";\r\n  private readonly _points: Point3d[] = [];\r\n  private _snapGeomId?: Id64String;\r\n  private _testGeomJson = false;\r\n  private _testGeomParts = false;\r\n  protected _startedCmd?: string;\r\n\r\n  protected override get wantAccuSnap(): boolean { return true; }\r\n  protected override get wantDynamics(): boolean { return true; }\r\n\r\n  protected async startCommand(): Promise<string> {\r\n    if (undefined !== this._startedCmd)\r\n      return this._startedCmd;\r\n    return EditTools.startCommand<string>({ commandId: editorBuiltInCmdIds.cmdBasicManipulation, iModelKey: this.iModel.key });\r\n  }\r\n\r\n  protected override setupAndPromptForNextAction(): void {\r\n    const nPts = this._points.length;\r\n\r\n    if (0 !== nPts) {\r\n      const hints = new AccuDrawHintBuilder();\r\n      hints.enableSmartRotation = true;\r\n\r\n      if (nPts > 1 && !this._points[nPts - 1].isAlmostEqual(this._points[nPts - 2]))\r\n        hints.setXAxis(Vector3d.createStartEnd(this._points[nPts - 2], this._points[nPts - 1])); // Rotate AccuDraw to last segment.\r\n\r\n      hints.setOrigin(this._points[nPts - 1]);\r\n      hints.sendHints();\r\n    }\r\n\r\n    super.setupAndPromptForNextAction();\r\n  }\r\n\r\n  protected override provideToolAssistance(_mainInstrText?: string, _additionalInstr?: ToolAssistanceInstruction[]): void {\r\n    const nPts = this._points.length;\r\n    const mainMsg = 0 === nPts ? \"ElementSet.Prompts.StartPoint\" : (1 === nPts ? \"ElementSet.Prompts.EndPoint\" : \"ElementSet.Inputs.AdditionalPoint\");\r\n    const leftMsg = \"ElementSet.Inputs.AcceptPoint\";\r\n    const rightMsg = nPts > 1 ? \"ElementSet.Inputs.Complete\" : \"ElementSet.Inputs.Cancel\";\r\n\r\n    const mouseInstructions: ToolAssistanceInstruction[] = [];\r\n    const touchInstructions: ToolAssistanceInstruction[] = [];\r\n\r\n    if (!ToolAssistance.createTouchCursorInstructions(touchInstructions))\r\n      touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.OneTouchTap, CoreTools.translate(leftMsg), false, ToolAssistanceInputMethod.Touch));\r\n    mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.LeftClick, CoreTools.translate(leftMsg), false, ToolAssistanceInputMethod.Mouse));\r\n\r\n    touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.TwoTouchTap, CoreTools.translate(rightMsg), false, ToolAssistanceInputMethod.Touch));\r\n    mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.RightClick, CoreTools.translate(rightMsg), false, ToolAssistanceInputMethod.Mouse));\r\n\r\n    const sections: ToolAssistanceSection[] = [];\r\n    sections.push(ToolAssistance.createSection(mouseInstructions, ToolAssistance.inputsLabel));\r\n    sections.push(ToolAssistance.createSection(touchInstructions, ToolAssistance.inputsLabel));\r\n\r\n    const mainInstruction = ToolAssistance.createInstruction(this.iconSpec, CoreTools.translate(mainMsg));\r\n    const instructions = ToolAssistance.createInstructions(mainInstruction, sections);\r\n    IModelApp.notifications.setToolAssistance(instructions);\r\n  }\r\n\r\n  public override testDecorationHit(id: Id64String): boolean {\r\n    return id === this._snapGeomId;\r\n  }\r\n\r\n  public override getDecorationGeometry(_hit: HitDetail): GeometryStreamProps | undefined {\r\n    if (this._points.length < 2)\r\n      return undefined;\r\n\r\n    const geom = IModelJson.Writer.toIModelJson(LineString3d.create(this._points));\r\n    return geom ? [geom] : undefined;\r\n  }\r\n\r\n  public override decorate(context: DecorateContext): void {\r\n    if (this._points.length < 2)\r\n      return;\r\n\r\n    if (undefined === this._snapGeomId)\r\n      this._snapGeomId = this.iModel.transientIds.getNext();\r\n\r\n    const builder = context.createGraphicBuilder(GraphicType.WorldDecoration, undefined, this._snapGeomId);\r\n    builder.setSymbology(context.viewport.getContrastToBackgroundColor(), ColorDef.black, 1);\r\n    builder.addLineString(this._points);\r\n    context.addDecorationFromBuilder(builder);\r\n  }\r\n\r\n  public override onDynamicFrame(ev: BeButtonEvent, context: DynamicsContext): void {\r\n    if (this._points.length < 1)\r\n      return;\r\n\r\n    // Only draw current segment in dynamics - accepted segments are drawn as pickable decorations.\r\n    const builder = context.createSceneGraphicBuilder();\r\n    builder.setSymbology(context.viewport.getContrastToBackgroundColor(), ColorDef.black, 1);\r\n    builder.addLineString([this._points[this._points.length - 1].clone(), ev.point.clone()]);\r\n    context.addGraphic(builder.finish());\r\n  }\r\n\r\n  public override async onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled> {\r\n    this._points.push(ev.point.clone());\r\n    return super.onDataButtonDown(ev);\r\n  }\r\n\r\n  protected async createElement(): Promise<void> {\r\n    const vp = this.targetView;\r\n    assert(undefined !== vp);\r\n    assert(2 <= this._points.length);\r\n\r\n    const model = this.targetModelId;\r\n    const category = this.targetCategory;\r\n\r\n    const origin = this._points[0];\r\n    const angles = new YawPitchRollAngles();\r\n\r\n    const matrix = AccuDrawHintBuilder.getCurrentRotation(vp, true, true);\r\n    ElementGeometry.Builder.placementAnglesFromPoints(this._points, matrix?.getColumn(2), angles);\r\n\r\n    try {\r\n      this._startedCmd = await this.startCommand();\r\n\r\n      if (this._testGeomJson) {\r\n        const builder = new GeometryStreamBuilder();\r\n        const primitive = LineString3d.create(this._points);\r\n\r\n        builder.setLocalToWorld3d(origin, angles); // Establish world to local transform...\r\n        if (!builder.appendGeometry(primitive))\r\n          return;\r\n\r\n        if (this._testGeomParts) {\r\n          const partBuilder = new GeometryStreamBuilder();\r\n          const sphere = Sphere.createCenterRadius(Point3d.createZero(), this._points[0].distance(this._points[1]) * 0.05);\r\n\r\n          if (!partBuilder.appendGeometry(sphere))\r\n            return;\r\n\r\n          const partProps: GeometryPartProps = { classFullName: \"BisCore:GeometryPart\", model: IModel.dictionaryId, code: Code.createEmpty(), geom: partBuilder.geometryStream };\r\n          const partId = await basicManipulationIpc.insertGeometryPart(partProps);\r\n\r\n          for (const pt of this._points) {\r\n            if (!builder.appendGeometryPart3d(partId, pt))\r\n              return;\r\n          }\r\n        }\r\n\r\n        const elemProps: PhysicalElementProps = { classFullName: \"Generic:PhysicalObject\", model, category, code: Code.createEmpty(), placement: { origin, angles }, geom: builder.geometryStream };\r\n        await basicManipulationIpc.insertGeometricElement(elemProps);\r\n        await this.saveChanges();\r\n      } else {\r\n        const builder = new ElementGeometry.Builder();\r\n        const primitive = LineString3d.create(this._points);\r\n\r\n        builder.setLocalToWorld3d(origin, angles); // Establish world to local transform...\r\n        if (!builder.appendGeometryQuery(primitive))\r\n          return;\r\n\r\n        if (this._testGeomParts) {\r\n          const partBuilder = new ElementGeometry.Builder();\r\n          const sphere = Sphere.createCenterRadius(Point3d.createZero(), this._points[0].distance(this._points[1]) * 0.05);\r\n\r\n          if (!partBuilder.appendGeometryQuery(sphere))\r\n            return;\r\n\r\n          const partProps: GeometryPartProps = { classFullName: \"BisCore:GeometryPart\", model: IModel.dictionaryId, code: Code.createEmpty() };\r\n          const partId = await basicManipulationIpc.insertGeometryPart(partProps, { entryArray: partBuilder.entries });\r\n\r\n          for (const pt of this._points) {\r\n            if (!builder.appendGeometryPart3d(partId, pt))\r\n              return;\r\n          }\r\n        }\r\n\r\n        const elemProps: PhysicalElementProps = { classFullName: \"Generic:PhysicalObject\", model, category, code: Code.createEmpty(), placement: { origin, angles } };\r\n        await basicManipulationIpc.insertGeometricElement(elemProps, { entryArray: builder.entries });\r\n        await this.saveChanges();\r\n      }\r\n    } catch (err: any) {\r\n      IModelApp.notifications.outputMessage(new NotifyMessageDetails(OutputMessagePriority.Error, err.toString()));\r\n    }\r\n  }\r\n\r\n  public override async onResetButtonUp(_ev: BeButtonEvent): Promise<EventHandled> {\r\n    // Accept on reset if we have at least 2 points, starting another tool will reject accepted segments...\r\n    if (this._points.length >= 2)\r\n      await this.createElement();\r\n\r\n    await this.onReinitialize();\r\n    return EventHandled.No;\r\n  }\r\n\r\n  public override async onUndoPreviousStep(): Promise<boolean> {\r\n    if (0 === this._points.length)\r\n      return false;\r\n\r\n    this._points.pop();\r\n    if (0 === this._points.length)\r\n      await this.onReinitialize();\r\n    else\r\n      this.setupAndPromptForNextAction();\r\n\r\n    return true;\r\n  }\r\n\r\n  public async onRestartTool() {\r\n    const tool = new PlaceLineStringTool();\r\n    if (!await tool.run())\r\n      return this.exitTool();\r\n  }\r\n}\r\n"
        ],
        "mappings": "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",
        "names": []
      }
    }
  ]
}
