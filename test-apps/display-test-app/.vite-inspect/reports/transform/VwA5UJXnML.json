{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/topology/HalfEdgeMarkSet.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\nimport { HalfEdgeMask } from \"./Graph\";\n/** @packageDocumentation\n * @module Topology\n */\n/**\n * A class to manage a set of edges as both (a) an array of possible members and (b) mask bits.\n * * A half edge is \"in the MarkSet\" if its mask is set.\n * * The MarkSet array is a superset of the half edges in the set.\n * * Entry of a HalfEdge into the set is indicated by both\n *    * adding the HalfEdge to the array\n *    * setting the mask on the half edge, edge, face, or vertex\n * * Half edges can \"go out of the MarkSet\" if the mask is cleared.\n *   * This clearing can happen independently of the array management.\n *   * Hence the array can contain half edges that are no longer in the MarkSet\n *   * the \"remove\" methods monitor this.\n * * Derived classes expand this concept for edge, vertex, or face MarkSets.\n *   * a single representative of an edge, vertex, or face is entered to the array\n *   * all edges around the edge, vertex, or face are marked with the mask\n *   * Hence the array contains one or more representatives of the edge, face, or vertex\n * * This allows quick query for both:\n *   * Testing the mask gives constant time test of whether a HalfEdge is in the set\n *   * access through the array gives direct access to the HalfEdge pointers\n * @internal\n */\nexport class AbstractHalfEdgeGraphMarkSet {\n    constructor(graph, mask) {\n        this._graph = graph;\n        this._candidates = [];\n        this._mask = mask;\n        this._graph.clearMask(mask);\n    }\n    /** remove all nodes from the set.\n     * * This pops from the array, clearing masks as the pop.\n     * * Note that it does NOT walk the entire graph to clear masks.\n     */\n    clear() {\n        for (; undefined !== this.chooseAndRemoveAny();) {\n        }\n    }\n    /**\n     * count the number of active members.\n     * * This is the number of HalfEdges which are (a) in the array and (b) masked.\n     */\n    getLength() {\n        let n = 0;\n        for (const candidate of this._candidates) {\n            if (candidate.isMaskSet(this._mask))\n                n++;\n        }\n        return n;\n    }\n    /**\n     * Return the number of candidates.\n     * * This may be more than `getLength ()`\n     * * This will typically only be called by the iterator.\n     */\n    getNumCandidates() {\n        return this._candidates.length;\n    }\n    /** Read property accessor: return the graph */\n    get graph() { return this._graph; }\n    /** return borrowed assets (the mask!) to the graph. */\n    teardown() {\n        this._graph.dropMask(this._mask);\n        this._candidates.length = 0;\n        // this._graph = undefined;\n    }\n    /** (Read property) return the mask used to mark members of the set. */\n    get mask() { return this._mask; }\n    /** pop and return the last node out of the array, without testing if it is still marked. */\n    popAndReturn() {\n        const n = this._candidates.length;\n        if (n === 0)\n            return undefined;\n        const node = this._candidates[n - 1];\n        this._candidates.pop();\n        return node;\n    }\n    /**\n     * * read at an index in the candidates array.\n     * * if that candidate has the mask, return it.\n     * * otherwise return undefined.\n     * * REMARK: This is only to be called by the iterator.\n     */\n    getAtIndex(index) {\n        if (index >= 0 && index < this._candidates.length) {\n            const candidate = this._candidates[index];\n            if (candidate.isMaskSet(this._mask))\n                return candidate;\n        }\n        return undefined;\n    }\n    /** Add a node to the set.  This means\n     * * Set the mask\n     * * push the node on the array\n     * * (BUT!) If the node already has the mask, do nothing.\n     * * This base class method affects only the single given HalfEdge.\n     * * Derived classes for edge, face, and vertex will override this method and also set the mask around the larger structures.\n     * @returns true if the HalfEdge is a new member of the set, false if it was already in the set.\n     */\n    addToSet(candidate) {\n        if (candidate.isMaskSet(this._mask))\n            return false;\n        this._candidates.push(candidate);\n        this.setMaskInScope(candidate);\n        return true;\n    }\n    /** Test if `candidate` is already in the set.\n     * * This examines only the mask.\n     */\n    isCandidateInSet(candidate) {\n        return candidate.isMaskSet(this._mask);\n    }\n    /**\n     * * If the candidate is not marked as a member of the MarkSet, do nothing.\n     * * If the candidate is marked:\n     *   * clear the mask\n     *   * but do NOT search the array.\n     *   * As the array is searched, the candidate will appear and be ignored because the mask is not set.\n     * @param candidate\n     * @return true if the candidate was a member (an hence removed), false if the candidate was not masked.\n     */\n    removeFromSet(candidate) {\n        if (!candidate.isMaskSet(this._mask))\n            return false;\n        this.clearMaskInScope(candidate);\n        return true;\n    }\n    /**\n     *  * Search the array to find any current set member\n     *  * If found, clear its mask and return it.\n     *  * If unmasked HalfEdges are found in the array, they are removed from the array.\n     */\n    chooseAndRemoveAny() {\n        for (;;) {\n            const candidate = this.popAndReturn();\n            if (!candidate)\n                return undefined;\n            if (this.removeFromSet(candidate))\n                return candidate;\n        }\n    }\n    /** Create an iterator over member HalfEdges */\n    [Symbol.iterator]() { return new IterableHalfEdgeMarkSetIterator(this); }\n    /**\n     * * visit all half edges around face.\n     * * Add each to mark set.\n     */\n    addAroundFace(seed) {\n        let p = seed;\n        do {\n            this.addToSet(p);\n            p = p.faceSuccessor;\n        } while (p !== seed);\n    }\n    /**\n     * * visit all half edges around vertex.\n     * * Add each to mark set.\n     */\n    addAroundVertex(seed) {\n        let p = seed;\n        do {\n            this.addToSet(p);\n            p = p.vertexSuccessor;\n        } while (p !== seed);\n    }\n}\n/**\n * AbstractHalfEdgeGraphMarkSet specialized to manage the masks on individual half edges\n * @internal\n */\nexport class MarkedHalfEdgeSt extends AbstractHalfEdgeGraphMarkSet {\n    constructor(graph, mask) {\n        super(graph, mask);\n    }\n    /** Create a new 'HalfEdgeMarkSet', operating on half edges with only themselves as scope.\n     * * Returns undefined if unable to get a mask for the graph.\n     * * Undefined return can only happen if the caller is failing to return grabbed masks.\n     */\n    static create(graph) {\n        const mask = graph.grabMask();\n        if (mask === HalfEdgeMask.NULL_MASK)\n            return undefined;\n        return new MarkedHalfEdgeSt(graph, mask);\n    }\n    /**\n     * * Set mask on candidate's edge.\n     * * This overrides the base class implementation.\n     */\n    setMaskInScope(candidate) {\n        candidate.setMask(this._mask);\n    }\n    /**\n     * * Clear mask on candidate's edge.\n     * * This overrides the base class implementation.\n     */\n    clearMaskInScope(candidate) {\n        candidate.clearMask(this._mask);\n    }\n    /**\n     * Return the number of half edges that would be set/cleared when dealing with this candidate.\n     * * This is always 1 for EdgeMarkSet\n     * * return 0 for undefined candidate\n     * @param candidate\n     */\n    countHalfEdgesAroundCandidate(candidate) {\n        if (!candidate)\n            return 0;\n        return 1;\n    }\n}\n/**\n * AbstractHalfEdgeGraphMarkSet specialized to manage the mask on both sides of edges.\n * @internal\n */\nexport class MarkedEdgeSet extends AbstractHalfEdgeGraphMarkSet {\n    constructor(graph, mask) {\n        super(graph, mask);\n    }\n    /** Create a new 'HalfEdgeMarkSet', operating on half edges with only themselves as scope.\n     * * Returns undefined if unable to get a mask for the graph.\n     * * Undefined return can only happen if the caller is failing to return grabbed masks.\n     */\n    static create(graph) {\n        const mask = graph.grabMask();\n        if (mask === HalfEdgeMask.NULL_MASK)\n            return undefined;\n        return new MarkedEdgeSet(graph, mask);\n    }\n    /**\n     * * Set mask on candidate's edge.\n     * * This overrides the base class implementation.\n     */\n    setMaskInScope(candidate) {\n        candidate.setMaskAroundEdge(this._mask);\n    }\n    /**\n     * * Clear mask on candidate's edge.\n     * * This overrides the base class implementation.\n     */\n    clearMaskInScope(candidate) {\n        candidate.clearMaskAroundEdge(this._mask);\n    }\n    /**\n     * Return the number of half edges that would be set/cleared when dealing with this candidate.\n     * * This is always 2 for EdgeMarkSet\n     * @param candidate\n     */\n    countHalfEdgesAroundCandidate(candidate) {\n        if (!candidate)\n            return 0;\n        return 2;\n    }\n}\n/**\n * AbstractHalfEdgeGraphMarkSet specialized to manage the mask around faces\n * @internal\n */\nexport class MarkedFaceSet extends AbstractHalfEdgeGraphMarkSet {\n    constructor(graph, mask) {\n        super(graph, mask);\n    }\n    /** Create a new 'HalfEdgeMarkSet', operating on half edges with only themselves as scope.\n     * * Returns undefined if unable to get a mask for the graph.\n     * * Undefined return can only happen if the caller is failing to return grabbed masks.\n     */\n    static create(graph) {\n        const mask = graph.grabMask();\n        if (mask === HalfEdgeMask.NULL_MASK)\n            return undefined;\n        return new MarkedFaceSet(graph, mask);\n    }\n    /**\n     * * Set mask on (all nodes around) candidate's face\n     * * This overrides the base class implementation.\n     */\n    setMaskInScope(candidate) {\n        candidate.setMaskAroundFace(this._mask);\n    }\n    /**\n     * * Clear mask on (all nodes around) candidate's face.\n     * * This overrides the base class implementation.\n     */\n    clearMaskInScope(candidate) {\n        candidate.clearMaskAroundFace(this._mask);\n    }\n    /**\n     * Return the number of half edges that would be set/cleared when dealing with this candidate.\n     * * This is the \"aroundFace\" count.\n     * @param candidate\n     */\n    countHalfEdgesAroundCandidate(candidate) {\n        if (!candidate)\n            return 0;\n        return candidate.countEdgesAroundFace();\n    }\n}\n/**\n * AbstractHalfEdgeGraphMarkSet specialized to manage the mask around faces\n * @internal\n */\nexport class MarkedVertexSet extends AbstractHalfEdgeGraphMarkSet {\n    constructor(graph, mask) {\n        super(graph, mask);\n    }\n    /** Create a new 'HalfEdgeMarkSet', operating on half edges with only themselves as scope.\n     * * Returns undefined if unable to get a mask for the graph.\n     * * Undefined return can only happen if the caller is failing to return grabbed masks.\n     */\n    static create(graph) {\n        const mask = graph.grabMask();\n        if (mask === HalfEdgeMask.NULL_MASK)\n            return undefined;\n        return new MarkedVertexSet(graph, mask);\n    }\n    /**\n     * * Set mask on (all nodes around) candidate's face\n     * * This overrides the base class implementation.\n     */\n    setMaskInScope(candidate) {\n        candidate.setMaskAroundVertex(this._mask);\n    }\n    /**\n     * * Clear mask on (all nodes around) candidate's face.\n     * * This overrides the base class implementation.\n     */\n    clearMaskInScope(candidate) {\n        candidate.clearMaskAroundVertex(this._mask);\n    }\n    /**\n     * Return the number of half edges that would be set/cleared when dealing with this candidate.\n     * * This is the \"aroundVertex\" count.\n     * @param candidate\n     */\n    countHalfEdgesAroundCandidate(candidate) {\n        if (!candidate)\n            return 0;\n        return candidate.countEdgesAroundVertex();\n    }\n}\n/**\n * Class to act as an iterator over points in a markSet.\n * * Internal data is:\n *   * pointer to the parent markSet\n *   * index of index of the next point to read.\n * * the parent markSet class\n */\nclass IterableHalfEdgeMarkSetIterator {\n    constructor(markSet) {\n        this._markSet = markSet;\n        this._nextReadIndex = 0;\n    }\n    next() {\n        const n = this._markSet.getNumCandidates();\n        // Walk over candidates that have been quietly de-masked\n        while (this._nextReadIndex < n) {\n            const p = this._markSet.getAtIndex(this._nextReadIndex++);\n            if (p !== undefined)\n                return { done: false, value: p };\n        }\n        return { done: true, value: undefined };\n    }\n    [Symbol.iterator]() { return this; }\n}\n//# sourceMappingURL=HalfEdgeMarkSet.js.map",
      "start": 1693508125543,
      "end": 1693508125639,
      "sourcemaps": null
    }
  ]
}
