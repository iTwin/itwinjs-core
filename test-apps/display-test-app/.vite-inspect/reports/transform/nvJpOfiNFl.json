{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/Matrix.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { assert } from \"@itwin/core-bentley\";\nimport { Matrix3d, Matrix4d, Point3d, Transform, Vector3d } from \"@itwin/core-geometry\";\n/** @internal */\nexport class Matrix3 {\n    constructor() {\n        this.data = new Float32Array(3 * 3);\n    }\n    initIdentity() {\n        this.setValues(1, 0, 0, 0, 1, 0, 0, 0, 1);\n    }\n    static fromIdentity(out) {\n        const mat = undefined !== out ? out : new Matrix3();\n        mat.initIdentity();\n        return mat;\n    }\n    copyFrom(src) {\n        for (let i = 0; i < this.data.length; i++) {\n            this.data[i] = src.data[i];\n        }\n    }\n    clone(out) {\n        const mat = undefined !== out ? out : new Matrix3();\n        mat.copyFrom(this);\n        return mat;\n    }\n    setValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n        this.m00 = m00;\n        this.m01 = m01;\n        this.m02 = m02;\n        this.m10 = m10;\n        this.m11 = m11;\n        this.m12 = m12;\n        this.m20 = m20;\n        this.m21 = m21;\n        this.m22 = m22;\n    }\n    static fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22, out) {\n        const mat = undefined !== out ? out : new Matrix3();\n        mat.setValues(m00, m01, m02, m10, m11, m12, m20, m21, m22);\n        return mat;\n    }\n    initFromMatrix3d(rot) {\n        this.setValues(rot.at(0, 0), rot.at(0, 1), rot.at(0, 2), rot.at(1, 0), rot.at(1, 1), rot.at(1, 2), rot.at(2, 0), rot.at(2, 1), rot.at(2, 2));\n    }\n    static fromMatrix3d(rot, out) {\n        const mat = undefined !== out ? out : new Matrix3();\n        mat.initFromMatrix3d(rot);\n        return mat;\n    }\n    toMatrix3d() {\n        const data = this.data;\n        return Matrix3d.createRowValues(data[0], data[3], data[6], data[1], data[4], data[7], data[2], data[5], data[8]);\n    }\n    swap(firstIndex, secondIndex) {\n        assert(firstIndex < this.data.length);\n        assert(secondIndex < this.data.length);\n        assert(secondIndex !== firstIndex);\n        const tmp = this.data[firstIndex];\n        this.data[firstIndex] = this.data[secondIndex];\n        this.data[secondIndex] = tmp;\n    }\n    transpose() {\n        this.swap(1, 3);\n        this.swap(5, 7);\n        this.swap(2, 6);\n    }\n    static fromTranspose(src, out) {\n        const mat = src.clone(out);\n        mat.transpose();\n        return mat;\n    }\n    get(index) {\n        assert(index < this.data.length);\n        return this.data[index];\n    }\n    set(index, value) {\n        assert(index < this.data.length);\n        this.data[index] = value;\n    }\n    at(row, col) { return this.get(col * 3 + row); }\n    setAt(row, col, value) { this.set(col * 3 + row, value); }\n    get m00() { return this.at(0, 0); }\n    set m00(value) { this.setAt(0, 0, value); }\n    get m01() { return this.at(0, 1); }\n    set m01(value) { this.setAt(0, 1, value); }\n    get m02() { return this.at(0, 2); }\n    set m02(value) { this.setAt(0, 2, value); }\n    get m10() { return this.at(1, 0); }\n    set m10(value) { this.setAt(1, 0, value); }\n    get m11() { return this.at(1, 1); }\n    set m11(value) { this.setAt(1, 1, value); }\n    get m12() { return this.at(1, 2); }\n    set m12(value) { this.setAt(1, 2, value); }\n    get m20() { return this.at(2, 0); }\n    set m20(value) { this.setAt(2, 0, value); }\n    get m21() { return this.at(2, 1); }\n    set m21(value) { this.setAt(2, 1, value); }\n    get m22() { return this.at(2, 2); }\n    set m22(value) { this.setAt(2, 2, value); }\n}\n/** @internal */\nexport class Matrix4 {\n    constructor() {\n        this.data = new Float32Array(4 * 4);\n    }\n    copyFrom(src) {\n        for (let i = 0; i < this.data.length; i++) {\n            this.data[i] = src.data[i];\n        }\n    }\n    clone(out) {\n        const mat = undefined !== out ? out : new Matrix4();\n        mat.copyFrom(this);\n        return mat;\n    }\n    initIdentity() {\n        this.setValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n    }\n    static fromIdentity(out) {\n        const mat = undefined !== out ? out : new Matrix4();\n        mat.initIdentity();\n        return mat;\n    }\n    setValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n        this.m00 = m00;\n        this.m01 = m01;\n        this.m02 = m02;\n        this.m03 = m03;\n        this.m10 = m10;\n        this.m11 = m11;\n        this.m12 = m12;\n        this.m13 = m13;\n        this.m20 = m20;\n        this.m21 = m21;\n        this.m22 = m22;\n        this.m23 = m23;\n        this.m30 = m30;\n        this.m31 = m31;\n        this.m32 = m32;\n        this.m33 = m33;\n    }\n    static fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33, out) {\n        const mat = undefined !== out ? out : new Matrix4();\n        mat.setValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);\n        return mat;\n    }\n    getRotation(out) {\n        const rot = undefined !== out ? out : new Matrix3();\n        rot.setValues(this.m00, this.m01, this.m02, this.m10, this.m11, this.m12, this.m20, this.m21, this.m22);\n        return rot;\n    }\n    initFromTransform(transform) {\n        const mat = transform.matrix;\n        const org = transform.origin;\n        this.setValues(mat.at(0, 0), mat.at(0, 1), mat.at(0, 2), org.x, mat.at(1, 0), mat.at(1, 1), mat.at(1, 2), org.y, mat.at(2, 0), mat.at(2, 1), mat.at(2, 2), org.z, 0, 0, 0, 1);\n    }\n    static fromTransform(transform, out) {\n        const mat = undefined !== out ? out : new Matrix4();\n        mat.initFromTransform(transform);\n        return mat;\n    }\n    toTransform() {\n        const data = this.data;\n        assert(0.0 === data[3] && 0.0 === data[7] && 0.0 === data[11] && 1.0 === data[15]);\n        const origin = new Point3d(data[12], data[13], data[14]);\n        const rotMat = Matrix3d.createIdentity();\n        for (let i = 0; i < 3; i++)\n            for (let j = 0; j < 3; j++)\n                rotMat.setAt(i, j, data[i + j * 4]);\n        return Transform.createRefs(origin, rotMat);\n    }\n    initFromMatrix4d(mat) {\n        this.setValues(mat.atIJ(0, 0), mat.atIJ(0, 1), mat.atIJ(0, 2), mat.atIJ(0, 3), mat.atIJ(1, 0), mat.atIJ(1, 1), mat.atIJ(1, 2), mat.atIJ(1, 3), mat.atIJ(2, 0), mat.atIJ(2, 1), mat.atIJ(2, 2), mat.atIJ(2, 3), mat.atIJ(3, 0), mat.atIJ(3, 1), mat.atIJ(3, 2), mat.atIJ(3, 3));\n    }\n    static fromMatrix4d(mat, out) {\n        const result = undefined !== out ? out : new Matrix4();\n        result.initFromMatrix4d(mat);\n        return result;\n    }\n    toMatrix4d(result) {\n        const data = this.data;\n        return Matrix4d.createRowValues(data[0], data[4], data[8], data[12], data[1], data[5], data[9], data[13], data[2], data[6], data[10], data[14], data[3], data[7], data[11], data[15], result);\n    }\n    lookAt(eye, center, up) {\n        const f = normalizedDifference(center, eye);\n        if (undefined === f) {\n            return false;\n        }\n        const s = fromNormalizedCrossProduct(f, up);\n        if (undefined === s) {\n            return false;\n        }\n        const u = Vector3d.createCrossProduct(s.x, s.y, s.z, f.x, f.y, f.z);\n        this.setValues(s.x, s.y, s.z, -s.dotProduct(eye), u.x, u.y, u.z, -u.dotProduct(eye), -f.x, -f.y, -f.z, f.dotProduct(eye), 0, 0, 0, 1);\n        return true;\n    }\n    static fromLookAt(eye, center, up, out) {\n        const mat = undefined !== out ? out : new Matrix4();\n        return mat.lookAt(eye, center, up) ? mat : undefined;\n    }\n    // left, right, bottom, top, near, far\n    frustum(l, r, b, t, n, f) {\n        this.setValues((2 * n) / (r - l), 0, (r + l) / (r - l), 0, 0, (2 * n) / (t - b), (t + b) / (t - b), 0, 0, 0, -(f + n) / (f - n), -(2 * f * n) / (f - n), 0, 0, -1, 0);\n    }\n    static fromFrustum(l, r, b, t, n, f, out) {\n        const mat = undefined !== out ? out : new Matrix4();\n        mat.frustum(l, r, b, t, n, f);\n        return mat;\n    }\n    perspective(fovY, aspectRatio, nearZ, farZ) {\n        const frustumHeight = Math.tan(fovY / 360 * Math.PI) * nearZ;\n        const frustumWidth = frustumHeight * aspectRatio;\n        this.frustum(-frustumWidth, frustumWidth, -frustumHeight, frustumHeight, nearZ, farZ);\n    }\n    static fromPerspective(fovY, aspectRatio, nearZ, farZ, out) {\n        const mat = undefined !== out ? out : new Matrix4();\n        mat.perspective(fovY, aspectRatio, nearZ, farZ);\n        return mat;\n    }\n    ortho(l, r, b, t, n, f) {\n        this.setValues(2 / (r - l), 0, 0, -(r + l) / (r - l), 0, 2 / (t - b), 0, -(t + b) / (t - b), 0, 0, -2 / (f - n), -(f + n) / (f - n), 0, 0, 0, 1);\n    }\n    static fromOrtho(l, r, b, t, n, f, out) {\n        const mat = undefined !== out ? out : new Matrix4();\n        mat.ortho(l, r, b, t, n, f);\n        return mat;\n    }\n    invert() {\n        const d = this.data;\n        const d0 = d[0];\n        const d1 = d[1];\n        const d2 = d[2];\n        const d3 = d[3];\n        this.setValues(d[5] * d[10] * d[15] - d[5] * d[11] * d[14] - d[9] * d[6] * d[15] + d[9] * d[7] * d[14] + d[13] * d[6] * d[11] - d[13] * d[7] * d[10], -d[4] * d[10] * d[15] + d[4] * d[11] * d[14] + d[8] * d[6] * d[15] - d[8] * d[7] * d[14] - d[12] * d[6] * d[11] + d[12] * d[7] * d[10], d[4] * d[9] * d[15] - d[4] * d[11] * d[13] - d[8] * d[5] * d[15] + d[8] * d[7] * d[13] + d[12] * d[5] * d[11] - d[12] * d[7] * d[9], -d[4] * d[9] * d[14] + d[4] * d[10] * d[13] + d[8] * d[5] * d[14] - d[8] * d[6] * d[13] - d[12] * d[5] * d[10] + d[12] * d[6] * d[9], -d[1] * d[10] * d[15] + d[1] * d[11] * d[14] + d[9] * d[2] * d[15] - d[9] * d[3] * d[14] - d[13] * d[2] * d[11] + d[13] * d[3] * d[10], d[0] * d[10] * d[15] - d[0] * d[11] * d[14] - d[8] * d[2] * d[15] + d[8] * d[3] * d[14] + d[12] * d[2] * d[11] - d[12] * d[3] * d[10], -d[0] * d[9] * d[15] + d[0] * d[11] * d[13] + d[8] * d[1] * d[15] - d[8] * d[3] * d[13] - d[12] * d[1] * d[11] + d[12] * d[3] * d[9], d[0] * d[9] * d[14] - d[0] * d[10] * d[13] - d[8] * d[1] * d[14] + d[8] * d[2] * d[13] + d[12] * d[1] * d[10] - d[12] * d[2] * d[9], d[1] * d[6] * d[15] - d[1] * d[7] * d[14] - d[5] * d[2] * d[15] + d[5] * d[3] * d[14] + d[13] * d[2] * d[7] - d[13] * d[3] * d[6], -d[0] * d[6] * d[15] + d[0] * d[7] * d[14] + d[4] * d[2] * d[15] - d[4] * d[3] * d[14] - d[12] * d[2] * d[7] + d[12] * d[3] * d[6], d[0] * d[5] * d[15] - d[0] * d[7] * d[13] - d[4] * d[1] * d[15] + d[4] * d[3] * d[13] + d[12] * d[1] * d[7] - d[12] * d[3] * d[5], -d[0] * d[5] * d[14] + d[0] * d[6] * d[13] + d[4] * d[1] * d[14] - d[4] * d[2] * d[13] - d[12] * d[1] * d[6] + d[12] * d[2] * d[5], -d[1] * d[6] * d[11] + d[1] * d[7] * d[10] + d[5] * d[2] * d[11] - d[5] * d[3] * d[10] - d[9] * d[2] * d[7] + d[9] * d[3] * d[6], d[0] * d[6] * d[11] - d[0] * d[7] * d[10] - d[4] * d[2] * d[11] + d[4] * d[3] * d[10] + d[8] * d[2] * d[7] - d[8] * d[3] * d[6], -d[0] * d[5] * d[11] + d[0] * d[7] * d[9] + d[4] * d[1] * d[11] - d[4] * d[3] * d[9] - d[8] * d[1] * d[7] + d[8] * d[3] * d[5], d[0] * d[5] * d[10] - d[0] * d[6] * d[9] - d[4] * d[1] * d[10] + d[4] * d[2] * d[9] + d[8] * d[1] * d[6] - d[8] * d[2] * d[5]);\n        const determinant = d0 * d[0] + d1 * d[4] + d2 * d[8] + d3 * d[12];\n        if (0 === determinant) {\n            this.initIdentity();\n            return false;\n        }\n        this.multiplyByScalar(1 / determinant);\n        return true;\n    }\n    static fromInverse(src, out) {\n        const mat = src.clone(out);\n        return mat.invert() ? mat : undefined;\n    }\n    swap(firstIndex, secondIndex) {\n        assert(firstIndex < this.data.length);\n        assert(secondIndex < this.data.length);\n        assert(secondIndex !== firstIndex);\n        const tmp = this.data[firstIndex];\n        this.data[firstIndex] = this.data[secondIndex];\n        this.data[secondIndex] = tmp;\n    }\n    transpose() {\n        this.swap(1, 4);\n        this.swap(2, 8);\n        this.swap(3, 12);\n        this.swap(6, 9);\n        this.swap(7, 13);\n        this.swap(11, 14);\n    }\n    static fromTranspose(src, out) {\n        const mat = src.clone(out);\n        mat.transpose();\n        return mat;\n    }\n    multiplyBy(other) {\n        const a = this.data;\n        const b = other.data;\n        this.setValues(a[0] * b[0] + a[4] * b[1] + a[8] * b[2] + a[12] * b[3], a[0] * b[4] + a[4] * b[5] + a[8] * b[6] + a[12] * b[7], a[0] * b[8] + a[4] * b[9] + a[8] * b[10] + a[12] * b[11], a[0] * b[12] + a[4] * b[13] + a[8] * b[14] + a[12] * b[15], a[1] * b[0] + a[5] * b[1] + a[9] * b[2] + a[13] * b[3], a[1] * b[4] + a[5] * b[5] + a[9] * b[6] + a[13] * b[7], a[1] * b[8] + a[5] * b[9] + a[9] * b[10] + a[13] * b[11], a[1] * b[12] + a[5] * b[13] + a[9] * b[14] + a[13] * b[15], a[2] * b[0] + a[6] * b[1] + a[10] * b[2] + a[14] * b[3], a[2] * b[4] + a[6] * b[5] + a[10] * b[6] + a[14] * b[7], a[2] * b[8] + a[6] * b[9] + a[10] * b[10] + a[14] * b[11], a[2] * b[12] + a[6] * b[13] + a[10] * b[14] + a[14] * b[15], a[3] * b[0] + a[7] * b[1] + a[11] * b[2] + a[15] * b[3], a[3] * b[4] + a[7] * b[5] + a[11] * b[6] + a[15] * b[7], a[3] * b[8] + a[7] * b[9] + a[11] * b[10] + a[15] * b[11], a[3] * b[12] + a[7] * b[13] + a[11] * b[14] + a[15] * b[15]);\n    }\n    static fromProduct(a, b, out) {\n        const mat = a.clone(out);\n        mat.multiplyBy(b);\n        return mat;\n    }\n    multiplyByScalar(scalar) {\n        for (let i = 0; i < this.data.length; i++) {\n            this.data[i] *= scalar;\n        }\n    }\n    get(index) {\n        assert(index < this.data.length);\n        return this.data[index];\n    }\n    set(index, value) {\n        assert(index < this.data.length);\n        this.data[index] = value;\n    }\n    at(row, col) { return this.get(col * 4 + row); }\n    setAt(row, col, value) { this.set(col * 4 + row, value); }\n    get m00() { return this.at(0, 0); }\n    set m00(value) { this.setAt(0, 0, value); }\n    get m01() { return this.at(0, 1); }\n    set m01(value) { this.setAt(0, 1, value); }\n    get m02() { return this.at(0, 2); }\n    set m02(value) { this.setAt(0, 2, value); }\n    get m03() { return this.at(0, 3); }\n    set m03(value) { this.setAt(0, 3, value); }\n    get m10() { return this.at(1, 0); }\n    set m10(value) { this.setAt(1, 0, value); }\n    get m11() { return this.at(1, 1); }\n    set m11(value) { this.setAt(1, 1, value); }\n    get m12() { return this.at(1, 2); }\n    set m12(value) { this.setAt(1, 2, value); }\n    get m13() { return this.at(1, 3); }\n    set m13(value) { this.setAt(1, 3, value); }\n    get m20() { return this.at(2, 0); }\n    set m20(value) { this.setAt(2, 0, value); }\n    get m21() { return this.at(2, 1); }\n    set m21(value) { this.setAt(2, 1, value); }\n    get m22() { return this.at(2, 2); }\n    set m22(value) { this.setAt(2, 2, value); }\n    get m23() { return this.at(2, 3); }\n    set m23(value) { this.setAt(2, 3, value); }\n    get m30() { return this.at(3, 0); }\n    set m30(value) { this.setAt(3, 0, value); }\n    get m31() { return this.at(3, 1); }\n    set m31(value) { this.setAt(3, 1, value); }\n    get m32() { return this.at(3, 2); }\n    set m32(value) { this.setAt(3, 2, value); }\n    get m33() { return this.at(3, 3); }\n    set m33(value) { this.setAt(3, 3, value); }\n}\n// missing Vector3d functions\n/** @internal */\nexport function fromNormalizedCrossProduct(vec0, vec1) {\n    return vec0.unitCrossProduct(vec1);\n}\n/** @internal */\nexport function normalizedDifference(target, origin) {\n    return Vector3d.createStartEnd(origin, target).normalize();\n}\n//# sourceMappingURL=Matrix.js.map",
      "start": 1693508124720,
      "end": 1693508124924,
      "sourcemaps": null
    }
  ]
}
