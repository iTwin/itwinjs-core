{
  "resolvedId": "D:/hub2023A/itwinjs-core/test-apps/display-test-app/src/frontend/ViewClipByElementGeometryTool.ts",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\r\n* See LICENSE.md in the project root for license terms and full copyright notice.\r\n*--------------------------------------------------------------------------------------------*/\r\nimport {\r\n  ClipPrimitive, ClipVector, ConvexClipPlaneSet, IndexedPolyface, Point3d, PolyfaceBuilder, PolyfaceQuery, UnionOfConvexClipPlaneSets,\r\n} from \"@itwin/core-geometry\";\r\nimport {\r\n  ElementMeshOptions, readElementMeshes,\r\n} from \"@itwin/core-common\";\r\nimport {\r\n  BeButtonEvent, CoordinateLockOverrides, EventHandled, IModelApp, LocateResponse, ViewClipTool, Viewport,\r\n} from \"@itwin/core-frontend\";\r\nimport {\r\n  ConvexMeshDecomposition, Options as DecompositionOptions,\r\n} from \"vhacd-js\";\r\n\r\n/** Settings that control the behavior of the ViewClipByElementGeometryTool. */\r\ninterface Settings extends ElementMeshOptions {\r\n  /** If true, produce convex hulls from the element geometry. Convex hulls are required for proper clipping; if this is\r\n   * set to false, make sure to only select elements that already have convex geometry.\r\n   */\r\n  computeConvexHulls: boolean;\r\n  /** Options used to produce convex hulls, if computeConvexHulls is true. */\r\n  decomposition: DecompositionOptions;\r\n  /** An offset in meters by which to expand or contract the surfaces of the clipping polyfaces.\r\n   * This is useful primarily for expanding the clipped volume slightly so that the element(s) from which the clip was produced are not clipped out.\r\n   */\r\n  offset?: number;\r\n}\r\n\r\n/** Uses vhacd-js to convert IndexedPolyfaces to convex IndexedPolyfaces. */\r\nclass ConvexDecomposer {\r\n  private readonly _impl: ConvexMeshDecomposition;\r\n  private readonly _opts: DecompositionOptions;\r\n\r\n  private constructor(impl: ConvexMeshDecomposition, options: DecompositionOptions) {\r\n    this._impl = impl;\r\n    this._opts = options;\r\n  }\r\n\r\n  public static async create(options: DecompositionOptions): Promise<ConvexDecomposer> {\r\n    const impl = await ConvexMeshDecomposition.create();\r\n    return new ConvexDecomposer(impl, options);\r\n  }\r\n\r\n  public decompose(polyfaces: IndexedPolyface[]): IndexedPolyface[] {\r\n    const decomposedPolyfaces: IndexedPolyface[] = [];\r\n    const polygon = [new Point3d(), new Point3d(), new Point3d()];\r\n\r\n    for (const polyface of polyfaces) {\r\n      if (PolyfaceQuery.isConvexByDihedralAngleCount(polyface)) {\r\n        // The polyface is already convex - don't bother performing decomposition.\r\n        decomposedPolyfaces.push(polyface);\r\n        continue;\r\n      }\r\n\r\n      const points = polyface.data.point;\r\n\r\n      // `points` is a GrowableXYZArray, which may allocate more space than it needs for the number of points it stores.\r\n      // Make sure to only pass the used portion of the allocation to vhacd-js.\r\n      const positions = new Float64Array(points.float64Data().buffer, 0, points.float64Length);\r\n\r\n      // Unfortunately we must copy the indices rather than passing them directly to vhacd-js.\r\n      const indices = new Uint32Array(polyface.data.pointIndex);\r\n      if (indices.length === 0 || positions.length === 0)\r\n        continue;\r\n\r\n      // Decompose the polyface into any number of convex hulls.\r\n      const meshes = this._impl.computeConvexHulls({ positions, indices }, this._opts);\r\n\r\n      // Convert each hull into a polyface.\r\n      for (const mesh of meshes) {\r\n        const builder = PolyfaceBuilder.create();\r\n        for (let i = 0; i < mesh.indices.length; i += 3) {\r\n          for (let j = 0; j < 3; j++)\r\n            this.getPoint(mesh.indices[i + j], mesh.positions, polygon[j]);\r\n\r\n          builder.addPolygon(polygon);\r\n        }\r\n\r\n        decomposedPolyfaces.push(builder.claimPolyface());\r\n      }\r\n    }\r\n\r\n    return decomposedPolyfaces;\r\n  }\r\n\r\n  private getPoint(index: number, positions: Float64Array, output: Point3d): void {\r\n    index *= 3;\r\n    output.set(positions[index + 0], positions[index + 1], positions[index + 2]);\r\n  }\r\n}\r\n\r\n// For demo purposes, settings are global and the only way to change them is to edit the code below.\r\nconst settings: Settings = {\r\n  offset: 0.025,\r\n  computeConvexHulls: true,\r\n  chordTolerance: 0.1,\r\n  decomposition: {\r\n    maxHulls: 10,\r\n    maxVerticesPerHull: 16,\r\n  },\r\n};\r\n\r\n/** Clips the view based on the geometry of one or more geometric elements.\r\n * We obtain polyfaces from the backend for each element and produce convex hulls from each polyface.\r\n * Then we create a ClipVector that clips out any geometry not inside one of the hulls.\r\n *\r\n * This tool exists for example purposes only. Some inefficiencies exist, including:\r\n *  - Convex mesh decomposition can take some time. Ideally it would be performed in a WebWorker so as not to block the UI thread.\r\n *  - If we had a way to determine if a polyface is already convex, we could avoid performing unnecessary decomposition on such polyfaces.\r\n */\r\nexport class ViewClipByElementGeometryTool extends ViewClipTool {\r\n  public static override toolId = \"DtaClipByElementGeometry\";\r\n  public static override iconSpec = \"icon-section-element\";\r\n\r\n  public override async onPostInstall() {\r\n    await super.onPostInstall();\r\n\r\n    // If some elements are already selected, immediately clip the view using their geometry.\r\n    if (this.targetView && this.targetView.iModel.selectionSet.isActive) {\r\n      await this.doClipToSelectedElements(this.targetView);\r\n      return;\r\n    }\r\n\r\n    // Wait for the user to select the elements to use for clipping.\r\n    this.initLocateElements(true, false, \"default\", CoordinateLockOverrides.All);\r\n  }\r\n\r\n  public override async onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled> {\r\n    if (!this.targetView)\r\n      return EventHandled.No;\r\n\r\n    // Identify the element selected.\r\n    const hit = await IModelApp.locateManager.doLocate(new LocateResponse(), true, ev.point, ev.viewport, ev.inputSource);\r\n    if (!hit || !hit.isElementHit)\r\n      return EventHandled.No;\r\n\r\n    // Clip the view using the selected element's geometry.\r\n    return await this.doClipToElements(this.targetView, new Set<string>([hit.sourceId])) ? EventHandled.Yes : EventHandled.No;\r\n  }\r\n\r\n  /** Clip the view using the geometry of all elements currently in the selection set. */\r\n  private async doClipToSelectedElements(viewport: Viewport): Promise<boolean> {\r\n    if (await this.doClipToElements(viewport, viewport.iModel.selectionSet.elements))\r\n      return true;\r\n\r\n    await this.exitTool();\r\n    return false;\r\n  }\r\n\r\n  /** Clip the view using the geometry of the specified elements. */\r\n  private async doClipToElements(viewport: Viewport, ids: Set<string>): Promise<boolean> {\r\n    try {\r\n      const union = UnionOfConvexClipPlaneSets.createEmpty();\r\n      const decomposer = settings.computeConvexHulls ? await ConvexDecomposer.create(settings.decomposition) : undefined;\r\n\r\n      for (const source of ids) {\r\n        // Obtain polyfaces for this element.\r\n        const meshData = await viewport.iModel.generateElementMeshes({ ...settings, source });\r\n        let polyfaces = readElementMeshes(meshData);\r\n\r\n        // Offset if specified - typically used to expand the element envelope slightly.\r\n        // ###TODO cloneOffset should return IndexedPolyface, not Polyface?\r\n        const offset = settings.offset;\r\n        if (offset)\r\n          polyfaces = polyfaces.map((pf) => PolyfaceQuery.cloneOffset(pf, offset));\r\n\r\n        // Convert to convex hulls unless otherwise specified.\r\n        if (decomposer)\r\n          polyfaces = decomposer.decompose(polyfaces);\r\n\r\n        // Add each polyface as a clipper.\r\n        for (const polyface of polyfaces)\r\n          union.addConvexSet(ConvexClipPlaneSet.createConvexPolyface(polyface).clipper);\r\n      }\r\n\r\n      // Apply the clip to the view.\r\n      ViewClipTool.enableClipVolume(viewport);\r\n      const primitive = ClipPrimitive.createCapture(union);\r\n      const clip = ClipVector.createCapture([primitive]);\r\n      ViewClipTool.setViewClip(viewport, clip);\r\n\r\n      this._clipEventHandler?.onNewClip(viewport);\r\n\r\n      await this.onReinitialize();\r\n      return true;\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n}\r\n",
      "start": 1693508121179,
      "end": 1693508121254,
      "sourcemaps": null
    },
    {
      "name": "vite:esbuild",
      "result": "\"use strict\";\nimport {\n  ClipPrimitive,\n  ClipVector,\n  ConvexClipPlaneSet,\n  Point3d,\n  PolyfaceBuilder,\n  PolyfaceQuery,\n  UnionOfConvexClipPlaneSets\n} from \"@itwin/core-geometry\";\nimport {\n  readElementMeshes\n} from \"@itwin/core-common\";\nimport {\n  CoordinateLockOverrides,\n  EventHandled,\n  IModelApp,\n  LocateResponse,\n  ViewClipTool\n} from \"@itwin/core-frontend\";\nimport {\n  ConvexMeshDecomposition\n} from \"vhacd-js\";\nclass ConvexDecomposer {\n  constructor(impl, options) {\n    this._impl = impl;\n    this._opts = options;\n  }\n  static async create(options) {\n    const impl = await ConvexMeshDecomposition.create();\n    return new ConvexDecomposer(impl, options);\n  }\n  decompose(polyfaces) {\n    const decomposedPolyfaces = [];\n    const polygon = [new Point3d(), new Point3d(), new Point3d()];\n    for (const polyface of polyfaces) {\n      if (PolyfaceQuery.isConvexByDihedralAngleCount(polyface)) {\n        decomposedPolyfaces.push(polyface);\n        continue;\n      }\n      const points = polyface.data.point;\n      const positions = new Float64Array(points.float64Data().buffer, 0, points.float64Length);\n      const indices = new Uint32Array(polyface.data.pointIndex);\n      if (indices.length === 0 || positions.length === 0)\n        continue;\n      const meshes = this._impl.computeConvexHulls({ positions, indices }, this._opts);\n      for (const mesh of meshes) {\n        const builder = PolyfaceBuilder.create();\n        for (let i = 0; i < mesh.indices.length; i += 3) {\n          for (let j = 0; j < 3; j++)\n            this.getPoint(mesh.indices[i + j], mesh.positions, polygon[j]);\n          builder.addPolygon(polygon);\n        }\n        decomposedPolyfaces.push(builder.claimPolyface());\n      }\n    }\n    return decomposedPolyfaces;\n  }\n  getPoint(index, positions, output) {\n    index *= 3;\n    output.set(positions[index + 0], positions[index + 1], positions[index + 2]);\n  }\n}\nconst settings = {\n  offset: 0.025,\n  computeConvexHulls: true,\n  chordTolerance: 0.1,\n  decomposition: {\n    maxHulls: 10,\n    maxVerticesPerHull: 16\n  }\n};\nexport class ViewClipByElementGeometryTool extends ViewClipTool {\n  async onPostInstall() {\n    await super.onPostInstall();\n    if (this.targetView && this.targetView.iModel.selectionSet.isActive) {\n      await this.doClipToSelectedElements(this.targetView);\n      return;\n    }\n    this.initLocateElements(true, false, \"default\", CoordinateLockOverrides.All);\n  }\n  async onDataButtonDown(ev) {\n    if (!this.targetView)\n      return EventHandled.No;\n    const hit = await IModelApp.locateManager.doLocate(new LocateResponse(), true, ev.point, ev.viewport, ev.inputSource);\n    if (!hit || !hit.isElementHit)\n      return EventHandled.No;\n    return await this.doClipToElements(this.targetView, /* @__PURE__ */ new Set([hit.sourceId])) ? EventHandled.Yes : EventHandled.No;\n  }\n  /** Clip the view using the geometry of all elements currently in the selection set. */\n  async doClipToSelectedElements(viewport) {\n    if (await this.doClipToElements(viewport, viewport.iModel.selectionSet.elements))\n      return true;\n    await this.exitTool();\n    return false;\n  }\n  /** Clip the view using the geometry of the specified elements. */\n  async doClipToElements(viewport, ids) {\n    try {\n      const union = UnionOfConvexClipPlaneSets.createEmpty();\n      const decomposer = settings.computeConvexHulls ? await ConvexDecomposer.create(settings.decomposition) : void 0;\n      for (const source of ids) {\n        const meshData = await viewport.iModel.generateElementMeshes({ ...settings, source });\n        let polyfaces = readElementMeshes(meshData);\n        const offset = settings.offset;\n        if (offset)\n          polyfaces = polyfaces.map((pf) => PolyfaceQuery.cloneOffset(pf, offset));\n        if (decomposer)\n          polyfaces = decomposer.decompose(polyfaces);\n        for (const polyface of polyfaces)\n          union.addConvexSet(ConvexClipPlaneSet.createConvexPolyface(polyface).clipper);\n      }\n      ViewClipTool.enableClipVolume(viewport);\n      const primitive = ClipPrimitive.createCapture(union);\n      const clip = ClipVector.createCapture([primitive]);\n      ViewClipTool.setViewClip(viewport, clip);\n      this._clipEventHandler?.onNewClip(viewport);\n      await this.onReinitialize();\n      return true;\n    } catch {\n      return false;\n    }\n  }\n}\nViewClipByElementGeometryTool.toolId = \"DtaClipByElementGeometry\";\nViewClipByElementGeometryTool.iconSpec = \"icon-section-element\";\n",
      "start": 1693508121254,
      "end": 1693508121435,
      "order": "normal",
      "sourcemaps": {
        "version": 3,
        "sources": [
          "D:/hub2023A/itwinjs-core/test-apps/display-test-app/src/frontend/ViewClipByElementGeometryTool.ts"
        ],
        "sourcesContent": [
          "/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\r\n* See LICENSE.md in the project root for license terms and full copyright notice.\r\n*--------------------------------------------------------------------------------------------*/\r\nimport {\r\n  ClipPrimitive, ClipVector, ConvexClipPlaneSet, IndexedPolyface, Point3d, PolyfaceBuilder, PolyfaceQuery, UnionOfConvexClipPlaneSets,\r\n} from \"@itwin/core-geometry\";\r\nimport {\r\n  ElementMeshOptions, readElementMeshes,\r\n} from \"@itwin/core-common\";\r\nimport {\r\n  BeButtonEvent, CoordinateLockOverrides, EventHandled, IModelApp, LocateResponse, ViewClipTool, Viewport,\r\n} from \"@itwin/core-frontend\";\r\nimport {\r\n  ConvexMeshDecomposition, Options as DecompositionOptions,\r\n} from \"vhacd-js\";\r\n\r\n/** Settings that control the behavior of the ViewClipByElementGeometryTool. */\r\ninterface Settings extends ElementMeshOptions {\r\n  /** If true, produce convex hulls from the element geometry. Convex hulls are required for proper clipping; if this is\r\n   * set to false, make sure to only select elements that already have convex geometry.\r\n   */\r\n  computeConvexHulls: boolean;\r\n  /** Options used to produce convex hulls, if computeConvexHulls is true. */\r\n  decomposition: DecompositionOptions;\r\n  /** An offset in meters by which to expand or contract the surfaces of the clipping polyfaces.\r\n   * This is useful primarily for expanding the clipped volume slightly so that the element(s) from which the clip was produced are not clipped out.\r\n   */\r\n  offset?: number;\r\n}\r\n\r\n/** Uses vhacd-js to convert IndexedPolyfaces to convex IndexedPolyfaces. */\r\nclass ConvexDecomposer {\r\n  private readonly _impl: ConvexMeshDecomposition;\r\n  private readonly _opts: DecompositionOptions;\r\n\r\n  private constructor(impl: ConvexMeshDecomposition, options: DecompositionOptions) {\r\n    this._impl = impl;\r\n    this._opts = options;\r\n  }\r\n\r\n  public static async create(options: DecompositionOptions): Promise<ConvexDecomposer> {\r\n    const impl = await ConvexMeshDecomposition.create();\r\n    return new ConvexDecomposer(impl, options);\r\n  }\r\n\r\n  public decompose(polyfaces: IndexedPolyface[]): IndexedPolyface[] {\r\n    const decomposedPolyfaces: IndexedPolyface[] = [];\r\n    const polygon = [new Point3d(), new Point3d(), new Point3d()];\r\n\r\n    for (const polyface of polyfaces) {\r\n      if (PolyfaceQuery.isConvexByDihedralAngleCount(polyface)) {\r\n        // The polyface is already convex - don't bother performing decomposition.\r\n        decomposedPolyfaces.push(polyface);\r\n        continue;\r\n      }\r\n\r\n      const points = polyface.data.point;\r\n\r\n      // `points` is a GrowableXYZArray, which may allocate more space than it needs for the number of points it stores.\r\n      // Make sure to only pass the used portion of the allocation to vhacd-js.\r\n      const positions = new Float64Array(points.float64Data().buffer, 0, points.float64Length);\r\n\r\n      // Unfortunately we must copy the indices rather than passing them directly to vhacd-js.\r\n      const indices = new Uint32Array(polyface.data.pointIndex);\r\n      if (indices.length === 0 || positions.length === 0)\r\n        continue;\r\n\r\n      // Decompose the polyface into any number of convex hulls.\r\n      const meshes = this._impl.computeConvexHulls({ positions, indices }, this._opts);\r\n\r\n      // Convert each hull into a polyface.\r\n      for (const mesh of meshes) {\r\n        const builder = PolyfaceBuilder.create();\r\n        for (let i = 0; i < mesh.indices.length; i += 3) {\r\n          for (let j = 0; j < 3; j++)\r\n            this.getPoint(mesh.indices[i + j], mesh.positions, polygon[j]);\r\n\r\n          builder.addPolygon(polygon);\r\n        }\r\n\r\n        decomposedPolyfaces.push(builder.claimPolyface());\r\n      }\r\n    }\r\n\r\n    return decomposedPolyfaces;\r\n  }\r\n\r\n  private getPoint(index: number, positions: Float64Array, output: Point3d): void {\r\n    index *= 3;\r\n    output.set(positions[index + 0], positions[index + 1], positions[index + 2]);\r\n  }\r\n}\r\n\r\n// For demo purposes, settings are global and the only way to change them is to edit the code below.\r\nconst settings: Settings = {\r\n  offset: 0.025,\r\n  computeConvexHulls: true,\r\n  chordTolerance: 0.1,\r\n  decomposition: {\r\n    maxHulls: 10,\r\n    maxVerticesPerHull: 16,\r\n  },\r\n};\r\n\r\n/** Clips the view based on the geometry of one or more geometric elements.\r\n * We obtain polyfaces from the backend for each element and produce convex hulls from each polyface.\r\n * Then we create a ClipVector that clips out any geometry not inside one of the hulls.\r\n *\r\n * This tool exists for example purposes only. Some inefficiencies exist, including:\r\n *  - Convex mesh decomposition can take some time. Ideally it would be performed in a WebWorker so as not to block the UI thread.\r\n *  - If we had a way to determine if a polyface is already convex, we could avoid performing unnecessary decomposition on such polyfaces.\r\n */\r\nexport class ViewClipByElementGeometryTool extends ViewClipTool {\r\n  public static override toolId = \"DtaClipByElementGeometry\";\r\n  public static override iconSpec = \"icon-section-element\";\r\n\r\n  public override async onPostInstall() {\r\n    await super.onPostInstall();\r\n\r\n    // If some elements are already selected, immediately clip the view using their geometry.\r\n    if (this.targetView && this.targetView.iModel.selectionSet.isActive) {\r\n      await this.doClipToSelectedElements(this.targetView);\r\n      return;\r\n    }\r\n\r\n    // Wait for the user to select the elements to use for clipping.\r\n    this.initLocateElements(true, false, \"default\", CoordinateLockOverrides.All);\r\n  }\r\n\r\n  public override async onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled> {\r\n    if (!this.targetView)\r\n      return EventHandled.No;\r\n\r\n    // Identify the element selected.\r\n    const hit = await IModelApp.locateManager.doLocate(new LocateResponse(), true, ev.point, ev.viewport, ev.inputSource);\r\n    if (!hit || !hit.isElementHit)\r\n      return EventHandled.No;\r\n\r\n    // Clip the view using the selected element's geometry.\r\n    return await this.doClipToElements(this.targetView, new Set<string>([hit.sourceId])) ? EventHandled.Yes : EventHandled.No;\r\n  }\r\n\r\n  /** Clip the view using the geometry of all elements currently in the selection set. */\r\n  private async doClipToSelectedElements(viewport: Viewport): Promise<boolean> {\r\n    if (await this.doClipToElements(viewport, viewport.iModel.selectionSet.elements))\r\n      return true;\r\n\r\n    await this.exitTool();\r\n    return false;\r\n  }\r\n\r\n  /** Clip the view using the geometry of the specified elements. */\r\n  private async doClipToElements(viewport: Viewport, ids: Set<string>): Promise<boolean> {\r\n    try {\r\n      const union = UnionOfConvexClipPlaneSets.createEmpty();\r\n      const decomposer = settings.computeConvexHulls ? await ConvexDecomposer.create(settings.decomposition) : undefined;\r\n\r\n      for (const source of ids) {\r\n        // Obtain polyfaces for this element.\r\n        const meshData = await viewport.iModel.generateElementMeshes({ ...settings, source });\r\n        let polyfaces = readElementMeshes(meshData);\r\n\r\n        // Offset if specified - typically used to expand the element envelope slightly.\r\n        // ###TODO cloneOffset should return IndexedPolyface, not Polyface?\r\n        const offset = settings.offset;\r\n        if (offset)\r\n          polyfaces = polyfaces.map((pf) => PolyfaceQuery.cloneOffset(pf, offset));\r\n\r\n        // Convert to convex hulls unless otherwise specified.\r\n        if (decomposer)\r\n          polyfaces = decomposer.decompose(polyfaces);\r\n\r\n        // Add each polyface as a clipper.\r\n        for (const polyface of polyfaces)\r\n          union.addConvexSet(ConvexClipPlaneSet.createConvexPolyface(polyface).clipper);\r\n      }\r\n\r\n      // Apply the clip to the view.\r\n      ViewClipTool.enableClipVolume(viewport);\r\n      const primitive = ClipPrimitive.createCapture(union);\r\n      const clip = ClipVector.createCapture([primitive]);\r\n      ViewClipTool.setViewClip(viewport, clip);\r\n\r\n      this._clipEventHandler?.onNewClip(viewport);\r\n\r\n      await this.onReinitialize();\r\n      return true;\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n}\r\n"
        ],
        "mappings": "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",
        "names": []
      }
    }
  ]
}
