{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/glsl/SkySphere.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { Angle, Point3d, Vector3d } from \"@itwin/core-geometry\";\nimport { Npc } from \"@itwin/core-common\";\nimport { AttributeMap } from \"../AttributeMap\";\nimport { fromSumOf } from \"../FrustumUniforms\";\nimport { TextureUnit } from \"../RenderFlags\";\nimport { System } from \"../System\";\nimport { assignFragColor } from \"./Fragment\";\nimport { createViewportQuadBuilder } from \"./ViewportQuad\";\nimport { addAtmosphericScatteringEffect } from \"./Atmosphere\";\nconst computeGradientValue = `\r\n  // For the gradient sky it's good enough to calculate these in the vertex shader.\r\n  vec3 eyeToVert = a_worldPos - u_worldEye;\r\n  float radius = sqrt(eyeToVert.x * eyeToVert.x + eyeToVert.y * eyeToVert.y);\r\n  float zValue = eyeToVert.z - radius * u_zOffset;\r\n  float d = atan(zValue, radius);\r\n  if (u_skyParams.x < 0.0) { // 2-color gradient\r\n    d = 0.5 - d / 3.14159265359;\r\n    return vec4(d, 0.0, 0.0, 0.0);\r\n  }\r\n  d = d / 1.570796326795;\r\n  return vec4(d, 1.0 - (d - horizonSize) / (1.0 - horizonSize), 1.0 - (-d - horizonSize) / (1.0 - horizonSize), (d + horizonSize) / (horizonSize * 2.0));\r\n`;\nconst computeSkySphereColorGradient = `\r\n  if (u_skyParams.x < 0.0) // 2-color\r\n    return vec4(mix(u_zenithColor, u_nadirColor, v_gradientValue.x), 1.0);\r\n\r\n  if (v_gradientValue.x > horizonSize) // above horizon\r\n    return vec4(mix(u_zenithColor, u_skyColor, pow(v_gradientValue.y, u_skyParams.y)), 1.0);\r\n  else if (v_gradientValue.x < -horizonSize) // below horizon\r\n    return vec4(mix(u_nadirColor, u_groundColor, pow(v_gradientValue.z, u_skyParams.z)), 1.0);\r\n\r\n  return vec4(mix(u_groundColor, u_skyColor, v_gradientValue.w), 1.0);\r\n`;\nconst computeSkySphereColorAtmosphere = `\r\n  return vec4(0.0, 0.0, 0.0, 1.0);\r\n`;\nconst computeEyeToVert = \"v_eyeToVert = a_worldPos - u_worldEye;\";\nconst computeSkySphereColorTexture = `\r\n  // For the texture we must calculate these per pixel.  Alternatively we could use a finer mesh.\r\n  float radius = sqrt(v_eyeToVert.x * v_eyeToVert.x + v_eyeToVert.y * v_eyeToVert.y);\r\n  float zValue = v_eyeToVert.z - radius * u_zOffset;\r\n  float u = 0.25 - (atan(v_eyeToVert.y, v_eyeToVert.x) + u_rotation) / 6.28318530718;\r\n  float v = 0.5 - atan(zValue, radius) / 3.14159265359;\r\n  if (u < 0.0)\r\n    u += 1.0;\r\n  if (v < 0.0)\r\n    v += 1.0;\r\n  return TEXTURE(s_skyTxtr, vec2(u, v));\r\n`;\n/**\n * Eye Space for the SkySphere is unique because the ViewportQuad is already aligned with the view.\n * For this reason, the modelView matrix is not useful in calculating eyeSpace.\n * Instead, we can calculate the eyeSpace coordinates via the frustum values directly.\n */\nconst computeEyeSpace = `\r\nvec3 computeEyeSpace(vec4 rawPos) {\r\n  vec3 pos01 = rawPos.xyz * 0.5 + 0.5;\r\n\r\n  float top = u_frustumPlanes.x;\r\n  float bottom = u_frustumPlanes.y;\r\n  float left = u_frustumPlanes.z;\r\n  float right = u_frustumPlanes.w;\r\n\r\n  return vec3(\r\n    mix(left, right, pos01.x),\r\n    mix(bottom, top, pos01.y),\r\n    -u_frustum.x\r\n  );\r\n}`;\nconst scratch3Floats = new Float32Array(3);\nconst scratchVec3 = new Vector3d();\nconst scratchPoint3 = new Point3d();\n/** @internal */\nfunction modulateColor(colorIn, t, colorOut) {\n    const b = 1.0 - t;\n    colorOut[0] = colorIn[0] * b;\n    colorOut[1] = colorIn[1] * b;\n    colorOut[2] = colorIn[2] * b;\n}\n/** @internal */\nfunction addGradientUniforms(builder) {\n    builder.vert.addUniform(\"u_skyParams\", 4 /* VariableType.Vec3 */, (shader) => {\n        shader.addGraphicUniform(\"u_skyParams\", (uniform, params) => {\n            const geom = params.geometry;\n            uniform.setUniform3fv(geom.typeAndExponents);\n        });\n    });\n    builder.vert.addUniform(\"u_zOffset\", 2 /* VariableType.Float */, (shader) => {\n        shader.addGraphicUniform(\"u_zOffset\", (uniform, params) => {\n            const geom = params.geometry;\n            uniform.setUniform1f(geom.zOffset);\n        });\n    });\n    builder.frag.addUniform(\"u_skyParams\", 4 /* VariableType.Vec3 */, (shader) => {\n        shader.addGraphicUniform(\"u_skyParams\", (uniform, params) => {\n            const geom = params.geometry;\n            uniform.setUniform3fv(geom.typeAndExponents);\n        });\n    });\n    builder.frag.addUniform(\"u_zenithColor\", 4 /* VariableType.Vec3 */, (shader) => {\n        shader.addGraphicUniform(\"u_zenithColor\", (uniform, params) => {\n            const geom = params.geometry;\n            const plan = params.target.plan;\n            if (plan.backgroundMapOn && plan.isGlobeMode3D) {\n                modulateColor(geom.zenithColor, plan.globalViewTransition, scratch3Floats);\n                uniform.setUniform3fv(scratch3Floats);\n            }\n            else\n                uniform.setUniform3fv(geom.zenithColor);\n        });\n    });\n    builder.frag.addUniform(\"u_skyColor\", 4 /* VariableType.Vec3 */, (shader) => {\n        shader.addGraphicUniform(\"u_skyColor\", (uniform, params) => {\n            const geom = params.geometry;\n            const plan = params.target.plan;\n            if (plan.backgroundMapOn && plan.isGlobeMode3D) {\n                modulateColor(geom.skyColor, plan.globalViewTransition, scratch3Floats);\n                uniform.setUniform3fv(scratch3Floats);\n            }\n            else\n                uniform.setUniform3fv(geom.skyColor);\n        });\n    });\n    builder.frag.addUniform(\"u_groundColor\", 4 /* VariableType.Vec3 */, (shader) => {\n        shader.addGraphicUniform(\"u_groundColor\", (uniform, params) => {\n            const geom = params.geometry;\n            const plan = params.target.plan;\n            if (plan.backgroundMapOn) {\n                let clr = geom.skyColor;\n                if (-1 === geom.typeAndExponents[0]) // 2-color gradient\n                    clr = geom.zenithColor;\n                if (plan.isGlobeMode3D) {\n                    modulateColor(clr, plan.globalViewTransition, scratch3Floats);\n                    uniform.setUniform3fv(scratch3Floats);\n                }\n                else\n                    uniform.setUniform3fv(clr);\n            }\n            else {\n                uniform.setUniform3fv(geom.groundColor);\n            }\n        });\n    });\n    builder.frag.addUniform(\"u_nadirColor\", 4 /* VariableType.Vec3 */, (shader) => {\n        shader.addGraphicUniform(\"u_nadirColor\", (uniform, params) => {\n            const geom = params.geometry;\n            const plan = params.target.plan;\n            if (plan.backgroundMapOn) {\n                let clr = geom.skyColor;\n                if (-1 === geom.typeAndExponents[0]) // 2-color gradient\n                    clr = geom.nadirColor;\n                if (plan.isGlobeMode3D) {\n                    modulateColor(clr, plan.globalViewTransition, scratch3Floats);\n                    uniform.setUniform3fv(scratch3Floats);\n                }\n                else\n                    uniform.setUniform3fv(clr);\n            }\n            else {\n                uniform.setUniform3fv(geom.nadirColor);\n            }\n        });\n    });\n}\n/** @internal */\nfunction addTextureUniforms(builder) {\n    builder.frag.addUniform(\"s_skyTxtr\", 8 /* VariableType.Sampler2D */, (shader) => {\n        shader.addGraphicUniform(\"s_skyTxtr\", (uniform, params) => {\n            const geom = params.geometry;\n            if (undefined !== geom.skyTexture)\n                geom.skyTexture.texture.bindSampler(uniform, TextureUnit.Zero);\n            else\n                System.instance.ensureSamplerBound(uniform, TextureUnit.FeatureSymbology);\n        });\n    });\n    builder.frag.addUniform(\"u_zOffset\", 2 /* VariableType.Float */, (shader) => {\n        shader.addGraphicUniform(\"u_zOffset\", (uniform, params) => {\n            const geom = params.geometry;\n            uniform.setUniform1f(geom.zOffset);\n        });\n    });\n    builder.frag.addUniform(\"u_rotation\", 2 /* VariableType.Float */, (shader) => {\n        shader.addGraphicUniform(\"u_rotation\", (uniform, params) => {\n            const geom = params.geometry;\n            uniform.setUniform1f(geom.rotation);\n        });\n    });\n}\n/** @internal */\nexport function createSkySphereBuilder(isGradient, flags) {\n    const attrMap = AttributeMap.findAttributeMap(isGradient ? 24 /* TechniqueId.SkySphereGradient */ : 25 /* TechniqueId.SkySphereTexture */, false);\n    const builder = createViewportQuadBuilder(false, attrMap);\n    const vert = builder.vert;\n    const frag = builder.frag;\n    vert.addFunction(computeEyeSpace);\n    builder.addInlineComputedVarying(\"v_eyeSpace\", 4 /* VariableType.Vec3 */, \"v_eyeSpace = computeEyeSpace(rawPosition);\");\n    vert.addUniform(\"u_frustumPlanes\", 5 /* VariableType.Vec4 */, (prg) => {\n        prg.addGraphicUniform(\"u_frustumPlanes\", (uniform, params) => {\n            uniform.setUniform4fv(params.target.uniforms.frustum.planes); // { top, bottom, left, right }\n        });\n    });\n    vert.addUniform(\"u_frustum\", 4 /* VariableType.Vec3 */, (prg) => {\n        prg.addGraphicUniform(\"u_frustum\", (uniform, params) => {\n            uniform.setUniform3fv(params.target.uniforms.frustum.frustum); // { near, far, type }\n        });\n    });\n    frag.set(16 /* FragmentShaderComponent.AssignFragData */, assignFragColor);\n    if (flags.enableAtmosphere) {\n        frag.set(1 /* FragmentShaderComponent.ComputeBaseColor */, computeSkySphereColorAtmosphere);\n        addAtmosphericScatteringEffect(builder, true, true);\n        return builder;\n    }\n    builder.vert.addUniform(\"u_worldEye\", 4 /* VariableType.Vec3 */, (shader) => {\n        shader.addGraphicUniform(\"u_worldEye\", (uniform, params) => {\n            const frustum = params.target.planFrustum;\n            if (2 /* FrustumUniformType.Perspective */ === params.target.uniforms.frustum.type) {\n                // compute eye point from frustum.\n                const farLowerLeft = frustum.getCorner(Npc.LeftBottomRear);\n                const nearLowerLeft = frustum.getCorner(Npc.LeftBottomFront);\n                const scale = 1.0 / (1.0 - params.target.planFraction);\n                const zVec = Vector3d.createStartEnd(farLowerLeft, nearLowerLeft, scratchVec3);\n                const cameraPosition = fromSumOf(farLowerLeft, zVec, scale, scratchPoint3);\n                scratch3Floats[0] = cameraPosition.x;\n                scratch3Floats[1] = cameraPosition.y;\n                scratch3Floats[2] = cameraPosition.z;\n                uniform.setUniform3fv(scratch3Floats);\n            }\n            else {\n                const delta = Vector3d.createStartEnd(frustum.getCorner(Npc.LeftBottomRear), frustum.getCorner(Npc.LeftBottomFront), scratchVec3);\n                const pseudoCameraHalfAngle = 22.5;\n                const diagonal = frustum.getCorner(Npc.LeftBottomRear).distance(frustum.getCorner(Npc.RightTopRear));\n                const focalLength = diagonal / (2 * Math.atan(pseudoCameraHalfAngle * Angle.radiansPerDegree));\n                let zScale = focalLength / delta.magnitude();\n                if (zScale < 1.000001)\n                    zScale = 1.000001; // prevent worldEye front being on or inside the frustum front plane\n                const worldEye = Point3d.createAdd3Scaled(frustum.getCorner(Npc.LeftBottomRear), .5, frustum.getCorner(Npc.RightTopRear), .5, delta, zScale, scratchPoint3);\n                scratch3Floats[0] = worldEye.x;\n                scratch3Floats[1] = worldEye.y;\n                scratch3Floats[2] = worldEye.z;\n                uniform.setUniform3fv(scratch3Floats);\n            }\n        });\n    });\n    if (isGradient) {\n        addGradientUniforms(builder);\n        builder.addGlobal(\"horizonSize\", 2 /* VariableType.Float */, 3 /* ShaderType.Both */, \"0.0015\", true);\n        builder.addFunctionComputedVarying(\"v_gradientValue\", 5 /* VariableType.Vec4 */, \"computeGradientValue\", computeGradientValue);\n        frag.set(1 /* FragmentShaderComponent.ComputeBaseColor */, computeSkySphereColorGradient);\n    }\n    else {\n        addTextureUniforms(builder);\n        builder.addInlineComputedVarying(\"v_eyeToVert\", 4 /* VariableType.Vec3 */, computeEyeToVert);\n        frag.set(1 /* FragmentShaderComponent.ComputeBaseColor */, computeSkySphereColorTexture);\n    }\n    return builder;\n}\n//# sourceMappingURL=SkySphere.js.map",
      "start": 1693508125931,
      "end": 1693508126042,
      "sourcemaps": null
    }
  ]
}
