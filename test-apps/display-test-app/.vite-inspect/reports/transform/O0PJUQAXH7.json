{
  "resolvedId": "D:/hub2023A/itwinjs-core/editor/frontend/lib/esm/ElementGeometryTool.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Editing\n */\nimport { Id64 } from \"@itwin/core-bentley\";\nimport { FeatureAppearance, FeatureAppearanceProvider, RgbColor } from \"@itwin/core-common\";\nimport { AccuDrawHintBuilder, BeModifierKeys, CoordSource, CoreTools, ElementSetTool, EventHandled, GraphicBranch, GraphicType, IModelApp, InputSource, readElementGraphics, ToolAssistance, ToolAssistanceImage, ToolAssistanceInputMethod, } from \"@itwin/core-frontend\";\nimport { Point3d, Range3d, Transform } from \"@itwin/core-geometry\";\nimport { BRepEntityType, editorBuiltInCmdIds, SubEntityType, } from \"@itwin/editor-common\";\nimport { computeChordToleranceFromPoint } from \"./CreateElementTool\";\nimport { EditTools } from \"./EditTool\";\nimport { solidModelingIpc } from \"./EditToolIpc\";\n/** @alpha */\nexport class ElementGeometryGraphicsProvider {\n    constructor(iModel) {\n        this.iModel = iModel;\n    }\n    /** Call to request a RenderGraphic for the supplied graphic data.\n     * @see [[cleanupGraphic]] Must be called when the tool exits.\n     */\n    async createGraphic(graphicData) {\n        try {\n            const graphic = await readElementGraphics(graphicData, this.iModel, Id64.invalid, true, { noFlash: true, noHilite: true });\n            const graphicOwner = graphic ? IModelApp.renderSystem.createGraphicOwner(graphic) : undefined;\n            this.cleanupGraphic();\n            return (undefined !== (this.graphic = graphicOwner));\n        }\n        catch {\n            return false;\n        }\n    }\n    /** Call to dispose of [[RenderGraphic]] held by [[RenderGraphicOwner]].\n     * @note Must be called when the tool exits to avoid leaks of graphics memory or other webgl resources.\n     */\n    cleanupGraphic() {\n        if (undefined === this.graphic)\n            return;\n        this.graphic.disposeGraphic();\n        this.graphic = undefined;\n    }\n    addGraphic(context, transform, opts) {\n        if (undefined === this.graphic)\n            return;\n        if (undefined === transform && undefined === opts) {\n            context.addGraphic(this.graphic);\n            return;\n        }\n        const branch = new GraphicBranch(false);\n        branch.add(this.graphic);\n        const branchGraphic = context.createGraphicBranch(branch, transform ? transform : Transform.createIdentity(), opts);\n        context.addGraphic(branchGraphic);\n    }\n    addDecoration(context, type, transform, opts) {\n        if (undefined === this.graphic)\n            return;\n        const branch = new GraphicBranch(false);\n        branch.add(this.graphic);\n        const branchGraphic = context.createGraphicBranch(branch, transform ? transform : Transform.createIdentity(), opts);\n        context.addDecoration(type, branchGraphic);\n    }\n}\n/** @alpha */\nexport function isSameSubEntity(a, b) {\n    if (a.type !== b.type)\n        return false;\n    if (a.id !== b.id)\n        return false;\n    if ((undefined !== a.index ? a.index : 0) !== (undefined !== b.index ? b.index : 0))\n        return false;\n    return true;\n}\n/** @alpha */\nexport class SubEntityData {\n    constructor(props) { this._props = props; }\n    get props() { return this._props; }\n    set props(value) {\n        this.cleanupGraphic();\n        this._props = value;\n    }\n    get geometry() { return this._geometry; }\n    set geometry(value) { this._geometry = value; }\n    isSame(other) { return isSameSubEntity(this._props, other); }\n    getAppearance(vp, accepted) {\n        const color = vp.hilite.color;\n        const rgb = RgbColor.fromColorDef(accepted ? color.inverse() : color);\n        const transparency = 0.25;\n        const emphasized = true; // Necessary for obscured sub-entities w/SceneGraphic...\n        let weight;\n        switch (this.props.type) {\n            case SubEntityType.Face:\n                break;\n            case SubEntityType.Edge:\n                const edgeWeight = accepted ? 1 : 3;\n                weight = this._geometry?.appearance?.weight ? Math.min(this._geometry.appearance.weight + edgeWeight, 31) : edgeWeight;\n                break;\n            case SubEntityType.Vertex:\n                const vertexWeight = accepted ? 8 : 10;\n                weight = this._geometry?.appearance?.weight ? Math.min(this._geometry.appearance.weight + vertexWeight, 31) : vertexWeight;\n                break;\n        }\n        return FeatureAppearance.fromJSON({ rgb, transparency, weight, emphasized, nonLocatable: true });\n    }\n    async createGraphic(iModel) {\n        if (undefined === this._geometry?.graphic)\n            return false;\n        if (undefined === this._graphicsProvider)\n            this._graphicsProvider = new ElementGeometryGraphicsProvider(iModel);\n        return this._graphicsProvider.createGraphic(this._geometry.graphic);\n    }\n    cleanupGraphic() {\n        if (undefined === this._graphicsProvider)\n            return;\n        this._graphicsProvider.cleanupGraphic();\n        this._graphicsProvider = undefined;\n    }\n    get hasGraphic() {\n        return (undefined !== this._graphicsProvider?.graphic);\n    }\n    display(context, accepted) {\n        if (undefined === this._graphicsProvider?.graphic)\n            return;\n        const range = (this._geometry?.range ? Range3d.fromJSON(this._geometry.range) : undefined);\n        const pixelSize = context.viewport.getPixelSizeAtPoint(range ? range.center : undefined);\n        const offsetDir = context.viewport.view.getZVector();\n        offsetDir.scaleToLength(3 * pixelSize, offsetDir);\n        const offsetTrans = Transform.createTranslation(offsetDir);\n        const appearanceProvider = FeatureAppearanceProvider.supplement((app) => {\n            return app.extendAppearance(this.getAppearance(context.viewport, accepted));\n        });\n        this._graphicsProvider.addDecoration(context, GraphicType.Scene, offsetTrans, { appearanceProvider });\n    }\n}\n/** @alpha Base class for tools that want to use the backend geometry cache. */\nexport class ElementGeometryCacheTool extends ElementSetTool {\n    constructor() {\n        super(...arguments);\n        this._checkedIds = new Map();\n        this._firstResult = true;\n    }\n    allowView(vp) { return vp.view.is3d(); }\n    isCompatibleViewport(vp, isSelectedViewChange) { return (super.isCompatibleViewport(vp, isSelectedViewChange) && undefined !== vp && this.allowView(vp)); }\n    async startCommand() {\n        if (undefined !== this._startedCmd)\n            return this._startedCmd;\n        return EditTools.startCommand({ commandId: editorBuiltInCmdIds.cmdSolidModeling, iModelKey: this.iModel.key });\n    }\n    agendaAppearance(isDynamics) {\n        if (isDynamics) {\n            if (undefined === this._agendaAppearanceDynamic)\n                this._agendaAppearanceDynamic = FeatureAppearance.fromTransparency(0.0);\n            return this._agendaAppearanceDynamic;\n        }\n        if (undefined === this._agendaAppearanceDefault)\n            this._agendaAppearanceDefault = FeatureAppearance.fromTransparency(0.9);\n        return this._agendaAppearanceDefault;\n    }\n    get wantAgendaAppearanceOverride() { return false; }\n    addFeatureOverrides(overrides, _vp) {\n        if (this.agenda.isEmpty)\n            return;\n        const appearance = this.agendaAppearance(false);\n        this.agenda.elements.forEach((elementId) => overrides.override({ elementId, appearance }));\n    }\n    updateAgendaAppearanceProvider(drop) {\n        if (!this.wantAgendaAppearanceOverride)\n            return;\n        for (const vp of IModelApp.viewManager) {\n            if (!this.allowView(vp))\n                continue;\n            if (drop || this.agenda.isEmpty)\n                vp.dropFeatureOverrideProvider(this);\n            else if (!vp.addFeatureOverrideProvider(this))\n                vp.setFeatureOverrideProviderChanged();\n        }\n    }\n    get geometryCacheFilter() { return undefined; }\n    onGeometryCacheFilterChanged() { this._checkedIds.clear(); }\n    async createElementGeometryCache(id) {\n        // NOTE: Creates cache if it doesn't already exist then test new or existing cache against filter...\n        try {\n            this._startedCmd = await this.startCommand();\n            return await solidModelingIpc.createElementGeometryCache(id, this.geometryCacheFilter);\n        }\n        catch (err) {\n            return false;\n        }\n    }\n    async acceptElementForOperation(id) {\n        if (Id64.isInvalid(id) || Id64.isTransient(id))\n            return false;\n        let accept = this._checkedIds.get(id);\n        if (undefined === accept) {\n            if (this.agenda.isEmpty && this._checkedIds.size > 1000)\n                this._checkedIds.clear(); // Limit auto-locate cache size to something reasonable...\n            accept = await this.createElementGeometryCache(id);\n            this._checkedIds.set(id, accept);\n        }\n        return accept;\n    }\n    async isElementValidForOperation(hit, out) {\n        if (!await super.isElementValidForOperation(hit, out))\n            return false;\n        return this.acceptElementForOperation(hit.sourceId);\n    }\n    async postFilterIds(arg) {\n        const ids = [];\n        for (const id of Id64.iterable(arg)) {\n            if (await this.acceptElementForOperation(id))\n                ids.push(id);\n        }\n        return ids;\n    }\n    async getGroupIds(id) {\n        return this.postFilterIds(await super.getGroupIds(id));\n    }\n    async getSelectionSetCandidates(ss) {\n        return this.postFilterIds(await super.getSelectionSetCandidates(ss));\n    }\n    async getDragSelectCandidates(vp, origin, corner, method, overlap) {\n        return this.postFilterIds(await super.getDragSelectCandidates(vp, origin, corner, method, overlap));\n    }\n    onDynamicFrame(_ev, context) {\n        if (undefined === this._graphicsProvider)\n            return;\n        if (!this.wantAgendaAppearanceOverride)\n            return this._graphicsProvider.addGraphic(context);\n        const appearanceProvider = FeatureAppearanceProvider.supplement((app) => {\n            return app.extendAppearance(this.agendaAppearance(true));\n        });\n        this._graphicsProvider.addGraphic(context, undefined, { appearanceProvider });\n    }\n    async onMouseMotion(ev) {\n        return this.updateGraphic(ev, IModelApp.viewManager.inDynamicsMode);\n    }\n    async getGraphicData(_ev) { return undefined; }\n    async updateGraphic(ev, isDynamics) {\n        if (!isDynamics || this._graphicsPending)\n            return; // Continue displaying previous graphic if new graphic is still pending...\n        this._graphicsPending = true;\n        const graphicData = await this.getGraphicData(ev);\n        this._graphicsPending = undefined;\n        if (undefined !== graphicData) {\n            if (this._firstResult) {\n                this.updateAgendaAppearanceProvider();\n                this._firstResult = false;\n            }\n            return this.createGraphic(graphicData);\n        }\n        if (undefined !== this._graphicsProvider)\n            this._graphicsProvider.cleanupGraphic();\n    }\n    async createGraphic(graphicData) {\n        if (undefined === this._graphicsProvider)\n            this._graphicsProvider = new ElementGeometryGraphicsProvider(this.iModel);\n        await this._graphicsProvider.createGraphic(graphicData);\n    }\n    clearGraphic() {\n        if (undefined === this._graphicsProvider)\n            return;\n        this._graphicsProvider.cleanupGraphic();\n        this._graphicsProvider = undefined;\n    }\n    async clearElementGeometryCache() {\n        try {\n            this._startedCmd = await this.startCommand();\n            await solidModelingIpc.clearElementGeometryCache();\n        }\n        catch (err) { }\n    }\n    async onUnsuspend() {\n        if (!this._firstResult)\n            this.updateAgendaAppearanceProvider();\n        return super.onUnsuspend();\n    }\n    async onSuspend() {\n        if (!this._firstResult)\n            this.updateAgendaAppearanceProvider(true);\n        return super.onSuspend();\n    }\n    async onPostInstall() {\n        await super.onPostInstall();\n        if (this.wantAgendaAppearanceOverride)\n            this.agenda.manageHiliteState = false;\n    }\n    async onCleanup() {\n        await super.onCleanup();\n        await this.clearElementGeometryCache();\n        this.updateAgendaAppearanceProvider(true);\n        this.clearGraphic();\n    }\n}\n/** @alpha Base class for tools that need to locate faces, edges, and vertices. */\nexport class LocateSubEntityTool extends ElementGeometryCacheTool {\n    constructor() {\n        super(...arguments);\n        this._acceptedSubEntities = [];\n        this._summaryIds = new Map();\n    }\n    provideToolAssistance(mainInstrText, additionalInstr) {\n        if (this.wantAdditionalSubEntities) {\n            const faceKey = this.wantSubEntityType(SubEntityType.Face) ? \"Face\" : \"\";\n            const edgeKey = this.wantSubEntityType(SubEntityType.Edge) ? \"Edge\" : \"\";\n            const vertexKey = this.wantSubEntityType(SubEntityType.Vertex) ? \"Vertex\" : \"\";\n            const subEntityKey = `${faceKey}${edgeKey}${vertexKey}`;\n            if (0 === subEntityKey.length) {\n                super.provideToolAssistance(mainInstrText, additionalInstr);\n                return;\n            }\n            if (undefined === mainInstrText)\n                mainInstrText = EditTools.translate(`LocateSubEntities.Identify.${subEntityKey}`);\n            const leftMsg = EditTools.translate(`LocateSubEntities.Accept.${subEntityKey}`);\n            const rightMsg = this.haveAcceptedSubEntities && this.allowSubEntitySelectNext ? EditTools.translate(`LocateSubEntities.AcceptNext.${subEntityKey}`) : CoreTools.translate(\"ElementSet.Inputs.Cancel\");\n            const mouseInstructions = [];\n            const touchInstructions = [];\n            if (!ToolAssistance.createTouchCursorInstructions(touchInstructions))\n                touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.OneTouchTap, leftMsg, false, ToolAssistanceInputMethod.Touch));\n            mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.LeftClick, leftMsg, false, ToolAssistanceInputMethod.Mouse));\n            touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.TwoTouchTap, rightMsg, false, ToolAssistanceInputMethod.Touch));\n            mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.RightClick, rightMsg, false, ToolAssistanceInputMethod.Mouse));\n            if (this.allowSubEntityControlSelect)\n                mouseInstructions.push(ToolAssistance.createModifierKeyInstruction(ToolAssistance.ctrlKey, ToolAssistanceImage.LeftClickDrag, EditTools.translate(`LocateSubEntities.IdentifyAdditional.${subEntityKey}`), false, ToolAssistanceInputMethod.Mouse));\n            if (undefined !== additionalInstr) {\n                for (const instr of additionalInstr) {\n                    if (ToolAssistanceInputMethod.Touch === instr.inputMethod)\n                        touchInstructions.push(instr);\n                    else\n                        mouseInstructions.push(instr);\n                }\n            }\n            const sections = [];\n            sections.push(ToolAssistance.createSection(mouseInstructions, ToolAssistance.inputsLabel));\n            sections.push(ToolAssistance.createSection(touchInstructions, ToolAssistance.inputsLabel));\n            const mainInstruction = ToolAssistance.createInstruction(this.iconSpec, mainInstrText);\n            const instructions = ToolAssistance.createInstructions(mainInstruction, sections);\n            IModelApp.notifications.setToolAssistance(instructions);\n            return;\n        }\n        super.provideToolAssistance(mainInstrText, additionalInstr);\n    }\n    get wantAgendaAppearanceOverride() { return true; }\n    get wantGeometrySummary() { return false; }\n    get wantSubEntitySnap() { return false; }\n    wantSubEntityType(type) { return SubEntityType.Face === type; }\n    getMaximumSubEntityHits(type) { return this.wantSubEntityType(type) ? 25 : 0; }\n    get requiredSubEntityCount() { return 1; }\n    get haveAcceptedSubEntities() { return (0 !== this._acceptedSubEntities.length); }\n    get inhibitSubEntityDisplay() { return this.isDynamicsStarted; }\n    get allowSubEntityControlSelect() { return true; }\n    get allowSubEntityControlDeselect() { return this.allowSubEntityControlSelect; }\n    get allowSubEntitySelectNext() { return !this.isDynamicsStarted; }\n    getBRepEntityTypeForSubEntity(id, subEntity) {\n        const summary = this._summaryIds.get(id);\n        if (undefined === summary)\n            return BRepEntityType.Invalid;\n        const index = (undefined !== subEntity.index ? subEntity.index : 0);\n        if (index >= summary.length)\n            return BRepEntityType.Invalid;\n        return summary[index];\n    }\n    async createElementGeometrySummary(id) {\n        let summary = this._summaryIds.get(id);\n        if (undefined === summary) {\n            if (this.agenda.isEmpty && this._summaryIds.size > 1000)\n                this._summaryIds.clear(); // Limit auto-locate cache size to something reasonable...\n            try {\n                this._startedCmd = await this.startCommand();\n                if (undefined === (summary = await solidModelingIpc.summarizeElementGeometryCache(id)))\n                    return false;\n            }\n            catch (err) {\n                return false;\n            }\n            this._summaryIds.set(id, summary);\n        }\n        return true;\n    }\n    async createElementGeometryCache(id) {\n        const accept = await super.createElementGeometryCache(id);\n        return (accept && this.wantGeometrySummary ? this.createElementGeometrySummary(id) : accept);\n    }\n    getAcceptedSubEntityData(index = -1) {\n        if (-1 === index)\n            index = this._acceptedSubEntities.length - 1;\n        if (index < 0 || index > this._acceptedSubEntities.length - 1)\n            return undefined;\n        return this._acceptedSubEntities[index];\n    }\n    getAcceptedSubEntities() {\n        const accepted = [];\n        this._acceptedSubEntities.forEach((entry) => accepted.push(entry.props));\n        return accepted;\n    }\n    drawSubEntity(context, subEntity, accepted) {\n        subEntity.display(context, accepted);\n    }\n    drawAcceptedSubEntities(context) {\n        this._acceptedSubEntities.forEach((entry) => this.drawSubEntity(context, entry, true));\n    }\n    decorate(context) {\n        if (this.inhibitSubEntityDisplay || !this.allowView(context.viewport))\n            return;\n        if (this.haveAcceptedSubEntities)\n            this.drawAcceptedSubEntities(context);\n        if (undefined !== this._currentSubEntity)\n            this.drawSubEntity(context, this._currentSubEntity, false);\n    }\n    decorateSuspended(context) {\n        if (this.inhibitSubEntityDisplay || !this.allowView(context.viewport))\n            return;\n        if (this.haveAcceptedSubEntities)\n            this.drawAcceptedSubEntities(context);\n    }\n    getLocateAperture(ev) {\n        if (undefined === ev.viewport)\n            return 0.0;\n        return ev.viewport.pixelsFromInches(InputSource.Touch === ev.inputSource ? IModelApp.locateManager.touchApertureInches : IModelApp.locateManager.apertureInches);\n    }\n    getMaxRayDistance(ev, aperture) {\n        if (undefined === ev.viewport)\n            return 0.0;\n        // NOTE: Compute a world coordinate radius for ray test, try getting aperture size at point on element...\n        const hit = IModelApp.accuSnap.currHit;\n        const vec = [];\n        vec[0] = ev.viewport.worldToView(hit ? hit.hitPoint : ev.point);\n        vec[1] = vec[0].clone();\n        vec[1].x += 1;\n        ev.viewport.viewToWorldArray(vec);\n        // The edge and vertex hits get post-filtered on xy distance, so this is fine for perspective views...\n        return (aperture * vec[0].distance(vec[1]));\n    }\n    getRayOrigin(ev) {\n        const spacePoint = ev.point.clone();\n        const vp = ev.viewport;\n        if (undefined === vp)\n            return spacePoint;\n        vp.worldToNpc(spacePoint, spacePoint);\n        spacePoint.z = 1.0;\n        vp.npcToWorld(spacePoint, spacePoint);\n        return spacePoint;\n    }\n    wantHiddenEdges(vp) {\n        return vp.viewFlags.hiddenEdgesVisible();\n    }\n    getSubEntityFilter() { return undefined; }\n    async pickSubEntities(id, boresite, maxFace, maxEdge, maxVertex, maxDistance, hiddenEdgesVisible, filter) {\n        try {\n            this._startedCmd = await this.startCommand();\n            const opts = {\n                maxFace,\n                maxEdge,\n                maxVertex,\n                maxDistance,\n                hiddenEdgesVisible,\n                filter,\n            };\n            return await solidModelingIpc.locateSubEntities(id, boresite.origin, boresite.direction, opts);\n        }\n        catch (err) {\n            return undefined;\n        }\n    }\n    async doPickSubEntities(id, ev) {\n        const vp = ev.viewport;\n        if (undefined === vp)\n            return undefined;\n        const maxFace = this.getMaximumSubEntityHits(SubEntityType.Face);\n        const maxEdge = this.getMaximumSubEntityHits(SubEntityType.Edge);\n        const maxVertex = this.getMaximumSubEntityHits(SubEntityType.Vertex);\n        if (0 === maxFace && 0 === maxEdge && 0 === maxVertex)\n            return undefined;\n        const aperture = this.getLocateAperture(ev);\n        const maxDistance = this.getMaxRayDistance(ev, aperture);\n        const spacePoint = this.getRayOrigin(ev);\n        const boresite = AccuDrawHintBuilder.getBoresite(spacePoint, vp);\n        const hiddenEdgesVisible = this.wantHiddenEdges(vp);\n        const filter = this.getSubEntityFilter();\n        let hits = await this.pickSubEntities(id, boresite, maxFace, maxEdge, maxVertex, maxDistance, hiddenEdgesVisible, filter);\n        // NOTE: Remove erroneous edge/vertex hits in perspective views by checking real xy distance to hit point...\n        if (undefined === hits || !vp.isCameraOn)\n            return hits;\n        if (maxEdge > 0 && hits.length > 1) {\n            const edgeApertureSquared = (aperture * aperture);\n            const vertexApertureSquared = ((aperture * 2.0) * (aperture * 2.0));\n            const e2 = Math.pow(aperture, 2);\n            const v2 = Math.pow(aperture * 2.0, 2);\n            if (e2 !== edgeApertureSquared || v2 !== vertexApertureSquared)\n                return hits;\n            const rayOrigin = vp.worldToView(boresite.origin);\n            hits = hits.filter((hit) => {\n                if (SubEntityType.Face === hit.subEntity.type)\n                    return true;\n                const hitPoint = vp.worldToView(Point3d.fromJSON(hit.point));\n                const distance = hitPoint.distanceSquaredXY(rayOrigin);\n                return (distance <= (SubEntityType.Edge === hit.subEntity.type ? edgeApertureSquared : vertexApertureSquared));\n            });\n        }\n        return hits;\n    }\n    async createSubEntityData(id, hit) {\n        const data = new SubEntityData(hit.subEntity);\n        const chordTolerance = (this.targetView ? computeChordToleranceFromPoint(this.targetView, Point3d.fromJSON(hit.point)) : undefined);\n        await this.createSubEntityGraphic(id, data, chordTolerance);\n        return data;\n    }\n    /** Append specified sub-entity to accepted array. */\n    async addSubEntity(id, props) {\n        this._acceptedSubEntities.push(await this.createSubEntityData(id, props));\n    }\n    /** Remove specified sub-entity from accepted array, or pop last sub-entity if undefined. */\n    async removeSubEntity(_id, props) {\n        if (undefined !== props)\n            this._acceptedSubEntities = this._acceptedSubEntities.filter((entry) => !isSameSubEntity(entry.props, props.subEntity));\n        else\n            this._acceptedSubEntities.pop();\n    }\n    /** Locate sub-entities for the most recently added (last) agenda entry. Tool sub-classes that wish to identity\n     * sub-entities from multiple elements are responsible for maintaining the sub-entities per-element.\n     */\n    async doLocateSubEntity(ev, newSearch) {\n        if (this.agenda.isEmpty || undefined === ev.viewport)\n            return false;\n        const id = this.agenda.elements[this.agenda.length - 1];\n        if (newSearch) {\n            this._locatedSubEntities = await this.doPickSubEntities(id, ev);\n            if (undefined === this._locatedSubEntities || 0 === this._locatedSubEntities.length)\n                return false;\n            /** NOTE: Set last button location to point on sub-entity when not snapping.\n              * If dynamics are enabled on this event, onDynamicFrame is called with this location.\n              */\n            if (CoordSource.ElemSnap !== ev.coordsFrom) {\n                ev.point.setFrom(Point3d.fromJSON(this._locatedSubEntities[0].point));\n                IModelApp.toolAdmin.setAdjustedDataPoint(ev);\n            }\n        }\n        else {\n            await this.removeSubEntity(id);\n        }\n        const hit = this._locatedSubEntities?.shift();\n        if (undefined !== hit) {\n            if (undefined === this._acceptedSubEntities.find((entry) => isSameSubEntity(entry.props, hit.subEntity)))\n                await this.addSubEntity(id, hit);\n            else if (this.allowSubEntityControlDeselect)\n                await this.removeSubEntity(id, hit);\n        }\n        IModelApp.viewManager.invalidateDecorationsAllViews();\n        return true;\n    }\n    async chooseNextHit(ev) {\n        if (!this.haveAcceptedSubEntities)\n            return super.chooseNextHit(ev);\n        if (!this.allowSubEntitySelectNext) {\n            await this.onReinitialize(); // Don't cycle through hits after starting dynamics...\n        }\n        else {\n            await this.doLocateSubEntity(ev, false);\n            if (!this.haveAcceptedSubEntities)\n                await this.onReinitialize();\n        }\n        return EventHandled.No;\n    }\n    get wantAdditionalSubEntities() {\n        return (this._acceptedSubEntities.length < this.requiredSubEntityCount || (this.allowSubEntityControlSelect && this.isControlDown));\n    }\n    async gatherInput(ev) {\n        if (this.wantAdditionalSubEntities) {\n            await this.doLocateSubEntity(ev, true);\n            if (this.wantAdditionalSubEntities) {\n                this.setupAndPromptForNextAction();\n                return EventHandled.No;\n            }\n            this.clearCurrentSubEntity();\n        }\n        return super.gatherInput(ev);\n    }\n    getCurrentElement() {\n        if (!this.agenda.isEmpty)\n            return this.agenda.elements[this.agenda.length - 1];\n        const hit = IModelApp.accuSnap.currHit;\n        return (undefined !== hit && hit.isElementHit ? hit.sourceId : undefined);\n    }\n    clearCurrentSubEntity() {\n        if (undefined === this._currentSubEntity)\n            return;\n        this._currentSubEntity.cleanupGraphic();\n        this._currentSubEntity = undefined;\n    }\n    async setCurrentSubEntity(id, hit, chordTolerance) {\n        if (undefined === this._currentSubEntity)\n            this._currentSubEntity = new SubEntityData(hit.subEntity);\n        else\n            this._currentSubEntity.props = hit.subEntity;\n        return this.createSubEntityGraphic(id, this._currentSubEntity, chordTolerance);\n    }\n    async changeCurrentSubEntity(id, current, chordTolerance) {\n        if (undefined === id || undefined === current) {\n            if (undefined === this._currentSubEntity || !this._currentSubEntity.hasGraphic)\n                return false;\n            this._currentSubEntity.cleanupGraphic();\n            return true;\n        }\n        if (undefined !== this._currentSubEntity && this._currentSubEntity.hasGraphic && this._currentSubEntity.isSame(current.subEntity))\n            return false;\n        return this.setCurrentSubEntity(id, current, chordTolerance);\n    }\n    async updateCurrentSubEntity(ev) {\n        if (undefined === ev.viewport)\n            return false;\n        const id = this.wantAdditionalSubEntities ? this.getCurrentElement() : undefined;\n        if (undefined === id)\n            return this.changeCurrentSubEntity();\n        if (this._subEntityGraphicPending)\n            return false;\n        this._subEntityGraphicPending = true;\n        const current = await this.doPickSubEntities(id, ev);\n        const chordTolerance = current ? computeChordToleranceFromPoint(ev.viewport, Point3d.fromJSON(current[0].point)) : 0.0;\n        const status = await this.changeCurrentSubEntity(id, current ? current[0] : undefined, chordTolerance);\n        this._subEntityGraphicPending = undefined;\n        if (status)\n            IModelApp.viewManager.invalidateDecorationsAllViews();\n        return status;\n    }\n    async createSubEntityGraphic(id, data, chordTolerance) {\n        try {\n            const opts = {\n                wantGraphic: true,\n                wantRange: true,\n                wantAppearance: true,\n                chordTolerance,\n            };\n            data.chordTolerance = chordTolerance;\n            data.geometry = await solidModelingIpc.getSubEntityGeometry(id, data.props, opts);\n            return await data.createGraphic(this.iModel);\n        }\n        catch (err) {\n            return false;\n        }\n    }\n    async updateGraphic(ev, isDynamics) {\n        if (isDynamics)\n            return super.updateGraphic(ev, isDynamics);\n        await this.updateCurrentSubEntity(ev);\n    }\n    async getGraphicData(ev) {\n        const result = await this.applyAgendaOperation(ev, false);\n        return result?.graphic;\n    }\n    async applyAgendaOperation(_ev, _isAccept) { return undefined; }\n    async processAgenda(ev) {\n        const result = await this.applyAgendaOperation(ev, true);\n        if (result?.elementId)\n            await this.saveChanges();\n    }\n    async onModifierKeyTransition(wentDown, modifier, event) {\n        if (EventHandled.Yes === await super.onModifierKeyTransition(wentDown, modifier, event))\n            return EventHandled.Yes;\n        if (BeModifierKeys.Control !== modifier)\n            return EventHandled.No;\n        if (IModelApp.toolAdmin.isLocateCircleOn === this.wantAdditionalSubEntities)\n            return EventHandled.No;\n        this.setupAndPromptForNextAction();\n        return EventHandled.Yes;\n    }\n    changeLocateState(enableLocate, enableSnap, cursor, coordLockOvr) {\n        super.changeLocateState(enableLocate, enableSnap, cursor, coordLockOvr);\n        // Keep showing locate circle when identifying sub-entities even if done locating elements...\n        if (!IModelApp.toolAdmin.isLocateCircleOn && this.wantAdditionalSubEntities)\n            IModelApp.toolAdmin.setLocateCircleOn(true);\n    }\n    get shouldEnableSnap() {\n        if (this.isSelectByPoints || !this.wantAccuSnap)\n            return false;\n        if (this.isDynamicsStarted)\n            return true;\n        const isCtrlSelect = (this.isControlDown && (this.controlKeyContinuesSelection || this.allowSubEntityControlSelect));\n        if (isCtrlSelect || this.wantAdditionalElements || this.wantAdditionalSubEntities)\n            return this.wantSubEntitySnap;\n        return !this.wantSubEntitySnap;\n    }\n    setupAccuDraw() { }\n    setupAndPromptForNextAction() {\n        this.setupAccuDraw();\n        super.setupAndPromptForNextAction();\n    }\n    clearSubEntityGraphics() {\n        if (undefined !== this._currentSubEntity)\n            this._currentSubEntity.cleanupGraphic();\n        this._acceptedSubEntities.forEach((entry) => entry.cleanupGraphic());\n    }\n    async onCleanup() {\n        this.clearSubEntityGraphics();\n        return super.onCleanup();\n    }\n}\n//# sourceMappingURL=ElementGeometryTool.js.map",
      "start": 1693508122894,
      "end": 1693508122999,
      "sourcemaps": null
    }
  ]
}
