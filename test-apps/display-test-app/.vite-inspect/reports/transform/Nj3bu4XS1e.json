{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/orbitgt/lib/esm/spatial/ecrs/projection/ObliqueMercator.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module OrbitGT\n */\nimport { OperationMethod } from \"../OperationMethod\";\n/**\n * Class ObliqueMercator defines an Oblique Mercator projection (Hotine Variant B).\n *\n * The 'source' CRS is the geographic CRS.\n * The 'target' CRS is the projected CRS.\n *\n * Based on the following document:\n *\n * Coordinate Conversions and Transformations including Formulas\n * Guidance Note Number 7, part 2\n * Revised August 2006\n * Available at: http://www.epsg.org/\n *\n * Formulas: see 1.4.6 (spec v6.13): Oblique Mercator and Hotine Oblique Mercator\n *\n * @version 1.0 May 2008\n */\n/** @internal */\nclass ObliqueMercator extends OperationMethod {\n    /**\n       * Create a new projection.\n       * @param parameters the values of the parameters.\n       */\n    constructor(parameters) {\n        super(ObliqueMercator.METHOD_CODE, \"Oblique Mercator\", parameters);\n        /* Store the parameters */\n        this._latC = parameters.getValue(8811);\n        this._lonC = parameters.getValue(8812);\n        this._aziC = parameters.getValue(8813);\n        this._gamC = parameters.getValue(8814);\n        this._kC = parameters.getValue(8815);\n        this._eC = parameters.getValue(8816);\n        this._nC = parameters.getValue(8817);\n    }\n    /**\n       * Get the sign of a number.\n       */\n    static sign(v) {\n        return (v < 0.0) ? (-1.0) : (1.0);\n    }\n    /**\n       * Get the power of a number (must be able to handle negative 'n' values).\n       */\n    static pow(n, e) {\n        let p = 1.0;\n        for (let i = 0; i < e; i++)\n            p *= n;\n        return p;\n    }\n    /**\n       * OperationMethod method.\n       * @see OperationMethod#initialize\n       */\n    initialize(operation) {\n        /* Get the ellipsoid */\n        const sourceCRS = operation.getSourceCRS();\n        /* Prepare the forward parameters */\n        this._a = sourceCRS.getEllipsoid().getA();\n        this._e = sourceCRS.getEllipsoid().getE();\n        this._e2 = this._e * this._e;\n        this._B = Math.sqrt(1.0 + (this._e2 * ObliqueMercator.pow(Math.cos(this._latC), 4) / (1.0 - this._e2)));\n        const esinLatC = this._e * Math.sin(this._latC);\n        this._A = this._a * this._B * this._kC * Math.sqrt(1.0 - this._e2) / (1.0 - ObliqueMercator.pow(esinLatC, 2));\n        this._tO = Math.tan(ObliqueMercator.PI / 4.0 - this._latC / 2.0) / Math.pow((1.0 - esinLatC) / (1.0 + esinLatC), this._e / 2.0);\n        this._D = this._B * Math.sqrt(1.0 - this._e2) / (Math.cos(this._latC) * Math.sqrt(1.0 - ObliqueMercator.pow(esinLatC, 2)));\n        const D2 = (this._D < 1.0) ? (1.0) : (this._D * this._D);\n        this._F = this._D + Math.sqrt(D2 - 1.0) * ObliqueMercator.sign(this._latC);\n        this._H = this._F * Math.pow(this._tO, this._B);\n        this._G = (this._F - 1.0 / this._F) / 2.0;\n        this._gamO = Math.asin(Math.sin(this._aziC) / this._D);\n        // fix for Switzerland CRS 2056 projection error. LER, 19/06/2018\n        let w = this._G * Math.tan(this._gamO);\n        if (Math.abs(1.0 - w) < 1.0e-13)\n            w = 1.0; // Math.asin(0.9999999999999999) gives a 1.49e-8 difference from the asin(1.0) value, which leads to a 19 cm projection error\n        //        this._lonO = lonC-Math.asin(G*Math.tan(gamO))/B;\n        this._lonO = this._lonC - Math.asin(w) / this._B;\n        // end of fix\n        this._vC = 0.0;\n        if (Math.abs(this._aziC - 0.5 * ObliqueMercator.PI) < 1.0e-12)\n            this._uC = this._A * (this._lonC - this._lonO); // special case aziC==90 (Hungary, Switzerland)\n        else\n            this._uC = (this._A / this._B) * Math.atan(Math.sqrt(D2 - 1.0) / Math.cos(this._aziC)) * ObliqueMercator.sign(this._latC);\n        /* Prepare the reverse parameters */\n        const e4 = this._e2 * this._e2;\n        const e6 = e4 * this._e2;\n        const e8 = e4 * e4;\n        this._rev1 = (this._e2 / 2.0 + 5.0 * e4 / 24.0 + e6 / 12.0 + 13.0 * e8 / 360.0);\n        this._rev2 = (7.0 * e4 / 48.0 + 29.0 * e6 / 240.0 + 811.0 * e8 / 11520.0);\n        this._rev3 = (7.0 * e6 / 120.0 + 81.0 * e8 / 1120.0);\n        this._rev4 = (4279.0 * e8 / 161280.0);\n    }\n    /**\n       * OperationMethod interface method.\n       * @see OperationMethod#forward\n       */\n    forward(sourceCRS, source, targetCRS, target) {\n        /* Get the parameters (radians) */\n        const lon = source.getX();\n        const lat = source.getY();\n        /* Make the calculation */\n        const esinLat = this._e * Math.sin(lat);\n        const t = Math.tan(ObliqueMercator.PI / 4.0 - lat / 2.0) / Math.pow((1.0 - esinLat) / (1.0 + esinLat), this._e / 2.0);\n        const Q = this._H / Math.pow(t, this._B);\n        const S = (Q - 1.0 / Q) / 2.0;\n        const T = (Q + 1.0 / Q) / 2.0;\n        const V = Math.sin(this._B * (lon - this._lonO));\n        const U = (-V * Math.cos(this._gamO) + S * Math.sin(this._gamO)) / T;\n        const v = this._A * Math.log((1.0 - U) / (1.0 + U)) / (2.0 * this._B);\n        let u;\n        if (Math.abs(this._aziC - 0.5 * ObliqueMercator.PI) < 1.0e-12) // aziC==90? new in guidance note 2 version 8.5. LER, 21/09/2016\n         {\n            if (lon == this._lonC)\n                u = 0.0;\n            else\n                u = (this._A * Math.atan((S * Math.cos(this._gamO) + V * Math.sin(this._gamO)) / Math.cos(this._B * (lon - this._lonO))) / this._B) - (Math.abs(this._uC) * ObliqueMercator.sign(this._latC) * ObliqueMercator.sign(this._lonC - lon));\n        }\n        else {\n            u = (this._A * Math.atan((S * Math.cos(this._gamO) + V * Math.sin(this._gamO)) / Math.cos(this._B * (lon - this._lonO))) / this._B) - (Math.abs(this._uC) * ObliqueMercator.sign(this._latC));\n        }\n        const sinGamC = Math.sin(this._gamC);\n        const cosGamC = Math.cos(this._gamC);\n        const E = v * cosGamC + u * sinGamC + this._eC;\n        const N = u * cosGamC - v * sinGamC + this._nC;\n        /* Save the position */\n        target.setX(E);\n        target.setY(N);\n        target.setZ(source.getZ()); // Keep the Z value\n    }\n    /**\n       * OperationMethod interface method.\n       * @see OperationMethod#reverse\n       */\n    reverse(sourceCRS, source, targetCRS, target) {\n        /* Get the parameters */\n        const E = target.getX();\n        const N = target.getY();\n        /* Make the calculation */\n        const sinGamC = Math.sin(this._gamC);\n        const cosGamC = Math.cos(this._gamC);\n        const v = (E - this._eC) * cosGamC - (N - this._nC) * sinGamC;\n        const u = (N - this._nC) * cosGamC + (E - this._eC) * sinGamC + (Math.abs(this._uC) * ObliqueMercator.sign(this._latC));\n        const Q = Math.exp(-this._B * v / this._A);\n        const S = (Q - 1.0 / Q) / 2.0;\n        const T = (Q + 1.0 / Q) / 2.0;\n        const V = Math.sin(this._B * u / this._A);\n        const U = (V * Math.cos(this._gamO) + S * Math.sin(this._gamO)) / T;\n        const t = Math.pow(this._H / Math.sqrt((1.0 + U) / (1.0 - U)), 1.0 / this._B);\n        const chi = ObliqueMercator.PI / 2.0 - 2.0 * Math.atan(t);\n        const lat = chi + Math.sin(2.0 * chi) * this._rev1 + Math.sin(4.0 * chi) * this._rev2 + Math.sin(6.0 * chi) * this._rev3 + Math.sin(8.0 * chi) * this._rev4;\n        //        double lon = lonO-Math.atan((S*Math.cos(gamO)-V*Math.sin(gamO))/Math.cos(B*u/A))/B;\n        const lon = this._lonO - Math.atan2((S * Math.cos(this._gamO) - V * Math.sin(this._gamO)), Math.cos(this._B * u / this._A)) / this._B; // replaced atan(y/x) by atan2(y,x). LER, 23/05/2017\n        /* Save the position */\n        source.setX(lon);\n        source.setY(lat);\n        source.setZ(target.getZ()); // Keep the Z value\n    }\n}\n/** The code of this method */\nObliqueMercator.METHOD_CODE = 9815; // Hotine Variant B\n/** The value of PI */\nObliqueMercator.PI = Math.PI;\nexport { ObliqueMercator };\n//# sourceMappingURL=ObliqueMercator.js.map",
      "start": 1693508127376,
      "end": 1693508127429,
      "sourcemaps": null
    }
  ]
}
