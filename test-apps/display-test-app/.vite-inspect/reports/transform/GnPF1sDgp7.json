{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/glsl/SolarShadowMapping.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { assert } from \"@itwin/core-bentley\";\nimport { RenderType } from \"@itwin/webgl-compatibility\";\nimport { TextureUnit } from \"../RenderFlags\";\nimport { System } from \"../System\";\nimport { addInstancedRtcMatrix } from \"./Vertex\";\nconst computeShadowPos = `\r\n  vec4 shadowProj = u_shadowProj * rawPosition;\r\n  v_shadowPos = shadowProj.xyz/shadowProj.w;\r\n  v_shadowPos.z = 1.0 - v_shadowPos.z;\r\n`;\nconst computeInstancedShadowPos = `\r\n  vec4 shadowProj = u_shadowProj * g_instancedRtcMatrix * rawPosition;\r\n  v_shadowPos = shadowProj.xyz/shadowProj.w;\r\n  v_shadowPos.z = 1.0 - v_shadowPos.z;\r\n`;\n// for 32-bit float, max exponent should be 44.36, for 16-bit should be 5.545\nconst evsm32Exp = 42.0;\nconst evsm16Exp = 5.545;\nexport const warpDepth = `\r\n// Applies exponential warp to shadow map depth, input depth should be in [0, 1]\r\nvec2 warpDepth(float depth, float exponent) {\r\n  depth = 2.0 * depth - 1.0; // Rescale depth into [-1, 1]\r\n  float pos =  exp( exponent * depth);\r\n  float neg = -exp(-exponent * depth);\r\n  return vec2(pos, neg);\r\n}\r\n`;\nconst chebyshevUpperBound = `\r\nfloat chebyshevUpperBound(vec2 moments, float mean, float minVariance) {\r\n  float variance = moments.y - (moments.x * moments.x);\r\n  variance = max(variance, minVariance);\r\n\r\n  // Compute probabilistic upper bound\r\n  float d = mean - moments.x;\r\n  float pMax = variance / (variance + (d * d));\r\n\r\n  return (mean <= moments.x ? 1.0 : pMax);  // One-tailed Chebyshev\r\n}\r\n`;\nconst shadowMapEVSM = `\r\nfloat shadowMapEVSM(vec3 shadowPos) {\r\n  vec2 warpedDepth = warpDepth(shadowPos.z, u_evsmExponent);\r\n  vec4 occluder = TEXTURE(s_shadowSampler, shadowPos.xy/* * 0.5*/); // shadow texture is 1/2 size (both dirs)\r\n\r\n  // Derivative of warping at depth\r\n  vec2 depthScale = kVSMBias * 0.01 * u_evsmExponent * warpedDepth;\r\n  vec2 minVariance = depthScale * depthScale;\r\n\r\n  float posContrib = chebyshevUpperBound(occluder.xz, warpedDepth.x, minVariance.x);\r\n  float negContrib = chebyshevUpperBound(occluder.yw, warpedDepth.y, minVariance.y);\r\n  return min(posContrib, negContrib);\r\n}\r\n`;\nconst applySolarShadowMap = `\r\n  if (v_shadowPos.x < 0.0 || v_shadowPos.x > 1.0 || v_shadowPos.y < 0.0 || v_shadowPos.y > 1.0 || v_shadowPos.z < 0.0 || v_shadowPos.z > 1.0)\r\n    return baseColor;\r\n  float visible = (u_surfaceFlags[kSurfaceBitIndex_HasNormals] && (dot(g_normal, u_sunDir) < 0.0)) ? 0.0 : shadowMapEVSM(v_shadowPos);\r\n  return vec4(baseColor.rgb * mix(u_shadowParams.rgb, vec3(1.0), visible), baseColor.a);\r\n`;\nconst applySolarShadowMapTerrain = `\r\n  if (v_shadowPos.x < 0.0 || v_shadowPos.x > 1.0 || v_shadowPos.y < 0.0 || v_shadowPos.y > 1.0 || v_shadowPos.z < 0.0 || v_shadowPos.z > 1.0)\r\n    return baseColor;\r\n\r\n  float visible = shadowMapEVSM(v_shadowPos);\r\n  return vec4(baseColor.rgb * mix(u_shadowParams.rgb, vec3(1.0), visible), baseColor.a);\r\n`;\n/** @internal */\nexport function addEvsmExponent(frag) {\n    frag.addUniform(\"u_evsmExponent\", 2 /* VariableType.Float */, (prog) => {\n        prog.addGraphicUniform(\"u_evsmExponent\", (uniform) => {\n            uniform.setUniform1f((RenderType.TextureFloat === System.instance.maxRenderType) ? evsm32Exp : evsm16Exp);\n        });\n    });\n}\n/** @internal */\nexport function addSolarShadowMap(builder, toTerrain = false) {\n    const frag = builder.frag;\n    const vert = builder.vert;\n    frag.addUniform(\"s_shadowSampler\", 8 /* VariableType.Sampler2D */, (prog) => {\n        prog.addGraphicUniform(\"s_shadowSampler\", (uniform, params) => {\n            const shadowMap = params.target.solarShadowMap;\n            assert(undefined !== shadowMap.shadowMapTexture);\n            shadowMap.shadowMapTexture.texture.bindSampler(uniform, TextureUnit.ShadowMap);\n        });\n    });\n    frag.addUniform(\"u_shadowParams\", 5 /* VariableType.Vec4 */, (prog) => {\n        prog.addGraphicUniform(\"u_shadowParams\", (uniform, params) => {\n            params.target.uniforms.shadow.bindColorAndBias(uniform);\n        });\n    });\n    if (!toTerrain) {\n        frag.addUniform(\"u_sunDir\", 4 /* VariableType.Vec3 */, (prog) => {\n            prog.addGraphicUniform(\"u_sunDir\", (uniform, params) => {\n                params.target.uniforms.bindSunDirection(uniform);\n            });\n        });\n    }\n    vert.addUniform(\"u_shadowProj\", 7 /* VariableType.Mat4 */, (prog) => {\n        prog.addGraphicUniform(\"u_shadowProj\", (uniform, params) => {\n            params.target.uniforms.shadow.bindProjectionMatrix(uniform);\n        });\n    });\n    addEvsmExponent(frag);\n    if (vert.usesInstancedGeometry)\n        addInstancedRtcMatrix(vert);\n    builder.addInlineComputedVarying(\"v_shadowPos\", 4 /* VariableType.Vec3 */, vert.usesInstancedGeometry ? computeInstancedShadowPos : computeShadowPos);\n    /* This is the EVSM bias value, which makes tradeoffs in shadow quality.  Normally it should be set to 0.1.\n       Lower values can introduce shadows where they should not be, including shadow acne. Higher values can cause Peter\n       Panning effect and light bleeding. Tested 0.01 and 1.0, woth more focus on 0.1 to 0.5 inclusive, chose 0.2 for a\n       while (on 9/13/19) then after having shadow tiles match view tile resolution for ones in view, retested and went\n       back to 0.1 (on 11/5/19). */\n    frag.addGlobal(\"kVSMBias\", 2 /* VariableType.Float */, \"0.1\", true);\n    frag.addFunction(warpDepth);\n    frag.addFunction(chebyshevUpperBound);\n    frag.addFunction(shadowMapEVSM);\n    frag.set(13 /* FragmentShaderComponent.ApplySolarShadowMap */, toTerrain ? applySolarShadowMapTerrain : applySolarShadowMap);\n}\n//# sourceMappingURL=SolarShadowMapping.js.map",
      "start": 1693508126479,
      "end": 1693508126580,
      "sourcemaps": null
    }
  ]
}
