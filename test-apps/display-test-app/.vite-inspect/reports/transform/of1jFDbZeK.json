{
  "resolvedId": "D:/hub2023A/itwinjs-core/test-apps/display-test-app/src/frontend/Surface.ts",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\r\n* See LICENSE.md in the project root for license terms and full copyright notice.\r\n*--------------------------------------------------------------------------------------------*/\r\nimport { KeyinField, parseArgs } from \"@itwin/frontend-devtools\";\r\nimport { Range3d } from \"@itwin/core-geometry\";\r\nimport { Cartographic } from \"@itwin/core-common\";\r\nimport { BlankConnection, BlankConnectionProps, IModelApp, Tool } from \"@itwin/core-frontend\";\r\nimport { DisplayTestApp } from \"./App\";\r\nimport { BrowserFileSelector, selectFileName } from \"./FileOpen\";\r\nimport { FpsMonitor } from \"./FpsMonitor\";\r\nimport { NotificationsWindow } from \"./Notifications\";\r\nimport { addSnapModes } from \"./SnapModes\";\r\nimport { TileLoadIndicator } from \"./TileLoadIndicator\";\r\nimport { createToolButton, ToolBar } from \"./ToolBar\";\r\nimport { Viewer, ViewerProps } from \"./Viewer\";\r\nimport { Dock, NamedWindow, NamedWindowProps, Window, WindowProps } from \"./Window\";\r\nimport { openIModel, OpenIModelProps } from \"./openIModel\";\r\nimport { setTitle } from \"./Title\";\r\nimport { openAnalysisStyleExample } from \"./AnalysisStyleExample\";\r\nimport { openDecorationGeometryExample } from \"./DecorationGeometryExample\";\r\n\r\n// cspell:ignore textbox topdiv\r\n\r\nexport class Surface {\r\n  public readonly element: HTMLElement;\r\n  public readonly keyinField: KeyinField;\r\n  private readonly _keyinDiv: HTMLElement;\r\n  private readonly _toolbarDiv: HTMLElement;\r\n  private readonly _windows: Window[] = [];\r\n  public readonly notifications: NotificationsWindow;\r\n  private readonly _toolbar: ToolBar;\r\n  public readonly browserFileSelector?: BrowserFileSelector;\r\n  public readonly openReadWrite: boolean;\r\n\r\n  public static get instance() { return DisplayTestApp.surface; }\r\n\r\n  public constructor(surfaceDiv: HTMLElement, toolbarDiv: HTMLElement, browserFileSelector: BrowserFileSelector | undefined, openReadWrite: boolean) {\r\n    // Ensure iModel gets closed on page close/reload\r\n    window.onbeforeunload = () => this.closeAllViewers();\r\n\r\n    this.element = surfaceDiv;\r\n    this.openReadWrite = openReadWrite;\r\n    this.browserFileSelector = browserFileSelector;\r\n    this._toolbarDiv = toolbarDiv;\r\n    this._toolbar = this.createToolBar();\r\n    this._toolbarDiv.appendChild(this._toolbar.element);\r\n\r\n    addSnapModes(document.getElementById(\"snapModesContainer\")!);\r\n    new TileLoadIndicator(document.getElementById(\"tileLoadIndicatorContainer\") as HTMLDivElement);\r\n    new FpsMonitor({\r\n      checkbox: document.getElementById(\"fps-checkbox\") as HTMLInputElement,\r\n      label: document.getElementById(\"fps-label\") as HTMLLabelElement,\r\n      output: document.getElementById(\"fps-output\") as HTMLSpanElement,\r\n    });\r\n\r\n    this._keyinDiv = document.getElementById(\"keyin-entry\")!;\r\n    this.keyinField = new KeyinField({\r\n      parent: this._keyinDiv,\r\n      baseId: \"dtaKeyinField\",\r\n      historyLength: 50,\r\n    });\r\n    this.keyinField.textBox.textbox.addEventListener(\"keydown\", (e) => {\r\n      if (\"Escape\" === e.key || \"`\" === e.key) {\r\n        this.keyinField.loseFocus();\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n      }\r\n    });\r\n    this.keyinField.textBox.div.className = \"keyin-entry\";\r\n    this.keyinField.textBox.textbox.className = \"keyin-entry-textbox\";\r\n\r\n    this.notifications = new NotificationsWindow(this, { title: \"Notifications\", width: 800, height: 800, maxStoredMessages: 50 });\r\n    this.addWindow(this.notifications);\r\n\r\n    document.addEventListener(\"keydown\", (e) => {\r\n      const handler = this.getKeyboardShortcutHandler(e);\r\n      if (undefined !== handler) {\r\n        handler();\r\n        e.preventDefault();\r\n      }\r\n    });\r\n\r\n    window.onresize = () => {\r\n      for (const window of this._windows) {\r\n        if (window.isDocked)\r\n          window.updateDock();\r\n        else\r\n          window.ensureInSurface();\r\n      }\r\n    };\r\n\r\n    IModelApp.viewManager.onSelectedViewportChanged.addListener((args) => {\r\n      if (null !== this._toolbarDiv.firstChild)\r\n        this._toolbarDiv.removeChild(this._toolbarDiv.firstChild);\r\n\r\n      if (undefined !== args.previous) {\r\n        const previous = this.findViewerByViewportId(args.previous.viewportId);\r\n        if (undefined !== previous)\r\n          previous.onDeselected();\r\n      }\r\n\r\n      if (undefined !== args.current) {\r\n        const current = this.findViewerByViewportId(args.current.viewportId);\r\n        if (undefined !== current) {\r\n          current.onSelected();\r\n          this._toolbarDiv.appendChild(current.toolBar.element);\r\n          this.focus(current);\r\n          return;\r\n        }\r\n      }\r\n\r\n      this._toolbarDiv.appendChild(this._toolbar.element);\r\n      this.focus(this.notifications);\r\n    });\r\n  }\r\n\r\n  private createToolBar(): ToolBar {\r\n    const div = IModelApp.makeHTMLElement(\"div\", { className: \"topdiv\" });\r\n    const tb = new ToolBar(div);\r\n\r\n    tb.addItem(createToolButton({\r\n      iconUnicode: \"\\ue9cc\", // \"briefcases\"\r\n      tooltip: \"Open iModel from disk\",\r\n      click: async () => {\r\n        await this.openFileIModel();\r\n      },\r\n    }));\r\n\r\n    tb.addItem(createToolButton({\r\n      iconUnicode: \"\\ue9d8\", // \"property-data\"\r\n      tooltip: \"Open Blank Connection\",\r\n      click: async () => {\r\n        await this.openBlankConnection();\r\n      },\r\n    }));\r\n\r\n    tb.addItem(createToolButton({\r\n      iconUnicode: \"\\uea32\", // play\r\n      tooltip: \"Analysis Style Example\",\r\n      click: async () => {\r\n        const viewer = await this.openBlankConnection({\r\n          name: \"Analysis Style Example\",\r\n          extents: new Range3d(0, 0, -30, 100, 100, 20),\r\n        });\r\n\r\n        await openAnalysisStyleExample(viewer);\r\n      },\r\n    }));\r\n\r\n    tb.addItem(createToolButton({\r\n      iconUnicode: \"\\ue9d8\",\r\n      tooltip: \"Decoration Geometry Example\",\r\n      click: async () => {\r\n        const viewer = await this.openBlankConnection({\r\n          name: \"Decoration Geometry Example\",\r\n          extents: new Range3d(-1, -1, -1, 13, 2, 2),\r\n        });\r\n        void openDecorationGeometryExample(viewer);\r\n      },\r\n    }));\r\n\r\n    return tb;\r\n  }\r\n\r\n  // create a new blank connection for testing backgroundMap and reality models.\r\n  private async openBlankConnection(props?: Partial<BlankConnectionProps>): Promise<Viewer> {\r\n    const iModel = BlankConnection.create({\r\n      location: props?.location ?? Cartographic.fromDegrees({longitude: -75.686694, latitude: 40.065757, height: 0}), // near Exton pa\r\n      extents: props?.extents ?? new Range3d(-1000, -1000, -100, 1000, 1000, 100),\r\n      name: props?.name ?? \"blank connection test\",\r\n    });\r\n\r\n    const viewer = await this.createViewer({ iModel });\r\n    viewer.dock(Dock.Full);\r\n    return viewer;\r\n  }\r\n\r\n  private async openFileIModel(fileName?: string): Promise<void> {\r\n    if (undefined === fileName) {\r\n      fileName = await this.selectFileName();\r\n      if (undefined === fileName) {\r\n        return;\r\n      }\r\n    }\r\n    await this.openIModel({ fileName, writable: this.openReadWrite });\r\n  }\r\n\r\n  private async openIModel(props: OpenIModelProps): Promise<void> {\r\n    try {\r\n      const iModel = await openIModel(props);\r\n      setTitle(iModel);\r\n      const viewer = await this.createViewer({ iModel });\r\n      viewer.dock(Dock.Full);\r\n    } catch (err: any) {\r\n      alert(`Error opening iModel: ${err.toString()}`);\r\n    }\r\n  }\r\n\r\n  public get firstViewer(): Viewer | undefined {\r\n    for (const window of this._windows)\r\n      if (window instanceof Viewer)\r\n        return window;\r\n\r\n    return undefined;\r\n  }\r\n\r\n  public async openFile(filename?: string): Promise<void> {\r\n    const viewer = this.firstViewer;\r\n    return undefined !== viewer ? viewer.openFile(filename) : this.openFileIModel(filename);\r\n  }\r\n\r\n  private getKeyboardShortcutHandler(e: KeyboardEvent): (() => void) | undefined {\r\n    if (e.repeat)\r\n      return undefined;\r\n\r\n    const key = e.key;\r\n    if (\"`\" === key)\r\n      return () => this.keyinField.focus();\r\n\r\n    if (!e.ctrlKey)\r\n      return undefined;\r\n\r\n    switch (key) {\r\n      case \"[\":\r\n      case \"]\":\r\n        return () => this.focusNextOrPrevious(\"]\" === key);\r\n    }\r\n\r\n    const focused = this.focusedWindow;\r\n    if (undefined === focused)\r\n      return undefined;\r\n\r\n    let dock: Dock | undefined;\r\n    switch (key) {\r\n      case \"\\\\\":\r\n        return () => {\r\n          if (focused instanceof Viewer)\r\n            this.addViewer(focused.clone());\r\n        };\r\n      case \"|\":\r\n        return () => this.close(focused);\r\n      case \"n\":\r\n        // NB: This doesn't work in Chrome (it doesn't give us the keydown event for ctrl-n)\r\n        return () => {\r\n          if (focused !== this.notifications)\r\n            this.notifications.focus();\r\n          else\r\n            this.focusNext();\r\n        };\r\n      case \"p\":\r\n        return () => this.togglePin(focused);\r\n      case \"i\":\r\n        return () => focused.dock(Dock.Full);\r\n      case \"m\":\r\n        return () => focused.undock();\r\n      case \"h\":\r\n        dock = Dock.Left;\r\n        break;\r\n      case \"l\":\r\n        dock = Dock.Right;\r\n        break;\r\n      case \"k\":\r\n        dock = Dock.Top;\r\n        break;\r\n      case \"j\":\r\n        dock = Dock.Bottom;\r\n        break;\r\n    }\r\n\r\n    if (undefined !== dock)\r\n      return () => focused.addDock(dock!);\r\n\r\n    return undefined;\r\n  }\r\n\r\n  public createNamedWindow(props: NamedWindowProps): NamedWindow {\r\n    const window = new NamedWindow(this, props);\r\n    this.element.appendChild(window.container);\r\n    this.addWindow(window);\r\n    return window;\r\n  }\r\n\r\n  public async createViewer(props: ViewerProps): Promise<Viewer> {\r\n    const viewer = await Viewer.create(this, props);\r\n    this.addViewer(viewer);\r\n    return viewer;\r\n  }\r\n\r\n  public addViewer(viewer: Viewer): void {\r\n    this.addWindow(viewer);\r\n    IModelApp.viewManager.addViewport(viewer.viewport);\r\n  }\r\n\r\n  public addWindow(window: Window): void {\r\n    this._windows.push(window);\r\n    window.ensureInSurface();\r\n    this.updateWindowsUi();\r\n    this.focus(window);\r\n  }\r\n\r\n  private updateWindowsUi(): void {\r\n    this._windows.forEach((window: Window) => window.updateUi());\r\n  }\r\n\r\n  public focus(window: Window): void {\r\n    const index = this._windows.indexOf(window);\r\n    if (index < 1) {\r\n      if (0 === index)\r\n        window.onFocus(); // for when we initially create the first window...\r\n\r\n      // not found, or already focused.\r\n      return;\r\n    }\r\n\r\n    this._windows.splice(index, 1);\r\n    this._windows.unshift(window);\r\n    this.updateFocus();\r\n\r\n    // ###TODO: This should only apply if you CLICKED on the window to focus it.\r\n    this.keyinField.loseFocus();\r\n  }\r\n\r\n  public focusNext() { this.focusNextOrPrevious(true); }\r\n  public focusPrevious() { this.focusNextOrPrevious(false); }\r\n  private focusNextOrPrevious(next: boolean): void {\r\n    // Focusing a window moves it to the front of the _windows array. So that array is ordered by most-recently- to least-recently-focused.\r\n    if (next) {\r\n      const front = this._windows[0];\r\n      this._windows.splice(0, 1);\r\n      this._windows.push(front);\r\n    } else {\r\n      const back = this._windows.pop()!;\r\n      this._windows.unshift(back);\r\n    }\r\n\r\n    this.updateFocus();\r\n  }\r\n\r\n  public togglePin(window: Window): void {\r\n    window.isPinned = !window.isPinned;\r\n    this.updateFocus();\r\n  }\r\n\r\n  private updateFocus(): void {\r\n    let zIndex = 10 + this._windows.length;\r\n    let first = true;\r\n    for (const w of this._windows) {\r\n      if (first) {\r\n        w.onFocus();\r\n        first = false;\r\n      } else {\r\n        w.onLoseFocus();\r\n      }\r\n\r\n      const z = zIndex + (w.isPinned ? 100 : 0);\r\n      w.container.style.zIndex = z.toString();\r\n      zIndex -= 1;\r\n    }\r\n  }\r\n\r\n  public findViewerByViewportId(id: number): Viewer | undefined {\r\n    for (const window of this._windows)\r\n      if (window instanceof Viewer && window.viewport.viewportId === id)\r\n        return window;\r\n\r\n    return undefined;\r\n  }\r\n\r\n  public get hasMultipleViewers(): boolean {\r\n    let num = 0;\r\n    for (const window of this._windows) {\r\n      if (window instanceof Viewer) {\r\n        ++num;\r\n        if (num > 1)\r\n          return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  public findWindowById(id: string): Window | undefined {\r\n    return this._windows.find((x) => x.windowId === id);\r\n  }\r\n\r\n  public get focusedWindow(): Window | undefined {\r\n    return this._windows[0];\r\n  }\r\n\r\n  public close(window: Window): void {\r\n    if (window.isCloseable)\r\n      this.forceClose(window);\r\n  }\r\n\r\n  public closeAllViewers(): void {\r\n    const viewers = this._windows.filter((x) => x instanceof Viewer);\r\n    for (const viewer of viewers)\r\n      this.forceClose(viewer);\r\n  }\r\n\r\n  public forceClose(window: Window): void {\r\n    // NB: Must do this before computing index, because closing a Viewer changes the selected viewport which changes focus which changes order of windows in array.\r\n    window.onClosing();\r\n    const index = this._windows.indexOf(window);\r\n    if (-1 !== index) {\r\n      this._windows.splice(index, 1);\r\n      this.element.removeChild(window.container);\r\n      window.onClosed();\r\n    }\r\n    this.updateWindowsUi();\r\n  }\r\n\r\n  public onResetIModel(viewer: Viewer): void {\r\n    for (const window of this._windows)\r\n      if (window instanceof Viewer && window !== viewer)\r\n        this.forceClose(window);\r\n  }\r\n\r\n  public async selectFileName(): Promise<string | undefined> {\r\n    return selectFileName(this.browserFileSelector);\r\n  }\r\n\r\n  public async selectHubIModel(): Promise<OpenIModelProps | undefined> {\r\n    // TODO: Show dialog to allow user to input iModelId and iTwinId.\r\n    alert(\"Not Implemented.\");\r\n    return undefined;\r\n  }\r\n}\r\n\r\nexport class CreateWindowTool extends Tool {\r\n  public static override toolId = \"CreateWindow\";\r\n  public static override get minArgs() { return 1; }\r\n  public static override get maxArgs() { return undefined; }\r\n\r\n  public override async run(props: NamedWindowProps): Promise<boolean> {\r\n    DisplayTestApp.surface.createNamedWindow(props);\r\n    return true;\r\n  }\r\n\r\n  public override async parseAndRun(...inputArgs: string[]): Promise<boolean> {\r\n    let name: string | undefined;\r\n    const props: WindowProps = {};\r\n\r\n    const args = parseArgs(inputArgs);\r\n    const id = args.get(\"id\");\r\n    if (undefined !== id)\r\n      name = id;\r\n\r\n    const title = args.get(\"title\");\r\n    if (undefined !== title)\r\n      props.title = title;\r\n\r\n    const sides: Array<\"top\" | \"left\" | \"width\" | \"height\"> = [\"top\", \"left\", \"width\", \"height\"];\r\n    for (const key of sides) {\r\n      const value = args.getInteger(key);\r\n      if (undefined !== value)\r\n        props[key] = value;\r\n    }\r\n\r\n    if (undefined !== name) {\r\n      const namedProps: NamedWindowProps = { id: name, ...props };\r\n      await this.run(namedProps);\r\n    }\r\n\r\n    return true;\r\n  }\r\n}\r\n\r\nexport abstract class WindowIdTool extends Tool {\r\n  public static override get minArgs() { return 0; }\r\n  public static override get maxArgs() { return 1; }\r\n\r\n  public abstract execute(_window: Window): void;\r\n\r\n  public override async run(windowId?: string): Promise<boolean> {\r\n    const window = undefined !== windowId ? Surface.instance.findWindowById(windowId) : Surface.instance.focusedWindow;\r\n    if (undefined !== window)\r\n      this.execute(window);\r\n\r\n    return true;\r\n  }\r\n\r\n  public override async parseAndRun(...args: string[]): Promise<boolean> {\r\n    return this.run(args[0]);\r\n  }\r\n}\r\n\r\nexport class FocusWindowTool extends WindowIdTool {\r\n  public static override toolId = \"FocusWindow\";\r\n  public execute(window: Window): void {\r\n    window.focus();\r\n  }\r\n}\r\n\r\nexport class MaximizeWindowTool extends WindowIdTool {\r\n  public static override toolId = \"MaximizeWindow\";\r\n  public execute(window: Window): void {\r\n    if (!window.isDocked)\r\n      window.dock(Dock.Full);\r\n  }\r\n}\r\n\r\nexport class RestoreWindowTool extends WindowIdTool {\r\n  public static override toolId = \"RestoreWindow\";\r\n  public execute(window: Window): void {\r\n    window.undock();\r\n  }\r\n}\r\n\r\nexport class CloseWindowTool extends WindowIdTool {\r\n  public static override toolId = \"CloseWindow\";\r\n  public execute(window: Window): void {\r\n    Surface.instance.close(window);\r\n  }\r\n}\r\nexport class ResizeWindowTool extends Tool {\r\n  public static override toolId = \"ResizeWindow\";\r\n  public static override get minArgs() { return 2; }\r\n  public static override get maxArgs() { return 3; }\r\n\r\n  public override async run(width: number, height: number, id?: string): Promise<boolean> {\r\n    const window = undefined !== id ? Surface.instance.findWindowById(id) : Surface.instance.focusedWindow;\r\n    if (undefined !== window)\r\n      window.resizeContent(width, height);\r\n\r\n    return true;\r\n  }\r\n\r\n  // width height [id]\r\n  public override async parseAndRun(...args: string[]): Promise<boolean> {\r\n    const w = parseInt(args[0], 10);\r\n    const h = parseInt(args[1], 10);\r\n    if (!Number.isNaN(w) || !Number.isNaN(h))\r\n      await this.run(w, h, args[2]);\r\n\r\n    return true;\r\n  }\r\n}\r\n\r\nexport class DockWindowTool extends Tool {\r\n  public static override toolId = \"DockWindow\";\r\n  public static override get minArgs() { return 1; }\r\n  public static override get maxArgs() { return 2; }\r\n\r\n  public override async run(dock: Dock, windowId?: string): Promise<boolean> {\r\n    const window = undefined !== windowId ? Surface.instance.findWindowById(windowId) : Surface.instance.focusedWindow;\r\n    if (undefined !== window)\r\n      window.dock(dock);\r\n\r\n    return true;\r\n  }\r\n\r\n  public override async parseAndRun(...args: string[]): Promise<boolean> {\r\n    let dock = 0;\r\n    for (const c of args[0].toLowerCase()) {\r\n      switch (c) {\r\n        case \"l\":\r\n          dock |= Dock.Left;\r\n          break;\r\n        case \"r\":\r\n          dock |= Dock.Right;\r\n          break;\r\n        case \"t\":\r\n          dock |= Dock.Top;\r\n          break;\r\n        case \"b\":\r\n          dock |= Dock.Bottom;\r\n          break;\r\n        default:\r\n          return true;\r\n      }\r\n    }\r\n\r\n    if (0 !== dock)\r\n      await this.run(dock, args[1]);\r\n\r\n    return true;\r\n  }\r\n}\r\n\r\nexport class CloneViewportTool extends Tool {\r\n  public static override toolId = \"CloneViewport\";\r\n  public static override get minArgs() { return 0; }\r\n  public static override get maxArgs() { return 1; }\r\n\r\n  public override async run(viewportId?: number): Promise<boolean> {\r\n    if (undefined === viewportId) {\r\n      const selectedView = IModelApp.viewManager.selectedView;\r\n      if (undefined === selectedView)\r\n        return true;\r\n\r\n      viewportId = selectedView.viewportId;\r\n    }\r\n\r\n    const surface = DisplayTestApp.surface;\r\n    const viewer = surface.findViewerByViewportId(viewportId);\r\n    if (undefined !== viewer)\r\n      surface.addViewer(viewer.clone());\r\n\r\n    return true;\r\n  }\r\n\r\n  public override async parseAndRun(...args: string[]): Promise<boolean> {\r\n    const viewportId = parseInt(args[0], 10);\r\n    return undefined !== viewportId && !Number.isNaN(viewportId) && this.run(viewportId);\r\n  }\r\n}\r\n\r\nexport class OpenIModelTool extends Tool {\r\n  public static override toolId = \"OpenIModel\";\r\n  public static override get minArgs() { return 0; }\r\n  public static override get maxArgs() { return 1; }\r\n\r\n  public override async run(filename?: string): Promise<boolean> {\r\n    await Surface.instance.openFile(filename);\r\n    return true;\r\n  }\r\n\r\n  public override async parseAndRun(...args: string[]): Promise<boolean> {\r\n    return this.run(args[0]);\r\n  }\r\n}\r\n\r\nexport class CloseIModelTool extends Tool {\r\n  public static override toolId = \"CloseIModel\";\r\n\r\n  public override async run(): Promise<boolean> {\r\n    Surface.instance.closeAllViewers();\r\n    return true;\r\n  }\r\n}\r\n\r\nexport class ReopenIModelTool extends Tool {\r\n  public static override toolId = \"ReopenIModel\";\r\n\r\n  public override async run(): Promise<boolean> {\r\n    const viewer = Surface.instance.firstViewer;\r\n    if (undefined !== viewer)\r\n      await viewer.openFile(viewer.viewport.iModel.key);\r\n\r\n    return true;\r\n  }\r\n}\r\n",
      "start": 1693508118379,
      "end": 1693508118556,
      "sourcemaps": null
    },
    {
      "name": "vite:esbuild",
      "result": "\"use strict\";\nimport { KeyinField, parseArgs } from \"@itwin/frontend-devtools\";\nimport { Range3d } from \"@itwin/core-geometry\";\nimport { Cartographic } from \"@itwin/core-common\";\nimport { BlankConnection, IModelApp, Tool } from \"@itwin/core-frontend\";\nimport { DisplayTestApp } from \"./App\";\nimport { selectFileName } from \"./FileOpen\";\nimport { FpsMonitor } from \"./FpsMonitor\";\nimport { NotificationsWindow } from \"./Notifications\";\nimport { addSnapModes } from \"./SnapModes\";\nimport { TileLoadIndicator } from \"./TileLoadIndicator\";\nimport { createToolButton, ToolBar } from \"./ToolBar\";\nimport { Viewer } from \"./Viewer\";\nimport { Dock, NamedWindow } from \"./Window\";\nimport { openIModel } from \"./openIModel\";\nimport { setTitle } from \"./Title\";\nimport { openAnalysisStyleExample } from \"./AnalysisStyleExample\";\nimport { openDecorationGeometryExample } from \"./DecorationGeometryExample\";\nexport class Surface {\n  constructor(surfaceDiv, toolbarDiv, browserFileSelector, openReadWrite) {\n    this._windows = [];\n    window.onbeforeunload = () => this.closeAllViewers();\n    this.element = surfaceDiv;\n    this.openReadWrite = openReadWrite;\n    this.browserFileSelector = browserFileSelector;\n    this._toolbarDiv = toolbarDiv;\n    this._toolbar = this.createToolBar();\n    this._toolbarDiv.appendChild(this._toolbar.element);\n    addSnapModes(document.getElementById(\"snapModesContainer\"));\n    new TileLoadIndicator(document.getElementById(\"tileLoadIndicatorContainer\"));\n    new FpsMonitor({\n      checkbox: document.getElementById(\"fps-checkbox\"),\n      label: document.getElementById(\"fps-label\"),\n      output: document.getElementById(\"fps-output\")\n    });\n    this._keyinDiv = document.getElementById(\"keyin-entry\");\n    this.keyinField = new KeyinField({\n      parent: this._keyinDiv,\n      baseId: \"dtaKeyinField\",\n      historyLength: 50\n    });\n    this.keyinField.textBox.textbox.addEventListener(\"keydown\", (e) => {\n      if (\"Escape\" === e.key || \"`\" === e.key) {\n        this.keyinField.loseFocus();\n        e.preventDefault();\n        e.stopPropagation();\n      }\n    });\n    this.keyinField.textBox.div.className = \"keyin-entry\";\n    this.keyinField.textBox.textbox.className = \"keyin-entry-textbox\";\n    this.notifications = new NotificationsWindow(this, { title: \"Notifications\", width: 800, height: 800, maxStoredMessages: 50 });\n    this.addWindow(this.notifications);\n    document.addEventListener(\"keydown\", (e) => {\n      const handler = this.getKeyboardShortcutHandler(e);\n      if (void 0 !== handler) {\n        handler();\n        e.preventDefault();\n      }\n    });\n    window.onresize = () => {\n      for (const window2 of this._windows) {\n        if (window2.isDocked)\n          window2.updateDock();\n        else\n          window2.ensureInSurface();\n      }\n    };\n    IModelApp.viewManager.onSelectedViewportChanged.addListener((args) => {\n      if (null !== this._toolbarDiv.firstChild)\n        this._toolbarDiv.removeChild(this._toolbarDiv.firstChild);\n      if (void 0 !== args.previous) {\n        const previous = this.findViewerByViewportId(args.previous.viewportId);\n        if (void 0 !== previous)\n          previous.onDeselected();\n      }\n      if (void 0 !== args.current) {\n        const current = this.findViewerByViewportId(args.current.viewportId);\n        if (void 0 !== current) {\n          current.onSelected();\n          this._toolbarDiv.appendChild(current.toolBar.element);\n          this.focus(current);\n          return;\n        }\n      }\n      this._toolbarDiv.appendChild(this._toolbar.element);\n      this.focus(this.notifications);\n    });\n  }\n  static get instance() {\n    return DisplayTestApp.surface;\n  }\n  createToolBar() {\n    const div = IModelApp.makeHTMLElement(\"div\", { className: \"topdiv\" });\n    const tb = new ToolBar(div);\n    tb.addItem(createToolButton({\n      iconUnicode: \"\",\n      // \"briefcases\"\n      tooltip: \"Open iModel from disk\",\n      click: async () => {\n        await this.openFileIModel();\n      }\n    }));\n    tb.addItem(createToolButton({\n      iconUnicode: \"\",\n      // \"property-data\"\n      tooltip: \"Open Blank Connection\",\n      click: async () => {\n        await this.openBlankConnection();\n      }\n    }));\n    tb.addItem(createToolButton({\n      iconUnicode: \"\",\n      // play\n      tooltip: \"Analysis Style Example\",\n      click: async () => {\n        const viewer = await this.openBlankConnection({\n          name: \"Analysis Style Example\",\n          extents: new Range3d(0, 0, -30, 100, 100, 20)\n        });\n        await openAnalysisStyleExample(viewer);\n      }\n    }));\n    tb.addItem(createToolButton({\n      iconUnicode: \"\",\n      tooltip: \"Decoration Geometry Example\",\n      click: async () => {\n        const viewer = await this.openBlankConnection({\n          name: \"Decoration Geometry Example\",\n          extents: new Range3d(-1, -1, -1, 13, 2, 2)\n        });\n        void openDecorationGeometryExample(viewer);\n      }\n    }));\n    return tb;\n  }\n  // create a new blank connection for testing backgroundMap and reality models.\n  async openBlankConnection(props) {\n    const iModel = BlankConnection.create({\n      location: props?.location ?? Cartographic.fromDegrees({ longitude: -75.686694, latitude: 40.065757, height: 0 }),\n      // near Exton pa\n      extents: props?.extents ?? new Range3d(-1e3, -1e3, -100, 1e3, 1e3, 100),\n      name: props?.name ?? \"blank connection test\"\n    });\n    const viewer = await this.createViewer({ iModel });\n    viewer.dock(Dock.Full);\n    return viewer;\n  }\n  async openFileIModel(fileName) {\n    if (void 0 === fileName) {\n      fileName = await this.selectFileName();\n      if (void 0 === fileName) {\n        return;\n      }\n    }\n    await this.openIModel({ fileName, writable: this.openReadWrite });\n  }\n  async openIModel(props) {\n    try {\n      const iModel = await openIModel(props);\n      setTitle(iModel);\n      const viewer = await this.createViewer({ iModel });\n      viewer.dock(Dock.Full);\n    } catch (err) {\n      alert(`Error opening iModel: ${err.toString()}`);\n    }\n  }\n  get firstViewer() {\n    for (const window2 of this._windows)\n      if (window2 instanceof Viewer)\n        return window2;\n    return void 0;\n  }\n  async openFile(filename) {\n    const viewer = this.firstViewer;\n    return void 0 !== viewer ? viewer.openFile(filename) : this.openFileIModel(filename);\n  }\n  getKeyboardShortcutHandler(e) {\n    if (e.repeat)\n      return void 0;\n    const key = e.key;\n    if (\"`\" === key)\n      return () => this.keyinField.focus();\n    if (!e.ctrlKey)\n      return void 0;\n    switch (key) {\n      case \"[\":\n      case \"]\":\n        return () => this.focusNextOrPrevious(\"]\" === key);\n    }\n    const focused = this.focusedWindow;\n    if (void 0 === focused)\n      return void 0;\n    let dock;\n    switch (key) {\n      case \"\\\\\":\n        return () => {\n          if (focused instanceof Viewer)\n            this.addViewer(focused.clone());\n        };\n      case \"|\":\n        return () => this.close(focused);\n      case \"n\":\n        return () => {\n          if (focused !== this.notifications)\n            this.notifications.focus();\n          else\n            this.focusNext();\n        };\n      case \"p\":\n        return () => this.togglePin(focused);\n      case \"i\":\n        return () => focused.dock(Dock.Full);\n      case \"m\":\n        return () => focused.undock();\n      case \"h\":\n        dock = Dock.Left;\n        break;\n      case \"l\":\n        dock = Dock.Right;\n        break;\n      case \"k\":\n        dock = Dock.Top;\n        break;\n      case \"j\":\n        dock = Dock.Bottom;\n        break;\n    }\n    if (void 0 !== dock)\n      return () => focused.addDock(dock);\n    return void 0;\n  }\n  createNamedWindow(props) {\n    const window2 = new NamedWindow(this, props);\n    this.element.appendChild(window2.container);\n    this.addWindow(window2);\n    return window2;\n  }\n  async createViewer(props) {\n    const viewer = await Viewer.create(this, props);\n    this.addViewer(viewer);\n    return viewer;\n  }\n  addViewer(viewer) {\n    this.addWindow(viewer);\n    IModelApp.viewManager.addViewport(viewer.viewport);\n  }\n  addWindow(window2) {\n    this._windows.push(window2);\n    window2.ensureInSurface();\n    this.updateWindowsUi();\n    this.focus(window2);\n  }\n  updateWindowsUi() {\n    this._windows.forEach((window2) => window2.updateUi());\n  }\n  focus(window2) {\n    const index = this._windows.indexOf(window2);\n    if (index < 1) {\n      if (0 === index)\n        window2.onFocus();\n      return;\n    }\n    this._windows.splice(index, 1);\n    this._windows.unshift(window2);\n    this.updateFocus();\n    this.keyinField.loseFocus();\n  }\n  focusNext() {\n    this.focusNextOrPrevious(true);\n  }\n  focusPrevious() {\n    this.focusNextOrPrevious(false);\n  }\n  focusNextOrPrevious(next) {\n    if (next) {\n      const front = this._windows[0];\n      this._windows.splice(0, 1);\n      this._windows.push(front);\n    } else {\n      const back = this._windows.pop();\n      this._windows.unshift(back);\n    }\n    this.updateFocus();\n  }\n  togglePin(window2) {\n    window2.isPinned = !window2.isPinned;\n    this.updateFocus();\n  }\n  updateFocus() {\n    let zIndex = 10 + this._windows.length;\n    let first = true;\n    for (const w of this._windows) {\n      if (first) {\n        w.onFocus();\n        first = false;\n      } else {\n        w.onLoseFocus();\n      }\n      const z = zIndex + (w.isPinned ? 100 : 0);\n      w.container.style.zIndex = z.toString();\n      zIndex -= 1;\n    }\n  }\n  findViewerByViewportId(id) {\n    for (const window2 of this._windows)\n      if (window2 instanceof Viewer && window2.viewport.viewportId === id)\n        return window2;\n    return void 0;\n  }\n  get hasMultipleViewers() {\n    let num = 0;\n    for (const window2 of this._windows) {\n      if (window2 instanceof Viewer) {\n        ++num;\n        if (num > 1)\n          return true;\n      }\n    }\n    return false;\n  }\n  findWindowById(id) {\n    return this._windows.find((x) => x.windowId === id);\n  }\n  get focusedWindow() {\n    return this._windows[0];\n  }\n  close(window2) {\n    if (window2.isCloseable)\n      this.forceClose(window2);\n  }\n  closeAllViewers() {\n    const viewers = this._windows.filter((x) => x instanceof Viewer);\n    for (const viewer of viewers)\n      this.forceClose(viewer);\n  }\n  forceClose(window2) {\n    window2.onClosing();\n    const index = this._windows.indexOf(window2);\n    if (-1 !== index) {\n      this._windows.splice(index, 1);\n      this.element.removeChild(window2.container);\n      window2.onClosed();\n    }\n    this.updateWindowsUi();\n  }\n  onResetIModel(viewer) {\n    for (const window2 of this._windows)\n      if (window2 instanceof Viewer && window2 !== viewer)\n        this.forceClose(window2);\n  }\n  async selectFileName() {\n    return selectFileName(this.browserFileSelector);\n  }\n  async selectHubIModel() {\n    alert(\"Not Implemented.\");\n    return void 0;\n  }\n}\nexport class CreateWindowTool extends Tool {\n  static get minArgs() {\n    return 1;\n  }\n  static get maxArgs() {\n    return void 0;\n  }\n  async run(props) {\n    DisplayTestApp.surface.createNamedWindow(props);\n    return true;\n  }\n  async parseAndRun(...inputArgs) {\n    let name;\n    const props = {};\n    const args = parseArgs(inputArgs);\n    const id = args.get(\"id\");\n    if (void 0 !== id)\n      name = id;\n    const title = args.get(\"title\");\n    if (void 0 !== title)\n      props.title = title;\n    const sides = [\"top\", \"left\", \"width\", \"height\"];\n    for (const key of sides) {\n      const value = args.getInteger(key);\n      if (void 0 !== value)\n        props[key] = value;\n    }\n    if (void 0 !== name) {\n      const namedProps = { id: name, ...props };\n      await this.run(namedProps);\n    }\n    return true;\n  }\n}\nCreateWindowTool.toolId = \"CreateWindow\";\nexport class WindowIdTool extends Tool {\n  static get minArgs() {\n    return 0;\n  }\n  static get maxArgs() {\n    return 1;\n  }\n  async run(windowId) {\n    const window2 = void 0 !== windowId ? Surface.instance.findWindowById(windowId) : Surface.instance.focusedWindow;\n    if (void 0 !== window2)\n      this.execute(window2);\n    return true;\n  }\n  async parseAndRun(...args) {\n    return this.run(args[0]);\n  }\n}\nexport class FocusWindowTool extends WindowIdTool {\n  execute(window2) {\n    window2.focus();\n  }\n}\nFocusWindowTool.toolId = \"FocusWindow\";\nexport class MaximizeWindowTool extends WindowIdTool {\n  execute(window2) {\n    if (!window2.isDocked)\n      window2.dock(Dock.Full);\n  }\n}\nMaximizeWindowTool.toolId = \"MaximizeWindow\";\nexport class RestoreWindowTool extends WindowIdTool {\n  execute(window2) {\n    window2.undock();\n  }\n}\nRestoreWindowTool.toolId = \"RestoreWindow\";\nexport class CloseWindowTool extends WindowIdTool {\n  execute(window2) {\n    Surface.instance.close(window2);\n  }\n}\nCloseWindowTool.toolId = \"CloseWindow\";\nexport class ResizeWindowTool extends Tool {\n  static get minArgs() {\n    return 2;\n  }\n  static get maxArgs() {\n    return 3;\n  }\n  async run(width, height, id) {\n    const window2 = void 0 !== id ? Surface.instance.findWindowById(id) : Surface.instance.focusedWindow;\n    if (void 0 !== window2)\n      window2.resizeContent(width, height);\n    return true;\n  }\n  // width height [id]\n  async parseAndRun(...args) {\n    const w = parseInt(args[0], 10);\n    const h = parseInt(args[1], 10);\n    if (!Number.isNaN(w) || !Number.isNaN(h))\n      await this.run(w, h, args[2]);\n    return true;\n  }\n}\nResizeWindowTool.toolId = \"ResizeWindow\";\nexport class DockWindowTool extends Tool {\n  static get minArgs() {\n    return 1;\n  }\n  static get maxArgs() {\n    return 2;\n  }\n  async run(dock, windowId) {\n    const window2 = void 0 !== windowId ? Surface.instance.findWindowById(windowId) : Surface.instance.focusedWindow;\n    if (void 0 !== window2)\n      window2.dock(dock);\n    return true;\n  }\n  async parseAndRun(...args) {\n    let dock = 0;\n    for (const c of args[0].toLowerCase()) {\n      switch (c) {\n        case \"l\":\n          dock |= Dock.Left;\n          break;\n        case \"r\":\n          dock |= Dock.Right;\n          break;\n        case \"t\":\n          dock |= Dock.Top;\n          break;\n        case \"b\":\n          dock |= Dock.Bottom;\n          break;\n        default:\n          return true;\n      }\n    }\n    if (0 !== dock)\n      await this.run(dock, args[1]);\n    return true;\n  }\n}\nDockWindowTool.toolId = \"DockWindow\";\nexport class CloneViewportTool extends Tool {\n  static get minArgs() {\n    return 0;\n  }\n  static get maxArgs() {\n    return 1;\n  }\n  async run(viewportId) {\n    if (void 0 === viewportId) {\n      const selectedView = IModelApp.viewManager.selectedView;\n      if (void 0 === selectedView)\n        return true;\n      viewportId = selectedView.viewportId;\n    }\n    const surface = DisplayTestApp.surface;\n    const viewer = surface.findViewerByViewportId(viewportId);\n    if (void 0 !== viewer)\n      surface.addViewer(viewer.clone());\n    return true;\n  }\n  async parseAndRun(...args) {\n    const viewportId = parseInt(args[0], 10);\n    return void 0 !== viewportId && !Number.isNaN(viewportId) && this.run(viewportId);\n  }\n}\nCloneViewportTool.toolId = \"CloneViewport\";\nexport class OpenIModelTool extends Tool {\n  static get minArgs() {\n    return 0;\n  }\n  static get maxArgs() {\n    return 1;\n  }\n  async run(filename) {\n    await Surface.instance.openFile(filename);\n    return true;\n  }\n  async parseAndRun(...args) {\n    return this.run(args[0]);\n  }\n}\nOpenIModelTool.toolId = \"OpenIModel\";\nexport class CloseIModelTool extends Tool {\n  async run() {\n    Surface.instance.closeAllViewers();\n    return true;\n  }\n}\nCloseIModelTool.toolId = \"CloseIModel\";\nexport class ReopenIModelTool extends Tool {\n  async run() {\n    const viewer = Surface.instance.firstViewer;\n    if (void 0 !== viewer)\n      await viewer.openFile(viewer.viewport.iModel.key);\n    return true;\n  }\n}\nReopenIModelTool.toolId = \"ReopenIModel\";\n",
      "start": 1693508118556,
      "end": 1693508118715,
      "order": "normal",
      "sourcemaps": {
        "version": 3,
        "sources": [
          "D:/hub2023A/itwinjs-core/test-apps/display-test-app/src/frontend/Surface.ts"
        ],
        "sourcesContent": [
          "/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\r\n* See LICENSE.md in the project root for license terms and full copyright notice.\r\n*--------------------------------------------------------------------------------------------*/\r\nimport { KeyinField, parseArgs } from \"@itwin/frontend-devtools\";\r\nimport { Range3d } from \"@itwin/core-geometry\";\r\nimport { Cartographic } from \"@itwin/core-common\";\r\nimport { BlankConnection, BlankConnectionProps, IModelApp, Tool } from \"@itwin/core-frontend\";\r\nimport { DisplayTestApp } from \"./App\";\r\nimport { BrowserFileSelector, selectFileName } from \"./FileOpen\";\r\nimport { FpsMonitor } from \"./FpsMonitor\";\r\nimport { NotificationsWindow } from \"./Notifications\";\r\nimport { addSnapModes } from \"./SnapModes\";\r\nimport { TileLoadIndicator } from \"./TileLoadIndicator\";\r\nimport { createToolButton, ToolBar } from \"./ToolBar\";\r\nimport { Viewer, ViewerProps } from \"./Viewer\";\r\nimport { Dock, NamedWindow, NamedWindowProps, Window, WindowProps } from \"./Window\";\r\nimport { openIModel, OpenIModelProps } from \"./openIModel\";\r\nimport { setTitle } from \"./Title\";\r\nimport { openAnalysisStyleExample } from \"./AnalysisStyleExample\";\r\nimport { openDecorationGeometryExample } from \"./DecorationGeometryExample\";\r\n\r\n// cspell:ignore textbox topdiv\r\n\r\nexport class Surface {\r\n  public readonly element: HTMLElement;\r\n  public readonly keyinField: KeyinField;\r\n  private readonly _keyinDiv: HTMLElement;\r\n  private readonly _toolbarDiv: HTMLElement;\r\n  private readonly _windows: Window[] = [];\r\n  public readonly notifications: NotificationsWindow;\r\n  private readonly _toolbar: ToolBar;\r\n  public readonly browserFileSelector?: BrowserFileSelector;\r\n  public readonly openReadWrite: boolean;\r\n\r\n  public static get instance() { return DisplayTestApp.surface; }\r\n\r\n  public constructor(surfaceDiv: HTMLElement, toolbarDiv: HTMLElement, browserFileSelector: BrowserFileSelector | undefined, openReadWrite: boolean) {\r\n    // Ensure iModel gets closed on page close/reload\r\n    window.onbeforeunload = () => this.closeAllViewers();\r\n\r\n    this.element = surfaceDiv;\r\n    this.openReadWrite = openReadWrite;\r\n    this.browserFileSelector = browserFileSelector;\r\n    this._toolbarDiv = toolbarDiv;\r\n    this._toolbar = this.createToolBar();\r\n    this._toolbarDiv.appendChild(this._toolbar.element);\r\n\r\n    addSnapModes(document.getElementById(\"snapModesContainer\")!);\r\n    new TileLoadIndicator(document.getElementById(\"tileLoadIndicatorContainer\") as HTMLDivElement);\r\n    new FpsMonitor({\r\n      checkbox: document.getElementById(\"fps-checkbox\") as HTMLInputElement,\r\n      label: document.getElementById(\"fps-label\") as HTMLLabelElement,\r\n      output: document.getElementById(\"fps-output\") as HTMLSpanElement,\r\n    });\r\n\r\n    this._keyinDiv = document.getElementById(\"keyin-entry\")!;\r\n    this.keyinField = new KeyinField({\r\n      parent: this._keyinDiv,\r\n      baseId: \"dtaKeyinField\",\r\n      historyLength: 50,\r\n    });\r\n    this.keyinField.textBox.textbox.addEventListener(\"keydown\", (e) => {\r\n      if (\"Escape\" === e.key || \"`\" === e.key) {\r\n        this.keyinField.loseFocus();\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n      }\r\n    });\r\n    this.keyinField.textBox.div.className = \"keyin-entry\";\r\n    this.keyinField.textBox.textbox.className = \"keyin-entry-textbox\";\r\n\r\n    this.notifications = new NotificationsWindow(this, { title: \"Notifications\", width: 800, height: 800, maxStoredMessages: 50 });\r\n    this.addWindow(this.notifications);\r\n\r\n    document.addEventListener(\"keydown\", (e) => {\r\n      const handler = this.getKeyboardShortcutHandler(e);\r\n      if (undefined !== handler) {\r\n        handler();\r\n        e.preventDefault();\r\n      }\r\n    });\r\n\r\n    window.onresize = () => {\r\n      for (const window of this._windows) {\r\n        if (window.isDocked)\r\n          window.updateDock();\r\n        else\r\n          window.ensureInSurface();\r\n      }\r\n    };\r\n\r\n    IModelApp.viewManager.onSelectedViewportChanged.addListener((args) => {\r\n      if (null !== this._toolbarDiv.firstChild)\r\n        this._toolbarDiv.removeChild(this._toolbarDiv.firstChild);\r\n\r\n      if (undefined !== args.previous) {\r\n        const previous = this.findViewerByViewportId(args.previous.viewportId);\r\n        if (undefined !== previous)\r\n          previous.onDeselected();\r\n      }\r\n\r\n      if (undefined !== args.current) {\r\n        const current = this.findViewerByViewportId(args.current.viewportId);\r\n        if (undefined !== current) {\r\n          current.onSelected();\r\n          this._toolbarDiv.appendChild(current.toolBar.element);\r\n          this.focus(current);\r\n          return;\r\n        }\r\n      }\r\n\r\n      this._toolbarDiv.appendChild(this._toolbar.element);\r\n      this.focus(this.notifications);\r\n    });\r\n  }\r\n\r\n  private createToolBar(): ToolBar {\r\n    const div = IModelApp.makeHTMLElement(\"div\", { className: \"topdiv\" });\r\n    const tb = new ToolBar(div);\r\n\r\n    tb.addItem(createToolButton({\r\n      iconUnicode: \"\\ue9cc\", // \"briefcases\"\r\n      tooltip: \"Open iModel from disk\",\r\n      click: async () => {\r\n        await this.openFileIModel();\r\n      },\r\n    }));\r\n\r\n    tb.addItem(createToolButton({\r\n      iconUnicode: \"\\ue9d8\", // \"property-data\"\r\n      tooltip: \"Open Blank Connection\",\r\n      click: async () => {\r\n        await this.openBlankConnection();\r\n      },\r\n    }));\r\n\r\n    tb.addItem(createToolButton({\r\n      iconUnicode: \"\\uea32\", // play\r\n      tooltip: \"Analysis Style Example\",\r\n      click: async () => {\r\n        const viewer = await this.openBlankConnection({\r\n          name: \"Analysis Style Example\",\r\n          extents: new Range3d(0, 0, -30, 100, 100, 20),\r\n        });\r\n\r\n        await openAnalysisStyleExample(viewer);\r\n      },\r\n    }));\r\n\r\n    tb.addItem(createToolButton({\r\n      iconUnicode: \"\\ue9d8\",\r\n      tooltip: \"Decoration Geometry Example\",\r\n      click: async () => {\r\n        const viewer = await this.openBlankConnection({\r\n          name: \"Decoration Geometry Example\",\r\n          extents: new Range3d(-1, -1, -1, 13, 2, 2),\r\n        });\r\n        void openDecorationGeometryExample(viewer);\r\n      },\r\n    }));\r\n\r\n    return tb;\r\n  }\r\n\r\n  // create a new blank connection for testing backgroundMap and reality models.\r\n  private async openBlankConnection(props?: Partial<BlankConnectionProps>): Promise<Viewer> {\r\n    const iModel = BlankConnection.create({\r\n      location: props?.location ?? Cartographic.fromDegrees({longitude: -75.686694, latitude: 40.065757, height: 0}), // near Exton pa\r\n      extents: props?.extents ?? new Range3d(-1000, -1000, -100, 1000, 1000, 100),\r\n      name: props?.name ?? \"blank connection test\",\r\n    });\r\n\r\n    const viewer = await this.createViewer({ iModel });\r\n    viewer.dock(Dock.Full);\r\n    return viewer;\r\n  }\r\n\r\n  private async openFileIModel(fileName?: string): Promise<void> {\r\n    if (undefined === fileName) {\r\n      fileName = await this.selectFileName();\r\n      if (undefined === fileName) {\r\n        return;\r\n      }\r\n    }\r\n    await this.openIModel({ fileName, writable: this.openReadWrite });\r\n  }\r\n\r\n  private async openIModel(props: OpenIModelProps): Promise<void> {\r\n    try {\r\n      const iModel = await openIModel(props);\r\n      setTitle(iModel);\r\n      const viewer = await this.createViewer({ iModel });\r\n      viewer.dock(Dock.Full);\r\n    } catch (err: any) {\r\n      alert(`Error opening iModel: ${err.toString()}`);\r\n    }\r\n  }\r\n\r\n  public get firstViewer(): Viewer | undefined {\r\n    for (const window of this._windows)\r\n      if (window instanceof Viewer)\r\n        return window;\r\n\r\n    return undefined;\r\n  }\r\n\r\n  public async openFile(filename?: string): Promise<void> {\r\n    const viewer = this.firstViewer;\r\n    return undefined !== viewer ? viewer.openFile(filename) : this.openFileIModel(filename);\r\n  }\r\n\r\n  private getKeyboardShortcutHandler(e: KeyboardEvent): (() => void) | undefined {\r\n    if (e.repeat)\r\n      return undefined;\r\n\r\n    const key = e.key;\r\n    if (\"`\" === key)\r\n      return () => this.keyinField.focus();\r\n\r\n    if (!e.ctrlKey)\r\n      return undefined;\r\n\r\n    switch (key) {\r\n      case \"[\":\r\n      case \"]\":\r\n        return () => this.focusNextOrPrevious(\"]\" === key);\r\n    }\r\n\r\n    const focused = this.focusedWindow;\r\n    if (undefined === focused)\r\n      return undefined;\r\n\r\n    let dock: Dock | undefined;\r\n    switch (key) {\r\n      case \"\\\\\":\r\n        return () => {\r\n          if (focused instanceof Viewer)\r\n            this.addViewer(focused.clone());\r\n        };\r\n      case \"|\":\r\n        return () => this.close(focused);\r\n      case \"n\":\r\n        // NB: This doesn't work in Chrome (it doesn't give us the keydown event for ctrl-n)\r\n        return () => {\r\n          if (focused !== this.notifications)\r\n            this.notifications.focus();\r\n          else\r\n            this.focusNext();\r\n        };\r\n      case \"p\":\r\n        return () => this.togglePin(focused);\r\n      case \"i\":\r\n        return () => focused.dock(Dock.Full);\r\n      case \"m\":\r\n        return () => focused.undock();\r\n      case \"h\":\r\n        dock = Dock.Left;\r\n        break;\r\n      case \"l\":\r\n        dock = Dock.Right;\r\n        break;\r\n      case \"k\":\r\n        dock = Dock.Top;\r\n        break;\r\n      case \"j\":\r\n        dock = Dock.Bottom;\r\n        break;\r\n    }\r\n\r\n    if (undefined !== dock)\r\n      return () => focused.addDock(dock!);\r\n\r\n    return undefined;\r\n  }\r\n\r\n  public createNamedWindow(props: NamedWindowProps): NamedWindow {\r\n    const window = new NamedWindow(this, props);\r\n    this.element.appendChild(window.container);\r\n    this.addWindow(window);\r\n    return window;\r\n  }\r\n\r\n  public async createViewer(props: ViewerProps): Promise<Viewer> {\r\n    const viewer = await Viewer.create(this, props);\r\n    this.addViewer(viewer);\r\n    return viewer;\r\n  }\r\n\r\n  public addViewer(viewer: Viewer): void {\r\n    this.addWindow(viewer);\r\n    IModelApp.viewManager.addViewport(viewer.viewport);\r\n  }\r\n\r\n  public addWindow(window: Window): void {\r\n    this._windows.push(window);\r\n    window.ensureInSurface();\r\n    this.updateWindowsUi();\r\n    this.focus(window);\r\n  }\r\n\r\n  private updateWindowsUi(): void {\r\n    this._windows.forEach((window: Window) => window.updateUi());\r\n  }\r\n\r\n  public focus(window: Window): void {\r\n    const index = this._windows.indexOf(window);\r\n    if (index < 1) {\r\n      if (0 === index)\r\n        window.onFocus(); // for when we initially create the first window...\r\n\r\n      // not found, or already focused.\r\n      return;\r\n    }\r\n\r\n    this._windows.splice(index, 1);\r\n    this._windows.unshift(window);\r\n    this.updateFocus();\r\n\r\n    // ###TODO: This should only apply if you CLICKED on the window to focus it.\r\n    this.keyinField.loseFocus();\r\n  }\r\n\r\n  public focusNext() { this.focusNextOrPrevious(true); }\r\n  public focusPrevious() { this.focusNextOrPrevious(false); }\r\n  private focusNextOrPrevious(next: boolean): void {\r\n    // Focusing a window moves it to the front of the _windows array. So that array is ordered by most-recently- to least-recently-focused.\r\n    if (next) {\r\n      const front = this._windows[0];\r\n      this._windows.splice(0, 1);\r\n      this._windows.push(front);\r\n    } else {\r\n      const back = this._windows.pop()!;\r\n      this._windows.unshift(back);\r\n    }\r\n\r\n    this.updateFocus();\r\n  }\r\n\r\n  public togglePin(window: Window): void {\r\n    window.isPinned = !window.isPinned;\r\n    this.updateFocus();\r\n  }\r\n\r\n  private updateFocus(): void {\r\n    let zIndex = 10 + this._windows.length;\r\n    let first = true;\r\n    for (const w of this._windows) {\r\n      if (first) {\r\n        w.onFocus();\r\n        first = false;\r\n      } else {\r\n        w.onLoseFocus();\r\n      }\r\n\r\n      const z = zIndex + (w.isPinned ? 100 : 0);\r\n      w.container.style.zIndex = z.toString();\r\n      zIndex -= 1;\r\n    }\r\n  }\r\n\r\n  public findViewerByViewportId(id: number): Viewer | undefined {\r\n    for (const window of this._windows)\r\n      if (window instanceof Viewer && window.viewport.viewportId === id)\r\n        return window;\r\n\r\n    return undefined;\r\n  }\r\n\r\n  public get hasMultipleViewers(): boolean {\r\n    let num = 0;\r\n    for (const window of this._windows) {\r\n      if (window instanceof Viewer) {\r\n        ++num;\r\n        if (num > 1)\r\n          return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  public findWindowById(id: string): Window | undefined {\r\n    return this._windows.find((x) => x.windowId === id);\r\n  }\r\n\r\n  public get focusedWindow(): Window | undefined {\r\n    return this._windows[0];\r\n  }\r\n\r\n  public close(window: Window): void {\r\n    if (window.isCloseable)\r\n      this.forceClose(window);\r\n  }\r\n\r\n  public closeAllViewers(): void {\r\n    const viewers = this._windows.filter((x) => x instanceof Viewer);\r\n    for (const viewer of viewers)\r\n      this.forceClose(viewer);\r\n  }\r\n\r\n  public forceClose(window: Window): void {\r\n    // NB: Must do this before computing index, because closing a Viewer changes the selected viewport which changes focus which changes order of windows in array.\r\n    window.onClosing();\r\n    const index = this._windows.indexOf(window);\r\n    if (-1 !== index) {\r\n      this._windows.splice(index, 1);\r\n      this.element.removeChild(window.container);\r\n      window.onClosed();\r\n    }\r\n    this.updateWindowsUi();\r\n  }\r\n\r\n  public onResetIModel(viewer: Viewer): void {\r\n    for (const window of this._windows)\r\n      if (window instanceof Viewer && window !== viewer)\r\n        this.forceClose(window);\r\n  }\r\n\r\n  public async selectFileName(): Promise<string | undefined> {\r\n    return selectFileName(this.browserFileSelector);\r\n  }\r\n\r\n  public async selectHubIModel(): Promise<OpenIModelProps | undefined> {\r\n    // TODO: Show dialog to allow user to input iModelId and iTwinId.\r\n    alert(\"Not Implemented.\");\r\n    return undefined;\r\n  }\r\n}\r\n\r\nexport class CreateWindowTool extends Tool {\r\n  public static override toolId = \"CreateWindow\";\r\n  public static override get minArgs() { return 1; }\r\n  public static override get maxArgs() { return undefined; }\r\n\r\n  public override async run(props: NamedWindowProps): Promise<boolean> {\r\n    DisplayTestApp.surface.createNamedWindow(props);\r\n    return true;\r\n  }\r\n\r\n  public override async parseAndRun(...inputArgs: string[]): Promise<boolean> {\r\n    let name: string | undefined;\r\n    const props: WindowProps = {};\r\n\r\n    const args = parseArgs(inputArgs);\r\n    const id = args.get(\"id\");\r\n    if (undefined !== id)\r\n      name = id;\r\n\r\n    const title = args.get(\"title\");\r\n    if (undefined !== title)\r\n      props.title = title;\r\n\r\n    const sides: Array<\"top\" | \"left\" | \"width\" | \"height\"> = [\"top\", \"left\", \"width\", \"height\"];\r\n    for (const key of sides) {\r\n      const value = args.getInteger(key);\r\n      if (undefined !== value)\r\n        props[key] = value;\r\n    }\r\n\r\n    if (undefined !== name) {\r\n      const namedProps: NamedWindowProps = { id: name, ...props };\r\n      await this.run(namedProps);\r\n    }\r\n\r\n    return true;\r\n  }\r\n}\r\n\r\nexport abstract class WindowIdTool extends Tool {\r\n  public static override get minArgs() { return 0; }\r\n  public static override get maxArgs() { return 1; }\r\n\r\n  public abstract execute(_window: Window): void;\r\n\r\n  public override async run(windowId?: string): Promise<boolean> {\r\n    const window = undefined !== windowId ? Surface.instance.findWindowById(windowId) : Surface.instance.focusedWindow;\r\n    if (undefined !== window)\r\n      this.execute(window);\r\n\r\n    return true;\r\n  }\r\n\r\n  public override async parseAndRun(...args: string[]): Promise<boolean> {\r\n    return this.run(args[0]);\r\n  }\r\n}\r\n\r\nexport class FocusWindowTool extends WindowIdTool {\r\n  public static override toolId = \"FocusWindow\";\r\n  public execute(window: Window): void {\r\n    window.focus();\r\n  }\r\n}\r\n\r\nexport class MaximizeWindowTool extends WindowIdTool {\r\n  public static override toolId = \"MaximizeWindow\";\r\n  public execute(window: Window): void {\r\n    if (!window.isDocked)\r\n      window.dock(Dock.Full);\r\n  }\r\n}\r\n\r\nexport class RestoreWindowTool extends WindowIdTool {\r\n  public static override toolId = \"RestoreWindow\";\r\n  public execute(window: Window): void {\r\n    window.undock();\r\n  }\r\n}\r\n\r\nexport class CloseWindowTool extends WindowIdTool {\r\n  public static override toolId = \"CloseWindow\";\r\n  public execute(window: Window): void {\r\n    Surface.instance.close(window);\r\n  }\r\n}\r\nexport class ResizeWindowTool extends Tool {\r\n  public static override toolId = \"ResizeWindow\";\r\n  public static override get minArgs() { return 2; }\r\n  public static override get maxArgs() { return 3; }\r\n\r\n  public override async run(width: number, height: number, id?: string): Promise<boolean> {\r\n    const window = undefined !== id ? Surface.instance.findWindowById(id) : Surface.instance.focusedWindow;\r\n    if (undefined !== window)\r\n      window.resizeContent(width, height);\r\n\r\n    return true;\r\n  }\r\n\r\n  // width height [id]\r\n  public override async parseAndRun(...args: string[]): Promise<boolean> {\r\n    const w = parseInt(args[0], 10);\r\n    const h = parseInt(args[1], 10);\r\n    if (!Number.isNaN(w) || !Number.isNaN(h))\r\n      await this.run(w, h, args[2]);\r\n\r\n    return true;\r\n  }\r\n}\r\n\r\nexport class DockWindowTool extends Tool {\r\n  public static override toolId = \"DockWindow\";\r\n  public static override get minArgs() { return 1; }\r\n  public static override get maxArgs() { return 2; }\r\n\r\n  public override async run(dock: Dock, windowId?: string): Promise<boolean> {\r\n    const window = undefined !== windowId ? Surface.instance.findWindowById(windowId) : Surface.instance.focusedWindow;\r\n    if (undefined !== window)\r\n      window.dock(dock);\r\n\r\n    return true;\r\n  }\r\n\r\n  public override async parseAndRun(...args: string[]): Promise<boolean> {\r\n    let dock = 0;\r\n    for (const c of args[0].toLowerCase()) {\r\n      switch (c) {\r\n        case \"l\":\r\n          dock |= Dock.Left;\r\n          break;\r\n        case \"r\":\r\n          dock |= Dock.Right;\r\n          break;\r\n        case \"t\":\r\n          dock |= Dock.Top;\r\n          break;\r\n        case \"b\":\r\n          dock |= Dock.Bottom;\r\n          break;\r\n        default:\r\n          return true;\r\n      }\r\n    }\r\n\r\n    if (0 !== dock)\r\n      await this.run(dock, args[1]);\r\n\r\n    return true;\r\n  }\r\n}\r\n\r\nexport class CloneViewportTool extends Tool {\r\n  public static override toolId = \"CloneViewport\";\r\n  public static override get minArgs() { return 0; }\r\n  public static override get maxArgs() { return 1; }\r\n\r\n  public override async run(viewportId?: number): Promise<boolean> {\r\n    if (undefined === viewportId) {\r\n      const selectedView = IModelApp.viewManager.selectedView;\r\n      if (undefined === selectedView)\r\n        return true;\r\n\r\n      viewportId = selectedView.viewportId;\r\n    }\r\n\r\n    const surface = DisplayTestApp.surface;\r\n    const viewer = surface.findViewerByViewportId(viewportId);\r\n    if (undefined !== viewer)\r\n      surface.addViewer(viewer.clone());\r\n\r\n    return true;\r\n  }\r\n\r\n  public override async parseAndRun(...args: string[]): Promise<boolean> {\r\n    const viewportId = parseInt(args[0], 10);\r\n    return undefined !== viewportId && !Number.isNaN(viewportId) && this.run(viewportId);\r\n  }\r\n}\r\n\r\nexport class OpenIModelTool extends Tool {\r\n  public static override toolId = \"OpenIModel\";\r\n  public static override get minArgs() { return 0; }\r\n  public static override get maxArgs() { return 1; }\r\n\r\n  public override async run(filename?: string): Promise<boolean> {\r\n    await Surface.instance.openFile(filename);\r\n    return true;\r\n  }\r\n\r\n  public override async parseAndRun(...args: string[]): Promise<boolean> {\r\n    return this.run(args[0]);\r\n  }\r\n}\r\n\r\nexport class CloseIModelTool extends Tool {\r\n  public static override toolId = \"CloseIModel\";\r\n\r\n  public override async run(): Promise<boolean> {\r\n    Surface.instance.closeAllViewers();\r\n    return true;\r\n  }\r\n}\r\n\r\nexport class ReopenIModelTool extends Tool {\r\n  public static override toolId = \"ReopenIModel\";\r\n\r\n  public override async run(): Promise<boolean> {\r\n    const viewer = Surface.instance.firstViewer;\r\n    if (undefined !== viewer)\r\n      await viewer.openFile(viewer.viewport.iModel.key);\r\n\r\n    return true;\r\n  }\r\n}\r\n"
        ],
        "mappings": "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",
        "names": [
          "window"
        ]
      }
    }
  ]
}
