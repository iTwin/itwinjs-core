{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/BriefcaseConnection.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module IModelConnection\n */\nimport { assert, BeEvent, CompressedId64Set, Guid, IModelStatus, OpenMode } from \"@itwin/core-bentley\";\nimport { getPullChangesIpcChannel, IModelError, } from \"@itwin/core-common\";\nimport { BriefcaseTxns } from \"./BriefcaseTxns\";\nimport { GraphicalEditingScope } from \"./GraphicalEditingScope\";\nimport { IModelApp } from \"./IModelApp\";\nimport { IModelConnection } from \"./IModelConnection\";\nimport { IpcApp } from \"./IpcApp\";\nimport { disposeTileTreesForGeometricModels } from \"./tile/internal\";\nimport { Viewport } from \"./Viewport\";\n/** Keeps track of changes to models, buffering them until synchronization points.\n * While a GraphicalEditingScope is open, the changes are buffered until the scope exits, at which point they are processed.\n * Otherwise, the buffered changes are processed after undo/redo, commit, or pull+merge changes.\n */\nclass ModelChangeMonitor {\n    constructor(briefcase) {\n        this._deletedModels = new Set();\n        this._modelIdToGuid = new Map();\n        this._removals = [];\n        this._briefcase = briefcase;\n        // Buffer updated geometry guids.\n        this._removals.push(briefcase.txns.onModelGeometryChanged.addListener((changes) => {\n            for (const change of changes) {\n                this._deletedModels.delete(change.id);\n                this._modelIdToGuid.set(change.id, change.guid);\n            }\n        }));\n        // Buffer deletions of models.\n        this._removals.push(briefcase.txns.onModelsChanged.addListener((changes) => {\n            if (changes.deleted) {\n                for (const id of CompressedId64Set.iterable(changes.deleted)) {\n                    this._modelIdToGuid.delete(id);\n                    this._deletedModels.add(id);\n                }\n            }\n        }));\n        // Outside of an editing scope, we want to update viewport contents after commit, undo/redo, or merging changes.\n        const maybeProcess = async () => {\n            if (this.editingScope)\n                return;\n            const modelIds = Array.from(this._modelIdToGuid.keys());\n            if (modelIds.length > 0)\n                await IModelApp.tileAdmin.purgeTileTrees(this._briefcase, modelIds);\n            this.processBuffered();\n        };\n        this._removals.push(briefcase.txns.onCommitted.addListener(maybeProcess));\n        this._removals.push(briefcase.txns.onReplayedExternalTxns.addListener(maybeProcess));\n        this._removals.push(briefcase.txns.onAfterUndoRedo.addListener(maybeProcess));\n        this._removals.push(briefcase.txns.onChangesPulled.addListener(maybeProcess));\n    }\n    async close() {\n        for (const removal of this._removals)\n            removal();\n        this._removals.length = 0;\n        if (this._editingScope) {\n            await this._editingScope.exit();\n            this._editingScope = undefined;\n        }\n    }\n    get editingScope() {\n        return this._editingScope;\n    }\n    async enterEditingScope() {\n        if (this._editingScope)\n            throw new Error(\"Cannot create an editing scope for an iModel that already has one\");\n        this._editingScope = await GraphicalEditingScope.enter(this._briefcase);\n        const removeGeomListener = this._editingScope.onGeometryChanges.addListener((changes) => {\n            const modelIds = [];\n            for (const change of changes)\n                modelIds.push(change.id);\n            this.invalidateScenes(modelIds);\n        });\n        this._editingScope.onExited.addOnce((scope) => {\n            assert(scope === this._editingScope);\n            this._editingScope = undefined;\n            removeGeomListener();\n            this.processBuffered();\n        });\n        return this._editingScope;\n    }\n    processBuffered() {\n        const models = this._briefcase.models;\n        for (const [id, guid] of this._modelIdToGuid) {\n            const model = models.getLoaded(id)?.asGeometricModel;\n            if (model)\n                model.geometryGuid = guid;\n        }\n        const modelIds = new Set(this._modelIdToGuid.keys());\n        for (const deleted of this._deletedModels) {\n            modelIds.add(deleted);\n            models.unload(deleted);\n        }\n        this.invalidateScenes(modelIds);\n        disposeTileTreesForGeometricModels(modelIds, this._briefcase);\n        this._briefcase.onBufferedModelChanges.raiseEvent(modelIds);\n        this._modelIdToGuid.clear();\n        this._deletedModels.clear();\n    }\n    invalidateScenes(changedModels) {\n        for (const user of IModelApp.tileAdmin.tileUsers) {\n            if (user instanceof Viewport && user.iModel === this._briefcase) {\n                for (const modelId of changedModels) {\n                    if (user.view.viewsModel(modelId)) {\n                        user.invalidateScene();\n                        user.setFeatureOverrideProviderChanged();\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}\n/** Settings that can be used to control the behavior of [[Tool]]s that modify a [[BriefcaseConnection]].\n * For example, tools that want to create new elements can consult the briefcase's editor tool settings to\n * determine into which model and category to insert the elements.\n * Specialized tools are free to ignore these settings.\n * @see [[BriefcaseConnection.editorToolSettings]] to query or modify the current settings for a briefcase.\n * @see [CreateElementTool]($editor-frontend) for an example of a tool that uses these settings.\n * @beta\n */\nexport class BriefcaseEditorToolSettings {\n    constructor() {\n        /** An event raised just after the default [[category]] is changed. */\n        this.onCategoryChanged = new BeEvent();\n        /** An event raised just after the default [[model]] is changed. */\n        this.onModelChanged = new BeEvent();\n    }\n    /** The [Category]($backend) into which new elements should be inserted by default.\n     * Specialized tools are free to ignore this setting and instead use their own logic to select an appropriate category.\n     * @see [[onCategoryChanged]] to be notified when this property is modified.\n     * @see [CreateElementTool.targetCategory]($editor-frontend) for an example of a tool that uses this setting.\n     */\n    get category() {\n        return this._category;\n    }\n    set category(category) {\n        const previousCategory = this.category;\n        if (category !== this.category) {\n            this._category = category;\n            this.onCategoryChanged.raiseEvent(previousCategory);\n        }\n    }\n    /** The [Model]($backend) into which new elements should be inserted by default.\n     * Specialized tools are free to ignore this setting and instead use their own logic to select an appropriate model.\n     * @see [[onModelChanged]] to be notified when this property is modified.\n     * @see [CreateElementTool.targetModelId]($editor-frontend) for an example of a tool that uses this setting.\n     */\n    get model() {\n        return this._model;\n    }\n    set model(model) {\n        const previousModel = this.model;\n        if (model !== this.model) {\n            this._model = model;\n            this.onModelChanged.raiseEvent(previousModel);\n        }\n    }\n}\n/** A connection to an editable briefcase on the backend. This class uses [Ipc]($docs/learning/IpcInterface.md) to communicate\n * to the backend and may only be used by [[IpcApp]]s.\n * @public\n */\nexport class BriefcaseConnection extends IModelConnection {\n    /** @internal */\n    isBriefcaseConnection() { return true; }\n    /** The Guid that identifies the iTwin that owns this iModel. */\n    get iTwinId() { return super.iTwinId; } // GuidString | undefined for IModelConnection, but required for BriefcaseConnection\n    /** The Guid that identifies this iModel. */\n    get iModelId() { return super.iModelId; } // GuidString | undefined for IModelConnection, but required for BriefcaseConnection\n    constructor(props, openMode) {\n        super(props);\n        /** Default settings that can be used to control the behavior of [[Tool]]s that modify this briefcase.\n         * @beta\n         */\n        this.editorToolSettings = new BriefcaseEditorToolSettings();\n        /** Strictly for tests - dispatched from ModelChangeMonitor.processBuffered.\n         * @internal\n         */\n        this.onBufferedModelChanges = new BeEvent();\n        this._openMode = openMode;\n        this.txns = new BriefcaseTxns(this);\n        this._modelsMonitor = new ModelChangeMonitor(this);\n    }\n    /** Open a BriefcaseConnection to a [BriefcaseDb]($backend). */\n    static async openFile(briefcaseProps) {\n        const iModelProps = await IpcApp.appFunctionIpc.openBriefcase(briefcaseProps);\n        const connection = new this({ ...briefcaseProps, ...iModelProps }, briefcaseProps.readonly ? OpenMode.Readonly : OpenMode.ReadWrite);\n        IModelConnection.onOpen.raiseEvent(connection);\n        return connection;\n    }\n    /** Open a BriefcaseConnection to a [StandaloneDb]($backend)\n     * @note StandaloneDbs, by definition, may not push or pull changes. Attempting to do so will throw exceptions.\n     */\n    static async openStandalone(filePath, openMode = OpenMode.ReadWrite, opts) {\n        const openResponse = await IpcApp.appFunctionIpc.openStandalone(filePath, openMode, opts);\n        const connection = new this(openResponse, openMode);\n        IModelConnection.onOpen.raiseEvent(connection);\n        return connection;\n    }\n    /** Returns `true` if [[close]] has already been called. */\n    get isClosed() { return this._isClosed === true; }\n    /**\n     * Close this BriefcaseConnection.\n     * @note make sure to call [[saveChanges]] before calling this method. Unsaved local changes are abandoned.\n     */\n    async close() {\n        if (this.isClosed)\n            return;\n        await this._modelsMonitor.close();\n        this.beforeClose();\n        this.txns.dispose();\n        this._isClosed = true;\n        await IpcApp.appFunctionIpc.closeIModel(this._fileKey);\n    }\n    requireTimeline() {\n        if (this.iTwinId === Guid.empty)\n            throw new IModelError(IModelStatus.WrongIModel, \"iModel has no timeline\");\n    }\n    /** Query if there are any pending Txns in this briefcase that are waiting to be pushed. */\n    async hasPendingTxns() {\n        return this.txns.hasPendingTxns();\n    }\n    /** Commit pending changes to this briefcase.\n     * @param description Optional description of the changes.\n     */\n    async saveChanges(description) {\n        await IpcApp.appFunctionIpc.saveChanges(this.key, description);\n    }\n    /** Pull (and potentially merge if there are local changes) up to a specified changeset from iModelHub into this briefcase\n     * @param toIndex The changeset index to pull changes to. If `undefined`, pull all changes.\n     * @param options Options for pulling changes.\n     * @see [[BriefcaseTxns.onChangesPulled]] for the event dispatched after changes are pulled.\n     */\n    async pullChanges(toIndex, options) {\n        const removeListeners = [];\n        // eslint-disable-next-line deprecation/deprecation\n        const shouldReportProgress = !!options?.progressCallback || !!options?.downloadProgressCallback;\n        if (shouldReportProgress) {\n            const handleProgress = (_evt, data) => {\n                // eslint-disable-next-line deprecation/deprecation\n                options?.progressCallback?.(data);\n                options?.downloadProgressCallback?.(data);\n            };\n            const removeProgressListener = IpcApp.addListener(getPullChangesIpcChannel(this.iModelId), handleProgress);\n            removeListeners.push(removeProgressListener);\n        }\n        if (options?.abortSignal) {\n            const abort = () => void IpcApp.appFunctionIpc.cancelPullChangesRequest(this.key);\n            options?.abortSignal.addEventListener(\"abort\", abort);\n            removeListeners.push(() => options?.abortSignal?.removeEventListener(\"abort\", abort));\n        }\n        this.requireTimeline();\n        const ipcAppOptions = {\n            reportProgress: shouldReportProgress,\n            progressInterval: options?.progressInterval,\n            enableCancellation: !!options?.abortSignal,\n        };\n        try {\n            this.changeset = await IpcApp.appFunctionIpc.pullChanges(this.key, toIndex, ipcAppOptions);\n        }\n        finally {\n            removeListeners.forEach((remove) => remove());\n        }\n    }\n    /** Create a changeset from local Txns and push to iModelHub. On success, clear Txn table.\n     * @param description The description for the changeset\n     * @returns the changesetId of the pushed changes\n     * @see [[BriefcaseTxns.onChangesPushed]] for the event dispatched after changes are pushed.\n     */\n    async pushChanges(description) {\n        this.requireTimeline();\n        return IpcApp.appFunctionIpc.pushChanges(this.key, description);\n    }\n    /** The current graphical editing scope, if one is in progress.\n     * @see [[enterEditingScope]] to begin graphical editing.\n     */\n    get editingScope() {\n        return this._modelsMonitor.editingScope;\n    }\n    /** Return whether graphical editing is supported for this briefcase. It is not supported if the briefcase is read-only, or the briefcase contains a version of\n     * the BisCore ECSchema older than v0.1.11.\n     * @see [[enterEditingScope]] to enable graphical editing.\n     */\n    async supportsGraphicalEditing() {\n        return IpcApp.appFunctionIpc.isGraphicalEditingSupported(this.key);\n    }\n    /** Begin a new graphical editing scope.\n     * @throws Error if an editing scope already exists or one could not be created.\n     * @see [[GraphicalEditingScope.exit]] to exit the scope.\n     * @see [[supportsGraphicalEditing]] to determine whether this method should be expected to succeed.\n     * @see [[editingScope]] to obtain the current editing scope, if one is in progress.\n     */\n    async enterEditingScope() {\n        return this._modelsMonitor.enterEditingScope();\n    }\n}\n//# sourceMappingURL=BriefcaseConnection.js.map",
      "start": 1693508118460,
      "end": 1693508118967,
      "sourcemaps": null
    }
  ]
}
