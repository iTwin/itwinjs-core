{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/glsl/Fragment.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { SourceBuilder } from \"../ShaderBuilder\";\nimport { encodeDepthRgb } from \"./Decode\";\nimport { addRenderPass } from \"./RenderPass\";\n/** @internal */\nexport function addWindowToTexCoords(frag) {\n    const windowCoordsToTexCoords = `\\nvec2 windowCoordsToTexCoords(vec2 wc) { return wc * u_invScreenSize; }\\n`;\n    frag.addFunction(windowCoordsToTexCoords);\n    frag.addUniform(\"u_invScreenSize\", 3 /* VariableType.Vec2 */, (prog) => {\n        prog.addProgramUniform(\"u_invScreenSize\", (uniform, params) => {\n            params.target.uniforms.viewRect.bindInverseDimensions(uniform);\n        });\n    });\n}\n/** @internal */\nexport function addWhiteOnWhiteReversal(frag) {\n    frag.addUniform(\"u_reverseWhiteOnWhite\", 0 /* VariableType.Boolean */, (prog) => {\n        prog.addGraphicUniform(\"u_reverseWhiteOnWhite\", (uniform, params) => {\n            const wantWoW = params.target.uniforms.style.wantWoWReversal;\n            const doReversal = (wantWoW && params.geometry.wantWoWReversal(params.programParams)) ? 1 : 0;\n            uniform.setUniform1i(doReversal);\n        });\n    });\n    frag.set(9 /* FragmentShaderComponent.ReverseWhiteOnWhite */, reverseWhiteOnWhite);\n}\nconst reverseWhiteOnWhite = `\r\n  const vec3 white = vec3(1.0);\r\n  const vec3 epsilon = vec3(0.0001);\r\n  vec3 color = baseColor.rgb;\r\n  vec3 delta = (color + epsilon) - white;\r\n  vec4 wowColor = vec4(baseColor.rgb * vec3(float(delta.x <= 0.0 || delta.y <= 0.0 || delta.z <= 0.0)), baseColor.a); // set to black if almost white\r\n  return u_reverseWhiteOnWhite ? wowColor : baseColor;\r\n`;\nconst multiplyAlpha = `\r\n  if (u_renderPass >= kRenderPass_OpaqueLinear && u_renderPass <= kRenderPass_OpaqueGeneral)\r\n    baseColor.a = 1.0;\r\n  else\r\n    baseColor = vec4(baseColor.rgb * baseColor.a, baseColor.a);\r\n`;\nconst computePickBufferOutputs = `${multiplyAlpha}\r\n  vec4 output0 = baseColor;\r\n\r\n  // Fix interpolation errors despite all vertices sending exact same feature_id...\r\n  ivec4 feature_id_i = ivec4(feature_id * 255.0 + 0.5);\r\n  vec4 output1 = vec4(feature_id_i) / 255.0;\r\n  float linearDepth = computeLinearDepth(v_eyeSpace.z);\r\n  vec4 output2 = vec4(renderOrder * 0.0625, encodeDepthRgb(linearDepth)); // near=1, far=0\r\n`;\nconst computeAltPickBufferOutputs = `${multiplyAlpha}\r\n  vec4 output0 = baseColor;\r\n  vec4 output1 = vec4(0.0);\r\n  vec4 output2 = vec4(0.0);\r\n`;\nconst assignPickBufferOutputsMRT = `\r\n  FragColor0 = output0;\r\n  FragColor1 = output1;\r\n  FragColor2 = output2;\r\n`;\nconst reassignFeatureId = \"  output1 = overrideFeatureId(output1);\";\n/** @internal */\nexport function addPickBufferOutputs(frag) {\n    frag.addFunction(encodeDepthRgb);\n    frag.addFunction(computeLinearDepth);\n    const prelude = new SourceBuilder();\n    const overrideOrder = frag.get(20 /* FragmentShaderComponent.OverrideRenderOrder */);\n    if (overrideOrder) {\n        frag.addFunction(\"float overrideRenderOrder(float currentOrder)\", overrideOrder);\n        prelude.addline(\"  float renderOrder = overrideRenderOrder(u_renderOrder);\");\n    }\n    else {\n        prelude.addline(\"  float renderOrder = u_renderOrder;\");\n    }\n    prelude.add(computePickBufferOutputs);\n    const overrideColor = frag.get(19 /* FragmentShaderComponent.OverrideColor */);\n    if (undefined !== overrideColor) {\n        frag.addFunction(\"vec4 overrideColor(vec4 currentColor)\", overrideColor);\n        prelude.addline(\"  output0 = overrideColor(output0);\");\n    }\n    const overrideFeatureId = frag.get(17 /* FragmentShaderComponent.OverrideFeatureId */);\n    if (undefined !== overrideFeatureId) {\n        frag.addFunction(\"vec4 overrideFeatureId(vec4 currentId)\", overrideFeatureId);\n        prelude.addline(reassignFeatureId);\n    }\n    addRenderPass(frag);\n    frag.addDrawBuffersExtension(3);\n    frag.set(16 /* FragmentShaderComponent.AssignFragData */, prelude.source + assignPickBufferOutputsMRT);\n}\n/** @internal */\nexport function addAltPickBufferOutputs(frag) {\n    const prelude = new SourceBuilder();\n    prelude.add(computeAltPickBufferOutputs);\n    const overrideColor = frag.get(19 /* FragmentShaderComponent.OverrideColor */);\n    if (undefined !== overrideColor) {\n        frag.addFunction(\"vec4 overrideColor(vec4 currentColor)\", overrideColor);\n        prelude.addline(\"  output0 = overrideColor(output0);\");\n    }\n    addRenderPass(frag);\n    frag.addDrawBuffersExtension(3);\n    frag.set(16 /* FragmentShaderComponent.AssignFragData */, prelude.source + assignPickBufferOutputsMRT);\n}\n/** @internal */\nexport function addFragColorWithPreMultipliedAlpha(frag) {\n    addRenderPass(frag);\n    const overrideColor = frag.get(19 /* FragmentShaderComponent.OverrideColor */);\n    if (undefined === overrideColor) {\n        frag.set(16 /* FragmentShaderComponent.AssignFragData */, assignFragColorWithPreMultipliedAlpha);\n    }\n    else {\n        frag.addFunction(\"vec4 overrideColor(vec4 currentColor)\", overrideColor);\n        frag.set(16 /* FragmentShaderComponent.AssignFragData */, overrideAndAssignFragColorWithPreMultipliedAlpha);\n    }\n}\n/** @internal */\nexport const assignFragColor = \"FragColor = baseColor;\";\nconst assignFragColorWithPreMultipliedAlpha = `${multiplyAlpha}\r\n  FragColor = baseColor;\r\n`;\nconst overrideAndAssignFragColorWithPreMultipliedAlpha = `${multiplyAlpha}\r\n  vec4 fragColor = overrideColor(baseColor);\r\n  FragColor = fragColor;\r\n`;\n/** @internal */\nexport const computeLinearDepth = `\r\nfloat computeLinearDepth(float eyeSpaceZ) {\r\n  float eyeZ = -eyeSpaceZ;\r\n  float near = u_frustum.x, far = u_frustum.y;\r\n  float depthRange = far - near;\r\n  float linearDepth = (eyeZ - near) / depthRange;\r\n  return 1.0 - linearDepth;\r\n}\r\n`;\n//# sourceMappingURL=Fragment.js.map",
      "start": 1693508125887,
      "end": 1693508125988,
      "sourcemaps": null
    }
  ]
}
