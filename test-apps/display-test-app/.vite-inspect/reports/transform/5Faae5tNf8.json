{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/ViewContext.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Rendering\n */\nimport { assert } from \"@itwin/core-bentley\";\nimport { FrustumPlanes } from \"@itwin/core-common\";\nimport { DecorationsCache } from \"./DecorationsCache\";\nimport { IModelApp } from \"./IModelApp\";\nimport { GraphicType } from \"./render/GraphicBuilder\";\nimport { Scene } from \"./render/Scene\";\nimport { TileGraphicType, TileLoadStatus } from \"./tile/internal\";\nimport { ELEMENT_MARKED_FOR_REMOVAL } from \"./Viewport\";\n/** Provides context for producing [[RenderGraphic]]s for drawing within a [[Viewport]].\n * @public\n * @extensions\n */\nexport class RenderContext {\n    constructor(vp, frustum) {\n        this._viewport = vp;\n        this.viewFlags = vp.viewFlags;\n        this.frustum = frustum ? frustum : vp.getFrustum();\n        this.frustumPlanes = FrustumPlanes.fromFrustum(this.frustum);\n    }\n    /** Given a point in world coordinates, determine approximately how many pixels it occupies on screen based on this context's frustum. */\n    getPixelSizeAtPoint(inPoint) {\n        return this.viewport.viewingSpace.getPixelSizeAtPoint(inPoint);\n    }\n    /** The [[Viewport]] associated with this context. */\n    get viewport() {\n        return this._viewport;\n    }\n    /** The [[RenderSystem]] being used to produce graphics for this context. */\n    get renderSystem() {\n        return this.target.renderSystem;\n    }\n    /** @internal */\n    get target() { return this.viewport.target; }\n    /** @internal */\n    _createGraphicBuilder(options) {\n        return this.target.createGraphicBuilder({ ...options, viewport: this.viewport });\n    }\n    /** Create a builder for creating a [[GraphicType.Scene]] [[RenderGraphic]] for rendering within this context's [[Viewport]].\n     * @param transform the local-to-world transform in which the builder's geometry is to be defined.\n     * @returns A builder for creating a [[GraphicType.Scene]] [[RenderGraphic]] for rendering within this context's [[Viewport]].\n     */\n    createSceneGraphicBuilder(transform) {\n        return this._createGraphicBuilder({ type: GraphicType.Scene, placement: transform });\n    }\n    /** Create a graphic from a [[GraphicBranch]]. */\n    createGraphicBranch(branch, location, opts) {\n        return this.target.renderSystem.createGraphicBranch(branch, location, opts);\n    }\n    /** Create a [[RenderGraphic]] which groups a set of graphics into a node in a scene graph, applying to each a transform and optional clip volume and symbology overrides.\n     * @param branch Contains the group of graphics and the symbology overrides.\n     * @param location the local-to-world transform applied to the grouped graphics.\n     * @returns A RenderGraphic suitable for drawing the scene graph node within this context's [[Viewport]].\n     * @see [[RenderSystem.createBranch]]\n     */\n    createBranch(branch, location) { return this.createGraphicBranch(branch, location); }\n    /** Given the size of a logical pixel in meters, convert it to the size of a physical pixel in meters, if [[RenderSystem.dpiAwareLOD]] is `true`.\n     * Used when computing LOD for graphics.\n     * @internal\n     */\n    adjustPixelSizeForLOD(cssPixelSize) {\n        return this.viewport.target.adjustPixelSizeForLOD(cssPixelSize);\n    }\n}\n/** Provides context for an [[InteractiveTool]] to display decorations representing its current state.\n * @see [[InteractiveTool.onDynamicFrame]]\n * @public\n */\nexport class DynamicsContext extends RenderContext {\n    /** Add a graphic to the list of dynamic graphics to be drawn in this context's [[Viewport]]. */\n    addGraphic(graphic) {\n        if (undefined === this._dynamics)\n            this._dynamics = [];\n        this._dynamics.push(graphic);\n    }\n    /** @internal */\n    changeDynamics() {\n        this.viewport.changeDynamics(this._dynamics);\n    }\n    /** Create a builder for producing a [[RenderGraphic]] appropriate for rendering within this context's [[Viewport]].\n     * @param options Options describing how to create the builder.\n     * @returns A builder that produces a [[RenderGraphic]].\n     */\n    createGraphic(options) {\n        return this._createGraphicBuilder(options);\n    }\n}\n/** Provides context for a [[ViewportDecorator]] to add [[Decorations]] to be rendered within a [[Viewport]].\n * @public\n * @extensions\n */\nexport class DecorateContext extends RenderContext {\n    /** The [[ScreenViewport]] in which this context's [[Decorations]] will be drawn. */\n    get viewport() {\n        return super.viewport;\n    }\n    /** @internal */\n    constructor(vp, decorations, cache) {\n        super(vp);\n        this._decorations = decorations;\n        this._cache = cache;\n    }\n    /** Create a new DecorateContext.\n     * @param args Describes the inputs to the context.\n     * @note Typically the [[ScreenViewport]] takes care of creating the context for you.\n     * @public\n     */\n    static create(args) {\n        return new DecorateContext(args.viewport, args.output, args.cache ?? new DecorationsCache());\n    }\n    /** Create a builder for creating a [[RenderGraphic]] of the specified type appropriate for rendering within this context's [[Viewport]].\n     * @param type The type of builder to create.\n     * @param transform the local-to-world transform in which the builder's geometry is to be defined.\n     * @param id If the decoration is to be pickable, a unique identifier to associate with the resultant [[RenderGraphic]].\n     * @returns A builder for creating a [[RenderGraphic]] of the specified type appropriate for rendering within this context's [[Viewport]].\n     * @see [[IModelConnection.transientIds]] for obtaining an ID for a pickable decoration.\n     * @see [[createGraphic]] for more options.\n     */\n    createGraphicBuilder(type, transform, id) {\n        return this.createGraphic({ type, placement: transform, pickable: undefined !== id ? { id } : undefined });\n    }\n    /** Create a builder for producing a [[RenderGraphic]] appropriate for rendering within this context's [[Viewport]].\n     * @param options Options describing how to create the builder.\n     * @returns A builder that produces a [[RenderGraphic]].\n     */\n    createGraphic(options) {\n        return this._createGraphicBuilder(options);\n    }\n    /** @internal */\n    addFromDecorator(decorator) {\n        assert(undefined === this._curCacheableDecorator);\n        try {\n            if (decorator.useCachedDecorations) {\n                const cached = this._cache.get(decorator);\n                if (cached) {\n                    this.restoreCache(cached);\n                    return;\n                }\n                this._curCacheableDecorator = decorator;\n            }\n            decorator.decorate(this);\n        }\n        finally {\n            this._curCacheableDecorator = undefined;\n        }\n    }\n    /** Restores decorations onto this context from the specified array of cached decorations. */\n    restoreCache(cachedDecorations) {\n        cachedDecorations.forEach((cachedDecoration) => {\n            switch (cachedDecoration.type) {\n                case \"graphic\":\n                    this.addDecoration(cachedDecoration.graphicType, cachedDecoration.graphicOwner);\n                    break;\n                case \"canvas\":\n                    this.addCanvasDecoration(cachedDecoration.canvasDecoration, cachedDecoration.atFront);\n                    break;\n                case \"html\":\n                    this.addHtmlDecoration(cachedDecoration.htmlElement);\n                    break;\n            }\n        });\n    }\n    _appendToCache(decoration) {\n        assert(undefined !== this._curCacheableDecorator);\n        this._cache.add(this._curCacheableDecorator, decoration);\n    }\n    /** Calls [[GraphicBuilder.finish]] on the supplied builder to obtain a [[RenderGraphic]], then adds the graphic to the appropriate list of\n     * [[Decorations]].\n     * @param builder The builder from which to extract the graphic.\n     * @note The builder should not be used after calling this method.\n     */\n    addDecorationFromBuilder(builder) {\n        this.addDecoration(builder.type, builder.finish());\n    }\n    /** Adds a graphic to the set of [[Decorations]] to be drawn in this context's [[ScreenViewport]].\n     * @param The type of the graphic, which determines to which list of decorations it is added.\n     * @param decoration The decoration graphic to add.\n     * @note The type must match the type with which the [[RenderGraphic]]'s [[GraphicBuilder]] was constructed.\n     * @see [[DecorateContext.addDecorationFromBuilder]] for a more convenient API.\n     */\n    addDecoration(type, decoration) {\n        if (this._curCacheableDecorator) {\n            const graphicOwner = this.target.renderSystem.createGraphicOwner(decoration);\n            this._appendToCache({ type: \"graphic\", graphicOwner, graphicType: type });\n            decoration = graphicOwner;\n        }\n        switch (type) {\n            case GraphicType.Scene:\n                if (undefined === this._decorations.normal)\n                    this._decorations.normal = [];\n                this._decorations.normal.push(decoration);\n                break;\n            case GraphicType.WorldDecoration:\n                if (!this._decorations.world)\n                    this._decorations.world = [];\n                this._decorations.world.push(decoration);\n                break;\n            case GraphicType.WorldOverlay:\n                if (!this._decorations.worldOverlay)\n                    this._decorations.worldOverlay = [];\n                this._decorations.worldOverlay.push(decoration);\n                break;\n            case GraphicType.ViewOverlay:\n                if (!this._decorations.viewOverlay)\n                    this._decorations.viewOverlay = [];\n                this._decorations.viewOverlay.push(decoration);\n                break;\n            case GraphicType.ViewBackground:\n                this.setViewBackground(decoration);\n                break;\n        }\n    }\n    /** Add a [[CanvasDecoration]] to be drawn in this context's [[ScreenViewport]]. */\n    addCanvasDecoration(decoration, atFront = false) {\n        if (this._curCacheableDecorator)\n            this._appendToCache({ type: \"canvas\", canvasDecoration: decoration, atFront });\n        if (undefined === this._decorations.canvasDecorations)\n            this._decorations.canvasDecorations = [];\n        const list = this._decorations.canvasDecorations;\n        if (0 === list.length || true === atFront)\n            list.push(decoration);\n        else\n            list.unshift(decoration);\n    }\n    /** Add an HTMLElement to be drawn as a decoration in this context's [[ScreenViewport]]. */\n    addHtmlDecoration(decoration) {\n        if (this._curCacheableDecorator)\n            this._appendToCache({ type: \"html\", htmlElement: decoration });\n        // an element decoration being added might already be on the decorationDiv, just marked for removal\n        if (decoration[ELEMENT_MARKED_FOR_REMOVAL]) {\n            decoration[ELEMENT_MARKED_FOR_REMOVAL] = false;\n        }\n        else if (decoration.parentElement !== this.viewport.decorationDiv) {\n            this.viewport.decorationDiv.appendChild(decoration);\n        }\n    }\n    /** @internal */\n    drawStandardGrid(gridOrigin, rMatrix, spacing, gridsPerRef, _isoGrid = false, _fixedRepetitions) {\n        const vp = this.viewport;\n        if (vp.viewingGlobe)\n            return;\n        const color = vp.getContrastToBackgroundColor();\n        const planarGrid = this.viewport.target.renderSystem.createPlanarGrid(vp.getFrustum(), { origin: gridOrigin, rMatrix, spacing, gridsPerRef, color });\n        if (planarGrid) {\n            this.addDecoration(GraphicType.WorldDecoration, planarGrid);\n        }\n    }\n    /** Display skyBox graphic that encompasses entire scene and rotates with camera.\n     * @see [[RenderSystem.createSkyBox]].\n     */\n    setSkyBox(graphic) {\n        this._decorations.skyBox = graphic;\n    }\n    /** Set the graphic to be displayed behind all other geometry as the background of this context's [[ScreenViewport]]. */\n    setViewBackground(graphic) {\n        this._decorations.viewBackground = graphic;\n    }\n}\n/** Context used to create the scene to be drawn in a [[Viewport]]. The scene consists of a set of [[RenderGraphic]]s produced by the\n * [[TileTree]]s visible within the viewport. Creating the scene may result in the enqueueing of requests for [[Tile]] content which\n * should be displayed in the viewport but are not yet loaded.\n * @public\n */\nexport class SceneContext extends RenderContext {\n    /** @internal */\n    markChildrenLoading() {\n        this._missingChildTiles = true;\n    }\n    /** @internal */\n    get hasMissingTiles() {\n        return this._missingChildTiles || this.missingTiles.size > 0;\n    }\n    constructor(vp, frustum) {\n        super(vp, frustum);\n        this._missingChildTiles = false;\n        /** The graphics comprising the scene. */\n        this.scene = new Scene();\n        /** @internal */\n        this.missingTiles = new Set();\n        this._graphicType = TileGraphicType.Scene;\n    }\n    /** The viewed volume containing the scene. */\n    get viewingSpace() {\n        return undefined !== this._viewingSpace ? this._viewingSpace : this.viewport.viewingSpace;\n    }\n    /** @internal */\n    get graphicType() { return this._graphicType; }\n    /** Add the specified graphic to the scene. */\n    outputGraphic(graphic) {\n        switch (this._graphicType) {\n            case TileGraphicType.BackgroundMap:\n                this.backgroundGraphics.push(graphic);\n                break;\n            case TileGraphicType.Overlay:\n                this.overlayGraphics.push(graphic);\n                break;\n            default:\n                this.graphics.push(graphic);\n                break;\n        }\n    }\n    /** Indicate that the specified tile is desired for the scene but is not yet ready. A request to load its contents will later be enqueued. */\n    insertMissingTile(tile) {\n        switch (tile.loadStatus) {\n            case TileLoadStatus.NotLoaded:\n            case TileLoadStatus.Queued:\n            case TileLoadStatus.Loading:\n                this.missingTiles.add(tile);\n                break;\n        }\n    }\n    /** @internal */\n    requestMissingTiles() {\n        IModelApp.tileAdmin.requestTiles(this.viewport, this.missingTiles);\n    }\n    /** @internal */\n    addPlanarClassifier(classifiedModelId, classifierTree, planarClipMask) {\n        // Target may have the classifier from a previous frame; if not we must create one.\n        let classifier = this.viewport.target.getPlanarClassifier(classifiedModelId);\n        if (undefined === classifier)\n            classifier = this.viewport.target.createPlanarClassifier(classifierTree?.activeClassifier);\n        // Either way, we need to collect the graphics to draw for this frame, and record that we did so.\n        if (undefined !== classifier) {\n            this.planarClassifiers.set(classifiedModelId, classifier);\n            classifier.setSource(classifierTree, planarClipMask);\n        }\n        return classifier;\n    }\n    /** @internal */\n    getPlanarClassifierForModel(modelId) {\n        return this.planarClassifiers.get(modelId);\n    }\n    /** @internal */\n    addBackgroundDrapedModel(drapedTreeRef, _heightRange) {\n        const drapedTree = drapedTreeRef.treeOwner.tileTree;\n        if (undefined === drapedTree)\n            return undefined;\n        const id = drapedTree.modelId;\n        let drape = this.getTextureDrapeForModel(id);\n        if (undefined !== drape)\n            return drape;\n        drape = this.viewport.target.getTextureDrape(id);\n        if (undefined === drape && this.viewport.backgroundDrapeMap)\n            drape = this.viewport.target.renderSystem.createBackgroundMapDrape(drapedTreeRef, this.viewport.backgroundDrapeMap);\n        if (undefined !== drape)\n            this.textureDrapes.set(id, drape);\n        return drape;\n    }\n    /** @internal */\n    getTextureDrapeForModel(modelId) {\n        return this.textureDrapes.get(modelId);\n    }\n    /** @internal */\n    withGraphicType(type, func) {\n        const prevType = this._graphicType;\n        this._graphicType = type;\n        func();\n        this._graphicType = prevType;\n    }\n    /** The graphics in the scene that will be drawn with depth. */\n    get graphics() { return this.scene.foreground; }\n    /** The graphics that will be drawn behind everything else in the scene. */\n    get backgroundGraphics() { return this.scene.background; }\n    /** The graphics that will be drawn in front of everything else in the scene. */\n    get overlayGraphics() { return this.scene.overlay; }\n    /** @internal */\n    get planarClassifiers() { return this.scene.planarClassifiers; }\n    /** @internal */\n    get textureDrapes() { return this.scene.textureDrapes; }\n    /** @internal */\n    setVolumeClassifier(classifier, modelId) {\n        this.scene.volumeClassifier = { classifier, modelId };\n    }\n}\n//# sourceMappingURL=ViewContext.js.map",
      "start": 1693508119557,
      "end": 1693508119680,
      "sourcemaps": null
    }
  ]
}
