{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/Marker.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Views\n */\nimport { assert, Logger, ObservableSet } from \"@itwin/core-bentley\";\nimport { Geometry, Matrix4d, Point2d, Point3d, Range1d, Vector3d } from \"@itwin/core-geometry\";\nimport { FrontendLoggerCategory } from \"./common/FrontendLoggerCategory\";\nimport { imageElementFromUrl } from \"./common/ImageUtil\";\nimport { ViewRect } from \"./common/ViewRect\";\nimport { IModelApp } from \"./IModelApp\";\nfunction getMinScaleViewW(vp) {\n    let zHigh;\n    const origin = vp.view.getCenter();\n    const direction = vp.view.getZVector();\n    direction.scaleInPlace(-1);\n    const corners = vp.view.iModel.projectExtents.corners();\n    const delta = Vector3d.create();\n    for (const corner of corners) {\n        Vector3d.createStartEnd(origin, corner, delta);\n        const projection = delta.dotProduct(direction);\n        if (undefined === zHigh || projection > zHigh)\n            zHigh = projection;\n    }\n    if (undefined === zHigh)\n        return 0.0;\n    origin.plusScaled(direction, zHigh, origin);\n    return vp.worldToView4d(origin).w;\n}\n/** A Marker is a [[CanvasDecoration]], whose position follows a fixed location in world space.\n * Markers draw on top of all scene graphics, and show visual cues about locations of interest.\n * @see [Markers]($docs/learning/frontend/Markers)\n * @public\n * @extensions\n */\nexport class Marker {\n    /** Return true to display [[image]], if present. */\n    get wantImage() { return true; }\n    /** Called when the mouse pointer enters this Marker. */\n    onMouseEnter(ev) {\n        this._isHilited = true;\n        this._hiliteColor = ev.viewport.hilite.color;\n        IModelApp.accuSnap.clear();\n    }\n    /** Called when the mouse pointer leaves this Marker. */\n    onMouseLeave() { this._isHilited = false; }\n    /** Called when the mouse pointer moves over this Marker */\n    onMouseMove(ev) {\n        if (this.title)\n            ev.viewport.openToolTip(this.title, ev.viewPoint, this.tooltipOptions);\n    }\n    /** Determine whether the point is within this Marker.  */\n    pick(pt) { return this.rect.containsPoint(pt); }\n    /** Establish a range of scale factors to increases and decrease the size of this Marker based on its distance from the camera.\n     * @param range The minimum and maximum scale factors to be applied to the size of this Marker based on its distance from the camera. `range.Low` is the scale factor\n     * for Markers at the back of the view frustum and `range.high` is the scale factor at the front of the view frustum.\n     * @note Marker size scaling is only applied in views with the camera enabled. It has no effect on orthographic views.\n     */\n    setScaleFactor(range) {\n        this._scaleFactorRange = Range1d.fromJSON(range);\n        this._scaleFactor = Point2d.create(1, 1);\n    }\n    /** Constructor for Marker\n     * @param worldLocation The location of this Marker in world coordinates.\n     * @param size The size of this Marker in pixels.\n     */\n    constructor(worldLocation, size) {\n        /** Whether this marker is currently enabled. If false, this Marker is not displayed. */\n        this.visible = true;\n        /** Whether this marker is currently hilited or not. */\n        this._isHilited = false;\n        /** The current position for the marker, in view coordinates (pixels). This value will be updated by calls to [[setPosition]]. */\n        this.position = new Point3d();\n        /** The current rectangle for the marker, in view coordinates (pixels). This value will be updated by calls to [[setPosition]]. */\n        this.rect = new ViewRect();\n        this.worldLocation = Point3d.createFrom(worldLocation);\n        this.size = Point2d.createFrom(size);\n    }\n    /** Make a new Marker at the same position and size as this Marker.\n     * The new Marker will share the world location and size, but will be otherwise blank.\n     */\n    static makeFrom(other, ...args) {\n        const out = new this(other.worldLocation, other.size, ...args);\n        out.rect.setFrom(other.rect);\n        out.position.setFrom(other.position);\n        if (other._scaleFactor)\n            out._scaleFactor = Point2d.createFrom(other._scaleFactor);\n        out._scaleFactorRange = other._scaleFactorRange;\n        return out;\n    }\n    /** When a Marker is displayed in its hilited state, this method is called first. If it returns true, no further action is taken.\n     * Otherwise the Marker's normal drawing operations are also called. By default, this method adds a shadowBlur effect and increases\n     * the size of the Marker by 25%.\n     * @return true to stop drawing this Marker\n     */\n    drawHilited(ctx) {\n        ctx.shadowBlur = 30;\n        ctx.shadowColor = this._hiliteColor ? this._hiliteColor.toHexString() : \"white\";\n        ctx.scale(1.25, 1.25);\n        return false;\n    }\n    /** Called during frame rendering to display this Marker onto the supplied context. */\n    drawDecoration(ctx) {\n        if (this._isHilited && this.drawHilited(ctx))\n            return;\n        if (this._scaleFactor !== undefined)\n            ctx.scale(this._scaleFactor.x, this._scaleFactor.y);\n        // first call the \"drawFunc\" if defined. This means it will be below the image and label if they overlap\n        if (undefined !== this.drawFunc)\n            this.drawFunc(ctx);\n        // next draw the image, if defined and desired\n        if (this.wantImage && this.image !== undefined) {\n            const size = this.imageSize ? this.imageSize : this.size;\n            const offset = new Point2d(size.x / 2, size.y / 2);\n            if (this.imageOffset)\n                offset.plus(this.imageOffset, offset);\n            ctx.drawImage(this.image, -offset.x, -offset.y, size.x, size.y);\n        }\n        // lastly, draw the label, if defined. This puts it on top of all other graphics for this Marker.\n        if (this.label !== undefined) {\n            ctx.textAlign = this.labelAlign ? this.labelAlign : \"center\";\n            ctx.textBaseline = this.labelBaseline ? this.labelBaseline : \"middle\";\n            ctx.font = this.labelFont ? this.labelFont : \"14px sans-serif\";\n            ctx.fillStyle = this.labelColor ? this.labelColor : \"white\";\n            ctx.fillText(this.label, this.labelOffset ? -this.labelOffset.x : 0, this.labelOffset ? -this.labelOffset.y : 0, this.labelMaxWidth);\n        }\n    }\n    /** Set the [[image]] for this marker.\n     * @param image Either a [[MarkerImage]] or a Promise for a [[MarkerImage]]. If a Promise is supplied, the [[image]] member is set\n     * when the Promise resolves.\n     */\n    setImage(image) {\n        if (image instanceof Promise) {\n            image.then((resolvedImage) => this.image = resolvedImage).catch((err) => {\n                const target = err.target;\n                const msg = `Could not load image ${target && target.src ? target.src : \"unknown\"}`;\n                Logger.logError(`${FrontendLoggerCategory.Package}.markers`, msg);\n                console.log(msg); // eslint-disable-line no-console\n            });\n        }\n        else\n            this.image = image;\n    }\n    /** Set the image for this Marker from a URL. */\n    setImageUrl(url) { this.setImage(imageElementFromUrl(url)); }\n    /** Set the position (in pixels) for this Marker in the supplied Viewport, based on its worldLocation.\n     * @param markerSet The MarkerSet if this Marker is included in a set.\n     * @return true if the Marker is visible and its new position is inside the Viewport.\n     */\n    setPosition(vp, markerSet) {\n        if (!this.visible) // if we're turned off, skip\n            return false;\n        const pt4 = vp.worldToView4d(this.worldLocation);\n        if (pt4.w > 1.0 || pt4.w < 1.0e-6) // outside of frustum or too close to eye.\n            return false;\n        pt4.realPoint(this.position);\n        if (!vp.viewRect.containsPoint(this.position))\n            return false; // outside this viewport rect\n        const origin = this.position;\n        const sizeX = this.size.x / 2;\n        const sizeY = this.size.y / 2;\n        this.rect.init(origin.x - sizeX, origin.y - sizeY, origin.x + sizeX, origin.y + sizeY);\n        // if there's a scale factor active, calculate it now.\n        if (this._scaleFactor && this._scaleFactorRange) {\n            let scale = 1.0;\n            if (vp.isCameraOn) {\n                const range = this._scaleFactorRange;\n                const minScaleViewW = (undefined !== markerSet ? markerSet.getMinScaleViewW(vp) : getMinScaleViewW(vp));\n                if (minScaleViewW > 0.0)\n                    scale = Geometry.clamp(range.high - (pt4.w / minScaleViewW) * range.length(), .4, 2.0);\n                else\n                    scale = Geometry.clamp(range.low + ((1 - pt4.w) * range.length()), .4, 2.0);\n                this.rect.scaleAboutCenter(scale, scale);\n            }\n            this._scaleFactor.set(scale, scale);\n        }\n        return true;\n    }\n    /** Position the HTMLElement for this Marker relative to the Marker's position in the view.\n     * The default implementation centers the HTMLElement (using its boundingClientRect) on the Marker.\n     * Override this method to provide an alternative positioning approach.\n     */\n    positionHtml() {\n        const html = this.htmlElement;\n        const style = html.style;\n        style.position = \"absolute\";\n        const size = html.getBoundingClientRect(); // Note: only call this *after* setting position = absolute\n        const markerPos = this.position;\n        style.left = `${markerPos.x - (size.width / 2)}px`;\n        style.top = `${markerPos.y - (size.height / 2)}px`;\n    }\n    /** Add this Marker to the supplied DecorateContext. */\n    addMarker(context) {\n        context.addCanvasDecoration(this);\n        if (undefined !== this.htmlElement) {\n            // add this Marker to the DOM\n            context.addHtmlDecoration(this.htmlElement);\n            this.positionHtml(); // always reposition it\n        }\n    }\n    /** Set the position and add this Marker to the supplied DecorateContext, if it's visible.\n     * This method should be called from your implementation of [[Decorator.decorate]]. It will set this Marker's position based on the\n     * Viewport from the context, and add this this Marker to the supplied DecorateContext.\n     * @param context The DecorateContext for the Marker\n     */\n    addDecoration(context) {\n        if (this.setPosition(context.viewport))\n            this.addMarker(context);\n    }\n}\n/** A cluster of one or more Markers that overlap one another in the view. The cluster's screen position is taken from its first entry.\n * Clusters also have a Marker themselves, that represents the whole group. The cluster marker isn't created until all entries have been added.\n * @public\n * @extensions\n */\nexport class Cluster {\n    constructor(markers) {\n        assert(markers.length > 0);\n        this.markers = markers;\n    }\n    get position() {\n        return this.markers[0].position;\n    }\n    /**\n     * Gets the location for the cluster\n     * @returns The average of the cluster markers worldLocation.\n     */\n    getClusterLocation() {\n        const location = Point3d.createZero();\n        if (this.markers.length > 0) {\n            this.markers.forEach((marker) => location.addInPlace(marker.worldLocation));\n            location.scaleInPlace(1 / this.markers.length);\n        }\n        return location;\n    }\n}\n/** A *set* of Markers that are logically related, such that they *cluster* when they overlap one another in screen space.\n * In that case, a *cluster marker* is drawn instead of the overlapping Markers.\n * @public\n * @extensions\n */\nexport class MarkerSet {\n    /** The set of Markers in this MarkerSet. Add your [[Marker]]s into this. */\n    get markers() { return this._markers; }\n    /** Construct a new MarkerSet for a specific ScreenViewport.\n     * @param viewport the ScreenViewport for this MarkerSet. If undefined, use [[IModelApp.viewManager.selectedView]]\n     */\n    constructor(viewport) {\n        /** @internal */\n        this._entries = []; // this is an array that holds either Markers or a cluster of markers.\n        /** @internal */\n        this._worldToViewMap = Matrix4d.createZero();\n        this._markers = new ObservableSet();\n        /** The minimum number of Markers that must overlap before they are clustered. Otherwise they are each drawn individually. Default is 1 (always create a cluster.) */\n        this.minimumClusterSize = 1;\n        /** The radius (in pixels) representing the distance between the screen X,Y positions of two Markers to be clustered. When less than or equal to 0 (the default), the radius is calculated based on the first visible marker imageSize/size. */\n        this.clusterRadius = 0;\n        this._viewport = undefined === viewport ? IModelApp.viewManager.selectedView : viewport;\n        const markDirty = () => this.markDirty();\n        this._markers.onAdded.addListener(markDirty);\n        this._markers.onDeleted.addListener(markDirty);\n        this._markers.onCleared.addListener(markDirty);\n    }\n    /** The ScreenViewport of this MarkerSet. */\n    get viewport() { return this._viewport; }\n    /** Change the ScreenViewport for this MarkerSet.\n     * After this call, the markers from this MarkerSet will only appear in the supplied ScreenViewport.\n     * @beta\n     */\n    changeViewport(viewport) {\n        this._viewport = viewport;\n        this.markDirty();\n    }\n    /** Indicate that this MarkerSet has been changed and is now *dirty*.\n     * This is necessary because [[addDecoration]] does not recreate the set of decoration graphics\n     * if it can detect that the previously-created set remains valid.\n     * The set becomes invalid when the view frustum changes, or the contents of [[markers]] changes.\n     * If some other criterion affecting the graphics changes, invoke this method. This should not be necessary for most use cases.\n     * @public\n     */\n    markDirty() {\n        this._worldToViewMap.setZero();\n    }\n    /** Get weight value limit establishing the distance from camera for the back of view scale factor. */\n    getMinScaleViewW(vp) {\n        if (undefined === this._minScaleViewW)\n            this._minScaleViewW = getMinScaleViewW(vp);\n        return this._minScaleViewW;\n    }\n    /** This method should be called from [[Decorator.decorate]]. It will add this this MarkerSet to the supplied DecorateContext.\n     * This method implements the logic that turns overlapping Markers into a Cluster.\n     * @param context The DecorateContext for the Markers\n     */\n    addDecoration(context) {\n        const vp = context.viewport;\n        if (vp !== this._viewport)\n            return; // not viewport of this MarkerSet, ignore it\n        const entries = this._entries;\n        // Don't recreate the entries array if the view hasn't changed. This is important for performance, but also necessary for hilite of\n        // clusters (otherwise they're recreated continually and never hilited.) */\n        if (!this._worldToViewMap.isAlmostEqual(vp.worldToViewMap.transform0)) {\n            this._worldToViewMap.setFrom(vp.worldToViewMap.transform0);\n            this._minScaleViewW = undefined; // Invalidate current value.\n            entries.length = 0; // start over.\n            let distSquared = this.clusterRadius * this.clusterRadius;\n            // loop through all of the Markers in the MarkerSet.\n            for (const marker of this.markers) {\n                // establish the screen position for this marker. If it's not in view, setPosition returns false\n                if (!marker.setPosition(vp, this))\n                    continue;\n                if (distSquared <= 0) {\n                    const size = marker.imageSize ? marker.imageSize : marker.size;\n                    const dist = Math.max(size.x, size.y) * 1.5;\n                    distSquared = dist * dist;\n                }\n                let added = false;\n                for (let i = 0; i < entries.length; ++i) { // loop through all of the currently visible markers/clusters\n                    const entry = entries[i];\n                    if (marker.position.distanceSquaredXY(entry.position) <= distSquared) {\n                        added = true; // yes, we're going to save it as a Cluster\n                        if (entry instanceof Cluster) { // is the entry already a Cluster?\n                            entry.markers.push(marker); // yes, just add this to the existing cluster\n                        }\n                        else {\n                            entries[i] = new Cluster([entry, marker]); // no, make a new Cluster holding both\n                        }\n                        break; // this Marker has been handled, we can stop looking for overlaps\n                    }\n                }\n                if (!added)\n                    entries.push(marker); // there was no overlap, save this Marker to be drawn\n            }\n        }\n        // we now have an array of Markers and Clusters, add them to context\n        for (const entry of entries) {\n            if (entry instanceof Cluster) { // is this entry a Cluster?\n                if (entry.markers.length <= this.minimumClusterSize) { // yes, does it have more than the minimum number of entries?\n                    entry.markers.forEach((marker) => marker.addMarker(context)); // no, just draw all of its Markers\n                }\n                else {\n                    // yes, get and draw the Marker for this Cluster\n                    if (undefined === entry.clusterMarker) { // have we already created this cluster marker?\n                        const clusterMarker = this.getClusterMarker(entry); // no, get it now.\n                        // set the marker's position as getClusterMarker may not set it.\n                        if (clusterMarker.rect.isNull)\n                            clusterMarker.setPosition(vp, this);\n                        entry.clusterMarker = clusterMarker;\n                    }\n                    entry.clusterMarker.addMarker(context);\n                }\n            }\n            else {\n                entry.addMarker(context); // entry is a non-overlapping Marker, draw it.\n            }\n        }\n    }\n}\n//# sourceMappingURL=Marker.js.map",
      "start": 1693508119390,
      "end": 1693508119558,
      "sourcemaps": null
    }
  ]
}
