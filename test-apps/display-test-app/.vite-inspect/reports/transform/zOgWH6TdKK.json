{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/topology/HalfEdgePriorityQueue.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Topology\n */\nimport { PriorityQueue } from \"@itwin/core-bentley\";\nimport { HalfEdgeGraphOps } from \"./Merging\";\n/**\n * * Combination of a priority queue of HalfEdges with\n * * Additional \"active\" array to carry edges that have been removed from the queue but are still to be\n *    inspected (possibly many times)\n * * The priority queue default sort is Y-then-X lexical sort.\n * * Caller has direct access to the queue and array.\n * * Methods are added here only to do things that involve both the queue and the array.\n * @internal\n */\nexport class HalfEdgePriorityQueueWithPartnerArray {\n    constructor(compare = (a, b) => HalfEdgeGraphOps.compareNodesYXUp(a, b)) {\n        this.priorityQueue = new PriorityQueue(compare);\n        this.activeEdges = [];\n    }\n    /** Read a member from the queue and transfer to the active array. */\n    popQueueToArray() {\n        if (this.priorityQueue.isEmpty)\n            return undefined;\n        const x = this.priorityQueue.pop();\n        this.activeEdges.push(x);\n        return x;\n    }\n    /** Pop the last entry and put it back as replacement for current entry at index i.\n     * * Effectively remove active member at index i\n     * * The array order is changed.\n     * * constant time.\n     */\n    popArrayToArrayIndex(i) {\n        const n = this.activeEdges.length;\n        if (i < n) {\n            const x = this.activeEdges.pop();\n            this.activeEdges[i] = x;\n        }\n    }\n    /**\n     * * Scan the active array.\n     * * remove edges whose top y is below y\n     * * (pack all remaining ones back towards the beginning)\n     */\n    removeArrayMembersWithY1Below(y) {\n        let numKeep = 0;\n        const n = this.activeEdges.length;\n        for (let i = 0; i < n; i++) {\n            const q = this.activeEdges[i];\n            const yB = q.faceSuccessor.y;\n            if (yB >= y) {\n                // copy [i] forward to [target]\n                if (numKeep < i)\n                    this.activeEdges[numKeep] = q;\n                numKeep++;\n            }\n            else {\n                // let it go by !!!\n            }\n        }\n        this.activeEdges.length = numKeep;\n    }\n}\n//# sourceMappingURL=HalfEdgePriorityQueue.js.map",
      "start": 1693508126359,
      "end": 1693508126441,
      "sourcemaps": null
    }
  ]
}
