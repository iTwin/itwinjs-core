{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/hypermodeling/lib/esm/HyperModeling.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module HyperModeling\n */\nimport { assert } from \"@itwin/core-bentley\";\nimport { SectionType } from \"@itwin/core-common\";\nimport { IModelApp, tryImageElementFromUrl, ViewManip } from \"@itwin/core-frontend\";\nimport { registerTools } from \"./Tools\";\nimport { HyperModelingDecorator } from \"./HyperModelingDecorator\";\nimport { SectionMarkerHandler } from \"./SectionMarkerHandler\";\nfunction assertInitialized(maybe) {\n    if (undefined === maybe.resources)\n        throw new Error(\"You must call HyperModeling.initialize before using the hypermodeling package\");\n}\n/** The API entry point for the hypermodeling package. Applications must call [[initialize]] and await the result before using the package.\n * The behavior of the package can be customized via a [[HyperModelingConfig]] supplied to [[initialize]], [[updateConfiguration]], or [[replaceConfiguration]].\n * Hypermodeling mode can be enabled or disabled via [[startOrStop]], which returns a [[HyperModelingDecorator]] when enabling hypermodeling.\n * Consult the package's `README.md` for a description of the available functionality.\n * @public\n */\nclass HyperModeling {\n    static shutdown() {\n        this.resources = undefined;\n        this._markerHandler = undefined;\n        this._markerConfig = {};\n        this._graphicsConfig = {};\n    }\n    /** Returns whether the hypermodeling package is initialized.\n     * @see [[HyperModeling.initialize]] to initialize the package.\n     */\n    static get isInitialized() {\n        return undefined !== this.resources;\n    }\n    /** Invoke this method to initialize the hypermodeling package for use. You *must* await the result before using any of this package's APIs.\n     * Typically an application would invoke this after [IModelApp.startup]($frontend), e.g.,\n     * ```ts\n     *  await IModelApp.startup();\n     *  await HyperModeling.initialize();\n     * ```\n     * Calling this method again after the first initialization behaves the same as calling [[HyperModeling.replaceConfiguration]].\n     * @note The hypermodeling package will be reset to uninitialized after [IModelApp.shutdown]($frontend) is invoked.\n     * @see [[replaceConfiguration]] and [[updateConfiguration]] to modify the configuration after initialization.\n     */\n    static async initialize(config) {\n        if (undefined !== this.resources) {\n            this.replaceConfiguration(config);\n            return;\n        }\n        // clean up if we're being shut down\n        IModelApp.onBeforeShutdown.addListener(() => this.shutdown());\n        const namespace = \"HyperModeling\";\n        await IModelApp.localization.registerNamespace(namespace);\n        const loadImages = [\n            tryImageElementFromUrl(`${IModelApp.publicPath}section-marker.svg`),\n            tryImageElementFromUrl(`${IModelApp.publicPath}detail-marker.svg`),\n            tryImageElementFromUrl(`${IModelApp.publicPath}elevation-marker.svg`),\n            tryImageElementFromUrl(`${IModelApp.publicPath}plan-marker.svg`),\n        ];\n        const images = await Promise.all(loadImages);\n        this.resources = {\n            namespace,\n            markers: {\n                section: { image: images[0], label: IModelApp.localization.getLocalizedString(\"HyperModeling:Message.SectionCallout\") },\n                detail: { image: images[1], label: IModelApp.localization.getLocalizedString(\"HyperModeling:Message.DetailCallout\") },\n                elevation: { image: images[2], label: IModelApp.localization.getLocalizedString(\"HyperModeling:Message.ElevationCallout\") },\n                plan: { image: images[3], label: IModelApp.localization.getLocalizedString(\"HyperModeling:Message.PlanCallout\") },\n            },\n        };\n        registerTools(namespace);\n        this.replaceConfiguration(config);\n    }\n    static async ensureInitialized() {\n        if (undefined === this.resources)\n            await this.initialize();\n        assertInitialized(this);\n    }\n    /** Replaces the current package configuration, overwriting all previous settings. Passing `undefined` resets all settings to defaults.\n     * @see [[HyperModeling.updateConfiguration]] for overriding specific aspects of the configuration.\n     */\n    static replaceConfiguration(config) {\n        config = config ?? {};\n        this._markerHandler = config.markerHandler ?? new SectionMarkerHandler();\n        this._markerConfig = config.markers ? { ...config.markers } : {};\n        this._graphicsConfig = config.graphics ? { ...config.graphics } : {};\n    }\n    /** Overrides specific aspects of the current package configuration. Any field that is not `undefined` will be replaced in the current configuration;\n     * the rest will retain their current values.\n     * @see [[HyperModeling.replaceConfiguration]].\n     */\n    static updateConfiguration(config) {\n        this._markerHandler = config.markerHandler ?? this._markerHandler;\n        if (config.markers) {\n            this._markerConfig = {\n                ignoreModelSelector: config.markers.ignoreModelSelector ?? this._markerConfig.ignoreModelSelector,\n                ignoreCategorySelector: config.markers.ignoreCategorySelector ?? this._markerConfig.ignoreCategorySelector,\n                hiddenSectionTypes: config.markers.hiddenSectionTypes ?? this._markerConfig.hiddenSectionTypes,\n            };\n        }\n        if (config.graphics) {\n            this._graphicsConfig = {\n                ignoreClip: config.graphics.ignoreClip ?? this._graphicsConfig.ignoreClip,\n                debugClipVolumes: config.graphics.debugClipVolumes ?? this._graphicsConfig.debugClipVolumes,\n                hideSectionGraphics: config.graphics.hideSectionGraphics ?? this._graphicsConfig.hideSectionGraphics,\n                hideSheetAnnotations: config.graphics.hideSheetAnnotations ?? this._graphicsConfig.hideSheetAnnotations,\n            };\n            IModelApp.viewManager.invalidateViewportScenes();\n        }\n    }\n    /** The handler that defines interactions with [[SectionMarker]]s.\n     * @see [[initialize]] to override the default handler at package initialization.\n     * @see [[updateConfiguration]] or [[replaceConfiguration]] to change the current handler.\n     */\n    static get markerHandler() {\n        assertInitialized(this);\n        assert(undefined !== this._markerHandler);\n        return this._markerHandler;\n    }\n    /** The current marker display configuration applied to any newly-created [[HyperModelingDecorator]]s.\n     * @see [[initialize]] to override the default configuration at package initialization.\n     * @see [[updateConfiguration]] or [[replaceConfiguration]] to change the current configuration.\n     * @see [[HyperModelingDecorator.replaceConfiguration]] or [[HyperModelingDecorator.updateConfiguration]] to change the configuration for an existing decorator.\n     */\n    static get markerConfig() {\n        return this._markerConfig;\n    }\n    /** This graphics options applied to graphics displayed by all [[HyperModelingDecorator]]s.\n     * @see [[updateConfiguration]] or [[replaceConfiguration]] to change the current configuration.\n     */\n    static get graphicsConfig() {\n        return this._graphicsConfig;\n    }\n    /** Returns true if the specified iModel contains any [SectionDrawingLocation]($backend)s. Hypermodeling is based on section drawing locations,\n     * so if none are present, hypermodeling features are not relevant to the iModel. Attempting to use those features with such an iModel is fine,\n     * but probably not useful.\n     */\n    static async isSupportedForIModel(imodel) {\n        try {\n            const reader = imodel.createQueryReader(\"SELECT ECInstanceId FROM bis.SectionDrawingLocation LIMIT 1\");\n            return await reader.step(); // i.e., are any results are returned?\n        }\n        catch {\n            // An iModel with a version of BisCore older than 1.0.11 will produce an expected \"table not found\" on the SectionDrawingLocation ECClass.\n            return false;\n        }\n    }\n    /** Returns whether hypermodeling is currently enabled for the specified viewport.\n     * @see [[startOrStop]] to enable or disable hypermodeling for a viewport.\n     */\n    static isEnabledForViewport(viewport) {\n        return undefined !== HyperModelingDecorator.getForViewport(viewport);\n    }\n    /** Start or stop hypermodeling mode for the specified viewport.\n     * Enabling hypermodeling registers and returns a [[HyperModelingDecorator]] to display [[SectionMarker]]s within the viewport.\n     * Disabling hypermodeling removes that decorator.\n     * @param viewport The hypermodeling viewport\n     * @param start `true` to enter hypermodeling mode, `false` to exit, or `undefined` to toggle the current mode.\n     * @returns The new decorator is hypermodeling was successfully enabled.\n     * @note Enabling hypermodeling may fail if the viewport is not viewing a spatial model or if the viewport's iModel does not support hypermodeling.\n     * @see [[start]] and [[stop]].\n     * @see [[isSupportedForIModel]].\n     */\n    static async startOrStop(viewport, start) {\n        // Help out the caller since we're async anyway...\n        await this.ensureInitialized();\n        const decorator = HyperModelingDecorator.getForViewport(viewport);\n        if (undefined === start)\n            start = undefined === decorator;\n        if (start) {\n            return this._start(viewport);\n        }\n        else {\n            decorator?.dispose();\n            return undefined;\n        }\n    }\n    /** Start hypermodeling mode for the specified viewport if it is not currently enabled.\n     * If hypermodeling is already enabled for the viewport, the existing decorator is returned; otherwise, a new decorator is created.\n     * @param viewport The viewport for which to enable hypermodeling\n     * @returns The decorator that implements hypermodeling features for the viewport, or `undefined` if hypermodeling could not be enabled.\n     * @note Enabling hypermodeling may fail if the viewport is not viewing a spatial model or if the viewport's iModel does not support hypermodeling.\n     */\n    static async start(viewport) {\n        await this.ensureInitialized();\n        return this._start(viewport);\n    }\n    static async _start(viewport) {\n        assertInitialized(this);\n        if (!viewport.view.isSpatialView())\n            return undefined;\n        let decorator = HyperModelingDecorator.getForViewport(viewport);\n        if (!decorator)\n            decorator = await HyperModelingDecorator.create(viewport, this._markerConfig);\n        if (undefined !== decorator && viewport.view.isCameraOn) {\n            // We want the 2d graphics to align with the 3d geometry. Perspective ruins that.\n            viewport.view.turnCameraOff();\n            ViewManip.fitView(viewport, false, { noSaveInUndo: true });\n            viewport.clearViewUndo();\n        }\n        return decorator;\n    }\n    /** Stop hypermodeling mode for the specified viewport if it is currently enabled. This disposes of the [[HyperModelingDecorator]] associated with the viewport.\n     * @see [[start]] to enable hypermodeling for a viewport.\n     * @see [[startOrStop]] to toggle hypermodeling mode.\n     */\n    static stop(viewport) {\n        const decorator = HyperModelingDecorator.getForViewport(viewport);\n        decorator?.dispose();\n    }\n    /** @internal */\n    static get namespace() {\n        assertInitialized(this);\n        return this.resources.namespace;\n    }\n    /** @internal */\n    static getMarkerData(type) {\n        assertInitialized(this);\n        switch (type) {\n            case SectionType.Plan:\n                return this.resources.markers.plan;\n            case SectionType.Elevation:\n                return this.resources.markers.elevation;\n            case SectionType.Detail:\n                return this.resources.markers.detail;\n            default:\n                return this.resources.markers.section;\n        }\n    }\n}\nHyperModeling._markerConfig = {};\nHyperModeling._graphicsConfig = {};\nexport { HyperModeling };\n//# sourceMappingURL=HyperModeling.js.map",
      "start": 1693508122860,
      "end": 1693508122957,
      "sourcemaps": null
    }
  ]
}
