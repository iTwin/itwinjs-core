{
  "resolvedId": "D:/hub2023A/itwinjs-core/extensions/map-layers-formats/lib/esm/ArcGisFeature/ArcGisSymbologyRenderer.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\nimport { Logger } from \"@itwin/core-bentley\";\n/** @internal */\nconst loggerCategory = \"MapLayersFormats.ArcGISFeature\";\n/** @internal */\nexport class ArcGisSymbologyRenderer {\n    static create(renderer, defaultSymbol) {\n        if (renderer?.type === \"uniqueValue\") {\n            return new ArcGisUniqueValueSymbologyRenderer(renderer, defaultSymbol);\n        }\n        else {\n            return new ArcGisSimpleSymbologyRenderer(renderer, defaultSymbol);\n        }\n    }\n}\n/** @internal */\nexport class ArcGisSimpleSymbologyRenderer extends ArcGisSymbologyRenderer {\n    isAttributeDriven() { return false; }\n    get symbol() { return this._symbol; }\n    get defaultSymbol() { return this._defaultSymbol; }\n    constructor(renderer, defaultSymbol) {\n        super();\n        this.lineWidthScaleFactor = 2; // This is value is empirical, this might need to be adjusted\n        this._defaultSymbol = defaultSymbol;\n        this.renderer = renderer;\n        if (this.renderer?.type === \"simple\") {\n            this._symbol = this.renderer.symbol;\n        }\n        else {\n            this._symbol = defaultSymbol;\n        }\n    }\n    applyFillStyle(context) {\n        if (!context)\n            return;\n        const fillColor = this.getFillColor();\n        if (fillColor) {\n            context.fillStyle = fillColor.toRgbaString();\n        }\n        else {\n            Logger.logTrace(loggerCategory, `Could not apply fill style`);\n        }\n    }\n    getFillColor() {\n        let fillColor;\n        if (this._symbol.type === \"esriSFS\") {\n            const sfs = this._symbol;\n            if (sfs.color) {\n                fillColor = sfs.color;\n            }\n        }\n        return fillColor;\n    }\n    applyStrokeStyle(context) {\n        if (!context)\n            return;\n        // Stroke style can be from SFS's outline style or a SLS's color\n        let sls;\n        if (this._symbol.type === \"esriSFS\") {\n            const sfs = this._symbol;\n            if (sfs.outline && sfs.outline.style === \"esriSLSSolid\") {\n                sls = sfs.outline;\n            }\n        }\n        else if (this._symbol.type === \"esriSLS\") {\n            sls = this._symbol;\n        }\n        if (sls) {\n            if (sls.color)\n                context.strokeStyle = sls.color.toRgbaString();\n            context.lineWidth = sls.width * this.lineWidthScaleFactor;\n        }\n        else {\n            Logger.logTrace(loggerCategory, `Could not apply stroke style`);\n        }\n    }\n    drawPoint(context, ptX, ptY) {\n        if (!context)\n            return;\n        if (this._symbol.type === \"esriPMS\") {\n            const pms = this._symbol;\n            let xOffset = 0, yOffset = 0;\n            if (pms.xoffset)\n                xOffset = pms.xoffset;\n            else if (pms.width)\n                xOffset = pms.width * -0.5; // if no offset center in the middle\n            if (pms.yoffset)\n                yOffset = pms.yoffset;\n            else if (pms.height)\n                yOffset = pms.height * -0.5; // if no offset center in the middle\n            if (pms.width && pms.height) {\n                context.drawImage(pms.image, ptX + xOffset, ptY + yOffset, pms.width, pms.height);\n            }\n            else {\n                context.drawImage(pms.image, ptX + xOffset, ptY + yOffset);\n            }\n            // TODO: marker rotation angle\n        }\n    }\n}\n/** @internal */\nexport class ArcGisUniqueValueSymbologyRenderer extends ArcGisSimpleSymbologyRenderer {\n    isAttributeDriven() { return true; }\n    get rendererFields() {\n        if (this.uvRenderer.field1)\n            return [this.uvRenderer.field1];\n        else\n            return undefined;\n    }\n    constructor(renderer, defaultSymbol) {\n        super(renderer, defaultSymbol);\n        this.uvRenderer = this.renderer;\n        if (this.uvRenderer.defaultSymbol) {\n            this._defaultSymbol = this.uvRenderer.defaultSymbol;\n            this._symbol = this.defaultSymbol;\n        }\n    }\n    setActiveFeatureAttributes(attributes) {\n        this._activeFeatureAttributes = attributes;\n        let newSymbolApplied = false;\n        if (this._activeFeatureAttributes) {\n            if (this.uvRenderer.field1 && Object.keys(this._activeFeatureAttributes).includes(this.uvRenderer.field1)) {\n                const queryValue = this._activeFeatureAttributes[this.uvRenderer.field1];\n                for (const uvi of this.uvRenderer.uniqueValueInfos) {\n                    // Strangely, ArcGIS documentation says 'value' is a string,\n                    // not too sure if a comparison on other types is possible, or its always forced to string properties?\n                    if (uvi.value === queryValue.toString()) {\n                        this._symbol = uvi.symbol;\n                        newSymbolApplied = true;\n                        break;\n                    }\n                }\n            }\n        }\n        // Fallback to default symbology to make sure we render something\n        if (!newSymbolApplied) {\n            this._symbol = this.defaultSymbol;\n        }\n    }\n}\n//# sourceMappingURL=ArcGisSymbologyRenderer.js.map",
      "start": 1693508125118,
      "end": 1693508125186,
      "sourcemaps": null
    }
  ]
}
