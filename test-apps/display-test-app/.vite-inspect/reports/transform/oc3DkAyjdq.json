{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/curve/spiral/TransitionConditionalProperties.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Curve\n */\nimport { Geometry } from \"../../Geometry\";\nimport { Angle } from \"../../geometry3d/Angle\";\nimport { TransitionSpiral3d } from \"./TransitionSpiral3d\";\n// import {} from \"./\";\n/** A true transition spiral is a curve defined by its curvature, with the curvature function symmetric about midpoint.\n * * The symmetry condition creates a relationship among the following 4 quantities:\n * ** curvature0 = curvature (i.e. 1/radius) at start\n * ** curvature1 = curvature (i.e. 1/radius) at end\n * ** sweepRadians = signed turning angle from start to end\n * ** arcLength = length of curve\n * * The relationship is the equation\n * ** `sweepRadians = arcLength * average Curvature = arcLength * 0.5 * (curvature0 + curvature1)`\n * * That is, regardless of any curvature properties other than symmetry, specifying any 3 of the quantities fully determines the remaining one.\n * @public\n */\nexport class TransitionConditionalProperties {\n    /**\n     * capture numeric or undefined values\n     * @param radius0 start radius or undefined\n     * @param radius1 end radius or undefined\n     * @param bearing0 start bearing or undefined\n     * @param bearing1 end bearing or undefined\n     * @param arcLength arc length or undefined\n     */\n    constructor(radius0, radius1, bearing0, bearing1, arcLength) {\n        this.radius0 = radius0;\n        this.radius1 = radius1;\n        this.bearing0 = bearing0;\n        this.bearing1 = bearing1;\n        this.curveLength = arcLength;\n    }\n    /** return the number of defined values among the 5 properties. */\n    numDefinedProperties() {\n        return Geometry.defined01(this.radius0)\n            + Geometry.defined01(this.radius1)\n            + Geometry.defined01(this.bearing0)\n            + Geometry.defined01(this.bearing1)\n            + Geometry.defined01(this.curveLength);\n    }\n    /** clone with all properties (i.e. preserve undefined states) */\n    clone() {\n        return new TransitionConditionalProperties(this.radius0, this.radius1, this.bearing0 === undefined ? undefined : this.bearing0.clone(), this.bearing1 === undefined ? undefined : this.bearing1.clone(), this.curveLength);\n    }\n    /** Return true if all components are defined and agree equationally. */\n    getIsValidCompleteSet() {\n        if (this.curveLength !== undefined && this.bearing0 !== undefined && this.bearing1 !== undefined\n            && this.radius0 !== undefined && this.radius1 !== undefined) {\n            const length1 = TransitionSpiral3d.radiusRadiusSweepRadiansToArcLength(this.radius0, this.radius1, this.bearing1.radians - this.bearing0.radians);\n            return Geometry.isSameCoordinate(this.curveLength, length1);\n        }\n        return false;\n    }\n    /** Examine which properties are defined and compute the (single) undefined.\n     * @returns Return true if the input state had precisely one undefined member.\n     */\n    tryResolveAnySingleUnknown() {\n        if (this.getIsValidCompleteSet())\n            return true;\n        if (this.bearing0 && this.bearing1) {\n            const sweepRadians = this.bearing1.radians - this.bearing0.radians;\n            if (this.curveLength === undefined && this.radius0 !== undefined && this.radius1 !== undefined) {\n                this.curveLength = TransitionSpiral3d.radiusRadiusSweepRadiansToArcLength(this.radius0, this.radius1, sweepRadians);\n                return true;\n            }\n            if (this.curveLength !== undefined && this.radius0 === undefined && this.radius1 !== undefined) {\n                this.radius0 = TransitionSpiral3d.radius1LengthSweepRadiansToRadius0(this.radius1, this.curveLength, sweepRadians);\n                return true;\n            }\n            if (this.curveLength !== undefined && this.radius0 !== undefined && this.radius1 === undefined) {\n                this.radius1 = TransitionSpiral3d.radius0LengthSweepRadiansToRadius1(this.radius0, this.curveLength, sweepRadians);\n                return true;\n            }\n            return false;\n        }\n        // at least one bearing is undefined ...\n        if (this.curveLength === undefined || this.radius0 === undefined || this.radius1 === undefined)\n            return false;\n        if (this.bearing0) { // bearing 1 is undefined\n            this.bearing1 = Angle.createRadians(this.bearing0.radians + TransitionSpiral3d.radiusRadiusLengthToSweepRadians(this.radius0, this.radius1, this.curveLength));\n            return true;\n        }\n        if (this.bearing1) { // bearing 0 is undefined\n            this.bearing0 = Angle.createRadians(this.bearing1.radians - TransitionSpiral3d.radiusRadiusLengthToSweepRadians(this.radius0, this.radius1, this.curveLength));\n            return true;\n        }\n        return false;\n    }\n    almostEqualCoordinate(a, b) {\n        if (a === undefined && b === undefined)\n            return true;\n        if (a !== undefined && b !== undefined)\n            return Geometry.isSameCoordinate(a, b);\n        return false;\n    }\n    almostEqualBearing(a, b) {\n        if (a === undefined && b === undefined)\n            return true;\n        if (a !== undefined && b !== undefined)\n            return a.isAlmostEqualNoPeriodShift(b);\n        return false;\n    }\n    /**\n     * Test if this and other have matching numeric and undefined members.\n     */\n    isAlmostEqual(other) {\n        if (!other)\n            return false;\n        if (!this.almostEqualCoordinate(this.radius0, other.radius0))\n            return false;\n        if (!this.almostEqualCoordinate(this.radius1, other.radius1))\n            return false;\n        if (!this.almostEqualBearing(this.bearing0, other.bearing0))\n            return false;\n        if (!this.almostEqualBearing(this.bearing1, other.bearing1))\n            return false;\n        if (!this.almostEqualCoordinate(this.curveLength, other.curveLength))\n            return false;\n        return true;\n    }\n    /** Apply a NONZERO scale factor to all distances. */\n    applyScaleFactor(a) {\n        if (this.radius0 !== undefined)\n            this.radius0 *= a;\n        if (this.radius1 !== undefined)\n            this.radius1 *= a;\n        if (this.curveLength !== undefined)\n            this.curveLength *= a;\n    }\n    static areAlmostEqual(a, b) {\n        if (a === undefined)\n            return b === undefined;\n        return a.isAlmostEqual(b);\n    }\n}\n//# sourceMappingURL=TransitionConditionalProperties.js.map",
      "start": 1693508125432,
      "end": 1693508125545,
      "sourcemaps": null
    }
  ]
}
