{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/orbitgt/lib/esm/spatial/ecrs/projection/LambertConical1SP.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module OrbitGT\n */\nimport { OperationMethod } from \"../OperationMethod\";\n/**\n * Class LambertConical1SP defines a Lambert Conical Conformal map projection with 1 standard parallel.\n *\n * The 'source' CRS is the geographic CRS.\n * The 'target' CRS is the projected CRS.\n *\n * Based on the following document:\n *\n * Coordinate Conversions and Transformations including Formulas\n * Guidance Note Number 7, part 2\n * Revised August 2006\n * Available at: http://www.epsg.org/\n *\n * Formulas: see 1.4.1.1 -> 1.4.1.4\n *\n * @version 1.0 January 2007\n */\n/** @internal */\nclass LambertConical1SP extends OperationMethod {\n    /**\n     * Create a new projection.\n     * @param parameters the values of the parameters.\n     */\n    constructor(parameters) {\n        super(LambertConical1SP.METHOD_CODE, \"Lambert Conic Conformal (1SP)\", parameters);\n        /* Store the parameters */\n        this._latN = parameters.getValue(8801);\n        this._lonN = parameters.getValue(8802);\n        this._k0 = parameters.getValue(8805);\n        this._fE = parameters.getValue(8806);\n        this._fN = parameters.getValue(8807);\n    }\n    /**\n     * Get the sign of a number.\n     */\n    static sign(v) {\n        return (v < 0.0) ? (-1.0) : (1.0);\n    }\n    /**\n     * Calculate M.\n     */\n    static calcM(e, lat) {\n        return Math.cos(lat) / Math.pow(1.0 - Math.pow(e * Math.sin(lat), 2.0), 0.5);\n    }\n    /**\n     * Calculate T.\n     */\n    static calcT(e, lat) {\n        return Math.tan(Math.PI * 0.25 - lat * 0.5) / Math.pow((1.0 - e * Math.sin(lat)) / (1.0 + e * Math.sin(lat)), e * 0.5);\n    }\n    /**\n     * Calculate R.\n     */\n    static calcR(a, F, t, n, k0) {\n        if (Math.abs(t) < 1.0e-6)\n            return 0.0;\n        return a * F * Math.pow(t, n) * k0;\n    }\n    /**\n     * OperationMethod interface method.\n     * @see OperationMethod#forward\n     */\n    forward(sourceCRS, source, targetCRS, target) {\n        /* Get the parameters */\n        let lon = source.getX();\n        let lat = source.getY();\n        /* Get the ellipsoid parameters */\n        let e = sourceCRS.getEllipsoid().getE();\n        let a = sourceCRS.getEllipsoid().getA();\n        /* Make the calculation */\n        let m0 = LambertConical1SP.calcM(e, this._latN);\n        let t0 = LambertConical1SP.calcT(e, this._latN);\n        let n = Math.sin(this._latN);\n        let F = m0 / (n * Math.pow(t0, n));\n        let r0 = LambertConical1SP.calcR(a, F, t0, n, this._k0);\n        let t = LambertConical1SP.calcT(e, lat);\n        let r = LambertConical1SP.calcR(a, F, t, n, this._k0);\n        let theta = n * (lon - this._lonN);\n        let E = this._fE + r * Math.sin(theta);\n        let N = this._fN + r0 - r * Math.cos(theta);\n        /* Save the position */\n        target.setX(E);\n        target.setY(N);\n        target.setZ(source.getZ()); // Keep the Z value\n    }\n    /**\n     * OperationMethod interface method.\n     * @see OperationMethod#reverse\n     */\n    reverse(sourceCRS, source, targetCRS, target) {\n        /* Get the parameters */\n        let E = target.getX();\n        let N = target.getY();\n        /* Get the ellipsoid parameters */\n        let e = sourceCRS.getEllipsoid().getE();\n        let a = sourceCRS.getEllipsoid().getA();\n        /* Make the calculation */\n        let m0 = LambertConical1SP.calcM(e, this._latN);\n        let t0 = LambertConical1SP.calcT(e, this._latN);\n        let n = Math.sin(this._latN);\n        let F = m0 / (n * Math.pow(t0, n));\n        let r0 = LambertConical1SP.calcR(a, F, t0, n, this._k0);\n        let r_ = LambertConical1SP.sign(n) * Math.pow(Math.pow(E - this._fE, 2.0) + Math.pow(r0 - (N - this._fN), 2.0), 0.5);\n        let t_ = Math.pow(r_ / (a * this._k0 * F), 1.0 / n);\n        let theta_ = Math.atan((E - this._fE) / (r0 - (N - this._fN)));\n        let lat = Math.PI * 0.5 - 2.0 * Math.atan(t_);\n        for (let i = 0; i < 7; i++)\n            lat = Math.PI * 0.5 - 2.0 * Math.atan(t_ * Math.pow((1.0 - e * Math.sin(lat)) / (1.0 + e * Math.sin(lat)), e * 0.5)); // recursive formula\n        let lon = (theta_) / n + this._lonN;\n        /* Save the position */\n        source.setX(lon);\n        source.setY(lat);\n        source.setZ(target.getZ()); // Keep the Z value\n    }\n}\n/** The code of this method */\nLambertConical1SP.METHOD_CODE = 9801;\nexport { LambertConical1SP };\n//# sourceMappingURL=LambertConical1SP.js.map",
      "start": 1693508127370,
      "end": 1693508127417,
      "sourcemaps": null
    }
  ]
}
