{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/glsl/PointCloud.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { assert } from \"@itwin/core-bentley\";\nimport { AttributeMap } from \"../AttributeMap\";\nimport { ProgramBuilder } from \"../ShaderBuilder\";\nimport { addUniformHiliter } from \"./FeatureSymbology\";\nimport { addColorPlanarClassifier, addFeaturePlanarClassifier, addHilitePlanarClassifier } from \"./PlanarClassification\";\nimport { addModelViewProjectionMatrix } from \"./Vertex\";\nimport { addViewportTransformation } from \"./Viewport\";\nimport { addThematicDisplay } from \"./Thematic\";\nimport { addTexture } from \"./Surface\";\nimport { assignFragColor } from \"./Fragment\";\n// Revert components if color format is BGR instead of RGB.\nconst computeColor = `\r\n  return u_pointCloud.y == 1.0 ? vec4(a_color.b, a_color.g, a_color.r, 1.0) : vec4(a_color, 1.0);\r\n`;\nconst computeBaseColor = \"return v_color;\";\n// Round the point unless drawing square points.\nconst roundPointDiscard = `\r\n  if (u_pointCloudSettings.w == 1.0)\r\n    return false;\r\n\r\n  vec2 pointXY = (2.0 * gl_PointCoord - 1.0);\r\n  return dot(pointXY, pointXY) > 1.0;\r\n`;\nconst checkForClassifiedDiscard = \"return baseColor.a == 0.0;\";\nconst computePosition = `\r\n  gl_PointSize = 1.0;\r\n  vec4 pos = MAT_MVP * rawPos;\r\n  if (u_pointCloudSettings.x > 0.0) {\r\n    // Size is specified in pixels.\r\n    gl_PointSize = u_pointCloudSettings.x;\r\n    return pos;\r\n  }\r\n\r\n  // Point size is in meters (voxel size).\r\n  if (pos.w <= 0.0) {\r\n    // Cannot perform perspective divide below.\r\n    return pos;\r\n  }\r\n\r\n  // Convert voxel size in meters into pixel size, then compute pixel size, taking perspective into account.\r\n  mat4 toView = u_viewportTransformation * MAT_MVP;\r\n  float scale = length(toView[0].xyz);\r\n  gl_PointSize = -u_pointCloudSettings.x * clamp(u_pointCloud.x * scale / pos.w, u_pointCloudSettings.y, u_pointCloudSettings.z);\r\n  return pos;\r\n`;\nfunction createBuilder() {\n    const builder = new ProgramBuilder(AttributeMap.findAttributeMap(2 /* TechniqueId.PointCloud */, false));\n    const vert = builder.vert;\n    addViewportTransformation(vert);\n    vert.set(10 /* VertexShaderComponent.ComputePosition */, computePosition);\n    addModelViewProjectionMatrix(vert);\n    builder.frag.set(0 /* FragmentShaderComponent.CheckForEarlyDiscard */, roundPointDiscard);\n    // Uniforms based on the PointCloudDisplaySettings.\n    builder.addUniform(\"u_pointCloudSettings\", 5 /* VariableType.Vec4 */, (prog) => {\n        prog.addGraphicUniform(\"u_pointCloudSettings\", (uniform, params) => {\n            params.target.uniforms.realityModel.pointCloud.bind(uniform);\n        });\n    });\n    // Uniforms based on the PointCloudGeometry.\n    builder.vert.addUniform(\"u_pointCloud\", 3 /* VariableType.Vec2 */, (prog) => {\n        prog.addGraphicUniform(\"u_pointCloud\", (uniform, params) => {\n            assert(params.geometry.asPointCloud !== undefined);\n            scratchPointCloud[0] = params.geometry.asPointCloud.voxelSize;\n            scratchPointCloud[1] = params.geometry.asPointCloud.colorIsBgr ? 1 : 0;\n            uniform.setUniform2fv(scratchPointCloud);\n        });\n    });\n    return builder;\n}\nconst scratchPointCloud = new Float32Array([0, 0]);\n/** @internal */\nexport function createPointCloudBuilder(classified, featureMode, thematic) {\n    const builder = createBuilder();\n    builder.addVarying(\"v_color\", 5 /* VariableType.Vec4 */);\n    builder.vert.set(5 /* VertexShaderComponent.ComputeBaseColor */, computeColor);\n    builder.frag.set(1 /* FragmentShaderComponent.ComputeBaseColor */, computeBaseColor);\n    if (classified) {\n        addColorPlanarClassifier(builder, false, thematic);\n        builder.frag.set(4 /* FragmentShaderComponent.CheckForDiscard */, checkForClassifiedDiscard);\n        if (0 /* FeatureMode.None */ !== featureMode)\n            addFeaturePlanarClassifier(builder);\n    }\n    if (1 /* IsThematic.Yes */ === thematic) {\n        addThematicDisplay(builder, true);\n        addTexture(builder, 0 /* IsAnimated.No */, 1 /* IsThematic.Yes */, true, false);\n    }\n    return builder;\n}\n/** @internal */\nexport function createPointCloudHiliter(classified) {\n    const builder = createBuilder();\n    if (classified) {\n        addHilitePlanarClassifier(builder, false);\n        builder.frag.set(16 /* FragmentShaderComponent.AssignFragData */, assignFragColor);\n    }\n    else {\n        addUniformHiliter(builder);\n    }\n    return builder;\n}\n//# sourceMappingURL=PointCloud.js.map",
      "start": 1693508125907,
      "end": 1693508126008,
      "sourcemaps": null
    }
  ]
}
