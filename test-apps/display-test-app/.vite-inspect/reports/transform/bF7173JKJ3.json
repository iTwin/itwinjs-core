{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/curve/Query/PlanarSubdivision.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\nimport { Geometry } from \"../../Geometry\";\nimport { HalfEdgeGraph } from \"../../topology/Graph\";\nimport { HalfEdgeGraphSearch } from \"../../topology/HalfEdgeGraphSearch\";\nimport { HalfEdgeGraphMerge } from \"../../topology/Merging\";\nimport { Arc3d } from \"../Arc3d\";\nimport { CurveLocationDetail, CurveLocationDetailPair } from \"../CurveLocationDetail\";\nimport { LineSegment3d } from \"../LineSegment3d\";\nimport { LineString3d } from \"../LineString3d\";\nimport { Loop, LoopCurveLoopCurve } from \"../Loop\";\nimport { RegionOps } from \"../RegionOps\";\n/** @packageDocumentation\n * @module Curve\n */\nclass MapCurvePrimitiveToCurveLocationDetailPairArray {\n    constructor() {\n        this.primitiveToPair = new Map();\n        // index assigned to this primitive (for debugging)\n        this.primitiveToIndex = new Map();\n        this._numIndexedPrimitives = 0;\n    }\n    assignPrimitiveIndex(primitive) {\n        if (primitive !== undefined) {\n            const index = this.primitiveToIndex.get(primitive);\n            if (index === undefined) {\n                this.primitiveToIndex.set(primitive, this._numIndexedPrimitives++);\n            }\n        }\n    }\n    insertPrimitiveToPair(primitive, pair) {\n        if (primitive) {\n            const priorPairs = this.primitiveToPair.get(primitive);\n            this.assignPrimitiveIndex(primitive);\n            if (!priorPairs) {\n                this.primitiveToPair.set(primitive, [pair]);\n            }\n            else {\n                priorPairs.push(pair);\n            }\n        }\n    }\n    insertPair(pair) {\n        const primitiveA = pair.detailA.curve;\n        if (primitiveA)\n            this.insertPrimitiveToPair(primitiveA, pair);\n        const primitiveB = pair.detailB.curve;\n        if (primitiveB)\n            this.insertPrimitiveToPair(primitiveB, pair);\n    }\n    /** Split closed missing primitives in half and add new intersection pairs */\n    splitAndAppendMissingClosedPrimitives(primitives, tolerance = Geometry.smallMetricDistance) {\n        for (const p of primitives) {\n            let closedCurveSplitCandidate = false;\n            if (p instanceof Arc3d)\n                closedCurveSplitCandidate = p.sweep.isFullCircle;\n            else if (!(p instanceof LineSegment3d) && !(p instanceof LineString3d))\n                closedCurveSplitCandidate = p.startPoint().isAlmostEqualXY(p.endPoint(), tolerance);\n            if (closedCurveSplitCandidate && !this.primitiveToPair.has(p)) {\n                const p0 = p.clonePartialCurve(0.0, 0.5);\n                const p1 = p.clonePartialCurve(0.5, 1.0);\n                if (p0 && p1) {\n                    this.insertPair(CurveLocationDetailPair.createCapture(CurveLocationDetail.createCurveEvaluatedFraction(p0, 0.0), CurveLocationDetail.createCurveEvaluatedFraction(p1, 1.0)));\n                    this.insertPair(CurveLocationDetailPair.createCapture(CurveLocationDetail.createCurveEvaluatedFraction(p0, 1.0), CurveLocationDetail.createCurveEvaluatedFraction(p1, 0.0)));\n                }\n            }\n        }\n    }\n}\n/**\n * @internal\n */\nexport class PlanarSubdivision {\n    /** Create a graph from an array of curves, and an array of the curves' precomputed intersections. Z-coordinates are ignored. */\n    static assembleHalfEdgeGraph(primitives, allPairs, mergeTolerance = Geometry.smallMetricDistance) {\n        const detailByPrimitive = new MapCurvePrimitiveToCurveLocationDetailPairArray(); // map from key CurvePrimitive to CurveLocationDetailPair.\n        for (const pair of allPairs)\n            detailByPrimitive.insertPair(pair);\n        if (primitives.length > detailByPrimitive.primitiveToPair.size)\n            detailByPrimitive.splitAndAppendMissingClosedPrimitives(primitives, mergeTolerance); // otherwise, these single-primitive loops are missing from the graph\n        const graph = new HalfEdgeGraph();\n        for (const entry of detailByPrimitive.primitiveToPair.entries()) {\n            const p = entry[0];\n            // convert each interval intersection into two isolated intersections\n            const details = entry[1].reduce((accumulator, detailPair) => {\n                if (!detailPair.detailA.hasFraction1)\n                    return [...accumulator, detailPair];\n                const detail = getDetailOnCurve(detailPair, p);\n                const detail0 = CurveLocationDetail.createCurveFractionPoint(p, detail.fraction, detail.point);\n                const detail1 = CurveLocationDetail.createCurveFractionPoint(p, detail.fraction1, detail.point1);\n                return [...accumulator, CurveLocationDetailPair.createCapture(detail0, detail0), CurveLocationDetailPair.createCapture(detail1, detail1)];\n            }, []);\n            // lexical sort on p intersection fraction\n            details.sort((pairA, pairB) => {\n                const fractionA = getFractionOnCurve(pairA, p);\n                const fractionB = getFractionOnCurve(pairB, p);\n                return fractionA - fractionB;\n            });\n            let last = { point: p.startPoint(), fraction: 0.0 };\n            for (const detailPair of details) {\n                const detail = getDetailOnCurve(detailPair, p);\n                const detailFraction = Geometry.restrictToInterval(detail.fraction, 0, 1); // truncate fraction, but don't snap point; clustering happens later\n                last = this.addHalfEdge(graph, p, last.point, last.fraction, detail.point, detailFraction, mergeTolerance);\n            }\n            this.addHalfEdge(graph, p, last.point, last.fraction, p.endPoint(), 1.0, mergeTolerance);\n        }\n        HalfEdgeGraphMerge.clusterAndMergeXYTheta(graph, (he) => he.sortAngle);\n        return graph;\n    }\n    /**\n     * Create a pair of mated half edges referencing an interval of a primitive\n     *   * no action if start and end points are identical.\n     * @param graph containing graph.\n     * @param p the curve\n     * @param fraction0 starting fraction\n     * @param point0 start point\n     * @param fraction1 end fraction\n     * @param point1 end point\n     * @returns end point and fraction, or start point and fraction if no action\n     */\n    static addHalfEdge(graph, p, point0, fraction0, point1, fraction1, mergeTolerance = Geometry.smallMetricDistance) {\n        if (point0.isAlmostEqualXY(point1, mergeTolerance))\n            return { point: point0, fraction: fraction0 };\n        const halfEdge = graph.createEdgeXYAndZ(point0, 0, point1, 0);\n        const detail01 = CurveLocationDetail.createCurveEvaluatedFractionFraction(p, fraction0, fraction1);\n        const mate = halfEdge.edgeMate;\n        halfEdge.edgeTag = detail01;\n        halfEdge.sortData = 1.0;\n        mate.edgeTag = detail01;\n        mate.sortData = -1.0;\n        halfEdge.sortAngle = sortAngle(p, fraction0, false);\n        mate.sortAngle = sortAngle(p, fraction1, true);\n        return { point: point1, fraction: fraction1 };\n    }\n    /**\n     * Based on computed (and toleranced) area, push the loop (pointer) onto the appropriate array of positive, negative, or sliver loops.\n     * @param zeroAreaTolerance absolute area tolerance for sliver face detection\n     * @param isSliverFace whether the loop is known a priori (e.g., via topology) to have zero area\n     * @returns the area (forced to zero if within tolerance)\n     */\n    static collectSignedLoop(loop, outLoops, zeroAreaTolerance = 1.0e-10, isSliverFace) {\n        let area = isSliverFace ? 0.0 : RegionOps.computeXYArea(loop);\n        if (area === undefined)\n            area = 0;\n        if (Math.abs(area) < zeroAreaTolerance)\n            area = 0.0;\n        loop.computedAreaInPlanarSubdivision = area;\n        if (area > 0)\n            outLoops.positiveAreaLoops.push(loop);\n        else if (area < 0)\n            outLoops.negativeAreaLoops.push(loop);\n        else\n            outLoops.slivers.push(loop);\n        return area;\n    }\n    static createLoopInFace(faceSeed, announce) {\n        let he = faceSeed;\n        const loop = Loop.create();\n        do {\n            const detail = he.edgeTag;\n            if (detail) {\n                let curve;\n                if (he.sortData > 0)\n                    curve = detail.curve.clonePartialCurve(detail.fraction, detail.fraction1);\n                else\n                    curve = detail.curve.clonePartialCurve(detail.fraction1, detail.fraction);\n                if (curve) {\n                    if (announce !== undefined)\n                        announce(he, curve, loop);\n                    loop.tryAddChild(curve);\n                }\n            }\n            he = he.faceSuccessor;\n        } while (he !== faceSeed);\n        return loop;\n    }\n    // Return true if there are only two edges in the face loop, and their start curvatures are the same.\n    static isNullFace(he) {\n        const faceHasTwoEdges = (he.faceSuccessor.faceSuccessor === he);\n        let faceIsBanana = false;\n        if (faceHasTwoEdges) {\n            const c0 = HalfEdgeGraphMerge.curvatureSortKey(he);\n            const c1 = HalfEdgeGraphMerge.curvatureSortKey(he.faceSuccessor.edgeMate);\n            if (!Geometry.isSameCoordinate(c0, c1)) // default tol!\n                faceIsBanana = true; // heuristic: we could also check end curvatures, and/or higher derivatives...\n        }\n        return faceHasTwoEdges && !faceIsBanana;\n    }\n    // Look across edge mates (possibly several) for a nonnull mate face.\n    static nonNullEdgeMate(_graph, e) {\n        if (this.isNullFace(e))\n            return undefined;\n        let e1 = e.edgeMate;\n        while (this.isNullFace(e1)) {\n            e1 = e1.faceSuccessor.edgeMate;\n            if (e1 === e)\n                return undefined;\n        }\n        return e1;\n    }\n    static collectSignedLoopSetsInHalfEdgeGraph(graph, zeroAreaTolerance = 1.0e-10) {\n        const q = HalfEdgeGraphSearch.collectConnectedComponentsWithExteriorParityMasks(graph, undefined);\n        const result = [];\n        const edgeMap = new Map();\n        for (const faceSeeds of q) {\n            const componentAreas = { positiveAreaLoops: [], negativeAreaLoops: [], slivers: [] };\n            const edges = [];\n            for (const faceSeed of faceSeeds) {\n                const isNullFace = this.isNullFace(faceSeed);\n                const loop = this.createLoopInFace(faceSeed, (he, curveC, loopC) => {\n                    if (!isNullFace) {\n                        const mate = this.nonNullEdgeMate(graph, he);\n                        if (mate !== undefined) {\n                            const e = edgeMap.get(mate);\n                            if (e === undefined) {\n                                // Record this as loopA,edgeA of a shared edge to be completed later from the other side of the edge\n                                const e1 = new LoopCurveLoopCurve(loopC, curveC, undefined, undefined);\n                                edgeMap.set(he, e1);\n                            }\n                            else if (e instanceof LoopCurveLoopCurve) {\n                                e.setB(loopC, curveC);\n                                edges.push(e);\n                                edgeMap.delete(mate);\n                            }\n                        }\n                    }\n                });\n                this.collectSignedLoop(loop, componentAreas, zeroAreaTolerance, isNullFace);\n            }\n            componentAreas.edges = edges;\n            result.push(componentAreas);\n            edgeMap.clear();\n        }\n        return result;\n    }\n}\nfunction sortAngle(curve, fraction, reverse) {\n    const ray = curve.fractionToPointAndDerivative(fraction);\n    const s = reverse ? -1.0 : 1.0;\n    return Math.atan2(s * ray.direction.y, s * ray.direction.x);\n}\nfunction getFractionOnCurve(pair, curve) {\n    if (pair.detailA.curve === curve)\n        return pair.detailA.fraction;\n    if (pair.detailB.curve === curve)\n        return pair.detailB.fraction;\n    return undefined;\n}\nfunction getDetailOnCurve(pair, curve) {\n    if (pair.detailA.curve === curve)\n        return pair.detailA;\n    if (pair.detailB.curve === curve)\n        return pair.detailB;\n    return undefined;\n}\n//# sourceMappingURL=PlanarSubdivision.js.map",
      "start": 1693508125374,
      "end": 1693508125491,
      "sourcemaps": null
    }
  ]
}
