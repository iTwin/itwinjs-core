{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/common/lib/esm/ColorDef.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Symbology\n */\nimport { Geometry } from \"@itwin/core-geometry\";\nimport { ColorByName } from \"./ColorByName\";\nimport { HSLColor } from \"./HSLColor\";\nimport { HSVColor, HSVConstants } from \"./HSVColor\";\n// cspell: ignore ttbbggrr bbggrr rrggbb aabbggrr abgr rrggbb hsla lerp torgb dhue dsaturation dvalue intpart fractpart cyanish\n// portions adapted from Three.js Copyright Â© 2010-2017 three.js authors\nconst scratchBytes = new Uint8Array(4);\nconst scratchUInt32 = new Uint32Array(scratchBytes.buffer);\n/** An immutable integer representation of a color.\n *\n * A color consists of 4 components: Red, Blue, Green, and Transparency. Each component is an 8-bit unsigned integer in the range [0..255]. A value of zero means that component contributes nothing\n * to the color: e.g., a color with Red=0 contains no shade of red, and a color with Transparency=0 is fully opaque. A value of 255 means that component contributes its maximum\n * value to the color: e.g., a color with Red=255 is as red as it is possible to be, and a color with Transparency=255 is fully transparent.\n *\n * Internally, these 4 components are combined into a single 32-bit unsigned integer as represented by [[ColorDefProps]]. This representation can result in some confusion regarding:\n *  1. The ordering of the individual components; and\n *  2. Whether to specify transparency or opacity (sometimes referred to as \"alpha\").\n *\n * ColorDef uses `0xTTBBGGRR` internally, which uses Transparency and puts Red in the low byte and Transparency in the high byte. It can be converted to `0xRRGGBB` format (blue in the low byte)\n * using [[getRgb]] and `0xAABBGGRRx format (red in the low byte, using opacity instead of transparency) using [[getAbgr]].\n *\n * A ColorDef can be created from a numeric [[ColorDefProps]], from a string in one of the common HTML formats (e.g., [[fromString]]), or by specifying values for the individual components\n * (e.g., [[from]]).\n *\n * ColorDef is **immutable**. To obtain a modified copy of a ColorDef, use methods like [[adjustedForContrast]], [[inverse]], or [[withTransparency]]. For example:\n * ```ts\n *  const semiTransparentBlue = ColorDef.blue.withTransparency(100);\n * ```\n * @public\n * @extensions\n */\nclass ColorDef {\n    constructor(tbgr) {\n        scratchUInt32[0] = tbgr; // Force to be a 32-bit unsigned integer\n        this._tbgr = scratchUInt32[0];\n    }\n    /**\n     * Create a new ColorDef.\n     * @param val value to use.\n     * If a number, it is interpreted as a 0xTTBBGGRR (Red in the low byte, high byte is transparency 0==fully opaque) value.\n     * If a string, it must be in one of the forms supported by [[fromString]] - any unrecognized string will produce [[black]].\n     */\n    static create(val) {\n        return this.fromTbgr(this.computeTbgr(val));\n    }\n    /** Compute the 0xTTBBGGRR value corresponding to the specified representation of a color.\n     * @see [[fromString]] for a description of valid string representations.\n     */\n    static computeTbgr(val) {\n        switch (typeof val) {\n            case \"number\":\n                return val;\n            case \"string\":\n                return this.computeTbgrFromString(val);\n            default:\n                return 0;\n        }\n    }\n    /** Convert this ColorDef to a 32 bit number representing the 0xTTBBGGRR value */\n    toJSON() { return this._tbgr; }\n    /** Create a new ColorDef from a json object. If the json object is a number, it is assumed to be a 0xTTBBGGRR value. */\n    static fromJSON(json) {\n        return this.create(json);\n    }\n    /** Create a ColorDef from Red, Green, Blue, Transparency values. All inputs should be integers between 0-255. */\n    static from(red, green, blue, transparency) {\n        return this.fromTbgr(this.computeTbgrFromComponents(red, green, blue, transparency));\n    }\n    /** Compute the 0xTTBBGGRR value corresponding to the specified Red, Green, Blue, Transparency components. All inputs should be integers between 0-255. */\n    static computeTbgrFromComponents(red, green, blue, transparency) {\n        scratchBytes[0] = red;\n        scratchBytes[1] = green;\n        scratchBytes[2] = blue;\n        scratchBytes[3] = transparency || 0;\n        return scratchUInt32[0];\n    }\n    /** Create a ColorDef from its 0xTTBBGGRR representation. */\n    static fromTbgr(tbgr) {\n        switch (tbgr) {\n            case ColorByName.black:\n                return this.black;\n            case ColorByName.white:\n                return this.white;\n            case ColorByName.red:\n                return this.red;\n            case ColorByName.green:\n                return this.green;\n            case ColorByName.blue:\n                return this.blue;\n            default:\n                return new ColorDef(tbgr);\n        }\n    }\n    /** Create a ColorDef from its 0xAABBGGRR representation. */\n    static fromAbgr(abgr) {\n        return this.fromTbgr(this.getAbgr(abgr));\n    }\n    /** Create a ColorDef from a string representation. The following representations are supported:\n     * *\"rgb(255,0,0)\"*\n     * *\"rgba(255,0,0,.2)\"*\n     * *\"rgb(100%,0%,0%)\"*\n     * *\"hsl(120,50%,50%)\"*\n     * *\"#rrbbgg\"*\n     * *\"blanchedAlmond\"* (see possible values from [[ColorByName]]). Case-insensitive.\n     *\n     * If `val` is not a valid color string, this function returns [[black]].\n     * @see [[isValidColor]] to determine if `val` is a valid color string.\n     */\n    static fromString(val) {\n        return this.fromTbgr(this.computeTbgrFromString(val));\n    }\n    /** Determine whether the input is a valid representation of a ColorDef.\n     * @see [[fromString]] for the definition of a valid string representation.\n     * @see [[ColorDefProps]] for the definition of a valid numeric representation.\n     */\n    static isValidColor(val) {\n        if (typeof val === \"number\")\n            return val >= 0 && val <= 0xffffffff && Math.floor(val) === val;\n        return undefined !== this.tryComputeTbgrFromString(val);\n    }\n    /** Compute the 0xTTBBGGRR value corresponding to a string representation of a color.\n     * If `val` is not a valid color string, this function returns 0 (black).\n     * @see [[fromString]] for the definition of a valid color string.\n     * @see [[tryComputeTbgrFromString]] to determine if `val` is a valid color string.\n     */\n    static computeTbgrFromString(val) {\n        return this.tryComputeTbgrFromString(val) ?? 0;\n    }\n    /** Try to compute the 0xTTBBGGRR value corresponding to a string representation of a ColorDef.\n     * @returns the corresponding numeric representation, or `undefined` if the input does not represent a color.\n     * @see [[fromString]] for the definition of a valid color string.\n     */\n    static tryComputeTbgrFromString(val) {\n        if (typeof val !== \"string\")\n            return undefined;\n        val = val.toLowerCase();\n        let m = /^((?:rgb|hsl)a?)\\(\\s*([^\\)]*)\\)/.exec(val);\n        if (m) { // rgb / hsl\n            let color;\n            const name = m[1];\n            const components = m[2];\n            const hasPercent = (str) => str[str.length - 1] === \"%\";\n            const floatOrPercent = (str) => {\n                const v = parseFloat(str);\n                return 255 * Geometry.clamp(hasPercent(str) ? v / 100 : v, 0, 1);\n            };\n            const intOrPercent = (str) => {\n                const v = hasPercent(str) ? (parseFloat(str) / 100) * 255 : parseInt(str, 10);\n                return Geometry.clamp(v, 0, 255);\n            };\n            switch (name) {\n                case \"rgb\":\n                case \"rgba\":\n                    color = /^(\\d+%*)\\s*[, ]\\s*(\\d+%*)\\s*[, ]\\s*(\\d+%*)\\s*([,\\/]\\s*([0-9]*\\.?[0-9]+%*)\\s*)?$/.exec(components);\n                    if (color) { // rgb(255,0,0) rgba(255,0,0,0.5)\n                        return this.computeTbgrFromComponents(intOrPercent(color[1]), intOrPercent(color[2]), intOrPercent(color[3]), typeof color[5] === \"string\" ? 255 - floatOrPercent(color[5]) : 0);\n                    }\n                    break;\n                case \"hsl\":\n                case \"hsla\":\n                    color = /^([0-9]*\\.?[0-9]+)\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec(components);\n                    if (color) { // hsl(120,50%,50%) hsla(120,50%,50%,0.5)\n                        const h = parseFloat(color[1]) / 360;\n                        const s = parseInt(color[2], 10) / 100;\n                        const l = parseInt(color[3], 10) / 100;\n                        const t = typeof color[5] === \"string\" ? 255 - floatOrPercent(color[5]) : 0;\n                        return this.computeTbgrFromHSL(h, s, l, t);\n                    }\n                    break;\n            }\n            // eslint-disable-next-line no-cond-assign\n        }\n        else if (m = /^\\#([a-f0-9]+)$/.exec(val)) { // hex color\n            const hex = m[1];\n            const size = hex.length;\n            if (size === 3) { // #ff0\n                return this.computeTbgrFromComponents(parseInt(hex.charAt(0) + hex.charAt(0), 16), parseInt(hex.charAt(1) + hex.charAt(1), 16), parseInt(hex.charAt(2) + hex.charAt(2), 16), 0);\n            }\n            if (size === 6) { // #ff0000\n                return this.computeTbgrFromComponents(parseInt(hex.charAt(0) + hex.charAt(1), 16), parseInt(hex.charAt(2) + hex.charAt(3), 16), parseInt(hex.charAt(4) + hex.charAt(5), 16), 0);\n            }\n        }\n        if (val && val.length > 0) { // ColorRgb value\n            for (const [key, value] of Object.entries(ColorByName))\n                if (key.toLowerCase() === val)\n                    return value;\n        }\n        return undefined;\n    }\n    /** Get the red, green, blue, and transparency values from this ColorDef. Values will be integers between 0-255. */\n    get colors() {\n        return ColorDef.getColors(this._tbgr);\n    }\n    /** Get the r,g,b,t values encoded in an 0xTTBBGGRR value. Values will be integers between 0-255. */\n    static getColors(tbgr) {\n        scratchUInt32[0] = tbgr;\n        return {\n            b: scratchBytes[2],\n            g: scratchBytes[1],\n            r: scratchBytes[0],\n            t: scratchBytes[3],\n        };\n    }\n    /** The color value of this ColorDef as an integer in the form 0xTTBBGGRR (red in the low byte) */\n    get tbgr() { return this._tbgr; }\n    /** Get the value of the color as a number in 0xAABBGGRR format (i.e. red is in low byte). Transparency (0==fully opaque) converted to alpha (0==fully transparent).  */\n    getAbgr() {\n        return ColorDef.getAbgr(this._tbgr);\n    }\n    /** Get the value of a 0xTTBBGGRR color as a number in 0xAABBGGRR format (i.e. red is in low byte). Transparency (0==fully opaque) converted to alpha (0==fully transparent).  */\n    static getAbgr(tbgr) {\n        scratchUInt32[0] = tbgr;\n        scratchBytes[3] = 255 - scratchBytes[3];\n        return scratchUInt32[0];\n    }\n    /** Get the RGB value of the color as a number in 0xRRGGBB format (i.e blue is in the low byte). Transparency is ignored. Value will be from 0 to 2^24 */\n    getRgb() {\n        return ColorDef.getRgb(this._tbgr);\n    }\n    /** Get the RGB value of the 0xTTBBGGRR color as a number in 0xRRGGBB format (i.e blue is in the low byte). Transparency is ignored. Value will be from 0 to 2^24 */\n    static getRgb(tbgr) {\n        scratchUInt32[0] = tbgr;\n        return (scratchBytes[0] << 16) + (scratchBytes[1] << 8) + scratchBytes[2];\n    }\n    /** Return a copy of this ColorDef with the specified alpha component.\n     * @param alpha the new alpha value as an integer between 0-255.\n     * @returns A ColorDef with equivalent red, green, and blue components to this one but with the specified alpha.\n     */\n    withAlpha(alpha) {\n        const tbgr = ColorDef.withAlpha(this._tbgr, alpha);\n        return tbgr === this._tbgr ? this : ColorDef.fromTbgr(tbgr);\n    }\n    /** Return a color equivalent to the specified 0xTTBBGGRR but with modified alpha component.\n     * @param alpha the new alpha value as an integer between 0-255.\n     * @returns The 0xTTBBGGRR value equivalent to `tbgr` but with the specified alpha.\n     */\n    static withAlpha(tbgr, alpha) {\n        scratchUInt32[0] = tbgr;\n        scratchBytes[3] = 255 - (alpha | 0);\n        return scratchUInt32[0];\n    }\n    /** Get the alpha value for this ColorDef. Will be between 0-255 */\n    getAlpha() {\n        return ColorDef.getAlpha(this._tbgr);\n    }\n    /** Extract the alpha value from a 0xTTBBGGRR color. */\n    static getAlpha(tbgr) {\n        scratchUInt32[0] = tbgr;\n        return 255 - scratchBytes[3];\n    }\n    /** True if this ColorDef is fully opaque. */\n    get isOpaque() {\n        return ColorDef.isOpaque(this._tbgr);\n    }\n    /** True if the specified 0xTTBBGGRR color is fully opaque. */\n    static isOpaque(tbgr) {\n        return 255 === this.getAlpha(tbgr);\n    }\n    /** Get the transparency value for this ColorDef (inverse of alpha). Will be between 0-255. */\n    getTransparency() {\n        return ColorDef.getTransparency(this._tbgr);\n    }\n    /** Extract the transparency component from a 0xTTBBGGRR color as an integer between 0-255.. */\n    static getTransparency(tbgr) {\n        scratchUInt32[0] = tbgr;\n        return scratchBytes[3];\n    }\n    /** Create a copy of this ColorDef with the specified transparency.\n     * @param transparency the new transparency value. Must be between 0-255, where 0 means 'fully opaque' and 255 means 'fully transparent'.\n     * @returns a new ColorDef with the same color as this one and the specified transparency.\n     */\n    withTransparency(transparency) {\n        const tbgr = ColorDef.withTransparency(this._tbgr, transparency);\n        return tbgr === this._tbgr ? this : ColorDef.fromTbgr(tbgr);\n    }\n    /** Compute the 0xTTBBGGRR value of the specified color and transparency.\n     * @param transparency the new transparency as an integer between 0-255.\n     * @returns The 0xTTBBGGRR value equivalent to `tbgr` but with the specified transparency.\n     */\n    static withTransparency(tbgr, transparency) {\n        return this.withAlpha(tbgr, 255 - transparency);\n    }\n    /** The \"known name\" for this ColorDef. Will be undefined if color value is not in [[ColorByName]] list */\n    get name() {\n        return ColorDef.getName(this.tbgr);\n    }\n    /** Obtain the name of the color in the [[ColorByName]] list associated with the specified 0xTTBBGGRR value, or undefined if no such named color exists.\n     * @note A handful of colors (like \"aqua\" and \"cyan\") have identical tbgr values; in such cases the first match will be returned.\n     */\n    static getName(tbgr) {\n        for (const [key, value] of Object.entries(ColorByName))\n            if (value === tbgr)\n                return key;\n        return undefined;\n    }\n    /** Convert this ColorDef to a string in the form \"#rrggbb\" where values are hex digits of the respective colors */\n    toHexString() {\n        return ColorDef.toHexString(this.tbgr);\n    }\n    /** Convert the 0xTTBBGGRR value to a string in the form \"#rrggbb\". */\n    static toHexString(tbgr) {\n        return `#${(`000000${this.getRgb(tbgr).toString(16)}`).slice(-6)}`;\n    }\n    static getColorsString(tbgr) {\n        const c = this.getColors(tbgr);\n        return `${c.r},${c.g},${c.b}`;\n    }\n    /** Convert this ColorDef to a string in the form \"rgb(r,g,b)\" where values are decimal digits of the respective colors. */\n    toRgbString() {\n        return ColorDef.toRgbString(this.tbgr);\n    }\n    /** Convert the 0xTTBBGGRR color to a string in the form \"rgb(r,g,b)\" where each component is specified in decimal. */\n    static toRgbString(tbgr) {\n        return `rgb(${this.getColorsString(tbgr)})`;\n    }\n    /** Convert this ColorDef to a string in the form \"rgba(r,g,b,a)\" where color values are decimal digits and a is a fraction */\n    toRgbaString() {\n        return ColorDef.toRgbaString(this.tbgr);\n    }\n    /** Convert the 0xTTBBGGRR color to a string of the form \"rgba(r,g,b,a)\" where the color components are specified in decimal and the alpha component is a fraction. */\n    static toRgbaString(tbgr) {\n        return `rgba(${this.getColorsString(tbgr)},${this.getAlpha(tbgr) / 255.})`;\n    }\n    /** Create a ColorDef that is the linear interpolation of this ColorDef and another ColorDef, using a weighting factor.\n     * @param color2 The other color\n     * @param weight The weighting factor for color2. 0.0 = this color, 1.0 = color2.\n     * @param result Optional ColorDef to hold result. If undefined, a new ColorDef is created.\n     */\n    lerp(color2, weight) {\n        return ColorDef.fromTbgr(ColorDef.lerp(this.tbgr, color2.tbgr, weight));\n    }\n    /** Interpolate between two 0xTTBBGGRR colors using a weighting factor.\n     * @param tbgr1 The first color\n     * @param tbgr2 The other color\n     * @param weight The weighting factor in [0..1]. A value of 0.0 selects `tbgr1`; 1.0 selects `tbgr2`; 0.5 mixes them evenly; etc.\n     * @returns The linear interpolation between `tbgr1` and `tbgr2` using the specified weight.\n     */\n    static lerp(tbgr1, tbgr2, weight) {\n        const c = this.getColors(tbgr1);\n        const color = this.getColors(tbgr2);\n        c.r += (color.r - c.r) * weight;\n        c.g += (color.g - c.g) * weight;\n        c.b += (color.b - c.b) * weight;\n        return this.computeTbgrFromComponents(c.r, c.g, c.b, c.t);\n    }\n    /** Create a new ColorDef that is the inverse (all colors set to 255 - this) of this color. Ignores transparency - result has 0 transparency. */\n    inverse() {\n        return ColorDef.fromTbgr(ColorDef.inverse(this.tbgr));\n    }\n    /** Return a 0xTTBBGGRR color whose color components are the inverse of the input color. The result has 0 transparency. */\n    static inverse(tbgr) {\n        const colors = this.getColors(tbgr);\n        return this.computeTbgrFromComponents(255 - colors.r, 255 - colors.g, 255 - colors.b);\n    }\n    /** Create a ColorDef from hue, saturation, lightness values */\n    static fromHSL(h, s, l, transparency = 0) {\n        return this.fromTbgr(this.computeTbgrFromHSL(h, s, l, transparency));\n    }\n    /** Compute the 0xTTBBGGRR color corresponding to the specified hue, saturation, lightness values. */\n    static computeTbgrFromHSL(h, s, l, transparency = 0) {\n        const torgb = (p1, q1, t) => {\n            if (t < 0)\n                t += 1;\n            if (t > 1)\n                t -= 1;\n            if (t < 1 / 6)\n                return p1 + (q1 - p1) * 6 * t;\n            if (t < 1 / 2)\n                return q1;\n            if (t < 2 / 3)\n                return p1 + (q1 - p1) * 6 * (2 / 3 - t);\n            return p1;\n        };\n        const hue2rgb = (p1, q1, t) => Math.round(torgb(p1, q1, t) * 255);\n        const modulo = (n, m) => ((n % m) + m) % m;\n        // h,s,l ranges are in 0.0 - 1.0\n        h = modulo(h, 1);\n        s = Geometry.clamp(s, 0, 1);\n        l = Geometry.clamp(l, 0, 1);\n        if (s === 0) {\n            l *= 255;\n            return this.computeTbgrFromComponents(l, l, l, transparency);\n        }\n        const p = l <= 0.5 ? l * (1 + s) : l + s - (l * s);\n        const q = (2 * l) - p;\n        return this.computeTbgrFromComponents(hue2rgb(q, p, h + 1 / 3), hue2rgb(q, p, h), hue2rgb(q, p, h - 1 / 3), transparency);\n    }\n    /** Create an [[HSLColor]] from this ColorDef */\n    toHSL() {\n        // h,s,l ranges are in 0.0 - 1.0\n        const col = this.colors;\n        col.r /= 255;\n        col.g /= 255;\n        col.b /= 255;\n        const max = Math.max(col.r, col.g, col.b);\n        const min = Math.min(col.r, col.g, col.b);\n        let hue = 0;\n        let saturation;\n        const lightness = (min + max) / 2.0;\n        if (min === max) {\n            saturation = 0;\n        }\n        else {\n            const delta = max - min;\n            saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);\n            switch (max) {\n                case col.r:\n                    hue = (col.g - col.b) / delta + (col.g < col.b ? 6 : 0);\n                    break;\n                case col.g:\n                    hue = (col.b - col.r) / delta + 2;\n                    break;\n                case col.b:\n                    hue = (col.r - col.g) / delta + 4;\n                    break;\n            }\n            hue /= 6;\n        }\n        return new HSLColor(hue, saturation, lightness);\n    }\n    /** Create an [[HSVColor]] from this ColorDef */\n    toHSV() {\n        const { r, g, b } = this.colors;\n        let min = (r < g) ? r : g;\n        if (b < min)\n            min = b;\n        let max = (r > g) ? r : g;\n        if (b > max)\n            max = b;\n        /* amount of \"blackness\" present */\n        const v = Math.floor((max / 255.0 * 100) + 0.5);\n        const deltaRgb = max - min;\n        const s = (max !== 0.0) ? Math.floor((deltaRgb / max * 100) + 0.5) : 0;\n        let h = 0;\n        if (s) {\n            const redDistance = (max - r) / deltaRgb;\n            const greenDistance = (max - g) / deltaRgb;\n            const blueDistance = (max - b) / deltaRgb;\n            let intermediateHue;\n            if (r === max) /* color between yellow & magenta */\n                intermediateHue = blueDistance - greenDistance;\n            else if (g === max) /* color between cyan & yellow */\n                intermediateHue = 2.0 + redDistance - blueDistance;\n            else /* color between magenta & cyan */\n                intermediateHue = 4.0 + greenDistance - redDistance;\n            /* intermediate hue is [0..6] */\n            intermediateHue *= 60;\n            if (intermediateHue < 0.0)\n                intermediateHue += 360;\n            h = Math.floor(intermediateHue + 0.5);\n            if (h >= 360)\n                h = 0;\n        }\n        else {\n            h = 0;\n        }\n        return new HSVColor(h, s, v);\n    }\n    /** Create a ColorDef from an HSVColor */\n    static fromHSV(hsv, transparency = 0) {\n        // Check for simple case first.\n        if ((!hsv.s) || (hsv.h === -1)) {\n            // hue must be undefined, have no color only white\n            const white = 0xff & Math.floor(((255.0 * hsv.v) / 100.0) + 0.5 + 3.0e-14);\n            return ColorDef.from(white, white, white, 0);\n        }\n        let dhue = hsv.h, dsaturation = hsv.s, dvalue = hsv.v;\n        if (dhue === 360)\n            dhue = 0.0;\n        dhue /= 60; // hue is now [0..6]\n        const hueIntpart = Math.floor(dhue); // convert double -> int\n        const hueFractpart = dhue - hueIntpart;\n        dvalue /= 100;\n        dsaturation /= 100;\n        const p = 0xff & Math.floor((dvalue * (1.0 - dsaturation) * 255.0) + 0.5);\n        const q = 0xff & Math.floor((dvalue * (1.0 - (dsaturation * hueFractpart)) * 255.0) + 0.5);\n        const t = 0xff & Math.floor((dvalue * (1.0 - (dsaturation * (1.0 - hueFractpart))) * 255.0) + 0.5);\n        const v = 0xff & Math.floor(dvalue * 255 + 0.5);\n        let r = 0, b = 0, g = 0;\n        switch (hueIntpart) {\n            /* eslint-disable max-statements-per-line */\n            case 0:\n                r = v;\n                g = t;\n                b = p;\n                break; // reddish\n            case 1:\n                r = q, g = v;\n                b = p;\n                break; // yellowish\n            case 2:\n                r = p, g = v;\n                b = t;\n                break; // greenish\n            case 3:\n                r = p, g = q;\n                b = v;\n                break; // cyanish\n            case 4:\n                r = t, g = p;\n                b = v;\n                break; // bluish\n            case 5:\n                r = v, g = p;\n                b = q;\n                break; // magenta-ish\n            /* eslint-enable max-statements-per-line */\n        }\n        return ColorDef.from(r, g, b, transparency);\n    }\n    visibilityCheck(other) {\n        const fg = this.colors;\n        const bg = other.colors;\n        // Compute luminosity\n        const red = Math.abs(fg.r - bg.r);\n        const green = Math.abs(fg.g - bg.g);\n        const blue = Math.abs(fg.b - bg.b);\n        return (0.30 * red) + (0.59 * green) + (0.11 * blue);\n    }\n    /**\n     * Create a new ColorDef that is adjusted from this ColorDef for maximum contrast against another color. The color will either be lighter\n     * or darker, depending on which has more visibility against the other color.\n     * @param other the color to contrast with\n     * @param alpha optional alpha value for the adjusted color. If not supplied alpha from this color is used.\n     */\n    adjustedForContrast(other, alpha) {\n        const visibility = this.visibilityCheck(other);\n        if (HSVConstants.VISIBILITY_GOAL <= visibility) {\n            return undefined !== alpha ? this.withAlpha(alpha) : this;\n        }\n        const adjPercent = Math.floor(((HSVConstants.VISIBILITY_GOAL - visibility) / 255.0) * 100.0);\n        let darkerHSV = this.toHSV();\n        let brightHSV = darkerHSV.clone();\n        darkerHSV = darkerHSV.adjusted(true, adjPercent);\n        brightHSV = brightHSV.adjusted(false, adjPercent);\n        if (undefined === alpha)\n            alpha = this.getAlpha();\n        const darker = ColorDef.fromHSV(darkerHSV).withAlpha(alpha);\n        const bright = ColorDef.fromHSV(brightHSV).withAlpha(alpha);\n        if (bright.getRgb() === other.getRgb()) // Couldn't adjust brighter...\n            return darker;\n        if (darker.getRgb() === other.getRgb()) // Couldn't adjust darker...\n            return bright;\n        // NOTE: Best choice is the one most visible against the other color...\n        return (bright.visibilityCheck(other) >= darker.visibilityCheck(other)) ? bright : darker;\n    }\n    /** True if the value of this ColorDef is the same as another ColorDef. */\n    equals(other) {\n        return this._tbgr === other._tbgr;\n    }\n}\n/** pure black */\nColorDef.black = new ColorDef(ColorByName.black);\n/** pure white */\nColorDef.white = new ColorDef(ColorByName.white);\n/** pure red */\nColorDef.red = new ColorDef(ColorByName.red);\n/** pure green */\nColorDef.green = new ColorDef(ColorByName.green);\n/** pure blue */\nColorDef.blue = new ColorDef(ColorByName.blue);\nexport { ColorDef };\n//# sourceMappingURL=ColorDef.js.map",
      "start": 1693508120694,
      "end": 1693508120739,
      "sourcemaps": null
    }
  ]
}
