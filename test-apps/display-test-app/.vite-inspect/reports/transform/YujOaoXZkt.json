{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/BatchUniforms.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { desync, sync } from \"./Sync\";\nconst scratchRgb = new Float32Array(3);\nconst noOverrideRgb = new Float32Array([-1.0, -1.0, -1.0]);\n/** Maintains uniform variable state associated with the Batch currently being drawn by a Target.\n * @internal\n */\nexport class BatchUniforms {\n    constructor(target, batchState) {\n        this._featureMode = 0 /* FeatureMode.None */;\n        this.syncKey = 0;\n        this._batchId = new Float32Array(4);\n        this._scratchBytes = new Uint8Array(4);\n        this._scratchUint32 = new Uint32Array(this._scratchBytes.buffer);\n        this.state = batchState;\n        this._target = target;\n    }\n    setCurrentBatch(batch) {\n        desync(this);\n        if (undefined !== batch)\n            this.state.push(batch, false);\n        else\n            this.state.pop();\n        const batchId = this.state.currentBatchId;\n        this._scratchUint32[0] = batchId;\n        this._batchId[0] = this._scratchBytes[0];\n        this._batchId[1] = this._scratchBytes[1];\n        this._batchId[2] = this._scratchBytes[2];\n        this._batchId[3] = this._scratchBytes[3];\n        const overrides = undefined !== batch ? batch.getOverrides(this._target) : undefined;\n        this._overrides = (undefined !== overrides && overrides.anyOverridden) ? overrides : undefined;\n        let sensors;\n        if (undefined !== batch && this._target.wantThematicSensors) {\n            const distanceCutoff = this._target.plan.thematic.sensorSettings.distanceCutoff;\n            if (distanceCutoff > 0) // if we have a distance cutoff, we want to create per-batch sensor textures\n                sensors = batch.getThematicSensors(this._target);\n        }\n        this._sensors = sensors;\n        if (undefined !== this._overrides)\n            this._featureMode = 2 /* FeatureMode.Overrides */;\n        else if (0 !== batchId)\n            this._featureMode = 1 /* FeatureMode.Pick */;\n        else\n            this._featureMode = 0 /* FeatureMode.None */;\n    }\n    resetBatchState() {\n        this.state.reset();\n    }\n    get featureMode() { return this._featureMode; }\n    bindNumThematicSensors(uniform) {\n        if (undefined !== this._sensors)\n            this._sensors.bindNumSensors(uniform);\n    }\n    bindThematicSensors(uniform) {\n        if (undefined !== this._sensors)\n            this._sensors.bindTexture(uniform);\n    }\n    bindLUT(uniform) {\n        // Note we can't use sync() here because a different texture may have been assigned to the desired texture unit\n        if (undefined !== this._overrides)\n            this._overrides.bindLUT(uniform);\n    }\n    bindLUTParams(uniform) {\n        if (undefined !== this._overrides && !sync(this, uniform))\n            this._overrides.bindLUTParams(uniform);\n    }\n    bindUniformSymbologyFlags(uniform) {\n        if (sync(this, uniform))\n            return;\n        if (undefined !== this._overrides)\n            this._overrides.bindUniformSymbologyFlags(uniform);\n        else\n            uniform.setUniform1f(0);\n    }\n    bindBatchId(uniform) {\n        if (!sync(this, uniform))\n            uniform.setUniform4fv(this._batchId);\n    }\n    bindUniformColorOverride(uniform) {\n        if (sync(this, uniform))\n            return;\n        if (undefined !== this._overrides) {\n            const uo = this._overrides.getUniformOverrides();\n            if (uo[0] & 2 /* OvrFlags.Rgb */) {\n                scratchRgb[0] = uo[4] / 255.0;\n                scratchRgb[1] = uo[5] / 255.0;\n                scratchRgb[2] = uo[6] / 255.0;\n                uniform.setUniform3fv(scratchRgb);\n            }\n            else {\n                uniform.setUniform3fv(noOverrideRgb);\n            }\n        }\n        else {\n            uniform.setUniform3fv(noOverrideRgb);\n        }\n    }\n    bindUniformTransparencyOverride(uniform) {\n        if (sync(this, uniform))\n            return;\n        if (undefined !== this._overrides) {\n            const uo = this._overrides.getUniformOverrides();\n            if (uo[0] & 4 /* OvrFlags.Alpha */) {\n                uniform.setUniform1f(uo[7] / 255.0);\n            }\n            else {\n                uniform.setUniform1f(-1.0);\n            }\n        }\n        else {\n            uniform.setUniform1f(-1.0);\n        }\n    }\n    bindUniformNonLocatable(uniform, ignoreNonLocatable) {\n        if (sync(this, uniform))\n            return;\n        let nonLocatable = 0;\n        if (!ignoreNonLocatable && undefined !== this._overrides) {\n            const uo = this._overrides.getUniformOverrides();\n            nonLocatable = (uo[0] & 32 /* OvrFlags.NonLocatable */) ? 1 : 0;\n        }\n        uniform.setUniform1i(nonLocatable);\n    }\n}\n//# sourceMappingURL=BatchUniforms.js.map",
      "start": 1693508124740,
      "end": 1693508124953,
      "sourcemaps": null
    }
  ]
}
