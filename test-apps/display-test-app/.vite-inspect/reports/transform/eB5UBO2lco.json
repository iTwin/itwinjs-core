{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/curve/UnionRegion.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\nimport { CurveCollection } from \"./CurveCollection\";\nimport { Loop } from \"./Loop\";\nimport { ParityRegion } from \"./ParityRegion\";\n/**\n * * A `UnionRegion` is a collection of other planar region types -- `Loop` and `ParityRegion`.\n * * The composite is the union of the contained regions.\n * * A point is \"in\" the composite if it is \"in\" one or more of the contained regions.\n * @see [Curve Collections]($docs/learning/geometry/CurveCollection.md) learning article.\n * @public\n */\nexport class UnionRegion extends CurveCollection {\n    /** Test if `other` is a `UnionRegion` */\n    isSameGeometryClass(other) {\n        return other instanceof UnionRegion;\n    }\n    /** Return the array of regions */\n    get children() {\n        return this._children;\n    }\n    /** Constructor -- initialize with no children */\n    constructor() {\n        super();\n        /** String name for schema properties */\n        this.curveCollectionType = \"unionRegion\";\n        this._children = [];\n    }\n    /** Create a `UnionRegion` with given region children */\n    static create(...data) {\n        const result = new UnionRegion();\n        for (const child of data) {\n            result.tryAddChild(child);\n        }\n        return result;\n    }\n    /** Return the boundary type (5) of a corresponding MicroStation CurveVector */\n    dgnBoundaryType() {\n        return 5;\n    }\n    /** Dispatch to more strongly typed `processor.announceUnionRegion(this, indexInParent)` */\n    announceToCurveProcessor(processor, indexInParent = -1) {\n        return processor.announceUnionRegion(this, indexInParent);\n    }\n    /** Return structural clone with stroked primitives. */\n    cloneStroked(options) {\n        const clone = new UnionRegion();\n        let child;\n        for (child of this._children) {\n            const childStrokes = child.cloneStroked(options);\n            if (childStrokes)\n                clone.children.push(childStrokes);\n        }\n        return clone;\n    }\n    /** Return new empty `UnionRegion` */\n    cloneEmptyPeer() {\n        return new UnionRegion();\n    }\n    /**\n     * Try to add a child.\n     * * Returns false if the `AnyCurve` child is not a region type.\n     */\n    tryAddChild(child) {\n        if (child && (child instanceof ParityRegion || child instanceof Loop)) {\n            this._children.push(child);\n            return true;\n        }\n        return false;\n    }\n    /** Return a child identified by index. */\n    getChild(i) {\n        if (i < this._children.length)\n            return this._children[i];\n        return undefined;\n    }\n    /** Second step of double dispatch:  call `handler.handleUnionRegion(this)` */\n    dispatchToGeometryHandler(handler) {\n        return handler.handleUnionRegion(this);\n    }\n}\n//# sourceMappingURL=UnionRegion.js.map",
      "start": 1693508123728,
      "end": 1693508123870,
      "sourcemaps": null
    }
  ]
}
