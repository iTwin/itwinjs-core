{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/BranchUniforms.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { assert } from \"@itwin/core-bentley\";\nimport { Matrix3d, Matrix4d, Point3d, Transform } from \"@itwin/core-geometry\";\nimport { BranchStack } from \"./BranchStack\";\nimport { BatchState } from \"./BatchState\";\nimport { Matrix3, Matrix4 } from \"./Matrix\";\nimport { RenderCommands } from \"./RenderCommands\";\nimport { desync, sync } from \"./Sync\";\nimport { ClipStack } from \"./ClipStack\";\nfunction equalXYZs(a, b) {\n    if (a === b)\n        return true;\n    if ((undefined === a) !== (undefined === b))\n        return false;\n    if (undefined !== a && undefined !== b)\n        return a.isExactEqual(b);\n    assert(undefined === a && undefined === b);\n    return true;\n}\n/** Maintains uniform variable state associated with the Branch currently being drawn by a Target.\n * @internal\n */\nexport class BranchUniforms {\n    get stack() { return this._stack; }\n    constructor(target) {\n        this._viewClipEnabled = false;\n        this.syncKey = 0;\n        this._stack = new BranchStack();\n        // Parameters that affect synchronization.\n        this._isInstanced = false;\n        // CPU state\n        this._mv = Matrix4d.createIdentity();\n        this._mvp = Matrix4d.createIdentity();\n        // GPU state\n        this._mv32 = new Matrix4();\n        this._mvp32 = new Matrix4();\n        this._m32 = new Matrix4();\n        this._v32 = new Matrix3();\n        // Working state\n        this._scratchTransform = Transform.createIdentity();\n        this._scratchTransform2 = Transform.createIdentity();\n        this._scratchViewToWorld = Matrix3d.createIdentity();\n        this._scratchVIModelMatrix = Transform.createIdentity();\n        this._zeroPoint = new Point3d(0, 0, 0);\n        this._target = target;\n        this.clipStack = new ClipStack(() => target.uniforms.frustum.viewMatrix, () => this._viewClipEnabled && this.top.viewFlags.clipVolume);\n    }\n    createBatchState() {\n        return new BatchState(this._stack);\n    }\n    createRenderCommands(batchState) {\n        return new RenderCommands(this._target, this._stack, batchState);\n    }\n    get modelViewMatrix() {\n        return this._mv;\n    }\n    get top() {\n        return this._stack.top;\n    }\n    get length() {\n        return this._stack.length;\n    }\n    pushBranch(branch) {\n        desync(this);\n        this._stack.pushBranch(branch);\n        if (this.top.clipVolume)\n            this.clipStack.push(this.top.clipVolume);\n        if (branch.branch.realityModelDisplaySettings)\n            this._target.uniforms.realityModel.update(branch.branch.realityModelDisplaySettings);\n    }\n    pushState(state) {\n        desync(this);\n        this._stack.pushState(state);\n        if (this.top.clipVolume)\n            this.clipStack.push(this.top.clipVolume);\n        if (state.realityModelDisplaySettings)\n            this._target.uniforms.realityModel.update(state.realityModelDisplaySettings);\n    }\n    pop() {\n        desync(this);\n        if (this.top.clipVolume)\n            this.clipStack.pop();\n        this._stack.pop();\n    }\n    pushViewClip() {\n        assert(!this._viewClipEnabled);\n        this._viewClipEnabled = true;\n        // Target.readPixels() pushes another BranchState before pushing view clip...\n        assert((this._target.isReadPixelsInProgress ? 2 : 1) === this._stack.length);\n    }\n    popViewClip() {\n        assert(this._viewClipEnabled);\n        this._viewClipEnabled = false;\n        assert((this._target.isReadPixelsInProgress ? 2 : 1) === this._stack.length);\n    }\n    changeRenderPlan(vf, is3d, hline) {\n        this._stack.changeRenderPlan(vf, is3d, hline);\n    }\n    updateViewClip(clip, style) {\n        this.clipStack.setViewClip(clip, style);\n    }\n    overrideFeatureSymbology(ovr) {\n        this._stack.setSymbologyOverrides(ovr);\n    }\n    bindModelViewMatrix(uniform, geom, isViewCoords) {\n        if (this.update(uniform, geom, isViewCoords))\n            uniform.setMatrix4(this._mv32);\n    }\n    bindModelViewProjectionMatrix(uniform, geom, isViewCoords) {\n        if (this.update(uniform, geom, isViewCoords))\n            uniform.setMatrix4(this._mvp32);\n    }\n    bindModelToWorldTransform(uniform, geom, isViewCoords) {\n        if (this.update(uniform, geom, isViewCoords))\n            uniform.setMatrix4(this._m32);\n    }\n    bindWorldToViewNTransform(uniform, geom, isViewCoords) {\n        if (this.update(uniform, geom, isViewCoords))\n            uniform.setMatrix3(this._v32);\n    }\n    update(uniform, geometry, isViewCoords) {\n        const uniforms = this._target.uniforms[isViewCoords ? \"viewRect\" : \"frustum\"];\n        if (!sync(uniforms, this))\n            desync(this);\n        const instancedGeom = geometry.asInstanced;\n        if (undefined !== instancedGeom || this._isInstanced) {\n            this._isInstanced = undefined !== instancedGeom;\n            desync(this);\n        }\n        const vio = geometry.viewIndependentOrigin;\n        if (!equalXYZs(vio, this._viewIndependentOrigin)) {\n            this._viewIndependentOrigin = vio;\n            desync(this);\n        }\n        if (sync(this, uniform))\n            return false;\n        let mv;\n        const modelMatrix = this._target.currentTransform;\n        if (isViewCoords) {\n            // Zero out Z for silly clipping tools...\n            mv = modelMatrix.clone(this._scratchTransform);\n            mv.matrix.coffs[2] = mv.matrix.coffs[5] = mv.matrix.coffs[8] = 0.0;\n            if (instancedGeom)\n                mv = instancedGeom.getRtcModelTransform(mv);\n            // Scale based on device-pixel ratio.\n            const scale = this._target.devicePixelRatio;\n            const viewMatrix = Transform.createScaleAboutPoint(this._zeroPoint, scale, this._scratchTransform2);\n            viewMatrix.multiplyTransformTransform(mv, mv);\n        }\n        else {\n            const viewMatrix = this._target.uniforms.frustum.viewMatrix;\n            if (undefined !== instancedGeom) {\n                // For instanced geometry, the \"model view\" matrix is really a transform from center of instanced geometry range to view.\n                // Shader will compute final model-view matrix based on this and the per-instance transform.\n                if (vio) {\n                    const viewToWorldRot = viewMatrix.matrix.inverse(this._scratchViewToWorld);\n                    const rotateAboutOrigin = Transform.createFixedPointAndMatrix(vio, viewToWorldRot, this._scratchTransform2);\n                    const viModelMatrix = rotateAboutOrigin.multiplyTransformTransform(instancedGeom.getRtcModelTransform(modelMatrix), this._scratchVIModelMatrix);\n                    mv = viewMatrix.multiplyTransformTransform(viModelMatrix, this._scratchTransform);\n                }\n                else {\n                    mv = viewMatrix.multiplyTransformTransform(instancedGeom.getRtcModelTransform(modelMatrix), this._scratchTransform);\n                }\n            }\n            else {\n                if (undefined !== vio) {\n                    const viewToWorldRot = viewMatrix.matrix.inverse(this._scratchViewToWorld);\n                    const rotateAboutOrigin = Transform.createFixedPointAndMatrix(vio, viewToWorldRot, this._scratchTransform2);\n                    const viModelMatrix = rotateAboutOrigin.multiplyTransformTransform(modelMatrix, this._scratchVIModelMatrix);\n                    mv = viewMatrix.multiplyTransformTransform(viModelMatrix, this._scratchTransform);\n                }\n                else {\n                    mv = viewMatrix.multiplyTransformTransform(modelMatrix, this._scratchTransform);\n                }\n            }\n        }\n        if (this._target.wantThematicDisplay) {\n            this._m32.initFromTransform(modelMatrix);\n            this._v32.initFromMatrix3d(this._target.uniforms.frustum.viewMatrix.matrix);\n        }\n        else if (undefined !== geometry.asSurface?.mesh.constantLodVParams) {\n            this._m32.initFromTransform(modelMatrix);\n        }\n        Matrix4d.createTransform(mv, this._mv);\n        this._mv32.initFromTransform(mv);\n        // Don't bother computing mvp for instanced geometry - it's not used.\n        if (!this._isInstanced) {\n            uniforms.projectionMatrix.multiplyMatrixMatrix(this._mv, this._mvp);\n            this._mvp32.initFromMatrix4d(this._mvp);\n        }\n        return true;\n    }\n}\n//# sourceMappingURL=BranchUniforms.js.map",
      "start": 1693508124742,
      "end": 1693508124968,
      "sourcemaps": null
    }
  ]
}
