{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/common/gltf/GltfParser.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Rendering\n */\nimport { ByteStream, JsonUtils, Logger, utf8ToString } from \"@itwin/core-bentley\";\nimport { Matrix3d, Point3d, Point4d, Transform } from \"@itwin/core-geometry\";\nimport { GlbHeader, ImageSource, TileFormat } from \"@itwin/core-common\";\nimport { FrontendLoggerCategory } from \"../FrontendLoggerCategory\";\nimport { getImageSourceFormatForMimeType, imageBitmapFromImageSource, imageElementFromImageSource, tryImageElementFromUrl, } from \"../ImageUtil\";\nimport { getGltfNodeMeshIds, gltfDictionaryIterator, GltfMeshMode, traverseGltfNodes, } from \"./GltfSchema\";\n/** Parse a [[GltfDocument]] or binary representation thereof to produce a [[Gltf.Model]].\n * This implementation is incomplete and not currently used.\n * @internal\n */\nexport async function parseGltf(args) {\n    const source = args.gltf;\n    let version;\n    let json;\n    let binary;\n    if (source instanceof Uint8Array) {\n        // It may be JSON - check for magic indicating glb.\n        const buffer = ByteStream.fromUint8Array(source);\n        if (TileFormat.Gltf !== buffer.readUint32()) {\n            try {\n                const utf8Json = utf8ToString(source);\n                if (!utf8Json)\n                    return undefined;\n                json = JSON.parse(utf8Json);\n                version = 2;\n            }\n            catch (_) {\n                return undefined;\n            }\n        }\n        else {\n            buffer.reset();\n            const header = new GlbHeader(buffer);\n            if (!header.isValid)\n                return undefined;\n            version = header.version;\n            if (header.binaryChunk)\n                binary = new Uint8Array(source.buffer, source.byteOffset + header.binaryChunk.offset, header.binaryChunk.length);\n            try {\n                const jsonBytes = new Uint8Array(source.buffer, source.byteOffset + header.jsonChunk.offset, header.jsonChunk.length);\n                const jsonStr = utf8ToString(jsonBytes);\n                if (undefined === jsonStr)\n                    return undefined;\n                json = JSON.parse(jsonStr);\n            }\n            catch (_) {\n                return undefined;\n            }\n        }\n    }\n    else {\n        version = 2; // ###TODO verify against source.asset?.version\n        json = source;\n    }\n    // asset is required in glTF 2, optional in glTF 1\n    const asset = JsonUtils.asObject(json.asset);\n    if (version === 2 && !asset)\n        return undefined;\n    const document = {\n        asset,\n        scene: JsonUtils.asString(json.scene),\n        extensions: JsonUtils.asObject(json.extensions),\n        extensionsUsed: JsonUtils.asArray(json.extensionsUsed),\n        extensionsRequired: JsonUtils.asArray(json.extensionsRequired),\n        accessors: JsonUtils.asObject(json.accessors),\n        buffers: JsonUtils.asObject(json.buffers),\n        bufferViews: JsonUtils.asObject(json.bufferViews),\n        images: JsonUtils.asObject(json.images),\n        materials: JsonUtils.asObject(json.materials),\n        meshes: JsonUtils.asObject(json.meshes),\n        nodes: JsonUtils.asObject(json.nodes),\n        samplers: JsonUtils.asObject(json.samplers),\n        scenes: JsonUtils.asObject(json.scenes),\n        textures: JsonUtils.asObject(json.textures),\n        techniques: JsonUtils.asObject(json.techniques),\n    };\n    if (!document.meshes)\n        return undefined;\n    const logger = args.logger ?? {\n        log: (message, type) => {\n            const category = `${FrontendLoggerCategory.Package}.gltf`;\n            const fn = type === \"error\" ? \"logError\" : (type === \"warning\" ? \"logWarning\" : \"logInfo\");\n            Logger[fn](category, message);\n        },\n    };\n    const parser = new GltfParser({\n        document,\n        version,\n        upAxis: args.upAxis ?? \"y\",\n        binary,\n        baseUrl: args.baseUrl,\n        logger,\n        isCanceled: () => args.isCanceled ?? false,\n        imageFromImageSource: (args.noCreateImageBitmap ?\n            async (imgSrc) => imageElementFromImageSource(imgSrc) :\n            async (imgSrc) => imageBitmapFromImageSource(imgSrc)),\n    });\n    return parser.parse();\n}\nclass GltfParser {\n    constructor(options) {\n        this._dracoMeshes = new Map();\n        this._version = options.version;\n        this._upAxis = options.upAxis;\n        this._baseUrl = options.baseUrl;\n        this._logger = options.logger;\n        this._isCanceled = options.isCanceled;\n        this._imageFromImageSource = options.imageFromImageSource;\n        const emptyDict = {};\n        const doc = options.document;\n        this._buffers = doc.buffers ?? emptyDict;\n        this._images = doc.images ?? emptyDict;\n        this._nodes = doc.nodes ?? emptyDict;\n        this._meshes = doc.meshes ?? emptyDict;\n        this._bufferViews = doc.bufferViews ?? emptyDict;\n        this._accessors = doc.accessors ?? emptyDict;\n        if (options.binary) {\n            const buffer = this._buffers[this._version === 2 ? 0 : \"binary_glTF\"];\n            if (buffer && undefined === buffer.uri)\n                buffer.resolvedBuffer = { data: options.binary };\n        }\n        let sceneNodes;\n        if (doc.scenes && undefined !== doc.scene)\n            sceneNodes = doc.scenes[doc.scene]?.nodes;\n        this._sceneNodes = sceneNodes ?? Object.keys(this._nodes);\n    }\n    async parse() {\n        // ###TODO_GLTF RTC_CENTER\n        // ###TODO_GLTF pseudo-rtc bias (apply translation to each point at read time, for scalable mesh...)\n        const toWorld = undefined;\n        await this.resolveResources();\n        if (this._isCanceled())\n            return undefined;\n        // ###TODO_GLTF compute content range (maybe do so elsewhere?)\n        // I think spec says POSITION must specify min and max?\n        const nodes = [];\n        for (const nodeKey of this._sceneNodes) {\n            const node = this._nodes[nodeKey];\n            if (node)\n                nodes.push(this.parseNode(node));\n        }\n        return {\n            toWorld,\n            nodes,\n        };\n    }\n    parseNode(node) {\n        const primitives = [];\n        for (const meshId of getGltfNodeMeshIds(node)) {\n            const mesh = this._meshes[meshId];\n            if (!mesh)\n                continue;\n            const parsedPrimitives = this.parsePrimitives(mesh);\n            for (const primitive of parsedPrimitives)\n                primitives.push(primitive);\n        }\n        let toParent;\n        if (node.matrix) {\n            const origin = Point3d.create(node.matrix[12], node.matrix[13], node.matrix[14]);\n            const matrix = Matrix3d.createRowValues(node.matrix[0], node.matrix[4], node.matrix[8], node.matrix[1], node.matrix[5], node.matrix[9], node.matrix[2], node.matrix[6], node.matrix[10]);\n            toParent = Transform.createOriginAndMatrix(origin, matrix);\n        }\n        else if (node.rotation || node.scale || node.translation) {\n            // SPEC: To compose the local transformation matrix, TRS properties MUST be converted to matrices and postmultiplied in the T * R * S order;\n            // first the scale is applied to the vertices, then the rotation, and then the translation.\n            const scale = Transform.createRefs(undefined, node.scale ? Matrix3d.createScale(node.scale[0], node.scale[1], node.scale[2]) : Matrix3d.identity);\n            const rot = Transform.createRefs(undefined, node.rotation ? Matrix3d.createFromQuaternion(Point4d.create(node.rotation[0], node.rotation[1], node.rotation[2], node.rotation[3])) : Matrix3d.identity);\n            rot.matrix.transposeInPlace(); // See comment on Matrix3d.createFromQuaternion\n            const trans = Transform.createTranslation(node.translation ? new Point3d(node.translation[0], node.translation[1], node.translation[2]) : Point3d.createZero());\n            toParent = scale.multiplyTransformTransform(rot);\n            trans.multiplyTransformTransform(toParent, toParent);\n        }\n        return {\n            primitives,\n            toParent,\n        };\n    }\n    parsePrimitives(mesh) {\n        const primitives = [];\n        if (!mesh.primitives)\n            return primitives;\n        for (const primitive of mesh.primitives) {\n            const parsedPrimitive = this.parsePrimitive(primitive);\n            if (parsedPrimitive)\n                primitives.push(parsedPrimitive);\n        }\n        return primitives;\n    }\n    parsePrimitive(primitive) {\n        const meshMode = JsonUtils.asInt(primitive.mode, GltfMeshMode.Triangles);\n        switch (meshMode) {\n            case GltfMeshMode.TriangleStrip:\n                return this.parseTrianglesPrimitive(primitive);\n            default:\n                // ###TODO_GLTF Make parser support all primitive types. Consumer can choose to do whatever with them.\n                return undefined;\n        }\n    }\n    parseTrianglesPrimitive(primitive) {\n        const posId = primitive.attributes.POSITION;\n        const pos = undefined !== posId ? this._accessors[posId] : undefined;\n        if (!pos)\n            return undefined;\n        return undefined; // ###TODO_GLTF\n    }\n    traverseNodes(nodeIds) {\n        return traverseGltfNodes(nodeIds, this._nodes, new Set());\n    }\n    async resolveResources() {\n        // Load any external images and buffers.\n        await this._resolveResources();\n        // If any meshes are draco-compressed, dynamically load the decoder module and then decode the meshes.\n        const dracoMeshes = [];\n        for (const node of this.traverseNodes(this._sceneNodes)) {\n            for (const meshId of getGltfNodeMeshIds(node)) {\n                const mesh = this._meshes[meshId];\n                if (mesh?.primitives)\n                    for (const primitive of mesh.primitives)\n                        if (primitive.extensions?.KHR_draco_mesh_compression)\n                            dracoMeshes.push(primitive.extensions.KHR_draco_mesh_compression);\n            }\n        }\n        if (dracoMeshes.length === 0)\n            return;\n        try {\n            const dracoLoader = (await import(\"@loaders.gl/draco\")).DracoLoader;\n            await Promise.all(dracoMeshes.map(async (x) => this.decodeDracoMesh(x, dracoLoader)));\n        }\n        catch (err) {\n            Logger.logWarning(FrontendLoggerCategory.Render, \"Failed to decode draco-encoded glTF mesh\");\n            Logger.logException(FrontendLoggerCategory.Render, err);\n        }\n    }\n    async _resolveResources() {\n        // ###TODO traverse the scene nodes to find resources referenced by them, instead of resolving everything - some resources may not\n        // be required for the scene.\n        const promises = [];\n        try {\n            for (const buffer of gltfDictionaryIterator(this._buffers))\n                if (!buffer.resolvedBuffer)\n                    promises.push(this.resolveBuffer(buffer));\n            await Promise.all(promises);\n            if (this._isCanceled())\n                return;\n            promises.length = 0;\n            for (const image of gltfDictionaryIterator(this._images))\n                if (!image.resolvedImage)\n                    promises.push(this.resolveImage(image));\n            await Promise.all(promises);\n        }\n        catch (_) {\n            // ###TODO_GLTF log\n        }\n    }\n    resolveUrl(uri) {\n        try {\n            return new URL(uri, this._baseUrl).toString();\n        }\n        catch (_) {\n            return undefined;\n        }\n    }\n    async resolveBuffer(buffer) {\n        if (buffer.resolvedBuffer || undefined === buffer.uri)\n            return;\n        try {\n            const url = this.resolveUrl(buffer.uri);\n            const response = url ? await fetch(url) : undefined;\n            if (this._isCanceled())\n                return;\n            const data = await response?.arrayBuffer();\n            if (this._isCanceled())\n                return;\n            if (data)\n                buffer.resolvedBuffer = { data: new Uint8Array(data) };\n        }\n        catch (_) {\n            //\n        }\n    }\n    async resolveImage(image) {\n        if (image.resolvedImage)\n            return;\n        const bvSrc = undefined !== image.bufferView ? image : image.extensions?.KHR_binary_glTF;\n        if (undefined !== bvSrc?.bufferView) {\n            const format = undefined !== bvSrc.mimeType ? getImageSourceFormatForMimeType(bvSrc.mimeType) : undefined;\n            const bufferView = this._bufferViews[bvSrc.bufferView];\n            if (undefined === format || !bufferView || !bufferView.byteLength || bufferView.byteLength < 0)\n                return;\n            const bufferData = this._buffers[bufferView.buffer]?.resolvedBuffer?.data;\n            if (!bufferData)\n                return;\n            const offset = bufferView.byteOffset ?? 0;\n            const bytes = bufferData.subarray(offset, offset + bufferView.byteLength);\n            try {\n                const imageSource = new ImageSource(bytes, format);\n                image.resolvedImage = await this._imageFromImageSource(imageSource);\n            }\n            catch (_) {\n                //\n            }\n            return;\n        }\n        const url = undefined !== image.uri ? this.resolveUrl(image.uri) : undefined;\n        if (undefined !== url)\n            image.resolvedImage = await tryImageElementFromUrl(url);\n    }\n    async decodeDracoMesh(ext, loader) {\n        const bv = this._bufferViews[ext.bufferView];\n        if (!bv || !bv.byteLength)\n            return;\n        let buf = this._buffers[bv.buffer]?.resolvedBuffer?.data;\n        if (!buf)\n            return;\n        const offset = bv.byteOffset ?? 0;\n        buf = buf.subarray(offset, offset + bv.byteLength);\n        const mesh = await loader.parse(buf, {}); // NB: `options` argument declared optional but will produce exception if not supplied.\n        if (mesh)\n            this._dracoMeshes.set(ext, mesh);\n    }\n}\n//# sourceMappingURL=GltfParser.js.map",
      "start": 1693508118553,
      "end": 1693508119098,
      "sourcemaps": null
    },
    {
      "name": "vite:build-import-analysis",
      "result": "import { __vitePreload } from \"\u0000vite/preload-helper\";/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Rendering\n */\nimport { ByteStream, JsonUtils, Logger, utf8ToString } from \"@itwin/core-bentley\";\nimport { Matrix3d, Point3d, Point4d, Transform } from \"@itwin/core-geometry\";\nimport { GlbHeader, ImageSource, TileFormat } from \"@itwin/core-common\";\nimport { FrontendLoggerCategory } from \"../FrontendLoggerCategory\";\nimport { getImageSourceFormatForMimeType, imageBitmapFromImageSource, imageElementFromImageSource, tryImageElementFromUrl, } from \"../ImageUtil\";\nimport { getGltfNodeMeshIds, gltfDictionaryIterator, GltfMeshMode, traverseGltfNodes, } from \"./GltfSchema\";\n/** Parse a [[GltfDocument]] or binary representation thereof to produce a [[Gltf.Model]].\n * This implementation is incomplete and not currently used.\n * @internal\n */\nexport async function parseGltf(args) {\n    const source = args.gltf;\n    let version;\n    let json;\n    let binary;\n    if (source instanceof Uint8Array) {\n        // It may be JSON - check for magic indicating glb.\n        const buffer = ByteStream.fromUint8Array(source);\n        if (TileFormat.Gltf !== buffer.readUint32()) {\n            try {\n                const utf8Json = utf8ToString(source);\n                if (!utf8Json)\n                    return undefined;\n                json = JSON.parse(utf8Json);\n                version = 2;\n            }\n            catch (_) {\n                return undefined;\n            }\n        }\n        else {\n            buffer.reset();\n            const header = new GlbHeader(buffer);\n            if (!header.isValid)\n                return undefined;\n            version = header.version;\n            if (header.binaryChunk)\n                binary = new Uint8Array(source.buffer, source.byteOffset + header.binaryChunk.offset, header.binaryChunk.length);\n            try {\n                const jsonBytes = new Uint8Array(source.buffer, source.byteOffset + header.jsonChunk.offset, header.jsonChunk.length);\n                const jsonStr = utf8ToString(jsonBytes);\n                if (undefined === jsonStr)\n                    return undefined;\n                json = JSON.parse(jsonStr);\n            }\n            catch (_) {\n                return undefined;\n            }\n        }\n    }\n    else {\n        version = 2; // ###TODO verify against source.asset?.version\n        json = source;\n    }\n    // asset is required in glTF 2, optional in glTF 1\n    const asset = JsonUtils.asObject(json.asset);\n    if (version === 2 && !asset)\n        return undefined;\n    const document = {\n        asset,\n        scene: JsonUtils.asString(json.scene),\n        extensions: JsonUtils.asObject(json.extensions),\n        extensionsUsed: JsonUtils.asArray(json.extensionsUsed),\n        extensionsRequired: JsonUtils.asArray(json.extensionsRequired),\n        accessors: JsonUtils.asObject(json.accessors),\n        buffers: JsonUtils.asObject(json.buffers),\n        bufferViews: JsonUtils.asObject(json.bufferViews),\n        images: JsonUtils.asObject(json.images),\n        materials: JsonUtils.asObject(json.materials),\n        meshes: JsonUtils.asObject(json.meshes),\n        nodes: JsonUtils.asObject(json.nodes),\n        samplers: JsonUtils.asObject(json.samplers),\n        scenes: JsonUtils.asObject(json.scenes),\n        textures: JsonUtils.asObject(json.textures),\n        techniques: JsonUtils.asObject(json.techniques),\n    };\n    if (!document.meshes)\n        return undefined;\n    const logger = args.logger ?? {\n        log: (message, type) => {\n            const category = `${FrontendLoggerCategory.Package}.gltf`;\n            const fn = type === \"error\" ? \"logError\" : (type === \"warning\" ? \"logWarning\" : \"logInfo\");\n            Logger[fn](category, message);\n        },\n    };\n    const parser = new GltfParser({\n        document,\n        version,\n        upAxis: args.upAxis ?? \"y\",\n        binary,\n        baseUrl: args.baseUrl,\n        logger,\n        isCanceled: () => args.isCanceled ?? false,\n        imageFromImageSource: (args.noCreateImageBitmap ?\n            async (imgSrc) => imageElementFromImageSource(imgSrc) :\n            async (imgSrc) => imageBitmapFromImageSource(imgSrc)),\n    });\n    return parser.parse();\n}\nclass GltfParser {\n    constructor(options) {\n        this._dracoMeshes = new Map();\n        this._version = options.version;\n        this._upAxis = options.upAxis;\n        this._baseUrl = options.baseUrl;\n        this._logger = options.logger;\n        this._isCanceled = options.isCanceled;\n        this._imageFromImageSource = options.imageFromImageSource;\n        const emptyDict = {};\n        const doc = options.document;\n        this._buffers = doc.buffers ?? emptyDict;\n        this._images = doc.images ?? emptyDict;\n        this._nodes = doc.nodes ?? emptyDict;\n        this._meshes = doc.meshes ?? emptyDict;\n        this._bufferViews = doc.bufferViews ?? emptyDict;\n        this._accessors = doc.accessors ?? emptyDict;\n        if (options.binary) {\n            const buffer = this._buffers[this._version === 2 ? 0 : \"binary_glTF\"];\n            if (buffer && undefined === buffer.uri)\n                buffer.resolvedBuffer = { data: options.binary };\n        }\n        let sceneNodes;\n        if (doc.scenes && undefined !== doc.scene)\n            sceneNodes = doc.scenes[doc.scene]?.nodes;\n        this._sceneNodes = sceneNodes ?? Object.keys(this._nodes);\n    }\n    async parse() {\n        // ###TODO_GLTF RTC_CENTER\n        // ###TODO_GLTF pseudo-rtc bias (apply translation to each point at read time, for scalable mesh...)\n        const toWorld = undefined;\n        await this.resolveResources();\n        if (this._isCanceled())\n            return undefined;\n        // ###TODO_GLTF compute content range (maybe do so elsewhere?)\n        // I think spec says POSITION must specify min and max?\n        const nodes = [];\n        for (const nodeKey of this._sceneNodes) {\n            const node = this._nodes[nodeKey];\n            if (node)\n                nodes.push(this.parseNode(node));\n        }\n        return {\n            toWorld,\n            nodes,\n        };\n    }\n    parseNode(node) {\n        const primitives = [];\n        for (const meshId of getGltfNodeMeshIds(node)) {\n            const mesh = this._meshes[meshId];\n            if (!mesh)\n                continue;\n            const parsedPrimitives = this.parsePrimitives(mesh);\n            for (const primitive of parsedPrimitives)\n                primitives.push(primitive);\n        }\n        let toParent;\n        if (node.matrix) {\n            const origin = Point3d.create(node.matrix[12], node.matrix[13], node.matrix[14]);\n            const matrix = Matrix3d.createRowValues(node.matrix[0], node.matrix[4], node.matrix[8], node.matrix[1], node.matrix[5], node.matrix[9], node.matrix[2], node.matrix[6], node.matrix[10]);\n            toParent = Transform.createOriginAndMatrix(origin, matrix);\n        }\n        else if (node.rotation || node.scale || node.translation) {\n            // SPEC: To compose the local transformation matrix, TRS properties MUST be converted to matrices and postmultiplied in the T * R * S order;\n            // first the scale is applied to the vertices, then the rotation, and then the translation.\n            const scale = Transform.createRefs(undefined, node.scale ? Matrix3d.createScale(node.scale[0], node.scale[1], node.scale[2]) : Matrix3d.identity);\n            const rot = Transform.createRefs(undefined, node.rotation ? Matrix3d.createFromQuaternion(Point4d.create(node.rotation[0], node.rotation[1], node.rotation[2], node.rotation[3])) : Matrix3d.identity);\n            rot.matrix.transposeInPlace(); // See comment on Matrix3d.createFromQuaternion\n            const trans = Transform.createTranslation(node.translation ? new Point3d(node.translation[0], node.translation[1], node.translation[2]) : Point3d.createZero());\n            toParent = scale.multiplyTransformTransform(rot);\n            trans.multiplyTransformTransform(toParent, toParent);\n        }\n        return {\n            primitives,\n            toParent,\n        };\n    }\n    parsePrimitives(mesh) {\n        const primitives = [];\n        if (!mesh.primitives)\n            return primitives;\n        for (const primitive of mesh.primitives) {\n            const parsedPrimitive = this.parsePrimitive(primitive);\n            if (parsedPrimitive)\n                primitives.push(parsedPrimitive);\n        }\n        return primitives;\n    }\n    parsePrimitive(primitive) {\n        const meshMode = JsonUtils.asInt(primitive.mode, GltfMeshMode.Triangles);\n        switch (meshMode) {\n            case GltfMeshMode.TriangleStrip:\n                return this.parseTrianglesPrimitive(primitive);\n            default:\n                // ###TODO_GLTF Make parser support all primitive types. Consumer can choose to do whatever with them.\n                return undefined;\n        }\n    }\n    parseTrianglesPrimitive(primitive) {\n        const posId = primitive.attributes.POSITION;\n        const pos = undefined !== posId ? this._accessors[posId] : undefined;\n        if (!pos)\n            return undefined;\n        return undefined; // ###TODO_GLTF\n    }\n    traverseNodes(nodeIds) {\n        return traverseGltfNodes(nodeIds, this._nodes, new Set());\n    }\n    async resolveResources() {\n        // Load any external images and buffers.\n        await this._resolveResources();\n        // If any meshes are draco-compressed, dynamically load the decoder module and then decode the meshes.\n        const dracoMeshes = [];\n        for (const node of this.traverseNodes(this._sceneNodes)) {\n            for (const meshId of getGltfNodeMeshIds(node)) {\n                const mesh = this._meshes[meshId];\n                if (mesh?.primitives)\n                    for (const primitive of mesh.primitives)\n                        if (primitive.extensions?.KHR_draco_mesh_compression)\n                            dracoMeshes.push(primitive.extensions.KHR_draco_mesh_compression);\n            }\n        }\n        if (dracoMeshes.length === 0)\n            return;\n        try {\n            const dracoLoader = (await __vitePreload(() => import(\"@loaders.gl/draco\"),__VITE_IS_MODERN__?\"__VITE_PRELOAD__\":void 0)).DracoLoader;\n            await Promise.all(dracoMeshes.map(async (x) => this.decodeDracoMesh(x, dracoLoader)));\n        }\n        catch (err) {\n            Logger.logWarning(FrontendLoggerCategory.Render, \"Failed to decode draco-encoded glTF mesh\");\n            Logger.logException(FrontendLoggerCategory.Render, err);\n        }\n    }\n    async _resolveResources() {\n        // ###TODO traverse the scene nodes to find resources referenced by them, instead of resolving everything - some resources may not\n        // be required for the scene.\n        const promises = [];\n        try {\n            for (const buffer of gltfDictionaryIterator(this._buffers))\n                if (!buffer.resolvedBuffer)\n                    promises.push(this.resolveBuffer(buffer));\n            await Promise.all(promises);\n            if (this._isCanceled())\n                return;\n            promises.length = 0;\n            for (const image of gltfDictionaryIterator(this._images))\n                if (!image.resolvedImage)\n                    promises.push(this.resolveImage(image));\n            await Promise.all(promises);\n        }\n        catch (_) {\n            // ###TODO_GLTF log\n        }\n    }\n    resolveUrl(uri) {\n        try {\n            return new URL(uri, this._baseUrl).toString();\n        }\n        catch (_) {\n            return undefined;\n        }\n    }\n    async resolveBuffer(buffer) {\n        if (buffer.resolvedBuffer || undefined === buffer.uri)\n            return;\n        try {\n            const url = this.resolveUrl(buffer.uri);\n            const response = url ? await fetch(url) : undefined;\n            if (this._isCanceled())\n                return;\n            const data = await response?.arrayBuffer();\n            if (this._isCanceled())\n                return;\n            if (data)\n                buffer.resolvedBuffer = { data: new Uint8Array(data) };\n        }\n        catch (_) {\n            //\n        }\n    }\n    async resolveImage(image) {\n        if (image.resolvedImage)\n            return;\n        const bvSrc = undefined !== image.bufferView ? image : image.extensions?.KHR_binary_glTF;\n        if (undefined !== bvSrc?.bufferView) {\n            const format = undefined !== bvSrc.mimeType ? getImageSourceFormatForMimeType(bvSrc.mimeType) : undefined;\n            const bufferView = this._bufferViews[bvSrc.bufferView];\n            if (undefined === format || !bufferView || !bufferView.byteLength || bufferView.byteLength < 0)\n                return;\n            const bufferData = this._buffers[bufferView.buffer]?.resolvedBuffer?.data;\n            if (!bufferData)\n                return;\n            const offset = bufferView.byteOffset ?? 0;\n            const bytes = bufferData.subarray(offset, offset + bufferView.byteLength);\n            try {\n                const imageSource = new ImageSource(bytes, format);\n                image.resolvedImage = await this._imageFromImageSource(imageSource);\n            }\n            catch (_) {\n                //\n            }\n            return;\n        }\n        const url = undefined !== image.uri ? this.resolveUrl(image.uri) : undefined;\n        if (undefined !== url)\n            image.resolvedImage = await tryImageElementFromUrl(url);\n    }\n    async decodeDracoMesh(ext, loader) {\n        const bv = this._bufferViews[ext.bufferView];\n        if (!bv || !bv.byteLength)\n            return;\n        let buf = this._buffers[bv.buffer]?.resolvedBuffer?.data;\n        if (!buf)\n            return;\n        const offset = bv.byteOffset ?? 0;\n        buf = buf.subarray(offset, offset + bv.byteLength);\n        const mesh = await loader.parse(buf, {}); // NB: `options` argument declared optional but will produce exception if not supplied.\n        if (mesh)\n            this._dracoMeshes.set(ext, mesh);\n    }\n}\n//# sourceMappingURL=GltfParser.js.map",
      "start": 1693508119105,
      "end": 1693508119106,
      "order": "normal",
      "sourcemaps": null
    }
  ]
}
