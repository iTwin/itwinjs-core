{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/primitives/EdgeParams.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Rendering\n */\nimport { assert } from \"@itwin/core-bentley\";\nimport { VertexIndices } from \"../../common/render/primitives/VertexIndices\";\nimport { calculateEdgeTableParams, } from \"../../common/render/primitives/EdgeParams\";\nimport { tesselatePolylineFromMesh, wantJointTriangles } from \"./PolylineParams\";\nimport { IModelApp } from \"../../IModelApp\";\nfunction convertPolylinesAndEdges(polylines, edges) {\n    let numIndices = undefined !== edges ? edges.length : 0;\n    if (undefined !== polylines)\n        for (const pd of polylines)\n            numIndices += (pd.length - 1);\n    if (0 === numIndices)\n        return undefined;\n    numIndices *= 6;\n    const indexBytes = new Uint8Array(numIndices * 3);\n    const endPointAndQuadIndexBytes = new Uint8Array(numIndices * 4);\n    let ndx = 0;\n    let ndx2 = 0;\n    const addPoint = (p0, p1, quadIndex) => {\n        VertexIndices.encodeIndex(p0, indexBytes, ndx);\n        ndx += 3;\n        VertexIndices.encodeIndex(p1, endPointAndQuadIndexBytes, ndx2);\n        endPointAndQuadIndexBytes[ndx2 + 3] = quadIndex;\n        ndx2 += 4;\n    };\n    if (undefined !== polylines) {\n        for (const pd of polylines) {\n            const num = pd.length - 1;\n            for (let i = 0; i < num; ++i) {\n                let p0 = pd[i];\n                let p1 = pd[i + 1];\n                if (p1 < p0) { // swap so that lower index is first.\n                    p0 = p1;\n                    p1 = pd[i];\n                }\n                addPoint(p0, p1, 0);\n                addPoint(p1, p0, 2);\n                addPoint(p0, p1, 1);\n                addPoint(p0, p1, 1);\n                addPoint(p1, p0, 2);\n                addPoint(p1, p0, 3);\n            }\n        }\n    }\n    if (undefined !== edges) {\n        for (const meshEdge of edges) {\n            const p0 = meshEdge.indices[0];\n            const p1 = meshEdge.indices[1];\n            addPoint(p0, p1, 0);\n            addPoint(p1, p0, 2);\n            addPoint(p0, p1, 1);\n            addPoint(p0, p1, 1);\n            addPoint(p1, p0, 2);\n            addPoint(p1, p0, 3);\n        }\n    }\n    return {\n        indices: new VertexIndices(indexBytes),\n        endPointAndQuadIndices: endPointAndQuadIndexBytes,\n    };\n}\nfunction convertSilhouettes(edges, normalPairs) {\n    const base = convertPolylinesAndEdges(undefined, edges);\n    if (undefined === base)\n        return undefined;\n    const normalPairBytes = new Uint8Array(normalPairs.length * 6 * 4);\n    const normalPair16 = new Uint16Array(normalPairBytes.buffer);\n    let ndx = 0;\n    for (const pair of normalPairs) {\n        for (let i = 0; i < 6; i++) {\n            normalPair16[ndx++] = pair.first.value;\n            normalPair16[ndx++] = pair.second.value;\n        }\n    }\n    return {\n        indices: base.indices,\n        endPointAndQuadIndices: base.endPointAndQuadIndices,\n        normalPairs: normalPairBytes,\n    };\n}\nfunction buildIndexedEdges(args, doPolylines, maxSize) {\n    const hardEdges = args.edges?.edges;\n    const silhouettes = args.silhouettes;\n    const polylines = doPolylines ? args.polylines?.lines : undefined;\n    const numHardEdges = hardEdges?.length ?? 0;\n    const numSilhouettes = silhouettes?.edges?.length ?? 0;\n    const numPolylines = polylines ? polylines.reduce((count, pd) => count + Math.max(0, pd.length - 1), 0) : 0;\n    const numSegmentEdges = numHardEdges + numPolylines;\n    const numTotalEdges = numSegmentEdges + numSilhouettes;\n    if (numTotalEdges === 0)\n        return undefined;\n    // Each edge is a quad consisting of six vertices. Each vertex is an identical 24-bit index into the lookup table.\n    const indices = new VertexIndices(new Uint8Array(numTotalEdges * 6 * 3));\n    for (let i = 0; i < numTotalEdges; i++)\n        for (let j = 0; j < 6; j++)\n            indices.setNthIndex(i * 6 + j, i);\n    const { width, height, silhouettePadding, silhouetteStartByteIndex } = calculateEdgeTableParams(numSegmentEdges, numSilhouettes, maxSize);\n    const data = new Uint8Array(width * height * 4);\n    function setUint24(byteIndex, value) {\n        data[byteIndex + 0] = value & 0x0000ff;\n        data[byteIndex + 1] = (value & 0x00ff00) >>> 8;\n        data[byteIndex + 2] = (value & 0xff0000) >>> 16;\n    }\n    function setEdge(index, startPointIndex, endPointIndex) {\n        const byteIndex = index * 6;\n        setUint24(byteIndex, startPointIndex);\n        setUint24(byteIndex + 3, endPointIndex);\n    }\n    let curIndex = 0;\n    if (hardEdges)\n        for (const edge of hardEdges)\n            setEdge(curIndex++, edge.indices[0], edge.indices[1]);\n    if (polylines) {\n        for (const pd of polylines) {\n            const num = pd.length - 1;\n            for (let i = 0; i < num; i++) {\n                const p0 = pd[i];\n                const p1 = pd[i + 1];\n                // Ensure lower index is first.\n                if (p0 < p1)\n                    setEdge(curIndex++, p0, p1);\n                else\n                    setEdge(curIndex++, p1, p0);\n            }\n        }\n    }\n    if (silhouettes?.edges) {\n        assert(undefined !== silhouettes.normals);\n        assert(silhouettes.normals.length === silhouettes.edges.length);\n        function setSilhouette(index, start, end, normals) {\n            const byteIndex = silhouetteStartByteIndex + silhouettePadding + index * 10;\n            setUint24(byteIndex, start);\n            setUint24(byteIndex + 3, end);\n            data[byteIndex + 6] = normals.first.value & 0xff;\n            data[byteIndex + 7] = (normals.first.value & 0xff00) >>> 8;\n            data[byteIndex + 8] = normals.second.value & 0xff;\n            data[byteIndex + 9] = (normals.second.value & 0xff00) >>> 8;\n        }\n        curIndex = 0;\n        for (let i = 0; i < silhouettes.edges.length; i++)\n            setSilhouette(curIndex++, silhouettes.edges[i].indices[0], silhouettes.edges[i].indices[1], silhouettes.normals[i]);\n    }\n    return {\n        indices,\n        edges: {\n            data,\n            width,\n            height,\n            numSegments: numSegmentEdges,\n            silhouettePadding,\n        },\n    };\n}\n/** @internal */\nexport function createEdgeParams(meshArgs, maxWidth) {\n    const args = meshArgs.edges;\n    if (!args)\n        return undefined;\n    const doJoints = wantJointTriangles(args.width, true === meshArgs.is2d);\n    const polylines = doJoints ? tesselatePolylineFromMesh(meshArgs) : undefined;\n    let segments;\n    let silhouettes;\n    let indexed;\n    if (\"non-indexed\" !== IModelApp.tileAdmin.edgeOptions.type) {\n        indexed = buildIndexedEdges(args, !doJoints, maxWidth ?? IModelApp.renderSystem.maxTextureSize);\n    }\n    else {\n        segments = convertPolylinesAndEdges(undefined, args.edges.edges);\n        silhouettes = args.silhouettes.edges && args.silhouettes.normals ? convertSilhouettes(args.silhouettes.edges, args.silhouettes.normals) : undefined;\n    }\n    if (!segments && !silhouettes && !polylines && !indexed)\n        return undefined;\n    return {\n        weight: args.width,\n        linePixels: args.linePixels,\n        segments,\n        silhouettes,\n        polylines,\n        indexed,\n    };\n}\n//# sourceMappingURL=EdgeParams.js.map",
      "start": 1693508119910,
      "end": 1693508119999,
      "sourcemaps": null
    }
  ]
}
