{
  "resolvedId": "D:/hub2023A/itwinjs-core/test-apps/display-test-app/src/frontend/ShadowMapDecoration.ts",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\r\n* See LICENSE.md in the project root for license terms and full copyright notice.\r\n*--------------------------------------------------------------------------------------------*/\r\nimport { parseToggle } from \"@itwin/frontend-devtools\";\r\nimport {\r\n  DecorateContext, GraphicBranch, GraphicType, IModelApp, RenderGraphic, RenderGraphicOwner, Target, Tool, Viewport,\r\n} from \"@itwin/core-frontend\";\r\n\r\nclass ShadowMapDecoration {\r\n  private static _instance?: ShadowMapDecoration;\r\n  private readonly _vp: Viewport;\r\n  private readonly _graphics: RenderGraphic[] = [];\r\n  private _removeMe?: () => void;\r\n\r\n  private get _target(): Target { return this._vp.target as Target; }\r\n\r\n  private constructor(vp: Viewport) {\r\n    this._vp = vp;\r\n    this._target.solarShadowMap.onGraphicsChanged = (gfx) => this.onGraphicsChanged(gfx);\r\n    vp.onChangeView.addOnce(() => ShadowMapDecoration.stop());\r\n    this._removeMe = IModelApp.viewManager.addDecorator(this);\r\n  }\r\n\r\n  private stop(): void {\r\n    if (undefined !== this._removeMe) {\r\n      this._removeMe();\r\n      this._removeMe = undefined;\r\n      for (const gf of this._graphics) {\r\n        gf.dispose();\r\n        if (gf instanceof RenderGraphicOwner)\r\n          gf.disposeGraphic();\r\n      }\r\n\r\n      this._graphics.length = 0;\r\n    }\r\n\r\n    this._target.solarShadowMap.onGraphicsChanged = undefined;\r\n    IModelApp.viewManager.invalidateCachedDecorationsAllViews(this);\r\n  }\r\n\r\n  /** This will allow the render system to cache and reuse the decorations created by this decorator's decorate() method. */\r\n  public readonly useCachedDecorations = true;\r\n\r\n  public decorate(context: DecorateContext): void {\r\n    const vp = context.viewport;\r\n    if (this._vp === vp || !this._vp.view.isSpatialView() || !vp.view.isSpatialView())\r\n      return;\r\n\r\n    for (const gf of this._graphics)\r\n      context.addDecoration(GraphicType.WorldDecoration, gf);\r\n  }\r\n\r\n  private onGraphicsChanged(gfx: RenderGraphic[]): void {\r\n    this._graphics.length = 0;\r\n    for (const gf of gfx) {\r\n      // Hack: GraphicBranch will be disposed, which empties out its array of graphics. Copy them.\r\n      const branch = (gf as any).branch as GraphicBranch;\r\n      if (undefined === branch || !(branch instanceof GraphicBranch)) {\r\n        this._graphics.push(gf);\r\n        continue;\r\n      }\r\n\r\n      const copy = new GraphicBranch(false);\r\n      copy.symbologyOverrides = this._target.currentFeatureSymbologyOverrides;\r\n      for (const entry of branch.entries)\r\n        copy.add(entry);\r\n\r\n      const copyGf = IModelApp.renderSystem.createBranch(copy, (gf as any).localToWorldTransform);\r\n      const owner = IModelApp.renderSystem.createGraphicOwner(copyGf);\r\n      this._graphics.push(owner);\r\n    }\r\n\r\n    IModelApp.viewManager.invalidateCachedDecorationsAllViews(this);\r\n  }\r\n\r\n  public static toggle(vp: Viewport, enabled?: boolean): void {\r\n    const cur = ShadowMapDecoration._instance;\r\n    if (undefined !== enabled) {\r\n      if ((undefined !== cur) === enabled)\r\n        return;\r\n    }\r\n\r\n    if (undefined === cur) {\r\n      ShadowMapDecoration._instance = new ShadowMapDecoration(vp);\r\n    } else {\r\n      cur.stop();\r\n      ShadowMapDecoration._instance = undefined;\r\n    }\r\n  }\r\n\r\n  public static stop(): void {\r\n    const cur = ShadowMapDecoration._instance;\r\n    if (undefined !== cur) {\r\n      cur.stop();\r\n      ShadowMapDecoration._instance = undefined;\r\n    }\r\n  }\r\n}\r\n\r\n/** Decorates all other viewports with the tiles selected for drawing the selected viewport's shadow map. */\r\nexport class ToggleShadowMapTilesTool extends Tool {\r\n  public static override toolId = \"ToggleShadowMapTiles\";\r\n  public static override get minArgs() { return 0; }\r\n  public static override get maxArgs() { return 1; }\r\n\r\n  public override async run(enable?: boolean): Promise<boolean> {\r\n    const vp = IModelApp.viewManager.selectedView;\r\n    if (undefined !== vp && vp.view.isSpatialView())\r\n      ShadowMapDecoration.toggle(vp, enable);\r\n\r\n    return true;\r\n  }\r\n\r\n  public override async parseAndRun(...args: string[]): Promise<boolean> {\r\n    const enable = parseToggle(args[0]);\r\n    if (typeof enable !== \"string\")\r\n      await this.run(enable);\r\n\r\n    return true;\r\n  }\r\n}\r\n",
      "start": 1693508121247,
      "end": 1693508121315,
      "sourcemaps": null
    },
    {
      "name": "vite:esbuild",
      "result": "\"use strict\";\nimport { parseToggle } from \"@itwin/frontend-devtools\";\nimport {\n  GraphicBranch,\n  GraphicType,\n  IModelApp,\n  RenderGraphicOwner,\n  Tool\n} from \"@itwin/core-frontend\";\nclass ShadowMapDecoration {\n  constructor(vp) {\n    this._graphics = [];\n    /** This will allow the render system to cache and reuse the decorations created by this decorator's decorate() method. */\n    this.useCachedDecorations = true;\n    this._vp = vp;\n    this._target.solarShadowMap.onGraphicsChanged = (gfx) => this.onGraphicsChanged(gfx);\n    vp.onChangeView.addOnce(() => ShadowMapDecoration.stop());\n    this._removeMe = IModelApp.viewManager.addDecorator(this);\n  }\n  get _target() {\n    return this._vp.target;\n  }\n  stop() {\n    if (void 0 !== this._removeMe) {\n      this._removeMe();\n      this._removeMe = void 0;\n      for (const gf of this._graphics) {\n        gf.dispose();\n        if (gf instanceof RenderGraphicOwner)\n          gf.disposeGraphic();\n      }\n      this._graphics.length = 0;\n    }\n    this._target.solarShadowMap.onGraphicsChanged = void 0;\n    IModelApp.viewManager.invalidateCachedDecorationsAllViews(this);\n  }\n  decorate(context) {\n    const vp = context.viewport;\n    if (this._vp === vp || !this._vp.view.isSpatialView() || !vp.view.isSpatialView())\n      return;\n    for (const gf of this._graphics)\n      context.addDecoration(GraphicType.WorldDecoration, gf);\n  }\n  onGraphicsChanged(gfx) {\n    this._graphics.length = 0;\n    for (const gf of gfx) {\n      const branch = gf.branch;\n      if (void 0 === branch || !(branch instanceof GraphicBranch)) {\n        this._graphics.push(gf);\n        continue;\n      }\n      const copy = new GraphicBranch(false);\n      copy.symbologyOverrides = this._target.currentFeatureSymbologyOverrides;\n      for (const entry of branch.entries)\n        copy.add(entry);\n      const copyGf = IModelApp.renderSystem.createBranch(copy, gf.localToWorldTransform);\n      const owner = IModelApp.renderSystem.createGraphicOwner(copyGf);\n      this._graphics.push(owner);\n    }\n    IModelApp.viewManager.invalidateCachedDecorationsAllViews(this);\n  }\n  static toggle(vp, enabled) {\n    const cur = ShadowMapDecoration._instance;\n    if (void 0 !== enabled) {\n      if (void 0 !== cur === enabled)\n        return;\n    }\n    if (void 0 === cur) {\n      ShadowMapDecoration._instance = new ShadowMapDecoration(vp);\n    } else {\n      cur.stop();\n      ShadowMapDecoration._instance = void 0;\n    }\n  }\n  static stop() {\n    const cur = ShadowMapDecoration._instance;\n    if (void 0 !== cur) {\n      cur.stop();\n      ShadowMapDecoration._instance = void 0;\n    }\n  }\n}\nexport class ToggleShadowMapTilesTool extends Tool {\n  static get minArgs() {\n    return 0;\n  }\n  static get maxArgs() {\n    return 1;\n  }\n  async run(enable) {\n    const vp = IModelApp.viewManager.selectedView;\n    if (void 0 !== vp && vp.view.isSpatialView())\n      ShadowMapDecoration.toggle(vp, enable);\n    return true;\n  }\n  async parseAndRun(...args) {\n    const enable = parseToggle(args[0]);\n    if (typeof enable !== \"string\")\n      await this.run(enable);\n    return true;\n  }\n}\nToggleShadowMapTilesTool.toolId = \"ToggleShadowMapTiles\";\n",
      "start": 1693508121315,
      "end": 1693508121469,
      "order": "normal",
      "sourcemaps": {
        "version": 3,
        "sources": [
          "D:/hub2023A/itwinjs-core/test-apps/display-test-app/src/frontend/ShadowMapDecoration.ts"
        ],
        "sourcesContent": [
          "/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\r\n* See LICENSE.md in the project root for license terms and full copyright notice.\r\n*--------------------------------------------------------------------------------------------*/\r\nimport { parseToggle } from \"@itwin/frontend-devtools\";\r\nimport {\r\n  DecorateContext, GraphicBranch, GraphicType, IModelApp, RenderGraphic, RenderGraphicOwner, Target, Tool, Viewport,\r\n} from \"@itwin/core-frontend\";\r\n\r\nclass ShadowMapDecoration {\r\n  private static _instance?: ShadowMapDecoration;\r\n  private readonly _vp: Viewport;\r\n  private readonly _graphics: RenderGraphic[] = [];\r\n  private _removeMe?: () => void;\r\n\r\n  private get _target(): Target { return this._vp.target as Target; }\r\n\r\n  private constructor(vp: Viewport) {\r\n    this._vp = vp;\r\n    this._target.solarShadowMap.onGraphicsChanged = (gfx) => this.onGraphicsChanged(gfx);\r\n    vp.onChangeView.addOnce(() => ShadowMapDecoration.stop());\r\n    this._removeMe = IModelApp.viewManager.addDecorator(this);\r\n  }\r\n\r\n  private stop(): void {\r\n    if (undefined !== this._removeMe) {\r\n      this._removeMe();\r\n      this._removeMe = undefined;\r\n      for (const gf of this._graphics) {\r\n        gf.dispose();\r\n        if (gf instanceof RenderGraphicOwner)\r\n          gf.disposeGraphic();\r\n      }\r\n\r\n      this._graphics.length = 0;\r\n    }\r\n\r\n    this._target.solarShadowMap.onGraphicsChanged = undefined;\r\n    IModelApp.viewManager.invalidateCachedDecorationsAllViews(this);\r\n  }\r\n\r\n  /** This will allow the render system to cache and reuse the decorations created by this decorator's decorate() method. */\r\n  public readonly useCachedDecorations = true;\r\n\r\n  public decorate(context: DecorateContext): void {\r\n    const vp = context.viewport;\r\n    if (this._vp === vp || !this._vp.view.isSpatialView() || !vp.view.isSpatialView())\r\n      return;\r\n\r\n    for (const gf of this._graphics)\r\n      context.addDecoration(GraphicType.WorldDecoration, gf);\r\n  }\r\n\r\n  private onGraphicsChanged(gfx: RenderGraphic[]): void {\r\n    this._graphics.length = 0;\r\n    for (const gf of gfx) {\r\n      // Hack: GraphicBranch will be disposed, which empties out its array of graphics. Copy them.\r\n      const branch = (gf as any).branch as GraphicBranch;\r\n      if (undefined === branch || !(branch instanceof GraphicBranch)) {\r\n        this._graphics.push(gf);\r\n        continue;\r\n      }\r\n\r\n      const copy = new GraphicBranch(false);\r\n      copy.symbologyOverrides = this._target.currentFeatureSymbologyOverrides;\r\n      for (const entry of branch.entries)\r\n        copy.add(entry);\r\n\r\n      const copyGf = IModelApp.renderSystem.createBranch(copy, (gf as any).localToWorldTransform);\r\n      const owner = IModelApp.renderSystem.createGraphicOwner(copyGf);\r\n      this._graphics.push(owner);\r\n    }\r\n\r\n    IModelApp.viewManager.invalidateCachedDecorationsAllViews(this);\r\n  }\r\n\r\n  public static toggle(vp: Viewport, enabled?: boolean): void {\r\n    const cur = ShadowMapDecoration._instance;\r\n    if (undefined !== enabled) {\r\n      if ((undefined !== cur) === enabled)\r\n        return;\r\n    }\r\n\r\n    if (undefined === cur) {\r\n      ShadowMapDecoration._instance = new ShadowMapDecoration(vp);\r\n    } else {\r\n      cur.stop();\r\n      ShadowMapDecoration._instance = undefined;\r\n    }\r\n  }\r\n\r\n  public static stop(): void {\r\n    const cur = ShadowMapDecoration._instance;\r\n    if (undefined !== cur) {\r\n      cur.stop();\r\n      ShadowMapDecoration._instance = undefined;\r\n    }\r\n  }\r\n}\r\n\r\n/** Decorates all other viewports with the tiles selected for drawing the selected viewport's shadow map. */\r\nexport class ToggleShadowMapTilesTool extends Tool {\r\n  public static override toolId = \"ToggleShadowMapTiles\";\r\n  public static override get minArgs() { return 0; }\r\n  public static override get maxArgs() { return 1; }\r\n\r\n  public override async run(enable?: boolean): Promise<boolean> {\r\n    const vp = IModelApp.viewManager.selectedView;\r\n    if (undefined !== vp && vp.view.isSpatialView())\r\n      ShadowMapDecoration.toggle(vp, enable);\r\n\r\n    return true;\r\n  }\r\n\r\n  public override async parseAndRun(...args: string[]): Promise<boolean> {\r\n    const enable = parseToggle(args[0]);\r\n    if (typeof enable !== \"string\")\r\n      await this.run(enable);\r\n\r\n    return true;\r\n  }\r\n}\r\n"
        ],
        "mappings": "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",
        "names": []
      }
    }
  ]
}
