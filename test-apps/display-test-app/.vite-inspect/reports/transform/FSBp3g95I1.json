{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/solid/RotationalSweep.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\nimport { StrokeOptions } from \"../curve/StrokeOptions\";\nimport { AxisOrder, Geometry } from \"../Geometry\";\nimport { Angle } from \"../geometry3d/Angle\";\nimport { Matrix3d } from \"../geometry3d/Matrix3d\";\nimport { Transform } from \"../geometry3d/Transform\";\nimport { SolidPrimitive } from \"./SolidPrimitive\";\nimport { SweepContour } from \"./SweepContour\";\n/**\n * A LinearSweep is\n * * A planar contour (any Loop, Path, or parityRegion)\n * * An axis vector.\n *   * The planar contour is expected to be in the plane of the axis vector\n *   * The contour may have points and/or lines that are on the axis, but otherwise is entirely on one side of the axis.\n * * A sweep angle.\n * @public\n */\nexport class RotationalSweep extends SolidPrimitive {\n    constructor(contour, normalizedAxis, sweepAngle, capped) {\n        super(capped);\n        /** String name for schema properties */\n        this.solidPrimitiveType = \"rotationalSweep\";\n        this._contour = contour;\n        this._normalizedAxis = normalizedAxis;\n        this.capped = capped;\n        this._sweepAngle = sweepAngle;\n    }\n    /** Create a rotational sweep. */\n    static create(contour, axis, sweepAngle, capped) {\n        if (!axis.direction.normalizeInPlace())\n            return undefined;\n        const sweepable = SweepContour.createForRotation(contour, axis);\n        if (!sweepable)\n            return undefined;\n        return new RotationalSweep(sweepable, axis, sweepAngle.clone(), capped);\n    }\n    /** Return a coordinate frame (right handed unit vectors)\n     * * origin at origin of rotation ray\n     * * z direction along the rotation ray.\n     * * y direction perpendicular to the base contour plane\n     */\n    getConstructiveFrame() {\n        const contourPerpendicular = this._contour.localToWorld.matrix.columnZ();\n        const axes = Matrix3d.createRigidFromColumns(contourPerpendicular, this._normalizedAxis.direction, AxisOrder.YZX);\n        if (axes) {\n            return Transform.createOriginAndMatrix(this._normalizedAxis.origin, axes);\n        }\n        return undefined;\n    }\n    /** return clone of (not reference to) the axis vector. */\n    cloneAxisRay() { return this._normalizedAxis.clone(); }\n    /** Return (REFERENCE TO) the swept curves. */\n    getCurves() { return this._contour.curves; }\n    /** Return (REFERENCE TO) the swept curves with containing plane markup. */\n    getSweepContourRef() { return this._contour; }\n    /** Return the sweep angle. */\n    getSweep() { return this._sweepAngle.clone(); }\n    /** Test if `other` is a `RotationalSweep` */\n    isSameGeometryClass(other) { return other instanceof RotationalSweep; }\n    /** Test for same axis, capping, and swept geometry. */\n    isAlmostEqual(other) {\n        if (other instanceof RotationalSweep) {\n            return this._contour.isAlmostEqual(other._contour)\n                && this._normalizedAxis.isAlmostEqual(other._normalizedAxis)\n                && this.capped === other.capped;\n        }\n        return false;\n    }\n    /** return a deep clone */\n    clone() {\n        return new RotationalSweep(this._contour.clone(), this._normalizedAxis.clone(), this._sweepAngle.clone(), this.capped);\n    }\n    /** Transform the contour and axis */\n    tryTransformInPlace(transform) {\n        if (!transform.matrix.isSingular()\n            && this._contour.tryTransformInPlace(transform)) {\n            this._normalizedAxis.transformInPlace(transform);\n            return this._normalizedAxis.direction.normalizeInPlace();\n        }\n        return false;\n    }\n    /** return a cloned transform. */\n    cloneTransformed(transform) {\n        const result = this.clone();\n        result.tryTransformInPlace(transform);\n        return result;\n    }\n    /** Dispatch to strongly typed handler  `handler.handleRotationalSweep(this)` */\n    dispatchToGeometryHandler(handler) {\n        return handler.handleRotationalSweep(this);\n    }\n    /** Return a transform that rotates around the rotational axis by a fraction of the total sweep. */\n    getFractionalRotationTransform(vFraction, result) {\n        const radians = this._sweepAngle.radians * vFraction;\n        const rotation = Transform.createFixedPointAndMatrix(this._normalizedAxis.origin, Matrix3d.createRotationAroundVector(this._normalizedAxis.direction, Angle.createRadians(radians), result ? result.matrix : undefined));\n        return rotation;\n    }\n    /**\n     * Return the curves of a constant-v section of the solid.\n     * @param vFraction fractional position along the sweep direction\n     */\n    constantVSection(vFraction) {\n        const section = this._contour.curves.clone();\n        if (section) {\n            section.tryTransformInPlace(this.getFractionalRotationTransform(vFraction));\n        }\n        return section;\n    }\n    /** Extend range using sampled points on the surface. */\n    extendRange(range, transform) {\n        const degreeStep = 360 / 32;\n        const options = StrokeOptions.createForCurves();\n        options.angleTol = Angle.createDegrees(degreeStep);\n        const strokes = this._contour.curves.cloneStroked(options);\n        const numStep = Geometry.stepCount(degreeStep, this._sweepAngle.degrees, 4, 32);\n        const stepTransform = Transform.createIdentity();\n        if (transform) {\n            const compositeTransform = Transform.createIdentity();\n            for (let i = 0; i <= numStep; i++) {\n                transform.multiplyTransformTransform(this.getFractionalRotationTransform(i / numStep, stepTransform), compositeTransform);\n                strokes.extendRange(range, compositeTransform);\n            }\n        }\n        else {\n            for (let i = 0; i <= numStep; i++)\n                strokes.extendRange(range, this.getFractionalRotationTransform(i / numStep, stepTransform));\n        }\n    }\n    /**\n     * @return true if this is a closed volume.\n     */\n    get isClosedVolume() {\n        return this.capped || this._sweepAngle.isFullCircle;\n    }\n}\n//# sourceMappingURL=RotationalSweep.js.map",
      "start": 1693508123769,
      "end": 1693508123895,
      "sourcemaps": null
    }
  ]
}
