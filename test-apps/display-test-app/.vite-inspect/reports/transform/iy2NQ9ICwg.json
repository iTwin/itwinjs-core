{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tile/B3dmReader.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tiles\n */\nimport { JsonUtils } from \"@itwin/core-bentley\";\nimport { Transform, Vector3d } from \"@itwin/core-geometry\";\nimport { B3dmHeader, ColorDef, Feature, FeatureTable, TileReadStatus } from \"@itwin/core-common\";\nimport { GltfDataType } from \"../common/gltf/GltfSchema\";\nimport { GltfReader, GltfReaderProps, } from \"./internal\";\n/**\n * Deserializes a tile in [b3dm](https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/specification/TileFormats/Batched3DModel) format.\n * @internal\n */\nexport class B3dmReader extends GltfReader {\n    static create(stream, iModel, modelId, is3d, range, system, yAxisUp, isLeaf, tileCenter, transformToRoot, isCanceled, idMap, deduplicateVertices = false) {\n        const header = new B3dmHeader(stream);\n        if (!header.isValid)\n            return undefined;\n        let returnToCenterTransform, pseudoRtcBias;\n        if (header.featureTableJson && Array.isArray(header.featureTableJson.RTC_CENTER)) {\n            returnToCenterTransform = Transform.createTranslationXYZ(header.featureTableJson.RTC_CENTER[0], header.featureTableJson.RTC_CENTER[1], header.featureTableJson.RTC_CENTER[2]);\n        }\n        else {\n            /**\n             * This is a workaround for tiles generated by\n             * context capture which have a large offset from the tileset origin that exceeds the\n             * capacity of 32 bit integers. It is essentially an ad hoc RTC applied at read time only if the tile is far from the\n             * origin and there is no RTC supplied either with the B3DM of the GLTF.\n             * as the vertices are supplied in a quantized format, applying the RTC bias to\n             * quantization origin will make these tiles work correctly.\n             */\n            pseudoRtcBias = Vector3d.create(tileCenter.x, tileCenter.y, tileCenter.z);\n        }\n        if (undefined !== returnToCenterTransform)\n            transformToRoot = transformToRoot ? transformToRoot.multiplyTransformTransform(returnToCenterTransform) : returnToCenterTransform;\n        const props = GltfReaderProps.create(stream.nextBytes(header.length - stream.curPos), yAxisUp);\n        const batchTableLength = header.featureTableJson ? JsonUtils.asInt(header.featureTableJson.BATCH_LENGTH, 0) : 0;\n        return undefined !== props ? new B3dmReader(props, iModel, modelId, is3d, system, range, isLeaf, batchTableLength, transformToRoot, header.batchTableJson, isCanceled, idMap, pseudoRtcBias, deduplicateVertices) : undefined;\n    }\n    constructor(props, iModel, modelId, is3d, system, _range, _isLeaf, _batchTableLength, _transformToRoot, _batchTableJson, shouldAbort, _idMap, _pseudoRtcBias, deduplicateVertices = false) {\n        super({\n            props, iModel, system, shouldAbort, deduplicateVertices,\n            is2d: !is3d,\n        });\n        this._range = _range;\n        this._isLeaf = _isLeaf;\n        this._batchTableLength = _batchTableLength;\n        this._transformToRoot = _transformToRoot;\n        this._batchTableJson = _batchTableJson;\n        this._idMap = _idMap;\n        this._pseudoRtcBias = _pseudoRtcBias;\n        this._batchIdRemap = new Map();\n        this._modelId = modelId;\n    }\n    async read() {\n        // NB: For reality models with no batch table, we want the model ID in the feature table\n        const featureTable = new FeatureTable(this._batchTableLength ? this._batchTableLength : 1, this._modelId, this._type);\n        if (this._batchTableLength > 0 && this._idMap !== undefined && this._batchTableJson !== undefined) {\n            if (this._batchTableJson.extensions && this._batchTableJson.extensions[\"3DTILES_batch_table_hierarchy\"]) {\n                const hierarchy = this._batchTableJson.extensions[\"3DTILES_batch_table_hierarchy\"];\n                const { classIds, classes, parentIds, parentCounts, instancesLength } = hierarchy;\n                if (classes !== undefined && classIds !== undefined && instancesLength !== 0) {\n                    const classCounts = new Array(classes.length);\n                    classCounts.fill(0);\n                    const classIndexes = new Uint16Array(instancesLength);\n                    for (let i = 0; i < instancesLength; ++i) {\n                        const classId = classIds[i];\n                        classIndexes[i] = classCounts[classId]++;\n                    }\n                    let parentMap;\n                    if (parentIds) {\n                        parentMap = new Array();\n                        for (let i = 0, parentIndex = 0; i < instancesLength; i++) {\n                            const parentCount = parentCounts === undefined ? 1 : parentCounts[i];\n                            parentMap[i] = parentIds.slice(parentIndex, parentIndex += parentCount);\n                        }\n                    }\n                    const getProperties = (instance, instanceIndex) => {\n                        const classId = classIds[instanceIndex];\n                        const instanceClass = classes[classId];\n                        const instances = instanceClass.instances;\n                        const indexInClass = classIndexes[instanceIndex];\n                        for (const key in instances) { // eslint-disable-line guard-for-in\n                            const value = instances[key][indexInClass];\n                            if (value !== undefined && value !== null)\n                                instance[key] = value;\n                        }\n                        if (parentIds !== undefined) {\n                            const thisParents = parentMap[instanceIndex];\n                            for (const parentId of thisParents) {\n                                if (parentId !== instanceIndex)\n                                    getProperties(instance, parentId);\n                            }\n                        }\n                    };\n                    for (let batchId = 0; batchId < instancesLength; batchId++) {\n                        const instance = {};\n                        getProperties(instance, batchId);\n                        this._batchIdRemap.set(batchId, featureTable.insert(new Feature(this._idMap.getBatchId(instance))));\n                        const cesiumColor = instance[\"cesium#color\"];\n                        if (undefined !== cesiumColor) {\n                            if (!this._colors) {\n                                this._colors = new Array(instancesLength);\n                                this._colors.fill(ColorDef.white.tbgr);\n                            }\n                            this._colors[batchId] = ColorDef.create(cesiumColor).tbgr;\n                        }\n                    }\n                }\n            }\n            else {\n                for (let i = 0; i < this._batchTableLength; i++) {\n                    const feature = {};\n                    for (const key in this._batchTableJson) // eslint-disable-line guard-for-in\n                        feature[key] = this._batchTableJson[key][i];\n                    this._batchIdRemap.set(i, featureTable.insert(new Feature(this._idMap.getBatchId(feature))));\n                }\n            }\n        }\n        if (featureTable.isEmpty) {\n            this._batchIdRemap.set(0, 0);\n            const feature = new Feature(this._modelId);\n            featureTable.insert(feature);\n        }\n        await this.resolveResources();\n        if (this._isCanceled)\n            return { readStatus: TileReadStatus.Canceled, isLeaf: this._isLeaf };\n        return this.readGltfAndCreateGraphics(this._isLeaf, featureTable, this._range, this._transformToRoot, this._pseudoRtcBias);\n    }\n    readBatchTable(mesh, json) {\n        if (mesh.features !== undefined) {\n            if (this._batchTableLength > 0 && undefined !== this._batchTableJson && undefined !== json.attributes) {\n                const view = this.getBufferView(json.attributes, \"_BATCHID\");\n                let batchIds;\n                if (undefined !== view && (undefined !== (batchIds = view.toBufferData(GltfDataType.UInt32)) || undefined !== (batchIds = view.toBufferData(GltfDataType.Float)))) {\n                    const indices = [];\n                    const { colors, colorMap } = mesh;\n                    let colorRemap;\n                    if (this._colors && this._colors.length === this._batchTableLength) {\n                        colorRemap = new Uint32Array(this._batchTableLength);\n                        for (let i = 0; i < this._batchTableLength; i++)\n                            colorRemap[i] = colorMap.insert(this._colors[i]);\n                    }\n                    for (let i = 0; i < batchIds.count; i++) {\n                        const batchId = batchIds.buffer[i * view.stride];\n                        const remapId = this._batchIdRemap.get(batchId);\n                        indices.push(remapId === undefined ? 0 : remapId);\n                        if (colorRemap)\n                            colors.push(colorRemap[batchId]);\n                    }\n                    mesh.features.setIndices(indices);\n                }\n            }\n            else {\n                mesh.features.add(new Feature(this._modelId), 1);\n            }\n        }\n    }\n}\n//# sourceMappingURL=B3dmReader.js.map",
      "start": 1693508121761,
      "end": 1693508121951,
      "sourcemaps": null
    }
  ]
}
