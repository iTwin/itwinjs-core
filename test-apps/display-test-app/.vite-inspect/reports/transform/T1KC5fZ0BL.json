{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend-devtools/lib/esm/tools/InspectElementTool.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tools\n */\nimport { BentleyError, Id64 } from \"@itwin/core-bentley\";\nimport { GeometrySummaryVerbosity, IModelReadRpcInterface } from \"@itwin/core-common\";\nimport { CoreTools, EventHandled, IModelApp, LocateFilterStatus, LocateResponse, MessageBoxIconType, MessageBoxType, NotifyMessageDetails, OutputMessagePriority, PrimitiveTool, } from \"@itwin/core-frontend\";\nimport { copyStringToClipboard } from \"../ClipboardUtilities\";\nimport { parseArgs } from \"./parseArgs\";\n/** Creates a readable text summary of a geometric element or geometry part. The keyin takes the following arguments, all of which are optional:\n *  - `id=elementId,elementId,elementId` comma-separated list of element Ids where each `elementId` is a hexadecimal element Id such as \"0x12cb\";\n *  - `symbology=0|1` where 1 indicates detailed symbology information should be included in the output;\n *  - `placement=0|1` where 1 indicates detailed geometric element placement should be included; and\n *  - `verbosity=0|1|2` controlling the verbosity of the output for each geometric primitive in the geometry stream. Higher values = more detailed information. Note verbosity=2 can produce megabytes of data for certain types of geometric primitives like large meshes.\n *  - `modal=0|1` where 1 indicates the output should appear in a modal dialog.\n *  - `copy=0|1` where 1 indicates the output should be copied to the clipboard. Defaults to true.\n *  - `refs=0|1` where 1 indicates that for geometry parts a list of all elements referencing that part should be included in the output. This is extremely computationally expensive.\n * If no id is specified, the tool runs in interactive mode: first operating upon the selection set (if any), then allowing the user to select additional elements.\n * @beta\n */\nclass InspectElementTool extends PrimitiveTool {\n    static get minArgs() { return 0; }\n    static get maxArgs() { return 6; }\n    constructor(options, elementIds) {\n        super();\n        this._options = {};\n        this._modal = false;\n        this._useSelection = false;\n        this._doCopy = false;\n        this._explodeParts = false;\n        if (undefined !== options)\n            this._options = { ...options };\n        this._elementIds = elementIds;\n    }\n    setupAndPromptForNextAction() {\n        this._useSelection = (undefined !== this.targetView && this.targetView.iModel.selectionSet.isActive);\n        if (!this._useSelection)\n            IModelApp.accuSnap.enableLocate(true);\n        this.showPrompt();\n    }\n    showPrompt() {\n        CoreTools.outputPromptByKey(this._useSelection ? \"ElementSet.Prompts.ConfirmSelection\" : \"ElementSet.Prompts.IdentifyElement\");\n    }\n    autoLockTarget() { }\n    requireWriteableTarget() { return false; }\n    async onUnsuspend() {\n        this.showPrompt();\n    }\n    async onPostInstall() {\n        await super.onPostInstall();\n        if (undefined !== this._elementIds)\n            this.process(this._elementIds).then(async () => {\n                await this.onReinitialize();\n            }).catch((err) => {\n                IModelApp.notifications.outputMessage(new NotifyMessageDetails(OutputMessagePriority.Error, err.toString()));\n            });\n        else {\n            this.setupAndPromptForNextAction();\n        }\n    }\n    async onDataButtonDown(ev) {\n        if (this._useSelection) {\n            if (undefined !== ev.viewport) {\n                const ids = [];\n                ev.viewport.iModel.selectionSet.elements.forEach((id) => {\n                    if (!Id64.isInvalid(id) && !Id64.isTransient(id))\n                        ids.push(id);\n                });\n                if (0 === ids.length)\n                    IModelApp.notifications.outputMessage(new NotifyMessageDetails(OutputMessagePriority.Error, CoreTools.translate(\"ElementSet.Error.NotSupportedElmType\")));\n                else\n                    await this.process(ids);\n                await this.onReinitialize();\n                return EventHandled.Yes;\n            }\n        }\n        const hit = await IModelApp.locateManager.doLocate(new LocateResponse(), true, ev.point, ev.viewport, ev.inputSource);\n        if (undefined === hit || !hit.isElementHit)\n            return EventHandled.No;\n        await this.process([hit.sourceId]);\n        this.setupAndPromptForNextAction();\n        return EventHandled.No;\n    }\n    async onResetButtonUp(_ev) {\n        await this.onReinitialize();\n        return EventHandled.No;\n    }\n    async onReinitialize() {\n        if (this._useSelection || undefined !== this._elementIds) {\n            await this.exitTool();\n        }\n        else {\n            await this.onRestartTool();\n        }\n    }\n    async onRestartTool() {\n        const tool = new InspectElementTool();\n        if (!await tool.run())\n            return this.exitTool();\n    }\n    async filterHit(hit, _out) {\n        return hit.isElementHit ? LocateFilterStatus.Accept : LocateFilterStatus.Reject;\n    }\n    async process(elementIds) {\n        const request = {\n            elementIds,\n            options: this._options,\n        };\n        let messageDetails;\n        try {\n            let str = await IModelReadRpcInterface.getClientForRouting(this.iModel.routingContext.token).getGeometrySummary(this.iModel.getRpcProps(), request);\n            if (this._explodeParts) {\n                const regex = /^part id: (0x[a-f0-9]+)/gm;\n                const partIds = new Set();\n                let match;\n                while (null !== (match = regex.exec(str)))\n                    partIds.add(match[1]);\n                if (partIds.size > 0) {\n                    request.elementIds = Array.from(partIds);\n                    str += `\\npart ids: ${JSON.stringify(request.elementIds)}\\n`;\n                    str += await IModelReadRpcInterface.getClientForRouting(this.iModel.routingContext.token).getGeometrySummary(this.iModel.getRpcProps(), request);\n                }\n            }\n            if (this._doCopy)\n                copyStringToClipboard(str);\n            const brief = `Summary ${this._doCopy ? \"copied to clipboard.\" : \"complete.\"}`;\n            messageDetails = new NotifyMessageDetails(OutputMessagePriority.Info, brief, str);\n            if (this._modal) {\n                const div = document.createElement(\"div\");\n                const appendText = (toAppend) => {\n                    const txt = document.createElement(\"div\");\n                    txt.innerText = toAppend;\n                    div.append(txt);\n                };\n                const lines = str.split(\"\\n\");\n                const maxLines = 30;\n                let curLine = 0;\n                for (const line of lines) {\n                    appendText(line);\n                    if (++curLine > maxLines) {\n                        appendText(\"...\");\n                        break;\n                    }\n                }\n                await IModelApp.notifications.openMessageBox(MessageBoxType.Ok, div, MessageBoxIconType.Information);\n            }\n        }\n        catch (err) {\n            messageDetails = new NotifyMessageDetails(OutputMessagePriority.Error, \"Error occurred while generating summary\", BentleyError.getErrorMessage(err));\n        }\n        IModelApp.notifications.outputMessage(messageDetails);\n    }\n    async parseAndRun(...inputArgs) {\n        const args = parseArgs(inputArgs);\n        const ids = args.get(\"i\");\n        if (undefined !== ids)\n            this._elementIds = ids.split(\",\");\n        const verbosity = args.getInteger(\"v\");\n        if (undefined !== verbosity) {\n            switch (verbosity) {\n                case 0:\n                    this._options.geometryVerbosity = GeometrySummaryVerbosity.Basic;\n                    break;\n                case 1:\n                    this._options.geometryVerbosity = GeometrySummaryVerbosity.Detailed;\n                    break;\n                case 2:\n                    this._options.geometryVerbosity = GeometrySummaryVerbosity.Full;\n                    break;\n            }\n        }\n        const symbology = args.getBoolean(\"s\");\n        if (undefined !== symbology)\n            this._options.verboseSymbology = symbology;\n        const placement = args.getBoolean(\"p\");\n        if (undefined !== placement)\n            this._options.includePlacement = placement;\n        const parts = args.getBoolean(\"r\");\n        if (true === parts && undefined !== IModelApp.viewManager.selectedView)\n            this._options.includePartReferences = IModelApp.viewManager.selectedView.view.is3d() ? \"3d\" : \"2d\";\n        const modal = args.getBoolean(\"m\");\n        if (undefined !== modal)\n            this._modal = modal;\n        const doCopy = args.getBoolean(\"c\");\n        if (undefined !== doCopy)\n            this._doCopy = doCopy;\n        this._explodeParts = true === args.getBoolean(\"e\");\n        return this.run();\n    }\n}\nInspectElementTool.toolId = \"InspectElement\";\nexport { InspectElementTool };\n//# sourceMappingURL=InspectElementTool.js.map",
      "start": 1693508122646,
      "end": 1693508122749,
      "sourcemaps": null
    }
  ]
}
