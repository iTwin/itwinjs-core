{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/glsl/EDL.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { TextureUnit } from \"../RenderFlags\";\nimport { Texture2DHandle } from \"../Texture\";\nimport { assignFragColor } from \"./Fragment\";\nimport { createViewportQuadBuilder } from \"./ViewportQuad\";\n// This shader calculates a more basic version of EDL, and only for the original size, so single pass\nconst calcBasicEDL = `\r\n    float strength = u_pointCloudEDL1.x;\r\n    float scaleFactor = u_pointCloudEDL1.z;\r\n    float pixRadius = u_pointCloudEDL1.y;\r\n    vec2 invTexSize = u_texInfo.xy;\r\n    float is3d = u_pointCloudEDL1.w;\r\n\r\n    vec4 color = TEXTURE(u_colorTexture, v_texCoord);\r\n    if (color.a == 0.0)\r\n        discard;\r\n    else {\r\n        const vec2 neighbors[8] = vec2[8] (  //neighbor relative position\r\n            vec2( 1.0, 0.0), vec2( 0.70710678,  0.70710678), vec2(0.0,  1.0), vec2(-0.70710678,  0.70710678),\r\n            vec2(-1.0, 0.0), vec2(-0.70710678, -0.70710678), vec2(0.0, -1.0), vec2( 0.70710678, -0.70710678));\r\n        float depth = TEXTURE(u_depthTexture, v_texCoord).r;\r\n        float sum = 0.0;\r\n        vec2 posScale = pixRadius * invTexSize;\r\n        // contribution of each neighbor\r\n        // NOTE: this is currently using neighbor depths regardless of if they were written by point cloud\r\n        for (int c = 0; c < 8; c++) {\r\n            vec2 nRelPos = posScale * neighbors[c];\r\n            vec2 nPos = v_texCoord + nRelPos;\r\n            float zN = TEXTURE(u_depthTexture, nPos).r;  // neighbor depth\r\n            sum += max(0.0, (is3d > 0.5) ? depth - zN : log (depth/zN));\r\n        }\r\n        float f = sum / 8.0;\r\n        f = exp(-f * 33.5 * strength * scaleFactor); // 33.5 factor to aim for a typical (unfactored) strength of 5\r\n        return vec4(f * color.rgb, 1.0);\r\n    }\r\n`;\n/** @internal */\nexport function createEDLCalcBasicProgram(context) {\n    const builder = createViewportQuadBuilder(true);\n    const frag = builder.frag;\n    frag.set(1 /* FragmentShaderComponent.ComputeBaseColor */, calcBasicEDL);\n    frag.set(16 /* FragmentShaderComponent.AssignFragData */, assignFragColor);\n    frag.addUniform(\"u_texInfo\", 4 /* VariableType.Vec3 */, (prog) => {\n        prog.addGraphicUniform(\"u_texInfo\", (uniform, params) => {\n            const geom = params.geometry;\n            uniform.setUniform3fv(geom.texInfo);\n        });\n    });\n    frag.addUniform(\"u_colorTexture\", 8 /* VariableType.Sampler2D */, (prog) => {\n        prog.addGraphicUniform(\"u_colorTexture\", (uniform, params) => {\n            const geom = params.geometry;\n            Texture2DHandle.bindSampler(uniform, geom.colorTexture, TextureUnit.Zero);\n        });\n    });\n    frag.addUniform(\"u_depthTexture\", 8 /* VariableType.Sampler2D */, (prog) => {\n        prog.addGraphicUniform(\"u_depthTexture\", (uniform, params) => {\n            const geom = params.geometry;\n            Texture2DHandle.bindSampler(uniform, geom.depthTexture, TextureUnit.One);\n        });\n    });\n    // Uniforms based on the PointCloudDisplaySettings.\n    frag.addUniform(\"u_pointCloudEDL1\", 5 /* VariableType.Vec4 */, (prog) => {\n        prog.addGraphicUniform(\"u_pointCloudEDL1\", (uniform, params) => {\n            params.target.uniforms.realityModel.pointCloud.bindEDL1(uniform);\n        });\n    });\n    builder.vert.headerComment = \"//!V! EDLCalcBasic\";\n    builder.frag.headerComment = \"//!F! EDLCalcBasic\";\n    return builder.buildProgram(context);\n}\n// This shader calculates the full version of EDL, and can be run at full, 1/2 and 1/4 scale\nconst calcFullEDL = `\r\n    float strength = u_pointCloudEDL1.x;\r\n    float scaleFactor = u_pointCloudEDL1.z;\r\n    float pixRadius = u_pointCloudEDL1.y;\r\n    float scale = u_texInfo.z;  // 1, 2, 4\r\n    vec2 invTexSize = u_texInfo.xy;\r\n    float is3d = u_pointCloudEDL1.w;\r\n\r\n    vec4 color = TEXTURE(u_colorTexture, v_texCoord);\r\n    if (color.a == 0.0)\r\n        return color;\r\n    else {\r\n        const vec2 neighbors[8] = vec2[8] (  //neighbor relative position\r\n            vec2( 1.0, 0.0), vec2( 0.70710678,  0.70710678), vec2(0.0,  1.0), vec2(-0.70710678,  0.70710678),\r\n            vec2(-1.0, 0.0), vec2(-0.70710678, -0.70710678), vec2(0.0, -1.0), vec2( 0.70710678, -0.70710678));\r\n        float depth = TEXTURE(u_depthTexture, v_texCoord).r;\r\n        float sum = 0.0;\r\n        vec2 posScale = pixRadius * invTexSize;\r\n        // contribution of each neighbor\r\n        // NOTE: this is currently using neighbor depths regardless of if they were written by point cloud\r\n        for (int c = 0; c < 8; c++) {\r\n            vec2 nRelPos = posScale * neighbors[c];\r\n            vec2 nPos = v_texCoord + nRelPos;\r\n            float zN = TEXTURE(u_depthTexture, nPos).r;  // neighbor depth\r\n            sum += max(0.0, (is3d > 0.5) ? depth - zN : log (depth/zN)) / scale;\r\n        }\r\n        float f = sum / 8.0;\r\n        f = exp(-f * 33.5 * strength * scaleFactor); // 33.5 factor to aim for a typical (unfactored) strength of 5\r\n        return vec4(f * color.rgb, 1.0);\r\n    }\r\n`;\n/** @internal */\nexport function createEDLCalcFullProgram(context) {\n    const builder = createViewportQuadBuilder(true);\n    const frag = builder.frag;\n    frag.set(1 /* FragmentShaderComponent.ComputeBaseColor */, calcFullEDL);\n    frag.set(16 /* FragmentShaderComponent.AssignFragData */, assignFragColor);\n    frag.addUniform(\"u_texInfo\", 4 /* VariableType.Vec3 */, (prog) => {\n        prog.addGraphicUniform(\"u_texInfo\", (uniform, params) => {\n            const geom = params.geometry;\n            uniform.setUniform3fv(geom.texInfo);\n        });\n    });\n    frag.addUniform(\"u_colorTexture\", 8 /* VariableType.Sampler2D */, (prog) => {\n        prog.addGraphicUniform(\"u_colorTexture\", (uniform, params) => {\n            const geom = params.geometry;\n            Texture2DHandle.bindSampler(uniform, geom.colorTexture, TextureUnit.Zero);\n        });\n    });\n    frag.addUniform(\"u_depthTexture\", 8 /* VariableType.Sampler2D */, (prog) => {\n        prog.addGraphicUniform(\"u_depthTexture\", (uniform, params) => {\n            const geom = params.geometry;\n            Texture2DHandle.bindSampler(uniform, geom.depthTexture, TextureUnit.One);\n        });\n    });\n    // Uniforms based on the PointCloudDisplaySettings.\n    frag.addUniform(\"u_pointCloudEDL1\", 5 /* VariableType.Vec4 */, (prog) => {\n        prog.addGraphicUniform(\"u_pointCloudEDL1\", (uniform, params) => {\n            params.target.uniforms.realityModel.pointCloud.bindEDL1(uniform);\n        });\n    });\n    builder.vert.headerComment = \"//!V! EDLCalcFull\";\n    builder.frag.headerComment = \"//!F! EDLCalcFull\";\n    return builder.buildProgram(context);\n}\n// This shader filters the EDL image, and can be run at 1/2 and 1/4 scale\nconst filterEDL = `\r\n    // NB: this bilateral filter hardcodes spatialSigma to 2.0 and depthSigma to 0.4, with halfSize = 2\r\n    float distCoefs[] = float[] (\r\n        1.0, 0.9692332344763441, 0.8824969025845955, 0.9692332344763441, 0.9394130628134758,\r\n        0.8553453273074225, 0.8824969025845955, 0.8553453273074225, 0.8553453273074225, 0.7788007830714049);\r\n    const float depthSigma = 0.4;\r\n    vec2 invTexSize = u_texInfo.xy;\r\n\r\n    float depth = TEXTURE(u_depthTexture, v_texCoord).r;\r\n    float wsum = 0.0;  // sum of all weights\r\n    vec3  csum = vec3(0.0);  // sum of all contributions\r\n    vec2  coordi = vec2(0.0, 0.0);  // ith neighbor position x,y\r\n\r\n    for (int c = -2; c <= 2; c++) {\r\n        coordi.x = float(c) * invTexSize.x;\r\n        int cabs = (c < 0) ? -c : c;\r\n\r\n        for (int d = -2; d <= 2; d++) {\r\n            coordi.y = float(d) * invTexSize.y;\r\n            vec4 ci = TEXTURE(u_colorTexture, v_texCoord + coordi); // neighbor color\r\n\r\n            //pixel distance based damping\r\n            int dabs = (d < 0) ? -d : d;\r\n            float fi = distCoefs[cabs * 3 + dabs];\r\n\r\n            //pixel depth difference based damping\r\n            float zi = TEXTURE(u_depthTexture, v_texCoord + coordi).r; // neighbor depth\r\n            float dz = (depth - zi) / depthSigma;\r\n            fi *= exp(-dz * dz / 2.0);\r\n\r\n            csum += ci.rgb * fi;\r\n            wsum += fi;\r\n        }\r\n    }\r\n    return vec4(csum / wsum, 1.0);\r\n`;\n/** @internal */\nexport function createEDLFilterProgram(context) {\n    const builder = createViewportQuadBuilder(true);\n    const frag = builder.frag;\n    frag.set(1 /* FragmentShaderComponent.ComputeBaseColor */, filterEDL);\n    frag.set(16 /* FragmentShaderComponent.AssignFragData */, assignFragColor);\n    frag.addUniform(\"u_texInfo\", 4 /* VariableType.Vec3 */, (prog) => {\n        prog.addGraphicUniform(\"u_texInfo\", (uniform, params) => {\n            const geom = params.geometry;\n            uniform.setUniform3fv(geom.texInfo);\n        });\n    });\n    frag.addUniform(\"u_colorTexture\", 8 /* VariableType.Sampler2D */, (prog) => {\n        prog.addGraphicUniform(\"u_colorTexture\", (uniform, params) => {\n            const geom = params.geometry;\n            Texture2DHandle.bindSampler(uniform, geom.colorTexture, TextureUnit.Zero);\n        });\n    });\n    frag.addUniform(\"u_depthTexture\", 8 /* VariableType.Sampler2D */, (prog) => {\n        prog.addGraphicUniform(\"u_depthTexture\", (uniform, params) => {\n            const geom = params.geometry;\n            Texture2DHandle.bindSampler(uniform, geom.depthTexture, TextureUnit.One);\n        });\n    });\n    builder.vert.headerComment = \"//!V! EDLFilter\";\n    builder.frag.headerComment = \"//!F! EDLFilter\";\n    return builder.buildProgram(context);\n}\n// This shader mixes the 3 EDL images into the final image\nconst mixEDL = `\r\n  vec4 col1 = TEXTURE(u_colorTexture1, v_texCoord);\r\n  if (col1.a == 0.0)\r\n      discard;\r\n  else {\r\n      vec3 col2 = TEXTURE(u_colorTexture2, v_texCoord).rgb;\r\n      vec3 col4 = TEXTURE(u_colorTexture4, v_texCoord).rgb;\r\n      return vec4 ((u_weights.x * col1.rgb + u_weights.y * col2 + u_weights.z * col4) / (u_weights.x + u_weights.y + u_weights.z), 1.0);\r\n  }\r\n`;\n/** @internal */\nexport function createEDLMixProgram(context) {\n    const builder = createViewportQuadBuilder(true);\n    const frag = builder.frag;\n    frag.set(1 /* FragmentShaderComponent.ComputeBaseColor */, mixEDL);\n    frag.set(16 /* FragmentShaderComponent.AssignFragData */, assignFragColor);\n    frag.addUniform(\"u_colorTexture1\", 8 /* VariableType.Sampler2D */, (prog) => {\n        prog.addGraphicUniform(\"u_colorTexture1\", (uniform, params) => {\n            const geom = params.geometry;\n            Texture2DHandle.bindSampler(uniform, geom.colorTexture1, TextureUnit.Zero);\n        });\n    });\n    frag.addUniform(\"u_colorTexture2\", 8 /* VariableType.Sampler2D */, (prog) => {\n        prog.addGraphicUniform(\"u_colorTexture2\", (uniform, params) => {\n            const geom = params.geometry;\n            Texture2DHandle.bindSampler(uniform, geom.colorTexture2, TextureUnit.One);\n        });\n    });\n    frag.addUniform(\"u_colorTexture4\", 8 /* VariableType.Sampler2D */, (prog) => {\n        prog.addGraphicUniform(\"u_colorTexture4\", (uniform, params) => {\n            const geom = params.geometry;\n            Texture2DHandle.bindSampler(uniform, geom.colorTexture4, TextureUnit.Two);\n        });\n    });\n    // Uniforms based on the PointCloudDisplaySettings.\n    frag.addUniform(\"u_weights\", 5 /* VariableType.Vec4 */, (prog) => {\n        prog.addGraphicUniform(\"u_weights\", (uniform, params) => {\n            params.target.uniforms.realityModel.pointCloud.bindEDL2(uniform);\n        });\n    });\n    builder.vert.headerComment = \"//!V! EDLMix\";\n    builder.frag.headerComment = \"//!F! EDLMix\";\n    return builder.buildProgram(context);\n}\n//# sourceMappingURL=EDL.js.map",
      "start": 1693508125838,
      "end": 1693508125919,
      "sourcemaps": null
    }
  ]
}
