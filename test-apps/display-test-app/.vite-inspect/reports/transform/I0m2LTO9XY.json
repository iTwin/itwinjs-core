{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/primitives/mesh/MeshBuilderMap.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Rendering\n */\nimport { compareBooleans, compareNumbers, Dictionary } from \"@itwin/core-bentley\";\nimport { FeatureTable } from \"@itwin/core-common\";\nimport { MeshPrimitiveType } from \"../../../common/render/primitives/MeshPrimitive\";\nimport { ToleranceRatio } from \"../Primitives\";\nimport { MeshBuilder, MeshEdgeCreationOptions } from \"./MeshBuilder\";\nimport { MeshList } from \"./MeshPrimitives\";\n/** @internal */\nexport class MeshBuilderMap extends Dictionary {\n    constructor(tolerance, range, is2d, options, pickable) {\n        super((lhs, rhs) => lhs.compare(rhs));\n        this._keyOrder = 0;\n        this.tolerance = tolerance;\n        this.vertexTolerance = tolerance * ToleranceRatio.vertex;\n        this.facetAreaTolerance = tolerance * ToleranceRatio.facetArea;\n        this.range = range;\n        this.is2d = is2d;\n        this.options = options;\n        if (pickable)\n            this.features = new FeatureTable(2048 * 1024, pickable.modelId);\n    }\n    static createFromGeometries(geometries, tolerance, range, is2d, options, pickable) {\n        const map = new MeshBuilderMap(tolerance, range, is2d, options, pickable);\n        for (const geom of geometries)\n            map.loadGeometry(geom);\n        return map;\n    }\n    toMeshes() {\n        const meshes = new MeshList(this.features, this.range);\n        for (const builder of this._values) {\n            if (builder.mesh.points.length > 0)\n                meshes.push(builder.mesh);\n        }\n        return meshes;\n    }\n    /**\n     * extract polyfaces and strokes from geometry into MeshBuilder stored in builderMap\n     * @param geom Geometry instance to extract polyfaces and strokes from\n     * @param wantSurfacesOnly if true prevent strokes from being loaded into builders\n     */\n    loadGeometry(geom) {\n        this.loadPolyfacePrimitiveList(geom);\n        if (!this.options.wantSurfacesOnly)\n            this.loadStrokePrimitiveList(geom);\n    }\n    /**\n     * extract polyface primitives from geometry in meshBuilder stored in builderMap\n     * @param geom Geometry instance to extract polyfaces from\n     */\n    loadPolyfacePrimitiveList(geom) {\n        const polyfaces = geom.getPolyfaces(this.tolerance);\n        if (polyfaces !== undefined)\n            for (const polyface of polyfaces)\n                this.loadIndexedPolyface(polyface, geom.feature);\n    }\n    /**\n     * extract indexed polyfaces into meshBuilder stored in builderMap\n     * @param polyface PolyfacePrimitive to extract indexed polyfaces from\n     */\n    loadIndexedPolyface(polyface, feature) {\n        const { indexedPolyface, displayParams, isPlanar } = polyface;\n        const { pointCount, normalCount } = indexedPolyface;\n        const { fillColor, isTextured } = displayParams;\n        const textureMapping = displayParams.textureMapping;\n        if (pointCount === 0)\n            return;\n        const builder = this.getBuilder(displayParams, MeshPrimitiveType.Mesh, normalCount > 0, isPlanar);\n        const edgeOptions = new MeshEdgeCreationOptions(polyface.displayEdges && this.options.edges ? MeshEdgeCreationOptions.Type.DefaultEdges : MeshEdgeCreationOptions.Type.NoEdges);\n        builder.addFromPolyface(indexedPolyface, { edgeOptions, includeParams: isTextured, fillColor: fillColor.tbgr, mappedTexture: textureMapping }, feature);\n    }\n    /**\n     * extract stroke primitives from geometry in meshBuilder stored in builderMap\n     * @param geom Geometry instance to extract strokes from\n     */\n    loadStrokePrimitiveList(geom) {\n        const strokes = geom.getStrokes(this.tolerance);\n        if (undefined !== strokes)\n            for (const stroke of strokes)\n                this.loadStrokesPrimitive(stroke, geom.feature);\n    }\n    /**\n     * extract strokes primitive into meshBuilder stored in builderMap\n     * @param strokePrimitive StrokesPrimitive instance to extractfrom\n     */\n    loadStrokesPrimitive(strokePrimitive, feature) {\n        const { displayParams, isDisjoint, isPlanar, strokes } = strokePrimitive;\n        const type = isDisjoint ? MeshPrimitiveType.Point : MeshPrimitiveType.Polyline;\n        const builder = this.getBuilder(displayParams, type, false, isPlanar);\n        builder.addStrokePointLists(strokes, isDisjoint, displayParams.fillColor.tbgr, feature);\n    }\n    getBuilder(displayParams, type, hasNormals, isPlanar) {\n        const { facetAreaTolerance, tolerance, is2d, range } = this;\n        const key = this.getKey(displayParams, type, hasNormals, isPlanar);\n        const quantizePositions = false; // ###TODO should this be configurable?\n        return this.getBuilderFromKey(key, {\n            displayParams,\n            type,\n            range,\n            quantizePositions,\n            is2d,\n            isPlanar,\n            tolerance,\n            areaTolerance: facetAreaTolerance,\n            features: this.features,\n        });\n    }\n    getKey(displayParams, type, hasNormals, isPlanar) {\n        const key = new MeshBuilderMap.Key(displayParams, type, hasNormals, isPlanar);\n        if (this.options.preserveOrder)\n            key.order = ++this._keyOrder;\n        return key;\n    }\n    /**\n     * gets builder associated with key if defined, otherwise creates a new builder and sets that with key\n     * @param key MeshBuilderMap.Key to associate with builder\n     * @param props MeshBuilder.Props required to create builder if it does not already exist\n     * @returns builder reference, changes will update instance stored in builderMap\n     */\n    getBuilderFromKey(key, props) {\n        let builder = this.get(key);\n        if (undefined === builder) {\n            builder = MeshBuilder.create(props);\n            this.set(key, builder);\n        }\n        return builder;\n    }\n}\n/** @internal */\n(function (MeshBuilderMap) {\n    class Key {\n        constructor(params, type, hasNormals, isPlanar) {\n            this.order = 0;\n            this.params = params;\n            this.type = type;\n            this.hasNormals = hasNormals;\n            this.isPlanar = isPlanar;\n        }\n        static createFromMesh(mesh) {\n            return new Key(mesh.displayParams, mesh.type, mesh.normals.length !== 0, mesh.isPlanar);\n        }\n        compare(rhs) {\n            let diff = compareNumbers(this.order, rhs.order);\n            if (0 === diff) {\n                diff = compareNumbers(this.type, rhs.type);\n                if (0 === diff) {\n                    diff = compareBooleans(this.isPlanar, rhs.isPlanar);\n                    if (0 === diff) {\n                        diff = compareBooleans(this.hasNormals, rhs.hasNormals);\n                        if (0 === diff) {\n                            diff = this.params.compareForMerge(rhs.params);\n                        }\n                    }\n                }\n            }\n            return diff;\n        }\n        equals(rhs) { return 0 === this.compare(rhs); }\n    }\n    MeshBuilderMap.Key = Key;\n})(MeshBuilderMap || (MeshBuilderMap = {}));\n//# sourceMappingURL=MeshBuilderMap.js.map",
      "start": 1693508119975,
      "end": 1693508120073,
      "sourcemaps": null
    }
  ]
}
