{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/topology/HalfEdgePointInGraphSearch.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Topology\n */\nimport { Geometry } from \"../Geometry\";\nimport { Vector3d } from \"../geometry3d/Point3dVector3d\";\nimport { NodeXYZUV } from \"./HalfEdgeNodeXYZUV\";\nimport { HalfEdgePositionDetail } from \"./HalfEdgePositionDetail\";\n/* eslint-disable @typescript-eslint/naming-convention */\nexport var RayClassification;\n(function (RayClassification) {\n    RayClassification[RayClassification[\"RC_NoHits\"] = 0] = \"RC_NoHits\";\n    RayClassification[RayClassification[\"RC_TargetOnVertex\"] = 1] = \"RC_TargetOnVertex\";\n    RayClassification[RayClassification[\"RC_TargetOnEdge\"] = 2] = \"RC_TargetOnEdge\";\n    RayClassification[RayClassification[\"RC_Bracket\"] = 3] = \"RC_Bracket\";\n    RayClassification[RayClassification[\"RC_TargetBefore\"] = 4] = \"RC_TargetBefore\";\n    RayClassification[RayClassification[\"RC_TargetAfter\"] = 5] = \"RC_TargetAfter\";\n})(RayClassification || (RayClassification = {}));\n/* eslint-enable @typescript-eslint/naming-convention */\nexport class PointSearchContext {\n    constructor(tol) {\n        this._tol = tol;\n    }\n    static create(tol = Geometry.smallMetricDistance) {\n        return new PointSearchContext(tol);\n    }\n    panic() {\n        return HalfEdgePositionDetail.create();\n    }\n    // From given edge start point\n    // The edgeHit is reused as the result.\n    reAimFromEdge(edgeHit, ray, targetDistance) {\n        const nodeA = edgeHit.node;\n        const dataA = NodeXYZUV.createNodeAndRayOrigin(nodeA, ray);\n        const dataB = NodeXYZUV.createNodeAndRayOrigin(nodeA.edgeMate, ray);\n        const sideA = -dataA.classifyV(0.0, this._tol);\n        const sideB = -dataB.classifyV(0.0, this._tol);\n        let result;\n        if (sideA * sideB < 0) {\n            // Simple crossing -- just aim into a face\n            if (sideA > 0) {\n                result = edgeHit.resetAsFace(dataA.node);\n            }\n            else {\n                result = edgeHit.resetAsFace(dataB.node);\n            }\n        }\n        else if (sideA === 0 || sideB === 0) {\n            // The usual case is both 0 i.e. ray is clearly along the edge.\n            const alongA = dataA.classifyU(targetDistance, this._tol);\n            const alongB = dataB.classifyU(targetDistance, this._tol);\n            if (alongA === 0 && sideA === 0) {\n                result = edgeHit.resetAsVertex(dataA.node);\n                result.setITag(1);\n            }\n            else if (alongB === 0 && sideB === 0) {\n                result = edgeHit.resetAsVertex(dataB.node);\n                result.setITag(1);\n            }\n            else if (alongA * alongB < 0) {\n                // target is within edge\n                // (.. This is written for the case where both sideA and sideB are zero.\n                //    If only one is zero, this computes a close edge point but the strong \"on\" conclusion might be wrong)\n                const edgeFraction = (targetDistance - dataA.u) / (dataB.u - dataA.u);\n                result = edgeHit.resetAtEdgeAndFraction(dataA.node, edgeFraction);\n                result.setITag(1);\n            }\n            else if (alongA < 0 && alongB < 0) {\n                // target is beyond the edge -- move towards it.\n                if (dataA.u > dataB.u)\n                    result = edgeHit.resetAsVertex(dataA.node);\n                else\n                    result = edgeHit.resetAsVertex(dataB.node);\n            }\n            else {\n                // This shouldn't happen -- maybe as if the initial edge point was not within the edge???\n                if (Math.abs(dataA.u) < this._tol\n                    && Math.abs(dataA.v) < this._tol) {\n                    result = edgeHit.resetAsVertex(dataA.node); // , dataA);\n                }\n                else if (Math.abs(dataB.u) < this._tol\n                    && Math.abs(dataB.v) < this._tol) {\n                    result = edgeHit.resetAsVertex(dataB.node);\n                }\n                else {\n                    edgeHit.resetAsUnknown();\n                    result = this.panic();\n                }\n            }\n        }\n        else {\n            // Both vertices are to same side of the line.   This can't happen for edge point between nodes.\n            edgeHit.resetAsUnknown();\n            result = this.panic();\n        }\n        return result;\n    }\n    // From given edge start point, pick vertex or edge side for proceeding along ray.\n    // RAY IS ASSUMED TO START AT THE VERTEX PRECISELY !!!!\n    reAimFromVertex(searchBase, ray, targetDistance) {\n        const vertexNode = searchBase.node;\n        let result;\n        let outboundEdge = vertexNode;\n        do {\n            // DPoint3d xyzBase;\n            // vu_getDPoint3d(& xyzBase, outboundEdge);\n            const data0 = NodeXYZUV.createNodeAndRayOrigin(outboundEdge.faceSuccessor, ray);\n            const data1 = NodeXYZUV.createNodeAndRayOrigin(outboundEdge.facePredecessor, ray);\n            const u0 = data0.u;\n            // double u1 = data1.GetU ();\n            const v0 = data0.v;\n            const v1 = data1.v;\n            if (Math.abs(v0) < this._tol) {\n                if (Math.abs(u0 - targetDistance) < this._tol) {\n                    // Direct hit at far end\n                    result = searchBase.resetAsVertex(data0.node);\n                    result.setITag(1);\n                    return result;\n                }\n                else if (u0 > targetDistance) {\n                    // Direct hig within edge\n                    const edgeFraction = targetDistance / u0;\n                    result = searchBase.resetAtEdgeAndFraction(outboundEdge, edgeFraction);\n                    return result;\n                }\n                else if (Math.abs(u0) <= this._tol) {\n                    // Unexpected direct hit on the base of the search, but call it a hit....\n                    result = searchBase.resetAsVertex(outboundEdge);\n                    result.setITag(1);\n                    return result;\n                }\n                else if (u0 > this._tol) {\n                    // Advance to vertex  ...\n                    // double edgeFraction = targetDistance / u0;\n                    result = searchBase.resetAsVertex(data0.node);\n                    return result;\n                }\n                else {\n                    // Search direction is exactly opposite this edge.\n                    // See if the other side of the sector is turned even beyond that ...\n                    if (v1 > this._tol) {\n                        result = searchBase.resetAsFace(outboundEdge, outboundEdge);\n                        return result;\n                    }\n                }\n            }\n            else if (v0 < -this._tol) {\n                if (v1 > this._tol) {\n                    // The usual simple entry into an angle < 180\n                    result = searchBase.resetAsFace(outboundEdge, outboundEdge);\n                    return result;\n                }\n            }\n            // NEEDS WORK: angle >= 180 cases !!!!\n            outboundEdge = outboundEdge.vertexSuccessor;\n        } while (outboundEdge !== vertexNode);\n        return this.panic();\n    }\n    // Visit all edges around face.\n    // reset lastBefore and firstAfter describing progress towards target distance on ray.\n    reAimAroundFace(faceNode, ray, targetDistance, // !< distance to target point\n    lastBefore, // CALLER CREATED -- reset as first hit on negative side of ray.\n    firstAfter) {\n        lastBefore.resetAsUndefinedWithTag(-Number.MAX_VALUE);\n        firstAfter.resetAsUndefinedWithTag(Number.MAX_VALUE);\n        const data0 = NodeXYZUV.createNodeAndRayOrigin(faceNode, ray);\n        let data1;\n        let node0 = faceNode;\n        do {\n            const node1 = node0.faceSuccessor;\n            data1 = NodeXYZUV.createNodeAndRayOrigin(node1, ray, data1);\n            const u0 = data0.u;\n            const u1 = data1.u;\n            const v0 = data0.v;\n            const v1 = data1.v;\n            if (Math.abs(v1) < this._tol) {\n                // Vertex hit ...\n                const vertexHit = HalfEdgePositionDetail.createVertex(node1);\n                vertexHit.setDTag(u1);\n                if (Math.abs(u1 - targetDistance) < this._tol) {\n                    firstAfter.setFrom(vertexHit);\n                    lastBefore.setFrom(vertexHit);\n                    return RayClassification.RC_TargetOnVertex;\n                }\n                if (u1 > targetDistance && u1 < firstAfter.getDTag())\n                    firstAfter.setFrom(vertexHit);\n                if (u1 < targetDistance && u1 > lastBefore.getDTag())\n                    lastBefore.setFrom(vertexHit);\n            }\n            else if (v0 * v1 < 0.0) {\n                // Edge Crossing ...\n                const edgeFraction = -v0 / (v1 - v0);\n                const uEdge = Geometry.interpolate(u0, edgeFraction, u1);\n                const edgeHit = HalfEdgePositionDetail.createEdgeAtFraction(data0.node, edgeFraction);\n                edgeHit.setDTag(uEdge);\n                if (Math.abs(uEdge - targetDistance) <= this._tol) {\n                    firstAfter.setFrom(edgeHit);\n                    lastBefore.setFrom(edgeHit);\n                    return RayClassification.RC_TargetOnEdge;\n                }\n                if (uEdge > targetDistance && uEdge < firstAfter.getDTag()) {\n                    firstAfter.setFrom(edgeHit);\n                    firstAfter.setITag(v0 > 0.0 ? -1 : 1);\n                }\n                if (uEdge < targetDistance && uEdge > lastBefore.getDTag()) {\n                    lastBefore.setFrom(edgeHit);\n                    lastBefore.setDTag(uEdge);\n                }\n            }\n            data0.setFrom(data1);\n            node0 = node0.faceSuccessor;\n        } while (node0 !== faceNode);\n        // Returned to start node !!!\n        const afterTag = firstAfter.getITag();\n        firstAfter.setITag(0);\n        lastBefore.setITag(0);\n        if (lastBefore.isUnclassified) {\n            if (firstAfter.isUnclassified)\n                return RayClassification.RC_NoHits;\n            return RayClassification.RC_TargetBefore;\n        }\n        if (firstAfter.isUnclassified\n            || (firstAfter.isEdge && afterTag && afterTag < 0)) {\n            return RayClassification.RC_TargetAfter;\n        }\n        else {\n            return RayClassification.RC_Bracket;\n        }\n    }\n    // Return false if target is reached !!!!\n    /**\n     * Set (replace contents) ray with\n     * * `origin` at start\n     * * `direction` is unit vector from start towards target\n     * * `a` is distance from start to target.\n     * @param start existing position\n     * @param target target xy coordinates\n     * @param ray ray to update\n     */\n    setSearchRay(start, target, ray) {\n        ray.origin.setFromPoint3d(start);\n        Vector3d.createStartEnd(ray.origin, target, ray.direction);\n        ray.direction.z = 0.0;\n        const distanceToTarget = ray.direction.magnitudeXY();\n        ray.a = ray.direction.magnitude();\n        ray.direction.scaleInPlace(1 / ray.a);\n        return distanceToTarget >= this._tol;\n    }\n}\n//# sourceMappingURL=HalfEdgePointInGraphSearch.js.map",
      "start": 1693508126364,
      "end": 1693508126432,
      "sourcemaps": null
    }
  ]
}
