{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/common/lib/esm/geometry/Placement.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Geometry\n */\nimport { IModelStatus } from \"@itwin/core-bentley\";\nimport { Angle, Constant, Matrix3d, Point2d, Point3d, Range2d, Range3d, Transform, Vector3d, YawPitchRollAngles, } from \"@itwin/core-geometry\";\nimport { Frustum } from \"../Frustum\";\nimport { IModelError } from \"../IModelError\";\n/** The placement of a GeometricElement3d. This includes the origin, orientation, and size (bounding box) of the element.\n * All geometry of a GeometricElement are relative to its placement.\n * @public\n */\nexport class Placement3d {\n    constructor(origin, angles, bbox) {\n        this.origin = origin;\n        this.angles = angles;\n        this.bbox = bbox;\n    }\n    /** Get the rotation from local coordinates of this placement to world coordinates. */\n    get rotation() { return this.angles.toMatrix3d(); }\n    /** Get the transform from local coordinates of this placement to world coordinates. */\n    get transform() { return Transform.createOriginAndMatrix(this.origin, this.rotation); }\n    /** determine if this is 3d placement */\n    get is3d() { return true; }\n    /** Create a new Placement3d from a Placement3dProps. */\n    static fromJSON(json) {\n        const props = json ? json : {};\n        return new Placement3d(Point3d.fromJSON(props.origin), YawPitchRollAngles.fromJSON(props.angles), Range3d.fromJSON(props.bbox));\n    }\n    /** Get the 8 corners, in world coordinates, of this placement. */\n    getWorldCorners(out) {\n        const frust = Frustum.fromRange(this.bbox, out);\n        frust.multiply(this.transform);\n        return frust;\n    }\n    /** Set the contents of this Placement3d from another Placement3d */\n    setFrom(other) {\n        this.origin.setFrom(other.origin);\n        this.angles.setFrom(other.angles);\n        this.bbox.setFrom(other.bbox);\n    }\n    /** Determine whether this Placement3d is valid. */\n    get isValid() { return !this.bbox.isNull && Math.max(this.origin.maxAbs(), this.bbox.maxAbs()) < Constant.circumferenceOfEarth; }\n    /** Calculate the axis-aligned bounding box for this placement. */\n    calculateRange() {\n        const range = new Range3d();\n        if (!this.isValid)\n            return range;\n        this.transform.multiplyRange(this.bbox, range);\n        // low and high are not allowed to be equal\n        range.ensureMinLengths();\n        return range;\n    }\n    /** Multiply the Transform of this Placement3d by the specified *other* Transform.\n     * @throws [[IModelError]] if the Transform is invalid for a GeometricElement3d.\n     */\n    multiplyTransform(other) {\n        const transform = other.multiplyTransformTransform(this.transform);\n        const angles = YawPitchRollAngles.createFromMatrix3d(transform.matrix);\n        if (undefined === angles)\n            throw new IModelError(IModelStatus.BadRequest, \"Invalid Transform\");\n        this.angles = angles;\n        this.origin.setFrom(transform.origin);\n    }\n}\n/** The placement of a GeometricElement2d. This includes the origin, rotation, and size (bounding box) of the element.\n * @public\n */\nexport class Placement2d {\n    constructor(origin, angle, bbox) {\n        this.origin = origin;\n        this.angle = angle;\n        this.bbox = bbox;\n    }\n    /** Get the rotation from local coordinates of this placement to world coordinates. */\n    get rotation() { return Matrix3d.createRotationAroundVector(Vector3d.unitZ(), this.angle); }\n    /** Get the transform from local coordinates of this placement to world coordinates. */\n    get transform() { return Transform.createOriginAndMatrix(Point3d.createFrom(this.origin), this.rotation); }\n    /** Create a new Placement2d from a Placement2dProps. */\n    static fromJSON(json) {\n        const props = json ? json : {};\n        return new Placement2d(Point2d.fromJSON(props.origin), Angle.fromJSON(props.angle), Range2d.fromJSON(props.bbox));\n    }\n    /** determine if this is 3d placement */\n    get is3d() { return false; }\n    /** Get the 8 corners, in world coordinates, of this placement. */\n    getWorldCorners(out) {\n        const frust = Frustum.fromRange(this.bbox, out);\n        frust.multiply(this.transform);\n        return frust;\n    }\n    /** Determine whether this Placement2d is valid. */\n    get isValid() { return !this.bbox.isNull && Math.max(this.origin.maxAbs(), this.bbox.maxAbs()) < Constant.circumferenceOfEarth; }\n    /** Set the contents of this Placement2d from another Placement2d */\n    setFrom(other) {\n        this.origin.setFrom(other.origin);\n        this.angle.setFrom(other.angle);\n        this.bbox.setFrom(other.bbox);\n    }\n    /** Calculate the axis-aligned bounding box for this placement. */\n    calculateRange() {\n        const range = new Range3d();\n        if (!this.isValid)\n            return range;\n        this.transform.multiplyRange(Range3d.createRange2d(this.bbox, 0), range);\n        // low and high are not allowed to be equal\n        range.ensureMinLengths();\n        range.low.z = -1.0; // is the 2dFrustumDepth, which === 1 meter\n        range.high.z = 1.0;\n        return range;\n    }\n    /** Multiply the Transform of this Placement2d by the specified *other* Transform.\n     * @throws [[IModelError]] if the Transform is invalid for a GeometricElement2d.\n     */\n    multiplyTransform(other) {\n        const transform = other.multiplyTransformTransform(this.transform);\n        const angles = YawPitchRollAngles.createFromMatrix3d(transform.matrix);\n        if ((undefined === angles) || !angles.pitch.isAlmostZero || !angles.roll.isAlmostZero)\n            throw new IModelError(IModelStatus.BadRequest, \"Invalid Transform\");\n        this.angle = angles.yaw;\n        this.origin.setFrom(transform.origin);\n    }\n}\n//# sourceMappingURL=Placement.js.map",
      "start": 1693508120782,
      "end": 1693508120887,
      "sourcemaps": null
    }
  ]
}
