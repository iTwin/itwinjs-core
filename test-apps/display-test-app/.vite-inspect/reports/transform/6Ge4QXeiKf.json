{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/AccuSnap.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module LocatingElements\n */\nimport { BeDuration, Id64 } from \"@itwin/core-bentley\";\nimport { CurveCurve, GeometryQuery, IModelJson as GeomJson, Point2d, Point3d, Vector3d } from \"@itwin/core-geometry\";\nimport { ElementLocateManager, LocateAction, LocateFilterStatus, LocateResponse, SnapStatus } from \"./ElementLocateManager\";\nimport { HitDetailType, HitGeomType, HitPriority, HitSource, IntersectDetail, SnapDetail, SnapHeat, SnapMode } from \"./HitDetail\";\nimport { IModelApp } from \"./IModelApp\";\nimport { IconSprites, SpriteLocation } from \"./Sprites\";\nimport { BeButton, BeButtonEvent, InputSource } from \"./tools/Tool\";\nimport { ToolSettings } from \"./tools/ToolSettings\";\n// cspell:ignore dont primitivetools\n/** Virtual cursor for using AccuSnap with touch input.\n * @internal\n */\nexport class TouchCursor {\n    constructor(vp) {\n        this.position = new Point3d();\n        this._offsetPosition = new Point3d();\n        this._isSelected = false;\n        this._isDragging = false;\n        this._inTouchTap = false;\n        this._size = vp.pixelsFromInches(0.3);\n        this._yOffset = this._size * 1.75;\n        this.viewport = vp;\n    }\n    setPosition(vp, worldLocation) {\n        const pointNpc = vp.worldToNpc(worldLocation);\n        if (pointNpc.z < 0.0 || pointNpc.z > 1.0)\n            pointNpc.z = 0.5; // move inside frustum.\n        const viewLocation = vp.npcToView(pointNpc);\n        if (!vp.viewRect.containsPoint(viewLocation))\n            return false; // outside this viewport rect\n        viewLocation.x = Math.floor(viewLocation.x) + 0.5;\n        viewLocation.y = Math.floor(viewLocation.y) + 0.5;\n        viewLocation.z = 0.0;\n        const offsetLocation = new Point3d(viewLocation.x, viewLocation.y - this._yOffset, viewLocation.z);\n        if (!vp.viewRect.containsPoint(offsetLocation))\n            return false; // outside this viewport rect\n        this.position.setFrom(viewLocation);\n        this._offsetPosition.setFrom(offsetLocation);\n        if (vp !== this.viewport) {\n            this.viewport.invalidateDecorations();\n            this.viewport = vp;\n        }\n        vp.invalidateDecorations();\n        return true;\n    }\n    drawHandle(ctx, filled) {\n        ctx.beginPath();\n        ctx.moveTo(-this._size, 0);\n        ctx.bezierCurveTo(-this._size, -this._size * 0.85, -this._size * 0.6, -this._yOffset * 0.6, 0, -this._yOffset * 0.8);\n        ctx.bezierCurveTo(this._size * 0.6, -this._yOffset * 0.6, this._size, -this._size * 0.85, this._size, 0);\n        ctx.arc(0, 0, this._size, 0, Math.PI);\n        if (filled)\n            ctx.fill();\n        ctx.stroke();\n        ctx.beginPath();\n        ctx.arc(0, 0, this._size * 0.75, 0, 2 * Math.PI);\n        ctx.stroke();\n        ctx.beginPath();\n        ctx.moveTo(-this._size * 0.4, 0);\n        ctx.lineTo(this._size * 0.4, 0);\n        ctx.moveTo(-this._size * 0.4, this._size * 0.25);\n        ctx.lineTo(this._size * 0.4, this._size * 0.25);\n        ctx.stroke();\n    }\n    drawDecoration(ctx) {\n        ctx.lineWidth = 1;\n        ctx.strokeStyle = \"rgba(0,0,0,.75)\";\n        ctx.fillStyle = \"white\";\n        ctx.strokeRect(-2, -(this._yOffset + 2), 5, 5);\n        ctx.fillRect(-1, -(this._yOffset + 1), 3, 3);\n        ctx.lineWidth = 3.5;\n        ctx.lineCap = \"round\";\n        ctx.fillStyle = this._isSelected ? \"rgba(35,187,252,.25)\" : \"rgba(255,215,0,.25)\";\n        ctx.shadowColor = \"black\";\n        ctx.shadowBlur = 10;\n        this.drawHandle(ctx, true);\n        ctx.lineWidth = 1.5;\n        ctx.strokeStyle = this._isSelected ? \"rgba(35,187,252,.75)\" : \"rgba(255,215,0,.75)\";\n        ctx.shadowBlur = 0;\n        this.drawHandle(ctx, false);\n    }\n    isSelected(pt) { return this.position.distance(Point3d.create(pt.x, pt.y)) < this._size; }\n    isButtonHandled(ev) { return (BeButton.Data === ev.button && InputSource.Touch === ev.inputSource && !this._inTouchTap); }\n    doTouchMove(ev) {\n        if (undefined === ev.viewport || !ev.isSingleTouch)\n            return false;\n        if (!this._isDragging || !this.setPosition(ev.viewport, ev.point))\n            return false;\n        ev.viewPoint = this._offsetPosition;\n        IModelApp.toolAdmin.convertTouchMoveToMotion(ev); // eslint-disable-line @typescript-eslint/no-floating-promises\n        return true;\n    }\n    doTouchMoveStart(ev, startEv) {\n        if (undefined === ev.viewport || !ev.isSingleTouch)\n            return false;\n        return (this._isDragging = this.isSelected(startEv.viewPoint));\n    }\n    doTouchStart(ev) {\n        this._isSelected = ev.isSingleTouch && this.isSelected(ev.viewPoint);\n        if (undefined !== ev.viewport)\n            ev.viewport.invalidateDecorations();\n    }\n    doTouchEnd(ev) {\n        if (this._isDragging && undefined !== ev.viewport)\n            IModelApp.toolAdmin.currentInputState.fromPoint(ev.viewport, this._offsetPosition, InputSource.Touch); // Current location should reflect virtual cursor offset...\n        this._isSelected = this._isDragging = false;\n        if (undefined !== ev.viewport)\n            ev.viewport.invalidateDecorations();\n    }\n    async doTouchTap(ev) {\n        if (undefined === ev.viewport || !ev.isSingleTouch || 1 !== ev.tapCount)\n            return false;\n        if (!this.isSelected(ev.viewPoint)) {\n            if (!this.setPosition(ev.viewport, ev.point))\n                return false;\n            ev.viewPoint = this._offsetPosition;\n            IModelApp.toolAdmin.convertTouchMoveToMotion(ev); // eslint-disable-line @typescript-eslint/no-floating-promises\n            return false;\n        }\n        ev.viewPoint = this._offsetPosition;\n        this._inTouchTap = true;\n        await IModelApp.toolAdmin.convertTouchTapToButtonDownAndUp(ev);\n        this._inTouchTap = false;\n        return true;\n    }\n    static createFromTouchTap(ev) {\n        if (undefined === ev.viewport || !ev.isSingleTouch || 1 !== ev.tapCount)\n            return undefined;\n        const touchCursor = new TouchCursor(ev.viewport);\n        if (!touchCursor.setPosition(ev.viewport, ev.point) && !touchCursor.setPosition(ev.viewport, ev.viewport.view.getCenter()))\n            return undefined;\n        ev.viewPoint = touchCursor._offsetPosition;\n        IModelApp.toolAdmin.convertTouchMoveToMotion(ev); // eslint-disable-line @typescript-eslint/no-floating-promises\n        return touchCursor;\n    }\n}\n/** AccuSnap is an aide for snapping to interesting points on elements or decorations as the cursor moves over them.\n * @see [Using AccuSnap]($docs/learning/frontend/primitivetools.md#AccuSnap)\n * @public\n * @extensions\n */\nexport class AccuSnap {\n    constructor() {\n        /** Views that need to be flashed */\n        this.needFlash = new Set();\n        /** Views that are already flashed */\n        this.areFlashed = new Set();\n        /** The \"+\" that indicates where the snap point is */\n        this.cross = new SpriteLocation();\n        /** The icon that indicates what type of snap is active */\n        this.icon = new SpriteLocation();\n        /** The icon that indicates an error */\n        this.errorIcon = new SpriteLocation();\n        /** Number of times \"suppress\" has been called -- unlike suspend this is not automatically cleared by tools */\n        this._suppressed = 0;\n        /** Location of cursor when we last checked for motion */\n        this._lastCursorPos = new Point2d();\n        /** @internal */\n        this.toolState = new AccuSnap.ToolState();\n        /** @internal */\n        this._settings = new AccuSnap.Settings();\n    }\n    /** @internal */\n    onInitialized() { }\n    get _searchDistance() { return this.isLocateEnabled ? 1.0 : this._settings.searchDistance; }\n    get _hotDistanceInches() { return IModelApp.locateManager.apertureInches * this._settings.hotDistanceFactor; }\n    /** Whether locate of elements under the cursor is enabled by the current InteractiveTool. */\n    get isLocateEnabled() { return this.toolState.locate; }\n    /** Whether snapping to elements under the cursor is enabled by the current InteractiveTool. */\n    get isSnapEnabled() { return this.toolState.enabled; }\n    /** Whether the user setting for snapping is enabled. Snapping is done only when both the user and current InteractiveTool have enabled it. */\n    get isSnapEnabledByUser() { return this._settings.enableFlag; }\n    /** AccuSnap user settings */\n    get userSettings() { return this._settings; }\n    isFlashed(view) { return (this.areFlashed.has(view)); }\n    needsFlash(view) { return (this.needFlash.has(view)); }\n    setNeedsFlash(view) {\n        this.needFlash.add(view);\n        this.clearIsFlashed(view);\n        view.invalidateDecorations();\n    }\n    setIsFlashed(view) { this.areFlashed.add(view); }\n    clearIsFlashed(view) { this.areFlashed.delete(view); }\n    static toSnapDetail(hit) { return (hit && hit instanceof SnapDetail) ? hit : undefined; }\n    /** Currently active snap */\n    getCurrSnapDetail() { return AccuSnap.toSnapDetail(this.currHit); }\n    /** Determine whether there is a current hit that is *hot*. */\n    get isHot() {\n        const currSnap = this.getCurrSnapDetail();\n        return !currSnap ? false : currSnap.isHot;\n    }\n    /** Optional ids to never flash. Useful for tools like \"trim curve\" that won't want a flashed segment to obscure a result preview.\n     * @note Cleared when a primitive or view tool is started and saved/restored when a primitive tool is suspended/unsuspended.\n     * @public\n     */\n    neverFlash(ids) {\n        if (undefined === ids) {\n            this.toolState.neverFlash = undefined;\n            return;\n        }\n        const newIds = new Set();\n        for (const id of Id64.iterable(ids))\n            newIds.add(id);\n        this.toolState.neverFlash = (0 !== newIds.size ? newIds : undefined);\n    }\n    /** @internal */\n    destroy() {\n        this.currHit = undefined;\n        this.aSnapHits = undefined;\n    }\n    get _doSnapping() { return this.isSnapEnabled && this.isSnapEnabledByUser && !this._isSnapSuspended; }\n    get _isSnapSuspended() { return (0 !== this._suppressed || 0 !== this.toolState.suspended); }\n    /** Get the current snap divisor to use to use for SnapMode.NearestKeypoint.\n     * @public\n     */\n    get keypointDivisor() { return 2; }\n    /** Get the current active SnapModes. SnapMode position determines priority, with the first entry being the highest. The SnapDetail will be returned for the first SnapMode that produces a hot snap.\n     * @public\n     */\n    getActiveSnapModes() {\n        const snaps = [];\n        snaps.push(SnapMode.NearestKeypoint);\n        return snaps;\n    }\n    /** Can be implemented by a subclass of AccuSnap to implement a SnapMode override that applies only to the next point.\n     * This method will be called whenever a new tool is installed and on button events.\n     * @internal\n     */\n    synchSnapMode() { }\n    /** Check whether current tentative snap has valid curve geometry for finding extended intersections. */\n    get _searchForExtendedIntersections() {\n        const snap = IModelApp.tentativePoint.getCurrSnap();\n        return (undefined !== snap && undefined !== snap.primitive);\n    }\n    /**\n     * Check to see whether its appropriate to generate an AccuSnap point, given the current user\n     * and command settings, and whether a tentative point is currently active.\n     */\n    get isActive() {\n        // Unless we're snapping in intersect mode (to find extended intersections), skip if tentative point active...\n        if (IModelApp.tentativePoint.isActive) {\n            if (!this._doSnapping || !this._searchForExtendedIntersections)\n                return false;\n            const snaps = this.getActiveSnapModes();\n            for (const snap of snaps) {\n                if (snap === SnapMode.Intersection)\n                    return true;\n            }\n            return false;\n        }\n        return this._doSnapping || this.isLocateEnabled;\n    }\n    initializeForCheckMotion() {\n        this._lastCursorPos.setFrom(IModelApp.toolAdmin.currentInputState.lastMotion);\n    }\n    /** Clear the current AccuSnap info. */\n    clear() { this.setCurrHit(undefined); }\n    /** @internal */\n    setCurrHit(newHit) {\n        const newSnap = AccuSnap.toSnapDetail(newHit);\n        const currSnap = this.getCurrSnapDetail();\n        const sameElem = (undefined !== newHit && newHit.isSameHit(this.currHit));\n        const sameHit = (sameElem && !newSnap);\n        const sameSnap = (sameElem && undefined !== newSnap && undefined !== currSnap);\n        const samePt = (sameHit || (sameSnap && newSnap.snapPoint.isAlmostEqual(currSnap.snapPoint)));\n        const sameHot = (sameHit || (sameSnap && (this.isHot === newSnap.isHot)));\n        const sameBaseSnapMode = (!newSnap || !currSnap || newSnap.snapMode === currSnap.snapMode);\n        const sameType = (sameHot && (!currSnap || (currSnap.getHitType() === newHit.getHitType())));\n        // see if it is the same point on the same element, the hot flags are the same multiple snaps, and the snap modes are the same\n        if (samePt && sameType && sameBaseSnapMode) {\n            // we know that nothing about the screen could change, just save the new hit and return to avoid screen flash\n            this.currHit = newHit;\n            return;\n        }\n        this.erase();\n        // if we hit the same element with the same \"hotness\" as last time, we don't need to erase it\n        //  multiple snaps: but only if the old and new snap modes are the same\n        if (!sameHot || !sameBaseSnapMode) {\n            this.unFlashViews();\n            this.setFlashHit(newHit);\n        }\n        // if we didn't get a new hit, we're done\n        if (undefined === (this.currHit = newHit))\n            return;\n        // draw sprites for this hit\n        this.showSnapSprite();\n    }\n    /** flash a hit in a single view. */\n    flashHitInView(hit, context) {\n        const viewport = context.viewport;\n        if (!viewport || !this.hitShouldBeHilited(hit) || !this.needsFlash(viewport))\n            return;\n        hit.draw(context);\n        this.setIsFlashed(viewport);\n    }\n    setNeedsFlashView(view) {\n        if (!this.isFlashed(view) && !this.needsFlash(view))\n            this.setNeedsFlash(view);\n    }\n    /** flash a hit in its view. */\n    setFlashHit(hit) {\n        if (hit !== undefined && this.hitShouldBeHilited(hit))\n            this.setNeedsFlashView(hit.viewport);\n    }\n    /** @internal */\n    erase() {\n        this.clearToolTip(undefined); // make sure there's no tooltip up.\n        this.clearSprites(); // remove all sprites from the screen\n    }\n    showElemInfo(viewPt, vp, hit, delay) {\n        if (!IModelApp.viewManager.doesHostHaveFocus || undefined !== this._toolTipPromise)\n            return;\n        const promise = this._toolTipPromise = delay.executeAfter(async () => {\n            if (promise !== this._toolTipPromise)\n                return; // we abandoned this request during delay\n            try {\n                const msg = await IModelApp.toolAdmin.getToolTip(hit);\n                if (this._toolTipPromise === promise) // have we abandoned this request while awaiting getToolTip?\n                    this.showLocateMessage(viewPt, vp, msg);\n            }\n            catch (error) { } // happens if getToolTip was canceled\n        });\n    }\n    showLocateMessage(viewPt, vp, msg) {\n        if (IModelApp.viewManager.doesHostHaveFocus)\n            vp.openToolTip(msg, viewPt);\n    }\n    /** @internal */\n    displayToolTip(viewPt, vp, uorPt) {\n        // if the tooltip is already displayed, or if user doesn't want it, quit.\n        if (!this._settings.toolTip || !IModelApp.notifications.isToolTipSupported || IModelApp.notifications.isToolTipOpen)\n            return;\n        const accuSnapHit = this.currHit;\n        const tpHit = IModelApp.tentativePoint.getCurrSnap();\n        // if we don't have either an AccuSnap or a tentative point hit, quit.\n        if (!accuSnapHit && !tpHit && !this.errorIcon.isActive)\n            return;\n        let theHit;\n        // determine which type of hit\n        if (tpHit) {\n            if (uorPt) {\n                // see if he came back somewhere near the currently snapped element\n                const aperture = (this._settings.stickyFactor * vp.pixelsFromInches(IModelApp.locateManager.apertureInches) / 2.0) + 1.5;\n                if (!IModelApp.locateManager.picker.testHit(tpHit, vp, uorPt, aperture, IModelApp.locateManager.options))\n                    return;\n            }\n            theHit = tpHit;\n        }\n        else {\n            theHit = accuSnapHit;\n        }\n        // if we're currently showing an error, get the error message...otherwise display hit info...\n        if (!this.errorIcon.isActive && theHit) {\n            this.showElemInfo(viewPt, vp, theHit, this._settings.toolTipDelay);\n            return;\n        }\n        // If we have an error explanation...use it as is!\n        if (this.explanation) {\n            this.showLocateMessage(viewPt, vp, this.explanation);\n            return;\n        }\n        // if we don't have an explanation yet, translate the error code.\n        if (!this.errorKey)\n            return;\n        this.explanation = IModelApp.localization.getLocalizedString(`iModelJs:${this.errorKey}`);\n        if (!this.explanation)\n            return;\n        this.showLocateMessage(viewPt, vp, this.explanation);\n    }\n    /** @internal */\n    clearToolTip(ev) {\n        // Throw away any stale request for a tooltip message\n        this._toolTipPromise = undefined;\n        if (!IModelApp.notifications.isToolTipOpen)\n            return;\n        if (ev && (5 > ev.viewPoint.distanceXY(IModelApp.notifications.toolTipLocation)))\n            return;\n        IModelApp.notifications.clearToolTip();\n    }\n    /** Display the sprites for the current snap to indicate its position on the screen and what snap mode it represents. */\n    showSnapSprite() {\n        const snap = this.getCurrSnapDetail();\n        if (!snap)\n            return;\n        const crossPt = snap.snapPoint;\n        const viewport = snap.viewport;\n        const crossSprite = IconSprites.getSpriteFromUrl(`${IModelApp.publicPath}${snap.isHot ? \"sprites/SnapCross.png\" : \"sprites/SnapUnfocused.png\"}`);\n        this.cross.activate(crossSprite, viewport, crossPt);\n        const snapSprite = snap.sprite;\n        if (snapSprite)\n            this.icon.activate(snapSprite, viewport, AccuSnap.adjustIconLocation(viewport, crossPt, snapSprite.size));\n    }\n    static adjustIconLocation(vp, input, iconSize) {\n        const out = vp.worldToView(input);\n        out.x += (iconSize.x / 3.0);\n        out.y -= (iconSize.y * 1.3);\n        return vp.viewToWorld(out, out);\n    }\n    /** try to indicate what's wrong with the current point (why we're not snapping). */\n    showSnapError(out, ev) {\n        this.explanation = out.explanation;\n        this.errorKey = out.reason;\n        this.errorIcon.deactivate();\n        const vp = ev.viewport;\n        let errorSprite;\n        switch (out.snapStatus) {\n            case SnapStatus.FilteredByApp:\n                errorSprite = IconSprites.getSpriteFromUrl(`${IModelApp.publicPath}sprites/SnapAppFiltered.png`);\n                break;\n            case SnapStatus.FilteredByAppQuietly:\n                this.errorKey = undefined;\n                break;\n            case SnapStatus.NotSnappable:\n                errorSprite = IconSprites.getSpriteFromUrl(`${IModelApp.publicPath}sprites/SnapNotSnappable.png`);\n                this.errorKey = ElementLocateManager.getFailureMessageKey(\"NotSnappable\");\n                break;\n        }\n        if (!errorSprite)\n            return;\n        const spriteSize = errorSprite.size;\n        const pt = AccuSnap.adjustIconLocation(vp, ev.rawPoint, spriteSize);\n        this.errorIcon.activate(errorSprite, vp, pt);\n    }\n    clearSprites() {\n        this.errorIcon.deactivate();\n        this.cross.deactivate();\n        this.icon.deactivate();\n    }\n    /** determine whether a hit should be hilited or not. */\n    hitShouldBeHilited(hit) {\n        if (!hit)\n            return false;\n        if (hit.isModelHit || hit.isMapHit)\n            return false; // Avoid annoying flashing of reality models.\n        if (this.toolState.neverFlash && this.toolState.neverFlash.has(hit.sourceId))\n            return false;\n        const snap = AccuSnap.toSnapDetail(hit);\n        return !snap || snap.isHot || this._settings.hiliteColdHits;\n    }\n    unFlashViews() {\n        this.needFlash.clear();\n        for (const vp of this.areFlashed)\n            vp.flashedId = undefined;\n        this.areFlashed.clear();\n    }\n    /** @internal */\n    adjustPointIfHot(pt, view) {\n        const currSnap = this.getCurrSnapDetail();\n        if (!currSnap || !currSnap.isHot || view !== currSnap.viewport)\n            return;\n        pt.setFrom(currSnap.adjustedPoint);\n    }\n    /** Implemented by sub-classes to update ui to show current enabled state.\n     * @internal\n     */\n    onEnabledStateChange(_isEnabled, _wasEnabled) { }\n    /** @internal */\n    getHitAndList(holder) {\n        const hit = this.currHit;\n        if (hit) {\n            holder.setHitList(this.aSnapHits);\n            this.aSnapHits = undefined;\n        }\n        return hit;\n    }\n    initCmdState() {\n        this.toolState.suspended = 0;\n        this.toolState.neverFlash = undefined;\n    }\n    /** @internal */\n    suspend(doSuspend) {\n        const previousDoSnapping = this._doSnapping;\n        if (doSuspend)\n            this.toolState.suspended++;\n        else if (this.toolState.suspended > 0)\n            this.toolState.suspended--;\n        this.onEnabledStateChange(this._doSnapping, previousDoSnapping);\n    }\n    /** @internal */\n    suppress(doSuppress) {\n        const previousDoSnapping = this._doSnapping;\n        if (doSuppress)\n            this._suppressed++;\n        else if (this._suppressed > 0)\n            this._suppressed--;\n        this.onEnabledStateChange(this._doSnapping, previousDoSnapping);\n        return this._suppressed;\n    }\n    /** Turn AccuSnap on or off */\n    enableSnap(yesNo) {\n        const previousDoSnapping = this._doSnapping;\n        this.toolState.enabled = yesNo;\n        if (!yesNo) {\n            this.clear();\n            if (undefined !== this.touchCursor && !this.wantVirtualCursor) {\n                this.touchCursor = undefined;\n                IModelApp.viewManager.invalidateDecorationsAllViews();\n            }\n        }\n        this.onEnabledStateChange(this._doSnapping, previousDoSnapping);\n    }\n    /** @internal */\n    intersectXY(tpSnap, second) {\n        // Get single segment curve from each snap to intersect...\n        const tpSegment = tpSnap.getCurvePrimitive();\n        if (undefined === tpSegment)\n            return undefined;\n        const segment = second.getCurvePrimitive();\n        if (undefined === segment)\n            return undefined;\n        const worldToView = second.viewport.worldToViewMap.transform0;\n        const detail = CurveCurve.intersectionProjectedXYPairs(worldToView, tpSegment, true, segment, true);\n        if (0 === detail.length)\n            return undefined;\n        let closeIndex = 0;\n        if (detail.length > 1) {\n            const snapPt = worldToView.multiplyPoint3d(HitGeomType.Point === tpSnap.geomType && HitGeomType.Point !== second.geomType ? second.getPoint() : tpSnap.getPoint(), 1); // Don't check distance from arc centers...\n            let lastDist;\n            for (let i = 0; i < detail.length; i++) {\n                const testPt = worldToView.multiplyPoint3d(detail[i].detailA.point, 1);\n                const testDist = snapPt.realDistanceXY(testPt);\n                if (undefined !== testDist && (undefined === lastDist || testDist < lastDist)) {\n                    lastDist = testDist;\n                    closeIndex = i;\n                }\n            }\n        }\n        const intersect = new IntersectDetail(tpSnap, SnapHeat.InRange, detail[closeIndex].detailA.point, segment, second.sourceId); // Should be ok to share hit detail with tentative...\n        intersect.primitive = tpSegment; // Just save single segment that was intersected for line strings/shapes...\n        return intersect;\n    }\n    /** @internal */\n    static async requestSnap(thisHit, snapModes, hotDistanceInches, keypointDivisor, hitList, out) {\n        if (thisHit.isModelHit || thisHit.isMapHit || thisHit.isClassifier) {\n            if (snapModes.includes(SnapMode.Nearest)) {\n                if (out)\n                    out.snapStatus = SnapStatus.Success;\n                return new SnapDetail(thisHit, SnapMode.Nearest, SnapHeat.InRange);\n            }\n            else if (1 === snapModes.length && snapModes.includes(SnapMode.Intersection)) {\n                if (out)\n                    out.snapStatus = SnapStatus.NoSnapPossible;\n                return undefined;\n            }\n            else {\n                if (out)\n                    out.snapStatus = SnapStatus.Success;\n                const realitySnap = new SnapDetail(thisHit, SnapMode.Nearest, SnapHeat.None);\n                realitySnap.sprite = undefined; // Don't show a snap mode that isn't applicable, but still accept hit point...\n                return realitySnap;\n            }\n        }\n        const hitVp = thisHit.viewAttachment ? thisHit.viewAttachment.viewport : thisHit.viewport;\n        if (undefined !== thisHit.subCategoryId && !thisHit.isExternalIModelHit) {\n            const appearance = hitVp.getSubCategoryAppearance(thisHit.subCategoryId);\n            if (appearance.dontSnap) {\n                if (out) {\n                    out.snapStatus = SnapStatus.NotSnappable;\n                    out.explanation = IModelApp.localization.getLocalizedString(`iModelJs:${ElementLocateManager.getFailureMessageKey(\"NotSnappableSubCategory\")}`);\n                }\n                return undefined;\n            }\n        }\n        const requestProps = {\n            id: thisHit.sourceId,\n            testPoint: thisHit.testPoint,\n            closePoint: thisHit.hitPoint,\n            worldToView: hitVp.worldToViewMap.transform0.toJSON(),\n            viewFlags: hitVp.viewFlags,\n            snapModes,\n            snapAperture: hitVp.pixelsFromInches(hotDistanceInches),\n            snapDivisor: keypointDivisor,\n            subCategoryId: thisHit.subCategoryId,\n            geometryClass: thisHit.geometryClass,\n        };\n        const thisGeom = (thisHit.isElementHit ? IModelApp.viewManager.overrideElementGeometry(thisHit) : IModelApp.viewManager.getDecorationGeometry(thisHit));\n        if (undefined !== thisGeom) {\n            requestProps.decorationGeometry = [{ id: thisHit.sourceId, geometryStream: thisGeom }];\n        }\n        else if (!thisHit.isElementHit) {\n            if (out)\n                out.snapStatus = SnapStatus.NoSnapPossible;\n            return undefined;\n        }\n        if (snapModes.includes(SnapMode.Intersection)) {\n            if (undefined !== hitList) {\n                for (const hit of hitList.hits) {\n                    if (thisHit.sourceId === hit.sourceId || thisHit.iModel !== hit.iModel)\n                        continue;\n                    const geom = (hit.isElementHit ? IModelApp.viewManager.overrideElementGeometry(hit) : IModelApp.viewManager.getDecorationGeometry(hit));\n                    if (undefined !== geom) {\n                        if (undefined === requestProps.decorationGeometry)\n                            requestProps.decorationGeometry = [{ id: thisHit.sourceId, geometryStream: geom }];\n                        else\n                            requestProps.decorationGeometry.push({ id: thisHit.sourceId, geometryStream: geom });\n                    }\n                    else if (!hit.isElementHit) {\n                        continue;\n                    }\n                    if (undefined === requestProps.intersectCandidates)\n                        requestProps.intersectCandidates = [hit.sourceId];\n                    else\n                        requestProps.intersectCandidates.push(hit.sourceId);\n                    if (5 === requestProps.intersectCandidates.length)\n                        break; // Search for intersection with a few of the next best hits...\n                }\n            }\n            if (1 === snapModes.length && undefined === requestProps.intersectCandidates) {\n                if (out)\n                    out.snapStatus = SnapStatus.NoSnapPossible;\n                return undefined; // Don't make back end request when only doing intersection snap when we don't have another hit to intersect with...\n            }\n        }\n        try {\n            const result = await thisHit.iModel.requestSnap(requestProps);\n            if (out)\n                out.snapStatus = result.status;\n            if (result.status !== SnapStatus.Success)\n                return undefined;\n            const parseCurve = (json) => {\n                const parsed = undefined !== json ? GeomJson.Reader.parse(json) : undefined;\n                return parsed instanceof GeometryQuery && \"curvePrimitive\" === parsed.geometryCategory ? parsed : undefined;\n            };\n            const snapPoint = Point3d.fromJSON(result.snapPoint);\n            const displayTransform = undefined !== thisHit.modelId ? thisHit.viewport.view.computeDisplayTransform({\n                modelId: thisHit.modelId,\n                elementId: thisHit.sourceId,\n                viewAttachmentId: thisHit.viewAttachment?.id,\n            }) : undefined;\n            displayTransform?.multiplyPoint3d(snapPoint, snapPoint);\n            const snap = new SnapDetail(thisHit, result.snapMode, result.heat, snapPoint);\n            snap.setCurvePrimitive(parseCurve(result.curve), displayTransform, result.geomType);\n            if (undefined !== result.parentGeomType)\n                snap.parentGeomType = result.parentGeomType;\n            // Update hitPoint from readPixels with exact point location corrected to surface/edge geometry.\n            if (undefined !== result.hitPoint) {\n                snap.hitPoint.setFromJSON(result.hitPoint);\n                displayTransform?.multiplyPoint3d(snap.hitPoint, snap.hitPoint);\n            }\n            // Apply display transform to normal.\n            if (undefined !== result.normal) {\n                snap.normal = Vector3d.fromJSON(result.normal);\n                displayTransform?.matrix.multiplyVector(snap.normal, snap.normal);\n                snap.normal.normalizeInPlace();\n            }\n            if (SnapMode.Intersection !== snap.snapMode)\n                return snap;\n            if (undefined === result.intersectId)\n                return undefined;\n            const otherPrimitive = parseCurve(result.intersectCurve);\n            if (undefined === otherPrimitive)\n                return undefined;\n            const intersect = new IntersectDetail(snap, snap.heat, snap.snapPoint, otherPrimitive, result.intersectId);\n            return intersect;\n        }\n        catch (_err) {\n            if (out)\n                out.snapStatus = SnapStatus.Aborted;\n            return undefined;\n        }\n    }\n    async getAccuSnapDetail(hitList, out) {\n        const thisHit = hitList.getNextHit();\n        if (undefined === thisHit)\n            return undefined;\n        const filterStatus = (this.isLocateEnabled ? await IModelApp.locateManager.filterHit(thisHit, LocateAction.AutoLocate, out) : LocateFilterStatus.Accept);\n        if (LocateFilterStatus.Accept !== filterStatus) {\n            out.snapStatus = SnapStatus.FilteredByApp;\n            return undefined;\n        }\n        let snapModes;\n        if (IModelApp.tentativePoint.isActive) {\n            snapModes = [];\n            snapModes.push(SnapMode.Nearest); // Special case: isActive only allows snapping with tentative to find extended intersections...\n        }\n        else {\n            snapModes = this.getActiveSnapModes(); // Get the list of point snap modes to consider\n        }\n        const thisSnap = await AccuSnap.requestSnap(thisHit, snapModes, this._hotDistanceInches, this.keypointDivisor, hitList, out);\n        if (undefined === thisSnap)\n            return undefined;\n        if (IModelApp.tentativePoint.isActive) {\n            const tpSnap = IModelApp.tentativePoint.getCurrSnap();\n            if (undefined === tpSnap)\n                return undefined;\n            const intersectSnap = this.intersectXY(tpSnap, thisSnap);\n            if (undefined === intersectSnap)\n                return undefined;\n            hitList.setCurrentHit(thisHit);\n            return intersectSnap;\n        }\n        IModelApp.accuDraw.onSnap(thisSnap); // AccuDraw can adjust nearest snap to intersection of circle (polar distance lock) or line (axis lock) with snapped to curve...\n        hitList.setCurrentHit(thisHit);\n        return thisSnap;\n    }\n    /** Request a snap from the backend for the supplied HitDetail.\n     * @param hit The HitDetail to snap to.\n     * @param snapMode Optional SnapMode, uses active snap modes if not specified.\n     * @return A Promise for the SnapDetail or undefined if no snap could be created.\n     */\n    async doSnapRequest(hit, snapMode) {\n        let snapModes;\n        if (undefined === snapMode)\n            snapModes = this.getActiveSnapModes();\n        else\n            snapModes = [snapMode];\n        return AccuSnap.requestSnap(hit, snapModes, this._hotDistanceInches, this.keypointDivisor);\n    }\n    findHits(ev, force = false) {\n        // When using AccuSnap to locate elements, we have to start with the datapoint adjusted\n        // for locks and not the raw point. Otherwise, when grid/unit lock are on, we locate elements by\n        // points not on the grid. This causes them to be \"pulled\" off the grid when they are accepted. On\n        // the other hand, when NOT locating, we need to use the raw point so we can snap to elements\n        // away from the grid.\n        const testPoint = this.isLocateEnabled ? ev.point : ev.rawPoint;\n        const vp = ev.viewport;\n        const picker = IModelApp.locateManager.picker;\n        const options = IModelApp.locateManager.options.clone(); // Copy to avoid changing out from under active Tool...\n        // NOTE: Since TestHit will use the same HitSource as the input hit we only need to sets this for DoPick...\n        options.hitSource = this.isSnapEnabled ? HitSource.AccuSnap : HitSource.MotionLocate;\n        let aperture = (vp.pixelsFromInches(IModelApp.locateManager.apertureInches) / 2.0) + 1.5;\n        this.initializeForCheckMotion();\n        aperture *= this._searchDistance;\n        if (0 === picker.doPick(vp, testPoint, aperture, options)) {\n            this.aSnapHits = undefined; // Clear any previous hit list so reset won't cycle through hits cursor is no longer over, etc.\n            return SnapStatus.NoElements;\n        }\n        this.aSnapHits = picker.getHitList(true); // take ownership of the pickElem hit list.\n        // see if we should keep the current hit\n        const canBeSticky = !force && this.aSnapHits.length > 1 && this.currHit && (HitDetailType.Intersection !== this.currHit.getHitType() && this.currHit.priority < HitPriority.PlanarSurface);\n        if (canBeSticky) {\n            for (let iHit = 1; iHit < this.aSnapHits.length; ++iHit) {\n                const thisHit = this.aSnapHits.hits[iHit];\n                if (!thisHit.isSameHit(this.currHit))\n                    continue;\n                this.aSnapHits.removeHit(iHit);\n                this.aSnapHits.insertHit(0, thisHit);\n                break;\n            }\n        }\n        return SnapStatus.Success;\n    }\n    async findLocatableHit(ev, newSearch, out) {\n        out.snapStatus = SnapStatus.NoElements;\n        if (newSearch) {\n            this.aSnapHits = undefined;\n            // search for new hits, but if the cursor is still close to the current hit, don't throw away list.\n            if (SnapStatus.Success !== (out.snapStatus = this.findHits(ev)))\n                return undefined;\n        }\n        else {\n            if (!this.aSnapHits) {\n                out.snapStatus = SnapStatus.NoElements;\n                return undefined;\n            }\n        }\n        const thisList = this.aSnapHits;\n        let thisHit;\n        let firstRejected;\n        const filterResponse = new LocateResponse();\n        // keep looking through hits until we find one that is accu-snappable.\n        while (undefined !== (thisHit = thisList.getNextHit())) {\n            if (LocateFilterStatus.Accept === await IModelApp.locateManager.filterHit(thisHit, LocateAction.AutoLocate, filterResponse))\n                return thisHit;\n            // we only care about the status of the first hit.\n            if (undefined !== firstRejected)\n                continue;\n            firstRejected = filterResponse.clone();\n            firstRejected.snapStatus = SnapStatus.FilteredByApp;\n        }\n        if (undefined !== firstRejected)\n            out.setFrom(firstRejected);\n        // Reset current hit index to go back to first hit on next AccuSnap reset event...\n        thisList.resetCurrentHit();\n        return undefined;\n    }\n    /** When in auto-locate mode, advance to the next hit without searching again.\n     * @internal\n     */\n    async resetButton() {\n        let hit;\n        const out = new LocateResponse();\n        out.snapStatus = SnapStatus.Disabled;\n        this.clearToolTip(undefined);\n        const ev = new BeButtonEvent();\n        IModelApp.toolAdmin.fillEventFromCursorLocation(ev);\n        if (this._doSnapping) {\n            // if we don't have any more candidate hits, get a new list at the current location\n            if (!this.aSnapHits || (0 === this.aSnapHits.length)) {\n                out.snapStatus = this.findHits(ev);\n                hit = (SnapStatus.Success !== out.snapStatus) ? undefined : await this.getAccuSnapDetail(this.aSnapHits, out);\n            }\n            else {\n                // drop the current hit from the list and then retest the list (without the dropped hit) to find the new snap\n                this.aSnapHits.removeCurrentHit();\n                hit = await this.getAccuSnapDetail(this.aSnapHits, out);\n            }\n            if (!this._doSnapping)\n                hit = undefined; // Snap no longer requested...\n        }\n        else if (this.isLocateEnabled) {\n            hit = await this.findLocatableHit(ev, false, out); // get next AccuSnap path (or undefined)\n            if (!this.isLocateEnabled)\n                hit = undefined; // Hit no longer requested...\n        }\n        // set the current hit\n        if (hit || this.currHit)\n            this.setCurrHit(hit);\n        // indicate errors\n        this.showSnapError(out, ev);\n        return out.snapStatus;\n    }\n    /** Find the best snap point according to the current cursor location\n     * @internal\n     */\n    async onMotion(ev) {\n        this.clearToolTip(ev);\n        const out = new LocateResponse();\n        out.snapStatus = SnapStatus.Disabled;\n        let hit;\n        if (this.isActive) {\n            if (this._doSnapping) {\n                out.snapStatus = this.findHits(ev);\n                hit = (SnapStatus.Success !== out.snapStatus) ? undefined : await this.getAccuSnapDetail(this.aSnapHits, out);\n                if (!this._doSnapping)\n                    hit = undefined; // Snap no longer requested...\n            }\n            else if (this.isLocateEnabled) {\n                hit = await this.findLocatableHit(ev, true, out);\n                if (!this.isLocateEnabled)\n                    hit = undefined; // Hit no longer requested...\n            }\n        }\n        // set the current hit and display the sprite (based on snap's KeypointType)\n        if (hit || this.currHit)\n            this.setCurrHit(hit);\n        // set up active error before calling displayToolTip to indicate error or show locate message...\n        this.showSnapError(out, ev);\n        this.displayToolTip(ev.viewPoint, ev.viewport, ev.rawPoint);\n        if (undefined !== this.touchCursor && InputSource.Mouse === ev.inputSource) {\n            this.touchCursor = undefined;\n            IModelApp.viewManager.invalidateDecorationsAllViews();\n        }\n    }\n    /** @internal */\n    onPreButtonEvent(ev) { return (undefined !== this.touchCursor) ? this.touchCursor.isButtonHandled(ev) : false; }\n    /** @internal */\n    onTouchStart(ev) {\n        if (undefined !== this.touchCursor)\n            this.touchCursor.doTouchStart(ev);\n    }\n    /** @internal */\n    onTouchEnd(ev) {\n        if (undefined !== this.touchCursor && 0 === ev.touchCount)\n            this.touchCursor.doTouchEnd(ev);\n    }\n    /** @internal */\n    onTouchCancel(ev) {\n        if (undefined !== this.touchCursor)\n            this.touchCursor.doTouchEnd(ev);\n    }\n    /** @internal */\n    onTouchMove(ev) {\n        return (undefined !== this.touchCursor) ? this.touchCursor.doTouchMove(ev) : false;\n    }\n    /** @internal */\n    onTouchMoveStart(ev, startEv) {\n        return (undefined !== this.touchCursor) ? this.touchCursor.doTouchMoveStart(ev, startEv) : false;\n    }\n    /** @internal */\n    get wantVirtualCursor() {\n        return this._doSnapping || (this.isLocateEnabled && ToolSettings.enableVirtualCursorForLocate);\n    }\n    /** @internal */\n    async onTouchTap(ev) {\n        if (undefined !== this.touchCursor)\n            return this.touchCursor.doTouchTap(ev);\n        if (!this.wantVirtualCursor)\n            return false;\n        this.touchCursor = TouchCursor.createFromTouchTap(ev);\n        if (undefined === this.touchCursor)\n            return false;\n        // Give active tool an opportunity to update it's tool assistance since event won't be passed along...\n        const tool = IModelApp.toolAdmin.activeTool;\n        if (undefined === tool)\n            return true;\n        await tool.onSuspend();\n        await tool.onUnsuspend();\n        return true;\n    }\n    flashElements(context) {\n        const viewport = context.viewport;\n        if (this.currHit) {\n            if (this.needsFlash(viewport))\n                this.flashHitInView(this.currHit, context);\n            return;\n        }\n        const hit = IModelApp.tentativePoint.getCurrSnap();\n        if (!hit || hit.isModelHit || hit.isMapHit)\n            return; // Don't hilite reality models.\n        if (this.toolState.neverFlash && this.toolState.neverFlash.has(hit.sourceId))\n            return;\n        hit.draw(context);\n    }\n    /** @internal */\n    decorate(context) {\n        if (undefined !== this.touchCursor && this.touchCursor.viewport === context.viewport)\n            context.addCanvasDecoration(this.touchCursor, true);\n        this.flashElements(context);\n        if (this.cross.isActive) {\n            this.cross.decorate(context);\n            this.icon.decorate(context);\n        }\n        this.errorIcon.decorate(context);\n    }\n    clearElemFromHitList(element) {\n        if (this.aSnapHits)\n            this.aSnapHits.removeHitsFrom(element);\n    }\n    /** @internal */\n    clearIfElement(sourceId) {\n        this.clearElemFromHitList(sourceId);\n        const hit = this.currHit;\n        if (hit && hit.sourceId === sourceId) {\n            this.destroy();\n        }\n    }\n    /** Enable locating elements.\n     * @public\n     */\n    enableLocate(yesNo) {\n        this.toolState.locate = yesNo;\n        if (!yesNo && undefined !== this.touchCursor && !this.wantVirtualCursor) {\n            this.touchCursor = undefined;\n            IModelApp.viewManager.invalidateDecorationsAllViews();\n        }\n    }\n    /** Called whenever a new [[Tool]] is started.\n     * @internal\n     */\n    onStartTool() {\n        this.initCmdState();\n        this.enableSnap(false);\n        this.enableLocate(false);\n        IModelApp.tentativePoint.clear(true);\n    }\n    /**\n     * Force AccuSnap to reevaluate the snap at the current cursor location.\n     * This is useful of an application changes the snap mode and wants AccuSnap to choose it immediately, without\n     * requiring the user to move the mouse.\n     * @internal\n     */\n    async reEvaluate() {\n        if (this.getCurrSnapDetail()) {\n            const ev = new BeButtonEvent();\n            IModelApp.toolAdmin.fillEventFromCursorLocation(ev);\n            return this.onMotion(ev);\n        }\n    }\n}\n/** TentativeOrAccuSnap returns information about an active snap generated by either [[AccuSnap]] or [[TentativePoint]].\n * @public\n */\nexport class TentativeOrAccuSnap {\n    /** @return true if AccuSnap is *hot* or TentativePoint is active and snapped to pickable geometry. */\n    static get isHot() { return IModelApp.accuSnap.isHot || IModelApp.tentativePoint.isSnapped; }\n    /** Get the current snap from either AccuSnap or TentativePoint.\n     * @param checkIsHot true to only return the snap from AccuSnap when it is *hot*.\n     * @return The current snap from AccuSnap, TentativePoint, or undefined.\n     */\n    static getCurrentSnap(checkIsHot = true) {\n        // Checking for a hot AccuSnap before checking TentativePoint is done to support extended intersections...\n        if (IModelApp.accuSnap.isHot)\n            return IModelApp.accuSnap.getCurrSnapDetail();\n        if (IModelApp.tentativePoint.isSnapped)\n            return IModelApp.tentativePoint.currSnap;\n        return (checkIsHot ? undefined : IModelApp.accuSnap.getCurrSnapDetail());\n    }\n    /** @return The current snap location from AccuSnap or TentativePoint */\n    static getCurrentPoint() {\n        if (IModelApp.accuSnap.isHot) {\n            const snap = IModelApp.accuSnap.getCurrSnapDetail();\n            if (snap)\n                return snap.adjustedPoint;\n        }\n        return IModelApp.tentativePoint.getPoint();\n    }\n    /** @return The current snap Viewport from AccuSnap or TentativePoint */\n    static getCurrentView() {\n        const snap = IModelApp.accuSnap.getCurrSnapDetail();\n        return snap ? snap.viewport : IModelApp.tentativePoint.viewport;\n    }\n}\n/** @public */\n(function (AccuSnap) {\n    class ToolState {\n        constructor() {\n            this.enabled = false;\n            this.locate = false;\n            this.suspended = 0;\n        }\n        setFrom(other) {\n            this.enabled = other.enabled;\n            this.locate = other.locate;\n            this.suspended = other.suspended;\n            this.neverFlash = other.neverFlash;\n        }\n        clone() {\n            const val = new ToolState();\n            val.setFrom(this);\n            return val;\n        }\n    }\n    AccuSnap.ToolState = ToolState;\n    class Settings {\n        constructor() {\n            this.hotDistanceFactor = 1.2;\n            this.stickyFactor = 1.0;\n            this.searchDistance = 2.0;\n            this.hiliteColdHits = true;\n            this.enableFlag = true;\n            this.toolTip = true;\n            this.toolTipDelay = BeDuration.fromSeconds(.5); // delay before tooltip pops up\n        }\n    }\n    AccuSnap.Settings = Settings;\n})(AccuSnap || (AccuSnap = {}));\n//# sourceMappingURL=AccuSnap.js.map",
      "start": 1693508118460,
      "end": 1693508118985,
      "sourcemaps": null
    }
  ]
}
