{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend-devtools/lib/esm/tools/RealityModelTools.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tools\n */\nimport { FeatureAppearance } from \"@itwin/core-common\";\nimport { getCesiumAssetUrl, IModelApp, NotifyMessageDetails, OutputMessagePriority, Tool } from \"@itwin/core-frontend\";\nimport { copyStringToClipboard } from \"../ClipboardUtilities\";\nimport { parseBoolean } from \"./parseBoolean\";\nimport { parseToggle } from \"./parseToggle\";\n/** This tool attaches a specified reality model.\n * @beta\n */\nclass AttachRealityModelTool extends Tool {\n    static get minArgs() { return 1; }\n    static get maxArgs() { return 1; }\n    /** This method runs the tool, attaching a specified reality model.\n     * @param data a [[ContextRealityModelProps]] JSON representation\n     */\n    async run(data) {\n        const props = JSON.parse(data);\n        const vp = IModelApp.viewManager.selectedView;\n        if (vp === undefined)\n            return false;\n        if (props === undefined || props.tilesetUrl === undefined) {\n            IModelApp.notifications.outputMessage(new NotifyMessageDetails(OutputMessagePriority.Error, `Properties ${props} are not valid`));\n        }\n        vp.displayStyle.attachRealityModel(props);\n        IModelApp.notifications.outputMessage(new NotifyMessageDetails(OutputMessagePriority.Info, `Reality Model ${props.tilesetUrl} attached`));\n        return true;\n    }\n    /** Executes this tool's run method with args[0] containing `data`.\n     * @see [[run]]\n     */\n    async parseAndRun(...args) {\n        return this.run(args[0]);\n    }\n}\nAttachRealityModelTool.toolId = \"AttachRealityModelTool\";\nexport { AttachRealityModelTool };\n/** This tool saves a reality model's JSON representation to the system clipboard.\n * @beta */\nclass SaveRealityModelTool extends Tool {\n    static get minArgs() { return 0; }\n    static get maxArgs() { return 1; }\n    /** This method runs the tool, saving a reality model's JSON representation to the system clipboard.\n     * @param name the name of the reality model to copy; if undefined, copy the last found reality model\n     */\n    async run(name) {\n        const vp = IModelApp.viewManager.selectedView;\n        if (vp === undefined)\n            return false;\n        vp.displayStyle.forEachRealityModel((realityModel) => {\n            if (name === undefined || realityModel.name === name) {\n                copyStringToClipboard(JSON.stringify(realityModel.toJSON()));\n                IModelApp.notifications.outputMessage(new NotifyMessageDetails(OutputMessagePriority.Info, `Reality Model ${realityModel.name} copied to clipboard`));\n            }\n        });\n        return true;\n    }\n    /** Executes this tool's run method with args[0] containing `name`.\n     * @see [[run]]\n     */\n    async parseAndRun(...args) {\n        return this.run(args.length > 0 ? args[0] : undefined);\n    }\n}\nSaveRealityModelTool.toolId = \"SaveRealityModelTool\";\nexport { SaveRealityModelTool };\nfunction changeRealityModelAppearanceOverrides(vp, overrides, index) {\n    if (index < 0) {\n        for (const model of vp.displayStyle.settings.contextRealityModels.models)\n            model.appearanceOverrides = model.appearanceOverrides ? model.appearanceOverrides.clone(overrides) : FeatureAppearance.fromJSON(overrides);\n        return vp.displayStyle.settings.contextRealityModels.models.length > 0;\n    }\n    else {\n        const model = vp.displayStyle.settings.contextRealityModels.models[index];\n        if (!model)\n            return false;\n        model.appearanceOverrides = model.appearanceOverrides ? model.appearanceOverrides.clone(overrides) : FeatureAppearance.fromJSON(overrides);\n        return true;\n    }\n}\nfunction appearanceChangedString(index) {\n    return index < 0 ? `All Reality Models` : `Reality Model at Index: ${index}`;\n}\n/** Set reality model appearance override for transparency in display style.\n * @beta\n */\nclass SetRealityModelTransparencyTool extends Tool {\n    static get minArgs() { return 1; }\n    static get maxArgs() { return 2; }\n    async run(transparency, index) {\n        const vp = IModelApp.viewManager.selectedView;\n        if (vp === undefined)\n            return false;\n        const changed = changeRealityModelAppearanceOverrides(vp, { transparency }, index);\n        if (changed)\n            IModelApp.notifications.outputMessage(new NotifyMessageDetails(OutputMessagePriority.Info, `${appearanceChangedString(index)} set to transparency: ${transparency}`));\n        return true;\n    }\n    async parseAndRun(...args) {\n        return this.run(parseFloat(args[0]), args.length > 1 ? parseInt(args[1], 10) : -1);\n    }\n}\nSetRealityModelTransparencyTool.toolId = \"SetRealityModelTransparencyTool\";\nexport { SetRealityModelTransparencyTool };\n/** Set reality model appearance override for locatable in display style.\n * @beta\n */\nclass SetRealityModelLocateTool extends Tool {\n    static get minArgs() { return 1; }\n    static get maxArgs() { return 2; }\n    async run(locate, index) {\n        const vp = IModelApp.viewManager.selectedView;\n        if (vp === undefined)\n            return false;\n        const nonLocatable = locate ? undefined : true;\n        const changed = changeRealityModelAppearanceOverrides(vp, { nonLocatable }, index);\n        if (changed)\n            IModelApp.notifications.outputMessage(new NotifyMessageDetails(OutputMessagePriority.Info, `${appearanceChangedString(index)} set to locate: ${locate}`));\n        return true;\n    }\n    async parseAndRun(...args) {\n        const locate = parseBoolean(args[0]);\n        return locate === undefined ? false : this.run(locate, args.length > 1 ? parseInt(args[1], 10) : -1);\n    }\n}\nSetRealityModelLocateTool.toolId = \"SetRealityModelLocateTool\";\nexport { SetRealityModelLocateTool };\n/** Set reality model appearance override for emphasized in display style.\n * @beta\n */\nclass SetRealityModelEmphasizedTool extends Tool {\n    static get minArgs() { return 1; }\n    static get maxArgs() { return 2; }\n    async run(emphasized, index) {\n        const vp = IModelApp.viewManager.selectedView;\n        if (vp === undefined)\n            return false;\n        const changed = changeRealityModelAppearanceOverrides(vp, { emphasized }, index);\n        if (changed)\n            IModelApp.notifications.outputMessage(new NotifyMessageDetails(OutputMessagePriority.Info, `${appearanceChangedString(index)} set to emphasized: ${emphasized}`));\n        return true;\n    }\n    async parseAndRun(...args) {\n        const emphasized = parseBoolean(args[0]);\n        return emphasized === undefined ? false : this.run(emphasized ? true : undefined, args.length > 1 ? parseInt(args[1], 10) : -1);\n    }\n}\nSetRealityModelEmphasizedTool.toolId = \"SetRealityModelEmphasizedTool\";\nexport { SetRealityModelEmphasizedTool };\n/** Detach reality model from display style.\n * @beta\n */\nclass DetachRealityModelTool extends Tool {\n    static get minArgs() { return 0; }\n    static get maxArgs() { return 1; }\n    async run(index) {\n        const vp = IModelApp.viewManager.selectedView;\n        if (vp === undefined)\n            return false;\n        if (index < 0) {\n            vp.displayStyle.settings.contextRealityModels.models.forEach((model) => vp.displayStyle.settings.contextRealityModels.delete(model));\n            return true;\n        }\n        else {\n            const model = vp.displayStyle.settings.contextRealityModels.models[index];\n            if (!model)\n                return false;\n            vp.displayStyle.settings.contextRealityModels.delete(model);\n            return true;\n        }\n    }\n    async parseAndRun(...args) {\n        return this.run(args.length > 0 ? parseInt(args[0], 10) : -1);\n    }\n}\nDetachRealityModelTool.toolId = \"ViewportDetachRealityModel\";\nexport { DetachRealityModelTool };\n/** Set reality model appearance override for color in display style.\n * @beta\n */\nclass SetRealityModelColorTool extends Tool {\n    static get minArgs() { return 3; }\n    static get maxArgs() { return 4; }\n    async run(rgb, index) {\n        const vp = IModelApp.viewManager.selectedView;\n        if (vp === undefined)\n            return false;\n        const changed = changeRealityModelAppearanceOverrides(vp, { rgb }, index);\n        if (changed)\n            IModelApp.notifications.outputMessage(new NotifyMessageDetails(OutputMessagePriority.Info, `${appearanceChangedString(index)} set to RGB color: (${rgb.r}, ${rgb.g}, ${rgb.b})`));\n        return true;\n    }\n    async parseAndRun(...args) {\n        return this.run({ r: parseFloat(args[0]), g: parseFloat(args[1]), b: parseFloat(args[2]) }, args.length > 3 ? parseInt(args[3], 10) : -1);\n    }\n}\nSetRealityModelColorTool.toolId = \"SetRealityModelColorTool\";\nexport { SetRealityModelColorTool };\n/** Clear reality model appearance override in display style.\n * @beta\n */\nclass ClearRealityModelAppearanceOverrides extends Tool {\n    static get minArgs() { return 0; }\n    static get maxArgs() { return 1; }\n    async run(index) {\n        const vp = IModelApp.viewManager.selectedView;\n        if (!vp)\n            return false;\n        const model = vp.displayStyle.settings.contextRealityModels.models[index];\n        if (!model)\n            return false;\n        model.appearanceOverrides = undefined;\n        return true;\n    }\n    async parseAndRun(...args) {\n        return this.run(args[0] === undefined ? -1 : parseInt(args[0], 10));\n    }\n}\nClearRealityModelAppearanceOverrides.toolId = \"ClearRealityModelAppearanceOverrides\";\nexport { ClearRealityModelAppearanceOverrides };\n/** Attach a cesium asset from the Ion ID and key.\n * @beta\n */\nclass AttachCesiumAssetTool extends Tool {\n    static get minArgs() { return 1; }\n    static get maxArgs() { return 2; }\n    async run(assetId, requestKey) {\n        const vp = IModelApp.viewManager.selectedView;\n        if (vp === undefined)\n            return false;\n        // attach using getCesiumAssetUrl\n        const accessKey = requestKey ? requestKey : IModelApp.tileAdmin.cesiumIonKey ? IModelApp.tileAdmin.cesiumIonKey : \"\";\n        const props = {\n            tilesetUrl: getCesiumAssetUrl(assetId, accessKey),\n        };\n        // Alternative new way to attach using rdSourceKey\n        // const rdSourceKey = RealityDataSource.createCesiumIonAssetKey(assetId, accessKey);\n        // const props: ContextRealityModelProps = { rdSourceKey, tilesetUrl: getCesiumAssetUrl(assetId, accessKey) };\n        vp.displayStyle.attachRealityModel(props);\n        IModelApp.notifications.outputMessage(new NotifyMessageDetails(OutputMessagePriority.Info, `Cesium Asset #${assetId} attached`));\n        return true;\n    }\n    async parseAndRun(...args) {\n        const assetId = parseInt(args[0], 10);\n        return Number.isNaN(assetId) ? false : this.run(assetId, args[1]);\n    }\n}\nAttachCesiumAssetTool.toolId = \"AttachCesiumAssetTool\";\nexport { AttachCesiumAssetTool };\n/** Turn on/off display of OpenStreetMap buildings\n * @beta\n */\nclass ToggleOSMBuildingDisplay extends Tool {\n    static get minArgs() { return 0; }\n    static get maxArgs() { return 2; }\n    async run(onOff, transparency) {\n        const vp = IModelApp.viewManager.selectedView;\n        if (vp === undefined)\n            return false;\n        if (onOff === undefined)\n            onOff = undefined === vp.displayStyle.getOSMBuildingRealityModel(); // Toggle current state.\n        const appearanceOverrides = (transparency !== undefined && transparency > 0 && transparency < 1) ? FeatureAppearance.fromJSON({ transparency }) : undefined;\n        vp.displayStyle.setOSMBuildingDisplay({ onOff, appearanceOverrides });\n        return true;\n    }\n    async parseAndRun(...args) {\n        const toggle = parseToggle(args[0]);\n        const transparency = args.length > 0 ? parseFloat(args[1]) : undefined;\n        return typeof toggle === \"string\" ? false : this.run(toggle, transparency);\n    }\n}\nToggleOSMBuildingDisplay.toolId = \"SetBuildingDisplay\";\nexport { ToggleOSMBuildingDisplay };\n//# sourceMappingURL=RealityModelTools.js.map",
      "start": 1693508122703,
      "end": 1693508122792,
      "sourcemaps": null
    }
  ]
}
