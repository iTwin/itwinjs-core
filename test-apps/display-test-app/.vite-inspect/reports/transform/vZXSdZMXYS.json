{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/curve/RegionMomentsXY.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\nimport { Angle } from \"../geometry3d/Angle\";\nimport { NullGeometryHandler } from \"../geometry3d/GeometryHandler\";\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\nimport { MomentData } from \"../geometry4d/MomentData\";\nimport { LineString3d } from \"./LineString3d\";\nimport { Loop } from \"./Loop\";\nimport { StrokeOptions } from \"./StrokeOptions\";\n/**\n * Implementation class for computing XY area moments.\n * @internal\n */\nexport class RegionMomentsXY extends NullGeometryHandler {\n    constructor() {\n        super(...arguments);\n        this._point0 = Point3d.create();\n        this._point1 = Point3d.create();\n    }\n    /** Accumulate (independent) integrations over\n     * * origin to chord of the arc.\n     * * origin to the \"cap\" between the chord and arc.\n     */\n    handleArc3d(arc) {\n        const momentData = this._activeMomentData;\n        const sweepRadians = arc.sweep.sweepRadians;\n        const alphaRadians = sweepRadians * 0.5;\n        // from https://apps.dtic.mil/dtic/tr/fulltext/u2/274936.pdf page 71  for radius = 1\n        let s = Math.sin(alphaRadians);\n        let c = Math.cos(alphaRadians);\n        let s1 = Math.sin(sweepRadians);\n        if (Angle.isFullCircleRadians(sweepRadians)) {\n            s = 0.0;\n            c = -1.0;\n            s1 = 0.0;\n        }\n        const q = 2 * s * s * s * c / (alphaRadians - s * c);\n        const s3 = s * s * s;\n        const s6 = s3 * s3;\n        const area = 0.5 * (sweepRadians - s1);\n        const inertiaXX = 0.25 * area * (1.0 - q / 3.0);\n        const inertiaYY1 = 0.25 * area * (1.0 + q);\n        const inertiaYY = inertiaYY1 - 4.0 * s6 / (9.0 * area);\n        const productXX = inertiaYY;\n        const productYY = inertiaXX;\n        const centerToCentroid = 4.0 * s * s * s / (3.0 * (sweepRadians - s1));\n        const midRadians = arc.sweep.fractionToRadians(0.5);\n        const centralPlane = arc.radiansToRotatedBasis(midRadians);\n        const centroid = centralPlane.origin.plusScaled(centralPlane.vectorU, centerToCentroid);\n        momentData.accumulateXYProductsInCentroidalFrame(productXX, 0.0, productYY, area, centroid, centralPlane.vectorU, centralPlane.vectorV);\n        const pointB = arc.fractionToPoint(0.0);\n        const pointC = arc.fractionToPoint(1.0);\n        momentData.accumulateTriangleMomentsXY(undefined, pointB, pointC);\n    }\n    /** Accumulate integrals over the (triangular) areas from the origin to each line segment */\n    handleLineString3d(ls) {\n        const momentData = this._activeMomentData;\n        momentData.accumulateTriangleToLineStringMomentsXY(undefined, ls.packedPoints);\n    }\n    /** Accumulate integrals over the (triangular) area from the origin to this line segment */\n    handleLineSegment3d(segment) {\n        const momentData = this._activeMomentData;\n        segment.startPoint(this._point0);\n        segment.endPoint(this._point1);\n        momentData.accumulateTriangleMomentsXY(undefined, this._point0, this._point1);\n    }\n    /** Accumulate integrals from origin to all primitives in the chain. */\n    handleLoop(loop) {\n        const momentData = this._activeMomentData = MomentData.create();\n        momentData.needOrigin = false;\n        for (const child of loop.children)\n            child.dispatchToGeometryHandler(this);\n        this._activeMomentData = undefined;\n        return momentData;\n    }\n    /**\n     * ASSUMPTIONS FOR ORIENTATION AND CONTAINMENT ISSUES\n     * * Largest area is outer\n     * * All others are interior (and not overlapping)\n     * Hence\n     * * Outer area sign must be positive -- negate all integrations as needed\n     * * Outer area signs must be positive -- negate all integrations as needed\n     * @param region\n     */\n    handleParityRegion(region) {\n        const allChildMoments = [];\n        let maxAbsArea = 0.0;\n        let largestChildMoments;\n        for (const child of region.children) {\n            if (child instanceof Loop) {\n                const childMoments = this.handleLoop(child);\n                if (childMoments) {\n                    allChildMoments.push(childMoments);\n                    const q = Math.abs(childMoments.quantitySum);\n                    if (q > maxAbsArea) {\n                        maxAbsArea = q;\n                        largestChildMoments = childMoments;\n                    }\n                }\n            }\n        }\n        if (largestChildMoments) {\n            const summedMoments = MomentData.create();\n            const sign0 = largestChildMoments.signFactor(1.0);\n            summedMoments.accumulateProducts(largestChildMoments, sign0);\n            for (const childMoments of allChildMoments) {\n                if (childMoments !== largestChildMoments) {\n                    const sign1 = childMoments.signFactor(-1.0);\n                    summedMoments.accumulateProducts(childMoments, sign1);\n                }\n            }\n            return summedMoments;\n        }\n        return undefined;\n    }\n    /** Accumulate (as simple addition) products over each component of the union region. */\n    handleUnionRegion(region) {\n        const summedMoments = MomentData.create();\n        for (const child of region.children) {\n            const childMoments = child.dispatchToGeometryHandler(this);\n            if (childMoments) {\n                const sign0 = childMoments.signFactor(1.0);\n                summedMoments.accumulateProducts(childMoments, sign0);\n            }\n        }\n        return summedMoments;\n    }\n    getStrokeOptions() {\n        if (this._strokeOptions)\n            return this._strokeOptions;\n        const options = StrokeOptions.createForCurves();\n        // this is unusually fine for stroking, but appropriate for sum.\n        options.angleTol = Angle.createDegrees(5.0);\n        this._strokeOptions = options;\n        return options;\n    }\n    /** Single curve primitive (not loop . . .).\n     * * stroke the curve\n     * * accumulate stroke array.\n     */\n    handleCurvePrimitive(cp) {\n        const strokes = LineString3d.create();\n        const options = this.getStrokeOptions();\n        cp.emitStrokes(strokes, options);\n        this.handleLineString3d(strokes);\n    }\n    /** handle strongly typed  BSplineCurve3d  as generic curve primitive */\n    handleBSplineCurve3d(g) { return this.handleCurvePrimitive(g); }\n    /** handle strongly typed  BSplineCurve3dH  as generic curve primitive */\n    handleBSplineCurve3dH(g) { return this.handleCurvePrimitive(g); }\n    /** handle strongly typed  TransitionSpiral as generic curve primitive  */\n    handleTransitionSpiral(g) { return this.handleCurvePrimitive(g); }\n}\n//# sourceMappingURL=RegionMomentsXY.js.map",
      "start": 1693508123677,
      "end": 1693508123811,
      "sourcemaps": null
    }
  ]
}
