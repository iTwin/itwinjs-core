{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tile/map/MapTilingScheme.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tiles\n */\nimport { Angle, Matrix3d, Point2d, Point3d, Transform, Vector3d } from \"@itwin/core-geometry\";\nimport { Cartographic } from \"@itwin/core-common\";\nimport { MapCartoRectangle } from \"../internal\";\n/** A scheme for converting between two representations of the surface of the Earth: an ellipsoid and a rectangular [tiled map](https://en.wikipedia.org/wiki/Tiled_web_map).\n * Positions on the surface of the ellipsoid are expressed in [Cartographic]($common) coordinates.\n * Rectangular [[MapTile]]s are projected onto this ellipsoid by the tiling scheme. Tile coordinates are represented by [[QuadId]]s.\n *\n * The tiling scheme represents the (x,y) coordinates of its tiles as fractions in [0,1] along the X and Y axes.\n * An X fraction of 0 corresponds to the easternmost longitude and an X fraction of 1 to the westernmost longitude.\n * The scheme can choose to correlate a Y fraction of 0 with either the north or south pole, as specified by [[rowZeroAtNorthPole]].\n * Implementing a tiling scheme only requires implementing the abstract method [[yFractionToLatitude]] and its inverse, [[latitudeToYFraction]].\n * @public\n */\nexport class MapTilingScheme {\n    /** Convert a longitude in [-pi, pi] radisn to a fraction in [0, 1] along the X axis. */\n    longitudeToXFraction(longitude) {\n        return longitude / Angle.pi2Radians + .5;\n    }\n    /** Convert a fraction in [0, 1] along the X axis into a longitude in [-pi, pi] radians. */\n    xFractionToLongitude(xFraction) {\n        return Angle.pi2Radians * (xFraction - .5);\n    }\n    constructor(numberOfLevelZeroTilesX, numberOfLevelZeroTilesY, rowZeroAtNorthPole) {\n        this._scratchFraction = Point2d.createZero();\n        this._scratchPoint2d = Point2d.createZero();\n        this.rowZeroAtNorthPole = rowZeroAtNorthPole;\n        this.numberOfLevelZeroTilesX = numberOfLevelZeroTilesX;\n        this.numberOfLevelZeroTilesY = numberOfLevelZeroTilesY;\n    }\n    /** The total number of tiles in the X direction at the specified level of detail.\n     * @param level The level of detail, with 0 corresponding to the root tile.\n     */\n    getNumberOfXTilesAtLevel(level) {\n        return level < 0 ? 1 : this.numberOfLevelZeroTilesX << level;\n    }\n    /** The total number of tiles in the Y direction at the specified level of detail.\n     * @param level The level of detail, with 0 corresponding to the root tile.\n     */\n    getNumberOfYTilesAtLevel(level) {\n        return level < 0 ? 1 : this.numberOfLevelZeroTilesY << level;\n    }\n    /** @alpha */\n    get rootLevel() {\n        return this.numberOfLevelZeroTilesX > 1 || this.numberOfLevelZeroTilesY > 1 ? -1 : 0;\n    }\n    /** @alpha */\n    getNumberOfXChildrenAtLevel(level) {\n        return level === 0 ? this.numberOfLevelZeroTilesX : 2;\n    }\n    /** @alpha */\n    getNumberOfYChildrenAtLevel(level) {\n        return level === 0 ? this.numberOfLevelZeroTilesY : 2;\n    }\n    /** Given the X component and level of a [[QuadId]], convert it to a fractional distance along the X axis. */\n    tileXToFraction(x, level) {\n        return x / this.getNumberOfXTilesAtLevel(level);\n    }\n    /** Given the Y component and level of a [[QuadId]], convert it to a fractional distance along the Y axis. */\n    tileYToFraction(y, level) {\n        return y / this.getNumberOfYTilesAtLevel(level);\n    }\n    /** Given a fractional distance along the X axis and a level of the quad tree, compute the X component of the corresponding [[QuadId]]. */\n    xFractionToTileX(xFraction, level) {\n        const nTiles = this.getNumberOfXTilesAtLevel(level);\n        return Math.min(Math.floor(xFraction * nTiles), nTiles - 1);\n    }\n    /** Given a fractional distance along the Y axis and a level of the quad tree, compute the Y component of the corresponding [[QuadId]]. */\n    yFractionToTileY(yFraction, level) {\n        const nTiles = this.getNumberOfYTilesAtLevel(level);\n        return Math.min(Math.floor(yFraction * nTiles), nTiles - 1);\n    }\n    /** Given the X component and level of a [[QuadId]], compute its longitude in [-pi, pi] radians. */\n    tileXToLongitude(x, level) {\n        return this.xFractionToLongitude(this.tileXToFraction(x, level));\n    }\n    /** Given the Y component and level of a [[QuadId]], compute its latitude in [-pi/2, pi/2] radians. */\n    tileYToLatitude(y, level) {\n        return this.yFractionToLatitude(this.tileYToFraction(y, level));\n    }\n    /** Given the components of a [[QuadId]], compute its fractional coordinates in the XY plane. */\n    tileXYToFraction(x, y, level, result) {\n        if (undefined === result)\n            result = Point2d.createZero();\n        result.x = this.tileXToFraction(x, level);\n        result.y = this.tileYToFraction(y, level);\n        return result;\n    }\n    /** Given the components of a [[QuadId]] and an elevation, compute the corresponding [Cartographic]($common) position.\n     * @param x The X component of the QuadId.\n     * @param y The Y component of the QuadId.\n     * @param level The level component of the QuadId.\n     * @param height The elevation above the ellipsoid.\n     * @returns the corresponding cartographic position.\n     */\n    tileXYToCartographic(x, y, level, result, height = 0) {\n        const pt = this.tileXYToFraction(x, y, level, this._scratchFraction);\n        return this.fractionToCartographic(pt.x, pt.y, result, height);\n    }\n    /** Given the components of a [[QuadId]], compute the corresponding region of the Earth's surface. */\n    tileXYToRectangle(x, y, level, result) {\n        if (level < 0)\n            return MapCartoRectangle.createMaximum();\n        return MapCartoRectangle.fromRadians(this.tileXToLongitude(x, level), this.tileYToLatitude(this.rowZeroAtNorthPole ? (y + 1) : y, level), this.tileXToLongitude(x + 1, level), this.tileYToLatitude(this.rowZeroAtNorthPole ? y : (y + 1), level), result);\n    }\n    /** Returns true if the tile at the specified X coordinate and level is adjacent to the north pole. */\n    tileBordersNorthPole(row, level) {\n        return this.rowZeroAtNorthPole ? this.tileYToFraction(row, level) === 0.0 : this.tileYToFraction(row + 1, level) === 1.0;\n    }\n    /** Returns true if the tile at the specified X coordinate and level is adjacent to the south pole. */\n    tileBordersSouthPole(row, level) {\n        return this.rowZeroAtNorthPole ? this.tileYToFraction(row + 1, level) === 1.0 : this.tileYToFraction(row, level) === 0.0;\n    }\n    /** Given a cartographic position, compute the corresponding position on the surface of the Earth as fractional distances along the\n     * X and Y axes.\n     */\n    cartographicToTileXY(carto, level, result) {\n        const fraction = this.cartographicToFraction(carto.latitude, carto.longitude, this._scratchPoint2d);\n        return Point2d.create(this.xFractionToTileX(fraction.x, level), this.yFractionToTileY(fraction.y, level), result);\n    }\n    /** Given fractional coordinates in the XY plane and an elevation, compute the corresponding cartographic position. */\n    fractionToCartographic(xFraction, yFraction, result, height = 0) {\n        result.longitude = this.xFractionToLongitude(xFraction);\n        result.latitude = this.yFractionToLatitude(yFraction);\n        result.height = height;\n        return result;\n    }\n    /** Given a cartographic location on the surface of the Earth, convert it to fractional coordinates in the XY plane. */\n    cartographicToFraction(latitudeRadians, longitudeRadians, result) {\n        result.x = this.longitudeToXFraction(longitudeRadians);\n        result.y = this.latitudeToYFraction(latitudeRadians);\n        return result;\n    }\n    /** @alpha */\n    ecefToPixelFraction(point, applyTerrain) {\n        const cartoGraphic = Cartographic.fromEcef(point);\n        return Point3d.create(this.longitudeToXFraction(cartoGraphic.longitude), this.latitudeToYFraction(cartoGraphic.latitude), applyTerrain ? cartoGraphic.height : 0);\n    }\n    /** @alpha */\n    computeMercatorFractionToDb(ecefToDb, bimElevationOffset, iModel, applyTerrain) {\n        const dbToEcef = ecefToDb.inverse();\n        const projectCenter = Point3d.create(iModel.projectExtents.center.x, iModel.projectExtents.center.y, bimElevationOffset);\n        const projectEast = projectCenter.plusXYZ(1, 0, 0);\n        const projectNorth = projectCenter.plusXYZ(0, 1, 0);\n        const mercatorOrigin = this.ecefToPixelFraction(dbToEcef.multiplyPoint3d(projectCenter), applyTerrain);\n        const mercatorX = this.ecefToPixelFraction(dbToEcef.multiplyPoint3d(projectEast), applyTerrain);\n        const mercatorY = this.ecefToPixelFraction(dbToEcef.multiplyPoint3d(projectNorth), applyTerrain);\n        const deltaX = Vector3d.createStartEnd(mercatorOrigin, mercatorX);\n        const deltaY = Vector3d.createStartEnd(mercatorOrigin, mercatorY);\n        const matrix = Matrix3d.createColumns(deltaX, deltaY, Vector3d.create(0, 0, 1));\n        const dbToMercator = Transform.createMatrixPickupPutdown(matrix, projectCenter, mercatorOrigin);\n        const mercatorToDb = dbToMercator.inverse();\n        return mercatorToDb === undefined ? Transform.createIdentity() : mercatorToDb;\n    }\n    /** @alpha */\n    yFractionFlip(fraction) {\n        return this.rowZeroAtNorthPole ? (1.0 - fraction) : fraction;\n    }\n}\n/** A [[MapTilingScheme]] using a simple geographic projection by which longitude and latitude are mapped directly to X and Y.\n * This projection is commonly known as \"geographic\", \"equirectangular\", \"equidistant cylindrical\", or \"plate carrÃ©e\".\n * @beta\n */\nexport class GeographicTilingScheme extends MapTilingScheme {\n    constructor(numberOfLevelZeroTilesX = 2, numberOfLevelZeroTilesY = 1, rowZeroAtNorthPole = false) {\n        super(numberOfLevelZeroTilesX, numberOfLevelZeroTilesY, rowZeroAtNorthPole);\n    }\n    /** Implements [[MapTilingScheme.yFractionToLatitude]]. */\n    yFractionToLatitude(yFraction) {\n        return Math.PI * (this.yFractionFlip(yFraction) - .5);\n    }\n    /** Implements [[MapTilingScheme.latitudeToYFraction]]. */\n    latitudeToYFraction(latitude) {\n        return this.yFractionFlip(.5 + latitude / Math.PI);\n    }\n}\n/** @alpha */\nclass WebMercatorProjection {\n    /**\n     * Converts a Mercator angle, in the range -PI to PI, to a geodetic latitude\n     * in the range -PI/2 to PI/2.\n     *\n     * @param {Number} mercatorAngle The angle to convert.\n     * @returns {Number} The geodetic latitude in radians.\n     */\n    static mercatorAngleToGeodeticLatitude(mercatorAngle) {\n        return Angle.piOver2Radians - (2.0 * Math.atan(Math.exp(-mercatorAngle)));\n    }\n    static geodeticLatitudeToMercatorAngle(latitude) {\n        // Clamp the latitude coordinate to the valid Mercator bounds.\n        if (latitude > WebMercatorProjection.maximumLatitude)\n            latitude = WebMercatorProjection.maximumLatitude;\n        else if (latitude < -WebMercatorProjection.maximumLatitude)\n            latitude = -WebMercatorProjection.maximumLatitude;\n        const sinLatitude = Math.sin(latitude);\n        return 0.5 * Math.log((1.0 + sinLatitude) / (1.0 - sinLatitude));\n    }\n}\nWebMercatorProjection.maximumLatitude = WebMercatorProjection.mercatorAngleToGeodeticLatitude(Angle.piRadians);\nexport { WebMercatorProjection };\n/** A [[MapTilingScheme]] using the [EPSG:3857](https://en.wikipedia.org/wiki/Web_Mercator_projection) projection.\n * This scheme is used by most [tiled web maps](https://en.wikipedia.org/wiki/Tiled_web_map), including Bing Maps and Google Maps.\n * @beta\n */\nexport class WebMercatorTilingScheme extends MapTilingScheme {\n    constructor(numberOfLevelZeroTilesX = 1, numberOfLevelZeroTilesY = 1, rowZeroAtNorthPole = true) {\n        super(numberOfLevelZeroTilesX, numberOfLevelZeroTilesY, rowZeroAtNorthPole);\n    }\n    /** Implements [[MapTilingScheme.yFractionToLatitude]]. */\n    yFractionToLatitude(yFraction) {\n        const mercatorAngle = Angle.pi2Radians * (this.rowZeroAtNorthPole ? (.5 - yFraction) : (yFraction - .5));\n        return WebMercatorProjection.mercatorAngleToGeodeticLatitude(mercatorAngle);\n    }\n    /** Implements [[MapTilingScheme.latitudeToYFraction. */\n    latitudeToYFraction(latitude) {\n        // Clamp the latitude coordinate to the valid Mercator bounds.\n        if (latitude > WebMercatorProjection.maximumLatitude) {\n            latitude = WebMercatorProjection.maximumLatitude;\n        }\n        else if (latitude < -WebMercatorProjection.maximumLatitude) {\n            latitude = -WebMercatorProjection.maximumLatitude;\n        }\n        const sinLatitude = Math.sin(latitude);\n        return (0.5 - Math.log((1.0 + sinLatitude) / (1.0 - sinLatitude)) / (4.0 * Angle.piRadians)); // https://msdn.microsoft.com/en-us/library/bb259689.aspx\n    }\n}\n//# sourceMappingURL=MapTilingScheme.js.map",
      "start": 1693508122028,
      "end": 1693508122171,
      "sourcemaps": null
    }
  ]
}
