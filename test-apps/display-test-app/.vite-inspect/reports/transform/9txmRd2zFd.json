{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/ViewportSync.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Views\n */\n/** Forms a connection between two or more [[Viewport]]s such that a change in any one of the viewports is reflected in all of the others.\n * When the connection is first formed, all of the viewports are synchronized to the current state of the **first** viewport in `viewports`.\n * Thereafter, an event listener registered with each viewport's [[Viewport.onViewChanged]] event is invoked when anything about that viewport's state changes.\n * Each time such an event occurs, the initating (\"source\") viewport is passed to `sync` to obtain a function that can be invoked to synchronize each of the other\n * (\"target\") viewports with the source viewport's new state. The function returned by `sync` can choose to synchronize any or all aspects of the viewports' states, such as\n * the viewed volume, display style, viewed categories or models, or anything else.\n *\n * To sever the connection, invoke the function returned by this function. For example:\n * ```ts\n *  // set up the connection.\n *  const disconnect = connectViewports([viewport0, viewport1, viewport2], (changedViewport) => synchronizeViewportFrusta(changedViewport));\n *  // some time later, sever the connection.\n *  disconnect();\n * ```\n *\n * @note [[Viewport.onViewChanged]] can be invoked **very** frequently - sometimes multiple times per frame. Try to avoid performing excessive computations within your synchronization functions.\n *\n * @param viewports The viewports to be connected. It should contain at least two viewports and no duplicate viewports. The initial state of each viewport will be synchronized with\n * the state of the first viewport in this iterable.\n * @param sync A function to be invoked whenever the state of any viewport in `viewports` changes, returning a function that can be used to synchronize the\n * state of each viewport.\n * @returns a function that can be invoked to sever the connection between the viewports.\n * @see [[connectViewportFrusta]] to synchronize the [Frustum]($common) of each viewport.\n * @see [[connectViewportViews]] to synchronize every aspect of the viewports.\n * @see [[TwoWayViewportSync]] to synchronize the state of exactly two viewports.\n * @see [Multiple Viewport Sample](https://www.itwinjs.org/sample-showcase/?group=Viewer+Features&sample=multi-viewport-sample&imodel=Metrostation+Sample)\n * @public\n * @extensions\n */\nexport function connectViewports(viewports, sync) {\n    const disconnect = [];\n    let echo = false;\n    const synchronize = (source) => {\n        if (echo)\n            return;\n        // Ignore onViewChanged events resulting from synchronization.\n        echo = true;\n        try {\n            const doSync = sync(source);\n            for (const vp of viewports)\n                if (vp !== source)\n                    doSync(source, vp);\n        }\n        finally {\n            echo = false;\n        }\n    };\n    let firstViewport;\n    for (const vp of viewports) {\n        if (!firstViewport)\n            firstViewport = vp;\n        disconnect.push(vp.onViewChanged.addListener(() => synchronize(vp)));\n    }\n    if (firstViewport)\n        synchronize(firstViewport);\n    return () => {\n        for (const f of disconnect)\n            f();\n        disconnect.length = 0;\n    };\n}\n/** A function that returns a [[SynchronizeViewports]] function that synchronizes every aspect of the viewports' states, including\n * display style, model and category selectors, [Frustum]($common), etc.\n * @see [[connectViewportViews]] to establish a connection between viewports using this synchronization strategy.\n * @public\n * @extensions\n */\nexport function synchronizeViewportViews(source) {\n    return (_source, target) => target.applyViewState(source.view.clone(target.iModel));\n}\n/** A function that returns a [[SynchronizeViewports]] function that synchronizes the viewed volumes of each viewport.\n * @see [[connectViewportFrusta]] to establish a connection between viewports using this synchronization strategy.\n * @public\n * @extensions\n */\nexport function synchronizeViewportFrusta(source) {\n    const pose = source.view.savePose();\n    return (_source, target) => {\n        const view = target.view.applyPose(pose);\n        target.applyViewState(view);\n    };\n}\n/** Form a connection between two or more [[Viewport]]s such that they all view the same volume. For example, zooming out in one viewport\n * will zoom out by the same distance in all of the other viewports.\n * @see [[connectViewports]] to customize how the viewports are synchronized.\n * @public\n * @extensions\n */\nexport function connectViewportFrusta(viewports) {\n    return connectViewports(viewports, (source) => synchronizeViewportFrusta(source));\n}\n/** Form a connection between two or more [[Viewport]]s such that every aspect of the viewports are kept in sync. For example, if the set of models\n * or categories visible in one viewport is changed, the same set of models and categories will be visible in the other viewports.\n * @see [[connectViewportFrusta]] to synchronize only the [Frustum]($common) of each viewport.\n * @see [[connectViewports]] to customize how the viewports are synchronized.\n * @public\n * @extensions\n */\nexport function connectViewportViews(viewports) {\n    return connectViewports(viewports, (source) => synchronizeViewportViews(source));\n}\n/** Forms a bidirectional connection between two [[Viewport]]s such that the [[ViewState]]s of each are synchronized with one another.\n * For example, panning in one viewport will cause the other viewport to pan by the same distance, and changing the [RenderMode]($common) of one viewport\n * will change it in the other viewport.\n * By default, all aspects of the views - display style, category and model selectors, frustum, etc - are synchronized, but this can be customized by\n * subclassing and overriding the [[syncViewports]] and [[connectViewports]] methods.\n * @see [Multiple Viewport Sample](https://www.itwinjs.org/sample-showcase/?group=Viewer+Features&sample=multi-viewport-sample&imodel=Metrostation+Sample)\n * for an interactive demonstration.\n * @see [[TwoWayViewportFrustumSync]] to synchronize only the frusta of the viewports.\n * @see [[connectViewportViews]] to synchronize the state of more than two viewports.\n * @public\n * @extensions\n */\nexport class TwoWayViewportSync {\n    constructor() {\n        this._disconnect = [];\n    }\n    /** Invoked from [[connect]] to set up the initial synchronization between the two viewports.\n     * `target` should be modified to match `source`.\n     * The default implementation applies a clone of `source`'s [[ViewState]] to `target`.\n     * @see [[syncViewports]] to customize subsequent synchronization.\n     */\n    connectViewports(source, target) {\n        const viewState = source.view.clone(target.iModel);\n        target.applyViewState(viewState);\n    }\n    /** Invoked each time `source` changes to update `target` to match.\n     * The default implementation applies a clone of `source`'s [[ViewState]] to `target`.\n     * @param source The viewport that changed\n     * @param target The viewport that should be updated to match `source`\n     * @see [[connectViewports]] to set up the initial synchronization between the two viewports.\n     */\n    syncViewports(source, target) {\n        target.applyViewState(source.view.clone(target.iModel));\n    }\n    /** Establish the connection between two Viewports. When this method is called, `viewport2` is initialized with the state of `viewport1` via [[connectViewports]].\n     * Thereafter, any change to the frustum of either viewport will be reflected in the frustum of the other viewport via [[syncViewports]].\n     */\n    connect(viewport1, viewport2) {\n        this.disconnect();\n        this.connectViewports(viewport1, viewport2);\n        this._disconnect.push(connectViewports([viewport1, viewport2], () => (source, target) => this.syncViewports(source, target)));\n    }\n    /** Remove the connection between the two views. */\n    disconnect() {\n        this._disconnect.forEach((f) => f());\n        this._disconnect.length = 0;\n    }\n}\n/** Forms a bidirectional connection between two [[Viewport]]s such that the [Frustum]($common)s of each are synchronized with one another.\n * For example, zooming out in one viewport will zoom out by the same distance in the other viewport.\n * No other aspects of the viewports are synchronized - they may have entirely different display styles, category/model selectors, etc.\n * @see [[TwoWayViewportSync]] to synchronize all aspects of the viewports.\n * @see [[connectViewportFrusta]] to synchronize the frusta of more than two viewports.\n * @public\n * @extensions\n */\nexport class TwoWayViewportFrustumSync extends TwoWayViewportSync {\n    /** Synchronizes the two viewports by applying `source`'s frustum to `target`. */\n    syncViewports(source, target) {\n        const pose = source.view.savePose();\n        const view = target.view.applyPose(pose);\n        target.applyViewState(view);\n    }\n    /** Sets up the initial connection between two viewports by applying `source`'s frustum to `target`. */\n    connectViewports(source, target) {\n        this.syncViewports(source, target);\n    }\n}\n//# sourceMappingURL=ViewportSync.js.map",
      "start": 1693508119586,
      "end": 1693508119735,
      "sourcemaps": null
    }
  ]
}
