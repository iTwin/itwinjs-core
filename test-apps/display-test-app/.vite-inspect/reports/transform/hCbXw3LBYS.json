{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend-devtools/lib/esm/widgets/MemoryTracker.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Widgets\n */\nimport { assert, BeTimePoint } from \"@itwin/core-bentley\";\nimport { DisclosedTileTreeSet, IModelApp, RenderMemory, } from \"@itwin/core-frontend\";\nimport { createComboBox } from \"../ui/ComboBox\";\nfunction collectTileTreeMemory(stats, owner) {\n    const tree = owner.tileTree;\n    if (undefined !== tree)\n        tree.collectStatistics(stats);\n}\n// Includes None (-1) at index 0\nconst memLabels = [\n    \"None\",\n    \"Viewed Tile Trees\",\n    \"Selected Tiles\",\n    \"All Tile Trees\",\n    \"Render Target\",\n    \"Viewport\",\n    \"System\",\n    \"All\",\n];\nfunction collectStatisticsForViewedTileTrees(vp, stats) {\n    vp.collectStatistics(stats);\n    const trees = new DisclosedTileTreeSet();\n    vp.discloseTileTrees(trees);\n    return trees.size;\n}\nfunction collectStatisticsForSelectedTiles(vp, stats) {\n    const trees = new Set();\n    const selectedTiles = IModelApp.tileAdmin.getTilesForUser(vp)?.selected;\n    if (selectedTiles) {\n        for (const tile of selectedTiles) {\n            trees.add(tile.tree);\n            tile.collectStatistics(stats);\n        }\n    }\n    return trees.size;\n}\nfunction collectStatisticsForAllTileTrees(vp, stats) {\n    let numTrees = 0;\n    vp.view.iModel.tiles.forEachTreeOwner((owner) => {\n        collectTileTreeMemory(stats, owner);\n        if (undefined !== owner.tileTree)\n            ++numTrees;\n    });\n    return numTrees;\n}\nconst calcMem = [\n    (stats, vp) => collectStatisticsForViewedTileTrees(vp, stats),\n    (stats, vp) => collectStatisticsForSelectedTiles(vp, stats),\n    (stats, vp) => collectStatisticsForAllTileTrees(vp, stats),\n    (stats, vp) => {\n        vp.target.collectStatistics(stats);\n        return 0;\n    },\n    (stats, vp) => {\n        vp.target.collectStatistics(stats);\n        return collectStatisticsForViewedTileTrees(vp, stats);\n    },\n    (stats, vp) => {\n        vp.target.renderSystem.collectStatistics(stats);\n        return 0;\n    },\n    (stats, vp) => {\n        vp.target.renderSystem.collectStatistics(stats);\n        for (const x of IModelApp.viewManager)\n            x.target.collectStatistics(stats);\n        return collectStatisticsForAllTileTrees(vp, stats);\n    },\n];\n// ###TODO...\nconst purgeMem = [\n    undefined,\n    (olderThan) => IModelApp.viewManager.purgeTileTrees(olderThan ? olderThan : BeTimePoint.now()),\n];\n/** @internal */\nexport function formatMemory(numBytes) {\n    let suffix = \"b\";\n    if (numBytes >= 1024) {\n        numBytes /= 1024;\n        suffix = \"kb\";\n        if (numBytes >= 1024) {\n            numBytes /= 1024;\n            suffix = \"mb\";\n        }\n    }\n    return numBytes.toFixed(2) + suffix;\n}\nclass MemoryPanel {\n    constructor(parent, label, labels) {\n        this._elems = [];\n        this._label = label;\n        this._labels = labels;\n        this._div = document.createElement(\"div\");\n        this._header = document.createElement(\"label\");\n        this._header.style.fontWeight = \"bold\";\n        this._div.appendChild(this._header);\n        const numElems = labels.length;\n        for (let i = 0; i < numElems; i++) {\n            const elem = document.createElement(\"label\");\n            this._elems.push(elem);\n            this._div.appendChild(elem);\n        }\n        parent.appendChild(this._div);\n    }\n    update(stats, total) {\n        assert(this._labels.length === stats.length);\n        assert(this._labels.length === this._elems.length);\n        this._header.innerHTML = `${this._label}: ${formatMemory(total)}`;\n        for (let i = 0; i < this._labels.length; i++) {\n            const elem = this._elems[i];\n            const stat = stats[i];\n            if (0 === stat.totalBytes) {\n                elem.style.display = \"none\";\n                continue;\n            }\n            elem.style.display = \"block\";\n            elem.innerHTML = `${this._labels[i]} (${stat.count}): ${formatMemory(stat.totalBytes)}`; // + \"\\n(max: \" + formatMemory(stat.maxBytes) + \")\";\n        }\n    }\n}\n/** Displays GPU memory allocated to tile trees - either all tile trees in the system, or only those associated with a specific Viewport.\n * @beta\n */\nexport class MemoryTracker {\n    constructor(parent, vp) {\n        this._stats = new RenderMemory.Statistics();\n        this._memIndex = -1 /* MemIndex.None */;\n        this._vp = vp;\n        this._div = document.createElement(\"div\");\n        this._div.style.display = \"none\";\n        this._div.style.textAlign = \"right\";\n        this.addSelector(parent);\n        const table = document.createElement(\"table\");\n        table.style.width = \"100%\";\n        table.setAttribute(\"border\", \"1\");\n        this._div.appendChild(table);\n        const row0 = document.createElement(\"tr\");\n        const cell00 = document.createElement(\"td\");\n        const cell01 = document.createElement(\"td\");\n        cell00.style.width = cell01.style.width = \"50%\";\n        row0.appendChild(cell00);\n        row0.appendChild(cell01);\n        table.appendChild(row0);\n        const row1 = document.createElement(\"tr\");\n        const cell10 = document.createElement(\"td\");\n        const cell11 = document.createElement(\"td\");\n        cell10.style.width = cell11.style.width = \"50%\";\n        row1.appendChild(cell10);\n        row1.appendChild(cell11);\n        table.appendChild(row1);\n        this._textures = new MemoryPanel(cell00, \"Textures\", [\"Surface Textures\", \"Vertex Tables\", \"Edge Tables\", \"Feature Tables\", \"Feature Overrides\", \"Clip Volumes\", \"Planar Classifiers\", \"Shadow Maps\", \"Texture Attachments\", \"Thematic Textures\"]);\n        this._buffers = new MemoryPanel(cell01, \"Buffers\", [\"Surfaces\", \"Visible Edges\", \"Silhouettes\", \"Polyline Edges\", \"Indexed Edges\", \"Polylines\", \"Point Strings\", \"Point Clouds\", \"Instances\", \"Terrain\", \"Reality Mesh\"]);\n        this._totalElem = this.addStatistics(cell10);\n        this._totalTreesElem = this.addStatistics(cell11);\n        this._purgeButton = this.addPurgeButton(this._div);\n        parent.appendChild(this._div);\n    }\n    dispose() {\n        this.clearInterval();\n    }\n    addSelector(parent) {\n        const entries = [];\n        for (let i = -1 /* MemIndex.None */; i < 7 /* MemIndex.COUNT */; i++)\n            entries.push({ name: memLabels[i + 1], value: i });\n        createComboBox({\n            parent,\n            name: \"Track Memory: \",\n            id: \"memTracker_type\",\n            value: -1 /* MemIndex.None */,\n            handler: (select) => this.change(Number.parseInt(select.value, 10)),\n            entries,\n        });\n    }\n    addPurgeButton(parent) {\n        const div = document.createElement(\"div\");\n        div.style.textAlign = \"center\";\n        const button = document.createElement(\"button\");\n        button.innerText = \"Purge\";\n        button.addEventListener(\"click\", () => this.purge());\n        div.appendChild(button);\n        parent.appendChild(div);\n        return button;\n    }\n    addStatistics(parent) {\n        const div = document.createElement(\"div\");\n        const text = document.createElement(\"text\");\n        text.style.fontWeight = \"bold\";\n        div.appendChild(text);\n        parent.appendChild(div);\n        return text;\n    }\n    clearInterval() {\n        if (undefined !== this._curIntervalId) {\n            clearInterval(this._curIntervalId);\n            this._curIntervalId = undefined;\n        }\n    }\n    change(newIndex) {\n        if (newIndex === this._memIndex)\n            return;\n        this._memIndex = newIndex;\n        if (-1 /* MemIndex.None */ === newIndex) {\n            this.clearInterval();\n            this._div.style.display = \"none\";\n            return;\n        }\n        if (undefined === this._curIntervalId) {\n            this._curIntervalId = setInterval(() => this.update(), 1000);\n            this._div.style.display = \"block\";\n        }\n        this._purgeButton.disabled = undefined === purgeMem[this._memIndex];\n        this.update();\n    }\n    update() {\n        const calc = calcMem[this._memIndex];\n        this._stats.clear();\n        const numTrees = calc(this._stats, this._vp);\n        this._totalElem.innerText = `Total: ${formatMemory(this._stats.totalBytes)}`;\n        this._totalTreesElem.innerText = `Total Tile Trees: ${numTrees}`;\n        this._textures.update(this._stats.consumers, this._stats.totalBytes - this._stats.buffers.totalBytes);\n        this._buffers.update(this._stats.buffers.consumers, this._stats.buffers.totalBytes);\n    }\n    purge() {\n        const purge = purgeMem[this._memIndex];\n        if (undefined !== purge) {\n            purge();\n            this._vp.invalidateScene(); // to trigger reloading of tiles we actually do want to continue drawing\n            this.update();\n        }\n    }\n}\n//# sourceMappingURL=MemoryTracker.js.map",
      "start": 1693508122844,
      "end": 1693508122914,
      "sourcemaps": null
    }
  ]
}
