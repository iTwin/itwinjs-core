{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/numerics/ConvexPolygon2d.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Numerics\n */\nimport { Geometry } from \"../Geometry\";\nimport { Vector2d } from \"../geometry3d/Point2dVector2d\";\nimport { Range1d } from \"../geometry3d/Range\";\nimport { Ray2d } from \"../geometry3d/Ray2d\";\n/**\n * Convex hull of points in 2d.\n * @internal\n */\nexport class ConvexPolygon2d {\n    constructor(points) {\n        this._hullPoints = [];\n        // Deep copy of points array given\n        if (points) {\n            for (const point of points) {\n                this._hullPoints.push(point);\n            }\n        }\n    }\n    /** Create the hull */\n    static createHull(points) {\n        return new ConvexPolygon2d(ConvexPolygon2d.computeConvexHull(points));\n    }\n    /** Create the hull. First try to use the points as given. */\n    static createHullIsValidCheck(points) {\n        if (ConvexPolygon2d.isValidConvexHull(points))\n            return new ConvexPolygon2d(points);\n        else\n            return new ConvexPolygon2d(ConvexPolygon2d.computeConvexHull(points));\n    }\n    /** Return a reference of the hull points. */\n    get points() {\n        return this._hullPoints;\n    }\n    /** Test if hull points are a convex, CCW polygon */\n    static isValidConvexHull(points) {\n        if (points.length < 3)\n            return false;\n        const n = points.length;\n        for (let i = 0; i < n; i++) {\n            const i1 = (i + 1) % n;\n            const i2 = (i + 2) % n;\n            if (points[i].crossProductToPoints(points[i1], points[i2]) < 0.0)\n                return false;\n        }\n        return true;\n    }\n    /** Return true if the convex hull (to the left of the edges) contains the test point */\n    containsPoint(point) {\n        let xy0 = this._hullPoints[this._hullPoints.length - 1];\n        // double tol = -1.0e-20;  negative tol!!\n        for (const i of this._hullPoints) {\n            const xy1 = i;\n            const c = xy0.crossProductToPoints(xy1, point);\n            if (c < 0.0)\n                return false;\n            xy0 = i;\n        }\n        return true;\n    }\n    /** Return the largest outside. (return 0 if in or on) */\n    distanceOutside(xy) {\n        let maxDistance = 0.0;\n        const n = this._hullPoints.length;\n        let xy0 = this._hullPoints[n - 1];\n        // double tol = -1.0e-20;  // negative tol!!\n        for (let i = 0; i < n; i++) {\n            const xy1 = this._hullPoints[i];\n            const c = xy0.crossProductToPoints(xy1, xy);\n            if (c < 0.0) {\n                const ray = Ray2d.createOriginAndTarget(xy0, xy1);\n                const s = ray.projectionFraction(xy);\n                let d = 0.0;\n                if (s < 0.0)\n                    d = xy0.distance(xy);\n                else if (s > 1.0)\n                    d = xy1.distance(xy);\n                else\n                    d = xy.distance(ray.fractionToPoint(s));\n                if (d > maxDistance)\n                    maxDistance = d;\n            }\n            xy0 = this._hullPoints[i];\n        }\n        return maxDistance;\n    }\n    /** Offset the entire hull (in place) by distance.\n     * Returns false if an undefined occurred from normalizing (could occur after changing some hull points already)\n     */\n    offsetInPlace(distance) {\n        const n = this._hullPoints.length;\n        if (n >= 3) {\n            const hullPoint0 = this._hullPoints[0];\n            let edgeA = this._hullPoints[n - 1].vectorTo(hullPoint0);\n            edgeA = edgeA.normalize();\n            if (edgeA === undefined) {\n                return false;\n            }\n            let perpA = edgeA.rotate90CWXY();\n            let edgeB;\n            let perpB;\n            for (let i = 0; i < n; i++) {\n                const j = i + 1;\n                edgeB = this._hullPoints[i].vectorTo(j < n ? this._hullPoints[j] : hullPoint0);\n                edgeB = edgeB.normalize();\n                if (edgeB === undefined) {\n                    return false;\n                }\n                perpB = edgeB.rotate90CWXY();\n                const offsetBisector = Vector2d.createOffsetBisector(perpA, perpB, distance);\n                if (offsetBisector === undefined) {\n                    return false;\n                }\n                this._hullPoints[i] = this._hullPoints[i].plus(offsetBisector);\n                // PerpA takes up reference to perpB, as perpB will die in new iteration\n                perpA = perpB;\n            }\n        }\n        return true;\n    }\n    /**\n     * Return 2 distances bounding the intersection of the ray with this convex hull.\n     * @param ray ray to clip to this convex polygon. ASSUME normalized direction vector, so that ray fractions are distances.\n     * @returns intersection bounds as min and max distances along the ray (from its origin).\n     * * Both negative and positive distances along the ray are possible.\n     * * Range has extreme values if less than 3 points, distanceA > distanceB, or if cross product < 0.\n     */\n    clipRay(ray) {\n        let distanceA = -Number.MAX_VALUE;\n        let distanceB = Number.MAX_VALUE;\n        const n = this._hullPoints.length;\n        if (n < 3)\n            return Range1d.createNull();\n        let xy0 = this._hullPoints[n - 1];\n        for (const xy1 of this._hullPoints) {\n            const { hasIntersection, fraction, cross } = ray.intersectUnboundedLine(xy0, xy1);\n            if (hasIntersection) {\n                if (cross > 0.0) {\n                    if (fraction < distanceB)\n                        distanceB = fraction;\n                }\n                else {\n                    if (fraction > distanceA)\n                        distanceA = fraction;\n                }\n                if (distanceA > distanceB)\n                    return Range1d.createNull();\n            }\n            else {\n                // ray is parallel to the edge.\n                // Any single point out classifies it all . ..\n                if (xy0.crossProductToPoints(xy1, ray.origin) < 0.0)\n                    return Range1d.createNull();\n            }\n            // xy1 is reassigned with each new loop\n            xy0 = xy1;\n        }\n        const range = Range1d.createNull();\n        range.extendX(distanceA);\n        range.extendX(distanceB);\n        return range;\n    }\n    /** Return the range of (fractional) ray positions for projections of all points from the arrays. */\n    rangeAlongRay(ray) {\n        const range = Range1d.createNull();\n        for (const xy1 of this._hullPoints)\n            range.extendX(ray.projectionFraction(xy1));\n        return range;\n    }\n    /** Return the range of (fractional) ray positions for projections of all points from the arrays. */\n    rangePerpendicularToRay(ray) {\n        const range = Range1d.createNull();\n        for (const xy1 of this._hullPoints)\n            range.extendX(ray.perpendicularProjectionFraction(xy1));\n        return range;\n    }\n    /** Computes the hull of a convex polygon from points given. Returns the hull as a new Point2d array.\n     *  Returns an empty hull if less than 3 points are given.\n     */\n    static computeConvexHull(points) {\n        const hull = [];\n        const n = points.length;\n        if (n < 3)\n            return undefined;\n        // Get deep copy\n        const xy1 = points.slice(0, n);\n        xy1.sort((a, b) => Geometry.lexicalXYLessThan(a, b));\n        hull.push(xy1[0]); // This is sure to stay\n        hull.push(xy1[1]); // This one can be removed in loop.\n        // First sweep creates upper hull\n        for (let i = 2; i < n; i++) {\n            const candidate = xy1[i];\n            let top = hull.length - 1;\n            while (top > 0 && hull[top - 1].crossProductToPoints(hull[top], candidate) <= 0.0) {\n                top--;\n                hull.pop();\n            }\n            hull.push(candidate);\n        }\n        // Second sweep creates lower hull right to left\n        const i0 = hull.length - 1;\n        // xy1.back () is already on stack.\n        hull.push(xy1[n - 2]);\n        for (let i = n - 2; i-- > 0;) {\n            const candidate = xy1[i];\n            let top = hull.length - 1;\n            while (top > i0 && hull[top - 1].crossProductToPoints(hull[top], candidate) <= 0.0) {\n                top--;\n                hull.pop();\n            }\n            if (i > 0) // don't replicate start point!!!\n                hull.push(candidate);\n        }\n        return hull;\n    }\n}\n//# sourceMappingURL=ConvexPolygon2d.js.map",
      "start": 1693508123385,
      "end": 1693508123554,
      "sourcemaps": null
    }
  ]
}
