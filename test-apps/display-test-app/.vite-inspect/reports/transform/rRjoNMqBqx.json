{
  "resolvedId": "D:/hub2023A/itwinjs-core/editor/frontend/lib/esm/ModifyElementTool.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Editing\n */\nimport { Id64 } from \"@itwin/core-bentley\";\nimport { FeatureAppearance } from \"@itwin/core-common\";\nimport { ElementSetTool, IModelApp } from \"@itwin/core-frontend\";\nimport { computeChordToleranceFromPoint, DynamicGraphicsProvider } from \"./CreateElementTool\";\n/** Edit tool base class for updating existing elements.\n * @beta\n */\nexport class ModifyElementTool extends ElementSetTool {\n    constructor() {\n        super(...arguments);\n        this._checkedIds = new Map();\n    }\n    allowView(_vp) { return true; }\n    isCompatibleViewport(vp, isSelectedViewChange) { return (super.isCompatibleViewport(vp, isSelectedViewChange) && undefined !== vp && this.allowView(vp)); }\n    onGeometryFilterChanged() { this._checkedIds.clear(); }\n    async doAcceptElementForOperation(_id) { return false; }\n    async acceptElementForOperation(id) {\n        if (Id64.isInvalid(id) || Id64.isTransient(id))\n            return false;\n        let accept = this._checkedIds.get(id);\n        if (undefined === accept) {\n            if (this.agenda.isEmpty && this._checkedIds.size > 1000)\n                this._checkedIds.clear(); // Limit auto-locate cache size to something reasonable...\n            accept = await this.doAcceptElementForOperation(id);\n            this._checkedIds.set(id, accept);\n        }\n        return accept;\n    }\n    async isElementValidForOperation(hit, out) {\n        if (!await super.isElementValidForOperation(hit, out))\n            return false;\n        return this.acceptElementForOperation(hit.sourceId);\n    }\n    async postFilterIds(arg) {\n        const ids = [];\n        for (const id of Id64.iterable(arg)) {\n            if (await this.acceptElementForOperation(id))\n                ids.push(id);\n        }\n        return ids;\n    }\n    async getGroupIds(id) {\n        return this.postFilterIds(await super.getGroupIds(id));\n    }\n    async getSelectionSetCandidates(ss) {\n        return this.postFilterIds(await super.getSelectionSetCandidates(ss));\n    }\n    async getDragSelectCandidates(vp, origin, corner, method, overlap) {\n        return this.postFilterIds(await super.getDragSelectCandidates(vp, origin, corner, method, overlap));\n    }\n    setupAccuDraw() { }\n    setupAndPromptForNextAction() {\n        this.setupAccuDraw();\n        super.setupAndPromptForNextAction();\n    }\n    async doUpdateElement(_props) { return false; }\n    async applyAgendaOperation(ev) {\n        const geometry = this.getGeometryProps(ev, true);\n        if (undefined === geometry)\n            return false;\n        const elemProps = this.getElementProps(ev);\n        if (undefined === elemProps)\n            return false;\n        if (\"flatbuffer\" === geometry.format)\n            elemProps.elementGeometryBuilderParams = { entryArray: geometry.data };\n        else\n            elemProps.geom = geometry.data;\n        return this.doUpdateElement(elemProps);\n    }\n    async processAgenda(ev) {\n        if (await this.applyAgendaOperation(ev))\n            return this.saveChanges();\n    }\n}\n/** Edit tool base class for updating existing elements that use dynamics to show intermediate results.\n * @beta\n */\nexport class ModifyElementWithDynamicsTool extends ModifyElementTool {\n    constructor() {\n        super(...arguments);\n        this._firstResult = true;\n    }\n    get wantAccuSnap() { return true; }\n    get wantDynamics() { return true; }\n    agendaAppearance(isDynamics) {\n        if (isDynamics) {\n            if (undefined === this._agendaAppearanceDynamic)\n                this._agendaAppearanceDynamic = FeatureAppearance.fromTransparency(0.0);\n            return this._agendaAppearanceDynamic;\n        }\n        if (undefined === this._agendaAppearanceDefault)\n            this._agendaAppearanceDefault = FeatureAppearance.fromTransparency(0.9);\n        return this._agendaAppearanceDefault;\n    }\n    get wantAgendaAppearanceOverride() { return false; }\n    addFeatureOverrides(overrides, _vp) {\n        if (this.agenda.isEmpty)\n            return;\n        const appearance = this.agendaAppearance(false);\n        this.agenda.elements.forEach((elementId) => overrides.override({ elementId, appearance }));\n    }\n    updateAgendaAppearanceProvider(drop) {\n        if (!this.wantAgendaAppearanceOverride)\n            return;\n        for (const vp of IModelApp.viewManager) {\n            if (!this.allowView(vp))\n                continue;\n            if (drop || this.agenda.isEmpty)\n                vp.dropFeatureOverrideProvider(this);\n            else if (!vp.addFeatureOverrideProvider(this))\n                vp.setFeatureOverrideProviderChanged();\n        }\n    }\n    clearGraphics() {\n        if (undefined === this._graphicsProvider)\n            return;\n        this._graphicsProvider.cleanupGraphic();\n        this._graphicsProvider = undefined;\n    }\n    async createGraphics(ev) {\n        if (!IModelApp.viewManager.inDynamicsMode)\n            return; // Don't need to create graphic if dynamics aren't yet active...\n        const geometry = this.getGeometryProps(ev, false);\n        if (undefined === geometry) {\n            this.clearGraphics();\n            return;\n        }\n        const elemProps = this.getElementProps(ev);\n        if (undefined === elemProps?.placement) {\n            this.clearGraphics();\n            return;\n        }\n        if (undefined === this._graphicsProvider) {\n            if (this._firstResult) {\n                this.updateAgendaAppearanceProvider();\n                this._firstResult = false;\n            }\n            this._graphicsProvider = new DynamicGraphicsProvider(this.iModel, this.toolId);\n        }\n        // Set chord tolerance for non-linear/non-planar geometry...\n        if (ev.viewport)\n            this._graphicsProvider.chordTolerance = computeChordToleranceFromPoint(ev.viewport, ev.point);\n        await this._graphicsProvider.createGraphic(elemProps.category, elemProps.placement, geometry);\n    }\n    onDynamicFrame(_ev, context) {\n        if (undefined !== this._graphicsProvider)\n            this._graphicsProvider.addGraphic(context);\n    }\n    async onMouseMotion(ev) {\n        return this.createGraphics(ev);\n    }\n    async onUnsuspend() {\n        if (!this._firstResult)\n            this.updateAgendaAppearanceProvider();\n        return super.onUnsuspend();\n    }\n    async onSuspend() {\n        if (!this._firstResult)\n            this.updateAgendaAppearanceProvider(true);\n        return super.onSuspend();\n    }\n    async onPostInstall() {\n        await super.onPostInstall();\n        if (this.wantAgendaAppearanceOverride)\n            this.agenda.manageHiliteState = false;\n    }\n    async onCleanup() {\n        this.clearGraphics();\n        this.updateAgendaAppearanceProvider(true);\n        return super.onCleanup();\n    }\n}\n//# sourceMappingURL=ModifyElementTool.js.map",
      "start": 1693508122916,
      "end": 1693508123034,
      "sourcemaps": null
    }
  ]
}
