{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/LocalhostIpcApp.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module IModelApp\n */\nimport { IpcSession, IpcWebSocket, IpcWebSocketFrontend, IpcWebSocketMessage, IpcWebSocketTransport, rpcOverIpcStrings } from \"@itwin/core-common\";\nimport { IpcApp } from \"./IpcApp\";\nimport { IModelApp } from \"./IModelApp\";\nclass LocalTransport extends IpcWebSocketTransport {\n    constructor(opts) {\n        super();\n        this._pending = [];\n        let url;\n        if (opts?.localhostIpcApp?.socketUrl) {\n            url = opts?.localhostIpcApp?.socketUrl;\n        }\n        else {\n            const port = opts?.localhostIpcApp?.socketPort ?? 3002;\n            url = new URL(`ws://localhost:${port}/`);\n        }\n        this._client = new WebSocket(url);\n        this._next = -1;\n        this._client.addEventListener(\"open\", () => {\n            const pending = this._pending;\n            this._pending = undefined;\n            pending.forEach((m) => this.send(m));\n        });\n        this._client.addEventListener(\"message\", async (event) => {\n            const message = await this.notifyIncoming(event.data, this._client);\n            if (IpcWebSocketMessage.skip(message)) {\n                return;\n            }\n            for (const listener of IpcWebSocket.receivers)\n                listener({}, message);\n        });\n    }\n    send(message) {\n        if (this._pending) {\n            this._pending.push(message);\n            return;\n        }\n        message.sequence = ++this._next;\n        const parts = this.serialize(message);\n        parts.forEach((part) => this._client.send(part));\n    }\n}\nclass LocalSession extends IpcSession {\n    async handleRpc(info) {\n        return IpcApp.callIpcChannel(rpcOverIpcStrings.channelName, \"request\", info);\n    }\n}\n/**\n * To be used only by test applications that want to test web-based editing using localhost.\n *  @internal\n */\nclass LocalhostIpcApp {\n    static buildUrlForSocket(base, path = \"ipc\") {\n        const url = new URL(base);\n        url.protocol = \"ws\";\n        url.pathname = [...url.pathname.split(\"/\"), path].filter((v) => v).join(\"/\");\n        return url;\n    }\n    static async startup(opts) {\n        if (!this._initialized) {\n            IpcWebSocket.transport = new LocalTransport(opts);\n            this._ipc = new IpcWebSocketFrontend();\n            this._initialized = true;\n        }\n        await IpcApp.startup(this._ipc, opts);\n        if (!IpcSession.active) {\n            IpcSession.start(new LocalSession());\n            IModelApp.onBeforeShutdown.addListener(() => IpcSession.stop());\n        }\n    }\n}\nLocalhostIpcApp._initialized = false;\nexport { LocalhostIpcApp };\n//# sourceMappingURL=LocalhostIpcApp.js.map",
      "start": 1693508120099,
      "end": 1693508120582,
      "sourcemaps": null
    }
  ]
}
