{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/bentley/lib/esm/TypedArrayBuilder.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Collections\n */\nimport { assert } from \"./Assert\";\n/** Incrementally builds a [TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) of unsigned 8-, 16-, or 32-bit integers.\n * Sometimes you wish to populate a `TypedArray`, but you don't know how many elements you will need.\n * `TypedArray` requires you to specify the size upon construction, and does not permit you to change the size later.\n *\n * `TypedArrayBuilder` manages a `TypedArray`, permitting you to [[push]] and [[append]] elements to it. It exposes two \"size\" properties\":\n *  - [[capacity]], the number of elements it has currently allocated space for - i.e., the length of the underlying TypedArray; and\n *  - [[length]], the number of elements that have so far been added to it, which is never bigger than [[capacity]].\n * When [[capacity]] is exceeded, a new, bigger TypedArray is allocated and the contents of the previous array are copied over to it.\n *\n * Once you've finished adding elements, you can obtain the finished `TypedArray` via [[toTypedArray]].\n * @see [[Uint8ArrayBuilder]], [[Uint16ArrayBuilder]], and [[Uint32ArrayBuilder]] to build specific types of arrays.\n * @see [[UintArrayBuilder]] when you don't know the maximum number of bytes required for each element in the array.\n * @public\n */\nexport class TypedArrayBuilder {\n    /** Constructs a new builder from the specified options, with a [[length]] of zero. */\n    constructor(constructor, options) {\n        this._constructor = constructor;\n        this._data = new constructor(options?.initialCapacity ?? 0);\n        this.growthFactor = Math.max(1.0, options?.growthFactor ?? 1.5);\n        this._length = 0;\n    }\n    /** The number of elements currently in the array. */\n    get length() {\n        return this._length;\n    }\n    /** The number of elements that can fit into the memory currently allocated for the array. */\n    get capacity() {\n        return this._data.length;\n    }\n    /** Like [TypedArray.at](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/at),\n     * returns the element at the specified index, with negative integers counting back from the end of the array.\n     * @note It is your responsibility to ensure the index falls within the bounds of the array.\n     */\n    at(index) {\n        if (index < 0)\n            index = this.length - index;\n        const value = this._data[index];\n        assert(value !== undefined, \"index out of bounds\");\n        return value;\n    }\n    /** Ensure that [[capacity]] is at least equal to `newCapacity`.\n     * This is used internally by methods like [[push]] and [[append]] to ensure the array has room for the element(s) to be added.\n     * It can also be useful when you know you intend to add some number of additional elements, to minimize reallocations.\n     *\n     * If `newCapacity` is not greater than the current [[capacity]], this function does nothing.\n     * Otherwise, it allocates a new `TypedArray` with room for `newCapacity * growthFactor` elements, and copies the contents of the previous `TypedArray` into it.\n     * [[length]] remains unchanged; [[capacity]] reflects the size of the new TypeArray.\n     */\n    ensureCapacity(newCapacity) {\n        if (this.capacity >= newCapacity)\n            return this.capacity;\n        assert(this.growthFactor >= 1.0);\n        newCapacity = Math.ceil(newCapacity * this.growthFactor);\n        const prevData = this._data;\n        this._data = new this._constructor(newCapacity);\n        this._data.set(prevData, 0);\n        assert(this.capacity === newCapacity);\n        return this.capacity;\n    }\n    /** Append the specified value, resizing if necessary. */\n    push(value) {\n        this.ensureCapacity(this.length + 1);\n        this._data[this.length] = value;\n        ++this._length;\n    }\n    /** Append an array of values, resizing (at most once) if necessary. */\n    append(values) {\n        const newLength = this.length + values.length;\n        this.ensureCapacity(newLength);\n        this._data.set(values, this.length);\n        this._length = newLength;\n    }\n    /** Obtain the finished array.\n     * @param includeUnusedCapacity If true, the length of the returned array will be equal to [[capacity]], with extra bytes initialized to zero; otherwise, the\n     * returned array's length will be equal to [[length]].\n     */\n    toTypedArray(includeUnusedCapacity = false) {\n        if (includeUnusedCapacity)\n            return this._data;\n        const subarray = this._data.subarray(0, this.length);\n        assert(subarray instanceof this._constructor);\n        assert(subarray.buffer === this._data.buffer);\n        return subarray;\n    }\n}\n/** A [[TypedArrayBuilder]] for producing a [Uint8Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array).\n * @public\n */\nexport class Uint8ArrayBuilder extends TypedArrayBuilder {\n    /** See [[TypedArrayBuilder]] constructor. */\n    constructor(options) {\n        super(Uint8Array, options);\n    }\n}\n/** A [[TypedArrayBuilder]] for producing a [Uint16Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array).\n * @public\n */\nexport class Uint16ArrayBuilder extends TypedArrayBuilder {\n    /** See [[TypedArrayBuilder]] constructor. */\n    constructor(options) {\n        super(Uint16Array, options);\n    }\n}\n/** A [[TypedArrayBuilder]] for producing a [Uint32Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array).\n * @public\n */\nexport class Uint32ArrayBuilder extends TypedArrayBuilder {\n    /** See [[TypedArrayBuilder]] constructor. */\n    constructor(options) {\n        super(Uint32Array, options);\n    }\n    /** Obtain a view of the finished array as an array of bytes. */\n    toUint8Array(includeUnusedCapacity = false) {\n        if (includeUnusedCapacity)\n            return new Uint8Array(this._data.buffer);\n        return new Uint8Array(this._data.buffer, 0, this.length * 4);\n    }\n}\n/** A [[TypedArrayBuilder]] that can populate a [[UintArray]] with the minimum\n * [bytes per element](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/BYTES_PER_ELEMENT) required.\n *\n * By default, the underlying array is a `Uint8Array`, though this can be configured via [[UintArrayBuilderOptions.initialType]].\n * As values are added to the array, if the bytes per element supported by the underlying array is too small to hold one of the new values, the array is\n * reallocated to a type large enough to hold all of the new values. For example, the following produces a `Uint8Array` because all values are less than 256:\n *\n * ```ts\n *  const builder = new UintArrayBuilder();\n *  builder.append([1, 2, 254, 255]);\n *  const array = builder.toTypedArray();\n *  assert(array instanceof Uint8Array);\n * ```\n *\n * However, the following produces a `Uint16Array` because one of the values is larger than 255 but none are larger than 65,535:\n *\n * ```ts\n *  const builder = new UintArrayBuilder();\n *  builder.append([1, 255, 257, 65535]);\n *  const array = builder.toTypedArray();\n *  assert(array instanceof Uint16Array);\n * ```\n *\n * @see [[Uint8ArrayBuilder]], [[Uint16ArrayBuilder]], or [[Uint32ArrayBuilder]] if you know the number of bytes you want to allocate for each element in the array.\n * @public\n */\nexport class UintArrayBuilder extends TypedArrayBuilder {\n    constructor(options) {\n        super(options?.initialType ?? Uint8Array, options);\n    }\n    /** The number of bytes (1, 2, or 4) currently allocated per element by the underlying array.\n     * This may change as larger values are added to the array.\n     */\n    get bytesPerElement() {\n        return this._data.BYTES_PER_ELEMENT;\n    }\n    /** Ensures that the underlying array is of a type that can contain the largest value in `newValues`.\n     * For example, if `_data` is a `Uint16Array` and `newValues` contains any value(s) larger than 65,535, it will be replaced with a `Uint32Array`.\n     * This method is invoked by [[push]] and [[append]].\n     */\n    ensureBytesPerElement(newValues) {\n        const curBytesPerElem = this.bytesPerElement;\n        assert(curBytesPerElem === 1 || curBytesPerElem === 2 || curBytesPerElem === 4);\n        if (curBytesPerElem >= 4)\n            return;\n        let neededBytesPerElem = curBytesPerElem;\n        for (const value of newValues) {\n            if (value > 0xffff) {\n                neededBytesPerElem = 4;\n                break;\n            }\n            else if (value > 0xff) {\n                neededBytesPerElem = 2;\n            }\n        }\n        if (neededBytesPerElem <= curBytesPerElem)\n            return;\n        this._constructor = neededBytesPerElem === 1 ? Uint8Array : (neededBytesPerElem === 2 ? Uint16Array : Uint32Array);\n        this._data = new this._constructor(this._data);\n    }\n    /** See [[TypedArrayBuilder.push]]. */\n    push(value) {\n        this.ensureBytesPerElement([value]);\n        super.push(value);\n    }\n    /** See [[TypedArrayBuilder.append]]. */\n    append(values) {\n        this.ensureBytesPerElement(values);\n        super.append(values);\n    }\n}\n//# sourceMappingURL=TypedArrayBuilder.js.map",
      "start": 1693508120633,
      "end": 1693508120698,
      "sourcemaps": null
    }
  ]
}
