{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend-devtools/lib/esm/effects/Saturation.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Effects\n */\nimport { Tool, UniformType, VaryingType } from \"@itwin/core-frontend\";\nimport { parseArgs } from \"../tools/parseArgs\";\nimport { AddEffectTool, refreshViewportsForEffect } from \"./EffectTools\";\n/** Adjusts the saturation of colors in a viewport.\n * @beta\n */\nclass SaturationEffect extends AddEffectTool {\n    get effectName() { return \"Saturation\"; }\n    get textureCoordFromPosition() { return true; }\n    get source() {\n        // rgb <-> hsl conversion routines from https://gamedev.stackexchange.com/questions/59797/glsl-shader-change-hue-saturation-brightness\n        return {\n            // Vertex shader simply computes texture coordinate for source pixel.\n            vertex: `\r\n        void effectMain(vec4 pos) {\r\n          v_texCoord = textureCoordFromPosition(pos);\r\n        }`,\n            // Fragment shader converts color to HSV, adjusts the saturation, and converts back to RGB.\n            fragment: `\r\n        vec3 rgb2hsv(vec3 c) {\r\n          vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\r\n          vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\r\n          vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\r\n\r\n          float d = q.x - min(q.w, q.y);\r\n          float e = 1.0e-10;\r\n          return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\r\n        }\r\n\r\n        vec3 hsv2rgb(vec3 c) {\r\n          vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\r\n          vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\r\n          return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\r\n        }\r\n\r\n        vec4 effectMain() {\r\n          vec4 color = TEXTURE(u_diffuse, v_texCoord);\r\n          color.rgb = rgb2hsv(color.rgb);\r\n          color.rgb.y = color.rgb.y * u_saturationMult;\r\n          color.rgb = hsv2rgb(color.rgb);\r\n          return color;\r\n        }`,\n        };\n    }\n    defineEffect(builder) {\n        builder.addVarying(\"v_texCoord\", VaryingType.Vec2);\n        builder.addUniform({\n            name: \"u_saturationMult\",\n            type: UniformType.Float,\n            bind: (uniform) => uniform.setUniform1f(SaturationConfig.multiplier),\n        });\n    }\n}\nSaturationEffect.toolId = \"SaturationEffect\";\nexport { SaturationEffect };\n/** Configures the [[SaturationEffect]].\n * @beta\n */\nclass SaturationConfig extends Tool {\n    static get minArgs() { return 0; }\n    static get maxArgs() { return 1; }\n    async run(multiplier) {\n        SaturationConfig.multiplier = multiplier ?? 2.0;\n        refreshViewportsForEffect(\"fdt Saturation\");\n        return true;\n    }\n    async parseAndRun(...input) {\n        const args = parseArgs(input);\n        return this.run(args.getFloat(\"s\"));\n    }\n}\nSaturationConfig.toolId = \"SaturationConfig\";\n/** Multiplier applied to the saturation of each color in the source image. */\nSaturationConfig.multiplier = 2.0;\nexport { SaturationConfig };\n//# sourceMappingURL=Saturation.js.map",
      "start": 1693508122605,
      "end": 1693508122704,
      "sourcemaps": null
    }
  ]
}
