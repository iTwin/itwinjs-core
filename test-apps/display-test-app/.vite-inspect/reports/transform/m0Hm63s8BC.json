{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/SpatialViewState.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Views\n */\nimport { BeEvent, CompressedId64Set } from \"@itwin/core-bentley\";\nimport { Constant, Range3d } from \"@itwin/core-geometry\";\nimport { AuxCoordSystemSpatialState } from \"./AuxCoordSys\";\nimport { ModelSelectorState } from \"./ModelSelectorState\";\nimport { CategorySelectorState } from \"./CategorySelectorState\";\nimport { DisplayStyle3dState } from \"./DisplayStyleState\";\nimport { ViewState3d } from \"./ViewState\";\nimport { SpatialTileTreeReferences } from \"./tile/internal\";\n/** Defines a view of one or more SpatialModels.\n * The list of viewed models is stored in the ModelSelector.\n * @public\n * @extensions\n */\nexport class SpatialViewState extends ViewState3d {\n    static get className() { return \"SpatialViewDefinition\"; }\n    get modelSelector() {\n        return this._modelSelector;\n    }\n    set modelSelector(selector) {\n        if (selector === this.modelSelector)\n            return;\n        const isAttached = this.isAttachedToViewport;\n        this.unregisterModelSelectorListeners();\n        this._modelSelector = selector;\n        if (isAttached) {\n            this.registerModelSelectorListeners();\n            this.onViewedModelsChanged.raiseEvent();\n        }\n    }\n    /** Create a new *blank* SpatialViewState. The returned SpatialViewState will nave non-persistent empty [[CategorySelectorState]] and [[ModelSelectorState]],\n     * and a non-persistent [[DisplayStyle3dState]] with default values for all of its components. Generally after creating a blank SpatialViewState,\n     * callers will modify the state to suit specific needs.\n     * @param iModel The IModelConnection for the new SpatialViewState\n     * @param origin The origin for the new SpatialViewState\n     * @param extents The extents for the new SpatialViewState\n     * @param rotation The rotation of the new SpatialViewState. If undefined, use top view.\n     * @public\n     */\n    static createBlank(iModel, origin, extents, rotation) {\n        const blank = {};\n        const cat = new CategorySelectorState(blank, iModel);\n        const modelSelectorState = new ModelSelectorState(blank, iModel);\n        const displayStyleState = new DisplayStyle3dState(blank, iModel);\n        const view = new this(blank, iModel, cat, displayStyleState, modelSelectorState);\n        view.setOrigin(origin);\n        view.setExtents(extents);\n        if (undefined !== rotation)\n            view.setRotation(rotation);\n        return view;\n    }\n    static createFromProps(props, iModel) {\n        const cat = new CategorySelectorState(props.categorySelectorProps, iModel);\n        const displayStyleState = new DisplayStyle3dState(props.displayStyleProps, iModel);\n        const modelSelectorState = new ModelSelectorState(props.modelSelectorProps, iModel);\n        return new this(props.viewDefinitionProps, iModel, cat, displayStyleState, modelSelectorState);\n    }\n    toProps() {\n        const props = super.toProps();\n        props.modelSelectorProps = this.modelSelector.toJSON();\n        return props;\n    }\n    constructor(props, iModel, arg3, displayStyle, modelSelector) {\n        super(props, iModel, arg3, displayStyle);\n        this._unregisterModelSelectorListeners = [];\n        /** An event raised when the set of models viewed by this view changes, *only* if the view is attached to a [[Viewport]].\n         * @public\n         */\n        this.onViewedModelsChanged = new BeEvent();\n        this._modelSelector = modelSelector;\n        if (arg3 instanceof SpatialViewState) // from clone\n            this._modelSelector = arg3.modelSelector.clone();\n        this._treeRefs = SpatialTileTreeReferences.create(this);\n    }\n    /** @internal */\n    isSpatialView() { return true; }\n    equals(other) { return super.equals(other) && this.modelSelector.equals(other.modelSelector); }\n    createAuxCoordSystem(acsName) { return AuxCoordSystemSpatialState.createNew(acsName, this.iModel); }\n    get defaultExtentLimits() { return { min: Constant.oneMillimeter, max: 3 * Constant.diameterOfEarth }; } // Increased max by 3X to support globe mode.\n    /** @internal */\n    markModelSelectorChanged() {\n        this._treeRefs.update();\n    }\n    /** Get world-space viewed extents based on the iModel's project extents.\n     * @deprecated in 3.6. These extents are based on [[IModelConnection.displayedExtents]], which is deprecated. Consider using [[computeFitRange]] or [[getViewedExtents]] instead.\n     */\n    getDisplayedExtents() {\n        /* eslint-disable-next-line deprecation/deprecation */\n        const extents = Range3d.fromJSON(this.iModel.displayedExtents);\n        extents.scaleAboutCenterInPlace(1.0001); // projectExtents. lying smack up against the extents is not excluded by frustum...\n        extents.extendRange(this.getGroundExtents());\n        return extents;\n    }\n    computeBaseExtents() {\n        const extents = Range3d.fromJSON(this.iModel.projectExtents);\n        // Ensure geometry coincident with planes of the project extents is not clipped.\n        extents.scaleAboutCenterInPlace(1.0001);\n        // Ensure ground plane is not clipped, if it's being drawn.\n        extents.extendRange(this.getGroundExtents());\n        return extents;\n    }\n    /** Compute a volume in world coordinates tightly encompassing the contents of the view. The volume is computed from the union of the volumes of the\n     * view's viewed models, including [GeometricModel]($backend)s and reality models.\n     * Those volumes are obtained from the [[TileTree]]s used to render those models, so any tile tree that has not yet been loaded will not contribute to the computation.\n     * If `options.baseExtents` is defined, it will be unioned with the computed volume.\n     * If the computed volume is null (empty), a default volume will be computed from [IModel.projectExtents]($common), which may be a looser approximation of the\n     * models' volumes.\n     * @param options Options used to customize how the volume is computed.\n     * @returns A non-null volume in world coordinates encompassing the contents of the view.\n     */\n    computeFitRange(options) {\n        // Fit to the union of the ranges of all loaded tile trees.\n        const range = options?.baseExtents?.clone() ?? new Range3d();\n        this.forEachTileTreeRef((ref) => {\n            ref.unionFitRange(range);\n        });\n        // Fall back to the project extents if necessary.\n        if (range.isNull)\n            range.setFrom(this.computeBaseExtents());\n        // Avoid ridiculously small extents.\n        range.ensureMinLengths(1.0);\n        return range;\n    }\n    getViewedExtents() {\n        // Encompass the project extents and ground plane.\n        const extents = this.computeBaseExtents();\n        // Include any tile trees that extend outside the project extents.\n        extents.extendRange(this.computeFitRange());\n        return extents;\n    }\n    toJSON() {\n        const val = super.toJSON();\n        val.modelSelectorId = this.modelSelector.id;\n        return val;\n    }\n    /** @internal */\n    preload(hydrateRequest) {\n        super.preload(hydrateRequest);\n        const notLoaded = this.iModel.models.filterLoaded(this.modelSelector.models);\n        if (undefined === notLoaded)\n            return; // all requested models are already loaded\n        hydrateRequest.notLoadedModelSelectorStateModels = CompressedId64Set.sortAndCompress(notLoaded);\n    }\n    /** @internal */\n    async postload(hydrateResponse) {\n        const promises = [];\n        promises.push(super.postload(hydrateResponse));\n        if (hydrateResponse.modelSelectorStateModels !== undefined)\n            promises.push(this.iModel.models.updateLoadedWithModelProps(hydrateResponse.modelSelectorStateModels));\n        await Promise.all(promises);\n    }\n    viewsModel(modelId) { return this.modelSelector.containsModel(modelId); }\n    clearViewedModels() { this.modelSelector.models.clear(); }\n    addViewedModel(id) { this.modelSelector.addModels(id); }\n    removeViewedModel(id) { this.modelSelector.dropModels(id); }\n    forEachModel(func) {\n        for (const modelId of this.modelSelector.models) {\n            const model = this.iModel.models.getLoaded(modelId);\n            if (undefined !== model && undefined !== model.asGeometricModel3d)\n                func(model);\n        }\n    }\n    /** @internal */\n    forEachModelTreeRef(func) {\n        for (const ref of this._treeRefs)\n            func(ref);\n    }\n    /** @internal */\n    createScene(context) {\n        super.createScene(context);\n        context.textureDrapes.forEach((drape) => drape.collectGraphics(context));\n        context.viewport.target.updateSolarShadows(this.getDisplayStyle3d().wantShadows ? context : undefined);\n    }\n    /** See [[ViewState.attachToViewport]]. */\n    attachToViewport(args) {\n        super.attachToViewport(args);\n        this.registerModelSelectorListeners();\n        this._treeRefs.attachToViewport(args);\n    }\n    /** See [[ViewState.detachFromViewport]]. */\n    detachFromViewport() {\n        super.detachFromViewport();\n        this._treeRefs.detachFromViewport();\n        this.unregisterModelSelectorListeners();\n    }\n    /** Chiefly for debugging: change the \"deactivated\" state of one or more tile tree references. Deactivated references are\n     * omitted when iterating the references, so e.g. their graphics are omitted from the scene.\n     * @param modelIds The Ids of one or more models whose tile tree references are to be affected. If omitted, all models are affected.\n     * @param deactivated True to deactivate the specified references, false to reactivate them, undefined to invert each one's current state.\n     * @param which The references to be affected as either a broad category or one or more indices of animated references.\n     * @internal\n     */\n    setTileTreeReferencesDeactivated(modelIds, deactivated, which) {\n        this._treeRefs.setDeactivated(modelIds, deactivated, which);\n    }\n    registerModelSelectorListeners() {\n        const models = this.modelSelector.observableModels;\n        const func = () => {\n            this.markModelSelectorChanged();\n            this.onViewedModelsChanged.raiseEvent();\n        };\n        this._unregisterModelSelectorListeners.push(models.onAdded.addListener(func));\n        this._unregisterModelSelectorListeners.push(models.onDeleted.addListener(func));\n        this._unregisterModelSelectorListeners.push(models.onCleared.addListener(func));\n    }\n    unregisterModelSelectorListeners() {\n        this._unregisterModelSelectorListeners.forEach((f) => f());\n        this._unregisterModelSelectorListeners.length = 0;\n    }\n}\n/** Defines a spatial view that displays geometry on the image plane using a parallel orthographic projection.\n * @public\n * @extensions\n */\nexport class OrthographicViewState extends SpatialViewState {\n    static get className() { return \"OrthographicViewDefinition\"; }\n    constructor(props, iModel, categories, displayStyle, modelSelector) { super(props, iModel, categories, displayStyle, modelSelector); }\n    supportsCamera() { return false; }\n}\n//# sourceMappingURL=SpatialViewState.js.map",
      "start": 1693508119462,
      "end": 1693508119630,
      "sourcemaps": null
    }
  ]
}
