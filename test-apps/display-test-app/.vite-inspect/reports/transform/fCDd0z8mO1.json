{
  "resolvedId": "D:/hub2023A/itwinjs-core/extensions/map-layers-formats/lib/esm/Tools/MapFeatureInfoDecorator.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/* eslint-disable no-console */\nimport { Base64EncodedString, ColorDef } from \"@itwin/core-common\";\nimport { GraphicType, IModelApp, MapTileTreeReference, Marker, MarkerSet, TileGeometryCollector, TileUser } from \"@itwin/core-frontend\";\nimport { ConvexClipPlaneSet, GrowableXYZArray, Point2d, Point3d, PolyfaceQuery, Range3d, SweepLineStringToFacetsOptions, Vector3d } from \"@itwin/core-geometry\";\n/** A TileGeometryCollector that restricts collection to tiles that overlap a line string.\n/* @internal\n*/\nclass DrapeLineStringCollector extends TileGeometryCollector {\n    constructor(user, chordTolerance, range, transform, _points) {\n        super({ user, chordTolerance, range, transform });\n        this._points = _points;\n    }\n    collectTile(tile) {\n        let status = super.collectTile(tile);\n        if (\"reject\" !== status && !this.rangeOverlapsLineString(tile.range))\n            status = \"reject\";\n        return status;\n    }\n    rangeOverlapsLineString(range) {\n        let inside = false;\n        const clipper = ConvexClipPlaneSet.createRange3dPlanes(range, true, true, true, true, false, false);\n        if (this._options.transform)\n            clipper.transformInPlace(this._options.transform);\n        for (let i = 0; i < this._points.length - 1 && !inside; i++)\n            inside = clipper.announceClippedSegmentIntervals(0, 1, this._points.getPoint3dAtUncheckedPointIndex(i), this._points.getPoint3dAtUncheckedPointIndex(i + 1));\n        return inside;\n    }\n}\n/** @internal */\nclass TerrainDraper {\n    constructor(viewport, treeRef) {\n        this.viewport = viewport;\n        this.treeRef = treeRef;\n        this.tileUserId = TileUser.generateId();\n        IModelApp.tileAdmin.registerUser(this);\n    }\n    dispose() {\n        IModelApp.tileAdmin.forgetUser(this);\n    }\n    get iModel() { return this.viewport.iModel; }\n    onRequestStateChanged() {\n        this.viewport.invalidateDecorations();\n    }\n    discloseTileTrees(trees) {\n        trees.disclose(this.treeRef);\n    }\n    drapeLineString(outStrings, inPoints, tolerance, maxDistance = 1.0E5) {\n        const tree = this.treeRef.treeOwner.load();\n        if (!tree)\n            return \"loading\";\n        const range = Range3d.createNull();\n        range.extendArray(inPoints);\n        range.extendZOnly(-maxDistance); // Expand - but not so much that we get opposite side of globe.\n        range.extendZOnly(maxDistance);\n        const collector = new DrapeLineStringCollector(this, tolerance, range, tree.iModelTransform, inPoints);\n        this.treeRef.collectTileGeometry(collector);\n        collector.requestMissingTiles();\n        if (collector.isAllGeometryLoaded && collector.polyfaces.length > 0) {\n            for (const polyface of collector.polyfaces)\n                outStrings.push(...PolyfaceQuery.sweepLineStringToFacets(inPoints, polyface, SweepLineStringToFacetsOptions.create(Vector3d.unitZ(), undefined, true, true, false, false)));\n            return \"complete\";\n        }\n        return \"loading\";\n    }\n}\n/** @internal */\nclass PinMarker extends Marker {\n    constructor(worldLocation, size, image) {\n        super(worldLocation, size);\n        this.image = image;\n        this.imageOffset = new Point3d(0, Math.floor(size.y * .5));\n    }\n}\n/** @internal */\nclass PinMarkerCluster extends Marker {\n    /** Create a new cluster marker */\n    constructor(location, size, cluster, image) {\n        super(location, size);\n        this.title = IModelApp.localization.getLocalizedString(\"mapLayersFormats:Messages.MapFeatureInfoDecorator.clusterZoomIn\", { nbInstances: cluster.markers.length });\n        this.imageOffset = new Point3d(0, size.y * 0.5);\n        this.label = cluster.markers.length.toLocaleString();\n        this.labelColor = \"black\";\n        this.labelFont = \"bold 14px sans-serif\";\n        if (image)\n            this.setImage(image);\n    }\n    /** Show the cluster as a white circle with an outline */\n    drawFunc(ctx) {\n        ctx.beginPath();\n        ctx.strokeStyle = \"#372528\";\n        ctx.fillStyle = \"white\";\n        ctx.lineWidth = 5;\n        ctx.arc(0, 0, this.size.x * 0.5, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.stroke();\n    }\n    onMouseButton(_ev) { return true; } // Don't allow clicks to be sent to active tool...\n}\n/** @internal */\nclass PinMarkerSet extends MarkerSet {\n    getClusterMarker(cluster) {\n        // No image passed to the cluster, we prefer to have the circle only\n        return new PinMarkerCluster(cluster.getClusterLocation(), cluster.markers[0].size, cluster, undefined);\n    }\n}\n/** @internal */\nexport class MapFeatureInfoDecorator {\n    get highlightColor() { return this._highlightColor; }\n    set highlightColor(color) {\n        this.updateMarkerImage();\n        this._highlightColor = color;\n    }\n    get defaultMarkerIconSvgXml() { return `<svg class=\"indicator\" viewBox=\"0 0 22 22\" width=\"22\" height=\"22\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"m11 0a7.44506 7.44506 0 0 0 -7.5 7.2875c0 1.65 1.132 4.2625 3.25477 8.1125 1.55652 2.75 4.24523 6.6 4.24523 6.6s2.68865-3.9875 4.24528-6.7375c2.12272-3.85 3.25472-6.4625 3.25472-8.1125a7.4215 7.4215 0 0 0 -7.5-7.15z\" fill=\"black\"/><path d=\"m11 1.01715a6.46476 6.46476 0 0 0 -6.48285 6.27033c0 1.72619 1.67181 4.97973 3.12836 7.62139.97564 1.7237 2.42828 3.92176 3.34118 5.27161.91413-1.39148 2.385-3.673 3.37336-5.41907 1.451-2.63171 3.1228-5.88525 3.1228-7.61139a6.39982 6.39982 0 0 0 -6.48285-6.13287zm.00183 8.98285a3 3 0 1 1 3-3 3 3 0 0 1 -3 3z\" fill=\"${this.highlightColor.toRgbString()}\"/></svg>`; }\n    constructor() {\n        this.useCachedDecorations = true;\n        this.disableTerrainDraper = true;\n        this.markerSize = new Point2d(32, 32);\n        this.lineWidth = 3;\n        this._highlightColor = ColorDef.from(0, 255, 255, 127);\n        this._drapePoints = new GrowableXYZArray();\n        this._scratchPoints = new GrowableXYZArray();\n        this._drapePointsStates = [];\n        this._allGeomDraped = false;\n        this._markerSet = new PinMarkerSet();\n        this._graphicType = GraphicType.WorldOverlay;\n        this.setState = (state) => {\n            this._drapedStrings = undefined;\n            this._allGeomDraped = false;\n            this._state = state;\n            IModelApp.viewManager.invalidateCachedDecorationsAllViews(this);\n            this._drapePoints.clear();\n            this._drapePointsStates = [];\n            if (!this.disableTerrainDraper && this._state.mapInfo?.layerInfos && state.hit.viewport.displayStyle.displayTerrain) {\n                if (state.hit?.modelId) {\n                    const drapeTreeRef = this.getGeometryTreeRef(state.hit.viewport);\n                    if (drapeTreeRef) {\n                        this._draper = new TerrainDraper(state.hit.viewport, drapeTreeRef);\n                        return;\n                    }\n                }\n            }\n            if (this._draper) {\n                // Dispose draper every time?\n                this._draper.dispose();\n                this._draper = undefined;\n            }\n        };\n        this._markerImage = new Image();\n        this.updateMarkerImage();\n    }\n    updateMarkerImage() {\n        const base64 = Base64EncodedString.encode(this.defaultMarkerIconSvgXml);\n        this._markerImage.src = `data:image/svg+xml;base64,${base64}`;\n    }\n    _computeChordTolerance(viewport, applyAspectRatioSkew, computeRange) {\n        let pixelSize = 1;\n        // Compute the horizontal distance in meters between two adjacent pixels at the center of the geometry.\n        pixelSize = viewport.getPixelSizeAtPoint(computeRange().center);\n        pixelSize = viewport.target.adjustPixelSizeForLOD(pixelSize);\n        // Aspect ratio skew > 1.0 stretches the view in Y. In that case use the smaller vertical pixel distance for our stroke tolerance.\n        const skew = applyAspectRatioSkew ? viewport.view.getAspectRatioSkew() : 0;\n        if (skew > 1)\n            pixelSize /= skew;\n        return pixelSize * 0.25;\n    }\n    getGeometryTreeRef(vp) {\n        let treeRef;\n        if (vp.backgroundMapSettings.applyTerrain) {\n            vp.forEachMapTreeRef((ref) => {\n                if (!treeRef && ref instanceof MapTileTreeReference) {\n                    treeRef = ref.createGeometryTreeReference();\n                }\n            });\n        }\n        return treeRef;\n    }\n    renderGraphics(context) {\n        this._markerSet.markers.clear();\n        if (this._state?.mapInfo?.layerInfos === undefined) {\n            return undefined;\n        }\n        const builder = context.createGraphicBuilder(this._graphicType);\n        if (this._draper) {\n            if (this._drapePoints.length === 0 && this._state.mapInfo.layerInfos) {\n                for (const layerInfo of this._state.mapInfo.layerInfos) {\n                    if (layerInfo.subLayerInfos) {\n                        for (const subLayerInfo of layerInfo.subLayerInfos) {\n                            for (const feature of subLayerInfo.features) {\n                                if (feature.geometries) {\n                                    for (const geom of feature.geometries) {\n                                        if (geom.graphic.type === \"linestring\") {\n                                            this._drapePointsStates.push({ count: geom.graphic.points.length, collectorState: \"loading\" });\n                                            this._drapePoints.pushAll(geom.graphic.points);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            if (!this._allGeomDraped) {\n                let hasMissingLineStrings = false;\n                let drapePointsOffset = 0;\n                for (const state of this._drapePointsStates) {\n                    if (state.collectorState === \"loading\") {\n                        this._scratchPoints.clear();\n                        this._scratchPoints.resize(state.count);\n                        let dstIdx = 0;\n                        for (let srcIdx = drapePointsOffset; srcIdx < drapePointsOffset + state.count; srcIdx++) {\n                            this._scratchPoints.transferFromGrowableXYZArray(dstIdx++, this._drapePoints, srcIdx);\n                        }\n                        const drapeRange = Range3d.createNull();\n                        drapeRange.extendArray(this._scratchPoints);\n                        const drapedStrings = [];\n                        const tolerance = this._computeChordTolerance(context.viewport, true, () => drapeRange) * 10; // 10 pixels\n                        if (\"loading\" === this._draper.drapeLineString(drapedStrings, this._scratchPoints, tolerance)) {\n                            hasMissingLineStrings = true;\n                        }\n                        else {\n                            this.addDrapedStrings(drapedStrings);\n                            state.collectorState = \"complete\";\n                        }\n                    }\n                    drapePointsOffset += state.count;\n                }\n                this._allGeomDraped = !hasMissingLineStrings;\n            }\n            if (this._drapedStrings) {\n                builder.setSymbology(this.highlightColor, this.highlightColor, this.lineWidth);\n                this._drapedStrings.forEach((line) => builder.addLineString(line.points));\n            }\n        }\n        else {\n            builder.setSymbology(this.highlightColor, this.highlightColor, this.lineWidth);\n            for (const layerInfo of this._state.mapInfo.layerInfos) {\n                if (layerInfo.subLayerInfos && !(layerInfo.subLayerInfos instanceof HTMLElement)) {\n                    for (const subLayerInfo of layerInfo.subLayerInfos) {\n                        for (const feature of subLayerInfo.features) {\n                            if (feature.geometries) {\n                                for (const geom of feature.geometries) {\n                                    if (geom.graphic.type === \"pointstring\") {\n                                        for (const point of geom.graphic.points)\n                                            this._markerSet.markers.add(new PinMarker(point, this.markerSize, this._markerImage));\n                                    }\n                                    else {\n                                        builder.addPrimitive(geom.graphic);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return builder.finish();\n    }\n    addDrapedStrings(drapedStrings) {\n        if (!this._drapedStrings) {\n            this._drapedStrings = [];\n        }\n        for (const ds of drapedStrings)\n            this._drapedStrings.push(ds);\n    }\n    decorate(context) {\n        const graphics = this.renderGraphics(context);\n        if (graphics)\n            context.addDecoration(this._graphicType, graphics);\n        this._markerSet.addDecoration(context);\n        return;\n    }\n}\n//# sourceMappingURL=MapFeatureInfoDecorator.js.map",
      "start": 1693508125127,
      "end": 1693508125205,
      "sourcemaps": null
    }
  ]
}
