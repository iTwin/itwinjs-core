{
  "resolvedId": "D:/hub2023A/itwinjs-core/editor/frontend/lib/esm/ModifyCurveTools.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\nimport { DialogProperty, PropertyDescriptionHelper } from \"@itwin/appui-abstract\";\nimport { CompressedId64Set } from \"@itwin/core-bentley\";\nimport { BentleyError, Code, ElementGeometry, ElementGeometryOpcode, } from \"@itwin/core-common\";\nimport { AccuDrawHintBuilder, IModelApp, LengthDescription, NotifyMessageDetails, OutputMessagePriority, } from \"@itwin/core-frontend\";\nimport { AngleSweep, Arc3d, AxisOrder, CurveChainWithDistanceIndex, CurveCollection, CurvePrimitive, FrameBuilder, Geometry, JointOptions, LineSegment3d, LineString3d, Loop, Matrix3d, Path, Plane3dByOriginAndUnitNormal, RegionBinaryOpType, RegionOps, UnionRegion, Vector3d, } from \"@itwin/core-geometry\";\nimport { editorBuiltInCmdIds } from \"@itwin/editor-common\";\nimport { EditTools } from \"./EditTool\";\nimport { basicManipulationIpc } from \"./EditToolIpc\";\nimport { ModifyElementWithDynamicsTool } from \"./ModifyElementTool\";\n/** @alpha */\nexport class CurveData {\n    constructor(props, params, geom) {\n        this.props = props;\n        this.params = params;\n        this.geom = geom;\n    }\n}\n/** @alpha Base class for modifying all types of curve geometry. */\nexport class ModifyCurveTool extends ModifyElementWithDynamicsTool {\n    async startCommand() {\n        if (undefined !== this._startedCmd)\n            return this._startedCmd;\n        return EditTools.startCommand({ commandId: editorBuiltInCmdIds.cmdBasicManipulation, iModelKey: this.iModel.key });\n    }\n    static isSingleCurve(info) {\n        const it = new ElementGeometry.Iterator(info);\n        it.requestWorldCoordinates();\n        for (const entry of it) {\n            const geom = entry.toGeometryQuery();\n            if (undefined === geom)\n                return;\n            if (\"curvePrimitive\" === geom.geometryCategory) {\n                return { curve: geom, params: entry.geomParams };\n            }\n            else if (\"curveCollection\" === geom.geometryCategory) {\n                return { curve: geom, params: entry.geomParams };\n            }\n            break;\n        }\n        return;\n    }\n    static isInPlane(curve, plane) {\n        if (\"curvePrimitive\" === curve.geometryCategory)\n            return curve.isInPlane(plane);\n        if (!curve.children)\n            return false;\n        for (const child of curve.children) {\n            if (child instanceof CurvePrimitive) {\n                if (!child.isInPlane(plane))\n                    return false;\n            }\n            else if (child instanceof CurveCollection) {\n                if (!this.isInPlane(child, plane))\n                    return false;\n            }\n        }\n        return true;\n    }\n    acceptCurve(_curve) { return true; }\n    modifyCurve(_ev, _isAccept) { return undefined; }\n    async getCurveData(id) {\n        try {\n            this._startedCmd = await this.startCommand();\n            const reject = [ElementGeometryOpcode.Polyface, ElementGeometryOpcode.SolidPrimitive, ElementGeometryOpcode.BsplineSurface, ElementGeometryOpcode.BRep];\n            const info = await basicManipulationIpc.requestElementGeometry(id, { maxDisplayable: 1, reject, geometry: { curves: true, surfaces: true, solids: false } });\n            if (undefined === info)\n                return undefined;\n            const data = ModifyCurveTool.isSingleCurve(info);\n            if (undefined === data)\n                return undefined;\n            if (!this.acceptCurve(data.curve))\n                return undefined;\n            const props = await this.iModel.elements.loadProps(id);\n            if (undefined === props)\n                return undefined;\n            return new CurveData(props, data.params, data.curve);\n        }\n        catch (err) {\n            IModelApp.notifications.outputMessage(new NotifyMessageDetails(OutputMessagePriority.Error, BentleyError.getErrorMessage(err)));\n            return undefined;\n        }\n    }\n    async doAcceptElementForOperation(id) {\n        return (undefined !== await this.getCurveData(id));\n    }\n    async onAgendaModified() {\n        this.curveData = undefined;\n        if (this.agenda.isEmpty)\n            return;\n        const id = this.agenda.elements[this.agenda.length - 1];\n        this.curveData = await this.getCurveData(id);\n    }\n    setupAccuDraw() {\n        const hints = new AccuDrawHintBuilder();\n        hints.enableSmartRotation = true;\n        hints.sendHints(false);\n    }\n    getGeometryProps(ev, isAccept) {\n        if (undefined === this.curveData)\n            return;\n        const geom = this.modifyCurve(ev, isAccept);\n        if (undefined === geom)\n            return;\n        const builder = new ElementGeometry.Builder();\n        builder.setLocalToWorldFromPlacement(this.curveData.props.placement);\n        if (!builder.appendGeometryParamsChange(this.curveData.params))\n            return;\n        if (!builder.appendGeometryQuery(geom))\n            return;\n        return { format: \"flatbuffer\", data: builder.entries };\n    }\n    getElementProps(ev) {\n        if (undefined === this.curveData)\n            return;\n        if (!this.wantModifyOriginal) {\n            // Create result as new element with same model and category as original...\n            const classFullName = (ev.viewport?.view.is3d() ? \"Generic:PhysicalObject\" : \"BisCore:DrawingGraphic\");\n            return { classFullName, model: this.curveData.props.model, category: this.curveData.props.category, code: Code.createEmpty(), placement: this.curveData.props.placement };\n        }\n        return this.curveData.props;\n    }\n    async doUpdateElement(elemProps) {\n        try {\n            this._startedCmd = await this.startCommand();\n            if (undefined === elemProps.id) {\n                const repeatOperation = this.wantContinueWithPreviousResult;\n                if (repeatOperation)\n                    this.agenda.clear();\n                const newId = await basicManipulationIpc.insertGeometricElement(elemProps);\n                if (repeatOperation && this.agenda.add(newId))\n                    await this.onAgendaModified();\n            }\n            else {\n                await basicManipulationIpc.updateGeometricElement(elemProps);\n            }\n            return true;\n        }\n        catch (err) {\n            IModelApp.notifications.outputMessage(new NotifyMessageDetails(OutputMessagePriority.Error, BentleyError.getErrorMessage(err) || \"An unknown error occurred.\"));\n            return false;\n        }\n    }\n    get wantModifyOriginal() { return true; }\n    get wantContinueWithPreviousResult() { return false; }\n    async onProcessComplete() {\n        // Don't restart tool want to continue operation using previous result...\n        if (this.wantContinueWithPreviousResult && !this.agenda.isEmpty && undefined !== this.curveData)\n            return;\n        return super.onProcessComplete();\n    }\n}\n/** @alpha Tool for applying an offset to paths and loops. */\nclass OffsetCurveTool extends ModifyCurveTool {\n    get useDistanceProperty() {\n        if (!this._useDistanceProperty)\n            this._useDistanceProperty = new DialogProperty(PropertyDescriptionHelper.buildLockPropertyDescription(\"useOffsetDistance\"), false);\n        return this._useDistanceProperty;\n    }\n    get useDistance() { return this.useDistanceProperty.value; }\n    set useDistance(value) { this.useDistanceProperty.value = value; }\n    get distanceProperty() {\n        if (!this._distanceProperty)\n            this._distanceProperty = new DialogProperty(new LengthDescription(\"offsetDistance\", EditTools.translate(\"OffsetCurve.Label.Distance\")), 0.1, undefined, !this.useDistance);\n        return this._distanceProperty;\n    }\n    get distance() { return this.distanceProperty.value; }\n    set distance(value) { this.distanceProperty.value = value; }\n    get makeCopyProperty() {\n        if (!this._makeCopyProperty)\n            this._makeCopyProperty = new DialogProperty(PropertyDescriptionHelper.buildToggleDescription(\"offsetCopy\", EditTools.translate(\"OffsetCurve.Label.MakeCopy\")), false);\n        return this._makeCopyProperty;\n    }\n    get makeCopy() { return this.makeCopyProperty.value; }\n    set makeCopy(value) { this.makeCopyProperty.value = value; }\n    getToolSettingPropertyLocked(property) {\n        return (property === this.useDistanceProperty ? this.distanceProperty : undefined);\n    }\n    async applyToolSettingPropertyChange(updatedValue) {\n        return this.changeToolSettingPropertyValue(updatedValue);\n    }\n    supplyToolSettingsProperties() {\n        this.initializeToolSettingPropertyValues([this.makeCopyProperty, this.useDistanceProperty, this.distanceProperty]);\n        const toolSettings = new Array();\n        // ensure controls are enabled/disabled based on current lock property state\n        this.distanceProperty.isDisabled = !this.useDistance;\n        const useDistanceLock = this.useDistanceProperty.toDialogItem({ rowPriority: 1, columnIndex: 0 });\n        toolSettings.push(this.distanceProperty.toDialogItem({ rowPriority: 1, columnIndex: 1 }, useDistanceLock));\n        toolSettings.push(this.makeCopyProperty.toDialogItem({ rowPriority: 2, columnIndex: 0 }));\n        return toolSettings;\n    }\n    acceptCurve(curve) {\n        if (\"curvePrimitive\" === curve.geometryCategory)\n            return true;\n        return (curve.isOpenPath || curve.isClosedPath);\n    }\n    modifyCurve(ev, isAccept) {\n        if (undefined === ev.viewport)\n            return undefined;\n        const geom = this.curveData?.geom;\n        if (undefined === geom)\n            return undefined;\n        const matrix = AccuDrawHintBuilder.getCurrentRotation(ev.viewport, true, true);\n        const localToWorld = FrameBuilder.createRightHandedFrame(matrix?.getColumn(2), geom);\n        if (undefined === localToWorld)\n            return undefined;\n        const worldToLocal = localToWorld.inverse();\n        if (undefined === worldToLocal)\n            return undefined;\n        const geomXY = ((geom instanceof CurvePrimitive) ? Path.create(geom) : geom).cloneTransformed(worldToLocal);\n        if (undefined === geomXY)\n            return undefined;\n        const spacePoint = AccuDrawHintBuilder.projectPointToPlaneInView(ev.point, localToWorld.getOrigin(), localToWorld.matrix.getColumn(2), ev.viewport);\n        if (undefined === spacePoint)\n            return undefined;\n        worldToLocal.multiplyPoint3d(spacePoint, spacePoint);\n        spacePoint.z = 0.0;\n        const closeDetail = geomXY.closestPoint(spacePoint);\n        if (undefined === closeDetail?.curve)\n            return undefined;\n        const unitZ = Vector3d.unitZ();\n        const unitX = closeDetail.curve.fractionToPointAndUnitTangent(closeDetail.fraction).direction;\n        const unitY = unitZ.unitCrossProduct(unitX);\n        if (undefined === unitY)\n            return undefined;\n        let distance = closeDetail.point.distance(spacePoint);\n        const refDir = Vector3d.createStartEnd(closeDetail.point, spacePoint);\n        if (refDir.dotProduct(unitY) < 0.0)\n            distance = -distance;\n        let offset = 0.0;\n        if (this.useDistance) {\n            offset = this.distance;\n            if ((offset < 0.0 && distance > 0.0) || (offset > 0.0 && distance < 0.0))\n                offset = -offset;\n        }\n        else {\n            offset = distance;\n        }\n        if (Math.abs(offset) < Geometry.smallMetricDistance)\n            return undefined;\n        if (offset !== this.distance) {\n            this.distance = offset;\n            this.syncToolSettingPropertyValue(this.distanceProperty);\n            if (isAccept)\n                this.saveToolSettingPropertyValue(this.distanceProperty, this.distanceProperty.dialogItemValue);\n        }\n        const jointOptions = new JointOptions(offset);\n        jointOptions.preserveEllipticalArcs = true;\n        const offsetGeom = RegionOps.constructCurveXYOffset(geomXY, jointOptions);\n        if (undefined === offsetGeom)\n            return undefined;\n        if (!offsetGeom.tryTransformInPlace(localToWorld))\n            return undefined;\n        if (geom instanceof CurvePrimitive && offsetGeom instanceof Path && 1 === offsetGeom.children.length)\n            return offsetGeom.getChild(0); // Don't create path for offset of single open curve...\n        return offsetGeom;\n    }\n    get wantModifyOriginal() {\n        return !this.makeCopy;\n    }\n    get wantContinueWithPreviousResult() {\n        return !this.wantModifyOriginal;\n    }\n    setupAccuDraw() {\n        const hints = new AccuDrawHintBuilder();\n        if (this.agenda.isEmpty) {\n            hints.enableSmartRotation = true;\n        }\n        else if (undefined !== this.anchorPoint && undefined !== this.targetView) {\n            const geom = this.curveData?.geom;\n            const closeDetail = (geom instanceof CurvePrimitive) ? geom.closestPoint(this.anchorPoint, false) : geom?.closestPoint(this.anchorPoint);\n            if (undefined !== closeDetail?.curve) {\n                const unitX = closeDetail.curve.fractionToPointAndUnitTangent(closeDetail.fraction).direction;\n                if (undefined !== unitX) {\n                    const matrix = AccuDrawHintBuilder.getCurrentRotation(this.targetView, true, true);\n                    const localToWorld = FrameBuilder.createRightHandedFrame(matrix?.getColumn(2), geom);\n                    if (undefined !== localToWorld) {\n                        const unitZ = localToWorld.matrix.getColumn(2);\n                        const frame = Matrix3d.createRigidFromColumns(unitX, unitZ, AxisOrder.XZY);\n                        if (undefined !== frame) {\n                            hints.setOrigin(closeDetail.point);\n                            hints.setMatrix(frame);\n                        }\n                    }\n                }\n            }\n        }\n        hints.sendHints(false);\n    }\n    provideToolAssistance(_mainInstrText, _additionalInstr) {\n        let mainMsg;\n        if (!this.agenda.isEmpty)\n            mainMsg = EditTools.translate(\"OffsetCurve.Prompts.DefineOffset\");\n        super.provideToolAssistance(mainMsg);\n    }\n    async onRestartTool() {\n        const tool = new OffsetCurveTool();\n        if (!await tool.run())\n            return this.exitTool();\n    }\n}\nOffsetCurveTool.toolId = \"OffsetCurve\";\nOffsetCurveTool.iconSpec = \"icon-scale\"; // Need better icon...\nexport { OffsetCurveTool };\n/** @alpha Tool for opening loops and splitting paths. */\nclass BreakCurveTool extends ModifyCurveTool {\n    constructor() {\n        super(...arguments);\n        this.modifyOriginal = true;\n    }\n    get wantDynamics() { return false; }\n    get wantModifyOriginal() { return this.modifyOriginal; }\n    acceptCurve(curve) {\n        if (\"curvePrimitive\" === curve.geometryCategory)\n            return true;\n        return (curve.isOpenPath || curve.isClosedPath);\n    }\n    doBreakCurve(ev) {\n        this.resultA = this.resultB = undefined;\n        if (undefined === ev.viewport)\n            return;\n        const geom = this.curveData?.geom;\n        if (undefined === geom)\n            return;\n        const closeDetail = (geom instanceof CurvePrimitive) ? geom.closestPoint(ev.point, false) : geom.closestPoint(ev.point);\n        if (undefined === closeDetail?.curve)\n            return;\n        const selectedStart = (closeDetail.fraction <= Geometry.smallFraction);\n        const selectedEnd = (closeDetail.fraction >= (1.0 - Geometry.smallFraction));\n        if (geom instanceof CurvePrimitive) {\n            if (selectedStart || selectedEnd)\n                return; // split is no-op...\n            this.resultA = geom.clonePartialCurve(0.0, closeDetail.fraction);\n            this.resultB = geom.clonePartialCurve(closeDetail.fraction, 1.0);\n            return;\n        }\n        else if (geom instanceof Path) {\n            const firstCurve = geom.children[0];\n            const lastCurve = geom.children[geom.children.length - 1];\n            if ((closeDetail.curve === firstCurve && selectedStart) || (closeDetail.curve === lastCurve && selectedEnd))\n                return; // split is no-op...\n            let beforeCurve = true;\n            const resultA = Path.create();\n            const resultB = Path.create();\n            for (const curve of geom.children) {\n                if (curve === closeDetail.curve) {\n                    if (selectedStart) {\n                        resultB.children.push(curve.clone());\n                    }\n                    else if (selectedEnd) {\n                        resultA.children.push(curve.clone());\n                    }\n                    else {\n                        const curveA = curve.clonePartialCurve(0.0, closeDetail.fraction);\n                        if (undefined !== curveA)\n                            resultA.children.push(curveA);\n                        const curveB = curve.clonePartialCurve(closeDetail.fraction, 1.0);\n                        if (undefined !== curveB)\n                            resultB.children.push(curveB);\n                    }\n                    beforeCurve = false;\n                }\n                else {\n                    if (beforeCurve)\n                        resultA.children.push(curve.clone());\n                    else\n                        resultB.children.push(curve.clone());\n                }\n            }\n            this.resultA = resultA;\n            this.resultB = resultB;\n        }\n        else if (geom instanceof Loop) {\n            const closeIndex = geom.children.findIndex((child) => child === closeDetail.curve);\n            if (-1 === closeIndex)\n                return;\n            const endIndex = closeIndex + geom.children.length;\n            const resultA = Path.create(); // Result is always a single path...\n            if (selectedStart) {\n                resultA.children.push(closeDetail.curve.clone());\n            }\n            else if (!selectedEnd) {\n                const curveB = closeDetail.curve.clonePartialCurve(closeDetail.fraction, 1.0);\n                if (undefined !== curveB)\n                    resultA.children.push(curveB);\n            }\n            for (let index = closeIndex; index < endIndex; ++index) {\n                const curve = geom.cyclicCurvePrimitive(index);\n                if (undefined === curve || curve === closeDetail.curve)\n                    continue;\n                resultA.children.push(curve.clone());\n            }\n            if (selectedEnd) {\n                resultA.children.push(closeDetail.curve.clone());\n            }\n            else if (!selectedStart) {\n                const curveA = closeDetail.curve.clonePartialCurve(0.0, closeDetail.fraction);\n                if (undefined !== curveA)\n                    resultA.children.push(curveA);\n            }\n            this.resultA = resultA;\n        }\n    }\n    modifyCurve(_ev, _isAccept) {\n        return (this.wantModifyOriginal ? this.resultA : this.resultB);\n    }\n    async processAgenda(ev) {\n        this.doBreakCurve(ev);\n        if (undefined === this.resultA || !await this.applyAgendaOperation(ev))\n            return;\n        if (undefined !== this.resultB) {\n            this.modifyOriginal = false;\n            await this.applyAgendaOperation(ev);\n        }\n        return this.saveChanges();\n    }\n    provideToolAssistance(_mainInstrText, _additionalInstr) {\n        let mainMsg;\n        if (this.agenda.isEmpty)\n            mainMsg = EditTools.translate(\"BreakCurve.Prompts.IdentifyBreak\");\n        super.provideToolAssistance(mainMsg);\n    }\n    async onRestartTool() {\n        const tool = new BreakCurveTool();\n        if (!await tool.run())\n            return this.exitTool();\n    }\n}\nBreakCurveTool.toolId = \"BreakCurve\";\nBreakCurveTool.iconSpec = \"icon-scale\"; // Need better icon...\nexport { BreakCurveTool };\n/** @alpha Tool to extend or trim a path or open curve */\nclass ExtendCurveTool extends ModifyCurveTool {\n    get wantAgendaAppearanceOverride() { return true; }\n    acceptCurve(curve) {\n        if (\"curvePrimitive\" === curve.geometryCategory)\n            return curve.isExtensibleFractionSpace;\n        return curve.isOpenPath;\n    }\n    extendCurve(geom, pickPoint, spacePoint) {\n        const pickDetail = geom.closestPoint(pickPoint, false);\n        if (undefined === pickDetail?.curve)\n            return undefined;\n        const closeDetail = geom.closestPoint(spacePoint, true);\n        if (undefined === closeDetail?.curve)\n            return undefined;\n        if (closeDetail.curve instanceof Arc3d) {\n            if (pickDetail.fraction > 0.5 && closeDetail.fraction < 0.0) {\n                const smallArc = closeDetail.curve.clonePartialCurve(closeDetail.fraction, 0.0);\n                smallArc.sweep.cloneComplement(false, smallArc.sweep);\n                return smallArc;\n            }\n            else if (pickDetail.fraction <= 0.5 && closeDetail.fraction > 1.0) {\n                const smallArc = closeDetail.curve.clonePartialCurve(1.0, closeDetail.fraction);\n                smallArc.sweep.cloneComplement(false, smallArc.sweep);\n                return smallArc;\n            }\n            else if (Math.abs(pickDetail.fraction > 0.5 ? closeDetail.fraction : 1.0 - closeDetail.fraction) < Geometry.smallFraction) {\n                const fullArc = closeDetail.curve.clone();\n                fullArc.sweep = AngleSweep.create360();\n                return fullArc;\n            }\n        }\n        return geom.clonePartialCurve(pickDetail.fraction > 0.5 ? 0.0 : 1.0, closeDetail.fraction);\n    }\n    extendPathEnd(geom, closeDetail, isStart) {\n        if (undefined === closeDetail.curve)\n            return undefined;\n        const curve = closeDetail.curve.clonePartialCurve(isStart ? closeDetail.fraction : 0.0, isStart ? 1.0 : closeDetail.fraction);\n        if (undefined === curve)\n            return undefined;\n        if (curve instanceof Arc3d && closeDetail.curve instanceof Arc3d && (curve.sweep.isCCW !== closeDetail.curve.sweep.isCCW))\n            curve.sweep.cloneComplement(true, curve.sweep); // Preserve current sweep direction...\n        const result = geom.clone();\n        result.children[isStart ? 0 : geom.children.length - 1] = curve;\n        return result;\n    }\n    extendPath(geom, pickPoint, spacePoint) {\n        if (geom.children.length < 2)\n            return this.extendCurve(geom.children[0], pickPoint, spacePoint);\n        const pathAsPrimitive = CurveChainWithDistanceIndex.createCapture(geom);\n        const closeDetail = pathAsPrimitive.closestPoint(spacePoint, true);\n        if (undefined === closeDetail?.curve || undefined === closeDetail.childDetail?.curve)\n            return undefined;\n        if (undefined !== this.modifyingEnd) {\n            if (closeDetail.childDetail.curve === this.modifyingEnd) {\n                this.modifyingEnd = undefined; // Ok to unlock extending first/last curve in path...\n            }\n            else {\n                const pathEndDetail = this.modifyingEnd.closestPoint(spacePoint, true);\n                if (undefined === pathEndDetail?.curve)\n                    return undefined;\n                return this.extendPathEnd(geom, pathEndDetail, (pathEndDetail.curve === geom.children[0]));\n            }\n        }\n        // NOTE: Special case extend instead of using CurveChainWithDistanceIndex.clonePartialCurve...\n        if (closeDetail.fraction < 0.0) {\n            this.modifyingEnd = closeDetail.childDetail.curve;\n            return this.extendPathEnd(geom, closeDetail.childDetail, true);\n        }\n        else if (closeDetail.fraction > 1.0) {\n            this.modifyingEnd = closeDetail.childDetail.curve;\n            return this.extendPathEnd(geom, closeDetail.childDetail, false);\n        }\n        const pickDetail = pathAsPrimitive.closestPoint(pickPoint, false);\n        if (undefined === pickDetail?.curve)\n            return undefined;\n        const result = pathAsPrimitive.clonePartialCurve(pickDetail.fraction > 0.5 ? 0.0 : 1.0, closeDetail.fraction);\n        if (undefined === result)\n            return undefined;\n        return Path.create(...result.path.children);\n    }\n    modifyCurve(ev, _isAccept) {\n        if (undefined === ev.viewport || undefined === this.anchorPoint)\n            return undefined;\n        const geom = this.curveData?.geom;\n        if (undefined === geom)\n            return undefined;\n        const matrix = AccuDrawHintBuilder.getCurrentRotation(ev.viewport, true, true);\n        const localToWorld = FrameBuilder.createRightHandedFrame(matrix?.getColumn(2), geom);\n        if (undefined === localToWorld)\n            return undefined;\n        const worldToLocal = localToWorld.inverse();\n        if (undefined === worldToLocal)\n            return undefined;\n        const spacePoint = AccuDrawHintBuilder.projectPointToPlaneInView(ev.point, localToWorld.getOrigin(), localToWorld.matrix.getColumn(2), ev.viewport);\n        if (undefined === spacePoint)\n            return undefined;\n        if (geom instanceof CurvePrimitive)\n            return this.extendCurve(geom, this.anchorPoint, spacePoint);\n        else if (geom instanceof Path)\n            return this.extendPath(geom, this.anchorPoint, spacePoint);\n        return undefined;\n    }\n    async onAgendaModified() {\n        IModelApp.accuSnap.neverFlash(this.agenda.elements); // Don't flash snapped segment for better preview when trimming curve/path...\n        return super.onAgendaModified();\n    }\n    setupAccuDraw() {\n        const hints = new AccuDrawHintBuilder();\n        if (this.agenda.isEmpty) {\n            hints.enableSmartRotation = true;\n        }\n        else {\n            const geom = this.curveData?.geom;\n            if (undefined === geom || undefined === this.anchorPoint)\n                return;\n            let pickDetail;\n            if (geom instanceof CurvePrimitive)\n                pickDetail = geom.closestPoint(this.anchorPoint, false);\n            else if (geom instanceof Path)\n                pickDetail = CurveChainWithDistanceIndex.createCapture(geom).closestPoint(this.anchorPoint, false);\n            if (undefined === pickDetail?.curve)\n                return;\n            const curve = (undefined !== pickDetail.childDetail?.curve ? pickDetail.childDetail?.curve : pickDetail.curve);\n            if (curve instanceof Arc3d) {\n                const matrix = curve.matrixClone();\n                matrix.normalizeColumnsInPlace();\n                hints.setOrigin(curve.center);\n                hints.setMatrix(matrix);\n                hints.setModePolar();\n            }\n            else if (curve instanceof LineSegment3d) {\n                hints.setOrigin(pickDetail.fraction > 0.5 ? curve.point0Ref : curve.point1Ref);\n                hints.setXAxis(Vector3d.createStartEnd(pickDetail.fraction > 0.5 ? curve.point0Ref : curve.point1Ref, pickDetail.fraction > 0.5 ? curve.point1Ref : curve.point0Ref));\n                hints.setModeRectangular();\n            }\n            else if (curve instanceof LineString3d) {\n                if (curve.numPoints() > 1) {\n                    hints.setOrigin(curve.packedPoints.getPoint3dAtUncheckedPointIndex(pickDetail.fraction > 0.5 ? curve.numPoints() - 2 : 1));\n                    hints.setXAxis(Vector3d.createStartEnd(curve.packedPoints.getPoint3dAtUncheckedPointIndex(pickDetail.fraction > 0.5 ? curve.numPoints() - 2 : 1), curve.packedPoints.getPoint3dAtUncheckedPointIndex(pickDetail.fraction > 0.5 ? curve.numPoints() - 1 : 0)));\n                }\n                hints.setModeRectangular();\n            }\n            else {\n                const ray = curve.fractionToPointAndUnitTangent(pickDetail.fraction > 0.5 ? 0.0 : 1.0);\n                hints.setOrigin(ray.origin);\n                hints.setXAxis(ray.direction);\n                hints.setModeRectangular();\n            }\n        }\n        hints.sendHints(false);\n    }\n    provideToolAssistance(_mainInstrText, _additionalInstr) {\n        let mainMsg;\n        if (this.agenda.isEmpty)\n            mainMsg = EditTools.translate(\"ExtendCurve.Prompts.IdentifyEnd\");\n        super.provideToolAssistance(mainMsg);\n    }\n    async onRestartTool() {\n        const tool = new ExtendCurveTool();\n        if (!await tool.run())\n            return this.exitTool();\n    }\n}\nExtendCurveTool.toolId = \"ExtendCurve\";\nExtendCurveTool.iconSpec = \"icon-scale\"; // Need better icon...\nexport { ExtendCurveTool };\n/** @alpha */\nexport var RegionBooleanMode;\n(function (RegionBooleanMode) {\n    /** Create region from union of all input regions */\n    RegionBooleanMode[RegionBooleanMode[\"Unite\"] = 0] = \"Unite\";\n    /** Create region from subtraction from the first input region */\n    RegionBooleanMode[RegionBooleanMode[\"Subtract\"] = 1] = \"Subtract\";\n    /** Create region from intersection of all input regions */\n    RegionBooleanMode[RegionBooleanMode[\"Intersect\"] = 2] = \"Intersect\";\n})(RegionBooleanMode || (RegionBooleanMode = {}));\n/** @alpha Tool to unite, subtract, or intersect planar regions. */\nclass RegionBooleanTool extends ModifyCurveTool {\n    get makeCopyProperty() {\n        if (!this._makeCopyProperty)\n            this._makeCopyProperty = new DialogProperty(PropertyDescriptionHelper.buildToggleDescription(\"regionBooleanKeep\", EditTools.translate(\"RegionBoolean.Label.KeepOriginal\")), false);\n        return this._makeCopyProperty;\n    }\n    get makeCopy() { return this.makeCopyProperty.value; }\n    set makeCopy(value) { this.makeCopyProperty.value = value; }\n    static modeMessage(str) { return EditTools.translate(`RegionBoolean.Mode.${str}`); }\n    get modeProperty() {\n        if (!this._modeProperty)\n            this._modeProperty = new DialogProperty(PropertyDescriptionHelper.buildEnumPicklistEditorDescription(\"regionBooleanMode\", EditTools.translate(\"RegionBoolean.Label.Mode\"), RegionBooleanTool.getModeChoices()), RegionBooleanMode.Unite);\n        return this._modeProperty;\n    }\n    get mode() { return this.modeProperty.value; }\n    set mode(mode) { this.modeProperty.value = mode; }\n    get clearSelectionSet() { return false; } // Don't clear for subtract so that mode can be changed...\n    get allowSelectionSet() { return RegionBooleanMode.Subtract !== this.mode; }\n    get allowDragSelect() { return RegionBooleanMode.Subtract !== this.mode; }\n    get controlKeyContinuesSelection() { return true; }\n    get requiredElementCount() { return 2; }\n    get wantAccuSnap() { return false; }\n    get wantDynamics() { return false; }\n    get wantModifyOriginal() { return !this.makeCopy; }\n    async onAgendaModified() { } // No intermediate result preview, defer to processAgenda...\n    acceptCurve(curve) {\n        if (\"curvePrimitive\" === curve.geometryCategory)\n            return false;\n        return curve.isAnyRegionType;\n    }\n    regionBinaryOp() {\n        switch (this.mode) {\n            case RegionBooleanMode.Subtract:\n                return RegionBinaryOpType.AMinusB;\n            case RegionBooleanMode.Intersect:\n                return RegionBinaryOpType.Intersection;\n            default:\n                return RegionBinaryOpType.Union;\n        }\n    }\n    regionFromSignedLoops(loops) {\n        switch (loops.negativeAreaLoops.length) {\n            case 0:\n                return undefined;\n            case 1:\n                return loops.negativeAreaLoops[0];\n            default:\n                return RegionOps.sortOuterAndHoleLoopsXY(loops.negativeAreaLoops);\n        }\n    }\n    regionBooleanXY(tools, op) {\n        if (tools.length < 2)\n            return undefined;\n        const loopsA = (RegionBinaryOpType.Union !== op ? tools[0] : tools);\n        const loopsB = (RegionBinaryOpType.Union !== op ? tools.slice(1) : undefined);\n        // TODO: Need to be able to specify group operation for loopsB to correctly support intersect w/o doing 2 at time...\n        const areas = RegionOps.regionBooleanXY(loopsA, loopsB, op);\n        if (undefined === areas)\n            return undefined;\n        // TODO: Holes are expected to be returned as negative area loops but currently are not...\n        const loops = RegionOps.constructAllXYRegionLoops(areas);\n        if (1 === loops.length)\n            return this.regionFromSignedLoops(loops[0]);\n        if (loops.length > 1) {\n            const unionRegion = UnionRegion.create();\n            for (const loop of loops) {\n                const child = this.regionFromSignedLoops(loop);\n                if (undefined === child)\n                    continue;\n                unionRegion.tryAddChild(child);\n            }\n            if (unionRegion.children.length > 1)\n                return unionRegion;\n        }\n        return undefined;\n    }\n    async doRegionBoolean(_ev) {\n        this.curveData = undefined;\n        if (this.agenda.length < this.requiredElementCount)\n            return;\n        const targetData = await this.getCurveData(this.agenda.elements[0]);\n        if (undefined === targetData?.geom)\n            return;\n        const targetLocalToWorld = FrameBuilder.createRightHandedFrame(undefined, targetData.geom);\n        if (undefined === targetLocalToWorld)\n            return;\n        const targetWorldToLocal = targetLocalToWorld.inverse();\n        if (undefined === targetWorldToLocal)\n            return;\n        const targetPlane = Plane3dByOriginAndUnitNormal.create(targetLocalToWorld.getOrigin(), targetLocalToWorld.matrix.getColumn(2));\n        if (undefined === targetPlane)\n            return;\n        if (!targetData.geom.tryTransformInPlace(targetWorldToLocal))\n            return;\n        const tools = [targetData.geom];\n        for (const id of this.agenda.elements) {\n            if (id === targetData.props.id)\n                continue;\n            const curveData = await this.getCurveData(id);\n            if (undefined === curveData?.geom)\n                return;\n            if (!ModifyCurveTool.isInPlane(curveData.geom, targetPlane)) {\n                IModelApp.notifications.outputMessage(new NotifyMessageDetails(OutputMessagePriority.Info, EditTools.translate(\"RegionBoolean.Error.NonCoplanar\")));\n                return;\n            }\n            if (!curveData.geom.tryTransformInPlace(targetWorldToLocal))\n                return;\n            tools.push(curveData.geom);\n        }\n        const result = this.regionBooleanXY(tools, this.regionBinaryOp());\n        if (undefined === result || !result.tryTransformInPlace(targetLocalToWorld))\n            return;\n        this.curveData = targetData;\n        this.curveData.geom = result;\n    }\n    modifyCurve(_ev, _isAccept) {\n        return this.curveData?.geom;\n    }\n    async applyAgendaOperation(ev) {\n        if (!await super.applyAgendaOperation(ev))\n            return false;\n        if (this.wantModifyOriginal && this.agenda.length > 1)\n            await basicManipulationIpc.deleteElements(CompressedId64Set.sortAndCompress(this.agenda.elements.slice(1)));\n        return true;\n    }\n    async processAgenda(ev) {\n        await this.doRegionBoolean(ev);\n        return super.processAgenda(ev);\n    }\n    async onRestartTool() {\n        const tool = new RegionBooleanTool();\n        if (!await tool.run())\n            return this.exitTool();\n    }\n    async applyToolSettingPropertyChange(updatedValue) {\n        if (!this.changeToolSettingPropertyValue(updatedValue))\n            return false;\n        if (this.modeProperty.name === updatedValue.propertyName)\n            await this.onReinitialize();\n        return true;\n    }\n    supplyToolSettingsProperties() {\n        this.initializeToolSettingPropertyValues([this.makeCopyProperty, this.modeProperty]);\n        const toolSettings = new Array();\n        toolSettings.push(this.modeProperty.toDialogItem({ rowPriority: 1, columnIndex: 0 }));\n        toolSettings.push(this.makeCopyProperty.toDialogItem({ rowPriority: 2, columnIndex: 0 }));\n        return toolSettings;\n    }\n}\nRegionBooleanTool.toolId = \"RegionBoolean\";\nRegionBooleanTool.iconSpec = \"icon-scale\"; // Need better icon...\nRegionBooleanTool.getModeChoices = () => {\n    return [\n        { label: RegionBooleanTool.modeMessage(\"Unite\"), value: RegionBooleanMode.Unite },\n        { label: RegionBooleanTool.modeMessage(\"Subtract\"), value: RegionBooleanMode.Subtract },\n        { label: RegionBooleanTool.modeMessage(\"Intersect\"), value: RegionBooleanMode.Intersect },\n    ];\n};\nexport { RegionBooleanTool };\n//# sourceMappingURL=ModifyCurveTools.js.map",
      "start": 1693508122913,
      "end": 1693508123012,
      "sourcemaps": null
    }
  ]
}
