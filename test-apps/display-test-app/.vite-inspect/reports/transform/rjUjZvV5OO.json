{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/curve/CurveChainWithDistanceIndex.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Curve\n */\nimport { CurvePrimitive } from \"../curve/CurvePrimitive\";\nimport { StrokeCountMap } from \"../curve/Query/StrokeCountMap\";\nimport { Geometry } from \"../Geometry\";\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\nimport { Range3d } from \"../geometry3d/Range\";\nimport { CurveChain } from \"./CurveCollection\";\nimport { CurveExtendMode, CurveExtendOptions } from \"./CurveExtendMode\";\nimport { CurveLocationDetail } from \"./CurveLocationDetail\";\nimport { PlaneAltitudeRangeContext } from \"./internalContexts/PlaneAltitudeRangeContext\";\nimport { OffsetOptions } from \"./OffsetOptions\";\nimport { Path } from \"./Path\";\n/**\n * Annotation of an interval of a curve.\n * * The interval is marked with two pairs of numbers:\n * * * fraction0, fraction1 = fraction parameters along the child curve\n * * * distance0,distance1 = distances within containing CurveChainWithDistanceIndex\n * @public\n */\nexport class PathFragment {\n    /** Create a fragment with complete fraction, distance and child data. */\n    constructor(childFraction0, childFraction1, distance0, distance1, childCurve, range) {\n        this.childFraction0 = childFraction0;\n        this.childFraction1 = childFraction1;\n        this.chainDistance0 = distance0;\n        this.chainDistance1 = distance1;\n        this.childCurve = childCurve;\n        this.range = range;\n        this.a = 0;\n    }\n    /**\n     * Return true if the distance is within the distance limits of this fragment.\n     * @param distance\n     */\n    containsChainDistance(distance) {\n        return distance >= this.chainDistance0 && distance <= this.chainDistance1;\n    }\n    /** Return a quick distance to the curve.  This may be SMALLER than true distance but may not be larger */\n    quickMinDistanceToChildCurve(spacePoint) {\n        if (this.range) {\n            return this.range.distanceToPoint(spacePoint);\n        }\n        // ugh.  have to do real computation ..\n        const detail = this.childCurve.closestPoint(spacePoint, false);\n        if (detail)\n            return detail.a;\n        return 0;\n    }\n    /**\n     * Return an array with (references to) all the path fragments, sorted smallest to largest on the \"a\" value\n     * equal to the quick min distance to the fragment\n     */\n    static collectSortedQuickMinDistances(fragments, spacePoint) {\n        const sortedFragments = [];\n        for (const f of fragments) {\n            f.a = f.quickMinDistanceToChildCurve(spacePoint);\n            sortedFragments.push(f);\n        }\n        sortedFragments.sort((a, b) => a.a - b.a);\n        return sortedFragments;\n    }\n    /**\n     * Return true if this fragment addresses `curve` and brackets `fraction`\n     * @param distance\n     */\n    containsChildCurveAndChildFraction(curve, fraction) {\n        return this.childCurve === curve && fraction >= this.childFraction0 && fraction <= this.childFraction1;\n    }\n    /**\n     * Convert distance to local fraction, and apply that to interpolate between the stored curve fractions.\n     * Note that proportional calculation does NOT account for nonuniform parameterization in the child curve.\n     */\n    chainDistanceToInterpolatedChildFraction(distance) {\n        return Geometry.inverseInterpolate(this.childFraction0, this.chainDistance0, this.childFraction1, this.chainDistance1, distance, this.childFraction0); // the interval \"must\" have nonzero length, division should be safe . ..\n    }\n    /** Convert chainDistance to true chidFraction, using detailed moveSignedDistanceFromFraction */\n    chainDistanceToAccurateChildFraction(chainDistance, allowExtrapolation) {\n        // The fragments are really expected to do good mappings in their distance range ...\n        const childDetail = this.childCurve.moveSignedDistanceFromFraction(this.childFraction0, chainDistance - this.chainDistance0, allowExtrapolation ?? false);\n        return childDetail.fraction;\n    }\n    /**\n     * Return the scale factor to map childCurve fraction derivatives to chain fraction derivatives\n     * @param globalDistance total length of the global curve.\n     */\n    fractionScaleFactor(globalDistance) {\n        return globalDistance * (this.childFraction1 - this.childFraction0) / (this.chainDistance1 - this.chainDistance0);\n    }\n    /**\n     * Reverse the fraction and distance data.\n     * * each child fraction `f` is replaced by `1-f`\n     * * each `chainDistance` is replaced by `totalDistance-chainDistance`\n     */\n    reverseFractionsAndDistances(totalDistance) {\n        const f0 = this.childFraction0;\n        const f1 = this.childFraction1;\n        const d0 = this.chainDistance0;\n        const d1 = this.chainDistance1;\n        this.childFraction0 = 1.0 - f1;\n        this.childFraction1 = 1.0 - f0;\n        this.chainDistance0 = totalDistance - d1;\n        this.chainDistance1 = totalDistance - d0;\n    }\n    /** @deprecated in 3.x. Use childFractionToChainDistance */\n    childFractionTChainDistance(fraction) {\n        return this.childFractionToChainDistance(fraction);\n    }\n    /**\n     * Convert a fractional position on the childCurve to distance in the chain space.\n     * * Return value is SIGNED -- will be negative when fraction < this.childFraction0.\n     * @param fraction fraction along the curve within this fragment\n     */\n    childFractionToChainDistance(fraction) {\n        let d = this.childCurve.curveLengthBetweenFractions(this.childFraction0, fraction);\n        if (fraction < this.childFraction0)\n            d = -d;\n        return this.chainDistance0 + d;\n    }\n}\n/** Non-instantiable class to build a distance index for a path. */\nclass DistanceIndexConstructionContext {\n    constructor() {\n        this._accumulatedDistance = 0;\n        this._fragments = [];\n    }\n    // ignore curve announcements -- they are repeated in stroke announcements\n    startParentCurvePrimitive(_cp) { }\n    startCurvePrimitive(_cp) { }\n    endParentCurvePrimitive(_cp) { }\n    endCurvePrimitive(_cp) { }\n    announcePointTangent(_xyz, _fraction, _tangent) { }\n    /** Announce numPoints interpolated between point0 and point1, with associated fractions */\n    announceSegmentInterval(cp, point0, point1, numStrokes, fraction0, fraction1) {\n        const fragmentPoint0 = point0.clone();\n        const fragmentPoint1 = point1.clone();\n        let d0 = this._accumulatedDistance;\n        if (numStrokes <= 1) {\n            this._accumulatedDistance += point0.distance(point1);\n            this._fragments.push(new PathFragment(fraction0, fraction1, d0, this._accumulatedDistance, cp, Range3d.create(fragmentPoint0, fragmentPoint1)));\n        }\n        else {\n            let f1;\n            for (let i = 1, f0 = fraction0; i <= numStrokes; i++, f0 = f1) {\n                f1 = Geometry.interpolate(fraction0, i / numStrokes, fraction1);\n                point0.interpolate(f1, point1, fragmentPoint1);\n                d0 = this._accumulatedDistance;\n                this._accumulatedDistance += (Math.abs(f1 - f0) * point0.distance(point1));\n                this._fragments.push(new PathFragment(f0, f1, d0, this._accumulatedDistance, cp, Range3d.create(fragmentPoint0, fragmentPoint1)));\n                fragmentPoint0.setFrom(fragmentPoint1);\n            }\n        }\n    }\n    announceIntervalForUniformStepStrokes(cp, numStrokes, fraction0, fraction1) {\n        let f1, d, d0;\n        for (let i = 1, f0 = fraction0; i <= numStrokes; i++, f0 = f1) {\n            f1 = Geometry.interpolate(fraction0, i / numStrokes, fraction1);\n            d = cp.curveLengthBetweenFractions(f0, f1);\n            d0 = this._accumulatedDistance;\n            this._accumulatedDistance += d;\n            const range = cp.rangeBetweenFractions(f0, f1);\n            this._fragments.push(new PathFragment(f0, f1, d0, this._accumulatedDistance, cp, range));\n        }\n    }\n    needPrimaryGeometryForStrokes() { return true; }\n    static createPathFragmentIndex(path, options) {\n        const handler = new DistanceIndexConstructionContext();\n        for (const curve of path.children) {\n            curve.emitStrokableParts(handler, options);\n        }\n        const fragments = handler._fragments;\n        return fragments;\n    }\n}\n/**\n * `CurveChainWithDistanceIndex` is a CurvePrimitive whose fractional parameterization is proportional to true\n * distance along a CurveChain.\n * * For example if the total length of the chain is `L`, then the distance along the chain from parameters `t0`\n * to `t1` is easily computed as `L*(t1-t0)`.\n * * The curve chain can be any type derived from CurveChain.\n * * * i.e. either a `Path` or a `Loop`\n * @public\n */\nclass CurveChainWithDistanceIndex extends CurvePrimitive {\n    /** Test if other is a `CurveChainWithDistanceIndex` */\n    isSameGeometryClass(other) {\n        return other instanceof CurveChainWithDistanceIndex;\n    }\n    // final assembly of CurveChainWithDistanceIndex -- caller must create valid fragment index.\n    constructor(path, fragments) {\n        super();\n        /** String name for schema properties */\n        this.curvePrimitiveType = \"curveChainWithDistanceIndex\";\n        this._path = path;\n        this._fragments = fragments;\n        this._totalLength = fragments.length > 0 ? fragments[fragments.length - 1].chainDistance1 : 0;\n    }\n    /**\n     * Create a clone, transformed and with its own distance index.\n     * @param transform transform to apply in the clone.\n     */\n    cloneTransformed(transform) {\n        const c = this._path.clone();\n        if (c instanceof CurveChain && c.tryTransformInPlace(transform))\n            return CurveChainWithDistanceIndex.createCapture(c);\n        return undefined;\n    }\n    /**\n     * Reference to the contained path.\n     * * Do not modify the path.  The distance index will be wrong.\n     */\n    get path() {\n        return this._path;\n    }\n    /**\n     * Reference to the fragments array.\n     * * Do not modify.\n     */\n    get fragments() {\n        return this._fragments;\n    }\n    /** Return a deep clone */\n    clone() {\n        const c = this._path.clone();\n        return CurveChainWithDistanceIndex.createCapture(c);\n    }\n    /** Return a deep clone */\n    clonePartialCurve(fractionA, fractionB) {\n        if (fractionA === fractionB)\n            return undefined;\n        let fracA = fractionA;\n        let fracB = fractionB;\n        const reversed = fractionA > fractionB;\n        if (reversed) {\n            fracA = fractionB;\n            fracB = fractionA;\n        }\n        const chainDistanceA = fracA * this._totalLength;\n        const chainDistanceB = fracB * this._totalLength;\n        const fragmentA = this.chainDistanceToFragment(chainDistanceA, true);\n        if (undefined === fragmentA)\n            return undefined;\n        const fragmentB = this.chainDistanceToFragment(chainDistanceB, true);\n        if (undefined === fragmentB)\n            return undefined;\n        const childCurveIndexA = this._path.childIndex(fragmentA.childCurve, true);\n        if (undefined === childCurveIndexA)\n            return undefined;\n        const childCurveIndexB = this._path.childIndex(fragmentB.childCurve, true);\n        if (undefined === childCurveIndexB)\n            return undefined;\n        const childFractionA = fragmentA.chainDistanceToAccurateChildFraction(chainDistanceA, true);\n        const childFractionB = fragmentB.chainDistanceToAccurateChildFraction(chainDistanceB, true);\n        // add a (possibly reversed) partial clone to newPath\n        const newPath = Path.create();\n        const addPartialChild = (childCurve, childFraction0, childFraction1, reversedClone) => {\n            if (childFraction0 === childFraction1)\n                return false;\n            let newCurve;\n            if (childFraction0 === 0.0 && childFraction1 === 1.0) {\n                newCurve = childCurve.clone();\n                if (reversedClone)\n                    newCurve.reverseInPlace();\n            }\n            else {\n                newCurve = reversedClone ?\n                    childCurve.clonePartialCurve(childFraction1, childFraction0)\n                    : childCurve.clonePartialCurve(childFraction0, childFraction1);\n            }\n            if (newCurve) {\n                newPath.children.push(newCurve);\n                return true;\n            }\n            return false;\n        };\n        if (fragmentA.childCurve === fragmentB.childCurve) {\n            // the two distances are within the same curve.\n            if (addPartialChild(fragmentA.childCurve, childFractionA, childFractionB, reversed))\n                return CurveChainWithDistanceIndex.createCapture(newPath); // singleton -- children[] does not need to be reversed.\n            return undefined;\n        }\n        addPartialChild(this._path.children[childCurveIndexA], childFractionA, 1.0, reversed);\n        // at least two distinct children are impacted ....\n        for (let childIndex = childCurveIndexA + 1; childIndex < childCurveIndexB; childIndex++) {\n            addPartialChild(this._path.children[childIndex], 0.0, 1.0, reversed);\n        }\n        addPartialChild(this._path.children[childCurveIndexB], 0.0, childFractionB, reversed);\n        // This reverses array entries but not orientation within each curve ...\n        if (reversed)\n            newPath.children.reverse();\n        return CurveChainWithDistanceIndex.createCapture(newPath);\n    }\n    /**\n     * Ask if the curve is within tolerance of a plane.\n     * @returns Returns true if the curve is completely within tolerance of the plane.\n     */\n    isInPlane(plane) {\n        for (const c of this._path.children) {\n            if (!c.isInPlane(plane))\n                return false;\n        }\n        return true;\n    }\n    /** Return the start point of the primitive.  The default implementation returns fractionToPoint (0.0) */\n    startPoint(result) {\n        const c = this._path.cyclicCurvePrimitive(0);\n        if (c)\n            return c.startPoint(result);\n        return Point3d.createZero(result);\n    }\n    /** Return the end point of the primitive. The default implementation returns fractionToPoint(1.0) */\n    endPoint(result) {\n        const c = this._path.cyclicCurvePrimitive(-1);\n        if (c)\n            return c.endPoint(result);\n        return Point3d.createZero(result);\n    }\n    /** Add strokes to caller-supplied linestring */\n    emitStrokes(dest, options) {\n        for (const c of this._path.children) {\n            c.emitStrokes(dest, options);\n        }\n    }\n    /**\n     * Ask the curve to announce points and simple subcurve fragments for stroking.\n     * See IStrokeHandler for description of the sequence of the method calls.\n     */\n    emitStrokableParts(dest, options) {\n        for (const c of this._path.children) {\n            c.emitStrokableParts(dest, options);\n        }\n    }\n    /**\n     * Return the stroke count required for given options.\n     * @param options StrokeOptions that determine count\n     */\n    computeStrokeCountForOptions(options) {\n        let numStroke = 0;\n        for (const c of this._path.children) {\n            numStroke += c.computeStrokeCountForOptions(options);\n        }\n        return numStroke;\n    }\n    /**\n     * Return an array containing only the curve primitives.\n     * @param collectorArray array to receive primitives (pushed -- the array is not cleared)\n     * @param smallestPossiblePrimitives if true, recurse on the (otherwise hidden) children. If false, only push `this`.\n     * @param explodeLinestrings (if smallestPossiblePrimitives is true) whether to push a [[LineSegment3d]] for each\n     * segment of a [[LineString3d]] child. If false, push only the [[LineString3d]].\n     */\n    collectCurvePrimitivesGo(collectorArray, smallestPossiblePrimitives = false, explodeLineStrings = false) {\n        if (smallestPossiblePrimitives) {\n            for (const c of this._path.children) {\n                c.collectCurvePrimitivesGo(collectorArray, smallestPossiblePrimitives, explodeLineStrings);\n            }\n        }\n        else {\n            collectorArray.push(this);\n        }\n    }\n    /**\n     * Construct StrokeCountMap for each child, accumulating data to stroke count map for this primitive.\n     * @param options StrokeOptions that determine count\n     * @param parentStrokeMap evolving parent map.\n     */\n    computeAndAttachRecursiveStrokeCounts(options, parentStrokeMap) {\n        const myMap = StrokeCountMap.createWithCurvePrimitiveAndOptionalParent(this, parentStrokeMap);\n        for (const c of this._path.children) {\n            c.computeAndAttachRecursiveStrokeCounts(options, myMap);\n        }\n        CurvePrimitive.installStrokeCountMap(this, myMap, parentStrokeMap);\n    }\n    /**\n     * Second step of double dispatch:  call `this._path.dispatchToGeometryHandler (handler)`\n     * * Note that this exposes the children individually to the handler.\n     */\n    dispatchToGeometryHandler(handler) {\n        return this._path.dispatchToGeometryHandler(handler);\n    }\n    /** Extend (increase) `rangeToExtend` as needed to include these curves (optionally transformed) */\n    extendRange(rangeToExtend, transform) {\n        this._path.extendRange(rangeToExtend, transform);\n    }\n    /**\n     * Curve length is always positive.\n     * @returns Returns a (high accuracy) length of the curve between fractional positions\n     * @returns Returns the length of the curve.\n     */\n    curveLengthBetweenFractions(fraction0, fraction1) {\n        return Math.abs(fraction1 - fraction0) * this._totalLength;\n    }\n    /**\n     * Capture (not clone) a path into a new `CurveChainWithDistanceIndex`\n     * @param path primitive array to be CAPTURED (not cloned)\n     */\n    static createCapture(path, options) {\n        const fragments = DistanceIndexConstructionContext.createPathFragmentIndex(path, options);\n        const result = new CurveChainWithDistanceIndex(path, fragments);\n        return result;\n    }\n    /**\n     * Resolve a fraction of the CurveChain to a PathFragment\n     * @param distance\n     * @param allowExtrapolation\n     */\n    chainDistanceToFragment(distance, allowExtrapolation = false) {\n        const i = this.chainDistanceToFragmentIndex(distance, allowExtrapolation);\n        if (undefined !== i)\n            return this._fragments[i];\n        return undefined;\n    }\n    /**\n     * Resolve a fraction of the CurveChain to a PathFragment index\n     * @param distance\n     * @param allowExtrapolation\n     */\n    chainDistanceToFragmentIndex(distance, allowExtrapolation = false) {\n        const numFragments = this._fragments.length;\n        const fragments = this._fragments;\n        if (numFragments > 0) {\n            if (distance < 0.0)\n                return allowExtrapolation ? 0 : undefined;\n            if (distance > this._totalLength)\n                return allowExtrapolation ? (numFragments - 1) : undefined;\n            // humbug, linear search\n            for (let i = 0; i < numFragments; i++) {\n                if (fragments[i].containsChainDistance(distance))\n                    return i;\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Convert distance along the chain to fraction along the chain.\n     * @param distance distance along the chain\n     */\n    chainDistanceToChainFraction(distance) {\n        return distance / this._totalLength;\n    }\n    /**\n     * Resolve a fraction within a specific curve to a fragment.\n     * @param curve\n     * @param fraction\n     */\n    curveAndChildFractionToFragment(curve, fraction) {\n        const numFragments = this._fragments.length;\n        const fragments = this._fragments;\n        if (numFragments > 0) {\n            // humbug, linear search\n            for (const fragment of fragments) {\n                if (fragment.containsChildCurveAndChildFraction(curve, fraction))\n                    return fragment;\n            }\n            if (fraction <= 0)\n                return fragments[0];\n            if (fraction > 1.0)\n                return fragments[numFragments - 1];\n        }\n        return undefined;\n    }\n    /** Returns the total length of curves. */\n    curveLength() {\n        return this._totalLength;\n    }\n    /**\n     * Returns the total length of the path.\n     * * This is exact (and simple property lookup) because the true lengths were summed at construction time.\n     */\n    quickLength() {\n        return this._totalLength;\n    }\n    /**\n     * Return the point (x,y,z) on the curve at fractional position along the chain.\n     * @param fraction fractional position along the geometry.\n     * @returns Returns a point on the curve.\n     */\n    fractionToPoint(fraction, result) {\n        const chainDistance = fraction * this._totalLength;\n        const fragment = this.chainDistanceToFragment(chainDistance, true);\n        if (fragment) {\n            const childFraction = fragment.chainDistanceToAccurateChildFraction(chainDistance, true);\n            return fragment.childCurve.fractionToPoint(childFraction, result);\n        }\n        // no fragment found.  Use _fragments[0]\n        //    fragment = this.chainDistanceToFragment(chainDistance, true);\n        return this._fragments[0].childCurve.fractionToPoint(0.0, result);\n    }\n    /**\n     * Return the point (x,y,z) and derivative on the curve at fractional position.\n     * * Note that this derivative is \"derivative of xyz with respect to fraction.\"\n     * * this derivative shows the speed of the \"fractional point\" moving along the curve.\n     * * this is not generally a unit vector.  use fractionToPointAndUnitTangent for a unit vector.\n     * @param fraction fractional position along the geometry.\n     * @returns Returns a ray whose origin is the curve point and direction is the derivative with respect to the fraction.\n     */\n    fractionToPointAndDerivative(fraction, result) {\n        const distanceAlongPath = fraction * this._totalLength;\n        const fragment = this.chainDistanceToFragment(distanceAlongPath, true);\n        const curveFraction = fragment.chainDistanceToAccurateChildFraction(distanceAlongPath, true);\n        result = fragment.childCurve.fractionToPointAndDerivative(curveFraction, result);\n        // Fractional arc length parameterization for the curve C is f=f(t)=s(t)/L, where\n        // L is total length of C, f'=||C'||/L, and inverse t=t(f), t'=1/f'=L/||C'||.\n        // Then d/df(C(t(f)))=C't'=C'L/||C'||. The fragment gave us C', so the\n        // derivative we seek is just a scale away.\n        const a = this._totalLength / result.direction.magnitude();\n        result.direction.scaleInPlace(a);\n        return result;\n    }\n    /**\n     * Returns a ray whose origin is the curve point and direction is the unit tangent.\n     * @param fraction fractional position on the curve\n     * @param result optional receiver for the result.\n     * Returns a ray whose origin is the curve point and direction is the unit tangent.\n     */\n    fractionToPointAndUnitTangent(fraction, result) {\n        const distanceAlongPath = fraction * this._totalLength;\n        const fragment = this.chainDistanceToFragment(distanceAlongPath, true);\n        const curveFraction = fragment.chainDistanceToAccurateChildFraction(distanceAlongPath, true);\n        result = fragment.childCurve.fractionToPointAndDerivative(curveFraction, result);\n        result.direction.normalizeInPlace();\n        return result;\n    }\n    /**\n     * Return a plane with\n     * * origin at fractional position along the curve\n     * * vectorU is the first derivative, i.e. tangent vector with length equal to the rate of change with respect to\n     * the fraction.\n     * * vectorV is the second derivative, i.e.derivative of vectorU.\n     */\n    fractionToPointAnd2Derivatives(fraction, result) {\n        const distanceAlongPath = fraction * this._totalLength;\n        const fragment = this.chainDistanceToFragment(distanceAlongPath, true);\n        const curveFraction = fragment.chainDistanceToAccurateChildFraction(distanceAlongPath, true);\n        result = fragment.childCurve.fractionToPointAnd2Derivatives(curveFraction, result);\n        if (!result)\n            return undefined;\n        // See fractionToPointAndDerivative for derivation of d/df(C(t(f)))=L C'/||C'||.\n        // For the 2nd deriv, use quotient rule, d/dt||x(t)||=x.x'/||x|| and ||x||^2=x.x :\n        // d/df(C'(t(f))) = L d/df(C'/||C'||)\n        //  = L (||C'|| d/df(C') - C' d/df||C'||) / ||C'||^2\n        //  = L (||C'|| C\" L/||C'|| - C' C'.C\"/||C'|| L/||C'||) / ||C'||^2\n        //  = (L/||C'||)^2 (C\" - C' C'.C\"/C'.C' )\n        // We have C' and C\" from the fragment.\n        const magU = result.vectorU.magnitude();\n        const dotUU = magU * magU;\n        const dotUV = result.vectorU.dotProduct(result.vectorV);\n        result.vectorV.addScaledInPlace(result.vectorU, -dotUV / dotUU);\n        const scale = this._totalLength / magU;\n        result.vectorU.scaleInPlace(scale);\n        result.vectorV.scaleInPlace(scale * scale);\n        return result;\n    }\n    /**\n     * Attempt to transform in place.\n     * * Warning: If any child fails, this object becomes invalid.  But that should never happen.\n     */\n    tryTransformInPlace(transform) {\n        let numFail = 0;\n        for (const c of this._path.children) {\n            if (!c.tryTransformInPlace(transform))\n                numFail++;\n        }\n        return numFail === 0;\n    }\n    /** Reverse the curve's data so that its fractional stroking moves in the opposite direction. */\n    reverseInPlace() {\n        this._path.reverseChildrenInPlace();\n        const totalLength = this._totalLength;\n        for (const fragment of this._fragments) {\n            fragment.reverseFractionsAndDistances(totalLength);\n        }\n        this._fragments.reverse();\n    }\n    /**\n     * Test for equality conditions:\n     * * Mismatched totalLength is a quick exit condition\n     * * If totalLength matches, recurse to the path for matching primitives.\n     * @param other\n     */\n    isAlmostEqual(other) {\n        if (other instanceof CurveChainWithDistanceIndex) {\n            return Geometry.isSameCoordinate(this._totalLength, other._totalLength)\n                && this._path.isAlmostEqual(other._path);\n        }\n        return false;\n    }\n    /**\n     * Implement moveSignedDistanceFromFraction.\n     * * See `CurvePrimitive` for parameter details.\n     * * The returned location directly identifies fractional position along the CurveChainWithDistanceIndex, and\n     * has pointer to an additional detail for the child curve.\n     */\n    moveSignedDistanceFromFraction(startFraction, signedDistance, allowExtension, result) {\n        const distanceA = startFraction * this._totalLength;\n        const distanceB = distanceA + signedDistance;\n        const fragmentB = this.chainDistanceToFragment(distanceB, true);\n        const childDetail = fragmentB.childCurve.moveSignedDistanceFromFraction(fragmentB.childFraction0, distanceB - fragmentB.chainDistance0, allowExtension, result);\n        const endFraction = startFraction + (signedDistance / this._totalLength);\n        const chainDetail = CurveLocationDetail.createConditionalMoveSignedDistance(allowExtension, this, startFraction, endFraction, signedDistance, result);\n        chainDetail.childDetail = childDetail;\n        return chainDetail;\n    }\n    /**\n     * The returned object has\n     * * numCalls = number of times closestPoint was called.\n     * * numCurvesTested = number of curves tested with full closestPoint\n     * * numAssigned = number of times a new minimum value was recorded\n     * * numCandidate = number of curves that would be tested in worst case.\n     * return an object summarizing closest point test counts\n     * @param clear if true, counts are cleared after the return object is formed.\n     */\n    static getClosestPointTestCounts(clear = true) {\n        const a = {\n            numCalls: this._numCalls,\n            numTested: this._numTested,\n            numAssigned: this._numAssigned,\n            numCandidate: this._numCandidate,\n        };\n        if (clear) {\n            this._numTested = this._numAssigned = this._numCandidate = 0;\n        }\n        return a;\n    }\n    /**\n     * Search for the curve point that is closest to the spacePoint.\n     * * The CurveChainWithDistanceIndex invokes the base class CurvePrimitive method, which\n     *     (via a handler) determines a CurveLocation detail among the children.\n     * * The returned detail directly identifies fractional position along the CurveChainWithDistanceIndex, and\n     * has pointer to an additional detail for the child curve.\n     * @param spacePoint point in space\n     * @param extend true to extend the curve\n     * @returns Returns a CurveLocationDetail structure that holds the details of the close point.\n     */\n    closestPoint(spacePoint, extend) {\n        let childDetail;\n        let aMin = Number.MAX_VALUE;\n        const numChildren = this.path.children.length;\n        if (numChildren === 1) {\n            childDetail = this.path.children[0].closestPoint(spacePoint, extend);\n        }\n        else {\n            const sortedFragments = PathFragment.collectSortedQuickMinDistances(this._fragments, spacePoint);\n            const extend0 = [CurveExtendOptions.resolveVariantCurveExtendParameterToCurveExtendMode(extend, 0), CurveExtendMode.None];\n            const extend1 = [CurveExtendMode.None, CurveExtendOptions.resolveVariantCurveExtendParameterToCurveExtendMode(extend, 1)];\n            const fragment0 = this._fragments[0];\n            const fragment1 = this._fragments[this._fragments.length - 1];\n            CurveChainWithDistanceIndex._numCalls++;\n            CurveChainWithDistanceIndex._numCandidate += sortedFragments.length;\n            for (const f of sortedFragments) {\n                if (f.a > aMin)\n                    break;\n                CurveChainWithDistanceIndex._numTested++;\n                const child = f.childCurve;\n                const detailA = child.closestPoint(spacePoint, f === fragment0 ? extend0 : f === fragment1 ? extend1 : false);\n                if (detailA && detailA.a < aMin) {\n                    aMin = detailA.a;\n                    childDetail = CurveLocationDetail.createCurveFractionPoint(detailA.curve, detailA.fraction, detailA.point, childDetail);\n                    childDetail.a = detailA.a;\n                    CurveChainWithDistanceIndex._numAssigned++;\n                }\n            }\n        }\n        if (!childDetail)\n            return undefined;\n        const fragment = this.curveAndChildFractionToFragment(childDetail.curve, childDetail.fraction);\n        if (fragment) {\n            const chainDistance = fragment.childFractionToChainDistance(childDetail.fraction);\n            const chainFraction = this.chainDistanceToChainFraction(chainDistance);\n            const chainDetail = CurveLocationDetail.createCurveFractionPoint(this, chainFraction, childDetail.point);\n            chainDetail.childDetail = childDetail;\n            chainDetail.a = childDetail.a;\n            return chainDetail;\n        }\n        return undefined;\n    }\n    /**\n     * Construct an offset of each child as viewed in the xy-plane (ignoring z).\n     * * No attempt is made to join the offset children. Use RegionOps.constructCurveXYOffset() to return a fully\n     * joined offset.\n     * @param offsetDistanceOrOptions offset distance (positive to left of the instance curve), or options object\n     */\n    constructOffsetXY(offsetDistanceOrOptions) {\n        const options = OffsetOptions.create(offsetDistanceOrOptions);\n        const offsets = [];\n        for (const prim of this.collectCurvePrimitives(undefined, true, true)) {\n            const offset = prim.constructOffsetXY(options);\n            if (offset !== undefined) {\n                if (offset instanceof CurvePrimitive)\n                    offsets.push(offset);\n                else if (Array.isArray(offset))\n                    offset.forEach((cp) => offsets.push(cp));\n            }\n        }\n        return offsets;\n    }\n    /**\n     * Project instance geometry (via dispatch) onto the given ray, and return the extreme fractional parameters of\n     * projection.\n     * @param ray ray onto which the instance is projected. A `Vector3d` is treated as a `Ray3d` with zero origin.\n     * @param lowHigh optional receiver for output\n     * @returns range of fractional projection parameters onto the ray, where 0.0 is start of the ray and 1.0 is the\n     * end of the ray.\n     */\n    projectedParameterRange(ray, lowHigh) {\n        return PlaneAltitudeRangeContext.findExtremeFractionsAlongDirection(this, ray, lowHigh);\n    }\n}\nCurveChainWithDistanceIndex._numCalls = 0;\nCurveChainWithDistanceIndex._numTested = 0;\nCurveChainWithDistanceIndex._numAssigned = 0;\nCurveChainWithDistanceIndex._numCandidate = 0;\nexport { CurveChainWithDistanceIndex };\n//# sourceMappingURL=CurveChainWithDistanceIndex.js.map",
      "start": 1693508123541,
      "end": 1693508123704,
      "sourcemaps": null
    }
  ]
}
