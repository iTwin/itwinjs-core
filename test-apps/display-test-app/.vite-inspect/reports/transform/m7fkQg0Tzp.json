{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/markup/lib/esm/Markup.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module MarkupApp\n */\nimport { BentleyError, Logger } from \"@itwin/core-bentley\";\nimport { Point3d } from \"@itwin/core-geometry\";\nimport { ImageSource, ImageSourceFormat } from \"@itwin/core-common\";\nimport { FrontendLoggerCategory, imageElementFromImageSource, IModelApp, ScreenViewport } from \"@itwin/core-frontend\";\nimport { adopt, create, Matrix, Point, SVG } from \"@svgdotjs/svg.js\";\nimport * as redlineTool from \"./RedlineTool\";\nimport { MarkupSelected, SelectTool } from \"./SelectTool\";\nimport * as textTool from \"./TextEdit\";\nimport { UndoManager } from \"./Undo\";\n/**\n * The main object for the Markup package. It is a singleton that stores the state of the Markup application.\n * It has only static members and methods. Applications may customize and control the behavior of the Markup by\n * setting members of [[MarkupApp.props]]. When [[MarkupApp.start]] is first called, it registers a set of \"Markup.xxx\"\n * tools that may be invoked from UI controls.\n * @public\n */\nclass MarkupApp {\n    /** @internal */\n    static screenToVbMtx() {\n        const matrix = this.markup?.svgMarkup?.screenCTM().inverse();\n        return (undefined !== matrix ? matrix : new Matrix());\n    }\n    /** @internal */\n    static getVpToScreenMtx() {\n        const rect = this.markup.markupDiv.getBoundingClientRect();\n        return (new Matrix()).translateO(rect.left, rect.top);\n    }\n    /** @internal */\n    static getVpToVbMtx() { return this.getVpToScreenMtx().lmultiplyO(this.screenToVbMtx()); }\n    /** @internal */\n    static convertVpToVb(pt) {\n        const pt0 = new Point(pt.x, pt.y);\n        pt0.transformO(this.getVpToVbMtx());\n        return new Point3d(pt0.x, pt0.y, 0);\n    }\n    /** determine whether there's a markup session currently active */\n    static get isActive() { return undefined !== this.markup; }\n    static createMarkup(view, markupData) { return new Markup(view, markupData); }\n    static lockViewportSize(view, markupData) {\n        const parentDiv = view.vpDiv;\n        const rect = parentDiv.getBoundingClientRect();\n        let width = rect.width;\n        let height = rect.height;\n        if (markupData) {\n            const aspect = markupData.rect.height / markupData.rect.width;\n            if ((width * aspect) > height)\n                width = Math.floor(height / aspect);\n            else\n                height = Math.floor(width * aspect);\n        }\n        const style = parentDiv.style;\n        style.width = `${width}px`;\n        style.height = `${height}px`;\n    }\n    /** @internal */\n    static getActionName(action) { return IModelApp.localization.getLocalizedString(`${this.namespace}:actions.${action}`); }\n    /** Start a markup session */\n    static async start(view, markupData) {\n        if (this.markup)\n            return; // a markup session is already active.\n        await this.initialize();\n        // first, lock the viewport to its current size while the markup session is running\n        this.lockViewportSize(view, markupData);\n        this.markup = this.createMarkup(view, markupData); // start a markup against the provided view.\n        if (!this.markup.svgMarkup) {\n            ScreenViewport.setToParentSize(this.markup.vp.vpDiv);\n            this.markup.markupDiv.remove();\n            return;\n        }\n        IModelApp.toolAdmin.markupView = view; // so viewing tools won't operate on the view.\n        // set the markup Select tool as the default tool and start it, saving current default tool\n        this._saveDefaultToolId = IModelApp.toolAdmin.defaultToolId;\n        IModelApp.toolAdmin.defaultToolId = this.markupSelectToolId;\n        return IModelApp.toolAdmin.startDefaultTool();\n    }\n    /** Read the result of a Markup session, then stop the session.\n     * @note see [MarkupApp.props.result] for options.\n     */\n    static async stop() {\n        const data = await this.readMarkup();\n        if (!this.markup)\n            return data;\n        // restore original size for vp.\n        ScreenViewport.setToParentSize(this.markup.vp.vpDiv);\n        IModelApp.toolAdmin.markupView = undefined; // re-enable viewing tools for the view being marked-up\n        this.markup.destroy();\n        this.markup = undefined;\n        // now restore the default tool and start it\n        IModelApp.toolAdmin.defaultToolId = this._saveDefaultToolId;\n        this._saveDefaultToolId = \"\";\n        await IModelApp.toolAdmin.startDefaultTool();\n        return data;\n    }\n    /** Call this method to initialize the Markup system.\n     * It asynchronously loads the MarkupTools namespace for the prompts and tool names for the Markup system, and\n     * also registers all of the Markup tools.\n     * @return a Promise that may be awaited to ensure that the MarkupTools namespace had been loaded.\n     * @note This method is automatically called every time you call [[start]]. Since the Markup tools cannot\n     * start unless there is a Markup active, there's really no need to call this method directly.\n     * The only virtue in doing so is to pre-load the Markup namespace if you have an opportunity to do so earlier in your\n     * startup code.\n     * @note This method may be called multiple times, but only the first time initiates the loading/registering. Subsequent\n     * calls return the same Promise.\n     */\n    static async initialize() {\n        if (undefined === this.namespace) { // only need to do this once\n            this.namespace = \"MarkupTools\";\n            const namespacePromise = IModelApp.localization.registerNamespace(this.namespace);\n            IModelApp.tools.register(SelectTool, this.namespace);\n            IModelApp.tools.registerModule(redlineTool, this.namespace);\n            IModelApp.tools.registerModule(textTool, this.namespace);\n            return namespacePromise;\n        }\n        return IModelApp.localization.getNamespacePromise(this.namespace); // so caller can make sure localized messages are ready.\n    }\n    /** convert the current markup SVG into a string, but don't include decorations or dynamics\n     * @internal\n     */\n    static readMarkupSvg() {\n        const markup = this.markup;\n        if (!markup || !markup.svgContainer)\n            return undefined;\n        markup.svgDecorations.remove(); // we don't want the decorations or dynamics to be included\n        markup.svgDynamics.remove();\n        void IModelApp.toolAdmin.startDefaultTool();\n        return markup.svgContainer.svg(); // string-ize the SVG data\n    }\n    /** convert the current markup SVG into a string (after calling readMarkupSvg) making sure width and height are specified.\n     * @internal\n     */\n    static readMarkupSvgForDrawImage() {\n        const markup = this.markup;\n        if (!markup || !markup.svgContainer)\n            return undefined;\n        // Firefox requires width and height on top-level svg or drawImage does nothing, passing width/height to drawImage doesn't work.\n        const rect = markup.markupDiv.getBoundingClientRect();\n        markup.svgContainer.width(rect.width);\n        markup.svgContainer.height(rect.height);\n        return markup.svgContainer.svg(); // string-ize the SVG data\n    }\n    /** @internal */\n    static async readMarkup() {\n        const result = this.props.result;\n        let canvas = this.markup.vp.readImageToCanvas();\n        let svg, image;\n        try {\n            svg = this.readMarkupSvg(); // read the current svg data for the markup\n            const svgForImage = (svg && result.imprintSvgOnImage ? this.readMarkupSvgForDrawImage() : undefined);\n            if (svgForImage) {\n                const svgImage = await imageElementFromImageSource(new ImageSource(svgForImage, ImageSourceFormat.Svg));\n                canvas.getContext(\"2d\").drawImage(svgImage, 0, 0); // draw markup svg onto view's canvas2d\n            }\n            // is the source view too wide? If so, we need to scale the image down.\n            if (canvas.width > result.maxWidth) {\n                // yes, we have to scale it down, create a new canvas and set the new canvas' size\n                const newCanvas = document.createElement(\"canvas\");\n                newCanvas.width = result.maxWidth;\n                newCanvas.height = canvas.height * (result.maxWidth / canvas.width);\n                newCanvas.getContext(\"2d\").drawImage(canvas, 0, 0, canvas.width, canvas.height, 0, 0, newCanvas.width, newCanvas.height);\n                canvas = newCanvas; // return the image from adjusted canvas, not view canvas.\n            }\n            // return the markup data to be saved by the application.\n            image = (!result.imageFormat ? undefined : canvas.toDataURL(result.imageFormat));\n        }\n        catch (e) {\n            Logger.logError(`${FrontendLoggerCategory.Package}.markup`, \"Error creating image from svg\", BentleyError.getErrorProps(e));\n        }\n        return { rect: { width: canvas.width, height: canvas.height }, svg, image };\n    }\n    /** @internal */\n    static get dropShadowId() { return `${this.markupPrefix}dropShadow`; } // this is referenced in the markup Svg to apply the drop-shadow filter to all markup elements.\n    /** @internal */\n    static get cornerId() { return `${this.markupPrefix}photoCorner`; }\n    /** @internal */\n    static get containerClass() { return `${this.markupPrefix}container`; }\n    /** @internal */\n    static get dynamicsClass() { return `${this.markupPrefix}dynamics`; }\n    /** @internal */\n    static get decorationsClass() { return `${this.markupPrefix}decorations`; }\n    /** @internal */\n    static get markupSvgClass() { return `${this.markupPrefix}svg`; }\n    /** @internal */\n    static get boxedTextClass() { return `${this.markupPrefix}boxedText`; }\n    /** @internal */\n    static get textClass() { return `${this.markupPrefix}text`; }\n    /** @internal */\n    static get stretchHandleClass() { return `${this.markupPrefix}stretchHandle`; }\n    /** @internal */\n    static get rotateLineClass() { return `${this.markupPrefix}rotateLine`; }\n    /** @internal */\n    static get rotateHandleClass() { return `${this.markupPrefix}rotateHandle`; }\n    /** @internal */\n    static get vertexHandleClass() { return `${this.markupPrefix}vertexHandle`; }\n    /** @internal */\n    static get moveHandleClass() { return `${this.markupPrefix}moveHandle`; }\n    /** @internal */\n    static get textOutlineClass() { return `${this.markupPrefix}textOutline`; }\n    /** @internal */\n    static get textEditorClass() { return `${this.markupPrefix}textEditor`; }\n}\n/** By setting members of this object, applications can control the appearance and behavior of various parts of MarkupApp. */\nMarkupApp.props = {\n    /** the UI controls displayed on Elements by the Select Tool to allow users to modify them. */\n    handles: {\n        /** The diameter of the circles for the handles. */\n        size: 10,\n        /** The attributes of the stretch handles */\n        stretch: { \"fill-opacity\": .85, \"stroke\": \"black\", \"fill\": \"white\" },\n        /** The attributes of the line that connects the top-center stretch handle to the rotate handle. */\n        rotateLine: { \"stroke\": \"grey\", \"fill-opacity\": .85 },\n        /** The attributes of the rotate handle. */\n        rotate: { \"cursor\": `url(${IModelApp.publicPath}Markup/rotate.png) 12 12, auto`, \"fill-opacity\": .85, \"stroke\": \"black\", \"fill\": \"lightBlue\" },\n        /** The attributes of box around the element. */\n        moveOutline: { \"cursor\": \"move\", \"stroke-dasharray\": \"6,6\", \"fill\": \"none\", \"stroke-opacity\": .85, \"stroke\": \"white\" },\n        /** The attributes of box that provides the move cursor. */\n        move: { \"cursor\": \"move\", \"opacity\": 0, \"stroke-width\": 10, \"stroke\": \"white\" },\n        /** The attributes of handles on the vertices of lines. */\n        vertex: { \"cursor\": `url(${IModelApp.publicPath}cursors/crosshair.cur), crosshair`, \"fill-opacity\": .85, \"stroke\": \"black\", \"fill\": \"white\" },\n    },\n    /** properties for providing feedback about selected elements. */\n    hilite: {\n        /** the color of selected elements */\n        color: \"magenta\",\n        /** the color of an element as the cursor passes over it */\n        flash: \"cyan\",\n    },\n    /** optionally, show a drop-shadow behind all markup elements. */\n    dropShadow: {\n        /** if false, no drop shadow */\n        enable: true,\n        /** the attributes of the drop shadow. See https://developer.mozilla.org/en-US/docs/Web/SVG/Element/feDropShadow */\n        attr: {\n            \"stdDeviation\": 2,\n            \"dx\": 1.2,\n            \"dy\": 1.4,\n            \"flood-color\": \"#1B3838\",\n        },\n    },\n    /** The \"active placement\" parameters. New elements are created with these parameters, so UI controls should set them. */\n    active: {\n        /** the CSS style properties of new text elements. */\n        text: {\n            \"font-family\": \"sans-serif\",\n            \"font-size\": \"30px\",\n            \"stroke\": \"none\",\n            \"fill\": \"red\",\n        },\n        /** the CSS style properties of new elements. */\n        element: {\n            \"stroke\": \"red\",\n            \"stroke-opacity\": 0.8,\n            \"stroke-width\": 3,\n            \"stroke-dasharray\": 0,\n            \"stroke-linecap\": \"round\",\n            \"stroke-linejoin\": \"round\",\n            \"fill\": \"blue\",\n            \"fill-opacity\": 0.2,\n        },\n        arrow: {\n            length: 7,\n            width: 6,\n        },\n        cloud: {\n            path: \"M3.0,2.5 C3.9,.78 5.6,-.4 8.1,1.0 C9.1,0 11.3,-.2 12.5,.5 C14.2,-.5 17,.16 17.9,2.5 C21,3 20.2,7.3 17.6,7.5 C16.5,9.2 14.4,9.8 12.7,8.9 C11.6,10 9.5,10.3 8.1,9.4 C5.7,10.8 3.3,9.4 2.6,7.5 C-.9,7.7 .6,1.7 3.0,2.5z\",\n        },\n    },\n    /** Values for placing and editing Text. */\n    text: {\n        /** A default string for the Markup.Text.Place command. Applications can turn this off, or supply the user's initials, for example. */\n        startValue: \"Note: \",\n        /** Parameters for the size and appearance of the text editor */\n        edit: {\n            background: \"blanchedalmond\",\n            /** Starting size, will be updated if user stretches the box */\n            size: { width: \"25%\", height: \"4em\" },\n            /** font size of the text editor */\n            fontSize: \"14pt\",\n            /** A background box drawn around text so user can tell what's being selected */\n            textBox: { \"fill\": \"lightGrey\", \"fill-opacity\": .1, \"stroke-opacity\": .85, \"stroke\": \"lightBlue\" },\n        },\n    },\n    /** Used to draw the border outline around the view while it is being marked up so the user can tell Markup is active */\n    borderOutline: {\n        \"stroke\": \"gold\",\n        \"stroke-width\": 6,\n        \"stroke-opacity\": 0.4,\n        \"fill\": \"none\",\n    },\n    /** Used to draw the border corner symbols for the view while it is being marked up so the user can tell Markup is active */\n    borderCorners: {\n        \"stroke\": \"black\",\n        \"stroke-width\": 2,\n        \"stroke-opacity\": 0.2,\n        \"fill\": \"gold\",\n        \"fill-opacity\": 0.2,\n    },\n    /** Determines what is returned by MarkupApp.stop */\n    result: {\n        /** The format for the image data. */\n        imageFormat: \"image/png\",\n        /** If true, the markup graphics will be imprinted in the returned image. */\n        imprintSvgOnImage: true,\n        /** the maximum width for the returned image. If the source view width is larger than this, it will be scaled down to this size. */\n        maxWidth: 2048,\n    },\n};\nMarkupApp._saveDefaultToolId = \"\";\nMarkupApp.markupSelectToolId = \"Markup.Select\";\n/** @internal */\nMarkupApp.markupPrefix = \"markup-\";\nexport { MarkupApp };\nconst removeSvgNamespace = (svg) => {\n    svg.node.removeAttribute(\"xmlns:svgjs\");\n    return svg;\n};\nconst newSvgElement = (name) => adopt(create(name));\n/**\n * The current markup being created/edited. Holds the SVG elements, plus the active [[MarkupTool]].\n * When starting a Markup, a new Div is added as a child of the ScreenViewport's vpDiv.\n * @public\n */\nexport class Markup {\n    /** create the drop-shadow filter in the Defs section of the supplied svg element */\n    createDropShadow(svg) {\n        const filter = SVG(`#${MarkupApp.dropShadowId}`); // see if we already have one?\n        if (filter)\n            filter.remove(); // yes, remove it. This must be someone modifying the drop shadow properties\n        // create a new filter, and add it to the Defs of the supplied svg\n        svg.defs()\n            .add(newSvgElement(\"filter\").id(MarkupApp.dropShadowId)\n            .add(newSvgElement(\"feDropShadow\").attr(MarkupApp.props.dropShadow.attr)));\n    }\n    addNested(className) { return this.svgContainer.group().addClass(className); }\n    addBorder() {\n        const rect = this.svgContainer.viewbox();\n        const inset = MarkupApp.props.borderOutline[\"stroke-width\"];\n        const cornerSize = inset * 6;\n        const cornerPts = [0, 0, cornerSize, 0, cornerSize * .7, cornerSize * .3, cornerSize * .3, cornerSize * .3, cornerSize * .3, cornerSize * .7, 0, cornerSize];\n        const decorations = this.svgDecorations;\n        const photoCorner = decorations.symbol().polygon(cornerPts).attr(MarkupApp.props.borderCorners).id(MarkupApp.cornerId);\n        const cornerGroup = decorations.group();\n        cornerGroup.rect(rect.width - inset, rect.height - inset).move(inset / 2, inset / 2).attr(MarkupApp.props.borderOutline);\n        cornerGroup.use(photoCorner);\n        cornerGroup.use(photoCorner).rotate(90).translate(rect.width - cornerSize, 0);\n        cornerGroup.use(photoCorner).rotate(180).translate(rect.width - cornerSize, rect.height - cornerSize);\n        cornerGroup.use(photoCorner).rotate(270).translate(0, rect.height - cornerSize);\n    }\n    /** Create a new Markup for the supplied ScreenViewport. Adds a new \"overlay-markup\" div into the \"vpDiv\"\n     * of the viewport.\n     * @note you must call destroy on this object at end of markup to remove the markup div.\n     */\n    constructor(vp, markupData) {\n        this.vp = vp;\n        /** Support undo/redo of markup operations */\n        this.undo = new UndoManager();\n        this.markupDiv = vp.addNewDiv(\"overlay-markup\", true, 20); // this div goes on top of the canvas, but behind UI layers\n        const rect = this.markupDiv.getBoundingClientRect();\n        // First, see if there is a markup passed in as an argument\n        if (markupData && markupData.svg) {\n            this.markupDiv.innerHTML = markupData.svg; // make it a child of the markupDiv\n            this.svgContainer = SVG(`.${MarkupApp.containerClass}`); // get it in svg.js format\n            this.svgMarkup = SVG(`.${MarkupApp.markupSvgClass}`);\n            if (!this.svgContainer || !this.svgMarkup) // if either isn't present, its not a valid markup\n                return;\n            removeSvgNamespace(this.svgContainer); // the SVG call above adds this - remove it\n            this.svgMarkup.each(() => { }, true); // create an SVG.Element for each entry in the supplied markup.\n        }\n        else {\n            // create the container that will be returned as the \"svg\" data for this markup\n            this.svgContainer = SVG().addTo(this.markupDiv).addClass(MarkupApp.containerClass).viewbox(0, 0, rect.width, rect.height);\n            removeSvgNamespace(this.svgContainer);\n            this.svgMarkup = this.addNested(MarkupApp.markupSvgClass);\n        }\n        if (MarkupApp.props.dropShadow.enable) {\n            this.createDropShadow(this.svgContainer);\n            this.svgContainer.attr(\"filter\", `url(#${MarkupApp.dropShadowId})`);\n        }\n        /** add two nested groups for providing feedback during the markup session. These Svgs are removed before the data is returned. */\n        this.svgDynamics = this.addNested(MarkupApp.dynamicsClass); // only for tool dynamics of SVG graphics.\n        this.svgDecorations = this.addNested(MarkupApp.decorationsClass); // only for temporary decorations of SVG graphics.\n        this.addBorder();\n        this.selected = new MarkupSelected(this.svgDecorations);\n    }\n    /** Called when the Markup is destroyed */\n    destroy() { this.markupDiv.remove(); }\n    /** Turn on picking the markup elements in the markup view */\n    enablePick() { this.markupDiv.style.pointerEvents = \"auto\"; }\n    /** Turn off picking the markup elements in the markup view */\n    disablePick() { this.markupDiv.style.pointerEvents = \"none\"; }\n    /** Change the default cursor for the markup view */\n    setCursor(cursor) { this.markupDiv.style.cursor = cursor; }\n    /** Delete all the entries in the selection set, then empty it. */\n    deleteSelected() { this.selected.deleteAll(this.undo); }\n    /** Bring all the entries in the selection set to the front. */\n    bringToFront() { this.selected.reposition(MarkupApp.getActionName(\"toFront\"), this.undo, (el) => el.front()); }\n    /** Send all the entries in the selection set to the back. */\n    sendToBack() { this.selected.reposition(MarkupApp.getActionName(\"toBack\"), this.undo, (el) => el.back()); }\n    /** Group all the entries in the selection set, then select the group. */\n    groupSelected() {\n        if (undefined !== this.svgMarkup)\n            this.selected.groupAll(this.undo);\n    }\n    /** Ungroup all the group entries in the selection set. */\n    ungroupSelected() {\n        if (undefined !== this.svgMarkup)\n            this.selected.ungroupAll(this.undo);\n    }\n    /** Check if the supplied MarkupElement is a group of MarkupText and the MarkupText's outline Rect.\n     * @param el the markup element to check\n     * @returns true if boxed text\n     */\n    isBoxedText(el) {\n        return el.type === \"g\" &&\n            el.node.classList.length > 0 &&\n            el.node.classList[0] === MarkupApp.boxedTextClass &&\n            el.children().length === 2;\n    }\n    /** Get an existing or create a new reusable symbol representing an arrow head.\n     * If a Marker for the supplied color and size already exists it is returned, otherwise a new Marker is created.\n     * @param color the arrow head color\n     * @param length the arrow head length\n     * @param width the arrow head width\n     * @note Flashing doesn't currently affect markers, need support for \"context-stroke\" and \"context-fill\". For now encode color in name...\n     */\n    createArrowMarker(color, length, width) {\n        length = Math.ceil(length); // Don't allow \".\" in selector string...\n        width = Math.ceil(width);\n        const arrowMarkerId = `ArrowMarker${length}x${width}-${color}`;\n        let marker = SVG(`#${arrowMarkerId}`);\n        if (null === marker) {\n            marker = this.svgMarkup.marker(length, width).id(arrowMarkerId);\n            marker.polygon([0, 0, length, width * 0.5, 0, width]);\n            marker.attr(\"orient\", \"auto-start-reverse\");\n            marker.attr(\"overflow\", \"visible\"); // Don't clip the stroke that is being applied to allow the specified start/end to be used directly while hiding the arrow tail fully under the arrow head...\n            marker.attr(\"refX\", length);\n            marker.css({ stroke: color, fill: color });\n        }\n        return marker;\n    }\n}\n//# sourceMappingURL=Markup.js.map",
      "start": 1693508125553,
      "end": 1693508125713,
      "sourcemaps": null
    }
  ]
}
