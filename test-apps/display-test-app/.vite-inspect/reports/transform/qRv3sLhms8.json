{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/ElementLocateManager.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module LocatingElements\n */\nimport { Id64 } from \"@itwin/core-bentley\";\nimport { Point2d, Point3d } from \"@itwin/core-geometry\";\nimport { HitDetail, HitList, HitSource } from \"./HitDetail\";\nimport { IModelApp } from \"./IModelApp\";\nimport { Pixel } from \"./render/Pixel\";\nimport { InputSource, InteractiveTool } from \"./tools/Tool\";\nimport { ViewRect } from \"./common/ViewRect\";\n/** The possible actions for which a locate filter can be called.\n * @public\n * @extensions\n */\nexport var LocateAction;\n(function (LocateAction) {\n    LocateAction[LocateAction[\"Identify\"] = 0] = \"Identify\";\n    LocateAction[LocateAction[\"AutoLocate\"] = 1] = \"AutoLocate\";\n})(LocateAction || (LocateAction = {}));\n/** Values to return from a locate filter.\n * Return `Reject` to indicate the element is unacceptable.\n * @public\n * @extensions\n */\nexport var LocateFilterStatus;\n(function (LocateFilterStatus) {\n    LocateFilterStatus[LocateFilterStatus[\"Accept\"] = 0] = \"Accept\";\n    LocateFilterStatus[LocateFilterStatus[\"Reject\"] = 1] = \"Reject\";\n})(LocateFilterStatus || (LocateFilterStatus = {}));\n/**\n * @public\n * @extensions\n */\nexport var SnapStatus;\n(function (SnapStatus) {\n    SnapStatus[SnapStatus[\"Success\"] = 0] = \"Success\";\n    SnapStatus[SnapStatus[\"Aborted\"] = 1] = \"Aborted\";\n    SnapStatus[SnapStatus[\"NoElements\"] = 2] = \"NoElements\";\n    SnapStatus[SnapStatus[\"Disabled\"] = 100] = \"Disabled\";\n    SnapStatus[SnapStatus[\"NoSnapPossible\"] = 200] = \"NoSnapPossible\";\n    SnapStatus[SnapStatus[\"NotSnappable\"] = 300] = \"NotSnappable\";\n    SnapStatus[SnapStatus[\"FilteredByApp\"] = 600] = \"FilteredByApp\";\n    SnapStatus[SnapStatus[\"FilteredByAppQuietly\"] = 700] = \"FilteredByAppQuietly\";\n})(SnapStatus || (SnapStatus = {}));\n/** Options that customize the way element location (i.e. *picking*) works.\n * @public\n * @extensions\n */\nexport class LocateOptions {\n    constructor() {\n        /** If true, also test graphics from view decorations. */\n        this.allowDecorations = false;\n        /** If true, also test graphics with non-locatable flag set. */\n        this.allowNonLocatable = false;\n        /** Maximum number of hits to return. */\n        this.maxHits = 20;\n        /** The [[HitSource]] identifying the caller. */\n        this.hitSource = HitSource.DataPoint;\n        /** If true, also test graphics from an IModelConnection other than the one associated with the Viewport. This can occur if, e.g., a\n         * [[TiledGraphicsProvider]] is used to display graphics from a different iModel into the [[Viewport]].\n         * @note If you override this, you must be prepared to properly handle [[HitDetail]]s originating from other IModelConnections.\n         * @see [[HitDetail.iModel]] and [[HitDetail.isExternalIModelHit]]\n         */\n        this.allowExternalIModels = false;\n        /** If true, then the world point of a hit on a model will preserve any transforms applied to the model at display time,\n         * such as those supplied by a [[ModelDisplayTransformProvider]] or [PlanProjectionSettings.elevation]($common).\n         * Otherwise, the world point will be multiplied by the inverse of any such transforms to correlate it with the model's true coordinate space.\n         */\n        this.preserveModelDisplayTransforms = false;\n    }\n    /** Make a copy of this LocateOptions. */\n    clone() {\n        const other = new LocateOptions();\n        other.allowDecorations = this.allowDecorations;\n        other.allowNonLocatable = this.allowNonLocatable;\n        other.maxHits = this.maxHits;\n        other.hitSource = this.hitSource;\n        other.allowExternalIModels = this.allowExternalIModels;\n        return other;\n    }\n    setFrom(other) {\n        this.allowDecorations = other.allowDecorations;\n        this.allowNonLocatable = other.allowNonLocatable;\n        this.maxHits = other.maxHits;\n        this.hitSource = other.hitSource;\n        this.allowExternalIModels = other.allowExternalIModels;\n    }\n    init() {\n        this.allowDecorations = this.allowNonLocatable = this.allowExternalIModels = false;\n        this.maxHits = 20;\n        this.hitSource = HitSource.DataPoint;\n    }\n}\n/**\n * @public\n * @extensions\n */\nexport class LocateResponse {\n    constructor() {\n        this.snapStatus = SnapStatus.Success;\n        this.explanation = \"\";\n    }\n    /** @internal */\n    clone() {\n        const other = new LocateResponse();\n        other.snapStatus = this.snapStatus;\n        other.reason = this.reason;\n        other.explanation = this.explanation;\n        return other;\n    }\n    /** @internal */\n    setFrom(other) {\n        this.snapStatus = other.snapStatus;\n        this.reason = other.reason;\n        this.explanation = other.explanation;\n    }\n}\n/**\n * @public\n * @extensions\n */\nexport class ElementPicker {\n    constructor() {\n        this.pickPointWorld = new Point3d();\n    }\n    empty() {\n        this.pickPointWorld.setZero();\n        this.viewport = undefined;\n        if (this.hitList)\n            this.hitList.empty();\n        else\n            this.hitList = new HitList();\n    }\n    /** return the HitList for the last Pick performed. Optionally allows the caller to take ownership of the list. */\n    getHitList(takeOwnership) {\n        const list = this.hitList;\n        if (takeOwnership)\n            this.hitList = undefined;\n        return list;\n    }\n    getNextHit() { return this.hitList ? this.hitList.getNextHit() : undefined; }\n    /** Return a hit from the list of hits created the last time pickElements was called. */\n    getHit(i) { return this.hitList ? this.hitList.getHit(i) : undefined; }\n    resetCurrentHit() {\n        if (this.hitList)\n            this.hitList.resetCurrentHit();\n    }\n    comparePixel(pixel1, pixel2, distXY1, distXY2) {\n        const priority1 = pixel1.computeHitPriority();\n        const priority2 = pixel2.computeHitPriority();\n        if (priority1 < priority2)\n            return -1;\n        if (priority1 > priority2)\n            return 1;\n        if (distXY1 < distXY2)\n            return -1;\n        if (distXY1 > distXY2)\n            return 1;\n        if (pixel1.distanceFraction > pixel2.distanceFraction)\n            return -1;\n        if (pixel1.distanceFraction < pixel2.distanceFraction)\n            return 1;\n        return 0;\n    }\n    /** Generate a list of elements that are close to a given point.\n     * @returns The number of hits in the hitList of this object.\n     */\n    doPick(vp, pickPointWorld, pickRadiusView, options) {\n        if (this.hitList && this.hitList.length > 0 && vp === this.viewport && pickPointWorld.isAlmostEqual(this.pickPointWorld)) {\n            this.hitList.resetCurrentHit();\n            return this.hitList.length;\n        }\n        this.empty(); // empty the hit list\n        this.viewport = vp;\n        this.pickPointWorld.setFrom(pickPointWorld);\n        const pickPointView = vp.worldToView(pickPointWorld);\n        const testPointView = new Point2d(Math.floor(pickPointView.x + 0.5), Math.floor(pickPointView.y + 0.5));\n        let pixelRadius = Math.floor(pickRadiusView + 0.5);\n        const rect = new ViewRect(testPointView.x - pixelRadius, testPointView.y - pixelRadius, testPointView.x + pixelRadius, testPointView.y + pixelRadius);\n        if (rect.isNull)\n            return 0;\n        let result = 0;\n        vp.readPixels(rect, Pixel.Selector.All, (pixels) => {\n            if (undefined === pixels)\n                return;\n            testPointView.x = vp.cssPixelsToDevicePixels(testPointView.x);\n            testPointView.y = vp.cssPixelsToDevicePixels(testPointView.y);\n            pixelRadius = vp.cssPixelsToDevicePixels(pixelRadius);\n            const elmHits = new Map();\n            const testPoint = Point2d.createZero();\n            for (testPoint.x = testPointView.x - pixelRadius; testPoint.x <= testPointView.x + pixelRadius; ++testPoint.x) {\n                for (testPoint.y = testPointView.y - pixelRadius; testPoint.y <= testPointView.y + pixelRadius; ++testPoint.y) {\n                    const pixel = pixels.getPixel(testPoint.x, testPoint.y);\n                    if (undefined === pixel || undefined === pixel.elementId || Id64.isInvalid(pixel.elementId))\n                        continue; // no geometry at this location...\n                    const distXY = testPointView.distance(testPoint);\n                    if (distXY > pixelRadius)\n                        continue; // ignore corners. it's a locate circle not square...\n                    const oldPoint = elmHits.get(pixel.elementId);\n                    if (undefined !== oldPoint) {\n                        if (this.comparePixel(pixel, pixels.getPixel(oldPoint.x, oldPoint.y), distXY, testPointView.distance(oldPoint)) < 0)\n                            oldPoint.setFrom(testPoint); // new hit is better, update location...\n                    }\n                    else {\n                        elmHits.set(pixel.elementId, testPoint.clone());\n                    }\n                }\n            }\n            if (0 === elmHits.size)\n                return;\n            for (const elmPoint of elmHits.values()) {\n                const pixel = pixels.getPixel(elmPoint.x, elmPoint.y);\n                if (undefined === pixel || undefined === pixel.elementId)\n                    continue;\n                const hitPointWorld = vp.getPixelDataWorldPoint({\n                    pixels,\n                    x: elmPoint.x,\n                    y: elmPoint.y,\n                    preserveModelDisplayTransforms: options.preserveModelDisplayTransforms,\n                });\n                if (!hitPointWorld)\n                    continue;\n                const hit = new HitDetail({\n                    ...pixel.toHitProps(vp),\n                    testPoint: pickPointWorld,\n                    viewport: vp,\n                    hitSource: options.hitSource,\n                    hitPoint: hitPointWorld,\n                    distXY: testPointView.distance(elmPoint),\n                });\n                this.hitList.addHit(hit);\n                if (this.hitList.hits.length > options.maxHits)\n                    this.hitList.hits.length = options.maxHits; // truncate array...\n            }\n            result = this.hitList.length;\n        }, !options.allowNonLocatable);\n        return result;\n    }\n    testHit(hit, vp, pickPointWorld, pickRadiusView, options) {\n        if (0 === this.doPick(vp, pickPointWorld, pickRadiusView, options))\n            return false;\n        return this.hitList.hits.some((thisHit) => hit.isSameHit(thisHit));\n    }\n}\n/**\n * @public\n * @extensions\n */\nexport class ElementLocateManager {\n    constructor() {\n        this.options = new LocateOptions();\n        this.picker = new ElementPicker();\n    }\n    /** get the full message key for a locate failure  */\n    static getFailureMessageKey(key) { return `LocateFailure.${key}`; }\n    onInitialized() { }\n    get apertureInches() { return 0.11; }\n    get touchApertureInches() { return 0.22; }\n    clear() { this.setCurrHit(undefined); }\n    setHitList(list) { this.hitList = list; }\n    setCurrHit(hit) { this.currHit = hit; }\n    getNextHit() { return this.hitList ? this.hitList.getNextHit() : undefined; }\n    /** return the current path from either the snapping logic or the pre-locating systems. */\n    getPreLocatedHit() {\n        // NOTE: Check AccuSnap first as Tentative is used to build intersect snap. For normal snaps when a Tentative is active there should be no AccuSnap.\n        let preLocated = IModelApp.accuSnap.getHitAndList(this);\n        if (!preLocated && !!(preLocated = IModelApp.tentativePoint.getHitAndList(this))) {\n            const vp = preLocated.viewport;\n            this.picker.empty(); // Get new hit list at hit point; want reset to cycle hits using adjusted point location...\n            this.picker.doPick(vp, preLocated.getPoint(), (vp.pixelsFromInches(this.apertureInches) / 2.0) + 1.5, this.options);\n            this.setHitList(this.picker.getHitList(true));\n        }\n        if (this.hitList)\n            this.hitList.resetCurrentHit();\n        return preLocated;\n    }\n    async filterHit(hit, _action, out) {\n        // Tools must opt-in to locate of transient geometry as it requires special treatment.\n        if (!this.options.allowDecorations && !hit.isElementHit) {\n            if (hit.isModelHit)\n                out.reason = ElementLocateManager.getFailureMessageKey(\"RealityModel\");\n            else if (hit.isMapHit)\n                out.reason = ElementLocateManager.getFailureMessageKey(\"Map\");\n            else\n                out.reason = ElementLocateManager.getFailureMessageKey(\"Transient\");\n            return LocateFilterStatus.Reject;\n        }\n        // Tools must opt-in to locate geometry from external iModels.\n        if (!this.options.allowExternalIModels && hit.isExternalIModelHit) {\n            out.reason = ElementLocateManager.getFailureMessageKey(\"ExternalIModel\");\n            return LocateFilterStatus.Reject;\n        }\n        if (undefined !== hit.subCategoryId && !hit.isExternalIModelHit) {\n            const appearance = hit.viewport.getSubCategoryAppearance(hit.subCategoryId);\n            if (appearance.dontLocate) {\n                out.reason = ElementLocateManager.getFailureMessageKey(\"NotLocatableSubCategory\");\n                return LocateFilterStatus.Reject;\n            }\n        }\n        const tool = IModelApp.toolAdmin.activeTool;\n        if (!(tool && tool instanceof InteractiveTool))\n            return LocateFilterStatus.Accept;\n        const status = await tool.filterHit(hit, out);\n        if (LocateFilterStatus.Reject === status)\n            out.reason = ElementLocateManager.getFailureMessageKey(\"ByApp\");\n        return status;\n    }\n    initLocateOptions() { this.options.init(); }\n    initToolLocate() {\n        this.initLocateOptions();\n        this.clear();\n        this.picker.empty();\n        IModelApp.tentativePoint.clear(true);\n    }\n    async _doLocate(response, newSearch, testPoint, vp, source, filterHits) {\n        if (!vp)\n            return;\n        // the \"newSearch\" flag indicates whether the caller wants us to conduct a new search at the testPoint, or just continue returning paths from the previous search.\n        if (newSearch) {\n            const hit = this.getPreLocatedHit();\n            // if we're snapped to something, that path has the highest priority and becomes the active hit.\n            if (hit) {\n                if (!filterHits || LocateFilterStatus.Accept === await this.filterHit(hit, LocateAction.Identify, response))\n                    return hit;\n                response = new LocateResponse(); // we have the reason and explanation we want.\n            }\n            this.picker.empty();\n            this.picker.doPick(vp, testPoint, (vp.pixelsFromInches(InputSource.Touch === source ? this.touchApertureInches : this.apertureInches) / 2.0) + 1.5, this.options);\n            const hitList = this.picker.getHitList(true);\n            this.setHitList(hitList);\n        }\n        let newHit;\n        while (undefined !== (newHit = this.getNextHit())) {\n            if (!filterHits || LocateFilterStatus.Accept === await this.filterHit(newHit, LocateAction.Identify, response))\n                return newHit;\n            response = new LocateResponse(); // we have the reason and explanation we want.\n        }\n        return undefined;\n    }\n    async doLocate(response, newSearch, testPoint, view, source, filterHits = true) {\n        response.reason = ElementLocateManager.getFailureMessageKey(\"NoElements\");\n        response.explanation = \"\";\n        const hit = await this._doLocate(response, newSearch, testPoint, view, source, filterHits);\n        this.setCurrHit(hit);\n        // if we found a hit, remove it from the list of remaining hits near the current search point.\n        if (hit && this.hitList)\n            this.hitList.removeHitsFrom(hit.sourceId);\n        return hit;\n    }\n}\n//# sourceMappingURL=ElementLocateManager.js.map",
      "start": 1693508119252,
      "end": 1693508119385,
      "sourcemaps": null
    }
  ]
}
