{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tools/SelectTool.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module SelectionSet\n */\nimport { Id64 } from \"@itwin/core-bentley\";\nimport { Point2d, Range2d } from \"@itwin/core-geometry\";\nimport { ColorDef } from \"@itwin/core-common\";\nimport { PropertyEditorParamTypes, } from \"@itwin/appui-abstract\";\nimport { LocateFilterStatus, LocateResponse } from \"../ElementLocateManager\";\nimport { IModelApp } from \"../IModelApp\";\nimport { Pixel } from \"../render/Pixel\";\nimport { ViewRect } from \"../common/ViewRect\";\nimport { PrimitiveTool } from \"./PrimitiveTool\";\nimport { BeButton, BeButtonEvent, BeModifierKeys, CoordinateLockOverrides, CoreTools, EventHandled, InputSource } from \"./Tool\";\nimport { ManipulatorToolEvent } from \"./ToolAdmin\";\nimport { ToolAssistance, ToolAssistanceImage, ToolAssistanceInputMethod } from \"./ToolAssistance\";\n// cSpell:ignore buttongroup\n/** The method for choosing elements with the [[SelectionTool]]\n * @public\n * @extensions\n */\nexport var SelectionMethod;\n(function (SelectionMethod) {\n    /** Identify element(s) by picking for drag selection (inside/overlap for drag box selection determined by point direction and shift key) */\n    SelectionMethod[SelectionMethod[\"Pick\"] = 0] = \"Pick\";\n    /** Identify elements by overlap with crossing line */\n    SelectionMethod[SelectionMethod[\"Line\"] = 1] = \"Line\";\n    /** Identify elements by box selection (inside/overlap for box selection determined by point direction and shift key) */\n    SelectionMethod[SelectionMethod[\"Box\"] = 2] = \"Box\";\n})(SelectionMethod || (SelectionMethod = {}));\n/** The mode for choosing elements with the [[SelectionTool]]\n * @public\n * @extensions\n */\nexport var SelectionMode;\n(function (SelectionMode) {\n    /** Identified elements replace the current selection set (use control key to add or remove) */\n    SelectionMode[SelectionMode[\"Replace\"] = 0] = \"Replace\";\n    /** Identified elements are added to the current selection set */\n    SelectionMode[SelectionMode[\"Add\"] = 1] = \"Add\";\n    /** Identified elements are removed from the current selection set */\n    SelectionMode[SelectionMode[\"Remove\"] = 2] = \"Remove\";\n})(SelectionMode || (SelectionMode = {}));\n/** The processing method to use to update the current selection.\n * @public\n * @extensions\n */\nexport var SelectionProcessing;\n(function (SelectionProcessing) {\n    /** Add element to selection. */\n    SelectionProcessing[SelectionProcessing[\"AddElementToSelection\"] = 0] = \"AddElementToSelection\";\n    /** Remove element from selection. */\n    SelectionProcessing[SelectionProcessing[\"RemoveElementFromSelection\"] = 1] = \"RemoveElementFromSelection\";\n    /** If element is in selection remove it, else add it. */\n    SelectionProcessing[SelectionProcessing[\"InvertElementInSelection\"] = 2] = \"InvertElementInSelection\";\n    /** Replace current selection with element. */\n    SelectionProcessing[SelectionProcessing[\"ReplaceSelectionWithElement\"] = 3] = \"ReplaceSelectionWithElement\";\n})(SelectionProcessing || (SelectionProcessing = {}));\n/** Tool for picking a set of elements of interest, selected by the user.\n * @public\n */\nclass SelectionTool extends PrimitiveTool {\n    constructor() {\n        super(...arguments);\n        this._isSelectByPoints = false;\n        this._isSuspended = false;\n        this._points = [];\n        this._selectionMethodValue = { value: SelectionMethod.Pick };\n        this._selectionModeValue = { value: SelectionMode.Replace };\n    }\n    requireWriteableTarget() { return false; }\n    autoLockTarget() { } // NOTE: For selecting elements we only care about iModel, so don't lock target model automatically.\n    wantSelectionClearOnMiss(_ev) { return SelectionMode.Replace === this.selectionMode; }\n    wantEditManipulators() { return SelectionMethod.Pick === this.selectionMethod; }\n    wantPickableDecorations() { return this.wantEditManipulators(); } // Allow pickable decorations selection to be independent of manipulators...\n    wantToolSettings() { return true; }\n    get selectionMethod() { return this._selectionMethodValue.value; }\n    set selectionMethod(method) { this._selectionMethodValue.value = method; }\n    get selectionMode() { return this._selectionModeValue.value; }\n    set selectionMode(mode) { this._selectionModeValue.value = mode; }\n    static methodsMessage(str) { return CoreTools.translate(`ElementSet.SelectionMethods.${str}`); }\n    /* The property descriptions used to generate ToolSettings UI. */\n    static _getMethodsDescription() {\n        return {\n            name: SelectionTool._methodsName,\n            displayLabel: \"\",\n            typename: \"enum\",\n            editor: {\n                name: \"enum-buttongroup\",\n                params: [{\n                        type: PropertyEditorParamTypes.ButtonGroupData,\n                        buttons: [\n                            { iconSpec: \"icon-select-single\" },\n                            { iconSpec: \"icon-select-line\" },\n                            { iconSpec: \"icon-select-box\" },\n                        ],\n                    }, {\n                        type: PropertyEditorParamTypes.SuppressEditorLabel,\n                        suppressLabelPlaceholder: true,\n                    },\n                ],\n            },\n            enum: {\n                choices: [\n                    { label: SelectionTool.methodsMessage(\"Pick\"), value: SelectionMethod.Pick },\n                    { label: SelectionTool.methodsMessage(\"Line\"), value: SelectionMethod.Line },\n                    { label: SelectionTool.methodsMessage(\"Box\"), value: SelectionMethod.Box },\n                ],\n            },\n        };\n    }\n    static modesMessage(str) { return CoreTools.translate(`ElementSet.SelectionModes.${str}`); }\n    /* The property descriptions used to generate ToolSettings UI. */\n    static _getModesDescription() {\n        return {\n            name: SelectionTool._modesName,\n            displayLabel: \"\",\n            typename: \"enum\",\n            editor: {\n                name: \"enum-buttongroup\",\n                params: [{\n                        type: PropertyEditorParamTypes.ButtonGroupData,\n                        buttons: [\n                            { iconSpec: \"icon-replace\" },\n                            { iconSpec: \"icon-select-plus\" },\n                            {\n                                iconSpec: \"icon-select-minus\",\n                                isEnabledFunction: () => {\n                                    const tool = IModelApp.toolAdmin.activeTool;\n                                    return tool instanceof PrimitiveTool ? tool.iModel.selectionSet.isActive : false;\n                                },\n                            },\n                        ],\n                    }, {\n                        type: PropertyEditorParamTypes.SuppressEditorLabel,\n                        suppressLabelPlaceholder: true,\n                    },\n                ],\n            },\n            enum: {\n                choices: [\n                    { label: SelectionTool.modesMessage(\"Replace\"), value: SelectionMode.Replace },\n                    { label: SelectionTool.modesMessage(\"Add\"), value: SelectionMode.Add },\n                    { label: SelectionTool.modesMessage(\"Remove\"), value: SelectionMode.Remove },\n                ],\n            },\n        };\n    }\n    showPrompt(mode, method) {\n        let mainMsg = \"ElementSet.Prompts.\";\n        switch (method) {\n            case SelectionMethod.Pick:\n                mainMsg += \"IdentifyElement\";\n                break;\n            case SelectionMethod.Line:\n                mainMsg += (0 === this._points.length ? \"StartPoint\" : \"EndPoint\");\n                break;\n            case SelectionMethod.Box:\n                mainMsg += (0 === this._points.length ? \"StartCorner\" : \"OppositeCorner\");\n                break;\n        }\n        const mainInstruction = ToolAssistance.createInstruction(this.iconSpec, CoreTools.translate(mainMsg));\n        const sections = [];\n        switch (method) {\n            case SelectionMethod.Pick:\n                const mousePickInstructions = [];\n                mousePickInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.LeftClick, CoreTools.translate(\"ElementSet.Inputs.AcceptElement\"), false, ToolAssistanceInputMethod.Mouse));\n                mousePickInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.LeftClickDrag, CoreTools.translate(\"ElementSet.Inputs.BoxCorners\"), false, ToolAssistanceInputMethod.Mouse));\n                mousePickInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.RightClickDrag, CoreTools.translate(\"ElementSet.Inputs.CrossingLine\"), false, ToolAssistanceInputMethod.Mouse));\n                mousePickInstructions.push(ToolAssistance.createModifierKeyInstruction(ToolAssistance.shiftKey, ToolAssistanceImage.LeftClickDrag, CoreTools.translate(\"ElementSet.Inputs.OverlapSelection\"), false, ToolAssistanceInputMethod.Mouse));\n                if (SelectionMode.Replace === mode) {\n                    mousePickInstructions.push(ToolAssistance.createKeyboardInstruction(ToolAssistance.ctrlKeyboardInfo, CoreTools.translate(\"ElementSet.Inputs.InvertSelection\"), false, ToolAssistanceInputMethod.Mouse));\n                    mousePickInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.CursorClick, CoreTools.translate(\"ElementSet.Inputs.ClearSelection\"), false, ToolAssistanceInputMethod.Mouse));\n                }\n                sections.push(ToolAssistance.createSection(mousePickInstructions, ToolAssistance.inputsLabel));\n                const touchPickInstructions = [];\n                if (!ToolAssistance.createTouchCursorInstructions(touchPickInstructions))\n                    touchPickInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.OneTouchTap, CoreTools.translate(\"ElementSet.Inputs.AcceptElement\"), false, ToolAssistanceInputMethod.Touch));\n                sections.push(ToolAssistance.createSection(touchPickInstructions, ToolAssistance.inputsLabel));\n                break;\n            case SelectionMethod.Line:\n                const mouseLineInstructions = [];\n                mouseLineInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.LeftClick, CoreTools.translate(\"ElementSet.Inputs.AcceptPoint\"), false, ToolAssistanceInputMethod.Mouse));\n                if (SelectionMode.Replace === mode)\n                    mouseLineInstructions.push(ToolAssistance.createModifierKeyInstruction(ToolAssistance.ctrlKey, ToolAssistanceImage.LeftClick, CoreTools.translate(\"ElementSet.Inputs.InvertSelection\"), false, ToolAssistanceInputMethod.Mouse));\n                sections.push(ToolAssistance.createSection(mouseLineInstructions, ToolAssistance.inputsLabel));\n                const touchLineInstructions = [];\n                touchLineInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.OneTouchDrag, CoreTools.translate(\"ElementSet.Inputs.AcceptPoint\"), false, ToolAssistanceInputMethod.Touch));\n                sections.push(ToolAssistance.createSection(touchLineInstructions, ToolAssistance.inputsLabel));\n                break;\n            case SelectionMethod.Box:\n                const mouseBoxInstructions = [];\n                mouseBoxInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.LeftClick, CoreTools.translate(\"ElementSet.Inputs.AcceptPoint\"), false, ToolAssistanceInputMethod.Mouse));\n                mouseBoxInstructions.push(ToolAssistance.createModifierKeyInstruction(ToolAssistance.shiftKey, ToolAssistanceImage.LeftClick, CoreTools.translate(\"ElementSet.Inputs.OverlapSelection\"), false, ToolAssistanceInputMethod.Mouse));\n                if (SelectionMode.Replace === mode)\n                    mouseBoxInstructions.push(ToolAssistance.createModifierKeyInstruction(ToolAssistance.ctrlKey, ToolAssistanceImage.LeftClick, CoreTools.translate(\"ElementSet.Inputs.InvertSelection\"), false, ToolAssistanceInputMethod.Mouse));\n                sections.push(ToolAssistance.createSection(mouseBoxInstructions, ToolAssistance.inputsLabel));\n                const touchBoxInstructions = [];\n                touchBoxInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.OneTouchDrag, CoreTools.translate(\"ElementSet.Inputs.AcceptPoint\"), false, ToolAssistanceInputMethod.Touch));\n                sections.push(ToolAssistance.createSection(touchBoxInstructions, ToolAssistance.inputsLabel));\n                break;\n        }\n        const instructions = ToolAssistance.createInstructions(mainInstruction, sections);\n        IModelApp.notifications.setToolAssistance(instructions);\n    }\n    initSelectTool() {\n        const method = this.selectionMethod;\n        const mode = this.selectionMode;\n        const enableLocate = SelectionMethod.Pick === method;\n        this._isSelectByPoints = false;\n        this._points.length = 0;\n        this.initLocateElements(enableLocate, false, enableLocate ? \"default\" : IModelApp.viewManager.crossHairCursor, CoordinateLockOverrides.All);\n        IModelApp.locateManager.options.allowDecorations = true; // Always locate to display tool tip even if we reject for adding to selection set...\n        this.showPrompt(mode, method);\n    }\n    processMiss(_ev) {\n        if (!this.iModel.selectionSet.isActive)\n            return false;\n        this.iModel.selectionSet.emptyAll();\n        return true;\n    }\n    updateSelection(elementId, process) {\n        let returnValue = false;\n        switch (process) {\n            case SelectionProcessing.AddElementToSelection:\n                returnValue = this.iModel.selectionSet.add(elementId);\n                break;\n            case SelectionProcessing.RemoveElementFromSelection:\n                returnValue = this.iModel.selectionSet.remove(elementId);\n                break;\n            case SelectionProcessing.InvertElementInSelection: // (if element is in selection remove it else add it.)\n                returnValue = this.iModel.selectionSet.invert(elementId);\n                break;\n            case SelectionProcessing.ReplaceSelectionWithElement:\n                this.iModel.selectionSet.replace(elementId);\n                returnValue = true;\n                break;\n            default:\n                return false;\n        }\n        // always force UI to sync display of options since the select option of Remove should only be enabled if the selection set has elements.\n        if (returnValue)\n            this.syncSelectionMode();\n        return returnValue;\n    }\n    async processSelection(elementId, process) { return this.updateSelection(elementId, process); }\n    useOverlapSelection(ev) {\n        if (undefined === ev.viewport)\n            return false;\n        const pt1 = ev.viewport.worldToView(this._points[0]);\n        const pt2 = ev.viewport.worldToView(ev.point);\n        const overlapMode = (pt1.x > pt2.x);\n        return (ev.isShiftKey ? !overlapMode : overlapMode); // Shift inverts inside/overlap selection...\n    }\n    selectByPointsDecorate(context) {\n        if (!this._isSelectByPoints)\n            return;\n        const ev = new BeButtonEvent();\n        IModelApp.toolAdmin.fillEventFromCursorLocation(ev);\n        if (undefined === ev.viewport)\n            return;\n        const vp = context.viewport;\n        const bestContrastIsBlack = (ColorDef.black === vp.getContrastToBackgroundColor());\n        const crossingLine = (SelectionMethod.Line === this.selectionMethod || (SelectionMethod.Pick === this.selectionMethod && BeButton.Reset === ev.button));\n        const overlapSelection = (crossingLine || this.useOverlapSelection(ev));\n        const position = vp.worldToView(this._points[0]);\n        position.x = Math.floor(position.x) + 0.5;\n        position.y = Math.floor(position.y) + 0.5;\n        const position2 = vp.worldToView(ev.point);\n        position2.x = Math.floor(position2.x) + 0.5;\n        position2.y = Math.floor(position2.y) + 0.5;\n        const offset = position2.minus(position);\n        const drawDecoration = (ctx) => {\n            ctx.strokeStyle = bestContrastIsBlack ? \"black\" : \"white\";\n            ctx.lineWidth = 1;\n            if (overlapSelection)\n                ctx.setLineDash([5, 5]);\n            if (crossingLine) {\n                ctx.beginPath();\n                ctx.moveTo(0, 0);\n                ctx.lineTo(offset.x, offset.y);\n                ctx.stroke();\n            }\n            else {\n                ctx.strokeRect(0, 0, offset.x, offset.y);\n                ctx.fillStyle = bestContrastIsBlack ? \"rgba(0,0,0,.06)\" : \"rgba(255,255,255,.06)\";\n                ctx.fillRect(0, 0, offset.x, offset.y);\n            }\n        };\n        context.addCanvasDecoration({ position, drawDecoration });\n    }\n    selectByPointsProcess(origin, corner, ev, method, overlap) {\n        const vp = ev.viewport;\n        if (!vp)\n            return;\n        const pts = [];\n        pts[0] = new Point2d(Math.floor(origin.x + 0.5), Math.floor(origin.y + 0.5));\n        pts[1] = new Point2d(Math.floor(corner.x + 0.5), Math.floor(corner.y + 0.5));\n        const range = Range2d.createArray(pts);\n        const rect = new ViewRect();\n        rect.initFromRange(range);\n        const allowTransients = this.wantPickableDecorations();\n        vp.readPixels(rect, Pixel.Selector.Feature, (pixels) => {\n            if (undefined === pixels)\n                return;\n            const sRange = Range2d.createNull();\n            sRange.extendPoint(Point2d.create(vp.cssPixelsToDevicePixels(range.low.x), vp.cssPixelsToDevicePixels(range.low.y)));\n            sRange.extendPoint(Point2d.create(vp.cssPixelsToDevicePixels(range.high.x), vp.cssPixelsToDevicePixels(range.high.y)));\n            pts[0].x = vp.cssPixelsToDevicePixels(pts[0].x);\n            pts[0].y = vp.cssPixelsToDevicePixels(pts[0].y);\n            pts[1].x = vp.cssPixelsToDevicePixels(pts[1].x);\n            pts[1].y = vp.cssPixelsToDevicePixels(pts[1].y);\n            let contents = new Set();\n            const testPoint = Point2d.createZero();\n            const getPixelElementId = (pixel) => {\n                if (undefined === pixel.elementId || Id64.isInvalid(pixel.elementId))\n                    return undefined; // no geometry at this location...\n                if (!allowTransients && Id64.isTransient(pixel.elementId))\n                    return undefined; // tool didn't request pickable decorations...\n                if (!vp.isPixelSelectable(pixel))\n                    return undefined; // reality model, terrain, etc - not selectable\n                return pixel.elementId;\n            };\n            if (SelectionMethod.Box === method) {\n                const outline = overlap ? undefined : new Set();\n                const offset = sRange.clone();\n                offset.expandInPlace(-2);\n                for (testPoint.x = sRange.low.x; testPoint.x <= sRange.high.x; ++testPoint.x) {\n                    for (testPoint.y = sRange.low.y; testPoint.y <= sRange.high.y; ++testPoint.y) {\n                        const pixel = pixels.getPixel(testPoint.x, testPoint.y);\n                        const elementId = getPixelElementId(pixel);\n                        if (undefined === elementId)\n                            continue;\n                        if (undefined !== outline && !offset.containsPoint(testPoint))\n                            outline.add(elementId.toString());\n                        else\n                            contents.add(elementId.toString());\n                    }\n                }\n                if (undefined !== outline && 0 !== outline.size) {\n                    const inside = new Set();\n                    contents.forEach((id) => {\n                        if (!outline.has(id))\n                            inside.add(id);\n                    });\n                    contents = inside;\n                }\n            }\n            else {\n                const closePoint = Point2d.createZero();\n                for (testPoint.x = sRange.low.x; testPoint.x <= sRange.high.x; ++testPoint.x) {\n                    for (testPoint.y = sRange.low.y; testPoint.y <= sRange.high.y; ++testPoint.y) {\n                        const pixel = pixels.getPixel(testPoint.x, testPoint.y);\n                        const elementId = getPixelElementId(pixel);\n                        if (undefined === elementId)\n                            continue;\n                        const fraction = testPoint.fractionOfProjectionToLine(pts[0], pts[1], 0.0);\n                        pts[0].interpolate(fraction, pts[1], closePoint);\n                        if (closePoint.distance(testPoint) < 1.5)\n                            contents.add(elementId.toString());\n                    }\n                }\n            }\n            if (0 === contents.size) {\n                if (!ev.isControlKey && this.wantSelectionClearOnMiss(ev) && this.processMiss(ev))\n                    this.syncSelectionMode();\n                return;\n            }\n            switch (this.selectionMode) {\n                case SelectionMode.Replace:\n                    if (!ev.isControlKey)\n                        this.processSelection(contents, SelectionProcessing.ReplaceSelectionWithElement); // eslint-disable-line @typescript-eslint/no-floating-promises\n                    else\n                        this.processSelection(contents, SelectionProcessing.InvertElementInSelection); // eslint-disable-line @typescript-eslint/no-floating-promises\n                    break;\n                case SelectionMode.Add:\n                    this.processSelection(contents, SelectionProcessing.AddElementToSelection); // eslint-disable-line @typescript-eslint/no-floating-promises\n                    break;\n                case SelectionMode.Remove:\n                    this.processSelection(contents, SelectionProcessing.RemoveElementFromSelection); // eslint-disable-line @typescript-eslint/no-floating-promises\n                    break;\n            }\n        }, true);\n    }\n    selectByPointsStart(ev) {\n        if (BeButton.Data !== ev.button && BeButton.Reset !== ev.button)\n            return false;\n        this._points.length = 0;\n        this._points.push(ev.point.clone());\n        this._isSelectByPoints = true;\n        IModelApp.accuSnap.enableLocate(false);\n        IModelApp.toolAdmin.setLocateCircleOn(false);\n        this.showPrompt(this.selectionMode, this.selectionMethod);\n        return true;\n    }\n    selectByPointsEnd(ev) {\n        if (!this._isSelectByPoints)\n            return false;\n        const vp = ev.viewport;\n        if (vp === undefined) {\n            this.initSelectTool();\n            return false;\n        }\n        const origin = vp.worldToView(this._points[0]);\n        const corner = vp.worldToView(ev.point);\n        if (SelectionMethod.Line === this.selectionMethod || (SelectionMethod.Pick === this.selectionMethod && BeButton.Reset === ev.button))\n            this.selectByPointsProcess(origin, corner, ev, SelectionMethod.Line, true);\n        else\n            this.selectByPointsProcess(origin, corner, ev, SelectionMethod.Box, this.useOverlapSelection(ev));\n        this.initSelectTool();\n        vp.invalidateDecorations();\n        return true;\n    }\n    async onMouseMotion(ev) {\n        if (undefined !== ev.viewport && this._isSelectByPoints)\n            ev.viewport.invalidateDecorations();\n    }\n    async selectDecoration(ev, currHit) {\n        if (undefined === currHit)\n            currHit = await IModelApp.locateManager.doLocate(new LocateResponse(), true, ev.point, ev.viewport, ev.inputSource);\n        if (undefined !== currHit)\n            return (currHit.isElementHit ? IModelApp.viewManager.overrideElementButtonEvent(currHit, ev) : IModelApp.viewManager.onDecorationButtonEvent(currHit, ev));\n        return EventHandled.No;\n    }\n    async onMouseStartDrag(ev) {\n        IModelApp.accuSnap.clear(); // Need to test hit at start drag location, not current AccuSnap...\n        if (EventHandled.Yes === await this.selectDecoration(ev))\n            return EventHandled.Yes;\n        if (InputSource.Touch === ev.inputSource && SelectionMethod.Pick === this.selectionMethod)\n            return EventHandled.No; // Require method change for line/box selection...allow IdleTool to handle touch move...\n        return this.selectByPointsStart(ev) ? EventHandled.Yes : EventHandled.No;\n    }\n    async onMouseEndDrag(ev) {\n        return this.selectByPointsEnd(ev) ? EventHandled.Yes : EventHandled.No;\n    }\n    async onDataButtonUp(ev) {\n        if (undefined === ev.viewport)\n            return EventHandled.No;\n        if (this.selectByPointsEnd(ev))\n            return EventHandled.Yes;\n        if (SelectionMethod.Pick !== this.selectionMethod) {\n            if (!ev.isControlKey && this.wantSelectionClearOnMiss(ev) && this.processMiss(ev))\n                this.syncSelectionMode();\n            if (InputSource.Touch !== ev.inputSource)\n                this.selectByPointsStart(ev); // Require touch move and not tap to start crossing line/box selection...\n            return EventHandled.Yes;\n        }\n        const hit = await IModelApp.locateManager.doLocate(new LocateResponse(), true, ev.point, ev.viewport, ev.inputSource);\n        if (hit !== undefined && !hit.isModelHit && !hit.isMapHit) { // model hit = terrain, reality models, background maps, etc - not selectable\n            if (EventHandled.Yes === await this.selectDecoration(ev, hit))\n                return EventHandled.Yes;\n            switch (this.selectionMode) {\n                case SelectionMode.Replace:\n                    await this.processSelection(hit.sourceId, ev.isControlKey ? SelectionProcessing.InvertElementInSelection : SelectionProcessing.ReplaceSelectionWithElement);\n                    break;\n                case SelectionMode.Add:\n                    await this.processSelection(hit.sourceId, SelectionProcessing.AddElementToSelection);\n                    break;\n                case SelectionMode.Remove:\n                    await this.processSelection(hit.sourceId, SelectionProcessing.RemoveElementFromSelection);\n                    break;\n            }\n            return EventHandled.Yes;\n        }\n        if (!ev.isControlKey && this.wantSelectionClearOnMiss(ev) && this.processMiss(ev))\n            this.syncSelectionMode();\n        return EventHandled.Yes;\n    }\n    async onResetButtonUp(ev) {\n        if (this._isSelectByPoints) {\n            if (undefined !== ev.viewport)\n                ev.viewport.invalidateDecorations();\n            this.initSelectTool();\n            return EventHandled.Yes;\n        }\n        // Check for overlapping hits...\n        const lastHit = SelectionMode.Remove === this.selectionMode ? undefined : IModelApp.locateManager.currHit;\n        if (lastHit && this.iModel.selectionSet.has(lastHit.sourceId)) {\n            const autoHit = IModelApp.accuSnap.currHit;\n            // Play nice w/auto-locate, only remove previous hit if not currently auto-locating or over previous hit\n            if (undefined === autoHit || autoHit.isSameHit(lastHit)) {\n                const response = new LocateResponse();\n                let nextHit;\n                do {\n                    nextHit = await IModelApp.locateManager.doLocate(response, false, ev.point, ev.viewport, ev.inputSource);\n                } while (undefined !== nextHit && (nextHit.isModelHit || nextHit.isMapHit)); // Ignore reality models, terrain, maps, etc.\n                // remove element(s) previously selected if in replace mode, or if we have a next element in add mode\n                if (SelectionMode.Replace === this.selectionMode || undefined !== nextHit)\n                    await this.processSelection(lastHit.sourceId, SelectionProcessing.RemoveElementFromSelection);\n                // add element(s) located via reset button\n                if (undefined !== nextHit)\n                    await this.processSelection(nextHit.sourceId, SelectionProcessing.AddElementToSelection);\n                return EventHandled.Yes;\n            }\n        }\n        if (EventHandled.Yes === await this.selectDecoration(ev, IModelApp.accuSnap.currHit))\n            return EventHandled.Yes;\n        await IModelApp.accuSnap.resetButton();\n        return EventHandled.Yes;\n    }\n    async onSuspend() {\n        this._isSuspended = true;\n        if (this.wantEditManipulators())\n            IModelApp.toolAdmin.manipulatorToolEvent.raiseEvent(this, ManipulatorToolEvent.Suspend);\n    }\n    async onUnsuspend() {\n        this._isSuspended = false;\n        if (this.wantEditManipulators())\n            IModelApp.toolAdmin.manipulatorToolEvent.raiseEvent(this, ManipulatorToolEvent.Unsuspend);\n        this.showPrompt(this.selectionMode, this.selectionMethod);\n    }\n    async onTouchMoveStart(ev, startEv) {\n        if (startEv.isSingleTouch && !this._isSelectByPoints)\n            await IModelApp.toolAdmin.convertTouchMoveStartToButtonDownAndMotion(startEv, ev);\n        return (this._isSuspended || this._isSelectByPoints) ? EventHandled.Yes : EventHandled.No;\n    }\n    async onTouchMove(ev) {\n        if (this._isSelectByPoints)\n            return IModelApp.toolAdmin.convertTouchMoveToMotion(ev);\n    }\n    async onTouchComplete(ev) {\n        if (this._isSelectByPoints)\n            return IModelApp.toolAdmin.convertTouchEndToButtonUp(ev);\n    }\n    async onTouchCancel(ev) {\n        if (this._isSelectByPoints)\n            return IModelApp.toolAdmin.convertTouchEndToButtonUp(ev, BeButton.Reset);\n    }\n    decorate(context) { this.selectByPointsDecorate(context); }\n    async onModifierKeyTransition(_wentDown, modifier, _event) {\n        return (modifier === BeModifierKeys.Shift && this._isSelectByPoints) ? EventHandled.Yes : EventHandled.No;\n    }\n    async filterHit(hit, out) {\n        if (!this.wantPickableDecorations() && !hit.isElementHit)\n            return LocateFilterStatus.Reject;\n        const mode = this.selectionMode;\n        if (SelectionMode.Replace === mode)\n            return LocateFilterStatus.Accept;\n        const isSelected = this.iModel.selectionSet.has(hit.sourceId);\n        const status = ((SelectionMode.Add === mode ? !isSelected : isSelected) ? LocateFilterStatus.Accept : LocateFilterStatus.Reject);\n        if (out && LocateFilterStatus.Reject === status)\n            out.explanation = CoreTools.translate(`ElementSet.Error.${isSelected ? \"AlreadySelected\" : \"NotSelected\"}`);\n        return status;\n    }\n    async onRestartTool() { return this.exitTool(); }\n    async onCleanup() {\n        if (this.wantEditManipulators())\n            IModelApp.toolAdmin.manipulatorToolEvent.raiseEvent(this, ManipulatorToolEvent.Stop);\n    }\n    async onPostInstall() {\n        await super.onPostInstall();\n        if (!this.targetView)\n            return;\n        if (this.wantEditManipulators())\n            IModelApp.toolAdmin.manipulatorToolEvent.raiseEvent(this, ManipulatorToolEvent.Start);\n        this.initSelectTool();\n    }\n    static async startTool() { return new SelectionTool().run(); }\n    syncSelectionMode() {\n        if (SelectionMode.Remove === this.selectionMode && !this.iModel.selectionSet.isActive) {\n            // No selection active resetting selection mode since there is nothing to Remove\n            this.selectionMode = SelectionMode.Replace;\n            this.initSelectTool();\n        }\n        if (this.wantToolSettings()) {\n            const syncMode = { value: this._selectionModeValue, propertyName: SelectionTool._modesName };\n            IModelApp.toolAdmin.toolSettingsState.saveToolSettingProperty(this.toolId, syncMode);\n            this.syncToolSettingsProperties([syncMode]);\n        }\n    }\n    /** Used to supply DefaultToolSettingProvider with a list of properties to use to generate ToolSettings.  If undefined then no ToolSettings will be displayed\n     * @beta\n     */\n    supplyToolSettingsProperties() {\n        if (!this.wantToolSettings())\n            return undefined;\n        // load latest values from session\n        IModelApp.toolAdmin.toolSettingsState.getInitialToolSettingValues(this.toolId, [SelectionTool._modesName])?.forEach((value) => {\n            if (value.propertyName === SelectionTool._modesName)\n                this._selectionModeValue = value.value;\n        });\n        // Make sure a mode of SelectionMode.Remove is valid\n        if (SelectionMode.Remove === this.selectionMode && !this.iModel.selectionSet.isActive) {\n            this.selectionMode = SelectionMode.Replace;\n            IModelApp.toolAdmin.toolSettingsState.saveToolSettingProperty(this.toolId, { propertyName: SelectionTool._modesName, value: this._selectionModeValue });\n        }\n        const toolSettings = new Array();\n        // generate 3 columns - label will be placed in column 0 and button group editors in columns 1 and 2.\n        toolSettings.push({ value: this._selectionMethodValue, property: SelectionTool._getMethodsDescription(), editorPosition: { rowPriority: 0, columnIndex: 1 } });\n        toolSettings.push({ value: this._selectionModeValue, property: SelectionTool._getModesDescription(), editorPosition: { rowPriority: 0, columnIndex: 2 } });\n        return toolSettings;\n    }\n    /** Used to send changes from UI back to Tool\n     * @beta\n     */\n    async applyToolSettingPropertyChange(updatedValue) {\n        let changed = false;\n        if (updatedValue.propertyName === SelectionTool._methodsName) {\n            const saveWantManipulators = this.wantEditManipulators();\n            this._selectionMethodValue = updatedValue.value;\n            if (this._selectionMethodValue) {\n                const currWantManipulators = this.wantEditManipulators();\n                if (saveWantManipulators !== currWantManipulators)\n                    IModelApp.toolAdmin.manipulatorToolEvent.raiseEvent(this, currWantManipulators ? ManipulatorToolEvent.Start : ManipulatorToolEvent.Stop);\n                changed = true;\n            }\n        }\n        if (updatedValue.propertyName === SelectionTool._modesName) {\n            this._selectionModeValue = updatedValue.value;\n            if (this._selectionModeValue) {\n                if (this.wantToolSettings())\n                    IModelApp.toolAdmin.toolSettingsState.saveToolSettingProperty(this.toolId, { propertyName: SelectionTool._modesName, value: this._selectionModeValue });\n                changed = true;\n            }\n        }\n        if (changed)\n            this.initSelectTool();\n        return true; // return true if change is valid\n    }\n}\nSelectionTool.hidden = false;\nSelectionTool.toolId = \"Select\";\nSelectionTool.iconSpec = \"icon-cursor\";\nSelectionTool._methodsName = \"selectionMethods\";\nSelectionTool._modesName = \"selectionModes\";\nexport { SelectionTool };\n//# sourceMappingURL=SelectTool.js.map",
      "start": 1693508120028,
      "end": 1693508120347,
      "sourcemaps": null
    }
  ]
}
