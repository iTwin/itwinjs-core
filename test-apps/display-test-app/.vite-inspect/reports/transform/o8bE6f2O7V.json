{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/FrustumUniforms.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { InverseMatrixState, Matrix4d, Point3d, Transform, Vector3d } from \"@itwin/core-geometry\";\nimport { Frustum, Npc } from \"@itwin/core-common\";\nimport { IModelFrameLifecycle } from \"./IModelFrameLifecycle\";\nimport { Matrix4 } from \"./Matrix\";\nimport { desync, sync } from \"./Sync\";\n/** Represents a Target's frustum for use in glsl as a pair of uniforms.\n * Do not modify fields of exposed objects directly. e.g., do not directly manipulate the projection or view matrices - use the appropriate APIs.\n * @internal\n */\nexport class FrustumUniforms {\n    constructor() {\n        // CPU state. Do not modify - use APIs.\n        this.planFrustum = new Frustum();\n        this._planFraction = 0;\n        this._nearPlaneCenter = new Point3d();\n        this.viewMatrix = Transform.createIdentity();\n        this.projectionMatrix = Matrix4d.createIdentity();\n        this._worldUpVector = Vector3d.unitZ();\n        this._viewUpVector = Vector3d.unitZ();\n        // GPU state\n        this._planeData = new Float32Array(4);\n        this._frustumData = new Float32Array(3);\n        this.projectionMatrix32 = new Matrix4();\n        this._logZData = new Float32Array(2);\n        this._viewUpVector32 = new Float32Array(3);\n        // SyncTarget\n        this.syncKey = 0;\n        // Scratch variables\n        this._scratch = {\n            point3d: new Point3d(),\n            vec3d: new Vector3d(),\n            viewX: new Vector3d(),\n            viewY: new Vector3d(),\n            viewZ: new Vector3d(),\n        };\n    }\n    bindProjectionMatrix(uniform) {\n        if (!sync(this, uniform))\n            uniform.setMatrix4(this.projectionMatrix32);\n    }\n    bindUpVector(uniform) {\n        if (!sync(this, uniform))\n            uniform.setUniform3fv(this._viewUpVector32);\n    }\n    // uniform vec4 u_frustumPlanes; // { top, bottom, left, right }\n    get planes() { return this._planeData; }\n    // uniform vec3 u_frustum; // { near, far, type }\n    get frustum() { return this._frustumData; }\n    get nearPlane() { return this._frustumData[0 /* FrustumData.kNear */]; }\n    get farPlane() { return this._frustumData[1 /* FrustumData.kFar */]; }\n    get type() { return this.frustum[2 /* FrustumData.kType */]; }\n    get is2d() { return 0 /* FrustumUniformType.TwoDee */ === this.type; }\n    get planFraction() { return this._planFraction; }\n    // uniform vec2 u_logZ where x = 1/near and y = log(far/near)\n    get logZ() { return this._logZData; }\n    changeFrustum(newFrustum, newFraction, is3d) {\n        if (newFraction === this._planFraction && is3d !== this.is2d && newFrustum.equals(this.planFrustum))\n            return;\n        desync(this);\n        newFrustum.clone(this.planFrustum);\n        const farLowerLeft = newFrustum.getCorner(Npc.LeftBottomRear);\n        const farLowerRight = newFrustum.getCorner(Npc.RightBottomRear);\n        const farUpperLeft = newFrustum.getCorner(Npc.LeftTopRear);\n        const farUpperRight = newFrustum.getCorner(Npc.RightTopRear);\n        const nearLowerLeft = newFrustum.getCorner(Npc.LeftBottomFront);\n        const nearLowerRight = newFrustum.getCorner(Npc.RightBottomFront);\n        const nearUpperLeft = newFrustum.getCorner(Npc.LeftTopFront);\n        const nearUpperRight = newFrustum.getCorner(Npc.RightTopFront);\n        const nearCenter = nearLowerLeft.interpolate(0.5, nearUpperRight, this._scratch.point3d);\n        const viewX = normalizedDifference(nearLowerRight, nearLowerLeft, this._scratch.viewX);\n        const viewY = normalizedDifference(nearUpperLeft, nearLowerLeft, this._scratch.viewY);\n        const viewZ = viewX.crossProduct(viewY, this._scratch.viewZ).normalize();\n        this._planFraction = newFraction;\n        if (!is3d || newFraction > 0.999) { // ortho or 2d\n            const halfWidth = Vector3d.createStartEnd(farLowerRight, farLowerLeft, this._scratch.vec3d).magnitude() * 0.5;\n            const halfHeight = Vector3d.createStartEnd(farLowerRight, farUpperRight).magnitude() * 0.5;\n            const depth = Vector3d.createStartEnd(farLowerLeft, nearLowerLeft, this._scratch.vec3d).magnitude();\n            lookIn(nearCenter, viewX, viewY, viewZ, this.viewMatrix);\n            ortho(-halfWidth, halfWidth, -halfHeight, halfHeight, 0, depth, this.projectionMatrix);\n            this._nearPlaneCenter.setFrom(nearLowerLeft);\n            this._nearPlaneCenter.interpolate(0.5, nearUpperRight, this._nearPlaneCenter);\n            this.setPlanes(halfHeight, -halfHeight, -halfWidth, halfWidth);\n            this.setFrustum(0, depth, is3d ? 1 /* FrustumUniformType.Orthographic */ : 0 /* FrustumUniformType.TwoDee */);\n        }\n        else { // perspective\n            const scale = 1.0 / (1.0 - newFraction);\n            const zVec = Vector3d.createStartEnd(farLowerLeft, nearLowerLeft, this._scratch.vec3d);\n            const cameraPosition = fromSumOf(farLowerLeft, zVec, scale, this._scratch.point3d);\n            const frustumLeft = dotDifference(farLowerLeft, cameraPosition, viewX) * newFraction;\n            const frustumRight = dotDifference(farLowerRight, cameraPosition, viewX) * newFraction;\n            const frustumBottom = dotDifference(farLowerLeft, cameraPosition, viewY) * newFraction;\n            const frustumTop = dotDifference(farUpperLeft, cameraPosition, viewY) * newFraction;\n            const frustumFront = -dotDifference(nearLowerLeft, cameraPosition, viewZ);\n            const frustumBack = -dotDifference(farLowerLeft, cameraPosition, viewZ);\n            lookIn(cameraPosition, viewX, viewY, viewZ, this.viewMatrix);\n            frustum(frustumLeft, frustumRight, frustumBottom, frustumTop, frustumFront, frustumBack, this.projectionMatrix);\n            IModelFrameLifecycle.onChangeCameraView.raiseEvent({\n                cameraPosition,\n                viewX,\n                viewY,\n                viewZ,\n            });\n            IModelFrameLifecycle.onChangeCameraFrustum.raiseEvent({\n                type: 2 /* FrustumUniformType.Perspective */,\n                left: frustumLeft,\n                right: frustumRight,\n                bottom: frustumBottom,\n                top: frustumTop,\n                front: frustumFront,\n                back: frustumBack,\n            });\n            this._nearPlaneCenter.setFrom(nearLowerLeft);\n            this._nearPlaneCenter.interpolate(0.5, nearUpperRight, this._nearPlaneCenter);\n            this.setPlanes(frustumTop, frustumBottom, frustumLeft, frustumRight);\n            this.setFrustum(frustumFront, frustumBack, 2 /* FrustumUniformType.Perspective */);\n        }\n        this.viewMatrix.matrix.inverseState = InverseMatrixState.unknown;\n        this.viewMatrix.matrix.multiplyVector(this._worldUpVector, this._viewUpVector);\n        this._viewUpVector.normalizeInPlace();\n        this._viewUpVector32[0] = this._viewUpVector.x;\n        this._viewUpVector32[1] = this._viewUpVector.y;\n        this._viewUpVector32[2] = this._viewUpVector.z;\n        this.projectionMatrix32.initFromMatrix4d(this.projectionMatrix);\n    }\n    changeProjectionMatrix(newMatrix) {\n        desync(this);\n        this.projectionMatrix.setFrom(newMatrix);\n        this.projectionMatrix32.initFromMatrix4d(this.projectionMatrix);\n    }\n    setPlanes(top, bottom, left, right) {\n        this._planeData[0 /* Plane.kTop */] = top;\n        this._planeData[1 /* Plane.kBottom */] = bottom;\n        this._planeData[2 /* Plane.kLeft */] = left;\n        this._planeData[3 /* Plane.kRight */] = right;\n    }\n    setFrustum(nearPlane, farPlane, type) {\n        this._frustumData[0 /* FrustumData.kNear */] = nearPlane;\n        this._frustumData[1 /* FrustumData.kFar */] = farPlane;\n        this._frustumData[2 /* FrustumData.kType */] = type;\n        // If nearPlane is zero, we don't have a camera (or got very unlucky); in that case shader will compute linear depth.\n        this._logZData[0] = 0 !== nearPlane ? 1 / nearPlane : 0;\n        this._logZData[1] = 0 !== nearPlane ? Math.log(farPlane / nearPlane) : farPlane;\n    }\n}\nfunction normalizedDifference(p0, p1, out) {\n    const result = undefined !== out ? out : new Vector3d();\n    result.x = p0.x - p1.x;\n    result.y = p0.y - p1.y;\n    result.z = p0.z - p1.z;\n    result.normalizeInPlace();\n    return result;\n}\n/** @internal */\nexport function fromSumOf(p, v, scale, out) {\n    const result = undefined !== out ? out : new Point3d();\n    result.x = p.x + v.x * scale;\n    result.y = p.y + v.y * scale;\n    result.z = p.z + v.z * scale;\n    return result;\n}\nfunction dotDifference(pt, origin, vec) {\n    return (pt.x - origin.x) * vec.x + (pt.y - origin.y) * vec.y + (pt.z - origin.z) * vec.z;\n}\nfunction lookIn(eye, viewX, viewY, viewZ, result) {\n    const rot = result.matrix.coffs;\n    rot[0] = viewX.x;\n    rot[1] = viewX.y;\n    rot[2] = viewX.z;\n    rot[3] = viewY.x;\n    rot[4] = viewY.y;\n    rot[5] = viewY.z;\n    rot[6] = viewZ.x;\n    rot[7] = viewZ.y;\n    rot[8] = viewZ.z;\n    result.origin.x = -viewX.dotProduct(eye);\n    result.origin.y = -viewY.dotProduct(eye);\n    result.origin.z = -viewZ.dotProduct(eye);\n}\nfunction ortho(left, right, bottom, top, near, far, result) {\n    Matrix4d.createRowValues(2.0 / (right - left), 0.0, 0.0, -(right + left) / (right - left), 0.0, 2.0 / (top - bottom), 0.0, -(top + bottom) / (top - bottom), 0.0, 0.0, -2.0 / (far - near), -(far + near) / (far - near), 0.0, 0.0, 0.0, 1.0, result);\n}\nfunction frustum(left, right, bottom, top, near, far, result) {\n    Matrix4d.createRowValues((2.0 * near) / (right - left), 0.0, (right + left) / (right - left), 0.0, 0.0, (2.0 * near) / (top - bottom), (top + bottom) / (top - bottom), 0.0, 0.0, 0.0, -(far + near) / (far - near), -(2.0 * far * near) / (far - near), 0.0, 0.0, -1.0, 0.0, result);\n}\n//# sourceMappingURL=FrustumUniforms.js.map",
      "start": 1693508124684,
      "end": 1693508124758,
      "sourcemaps": null
    }
  ]
}
