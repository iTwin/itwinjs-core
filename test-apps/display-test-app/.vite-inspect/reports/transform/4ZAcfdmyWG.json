{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/polyface/IndexedPolyfaceVisitor.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Polyface\n */\nimport { Geometry } from \"../Geometry\";\nimport { PolyfaceData } from \"./PolyfaceData\";\n/* eslint-disable @itwin/prefer-get */\n/**\n * An `IndexedPolyfaceVisitor` is an iterator-like object that \"visits\" facets of a mesh.\n * * The visitor extends a `PolyfaceData ` class, so it can at any time hold all the data of a single facet.\n * @public\n */\nexport class IndexedPolyfaceVisitor extends PolyfaceData {\n    // to be called from static factory method that validates the polyface ...\n    constructor(facets, numWrap) {\n        super(facets.data.normalCount > 0, facets.data.paramCount > 0, facets.data.colorCount > 0, facets.twoSided);\n        this._polyface = facets;\n        this._numWrap = numWrap;\n        if (facets.data.auxData)\n            this.auxData = facets.data.auxData.createForVisitor();\n        this.reset();\n        this._numEdges = 0;\n        this._nextFacetIndex = 0;\n        this._currentFacetIndex = -1;\n    }\n    /** Return the client polyface object. */\n    clientPolyface() { return this._polyface; }\n    /** Set the number of vertices duplicated (e.g. 1 for start and end) in arrays in the visitor. */\n    setNumWrap(numWrap) { this._numWrap = numWrap; }\n    /** Return the number of edges in the current facet.\n     * * Note that if this visitor has `numWrap` greater than zero, the number of edges is smaller than the number of points.\n     */\n    get numEdgesThisFacet() { return this._numEdges; }\n    /** Create a visitor for iterating the facets of `polyface`, with indicated number of points to be added to each facet to produce closed point arrays\n     * Typical wrap counts are:\n     * * 0 -- leave the point arrays with \"missing final edge\"\n     * * 1 -- add point 0 as closure point\n     * * 2 -- add points 0 and 1 as closure and wrap point.  This is useful when vertex visit requires two adjacent vectors, e.g. for cross products.\n     */\n    static create(polyface, numWrap) {\n        return new IndexedPolyfaceVisitor(polyface, numWrap);\n    }\n    /** Advance the iterator to a particular facet in the client polyface */\n    moveToReadIndex(facetIndex) {\n        if (!this._polyface.isValidFacetIndex(facetIndex))\n            return false;\n        this._currentFacetIndex = facetIndex;\n        this._nextFacetIndex = facetIndex + 1;\n        this._numEdges = this._polyface.numEdgeInFacet(facetIndex);\n        this.resizeAllDataArrays(this._numEdges + this._numWrap);\n        this.gatherIndexedData(this._polyface.data, this._polyface.facetIndex0(this._currentFacetIndex), this._polyface.facetIndex1(this._currentFacetIndex), this._numWrap);\n        return true;\n    }\n    /** Advance the iterator to a the 'next' facet in the client polyface */\n    moveToNextFacet() {\n        if (this._nextFacetIndex !== this._currentFacetIndex)\n            return this.moveToReadIndex(this._nextFacetIndex);\n        this._nextFacetIndex++;\n        return true;\n    }\n    /** Reset the iterator to start at the first facet of the polyface. */\n    reset() {\n        this.moveToReadIndex(0);\n        this._nextFacetIndex = 0; // so immediate moveToNextFacet stays here.\n    }\n    /**\n     * Attempts to extract the distance parameter for the given vertex index on the current facet\n     * Returns the distance parameter as a point. Returns undefined on failure.\n     */\n    tryGetDistanceParameter(index, result) {\n        if (index >= this.numEdgesThisFacet)\n            return undefined;\n        if (this.param === undefined || this._polyface.data.face.length === 0)\n            return undefined;\n        const faceData = this._polyface.tryGetFaceData(this._currentFacetIndex);\n        if (!faceData)\n            return undefined;\n        return faceData.convertParamXYToDistance(this.param.getXAtUncheckedPointIndex(index), this.param.getYAtUncheckedPointIndex(index), result);\n    }\n    /**\n     * Attempts to extract the normalized parameter (0,1) for the given vertex index on the current facet.\n     * Returns the normalized parameter as a point. Returns undefined on failure.\n     */\n    tryGetNormalizedParameter(index, result) {\n        if (index >= this.numEdgesThisFacet)\n            return undefined;\n        if (this.param === undefined || this._polyface.data.face.length === 0)\n            return undefined;\n        const faceData = this._polyface.tryGetFaceData(this._currentFacetIndex);\n        if (!faceData)\n            return undefined;\n        return faceData.convertParamXYToNormalized(this.param.getXAtUncheckedPointIndex(index), this.param.getYAtUncheckedPointIndex(index), result);\n    }\n    /** Return the index (in the client polyface) of the current facet */\n    currentReadIndex() { return this._currentFacetIndex; }\n    /** Return the point index of vertex i within the currently loaded facet */\n    clientPointIndex(i) { return this.pointIndex[i]; }\n    /** Return the param index of vertex i within the currently loaded facet */\n    clientParamIndex(i) { return this.paramIndex ? this.paramIndex[i] : -1; }\n    /** Return the normal index of vertex i within the currently loaded facet */\n    clientNormalIndex(i) { return this.normalIndex ? this.normalIndex[i] : -1; }\n    /** Return the color index of vertex i within the currently loaded facet */\n    clientColorIndex(i) { return this.colorIndex ? this.colorIndex[i] : -1; }\n    /** Return the aux data index of vertex i within the currently loaded facet */\n    clientAuxIndex(i) { return this.auxData ? this.auxData.indices[i] : -1; }\n    /** clear the contents of all arrays.  Use this along with transferDataFrom methods to build up new facets */\n    clearArrays() {\n        if (this.point !== undefined)\n            this.point.length = 0;\n        if (this.param !== undefined)\n            this.param.length = 0;\n        if (this.normal !== undefined)\n            this.normal.length = 0;\n        if (this.color !== undefined)\n            this.color.length = 0;\n    }\n    /** transfer data from a specified index of the other visitor as new data in this visitor. */\n    pushDataFrom(other, index) {\n        this.point.pushFromGrowableXYZArray(other.point, index);\n        if (this.color && other.color && index < other.color.length)\n            this.color.push(other.color[index]);\n        if (this.param && other.param && index < other.param.length)\n            this.param.pushFromGrowableXYArray(other.param, index);\n        if (this.normal && other.normal && index < other.normal.length)\n            this.normal.pushFromGrowableXYZArray(other.normal, index);\n    }\n    /** transfer interpolated data from the other visitor.\n     * * all data values are interpolated at `fraction` between `other` values at index0 and index1.\n     */\n    pushInterpolatedDataFrom(other, index0, fraction, index1) {\n        this.point.pushInterpolatedFromGrowableXYZArray(other.point, index0, fraction, index1);\n        if (this.color && other.color && index0 < other.color.length && index1 < other.color.length)\n            this.color.push(interpolateColor(other.color[index0], fraction, other.color[index1]));\n        if (this.param && other.param && index0 < other.param.length && index1 < other.param.length)\n            this.param.pushInterpolatedFromGrowableXYArray(other.param, index0, fraction, index1);\n        if (this.normal && other.normal && index0 < other.normal.length && index1 < other.normal.length)\n            this.normal.pushInterpolatedFromGrowableXYZArray(other.normal, index0, fraction, index1);\n    }\n}\n/**\n * * shift to right by shiftBits.\n * * mask off the low 8 bits\n * * interpolate the number\n * * truncate to floor\n * * shift left\n * * Hence all numbers in and out of the floating point are 0..255.\n * @param color0\n * @param fraction\n * @param color1\n * @param shiftBits\n */\nfunction interpolateByte(color0, fraction, color1, shiftBits) {\n    color0 = (color0 >>> shiftBits) & 0xFF;\n    color1 = (color1 >>> shiftBits) & 0xFF;\n    const color = Math.floor(color0 + fraction * (color1 - color0)) & 0xFF;\n    return color << shiftBits;\n}\n/**\n * Interpolate each byte of color0 and color1 as integers.\n * @param color0 32 bit color (e.g. rgb+transparency)\n * @param fraction fractional position.  This is clamped to 0..1 to prevent byte values outside their 0..255 range.\n * @param color1\n * @param shiftBits\n * @internal\n */\nexport function interpolateColor(color0, fraction, color1) {\n    // don't allow fractions outside the individual byte ranges.\n    fraction = Geometry.clamp(fraction, 0, 1);\n    // interpolate each byte in place ....\n    /*\n    const byte0 = interpolateLowByte(color0 & 0xFF, fraction, color1 & 0xFF);\n    const byte1 = interpolateLowByte((color0 & 0xFF00) >>> 8, fraction, (color1 & 0xFF00) >>> 8) << 8;\n    const byte2 = interpolateLowByte((color0 & 0xFF0000) >>> 16, fraction, (color1 & 0xFF0000) >>> 16) << 16;\n    const byte3 = interpolateLowByte((color0 & 0xFF000000) >>> 24, fraction, (color1 & 0xFF000000) >>> 24) << 24;\n    */\n    const byte0 = interpolateByte(color0, fraction, color1, 0);\n    const byte1 = interpolateByte(color0, fraction, color1, 8);\n    const byte2 = interpolateByte(color0, fraction, color1, 16);\n    const byte3 = interpolateByte(color0, fraction, color1, 24);\n    return (byte0 | byte1 | byte2 | byte3);\n}\n/**\n * An `IndexedPolyfaceSubsetVisitor` is an IndexedPolyfaceVisitor which only visits a subset of facets in the polyface.\n * * The subset is defined by an array of facet indices provided when this visitor is created.\n * * Within the subset visitor, \"facetIndex\" is understood as index within the subset array:\n *   * moveToNextFacet moves only within the subset\n *   * moveToReadIndex(i) moves underlying visitor's parentFacetIndex(i)\n * @public\n */\nexport class IndexedPolyfaceSubsetVisitor extends IndexedPolyfaceVisitor {\n    constructor(polyface, activeFacetIndices, numWrap) {\n        super(polyface, numWrap);\n        this._parentFacetIndices = activeFacetIndices.slice();\n        this._nextActiveIndex = 0;\n    }\n    /** Create a visitor for iterating a subset of the facets of `polyface`, with indicated number of points to be added to each facet to produce closed point arrays\n     * * Typical wrap counts are:\n     *   * 0 -- leave the point arrays with \"missing final edge\"\n     *   * 1 -- add point 0 as closure point\n     *   * 2 -- add points 0 and 1 as closure and wrap point.  This is useful when vertex visit requires two adjacent vectors, e.g. for cross products.\n     * * The activeFacetIndices array indicates all facets to be visited.\n     */\n    static createSubsetVisitor(polyface, activeFacetIndices, numWrap) {\n        return new IndexedPolyfaceSubsetVisitor(polyface, activeFacetIndices, numWrap);\n    }\n    /** Advance the iterator to a particular facet in the client polyface */\n    moveToReadIndex(activeIndex) {\n        if (activeIndex >= 0 && activeIndex <= this._parentFacetIndices.length) {\n            this._nextActiveIndex = activeIndex;\n            return super.moveToReadIndex(this._parentFacetIndices[activeIndex++]);\n        }\n        return false;\n    }\n    /** Advance the iterator to a the 'next' facet in the client polyface */\n    moveToNextFacet() {\n        if (this._nextActiveIndex < this._parentFacetIndices.length) {\n            const result = this.moveToReadIndex(this._nextActiveIndex);\n            if (result) {\n                this._nextActiveIndex++;\n                return true;\n            }\n        }\n        return false;\n    }\n    /** Reset the iterator to start at the first facet of the polyface. */\n    reset() {\n        this._nextActiveIndex = 0;\n    }\n    /** return the parent facet index of the indicated index within the active facets */\n    parentFacetIndex(activeIndex) {\n        if (activeIndex >= 0 && activeIndex <= this._nextActiveIndex) {\n            return this._parentFacetIndices[activeIndex];\n        }\n        return undefined;\n    }\n}\n//# sourceMappingURL=IndexedPolyfaceVisitor.js.map",
      "start": 1693508123911,
      "end": 1693508124071,
      "sourcemaps": null
    }
  ]
}
