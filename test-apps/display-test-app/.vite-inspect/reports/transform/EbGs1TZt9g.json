{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tile/LRUTileList.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tiles\n */\nimport { assert, ReadonlySortedArray, SortedArray } from \"@itwin/core-bentley\";\nimport { RenderMemory } from \"../render/RenderMemory\";\n/** Maintains in sorted order a set of [[TileUser]] Ids for which a given tile has been selected for display. The number of users in a set is expected to be very small - often only 1 for a typical application.\n * Strictly for use by LRUTileList.\n * @see TileUserIdSets.\n * @internal\n */\nexport class TileUserIdSet extends ReadonlySortedArray {\n    constructor(userId) {\n        super((lhs, rhs) => lhs - rhs);\n        if (undefined !== userId)\n            this._array.push(userId);\n    }\n    equals(set) {\n        if (this.length !== set.length)\n            return false;\n        for (let i = 0; i < this.length; i++)\n            if (this._array[i] !== set._array[i])\n                return false;\n        return true;\n    }\n    add(userId) {\n        this._insert(userId);\n    }\n    drop(userId) {\n        this._remove(userId);\n    }\n    clear() {\n        this._clear();\n    }\n    copyFrom(src) {\n        this._array.length = src.length;\n        let i = 0;\n        for (const userId of src)\n            this._array[i++] = userId;\n    }\n    clone() {\n        const clone = new TileUserIdSet();\n        clone.copyFrom(this);\n        return clone;\n    }\n}\n/** Maintains a set of TileUserIdSets such that each set represents a unique combination of TileUser ids and each set contains at least one TileUser id.\n * Exported strictly for tests.\n * @see LRUTileList.\n * @internal\n */\nexport class TileUserIdSets extends SortedArray {\n    constructor() {\n        super((lhs, rhs) => {\n            if (lhs === rhs)\n                return 0;\n            let diff = lhs.length - rhs.length;\n            if (0 !== diff)\n                return diff;\n            for (let i = 0; i < lhs.length; i++) {\n                const lhId = lhs.get(i);\n                const rhId = rhs.get(i);\n                diff = lhId - rhId;\n                if (0 !== diff)\n                    return diff;\n            }\n            return 0;\n        });\n        this._scratch = new TileUserIdSet();\n    }\n    /** Remove the specified TileUser Id from all sets and remove empty and duplicate sets. */\n    drop(userId) {\n        // Remove from all sets, and delete empty sets.\n        let i = 0;\n        for ( /* */; i < this._array.length; i++) {\n            const set = this._array[i];\n            set.drop(userId);\n            if (set.length === 0)\n                this._array.splice(i, 1);\n        }\n        // Collapse equivalent sets.\n        i = 0;\n        for (let j = 1; j < this._array.length; /* */) {\n            if (this._array[i].equals(this._array[j])) {\n                this._array.splice(i, 1);\n            }\n            else {\n                i++;\n                j++;\n            }\n        }\n    }\n    /** Obtain a TileUserIdSet owned by this object containing userId and (if specified) userIds. */\n    plus(userId, userIds) {\n        const scratch = this.scratch(userIds);\n        scratch.add(userId);\n        return this.getEquivalent(scratch);\n    }\n    /** Obtain a TileUserIdSet owned by this object containing all of userIds (if specified) but not userId. Returns undefined if the resultant set would be empty. */\n    minus(userId, userIds) {\n        const scratch = this.scratch(userIds);\n        scratch.drop(userId);\n        return scratch.length > 0 ? this.getEquivalent(scratch) : undefined;\n    }\n    scratch(userIds) {\n        const scratch = this._scratch;\n        if (userIds)\n            scratch.copyFrom(userIds);\n        else\n            scratch.clear();\n        return scratch;\n    }\n    getEquivalent(sought) {\n        assert(sought.length > 0);\n        for (const set of this)\n            if (set.equals(sought))\n                return set;\n        const newSet = sought.clone();\n        this.insert(newSet);\n        return newSet;\n    }\n}\nfunction isLinked(node) {\n    return undefined !== node.previous || undefined !== node.next;\n}\nfunction* lruListIterator(start, end) {\n    let cur = start;\n    while (cur && cur !== end) {\n        const prev = cur;\n        cur = cur.next;\n        yield prev;\n    }\n}\n/** An intrusive doubly-linked list of LRUTileListNodes, containing Tiles partitioned by a singleton sentinel node into two partitions and ordered from least-recently- to most-recently-used by any TileUser.\n * Used by TileAdmin to keep track of and impose limits upon the total amount of GPU memory allocated to tile content.\n *\n * Illustration of the structure of the list:\n *\n * ```\n * v------------- Not selected --------------v                                v----------------- Selected ------------------v\n *   ______               ______                           __________                           ______               ______\n *  | head |.next =>     |      |.next => ...             | sentinel |.next => ...             |      |.next =>     | tail |\n *  | 12kb |             |  8kb |                         |   0kb    |                         | 19kb |             | 23kb |\n *  |______| <= previous.|______|         ... <= previous.|__________|         ... <= previous.|______| <= previous.|______|\n *\n * least-recently-selected --> --> --> --> --> --> --> --> --> --> --> --> --> --> --> --> --> --> --> most-recently-selected\n * ```\n *\n * The sentinel node is always present and floats freely as the contents of each partition change. Note that the `next` and `previous` pointers are stored directly on the tiles - no link nodes are allocated to hold the entries in the list. This of course means that a Tile can only ever belong to one LRUTileList - the one owned by the TileAdmin.\n *\n * The list contains only those tiles whose content has been loaded. Each node records the amount of GPU memory allocated for the tile's content. The list keeps track of the total amount of GPU memory allocated by all tiles. The list's contents are updated as follows:\n *\n * - When a tile's content is loaded, it is added to the end of the \"not selected\" partition. Its memory usage is computed and added to the list's total.\n * - When a tile's content is unloaded, it is removed from the list. Its memory usage is deducted from the list's totla.\n * - Just before a TileUser selects tiles for use (e.g., Viewport selects tiles for display), it is removed from each tile's set of viewports in which they are selected. If a tile's set of users becomes empty as a result, it is moved to the end of the \"not selected\" partition.\n * - When a tile becomes selected for use by a TileUser, the user is added to its user set and the tile is moved to the end of the \"selected\" partition.\n *\n * When the system determines that GPU memory should be freed up, it can simply pop nodes off the beginning of the \"not selected\" partition, freeing their content, until the target memory usage is reached or no more non-selected nodes exist.\n *\n * Strictly for use by [[TileAdmin]].\n * @internal\n */\nexport class LRUTileList {\n    /** The amount of GPU memory, in bytes, allocated to all tiles in the list. */\n    get totalBytesUsed() {\n        return this._totalBytesUsed;\n    }\n    constructor() {\n        this._stats = new RenderMemory.Statistics();\n        this._userIdSets = new TileUserIdSets();\n        this._totalBytesUsed = 0;\n        this._head = this._tail = this._sentinel = { bytesUsed: 0 };\n    }\n    dispose() {\n        let node = this._head;\n        let next;\n        while (node) {\n            next = node.next;\n            node.previous = node.next = undefined;\n            node.bytesUsed = 0;\n            node.tileUserIds = undefined;\n            node = next;\n        }\n        this._head = this._tail = this._sentinel;\n        this._totalBytesUsed = 0;\n        this._userIdSets.clear();\n    }\n    /** Compute the amount of GPU memory allocated to the tile's content and, if greater than zero, add the tile to the end of the \"not selected\" partition.\n     * Invoked by TileAdmin whenever a tile's content is set to a valid RenderGraphic.\n     */\n    add(tile) {\n        assert(!isLinked(tile));\n        if (isLinked(tile))\n            return;\n        assert(tile.bytesUsed === 0);\n        assert(tile.tileUserIds === undefined);\n        this._stats.clear();\n        tile.collectStatistics(this._stats, false);\n        tile.bytesUsed = this.computeBytesUsed(tile);\n        assert(tile.bytesUsed >= 0);\n        assert(tile.bytesUsed === Math.floor(tile.bytesUsed));\n        if (tile.bytesUsed <= 0)\n            return;\n        // Insert just before the sentinel, indicating this is the most-recently-used non-selected tile.\n        this._totalBytesUsed += tile.bytesUsed;\n        this.append(tile);\n        this.moveBeforeSentinel(tile);\n    }\n    /** Remove the tile from the list and deduct its previously-used GPU memory from the list's running total.\n     * Invoked by TileAdmin when a tile's content is unloaded, including when the list itself disposes of the content in its `freeMemory` method.\n     */\n    drop(tile) {\n        assert(isLinked(tile) || tile.bytesUsed === 0);\n        if (!isLinked(tile))\n            return;\n        assert(tile.bytesUsed > 0);\n        this._totalBytesUsed -= tile.bytesUsed;\n        assert(this._totalBytesUsed >= 0);\n        this.unlink(tile);\n        tile.tileUserIds = undefined;\n        tile.bytesUsed = 0;\n        this.assertList();\n    }\n    /** Mark the tiles as in use by the specified TileUser. They are moved to the end of the \"selected\" partition. */\n    markUsed(userId, tiles) {\n        for (const tile of tiles) {\n            if (tile.bytesUsed <= 0)\n                continue;\n            assert(isLinked(tile));\n            if (isLinked(tile)) {\n                tile.tileUserIds = this._userIdSets.plus(userId, tile.tileUserIds);\n                this.moveToEnd(tile);\n            }\n        }\n    }\n    /** Mark the tiles as no longer in user by the specified TileUser.\n     * If this results in a tile being no longer selected for any user, it is moved to the end of the \"not selected\" partition.\n     */\n    clearUsed(userId) {\n        this._userIdSets.drop(userId);\n        let prev = this._sentinel;\n        while (prev && prev.next) {\n            const tile = prev.next;\n            assert(tile !== this._sentinel);\n            tile.tileUserIds = this._userIdSets.minus(userId, tile.tileUserIds);\n            if (undefined === tile.tileUserIds)\n                this.moveBeforeSentinel(tile);\n            else\n                prev = tile;\n        }\n    }\n    /** Dispose of the contents of tiles currently not selected for display until the total amount of memory consumed is no more than `maxBytes`\n     * or until the contents of all un-selected tiles have been disposed.\n     */\n    freeMemory(maxBytes) {\n        let prev = this._head;\n        while (prev && prev !== this._sentinel && this.totalBytesUsed > maxBytes) {\n            const tile = prev;\n            prev = tile.next;\n            tile.freeMemory();\n            // Some tiles (ImageryMapTile) use reference-counting, in which case freeMemory() may not actually free the contents.\n            // If the contents *were* disposed, then `this.drop` will have been called, and `tile` is no longer in the list.\n            // Otherwise, `tile` remains in the list. Either way, we proceed to the next entry in the list.\n            assert((this.computeBytesUsed(tile) > 0) === isLinked(tile));\n        }\n    }\n    /** Iterate over all of the tiles in the unselected partition. */\n    get unselectedTiles() {\n        const start = this._head === this._sentinel ? undefined : this._head;\n        return {\n            [Symbol.iterator]: () => lruListIterator(start, this._sentinel),\n        };\n    }\n    /** Iterate over all of the tiles in the selected partition. */\n    get selectedTiles() {\n        return {\n            [Symbol.iterator]: () => lruListIterator(this._sentinel.next, undefined),\n        };\n    }\n    computeBytesUsed(tile) {\n        this._stats.clear();\n        tile.collectStatistics(this._stats, false);\n        return this._stats.totalBytes;\n    }\n    assertList() {\n        assert(this._head !== undefined);\n        assert(this._tail !== undefined);\n    }\n    append(tile) {\n        assert(!isLinked(tile));\n        if (isLinked(tile))\n            this.unlink(tile);\n        this._tail.next = tile;\n        tile.previous = this._tail;\n        this._tail = tile;\n    }\n    unlink(tile) {\n        assert(isLinked(tile));\n        if (!isLinked(tile))\n            return;\n        if (tile.next && tile.previous) {\n            assert(tile !== this._head);\n            assert(tile !== this._tail);\n            assert(tile.previous.next === tile);\n            assert(tile.next.previous === tile);\n            tile.previous.next = tile.next;\n            tile.next.previous = tile.previous;\n        }\n        else if (tile.previous) {\n            assert(tile === this._tail);\n            assert(undefined === tile.next);\n            assert(tile.previous.next === tile);\n            tile.previous.next = undefined;\n            this._tail = tile.previous;\n        }\n        else {\n            assert(tile === this._head);\n            assert(undefined !== tile.next);\n            assert(tile.next.previous === tile);\n            tile.next.previous = undefined;\n            this._head = tile.next;\n        }\n        tile.next = tile.previous = undefined;\n        this.assertList();\n    }\n    moveToEnd(tile) {\n        this.unlink(tile);\n        this.append(tile);\n    }\n    moveBeforeSentinel(tile) {\n        this.unlink(tile);\n        tile.previous = this._sentinel.previous;\n        this._sentinel.previous = tile;\n        tile.next = this._sentinel;\n        if (!tile.previous)\n            this._head = tile;\n        else\n            tile.previous.next = tile;\n    }\n}\n//# sourceMappingURL=LRUTileList.js.map",
      "start": 1693508121434,
      "end": 1693508121690,
      "sourcemaps": null
    }
  ]
}
