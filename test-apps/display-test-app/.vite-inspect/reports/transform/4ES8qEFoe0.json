{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/bspline/BSplineSurface.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Bspline\n */\nimport { GeometryQuery } from \"../curve/GeometryQuery\";\nimport { AxisOrder, Geometry } from \"../Geometry\";\nimport { Matrix3d } from \"../geometry3d/Matrix3d\";\nimport { Plane3dByOriginAndVectors } from \"../geometry3d/Plane3dByOriginAndVectors\";\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\nimport { Point3dArray, Point4dArray } from \"../geometry3d/PointHelpers\";\nimport { Transform } from \"../geometry3d/Transform\";\nimport { Point4d } from \"../geometry4d/Point4d\";\nimport { BSplineWrapMode, KnotVector } from \"./KnotVector\";\n/**\n * UVSelect is an integer indicating uDirection (0) or vDirection (1) in a bspline surface parameterization.\n * @public\n */\nexport var UVSelect;\n(function (UVSelect) {\n    /** index of u direction */\n    UVSelect[UVSelect[\"uDirection\"] = 0] = \"uDirection\";\n    /** index of v direction */\n    UVSelect[UVSelect[\"VDirection\"] = 1] = \"VDirection\";\n})(UVSelect || (UVSelect = {}));\n/**\n * Enumeration of how weights are carried\n * * UnWeighted (0) -- there are no weights\n * * WeightsAlreadyAppliedToCoordinates (1) -- for real point (x,y,z) the homogeneous point has weight applied throughout as (wx,wy,wz,w)\n * * WeightsSeparateFromCoordinates (2) -- for real point (x,y,z) the homogeneous point is (x,y,z,w)\n *   * Note that \"internal\" computations never use WeightsSeparateFromCoordinates.\n *   * WeightsSeparateFromCoordinates is only useful as input or output state in serializer.\n * @public\n */\nexport var WeightStyle;\n(function (WeightStyle) {\n    /** There are no weights. */\n    WeightStyle[WeightStyle[\"UnWeighted\"] = 0] = \"UnWeighted\";\n    /**\n     * * Data is weighted\n     * * point with normalized coordinate `[x,y,z]` and weight `w` has weights already multiplied in as `[x*w,y*w,z*w,w]`\n     * */\n    WeightStyle[WeightStyle[\"WeightsAlreadyAppliedToCoordinates\"] = 1] = \"WeightsAlreadyAppliedToCoordinates\";\n    /**\n     * * Data is weighted\n     * * point with normalized coordinate `[x,y,z]` and weight `w` has is `[x,y,z,w]`\n     * */\n    WeightStyle[WeightStyle[\"WeightsSeparateFromCoordinates\"] = 2] = \"WeightsSeparateFromCoordinates\";\n})(WeightStyle || (WeightStyle = {}));\n/** Bspline knots and poles for 2d-to-Nd.\n * * This abstract class in not independently instantiable -- GeometryQuery methods must be implemented by derived classes.\n * @public\n */\nexport class BSpline2dNd extends GeometryQuery {\n    /** Return the degree (one less than order) for the `select` direction (0 or 1) */\n    degreeUV(select) { return this.knots[select].degree; }\n    /** Return the order (one more than degree) for the `select` direction (0 or 1) */\n    orderUV(select) { return this.knots[select].degree + 1; }\n    /** Return the number of spans (INCLUDING NULL SPANS) for the `select` direction (0 or 1) */\n    numSpanUV(select) { return this._numPoles[select] - this.knots[select].degree; }\n    /** Return the total number of poles (product of x and y pole counts) */\n    numPolesTotal() { return this.coffs.length / this.poleDimension; }\n    /** Return the number of poles for the `select` direction (0 or 1) */\n    numPolesUV(select) { return this._numPoles[select]; }\n    /** Return the step between adjacent poles for the `select` direction (0 or 1) */\n    poleStepUV(select) { return select === 0 ? 1 : this._numPoles[0]; }\n    /** Confirm that order and pole counts agree for both u and v directions */\n    static validOrderAndPoleCounts(orderU, numPolesU, orderV, numPolesV, numUV) {\n        if (orderU < 2 || numPolesU < orderU)\n            return false;\n        if (orderV < 2 || numPolesV < orderV)\n            return false;\n        if (numPolesU * numPolesV !== numUV)\n            return false;\n        return true;\n    }\n    /** Get the Point3d by row and column.\n     * * (IMPORTANT) This assumes this is an xyz surface.  Data will be incorrect if this is an xyzw surface.\n     */\n    getPoint3dPole(i, j, result) {\n        return Point3d.createFromPacked(this.coffs, i + j * this._numPoles[0], result);\n    }\n    /** Get the Point3d by row and column, projecting the weight away to get to xyz\n     * * (IMPORTANT) This assumes this is an xyzw surface.  Data will be incorrect if this is an xyz surface.\n     */\n    getPoint3dPoleXYZW(i, j, result) {\n        return Point3d.createFromPackedXYZW(this.coffs, i + j * this._numPoles[0], result);\n    }\n    /**\n     * Return 0 for 0 input, 1 for any nonzero input.\n     * @param value numeric value to convert to strict 0 or 1.\n     */\n    numberToUVSelect(value) { return value === 0 ? 0 : 1; }\n    /** extend a range, treating each block as simple XYZ */\n    extendRangeXYZ(rangeToExtend, transform) {\n        const buffer = this.coffs;\n        const pd = this.poleDimension;\n        const n = buffer.length + 1 - pd;\n        if (transform) {\n            for (let i0 = 0; i0 < n; i0 += pd)\n                rangeToExtend.extendTransformedXYZ(transform, buffer[i0], buffer[i0 + 1], buffer[i0 + 2]);\n        }\n        else {\n            for (let i0 = 0; i0 < n; i0 += pd)\n                rangeToExtend.extendXYZ(buffer[i0], buffer[i0 + 1], buffer[i0 + 2]);\n        }\n    }\n    /** extend a range, treating each block as homogeneous xyzw, with weight at offset 3 */\n    extendRangeXYZH(rangeToExtend, transform) {\n        const buffer = this.coffs;\n        const pd = this.poleDimension;\n        const n = buffer.length + 1 - pd;\n        let w = 0;\n        let divW = 0;\n        if (transform) {\n            for (let i0 = 0; i0 < n; i0 += pd) {\n                w = buffer[i0 + 3];\n                if (w !== 0.0) {\n                    divW = 1.0 / w;\n                    rangeToExtend.extendTransformedXYZ(transform, buffer[i0] * divW, buffer[i0 + 1] * divW, buffer[i0 + 2] * divW);\n                }\n            }\n        }\n        else {\n            for (let i0 = 0; i0 < n; i0 += pd) {\n                w = buffer[i0 + 3];\n                if (w !== 0.0) {\n                    divW = 1.0 / w;\n                    rangeToExtend.extendXYZ(buffer[i0] * divW, buffer[i0 + 1] * divW, buffer[i0 + 2] * divW);\n                }\n            }\n        }\n    }\n    /**\n     * evaluate the surface at u and v fractions. Return a (squared, right handed) coordinate frame at that point on the surface.\n     * @param fractionU u parameter\n     * @param fractionV v parameter\n     * @param result undefined if surface derivatives are parallel (or either alone is zero)\n     */\n    fractionToRigidFrame(fractionU, fractionV, result) {\n        const skewVectors = this.fractionToPointAndDerivatives(fractionU, fractionV);\n        if (!skewVectors)\n            return undefined;\n        const axes = Matrix3d.createColumnsInAxisOrder(AxisOrder.XYZ, skewVectors.vectorU, skewVectors.vectorV, undefined);\n        const axes1 = Matrix3d.createRigidFromMatrix3d(axes, AxisOrder.XYZ, axes);\n        if (axes1)\n            result = Transform.createOriginAndMatrix(skewVectors.origin, axes1, result);\n        return result;\n    }\n    /**\n     * initialize arrays for given spline dimensions.\n     * coffs length must be poleLength * numPolesU * numPolesV    !!!!\n     */\n    constructor(numPolesU, numPolesV, poleLength, knotsU, knotsV, coffs) {\n        super();\n        /** String name for schema properties */\n        this.geometryCategory = \"bsurf\";\n        const orderU = knotsU.degree + 1;\n        const orderV = knotsV.degree + 1;\n        this.knots = [knotsU, knotsV];\n        this.coffs = coffs;\n        this.poleDimension = poleLength;\n        this._basisBufferUV = [new Float64Array(orderU), new Float64Array(orderV)];\n        this._basisBuffer1UV = [new Float64Array(orderU), new Float64Array(orderV)];\n        this._numPoles = [numPolesU, numPolesV];\n        this._poleBuffer = new Float64Array(poleLength);\n        this._poleBuffer1UV = [new Float64Array(poleLength), new Float64Array(poleLength)];\n    }\n    /**\n     * Map a position, specified as (uv direction, bezier span, fraction within the bezier), to an overall knot value.\n     * @param select selector indicating U or V direction.\n     * @param span index of bezier span\n     * @param localFraction fractional coordinate within the bezier span\n     */\n    spanFractionToKnot(select, span, localFraction) {\n        return this.knots[select].spanFractionToKnot(span, localFraction);\n    }\n    /** Evaluate basis functions given\n     * * choice of u or v\n     * * span index\n     * * local fraction within the span.\n     */\n    spanFractionsToBasisFunctions(select, spanIndex, spanFraction, f, df) {\n        spanIndex = Geometry.clampToStartEnd(spanIndex, 0, this.numSpanUV(select));\n        const knotIndex0 = spanIndex + this.degreeUV(select) - 1;\n        const globalKnot = this.knots[select].baseKnotFractionToKnot(knotIndex0, spanFraction);\n        return df ?\n            this.knots[select].evaluateBasisFunctions1(knotIndex0, globalKnot, f, df) :\n            this.knots[select].evaluateBasisFunctions(knotIndex0, globalKnot, f);\n    }\n    /** sum poles by the weights in the basisBuffer, using poles for given span */\n    sumPoleBufferForSpan(spanIndexU, spanIndexV) {\n        const poleBuffer = this._poleBuffer;\n        const coffs = this.coffs;\n        poleBuffer.fill(0);\n        const m = this.poleDimension;\n        const stepV = this.poleDimension * this._numPoles[0];\n        let kU = m * spanIndexU + spanIndexV * stepV;\n        let g = 0;\n        for (const fV of this._basisBufferUV[1]) {\n            let k = kU;\n            for (const fU of this._basisBufferUV[0]) {\n                g = fU * fV;\n                for (let j = 0; j < m; j++) {\n                    poleBuffer[j] += g * coffs[k++];\n                }\n            }\n            kU += stepV;\n        }\n    }\n    // cSpell:word sumpole\n    /** sum derivatives by the weights in the basisBuffer, using poles for given span */\n    sumpoleBufferDerivativesForSpan(spanIndexU, spanIndexV) {\n        const poleBuffer1U = this._poleBuffer1UV[0];\n        const poleBuffer1V = this._poleBuffer1UV[1];\n        poleBuffer1U.fill(0);\n        poleBuffer1V.fill(0);\n        const m = this.poleDimension;\n        const stepV = this.poleDimension * this._numPoles[0];\n        let kU = m * spanIndexU + spanIndexV * stepV;\n        // U partial derivatives ...\n        let g = 0;\n        for (const fV of this._basisBufferUV[1]) {\n            let k = kU;\n            for (const fU of this._basisBuffer1UV[0]) {\n                g = fU * fV;\n                for (let j = 0; j < m; j++) {\n                    poleBuffer1U[j] += g * this.coffs[k++];\n                }\n            }\n            kU += stepV;\n        }\n        // V partial derivatives ...\n        kU = m * spanIndexU + spanIndexV * stepV;\n        for (const fV of this._basisBuffer1UV[1]) {\n            let k = kU;\n            for (const fU of this._basisBufferUV[0]) {\n                g = fU * fV;\n                for (let j = 0; j < m; j++) {\n                    poleBuffer1V[j] += g * this.coffs[k++];\n                }\n            }\n            kU += stepV;\n        }\n    }\n    /**\n     * Evaluate the _basisBuffer, _poleBuffer and (optionally) _basisBuffer1 and _poleBuffer1 arrays at given knot.\n     *\n     * @param u u knot value\n     * @param v v not value\n     * @param numDerivative number of derivatives needed\n     */\n    evaluateBuffersAtKnot(u, v, numDerivative = 0) {\n        const knotIndex0U = this.knots[0].knotToLeftKnotIndex(u);\n        const knotIndex0V = this.knots[1].knotToLeftKnotIndex(v);\n        const poleIndex0U = knotIndex0U - this.degreeUV(0) + 1;\n        const poleIndex0V = knotIndex0V - this.degreeUV(1) + 1;\n        if (numDerivative < 1) {\n            this.knots[0].evaluateBasisFunctions(knotIndex0U, u, this._basisBufferUV[0]);\n            this.knots[1].evaluateBasisFunctions(knotIndex0V, v, this._basisBufferUV[1]);\n            this.sumPoleBufferForSpan(poleIndex0U, poleIndex0V);\n        }\n        else {\n            this.knots[0].evaluateBasisFunctions1(knotIndex0U, u, this._basisBufferUV[0], this._basisBuffer1UV[0]);\n            this.knots[1].evaluateBasisFunctions1(knotIndex0V, v, this._basisBufferUV[1], this._basisBuffer1UV[1]);\n            this.sumPoleBufferForSpan(poleIndex0U, poleIndex0V);\n            this.sumpoleBufferDerivativesForSpan(poleIndex0U, poleIndex0V);\n        }\n    }\n    // Swap numSwap entries in coffs, starting at i0 and i1 (absolute indices -- not blocks)\n    swapBlocks(i0, i1, numSwap) {\n        let a;\n        for (let i = 0; i < numSwap; i++) {\n            a = this.coffs[i0 + i];\n            this.coffs[i0 + i] = this.coffs[i1 + i];\n            this.coffs[i1 + i] = a;\n        }\n    }\n    /**\n     * Reverse the parameter direction for either u or v.\n     * @param select direction to reverse -- 0 for u, 1 for v.\n     */\n    reverseInPlace(select) {\n        const m = this.poleDimension;\n        const numU = this.numPolesUV(0);\n        const numV = this.numPolesUV(1);\n        if (select === 0) {\n            // reverse within rows.\n            for (let j = 0; j < numV; j++) {\n                const rowStart = j * numU * m;\n                for (let i0 = 0, i1 = numU - 1; i0 < i1; i0++, i1--) {\n                    this.swapBlocks(rowStart + i0 * m, rowStart + i1 * m, m);\n                }\n            }\n        }\n        else {\n            // swap full rows ..\n            const numPerRow = m * numU;\n            for (let i0 = 0, i1 = (numV - 1) * numPerRow; i0 < i1; i0 += numPerRow, i1 -= numPerRow) {\n                this.swapBlocks(i0, i1, numPerRow);\n            }\n        }\n        this.knots[select].reflectKnots();\n    }\n    /**\n     * Set the flag indicating the bspline might be suitable for having wrapped \"closed\" interpretation.\n     */\n    setWrappable(select, value) {\n        this.knots[select].wrappable = value;\n    }\n    /**\n     * Test if `degree` leading and trailing (one of U or V) blocks match, as if the data is an unwrapped closed spline in the selected direction.\n     * @param select select U or V direction\n     * @returns true if coordinates matched.\n     */\n    isClosable(select) {\n        if (this.knots[select].wrappable === BSplineWrapMode.None)\n            return false;\n        if (!this.knots[select].testClosable())\n            return false;\n        const numU = this.numPolesUV(0);\n        const numV = this.numPolesUV(1);\n        const blockSize = this.poleDimension;\n        const rowToRowStep = numU * blockSize;\n        const degreeU = this.degreeUV(0);\n        const degreeV = this.degreeUV(1);\n        const data = this.coffs;\n        if (select === 0) {\n            const numTest = blockSize * degreeU; // degreeU contiguous poles.\n            for (let row = 0; row < numV; row++) {\n                const i0 = row * rowToRowStep;\n                const i1 = i0 + rowToRowStep - numTest;\n                for (let i = 0; i < numTest; i++) {\n                    if (!Geometry.isSameCoordinate(data[i0 + i], data[i1 + i]))\n                        return false;\n                }\n            }\n        }\n        else {\n            // Test the entire multi-row contiguous block in one loop . ..\n            const numTest = degreeV * rowToRowStep;\n            const i1 = blockSize * numU * numV - numTest;\n            for (let i = 0; i < numTest; i++) {\n                if (!Geometry.isSameCoordinate(data[i], data[i1 + i]))\n                    return false;\n            }\n        }\n        return true;\n    }\n}\n/**  BSplineSurface3d is a parametric surface in xyz space.\n * * This (BSplineSurface3d) is an unweighted surface.   Use the separate class BSplineSurface3dH for a weighted surface.\n *\n * The various static \"create\" methods have subtle differences in how grid sizes are conveyed:\n * | Method | control point array | counts |\n * | create | flat array of [x,y,z] | arguments numPolesU, numPolesV |\n * | createGrid | array of array of [x,y,z ] | There are no `numPolesU` or `numPolesV` args. The counts are conveyed by the deep arrays |\n * @public\n */\nexport class BSplineSurface3d extends BSpline2dNd {\n    /** Test if `other` is an instance of `BSplineSurface3d */\n    isSameGeometryClass(other) { return other instanceof BSplineSurface3d; }\n    /** Apply the transform to the poles */\n    tryTransformInPlace(transform) { Point3dArray.multiplyInPlace(transform, this.coffs); return true; }\n    /** Return a pole by u and v indices */\n    getPole(i, j, result) {\n        return this.getPoint3dPole(i, j, result);\n    }\n    constructor(numPolesU, numPolesV, knotsU, knotsV, coffs) {\n        super(numPolesU, numPolesV, 3, knotsU, knotsV, coffs);\n    }\n    /**\n     * Return control points json arrays.\n     * * if `flatArray===true`, each point appears as an array [x,y,z] in row-major order of a containing array.\n     * * if `flatArray===false` each row of points is an an array of [x,y,z] in an array.  Each of these row arrays is in the result array.\n     */\n    getPointArray(flatArray = true) {\n        if (flatArray)\n            return Point3dArray.unpackNumbersToNestedArrays(this.coffs, 3);\n        return Point3dArray.unpackNumbersToNestedArraysIJK(this.coffs, 3, this.numPolesUV(0));\n    }\n    /**\n     * Return control points json arrays.\n     * * Each row of points is an an array.\n     * * Within the array for each row, each point is an array [x,y,z]\n     */\n    getPointGridJSON() {\n        const result = {\n            points: Point3dArray.unpackNumbersToNestedArraysIJK(this.coffs, 3, this.numPolesUV(0)),\n            weighStyle: WeightStyle.UnWeighted,\n            numCartesianDimensions: 3,\n        };\n        return result;\n    }\n    /** Return a simple array of the control points coordinates */\n    copyPointsFloat64Array() { return this.coffs.slice(); }\n    /**\n     * return a simple array form of the knots.  optionally replicate the first and last\n     * in classic over-clamped manner\n     */\n    copyKnots(select, includeExtraEndKnot) { return this.knots[select].copyKnots(includeExtraEndKnot); }\n    /** Create a bspline surface.\n     * * This `create` variant takes control points in a \"flattened\" array, with\n     *  points from succeeding U rows packed together in one array.  Use `createGrid` if the points are in\n     *  a row-by-row grid structure\n     * * knotArrayU and knotArrayV are optional -- uniform knots are implied if they are omitted (undefined).\n     * *  When knots are given, two knot count conditions are recognized:\n     * * + If poleArray.length + order == knotArray.length, the first and last are assumed to be the\n     *      extraneous knots of classic clamping.\n     * * + If poleArray.length + order == knotArray.length + 2, the knots are in modern form that does not have\n     *      the classic unused first and last knot.\n     * @param controlPointArray Array of points, ordered along the U direction.\n     * @param numPoleU number of poles in each row in the U direction.\n     * @param orderU order for the U direction polynomial (`order` is one more than the `degree`.  \"cubic\" polynomial is order 4.)\n     * @param KnotArrayU knots for the V direction.  See note above about knot counts.\n     * @param numPoleV number of poles in each row in the U direction.\n     * @param orderV order for the V direction polynomial (`order` is one more than the `degree`.  \"cubic\" polynomial is order 4.)\n     * @param KnotArrayV knots for the V direction.  See note above about knot counts.\n     */\n    static create(controlPointArray, numPolesU, orderU, knotArrayU, numPolesV, orderV, knotArrayV) {\n        let numPoles = controlPointArray.length;\n        if (controlPointArray instanceof Float64Array)\n            numPoles /= 3;\n        if (!this.validOrderAndPoleCounts(orderU, numPolesU, orderV, numPolesV, numPoles))\n            return undefined;\n        // shift knots-of-interest limits for over-clamped case ...\n        const numKnotsU = knotArrayU ? knotArrayU.length : numPolesU + orderU - 2;\n        const numKnotsV = knotArrayV ? knotArrayV.length : numPolesV + orderV - 2;\n        const skipFirstAndLastU = (numPolesU + orderU === numKnotsU);\n        const skipFirstAndLastV = (numPolesV + orderV === numKnotsV);\n        const knotsU = knotArrayU ?\n            KnotVector.create(knotArrayU, orderU - 1, skipFirstAndLastU) :\n            KnotVector.createUniformClamped(numPolesU, orderU - 1, 0.0, 1.0);\n        const knotsV = knotArrayV ?\n            KnotVector.create(knotArrayV, orderV - 1, skipFirstAndLastV) :\n            KnotVector.createUniformClamped(numPolesV, orderV - 1, 0.0, 1.0);\n        const coffs = new Float64Array(3 * numPolesU * numPolesV);\n        if (controlPointArray instanceof Float64Array) {\n            let i = 0;\n            for (const coordinate of controlPointArray) {\n                coffs[i++] = coordinate;\n            }\n        }\n        else {\n            let i = 0;\n            for (const p of controlPointArray) {\n                coffs[i++] = p.x;\n                coffs[i++] = p.y;\n                coffs[i++] = p.z;\n            }\n        }\n        const surface = new BSplineSurface3d(numPolesU, numPolesV, knotsU, knotsV, coffs);\n        return surface;\n    }\n    /** Create a bspline surface.\n     * * This `create` variant takes control points in a \"grid\" array, with the points from\n     * each grid row `[rowIndex]` being an independent array `points[rowIndex][indexAlongRow][x,y,z]`\n     * * knotArrayU and knotArrayV are optional -- uniform knots are implied if they are omitted (undefined).\n     * *  When knots are given, two knot count conditions are recognized:\n     * * + If poleArray.length + order == knotArray.length, the first and last are assumed to be the\n     *      extraneous knots of classic clamping.\n     * * + If poleArray.length + order == knotArray.length + 2, the knots are in modern form that does not have\n     *      the classic unused first and last knot.\n     * @param controlPointArray Array of points, ordered along the U direction.\n     * @param numPoleU number of poles in each row in the U direction.\n     * @param orderU order for the U direction polynomial (`order` is one more than the `degree`.  \"cubic\" polynomial is order 4.)\n     * @param KnotArrayU knots for the V direction.  See note above about knot counts.\n     * @param numPoleV number of poles in each row in the U direction.\n     * @param orderV order for the V direction polynomial (`order` is one more than the `degree`.  \"cubic\" polynomial is order 4.)\n     * @param KnotArrayV knots for the V direction.  See note above about knot counts.\n     */\n    static createGrid(points, orderU, knotArrayU, orderV, knotArrayV) {\n        const numPolesV = points.length;\n        const numPolesU = points[0].length;\n        const numPoles = numPolesU * numPolesV;\n        // shift knots-of-interest limits for overclamped case ...\n        const numKnotsU = knotArrayU ? knotArrayU.length : numPolesU + orderU - 2;\n        const numKnotsV = knotArrayV ? knotArrayV.length : numPolesV + orderV - 2;\n        const skipFirstAndLastU = (numPolesU + orderU === numKnotsU);\n        const skipFirstAndLastV = (numPolesV + orderV === numKnotsV);\n        if (!this.validOrderAndPoleCounts(orderU, numPolesU, orderV, numPolesV, numPoles))\n            return undefined;\n        const knotsU = knotArrayU ?\n            KnotVector.create(knotArrayU, orderU - 1, skipFirstAndLastU) :\n            KnotVector.createUniformClamped(numPolesU, orderU - 1, 0.0, 1.0);\n        const knotsV = knotArrayV ?\n            KnotVector.create(knotArrayV, orderV - 1, skipFirstAndLastV) :\n            KnotVector.createUniformClamped(numPolesU, orderU - 1, 0.0, 1.0);\n        const coffs = new Float64Array(3 * numPolesU * numPolesV);\n        let i = 0;\n        for (const row of points) {\n            for (const xyz of row) {\n                coffs[i++] = xyz[0];\n                coffs[i++] = xyz[1];\n                coffs[i++] = xyz[2];\n            }\n        }\n        const surface = new BSplineSurface3d(numPolesU, numPolesV, knotsU, knotsV, coffs);\n        return surface;\n    }\n    /**\n     * Return a complete copy of the bspline surface.\n     */\n    clone() {\n        const knotVector1U = this.knots[0].clone();\n        const knotVector1V = this.knots[1].clone();\n        const surface1 = new BSplineSurface3d(this.numPolesUV(0), this.numPolesUV(1), knotVector1U, knotVector1V, this.coffs.slice());\n        return surface1;\n    }\n    /**\n     * Return a complete copy of the bspline surface, with a transform applied to the control points.\n     * @param transform transform to apply to the control points\n     */\n    cloneTransformed(transform) {\n        const surface1 = this.clone();\n        surface1.tryTransformInPlace(transform);\n        return surface1;\n    }\n    /** Evaluate at a position given by u and v coordinates in knot space.\n     * @param u u value, in knot range.\n     * @param v v value in knot range.\n   * @returns Return the xyz coordinates on the surface.\n     */\n    knotToPoint(u, v) {\n        this.evaluateBuffersAtKnot(u, v);\n        return Point3d.createFrom(this._poleBuffer);\n    }\n    /** Evaluate at a position given by a knot value.  */\n    knotToPointAndDerivatives(u, v, result) {\n        this.evaluateBuffersAtKnot(u, v, 1);\n        return Plane3dByOriginAndVectors.createOriginAndVectorsArrays(this._poleBuffer, this._poleBuffer1UV[0], this._poleBuffer1UV[1], result);\n    }\n    /** Evaluate at a position given by fractional coordinate in each direction.\n       * @param fractionU u coordinate, as a fraction of the knot range.\n       * @param fractionV v coordinate, as a fraction of the knot range.\n     * @returns Return the xyz coordinates on the surface.\n     */\n    fractionToPoint(fractionU, fractionV) {\n        return this.knotToPoint(this.knots[0].fractionToKnot(fractionU), this.knots[1].fractionToKnot(fractionV));\n    }\n    /**\n     * evaluate the surface at u and v fractions.\n     * @returns plane with origin at the surface point, direction vectors are derivatives in the u and v directions.\n     * @param fractionU u coordinate, as a fraction of the knot range.\n     * @param fractionV v coordinate, as a fraction of the knot range.\n     * @param result optional pre-allocated object for return values.\n     * @returns Returns point and derivative directions.\n     */\n    fractionToPointAndDerivatives(fractionU, fractionV, result) {\n        const knotU = this.knots[0].fractionToKnot(fractionU);\n        const knotV = this.knots[1].fractionToKnot(fractionV);\n        return this.knotToPointAndDerivatives(knotU, knotV, result);\n    }\n    /** test for identical counts and near-equal coordinates */\n    isAlmostEqual(other) {\n        if (other instanceof BSplineSurface3d) {\n            return this.knots[0].isAlmostEqual(other.knots[0])\n                && this.knots[1].isAlmostEqual(other.knots[1])\n                && Point3dArray.isAlmostEqual(this.coffs, other.coffs);\n        }\n        return false;\n    }\n    /** Test if all poles are in a plane */\n    isInPlane(plane) {\n        return Point3dArray.isCloseToPlane(this.coffs, plane);\n    }\n    /** Second step of double dispatch:  call `handler.handleBSplineSurface3d(this)` */\n    dispatchToGeometryHandler(handler) {\n        return handler.handleBSplineSurface3d(this);\n    }\n    /** Extend the range to include all poles\n     * * This is not a tight range.\n     */\n    extendRange(rangeToExtend, transform) {\n        this.extendRangeXYZ(rangeToExtend, transform);\n    }\n}\n/**  BSpline Surface in xyzw homogeneous space\n * @public\n */\nexport class BSplineSurface3dH extends BSpline2dNd {\n    /** Test if `other` is an instance of `BSplineSurface3dH */\n    isSameGeometryClass(other) { return other instanceof BSplineSurface3dH; }\n    /** Apply the transform to the poles */\n    tryTransformInPlace(transform) {\n        Point4dArray.multiplyInPlace(transform, this.coffs);\n        return true;\n    }\n    /** Return a pole by u and v indices */\n    getPole(i, j, result) {\n        return this.getPoint3dPoleXYZW(i, j, result);\n    }\n    constructor(numPolesU, numPolesV, knotsU, knotsV, coffs) {\n        super(numPolesU, numPolesV, 4, knotsU, knotsV, coffs);\n    }\n    /** Return a simple array of the control points. */\n    copyPoints4d() { return Point4dArray.unpackToPoint4dArray(this.coffs); }\n    /** Return a simple array of the control points. */\n    copyPointsAndWeights(points, weights, formatter = (x, y, z) => Point3d.create(x, y, z)) {\n        Point4dArray.unpackFloat64ArrayToPointsAndWeights(this.coffs, points, weights, formatter);\n    }\n    /** unpack from xyzw xyzw ... to packed xyz, optionally unweighted\n     */\n    copyXYZToFloat64Array(unweight) {\n        const numPoints = Math.floor(this.coffs.length / 4);\n        const result = new Float64Array(numPoints * 3);\n        let j = 0;\n        for (let i = 0; i < numPoints; i++) {\n            const ix = i * 4;\n            if (unweight) {\n                const dw = 1.0 / this.coffs[ix + 3];\n                result[j++] = this.coffs[ix] * dw;\n                result[j++] = this.coffs[ix + 1] * dw;\n                result[j++] = this.coffs[ix + 2] * dw;\n            }\n            else {\n                result[j++] = this.coffs[ix];\n                result[j++] = this.coffs[ix + 1];\n                result[j++] = this.coffs[ix + 2];\n            }\n        }\n        return result;\n    }\n    /** unpack from xyzw xyzw ... to packed xyz, optionally unweighted\n     */\n    copyWeightsToFloat64Array() {\n        const numPoints = Math.floor(this.coffs.length / 4);\n        const result = new Float64Array(numPoints);\n        let i = 0;\n        let j = 0;\n        for (; i < numPoints; i++) {\n            result[j++] = this.coffs[4 * i + 3];\n        }\n        return result;\n    }\n    /**\n     * return a simple array form of the knots.  optionally replicate the first and last\n     * in classic over-clamped manner\n     */\n    copyKnots(select, includeExtraEndKnot) { return this.knots[select].copyKnots(includeExtraEndKnot); }\n    /** Create a weighted bspline surface, with control points and weights each organized as flattened array of points continuing from one U row to the next.\n     * * This `create` variant takes control points in a \"flattened\" array, with\n     *  points from succeeding U rows packed together in one array.  Use `createGrid` if the points are in\n     *  a deeper grid array structure.\n     * * knotArrayU and knotArrayV are optional -- uniform knots are implied if they are omitted (undefined).\n     * *  When knots are given, two knot count conditions are recognized:\n     * * * If poleArray.length + order == knotArray.length, the first and last are assumed to be the\n     *      extraneous knots of classic clamping.\n     * * * If poleArray.length + order == knotArray.length + 2, the knots are in modern form that does not have\n     *      the classic unused first and last knot.\n     * @param controlPointArray Array of points, ordered along the U direction.\n     * @param weightArray array of weights, ordered along the U direction.\n     * @param numPoleU number of poles in each row in the U direction.\n     * @param orderU order for the U direction polynomial (`order` is one more than the `degree`.  \"cubic\" polynomial is order 4.)\n     * @param KnotArrayU optional knots for the V direction.  See note above about knot counts.\n     * @param numPoleV number of poles in each row in the U direction.\n     * @param orderV order for the V direction polynomial (`order` is one more than the `degree`.  \"cubic\" polynomial is order 4.)\n     * @param KnotArrayV optional knots for the V direction.  See note above about knot counts.\n     */\n    static create(controlPointArray, weightArray, numPolesU, orderU, knotArrayU, numPolesV, orderV, knotArrayV) {\n        const numPoles = numPolesU * numPolesV;\n        if (!this.validOrderAndPoleCounts(orderU, numPolesU, orderV, numPolesV, numPoles))\n            return undefined;\n        const numKnotsU = knotArrayU ? knotArrayU.length : numPolesU + orderU - 2;\n        const numKnotsV = knotArrayV ? knotArrayV.length : numPolesV + orderV - 2;\n        const skipFirstAndLastU = (numPolesU + orderU === numKnotsU);\n        const skipFirstAndLastV = (numPolesV + orderV === numKnotsV);\n        const knotsU = knotArrayU ?\n            KnotVector.create(knotArrayU, orderU - 1, skipFirstAndLastU) :\n            KnotVector.createUniformClamped(numPolesU, orderU - 1, 0.0, 1.0);\n        const knotsV = knotArrayV ?\n            KnotVector.create(knotArrayV, orderV - 1, skipFirstAndLastV) :\n            KnotVector.createUniformClamped(numPolesV, orderV - 1, 0.0, 1.0);\n        const coffs = Point4dArray.packPointsAndWeightsToFloat64Array(controlPointArray, weightArray);\n        if (coffs === undefined || coffs.length !== 4 * numPolesU * numPolesV)\n            return undefined;\n        const surface = new BSplineSurface3dH(numPolesU, numPolesV, knotsU, knotsV, coffs);\n        return surface;\n    }\n    /** Create a bspline with given knots.\n     *\n     *   Two count conditions are recognized in each direction:\n     *\n     * ** If poleArray.length + order == knotArray.length, the first and last are assumed to be the\n     *      extraneous knots of classic clamping.\n     * ** If poleArray.length + order == knotArray.length + 2, the knots are in modern form.\n     *\n     */\n    static createGrid(xyzwGrid, weightStyle, orderU, knotArrayU, orderV, knotArrayV) {\n        const numPolesV = xyzwGrid.length;\n        const numPolesU = xyzwGrid[0].length;\n        const numPoles = numPolesU * numPolesV;\n        if (!this.validOrderAndPoleCounts(orderU, numPolesU, orderV, numPolesV, numPoles))\n            return undefined;\n        // const numPoles = numPolesU * numPolesV;\n        // shift knots-of-interest limits for overclamped case ...\n        const numKnotsU = knotArrayU.length;\n        const numKnotsV = knotArrayV.length;\n        const skipFirstAndLastU = (numPolesU + orderU === numKnotsU);\n        const skipFirstAndLastV = (numPolesV + orderV === numKnotsV);\n        const knotsU = KnotVector.create(knotArrayU, orderU - 1, skipFirstAndLastU);\n        const knotsV = KnotVector.create(knotArrayV, orderV - 1, skipFirstAndLastV);\n        const coffs = new Float64Array(4 * numPoles);\n        if (weightStyle === WeightStyle.WeightsSeparateFromCoordinates) {\n            let i = 0;\n            for (const row of xyzwGrid) {\n                for (const point of row) {\n                    const w = point[3];\n                    coffs[i++] = point[0] * w;\n                    coffs[i++] = point[1] * w;\n                    coffs[i++] = point[2] * w;\n                    coffs[i++] = point[3];\n                }\n            }\n        }\n        else {\n            // implicit WeightStyle.WeightsAlreadyAppliedToCoordinates\n            let i = 0;\n            for (const row of xyzwGrid) {\n                for (const point of row) {\n                    coffs[i++] = point[0];\n                    coffs[i++] = point[1];\n                    coffs[i++] = point[2];\n                    coffs[i++] = point[3];\n                }\n            }\n        }\n        const surface = new BSplineSurface3dH(numPolesU, numPolesV, knotsU, knotsV, coffs);\n        return surface;\n    }\n    /** Return a deep clone */\n    clone() {\n        const knotVector1U = this.knots[0].clone();\n        const knotVector1V = this.knots[1].clone();\n        const surface1 = new BSplineSurface3dH(this.numPolesUV(0), this.numPolesUV(1), knotVector1U, knotVector1V, this.coffs.slice());\n        surface1.coffs = this.coffs.slice();\n        return surface1;\n    }\n    /** Return a transformed clone */\n    cloneTransformed(transform) {\n        const surface1 = this.clone();\n        surface1.tryTransformInPlace(transform);\n        return surface1;\n    }\n    /**\n      * Return control points json arrays.\n      * * Each row of points is an an array.\n      * * Within the array for each row, each point is an array [wx,wy,wz,w].\n      */\n    getPointGridJSON() {\n        const result = {\n            points: Point3dArray.unpackNumbersToNestedArraysIJK(this.coffs, 4, this.numPolesUV(0)),\n            numCartesianDimensions: 3,\n            weightStyle: WeightStyle.WeightsAlreadyAppliedToCoordinates,\n        };\n        return result;\n    }\n    /** Evaluate at a position given by a knot value.  */\n    knotToPoint4d(u, v) {\n        this.evaluateBuffersAtKnot(u, v);\n        return Point4d.createFromPackedXYZW(this._poleBuffer, 0);\n    }\n    /** Evaluate at a position given by a knot value.  */\n    knotToPointAndDerivatives(u, v, result) {\n        this.evaluateBuffersAtKnot(u, v, 1);\n        return Plane3dByOriginAndVectors.createOriginAndVectorsWeightedArrays(this._poleBuffer, this._poleBuffer1UV[0], this._poleBuffer1UV[1], result);\n    }\n    /** Evaluate the Point4d (leaving weights in the point) at given fractional coordinates. */\n    fractionToPoint4d(fractionU, fractionV) {\n        return this.knotToPoint4d(this.knots[0].fractionToKnot(fractionU), this.knots[1].fractionToKnot(fractionV));\n    }\n    /**\n     * * evaluate the surface and return the cartesian (weight = 1) point.\n     * * if the surface XYZW point has weight0, returns point3d at 000.\n     * @param fractionU u direction fraction\n     * @param fractionV v direction fraction\n     * @param result optional result\n     */\n    fractionToPoint(fractionU, fractionV, result) {\n        const point4d = this.knotToPoint4d(this.knots[0].fractionToKnot(fractionU), this.knots[1].fractionToKnot(fractionV));\n        return point4d.realPointDefault000(result);\n    }\n    /**\n   * * evaluate the surface and return the cartesian (weight = 1) point.\n   * * if the surface XYZW point has weight0, returns point3d at 000.\n   * @param knotU u direction knot\n   * @param knotV v direction knot\n   * @param result optional result\n   */\n    knotToPoint(knotU, knotV, result) {\n        const point4d = this.knotToPoint4d(knotU, knotV);\n        return point4d.realPointDefault000(result);\n    }\n    /**\n     * evaluate the surface at u and v fractions.\n     * @returns plane with origin at the surface point, direction vectors are derivatives in the u and v directions.\n     * @param fractionU u coordinate, as a fraction of the knot range.\n     * @param fractionV v coordinate, as a fraction of the knot range.\n     * @param result optional pre-allocated object for return values.\n     * @returns Returns point and derivative directions.\n     */\n    fractionToPointAndDerivatives(fractionU, fractionV, result) {\n        const knotU = this.knots[0].fractionToKnot(fractionU);\n        const knotV = this.knots[1].fractionToKnot(fractionV);\n        return this.knotToPointAndDerivatives(knotU, knotV, result);\n    }\n    /** test for identical counts and near-equal coordinates */\n    isAlmostEqual(other) {\n        if (other instanceof BSplineSurface3dH) {\n            return this.knots[0].isAlmostEqual(other.knots[0])\n                && this.knots[1].isAlmostEqual(other.knots[1])\n                && Point4dArray.isAlmostEqual(this.coffs, other.coffs);\n        }\n        return false;\n    }\n    /** Test if all poles are in a plane */\n    isInPlane(plane) {\n        return Point4dArray.isCloseToPlane(this.coffs, plane);\n    }\n    /** Second step of double dispatch:  call `handler.handleBSplineSurface3dH(this)` */\n    dispatchToGeometryHandler(handler) {\n        return handler.handleBSplineSurface3dH(this);\n    }\n    /**\n     * extend a range to include the (optionally transformed) points of this surface\n     * @param rangeToExtend range that is updated to include this surface range\n     * @param transform transform to apply to the surface points\n     */\n    extendRange(rangeToExtend, transform) {\n        this.extendRangeXYZH(rangeToExtend, transform);\n    }\n}\n//# sourceMappingURL=BSplineSurface.js.map",
      "start": 1693508123871,
      "end": 1693508124028,
      "sourcemaps": null
    }
  ]
}
