{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/ClipStack.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { assert, dispose } from \"@itwin/core-bentley\";\nimport { ClipPlaneContainment, Point3d, Transform } from \"@itwin/core-geometry\";\nimport { IModelApp } from \"../../IModelApp\";\nimport { FloatRgba } from \"./FloatRGBA\";\nimport { Texture2DHandle } from \"./Texture\";\nimport { ClipVolume } from \"./ClipVolume\";\nimport { GL } from \"./GL\";\nconst emptyClipData = new Uint8Array(0);\nconst emptyClip = {\n    numRows: 0,\n    getData: () => emptyClipData,\n};\nconst scratchRangeCorners = [\n    new Point3d(), new Point3d(), new Point3d(), new Point3d(),\n    new Point3d(), new Point3d(), new Point3d(), new Point3d(),\n];\nfunction getRangeCorners(r) {\n    return r.corners(scratchRangeCorners);\n}\n/** Maintains a stack of ClipVolumes. The volumes nest such that the stack represents the intersection of all the volumes.\n * The bottom of the stack represents the view's clip volume and is always present even if the view has no clip.\n * It also maintains the inside/outside clip colors, where the alpha component is 1 if the color should be applied and 0 if not.\n * @internal\n */\nexport class ClipStack {\n    constructor(getTransform, wantViewClip) {\n        /** The first entry always represents the view clip. The rest are pushed and popped with GraphicBranches. */\n        this._stack = [emptyClip];\n        /** True if we need to recompute the texture. */\n        this._isStackDirty = false;\n        /** If alpha is 1 then geometry inside the clip will be drawn in this color. */\n        this._insideColor = FloatRgba.from(0, 0, 0, 0);\n        /** If alpha is 1 then geometry outside the clip will be drawn in this color. */\n        this._outsideColor = FloatRgba.from(0, 0, 0, 0);\n        /** For detecting whether the transform changed from one invocation of setViewClip to the next. */\n        this._prevTransform = Transform.createZero();\n        this._getTransform = getTransform;\n        this._wantViewClip = wantViewClip;\n        this._numTotalRows = this._numRowsInUse = 0;\n        this._cpuBuffer = new Uint8Array(this._numTotalRows);\n        this._gpuBuffer = this.allocateGpuBuffer();\n    }\n    get insideColor() {\n        return this._insideColor;\n    }\n    get outsideColor() {\n        return this._outsideColor;\n    }\n    get hasOutsideColor() {\n        return this.outsideColor.alpha !== 0;\n    }\n    get bytesUsed() {\n        return this._texture ? this._texture.bytesUsed : 0;\n    }\n    setViewClip(clip, style) {\n        assert(this._stack.length === 1);\n        this.updateColor(style.insideColor, this._insideColor);\n        this.updateColor(style.outsideColor, this._outsideColor);\n        const transform = this._getTransform();\n        if (!transform.isAlmostEqual(this._prevTransform)) {\n            transform.clone(this._prevTransform);\n            this._isStackDirty = true;\n        }\n        const cur = this._stack[0];\n        if (cur === emptyClip) {\n            if (!clip)\n                return; // no change.\n        }\n        else if (!clip) {\n            this._stack[0] = emptyClip;\n            this._numRowsInUse = 0;\n            this._isStackDirty = true;\n            return;\n        }\n        else {\n            assert(cur instanceof ClipVolume);\n            if (cur.clipVector === clip) {\n                // We assume that the active view's ClipVector is never mutated in place, so if we are given the same ClipVector, we expect our RenderClipVolume to match it.\n                return;\n            }\n        }\n        // ClipVector has changed.\n        const newClip = IModelApp.renderSystem.createClipVolume(clip);\n        if (!newClip) {\n            this._isStackDirty = this._stack[0] !== emptyClip;\n            this._stack[0] = emptyClip;\n            this._numRowsInUse = 0;\n        }\n        else {\n            this.pop();\n            this.push(newClip);\n        }\n    }\n    push(clip) {\n        assert(clip instanceof ClipVolume);\n        this._stack.push(clip);\n        this._numRowsInUse += clip.numRows;\n        this._numTotalRows = Math.max(this._numRowsInUse, this._numTotalRows);\n        this._isStackDirty = true;\n    }\n    pop() {\n        assert(this._stack.length > 0);\n        const clip = this._stack.pop();\n        this._numRowsInUse -= (clip ? clip.numRows : 0);\n    }\n    get hasClip() {\n        return this.startIndex < this.endIndex;\n    }\n    get hasViewClip() {\n        return emptyClip !== this._stack[0] && this._wantViewClip();\n    }\n    get startIndex() {\n        assert(this._stack.length > 0);\n        return this._wantViewClip() ? 0 : this._stack[0].numRows;\n    }\n    get endIndex() {\n        return this._numRowsInUse;\n    }\n    get textureHeight() {\n        return this._numTotalRows;\n    }\n    get texture() {\n        this.updateTexture();\n        return this._texture;\n    }\n    isRangeClipped(range, transform) {\n        if (this.hasOutsideColor || !this.hasClip)\n            return false;\n        range = transform.multiplyRange(range, range);\n        const corners = getRangeCorners(range);\n        const startIndex = this._wantViewClip() && emptyClip !== this._stack[0] ? 0 : 1;\n        for (let i = startIndex; i < this._stack.length; i++) {\n            const clip = this._stack[i];\n            assert(clip instanceof ClipVolume);\n            if (ClipPlaneContainment.StronglyOutside === clip.clipVector.classifyPointContainment(corners))\n                return true;\n        }\n        return false;\n    }\n    /** Exposed strictly for tests. */\n    get clips() {\n        return this._stack;\n    }\n    /** Exposed strictly for tests. */\n    static get emptyViewClip() {\n        return emptyClip;\n    }\n    updateTexture() {\n        if (this._numTotalRows > 0 && (!this._texture || this._texture.height < this._numTotalRows)) {\n            // We need to resize the texture.\n            assert(this._isStackDirty);\n            this._isStackDirty = true;\n            this._texture = dispose(this._texture);\n            this._cpuBuffer = new Uint8Array(this._numTotalRows * 4 * 4);\n            this._gpuBuffer = this.allocateGpuBuffer();\n        }\n        if (this._isStackDirty) {\n            this._isStackDirty = false;\n            this.recomputeTexture();\n        }\n    }\n    recomputeTexture() {\n        // Copy each clip's data to the buffer, recording whether the buffer's contents actually changed.\n        let bufferDirty = false;\n        const transform = this._getTransform();\n        let bufferIndex = 0;\n        for (const clip of this._stack) {\n            const data = clip.getData(transform);\n            for (let i = 0; i < data.byteLength; i++) {\n                const byte = data[i];\n                bufferDirty = bufferDirty || byte !== this._cpuBuffer[bufferIndex];\n                this._cpuBuffer[bufferIndex++] = byte;\n            }\n        }\n        // If the contents have changed, upload the new texture data to the GPU.\n        if (bufferDirty) {\n            this.uploadTexture();\n        }\n    }\n    uploadTexture() {\n        if (this._texture)\n            this._texture.replaceTextureData(this._gpuBuffer);\n        else\n            this._texture = Texture2DHandle.createForData(1, this._numTotalRows, this._gpuBuffer, false, GL.Texture.WrapMode.ClampToEdge, GL.Texture.Format.Rgba);\n        assert(this._texture.height === this._numTotalRows);\n    }\n    allocateGpuBuffer() {\n        return new Float32Array(this._cpuBuffer.buffer);\n    }\n    updateColor(rgb, rgba) {\n        rgba.alpha = undefined !== rgb ? 1 : 0;\n        if (rgb)\n            rgba.setRgbColor(rgb);\n    }\n}\n//# sourceMappingURL=ClipStack.js.map",
      "start": 1693508126119,
      "end": 1693508126258,
      "sourcemaps": null
    }
  ]
}
