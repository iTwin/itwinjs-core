{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/numerics/Quadrature.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\nimport { Geometry } from \"../Geometry\";\n/** @packageDocumentation\n * @module Numerics\n */\n/** Support class for quadrature -- approximate integrals by summing weighted function values.\n * These are filled with x and weight for quadrature between xA and xB\n *\n * Since quadrature is done in side tight loops, these methods are structured for minimum object\n * allocation.\n * For methods names setupGauss<N> (where N is a smallish integer), the CALLER creates arrays xMapped and wMapped\n * The method installs particular x and weight values.\n * @internal\n */\nclass Quadrature {\n    /**\n     * Given points and weights in a reference interval (usually 0 to 1):\n     *\n     * * map each xRef[i] to xA + h * xRef[i];\n     * * scale each weight wRef[i] to h * wRef[i]\n     * * all arrays are assumed to have xRef.length entries.\n     * * the return value is xRef.length\n     * @param xA beginning of target interval\n     * @param h length of target interval\n     * @param xRef x coordinates in reference interval\n     * @param wRef weights for integration in the reference interval\n     * @param xMapped x coordinates to evaluate integrands\n     * @param wMapped weights for evaluated integrands\n     */\n    static mapWeights(xA, h, xRef, wRef, xMapped, wMapped) {\n        const n = xRef.length;\n        for (let i = 0; i < n; i++) {\n            xMapped[i] = xA + h * xRef[i];\n            wMapped[i] = h * wRef[i];\n        }\n        return n;\n    }\n    /** Install 1 (ONE) x and weight values for quadrature from xA to xB. */\n    static setupGauss1(xA, xB, xMapped, wMapped) {\n        return Quadrature.mapWeights(xA, xB - xA, Quadrature.gaussX1Interval01, Quadrature.gaussW1Interval01, xMapped, wMapped);\n    }\n    /** Install 2 (TWO) x and weight values for quadrature from xA to xB. */\n    static setupGauss2(xA, xB, xMapped, wMapped) {\n        return Quadrature.mapWeights(xA, xB - xA, Quadrature.gaussX2Interval01, Quadrature.gaussW2Interval01, xMapped, wMapped);\n        /*  // exact formulas for interval xA..xB:\n            const x0 = 0.5 * (xA + xB);\n                const h = 0.5 * (xB - xA);\n                const dx = h / Math.sqrt(3);\n                xMapped[0] = x0 - dx; xMapped[1] = x0 + dx;\n                wMapped[0] = wMapped[1] = h;\n                */\n    }\n    /** Install 3 (THREE) x and weight values for quadrature from xA to xB. */\n    static setupGauss3(xA, xB, xMapped, wMapped) {\n        return Quadrature.mapWeights(xA, xB - xA, Quadrature.gaussX3Interval01, Quadrature.gaussW3Interval01, xMapped, wMapped);\n        /*  // exact formulas for interval xA..xB:\n        const x0 = 0.5 * (xA + xB);\n        const h = 0.5 * (xB - xA);\n        const a = Math.sqrt(0.6);\n        const b = h * 5.0 / 9.0;\n        const dx = a * h;\n        xMapped[0] = x0 - dx; xMapped[1] = x0; xMapped[2] = x0 + dx;\n        wMapped[0] = wMapped[2] = b;\n        wMapped[1] = h * 8.0 / 9.0;\n        return 3;\n        */\n    }\n    /** Install 5 (FIVE) x and weight values for quadrature from xA to xB. */\n    static setupGauss5(xA, xB, xMapped, wMapped) {\n        return Quadrature.mapWeights(xA, xB - xA, Quadrature.gaussX5Interval01, Quadrature.gaussW5Interval01, xMapped, wMapped);\n        /*  // exact formulas for interval xA..xB:\n        const x0 = 0.5 * (xA + xB);\n        const h = 0.5 * (xB - xA);\n        const q = 2.0 * Math.sqrt(10.0 / 7.0);\n        const b = 13.0 * Math.sqrt(70.0);\n        const a1 = h * Math.sqrt(5.0 - q) / 3.0;\n        const a2 = h * Math.sqrt(5.0 + q) / 3.0;\n        const w1 = h * (322.0 + b) / 900.0;\n        const w2 = h * (322.0 - b) / 900;\n        const w0 = h * 128.0 / 225.0;\n        xMapped[0] = x0 - a2; xMapped[1] = x0 - a1; xMapped[2] = x0; xMapped[3] = x0 + a1; xMapped[4] = x0 + a2;\n        wMapped[0] = w2; wMapped[1] = w1; wMapped[2] = w0; wMapped[3] = w1; wMapped[4] = w2;\n        return 5;\n        */\n    }\n    /** Install 4 (FOUR) x and weight values for quadrature from xA to xB. */\n    static setupGauss4(xA, xB, xMapped, wMapped) {\n        return Quadrature.mapWeights(xA, xB - xA, Quadrature.gaussX4Interval01, Quadrature.gaussW4Interval01, xMapped, wMapped);\n        /*  // exact formulas for interval xA..xB:\n    const x0 = 0.5 * (xA + xB);\n    const h = 0.5 * (xB - xA);\n    const q = 2.0 * Math.sqrt(6.0 / 5.0);\n    const r = Math.sqrt(30.0);\n    const a1 = h * Math.sqrt((3 - q) / 7.0);\n    const w1 = h * (18.0 + r) / 36.0;\n    const a2 = h * Math.sqrt((3 + q) / 7.0);\n    const w2 = h * (18.0 - r) / 36.0;\n    xMapped[0] = x0 - a2; xMapped[1] = x0 - a1; xMapped[2] = x0 + a1; xMapped[3] = x0 + a2;\n    wMapped[0] = w2; wMapped[1] = w1; wMapped[2] = w1; wMapped[3] = w2;\n    return 4;\n    */\n    }\n    /** Sum function values with given weights and x values. */\n    static sum1(xx, ww, n, f) {\n        let sum = 0;\n        for (let i = 0; i < n; i++)\n            sum += ww[i] * f(xx[i]);\n        return sum;\n    }\n    /**\n     * Do a Guass quadrature integral for a (number)=>number function over an interval, with caller specified sub-interval count and\n     * @param x0 start of overall interval\n     * @param x1 end of overall interval\n     * @param f function to evaluate\n     * @param numInterval number of internal intervals\n     * @param numGauss number of gauss points.    must be supported by GaussMapper, i.e. 1,2,3,4,5\n     */\n    static doGaussIntegral(x0, x1, f, numInterval, numGauss = 5) {\n        const mapper = new GaussMapper(numGauss);\n        if (numInterval < 1)\n            numInterval = 1;\n        const df = 1.0 / numInterval;\n        let sum = 0;\n        for (let i = 1; i <= numInterval; i++) {\n            const xA = Geometry.interpolate(x0, (i - 1) * df, x1);\n            const xB = i === numInterval ? x1 : Geometry.interpolate(x0, (i) * df, x1);\n            const n = mapper.mapXAndW(xA, xB);\n            for (let k = 0; k < n; k++) {\n                sum += mapper.gaussW[k] * f(mapper.gaussX[k]);\n            }\n        }\n        return sum;\n    }\n}\n/** x value for 1 point gauss rule in 0..1 interval */\nQuadrature.gaussX1Interval01 = new Float64Array([0.5]);\n/** weight for 1 point gauss rule in 0..1 interval */\nQuadrature.gaussW1Interval01 = new Float64Array([1.0]);\n/** x value for 2 point gauss rule in 0..1 interval */\nQuadrature.gaussX2Interval01 = new Float64Array([0.21132486540518708, 0.7886751345948129]);\n/** weight for 2 point gauss rule in 0..1 interval */\nQuadrature.gaussW2Interval01 = new Float64Array([0.5, 0.5]);\n/** x value for 3 point gauss rule in 0..1 interval */\nQuadrature.gaussX3Interval01 = new Float64Array([0.1127016653792583, 0.5, 0.8872983346207417]);\n/** weight for 3 point gauss rule in 0..1 interval */\nQuadrature.gaussW3Interval01 = new Float64Array([0.2777777777777778, 0.4444444444444444, 0.2777777777777778]);\n/** x value for 4 point gauss rule in 0..1 interval */\nQuadrature.gaussX4Interval01 = new Float64Array([0.06943184420297371, 0.33000947820757187, 0.6699905217924281, 0.9305681557970262]);\n/** weight for 4 point gauss rule in 0..1 interval */\nQuadrature.gaussW4Interval01 = new Float64Array([0.17392742256872692, 0.3260725774312731, 0.3260725774312731, 0.17392742256872692]);\n/** x value for 5 point gauss rule in 0..1 interval */\nQuadrature.gaussX5Interval01 = new Float64Array([0.04691007703066802, 0.23076534494715845, 0.5, 0.7692346550528415, 0.9530899229693319]);\n/** weight for 5 point gauss rule in 0..1 interval */\nQuadrature.gaussW5Interval01 = new Float64Array([0.11846344252809454, 0.23931433524968324, 0.28444444444444444, 0.23931433524968324, 0.11846344252809454]);\nexport { Quadrature };\n/**\n * This class carries public members as needed for users to have gauss points that are used\n * in the callers loops.\n * @internal\n */\nexport class GaussMapper {\n    /** Execute the mapXAndWFunction to set up arrays for integration from xA to xB */\n    mapXAndW(xA, xB) {\n        return this.mapXAndWFunction(xA, xB, this.gaussX, this.gaussW);\n    }\n    /** setup gauss arrays.\n     * * Number of gauss points must be 1 to 5 (inclusive)\n     * @param numGauss requested number of gauss points.\n     */\n    constructor(numGaussPoints) {\n        const maxGauss = 7; // (As of Nov 2 2018, 7 is a fluffy over-allocation-- the quadrature class only handles up to 5.)\n        this.gaussX = new Float64Array(maxGauss);\n        this.gaussW = new Float64Array(maxGauss);\n        // This sets the number of gauss points.  This integrates exactly for polynomials of (degree 2*numGauss - 1).\n        if (numGaussPoints > 5 || numGaussPoints < 1)\n            numGaussPoints = 5;\n        switch (numGaussPoints) {\n            case 1:\n                this.mapXAndWFunction = (xA, xB, xMapped, wMapped) => Quadrature.setupGauss1(xA, xB, xMapped, wMapped);\n                break;\n            case 2:\n                this.mapXAndWFunction = (xA, xB, xMapped, wMapped) => Quadrature.setupGauss2(xA, xB, xMapped, wMapped);\n                break;\n            case 3:\n                this.mapXAndWFunction = (xA, xB, xMapped, wMapped) => Quadrature.setupGauss3(xA, xB, xMapped, wMapped);\n                break;\n            case 4:\n                this.mapXAndWFunction = (xA, xB, xMapped, wMapped) => Quadrature.setupGauss4(xA, xB, xMapped, wMapped);\n                break;\n            default:\n                this.mapXAndWFunction = (xA, xB, xMapped, wMapped) => Quadrature.setupGauss5(xA, xB, xMapped, wMapped);\n                break;\n        }\n    }\n}\n// someday .... http://www.holoborodko.com/pavel/numerical-methods/numerical-integration/overlapped-newton-cotes-quadratures/\n//# sourceMappingURL=Quadrature.js.map",
      "start": 1693508123487,
      "end": 1693508123663,
      "sourcemaps": null
    }
  ]
}
