{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tile/TileRequestChannels.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tiles\n */\nimport { IpcApp } from \"../IpcApp\";\nimport { IModelTileRequestChannels, TileRequestChannel, TileRequestChannelStatistics, } from \"./internal\";\n/** For an [[IpcApp]], allows backend element graphics requests in progress to be canceled. */\nclass ElementGraphicsChannel extends TileRequestChannel {\n    constructor() {\n        super(...arguments);\n        this._canceled = new Map();\n    }\n    onActiveRequestCanceled(request) {\n        const imodel = request.tile.tree.iModel;\n        let ids = this._canceled.get(imodel);\n        if (!ids)\n            this._canceled.set(imodel, ids = []);\n        ids.push(request.tile.contentId);\n    }\n    processCancellations() {\n        for (const [imodel, requestIds] of this._canceled) {\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            IpcApp.appFunctionIpc.cancelElementGraphicsRequests(imodel.key, requestIds);\n            this._statistics.totalAbortedRequests += requestIds.length;\n        }\n        this._canceled.clear();\n    }\n    onIModelClosed(imodel) {\n        this._canceled.delete(imodel);\n    }\n}\n/** A set of named [[TileRequestChannel]]s via which content for [[Tile]]s can be requested.\n * @see [[TileAdmin.channels]] for the channels configured for use with the iTwin.js display system.\n * @see [[TileRequestChannels.getForHttp]] for the most typical way of obtaining or registering a channel.\n * @public\n * @extensions\n */\nexport class TileRequestChannels {\n    /** `rpcConcurrency` is defined if [[IpcApp.isValid]]; otherwise RPC requests are made over HTTP and use the same limits.\n     * @internal\n     */\n    constructor(rpcConcurrency, cacheMetadata) {\n        /** The maximum number of active requests for a channel that uses HTTP to request content. */\n        this.httpConcurrency = 6;\n        this._channels = new Map();\n        this._rpcConcurrency = rpcConcurrency ?? this.httpConcurrency;\n        const elementGraphicsChannelName = \"itwinjs-elem-rpc\";\n        if (undefined !== rpcConcurrency)\n            this.elementGraphicsRpc = new ElementGraphicsChannel(elementGraphicsChannelName, rpcConcurrency);\n        else\n            this.elementGraphicsRpc = new TileRequestChannel(elementGraphicsChannelName, this.rpcConcurrency);\n        this.add(this.elementGraphicsRpc);\n        this.iModelChannels = new IModelTileRequestChannels({\n            concurrency: this.rpcConcurrency,\n            usesHttp: undefined === rpcConcurrency,\n            cacheMetadata,\n            cacheConcurrency: this.httpConcurrency,\n        });\n        for (const channel of this.iModelChannels)\n            this.add(channel);\n    }\n    /** The number of registered channels. */\n    get size() {\n        return this._channels.size;\n    }\n    /** Look up a registered channel by its name. */\n    get(name) {\n        return this._channels.get(name);\n    }\n    /** Return whether the specified channel has been registered. Primarily for debugging. */\n    has(channel) {\n        const existing = this.get(channel.name);\n        return existing !== undefined && existing === channel;\n    }\n    /** Add a new channel.\n     * @throws Error if a channel by the same name has already been registered.\n     */\n    add(channel) {\n        if (this.get(channel.name))\n            throw new Error(`Tile request channel ${channel.name} is already registered.`);\n        this._channels.set(channel.name, channel);\n    }\n    /** Extract the host name from a URL for use as the name of the corresponding [[TileRequestChannel]].\n     * @throws TypeError if `url` is a string and does not represent a valid URL.\n     * @see [[getForHttp]] to obtain or register a channel for the host name.\n     */\n    static getNameFromUrl(url) {\n        if (typeof url === \"string\")\n            url = new URL(url);\n        return url.hostname;\n    }\n    /** Obtain a channel that requests content over HTTP using HTTP 1.1 limits on simultaneous connections.\n     * If a channel with the specified name does not already exist, it will be created and registered.\n     * @see [[getNameFromUrl]] to obtain a channel name corresponding to a hostname.\n     */\n    getForHttp(name) {\n        let channel = this.get(name);\n        if (!channel)\n            this.add(channel = new TileRequestChannel(name, this.httpConcurrency));\n        return channel;\n    }\n    /** Iterator over all of the channels. */\n    [Symbol.iterator]() {\n        return this._channels.values()[Symbol.iterator]();\n    }\n    /** The maximum number of active requests for a channel that uses an RpcInterface to satisfy its requests.\n     * For web-based applications, this is the same as [[httpConcurrency]], but for [[IpcApp]]s it is determined by the number of workers threads allocated by the backend.\n     */\n    get rpcConcurrency() {\n        return this._rpcConcurrency;\n    }\n    /** @internal */\n    getIModelTileChannel(tile) {\n        return this.iModelChannels.getChannelForTile(tile);\n    }\n    /** Chiefly for debugging.\n     * @internal\n     */\n    setRpcConcurrency(concurrency) {\n        this._rpcConcurrency = concurrency;\n        this.iModelChannels.setRpcConcurrency(concurrency);\n        this.elementGraphicsRpc.concurrency = concurrency;\n    }\n    /** Statistics intended primarily for debugging. */\n    get statistics() {\n        const stats = new TileRequestChannelStatistics();\n        for (const channel of this)\n            channel.statistics.addTo(stats);\n        return stats;\n    }\n    /** Reset all [[statistics]] to zero. */\n    resetStatistics() {\n        for (const channel of this)\n            channel.resetStatistics();\n    }\n    /** Invoked by [[TileAdmin.processQueue]] when it is about to start enqueuing new requests.\n     * @internal\n     */\n    swapPending() {\n        for (const channel of this)\n            channel.swapPending();\n    }\n    /** Invoked by [[TileAdmin.processQueue]] when it is about to start enqueuing new requests.\n     * @internal\n     */\n    process() {\n        for (const channel of this)\n            channel.process();\n    }\n    /** Invoked by [[TileAdmin.onIModelClosed]].\n     * @internal\n     */\n    onIModelClosed(iModel) {\n        for (const channel of this)\n            channel.onIModelClosed(iModel);\n    }\n    /** Invoked by [[TileAdmin.onShutDown]].\n     * @internal\n     */\n    onShutDown() {\n        for (const channel of this)\n            channel.cancelAndClearAll();\n        this._channels.clear();\n    }\n}\n//# sourceMappingURL=TileRequestChannels.js.map",
      "start": 1693508121708,
      "end": 1693508121816,
      "sourcemaps": null
    }
  ]
}
