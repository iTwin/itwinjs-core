{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/glsl/Decode.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\n/** @internal */\nexport const decodeUint16 = `\r\nfloat decodeUInt16(vec2 v) {\r\n  return dot(v, vec2(1.0, 256.0)); // v.x | (v.y << 8)\r\n}\r\n`;\n/** @internal */\nexport const decodeUint24 = `\r\nfloat decodeUInt24(vec3 v) {\r\n  return dot(v, vec3(1.0, 256.0, 256.0*256.0)); // v.x | (v.y << 8) | (v.z << 16)\r\n}\r\n`;\n/** @internal */\nexport const unquantize3d = `\r\nvec3 unquantize3d(vec3 qpos, vec3 origin, vec3 scale) { return origin + scale * qpos; }\r\n`;\n/** @internal */\nexport const unquantize2d = `\r\n// params.xy = origin. params.zw = scale.\r\nvec2 unquantize2d(vec2 qpos, vec4 params) { return params.xy + params.zw * qpos; }\r\n`;\n/** @internal */\nexport const decodeDepthRgb = `\r\nfloat decodeDepthRgb(vec3 rgb) { return dot(rgb, vec3(1.0, 1.0 / 255.0, 1.0 / 65025.0)); }\r\n`;\n/** @internal */\nexport const encodeDepthRgb = `\r\nvec3 encodeDepthRgb(float depth) {\r\n  // 1.0 must be reduced slightly; otherwise decoding will produce zero. It's the far plane, so we don't care (and decoding produces 1.0 anyway).\r\n  depth = min(depth, 16777215.0/16777216.0);\r\n\r\n  vec3 enc = vec3(1.0, 255.0, 65025.0) * depth;\r\n  enc = fract(enc);\r\n  enc.xy -= enc.yz / 255.0;\r\n  return enc;\r\n}\r\n`;\n/** Pack 2 floats in the integer range [0..255] into a single float equal to v.x | (v.y << 8)\n * @internal\n */\nexport const pack2Bytes = `\r\nfloat pack2Bytes(vec2 v) {\r\n  return v.x + (v.y * 256.0);\r\n}\r\n`;\n/** Unpack a float in the integer range [0..0xffff] into a vec2 containing 2 integers in the range [0..255]\n * @internal\n */\nexport const unpack2Bytes = `\r\nvec2 unpack2Bytes(float f) {\r\n  f = floor(f + 0.5);\r\n  vec2 v;\r\n  v.y = floor(f / 256.0);\r\n  v.x = floor(f - v.y * 256.0);\r\n  return v;\r\n}\r\n`;\n/** @internal */\nexport const unpackAndNormalize2Bytes = `\r\nvec2 unpackAndNormalize2Bytes(float f) {\r\n  return unpack2Bytes(f) / 255.0;\r\n}\r\n`;\n/** @internal */\nexport function addUnpackAndNormalize2Bytes(builder) {\n    builder.addFunction(unpack2Bytes);\n    builder.addFunction(unpackAndNormalize2Bytes);\n}\n/** Given an IEEE 32-bit float stuffed into a RGBA unsigned byte texture, extract the float.\n * The input vec4 components are in the integer range [0..255].\n * From https://github.com/CesiumGS/cesium/blob/main/Source/Shaders/Builtin/Functions/unpackFloat.glsl\n * @internal\n */\nexport const decodeFloat32 = `\r\nfloat decodeFloat32(vec4 packedFloat) {\r\n  float sign = 1.0 - step(128.0, packedFloat[3]) * 2.0;\r\n  float exponent = 2.0 * mod(packedFloat[3], 128.0) + step(128.0, packedFloat[2]) - 127.0;\r\n  if (exponent == -127.0)\r\n    return 0.0;\r\n\r\n  float mantissa = mod(packedFloat[2], 128.0) * 65536.0 + packedFloat[1] * 256.0 + packedFloat[0] + float(0x800000);\r\n  float result = sign * exp2(exponent - 23.0) * mantissa;\r\n  return result;\r\n}\r\n`;\nexport const decode3Float32 = `\r\n// This expects an array of 4 vec3s, where each vec4 contains a slice of all 3 of the packed floats in .xyz\r\n// pf0 is in [0].x, pf1 is in [0].y, and pf2 in [0].z\r\n// e.g.: packedFloat[0] = vec3(pf0.x, pf1.x, pf2.x)\r\n// likewise .y info is in [1], .z in [2], and .w in [3]\r\nvec3 decode3Float32(vec3 packedFloat[4]) {\r\n  vec3 sign = 1.0 - step(128.0, packedFloat[3].xyz) * 2.0;\r\n  vec3 exponent = 2.0 * mod(packedFloat[3].xyz, 128.0) + step(128.0, packedFloat[2].xyz) - 127.0;\r\n  vec3 zeroFlag = vec3(notEqual(vec3(-127.0), exponent));\r\n  vec3 mantissa = mod(packedFloat[2].xyz, 128.0) * 65536.0 + packedFloat[1].xyz * 256.0 + packedFloat[0].xyz + float(0x800000);\r\n  vec3 result = sign * exp2(exponent - 23.0) * mantissa * zeroFlag;\r\n  return result;\r\n}\r\n`;\n//# sourceMappingURL=Decode.js.map",
      "start": 1693508126436,
      "end": 1693508126539,
      "sourcemaps": null
    }
  ]
}
