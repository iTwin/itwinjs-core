{
  "resolvedId": "D:/hub2023A/itwinjs-core/test-apps/display-test-app/src/frontend/GltfDecoration.ts",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\r\n* See LICENSE.md in the project root for license terms and full copyright notice.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\nimport { Transform } from \"@itwin/core-geometry\";\r\nimport {\r\n  DecorateContext, GraphicBranch, GraphicType, IModelApp, readGltfGraphics, RenderGraphic, Tool,\r\n} from \"@itwin/core-frontend\";\r\n\r\nclass GltfDecoration {\r\n  private readonly _graphic: RenderGraphic;\r\n  private readonly _tooltip: string;\r\n  private readonly _pickableId?: string;\r\n\r\n  public constructor(graphic: RenderGraphic, tooltip: string | undefined, pickableId?: string) {\r\n    this._graphic = graphic;\r\n    this._tooltip = tooltip ?? \"glTF model\";\r\n    this._pickableId = pickableId;\r\n  }\r\n\r\n  public readonly useCachedDecorations = true;\r\n\r\n  public decorate(context: DecorateContext): void {\r\n    if (context.viewport.view.isSpatialView())\r\n      context.addDecoration(GraphicType.Scene, this._graphic);\r\n  }\r\n\r\n  public testDecorationHit(id: string): boolean {\r\n    return undefined !== this._pickableId && id === this._pickableId;\r\n  }\r\n\r\n  public async getDecorationToolTip() {\r\n    return this._tooltip;\r\n  }\r\n}\r\n\r\n/** Opens a file picker from which the user can select a glTF or glb file. Creates a decoration graphic from the glTF and\r\n * installs a decorator to display it at the center of the active viewport's iModel's project extents.\r\n */\r\nexport class GltfDecorationTool extends Tool {\r\n  public static override toolId = \"AddGltfDecoration\";\r\n  public static override get minArgs() { return 0; }\r\n  public static override get maxArgs() { return 1; }\r\n\r\n  public override async parseAndRun(...args: string[]) {\r\n    return this.run(args[0]);\r\n  }\r\n\r\n  private async queryAsset(url?: string): Promise<ArrayBuffer | undefined> {\r\n    if (url) {\r\n      const response = await fetch(url);\r\n      return response.arrayBuffer();\r\n    }\r\n\r\n    // No url specified - choose an asset from local file system.\r\n    const [handle] = await (window as any).showOpenFilePicker({\r\n      types: [\r\n        {\r\n          description: \"glTF\",\r\n          accept: { \"model/*\": [\".gltf\", \".glb\"] },\r\n        },\r\n      ],\r\n    });\r\n\r\n    const file = await handle.getFile();\r\n    return file.arrayBuffer();\r\n  }\r\n\r\n  public override async run(url?: string) {\r\n    const iModel = IModelApp.viewManager.selectedView?.iModel;\r\n    if (!iModel)\r\n      return false;\r\n\r\n    try {\r\n      const buffer = await this.queryAsset(url);\r\n      if (!buffer)\r\n        return false;\r\n\r\n      // Convert the glTF into a RenderGraphic.\r\n      const id = iModel.transientIds.getNext();\r\n      let graphic = await readGltfGraphics({\r\n        gltf: new Uint8Array(buffer),\r\n        iModel,\r\n        baseUrl: url ? new URL(url) : undefined,\r\n        pickableOptions: {\r\n          id,\r\n          // The modelId must be different from the pickable Id for the decoration to be selectable and hilite-able.\r\n          modelId: iModel.transientIds.getNext(),\r\n        },\r\n      });\r\n\r\n      if (!graphic)\r\n        return false;\r\n\r\n      // Transform the graphic to the center of the project extents.\r\n      const branch = new GraphicBranch();\r\n      branch.add(graphic);\r\n      const transform = Transform.createTranslation(iModel.projectExtents.center);\r\n      graphic = IModelApp.renderSystem.createGraphicBranch(branch, transform);\r\n\r\n      // Take ownership of the graphic so it is not disposed of until we're finished with it.\r\n      const graphicOwner = IModelApp.renderSystem.createGraphicOwner(graphic);\r\n\r\n      // Install the decorator.\r\n      const decorator = new GltfDecoration(graphicOwner, url, id);\r\n      IModelApp.viewManager.addDecorator(decorator);\r\n\r\n      // Once the iModel is closed, dispose of the graphic and uninstall the decorator.\r\n      iModel.onClose.addOnce(() => {\r\n        graphicOwner.disposeGraphic();\r\n        IModelApp.viewManager.dropDecorator(decorator);\r\n      });\r\n\r\n      return true;\r\n    } catch (_) {\r\n      return false;\r\n    }\r\n  }\r\n}\r\n",
      "start": 1693508121240,
      "end": 1693508121313,
      "sourcemaps": null
    },
    {
      "name": "vite:esbuild",
      "result": "\"use strict\";\nimport { Transform } from \"@itwin/core-geometry\";\nimport {\n  GraphicBranch,\n  GraphicType,\n  IModelApp,\n  readGltfGraphics,\n  Tool\n} from \"@itwin/core-frontend\";\nclass GltfDecoration {\n  constructor(graphic, tooltip, pickableId) {\n    this.useCachedDecorations = true;\n    this._graphic = graphic;\n    this._tooltip = tooltip ?? \"glTF model\";\n    this._pickableId = pickableId;\n  }\n  decorate(context) {\n    if (context.viewport.view.isSpatialView())\n      context.addDecoration(GraphicType.Scene, this._graphic);\n  }\n  testDecorationHit(id) {\n    return void 0 !== this._pickableId && id === this._pickableId;\n  }\n  async getDecorationToolTip() {\n    return this._tooltip;\n  }\n}\nexport class GltfDecorationTool extends Tool {\n  static get minArgs() {\n    return 0;\n  }\n  static get maxArgs() {\n    return 1;\n  }\n  async parseAndRun(...args) {\n    return this.run(args[0]);\n  }\n  async queryAsset(url) {\n    if (url) {\n      const response = await fetch(url);\n      return response.arrayBuffer();\n    }\n    const [handle] = await window.showOpenFilePicker({\n      types: [\n        {\n          description: \"glTF\",\n          accept: { \"model/*\": [\".gltf\", \".glb\"] }\n        }\n      ]\n    });\n    const file = await handle.getFile();\n    return file.arrayBuffer();\n  }\n  async run(url) {\n    const iModel = IModelApp.viewManager.selectedView?.iModel;\n    if (!iModel)\n      return false;\n    try {\n      const buffer = await this.queryAsset(url);\n      if (!buffer)\n        return false;\n      const id = iModel.transientIds.getNext();\n      let graphic = await readGltfGraphics({\n        gltf: new Uint8Array(buffer),\n        iModel,\n        baseUrl: url ? new URL(url) : void 0,\n        pickableOptions: {\n          id,\n          // The modelId must be different from the pickable Id for the decoration to be selectable and hilite-able.\n          modelId: iModel.transientIds.getNext()\n        }\n      });\n      if (!graphic)\n        return false;\n      const branch = new GraphicBranch();\n      branch.add(graphic);\n      const transform = Transform.createTranslation(iModel.projectExtents.center);\n      graphic = IModelApp.renderSystem.createGraphicBranch(branch, transform);\n      const graphicOwner = IModelApp.renderSystem.createGraphicOwner(graphic);\n      const decorator = new GltfDecoration(graphicOwner, url, id);\n      IModelApp.viewManager.addDecorator(decorator);\n      iModel.onClose.addOnce(() => {\n        graphicOwner.disposeGraphic();\n        IModelApp.viewManager.dropDecorator(decorator);\n      });\n      return true;\n    } catch (_) {\n      return false;\n    }\n  }\n}\nGltfDecorationTool.toolId = \"AddGltfDecoration\";\n",
      "start": 1693508121314,
      "end": 1693508121455,
      "order": "normal",
      "sourcemaps": {
        "version": 3,
        "sources": [
          "D:/hub2023A/itwinjs-core/test-apps/display-test-app/src/frontend/GltfDecoration.ts"
        ],
        "sourcesContent": [
          "/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\r\n* See LICENSE.md in the project root for license terms and full copyright notice.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\nimport { Transform } from \"@itwin/core-geometry\";\r\nimport {\r\n  DecorateContext, GraphicBranch, GraphicType, IModelApp, readGltfGraphics, RenderGraphic, Tool,\r\n} from \"@itwin/core-frontend\";\r\n\r\nclass GltfDecoration {\r\n  private readonly _graphic: RenderGraphic;\r\n  private readonly _tooltip: string;\r\n  private readonly _pickableId?: string;\r\n\r\n  public constructor(graphic: RenderGraphic, tooltip: string | undefined, pickableId?: string) {\r\n    this._graphic = graphic;\r\n    this._tooltip = tooltip ?? \"glTF model\";\r\n    this._pickableId = pickableId;\r\n  }\r\n\r\n  public readonly useCachedDecorations = true;\r\n\r\n  public decorate(context: DecorateContext): void {\r\n    if (context.viewport.view.isSpatialView())\r\n      context.addDecoration(GraphicType.Scene, this._graphic);\r\n  }\r\n\r\n  public testDecorationHit(id: string): boolean {\r\n    return undefined !== this._pickableId && id === this._pickableId;\r\n  }\r\n\r\n  public async getDecorationToolTip() {\r\n    return this._tooltip;\r\n  }\r\n}\r\n\r\n/** Opens a file picker from which the user can select a glTF or glb file. Creates a decoration graphic from the glTF and\r\n * installs a decorator to display it at the center of the active viewport's iModel's project extents.\r\n */\r\nexport class GltfDecorationTool extends Tool {\r\n  public static override toolId = \"AddGltfDecoration\";\r\n  public static override get minArgs() { return 0; }\r\n  public static override get maxArgs() { return 1; }\r\n\r\n  public override async parseAndRun(...args: string[]) {\r\n    return this.run(args[0]);\r\n  }\r\n\r\n  private async queryAsset(url?: string): Promise<ArrayBuffer | undefined> {\r\n    if (url) {\r\n      const response = await fetch(url);\r\n      return response.arrayBuffer();\r\n    }\r\n\r\n    // No url specified - choose an asset from local file system.\r\n    const [handle] = await (window as any).showOpenFilePicker({\r\n      types: [\r\n        {\r\n          description: \"glTF\",\r\n          accept: { \"model/*\": [\".gltf\", \".glb\"] },\r\n        },\r\n      ],\r\n    });\r\n\r\n    const file = await handle.getFile();\r\n    return file.arrayBuffer();\r\n  }\r\n\r\n  public override async run(url?: string) {\r\n    const iModel = IModelApp.viewManager.selectedView?.iModel;\r\n    if (!iModel)\r\n      return false;\r\n\r\n    try {\r\n      const buffer = await this.queryAsset(url);\r\n      if (!buffer)\r\n        return false;\r\n\r\n      // Convert the glTF into a RenderGraphic.\r\n      const id = iModel.transientIds.getNext();\r\n      let graphic = await readGltfGraphics({\r\n        gltf: new Uint8Array(buffer),\r\n        iModel,\r\n        baseUrl: url ? new URL(url) : undefined,\r\n        pickableOptions: {\r\n          id,\r\n          // The modelId must be different from the pickable Id for the decoration to be selectable and hilite-able.\r\n          modelId: iModel.transientIds.getNext(),\r\n        },\r\n      });\r\n\r\n      if (!graphic)\r\n        return false;\r\n\r\n      // Transform the graphic to the center of the project extents.\r\n      const branch = new GraphicBranch();\r\n      branch.add(graphic);\r\n      const transform = Transform.createTranslation(iModel.projectExtents.center);\r\n      graphic = IModelApp.renderSystem.createGraphicBranch(branch, transform);\r\n\r\n      // Take ownership of the graphic so it is not disposed of until we're finished with it.\r\n      const graphicOwner = IModelApp.renderSystem.createGraphicOwner(graphic);\r\n\r\n      // Install the decorator.\r\n      const decorator = new GltfDecoration(graphicOwner, url, id);\r\n      IModelApp.viewManager.addDecorator(decorator);\r\n\r\n      // Once the iModel is closed, dispose of the graphic and uninstall the decorator.\r\n      iModel.onClose.addOnce(() => {\r\n        graphicOwner.disposeGraphic();\r\n        IModelApp.viewManager.dropDecorator(decorator);\r\n      });\r\n\r\n      return true;\r\n    } catch (_) {\r\n      return false;\r\n    }\r\n  }\r\n}\r\n"
        ],
        "mappings": ";AAKA,SAAS,iBAAiB;AAC1B;AAAA,EACmB;AAAA,EAAe;AAAA,EAAa;AAAA,EAAW;AAAA,EAAiC;AAAA,OACpF;AAEP,MAAM,eAAe;AAAA,EAKZ,YAAY,SAAwB,SAA6B,YAAqB;AAM7F,SAAgB,uBAAuB;AALrC,SAAK,WAAW;AAChB,SAAK,WAAW,WAAW;AAC3B,SAAK,cAAc;AAAA,EACrB;AAAA,EAIO,SAAS,SAAgC;AAC9C,QAAI,QAAQ,SAAS,KAAK,cAAc;AACtC,cAAQ,cAAc,YAAY,OAAO,KAAK,QAAQ;AAAA,EAC1D;AAAA,EAEO,kBAAkB,IAAqB;AAC5C,WAAO,WAAc,KAAK,eAAe,OAAO,KAAK;AAAA,EACvD;AAAA,EAEA,MAAa,uBAAuB;AAClC,WAAO,KAAK;AAAA,EACd;AACF;AAKO,aAAM,2BAA2B,KAAK;AAAA,EAE3C,WAA2B,UAAU;AAAE,WAAO;AAAA,EAAG;AAAA,EACjD,WAA2B,UAAU;AAAE,WAAO;AAAA,EAAG;AAAA,EAEjD,MAAsB,eAAe,MAAgB;AACnD,WAAO,KAAK,IAAI,KAAK,CAAC,CAAC;AAAA,EACzB;AAAA,EAEA,MAAc,WAAW,KAAgD;AACvE,QAAI,KAAK;AACP,YAAM,WAAW,MAAM,MAAM,GAAG;AAChC,aAAO,SAAS,YAAY;AAAA,IAC9B;AAGA,UAAM,CAAC,MAAM,IAAI,MAAO,OAAe,mBAAmB;AAAA,MACxD,OAAO;AAAA,QACL;AAAA,UACE,aAAa;AAAA,UACb,QAAQ,EAAE,WAAW,CAAC,SAAS,MAAM,EAAE;AAAA,QACzC;AAAA,MACF;AAAA,IACF,CAAC;AAED,UAAM,OAAO,MAAM,OAAO,QAAQ;AAClC,WAAO,KAAK,YAAY;AAAA,EAC1B;AAAA,EAEA,MAAsB,IAAI,KAAc;AACtC,UAAM,SAAS,UAAU,YAAY,cAAc;AACnD,QAAI,CAAC;AACH,aAAO;AAET,QAAI;AACF,YAAM,SAAS,MAAM,KAAK,WAAW,GAAG;AACxC,UAAI,CAAC;AACH,eAAO;AAGT,YAAM,KAAK,OAAO,aAAa,QAAQ;AACvC,UAAI,UAAU,MAAM,iBAAiB;AAAA,QACnC,MAAM,IAAI,WAAW,MAAM;AAAA,QAC3B;AAAA,QACA,SAAS,MAAM,IAAI,IAAI,GAAG,IAAI;AAAA,QAC9B,iBAAiB;AAAA,UACf;AAAA;AAAA,UAEA,SAAS,OAAO,aAAa,QAAQ;AAAA,QACvC;AAAA,MACF,CAAC;AAED,UAAI,CAAC;AACH,eAAO;AAGT,YAAM,SAAS,IAAI,cAAc;AACjC,aAAO,IAAI,OAAO;AAClB,YAAM,YAAY,UAAU,kBAAkB,OAAO,eAAe,MAAM;AAC1E,gBAAU,UAAU,aAAa,oBAAoB,QAAQ,SAAS;AAGtE,YAAM,eAAe,UAAU,aAAa,mBAAmB,OAAO;AAGtE,YAAM,YAAY,IAAI,eAAe,cAAc,KAAK,EAAE;AAC1D,gBAAU,YAAY,aAAa,SAAS;AAG5C,aAAO,QAAQ,QAAQ,MAAM;AAC3B,qBAAa,eAAe;AAC5B,kBAAU,YAAY,cAAc,SAAS;AAAA,MAC/C,CAAC;AAED,aAAO;AAAA,IACT,SAAS,GAAG;AACV,aAAO;AAAA,IACT;AAAA,EACF;AACF;AA/Ea,mBACY,SAAS;",
        "names": []
      }
    }
  ]
}
