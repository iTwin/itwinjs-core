{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/markup/lib/esm/RedlineTool.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module MarkupTools\n */\n// cspell:ignore rtmp stmp\nimport { Point3d, Vector3d } from \"@itwin/core-geometry\";\nimport { CoordinateLockOverrides, CoreTools, EventHandled, IModelApp, QuantityType, ToolAssistance, ToolAssistanceImage, ToolAssistanceInputMethod, } from \"@itwin/core-frontend\";\nimport { MarkupApp } from \"./Markup\";\nimport { MarkupTool } from \"./MarkupTool\";\n/** Base class for tools that place new Markup elements\n * @public\n */\nexport class RedlineTool extends MarkupTool {\n    constructor() {\n        super(...arguments);\n        this._minPoints = 1;\n        this._nRequiredPoints = 2;\n        this._points = [];\n    }\n    onAdded(el) {\n        const markup = this.markup;\n        const undo = markup.undo;\n        undo.performOperation(this.keyin, () => undo.onAdded(el));\n        markup.selected.restart(el);\n    }\n    isComplete(_ev) { return this._points.length >= this._nRequiredPoints; }\n    setupAndPromptForNextAction() {\n        super.setupAndPromptForNextAction();\n        this.markup.disablePick();\n        IModelApp.toolAdmin.setCursor(0 === this._points.length ? IModelApp.viewManager.crossHairCursor : IModelApp.viewManager.dynamicsCursor);\n    }\n    createMarkup(_svgMarkup, _ev, _isDynamics) { }\n    clearDynamicsMarkup(_isDynamics) { this.markup.svgDynamics.clear(); }\n    async onRestartTool() { return this.exitTool(); } // Default to single shot and return control to select tool...\n    async onCleanup() { this.clearDynamicsMarkup(false); }\n    async onReinitialize() {\n        this.clearDynamicsMarkup(false);\n        return super.onReinitialize();\n    }\n    async onUndoPreviousStep() {\n        return (0 === this._points.length) ? false : (this.onReinitialize(), true);\n    }\n    async onMouseMotion(ev) {\n        if (undefined === ev.viewport || this._points.length < this._minPoints)\n            return;\n        this.clearDynamicsMarkup(true);\n        this.createMarkup(this.markup.svgDynamics, ev, true);\n    }\n    async onDataButtonDown(ev) {\n        if (undefined === ev.viewport)\n            return EventHandled.No;\n        this._points.push(MarkupApp.convertVpToVb(ev.viewPoint));\n        if (!this.isComplete(ev)) {\n            this.setupAndPromptForNextAction();\n            return EventHandled.No;\n        }\n        this.createMarkup(this.markup.svgMarkup, ev, false);\n        await this.onReinitialize();\n        return EventHandled.No;\n    }\n    async onResetButtonUp(_ev) {\n        await this.onReinitialize();\n        return EventHandled.No;\n    }\n    provideToolAssistance(mainInstrKey, singlePoint = false) {\n        const mainInstruction = ToolAssistance.createInstruction(this.iconSpec, IModelApp.localization.getLocalizedString(mainInstrKey));\n        const mouseInstructions = [];\n        const touchInstructions = [];\n        const acceptMsg = CoreTools.translate(\"ElementSet.Inputs.AcceptPoint\");\n        const rejectMsg = CoreTools.translate(\"ElementSet.Inputs.Exit\");\n        if (!ToolAssistance.createTouchCursorInstructions(touchInstructions))\n            touchInstructions.push(ToolAssistance.createInstruction(singlePoint ? ToolAssistanceImage.OneTouchTap : ToolAssistanceImage.OneTouchDrag, acceptMsg, false, ToolAssistanceInputMethod.Touch));\n        mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.LeftClick, acceptMsg, false, ToolAssistanceInputMethod.Mouse));\n        touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.TwoTouchTap, rejectMsg, false, ToolAssistanceInputMethod.Touch));\n        mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.RightClick, rejectMsg, false, ToolAssistanceInputMethod.Mouse));\n        const sections = [];\n        sections.push(ToolAssistance.createSection(mouseInstructions, ToolAssistance.inputsLabel));\n        sections.push(ToolAssistance.createSection(touchInstructions, ToolAssistance.inputsLabel));\n        const instructions = ToolAssistance.createInstructions(mainInstruction, sections);\n        IModelApp.notifications.setToolAssistance(instructions);\n    }\n}\n/** Tool for placing Markup Lines\n * @public\n */\nclass LineTool extends RedlineTool {\n    showPrompt() { this.provideToolAssistance(CoreTools.tools + (0 === this._points.length ? \"ElementSet.Prompts.StartPoint\" : \"ElementSet.Prompts.EndPoint\")); }\n    createMarkup(svgMarkup, ev, isDynamics) {\n        if (this._points.length < (isDynamics ? this._nRequiredPoints - 1 : this._nRequiredPoints))\n            return;\n        const start = this._points[0];\n        const end = isDynamics ? MarkupApp.convertVpToVb(ev.viewPoint) : this._points[1];\n        const element = svgMarkup.line(start.x, start.y, end.x, end.y);\n        this.setCurrentStyle(element, false);\n        if (!isDynamics)\n            this.onAdded(element);\n    }\n}\nLineTool.toolId = \"Markup.Line\";\nLineTool.iconSpec = \"icon-line\";\nexport { LineTool };\n/** Tool for placing Markup Rectangles\n * @public\n */\nclass RectangleTool extends RedlineTool {\n    constructor(_cornerRadius) {\n        super();\n        this._cornerRadius = _cornerRadius;\n    } // Specify radius to create a rectangle with rounded corners.\n    showPrompt() { this.provideToolAssistance(CoreTools.tools + (0 === this._points.length ? \"ElementSet.Prompts.StartCorner\" : \"ElementSet.Prompts.OppositeCorner\")); }\n    createMarkup(svgMarkup, ev, isDynamics) {\n        if (this._points.length < (isDynamics ? this._nRequiredPoints - 1 : this._nRequiredPoints))\n            return;\n        const start = this._points[0];\n        const end = isDynamics ? MarkupApp.convertVpToVb(ev.viewPoint) : this._points[1];\n        const vec = start.vectorTo(end);\n        const width = Math.abs(vec.x);\n        const height = Math.abs(vec.y);\n        if (width < 1 || height < 1)\n            return;\n        const offset = Point3d.create(vec.x < 0 ? end.x : start.x, vec.y < 0 ? end.y : start.y); // define location by corner points...\n        const element = svgMarkup.rect(width, height).move(offset.x, offset.y);\n        this.setCurrentStyle(element, true);\n        if (undefined !== this._cornerRadius)\n            element.radius(this._cornerRadius);\n        if (!isDynamics)\n            this.onAdded(element);\n    }\n}\nRectangleTool.toolId = \"Markup.Rectangle\";\nRectangleTool.iconSpec = \"icon-rectangle\";\nexport { RectangleTool };\n/** Tool for placing Markup Polygons\n * @public\n */\nclass PolygonTool extends RedlineTool {\n    constructor(_numSides) {\n        super();\n        this._numSides = _numSides;\n    } // Specify number of polygon sides. Default if undefined is 5.\n    showPrompt() { this.provideToolAssistance(MarkupTool.toolKey + (0 === this._points.length ? \"Polygon.Prompts.FirstPoint\" : \"Polygon.Prompts.NextPoint\")); }\n    getPoints(points, center, edge, numSides, inscribe) {\n        if (numSides < 3 || numSides > 100)\n            return false;\n        let radius = center.distanceXY(edge);\n        if (radius < 1)\n            return false;\n        const delta = (Math.PI * 2.0) / numSides;\n        const vec = center.vectorTo(edge);\n        let angle = Vector3d.unitX().planarRadiansTo(vec, Vector3d.unitZ());\n        if (!inscribe) {\n            const theta = delta * 0.5;\n            angle -= theta;\n            radius /= Math.cos(theta);\n        }\n        const rtmp = Point3d.create();\n        const stmp = Point3d.create();\n        for (let i = 0; i < numSides; i++, angle += delta) {\n            rtmp.x = radius * Math.cos(angle);\n            rtmp.y = radius * Math.sin(angle);\n            rtmp.z = 0.0;\n            center.plus(rtmp, stmp);\n            points.push(stmp.x);\n            points.push(stmp.y);\n        }\n        return true;\n    }\n    createMarkup(svgMarkup, ev, isDynamics) {\n        if (this._points.length < (isDynamics ? this._nRequiredPoints - 1 : this._nRequiredPoints))\n            return;\n        const center = this._points[0];\n        const edge = isDynamics ? MarkupApp.convertVpToVb(ev.viewPoint) : this._points[1];\n        const pts = [];\n        if (!this.getPoints(pts, center, edge, undefined !== this._numSides ? this._numSides : 5, true))\n            return;\n        const element = svgMarkup.polygon(pts);\n        this.setCurrentStyle(element, true);\n        if (!isDynamics)\n            this.onAdded(element);\n    }\n}\nPolygonTool.toolId = \"Markup.Polygon\";\nPolygonTool.iconSpec = \"icon-polygon\";\nexport { PolygonTool };\n/** Tool for placing Markup Clouds\n * @public\n */\nclass CloudTool extends RedlineTool {\n    showPrompt() { this.provideToolAssistance(CoreTools.tools + (0 === this._points.length ? \"ElementSet.Prompts.StartCorner\" : \"ElementSet.Prompts.OppositeCorner\")); }\n    createMarkup(svgMarkup, ev, isDynamics) {\n        if (this._points.length < (isDynamics ? this._nRequiredPoints - 1 : this._nRequiredPoints))\n            return;\n        const start = this._points[0];\n        const end = isDynamics ? MarkupApp.convertVpToVb(ev.viewPoint) : this._points[1];\n        const vec = start.vectorTo(end);\n        const width = Math.abs(vec.x);\n        const height = Math.abs(vec.y);\n        if (width < 10 || height < 10)\n            return;\n        if (undefined === this._cloud) {\n            this._cloud = svgMarkup.path(MarkupApp.props.active.cloud.path);\n        }\n        else if (!isDynamics) {\n            svgMarkup.add(this._cloud);\n        }\n        const offset = Point3d.create(vec.x < 0 ? end.x : start.x, vec.y < 0 ? end.y : start.y); // define location by corner points...\n        this._cloud.move(offset.x, offset.y);\n        this._cloud.width(width);\n        this._cloud.height(height);\n        this.setCurrentStyle(this._cloud, true);\n        if (!isDynamics)\n            this.onAdded(this._cloud);\n    }\n    clearDynamicsMarkup(isDynamics) {\n        if (!isDynamics)\n            super.clearDynamicsMarkup(isDynamics); // For dynamics we don't create a new cloud each frame, we just set the width/height...\n    }\n}\nCloudTool.toolId = \"Markup.Cloud\";\nCloudTool.iconSpec = \"icon-cloud\";\nexport { CloudTool };\n/** Tool for placing Markup Circles\n * @public\n */\nclass CircleTool extends RedlineTool {\n    showPrompt() { this.provideToolAssistance(MarkupTool.toolKey + (0 === this._points.length ? \"Circle.Prompts.FirstPoint\" : \"Circle.Prompts.NextPoint\")); }\n    createMarkup(svgMarkup, ev, isDynamics) {\n        if (this._points.length < (isDynamics ? this._nRequiredPoints - 1 : this._nRequiredPoints))\n            return;\n        const start = this._points[0];\n        const end = isDynamics ? MarkupApp.convertVpToVb(ev.viewPoint) : this._points[1];\n        const radius = start.distanceXY(end);\n        if (radius < 1)\n            return;\n        const element = svgMarkup.circle(radius * 2.0).center(start.x, start.y);\n        this.setCurrentStyle(element, true);\n        if (!isDynamics)\n            this.onAdded(element);\n    }\n}\nCircleTool.toolId = \"Markup.Circle\";\nCircleTool.iconSpec = \"icon-circle\";\nexport { CircleTool };\n/** Tool for placing Markup Ellipses\n * @public\n */\nclass EllipseTool extends RedlineTool {\n    showPrompt() { this.provideToolAssistance(CoreTools.tools + (0 === this._points.length ? \"ElementSet.Prompts.StartCorner\" : \"ElementSet.Prompts.OppositeCorner\")); }\n    createMarkup(svgMarkup, ev, isDynamics) {\n        if (this._points.length < (isDynamics ? this._nRequiredPoints - 1 : this._nRequiredPoints))\n            return;\n        const start = this._points[0];\n        const end = isDynamics ? MarkupApp.convertVpToVb(ev.viewPoint) : this._points[1];\n        const vec = start.vectorTo(end);\n        const width = Math.abs(vec.x);\n        const height = Math.abs(vec.y);\n        if (width < 1 || height < 1)\n            return;\n        const offset = Point3d.create(vec.x < 0 ? end.x : start.x, vec.y < 0 ? end.y : start.y); // define location by corner points...\n        const element = svgMarkup.ellipse(width, height).move(offset.x, offset.y);\n        this.setCurrentStyle(element, true);\n        if (!isDynamics)\n            this.onAdded(element);\n    }\n}\nEllipseTool.toolId = \"Markup.Ellipse\";\nEllipseTool.iconSpec = \"icon-ellipse\";\nexport { EllipseTool };\n/** Tool for placing Markup Arrows\n * @public\n */\nclass ArrowTool extends RedlineTool {\n    /** ctor for ArrowTool\n     * @param _arrowPos \"start\", \"end\", or \"both\". If undefined = \"end\".\n     */\n    constructor(_arrowPos) {\n        super();\n        this._arrowPos = _arrowPos;\n    }\n    showPrompt() { this.provideToolAssistance(CoreTools.tools + (0 === this._points.length ? \"ElementSet.Prompts.StartPoint\" : \"ElementSet.Prompts.EndPoint\")); }\n    getOrCreateArrowMarker(color) {\n        const arrowProps = MarkupApp.props.active.arrow;\n        return this.markup.createArrowMarker(color, arrowProps.length, arrowProps.width);\n    }\n    createMarkup(svgMarkup, ev, isDynamics) {\n        if (this._points.length < (isDynamics ? this._nRequiredPoints - 1 : this._nRequiredPoints))\n            return;\n        const start = this._points[0];\n        const end = isDynamics ? MarkupApp.convertVpToVb(ev.viewPoint) : this._points[1];\n        const vec = start.vectorTo(end);\n        if (!vec.normalizeInPlace())\n            return;\n        const element = svgMarkup.line(start.x, start.y, end.x, end.y);\n        this.setCurrentStyle(element, false);\n        const marker = this.getOrCreateArrowMarker(element.css(\"stroke\"));\n        const addToStart = (\"start\" === this._arrowPos || \"both\" === this._arrowPos);\n        const addToEnd = (\"end\" === this._arrowPos || \"both\" === this._arrowPos);\n        if (addToStart)\n            element.marker(\"start\", marker);\n        if (addToEnd || !addToStart)\n            element.marker(\"end\", marker);\n        if (!isDynamics)\n            this.onAdded(element);\n    }\n}\nArrowTool.toolId = \"Markup.Arrow\";\nArrowTool.iconSpec = \"icon-callout\";\nexport { ArrowTool };\n/** Tool for measuring distances and placing Markups of them\n * @public\n */\nclass DistanceTool extends ArrowTool {\n    constructor() {\n        super(...arguments);\n        this._startPointWorld = new Point3d();\n    }\n    showPrompt() { this.provideToolAssistance(CoreTools.tools + (0 === this._points.length ? \"ElementSet.Prompts.StartPoint\" : \"ElementSet.Prompts.EndPoint\")); }\n    setupAndPromptForNextAction() {\n        IModelApp.accuSnap.enableSnap(true);\n        IModelApp.toolAdmin.toolState.coordLockOvr = CoordinateLockOverrides.None;\n        super.setupAndPromptForNextAction();\n    }\n    getFormattedDistance(distance) {\n        const formatterSpec = IModelApp.quantityFormatter.findFormatterSpecByQuantityType(QuantityType.Length);\n        if (undefined === formatterSpec)\n            return undefined;\n        return IModelApp.quantityFormatter.formatQuantity(distance, formatterSpec);\n    }\n    createMarkup(svgMarkup, ev, isDynamics) {\n        if (this._points.length < (isDynamics ? this._nRequiredPoints - 1 : this._nRequiredPoints))\n            return;\n        const start = this._points[0];\n        const end = isDynamics ? MarkupApp.convertVpToVb(ev.viewPoint) : this._points[1];\n        const vec = start.vectorTo(end);\n        if (!vec.normalizeInPlace())\n            return;\n        const formatterSpec = IModelApp.quantityFormatter.findFormatterSpecByQuantityType(QuantityType.Length);\n        if (undefined === formatterSpec)\n            return;\n        const distanceLine = svgMarkup.line(start.x, start.y, end.x, end.y);\n        this.setCurrentStyle(distanceLine, false);\n        const marker = this.getOrCreateArrowMarker(distanceLine.css(\"stroke\"));\n        distanceLine.marker(\"start\", marker);\n        distanceLine.marker(\"end\", marker);\n        const loc = start.interpolate(0.5, end);\n        const distance = IModelApp.quantityFormatter.formatQuantity(this._startPointWorld.distance(ev.point), formatterSpec);\n        const text = svgMarkup.plain(distance).addClass(MarkupApp.textClass).attr(\"text-anchor\", \"middle\").translate(loc.x, loc.y);\n        this.setCurrentTextStyle(text);\n        const textWithBg = this.createBoxedText(svgMarkup, text);\n        if (!isDynamics) {\n            const markup = this.markup;\n            const undo = markup.undo;\n            undo.performOperation(this.keyin, () => {\n                undo.onAdded(distanceLine);\n                undo.onAdded(textWithBg);\n            });\n            markup.selected.restart(textWithBg); // Select text+box so that user can freely position relative to distance line...\n        }\n    }\n    async onDataButtonDown(ev) {\n        if (undefined === await IModelApp.quantityFormatter.getFormatterSpecByQuantityType(QuantityType.Length)) {\n            await this.onReinitialize();\n            return EventHandled.No;\n        }\n        if (0 === this._points.length)\n            this._startPointWorld.setFrom(ev.point);\n        return super.onDataButtonDown(ev);\n    }\n}\nDistanceTool.toolId = \"Markup.Distance\";\nDistanceTool.iconSpec = \"icon-distance\";\nexport { DistanceTool };\n/** Tool for placing Markup freehand sketches\n * @public\n */\nclass SketchTool extends RedlineTool {\n    constructor() {\n        super(...arguments);\n        this._minDistSquared = 100;\n    }\n    showPrompt() { this.provideToolAssistance(CoreTools.tools + (0 === this._points.length ? \"ElementSet.Prompts.StartPoint\" : \"ElementSet.Prompts.EndPoint\")); }\n    createMarkup(svgMarkup, ev, isDynamics) {\n        if (this._points.length < (isDynamics ? this._nRequiredPoints - 1 : this._nRequiredPoints))\n            return;\n        const pts = [];\n        const evPt = MarkupApp.convertVpToVb(ev.viewPoint);\n        this._points.forEach((pt) => {\n            pts.push(pt.x);\n            pts.push(pt.y);\n        });\n        if (isDynamics && !evPt.isAlmostEqualXY(this._points[this._points.length - 1])) {\n            pts.push(evPt.x);\n            pts.push(evPt.y);\n        }\n        const isClosed = (this._points.length > 2 && (this._points[0].distanceSquaredXY(isDynamics ? evPt : this._points[this._points.length - 1]) < this._minDistSquared * 2));\n        const element = isClosed ? svgMarkup.polygon(pts) : svgMarkup.polyline(pts);\n        this.setCurrentStyle(element, isClosed);\n        if (!isDynamics)\n            this.onAdded(element);\n    }\n    async onMouseMotion(ev) {\n        const evPt = MarkupApp.convertVpToVb(ev.viewPoint);\n        if (undefined !== ev.viewport && this._points.length > 0 && evPt.distanceSquaredXY(this._points[this._points.length - 1]) > this._minDistSquared)\n            this._points.push(evPt);\n        return super.onMouseMotion(ev);\n    }\n}\nSketchTool.toolId = \"Markup.Sketch\";\nSketchTool.iconSpec = \"icon-draw\";\nexport { SketchTool };\n/** Tool for placing SVG symbols on a Markup\n * @public\n */\nclass SymbolTool extends RedlineTool {\n    constructor(_symbolData, _applyCurrentStyle) {\n        super();\n        this._symbolData = _symbolData;\n        this._applyCurrentStyle = _applyCurrentStyle;\n    }\n    async onInstall() {\n        if (undefined === this._symbolData)\n            return false;\n        return super.onInstall();\n    }\n    showPrompt() {\n        this.provideToolAssistance(0 === this._points.length ? (`${MarkupTool.toolKey}Symbol.Prompts.FirstPoint`) : `${CoreTools.tools}ElementSet.Prompts.OppositeCorner`, true);\n    }\n    createMarkup(svgMarkup, ev, isDynamics) {\n        if (undefined === this._symbolData)\n            return;\n        if (this._points.length < this._minPoints)\n            return;\n        const start = this._points[0];\n        const end = isDynamics ? MarkupApp.convertVpToVb(ev.viewPoint) : this._points[this._points.length - 1];\n        const vec = start.vectorTo(end);\n        const width = Math.abs(vec.x);\n        const height = Math.abs(vec.y);\n        if ((width < 10 || height < 10) && (isDynamics || this._points.length !== this._minPoints))\n            return;\n        if (undefined === this._symbol) {\n            const symbol = svgMarkup.group().svg(this._symbolData); // creating group instead of using symbol because of inability to flash/hilite multi-color symbol instance...\n            if (0 === symbol.children().length) {\n                symbol.remove();\n                this._symbolData = undefined;\n            }\n            try {\n                symbol.flatten(symbol);\n            }\n            catch { }\n            this._symbol = symbol;\n        }\n        else if (!isDynamics) {\n            svgMarkup.add(this._symbol);\n        }\n        const offset = Point3d.create(vec.x < 0 ? end.x : start.x, vec.y < 0 ? end.y : start.y); // define location by corner points...\n        if (!isDynamics && this._points.length === this._minPoints)\n            this._symbol.size(ev.viewport.viewRect.width * 0.1).center(offset.x, offset.y);\n        else if (!ev.isShiftKey)\n            this._symbol.size(width).move(offset.x, offset.y);\n        else\n            this._symbol.size(width, height).move(offset.x, offset.y);\n        if (this._applyCurrentStyle) {\n            const active = MarkupApp.props.active; // Apply color and transparency only; using active stroke-width, etc. for pre-defined symbols is likely undesirable...\n            this._symbol.forElementsOfGroup((child) => {\n                const css = window.getComputedStyle(child.node);\n                const toValue = (val, newVal) => (!val || val === \"none\") ? \"none\" : newVal;\n                child.css({ \"fill\": toValue(css.fill, active.element.fill), \"stroke\": toValue(css.stroke, active.element.stroke), \"fill-opacity\": active.element[\"fill-opacity\"], \"stroke-opacity\": active.element[\"stroke-opacity\"] });\n            });\n        }\n        if (!isDynamics)\n            this.onAdded(this._symbol);\n    }\n    async onDataButtonUp(ev) {\n        if (undefined === ev.viewport || this._points.length !== this._minPoints)\n            return EventHandled.No;\n        this.createMarkup(this.markup.svgMarkup, ev, false);\n        await this.onReinitialize();\n        return EventHandled.No;\n    }\n    async onResetButtonUp(_ev) {\n        await this.onReinitialize();\n        return EventHandled.No;\n    }\n    clearDynamicsMarkup(isDynamics) {\n        if (!isDynamics)\n            super.clearDynamicsMarkup(isDynamics); // For dynamics we don't create a new symbol each frame, we just set the width/height...\n    }\n}\nSymbolTool.toolId = \"Markup.Symbol\";\nSymbolTool.iconSpec = \"icon-symbol\";\nexport { SymbolTool };\n//# sourceMappingURL=RedlineTool.js.map",
      "start": 1693508125561,
      "end": 1693508125725,
      "sourcemaps": null
    }
  ]
}
