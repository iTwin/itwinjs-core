{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/RealityModelUniforms.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { PointCloudDisplaySettings } from \"@itwin/core-common\";\nimport { desync, sync } from \"./Sync\";\nimport { Vector3d } from \"@itwin/core-geometry\";\n/** A Target keeps track of the current settings for drawing point clouds.\n * Pushing a Branch may *replace* the current settings. Popping the Branch does not reset them. It is expected that every Branch containing\n * a point cloud will also specify the settings for drawing that point cloud.\n * This permits the same point cloud graphics to be rendered differently in different viewports.\n * In future these uniforms will include eye-dome lighting.\n * @internal\n */\nexport class PointCloudUniforms {\n    constructor() {\n        this.syncKey = 0;\n        this._settings = PointCloudDisplaySettings.defaults;\n        this._scaleFactor = 8.0;\n        this._is3d = true;\n        // vec3 u_pointSize\n        // x = fixed point size in pixels if > 0, else scale applied to voxel size (negated).\n        // y = minimum size in pixels if using voxel size.\n        // z = maximum size in pixels if using voxel size\n        // w = 1.0 if drawing square points, 0.0 if round.\n        this._vec4 = new Float32Array(4);\n        // x = strength - 0.0 disables EDL\n        // y = radius\n        // z =\n        // w =\n        this._edl1 = new Float32Array(4);\n        this._edl2 = new Float32Array(4);\n        this.initialize(this._settings);\n    }\n    update(settings) {\n        if (this._settings.equals(settings))\n            return;\n        this._settings = settings;\n        desync(this);\n        this.initialize(settings);\n    }\n    updateRange(range, target, xform, is3d) {\n        let rangeFactor = 8.0; // default to min scale factor of 8\n        const near = target.uniforms.frustum.nearPlane;\n        const far = target.uniforms.frustum.farPlane;\n        const viewDepth = far - near;\n        if (range !== undefined) {\n            const scale = xform.matrix;\n            // calculate a \"normalized\" strength factor based on the size of the point cloud versus the current viewing depth\n            //   from the matrix, only care about scaling factor here (entries 0,4,8) to scale the range lengths\n            //   then use the largest length component as the reference for the size of the point cloud\n            const rangeScale = Vector3d.create(scale.coffs[0] * range.xLength(), scale.coffs[4] * range.xLength(), scale.coffs[8] * range.xLength()).maxAbs();\n            // limit the viewDepth/rangeScale ratio to min of 10 to still get reasonable factors when close to and inside the model\n            rangeFactor = Math.log(Math.max(10, viewDepth / rangeScale));\n        }\n        const zoomFactor = Math.log(far / near); // compensate for zoom level\n        const winSizeFactor = Math.pow(1.8440033, Math.log2(2226 / target.uniforms.viewRect.width)); // compensate for window size\n        const scaleFactor = (rangeFactor + zoomFactor) / winSizeFactor;\n        if (this._scaleFactor === scaleFactor && this._is3d === is3d)\n            return;\n        this._scaleFactor = scaleFactor;\n        this._is3d = is3d;\n        desync(this);\n        this.initialize(this._settings);\n    }\n    bind(uniform) {\n        if (!sync(this, uniform))\n            uniform.setUniform4fv(this._vec4);\n    }\n    bindEDL1(uniform) {\n        if (!sync(this, uniform))\n            uniform.setUniform4fv(this._edl1);\n    }\n    bindEDL2(uniform) {\n        if (!sync(this, uniform))\n            uniform.setUniform4fv(this._edl2);\n    }\n    initialize(settings) {\n        this._vec4[0] = \"pixel\" === settings.sizeMode ? settings.pixelSize : -settings.voxelScale;\n        this._vec4[1] = settings.minPixelsPerVoxel;\n        this._vec4[2] = settings.maxPixelsPerVoxel;\n        this._vec4[3] = \"square\" === settings.shape ? 1 : 0;\n        this._edl1[0] = settings.edlStrength;\n        this._edl1[1] = settings.edlRadius;\n        this._edl1[2] = this._scaleFactor;\n        this._edl1[3] = this._is3d ? 1 : 0;\n        this._edl2[0] = settings?.edlMixWts1 ?? 1.0;\n        this._edl2[1] = settings?.edlMixWts2 ?? 0.5;\n        this._edl2[2] = settings?.edlMixWts4 ?? 0.25;\n        this._edl2[3] = 0;\n    }\n}\n/** Uniforms affecting how reality models are drawn.\n * Pushing a Branch may *replace* the current settings. Popping the Branch does not reset them. It is expected that every Branch containing\n * a reality model will also specify the settings for drawing that reality model.\n * This permits the same reality model graphics to be rendered differently in different viewports.\n * In future these uniforms may include additional settings for reality meshes - currently only the override color ratio applies to them.\n * @internal\n */\nexport class RealityModelUniforms {\n    constructor() {\n        // ###TODO when we need it: public readonly mesh = new RealityMeshUniforms();\n        this.pointCloud = new PointCloudUniforms();\n        this._overrideColorMix = 0.5;\n    }\n    update(settings) {\n        this._overrideColorMix = settings.overrideColorRatio;\n        this.pointCloud.update(settings.pointCloud);\n    }\n    bindOverrideColorMix(uniform) {\n        uniform.setUniform1f(this._overrideColorMix);\n    }\n}\n//# sourceMappingURL=RealityModelUniforms.js.map",
      "start": 1693508124801,
      "end": 1693508125009,
      "sourcemaps": null
    }
  ]
}
