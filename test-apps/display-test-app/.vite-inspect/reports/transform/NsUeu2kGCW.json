{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/glsl/PointString.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { AttributeMap } from \"../AttributeMap\";\nimport { ProgramBuilder } from \"../ShaderBuilder\";\nimport { addColor } from \"./Color\";\nimport { addShaderFlags } from \"./Common\";\nimport { addHiliter } from \"./FeatureSymbology\";\nimport { addWhiteOnWhiteReversal } from \"./Fragment\";\nimport { addLineWeight, addModelViewProjectionMatrix } from \"./Vertex\";\nconst computePosition = `\r\n  float lineWeight = computeLineWeight();\r\n  lineWeight += 0.5 * float(lineWeight > 4.0); // fudge factor for rounding fat points...\r\n  gl_PointSize = lineWeight;\r\n  return MAT_MVP * rawPos;\r\n`;\n// gl_PointSize specifies coordinates of this fragment within the point in range [0,1].\n// This should be the most precise of the many approaches we've tried, but it still yields some asymmetry...\n// Discarding if it meets radius precisely seems to reduce that slightly...\n// ###TODO try point sprites?\nconst roundCorners = `\r\n  const vec2 center = vec2(0.5, 0.5);\r\n  vec2 vt = gl_PointCoord - center;\r\n  return dot(vt, vt) * v_roundCorners >= 0.25; // meets or exceeds radius of circle\r\n`;\nconst computeRoundCorners = \"  v_roundCorners = gl_PointSize > 4.0 ? 1.0 : 0.0;\";\nfunction createBase(instanced, positionType) {\n    const attrMap = AttributeMap.findAttributeMap(3 /* TechniqueId.PointString */, 1 /* IsInstanced.Yes */ === instanced);\n    const builder = new ProgramBuilder(attrMap, { positionType, instanced: 1 /* IsInstanced.Yes */ === instanced });\n    const vert = builder.vert;\n    vert.set(10 /* VertexShaderComponent.ComputePosition */, computePosition);\n    addModelViewProjectionMatrix(vert);\n    addLineWeight(vert);\n    builder.addInlineComputedVarying(\"v_roundCorners\", 2 /* VariableType.Float */, computeRoundCorners);\n    builder.frag.set(0 /* FragmentShaderComponent.CheckForEarlyDiscard */, roundCorners);\n    return builder;\n}\n/** @internal */\nexport function createPointStringHiliter(instanced, posType) {\n    const builder = createBase(instanced, posType);\n    addHiliter(builder, true);\n    return builder;\n}\n/** @internal */\nexport function createPointStringBuilder(instanced, posType) {\n    const builder = createBase(instanced, posType);\n    addShaderFlags(builder);\n    addColor(builder);\n    addWhiteOnWhiteReversal(builder.frag);\n    return builder;\n}\n//# sourceMappingURL=PointString.js.map",
      "start": 1693508125910,
      "end": 1693508126003,
      "sourcemaps": null
    }
  ]
}
