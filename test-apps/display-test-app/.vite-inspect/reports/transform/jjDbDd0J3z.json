{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/RenderMemory.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Rendering\n */\n/** APIs for querying memory consumed by the [[RenderSystem]].\n * Use methods like [[Viewport.collectStatistics]] and [[TileTreeReference.collectStatistics]] to query this memory usage.\n * @public\n */\nexport var RenderMemory;\n(function (RenderMemory) {\n    /** Describes memory consumed by a particular type of resource.\n     * @internal\n     */\n    class Consumers {\n        constructor() {\n            this.totalBytes = 0; // total number of bytes consumed by all consumers\n            this.maxBytes = 0; // largest number of bytes consumed by a single consumer\n            this.count = 0; // total number of consumers of this type\n        }\n        addConsumer(numBytes) {\n            this.totalBytes += numBytes;\n            this.maxBytes = Math.max(this.maxBytes, numBytes);\n            ++this.count;\n        }\n        clear() {\n            this.totalBytes = this.maxBytes = this.count = 0;\n        }\n    }\n    RenderMemory.Consumers = Consumers;\n    /** @internal */\n    let BufferType;\n    (function (BufferType) {\n        BufferType[BufferType[\"Surfaces\"] = 0] = \"Surfaces\";\n        BufferType[BufferType[\"VisibleEdges\"] = 1] = \"VisibleEdges\";\n        BufferType[BufferType[\"SilhouetteEdges\"] = 2] = \"SilhouetteEdges\";\n        BufferType[BufferType[\"PolylineEdges\"] = 3] = \"PolylineEdges\";\n        BufferType[BufferType[\"IndexedEdges\"] = 4] = \"IndexedEdges\";\n        BufferType[BufferType[\"Polylines\"] = 5] = \"Polylines\";\n        BufferType[BufferType[\"PointStrings\"] = 6] = \"PointStrings\";\n        BufferType[BufferType[\"PointClouds\"] = 7] = \"PointClouds\";\n        BufferType[BufferType[\"Instances\"] = 8] = \"Instances\";\n        BufferType[BufferType[\"Terrain\"] = 9] = \"Terrain\";\n        BufferType[BufferType[\"RealityMesh\"] = 10] = \"RealityMesh\";\n        BufferType[BufferType[\"COUNT\"] = 11] = \"COUNT\";\n    })(BufferType = RenderMemory.BufferType || (RenderMemory.BufferType = {}));\n    /** Describes memory consumed by GPU-allocated buffers.\n     * @internal\n     */\n    class Buffers extends Consumers {\n        constructor() {\n            super();\n            this.consumers = [];\n            for (let i = 0; i < BufferType.COUNT; i++)\n                this.consumers[i] = new Consumers();\n        }\n        get surfaces() { return this.consumers[BufferType.Surfaces]; }\n        get visibleEdges() { return this.consumers[BufferType.VisibleEdges]; }\n        get indexedEdges() { return this.consumers[BufferType.IndexedEdges]; }\n        get silhouetteEdges() { return this.consumers[BufferType.SilhouetteEdges]; }\n        get polylineEdges() { return this.consumers[BufferType.PolylineEdges]; }\n        get polylines() { return this.consumers[BufferType.Polylines]; }\n        get pointStrings() { return this.consumers[BufferType.PointStrings]; }\n        get pointClouds() { return this.consumers[BufferType.PointClouds]; }\n        get instances() { return this.consumers[BufferType.Instances]; }\n        get terrain() { return this.consumers[BufferType.Terrain]; }\n        get reality() { return this.consumers[BufferType.RealityMesh]; }\n        clear() {\n            for (const consumer of this.consumers)\n                consumer.clear();\n            super.clear();\n        }\n        addBuffer(type, numBytes) {\n            this.addConsumer(numBytes);\n            this.consumers[type].addConsumer(numBytes);\n        }\n    }\n    RenderMemory.Buffers = Buffers;\n    /** @internal */\n    let ConsumerType;\n    (function (ConsumerType) {\n        ConsumerType[ConsumerType[\"Textures\"] = 0] = \"Textures\";\n        ConsumerType[ConsumerType[\"VertexTables\"] = 1] = \"VertexTables\";\n        ConsumerType[ConsumerType[\"EdgeTables\"] = 2] = \"EdgeTables\";\n        ConsumerType[ConsumerType[\"FeatureTables\"] = 3] = \"FeatureTables\";\n        ConsumerType[ConsumerType[\"FeatureOverrides\"] = 4] = \"FeatureOverrides\";\n        ConsumerType[ConsumerType[\"ClipVolumes\"] = 5] = \"ClipVolumes\";\n        ConsumerType[ConsumerType[\"PlanarClassifiers\"] = 6] = \"PlanarClassifiers\";\n        ConsumerType[ConsumerType[\"ShadowMaps\"] = 7] = \"ShadowMaps\";\n        ConsumerType[ConsumerType[\"TextureAttachments\"] = 8] = \"TextureAttachments\";\n        ConsumerType[ConsumerType[\"ThematicTextures\"] = 9] = \"ThematicTextures\";\n        ConsumerType[ConsumerType[\"COUNT\"] = 10] = \"COUNT\";\n    })(ConsumerType = RenderMemory.ConsumerType || (RenderMemory.ConsumerType = {}));\n    /** Contains statistics about the amount and type of memory consumed by the [[RenderSystem]].\n     * Use methods like [[Viewport.collectStatistics]] and [[TileTreeReference.collectStatistics]] to query this memory usage.\n     * @see [[Statistics.create]] to instantiate an instance of this class.\n     * @public\n     */\n    class Statistics {\n        /** Create a new, empty statistics object. */\n        static create() {\n            return new Statistics();\n        }\n        /** @internal */\n        constructor() {\n            this._totalBytes = 0;\n            /** @internal */\n            this.buffers = new Buffers();\n            this.consumers = [];\n            for (let i = 0; i < ConsumerType.COUNT; i++)\n                this.consumers[i] = new Consumers();\n        }\n        /** The total reported memory consumption, in bytes.\n         * @note A web browser provides no direct access to actual memory used by the host device or its graphics hardware. The reported memory usage\n         * is an estimate based on the number of bytes of data requested via WebGL APIs. It is always an *under-estimate* as each WebGL implementation imposes\n         * its own additional overhead.\n         */\n        get totalBytes() { return this._totalBytes; }\n        /** @internal */\n        get textures() { return this.consumers[ConsumerType.Textures]; }\n        /** @internal */\n        get vertexTables() { return this.consumers[ConsumerType.VertexTables]; }\n        /** @internal */\n        get edgeTables() { return this.consumers[ConsumerType.EdgeTables]; }\n        /** @internal */\n        get featureTables() { return this.consumers[ConsumerType.FeatureTables]; }\n        /** @internal */\n        get thematicTextures() { return this.consumers[ConsumerType.ThematicTextures]; }\n        /** @internal */\n        get featureOverrides() { return this.consumers[ConsumerType.FeatureOverrides]; }\n        /** @internal */\n        get clipVolumes() { return this.consumers[ConsumerType.ClipVolumes]; }\n        /** @internal */\n        get planarClassifiers() { return this.consumers[ConsumerType.PlanarClassifiers]; }\n        /** @internal */\n        get shadowMaps() { return this.consumers[ConsumerType.ShadowMaps]; }\n        /** @internal */\n        get textureAttachments() { return this.consumers[ConsumerType.TextureAttachments]; }\n        /** @internal */\n        addBuffer(type, numBytes) {\n            this._totalBytes += numBytes;\n            this.buffers.addBuffer(type, numBytes);\n        }\n        /** @internal */\n        addConsumer(type, numBytes) {\n            this._totalBytes += numBytes;\n            this.consumers[type].addConsumer(numBytes);\n        }\n        /** @internal */\n        clear() {\n            this._totalBytes = 0;\n            this.buffers.clear();\n            for (const consumer of this.consumers)\n                consumer.clear();\n        }\n        /** @internal */\n        addTexture(numBytes) { this.addConsumer(ConsumerType.Textures, numBytes); }\n        /** @internal */\n        addVertexTable(numBytes) { this.addConsumer(ConsumerType.VertexTables, numBytes); }\n        /** @internal */\n        addEdgeTable(numBytes) { this.addConsumer(ConsumerType.EdgeTables, numBytes); }\n        /** @internal */\n        addFeatureTable(numBytes) { this.addConsumer(ConsumerType.FeatureTables, numBytes); }\n        /** @internal */\n        addThematicTexture(numBytes) { this.addConsumer(ConsumerType.ThematicTextures, numBytes); }\n        /** @internal */\n        addFeatureOverrides(numBytes) { this.addConsumer(ConsumerType.FeatureOverrides, numBytes); }\n        /** @internal */\n        addClipVolume(numBytes) { this.addConsumer(ConsumerType.ClipVolumes, numBytes); }\n        /** @internal */\n        addPlanarClassifier(numBytes) { this.addConsumer(ConsumerType.PlanarClassifiers, numBytes); }\n        /** @internal */\n        addShadowMap(numBytes) { this.addConsumer(ConsumerType.ShadowMaps, numBytes); }\n        /** @internal */\n        addTextureAttachment(numBytes) { this.addConsumer(ConsumerType.TextureAttachments, numBytes); }\n        /** @internal */\n        addSurface(numBytes) { this.addBuffer(BufferType.Surfaces, numBytes); }\n        /** @internal */\n        addVisibleEdges(numBytes) { this.addBuffer(BufferType.VisibleEdges, numBytes); }\n        /** @internal */\n        addIndexedEdges(numBytes) { this.addBuffer(BufferType.IndexedEdges, numBytes); }\n        /** @internal */\n        addSilhouetteEdges(numBytes) { this.addBuffer(BufferType.SilhouetteEdges, numBytes); }\n        /** @internal */\n        addPolylineEdges(numBytes) { this.addBuffer(BufferType.PolylineEdges, numBytes); }\n        /** @internal */\n        addPolyline(numBytes) { this.addBuffer(BufferType.Polylines, numBytes); }\n        /** @internal */\n        addPointString(numBytes) { this.addBuffer(BufferType.PointStrings, numBytes); }\n        /** @internal */\n        addPointCloud(numBytes) { this.addBuffer(BufferType.PointClouds, numBytes); }\n        /** @internal */\n        addTerrain(numBytes) {\n            this.addBuffer(BufferType.Terrain, numBytes);\n        }\n        /** @internal */\n        addRealityMesh(numBytes) {\n            this.addBuffer(BufferType.RealityMesh, numBytes);\n        }\n        /** @internal */\n        addInstances(numBytes) { this.addBuffer(BufferType.Instances, numBytes); }\n    }\n    RenderMemory.Statistics = Statistics;\n})(RenderMemory || (RenderMemory = {}));\n//# sourceMappingURL=RenderMemory.js.map",
      "start": 1693508119890,
      "end": 1693508119958,
      "sourcemaps": null
    }
  ]
}
