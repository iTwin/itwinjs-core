{
  "resolvedId": "D:/hub2023A/itwinjs-core/editor/frontend/lib/esm/TransformElementsTool.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Editing\n */\nimport { DialogProperty, PropertyDescriptionHelper, PropertyEditorParamTypes, } from \"@itwin/appui-abstract\";\nimport { BentleyError, Id64 } from \"@itwin/core-bentley\";\nimport { Code, ColorDef, IModelStatus, isPlacement2dProps, LinePixels, Placement2d, Placement3d, } from \"@itwin/core-common\";\nimport { AccuDrawHintBuilder, AngleDescription, CoreTools, ElementSetTool, GraphicBranch, GraphicType, IModelApp, IpcApp, ModifyElementSource, NotifyMessageDetails, OutputMessagePriority, readElementGraphics, } from \"@itwin/core-frontend\";\nimport { Angle, Geometry, Matrix3d, Point3d, Transform, Vector3d, YawPitchRollAngles } from \"@itwin/core-geometry\";\nimport { editorBuiltInCmdIds } from \"@itwin/editor-common\";\nimport { EditTools } from \"./EditTool\";\nimport { basicManipulationIpc } from \"./EditToolIpc\";\n/** A class for creating and managing RenderGraphics representing geometric elements for the purpose of interactive tool dynamics.\n * @beta\n */\nexport class TransformGraphicsProvider {\n    constructor(iModel, prefix) {\n        /** Chord tolerance to use to stroke the element's geometry in meters. */\n        this.chordTolerance = 0.01;\n        this.iModel = iModel;\n        this.prefix = prefix;\n        this.data = new Array();\n        this.pending = new Map();\n    }\n    getRequestId(id) { return `${this.prefix}-${id}`; }\n    getToleranceLog10() { return Math.floor(Math.log10(this.chordTolerance)); }\n    async createRequest(id) {\n        const elementProps = (await this.iModel.elements.getProps(id));\n        if (0 === elementProps.length)\n            return;\n        const placementProps = elementProps[0].placement;\n        if (undefined === placementProps)\n            return;\n        const placement = isPlacement2dProps(placementProps) ? Placement2d.fromJSON(placementProps) : Placement3d.fromJSON(placementProps);\n        if (!placement.isValid)\n            return; // Ignore assembly parents w/o geometry, etc...\n        const requestProps = {\n            id: this.getRequestId(id),\n            elementId: id,\n            toleranceLog10: this.getToleranceLog10(),\n        };\n        this.pending.set(id, requestProps.id); // keep track of requests so they can be cancelled...\n        const graphicData = await IModelApp.tileAdmin.requestElementGraphics(this.iModel, requestProps);\n        if (undefined === graphicData)\n            return;\n        const graphic = await readElementGraphics(graphicData, this.iModel, elementProps[0].model, placement.is3d, { noFlash: true, noHilite: true });\n        if (undefined === graphic)\n            return;\n        return { id, placement, graphic: IModelApp.renderSystem.createGraphicOwner(graphic) };\n    }\n    disposeOfGraphics() {\n        this.data.forEach((data) => {\n            data.graphic.disposeGraphic();\n        });\n        this.data.length = 0;\n    }\n    async cancelPendingRequests() {\n        const requests = new Array();\n        for (const [_key, id] of this.pending)\n            requests.push(id);\n        this.pending.clear();\n        if (0 === requests.length)\n            return;\n        return IpcApp.appFunctionIpc.cancelElementGraphicsRequests(this.iModel.key, requests);\n    }\n    /** Call to request a RenderGraphic for the supplied element id.\n   * @see [[cleanupGraphics]] Must be called when the tool exits.\n   */\n    async createSingleGraphic(id) {\n        try {\n            const info = await this.createRequest(id);\n            if (undefined !== info?.id)\n                this.pending.delete(info.id);\n            if (undefined === info?.graphic)\n                return false;\n            this.data.push(info);\n            return true;\n        }\n        catch {\n            return false;\n        }\n    }\n    /** Call to request RenderGraphics for the supplied element ids. Does not wait for results as\n     * generating graphics for a large number of elements can take time. Instead an array of [[RenderGraphicOwner]]\n     * is populated as requests are resolved and the current dynamics frame displays what is available.\n     * @see [[cleanupGraphics]] Must be called when the tool exits.\n     */\n    createGraphics(elements) {\n        if (0 === Id64.sizeOf(elements))\n            return;\n        try {\n            for (const id of Id64.iterable(elements)) {\n                const promise = this.createRequest(id);\n                // eslint-disable-next-line @typescript-eslint/no-floating-promises\n                promise.then((info) => {\n                    if (undefined !== info?.id)\n                        this.pending.delete(info.id);\n                    if (undefined !== info?.graphic)\n                        this.data.push(info);\n                });\n            }\n        }\n        catch { }\n    }\n    /** Call to dispose of [[RenderGraphic]] held by [[RenderGraphicOwner]] and cancel requests that are still pending.\n     * @note Must be called when the tool exits to avoid leaks of graphics memory or other webgl resources.\n     */\n    async cleanupGraphics() {\n        await this.cancelPendingRequests();\n        this.disposeOfGraphics();\n    }\n    addSingleGraphic(graphic, transform, context) {\n        const branch = new GraphicBranch(false);\n        branch.add(graphic);\n        const branchGraphic = context.createBranch(branch, transform);\n        context.addGraphic(branchGraphic);\n    }\n    addGraphics(transform, context) {\n        if (0 === this.data.length)\n            return;\n        const branch = new GraphicBranch(false);\n        for (const data of this.data)\n            branch.add(data.graphic);\n        const branchGraphic = context.createBranch(branch, transform);\n        context.addGraphic(branchGraphic);\n    }\n}\n/** Edit tool base class for applying a transform to element placements.\n * @beta\n */\nexport class TransformElementsTool extends ElementSetTool {\n    get allowSelectionSet() { return true; }\n    get allowGroups() { return true; }\n    get allowDragSelect() { return true; }\n    get controlKeyContinuesSelection() { return true; }\n    get wantAccuSnap() { return true; }\n    get wantDynamics() { return true; }\n    get wantMakeCopy() { return false; }\n    get wantRepeatOperation() { return this.wantMakeCopy && !this.agenda.isEmpty; }\n    async createAgendaGraphics(changed) {\n        if (changed) {\n            if (undefined === this._graphicsProvider)\n                return; // Not yet needed...\n        }\n        else {\n            if (undefined !== this._graphicsProvider)\n                return; // Use existing graphics...\n        }\n        if (undefined === this._graphicsProvider)\n            this._graphicsProvider = new TransformGraphicsProvider(this.iModel, this.toolId);\n        else\n            await this._graphicsProvider.cleanupGraphics();\n        if (1 === this.agenda.length) {\n            await this._graphicsProvider.createSingleGraphic(this.agenda.elements[0]);\n            return;\n        }\n        this._graphicsProvider.createGraphics(this.agenda.elements);\n    }\n    async clearAgendaGraphics() {\n        if (undefined === this._graphicsProvider)\n            return;\n        await this._graphicsProvider.cleanupGraphics();\n        this._graphicsProvider = undefined;\n    }\n    async onAgendaModified() {\n        await this.createAgendaGraphics(true);\n    }\n    async initAgendaDynamics() {\n        await this.createAgendaGraphics(false);\n        return super.initAgendaDynamics();\n    }\n    transformAgendaDynamics(transform, context) {\n        if (undefined !== this._graphicsProvider)\n            this._graphicsProvider.addGraphics(transform, context);\n    }\n    onDynamicFrame(ev, context) {\n        const transform = this.calculateTransform(ev);\n        if (undefined === transform)\n            return;\n        this.transformAgendaDynamics(transform, context);\n    }\n    updateAnchorLocation(transform) {\n        // Update anchor point to support creating additional copies (repeat vs. restart)...\n        if (undefined === this.anchorPoint)\n            return;\n        transform.multiplyPoint3d(this.anchorPoint, this.anchorPoint);\n        const hints = new AccuDrawHintBuilder();\n        hints.setOrigin(this.anchorPoint);\n        hints.sendHints();\n    }\n    async startCommand() {\n        if (undefined !== this._startedCmd)\n            return this._startedCmd;\n        return EditTools.startCommand({ commandId: editorBuiltInCmdIds.cmdBasicManipulation, iModelKey: this.iModel.key });\n    }\n    async replaceAgenda(newIds) {\n        this.agenda.clear();\n        if (undefined !== newIds)\n            this.agenda.add(newIds);\n        if (this.isSelectionSetModify) {\n            if (this.agenda.isEmpty)\n                this.iModel.selectionSet.emptyAll();\n            else\n                this.iModel.selectionSet.replace(this.agenda.elements);\n            this.agenda.setSource(ModifyElementSource.SelectionSet);\n            this.setPreferredElementSource(); // Update \"use selection set\" flag...\n        }\n        return this.onAgendaModified();\n    }\n    async transformAndCopyAgenda(_transform) {\n        return undefined;\n    }\n    async transformAgenda(transform) {\n        try {\n            this._startedCmd = await this.startCommand();\n            if (IModelStatus.Success === await basicManipulationIpc.transformPlacement(this.agenda.compressIds(), transform.toJSON()))\n                await this.saveChanges();\n        }\n        catch (err) {\n            IModelApp.notifications.outputMessage(new NotifyMessageDetails(OutputMessagePriority.Error, BentleyError.getErrorMessage(err) || \"An unknown error occurred.\"));\n        }\n    }\n    async processAgenda(ev) {\n        const transform = this.calculateTransform(ev);\n        if (undefined === transform)\n            return;\n        if (this.wantMakeCopy)\n            await this.replaceAgenda(await this.transformAndCopyAgenda(transform));\n        else\n            await this.transformAgenda(transform);\n        this.updateAnchorLocation(transform);\n    }\n    async onProcessComplete() {\n        if (this.wantRepeatOperation)\n            return; // Continue with current agenda instead of restarting (ex. create additional copies)\n        return super.onProcessComplete();\n    }\n    async onCleanup() {\n        await this.clearAgendaGraphics();\n        return super.onCleanup();\n    }\n}\n/** @alpha Move elements by applying translation to placement. */\nclass MoveElementsTool extends TransformElementsTool {\n    calculateTransform(ev) {\n        if (undefined === this.anchorPoint)\n            return undefined;\n        return Transform.createTranslation(ev.point.minus(this.anchorPoint));\n    }\n    provideToolAssistance(_mainInstrText, _additionalInstr) {\n        let mainMsg;\n        if (!this.isSelectByPoints && !this.wantAdditionalElements)\n            mainMsg = CoreTools.translate(this.wantAdditionalInput ? \"ElementSet.Prompts.StartPoint\" : \"ElementSet.Prompts.EndPoint\");\n        super.provideToolAssistance(mainMsg);\n    }\n    async onRestartTool() {\n        const tool = new MoveElementsTool();\n        if (!await tool.run())\n            return this.exitTool();\n    }\n}\nMoveElementsTool.toolId = \"MoveElements\";\nMoveElementsTool.iconSpec = \"icon-move\";\nexport { MoveElementsTool };\n/** Create new elements with translation applied to placement.\n * This is a brute force implementation strictly for example and testing purposes.\n * The new elements are Generic:PhysicalObject or BisCore:DrawingGraphic using the model and category of original.\n * Does not preserve assemblies and geometric elements without geometry are not copied.\n * Using loadProps to return json format geometry to the frontend for each element in the tool agenda is very inefficient.\n * Applications that wish to support copy are expected to sub-class TransformElementsTool and register their\n * own EditCommand that can correctly copy their application elements.\n * @alpha\n */\nclass CopyElementsTool extends MoveElementsTool {\n    static get minArgs() { return 0; }\n    static get maxArgs() { return 1; }\n    get numCopiesProperty() {\n        if (!this._numCopiesProperty)\n            this._numCopiesProperty = new DialogProperty(PropertyDescriptionHelper.buildNumberEditorDescription(\"numCopies\", EditTools.translate(\"CopyElements.Label.NumCopies\"), { type: PropertyEditorParamTypes.Range, minimum: 1 }), 1);\n        return this._numCopiesProperty;\n    }\n    get numCopies() { return this.numCopiesProperty.value; }\n    set numCopies(value) { this.numCopiesProperty.value = value; }\n    get wantMakeCopy() { return this.numCopies > 0; }\n    updateAnchorLocation(transform) {\n        // Account for additional copies for repeat operation anchor point...\n        for (let iCopy = 0; iCopy < this.numCopies; ++iCopy)\n            super.updateAnchorLocation(transform);\n    }\n    async doTransformedCopy(ids, transform, numCopies) {\n        if (numCopies < 1 || 0 === ids.length)\n            return undefined;\n        this._startedCmd = await this.startCommand();\n        const newIds = [];\n        for (const id of ids) {\n            // NOTE: For testing only. Using loadProps to return json format geometry to the frontend for each element in the tool agenda is very inefficient.\n            const props = await this.iModel.elements.loadProps(id, { wantGeometry: true, wantBRepData: true });\n            if (undefined === props.placement)\n                continue;\n            const placement = isPlacement2dProps(props.placement) ? Placement2d.fromJSON(props.placement) : Placement3d.fromJSON(props.placement);\n            if (!placement.isValid)\n                continue; // Ignore assembly parents w/o geometry, etc...\n            const classFullName = (placement.is3d ? \"Generic:PhysicalObject\" : \"BisCore:DrawingGraphic\");\n            const newProps = { classFullName, model: props.model, category: props.category, code: Code.createEmpty(), placement, geom: props.geom };\n            let newId;\n            for (let iCopy = 0; iCopy < numCopies; ++iCopy) {\n                placement.multiplyTransform(transform);\n                newId = await basicManipulationIpc.insertGeometricElement(newProps);\n            }\n            if (undefined !== newId)\n                newIds.push(newId); // When numCopies > 1 ids are return for just the final copy...\n        }\n        return (0 === newIds.length ? undefined : newIds);\n    }\n    async transformAndCopyAgenda(transform) {\n        try {\n            const newIds = await this.doTransformedCopy(this.agenda.elements, transform, this.numCopies);\n            if (undefined !== newIds)\n                await this.saveChanges();\n            return newIds;\n        }\n        catch (err) {\n            IModelApp.notifications.outputMessage(new NotifyMessageDetails(OutputMessagePriority.Error, BentleyError.getErrorMessage(err) || \"An unknown error occurred.\"));\n            return undefined;\n        }\n    }\n    async applyToolSettingPropertyChange(updatedValue) {\n        // NOTE: Don't call changeToolSettingPropertyValue, value of numCopies should not be saved...\n        if (updatedValue.propertyName !== this.numCopiesProperty.name || undefined === updatedValue.value.value)\n            return false;\n        this.numCopies = updatedValue.value.value;\n        return true;\n    }\n    supplyToolSettingsProperties() {\n        // NOTE: Don't call initializeToolSettingPropertyValues, value of numCopies is not saved...\n        const toolSettings = new Array();\n        toolSettings.push(this.numCopiesProperty.toDialogItem({ rowPriority: 1, columnIndex: 2 }));\n        return toolSettings;\n    }\n    async onRestartTool() {\n        const tool = new CopyElementsTool();\n        tool.numCopies = this.numCopies; // Preserve numCopies on restart...\n        if (!await tool.run())\n            return this.exitTool();\n    }\n    /** The keyin takes the following arguments, all of which are optional:\n     *  - `numCopies=number` Number of copies of each element to create, default is 1.\n     */\n    async parseAndRun(...inputArgs) {\n        for (const arg of inputArgs) {\n            const parts = arg.split(\"=\");\n            if (2 !== parts.length)\n                continue;\n            if (parts[0].toLowerCase().startsWith(\"num\")) {\n                const copies = Number.parseInt(parts[1], 10);\n                if (copies >= 1)\n                    this.numCopies = copies; // NOTE: Don't call saveToolSettingPropertyValue, always default to single copy...\n            }\n        }\n        return this.run();\n    }\n}\nCopyElementsTool.toolId = \"CopyElements\";\nCopyElementsTool.iconSpec = \"icon-move\"; // Need better icon...\nexport { CopyElementsTool };\n/** @alpha */\nexport var RotateMethod;\n(function (RotateMethod) {\n    RotateMethod[RotateMethod[\"By3Points\"] = 0] = \"By3Points\";\n    RotateMethod[RotateMethod[\"ByAngle\"] = 1] = \"ByAngle\";\n})(RotateMethod || (RotateMethod = {}));\n/** @alpha */\nexport var RotateAbout;\n(function (RotateAbout) {\n    RotateAbout[RotateAbout[\"Point\"] = 0] = \"Point\";\n    RotateAbout[RotateAbout[\"Origin\"] = 1] = \"Origin\";\n    RotateAbout[RotateAbout[\"Center\"] = 2] = \"Center\";\n})(RotateAbout || (RotateAbout = {}));\n/** @alpha Rotate elements by applying transform to placement. */\nclass RotateElementsTool extends TransformElementsTool {\n    constructor() {\n        super(...arguments);\n        this.havePivotPoint = false;\n        this.haveFinalPoint = false;\n    }\n    static get minArgs() { return 0; }\n    static get maxArgs() { return 3; }\n    static methodMessage(str) { return EditTools.translate(`RotateElements.Method.${str}`); }\n    get methodProperty() {\n        if (!this._methodProperty)\n            this._methodProperty = new DialogProperty(PropertyDescriptionHelper.buildEnumPicklistEditorDescription(\"rotateMethod\", EditTools.translate(\"RotateElements.Label.Method\"), RotateElementsTool.getMethodChoices()), RotateMethod.By3Points);\n        return this._methodProperty;\n    }\n    get rotateMethod() { return this.methodProperty.value; }\n    set rotateMethod(method) { this.methodProperty.value = method; }\n    static aboutMessage(str) { return EditTools.translate(`RotateElements.About.${str}`); }\n    get aboutProperty() {\n        if (!this._aboutProperty)\n            this._aboutProperty = new DialogProperty(PropertyDescriptionHelper.buildEnumPicklistEditorDescription(\"rotateAbout\", EditTools.translate(\"RotateElements.Label.About\"), RotateElementsTool.getAboutChoices()), RotateAbout.Point);\n        return this._aboutProperty;\n    }\n    get rotateAbout() { return this.aboutProperty.value; }\n    set rotateAbout(method) { this.aboutProperty.value = method; }\n    get angleProperty() {\n        if (!this._angleProperty)\n            this._angleProperty = new DialogProperty(new AngleDescription(\"rotateAngle\", EditTools.translate(\"RotateElements.Label.Angle\")), 0.0);\n        return this._angleProperty;\n    }\n    get rotateAngle() { return this.angleProperty.value; }\n    set rotateAngle(value) { this.angleProperty.value = value; }\n    get requireAcceptForSelectionSetDynamics() { return RotateMethod.ByAngle !== this.rotateMethod; }\n    calculateTransform(ev) {\n        if (undefined === ev.viewport)\n            return undefined;\n        if (RotateMethod.ByAngle === this.rotateMethod) {\n            const rotMatrix = AccuDrawHintBuilder.getCurrentRotation(ev.viewport, true, true);\n            if (undefined === rotMatrix)\n                return undefined;\n            const invMatrix = rotMatrix.inverse();\n            if (undefined === invMatrix)\n                return undefined;\n            const angMatrix = YawPitchRollAngles.createRadians(this.rotateAngle, 0, 0).toMatrix3d();\n            if (undefined === angMatrix)\n                return undefined;\n            angMatrix.multiplyMatrixMatrix(invMatrix, invMatrix);\n            rotMatrix.multiplyMatrixMatrix(invMatrix, rotMatrix);\n            return Transform.createFixedPointAndMatrix(ev.point, rotMatrix);\n        }\n        if (undefined === this.anchorPoint || undefined === this.xAxisPoint)\n            return undefined;\n        const vec1 = Vector3d.createStartEnd(this.anchorPoint, this.xAxisPoint);\n        const vec2 = Vector3d.createStartEnd(this.anchorPoint, ev.point);\n        if (!vec1.normalizeInPlace() || !vec2.normalizeInPlace())\n            return undefined;\n        const dot = vec1.dotProduct(vec2);\n        if (dot > (1.0 - Geometry.smallAngleRadians))\n            return undefined;\n        if (dot < (-1.0 + Geometry.smallAngleRadians)) {\n            const rotMatrix = AccuDrawHintBuilder.getCurrentRotation(ev.viewport, true, true);\n            if (undefined === rotMatrix)\n                return undefined;\n            const invMatrix = rotMatrix.inverse();\n            if (undefined === invMatrix)\n                return undefined;\n            const angMatrix = YawPitchRollAngles.createRadians(Math.PI, 0, 0).toMatrix3d(); // 180 degree rotation...\n            if (undefined === angMatrix)\n                return undefined;\n            angMatrix.multiplyMatrixMatrix(invMatrix, invMatrix);\n            rotMatrix.multiplyMatrixMatrix(invMatrix, rotMatrix);\n            return Transform.createFixedPointAndMatrix(this.anchorPoint, rotMatrix);\n        }\n        const zVec = vec1.unitCrossProduct(vec2);\n        if (undefined === zVec)\n            return undefined;\n        const yVec = zVec.unitCrossProduct(vec1);\n        if (undefined === yVec)\n            return undefined;\n        const matrix1 = Matrix3d.createRows(vec1, yVec, zVec);\n        zVec.unitCrossProduct(vec2, yVec);\n        const matrix2 = Matrix3d.createColumns(vec2, yVec, zVec);\n        const matrix = matrix2.multiplyMatrixMatrix(matrix1);\n        if (undefined === matrix)\n            return undefined;\n        return Transform.createFixedPointAndMatrix(this.anchorPoint, matrix);\n    }\n    transformAgendaDynamics(transform, context) {\n        if (RotateAbout.Point === this.rotateAbout)\n            return super.transformAgendaDynamics(transform, context);\n        if (undefined === this._graphicsProvider)\n            return;\n        const rotatePoint = Point3d.create();\n        for (const data of this._graphicsProvider.data) {\n            if (RotateAbout.Origin === this.rotateAbout)\n                rotatePoint.setFrom(data.placement.origin);\n            else\n                rotatePoint.setFrom(data.placement.calculateRange().center);\n            const rotateTrans = Transform.createFixedPointAndMatrix(rotatePoint, transform.matrix);\n            this._graphicsProvider.addSingleGraphic(data.graphic, rotateTrans, context);\n        }\n    }\n    async transformAgenda(transform) {\n        if (RotateAbout.Point === this.rotateAbout)\n            return super.transformAgenda(transform);\n        try {\n            this._startedCmd = await this.startCommand();\n            if (IModelStatus.Success === await basicManipulationIpc.rotatePlacement(this.agenda.compressIds(), transform.matrix.toJSON(), RotateAbout.Center === this.rotateAbout))\n                await this.saveChanges();\n        }\n        catch (err) {\n            IModelApp.notifications.outputMessage(new NotifyMessageDetails(OutputMessagePriority.Error, BentleyError.getErrorMessage(err) || \"An unknown error occurred.\"));\n        }\n    }\n    onDynamicFrame(ev, context) {\n        const transform = this.calculateTransform(ev);\n        if (undefined !== transform)\n            return this.transformAgendaDynamics(transform, context);\n        if (undefined === this.anchorPoint)\n            return;\n        const builder = context.createGraphic({ type: GraphicType.WorldOverlay });\n        builder.setSymbology(context.viewport.getContrastToBackgroundColor(), ColorDef.black, 1, LinePixels.Code2);\n        builder.addLineString([this.anchorPoint.clone(), ev.point.clone()]);\n        context.addGraphic(builder.finish());\n    }\n    get wantAdditionalInput() {\n        if (RotateMethod.ByAngle === this.rotateMethod)\n            return super.wantAdditionalInput;\n        return !this.haveFinalPoint;\n    }\n    wantProcessAgenda(ev) {\n        if (RotateMethod.ByAngle === this.rotateMethod)\n            return super.wantProcessAgenda(ev);\n        if (!this.havePivotPoint)\n            this.havePivotPoint = true; // Uses anchorPoint...\n        else if (undefined === this.xAxisPoint)\n            this.xAxisPoint = ev.point.clone();\n        else if (!this.haveFinalPoint)\n            this.haveFinalPoint = true; // Uses button event...\n        return super.wantProcessAgenda(ev);\n    }\n    setupAndPromptForNextAction() {\n        super.setupAndPromptForNextAction();\n        if (RotateMethod.ByAngle === this.rotateMethod)\n            return;\n        if (undefined === this.anchorPoint || undefined === this.xAxisPoint)\n            return;\n        const hints = new AccuDrawHintBuilder();\n        hints.setXAxis(Vector3d.createStartEnd(this.anchorPoint, this.xAxisPoint));\n        hints.setOrigin(this.anchorPoint);\n        hints.setModePolar();\n        hints.sendHints();\n    }\n    provideToolAssistance(_mainInstrText, _additionalInstr) {\n        let mainMsg;\n        if (RotateMethod.ByAngle === this.rotateMethod) {\n            if (!this.isSelectByPoints && !this.wantAdditionalElements && this.wantAdditionalInput)\n                mainMsg = EditTools.translate(\"RotateElements.Prompts.IdentifyPoint\");\n        }\n        else {\n            if (!this.isSelectByPoints && !this.wantAdditionalElements) {\n                if (!this.havePivotPoint)\n                    mainMsg = EditTools.translate(\"RotateElements.Prompts.IdentifyPoint\");\n                else if (undefined === this.xAxisPoint)\n                    mainMsg = EditTools.translate(\"RotateElements.Prompts.DefineStart\");\n                else\n                    mainMsg = EditTools.translate(\"RotateElements.Prompts.DefineAmount\");\n            }\n        }\n        super.provideToolAssistance(mainMsg);\n    }\n    async applyToolSettingPropertyChange(updatedValue) {\n        if (!this.changeToolSettingPropertyValue(updatedValue))\n            return false;\n        if (this.methodProperty.name === updatedValue.propertyName)\n            await this.onRestartTool(); // calling restart, not reinitialize to not exit tool for selection set...\n        return true;\n    }\n    supplyToolSettingsProperties() {\n        const toolSettings = new Array();\n        toolSettings.push(this.methodProperty.toDialogItem({ rowPriority: 1, columnIndex: 2 }));\n        toolSettings.push(this.aboutProperty.toDialogItem({ rowPriority: 2, columnIndex: 2 }));\n        if (RotateMethod.ByAngle === this.rotateMethod)\n            toolSettings.push(this.angleProperty.toDialogItem({ rowPriority: 3, columnIndex: 2 }));\n        return toolSettings;\n    }\n    async onRestartTool() {\n        const tool = new RotateElementsTool();\n        if (!await tool.run())\n            return this.exitTool();\n    }\n    async onInstall() {\n        if (!await super.onInstall())\n            return false;\n        // Setup initial values here instead of supplyToolSettingsProperties to support keyin args w/o appui-react...\n        this.initializeToolSettingPropertyValues([this.methodProperty, this.aboutProperty, this.angleProperty]);\n        return true;\n    }\n    /** The keyin takes the following arguments, all of which are optional:\n     *  - `method=0|1` How rotate angle will be specified. 0 for by 3 points, 1 for by specified angle.\n     *  - `about=0|1|2` Location to rotate about. 0 for point, 1 for placement origin, and 2 for center of range.\n     *  - `angle=number` Rotation angle in degrees when not defining angle by points.\n     */\n    async parseAndRun(...inputArgs) {\n        let rotateMethod;\n        let rotateAbout;\n        let rotateAngle;\n        for (const arg of inputArgs) {\n            const parts = arg.split(\"=\");\n            if (2 !== parts.length)\n                continue;\n            if (parts[0].toLowerCase().startsWith(\"me\")) {\n                const method = Number.parseInt(parts[1], 10);\n                if (!Number.isNaN(method)) {\n                    switch (method) {\n                        case 0:\n                            rotateMethod = RotateMethod.By3Points;\n                            break;\n                        case 1:\n                            rotateMethod = RotateMethod.ByAngle;\n                            break;\n                    }\n                }\n            }\n            else if (parts[0].toLowerCase().startsWith(\"ab\")) {\n                const about = Number.parseInt(parts[1], 10);\n                if (!Number.isNaN(about)) {\n                    switch (about) {\n                        case 0:\n                            rotateAbout = RotateAbout.Point;\n                            break;\n                        case 1:\n                            rotateAbout = RotateAbout.Origin;\n                            break;\n                        case 2:\n                            rotateAbout = RotateAbout.Center;\n                            break;\n                    }\n                }\n            }\n            else if (parts[0].toLowerCase().startsWith(\"an\")) {\n                const angle = Number.parseFloat(parts[1]);\n                if (!Number.isNaN(angle)) {\n                    rotateAngle = Angle.createDegrees(angle).radians;\n                }\n            }\n        }\n        // Update current session values so keyin args are picked up for tool settings/restart...\n        if (undefined !== rotateMethod)\n            this.saveToolSettingPropertyValue(this.methodProperty, { value: rotateMethod });\n        if (undefined !== rotateAbout)\n            this.saveToolSettingPropertyValue(this.aboutProperty, { value: rotateAbout });\n        if (undefined !== rotateAngle)\n            this.saveToolSettingPropertyValue(this.angleProperty, { value: rotateAngle });\n        return this.run();\n    }\n}\nRotateElementsTool.toolId = \"RotateElements\";\nRotateElementsTool.iconSpec = \"icon-rotate\";\nRotateElementsTool.getMethodChoices = () => {\n    return [\n        { label: RotateElementsTool.methodMessage(\"3Points\"), value: RotateMethod.By3Points },\n        { label: RotateElementsTool.methodMessage(\"Angle\"), value: RotateMethod.ByAngle },\n    ];\n};\nRotateElementsTool.getAboutChoices = () => {\n    return [\n        { label: RotateElementsTool.aboutMessage(\"Point\"), value: RotateAbout.Point },\n        { label: RotateElementsTool.aboutMessage(\"Origin\"), value: RotateAbout.Origin },\n        { label: RotateElementsTool.aboutMessage(\"Center\"), value: RotateAbout.Center },\n    ];\n};\nexport { RotateElementsTool };\n//# sourceMappingURL=TransformElementsTool.js.map",
      "start": 1693508122948,
      "end": 1693508123152,
      "sourcemaps": null
    }
  ]
}
