{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/bentley/lib/esm/Dictionary.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Collections\n */\nimport { lowerBound, shallowClone } from \"./SortedArray\";\nclass DictionaryIterator {\n    constructor(keys, values) {\n        this._curIndex = -1;\n        this._keys = keys;\n        this._values = values;\n    }\n    next() {\n        if (++this._curIndex >= this._keys.length) {\n            // The ECMAScript spec states that value=undefined is valid if done=true. The TypeScript interface violates the spec hence the cast to any and back below.\n            return { done: true };\n        }\n        else {\n            return {\n                value: {\n                    key: this._keys[this._curIndex],\n                    value: this._values[this._curIndex],\n                },\n                done: false,\n            };\n        }\n    }\n}\n/**\n * Maintains a mapping of keys to values.\n * Unlike the standard Map<K, V>, a Dictionary<K, V> supports custom comparison logic for keys of object type (and for any other type).\n * The user supplies a key comparison function to the constructor, that must meet the following criteria given 'lhs' and 'rhs' of type K:\n *  - If lhs is equal to rhs, returns 0\n *  - If lhs is less than rhs, returns a negative value\n *  - If lhs is greater than rhs, returns a positive value\n *  - If compare(lhs, rhs) returns 0, then compare(rhs, lhs) must also return 0\n *  - If compare(lhs, rhs) returns a negative value, then compare(rhs, lhs) must return a positive value, and vice versa.\n *\n * Modifying a key in a way that affects the comparison function will produce unpredictable results, the\n * most likely of which is that keys will cease to map to the values with which they were initially inserted.\n * @public\n */\nexport class Dictionary {\n    /**\n     * Construct a new Dictionary<K, V>.\n     * @param compareKeys The function used to compare keys within the dictionary.\n     * @param cloneKey The function invoked to clone a key for insertion into the dictionary. The default implementation simply returns its input.\n     * @param cloneValue The function invoked to clone a value for insertion into the dictionary. The default implementation simply returns its input.\n     */\n    constructor(compareKeys, cloneKey = shallowClone, cloneValue = shallowClone) {\n        this._keys = [];\n        this._values = [];\n        this._compareKeys = compareKeys;\n        this._cloneKey = cloneKey;\n        this._cloneValue = cloneValue;\n    }\n    /** The number of entries in the dictionary. */\n    get size() { return this._keys.length; }\n    /** Returns an iterator over the key-value pairs in the Dictionary suitable for use in `for-of` loops. Entries are returned in sorted order by key. */\n    [Symbol.iterator]() {\n        return new DictionaryIterator(this._keys, this._values);\n    }\n    /** Provides iteration over the keys in this Dictionary, in sorted order. */\n    keys() {\n        function* iterator(dict) {\n            for (const entry of dict)\n                yield entry.key;\n        }\n        return {\n            [Symbol.iterator]: () => iterator(this),\n        };\n    }\n    /** Provides iteration over the values in this Dictionary, in sorted order by the corresponding keys. */\n    values() {\n        function* iterator(dict) {\n            for (const entry of dict)\n                yield entry.value;\n        }\n        return {\n            [Symbol.iterator]: () => iterator(this),\n        };\n    }\n    /** Removes all entries from this dictionary */\n    clear() {\n        this._keys = [];\n        this._values = [];\n    }\n    /**\n     * Looks up a value by its key.\n     * @param key The key to search for\n     * @returns the value associated with the key, or undefined if the key is not present in the dictionary.\n     */\n    get(key) {\n        const bound = this.lowerBound(key);\n        return bound.equal ? this._values[bound.index] : undefined;\n    }\n    /**\n     * Determines if an entry exists for the specified key\n     * @param key The key to search for\n     * @returns true if an entry exists in this dictionary corresponding to the specified key.\n     */\n    has(key) {\n        return this.lowerBound(key).equal;\n    }\n    /**\n     * Deletes a value using its key.\n     * @param key The key to delete\n     * @returns true if the key was found and deleted.\n     */\n    delete(key) {\n        const bound = this.lowerBound(key);\n        if (bound.equal) {\n            this._values.splice(bound.index, 1);\n            this._keys.splice(bound.index, 1);\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    /**\n     * Attempts to insert a new entry into the dictionary. If an entry with an equivalent key exists, the dictionary is unmodified.\n     * If the new entry is in fact inserted, both the key and value will be cloned using the functions supplied to the dictionary's constructor.\n     * @param key The key to associate with the value\n     * @param value The value to associate with the key\n     * @returns true if the new entry was inserted, false if an entry with an equivalent key already exists.\n     */\n    insert(key, value) {\n        const result = this.findOrInsert(key, value);\n        return result.inserted;\n    }\n    /** Obtains the value associated with the specified key, or inserts it if the specified key does not yet exist.\n     * @param key The key to search for.\n     * @param value The value to associate with `key` if `key` does not yet exist in the dictionary.\n     * @returns The found or inserted value and a flag indicating whether the new value was inserted.\n     */\n    findOrInsert(key, value) {\n        const bound = this.lowerBound(key);\n        if (bound.equal)\n            return { value: this._values[bound.index], inserted: false };\n        value = this._cloneValue(value);\n        this._keys.splice(bound.index, 0, this._cloneKey(key));\n        this._values.splice(bound.index, 0, this._cloneValue(value));\n        return { value, inserted: true };\n    }\n    /**\n     * Sets the value associated with the specified key in the dictionary.\n     * If no such key already exists, this is equivalent to insert(key, value); otherwise, the existing value associated with the key is replaced.\n     * In either case, the value will be cloned using the function supplied to the dictionary's constructor.\n     */\n    set(key, value) {\n        value = this._cloneValue(value);\n        const bound = this.lowerBound(key);\n        if (bound.equal) {\n            this._values[bound.index] = value;\n        }\n        else {\n            this._keys.splice(bound.index, 0, this._cloneKey(key));\n            this._values.splice(bound.index, 0, value);\n        }\n    }\n    /**\n     * Extracts the contents of this dictionary as an array of { key, value } pairs, and empties this dictionary.\n     * @returns An array of { key, value } pairs sorted by key.\n     */\n    extractPairs() {\n        const pairs = [];\n        for (let i = 0; i < this.size; i++)\n            pairs.push({ key: this._keys[i], value: this._values[i] });\n        this.clear();\n        return pairs;\n    }\n    /**\n     * Extracts the contents of this dictionary as a pair of { keys, values } arrays, and empties this dictionary.\n     * The array of keys is sorted according to the comparison criterion.\n     * The position of each value in the array of values corresponds the the position of the corresponding key in the array of keys.\n     * @returns a pair of { keys, values } arrays in which key[i] corresponds to value[i] in this dictionary and the keys are in sorted order.\n     */\n    extractArrays() {\n        const result = { keys: this._keys, values: this._values };\n        this.clear();\n        return result;\n    }\n    /** Apply a function to each (key, value) pair in the dictionary, in sorted order.\n     * @param func The function to be applied.\n     */\n    forEach(func) {\n        for (let i = 0; i < this.size; i++)\n            func(this._keys[i], this._values[i]);\n    }\n    /**\n     * Computes the position at which the specified key should be inserted to maintain sorted order.\n     * @param key The key whose position is to be computed.\n     * @returns an object with 'index' corresponding to the computed position and 'equal' set to true if an equivalent key already exists at that index.\n     */\n    lowerBound(key) { return lowerBound(key, this._keys, this._compareKeys); }\n}\n//# sourceMappingURL=Dictionary.js.map",
      "start": 1693508120408,
      "end": 1693508120624,
      "sourcemaps": null
    }
  ]
}
