{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/bentley/lib/esm/Time.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Utils\n */\n/** A duration of time. Can be either positive (towards future) or negative (in the past).\n * BeDurations are immutable.\n * @public\n */\nexport class BeDuration {\n    constructor(milliseconds = 0) { this._milliseconds = milliseconds; }\n    /** The duration in milliseconds */\n    get milliseconds() { return this._milliseconds; }\n    get seconds() { return this._milliseconds / 1000; }\n    /** Create a BeDuration from seconds.\n     * @param seconds the number of seconds for this BeDuration\n     */\n    static fromSeconds(seconds) { return new BeDuration(seconds * 1000); }\n    /** Create a BeDuration from milliseconds.\n     * @param milliseconds the number of milliseconds for this BeDuration\n     */\n    static fromMilliseconds(milliseconds) { return new BeDuration(milliseconds); }\n    /** Determine whether this BeDuration is 0 seconds */\n    get isZero() { return this._milliseconds === 0; }\n    /** Determine whether this BeDuration is towards the future */\n    get isTowardsFuture() { return this._milliseconds > 0; }\n    /** Determine whether this BeDuration is towards the past */\n    get isTowardsPast() { return this._milliseconds < 0; }\n    /** Subtract a BeDuration from this BeDuration, returning a new BeDuration. */\n    minus(other) { return new BeDuration(this._milliseconds - other._milliseconds); }\n    /** Add a BeDuration to this BeDuration, returning a new BeDuration */\n    plus(other) { return new BeDuration(this._milliseconds + other._milliseconds); }\n    /** Utility function to just wait for the specified time\n     * @param ms Duration in milliseconds to wait\n     * @return Promise that resolves after the specified wait period\n     */\n    static async wait(ms) {\n        return new Promise((resolve) => setTimeout(resolve, ms));\n    }\n    /** Utility function to wait for either the specified time or a promise, whichever resolves first\n     * @param ms Maximum duration in milliseconds to wait\n     * @param promise A pending promise to wait for\n     * @return Promise that resolves after the specified wait period or the provided promise resolves, whichever comes first\n     */\n    static async race(ms, promise) {\n        let timeout;\n        const waitPromise = new Promise((resolve) => {\n            timeout = setTimeout(resolve, ms);\n        });\n        return Promise.race([waitPromise, promise]).finally(() => {\n            if (timeout)\n                clearTimeout(timeout);\n        });\n    }\n    /** Utility function to just wait for the specified time\n     * @return Promise that resolves after the specified wait period\n     */\n    async wait() {\n        return new Promise((resolve) => setTimeout(resolve, this._milliseconds));\n    }\n    /** Execute a function after delaying by this duration.\n     * @param fn the function to execute after the delay\n     * @param scope An optional object scope to serve as the 'this' pointer when `fn` is invoked.\n     * @param args optional arguments to `fn`\n     * @return Promise resolved by `fn`\n     */\n    async executeAfter(fn, scope, ...args) {\n        return new Promise((resolve) => setTimeout(() => resolve(fn.apply(scope, args)), this._milliseconds));\n    }\n}\n/** A specific point in time relative to the current time.\n * BeTimePoints are used for timing operations. They are created from a BeDuration relative to the \"now\".\n * BeTimePoints are immutable.\n * @public\n */\nexport class BeTimePoint {\n    /** the time in milliseconds, of this BeTimePoint (relative to January 1, 1970 00:00:00 UTC.) */\n    get milliseconds() { return this._milliseconds; }\n    constructor(milliseconds) { this._milliseconds = milliseconds; }\n    /** Create a BeTimePoint from Date.now() */\n    static now() { return new BeTimePoint(Date.now()); }\n    /** Create a BeTimePoint at a specified duration in the future from now\n     *  @param val the duration from now\n     */\n    static fromNow(val) { return new BeTimePoint(Date.now() + val.milliseconds); }\n    /** Create a BeTimePoint at a specified duration in the past before now\n     * @param val the duration before now\n     */\n    static beforeNow(val) { return new BeTimePoint(Date.now() - val.milliseconds); }\n    /** Determine whether this BeTimePoint is a time in the future from the time this method is called (it calls now()!) */\n    get isInFuture() { return Date.now() < this._milliseconds; }\n    /** Determine whether this BeTimePoint is a time that has already passed before the time this method is called (it calls now()!) */\n    get isInPast() { return Date.now() > this._milliseconds; }\n    /** Determine whether this BeTimePoint happens before another one.\n     * @param other the other BeTimePoint.\n     */\n    before(other) { return this._milliseconds < other._milliseconds; }\n    /** Determine whether this BeTimePoint happens after another one.\n     * @param other the other BeTimePoint.\n     */\n    after(other) { return this._milliseconds > other._milliseconds; }\n    /** Subtract a BeDuration from this BeTimePoint, returning a new BeTimePoint. This moves this BeTimePoint backwards in time if BeDuration.isTowardsFuture() === true\n     * @param duration the duration to subtract.\n     */\n    minus(duration) { return new BeTimePoint(this._milliseconds - duration.milliseconds); }\n    /** Subtract a BeDuration from this BeTimePoint, returning a new BeTimePoint. This moves this BeTimePoint backwards in time if BeDuration.isTowardsFuture() === true\n     * @param duration the duration to subtract.\n     */\n    plus(duration) { return new BeTimePoint(this._milliseconds + duration.milliseconds); }\n}\n/** A StopWatch for timing operations.\n * @public\n */\nexport class StopWatch {\n    /** Get the elapsed time since start() on a running timer. */\n    get current() { return BeDuration.fromMilliseconds(BeTimePoint.now().milliseconds - (!!this._start ? this._start.milliseconds : 0)); }\n    /** Get the elapsed time, in seconds, since start() on a running timer. */\n    get currentSeconds() { return this.current.seconds; }\n    /** Get the elapsed time between start() and stop() on this timer in milliseconds. */\n    get elapsed() { return BeDuration.fromMilliseconds((!!this._stop ? this._stop.milliseconds : BeTimePoint.now().milliseconds) - (!!this._start ? this._start.milliseconds : 0)); }\n    /** Get the elapsed time, in seconds, between start() and stop() on this  timer. */\n    get elapsedSeconds() { return this.elapsed.seconds; }\n    /** ctor for StopWatch\n     * @param description optional string stored with the StopWatch\n     * @param startImmediately if true, StopWatch is started when created. Otherwise, call start() explicitly.\n     */\n    constructor(description, startImmediately = false) {\n        this.description = description;\n        if (startImmediately)\n            this.start();\n    }\n    /** Start the stopwatch. Any future time measurements will be based on this new value. */\n    start() {\n        this.reset();\n        this._start = BeTimePoint.now();\n    }\n    /** Stop the stopwatch so that the duration can be viewed later. */\n    stop() {\n        this._stop = BeTimePoint.now();\n        return this.elapsed;\n    }\n    /** Clear the StopWatch */\n    reset() { this._start = this._stop = undefined; }\n}\n//# sourceMappingURL=Time.js.map",
      "start": 1693508120624,
      "end": 1693508120684,
      "sourcemaps": null
    }
  ]
}
