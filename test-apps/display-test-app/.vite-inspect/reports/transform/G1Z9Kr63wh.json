{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/bentley/lib/esm/CompressedId64Set.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Ids\n */\nimport { assert } from \"./Assert\";\nimport { Id64 } from \"./Id\";\nimport { OrderedId64Iterable } from \"./OrderedId64Iterable\";\nimport { SortedArray } from \"./SortedArray\";\n/** A compact string representation of an [[Id64Set]]. Such a representation is useful when serializing potentially very large\n * sets of Ids.\n * @see [[CompressedId64Set.iterable]] to efficiently iterate the Ids represented by a compact string.\n * @see [[CompressedId64Set.compressSet]] and [[CompressedId64Set.compressArray]] to produce a compact string from a collection of Ids.\n * @see [[CompressedId64Set.decompressSet]] and [[CompressedId64Set.decompressArray]] to produce a collection of Ids from a compact string.\n * @see [[OrderedId64Iterable]] for a generic representation of an ordered set of Ids (compressed or otherwise).\n * @see [[MutableCompressedId64Set]] for a mutable version.\n * @public\n */\nexport var CompressedId64Set;\n(function (CompressedId64Set) {\n    function isHexDigit(ch) {\n        // ascii values:\n        // '0' = 48\n        // '9' = 57\n        // 'a' = 65\n        // 'f' = 70\n        return (ch >= 48 && ch <= 57) || (ch >= 65 && ch <= 70);\n    }\n    function compactRange(increment, length) {\n        assert(length > 0);\n        const inc = `+${increment.toString()}`;\n        if (length <= 1)\n            return inc;\n        const len = length.toString(16).toUpperCase();\n        return `${inc}*${len}`;\n    }\n    /** Given a set of [[Id64String]]s, produce a compact string representation. Useful when serializing potentially large sets of Ids.\n     * @note Invalid Ids are ignored.\n     * @see [[CompressedId64Set.sortAndCompress]] to compress any unordered collection of Ids.\n     * @see [[CompressedId64Set.compressArray]] to perform the same operation on an [[Id64Array]].\n     * @see [[CompressedId64Set.decompressSet]] to perform the inverse operation.\n     */\n    function compressSet(ids) {\n        return sortAndCompress(ids);\n    }\n    CompressedId64Set.compressSet = compressSet;\n    /** Create a sorted array from `ids`, then return a compact string representation of those Ids.\n     * @see [[compressIds]] if `ids` is known to already be sorted.\n     */\n    function sortAndCompress(ids) {\n        // `string` is an Iterable<string>. In that case assume caller passed a single Id64String.\n        const arr = typeof ids === \"string\" ? [ids] : Array.from(ids);\n        OrderedId64Iterable.sortArray(arr);\n        return compressArray(arr);\n    }\n    CompressedId64Set.sortAndCompress = sortAndCompress;\n    /** Give a **numerically-ordered** array of [[Id64String]]s, produce a compact string representation. Useful when serializing potentially large sets of Ids.\n     * Duplicate Ids are included only once in the string representation.\n     * @throws Error if two consecutive Ids `x` and `y` exist such that the numerical value of `x` is greater than that of `y` - i.e., the array is not properly sorted.\n     * @note The array must be sorted according to the 64-bit numerical value of each Id.\n     * @note Invalid Ids are ignored.\n     * @see [[CompressedId64Set.decompressArray]] to perform the inverse operation.\n     * @see [[OrderedId64Iterable.sortArray]] to ensure the Ids are properly sorted.\n     * @see [[CompressedId64Set.sortAndCompress]] to compress any unordered collection of Ids.\n     */\n    function compressArray(ids) {\n        return compressIds(ids);\n    }\n    CompressedId64Set.compressArray = compressArray;\n    /** Give a **numerically-ordered** collection of [[Id64String]]s, produce a compact string representation. Useful when serializing potentially large sets of Ids.\n     * Duplicate Ids are included only once in the string representation.\n     * @throws Error if two consecutive Ids `x` and `y` exist such that the numerical value of `x` is greater than that of `y` - i.e., the collection is not properly sorted.\n     * @note The collection must be sorted according to the 64-bit numerical value of each Id.\n     * @note Invalid Ids are ignored.\n     * @see [[CompressedId64Set.iterable]] to perform the inverse operation.\n     * @see [[OrderedId64Iterable.sortArray]] or [[OrderedId64Iterable.compare]] to ensure the Ids are properly sorted.\n     * @see [[CompressedId64Set.sortAndCompress]] to compress any unordered collection of Ids.\n     */\n    function compressIds(ids) {\n        if (\"string\" === typeof ids)\n            return ids;\n        let str = \"\";\n        const prevId = new Uint64();\n        const rangeIncrement = new Uint64();\n        let rangeLen = 0;\n        const curId = new Uint64();\n        const curIncrement = new Uint64();\n        for (const id of ids) {\n            if (!Id64.isValidId64(id))\n                continue; // ignore garbage and invalid Ids (\"0\")\n            curId.setFromId(id);\n            curIncrement.setFromDifference(curId, prevId);\n            const cmp = prevId.compare(curId);\n            if (0 === cmp)\n                continue; // ignore duplicates\n            else if (cmp > 0)\n                throw new Error(\"CompressedId64Set.compressArray requires a sorted array as input\");\n            prevId.copyFrom(curId);\n            if (0 === rangeLen) {\n                rangeIncrement.copyFrom(curIncrement);\n                rangeLen = 1;\n            }\n            else if (curIncrement.equals(rangeIncrement)) {\n                ++rangeLen;\n            }\n            else {\n                str += compactRange(rangeIncrement, rangeLen);\n                rangeIncrement.copyFrom(curIncrement);\n                rangeLen = 1;\n            }\n        }\n        if (0 < rangeLen)\n            str += compactRange(rangeIncrement, rangeLen);\n        return str;\n    }\n    CompressedId64Set.compressIds = compressIds;\n    /** This exists strictly for the purposes of compressed sets of 64-bit Ids, to avoid the overhead of BigInt for handling 64-bit integers. */\n    class Uint64 {\n        static assertUint32(num) {\n            assert(num >= 0);\n            assert(num < Uint64._base);\n            assert(Math.floor(num) === num);\n        }\n        assertConstraints() {\n            Uint64.assertUint32(this.lower);\n            Uint64.assertUint32(this.upper);\n        }\n        constructor(lower = 0, upper = 0) {\n            this.lower = lower;\n            this.upper = upper;\n            this.assertConstraints();\n        }\n        compare(rhs) {\n            const diff = this.upper - rhs.upper;\n            return 0 === diff ? this.lower - rhs.lower : diff;\n        }\n        equals(rhs) { return 0 === this.compare(rhs); }\n        isLessThan(rhs) { return this.compare(rhs) < 0; }\n        isGreaterThan(rhs) { return this.compare(rhs) > 0; }\n        get isZero() { return 0 === this.lower && 0 === this.upper; }\n        setFromDifference(lhs, rhs) {\n            assert(!rhs.isGreaterThan(lhs));\n            this.lower = lhs.lower - rhs.lower;\n            this.upper = lhs.upper - rhs.upper;\n            if (this.lower < 0) {\n                this.lower += Uint64._base;\n                this.upper -= 1;\n            }\n        }\n        add(rhs) {\n            let lower = rhs.lower;\n            let upper = rhs.upper;\n            if (lower + this.lower >= Uint64._base) {\n                lower -= Uint64._base;\n                upper += 1;\n            }\n            this.lower += lower;\n            this.upper += upper;\n            this.assertConstraints();\n        }\n        setFromId(id) {\n            Id64.getUint32Pair(id, this);\n        }\n        copyFrom(other) {\n            this.lower = other.lower;\n            this.upper = other.upper;\n        }\n        toString() {\n            if (0 === this.upper)\n                return this.lower.toString(16).toUpperCase();\n            const upper = this.upper.toString(16);\n            const lower = this.lower.toString(16).padStart(8, \"0\");\n            assert(lower.length === 8);\n            return `${upper}${lower}`.toUpperCase();\n        }\n        toId64String() {\n            return Id64.fromUint32Pair(this.lower, this.upper);\n        }\n    }\n    Uint64._base = 0x100000000;\n    /** Supplies an iterator over the [[Id64String]]s in a [[CompressedId64Set]].\n     * The Ids are iterated in ascending order based on their unsigned 64-bit integer values.\n     */\n    function* iterator(ids) {\n        if (0 === ids.length)\n            return; // empty set.\n        if (\"+\" !== ids[0])\n            throw new Error(\"Invalid CompressedId64Set\");\n        let curIndex = 1; // skip the leading '+'\n        const curId = new Uint64();\n        function parseUint32() {\n            let value = 0;\n            let nChars = 0;\n            while (curIndex < ids.length && nChars < 8) {\n                ++nChars;\n                const ch = ids.charCodeAt(curIndex);\n                if (!isHexDigit(ch))\n                    break; // not a hex digit in [0..9] or [A..F]\n                value <<= 4;\n                value |= (ch >= 65 ? ch - 65 + 10 : ch - 48); // ch - 'A' + 10 or ch - '0'\n                value = value >>> 0; // restore unsignedness because silly javascript.\n                ++curIndex;\n            }\n            return value;\n        }\n        function parseUint64(uint64) {\n            let lower = 0;\n            let upper = 0;\n            // Read up to the first 8 digits.\n            const startIndex = curIndex;\n            const first = parseUint32();\n            const nFirstDigits = curIndex - startIndex;\n            assert(nFirstDigits <= 8);\n            if (8 === nFirstDigits && curIndex + 1 < ids.length && isHexDigit(ids.charCodeAt(curIndex + 1))) {\n                // We've got up to 8 more digits remaining\n                const secondIndex = curIndex;\n                const second = parseUint32();\n                // Transfer excess digits from upper to lower.\n                const nSecondDigits = curIndex - secondIndex;\n                assert(nSecondDigits > 0 && nSecondDigits <= 8);\n                const nDigitsToTransfer = 8 - nSecondDigits;\n                upper = first >>> (4 * nDigitsToTransfer);\n                const transfer = first - ((upper << (4 * nDigitsToTransfer)) >>> 0);\n                lower = (second | ((transfer << (4 * nSecondDigits)) >>> 0)) >>> 0;\n            }\n            else {\n                lower = first;\n            }\n            uint64.lower = lower;\n            uint64.upper = upper;\n        }\n        const increment = new Uint64();\n        while (curIndex < ids.length) {\n            let multiplier = 1;\n            parseUint64(increment);\n            if (increment.isZero)\n                throw new Error(\"Invalid CompressedId64Set\");\n            if (curIndex < ids.length) {\n                switch (ids[curIndex++]) {\n                    case \"*\":\n                        multiplier = parseUint32();\n                        if (0 === multiplier)\n                            throw new Error(\"Invalid CompressedId64Set\");\n                        if (curIndex !== ids.length && ids[curIndex++] !== \"+\")\n                            return;\n                        break;\n                    case \"+\":\n                        break;\n                    default:\n                        throw new Error(\"Invalid CompressedId64Set\");\n                }\n            }\n            for (let i = 0; i < multiplier; i++) {\n                curId.add(increment);\n                yield curId.toId64String();\n            }\n        }\n    }\n    CompressedId64Set.iterator = iterator;\n    /** Supplies an iterable over the [[Id64String]]s in a [[CompressedId64Set]].\n     * The Ids are iterated in ascending order based on their unsigned 64-bit integer values.\n     */\n    function iterable(ids) {\n        return {\n            [Symbol.iterator]: () => iterator(ids),\n        };\n    }\n    CompressedId64Set.iterable = iterable;\n    /** Decompress the compact string representation of an [[Id64Set]] into an [[Id64Set]].\n     * @param compressedIds The compact string representation.\n     * @param out If supplied, the Ids will be inserted into this set rather than allocating and returning a new set.\n     * @returns The set containing the decompressed Ids.\n     * @throws Error if `compressedIds` is not a well-formed [[CompressedId64Set]].\n     * @see [[CompressedId64Set.compressSet]] to perform the inverse operation.\n     * @see [[CompressedId64Set.decompressArray]] to decompress as an [[Id64Array]] instead.\n     * @see [[CompressedId64Set.iterable]] to efficiently iterate the Ids.\n     */\n    function decompressSet(compressedIds, out) {\n        const set = out ?? new Set();\n        for (const id of iterable(compressedIds))\n            set.add(id);\n        return set;\n    }\n    CompressedId64Set.decompressSet = decompressSet;\n    /** Decompress the compact string representation of an [[Id64Set]] into an [[Id64Array]].\n     * @param compressedIds The compact string representation.\n     * @param out If supplied, the Ids will be appended to this array rather than allocating and returning a new array.\n     * @returns The array containing the decompressed Ids.\n     * @throws Error if `compressedIds` is not a well-formed [[CompressedId64Set]].\n     * @note The Ids are decompressed and appended to the array in ascending order based on their 64-bit numerical values.\n     * @see [[CompressedId64Set.compressArray]] to perform the inverse operation.\n     * @see [[CompressedId64Set.decompressSet]] to decompress as an [[Id64Set]] instead.\n     * @see [[CompressedId64Set.iterable]] to efficiently iterate the Ids.\n     */\n    function decompressArray(compressedIds, out) {\n        const arr = out ?? [];\n        for (const id of iterable(compressedIds))\n            arr.push(id);\n        return arr;\n    }\n    CompressedId64Set.decompressArray = decompressArray;\n})(CompressedId64Set || (CompressedId64Set = {}));\n/** A [[SortedArray]] of unique [[Id64String]]s sorted in ascending order by the 64-bit unsigned integer values of the Ids.\n * @see [[CompressedId64Set]] for an immutable compact string representation.\n * @public\n */\nexport class OrderedId64Array extends SortedArray {\n    /** Construct a new, empty array. */\n    constructor() {\n        super((lhs, rhs) => OrderedId64Iterable.compare(lhs, rhs));\n    }\n    /** An iterable that iterates over the Ids in sorted order. */\n    get ids() { return this._array; }\n    /** The underlying array of Ids. */\n    get array() { return this._array; }\n}\n/** A mutable set of valid [[Id64String]]s sorted in ascending order by the 64-bit unsigned integer value of the Ids.\n * Internally the set of Ids is maintained as a [[CompressedId64Set]] string representation.\n * Insertions and removals are buffered until the string representation needs to be recomputed. The string representation is recomputed by every public method except [[add]] and [[delete]] -\n * therefore, if multiple removals and/or insertions are required, it is most efficient to perform them all before invoking other methods.\n * @public\n */\nexport class MutableCompressedId64Set {\n    /** Construct a new set, optionally initialized to contain the Ids represented by `ids`. */\n    constructor(ids) {\n        this._inserted = new OrderedId64Array();\n        this._deleted = new OrderedId64Array();\n        this._ids = ids ?? \"\";\n    }\n    /** Obtain the compact string representation of the contents of this set. If any insertions or removals are pending, they will be applied and the string recomputed. */\n    get ids() {\n        this.updateIds();\n        return this._ids;\n    }\n    /** Add the specified Id to the set.\n     * @throws Error if `id` is not a valid [[Id64String]].\n     */\n    add(id) {\n        if (!Id64.isValidId64(id))\n            throw new Error(\"MutableCompressedId64Set.add: invalid Id\");\n        this._deleted.remove(id);\n        this._inserted.insert(id);\n    }\n    /** Remove the specified Id from the set.\n     * @throws Error if `id` is not a valid [[Id64String]].\n     */\n    delete(id) {\n        if (!Id64.isValidId64(id))\n            throw new Error(\"MutableCompressedId64Set.delete: invalid Id\");\n        this._inserted.remove(id);\n        this._deleted.insert(id);\n    }\n    /** Remove all Ids from the set. */\n    clear() {\n        this._ids = \"\";\n        this._inserted.clear();\n        this._deleted.clear();\n    }\n    /** Remove all Ids from the set, then add the specified Ids. */\n    reset(ids) {\n        this.clear();\n        this._ids = ids ?? \"\";\n    }\n    /** Obtain an iterator over the Ids in this set. The Ids are returned in ascending order based on their unsigned 64-bit integer values. */\n    [Symbol.iterator]() {\n        return CompressedId64Set.iterator(this.ids);\n    }\n    /** Compute a compact string representation of the union of this and another set of Ids - i.e., those Ids present in either this and/or the other set. */\n    computeUnion(ids) {\n        if (this.isEmpty)\n            return CompressedId64Set.compressIds(ids);\n        else if (OrderedId64Iterable.isEmptySet(ids) || this.equals(ids))\n            return this.ids;\n        return CompressedId64Set.compressIds(OrderedId64Iterable.union(this, ids));\n    }\n    /** Compute a compact string representation of the intersection of this and another set of Ids - i.e., those Ids present in both this and the other set. */\n    computeIntersection(ids) {\n        if (this.equals(ids))\n            return this.ids;\n        else if (this.isEmpty || OrderedId64Iterable.isEmptySet(ids))\n            return \"\";\n        return CompressedId64Set.compressIds(OrderedId64Iterable.intersection(this, ids));\n    }\n    /** Compute a compact string representation of the difference between this and another set - i.e., those Ids present in this but not in the other set. */\n    computeDifference(ids) {\n        if (this.isEmpty || this.equals(ids))\n            return \"\";\n        return CompressedId64Set.compressIds(OrderedId64Iterable.difference(this, ids));\n    }\n    /** Return true if this set contains no Ids. */\n    get isEmpty() {\n        return OrderedId64Iterable.isEmptySet(this.ids);\n    }\n    /** Return true if the set of Ids represented by `other` is identical to those in this set.\n     * @note This considers only the **distinct** Ids in `other` - duplicates are ignored.\n     */\n    equals(other) {\n        if (other instanceof MutableCompressedId64Set) {\n            if (other === this)\n                return true;\n            if (typeof other !== \"string\")\n                other = other.ids;\n        }\n        if (typeof other === \"string\")\n            return other === this.ids;\n        this.updateIds();\n        return OrderedId64Iterable.areEqualSets(this, other);\n    }\n    get _isDirty() {\n        return !this._inserted.isEmpty || !this._deleted.isEmpty;\n    }\n    updateIds() {\n        if (!this._isDirty)\n            return;\n        const difference = OrderedId64Iterable.difference(CompressedId64Set.iterable(this._ids), this._deleted.ids);\n        const union = { [Symbol.iterator]: () => OrderedId64Iterable.unionIterator(difference, this._inserted.ids) };\n        this._ids = CompressedId64Set.compressIds(union);\n        this._inserted.clear();\n        this._deleted.clear();\n    }\n}\n//# sourceMappingURL=CompressedId64Set.js.map",
      "start": 1693508120371,
      "end": 1693508120627,
      "sourcemaps": null
    }
  ]
}
