{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/orbitgt/lib/esm/spatial/ecrs/Transform.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module OrbitGT\n */\nimport { Message } from \"../../system/runtime/Message\";\nimport { Strings } from \"../../system/runtime/Strings\";\nimport { Coordinate } from \"../geom/Coordinate\";\nimport { CRS } from \"./CRS\";\nimport { Registry } from \"./Registry\";\n/**\n * Class Transform transforms coordinates between coordinate reference systems.\n *\n * @version 1.0 September 2005\n */\n/** @internal */\nclass Transform {\n    /**\n     * Prevent instantiation.\n     */\n    constructor() { }\n    /**\n     * Is a conversion between two coordinate systems possible/needed?\n     * @param sourceCRS the name/code of the source reference system.\n     * @param targetCRS the name/code of the target reference system.\n     * @return true if a conversion is possible/needed.\n     */\n    static canTransform(sourceCRS, targetCRS) {\n        /* We need two CRSs */\n        if (sourceCRS == null || Strings.getLength(sourceCRS) == 0)\n            return false;\n        if (targetCRS == null || Strings.getLength(targetCRS) == 0)\n            return false;\n        /* Same CRS ? */\n        if (Strings.equalsIgnoreCase(targetCRS, sourceCRS))\n            return true;\n        /* Get the two CRSs */\n        let source = Registry.getCRS2(sourceCRS);\n        let target = Registry.getCRS2(targetCRS);\n        /* We need two CRSs */\n        if (source == null)\n            return false;\n        if (target == null)\n            return false;\n        /* Vertical transform ? */\n        if (source.hasVerticalComponent() || target.hasVerticalComponent()) {\n            /* Get the horizontal components */\n            let sourceHor = (source.hasVerticalComponent()) ? source.getHorizontalComponent() : source;\n            let targetHor = (target.hasVerticalComponent()) ? target.getHorizontalComponent() : target;\n            /* Check transform in the horizontal CRS */\n            return Transform.canTransform(\"\" + sourceHor.getCode(), \"\" + targetHor.getCode());\n        }\n        /* Same datum ? */\n        if (source.getDatum().isCompatible(target.getDatum()))\n            return true;\n        /* Chained transform ? */\n        if ((source.getCode() != CRS.WGS84_2D_CRS_CODE) && (target.getCode() != CRS.WGS84_2D_CRS_CODE)) {\n            /* Use WGS as in-between */\n            if (source.isWGSCompatible() == false)\n                return false;\n            if (target.isWGSCompatible() == false)\n                return false;\n            /* Possible */\n            return true;\n        }\n        /* To WGS ? */\n        if (target.getCode() == CRS.WGS84_2D_CRS_CODE) {\n            /* Use WGS */\n            if (source.isWGSCompatible() == false)\n                return false;\n            /* Possible */\n            return true;\n        }\n        /* From WGS ? */\n        if (source.getCode() == CRS.WGS84_2D_CRS_CODE) {\n            /* Use WGS */\n            if (target.isWGSCompatible() == false)\n                return false;\n            /* Possible */\n            return true;\n        }\n        /* Not possible */\n        return false;\n    }\n    /**\n     * Do a vertical transform.\n     * @param horizontalCRS the horizontal CRS.\n     * @param fromVerticalCRS the vertical CRS to convert from.\n     * @param from the coordinate to convert from.\n     * @param toVerticalCRS the vertical CRS to convert to.\n     * @param to the coordinate to convert to.\n     */\n    static transformVertical(horizontalCRS, fromVerticalCRS, from, toVerticalCRS, to) {\n        /* 1: From 'ellipsoid' to 'ellipsoid' height ? */\n        if ((fromVerticalCRS == null) && (toVerticalCRS == null)) {\n            /* Straight copy */\n            to.setX(from.getX());\n            to.setY(from.getY());\n            to.setZ(from.getZ());\n            //Message.print(MODULE,\"_VERTICAL: ellipsoid->ellipsoid: \"+from.getZ());\n        }\n        /* 2: From 'ellipsoid' to 'local' height ? */\n        else if ((fromVerticalCRS == null) && (toVerticalCRS != null)) {\n            /* Get the geoid separation */\n            let geoidModel = toVerticalCRS.getVerticalModel();\n            let toZ = from.getZ();\n            if (geoidModel != null)\n                toZ = geoidModel.toLocalHeight(horizontalCRS, from);\n            else\n                Message.printWarning(Transform.MODULE, \"Target vertical CRS \" + toVerticalCRS + \" does not have a height model\");\n            //Message.print(MODULE,\"_VERTICAL: ellipsoid->local: \"+from.getZ()+\"->\"+toZ);\n            /* Substract the separation */\n            to.setX(from.getX());\n            to.setY(from.getY());\n            to.setZ(toZ);\n        }\n        /* 3: From 'local' to 'ellipsoid' height ? */\n        else if ((fromVerticalCRS != null) && (toVerticalCRS == null)) {\n            /* Get the geoid separation */\n            let geoidModel = fromVerticalCRS.getVerticalModel();\n            let toZ = from.getZ();\n            if (geoidModel != null)\n                toZ = geoidModel.toEllipsoidHeight(horizontalCRS, from);\n            else\n                Message.printWarning(Transform.MODULE, \"Source vertical CRS \" + fromVerticalCRS + \" does not have a height model\");\n            //Message.print(MODULE,\"_VERTICAL: local->ellipsoid: \"+from.getZ()+\"->\"+toZ);\n            /* Add the separation */\n            to.setX(from.getX());\n            to.setY(from.getY());\n            to.setZ(toZ);\n        }\n        /* 4: From 'local1' to 'local2' */\n        else {\n            /* Same ? */\n            if (fromVerticalCRS.getCode() == toVerticalCRS.getCode()) {\n                /* Straight copy */\n                to.setX(from.getX());\n                to.setY(from.getY());\n                to.setZ(from.getZ());\n                //Message.print(MODULE,\"_VERTICAL: local->local same: \"+from.getZ());\n            }\n            else {\n                /* Get the 'from' ellipsoid height */\n                let fromGeoidModel = fromVerticalCRS.getVerticalModel();\n                let fromZ = from.getZ();\n                if (fromGeoidModel != null)\n                    fromZ = fromGeoidModel.toEllipsoidHeight(horizontalCRS, from);\n                else\n                    Message.printWarning(Transform.MODULE, \"Source vertical CRS \" + fromVerticalCRS + \" does not have a height model\");\n                /* Copy */\n                to.setX(from.getX());\n                to.setY(from.getY());\n                to.setZ(fromZ);\n                /* Get the 'to' local height */\n                let toGeoidModel = toVerticalCRS.getVerticalModel();\n                let toZ = to.getZ();\n                if (toGeoidModel != null)\n                    toZ = toGeoidModel.toLocalHeight(horizontalCRS, to);\n                else\n                    Message.printWarning(Transform.MODULE, \"Target vertical CRS \" + toVerticalCRS + \" does not have a height model\");\n                //Message.print(MODULE,\"_VERTICAL: local->local: \"+from.getZ()+\"->\"+fromZ+\"->\"+toZ);\n                /* Copy */\n                to.setZ(toZ);\n            }\n        }\n    }\n    /**\n     * Get the transformation path from one CRS to another CRS.\n     * @param sourceCRS the source reference system.\n     * @param targetCRS the target reference system.\n     * @return the transformation path.\n     */\n    static getTransformPath(sourceCRS, targetCRS) {\n        /* Same CRS ? */\n        if (targetCRS.getCode() == sourceCRS.getCode()) {\n            return Transform._SAME_CRS;\n        }\n        /* Compatible CRS ? */\n        if (targetCRS.isCompatible(sourceCRS)) {\n            return Transform._SAME_CRS;\n        }\n        /* Vertical transform ? */\n        if (sourceCRS.hasVerticalComponent() || targetCRS.hasVerticalComponent()) {\n            return Transform._VERTICAL;\n        }\n        /* Same datum/ellipsoid ? (added on 24/11/2011) */\n        if (sourceCRS.getDatum().isCompatible(targetCRS.getDatum())) {\n            /* Is the target a projection of the source ? (added on 05/12/2011) */\n            if (targetCRS.isProjectionOf(sourceCRS)) {\n                return Transform._FORWARD_PROJECTION;\n            }\n            /* Is the source a projection of the target ? (added on 05/12/2011) */\n            if (sourceCRS.isProjectionOf(targetCRS)) {\n                return Transform._INVERSE_PROJECTION;\n            }\n            /* Two projections of the same base? */\n            if (sourceCRS.isProjected() && targetCRS.isProjected() && (targetCRS.getBaseCRS().isCompatible(sourceCRS.getBaseCRS()))) {\n                return Transform._TWO_PROJECTIONS;\n            }\n        }\n        /* To WGS ? */\n        if (targetCRS.getCode() == CRS.WGS84_2D_CRS_CODE) {\n            return Transform._TO_WGS;\n        }\n        /* From WGS ? */\n        if (sourceCRS.getCode() == CRS.WGS84_2D_CRS_CODE) {\n            return Transform._FROM_WGS;\n        }\n        /* Use WGS as in-between (slowest path) */\n        return Transform._FULL_TRANSFORM;\n    }\n    /**\n     * Convert between two coordinate reference systems.\n     * @param sourceCRS the source reference system.\n     * @param from the coordinate to convert from.\n     * @param targetCRS the target reference system.\n     * @param to the coordinate to convert to.\n     */\n    static transformWithPath(path, sourceCRS, from, targetCRS, to) {\n        //Message.print(MODULE,\"---------->>>\");\n        //Message.print(MODULE,\"TRANSFORM: sourceCRS = \"+sourceCRS.getCode());\n        //Message.print(MODULE,\"TRANSFORM: targetCRS = \"+targetCRS.getCode());\n        //Message.print(MODULE,\"TRANSFORM: from = \"+from);\n        //Message.print(MODULE,\"TRANSFORM: path = \"+path);\n        /* Same CRS ? */\n        if (path == Transform._SAME_CRS) {\n            //Message.print(MODULE,\"TRANSFORM: _SAME_CRS\");\n            /* Straight copy */\n            to.setX(from.getX());\n            to.setY(from.getY());\n            to.setZ(from.getZ());\n            //Message.print(MODULE,\"TRANSFORMED: to = \"+to);\n            return;\n        }\n        /* Is the target a projection of the source ? (added on 05/12/2011) */\n        if (path == Transform._FORWARD_PROJECTION) {\n            //Message.print(MODULE,\"TRANSFORM: _FORWARD_PROJECTION\");\n            /* Apply the projection */\n            targetCRS.toProjected(from, to);\n            //Message.print(MODULE,\"TRANSFORMED: to = \"+to);\n            return;\n        }\n        /* Is the source a projection of the target ? (added on 05/12/2011) */\n        if (path == Transform._INVERSE_PROJECTION) {\n            //Message.print(MODULE,\"TRANSFORM: _INVERSE_PROJECTION\");\n            /* Reverse the projection */\n            sourceCRS.fromProjected(from, to);\n            //Message.print(MODULE,\"TRANSFORMED: to = \"+to);\n            return;\n        }\n        /* Two projections of the same base? */\n        if (path == Transform._TWO_PROJECTIONS) {\n            //Message.print(MODULE,\"TRANSFORM: _TWO_PROJECTIONS\");\n            /* Reverse the projection */\n            sourceCRS.fromProjected(from, to);\n            /* Apply the projection */\n            targetCRS.toProjected(to, to);\n            //Message.print(MODULE,\"TRANSFORMED: to = \"+to);\n            return;\n        }\n        /* To WGS ? */\n        if (path == Transform._TO_WGS) {\n            //Message.print(MODULE,\"TRANSFORM: _TO_WGS\");\n            /* Use WGS */\n            let toWGS = sourceCRS.toWGS(from);\n            /* Set the target */\n            to.setX(toWGS.getX());\n            to.setY(toWGS.getY());\n            to.setZ(toWGS.getZ());\n            //Message.print(MODULE,\"TRANSFORMED: to = \"+to);\n            return;\n        }\n        /* From WGS ? */\n        if (path == Transform._FROM_WGS) {\n            //Message.print(MODULE,\"TRANSFORM: _FROM_WGS\");\n            /* Use WGS */\n            let fromWGS = targetCRS.fromWGS(from);\n            /* Set the target */\n            to.setX(fromWGS.getX());\n            to.setY(fromWGS.getY());\n            to.setZ(fromWGS.getZ());\n            //Message.print(MODULE,\"TRANSFORMED: to = \"+to);\n            return;\n        }\n        /* Full transform ? */\n        if (path == Transform._FULL_TRANSFORM) {\n            //Message.print(MODULE,\"TRANSFORM: _FULL_TRANSFORM\");\n            /* Use WGS as in-between */\n            let toWGS = sourceCRS.toWGS(from);\n            let fromWGS = targetCRS.fromWGS(toWGS);\n            /* Set the target */\n            to.setX(fromWGS.getX());\n            to.setY(fromWGS.getY());\n            to.setZ(fromWGS.getZ());\n            //Message.print(MODULE,\"TRANSFORMED: to = \"+to);\n            return;\n        }\n        /* Vertical transform ? */\n        if (path == Transform._VERTICAL) {\n            //Message.print(MODULE,\"TRANSFORM: _VERTICAL\");\n            /* Get the horizontal components */\n            let sourceHorCRS = (sourceCRS.hasVerticalComponent()) ? sourceCRS.getHorizontalComponent() : sourceCRS;\n            let targetHorCRS = (targetCRS.hasVerticalComponent()) ? targetCRS.getHorizontalComponent() : targetCRS;\n            /* Get the vertical components */\n            let sourceVerCRS = (sourceCRS.hasVerticalComponent()) ? sourceCRS.getVerticalComponent() : null;\n            let targetVerCRS = (targetCRS.hasVerticalComponent()) ? targetCRS.getVerticalComponent() : null;\n            /* Put the source coordinate in the ellipsoid height */\n            if (sourceVerCRS != null) {\n                /* Move to the default 'ellipsoid' height */\n                //Message.print(MODULE,\"TRANSFORM: source to ellipsoidZ\");\n                Transform.transformVertical(sourceHorCRS, sourceVerCRS, from, null, to);\n                from = to;\n                //Message.print(MODULE,\"TRANSFORM: source ellipsoidZ = \"+to);\n            }\n            /* Get the ellipsoid height */\n            let ellipsoidZ = from.getZ();\n            if (sourceHorCRS.isGeoCentric()) {\n                /* Calculate the ellipsoid height */\n                let geographic = new Coordinate(0.0, 0.0, 0.0);\n                sourceHorCRS.getEllipsoid().toGeoGraphic(from, geographic);\n                ellipsoidZ = geographic.getZ();\n            }\n            /* Transform in the horizontal CRS (keep the WGS Z (and not the Bessel Z) for transform from WGS to RD-NAP) */\n            //Message.print(MODULE,\"TRANSFORM: ellipsoidZ = \"+ellipsoidZ);\n            //Message.print(MODULE,\"TRANSFORM: horizontal \"+sourceHorCRS.getCode()+\" -> \"+targetHorCRS.getCode());\n            Transform.transformCRS(sourceHorCRS, from, targetHorCRS, to);\n            /* Is the target CRS horizontal? */\n            if (targetHorCRS.isGeoCentric() == false) {\n                /* Keep the ellipsoid height after the horizontal transform */\n                to.setZ(ellipsoidZ);\n            }\n            from = to;\n            //Message.print(MODULE,\"TRANSFORM: intermediate = \"+from);\n            /* Put the target coordinate in the vertical CRS */\n            if (targetVerCRS != null) {\n                /* Move from the default 'ellipsoid' height */\n                Transform.transformVertical(targetHorCRS, null, from, targetVerCRS, to);\n                from = to;\n                //Message.print(MODULE,\"TRANSFORM: target vtransf = \"+to);\n            }\n            /* Done */\n            //Message.print(MODULE,\"TRANSFORMED: to = \"+to);\n            return;\n        }\n        //Message.print(MODULE,\"TRANSFORMED: UNKNOWN!\");\n    }\n    /**\n     * Convert between two coordinate reference systems.\n     * @param sourceCRS the source reference system.\n     * @param from the coordinate to convert from.\n     * @param targetCRS the target reference system.\n     * @param to the coordinate to convert to.\n     */\n    static transformCRS(sourceCRS, from, targetCRS, to) {\n        Transform.transformWithPath(Transform.getTransformPath(sourceCRS, targetCRS), sourceCRS, from, targetCRS, to);\n    }\n    /**\n     * Convert between two coordinate reference systems.\n     * @param sourceCRS the name/code of the source reference system.\n     * @param from the coordinate to convert from.\n     * @param targetCRS the name/code of the target reference system.\n     * @param to the coordinate to convert to.\n     */\n    static transform(sourceCRS, from, targetCRS, to) {\n        /* Same CRS ? */\n        if (Strings.equalsIgnoreCase(targetCRS, sourceCRS)) {\n            /* Straight copy */\n            to.setX(from.getX());\n            to.setY(from.getY());\n            to.setZ(from.getZ());\n            return;\n        }\n        /* Get the two CRSs */\n        let source = Registry.getCRS2(sourceCRS);\n        let target = Registry.getCRS2(targetCRS);\n        /* Transform */\n        Transform.transformCRS(source, from, target, to);\n    }\n}\n/** The name of this module */\nTransform.MODULE = \"Transform\";\n/** Define the different paths a CRS transformation can take */\nTransform._SAME_CRS = 1;\nTransform._FORWARD_PROJECTION = 2;\nTransform._INVERSE_PROJECTION = 3;\nTransform._TWO_PROJECTIONS = 4;\nTransform._TO_WGS = 6;\nTransform._FROM_WGS = 7;\nTransform._FULL_TRANSFORM = 8;\nTransform._VERTICAL = 9;\nexport { Transform };\n//# sourceMappingURL=Transform.js.map",
      "start": 1693508126619,
      "end": 1693508126675,
      "sourcemaps": null
    }
  ]
}
