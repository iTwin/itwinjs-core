{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/glsl/RealityMesh.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { assert } from \"@itwin/core-bentley\";\nimport { ColorDef } from \"@itwin/core-common\";\nimport { Matrix4d } from \"@itwin/core-geometry\";\nimport { AttributeMap } from \"../AttributeMap\";\nimport { Matrix4 } from \"../Matrix\";\nimport { TextureUnit } from \"../RenderFlags\";\nimport { ProgramBuilder } from \"../ShaderBuilder\";\nimport { System } from \"../System\";\nimport { addAtmosphericScatteringEffect } from \"./Atmosphere\";\nimport { addVaryingColor } from \"./Color\";\nimport { addEyeSpace, addShaderFlags, addUInt32s } from \"./Common\";\nimport { decodeDepthRgb, unquantize2d } from \"./Decode\";\nimport { addFeatureSymbology, addHiliter } from \"./FeatureSymbology\";\nimport { addAltPickBufferOutputs, addPickBufferOutputs, assignFragColor } from \"./Fragment\";\nimport { addColorPlanarClassifier, addFeaturePlanarClassifier, addHilitePlanarClassifier } from \"./PlanarClassification\";\nimport { addSolarShadowMap } from \"./SolarShadowMapping\";\nimport { addClassificationTranslucencyDiscard, octDecodeNormal } from \"./Surface\";\nimport { addThematicDisplay, getComputeThematicIndex } from \"./Thematic\";\nimport { addModelViewProjectionMatrix, addNormalMatrix } from \"./Vertex\";\nimport { addWiremesh } from \"./Wiremesh\";\nconst computePosition = \"gl_PointSize = 1.0; return MAT_MVP * rawPos;\";\nconst computeNormal = `\r\n  vec3 normal = octDecodeNormal(a_norm); // normal coming in for is already in world space\r\n  g_hillshadeIndex = normal.z;           // save off world Z for thematic hill shade mode index\r\n  return normalize(u_worldToViewN * normal);\r\n`;\nexport const finalizeNormal = `\r\n  return normalize(v_n) * (2.0 * float(gl_FrontFacing) - 1.0);\r\n`;\nconst testInside = `\r\nbool testInside(float x0, float y0, float x1, float y1, float x, float y) {\r\n  vec2 perp = vec2(y0 - y1, x1 - x0), test = vec2(x - x0, y - y0);\r\n  float dot = (test.x * perp.x + test.y * perp.y) / sqrt(perp.x * perp.x + perp.y * perp.y);\r\n  return dot >= -0.001;\r\n}\r\n`;\n/* There are two methods of applying a texture to a reality mesh.  the first member of \"params\" denotes which\n  method is to be used.  A value of zero indicates a standard texture and one represents a projected texture.\n\n  A standard (nonprojected) texture is generated by multiplying v_textCoord by the scaling and translation packed into the first row\n  of \"matrix\". A clip rectangle is packed into second row of \"matrix\".\n\n  A \"projected\" reality mesh texture is used for map layers.  It does not uses v_texCoord, the texture coordinates\n  are instead generated by a projection of the model position onto the X-Y plane. We only have eye position, not model position\n  so the matrix in this case is a real transform matrix that contains a mapping from eye to model position\n  followed by the model to texture projection.\n*/\nconst applyTexture = `\r\nbool applyTexture(inout vec4 col, sampler2D sampler, mat4 params, mat4 matrix) {\r\n  vec2 uv;\r\n  float layerAlpha;\r\n  bool isProjected = params[0][0] != 0.0;\r\n  float imageCount = params[0][1];\r\n  vec2 classPos;\r\n\r\n  if (isProjected) {\r\n    vec4 eye4 = vec4(v_eyeSpace, 1.0);\r\n    vec4 classPos4 = matrix * eye4;\r\n    classPos = classPos4.xy / classPos4.w;\r\n\r\n    if (!testInside(params[2].x, params[2].y, params[2].z, params[2].w, classPos.x, classPos.y) ||\r\n        !testInside(params[2].z, params[2].w, params[3].x, params[3].y, classPos.x, classPos.y) ||\r\n        !testInside(params[3].x, params[3].y, params[3].z, params[3].w, classPos.x, classPos.y) ||\r\n        !testInside(params[3].z, params[3].w, params[2].x, params[2].y, classPos.x, classPos.y))\r\n        return false;\r\n\r\n    uv.x = classPos.x;\r\n    uv.y = classPos.y / imageCount;\r\n    layerAlpha = params[0][2];\r\n\r\n    if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0)\r\n      return false;\r\n\r\n  } else {\r\n    vec4 texTransform = matrix[0].xyzw;\r\n    vec4 texClip = matrix[1].xyzw;\r\n    layerAlpha = matrix[2].x;\r\n    uv = vec2(texTransform[0] + texTransform[2] * v_texCoord.x, texTransform[1] + texTransform[3] * v_texCoord.y);\r\n\r\n    if (uv.x < texClip[0] || uv.x > texClip[2] || uv.y < texClip[1] || uv.y > texClip[3])\r\n      return false;\r\n\r\n    uv.y = 1.0 - uv.y;\r\n  }\r\n\r\n  vec4 texCol = TEXTURE(sampler, uv);\r\n  float alpha = layerAlpha * texCol.a;\r\n\r\n  if (alpha > 0.05) {\r\n    vec3 texRgb = isProjected ? (texCol.rgb / texCol.a) : texCol.rgb; // If projected, undo premultiplication\r\n    // Texture color is premultiplied earlier by alpha only if projected (from classification).\r\n\r\n    col.rgb = (1.0 - alpha) * col.rgb + alpha * texRgb;\r\n\r\n    if (isProjected) {\r\n      vec4 featureTexel = TEXTURE(sampler, vec2(uv.x, (1.0 + classPos.y) / imageCount));\r\n      classifierId = addUInt32s(params[1], featureTexel * 255.0) / 255.0;\r\n    } else {\r\n      featureIncrement = matrix[2].y;\r\n      classifierId = vec4(0);\r\n    }\r\n\r\n    if (alpha > col.a)\r\n      col.a = alpha;\r\n\r\n    return true;\r\n  }\r\n\r\n  // If texture color is transparent but base color is not, return true (don't discard)\r\n  // Else return false (discard) if both the texture and base color are transparent\r\n  return (col.a > 0.05);\r\n}\r\n`;\nconst computeTexCoord = \"return unquantize2d(a_uvParam, u_qTexCoordParams);\";\nconst scratchMatrix4d1 = Matrix4d.createIdentity();\nconst scratchMatrix4d2 = Matrix4d.createIdentity();\nconst scratchMatrix = new Matrix4();\nconst overrideFeatureId = `return (classifierId == vec4(0)) ? (addUInt32s(feature_id * 255.0, vec4(featureIncrement, 0.0, 0.0, 0.0)) / 255.0) : classifierId;`;\nfunction addTextures(builder, maxTexturesPerMesh) {\n    builder.vert.addFunction(unquantize2d);\n    builder.addFunctionComputedVarying(\"v_texCoord\", 3 /* VariableType.Vec2 */, \"computeTexCoord\", computeTexCoord);\n    builder.vert.addUniform(\"u_qTexCoordParams\", 5 /* VariableType.Vec4 */, (prog) => {\n        prog.addGraphicUniform(\"u_qTexCoordParams\", (uniform, params) => {\n            const realityMesh = params.geometry.asRealityMesh;\n            if (undefined !== realityMesh.uvQParams) {\n                uniform.setUniform4fv(realityMesh.uvQParams);\n            }\n        });\n    });\n    builder.frag.addUniform(\"u_texturesPresent\", 0 /* VariableType.Boolean */, (program) => {\n        program.addGraphicUniform(\"u_texturesPresent\", (uniform, params) => {\n            uniform.setUniform1i(params.geometry.asRealityMesh.hasTextures ? 1 : 0);\n        });\n    });\n    for (let i = 0; i < maxTexturesPerMesh; i++) {\n        const textureLabel = `s_texture${i}`;\n        builder.frag.addUniform(textureLabel, 8 /* VariableType.Sampler2D */, (prog) => {\n            prog.addGraphicUniform(textureLabel, (uniform, params) => {\n                const textureUnits = [TextureUnit.RealityMesh0, TextureUnit.RealityMesh1, params.target.drawForReadPixels ? TextureUnit.ShadowMap : TextureUnit.PickDepthAndOrder, TextureUnit.RealityMesh3, TextureUnit.RealityMesh4, TextureUnit.RealityMesh5];\n                const realityMesh = params.geometry.asRealityMesh;\n                const realityTexture = realityMesh.textureParams ? realityMesh.textureParams.params[i].texture : undefined;\n                if (realityTexture !== undefined) {\n                    const texture = realityTexture;\n                    texture.texture.bindSampler(uniform, textureUnits[i]);\n                }\n                else {\n                    // assert(false, \"Terrain Mesh texture not defined when beginning texture.\");\n                    System.instance.ensureSamplerBound(uniform, textureUnits[i]);\n                }\n            });\n        });\n        const paramsLabel = `u_texParams${i}`, matrixLabel = `u_texMatrix${i}`;\n        builder.frag.addUniform(matrixLabel, 7 /* VariableType.Mat4 */, (prog) => {\n            prog.addGraphicUniform(matrixLabel, (uniform, params) => {\n                const realityMesh = params.geometry.asRealityMesh;\n                const textureParam = realityMesh.textureParams?.params[i];\n                assert(undefined !== textureParam);\n                if (undefined !== textureParam) {\n                    const projectionMatrix = textureParam.getProjectionMatrix();\n                    if (projectionMatrix) {\n                        const eyeToModel = Matrix4d.createTransform(params.target.uniforms.frustum.viewMatrix.inverse(), scratchMatrix4d1);\n                        const eyeToTexture = projectionMatrix.multiplyMatrixMatrix(eyeToModel, scratchMatrix4d2);\n                        uniform.setMatrix4(Matrix4.fromMatrix4d(eyeToTexture, scratchMatrix));\n                    }\n                    else\n                        uniform.setMatrix4(textureParam.getTerrainMatrix());\n                }\n            });\n        });\n        builder.frag.addUniform(paramsLabel, 7 /* VariableType.Mat4 */, (prog) => {\n            prog.addGraphicUniform(paramsLabel, (uniform, params) => {\n                const realityMesh = params.geometry.asRealityMesh;\n                const textureParam = realityMesh.textureParams?.params[i];\n                assert(undefined !== textureParam);\n                if (undefined !== textureParam) {\n                    uniform.setMatrix4(textureParam.getParams(scratchMatrix));\n                }\n            });\n        });\n    }\n}\nfunction baseColorFromTextures(textureCount, applyFeatureColor) {\n    const applyTextureStrings = [];\n    for (let i = 0; i < textureCount; i++)\n        applyTextureStrings.push(`if (applyTexture(col, s_texture${i}, u_texParams${i}, u_texMatrix${i})) doDiscard = false; `);\n    return `\r\n  if (!u_texturesPresent) {\r\n    vec4 col = u_baseColor;\r\n    ${applyFeatureColor}\r\n    return col;\r\n  }\r\n\r\n  bool doDiscard = true;\r\n  vec4 col = u_baseColor;\r\n  ${applyTextureStrings.join(\"\\n  \")}\r\n  if (doDiscard)\r\n    discard;\r\n\r\n  ${applyFeatureColor}\r\n\r\n  return col;\r\n`;\n}\n// feature_rgb.r = -1.0 if rgb color not overridden for feature.\n// feature_alpha = -1.0 if alpha not overridden for feature.\nconst mixFeatureColor = `\r\n  col.rgb = mix(col.rgb, mix(col.rgb, v_color.rgb, u_overrideColorMix), step(0.0, v_color.r));\r\n  col.a = mix(col.a, v_color.a, step(0.0, v_color.a));\r\n  `;\nfunction addThematicToRealityMesh(builder, gradientTextureUnit) {\n    addNormalMatrix(builder.vert);\n    builder.vert.addFunction(octDecodeNormal);\n    builder.vert.addGlobal(\"g_hillshadeIndex\", 2 /* VariableType.Float */);\n    builder.addFunctionComputedVarying(\"v_n\", 4 /* VariableType.Vec3 */, \"computeLightingNormal\", computeNormal);\n    builder.frag.addGlobal(\"g_normal\", 4 /* VariableType.Vec3 */);\n    builder.frag.set(22 /* FragmentShaderComponent.FinalizeNormal */, finalizeNormal);\n    addThematicDisplay(builder, false, true);\n    builder.addInlineComputedVarying(\"v_thematicIndex\", 2 /* VariableType.Float */, getComputeThematicIndex(builder.vert.usesInstancedGeometry, false, false));\n    builder.vert.addUniform(\"u_worldToViewN\", 6 /* VariableType.Mat3 */, (prog) => {\n        prog.addGraphicUniform(\"u_worldToViewN\", (uniform, params) => {\n            params.target.uniforms.branch.bindWorldToViewNTransform(uniform, params.geometry, false);\n        });\n    });\n    builder.frag.addUniform(\"s_texture\", 8 /* VariableType.Sampler2D */, (prog) => {\n        prog.addGraphicUniform(\"s_texture\", (uniform, params) => {\n            params.target.uniforms.thematic.bindTexture(uniform, gradientTextureUnit >= 0 ? gradientTextureUnit : (params.target.drawForReadPixels ? TextureUnit.ShadowMap : TextureUnit.PickDepthAndOrder));\n        });\n    });\n}\n/** @internal */\nexport function addColorOverrideMix(frag) {\n    frag.addUniform(\"u_overrideColorMix\", 2 /* VariableType.Float */, (prog) => {\n        prog.addGraphicUniform(\"u_overrideColorMix\", (uniform, params) => {\n            params.target.uniforms.realityModel.bindOverrideColorMix(uniform);\n        });\n    });\n}\nfunction createRealityMeshHiliterBuilder() {\n    const builder = new ProgramBuilder(AttributeMap.findAttributeMap(7 /* TechniqueId.RealityMesh */, false));\n    const vert = builder.vert;\n    vert.set(10 /* VertexShaderComponent.ComputePosition */, computePosition);\n    addModelViewProjectionMatrix(vert);\n    builder.frag.set(16 /* FragmentShaderComponent.AssignFragData */, assignFragColor);\n    return builder;\n}\n/** @internal */\nexport function createClassifierRealityMeshHiliter() {\n    const builder = createRealityMeshHiliterBuilder();\n    addHilitePlanarClassifier(builder, false);\n    return builder;\n}\n/** @internal */\nexport function createRealityMeshHiliter() {\n    const builder = createRealityMeshHiliterBuilder();\n    addHiliter(builder, false);\n    return builder;\n}\n/** @internal */\nexport function createRealityMeshBuilder(flags) {\n    const builder = new ProgramBuilder(AttributeMap.findAttributeMap(7 /* TechniqueId.RealityMesh */, false));\n    const vert = builder.vert;\n    vert.set(10 /* VertexShaderComponent.ComputePosition */, computePosition);\n    addModelViewProjectionMatrix(vert);\n    if (flags.isShadowable === 1 /* IsShadowable.Yes */)\n        addSolarShadowMap(builder, true);\n    const frag = builder.frag;\n    frag.addGlobal(\"featureIncrement\", 2 /* VariableType.Float */, \"0.0\");\n    frag.addGlobal(\"classifierId\", 5 /* VariableType.Vec4 */);\n    frag.set(17 /* FragmentShaderComponent.OverrideFeatureId */, overrideFeatureId);\n    const textureCount = System.instance.maxRealityImageryLayers;\n    const gradientTextureUnit = TextureUnit.RealityMeshThematicGradient;\n    const feat = flags.featureMode;\n    let opts = 2 /* FeatureMode.Overrides */ === feat ? 28 /* FeatureSymbologyOptions.Surface */ : 0 /* FeatureSymbologyOptions.None */;\n    let applyFragmentFeatureColor = \"\";\n    if (flags.isClassified) {\n        opts &= ~16 /* FeatureSymbologyOptions.Alpha */;\n        addColorPlanarClassifier(builder, flags.isTranslucent, flags.isThematic);\n        addClassificationTranslucencyDiscard(builder);\n    }\n    addFeatureSymbology(builder, feat, opts);\n    if (feat === 2 /* FeatureMode.Overrides */) {\n        addShaderFlags(builder);\n        addVaryingColor(builder, \"return vec4(-1.0, -1.0, -1.0, -1.0);\");\n        applyFragmentFeatureColor = mixFeatureColor;\n        addColorOverrideMix(builder.frag);\n    }\n    const computeFragmentBaseColor = baseColorFromTextures(textureCount, applyFragmentFeatureColor);\n    frag.addFunction(addUInt32s);\n    frag.addFunction(testInside);\n    addEyeSpace(builder);\n    frag.addFunction(applyTexture);\n    frag.set(1 /* FragmentShaderComponent.ComputeBaseColor */, computeFragmentBaseColor);\n    builder.frag.addUniform(\"u_baseColor\", 5 /* VariableType.Vec4 */, (prog) => {\n        prog.addGraphicUniform(\"u_baseColor\", (uniform, params) => {\n            const realityMesh = params.geometry.asRealityMesh;\n            const baseColor = (realityMesh.baseColor ? realityMesh.baseColor : ColorDef.create(0xff000000)).colors;\n            uniform.setUniform4fv([baseColor.r / 255, baseColor.g / 255, baseColor.b / 255, 1 - baseColor.t / 255]);\n        });\n    });\n    builder.frag.set(1 /* FragmentShaderComponent.ComputeBaseColor */, computeFragmentBaseColor);\n    if (!flags.isTranslucent) {\n        if (0 /* FeatureMode.None */ !== feat) {\n            if (flags.isClassified)\n                addFeaturePlanarClassifier(builder);\n            builder.frag.addFunction(decodeDepthRgb);\n            if (flags.isClassified)\n                addPickBufferOutputs(builder.frag);\n            else\n                addAltPickBufferOutputs(builder.frag);\n        }\n    }\n    addTextures(builder, textureCount);\n    if (1 /* IsThematic.Yes */ === flags.isThematic)\n        addThematicToRealityMesh(builder, gradientTextureUnit);\n    if (flags.isWiremesh)\n        addWiremesh(builder);\n    if (flags.enableAtmosphere)\n        addAtmosphericScatteringEffect(builder, false, false);\n    return builder;\n}\n//# sourceMappingURL=RealityMesh.js.map",
      "start": 1693508125918,
      "end": 1693508126027,
      "sourcemaps": null
    }
  ]
}
