{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/topology/Graph.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Topology\n */\nimport { LineSegment3d } from \"../curve/LineSegment3d\";\nimport { Geometry } from \"../Geometry\";\nimport { Angle } from \"../geometry3d/Angle\";\nimport { Point2d, Vector2d } from \"../geometry3d/Point2dVector2d\";\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\nimport { SmallSystem } from \"../numerics/Polynomials\";\nimport { MaskManager } from \"./MaskManager\";\n// import { GraphChecker } from \"../test/topology/Graph.test\";\n/* eslint-disable @typescript-eslint/no-this-alias */\n// cspell:word CONSTU\n// cspell:word CONSTV\n// cspell:word USEAM\n// cspell:word VSEAM\n/**\n * * Each node of the graph has a mask member.\n * * The mask member is a number which is used as set of single bit boolean values.\n * * Particular meanings of the various bits are HIGHLY application dependent.\n *   * The EXTERIOR mask bit is widely used to mark nodes that are \"outside\" the active areas\n *   * The PRIMARY_EDGE bit is widely used to indicate linework created directly from input data, hence protected from triangle edge flipping.\n *   * The BOUNDARY bit is widely used to indicate that crossing this edge is a transition from outside to inside.\n *   * VISITED is used locally in many searches.\n *      * Never use VISITED unless the search logic is highly self contained.\n * @internal\n */\nexport var HalfEdgeMask;\n(function (HalfEdgeMask) {\n    /**  Mask commonly set consistently around exterior faces.\n     * * A boundary edge with interior to one side, exterior to the other will have EXTERIOR only on the outside.\n     * * An an edge inserted \"within a purely exterior face\" can have EXTERIOR on both sides.\n     * * An interior edge (such as added during triangulation) will have no EXTERIOR bits.\n     */\n    HalfEdgeMask[HalfEdgeMask[\"EXTERIOR\"] = 1] = \"EXTERIOR\";\n    /** Mask commonly set (on both sides) of original geometry edges that are transition from outside from to inside.\n     * * At the moment of creating an edge from primary user boundary loop coordinates, the fact that an edge is BOUNDARY is often clear even though\n     *  there is uncertainty about which side should be EXTERIOR.\n     */\n    HalfEdgeMask[HalfEdgeMask[\"BOUNDARY_EDGE\"] = 2] = \"BOUNDARY_EDGE\";\n    // REMARK: Various mask names are COMMENTED here for reference to native legacy code.\n    // CONSTU_MASK = 0x00000004,\n    // CONSTV_MASK = 0x00000008,\n    // USEAM_MASK = 0x00000010,\n    // VSEAM_MASK = 0x00000020,\n    // BOUNDARY_VERTEX_MASK = 0x00000040,\n    // PRIMARY_VERTEX_MASK = 0x00000080,\n    // DIRECTED_EDGE_MASK = 0x00000100,\n    /** Mask commonly set (on both sides) of original geometry edges, but NOT indicating that the edge is certainly a boundary between outside and inside.\n     * * For instance, if geometry is provided as stray sticks (not loops), it can be marked PRIMARY_EDGE but neither BOUNDARY_EDGE nor EXTERIOR_EDGE\n     */\n    HalfEdgeMask[HalfEdgeMask[\"PRIMARY_EDGE\"] = 4] = \"PRIMARY_EDGE\";\n    /** Mask used for low level searches to identify previously-visited nodes */\n    HalfEdgeMask[HalfEdgeMask[\"VISITED\"] = 16] = \"VISITED\";\n    /** Mask applied to triangles by earcut triangulator */\n    HalfEdgeMask[HalfEdgeMask[\"TRIANGULATED_FACE\"] = 256] = \"TRIANGULATED_FACE\";\n    /** mask applied in a face with 2 edges. */\n    HalfEdgeMask[HalfEdgeMask[\"NULL_FACE\"] = 512] = \"NULL_FACE\";\n    /** no mask bits */\n    HalfEdgeMask[HalfEdgeMask[\"NULL_MASK\"] = 0] = \"NULL_MASK\";\n    /** The \"upper 12 \" bits of 32 bit integer. */\n    HalfEdgeMask[HalfEdgeMask[\"ALL_GRAB_DROP_MASKS\"] = 4293918720] = \"ALL_GRAB_DROP_MASKS\";\n    /** all mask bits */\n    HalfEdgeMask[HalfEdgeMask[\"ALL_MASK\"] = 4294967295] = \"ALL_MASK\";\n    // informal convention on preassigned mask bit numbers:\n    // byte0 (EXTERIOR, BOUNDARY_EDGE, PRIMARY_EDGE) -- edge properties\n    // byte1 (VISITED, VISIT_A, WORK_MASK0, WORK_MASK1) -- temp masks for algorithms.\n    // byte2 (TRIANGULATED_FACE, NULL_FACE) -- face properties.\n})(HalfEdgeMask || (HalfEdgeMask = {}));\n/**\n *\n * * A HalfEdge is \"one side of an edge\" in a structure of faces, edges and vertices.  From a node there are navigational links to:\n * ** \"faceSuccessor\" -- the next half edge in a loop around a face.\n * ** \"facePredecessor\" -- the previous half edge in a loop around a face.\n * ** \"edgeMate\"  -- the node's partner on the other side of the edge.\n * * The next, prev, and mate are the essential connectivity.  Additional node content is for application-specific\n *     uses.  The most useful ones are:\n * ** x,y -- coordinates in the xy plane\n * ** z -- z coordinate.  This is normally ignored during planar setup, but used for output.\n * ** buffer -- a integer value manipulated as individual bits.\n * * In properly connected planar graph, interior face loops are counterclockwise.  But that property (along with\n *      expected masking) is a result of extensive validation of inputs, and is not true in intermediate phases\n *      of graph manipulation.\n * @internal\n */\nclass HalfEdge {\n    /** id assigned sequentially during construction --- useful for debugging. */\n    get id() { return this._id; }\n    /** previous half edge \"around the face\"\n     */\n    get facePredecessor() { return this._facePredecessor; }\n    /** next half edge \"around the face\" */\n    get faceSuccessor() { return this._faceSuccessor; }\n    /** Half edge on the other side of this edge.\n     */\n    get edgeMate() { return this._edgeMate; }\n    /** Take numStep face steps and return y coordinate\n     * * positive steps are through faceSuccessor\n     * * negative steps are through facePredecessor\n     */\n    faceStepY(numStep) {\n        let node = this;\n        if (numStep > 0)\n            for (let i = 0; i < numStep; i++)\n                node = node.faceSuccessor;\n        else if (numStep < 0)\n            for (let i = 0; i > numStep; i--)\n                node = node.facePredecessor;\n        return node.y;\n    }\n    /**\n     * * Create 2 half edges.\n     * * The two edges are joined as edgeMate pair.\n     * * The two edges are a 2-half-edge face loop in both the faceSuccessor and facePredecessor directions.\n     * @returns Returns the reference to the first half edge created\n     */\n    static createHalfEdgePair(heArray) {\n        const a = new HalfEdge();\n        const b = new HalfEdge();\n        if (heArray) {\n            heArray.push(a);\n            heArray.push(b);\n        }\n        HalfEdge.setFaceLinks(a, b);\n        HalfEdge.setFaceLinks(b, a);\n        HalfEdge.setEdgeMates(a, b);\n        return a;\n    }\n    /**\n     * * Create 2 half edges.\n     * * The two edges are joined as edgeMate pair.\n     * * The two edges are a 2-half-edge face loop in both the faceSuccessor and facePredecessor directions.\n     * * Properties x,y,z,i are inserted in each\n     * @returns Returns the reference to the first half edge created\n     */\n    static createHalfEdgePairWithCoordinates(xA = 0, yA = 0, zA = 0, iA = 0, xB = 0, yB = 0, zB = 0, iB = 0, heArray) {\n        const a = HalfEdge.createHalfEdgePair(heArray);\n        const b = a._edgeMate;\n        a.x = xA;\n        a.y = yA;\n        a.z = zA;\n        a.i = iA;\n        b.x = xB;\n        b.y = yB;\n        b.z = zB;\n        b.i = iB;\n        return a;\n    }\n    /**\n     * * set heA <==> heB pointer relation through heA._faceSuccessor and heB._facePredecessor\n     * * This changes heA._faceSuccessor and heB._facePredecessor, but not heA._facePredecessor and heB._faceSuccessor.\n     * * this must always be done with another call to reestablish the entire double-linked list.\n     */\n    static setFaceLinks(heA, heB) {\n        heA._faceSuccessor = heB;\n        heB._facePredecessor = heA;\n    }\n    /**\n     * * set heA <==> heB pointer relation edgeMate\n     */\n    static setEdgeMates(heA, heB) {\n        heA._edgeMate = heB;\n        heB._edgeMate = heA;\n    }\n    /**\n     * * Create a new vertex within the edge from base.\n     * * Insert it \"within\" the base edge.\n     * * This requires two new half edges.\n     * * if the base is undefined, create a single-edge loop.\n     * * This (unlike pinch) breaks the edgeMate pairing of the base edge.\n     * * This preserves xyz and i properties at all existing vertices.\n     * * on each side, if edgeTag is present it is copied to the new edge.\n     * @returns Returns the reference to the half edge created.\n     */\n    static splitEdge(baseA, xA = 0, yA = 0, zA = 0, iA = 0, heArray) {\n        const newA = new HalfEdge(xA, yA, zA, iA);\n        const newB = new HalfEdge(xA, yA, zA, iA);\n        if (heArray) {\n            heArray.push(newA);\n            heArray.push(newB);\n        }\n        if (baseA === undefined) {\n            newA._faceSuccessor = newA._facePredecessor = newA;\n            newB._faceSuccessor = newB._facePredecessor = newB;\n            HalfEdge.setEdgeMates(newA, newB);\n        }\n        else {\n            const nextA = baseA._faceSuccessor;\n            const mateA = baseA._edgeMate;\n            const vPredA = mateA._faceSuccessor;\n            HalfEdge.setFaceLinks(newA, nextA);\n            HalfEdge.setFaceLinks(baseA, newA);\n            HalfEdge.setFaceLinks(mateA, newB);\n            HalfEdge.setFaceLinks(newB, vPredA);\n            HalfEdge.setEdgeMates(newA, mateA);\n            HalfEdge.setEdgeMates(newB, baseA);\n            this.transferEdgeProperties(baseA, newA);\n            this.transferEdgeProperties(mateA, newB);\n        }\n        return newA;\n    }\n    /**\n     * * Create a new sliver face \"inside\" an existing edge.\n     * * Insert it \"within\" the base edge.\n     * * This requires two new half edges.\n     * * if the base is undefined, create a single-edge loop.\n     * * This (unlike pinch) breaks the edgeMate pairing of the base edge.\n     * * This preserves xyz and i properties at all existing vertices.\n     * * The two new half edges are a sliver face (via their predecessor and successor)\n     * * Each new edge mates to one existing edge.\n     * @returns Returns the reference to the half edge created.\n     */\n    static splitEdgeCreateSliverFace(baseA, heArray) {\n        // raw edges ...\n        const newA = new HalfEdge();\n        const newB = new HalfEdge();\n        const baseB = baseA.edgeMate;\n        if (heArray) {\n            heArray.push(newA);\n            heArray.push(newB);\n        }\n        newA._faceSuccessor = newA._facePredecessor = newB;\n        newB._faceSuccessor = newB._facePredecessor = newA;\n        // newA is in vertex loop with baseA etc.\n        // newA mates to baseB\n        HalfEdge.setEdgeMates(newA, baseB);\n        HalfEdge.setEdgeMates(newB, baseA);\n        newA.copyDataFrom(baseA, true, true, false, false);\n        newB.copyDataFrom(baseB, true, true, false, false);\n        return newA;\n    }\n    /**\n     * Copy \"edge based\" content of fromNode to toNode\n     * * edgeTag\n     * * masks in _edgePropertyMasks: EXTERIOR, BOUNDARY_EDGE, NULL_FACE, PRIMARY_EDGE\n     * @param fromNode\n     * @param toNode\n     */\n    static transferEdgeProperties(fromNode, toNode) {\n        toNode.edgeTag = fromNode.edgeTag;\n        for (const mask of this._edgePropertyMasks) {\n            if (fromNode.getMask(mask))\n                toNode.setMask(mask);\n            else\n                toNode.clearMask(mask);\n        }\n    }\n    constructor(x = 0, y = 0, z = 0, i = 0) {\n        this._id = HalfEdge._totalNodesCreated++;\n        this.i = i;\n        this.maskBits = 0x00000000;\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        // Explicit init to undefined is important for performance here\n        this.sortAngle = undefined;\n        this.sortData = undefined;\n        this.edgeTag = undefined;\n        this.faceTag = undefined;\n        // Always created in pairs, init here to make TS compiler and JS runtime happy\n        this._facePredecessor = this;\n        this._faceSuccessor = this;\n        this._edgeMate = this;\n    }\n    /**\n     * Return the next outbound half edge around this vertex in the CCW direction\n     */\n    get vertexSuccessor() { return this.facePredecessor.edgeMate; }\n    /**\n     * Return the next outbound half edge around this vertex in the CW direction\n     */\n    get vertexPredecessor() { return this.edgeMate.faceSuccessor; }\n    /**\n     * Set mask bits on this HalfEdge\n     * @param mask mask to apply\n     */\n    setMask(mask) { this.maskBits |= mask; }\n    /**\n     * Get mask bits from this HalfEdge\n     * @param mask mask to query\n     */\n    getMask(mask) { return (this.maskBits & mask); }\n    /**\n     * Clear mask bits from this HalfEdge\n     * @param mask mask to clear\n     */\n    clearMask(mask) { this.maskBits &= ~mask; }\n    /**\n     * Set a mask at all nodes around a vertex.\n     * @param mask mask to apply to the half edges around this HalfEdge's vertex loop\n     */\n    setMaskAroundVertex(mask) {\n        let node = this;\n        do {\n            node.setMask(mask);\n            node = node.vertexSuccessor;\n        } while (node !== this);\n    }\n    /**\n     * Set x,y,z at all nodes around a vertex.\n     * @param mask mask to apply to the half edges around this HalfEdge's vertex loop\n     */\n    setXYZAroundVertex(x, y, z) {\n        let node = this;\n        do {\n            node.x = x;\n            node.y = y;\n            node.z = z;\n            node = node.vertexSuccessor;\n        } while (node !== this);\n    }\n    /**\n     * Apply a mask to all edges around a face.\n     * @param mask mask to apply to the half edges around this HalfEdge's face loop\n     */\n    setMaskAroundFace(mask) {\n        let node = this;\n        do {\n            node.setMask(mask);\n            node = node.faceSuccessor;\n        } while (node !== this);\n    }\n    /**\n     * Apply a mask to both sides of an edge.\n     * @param mask mask to apply to this edge and its `edgeMate`\n     */\n    setMaskAroundEdge(mask) {\n        this.setMask(mask);\n        this.edgeMate.setMask(mask);\n    }\n    /**\n     * Apply a mask to both sides of an edge.\n     * @param mask mask to apply to this edge and its `edgeMate`\n     */\n    clearMaskAroundEdge(mask) {\n        this.clearMask(mask);\n        this.edgeMate.clearMask(mask);\n    }\n    /** Returns the number of edges around this face. */\n    countEdgesAroundFace() {\n        let count = 0;\n        let node = this;\n        do {\n            count++;\n            node = node.faceSuccessor;\n        } while (node !== this);\n        return count;\n    }\n    /** Return true if other is in the vertex loop around this. */\n    findAroundVertex(other) {\n        let node = this;\n        do {\n            if (node === other)\n                return true;\n            node = node.vertexSuccessor;\n        } while (node !== this);\n        return false;\n    }\n    /** Return true if other is in the face loop around this. */\n    findAroundFace(other) {\n        let node = this;\n        do {\n            if (node === other)\n                return true;\n            node = node.faceSuccessor;\n        } while (node !== this);\n        return false;\n    }\n    /**\n     * @return whether the mask is set (or unset) on all nodes of the face loop\n     */\n    isMaskedAroundFace(mask, value = true) {\n        let node = this;\n        if (value) {\n            do {\n                if (!node.isMaskSet(mask))\n                    return false;\n                node = node.faceSuccessor;\n            } while (node !== this);\n        }\n        else {\n            do {\n                if (node.isMaskSet(mask))\n                    return false;\n                node = node.faceSuccessor;\n            } while (node !== this);\n        }\n        return true;\n    }\n    /**\n     * Apply a edgeTag and mask to all edges around a face.\n     * optionally apply it to all edge mates.\n     * @param edgeTag tag to apply\n     * @param bothSides If true, also apply the tag to the mates around the face.\n     */\n    setMaskAndEdgeTagAroundFace(mask, tag, applyToMate = false) {\n        let node = this;\n        do {\n            node.setMask(mask);\n            node.edgeTag = tag;\n            if (applyToMate) {\n                const mate = node.edgeMate;\n                mate.edgeTag = tag;\n                mate.setMask(mask);\n            }\n            node = node.faceSuccessor;\n        } while (node !== this);\n    }\n    /** Returns the number of edges around vertex. */\n    countEdgesAroundVertex() {\n        let count = 0;\n        let node = this;\n        do {\n            count++;\n            node = node.vertexSuccessor;\n        } while (node !== this);\n        return count;\n    }\n    /** Returns the number of nodes found with the given mask value around this vertex loop. */\n    countMaskAroundFace(mask, value = true) {\n        let count = 0;\n        let node = this;\n        if (value) {\n            do {\n                if (node.isMaskSet(mask))\n                    count++;\n                node = node.faceSuccessor;\n            } while (node !== this);\n        }\n        else {\n            do {\n                if (!node.isMaskSet(mask))\n                    count++;\n                node = node.faceSuccessor;\n            } while (node !== this);\n        }\n        return count;\n    }\n    /** Returns the number of nodes found with the given mask value around this vertex loop.   */\n    countMaskAroundVertex(mask, value = true) {\n        let count = 0;\n        let node = this;\n        if (value) {\n            do {\n                if (node.isMaskSet(mask))\n                    count++;\n                node = node.vertexSuccessor;\n            } while (node !== this);\n        }\n        else {\n            do {\n                if (!node.isMaskSet(mask))\n                    count++;\n                node = node.vertexSuccessor;\n            } while (node !== this);\n        }\n        return count;\n    }\n    /** Returns the first node with given mask value around this vertex loop.   */\n    findMaskAroundVertex(mask, value = true) {\n        let node = this;\n        do {\n            if (node.isMaskSet(mask) === value)\n                return node;\n            node = node.vertexSuccessor;\n        } while (node !== this);\n        return undefined;\n    }\n    /** Returns the first node with given mask value around this face loop.   */\n    findMaskAroundFace(mask, value = true) {\n        let node = this;\n        do {\n            if (node.isMaskSet(mask) === value)\n                return node;\n            node = node.faceSuccessor;\n        } while (node !== this);\n        return undefined;\n    }\n    /** Returns the first node with given mask value on this edge (i.e. examining this and this.mate)  */\n    findMaskAroundEdge(mask, value = true) {\n        if (this.isMaskSet(mask) === value)\n            return this;\n        const mate = this.edgeMate;\n        if (mate.isMaskSet(mask) === value)\n            return mate;\n        return undefined;\n    }\n    /** Set a mask, and return prior value.\n     * @param mask mask to apply\n     */\n    testAndSetMask(mask) {\n        const oldMask = this.maskBits & mask;\n        this.maskBits |= mask;\n        return oldMask;\n    }\n    /**\n     * Set (copy) the this.x, this.y, this.z from node.x, node.y, node.z\n     * @param node node containing xyz\n     */\n    setXYZFrom(node) {\n        this.x = node.x;\n        this.y = node.y;\n        this.z = node.z;\n    }\n    /**\n     * Set (copy) the this.x, this.y, this.z from xyz.x, xyz.y, xyz.z\n     * @param node source with x,y,z properties\n     */\n    setXYZ(xyz) {\n        this.x = xyz.x;\n        this.y = xyz.y;\n        this.z = xyz.z;\n    }\n    /**\n     * Test if mask bits are set in the node's bitMask.\n     * @return Return true (as a simple boolean, not a mask) if any bits of the mask parameter match bits of the node's bitMask\n     */\n    isMaskSet(mask) { return (this.maskBits & mask) !== 0; }\n    /** (static!) method to test if a mask is set on a node.\n     * This is used as filter in searches.\n     * @returns true iff `node.isMaskSet (mask)`\n     */\n    static filterIsMaskOn(node, mask) {\n        return node.isMaskSet(mask);\n    }\n    /** (static!) method to test if a mask is set on a node.\n     * This is used as filter in searches.\n     * @returns true iff `!node.isMaskSet (mask)`\n     */\n    static filterIsMaskOff(node, mask) {\n        return !node.isMaskSet(mask);\n    }\n    /**\n     * Create an edge with initial id,x,y at each end.\n     * @param id0 id for first node\n     * @param x0  x coordinate for first node\n     * @param y0  y coordinate for first node\n     * @param id1 id for second node\n     * @param x1 x coordinate for second node\n     * @param y1 y coordinate for second node\n     */\n    static createEdgeXYXY(id0, x0, y0, id1, x1, y1) {\n        const node0 = new HalfEdge(x0, y0);\n        const node1 = new HalfEdge(x1, y1);\n        node0._faceSuccessor = node0._facePredecessor = node0._edgeMate = node1;\n        node1._faceSuccessor = node1._facePredecessor = node1._edgeMate = node0;\n        node0._id = id0;\n        node1._id = id1;\n        return node0;\n    }\n    /** \"pinch\" ...\n     *\n     * * is the universal manipulator for manipulating a node's next and prev pointers\n     * * swaps face predecessors of nodeA and nodeB.\n     * *  is its own inverse.\n     * *  if nodeA, nodeB are in different face loops, the loops join to one loop.\n     * *  if nodeA, nodeB are in the same face loop, the loop splits into two loops.\n     */\n    static pinch(nodeA, nodeB) {\n        if (nodeA !== nodeB) {\n            const predA = nodeA._facePredecessor;\n            const predB = nodeB._facePredecessor;\n            nodeB._facePredecessor = predA;\n            nodeA._facePredecessor = predB;\n            predB._faceSuccessor = nodeA;\n            predA._faceSuccessor = nodeB;\n        }\n    }\n    /**\n     * Pinch this half edge out of its base vertex loop.\n     * @return the surviving HalfEdge in the vertex loop, or undefined if the instance HalfEdge is already dangling\n     */\n    yankFromVertexLoop() {\n        const other = this.edgeMate.faceSuccessor;\n        if (other === this)\n            return undefined;\n        HalfEdge.pinch(this, other);\n        return other;\n    }\n    /** Turn all pointers to undefined so garbage collector can reuse the object.\n     *  This is to be called only by a Graph object that is being decommissioned.\n     */\n    decommission() {\n        this._facePredecessor = undefined;\n        this._faceSuccessor = undefined;\n        this._edgeMate = undefined;\n    }\n    /** Return the node. This identity function is useful as the NodeFunction in collector methods. */\n    static nodeToSelf(node) { return node; }\n    /** Return the id of a node.  Useful for collector methods. */\n    static nodeToId(node) { return node.id; }\n    /** Return the id of a node.Useful for collector methods. */\n    static nodeToIdString(node) { return node.id.toString(); }\n    /** Return the [id, [x,y]] of a node.  Useful for collector methods. */\n    static nodeToIdMaskXY(node) {\n        return { id: node.id, mask: HalfEdge.nodeToMaskString(node), xy: [node.x, node.y] };\n    }\n    /** Return the [id, [x,y]] of a node.  Useful for collector methods. */\n    static nodeToIdXYString(node) {\n        const s = `${node.id.toString()}+${HalfEdge.nodeToMaskString(node)}[${node.x},${node.y}]`;\n        return s;\n    }\n    /** Return the [id, [x,y],z] of a node.  Useful for collector methods. */\n    static nodeToIdXYZString(node) {\n        return `[${node.id.toString()}: ${node.x},${node.y},${node.z}]`;\n    }\n    /** Create a string representation of the mask\n     * * Null mask is empty string.\n     * * Appended characters B,P,X for Boundary, Primary, Exterior mask bits.\n     */\n    static nodeToMaskString(node) {\n        let s = \"\";\n        if (node.isMaskSet(HalfEdgeMask.BOUNDARY_EDGE))\n            s += \"B\";\n        if (node.isMaskSet(HalfEdgeMask.PRIMARY_EDGE))\n            s += \"P\";\n        if (node.isMaskSet(HalfEdgeMask.EXTERIOR))\n            s += \"X\";\n        if (node.isMaskSet(HalfEdgeMask.NULL_FACE))\n            s += \"N\";\n        return s;\n    }\n    /** Return [x,y] with coordinates of node */\n    static nodeToXY(node) { return [node.x, node.y]; }\n    /** Return Vector2d to face successor, with only xy coordinates */\n    vectorToFaceSuccessorXY(result) {\n        return Vector2d.create(this.faceSuccessor.x - this.x, this.faceSuccessor.y - this.y, result);\n    }\n    /** Return Vector3d to face successor */\n    vectorToFaceSuccessor(result) {\n        const other = this.faceSuccessor;\n        return Vector3d.create(other.x - this.x, other.y - this.y, other.z - this.z, result);\n    }\n    /** Return Vector3d to face successor */\n    vectorToFacePredecessor(result) {\n        const other = this.facePredecessor;\n        return Vector3d.create(other.x - this.x, other.y - this.y, other.z - this.z, result);\n    }\n    /** test if spaceNode is in the sector at sectorNode */\n    static isNodeVisibleInSector(spaceNode, sectorNode) {\n        // remark: fussy details ported from native code.\n        // The obscure cases seemed \"unlikely\" at first.  But preexisting unit tests for triangulation pinged just about everything.\n        // So it really matters to do the \"0\" cases this way.\n        //  (As usual, hard coded zero is suspect, but it seems to work nicely in the discrete decisions.)\n        if (sectorNode.vertexSuccessor === sectorNode)\n            return true;\n        const successor = sectorNode.faceSuccessor;\n        const predecessor = sectorNode.facePredecessor;\n        const successorCross = this.crossProductXYToTargets(sectorNode, successor, spaceNode);\n        const predecessorCross = this.crossProductXYToTargets(predecessor, sectorNode, spaceNode);\n        // simplest case:  two positives\n        if (successorCross > 0.0 && predecessorCross > 0.0)\n            return true;\n        const sectorCross = this.crossProductXYToTargets(predecessor, sectorNode, successor);\n        if (predecessorCross <= 0.0 && successorCross <= 0.0) {\n            if (predecessorCross === 0.0 && successorCross === 0.0 && sectorCross === 0.0) {\n                /* Everything is on a line.*/\n                /* If the sector is a degenerate face, nodeP can only be\n                        in if it is the other node in the degenerate face.\n                */\n                if (predecessor === successor && sectorNode.vertexSuccessor !== sectorNode)\n                    return spaceNode === successor;\n                /* Sector is 360 degrees.  Call it in only if vector from predP\n                    to sectorP points forward to nodeP.\n                */\n                return HalfEdge.dotProductNodeToNodeVectorsXY(predecessor, sectorNode, sectorNode, spaceNode) > 0.0;\n            }\n            else {\n                return false;\n            }\n        }\n        else {\n            if (sectorCross === 0.0 && predecessorCross !== 0.0 && successorCross !== 0.0) {\n                // The incoming and outgoing edges at the sector are identical direction.\n                // We have to decide if this node is  inside the degenerate face (i.e. a geometrically empty sector)\n                // or outside (i.e. a nearly complete sector).\n                // In the inside case, the face is just two nodes.\n                // Exact equality for zero is ok because cross product should be using identical\n                // coordinates in subtracted terms.  (All furrow eyebrows in unison ....)\n                return predecessor !== successor;\n            }\n            return sectorCross < 0.0;\n        }\n    }\n    /** Returns Return cross product (2d) of vectors from baseA to targetA and baseB to targetB */\n    static crossProductXYToTargets(base, targetA, targetB) {\n        return Geometry.crossProductXYXY(targetA.x - base.x, targetA.y - base.y, targetB.x - base.x, targetB.y - base.y);\n    }\n    /** Returns Return dot product (2d) of vectors along two edges. */\n    static dotProductNodeToNodeVectorsXY(baseA, targetA, baseB, targetB) {\n        return Geometry.dotProductXYXY(targetA.x - baseA.x, targetA.y - baseA.y, targetB.x - baseB.x, targetB.y - baseB.y);\n    }\n    /** Return cross product (2d) of vectors from nodeA to nodeB and nodeB to nodeC\n     */\n    static crossProductXYAlongChain(nodeA, nodeB, nodeC) {\n        return Geometry.crossProductXYXY(nodeB.x - nodeA.x, nodeB.y - nodeA.y, nodeC.x - nodeB.x, nodeC.y - nodeB.y);\n    }\n    /**\n     * @return whether the sector represented by the 2D vectors from nodeA to nodeB and nodeB to nodeC is convex.\n     */\n    static isSectorConvex(nodeA, nodeB, nodeC) {\n        const cross = HalfEdge.crossProductXYAlongChain(nodeA, nodeB, nodeC);\n        if (cross > 0.0)\n            return true;\n        if (cross < 0.0)\n            return false;\n        return HalfEdge.dotProductNodeToNodeVectorsXY(nodeA, nodeB, nodeB, nodeC) > 0.0;\n    }\n    /**\n     * @return whether the sector of the face is convex.\n     */\n    // eslint-disable-next-line @itwin/prefer-get\n    isSectorConvex() {\n        return HalfEdge.isSectorConvex(this.facePredecessor, this, this.faceSuccessor);\n    }\n    /**\n     * @return whether the face is convex.\n     */\n    // eslint-disable-next-line @itwin/prefer-get\n    isFaceConvex() {\n        let node = this;\n        do {\n            if (!node.isSectorConvex())\n                return false;\n            node = node.faceSuccessor;\n        } while (node !== this);\n        return true;\n    }\n    /**\n     * Isolate the edge from the graph by yanking each end from its vertex loop.\n     */\n    isolateEdge() {\n        const mate = this.edgeMate;\n        this.yankFromVertexLoop();\n        mate.yankFromVertexLoop();\n    }\n    /**\n     * @return whether this edge is isolated from the rest of the graph.\n     */\n    get isIsolatedEdge() {\n        return this === this.vertexSuccessor && this.edgeMate === this.edgeMate.vertexSuccessor;\n    }\n    /** Return true if `this` is lexically below `other`, comparing y first then x. */\n    belowYX(other) {\n        // Check y's\n        // if (!Geometry.isSameCoordinate(a.y, b.y))\n        if (this.y < other.y)\n            return true;\n        if (this.y > other.y)\n            return false;\n        // same y.\n        // Check x's\n        if (this.x < other.x)\n            return true;\n        return false;\n    }\n    /** Returns Returns true if the node does NOT have Mask.EXTERIOR_MASK set. */\n    static testNodeMaskNotExterior(node) { return !node.isMaskSet(HalfEdgeMask.EXTERIOR); }\n    /** Returns Returns true if the node does NOT have Mask.EXTERIOR_MASK set. */\n    static testMateMaskExterior(node) { return node.edgeMate.isMaskSet(HalfEdgeMask.EXTERIOR); }\n    /** Returns radians between this edge and its face predecessor edge, using all three coordinates x,y,z and given normal to resolve sweep direction.\n     *   * The returned angle is positive, i.e. may be larger than PI radians.\n    */\n    static sectorSweepRadiansXYZ(node, normal) {\n        const nodeB = node.faceSuccessor;\n        const nodeC = node.facePredecessor;\n        return Angle.orientedRadiansBetweenVectorsXYZ(nodeB.x - node.x, nodeB.y - node.y, nodeB.z - node.z, nodeC.x - node.x, nodeC.y - node.y, nodeC.z - node.z, normal.x, normal.y, normal.z, true);\n    }\n    /** Returns Returns true if the face has positive area in xy parts. */\n    static testFacePositiveAreaXY(node) {\n        return node.countEdgesAroundFace() > 2 && node.signedFaceArea() > 0.0;\n    }\n    /** Return true if x and y coordinates of this and other are exactly equal */\n    isEqualXY(other) {\n        return this.x === other.x && this.y === other.y;\n    }\n    /** Return distance between xy coordinates of this and other node */\n    distanceXY(other) {\n        return Geometry.distanceXYXY(this.x, this.y, other.x, other.y);\n    }\n    /** Return distance between xyz coordinates of this and other node */\n    distanceXYZ(other) {\n        return Geometry.distanceXYZXYZ(this.x, this.y, this.z, other.x, other.y, other.z);\n    }\n    /**\n     *\n     * * Evaluate f(node) at each node around a face loop.\n     * * Collect the function values.\n     * @returns Return the array of function values.\n     */\n    collectAroundFace(f) {\n        const nodes = [];\n        let node = this;\n        do {\n            nodes.push(f ? f(node) : node);\n            node = node.faceSuccessor;\n        } while (node !== this);\n        return nodes;\n    }\n    /**\n     * search around a vertex for nodes that have a specified mask setting.\n     * @param vertexSeed first node to search\n     * @param mask target mask\n     * @param value target value for mask on half edges.\n     * @param collectedNodes optional array to be cleared and receive masked nodes\n     */\n    collectMaskedEdgesAroundVertex(mask, value = true, result) {\n        if (result === undefined)\n            result = [];\n        else\n            result.length = 0;\n        let node = this;\n        do {\n            if (node.isMaskSet(mask) === value)\n                result.push(node);\n            node = node.vertexSuccessor;\n        } while (node !== this);\n        return result;\n    }\n    /**\n     *\n     * * Evaluate f(node) at each outbound node around this node's vertex loop.\n     * * Collect the function values.\n     * @returns Return the array of function values.\n     */\n    collectAroundVertex(f) {\n        const nodes = [];\n        let node = this;\n        do {\n            nodes.push(f ? f(node) : node);\n            node = node.vertexSuccessor;\n        } while (node !== this);\n        return nodes;\n    }\n    /**\n     *\n     * * Evaluate f(node) at each node around a face loop.\n     * * Sum the function values\n     * @returns Return the sum\n     */\n    sumAroundFace(f) {\n        let node = this;\n        let sum = 0;\n        do {\n            sum += f(node);\n            node = node.faceSuccessor;\n        } while (node !== this);\n        return sum;\n    }\n    /**\n     *\n     * * Evaluate f(node) at each outbound node around this node's vertex loop.\n     * * Sum the function values\n     * @returns Return the sum\n     */\n    sumAroundVertex(f) {\n        let node = this;\n        let sum = 0;\n        do {\n            sum += f(node);\n            node = node.vertexSuccessor;\n        } while (node !== this);\n        return sum;\n    }\n    /** For all the nodes in the face loop of the given node, clear out the mask given */\n    clearMaskAroundFace(mask) {\n        let node = this;\n        do {\n            node.clearMask(mask);\n            node = node.faceSuccessor;\n        } while (node !== this);\n    }\n    /** For all the nodes in the vertex loop of the given node, clear out the mask given */\n    clearMaskAroundVertex(mask) {\n        let node = this;\n        do {\n            node.clearMask(mask);\n            node = node.vertexSuccessor;\n        } while (node !== this);\n    }\n    /** Returns the signed sum of xy areas of triangles from first node to edges.\n     *\n     * * A positive area is counterclockwise.\n     * * A negative area is clockwise.\n     */\n    signedFaceArea() {\n        let sum = 0;\n        // sum area of trapezoids.\n        // * the formula in the loop gives twice the area (because it does nto average the y values).\n        // * this is fixed up at the end by a single multiply by 0.5\n        // * individual trapezoid heights are measured from y at the start node to keep area values numerical smaller.\n        const y0 = this.y;\n        let dy0 = 0.0;\n        let dy1 = 0.0;\n        let x0 = this.x;\n        let x1;\n        let node1;\n        let node0 = this;\n        do {\n            node1 = node0.faceSuccessor;\n            x1 = node1.x;\n            dy1 = node1.y - y0;\n            sum += (x0 - x1) * (dy0 + dy1);\n            x0 = x1;\n            dy0 = dy1;\n            node0 = node1;\n        } while (node0 !== this);\n        return 0.5 * sum;\n    }\n    /**\n     * interpolate xy coordinates between this node and its face successor.\n     * @param fraction fractional position along this edge.\n     * @param result xy coordinates\n     */\n    fractionToPoint2d(fraction, result) {\n        const node1 = this.faceSuccessor;\n        return Point2d.create(this.x + (node1.x - this.x) * fraction, this.y + (node1.y - this.y) * fraction, result);\n    }\n    /**\n     * interpolate xy coordinates between this node and its face successor.\n     * @param fraction fractional position along this edge.\n     * @param result xy coordinates\n     */\n    fractionToPoint3d(fraction, result) {\n        const node1 = this.faceSuccessor;\n        return Point3d.create(this.x + (node1.x - this.x) * fraction, this.y + (node1.y - this.y) * fraction, this.z + (node1.z - this.z) * fraction, result);\n    }\n    /**\n     * * interpolate xy coordinates at fractionAlong between this node and its face successor.\n     * * shift to left by fractionPerpendicular\n     * @param fraction fractional position along this edge.\n     * @param result xy coordinates\n     */\n    fractionAlongAndPerpendicularToPoint2d(fractionAlong, fractionPerpendicular, result) {\n        const node1 = this.faceSuccessor;\n        const dx = node1.x - this.x;\n        const dy = node1.y - this.y;\n        return Point2d.create(this.x + dx * fractionAlong - dy * fractionPerpendicular, this.y + dy * fractionAlong + dx * fractionPerpendicular, result);\n    }\n    /**\n     * return the 3d coordinates at this half edge base\n     */\n    getPoint3d(result) {\n        return Point3d.create(this.x, this.y, this.z, result);\n    }\n    /**\n     * return the 2d coordinates at this half edge base\n     */\n    getPoint2d(result) {\n        return Point2d.create(this.x, this.y, result);\n    }\n    /**\n     * return a 3d vector from start to end of this half edge.\n     */\n    getVector3dAlongEdge(result) {\n        const nodeB = this.faceSuccessor;\n        return Vector3d.create(nodeB.x - this.x, nodeB.y - this.y, nodeB.z - this.z, result);\n    }\n    /**\n     * return a 2d vector from start to end of this half edge\n     */\n    getVector2dAlongEdge(result) {\n        const nodeB = this.faceSuccessor;\n        return Vector2d.create(nodeB.x - this.x, nodeB.y - this.y, result);\n    }\n    /**\n     * Return the interpolated x coordinate between this node and its face successor.\n     * @param fraction fractional position along this edge.\n     */\n    fractionToX(fraction) {\n        const node1 = this.faceSuccessor;\n        return this.x + (node1.x - this.x) * fraction;\n    }\n    /**\n     * Return the interpolated y coordinate between this node and its face successor.\n     * @param fraction fractional position along this edge.\n     */\n    fractionToY(fraction) {\n        const node1 = this.faceSuccessor;\n        return this.y + (node1.y - this.y) * fraction;\n    }\n    /**\n     * Return the interpolated z coordinate between this node and its face successor.\n     * @param fraction fractional position along this edge.\n     */\n    fractionToZ(fraction) {\n        const node1 = this.faceSuccessor;\n        return this.z + (node1.z - this.z) * fraction;\n    }\n    /**\n     * * Compute fractional coordinates of the intersection of edges from given base nodes\n     * * If parallel or colinear, return undefined.\n     * * If (possibly extended) lines intersect, return the fractions of intersection as x,y in the result.\n     * @param nodeA0 Base node of edge A\n     * @param nodeB0 Base node of edge B\n     * @param result optional preallocated result\n     */\n    static transverseIntersectionFractions(nodeA0, nodeB0, result) {\n        const nodeA1 = nodeA0.faceSuccessor;\n        const nodeB1 = nodeB0.faceSuccessor;\n        if (!result)\n            result = Vector2d.create();\n        if (SmallSystem.linearSystem2d(nodeA1.x - nodeA0.x, nodeB0.x - nodeB1.x, nodeA1.y - nodeA0.y, nodeB0.y - nodeB1.y, nodeB0.x - nodeA0.x, nodeB0.y - nodeA0.y, result))\n            return result;\n        return undefined;\n    }\n    /**\n     * * Compute fractional coordinates of the intersection of a horizontal line with an edge.\n     * * If the edge is horizontal with (approximate) identical y, return the node.\n     * * If the edge is horizontal with different y, return undefined.\n     * * If the edge is not horizontal, return the fractional position (possibly outside 0..1) of the intersection.\n     * @param node0 Base node of edge\n     */\n    static horizontalScanFraction(node0, y) {\n        const node1 = node0.faceSuccessor;\n        const dy = node1.y - node0.y;\n        if (Geometry.isSameCoordinate(y, node0.y) && Geometry.isSameCoordinate(y, node1.y))\n            return node0;\n        if (Geometry.isSameCoordinate(dy, 0.0))\n            return undefined;\n        return Geometry.conditionalDivideFraction(y - node0.y, dy);\n    }\n    /**\n     * * Compute fractional coordinates of the intersection of a horizontal line with an edge.\n     * * If the edge is horizontal return undefined (no test for horizontal at y!!!)\n     * * If the edge is not horizontal and y is between its end y's, return the fraction\n     * @param node0 Base node of edge\n     */\n    static horizontalScanFraction01(node0, y) {\n        const node1 = node0.faceSuccessor;\n        const dy = node1.y - node0.y;\n        if (Geometry.isSameCoordinate(y, node0.y) && Geometry.isSameCoordinate(y, node1.y))\n            return undefined;\n        if (Geometry.isSameCoordinate(dy, 0.0))\n            return undefined;\n        const fraction = Geometry.conditionalDivideFraction(y - node0.y, dy);\n        if (fraction !== undefined && fraction >= 0.0 && fraction <= 1.0)\n            return fraction;\n        return undefined;\n    }\n    /**\n     * Copy various data from source to this.\n     * @param source other half edge.\n     * @param XYZ copy simple coordinates\n     * @param copyVertexData true to copy data belonging to the vertex. (i.e. the \"i\" member)\n     * @param copyVertexData true to copy data belonging to the edge. (i.e. call transferEdgeData)\n     * @param copyFaceData true to copy faceTag\n     */\n    copyDataFrom(source, copyXYZ, copyVertexData, copyEdgeData, copyFaceData) {\n        if (copyXYZ) {\n            this.x = source.x;\n            this.y = source.y;\n            this.z = source.z;\n        }\n        if (copyVertexData) {\n            this.i = source.i;\n        }\n        if (copyEdgeData) {\n            HalfEdge.transferEdgeProperties(source, this);\n            this.edgeTag = source.edgeTag;\n        }\n        if (copyFaceData) {\n            this.faceTag = source.faceTag;\n        }\n    }\n}\nHalfEdge._edgePropertyMasks = [HalfEdgeMask.BOUNDARY_EDGE, HalfEdgeMask.EXTERIOR, HalfEdgeMask.PRIMARY_EDGE, HalfEdgeMask.NULL_FACE];\nHalfEdge._totalNodesCreated = 0;\nexport { HalfEdge };\n/**\n * A HalfEdgeGraph has:\n * * An array of (pointers to ) HalfEdge objects.\n * * A pool of masks for grab/drop use by algorithms.\n * @internal\n */\nexport class HalfEdgeGraph {\n    constructor() {\n        this._numNodesCreated = 0;\n        this.allHalfEdges = [];\n        this._maskManager = MaskManager.create(HalfEdgeMask.ALL_GRAB_DROP_MASKS);\n    }\n    /** Ask for a mask (from the graph's free pool.) for caller's use.\n     * * Optionally clear the mask throughout the graph.\n     */\n    grabMask(clearInAllHalfEdges = true) {\n        const mask = this._maskManager.grabMask();\n        if (clearInAllHalfEdges) {\n            this.clearMask(mask);\n        }\n        return mask;\n    }\n    /**\n     * Return `mask` to the free pool.\n     */\n    dropMask(mask) { this._maskManager.dropMask(mask); }\n    /**\n     * * Create 2 half edges forming 2 vertices, 1 edge, and 1 face\n     * * The two edges are joined as edgeMate pair.\n     * * The two edges are a 2-half-edge face loop in both the faceSuccessor and facePredecessor directions.\n     * * The two edges are added to the graph's HalfEdge set\n     * @returns Return pointer to the first half edge created.\n     */\n    createEdgeXYZXYZ(xA = 0, yA = 0, zA = 0, iA = 0, xB = 0, yB = 0, zB = 0, iB = 0) {\n        const a = HalfEdge.createHalfEdgePairWithCoordinates(xA, yA, zA, iA, xB, yB, zB, iB, this.allHalfEdges);\n        return a;\n    }\n    /**\n     * * Create 2 half edges forming 2 vertices, 1 edge, and 1 face\n     * * The two edges are joined as edgeMate pair.\n     * * The two edges are a 2-half-edge face loop in both the faceSuccessor and facePredecessor directions.\n     * * The two edges are added to the graph's HalfEdge set\n     * * Coordinates are set to zero.\n     * * ids are installed in the two half edges.\n     * @returns Return pointer to the first half edge created.  (This has idA as its id.)\n     */\n    createEdgeIdId(iA = 0, iB = 0) {\n        const a = HalfEdge.createHalfEdgePairWithCoordinates(0.0, 0.0, 0.0, iA, 0.0, 0.0, 0.0, iB, this.allHalfEdges);\n        return a;\n    }\n    /**\n     * * create an edge from coordinates x,y,z to (the tail of) an existing half edge.\n     * @returns Return pointer to the half edge with tail at x,y,z\n     */\n    createEdgeXYZHalfEdge(xA = 0, yA = 0, zA = 0, iA = 0, node, iB = 0) {\n        const a = HalfEdge.createHalfEdgePairWithCoordinates(xA, yA, zA, iA, node.x, node.y, node.z, iB, this.allHalfEdges);\n        const b = a.faceSuccessor;\n        HalfEdge.pinch(node, b);\n        return a;\n    }\n    /**\n     * * create an edge from coordinates x,y,z to (the tail of) an existing half edge.\n     * @returns Return pointer to the half edge with tail at x,y,z\n     */\n    createEdgeHalfEdgeHalfEdge(nodeA, idA, nodeB, idB = 0) {\n        const a = HalfEdge.createHalfEdgePairWithCoordinates(nodeA.x, nodeA.y, nodeA.z, idA, nodeB.x, nodeB.y, nodeB.z, idB, this.allHalfEdges);\n        const b = a.faceSuccessor;\n        HalfEdge.pinch(nodeA, a);\n        HalfEdge.pinch(nodeB, b);\n        return a;\n    }\n    /**\n     * * Create 2 half edges forming 2 vertices, 1 edge, and 1 face\n     * * The two edges are joined as edgeMate pair.\n     * * The two edges are a 2-half-edge face loop in both the faceSuccessor and facePredecessor directions.\n     * * The two edges are added to the graph's HalfEdge set\n     * @returns Return pointer to the first half edge created.\n     */\n    createEdgeXYAndZ(xyz0, id0, xyz1, id1) {\n        const a = HalfEdge.createHalfEdgePairWithCoordinates(xyz0.x, xyz0.y, xyz0.z, id0, xyz1.x, xyz1.y, xyz1.z, id1, this.allHalfEdges);\n        return a;\n    }\n    /**\n     * * Insert a vertex in the edge beginning at base.\n     * * this creates two half edges.\n     * * The base of the new edge is 'after' the (possibly undefined) start node in its face loop.\n     * * The existing mate retains its base xyz and i properties but is no longer the mate of base.\n     * * The base and existing mate each become mates with a new half edge.\n     * @returns Returns the reference to the half edge created.\n     */\n    splitEdge(base, xA = 0, yA = 0, zA = 0, iA = 0) {\n        const he = HalfEdge.splitEdge(base, xA, yA, zA, iA, this.allHalfEdges);\n        return he;\n    }\n    /**\n     * * Create a sliver face \"within\" an edge.\n     * * this creates two half edges.\n     * * The existing edges both stay in their same face loops and retain coordinates and i value.\n     * * Each existing edge's mate is a new edge (rather than original mate)\n     * * Coordinates are copied to the new edges at respective vertices.\n     * * New faceTag and edgeTag undefined.\n     * * i members are copied around their respective vertices.\n     * @returns Returns the reference to the half edge created.\n     */\n    splitEdgeCreateSliverFace(base) {\n        const he = HalfEdge.splitEdgeCreateSliverFace(base, this.allHalfEdges);\n        return he;\n    }\n    /**\n     * * Insert a vertex in the edge beginning at base, with coordinates specified as a fraction along the existing edge.\n     * * this creates two half edges.\n     * * The base of the new edge is 'after' the (possibly undefined) start node in its face loop.\n     * * The existing mate retains its base xyz and i properties but is no longer the mate of base.\n     * * The base and existing mate each become mates with a new half edge.\n     * @returns Returns the reference to the half edge created.\n     */\n    splitEdgeAtFraction(base, fraction) {\n        const he = HalfEdge.splitEdge(base, base.fractionToX(fraction), base.fractionToY(fraction), base.fractionToZ(fraction), 0, this.allHalfEdges);\n        return he;\n    }\n    /** This is a destructor-like action that eliminates all interconnection among the graph's nodes.\n     * After this is called the graph is unusable.\n     */\n    decommission() {\n        for (const node of this.allHalfEdges) {\n            node.decommission();\n        }\n        this.allHalfEdges.length = 0;\n        this.allHalfEdges = undefined;\n    }\n    /** create two nodes of a new edge.\n     * @returns Return one of the two nodes, which the caller may consider as the start of the edge.\n     */\n    addEdgeXY(x0, y0, x1, y1) {\n        const baseNode = HalfEdge.createEdgeXYXY(this._numNodesCreated, x0, y0, this._numNodesCreated + 1, x1, y1);\n        this._numNodesCreated += 2;\n        this.allHalfEdges.push(baseNode);\n        this.allHalfEdges.push(baseNode.faceSuccessor);\n        return baseNode;\n    }\n    /** Clear selected bits in all nodes of the graph. */\n    clearMask(mask) {\n        for (const node of this.allHalfEdges)\n            node.maskBits &= ~mask;\n    }\n    /** Set selected bits in all nodes of the graph. */\n    setMask(mask) {\n        for (const node of this.allHalfEdges)\n            node.maskBits |= mask;\n    }\n    /** toggle selected bits in all nodes of the graph. */\n    reverseMask(mask) {\n        for (const node of this.allHalfEdges) {\n            node.maskBits ^= mask;\n        }\n    }\n    /**\n     * Return the number of nodes that have a specified mask bit set.\n     * @param mask mask to count\n     */\n    countMask(mask) {\n        let n = 0;\n        for (const node of this.allHalfEdges)\n            if (node.isMaskSet(mask))\n                n++;\n        return n;\n    }\n    /** Return an array LineSegment3d.\n     * * The array has one segment per edge\n     * * The coordinates are taken from a node and its face successor.\n     * * On each edge, the line segment start at the HalfEdge with lower id than its edgeMate.\n     */\n    collectSegments() {\n        const segments = [];\n        for (const node of this.allHalfEdges) {\n            if (node.id < node.edgeMate.id)\n                segments.push(LineSegment3d.create(Point3d.create(node.x, node.y), Point3d.create(node.faceSuccessor.x, node.faceSuccessor.y)));\n        }\n        return segments;\n    }\n    /** Returns the number of vertex loops in a graph structure */\n    countVertexLoops() {\n        this.clearMask(HalfEdgeMask.VISITED);\n        let count = 0;\n        this.announceVertexLoops((_graph, _seed) => { count++; return true; });\n        return count;\n    }\n    /** Returns the number of face loops */\n    countFaceLoops() {\n        this.clearMask(HalfEdgeMask.VISITED);\n        let count = 0;\n        this.announceFaceLoops((_graph, _seed) => { count++; return true; });\n        return count;\n    }\n    /**\n     * Returns the number of face loops satisfying a filter function with mask argument.\n     *\n     */\n    countFaceLoopsWithMaskFilter(filter, mask) {\n        this.clearMask(HalfEdgeMask.VISITED);\n        let count = 0;\n        this.announceFaceLoops((_graph, seed) => {\n            if (filter(seed, mask))\n                count++;\n            return true;\n        });\n        return count;\n    }\n    /** Returns an array of nodes, where each node represents a starting point of a face loop.\n     */\n    collectFaceLoops() {\n        const returnArray = [];\n        this.announceFaceLoops((_graph, node) => { returnArray.push(node); return true; });\n        return returnArray;\n    }\n    /** Returns an array of nodes, where each node represents a starting point of a vertex loop.\n     */\n    collectVertexLoops() {\n        this.clearMask(HalfEdgeMask.VISITED);\n        const returnArray = [];\n        for (const node of this.allHalfEdges) {\n            if (node.getMask(HalfEdgeMask.VISITED))\n                continue;\n            returnArray.push(node);\n            node.setMaskAroundVertex(HalfEdgeMask.VISITED);\n        }\n        return returnArray;\n    }\n    /**\n     * * Visit each facet of the graph once.\n     * * Call the announceFace function\n     * * continue search if announceFace(graph, node) returns true\n     * * terminate search if announce face (graph, node) returns false\n     * @param  announceFace function to apply at one node of each face.\n     */\n    announceFaceLoops(announceFace) {\n        this.clearMask(HalfEdgeMask.VISITED);\n        for (const node of this.allHalfEdges) {\n            if (node.getMask(HalfEdgeMask.VISITED))\n                continue;\n            node.setMaskAroundFace(HalfEdgeMask.VISITED);\n            if (!announceFace(this, node))\n                break;\n        }\n    }\n    /**\n       * * Visit each edge of the graph once.\n       * * Call the announceEdge function.\n       * * the edge mate will NOT appear in an announceEdge call.\n       * * continue search if announceEdge(graph, node) returns true\n       * * terminate search if announceEdge (graph, node) returns false\n       * @param  announceEdge function to apply at one node of each edge.\n       */\n    announceEdges(announceEdge) {\n        this.clearMask(HalfEdgeMask.VISITED);\n        for (const node of this.allHalfEdges) {\n            if (node.getMask(HalfEdgeMask.VISITED))\n                continue;\n            const mate = node.edgeMate;\n            node.setMask(HalfEdgeMask.VISITED);\n            mate.setMask(HalfEdgeMask.VISITED);\n            if (!announceEdge(this, node))\n                break;\n        }\n    }\n    /**\n     * * Visit each vertex loop of the graph once.\n     * * Call the announceVertex function\n     * * continue search if announceVertex(graph, node) returns true\n     * * terminate search if announce vertex (graph, node) returns false\n     * @param  announceVertex function to apply at one node of each face.\n     */\n    announceVertexLoops(announceVertex) {\n        this.clearMask(HalfEdgeMask.VISITED);\n        for (const node of this.allHalfEdges) {\n            if (node.getMask(HalfEdgeMask.VISITED))\n                continue;\n            node.setMaskAroundVertex(HalfEdgeMask.VISITED);\n            if (!announceVertex(this, node))\n                break;\n        }\n    }\n    /**\n     * * Visit each half edge (node) of the graph once.\n     * * Call the announceNode function\n     * * continue search if announceNode(graph, node) returns true\n     * * terminate search if announce face (graph, node) returns false\n     * @param  announceNode function to apply at one node of each face.\n     */\n    announceNodes(announceNode) {\n        for (const node of this.allHalfEdges) {\n            if (!announceNode(this, node))\n                break;\n        }\n    }\n    /** Return the number of nodes in the graph */\n    countNodes() { return this.allHalfEdges.length; }\n    /** Apply transform to the xyz coordinates in the graph. */\n    transformInPlace(transform) {\n        for (const node of this.allHalfEdges) {\n            transform.multiplyXYAndZInPlace(node);\n        }\n    }\n    /**\n     * disconnect and delete all nodes that satisfy a filter condition.\n     * @param deleteThisNode returns true to delete the corresponding edge. Should act symmetrically on the edgeMate.\n     * @returns the number of nodes deleted (twice the number of deleted edges).\n     */\n    yankAndDeleteEdges(deleteThisNode) {\n        const numTotal = this.allHalfEdges.length;\n        let numAccepted = 0;\n        for (let i = 0; i < numTotal; i++) {\n            const candidate = this.allHalfEdges[i];\n            if (!deleteThisNode(candidate)) {\n                this.allHalfEdges[numAccepted++] = candidate;\n            }\n            else\n                candidate.isolateEdge();\n        }\n        const numDeleted = numTotal - numAccepted;\n        this.allHalfEdges.length = numAccepted;\n        return numDeleted;\n    }\n    /**\n     * Delete all isolated edges.\n     * @return the number of nodes deleted (twice the number of deleted edges).\n     */\n    deleteIsolatedEdges() {\n        const numTotal = this.allHalfEdges.length;\n        let numAccepted = 0;\n        for (let i = 0; i < numTotal; i++) {\n            const candidate = this.allHalfEdges[i];\n            if (!candidate.isIsolatedEdge) {\n                this.allHalfEdges[numAccepted++] = candidate;\n            }\n        }\n        const numDeleted = numTotal - numAccepted;\n        this.allHalfEdges.length = numAccepted;\n        return numDeleted;\n    }\n}\n//# sourceMappingURL=Graph.js.map",
      "start": 1693508123974,
      "end": 1693508124219,
      "sourcemaps": null
    }
  ]
}
