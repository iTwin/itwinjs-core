{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/orbitgt/lib/esm/system/runtime/ALong.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module OrbitGT\n */\nimport { ASystem } from \"./ASystem\";\nimport { Numbers } from \"./Numbers\";\nimport { Strings } from \"./Strings\";\n/**\n * Class ALong defines a signed 64-bit integer using two (high and low) 64-bit floats.\n *\n * @version 1.0 February 2019\n */\n/** @internal */\nclass ALong {\n    /**\n     * Create a new value.\n     * @param high the 32-bit high part.\n     * @param low the 32-bit low part.\n     */\n    constructor(high, low) {\n        this._high = high;\n        this._low = low;\n    }\n    /**\n     * Check if the number is zero.\n     * @return true if zero.\n     */\n    isZero() {\n        return (this._high == 0.0) && (this._low == 0.0);\n    }\n    /**\n     * Check if the number is not zero.\n     * @return true if zero.\n     */\n    isNonZero() {\n        return (this.isZero() == false);\n    }\n    /**\n     * Check if the number is one.\n     * @return true if one.\n     */\n    isOne() {\n        return (this._high == 0.0) && (this._low == 1.0);\n    }\n    /**\n     * Check if the number is positive.\n     * @return true if positive (false if zero).\n     */\n    isPositive() {\n        return this.isZero() ? false : (this._high < ALong._U31);\n    }\n    /**\n     * Check if the number is negative.\n     * @return true if negative (false if zero).\n     */\n    isNegative() {\n        return this.isZero() ? false : (this._high >= ALong._U31);\n    }\n    /**\n     * Normalize the number.\n     * @return this number for chaining operations.\n     */\n    static normalize2(high, low) {\n        // normalize the low part\n        let overflowLow = Numbers.floor(low / ALong._U32);\n        low = (low - overflowLow * ALong._U32); // inside range [0..U32[\n        high += overflowLow;\n        // normalize the high part\n        let overflowHigh = Numbers.floor(high / ALong._U32);\n        high = (high - overflowHigh * ALong._U32); // inside range [0..U32[\n        // return the result\n        return new ALong(high, low);\n    }\n    /**\n     * Negate the number.\n     * @return the result.\n     */\n    negate() {\n        /* Zero? */\n        if (this.isZero()) {\n            /* Return this immutable instance */\n            return this;\n        }\n        /* Compute */\n        let resultHigh = (ALong._U32 - 1.0 - this._high);\n        let resultLow = (ALong._U32 - this._low);\n        /* Overflow? */\n        if (resultLow == ALong._U32) {\n            resultLow = 0.0;\n            resultHigh += 1.0; // in case we try to invert ALong.MIN_VALUE we get ALong.MIN_VALUE as a result again\n        }\n        /* Return the result */\n        return new ALong(resultHigh, resultLow);\n    }\n    /**\n     * Add a number.\n     * @param value the value to add.\n     * @return the result.\n     */\n    add(value) {\n        /* Compute */\n        let resultHigh = (this._high + value._high);\n        let resultLow = (this._low + value._low);\n        /* Return the result */\n        return ALong.normalize2(resultHigh, resultLow);\n    }\n    /**\n     * Add a number.\n     * @param value the value to add.\n     * @return the result.\n     */\n    addInt(value) {\n        return this.add(ALong.fromInt(value));\n    }\n    /**\n     * Increase by one.\n     * @return the result.\n     */\n    increase() {\n        return this.addInt(1);\n    }\n    /**\n     * Subtract a number.\n     * @param value the value to subtract.\n     * @return the result.\n     */\n    sub(value) {\n        return this.add(value.negate());\n    }\n    /**\n     * Subtract a number.\n     * @param value the value to subtract.\n     * @return the result.\n     */\n    subInt(value) {\n        return this.sub(ALong.fromInt(value));\n    }\n    /**\n     * Decrease by one.\n     * @return the result.\n     */\n    decrease() {\n        return this.subInt(1);\n    }\n    /**\n     * Multiply two unsigned 32-bit integer values.\n     * @param v1 the first value.\n     * @param v2 the second value.\n     * @param high0 the initial high value of the result.\n     * @return the unsigned 64-bit product.\n     */\n    static mul2(v1, v2) {\n        /* Zero? */\n        if (v1.isZero())\n            return v1;\n        if (v2.isZero())\n            return v2;\n        /* Make the values unsigned */\n        let neg1 = v1.isNegative() ? 1 : 0;\n        if (neg1 == 1)\n            v1 = v1.negate();\n        let neg2 = v2.isNegative() ? 1 : 0;\n        if (neg2 == 1)\n            v2 = v2.negate();\n        /* Split first low into 16-bit parts */\n        let a1 = Numbers.floor(v1._low / ALong._U16);\n        ;\n        let a2 = (v1._low - a1 * ALong._U16);\n        /* Split second low into 16-bit parts */\n        let b1 = Numbers.floor(v2._low / ALong._U16);\n        ;\n        let b2 = (v2._low - b1 * ALong._U16);\n        /* Compute */\n        let resultHigh = (v1._high * v2._low + v1._low * v2._high) + (a1 * b1);\n        let resultLow = (a1 * b2 + a2 * b1) * ALong._U16 + (a2 * b2);\n        let result = ALong.normalize2(resultHigh, resultLow);\n        /* Return the result */\n        return (neg1 + neg2 == 1) ? result.negate() : result;\n    }\n    /**\n     * Multiply by a number.\n     * @param value the value to multiply.\n     * @return the result.\n     */\n    mul(value) {\n        return ALong.mul2(this, value);\n    }\n    /**\n     * Multiply by a number.\n     * @param value the value to multiply.\n     * @return the result.\n     */\n    mulInt(value) {\n        return this.mul(ALong.fromInt(value));\n    }\n    /**\n     * Divide by a number.\n     * @param value the value to divide by.\n     * @return the result.\n     */\n    div(value) {\n        /* Division by zero? */\n        ASystem.assertNot(value.isZero(), \"ALong division by ALong zero\");\n        /* Division by one? */\n        if (value.isOne())\n            return this;\n        /* Make the values unsigned */\n        let currentValue = this;\n        let neg1 = currentValue.isNegative();\n        if (neg1)\n            currentValue = currentValue.negate();\n        let value2 = value;\n        let neg2 = value2.isNegative();\n        if (neg2)\n            value2.negate();\n        let neg = (neg1 && !neg2) || (!neg1 && neg2);\n        /* Loop until the remainder is smaller than the value */\n        let result = ALong.ZERO;\n        while (currentValue.isLargerThanOrEqualTo(value2)) {\n            /* Shift the value as much as possible */\n            let test = value2;\n            let times = ALong.ONE;\n            if (test.isSmallerThan(currentValue)) {\n                while (test.isSmallerThan(currentValue)) {\n                    test = test.mulInt(2);\n                    times = times.mulInt(2);\n                }\n                test = test.divInt(2);\n                times = times.divInt(2);\n            }\n            /* Subtract the shifted value */\n            currentValue = currentValue.sub(test);\n            result = result.add(times);\n        }\n        /* Return the result */\n        return (neg) ? result.negate() : result;\n    }\n    /**\n     * Divide by a number.\n     * @param value the value to divide by.\n     * @return the result.\n     */\n    divInt(value) {\n        /* Division by zero? */\n        ASystem.assertNot(value == 0, \"ALong division by int zero\");\n        /* Division by one? */\n        if (value == 1)\n            return this;\n        /* Make the values unsigned */\n        let value1 = this;\n        let neg1 = value1.isNegative();\n        if (neg1)\n            value1 = value1.negate();\n        let neg2 = (value < 0);\n        if (neg2)\n            value = -1 * value;\n        let neg = (neg1 && !neg2) || (!neg1 && neg2);\n        /* Compute */\n        let valueF = (0.0 + value);\n        let h1 = Numbers.floor(value1._high / valueF);\n        let h2 = (value1._high - valueF * h1);\n        let l1 = Numbers.floor(value1._low / valueF);\n        let l2 = (value1._low - valueF * l1);\n        let t = (h2 * ALong._U32 + l2);\n        let t1 = Numbers.floor(t / valueF);\n        let t2 = (t - valueF * t1); // remainder\n        let result = ALong.normalize2(h1, l1 + t1);\n        /* Return the result */\n        return (neg) ? result.negate() : result;\n    }\n    /**\n     * Modulate by a number.\n     * @param value the value to modulate by.\n     * @return the result.\n     */\n    mod(value) {\n        /* Division by zero? */\n        ASystem.assertNot(value.isZero(), \"ALong modulo by ALong zero\");\n        /* Division by one? */\n        if (value.isOne())\n            return ALong.ZERO;\n        /* Compute */\n        let result = this.sub(this.div(value).mul(value));\n        /* Return the result */\n        return result;\n    }\n    /**\n     * Modulate by a number.\n     * @param value the value to modulate by.\n     * @return the modulo value.\n     */\n    modInt(value) {\n        /* Division by zero? */\n        ASystem.assertNot(value == 0, \"ALong modulo by int zero\");\n        /* Division by one? */\n        if (value == 1)\n            return 0;\n        /* Make the values unsigned */\n        let value1 = this;\n        let neg1 = value1.isNegative();\n        if (neg1)\n            value1 = value1.negate();\n        let neg2 = (value < 0);\n        if (neg2)\n            value = -1 * value;\n        let neg = (neg1 && !neg2) || (!neg1 && neg2);\n        /* Compute */\n        let valueF = (0.0 + value);\n        let h1 = Numbers.floor(value1._high / valueF);\n        let h2 = (value1._high - valueF * h1);\n        let l1 = Numbers.floor(value1._low / valueF);\n        let l2 = (value1._low - valueF * l1);\n        let t = (h2 * ALong._U32 + l2);\n        let t1 = Numbers.floor(t / valueF);\n        let t2 = (t - valueF * t1); // remainder\n        let result = Math.trunc(t2);\n        /* Return the result */\n        return result;\n    }\n    /**\n     * Create a new number.\n     * @param value the 64-bit float value.\n     * @return the new number.\n     */\n    static fromDouble(value) {\n        /* Make the value unsigned */\n        let neg = (value < 0.0);\n        if (neg)\n            value = (-1.0 * value);\n        /* Compute */\n        value = Numbers.floor(value);\n        let high = Numbers.floor(value / ALong._U32);\n        let low = (value - high * ALong._U32);\n        let result = ALong.normalize2(high, low);\n        /* Return the result */\n        return (neg) ? result.negate() : result;\n    }\n    /**\n     * Get a double.\n     * @return the double value.\n     */\n    toDouble() {\n        /* Make the value unsigned */\n        let value = this;\n        let neg = value.isNegative();\n        if (neg)\n            value = value.negate();\n        /* Compute */\n        let result = (value._high * ALong._U32) + value._low;\n        if (neg)\n            result *= -1.0;\n        /* Return the result */\n        return result;\n    }\n    /**\n     * Create a new number.\n     * @param value the 32-bit integer value.\n     * @return the new number.\n     */\n    static fromInt(value) {\n        return (value < 0.0) ? new ALong(ALong._U32 - 1.0, ALong._U32 + value) : new ALong(0.0, value);\n    }\n    /**\n     * Get a 32-bit integer.\n     * @return the integer value.\n     */\n    toInt() {\n        /* Make the value unsigned */\n        let value = this;\n        let neg = value.isNegative();\n        if (neg)\n            value = value.negate();\n        /* Compute */\n        let result = value._low;\n        if (neg)\n            result *= -1.0;\n        /* Return the result */\n        return Numbers.doubleToInt(result);\n    }\n    /**\n     * Create a new number.\n     * @param i1 the 32-bit high part.\n     * @param i0 the 32-bit low part.\n     * @return the new number.\n     */\n    static fromHighLow(i1, i0) {\n        if (i1 < 0.0)\n            i1 += ALong._U32; // make unsigned\n        if (i0 < 0.0)\n            i0 += ALong._U32;\n        return new ALong(i1, i0);\n    }\n    /**\n     * Get the high part.\n     * @return the integer value (0..4294967295)\n     */\n    getHigh() {\n        return this._high;\n    }\n    /**\n     * Get the low part.\n     * @return the integer value (0..4294967295)\n     */\n    getLow() {\n        return this._low;\n    }\n    /**\n     * Create a new number.\n     * @param b7 the most significant 8-bit byte of the high part (0..255).\n     * @param b6 the most third 8-bit byte of the high part (0..255).\n     * @param b5 the most second 8-bit byte of the high part (0..255).\n     * @param b4 the most least 8-bit byte of the high part (0..255).\n     * @param b3 the most significant 8-bit byte of the low part (0..255).\n     * @param b2 the most third 8-bit byte of the low part (0..255).\n     * @param b1 the most second 8-bit byte of the low part (0..255).\n     * @param b0 the most least 8-bit byte of the low part (0..255).\n     * @return the new number.\n     */\n    static fromBytes(b7, b6, b5, b4, b3, b2, b1, b0) {\n        if (b7 < 0.0)\n            b7 += ALong._U8; // make unsigned\n        if (b6 < 0.0)\n            b6 += ALong._U8;\n        if (b5 < 0.0)\n            b5 += ALong._U8;\n        if (b4 < 0.0)\n            b4 += ALong._U8;\n        if (b3 < 0.0)\n            b3 += ALong._U8;\n        if (b2 < 0.0)\n            b2 += ALong._U8;\n        if (b1 < 0.0)\n            b1 += ALong._U8;\n        if (b0 < 0.0)\n            b0 += ALong._U8;\n        let high = (b7 * ALong._U24 + b6 * ALong._U16 + b5 * ALong._U8 + b4);\n        let low = (b3 * ALong._U24 + b2 * ALong._U16 + b1 * ALong._U8 + b0);\n        return ALong.fromHighLow(high, low);\n    }\n    /**\n     * Get a byte.\n     * @param index the index of the byte (0..7 where 0 is low).\n     * @return the byte value (0..255)\n     */\n    getByte(index) {\n        let value = (index < 4) ? this._low : this._high; // this should be unsigned\n        let position = (index < 4) ? index : (index - 4);\n        for (let i = 0; i < position; i++)\n            value = Numbers.floor(value / 256.0);\n        return Math.trunc(value % 256);\n    }\n    /**\n     * Check if a number is equal.\n     * @param value the value to check.\n     * @return true if equal.\n     */\n    isEqualTo(value) {\n        return (value._high == this._high) && (value._low == this._low);\n    }\n    /**\n     * Check if a number is not equal.\n     * @param value the value to check.\n     * @return true if equal.\n     */\n    isNotEqualTo(value) {\n        return (this.isEqualTo(value) == false);\n    }\n    /**\n     * Check if a number is equal.\n     * @param value the value to check.\n     * @return true if equal.\n     */\n    same(value) {\n        return this.isEqualTo(value);\n    }\n    /**\n     * Check if a number is equal.\n     * @param value the value to check.\n     * @return true if equal.\n     */\n    equals(value) {\n        return this.isEqualTo(value);\n    }\n    /**\n     * Compare this long to another long.\n     * @param value the other long.\n     * @return zero if equal, positive if smaller, or negative if value is larger.\n     */\n    compareTo(value) {\n        let diff = this.sub(value);\n        if (diff.isZero())\n            return 0;\n        return diff.isNegative() ? -1 : 1;\n    }\n    /**\n     * Check if a value is larger.\n     * @param value the value to check.\n     * @return true if this number is larger than the check value.\n     */\n    isLargerThan(value) {\n        return (this.compareTo(value) > 0);\n    }\n    /**\n     * Check if a value is larger.\n     * @param value the value to check.\n     * @return true if this number is larger than the check value.\n     */\n    isLargerThanOrEqualTo(value) {\n        return (this.compareTo(value) >= 0);\n    }\n    /**\n     * Check if a value is smaller.\n     * @param value the value to check.\n     * @return true if this number is smaller than the check value.\n     */\n    isSmallerThan(value) {\n        return (this.compareTo(value) < 0);\n    }\n    /**\n     * Check if a value is smaller.\n     * @param value the value to check.\n     * @return true if this number is smaller than the check value.\n     */\n    isSmallerThanOrEqualTo(value) {\n        return (this.compareTo(value) <= 0);\n    }\n    /**\n     * Get the maximum value.\n     * @param v1 the first value.\n     * @param v2 the second value.\n     * @return the maximum value.\n     */\n    static max(v1, v2) {\n        return (v2.isLargerThan(v1)) ? v2 : v1;\n    }\n    /**\n     * Get the minimum value.\n     * @param v1 the first value.\n     * @param v2 the second value.\n     * @return the minimum value.\n     */\n    static min(v1, v2) {\n        return (v2.isSmallerThan(v1)) ? v2 : v1;\n    }\n    /**\n     * Create a number from a string.\n     * @param svalue the string value.\n     * @param radix the radix (2 to 36).\n     * @return the number.\n     */\n    static fromRadixString(svalue, radix) {\n        /* Check the radix */\n        ASystem.assertNot((radix < 2) || (radix > 36), \"Invalid radix: \" + radix);\n        /* Common values? */\n        if (Strings.equals(svalue, \"0\"))\n            return ALong.ZERO;\n        if (Strings.equals(svalue, \"1\"))\n            return ALong.ONE;\n        /* Negative? */\n        let neg = Strings.startsWith(svalue, \"-\");\n        if (neg)\n            svalue = Strings.substringFrom(svalue, 1);\n        /* Add all digits */\n        let result = ALong.ZERO;\n        let unit = ALong.ONE;\n        let radixHL = ALong.fromInt(radix);\n        let slength = Strings.getLength(svalue);\n        for (let i = 0; i < slength; i++) {\n            /* Add the next digit */\n            let charCode = Strings.charCodeAt(svalue, slength - 1 - i);\n            let digit = (charCode >= 65) ? (charCode - 65 + 10) : (charCode - 48);\n            if (digit > 0)\n                result = result.add(unit.mulInt(digit));\n            unit = unit.mul(radixHL);\n        }\n        /* Return the result */\n        return (neg) ? result.negate() : result;\n    }\n    /**\n     * Create a number from a decimal string.\n     * @param value the string value.\n     * @return the number.\n     */\n    static fromString(value) {\n        if (value == null)\n            return null;\n        return ALong.fromRadixString(value, 10);\n    }\n    /**\n     * Create a number from a hexadecimal string.\n     * @param value the string value.\n     * @return the number.\n     */\n    static fromHexString(value) {\n        if (value == null)\n            return null;\n        return ALong.fromRadixString(value, 16);\n    }\n    /**\n     * Convert the number to a string.\n     * @param radix the radix (2 to 36).\n     * @return the string.\n     */\n    getRadixString(radix) {\n        /* Check the radix */\n        ASystem.assertNot((radix < 2) || (radix > 36), \"Invalid radix: \" + radix);\n        /* Common values? */\n        let value = this;\n        if (value.isZero())\n            return \"0\";\n        /* Make the value unsigned */\n        let neg = value.isNegative();\n        if (neg)\n            value = value.negate();\n        /* Add all digits */\n        let result = \"\";\n        while (true) {\n            /* Add the next digit */\n            if (value.isZero())\n                break;\n            let digit = value.modInt(radix);\n            value = value.divInt(radix);\n            let sdigit = (digit < 10) ? Strings.charCodeToString(48 + digit) : Strings.charCodeToString(65 + digit - 10);\n            result = (sdigit + result);\n            /* Fail? */\n            ASystem.assertNot(Strings.getLength(result) > 20, \"Failed to convert longHL to string (radix \" + radix + \"): \" + this._high + \";\" + this._low);\n        }\n        if (neg)\n            result = (\"-\" + result);\n        /* Return the result */\n        return result;\n    }\n    /**\n     * Convert the number to a decimal string.\n     * @return the string.\n     */\n    getString() {\n        return this.getRadixString(10);\n    }\n    /**\n     * Convert the number to a hexadecimal string.\n     * @return the string.\n     */\n    getHexString() {\n        return this.getRadixString(16);\n    }\n    /**\n     * The standard toString method.\n     * @see Object#toString\n     */\n    toString() {\n        return this.getString();\n    }\n}\n/** The value of a 32 bit unit */\nALong._U32 = 4294967296.0;\n/** The value of a 31 bit unit */\nALong._U31 = 2147483648.0;\n/** The value of a 24 bit unit */\nALong._U24 = 16777216.0;\n/** The value of a 16 bit unit */\nALong._U16 = 65536.0;\n/** The value of a 8 bit unit */\nALong._U8 = 256.0;\n/** The integer value 0 */\nALong.ZERO = new ALong(0.0, 0.0);\n/** The integer value 1 */\nALong.ONE = new ALong(0.0, 1.0);\n/** The integer value 2 */\nALong.TWO = new ALong(0.0, 2.0);\n/** The integer value 4 */\nALong.FOUR = new ALong(0.0, 4.0);\n/** The integer value 10 */\nALong.TEN = new ALong(0.0, 10.0);\n/** The integer value -1 */\nALong.MINUS_ONE = new ALong(ALong._U32 - 1.0, ALong._U32 - 1.0);\n/** The maximum positive value of a signed_ 64-bit integer (9223372036854775807) */\nALong.MAX_VALUE = new ALong(ALong._U31 - 1.0, ALong._U32 - 1.0);\n/** The minimum negative value of a signed 64-bit integer (-9223372036854775808) */\nALong.MIN_VALUE = new ALong(ALong._U31, 0.0);\nexport { ALong };\n//# sourceMappingURL=ALong.js.map",
      "start": 1693508126079,
      "end": 1693508126226,
      "sourcemaps": null
    }
  ]
}
