{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/common/ImageUtil.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Rendering\n */\nimport { Point2d } from \"@itwin/core-geometry\";\nimport { ImageBuffer, ImageBufferFormat, ImageSourceFormat } from \"@itwin/core-common\";\nimport { ViewRect } from \"./ViewRect\";\nconst scratchRgba = { r: 0, g: 0, b: 0, a: 0 };\nfunction rgbaFromAlpha(rgba, src, idx) {\n    rgba.r = rgba.g = rgba.b = rgba.a = src[idx];\n    return idx + 1;\n}\nfunction rgbaFromRgb(rgba, src, idx) {\n    rgba.r = src[idx + 0];\n    rgba.g = src[idx + 1];\n    rgba.b = src[idx + 2];\n    rgba.a = 255;\n    return idx + 3;\n}\nfunction rgbaFromRgba(rgba, src, idx) {\n    rgbaFromRgb(rgba, src, idx);\n    rgba.a = src[idx + 3];\n    return idx + 4;\n}\n/** Resize a canvas to a desired size.  The final size will be targetSize plus barSize.  The original canvas is left untouched and a new, resized canvas with potential side bars is returned.\n * @param canvasIn the source [HTMLCanvasElement](https://developer.mozilla.org/docs/Web/API/HTMLCanvasElement) to resize.\n * @param targetSize the desired new size for the canvas image.\n * @param barSize total size of side bars to add to the image in width and height; defaults to (0, 0).  For example, if you specify (2, 0), a 1 pixel side bar will be added to the left and right sides of the resized image.  If an odd dimension is specified, the left or upper side of the image will be one pixel larger than the opposite side.  For example, if you specify (1, 0), a 1 pixel side bar will be added to the left side of the image and a 0 pixel side bar will be added to the right side of the image.\n * @param barStyle CSS style string to apply to any side bars; defaults to \"#C0C0C0\", which is silver.\n * @returns an [HTMLCanvasElement](https://developer.mozilla.org/docs/Web/API/HTMLCanvasElement) object containing the resized image and any requested side bars.\n * @public\n * @extensions\n */\nexport function canvasToResizedCanvasWithBars(canvasIn, targetSize, barSize = new Point2d(0, 0), barStyle = \"#C0C0C0\") {\n    const canvasOut = document.createElement(\"canvas\");\n    canvasOut.width = targetSize.x + barSize.x;\n    canvasOut.height = targetSize.y + barSize.y;\n    let adjustImageX = barSize.x / 2;\n    let adjustImageY = barSize.y / 2;\n    if (1 === barSize.x % 2) {\n        adjustImageX += 0.5;\n    }\n    if (1 === barSize.y % 2) {\n        adjustImageY += 0.5;\n    }\n    const context = canvasOut.getContext(\"2d\");\n    context.fillStyle = barStyle;\n    context.fillRect(0, 0, canvasOut.width, canvasOut.height);\n    context.drawImage(canvasIn, adjustImageX, adjustImageY, targetSize.x, targetSize.y);\n    return canvasOut;\n}\n/** Create a canvas element with the same dimensions and contents as an image buffer.\n * @param buffer the source [[ImageBuffer]] object from which the [HTMLCanvasElement](https://developer.mozilla.org/docs/Web/API/HTMLCanvasElement) object will be constructed.\n * @param preserveAlpha If false, the alpha channel will be set to 255 (fully opaque). This is recommended when converting an already-blended image (e.g., one obtained from [[Viewport.readImageBuffer]]).\n * @returns an [HTMLCanvasElement](https://developer.mozilla.org/docs/Web/API/HTMLCanvasElement) object containing the contents of the source image buffer, or undefined if the conversion fails.\n * @public\n * @extensions\n */\nexport function imageBufferToCanvas(buffer, preserveAlpha = true) {\n    const canvas = document.createElement(\"canvas\");\n    if (null === canvas)\n        return undefined;\n    canvas.width = buffer.width;\n    canvas.height = buffer.height;\n    const context = canvas.getContext(\"2d\");\n    if (null === context)\n        return undefined;\n    const imageData = context.createImageData(buffer.width, buffer.height);\n    const extractRgba = ImageBufferFormat.Alpha === buffer.format ? rgbaFromAlpha : (ImageBufferFormat.Rgb === buffer.format ? rgbaFromRgb : rgbaFromRgba);\n    const bufferData = buffer.data;\n    let i = 0;\n    let j = 0;\n    const rgba = scratchRgba;\n    while (i < bufferData.length) {\n        i = extractRgba(rgba, bufferData, i);\n        imageData.data[j + 0] = rgba.r;\n        imageData.data[j + 1] = rgba.g;\n        imageData.data[j + 2] = rgba.b;\n        imageData.data[j + 3] = preserveAlpha ? rgba.a : 0xff;\n        j += 4;\n    }\n    context.putImageData(imageData, 0, 0);\n    return canvas;\n}\n/** Create an ImageBuffer in the specified format with the same dimensions and contents as a canvas.\n * @param canvas the source [HTMLCanvasElement](https://developer.mozilla.org/docs/Web/API/HTMLCanvasElement) object from which the [[ImageBuffer]] object will be constructed.\n * @param format the desired format of the created ImageBuffer; defaults to [[ImageBufferFormat.Rgba]].\n * @returns an [[ImageBuffer]] object containing the contents of the source canvas, or undefined if the conversion fails.\n * @public\n * @extensions\n */\nexport function canvasToImageBuffer(canvas, format = ImageBufferFormat.Rgba) {\n    const context = canvas.getContext(\"2d\");\n    if (null === context)\n        return undefined;\n    const imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n    let imageBufferData;\n    if (ImageBufferFormat.Rgba === format) {\n        imageBufferData = new Uint8Array(imageData.data.length);\n    }\n    else if (ImageBufferFormat.Rgb === format) {\n        imageBufferData = new Uint8Array((imageData.data.length / 4) * 3);\n    }\n    else if (ImageBufferFormat.Alpha === format) {\n        imageBufferData = new Uint8Array(imageData.data.length / 4);\n    }\n    if (undefined === imageBufferData)\n        return undefined;\n    let i = 0;\n    let j = 0;\n    while (i < imageData.data.length) {\n        if (ImageBufferFormat.Rgba === format) {\n            imageBufferData[j + 0] = imageData.data[i + 0];\n            imageBufferData[j + 1] = imageData.data[i + 1];\n            imageBufferData[j + 2] = imageData.data[i + 2];\n            imageBufferData[j + 3] = imageData.data[i + 3];\n            j += 4;\n        }\n        else if (ImageBufferFormat.Rgb === format) {\n            imageBufferData[j + 0] = imageData.data[i + 0];\n            imageBufferData[j + 1] = imageData.data[i + 1];\n            imageBufferData[j + 2] = imageData.data[i + 2];\n            j += 3;\n        }\n        else if (ImageBufferFormat.Alpha === format) {\n            imageBufferData[j] = imageData.data[i + 3];\n            j++;\n        }\n        i += 4;\n    }\n    return ImageBuffer.create(imageBufferData, format, canvas.width);\n}\n/** Get a string describing the mime type associated with an ImageSource format.\n * @public\n * @extensions\n */\nexport function getImageSourceMimeType(format) {\n    switch (format) {\n        case ImageSourceFormat.Jpeg:\n            return \"image/jpeg\";\n        case ImageSourceFormat.Png:\n            return \"image/png\";\n        case ImageSourceFormat.Svg:\n            return \"image/svg+xml;charset=utf-8\";\n    }\n    return \"\";\n}\n/** Get the ImageSourceFormat corresponding to the mime type string, or undefined if the string does not identify a supported ImageSourceFormat.\n * @public\n * @extensions\n */\nexport function getImageSourceFormatForMimeType(mimeType) {\n    switch (mimeType) {\n        case \"image/jpeg\": return ImageSourceFormat.Jpeg;\n        // not standard, but people accidentally use it anyway.\n        case \"image/jpg\": return ImageSourceFormat.Jpeg;\n        case \"image/png\": return ImageSourceFormat.Png;\n        case \"image/svg+xml;charset=utf-8\": return ImageSourceFormat.Svg;\n        default: return undefined;\n    }\n}\n/** Extract an html Image element from a binary jpeg or png.\n * @param source The ImageSource containing the binary jpeg or png data.\n * @returns a Promise which resolves to an HTMLImageElement containing the uncompressed bitmap image in RGBA format.\n * @public\n * @extensions\n */\nexport async function imageElementFromImageSource(source) {\n    const blob = new Blob([source.data], { type: getImageSourceMimeType(source.format) });\n    return imageElementFromUrl(URL.createObjectURL(blob));\n}\n/** Extract a bitmap from a binary jpeg or png.\n * @param source The ImageSource containing the binary jpeg or png data.\n * @returns a Promise which resolves to an ImageBitmap containing the uncompressed bitmap image in RGBA format.\n * @public\n */\nexport async function imageBitmapFromImageSource(source) {\n    const blob = new Blob([source.data], { type: getImageSourceMimeType(source.format) });\n    return createImageBitmap(blob, {\n        premultiplyAlpha: \"none\",\n        colorSpaceConversion: \"none\",\n    });\n}\n/** Create an html Image element from a URL.\n * @param url The URL pointing to the image data.\n * @param skipCrossOriginCheck Set this to true to allow an image from a different origin than the web app to load. Default is false.\n * @returns A Promise resolving to an HTMLImageElement when the image data has been loaded from the URL.\n * @see tryImageElementFromUrl.\n * @public\n * @extensions\n */\nexport async function imageElementFromUrl(url, skipCrossOriginCheck = false) {\n    // We must set crossorigin property so that images loaded from same origin can be used with texImage2d.\n    // We must do that outside of the promise constructor or it won't work, for reasons.\n    const image = new Image();\n    if (!skipCrossOriginCheck) {\n        image.crossOrigin = \"anonymous\";\n    }\n    return new Promise((resolve, reject) => {\n        image.onload = () => resolve(image);\n        // The \"error\" produced by Image is not an Error. It looks like an Event, but isn't one.\n        image.onerror = () => reject(new Error(\"Failed to create image from url\"));\n        image.src = url;\n    });\n}\n/** Try to create an html Image element from a URL.\n * @param url The URL pointing to the image data.\n * @param skipCrossOriginCheck Set this to true to allow an image from a different origin than the web app to load. Default is false.\n * @returns A Promise resolving to an HTMLImageElement when the image data has been loaded from the URL, or to `undefined` if an exception occurred.\n * @see imageElementFromUrl\n * @public\n */\nexport async function tryImageElementFromUrl(url, skipCrossOriginCheck = false) {\n    try {\n        return await imageElementFromUrl(url, skipCrossOriginCheck);\n    }\n    catch {\n        return undefined;\n    }\n}\n/**\n * Extract the dimensions of the jpeg or png data encoded in an ImageSource.\n * @param source The ImageSource containing the binary jpeg or png data.\n * @returns a Promise resolving to a Point2d of which x corresponds to the integer width of the uncompressed bitmap and y to the height.\n * @public\n * @extensions\n */\nexport async function extractImageSourceDimensions(source) {\n    const image = await imageElementFromImageSource(source);\n    return new Point2d(image.naturalWidth, image.naturalHeight);\n}\n/**\n * Produces a data url in \"image/png\" format from the contents of an ImageBuffer.\n * @param buffer The ImageBuffer, of any format.\n * @param preserveAlpha If false, the alpha channel will be set to 255 (fully opaque). This is recommended when converting an already-blended image (e.g., one obtained from [[Viewport.readImageBuffer]]).\n * @returns a data url as a string suitable for setting as the `src` property of an HTMLImageElement, or undefined if the url could not be created.\n * @public\n * @extensions\n */\nexport function imageBufferToPngDataUrl(buffer, preserveAlpha = true) {\n    // The default format (and the only format required to be supported) for toDataUrl() is \"image/png\".\n    const canvas = imageBufferToCanvas(buffer, preserveAlpha);\n    return undefined !== canvas ? canvas.toDataURL() : undefined;\n}\n/**\n * Converts the contents of an ImageBuffer to PNG format.\n * @param buffer The ImageBuffer, of any format.\n * @param preserveAlpha If false, the alpha channel will be set to 255 (fully opaque). This is recommended when converting an already-blended image (e.g., one obtained from [[Viewport.readImageBuffer]]).\n * @returns a base64-encoded string representing the image as a PNG, or undefined if the conversion failed.\n * @public\n * @extensions\n */\nexport function imageBufferToBase64EncodedPng(buffer, preserveAlpha = true) {\n    const urlPrefix = \"data:image/png;base64,\";\n    const url = imageBufferToPngDataUrl(buffer, preserveAlpha);\n    if (undefined === url || !url.startsWith(urlPrefix))\n        return undefined;\n    return url.substring(urlPrefix.length);\n}\n/** Open an image specified as a data URL in a new window or tab. Works around differences between browsers and Electron.\n * @param url The base64-encoded image URL.\n * @param title An optional title to apply to the new window.\n * @beta\n */\nexport function openImageDataUrlInNewWindow(url, title) {\n    const win = window.open();\n    if (null === win)\n        return;\n    const div = win.document.createElement(\"div\");\n    div.innerHTML = `<img src='${url}'/>`;\n    win.document.body.append(div);\n    if (undefined !== title)\n        win.document.title = title;\n}\n/** Determine the maximum [[ViewRect]] that can be fitted and centered in specified ViewRect given a required aspect ratio.\n * @param viewRect The rectangle in which the returned rectangle is to be centered and fitted.\n * @param aspectRatio Ratio of width to height.\n * @returns A ViewRect centered in the input rectangle.\n * @public\n */\nexport function getCenteredViewRect(viewRect, aspectRatio = 1.4) {\n    // Determine scale that ensures ability to return an image with the prescribed aspectRatio\n    const scale = Math.min(viewRect.width / aspectRatio, viewRect.height);\n    const finalWidth = scale * aspectRatio;\n    const finalHeight = scale;\n    const left = (viewRect.width - finalWidth) / 2.0;\n    const right = left + finalWidth;\n    const top = (viewRect.height - finalHeight) / 2.0;\n    const bottom = top + finalHeight;\n    return new ViewRect(left, top, right, bottom);\n}\n/** Produce a jpeg compressed to no more than specified bytes and of no less than specified quality.\n * @param canvas Canvas containing the image to be compressed.\n * @param maxBytes Maximum size of output jpeg in bytes.\n * @param minCompressionQuality The minimum acceptable image quality as a number between 0 (lowest quality) and 1 (highest quality).\n * @returns A [data URL](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs) for the image, or `undefined` if the compression and size constraints could not be met.\n * @public\n * @extensions\n */\nexport function getCompressedJpegFromCanvas(canvas, maxBytes = 60000, minCompressionQuality = 0.1) {\n    const decrements = 0.1; // Decrements of quality\n    const bytesPerCharacter = 2; // Assume 16-bit per character\n    let quality = 1.0; // JPEG Compression quality\n    while (quality > minCompressionQuality) {\n        const data = canvas.toDataURL(\"image/jpeg\", quality);\n        // If we are less than 60 Kb, we are good\n        if (data.length * bytesPerCharacter < maxBytes)\n            return data;\n        quality -= decrements;\n    }\n    return undefined;\n}\n//# sourceMappingURL=ImageUtil.js.map",
      "start": 1693508118555,
      "end": 1693508119139,
      "sourcemaps": null
    }
  ]
}
