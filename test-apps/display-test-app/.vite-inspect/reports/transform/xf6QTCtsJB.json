{
  "resolvedId": "D:/hub2023A/itwinjs-core/extensions/map-layers-formats/lib/esm/ArcGisFeature/ArcGisPbfFeatureReader.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\nimport { esriPBuffer } from \"../ArcGisFeature/esriPBuffer.gen\";\nimport { PropertyValueFormat, StandardTypeNames } from \"@itwin/appui-abstract\";\nimport { ArcGisBaseFeatureReader } from \"./ArcGisFeatureReader\";\nimport { Logger } from \"@itwin/core-bentley\";\nconst esriGeometryType = esriPBuffer.FeatureCollectionPBuffer.GeometryType;\nconst loggerCategory = \"MapLayersFormats.ArcGISFeature\";\n/** @internal */\nexport class ArcGisPbfFeatureReader extends ArcGisBaseFeatureReader {\n    constructor(settings, layerMetadata) {\n        super(settings, layerMetadata);\n    }\n    static getArcGisFeatureGeometryType(geomType) {\n        switch (geomType) {\n            case esriPBuffer.FeatureCollectionPBuffer.GeometryType.esriGeometryTypeMultipatch:\n                return \"esriGeometryMultiPatch\";\n            case esriPBuffer.FeatureCollectionPBuffer.GeometryType.esriGeometryTypeMultipoint:\n                return \"esriGeometryMultipoint\";\n            case esriPBuffer.FeatureCollectionPBuffer.GeometryType.esriGeometryTypePoint:\n                return \"esriGeometryPoint\";\n            case esriPBuffer.FeatureCollectionPBuffer.GeometryType.esriGeometryTypePolygon:\n                return \"esriGeometryPolygon\";\n            case esriPBuffer.FeatureCollectionPBuffer.GeometryType.esriGeometryTypePolyline:\n                return \"esriGeometryPolyline\";\n            default:\n                return \"esriGeometryNull\";\n        }\n    }\n    getNumericValue(attrValue) {\n        const propertyValue = { valueFormat: PropertyValueFormat.Primitive };\n        let typename = StandardTypeNames.Number;\n        if (attrValue.has_double_value) {\n            const value = this.toFixedWithoutPadding(attrValue.double_value);\n            propertyValue.value = value;\n            typename = StandardTypeNames.Double;\n        }\n        else if (attrValue.has_float_value) {\n            const value = this.toFixedWithoutPadding(attrValue.float_value);\n            propertyValue.value = value;\n            typename = StandardTypeNames.Float;\n        }\n        else if (attrValue.has_int64_value) {\n            propertyValue.value = attrValue.int64_value;\n            typename = StandardTypeNames.Integer;\n        }\n        else if (attrValue.has_sint64_value) {\n            propertyValue.value = attrValue.sint64_value;\n            typename = StandardTypeNames.Integer;\n        }\n        else if (attrValue.has_sint_value) {\n            propertyValue.value = attrValue.sint_value;\n            typename = StandardTypeNames.Integer;\n        }\n        else if (attrValue.has_uint64_value) {\n            propertyValue.value = attrValue.uint64_value;\n            typename = StandardTypeNames.Integer;\n        }\n        else if (attrValue.has_uint_value) {\n            propertyValue.value = attrValue.uint_value;\n            typename = StandardTypeNames.Integer;\n        }\n        else {\n            propertyValue.value = undefined;\n        }\n        return { propertyValue, typename };\n    }\n    getFeatureAttribute(fieldInfo, attrValue) {\n        let propertyValue = { valueFormat: PropertyValueFormat.Primitive };\n        let typename = StandardTypeNames.String;\n        if (fieldInfo.type === esriPBuffer.FeatureCollectionPBuffer.FieldType.esriFieldTypeDouble\n            || fieldInfo.type === esriPBuffer.FeatureCollectionPBuffer.FieldType.esriFieldTypeInteger\n            || fieldInfo.type === esriPBuffer.FeatureCollectionPBuffer.FieldType.esriFieldTypeSmallInteger\n            || fieldInfo.type === esriPBuffer.FeatureCollectionPBuffer.FieldType.esriFieldTypeOID\n            || fieldInfo.type === esriPBuffer.FeatureCollectionPBuffer.FieldType.esriFieldTypeSingle\n            || fieldInfo.type === esriPBuffer.FeatureCollectionPBuffer.FieldType.esriFieldTypeDate) {\n            const value = this.getNumericValue(attrValue);\n            if (value.propertyValue === undefined) {\n                Logger.logError(loggerCategory, `Could not read numeric value for field ${fieldInfo.name}`);\n                return undefined;\n            }\n            if (fieldInfo.type === esriPBuffer.FeatureCollectionPBuffer.FieldType.esriFieldTypeDate) {\n                const test = value.propertyValue.value;\n                propertyValue.value = new Date(test);\n                typename = StandardTypeNames.DateTime;\n            }\n            else {\n                typename = value.typename;\n                propertyValue = value.propertyValue;\n            }\n        }\n        else if (fieldInfo.type === esriPBuffer.FeatureCollectionPBuffer.FieldType.esriFieldTypeString) {\n            if (attrValue.has_string_value) {\n                propertyValue.value = attrValue.string_value;\n                typename = StandardTypeNames.String;\n            }\n        }\n        else if (fieldInfo.type === esriPBuffer.FeatureCollectionPBuffer.FieldType.esriFieldTypeGlobalID) {\n            if (attrValue.has_string_value) {\n                propertyValue.value = attrValue.string_value;\n                typename = StandardTypeNames.String;\n            }\n            else {\n                const value = this.getNumericValue(attrValue);\n                if (value.propertyValue === undefined) {\n                    Logger.logError(loggerCategory, `Could not read GlobalId value for field ${fieldInfo.name}`);\n                    return undefined;\n                }\n            }\n        }\n        else if (attrValue.has_string_value) {\n            // If we reach this case that probably mean we don't support the field type, simply try to output string value\n            typename = StandardTypeNames.String;\n            propertyValue.value = attrValue.string_value;\n        }\n        else if (attrValue.value_type === \"none\") {\n            // Sometimes fields are just empty, use an empty string\n            typename = StandardTypeNames.String;\n            propertyValue.value = undefined;\n        }\n        else {\n            Logger.logError(loggerCategory, `Could not read value for field ${fieldInfo.name}`);\n            return undefined;\n        }\n        propertyValue.displayValue = this.getDisplayValue(typename, propertyValue.value);\n        return { value: propertyValue, property: { name: fieldInfo.name, displayLabel: fieldInfo.name, typename } };\n    }\n    async readAndRender(response, renderer) {\n        if (!(response.data instanceof esriPBuffer.FeatureCollectionPBuffer)) {\n            const msg = \"Response was not in PBF format\";\n            Logger.logError(loggerCategory, msg);\n            return;\n        }\n        const collection = response.data;\n        if (!collection.has_queryResult || !collection.queryResult.has_featureResult || collection?.queryResult?.featureResult?.features === undefined)\n            return;\n        const attrSymbology = renderer.attributeSymbology;\n        // Fields metadata is stored outside feature results, create dedicated array first\n        const fields = [];\n        for (const field of collection.queryResult.featureResult.fields)\n            fields.push({ name: field.name, type: field.fieldType });\n        const geomType = collection.queryResult.featureResult.geometryType;\n        const stride = (collection.queryResult.featureResult.hasM || collection.queryResult.featureResult.hasZ) ? 3 : 2;\n        const relativeCoords = renderer.transform === undefined;\n        for (const feature of collection.queryResult.featureResult.features) {\n            // Render geometries\n            if (renderer && feature?.has_geometry) {\n                if (attrSymbology) {\n                    // Read attributes if needed (attribute driven symbology)\n                    this.applySymbologyAttributes(attrSymbology, feature, fields);\n                }\n                if (geomType === esriGeometryType.esriGeometryTypePoint || geomType === esriGeometryType.esriGeometryTypeMultipoint) {\n                    await renderer.renderPoint(feature.geometry.lengths, feature.geometry.coords, stride, relativeCoords);\n                }\n                else if (geomType === esriGeometryType.esriGeometryTypePolyline || geomType === esriGeometryType.esriGeometryTypePolygon) {\n                    const fill = (geomType === esriGeometryType.esriGeometryTypePolygon);\n                    await renderer.renderPath(feature.geometry.lengths, feature.geometry.coords, fill, stride, relativeCoords);\n                }\n            }\n        }\n    }\n    applySymbologyAttributes(attrSymbology, feature, fields) {\n        if (attrSymbology) {\n            const symbolFields = attrSymbology.rendererFields;\n            if (symbolFields && symbolFields.length > 0 && feature.attributes) {\n                let fieldIdx = 0;\n                const featureAttr = {};\n                for (const attrValue of feature.attributes) {\n                    if (fieldIdx > fields.length) {\n                        Logger.logError(loggerCategory, \"Error while read feature info data: fields metadata missing\");\n                        break;\n                    }\n                    const fieldInfo = fields[fieldIdx++];\n                    if (symbolFields.includes(fieldInfo.name)) {\n                        const attr = this.getFeatureAttribute(fieldInfo, attrValue);\n                        if (attr) {\n                            const primitiveValue = attr.value;\n                            featureAttr[fieldInfo.name] = primitiveValue.value;\n                        }\n                    }\n                }\n                attrSymbology.setActiveFeatureAttributes(featureAttr);\n            }\n        }\n    }\n    async readFeatureInfo(response, featureInfos, renderer) {\n        if (!(response.data instanceof esriPBuffer.FeatureCollectionPBuffer)) {\n            Logger.logError(loggerCategory, \"Response was not in PBF format\");\n        }\n        const collection = response.data;\n        if (!collection.has_queryResult || !collection.queryResult.has_featureResult || collection?.queryResult?.featureResult?.features === undefined)\n            return;\n        const layerInfo = { layerName: this._settings.name, subLayerInfos: [] };\n        // Fields metadata is stored outside feature results, create dedicated array first\n        const fields = [];\n        for (const field of collection.queryResult.featureResult.fields)\n            fields.push({ name: field.name, type: field.fieldType });\n        const geomType = collection.queryResult.featureResult.geometryType;\n        const stride = (collection.queryResult.featureResult.hasM || collection.queryResult.featureResult.hasZ) ? 3 : 2;\n        const subLayerInfo = {\n            subLayerName: this._layerMetadata.name,\n            displayFieldName: this._layerMetadata.name,\n            features: [],\n        };\n        // Read feature values\n        for (const featureResponse of collection.queryResult.featureResult.features) {\n            const feature = { attributes: [] };\n            if (renderer && featureResponse?.has_geometry) {\n                if (geomType === esriGeometryType.esriGeometryTypePoint || geomType === esriGeometryType.esriGeometryTypeMultipoint) {\n                    await renderer.renderPoint(featureResponse.geometry.lengths, featureResponse.geometry.coords, stride, true);\n                }\n                else if (geomType === esriGeometryType.esriGeometryTypePolyline || geomType === esriGeometryType.esriGeometryTypePolygon) {\n                    const fill = (geomType === esriGeometryType.esriGeometryTypePolygon);\n                    await renderer.renderPath(featureResponse.geometry.lengths, featureResponse.geometry.coords, fill, stride, true);\n                }\n                const graphics = renderer.moveGraphics();\n                feature.geometries = graphics.map((graphic) => {\n                    return { graphic };\n                });\n            }\n            let fieldIdx = 0;\n            for (const attrValue of featureResponse.attributes) {\n                if (fieldIdx > fields.length) {\n                    Logger.logError(loggerCategory, \"Error while read feature info data: fields metadata missing\");\n                    break;\n                }\n                // Convert everything to string for now\n                const attr = this.getFeatureAttribute(fields[fieldIdx], attrValue);\n                if (attr) {\n                    feature.attributes?.push(attr);\n                }\n                fieldIdx++;\n            }\n            subLayerInfo.features.push(feature);\n        }\n        if (layerInfo.subLayerInfos === undefined) {\n            layerInfo.subLayerInfos = [];\n        }\n        layerInfo.subLayerInfos.push(subLayerInfo);\n        featureInfos.push(layerInfo);\n    }\n}\n//# sourceMappingURL=ArcGisPbfFeatureReader.js.map",
      "start": 1693508125119,
      "end": 1693508125191,
      "sourcemaps": null
    }
  ]
}
