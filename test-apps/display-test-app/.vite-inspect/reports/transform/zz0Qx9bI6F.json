{
  "resolvedId": "D:/hub2023A/itwinjs-core/test-apps/display-test-app/src/frontend/PathDecorationTest.ts",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\r\n* See LICENSE.md in the project root for license terms and full copyright notice.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\nimport { CanvasDecoration, DecorateContext, GraphicType, HitDetail, IModelApp, Tool } from \"@itwin/core-frontend\";\r\nimport { AxisAlignedBox3d, GeometryStreamProps } from \"@itwin/core-common\";\r\nimport { AngleSweep, Arc3d, Path, Range1d, Range3d } from \"@itwin/core-geometry\";\r\n\r\nclass PathCanvasDecoration implements CanvasDecoration {\r\n  public drawDecoration(ctx: CanvasRenderingContext2D) {\r\n    ctx.textAlign = \"center\";\r\n    ctx.textBaseline = \"middle\";\r\n    ctx.font = \"14px sans-serif\";\r\n    ctx.fillStyle = \"white\";\r\n    ctx.fillText(\"Path Decoration Test Tool Active\", 256, 256);\r\n  }\r\n}\r\n\r\n/** This class decorates a viewport with a small path.\r\n */\r\nexport class PathDecorationTest {\r\n  public static decorator?: PathDecorationTest; // static variable so we can tell if the test is active.\r\n  public static canvasDecoration = new PathCanvasDecoration();\r\n\r\n  private _path: Path;\r\n  private _pickId?: string;\r\n\r\n  public constructor(extents: AxisAlignedBox3d) {\r\n    this._path = _getPath(extents);\r\n  }\r\n\r\n  /** This will allow the render system to cache and reuse the decorations created by this decorator's decorate() method. */\r\n  public readonly useCachedDecorations = true;\r\n\r\n  /** We added this class as a ViewManager.decorator below. This method is called to ask for our decorations. Here we add the line string. */\r\n  public decorate(context: DecorateContext) {\r\n    if (undefined === this._pickId)\r\n      this._pickId = context.viewport.iModel.transientIds.getNext();\r\n    const pathBuilder = context.createGraphicBuilder(GraphicType.WorldDecoration, undefined, this._pickId);\r\n    pathBuilder.addPath(this._path);\r\n    context.addDecorationFromBuilder(pathBuilder);\r\n    context.addCanvasDecoration(PathDecorationTest.canvasDecoration);\r\n  }\r\n\r\n  /** Test any hits against this id. */\r\n  public testDecorationHit(id: string): boolean { return id === this._pickId; }\r\n\r\n  /** Return no decoration geometry for picking. */\r\n  public getDecorationGeometry(_hit: HitDetail): GeometryStreamProps | undefined { return undefined; }\r\n\r\n  /** Create the PathDecorationTest object and adding it as a ViewManager decorator. */\r\n  private static start(extents: AxisAlignedBox3d) {\r\n    PathDecorationTest.decorator = new PathDecorationTest(extents);\r\n    IModelApp.viewManager.addDecorator(PathDecorationTest.decorator);\r\n  }\r\n\r\n  /** stop the demo */\r\n  private static stop() {\r\n    if (PathDecorationTest.decorator)\r\n      IModelApp.viewManager.dropDecorator(PathDecorationTest.decorator);\r\n    PathDecorationTest.decorator = undefined;\r\n  }\r\n\r\n  /** Turn the line decoration on and off. */\r\n  public static toggle(extents: AxisAlignedBox3d) {\r\n    if (undefined === PathDecorationTest.decorator)\r\n      this.start(extents);\r\n    else\r\n      this.stop();\r\n  }\r\n}\r\n\r\nexport class PathDecorationTestTool extends Tool {\r\n  public static override toolId = \"TogglePathDecoration\";\r\n  public override async run(_args: any[]) {\r\n    const vp = IModelApp.viewManager.selectedView;\r\n    if (undefined !== vp)\r\n      PathDecorationTest.toggle(vp.view.iModel.projectExtents);\r\n    return true;\r\n  }\r\n}\r\n\r\nfunction _getPath(extents: AxisAlignedBox3d): Path {\r\n  const range = Range3d.createNull();\r\n  range.extendPoint(extents.low);\r\n  range.extendPoint(extents.high);\r\n\r\n  const range1d = Range1d.createXX(0.0, 0.2);\r\n  const curves = [];\r\n\r\n  const numIterations = 1000;\r\n  for (let i = 0; i < numIterations; i++) {\r\n    const fract = range1d.fractionToPoint((i + 1.0) / numIterations);\r\n    const halfFract = fract * 0.5;\r\n\r\n    const a = range.fractionToPoint(0.0, 0.0, 0.0);\r\n    const b = range.fractionToPoint(halfFract, 0.0, 0.0);\r\n    const c = range.fractionToPoint(halfFract, halfFract, 0.0);\r\n    const d = range.fractionToPoint(halfFract, halfFract, halfFract);\r\n    const e = range.fractionToPoint(fract * 0.75, fract, fract);\r\n    const f = range.fractionToPoint(fract, fract, fract);\r\n\r\n    curves.push([a, b, c, d]);\r\n    curves.push(Arc3d.create(d, d.vectorTo(e), d.vectorTo(f), AngleSweep.createStartEndDegrees(0.0, 90.0)));\r\n  }\r\n\r\n  return Path.create(...curves);\r\n}\r\n",
      "start": 1693508121233,
      "end": 1693508121256,
      "sourcemaps": null
    },
    {
      "name": "vite:esbuild",
      "result": "\"use strict\";\nimport { GraphicType, IModelApp, Tool } from \"@itwin/core-frontend\";\nimport { AngleSweep, Arc3d, Path, Range1d, Range3d } from \"@itwin/core-geometry\";\nclass PathCanvasDecoration {\n  drawDecoration(ctx) {\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n    ctx.font = \"14px sans-serif\";\n    ctx.fillStyle = \"white\";\n    ctx.fillText(\"Path Decoration Test Tool Active\", 256, 256);\n  }\n}\nconst _PathDecorationTest = class _PathDecorationTest {\n  constructor(extents) {\n    /** This will allow the render system to cache and reuse the decorations created by this decorator's decorate() method. */\n    this.useCachedDecorations = true;\n    this._path = _getPath(extents);\n  }\n  /** We added this class as a ViewManager.decorator below. This method is called to ask for our decorations. Here we add the line string. */\n  decorate(context) {\n    if (void 0 === this._pickId)\n      this._pickId = context.viewport.iModel.transientIds.getNext();\n    const pathBuilder = context.createGraphicBuilder(GraphicType.WorldDecoration, void 0, this._pickId);\n    pathBuilder.addPath(this._path);\n    context.addDecorationFromBuilder(pathBuilder);\n    context.addCanvasDecoration(_PathDecorationTest.canvasDecoration);\n  }\n  /** Test any hits against this id. */\n  testDecorationHit(id) {\n    return id === this._pickId;\n  }\n  /** Return no decoration geometry for picking. */\n  getDecorationGeometry(_hit) {\n    return void 0;\n  }\n  /** Create the PathDecorationTest object and adding it as a ViewManager decorator. */\n  static start(extents) {\n    _PathDecorationTest.decorator = new _PathDecorationTest(extents);\n    IModelApp.viewManager.addDecorator(_PathDecorationTest.decorator);\n  }\n  /** stop the demo */\n  static stop() {\n    if (_PathDecorationTest.decorator)\n      IModelApp.viewManager.dropDecorator(_PathDecorationTest.decorator);\n    _PathDecorationTest.decorator = void 0;\n  }\n  /** Turn the line decoration on and off. */\n  static toggle(extents) {\n    if (void 0 === _PathDecorationTest.decorator)\n      this.start(extents);\n    else\n      this.stop();\n  }\n};\n// static variable so we can tell if the test is active.\n_PathDecorationTest.canvasDecoration = new PathCanvasDecoration();\nexport let PathDecorationTest = _PathDecorationTest;\nexport class PathDecorationTestTool extends Tool {\n  async run(_args) {\n    const vp = IModelApp.viewManager.selectedView;\n    if (void 0 !== vp)\n      PathDecorationTest.toggle(vp.view.iModel.projectExtents);\n    return true;\n  }\n}\nPathDecorationTestTool.toolId = \"TogglePathDecoration\";\nfunction _getPath(extents) {\n  const range = Range3d.createNull();\n  range.extendPoint(extents.low);\n  range.extendPoint(extents.high);\n  const range1d = Range1d.createXX(0, 0.2);\n  const curves = [];\n  const numIterations = 1e3;\n  for (let i = 0; i < numIterations; i++) {\n    const fract = range1d.fractionToPoint((i + 1) / numIterations);\n    const halfFract = fract * 0.5;\n    const a = range.fractionToPoint(0, 0, 0);\n    const b = range.fractionToPoint(halfFract, 0, 0);\n    const c = range.fractionToPoint(halfFract, halfFract, 0);\n    const d = range.fractionToPoint(halfFract, halfFract, halfFract);\n    const e = range.fractionToPoint(fract * 0.75, fract, fract);\n    const f = range.fractionToPoint(fract, fract, fract);\n    curves.push([a, b, c, d]);\n    curves.push(Arc3d.create(d, d.vectorTo(e), d.vectorTo(f), AngleSweep.createStartEndDegrees(0, 90)));\n  }\n  return Path.create(...curves);\n}\n",
      "start": 1693508121256,
      "end": 1693508121435,
      "order": "normal",
      "sourcemaps": {
        "version": 3,
        "sources": [
          "D:/hub2023A/itwinjs-core/test-apps/display-test-app/src/frontend/PathDecorationTest.ts"
        ],
        "sourcesContent": [
          "/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\r\n* See LICENSE.md in the project root for license terms and full copyright notice.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\nimport { CanvasDecoration, DecorateContext, GraphicType, HitDetail, IModelApp, Tool } from \"@itwin/core-frontend\";\r\nimport { AxisAlignedBox3d, GeometryStreamProps } from \"@itwin/core-common\";\r\nimport { AngleSweep, Arc3d, Path, Range1d, Range3d } from \"@itwin/core-geometry\";\r\n\r\nclass PathCanvasDecoration implements CanvasDecoration {\r\n  public drawDecoration(ctx: CanvasRenderingContext2D) {\r\n    ctx.textAlign = \"center\";\r\n    ctx.textBaseline = \"middle\";\r\n    ctx.font = \"14px sans-serif\";\r\n    ctx.fillStyle = \"white\";\r\n    ctx.fillText(\"Path Decoration Test Tool Active\", 256, 256);\r\n  }\r\n}\r\n\r\n/** This class decorates a viewport with a small path.\r\n */\r\nexport class PathDecorationTest {\r\n  public static decorator?: PathDecorationTest; // static variable so we can tell if the test is active.\r\n  public static canvasDecoration = new PathCanvasDecoration();\r\n\r\n  private _path: Path;\r\n  private _pickId?: string;\r\n\r\n  public constructor(extents: AxisAlignedBox3d) {\r\n    this._path = _getPath(extents);\r\n  }\r\n\r\n  /** This will allow the render system to cache and reuse the decorations created by this decorator's decorate() method. */\r\n  public readonly useCachedDecorations = true;\r\n\r\n  /** We added this class as a ViewManager.decorator below. This method is called to ask for our decorations. Here we add the line string. */\r\n  public decorate(context: DecorateContext) {\r\n    if (undefined === this._pickId)\r\n      this._pickId = context.viewport.iModel.transientIds.getNext();\r\n    const pathBuilder = context.createGraphicBuilder(GraphicType.WorldDecoration, undefined, this._pickId);\r\n    pathBuilder.addPath(this._path);\r\n    context.addDecorationFromBuilder(pathBuilder);\r\n    context.addCanvasDecoration(PathDecorationTest.canvasDecoration);\r\n  }\r\n\r\n  /** Test any hits against this id. */\r\n  public testDecorationHit(id: string): boolean { return id === this._pickId; }\r\n\r\n  /** Return no decoration geometry for picking. */\r\n  public getDecorationGeometry(_hit: HitDetail): GeometryStreamProps | undefined { return undefined; }\r\n\r\n  /** Create the PathDecorationTest object and adding it as a ViewManager decorator. */\r\n  private static start(extents: AxisAlignedBox3d) {\r\n    PathDecorationTest.decorator = new PathDecorationTest(extents);\r\n    IModelApp.viewManager.addDecorator(PathDecorationTest.decorator);\r\n  }\r\n\r\n  /** stop the demo */\r\n  private static stop() {\r\n    if (PathDecorationTest.decorator)\r\n      IModelApp.viewManager.dropDecorator(PathDecorationTest.decorator);\r\n    PathDecorationTest.decorator = undefined;\r\n  }\r\n\r\n  /** Turn the line decoration on and off. */\r\n  public static toggle(extents: AxisAlignedBox3d) {\r\n    if (undefined === PathDecorationTest.decorator)\r\n      this.start(extents);\r\n    else\r\n      this.stop();\r\n  }\r\n}\r\n\r\nexport class PathDecorationTestTool extends Tool {\r\n  public static override toolId = \"TogglePathDecoration\";\r\n  public override async run(_args: any[]) {\r\n    const vp = IModelApp.viewManager.selectedView;\r\n    if (undefined !== vp)\r\n      PathDecorationTest.toggle(vp.view.iModel.projectExtents);\r\n    return true;\r\n  }\r\n}\r\n\r\nfunction _getPath(extents: AxisAlignedBox3d): Path {\r\n  const range = Range3d.createNull();\r\n  range.extendPoint(extents.low);\r\n  range.extendPoint(extents.high);\r\n\r\n  const range1d = Range1d.createXX(0.0, 0.2);\r\n  const curves = [];\r\n\r\n  const numIterations = 1000;\r\n  for (let i = 0; i < numIterations; i++) {\r\n    const fract = range1d.fractionToPoint((i + 1.0) / numIterations);\r\n    const halfFract = fract * 0.5;\r\n\r\n    const a = range.fractionToPoint(0.0, 0.0, 0.0);\r\n    const b = range.fractionToPoint(halfFract, 0.0, 0.0);\r\n    const c = range.fractionToPoint(halfFract, halfFract, 0.0);\r\n    const d = range.fractionToPoint(halfFract, halfFract, halfFract);\r\n    const e = range.fractionToPoint(fract * 0.75, fract, fract);\r\n    const f = range.fractionToPoint(fract, fract, fract);\r\n\r\n    curves.push([a, b, c, d]);\r\n    curves.push(Arc3d.create(d, d.vectorTo(e), d.vectorTo(f), AngleSweep.createStartEndDegrees(0.0, 90.0)));\r\n  }\r\n\r\n  return Path.create(...curves);\r\n}\r\n"
        ],
        "mappings": ";AAKA,SAA4C,aAAwB,WAAW,YAAY;AAE3F,SAAS,YAAY,OAAO,MAAM,SAAS,eAAe;AAE1D,MAAM,qBAAiD;AAAA,EAC9C,eAAe,KAA+B;AACnD,QAAI,YAAY;AAChB,QAAI,eAAe;AACnB,QAAI,OAAO;AACX,QAAI,YAAY;AAChB,QAAI,SAAS,oCAAoC,KAAK,GAAG;AAAA,EAC3D;AACF;AAIO,MAAM,sBAAN,MAAM,oBAAmB;AAAA,EAOvB,YAAY,SAA2B;AAK9C;AAAA,SAAgB,uBAAuB;AAJrC,SAAK,QAAQ,SAAS,OAAO;AAAA,EAC/B;AAAA;AAAA,EAMO,SAAS,SAA0B;AACxC,QAAI,WAAc,KAAK;AACrB,WAAK,UAAU,QAAQ,SAAS,OAAO,aAAa,QAAQ;AAC9D,UAAM,cAAc,QAAQ,qBAAqB,YAAY,iBAAiB,QAAW,KAAK,OAAO;AACrG,gBAAY,QAAQ,KAAK,KAAK;AAC9B,YAAQ,yBAAyB,WAAW;AAC5C,YAAQ,oBAAoB,oBAAmB,gBAAgB;AAAA,EACjE;AAAA;AAAA,EAGO,kBAAkB,IAAqB;AAAE,WAAO,OAAO,KAAK;AAAA,EAAS;AAAA;AAAA,EAGrE,sBAAsB,MAAkD;AAAE,WAAO;AAAA,EAAW;AAAA;AAAA,EAGnG,OAAe,MAAM,SAA2B;AAC9C,wBAAmB,YAAY,IAAI,oBAAmB,OAAO;AAC7D,cAAU,YAAY,aAAa,oBAAmB,SAAS;AAAA,EACjE;AAAA;AAAA,EAGA,OAAe,OAAO;AACpB,QAAI,oBAAmB;AACrB,gBAAU,YAAY,cAAc,oBAAmB,SAAS;AAClE,wBAAmB,YAAY;AAAA,EACjC;AAAA;AAAA,EAGA,OAAc,OAAO,SAA2B;AAC9C,QAAI,WAAc,oBAAmB;AACnC,WAAK,MAAM,OAAO;AAAA;AAElB,WAAK,KAAK;AAAA,EACd;AACF;AAAA;AAlDa,oBAEG,mBAAmB,IAAI,qBAAqB;AAFrD,WAAM,qBAAN;AAoDA,aAAM,+BAA+B,KAAK;AAAA,EAE/C,MAAsB,IAAI,OAAc;AACtC,UAAM,KAAK,UAAU,YAAY;AACjC,QAAI,WAAc;AAChB,yBAAmB,OAAO,GAAG,KAAK,OAAO,cAAc;AACzD,WAAO;AAAA,EACT;AACF;AARa,uBACY,SAAS;AASlC,SAAS,SAAS,SAAiC;AACjD,QAAM,QAAQ,QAAQ,WAAW;AACjC,QAAM,YAAY,QAAQ,GAAG;AAC7B,QAAM,YAAY,QAAQ,IAAI;AAE9B,QAAM,UAAU,QAAQ,SAAS,GAAK,GAAG;AACzC,QAAM,SAAS,CAAC;AAEhB,QAAM,gBAAgB;AACtB,WAAS,IAAI,GAAG,IAAI,eAAe,KAAK;AACtC,UAAM,QAAQ,QAAQ,iBAAiB,IAAI,KAAO,aAAa;AAC/D,UAAM,YAAY,QAAQ;AAE1B,UAAM,IAAI,MAAM,gBAAgB,GAAK,GAAK,CAAG;AAC7C,UAAM,IAAI,MAAM,gBAAgB,WAAW,GAAK,CAAG;AACnD,UAAM,IAAI,MAAM,gBAAgB,WAAW,WAAW,CAAG;AACzD,UAAM,IAAI,MAAM,gBAAgB,WAAW,WAAW,SAAS;AAC/D,UAAM,IAAI,MAAM,gBAAgB,QAAQ,MAAM,OAAO,KAAK;AAC1D,UAAM,IAAI,MAAM,gBAAgB,OAAO,OAAO,KAAK;AAEnD,WAAO,KAAK,CAAC,GAAG,GAAG,GAAG,CAAC,CAAC;AACxB,WAAO,KAAK,MAAM,OAAO,GAAG,EAAE,SAAS,CAAC,GAAG,EAAE,SAAS,CAAC,GAAG,WAAW,sBAAsB,GAAK,EAAI,CAAC,CAAC;AAAA,EACxG;AAEA,SAAO,KAAK,OAAO,GAAG,MAAM;AAC9B;",
        "names": []
      }
    }
  ]
}
