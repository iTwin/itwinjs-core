{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/VertexLUT.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { dispose } from \"@itwin/core-bentley\";\nimport { ColorInfo } from \"./ColorInfo\";\nimport { qorigin3dToArray, qparams2dToArray, qscale3dToArray } from \"./AttributeBuffers\";\nimport { TextureHandle } from \"./Texture\";\n/** @internal */\nexport class AuxChannelLUT {\n    constructor(texture, table) {\n        this.texture = texture;\n        this.numVertices = table.numVertices;\n        this.numBytesPerVertex = table.numBytesPerVertex;\n        this.initChannels(table, \"displacements\");\n        this.initChannels(table, \"normals\");\n        this.initChannels(table, \"params\");\n    }\n    initChannels(table, name) {\n        const channels = table[name];\n        if (undefined === channels)\n            return;\n        const map = new Map();\n        // TS2322: Type 'Map<string, T>' is not assignable to type 'Map<string, AuxChannel> & Map<string, AuxDisplacementChannel> & Map<string, AuxParamChannel>'.\n        // (Compiler cannot detect that the specific property name is matched to the correct subtype at each call site - but we know that).\n        this[name] = map;\n        for (const channel of channels)\n            map.set(channel.name, channel);\n    }\n    get bytesUsed() { return this.texture.bytesUsed; }\n    get hasScalarAnimation() { return undefined !== this.params; }\n    get isDisposed() { return this.texture.isDisposed; }\n    dispose() {\n        dispose(this.texture);\n    }\n    static create(table) {\n        const texture = TextureHandle.createForData(table.width, table.height, table.data);\n        return undefined !== texture ? new AuxChannelLUT(texture, table) : undefined;\n    }\n}\n/** Represents the finished lookup table ready for submission to GPU.\n * @internal\n */\nexport class VertexLUT {\n    get hasAnimation() { return undefined !== this.auxChannels; }\n    get hasScalarAnimation() { return undefined !== this.auxChannels && this.auxChannels.hasScalarAnimation; }\n    get bytesUsed() {\n        let bytesUsed = this.texture.bytesUsed;\n        if (undefined !== this.auxChannels)\n            bytesUsed += this.auxChannels.bytesUsed;\n        return bytesUsed;\n    }\n    static createFromVertexTable(vt, aux) {\n        const texture = TextureHandle.createForData(vt.width, vt.height, vt.data);\n        if (undefined === texture)\n            return undefined;\n        const auxLUT = undefined !== aux ? AuxChannelLUT.create(aux) : undefined;\n        return new VertexLUT(texture, vt, ColorInfo.createFromVertexTable(vt), vt.qparams, !vt.usesUnquantizedPositions, vt.uvParams, auxLUT);\n    }\n    constructor(texture, table, colorInfo, qparams, positionsAreQuantized, uvParams, auxChannels) {\n        this.texture = texture;\n        this.numVertices = table.numVertices;\n        this.numRgbaPerVertex = table.numRgbaPerVertex;\n        this.colorInfo = colorInfo;\n        this.qOrigin = qorigin3dToArray(qparams.origin);\n        this.qScale = qscale3dToArray(qparams.scale);\n        this.usesQuantizedPositions = positionsAreQuantized;\n        this.auxChannels = auxChannels;\n        if (undefined !== uvParams)\n            this.uvQParams = qparams2dToArray(uvParams);\n    }\n    get isDisposed() { return this.texture.isDisposed; }\n    dispose() {\n        dispose(this.texture);\n    }\n}\n//# sourceMappingURL=VertexLUT.js.map",
      "start": 1693508125824,
      "end": 1693508125897,
      "sourcemaps": null
    }
  ]
}
