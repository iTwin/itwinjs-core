{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/common/lib/esm/HiddenLine.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module DisplayStyles\n */\nimport { JsonUtils } from \"@itwin/core-bentley\";\nimport { ColorDef } from \"./ColorDef\";\nimport { LinePixels } from \"./LinePixels\";\n/** Namespace containing types controlling how edges and surfaces should be drawn in \"hidden line\" and \"solid fill\" [[RenderMode]]s.\n * @public\n */\nexport var HiddenLine;\n(function (HiddenLine) {\n    /** Describes the symbology with which edges should be drawn. */\n    class Style {\n        /** @internal */\n        get ovrColor() { return undefined !== this.color; }\n        constructor(json, hidden) {\n            if (JsonUtils.isEmptyObjectOrUndefined(json)) {\n                if (hidden)\n                    this.pattern = LinePixels.HiddenLine;\n                return;\n            }\n            json = json; // per JsonUtils.isEmptyObjectOrUndefined()\n            if (undefined !== json.color && false !== json.ovrColor)\n                this.color = ColorDef.fromJSON(json.color);\n            if (undefined !== json.pattern) {\n                const pattern = JsonUtils.asInt(json.pattern, hidden ? LinePixels.HiddenLine : LinePixels.Invalid);\n                if (LinePixels.Invalid !== pattern)\n                    this.pattern = pattern;\n            }\n            else if (hidden) {\n                this.pattern = LinePixels.HiddenLine;\n            }\n            if (undefined !== json.width) {\n                let width = JsonUtils.asInt(json.width, 0);\n                if (0 !== width) {\n                    width = Math.max(1, width);\n                    this.width = Math.min(32, width);\n                }\n            }\n        }\n        static fromJSON(json, hidden) {\n            if (undefined !== json)\n                return new Style(json, hidden);\n            return hidden ? this.defaultHidden : this.defaultVisible;\n        }\n        /** Create a Style equivalent to this one but with the specified color override. */\n        overrideColor(color) {\n            if (undefined === this.color && undefined === color)\n                return this;\n            if (undefined !== this.color && undefined !== color && this.color.equals(color))\n                return this;\n            return Style.fromJSON({\n                color: color?.toJSON(),\n                ovrColor: undefined !== color,\n                pattern: this.pattern,\n                width: this.width,\n            });\n        }\n        /** Create a Style equivalent to this one but with the specified pattern override. */\n        overridePattern(pattern) {\n            if (pattern === this.pattern)\n                return this;\n            return Style.fromJSON({\n                color: this.color?.toJSON(),\n                ovrColor: this.ovrColor,\n                pattern,\n                width: this.width,\n            });\n        }\n        /** Create a Style equivalent to this one but with the specified width override. */\n        overrideWidth(width) {\n            if (width === this.width)\n                return this;\n            return Style.fromJSON({\n                color: this.color?.toJSON(),\n                ovrColor: this.ovrColor,\n                pattern: this.pattern,\n                width,\n            });\n        }\n        /** Returns true if this Style is equivalent to the supplied Style. */\n        equals(other) {\n            if (this === other)\n                return true;\n            else if (this.ovrColor !== other.ovrColor || this.pattern !== other.pattern || this.width !== other.width)\n                return false;\n            else\n                return undefined === this.color || this.color.equals(other.color);\n        }\n        toJSON() {\n            return {\n                ovrColor: this.ovrColor,\n                color: this.color ? this.color.toJSON() : ColorDef.white.toJSON(),\n                pattern: undefined !== this.pattern ? this.pattern : LinePixels.Invalid,\n                width: undefined !== this.width ? this.width : 0,\n            };\n        }\n    }\n    Style.defaultVisible = new Style({});\n    Style.defaultHidden = new Style({}, true);\n    HiddenLine.Style = Style;\n    /** Describes how visible and hidden edges and transparent surfaces should be rendered in \"hidden line\" and \"solid fill\" [[RenderMode]]s. */\n    class Settings {\n        /** An alias for [[transparencyThreshold]]. */\n        get transThreshold() { return this.transparencyThreshold; }\n        /** Create a DisplaySettings from its JSON representation. */\n        static fromJSON(json) {\n            if (JsonUtils.isEmptyObjectOrUndefined(json))\n                return this.defaults;\n            else if (json instanceof Settings)\n                return json;\n            else\n                return new Settings(json);\n        }\n        toJSON() {\n            const props = {\n                visible: this.visible.toJSON(),\n                hidden: this.hidden.toJSON(),\n                transThreshold: this.transThreshold,\n            };\n            return props;\n        }\n        /** Create a Settings equivalent to this one with the exception of those properties defined in the supplied JSON. */\n        override(props) {\n            const visible = props.visible;\n            const hidden = props.hidden;\n            const transparencyThreshold = props.transThreshold;\n            return Settings.fromJSON({\n                visible: undefined !== visible ? visible : this.visible.toJSON(),\n                hidden: undefined !== hidden ? hidden : this.hidden.toJSON(),\n                transThreshold: undefined !== transparencyThreshold ? transparencyThreshold : this.transparencyThreshold,\n            });\n        }\n        equals(other) {\n            if (this === other)\n                return true;\n            return this.visible.equals(other.visible)\n                && this.hidden.equals(other.hidden)\n                && this.transparencyThreshold === other.transparencyThreshold;\n        }\n        get matchesDefaults() {\n            return this.equals(Settings.defaults);\n        }\n        constructor(json) {\n            this.visible = Style.fromJSON(json.visible);\n            this.hidden = Style.fromJSON(json.hidden, true);\n            this.transparencyThreshold = JsonUtils.asDouble(json.transThreshold, 1.0);\n        }\n    }\n    /** The default display settings. */\n    Settings.defaults = new Settings({});\n    HiddenLine.Settings = Settings;\n})(HiddenLine || (HiddenLine = {}));\n//# sourceMappingURL=HiddenLine.js.map",
      "start": 1693508120811,
      "end": 1693508120915,
      "sourcemaps": null
    }
  ]
}
