{
  "resolvedId": "D:/hub2023A/itwinjs-core/editor/frontend/lib/esm/SketchTools.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Editing\n */\nimport { DialogProperty, PropertyDescriptionHelper, PropertyEditorParamTypes, } from \"@itwin/appui-abstract\";\nimport { BentleyError } from \"@itwin/core-bentley\";\nimport { Code, ColorDef, ElementGeometry, isPlacement3dProps, LinePixels, } from \"@itwin/core-common\";\nimport { AccuDrawHintBuilder, AngleDescription, BeButton, BeModifierKeys, CoreTools, EventHandled, GraphicType, IModelApp, LengthDescription, NotifyMessageDetails, OutputMessagePriority, TentativeOrAccuSnap, ToolAssistance, ToolAssistanceImage, ToolAssistanceInputMethod, } from \"@itwin/core-frontend\";\nimport { Angle, AngleSweep, Arc3d, BSplineCurve3d, CurveFactory, FrameBuilder, Geometry, IModelJson, InterpolationCurve3d, InterpolationCurve3dOptions, LineString3d, Loop, Matrix3d, Path, Plane3dByOriginAndUnitNormal, Point3d, PointString3d, Ray3d, RegionOps, Transform, Vector3d, YawPitchRollAngles, } from \"@itwin/core-geometry\";\nimport { editorBuiltInCmdIds } from \"@itwin/editor-common\";\nimport { CreateElementWithDynamicsTool } from \"./CreateElementTool\";\nimport { EditTools } from \"./EditTool\";\nimport { basicManipulationIpc } from \"./EditToolIpc\";\n/** @alpha Values for [[CreateOrContinueTool.createCurvePhase] to support join and closure. */\nexport var CreateCurvePhase;\n(function (CreateCurvePhase) {\n    /** Current tool phase changes CurvePrimitive startPoint.\n     * ex. Arc defined by center, start would return this when accepted length is 1.\n     */\n    CreateCurvePhase[CreateCurvePhase[\"DefineStart\"] = 0] = \"DefineStart\";\n    /** Current tool phase changes CurvePrimitive endPoint.\n     * ex. Arc defined by start, end, mid would return this when accepted length is 1.\n     */\n    CreateCurvePhase[CreateCurvePhase[\"DefineEnd\"] = 1] = \"DefineEnd\";\n    /** Current tool phase does NOT change CurvePrimitive startPoint or endPoint.\n     * ex. When defining arc mid point, or start and end tangents for a bcurve return this.\n     */\n    CreateCurvePhase[CreateCurvePhase[\"DefineOther\"] = 2] = \"DefineOther\";\n})(CreateCurvePhase || (CreateCurvePhase = {}));\n/** @alpha Base class for creating open and closed paths. */\nexport class CreateOrContinuePathTool extends CreateElementWithDynamicsTool {\n    constructor() {\n        super(...arguments);\n        this._createCurvePhase = CreateCurvePhase.DefineOther;\n        this.accepted = [];\n        this.isClosed = false;\n        this.isConstruction = false; // Sub-classes can set in createNewCurvePrimitive to bypass creating element graphics...\n    }\n    async startCommand() {\n        if (undefined !== this._startedCmd)\n            return this._startedCmd;\n        return EditTools.startCommand({ commandId: editorBuiltInCmdIds.cmdBasicManipulation, iModelKey: this.iModel.key });\n    }\n    get allowJoin() { return this.isControlDown; }\n    get allowClosure() { return this.isControlDown; }\n    get allowSimplify() { return true; }\n    get wantSmartRotation() { return this.isContinueExistingPath || this.isControlDown; }\n    get wantPickableDynamics() { return false; }\n    get wantJoin() { return this.allowJoin; }\n    get wantClosure() { return this.isContinueExistingPath && this.allowClosure; }\n    get wantSimplify() { return this.allowSimplify; }\n    get showCurveConstructions() { return false; }\n    get showJoin() { return this.isContinueExistingPath && CreateCurvePhase.DefineStart === this.createCurvePhase; }\n    get showClosure() { return this.isClosed && CreateCurvePhase.DefineEnd === this.createCurvePhase; }\n    get createCurvePhase() { return this._createCurvePhase; }\n    /** Sub-classes should override unless they don't support join or closure. */\n    updateCurvePhase() { }\n    getCurrentRotation(ev) {\n        const matrix = (undefined !== ev.viewport ? AccuDrawHintBuilder.getCurrentRotation(ev.viewport, true, true) : undefined);\n        return (undefined !== matrix ? matrix : Matrix3d.createIdentity());\n    }\n    getUpVector(ev) {\n        return this.getCurrentRotation(ev).getColumn(2);\n    }\n    async updateCurveAndContinuationData(ev, isDynamics) {\n        this.isConstruction = false;\n        this.current = this.createNewCurvePrimitive(ev, isDynamics);\n        if (CreateCurvePhase.DefineStart === this.createCurvePhase)\n            await this.isValidForJoin(); // Updates this.continuationData...\n        else if (CreateCurvePhase.DefineEnd === this.createCurvePhase)\n            await this.isValidForClosure(); // Updates this.isClosed...\n    }\n    async updateElementData(ev, isDynamics) {\n        if (!isDynamics)\n            this.accepted.push(ev.point.clone());\n        await this.updateCurveAndContinuationData(ev, isDynamics);\n        if (!isDynamics)\n            this.updateCurvePhase();\n    }\n    async updateDynamicData(ev) {\n        // Need to update continuation data for first data point before dynamics has started...\n        await this.updateCurveAndContinuationData(ev, true);\n        // Don't need to create graphic if dynamics aren't yet active or showing construction geometry...\n        return (IModelApp.viewManager.inDynamicsMode && !this.isConstruction);\n    }\n    get isContinueExistingPath() { return undefined !== this.continuationData; }\n    async isValidForContinue(snap) {\n        if (!snap.isElementHit)\n            return;\n        const snapCurve = snap.getCurvePrimitive();\n        if (undefined === snapCurve)\n            return;\n        const curveS = snapCurve.startPoint();\n        const curveE = snapCurve.endPoint();\n        if (curveS.isAlmostEqual(curveE))\n            return; // Reject snap to single physically closed curve primitive...\n        const snapPt = snap.adjustedPoint;\n        if (!(snapPt.isAlmostEqual(curveS) || snapPt.isAlmostEqual(curveE)))\n            return; // No point to further checks if snap wasn't to endpoint of curve primitive...\n        try {\n            this._startedCmd = await this.startCommand();\n            const info = await basicManipulationIpc.requestElementGeometry(snap.sourceId, { maxDisplayable: 1, geometry: { curves: true, surfaces: false, solids: false } });\n            if (undefined === info)\n                return;\n            const data = CreateOrContinuePathTool.isSingleOpenPath(info);\n            if (undefined === data)\n                return;\n            const props = await this.iModel.elements.loadProps(snap.sourceId);\n            if (undefined === props)\n                return;\n            return { props, path: data.path, params: data.params };\n        }\n        catch (err) {\n            IModelApp.notifications.outputMessage(new NotifyMessageDetails(OutputMessagePriority.Error, BentleyError.getErrorMessage(err) || \"An unknown error occurred.\"));\n            return;\n        }\n    }\n    async isValidForJoin() {\n        this.continuationData = undefined;\n        if (!this.wantJoin)\n            return false;\n        if (undefined === this.current)\n            return false;\n        const snap = TentativeOrAccuSnap.getCurrentSnap();\n        if (undefined === snap)\n            return false;\n        const data = await this.isValidForContinue(snap);\n        if (undefined === data)\n            return false;\n        if (!CreateOrContinuePathTool.isPathEndPoint(this.current, data.path))\n            return false;\n        this.continuationData = data;\n        return true;\n    }\n    async isValidForClosure() {\n        this.isClosed = false;\n        if (!this.wantClosure)\n            return false;\n        if (undefined === this.current)\n            return false;\n        return (this.isClosed = CreateOrContinuePathTool.isPathClosurePoint(this.current, this.continuationData?.path));\n    }\n    static isSingleOpenPath(info) {\n        const it = new ElementGeometry.Iterator(info);\n        it.requestWorldCoordinates();\n        for (const entry of it) {\n            const geom = entry.toGeometryQuery();\n            if (undefined === geom)\n                return;\n            if (\"curvePrimitive\" === geom.geometryCategory) {\n                const curve = geom;\n                const curveS = curve.startPoint();\n                const curveE = curve.endPoint();\n                if (curveS.isAlmostEqual(curveE))\n                    return; // Reject zero length lines, physically closed arcs, linestrings, etc...\n                return { path: Path.create(curve), params: entry.geomParams };\n            }\n            else if (\"curveCollection\" === geom.geometryCategory) {\n                const curves = geom;\n                if (!curves.isOpenPath)\n                    return;\n                const path = curves;\n                const curveS = path.children[0].startPoint();\n                const curveE = path.children[path.children.length - 1].endPoint();\n                if (curveS.isAlmostEqual(curveE))\n                    return; // Reject physically closed path...\n                return { path, params: entry.geomParams };\n            }\n            break;\n        }\n        return;\n    }\n    static isPathEndPoint(curve, path) {\n        const curveS = curve.startPoint();\n        const pathS = path.children[0].startPoint();\n        const pathE = path.children[path.children.length - 1].endPoint();\n        if (!(curveS.isAlmostEqual(pathS) || curveS.isAlmostEqual(pathE)))\n            return false;\n        return true;\n    }\n    static isPathClosurePoint(curve, path) {\n        const length = curve.quickLength();\n        if (length < Geometry.smallMetricDistance)\n            return false;\n        const curveS = curve.startPoint();\n        const curveE = curve.endPoint();\n        if (undefined === path) {\n            if (!curveS.isAlmostEqual(curveE))\n                return false;\n            const curveLocalToWorld = FrameBuilder.createRightHandedFrame(undefined, curve);\n            if (undefined === curveLocalToWorld)\n                return false;\n            // Don't create a Loop unless new CurvePrimitive is planar...\n            const curvePlane = Plane3dByOriginAndUnitNormal.create(curveLocalToWorld.getOrigin(), curveLocalToWorld.matrix.getColumn(2));\n            return (undefined !== curvePlane && curve.isInPlane(curvePlane));\n        }\n        const pathS = path.children[0].startPoint();\n        const pathE = path.children[path.children.length - 1].endPoint();\n        if (!(curveS.isAlmostEqual(pathS) && curveE.isAlmostEqual(pathE) || curveS.isAlmostEqual(pathE) && curveE.isAlmostEqual(pathS)))\n            return false;\n        const pathLocalToWorld = FrameBuilder.createRightHandedFrame(undefined, [curve, path]);\n        if (undefined === pathLocalToWorld)\n            return false;\n        // Don't create a Loop unless new CurvePrimitive + existing Path is planar...\n        const pathPlane = Plane3dByOriginAndUnitNormal.create(pathLocalToWorld.getOrigin(), pathLocalToWorld.matrix.getColumn(2));\n        if (undefined === pathPlane)\n            return false;\n        if (!curve.isInPlane(pathPlane))\n            return false;\n        for (const child of path.children) {\n            if (!child.isInPlane(pathPlane))\n                return false;\n        }\n        return true;\n    }\n    addConstructionGraphics(curve, showCurve, context) {\n        if (!showCurve) {\n            switch (curve.curvePrimitiveType) {\n                case \"arc\":\n                case \"bsplineCurve\":\n                case \"interpolationCurve\":\n                    break;\n                default:\n                    return;\n            }\n        }\n        const builder = context.createGraphic({ type: GraphicType.WorldOverlay });\n        builder.setSymbology(context.viewport.getContrastToBackgroundColor(), ColorDef.black, 1, LinePixels.Code2);\n        if (showCurve)\n            builder.addPath(Path.create(curve));\n        switch (curve.curvePrimitiveType) {\n            case \"arc\": {\n                const arc = curve;\n                const start = arc.startPoint();\n                const end = arc.endPoint();\n                builder.addLineString([arc.center, start]);\n                if (!start.isAlmostEqual(end))\n                    builder.addLineString([arc.center, end]);\n                builder.setSymbology(context.viewport.getContrastToBackgroundColor(), ColorDef.black, 5);\n                builder.addPointString([arc.center]);\n                break;\n            }\n            case \"bsplineCurve\": {\n                const bcurve = curve;\n                const poles = [];\n                for (let iPole = 0; iPole < bcurve.numPoles; ++iPole) {\n                    const polePt = bcurve.getPolePoint3d(iPole);\n                    if (undefined !== polePt)\n                        poles.push(polePt);\n                }\n                builder.addLineString(poles);\n                builder.setSymbology(context.viewport.getContrastToBackgroundColor(), ColorDef.black, 5);\n                builder.addPointString(poles);\n                break;\n            }\n            case \"interpolationCurve\": {\n                const fitCurve = curve;\n                builder.setSymbology(context.viewport.getContrastToBackgroundColor(), ColorDef.black, 5);\n                builder.addPointString(fitCurve.options.fitPoints); // deep copy shoulnd't be necessary...\n                break;\n            }\n            default:\n                break;\n        }\n        context.addGraphic(builder.finish());\n    }\n    showConstructionGraphics(_ev, context) {\n        if (undefined === this.current)\n            return false;\n        if (!this.isConstruction) {\n            if (this.showCurveConstructions)\n                this.addConstructionGraphics(this.current, false, context);\n            return false;\n        }\n        this.addConstructionGraphics(this.current, true, context);\n        return true;\n    }\n    onDynamicFrame(ev, context) {\n        if (this.showConstructionGraphics(ev, context))\n            return; // Don't display element graphics...\n        super.onDynamicFrame(ev, context);\n    }\n    showJoinIndicator(context, pt) {\n        const lengthX = Math.floor(context.viewport.pixelsFromInches(0.08)) + 0.5;\n        const lengthY = Math.floor(lengthX * 0.6) + 0.5;\n        const offsetX = lengthX * 3;\n        const offsetY = lengthY * 3;\n        const position = context.viewport.worldToView(pt);\n        position.x = Math.floor(position.x - offsetX) + 0.5;\n        position.y = Math.floor(position.y + offsetY) + 0.5;\n        const drawDecoration = (ctx) => {\n            ctx.beginPath();\n            ctx.strokeStyle = \"rgba(0,0,0,.8)\";\n            ctx.lineWidth = 3;\n            ctx.lineCap = \"round\";\n            ctx.moveTo(-lengthX, lengthY);\n            ctx.lineTo(0, lengthY);\n            ctx.lineTo(0, -lengthY);\n            ctx.lineTo(lengthX, -lengthY);\n            ctx.stroke();\n            ctx.beginPath();\n            ctx.strokeStyle = \"rgba(255,255,255,.8)\";\n            ctx.lineWidth = 1;\n            ctx.moveTo(-lengthX, lengthY);\n            ctx.lineTo(0, lengthY);\n            ctx.lineTo(0, -lengthY);\n            ctx.lineTo(lengthX, -lengthY);\n            ctx.stroke();\n            ctx.beginPath();\n            ctx.strokeStyle = \"rgba(0,0,0,.8)\";\n            ctx.fillStyle = \"rgba(0,255,255,.8)\";\n            ctx.arc(0, -lengthY, 2.5, 0, 2 * Math.PI);\n            ctx.fill();\n            ctx.stroke();\n        };\n        context.addCanvasDecoration({ position, drawDecoration }, true);\n    }\n    showClosureIndicator(context, pt) {\n        const radius = Math.floor(context.viewport.pixelsFromInches(0.06)) + 0.5;\n        const offset = radius * 2.5;\n        const position = context.viewport.worldToView(pt);\n        position.x = Math.floor(position.x - offset) + 0.5;\n        position.y = Math.floor(position.y + offset) + 0.5;\n        const drawDecoration = (ctx) => {\n            ctx.beginPath();\n            ctx.strokeStyle = \"rgba(255,255,255,.8)\";\n            ctx.lineWidth = 1;\n            ctx.fillStyle = \"rgba(0,0,255,.2)\";\n            ctx.arc(0, 0, radius, 0, 2 * Math.PI);\n            ctx.fill();\n            ctx.stroke();\n            ctx.beginPath();\n            ctx.strokeStyle = \"rgba(0,0,0,.8)\";\n            ctx.arc(0, 0, radius + 1, 0, 2 * Math.PI);\n            ctx.stroke();\n            ctx.beginPath();\n            ctx.strokeStyle = \"rgba(0,0,0,.8)\";\n            ctx.fillStyle = \"rgba(0,255,255,.8)\";\n            ctx.arc(-radius, 0, 2.5, 0, 2 * Math.PI);\n            ctx.fill();\n            ctx.stroke();\n        };\n        context.addCanvasDecoration({ position, drawDecoration }, true);\n    }\n    testDecorationHit(id) {\n        return id === this._snapGeomId;\n    }\n    async getToolTip(hit) {\n        if (this.testDecorationHit(hit.sourceId))\n            return this.description;\n        return super.getToolTip(hit);\n    }\n    getSnapGeometry() {\n        if (this.accepted.length < 2)\n            return;\n        // Treat accepted points as linear segments by default...\n        return LineString3d.create(this.accepted);\n    }\n    getDecorationGeometry(_hit) {\n        const geomQuery = this.getSnapGeometry();\n        if (undefined === geomQuery)\n            return;\n        const geomJson = IModelJson.Writer.toIModelJson(geomQuery);\n        return geomJson ? [geomJson] : undefined;\n    }\n    addPickableGraphics(context) {\n        const geomQuery = this.getSnapGeometry();\n        if (undefined === geomQuery)\n            return;\n        if (undefined === this._snapGeomId)\n            this._snapGeomId = this.iModel.transientIds.getNext();\n        const builder = context.createGraphic({ type: GraphicType.WorldDecoration, pickable: { id: this._snapGeomId, locateOnly: true } });\n        builder.setSymbology(ColorDef.white, ColorDef.white, 1);\n        switch (geomQuery.geometryCategory) {\n            case \"pointCollection\": {\n                const pointString = geomQuery;\n                builder.addPointString(pointString.points);\n                break;\n            }\n            case \"curvePrimitive\": {\n                const curvePrimitive = geomQuery;\n                switch (curvePrimitive.curvePrimitiveType) {\n                    case \"lineString\": {\n                        const lineString = geomQuery;\n                        builder.addLineString(lineString.points);\n                        break;\n                    }\n                    default:\n                        return; // Don't need to support other types of CurvePrimitive currently...\n                }\n                break;\n            }\n            default:\n                return; // Don't need to support other types of GeometryQuery currently...\n        }\n        context.addDecorationFromBuilder(builder);\n    }\n    decorate(context) {\n        if (this.wantPickableDynamics)\n            this.addPickableGraphics(context);\n        if (undefined === this.current)\n            return;\n        if (this.showJoin)\n            this.showJoinIndicator(context, this.current.startPoint());\n        else if (this.showClosure)\n            this.showClosureIndicator(context, this.current.endPoint());\n    }\n    async onModifierKeyTransition(_wentDown, modifier, _event) {\n        if (BeModifierKeys.Control !== modifier)\n            return EventHandled.No;\n        // Update display for join/closure change w/o waiting for a motion event...\n        return EventHandled.Yes;\n    }\n    getPlacementProps() {\n        if (undefined !== this.continuationData)\n            return this.continuationData.props.placement;\n        if (undefined === this.current)\n            return;\n        const vp = this.targetView;\n        if (undefined === vp)\n            return;\n        const matrix = AccuDrawHintBuilder.getCurrentRotation(vp, true, true);\n        const localToWorld = FrameBuilder.createRightHandedFrame(matrix?.getColumn(2), this.current);\n        if (undefined === localToWorld)\n            return;\n        const origin = localToWorld.getOrigin();\n        const angles = new YawPitchRollAngles();\n        YawPitchRollAngles.createFromMatrix3d(localToWorld.matrix, angles);\n        if (vp.view.is3d())\n            return { origin, angles };\n        return { origin, angle: angles.yaw };\n    }\n    createNewPath(placement) {\n        if (undefined === this.current)\n            return;\n        const builder = new ElementGeometry.Builder();\n        builder.setLocalToWorldFromPlacement(placement);\n        const geometry = (this.isClosed ? Loop.create(this.current) : this.current);\n        if (!builder.appendGeometryQuery(geometry))\n            return;\n        return { format: \"flatbuffer\", data: builder.entries };\n    }\n    continueExistingPath(placement) {\n        if (undefined === this.current || undefined === this.continuationData)\n            return;\n        const length = this.current.quickLength();\n        if (length < Geometry.smallMetricDistance)\n            return;\n        const curveS = this.current.startPoint();\n        const pathS = this.continuationData.path.children[0].startPoint();\n        const pathE = this.continuationData.path.children[this.continuationData.path.children.length - 1].endPoint();\n        const append = pathE.isAlmostEqual(curveS);\n        if (!append && !pathS.isAlmostEqual(curveS))\n            return;\n        const continuePath = this.continuationData.path.clone();\n        if (undefined === continuePath)\n            return;\n        const current = this.current.clone();\n        if (undefined === current)\n            return;\n        if (append) {\n            continuePath.tryAddChild(current);\n        }\n        else {\n            current.reverseInPlace();\n            continuePath.children.splice(0, 0, current);\n        }\n        const geometry = (this.isClosed ? Loop.create(...continuePath.children) : continuePath);\n        if (this.wantSimplify)\n            RegionOps.consolidateAdjacentPrimitives(geometry);\n        const builder = new ElementGeometry.Builder();\n        builder.setLocalToWorldFromPlacement(placement);\n        builder.appendGeometryParamsChange(this.continuationData.params);\n        if (!builder.appendGeometryQuery(geometry))\n            return;\n        return { format: \"flatbuffer\", data: builder.entries };\n    }\n    getGeometryProps(placement) {\n        if (this.isContinueExistingPath)\n            return this.continueExistingPath(placement);\n        return this.createNewPath(placement);\n    }\n    getElementProps(placement) {\n        if (undefined !== this.continuationData)\n            return this.continuationData.props;\n        const model = this.targetModelId;\n        const category = this.targetCategory;\n        if (isPlacement3dProps(placement))\n            return { classFullName: \"Generic:PhysicalObject\", model, category, code: Code.createEmpty(), placement };\n        return { classFullName: \"BisCore:DrawingGraphic\", model, category, code: Code.createEmpty(), placement };\n    }\n    async doCreateElement(props, data) {\n        try {\n            this._startedCmd = await this.startCommand();\n            if (undefined === props.id)\n                await basicManipulationIpc.insertGeometricElement(props, data);\n            else\n                await basicManipulationIpc.updateGeometricElement(props, data);\n            await this.saveChanges();\n        }\n        catch (err) {\n            IModelApp.notifications.outputMessage(new NotifyMessageDetails(OutputMessagePriority.Error, BentleyError.getErrorMessage(err) || \"An unknown error occurred.\"));\n        }\n    }\n    setupAccuDraw() {\n        const nPts = this.accepted.length;\n        if (0 === nPts)\n            return;\n        const hints = new AccuDrawHintBuilder();\n        if (this.wantSmartRotation)\n            hints.enableSmartRotation = true;\n        // Rotate AccuDraw to last segment...\n        if (nPts > 1 && !this.accepted[nPts - 1].isAlmostEqual(this.accepted[nPts - 2]))\n            hints.setXAxis(Vector3d.createStartEnd(this.accepted[nPts - 2], this.accepted[nPts - 1]));\n        hints.setOrigin(this.accepted[nPts - 1]);\n        hints.sendHints();\n    }\n    async onUndoPreviousStep() {\n        if (0 === this.accepted.length)\n            return false;\n        this.accepted.pop();\n        if (0 === this.accepted.length) {\n            await this.onReinitialize();\n        }\n        else {\n            this.updateCurvePhase();\n            this.setupAndPromptForNextAction();\n        }\n        return true;\n    }\n    async onPostInstall() {\n        await super.onPostInstall();\n        this.updateCurvePhase();\n    }\n}\n/** @alpha Creates a line string or shape. Uses model and category from [[BriefcaseConnection.editorToolSettings]]. */\nclass CreateLineStringTool extends CreateOrContinuePathTool {\n    get wantPickableDynamics() { return true; } // Allow snapping to accepted segments...\n    provideToolAssistance(_mainInstrText, _additionalInstr) {\n        const nPts = this.accepted.length;\n        const mainMsg = CoreTools.translate(0 === nPts ? \"ElementSet.Prompts.StartPoint\" : (1 === nPts ? \"ElementSet.Prompts.EndPoint\" : \"ElementSet.Inputs.AdditionalPoint\"));\n        const leftMsg = CoreTools.translate(\"ElementSet.Inputs.AcceptPoint\");\n        const rightMsg = CoreTools.translate(nPts > 1 ? \"ElementSet.Inputs.Complete\" : \"ElementSet.Inputs.Cancel\");\n        const mouseInstructions = [];\n        const touchInstructions = [];\n        if (!ToolAssistance.createTouchCursorInstructions(touchInstructions))\n            touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.OneTouchTap, leftMsg, false, ToolAssistanceInputMethod.Touch));\n        mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.LeftClick, leftMsg, false, ToolAssistanceInputMethod.Mouse));\n        touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.TwoTouchTap, rightMsg, false, ToolAssistanceInputMethod.Touch));\n        mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.RightClick, rightMsg, false, ToolAssistanceInputMethod.Mouse));\n        const sections = [];\n        sections.push(ToolAssistance.createSection(mouseInstructions, ToolAssistance.inputsLabel));\n        sections.push(ToolAssistance.createSection(touchInstructions, ToolAssistance.inputsLabel));\n        const mainInstruction = ToolAssistance.createInstruction(this.iconSpec, mainMsg);\n        const instructions = ToolAssistance.createInstructions(mainInstruction, sections);\n        IModelApp.notifications.setToolAssistance(instructions);\n    }\n    get wantClosure() {\n        // A linestring can support physical closure when creating a new path...\n        return this.allowClosure;\n    }\n    updateCurvePhase() {\n        // The first point changes startPoint and last point changes endPoint.\n        this._createCurvePhase = (0 === this.accepted.length ? CreateCurvePhase.DefineStart : CreateCurvePhase.DefineEnd);\n    }\n    isComplete(ev) {\n        // Accept on reset with at least 2 points...\n        if (BeButton.Reset === ev.button)\n            return (this.accepted.length > 1);\n        // Allow data to complete on physical closure (creates Loop)...\n        return this.isClosed;\n    }\n    createNewCurvePrimitive(ev, isDynamics) {\n        const numRequired = (isDynamics ? 1 : 2);\n        if (this.accepted.length < numRequired) {\n            this.isConstruction = true; // Create zero length line as construction geometry to support join...\n            const pt = (0 !== this.accepted.length ? this.accepted[0] : ev.point);\n            return LineString3d.create([pt, pt]);\n        }\n        const pts = (isDynamics ? [...this.accepted, ev.point] : this.accepted);\n        return LineString3d.create(pts);\n    }\n    async cancelPoint(ev) {\n        // NOTE: Starting another tool will not create element...require reset or closure...\n        if (this.isComplete(ev)) {\n            this._createCurvePhase = CreateCurvePhase.DefineEnd;\n            await this.updateCurveAndContinuationData(ev, false);\n            await this.createElement();\n        }\n        return true;\n    }\n    async onRestartTool() {\n        const tool = new CreateLineStringTool();\n        if (!await tool.run())\n            return this.exitTool();\n    }\n}\nCreateLineStringTool.toolId = \"CreateLineString\";\nCreateLineStringTool.iconSpec = \"icon-snaps\"; // Need better icon...\nexport { CreateLineStringTool };\n/** @alpha */\nexport var ArcMethod;\n(function (ArcMethod) {\n    ArcMethod[ArcMethod[\"CenterStart\"] = 0] = \"CenterStart\";\n    ArcMethod[ArcMethod[\"StartCenter\"] = 1] = \"StartCenter\";\n    ArcMethod[ArcMethod[\"StartMidEnd\"] = 2] = \"StartMidEnd\";\n    ArcMethod[ArcMethod[\"StartEndMid\"] = 3] = \"StartEndMid\";\n})(ArcMethod || (ArcMethod = {}));\n/** @alpha Creates an arc. Uses model and category from [[BriefcaseConnection.editorToolSettings]]. */\nclass CreateArcTool extends CreateOrContinuePathTool {\n    static get minArgs() { return 0; }\n    static get maxArgs() { return 3; } // method, radius, sweep - zero value unlocks associated \"use\" toggle...\n    get showCurveConstructions() { return true; } // Display lines from center to start/end...\n    provideToolAssistance(mainInstrText, additionalInstr) {\n        const nPts = this.accepted.length;\n        switch (this.method) {\n            case ArcMethod.CenterStart:\n                mainInstrText = (0 === nPts ? EditTools.translate(\"CreateArc.Prompts.CenterPoint\") : (1 === nPts ? CoreTools.translate(\"ElementSet.Prompts.StartPoint\") : CoreTools.translate(\"ElementSet.Prompts.EndPoint\")));\n                break;\n            case ArcMethod.StartCenter:\n                mainInstrText = (0 === nPts ? CoreTools.translate(\"ElementSet.Prompts.StartPoint\") : (1 === nPts ? EditTools.translate(\"CreateArc.Prompts.CenterPoint\") : CoreTools.translate(\"ElementSet.Prompts.EndPoint\")));\n                break;\n            case ArcMethod.StartMidEnd:\n                mainInstrText = (0 === nPts ? CoreTools.translate(\"ElementSet.Prompts.StartPoint\") : (1 === nPts ? EditTools.translate(\"CreateArc.Prompts.MidPoint\") : CoreTools.translate(\"ElementSet.Prompts.EndPoint\")));\n                break;\n            case ArcMethod.StartEndMid:\n                mainInstrText = (0 === nPts ? CoreTools.translate(\"ElementSet.Prompts.StartPoint\") : (1 === nPts ? CoreTools.translate(\"ElementSet.Prompts.EndPoint\") : EditTools.translate(\"CreateArc.Prompts.MidPoint\")));\n                break;\n        }\n        super.provideToolAssistance(mainInstrText, additionalInstr);\n    }\n    setupAccuDraw() {\n        const nPts = this.accepted.length;\n        if (0 === nPts)\n            return;\n        const hints = new AccuDrawHintBuilder();\n        if (this.wantSmartRotation)\n            hints.enableSmartRotation = true;\n        switch (this.accepted.length) {\n            case 1:\n                hints.setOrigin(this.accepted[0]);\n                if (ArcMethod.CenterStart !== this.method)\n                    break;\n                hints.setOriginFixed = true;\n                hints.setModePolar();\n                break;\n            case 2:\n                switch (this.method) {\n                    case ArcMethod.CenterStart:\n                        if (!this.accepted[0].isAlmostEqual(this.accepted[1]))\n                            hints.setXAxis(Vector3d.createStartEnd(this.accepted[0], this.accepted[1])); // Rotate AccuDraw to major axis...\n                        break;\n                    case ArcMethod.StartCenter:\n                        let center = this.accepted[1];\n                        const start = this.accepted[0];\n                        const vector0 = center.unitVectorTo(start);\n                        if (undefined === vector0)\n                            break;\n                        if (this.useRadius)\n                            center = start.plusScaled(vector0, -this.radius);\n                        hints.setOrigin(center);\n                        hints.setOriginFixed = true;\n                        hints.setModePolar();\n                        hints.setXAxis(vector0);\n                        break;\n                    default:\n                        hints.setOrigin(this.accepted[1]);\n                        break;\n                }\n                break;\n        }\n        hints.sendHints();\n    }\n    static methodMessage(str) { return EditTools.translate(`CreateArc.Method.${str}`); }\n    get methodProperty() {\n        if (!this._methodProperty)\n            this._methodProperty = new DialogProperty(PropertyDescriptionHelper.buildEnumPicklistEditorDescription(\"arcMethod\", EditTools.translate(\"CreateArc.Label.Method\"), CreateArcTool.getMethodChoices()), ArcMethod.StartCenter);\n        return this._methodProperty;\n    }\n    get method() { return this.methodProperty.value; }\n    set method(method) { this.methodProperty.value = method; }\n    get useRadiusProperty() {\n        if (!this._useRadiusProperty)\n            this._useRadiusProperty = new DialogProperty(PropertyDescriptionHelper.buildLockPropertyDescription(\"useArcRadius\"), false);\n        return this._useRadiusProperty;\n    }\n    get useRadius() { return this.useRadiusProperty.value; }\n    set useRadius(value) { this.useRadiusProperty.value = value; }\n    get radiusProperty() {\n        if (!this._radiusProperty)\n            this._radiusProperty = new DialogProperty(new LengthDescription(\"arcRadius\", EditTools.translate(\"CreateArc.Label.Radius\")), 0.1, undefined, !this.useRadius);\n        return this._radiusProperty;\n    }\n    get radius() { return this.radiusProperty.value; }\n    set radius(value) { this.radiusProperty.value = value; }\n    get useSweepProperty() {\n        if (!this._useSweepProperty)\n            this._useSweepProperty = new DialogProperty(PropertyDescriptionHelper.buildLockPropertyDescription(\"useArcSweep\"), false);\n        return this._useSweepProperty;\n    }\n    get useSweep() { return this.useSweepProperty.value; }\n    set useSweep(value) { this.useSweepProperty.value = value; }\n    get sweepProperty() {\n        if (!this._sweepProperty)\n            this._sweepProperty = new DialogProperty(new AngleDescription(\"arcSweep\", EditTools.translate(\"CreateArc.Label.Sweep\")), Math.PI / 2.0, undefined, !this.useSweep);\n        return this._sweepProperty;\n    }\n    get sweep() { return this.sweepProperty.value; }\n    set sweep(value) { this.sweepProperty.value = value; }\n    isComplete(_ev) {\n        return (3 === this.accepted.length);\n    }\n    updateCurvePhase() {\n        switch (this.accepted.length) {\n            case 0:\n                this._createCurvePhase = ArcMethod.CenterStart === this.method ? CreateCurvePhase.DefineOther : CreateCurvePhase.DefineStart;\n                break;\n            case 1:\n                if (ArcMethod.CenterStart === this.method)\n                    this._createCurvePhase = CreateCurvePhase.DefineStart;\n                else if (ArcMethod.StartEndMid === this.method)\n                    this._createCurvePhase = CreateCurvePhase.DefineEnd;\n                else\n                    this._createCurvePhase = CreateCurvePhase.DefineOther;\n                break;\n            default:\n                this._createCurvePhase = ArcMethod.StartEndMid === this.method ? CreateCurvePhase.DefineOther : CreateCurvePhase.DefineEnd;\n                break;\n        }\n    }\n    createConstructionCurve(ev, isDynamics) {\n        switch (this.accepted.length) {\n            case 0: {\n                if (ArcMethod.CenterStart === this.method)\n                    return undefined;\n                return LineString3d.create([ev.point, ev.point]);\n            }\n            case 1: {\n                const pt1 = this.accepted[0];\n                const pt2 = (isDynamics ? ev.point : pt1);\n                switch (this.method) {\n                    case ArcMethod.CenterStart:\n                    case ArcMethod.StartCenter: {\n                        if (pt1.isAlmostEqual(pt2))\n                            return (ArcMethod.StartCenter === this.method ? LineString3d.create([pt1, pt2]) : undefined);\n                        let center = (ArcMethod.CenterStart === this.method ? pt1 : pt2);\n                        const start = (ArcMethod.CenterStart === this.method ? pt2 : pt1);\n                        const normal = this.getUpVector(ev);\n                        const vector0 = Vector3d.createStartEnd(center, start);\n                        const vector90 = normal.crossProduct(vector0);\n                        const radius = (this.useRadius ? this.radius : vector0.magnitude());\n                        if (this.useRadius) {\n                            if (ArcMethod.StartCenter === this.method) {\n                                vector0.normalizeInPlace();\n                                center = start.plusScaled(vector0, -radius);\n                            }\n                        }\n                        else {\n                            this.radius = radius;\n                            this.syncToolSettingsRadiusAndSweep();\n                        }\n                        vector0.scaleToLength(radius, vector0);\n                        vector90.scaleToLength(radius, vector90);\n                        return Arc3d.create(center, vector0, vector90);\n                    }\n                    case ArcMethod.StartMidEnd:\n                    case ArcMethod.StartEndMid: {\n                        return LineString3d.create([pt1, pt2]);\n                    }\n                    default:\n                        return undefined;\n                }\n            }\n            case 2: {\n                switch (this.method) {\n                    case ArcMethod.CenterStart:\n                        return LineString3d.create([this.accepted[1], this.accepted[0]]);\n                    case ArcMethod.StartCenter:\n                    case ArcMethod.StartMidEnd:\n                    case ArcMethod.StartEndMid:\n                        return LineString3d.create([this.accepted[0], this.accepted[1]]);\n                    default:\n                        return undefined;\n                }\n            }\n            default:\n                return undefined;\n        }\n    }\n    createNewCurvePrimitive(ev, isDynamics) {\n        const numRequired = (isDynamics ? 2 : 3);\n        if (this.accepted.length < numRequired) {\n            this.isConstruction = true; // Create construction geometry to support join...\n            return this.createConstructionCurve(ev, isDynamics);\n        }\n        const final = (isDynamics ? ev.point : this.accepted[2]);\n        const start = (ArcMethod.CenterStart === this.method ? this.accepted[1] : this.accepted[0]);\n        const end = (ArcMethod.StartEndMid === this.method ? this.accepted[1] : final);\n        switch (this.method) {\n            case ArcMethod.CenterStart:\n            case ArcMethod.StartCenter:\n                let center = (ArcMethod.CenterStart === this.method ? this.accepted[0] : this.accepted[1]);\n                if (center.isAlmostEqual(start))\n                    return undefined; // Don't create 0 radius arc...\n                const vector0 = Vector3d.createStartEnd(center, start);\n                const vector90 = Vector3d.create();\n                const radius = (this.useRadius ? this.radius : vector0.magnitude());\n                const sweep = Angle.createRadians(this.useSweep ? this.sweep : Angle.pi2Radians);\n                if (this.useRadius) {\n                    if (ArcMethod.StartCenter === this.method) {\n                        vector0.normalizeInPlace();\n                        center = start.plusScaled(vector0, -radius);\n                    }\n                }\n                else {\n                    this.radius = radius;\n                }\n                let defaultArc = (undefined !== this.current && \"arc\" === this.current.curvePrimitiveType ? this.current : undefined);\n                if (undefined === defaultArc) {\n                    this.getUpVector(ev).crossProduct(vector0, vector90);\n                    vector0.scaleToLength(radius, vector0);\n                    vector90.scaleToLength(radius, vector90);\n                    // Create default arc that follows continuation path start/end tangent...\n                    if (undefined !== this.continuationData) {\n                        const pathS = this.continuationData.path.children[0].startPoint();\n                        if (start.isAlmostEqual(pathS)) {\n                            const tangentS = this.continuationData.path.children[0].fractionToPointAndUnitTangent(0.0);\n                            if (vector90.dotProduct(tangentS.direction) > 0.0)\n                                sweep.setRadians(-sweep.radians);\n                        }\n                        else {\n                            const tangentE = this.continuationData.path.children[this.continuationData.path.children.length - 1].fractionToPointAndUnitTangent(1.0);\n                            if (vector90.dotProduct(tangentE.direction) < 0.0)\n                                sweep.setRadians(-sweep.radians);\n                        }\n                    }\n                    defaultArc = Arc3d.create(center, vector0, vector90, AngleSweep.create(sweep));\n                }\n                // Don't have well defined minor axis, continue using previous or default arc...\n                if (start.isAlmostEqual(end))\n                    return defaultArc;\n                const prevSweep = Angle.createRadians(defaultArc.sweep.sweepRadians);\n                Vector3d.createStartEnd(center, end, vector90);\n                sweep.setFrom(vector0.planarAngleTo(vector90, defaultArc.perpendicularVector));\n                defaultArc.perpendicularVector.crossProduct(vector0, vector90);\n                vector0.scaleToLength(radius, vector0);\n                vector90.scaleToLength(radius, vector90);\n                if (Math.abs(sweep.radians) < Angle.createDegrees(30.0).radians && prevSweep.isFullCircle && ((sweep.radians < 0.0 && prevSweep.radians > 0.0) || (sweep.radians > 0.0 && prevSweep.radians < 0.0)))\n                    prevSweep.setRadians(-prevSweep.radians); // Reverse direction...\n                if (sweep.isAlmostZero)\n                    sweep.setDegrees(prevSweep.radians < 0.0 ? -360.0 : 360.0); // Create full sweep...\n                if (this.useSweep) {\n                    if ((sweep.radians < 0.0 && this.sweep > 0.0) || (sweep.radians > 0.0 && this.sweep < 0.0))\n                        sweep.setRadians(-this.sweep);\n                    else\n                        sweep.setRadians(this.sweep);\n                }\n                else {\n                    if (sweep.radians < 0.0 && prevSweep.radians > 0.0)\n                        sweep.setRadians(Angle.pi2Radians + sweep.radians);\n                    else if (sweep.radians > 0.0 && prevSweep.radians < 0.0)\n                        sweep.setRadians(-(Angle.pi2Radians - sweep.radians));\n                    this.sweep = sweep.radians;\n                }\n                if (!this.useRadius || !this.useSweep)\n                    this.syncToolSettingsRadiusAndSweep();\n                return Arc3d.create(center, vector0, vector90, AngleSweep.create(sweep));\n            case ArcMethod.StartMidEnd:\n            case ArcMethod.StartEndMid:\n                const mid = (ArcMethod.StartEndMid === this.method ? final : this.accepted[1]);\n                return Arc3d.createCircularStartMiddleEnd(start, mid, end);\n        }\n    }\n    syncToolSettingsRadiusAndSweep() {\n        switch (this.method) {\n            case ArcMethod.CenterStart:\n            case ArcMethod.StartCenter:\n                if (this.useRadius && this.useSweep)\n                    return;\n                break;\n            default:\n                return;\n        }\n        const syncData = [];\n        if (!this.useRadius)\n            syncData.push(this.radiusProperty.syncItem);\n        if (!this.useSweep)\n            syncData.push(this.sweepProperty.syncItem);\n        if (0 !== syncData.length)\n            this.syncToolSettingsProperties(syncData);\n    }\n    getToolSettingPropertyLocked(property) {\n        if (property === this.useRadiusProperty)\n            return this.radiusProperty;\n        else if (property === this.useSweepProperty)\n            return this.sweepProperty;\n        return undefined;\n    }\n    async applyToolSettingPropertyChange(updatedValue) {\n        if (!this.changeToolSettingPropertyValue(updatedValue))\n            return false;\n        if (this.methodProperty.name === updatedValue.propertyName)\n            await this.onReinitialize();\n        else if (updatedValue.propertyName === this.radiusProperty.name && ArcMethod.StartCenter === this.method && this.useRadius && 2 === this.accepted.length)\n            await this.onUndoPreviousStep(); // If radius is changed when creating arc by start/center after center has been defined, back up a step to defined a new center point...\n        return true;\n    }\n    supplyToolSettingsProperties() {\n        const toolSettings = new Array();\n        toolSettings.push(this.methodProperty.toDialogItem({ rowPriority: 1, columnIndex: 0 }));\n        if (ArcMethod.CenterStart === this.method || ArcMethod.StartCenter === this.method) {\n            // ensure controls are enabled/disabled base on current lock property state\n            this.radiusProperty.isDisabled = !this.useRadius;\n            this.sweepProperty.isDisabled = !this.useSweep;\n            const useRadiusLock = this.useRadiusProperty.toDialogItem({ rowPriority: 2, columnIndex: 0 });\n            const useSweepLock = this.useSweepProperty.toDialogItem({ rowPriority: 3, columnIndex: 0 });\n            toolSettings.push(this.radiusProperty.toDialogItem({ rowPriority: 2, columnIndex: 1 }, useRadiusLock));\n            toolSettings.push(this.sweepProperty.toDialogItem({ rowPriority: 3, columnIndex: 1 }, useSweepLock));\n        }\n        return toolSettings;\n    }\n    async onRestartTool() {\n        const tool = new CreateArcTool();\n        if (!await tool.run())\n            return this.exitTool();\n    }\n    async onInstall() {\n        if (!await super.onInstall())\n            return false;\n        // Setup initial values here instead of supplyToolSettingsProperties to support keyin args w/o appui-react...\n        this.initializeToolSettingPropertyValues([this.methodProperty, this.radiusProperty, this.useRadiusProperty, this.sweepProperty, this.useSweepProperty]);\n        if (!this.radius)\n            this.useRadius = false;\n        if (!this.sweep)\n            this.useSweep = false;\n        return true;\n    }\n    /** The keyin takes the following arguments, all of which are optional:\n     *  - `method=0|1|2|3` How arc will be defined. 0 for center/start, 1 for start/center, 2 for start/mid/end, and 3 for start/end/mid.\n     *  - `radius=number` Arc radius for start/center or center/start, 0 to define by points.\n     *  - `sweep=number` Arc sweep angle in degrees for start/center or center/start, 0 to define by points.\n     */\n    async parseAndRun(...inputArgs) {\n        let arcMethod;\n        let arcRadius;\n        let arcSweep;\n        for (const arg of inputArgs) {\n            const parts = arg.split(\"=\");\n            if (2 !== parts.length)\n                continue;\n            if (parts[0].toLowerCase().startsWith(\"me\")) {\n                const method = Number.parseInt(parts[1], 10);\n                if (!Number.isNaN(method)) {\n                    switch (method) {\n                        case 0:\n                            arcMethod = ArcMethod.CenterStart;\n                            break;\n                        case 1:\n                            arcMethod = ArcMethod.StartCenter;\n                            break;\n                        case 2:\n                            arcMethod = ArcMethod.StartMidEnd;\n                            break;\n                        case 3:\n                            arcMethod = ArcMethod.StartEndMid;\n                            break;\n                    }\n                }\n            }\n            else if (parts[0].toLowerCase().startsWith(\"ra\")) {\n                const radius = Number.parseFloat(parts[1]);\n                if (!Number.isNaN(radius)) {\n                    arcRadius = radius;\n                }\n            }\n            else if (parts[0].toLowerCase().startsWith(\"sw\")) {\n                const sweep = Number.parseFloat(parts[1]);\n                if (!Number.isNaN(sweep)) {\n                    arcSweep = Angle.createDegrees(sweep).radians;\n                }\n            }\n        }\n        // Update current session values so keyin args are picked up for tool settings/restart...\n        if (undefined !== arcMethod)\n            this.saveToolSettingPropertyValue(this.methodProperty, { value: arcMethod });\n        if (undefined !== arcRadius) {\n            if (0.0 !== arcRadius)\n                this.saveToolSettingPropertyValue(this.radiusProperty, { value: arcRadius });\n            this.saveToolSettingPropertyValue(this.useRadiusProperty, { value: 0.0 !== arcRadius });\n        }\n        if (undefined !== arcSweep) {\n            if (0.0 !== arcSweep)\n                this.saveToolSettingPropertyValue(this.sweepProperty, { value: arcSweep });\n            this.saveToolSettingPropertyValue(this.useSweepProperty, { value: 0.0 !== arcSweep });\n        }\n        return this.run();\n    }\n}\nCreateArcTool.toolId = \"CreateArc\";\nCreateArcTool.iconSpec = \"icon-three-points-circular-arc\";\nCreateArcTool.getMethodChoices = () => {\n    return [\n        { label: CreateArcTool.methodMessage(\"CenterStart\"), value: ArcMethod.CenterStart },\n        { label: CreateArcTool.methodMessage(\"StartCenter\"), value: ArcMethod.StartCenter },\n        { label: CreateArcTool.methodMessage(\"StartMidEnd\"), value: ArcMethod.StartMidEnd },\n        { label: CreateArcTool.methodMessage(\"StartEndMid\"), value: ArcMethod.StartEndMid },\n    ];\n};\nexport { CreateArcTool };\n/** @alpha */\nexport var CircleMethod;\n(function (CircleMethod) {\n    CircleMethod[CircleMethod[\"Center\"] = 0] = \"Center\";\n    CircleMethod[CircleMethod[\"Edge\"] = 1] = \"Edge\";\n})(CircleMethod || (CircleMethod = {}));\n/** @alpha Creates a circle. Uses model and category from [[BriefcaseConnection.editorToolSettings]]. */\nclass CreateCircleTool extends CreateOrContinuePathTool {\n    static get minArgs() { return 0; }\n    static get maxArgs() { return 2; } // method, radius - zero value unlocks associated \"use\" toggle...\n    get showCurveConstructions() { return !(CircleMethod.Center === this.method && this.useRadius); }\n    provideToolAssistance(mainInstrText, additionalInstr) {\n        const nPts = this.accepted.length;\n        switch (this.method) {\n            case CircleMethod.Center:\n                mainInstrText = EditTools.translate(0 === nPts ? \"CreateCircle.Prompts.CenterPoint\" : \"CreateCircle.Prompts.EdgePoint\");\n                break;\n            case CircleMethod.Edge:\n                mainInstrText = EditTools.translate(0 === nPts ? \"CreateCircle.Prompts.EdgePoint\" : \"CreateCircle.Prompts.CenterPoint\");\n                break;\n        }\n        super.provideToolAssistance(mainInstrText, additionalInstr);\n    }\n    setupAccuDraw() {\n        const nPts = this.accepted.length;\n        if (0 === nPts)\n            return;\n        const hints = new AccuDrawHintBuilder();\n        if (this.wantSmartRotation)\n            hints.enableSmartRotation = true;\n        if (CircleMethod.Center === this.method && 1 === this.accepted.length) {\n            hints.setOrigin(this.accepted[0]);\n            hints.setOriginFixed = true;\n            hints.setModePolar();\n        }\n        hints.sendHints();\n    }\n    static methodMessage(str) { return EditTools.translate(`CreateCircle.Method.${str}`); }\n    get methodProperty() {\n        if (!this._methodProperty)\n            this._methodProperty = new DialogProperty(PropertyDescriptionHelper.buildEnumPicklistEditorDescription(\"circleMethod\", EditTools.translate(\"CreateCircle.Label.Method\"), CreateCircleTool.getMethodChoices()), CircleMethod.Center);\n        return this._methodProperty;\n    }\n    get method() { return this.methodProperty.value; }\n    set method(method) { this.methodProperty.value = method; }\n    get useRadiusProperty() {\n        if (!this._useRadiusProperty)\n            this._useRadiusProperty = new DialogProperty(PropertyDescriptionHelper.buildLockPropertyDescription(\"useCircleRadius\"), false);\n        return this._useRadiusProperty;\n    }\n    get useRadius() { return this.useRadiusProperty.value; }\n    set useRadius(value) { this.useRadiusProperty.value = value; }\n    get radiusProperty() {\n        if (!this._radiusProperty)\n            this._radiusProperty = new DialogProperty(new LengthDescription(\"circleRadius\", EditTools.translate(\"CreateCircle.Label.Radius\")), 0.1, undefined, !this.useRadius);\n        return this._radiusProperty;\n    }\n    get radius() { return this.radiusProperty.value; }\n    set radius(value) { this.radiusProperty.value = value; }\n    isComplete(_ev) {\n        if (CircleMethod.Center === this.method && this.useRadius)\n            return (this.accepted.length >= 1); // Could be 2 if radius locked after 1st data point...\n        return (2 === this.accepted.length);\n    }\n    createNewCurvePrimitive(ev, isDynamics) {\n        this.isClosed = true; // Always closed...\n        const numRequired = (isDynamics ? 1 : 2);\n        if (this.accepted.length < numRequired) {\n            if (CircleMethod.Center === this.method && this.useRadius)\n                return Arc3d.createCenterNormalRadius(isDynamics ? ev.point : this.accepted[0], this.getUpVector(ev), this.radius);\n            return undefined;\n        }\n        const pt1 = this.accepted[0];\n        const pt2 = (isDynamics ? ev.point : this.accepted[1]);\n        let center = (CircleMethod.Center === this.method ? pt1 : pt2);\n        const edge = (CircleMethod.Center === this.method ? pt2 : pt1);\n        const normal = this.getUpVector(ev);\n        const vector0 = Vector3d.createStartEnd(center, edge);\n        const vector90 = normal.crossProduct(vector0);\n        const radius = (this.useRadius ? this.radius : vector0.magnitude());\n        if (this.useRadius) {\n            if (CircleMethod.Edge === this.method) {\n                vector0.normalizeInPlace();\n                center = edge.plusScaled(vector0, -radius);\n            }\n        }\n        else {\n            this.radius = radius;\n            this.syncToolSettingPropertyValue(this.radiusProperty);\n        }\n        vector0.scaleToLength(radius, vector0);\n        vector90.scaleToLength(radius, vector90);\n        return Arc3d.create(center, vector0, vector90);\n    }\n    async cancelPoint(_ev) {\n        if (CircleMethod.Center === this.method && this.useRadius) {\n            // Exit instead of restarting to avoid having circle \"stuck\" on cursor...\n            await this.exitTool();\n            return false;\n        }\n        return true;\n    }\n    getToolSettingPropertyLocked(property) {\n        return (property === this.useRadiusProperty ? this.radiusProperty : undefined);\n    }\n    async applyToolSettingPropertyChange(updatedValue) {\n        if (!this.changeToolSettingPropertyValue(updatedValue))\n            return false;\n        if (this.methodProperty.name === updatedValue.propertyName)\n            await this.onReinitialize();\n        else if (updatedValue.propertyName === this.useRadiusProperty.name && CircleMethod.Center === this.method && this.useRadius && 0 === this.accepted.length)\n            await this.onReinitialize();\n        return true;\n    }\n    supplyToolSettingsProperties() {\n        const toolSettings = new Array();\n        toolSettings.push(this.methodProperty.toDialogItem({ rowPriority: 1, columnIndex: 0 }));\n        // ensure controls are enabled/disabled base on current lock property state\n        this.radiusProperty.isDisabled = !this.useRadius;\n        const useRadiusLock = this.useRadiusProperty.toDialogItem({ rowPriority: 2, columnIndex: 0 });\n        toolSettings.push(this.radiusProperty.toDialogItem({ rowPriority: 2, columnIndex: 1 }, useRadiusLock));\n        return toolSettings;\n    }\n    async onRestartTool() {\n        const tool = new CreateCircleTool();\n        if (!await tool.run())\n            return this.exitTool();\n    }\n    async onReinitialize() {\n        if (CircleMethod.Center === this.method && this.useRadius) {\n            // Don't install a new tool instance, we want to preserve current AccuDraw state...\n            this.accepted.length = 0;\n            this.setupAndPromptForNextAction();\n            this.beginDynamics();\n            return;\n        }\n        return super.onReinitialize();\n    }\n    async onPostInstall() {\n        await super.onPostInstall();\n        if (CircleMethod.Center === this.method && this.useRadius) {\n            // Start dynamics before 1st data point when placing by center w/locked radius value.\n            // Require the user to explicitly enable AccuDraw so that the compass location can be adjusted for changes\n            // to locks or view ACS (as opposed to appearing at it's previous or default location).\n            AccuDrawHintBuilder.deactivate();\n            this.beginDynamics();\n        }\n    }\n    async onInstall() {\n        if (!await super.onInstall())\n            return false;\n        // Setup initial values here instead of supplyToolSettingsProperties to support keyin args w/o appui-react...\n        this.initializeToolSettingPropertyValues([this.methodProperty, this.radiusProperty, this.useRadiusProperty]);\n        if (!this.radius)\n            this.useRadius = false;\n        return true;\n    }\n    /** The keyin takes the following arguments, all of which are optional:\n     *  - `method=0|1` How circle will be defined. 0 for center, 1 for edge.\n     *  - `radius=number` Circle radius, 0 to define by points.\n     */\n    async parseAndRun(...inputArgs) {\n        let circleMethod;\n        let circleRadius;\n        for (const arg of inputArgs) {\n            const parts = arg.split(\"=\");\n            if (2 !== parts.length)\n                continue;\n            if (parts[0].toLowerCase().startsWith(\"me\")) {\n                const method = Number.parseInt(parts[1], 10);\n                if (!Number.isNaN(method)) {\n                    switch (method) {\n                        case 0:\n                            circleMethod = CircleMethod.Center;\n                            break;\n                        case 1:\n                            circleMethod = CircleMethod.Edge;\n                            break;\n                    }\n                }\n            }\n            else if (parts[0].toLowerCase().startsWith(\"ra\")) {\n                const radius = Number.parseFloat(parts[1]);\n                if (!Number.isNaN(radius)) {\n                    circleRadius = radius;\n                }\n            }\n        }\n        // Update current session values so keyin args are picked up for tool settings/restart...\n        if (undefined !== circleMethod)\n            this.saveToolSettingPropertyValue(this.methodProperty, { value: circleMethod });\n        if (undefined !== circleRadius) {\n            if (0.0 !== circleRadius)\n                this.saveToolSettingPropertyValue(this.radiusProperty, { value: circleRadius });\n            this.saveToolSettingPropertyValue(this.useRadiusProperty, { value: 0.0 !== circleRadius });\n        }\n        return this.run();\n    }\n}\nCreateCircleTool.toolId = \"CreateCircle\";\nCreateCircleTool.iconSpec = \"icon-circle\";\nCreateCircleTool.getMethodChoices = () => {\n    return [\n        { label: CreateCircleTool.methodMessage(\"Center\"), value: CircleMethod.Center },\n        { label: CreateCircleTool.methodMessage(\"Edge\"), value: CircleMethod.Edge },\n    ];\n};\nexport { CreateCircleTool };\n/** @alpha Creates an ellipse. Uses model and category from [[BriefcaseConnection.editorToolSettings]]. */\nclass CreateEllipseTool extends CreateOrContinuePathTool {\n    isComplete(_ev) {\n        return (3 === this.accepted.length);\n    }\n    provideToolAssistance(mainInstrText, additionalInstr) {\n        const nPts = this.accepted.length;\n        switch (nPts) {\n            case 0:\n                mainInstrText = EditTools.translate(\"CreateEllipse.Prompts.CenterPoint\");\n                break;\n            case 1:\n                mainInstrText = EditTools.translate(\"CreateEllipse.Prompts.MajorAxis\");\n                break;\n            case 2:\n                mainInstrText = EditTools.translate(\"CreateEllipse.Prompts.MinorAxis\");\n                break;\n        }\n        super.provideToolAssistance(mainInstrText, additionalInstr);\n    }\n    setupAccuDraw() {\n        const nPts = this.accepted.length;\n        if (0 === nPts)\n            return;\n        const hints = new AccuDrawHintBuilder();\n        if (this.wantSmartRotation)\n            hints.enableSmartRotation = true;\n        switch (nPts) {\n            case 1:\n                hints.setOrigin(this.accepted[0]);\n                hints.setOriginFixed = true;\n                break;\n            case 2:\n                hints.setXAxis(Vector3d.createStartEnd(this.accepted[0], this.accepted[1]));\n                hints.setLockX = true;\n                break;\n        }\n        hints.sendHints();\n    }\n    createNewCurvePrimitive(ev, isDynamics) {\n        const numRequired = (isDynamics ? 2 : 3);\n        if (this.accepted.length < numRequired) {\n            if (this.accepted.length < (numRequired - 1))\n                return undefined;\n            this.isConstruction = true; // Create construction geometry to show  major axis...\n            return LineString3d.create([this.accepted[0], (isDynamics ? ev.point : this.accepted[1])]);\n        }\n        this.isClosed = true; // Always closed...\n        const center = this.accepted[0];\n        const major = this.accepted[1];\n        const normal = this.getUpVector(ev);\n        const vector0 = Vector3d.createStartEnd(center, major);\n        const vector90 = normal.crossProduct(vector0);\n        const dir = Ray3d.create(center, vector90);\n        const minor = dir.projectPointToRay(isDynamics ? ev.point : this.accepted[2]);\n        vector90.scaleToLength(center.distance(minor), vector90);\n        return Arc3d.create(center, vector0, vector90);\n    }\n    async onRestartTool() {\n        const tool = new CreateEllipseTool();\n        if (!await tool.run())\n            return this.exitTool();\n    }\n}\nCreateEllipseTool.toolId = \"CreateEllipse\";\nCreateEllipseTool.iconSpec = \"icon-ellipse\";\nexport { CreateEllipseTool };\n/** @alpha Creates a rectangle by corner points. Uses model and category from [[BriefcaseConnection.editorToolSettings]]. */\nclass CreateRectangleTool extends CreateOrContinuePathTool {\n    constructor() {\n        super(...arguments);\n        this.localToWorld = Transform.createIdentity();\n    }\n    static get minArgs() { return 0; }\n    static get maxArgs() { return 1; } // radius - zero value unlocks associated \"use\" toggle...\n    provideToolAssistance(mainInstrText, additionalInstr) {\n        mainInstrText = CoreTools.translate(0 === this.accepted.length ? \"ElementSet.Prompts.StartCorner\" : \"ElementSet.Prompts.OppositeCorner\");\n        super.provideToolAssistance(mainInstrText, additionalInstr);\n    }\n    setupAccuDraw() {\n        const nPts = this.accepted.length;\n        if (0 === nPts)\n            return;\n        const hints = new AccuDrawHintBuilder();\n        if (this.wantSmartRotation)\n            hints.enableSmartRotation = true;\n        hints.setOrigin(this.accepted[0]);\n        hints.sendHints();\n    }\n    get useRadiusProperty() {\n        if (!this._useRadiusProperty)\n            this._useRadiusProperty = new DialogProperty(PropertyDescriptionHelper.buildLockPropertyDescription(\"useCornerRadius\"), false);\n        return this._useRadiusProperty;\n    }\n    get useRadius() { return this.useRadiusProperty.value; }\n    set useRadius(value) { this.useRadiusProperty.value = value; }\n    get radiusProperty() {\n        if (!this._radiusProperty)\n            this._radiusProperty = new DialogProperty(new LengthDescription(\"cornerRadius\", EditTools.translate(\"CreateRectangle.Label.CornerRadius\")), 0.1, undefined, !this.useRadius);\n        return this._radiusProperty;\n    }\n    get radius() { return this.radiusProperty.value; }\n    set radius(value) { this.radiusProperty.value = value; }\n    isComplete(_ev) {\n        return (2 === this.accepted.length);\n    }\n    createNewCurvePrimitive(ev, isDynamics) {\n        const numRequired = (isDynamics ? 1 : 2);\n        if (this.accepted.length < numRequired)\n            return undefined;\n        const origin = this.accepted[0];\n        const corner = (isDynamics ? ev.point : this.accepted[1]);\n        const matrix = this.getCurrentRotation(ev);\n        Transform.createOriginAndMatrix(Point3d.createZero(), matrix, this.localToWorld);\n        this.originLocal = this.localToWorld.multiplyInversePoint3d(origin);\n        this.cornerLocal = this.localToWorld.multiplyInversePoint3d(corner);\n        if (undefined === this.originLocal || undefined === this.cornerLocal)\n            return undefined;\n        const shapePts = [];\n        shapePts[0] = Point3d.create(this.originLocal.x, this.originLocal.y, this.originLocal.z);\n        shapePts[1] = Point3d.create(this.cornerLocal.x, this.originLocal.y, this.cornerLocal.z);\n        shapePts[2] = Point3d.create(this.cornerLocal.x, this.cornerLocal.y, this.cornerLocal.z);\n        shapePts[3] = Point3d.create(this.originLocal.x, this.cornerLocal.y, this.originLocal.z);\n        shapePts[4] = shapePts[0].clone();\n        this.localToWorld.multiplyPoint3dArrayInPlace(shapePts);\n        this.isClosed = true; // Always closed...\n        return LineString3d.create(shapePts);\n    }\n    createNewPath(placement) {\n        if (!this.useRadius || 0.0 === this.radius || undefined === this.originLocal || undefined === this.cornerLocal)\n            return super.createNewPath(placement);\n        const builder = new ElementGeometry.Builder();\n        builder.setLocalToWorldFromPlacement(placement);\n        const loop = CurveFactory.createRectangleXY(this.originLocal.x, this.originLocal.y, this.cornerLocal.x, this.cornerLocal.y, this.originLocal.z, this.radius);\n        loop.tryTransformInPlace(this.localToWorld);\n        if (!builder.appendGeometryQuery(loop))\n            return;\n        return { format: \"flatbuffer\", data: builder.entries };\n    }\n    getToolSettingPropertyLocked(property) {\n        return (property === this.useRadiusProperty ? this.radiusProperty : undefined);\n    }\n    async applyToolSettingPropertyChange(updatedValue) {\n        return this.changeToolSettingPropertyValue(updatedValue);\n    }\n    supplyToolSettingsProperties() {\n        const toolSettings = new Array();\n        // ensure controls are enabled/disabled base on current lock property state\n        this.radiusProperty.isDisabled = !this.useRadius;\n        const useRadiusLock = this.useRadiusProperty.toDialogItem({ rowPriority: 1, columnIndex: 0 });\n        toolSettings.push(this.radiusProperty.toDialogItem({ rowPriority: 1, columnIndex: 1 }, useRadiusLock));\n        return toolSettings;\n    }\n    async onRestartTool() {\n        const tool = new CreateRectangleTool();\n        if (!await tool.run())\n            return this.exitTool();\n    }\n    async onInstall() {\n        if (!await super.onInstall())\n            return false;\n        // Setup initial values here instead of supplyToolSettingsProperties to support keyin args w/o appui-react...\n        this.initializeToolSettingPropertyValues([this.radiusProperty, this.useRadiusProperty]);\n        if (!this.radius)\n            this.useRadius = false;\n        return true;\n    }\n    /** The keyin takes the following arguments, all of which are optional:\n     *  - `radius=number` Corner radius, 0 for sharp corners.\n     */\n    async parseAndRun(...inputArgs) {\n        let cornerRadius;\n        for (const arg of inputArgs) {\n            const parts = arg.split(\"=\");\n            if (2 !== parts.length)\n                continue;\n            if (parts[0].toLowerCase().startsWith(\"ra\")) {\n                const radius = Number.parseFloat(parts[1]);\n                if (!Number.isNaN(radius)) {\n                    cornerRadius = radius;\n                }\n            }\n        }\n        // Update current session values so keyin args are picked up for tool settings/restart...\n        if (undefined !== cornerRadius) {\n            if (0.0 !== cornerRadius)\n                this.saveToolSettingPropertyValue(this.radiusProperty, { value: cornerRadius });\n            this.saveToolSettingPropertyValue(this.useRadiusProperty, { value: 0.0 !== cornerRadius });\n        }\n        return this.run();\n    }\n}\nCreateRectangleTool.toolId = \"CreateRectangle\";\nCreateRectangleTool.iconSpec = \"icon-rectangle\";\nexport { CreateRectangleTool };\n/** @alpha */\nexport var BCurveMethod;\n(function (BCurveMethod) {\n    BCurveMethod[BCurveMethod[\"ControlPoints\"] = 0] = \"ControlPoints\";\n    BCurveMethod[BCurveMethod[\"ThroughPoints\"] = 1] = \"ThroughPoints\";\n})(BCurveMethod || (BCurveMethod = {}));\n/** @alpha Creates a bspline curve by poles or through points. Uses model and category from [[BriefcaseConnection.editorToolSettings]]. */\nclass CreateBCurveTool extends CreateOrContinuePathTool {\n    constructor() {\n        super(...arguments);\n        this._isPhysicallyClosedOrComplete = false;\n        this._tangentPhase = CreateCurvePhase.DefineOther;\n    }\n    static get minArgs() { return 0; }\n    static get maxArgs() { return 3; } // method, order, tangents...\n    get wantPickableDynamics() { return true; } // Allow snapping to control polygon or through points...\n    get showCurveConstructions() { return true; } // Display control polygon or through points...\n    provideToolAssistance(_mainInstrText, _additionalInstr) {\n        const nPts = this.accepted.length;\n        let mainMsg;\n        if (CreateCurvePhase.DefineOther === this._tangentPhase)\n            mainMsg = CoreTools.translate(0 === nPts ? \"ElementSet.Prompts.StartPoint\" : \"ElementSet.Inputs.AdditionalPoint\");\n        else\n            mainMsg = EditTools.translate(CreateCurvePhase.DefineStart === this._tangentPhase ? \"CreateBCurve.Prompts.StartTangent\" : \"CreateBCurve.Prompts.EndTangent\");\n        const leftMsg = CoreTools.translate(\"ElementSet.Inputs.AcceptPoint\");\n        const rightMsg = CoreTools.translate(CreateCurvePhase.DefineOther === this._tangentPhase && nPts >= this.requiredPointCount ? \"ElementSet.Inputs.Complete\" : \"ElementSet.Inputs.Cancel\");\n        const mouseInstructions = [];\n        const touchInstructions = [];\n        if (!ToolAssistance.createTouchCursorInstructions(touchInstructions))\n            touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.OneTouchTap, leftMsg, false, ToolAssistanceInputMethod.Touch));\n        mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.LeftClick, leftMsg, false, ToolAssistanceInputMethod.Mouse));\n        touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.TwoTouchTap, rightMsg, false, ToolAssistanceInputMethod.Touch));\n        mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.RightClick, rightMsg, false, ToolAssistanceInputMethod.Mouse));\n        const sections = [];\n        sections.push(ToolAssistance.createSection(mouseInstructions, ToolAssistance.inputsLabel));\n        sections.push(ToolAssistance.createSection(touchInstructions, ToolAssistance.inputsLabel));\n        const mainInstruction = ToolAssistance.createInstruction(this.iconSpec, mainMsg);\n        const instructions = ToolAssistance.createInstructions(mainInstruction, sections);\n        IModelApp.notifications.setToolAssistance(instructions);\n    }\n    static methodMessage(str) { return EditTools.translate(`CreateBCurve.Method.${str}`); }\n    get methodProperty() {\n        if (!this._methodProperty)\n            this._methodProperty = new DialogProperty(PropertyDescriptionHelper.buildEnumPicklistEditorDescription(\"bcurveMethod\", EditTools.translate(\"CreateBCurve.Label.Method\"), CreateBCurveTool.getMethodChoices()), BCurveMethod.ControlPoints);\n        return this._methodProperty;\n    }\n    get method() { return this.methodProperty.value; }\n    set method(method) { this.methodProperty.value = method; }\n    get orderProperty() {\n        if (!this._orderProperty)\n            this._orderProperty = new DialogProperty(PropertyDescriptionHelper.buildNumberEditorDescription(\"bcurveOrder\", EditTools.translate(\"CreateBCurve.Label.Order\"), { type: PropertyEditorParamTypes.Range, minimum: this.minOrder, maximum: this.maxOrder }), 3);\n        return this._orderProperty;\n    }\n    get order() { return this.orderProperty.value; }\n    set order(value) { this.orderProperty.value = value; }\n    get minOrder() { return 2; }\n    get maxOrder() { return 16; }\n    get tangentsProperty() {\n        if (!this._tangentsProperty)\n            this._tangentsProperty = new DialogProperty(PropertyDescriptionHelper.buildToggleDescription(\"bcurveTangents\", EditTools.translate(\"CreateBCurve.Label.Tangents\")), false);\n        return this._tangentsProperty;\n    }\n    get tangents() { return this.tangentsProperty.value; }\n    set tangents(value) { this.tangentsProperty.value = value; }\n    get wantClosure() {\n        // A bcurve can support physical closure when creating a new path...\n        return this.allowClosure;\n    }\n    get requiredPointCount() {\n        if (BCurveMethod.ThroughPoints === this.method)\n            return 3; // Interpolation curve is always order 4 with 3 point minimum...\n        return this.order;\n    }\n    get createCurvePhase() {\n        if (CreateCurvePhase.DefineOther !== this._tangentPhase)\n            return CreateCurvePhase.DefineOther;\n        return super.createCurvePhase;\n    }\n    updateCurvePhase() {\n        // The first point changes startPoint and last point changes endPoint.\n        this._createCurvePhase = (0 === this.accepted.length ? CreateCurvePhase.DefineStart : CreateCurvePhase.DefineEnd);\n    }\n    isComplete(ev) {\n        // Accept on reset with sufficient points...\n        if (BeButton.Reset === ev.button)\n            return (this.accepted.length >= this.requiredPointCount);\n        // Allow data to complete on physical closure...\n        return this.isClosed || this._isPhysicallyClosedOrComplete;\n    }\n    showConstructionGraphics(ev, context) {\n        if (CreateCurvePhase.DefineOther !== this._tangentPhase && this.current) {\n            const fitCurve = this.current;\n            const builder = context.createGraphic({ type: GraphicType.WorldOverlay });\n            const color = context.viewport.getContrastToBackgroundColor();\n            builder.setSymbology(color, ColorDef.black, 1, LinePixels.Code2);\n            builder.addLineString([ev.point, fitCurve.options.fitPoints[CreateCurvePhase.DefineStart === this._tangentPhase ? 0 : fitCurve.options.fitPoints.length - 1]]);\n            builder.setSymbology(color, ColorDef.black, 8);\n            builder.addPointString([ev.point]);\n            context.addGraphic(builder.finish());\n        }\n        return super.showConstructionGraphics(ev, context);\n    }\n    createNewCurvePrimitive(ev, isDynamics) {\n        if (CreateCurvePhase.DefineOther !== this._tangentPhase && this.current) {\n            const fitCurve = this.current;\n            if (CreateCurvePhase.DefineStart === this._tangentPhase) {\n                const tangentS = Vector3d.createStartEnd(ev.point, fitCurve.options.fitPoints[0]);\n                if (tangentS.magnitude() > Geometry.smallMetricDistance)\n                    fitCurve.options.startTangent = tangentS;\n            }\n            else {\n                const tangentE = Vector3d.createStartEnd(ev.point, fitCurve.options.fitPoints[fitCurve.options.fitPoints.length - 1]);\n                if (tangentE.magnitude() > Geometry.smallMetricDistance)\n                    fitCurve.options.endTangent = tangentE;\n            }\n            return fitCurve;\n        }\n        // Don't include current point if it's the same as the last accepted point, want dynamics to show an accurate preview of what reset will accept...\n        const includeCurrPt = (isDynamics && (0 === this.accepted.length || !ev.point.isAlmostEqual(this.accepted[this.accepted.length - 1])));\n        const pts = (includeCurrPt ? [...this.accepted, ev.point] : this.accepted);\n        const numRequired = this.requiredPointCount;\n        if (pts.length < numRequired) {\n            // Create point/linestring construction geometry to support join...\n            this.isConstruction = true;\n            return LineString3d.create(1 === pts.length ? [pts[0], pts[0]] : pts);\n        }\n        // Create periodic-looking curve on physical closure with sufficient points even when not creating a loop/surface...\n        this._isPhysicallyClosedOrComplete = (undefined === this.continuationData && pts[0].isAlmostEqual(pts[pts.length - 1]));\n        if (BCurveMethod.ControlPoints === this.method) {\n            if (this._isPhysicallyClosedOrComplete && this.order > 2) {\n                const tmpPts = pts.slice(undefined, -1); // Don't include closure point...\n                return BSplineCurve3d.createPeriodicUniformKnots(tmpPts, this.order);\n            }\n            return BSplineCurve3d.createUniformKnots(pts, this.order);\n        }\n        const interpProps = { fitPoints: pts, closed: this._isPhysicallyClosedOrComplete, isChordLenKnots: 1, isColinearTangents: 1 };\n        // Create interpolation curve tangent to continuation curve...\n        if (undefined !== this.continuationData && this.tangents) {\n            const tangentS = this.continuationData.path.children[0].fractionToPointAndUnitTangent(0.0);\n            const tangentE = this.continuationData.path.children[this.continuationData.path.children.length - 1].fractionToPointAndUnitTangent(1.0);\n            if (pts[0].isAlmostEqual(tangentS.origin))\n                interpProps.startTangent = tangentS.direction.scale(-1);\n            else if (pts[0].isAlmostEqual(tangentE.origin))\n                interpProps.startTangent = tangentE.direction;\n            if (pts[pts.length - 1].isAlmostEqual(tangentS.origin))\n                interpProps.endTangent = tangentS.direction.scale(-1);\n            else if (pts[pts.length - 1].isAlmostEqual(tangentE.origin))\n                interpProps.endTangent = tangentE.direction;\n            this._isPhysicallyClosedOrComplete = (undefined !== interpProps.startTangent && undefined !== interpProps.endTangent);\n        }\n        const interpOpts = InterpolationCurve3dOptions.create(interpProps);\n        return InterpolationCurve3d.createCapture(interpOpts);\n    }\n    getSnapGeometry() {\n        // Only snap to through points...\n        if (BCurveMethod.ThroughPoints === this.method)\n            return (this.accepted.length > 1 ? PointString3d.create(this.accepted) : undefined);\n        return super.getSnapGeometry();\n    }\n    async acceptPoint(ev) {\n        switch (this._tangentPhase) {\n            case CreateCurvePhase.DefineOther:\n                return super.acceptPoint(ev);\n            case CreateCurvePhase.DefineStart:\n                this._tangentPhase = CreateCurvePhase.DefineEnd;\n                break;\n            case CreateCurvePhase.DefineEnd:\n                this._isPhysicallyClosedOrComplete = true;\n                break;\n        }\n        await this.updateCurveAndContinuationData(ev, false);\n        return true;\n    }\n    async cancelPoint(ev) {\n        // NOTE: Starting another tool will not create element...require reset or closure...\n        if (this.isComplete(ev)) {\n            if (BCurveMethod.ThroughPoints === this.method && this.tangents && this.current) {\n                const fitCurve = this.current;\n                switch (this._tangentPhase) {\n                    case CreateCurvePhase.DefineOther:\n                        this._createCurvePhase = CreateCurvePhase.DefineEnd;\n                        await this.updateCurveAndContinuationData(ev, false);\n                        this._tangentPhase = (undefined === fitCurve.options.startTangent ? CreateCurvePhase.DefineStart : CreateCurvePhase.DefineEnd);\n                        IModelApp.toolAdmin.updateDynamics();\n                        this.setupAndPromptForNextAction();\n                        return false;\n                    case CreateCurvePhase.DefineStart:\n                        fitCurve.options.startTangent = undefined; // Not accepted, compute default start tangent...\n                        this._tangentPhase = CreateCurvePhase.DefineEnd;\n                        IModelApp.toolAdmin.updateDynamics();\n                        this.setupAndPromptForNextAction();\n                        return false;\n                    case CreateCurvePhase.DefineEnd:\n                        fitCurve.options.endTangent = undefined; // Not accepted, compute default end tangent...\n                        await this.createElement();\n                        return true;\n                }\n            }\n            this._createCurvePhase = CreateCurvePhase.DefineEnd;\n            await this.updateCurveAndContinuationData(ev, false);\n            await this.createElement();\n        }\n        return true;\n    }\n    async applyToolSettingPropertyChange(updatedValue) {\n        if (!this.changeToolSettingPropertyValue(updatedValue))\n            return false;\n        if (this.methodProperty.name === updatedValue.propertyName)\n            await this.onReinitialize();\n        return true;\n    }\n    supplyToolSettingsProperties() {\n        const toolSettings = new Array();\n        toolSettings.push(this.methodProperty.toDialogItem({ rowPriority: 1, columnIndex: 0 }));\n        if (BCurveMethod.ThroughPoints === this.method)\n            toolSettings.push(this.tangentsProperty.toDialogItem({ rowPriority: 2, columnIndex: 0 }));\n        else\n            toolSettings.push(this.orderProperty.toDialogItem({ rowPriority: 2, columnIndex: 1 }));\n        return toolSettings;\n    }\n    async onRestartTool() {\n        const tool = new CreateBCurveTool();\n        if (!await tool.run())\n            return this.exitTool();\n    }\n    async onInstall() {\n        if (!await super.onInstall())\n            return false;\n        // Setup initial values here instead of supplyToolSettingsProperties to support keyin args w/o appui-react...\n        this.initializeToolSettingPropertyValues([this.methodProperty, this.orderProperty, this.tangentsProperty]);\n        return true;\n    }\n    /** The keyin takes the following arguments, all of which are optional:\n     *  - `method=0|1` How bcurve will be defined. 0 for control points, 1 for through points.\n     *  - `order=number` bcurve order from 2 to 16.\n     *  - 'tangents=0|1 Whether to specify start/end tangents for through points construction.\n     */\n    async parseAndRun(...inputArgs) {\n        let bcurveMethod;\n        let bcurveOrder;\n        let bcurveTangents;\n        for (const arg of inputArgs) {\n            const parts = arg.split(\"=\");\n            if (2 !== parts.length)\n                continue;\n            if (parts[0].toLowerCase().startsWith(\"me\")) {\n                const method = Number.parseInt(parts[1], 10);\n                if (!Number.isNaN(method)) {\n                    switch (method) {\n                        case 0:\n                            bcurveMethod = BCurveMethod.ControlPoints;\n                            break;\n                        case 1:\n                            bcurveMethod = BCurveMethod.ThroughPoints;\n                            break;\n                    }\n                }\n            }\n            else if (parts[0].toLowerCase().startsWith(\"or\")) {\n                const order = Number.parseInt(parts[1], 10);\n                if (order >= this.minOrder && order <= this.maxOrder) {\n                    bcurveOrder = order;\n                }\n            }\n            else if (parts[0].toLowerCase().startsWith(\"ta\")) {\n                const tangents = Number.parseInt(parts[1], 10);\n                bcurveTangents = (0 !== tangents);\n            }\n        }\n        // Update current session values so keyin args are picked up for tool settings/restart...\n        if (undefined !== bcurveMethod)\n            this.saveToolSettingPropertyValue(this.methodProperty, { value: bcurveMethod });\n        if (undefined !== bcurveOrder)\n            this.saveToolSettingPropertyValue(this.orderProperty, { value: bcurveOrder });\n        if (undefined !== bcurveTangents)\n            this.saveToolSettingPropertyValue(this.tangentsProperty, { value: bcurveTangents });\n        return this.run();\n    }\n}\nCreateBCurveTool.toolId = \"CreateBCurve\";\nCreateBCurveTool.iconSpec = \"icon-snaps-nearest\"; // Need better icon...\nCreateBCurveTool.getMethodChoices = () => {\n    return [\n        { label: CreateBCurveTool.methodMessage(\"ControlPoints\"), value: BCurveMethod.ControlPoints },\n        { label: CreateBCurveTool.methodMessage(\"ThroughPoints\"), value: BCurveMethod.ThroughPoints },\n    ];\n};\nexport { CreateBCurveTool };\n//# sourceMappingURL=SketchTools.js.map",
      "start": 1693508122935,
      "end": 1693508123064,
      "sourcemaps": null
    }
  ]
}
