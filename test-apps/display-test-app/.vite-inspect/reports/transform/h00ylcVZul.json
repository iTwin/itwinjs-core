{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tile/ImdlGraphicsCreator.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tiles\n */\nimport { JsonUtils } from \"@itwin/core-bentley\";\nimport { ClipVector, Point2d, Point3d, Range3d, Transform } from \"@itwin/core-geometry\";\nimport { ColorDef, Gradient, ImageSource, RenderMaterial, RenderTexture, TextureMapping, } from \"@itwin/core-common\";\nimport { AuxChannelTable } from \"../common/render/primitives/AuxChannelTable\";\nimport { createSurfaceMaterial } from \"../common//render/primitives/SurfaceParams\";\nimport { edgeParamsFromImdl, toMaterialParams, toVertexTable } from \"../common/imdl/ParseImdlDocument\";\nimport { VertexIndices } from \"../common/render/primitives/VertexIndices\";\nimport { GraphicBranch } from \"../render/GraphicBranch\";\nasync function loadNamedTexture(name, namedTex, options) {\n    // Reasons a texture could be embedded in the tile content instead of requested separately from the backend:\n    // - external textures are disabled\n    // - the texture name is not a valid Id64 string\n    // - the texture is below a certain backend-hardcoded size threshold\n    // The bufferViewJson being defined signifies any of the above conditions. In that case, the image content\n    // has been embedded in the tile contents. Otherwise, we will attempt to request the image content separately\n    // from the backend.\n    try {\n        let textureType = RenderTexture.Type.Normal;\n        const isGlyph = JsonUtils.asBool(namedTex.isGlyph);\n        const isTileSection = !isGlyph && JsonUtils.asBool(namedTex.isTileSection);\n        if (isGlyph)\n            textureType = RenderTexture.Type.Glyph;\n        else if (isTileSection)\n            textureType = RenderTexture.Type.TileSection;\n        // We produce unique tile sections for very large (> 8 megapixel) textures, and unique glyph atlases for raster text.\n        // Neither should be cached.\n        const cacheable = !isGlyph && !isTileSection;\n        const ownership = cacheable ? { iModel: options.iModel, key: name } : undefined;\n        const bufferViewId = JsonUtils.asString(namedTex.bufferView);\n        const bufferViewJson = 0 !== bufferViewId.length ? options.document.json.bufferViews[bufferViewId] : undefined;\n        if (undefined !== bufferViewJson) { // presence of bufferViewJson signifies we should read the texture from the tile content\n            const byteOffset = JsonUtils.asInt(bufferViewJson.byteOffset);\n            const byteLength = JsonUtils.asInt(bufferViewJson.byteLength);\n            if (0 === byteLength)\n                return undefined;\n            const texBytes = options.document.binaryData.subarray(byteOffset, byteOffset + byteLength);\n            const format = namedTex.format;\n            const source = new ImageSource(texBytes, format);\n            return await options.system.createTextureFromSource({ source, ownership, type: textureType, transparency: namedTex.transparency });\n        }\n        // bufferViewJson was undefined, so attempt to request the texture directly from the backend\n        // eslint-disable-next-line deprecation/deprecation\n        const params = new RenderTexture.Params(cacheable ? name : undefined, textureType);\n        return options.system.createTextureFromElement(name, options.iModel, params, namedTex.format);\n    }\n    catch (_) {\n        return undefined;\n    }\n}\nasync function loadNamedTextures(options) {\n    const result = new Map();\n    const namedTextures = options.document.json.namedTextures;\n    if (!namedTextures)\n        return result;\n    const promises = new Array();\n    for (const [name, namedTexture] of Object.entries(namedTextures)) {\n        const texture = options.system.findTexture(name, options.iModel);\n        if (texture) {\n            result.set(name, texture);\n            continue;\n        }\n        else if (namedTexture) {\n            promises.push(loadNamedTexture(name, namedTexture, options).then((tx) => {\n                if (tx)\n                    result.set(name, tx);\n            }));\n        }\n    }\n    if (promises.length > 0)\n        await Promise.all(promises);\n    return result;\n}\nfunction constantLodParamPropsFromJson(propsJson) {\n    if (undefined === propsJson)\n        return undefined;\n    const constantLodPops = {\n        repetitions: JsonUtils.asDouble(propsJson.repetitions, 1.0),\n        offset: { x: propsJson.offset ? JsonUtils.asDouble(propsJson.offset[0]) : 0.0, y: propsJson.offset ? JsonUtils.asDouble(propsJson.offset[1]) : 0.0 },\n        minDistClamp: JsonUtils.asDouble(propsJson.minDistClamp, 1.0),\n        maxDistClamp: JsonUtils.asDouble(propsJson.maxDistClamp, 4096.0 * 1024.0 * 1024.0),\n    };\n    return constantLodPops;\n}\nfunction textureMappingFromJson(json, options) {\n    if (!json)\n        return undefined;\n    const texture = options.textures.get(JsonUtils.asString(json.name));\n    if (!texture)\n        return undefined;\n    const paramsJson = json.params;\n    const tf = paramsJson.transform;\n    const paramProps = {\n        textureMat2x3: new TextureMapping.Trans2x3(tf[0][0], tf[0][1], tf[0][2], tf[1][0], tf[1][1], tf[1][2]),\n        textureWeight: JsonUtils.asDouble(paramsJson.weight, 1.0),\n        mapMode: JsonUtils.asInt(paramsJson.mode),\n        worldMapping: JsonUtils.asBool(paramsJson.worldMapping),\n        useConstantLod: JsonUtils.asBool(paramsJson.useConstantLod),\n        constantLodProps: constantLodParamPropsFromJson(paramsJson.constantLodParams),\n    };\n    const textureMapping = new TextureMapping(texture, new TextureMapping.Params(paramProps));\n    const normalMapJson = json.normalMapParams;\n    if (normalMapJson) {\n        let normalMap;\n        const normalTexName = JsonUtils.asString(normalMapJson.textureName);\n        if (normalTexName.length === 0 || undefined !== (normalMap = options.textures.get(normalTexName))) {\n            textureMapping.normalMapParams = {\n                normalMap,\n                greenUp: JsonUtils.asBool(normalMapJson.greenUp),\n                scale: JsonUtils.asDouble(normalMapJson.scale, 1),\n                useConstantLod: JsonUtils.asBool(normalMapJson.useConstantLod),\n            };\n        }\n    }\n    return textureMapping;\n}\nfunction getMaterial(mat, options) {\n    if (typeof mat !== \"string\") {\n        const args = toMaterialParams(mat);\n        return options.system.createRenderMaterial(args);\n    }\n    const material = options.system.findMaterial(mat, options.iModel);\n    if (material || !options.document.json.renderMaterials)\n        return material;\n    const json = options.document.json.renderMaterials[mat];\n    if (!json)\n        return undefined;\n    function colorDefFromJson(col) {\n        return col ? ColorDef.from(col[0] * 255 + 0.5, col[1] * 255 + 0.5, col[2] * 255 + 0.5) : undefined;\n    }\n    // eslint-disable-next-line deprecation/deprecation\n    const params = new RenderMaterial.Params(mat);\n    params.diffuseColor = colorDefFromJson(json.diffuseColor);\n    if (json.diffuse !== undefined)\n        params.diffuse = JsonUtils.asDouble(json.diffuse);\n    params.specularColor = colorDefFromJson(json.specularColor);\n    if (json.specular !== undefined)\n        params.specular = JsonUtils.asDouble(json.specular);\n    params.reflectColor = colorDefFromJson(json.reflectColor);\n    if (json.reflect !== undefined)\n        params.reflect = JsonUtils.asDouble(json.reflect);\n    if (json.specularExponent !== undefined)\n        params.specularExponent = json.specularExponent;\n    if (undefined !== json.transparency)\n        params.alpha = 1.0 - json.transparency;\n    params.refract = JsonUtils.asDouble(json.refract);\n    params.shadows = JsonUtils.asBool(json.shadows);\n    params.ambient = JsonUtils.asDouble(json.ambient);\n    if (undefined !== json.textureMapping)\n        params.textureMapping = textureMappingFromJson(json.textureMapping.texture, options);\n    // eslint-disable-next-line deprecation/deprecation\n    return options.system.createMaterial(params, options.iModel);\n}\nfunction getModifiers(primitive) {\n    const mod = primitive.modifier;\n    switch (mod?.type) {\n        case \"instances\":\n            return {\n                instances: {\n                    ...mod,\n                    transformCenter: Point3d.fromJSON(mod.transformCenter),\n                    range: mod.range ? Range3d.fromJSON(mod.range) : undefined,\n                },\n            };\n        case \"viewIndependentOrigin\":\n            return {\n                viOrigin: Point3d.fromJSON(mod.origin),\n            };\n        default:\n            return {};\n    }\n}\nfunction createPrimitiveGeometry(primitive, options, viOrigin) {\n    switch (primitive.type) {\n        case \"point\":\n            return options.system.createPointStringGeometry({\n                ...primitive.params,\n                vertices: toVertexTable(primitive.params.vertices),\n                indices: new VertexIndices(primitive.params.indices),\n            }, viOrigin);\n        case \"polyline\":\n            return options.system.createPolylineGeometry({\n                ...primitive.params,\n                vertices: toVertexTable(primitive.params.vertices),\n                polyline: {\n                    ...primitive.params.polyline,\n                    indices: new VertexIndices(primitive.params.polyline.indices),\n                    prevIndices: new VertexIndices(primitive.params.polyline.prevIndices),\n                },\n            }, viOrigin);\n        case \"mesh\": {\n            const surf = primitive.params.surface;\n            let material;\n            if (surf.material) {\n                if (!surf.material.isAtlas)\n                    material = createSurfaceMaterial(getMaterial(surf.material.material, options));\n                else\n                    material = surf.material;\n            }\n            let textureMapping;\n            if (surf.textureMapping) {\n                let texture;\n                if (typeof surf.textureMapping.texture === \"string\") {\n                    texture = options.textures.get(surf.textureMapping.texture);\n                }\n                else {\n                    const gradient = Gradient.Symb.fromJSON(surf.textureMapping.texture);\n                    texture = options.system.getGradientTexture(gradient, options.iModel);\n                }\n                if (texture)\n                    textureMapping = { texture, alwaysDisplayed: surf.textureMapping.alwaysDisplayed };\n            }\n            return options.system.createMeshGeometry({\n                ...primitive.params,\n                edges: primitive.params.edges ? edgeParamsFromImdl(primitive.params.edges) : undefined,\n                vertices: toVertexTable(primitive.params.vertices),\n                auxChannels: primitive.params.auxChannels ? AuxChannelTable.fromJSON(primitive.params.auxChannels) : undefined,\n                surface: {\n                    ...primitive.params.surface,\n                    material,\n                    textureMapping,\n                    indices: new VertexIndices(primitive.params.surface.indices),\n                },\n            }, viOrigin);\n        }\n    }\n}\nfunction createPrimitiveGraphic(primitive, options) {\n    const mods = getModifiers(primitive);\n    const geometry = createPrimitiveGeometry(primitive, options, mods.viOrigin);\n    return geometry ? options.system.createRenderGraphic(geometry, mods.instances) : undefined;\n}\nfunction createPatternGeometries(primitives, options) {\n    const geometries = [];\n    for (const primitive of primitives) {\n        const geometry = createPrimitiveGeometry(primitive, options, undefined);\n        if (geometry)\n            geometries.push(geometry);\n    }\n    return geometries;\n}\nfunction createPatternGraphic(params, options) {\n    const geometries = options.patterns.get(params.symbolName);\n    if (!geometries || geometries.length === 0)\n        return undefined;\n    const clip = ClipVector.fromJSON(params.clip);\n    const clipVolume = clip?.isValid ? options.system.createClipVolume(clip) : undefined;\n    if (!clipVolume)\n        return undefined;\n    const viewIndependentOrigin = params.viewIndependentOrigin ? Point3d.fromJSON(params.viewIndependentOrigin) : undefined;\n    const pattern = options.system.createAreaPattern({\n        xyOffsets: params.xyOffsets,\n        featureId: params.featureId,\n        orgTransform: Transform.fromJSON(params.orgTransform),\n        origin: Point2d.fromJSON(params.origin),\n        scale: params.scale,\n        spacing: Point2d.fromJSON(params.spacing),\n        patternToModel: Transform.fromJSON(params.modelTransform),\n        range: Range3d.fromJSON(params.range),\n        symbolTranslation: Point3d.fromJSON(params.symbolTranslation),\n        viewIndependentOrigin,\n    });\n    if (!pattern)\n        return undefined;\n    const branch = new GraphicBranch(true);\n    for (const geometry of geometries) {\n        const graphic = options.system.createRenderGraphic(geometry, pattern);\n        if (graphic)\n            branch.add(graphic);\n    }\n    return branch.isEmpty ? undefined : options.system.createGraphicBranch(branch, Transform.createIdentity(), { clipVolume });\n}\nfunction createNodeGraphics(node, options) {\n    const graphics = [];\n    for (const primitive of node.primitives) {\n        const graphic = primitive.type === \"pattern\" ? createPatternGraphic(primitive.params, options) : createPrimitiveGraphic(primitive, options);\n        if (graphic)\n            graphics.push(graphic);\n    }\n    return graphics;\n}\n/** @internal */\nexport async function decodeImdlGraphics(options) {\n    const textures = await loadNamedTextures(options);\n    if (options.isCanceled && options.isCanceled())\n        return undefined;\n    const patterns = new Map();\n    const graphicsOptions = { ...options, textures, patterns };\n    for (const [name, primitives] of options.document.patterns)\n        patterns.set(name, createPatternGeometries(primitives, graphicsOptions));\n    const system = options.system;\n    const graphics = [];\n    for (const node of options.document.nodes) {\n        const nodeGraphics = createNodeGraphics(node, graphicsOptions);\n        if (nodeGraphics.length === 0)\n            continue;\n        if (undefined !== node.layerId) {\n            const layerGraphic = 1 === nodeGraphics.length ? nodeGraphics[0] : system.createGraphicList(nodeGraphics);\n            graphics.push(system.createGraphicLayer(layerGraphic, node.layerId));\n        }\n        else if (undefined !== node.animationNodeId) {\n            const branch = new GraphicBranch(true);\n            branch.animationId = node.animationId;\n            branch.animationNodeId = node.animationNodeId;\n            branch.entries.push(...nodeGraphics);\n            graphics.push(system.createBranch(branch, Transform.createIdentity()));\n        }\n        else {\n            graphics.push(...nodeGraphics);\n        }\n    }\n    switch (graphics.length) {\n        case 0: return undefined;\n        case 1: return graphics[0];\n        default: return system.createGraphicList(graphics);\n    }\n}\n//# sourceMappingURL=ImdlGraphicsCreator.js.map",
      "start": 1693508121765,
      "end": 1693508121957,
      "sourcemaps": null
    }
  ]
}
