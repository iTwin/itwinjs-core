{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/ThematicUniforms.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { assert, dispose } from \"@itwin/core-bentley\";\nimport { Gradient, RenderTexture, ThematicDisplayMode, ThematicGradientMode } from \"@itwin/core-common\";\nimport { TextureUnit } from \"./RenderFlags\";\nimport { desync, sync } from \"./Sync\";\nimport { TextureHandle } from \"./Texture\";\nimport { ThematicSensors } from \"./ThematicSensors\";\nimport { Angle, Range3d, Vector3d } from \"@itwin/core-geometry\";\nimport { System } from \"./System\";\nimport { FloatRgb } from \"./FloatRGBA\";\n/** Maintains state for uniforms related to thematic display.\n * @internal\n */\nexport class ThematicUniforms {\n    constructor() {\n        this._range = new Float32Array(2);\n        this._colorMix = 0.0;\n        this._axis = new Float32Array(3);\n        this._sunDirection = new Float32Array(3);\n        this._marginColor = new Float32Array(3);\n        this._displayMode = new Float32Array(1);\n        this._fragSettings = new Float32Array(3); // gradientMode, distanceCutoff, stepCount\n        this._numSensors = 0;\n        this._gradientDimension = _getGradientDimension();\n        this.syncKey = 0;\n        this._scratchVector = new Vector3d();\n    }\n    get _distanceCutoff() { return this._fragSettings[1]; }\n    get thematicDisplay() {\n        return this._thematicDisplay;\n    }\n    get wantIsoLines() {\n        if (undefined !== this.thematicDisplay)\n            return ThematicDisplayMode.Height === this._displayMode[0] && ThematicGradientMode.IsoLines === this.thematicDisplay.gradientSettings.mode;\n        return false;\n    }\n    get wantSlopeMode() {\n        return (undefined !== this.thematicDisplay) ? ThematicDisplayMode.Slope === this._displayMode[0] : false;\n    }\n    get wantHillShadeMode() {\n        return (undefined !== this.thematicDisplay) ? ThematicDisplayMode.HillShade === this._displayMode[0] : false;\n    }\n    get wantGlobalSensorTexture() {\n        return !(this._distanceCutoff > 0);\n    }\n    get bytesUsed() {\n        return this._sensors ? this._sensors.bytesUsed : 0;\n    }\n    _updateAxis(axis, viewMatrix) {\n        const tAxis = (viewMatrix !== undefined) ? viewMatrix.multiplyVector(axis, this._scratchVector) : axis;\n        tAxis.normalizeInPlace();\n        this._axis[0] = tAxis.x;\n        this._axis[1] = tAxis.y;\n        this._axis[2] = tAxis.z;\n    }\n    _updateSunDirection(sunDir, viewMatrix) {\n        viewMatrix.multiplyVector(sunDir, this._scratchVector);\n        this._scratchVector.negate(this._scratchVector);\n        this._scratchVector.normalizeInPlace();\n        this._sunDirection[0] = this._scratchVector.x;\n        this._sunDirection[1] = this._scratchVector.y;\n        this._sunDirection[2] = this._scratchVector.z;\n    }\n    update(target) {\n        const plan = target.plan;\n        if (this.thematicDisplay && plan.thematic && this.thematicDisplay.equals(plan.thematic) && this._texture) {\n            if (undefined !== this._sensors)\n                this._sensors.update(target.uniforms.frustum.viewMatrix);\n            if (ThematicDisplayMode.Slope === this.thematicDisplay.displayMode) {\n                this._updateAxis(this.thematicDisplay.axis, target.uniforms.frustum.viewMatrix);\n                desync(this);\n            }\n            else if (ThematicDisplayMode.HillShade === this.thematicDisplay.displayMode) {\n                this._updateSunDirection(this.thematicDisplay.sunDirection, target.uniforms.frustum.viewMatrix);\n                desync(this);\n            }\n            return;\n        }\n        desync(this);\n        this._thematicDisplay = plan.thematic;\n        this._texture = dispose(this._texture);\n        if (!this.thematicDisplay)\n            return;\n        if (ThematicDisplayMode.Slope === this.thematicDisplay.displayMode) {\n            this._range[0] = Angle.degreesToRadians(this.thematicDisplay.range.low);\n            this._range[1] = Angle.degreesToRadians(this.thematicDisplay.range.high);\n        }\n        else {\n            this._range[0] = this.thematicDisplay.range.low;\n            this._range[1] = this.thematicDisplay.range.high;\n        }\n        this._colorMix = this.thematicDisplay.gradientSettings.colorMix;\n        this._updateAxis(this.thematicDisplay.axis, (ThematicDisplayMode.Slope === this.thematicDisplay.displayMode) ? target.uniforms.frustum.viewMatrix : undefined);\n        if (ThematicDisplayMode.HillShade === this.thematicDisplay.displayMode)\n            this._updateSunDirection(this.thematicDisplay.sunDirection, target.uniforms.frustum.viewMatrix);\n        const marginRgb = FloatRgb.fromColorDef(this.thematicDisplay.gradientSettings.marginColor);\n        this._marginColor[0] = marginRgb.red;\n        this._marginColor[1] = marginRgb.green;\n        this._marginColor[2] = marginRgb.blue;\n        this._displayMode[0] = this.thematicDisplay.displayMode;\n        this._fragSettings[0] = this.thematicDisplay.gradientSettings.mode;\n        const sensorSettings = this.thematicDisplay.sensorSettings;\n        this._fragSettings[1] = (undefined === sensorSettings) ? 0 : this.thematicDisplay.sensorSettings.distanceCutoff;\n        this._fragSettings[2] = Math.min(this.thematicDisplay.gradientSettings.stepCount, this._gradientDimension);\n        // If we want sensors and have no distance cutoff, then create a global shared sensor texture.\n        if (target.wantThematicSensors && !(this._distanceCutoff > 0)) {\n            this._numSensors = sensorSettings.sensors.length;\n            this._sensors = dispose(this._sensors);\n            this._sensors = ThematicSensors.create(target, Range3d.createNull());\n        }\n        const symb = Gradient.Symb.createThematic(this.thematicDisplay.gradientSettings);\n        const image = symb.getThematicImageForRenderer(this._gradientDimension);\n        this._texture = TextureHandle.createForImageBuffer(image, RenderTexture.Type.ThematicGradient);\n    }\n    bindRange(uniform) {\n        if (!sync(this, uniform))\n            uniform.setUniform2fv(this._range);\n    }\n    bindAxis(uniform) {\n        if (!sync(this, uniform))\n            uniform.setUniform3fv(this._axis);\n    }\n    bindSunDirection(uniform) {\n        if (!sync(this, uniform))\n            uniform.setUniform3fv(this._sunDirection);\n    }\n    bindMarginColor(uniform) {\n        if (!sync(this, uniform))\n            uniform.setUniform3fv(this._marginColor);\n    }\n    bindDisplayMode(uniform) {\n        if (!sync(this, uniform))\n            uniform.setUniform1fv(this._displayMode);\n    }\n    bindFragSettings(uniform) {\n        if (!sync(this, uniform))\n            uniform.setUniform3fv(this._fragSettings);\n    }\n    bindTexture(uniform, unit) {\n        assert(undefined !== this._texture);\n        this._texture.bindSampler(uniform, unit);\n    }\n    bindNumSensors(uniform) {\n        if (!sync(this, uniform))\n            uniform.setUniform1i(this._numSensors);\n    }\n    bindSensors(uniform) {\n        assert(undefined !== this._sensors);\n        this._sensors.texture.bindSampler(uniform, TextureUnit.ThematicSensors);\n    }\n    get isDisposed() {\n        return undefined === this._texture && undefined === this._sensors;\n    }\n    dispose() {\n        this._texture = dispose(this._texture);\n        this._sensors = dispose(this._sensors);\n    }\n}\nfunction _getGradientDimension() {\n    const preferDimension = 8192;\n    const maxDimension = System.instance.maxTextureSize;\n    return (preferDimension > maxDimension) ? maxDimension : preferDimension;\n}\n//# sourceMappingURL=ThematicUniforms.js.map",
      "start": 1693508124781,
      "end": 1693508124989,
      "sourcemaps": null
    }
  ]
}
