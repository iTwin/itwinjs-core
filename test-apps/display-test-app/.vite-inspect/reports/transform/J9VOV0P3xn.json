{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend-devtools/lib/esm/tools/TileRequestDecoration.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tools\n */\nimport { ColorDef, LinePixels } from \"@itwin/core-common\";\nimport { GraphicType, IModelApp, Tool } from \"@itwin/core-frontend\";\nimport { parseToggle } from \"./parseToggle\";\nclass TileRequestDecoration {\n    constructor(vp) {\n        /** This will allow the render system to cache and reuse the decorations created by this decorator's decorate() method. */\n        this.useCachedDecorations = true;\n        this._targetVp = vp;\n        this._removeDecorator = IModelApp.viewManager.addDecorator(this);\n    }\n    stop() {\n        if (this._removeDecorator) {\n            this._removeDecorator();\n            this._removeDecorator = undefined;\n        }\n    }\n    decorate(context) {\n        const tiles = IModelApp.tileAdmin.getRequestsForUser(this._targetVp);\n        if (undefined === tiles)\n            return;\n        const map = new Map();\n        for (const tile of tiles) {\n            let builder = map.get(tile.tree);\n            if (undefined === builder) {\n                builder = context.createGraphicBuilder(GraphicType.WorldDecoration, tile.tree.iModelTransform);\n                map.set(tile.tree, builder);\n            }\n            let color = ColorDef.white;\n            if (undefined !== tile.request)\n                color = tile.request.isQueued ? ColorDef.green : ColorDef.red;\n            builder.setSymbology(color, color, 1, LinePixels.Solid);\n            builder.addRangeBox(tile.range);\n        }\n        for (const builder of map.values())\n            context.addDecorationFromBuilder(builder);\n    }\n    static toggle(vp, enabled) {\n        const instance = TileRequestDecoration._instance;\n        if (undefined !== enabled) {\n            if ((undefined !== instance) === enabled)\n                return;\n        }\n        if (undefined === instance) {\n            TileRequestDecoration._instance = new TileRequestDecoration(vp);\n        }\n        else {\n            instance.stop();\n            TileRequestDecoration._instance = undefined;\n        }\n    }\n}\n/** Display in every viewport a range graphic for every tile currently being requested for the viewport that was initially selected when the decorator was installed.\n * Green indicates queued (http request not yet sent), red indicates active (http request sent). White indicates unexpected state.\n * @beta\n */\nclass ToggleTileRequestDecorationTool extends Tool {\n    static get minArgs() { return 0; }\n    static get maxArgs() { return 1; }\n    async run(enable) {\n        const vp = IModelApp.viewManager.selectedView;\n        if (undefined !== vp)\n            TileRequestDecoration.toggle(vp, enable);\n        return true;\n    }\n    async parseAndRun(...args) {\n        const enable = parseToggle(args[0]);\n        if (typeof enable !== \"string\")\n            await this.run(enable);\n        return true;\n    }\n}\nToggleTileRequestDecorationTool.toolId = \"ToggleTileRequestDecoration\";\nexport { ToggleTileRequestDecorationTool };\n//# sourceMappingURL=TileRequestDecoration.js.map",
      "start": 1693508122751,
      "end": 1693508122848,
      "sourcemaps": null
    }
  ]
}
