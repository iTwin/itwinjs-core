{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/BriefcaseTxns.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module IModelConnection\n */\nimport { BeEvent } from \"@itwin/core-bentley\";\nimport { EcefLocation, GeographicCRS, ipcAppChannels, } from \"@itwin/core-common\";\nimport { Point3d, Range3d } from \"@itwin/core-geometry\";\nimport { IpcApp, NotificationHandler } from \"./IpcApp\";\n/**\n * Base class for notification handlers for events from the backend that are specific to a [[BriefcaseConnection]].\n * @see [[BriefcaseTxns]].\n * @public\n */\nexport class BriefcaseNotificationHandler extends NotificationHandler {\n    constructor(_key) {\n        super();\n        this._key = _key;\n    }\n    get channelName() { return `${this.briefcaseChannelName}/${this._key}`; }\n}\n/** Manages local changes to a [[BriefcaseConnection]] via [Txns]($docs/learning/InteractiveEditing.md).\n * @see [[BriefcaseConnection.txns]].\n * @see [TxnManager]($backend) for the backend counterpart.\n * @public\n */\nexport class BriefcaseTxns extends BriefcaseNotificationHandler {\n    /** @internal */\n    get briefcaseChannelName() {\n        return ipcAppChannels.txns;\n    }\n    /** @internal */\n    constructor(iModel) {\n        super(iModel.key);\n        /** Event raised after Txn validation or changeset application to indicate the set of changed elements.\n         * @note If there are many changed elements in a single Txn, the notifications are sent in batches so this event *may be called multiple times* per Txn.\n         */\n        this.onElementsChanged = new BeEvent();\n        /** Event raised after Txn validation or changeset application to indicate the set of changed models.\n         * @note If there are many changed models in a single Txn, the notifications are sent in batches so this event *may be called multiple times* per Txn.\n         */\n        this.onModelsChanged = new BeEvent();\n        /** Event raised after the geometry within one or more [[GeometricModelState]]s is modified by applying a changeset or validation of a transaction.\n         * A model's geometry can change as a result of:\n         *  - Insertion or deletion of a geometric element within the model; or\n         *  - Modification of an existing element's geometric properties; or\n         *  - An explicit request to flag it as changed via [IModelDb.Models.updateModel]($backend).\n         */\n        this.onModelGeometryChanged = new BeEvent();\n        /** Event raised before a commit operation is performed. Initiated by a call to [[BriefcaseConnection.saveChanges]], unless there are no changes to save.\n         * @see [[onCommitted]] for the event raised after the operation.\n         */\n        this.onCommit = new BeEvent();\n        /** Event raised after a commit operation is performed. Initiated by a call to [[BriefcaseConnection.saveChanges]], even if there were no changes to save.\n         * The event supplies the following information:\n         *  - `hasPendingTxns`: true if the briefcase has local changes not yet pushed to the server.\n         *  - `time`: the time at which changes were saved on the backend (obtained via `Date.now()`).\n         * @see [[onCommit]] for the event raised before the operation.\n         */\n        this.onCommitted = new BeEvent();\n        /** Event raised for a read-only briefcase that was opened with the `watchForChanges` flag enabled when changes made by another connection are applied to the briefcase.\n         * @see [[onReplayedExternalTxns]] for the event raised after all such changes have been applied.\n         */\n        this.onReplayExternalTxns = new BeEvent();\n        /** Event raised for a read-only briefcase that was opened with the `watchForChanges` flag enabled when changes made by another connection are applied to the briefcase.\n         * @see [[onReplayExternalTxns]] for the event raised before the changes are applied.\n         */\n        this.onReplayedExternalTxns = new BeEvent();\n        /** Event raised after a changeset has been applied to the briefcase.\n         * Changesets may be applied as a result of [[BriefcaseConnection.pullChanges]], or by undo/redo operations.\n         */\n        this.onChangesApplied = new BeEvent();\n        /** Event raised before an undo/redo operation is performed.\n         * @see [[onAfterUndoRedo]] for the event raised after the operation.\n         */\n        this.onBeforeUndoRedo = new BeEvent();\n        /** Event raised after an undo/redo operation is performed.\n         * @see [[onBeforeUndoRedo]] for the event raised before to the operation.\n         */\n        this.onAfterUndoRedo = new BeEvent();\n        /** Event raised after changes are pulled and merged into the briefcase.\n         * @see [[BriefcaseConnection.pullAndMergeChanges]].\n         */\n        this.onChangesPulled = new BeEvent();\n        /** Event raised after the briefcase's local changes are pushed.\n         * @see [[BriefcaseConnection.pushChanges]].\n         */\n        this.onChangesPushed = new BeEvent();\n        this._iModel = iModel;\n        this._cleanup = this.registerImpl();\n    }\n    /** @internal */\n    dispose() {\n        if (this._cleanup) {\n            this._cleanup();\n            this._cleanup = undefined;\n            this.onElementsChanged.clear();\n            this.onModelsChanged.clear();\n            this.onModelGeometryChanged.clear();\n            this.onCommit.clear();\n            this.onCommitted.clear();\n            this.onChangesApplied.clear();\n            this.onBeforeUndoRedo.clear();\n            this.onAfterUndoRedo.clear();\n            this.onChangesPulled.clear();\n            this.onChangesPushed.clear();\n        }\n    }\n    /** Query if the briefcase has any pending Txns waiting to be pushed. */\n    async hasPendingTxns() {\n        return IpcApp.appFunctionIpc.hasPendingTxns(this._iModel.key);\n    }\n    /** Determine if any reversible (undoable) changes exist.\n     * @see [[reverseSingleTxn]] or [[reverseAll]] to undo changes.\n     */\n    async isUndoPossible() {\n        return IpcApp.appFunctionIpc.isUndoPossible(this._iModel.key);\n    }\n    /** Determine if any reinstatable (redoable) changes exist.\n     * @see [[reinstateTxn]] to redo changes.\n     */\n    async isRedoPossible() {\n        return IpcApp.appFunctionIpc.isRedoPossible(this._iModel.key);\n    }\n    /** Get the description of the operation that would be reversed by calling [[reverseTxns]]`(1)`.\n     * This is useful for showing the operation that would be undone, for example in a menu.\n     */\n    async getUndoString() {\n        return IpcApp.appFunctionIpc.getUndoString(this._iModel.key);\n    }\n    /** Get a description of the operation that would be reinstated by calling [[reinstateTxn]].\n     * This is useful for showing the operation that would be redone, in a pull-down menu for example.\n     */\n    async getRedoString() {\n        return IpcApp.appFunctionIpc.getRedoString(this._iModel.key);\n    }\n    /** Reverse (undo) the most recent operation.\n     * @see [[reinstateTxn]] to redo operations.\n     * @see [[reverseAll]] to undo all operations.\n     * @see [[isUndoPossible]] to determine if any reversible operations exist.\n     */\n    async reverseSingleTxn() {\n        return this.reverseTxns(1);\n    }\n    /** Reverse (undo) the most recent operation(s) to the briefcase in the current session.\n     * @param numOperations the number of operations to reverse. If this is greater than 1, the entire set of operations will\n     *  be reinstated together when/if [[reinstateTxn]] is called.\n     * @note If there are any outstanding uncommitted changes, they are reversed.\n     * @note The term \"operation\" is used rather than Txn, since multiple Txns can be grouped together via [TxnManager.beginMultiTxnOperation]($backend). So,\n     * even if numOperations is 1, multiple Txns may be reversed if they were grouped together when they were made.\n     * @note If numOperations is too large only the number of reversible operations are reversed.\n     */\n    async reverseTxns(numOperations) {\n        return IpcApp.appFunctionIpc.reverseTxns(this._iModel.key, numOperations);\n    }\n    /** Reverse (undo) all changes back to the beginning of the session.\n     * @see [[reinstateTxn]] to redo changes.\n     * @see [[reverseSingleTxn]] to undo only the most recent operation.\n     * @see [[isUndoPossible]] to determine if any reversible operations exist.\n     */\n    async reverseAll() {\n        return IpcApp.appFunctionIpc.reverseAllTxn(this._iModel.key);\n    }\n    /** Reinstate (redo) the most recently reversed transaction. Since at any time multiple transactions can be reversed, it\n     * may take multiple calls to this method to reinstate all reversed operations.\n     * @returns Success if a reversed transaction was reinstated, error status otherwise.\n     * @note If there are any outstanding uncommitted changes, they are canceled before the Txn is reinstated.\n     * @see [[isRedoPossible]] to determine if any reinstatable operations exist.\n     * @see [[reverseSingleTxn]] or [[reverseAll]] to undo changes.\n     */\n    async reinstateTxn() {\n        return IpcApp.appFunctionIpc.reinstateTxn(this._iModel.key);\n    }\n    /** Restart the current TxnManager session. This causes all Txns in the current session to no longer be undoable (as if the file was closed\n     * and reopened.)\n     * @note This can be quite disconcerting to the user expecting to be able to undo previously made changes. It should only be used\n     * under extreme circumstances where damage to the file or session could happen if the currently committed are reversed. Use sparingly and with care.\n     * Probably a good idea to alert the user it happened.\n     */\n    async restartTxnSession() {\n        await IpcApp.appFunctionIpc.restartTxnSession(this._iModel.key);\n    }\n    /** @internal */\n    notifyElementsChanged(changed) {\n        this.onElementsChanged.raiseEvent(changed);\n    }\n    /** @internal */\n    notifyModelsChanged(changed) {\n        this.onModelsChanged.raiseEvent(changed);\n    }\n    /** @internal */\n    notifyGeometryGuidsChanged(changes) {\n        this.onModelGeometryChanged.raiseEvent(changes);\n    }\n    /** @internal */\n    notifyCommit() {\n        this.onCommit.raiseEvent();\n    }\n    /** @internal */\n    notifyCommitted(hasPendingTxns, time) {\n        this.onCommitted.raiseEvent(hasPendingTxns, time);\n    }\n    /** @internal */\n    notifyReplayExternalTxns() {\n        this.onReplayExternalTxns.raiseEvent();\n    }\n    /** @internal */\n    notifyReplayedExternalTxns() {\n        this.onReplayedExternalTxns.raiseEvent();\n    }\n    /** @internal */\n    notifyChangesApplied() {\n        this.onChangesApplied.raiseEvent();\n    }\n    /** @internal */\n    notifyBeforeUndoRedo(isUndo) {\n        this.onBeforeUndoRedo.raiseEvent(isUndo);\n    }\n    /** @internal */\n    notifyAfterUndoRedo(isUndo) {\n        this.onAfterUndoRedo.raiseEvent(isUndo);\n    }\n    /** @internal */\n    notifyPulledChanges(parentChangeset) {\n        this.onChangesPulled.raiseEvent(parentChangeset);\n    }\n    /** @internal */\n    notifyPushedChanges(parentChangeset) {\n        this.onChangesPushed.raiseEvent(parentChangeset);\n    }\n    /** @internal */\n    notifyIModelNameChanged(name) {\n        this._iModel.name = name;\n    }\n    /** @internal */\n    notifyRootSubjectChanged(subject) {\n        this._iModel.rootSubject = subject;\n    }\n    /** @internal */\n    notifyProjectExtentsChanged(range) {\n        this._iModel.projectExtents = Range3d.fromJSON(range);\n    }\n    /** @internal */\n    notifyGlobalOriginChanged(origin) {\n        this._iModel.globalOrigin = Point3d.fromJSON(origin);\n    }\n    /** @internal */\n    notifyEcefLocationChanged(ecef) {\n        this._iModel.ecefLocation = ecef ? new EcefLocation(ecef) : undefined;\n    }\n    /** @internal */\n    notifyGeographicCoordinateSystemChanged(gcs) {\n        this._iModel.geographicCoordinateSystem = gcs ? new GeographicCRS(gcs) : undefined;\n    }\n}\n//# sourceMappingURL=BriefcaseTxns.js.map",
      "start": 1693508118460,
      "end": 1693508119061,
      "sourcemaps": null
    }
  ]
}
