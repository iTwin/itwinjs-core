{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/EdgeGeometry.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { assert, dispose } from \"@itwin/core-bentley\";\nimport { RenderMode } from \"@itwin/core-common\";\nimport { RenderMemory } from \"../RenderMemory\";\nimport { AttributeMap } from \"./AttributeMap\";\nimport { PolylineBuffers } from \"./CachedGeometry\";\nimport { GL } from \"./GL\";\nimport { BufferHandle, BufferParameters, BuffersContainer } from \"./AttributeBuffers\";\nimport { System } from \"./System\";\nimport { MeshGeometry } from \"./MeshGeometry\";\n/** @internal */\nexport class EdgeGeometry extends MeshGeometry {\n    get lutBuffers() { return this.buffers; }\n    get asSurface() { return undefined; }\n    get asEdge() { return this; }\n    get asSilhouette() { return undefined; }\n    static create(mesh, edges) {\n        const indexBuffer = BufferHandle.createArrayBuffer(edges.indices.data);\n        const endPointBuffer = BufferHandle.createArrayBuffer(edges.endPointAndQuadIndices);\n        return undefined !== indexBuffer && undefined !== endPointBuffer ? new EdgeGeometry(indexBuffer, endPointBuffer, edges.indices.length, mesh) : undefined;\n    }\n    get isDisposed() {\n        return this.buffers.isDisposed\n            && this._indices.isDisposed\n            && this._endPointAndQuadIndices.isDisposed;\n    }\n    dispose() {\n        dispose(this.buffers);\n        dispose(this._indices);\n        dispose(this._endPointAndQuadIndices);\n    }\n    collectStatistics(stats) {\n        stats.addVisibleEdges(this._indices.bytesUsed + this._endPointAndQuadIndices.bytesUsed);\n    }\n    _draw(numInstances, instanceBuffersContainer) {\n        const bufs = instanceBuffersContainer !== undefined ? instanceBuffersContainer : this.buffers;\n        bufs.bind();\n        System.instance.drawArrays(GL.PrimitiveType.Triangles, 0, this._numIndices, numInstances);\n        bufs.unbind();\n    }\n    _wantWoWReversal(_target) { return true; }\n    _getLineCode(params) { return this.computeEdgeLineCode(params); }\n    get techniqueId() { return 4 /* TechniqueId.Edge */; }\n    getPass(target) { return this.computeEdgePass(target); }\n    get renderOrder() { return this.isPlanar ? 14 /* RenderOrder.PlanarEdge */ : 6 /* RenderOrder.Edge */; }\n    getColor(target) { return this.computeEdgeColor(target); }\n    get endPointAndQuadIndices() { return this._endPointAndQuadIndices; }\n    wantMonochrome(target) {\n        return target.currentViewFlags.renderMode === RenderMode.Wireframe;\n    }\n    constructor(indices, endPointAndQuadsIndices, numIndices, mesh) {\n        super(mesh, numIndices);\n        this.buffers = BuffersContainer.create();\n        const attrPos = AttributeMap.findAttribute(\"a_pos\", 4 /* TechniqueId.Edge */, false);\n        const attrEndPointAndQuadIndices = AttributeMap.findAttribute(\"a_endPointAndQuadIndices\", 4 /* TechniqueId.Edge */, false);\n        assert(attrPos !== undefined);\n        assert(attrEndPointAndQuadIndices !== undefined);\n        this.buffers.addBuffer(indices, [BufferParameters.create(attrPos.location, 3, GL.DataType.UnsignedByte, false, 0, 0, false)]);\n        this.buffers.addBuffer(endPointAndQuadsIndices, [BufferParameters.create(attrEndPointAndQuadIndices.location, 4, GL.DataType.UnsignedByte, false, 0, 0, false)]);\n        this._indices = indices;\n        this._endPointAndQuadIndices = endPointAndQuadsIndices;\n    }\n}\n/** @internal */\nexport class SilhouetteEdgeGeometry extends EdgeGeometry {\n    get asSilhouette() { return this; }\n    static createSilhouettes(mesh, params) {\n        const indexBuffer = BufferHandle.createArrayBuffer(params.indices.data);\n        const endPointBuffer = BufferHandle.createArrayBuffer(params.endPointAndQuadIndices);\n        const normalsBuffer = BufferHandle.createArrayBuffer(params.normalPairs);\n        return undefined !== indexBuffer && undefined !== endPointBuffer && undefined !== normalsBuffer ? new SilhouetteEdgeGeometry(indexBuffer, endPointBuffer, normalsBuffer, params.indices.length, mesh) : undefined;\n    }\n    get isDisposed() { return super.isDisposed && this._normalPairs.isDisposed; }\n    dispose() {\n        super.dispose();\n        dispose(this._normalPairs);\n    }\n    collectStatistics(stats) {\n        stats.addSilhouetteEdges(this._indices.bytesUsed + this._endPointAndQuadIndices.bytesUsed + this._normalPairs.bytesUsed);\n    }\n    get techniqueId() { return 5 /* TechniqueId.SilhouetteEdge */; }\n    get renderOrder() { return this.isPlanar ? 15 /* RenderOrder.PlanarSilhouette */ : 7 /* RenderOrder.Silhouette */; }\n    get normalPairs() { return this._normalPairs; }\n    constructor(indices, endPointAndQuadsIndices, normalPairs, numIndices, mesh) {\n        super(indices, endPointAndQuadsIndices, numIndices, mesh);\n        const attrNormals = AttributeMap.findAttribute(\"a_normals\", 5 /* TechniqueId.SilhouetteEdge */, false);\n        assert(attrNormals !== undefined);\n        this.buffers.addBuffer(normalPairs, [BufferParameters.create(attrNormals.location, 4, GL.DataType.UnsignedByte, false, 0, 0, false)]);\n        this._normalPairs = normalPairs;\n    }\n}\n/** @internal */\nexport class PolylineEdgeGeometry extends MeshGeometry {\n    get lutBuffers() { return this._buffers.buffers; }\n    static create(mesh, polyline) {\n        const buffers = PolylineBuffers.create(polyline);\n        return undefined !== buffers ? new PolylineEdgeGeometry(polyline.indices.length, buffers, mesh) : undefined;\n    }\n    get isDisposed() { return this._buffers.isDisposed; }\n    dispose() {\n        dispose(this._buffers);\n    }\n    collectStatistics(stats) {\n        this._buffers.collectStatistics(stats, RenderMemory.BufferType.PolylineEdges);\n    }\n    _wantWoWReversal(_target) { return true; }\n    _getLineWeight(params) { return this.computeEdgeWeight(params); }\n    _getLineCode(params) { return this.computeEdgeLineCode(params); }\n    getColor(target) { return this.computeEdgeColor(target); }\n    get techniqueId() { return 1 /* TechniqueId.Polyline */; }\n    getPass(target) { return this.computeEdgePass(target); }\n    get renderOrder() { return this.isPlanar ? 14 /* RenderOrder.PlanarEdge */ : 6 /* RenderOrder.Edge */; }\n    get polylineBuffers() { return this._buffers; }\n    wantMonochrome(target) {\n        return target.currentViewFlags.renderMode === RenderMode.Wireframe;\n    }\n    _draw(numInstances, instanceBuffersContainer) {\n        const gl = System.instance;\n        const bufs = instanceBuffersContainer !== undefined ? instanceBuffersContainer : this._buffers.buffers;\n        bufs.bind();\n        gl.drawArrays(GL.PrimitiveType.Triangles, 0, this._numIndices, numInstances);\n        bufs.unbind();\n    }\n    constructor(numIndices, buffers, mesh) {\n        super(mesh, numIndices);\n        this._buffers = buffers;\n    }\n}\n//# sourceMappingURL=EdgeGeometry.js.map",
      "start": 1693508125807,
      "end": 1693508125874,
      "sourcemaps": null
    }
  ]
}
