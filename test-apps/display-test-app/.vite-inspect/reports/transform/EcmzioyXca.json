{
  "resolvedId": "D:/hub2023A/itwinjs-core/extensions/map-layers-formats/lib/esm/ArcGisFeature/ArcGisFeatureProvider.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\nvar _a;\nimport { ImageSource, ImageSourceFormat, ServerError } from \"@itwin/core-common\";\nimport { base64StringToUint8Array, IModelStatus, Logger } from \"@itwin/core-bentley\";\nimport { Matrix4d, Point3d, Range2d } from \"@itwin/core-geometry\";\nimport { ArcGisErrorCode, ArcGisGraphicsRenderer, ArcGISImageryProvider, ArcGisUtilities, MapCartoRectangle, MapLayerImageryProviderStatus } from \"@itwin/core-frontend\";\nimport { ArcGisSymbologyRenderer } from \"./ArcGisSymbologyRenderer\";\nimport { ArcGisFeatureQuery } from \"./ArcGisFeatureQuery\";\nimport { ArcGisPbfFeatureReader } from \"./ArcGisPbfFeatureReader\";\nimport { ArcGisJsonFeatureReader } from \"./ArcGisJsonFeatureReader\";\nimport { ArcGisFeatureResponse } from \"./ArcGisFeatureResponse\";\nimport { ArcGisCanvasRenderer } from \"./ArcGisCanvasRenderer\";\nimport { EsriPMS, EsriRenderer, EsriSFS, EsriSLS } from \"./EsriSymbology\";\nconst loggerCategory = \"MapLayersFormats.ArcGISFeature\";\n/**  Provide tiles from a ESRI ArcGIS Feature service\n* @internal\n*/\nclass ArcGisFeatureProvider extends ArcGISImageryProvider {\n    get minimumZoomLevel() { return this._minDepthFromLod; }\n    get maximumZoomLevel() { return this._maxDepthFromLod; }\n    constructor(settings) {\n        super(settings, true);\n        // Debug flags, should always be committed to FALSE !\n        this._drawDebugInfo = false;\n        this._debugFeatureGeom = false;\n        this._supportsCoordinatesQuantization = false;\n        this._layerId = 0;\n        this._outSR = 102100;\n        this._maxDepthFromLod = 0;\n        this._minDepthFromLod = 0;\n    }\n    async initialize() {\n        const metadata = await this.getServiceJson();\n        const json = metadata?.content;\n        if (json === undefined) {\n            Logger.logError(loggerCategory, \"Could not get service JSON\");\n            throw new ServerError(IModelStatus.ValidationFailed, \"\");\n        }\n        if (json?.error?.code === ArcGisErrorCode.TokenRequired || json?.error?.code === ArcGisErrorCode.InvalidToken) {\n            // Check again layer status, it might have change during await.\n            if (this.status === MapLayerImageryProviderStatus.Valid) {\n                this.setStatus(MapLayerImageryProviderStatus.RequireAuth);\n                return;\n            }\n        }\n        if (json.capabilities) {\n            this._querySupported = json.capabilities.indexOf(\"Query\") >= 0;\n            if (!this._querySupported)\n                throw new ServerError(IModelStatus.ValidationFailed, \"\");\n        }\n        this.serviceJson = json;\n        let foundVisibleSubLayer = false;\n        if (this._settings.subLayers.length >= 0) {\n            // There is more than sub-layer for this layer, pick the first visible one.\n            for (const layer of this._settings.subLayers) {\n                if (layer.visible && typeof layer.id === \"number\") {\n                    this._layerId = layer.id;\n                    foundVisibleSubLayer = true;\n                    break;\n                }\n            }\n        }\n        if (!foundVisibleSubLayer && json !== undefined) {\n            // No suitable sublayer was specified on the layerSettings object, lets find a default one in the capabilities\n            // Check layer metadata\n            if (Array.isArray(this.serviceJson.layers) && this.serviceJson.layers.length >= 1) {\n                const hasDefaultVisibility = Object.keys(this.serviceJson.layers[0]).includes(\"defaultVisibility\");\n                if (hasDefaultVisibility) {\n                    for (const layer of this.serviceJson.layers) {\n                        if (layer.defaultVisibility) {\n                            this._layerId = layer.id;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    // On some older servers, the default visiblity is on the layer capabilities (i.e. not the service capabilities)\n                    for (const layer of this.serviceJson.layers) {\n                        const layerJson = await this.getLayerMetadata(layer.id);\n                        if (!layerJson) {\n                            continue;\n                        }\n                        if (layerJson.defaultVisibility) {\n                            this._layerId = layer.id;\n                            this._layerMetadata = layerJson;\n                            break;\n                        }\n                    }\n                }\n            }\n            else {\n                // There is no layer to publish? Something is off with this server..\n                throw new ServerError(IModelStatus.ValidationFailed, \"\");\n            }\n        }\n        // Make sure we cache layer info (i.e. rendering info)\n        if (!this._layerMetadata) {\n            this._layerMetadata = await this.getLayerMetadata(this._layerId);\n            if (!this._layerMetadata) {\n                Logger.logError(loggerCategory, \"Could not layer metadata\");\n                throw new ServerError(IModelStatus.ValidationFailed, \"\");\n            }\n        }\n        // Parse server version\n        let majorVersion;\n        if (this.serviceJson?.currentVersion) {\n            try {\n                majorVersion = Math.trunc(this.serviceJson?.currentVersion);\n            }\n            catch {\n            }\n        }\n        // Coordinates Quantization:  If supported, server will transform for us the coordinates in the Tile coordinate space (pixels, origin = upper left corner\n        // If not supported, transformation will be applied client side.\n        // Note: For some reasons, even though 'supportsCoordinatesQuantization' is set to 'true' on the layer metadata, server will give an error message for server version < 11\n        if (majorVersion && majorVersion >= 11 && this._layerMetadata.supportsCoordinatesQuantization) {\n            this._supportsCoordinatesQuantization = true;\n        }\n        // Check supported query formats: JSON and PBF are currently implemented by this provider\n        // Note: needs to be checked on the layer metadata, service metadata advertises a different set of formats\n        //       Also, since PBF format does not support floating points, there is no point using this format if supportsCoordinatesQuantization is not available.\n        if (this._layerMetadata.supportedQueryFormats) {\n            const formats = this._layerMetadata.supportedQueryFormats.split(\", \");\n            if (formats.includes(\"PBF\") && this._supportsCoordinatesQuantization) {\n                this._format = \"PBF\";\n            }\n            else if (formats.includes(\"JSON\")) {\n                this._format = \"JSON\";\n            }\n        }\n        if (!this._format) {\n            Logger.logError(loggerCategory, \"Could not get request format from service JSON\");\n            throw new ServerError(IModelStatus.ValidationFailed, \"\");\n        }\n        // Read range using full extent from service metadata\n        if (this._layerMetadata?.extent) {\n            const layerExtent = this._layerMetadata.extent;\n            if (layerExtent.spatialReference.latestWkid === 3857 || layerExtent.spatialReference.wkid === 102100) {\n                this.setCartoRangeFromExtentJson(layerExtent);\n            }\n        }\n        if (!this.cartoRange) {\n            // Range could not be found (or is not in a coordinate system we support), make a request to compute the extent\n            try {\n                const extentJson = await this.fetchLayerExtent();\n                if (extentJson)\n                    this.setCartoRangeFromExtentJson(extentJson);\n                else\n                    Logger.logWarning(loggerCategory, `Could not get features extent, disabling extent filtering`);\n            }\n            catch {\n                Logger.logError(loggerCategory, `Could not get feature extent`);\n            }\n        }\n        // Check for minScale / max scale\n        const minScale = this._layerMetadata?.minScale || undefined; // undefined, 0 -> undefined\n        const maxScale = this._layerMetadata?.maxScale || undefined; // undefined, 0 -> undefined\n        const scales = ArcGisUtilities.getZoomLevelsScales(this.defaultMaximumZoomLevel, this.tileSize, minScale, maxScale, 1.0);\n        if (scales.minLod)\n            this._minDepthFromLod = scales.minLod;\n        // Some servers advertises a max LOD of 0, it should be interpreted as 'not defined' (otherwise a max lod of 0 would would mean never display anything)\n        this._maxDepthFromLod = (scales.maxLod ? scales.maxLod : this.defaultMaximumZoomLevel);\n        this._defaultSymbol = ArcGisFeatureProvider.getDefaultSymbology(this._layerMetadata?.geometryType);\n        if (!this._defaultSymbol) {\n            Logger.logError(loggerCategory, \"Could not determine default symbology: geometry type not supported\");\n            throw new Error(\"Could not determine default symbology: geometry type not supported\");\n        }\n        if (this._defaultSymbol.type === \"esriPMS\") {\n            await this._defaultSymbol.loadImage();\n        }\n        try {\n            this._renderer = EsriRenderer.fromJSON(this._layerMetadata?.drawingInfo?.renderer);\n            await this._renderer.initialize();\n        }\n        catch {\n            Logger.logError(loggerCategory, `Could not initialize symbology renderer`);\n        }\n    }\n    static getDefaultSymbology(geomType) {\n        if (geomType) {\n            if (geomType === \"esriGeometryPoint\" || geomType === \"esriGeometryMultipoint\") {\n                return EsriPMS.fromJSON(ArcGisFeatureProvider.defaultPMS);\n            }\n            else if (geomType === \"esriGeometryLine\" || geomType === \"esriGeometryPolyline\") {\n                return EsriSLS.fromJSON(ArcGisFeatureProvider.defaultSLS);\n            }\n            else if (geomType === \"esriGeometryPolygon\") {\n                return EsriSFS.fromJSON(ArcGisFeatureProvider.defaultSFS);\n            }\n        }\n        return undefined;\n    }\n    async fetchLayerExtent() {\n        let extentJson;\n        const tmpUrl = new URL(this._settings.url);\n        tmpUrl.pathname = `${tmpUrl.pathname}/${this._layerId}/query`;\n        tmpUrl.searchParams.append(\"where\", \"1=1\");\n        tmpUrl.searchParams.append(\"outSR\", \"3857\");\n        tmpUrl.searchParams.append(\"returnExtentOnly\", \"true\");\n        tmpUrl.searchParams.append(\"f\", \"json\");\n        const cached = ArcGisFeatureProvider._extentCache.get(tmpUrl.toString());\n        if (cached) {\n            extentJson = cached;\n        }\n        else {\n            const response = await this.fetch(tmpUrl, { method: \"GET\" });\n            extentJson = await response.json();\n            ArcGisFeatureProvider._extentCache.set(tmpUrl.toString(), extentJson);\n        }\n        return (extentJson ? extentJson.extent : undefined);\n    }\n    setCartoRangeFromExtentJson(extent) {\n        const range3857 = Range2d.createFrom({\n            low: { x: extent.xmin, y: extent.ymin },\n            high: { x: extent.xmax, y: extent.ymax },\n        });\n        const west = this.getEPSG4326Lon(range3857.xLow);\n        const south = this.getEPSG4326Lat(range3857.yLow);\n        const east = this.getEPSG4326Lon(range3857.xHigh);\n        const north = this.getEPSG4326Lat(range3857.yHigh);\n        this.cartoRange = MapCartoRectangle.fromDegrees(west, south, east, north);\n    }\n    async getLayerMetadata(layerId) {\n        let metadata;\n        try {\n            const url = new URL(this._settings.url);\n            url.pathname = `${url.pathname}/${layerId}`;\n            metadata = await ArcGisUtilities.getServiceJson(url.toString(), this._settings.formatId, this._settings.userName, this._settings.password, this._accessTokenRequired);\n        }\n        catch {\n        }\n        return metadata?.content;\n    }\n    get tileSize() { return 512; }\n    get format() { return this._format; }\n    // We don't use this method inside this provider (see constructFeatureUrl), but since this is an abstract method, we need to define something\n    async constructUrl(_row, _column, _zoomLevel) {\n        return \"\";\n    }\n    constructFeatureUrl(row, column, zoomLevel, format, resultType, geomOverride, outFields, tolerance, returnGeometry, maxAllowableOffset) {\n        const tileExtent = this.getEPSG3857Extent(row, column, zoomLevel);\n        const tileEnvelope = {\n            xmin: tileExtent.left, ymin: tileExtent.bottom,\n            xmax: tileExtent.right, ymax: tileExtent.top,\n            spatialReference: { wkid: 102100, latestWkid: 3857 },\n        };\n        // Actual spatial filter.\n        // By default, we request the tile extent.  If 'cartoPoint' is specified,\n        // we restrict the spatial to specific point. (i.e. GetFeatureInfo requests)\n        // If envelope is provided, it has the priority over 'cartoPoint'\n        let geometry;\n        if (geomOverride) {\n            geometry = geomOverride;\n        }\n        else {\n            geometry = { geom: tileEnvelope, type: \"esriGeometryEnvelope\" };\n        }\n        let quantizationParameters;\n        const toleranceWorld = (tileExtent.top - tileExtent.bottom) / this.tileSize;\n        if (resultType === \"tile\" && this._supportsCoordinatesQuantization) {\n            quantizationParameters = {\n                mode: \"view\",\n                originPosition: \"upperLeft\",\n                tolerance: toleranceWorld,\n                extent: tileEnvelope,\n            };\n        }\n        const url = new ArcGisFeatureQuery(this._settings.url, this._layerId, format, this._outSR, {\n            geometry,\n            geometryType: \"esriGeometryEnvelope\",\n            returnExceededLimitFeatures: false,\n            maxRecordCountFactor: 3,\n            resultType,\n            quantizationParameters,\n            outFields,\n            returnGeometry,\n            distance: (tolerance ? tolerance * toleranceWorld : undefined),\n            maxAllowableOffset,\n        });\n        let envelope;\n        if (geomOverride && geomOverride.type === \"esriGeometryEnvelope\") {\n            envelope = geomOverride.geom;\n        }\n        else {\n            envelope = tileEnvelope;\n        }\n        return { url: url.toString(), envelope };\n    }\n    // Makes an identify request to ESRI MapService , and return it as a list MapLayerFeatureInfo object\n    async getFeatureInfo(featureInfos, quadId, carto, _tree, hit) {\n        if (!this._querySupported || this.format === undefined)\n            return;\n        const epsg3857X = this.getEPSG3857X(carto.longitudeDegrees);\n        const epsg3857Y = this.getEPSG3857Y(carto.latitudeDegrees);\n        const tileExtent = this.getEPSG3857Extent(quadId.row, quadId.column, quadId.level);\n        const tilePixelSize = (tileExtent.top - tileExtent.bottom) / this.tileSize;\n        const tolerancePixel = 3;\n        const toleranceWorld = tilePixelSize * tolerancePixel;\n        // Note: We used to pass a single point as the query 'geometry' and leverage the 'distance' parameter, turns\n        // out that approach was a lot slower on some server compared to using a single envelope.\n        const queryEnvelope = {\n            type: \"esriGeometryEnvelope\",\n            geom: {\n                xmin: epsg3857X - toleranceWorld, ymin: epsg3857Y - toleranceWorld,\n                xmax: epsg3857X + toleranceWorld, ymax: epsg3857Y + toleranceWorld,\n                spatialReference: { wkid: 102100, latestWkid: 3857 },\n            }\n        };\n        const doFeatureInfoQuery = async (format, outFields, returnGeometry) => {\n            const infoUrl = this.constructFeatureUrl(quadId.row, quadId.column, quadId.level, format, \"standard\", queryEnvelope, outFields, undefined, returnGeometry, toleranceWorld);\n            if (!infoUrl || infoUrl.url.length === 0) {\n                Logger.logError(loggerCategory, `Could not construct feature info query URL`);\n                return undefined;\n            }\n            const response = this.fetch(new URL(infoUrl.url), { method: \"GET\" });\n            const featureResponse = new ArcGisFeatureResponse(format, response);\n            return featureResponse.getResponseData();\n        };\n        if (this._debugFeatureGeom) {\n            try {\n                let responseData = await doFeatureInfoQuery(\"PBF\", \"\", true);\n                if (responseData) {\n                    const json = JSON.stringify(responseData.data.toObject());\n                    Logger.logInfo(loggerCategory, json);\n                }\n                responseData = await doFeatureInfoQuery(\"JSON\", \"\", true);\n                if (responseData) {\n                    const json = JSON.stringify(responseData.data);\n                    Logger.logInfo(loggerCategory, json);\n                }\n            }\n            catch (e) {\n                Logger.logInfo(loggerCategory, `Error occurred with debug FeatureInfo: ${e}`);\n            }\n        }\n        try {\n            // Feature Info requests are always made in JSON for now.\n            const responseData = await doFeatureInfoQuery(\"JSON\", \"*\", true);\n            if (!responseData) {\n                Logger.logError(loggerCategory, `Could not get feature info data`);\n                return;\n            }\n            if (responseData.exceedTransferLimit) {\n                Logger.logError(loggerCategory, `Could not get feature info : transfer limit exceeded.`);\n                return;\n            }\n            const featureReader = new ArcGisJsonFeatureReader(this._settings, this._layerMetadata);\n            const renderer = new ArcGisGraphicsRenderer(hit.iModel);\n            await featureReader.readFeatureInfo(responseData, featureInfos, renderer);\n        }\n        catch (e) {\n            Logger.logError(loggerCategory, `Exception occurred while loading feature info data : ${e}`);\n            return;\n        }\n        return;\n    }\n    async fetchTile(row, column, zoomLevel, refineEnvelope) {\n        if (!this.format) {\n            return undefined;\n        }\n        const geomOverride = (refineEnvelope ? { geom: refineEnvelope, type: \"esriGeometryEnvelope\" } : undefined);\n        let outFields;\n        if (this._renderer?.type === \"uniqueValue\") {\n            const uvRenderer = this._renderer;\n            if (uvRenderer.field1)\n                outFields = uvRenderer.field1;\n        }\n        const tileUrl = this.constructFeatureUrl(row, column, zoomLevel, this.format, \"tile\", geomOverride, outFields);\n        if (!tileUrl || tileUrl.url.length === 0) {\n            Logger.logError(loggerCategory, `Could not construct feature query URL for tile ${zoomLevel}/${row}/${column}`);\n            return undefined;\n        }\n        const response = this.fetch(new URL(tileUrl.url), { method: \"GET\" });\n        return new ArcGisFeatureResponse(this.format, response, tileUrl.envelope);\n    }\n    drawTileDebugInfo(row, column, zoomLevel, context) {\n        context.fillStyle = \"cyan\";\n        context.strokeRect(0, 0, this.tileSize, this.tileSize);\n        context.font = \"30px Arial\";\n        context.lineWidth = 5;\n        context.fillText(`${zoomLevel}-${row}-${column}`, 10, 50);\n    }\n    // Compute transform that provides coordinates in the canvas coordinate system (pixels, origin = top-left)\n    // from coordinate in world (i.e EPSG:3857)\n    computeTileWorld2CanvasTransform(row, column, zoomLevel) {\n        const tileExtentWorld3857 = this.getEPSG3857Extent(row, column, zoomLevel);\n        const worldTileWidth = tileExtentWorld3857.right - tileExtentWorld3857.left;\n        const canvasTileWidth = this.tileSize;\n        const world2CanvasRatio = canvasTileWidth / worldTileWidth;\n        const worldTileOrigin = Point3d.create(tileExtentWorld3857.left, tileExtentWorld3857.bottom);\n        const worldTileExtent = Point3d.create(tileExtentWorld3857.right, tileExtentWorld3857.top);\n        const canvasTileOriginOffset = worldTileOrigin.clone();\n        const canvasTileExtentOffset = worldTileExtent.clone();\n        canvasTileOriginOffset.scaleInPlace(world2CanvasRatio);\n        canvasTileExtentOffset.scaleInPlace(world2CanvasRatio);\n        const xTranslate = -1 * canvasTileOriginOffset.x;\n        // Canvas origin is uppler left corner, so we need to flip the y axsis\n        const yTranslate = canvasTileExtentOffset.y; // y-axis flip\n        const yWorld2CanvasRatio = -1 * world2CanvasRatio; // y-axis flip\n        const matrix = Matrix4d.createTranslationAndScaleXYZ(xTranslate, yTranslate, 0, world2CanvasRatio, yWorld2CanvasRatio, 1);\n        return matrix.asTransform;\n    }\n    async loadTile(row, column, zoomLevel) {\n        if ((this.status === MapLayerImageryProviderStatus.RequireAuth)) {\n            return undefined;\n        }\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = this.tileSize;\n        canvas.height = this.tileSize;\n        const ctx = canvas.getContext(\"2d\");\n        if (ctx == null) {\n            Logger.logError(loggerCategory, \"No canvas context available for loading tile.\");\n            return undefined;\n        }\n        try {\n            // Compute transform if CoordinatesQuantization is not supported by service\n            let transfo;\n            if (!this._supportsCoordinatesQuantization) {\n                transfo = this.computeTileWorld2CanvasTransform(row, column, zoomLevel);\n                if (!transfo) {\n                    Logger.logError(loggerCategory, `Could not compute data transformation for tile (${zoomLevel}/${row}/${column})`);\n                }\n            }\n            // Create the renderer\n            const symbRenderer = ArcGisSymbologyRenderer.create(this._renderer, this._defaultSymbol);\n            const renderer = new ArcGisCanvasRenderer(ctx, symbRenderer, transfo);\n            const featureReader = this.format === \"PBF\" ? new ArcGisPbfFeatureReader(this._settings, this._layerMetadata) : new ArcGisJsonFeatureReader(this._settings, this._layerMetadata);\n            const getSubEnvelopes = (envelope) => {\n                const dx = (envelope.xmax - envelope.xmin) * 0.5;\n                const dy = (envelope.xmax - envelope.xmin) * 0.5;\n                const subEnvelopes = [];\n                for (let posX = 0; posX < ArcGisFeatureProvider._nbSubTiles; posX++) {\n                    for (let posY = 0; posY < ArcGisFeatureProvider._nbSubTiles; posY++) {\n                        subEnvelopes.push({\n                            xmin: envelope.xmin + (dx * posX), ymin: envelope.ymin + (dy * posY),\n                            xmax: envelope.xmin + (dx * (posX + 1)), ymax: envelope.ymin + (dy * (posY + 1)),\n                            spatialReference: { wkid: 102100, latestWkid: 3857 },\n                        });\n                    }\n                }\n                return subEnvelopes;\n            };\n            // The strategy here is simple: we make a request for an area that represents the current tile (i.e envelope),\n            // the server will either return the requested data OR a 'exceedTransferLimit' message (too much data to transfers).\n            // In the latter case, we subdivide the previous request envelope in for 4 sub-envelopes,\n            // and repeat again until we get data.\n            const renderData = async (envelope) => {\n                let response;\n                let responseData;\n                try {\n                    response = await this.fetchTile(row, column, zoomLevel, envelope);\n                    if (!response) {\n                        Logger.logError(loggerCategory, `Error occurred while fetching tile (${zoomLevel}/${row}/${column})`);\n                        return;\n                    }\n                    responseData = await response.getResponseData();\n                    if (!responseData) {\n                        Logger.logError(loggerCategory, `Could not get response data for tile (${zoomLevel}/${row}/${column})`);\n                        return;\n                    }\n                }\n                catch (e) {\n                    Logger.logError(loggerCategory, `Exception occurred while loading tile (${zoomLevel}/${row}/${column}) : ${e}`);\n                    return;\n                }\n                if (responseData.exceedTransferLimit) {\n                    if (response.envelope) {\n                        const subEnvelopes = getSubEnvelopes(response.envelope);\n                        const renderPromises = [];\n                        for (const subEnvelope of subEnvelopes) {\n                            renderPromises.push(renderData(subEnvelope));\n                        }\n                        await Promise.all(renderPromises);\n                    }\n                    else {\n                        Logger.logError(loggerCategory, `Request exceeded transfer limit, could not refine request`);\n                    }\n                }\n                else {\n                    await featureReader.readAndRender(responseData, renderer);\n                }\n            };\n            await renderData();\n            if (this._drawDebugInfo)\n                this.drawTileDebugInfo(row, column, zoomLevel, ctx);\n        }\n        catch (e) {\n            Logger.logError(loggerCategory, `Exception occurred while loading tile (${zoomLevel}/${row}/${column}) : ${e}`);\n        }\n        try {\n            const dataUrl = canvas.toDataURL(\"image/png\");\n            const header = \"data:image/png;base64,\";\n            const dataUrl2 = dataUrl.substring(header.length);\n            return new ImageSource(base64StringToUint8Array(dataUrl2), ImageSourceFormat.Png);\n        }\n        catch (e) {\n            Logger.logError(loggerCategory, `Exception occurred while rendering tile (${zoomLevel}/${row}/${column}) : ${e}.`);\n        }\n        return undefined;\n    }\n}\n_a = ArcGisFeatureProvider;\nArcGisFeatureProvider._nbSubTiles = 2; // Number of subtiles for a single axis\nArcGisFeatureProvider.defaultPMS = {\n    type: \"esriPMS\",\n    url: \"\",\n    contentType: \"image/png\",\n    imageData: \"iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAmBJREFUOE+Nk01IVFEUx//n3jfvOZOaJkMtiiJ7o9RG3LgoqKhFSFJBTS1ahFBBi0ijfJXCIyQr+hBbSIsoW7iQoKKFCw2CkAI3tZAgy8Ei+xhoTCbnje/NPfHGnA816KzuPR+/c8/HJRQJE7o+VUhym0DcCOYGgBQEXjOLlyqo+nHanCkMoaL4rslKjZwOQLT4ek3Mmz3FACFNLB67ut6M1nWphbg8wI6VyJK5KEH0EQFVJRKbwzokAW++p/ErraAYSQK3u47bC3vLnA+ZB9i2gHF0oyQMCfCGNaUa+vauxs71wWz2V18cnBj8gQ8J1/eeBnHUa4sMFQDGdGno+4gwEAoQzjVUon3rqlx1KY9x7+0MWobjAPg3QJ2eZV4tAEyFNCN5FkSXyw2B3j1hRGvLcgBXMV5MptA4MOXr0gT0u5bZnAf0jBsyiSgJPAxqhON1K3FlRxUMvwFAtv7u0Wl0jvwEmJNEuOhakTt5wKEBifr6Oo14BIBRpgt07w6jcVMIngKGY7NofR5HwlF+zDcpsC193vyYB/innvHywCzdZfAR/+onX1segBTAxHzzfPE7/8yzzIPLjJE1LTixHZx5CtCK4gXLzovBiDPUsYxVM7gUkB3nWKlm6DYEnQGzXARxCOK+a1WfKtQXb6LNAvr7iCboCUA1Ocdsdv5KLPe7F6pH/w3wLbc+BwOuc5IZ1wEE/jonQbjptZn24tKKX7BgvR2r0NKZRwDvAqCI+Z30VJPTURv7P4A9psuQcYAUPwAoReBLrmX2Lmls7i8sZ7kWLwuoxA1FVJGxzMPLufi6P2r+2xFbOUjGAAAAAElFTkSuQmCC\",\n    width: 16,\n    height: 16,\n    xoffset: -8,\n    yoffset: -16,\n};\nArcGisFeatureProvider.defaultSLS = {\n    type: \"esriSLS\",\n    color: [0, 0, 0, 255],\n    width: 1,\n    style: \"esriSLSSolid\",\n};\nArcGisFeatureProvider.defaultSFS = {\n    type: \"esriSFS\",\n    color: [0, 0, 255, 255],\n    style: \"esriSFSSolid\",\n    outline: _a.defaultSLS,\n};\nArcGisFeatureProvider._extentCache = new Map();\nexport { ArcGisFeatureProvider };\n//# sourceMappingURL=ArcGisFeatureProvider.js.map",
      "start": 1693508122963,
      "end": 1693508123161,
      "sourcemaps": null
    }
  ]
}
