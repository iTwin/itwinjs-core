{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/common/lib/esm/Tween.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tween\n */\n/**\n * Adapted from:\n *\n * Tween.js - Licensed under the MIT license\n * https://github.com/tweenjs/tween.js\n * ----------------------------------------------\n *\n * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.\n * Thank you all, you're awesome!\n */\n// cSpell:ignore tweens yoyo catmull\n/* eslint-disable guard-for-in */\n/* eslint-disable @typescript-eslint/prefer-for-of */\n/* eslint-disable @typescript-eslint/naming-convention */\n/** A group of `Tween`s. This class is called `Group` in the tween.js library.\n * @note Unlike tween.js, we do NOT create any global instances of this class\n * like the global object `TWEEN` in tween.js. You must create an instance of this class, and then create [[Tween]]s by\n * calling [[Tweens.create]] or by calling `new Tween()` and pass your Group as its first argument.\n * @see The [tween.js users guide](https://github.com/tweenjs/tween.js/blob/master/docs/user_guide.md)\n * @public\n */\nexport class Tweens {\n    constructor() {\n        this._tweens = {};\n        this._tweensAddedDuringUpdate = {};\n        this._nextId = 0;\n    }\n    nextId() { return this._nextId++; }\n    getAll() {\n        return Object.keys(this._tweens).map((tweenId) => this._tweens[tweenId]);\n    }\n    removeAll() {\n        this._tweens = {};\n    }\n    add(tween) {\n        this._tweens[tween.getId()] = tween;\n        this._tweensAddedDuringUpdate[tween.getId()] = tween;\n    }\n    remove(tween) {\n        delete this._tweens[tween.getId()];\n        delete this._tweensAddedDuringUpdate[tween.getId()];\n    }\n    update(time, preserve) {\n        let tweenIds = Object.keys(this._tweens);\n        if (tweenIds.length === 0)\n            return false;\n        time = time !== undefined ? time : Date.now();\n        // Tweens are updated in \"batches\". If you add a new tween during an\n        // update, then the new tween will be updated in the next batch.\n        // If you remove a tween during an update, it may or may not be updated.\n        // However, if the removed tween was added during the current batch,\n        // then it will not be updated.\n        while (tweenIds.length > 0) {\n            this._tweensAddedDuringUpdate = {};\n            for (const tweenId of tweenIds) {\n                const tween = this._tweens[tweenId];\n                if (tween && tween.update(time) === false) {\n                    tween._isPlaying = false;\n                    if (!preserve) {\n                        delete this._tweens[tweenId];\n                    }\n                }\n            }\n            tweenIds = Object.keys(this._tweensAddedDuringUpdate);\n        }\n        return true;\n    }\n    /** Create a new Tween owned by this Group. Equivalent to `new TWEEN.Tween` in tween.js library. */\n    create(from, opts) {\n        const t = new Tween(this, from);\n        if (opts) {\n            t.to(opts.to)\n                .duration(opts.duration)\n                .onUpdate(opts.onUpdate)\n                .delay(opts.delay)\n                .easing(opts.easing)\n                .interpolation(opts.interpolation)\n                .onComplete(opts.onComplete);\n            if (opts.start)\n                t.start();\n        }\n        return t;\n    }\n}\n/** A Tween for interpolating values of an object. Instances of this class are owned by a `Tweens` group.\n * @see The [tween.js users guide](https://github.com/tweenjs/tween.js/blob/master/docs/user_guide.md)\n * @public\n */\nexport class Tween {\n    constructor(_group, _object) {\n        this._group = _group;\n        this._object = _object;\n        this._isPaused = false;\n        this._valuesStart = {};\n        this._valuesEnd = {};\n        this._valuesStartRepeat = {};\n        this._duration = 1000;\n        this._repeat = 0;\n        this._yoyo = false;\n        this._isPlaying = false;\n        this._reversed = false;\n        this._delayTime = 0;\n        this._easingFunction = Easing.Linear.None;\n        this._interpolationFunction = Interpolation.Linear;\n        this._chainedTweens = [];\n        this._onStartCallbackFired = false;\n        this._id = _group.nextId();\n    }\n    getId() { return this._id; }\n    get isPlaying() { return this._isPlaying; }\n    get isPaused() { return this._isPaused; }\n    to(properties, duration) {\n        this._valuesEnd = Object.create(properties);\n        if (duration !== undefined)\n            this._duration = duration;\n        return this;\n    }\n    duration(d) {\n        this._duration = d;\n        return this;\n    }\n    start(time) {\n        this._group.add(this);\n        this._isPlaying = true;\n        this._isPaused = false;\n        this._onStartCallbackFired = false;\n        this._startTime = time !== undefined ? typeof time === \"string\" ? Date.now() + parseFloat(time) : time : Date.now();\n        this._startTime += this._delayTime;\n        for (const property in this._valuesEnd) {\n            // Check if an Array was provided as property value\n            if (this._valuesEnd[property] instanceof Array) {\n                if (this._valuesEnd[property].length === 0)\n                    continue;\n                // Create a local copy of the Array with the start value at the front\n                this._valuesEnd[property] = [this._object[property]].concat(this._valuesEnd[property]);\n            }\n            // If `to()` specifies a property that doesn't exist in the source object,\n            // we should not set that property in the object\n            if (this._object[property] === undefined)\n                continue;\n            // Save the starting value, but only once.\n            if (typeof (this._valuesStart[property]) === \"undefined\")\n                this._valuesStart[property] = this._object[property];\n            if ((this._valuesStart[property] instanceof Array) === false)\n                this._valuesStart[property] *= 1.0; // Ensures we're using numbers, not strings\n            this._valuesStartRepeat[property] = this._valuesStart[property] || 0;\n        }\n        return this;\n    }\n    stop() {\n        if (!this._isPlaying)\n            return this;\n        this._group.remove(this);\n        this._isPlaying = false;\n        this._isPaused = false;\n        if (this._onStopCallback !== undefined)\n            this._onStopCallback(this._object);\n        this.stopChainedTweens();\n        return this;\n    }\n    end() {\n        this.update(Infinity);\n        return this;\n    }\n    pause(time) {\n        if (this._isPaused || !this._isPlaying)\n            return this;\n        this._isPaused = true;\n        this._pauseStart = time === undefined ? Date.now() : time;\n        this._group.remove(this);\n        return this;\n    }\n    resume(time) {\n        if (!this._isPaused || !this._isPlaying)\n            return this;\n        this._isPaused = false;\n        this._startTime += (time === undefined ? Date.now() : time) - this._pauseStart;\n        this._pauseStart = 0;\n        this._group.add(this);\n        return this;\n    }\n    stopChainedTweens() {\n        for (let i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {\n            this._chainedTweens[i].stop();\n        }\n    }\n    group(group) {\n        this._group = group;\n        return this;\n    }\n    delay(amount) {\n        if (undefined !== amount)\n            this._delayTime = amount;\n        return this;\n    }\n    repeat(times) {\n        this._repeat = times;\n        return this;\n    }\n    repeatDelay(amount) {\n        this._repeatDelayTime = amount;\n        return this;\n    }\n    yoyo(yoyo) {\n        this._yoyo = yoyo;\n        return this;\n    }\n    easing(easingFunction) {\n        if (easingFunction)\n            this._easingFunction = easingFunction;\n        return this;\n    }\n    interpolation(interpolationFunction) {\n        if (interpolationFunction)\n            this._interpolationFunction = interpolationFunction;\n        return this;\n    }\n    chain(...tweens) {\n        this._chainedTweens = tweens;\n        return this;\n    }\n    onStart(callback) {\n        this._onStartCallback = callback;\n        return this;\n    }\n    onUpdate(callback) {\n        this._onUpdateCallback = callback;\n        return this;\n    }\n    onRepeat(callback) {\n        this._onRepeatCallback = callback;\n        return this;\n    }\n    onComplete(callback) {\n        this._onCompleteCallback = callback;\n        return this;\n    }\n    onStop(callback) {\n        this._onStopCallback = callback;\n        return this;\n    }\n    update(time) {\n        if (undefined === this._startTime || time < this._startTime)\n            return true;\n        if (this._onStartCallbackFired === false) {\n            if (this._onStartCallback !== undefined) {\n                this._onStartCallback(this._object);\n            }\n            this._onStartCallbackFired = true;\n        }\n        let elapsed = (time - this._startTime) / this._duration;\n        elapsed = (this._duration === 0 || elapsed > 1) ? 1 : elapsed;\n        const value = this._easingFunction(elapsed);\n        let property;\n        for (property in this._valuesEnd) {\n            // Don't update properties that do not exist in the source object\n            if (this._valuesStart[property] === undefined)\n                continue;\n            const start = this._valuesStart[property] || 0;\n            let end = this._valuesEnd[property];\n            if (end instanceof Array) {\n                this._object[property] = this._interpolationFunction(end, value);\n            }\n            else {\n                // Parses relative end values with start as base (e.g.: +10, -3)\n                if (typeof (end) === \"string\") {\n                    if (end.charAt(0) === \"+\" || end.charAt(0) === \"-\")\n                        end = start + parseFloat(end);\n                    else\n                        end = parseFloat(end);\n                }\n                // Protect against non numeric properties.\n                if (typeof (end) === \"number\")\n                    this._object[property] = start + (end - start) * value;\n            }\n        }\n        if (this._onUpdateCallback !== undefined)\n            this._onUpdateCallback(this._object, elapsed);\n        if (elapsed === 1) {\n            if (this._repeat > 0) {\n                if (isFinite(this._repeat))\n                    this._repeat--;\n                // Reassign starting values, restart by making startTime = now\n                for (property in this._valuesStartRepeat) {\n                    if (typeof (this._valuesEnd[property]) === \"string\") {\n                        this._valuesStartRepeat[property] = this._valuesStartRepeat[property] + parseFloat(this._valuesEnd[property]);\n                    }\n                    if (this._yoyo) {\n                        const tmp = this._valuesStartRepeat[property];\n                        this._valuesStartRepeat[property] = this._valuesEnd[property];\n                        this._valuesEnd[property] = tmp;\n                    }\n                    this._valuesStart[property] = this._valuesStartRepeat[property];\n                }\n                if (this._yoyo)\n                    this._reversed = !this._reversed;\n                if (this._repeatDelayTime !== undefined)\n                    this._startTime = time + this._repeatDelayTime;\n                else\n                    this._startTime = time + this._delayTime;\n                if (this._onRepeatCallback !== undefined)\n                    this._onRepeatCallback(this._object);\n                return true;\n            }\n            else {\n                if (this._onCompleteCallback !== undefined)\n                    this._onCompleteCallback(this._object);\n                for (let i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {\n                    // Make the chained tweens start exactly at the time they should,\n                    // even if the `update()` method was called way past the duration of the tween\n                    this._chainedTweens[i].start(this._startTime + this._duration);\n                }\n                return false;\n            }\n        }\n        return true;\n    }\n}\n/** Easing functions from tween.js\n * @public\n */\nexport const Easing = {\n    Linear: {\n        None: (k) => {\n            return k;\n        },\n    },\n    Quadratic: {\n        In: (k) => {\n            return k * k;\n        },\n        Out: (k) => {\n            return k * (2 - k);\n        },\n        InOut: (k) => {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k;\n            }\n            return -0.5 * (--k * (k - 2) - 1);\n        },\n    },\n    Cubic: {\n        In: (k) => {\n            return k * k * k;\n        },\n        Out: (k) => {\n            return --k * k * k + 1;\n        },\n        InOut: (k) => {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k;\n            }\n            return 0.5 * ((k -= 2) * k * k + 2);\n        },\n    },\n    Quartic: {\n        In: (k) => {\n            return k * k * k * k;\n        },\n        Out: (k) => {\n            return 1 - (--k * k * k * k);\n        },\n        InOut: (k) => {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k * k;\n            }\n            return -0.5 * ((k -= 2) * k * k * k - 2);\n        },\n    },\n    Quintic: {\n        In: (k) => {\n            return k * k * k * k * k;\n        },\n        Out: (k) => {\n            return --k * k * k * k * k + 1;\n        },\n        InOut: (k) => {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k * k * k;\n            }\n            return 0.5 * ((k -= 2) * k * k * k * k + 2);\n        },\n    },\n    Sinusoidal: {\n        In: (k) => {\n            return 1 - Math.cos(k * Math.PI / 2);\n        },\n        Out: (k) => {\n            return Math.sin(k * Math.PI / 2);\n        },\n        InOut: (k) => {\n            return 0.5 * (1 - Math.cos(Math.PI * k));\n        },\n    },\n    Exponential: {\n        In: (k) => {\n            return k === 0 ? 0 : Math.pow(1024, k - 1);\n        },\n        Out: (k) => {\n            return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n        },\n        InOut: (k) => {\n            if (k === 0)\n                return 0;\n            if (k === 1)\n                return 1;\n            if ((k *= 2) < 1)\n                return 0.5 * Math.pow(1024, k - 1);\n            return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n        },\n    },\n    Circular: {\n        In: (k) => {\n            return 1 - Math.sqrt(1 - k * k);\n        },\n        Out: (k) => {\n            return Math.sqrt(1 - (--k * k));\n        },\n        InOut: (k) => {\n            if ((k *= 2) < 1)\n                return -0.5 * (Math.sqrt(1 - k * k) - 1);\n            return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n        },\n    },\n    Elastic: {\n        In: (k) => {\n            if (k === 0)\n                return 0;\n            if (k === 1)\n                return 1;\n            return -Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);\n        },\n        Out: (k) => {\n            if (k === 0)\n                return 0;\n            if (k === 1)\n                return 1;\n            return Math.pow(2, -10 * k) * Math.sin((k - 0.1) * 5 * Math.PI) + 1;\n        },\n        InOut: (k) => {\n            if (k === 0)\n                return 0;\n            if (k === 1)\n                return 1;\n            k *= 2;\n            if (k < 1)\n                return -0.5 * Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);\n            return 0.5 * Math.pow(2, -10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI) + 1;\n        },\n    },\n    Back: {\n        In: (k) => {\n            const s = 1.70158;\n            return k * k * ((s + 1) * k - s);\n        },\n        Out: (k) => {\n            const s = 1.70158;\n            return --k * k * ((s + 1) * k + s) + 1;\n        },\n        InOut: (k) => {\n            const s = 1.70158 * 1.525;\n            if ((k *= 2) < 1)\n                return 0.5 * (k * k * ((s + 1) * k - s));\n            return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n        },\n    },\n    Bounce: {\n        In: (k) => {\n            return 1 - Easing.Bounce.Out(1 - k);\n        },\n        Out: (k) => {\n            if (k < (1 / 2.75))\n                return 7.5625 * k * k;\n            if (k < (2 / 2.75))\n                return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;\n            if (k < (2.5 / 2.75))\n                return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;\n            return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;\n        },\n        InOut: (k) => {\n            if (k < 0.5)\n                return Easing.Bounce.In(k * 2) * 0.5;\n            return Easing.Bounce.Out(k * 2 - 1) * 0.5 + 0.5;\n        },\n    },\n};\n/** Interpolation functions from tween.js\n *  @public\n */\nexport const Interpolation = {\n    Linear: (v, k) => {\n        const m = v.length - 1;\n        const f = m * k;\n        const i = Math.floor(f);\n        const fn = Interpolation.Utils.Linear;\n        if (k < 0)\n            return fn(v[0], v[1], f);\n        if (k > 1)\n            return fn(v[m], v[m - 1], m - f);\n        return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);\n    },\n    Bezier: (v, k) => {\n        let b = 0;\n        const n = v.length - 1;\n        const pw = Math.pow;\n        const bn = Interpolation.Utils.Bernstein;\n        for (let i = 0; i <= n; i++)\n            b += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);\n        return b;\n    },\n    CatmullRom: (v, k) => {\n        const m = v.length - 1;\n        let f = m * k;\n        let i = Math.floor(f);\n        const fn = Interpolation.Utils.CatmullRom;\n        if (v[0] === v[m]) {\n            if (k < 0) {\n                i = Math.floor(f = m * (1 + k));\n            }\n            return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);\n        }\n        else {\n            if (k < 0)\n                return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);\n            if (k > 1)\n                return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);\n            return fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);\n        }\n    },\n    Utils: {\n        Linear: (p0, p1, t) => {\n            return (p1 - p0) * t + p0;\n        },\n        Bernstein: (n, i) => {\n            const fc = Interpolation.Utils.Factorial;\n            return fc(n) / fc(i) / fc(n - i);\n        },\n        Factorial: (() => {\n            const a = [1];\n            return (n) => {\n                let s = 1;\n                if (a[n])\n                    return a[n];\n                for (let i = n; i > 1; i--)\n                    s *= i;\n                a[n] = s;\n                return s;\n            };\n        })(),\n        CatmullRom: (p0, p1, p2, p3, t) => {\n            const v0 = (p2 - p0) * 0.5;\n            const v1 = (p3 - p1) * 0.5;\n            const t2 = t * t;\n            const t3 = t * t2;\n            return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;\n        },\n    },\n};\n//# sourceMappingURL=Tween.js.map",
      "start": 1693508120992,
      "end": 1693508121040,
      "sourcemaps": null
    }
  ]
}
