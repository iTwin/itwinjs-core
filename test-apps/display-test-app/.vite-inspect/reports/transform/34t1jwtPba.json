{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/geometry3d/GrowableXYZArray.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module ArraysAndInterfaces\n */\nimport { Geometry } from \"../Geometry\";\nimport { IndexedReadWriteXYZCollection, IndexedXYZCollection } from \"./IndexedXYZCollection\";\nimport { Point2d } from \"./Point2dVector2d\";\nimport { Point3d, Vector3d } from \"./Point3dVector3d\";\nimport { PointStreamGrowableXYZArrayCollector, VariantPointDataStream } from \"./PointStreaming\";\nimport { Range1d, Range3d } from \"./Range\";\nimport { Transform } from \"./Transform\";\n/** `GrowableXYArray` manages a (possibly growing) Float64Array to pack xy coordinates.\n * @public\n */\nexport class GrowableXYZArray extends IndexedReadWriteXYZCollection {\n    /** Construct a new GrowablePoint3d array.\n     * @param numPoints initial capacity in xyz triples (default 8)\n     * @param growthFactor used by ensureCapacity to expand requested reallocation size (default 1.5)\n     */\n    constructor(numPoints = 8, growthFactor) {\n        super();\n        this._data = new Float64Array(numPoints * 3); // 3 values per point\n        this._xyzInUse = 0;\n        this._xyzCapacity = numPoints;\n        this._growthFactor = (undefined !== growthFactor && growthFactor >= 1.0) ? growthFactor : 1.5;\n    }\n    /** Copy xyz points from source array. Does not reallocate or change active point count.\n     * @param source array to copy from\n     * @param sourceCount copy the first sourceCount points; all points if undefined\n     * @param destOffset copy to instance array starting at this point index; zero if undefined\n     * @return count and offset of points copied\n     */\n    copyData(source, sourceCount, destOffset) {\n        // validate inputs and convert from points to entries\n        let myOffset = (undefined !== destOffset) ? destOffset * 3 : 0;\n        if (myOffset < 0)\n            myOffset = 0;\n        if (myOffset >= this._data.length)\n            return { count: 0, offset: 0 };\n        let myCount = (undefined !== sourceCount) ? sourceCount * 3 : source.length;\n        if (myCount > 0) {\n            if (myCount > source.length)\n                myCount = source.length;\n            if (myOffset + myCount > this._data.length)\n                myCount = this._data.length - myOffset;\n            if (myCount % 3 !== 0)\n                myCount -= myCount % 3;\n        }\n        if (myCount <= 0)\n            return { count: 0, offset: 0 };\n        if (myCount === source.length)\n            this._data.set(source, myOffset);\n        else if (source instanceof Float64Array)\n            this._data.set(source.subarray(0, myCount), myOffset);\n        else\n            this._data.set(source.slice(0, myCount), myOffset);\n        return { count: myCount / 3, offset: myOffset / 3 };\n    }\n    /** The number of points in use. When the length is increased, the array is padded with zeroes. */\n    get length() { return this._xyzInUse; }\n    set length(newLength) { this.resize(newLength, true); }\n    /** Return the number of float64 in use. */\n    get float64Length() { return this._xyzInUse * 3; }\n    /** Return the raw packed data.\n     * * Note that the length of the returned Float64Array is a count of doubles, and includes the excess capacity\n     */\n    float64Data() { return this._data; }\n    /** If necessary, increase the capacity to the new number of points.  Current coordinates and point count (length) are unchanged. */\n    ensureCapacity(pointCapacity, applyGrowthFactor = true) {\n        if (pointCapacity > this._xyzCapacity) {\n            if (applyGrowthFactor)\n                pointCapacity *= this._growthFactor;\n            const prevData = this._data;\n            this._data = new Float64Array(pointCapacity * 3);\n            this.copyData(prevData, this._xyzInUse);\n            this._xyzCapacity = pointCapacity;\n        }\n    }\n    /**\n     * * If pointCount is less than current length, just reset current length to pointCount, effectively trimming active points but preserving original capacity.\n     * * If pointCount is greater than current length, reallocate to exactly pointCount, copy existing points, and optionally pad excess with zero.\n     * @param pointCount new number of active points in array\n     * @param padWithZero when increasing point count, whether to zero out new points (default false)\n    */\n    resize(pointCount, padWithZero) {\n        if (pointCount >= 0 && pointCount < this._xyzInUse)\n            this._xyzInUse = pointCount;\n        else if (pointCount > this._xyzInUse) {\n            this.ensureCapacity(pointCount, false);\n            if (padWithZero ?? false)\n                this._data.fill(0, this._xyzInUse * 3);\n            this._xyzInUse = pointCount;\n        }\n    }\n    /**\n     * Make a copy of the (active) points in this array.\n     * (The clone does NOT get excess capacity)\n     */\n    clone(result) {\n        if (!result)\n            result = new GrowableXYZArray(this.length);\n        else {\n            if (result.length !== this.length)\n                result.clear(); // force resize to trim excess capacity\n            result.resize(this.length);\n        }\n        result.copyData(this._data, this.length);\n        result._xyzInUse = this.length;\n        return result;\n    }\n    /** Create an array from various point data formats.\n     * Valid inputs are:\n     * * Point2d\n     * * Point3d\n     * * An array of 2 doubles\n     * * An array of 3 doubles\n     * * A GrowableXYZArray\n     * * Any json object satisfying Point3d.isXYAndZ\n     * * Any json object satisfying Point3d.isXAndY\n     * * A Float64Array of doubles, interpreted as xyzxyz\n     * * An array of any of the above\n     * @param data source points.\n     * @param result optional pre-allocated GrowableXYZArray to clear and fill.\n     */\n    static create(data, result) {\n        if (result) {\n            result.clear();\n        }\n        else {\n            const pointCount = typeof data[0] === \"number\" ? data.length / 3 : data.length;\n            result = new GrowableXYZArray(pointCount);\n        }\n        result.pushFrom(data);\n        return result;\n    }\n    /** Restructure MultiLineStringDataVariant as array of GrowableXYZArray */\n    static createArrayOfGrowableXYZArray(data) {\n        const collector = new PointStreamGrowableXYZArrayCollector();\n        VariantPointDataStream.streamXYZ(data, collector);\n        return collector.claimArrayOfGrowableXYZArray();\n    }\n    /** push a point to the end of the array */\n    push(toPush) {\n        this.pushXYZ(toPush.x, toPush.y, toPush.z);\n    }\n    /** push all points of an array */\n    pushAll(points) {\n        this.ensureCapacity(this._xyzInUse + points.length, false);\n        for (const p of points)\n            this.push(p);\n    }\n    /** Push points from variant sources.\n     * Valid inputs are:\n     * * Point2d\n     * * Point3d\n     * * An array of 2 doubles\n     * * An array of 3 doubles\n     * * A GrowableXYZArray\n     * * Any json object satisfying Point3d.isXYAndZ\n     * * Any json object satisfying Point3d.isXAndY\n     * * A Float64Array of doubles, interpreted as xyzxyz\n     * * An array of any of the above\n     */\n    pushFrom(p) {\n        if (p instanceof Point3d)\n            this.pushXYZ(p.x, p.y, p.z);\n        else if (p instanceof GrowableXYZArray)\n            this.pushFromGrowableXYZArray(p);\n        else if (p instanceof Point2d)\n            this.pushXYZ(p.x, p.y, 0.0);\n        else if (Geometry.isNumberArray(p, 4) || p instanceof Float64Array) {\n            const xyzToAdd = Math.trunc(p.length / 3);\n            this.ensureCapacity(this._xyzInUse + xyzToAdd, false);\n            this.copyData(p, xyzToAdd, this._xyzInUse);\n            this._xyzInUse += xyzToAdd;\n        }\n        else if (Geometry.isNumberArray(p, 3))\n            this.pushXYZ(p[0], p[1], p[2]);\n        else if (Geometry.isNumberArray(p, 2))\n            this.pushXYZ(p[0], p[1], 0.0);\n        else if (Array.isArray(p)) {\n            // direct recursion re-wraps p and goes infinite. Unroll here.\n            for (const q of p)\n                this.pushFrom(q);\n        }\n        else if (Point3d.isXYAndZ(p))\n            this.pushXYZ(p.x, p.y, p.z);\n        else if (Point3d.isXAndY(p))\n            this.pushXYZ(p.x, p.y, 0.0);\n        else if (p instanceof IndexedXYZCollection) {\n            const n = p.length;\n            this.ensureCapacity(this._xyzInUse + n, false);\n            for (let i = 0; i < n; i++)\n                this.pushXYZ(p.getXAtUncheckedPointIndex(i), p.getYAtUncheckedPointIndex(i), p.getZAtUncheckedPointIndex(i));\n        }\n    }\n    /**\n     * Replicate numWrap xyz values from the front of the array as new values at the end.\n     * @param numWrap number of xyz values to replicate\n     */\n    pushWrap(numWrap) {\n        if (this._xyzInUse >= numWrap) {\n            this.ensureCapacity(this._xyzInUse + numWrap, false);\n            for (let i = 0; i < numWrap; i++) {\n                const k = 3 * i;\n                this.pushXYZ(this._data[k], this._data[k + 1], this._data[k + 2]);\n            }\n        }\n    }\n    /** append a new point with given x,y,z */\n    pushXYZ(x, y, z) {\n        this.ensureCapacity(this._xyzInUse + 1);\n        const index = this._xyzInUse * 3;\n        this._data[index] = x;\n        this._data[index + 1] = y;\n        this._data[index + 2] = z;\n        this._xyzInUse++;\n    }\n    /** Shift all data forward to make space for numPoints at the front.\n     * * Leading (3*numPoints) doubles are left with prior contents.\n     * * _xyzInUse count is increased\n    */\n    shiftForward(numPoints) {\n        if (numPoints <= 0)\n            return;\n        this.ensureCapacity(this._xyzInUse + numPoints);\n        const numAddedDouble = 3 * numPoints;\n        const lastIndex = this._xyzInUse * 3;\n        this._data.copyWithin(numAddedDouble, 0, lastIndex);\n        this._xyzInUse += numPoints;\n    }\n    /** prepend a new point with given x,y,z\n     * * Remark: this copies all content forward.\n     */\n    pushFrontXYZ(x, y, z) {\n        this.shiftForward(1);\n        this._data[0] = x;\n        this._data[1] = y;\n        this._data[2] = z;\n    }\n    /** prepend a new point at the front of the array.\n     *\n     */\n    pushFront(toPush) {\n        this.pushFrontXYZ(toPush.x, toPush.y, toPush.z);\n    }\n    /** move the coordinates at fromIndex to toIndex.\n     * * No action if either index is invalid.\n     */\n    moveIndexToIndex(fromIndex, toIndex) {\n        if (this.isIndexValid(fromIndex) && this.isIndexValid(toIndex)) {\n            let iA = fromIndex * 3;\n            let iB = toIndex * 3;\n            this._data[iB++] = this._data[iA++];\n            this._data[iB++] = this._data[iA++];\n            this._data[iB] = this._data[iA];\n        }\n    }\n    /** Remove one point from the back.\n     * * NOTE that (in the manner of std::vector native) this is \"just\" removing the point -- no point is NOT returned.\n     * * Use `back ()` to get the last x,y,z assembled into a `Point3d `\n     */\n    pop() {\n        if (this._xyzInUse > 0)\n            this._xyzInUse--;\n    }\n    /**\n     * Test if index is valid for an xyz (point or vector) within this array\n     * @param index xyz index to test.\n     */\n    isIndexValid(index) {\n        if (index >= this._xyzInUse || index < 0)\n            return false;\n        return true;\n    }\n    /**\n     * Clear all xyz data, but leave capacity unchanged.\n     */\n    clear() {\n        this._xyzInUse = 0;\n    }\n    /**\n     * Get a point by index, strongly typed as a Point3d.  This is unchecked.  Use getPoint3dAtCheckedPointIndex to have validity test.\n     * @param pointIndex index to access\n     * @param result optional result\n     */\n    getPoint3dAtUncheckedPointIndex(pointIndex, result) {\n        const index = 3 * pointIndex;\n        return Point3d.create(this._data[index], this._data[index + 1], this._data[index + 2], result);\n    }\n    /**\n     * Get a point by index, strongly typed as a Point2d.  This is unchecked.  Use getPoint2dAtCheckedPointIndex to have validity test.\n     * @param pointIndex index to access\n     * @param result optional result\n     */\n    getPoint2dAtUncheckedPointIndex(pointIndex, result) {\n        const index = 3 * pointIndex;\n        return Point2d.create(this._data[index], this._data[index + 1], result);\n    }\n    /** copy xyz into strongly typed Point3d */\n    getPoint3dAtCheckedPointIndex(pointIndex, result) {\n        if (this.isIndexValid(pointIndex)) {\n            const index = 3 * pointIndex;\n            return Point3d.create(this._data[index], this._data[index + 1], this._data[index + 2], result);\n        }\n        return undefined;\n    }\n    /** access x of indexed point */\n    getXAtUncheckedPointIndex(pointIndex) {\n        const index = 3 * pointIndex;\n        return this._data[index];\n    }\n    /** access y of indexed point */\n    getYAtUncheckedPointIndex(pointIndex) {\n        const index = 3 * pointIndex;\n        return this._data[index + 1];\n    }\n    /** access y of indexed point */\n    getZAtUncheckedPointIndex(pointIndex) {\n        const index = 3 * pointIndex;\n        return this._data[index + 2];\n    }\n    /** copy xy into strongly typed Point2d */\n    getPoint2dAtCheckedPointIndex(pointIndex, result) {\n        if (this.isIndexValid(pointIndex)) {\n            const index = 3 * pointIndex;\n            return Point2d.create(this._data[index], this._data[index + 1], result);\n        }\n        return undefined;\n    }\n    /** copy xyz into strongly typed Vector3d */\n    getVector3dAtCheckedVectorIndex(vectorIndex, result) {\n        if (this.isIndexValid(vectorIndex)) {\n            const index = 3 * vectorIndex;\n            return Vector3d.create(this._data[index], this._data[index + 1], this._data[index + 2], result);\n        }\n        return undefined;\n    }\n    /**\n     * Read coordinates from source array, place them at index within this array.\n     * @param destIndex point index where coordinates are to be placed in this array\n     * @param source source array\n     * @param sourceIndex point index in source array\n     * @returns true if destIndex and sourceIndex are both valid.\n     */\n    transferFromGrowableXYZArray(destIndex, source, sourceIndex) {\n        if (this.isIndexValid(destIndex) && source.isIndexValid(sourceIndex)) {\n            const i = destIndex * 3;\n            const j = sourceIndex * 3;\n            this._data[i] = source._data[j];\n            this._data[i + 1] = source._data[j + 1];\n            this._data[i + 2] = source._data[j + 2];\n            return true;\n        }\n        return false;\n    }\n    /**\n     * push coordinates from the source array to the end of this array.\n     * @param source source array\n     * @param sourceIndex xyz index within the source.  If undefined, entire source is pushed.\n     * @returns number of points pushed.\n     */\n    pushFromGrowableXYZArray(source, sourceIndex) {\n        // full array push  . . .\n        if (sourceIndex === undefined) {\n            const numXYZAdd = source.length;\n            this.ensureCapacity(this.length + numXYZAdd, false);\n            this.copyData(source._data, numXYZAdd, this.length);\n            this._xyzInUse += numXYZAdd;\n            return numXYZAdd;\n        }\n        // single point push . . .\n        if (source.isIndexValid(sourceIndex)) {\n            const j = sourceIndex * 3;\n            this.pushXYZ(source._data[j], source._data[j + 1], source._data[j + 2]);\n            return 1;\n        }\n        return 0;\n    }\n    /**\n     * Set the coordinates of a single point.\n     * @param pointIndex index of point to set\n     * @param value coordinates to set\n     */\n    setAtCheckedPointIndex(pointIndex, value) {\n        if (!this.isIndexValid(pointIndex))\n            return false;\n        let index = pointIndex * 3;\n        this._data[index++] = value.x;\n        this._data[index++] = value.y;\n        this._data[index] = value.z;\n        return true;\n    }\n    /**\n     * Set the coordinates of a single point given as coordinates\n     * @param pointIndex index of point to set\n     * @param x x coordinate\n     * @param y y coordinate\n     * @param z z coordinate\n     */\n    setXYZAtCheckedPointIndex(pointIndex, x, y, z) {\n        if (!this.isIndexValid(pointIndex))\n            return false;\n        let index = pointIndex * 3;\n        this._data[index++] = x;\n        this._data[index++] = y;\n        this._data[index] = z;\n        return true;\n    }\n    /**\n     * Copy all points into a simple array of Point3d\n     */\n    getPoint3dArray() {\n        const n = 3 * this._xyzInUse;\n        const result = [];\n        const data = this._data;\n        for (let i = 0; i < n; i += 3)\n            result.push(Point3d.create(data[i], data[i + 1], data[i + 2]));\n        return result;\n    }\n    /** multiply each point by the transform, replace values. */\n    static multiplyTransformInPlace(transform, data) {\n        if (Array.isArray(data)) {\n            for (const d of data)\n                d.multiplyTransformInPlace(transform);\n        }\n        else {\n            data.multiplyTransformInPlace(transform);\n        }\n    }\n    /** multiply each point by the transform, replace values. */\n    multiplyTransformInPlace(transform) {\n        const data = this._data;\n        const nDouble = this.float64Length;\n        const coffs = transform.matrix.coffs;\n        const origin = transform.origin;\n        const x0 = origin.x;\n        const y0 = origin.y;\n        const z0 = origin.z;\n        let x = 0;\n        let y = 0;\n        let z = 0;\n        for (let i = 0; i + 2 <= nDouble; i += 3) {\n            x = data[i];\n            y = data[i + 1];\n            z = data[i + 2];\n            data[i] = coffs[0] * x + coffs[1] * y + coffs[2] * z + x0;\n            data[i + 1] = coffs[3] * x + coffs[4] * y + coffs[5] * z + y0;\n            data[i + 2] = coffs[6] * x + coffs[7] * y + coffs[8] * z + z0;\n        }\n    }\n    /** reverse the order of points. */\n    reverseInPlace() {\n        const n = this.length;\n        let j0, j1;\n        let a;\n        const data = this._data;\n        for (let i0 = 0, i1 = n - 1; i0 < i1; i0++, i1--) {\n            j0 = 3 * i0;\n            j1 = 3 * i1;\n            a = data[j0];\n            data[j0] = data[j1];\n            data[j1] = a;\n            j0++;\n            j1++;\n            a = data[j0];\n            data[j0] = data[j1];\n            data[j1] = a;\n            j0++;\n            j1++;\n            a = data[j0];\n            data[j0] = data[j1];\n            data[j1] = a;\n        }\n    }\n    /** multiply each xyz (as a vector) by matrix, replace values. */\n    multiplyMatrix3dInPlace(matrix) {\n        const data = this._data;\n        const nDouble = this.float64Length;\n        const coffs = matrix.coffs;\n        let x = 0;\n        let y = 0;\n        let z = 0;\n        for (let i = 0; i + 2 <= nDouble; i += 3) {\n            x = data[i];\n            y = data[i + 1];\n            z = data[i + 2];\n            data[i] = coffs[0] * x + coffs[1] * y + coffs[2] * z;\n            data[i + 1] = coffs[3] * x + coffs[4] * y + coffs[5] * z;\n            data[i + 2] = coffs[6] * x + coffs[7] * y + coffs[8] * z;\n        }\n    }\n    /** multiply each xyz (as a vector) by matrix inverse transpose, renormalize the vector, replace values.\n     * * This is the way to apply a matrix (possibly with skew and scale) to a surface normal, and\n     *      have it end up perpendicular to the transformed in-surface vectors.\n     * * Return false if matrix is not invertible or if any normalization fails.\n     */\n    multiplyAndRenormalizeMatrix3dInverseTransposeInPlace(matrix) {\n        const data = this._data;\n        const nDouble = this.float64Length;\n        if (!matrix.computeCachedInverse(true))\n            return false;\n        const coffs = matrix.inverseCoffs;\n        const tol = Geometry.smallFloatingPoint;\n        let x = 0;\n        let y = 0;\n        let z = 0;\n        let x1;\n        let y1;\n        let z1;\n        let q;\n        let a;\n        let numFail = 0;\n        for (let i = 0; i + 2 <= nDouble; i += 3) {\n            x = data[i];\n            y = data[i + 1];\n            z = data[i + 2];\n            x1 = coffs[0] * x + coffs[3] * y + coffs[6] * z;\n            y1 = coffs[1] * x + coffs[4] * y + coffs[7] * z;\n            z1 = coffs[2] * x + coffs[5] * y + coffs[8] * z;\n            a = x1 * x1 + y1 * y1 + z1 * z1;\n            if (a < tol) {\n                // put the originals back ..\n                x1 = x;\n                y1 = y;\n                z1 = z;\n                numFail++;\n            }\n            else if (Math.abs(a - 1.0) > tol) {\n                q = 1.0 / Math.sqrt(a);\n                x1 *= q;\n                y1 *= q;\n                z1 *= q;\n            } // else -- q is near 1, no need to do the division !!\n            data[i] = x1;\n            data[i + 1] = y1;\n            data[i + 2] = z1;\n        }\n        return numFail === 0;\n    }\n    /** multiply each xyz (as a point) by a homogeneous matrix and update as the normalized point\n     *\n     */\n    multiplyMatrix4dAndQuietRenormalizeMatrix4d(matrix) {\n        const data = this._data;\n        const nDouble = this.float64Length;\n        const xyz1 = Point3d.create();\n        for (let i = 0; i + 2 <= nDouble; i += 3) {\n            matrix.multiplyXYZWQuietRenormalize(data[i], data[i + 1], data[i + 2], 1.0, xyz1);\n            data[i] = xyz1.x;\n            data[i + 1] = xyz1.y;\n            data[i + 2] = xyz1.z;\n        }\n    }\n    /** multiply each point by the transform, replace values. */\n    tryTransformInverseInPlace(transform) {\n        const data = this._data;\n        const nDouble = this.float64Length;\n        const matrix = transform.matrix;\n        matrix.computeCachedInverse(true);\n        const coffs = matrix.inverseCoffs;\n        if (!coffs)\n            return false;\n        const origin = transform.origin;\n        const x0 = origin.x;\n        const y0 = origin.y;\n        const z0 = origin.z;\n        let x = 0;\n        let y = 0;\n        let z = 0;\n        for (let i = 0; i + 2 < nDouble; i += 3) {\n            x = data[i] - x0;\n            y = data[i + 1] - y0;\n            z = data[i + 2] - z0;\n            data[i] = coffs[0] * x + coffs[1] * y + coffs[2] * z;\n            data[i + 1] = coffs[3] * x + coffs[4] * y + coffs[5] * z;\n            data[i + 2] = coffs[6] * x + coffs[7] * y + coffs[8] * z;\n        }\n        return true;\n    }\n    /** Extend `range` to extend by all points. */\n    extendRange(rangeToExtend, transform) {\n        const numDouble = this.float64Length;\n        const data = this._data;\n        if (transform) {\n            for (let i = 0; i + 2 < numDouble; i += 3)\n                rangeToExtend.extendTransformedXYZ(transform, data[i], data[i + 1], data[i + 2]);\n        }\n        else {\n            for (let i = 0; i + 2 < numDouble; i += 3)\n                rangeToExtend.extendXYZ(data[i], data[i + 1], data[i + 2]);\n        }\n    }\n    /** get range of points. */\n    getRange(transform) {\n        const range = Range3d.createNull();\n        this.extendRange(range, transform);\n        return range;\n    }\n    /** Initialize `range` with coordinates in this array. */\n    setRange(range, transform) {\n        range.setNull();\n        this.extendRange(range, transform);\n    }\n    /** Sum the lengths of segments between points. */\n    sumLengths() {\n        let sum = 0.0;\n        const n = 3 * (this._xyzInUse - 1); // Length already takes into account what specifically is in use\n        const data = this._data;\n        for (let i = 0; i < n; i += 3)\n            sum += Geometry.hypotenuseXYZ(data[i + 3] - data[i], data[i + 4] - data[i + 1], data[i + 5] - data[i + 2]);\n        return sum;\n    }\n    /**\n     * Multiply each x,y,z by the scale factor.\n     * @param factor\n     */\n    scaleInPlace(factor) {\n        if (this._data) {\n            const numFloat = this.float64Length;\n            for (let i = 0; i < numFloat; i++)\n                this._data[i] = this._data[i] * factor;\n        }\n    }\n    /** test if all points are within tolerance of a plane. */\n    isCloseToPlane(plane, tolerance = Geometry.smallMetricDistance) {\n        const numCoordinate = 3 * this._xyzInUse;\n        const data = this._data;\n        for (let i = 0; i < numCoordinate; i += 3)\n            if (Math.abs(plane.altitudeXYZ(data[i], data[i + 1], data[i + 2])) > tolerance)\n                return false;\n        return true;\n    }\n    /**\n     * * If not already closed, push a copy of the first point.\n     * * If already closed within tolerance, force exact copy\n     * * otherwise leave unchanged.\n     */\n    forceClosure(tolerance = Geometry.smallMetricDistance) {\n        const d = this.distanceIndexIndex(0, this.length - 1);\n        // leave the empty array alone.\n        // Note that singleton will generate 0 distance and do nothing.\n        if (d === undefined) {\n        }\n        else if (d > tolerance)\n            this.pushXYZ(this._data[0], this._data[1], this._data[2]);\n        else if (d > 0) {\n            // overwrite last point with exact exact first point\n            const i0 = this._data.length - 3;\n            for (let i = 0; i < 3; i++)\n                this._data[i0 + i] = this._data[i];\n        }\n    }\n    /** Compute a point at fractional coordinate between points i and j */\n    interpolate(i, fraction, j, result) {\n        if (this.isIndexValid(i) && this.isIndexValid(j)) {\n            const fraction0 = 1.0 - fraction;\n            const data = this._data;\n            i = 3 * i;\n            j = 3 * j;\n            return Point3d.create(fraction0 * data[i] + fraction * data[j], fraction0 * data[i + 1] + fraction * data[j + 1], fraction0 * data[i + 2] + fraction * data[j + 2], result);\n        }\n        return undefined;\n    }\n    /**\n     * * Compute a point at fractional coordinate between points i and j of source\n     * * push onto this array.\n     */\n    pushInterpolatedFromGrowableXYZArray(source, i, fraction, j) {\n        if (source.isIndexValid(i) && source.isIndexValid(j)) {\n            const fraction0 = 1.0 - fraction;\n            const data = source._data;\n            i = 3 * i;\n            j = 3 * j;\n            this.pushXYZ(fraction0 * data[i] + fraction * data[j], fraction0 * data[i + 1] + fraction * data[j + 1], fraction0 * data[i + 2] + fraction * data[j + 2]);\n        }\n    }\n    /** Sum the signed areas of the projection to xy plane */\n    areaXY() {\n        let area = 0.0;\n        const n = 3 * this._xyzInUse; // float count !!\n        if (n > 6) {\n            const x0 = this._data[n - 3];\n            const y0 = this._data[n - 2];\n            let dx1 = this._data[0] - x0;\n            let dy1 = this._data[1] - y0;\n            let dx2 = 0;\n            let dy2 = 0;\n            for (let i = 3; i < n; i += 3, dx1 = dx2, dy1 = dy2) {\n                dx2 = this._data[i] - x0;\n                dy2 = this._data[i + 1] - y0;\n                area += Geometry.crossProductXYXY(dx1, dy1, dx2, dy2);\n            }\n        }\n        return 0.5 * area;\n    }\n    /** Compute a vector from index origin i to indexed target j  */\n    vectorIndexIndex(i, j, result) {\n        if (!this.isIndexValid(i) || !this.isIndexValid(j))\n            return undefined;\n        const data = this._data;\n        i = 3 * i;\n        j = 3 * j;\n        return Vector3d.create(data[j] - data[i], data[j + 1] - data[i + 1], data[j + 2] - data[i + 2], result);\n    }\n    /** Compute a vector from origin to indexed target j */\n    vectorXYAndZIndex(origin, j, result) {\n        if (this.isIndexValid(j)) {\n            const data = this._data;\n            j = 3 * j;\n            return Vector3d.create(data[j] - origin.x, data[j + 1] - origin.y, data[j + 2] - origin.z, result);\n        }\n        return undefined;\n    }\n    /** Compute the cross product of vectors from from indexed origin to indexed targets i and j */\n    crossProductIndexIndexIndex(originIndex, targetAIndex, targetBIndex, result) {\n        if (this.isIndexValid(originIndex) && this.isIndexValid(targetAIndex) && this.isIndexValid(targetBIndex)) {\n            const i = originIndex * 3;\n            const j = targetAIndex * 3;\n            const k = targetBIndex * 3;\n            const data = this._data;\n            return Geometry.crossProductXYZXYZ(data[j] - data[i], data[j + 1] - data[i + 1], data[j + 2] - data[i + 2], data[k] - data[i], data[k + 1] - data[i + 1], data[k + 2] - data[i + 2], result);\n        }\n        return undefined;\n    }\n    /** Compute the dot product of pointIndex with [x,y,z] */\n    evaluateUncheckedIndexDotProductXYZ(pointIndex, x, y, z) {\n        const i = pointIndex * 3;\n        const data = this._data;\n        return data[i] * x + data[i + 1] * y + data[i + 2] * z;\n    }\n    /** Compute the dot product of pointIndex with [x,y,z] */\n    evaluateUncheckedIndexPlaneAltitude(pointIndex, plane) {\n        const i = pointIndex * 3;\n        const data = this._data;\n        return plane.altitudeXYZ(data[i], data[i + 1], data[i + 2]);\n    }\n    /**\n     * * compute the cross product from indexed origin t indexed targets targetAIndex and targetB index.\n     * * accumulate it to the result.\n     */\n    accumulateCrossProductIndexIndexIndex(originIndex, targetAIndex, targetBIndex, result) {\n        if (this.isIndexValid(originIndex) && this.isIndexValid(targetAIndex) && this.isIndexValid(targetBIndex)) {\n            const i = originIndex * 3;\n            const j = targetAIndex * 3;\n            const k = targetBIndex * 3;\n            const data = this._data;\n            result.addCrossProductToTargetsInPlace(data[i], data[i + 1], data[i + 2], data[j], data[j + 1], data[j + 2], data[k], data[k + 1], data[k + 2]);\n        }\n    }\n    /**\n     * * compute the cross product from indexed origin t indexed targets targetAIndex and targetB index.\n     * * accumulate it to the result.\n     */\n    accumulateScaledXYZ(index, scale, sum) {\n        if (this.isIndexValid(index)) {\n            const i = index * 3;\n            const data = this._data;\n            sum.x += scale * data[i];\n            sum.y += scale * data[i + 1];\n            sum.z += scale * data[i + 2];\n        }\n    }\n    /** Compute the cross product of vectors from from origin to indexed targets i and j */\n    crossProductXYAndZIndexIndex(origin, targetAIndex, targetBIndex, result) {\n        if (this.isIndexValid(targetAIndex) && this.isIndexValid(targetBIndex)) {\n            const j = targetAIndex * 3;\n            const k = targetBIndex * 3;\n            const data = this._data;\n            return Geometry.crossProductXYZXYZ(data[j] - origin.x, data[j + 1] - origin.y, data[j + 2] - origin.z, data[k] - origin.x, data[k + 1] - origin.y, data[k + 2] - origin.z, result);\n        }\n        return undefined;\n    }\n    /** Return the distance between an array point and the input point. */\n    distanceIndexToPoint(i, spacePoint) {\n        if (this.isIndexValid(i)) {\n            const i0 = 3 * i;\n            return Geometry.hypotenuseXYZ(spacePoint.x - this._data[i0], spacePoint.y - this._data[i0 + 1], spacePoint.z - this._data[i0 + 2]);\n        }\n        return undefined;\n    }\n    /**\n     * Return distance squared between indicated points.\n     * @param i first point index\n     * @param j second point index\n     */\n    distanceSquaredIndexIndex(i, j) {\n        if (this.isIndexValid(i) && this.isIndexValid(j)) {\n            const i0 = 3 * i;\n            const j0 = 3 * j;\n            return Geometry.hypotenuseSquaredXYZ(this._data[j0] - this._data[i0], this._data[j0 + 1] - this._data[i0 + 1], this._data[j0 + 2] - this._data[i0 + 2]);\n        }\n        return undefined;\n    }\n    /**\n     * Return distance between indicated points.\n     * @param i first point index\n     * @param j second point index\n     */\n    distanceIndexIndex(i, j) {\n        if (this.isIndexValid(i) && this.isIndexValid(j)) {\n            const i0 = 3 * i;\n            const j0 = 3 * j;\n            return Geometry.hypotenuseXYZ(this._data[j0] - this._data[i0], this._data[j0 + 1] - this._data[i0 + 1], this._data[j0 + 2] - this._data[i0 + 2]);\n        }\n        return undefined;\n    }\n    /** Return the distance between points in distinct arrays. */\n    static distanceBetweenPointsIn2Arrays(arrayA, i, arrayB, j) {\n        if (arrayA.isIndexValid(i) && arrayB.isIndexValid(j)) {\n            const i0 = 3 * i;\n            const j0 = 3 * j;\n            return Geometry.hypotenuseXYZ(arrayB._data[j0] - arrayA._data[i0], arrayB._data[j0 + 1] - arrayA._data[i0 + 1], arrayB._data[j0 + 2] - arrayA._data[i0 + 2]);\n        }\n        return undefined;\n    }\n    /** test for near equality between two `GrowableXYZArray`. */\n    static isAlmostEqual(dataA, dataB) {\n        if (dataA && dataB) {\n            if (dataA.length !== dataB.length)\n                return false;\n            for (let i = 0; i < dataA.length; i++)\n                if (!dataA.getPoint3dAtUncheckedPointIndex(i).isAlmostEqual(dataB.getPoint3dAtUncheckedPointIndex(i)))\n                    return false;\n            return true;\n        }\n        // if both are null it is equal, otherwise unequal\n        return (!dataA && !dataB);\n    }\n    /** Return an array of block indices sorted per compareLexicalBlock function */\n    sortIndicesLexical() {\n        const n = this._xyzInUse;\n        // let numCompare = 0;\n        const result = new Uint32Array(n);\n        for (let i = 0; i < n; i++)\n            result[i] = i;\n        result.sort((blockIndexA, blockIndexB) => {\n            // numCompare++;\n            return this.compareLexicalBlock(blockIndexA, blockIndexB);\n        });\n        // console.log (n, numCompare);\n        return result;\n    }\n    /** compare two blocks in simple lexical order. */\n    compareLexicalBlock(ia, ib) {\n        let ax = 0;\n        let bx = 0;\n        for (let i = 0; i < 3; i++) {\n            ax = this._data[ia * 3 + i];\n            bx = this._data[ib * 3 + i];\n            if (ax > bx)\n                return 1;\n            if (ax < bx)\n                return -1;\n        }\n        return ia - ib; // so original order is maintained among duplicates !!!!\n    }\n    /** Access a single double at offset within a block.  This has no index checking. */\n    component(pointIndex, componentIndex) {\n        return this._data[3 * pointIndex + componentIndex];\n    }\n    /**\n     * add points at regular steps from `other`\n     * @param source\n     * @param pointIndex0\n     * @param step\n     * @param numAdd\n     */\n    addSteppedPoints(other, pointIndex0, step, numAdd) {\n        const dataB = other._data;\n        let b0 = pointIndex0 * 3;\n        const nb = other.length * 3;\n        let numAdded = 0;\n        this.ensureCapacity(this._xyzInUse + numAdd, false);\n        while (b0 >= 0 && b0 + 2 < nb && numAdded < numAdd) {\n            this.pushXYZ(dataB[b0], dataB[b0 + 1], dataB[b0 + 2]);\n            b0 += step * 3;\n            numAdded++;\n        }\n    }\n    /**\n     * find the min and max distance between corresponding indexed points.   Excess points are ignored.\n     * @param arrayA first array\n     * @param arrayB second array\n     */\n    static distanceRangeBetweenCorrespondingPoints(arrayA, arrayB) {\n        const dataA = arrayA._data;\n        const dataB = arrayB._data;\n        const n = Math.min(arrayA.length, arrayB.length);\n        let i = 0;\n        let k0;\n        const range = Range1d.createNull();\n        while (i < n) {\n            k0 = 3 * i;\n            range.extendX(Geometry.hypotenuseXYZ(dataA[k0] - dataB[k0], dataA[k0 + 1] - dataB[k0 + 1], dataA[k0 + 2] - dataB[k0 + 2]));\n            i++;\n        }\n        return range;\n    }\n    /**\n     * remove trailing point(s) within tolerance of the start point.\n     * @param points\n     * @param tolerance\n     */\n    static removeClosure(points, tolerance = Geometry.smallMetricDistance) {\n        while (points.length > 1 && points.distanceIndexIndex(0, points.length - 1) < tolerance)\n            points.pop();\n    }\n    /**\n     * Compute frame for a triangle formed by three (unchecked!) points identified by index.\n     * * z direction of frame is 001.\n     * * Transform axes from origin to targetA and targetB\n     * * in local coordinates (u,v,w) the xy interior of the triangle is `u>=0, v>= 0, w>= 0, u+v+w<1`\n     * * Return undefined if transform is not invertible, e.g. if points are in a vertical plane.\n     */\n    fillLocalXYTriangleFrame(originIndex, targetAIndex, targetBIndex, result) {\n        if (this.isIndexValid(originIndex) && this.isIndexValid(targetAIndex) && this.isIndexValid(targetBIndex)) {\n            let i0 = originIndex * 3;\n            const data = this._data;\n            const ax = data[i0++];\n            const ay = data[i0++];\n            const az = data[i0++];\n            i0 = targetAIndex * 3;\n            const ux = data[i0++] - ax;\n            const uy = data[i0++] - ay;\n            const uz = data[i0++] - az;\n            i0 = targetBIndex * 3;\n            const vx = data[i0++] - ax;\n            const vy = data[i0++] - ay;\n            const vz = data[i0++] - az;\n            result = Transform.createRowValues(ux, vx, 0, ax, uy, vy, 0, ay, uz, vz, 1, az, result);\n            return result.computeCachedInverse() ? result : undefined;\n        }\n        return undefined;\n    }\n    /**\n     * Pass the (x,y,z) of each point to a function which returns a replacement for one of the 3 components.\n     * @param componentIndex Index (0,1,2) of component to be replaced.\n     * @param func function to be called as `func(x,y,z)`, returning a replacement value for componentIndex\n     */\n    mapComponent(componentIndex, func) {\n        const n = this._data.length;\n        let q;\n        for (let i = 0; i + 2 < n; i += 3) {\n            q = func(this._data[i], this._data[i + 1], this._data[i + 2]);\n            this._data[i + componentIndex] = q;\n        }\n    }\n}\n//# sourceMappingURL=GrowableXYZArray.js.map",
      "start": 1693508123097,
      "end": 1693508123274,
      "sourcemaps": null
    }
  ]
}
