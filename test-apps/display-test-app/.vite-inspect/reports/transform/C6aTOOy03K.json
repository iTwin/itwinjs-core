{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/common/lib/esm/RpcInterface.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module RpcInterface\n */\nimport { RpcConfiguration } from \"./rpc/core/RpcConfiguration\";\nimport { CURRENT_REQUEST } from \"./rpc/core/RpcRegistry\";\nimport { aggregateLoad, RpcRequest } from \"./rpc/core/RpcRequest\";\nimport { RpcRoutingToken } from \"./rpc/core/RpcRoutingToken\";\nimport { IpcSession } from \"./ipc/IpcSession\";\nimport { BentleyStatus, IModelError, NoContentError } from \"./IModelError\";\nimport { RpcRequestEvent, RpcRequestStatus } from \"./rpc/core/RpcConstants\";\nimport { BeDuration } from \"@itwin/core-bentley\";\n/** An RPC interface is a set of operations exposed by a service that a client can call, using configurable protocols,\n * in a platform-independent way. TheRpcInterface class is the base class for RPC interface definitions and implementations.\n * @public\n */\nexport class RpcInterface {\n    static findDiff(backend, frontend) {\n        return backend.major !== frontend.major ? \"major\" :\n            backend.minor !== frontend.minor ? \"minor\" :\n                backend.patch !== frontend.patch ? \"patch\" :\n                    backend.prerelease !== frontend.prerelease ? \"prerelease\" :\n                        \"same\";\n    }\n    static parseVer(version) {\n        // separate the version from the prerelease tag\n        const parts = version.split(/[:-]/);\n        // Split the major.minor.path into separate components\n        const prefix = parts[0].split(\".\");\n        const ver = { major: Number(prefix[0]), minor: Number(prefix[1]), patch: Number(prefix[2]) };\n        if (parts.length > 1)\n            ver.prerelease = parts[1];\n        return ver;\n    }\n    /** Determines whether the backend version of an RPC interface is compatible (according to semantic versioning) with the frontend version of the interface. */\n    static isVersionCompatible(backend, frontend) {\n        if (backend === frontend)\n            return true; // most common case, versions are identical\n        const backendSemver = this.parseVer(backend);\n        const frontendSemver = this.parseVer(frontend);\n        // if either has a prerelease tag, they are not compatible unless version strings are identical\n        if (backendSemver.prerelease || frontendSemver.prerelease)\n            return false;\n        const difference = this.findDiff(backendSemver, frontendSemver);\n        // If the major versions are different, the versions are not compatible\n        if (difference === \"major\")\n            return false;\n        // special case for major version 0. If patch difference, backend patch must be greater than frontend patch\n        if (backendSemver.major === 0)\n            return (difference === \"patch\" && frontendSemver.patch < backendSemver.patch);\n        // patch difference is fine. If minor versions differ, compatible as long as backend minor version is greater\n        return difference === \"patch\" || (difference === \"minor\" && frontendSemver.minor < backendSemver.minor);\n    }\n    /** @beta */\n    constructor(routing = RpcRoutingToken.default) {\n        this.routing = routing;\n        this.configuration = RpcConfiguration.supply(this);\n    }\n    /** Obtains the implementation result for an RPC operation. */\n    async forward(parameters) {\n        const parametersCompat = (arguments.length === 1 && typeof (parameters) === \"object\") ? parameters : arguments;\n        const parametersArray = Array.isArray(parametersCompat) ? parametersCompat : Array.prototype.slice.call(parametersCompat);\n        const operationName = parametersArray.pop();\n        const session = IpcSession.active;\n        if (session) {\n            return intercept(session, this, operationName, parametersArray);\n        }\n        else {\n            const request = new this.configuration.protocol.requestType(this, operationName, parametersArray);\n            request.submit(); // eslint-disable-line @typescript-eslint/no-floating-promises\n            this[CURRENT_REQUEST] = request;\n            return request.response;\n        }\n    }\n}\nRpcInterface.prototype.configurationSupplier = undefined;\nclass InterceptedRequest extends RpcRequest {\n    async load() { throw new Error(); }\n    async send() { throw new Error(); }\n    setHeader(_name, _value) { throw new Error(); }\n}\nasync function intercept(session, client, operation, parameters) {\n    const request = new InterceptedRequest(client, operation, []);\n    client[CURRENT_REQUEST] = request;\n    const context = await client.configuration.protocol.serialize(request);\n    request.parameters = parameters;\n    const info = {\n        definition: {\n            interfaceName: context.operation.interfaceDefinition,\n            interfaceVersion: context.operation.interfaceVersion,\n        },\n        operation,\n        parameters,\n        context: {\n            applicationId: context.applicationId,\n            applicationVersion: context.applicationVersion,\n            id: context.id,\n            sessionId: context.sessionId,\n            protocolVersion: (context.protocolVersion || 0).toString(),\n        },\n    };\n    const dispatch = async () => {\n        aggregateLoad.lastRequest = new Date().getTime();\n        const response = await session.handleRpc(info);\n        aggregateLoad.lastResponse = new Date().getTime();\n        if (typeof (response) === \"object\" && response.hasOwnProperty(\"iTwinRpcCoreResponse\") && response.hasOwnProperty(\"managedStatus\")) {\n            const status = response;\n            if (status.managedStatus === \"pending\") {\n                return handlePending(request, status, dispatch);\n            }\n            else if (status.managedStatus === \"notFound\") {\n                return handleNotFound(request, status, dispatch);\n            }\n            else if (status.managedStatus === \"noContent\") {\n                return handleNoContent();\n            }\n        }\n        else {\n            return response;\n        }\n    };\n    return dispatch();\n}\nasync function handlePending(request, status, dispatch) {\n    request._status = RpcRequestStatus.Pending;\n    request._extendedStatus = status.responseValue.message;\n    RpcRequest.events.raiseEvent(RpcRequestEvent.PendingUpdateReceived, request);\n    const delay = request.operation.policy.retryInterval(request.client.configuration);\n    await BeDuration.wait(delay);\n    return dispatch();\n}\nasync function handleNotFound(request, status, dispatch) {\n    return new Promise((resolve, reject) => {\n        let resubmitted = false;\n        RpcRequest.notFoundHandlers.raiseEvent(request, status.responseValue, async () => {\n            if (resubmitted) {\n                throw new IModelError(BentleyStatus.ERROR, `Already resubmitted using this handler.`);\n            }\n            resubmitted = true;\n            try {\n                const response = await dispatch();\n                resolve(response);\n            }\n            catch (err) {\n                reject(err);\n            }\n        }, reject);\n    });\n}\nasync function handleNoContent() {\n    throw new NoContentError();\n}\n//# sourceMappingURL=RpcInterface.js.map",
      "start": 1693508121052,
      "end": 1693508121122,
      "sourcemaps": null
    }
  ]
}
