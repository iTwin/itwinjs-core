{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/ApproximateTerrainHeights.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Views\n */\nimport { assert } from \"@itwin/core-bentley\";\nimport { Point2d, Range1d } from \"@itwin/core-geometry\";\nimport { Cartographic } from \"@itwin/core-common\";\nimport { GeographicTilingScheme } from \"./tile/internal\";\nlet instance;\n/**\n * A collection of functions for approximating terrain height\n * @internal\n */\nclass ApproximateTerrainHeights {\n    constructor() {\n        this.globalHeightRange = Range1d.createXX(-400, 90000); // Dead Sea to Mount Everest.\n        this._scratchCorners = [Cartographic.createZero(), Cartographic.createZero(), Cartographic.createZero(), Cartographic.createZero()];\n        this._tilingScheme = new GeographicTilingScheme(2, 1, true); // Y at top... ?\n        this._scratchTileXY = Point2d.createZero();\n    }\n    static get instance() {\n        if (undefined === instance)\n            instance = new ApproximateTerrainHeights();\n        return instance;\n    }\n    /**\n     * Initializes the minimum and maximum terrain heights.\n     * @return {Promise}\n     */\n    async initialize() {\n        if (!this._terrainHeights) {\n            const { terrainHeightsPropsString } = await import(\"./ApproximateTerrainHeightsProps\");\n            this._terrainHeights = JSON.parse(terrainHeightsPropsString);\n        }\n    }\n    getTileHeightRange(quadId, result) {\n        result = Range1d.createFrom(this.globalHeightRange, result);\n        if (undefined === this._terrainHeights)\n            return result; // Not initialized.\n        let level = quadId.level, column = quadId.column, row = quadId.row;\n        if (level > 6) {\n            column = column >> (level - 6);\n            row = row >> quadId.row >> ((level - 6));\n            level = 6;\n        }\n        const key = `${level}-${column}-${row}`;\n        const heights = this._terrainHeights[key];\n        assert(undefined !== heights);\n        result.low = heights[0];\n        result.high = heights[1];\n        return result;\n    }\n    getMinimumMaximumHeights(rectangle, result) {\n        result = Range1d.createFrom(this.globalHeightRange, result);\n        if (undefined === this._terrainHeights)\n            return result; // Not initialized.\n        const xyLevel = this._getTileXYLevel(rectangle);\n        if (undefined !== xyLevel) {\n            const key = `${xyLevel.level}-${xyLevel.x}-${xyLevel.y}`;\n            const heights = this._terrainHeights[key];\n            assert(undefined !== heights);\n            if (undefined !== heights) {\n                result.low = heights[0];\n                result.high = heights[1];\n            }\n        }\n        return result;\n    }\n    _getTileXYLevel(rectangle) {\n        Cartographic.fromRadians({ longitude: rectangle.low.x, latitude: rectangle.high.y, height: 0.0 }, this._scratchCorners[0]);\n        Cartographic.fromRadians({ longitude: rectangle.high.x, latitude: rectangle.high.y, height: 0.0 }, this._scratchCorners[1]);\n        Cartographic.fromRadians({ longitude: rectangle.low.x, latitude: rectangle.low.y, height: 0.0 }, this._scratchCorners[2]);\n        Cartographic.fromRadians({ longitude: rectangle.high.x, latitude: rectangle.low.y, height: 0.0 }, this._scratchCorners[3]);\n        // Determine which tile the bounding rectangle is in\n        let lastLevelX = 0, lastLevelY = 0;\n        let currentX = 0, currentY = 0;\n        const maxLevel = ApproximateTerrainHeights.maxLevel;\n        let i;\n        for (i = 0; i <= maxLevel; ++i) {\n            let failed = false;\n            for (let j = 0; j < 4; ++j) {\n                const corner = this._scratchCorners[j];\n                this._tilingScheme.cartographicToTileXY(corner, i, this._scratchTileXY);\n                if (j === 0) {\n                    currentX = this._scratchTileXY.x;\n                    currentY = this._scratchTileXY.y;\n                }\n                else if (currentX !== this._scratchTileXY.x || currentY !== this._scratchTileXY.y) {\n                    failed = true;\n                    break;\n                }\n            }\n            if (failed)\n                break;\n            lastLevelX = currentX;\n            lastLevelY = currentY;\n        }\n        if (i === 0) {\n            return undefined;\n        }\n        return {\n            x: lastLevelX,\n            y: lastLevelY,\n            level: (i > maxLevel) ? maxLevel : (i - 1),\n        };\n    }\n}\nApproximateTerrainHeights.maxLevel = 6;\nexport { ApproximateTerrainHeights };\n//# sourceMappingURL=ApproximateTerrainHeights.js.map",
      "start": 1693508121320,
      "end": 1693508121504,
      "sourcemaps": null
    },
    {
      "name": "vite:build-import-analysis",
      "result": "import { __vitePreload } from \"\u0000vite/preload-helper\";/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Views\n */\nimport { assert } from \"@itwin/core-bentley\";\nimport { Point2d, Range1d } from \"@itwin/core-geometry\";\nimport { Cartographic } from \"@itwin/core-common\";\nimport { GeographicTilingScheme } from \"./tile/internal\";\nlet instance;\n/**\n * A collection of functions for approximating terrain height\n * @internal\n */\nclass ApproximateTerrainHeights {\n    constructor() {\n        this.globalHeightRange = Range1d.createXX(-400, 90000); // Dead Sea to Mount Everest.\n        this._scratchCorners = [Cartographic.createZero(), Cartographic.createZero(), Cartographic.createZero(), Cartographic.createZero()];\n        this._tilingScheme = new GeographicTilingScheme(2, 1, true); // Y at top... ?\n        this._scratchTileXY = Point2d.createZero();\n    }\n    static get instance() {\n        if (undefined === instance)\n            instance = new ApproximateTerrainHeights();\n        return instance;\n    }\n    /**\n     * Initializes the minimum and maximum terrain heights.\n     * @return {Promise}\n     */\n    async initialize() {\n        if (!this._terrainHeights) {\n            const { terrainHeightsPropsString } = await __vitePreload(() => import(\"./ApproximateTerrainHeightsProps\"),__VITE_IS_MODERN__?\"__VITE_PRELOAD__\":void 0);\n            this._terrainHeights = JSON.parse(terrainHeightsPropsString);\n        }\n    }\n    getTileHeightRange(quadId, result) {\n        result = Range1d.createFrom(this.globalHeightRange, result);\n        if (undefined === this._terrainHeights)\n            return result; // Not initialized.\n        let level = quadId.level, column = quadId.column, row = quadId.row;\n        if (level > 6) {\n            column = column >> (level - 6);\n            row = row >> quadId.row >> ((level - 6));\n            level = 6;\n        }\n        const key = `${level}-${column}-${row}`;\n        const heights = this._terrainHeights[key];\n        assert(undefined !== heights);\n        result.low = heights[0];\n        result.high = heights[1];\n        return result;\n    }\n    getMinimumMaximumHeights(rectangle, result) {\n        result = Range1d.createFrom(this.globalHeightRange, result);\n        if (undefined === this._terrainHeights)\n            return result; // Not initialized.\n        const xyLevel = this._getTileXYLevel(rectangle);\n        if (undefined !== xyLevel) {\n            const key = `${xyLevel.level}-${xyLevel.x}-${xyLevel.y}`;\n            const heights = this._terrainHeights[key];\n            assert(undefined !== heights);\n            if (undefined !== heights) {\n                result.low = heights[0];\n                result.high = heights[1];\n            }\n        }\n        return result;\n    }\n    _getTileXYLevel(rectangle) {\n        Cartographic.fromRadians({ longitude: rectangle.low.x, latitude: rectangle.high.y, height: 0.0 }, this._scratchCorners[0]);\n        Cartographic.fromRadians({ longitude: rectangle.high.x, latitude: rectangle.high.y, height: 0.0 }, this._scratchCorners[1]);\n        Cartographic.fromRadians({ longitude: rectangle.low.x, latitude: rectangle.low.y, height: 0.0 }, this._scratchCorners[2]);\n        Cartographic.fromRadians({ longitude: rectangle.high.x, latitude: rectangle.low.y, height: 0.0 }, this._scratchCorners[3]);\n        // Determine which tile the bounding rectangle is in\n        let lastLevelX = 0, lastLevelY = 0;\n        let currentX = 0, currentY = 0;\n        const maxLevel = ApproximateTerrainHeights.maxLevel;\n        let i;\n        for (i = 0; i <= maxLevel; ++i) {\n            let failed = false;\n            for (let j = 0; j < 4; ++j) {\n                const corner = this._scratchCorners[j];\n                this._tilingScheme.cartographicToTileXY(corner, i, this._scratchTileXY);\n                if (j === 0) {\n                    currentX = this._scratchTileXY.x;\n                    currentY = this._scratchTileXY.y;\n                }\n                else if (currentX !== this._scratchTileXY.x || currentY !== this._scratchTileXY.y) {\n                    failed = true;\n                    break;\n                }\n            }\n            if (failed)\n                break;\n            lastLevelX = currentX;\n            lastLevelY = currentY;\n        }\n        if (i === 0) {\n            return undefined;\n        }\n        return {\n            x: lastLevelX,\n            y: lastLevelY,\n            level: (i > maxLevel) ? maxLevel : (i - 1),\n        };\n    }\n}\nApproximateTerrainHeights.maxLevel = 6;\nexport { ApproximateTerrainHeights };\n//# sourceMappingURL=ApproximateTerrainHeights.js.map",
      "start": 1693508121506,
      "end": 1693508121506,
      "order": "normal",
      "sourcemaps": null
    }
  ]
}
