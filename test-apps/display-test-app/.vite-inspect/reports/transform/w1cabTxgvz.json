{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/serialization/GeometrySamples.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Serialization\n */\nimport { BezierCurve3d } from \"../bspline/BezierCurve3d\";\nimport { BezierCurve3dH } from \"../bspline/BezierCurve3dH\";\nimport { BSplineCurve3d } from \"../bspline/BSplineCurve\";\nimport { BSplineCurve3dH } from \"../bspline/BSplineCurve3dH\";\nimport { BSplineSurface3d, BSplineSurface3dH, WeightStyle } from \"../bspline/BSplineSurface\";\nimport { InterpolationCurve3d, InterpolationCurve3dOptions } from \"../bspline/InterpolationCurve3d\";\nimport { BSplineWrapMode, KnotVector } from \"../bspline/KnotVector\";\nimport { ClipPlane } from \"../clipping/ClipPlane\";\nimport { ConvexClipPlaneSet } from \"../clipping/ConvexClipPlaneSet\";\nimport { UnionOfConvexClipPlaneSets } from \"../clipping/UnionOfConvexClipPlaneSets\";\nimport { Arc3d } from \"../curve/Arc3d\";\nimport { CoordinateXYZ } from \"../curve/CoordinateXYZ\";\nimport { CurveChainWithDistanceIndex } from \"../curve/CurveChainWithDistanceIndex\";\nimport { BagOfCurves } from \"../curve/CurveCollection\";\nimport { LineSegment3d } from \"../curve/LineSegment3d\";\nimport { LineString3d } from \"../curve/LineString3d\";\nimport { Loop } from \"../curve/Loop\";\nimport { ParityRegion } from \"../curve/ParityRegion\";\nimport { Path } from \"../curve/Path\";\nimport { PointString3d } from \"../curve/PointString3d\";\nimport { DirectSpiral3d } from \"../curve/spiral/DirectSpiral3d\";\nimport { IntegratedSpiral3d } from \"../curve/spiral/IntegratedSpiral3d\";\nimport { UnionRegion } from \"../curve/UnionRegion\";\nimport { AxisOrder, Geometry } from \"../Geometry\";\nimport { Angle } from \"../geometry3d/Angle\";\nimport { AngleSweep } from \"../geometry3d/AngleSweep\";\nimport { GrowableFloat64Array } from \"../geometry3d/GrowableFloat64Array\";\nimport { GrowableXYZArray } from \"../geometry3d/GrowableXYZArray\";\nimport { Matrix3d } from \"../geometry3d/Matrix3d\";\nimport { Plane3dByOriginAndUnitNormal } from \"../geometry3d/Plane3dByOriginAndUnitNormal\";\nimport { Point2d, Vector2d } from \"../geometry3d/Point2dVector2d\";\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\nimport { Range1d, Range2d, Range3d } from \"../geometry3d/Range\";\nimport { Ray3d } from \"../geometry3d/Ray3d\";\nimport { Segment1d } from \"../geometry3d/Segment1d\";\nimport { Transform } from \"../geometry3d/Transform\";\nimport { Map4d } from \"../geometry4d/Map4d\";\nimport { Matrix4d } from \"../geometry4d/Matrix4d\";\nimport { Point4d } from \"../geometry4d/Point4d\";\nimport { AuxChannel, AuxChannelData, PolyfaceAuxData } from \"../polyface/AuxData\";\nimport { IndexedPolyface } from \"../polyface/Polyface\";\nimport { PolyfaceBuilder } from \"../polyface/PolyfaceBuilder\";\nimport { Box } from \"../solid/Box\";\nimport { Cone } from \"../solid/Cone\";\nimport { LinearSweep } from \"../solid/LinearSweep\";\nimport { RotationalSweep } from \"../solid/RotationalSweep\";\nimport { RuledSweep } from \"../solid/RuledSweep\";\nimport { Sphere } from \"../solid/Sphere\";\nimport { TorusPipe } from \"../solid/TorusPipe\";\n/**\n * Static methods to create functions of type SteppedIndexFunction\n * * Convention: constant value is optional last argument, with default value 0\n * @alpha\n */\nexport class SteppedIndexFunctionFactory {\n    /** Returns a callable function that returns a constant value. */\n    static createConstant(value = 0) {\n        return (_i, _n) => value;\n    }\n    /**\n     * Return a function that steps linearly\n     * *  f(i,n) = y0 + (i/n) * a\n     */\n    static createLinear(a, f0 = 0) {\n        return (i, n) => (f0 + a * (i / n));\n    }\n    /**\n     * Return a function that steps with cosine of angles in sweep\n     * *  f(i,n) = y0 + amplitude * cos(i/n)\n     */\n    static createCosine(amplitude, sweep = AngleSweep.create360(), f0 = 0) {\n        return (i, n) => (f0 + amplitude * Math.cos(sweep.fractionToRadians(i / n)));\n    }\n    /**\n     * Return a function that steps with cosine of angles in sweep.\n     * *  f(i,n) = y0 + amplitude * sin(i/n)\n     */\n    static createSine(amplitude, sweep = AngleSweep.create360(), f0 = 0) {\n        return (i, n) => (f0 + amplitude * Math.sin(sweep.fractionToRadians(i / n)));\n    }\n}\n/**\n * `Sample` has static methods to create a variety of geometry samples useful in testing.\n * @alpha\n */\nclass Sample {\n    /**\n     * Return an array of Point3d, with x,y,z all stepping through a range of values.\n     * x varies fastest, then y then z\n     */\n    static createPoint3dLattice(low, step, high) {\n        const points = [];\n        for (let z = low; z <= high; z += step)\n            for (let y = low; y <= high; y += step)\n                for (let x = low; x <= high; x += step)\n                    points.push(Point3d.create(x, y, z));\n        return points;\n    }\n    /**\n     * Return an array of Point2d, with x,y all stepping through a range of values.\n     * x varies fastest, then y\n     */\n    static createPoint2dLattice(low, step, high) {\n        const points = [];\n        for (let y = low; y <= high; y += step)\n            for (let x = low; x <= high; x += step)\n                points.push(Point2d.create(x, y));\n        return points;\n    }\n    /** Array with assorted nonzero vector samples. */\n    static createNonZeroVectors() {\n        return [\n            Vector3d.create(1, 0, 0),\n            Vector3d.create(0, 1, 0),\n            Vector3d.create(0, 0, 1),\n            Vector3d.create(-1, 0, 0),\n            Vector3d.create(0, -1, 0),\n            Vector3d.create(0, 0, -1),\n            Vector3d.createPolar(1.0, Angle.createDegrees(20)),\n            Vector3d.createSpherical(1.0, Angle.createDegrees(20), Angle.createDegrees(10)),\n            Vector3d.createPolar(2.0, Angle.createDegrees(20)),\n            Vector3d.createSpherical(2.0, Angle.createDegrees(20), Angle.createDegrees(10)),\n            Vector3d.create(2, 3, 0),\n        ];\n    }\n    /** Return an array with assorted Range3d samples */\n    static createRange3ds() {\n        return [\n            Range3d.createXYZXYZ(0, 0, 0, 1, 1, 1),\n            Range3d.createXYZ(1, 2, 3),\n            Range3d.createXYZXYZ(-2, -3, 1, 200, 301, 8),\n        ];\n    }\n    /** Create 5 points of a (axis aligned) rectangle with corners (x0,y0) and (x0+ax, y0 + ay) */\n    static createRectangleXY(x0, y0, ax, ay, z = 0) {\n        return [\n            Point3d.create(x0, y0, z),\n            Point3d.create(x0 + ax, y0, z),\n            Point3d.create(x0 + ax, y0 + ay, z),\n            Point3d.create(x0, y0 + ay, z),\n            Point3d.create(x0, y0, z),\n        ];\n    }\n    /** Create 5 points of a (axis aligned) rectangle with corners (cx-ax,cy-ay) and (cx+ax,cy+ay) */\n    static createCenteredRectangleXY(cx, cy, ax, ay, z = 0) {\n        return this.createRectangleXY(cx - ax, cy - ay, 2 * ax, 2 * ay, z);\n    }\n    /**\n     * Access the last point in the array. push another shifted by dx,dy,dz.\n     * * No push if all are 0.\n     * * If array is empty, push a leading 000\n     */\n    static pushMove(data, dx, dy, dz = 0.0) {\n        if (data.length === 0)\n            data.push(Point3d.create(0, 0, 0));\n        const back = data[data.length - 1];\n        if (dx !== 0 || dy !== 0 || dz !== 0)\n            data.push(Point3d.create(back.x + dx, back.y + dy, back.z + dz));\n    }\n    /** Return an array with numPoints on the unit circle (counting closure) */\n    static createUnitCircle(numPoints) {\n        const points = [];\n        const dTheta = Geometry.safeDivideFraction(Math.PI * 2, numPoints - 1, 0.0);\n        for (let i = 0; i + 1 < numPoints; i++) {\n            const theta = i * dTheta;\n            points.push(Point3d.create(Math.cos(theta), Math.sin(theta), 0.0));\n        }\n        points.push(points[0].clone());\n        return points;\n    }\n    /**\n     * Create points for an L shaped polygon\n     * * lower left at x0,y0.\n     * * ax,ay are larger side lengths (lower left to corners along x and y directions)\n     * * bx,by are smaller side lengths (inner corner to points along x and y directions)\n     */\n    static createLShapedPolygon(x0, y0, ax, ay, bx, by, z = 0) {\n        return [\n            Point3d.create(x0, y0, z),\n            Point3d.create(x0 + ax, y0, z),\n            Point3d.create(x0 + ax, y0 + by),\n            Point3d.create(x0 + bx, y0 + by),\n            Point3d.create(x0 + bx, y0 + ay, z),\n            Point3d.create(x0, y0 + ay, z),\n            Point3d.create(x0, y0, z),\n        ];\n    }\n    /** Create assorted clip planes. */\n    static createClipPlanes() {\n        const plane0 = ClipPlane.createNormalAndDistance(Vector3d.create(1, 0, 0), 2.0);\n        const plane1 = plane0.cloneNegated();\n        const plane2 = plane1.clone();\n        plane2.setFlags(true, true);\n        return [\n            plane0, plane1, plane2,\n            ClipPlane.createNormalAndDistance(Vector3d.create(3, 4, 0), 2.0),\n            ClipPlane.createEdgeXY(Point3d.create(1, 0, 0), Point3d.create(24, 32, 0)),\n        ];\n    }\n    /**\n     * * A first-quadrant unit square\n     * * Two squares -- first and fourth quadrant unit squares\n     * * Three squares -- first, second and fourth quadrant unit squares\n     */\n    static createClipPlaneSets() {\n        const result = [];\n        const quadrant1 = ConvexClipPlaneSet.createXYBox(0, 0, 1, 1);\n        result.push(UnionOfConvexClipPlaneSets.createConvexSets([quadrant1.clone()]));\n        const quadrant2 = ConvexClipPlaneSet.createXYBox(-1, 0, 0, 1);\n        const quadrant4 = ConvexClipPlaneSet.createXYBox(0, -1, 1, 0);\n        result.push(UnionOfConvexClipPlaneSets.createConvexSets([\n            quadrant1.clone(),\n            quadrant4.clone(),\n        ]));\n        result.push(UnionOfConvexClipPlaneSets.createConvexSets([\n            quadrant1.clone(),\n            quadrant2.clone(),\n            quadrant4.clone(),\n        ]));\n        return result;\n    }\n    /**\n     * Create (unweighted) bspline curves.\n     * order varies from 2 to 5\n     */\n    static createBsplineCurves(includeMultipleKnots = false) {\n        const result = [];\n        const yScale = 0.1;\n        for (const order of [2, 3, 4, 5]) {\n            const points = [];\n            for (const x of [0, 1, 2, 3, 4, 5, 7]) {\n                points.push(Point3d.create(x, yScale * (1 + x * x), 0.0));\n            }\n            const curve = BSplineCurve3d.createUniformKnots(points, order);\n            result.push(curve);\n        }\n        if (includeMultipleKnots) {\n            const interiorKnotCandidates = [1, 2, 2, 3, 4, 5, 5, 6, 7, 7, 8];\n            for (const order of [3, 4]) {\n                const numPoints = 8;\n                const points = [];\n                for (let i = 0; i < numPoints; i++)\n                    points.push(Point3d.create(i, i * i, 0));\n                const knots = [];\n                for (let i = 0; i < order - 1; i++)\n                    knots.push(0);\n                const numInteriorNeeded = numPoints - order;\n                for (let i = 0; i < numInteriorNeeded; i++)\n                    knots.push(interiorKnotCandidates[i]);\n                const lastKnot = knots[knots.length - 1] + 1;\n                for (let i = 0; i < order - 1; i++)\n                    knots.push(lastKnot);\n                const curve = BSplineCurve3d.create(points, knots, order);\n                if (curve)\n                    result.push(curve);\n            }\n        }\n        return result;\n    }\n    /**\n     * Create weighted bspline curves.\n     * order varies from 2 to 5\n     */\n    static createBspline3dHCurves() {\n        const result = [];\n        const yScale = 0.1;\n        for (const weightVariation of [0, 0.125]) {\n            for (const order of [2, 3, 4, 5]) {\n                const points = [];\n                for (const x of [0, 1, 2, 3, 4, 5, 7]) {\n                    points.push(Point4d.create(x, yScale * (1 + x * x), 0.0, 1.0 + weightVariation * Math.sin(x * Math.PI * 0.25)));\n                }\n                const curve = BSplineCurve3dH.createUniformKnots(points, order);\n                result.push(curve);\n            }\n        }\n        return result;\n    }\n    /** Create various orders of non-rational B-spline curves with helical poles */\n    static createBsplineCurveHelices(radius, height, numTurns, numSamplesPerTurn) {\n        const pts = [];\n        const zDelta = (height / numTurns) / numSamplesPerTurn;\n        const aDelta = 2 * Math.PI / numSamplesPerTurn;\n        for (let iTurn = 0; iTurn < numTurns; ++iTurn) {\n            for (let iSample = 0; iSample < numSamplesPerTurn; iSample++) {\n                pts.push(Point3d.create(radius * Math.cos(iSample * aDelta), radius * Math.sin(iSample * aDelta), pts.length * zDelta));\n            }\n        }\n        const result = [];\n        for (const order of [2, 3, 4, 9, 16, 25]) {\n            if (order > pts.length)\n                continue;\n            const curve = BSplineCurve3d.createUniformKnots(pts, order);\n            if (curve !== undefined)\n                result.push(curve);\n        }\n        return result;\n    }\n    /** Create weighted bsplines for circular arcs. */\n    static createBspline3dHArcs() {\n        const result = [];\n        const halfRadians = Angle.degreesToRadians(60.0);\n        const c = Math.cos(halfRadians);\n        const s = Math.sin(halfRadians);\n        // const sec = 1.0 / c;\n        // const t = s / c;\n        const points = [\n            Point4d.create(1, 0, 0, 1),\n            Point4d.create(c, s, 0, c),\n            Point4d.create(-c, s, 0, 1),\n            Point4d.create(-1, 0, 0, c),\n            Point4d.create(-c, -s, 0, 1),\n            Point4d.create(c, -s, 0, c),\n            Point4d.create(1, 0, 0, 1),\n        ];\n        const knots = [0, 0, 1, 1, 2, 2, 3, 3];\n        const curve = BSplineCurve3dH.create(points, knots, 3);\n        result.push(curve);\n        return result;\n    }\n    /**\n     * Return array   [x,y,z,w] bspline control points for an arc in 90 degree bspline spans.\n     * @param points array of [x,y,z,w]\n     * @param center center of arc\n     * @param axes matrix with 0 and 90 degree axes\n     * @param radius0 radius multiplier for x direction.\n     * @param radius90 radius multiplier for y direction.\n     * @param applyWeightsToXYZ\n     */\n    static createBsplineArc90SectionToXYZWArrays(center, axes, radius0, radius90, applyWeightsToXYZ) {\n        const a = Math.sqrt(0.5);\n        const xyz = Point3d.create();\n        Matrix3d.xyzPlusMatrixTimesCoordinates(center, axes, radius0, 0.0, 0, xyz);\n        const controlPoints = [];\n        controlPoints.push([xyz.x, xyz.y, xyz.z, 1.0]);\n        const cornerTrig = [1, 1, -1, -1, 1];\n        const axisTrig = [1, 0, -1, 0, 1];\n        for (let i = 0; i < 4; i++) {\n            Matrix3d.xyzPlusMatrixTimesCoordinates(center, axes, radius0 * cornerTrig[i + 1], radius90 * cornerTrig[i], 0, xyz);\n            controlPoints.push([xyz.x, xyz.y, xyz.z, a]);\n            Matrix3d.xyzPlusMatrixTimesCoordinates(center, axes, radius0 * axisTrig[i + 1], radius90 * axisTrig[i], 0, xyz);\n            controlPoints.push([xyz.x, xyz.y, xyz.z, 1.0]);\n        }\n        if (applyWeightsToXYZ) {\n            for (const xyzw of controlPoints) {\n                const b = xyzw[3];\n                xyzw[0] *= b;\n                xyzw[1] *= b;\n                xyzw[2] *= b;\n            }\n        }\n        return controlPoints;\n    }\n    /**\n     * Create both unweighted and weighted bspline curves.\n     * (This is the combined results from createBsplineCurves and createBspline3dHCurves)\n     */\n    static createMixedBsplineCurves() {\n        const arrayA = Sample.createBsplineCurves();\n        const arrayB = Sample.createBspline3dHCurves();\n        const result = [];\n        for (const a of arrayA)\n            result.push(a);\n        for (const b of arrayB)\n            result.push(b);\n        return result;\n    }\n    /** Create a plane from origin and normal coordinates -- default to 001 normal if needed. */\n    static createPlane(x, y, z, u, v, w) {\n        const point = Point3d.create(x, y, z);\n        const vector = Vector3d.create(u, v, w).normalize();\n        if (vector) {\n            const plane = Plane3dByOriginAndUnitNormal.create(point, vector);\n            if (plane)\n                return plane;\n        }\n        return Sample.createPlane(x, y, z, u, v, 1);\n    }\n    /** Create ray from (x,y,z) and direction components.   (Normalize the direction) */\n    static createRay(x, y, z, u, v, w) {\n        return Ray3d.create(Point3d.create(x, y, z), Vector3d.create(u, v, w).normalize());\n    }\n    /** Assorted lines strings */\n    static createLineStrings() {\n        return [\n            LineString3d.createPoints([\n                Point3d.create(0, 0, 0),\n                Point3d.create(1, 0, 0),\n            ]),\n            LineString3d.createPoints([\n                Point3d.create(0, 0, 0),\n                Point3d.create(1, 0, 0),\n                Point3d.create(1, 1, 0),\n            ]),\n            LineString3d.createPoints([\n                Point3d.create(0, 0, 0),\n                Point3d.create(1, 0, 0),\n                Point3d.create(1, 1, 0),\n                Point3d.create(2, 2, 0),\n            ]),\n        ];\n    }\n    /**\n     * Assorted Matrix3d:\n     * * identity\n     * * rotation around x\n     * * rotation around general vector\n     * * uniform scale\n     * * nonuniform scale (including negative scales!)\n     */\n    static createMatrix3dArray() {\n        return [\n            Matrix3d.createIdentity(),\n            Matrix3d.createRotationAroundVector(Vector3d.create(1, 0, 0), Angle.createDegrees(10)),\n            Matrix3d.createRotationAroundVector(Vector3d.create(1, -2, 5), Angle.createDegrees(-6.0)),\n            Matrix3d.createRotationAroundVector(Vector3d.create(1, 2, 3), Angle.createDegrees(49.0)),\n            Matrix3d.createUniformScale(2.0),\n            Matrix3d.createScale(1, 1, -1),\n            Matrix3d.createScale(2, 3, 4),\n        ];\n    }\n    /** Assorted invertible transforms. */\n    static createInvertibleTransforms() {\n        return [\n            Transform.createIdentity(),\n            Transform.createTranslationXYZ(1, 2, 0),\n            Transform.createTranslationXYZ(1, 2, 3),\n            Transform.createFixedPointAndMatrix(Point3d.create(4, 1, -2), Matrix3d.createUniformScale(2.0)),\n            Transform.createFixedPointAndMatrix(Point3d.create(4, 1, -2), Matrix3d.createRotationAroundVector(Vector3d.create(1, 2, 3), Angle.createRadians(10))),\n        ];\n    }\n    /**\n     * Return an array of Matrix3d with various skew and scale.  This includes at least:\n     * * identity\n     * * 3 distinct diagonals.\n     * * The distinct diagonal base with smaller value added to other 6 spots in succession.\n     * * the distinct diagonals with all others also smaller non-zeros.\n     */\n    static createScaleSkewMatrix3d() {\n        return [\n            Matrix3d.createRowValues(1, 0, 0, 0, 1, 0, 0, 0, 1),\n            Matrix3d.createRowValues(5, 0, 0, 0, 6, 0, 0, 0, 7),\n            Matrix3d.createRowValues(5, 2, 0, 0, 6, 0, 0, 0, 7),\n            Matrix3d.createRowValues(5, 0, 2, 0, 6, 0, 0, 0, 7),\n            Matrix3d.createRowValues(5, 0, 0, 1, 6, 0, 0, 0, 7),\n            Matrix3d.createRowValues(5, 0, 0, 0, 6, 1, 0, 0, 7),\n            Matrix3d.createRowValues(5, 0, 0, 0, 6, 0, 1, 0, 7),\n            Matrix3d.createRowValues(5, 0, 0, 0, 6, 0, 0, 1, 7),\n            Matrix3d.createRowValues(5, 2, 3, 2, 6, 1, -1, 2, 7),\n        ];\n    }\n    /**\n     * Return an array of singular Matrix3d. This includes at least:\n     * * all zeros\n     * * one non-zero column\n     * * two independent columns, third is zero\n     * * two independent columns, third is sum of those\n     * * two independent columns, third is copy of one\n     */\n    static createSingularMatrix3d() {\n        const vectorU = Vector3d.create(2, 3, 6);\n        const vectorV = Vector3d.create(-1, 5, 2);\n        const vectorUPlusV = vectorU.plus(vectorV);\n        const vector0 = Vector3d.createZero();\n        return [\n            Matrix3d.createZero(),\n            // one non-zero column\n            Matrix3d.createColumns(vectorU, vector0, vector0),\n            Matrix3d.createColumns(vector0, vectorU, vector0),\n            Matrix3d.createColumns(vector0, vector0, vectorU),\n            // two independent non-zero columns with one zero column\n            Matrix3d.createColumns(vectorU, vectorV, vector0),\n            Matrix3d.createColumns(vector0, vectorU, vectorV),\n            Matrix3d.createColumns(vectorU, vector0, vectorV),\n            // two independent columns with one dependent column\n            Matrix3d.createColumns(vectorU, vectorV, vectorUPlusV),\n            Matrix3d.createColumns(vectorU, vectorUPlusV, vectorV),\n            Matrix3d.createColumns(vectorUPlusV, vectorU, vectorV),\n            // two independent with columns with one duplicate column\n            Matrix3d.createColumns(vectorU, vectorU, vectorV),\n            Matrix3d.createColumns(vectorU, vectorV, vectorU),\n            Matrix3d.createColumns(vectorV, vectorU, vectorU),\n        ];\n    }\n    /**\n     * Return an array of rigid transforms. This includes (at least)\n     *   * Identity\n     *   * translation with identity matrix\n     *   * rotation around origin and arbitrary vector\n     *   * rotation around space point and arbitrary vector\n     * * use given refDistance is crude distance of translation and distance to fixed point.\n     */\n    static createRigidTransforms(distanceScale = 4.0) {\n        const distanceScale3 = distanceScale / 3.0;\n        const distanceScale4 = distanceScale / 4.0;\n        return [\n            Transform.createIdentity(),\n            Transform.createTranslationXYZ(distanceScale3 * 1, distanceScale3 * 2, distanceScale3 * 3),\n            Transform.createFixedPointAndMatrix(Point3d.create(0, 0, 0), Matrix3d.createRotationAroundVector(Vector3d.unitY(), Angle.createDegrees(10))),\n            Transform.createFixedPointAndMatrix(Point3d.create(distanceScale4 * 4, distanceScale4 * 1, -distanceScale4 * 2), Matrix3d.createRotationAroundVector(Vector3d.create(1, 2, 3), Angle.createDegrees(10))),\n            Transform.createFixedPointAndMatrix(Point3d.create(distanceScale4 * 4, distanceScale4 * 1, -distanceScale4 * 2), Matrix3d.createRotationAroundVector(Vector3d.create(-2, 1, 4), Angle.createDegrees(35))),\n        ];\n    }\n    /** Return a single rigid transform with all terms nonzero. */\n    static createMessyRigidTransform(fixedPoint) {\n        return Transform.createFixedPointAndMatrix(fixedPoint ? fixedPoint : Point3d.create(1, 2, 3), Matrix3d.createRotationAroundVector(Vector3d.create(0.3, -0.2, 1.2), Angle.createDegrees(15.7)));\n    }\n    /**\n     * Return various rigid matrices:\n     * * identity\n     * * small rotations around x, y, z\n     * * small rotation around (1,2,3)\n     */\n    static createRigidAxes() {\n        return [\n            Matrix3d.createIdentity(),\n            Matrix3d.createRotationAroundVector(Vector3d.unitX(), Angle.createDegrees(10)),\n            Matrix3d.createRotationAroundVector(Vector3d.unitY(), Angle.createDegrees(10)),\n            Matrix3d.createRotationAroundVector(Vector3d.unitZ(), Angle.createDegrees(10)),\n            Matrix3d.createRotationAroundVector(Vector3d.create(1, 2, 3), Angle.createDegrees(10)),\n        ];\n    }\n    /**\n     * Return various Matrix4d\n     * * Simple promotion of each Sample.createInvertibleTransforms ()\n     * * optional nasty [1,2,3,4...15] row order\n     * @param includeIrregular if true, include [1,2,..15] row major\n     */ // promote each transform[] to a Matrix4d.\n    static createMatrix4ds(includeIrregular = false) {\n        const result = [];\n        let transform;\n        for (transform of Sample.createInvertibleTransforms())\n            result.push(Matrix4d.createTransform(transform));\n        if (includeIrregular) {\n            result.push(Matrix4d.createRowValues(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16));\n        }\n        return result;\n    }\n    /** Create full Map4d for each `Sample.createInvertibleTransforms()` */\n    static createMap4ds() {\n        const result = [];\n        let transform;\n        for (transform of Sample.createInvertibleTransforms()) {\n            const inverse = transform.inverse();\n            if (inverse) {\n                const map = Map4d.createTransform(transform, inverse);\n                if (map)\n                    result.push(map);\n            }\n        }\n        return result;\n    }\n    /** Assorted simple `Path` objects. */\n    static createSimplePaths(withGaps = false) {\n        const point0 = Point3d.create(0, 0, 0);\n        const point1 = Point3d.create(10, 0, 0);\n        const p1 = [\n            point1, Point3d.create(0, 10, 0),\n            Point3d.create(6, 10, 0),\n            Point3d.create(6, 10, 0),\n            Point3d.create(0, 10, 0),\n        ];\n        const segment1 = LineSegment3d.create(point0, point1);\n        const vectorU = Vector3d.unitX(3);\n        const vectorV = Vector3d.unitY(3);\n        const arc2 = Arc3d.create(point1.minus(vectorU), vectorU, vectorV, AngleSweep.createStartEndDegrees(0, 90));\n        const simplePaths = [\n            Path.create(segment1),\n            Path.create(segment1, arc2),\n            Path.create(LineSegment3d.create(point0, point1), LineString3d.create(p1)),\n            Sample.createCappedArcPath(4, 0, 180),\n        ];\n        if (withGaps)\n            simplePaths.push(Path.create(LineSegment3d.create(Point3d.create(0, 0, 0), Point3d.create(10, 0, 0)), LineSegment3d.create(Point3d.create(10, 10, 0), Point3d.create(5, 0, 0))));\n        return simplePaths;\n    }\n    /**\n     * Assorted `Path` with lines and arcs.\n     * Specifically useful for offset tests.\n     */\n    static createLineArcPaths() {\n        const paths = [];\n        const x1 = 10.0;\n        const y2 = 5.0;\n        const y3 = 10.0;\n        for (const y0 of [0, -1, 1]) {\n            for (const x2 of [15, 11, 20, 9, 7]) {\n                const point0 = Point3d.create(0, y0, 0);\n                const point1 = Point3d.create(x1, 0, 0);\n                const point2 = Point3d.create(x2, y2, 0);\n                const point3 = Point3d.create(x1, y3, 0);\n                const point4 = Point3d.create(0, y3 + y0, 0);\n                const path0 = Path.create();\n                path0.tryAddChild(LineString3d.create(point0, point1, point2, point3, point4));\n                paths.push(path0);\n                const path1 = Path.create();\n                path1.tryAddChild(LineSegment3d.create(point0, point1));\n                path1.tryAddChild(Arc3d.createCircularStartMiddleEnd(point1, Point3d.create(x2, y2, 0), point3));\n                path1.tryAddChild(LineSegment3d.create(point3, point4));\n                paths.push(path1);\n            }\n        }\n        return paths;\n    }\n    /** Assorted `PointString3d` objects. */\n    static createSimplePointStrings() {\n        const p1 = [\n            [Point3d.create(0, 10, 0)],\n            [Point3d.create(6, 10, 0)],\n            [Point3d.create(6, 10, 0), [Point3d.create(6, 10, 0)]],\n        ];\n        const simplePaths = [\n            PointString3d.create(Point3d.create(1, 2, 0)),\n            PointString3d.create(Point3d.create(0, 0, 0), Point3d.create(10, 0, 0)),\n            PointString3d.create(Point3d.create(10, 0, 0), Point3d.create(10, 5, 0)),\n            PointString3d.create(p1),\n        ];\n        return simplePaths;\n    }\n    /** Assorted `Loop` objects */\n    static createSimpleLoops() {\n        const point0 = Point3d.create(0, 0, 0);\n        const point1 = Point3d.create(10, 0, 0);\n        const point2 = Point3d.create(10, 5, 0);\n        const point3 = Point3d.create(0, 5, 0);\n        const result = [\n            // rectangle with single linestring\n            Loop.create(LineString3d.create(point0, point1, point2, point3, point0)),\n            // unit circle\n            Loop.create(Arc3d.createUnitCircle()),\n            // rectangle, but with individual line segments\n            Loop.create(LineSegment3d.create(point0, point1), LineSegment3d.create(point1, point2), LineSegment3d.create(point2, point3), LineSegment3d.create(point3, point0)),\n            // Semicircle\n            Sample.createCappedArcLoop(4, -90, 90),\n        ];\n        return result;\n    }\n    /**\n     * Create a square wave along x direction\n     * @param dx0 distance along x axis at y=0\n     * @param dy vertical rise\n     * @param dx1 distance along x axis at y=dy\n     * @param numPhase number of phases of the jump.\n     * @param dyReturn y value for return to origin.  If 0, the wave ends at y=0 after then final \"down\" with one extra horizontal dx0\n     * If nonzero, rise to that y value, return to x=0, and return down to origin.\n     */\n    static createSquareWave(origin, dx0, dy, dx1, numPhase, dyReturn) {\n        const result = [origin.clone()];\n        for (let i = 0; i < numPhase; i++) {\n            this.pushMove(result, dx0, 0);\n            this.pushMove(result, 0, dy);\n            this.pushMove(result, dx1, 0);\n            this.pushMove(result, 0, -dy);\n        }\n        this.pushMove(result, dx0, 0);\n        if (dyReturn !== 0.0) {\n            this.pushMove(result, 0, dyReturn);\n            result.push(Point3d.create(origin.x, origin.y + dyReturn));\n            result.push(result[0].clone());\n        }\n        return result;\n    }\n    /**\n     * Create multiple interpolated points between two points\n     * @param point0 start point (at fraction0)\n     * @param point1 end point (at fraction1)\n     * @param numPoints total number of points.  This is force to at least 2.\n     * @param result optional existing array to receive points.\n     * @param index0 optional index of first point.  Default is 0.\n     * @param index1 optional index of final point.  Default is numPoints\n     */\n    static createInterpolatedPoints(point0, point1, numPoints, result, index0, index1) {\n        if (numPoints < 2)\n            numPoints = 2;\n        if (result === undefined)\n            result = [];\n        if (index0 === undefined)\n            index0 = 0;\n        if (index1 === undefined)\n            index1 = numPoints;\n        for (let i = index0; i <= index1; i++) {\n            result.push(point0.interpolate(i / numPoints, point1));\n        }\n        return result;\n    }\n    /**\n     * Append numPhase teeth.  Each tooth starts with dxLow dwell at initial y, then sloped rise, then dwell at top, then sloped fall\n     * * If no points are present, start with 000.  (this happens in pushMove) Otherwise start from final point.\n     * * return points array reference.\n     * @param points point array to receive points\n     * @param dxLow starting step along x direction\n     * @param riseX width of rising and falling parts\n     * @param riseY height of rise\n     * @param dxHigh width at top\n     * @param numPhase number of phases.\n     */\n    static appendSawTooth(points, dxLow, riseX, riseY, dxHigh, numPhase) {\n        for (let i = 0; i < numPhase; i++) {\n            this.pushMove(points, dxLow, 0, 0);\n            this.pushMove(points, riseX, riseY, 0);\n            this.pushMove(points, dxHigh, 0, 0);\n            this.pushMove(points, riseX, -riseY, 0);\n        }\n        return points;\n    }\n    /** Append sawtooth with x distances successively scaled by xFactor */\n    static appendVariableSawTooth(points, dxLow, riseX, riseY, dxHigh, numPhase, xFactor) {\n        let factor = 1.0;\n        for (let i = 0; i < numPhase; i++) {\n            this.appendSawTooth(points, factor * dxLow, factor * riseX, riseY, factor * dxHigh, 1);\n            factor *= xFactor;\n        }\n        return points;\n    }\n    /**\n     * Create a pair of sawtooth patterns, one (nominally) outbound and up, the other inbound and down.\n     * * return phase count adjusted to end at start x\n     * * enter return dx values as lengths -- sign will be negated in construction.\n     * @param origin start of entire path.\n     * @param dxLow low outbound dwell\n     * @param riseX x part of outbound rise and fall\n     * @param riseY y part of outbound rise and fall\n     * @param dxHigh high outbound dwell\n     * @param numPhaseOutbound number of phases outbound.  Final phase followed by dxLow dwell.\n     * @param dyFinal rise after final dwell.\n     * @param dxLowReturn dwell at return high\n     * @param riseXReturn rise x part of return\n     * @param riseYReturn rise y part of return\n     * @param dxHighReturn  dwell at return high\n     */\n    static createBidirectionalSawtooth(origin, dxLow, riseX, riseY, dxHigh, numPhaseOutbound, dyFinal, dxLowReturn, riseXReturn, riseYReturn, dxHighReturn) {\n        const data = [origin.clone()];\n        const x0 = data[0].x;\n        this.appendSawTooth(data, dxLow, riseX, riseY, dxHigh, numPhaseOutbound);\n        this.pushMove(data, dxLow, 0, 0);\n        this.pushMove(data, 0, dyFinal);\n        const x1 = data[data.length - 1].x;\n        const returnPhase = Math.abs(dxLowReturn + 2 * riseXReturn + dxHighReturn);\n        const totalDX = Math.abs(x1 - x0);\n        const numReturnPhase = Math.floor(Math.abs(totalDX / returnPhase));\n        this.appendSawTooth(data, -dxLowReturn, -riseXReturn, riseYReturn, -dxHighReturn, numReturnPhase);\n        const x2 = data[data.length - 1].x;\n        this.pushMove(data, x0 - x2, 0, 0);\n        data.push(data[0].clone());\n        return data;\n    }\n    /**\n     * Append to a linestring, taking steps along given vector directions\n     * If the linestring is empty, a 000 point is added.\n     * @param linestring LineString3d to receive points.\n     * @param numPhase number of phases of the sawtooth\n     * @param vectors any number of vector steps.\n     */\n    static appendPhases(linestring, numPhase, ...vectors) {\n        const tailPoint = linestring.endPoint(); // and this defaults to 000 . ..\n        if (linestring.numPoints() === 0)\n            linestring.addPoint(tailPoint);\n        for (let i = 0; i < numPhase; i++) {\n            for (const v of vectors) {\n                tailPoint.addInPlace(v);\n                linestring.addPoint(tailPoint);\n            }\n        }\n    }\n    /**\n     * Assorted regions with arc boundaries\n     * * full circle\n     * * with varying sweep:\n     *    * partial arc with single chord closure\n     *    * partial arc with 2-edge closure via center\n     */\n    static createArcRegions() {\n        const result = [];\n        const center = Point3d.create(0, 0, 0);\n        for (const sweep of [\n            AngleSweep.createStartEndDegrees(0, 360),\n            AngleSweep.createStartEndDegrees(-20, 20),\n            AngleSweep.createStartEndDegrees(0, 90),\n            AngleSweep.createStartEndDegrees(0, 180),\n        ]) {\n            const arc0 = Arc3d.createXY(Point3d.create(0, 0), 2.0, sweep);\n            if (arc0.sweep.isFullCircle) {\n                result.push(Loop.create(arc0));\n            }\n            else {\n                const chord = LineSegment3d.create(arc0.endPoint(), arc0.startPoint());\n                result.push(Loop.create(arc0, chord));\n                result.push(Loop.create(arc0, LineString3d.create(arc0.endPoint(), center, arc0.startPoint())));\n            }\n        }\n        return result;\n    }\n    /**\n     * Assorted loops in xy plane:\n     * * unit square\n     * * rectangle\n     * * L shape\n     */\n    static createSimpleXYPointLoops() {\n        const result = [];\n        result.push(Sample.createRectangleXY(0, 0, 1, 1));\n        result.push(Sample.createRectangleXY(0, 0, 4, 3));\n        result.push(Sample.createLShapedPolygon(0, 0, 5, 4, 1, 2));\n        return result;\n    }\n    /** Assorted `ParityRegion` objects */\n    static createSimpleParityRegions(includeBCurves = false) {\n        const pointC = Point3d.create(-5, 0, 0);\n        const point0 = Point3d.create(0, 0, 0);\n        const point1 = Point3d.create(4, 2, 0);\n        const point2 = Point3d.create(6, 4, 0);\n        const point3 = Point3d.create(5, 5, 0);\n        const point4 = Point3d.create(8, 3, 0);\n        const reverseSweep = AngleSweep.createStartEndDegrees(0, -360);\n        const ax = 10.0;\n        const ay = 8.0;\n        const bx = -3.0;\n        const by = 2.0;\n        const r2 = 0.5;\n        const r2A = 2.5;\n        const pointA = point0.plusXYZ(ax, 0, 0);\n        const pointB = pointA.plusXYZ(0, ay, 0);\n        const pointC1 = point0.plusXYZ(0, ay);\n        const result = [\n            ParityRegion.create(Loop.create(LineString3d.create(point0, pointA, pointB), Arc3d.createCircularStartMiddleEnd(pointB, pointC1, point0)), Loop.create(LineString3d.createRectangleXY(point1, bx, by))),\n            ParityRegion.create(Loop.create(Arc3d.createXY(pointC, 2.0)), Loop.create(Arc3d.createXY(pointC, 1.0, reverseSweep))),\n            ParityRegion.create(Loop.create(LineString3d.createRectangleXY(point0, ax, ay)), Loop.create(LineString3d.createRectangleXY(point1, bx, by))),\n            ParityRegion.create(Loop.create(LineString3d.createRectangleXY(point0, ax, ay)), Loop.create(LineString3d.createRectangleXY(point1, bx, by)), Loop.create(Arc3d.createXY(point2, r2, reverseSweep))),\n            ParityRegion.create(Loop.create(LineString3d.createRectangleXY(point0, ax, ay)), Loop.create(LineString3d.createRectangleXY(point1, bx, by)), Loop.create(Arc3d.createXY(point2, r2, reverseSweep)), Loop.create(LineString3d.createRectangleXY(point3, bx, by))),\n            ParityRegion.create(Loop.create(LineString3d.create(point0, pointA, pointB), Arc3d.createCircularStartMiddleEnd(pointB, pointC1, point0)), Loop.create(LineString3d.createRectangleXY(point1, bx, by)), Loop.create(Arc3d.create(point4, Vector3d.create(-r2, 0), Vector3d.create(0, r2A))), Loop.create(LineString3d.createRectangleXY(point3, bx, by))),\n        ];\n        if (includeBCurves) {\n            const ey = 1.0;\n            result.push(ParityRegion.create(Loop.create(LineSegment3d.create(point0, pointA), BSplineCurve3d.createUniformKnots([\n                pointA,\n                Point3d.create(ax + 1, ey),\n                Point3d.create(ax + 1, 2 * ey),\n                Point3d.create(ax + 2, 3 * ey),\n                Point3d.create(ax + 1, 4 * ey),\n                pointB,\n            ], 3), Arc3d.createCircularStartMiddleEnd(pointB, pointC1, point0))));\n        }\n        return result;\n    }\n    /** Union region. */\n    static createSimpleUnions() {\n        const parityRegions = Sample.createSimpleParityRegions();\n        const parityRange = parityRegions[0].range();\n        const ax = 3.0;\n        const ay = 1.0;\n        const bx = 4.0;\n        const by = 2.0;\n        const result = [\n            UnionRegion.create(Loop.create(LineString3d.createRectangleXY(Point3d.create(0, 0, 0), ax, ay)), Loop.create(LineString3d.createRectangleXY(Point3d.create(0, 2 * ay, 0), bx, by))),\n            UnionRegion.create(Loop.create(LineString3d.create(Sample.createRectangleXY(parityRange.low.x, parityRange.high.y + 0.5, parityRange.xLength(), parityRange.yLength()))), parityRegions[0]),\n        ];\n        return result;\n    }\n    /** Assorted unstructured curve sets. */\n    static createBagOfCurves() {\n        const parityRegions = Sample.createSimpleParityRegions();\n        const loops = Sample.createSimpleLoops();\n        const result = [\n            BagOfCurves.create(loops[0], parityRegions[0], LineSegment3d.createXYXY(0, 1, 4, 2, 1)),\n            // a bag with just an arc\n            BagOfCurves.create(Arc3d.createUnitCircle()),\n            // a bag with just a line segment\n            BagOfCurves.create(LineSegment3d.create(Point3d.create(0, 0, 0), Point3d.create(1, 1, 0))),\n            // a bag with just a linestring\n            BagOfCurves.create(LineString3d.create(Point3d.create(0, 0, 0), Point3d.create(1, 1, 0), Point3d.create(2, 1, 0))),\n        ];\n        return result;\n    }\n    /**\n     * Assorted smooth curve primitives:\n     * * line segments\n     * * arcs\n     */\n    static createSmoothCurvePrimitives(size = 1.0) {\n        const alpha = 0.1;\n        const beta = 0.3;\n        return [\n            LineSegment3d.create(Point3d.create(0, 0, 0), Point3d.create(size, 0, 0)),\n            LineSegment3d.create(Point3d.create(0, 0, 0), Point3d.create(size, size, 0)),\n            Arc3d.create(Point3d.create(0, 0, 0), Vector3d.create(size, 0, 0), Vector3d.create(0, size, 0), AngleSweep.createStartEndDegrees(0, 90)),\n            Arc3d.create(Point3d.create(0, 0, 0), Vector3d.create(size, 0, 0), Vector3d.create(0, size, 0), AngleSweep.createStartEndDegrees(-40, 270)),\n            Arc3d.create(Point3d.create(0, 0, 0), Vector3d.create(size, alpha * size, 0), Vector3d.create(-alpha * beta * size, beta * size, 0), AngleSweep.createStartEndDegrees(-40, 270)),\n        ];\n    }\n    /** Assorted small polyface grids, possibly expanded by gridMultiplier */\n    static createSimpleIndexedPolyfaces(gridMultiplier) {\n        const meshes = [\n            Sample.createTriangularUnitGridPolyface(Point3d.create(), Vector3d.unitX(), Vector3d.unitY(), gridMultiplier * 3, 2 * gridMultiplier, false, false, false),\n            Sample.createTriangularUnitGridPolyface(Point3d.create(), Vector3d.unitX(), Vector3d.unitY(), 3 * gridMultiplier, 2 * gridMultiplier, true, false, false),\n            Sample.createTriangularUnitGridPolyface(Point3d.create(), Vector3d.unitX(), Vector3d.unitY(), 3 * gridMultiplier, 2 * gridMultiplier, false, true, false),\n            Sample.createTriangularUnitGridPolyface(Point3d.create(), Vector3d.unitX(), Vector3d.unitY(), 3 * gridMultiplier, 2 * gridMultiplier, false, false, true),\n            Sample.createTriangularUnitGridPolyface(Point3d.create(), Vector3d.unitX(), Vector3d.unitY(), 3 * gridMultiplier, 2 * gridMultiplier, true, true, true),\n        ];\n        for (const m of meshes)\n            m.expectedClosure = 1;\n        return meshes;\n    }\n    /**\n     * Build a mesh that is a (possibly skewed) grid in a plane.\n     * @param origin \"lower left\" coordinate\n     * @param vectorX step in \"X\" direction\n     * @param vectorY step in \"Y\" direction\n     * @param numXVertices number of vertices in X direction\n     * @param numYVertices number of vertices in y direction\n     * @param createParams true to create parameters, with parameter value `(i,j)` for point at (0 based) vertex in x,y directions\n     * @param createNormals true to create a (single) normal indexed from all facets\n     * @param createColors true to create a single color on each quad.  (shared between its triangles)\n     * @note edgeVisible is false only on the diagonals\n     */\n    static createTriangularUnitGridPolyface(origin, vectorX, vectorY, numXVertices, numYVertices, createParams = false, createNormals = false, createColors = false, triangulate = true) {\n        const mesh = IndexedPolyface.create(createNormals, createParams, createColors);\n        const normal = vectorX.crossProduct(vectorY);\n        if (createNormals) {\n            normal.normalizeInPlace();\n            mesh.addNormalXYZ(normal.x, normal.y, normal.z); // use XYZ to help coverage count!!\n        }\n        // Push to coordinate arrays\n        for (let j = 0; j < numYVertices; j++) {\n            for (let i = 0; i < numXVertices; i++) {\n                mesh.addPoint(origin.plus2Scaled(vectorX, i, vectorY, j));\n                if (createParams)\n                    mesh.addParamUV(i, j);\n            }\n        }\n        let color = 0xFF5CE51A; // arbitrary color so colorIndex is different from color.\n        const colorDiff = 0x12345;\n        // Push elements to index array (vertices are calculated using i and j positioning for each point)\n        let thisColorIndex = 0;\n        for (let j = 0; j + 1 < numYVertices; j++) {\n            for (let i = 0; i + 1 < numXVertices; i++) {\n                const vertex00 = numXVertices * j + i;\n                const vertex10 = vertex00 + 1;\n                const vertex01 = vertex00 + numXVertices;\n                const vertex11 = vertex01 + 1;\n                if (triangulate) {\n                    // Push lower triangle\n                    mesh.addPointIndex(vertex00, true);\n                    mesh.addPointIndex(vertex10, true);\n                    mesh.addPointIndex(vertex11, false);\n                    // make color === faceIndex\n                    if (createColors) {\n                        thisColorIndex = mesh.addColor(color += colorDiff);\n                        mesh.addColorIndex(thisColorIndex);\n                        mesh.addColorIndex(thisColorIndex);\n                        mesh.addColorIndex(thisColorIndex);\n                    }\n                    // param indexing matches points .  .\n                    if (createParams) {\n                        mesh.addParamIndex(vertex00);\n                        mesh.addParamIndex(vertex10);\n                        mesh.addParamIndex(vertex11);\n                    }\n                    if (createNormals) {\n                        mesh.addNormalIndex(0);\n                        mesh.addNormalIndex(0);\n                        mesh.addNormalIndex(0);\n                    }\n                    mesh.terminateFacet(false);\n                    // upper triangle\n                    mesh.addPointIndex(vertex11, true);\n                    mesh.addPointIndex(vertex01, true);\n                    mesh.addPointIndex(vertex00, false);\n                    // make color === faceIndex\n                    if (createColors) {\n                        mesh.addColorIndex(thisColorIndex);\n                        mesh.addColorIndex(thisColorIndex);\n                        mesh.addColorIndex(thisColorIndex);\n                    }\n                    // param indexing matches points.\n                    if (createParams) {\n                        mesh.addParamIndex(vertex11);\n                        mesh.addParamIndex(vertex01);\n                        mesh.addParamIndex(vertex00);\n                    }\n                    if (createNormals) {\n                        mesh.addNormalIndex(0);\n                        mesh.addNormalIndex(0);\n                        mesh.addNormalIndex(0);\n                    }\n                    mesh.terminateFacet(false);\n                }\n                else {\n                    // Push quad\n                    mesh.addPointIndex(vertex00, true);\n                    mesh.addPointIndex(vertex10, true);\n                    mesh.addPointIndex(vertex11, true);\n                    mesh.addPointIndex(vertex01, true);\n                    // make color === faceIndex\n                    if (createColors) {\n                        thisColorIndex = mesh.addColor(color += colorDiff);\n                        mesh.addColorIndex(thisColorIndex);\n                        mesh.addColorIndex(thisColorIndex);\n                        mesh.addColorIndex(thisColorIndex);\n                        mesh.addColorIndex(thisColorIndex);\n                    }\n                    // param indexing matches points .  .\n                    if (createParams) {\n                        mesh.addParamIndex(vertex00);\n                        mesh.addParamIndex(vertex10);\n                        mesh.addParamIndex(vertex11);\n                        mesh.addParamIndex(vertex01);\n                    }\n                    if (createNormals) {\n                        mesh.addNormalIndex(0);\n                        mesh.addNormalIndex(0);\n                        mesh.addNormalIndex(0);\n                        mesh.addNormalIndex(0);\n                    }\n                    mesh.terminateFacet(false);\n                }\n            }\n        }\n        return mesh;\n    }\n    /** Create an xy grid of points in single array with x varying fastest. */\n    static createXYGrid(numU, numV, dX = 1.0, dY = 1.0) {\n        const points = [];\n        for (let j = 0; j < numV; j++) {\n            for (let i = 0; i < numU; i++) {\n                points.push(Point3d.create(i * dX, j * dY, 0));\n            }\n        }\n        return points;\n    }\n    /** Create simple bspline surface on xy plane grid. */\n    static createXYGridBsplineSurface(numU, numV, orderU, orderV) {\n        return BSplineSurface3d.create(Sample.createXYGrid(numU, numV, 1.0, 1.0), numU, orderU, undefined, numV, orderV, undefined);\n    }\n    /**\n     * Create a bspline surface whose poles area on circular paths.\n     * * (BUT not weighted bspline, therefore although u and v isolines \"go around\" they are not true circles.)\n     * @param radiusU major radius\n     * @param radiusV minor radius\n     * @param numU number of facets around major hoop\n     * @param numV number of facets around minor hoop\n     * @param orderU major hoop order\n     * @param orderV minor hoop order\n     */\n    static createPseudoTorusBsplineSurface(radiusU, radiusV, numU, numV, orderU, orderV) {\n        const points = [];\n        const numUPole = numU + orderU - 1;\n        const numVPole = numV + orderV - 1;\n        const uKnots = KnotVector.createUniformWrapped(numU, orderU - 1, 0, 1);\n        const vKnots = KnotVector.createUniformWrapped(numV, orderV - 1, 0, 1);\n        const dURadians = 2.0 * Math.PI / numU;\n        const dVRadians = 2.0 * Math.PI / numV;\n        for (let iV = 0; iV < numVPole; iV++) {\n            const vRadians = iV * dVRadians;\n            const cV = Math.cos(vRadians);\n            const sV = Math.sin(vRadians);\n            for (let iU = 0; iU < numUPole; iU++) {\n                const uRadians = iU * dURadians;\n                const cU = Math.cos(uRadians);\n                const sU = Math.sin(uRadians);\n                const rho = radiusU + cV * radiusV;\n                points.push(Point3d.create(rho * cU, rho * sU, sV * radiusV));\n            }\n        }\n        const result = BSplineSurface3d.create(points, numUPole, orderU, uKnots.knots, numVPole, orderV, vKnots.knots);\n        if (result) {\n            result.setWrappable(0, BSplineWrapMode.OpenByAddingControlPoints);\n            result.setWrappable(1, BSplineWrapMode.OpenByAddingControlPoints);\n        }\n        return result;\n    }\n    /**\n     * Create a Bspline surface for a cone.\n     * @param centerA center at section A\n     * @param centerB center at section B\n     * @param radiusA radius at point A\n     * @param radiusB radius at point B\n     */\n    static createConeBsplineSurface(centerA, centerB, radiusA, radiusB, numSection) {\n        if (numSection < 2)\n            numSection = 2;\n        const controlPoints = [];\n        const numVPole = numSection;\n        const q1 = 0.25;\n        const q2 = 0.5;\n        const q3 = 0.75;\n        const uKnots = [0, 0, q1, q1, q2, q2, q3, q3, 1, 1];\n        const vKnots = [];\n        const dv = 1.0 / (numSection - 1);\n        for (let i = 0; i < numSection; i++) {\n            vKnots.push(i * dv);\n        }\n        const center = Point3d.create();\n        const vectorAB = Vector3d.createStartEnd(centerA, centerB);\n        const axes = Matrix3d.createRigidHeadsUp(vectorAB, AxisOrder.ZXY);\n        let r0, r90, v;\n        for (let iV = 0; iV < numVPole; iV++) {\n            v = iV * dv;\n            centerA.interpolate(v, centerB, center);\n            r0 = r90 = Geometry.interpolate(radiusA, v, radiusB);\n            controlPoints.push(Sample.createBsplineArc90SectionToXYZWArrays(center, axes, r0, r90, false));\n        }\n        const result = BSplineSurface3dH.createGrid(controlPoints, WeightStyle.WeightsSeparateFromCoordinates, 3, uKnots, 2, vKnots);\n        // if (result) {\n        // result.setWrappable(0, BSplineWrapMode.OpenByAddingControlPoints);\n        // result.setWrappable(1, BSplineWrapMode.OpenByAddingControlPoints);\n        // }\n        return result;\n    }\n    /** Create bspline surface on xy grid with weights. */\n    static createWeightedXYGridBsplineSurface(numU, numV, orderU, orderV, weight00 = 1.0, weight10 = 1.0, weight01 = 1.0, weight11 = 1.0) {\n        const xyzPoles = Sample.createXYGrid(numU, numV, 1.0, 1.0);\n        const weights = [];\n        for (let i = 0; i < numU; i++)\n            for (let j = 0; j < numV; j++) {\n                const wu0 = Geometry.interpolate(weight00, i / (numU - 1), weight10);\n                const wu1 = Geometry.interpolate(weight01, i / (numU - 1), weight11);\n                weights.push(Geometry.interpolate(wu0, j / (numV - 1), wu1));\n            }\n        return BSplineSurface3dH.create(xyzPoles, weights, numU, orderU, undefined, numV, orderV, undefined);\n    }\n    /** Assorted linear sweeps */\n    static createSimpleLinearSweeps() {\n        const result = [];\n        const base = Loop.create(LineString3d.createRectangleXY(Point3d.create(), 2, 3));\n        const vectorZ = Vector3d.create(0, 0, 1.234);\n        const vectorQ = Vector3d.create(0.1, 0.21, 1.234);\n        result.push(LinearSweep.create(base, vectorZ, false));\n        result.push(LinearSweep.create(base, vectorZ, true));\n        result.push(LinearSweep.create(base, vectorQ, false));\n        result.push(LinearSweep.create(base, vectorQ, true));\n        result.push(LinearSweep.create(Sample.createCappedArcLoop(5, -45, 90), vectorQ, true));\n        for (const curve of Sample.createSmoothCurvePrimitives()) {\n            const path = Path.create(curve);\n            result.push(LinearSweep.create(path, vectorZ, false));\n        }\n        // coordinates for a clearly unclosed linestring ....\n        const xyPoints = [\n            Point2d.create(0, 0),\n            Point2d.create(1, 0),\n            Point2d.create(1, 1),\n        ];\n        result.push(LinearSweep.createZSweep(xyPoints, 1, 3, false));\n        // this forces artificial closure point . . .\n        result.push(LinearSweep.createZSweep(xyPoints, 1, 3, true));\n        // add a not-quite-exact closure point ...\n        const e = 1.0e-11;\n        xyPoints.push(Point2d.create(e, e));\n        result.push(LinearSweep.createZSweep(xyPoints, 1, 3, false));\n        result.push(LinearSweep.createZSweep(xyPoints, 1, 3, true));\n        // make it a better closure\n        xyPoints.pop();\n        xyPoints.push(xyPoints[0]);\n        result.push(LinearSweep.createZSweep(xyPoints, 1, 3, false));\n        result.push(LinearSweep.createZSweep(xyPoints, 1, 3, true));\n        // negative sweep ...\n        result.push(LinearSweep.createZSweep(xyPoints, 1, -3, true));\n        return result;\n    }\n    /**\n     * Create an array of primitives with an arc centered at origin and a line segment closing back to the arc start.\n     * This can be bundled into Path or Loop by caller.\n     */\n    static createCappedArcPrimitives(radius, startDegrees, endDegrees) {\n        const arc = Arc3d.create(Point3d.create(0, 0, 0), Vector3d.unitX(radius), Vector3d.unitY(radius), AngleSweep.createStartEndDegrees(startDegrees, endDegrees));\n        return [arc, LineSegment3d.create(arc.fractionToPoint(1.0), arc.fractionToPoint(0.0))];\n    }\n    /** Return a Path structure for a segment of arc, with closure segment */\n    static createCappedArcPath(radius, startDegrees, endDegrees) {\n        return Path.createArray(Sample.createCappedArcPrimitives(radius, startDegrees, endDegrees));\n    }\n    /** Return a Loop structure for a segment of arc, with closure segment */\n    static createCappedArcLoop(radius, startDegrees, endDegrees) {\n        return Loop.createArray(Sample.createCappedArcPrimitives(radius, startDegrees, endDegrees));\n    }\n    /** Create assorted rotational sweeps. */\n    static createSimpleRotationalSweeps() {\n        const result = [];\n        // rectangle in xy plane\n        const base = Loop.create(LineString3d.createRectangleXY(Point3d.create(1, 0, 0), 2, 3));\n        // rotate around the y axis\n        for (const axis of [\n            Ray3d.createXYZUVW(0, 0, 0, 0, 1, 0),\n            Ray3d.createXYZUVW(5, 0, 0, 0, 1, 0),\n            Ray3d.createXYZUVW(-1, 0, 0, -1, 1, 0),\n        ]) {\n            result.push(RotationalSweep.create(base, axis, Angle.createDegrees(45.0), false));\n            result.push(RotationalSweep.create(base, axis, Angle.createDegrees(150.0), true));\n        }\n        return result;\n    }\n    /** Create assorted spheres */\n    static createSpheres(includeEllipsoidal = false) {\n        const result = [];\n        result.push(Sphere.createCenterRadius(Point3d.create(0, 0, 0), 1.0));\n        result.push(Sphere.createCenterRadius(Point3d.create(1, 2, 3), 3.0));\n        const s1 = Sphere.createCenterRadius(Point3d.create(1, 2, 3), 2.0, AngleSweep.createStartEndDegrees(-45, 80));\n        s1.capped = true;\n        result.push(s1);\n        // still a sphere, but with axes KIJ . .\n        const s2 = Sphere.createFromAxesAndScales(Point3d.create(1, 2, 3), Matrix3d.createRowValues(0, 1, 0, 0, 0, 1, 1, 0, 0), 4, 4, 4, AngleSweep.createStartEndDegrees(-45, 45), true);\n        result.push(s2);\n        if (includeEllipsoidal)\n            result.push(Sphere.createDgnSphere(Point3d.create(1, 2, 3), Vector3d.unitX(), Vector3d.unitZ(), 3, 2, AngleSweep.createFullLatitude(), false));\n        return result;\n    }\n    /** Create true (non-spherical) ellipsoids. */\n    static createEllipsoids() {\n        return [\n            Sphere.createEllipsoid(Transform.createOriginAndMatrix(Point3d.create(0, 0, 0), Matrix3d.createRowValues(4, 1, 1, 1, 4, 1, 0.5, 0.2, 5)), AngleSweep.createFullLatitude(), true),\n        ];\n    }\n    /** Create assorted cones. */\n    static createCones() {\n        const result = [];\n        const origin = Point3d.create(0, 0, 0);\n        const topZ = Point3d.create(0, 0, 5);\n        const centerA = Point3d.create(1, 2, 1);\n        const centerB = Point3d.create(2, 3, 8);\n        result.push(Cone.createAxisPoints(Point3d.create(0, 0, 0), Point3d.create(0, 0, 1), 0.5, 0.5, false));\n        result.push(Cone.createAxisPoints(centerA, centerB, 0.5, 0.5, false));\n        result.push(Cone.createAxisPoints(origin, topZ, 1.0, 0.2, true));\n        result.push(Cone.createAxisPoints(centerA, centerB, 0.2, 0.5, false));\n        result.push(Cone.createAxisPoints(origin, centerB, 1.0, 0.0, false));\n        result.push(Cone.createAxisPoints(topZ, origin, 0.0, 1.0, true));\n        return result;\n    }\n    /** Return a TorusPipe with swept circle in xz plane rotating through an angle range around the Z axis. */\n    static createPartialTorusAroundZ(majorRadius, majorSweep, minorRadius, minorStart, minorEnd) {\n        const arc = Arc3d.createXYZXYZXYZ(majorRadius, 0, 0, minorRadius, 0, 0, 0, minorRadius, 0, AngleSweep.createStartEnd(minorStart, minorEnd));\n        const contour = Path.create(arc);\n        return RotationalSweep.create(contour, Ray3d.createZAxis(), majorSweep, false);\n    }\n    /** Create assorted Torus Pipes */\n    static createTorusPipes() {\n        const result = [];\n        const center = Point3d.create(1, 2, 3);\n        const frame = Matrix3d.createRotationAroundVector(Vector3d.create(1, 2, 3), Angle.createRadians(10));\n        const vectorX = frame.columnX();\n        const vectorY = frame.columnY();\n        const vectorZ = frame.columnZ();\n        result.push(TorusPipe.createInFrame(Transform.createIdentity(), 5.0, 0.8, Angle.create360(), false));\n        result.push(TorusPipe.createInFrame(Transform.createIdentity(), 5.0, 1.0, Angle.createDegrees(90), true));\n        result.push(TorusPipe.createDgnTorusPipe(center, vectorX, vectorY, 10, 1, Angle.createDegrees(180), true));\n        result.push(TorusPipe.createDgnTorusPipe(center, vectorY, vectorZ, 10, 1, Angle.createDegrees(45), true));\n        return result;\n    }\n    /** Create assorted boxes. */\n    static createBoxes(capped = true) {\n        const result = [];\n        const cornerA = Point3d.create(1, 2, 3);\n        const aX = 3.0;\n        const aY = 2.0;\n        const bX = 1.5;\n        const bY = 1.0;\n        const h = 5.0;\n        const frame = Matrix3d.createRotationAroundVector(Vector3d.create(0, 0, 1), Angle.createDegrees(10));\n        const vectorX = frame.columnX();\n        const vectorY = frame.columnY();\n        const cornerB = Matrix3d.xyzPlusMatrixTimesCoordinates(cornerA, frame, 0, 0, h);\n        result.push(Box.createDgnBox(cornerA, Vector3d.unitX(), Vector3d.unitY(), cornerB, aX, aY, aX, aY, capped));\n        result.push(Box.createDgnBox(cornerA, Vector3d.unitX(), Vector3d.unitY(), cornerB, aX, aY, bX, bY, capped));\n        result.push(Box.createDgnBox(cornerA, vectorX, vectorY, cornerB, aX, aY, bX, bY, capped));\n        const frameY = Matrix3d.createRotationAroundVector(Vector3d.create(0, 1, 0), Angle.createDegrees(10));\n        result.push(Box.createDgnBox(cornerA, frameY.columnX(), frameY.columnY(), cornerA.plusScaled(frameY.columnZ(), h), aX, aY, bX, bY, capped));\n        return result;\n    }\n    /** Create an array of points for a rectangle with corners (x0,y0,z) and (x1,y1,z) */\n    static createRectangle(x0, y0, x1, y1, z = 0.0, closed = false) {\n        const points = [\n            Point3d.create(x0, y0, z),\n            Point3d.create(x1, y0, z),\n            Point3d.create(x1, y1, z),\n            Point3d.create(x0, y1, z),\n        ];\n        if (closed)\n            points.push(Point3d.create(x0, y0, z));\n        return points;\n    }\n    /** Create an array of points for a rectangle with corners of a Range2d. */\n    static createRectangleInRange2d(range, z = 0.0, closed = false) {\n        const x0 = range.low.x;\n        const x1 = range.high.x;\n        const y0 = range.low.y;\n        const y1 = range.high.y;\n        return this.createRectangle(x0, y0, x1, y1, z, closed);\n    }\n    /** Create assorted ruled sweeps */\n    static createRuledSweeps(includeParityRegion = false, includeBagOfCurves = false) {\n        const allSweeps = [];\n        const contour0 = Loop.create(LineString3d.create(this.createRectangleXY(0, 0, 3, 2, 0)));\n        const contour1 = Loop.create(LineString3d.create(this.createRectangleXY(0, 0, 3, 2.5, 2)));\n        const contour2 = Loop.create(LineString3d.create(this.createRectangleXY(0, 0, 4, 3.5, 4)));\n        const contour3 = Loop.create(LineString3d.create(this.createRectangleXY(0, 0, 2, 1, 7)));\n        const allContours = [contour0, contour1, contour2];\n        allSweeps.push(RuledSweep.create([contour0, contour1], true));\n        allSweeps.push(RuledSweep.create([contour0, contour1, contour2], true));\n        allSweeps.push(RuledSweep.create([contour0, contour1, contour2, contour3], true));\n        allSweeps.push(RuledSweep.create(allContours, false));\n        const curves = Sample.createSmoothCurvePrimitives();\n        for (const c of curves) {\n            const frame = c.fractionToFrenetFrame(0.0);\n            if (frame) {\n                const perpVector = frame.matrix.columnZ();\n                perpVector.scaleInPlace(10.0);\n                const c1 = c.cloneTransformed(Transform.createTranslation(perpVector));\n                allSweeps.push(RuledSweep.create([Path.create(c), Path.create(c1)], false));\n            }\n        }\n        if (includeParityRegion) {\n            const outer = Loop.create(LineString3d.create(this.createRectangleXY(0, 0, 5, 6, 0)));\n            const inner = Loop.create(LineString3d.create(this.createRectangleXY(1, 1, 2, 3, 0)));\n            const contourA = ParityRegion.create(outer, inner);\n            const contourB = contourA.clone();\n            contourB.tryTranslateInPlace(0, 0, 2);\n            allSweeps.push(RuledSweep.create([contourA, contourB], false));\n        }\n        if (includeBagOfCurves) {\n            const contourA = BagOfCurves.create(LineSegment3d.createXYZXYZ(1, 1, 0, 3, 1, 0));\n            const contourB = BagOfCurves.create(LineSegment3d.createXYZXYZ(1, 1, 1, 3, 1, 1));\n            allSweeps.push(RuledSweep.create([contourA, contourB], false));\n        }\n        return allSweeps;\n    }\n    /**\n     * Uniformly spaced numbers\n     * @param a0 first entry\n     * @param delta step between entries\n     * @param n number of entries\n     */\n    static createGrowableArrayCountedSteps(a0, delta, n) {\n        const data = new GrowableFloat64Array(n);\n        for (let i = 0; i < n; i++)\n            data.push(a0 + i * delta);\n        return data;\n    }\n    /**\n     * Create points on a unit circle\n     * @param radius first entry\n     * @param numEdge number of edges of chorded circle.  Angle step is 2PI/numEdge (whether or not closed)\n     * @param closed true to include final point (i.e. return numEdge+1 points)\n     */\n    static createGrowableArrayCirclePoints(radius, numEdge, closed = false, centerX = 0, centerY = 0, data) {\n        if (!data)\n            data = new GrowableXYZArray();\n        data.ensureCapacity(numEdge + (closed ? 1 : 0));\n        const delta = 2.0 * Math.PI / numEdge;\n        for (let i = 0; i < numEdge; i++) {\n            const radians = i * delta;\n            data.push(Point3d.create(centerX + radius * Math.cos(radians), centerY + radius * Math.sin(radians)));\n        }\n        return data;\n    }\n    static pushIfDistinct(points, xyz, tol = 1.0e-12) {\n        if (points.length === 0 || points[points.length - 1].distanceXY(xyz) > tol)\n            points.push(xyz);\n    }\n    static appendToFractalEval(points, pointA, pointB, pattern, numRecursion, perpendicularFactor) {\n        const point0 = pointA.clone();\n        Sample.pushIfDistinct(points, pointA);\n        for (const uv of pattern) {\n            const point1 = pointA.interpolatePerpendicularXY(uv.x, pointB, perpendicularFactor * uv.y);\n            if (numRecursion > 0)\n                Sample.appendToFractalEval(points, point0, point1, pattern, numRecursion - 1, perpendicularFactor);\n            Sample.pushIfDistinct(points, point1);\n            point0.setFrom(point1);\n        }\n        Sample.pushIfDistinct(points, pointB);\n    }\n    /**\n     * For each edge of points, construct a transform (with scale, rotate, and translate) that spreads the patter out along the edge.\n     * Repeat recursively for each edge\n     * @returns Returns an array of recursively generated fractal points\n     * @param poles level-0 (coarse) polygon whose edges are to be replaced by recursive fractals\n     * @param pattern pattern to map to each edge of poles (and to edges of the recursion)\n     * @param numRecursion  number of recursions\n     * @param perpendicularFactor factor to apply to perpendicular sizing.\n     */\n    static createRecursiveFractalPolygon(poles, pattern, numRecursion, perpendicularFactor) {\n        const points = [];\n        Sample.pushIfDistinct(points, poles[0]);\n        for (let i = 0; i + 1 < poles.length; i++) {\n            if (numRecursion > 0)\n                Sample.appendToFractalEval(points, poles[i], poles[i + 1], pattern, numRecursion - 1, perpendicularFactor);\n            Sample.pushIfDistinct(points, poles[i + 1]);\n        }\n        return points;\n    }\n    /**\n     * Primary shape is a \"triangle\" with lower edge pushed in so it becomes a mild nonconvex quad.\n     * Fractal effects are gentle.\n     */\n    static nonConvexQuadSimpleFractal(numRecursion, perpendicularFactor) {\n        const pattern = [\n            Point2d.create(),\n            Point2d.create(0.5, 0.1),\n            Point2d.create(1.0, 0.0),\n        ];\n        const poles = [\n            Point3d.create(0, 0, 0),\n            Point3d.create(0.6, 0.1, 0),\n            Point3d.create(1, 0.1, 0),\n            Point3d.create(0.6, 1, 0),\n            Point3d.create(),\n        ];\n        return Sample.createRecursiveFractalPolygon(poles, pattern, numRecursion, perpendicularFactor);\n    }\n    /** Create a diamond with convex fractal */\n    static createFractalDiamondConvexPattern(numRecursion, perpendicularFactor) {\n        const pattern = [\n            Point2d.create(),\n            Point2d.create(0.3, 0.05),\n            Point2d.create(0.5, 0.10),\n            Point2d.create(0.7, 0.04),\n            Point2d.create(1.0, 0.0),\n        ];\n        const poles = [\n            Point3d.create(0, -1, 0),\n            Point3d.create(1, 0, 0),\n            Point3d.create(0, 1, 0),\n            Point3d.create(-1, 0, 0),\n            Point3d.create(0, -1, 0),\n        ];\n        return Sample.createRecursiveFractalPolygon(poles, pattern, numRecursion, perpendicularFactor);\n    }\n    /** Create l on a square, with pattern shift to both directions. */\n    static createFractalSquareReversingPattern(numRecursion, perpendicularFactor) {\n        const pattern = [\n            Point2d.create(),\n            Point2d.create(0.25, 0),\n            Point2d.create(0.5, 0.2),\n            Point2d.create(0.75, -0.1),\n            Point2d.create(1.0, 0.0),\n        ];\n        const poles = [\n            Point3d.create(),\n            Point3d.create(1, 0, 0),\n            Point3d.create(1, 1, 0),\n            Point3d.create(0, 1, 0),\n            Point3d.create(0, 0, 0),\n        ];\n        return Sample.createRecursiveFractalPolygon(poles, pattern, numRecursion, perpendicularFactor);\n    }\n    /** Create a fractal on a non-convex base and reversing pattern */\n    static createFractalHatReversingPattern(numRecursion, perpendicularFactor) {\n        const pattern = [\n            Point2d.create(),\n            Point2d.create(0.25, 0),\n            Point2d.create(0.25, 0.1),\n            Point2d.create(0.50, 0.1),\n            Point2d.create(0.50, -0.1),\n            Point2d.create(0.75, -0.1),\n            Point2d.create(0.75, 0),\n            Point2d.create(1.0, 0.0),\n        ];\n        const poles = [\n            Point3d.create(),\n            Point3d.create(1, 0, 0),\n            Point3d.create(1, 1, 0),\n            Point3d.create(0, 1, 0),\n            Point3d.create(0, 0, 0),\n        ];\n        return Sample.createRecursiveFractalPolygon(poles, pattern, numRecursion, perpendicularFactor);\n    }\n    /** Create a fractal on a primary L shape with a reversing pattern */\n    static createFractalLReversingPattern(numRecursion, perpendicularFactor) {\n        const pattern = [\n            Point2d.create(),\n            Point2d.create(0.25, 0),\n            Point2d.create(0.5, 0.2),\n            Point2d.create(0.75, -0.1),\n            Point2d.create(1.0, 0.0),\n        ];\n        const poles = [\n            Point3d.create(),\n            Point3d.create(1, 0, 0),\n            Point3d.create(1, 1, 0),\n            Point3d.create(2, 2, 0),\n            Point3d.create(2, 3, 0),\n            Point3d.create(0, 3, 0),\n            Point3d.create(),\n        ];\n        return Sample.createRecursiveFractalPolygon(poles, pattern, numRecursion, perpendicularFactor);\n    }\n    /** Fractal with fewer concavity changes.... */\n    static createFractalLMildConcavePatter(numRecursion, perpendicularFactor) {\n        const pattern = [\n            Point2d.create(),\n            Point2d.create(0.25, 0.05),\n            Point2d.create(0.5, 0.15),\n            Point2d.create(0.75, 0.05),\n            Point2d.create(1.0, 0.0),\n        ];\n        const poles = [\n            Point3d.create(),\n            Point3d.create(1, 0, 0),\n            Point3d.create(1, 1, 0),\n            Point3d.create(2, 2, 0),\n            Point3d.create(1.5, 3, 0),\n            Point3d.create(0, 3, 0),\n            Point3d.create(),\n        ];\n        return Sample.createRecursiveFractalPolygon(poles, pattern, numRecursion, perpendicularFactor);\n    }\n    /** Append interpolated points from the array tail to the target. */\n    static appendSplits(points, target, numSplit, includeTarget) {\n        const pointA = points[points.length - 1];\n        for (let i = 0; i < numSplit; i++)\n            points.push(pointA.interpolate(i / numSplit, target));\n        if (includeTarget)\n            points.push(target);\n    }\n    /**\n     * Triangle with 3 given vertices, and indicated extra points on each each.\n     * @param numSplitAB number of extra points on edge AB\n     * @param numSplitBC number of extra points on edge BC\n     * @param numSplitCA number of extra points on edge CA\n     * @param wrap true to replicate vertexA at end\n     * @param xyzA vertexA\n     * @param xyzB vertexB\n     * @param xyzC vertexC\n     */\n    static createTriangleWithSplitEdges(numSplitAB, numSplitBC, numSplitCA, wrap = true, xyzA = Point3d.create(0, 0, 0), xyzB = Point3d.create(1, 0, 0), xyzC = Point3d.create(0, 1, 0)) {\n        const result = [xyzA.clone()];\n        Sample.appendSplits(result, xyzB, numSplitAB, true);\n        Sample.appendSplits(result, xyzC, numSplitBC, true);\n        Sample.appendSplits(result, xyzA, numSplitCA, wrap);\n        return result;\n    }\n    /** Create a box (xyz) from half-lengths and center. */\n    static createCenteredBoxEdges(ax = 1, ay = 1, az = 0, cx = 0, cy = 0, cz = 0, geometry) {\n        if (!geometry)\n            geometry = [];\n        const x0 = cx - ax;\n        const y0 = cy - ay;\n        const z0 = cz - az;\n        const x1 = cx + ax;\n        const y1 = cy + ay;\n        const z1 = cz + az;\n        for (const z of [z0, z1]) {\n            geometry.push(LineString3d.create(Point3d.create(x0, y0, z), Point3d.create(x1, y0, z), Point3d.create(x1, y1, z), Point3d.create(x0, y1, z), Point3d.create(x0, y0, z)));\n        }\n        geometry.push(LineSegment3d.createXYZXYZ(x0, y0, z0, x0, y0, z1));\n        geometry.push(LineSegment3d.createXYZXYZ(x1, y0, z0, x1, y0, z1));\n        geometry.push(LineSegment3d.createXYZXYZ(x1, y1, z0, x1, y1, z1));\n        geometry.push(LineSegment3d.createXYZXYZ(x0, y1, z0, x0, y1, z1));\n        return geometry;\n    }\n    /**\n     * Assorted transition spirals\n     * * (All combinations of bearing radius bearing radius length subsets.)\n     */\n    static createSimpleTransitionSpirals() {\n        // 5 spirals exercise the intricate \"4 out of 5\" input rules for spirals . ..\n        const r1 = 1000.0;\n        const r0 = 0.0;\n        const averageCurvature = IntegratedSpiral3d.averageCurvatureR0R1(r0, r1);\n        const arcLength = 100.0;\n        const dThetaRadians = arcLength * averageCurvature;\n        return [\n            IntegratedSpiral3d.createFrom4OutOf5(\"clothoid\", r0, r1, Angle.createDegrees(0), Angle.createRadians(dThetaRadians), undefined, undefined, Transform.createIdentity()),\n            IntegratedSpiral3d.createFrom4OutOf5(\"bloss\", r0, r1, Angle.createDegrees(0), undefined, arcLength, undefined, Transform.createIdentity()),\n            IntegratedSpiral3d.createFrom4OutOf5(\"clothoid\", r0, r1, undefined, Angle.createRadians(dThetaRadians), arcLength, undefined, Transform.createIdentity()),\n            IntegratedSpiral3d.createFrom4OutOf5(\"biquadratic\", r0, undefined, Angle.createDegrees(0), Angle.createRadians(dThetaRadians), arcLength, undefined, Transform.createIdentity()),\n            IntegratedSpiral3d.createFrom4OutOf5(\"sine\", undefined, r1, Angle.createDegrees(0), Angle.createRadians(dThetaRadians), arcLength, undefined, Transform.createIdentity()),\n            IntegratedSpiral3d.createFrom4OutOf5(\"cosine\", r0, r1, Angle.createDegrees(0), Angle.createRadians(dThetaRadians), undefined, Segment1d.create(0, 0.5), Transform.createOriginAndMatrix(Point3d.create(1, 2, 0), Matrix3d.createRotationAroundVector(Vector3d.unitZ(), Angle.createDegrees(15)))),\n            DirectSpiral3d.createFromLengthAndRadius(\"Arema\", r0, r1, Angle.createDegrees(0), undefined, arcLength, undefined, Transform.createOriginAndMatrix(Point3d.create(1, 2, 0), Matrix3d.createRotationAroundVector(Vector3d.unitZ(), Angle.createDegrees(15)))),\n            DirectSpiral3d.createFromLengthAndRadius(\"ChineseCubic\", r0, r1, Angle.createDegrees(0), undefined, arcLength, undefined, Transform.createOriginAndMatrix(Point3d.create(1, 2, 0), Matrix3d.createRotationAroundVector(Vector3d.unitZ(), Angle.createDegrees(15)))),\n            DirectSpiral3d.createFromLengthAndRadius(\"JapaneseCubic\", r0, r1, Angle.createDegrees(0), undefined, arcLength, undefined, Transform.createOriginAndMatrix(Point3d.create(1, 2, 0), Matrix3d.createRotationAroundVector(Vector3d.unitZ(), Angle.createDegrees(15)))),\n            DirectSpiral3d.createFromLengthAndRadius(\"DirectHalfCosine\", r0, r1, Angle.createDegrees(0), undefined, arcLength, undefined, Transform.createOriginAndMatrix(Point3d.create(1, 2, 0), Matrix3d.createRotationAroundVector(Vector3d.unitZ(), Angle.createDegrees(15)))),\n            DirectSpiral3d.createCzechCubic(Transform.createIdentity(), arcLength, r1),\n        ];\n    }\n    /**\n     * Create a Bezier curve with significant twist effects\n     * * r and theta are circle in xy plane at steps in thetaStepper\n     * * z varies with sin(phi) at steps in phiStepper.\n     */\n    static createTwistingBezier(order, x0, y0, r, thetaStepper, phiStepper, weightInterval) {\n        if (weightInterval !== undefined) {\n            const points = [];\n            for (let i = 0; i < order; i++) {\n                const theta = thetaStepper.fractionToRadians(i);\n                const phi = phiStepper.fractionToRadians(i);\n                const weight = weightInterval.fractionToPoint(i / (order - 1));\n                points.push(Point4d.create(weight * (x0 + r * Math.cos(theta)), weight * (y0 + r * Math.sin(theta)), weight * Math.sin(phi), weight));\n            }\n            return BezierCurve3dH.create(points);\n        }\n        else {\n            const points = [];\n            for (let i = 0; i < order; i++) {\n                const theta = thetaStepper.fractionToRadians(i);\n                const phi = phiStepper.fractionToRadians(i);\n                points.push(Point3d.create(x0 + r * Math.cos(theta), y0 + r * Math.sin(theta), Math.sin(phi)));\n            }\n            return BezierCurve3d.create(points);\n        }\n    }\n    /**\n     * Create various curve chains with distance indexing.\n     * * LineSegment\n     * * CircularArc\n     * * LineString\n     * * order 3 bspline\n     * * order 4 bspline\n     * * alternating lines and arcs\n     * * arc spline with corners\n     * * arc spline with smooth joins\n     * * interpolation curve 2 pts\n     * * interpolation curve 3 pts\n     * * interpolation curve >3 pts\n     * * integrated spiral (bloss)\n     * * direct spiral (half-cosine)\n     */\n    static createCurveChainWithDistanceIndex() {\n        const pointsA = [Point3d.create(0, 0, 0), Point3d.create(1, 3, 0), Point3d.create(2, 4, 0), Point3d.create(3, 3, 0), Point3d.create(4, 0, 0)];\n        const result = [];\n        // one singleton per basic curve type ...\n        result.push(CurveChainWithDistanceIndex.createCapture(Path.create(LineSegment3d.create(Point3d.create(0, 0, 0), Point3d.create(5, 0, 0)))));\n        result.push(CurveChainWithDistanceIndex.createCapture(Path.create(Arc3d.createCircularStartMiddleEnd(Point3d.create(0, 0, 0), Point3d.create(3, 3, 0), Point3d.create(6, 0, 0)))));\n        result.push(CurveChainWithDistanceIndex.createCapture(Path.create(LineString3d.create(pointsA))));\n        result.push(CurveChainWithDistanceIndex.createCapture(Path.create(BSplineCurve3d.createUniformKnots(pointsA, 3))));\n        result.push(CurveChainWithDistanceIndex.createCapture(Path.create(BSplineCurve3d.createUniformKnots(pointsA, 4))));\n        result.push(CurveChainWithDistanceIndex.createCapture(Path.create(LineSegment3d.create(pointsA[0], pointsA[1]), Arc3d.createCircularStartMiddleEnd(pointsA[1], pointsA[2], pointsA[3]), LineSegment3d.create(pointsA[3], pointsA[4]))));\n        result.push(CurveChainWithDistanceIndex.createCapture(Path.create(// arc spline with corners\n        Arc3d.createXY(Point3d.create(5, 0), 5, AngleSweep.createStartEndDegrees(180, 0)), Arc3d.createXY(Point3d.create(15, 0), 5, AngleSweep.createStartEndDegrees(180, 0)), Arc3d.createXY(Point3d.create(25, 0), 5, AngleSweep.createStartEndDegrees(180, 0)))));\n        result.push(CurveChainWithDistanceIndex.createCapture(Path.create(// arc spline with smooth joins\n        Arc3d.createXY(Point3d.create(5, 0), 5, AngleSweep.createStartEndDegrees(180, 0)), Arc3d.createXY(Point3d.create(15, 0), 5, AngleSweep.createStartEndDegrees(180, 360)), Arc3d.createXY(Point3d.create(25, 0), 5, AngleSweep.createStartEndDegrees(180, 0)))));\n        result.push(CurveChainWithDistanceIndex.createCapture(Path.create(// 2-pt Interpolation Curve\n        InterpolationCurve3d.createCapture(InterpolationCurve3dOptions.create({ fitPoints: [pointsA[0], pointsA[1]] })))));\n        result.push(CurveChainWithDistanceIndex.createCapture(Path.create(// 3-pt Interpolation Curve\n        InterpolationCurve3d.createCapture(InterpolationCurve3dOptions.create({ fitPoints: [pointsA[0], pointsA[1], pointsA[2]] })))));\n        result.push(CurveChainWithDistanceIndex.createCapture(Path.create(InterpolationCurve3d.createCapture(InterpolationCurve3dOptions.create({ fitPoints: pointsA, startTangent: Point3d.create(1, -1), endTangent: Point3d.create(-1, -1) })))));\n        result.push(CurveChainWithDistanceIndex.createCapture(Path.create(IntegratedSpiral3d.createRadiusRadiusBearingBearing(Segment1d.create(0, 100), AngleSweep.createStartEndDegrees(10, 75), Segment1d.create(0, 1), Transform.createOriginAndMatrix(Point3d.createZero(), Matrix3d.createRotationAroundAxisIndex(2, Angle.createDegrees(30))), \"bloss\"))));\n        result.push(CurveChainWithDistanceIndex.createCapture(Path.create(DirectSpiral3d.createDirectHalfCosine(Transform.createOriginAndMatrix(Point3d.createZero(), Matrix3d.createRotationAroundAxisIndex(2, Angle.createDegrees(110))), 50, 350, Segment1d.create(0, 1)))));\n        return result;\n    }\n    /**\n     * Create a square wave path.\n     * @param numTooth number of teeth.\n     * @param dxA x size of \"A\" part\n     * @param dxB x size of \"B\" part\n     * @param yA y for A part\n     * @param yB y for B part\n     * @param structure 1 for line segments, 2 for one linestring per tooth, 0 for single linestring\n     */\n    static createSquareWavePath(numTooth, dxA, dxB, yA, yB, structure) {\n        const dxAB = dxA + dxB;\n        const path = Path.create();\n        // build the whole linestring ...\n        const allPoints = new GrowableXYZArray(4 * numTooth);\n        let x2 = 0.0;\n        for (let i = 0; i < numTooth; i++) {\n            const x0 = i * dxAB;\n            const x1 = x0 + dxA;\n            x2 = (i + 1) * dxAB;\n            allPoints.pushXYZ(x0, yA, 0);\n            allPoints.pushXYZ(x1, yA, 0.0);\n            allPoints.pushXYZ(x1, yB, 0.0);\n            allPoints.pushXYZ(x2, yB, 0.0);\n        }\n        allPoints.pushXYZ(x2, yA, 0.0);\n        const numPoints = allPoints.length;\n        if (structure === 1) {\n            const pointA = Point3d.create();\n            const pointB = Point3d.create();\n            allPoints.getPoint3dAtUncheckedPointIndex(0, pointA);\n            for (let i1 = 0; i1 + 1 < numPoints; i1++) {\n                allPoints.getPoint3dAtUncheckedPointIndex(i1, pointB);\n                path.tryAddChild(LineSegment3d.create(pointA, pointB));\n                pointA.setFromPoint3d(pointB);\n            }\n        }\n        else if (structure === 2) {\n            for (let i0 = 0; i0 + 4 < numPoints; i0 += 4) {\n                const ls = LineString3d.create();\n                ls.addSteppedPoints(allPoints, i0, 1, 5);\n                path.tryAddChild(ls);\n            }\n        }\n        else {\n            const ls = LineString3d.create();\n            ls.addSteppedPoints(allPoints, 0, 1, numPoints);\n            path.tryAddChild(ls);\n        }\n        return path;\n    }\n    /**\n     * Create various elliptic arcs\n     * * circle with vector0, vector90 aligned with x,y\n     * * circle with axes rotated\n     * *\n     * @param radiusRatio = vector90.magnitude / vector0.magnitude\n     */\n    static createArcs(radiusRatio = 1.0, sweep = AngleSweep.create360()) {\n        const arcs = [];\n        const center0 = Point3d.create(0, 0, 0);\n        const a = 1.0;\n        const b = radiusRatio;\n        const direction0 = Vector3d.createPolar(a, Angle.createDegrees(35.0));\n        const direction90 = direction0.rotate90CCWXY();\n        direction90.scaleInPlace(radiusRatio);\n        arcs.push(Arc3d.create(center0, Vector3d.create(a, 0, 0), Vector3d.create(0, b, 0), sweep));\n        arcs.push(Arc3d.create(center0, direction0, direction90, sweep));\n        return arcs;\n    }\n    /**\n     * Create many arcs, optionally including skews\n     * * @param skewFactor array of skew factors.  for each skew factor, all base arcs are replicated with vector90 shifted by the factor times vector0\n     */\n    static createManyArcs(skewFactors = []) {\n        const result = [];\n        const sweep1 = AngleSweep.createStartEndDegrees(-10, 75);\n        const sweep2 = AngleSweep.createStartEndDegrees(160.0, 380.0);\n        for (const arcs of [\n            Sample.createArcs(1.0), Sample.createArcs(0.5),\n            Sample.createArcs(1.0, sweep1), Sample.createArcs(0.3, sweep2),\n        ]) {\n            for (const arc of arcs)\n                result.push(arc);\n        }\n        const numBase = result.length;\n        for (const skewFactor of skewFactors) {\n            for (let i = 0; i < numBase; i++) {\n                const originalArc = result[i];\n                result.push(Arc3d.create(originalArc.center, originalArc.vector0, originalArc.vector90.plusScaled(originalArc.vector0, skewFactor), originalArc.sweep));\n            }\n        }\n        return result;\n    }\n    /**\n     * Create edges of a range box.\n     * * Line strings on low and high z\n     * * single lines on each low z to high z edge.\n     * * @param range (possibly null) range\n     */\n    static createRangeEdges(range) {\n        if (range.isNull)\n            return undefined;\n        const corners = range.corners();\n        return BagOfCurves.create(LineString3d.create(corners[0], corners[1], corners[3], corners[2], corners[0]), LineString3d.create(corners[4], corners[5], corners[7], corners[6], corners[4]), LineSegment3d.create(corners[0], corners[4]), LineSegment3d.create(corners[1], corners[5]), LineSegment3d.create(corners[2], corners[6]), LineSegment3d.create(corners[3], corners[7]));\n    }\n    /** Create swept \"solids\" that can be capped.\n     * * At least one of each solid type.\n     * * each is within 10 of the origin all directions.\n     * @param capped true to include caps\n     * @param rotationAngle angle of rotation for the angular sweep. The default is 90 degrees.\n     *      Beware that the rotation sweep created with the default or any positive angle produces a mesh with inward normals.\n     */\n    static createClosedSolidSampler(capped, rotationAngle = Angle.createDegrees(90)) {\n        const result = [];\n        result.push(Box.createRange(Range3d.createXYZXYZ(0, 0, 0, 3, 2, 5), capped));\n        result.push(Cone.createAxisPoints(Point3d.create(0, 0, 0), Point3d.create(0, 0, 5), 1.0, 1.0, capped));\n        result.push(Sphere.createCenterRadius(Point3d.create(0, 0, 0), 1.0));\n        result.push(TorusPipe.createInFrame(Transform.createIdentity(), 3.0, 1.0, Angle.create360(), capped));\n        const arcA = Arc3d.createXY(Point3d.create(6, 1, 0), 1.0, AngleSweep.createStartEndDegrees(-90, 0));\n        const point0 = arcA.fractionAndDistanceToPointOnTangent(0.0, -4);\n        const pointQ1 = arcA.fractionAndDistanceToPointOnTangent(1.0, 2);\n        const pointQ2 = arcA.fractionAndDistanceToPointOnTangent(1.0, 0.5);\n        const pointR1 = Point3d.create(point0.x, pointQ1.y);\n        const pointR2 = Point3d.create(point0.x, pointQ1.y);\n        const pointR3 = Point3d.create(pointQ1.x - 1, pointQ1.y);\n        const pointR4 = Point3d.create(pointQ1.x - 3, pointQ1.y);\n        const linestringQ1 = LineString3d.create(arcA.fractionToPoint(1.0), pointQ1, pointR1, point0);\n        const linestringQ2 = LineString3d.create(arcA.fractionToPoint(1.0), pointQ2, pointR2, point0);\n        const linestringQ3 = LineString3d.create(arcA.fractionToPoint(1.0), pointQ2, pointR3, pointR4, point0);\n        const contourZ = Path.create(linestringQ1.clone());\n        const contourA = Loop.create(LineSegment3d.create(point0, arcA.fractionToPoint(0)), arcA.clone(), linestringQ1.clone());\n        const contourB = Loop.create(LineSegment3d.create(point0, arcA.fractionToPoint(0)), arcA.clone(), linestringQ2.clone());\n        const contourC1 = Loop.create(LineSegment3d.create(point0, arcA.fractionToPoint(0)), arcA.clone(), linestringQ3.clone());\n        contourB.tryTransformInPlace(Transform.createTranslationXYZ(1, 1, 3));\n        // const contourC = contourB.cloneTransformed(Transform.createTranslationXYZ(2, 1, 4))!;\n        result.push(LinearSweep.create(contourA, Vector3d.create(0, 0, 5), capped));\n        result.push(LinearSweep.create(contourC1, Vector3d.create(0, 0, 5), capped));\n        const axis = Ray3d.createXYZUVW(0, 8, 0, 1, 0, 0);\n        result.push(RotationalSweep.create(contourA.clone(), axis.clone(), rotationAngle, capped));\n        if (!capped)\n            result.push(RotationalSweep.create(contourZ.clone(), axis.clone(), rotationAngle, false));\n        result.push(RuledSweep.create([contourA.clone(), contourB.clone()], capped));\n        const transformC = Transform.createScaleAboutPoint(Point3d.create(0, 0, 8), 0.5);\n        const contourC = contourB.cloneTransformed(transformC);\n        result.push(RuledSweep.create([contourA.clone(), contourB.clone(), contourC.clone()], capped));\n        return result;\n    }\n    /**\n     * Create points:\n     * *  `numRadialEdges` radially from origin to polar point (r,sweep.start)\n     * * `numArcEdges` along arc from (r,sweep.start) to (r,sweep.end)\n     * * `numRadialEdges` returning to origin.\n     * * optionally include closure point at origin.\n     * @param x0 center x\n     * @param y0 center y\n     * @param radius radius of circle.\n     * @param sweep start and end angles of sweep.\n     * @param numRadialEdges number of edges from center to arc\n     * @param numArcEdges number of edges along arc\n     * @param addClosure true to repeat center as closure point\n     */\n    static createCutPie(x0, y0, radius, sweep, numRadialEdges, numArcEdges, addClosure = false) {\n        const points = [];\n        const center = Point3d.create(x0, y0);\n        points.push(center);\n        const pointA = Point3d.create(x0 + radius * Math.cos(sweep.startRadians), y0 + radius * Math.sin(sweep.startRadians));\n        const pointB = Point3d.create(x0 + radius * Math.cos(sweep.endRadians), y0 + radius * Math.sin(sweep.endRadians));\n        for (let i = 1; i < numRadialEdges; i++)\n            points.push(center.interpolate(i / numRadialEdges, pointA));\n        points.push(pointA);\n        for (let i = 1; i < numArcEdges; i++) {\n            const radians = sweep.fractionToRadians(i / numArcEdges);\n            points.push(Point3d.create(x0 + radius * Math.cos(radians), y0 + radius * Math.sin(radians)));\n        }\n        points.push(pointB);\n        for (let i = 1; i < numRadialEdges; i++)\n            points.push(pointB.interpolate(i / numRadialEdges, center));\n        if (addClosure)\n            points.push(center.clone());\n        return points;\n    }\n    /**\n     * * Let ay = 4\n     * * Base polygon has vertices (0,0), (ax,0), (2*ax,0), (2* ax,ay), (ax,ay), (0,ay), (0,0).\n     * * Shift the x coordinates of vertices 1,4 by indicated amounts (0-based numbering)\n     * * Shift the y coordinates for points 1,2,3,4 by indicated amounts (in 0-based numbering)\n     * * This is useful for testing non-y-monotonic face situations.\n     * * Return as points.\n     * @param dy1\n     * @param dy2\n     * @param dy3\n     * @param dy4\n     */\n    static createVerticalStaggerPolygon(dy1, dy2, dy3, dy4, ax, ay, dx1, dx4) {\n        const points = [];\n        points.push(Point3d.create(0, 0));\n        points.push(Point3d.create(ax + dx1, dy1));\n        points.push(Point3d.create(2 * ax, dy2));\n        points.push(Point3d.create(2 * ax, ay + dy3));\n        points.push(Point3d.create(ax + dx4, ay + dy4));\n        points.push(Point3d.create(0.0, ay));\n        points.push(Point3d.create(0, 0));\n        return points;\n    }\n    // cspell:word creat\n    /** @deprecated in 4.x. Use createVerticalStaggerPolygon instead. */\n    static creatVerticalStaggerPolygon(dy1, dy2, dy3, dy4, ax, ay, dx1, dx4) {\n        return this.createVerticalStaggerPolygon(dy1, dy2, dy3, dy4, ax, ay, dx1, dx4);\n    }\n    /**\n     * Make line segments for each pair of adjacent points.\n     * @param points array of points\n     * @param forceClosure if true, inspect coordinates to determine if a closure edge is needed.\n     */\n    static convertPointsToSegments(points, forceClosure = false) {\n        const segments = [];\n        const n = points.length;\n        for (let i = 0; i + 1 < n; i++) {\n            segments.push(LineSegment3d.create(points[i], points[i + 1]));\n        }\n        if (forceClosure && n > 1 && !points[0].isAlmostEqual(points[n - 1]))\n            segments.push(LineSegment3d.create(points[n - 1], points[0]));\n        return segments;\n    }\n    /**\n     * Create a regular polygon\n     * @param angle0 angle from x axis to first point.\n     * @param numPoint number of points\n     * @param close true to add closure edge.\n     */\n    static createRegularPolygon(cx, cy, cz, angle0, r, numPoint, close) {\n        const points = [];\n        const angleStepRadians = 2.0 * Math.PI / numPoint;\n        let radians;\n        for (let i = 0; i < numPoint; i++) {\n            radians = angle0.radians + i * angleStepRadians;\n            points.push(Point3d.create(cx + r * Math.cos(radians), cy + r * Math.sin(radians), cz));\n        }\n        if (close)\n            points.push(points[0].clone());\n        return points;\n    }\n    /**\n     * Create a star by alternating radii (with equal angular steps)\n     * @param r0 first point radius\n     * @param r1 second point radius (if undefined, this is skipped and the result is points on a circle.)\n     * @param numPoint number of points\n     * @param close true to add closure edge.\n     */\n    static createStar(cx, cy, cz, r0, r1, numPoint, close, theta0) {\n        const points = [];\n        const angleStepRadians = Math.PI / numPoint;\n        const radians0 = theta0 === undefined ? 0.0 : theta0.radians;\n        let radians;\n        for (let i = 0; i < numPoint; i++) {\n            radians = radians0 + 2 * i * angleStepRadians;\n            points.push(Point3d.create(cx + r0 * Math.cos(radians), cy + r0 * Math.sin(radians), cz));\n            if (r1 !== undefined) {\n                radians = radians0 + (2 * i + 1) * angleStepRadians;\n                points.push(Point3d.create(cx + r1 * Math.cos(radians), cy + r1 * Math.sin(radians), cz));\n            }\n        }\n        if (close)\n            points.push(points[0].clone());\n        return points;\n    }\n    /**\n     * Create an outer star A\n     * Place multiple inner stars B with centers on circle C\n     * @param rA0 radius to star tips on starA\n     * @param rA1 radius to star tips on starA\n     * @param numAPoint number of points on starA\n     * @param rB0 radius to star B tips\n     * @param rB1 radius to star B  tips\n     * @param numBPoint\n     * @param rC radius for inner star centers\n     * @param numC number of inner stars\n     */\n    static createStarsInStars(rA0, rA1, numAPoint, rB0, rB1, numBPoint, rC, numC, close) {\n        const loops = [];\n        loops.push(this.createStar(0, 0, 0, rA0, rA1, numAPoint, close));\n        if (numC > 0) {\n            const radiansStep = Math.PI * 2.0 / numC;\n            for (let i = 0; i < numC; i++) {\n                const radians = i * radiansStep;\n                loops.push(this.createStar(rC * Math.cos(radians), rC * Math.sin(radians), 0.0, rB0, rB1, numBPoint, close));\n            }\n        }\n        return loops;\n    }\n    static appendGeometry(source, dest) {\n        for (const g of source)\n            dest.push(g);\n    }\n    /** Create a simple example of each GeometryQuery type .... */\n    static createAllGeometryQueryTypes() {\n        const result = [];\n        const pointA = Point3d.create(0, 0, 0);\n        const pointB = Point3d.create(1, 0, 0);\n        const pointC = Point3d.create(1, 1, 0);\n        const pointD = Point3d.create(0, 1, 0);\n        const pointABC = [pointA, pointB, pointC];\n        const pointABCD = [pointA, pointB, pointC, pointD];\n        const pointABCDA = [pointA, pointB, pointC, pointD, pointA];\n        result.push(LineSegment3d.create(pointA, pointB));\n        result.push(CoordinateXYZ.create(pointA));\n        result.push(Arc3d.createCircularStartMiddleEnd(pointA, pointB, pointC));\n        result.push(PointString3d.create(pointA, pointB));\n        result.push(IntegratedSpiral3d.createRadiusRadiusBearingBearing(Segment1d.create(0, 100), AngleSweep.createStartEndDegrees(0, 5), Segment1d.create(0, 0.5), Transform.createIdentity()));\n        result.push(LineString3d.create(pointABCD));\n        result.push(BezierCurve3d.create(pointABC));\n        result.push(BezierCurve3dH.create(pointABC));\n        result.push(BSplineCurve3d.createUniformKnots(pointABC, 3));\n        result.push(BSplineCurve3dH.createUniformKnots(pointABC, 3));\n        result.push(Loop.create(LineString3d.create(pointABCDA)));\n        result.push(Path.create(LineString3d.create(pointABCD)));\n        result.push(this.createConeBsplineSurface(pointA, pointC, 1, 2, 4));\n        result.push(this.createXYGridBsplineSurface(8, 4, 4, 3));\n        this.appendGeometry(this.createClosedSolidSampler(true), result);\n        result.push(this.createTriangularUnitGridPolyface(pointA, Vector3d.unitX(), Vector3d.unitY(), 4, 5));\n        result.push(this.createTriangularUnitGridPolyface(pointA, Vector3d.unitX(), Vector3d.unitY(), 4, 5, true, true, true, false));\n        this.appendGeometry(this.createSimpleParityRegions(), result);\n        this.appendGeometry(this.createSimpleUnions(), result);\n        this.appendGeometry(this.createBagOfCurves(), result);\n        return result;\n    }\n    /**\n     * Create points on a sine wave\n     * Point i is origin + (i * xStep, a *sin(theta0 + i * dTheta), b * sin(beta0 + i * dBeta))\n     * * Default b is zero, so it is a simple sine wave\n     * * If the dTheta and dBeta are equal, it is a sine wave in a tilted plane.\n     * * If dTheta and dBeta are different it is a non-planar curve\n     */\n    static createPointSineWave(origin, numInterval = 24, xStep = Math.PI / 12, a = 1, thetaSweep = AngleSweep.createStartEndDegrees(0, 360), b = 0, betaSweep = AngleSweep.createStartEndDegrees(0, 180)) {\n        return this.createPointsByIndexFunctions(numInterval, SteppedIndexFunctionFactory.createLinear(xStep, origin ? origin.x : 0), SteppedIndexFunctionFactory.createCosine(a, thetaSweep, origin ? origin.y : 0), SteppedIndexFunctionFactory.createCosine(b, betaSweep, origin ? origin.z : 0));\n    }\n    /**\n     * Create points with x,y,z independent functions of i and numInterval,\n     * Point3d.create (fx(i,numInterval), fy(i,numInterval), fz(i, numInterval));\n     */\n    static createPointsByIndexFunctions(numInterval, fx, fy, fz) {\n        const points = [];\n        if (numInterval > 0) {\n            for (let i = 0; i <= numInterval; i++) {\n                points.push(Point3d.create(fx(i, numInterval), fy(i, numInterval), fz ? fz(i, numInterval) : 0));\n            }\n        }\n        return points;\n    }\n    /**\n     * Add an AuxData  (with multiple AuxChannelData) using data evaluated by a function of input and xyz.\n     * @param data existing polyface data object to receive the additional AuxChannel\n     * @param channelIndex\n     * @param name name of channel\n     * @param inputName name of input\n     * @param input0 input value for channel 0\n     * @param inputStep step between inputs (channels)\n     * @param numInput number of channels (inputs)\n     * @param dataType\n     * @param scalarFunction function to return the scalar value at (input, point)\n     */\n    static addAuxDataScalarChannel(data, channelIndex, name, inputName, input0, inputStep, numInput, dataType, scalarFunction) {\n        if (!data.auxData)\n            data.auxData = new PolyfaceAuxData([], []);\n        const channelDataArray = [];\n        const xyz = Point3d.create();\n        for (let i = 0; i < numInput; i++) {\n            const input = input0 + i * inputStep;\n            const values = [];\n            for (let k = 0; k < data.point.length; k++) {\n                data.point.getPoint3dAtUncheckedPointIndex(k, xyz);\n                values.push(scalarFunction(input, xyz));\n            }\n            channelDataArray.push(new AuxChannelData(input, values));\n        }\n        const channel = new AuxChannel(channelDataArray, dataType, name, inputName);\n        for (const _q of data.pointIndex) {\n            data.auxData.indices.push(channelIndex);\n        }\n        data.auxData.channels.push(channel);\n    }\n    /**\n     * Create a mesh between concentric arcs\n     * @param edgesPerQuadrant edges per 90 degrees\n     * @param center arc center\n     * @param r0 first radius\n     * @param r1 second radius\n     * @param theta0 start angle\n     * @param theta1 end angle.\n     * @returns\n     */\n    static createMeshInAnnulus(edgesPerQuadrant, center, r0, r1, theta0, theta1) {\n        const point0 = [];\n        const point1 = [];\n        if (edgesPerQuadrant < 1)\n            edgesPerQuadrant = 1;\n        let edgeCount = Math.ceil(edgesPerQuadrant * (theta1.degrees - theta0.degrees) / 90);\n        if (edgeCount < 1)\n            edgeCount = 1;\n        for (let i = 0; i <= edgeCount; i++) {\n            const theta = Angle.createInterpolate(theta0, i / edgeCount, theta1);\n            point0.push(center.plusXYZ(r0 * theta.cos(), r0 * theta.sin(), 0));\n            point1.push(center.plusXYZ(r1 * theta.cos(), r1 * theta.sin(), 0));\n        }\n        point1.reverse();\n        const builder = PolyfaceBuilder.create();\n        builder.addGreedyTriangulationBetweenLineStrings(point0, point1);\n        return builder.claimPolyface();\n    }\n    /** Create strokes on an arc at radius r0, then returning at radius r1. */\n    static createAnnulusPolyline(edgesPerQuadrant, center, r0, r1, theta0, theta1, addClosure) {\n        const point0 = [];\n        const point1 = [];\n        if (edgesPerQuadrant < 1)\n            edgesPerQuadrant = 1;\n        let edgeCount = Math.ceil(edgesPerQuadrant * (theta1.degrees - theta0.degrees) / 90);\n        if (edgeCount < 1)\n            edgeCount = 1;\n        for (let i = 0; i <= edgeCount; i++) {\n            const theta = Angle.createInterpolate(theta0, i / edgeCount, theta1);\n            point0.push(center.plusXYZ(r0 * theta.cos(), r0 * theta.sin(), 0));\n            point1.push(center.plusXYZ(r1 * theta.cos(), r1 * theta.sin(), 0));\n        }\n        while (point1.length > 0)\n            point0.push(point1.pop());\n        if (addClosure)\n            point0.push(point0[0].clone());\n        return point0;\n    }\n    /**\n     * Return an array of points on a circular arc.\n     * @param edgesPerQuadrant number of edges per 90 degrees\n     * @param center arc center\n     * @param r0 arc radius\n     * @param theta0 start angle\n     * @param theta1 end angle\n     * @param addClosure true to add a closure stroke\n     * @returns\n     */\n    static createArcStrokes(edgesPerQuadrant, center, r0, theta0, theta1, addClosure = true, z = 0) {\n        const point0 = [];\n        if (edgesPerQuadrant < 1)\n            edgesPerQuadrant = 1;\n        let edgeCount = Math.ceil(edgesPerQuadrant * (theta1.degrees - theta0.degrees) / 90);\n        if (edgeCount < 1)\n            edgeCount = 1;\n        for (let i = 0; i <= edgeCount; i++) {\n            const theta = Angle.createInterpolate(theta0, i / edgeCount, theta1);\n            point0.push(center.plusXYZ(r0 * theta.cos(), r0 * theta.sin(), z));\n        }\n        if (addClosure)\n            point0.push(point0[0].clone());\n        return point0;\n    }\n    /**\n     * Create a mesh with\n     *   * xy facets are 1x1 quads starting at origin\n     *   * acceptFunction is called to accept or reject each quad's lower left xy coordinates\n     * @param xzPoints array of points in the xz plane.  Expected to have increasing x and all integer coordinates.\n     * @param ySweep distance to sweep in y direction\n     * @param acceptFunction (x0: number, y0: number)=> boolean\n     */\n    static sweepXZLineStringToMeshWithHoles(xzPoints, ySweep, acceptFunction) {\n        const builder = PolyfaceBuilder.create();\n        for (let i0 = 0; i0 + 1 < xzPoints.length; i0++) {\n            const x0 = xzPoints[i0][0];\n            const z0 = xzPoints[i0][1];\n            const i1 = i0 + 1;\n            const x1 = xzPoints[i1][0];\n            const z1 = xzPoints[i1][1];\n            for (let xA = x0; xA + 1 <= x1; xA++) {\n                const xB = xA + 1;\n                const sA = (xA - x0) / (x1 - x0);\n                const sB = (xB - x0) / (x1 - x0);\n                const zA = Geometry.interpolate(z0, sA, z1);\n                const zB = Geometry.interpolate(z0, sB, z1);\n                for (let yC = 0; yC + 1 <= ySweep; yC++) {\n                    const yD = yC + 1;\n                    if (acceptFunction(xA, yC))\n                        builder.addPolygon([\n                            Point3d.create(xA, yC, zA),\n                            Point3d.create(xB, yC, zB),\n                            Point3d.create(xB, yD, zB),\n                            Point3d.create(xA, yD, zA),\n                        ]);\n                }\n            }\n        }\n        return builder.claimPolyface(true);\n    }\n    /**\n     *  Successively move in directions in the steps array, creating numStroke total strokes.\n     * * In typical use there are two entries in the steps vector, giving the effect of stair steps if they are perpendicular.\n     * * if start is a single point, create a new point array with start as its first entry.\n     * * if start is an array, add to it.\n     * * if start is an empty array, push 000 as starting point.\n     * @param start start point or prior array of points whose last is start point.\n     * @param steps array of vectors giving step vectors.\n     * @param numStroke number of steps to take.\n     */\n    static createZigZag(start, steps, numStroke) {\n        let result;\n        if (Array.isArray(start)) {\n            result = start;\n            if (result.length === 0)\n                result.push(Point3d.create(0, 0, 0));\n        }\n        else {\n            result = [start.clone()];\n        }\n        let numAdded = 0;\n        for (;;) {\n            for (const step of steps) {\n                if (++numAdded > numStroke)\n                    return result;\n                result.push(result[result.length - 1].plus(step));\n            }\n        }\n        return result;\n    }\n}\n/** Array with assorted Point2d samples */\nSample.point2d = [\n    Point2d.create(0, 0),\n    Point2d.create(1, 0),\n    Point2d.create(0, 1),\n    Point2d.create(2, 3)\n];\n/** Array with assorted Point3d samples */\nSample.point3d = [\n    Point3d.create(0, 0, 0),\n    Point3d.create(1, 0, 0),\n    Point3d.create(0, 1, 0),\n    Point3d.create(0, 1, 0),\n    Point3d.create(0, 0, 1),\n    Point3d.create(2, 3, 0),\n    Point3d.create(0, 2, 5),\n    Point3d.create(-3, 0, 5),\n    Point3d.create(4, 3, -2)\n];\n/** Array with assorted Point4d samples */\nSample.point4d = [\n    Point4d.create(0, 0, 0, 1),\n    Point4d.create(1, 0, 0, 1),\n    Point4d.create(0, 1, 0, 1),\n    Point4d.create(0, 1, 0, 1),\n    Point4d.create(0, 0, 1, 1),\n    Point4d.create(2, 3, 0, 1),\n    Point4d.create(0, 2, 5, 1),\n    Point4d.create(-3, 0, 5, 1),\n    Point4d.create(-3, 0, 5, 0.3),\n    Point4d.create(-3, 0, 5, -0.2),\n    Point4d.create(4, 3, -2, 1)\n];\n/** Array with assorted nonzero Vector2d samples */\nSample.vector2d = [\n    Vector2d.create(1, 0),\n    Vector2d.create(0, 1),\n    Vector2d.create(0, 0),\n    Vector2d.create(-1, 0),\n    Vector2d.create(0, -1),\n    Vector2d.create(0, 0),\n    Vector2d.createPolar(1.0, Angle.createDegrees(20)),\n    Vector2d.createPolar(2.0, Angle.createDegrees(20)),\n    Vector2d.create(2, 3),\n];\n/** Assorted Plane3dBYOriginAndUnitNormal */\nSample.plane3dByOriginAndUnitNormal = [\n    Plane3dByOriginAndUnitNormal.createXYPlane(),\n    Plane3dByOriginAndUnitNormal.createYZPlane(),\n    Plane3dByOriginAndUnitNormal.createZXPlane(),\n    Sample.createPlane(0, 0, 0, 3, 0, 1),\n    Sample.createPlane(1, 2, 3, 2, 4, -1),\n];\n/** Assorted Ray3d, not all unit direction vectors. */\nSample.ray3d = [\n    Sample.createRay(0, 0, 0, 1, 0, 0),\n    Sample.createRay(0, 0, 0, 0, 1, 0),\n    Sample.createRay(0, 0, 0, 0, 0, 1),\n    Sample.createRay(0, 0, 0, 1, 2, 0),\n    Sample.createRay(1, 2, 3, 4, 2, -1),\n];\n/** Assorted angles.  All principal directions, some others included. */\nSample.angle = [\n    Angle.createDegrees(0),\n    Angle.createDegrees(90),\n    Angle.createDegrees(180),\n    Angle.createDegrees(-90),\n    Angle.createDegrees(30),\n    Angle.createDegrees(-105),\n];\n/** Assorted angle sweeps */\nSample.angleSweep = [\n    AngleSweep.createStartEndDegrees(0, 90),\n    AngleSweep.createStartEndDegrees(0, 180),\n    AngleSweep.createStartEndDegrees(-90, 0),\n    AngleSweep.createStartEndDegrees(0, -90),\n    AngleSweep.createStartEndDegrees(0, 30),\n    AngleSweep.createStartEndDegrees(45, 110),\n];\n/** Assorted line segments */\nSample.lineSegment3d = [\n    LineSegment3d.create(Point3d.create(0, 0, 0), Point3d.create(1, 0, 0)),\n    LineSegment3d.create(Point3d.create(0, 0, 0), Point3d.create(0, 1, 0)),\n    LineSegment3d.create(Point3d.create(0, 0, 0), Point3d.create(0, 0, 1)),\n    LineSegment3d.create(Point3d.create(1, 2, 3), Point3d.create(-2, -3, 0.5)),\n];\n/** Assorted Range1d: single point, null, simple forward, simple reverse */\nSample.range1d = [\n    Range1d.createX(1),\n    Range1d.createNull(),\n    Range1d.createXX(1, 2),\n    Range1d.createXX(2, 1),\n];\n/** Assorted range2d: single point, null, 2 point with various creation orders. */\nSample.range2d = [\n    Range2d.createXY(1, 2),\n    Range2d.createNull(),\n    Range2d.createXYXY(1, 2, 0, 3),\n    Range2d.createXYXY(1, 2, 3, 4),\n];\n/** Assorted range2d: single point, null, 2 point with various creation orders. */\nSample.range3d = [\n    Range3d.createXYZ(1, 2, 3),\n    Range3d.createNull(),\n    Range3d.createXYZXYZ(1, 2, 0, 3, 4, 7),\n    Range3d.createXYZXYZ(1, 2, 3, -2, -4, -1),\n];\nexport { Sample };\n//# sourceMappingURL=GeometrySamples.js.map",
      "start": 1693508124041,
      "end": 1693508124285,
      "sourcemaps": null
    }
  ]
}
