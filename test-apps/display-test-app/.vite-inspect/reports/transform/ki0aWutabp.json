{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/clipping/ClipPrimitive.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module CartesianGeometry\n */\nimport { Geometry } from \"../Geometry\";\nimport { Vector2d } from \"../geometry3d/Point2dVector2d\";\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\nimport { PolygonOps } from \"../geometry3d/PolygonOps\";\nimport { Transform } from \"../geometry3d/Transform\";\nimport { HalfEdgeMask } from \"../topology/Graph\";\nimport { Triangulator } from \"../topology/Triangulation\";\nimport { ClipPlane } from \"./ClipPlane\";\nimport { ClipPlaneContainment } from \"./ClipUtils\";\nimport { ConvexClipPlaneSet } from \"./ConvexClipPlaneSet\";\nimport { UnionOfConvexClipPlaneSets } from \"./UnionOfConvexClipPlaneSets\";\nimport { AlternatingCCTreeNode } from \"./AlternatingConvexClipTree\";\nimport { Point3dArray } from \"../geometry3d/PointHelpers\";\nimport { PolylineOps } from \"../geometry3d/PolylineOps\";\n// cspell:word zlow\n// cspell:word zhigh\n/**\n * Bit mask type for referencing subsets of 6 planes of range box.\n * @public\n */\nexport var ClipMaskXYZRangePlanes;\n(function (ClipMaskXYZRangePlanes) {\n    /** no planes */\n    ClipMaskXYZRangePlanes[ClipMaskXYZRangePlanes[\"None\"] = 0] = \"None\";\n    /** low x plane */\n    ClipMaskXYZRangePlanes[ClipMaskXYZRangePlanes[\"XLow\"] = 1] = \"XLow\";\n    /** high x plane */\n    ClipMaskXYZRangePlanes[ClipMaskXYZRangePlanes[\"XHigh\"] = 2] = \"XHigh\";\n    /** low y plane */\n    ClipMaskXYZRangePlanes[ClipMaskXYZRangePlanes[\"YLow\"] = 4] = \"YLow\";\n    /** high y plane */\n    ClipMaskXYZRangePlanes[ClipMaskXYZRangePlanes[\"YHigh\"] = 8] = \"YHigh\";\n    /** low z plane */\n    ClipMaskXYZRangePlanes[ClipMaskXYZRangePlanes[\"ZLow\"] = 16] = \"ZLow\";\n    /** high z plane */\n    ClipMaskXYZRangePlanes[ClipMaskXYZRangePlanes[\"ZHigh\"] = 32] = \"ZHigh\";\n    /** all x and y planes, neither z plane */\n    ClipMaskXYZRangePlanes[ClipMaskXYZRangePlanes[\"XAndY\"] = 15] = \"XAndY\";\n    /** all 6 planes */\n    ClipMaskXYZRangePlanes[ClipMaskXYZRangePlanes[\"All\"] = 63] = \"All\";\n})(ClipMaskXYZRangePlanes || (ClipMaskXYZRangePlanes = {}));\n/**\n * * ClipPrimitive is a base class for clipping implementations that use\n *   * A UnionOfConvexClipPlaneSets designated \"clipPlanes\".\n *   * An \"invisible\" flag.\n * * When constructed directly, objects of type ClipPrimitive (directly, not through a derived class) will have just planes.\n * * Derived classes (e.g. ClipShape) carry additional data such as a swept shape.\n * * ClipPrimitive can be constructed with no planes.\n *     * Derived class is responsible for filling the plane sets.\n *     * At discretion of derived classes, plane construction can be done at construction time or \"on demand when\" queries\n * call `ensurePlaneSets ()`\n * * ClipPrimitive can be constructed directly with planes (and no derived class).\n * * That the prevailing use is via a ClipShape derived class.\n *    * The ClipShape has an \"isMask\" property\n *       * isMask === false means the plane sets should cover the inside of its polygon.\n *       * isMask === true means the plane sets should cover the outside of its polygon.\n *  * Note that the ClipShape's `isMask` property and the ClipPrimitive's `isInvisible` property are distinct controls.\n *     * In normal usage, callers get \"outside\" clip behavior using ONLY the ClipShape isMask property.\n *     * The ClipShape happens to pass the _invisible bit down to ClipPlanes that it creates.\n *         * At that level, the flag controls whether the cut edges are produced on the plane\n * @public\n */\nexport class ClipPrimitive {\n    /**\n     * Get a reference to the `UnionOfConvexClipPlaneSets`.\n     * * It triggers construction of the sets by `this.ensurePlaneSets()`.\n     * * Derived class typically caches the set on the first such call.\n     */\n    fetchClipPlanesRef() {\n        this.ensurePlaneSets();\n        return this._clipPlanes;\n    }\n    /** Ask if this primitive is a hole. */\n    get invisible() {\n        return this._invisible;\n    }\n    constructor(planeSet, isInvisible = false) {\n        this._clipPlanes = planeSet;\n        this._invisible = isInvisible;\n    }\n    /**\n     * Create a ClipPrimitive, capturing the supplied plane set as the clip planes.\n     * @param planes clipper\n     * @param isInvisible set the invisible flag on the ClipPrimitive\n     */\n    static createCapture(planes, isInvisible = false) {\n        let planeData;\n        if (planes instanceof UnionOfConvexClipPlaneSets)\n            planeData = planes;\n        if (planes instanceof ConvexClipPlaneSet)\n            planeData = UnionOfConvexClipPlaneSets.createConvexSets([planes]);\n        return new ClipPrimitive(planeData, isInvisible);\n    }\n    /** Emit json form of the clip planes */\n    toJSON() {\n        const planes = {};\n        if (this._clipPlanes)\n            planes.clips = this._clipPlanes.toJSON();\n        if (this._invisible)\n            planes.invisible = true;\n        return { planes };\n    }\n    /**\n     * Returns true if the planes are present.\n     * * This can be false (for instance) if a ClipShape is holding a polygon but has not yet been asked to construct\n     * the planes.\n     */\n    arePlanesDefined() {\n        return this._clipPlanes !== undefined;\n    }\n    /** Return a deep clone. */\n    clone() {\n        const newPlanes = this._clipPlanes ? this._clipPlanes.clone() : undefined;\n        const result = new ClipPrimitive(newPlanes, this._invisible);\n        return result;\n    }\n    /**\n     * Trigger (if needed) computation of plane sets (if applicable) in the derived class.\n     * * Base class is no op.\n     * * In derived class, on first call create planes sets from defining data (e.g. swept shape).\n     * * In derived class, if planes are present leave them alone.\n     */\n    ensurePlaneSets() { }\n    /**\n     * Return true if the point lies inside/on this polygon (or not inside/on if this polygon is a mask). Otherwise,\n     * return false.\n     * * Note that a derived class may choose to (a) implement its own test using its defining data, or (b) accept\n     * this implementation using planes that it inserted in the base class.\n     */\n    pointInside(point, onTolerance = Geometry.smallMetricDistanceSquared) {\n        this.ensurePlaneSets();\n        let inside = true;\n        if (this._clipPlanes)\n            inside = this._clipPlanes.isPointOnOrInside(point, onTolerance);\n        return inside;\n    }\n    /**\n     * Method from [[Clipper]] interface.\n     * * Implement as dispatch to clipPlaneSets as supplied by derived class.\n     */\n    isPointOnOrInside(point, onTolerance = Geometry.smallMetricDistanceSquared) {\n        this.ensurePlaneSets();\n        let inside = true;\n        if (this._clipPlanes)\n            inside = this._clipPlanes.isPointOnOrInside(point, onTolerance);\n        return inside;\n    }\n    /**\n     * Method from [[Clipper]] interface.\n     * * Implement as dispatch to clipPlaneSets as supplied by derived class.\n     */\n    announceClippedSegmentIntervals(f0, f1, pointA, pointB, announce) {\n        this.ensurePlaneSets();\n        let hasInsideParts = false;\n        if (this._clipPlanes)\n            hasInsideParts = this._clipPlanes.announceClippedSegmentIntervals(f0, f1, pointA, pointB, announce);\n        return hasInsideParts;\n    }\n    /**\n     * Method from [[Clipper]] interface.\n     * * Implement as dispatch to clipPlaneSets as supplied by derived class.\n     */\n    announceClippedArcIntervals(arc, announce) {\n        this.ensurePlaneSets();\n        let hasInsideParts = false;\n        if (this._clipPlanes)\n            hasInsideParts = this._clipPlanes.announceClippedArcIntervals(arc, announce);\n        return hasInsideParts;\n    }\n    /**\n     * Multiply all ClipPlanes DPoint4d by matrix.\n     * @param matrix matrix to apply.\n     * @param invert if true, use in verse of the matrix.\n     * @param transpose if true, use the transpose of the matrix (or inverse, per invert parameter).\n     * @param matrix matrix to apply.\n     * * Note that if matrixA is applied to all of space, the matrix to send to this method to get a corresponding\n     * effect on the plane is the inverse transpose of matrixA.\n     * * Callers that will apply the same matrix to many planes should pre-invert the matrix for efficiency.\n     * * Both params default to true to get the full effect of transforming space.\n     */\n    multiplyPlanesByMatrix4d(matrix, invert = true, transpose = true) {\n        if (invert) { // form inverse once here, reuse for all planes\n            const inverse = matrix.createInverse();\n            if (!inverse)\n                return false;\n            return this.multiplyPlanesByMatrix4d(inverse, false, transpose);\n        }\n        if (this._clipPlanes)\n            this._clipPlanes.multiplyPlanesByMatrix4d(matrix);\n        return true;\n    }\n    /** Apply a transform to the clipper (e.g. transform all planes). */\n    transformInPlace(transform) {\n        if (this._clipPlanes)\n            this._clipPlanes.transformInPlace(transform);\n        return true;\n    }\n    /** Sets both the clip plane set and the mask set visibility */\n    setInvisible(invisible) {\n        this._invisible = invisible;\n    }\n    /**\n     * Return true if any plane of the primary clipPlanes has (a) non-zero z component in its normal vector and\n     * (b) finite distance from origin.\n     */\n    containsZClip() {\n        if (this.fetchClipPlanesRef() !== undefined)\n            for (const convexSet of this._clipPlanes.convexSets)\n                for (const plane of convexSet.planes)\n                    if (Math.abs(plane.inwardNormalRef.z) > 1.0e-6 && Math.abs(plane.distance) !== Number.MAX_VALUE)\n                        return true;\n        return false;\n    }\n    /**\n     * Quick test of whether the given points fall completely inside or outside.\n     * @param points points to test.\n     * @param ignoreInvisibleSetting if true, do the test with the clip planes and return that, ignoring the\n     * invisible setting.\n     */\n    classifyPointContainment(points, ignoreInvisibleSetting) {\n        this.ensurePlaneSets();\n        const planes = this._clipPlanes;\n        let inside = ClipPlaneContainment.StronglyInside;\n        if (planes)\n            inside = planes.classifyPointContainment(points, false);\n        if (this._invisible && !ignoreInvisibleSetting)\n            switch (inside) {\n                case ClipPlaneContainment.StronglyInside:\n                    return ClipPlaneContainment.StronglyOutside;\n                case ClipPlaneContainment.StronglyOutside:\n                    return ClipPlaneContainment.StronglyInside;\n                case ClipPlaneContainment.Ambiguous:\n                    return ClipPlaneContainment.Ambiguous;\n            }\n        return inside;\n    }\n    /**\n     * Promote json object form to class instance.\n     * * First try to convert to a ClipShape.\n     * * then try as a standalone instance of the base class ClipPrimitive.\n     */\n    static fromJSON(json) {\n        if (!json)\n            return undefined;\n        const shape = ClipShape.fromClipShapeJSON(json);\n        if (shape)\n            return shape;\n        return ClipPrimitive.fromJSONClipPrimitive(json);\n    }\n    /** Specific converter producing the base class ClipPrimitive. */\n    static fromJSONClipPrimitive(json) {\n        const planes = json?.planes;\n        if (!planes)\n            return undefined;\n        const clipPlanes = planes.clips ? UnionOfConvexClipPlaneSets.fromJSON(planes.clips) : undefined;\n        const invisible = undefined !== planes.invisible ? planes.invisible : false;\n        return new ClipPrimitive(clipPlanes, invisible);\n    }\n}\n/** Internal helper class holding XYZ components that serves as a representation of polygon edges defined by clip planes */\nclass PolyEdge {\n    constructor(origin, next, normal, z) {\n        this.pointA = Point3d.create(origin.x, origin.y, z);\n        this.pointB = Point3d.create(next.x, next.y, z);\n        this.normal = normal;\n    }\n    // Assume both normals are unit length.\n    // old logic: use difference of (previously computed) normals as perpendicular to bisector.\n    static makeUnitPerpendicularToBisector(edgeA, edgeB, reverse) {\n        let candidate = edgeB.normal.minus(edgeA.normal);\n        if (candidate.normalize(candidate) === undefined) {\n            candidate = Vector3d.createStartEnd(edgeA.pointA, edgeB.pointB);\n            if (candidate.normalize(candidate) === undefined)\n                return undefined;\n        }\n        if (reverse)\n            candidate.scale(-1.0, candidate);\n        return candidate;\n    }\n}\n/**\n * A clipping volume defined by a shape (an array of 3d points using only x and y dimensions).\n * May be given either a ClipPlaneSet to store directly, or an array of polygon points as well as other parameters\n * for parsing ClipPlanes from the shape later.\n * @public\n */\nexport class ClipShape extends ClipPrimitive {\n    constructor(polygon = [], zLow, zHigh, transform, isMask = false, invisible = false) {\n        super(undefined, invisible); // ClipPlaneSets will be set up later after storing points\n        this._isMask = false;\n        this._polygon = polygon;\n        this.initSecondaryProps(isMask, zLow, zHigh, transform);\n    }\n    /** Returns true if this ClipShape is marked as invisible. */\n    get invisible() {\n        return this._invisible;\n    }\n    /** Return this transformFromClip, which may be undefined. */\n    get transformFromClip() {\n        return this._transformFromClip;\n    }\n    /** Return this transformToClip, which may be undefined. */\n    get transformToClip() {\n        return this._transformToClip;\n    }\n    /** Returns true if this ClipShape's transforms are currently set. */\n    get transformValid() {\n        return this.transformFromClip !== undefined;\n    }\n    /** Returns true if this ClipShape's lower z boundary is set. */\n    get zLowValid() {\n        return this._zLow !== undefined;\n    }\n    /** Returns true if this ClipShape's upper z boundary is set. */\n    get zHighValid() {\n        return this._zHigh !== undefined;\n    }\n    /** Return true if this ClipShape has a local to world transform */\n    get transformIsValid() {\n        return this._transformFromClip !== undefined;\n    }\n    /** Return this zLow, which may be undefined. */\n    get zLow() {\n        return this._zLow;\n    }\n    /** Return this zHigh, which may be undefined. */\n    get zHigh() {\n        return this._zHigh;\n    }\n    /** Returns a reference to this ClipShape's polygon array. */\n    get polygon() {\n        return this._polygon;\n    }\n    /** Returns true if this ClipShape is a masking set. */\n    get isMask() {\n        return this._isMask;\n    }\n    /** Sets the polygon points array of this ClipShape to the array given (by reference). */\n    setPolygon(polygon) {\n        // Add closure point\n        if (!polygon[0].isAlmostEqual(polygon[polygon.length - 1]))\n            polygon.push(polygon[0].clone());\n        this._polygon = polygon;\n    }\n    /**\n     * If the ClipShape's associated `UnionOfConvexClipPlaneSets` is defined, do nothing.\n     * If the ClipShape's associated `UnionOfConvexClipPlaneSets` is undefined, generate it from the `ClipShape`\n     * and transform.\n     */\n    ensurePlaneSets() {\n        if (this._clipPlanes !== undefined)\n            return;\n        this._clipPlanes = UnionOfConvexClipPlaneSets.createEmpty();\n        this.parseClipPlanes(this._clipPlanes);\n        if (this._transformFromClip)\n            this._clipPlanes.transformInPlace(this._transformFromClip);\n    }\n    /**\n     * Initialize the members of the ClipShape class that may at times be undefined.\n     * zLow and zHigh default to Number.MAX_VALUE, and the transform defaults to an identity transform.\n     */\n    initSecondaryProps(isMask, zLow, zHigh, transform) {\n        this._isMask = isMask;\n        this._zLow = zLow;\n        this._zHigh = zHigh;\n        if (transform !== undefined) {\n            this._transformFromClip = transform;\n            this._transformToClip = transform.inverse(); // could be undefined\n        }\n        else {\n            this._transformFromClip = Transform.createIdentity();\n            this._transformToClip = Transform.createIdentity();\n        }\n    }\n    /** Emit json object form */\n    toJSON() {\n        const shape = {\n            points: this._polygon.map((pt) => pt.toJSON()),\n        };\n        if (this.invisible)\n            shape.invisible = true;\n        if (this._transformFromClip && !this._transformFromClip.isIdentity)\n            shape.trans = this._transformFromClip.toJSON();\n        if (this.isMask)\n            shape.mask = true;\n        if (typeof (this.zLow) !== \"undefined\" && this.zLow !== -Number.MAX_VALUE)\n            shape.zlow = this.zLow;\n        if (typeof (this.zHigh) !== \"undefined\" && this.zHigh !== Number.MAX_VALUE)\n            shape.zhigh = this.zHigh;\n        return { shape };\n    }\n    /** Parse `json` to a clip shape. */\n    static fromClipShapeJSON(json, result) {\n        const shape = json?.shape;\n        if (!shape)\n            return undefined;\n        const points = shape.points ? shape.points.map((pt) => Point3d.fromJSON(pt)) : [];\n        const trans = shape.trans ? Transform.fromJSON(shape.trans) : undefined;\n        const zLow = typeof shape.zlow === \"number\" ? shape.zlow : undefined;\n        const zHigh = typeof shape.zhigh === \"number\" ? shape.zhigh : undefined;\n        const isMask = typeof shape.mask === \"boolean\" && shape.mask;\n        const invisible = typeof shape.invisible === \"boolean\" && shape.invisible;\n        return ClipShape.createShape(points, zLow, zHigh, trans, isMask, invisible, result);\n    }\n    /** Returns a new ClipShape that is a deep copy of the ClipShape given */\n    static createFrom(other, result) {\n        const retVal = ClipShape.createEmpty(false, false, undefined, result);\n        retVal._invisible = other._invisible;\n        for (const point of other._polygon) {\n            retVal._polygon.push(point.clone());\n        }\n        retVal._isMask = other._isMask;\n        retVal._zLow = other._zLow;\n        retVal._zHigh = other._zHigh;\n        retVal._transformToClip = other._transformToClip ? other._transformToClip.clone() : undefined;\n        retVal._transformFromClip = other._transformFromClip ? other._transformFromClip.clone() : undefined;\n        return retVal;\n    }\n    /** Create a new ClipShape from an array of points that make up a 2d shape (stores a deep copy of these points). */\n    static createShape(polygon = [], zLow, zHigh, transform, isMask = false, invisible = false, result) {\n        if (polygon.length < 3)\n            return undefined;\n        const pPoints = polygon.slice(0);\n        // Add closure point.\n        if (pPoints[0].isAlmostEqual(pPoints[pPoints.length - 1]))\n            pPoints[0].clone(pPoints[pPoints.length - 1]);\n        else\n            pPoints.push(pPoints[0].clone());\n        if (result) {\n            result._clipPlanes = undefined; // Start as undefined\n            result._invisible = invisible;\n            result._polygon = pPoints;\n            result.initSecondaryProps(isMask, zLow, zHigh, transform);\n            return result;\n        }\n        else {\n            return new ClipShape(pPoints, zLow, zHigh, transform, isMask, invisible);\n        }\n    }\n    /**\n     * Create a ClipShape that exists as a 3 dimensional box of the range given. Optionally choose to\n     * also store this shape's zLow and zHigh members from the range through the use of a RangePlaneBitMask.\n     */\n    static createBlock(extremities, clipMask, isMask = false, invisible = false, transform, result) {\n        const low = extremities.low;\n        const high = extremities.high;\n        const blockPoints = [];\n        for (let i = 0; i < 5; i++)\n            blockPoints.push(Point3d.create());\n        blockPoints[0].x = blockPoints[3].x = blockPoints[4].x = low.x;\n        blockPoints[1].x = blockPoints[2].x = high.x;\n        blockPoints[0].y = blockPoints[1].y = blockPoints[4].y = low.y;\n        blockPoints[2].y = blockPoints[3].y = high.y;\n        return ClipShape.createShape(blockPoints, (ClipMaskXYZRangePlanes.None !== (clipMask & ClipMaskXYZRangePlanes.ZLow)) ? low.z : undefined, (ClipMaskXYZRangePlanes.None !== (clipMask & ClipMaskXYZRangePlanes.ZHigh)) ? high.z : undefined, transform, isMask, invisible, result);\n    }\n    /** Creates a new ClipShape with undefined members and a polygon points array of zero length. */\n    static createEmpty(isMask = false, invisible = false, transform, result) {\n        if (result) {\n            result._clipPlanes = undefined;\n            result._invisible = invisible;\n            result._polygon.length = 0;\n            result.initSecondaryProps(isMask, undefined, undefined, transform);\n            return result;\n        }\n        return new ClipShape([], undefined, undefined, transform, isMask, invisible);\n    }\n    /** Checks to ensure that the member polygon has an area, and that the polygon is closed. */\n    get isValidPolygon() {\n        if (this._polygon.length < 3)\n            return false;\n        if (!this._polygon[0].isExactEqual(this._polygon[this._polygon.length - 1]))\n            return false;\n        return true;\n    }\n    /** Returns a deep copy of this instance of ClipShape, storing in an optional result. */\n    clone(result) {\n        return ClipShape.createFrom(this, result);\n    }\n    /**\n     * Given the current polygon data, parses clip planes that together form an object, storing the result in\n     * the set given, either clip planes or mask planes.\n     */\n    parseClipPlanes(set) {\n        const points = this._polygon;\n        if (points.length === 3 && !this._isMask && points[0].isExactEqual(points[points.length - 1])) {\n            this.parseLinearPlanes(set, this._polygon[0], this._polygon[1]);\n            return true;\n        }\n        if (!this.isMask) {\n            const direction = PolygonOps.testXYPolygonTurningDirections(this.polygon);\n            if (direction !== 0) {\n                this.parseConvexPolygonPlanes(set, this._polygon, direction, false);\n                return true;\n            }\n        }\n        // REMARK:  Pass all polygons to non-convex case.  It will funnel\n        // to concave case as appropriate.\n        this.parsePolygonPlanes(set, this._polygon, this.isMask);\n        return true;\n    }\n    /**\n     * Given a start and end point, populate the given UnionOfConvexClipPlaneSets with ConvexClipPlaneSets\n     * defining the bounded region of linear planes. Returns true if successful.\n     */\n    parseLinearPlanes(set, start, end, cameraFocalLength) {\n        // Handles the degenerate case of 2 distinct points (used by select by line).\n        const normal = start.vectorTo(end);\n        if (normal.magnitude() === 0.0)\n            return false;\n        normal.normalize(normal);\n        const convexSet = ConvexClipPlaneSet.createEmpty();\n        if (cameraFocalLength === undefined) {\n            const perpendicular = Vector2d.create(-normal.y, normal.x);\n            convexSet.planes.push(ClipPlane.createNormalAndPoint(Vector3d.create(normal.x, normal.y), Point3d.createFrom(start), this._invisible));\n            convexSet.planes.push(ClipPlane.createNormalAndPoint(Vector3d.create(-normal.x, -normal.y), Point3d.createFrom(end), this._invisible));\n            convexSet.planes.push(ClipPlane.createNormalAndPoint(Vector3d.create(perpendicular.x, perpendicular.y), Point3d.createFrom(start), this._invisible));\n            convexSet.planes.push(ClipPlane.createNormalAndPoint(Vector3d.create(-perpendicular.x, -perpendicular.y), Point3d.createFrom(start), this._invisible));\n        }\n        else {\n            const start3d = Point3d.create(start.x, start.y, -cameraFocalLength);\n            const end3d = Point3d.create(end.x, end.y, -cameraFocalLength);\n            const vecEnd3d = Vector3d.createFrom(end3d);\n            const perpendicular = vecEnd3d.crossProduct(Vector3d.createFrom(start3d)).normalize();\n            let endNormal = Vector3d.createFrom(start3d).crossProduct(perpendicular).normalize();\n            convexSet.planes.push(ClipPlane.createNormalAndDistance(perpendicular, 0.0, this._invisible));\n            convexSet.planes.push(ClipPlane.createNormalAndDistance(endNormal, 0.0, this._invisible));\n            perpendicular.negate();\n            endNormal = vecEnd3d.crossProduct(perpendicular).normalize();\n            convexSet.planes.push(ClipPlane.createNormalAndDistance(perpendicular, 0.0, this._invisible));\n            convexSet.planes.push(ClipPlane.createNormalAndDistance(endNormal, 0.0, this._invisible));\n        }\n        convexSet.addZClipPlanes(this._invisible, this._zLow, this._zHigh);\n        set.addConvexSet(convexSet);\n        return true;\n    }\n    /**\n     * Given a convex polygon defined as an array of points, populate the given UnionOfConvexClipPlaneSets with\n     * ConvexClipPlaneSets defining the bounded region. Returns true if successful.\n     */\n    parseConvexPolygonPlanes(set, polygon, direction, buildExteriorClipper, cameraFocalLength) {\n        const samePointTolerance = 1.0e-8; // This could possibly be replaced with more widely used constants\n        const edges = [];\n        //  const reverse = (direction < 0) !== this._isMask;\n        const reverse = direction < 0;\n        for (let i = 0; i < polygon.length - 1; i++) {\n            const z = (cameraFocalLength === undefined) ? 0.0 : -cameraFocalLength;\n            const dir = Vector3d.createStartEnd(polygon[i], polygon[i + 1]);\n            const magnitude = dir.magnitude();\n            dir.normalize(dir);\n            if (magnitude > samePointTolerance) {\n                const normal = Vector3d.create(reverse ? dir.y : -dir.y, reverse ? -dir.x : dir.x);\n                edges.push(new PolyEdge(polygon[i], polygon[i + 1], normal, z));\n            }\n        }\n        if (edges.length < 3) {\n            return false;\n        }\n        if (buildExteriorClipper) {\n            const last = edges.length - 1;\n            for (let i = 0; i <= last; i++) {\n                const edge = edges[i];\n                const prevEdge = edges[i ? (i - 1) : last];\n                const nextEdge = edges[(i === last) ? 0 : (i + 1)];\n                const convexSet = ConvexClipPlaneSet.createEmpty();\n                const previousPerpendicular = PolyEdge.makeUnitPerpendicularToBisector(prevEdge, edge, !reverse);\n                const nextPerpendicular = PolyEdge.makeUnitPerpendicularToBisector(edge, nextEdge, reverse);\n                // Create three-sided fans from each edge.   Note we could define the correct region\n                // with only two planes for edge, but cannot then designate the \"interior\" status of the edges accurately.\n                if (previousPerpendicular)\n                    convexSet.planes.push(ClipPlane.createNormalAndPoint(previousPerpendicular, edge.pointA, this._invisible, true));\n                convexSet.planes.push(ClipPlane.createNormalAndPoint(edge.normal, edge.pointB, this._invisible, false));\n                if (nextPerpendicular)\n                    convexSet.planes.push(ClipPlane.createNormalAndPoint(nextPerpendicular, nextEdge.pointA, this._invisible, true));\n                set.addConvexSet(convexSet);\n                set.addOutsideZClipSets(this._invisible, this._zLow, this._zHigh);\n            }\n        }\n        else {\n            const convexSet = ConvexClipPlaneSet.createEmpty();\n            if (cameraFocalLength === undefined) {\n                for (const edge of edges)\n                    convexSet.planes.push(ClipPlane.createNormalAndPoint(Vector3d.create(edge.normal.x, edge.normal.y), edge.pointA));\n            }\n            else {\n                if (reverse)\n                    for (const edge of edges)\n                        convexSet.planes.push(ClipPlane.createNormalAndDistance(Vector3d.createFrom(edge.pointA).crossProduct(Vector3d.createFrom(edge.pointB)).normalize(), 0.0));\n                else\n                    for (const edge of edges)\n                        convexSet.planes.push(ClipPlane.createNormalAndDistance(Vector3d.createFrom(edge.pointB).crossProduct(Vector3d.createFrom(edge.pointA)).normalize(), 0.0));\n            }\n            convexSet.addZClipPlanes(this._invisible, this._zLow, this._zHigh);\n            set.addConvexSet(convexSet);\n        }\n        return true;\n    }\n    /**\n     * Given a (possibly non-convex) polygon defined as an array of points, populate the given UnionOfConvexClipPlaneSets\n     * with multiple ConvexClipPlaneSets defining the bounded region. Returns true if successful.\n     */\n    parsePolygonPlanes(set, polygon, isMask, cameraFocalLength) {\n        const cleanPolygon = PolylineOps.compressDanglers(polygon, true);\n        const announceFace = (_graph, edge) => {\n            if (!edge.isMaskSet(HalfEdgeMask.EXTERIOR)) {\n                const convexFacetPoints = edge.collectAroundFace((node) => {\n                    if (!node.isMaskSet(HalfEdgeMask.EXTERIOR))\n                        return Point3d.create(node.x, node.y, 0);\n                });\n                // parseConvexPolygonPlanes expects a closed loop (pushing the reference doesn't matter)\n                convexFacetPoints.push(convexFacetPoints[0].clone());\n                const direction = PolygonOps.testXYPolygonTurningDirections(convexFacetPoints); // ###TODO: Can we expect a direction coming out of graph facet?\n                this.parseConvexPolygonPlanes(set, convexFacetPoints, direction, false, cameraFocalLength);\n            }\n            return true;\n        };\n        if (isMask) {\n            const polygonA = Point3dArray.clonePoint3dArray(cleanPolygon);\n            const hullAndInlets = AlternatingCCTreeNode.createHullAndInletsForPolygon(polygonA);\n            const allLoops = hullAndInlets.extractLoops();\n            if (allLoops.length === 0)\n                return false;\n            const hull = allLoops[0];\n            const direction1 = PolygonOps.testXYPolygonTurningDirections(hull); // ###TODO: Can we expect a direction coming out of graph facet?\n            this.parseConvexPolygonPlanes(set, hull, -direction1, true, cameraFocalLength);\n            for (let i = 1; i < allLoops.length; i++) {\n                const triangulatedPolygon = Triangulator.createTriangulatedGraphFromSingleLoop(allLoops[i]);\n                if (triangulatedPolygon) {\n                    Triangulator.flipTriangles(triangulatedPolygon);\n                    triangulatedPolygon.announceFaceLoops(announceFace);\n                }\n            }\n            return true;\n        }\n        else {\n            const triangulatedPolygon = Triangulator.createTriangulatedGraphFromSingleLoop(cleanPolygon);\n            if (triangulatedPolygon === undefined)\n                return false;\n            Triangulator.flipTriangles(triangulatedPolygon);\n            triangulatedPolygon.announceFaceLoops(announceFace);\n        }\n        return true;\n    }\n    /**\n     * Multiply all ClipPlanes DPoint4d by matrix.\n     * @param matrix matrix to apply.\n     * @param invert if true, use in verse of the matrix.\n     * @param transpose if true, use the transpose of the matrix (or inverse, per invert parameter).\n     * @param matrix matrix to apply.\n     * * Note that if matrixA is applied to all of space, the matrix to send to this method to get a corresponding effect\n     * on the plane is the inverse transpose of matrixA.\n     * * Callers that will apply the same matrix to many planes should pre-invert the matrix for efficiency.\n     * * Both params default to true to get the full effect of transforming space.\n     */\n    multiplyPlanesByMatrix4d(matrix, invert = true, transpose = true) {\n        this.ensurePlaneSets();\n        return super.multiplyPlanesByMatrix4d(matrix, invert, transpose);\n    }\n    /**\n     * Apply `transform` to the local to world (`transformFromClip`) transform.\n     * * The world to local transform (`transformToClip` is recomputed from the (changed) `transformToClip`\n     * * the transform is passed to the base class to be applied to clip plane form of the clipper.\n     */\n    transformInPlace(transform) {\n        if (transform.isIdentity)\n            return true;\n        super.transformInPlace(transform);\n        if (this._transformFromClip)\n            transform.multiplyTransformTransform(this._transformFromClip, this._transformFromClip);\n        else\n            this._transformFromClip = transform.clone();\n        this._transformToClip = this._transformFromClip.inverse(); // could be undefined\n        return true;\n    }\n    /**\n     * Return true if\n     * * at least one point is defined\n     * * The local to world transform (transformFromClip) either\n     *   * is undefined\n     *   * has no xy parts in its column Z (local frame Z is parallel to global Z)\n     */\n    get isXYPolygon() {\n        if (this._polygon.length === 0) // Note: This is a lenient check, as points array could also contain less than 3 points (not a polygon)\n            return false;\n        if (this._transformFromClip === undefined)\n            return true;\n        const zVector = this._transformFromClip.matrix.columnZ();\n        return zVector.magnitudeXY() < 1.0e-8;\n    }\n    /** Transform the input point in place using this instance's `transformToClip` member */\n    performTransformToClip(point) {\n        if (this._transformToClip !== undefined)\n            this._transformToClip.multiplyPoint3d(point, point);\n    }\n    /** Transform the input point in place using this instance's `transformFromClip` member */\n    performTransformFromClip(point) {\n        if (this._transformFromClip !== undefined)\n            this._transformFromClip.multiplyPoint3d(point, point);\n    }\n}\n//# sourceMappingURL=ClipPrimitive.js.map",
      "start": 1693508123347,
      "end": 1693508123520,
      "sourcemaps": null
    }
  ]
}
