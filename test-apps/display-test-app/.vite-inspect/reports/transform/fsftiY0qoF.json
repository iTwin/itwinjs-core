{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/glsl/Translucency.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { addEyeSpace, addFrustum } from \"./Common\";\nimport { computeLinearDepth } from \"./Fragment\";\nimport { addModelViewMatrix } from \"./Vertex\";\n// See Weighted Blended Order-Independent Transparency for examples of different weighting functions:\n// http://jcgt.org/published/0002/02/09/\n// We are using Equation 10 from the above paper.  Equation 10 directly uses screen-space gl_FragCoord.z.\n// flatAlphaWeight bit is set if we want to apply OIT transparency using a constant Z value of 1.\n// computeLinearDepth() removes the perspective and puts z in linear [0..1]\n// To avoid excessively low weight for fragments close to the far plane, scale depth to [0.15, 1.0].\nconst computeAlphaWeight = `\r\nfloat computeAlphaWeight(float a) {\r\n  float d = computeLinearDepth(v_eyeSpace.z) * .85 + .15;\r\n  float z = (u_shaderFlags[kShaderBit_OITFlatAlphaWeight] ? 1.0 : d);\r\n  return pow(a + 0.01, 4.0) + max(1e-2, 3.0 * 1e3 * pow(z, 3.0));\r\n}\r\n`;\n// NB: Our blending algorithm uses pre-multiplied alpha\nconst computeOutputs = `\r\n  vec3 Ci = baseColor.rgb * baseColor.a;\r\n  float ai = min(0.99, baseColor.a); // OIT algorithm does not nicely handle a=1\r\n  float wzi = computeAlphaWeight(ai);\r\n\r\n  // If we are scaling output into the 0 to 1 range, we use the maximum output of the alpha weight function.\r\n  float outputScale = (u_shaderFlags[kShaderBit_OITScaleOutput] ? 1.0 / 3001.040604 : 1.0);\r\n\r\n  vec4 output0 = vec4(Ci * wzi * outputScale, ai);\r\n  vec4 output1 = vec4(ai * wzi * outputScale);\r\n`;\nconst assignFragData = `${computeOutputs}\r\n  FragColor0 = output0;\r\n  FragColor1 = output1;\r\n`;\n/** @internal */\nexport function addTranslucency(prog) {\n    const frag = prog.frag;\n    addEyeSpace(prog);\n    addFrustum(prog);\n    addModelViewMatrix(prog.vert);\n    frag.addFunction(computeLinearDepth);\n    frag.addFunction(computeAlphaWeight);\n    frag.addDrawBuffersExtension(2);\n    frag.set(16 /* FragmentShaderComponent.AssignFragData */, assignFragData);\n}\n//# sourceMappingURL=Translucency.js.map",
      "start": 1693508125937,
      "end": 1693508126075,
      "sourcemaps": null
    }
  ]
}
