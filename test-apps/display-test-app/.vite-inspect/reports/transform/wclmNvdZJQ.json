{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/common/lib/esm/RenderSchedule.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module DisplayStyles\n */\nimport { assert, compareBooleans, compareNumbers, comparePossiblyUndefined, compareStrings, compareStringsOrUndefined, CompressedId64Set, Id64, OrderedId64Iterable, } from \"@itwin/core-bentley\";\nimport { ClipPlane, ClipPrimitive, ClipVector, ConvexClipPlaneSet, Matrix3d, Plane3dByOriginAndUnitNormal, Point3d, Point4d, Range1d, Transform, UnionOfConvexClipPlaneSets, Vector3d, } from \"@itwin/core-geometry\";\nimport { RgbColor } from \"./RgbColor\";\nimport { FeatureAppearance } from \"./FeatureSymbology\";\nfunction interpolate(start, end, fraction) {\n    return start + fraction * (end - start);\n}\nfunction interpolateRgb(start, end, fraction) {\n    return new RgbColor(interpolate(start.r, end.r, fraction), interpolate(start.g, end.g, fraction), interpolate(start.b, end.b, fraction));\n}\nfunction compareXYZ(lhs, rhs) {\n    return compareNumbers(lhs.x, rhs.x) || compareNumbers(lhs.y, rhs.y) || compareNumbers(lhs.z, rhs.z);\n}\nfunction compare4d(lhs, rhs) {\n    return compareNumbers(lhs.x, rhs.x) || compareNumbers(lhs.y, rhs.y) || compareNumbers(lhs.z, rhs.z) || compareNumbers(lhs.w, rhs.w);\n}\nconst scratchVec3a = new Vector3d();\nconst scratchVec3b = new Vector3d();\nfunction compareMatrices(lhs, rhs) {\n    return compareXYZ(lhs.columnX(scratchVec3a), rhs.columnX(scratchVec3b))\n        || compareXYZ(lhs.columnY(scratchVec3a), rhs.columnY(scratchVec3b))\n        || compareXYZ(lhs.columnZ(scratchVec3a), rhs.columnZ(scratchVec3b));\n}\nfunction compareDurations(lhs, rhs) {\n    return compareNumbers(lhs.low, rhs.low) || compareNumbers(lhs.high, rhs.high);\n}\n/** Namespace containing types that collectively define a script that animates the contents of a view by adjusting the visibility, position,\n * and/or symbology of groups of elements over time. A [[RenderSchedule.Script]] is hosted by a [RenderTimeline]($backend) element. The script\n * can be associated with a [DisplayStyleState]($frontend) by way of its [[DisplayStyleSettings.renderTimeline]] property.\n * @public\n */\nexport var RenderSchedule;\n(function (RenderSchedule) {\n    /** Defines how two interpolate between two entries in a [[RenderSchedule.Timeline]].\n     * @note Currently only Linear and Step are supported. Any other value is treated as Step.\n     * @see [[RenderSchedule.TimelineEntry]].\n     */\n    let Interpolation;\n    (function (Interpolation) {\n        /** Each timeline entry's value is discrete - the timeline jumps from one entry's value directly to another. */\n        Interpolation[Interpolation[\"Step\"] = 1] = \"Step\";\n        /** Given two entries on the timeline and a timepoint in between them, linearly interpolate based on the timepoint's distance between the\n         * two entries.\n         */\n        Interpolation[Interpolation[\"Linear\"] = 2] = \"Linear\";\n    })(Interpolation = RenderSchedule.Interpolation || (RenderSchedule.Interpolation = {}));\n    /** Describes the value of some property at a specific point along a [[RenderSchedule.Timeline]].\n     * @see [[RenderSchedule.VisibilityEntry]]\n     * @see [[RenderSchedule.ColorEntry]]\n     * @see [[RenderSchedule.TransformEntry]]\n     * @see [[RenderSchedule.CuttingPlaneEntry]]\n     */\n    class TimelineEntry {\n        constructor(props) {\n            this.time = props.time;\n            this.interpolation = props.interpolation === Interpolation.Linear ? props.interpolation : Interpolation.Step;\n        }\n        toJSON() {\n            const props = {\n                time: this.time,\n            };\n            if (this.interpolation === Interpolation.Linear)\n                props.interpolation = this.interpolation;\n            return props;\n        }\n        compareTo(other) {\n            return compareNumbers(this.interpolation, other.interpolation) || compareNumbers(this.time, other.time);\n        }\n        equals(other) {\n            return 0 === this.compareTo(other);\n        }\n    }\n    RenderSchedule.TimelineEntry = TimelineEntry;\n    /** A timeline entry that controls the visibility of the associated geometry. */\n    class VisibilityEntry extends TimelineEntry {\n        constructor(props) {\n            super(props);\n            if (typeof props.value !== \"number\")\n                this.value = 100;\n            else\n                this.value = Math.max(0, Math.min(100, props.value));\n        }\n        toJSON() {\n            const props = super.toJSON();\n            if (100 !== this.value)\n                props.value = this.value;\n            return props;\n        }\n        compareTo(other) {\n            assert(other instanceof VisibilityEntry);\n            return super.compareTo(other) || compareNumbers(this.value, other.value);\n        }\n    }\n    RenderSchedule.VisibilityEntry = VisibilityEntry;\n    /** A timeline entry controlling the color of the affected geometry. */\n    class ColorEntry extends TimelineEntry {\n        constructor(props) {\n            super(props);\n            if (props.value)\n                this.value = new RgbColor(props.value.red, props.value.green, props.value.blue);\n        }\n        toJSON() {\n            const props = super.toJSON();\n            if (this.value) {\n                props.value = {\n                    red: this.value.r,\n                    green: this.value.g,\n                    blue: this.value.b,\n                };\n            }\n            return props;\n        }\n        compareTo(other) {\n            assert(other instanceof ColorEntry);\n            return super.compareTo(other) || comparePossiblyUndefined((lhs, rhs) => lhs.compareTo(rhs), this.value, other.value);\n        }\n    }\n    RenderSchedule.ColorEntry = ColorEntry;\n    /** Describes the components of a [[RenderSchedule.TransformEntry]] as a rotation around a pivot point followed by a translation. */\n    class TransformComponents {\n        constructor(position, pivot, orientation) {\n            this.position = position;\n            this.pivot = pivot;\n            this.orientation = orientation;\n        }\n        static fromJSON(props) {\n            if (props.pivot && props.position && props.orientation)\n                return new TransformComponents(Vector3d.fromJSON(props.position), Vector3d.fromJSON(props.pivot), Point4d.fromJSON(props.orientation));\n            else\n                return undefined;\n        }\n        toJSON() {\n            return {\n                position: [this.position.x, this.position.y, this.position.z],\n                pivot: [this.pivot.x, this.pivot.y, this.pivot.z],\n                orientation: [this.orientation.x, this.orientation.y, this.orientation.z, this.orientation.w],\n            };\n        }\n        compareTo(other) {\n            return compareXYZ(this.pivot, other.pivot) || compareXYZ(this.position, other.position) || compare4d(this.orientation, other.orientation);\n        }\n        equals(other) {\n            return this.pivot.isAlmostEqual(other.pivot) && this.position.isAlmostEqual(other.position) && this.orientation.isAlmostEqual(other.orientation);\n        }\n    }\n    RenderSchedule.TransformComponents = TransformComponents;\n    /** A timeline entry that applies rotation, scaling, and/or translation to the affected geometry. */\n    class TransformEntry extends TimelineEntry {\n        constructor(props) {\n            super(props);\n            this.value = props.value ? Transform.fromJSON(props.value.transform) : Transform.identity;\n            if (props.value)\n                this.components = TransformComponents.fromJSON(props.value);\n        }\n        toJSON() {\n            const props = super.toJSON();\n            if (this.components) {\n                props.value = this.components.toJSON();\n                props.value.transform = this.value.toRows();\n            }\n            else {\n                props.value = { transform: this.value.toRows() };\n            }\n            return props;\n        }\n        compareTo(other) {\n            assert(other instanceof TransformEntry);\n            const cmp = super.compareTo(other);\n            if (0 !== cmp)\n                return cmp;\n            if (this.components || other.components) {\n                if (!this.components || !other.components)\n                    return this.components ? 1 : -1;\n                return this.components.compareTo(other.components);\n            }\n            return compareXYZ(this.value.origin, other.value.origin) || compareMatrices(this.value.matrix, other.value.matrix);\n        }\n    }\n    RenderSchedule.TransformEntry = TransformEntry;\n    /** Defines a [ClipPlane]($core-geometry) associated with a [[RenderSchedule.CuttingPlaneEntry]]. */\n    class CuttingPlane {\n        constructor(props) {\n            this.position = Point3d.fromJSON(props.position);\n            this.direction = Point3d.fromJSON(props.direction);\n            this.hidden = true === props.hidden;\n            this.visible = true === props.visible;\n        }\n        toJSON() {\n            const props = {\n                position: [this.position.x, this.position.y, this.position.z],\n                direction: [this.direction.x, this.direction.y, this.direction.z],\n            };\n            if (this.visible)\n                props.visible = true;\n            if (this.hidden)\n                props.hidden = true;\n            return props;\n        }\n        compareTo(other) {\n            return compareXYZ(this.position, other.position) || compareXYZ(this.direction, other.direction) || compareBooleans(this.visible, other.visible) || compareBooleans(this.hidden, other.hidden);\n        }\n        equals(other) {\n            return 0 === this.compareTo(other);\n        }\n    }\n    RenderSchedule.CuttingPlane = CuttingPlane;\n    /** A timeline entry that applies a [ClipPlane]($core-geometry) to the affected geometry. */\n    class CuttingPlaneEntry extends TimelineEntry {\n        constructor(props) {\n            super(props);\n            if (props.value)\n                this.value = new CuttingPlane(props.value);\n        }\n        toJSON() {\n            const props = super.toJSON();\n            if (this.value)\n                props.value = this.value.toJSON();\n            return props;\n        }\n        compareTo(other) {\n            assert(other instanceof CuttingPlaneEntry);\n            return super.compareTo(other) || comparePossiblyUndefined((x, y) => x.compareTo(y), this.value, other.value);\n        }\n    }\n    RenderSchedule.CuttingPlaneEntry = CuttingPlaneEntry;\n    /** Identifies a fractional position along a [[RenderSchedule.Timeline]] between any two [[RenderSchedule.TimelineEntry]]'s within a [[RenderSchedule.TimelineEntryList]].\n     * @internal\n     */\n    class Interval {\n        constructor(lower = 0, upper = 0, fraction = 0) {\n            this.init(lower, upper, fraction);\n        }\n        init(lower = 0, upper = 0, fraction = 0) {\n            this.lowerIndex = lower;\n            this.upperIndex = upper;\n            this.fraction = fraction;\n        }\n    }\n    RenderSchedule.Interval = Interval;\n    /** A list of the [[RenderSchedule.TimelineEntry]] objects within a [[RenderSchedule.Timeline]]. The type parameters are:\n     *  - T, a subclass of TimelineEntry with a `value` property specifying the value of the property controlled by the timeline at that entry's time point.\n     *  - P, the JSON representation from which T is to be constructed.\n     *  - V, the type of `T.value`.\n     */\n    class TimelineEntryList {\n        constructor(props, ctor) {\n            this.duration = Range1d.createNull();\n            this._entries = props.map((x) => {\n                const entry = new ctor(x);\n                this.duration.extendX(entry.time);\n                return entry;\n            });\n        }\n        /** The number of entries in the list. */\n        get length() {\n            return this._entries.length;\n        }\n        /** An iterator over the entries in the list. */\n        [Symbol.iterator]() {\n            return this._entries[Symbol.iterator]();\n        }\n        /** Look up an entry by its position in the list. */\n        getEntry(index) {\n            return this._entries[index];\n        }\n        /** Look up the value of an entry by its position in the list. */\n        getValue(index) {\n            return this.getEntry(index)?.value;\n        }\n        toJSON() {\n            return this._entries.map((x) => x.toJSON());\n        }\n        compareTo(other) {\n            let cmp = compareNumbers(this._entries.length, other._entries.length) || compareDurations(this.duration, other.duration);\n            if (0 === cmp) {\n                for (let i = 0; i < this.length; i++)\n                    if (0 !== (cmp = this._entries[i].compareTo(other._entries[i])))\n                        break;\n            }\n            return cmp;\n        }\n        equals(other) {\n            return 0 === this.compareTo(other);\n        }\n        /** @internal */\n        findInterval(time, interval) {\n            if (this.length === 0)\n                return undefined;\n            interval = interval ?? new Interval();\n            if (time < this._entries[0].time) {\n                interval.init(0, 0, 0);\n                return interval;\n            }\n            const last = this.length - 1;\n            if (time >= this._entries[last].time) {\n                interval.init(last, last, 0);\n                return interval;\n            }\n            for (let i = 0; i < last; i++) {\n                const time0 = this._entries[i].time;\n                const time1 = this._entries[i + 1].time;\n                if (time0 <= time && time1 >= time) {\n                    let fraction;\n                    if (Interpolation.Linear === this._entries[i].interpolation)\n                        fraction = (time - time0) / (time1 - time0);\n                    else\n                        fraction = 0;\n                    interval.init(i, i + 1, fraction);\n                    return interval;\n                }\n            }\n            return undefined;\n        }\n    }\n    RenderSchedule.TimelineEntryList = TimelineEntryList;\n    const scratchInterval = new Interval();\n    /** A list of [[RenderSchedule.VisibilityEntry]]s within a [[RenderSchedule.Timeline]]. */\n    class VisibilityTimelineEntries extends TimelineEntryList {\n        /** Returns the visibility value for the entry at the specified position in the list, or 100 (fully-visible) if no such entry exists. */\n        getValue(index) {\n            return super.getValue(index) ?? 100;\n        }\n    }\n    RenderSchedule.VisibilityTimelineEntries = VisibilityTimelineEntries;\n    /** A list of [[RenderSchedule.TransformEntry]]s within a [[RenderSchedule.Timeline]]. */\n    class TransformTimelineEntries extends TimelineEntryList {\n        /** Returns the transform for the entry at the specified position in the list, or an identity transform if no such entry exists. */\n        getValue(index) {\n            return super.getValue(index) ?? Transform.identity;\n        }\n    }\n    RenderSchedule.TransformTimelineEntries = TransformTimelineEntries;\n    /** Specifies how to animate a set of geometry over time within a [[RenderSchedule.Script]].\n     * A [[RenderSchedule.Script]] can contain any number of [[RenderSchedule.Timeline]]s, each affecting different sets of geometry.\n     * @see [[RenderSchedule.ElementTimeline]] and [[RenderSchedule.ModelTimeline]].\n     */\n    class Timeline {\n        constructor(props) {\n            this.duration = Range1d.createNull();\n            if (props.visibilityTimeline) {\n                this.visibility = new VisibilityTimelineEntries(props.visibilityTimeline, VisibilityEntry);\n                this.duration.extendRange(this.visibility.duration);\n            }\n            if (props.colorTimeline) {\n                this.color = new TimelineEntryList(props.colorTimeline, ColorEntry);\n                this.duration.extendRange(this.color.duration);\n            }\n            if (props.transformTimeline) {\n                this.transform = new TransformTimelineEntries(props.transformTimeline, TransformEntry);\n                this.duration.extendRange(this.transform.duration);\n            }\n            if (props.cuttingPlaneTimeline) {\n                this.cuttingPlane = new TimelineEntryList(props.cuttingPlaneTimeline, CuttingPlaneEntry);\n                this.duration.extendRange(this.cuttingPlane.duration);\n            }\n        }\n        toJSON() {\n            return {\n                visibilityTimeline: this.visibility?.toJSON(),\n                colorTimeline: this.color?.toJSON(),\n                transformTimeline: this.transform?.toJSON(),\n                cuttingPlaneTimeline: this.cuttingPlane?.toJSON(),\n            };\n        }\n        compareTo(other) {\n            const cmp = compareDurations(this.duration, other.duration);\n            if (0 !== cmp)\n                return cmp;\n            // Do cheaper checks before iterating through timeline entries\n            if (!!this.visibility !== !!other.visibility)\n                return this.visibility ? 1 : -1;\n            else if (!!this.color !== !!other.color)\n                return this.color ? 1 : -1;\n            else if (!!this.transform !== !!other.transform)\n                return this.transform ? 1 : -1;\n            else if (!!this.cuttingPlane !== !!other.cuttingPlane)\n                return this.cuttingPlane ? 1 : -1;\n            return comparePossiblyUndefined((x, y) => x.compareTo(y), this.visibility, other.visibility) || comparePossiblyUndefined((x, y) => x.compareTo(y), this.color, other.color)\n                || comparePossiblyUndefined((x, y) => x.compareTo(y), this.transform, other.transform) || comparePossiblyUndefined((x, y) => x.compareTo(y), this.cuttingPlane, other.cuttingPlane);\n        }\n        equals(other) {\n            return 0 === this.compareTo(other);\n        }\n        /** Get the visibility of the geometry at the specified time point. */\n        getVisibility(time) {\n            let interval;\n            if (!this.visibility || !(interval = this.visibility.findInterval(time, scratchInterval)))\n                return 100;\n            let visibility = this.visibility.getValue(interval.lowerIndex) ?? 100;\n            if (interval.fraction > 0)\n                visibility = interpolate(visibility, this.visibility.getValue(interval.upperIndex) ?? 100, interval.fraction);\n            return visibility;\n        }\n        /** Get the color of the geometry at the specified time point, or undefined if the color is not overridden at that time point. */\n        getColor(time) {\n            let interval;\n            if (!this.color || !(interval = this.color.findInterval(time, scratchInterval)))\n                return undefined;\n            const start = this.color.getValue(interval.lowerIndex);\n            if (start && interval.fraction > 0) {\n                const end = this.color.getValue(interval.upperIndex);\n                if (end)\n                    return interpolateRgb(start, end, interval.fraction);\n            }\n            return start;\n        }\n        /** Get the transform applied to the geometry at the specified time point. */\n        getAnimationTransform(time) {\n            let interval;\n            if (!this.transform || !(interval = this.transform.findInterval(time, scratchInterval)))\n                return Transform.identity;\n            let transform = this.transform.getValue(interval.lowerIndex);\n            if (interval.fraction > 0) {\n                const comp0 = this.transform.getEntry(interval.lowerIndex)?.components;\n                const comp1 = this.transform.getEntry(interval.upperIndex)?.components;\n                if (comp0 && comp1) {\n                    const sum = Point4d.interpolateQuaternions(comp0.orientation, interval.fraction, comp1.orientation);\n                    const matrix = Matrix3d.createFromQuaternion(sum);\n                    const pre = Transform.createTranslation(comp0.pivot);\n                    const post = Transform.createTranslation(comp0.position.interpolate(interval.fraction, comp1.position));\n                    const product = post.multiplyTransformMatrix3d(matrix);\n                    product.multiplyTransformTransform(pre, product);\n                    transform = product;\n                }\n                else {\n                    const end = this.transform.getValue(interval.upperIndex);\n                    const q0 = transform.matrix.inverse()?.toQuaternion();\n                    const q1 = end.matrix.inverse()?.toQuaternion();\n                    if (q0 && q1) {\n                        const sum = Point4d.interpolateQuaternions(q0, interval.fraction, q1);\n                        const matrix = Matrix3d.createFromQuaternion(sum);\n                        const origin0 = Vector3d.createFrom(transform.origin);\n                        const origin1 = Vector3d.createFrom(end.origin);\n                        transform = Transform.createRefs(origin0.interpolate(interval.fraction, origin1), matrix);\n                    }\n                }\n            }\n            return transform;\n        }\n        /** Get the clipping plane applied to the geometry at the specified time point, or undefined if the geometry is unclipped at that time point. */\n        getCuttingPlane(time) {\n            let interval;\n            if (!this.cuttingPlane || !(interval = this.cuttingPlane.findInterval(time, scratchInterval)))\n                return undefined;\n            const start = this.cuttingPlane.getValue(interval.lowerIndex);\n            if (!start)\n                return undefined;\n            const position = Point3d.createFrom(start.position);\n            const direction = Vector3d.createFrom(start.direction);\n            const end = interval.fraction > 0 ? this.cuttingPlane.getValue(interval.upperIndex) : undefined;\n            if (end) {\n                position.interpolate(interval.fraction, end.position, position);\n                direction.interpolate(interval.fraction, end.direction, direction);\n            }\n            else {\n                if (start.hidden || start.visible)\n                    return undefined;\n            }\n            direction.negate(direction);\n            direction.normalizeInPlace();\n            return Plane3dByOriginAndUnitNormal.create(position, direction);\n        }\n        /** Create a ClipVector from the [[RenderSchedule.CuttingPlane]] applied to the geometry at the specified time point, if any. */\n        getClipVector(time) {\n            const plane = this.getCuttingPlane(time);\n            if (!plane)\n                return undefined;\n            const cp = ClipPlane.createPlane(plane);\n            const cps = UnionOfConvexClipPlaneSets.createConvexSets([ConvexClipPlaneSet.createPlanes([cp])]);\n            const prim = ClipPrimitive.createCapture(cps);\n            return ClipVector.createCapture([prim]);\n        }\n        /** @internal */\n        getFeatureAppearance(visibility, time) {\n            const transparency = visibility < 100 ? (1 - visibility / 100) : undefined;\n            const rgb = this.getColor(time);\n            return undefined !== rgb || undefined !== transparency ? FeatureAppearance.fromJSON({ rgb, transparency }) : undefined;\n        }\n    }\n    RenderSchedule.Timeline = Timeline;\n    /** Specifies how to animate the geometry belonging to a set of [GeometricElement]($backend)s as part of a [[RenderSchedule.Script]]. */\n    class ElementTimeline extends Timeline {\n        constructor(props) {\n            super(props);\n            this.batchId = props.batchId;\n            this._elementIds = props.elementIds;\n        }\n        static fromJSON(props) {\n            return new ElementTimeline(props ?? { elementIds: [], batchId: 0 });\n        }\n        toJSON() {\n            return {\n                ...super.toJSON(),\n                batchId: this.batchId,\n                elementIds: this._elementIds,\n            };\n        }\n        get containsElementIds() {\n            return this._elementIds.length > 0;\n        }\n        compareElementIds(other) {\n            if (typeof this._elementIds === typeof other._elementIds) {\n                const cmp = compareNumbers(this._elementIds.length, other._elementIds.length);\n                if (0 !== cmp)\n                    return cmp;\n                if (typeof this._elementIds === \"string\") {\n                    assert(typeof other._elementIds === \"string\");\n                    return compareStrings(this._elementIds, other._elementIds);\n                }\n            }\n            // One or both are stored as arrays, in which case they might contain the same Ids in different orders. We will consider them different in that case.\n            const mine = this.elementIds[Symbol.iterator]();\n            const theirs = other.elementIds[Symbol.iterator]();\n            while (true) {\n                const a = mine.next();\n                const b = theirs.next();\n                if (a.done !== b.done)\n                    return compareBooleans(!!a.done, !!b.done);\n                else if (a.done)\n                    return 0;\n                const cmp = compareStrings(a.value, b.value);\n                if (0 !== cmp)\n                    return cmp;\n            }\n        }\n        compareTo(other) {\n            assert(other instanceof ElementTimeline);\n            return compareNumbers(this.batchId, other.batchId) || this.compareElementIds(other) || super.compareTo(other);\n        }\n        /** @internal */\n        static getElementIds(ids) {\n            if (typeof ids === \"string\")\n                return CompressedId64Set.iterable(ids);\n            else if (Array.isArray(ids)) {\n                return ids;\n            }\n            else {\n                return [];\n            }\n        }\n        /** The Ids of the elements controlled by this timeline. */\n        get elementIds() {\n            return ElementTimeline.getElementIds(this._elementIds);\n        }\n        /** True if this timeline affects the color or transparency of the elements. */\n        get containsFeatureOverrides() {\n            return undefined !== this.visibility || undefined !== this.color;\n        }\n        /** If true, applying this timeline requires special tiles to be generated in which groups of elements are batched into nodes.\n         * @internal\n         */\n        get requiresBatching() {\n            if (this.cuttingPlane)\n                return true;\n            return this.batchId !== 0 && (undefined !== this.color || undefined !== this.visibility);\n        }\n        /** True if this timeline affects the position, orientation, or scale of the elements. */\n        get containsTransform() {\n            return undefined !== this.transform;\n        }\n        /** @internal */\n        addSymbologyOverrides(overrides, time) {\n            assert(0 !== this.batchId);\n            const vis = this.getVisibility(time);\n            if (vis <= 0) {\n                overrides.setAnimationNodeNeverDrawn(this.batchId);\n                return;\n            }\n            const appearance = this.getFeatureAppearance(vis, time);\n            if (appearance)\n                overrides.overrideAnimationNode(this.batchId, appearance);\n        }\n    }\n    RenderSchedule.ElementTimeline = ElementTimeline;\n    /** Specifies how to animate the geometry within a [GeometricModel]($backend) as part of a [[RenderSchedule.Script]]. */\n    class ModelTimeline extends Timeline {\n        constructor(props) {\n            super(props);\n            /** Tile tree suppliers perform **very** frequent ordered comparisons of ModelTimelines. They need to be fast. */\n            this._cachedComparisons = new WeakMap();\n            this.modelId = props.modelId;\n            this.realityModelUrl = props.realityModelUrl;\n            this.containsModelClipping = undefined !== this.cuttingPlane;\n            let containsFeatureOverrides = undefined !== this.visibility || undefined !== this.color;\n            let requiresBatching = false;\n            let containsTransform = false;\n            const transformBatchIds = [];\n            const elementTimelines = [];\n            let containsElementIds = false;\n            for (const elProps of props.elementTimelines) {\n                const el = ElementTimeline.fromJSON(elProps);\n                elementTimelines.push(el);\n                this.duration.extendRange(el.duration);\n                if (el.containsTransform) {\n                    containsTransform = true;\n                    if (el.batchId)\n                        transformBatchIds.push(el.batchId);\n                }\n                containsFeatureOverrides ||= el.containsFeatureOverrides;\n                requiresBatching ||= el.requiresBatching;\n                containsElementIds = containsElementIds || el.containsElementIds;\n            }\n            this.elementTimelines = elementTimelines;\n            this.transformBatchIds = transformBatchIds;\n            this.omitsElementIds = elementTimelines.length > 0 && !containsElementIds;\n            this.containsFeatureOverrides = containsFeatureOverrides;\n            this.requiresBatching = requiresBatching;\n            this.containsTransform = containsTransform;\n        }\n        static fromJSON(props) {\n            return new ModelTimeline(props ?? { elementTimelines: [], modelId: Id64.invalid });\n        }\n        toJSON() {\n            return {\n                ...super.toJSON(),\n                modelId: this.modelId,\n                realityModelUrl: this.realityModelUrl,\n                elementTimelines: this.elementTimelines.map((x) => x.toJSON()),\n            };\n        }\n        compareTo(other) {\n            if (this === other)\n                return 0;\n            const cached = this._cachedComparisons.get(other);\n            if (undefined !== cached)\n                return cached;\n            assert(other instanceof ModelTimeline);\n            let cmp = compareStrings(this.modelId, other.modelId) || compareStringsOrUndefined(this.realityModelUrl, other.realityModelUrl)\n                || compareNumbers(this.elementTimelines.length, other.elementTimelines.length) || compareBooleans(this.containsFeatureOverrides, other.containsFeatureOverrides)\n                || compareBooleans(this.containsModelClipping, other.containsModelClipping) || compareBooleans(this.containsTransform, other.containsTransform)\n                || super.compareTo(other);\n            if (0 === cmp) {\n                for (let i = 0; i < this.elementTimelines.length; i++)\n                    if (0 !== (cmp = this.elementTimelines[i].compareTo(other.elementTimelines[i])))\n                        break;\n            }\n            this._cachedComparisons.set(other, cmp);\n            other._cachedComparisons.set(this, -cmp);\n            return cmp;\n        }\n        /** Look up the element timeline with the specified batch Id. */\n        findByBatchId(batchId) {\n            return this.elementTimelines.find((x) => x.batchId === batchId);\n        }\n        /** @internal */\n        addSymbologyOverrides(overrides, time) {\n            const appearance = this.getFeatureAppearance(this.getVisibility(time), time);\n            if (appearance)\n                overrides.override({ modelId: this.modelId, appearance });\n            for (const timeline of this.elementTimelines)\n                timeline.addSymbologyOverrides(overrides, time);\n        }\n        /** Obtain the transform applied to the model at the specified time point, if any. */\n        getTransform(batchId, time) {\n            return this.findByBatchId(batchId)?.getAnimationTransform(time);\n        }\n        /** Get the highest batchId of any ElementTimeline in this timeline. */\n        get maxBatchId() {\n            if (undefined === this._maxBatchId) {\n                this._maxBatchId = 0;\n                for (const elem of this.elementTimelines)\n                    this._maxBatchId = Math.max(this._maxBatchId, elem.batchId);\n            }\n            return this._maxBatchId;\n        }\n        /** Given the two halves of an [Id64]($bentley) return the [[ElementTimeline]] containing the corresponding element.\n         * @note The first call to this method populates a mapping for fast lookup.\n         * @alpha\n         */\n        getTimelineForElement(idLo, idHi) {\n            if (!this._idPairToElementTimeline) {\n                this._idPairToElementTimeline = new Id64.Uint32Map();\n                for (const timeline of this.elementTimelines) {\n                    for (const elementId of timeline.elementIds) {\n                        // NB: a malformed script may place the same element Id into multiple timelines. We're not going to check for such data errors here.\n                        this._idPairToElementTimeline.setById(elementId, timeline);\n                    }\n                }\n            }\n            return this._idPairToElementTimeline.get(idLo, idHi);\n        }\n        /** The batch Ids of the subset of [[elementTimelines]] that apply a transform and/or cutting plane.\n         * @alpha\n         */\n        get discreteBatchIds() {\n            if (!this._discreteBatchIds) {\n                this._discreteBatchIds = new Set(this.transformBatchIds);\n                for (const timeline of this.elementTimelines)\n                    if (!timeline.containsTransform && undefined !== timeline.cuttingPlane)\n                        this._discreteBatchIds.add(timeline.batchId);\n            }\n            return this._discreteBatchIds;\n        }\n        /** @internal see ImdlReader.readAnimationBranches */\n        getBatchIdForFeature(feature) {\n            assert(Id64.fromUint32PairObject(feature.modelId) === this.modelId);\n            const elementTimeline = this.getTimelineForElement(feature.elementId.lower, feature.elementId.upper);\n            return elementTimeline?.batchId ?? 0;\n        }\n    }\n    RenderSchedule.ModelTimeline = ModelTimeline;\n    /** Specifies how to animate the contents of a [ViewState]($frontend) over time. The script contains any number of [[RenderSchedule.ModelTimeline]]s, each describing how\n     * to animate one of the models in the view.\n     * @see [RenderTimeline]($backend) to create an [Element]($backend) to host a script.\n     * @see [[DisplayStyleSettings.renderTimeline]] to associate a [RenderTimeline]($backend)'s script with a [DisplayStyle]($backend).\n     * @see [DisplayStyleState.scheduleScript]($frontend) to obtain the script associated with a display style.\n     * @see [[RenderSchedule.ScriptBuilder]] to define a new script.\n     */\n    class Script {\n        compareTo(other) {\n            if (this === other)\n                return 0;\n            const cached = this._cachedComparisons.get(other);\n            if (undefined !== cached)\n                return cached;\n            let cmp = compareNumbers(this.modelTimelines.length, other.modelTimelines.length) || compareBooleans(this.containsModelClipping, other.containsModelClipping)\n                || compareBooleans(this.requiresBatching, other.requiresBatching) || compareBooleans(this.containsTransform, other.containsTransform)\n                || compareBooleans(this.containsFeatureOverrides, other.containsFeatureOverrides) || compareDurations(this.duration, other.duration);\n            if (0 === cmp) {\n                for (let i = 0; i < this.modelTimelines.length; i++)\n                    if (0 !== (cmp = this.modelTimelines[i].compareTo(other.modelTimelines[i])))\n                        break;\n            }\n            this._cachedComparisons.set(other, cmp);\n            other._cachedComparisons.set(this, -cmp);\n            return cmp;\n        }\n        equals(other) {\n            return 0 === this.compareTo(other);\n        }\n        constructor(props) {\n            /** Tile tree references perform **very** frequent ordered comparisons of Scripts. They need to be fast. */\n            this._cachedComparisons = new WeakMap();\n            this.duration = Range1d.createNull();\n            const transformBatchIds = new Set();\n            const modelTimelines = [];\n            let containsModelClipping = false;\n            let requiresBatching = false;\n            let containsTransform = false;\n            let containsFeatureOverrides = false;\n            for (const modelProps of props) {\n                const model = ModelTimeline.fromJSON(modelProps);\n                modelTimelines.push(model);\n                this.duration.extendRange(model.duration);\n                containsModelClipping ||= model.containsModelClipping;\n                requiresBatching ||= model.requiresBatching;\n                containsTransform ||= model.containsTransform;\n                containsFeatureOverrides ||= model.containsFeatureOverrides;\n                for (const batchId of model.transformBatchIds)\n                    transformBatchIds.add(batchId);\n            }\n            this.modelTimelines = modelTimelines;\n            this.containsModelClipping = containsModelClipping;\n            this.containsTransform = containsTransform;\n            this.requiresBatching = requiresBatching || this.containsTransform;\n            this.containsFeatureOverrides = containsFeatureOverrides;\n            this.transformBatchIds = transformBatchIds;\n        }\n        static fromJSON(props) {\n            if (!Array.isArray(props) || props.length === 0)\n                return undefined;\n            return new Script(props);\n        }\n        toJSON() {\n            return this.modelTimelines.map((x) => x.toJSON());\n        }\n        /** Look up the timeline that animates the specified model, if any. */\n        find(modelId) {\n            return this.modelTimelines.find((x) => x.modelId === modelId);\n        }\n        /** @internal */\n        getTransformBatchIds(modelId) {\n            return this.find(modelId)?.transformBatchIds;\n        }\n        /** @internal */\n        getTransform(modelId, batchId, time) {\n            return this.find(modelId)?.getTransform(batchId, time);\n        }\n        /** @internal */\n        addSymbologyOverrides(overrides, time) {\n            for (const timeline of this.modelTimelines)\n                timeline.addSymbologyOverrides(overrides, time);\n        }\n        /** Used by the [Entity.collectReferenceIds]($backend) method overrides in RenderTimeline and DisplayStyle.\n         * @internal\n         */\n        discloseIds(ids) {\n            for (const model of this.modelTimelines) {\n                ids.addModel(model.modelId);\n                for (const element of model.elementTimelines)\n                    for (const id of element.elementIds)\n                        ids.addElement(id);\n            }\n        }\n        /** @internal */\n        modelRequiresBatching(modelId) {\n            // Only if the script contains animation (cutting plane, transform or visibility by node ID) do we require separate tilesets for animations.\n            return this.requiresBatching && this.modelTimelines.some((x) => x.modelId === modelId && x.requiresBatching);\n        }\n        /** The batch Ids of the subset of [[elementTimelines]] that apply a transform and/or cutting plane.\n         * @alpha\n         */\n        get discreteBatchIds() {\n            if (this._discreteBatchIds)\n                return this._discreteBatchIds;\n            this._discreteBatchIds = new Set();\n            for (const timeline of this.modelTimelines)\n                for (const batchId of timeline.discreteBatchIds)\n                    this._discreteBatchIds.add(batchId);\n            return this._discreteBatchIds;\n        }\n        /** @internal see ImdlReader.readAnimationBranches. */\n        getBatchIdForFeature(feature) {\n            let timeline;\n            const prev = this._lastFeatureModelTimeline;\n            if (prev && prev.idLower === feature.modelId.lower && prev.idUpper === feature.modelId.upper) {\n                timeline = prev.timeline;\n            }\n            else {\n                const modelId = Id64.fromUint32PairObject(feature.modelId);\n                timeline = this.find(modelId);\n                this._lastFeatureModelTimeline = { timeline, idLower: feature.modelId.lower, idUpper: feature.modelId.upper };\n            }\n            return timeline?.getBatchIdForFeature(feature) ?? 0;\n        }\n        /** @alpha */\n        get maxBatchId() {\n            return this._maxBatchId ?? (this._maxBatchId = this.modelTimelines.reduce((accum, timeline) => Math.max(accum, timeline.maxBatchId), 0));\n        }\n    }\n    RenderSchedule.Script = Script;\n    /** A reference to a [[RenderSchedule.Script]], optionally identifying the source of the script.\n     * @see [DisplayStyle.loadScheduleScript]($backend) and [DisplayStyleState.scheduleScript]($frontend) to obtain the script reference for a display style on the frontend\n     * and backend respectively.\n     * @see [DisplayStyleState.scheduleScript]($frontend) or [DisplayStyleState.changeRenderTimeline]($frontend) to change a display style's script on the frontend.\n     */\n    class ScriptReference {\n        /** @internal Use one of the public constructor overloads which forward to this one. */\n        constructor(sourceIdOrScript, scriptIfSourceId) {\n            if (typeof sourceIdOrScript === \"string\") {\n                assert(scriptIfSourceId instanceof Script);\n                this.sourceId = sourceIdOrScript;\n                this.script = scriptIfSourceId;\n            }\n            else {\n                assert(undefined === scriptIfSourceId);\n                this.script = sourceIdOrScript;\n                this.sourceId = Id64.invalid;\n            }\n        }\n    }\n    RenderSchedule.ScriptReference = ScriptReference;\n    /** Used as part of a [[RenderSchedule.ScriptBuilder]] to define a [[RenderSchedule.Timeline]]. Functions that append\n     * to the timeline expect entries to be appended in chronological order - i.e., you cannot append an entry that is earlier\n     * than a previously appended entry.\n     * @see [[RenderSchedule.ElementTimelineBuilder]] and [[RenderSchedule.ModelTimelineBuilder]].\n     */\n    class TimelineBuilder {\n        /** Append a new [[RenderSchedule.VisibilityEntry]] to the timeline. `time` must be more recent than any previously-appended visibility entries. */\n        addVisibility(time, visibility, interpolation = Interpolation.Linear) {\n            if (!this.visibility)\n                this.visibility = [];\n            this.visibility.push({ time, value: visibility, interpolation });\n        }\n        /** Append a new [[RenderSchedule.ColorEntry]] to the timeline. `time` must be more recent than any previously-appended color entries. */\n        addColor(time, color, interpolation = Interpolation.Linear) {\n            if (!this.color)\n                this.color = [];\n            const value = color instanceof RgbColor ? { red: color.r, green: color.g, blue: color.b } : color;\n            this.color.push({ time, value, interpolation });\n        }\n        /** Append a new [[RenderSchedule.CuttingPlaneEntry]] to the timeline.  `time` must be more recent than any previously-appended cutting plane entries. */\n        addCuttingPlane(time, plane, interpolation = Interpolation.Linear) {\n            if (!this.cuttingPlane)\n                this.cuttingPlane = [];\n            let value;\n            if (plane) {\n                value = {\n                    position: [plane.position.x, plane.position.y, plane.position.z],\n                    direction: [plane.direction.x, plane.direction.y, plane.direction.z],\n                };\n                if (plane.visible)\n                    value.visible = true;\n                if (plane.hidden)\n                    value.hidden = true;\n            }\n            this.cuttingPlane.push({ time, value, interpolation });\n        }\n        /** Append a new [[RenderSchedule.TransformEntry]] to the timeline.  `time` must be more recent than any previously-appended transform entries. */\n        addTransform(time, transform, components, interpolation = Interpolation.Linear) {\n            if (!this.transform)\n                this.transform = [];\n            const value = { transform: transform?.toRows() };\n            if (components) {\n                value.pivot = [components.pivot.x, components.pivot.y, components.pivot.z];\n                value.orientation = components.orientation.toJSON();\n                value.position = [components.position.x, components.position.y, components.position.z];\n            }\n            this.transform.push({ time, value, interpolation });\n        }\n        /** Obtain the JSON representation of the [[RenderSchedule.Timeline]] produced by this builder.\n         * @see [[RenderSchedule.ScriptBuilder.finish]] to obtain the JSON for the entire [[RenderSchedule.Script]].\n         */\n        finish() {\n            const props = {};\n            if (this.visibility?.length)\n                props.visibilityTimeline = this.visibility;\n            if (this.color?.length)\n                props.colorTimeline = this.color;\n            if (this.transform?.length)\n                props.transformTimeline = this.transform;\n            if (this.cuttingPlane?.length)\n                props.cuttingPlaneTimeline = this.cuttingPlane;\n            return props;\n        }\n    }\n    RenderSchedule.TimelineBuilder = TimelineBuilder;\n    /** As part of a [[RenderSchedule.ScriptBuilder]], assembles a [[RenderSchedule.ElementTimeline]].\n     * @see [[RenderSchedule.ModelTimelineBuilder.addElementTimeline]].\n     */\n    class ElementTimelineBuilder extends TimelineBuilder {\n        /** Constructor - typically not used directly.\n         * @see [[RenderSchedule.ModelTimelineBuilder.addElementTimeline]] to create an ElementTimelineBuilder.\n         */\n        constructor(batchId, elementIds) {\n            super();\n            this.batchId = batchId;\n            this.elementIds = elementIds;\n        }\n        /** Obtain the JSON representation of the [[RenderSchedule.ElementTimeline]] produced by this builder.\n         * @see [[RenderSchedule.ScriptBuilder.finish]] to obtain the JSON for the entire [[RenderSchedule.Script]].\n         */\n        finish() {\n            const props = super.finish();\n            props.batchId = this.batchId;\n            props.elementIds = this.elementIds;\n            return props;\n        }\n    }\n    RenderSchedule.ElementTimelineBuilder = ElementTimelineBuilder;\n    /** As part of a [[RenderSchedule.ScriptBuilder, assembles a [[RenderSchedule.ModelTimeline]].\n     * @see [[RenderSchedule.ScriptBuilder.addModelTimeline]].\n     */\n    class ModelTimelineBuilder extends TimelineBuilder {\n        /** Constructor - typically not used directly.\n         * @see [[RenderSchedule.ScriptBuilder.addModelTimeline]] to create a ModelTimelineBuilder.\n         */\n        constructor(modelId, obtainNextBatchId) {\n            super();\n            this._elements = [];\n            this.modelId = modelId;\n            this._obtainNextBatchId = obtainNextBatchId;\n        }\n        /** Add a new [[RenderSchedule.ElementTimeline]] to be applied to the specified elements.\n         * This function will sort and compress the Ids if they are not already compressed.\n         *\n         */\n        addElementTimeline(elementIds) {\n            const batchId = this._obtainNextBatchId();\n            let ids;\n            // It's far too easy to accidentally pass a single Id (compiler can't help).\n            if (typeof elementIds === \"string\" && Id64.isValidId64(elementIds))\n                elementIds = [elementIds];\n            if (typeof elementIds === \"string\") {\n                // Already compressed.\n                ids = elementIds;\n            }\n            else {\n                const sorted = Array.from(elementIds);\n                OrderedId64Iterable.sortArray(sorted);\n                ids = CompressedId64Set.compressIds(sorted);\n            }\n            const builder = new ElementTimelineBuilder(batchId, ids);\n            this._elements.push(builder);\n            return builder;\n        }\n        /** Obtain the JSON representation of the [[RenderSchedule.ModelTimeline]] produced by this builder.\n         * @see [[RenderSchedule.ScriptBuilder.finish]] to obtain the JSON for the entire [[RenderSchedule.Script]].\n         */\n        finish() {\n            const props = super.finish();\n            props.modelId = this.modelId;\n            if (undefined !== this.realityModelUrl)\n                props.realityModelUrl = this.realityModelUrl;\n            props.elementTimelines = this._elements.map((x) => x.finish());\n            return props;\n        }\n    }\n    RenderSchedule.ModelTimelineBuilder = ModelTimelineBuilder;\n    /** Assembles the JSON representation for a new [[RenderSchedule.Script]]. Ensure that entries on any given element timeline are added chronologically. As an extremely simple example, the following code produces a script that changes the color of a single element:\n     * ```ts\n     *  const script = new ScriptBuilder();\n     *  const model = script.addModelTimeline(\"0x123\");\n     *  const element = model.addElementTimeline([ \"0x456\" ]);\n     *  element.addColor(Date.now(), new RgbColor(0xff, 0x7f, 0));\n     *  const scriptProps = script.finish();\n     * ```\n     */\n    class ScriptBuilder {\n        constructor() {\n            this._nextBatchId = 1;\n            this._models = [];\n        }\n        /** Add a new [[RenderSchedule.ModelTimeline]] to be applied to the specified model. */\n        addModelTimeline(modelId) {\n            const builder = new ModelTimelineBuilder(modelId, () => this._nextBatchId++);\n            this._models.push(builder);\n            return builder;\n        }\n        /** Obtain the JSON representation of the [[RenderSchedule.Script]] produced by this builder.\n         * @see [RenderTimeline.scriptProps]($backend) to assign the new script to a RenderTimeline element.\n         */\n        finish() {\n            return this._models.map((x) => x.finish());\n        }\n    }\n    RenderSchedule.ScriptBuilder = ScriptBuilder;\n})(RenderSchedule || (RenderSchedule = {}));\n//# sourceMappingURL=RenderSchedule.js.map",
      "start": 1693508120943,
      "end": 1693508120994,
      "sourcemaps": null
    }
  ]
}
