{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/polyface/PolyfaceQuery.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Polyface\n */\n/* eslint-disable @typescript-eslint/naming-convention, no-empty */\nimport { BagOfCurves } from \"../curve/CurveCollection\";\nimport { CurveOps } from \"../curve/CurveOps\";\nimport { MultiChainCollector } from \"../curve/internalContexts/MultiChainCollector\";\nimport { LineSegment3d } from \"../curve/LineSegment3d\";\nimport { LineString3d } from \"../curve/LineString3d\";\nimport { Loop } from \"../curve/Loop\";\nimport { StrokeOptions } from \"../curve/StrokeOptions\";\nimport { Geometry } from \"../Geometry\";\nimport { Angle } from \"../geometry3d/Angle\";\nimport { BarycentricTriangle } from \"../geometry3d/BarycentricTriangle\";\nimport { FrameBuilder } from \"../geometry3d/FrameBuilder\";\nimport { Point3dArrayCarrier } from \"../geometry3d/Point3dArrayCarrier\";\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\nimport { Point3dArray } from \"../geometry3d/PointHelpers\";\nimport { PolygonOps } from \"../geometry3d/PolygonOps\";\nimport { Range3d } from \"../geometry3d/Range\";\nimport { Matrix4d } from \"../geometry4d/Matrix4d\";\nimport { MomentData } from \"../geometry4d/MomentData\";\nimport { UnionFindContext } from \"../numerics/UnionFind\";\nimport { ChainMergeContext } from \"../topology/ChainMerge\";\nimport { HalfEdgeMask } from \"../topology/Graph\";\nimport { HalfEdgeGraphFromIndexedLoopsContext } from \"../topology/HalfEdgeGraphFromIndexedLoopsContext\";\nimport { HalfEdgeGraphSearch, HalfEdgeMaskTester } from \"../topology/HalfEdgeGraphSearch\";\nimport { HalfEdgeGraphMerge } from \"../topology/Merging\";\nimport { SpacePolygonTriangulation } from \"../topology/SpaceTriangulation\";\nimport { ConvexFacetLocationDetail, NonConvexFacetLocationDetail, TriangularFacetLocationDetail, } from \"./FacetLocationDetail\";\nimport { FacetOrientationFixup } from \"./FacetOrientation\";\nimport { IndexedEdgeMatcher, SortableEdge } from \"./IndexedEdgeMatcher\";\nimport { IndexedPolyfaceSubsetVisitor } from \"./IndexedPolyfaceVisitor\";\nimport { BuildAverageNormalsContext } from \"./multiclip/BuildAverageNormalsContext\";\nimport { OffsetMeshContext } from \"./multiclip/OffsetMeshContext\";\nimport { ClipSweptLineStringContext, EdgeClipData, SweepLineStringToFacetContext } from \"./multiclip/SweepLineStringToFacetContext\";\nimport { XYPointBuckets } from \"./multiclip/XYPointBuckets\";\nimport { Polyface } from \"./Polyface\";\nimport { PolyfaceBuilder } from \"./PolyfaceBuilder\";\nimport { RangeLengthData } from \"./RangeLengthData\";\n/**\n * Options carrier for sweeping linework onto meshes.\n * * The create method initializes all options.\n * @public\n */\nexport class SweepLineStringToFacetsOptions {\n    /** constructor -- captures fully-checked parameters from static create method.\n    */\n    constructor(vectorToEye, sideAngle, assembleChains, collectOnForwardFacets, collectOnSideFacets, collectOnRearFacets) {\n        this.vectorToEye = vectorToEye;\n        this.sideAngle = sideAngle;\n        this.assembleChains = assembleChains;\n        this.collectOnForwardFacets = collectOnForwardFacets;\n        this.collectOnSideFacets = collectOnSideFacets;\n        this.collectOnRearFacets = collectOnRearFacets;\n    }\n    /** Create an options structure.\n     * * Default vectorToEye is positive Z\n     * * Default sideAngle has radians value Geometry.smallAngleRadians\n     * * Default assembleChains is true\n     * * Default collectOnForwardFacets, collectOnSideFacets, collectOnRearFacets are all true.\n     */\n    static create(vectorToEye, sideAngle, assembleChains, collectOnForwardFacets, collectOnSideFacets, collectOnRearFacets) {\n        return new SweepLineStringToFacetsOptions(vectorToEye === undefined ? Vector3d.unitZ() : vectorToEye.clone(), sideAngle === undefined ? Angle.createRadians(Geometry.smallAngleRadians) : sideAngle.clone(), Geometry.resolveValue(assembleChains, true), Geometry.resolveValue(collectOnForwardFacets, true), Geometry.resolveValue(collectOnSideFacets, true), Geometry.resolveValue(collectOnRearFacets, true));\n    }\n    /** Return true if all outputs are requested */\n    get collectAll() { return this.collectOnForwardFacets === true && this.collectOnRearFacets === true && this.collectOnRearFacets === true; }\n    /** Decide if the instance flags accept this facet.\n     * * Facets whose facet normal have positive, zero, or negative dot product with the vectorToEye are forward, side, and rear.\n     * * Undefined facet normal returns false\n    */\n    collectFromThisFacetNormal(facetNormal) {\n        if (facetNormal === undefined)\n            return false;\n        const theta = facetNormal.angleFromPerpendicular(this.vectorToEye);\n        if (theta.isMagnitudeLessThanOrEqual(this.sideAngle))\n            return this.collectOnSideFacets;\n        return facetNormal.dotProduct(this.vectorToEye) > 0 ? this.collectOnForwardFacets : this.collectOnRearFacets;\n    }\n}\n/**\n * Options carrier for [[PolyfaceQuery.cloneOffset]].\n * * Default options are strongly recommended.\n * * The option most likely to be changed is chamferTurnAngle\n * @public\n */\nexport class OffsetMeshOptions {\n    /** Constructor -- CAPTURE parameters ... */\n    constructor(smoothSingleAngleBetweenNormals = Angle.createDegrees(25), smoothAccumulatedAngleBetweenNormals = Angle.createDegrees(60), chamferTurnAngle = Angle.createDegrees(90)) {\n        this.smoothSingleAngleBetweenNormals = smoothSingleAngleBetweenNormals.clone();\n        this.smoothAccumulatedAngleBetweenNormals = smoothAccumulatedAngleBetweenNormals.clone();\n        this.chamferAngleBetweenNormals = chamferTurnAngle.clone();\n    }\n    /** construct and return an OffsetMeshOptions with given parameters.\n     * * Angles are forced to minimum values.\n     * * Clones of the angles are given to the constructor.\n     * @param smoothSingleRadiansBetweenNormals an angle larger than this (between facets) is considered a sharp edge\n     * @param smoothAccumulatedAngleBetweenNormals angles that sum to this much may be consolidated for average normal\n     * @param chamferTurnAngleBetweenNormals when facets meet with larger angle, a chamfer edge may be added if the angle between facet normals is larger than this.\n     */\n    static create(smoothSingleAngleBetweenNormals = Angle.createDegrees(25), smoothAccumulatedAngleBetweenNormals = Angle.createDegrees(60), chamferTurnAngleBetweenNormals = Angle.createDegrees(120)) {\n        const mySmoothSingleRadiansBetweenNormals = smoothSingleAngleBetweenNormals.clone();\n        const mySmoothAccumulatedRadiansBetweenNormals = smoothAccumulatedAngleBetweenNormals.clone();\n        const myChamferTurnAngleBetweenNormals = chamferTurnAngleBetweenNormals.clone();\n        if (mySmoothSingleRadiansBetweenNormals.degrees < 1)\n            mySmoothAccumulatedRadiansBetweenNormals.setDegrees(1.0);\n        if (mySmoothAccumulatedRadiansBetweenNormals.degrees < 1.0)\n            mySmoothAccumulatedRadiansBetweenNormals.setDegrees(1.0);\n        if (mySmoothAccumulatedRadiansBetweenNormals.degrees < 15.0)\n            mySmoothAccumulatedRadiansBetweenNormals.setDegrees(15.0);\n        return new OffsetMeshOptions(mySmoothSingleRadiansBetweenNormals, mySmoothAccumulatedRadiansBetweenNormals, myChamferTurnAngleBetweenNormals);\n    }\n}\n/**\n * Enumeration of cases for retaining facets among duplicates\n * @public\n */\nexport var DuplicateFacetClusterSelector;\n(function (DuplicateFacetClusterSelector) {\n    /** retain none of the duplicates */\n    DuplicateFacetClusterSelector[DuplicateFacetClusterSelector[\"SelectNone\"] = 0] = \"SelectNone\";\n    /** retain any one member among duplicates */\n    DuplicateFacetClusterSelector[DuplicateFacetClusterSelector[\"SelectAny\"] = 1] = \"SelectAny\";\n    /** retain all members among duplicates */\n    DuplicateFacetClusterSelector[DuplicateFacetClusterSelector[\"SelectAll\"] = 2] = \"SelectAll\";\n    /** retain one from any cluster with an odd number of faces */\n    DuplicateFacetClusterSelector[DuplicateFacetClusterSelector[\"SelectOneByParity\"] = 3] = \"SelectOneByParity\";\n})(DuplicateFacetClusterSelector || (DuplicateFacetClusterSelector = {}));\n/** PolyfaceQuery is a static class whose methods implement queries on a polyface or polyface visitor provided as a parameter to each method.\n * @public\n */\nclass PolyfaceQuery {\n    /** copy the points from a visitor into a Linestring3d in a Loop object */\n    static visitorToLoop(visitor) {\n        const ls = LineString3d.createPoints(visitor.point.getPoint3dArray());\n        return Loop.create(ls);\n    }\n    /** Create a linestring loop for each facet of the polyface. */\n    static indexedPolyfaceToLoops(polyface) {\n        const result = BagOfCurves.create();\n        const visitor = polyface.createVisitor(1);\n        while (visitor.moveToNextFacet()) {\n            const loop = PolyfaceQuery.visitorToLoop(visitor);\n            result.tryAddChild(loop);\n        }\n        return result;\n    }\n    /** Return the sum of all facet areas.\n     * @param vectorToEye compute facet area projected to a view plane perpendicular to this vector\n    */\n    static sumFacetAreas(source, vectorToEye) {\n        let s = 0;\n        if (source !== undefined) {\n            if (source instanceof Polyface)\n                return PolyfaceQuery.sumFacetAreas(source.createVisitor(1), vectorToEye);\n            let unitVectorToEye;\n            if (vectorToEye !== undefined)\n                unitVectorToEye = vectorToEye.normalize();\n            source.reset();\n            while (source.moveToNextFacet()) {\n                const scaledNormal = PolygonOps.areaNormal(source.point.getPoint3dArray());\n                let area = scaledNormal.magnitude();\n                if (unitVectorToEye !== undefined) {\n                    const scale = Geometry.conditionalDivideCoordinate(1.0, area);\n                    if (scale !== undefined)\n                        area *= scaledNormal.dotProduct(unitVectorToEye) * scale;\n                }\n                s += area;\n            }\n        }\n        return s;\n    }\n    /** sum volumes of tetrahedra from origin to all facets.\n     * * if origin is omitted, the first point encountered (by the visitor) is used as origin.\n     * * If the mesh is closed, this sum is the volume.\n     * * If the mesh is not closed, this sum is the volume of a mesh with various additional facets\n     * from the origin to facets.\n    */\n    static sumTetrahedralVolumes(source, origin) {\n        let s = 0;\n        if (source instanceof Polyface)\n            return PolyfaceQuery.sumTetrahedralVolumes(source.createVisitor(0), origin);\n        let myOrigin = origin;\n        const facetOrigin = Point3d.create();\n        const targetA = Point3d.create();\n        const targetB = Point3d.create();\n        source.reset();\n        while (source.moveToNextFacet()) {\n            if (myOrigin === undefined)\n                myOrigin = source.point.getPoint3dAtUncheckedPointIndex(0);\n            source.point.getPoint3dAtUncheckedPointIndex(0, facetOrigin);\n            for (let i = 1; i + 1 < source.point.length; i++) {\n                source.point.getPoint3dAtUncheckedPointIndex(i, targetA);\n                source.point.getPoint3dAtUncheckedPointIndex(i + 1, targetB);\n                s += myOrigin.tripleProductToPoints(facetOrigin, targetA, targetB);\n            }\n        }\n        return s / 6.0;\n    }\n    /** sum (signed) volumes between facets and a plane.\n     * Return a structure with multiple sums:\n     * * volume = the sum of (signed) volumes between facets and the plane.\n     * * positiveAreaMomentData, negativeProjectedFacetAreaMoments = moment data with centroid, area, and second moments with respect to the centroid.\n     *\n    */\n    static sumVolumeBetweenFacetsAndPlane(source, plane) {\n        if (source instanceof Polyface)\n            return PolyfaceQuery.sumVolumeBetweenFacetsAndPlane(source.createVisitor(0), plane);\n        const facetOrigin = Point3d.create();\n        const targetA = Point3d.create();\n        const targetB = Point3d.create();\n        const triangleNormal = Vector3d.create();\n        const planeNormal = plane.getNormalRef();\n        let h0, hA, hB;\n        let signedVolumeSum = 0.0;\n        let signedTriangleArea;\n        let singleFacetArea;\n        const positiveAreaMomentSums = MomentData.create(undefined, true);\n        const negativeAreaMomentSums = MomentData.create(undefined, true);\n        const singleFacetProducts = Matrix4d.createZero();\n        const projectToPlane = plane.getProjectionToPlane();\n        source.reset();\n        // For each facet ..\n        //   Form triangles from facet origin to each far edge.\n        //   Sum signed area and volume contributions\n        // each \"projectedArea\" contribution is twice the area of a triangle.\n        // each volume contribution is  3 times the actual volume -- (1/3) of the altitude sums was the centroid altitude.\n        while (source.moveToNextFacet()) {\n            source.point.getPoint3dAtUncheckedPointIndex(0, facetOrigin);\n            h0 = plane.altitude(facetOrigin);\n            singleFacetArea = 0;\n            // within a single facets, the singleFacetArea sum is accumulated with signs of individual triangles.\n            // For a non-convex facet, this can be a mixture of positive and negative areas.\n            // The absoluteProjectedAreaSum contribution is forced positive after the sum for the facet.\n            for (let i = 1; i + 1 < source.point.length; i++) {\n                source.point.getPoint3dAtUncheckedPointIndex(i, targetA);\n                source.point.getPoint3dAtUncheckedPointIndex(i + 1, targetB);\n                facetOrigin.crossProductToPoints(targetA, targetB, triangleNormal);\n                hA = plane.altitude(targetA);\n                hB = plane.altitude(targetB);\n                signedTriangleArea = planeNormal.dotProduct(triangleNormal);\n                singleFacetArea += signedTriangleArea;\n                signedVolumeSum += signedTriangleArea * (h0 + hA + hB);\n            }\n            singleFacetProducts.setZero();\n            source.point.multiplyTransformInPlace(projectToPlane);\n            PolygonOps.addSecondMomentAreaProducts(source.point, facetOrigin, singleFacetProducts);\n            if (singleFacetArea > 0) {\n                positiveAreaMomentSums.accumulateProductsFromOrigin(facetOrigin, singleFacetProducts, 1.0);\n            }\n            else {\n                negativeAreaMomentSums.accumulateProductsFromOrigin(facetOrigin, singleFacetProducts, 1.0);\n            }\n        }\n        positiveAreaMomentSums.shiftOriginAndSumsToCentroidOfSums();\n        negativeAreaMomentSums.shiftOriginAndSumsToCentroidOfSums();\n        const positiveAreaMoments = MomentData.inertiaProductsToPrincipalAxes(positiveAreaMomentSums.origin, positiveAreaMomentSums.sums);\n        const negativeAreaMoments = MomentData.inertiaProductsToPrincipalAxes(negativeAreaMomentSums.origin, negativeAreaMomentSums.sums);\n        return {\n            volume: signedVolumeSum / 6.0,\n            positiveProjectedFacetAreaMoments: positiveAreaMoments,\n            negativeProjectedFacetAreaMoments: negativeAreaMoments,\n        };\n    }\n    /** Return the inertia products [xx,xy,xz,xw, yw, etc] integrated over all all facets, as viewed from origin. */\n    static sumFacetSecondAreaMomentProducts(source, origin) {\n        if (source instanceof Polyface)\n            return PolyfaceQuery.sumFacetSecondAreaMomentProducts(source.createVisitor(0), origin);\n        const products = Matrix4d.createZero();\n        source.reset();\n        while (source.moveToNextFacet()) {\n            PolygonOps.addSecondMomentAreaProducts(source.point, origin, products);\n        }\n        return products;\n    }\n    /** Return the inertia products [xx,xy,xz,xw, yw, etc] integrated over all tetrahedral volumes from origin */\n    static sumFacetSecondVolumeMomentProducts(source, origin) {\n        if (source instanceof Polyface)\n            return PolyfaceQuery.sumFacetSecondVolumeMomentProducts(source.createVisitor(0), origin);\n        const products = Matrix4d.createZero();\n        source.reset();\n        while (source.moveToNextFacet()) {\n            PolygonOps.addSecondMomentVolumeProducts(source.point, origin, products);\n        }\n        return products;\n    }\n    /** Compute area moments for the mesh. In the returned MomentData:\n     * * origin is the centroid.\n     * * localToWorldMap has the origin and principal directions\n     * * radiiOfGyration radii for rotation around the x,y,z axes.\n     */\n    static computePrincipalAreaMoments(source) {\n        const origin = source.data.getPoint(0);\n        if (!origin)\n            return undefined;\n        const inertiaProducts = PolyfaceQuery.sumFacetSecondAreaMomentProducts(source, origin);\n        return MomentData.inertiaProductsToPrincipalAxes(origin, inertiaProducts);\n    }\n    /** Compute area moments for the mesh. In the returned MomentData:\n     * * origin is the centroid.\n     * * localToWorldMap has the origin and principal directions\n     * * radiiOfGyration radii for rotation around the x,y,z axes.\n     * * The result is only valid if the mesh is closed.\n     * * There is no test for closure.  Use `PolyfaceQuery.isPolyfaceClosedByEdgePairing(polyface)` to test for closure.\n     */\n    static computePrincipalVolumeMoments(source) {\n        const origin = source.data.getPoint(0);\n        if (!origin)\n            return undefined;\n        const inertiaProducts = PolyfaceQuery.sumFacetSecondVolumeMomentProducts(source, origin);\n        return MomentData.inertiaProductsToPrincipalAxes(origin, inertiaProducts);\n    }\n    /**\n     * Test for convex volume by dihedral angle tests on all edges.\n     * * This tests if all dihedral angles are positive.\n     * * In a closed solid, this is a strong test for overall convexity.\n     * * With `ignoreBoundaries` true, this may be a useful test when all the facets are in a single edge-connected component, such as a pyramid with no underside.\n     * * It is not a correct test if there are multiple, disjoint components.\n     *   * Take the above-mentioned pyramid with no underside.\n     *   * Within the same mesh, have a second pyramid placed to the side, still facing upward.\n     *   * The angles will pass the dihedral convexity test, but the composite thing surely is not convex.\n     * @param source mesh to examine\n     * @param ignoreBoundaries if true, ignore simple boundary edges, i.e. allow unclosed meshes.\n     * @returns true if the mesh is closed and has all dihedral angles (angle across edge) positive\n     */\n    static isConvexByDihedralAngleCount(source, ignoreBoundaries = false) {\n        return this.dihedralAngleSummary(source, ignoreBoundaries) > 0;\n    }\n    /**\n    * Compute a number summarizing the dihedral angles in the mesh.\n    * @see [[isConvexByDihedralAngleCount]] for comments about ignoreBoundaries===true when there are multiple connected components.\n    * @param source mesh to examine\n    * @param ignoreBoundaries if true, ignore simple boundary edges, i.e. allow unclosed meshes.\n    * @returns a number summarizing the dihedral angles in the mesh.\n    *   * Return 1 if all angles are positive or planar.  The mesh is probably convex with outward normals.\n    *   * Return -1 if all angles are negative or planar.  The mesh is probably convex with inward normals.\n    *   * Return 0 if\n    *     * angles area mixed\n    *     * any edge has other than 1 incident facet or more than 2 incident facets.\n    *     * (but null edges are permitted -- These occur naturally at edges of quads at north or south pole)\n    */\n    static dihedralAngleSummary(source, ignoreBoundaries = false) {\n        const edges = new IndexedEdgeMatcher();\n        const visitor = source.createVisitor(1);\n        visitor.reset();\n        const centroidNormal = [];\n        let normalCounter = 0;\n        while (visitor.moveToNextFacet()) {\n            const numEdges = visitor.pointCount - 1;\n            const normal = PolygonOps.centroidAreaNormal(visitor.point);\n            if (normal === undefined)\n                return 0;\n            centroidNormal.push(normal);\n            for (let i = 0; i < numEdges; i++) {\n                edges.addEdge(visitor.clientPointIndex(i), visitor.clientPointIndex(i + 1), normalCounter);\n            }\n            normalCounter++;\n        }\n        const badClusters = [];\n        const manifoldClusters = [];\n        edges.sortAndCollectClusters(manifoldClusters, ignoreBoundaries ? undefined : badClusters, undefined, badClusters);\n        if (badClusters.length > 0)\n            return 0;\n        let numPositive = 0;\n        let numPlanar = 0;\n        let numNegative = 0;\n        const edgeVector = Vector3d.create();\n        for (const cluster of manifoldClusters) {\n            const sideA = cluster[0];\n            const sideB = cluster[1];\n            if (sideA instanceof SortableEdge\n                && sideB instanceof SortableEdge\n                && source.data.point.vectorIndexIndex(sideA.vertexIndexA, sideA.vertexIndexB, edgeVector)) {\n                const dihedralAngle = centroidNormal[sideA.facetIndex].direction.signedAngleTo(centroidNormal[sideB.facetIndex].direction, edgeVector);\n                if (dihedralAngle.isAlmostZero)\n                    numPlanar++;\n                else if (dihedralAngle.radians > 0.0)\n                    numPositive++;\n                else\n                    numNegative++;\n            }\n        }\n        if (numPositive > 0 && numNegative === 0)\n            return 1;\n        if (numNegative > 0 && numPositive === 0)\n            return -1;\n        // problem case: if all edges have zero dihedral angle, record it as convex.\n        if (numPlanar > 0 && numPositive === 0 && numNegative === 0)\n            return 1;\n        return 0;\n    }\n    /**\n     * Test if the facets in `source` occur in perfectly mated pairs, as is required for a closed manifold volume.\n     */\n    static isPolyfaceClosedByEdgePairing(source) {\n        return this.isPolyfaceManifold(source, false);\n    }\n    /** Test edges pairing in `source` mesh.\n     * * for `allowSimpleBoundaries === false` true return means this is a closed 2-manifold surface\n     * * for `allowSimpleBoundaries === true` true means this is a 2-manifold surface which may have boundary, but is still properly matched internally.\n     * * Any edge with 3 or more incident facets triggers `false` return.\n     * * Any edge with 2 incident facets in the same direction triggers a `false` return.\n    */\n    static isPolyfaceManifold(source, allowSimpleBoundaries = false) {\n        const edges = new IndexedEdgeMatcher();\n        const visitor = source.createVisitor(1);\n        visitor.reset();\n        while (visitor.moveToNextFacet()) {\n            const numEdges = visitor.pointCount - 1;\n            for (let i = 0; i < numEdges; i++) {\n                edges.addEdge(visitor.clientPointIndex(i), visitor.clientPointIndex(i + 1), visitor.currentReadIndex());\n            }\n        }\n        const badClusters = [];\n        edges.sortAndCollectClusters(undefined, allowSimpleBoundaries ? undefined : badClusters, undefined, badClusters);\n        return badClusters.length === 0;\n    }\n    /**\n     * construct a CurveCollection containing boundary edges.\n     *   * each edge is a LineSegment3d\n     * @param source polyface or visitor\n     * @param includeDanglers true to in include typical boundary edges with a single incident facet\n     * @param includeMismatch true to include edges with more than 2 incident facets\n     * @param includeNull true to include edges with identical start and end vertex indices.\n     * @returns\n     */\n    static boundaryEdges(source, includeDanglers = true, includeMismatch = true, includeNull = true) {\n        const result = new BagOfCurves();\n        const announceEdge = (pointA, pointB, _indexA, _indexB, _readIndex) => {\n            result.tryAddChild(LineSegment3d.create(pointA, pointB));\n        };\n        PolyfaceQuery.announceBoundaryEdges(source, announceEdge, includeDanglers, includeMismatch, includeNull);\n        if (result.children.length === 0)\n            return undefined;\n        return result;\n    }\n    /**\n  * Test if the facets in `source` occur in perfectly mated pairs, as is required for a closed manifold volume.\n  * If not, extract the boundary edges as lines.\n  * @param source polyface or visitor\n  * @param announceEdge function to be called with each boundary edge. The announcement is start and end points, start and end indices, and facet index.\n  * @param includeDanglers true to in include typical boundary edges with a single incident facet\n  * @param includeMismatch true to include edges with more than 2 incident facets\n  * @param includeNull true to include edges with identical start and end vertex indices.\n  */\n    static announceBoundaryEdges(source, announceEdge, includeDanglers = true, includeMismatch = true, includeNull = true) {\n        if (source === undefined)\n            return undefined;\n        const edges = new IndexedEdgeMatcher();\n        const visitor = source instanceof Polyface ? source.createVisitor(1) : source;\n        visitor.setNumWrap(1);\n        visitor.reset();\n        while (visitor.moveToNextFacet()) {\n            const numEdges = visitor.pointCount - 1;\n            for (let i = 0; i < numEdges; i++) {\n                edges.addEdge(visitor.clientPointIndex(i), visitor.clientPointIndex(i + 1), visitor.currentReadIndex());\n            }\n        }\n        const bad1 = [];\n        const bad2 = [];\n        const bad0 = [];\n        edges.sortAndCollectClusters(undefined, bad1, bad0, bad2);\n        const badList = [];\n        if (includeDanglers && bad1.length > 0)\n            badList.push(bad1);\n        if (includeMismatch && bad2.length > 0)\n            badList.push(bad2);\n        if (includeNull && bad0.length > 0)\n            badList.push(bad0);\n        if (badList.length === 0)\n            return undefined;\n        const sourcePolyface = visitor.clientPolyface();\n        for (const list of badList) {\n            for (const e of list) {\n                const e1 = e instanceof SortableEdge ? e : e[0];\n                const indexA = e1.vertexIndexA;\n                const indexB = e1.vertexIndexB;\n                const pointA = sourcePolyface.data.getPoint(indexA);\n                const pointB = sourcePolyface.data.getPoint(indexB);\n                if (pointA && pointB)\n                    announceEdge(pointA, pointB, indexA, indexB, visitor.currentReadIndex());\n            }\n        }\n    }\n    /** Find segments (within the linestring) which project to facets.\n     * * Announce each pair of linestring segment and on-facet segment through a callback.\n     * * Facets are ASSUMED to be convex and planar, and not overlap in the z direction.\n     */\n    static announceSweepLinestringToConvexPolyfaceXY(linestringPoints, polyface, announce) {\n        const context = SweepLineStringToFacetContext.create(linestringPoints);\n        if (context) {\n            const visitor = polyface.createVisitor(0);\n            for (visitor.reset(); visitor.moveToNextFacet();) {\n                context.projectToPolygon(visitor.point, announce, polyface, visitor.currentReadIndex());\n            }\n        }\n    }\n    /** Execute context.projectToPolygon until its work estimates accumulate to workLimit  */\n    static async continueAnnounceSweepLinestringToConvexPolyfaceXY(context, visitor, announce) {\n        let workCount = 0;\n        while ((workCount < this.asyncWorkLimit) && visitor.moveToNextFacet()) {\n            workCount += context.projectToPolygon(visitor.point, announce, visitor.clientPolyface(), visitor.currentReadIndex());\n        }\n        return workCount;\n    }\n    /** Set the limit on work during an async time blocks, and return the old value.\n     * * This should be a large number -- default is 1.0e6\n     * @internal\n     */\n    static setAsyncWorkLimit(value) { const a = this._asyncWorkLimit; this._asyncWorkLimit = value; return a; }\n    /** Query the current limit on work during an async time block.\n     * @internal\n     */\n    static get asyncWorkLimit() { return this._asyncWorkLimit; }\n    /** Find segments (within the linestring) which project to facets.\n     * * Announce each pair of linestring segment and on-facet segment through a callback.\n     * * Facets are ASSUMED to be convex and planar, and not overlap in the z direction.\n     * * REMARK: Although this is public, the usual use is via slightly higher level public methods, viz:\n     *   * asyncSweepLinestringToFacetsXYReturnChains\n     * @internal\n     */\n    static async asyncAnnounceSweepLinestringToConvexPolyfaceXY(linestringPoints, polyface, announce) {\n        const context = SweepLineStringToFacetContext.create(linestringPoints);\n        this.awaitBlockCount = 0;\n        let workTotal = 0;\n        if (context) {\n            const visitor = polyface.createVisitor(0);\n            let workCount;\n            while (0 < (workCount = await Promise.resolve(PolyfaceQuery.continueAnnounceSweepLinestringToConvexPolyfaceXY(context, visitor, announce)))) {\n                workTotal += workCount;\n                this.awaitBlockCount++;\n                // GeometryCoreTestIO.consoleLog({ myWorkCount: workCount, myBlockCount: this.awaitBlockCount });\n            }\n        }\n        // GeometryCoreTestIO.consoleLog({ myWorkTotal: workTotal, myBlockCount: this.awaitBlockCount });\n        return workTotal;\n    }\n    /** Search the facets for facet subsets that are connected with at least vertex contact.\n     * * Return array of arrays of facet indices.\n     */\n    static partitionFacetIndicesByVertexConnectedComponent(polyface) {\n        if (polyface instanceof Polyface) {\n            return this.partitionFacetIndicesByVertexConnectedComponent(polyface.createVisitor(0));\n        }\n        // The polyface is really a visitor !!!\n        const context = new UnionFindContext(this.visitorClientPointCount(polyface));\n        for (polyface.reset(); polyface.moveToNextFacet();) {\n            const firstVertexIndexOnThisFacet = polyface.pointIndex[0];\n            for (const vertexIndex of polyface.pointIndex)\n                context.mergeSubsets(firstVertexIndexOnThisFacet, vertexIndex);\n        }\n        const roots = context.collectRootIndices();\n        const facetsInComponent = [];\n        const numRoots = roots.length;\n        for (let i = 0; i < numRoots; i++) {\n            facetsInComponent.push([]);\n        }\n        for (polyface.reset(); polyface.moveToNextFacet();) {\n            const firstVertexIndexOnThisFacet = polyface.pointIndex[0];\n            const rootVertexForThisFacet = context.findRoot(firstVertexIndexOnThisFacet);\n            for (let rootIndex = 0; rootIndex < numRoots; rootIndex++) {\n                if (roots[rootIndex] === rootVertexForThisFacet) {\n                    facetsInComponent[rootIndex].push(polyface.currentReadIndex());\n                    break;\n                }\n            }\n        }\n        return facetsInComponent;\n    }\n    /**\n     * * Examine the normal orientation for each faces.\n     * * Separate to 3 partitions:\n     *    * facets with normal in the positive direction of the vectorToEye (partition 0)\n     *    * facets with normal in the negative direction of the vectorToEye (partition 1)\n     *    * facets nearly perpendicular to the view vector  (partition 2)\n     * * Return array of arrays of facet indices.\n     */\n    static partitionFacetIndicesByVisibilityVector(polyface, vectorToEye, sideAngleTolerance) {\n        if (polyface instanceof Polyface) {\n            return this.partitionFacetIndicesByVisibilityVector(polyface.createVisitor(0), vectorToEye, sideAngleTolerance);\n        }\n        const facetsInComponent = [];\n        for (let i = 0; i < 3; i++) {\n            facetsInComponent.push([]);\n        }\n        const forwardComponent = facetsInComponent[0];\n        const rearComponent = facetsInComponent[1];\n        const sideComponent = facetsInComponent[2];\n        const radiansTol = Math.max(sideAngleTolerance.radians, 1.0e-8);\n        for (polyface.reset(); polyface.moveToNextFacet();) {\n            const areaNormal = PolygonOps.areaNormalGo(polyface.point);\n            const index = polyface.currentReadIndex();\n            if (areaNormal) {\n                const angle = areaNormal.angleFromPerpendicular(vectorToEye);\n                if (Math.abs(angle.radians) < radiansTol) {\n                    sideComponent.push(index);\n                }\n                else if (areaNormal.dotProduct(vectorToEye) < 0) {\n                    rearComponent.push(index);\n                }\n                else {\n                    forwardComponent.push(index);\n                }\n            }\n        }\n        return facetsInComponent;\n    }\n    /**\n     * Return the boundary of facets that are facing the eye.\n     * @param polyface\n     * @param visibilitySubset selector among the visible facet sets extracted by partitionFacetIndicesByVisibilityVector\n     *   * 0 ==> forward facing\n     *   * 1 ==> rear facing\n     *   * 2 ==> side facing\n     * @param vectorToEye\n     * @param sideAngleTolerance\n     */\n    static boundaryOfVisibleSubset(polyface, visibilitySelect, vectorToEye, sideAngleTolerance = Angle.createDegrees(1.0e-3)) {\n        const partitionedIndices = this.partitionFacetIndicesByVisibilityVector(polyface, vectorToEye, sideAngleTolerance);\n        if (partitionedIndices[visibilitySelect].length === 0)\n            return undefined;\n        const visitor = IndexedPolyfaceSubsetVisitor.createSubsetVisitor(polyface, partitionedIndices[visibilitySelect], 1);\n        return this.boundaryEdges(visitor, true, false, false);\n    }\n    /**\n     * Search for edges with only 1 incident facet.\n     * * chain them into loops\n     * * emit the loops to the announceLoop function\n     * @param mesh\n     */\n    static announceBoundaryChainsAsLineString3d(mesh, announceLoop) {\n        const collector = new MultiChainCollector(Geometry.smallMetricDistance, 1000);\n        PolyfaceQuery.announceBoundaryEdges(mesh, (pointA, pointB, _indexA, _indexB) => collector.captureCurve(LineSegment3d.create(pointA, pointB)), true, false, false);\n        collector.announceChainsAsLineString3d(announceLoop);\n    }\n    /**\n     * Return a mesh with\n     *  * clusters of adjacent, coplanar facets merged into larger facets.\n     *  * other facets included unchanged.\n     * @param mesh existing mesh or visitor\n     * @returns\n     */\n    static cloneWithMaximalPlanarFacets(mesh) {\n        if (mesh instanceof Polyface)\n            return this.cloneWithMaximalPlanarFacets(mesh.createVisitor(0));\n        const numFacets = PolyfaceQuery.visitorClientFacetCount(mesh);\n        const smoothEdges = PolyfaceQuery.collectEdgesByDihedralAngle(mesh);\n        const partitions = PolyfaceQuery.partitionFacetIndicesBySortableEdgeClusters(smoothEdges, numFacets);\n        const builder = PolyfaceBuilder.create();\n        const visitor = mesh;\n        const planarPartitions = [];\n        for (const partition of partitions) {\n            if (partition.length === 1) {\n                if (visitor.moveToReadIndex(partition[0]))\n                    builder.addFacetFromVisitor(visitor);\n            }\n            else {\n                // This is a non-trivial set of contiguous coplanar facets\n                planarPartitions.push(partition);\n            }\n        }\n        const fragmentPolyfaces = PolyfaceQuery.clonePartitions(mesh, planarPartitions);\n        const gapTolerance = 1.0e-4;\n        const planarityTolerance = 1.0e-4;\n        for (const fragment of fragmentPolyfaces) {\n            const edges = [];\n            const edgeStrings = [];\n            PolyfaceQuery.announceBoundaryEdges(fragment, (pointA, pointB, _indexA, _indexB) => {\n                edges.push(LineSegment3d.create(pointA, pointB));\n                edgeStrings.push([pointA.clone(), pointB.clone()]);\n            });\n            const chains = CurveOps.collectChains(edges, gapTolerance, planarityTolerance);\n            if (chains) {\n                const frameBuilder = new FrameBuilder();\n                frameBuilder.announce(chains);\n                const frame = frameBuilder.getValidatedFrame(false);\n                if (frame !== undefined) {\n                    const inverseFrame = frame.inverse();\n                    if (inverseFrame !== undefined) {\n                        inverseFrame.multiplyPoint3dArrayArrayInPlace(edgeStrings);\n                        const graph = HalfEdgeGraphMerge.formGraphFromChains(edgeStrings, true, HalfEdgeMask.BOUNDARY_EDGE);\n                        if (graph) {\n                            HalfEdgeGraphSearch.collectConnectedComponentsWithExteriorParityMasks(graph, new HalfEdgeMaskTester(HalfEdgeMask.BOUNDARY_EDGE), HalfEdgeMask.EXTERIOR);\n                            // this.purgeNullFaces(HalfEdgeMask.EXTERIOR);\n                            const polyface1 = PolyfaceBuilder.graphToPolyface(graph);\n                            builder.addIndexedPolyface(polyface1, false, frame);\n                        }\n                    }\n                }\n            }\n        }\n        return builder.claimPolyface(true);\n    }\n    /**\n     * Return a mesh with \"some\" holes filled in with new facets.\n     *  * Candidate chains are computed by [[announceBoundaryChainsAsLineString3d]].\n     *  * Unclosed chains are rejected.\n     *  * Closed chains are triangulated and returned as a mesh.\n     *  * The options structure enforces restrictions on how complicated the hole filling can be:\n     *     * maxEdgesAroundHole -- holes with more edges are skipped\n     *     * maxPerimeter -- holes with larger summed edge lengths are skipped.\n     *     * upVector -- holes that do not have positive area along this view are skipped.\n     *     * includeOriginalMesh -- includes the original mesh in the output mesh, so the composite mesh is a clone with holes filled\n     * @param mesh existing mesh\n     * @param options options controlling the hole fill.\n     * @param unfilledChains optional array to receive the points around holes that were not filled.\n     * @returns\n     */\n    static fillSimpleHoles(mesh, options, unfilledChains) {\n        if (mesh instanceof Polyface)\n            return this.fillSimpleHoles(mesh.createVisitor(0), options, unfilledChains);\n        const builder = PolyfaceBuilder.create();\n        const chains = [];\n        PolyfaceQuery.announceBoundaryChainsAsLineString3d(mesh, (ls) => { ls.reverseInPlace(); chains.push(ls); });\n        for (const c of chains) {\n            const points = c.points;\n            let rejected = false;\n            if (!c.isPhysicallyClosed)\n                rejected = true;\n            else if (options.maxEdgesAroundHole !== undefined && points.length > options.maxEdgesAroundHole)\n                rejected = true;\n            else if (options.maxPerimeter !== undefined && Point3dArray.sumEdgeLengths(points, false) > options.maxPerimeter)\n                rejected = true;\n            else if (options.upVector !== undefined && PolygonOps.sumTriangleAreasPerpendicularToUpVector(points, options.upVector) <= 0.0)\n                rejected = true;\n            if (!rejected && SpacePolygonTriangulation.triangulateSimplestSpaceLoop(points, (_loop, triangles) => {\n                for (const t of triangles)\n                    builder.addPolygon(t);\n            })) {\n            }\n            else {\n                rejected = true;\n            }\n            if (rejected && unfilledChains !== undefined)\n                unfilledChains.push(c); // yes, capture it -- this scope owns the chains and has no further use for it.\n        }\n        if (options.includeOriginalMesh !== undefined && options.includeOriginalMesh) {\n            for (mesh.reset(); mesh.moveToNextFacet();)\n                builder.addFacetFromVisitor(mesh);\n        }\n        return builder.claimPolyface(true);\n    }\n    /** Clone the facets in each partition to a separate polyface.\n   *\n   */\n    static clonePartitions(polyface, partitions) {\n        if (polyface instanceof Polyface) {\n            return this.clonePartitions(polyface.createVisitor(0), partitions);\n        }\n        polyface.setNumWrap(0);\n        const polyfaces = [];\n        const options = StrokeOptions.createForFacets();\n        options.needNormals = polyface.normal !== undefined;\n        options.needParams = polyface.param !== undefined;\n        options.needColors = polyface.color !== undefined;\n        options.needTwoSided = polyface.twoSided;\n        for (const partition of partitions) {\n            const builder = PolyfaceBuilder.create(options);\n            polyface.reset();\n            for (const facetIndex of partition) {\n                polyface.moveToReadIndex(facetIndex);\n                builder.addFacetFromVisitor(polyface);\n            }\n            polyfaces.push(builder.claimPolyface(true));\n        }\n        return polyfaces;\n    }\n    /** Clone facets that pass an filter function\n     */\n    static cloneFiltered(source, filter) {\n        if (source instanceof Polyface) {\n            return this.cloneFiltered(source.createVisitor(0), filter);\n        }\n        source.setNumWrap(0);\n        const options = StrokeOptions.createForFacets();\n        options.needNormals = source.normal !== undefined;\n        options.needParams = source.param !== undefined;\n        options.needColors = source.color !== undefined;\n        options.needTwoSided = source.twoSided;\n        const builder = PolyfaceBuilder.create(options);\n        source.reset();\n        for (; source.moveToNextFacet();) {\n            if (filter(source))\n                builder.addFacetFromVisitor(source);\n        }\n        return builder.claimPolyface(true);\n    }\n    /** If the visitor's client is a polyface, simply return its point array length.\n     * If not a polyface, visit all facets to find the largest index.\n     */\n    static visitorClientPointCount(visitor) {\n        const polyface = visitor.clientPolyface();\n        if (polyface !== undefined)\n            return polyface.data.point.length;\n        visitor.reset();\n        let maxIndex = -1;\n        while (visitor.moveToNextFacet()) {\n            for (const pointIndex of visitor.pointIndex)\n                if (pointIndex > maxIndex)\n                    maxIndex = pointIndex;\n        }\n        return maxIndex + 1;\n    }\n    /** If the visitor's client is a polyface, simply return its facet count.\n     * If not a polyface, visit all facets to accumulate a count.\n     */\n    static visitorClientFacetCount(visitor) {\n        const polyface = visitor.clientPolyface();\n        if (polyface !== undefined && polyface.facetCount !== undefined)\n            return polyface.facetCount;\n        let facetCount = 0;\n        visitor.reset();\n        while (visitor.moveToNextFacet())\n            ++facetCount;\n        return facetCount;\n    }\n    /** Partition the facet set into connected components such that two adjacent facets are in the same component if and only if they are adjacent across a clustered edge.\n     * @param edgeClusters sorted and clustered edges (cf. `IndexedEdgeMatcher.sortAndCollectClusters`).\n     * @param numFacets facet count in the parent mesh. In particular, `edge.facetIndex < numFacets` for every input edge.\n     * @return collection of facet index arrays, one array per connected component\n     */\n    static partitionFacetIndicesBySortableEdgeClusters(edgeClusters, numFacets) {\n        const context = new UnionFindContext(numFacets);\n        for (const cluster of edgeClusters) {\n            if (cluster instanceof SortableEdge) {\n                // this edge does not connect anywhere.  Ignore it!!\n            }\n            else {\n                const edge0 = cluster[0];\n                for (let i = 1; i < cluster.length; i++)\n                    context.mergeSubsets(edge0.facetIndex, cluster[i].facetIndex);\n            }\n        }\n        const roots = context.collectRootIndices();\n        const facetsInComponent = [];\n        const numRoots = roots.length;\n        for (let i = 0; i < numRoots; i++) {\n            facetsInComponent.push([]);\n        }\n        for (let facetIndex = 0; facetIndex < numFacets; facetIndex++) {\n            const rootOfFacet = context.findRoot(facetIndex);\n            for (let rootIndex = 0; rootIndex < numRoots; rootIndex++) {\n                if (roots[rootIndex] === rootOfFacet) {\n                    facetsInComponent[rootIndex].push(facetIndex);\n                    break;\n                }\n            }\n        }\n        return facetsInComponent;\n    }\n    /** Partition the facet set into connected components. Each facet in a given component shares an edge only with other facets in the component (or is a boundary edge).\n     * @param polyface facets to partition\n     * @param stopAtVisibleEdges whether to further split connected components by visible edges of the polyface\n     * @return collection of facet index arrays, one per connected component\n     */\n    static partitionFacetIndicesByEdgeConnectedComponent(polyface, stopAtVisibleEdges = false) {\n        if (polyface instanceof Polyface) {\n            return this.partitionFacetIndicesByEdgeConnectedComponent(polyface.createVisitor(0), stopAtVisibleEdges);\n        }\n        polyface.setNumWrap(1);\n        const matcher = new IndexedEdgeMatcher();\n        polyface.reset();\n        let numFacets = 0;\n        while (polyface.moveToNextFacet()) {\n            const numEdges = polyface.pointCount - 1;\n            numFacets++;\n            for (let i = 0; i < numEdges; i++) {\n                if (stopAtVisibleEdges && polyface.edgeVisible[i]) {\n                }\n                else {\n                    matcher.addEdge(polyface.clientPointIndex(i), polyface.clientPointIndex(i + 1), polyface.currentReadIndex());\n                }\n            }\n        }\n        const allEdges = [];\n        matcher.sortAndCollectClusters(allEdges, allEdges, allEdges, allEdges);\n        return this.partitionFacetIndicesBySortableEdgeClusters(allEdges, numFacets);\n    }\n    /** Find segments (within the line string) which project to facets.\n     * * Assemble each input segment paired with its projected segment/point as a quad/triangle facet in a new polyface.\n     * * Input facets are ASSUMED to be convex and planar, and not overlap in the z direction.\n     */\n    static sweepLineStringToFacetsXYReturnSweptFacets(lineStringPoints, polyface) {\n        const builder = PolyfaceBuilder.create();\n        this.announceSweepLinestringToConvexPolyfaceXY(lineStringPoints, polyface, (_linestring, _segmentIndex, _polyface, _facetIndex, points) => {\n            if (points.length === 4)\n                builder.addQuadFacet(points);\n            else if (points.length === 3)\n                builder.addTriangleFacet(points);\n        });\n        return builder.claimPolyface(true);\n    }\n    /** @deprecated in 4.x. Use sweepLineStringToFacetsXYReturnSweptFacets instead. */\n    static sweepLinestringToFacetsXYreturnSweptFacets(linestringPoints, polyface) {\n        return this.sweepLineStringToFacetsXYReturnSweptFacets(linestringPoints, polyface);\n    }\n    /**\n     * Sweep the line string to intersections with a mesh.\n     * * Return collected line segments.\n     * * If no options are given, the default sweep direction is the z-axis, and chains are assembled and returned.\n     * * See [[SweepLineStringToFacetsOptions]] for input and output options, including filtering by forward/side/rear facets.\n     * * Facets are ASSUMED to be convex and planar, and not overlap in the sweep direction.\n     */\n    static sweepLineStringToFacets(linestringPoints, polyfaceOrVisitor, options) {\n        let result = [];\n        // setup default options:\n        if (options === undefined)\n            options = SweepLineStringToFacetsOptions.create(Vector3d.unitZ(), Angle.createRadians(Geometry.smallAngleRadians), // tight geometry tolerance for vertical side facets\n            true, // assemble chains\n            true, true, true); // accept all outputs\n        let chainContext;\n        if (options.assembleChains)\n            chainContext = ChainMergeContext.create();\n        const context = ClipSweptLineStringContext.create(linestringPoints, options.vectorToEye);\n        if (context) {\n            let visitor;\n            if (polyfaceOrVisitor instanceof Polyface)\n                visitor = polyfaceOrVisitor.createVisitor(0);\n            else\n                visitor = polyfaceOrVisitor;\n            const workNormal = Vector3d.createZero();\n            for (visitor.reset(); visitor.moveToNextFacet();) {\n                if (options.collectFromThisFacetNormal(PolygonOps.areaNormalGo(visitor.point, workNormal))) {\n                    context.processPolygon(visitor.point.getArray(), (pointA, pointB) => {\n                        if (chainContext !== undefined)\n                            chainContext.addSegment(pointA, pointB);\n                        else\n                            result.push(LineSegment3d.create(pointA, pointB));\n                    });\n                }\n            }\n            if (chainContext !== undefined) {\n                chainContext.clusterAndMergeVerticesXYZ();\n                result = chainContext.collectMaximalChains();\n            }\n        }\n        return result;\n    }\n    /**\n     * Sweep the line string in the z-direction to intersections with a mesh, using a search object for speedup.\n     * @param lineStringPoints input line string to drape on the mesh\n     * @param polyfaceOrVisitor mesh, or mesh visitor to traverse only part of a mesh\n     * @param searchByReadIndex object for searching facet 2D ranges tagged by mesh read index\n     * @example Using a 5x5 indexed search grid:\n     * ```\n     * const xyRange = Range2d.createFrom(myPolyface.range());\n     * const searcher = GriddedRaggedRange2dSetWithOverflow.create<number>(xyRange, 5, 5)!;\n     * for (const visitor = myPolyface.createVisitor(0); visitor.moveToNextFacet();) {\n     *   searcher.addRange(visitor.point.getRange(), visitor.currentReadIndex());\n     * }\n     * const drapedLineStrings = PolyfaceQuery.sweepLineStringToFacetsXY(lineString, myPolyface, searcher);\n     * ```\n     * @returns collected line strings\n     */\n    static sweepLineStringToFacetsXY(lineStringPoints, polyfaceOrVisitor, searchByReadIndex) {\n        const chainContext = ChainMergeContext.create();\n        const sweepVector = Vector3d.create(0, 0, 1);\n        const searchRange = Range3d.create();\n        let visitor;\n        if (polyfaceOrVisitor instanceof Polyface)\n            visitor = polyfaceOrVisitor.createVisitor(0);\n        else\n            visitor = polyfaceOrVisitor;\n        let lineStringSource;\n        if (Array.isArray(lineStringPoints))\n            lineStringSource = new Point3dArrayCarrier(lineStringPoints);\n        else\n            lineStringSource = lineStringPoints;\n        for (let i = 1; i < lineStringSource.length; i++) {\n            const point0 = lineStringSource.getPoint3dAtUncheckedPointIndex(i - 1);\n            const point1 = lineStringSource.getPoint3dAtUncheckedPointIndex(i);\n            const edgeClipper = EdgeClipData.createPointPointSweep(point0, point1, sweepVector);\n            if (edgeClipper !== undefined) {\n                Range3d.createNull(searchRange);\n                searchRange.extendPoint(point0);\n                searchRange.extendPoint(point1);\n                searchByReadIndex.searchRange2d(searchRange, (_facetRange, readIndex) => {\n                    if (visitor.moveToReadIndex(readIndex))\n                        edgeClipper.processPolygon(visitor.point, (pointA, pointB) => chainContext.addSegment(pointA, pointB));\n                    return true;\n                });\n            }\n        }\n        chainContext.clusterAndMergeVerticesXYZ();\n        return chainContext.collectMaximalChains();\n    }\n    /** Find segments (within the linestring) which project to facets.\n      * * Return collected line segments.\n      * * This calls [[sweepLineStringToFacets]] with options created by\n      *   `const options = SweepLineStringToFacetsOptions.create(Vector3d.unitZ(), Angle.createSmallAngle(),false, true, true, true);`\n      * @deprecated in 4.x. Use [[sweepLineStringToFacets]] to get further options.\n      */\n    static sweepLinestringToFacetsXYReturnLines(linestringPoints, polyface) {\n        const options = SweepLineStringToFacetsOptions.create(Vector3d.unitZ(), Angle.createSmallAngle(), false, true, true, true);\n        const result = PolyfaceQuery.sweepLineStringToFacets(linestringPoints, polyface, options);\n        return result;\n    }\n    /** Find segments (within the linestring) which project to facets.\n     * * Return chains.\n     * * This calls [[sweepLineStringToFacets]] with options created by\n     *   `const options = SweepLineStringToFacetsOptions.create(Vector3d.unitZ(), Angle.createSmallAngle(),true, true, true, true);`\n     * @deprecated in 4.x. Use [[sweepLineStringToFacets]] to get further options.\n     */\n    static sweepLinestringToFacetsXYReturnChains(linestringPoints, polyface) {\n        const options = SweepLineStringToFacetsOptions.create(Vector3d.unitZ(), Angle.createSmallAngle(), true, true, true, true);\n        const result = PolyfaceQuery.sweepLineStringToFacets(linestringPoints, polyface, options);\n        return result;\n    }\n    /** Find segments (within the linestring) which project to facets.\n     * * This is done as a sequence of \"await\" steps.\n     * * Each \"await\" step deals with approximately PolyfaceQuery.asyncWorkLimit pairings of (linestring edge) with (facet edge)\n     * * PolyfaceQuery.setAsyncWorkLimit() to change work blocks from default\n     * * Return chains.\n     * * Facets are ASSUMED to be convex and planar, and not overlap in the z direction.\n     */\n    static async asyncSweepLinestringToFacetsXYReturnChains(linestringPoints, polyface) {\n        const chainContext = ChainMergeContext.create();\n        await Promise.resolve(this.asyncAnnounceSweepLinestringToConvexPolyfaceXY(linestringPoints, polyface, (_linestring, _segmentIndex, _polyface, _facetIndex, points, indexA, indexB) => {\n            chainContext.addSegment(points[indexA], points[indexB]);\n        }));\n        chainContext.clusterAndMergeVerticesXYZ();\n        const chains = chainContext.collectMaximalChains();\n        return chains;\n    }\n    /**\n     * * Examine ranges of facets.\n     * * Return statistical summary of x,y,z ranges.\n     */\n    static collectRangeLengthData(polyface) {\n        if (polyface instanceof Polyface) {\n            return this.collectRangeLengthData(polyface.createVisitor(0));\n        }\n        const rangeData = new RangeLengthData();\n        // polyface is a visitor ...\n        for (polyface.reset(); polyface.moveToNextFacet();)\n            rangeData.accumulateGrowableXYZArrayRange(polyface.point);\n        return rangeData;\n    }\n    /** Clone the facets, inserting vertices (within edges) where points not part of each facet's vertex indices impinge within edges.\n     *\n     */\n    static cloneWithTVertexFixup(polyface) {\n        const oldFacetVisitor = polyface.createVisitor(1); // This is to visit the existing facets.\n        const newFacetVisitor = polyface.createVisitor(0); // This is to build the new facets.\n        const rangeSearcher = XYPointBuckets.create(polyface.data.point, 30);\n        const builder = PolyfaceBuilder.create();\n        const edgeRange = Range3d.createNull();\n        const point0 = Point3d.create();\n        const point1 = Point3d.create();\n        const spacePoint = Point3d.create();\n        const segment = LineSegment3d.create(point0, point1);\n        for (oldFacetVisitor.reset(); oldFacetVisitor.moveToNextFacet();) {\n            newFacetVisitor.clearArrays();\n            for (let i = 0; i + 1 < oldFacetVisitor.point.length; i++) {\n                // each base vertex is part of the result ...\n                oldFacetVisitor.point.getPoint3dAtUncheckedPointIndex(i, point0);\n                oldFacetVisitor.point.getPoint3dAtUncheckedPointIndex(i + 1, point1);\n                newFacetVisitor.pushDataFrom(oldFacetVisitor, i);\n                edgeRange.setNull();\n                LineSegment3d.create(point0, point1, segment);\n                let detailArray;\n                edgeRange.extend(point0);\n                edgeRange.extend(point1);\n                rangeSearcher.announcePointsInRange(edgeRange, (index, _x, _y, _z) => {\n                    // x,y,z has x,y within the range of the search ... test for exact on (in full 3d!)\n                    polyface.data.point.getPoint3dAtUncheckedPointIndex(index, spacePoint);\n                    const detail = segment.closestPoint(spacePoint, false);\n                    if (undefined !== detail) {\n                        if (detail.fraction >= 0.0 && detail.fraction < 1.0 && !detail.point.isAlmostEqual(point0) && !detail.point.isAlmostEqual(point1)\n                            && spacePoint.isAlmostEqual(detail.point)) {\n                            if (detailArray === undefined)\n                                detailArray = [];\n                            detail.a = index;\n                            detailArray.push(detail);\n                        }\n                    }\n                    return true;\n                });\n                if (detailArray !== undefined) {\n                    detailArray.sort((a, b) => (a.fraction - b.fraction));\n                    for (const d of detailArray) {\n                        newFacetVisitor.pushInterpolatedDataFrom(oldFacetVisitor, i, d.fraction, i + 1);\n                    }\n                }\n            }\n            builder.addFacetFromGrowableArrays(newFacetVisitor.point, newFacetVisitor.normal, newFacetVisitor.param, newFacetVisitor.color, newFacetVisitor.edgeVisible);\n        }\n        return builder.claimPolyface();\n    }\n    /**\n     * * Each array input structure is: [facetIndex, vertexIndex0, vertexIndex1, ....]\n     * * Vertex indices assumed reversed so it\n     *   * vertexIndex0 is the lowest index on the facet\n     *   * vertexIndex1 is the lowest neighbor of vertex0\n     *   * first different entry among vertex indices determines lexical result.\n     *   * Hence facets with duplicate indices (whether forward or reversed) are considered equal.\n     * @param arrayA\n     * @param arrayB\n     */\n    static compareFacetIndexAndVertexIndices(arrayA, arrayB) {\n        if (arrayA.length !== arrayB.length)\n            return arrayA.length - arrayB.length;\n        for (let i = 1; i < arrayA.length; i++) {\n            if (arrayA[i] !== arrayB[i]) {\n                return arrayA[i] - arrayB[i];\n            }\n        }\n        return 0;\n    }\n    /**\n     * * Return an array of arrays describing facet duplication.\n     * @param includeSingletons if true, non-duplicated facets are included in the output.\n     * * Each array `entry` in the output contains read indices of a cluster of facets with the same vertex indices.\n     */\n    static collectDuplicateFacetIndices(polyface, includeSingletons = false) {\n        const result = [];\n        this.announceDuplicateFacetIndices(polyface, (clusterFacetIndices) => {\n            if (includeSingletons || clusterFacetIndices.length > 1)\n                result.push(clusterFacetIndices.slice());\n        });\n        return result;\n    }\n    /**\n     * * Return an array of arrays describing facet duplication.\n     * @param includeSingletons if true, non-duplicated facets are included in the output.\n     * * Each array `entry` in the output contains read indices of a cluster of facets with the same vertex indices.\n     */\n    static announceDuplicateFacetIndices(polyface, announceCluster) {\n        const visitor = polyface.createVisitor(0); // This is to visit the existing facets.\n        const facetIndexAndVertexIndices = [];\n        for (visitor.reset(); visitor.moveToNextFacet();) {\n            const facetIndex = visitor.currentReadIndex();\n            const entry = [facetIndex];\n            const pointIndex = visitor.pointIndex;\n            const numPointsThisFacet = pointIndex.length;\n            let lowIndex = 0;\n            // find the lowest point index ...\n            for (let i = 1; i < visitor.pointIndex.length; i++) {\n                if (pointIndex[i] < pointIndex[lowIndex])\n                    lowIndex = i;\n            }\n            // find its lowest neighbor -- assemble sort array in that direction\n            if (pointIndex[(lowIndex + 1) % numPointsThisFacet] < pointIndex[(lowIndex + numPointsThisFacet - 1) % numPointsThisFacet]) {\n                for (let i = 0; i < numPointsThisFacet; i++) {\n                    entry.push(pointIndex[(lowIndex + i) % numPointsThisFacet]);\n                }\n            }\n            else {\n                for (let i = 0; i < numPointsThisFacet; i++) {\n                    entry.push(pointIndex[(lowIndex + numPointsThisFacet - i) % numPointsThisFacet]);\n                }\n            }\n            facetIndexAndVertexIndices.push(entry);\n        }\n        facetIndexAndVertexIndices.sort((arrayA, arrayB) => this.compareFacetIndexAndVertexIndices(arrayA, arrayB));\n        let i0, i1;\n        const n = facetIndexAndVertexIndices.length;\n        const clusterArray = [];\n        for (i0 = 0; i0 < n; i0 = i1) {\n            i1 = i0 + 1;\n            clusterArray.length = 0;\n            clusterArray.push(facetIndexAndVertexIndices[i0][0]);\n            while (i1 < n && 0 === this.compareFacetIndexAndVertexIndices(facetIndexAndVertexIndices[i0], facetIndexAndVertexIndices[i1])) {\n                clusterArray.push(facetIndexAndVertexIndices[i1][0]);\n                i1++;\n            }\n            announceCluster(clusterArray);\n        }\n    }\n    /** Return a new facet set with a subset of facets in source\n     * @param includeSingletons true to copy facets that only appear once\n     * @param clusterSelector indicates whether duplicate clusters are to have 0, 1, or all facets included\n     */\n    static cloneByFacetDuplication(source, includeSingletons, clusterSelector) {\n        const builder = PolyfaceBuilder.create();\n        const visitor = source.createVisitor(0);\n        this.announceDuplicateFacetIndices(source, (clusterFacetIndices) => {\n            let numToSelect = 0;\n            if (clusterFacetIndices.length === 1) {\n                if (includeSingletons)\n                    numToSelect = 1;\n            }\n            else if (clusterFacetIndices.length > 1) {\n                if (clusterSelector === DuplicateFacetClusterSelector.SelectAny)\n                    numToSelect = 1;\n                else if (clusterSelector === DuplicateFacetClusterSelector.SelectAll)\n                    numToSelect = clusterFacetIndices.length;\n                else if (clusterSelector === DuplicateFacetClusterSelector.SelectOneByParity)\n                    numToSelect = (clusterFacetIndices.length & 0x01) === 0x01 ? 1 : 0;\n            }\n            for (let i = 0; i < numToSelect; i++) {\n                visitor.moveToReadIndex(clusterFacetIndices[i]);\n                builder.addFacetFromVisitor(visitor);\n            }\n        });\n        return builder.claimPolyface();\n    }\n    /** Clone the facets, inserting removing points that are simply within colinear edges.\n     *\n     */\n    static cloneWithColinearEdgeFixup(polyface) {\n        const oldFacetVisitor = polyface.createVisitor(2); // This is to visit the existing facets.\n        const newFacetVisitor = polyface.createVisitor(0); // This is to build the new facets.\n        const builder = PolyfaceBuilder.create();\n        const vector01 = Vector3d.create();\n        const vector12 = Vector3d.create();\n        const numPoint = polyface.data.point.length;\n        const pointState = new Int32Array(numPoint);\n        // FIRST PASS -- in each sector of each facet, determine if the sector has colinear incoming and outgoing vectors.\n        //   Mark each point as\n        //  0 unvisited\n        // -1 incident to a non-colinear sector\n        //  n incident to n colinear sectors\n        for (oldFacetVisitor.reset(); oldFacetVisitor.moveToNextFacet();) {\n            for (let i = 0; i + 2 < oldFacetVisitor.point.length; i++) {\n                // each base vertex is part of the result ...\n                oldFacetVisitor.point.vectorIndexIndex(i, i + 1, vector01);\n                oldFacetVisitor.point.vectorIndexIndex(i + 1, i + 2, vector12);\n                const pointIndex = oldFacetVisitor.clientPointIndex(i + 1);\n                if (pointState[pointIndex] >= 0) {\n                    const theta = vector01.angleTo(vector12);\n                    if (theta.isAlmostZero) {\n                        pointState[pointIndex]++;\n                    }\n                    else {\n                        pointState[pointIndex] = -1;\n                    }\n                }\n            }\n        }\n        // SECOND PASS -- make copies, omitting references to points at colinear sectors\n        for (oldFacetVisitor.reset(); oldFacetVisitor.moveToNextFacet();) {\n            newFacetVisitor.clearArrays();\n            for (let i = 0; i + 2 < oldFacetVisitor.point.length; i++) {\n                const pointIndex = oldFacetVisitor.clientPointIndex(i);\n                if (pointState[pointIndex] < 0) {\n                    newFacetVisitor.pushDataFrom(oldFacetVisitor, i);\n                }\n            }\n            if (newFacetVisitor.point.length > 2)\n                builder.addFacetFromGrowableArrays(newFacetVisitor.point, newFacetVisitor.normal, newFacetVisitor.param, newFacetVisitor.color, newFacetVisitor.edgeVisible);\n        }\n        return builder.claimPolyface();\n    }\n    /**\n     * Set the edge visibility for specified edges in the polyface.\n     * @param polyface mesh to be edited\n     * @param clusters array of edge references\n     * @param value visibility value (true or false)\n     */\n    static setEdgeVisibility(polyface, clusters, value) {\n        for (const cluster of clusters) {\n            if (cluster instanceof SortableEdge) {\n                this.setSingleEdgeVisibility(polyface, cluster.facetIndex, cluster.vertexIndexA, value);\n            }\n            else if (Array.isArray(cluster)) {\n                for (const e1 of cluster)\n                    this.setSingleEdgeVisibility(polyface, e1.facetIndex, e1.vertexIndexA, value);\n            }\n        }\n    }\n    /**\n     * Set the visibility of a particular edge of a particular facet.\n     * @param polyface containing polyface\n     * @param facetIndex facet index\n     * @param vertexIndex vertex index (in vertex array) at which the edge starts\n     * @param value visibility value.\n     */\n    static setSingleEdgeVisibility(polyface, facetIndex, vertexIndex, value) {\n        const data = polyface.data;\n        const index0 = polyface.facetIndex0(facetIndex);\n        const index1 = polyface.facetIndex1(facetIndex);\n        for (let i = index0; i < index1; i++)\n            if (data.pointIndex[i] === vertexIndex)\n                data.edgeVisible[i] = value; // actually sets visibility on all edges in the face that start at this vertex\n    }\n    /**\n     * Get the visibility of a particular edge of a particular facet.\n     * @param polyface containing polyface\n     * @param facetIndex facet index\n     * @param vertexIndex vertex index (in vertex array) at which the edge starts\n     */\n    static getSingleEdgeVisibility(polyface, facetIndex, vertexIndex) {\n        const data = polyface.data;\n        const index0 = polyface.facetIndex0(facetIndex);\n        const index1 = polyface.facetIndex1(facetIndex);\n        for (let i = index0; i < index1; i++)\n            if (data.pointIndex[i] === vertexIndex)\n                return data.edgeVisible[i]; // return visibility of first edge in the face that starts at this vertex\n        return undefined;\n    }\n    /** Load all half edges from a mesh to an IndexedEdgeMatcher.\n     * @param polyface a mesh, or a visitor assumed to have numWrap === 1\n    */\n    static createIndexedEdges(polyface) {\n        if (polyface instanceof Polyface)\n            return this.createIndexedEdges(polyface.createVisitor(1));\n        const edges = new IndexedEdgeMatcher();\n        polyface.reset();\n        while (polyface.moveToNextFacet()) {\n            const numEdges = polyface.pointCount - 1;\n            for (let i = 0; i < numEdges; i++) {\n                edges.addEdge(polyface.clientPointIndex(i), polyface.clientPointIndex(i + 1), polyface.currentReadIndex());\n            }\n        }\n        return edges;\n    }\n    /**\n     * Return manifold edge pairs whose dihedral angle is bounded by the given angle.\n     * * The dihedral angle of a manifold edge is measured between the normals of its two adjacent faces.\n     * * Boundary edges are not returned as they are not manifold.\n     * @param mesh existing polyface or visitor\n     * @param maxSmoothEdgeAngle maximum dihedral angle of a smooth edge. If undefined, uses `Geometry.smallAngleRadians`.\n     * @param sharpEdges true to reverse the angle threshold test and return sharp edges; otherwise return smooth edges (default)\n     */\n    static collectEdgesByDihedralAngle(mesh, maxSmoothEdgeAngle, sharpEdges = false) {\n        if (mesh instanceof Polyface)\n            return this.collectEdgesByDihedralAngle(mesh.createVisitor(1), maxSmoothEdgeAngle, sharpEdges);\n        mesh.setNumWrap(1);\n        const allEdges = this.createIndexedEdges(mesh);\n        const manifoldEdges = [];\n        allEdges.sortAndCollectClusters(manifoldEdges);\n        if (undefined === maxSmoothEdgeAngle || maxSmoothEdgeAngle.radians < 0)\n            maxSmoothEdgeAngle = Angle.createRadians(Geometry.smallAngleRadians);\n        const outEdges = [];\n        const normal0 = Vector3d.create();\n        const normal1 = Vector3d.create();\n        for (const pair of manifoldEdges) {\n            if (Array.isArray(pair) && pair.length === 2) {\n                const e0 = pair[0];\n                const e1 = pair[1];\n                if (undefined !== PolyfaceQuery.computeFacetUnitNormal(mesh, e0.facetIndex, normal0)\n                    && undefined !== PolyfaceQuery.computeFacetUnitNormal(mesh, e1.facetIndex, normal1)) {\n                    const edgeAngle = normal0.smallerUnorientedAngleTo(normal1);\n                    if (sharpEdges) {\n                        if (edgeAngle.radians > maxSmoothEdgeAngle.radians)\n                            outEdges.push(pair);\n                    }\n                    else {\n                        if (edgeAngle.radians <= maxSmoothEdgeAngle.radians)\n                            outEdges.push(pair);\n                    }\n                }\n            }\n        }\n        return outEdges;\n    }\n    /**\n    * * Find mated pairs among facet edges.\n    * * Mated pairs have the same vertex indices appearing in opposite order.\n    * * Mark all non-mated pairs visible.\n    * * At mated pairs\n    *    * if angle across the edge is larger than `sharpEdgeAngle`, mark visible\n    *    * otherwise mark invisible.\n    * @param mesh mesh to be marked\n    */\n    static markPairedEdgesInvisible(mesh, sharpEdgeAngle) {\n        const visitor = mesh.createVisitor(1);\n        const edges = this.createIndexedEdges(visitor);\n        const pairedEdges = [];\n        const boundaryEdges = [];\n        edges.sortAndCollectClusters(pairedEdges, boundaryEdges, boundaryEdges, boundaryEdges);\n        this.markAllEdgeVisibility(mesh, false);\n        this.setEdgeVisibility(mesh, boundaryEdges, true);\n        if (sharpEdgeAngle !== undefined) {\n            const normal0 = Vector3d.create();\n            const normal1 = Vector3d.create();\n            for (const pair of pairedEdges) {\n                if (Array.isArray(pair) && pair.length === 2) {\n                    const e0 = pair[0];\n                    const e1 = pair[1];\n                    if (undefined !== PolyfaceQuery.computeFacetUnitNormal(visitor, e0.facetIndex, normal0)\n                        && undefined !== PolyfaceQuery.computeFacetUnitNormal(visitor, e1.facetIndex, normal1)) {\n                        const edgeAngle = normal0.smallerUnorientedAngleTo(normal1);\n                        if (edgeAngle.radians > sharpEdgeAngle.radians) {\n                            this.setSingleEdgeVisibility(mesh, e0.facetIndex, e0.vertexIndexA, true);\n                            this.setSingleEdgeVisibility(mesh, e1.facetIndex, e1.vertexIndexA, true);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    /** Try to compute a unit normal for a facet accessible through a visitor.\n     * * Unit normal is computed by `PolygonOps.unitNormal` with the points around the facet.\n     */\n    static computeFacetUnitNormal(visitor, facetIndex, result) {\n        if (!result)\n            result = Vector3d.create();\n        if (visitor.moveToReadIndex(facetIndex)) {\n            if (PolygonOps.unitNormal(visitor.point, result))\n                return result;\n        }\n        return undefined;\n    }\n    /**\n    * * Mark all edge visibilities in the IndexedPolyface\n    * @param mesh mesh to be marked\n    * @param value true for visible, false for hidden\n    */\n    static markAllEdgeVisibility(mesh, value) {\n        const data = mesh.data;\n        for (let i = 0; i < data.edgeVisible.length; i++)\n            data.edgeVisible[i] = value;\n    }\n    /**\n     * Create a HalfEdgeGraph with a face for each facet of the IndexedPolyface\n     * @param mesh mesh to convert\n     * @internal\n     */\n    static convertToHalfEdgeGraph(mesh) {\n        const builder = new HalfEdgeGraphFromIndexedLoopsContext();\n        const visitor = mesh.createVisitor(0);\n        for (visitor.reset(); visitor.moveToNextFacet();) {\n            builder.insertLoop(visitor.pointIndex);\n        }\n        const graph = builder.graph;\n        const xyz = Point3d.create();\n        graph.announceNodes((_graph, halfEdge) => {\n            const vertexIndex = halfEdge.i;\n            mesh.data.getPoint(vertexIndex, xyz);\n            halfEdge.setXYZ(xyz);\n            return true;\n        });\n        return graph;\n    }\n    /**\n     * * Examine adjacent facet orientations throughout the mesh\n     * * If possible, reverse a subset to achieve proper pairing.\n     * @param mesh\n     */\n    static reorientVertexOrderAroundFacetsForConsistentOrientation(mesh) {\n        return FacetOrientationFixup.doFixup(mesh);\n    }\n    /**\n     * Set up indexed normals with one normal in the plane of each facet of the mesh.\n     * @param polyface\n     */\n    static buildPerFaceNormals(polyface) {\n        BuildAverageNormalsContext.buildPerFaceNormals(polyface);\n    }\n    /**\n    * * At each vertex of the mesh\n    *   * Find clusters of almost parallel normals\n    *   * Compute simple average of those normals\n    *   * Index to the averages\n    * * For typical meshes, this correctly clusters adjacent normals.\n    * * One can imagine a vertex with multiple \"smooth cone-like\" sets of incident facets such that averaging occurs among two nonadjacent cones.  But this does not seem to be a problem in practice.\n    * @param polyface polyface to update.\n    * @param toleranceAngle averaging is done between normals up to this angle.\n    */\n    static buildAverageNormals(polyface, toleranceAngle = Angle.createDegrees(31.0)) {\n        BuildAverageNormalsContext.buildFastAverageNormals(polyface, toleranceAngle);\n    }\n    /**\n     * Offset the faces of the mesh.\n     * @param source original mesh\n     * @param signedOffsetDistance distance to offset\n     * @param offsetOptions angle options.  The default options are recommended.\n     * @returns shifted mesh.\n     */\n    static cloneOffset(source, signedOffsetDistance, offsetOptions = OffsetMeshOptions.create()) {\n        const strokeOptions = StrokeOptions.createForFacets();\n        const offsetBuilder = PolyfaceBuilder.create(strokeOptions);\n        OffsetMeshContext.buildOffsetMeshWithEdgeChamfers(source, offsetBuilder, signedOffsetDistance, offsetOptions);\n        return offsetBuilder.claimPolyface();\n    }\n    /** Search facets for the first one that intersects the infinite line.\n     * * To process _all_ intersections, callers can supply an `options.acceptIntersection` callback that always returns false.\n     * In this case, `intersectRay3d` will return undefined, but the callback will be invoked for each intersection.\n     * * Example callback logic:\n     *    * Accept the first found facet that intersects the half-line specified by the ray: `return detail.a >= 0.0;`\n     *    * Collect all intersections: `myIntersections.push(detail.clone()); return false;` Then after `intersectRay3d` returns, sort along `ray` with `myIntersections.sort((d0, d1) => d0.a - d1.a);`\n     * @param visitor facet iterator\n     * @param ray infinite line parameterized as a ray. The returned `detail.a` is the intersection parameter on the ray, e.g., zero at `ray.origin` and increasing in `ray.direction`.\n     * @param options options for computing and populating an intersection detail, and an optional callback for accepting one\n     * @return detail for the (accepted) intersection with `detail.IsInsideOrOn === true`, or `undefined` if no (accepted) intersection\n     * @see PolygonOps.intersectRay3d\n    */\n    static intersectRay3d(visitor, ray, options) {\n        if (visitor instanceof Polyface)\n            return PolyfaceQuery.intersectRay3d(visitor.createVisitor(0), ray, options);\n        let detail;\n        visitor.setNumWrap(0);\n        while (visitor.moveToNextFacet()) {\n            const numEdges = visitor.pointCount; // #vertices = #edges since numWrap is zero\n            const vertices = visitor.point;\n            if (3 === numEdges) {\n                const tri = this._workTriangle = BarycentricTriangle.create(vertices.getPoint3dAtUncheckedPointIndex(0), vertices.getPoint3dAtUncheckedPointIndex(1), vertices.getPoint3dAtUncheckedPointIndex(2), this._workTriangle);\n                const detail3 = this._workTriDetail = tri.intersectRay3d(ray, this._workTriDetail);\n                tri.snapLocationToEdge(detail3, options?.distanceTolerance, options?.parameterTolerance);\n                detail = this._workFacetDetail3 = TriangularFacetLocationDetail.create(visitor.currentReadIndex(), detail3, this._workFacetDetail3);\n            }\n            else {\n                const detailN = this._workPolyDetail = PolygonOps.intersectRay3d(vertices, ray, options?.distanceTolerance, this._workPolyDetail);\n                if (PolygonOps.isConvex(vertices))\n                    detail = this._workFacetDetailC = ConvexFacetLocationDetail.create(visitor.currentReadIndex(), numEdges, detailN, this._workFacetDetailC);\n                else\n                    detail = this._workFacetDetailNC = NonConvexFacetLocationDetail.create(visitor.currentReadIndex(), numEdges, detailN, this._workFacetDetailNC);\n            }\n            if (detail.isInsideOrOn) { // set optional caches, process the intersection\n                if (options?.needNormal && visitor.normal)\n                    detail.getNormal(visitor.normal, vertices, options?.distanceTolerance);\n                if (options?.needParam && visitor.param)\n                    detail.getParam(visitor.param, vertices, options?.distanceTolerance);\n                if (options?.needColor && visitor.color)\n                    detail.getColor(visitor.color, vertices, options?.distanceTolerance);\n                if (options?.needBarycentricCoordinates)\n                    detail.getBarycentricCoordinates(vertices, options?.distanceTolerance);\n                if (options?.acceptIntersection && !options.acceptIntersection(detail, visitor))\n                    continue;\n                return detail;\n            }\n        }\n        return undefined; // no intersection\n    }\n}\n// amount of computation to do per step of async methods.\nPolyfaceQuery._asyncWorkLimit = 1.e06;\n/** Number of \"await\" steps executed in recent async calls.\n * @internal\n */\nPolyfaceQuery.awaitBlockCount = 0;\nexport { PolyfaceQuery };\n//# sourceMappingURL=PolyfaceQuery.js.map",
      "start": 1693508123954,
      "end": 1693508124177,
      "sourcemaps": null
    }
  ]
}
