{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/InstancedGeometry.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { assert, dispose } from \"@itwin/core-bentley\";\nimport { Point3d, Range3d, Transform } from \"@itwin/core-geometry\";\nimport { AttributeMap } from \"./AttributeMap\";\nimport { CachedGeometry } from \"./CachedGeometry\";\nimport { GL } from \"./GL\";\nimport { BufferHandle, BufferParameters, BuffersContainer } from \"./AttributeBuffers\";\nimport { Matrix4 } from \"./Matrix\";\n/** @internal */\nexport function isInstancedGraphicParams(params) {\n    return typeof params === \"object\" && typeof params.count === \"number\" && params.transforms instanceof Float32Array && params.transformCenter instanceof Point3d;\n}\nclass InstanceData {\n    constructor(numInstances, rtcCenter, range) {\n        // The model matrix from which _rtcModelTransform was previously computed. If it changes, _rtcModelTransform must be recomputed.\n        this._modelMatrix = Transform.createIdentity();\n        this.numInstances = numInstances;\n        this.range = range;\n        this._rtcOnlyTransform = Transform.createTranslation(rtcCenter);\n        this._rtcModelTransform = this._rtcOnlyTransform.clone();\n    }\n    getRtcModelTransform(modelMatrix) {\n        if (!this._modelMatrix.isAlmostEqual(modelMatrix)) {\n            modelMatrix.clone(this._modelMatrix);\n            modelMatrix.multiplyTransformTransform(this._rtcOnlyTransform, this._rtcModelTransform);\n        }\n        return this._rtcModelTransform;\n    }\n    getRtcOnlyTransform() {\n        return this._rtcOnlyTransform;\n    }\n    get patternFeatureId() {\n        return InstanceData._noFeatureId;\n    }\n}\nInstanceData._noFeatureId = new Float32Array([0, 0, 0]);\n/** @internal */\nclass InstanceBuffers extends InstanceData {\n    constructor(count, transforms, rtcCenter, range, symbology, featureIds) {\n        super(count, rtcCenter, range);\n        this.patternParams = InstanceBuffers._patternParams;\n        this.patternTransforms = undefined;\n        this.viewIndependentOrigin = undefined;\n        this.transforms = transforms;\n        this.featureIds = featureIds;\n        this.hasFeatures = undefined !== featureIds;\n        this.symbology = symbology;\n    }\n    static createTransformBufferParameters(techniqueId) {\n        const params = [];\n        const numRows = 3;\n        let row = 0;\n        while (row < numRows) {\n            // 3 rows per instance; 4 floats per row; 4 bytes per float.\n            const floatsPerRow = 4;\n            const bytesPerVertex = floatsPerRow * 4;\n            const offset = row * bytesPerVertex;\n            const stride = 3 * bytesPerVertex;\n            const name = `a_instanceMatrixRow${row}`;\n            const details = AttributeMap.findAttribute(name, techniqueId, true);\n            assert(details !== undefined);\n            const bParams = {\n                glAttribLoc: details.location,\n                glSize: floatsPerRow,\n                glType: GL.DataType.Float,\n                glNormalized: false,\n                glStride: stride,\n                glOffset: offset,\n                glInstanced: true,\n            };\n            params.push(bParams);\n            row++;\n        }\n        return params;\n    }\n    static create(params, range) {\n        const { count, featureIds, symbologyOverrides, transforms } = params;\n        assert(count > 0 && Math.floor(count) === count);\n        assert(count === transforms.length / 12);\n        assert(undefined === featureIds || count === featureIds.length / 3);\n        assert(undefined === symbologyOverrides || count * 8 === symbologyOverrides.length);\n        let idBuf;\n        if (undefined !== featureIds && undefined === (idBuf = BufferHandle.createArrayBuffer(featureIds)))\n            return undefined;\n        let symBuf;\n        if (undefined !== symbologyOverrides && undefined === (symBuf = BufferHandle.createArrayBuffer(symbologyOverrides)))\n            return undefined;\n        const tfBuf = BufferHandle.createArrayBuffer(transforms);\n        return undefined !== tfBuf ? new InstanceBuffers(count, tfBuf, params.transformCenter, range, symBuf, idBuf) : undefined;\n    }\n    get isDisposed() {\n        return this.transforms.isDisposed\n            && (undefined === this.featureIds || this.featureIds.isDisposed)\n            && (undefined === this.symbology || this.symbology.isDisposed);\n    }\n    dispose() {\n        dispose(this.transforms);\n        dispose(this.featureIds);\n        dispose(this.symbology);\n    }\n    collectStatistics(stats) {\n        const featureBytes = undefined !== this.featureIds ? this.featureIds.bytesUsed : 0;\n        const symBytes = undefined !== this.symbology ? this.symbology.bytesUsed : 0;\n        const bytesUsed = this.transforms.bytesUsed + symBytes + featureBytes;\n        stats.addInstances(bytesUsed);\n    }\n    static extendTransformedRange(tfs, i, range, x, y, z) {\n        range.extendXYZ(tfs[i + 3] + tfs[i + 0] * x + tfs[i + 1] * y + tfs[i + 2] * z, tfs[i + 7] + tfs[i + 4] * x + tfs[i + 5] * y + tfs[i + 6] * z, tfs[i + 11] + tfs[i + 8] * x + tfs[i + 9] * y + tfs[i + 10] * z);\n    }\n    static computeRange(reprRange, tfs, rtcCenter, out) {\n        const range = out ?? new Range3d();\n        const numFloatsPerTransform = 3 * 4;\n        assert(0 === tfs.length % (3 * 4));\n        for (let i = 0; i < tfs.length; i += numFloatsPerTransform) {\n            this.extendTransformedRange(tfs, i, range, reprRange.low.x, reprRange.low.y, reprRange.low.z);\n            this.extendTransformedRange(tfs, i, range, reprRange.low.x, reprRange.low.y, reprRange.high.z);\n            this.extendTransformedRange(tfs, i, range, reprRange.low.x, reprRange.high.y, reprRange.low.z);\n            this.extendTransformedRange(tfs, i, range, reprRange.low.x, reprRange.high.y, reprRange.high.z);\n            this.extendTransformedRange(tfs, i, range, reprRange.high.x, reprRange.low.y, reprRange.low.z);\n            this.extendTransformedRange(tfs, i, range, reprRange.high.x, reprRange.low.y, reprRange.high.z);\n            this.extendTransformedRange(tfs, i, range, reprRange.high.x, reprRange.high.y, reprRange.low.z);\n            this.extendTransformedRange(tfs, i, range, reprRange.high.x, reprRange.high.y, reprRange.high.z);\n        }\n        range.low.addInPlace(rtcCenter);\n        range.high.addInPlace(rtcCenter);\n        return range.clone(out);\n    }\n}\nInstanceBuffers._patternParams = new Float32Array([0, 0, 0, 0]);\nexport { InstanceBuffers };\n/** @internal */\nexport class PatternBuffers extends InstanceData {\n    constructor(count, rtcCenter, range, patternParams, // [ isAreaPattern, spacingX, spacingY, scale ]\n    origin, // [ x, y ]\n    orgTransform, localToModel, symbolToLocal, offsets, featureId, viewIndependentOrigin) {\n        super(count, rtcCenter, range);\n        this.patternParams = patternParams;\n        this.origin = origin;\n        this.orgTransform = orgTransform;\n        this.localToModel = localToModel;\n        this.symbolToLocal = symbolToLocal;\n        this.offsets = offsets;\n        this.viewIndependentOrigin = viewIndependentOrigin;\n        this.patternTransforms = this;\n        if (undefined !== featureId) {\n            this._featureId = new Float32Array([\n                (featureId & 0x0000ff) >>> 0,\n                (featureId & 0x00ff00) >>> 8,\n                (featureId & 0xff0000) >>> 16,\n            ]);\n        }\n    }\n    static create(params) {\n        const count = params.xyOffsets.byteLength / 2;\n        assert(Math.floor(count) === count);\n        const offsets = BufferHandle.createArrayBuffer(params.xyOffsets);\n        if (!offsets)\n            return undefined;\n        return new PatternBuffers(count, new Point3d(), params.range, new Float32Array([1, params.spacing.x, params.spacing.y, params.scale]), new Float32Array([params.origin.x, params.origin.y]), Matrix4.fromTransform(params.orgTransform), Matrix4.fromTransform(params.patternToModel), Matrix4.fromTransform(Transform.createTranslation(params.symbolTranslation)), offsets, params.featureId, params.viewIndependentOrigin);\n    }\n    get hasFeatures() {\n        return undefined !== this._featureId;\n    }\n    get patternFeatureId() {\n        return this._featureId ?? super.patternFeatureId;\n    }\n    get isDisposed() {\n        return this.offsets.isDisposed;\n    }\n    dispose() {\n        dispose(this.offsets);\n    }\n    collectStatistics(stats) {\n        stats.addInstances(this.offsets.bytesUsed);\n    }\n}\n/** @internal */\nexport class InstancedGeometry extends CachedGeometry {\n    getRtcModelTransform(modelMatrix) { return this._buffers.getRtcModelTransform(modelMatrix); }\n    getRtcOnlyTransform() { return this._buffers.getRtcOnlyTransform(); }\n    get viewIndependentOrigin() { return this._buffers.viewIndependentOrigin; }\n    get asInstanced() { return this; }\n    get asLUT() { return this._repr.asLUT; }\n    get asMesh() { return this._repr.asMesh; }\n    get asSurface() { return this._repr.asSurface; }\n    get asEdge() { return this._repr.asEdge; }\n    get asSilhouette() { return this._repr.asSilhouette; }\n    get asIndexedEdge() { return this._repr.asIndexedEdge; }\n    get renderOrder() { return this._repr.renderOrder; }\n    get isLitSurface() { return this._repr.isLitSurface; }\n    get hasBakedLighting() { return this._repr.hasBakedLighting; }\n    get hasAnimation() { return this._repr.hasAnimation; }\n    get qOrigin() { return this._repr.qOrigin; }\n    get qScale() { return this._repr.qScale; }\n    get materialInfo() { return this._repr.materialInfo; }\n    get polylineBuffers() { return this._repr.polylineBuffers; }\n    get isEdge() { return this._repr.isEdge; }\n    get hasFeatures() { return this._buffers.hasFeatures; }\n    get techniqueId() { return this._repr.techniqueId; }\n    get supportsThematicDisplay() { return this._repr.supportsThematicDisplay; }\n    getPass(target) { return this._repr.getPass(target); }\n    wantWoWReversal(params) { return this._repr.wantWoWReversal(params); }\n    getLineCode(params) { return this._repr.getLineCode(params); }\n    getLineWeight(params) { return this._repr.getLineWeight(params); }\n    wantMonochrome(target) { return this._repr.wantMonochrome(target); }\n    wantMixMonochromeColor(target) { return this._repr.wantMixMonochromeColor(target); }\n    static create(repr, ownsBuffers, buffers) {\n        const techId = repr.techniqueId;\n        const container = BuffersContainer.create();\n        container.appendLinkages(repr.lutBuffers.linkages);\n        container.addBuffer(buffers.transforms, InstanceBuffers.createTransformBufferParameters(repr.techniqueId));\n        if (buffers.symbology) {\n            const attrInstanceOverrides = AttributeMap.findAttribute(\"a_instanceOverrides\", techId, true);\n            const attrInstanceRgba = AttributeMap.findAttribute(\"a_instanceRgba\", techId, true);\n            assert(attrInstanceOverrides !== undefined);\n            assert(attrInstanceRgba !== undefined);\n            container.addBuffer(buffers.symbology, [\n                BufferParameters.create(attrInstanceOverrides.location, 4, GL.DataType.UnsignedByte, false, 8, 0, true),\n                BufferParameters.create(attrInstanceRgba.location, 4, GL.DataType.UnsignedByte, false, 8, 4, true),\n            ]);\n        }\n        if (buffers.featureIds) {\n            const attrFeatureId = AttributeMap.findAttribute(\"a_featureId\", techId, true);\n            assert(attrFeatureId !== undefined);\n            container.addBuffer(buffers.featureIds, [BufferParameters.create(attrFeatureId.location, 3, GL.DataType.UnsignedByte, false, 0, 0, true)]);\n        }\n        return new this(repr, ownsBuffers, buffers, container);\n    }\n    static createPattern(repr, ownsBuffers, buffers) {\n        const techId = repr.techniqueId;\n        const container = BuffersContainer.create();\n        container.appendLinkages(repr.lutBuffers.linkages);\n        const attrX = AttributeMap.findAttribute(\"a_patternX\", techId, true);\n        const attrY = AttributeMap.findAttribute(\"a_patternY\", techId, true);\n        assert(undefined !== attrX && undefined !== attrY);\n        container.addBuffer(buffers.offsets, [\n            BufferParameters.create(attrX.location, 1, GL.DataType.Float, false, 8, 0, true),\n            BufferParameters.create(attrY.location, 1, GL.DataType.Float, false, 8, 4, true),\n        ]);\n        return new this(repr, ownsBuffers, buffers, container);\n    }\n    constructor(repr, ownsBuffers, buffers, container) {\n        super();\n        this._repr = repr;\n        this._ownsBuffers = ownsBuffers;\n        this._buffers = buffers;\n        this._buffersContainer = container;\n    }\n    get isDisposed() {\n        if (!this._repr.isDisposed)\n            return false;\n        return !this._ownsBuffers || this._buffers.isDisposed;\n    }\n    dispose() {\n        this._repr.dispose();\n        if (this._ownsBuffers)\n            dispose(this._buffers);\n    }\n    _wantWoWReversal(_target) {\n        assert(false, \"Should never be called\");\n        return false;\n    }\n    draw() {\n        this._repr.drawInstanced(this._buffers.numInstances, this._buffersContainer);\n    }\n    computeRange(output) {\n        return this._buffers.range.clone(output);\n    }\n    collectStatistics(stats) {\n        this._repr.collectStatistics(stats);\n        if (this._ownsBuffers)\n            this._buffers.collectStatistics(stats);\n    }\n    get patternParams() { return this._buffers.patternParams; }\n    get patternTransforms() { return this._buffers.patternTransforms; }\n    get patternFeatureId() { return this._buffers.patternFeatureId; }\n}\n//# sourceMappingURL=InstancedGeometry.js.map",
      "start": 1693508124521,
      "end": 1693508124569,
      "sourcemaps": null
    }
  ]
}
