{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend-devtools/lib/esm/effects/Snow.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Effects\n */\nimport { dispose } from \"@itwin/core-bentley\";\nimport { Point2d, Range1d, Range2d, Vector2d } from \"@itwin/core-geometry\";\nimport { TextureTransparency } from \"@itwin/core-common\";\nimport { GraphicType, imageElementFromUrl, IModelApp, ParticleCollectionBuilder, Tool, } from \"@itwin/core-frontend\";\nimport { parseToggle } from \"../tools/parseToggle\";\nimport { randomFloat, randomInteger } from \"./Random\";\n/** The default snow effect parameters used by newly-created SnowDecorators. */\nconst defaultSnowParams = {\n    numParticles: 2000,\n    sizeRange: Range1d.createXX(3, 22),\n    transparencyRange: Range1d.createXX(0, 50),\n    velocityRange: new Range2d(-30, 50, 30, 130),\n    accelerationRange: new Range2d(-1, -0.25, 1, 0.25),\n    windVelocity: 0,\n};\n/** Simulates snowfall in a [Viewport]($frontend) using particle effects.\n * @see [[SnowEffect]] for a [Tool]($frontend) that toggles this decorator.\n * @see [ParticleCollectionBuilder]($frontend) for defining custom particle effects.\n * @beta\n */\nclass SnowDecorator {\n    constructor(viewport, texture) {\n        /** The list of particles being drawn. */\n        this._particles = [];\n        this._params = { ...defaultSnowParams };\n        this.viewport = viewport;\n        this._dimensions = new Point2d(viewport.viewRect.width, viewport.viewRect.height);\n        this._lastUpdateTime = Date.now();\n        this._texture = texture;\n        // Tell the viewport to re-render the decorations every frame so that the snow particles animate smoothly.\n        const removeOnRender = viewport.onRender.addListener(() => viewport.invalidateDecorations());\n        // When the viewport is resized, replace this decorator with a new one to match the new dimensions.\n        const removeOnResized = viewport.onResized.addListener(() => {\n            // Transfer ownership of the texture to the new decorator.\n            const tex = this._texture;\n            this._texture = undefined;\n            this.dispose();\n            new SnowDecorator(viewport, tex);\n        });\n        // When the viewport is destroyed, dispose of this decorator too.\n        const removeOnDispose = viewport.onDisposed.addListener(() => this.dispose());\n        const removeDecorator = IModelApp.viewManager.addDecorator(this);\n        this.dispose = () => {\n            removeDecorator();\n            removeOnRender();\n            removeOnDispose();\n            removeOnResized();\n            this._texture = dispose(this._texture);\n            SnowDecorator._decorators.delete(viewport);\n        };\n        SnowDecorator._decorators.set(viewport, this);\n        // Initialize the particles.\n        for (let i = 0; i < this._params.numParticles; i++)\n            this._particles.push(this.emit(true));\n    }\n    decorate(context) {\n        if (context.viewport !== this.viewport || !this._texture)\n            return;\n        // Update the particles.\n        const now = Date.now();\n        const deltaMillis = now - this._lastUpdateTime;\n        this._lastUpdateTime = now;\n        this.updateParticles(deltaMillis / 1000);\n        // Create particle graphics.\n        const builder = ParticleCollectionBuilder.create({\n            viewport: this.viewport,\n            isViewCoords: true,\n            texture: this._texture,\n            size: (this._params.sizeRange.high - this._params.sizeRange.low) / 2,\n        });\n        for (const particle of this._particles)\n            builder.addParticle(particle);\n        const graphic = builder.finish();\n        if (graphic)\n            context.addDecoration(GraphicType.ViewOverlay, graphic);\n    }\n    /** Change some of the parameters affecting this decorator. */\n    configure(params) {\n        for (const key of Object.keys(params)) {\n            const val = params[key];\n            if (undefined !== val)\n                this._params[key] = val;\n        }\n    }\n    /** Emit a new particle with randomized properties. */\n    emit(randomizeHeight) {\n        return {\n            x: randomInteger(0, this._dimensions.x),\n            y: randomizeHeight ? randomInteger(0, this._dimensions.y) : 0,\n            z: 0,\n            size: randomInteger(this._params.sizeRange.low, this._params.sizeRange.high),\n            transparency: randomInteger(this._params.transparencyRange.low, this._params.transparencyRange.high),\n            velocity: new Vector2d(randomFloat(this._params.velocityRange.low.x, this._params.velocityRange.high.x), randomFloat(this._params.velocityRange.low.y, this._params.velocityRange.high.y)),\n        };\n    }\n    // Update the positions and velocities of all the particles based on the amount of time that has passed since the last update.\n    updateParticles(elapsedSeconds) {\n        // Determine if someone changed the desired number of particles.\n        const particleDiscrepancy = this._params.numParticles - this._particles.length;\n        if (particleDiscrepancy > 0) {\n            // Birth new particles up to the new maximum.\n            for (let i = 0; i < particleDiscrepancy; i++)\n                this._particles.push(this.emit(true));\n        }\n        else {\n            // Destroy extra particles.\n            this._particles.length = this._params.numParticles;\n        }\n        const acceleration = new Vector2d();\n        const velocity = new Vector2d();\n        for (let i = 0; i < this._particles.length; i++) {\n            // Apply some acceleration to produce random drift.\n            const particle = this._particles[i];\n            acceleration.set(randomFloat(this._params.accelerationRange.low.x, this._params.accelerationRange.high.x), randomFloat(this._params.accelerationRange.low.y, this._params.accelerationRange.high.y));\n            acceleration.scale(elapsedSeconds, acceleration);\n            particle.velocity.plus(acceleration, particle.velocity);\n            // Apply velocity.\n            particle.velocity.clone(velocity);\n            velocity.scale(elapsedSeconds, velocity);\n            particle.x += velocity.x;\n            particle.y += velocity.y;\n            // Apply wind\n            particle.x += this._params.windVelocity * elapsedSeconds;\n            // Particles that travel beyond the viewport's left or right edges wrap around to the other side.\n            if (particle.x < 0)\n                particle.x = this._dimensions.x - 1;\n            else if (particle.x >= this._dimensions.x)\n                particle.x = 0;\n            // Particles that travel beyond the viewport's bottom or top edges are replaced by newborn particles.\n            if (particle.y < 0 || particle.y >= this._dimensions.y)\n                this._particles[i] = this.emit(false);\n        }\n    }\n    /** Toggle this decorator for the specified viewport.\n     * @param viewport The viewport to which the effect should be applied or removed.\n     * @param enable `true` to enable the effect, `false` to disable it, or `undefined` to toggle the current state.\n     */\n    static async toggle(viewport, enable) {\n        const decorator = this._decorators.get(viewport);\n        if (undefined === enable)\n            enable = undefined === decorator;\n        if (undefined !== decorator && !enable)\n            decorator.dispose();\n        else if (undefined === decorator && enable) {\n            // Create a texture to use for the particles.\n            // Note: the decorator takes ownership of the texture, and disposes of it when the decorator is disposed.\n            const image = await imageElementFromUrl(`${IModelApp.publicPath}sprites/particle_snow.png`);\n            const texture = IModelApp.renderSystem.createTexture({\n                ownership: \"external\",\n                image: { source: image, transparency: TextureTransparency.Mixed },\n            });\n            new SnowDecorator(viewport, texture);\n        }\n    }\n}\nSnowDecorator._decorators = new Map();\nexport { SnowDecorator };\n/** Toggles a decorator that simulates snow using particle effects.\n * @see [[SnowDecorator]] for the implementation of the decorator.\n * @beta\n */\nclass SnowEffect extends Tool {\n    async run(enable) {\n        const vp = IModelApp.viewManager.selectedView;\n        if (vp)\n            await SnowDecorator.toggle(vp, enable);\n        return true;\n    }\n    async parseAndRun(...args) {\n        const enable = parseToggle(args[0]);\n        if (typeof enable !== \"string\")\n            await this.run(enable);\n        return true;\n    }\n}\nSnowEffect.toolId = \"SnowEffect\";\nexport { SnowEffect };\n//# sourceMappingURL=Snow.js.map",
      "start": 1693508122606,
      "end": 1693508122706,
      "sourcemaps": null
    }
  ]
}
