{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/curve/internalContexts/CurveOffsetXYHandler.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Curve\n */\nimport { Geometry } from \"../../Geometry\";\nimport { Point3d, Vector3d } from \"../../geometry3d/Point3dVector3d\";\nimport { Ray3d } from \"../../geometry3d/Ray3d\";\nimport { InterpolationCurve3dOptions } from \"../../bspline/InterpolationCurve3d\";\nimport { BSplineCurveOps } from \"../../bspline/BSplineCurveOps\";\n/**\n * Context for constructing the xy-offset of a CurvePrimitive by interpolating the xy-offsets of computed strokes.\n * @internal\n */\nexport class CurveOffsetXYHandler {\n    constructor(cp, offsetDistance) {\n        // temporary workspace\n        this._p0 = Point3d.createZero();\n        this._p1 = Point3d.createZero();\n        this._v0 = Vector3d.createZero();\n        this._v1 = Vector3d.createZero();\n        this._r0 = Ray3d.createZero();\n        this._offsetDistance = offsetDistance;\n        this._fitOptions = new InterpolationCurve3dOptions();\n        const startTangent = cp.fractionToPointAndUnitTangent(0.0, this._r0).direction.clone();\n        const endTangent = cp.fractionToPointAndUnitTangent(1.0, this._r0).direction.negate(); // points into curve\n        this._fitOptions.startTangent = startTangent;\n        this._fitOptions.endTangent = endTangent;\n        if (this._fitOptions.closed = (cp.startPoint(this._p0).isAlmostEqual(cp.endPoint(this._p1)) && startTangent.isParallelTo(endTangent, true)))\n            this._fitOptions.isChordLenKnots = 1;\n    }\n    pushOffsetPoint(xyz, tangent) {\n        if (!Geometry.isSmallMetricDistance(tangent.x) || !Geometry.isSmallMetricDistance(tangent.y))\n            this._fitOptions.fitPoints.push(xyz.plusScaled(tangent.unitPerpendicularXY(this._v0), this._offsetDistance));\n    }\n    needPrimaryGeometryForStrokes() { return true; }\n    startParentCurvePrimitive(_cp) { }\n    startCurvePrimitive(_cp) { }\n    endCurvePrimitive(_cp) { }\n    endParentCurvePrimitive(_cp) { }\n    announceIntervalForUniformStepStrokes(cp, numStrokes, fraction0, fraction1) {\n        for (let i = 0; i <= numStrokes; ++i) { // announce both start and end; adjacent duplicates will be filtered by c2 cubic fit logic\n            const fraction = Geometry.interpolate(fraction0, i / numStrokes, fraction1);\n            const ray = cp.fractionToPointAndDerivative(fraction, this._r0);\n            this.pushOffsetPoint(ray.origin, ray.direction);\n        }\n    }\n    announceSegmentInterval(_cp, point0, point1, numStrokes, _fraction0, _fraction1) {\n        if (numStrokes > 0) {\n            const tangent = Vector3d.createStartEnd(point0, point1, this._v1);\n            for (let i = 0; i <= numStrokes; ++i) { // announce both start and end; adjacent duplicates will be filtered by c2 cubic fit logic\n                this.pushOffsetPoint(point0.interpolate(i / numStrokes, point1, this._p0), tangent);\n            }\n        }\n    }\n    announcePointTangent(xyz, _fraction, tangent) {\n        this.pushOffsetPoint(xyz, tangent);\n    }\n    /**\n     * Construct a C2 cubic interpolating B-spline curve through the collected xy-offset points.\n     * @returns the xy-offset curve\n     */\n    claimResult() {\n        return BSplineCurveOps.createThroughPointsC2Cubic(this._fitOptions);\n    }\n}\n//# sourceMappingURL=CurveOffsetXYHandler.js.map",
      "start": 1693508125189,
      "end": 1693508125364,
      "sourcemaps": null
    }
  ]
}
