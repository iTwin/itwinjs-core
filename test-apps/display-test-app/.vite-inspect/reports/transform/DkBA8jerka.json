{
  "resolvedId": "D:/hub2023A/itwinjs-core/editor/frontend/lib/esm/ProjectLocation/ProjectGeolocation.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Editing\n */\nimport { AccuDrawHintBuilder, AccuDrawShortcuts, AngleDescription, CoreTools, EventHandled, GraphicType, IModelApp, LengthDescription, PrimitiveTool, ToolAssistance, ToolAssistanceImage, ToolAssistanceInputMethod } from \"@itwin/core-frontend\";\nimport { Angle, Matrix3d, Point3d, Ray3d, Vector3d } from \"@itwin/core-geometry\";\nimport { Cartographic, ColorDef, LinePixels } from \"@itwin/core-common\";\nimport { ProjectExtentsClipDecoration } from \"./ProjectExtentsDecoration\";\nimport { DialogProperty } from \"@itwin/appui-abstract\";\nimport { EditTools } from \"../EditTool\";\nfunction translatePrompt(key) {\n    return EditTools.translate(`ProjectLocation:Prompts.${key}`);\n}\nfunction translateMessage(key) {\n    return EditTools.translate(`ProjectLocation:Message.${key}`);\n}\n/** @internal */\nclass LabelDecoration {\n    constructor(worldLocation, label) {\n        this.worldLocation = new Point3d();\n        this.position = new Point3d();\n        this.worldLocation.setFrom(worldLocation);\n        this.label = label;\n    }\n    drawDecoration(ctx) {\n        ctx.font = \"16px san-serif\";\n        const labelHeight = ctx.measureText(\"M\").width; // Close enough for border padding...\n        const labelWidth = ctx.measureText(this.label).width + labelHeight;\n        ctx.lineWidth = 1;\n        ctx.strokeStyle = \"white\";\n        ctx.fillStyle = \"rgba(0,0,0,.4)\";\n        ctx.shadowColor = \"black\";\n        ctx.shadowBlur = 10;\n        ctx.fillRect(-(labelWidth / 2), -labelHeight, labelWidth, labelHeight * 2);\n        ctx.strokeRect(-(labelWidth / 2), -labelHeight, labelWidth, labelHeight * 2);\n        ctx.fillStyle = \"white\";\n        ctx.shadowBlur = 0;\n        ctx.textAlign = \"center\";\n        ctx.textBaseline = \"middle\";\n        ctx.fillText(this.label, 0, 0);\n    }\n    setPosition(vp) {\n        vp.worldToView(this.worldLocation, this.position);\n        this.position.y -= Math.floor(vp.pixelsFromInches(0.45)) + 0.5; // Offset from world location...\n        return vp.viewRect.containsPoint(this.position);\n    }\n    addDecoration(context) {\n        if (this.setPosition(context.viewport))\n            context.addCanvasDecoration(this);\n    }\n}\n/** Change or update geolocation for project.\n * To show tool settings for specifying lat/long, make sure formatting and parsing data are cached before the tool starts\n * by calling QuantityFormatter.onInitialized at app startup.\n * @beta\n */\nclass ProjectGeolocationPointTool extends PrimitiveTool {\n    constructor() {\n        super(...arguments);\n        this._haveToolSettings = false;\n        this._cartographicFromArgs = false;\n        this._accept = false;\n        this._scale = 1.0;\n    }\n    static get minArgs() { return 0; }\n    static get maxArgs() { return 4; } // latitude, longitude, altitude, north direction...\n    isCompatibleViewport(vp, isSelectedViewChange) { return (super.isCompatibleViewport(vp, isSelectedViewChange) && undefined !== vp && vp.view.isSpatialView()); }\n    isValidLocation(_ev, _isButtonEvent) { return true; } // Allow snapping to terrain, etc. outside project extents...\n    requireWriteableTarget() { return false; } // Tool doesn't modify the imodel...\n    async onPostInstall() {\n        await super.onPostInstall();\n        this.setupAndPromptForNextAction();\n    }\n    async onCleanup() {\n        await super.onCleanup();\n        this.unsuspendDecorations();\n    }\n    async onRestartTool() { return this.exitTool(); }\n    async onUnsuspend() { this.provideToolAssistance(); }\n    get latitudeProperty() {\n        if (!this._latitudeProperty)\n            this._latitudeProperty = new DialogProperty(new AngleDescription(\"latitude\", translateMessage(\"Latitude\")), 0.0);\n        return this._latitudeProperty;\n    }\n    get latitude() { return this.latitudeProperty.value; }\n    set latitude(value) { this.latitudeProperty.value = value; }\n    get longitudeProperty() {\n        if (!this._longitudeProperty)\n            this._longitudeProperty = new DialogProperty(new AngleDescription(\"longitude\", translateMessage(\"Longitude\")), 0.0);\n        return this._longitudeProperty;\n    }\n    get longitude() { return this.longitudeProperty.value; }\n    set longitude(value) { this.longitudeProperty.value = value; }\n    get altitudeProperty() {\n        if (!this._altitudeProperty)\n            this._altitudeProperty = new DialogProperty(new LengthDescription(\"altitude\", CoreTools.translate(\"Measure.Labels.Altitude\")), 0.0);\n        return this._altitudeProperty;\n    }\n    get altitude() { return this.altitudeProperty.value; }\n    set altitude(value) { this.altitudeProperty.value = value; }\n    get northProperty() {\n        if (!this._northProperty)\n            this._northProperty = new DialogProperty(new AngleDescription(\"north\", translateMessage(\"North\")), 0.0);\n        return this._northProperty;\n    }\n    get north() { return this.northProperty.value; }\n    set north(value) { this.northProperty.value = value; }\n    syncToolSettingsCoordinates() {\n        this.syncToolSettingsProperties([this.latitudeProperty.syncItem, this.longitudeProperty.syncItem, this.altitudeProperty.syncItem, this.northProperty.syncItem]);\n    }\n    async applyToolSettingPropertyChange(updatedValue) {\n        return this.changeToolSettingPropertyValue(updatedValue);\n    }\n    supplyToolSettingsProperties() {\n        this._haveToolSettings = true;\n        const toolSettings = new Array();\n        toolSettings.push(this.latitudeProperty.toDialogItem({ rowPriority: 1, columnIndex: 2 }));\n        toolSettings.push(this.longitudeProperty.toDialogItem({ rowPriority: 2, columnIndex: 2 }));\n        toolSettings.push(this.altitudeProperty.toDialogItem({ rowPriority: 3, columnIndex: 2 }));\n        toolSettings.push(this.northProperty.toDialogItem({ rowPriority: 4, columnIndex: 2 }));\n        return toolSettings;\n    }\n    provideToolAssistance() {\n        const acceptMsg = CoreTools.translate(undefined === this._origin ? \"ElementSet.Inputs.AcceptPoint\" : \"ElementSet.Inputs.Accept\");\n        const rejectMsg = CoreTools.translate(\"ElementSet.Inputs.Cancel\");\n        const mainInstruction = ToolAssistance.createInstruction(this.iconSpec, translatePrompt(undefined === this._origin ? \"IdentifyKnownLocation\" : \"ConfirmCoordinates\"));\n        const sections = [];\n        const mouseInstructions = [];\n        mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.LeftClick, acceptMsg, false, ToolAssistanceInputMethod.Mouse));\n        mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.RightClick, rejectMsg, false, ToolAssistanceInputMethod.Mouse));\n        sections.push(ToolAssistance.createSection(mouseInstructions, ToolAssistance.inputsLabel));\n        const touchInstructions = [];\n        if (!ToolAssistance.createTouchCursorInstructions(touchInstructions))\n            touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.OneTouchTap, acceptMsg, false, ToolAssistanceInputMethod.Touch));\n        touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.TwoTouchTap, rejectMsg, false, ToolAssistanceInputMethod.Touch));\n        sections.push(ToolAssistance.createSection(touchInstructions, ToolAssistance.inputsLabel));\n        const instructions = ToolAssistance.createInstructions(mainInstruction, sections);\n        IModelApp.notifications.setToolAssistance(instructions);\n    }\n    setupAndPromptForNextAction() {\n        IModelApp.accuSnap.enableSnap(undefined === this._origin);\n        this.provideToolAssistance();\n    }\n    pulseDecoration() {\n        if (!this._accept)\n            return;\n        const deco = ProjectExtentsClipDecoration.get();\n        if (undefined === deco)\n            return;\n        this._scale += 0.1;\n        if (this._scale > 1.6)\n            this._scale = 1.0;\n        deco.viewport.invalidateDecorations();\n        setTimeout(() => this.pulseDecoration(), 100);\n    }\n    unsuspendDecorations() {\n        const deco = ProjectExtentsClipDecoration.get();\n        if (undefined !== deco)\n            deco.suspendGeolocationDecorations = false;\n    }\n    decorate(context) {\n        if (undefined === this._origin || !context.viewport.view.isSpatialView())\n            return;\n        const deco = ProjectExtentsClipDecoration.get();\n        if (undefined === deco)\n            return;\n        deco.suspendGeolocationDecorations = true;\n        deco.drawMonumentPoint(context, this._origin, this._scale);\n        if (undefined !== this._labelDeco)\n            this._labelDeco.addDecoration(context);\n    }\n    async onMouseMotion(ev) {\n        if (undefined === ev.viewport || this._accept)\n            return;\n        this._origin = ev.point.clone();\n        ev.viewport.invalidateDecorations();\n    }\n    async onResetButtonUp(_ev) {\n        await this.onReinitialize(); // Calls onRestartTool to exit...\n        return EventHandled.No;\n    }\n    acceptDefaultLocation() {\n        // Greenwich is better default when testing control handle w/o tool settings support...\n        this.latitude = Angle.createDegrees(51.4934).radians;\n        this.longitude = Angle.createDegrees(0.0098).radians;\n        this.altitude = 50.0;\n        this.north = 0.0;\n    }\n    acceptKnownLocation(ev) {\n        const deco = ProjectExtentsClipDecoration.get();\n        if (undefined === deco)\n            return;\n        this._accept = true; // Require explicit accept to give user a chance to change values...\n        this._origin = ev.point.clone();\n        this._labelDeco = new LabelDecoration(this._origin, translatePrompt(\"SpecifyCoordinates\"));\n        if (!this._cartographicFromArgs) {\n            if (this.iModel.isGeoLocated) {\n                const cartographic = this.iModel.spatialToCartographicFromEcef(this._origin);\n                this.latitude = cartographic.latitude;\n                this.longitude = cartographic.longitude;\n                this.altitude = cartographic.height;\n                this.north = deco.getClockwiseAngleToNorth().radians;\n            }\n            else if (!this._haveToolSettings) {\n                this.acceptDefaultLocation();\n            }\n        }\n        this.syncToolSettingsCoordinates();\n        this.pulseDecoration(); // Pulse to indicate that we are waiting for user input...\n        this.setupAndPromptForNextAction();\n    }\n    async acceptCoordinates() {\n        const deco = ProjectExtentsClipDecoration.get();\n        if (undefined === deco)\n            return;\n        const origin = Cartographic.fromRadians({ longitude: this.longitude, latitude: this.latitude, height: this.altitude });\n        if (!deco.updateEcefLocation(origin, this._origin, Angle.createRadians(this.north)))\n            return;\n        return this.onReinitialize(); // Calls onRestartTool to exit...\n    }\n    async onDataButtonDown(ev) {\n        if (undefined === ev.viewport)\n            return EventHandled.No; // Shouldn't really happen...\n        const haveKnownLocation = this._accept;\n        if (!haveKnownLocation)\n            this.acceptKnownLocation(ev);\n        const needAcceptPoint = !haveKnownLocation && this._haveToolSettings;\n        if (!needAcceptPoint)\n            await this.acceptCoordinates();\n        return EventHandled.No;\n    }\n    async onInstall() {\n        if (!ProjectExtentsClipDecoration.allowEcefLocationChange(false))\n            return false;\n        // Setup initial values here instead of supplyToolSettingsProperties to support keyin args w/o appui-react...\n        this.initializeToolSettingPropertyValues([this.latitudeProperty, this.longitudeProperty, this.altitudeProperty, this.northProperty]);\n        return true;\n    }\n    /** The keyin takes the following arguments, all of which are optional:\n     *  - `latitude=number` Latitude of accept point in degrees.\n     *  - `longitude=number` Longitude of accept point in degrees.\n     *  - `altitude=number` Height above ellipsoid of accept point.\n     *  - `north=number` North direction in degrees of accept point.\n     */\n    async parseAndRun(...inputArgs) {\n        for (const arg of inputArgs) {\n            const parts = arg.split(\"=\");\n            if (2 !== parts.length)\n                continue;\n            if (parts[0].toLowerCase().startsWith(\"la\")) {\n                const latitude = Number.parseFloat(parts[1]);\n                if (!Number.isNaN(latitude)) {\n                    this.saveToolSettingPropertyValue(this.latitudeProperty, { value: Angle.createDegrees(latitude).radians });\n                    this._cartographicFromArgs = true;\n                }\n            }\n            else if (parts[0].toLowerCase().startsWith(\"lo\")) {\n                const longitude = Number.parseFloat(parts[1]);\n                if (!Number.isNaN(longitude)) {\n                    this.saveToolSettingPropertyValue(this.longitudeProperty, { value: Angle.createDegrees(longitude).radians });\n                    this._cartographicFromArgs = true;\n                }\n            }\n            else if (parts[0].toLowerCase().startsWith(\"al\")) {\n                const altitude = Number.parseFloat(parts[1]);\n                if (!Number.isNaN(altitude)) {\n                    this.saveToolSettingPropertyValue(this.altitudeProperty, { value: altitude });\n                    this._cartographicFromArgs = true;\n                }\n            }\n            else if (parts[0].toLowerCase().startsWith(\"no\")) {\n                const north = Number.parseFloat(parts[1]);\n                if (!Number.isNaN(north)) {\n                    this.saveToolSettingPropertyValue(this.northProperty, { value: Angle.createDegrees(north).radians });\n                    this._cartographicFromArgs = true;\n                }\n            }\n        }\n        return this.run();\n    }\n    static async startTool() { return new ProjectGeolocationPointTool().run(); }\n}\nProjectGeolocationPointTool.toolId = \"ProjectLocation.Geolocation.Point\";\nProjectGeolocationPointTool.iconSpec = \"icon-globe\"; // <== Tool button should use whatever icon you have here...\nexport { ProjectGeolocationPointTool };\n/** Change or update geolocation direction to true north.\n * @beta\n */\nclass ProjectGeolocationNorthTool extends PrimitiveTool {\n    isCompatibleViewport(vp, isSelectedViewChange) { return (super.isCompatibleViewport(vp, isSelectedViewChange) && undefined !== vp && vp.view.isSpatialView()); }\n    isValidLocation(_ev, _isButtonEvent) { return true; } // Allow snapping to terrain, etc. outside project extents...\n    requireWriteableTarget() { return false; } // Tool doesn't modify the imodel...\n    async onPostInstall() {\n        await super.onPostInstall();\n        this.setupAndPromptForNextAction();\n    }\n    async onCleanup() {\n        await super.onCleanup();\n        this.unsuspendDecorations();\n    }\n    async onRestartTool() { return this.exitTool(); }\n    async onUnsuspend() { this.provideToolAssistance(); }\n    provideToolAssistance() {\n        const acceptMsg = CoreTools.translate(\"ElementSet.Inputs.AcceptPoint\");\n        const rejectMsg = CoreTools.translate(\"ElementSet.Inputs.Cancel\");\n        const mainInstruction = ToolAssistance.createInstruction(this.iconSpec, translatePrompt(undefined === this._origin ? \"IdentifyRefPoint\" : \"DefineAngle\"));\n        const sections = [];\n        const mouseInstructions = [];\n        mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.LeftClick, acceptMsg, false, ToolAssistanceInputMethod.Mouse));\n        mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.RightClick, rejectMsg, false, ToolAssistanceInputMethod.Mouse));\n        sections.push(ToolAssistance.createSection(mouseInstructions, ToolAssistance.inputsLabel));\n        const touchInstructions = [];\n        if (!ToolAssistance.createTouchCursorInstructions(touchInstructions))\n            touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.OneTouchTap, acceptMsg, false, ToolAssistanceInputMethod.Touch));\n        touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.TwoTouchTap, rejectMsg, false, ToolAssistanceInputMethod.Touch));\n        sections.push(ToolAssistance.createSection(touchInstructions, ToolAssistance.inputsLabel));\n        const instructions = ToolAssistance.createInstructions(mainInstruction, sections);\n        IModelApp.notifications.setToolAssistance(instructions);\n    }\n    setupAndPromptForNextAction() {\n        IModelApp.accuSnap.enableSnap(true);\n        this.provideToolAssistance();\n        if (undefined === this._origin)\n            return;\n        const hints = new AccuDrawHintBuilder();\n        hints.setRotation(Matrix3d.createIdentity());\n        hints.setOrigin(this._origin);\n        hints.setModePolar();\n        hints.setOriginFixed = true;\n        hints.setLockZ = true;\n        hints.sendHints();\n    }\n    getAdjustedPoint(ev) {\n        if (undefined === this._origin)\n            return undefined;\n        return AccuDrawHintBuilder.projectPointToPlaneInView(ev.point, this._origin, Vector3d.unitZ(), ev.viewport, true);\n    }\n    unsuspendDecorations() {\n        const deco = ProjectExtentsClipDecoration.get();\n        if (undefined !== deco)\n            deco.suspendGeolocationDecorations = false;\n    }\n    updateNorthVector(ev) {\n        if (undefined === ev.viewport)\n            return;\n        if (undefined === this._northDir)\n            this._northDir = Ray3d.create(ev.point, Vector3d.unitY());\n        else\n            this._northDir.origin.setFrom(undefined !== this._origin ? this._origin : ev.point);\n        const dirPt = this.getAdjustedPoint(ev);\n        if (undefined === dirPt)\n            return;\n        this._northDir.direction.setStartEnd(this._northDir.origin, dirPt);\n        if (this._northDir.direction.magnitude() < 1.0e-6)\n            this._northDir.direction.setFrom(Vector3d.unitY());\n        this._northDir.direction.z = 0.0;\n        this._northDir.direction.normalizeInPlace();\n    }\n    decorate(context) {\n        if (undefined === this._northDir || !context.viewport.view.isSpatialView())\n            return;\n        const deco = ProjectExtentsClipDecoration.get();\n        if (undefined === deco)\n            return;\n        deco.suspendGeolocationDecorations = true;\n        deco.drawNorthArrow(context, this._northDir);\n    }\n    async onKeyTransition(wentDown, keyEvent) {\n        if (EventHandled.Yes === await super.onKeyTransition(wentDown, keyEvent))\n            return EventHandled.Yes;\n        return (wentDown && await AccuDrawShortcuts.processShortcutKey(keyEvent)) ? EventHandled.Yes : EventHandled.No;\n    }\n    async onMouseMotion(ev) {\n        if (undefined === ev.viewport)\n            return;\n        this.updateNorthVector(ev);\n        ev.viewport.invalidateDecorations();\n    }\n    async onResetButtonUp(_ev) {\n        await this.onReinitialize(); // Calls onRestartTool to exit...\n        return EventHandled.No;\n    }\n    async onDataButtonDown(ev) {\n        if (undefined === ev.viewport)\n            return EventHandled.No; // Shouldn't really happen...\n        if (undefined === this._origin) {\n            this._origin = ev.point.clone();\n            this.setupAndPromptForNextAction();\n            return EventHandled.No;\n        }\n        this.updateNorthVector(ev);\n        if (undefined !== this._northDir) {\n            const deco = ProjectExtentsClipDecoration.get();\n            if (undefined !== deco)\n                deco.updateNorthDirection(this._northDir);\n        }\n        await this.onReinitialize(); // Calls onRestartTool to exit...\n        return EventHandled.No;\n    }\n    async onInstall() { return ProjectExtentsClipDecoration.allowEcefLocationChange(true); }\n    static async startTool() { return new ProjectGeolocationNorthTool().run(); }\n}\nProjectGeolocationNorthTool.toolId = \"ProjectLocation.Geolocation.North\";\nProjectGeolocationNorthTool.iconSpec = \"icon-sort-up\"; // <== Tool button should use whatever icon you have here...\nexport { ProjectGeolocationNorthTool };\n/** Move a geolocated model by specifying two points to define the offset.\n * @beta\n */\nclass ProjectGeolocationMoveTool extends PrimitiveTool {\n    isCompatibleViewport(vp, isSelectedViewChange) { return (super.isCompatibleViewport(vp, isSelectedViewChange) && undefined !== vp && vp.view.isSpatialView()); }\n    isValidLocation(_ev, _isButtonEvent) { return true; } // Allow snapping to terrain, etc. outside project extents...\n    requireWriteableTarget() { return false; } // Tool doesn't modify the imodel...\n    async onPostInstall() {\n        await super.onPostInstall();\n        this.setupAndPromptForNextAction();\n    }\n    async onCleanup() {\n        await super.onCleanup();\n        this.unsuspendDecorations();\n    }\n    async onRestartTool() {\n        const tool = new ProjectGeolocationMoveTool();\n        if (!await tool.run())\n            return this.exitTool();\n    }\n    async onUnsuspend() { this.provideToolAssistance(); }\n    provideToolAssistance() {\n        const acceptMsg = CoreTools.translate(\"ElementSet.Inputs.AcceptPoint\");\n        const rejectMsg = CoreTools.translate(\"ElementSet.Inputs.Cancel\");\n        const mainInstruction = ToolAssistance.createInstruction(this.iconSpec, translatePrompt(undefined === this._origin ? \"IdentifyRefPoint\" : \"DefineOffset\"));\n        const sections = [];\n        const mouseInstructions = [];\n        mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.LeftClick, acceptMsg, false, ToolAssistanceInputMethod.Mouse));\n        mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.RightClick, rejectMsg, false, ToolAssistanceInputMethod.Mouse));\n        sections.push(ToolAssistance.createSection(mouseInstructions, ToolAssistance.inputsLabel));\n        const touchInstructions = [];\n        if (!ToolAssistance.createTouchCursorInstructions(touchInstructions))\n            touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.OneTouchTap, acceptMsg, false, ToolAssistanceInputMethod.Touch));\n        touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.TwoTouchTap, rejectMsg, false, ToolAssistanceInputMethod.Touch));\n        sections.push(ToolAssistance.createSection(touchInstructions, ToolAssistance.inputsLabel));\n        const instructions = ToolAssistance.createInstructions(mainInstruction, sections);\n        IModelApp.notifications.setToolAssistance(instructions);\n    }\n    setupAndPromptForNextAction() {\n        IModelApp.accuSnap.enableSnap(true);\n        this.provideToolAssistance();\n        if (undefined === this._origin)\n            return;\n        const hints = new AccuDrawHintBuilder();\n        hints.setRotation(Matrix3d.createIdentity());\n        hints.setOrigin(this._origin);\n        hints.setModePolar();\n        hints.setOriginFixed = true;\n        hints.sendHints();\n    }\n    unsuspendDecorations() {\n        const deco = ProjectExtentsClipDecoration.get();\n        if (undefined !== deco)\n            deco.suspendGeolocationDecorations = false;\n    }\n    async acceptOffset(ev) {\n        if (undefined === ev.viewport || undefined === this._origin)\n            return;\n        const deco = ProjectExtentsClipDecoration.get();\n        if (undefined === deco)\n            return;\n        const origin = this.iModel.spatialToCartographicFromEcef(ev.point);\n        if (!deco.updateEcefLocation(origin, this._origin))\n            return;\n        return this.onReinitialize(); // Calls onRestartTool to exit...\n    }\n    decorate(context) {\n        if (undefined === this._origin || undefined === this._current || !context.viewport.view.isSpatialView())\n            return;\n        const deco = ProjectExtentsClipDecoration.get();\n        if (undefined === deco)\n            return;\n        const builderAccVis = context.createGraphicBuilder(GraphicType.WorldDecoration);\n        const builderAccHid = context.createGraphicBuilder(GraphicType.WorldOverlay);\n        const colorAccVis = ColorDef.white.adjustedForContrast(context.viewport.view.backgroundColor);\n        const colorAccHid = colorAccVis.withAlpha(100);\n        builderAccVis.setSymbology(colorAccVis, ColorDef.black, 3);\n        builderAccHid.setSymbology(colorAccHid, ColorDef.black, 1, LinePixels.Code2);\n        const extents = this.iModel.projectExtents.cloneTranslated(Vector3d.createStartEnd(this._origin, this._current));\n        builderAccVis.addRangeBox(extents);\n        builderAccHid.addRangeBox(extents);\n        builderAccHid.addLineString([this._origin, this._current]);\n        context.addDecorationFromBuilder(builderAccVis);\n        context.addDecorationFromBuilder(builderAccHid);\n        deco.suspendGeolocationDecorations = true;\n    }\n    async onKeyTransition(wentDown, keyEvent) {\n        if (EventHandled.Yes === await super.onKeyTransition(wentDown, keyEvent))\n            return EventHandled.Yes;\n        return (wentDown && await AccuDrawShortcuts.processShortcutKey(keyEvent)) ? EventHandled.Yes : EventHandled.No;\n    }\n    async onMouseMotion(ev) {\n        if (undefined === ev.viewport)\n            return;\n        this._current = ev.point;\n        ev.viewport.invalidateDecorations();\n    }\n    async onResetButtonUp(_ev) {\n        if (undefined === this._origin)\n            await this.exitTool(); // exit to select tool if we haven't gotten first point...\n        else\n            await this.onReinitialize(); // Calls onRestartTool...\n        return EventHandled.No;\n    }\n    async onDataButtonDown(ev) {\n        if (undefined === ev.viewport)\n            return EventHandled.No; // Shouldn't really happen...\n        if (undefined === this._origin) {\n            this._origin = ev.point.clone();\n            this.setupAndPromptForNextAction();\n            return EventHandled.No;\n        }\n        await this.acceptOffset(ev);\n        return EventHandled.No;\n    }\n    async onInstall() { return ProjectExtentsClipDecoration.allowEcefLocationChange(true); }\n    static async startTool() { return new ProjectGeolocationMoveTool().run(); }\n}\nProjectGeolocationMoveTool.toolId = \"ProjectLocation.Geolocation.Move\";\nProjectGeolocationMoveTool.iconSpec = \"icon-move\"; // <== Tool button should use whatever icon you have here...\nexport { ProjectGeolocationMoveTool };\n//# sourceMappingURL=ProjectGeolocation.js.map",
      "start": 1693508122928,
      "end": 1693508123054,
      "sourcemaps": null
    }
  ]
}
