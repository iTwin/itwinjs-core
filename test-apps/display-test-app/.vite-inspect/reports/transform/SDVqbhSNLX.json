{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/curve/CurveCollection.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Curve\n */\nimport { Geometry } from \"../Geometry\";\nimport { CurveLocationDetail } from \"./CurveLocationDetail\";\nimport { CurvePrimitive } from \"./CurvePrimitive\";\nimport { GeometryQuery } from \"./GeometryQuery\";\nimport { CloneCurvesContext } from \"./internalContexts/CloneCurvesContext\";\nimport { CloneWithExpandedLineStrings } from \"./internalContexts/CloneWithExpandedLineStrings\";\nimport { CountLinearPartsSearchContext } from \"./internalContexts/CountLinearPartsSearchContext\";\nimport { GapSearchContext } from \"./internalContexts/GapSearchContext\";\nimport { PlaneAltitudeRangeContext } from \"./internalContexts/PlaneAltitudeRangeContext\";\nimport { SumLengthsContext } from \"./internalContexts/SumLengthsContext\";\nimport { TransformInPlaceContext } from \"./internalContexts/TransformInPlaceContext\";\nimport { LineString3d } from \"./LineString3d\";\nimport { ProxyCurve } from \"./ProxyCurve\";\n/**\n * A `CurveCollection` is an abstract (non-instantiable) class for various sets of curves with particular structures:\n * - `CurveChain` is a (non-instantiable) intermediate class for a sequence of `CurvePrimitive` joining head-to-tail.\n * The two instantiable forms of `CurveChain` are\n *   - `Path` - A chain not required to close and not enclosing a planar area (so curves do not have to be on the\n * same plane).\n *   - `Loop` - A chain required to close from last to first so that a planar area is enclosed (so curves have to\n * be on the same plane).\n * - `ParityRegion` -- a collection of coplanar `Loop`, with \"in/out\" classification by parity rules.\n * - `UnionRegion` -- a collection of coplanar `Loop` and/or `ParityRegion`, with \"in/out\" classification by union rules.\n * - `BagOfCurves` -- a collection of `AnyCurve` with no implied structure.\n *\n * @see [Curve Collections]($docs/learning/geometry/CurveCollection.md) learning article.\n * @public\n */\nexport class CurveCollection extends GeometryQuery {\n    constructor() {\n        super(...arguments);\n        /** String name for schema properties */\n        this.geometryCategory = \"curveCollection\";\n        /* eslint-disable @typescript-eslint/naming-convention, no-empty */\n        /** Flag for inner loop status. Only used by `Loop`. */\n        this.isInner = false;\n    }\n    /** Return the sum of the lengths of all contained curves. */\n    sumLengths() {\n        return SumLengthsContext.sumLengths(this);\n    }\n    /** Return the closest point on the contained curves */\n    closestPoint(spacePoint) {\n        let detailA;\n        if (this.children !== undefined) {\n            for (const child of this.children) {\n                if (child instanceof CurvePrimitive) {\n                    const detailB = child.closestPoint(spacePoint, false);\n                    detailA = CurveLocationDetail.chooseSmallerA(detailA, detailB);\n                }\n                else if (child instanceof CurveCollection) {\n                    const detailB = child.closestPoint(spacePoint);\n                    detailA = CurveLocationDetail.chooseSmallerA(detailA, detailB);\n                }\n            }\n        }\n        return detailA;\n    }\n    /**\n     * Return the max gap between adjacent primitives in Path and Loop collections.\n     * * In a Path, gaps are computed between consecutive primitives.\n     * * In a Loop, gaps are computed between consecutive primitives and between last and first.\n     * * Gaps are NOT computed between consecutive CurvePrimitives in \"unstructured\" collections. The type is\n     * \"unstructured\" so gaps should not be semantically meaningful.\n     */\n    maxGap() {\n        return GapSearchContext.maxGap(this);\n    }\n    /** Return true if the curve collection has any primitives other than LineSegment3d and LineString3d  */\n    checkForNonLinearPrimitives() {\n        return CountLinearPartsSearchContext.hasNonLinearPrimitives(this);\n    }\n    /** Apply transform recursively to children */\n    tryTransformInPlace(transform) {\n        return TransformInPlaceContext.tryTransformInPlace(this, transform);\n    }\n    /** Return a deep copy. */\n    clone() {\n        return CloneCurvesContext.clone(this);\n    }\n    /** Create a deep copy of transformed curves. */\n    cloneTransformed(transform) {\n        return CloneCurvesContext.clone(this, transform);\n    }\n    /** Create a deep copy with all linestrings broken down into multiple LineSegment3d. */\n    cloneWithExpandedLineStrings() {\n        return CloneWithExpandedLineStrings.clone(this);\n    }\n    /**\n     * Push all CurvePrimitives contained in the instance onto the `results` array.\n     * * This method is recursive. For example, if the CurveCollection contains a Loop, all CurvePrimitives\n     * of the Loop are pushed onto `results`.\n     */\n    collectCurvePrimitivesGo(results, smallestPossiblePrimitives, explodeLinestrings = false) {\n        if (this.children) {\n            for (const child of this.children) {\n                if (child instanceof CurvePrimitive)\n                    child.collectCurvePrimitivesGo(results, smallestPossiblePrimitives, explodeLinestrings);\n                else if (child instanceof CurveCollection)\n                    child.collectCurvePrimitivesGo(results, smallestPossiblePrimitives, explodeLinestrings);\n            }\n        }\n    }\n    /**\n     * Return an array containing all CurvePrimitives in the instance.\n     * * This method is recursive. For example, if the CurveCollection contains a Loop, all CurvePrimitives of\n     * the Loop are pushed onto the returned array.\n     * @param collectorArray optional array to receive primitives. If present, new primitives are ADDED (without\n     * clearing the array).\n     * @param smallestPossiblePrimitives if false, CurvePrimitiveWithDistanceIndex returns only itself. If true,\n     * it recurses to its (otherwise hidden) children.\n     */\n    collectCurvePrimitives(collectorArray, smallestPossiblePrimitives = false, explodeLineStrings = false) {\n        const results = collectorArray === undefined ? [] : collectorArray;\n        this.collectCurvePrimitivesGo(results, smallestPossiblePrimitives, explodeLineStrings);\n        return results;\n    }\n    /**\n     * Return true for planar region types:\n     * * `Loop`\n     * * `ParityRegion`\n     * * `UnionRegion`\n     */\n    get isAnyRegionType() {\n        return this.dgnBoundaryType() === 2 || this.dgnBoundaryType() === 4 || this.dgnBoundaryType() === 5;\n    }\n    /** Return true for a `Path`, i.e. a chain of curves joined head-to-tail */\n    get isOpenPath() {\n        return this.dgnBoundaryType() === 1;\n    }\n    /**\n     * Return true for a single-loop planar region type, i.e. `Loop`.\n     * * This is NOT a test for physical closure of a `Path`.\n     */\n    get isClosedPath() {\n        return this.dgnBoundaryType() === 2;\n    }\n    /**\n     * Extend (increase) the given range as needed to encompass all curves in the curve collection.\n     * @param rangeToExtend the given range.\n     * @param transform if supplied, the range is extended with transformed curves.\n     */\n    extendRange(rangeToExtend, transform) {\n        const children = this.children;\n        if (children) {\n            for (const c of children) {\n                c.extendRange(rangeToExtend, transform);\n            }\n        }\n    }\n    /**\n     * Find any CurvePrimitive in the source and evaluate it at the given fraction.\n     * * The first CurvePrimitive found is evaluated. Any other CurvePrimitives are ignored.\n     * @param source containing `CurvePrimitive` or `CurveCollection`\n     * @param fraction fraction to use in `curve.fractionToPoint(fraction)`\n     */\n    static createCurveLocationDetailOnAnyCurvePrimitive(source, fraction = 0.5) {\n        if (!source)\n            return undefined;\n        if (source instanceof CurvePrimitive) {\n            return CurveLocationDetail.createCurveEvaluatedFraction(source, fraction);\n        }\n        else if (source instanceof CurveCollection && source.children !== undefined)\n            for (const child of source.children) {\n                const detail = this.createCurveLocationDetailOnAnyCurvePrimitive(child, fraction);\n                if (detail)\n                    return detail;\n            }\n        return undefined;\n    }\n    /**\n     * Project instance geometry (via dispatch) onto the given ray, and return the extreme fractional parameters\n     * of projection.\n     * @param ray ray onto which the instance is projected. A `Vector3d` is treated as a `Ray3d` with zero origin.\n     * @param lowHigh optional receiver for output\n     * @returns range of fractional projection parameters onto the ray, where 0.0 is start of the ray and 1.0 is the\n     * end of the ray.\n     */\n    projectedParameterRange(ray, lowHigh) {\n        return PlaneAltitudeRangeContext.findExtremeFractionsAlongDirection(this, ray, lowHigh);\n    }\n}\n/**\n * Shared base class for use by both open and closed paths.\n * * A `CurveChain` contains only CurvePrimitives. No other paths, loops, or regions allowed.\n * * The specific derived classes are `Path` and `Loop`.\n * * `CurveChain` is an intermediate class. It is not instantiable on its own.\n * * The related class `CurveChainWithDistanceIndex` is a `CurvePrimitive` whose API presents well-defined mappings\n * from fraction to xyz over the entire chain, but in fact does all the calculations over multiple primitives.\n * @see [Curve Collections]($docs/learning/geometry/CurveCollection.md) learning article.\n * @public\n */\nexport class CurveChain extends CurveCollection {\n    /** Constructor */\n    constructor() {\n        super();\n        this._curves = [];\n    }\n    /** Return the array of `CurvePrimitive` */\n    get children() {\n        return this._curves;\n    }\n    /**\n     * Return the curve primitive at the given `index`, optionally using `modulo` to map `index` to the cyclic indexing.\n     * * In particular, `-1` is the final curve.\n     * @param index cyclic index\n     */\n    cyclicCurvePrimitive(index, cyclic = true) {\n        const n = this.children.length;\n        if (n === 0)\n            return undefined;\n        if (index >= 0 && index < n) // try simplest non-cyclic access first\n            return this.children[index];\n        if (cyclic) {\n            const index2 = Geometry.modulo(index, n);\n            return this.children[index2];\n        }\n        return undefined;\n    }\n    /**\n     * Stroke the chain into a simple xyz array.\n     * @param options tolerance parameters controlling the stroking.\n     */\n    getPackedStrokes(options) {\n        /**\n         * The object returned by \"cloneStroked\" has the same type (Loop or Path) but instead of a chain of\n         * CurvePrimitives as children, it has a single LineString3d child. \"getPackedStrokes\" just returns\n         * the points of that LineString3d using \"packedPoints\".\n         */\n        const tree = this.cloneStroked(options);\n        if (tree instanceof CurveChain) {\n            const children = tree.children;\n            if (children.length === 1) {\n                const ls = children[0];\n                if (ls instanceof LineString3d)\n                    return ls.packedPoints;\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Add a child curve.\n     * * Returns false if the given child is not a CurvePrimitive.\n     */\n    tryAddChild(child) {\n        if (child && child instanceof CurvePrimitive) {\n            this._curves.push(child);\n            return true;\n        }\n        return false;\n    }\n    /** Return a child by index */\n    getChild(i) {\n        if (i < this._curves.length)\n            return this._curves[i];\n        return undefined;\n    }\n    /** Invoke `curve.extendRange(range, transform)` for each child  */\n    extendRange(range, transform) {\n        for (const curve of this._curves)\n            curve.extendRange(range, transform);\n    }\n    /**\n     * Reverse each child curve (in place)\n     * Reverse the order of the children in the CurveChain array.\n     */\n    reverseChildrenInPlace() {\n        for (const curve of this._curves)\n            curve.reverseInPlace();\n        this._curves.reverse();\n    }\n    /**\n     * Return the index where target is found in the array of children.\n     * @param alsoSearchProxies whether to also check proxy curves of the children\n     */\n    childIndex(target, alsoSearchProxies) {\n        for (let i = 0; i < this._curves.length; i++) {\n            if (this._curves[i] === target)\n                return i;\n        }\n        if (alsoSearchProxies ?? false) {\n            for (let i = 0; i < this._curves.length; i++) {\n                const childCurve = this._curves[i];\n                if (childCurve instanceof ProxyCurve) {\n                    if (childCurve.proxyCurve === target)\n                        return i;\n                }\n            }\n        }\n        return undefined;\n    }\n    /** Evaluate an indexed curve at a fraction. Return as a CurveLocationDetail that indicates the primitive. */\n    primitiveIndexAndFractionToCurveLocationDetailPointAndDerivative(index, fraction, cyclic = false, result) {\n        const primitive = this.cyclicCurvePrimitive(index, cyclic);\n        if (primitive) {\n            return CurveLocationDetail.createCurveEvaluatedFractionPointAndDerivative(primitive, fraction, result);\n        }\n        return undefined;\n    }\n}\n/**\n * * A `BagOfCurves` object is a collection of `AnyCurve` objects.\n * * A `BagOfCurves` has no implied properties such as being planar.\n * @public\n */\nexport class BagOfCurves extends CurveCollection {\n    /** Test if `other` is an instance of `BagOfCurves` */\n    isSameGeometryClass(other) {\n        return other instanceof BagOfCurves;\n    }\n    /** Construct an empty `BagOfCurves` */\n    constructor() {\n        super();\n        /** String name for schema properties */\n        this.curveCollectionType = \"bagOfCurves\";\n        this._children = [];\n    }\n    /** Return the (reference to) array of children */\n    get children() {\n        return this._children;\n    }\n    /** Create with given curves. */\n    static create(...data) {\n        const result = new BagOfCurves();\n        for (const child of data) {\n            result.tryAddChild(child);\n        }\n        return result;\n    }\n    /** Return the boundary type (0) of a corresponding  MicroStation CurveVector */\n    dgnBoundaryType() {\n        return 0;\n    }\n    /** Invoke `processor.announceBagOfCurves(this, indexInParent);` */\n    announceToCurveProcessor(processor, indexInParent = -1) {\n        return processor.announceBagOfCurves(this, indexInParent);\n    }\n    /** Clone all children in stroked form. */\n    cloneStroked(options) {\n        const clone = new BagOfCurves();\n        let child;\n        for (child of this.children) {\n            if (child instanceof CurvePrimitive) {\n                const ls = LineString3d.create();\n                child.emitStrokes(ls, options);\n                if (ls)\n                    clone.children.push(ls);\n            }\n            else if (child instanceof CurveCollection) {\n                const childStrokes = child.cloneStroked(options);\n                if (childStrokes)\n                    clone.children.push(childStrokes);\n            }\n        }\n        return clone;\n    }\n    /** Return an empty `BagOfCurves` */\n    cloneEmptyPeer() {\n        return new BagOfCurves();\n    }\n    /** Add a child  */\n    tryAddChild(child) {\n        if (child)\n            this._children.push(child);\n        return true;\n    }\n    /** Get a child by index */\n    getChild(i) {\n        if (i < this._children.length)\n            return this._children[i];\n        return undefined;\n    }\n    /** Second step of double dispatch:  call `handler.handleBagOfCurves(this)` */\n    dispatchToGeometryHandler(handler) {\n        return handler.handleBagOfCurves(this);\n    }\n}\n/**\n * * Options to control method `RegionOps.consolidateAdjacentPrimitives`\n * @public\n */\nexport class ConsolidateAdjacentCurvePrimitivesOptions {\n    constructor() {\n        /** True to consolidated linear geometry   (e.g. separate LineSegment3d and LineString3d) into LineString3d */\n        this.consolidateLinearGeometry = true;\n        /** True to consolidate contiguous arcs */\n        this.consolidateCompatibleArcs = true;\n        /** Tolerance for collapsing identical points */\n        this.duplicatePointTolerance = Geometry.smallMetricDistance;\n        /** Tolerance for removing interior colinear points. */\n        this.colinearPointTolerance = Geometry.smallMetricDistance;\n    }\n}\n//# sourceMappingURL=CurveCollection.js.map",
      "start": 1693508123559,
      "end": 1693508123715,
      "sourcemaps": null
    }
  ]
}
