{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/AuxCoordSys.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Views\n */\nimport { JsonUtils } from \"@itwin/core-bentley\";\nimport { Angle, AngleSweep, Arc3d, Matrix3d, Point2d, Point3d, Transform, Vector3d, YawPitchRollAngles } from \"@itwin/core-geometry\";\nimport { BisCodeSpec, Code, ColorDef, IModel, LinePixels, Npc, } from \"@itwin/core-common\";\nimport { ElementState } from \"./EntityState\";\nimport { GraphicType } from \"./render/GraphicBuilder\";\nimport { CoordSystem } from \"./CoordSystem\";\n/**\n * @public\n * @extensions\n */\nexport var ACSType;\n(function (ACSType) {\n    ACSType[ACSType[\"None\"] = 0] = \"None\";\n    ACSType[ACSType[\"Rectangular\"] = 1] = \"Rectangular\";\n    ACSType[ACSType[\"Cylindrical\"] = 2] = \"Cylindrical\";\n    ACSType[ACSType[\"Spherical\"] = 3] = \"Spherical\";\n})(ACSType || (ACSType = {}));\n/**\n * @public\n * @extensions\n */\nexport var ACSDisplayOptions;\n(function (ACSDisplayOptions) {\n    ACSDisplayOptions[ACSDisplayOptions[\"None\"] = 0] = \"None\";\n    ACSDisplayOptions[ACSDisplayOptions[\"Active\"] = 1] = \"Active\";\n    ACSDisplayOptions[ACSDisplayOptions[\"Deemphasized\"] = 2] = \"Deemphasized\";\n    ACSDisplayOptions[ACSDisplayOptions[\"Hilite\"] = 4] = \"Hilite\";\n    ACSDisplayOptions[ACSDisplayOptions[\"CheckVisible\"] = 8] = \"CheckVisible\";\n    ACSDisplayOptions[ACSDisplayOptions[\"Dynamics\"] = 16] = \"Dynamics\";\n})(ACSDisplayOptions || (ACSDisplayOptions = {}));\n/** The state of an AuxCoordSystem element in the frontend\n * @public\n * @extensions\n */\nexport class AuxCoordSystemState extends ElementState {\n    static get className() { return \"AuxCoordSystem\"; }\n    static fromProps(props, iModel) {\n        const name = props.classFullName.toLowerCase();\n        if (name.endsWith(\"system2d\"))\n            return new AuxCoordSystem2dState(props, iModel);\n        if (name.endsWith(\"system3d\"))\n            return new AuxCoordSystem3dState(props, iModel);\n        return new AuxCoordSystemSpatialState(props, iModel);\n    }\n    /** Create a new AuxCoordSystemState.\n     * @param acsName the name for the new AuxCoordSystem\n     * @param iModel the iModel for which the ACS applies.\n     * @note call this method with the appropriate subclass (e.g. AuxCoordSystemSpatialState, AuxCoordSystem2dState, etc), not on AuxCoordSystemState directly\n     */\n    static createNew(acsName, iModel) {\n        const myCode = new Code({ spec: BisCodeSpec.auxCoordSystemSpatial, scope: IModel.dictionaryId.toString(), value: acsName });\n        return new AuxCoordSystemSpatialState({ model: IModel.dictionaryId, code: myCode, classFullName: this.classFullName }, iModel);\n    }\n    constructor(props, iModel) {\n        super(props, iModel);\n        this.type = JsonUtils.asInt(props.type, ACSType.None);\n        this.description = props.description;\n    }\n    toJSON() {\n        const val = super.toJSON();\n        val.type = this.type;\n        val.description = this.description;\n        return val;\n    }\n    isValidForView(view) {\n        if (view.isSpatialView())\n            return this instanceof AuxCoordSystemSpatialState;\n        return (view.is3d() === this.is3d);\n    }\n    get is3d() { return this instanceof AuxCoordSystem3dState; }\n    drawGrid(context) {\n        // Called for active ACS when grid orientation is GridOrientationType::ACS.\n        const view = context.viewport.view;\n        const fixedRepsAuto = Point2d.create(); // limit grid to project extents\n        context.drawStandardGrid(this.getOrigin(), this.getRotation(), view.getGridSpacing(), view.getGridsPerRef(), false, fixedRepsAuto);\n    }\n    /** Returns the value, clamped to the supplied range. */\n    static limitRange(min, max, val) { return Math.max(min, Math.min(max, val)); }\n    /**\n     * Given an origin point, returns whether the point falls within the view or not. If adjustOrigin is set to true, a point outside\n     * the view will be modified to fall within the appropriate range.\n     */\n    static isOriginInView(drawOrigin, viewport, adjustOrigin) {\n        const testPtView = viewport.worldToView(drawOrigin);\n        const frustum = viewport.getFrustum(CoordSystem.View);\n        const screenRange = Point3d.create();\n        screenRange.x = frustum.points[Npc._000].distance(frustum.points[Npc._100]);\n        screenRange.y = frustum.points[Npc._000].distance(frustum.points[Npc._010]);\n        screenRange.z = frustum.points[Npc._000].distance(frustum.points[Npc._001]);\n        // Check if current acs origin is outside view...\n        const inView = (!((testPtView.x < 0 || testPtView.x > screenRange.x) || (testPtView.y < 0 || testPtView.y > screenRange.y)));\n        if (!adjustOrigin)\n            return inView;\n        if (!inView) {\n            const offset = viewport.pixelsFromInches(0.6 /* ACSDisplaySizes.TriadSizeInches */);\n            testPtView.x = AuxCoordSystemState.limitRange(offset, screenRange.x - offset, testPtView.x);\n            testPtView.y = AuxCoordSystemState.limitRange(offset, screenRange.y - offset, testPtView.y);\n        }\n        // Limit point to NPC box to prevent triad from being clipped from display...\n        const originPtNpc = viewport.viewToNpc(testPtView);\n        originPtNpc.x = AuxCoordSystemState.limitRange(0, 1, originPtNpc.x);\n        originPtNpc.y = AuxCoordSystemState.limitRange(0, 1, originPtNpc.y);\n        originPtNpc.z = AuxCoordSystemState.limitRange(0, 1, originPtNpc.z);\n        viewport.npcToView(originPtNpc, testPtView);\n        viewport.viewToWorld(testPtView, drawOrigin);\n        return inView;\n    }\n    getAdjustedColor(inColor, isFill, viewport, options) {\n        let color;\n        if ((options & ACSDisplayOptions.Hilite) !== ACSDisplayOptions.None) {\n            color = viewport.hilite.color;\n        }\n        else if ((options & ACSDisplayOptions.Active) !== ACSDisplayOptions.None) {\n            color = inColor.equals(ColorDef.white) ? viewport.getContrastToBackgroundColor() : inColor;\n        }\n        else {\n            color = ColorDef.from(150, 150, 150, 0);\n        }\n        color = color.adjustedForContrast(viewport.view.backgroundColor);\n        if (isFill)\n            color = color.withTransparency((options & (ACSDisplayOptions.Deemphasized | ACSDisplayOptions.Dynamics)) !== ACSDisplayOptions.None ? 225 : 200);\n        else\n            color = color.withTransparency((options & ACSDisplayOptions.Deemphasized) !== ACSDisplayOptions.None ? 150 : 75);\n        return color;\n    }\n    addAxisLabel(builder, axis, options, vp) {\n        const color = ColorDef.white;\n        const lineColor = this.getAdjustedColor(color, false, vp, options);\n        builder.setSymbology(lineColor, lineColor, 2);\n        const linePts1 = [];\n        if (0 === axis) {\n            linePts1[0] = Point3d.create(0.4 /* ACSDisplaySizes.LabelStart */, -0.15 /* ACSDisplaySizes.LabelWidth */);\n            linePts1[1] = Point3d.create(0.8 /* ACSDisplaySizes.LabelEnd */, 0.15 /* ACSDisplaySizes.LabelWidth */);\n        }\n        else {\n            linePts1[0] = Point3d.create(0.0, 0.4 /* ACSDisplaySizes.LabelStart */);\n            linePts1[1] = Point3d.create(0.0, (0.4 /* ACSDisplaySizes.LabelStart */ + 0.8 /* ACSDisplaySizes.LabelEnd */) * 0.5);\n        }\n        builder.addLineString(linePts1);\n        const linePts2 = []; // NOTE: Don't use same point array, addPointString/addLineString don't deep copy...\n        if (0 === axis) {\n            linePts2[0] = Point3d.create(0.4 /* ACSDisplaySizes.LabelStart */, 0.15 /* ACSDisplaySizes.LabelWidth */);\n            linePts2[1] = Point3d.create(0.8 /* ACSDisplaySizes.LabelEnd */, -0.15 /* ACSDisplaySizes.LabelWidth */);\n        }\n        else {\n            linePts2[0] = Point3d.create(0.15 /* ACSDisplaySizes.LabelWidth */, 0.8 /* ACSDisplaySizes.LabelEnd */);\n            linePts2[1] = Point3d.create(0.0, (0.4 /* ACSDisplaySizes.LabelStart */ + 0.8 /* ACSDisplaySizes.LabelEnd */) * 0.5);\n            linePts2[2] = Point3d.create(-0.15 /* ACSDisplaySizes.LabelWidth */, 0.8 /* ACSDisplaySizes.LabelEnd */);\n        }\n        builder.addLineString(linePts2);\n    }\n    addAxis(builder, axis, options, vp) {\n        const color = (0 === axis ? ColorDef.red : (1 === axis ? ColorDef.green : ColorDef.blue));\n        const lineColor = this.getAdjustedColor(color, false, vp, options);\n        const fillColor = this.getAdjustedColor(color, true, vp, options);\n        if (axis === 2) {\n            builder.setSymbology(lineColor, lineColor, 6);\n            builder.addPointString([Point3d.create(0.0, 0.0, 0.65 /* ACSDisplaySizes.ZAxisLength */)]); // NOTE: ACS origin point will be drawn separately as a pickable world decoration...\n            const linePts2 = [Point3d.create(), Point3d.create()]; // NOTE: Don't use same point array, addPointString/addLineString don't deep copy...\n            linePts2[1].z = 0.65 /* ACSDisplaySizes.ZAxisLength */;\n            builder.setSymbology(lineColor, lineColor, 1, (options & ACSDisplayOptions.Dynamics) === ACSDisplayOptions.None ? LinePixels.Solid : LinePixels.Code2);\n            builder.addLineString(linePts2);\n            const scale = 0.4 /* ACSDisplaySizes.ArrowTipWidth */ / 2;\n            const center = Point3d.create();\n            const viewRMatrix = vp.rotation;\n            const xVec = viewRMatrix.getRow(0);\n            const yVec = viewRMatrix.getRow(1);\n            builder.placement.matrix.multiplyTransposeVectorInPlace(xVec);\n            builder.placement.matrix.multiplyTransposeVectorInPlace(yVec);\n            xVec.normalize(xVec);\n            yVec.normalize(yVec);\n            const ellipse = Arc3d.createScaledXYColumns(center, Matrix3d.createColumns(xVec, yVec, Vector3d.create()), scale, scale, AngleSweep.createStartEnd(Angle.createRadians(0), Angle.createRadians(Math.PI * 2)));\n            builder.addArc(ellipse, false, false);\n            builder.setBlankingFill(fillColor);\n            builder.addArc(ellipse, true, true);\n            return;\n        }\n        const shapePts = [];\n        shapePts[0] = Point3d.create(1.25 /* ACSDisplaySizes.ArrowTipEnd */, 0.0);\n        shapePts[1] = Point3d.create(0.75 /* ACSDisplaySizes.ArrowTipFlange */, 0.4 /* ACSDisplaySizes.ArrowTipWidth */);\n        shapePts[2] = Point3d.create(0.85 /* ACSDisplaySizes.ArrowTipStart */, 0.2 /* ACSDisplaySizes.ArrowBaseWidth */);\n        shapePts[3] = Point3d.create(0.3 /* ACSDisplaySizes.ArrowBaseStart */, 0.2 /* ACSDisplaySizes.ArrowBaseWidth */);\n        shapePts[4] = Point3d.create(0.3 /* ACSDisplaySizes.ArrowBaseStart */, -0.2 /* ACSDisplaySizes.ArrowBaseWidth */);\n        shapePts[5] = Point3d.create(0.85 /* ACSDisplaySizes.ArrowTipStart */, -0.2 /* ACSDisplaySizes.ArrowBaseWidth */);\n        shapePts[6] = Point3d.create(0.75 /* ACSDisplaySizes.ArrowTipFlange */, -0.4 /* ACSDisplaySizes.ArrowTipWidth */);\n        shapePts[7] = shapePts[0].clone();\n        if (1 === axis)\n            shapePts.forEach((tmpPt) => tmpPt.set(tmpPt.y, tmpPt.x));\n        builder.setSymbology(lineColor, lineColor, 1, (options & ACSDisplayOptions.Dynamics) === ACSDisplayOptions.None ? LinePixels.Solid : LinePixels.Code2);\n        builder.addLineString(shapePts);\n        this.addAxisLabel(builder, axis, options, vp);\n        builder.setBlankingFill(fillColor);\n        builder.addShape(shapePts);\n    }\n    /** Returns a GraphicBuilder for this AuxCoordSystemState. */\n    createGraphicBuilder(context, options) {\n        const checkOutOfView = (options & ACSDisplayOptions.CheckVisible) !== ACSDisplayOptions.None;\n        const drawOrigin = this.getOrigin();\n        if (checkOutOfView && !AuxCoordSystemState.isOriginInView(drawOrigin, context.viewport, true))\n            options = options | ACSDisplayOptions.Deemphasized;\n        let pixelSize = context.viewport.pixelsFromInches(0.6 /* ACSDisplaySizes.TriadSizeInches */);\n        if ((options & ACSDisplayOptions.Deemphasized) !== ACSDisplayOptions.None)\n            pixelSize *= 0.8;\n        else if ((options & ACSDisplayOptions.Active) !== ACSDisplayOptions.None)\n            pixelSize *= 0.9;\n        const exaggerate = context.viewport.view.getAspectRatioSkew();\n        const scale = context.getPixelSizeAtPoint(drawOrigin) * pixelSize;\n        const rMatrix = this.getRotation();\n        rMatrix.transposeInPlace();\n        rMatrix.scaleColumns(scale, scale / exaggerate, scale, rMatrix);\n        const transform = Transform.createRefs(drawOrigin, rMatrix);\n        const builder = context.createGraphicBuilder(GraphicType.WorldOverlay, transform);\n        const vp = context.viewport;\n        this.addAxis(builder, 0, options, vp);\n        this.addAxis(builder, 1, options, vp);\n        this.addAxis(builder, 2, options, vp);\n        return builder;\n    }\n    display(context, options) {\n        const builder = this.createGraphicBuilder(context, options);\n        if (undefined !== builder)\n            context.addDecorationFromBuilder(builder);\n    }\n}\n/** The state of an AuxCoordSystem2d element in the frontend\n * @public\n * @extensions\n */\nexport class AuxCoordSystem2dState extends AuxCoordSystemState {\n    static get className() { return \"AuxCoordSystem2d\"; }\n    constructor(props, iModel) {\n        super(props, iModel);\n        this.origin = Point2d.fromJSON(props.origin);\n        this.angle = JsonUtils.asDouble(props.angle);\n        this._rMatrix = Matrix3d.createRotationAroundVector(Vector3d.unitZ(), Angle.createDegrees(this.angle));\n    }\n    toJSON() {\n        const val = super.toJSON();\n        val.origin = this.origin;\n        val.angle = this.angle;\n        return val;\n    }\n    getOrigin(result) { return Point3d.createFrom(this.origin, result); }\n    setOrigin(val) { this.origin.setFrom(val); }\n    getRotation(result) { return this._rMatrix.clone(result); }\n    setRotation(val) {\n        this._rMatrix.setFrom(val);\n        const angle = YawPitchRollAngles.createFromMatrix3d(val);\n        this.angle = (undefined !== angle ? angle.yaw.degrees : 0.0);\n    }\n}\n/** The state of an AuxCoordSystem3d element in the frontend\n * @public\n * @extensions\n */\nexport class AuxCoordSystem3dState extends AuxCoordSystemState {\n    static get className() { return \"AuxCoordSystem3d\"; }\n    constructor(props, iModel) {\n        super(props, iModel);\n        this.origin = Point3d.fromJSON(props.origin);\n        this.yaw = JsonUtils.asDouble(props.yaw);\n        this.pitch = JsonUtils.asDouble(props.pitch);\n        this.roll = JsonUtils.asDouble(props.roll);\n        const angles = new YawPitchRollAngles(Angle.createDegrees(this.yaw), Angle.createDegrees(this.pitch), Angle.createDegrees(this.roll));\n        this._rMatrix = angles.toMatrix3d();\n    }\n    toJSON() {\n        const val = super.toJSON();\n        val.origin = this.origin;\n        val.yaw = this.yaw;\n        val.pitch = this.pitch;\n        val.roll = this.roll;\n        return val;\n    }\n    getOrigin(result) { return Point3d.createFrom(this.origin, result); }\n    setOrigin(val) { this.origin.setFrom(val); }\n    getRotation(result) { return this._rMatrix.clone(result); }\n    setRotation(rMatrix) {\n        this._rMatrix.setFrom(rMatrix);\n        const angles = YawPitchRollAngles.createFromMatrix3d(rMatrix);\n        this.yaw = (undefined !== angles ? angles.yaw.degrees : 0.0);\n        this.pitch = (undefined !== angles ? angles.pitch.degrees : 0.0);\n        this.roll = (undefined !== angles ? angles.roll.degrees : 0.0);\n    }\n}\n/** The state of an AuxCoordSystemSpatial element in the frontend\n * @public\n * @extensions\n */\nexport class AuxCoordSystemSpatialState extends AuxCoordSystem3dState {\n    static get className() { return \"AuxCoordSystemSpatial\"; }\n}\n//# sourceMappingURL=AuxCoordSys.js.map",
      "start": 1693508118460,
      "end": 1693508119042,
      "sourcemaps": null
    }
  ]
}
