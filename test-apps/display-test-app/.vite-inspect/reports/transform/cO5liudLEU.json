{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tile/IModelTileTree.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tiles\n */\nimport { assert, BeTimePoint } from \"@itwin/core-bentley\";\nimport { Range3d, Transform } from \"@itwin/core-geometry\";\nimport { BatchType, ContentIdProvider, FeatureAppearanceProvider, } from \"@itwin/core-common\";\nimport { IModelApp } from \"../IModelApp\";\nimport { GraphicalEditingScope } from \"../GraphicalEditingScope\";\nimport { GraphicBranch } from \"../render/GraphicBranch\";\nimport { acquireImdlDecoder, DynamicIModelTile, IModelTile, iModelTileParamsFromJSON, Tile, TileLoadPriority, TileTree, } from \"./internal\";\n// Overrides nothing.\nconst viewFlagOverrides = {};\n/** @internal */\nexport function iModelTileTreeParamsFromJSON(props, iModel, modelId, options) {\n    const location = Transform.fromJSON(props.location);\n    const { formatVersion, id, rootTile, contentIdQualifier, maxInitialTilesToSkip, geometryGuid } = props;\n    const tileScreenSize = props.tileScreenSize ?? 512;\n    let contentRange;\n    if (undefined !== props.contentRange)\n        contentRange = Range3d.fromJSON(props.contentRange);\n    let transformNodeRanges;\n    if (props.transformNodeRanges) {\n        transformNodeRanges = new Map();\n        for (const entry of props.transformNodeRanges)\n            transformNodeRanges.set(entry.id, Range3d.fromJSON(entry));\n    }\n    const priority = BatchType.Primary === options.batchType ? TileLoadPriority.Primary : TileLoadPriority.Classifier;\n    return {\n        formatVersion,\n        id,\n        rootTile,\n        iModel,\n        location,\n        modelId,\n        contentRange,\n        geometryGuid,\n        contentIdQualifier,\n        maxInitialTilesToSkip,\n        priority,\n        options,\n        tileScreenSize,\n        transformNodeRanges,\n    };\n}\nfunction findElementChangesForModel(changes, modelId) {\n    for (const change of changes)\n        if (change.id === modelId)\n            return change.elements;\n    return undefined;\n}\n/** No graphical editing scope is currently active. */\nclass StaticState {\n    constructor(root) {\n        this.type = \"static\";\n        this.dispose = GraphicalEditingScope.onEnter.addOnce((scope) => {\n            root.transition(new InteractiveState(scope, root));\n        });\n    }\n}\n/** A graphical editing scope is currently active, but no elements in the tile tree's model have been modified. */\nclass InteractiveState {\n    constructor(scope, root) {\n        this.type = \"interactive\";\n        const removeEndingListener = scope.onExiting.addOnce((_) => {\n            root.transition(new StaticState(root));\n        });\n        const removeGeomListener = scope.onGeometryChanges.addListener((changes, _scope) => {\n            assert(scope === _scope);\n            const elemChanges = findElementChangesForModel(changes, root.tree.modelId);\n            if (elemChanges)\n                root.transition(new DynamicState(root, elemChanges, scope));\n        });\n        this.dispose = () => {\n            removeEndingListener();\n            removeGeomListener();\n        };\n    }\n}\n/** Elements in the tile tree's model have been modified during the current editing scope. */\nclass DynamicState {\n    dispose() {\n        this._dispose();\n        this.rootTile.dispose();\n    }\n    constructor(root, elemChanges, scope) {\n        this.type = \"dynamic\";\n        this.rootTile = DynamicIModelTile.create(root, elemChanges);\n        const removeEndingListener = scope.onExiting.addOnce((_) => {\n            root.transition(new StaticState(root));\n        });\n        const removeGeomListener = scope.onGeometryChanges.addListener((changes, _scope) => {\n            assert(scope === _scope);\n            const elems = findElementChangesForModel(changes, root.tree.modelId);\n            if (elems)\n                this.rootTile.handleGeometryChanges(elems);\n        });\n        this._dispose = () => {\n            removeEndingListener();\n            removeGeomListener();\n        };\n    }\n}\n/** The tile tree has been disposed. */\nclass DisposedState {\n    constructor() {\n        this.type = \"disposed\";\n    }\n    dispose() { }\n}\nconst disposedState = new DisposedState();\n/** Represents the root [[Tile]] of an [[IModelTileTree]]. The root tile has one or two direct child tiles which represent different branches of the tree:\n *  - The static branch, containing tiles that represent the state of the model's geometry as of the beginning of the current [[GraphicalEditingScope]].\n *  - The dynamic branch, containing tiles representing the geometry of elements that have been modified during the current [[GraphicalEditingScope]].\n * If no editing scope is currently active, the dynamic branch does not exist, and the static branch represents the current state of all elements in the model.\n */\nclass RootTile extends Tile {\n    get tileState() {\n        return this._tileState;\n    }\n    constructor(params, tree) {\n        const rootParams = {\n            ...params,\n            range: params.range.clone(),\n            contentRange: params.contentRange?.clone(),\n            isLeaf: false,\n            contentId: \"\",\n        };\n        super(rootParams, tree);\n        this.staticBranch = new IModelTile(params, tree);\n        this._staticTreeContentRange = tree.contentRange?.clone();\n        if (!this._contentRange)\n            this._contentRange = this.staticBranch.contentRange.clone();\n        // Determine initial state.\n        const scope = tree.iModel.isBriefcaseConnection() ? tree.iModel.editingScope : undefined;\n        if (undefined === scope) {\n            this._tileState = new StaticState(this);\n        }\n        else {\n            const changes = scope.getGeometryChangesForModel(tree.modelId);\n            this._tileState = changes ? new DynamicState(this, changes, scope) : new InteractiveState(scope, this);\n        }\n        // Load the children immediately.\n        this.setIsReady();\n        this.loadChildren();\n    }\n    dispose() {\n        this.transition(disposedState);\n        super.dispose();\n    }\n    _loadChildren(resolve, _reject) {\n        const children = [this.staticBranch];\n        if (this._tileState.type === \"dynamic\")\n            children.push(this._tileState.rootTile);\n        resolve(children);\n    }\n    get channel() {\n        throw new Error(\"Root iModel tile has no content\");\n    }\n    async requestContent(_isCanceled) {\n        assert(false, \"Root iModel tile has no content\");\n        return undefined;\n    }\n    async readContent(_data, _system, _isCanceled) {\n        throw new Error(\"Root iModel tile has no content\");\n    }\n    draw(args, tiles, numStaticTiles) {\n        assert(numStaticTiles >= 0 && numStaticTiles <= tiles.length);\n        // Draw the static tiles.\n        for (let i = 0; i < numStaticTiles; i++)\n            tiles[i].drawGraphics(args);\n        if (\"dynamic\" !== this._tileState.type || numStaticTiles === tiles.length) {\n            if (\"dynamic\" === this._tileState.type)\n                args.addAppearanceProvider(this._tileState.rootTile.appearanceProvider);\n            args.drawGraphics();\n            return;\n        }\n        // We need to hide any modified elements in the static tiles. Pull their graphics into a separate branch.\n        if (!args.graphics.isEmpty) {\n            const staticBranch = new GraphicBranch();\n            for (const staticGraphic of args.graphics.entries)\n                staticBranch.add(staticGraphic);\n            let appearanceProvider = this._tileState.rootTile.appearanceProvider;\n            if (args.appearanceProvider)\n                appearanceProvider = FeatureAppearanceProvider.chain(args.appearanceProvider, appearanceProvider);\n            args.graphics.clear();\n            args.graphics.add(args.context.createGraphicBranch(staticBranch, Transform.createIdentity(), { appearanceProvider }));\n        }\n        // Draw the dynamic tiles.\n        for (let i = numStaticTiles; i < tiles.length; i++)\n            tiles[i].drawGraphics(args);\n        args.drawGraphics();\n    }\n    prune(olderThan) {\n        this.staticBranch.pruneChildren(olderThan);\n        if (\"dynamic\" === this._tileState.type)\n            this._tileState.rootTile.pruneChildren(olderThan);\n    }\n    transition(newState) {\n        assert(newState.type !== this._tileState.type);\n        const resetRange = \"dynamic\" === this._tileState.type;\n        assert(undefined !== this.children);\n        if (\"dynamic\" === this._tileState.type) {\n            assert(2 === this.children.length);\n            this.children.pop();\n        }\n        else if (\"dynamic\" === newState.type) {\n            assert(1 === this.children.length);\n            this.children.push(newState.rootTile);\n        }\n        this._tileState.dispose();\n        this._tileState = newState;\n        if (resetRange)\n            this.resetRange();\n    }\n    resetRange() {\n        this.staticBranch.range.clone(this.range);\n        this.staticBranch.contentRange.clone(this._contentRange);\n        if (this._staticTreeContentRange && this.tree.contentRange)\n            this._staticTreeContentRange.clone(this.tree.contentRange);\n    }\n    get tileScreenSize() {\n        return this.staticBranch.iModelTree.tileScreenSize;\n    }\n    updateDynamicRange(tile) {\n        this.resetRange();\n        if (this._staticTreeContentRange && this.tree.contentRange && !tile.contentRange.isNull)\n            this.tree.contentRange.extendRange(tile.contentRange);\n        if (!tile.range.isNull)\n            this.range.extendRange(tile.range);\n        assert(undefined !== this._contentRange);\n        if (!tile.contentRange.isNull)\n            this._contentRange.extendRange(tile.contentRange);\n    }\n}\n/** A TileTree whose contents are derived from geometry stored in a Model in an IModelDb.\n * @internal\n */\nexport class IModelTileTree extends TileTree {\n    constructor(params, treeId) {\n        super(params);\n        /** A little hacky...we must not override selectTiles(), but draw() needs to distinguish between static and dynamic tiles.\n         * So _selectTiles() puts the static tiles first in the Tile[] array, and records the number of static tiles selected, to be\n         * used by draw().\n         */\n        this._numStaticTilesSelected = 0;\n        this.iModelTileTreeId = treeId;\n        this.contentIdQualifier = params.contentIdQualifier;\n        this.geometryGuid = params.geometryGuid;\n        this.tileScreenSize = params.tileScreenSize;\n        if (BatchType.Primary === treeId.type)\n            this.stringifiedSectionClip = treeId.sectionCut;\n        this.maxInitialTilesToSkip = params.maxInitialTilesToSkip ?? 0;\n        this.maxTilesToSkip = IModelApp.tileAdmin.maximumLevelsToSkip;\n        this._options = params.options;\n        this._transformNodeRanges = params.transformNodeRanges;\n        this.contentIdProvider = ContentIdProvider.create(params.options.allowInstancing, IModelApp.tileAdmin, params.formatVersion);\n        params.rootTile.contentId = this.contentIdProvider.rootContentId;\n        this._rootTile = new RootTile(iModelTileParamsFromJSON(params.rootTile, undefined), this);\n        this.decoder = acquireImdlDecoder({\n            type: this.batchType,\n            omitEdges: false === this.edgeOptions,\n            timeline: this.timeline,\n            iModel: this.iModel,\n            batchModelId: this.modelId,\n            is3d: this.is3d,\n            containsTransformNodes: this.containsTransformNodes,\n            noWorker: !IModelApp.tileAdmin.decodeImdlInWorker,\n        });\n    }\n    dispose() {\n        this.decoder.release();\n        super.dispose();\n    }\n    get maxDepth() { return 32; }\n    get rootTile() { return this._rootTile; }\n    /** Exposed chiefly for tests. */\n    get staticBranch() { return this._rootTile.staticBranch; }\n    get is3d() { return this._options.is3d; }\n    get isContentUnbounded() { return false; }\n    get viewFlagOverrides() { return viewFlagOverrides; }\n    get batchType() { return this._options.batchType; }\n    get edgeOptions() { return this._options.edges; }\n    get timeline() { return this._options.timeline; }\n    get loadPriority() {\n        // If the model has been modified, we want to prioritize keeping its graphics up to date.\n        return this.tileState === \"dynamic\" ? TileLoadPriority.Dynamic : super.loadPriority;\n    }\n    _selectTiles(args) {\n        args.markUsed(this._rootTile);\n        const tiles = [];\n        this._rootTile.staticBranch.selectTiles(tiles, args, 0);\n        this._numStaticTilesSelected = tiles.length;\n        if (this._rootTile.tileState.type === \"dynamic\")\n            this._rootTile.tileState.rootTile.selectTiles(tiles, args);\n        return tiles;\n    }\n    draw(args) {\n        const tiles = this.selectTiles(args);\n        this._rootTile.draw(args, tiles, this._numStaticTilesSelected);\n    }\n    prune() {\n        const olderThan = BeTimePoint.now().minus(this.expirationTime);\n        this._rootTile.prune(olderThan);\n    }\n    /** Exposed strictly for tests. */\n    get tileState() {\n        return this._rootTile.tileState.type;\n    }\n    /** Exposed strictly for tests. */\n    get hiddenElements() {\n        const state = this._rootTile.tileState;\n        return \"dynamic\" === state.type ? state.rootTile.hiddenElements : [];\n    }\n    getTransformNodeRange(nodeId) {\n        return this._transformNodeRanges?.get(nodeId);\n    }\n    get containsTransformNodes() {\n        return undefined !== this._transformNodeRanges;\n    }\n}\n//# sourceMappingURL=IModelTileTree.js.map",
      "start": 1693508122058,
      "end": 1693508122232,
      "sourcemaps": null
    }
  ]
}
