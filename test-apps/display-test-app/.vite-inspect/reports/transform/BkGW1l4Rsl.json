{
  "resolvedId": "D:/hub2023A/itwinjs-core/test-apps/display-test-app/src/frontend/Window.ts",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\r\n* See LICENSE.md in the project root for license terms and full copyright notice.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\nimport { IModelApp } from \"@itwin/core-frontend\";\r\nimport { Surface } from \"./Surface\";\r\n\r\nclass DragState {\r\n  private _newX = 0;\r\n  private _newY = 0;\r\n  private _prevX = 0;\r\n  private _prevY = 0;\r\n\r\n  public constructor(window: Window, click: HTMLElement) {\r\n    const drag = (e: MouseEvent) => {\r\n      window.invalidateDock();\r\n      const target = window.container;\r\n      const surf = window.surface.element;\r\n      e.preventDefault();\r\n      this._newX = this._prevX - e.clientX;\r\n      this._newY = this._prevY - e.clientY;\r\n      this._prevX = e.clientX;\r\n      this._prevY = e.clientY;\r\n\r\n      let top = Math.max(0, target.offsetTop - this._newY);\r\n      let left = Math.max(0, target.offsetLeft - this._newX);\r\n      top = Math.min(surf.clientHeight - target.clientHeight, top);\r\n      left = Math.min(surf.clientWidth - target.clientWidth, left);\r\n      target.style.top = `${top}px`;\r\n      target.style.left = `${left}px`;\r\n    };\r\n\r\n    const stopDrag = () => {\r\n      document.removeEventListener(\"mousemove\", drag);\r\n      document.removeEventListener(\"mouseup\", stopDrag);\r\n    };\r\n\r\n    const startDrag = (e: MouseEvent) => {\r\n      e.preventDefault();\r\n      this._prevX = e.clientX;\r\n      this._prevY = e.clientY;\r\n      document.addEventListener(\"mousemove\", drag);\r\n      document.addEventListener(\"mouseup\", stopDrag);\r\n\r\n      window.focus();\r\n    };\r\n\r\n    click.addEventListener(\"mousedown\", startDrag);\r\n  }\r\n}\r\n\r\nclass ResizeState {\r\n  public readonly minSize: number;\r\n  private _prevWidth = 0;\r\n  private _prevHeight = 0;\r\n  private _prevY = 0;\r\n  private _prevMouseX = 0;\r\n  private _prevMouseY = 0;\r\n\r\n  public constructor(window: Window, click: HTMLElement, minSize = 50) {\r\n    const target = window.container;\r\n    this.minSize = minSize;\r\n    const resize = (e: MouseEvent) => {\r\n      window.invalidateDock();\r\n      const width = this._prevWidth + (e.pageX - this._prevMouseX);\r\n      const height = this._prevHeight - (e.pageY - this._prevMouseY);\r\n      const windowTop = this._prevY + (e.pageY - this._prevMouseY);\r\n      const windowLeft = parseInt(window.container.style.left, 10);\r\n      const windowRight = windowLeft + width;\r\n      const prevBottom = this._prevY + this._prevHeight;\r\n      const surfaceWidth = window.surface.element.clientWidth;\r\n      const surfaceRight = window.surface.element.clientLeft + surfaceWidth;\r\n      const surfaceTop = window.surface.element.clientTop;\r\n\r\n      if (width > this.minSize)\r\n        target.style.width = `${(windowRight <= surfaceRight) ? width : surfaceWidth - windowLeft}px`;\r\n\r\n      if (height > minSize) {\r\n        target.style.height = `${(windowTop >= surfaceTop) ? height : prevBottom}px`;\r\n        target.style.top = `${(windowTop >= surfaceTop) ? windowTop : surfaceTop}px`;\r\n      }\r\n    };\r\n\r\n    const stopResize = () => {\r\n      document.removeEventListener(\"mousemove\", resize);\r\n      document.removeEventListener(\"mouseup\", stopResize);\r\n    };\r\n\r\n    click.addEventListener(\"mousedown\", (e) => {\r\n      e.preventDefault();\r\n      e.stopPropagation();\r\n\r\n      const style = getComputedStyle(target, null);\r\n      const pxToNum = (propName: string) => parseFloat(style.getPropertyValue(propName).replace(\"px\", \"\"));\r\n      this._prevWidth = pxToNum(\"width\");\r\n      this._prevHeight = pxToNum(\"height\");\r\n      this._prevY = pxToNum(\"top\");\r\n      this._prevMouseX = e.pageX;\r\n      this._prevMouseY = e.pageY;\r\n\r\n      document.addEventListener(\"mousemove\", resize);\r\n      document.addEventListener(\"mouseup\", stopResize);\r\n\r\n      window.focus();\r\n    });\r\n  }\r\n}\r\n\r\nexport enum Dock {\r\n  Full = 0,\r\n  Top = 1 << 0,\r\n  Left = 1 << 1,\r\n  Right = 1 << 2,\r\n  Bottom = 1 << 3,\r\n  TopLeft = Top | Left,\r\n  TopRight = Top | Right,\r\n  BottomLeft = Bottom | Left,\r\n  BottomRight = Bottom | Right,\r\n}\r\n\r\ninterface DockState {\r\n  dock: Dock;\r\n  width: number;\r\n  height: number;\r\n  top: string;\r\n  left: string;\r\n}\r\n\r\nclass WindowHeader {\r\n  public readonly window: Window;\r\n  public readonly element: HTMLElement;\r\n  private readonly _titleElement: HTMLElement;\r\n  private readonly _closeElement: HTMLElement;\r\n  private readonly _resizerElement: HTMLElement;\r\n  private _dockState?: DockState;\r\n  private readonly _resizeState: ResizeState;\r\n\r\n  public constructor(window: Window, parent: HTMLElement, title?: string) {\r\n    this.window = window;\r\n    this.element = IModelApp.makeHTMLElement(\"div\", { className: \"floating-window-header\", parent });\r\n\r\n    this._titleElement = IModelApp.makeHTMLElement(\"span\", { parent: this.element });\r\n    this.setTitle(title);\r\n\r\n    this._closeElement = IModelApp.makeHTMLElement(\"div\", { className: \"floating-window-header-close\", parent: this.element });\r\n    this._closeElement.onclick = () => this.window.surface.close(this.window);\r\n    this.hideCloseWidget(!this.window.isCloseable);\r\n\r\n    this._resizerElement = IModelApp.makeHTMLElement(\"div\", { className: \"floating-window-header-resize\", parent: this.element });\r\n    this.hideResizerWidget(!this.window.isResizable);\r\n\r\n    // Left-drag => move\r\n    new DragState(window, this.element);\r\n\r\n    // Left-drag corner => resize\r\n    this._resizeState = new ResizeState(window, this._resizerElement);\r\n\r\n    // Double-click => maximize or restore\r\n    const maximizeOrRestore = () => {\r\n      if (this.isDocked)\r\n        this.undock();\r\n      else\r\n        this.dock(Dock.Full);\r\n    };\r\n\r\n    this.element.addEventListener(\"dblclick\", maximizeOrRestore);\r\n  }\r\n\r\n  public setTitle(title?: string): void {\r\n    this._titleElement.innerText = undefined !== title ? title : \"\";\r\n  }\r\n\r\n  public get title(): string {\r\n    const title = this._titleElement.innerText;\r\n    return title ? title : \"\";\r\n  }\r\n\r\n  public dock(dock: Dock): void {\r\n    // NB: Don't update saved position+dimensions if currently docked.\r\n    const state = this._dockState;\r\n    const target = this.window.container;\r\n    this._dockState = {\r\n      dock,\r\n      width: undefined !== state ? state.width : target.clientWidth,\r\n      height: undefined !== state ? state.height : target.clientHeight,\r\n      top: undefined !== state ? state.top : target.style.top,\r\n      left: undefined !== state ? state.left : target.style.left,\r\n    };\r\n    this.applyDock();\r\n  }\r\n\r\n  public undock(): void {\r\n    const s = this._dockState;\r\n    if (undefined === s)\r\n      return;\r\n\r\n    const target = this.window.container;\r\n    target.style.width = `${s.width}px`;\r\n    target.style.height = `${s.height}px`;\r\n    target.style.top = s.top;\r\n    target.style.left = s.left;\r\n\r\n    this._dockState = undefined;\r\n    this.window.focus();\r\n  }\r\n\r\n  public applyDock(): void {\r\n    if (undefined === this._dockState || !this.window.isResizable)\r\n      return;\r\n\r\n    const surf = this.window.surface;\r\n    const sw = surf.element.clientWidth;\r\n    const sh = surf.element.clientHeight;\r\n    const hw = Math.floor(sw / 2);\r\n    const hh = Math.floor(sh / 2);\r\n\r\n    let l = 0;\r\n    let w = sw;\r\n    let t = 0;\r\n    let h = sh;\r\n\r\n    const dock = this._dockState.dock;\r\n    if (Dock.Full !== dock) {\r\n      if (dock & Dock.Top)\r\n        h = hh;\r\n      else if (dock & Dock.Bottom)\r\n        t = h = hh;\r\n\r\n      if (dock & Dock.Left)\r\n        w = hw;\r\n      else if (dock & Dock.Right)\r\n        l = w = hw;\r\n    }\r\n\r\n    const style = this.window.container.style;\r\n    style.left = `${l}px`;\r\n    style.top = `${t}px`;\r\n    style.width = `${w}px`;\r\n    style.height = `${h}px`;\r\n\r\n    this.window.focus();\r\n  }\r\n\r\n  public ensureInSurface(): void {\r\n    const surf = this.window.surface;\r\n    const surfaceTop = surf.element.clientTop;\r\n    const surfaceBottom = surf.element.clientHeight;\r\n    const surfaceLeft = surf.element.clientLeft;\r\n    const surfaceRight = surfaceLeft + surf.element.clientWidth;\r\n    const style = this.window.container.style;\r\n    const windowHeight = this.window.container.clientHeight;\r\n    const windowWidth = this.window.container.clientWidth;\r\n    let windowTop = parseInt(style.top, 10);\r\n    let windowLeft = parseInt(style.left, 10);\r\n    const windowBottom = windowTop + windowHeight;\r\n    const windowRight = windowLeft + windowWidth;\r\n\r\n    // assure the window above of the surface boarder\r\n    if (windowBottom >= surfaceBottom)\r\n      windowTop = (surfaceBottom - windowHeight);\r\n    if (windowTop < surfaceTop)\r\n      windowTop = surfaceTop;\r\n    style.top = `${windowTop}px`;\r\n    if (windowHeight > surfaceBottom)\r\n      style.height = `${surfaceBottom}px`;\r\n\r\n    // assure the window left of the surface boarder\r\n    if (windowRight >= surfaceRight)\r\n      windowLeft = (surfaceRight - windowWidth);\r\n    if (windowLeft < surfaceLeft)\r\n      windowLeft = surfaceLeft;\r\n    style.left = `${windowLeft}px`;\r\n    if (windowWidth > surfaceRight)\r\n      style.width = `${surfaceRight}px`;\r\n  }\r\n\r\n  public addDock(add: Dock): void {\r\n    if (undefined === this._dockState) {\r\n      this.dock(add);\r\n      return;\r\n    }\r\n\r\n    if (Dock.Full === add)\r\n      return;\r\n\r\n    let dock = this._dockState.dock;\r\n    dock |= add;\r\n    if (add & Dock.Left)\r\n      dock &= ~Dock.Right;\r\n    if (add & Dock.Right)\r\n      dock &= ~Dock.Left;\r\n    if (add & Dock.Top)\r\n      dock &= ~Dock.Bottom;\r\n    if (add & Dock.Bottom)\r\n      dock &= ~Dock.Top;\r\n\r\n    this._dockState.dock = dock;\r\n    this.applyDock();\r\n  }\r\n\r\n  public get isDocked() { return undefined !== this._dockState; }\r\n  public invalidateDock() { this._dockState = undefined; }\r\n\r\n  public resizeContent(w: number, h: number): void {\r\n    // ###TODO kludge for 2px borders...\r\n    w += 4;\r\n    h += 4;\r\n    w = Math.max(w, this._resizeState.minSize);\r\n    h = Math.max(h, this._resizeState.minSize);\r\n\r\n    this._dockState = undefined;\r\n    const pw = this.window.contentDiv.clientWidth;\r\n    const ph = this.window.contentDiv.clientHeight;\r\n    const dw = w - pw;\r\n    const dh = h - ph;\r\n\r\n    const cont = this.window.container;\r\n    cont.style.width = `${cont.clientWidth + dw}px`;\r\n    cont.style.height = `${cont.clientHeight + dh}px`;\r\n  }\r\n\r\n  public hideCloseWidget(hide: boolean) {\r\n    this._closeElement.style.display = hide ? \"none\" : \"block\";\r\n  }\r\n\r\n  public hideResizerWidget(hide: boolean) {\r\n    this._resizerElement.style.display = hide ? \"none\" : \"block\";\r\n  }\r\n\r\n  public markAsPinned(isPinned: boolean) {\r\n    if (isPinned)\r\n      this._resizerElement.classList.add(\"window-pinned\");\r\n    else\r\n      this._resizerElement.classList.remove(\"window-pinned\");\r\n  }\r\n}\r\n\r\nexport interface WindowProps {\r\n  title?: string;\r\n  top?: number;\r\n  left?: number;\r\n  width?: number;\r\n  height?: number;\r\n  scrollbars?: boolean;\r\n}\r\n\r\nexport abstract class Window {\r\n  protected readonly _header: WindowHeader;\r\n  public readonly container: HTMLElement;\r\n  public readonly contentDiv: HTMLDivElement;\r\n  public readonly surface: Surface;\r\n  private _isPinned = false;\r\n\r\n  public abstract get windowId(): string;\r\n\r\n  public constructor(surface: Surface, props?: WindowProps) {\r\n    this.surface = surface;\r\n    this.container = IModelApp.makeHTMLElement(\"div\", { className: \"floating-window-container\" });\r\n\r\n    this.container.style.top = `${0}px`;\r\n    this.container.style.left = `${0}px`;\r\n    this.container.style.width = `${surface.element.clientWidth / 3}px`;\r\n    this.container.style.height = `${surface.element.clientHeight / 3}px`;\r\n    if (undefined !== props) {\r\n      if (undefined !== props.top)\r\n        this.container.style.top = `${props.top}px`;\r\n      if (undefined !== props.left)\r\n        this.container.style.left = `${props.left}px`;\r\n      if (undefined !== props.width)\r\n        this.container.style.width = `${props.width}px`;\r\n      if (undefined !== props.height)\r\n        this.container.style.height = `${props.height}px`;\r\n    }\r\n\r\n    this._header = new WindowHeader(this, this.container, undefined !== props ? props.title : undefined);\r\n    this.contentDiv = IModelApp.makeHTMLElement(\"div\", { className: \"floating-window\", parent: this.container });\r\n    if (props && props.scrollbars)\r\n      this.contentDiv.classList.add(\"overflow-auto\");\r\n  }\r\n\r\n  // Do not set directly - use Surface.togglePin(window)\r\n  public get isPinned(): boolean { return this._isPinned; }\r\n  public set isPinned(value: boolean) {\r\n    this._header.markAsPinned(value);\r\n    this._isPinned = value;\r\n  }\r\n\r\n  public set title(title: string | undefined) {\r\n    this._header.setTitle(title);\r\n  }\r\n\r\n  public focus(): void {\r\n    this.surface.focus(this);\r\n  }\r\n\r\n  public get isDocked() { return this._header.isDocked; }\r\n  public dock(dock: Dock) { this._header.dock(dock); }\r\n  public updateDock() { this._header.applyDock(); }\r\n  public undock() { this._header.undock(); }\r\n  public ensureInSurface() { this._header.ensureInSurface(); }\r\n  public invalidateDock() { this._header.invalidateDock(); }\r\n  public addDock(dock: Dock) { this._header.addDock(dock); }\r\n  public updateUi(): void { this._header.hideCloseWidget(!this.isCloseable); }\r\n\r\n  public onFocus(): void {\r\n    this.container.classList.add(\"window-focused\");\r\n    this._header.element.classList.add(\"window-header-focused\");\r\n  }\r\n\r\n  public onLoseFocus(): void {\r\n    this.container.classList.remove(\"window-focused\");\r\n    this._header.element.classList.remove(\"window-header-focused\");\r\n  }\r\n\r\n  public onClosing(): void { }\r\n  public onClosed(): void { }\r\n  public get isCloseable(): boolean { return true; }\r\n  public get isResizable(): boolean { return true; }\r\n\r\n  public resizeContent(w: number, h: number): void {\r\n    this._header.resizeContent(w, h);\r\n  }\r\n\r\n  public setHeaderVisible(visible: boolean): void {\r\n    this._header.element.style.display = visible ? \"block\" : \"none\";\r\n  }\r\n}\r\n\r\nexport interface NamedWindowProps extends WindowProps {\r\n  id: string;\r\n}\r\n\r\nexport class NamedWindow extends Window {\r\n  private readonly _windowId: string;\r\n\r\n  public constructor(surface: Surface, props: NamedWindowProps) {\r\n    super(surface, props);\r\n    this._windowId = props.id;\r\n    if (undefined === props.title)\r\n      this._header.setTitle(this.windowId);\r\n  }\r\n\r\n  public get windowId() { return this._windowId; }\r\n}\r\n",
      "start": 1693508118379,
      "end": 1693508118561,
      "sourcemaps": null
    },
    {
      "name": "vite:esbuild",
      "result": "\"use strict\";\nimport { IModelApp } from \"@itwin/core-frontend\";\nclass DragState {\n  constructor(window, click) {\n    this._newX = 0;\n    this._newY = 0;\n    this._prevX = 0;\n    this._prevY = 0;\n    const drag = (e) => {\n      window.invalidateDock();\n      const target = window.container;\n      const surf = window.surface.element;\n      e.preventDefault();\n      this._newX = this._prevX - e.clientX;\n      this._newY = this._prevY - e.clientY;\n      this._prevX = e.clientX;\n      this._prevY = e.clientY;\n      let top = Math.max(0, target.offsetTop - this._newY);\n      let left = Math.max(0, target.offsetLeft - this._newX);\n      top = Math.min(surf.clientHeight - target.clientHeight, top);\n      left = Math.min(surf.clientWidth - target.clientWidth, left);\n      target.style.top = `${top}px`;\n      target.style.left = `${left}px`;\n    };\n    const stopDrag = () => {\n      document.removeEventListener(\"mousemove\", drag);\n      document.removeEventListener(\"mouseup\", stopDrag);\n    };\n    const startDrag = (e) => {\n      e.preventDefault();\n      this._prevX = e.clientX;\n      this._prevY = e.clientY;\n      document.addEventListener(\"mousemove\", drag);\n      document.addEventListener(\"mouseup\", stopDrag);\n      window.focus();\n    };\n    click.addEventListener(\"mousedown\", startDrag);\n  }\n}\nclass ResizeState {\n  constructor(window, click, minSize = 50) {\n    this._prevWidth = 0;\n    this._prevHeight = 0;\n    this._prevY = 0;\n    this._prevMouseX = 0;\n    this._prevMouseY = 0;\n    const target = window.container;\n    this.minSize = minSize;\n    const resize = (e) => {\n      window.invalidateDock();\n      const width = this._prevWidth + (e.pageX - this._prevMouseX);\n      const height = this._prevHeight - (e.pageY - this._prevMouseY);\n      const windowTop = this._prevY + (e.pageY - this._prevMouseY);\n      const windowLeft = parseInt(window.container.style.left, 10);\n      const windowRight = windowLeft + width;\n      const prevBottom = this._prevY + this._prevHeight;\n      const surfaceWidth = window.surface.element.clientWidth;\n      const surfaceRight = window.surface.element.clientLeft + surfaceWidth;\n      const surfaceTop = window.surface.element.clientTop;\n      if (width > this.minSize)\n        target.style.width = `${windowRight <= surfaceRight ? width : surfaceWidth - windowLeft}px`;\n      if (height > minSize) {\n        target.style.height = `${windowTop >= surfaceTop ? height : prevBottom}px`;\n        target.style.top = `${windowTop >= surfaceTop ? windowTop : surfaceTop}px`;\n      }\n    };\n    const stopResize = () => {\n      document.removeEventListener(\"mousemove\", resize);\n      document.removeEventListener(\"mouseup\", stopResize);\n    };\n    click.addEventListener(\"mousedown\", (e) => {\n      e.preventDefault();\n      e.stopPropagation();\n      const style = getComputedStyle(target, null);\n      const pxToNum = (propName) => parseFloat(style.getPropertyValue(propName).replace(\"px\", \"\"));\n      this._prevWidth = pxToNum(\"width\");\n      this._prevHeight = pxToNum(\"height\");\n      this._prevY = pxToNum(\"top\");\n      this._prevMouseX = e.pageX;\n      this._prevMouseY = e.pageY;\n      document.addEventListener(\"mousemove\", resize);\n      document.addEventListener(\"mouseup\", stopResize);\n      window.focus();\n    });\n  }\n}\nexport var Dock = /* @__PURE__ */ ((Dock2) => {\n  Dock2[Dock2[\"Full\"] = 0] = \"Full\";\n  Dock2[Dock2[\"Top\"] = 1] = \"Top\";\n  Dock2[Dock2[\"Left\"] = 2] = \"Left\";\n  Dock2[Dock2[\"Right\"] = 4] = \"Right\";\n  Dock2[Dock2[\"Bottom\"] = 8] = \"Bottom\";\n  Dock2[Dock2[\"TopLeft\"] = 3] = \"TopLeft\";\n  Dock2[Dock2[\"TopRight\"] = 5] = \"TopRight\";\n  Dock2[Dock2[\"BottomLeft\"] = 10] = \"BottomLeft\";\n  Dock2[Dock2[\"BottomRight\"] = 12] = \"BottomRight\";\n  return Dock2;\n})(Dock || {});\nclass WindowHeader {\n  constructor(window, parent, title) {\n    this.window = window;\n    this.element = IModelApp.makeHTMLElement(\"div\", { className: \"floating-window-header\", parent });\n    this._titleElement = IModelApp.makeHTMLElement(\"span\", { parent: this.element });\n    this.setTitle(title);\n    this._closeElement = IModelApp.makeHTMLElement(\"div\", { className: \"floating-window-header-close\", parent: this.element });\n    this._closeElement.onclick = () => this.window.surface.close(this.window);\n    this.hideCloseWidget(!this.window.isCloseable);\n    this._resizerElement = IModelApp.makeHTMLElement(\"div\", { className: \"floating-window-header-resize\", parent: this.element });\n    this.hideResizerWidget(!this.window.isResizable);\n    new DragState(window, this.element);\n    this._resizeState = new ResizeState(window, this._resizerElement);\n    const maximizeOrRestore = () => {\n      if (this.isDocked)\n        this.undock();\n      else\n        this.dock(0 /* Full */);\n    };\n    this.element.addEventListener(\"dblclick\", maximizeOrRestore);\n  }\n  setTitle(title) {\n    this._titleElement.innerText = void 0 !== title ? title : \"\";\n  }\n  get title() {\n    const title = this._titleElement.innerText;\n    return title ? title : \"\";\n  }\n  dock(dock) {\n    const state = this._dockState;\n    const target = this.window.container;\n    this._dockState = {\n      dock,\n      width: void 0 !== state ? state.width : target.clientWidth,\n      height: void 0 !== state ? state.height : target.clientHeight,\n      top: void 0 !== state ? state.top : target.style.top,\n      left: void 0 !== state ? state.left : target.style.left\n    };\n    this.applyDock();\n  }\n  undock() {\n    const s = this._dockState;\n    if (void 0 === s)\n      return;\n    const target = this.window.container;\n    target.style.width = `${s.width}px`;\n    target.style.height = `${s.height}px`;\n    target.style.top = s.top;\n    target.style.left = s.left;\n    this._dockState = void 0;\n    this.window.focus();\n  }\n  applyDock() {\n    if (void 0 === this._dockState || !this.window.isResizable)\n      return;\n    const surf = this.window.surface;\n    const sw = surf.element.clientWidth;\n    const sh = surf.element.clientHeight;\n    const hw = Math.floor(sw / 2);\n    const hh = Math.floor(sh / 2);\n    let l = 0;\n    let w = sw;\n    let t = 0;\n    let h = sh;\n    const dock = this._dockState.dock;\n    if (0 /* Full */ !== dock) {\n      if (dock & 1 /* Top */)\n        h = hh;\n      else if (dock & 8 /* Bottom */)\n        t = h = hh;\n      if (dock & 2 /* Left */)\n        w = hw;\n      else if (dock & 4 /* Right */)\n        l = w = hw;\n    }\n    const style = this.window.container.style;\n    style.left = `${l}px`;\n    style.top = `${t}px`;\n    style.width = `${w}px`;\n    style.height = `${h}px`;\n    this.window.focus();\n  }\n  ensureInSurface() {\n    const surf = this.window.surface;\n    const surfaceTop = surf.element.clientTop;\n    const surfaceBottom = surf.element.clientHeight;\n    const surfaceLeft = surf.element.clientLeft;\n    const surfaceRight = surfaceLeft + surf.element.clientWidth;\n    const style = this.window.container.style;\n    const windowHeight = this.window.container.clientHeight;\n    const windowWidth = this.window.container.clientWidth;\n    let windowTop = parseInt(style.top, 10);\n    let windowLeft = parseInt(style.left, 10);\n    const windowBottom = windowTop + windowHeight;\n    const windowRight = windowLeft + windowWidth;\n    if (windowBottom >= surfaceBottom)\n      windowTop = surfaceBottom - windowHeight;\n    if (windowTop < surfaceTop)\n      windowTop = surfaceTop;\n    style.top = `${windowTop}px`;\n    if (windowHeight > surfaceBottom)\n      style.height = `${surfaceBottom}px`;\n    if (windowRight >= surfaceRight)\n      windowLeft = surfaceRight - windowWidth;\n    if (windowLeft < surfaceLeft)\n      windowLeft = surfaceLeft;\n    style.left = `${windowLeft}px`;\n    if (windowWidth > surfaceRight)\n      style.width = `${surfaceRight}px`;\n  }\n  addDock(add) {\n    if (void 0 === this._dockState) {\n      this.dock(add);\n      return;\n    }\n    if (0 /* Full */ === add)\n      return;\n    let dock = this._dockState.dock;\n    dock |= add;\n    if (add & 2 /* Left */)\n      dock &= ~4 /* Right */;\n    if (add & 4 /* Right */)\n      dock &= ~2 /* Left */;\n    if (add & 1 /* Top */)\n      dock &= ~8 /* Bottom */;\n    if (add & 8 /* Bottom */)\n      dock &= ~1 /* Top */;\n    this._dockState.dock = dock;\n    this.applyDock();\n  }\n  get isDocked() {\n    return void 0 !== this._dockState;\n  }\n  invalidateDock() {\n    this._dockState = void 0;\n  }\n  resizeContent(w, h) {\n    w += 4;\n    h += 4;\n    w = Math.max(w, this._resizeState.minSize);\n    h = Math.max(h, this._resizeState.minSize);\n    this._dockState = void 0;\n    const pw = this.window.contentDiv.clientWidth;\n    const ph = this.window.contentDiv.clientHeight;\n    const dw = w - pw;\n    const dh = h - ph;\n    const cont = this.window.container;\n    cont.style.width = `${cont.clientWidth + dw}px`;\n    cont.style.height = `${cont.clientHeight + dh}px`;\n  }\n  hideCloseWidget(hide) {\n    this._closeElement.style.display = hide ? \"none\" : \"block\";\n  }\n  hideResizerWidget(hide) {\n    this._resizerElement.style.display = hide ? \"none\" : \"block\";\n  }\n  markAsPinned(isPinned) {\n    if (isPinned)\n      this._resizerElement.classList.add(\"window-pinned\");\n    else\n      this._resizerElement.classList.remove(\"window-pinned\");\n  }\n}\nexport class Window {\n  constructor(surface, props) {\n    this._isPinned = false;\n    this.surface = surface;\n    this.container = IModelApp.makeHTMLElement(\"div\", { className: \"floating-window-container\" });\n    this.container.style.top = `${0}px`;\n    this.container.style.left = `${0}px`;\n    this.container.style.width = `${surface.element.clientWidth / 3}px`;\n    this.container.style.height = `${surface.element.clientHeight / 3}px`;\n    if (void 0 !== props) {\n      if (void 0 !== props.top)\n        this.container.style.top = `${props.top}px`;\n      if (void 0 !== props.left)\n        this.container.style.left = `${props.left}px`;\n      if (void 0 !== props.width)\n        this.container.style.width = `${props.width}px`;\n      if (void 0 !== props.height)\n        this.container.style.height = `${props.height}px`;\n    }\n    this._header = new WindowHeader(this, this.container, void 0 !== props ? props.title : void 0);\n    this.contentDiv = IModelApp.makeHTMLElement(\"div\", { className: \"floating-window\", parent: this.container });\n    if (props && props.scrollbars)\n      this.contentDiv.classList.add(\"overflow-auto\");\n  }\n  // Do not set directly - use Surface.togglePin(window)\n  get isPinned() {\n    return this._isPinned;\n  }\n  set isPinned(value) {\n    this._header.markAsPinned(value);\n    this._isPinned = value;\n  }\n  set title(title) {\n    this._header.setTitle(title);\n  }\n  focus() {\n    this.surface.focus(this);\n  }\n  get isDocked() {\n    return this._header.isDocked;\n  }\n  dock(dock) {\n    this._header.dock(dock);\n  }\n  updateDock() {\n    this._header.applyDock();\n  }\n  undock() {\n    this._header.undock();\n  }\n  ensureInSurface() {\n    this._header.ensureInSurface();\n  }\n  invalidateDock() {\n    this._header.invalidateDock();\n  }\n  addDock(dock) {\n    this._header.addDock(dock);\n  }\n  updateUi() {\n    this._header.hideCloseWidget(!this.isCloseable);\n  }\n  onFocus() {\n    this.container.classList.add(\"window-focused\");\n    this._header.element.classList.add(\"window-header-focused\");\n  }\n  onLoseFocus() {\n    this.container.classList.remove(\"window-focused\");\n    this._header.element.classList.remove(\"window-header-focused\");\n  }\n  onClosing() {\n  }\n  onClosed() {\n  }\n  get isCloseable() {\n    return true;\n  }\n  get isResizable() {\n    return true;\n  }\n  resizeContent(w, h) {\n    this._header.resizeContent(w, h);\n  }\n  setHeaderVisible(visible) {\n    this._header.element.style.display = visible ? \"block\" : \"none\";\n  }\n}\nexport class NamedWindow extends Window {\n  constructor(surface, props) {\n    super(surface, props);\n    this._windowId = props.id;\n    if (void 0 === props.title)\n      this._header.setTitle(this.windowId);\n  }\n  get windowId() {\n    return this._windowId;\n  }\n}\n",
      "start": 1693508118561,
      "end": 1693508118676,
      "order": "normal",
      "sourcemaps": {
        "version": 3,
        "sources": [
          "D:/hub2023A/itwinjs-core/test-apps/display-test-app/src/frontend/Window.ts"
        ],
        "sourcesContent": [
          "/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\r\n* See LICENSE.md in the project root for license terms and full copyright notice.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\nimport { IModelApp } from \"@itwin/core-frontend\";\r\nimport { Surface } from \"./Surface\";\r\n\r\nclass DragState {\r\n  private _newX = 0;\r\n  private _newY = 0;\r\n  private _prevX = 0;\r\n  private _prevY = 0;\r\n\r\n  public constructor(window: Window, click: HTMLElement) {\r\n    const drag = (e: MouseEvent) => {\r\n      window.invalidateDock();\r\n      const target = window.container;\r\n      const surf = window.surface.element;\r\n      e.preventDefault();\r\n      this._newX = this._prevX - e.clientX;\r\n      this._newY = this._prevY - e.clientY;\r\n      this._prevX = e.clientX;\r\n      this._prevY = e.clientY;\r\n\r\n      let top = Math.max(0, target.offsetTop - this._newY);\r\n      let left = Math.max(0, target.offsetLeft - this._newX);\r\n      top = Math.min(surf.clientHeight - target.clientHeight, top);\r\n      left = Math.min(surf.clientWidth - target.clientWidth, left);\r\n      target.style.top = `${top}px`;\r\n      target.style.left = `${left}px`;\r\n    };\r\n\r\n    const stopDrag = () => {\r\n      document.removeEventListener(\"mousemove\", drag);\r\n      document.removeEventListener(\"mouseup\", stopDrag);\r\n    };\r\n\r\n    const startDrag = (e: MouseEvent) => {\r\n      e.preventDefault();\r\n      this._prevX = e.clientX;\r\n      this._prevY = e.clientY;\r\n      document.addEventListener(\"mousemove\", drag);\r\n      document.addEventListener(\"mouseup\", stopDrag);\r\n\r\n      window.focus();\r\n    };\r\n\r\n    click.addEventListener(\"mousedown\", startDrag);\r\n  }\r\n}\r\n\r\nclass ResizeState {\r\n  public readonly minSize: number;\r\n  private _prevWidth = 0;\r\n  private _prevHeight = 0;\r\n  private _prevY = 0;\r\n  private _prevMouseX = 0;\r\n  private _prevMouseY = 0;\r\n\r\n  public constructor(window: Window, click: HTMLElement, minSize = 50) {\r\n    const target = window.container;\r\n    this.minSize = minSize;\r\n    const resize = (e: MouseEvent) => {\r\n      window.invalidateDock();\r\n      const width = this._prevWidth + (e.pageX - this._prevMouseX);\r\n      const height = this._prevHeight - (e.pageY - this._prevMouseY);\r\n      const windowTop = this._prevY + (e.pageY - this._prevMouseY);\r\n      const windowLeft = parseInt(window.container.style.left, 10);\r\n      const windowRight = windowLeft + width;\r\n      const prevBottom = this._prevY + this._prevHeight;\r\n      const surfaceWidth = window.surface.element.clientWidth;\r\n      const surfaceRight = window.surface.element.clientLeft + surfaceWidth;\r\n      const surfaceTop = window.surface.element.clientTop;\r\n\r\n      if (width > this.minSize)\r\n        target.style.width = `${(windowRight <= surfaceRight) ? width : surfaceWidth - windowLeft}px`;\r\n\r\n      if (height > minSize) {\r\n        target.style.height = `${(windowTop >= surfaceTop) ? height : prevBottom}px`;\r\n        target.style.top = `${(windowTop >= surfaceTop) ? windowTop : surfaceTop}px`;\r\n      }\r\n    };\r\n\r\n    const stopResize = () => {\r\n      document.removeEventListener(\"mousemove\", resize);\r\n      document.removeEventListener(\"mouseup\", stopResize);\r\n    };\r\n\r\n    click.addEventListener(\"mousedown\", (e) => {\r\n      e.preventDefault();\r\n      e.stopPropagation();\r\n\r\n      const style = getComputedStyle(target, null);\r\n      const pxToNum = (propName: string) => parseFloat(style.getPropertyValue(propName).replace(\"px\", \"\"));\r\n      this._prevWidth = pxToNum(\"width\");\r\n      this._prevHeight = pxToNum(\"height\");\r\n      this._prevY = pxToNum(\"top\");\r\n      this._prevMouseX = e.pageX;\r\n      this._prevMouseY = e.pageY;\r\n\r\n      document.addEventListener(\"mousemove\", resize);\r\n      document.addEventListener(\"mouseup\", stopResize);\r\n\r\n      window.focus();\r\n    });\r\n  }\r\n}\r\n\r\nexport enum Dock {\r\n  Full = 0,\r\n  Top = 1 << 0,\r\n  Left = 1 << 1,\r\n  Right = 1 << 2,\r\n  Bottom = 1 << 3,\r\n  TopLeft = Top | Left,\r\n  TopRight = Top | Right,\r\n  BottomLeft = Bottom | Left,\r\n  BottomRight = Bottom | Right,\r\n}\r\n\r\ninterface DockState {\r\n  dock: Dock;\r\n  width: number;\r\n  height: number;\r\n  top: string;\r\n  left: string;\r\n}\r\n\r\nclass WindowHeader {\r\n  public readonly window: Window;\r\n  public readonly element: HTMLElement;\r\n  private readonly _titleElement: HTMLElement;\r\n  private readonly _closeElement: HTMLElement;\r\n  private readonly _resizerElement: HTMLElement;\r\n  private _dockState?: DockState;\r\n  private readonly _resizeState: ResizeState;\r\n\r\n  public constructor(window: Window, parent: HTMLElement, title?: string) {\r\n    this.window = window;\r\n    this.element = IModelApp.makeHTMLElement(\"div\", { className: \"floating-window-header\", parent });\r\n\r\n    this._titleElement = IModelApp.makeHTMLElement(\"span\", { parent: this.element });\r\n    this.setTitle(title);\r\n\r\n    this._closeElement = IModelApp.makeHTMLElement(\"div\", { className: \"floating-window-header-close\", parent: this.element });\r\n    this._closeElement.onclick = () => this.window.surface.close(this.window);\r\n    this.hideCloseWidget(!this.window.isCloseable);\r\n\r\n    this._resizerElement = IModelApp.makeHTMLElement(\"div\", { className: \"floating-window-header-resize\", parent: this.element });\r\n    this.hideResizerWidget(!this.window.isResizable);\r\n\r\n    // Left-drag => move\r\n    new DragState(window, this.element);\r\n\r\n    // Left-drag corner => resize\r\n    this._resizeState = new ResizeState(window, this._resizerElement);\r\n\r\n    // Double-click => maximize or restore\r\n    const maximizeOrRestore = () => {\r\n      if (this.isDocked)\r\n        this.undock();\r\n      else\r\n        this.dock(Dock.Full);\r\n    };\r\n\r\n    this.element.addEventListener(\"dblclick\", maximizeOrRestore);\r\n  }\r\n\r\n  public setTitle(title?: string): void {\r\n    this._titleElement.innerText = undefined !== title ? title : \"\";\r\n  }\r\n\r\n  public get title(): string {\r\n    const title = this._titleElement.innerText;\r\n    return title ? title : \"\";\r\n  }\r\n\r\n  public dock(dock: Dock): void {\r\n    // NB: Don't update saved position+dimensions if currently docked.\r\n    const state = this._dockState;\r\n    const target = this.window.container;\r\n    this._dockState = {\r\n      dock,\r\n      width: undefined !== state ? state.width : target.clientWidth,\r\n      height: undefined !== state ? state.height : target.clientHeight,\r\n      top: undefined !== state ? state.top : target.style.top,\r\n      left: undefined !== state ? state.left : target.style.left,\r\n    };\r\n    this.applyDock();\r\n  }\r\n\r\n  public undock(): void {\r\n    const s = this._dockState;\r\n    if (undefined === s)\r\n      return;\r\n\r\n    const target = this.window.container;\r\n    target.style.width = `${s.width}px`;\r\n    target.style.height = `${s.height}px`;\r\n    target.style.top = s.top;\r\n    target.style.left = s.left;\r\n\r\n    this._dockState = undefined;\r\n    this.window.focus();\r\n  }\r\n\r\n  public applyDock(): void {\r\n    if (undefined === this._dockState || !this.window.isResizable)\r\n      return;\r\n\r\n    const surf = this.window.surface;\r\n    const sw = surf.element.clientWidth;\r\n    const sh = surf.element.clientHeight;\r\n    const hw = Math.floor(sw / 2);\r\n    const hh = Math.floor(sh / 2);\r\n\r\n    let l = 0;\r\n    let w = sw;\r\n    let t = 0;\r\n    let h = sh;\r\n\r\n    const dock = this._dockState.dock;\r\n    if (Dock.Full !== dock) {\r\n      if (dock & Dock.Top)\r\n        h = hh;\r\n      else if (dock & Dock.Bottom)\r\n        t = h = hh;\r\n\r\n      if (dock & Dock.Left)\r\n        w = hw;\r\n      else if (dock & Dock.Right)\r\n        l = w = hw;\r\n    }\r\n\r\n    const style = this.window.container.style;\r\n    style.left = `${l}px`;\r\n    style.top = `${t}px`;\r\n    style.width = `${w}px`;\r\n    style.height = `${h}px`;\r\n\r\n    this.window.focus();\r\n  }\r\n\r\n  public ensureInSurface(): void {\r\n    const surf = this.window.surface;\r\n    const surfaceTop = surf.element.clientTop;\r\n    const surfaceBottom = surf.element.clientHeight;\r\n    const surfaceLeft = surf.element.clientLeft;\r\n    const surfaceRight = surfaceLeft + surf.element.clientWidth;\r\n    const style = this.window.container.style;\r\n    const windowHeight = this.window.container.clientHeight;\r\n    const windowWidth = this.window.container.clientWidth;\r\n    let windowTop = parseInt(style.top, 10);\r\n    let windowLeft = parseInt(style.left, 10);\r\n    const windowBottom = windowTop + windowHeight;\r\n    const windowRight = windowLeft + windowWidth;\r\n\r\n    // assure the window above of the surface boarder\r\n    if (windowBottom >= surfaceBottom)\r\n      windowTop = (surfaceBottom - windowHeight);\r\n    if (windowTop < surfaceTop)\r\n      windowTop = surfaceTop;\r\n    style.top = `${windowTop}px`;\r\n    if (windowHeight > surfaceBottom)\r\n      style.height = `${surfaceBottom}px`;\r\n\r\n    // assure the window left of the surface boarder\r\n    if (windowRight >= surfaceRight)\r\n      windowLeft = (surfaceRight - windowWidth);\r\n    if (windowLeft < surfaceLeft)\r\n      windowLeft = surfaceLeft;\r\n    style.left = `${windowLeft}px`;\r\n    if (windowWidth > surfaceRight)\r\n      style.width = `${surfaceRight}px`;\r\n  }\r\n\r\n  public addDock(add: Dock): void {\r\n    if (undefined === this._dockState) {\r\n      this.dock(add);\r\n      return;\r\n    }\r\n\r\n    if (Dock.Full === add)\r\n      return;\r\n\r\n    let dock = this._dockState.dock;\r\n    dock |= add;\r\n    if (add & Dock.Left)\r\n      dock &= ~Dock.Right;\r\n    if (add & Dock.Right)\r\n      dock &= ~Dock.Left;\r\n    if (add & Dock.Top)\r\n      dock &= ~Dock.Bottom;\r\n    if (add & Dock.Bottom)\r\n      dock &= ~Dock.Top;\r\n\r\n    this._dockState.dock = dock;\r\n    this.applyDock();\r\n  }\r\n\r\n  public get isDocked() { return undefined !== this._dockState; }\r\n  public invalidateDock() { this._dockState = undefined; }\r\n\r\n  public resizeContent(w: number, h: number): void {\r\n    // ###TODO kludge for 2px borders...\r\n    w += 4;\r\n    h += 4;\r\n    w = Math.max(w, this._resizeState.minSize);\r\n    h = Math.max(h, this._resizeState.minSize);\r\n\r\n    this._dockState = undefined;\r\n    const pw = this.window.contentDiv.clientWidth;\r\n    const ph = this.window.contentDiv.clientHeight;\r\n    const dw = w - pw;\r\n    const dh = h - ph;\r\n\r\n    const cont = this.window.container;\r\n    cont.style.width = `${cont.clientWidth + dw}px`;\r\n    cont.style.height = `${cont.clientHeight + dh}px`;\r\n  }\r\n\r\n  public hideCloseWidget(hide: boolean) {\r\n    this._closeElement.style.display = hide ? \"none\" : \"block\";\r\n  }\r\n\r\n  public hideResizerWidget(hide: boolean) {\r\n    this._resizerElement.style.display = hide ? \"none\" : \"block\";\r\n  }\r\n\r\n  public markAsPinned(isPinned: boolean) {\r\n    if (isPinned)\r\n      this._resizerElement.classList.add(\"window-pinned\");\r\n    else\r\n      this._resizerElement.classList.remove(\"window-pinned\");\r\n  }\r\n}\r\n\r\nexport interface WindowProps {\r\n  title?: string;\r\n  top?: number;\r\n  left?: number;\r\n  width?: number;\r\n  height?: number;\r\n  scrollbars?: boolean;\r\n}\r\n\r\nexport abstract class Window {\r\n  protected readonly _header: WindowHeader;\r\n  public readonly container: HTMLElement;\r\n  public readonly contentDiv: HTMLDivElement;\r\n  public readonly surface: Surface;\r\n  private _isPinned = false;\r\n\r\n  public abstract get windowId(): string;\r\n\r\n  public constructor(surface: Surface, props?: WindowProps) {\r\n    this.surface = surface;\r\n    this.container = IModelApp.makeHTMLElement(\"div\", { className: \"floating-window-container\" });\r\n\r\n    this.container.style.top = `${0}px`;\r\n    this.container.style.left = `${0}px`;\r\n    this.container.style.width = `${surface.element.clientWidth / 3}px`;\r\n    this.container.style.height = `${surface.element.clientHeight / 3}px`;\r\n    if (undefined !== props) {\r\n      if (undefined !== props.top)\r\n        this.container.style.top = `${props.top}px`;\r\n      if (undefined !== props.left)\r\n        this.container.style.left = `${props.left}px`;\r\n      if (undefined !== props.width)\r\n        this.container.style.width = `${props.width}px`;\r\n      if (undefined !== props.height)\r\n        this.container.style.height = `${props.height}px`;\r\n    }\r\n\r\n    this._header = new WindowHeader(this, this.container, undefined !== props ? props.title : undefined);\r\n    this.contentDiv = IModelApp.makeHTMLElement(\"div\", { className: \"floating-window\", parent: this.container });\r\n    if (props && props.scrollbars)\r\n      this.contentDiv.classList.add(\"overflow-auto\");\r\n  }\r\n\r\n  // Do not set directly - use Surface.togglePin(window)\r\n  public get isPinned(): boolean { return this._isPinned; }\r\n  public set isPinned(value: boolean) {\r\n    this._header.markAsPinned(value);\r\n    this._isPinned = value;\r\n  }\r\n\r\n  public set title(title: string | undefined) {\r\n    this._header.setTitle(title);\r\n  }\r\n\r\n  public focus(): void {\r\n    this.surface.focus(this);\r\n  }\r\n\r\n  public get isDocked() { return this._header.isDocked; }\r\n  public dock(dock: Dock) { this._header.dock(dock); }\r\n  public updateDock() { this._header.applyDock(); }\r\n  public undock() { this._header.undock(); }\r\n  public ensureInSurface() { this._header.ensureInSurface(); }\r\n  public invalidateDock() { this._header.invalidateDock(); }\r\n  public addDock(dock: Dock) { this._header.addDock(dock); }\r\n  public updateUi(): void { this._header.hideCloseWidget(!this.isCloseable); }\r\n\r\n  public onFocus(): void {\r\n    this.container.classList.add(\"window-focused\");\r\n    this._header.element.classList.add(\"window-header-focused\");\r\n  }\r\n\r\n  public onLoseFocus(): void {\r\n    this.container.classList.remove(\"window-focused\");\r\n    this._header.element.classList.remove(\"window-header-focused\");\r\n  }\r\n\r\n  public onClosing(): void { }\r\n  public onClosed(): void { }\r\n  public get isCloseable(): boolean { return true; }\r\n  public get isResizable(): boolean { return true; }\r\n\r\n  public resizeContent(w: number, h: number): void {\r\n    this._header.resizeContent(w, h);\r\n  }\r\n\r\n  public setHeaderVisible(visible: boolean): void {\r\n    this._header.element.style.display = visible ? \"block\" : \"none\";\r\n  }\r\n}\r\n\r\nexport interface NamedWindowProps extends WindowProps {\r\n  id: string;\r\n}\r\n\r\nexport class NamedWindow extends Window {\r\n  private readonly _windowId: string;\r\n\r\n  public constructor(surface: Surface, props: NamedWindowProps) {\r\n    super(surface, props);\r\n    this._windowId = props.id;\r\n    if (undefined === props.title)\r\n      this._header.setTitle(this.windowId);\r\n  }\r\n\r\n  public get windowId() { return this._windowId; }\r\n}\r\n"
        ],
        "mappings": "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",
        "names": [
          "Dock"
        ]
      }
    }
  ]
}
