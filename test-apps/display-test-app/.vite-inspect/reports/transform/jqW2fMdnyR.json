{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/orbitgt/lib/esm/spatial/ecrs/CRS.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module OrbitGT\n */\nimport { AList } from \"../../system/collection/AList\";\nimport { ASystem } from \"../../system/runtime/ASystem\";\nimport { Strings } from \"../../system/runtime/Strings\";\nimport { Coordinate } from \"../geom/Coordinate\";\nimport { CoordinateSystem } from \"./CoordinateSystem\";\nimport { Datum } from \"./Datum\";\nimport { Operation } from \"./Operation\";\nimport { Registry } from \"./Registry\";\nimport { Unit } from \"./Unit\";\n/**\n * Class CRS defines the parameters of a coordinate reference system.\n * NOTE: geographic (lon-lat) CRSs have their coordinates in degrees (0..360) instead of radians (0..2PI).\n * NOTE: geocentric (ECEF) CRSs have their coordinates in meters.\n *\n * Based on the following document:\n *\n * Coordinate Conversions and Transformations including Formulas\n * Guidance Note Number 7, part 2\n * Revised May 2005\n * Available at: http://www.epsg.org/\n *\n * @version 1.0 July 2005\n */\n/** @internal */\nclass CRS {\n    /**\n     * Create a new CRS.\n     * @param code the code.\n     * @param name the name.\n     * @param area the area of use.\n     * @param type the type.\n     * @param csCode the coordinate-system code.\n     * @param datum the datum.\n     * @param baseCRS the base geographic CRS.\n     * @param projection the projection (from the base CRS to this CRS).\n     * @param transformationsToWGS the transformations from the base geographic CRS to the WGS 84 datum (of CRS 4326).\n     */\n    constructor(code, name, area, type, csCode, datum, baseCRS, projection, transformationsToWGS) {\n        /* Store the parameters */\n        this._code = code;\n        this._name = name;\n        this._area = area;\n        this._type = type;\n        this._csCode = csCode;\n        this._axes = null;\n        this._coordinateSystem = null;\n        this._datum = datum;\n        this._baseCRS = baseCRS;\n        this._projection = projection;\n        this._transformationsToWGS = transformationsToWGS;\n        /* Get the default transform */\n        this._transformationToWGS = Operation.getLatestTransformation(transformationsToWGS);\n        /* Clear */\n        this._horizontalComponent = null;\n        this._verticalComponent = null;\n        this._verticalModel = null;\n        this._textForm = null;\n        this._accessTime = 0.0;\n    }\n    /**\n     * Create a compound CRS.\n     * @param code the code.\n     * @param name the name.\n     * @param area the area of use.\n     * @param horizontalCRS the horizontal CRS.\n     * @param verticalCRS the vertical CRS.\n     * @return the compound CRS.\n     */\n    static createCompound(code, name, area, horizontalCRS, verticalCRS) {\n        /* Check the parameters */\n        ASystem.assertNot(horizontalCRS == null, \"No horizontal CRS\");\n        ASystem.assertNot(verticalCRS == null, \"No vertical CRS\");\n        ASystem.assertNot(horizontalCRS.isVertical(), \"CRS is not horizontal: \" + horizontalCRS);\n        ASystem.assertNot(verticalCRS.isVertical() == false, \"CRS is not vertical: \" + verticalCRS);\n        /* Make the CRS */\n        let crs = new CRS(code, name, area, CRS.COMPOUND, 0 /*csCode*/, null /*datum*/, null /*baseCRS*/, null /*projection*/, null /*transformationsToWGS*/);\n        crs._horizontalComponent = horizontalCRS;\n        crs._verticalComponent = verticalCRS;\n        /* Return the CRS */\n        return crs;\n    }\n    /**\n     * Get the code.\n     * @return the code.\n     */\n    getCode() {\n        return this._code;\n    }\n    /**\n     * Get the string code.\n     * @return the string code.\n     */\n    getStringCode() {\n        return \"\" + this._code;\n    }\n    /**\n     * Check if a code matches the CRS code.\n     * @param code the code.\n     * @return true if the code matches.\n     */\n    hasStringCode(code) {\n        return Strings.equals(code, this.getStringCode());\n    }\n    /**\n     * Get the name.\n     * @return the name.\n     */\n    getName() {\n        return this._name;\n    }\n    /**\n     * Get the area of use.\n     * @return the area.\n     */\n    getArea() {\n        return this._area;\n    }\n    /**\n     * Get the type.\n     * @return the type.\n     */\n    getType() {\n        return this._type;\n    }\n    /**\n     * Get the type label.\n     * @return the type label.\n     */\n    getTypeLabel() {\n        return CRS.labelCRSType(this._type);\n    }\n    /**\n     * Is this a geocentric CRS?\n     * @return true for a geocentric CRS.\n     */\n    isGeoCentric() {\n        return (this._type == CRS.GEOCENTRIC);\n    }\n    /**\n     * Is this a geographic CRS?\n     * @return true for a projected CRS.\n     */\n    isGeoGraphic() {\n        return (this._type == CRS.GEOGRAPHIC_2D || this._type == CRS.GEOGRAPHIC_3D);\n    }\n    /**\n     * Is this a geographic 2D CRS?\n     * @return true for a projected 2D CRS.\n     */\n    isGeoGraphic2D() {\n        return (this._type == CRS.GEOGRAPHIC_2D);\n    }\n    /**\n     * Is this a geographic 3D CRS?\n     * @return true for a projected 3D CRS.\n     */\n    isGeoGraphic3D() {\n        return (this._type == CRS.GEOGRAPHIC_3D);\n    }\n    /**\n     * Is this a projected CRS?\n     * @return true for a projected CRS.\n     */\n    isProjectedType() {\n        return (this._type == CRS.PROJECTED);\n    }\n    /**\n     * Is this a projected CRS?\n     * @return true for a projected CRS.\n     */\n    isProjected() {\n        if (this._type == CRS.COMPOUND)\n            return this._horizontalComponent.isProjected();\n        return (this._type == CRS.PROJECTED);\n    }\n    /**\n     * Is this a vertical CRS?\n     * @return true for a vertical CRS.\n     */\n    isVertical() {\n        return (this._type == CRS.VERTICAL);\n    }\n    /**\n     * Is this a compound CRS?\n     * @return true for a compound CRS.\n     */\n    isCompound() {\n        return (this._type == CRS.COMPOUND);\n    }\n    /**\n     * Get the coordinate-system code.\n     * @return the coordinate-system code.\n     */\n    getCoordinateSystemCode() {\n        return this._csCode;\n    }\n    /**\n     * Get the coordinate system.\n     * @return the coordinate system (can be null if standard).\n     */\n    getCoordinateSystem() {\n        return this._coordinateSystem;\n    }\n    /**\n     * Get the datum.\n     * @return the datum.\n     */\n    getDatum() {\n        if (this._datum != null)\n            return this._datum;\n        if (this._baseCRS != null)\n            return this._baseCRS.getDatum();\n        return null;\n    }\n    /**\n     * Get the code of the datum.\n     * @return the code of the datum (0 if there is no datum).\n     */\n    getDatumCode() {\n        let datum = this.getDatum();\n        return (datum == null) ? 0 : datum.getCode();\n    }\n    /**\n     * Set the datum.\n     * @param datum the new datum (if null check the base CRS).\n     */\n    setDatum(datum) {\n        this._datum = datum;\n    }\n    /**\n     * Get the ellipsoid.\n     * @return the ellipsoid.\n     */\n    getEllipsoid() {\n        return this.getDatum().getEllipsoid();\n    }\n    /**\n     * Get the base geographic CRS.\n     * @return the base geographic CRS.\n     */\n    getBaseCRS() {\n        return this._baseCRS;\n    }\n    /**\n     * Set the base geographic CRS.\n     * @param baseCRS the new base geographic CRS.\n     */\n    setBaseCRS(baseCRS) {\n        this._baseCRS = baseCRS;\n    }\n    /**\n     * Get the coordinate axis of the CRS.\n     * @return the coordinate axis of the CRS.\n     */\n    getAxes() {\n        return this._axes;\n    }\n    /**\n     * Set the coordinate axis of the CRS.\n     * @param axis the coordinate axis of the CRS.\n     */\n    setAxes(axes) {\n        /* Store the parameters */\n        this._axes = axes;\n        /* Update the coordinate system */\n        this._coordinateSystem = CoordinateSystem.create(this._type, this._csCode, this._axes);\n    }\n    /**\n     * Get the unit code of the first coordinate axis of the CRS.\n     * @return the unit code (defaults to METER).\n     */\n    getFirstAxisUnitCode() {\n        if (this._type == CRS.COMPOUND)\n            return this._horizontalComponent.getFirstAxisUnitCode();\n        if (this._axes == null)\n            return Unit.METER;\n        if (this._axes.size() == 0)\n            return Unit.METER;\n        return this._axes.get(0).getUnitCode();\n    }\n    /**\n     * Get the projection (from the base CRS to this CRS).\n     * @return the projection.\n     */\n    getProjection() {\n        return this._projection;\n    }\n    /**\n     * Set the projection (from the base CRS to this CRS).\n     * @param projection the projection.\n     */\n    setProjection(projection) {\n        this._projection = projection;\n    }\n    /**\n     * Get the projection method (from the base CRS to this CRS).\n     * @return the projection method.\n     */\n    getProjectionMethod() {\n        if (this._projection == null)\n            return null;\n        return this._projection.getMethod();\n    }\n    /**\n     * Get the horizontal component of a compound CRS.\n     * @return the horizontal component of a compound CRS.\n     */\n    getHorizontalComponent() {\n        /* Check the type */\n        ASystem.assertNot(this._type != CRS.COMPOUND, \"CRS \" + this._code + \" is not compound\");\n        /* Return the component */\n        return this._horizontalComponent;\n    }\n    /**\n     * Check if there is a vertical component (only for type COMPOUND).\n     * @return true if there is a vertical component.\n     */\n    hasVerticalComponent() {\n        /* Check the type */\n        if (this._type != CRS.COMPOUND)\n            return false;\n        /* Check the component */\n        return (this._verticalComponent != null);\n    }\n    /**\n     * Get the vertical component of a compound CRS.\n     * @return the vertical component of a compound CRS.\n     */\n    getVerticalComponent() {\n        /* Check the type */\n        ASystem.assertNot(this._type != CRS.COMPOUND, \"CRS \" + this._code + \" is not compound\");\n        /* Return the component */\n        return this._verticalComponent;\n    }\n    /**\n     * Get the vertical model (only for type VERTICAL).\n     * @return the vertical model.\n     */\n    getVerticalModel() {\n        return this._verticalModel;\n    }\n    /**\n     * Set the vertical model (only for type VERTICAL).\n     * @param verticalModel the vertical model.\n     */\n    setVerticalModel(verticalModel) {\n        this._verticalModel = verticalModel;\n    }\n    /**\n     * Peek at the transformations from the base geographic CRS to the WGS 84 datum (of CRS 4326).\n     * @return the transformations.\n     */\n    peekTransformationsToWGS() {\n        return this._transformationsToWGS;\n    }\n    /**\n     * Get the transformations from the base geographic CRS to the WGS 84 datum (of CRS 4326).\n     * @return the transformations.\n     */\n    getTransformationsToWGS() {\n        if ((this._transformationsToWGS != null) && (this._transformationsToWGS.size() > 0))\n            return this._transformationsToWGS;\n        if (this._baseCRS != null)\n            return this._baseCRS.getTransformationsToWGS();\n        return new AList();\n    }\n    /**\n     * Set the transformations from the base geographic CRS to the WGS 84 datum (of CRS 4326).\n     * @param transformations the transformations.\n     */\n    setTransformationsToWGS(transformations) {\n        this._transformationsToWGS = transformations;\n    }\n    /**\n     * Get the default transformation from the base geographic CRS to the WGS 84 datum (of CRS 4326).\n     * @return a transformation (null if not available).\n     */\n    getTransformationToWGS() {\n        if (this._transformationToWGS != null)\n            return this._transformationToWGS;\n        if (this._baseCRS != null)\n            return this._baseCRS.getTransformationToWGS();\n        return null;\n    }\n    /**\n     * Set the default transformation from the base geographic CRS to the WGS 84 datum (of CRS 4326).\n     * @param transformation a transformation (null if not available).\n     */\n    setTransformationToWGS(transformation) {\n        this._transformationToWGS = transformation;\n    }\n    /**\n     * Convert to a geocentric coordinate.\n     * @param local the coordinate in this CRS.\n     * @return the geocentric coordinate.\n     */\n    toGeoCentric(local) {\n        /* Projection ? */\n        if (this._type == CRS.PROJECTED) {\n            /* We need a geographic base CRS */\n            ASystem.assertNot(this._baseCRS.isGeoGraphic() == false, \"Projected CRS '\" + this._code + \"' needs a geographic base CRS '\" + this._baseCRS.getCode() + \"', not '\" + this._baseCRS.getTypeLabel() + \"'\");\n            /* Convert to standard units */\n            let projected = local.copy();\n            if (this._coordinateSystem != null)\n                this._coordinateSystem.localToStandard(projected, projected);\n            /* Inverse the projection to get geographic (lon,lat) coordinates (radians) */\n            let geographic = new Coordinate(0.0, 0.0, 0.0);\n            this._projection.reverse(geographic, projected);\n            /* The geographic coordinates are in degrees */\n            geographic.setX(geographic.getX() / Math.PI * 180.0);\n            geographic.setY(geographic.getY() / Math.PI * 180.0);\n            /* Let the base CRS calculate the geocentric coordinates */\n            return this._baseCRS.toGeoCentric(geographic);\n        }\n        /* Geocentric ? */\n        if (this._type == CRS.GEOCENTRIC) {\n            /* Already geocentric */\n            return local.copy();\n        }\n        /* Geographic ? */\n        if (this._type == CRS.GEOGRAPHIC_2D || this._type == CRS.GEOGRAPHIC_3D) {\n            /* All geographic coordinates are in degrees */\n            let geographic = local.copy();\n            geographic.setX(geographic.getX() / 180.0 * Math.PI);\n            geographic.setY(geographic.getY() / 180.0 * Math.PI);\n            /* Convert from geographic (radians) to geocentric */\n            let geocentric = new Coordinate(0.0, 0.0, 0.0);\n            this._datum.getEllipsoid().toGeoCentric(geographic, geocentric);\n            /* Return the geocentric coordinates */\n            return geocentric;\n        }\n        /* We cannot transform */\n        ASystem.assertNot(true, \"No geocentric transform for \" + this);\n        return null;\n    }\n    /**\n     * Convert from a geocentric coordinate.\n     * @param geocentric the geocentric coordinate.\n     * @return the coordinate in this CRS.\n     */\n    fromGeoCentric(geocentric) {\n        /* Projection ? */\n        if (this._type == CRS.PROJECTED) {\n            /* We need a geographic base CRS */\n            ASystem.assertNot(this._baseCRS.isGeoGraphic() == false, \"Projected CRS '\" + this._code + \"' needs a geographic base CRS '\" + this._baseCRS.getCode() + \"', not '\" + this._baseCRS.getTypeLabel() + \"'\");\n            /* Get the geographic coordinate */\n            let geographic = this._baseCRS.fromGeoCentric(geocentric);\n            /* The geographic coordinates are in degrees */\n            geographic.setX(geographic.getX() / 180.0 * Math.PI);\n            geographic.setY(geographic.getY() / 180.0 * Math.PI);\n            /* Make the projection */\n            let projected = new Coordinate(0.0, 0.0, 0.0);\n            this._projection.forward(geographic, projected);\n            /* Convert to local units */\n            if (this._coordinateSystem != null)\n                this._coordinateSystem.standardToLocal(projected, projected);\n            /* Return the projected coordinate */\n            return projected;\n        }\n        /* Geocentric ? */\n        if (this._type == CRS.GEOCENTRIC) {\n            /* Already geocentric */\n            return geocentric.copy();\n        }\n        /* Geographic ? */\n        if (this._type == CRS.GEOGRAPHIC_2D || this._type == CRS.GEOGRAPHIC_3D) {\n            /* Convert from geocentric to geographic (radians) */\n            let geographic = new Coordinate(0.0, 0.0, 0.0);\n            this._datum.getEllipsoid().toGeoGraphic(geocentric, geographic);\n            /* All geographic coordinates need to be in degrees */\n            geographic.setX(geographic.getX() / Math.PI * 180.0);\n            geographic.setY(geographic.getY() / Math.PI * 180.0);\n            /* Return the geographic coordinate */\n            return geographic;\n        }\n        /* We cannot transform */\n        ASystem.assertNot(true, \"No geocentric transform for \" + this);\n        return null;\n    }\n    /**\n     * Check if this CRS is a projection of another CRS.\n     * @param geographic the geographic CRS to check.\n     * @return true if this is a projection of the geographic CRS.\n     */\n    isProjectionOf(geographic) {\n        /* This has to be a projection */\n        if (this._type != CRS.PROJECTED)\n            return false;\n        if (this._projection == null)\n            return false;\n        if (this._baseCRS == null)\n            return false;\n        /* We need a geographic system */\n        if (geographic._type != CRS.GEOGRAPHIC_2D && geographic._type != CRS.GEOGRAPHIC_3D)\n            return false;\n        /* Is this our base CRS? */\n        return (this._baseCRS.isCompatible(geographic));\n    }\n    /**\n     * Convert from a geographic coordinate to a projected coordinate.\n     * @param geographic the source geographic coordinate (in degrees).\n     * @param projected the target projected coordinate (use null to create a new coordinate).\n     * @return the projected coordinate.\n     */\n    toProjected(geographic, projected) {\n        /* Create target? */\n        if (projected == null)\n            projected = new Coordinate(0.0, 0.0, 0.0);\n        /* The geographic coordinates are kept in degrees */\n        projected.setX(geographic.getX() / 180.0 * Math.PI);\n        projected.setY(geographic.getY() / 180.0 * Math.PI);\n        projected.setZ(geographic.getZ());\n        /* Make the projection */\n        this._projection.forward(projected, projected);\n        /* Convert to local units */\n        if (this._coordinateSystem != null)\n            this._coordinateSystem.standardToLocal(projected, projected);\n        /* Return the result */\n        return projected;\n    }\n    /**\n     * Convert from a projected coordinate to a geographic coordinate.\n     * @param projected the source projected coordinate.\n     * @param geographic the target geographic coordinate (in degrees) (use null to create a new coordinate).\n     * @return the geographic coordinate.\n     */\n    fromProjected(projected, geographic) {\n        /* Create target? */\n        if (geographic == null)\n            geographic = new Coordinate(0.0, 0.0, 0.0);\n        /* Convert to standard units */\n        let projected2 = projected.copy();\n        if (this._coordinateSystem != null)\n            this._coordinateSystem.localToStandard(projected2, projected2);\n        /* Inverse the projection to get the geographic (lon,lat) coordinates (radians) */\n        this._projection.reverse(geographic, projected2);\n        /* The geographic coordinates are kept in degrees */\n        geographic.setX(geographic.getX() / Math.PI * 180.0);\n        geographic.setY(geographic.getY() / Math.PI * 180.0);\n        /* Return the result */\n        return geographic;\n    }\n    /**\n     * Get the WGS 84 2D geocentric reference system.\n     * @return the WGS 84 2D geocentric reference system.\n     */\n    static getWGS84_GeoCentric() {\n        if (CRS._CACHE_WGS84_GEOCENTRIC == null)\n            CRS._CACHE_WGS84_GEOCENTRIC = Registry.getCRS2(CRS.CRS_WGS84_GEOCENTRIC);\n        return CRS._CACHE_WGS84_GEOCENTRIC;\n    }\n    /**\n     * Get the WGS 84 2D geographic reference system.\n     * @return the WGS 84 2D geographic reference system.\n     */\n    static getWGS84_3D() {\n        if (CRS._CACHE_WGS84_3D == null)\n            CRS._CACHE_WGS84_3D = Registry.getCRS2(CRS.CRS_WGS84_3D);\n        return CRS._CACHE_WGS84_3D;\n    }\n    /**\n     * Get the WGS 84 2D coordinate reference system.\n     * @return the WGS 84 2D coordinate reference system.\n     */\n    static getWGS84_2D() {\n        if (CRS._CACHE_WGS84_2D == null)\n            CRS._CACHE_WGS84_2D = Registry.getCRS2(CRS.CRS_WGS84_2D);\n        return CRS._CACHE_WGS84_2D;\n    }\n    /**\n     * Is a conversion to and from the WGS 84 coordinate system possible?\n     * @return true if possible.\n     */\n    isWGSCompatible() {\n        /* Already in WGS ? */\n        if (this.getDatum().getCode() == CRS.WGS84_DATUM_CODE)\n            return true;\n        /* Get the transformation from the local datum to the WGS datum */\n        let localToWGS = this.getTransformationToWGS();\n        if (localToWGS == null)\n            return false;\n        /* Compatible */\n        return true;\n    }\n    /**\n     * Convert a coordinate to the WGS 84 (geographic 2D) coordinate system.\n     * @param source the coordinates in this CRS.\n     * @param wgsTransformationIndex the index of the WGS transformation to use (negative for the default transformation).\n     * @return the WGS 84 coordinate, x is longitude(-180..+180), y is latitude(-90..+90) and z is height (the z height is the same as the local height).\n     */\n    toWGSi(source, wgsTransformationIndex) {\n        /* Already in the WGS datum ? */\n        if (this.getDatum().getCode() == CRS.WGS84_DATUM_CODE) {\n            /* Geocentric ? */\n            if (this._type == CRS.GEOCENTRIC) {\n                /* Convert from geocentric to geographic coordinates */\n                let ageographic = new Coordinate(0.0, 0.0, 0.0);\n                this._datum.getEllipsoid().toGeoGraphic(source /*geocentric*/, ageographic);\n                /* The WGS coordinates need to be in degrees */\n                ageographic.setX(ageographic.getX() / Math.PI * 180.0);\n                ageographic.setY(ageographic.getY() / Math.PI * 180.0);\n                /* Return the WGS coordinates */\n                return ageographic;\n            }\n            /* Projected ? */\n            if (this._projection != null) {\n                /* Convert to standard units */\n                let projected = source.copy();\n                if (this._coordinateSystem != null)\n                    this._coordinateSystem.localToStandard(projected, projected);\n                /* Inverse the projection to go from projected to geographic (lon,lat) coordinates */\n                let ageographic = new Coordinate(0.0, 0.0, 0.0);\n                this._projection.reverse(ageographic, projected);\n                /* The WGS coordinates need to be in degrees */\n                ageographic.setX(ageographic.getX() / Math.PI * 180.0);\n                ageographic.setY(ageographic.getY() / Math.PI * 180.0);\n                /* Return the WGS coordinates */\n                return ageographic;\n            }\n            /* Geographic */\n            return new Coordinate(source.getX(), source.getY(), source.getZ());\n        }\n        /* Get the transformation from the local datum to the WGS datum */\n        let localToWGS = (wgsTransformationIndex < 0) ? this.getTransformationToWGS() : this.getTransformationsToWGS().get(wgsTransformationIndex);\n        //        if (localToWGS==null)\n        //        {\n        //            /* We cannot transform */\n        //            ASystem.assert(false,\"No datum transformation from \"+this+\" to WGS\");\n        //        }\n        /* Does the transform work on the projected coordinates (like the OSTN02 grid correction)? */\n        let geocentric;\n        if ((localToWGS != null) && localToWGS.getSourceCRS().isProjected()) {\n            /* Start with the projected coordinate */\n            geocentric = new Coordinate(source.getX(), source.getY(), source.getZ());\n        }\n        else {\n            /* Calculate the geocentric coordinate */\n            geocentric = this.toGeoCentric(new Coordinate(source.getX(), source.getY(), source.getZ()));\n        }\n        /* Apply the transform to the WGS datum */\n        if (localToWGS != null)\n            localToWGS.forward(geocentric, geocentric);\n        /* Get the geographic coordinate */\n        let geographic = CRS.getWGS84_2D().fromGeoCentric(geocentric);\n        /* Does the transform work on the projected coordinates (like the OSTN02 grid correction)? */\n        if ((localToWGS != null) && localToWGS.getSourceCRS().isProjected()) {\n            /* Assume we have the right Z */\n        }\n        else {\n            /* Restore the original Z (is this allowed??) <ISSUE> */\n            geographic.setZ(source.getZ());\n        }\n        /* Return the WGS geographic coordinates */\n        return geographic;\n    }\n    /**\n     * Convert a coordinate to the WGS 84 (geographic 2D) coordinate system.\n     * @param source the coordinates in this CRS.\n     * @return the WGS 84 coordinate, x is longitude(-180..+180), y is latitude(-90..+90) and z is height (the z height is the same as the local height).\n     */\n    toWGS(source) {\n        return this.toWGSi(source, -1);\n    }\n    /**\n     * Convert from the WGS 84 (geographic 2D) coordinate system to this coordinate system.\n     * @param source the coordinates in the WGS 84 coordinate system, where x is longitude(-180..+180), y is latitude(-90..+90) and z is height.\n     * @param wgsTransformationIndex the index of the WGS transformation to use (negative for the default transformation).\n     * @return the coordinates in this CRS (the z height is the same as the WGS height).\n     */\n    fromWGSi(source, wgsTransformationIndex) {\n        /* Already in the WGS datum ? */\n        if (this.getDatum().getCode() == CRS.WGS84_DATUM_CODE) {\n            /* Geocentric ? */\n            if (this._type == CRS.GEOCENTRIC) {\n                /* Convert to radians */\n                let lon = source.getX() / 180.0 * Math.PI;\n                let lat = source.getY() / 180.0 * Math.PI;\n                let geographic = new Coordinate(lon, lat, source.getZ());\n                /* Convert from geographic to geocentric coordinates */\n                let geocentric = new Coordinate(0.0, 0.0, 0.0);\n                this._datum.getEllipsoid().toGeoCentric(geographic, geocentric);\n                /* Return the geocentric coordinates */\n                return geocentric;\n            }\n            /* Projected ? */\n            if (this._projection != null) {\n                /* Convert to radians */\n                let lon = source.getX() / 180.0 * Math.PI;\n                let lat = source.getY() / 180.0 * Math.PI;\n                let geographic = new Coordinate(lon, lat, source.getZ());\n                /* Use the projection to go from geographic (lon,lat) coordinates to projected coordinates */\n                let projected = new Coordinate(0.0, 0.0, 0.0);\n                this._projection.forward(geographic, projected);\n                /* Convert to local units */\n                if (this._coordinateSystem != null)\n                    this._coordinateSystem.standardToLocal(projected, projected);\n                /* Return the projected coordinates */\n                return projected;\n            }\n            /* Geographic */\n            return new Coordinate(source.getX(), source.getY(), source.getZ());\n        }\n        /* Get the transformation from the local datum to the WGS datum */\n        let localToWGS = (wgsTransformationIndex < 0) ? this.getTransformationToWGS() : this.getTransformationsToWGS().get(wgsTransformationIndex);\n        //        if (localToWGS==null)\n        //        {\n        //            /* We cannot transform */\n        //            ASystem.assert(false,\"No datum transformation from \"+this+\" to WGS\");\n        //        }\n        /* Transform from the WGS datum to the local datum */\n        let localGeocentric = CRS.getWGS84_2D().toGeoCentric(source /*geographic*/);\n        if (localToWGS != null)\n            localToWGS.reverse(localGeocentric, localGeocentric);\n        /* Does the transform work on the projected coordinates (like the OSTN02 grid correction)? */\n        if ((localToWGS != null) && localToWGS.getSourceCRS().isProjected()) {\n            /* We already have the result */\n            return localGeocentric;\n        }\n        else {\n            /* Convert from geocentric to local coordinates */\n            let local = this.fromGeoCentric(localGeocentric);\n            /* Restore the original Z (is this allowed??) <ISSUE> */\n            local.setZ(source.getZ());\n            /* Return the local coordinates */\n            return local;\n        }\n    }\n    /**\n     * Convert from the WGS 84 (geographic 2D) coordinate system to this coordinate system.\n     * @param source the coordinates in the WGS 84 coordinate system, where x is longitude(-180..+180), y is latitude(-90..+90) and z is height.\n     * @return the coordinates in this CRS (the z height is the same as the WGS height).\n     */\n    fromWGS(source) {\n        return this.fromWGSi(source, -1);\n    }\n    /**\n     * Check if another CRS is compatible with this one.\n     * @param other the other CRS.\n     * @return true if compatible.\n     */\n    isCompatible(other) {\n        /* Check the base parameters */\n        if (other._code == this._code)\n            return true;\n        if (other._type != this._type)\n            return false;\n        if (other._csCode != this._csCode)\n            return false;\n        /* Geographic? */\n        if (this.isGeoCentric() || this.isGeoGraphic()) {\n            /* Same datum? */\n            if (Datum.areCompatible(other.getDatum(), this.getDatum()) == false)\n                return false;\n            /* We need the same transformation to WGS (check CRS 2039 for example: wgs compatible datum, but with geocentric translation to wgs) */\n            if (Operation.isCompatibleOperation(other.getTransformationToWGS(), this.getTransformationToWGS()) == false)\n                return false;\n            return true;\n        }\n        /* Projected? */\n        else if (this.isProjected()) {\n            /* Same projection? */\n            if (Operation.isCompatibleOperation(other._projection, this._projection) == false)\n                return false;\n            /* Has base CRS? */\n            if (other._baseCRS == null || this._baseCRS == null)\n                return false;\n            /* Same base? */\n            return (other._baseCRS.isCompatible(this._baseCRS));\n        }\n        /* Vertical? */\n        else if (this.isVertical()) {\n            /* Same datum? */\n            if (Datum.areCompatible(other.getDatum(), this.getDatum()) == false)\n                return false;\n            return true;\n        }\n        /* Compound? */\n        else if (this.isCompound()) {\n            /* Same components? */\n            if (CRS.areCompatible(other._horizontalComponent, this._horizontalComponent) == false)\n                return false;\n            if (CRS.areCompatible(other._verticalComponent, this._verticalComponent) == false)\n                return false;\n            return true;\n        }\n        /* Other */\n        else {\n            return false;\n        }\n    }\n    /**\n     * Check if two CRSs are compatible.\n     * @param crs1 the first CRS.\n     * @param crs2 the second CRS.\n     * @return true if compatible.\n     */\n    static areCompatible(crs1, crs2) {\n        if (crs1 == null)\n            return (crs2 == null);\n        if (crs2 == null)\n            return false;\n        return crs1.isCompatible(crs2);\n    }\n    /**\n     * Get the text form of the CRS.\n     * @return the text form of the CRS.\n     */\n    getTextForm() {\n        return this._textForm;\n    }\n    /**\n     * Set the text form of the CRS.\n     * @param textForm the text form of the CRS.\n     */\n    setTextForm(textForm) {\n        this._textForm = textForm;\n    }\n    /**\n     * Get the access time.\n     * @return the access time.\n     */\n    getAccessTime() {\n        return this._accessTime;\n    }\n    /**\n     * Set the access time.\n     * @param time the access time.\n     */\n    setAccessTime(time) {\n        this._accessTime = time;\n    }\n    /**\n     * The standard toString method.\n     * @see Object#toString\n     */\n    toString() {\n        return \"[CRS:code=\" + this._code + \",name='\" + this._name + \"',area=\" + this._area + \",type='\" + CRS.labelCRSType(this._type) + \"',datum=\" + this._datum + \",baseCRS=\" + this._baseCRS + \",wgs-transform=\" + (this._transformationToWGS != null) + \"]\";\n    }\n    /**\n     * Get the type of a CRS.\n     * @param crsKind the type of CRS.\n     * @return a parsed type.\n     */\n    static parseCRSType(crsKind) {\n        if (Strings.equalsIgnoreCase(crsKind, \"compound\"))\n            return CRS.COMPOUND;\n        if (Strings.equalsIgnoreCase(crsKind, \"engineering\"))\n            return CRS.ENGINEERING;\n        if (Strings.equalsIgnoreCase(crsKind, \"geocentric\"))\n            return CRS.GEOCENTRIC;\n        if (Strings.equalsIgnoreCase(crsKind, \"geographic 2D\"))\n            return CRS.GEOGRAPHIC_2D;\n        if (Strings.equalsIgnoreCase(crsKind, \"geographic 3D\"))\n            return CRS.GEOGRAPHIC_3D;\n        if (Strings.equalsIgnoreCase(crsKind, \"projected\"))\n            return CRS.PROJECTED;\n        if (Strings.equalsIgnoreCase(crsKind, \"vertical\"))\n            return CRS.VERTICAL;\n        ASystem.assert0(false, \"CRS kind '\" + crsKind + \"' not found\");\n        return 0;\n    }\n    /**\n     * Get the label of a type of a CRS.\n     * @param crsType the type of CRS.\n     * @return a label.\n     */\n    static labelCRSType(crsType) {\n        if (crsType == CRS.COMPOUND)\n            return \"compound\";\n        if (crsType == CRS.ENGINEERING)\n            return \"engineering\";\n        if (crsType == CRS.GEOCENTRIC)\n            return \"geocentric\";\n        if (crsType == CRS.GEOGRAPHIC_2D)\n            return \"geographic 2D\";\n        if (crsType == CRS.GEOGRAPHIC_3D)\n            return \"geographic 3D\";\n        if (crsType == CRS.PROJECTED)\n            return \"projected\";\n        if (crsType == CRS.VERTICAL)\n            return \"vertical\";\n        ASystem.assert0(false, \"CRS type '\" + crsType + \"' not found\");\n        return null;\n    }\n}\n/** The type of a compound CRS */\nCRS.COMPOUND = 1;\n/** The type of a engineering CRS */\nCRS.ENGINEERING = 2;\n/** The type of a geocentric CRS */\nCRS.GEOCENTRIC = 3;\n/** The type of a geographic-2D CRS */\nCRS.GEOGRAPHIC_2D = 4;\n/** The type of a geographic-3D CRS */\nCRS.GEOGRAPHIC_3D = 5;\n/** The type of a projected CRS */\nCRS.PROJECTED = 6;\n/** The type of a vertical CRS */\nCRS.VERTICAL = 7;\n/** The identification code of the WGS 84 geocentric reference system */\nCRS.WGS84_GEOCENTRIC_CRS_CODE = 4978;\n/** The identification code of the WGS 84 3D coordinate reference system */\nCRS.WGS84_3D_CRS_CODE = 4979;\n/** The identification code of the WGS 84 2D coordinate reference system */\nCRS.WGS84_2D_CRS_CODE = 4326;\n/** The identification code of the WGS 84 datum */\nCRS.WGS84_DATUM_CODE = 6326;\n/** The identification code of the WGS 84 geocentric coordinate reference system */\nCRS.CRS_WGS84_GEOCENTRIC = \"4978\";\n/** The identification code of the WGS 84 geographic coordinate reference system */\nCRS.CRS_WGS84_3D = \"4979\";\n/** The identification code of the WGS 84 2D coordinate reference system */\nCRS.CRS_WGS84_2D = \"4326\";\n/** The cache of the WGS 84 geocentric coordinate reference system (4978) */\nCRS._CACHE_WGS84_GEOCENTRIC = null;\n/** The cache of the WGS 84 geographic coordinate reference system (4979) */\nCRS._CACHE_WGS84_3D = null;\n/** The cache of the WGS 84 2D coordinate reference system (4326) */\nCRS._CACHE_WGS84_2D = null;\nexport { CRS };\n//# sourceMappingURL=CRS.js.map",
      "start": 1693508127212,
      "end": 1693508127307,
      "sourcemaps": null
    }
  ]
}
