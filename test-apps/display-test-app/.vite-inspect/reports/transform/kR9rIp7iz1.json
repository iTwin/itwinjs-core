{
  "resolvedId": "D:/hub2023A/itwinjs-core/editor/frontend/lib/esm/ProjectLocation/ProjectExtentsDecoration.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Editing\n */\nimport { BeDuration, BeEvent, BentleyError } from \"@itwin/core-bentley\";\nimport { ColorDef, EcefLocation } from \"@itwin/core-common\";\nimport { BeButton, CoreTools, EditManipulator, EventHandled, GraphicType, IModelApp, MessageBoxIconType, MessageBoxType, MessageBoxValue, NotifyMessageDetails, OutputMessagePriority, QuantityType, Tool, ViewClipControlArrow, ViewClipDecorationProvider, ViewClipShapeModifyTool, ViewClipTool, } from \"@itwin/core-frontend\";\nimport { Angle, Arc3d, AxisIndex, AxisOrder, Constant, Matrix3d, Point3d, PolygonOps, Range1d, Range3d, Ray3d, Transform, Vector3d, } from \"@itwin/core-geometry\";\nimport { editorBuiltInCmdIds } from \"@itwin/editor-common\";\nimport { EditTools } from \"../EditTool\";\nimport { basicManipulationIpc } from \"../EditToolIpc\";\nimport { ProjectGeolocationNorthTool, ProjectGeolocationPointTool } from \"./ProjectGeolocation\";\nfunction translateMessage(key) {\n    return EditTools.translate(`ProjectLocation:Message.${key}`);\n}\nfunction translateMessageBold(key) {\n    return `<b>${translateMessage(key)}:</b> `;\n}\nfunction translateCoreMeasureBold(key) {\n    return `<b>${CoreTools.translate(`Measure.Labels.${key}`)}:</b> `;\n}\nfunction clearViewClip(vp) {\n    if (!ViewClipTool.doClipClear(vp))\n        return false;\n    ViewClipDecorationProvider.create().onClearClip(vp); // Send clear event...\n    ViewClipDecorationProvider.clear();\n    return true;\n}\nfunction clipToProjectExtents(vp) {\n    clearViewClip(vp); // Clear any existing view clip and send clear event...\n    ViewClipTool.enableClipVolume(vp);\n    return ViewClipTool.doClipToRange(vp, vp.iModel.projectExtents, Transform.createIdentity());\n}\nfunction enableBackgroundMap(viewport, onOff) {\n    if (onOff === viewport.viewFlags.backgroundMap)\n        return false;\n    viewport.viewFlags = viewport.viewFlags.with(\"backgroundMap\", onOff);\n    return true;\n}\nfunction updateMapDisplay(vp, turnOnMap) {\n    if (!turnOnMap || !enableBackgroundMap(vp, true))\n        vp.invalidateRenderPlan();\n}\nclass ProjectExtentsControlArrow extends ViewClipControlArrow {\n    constructor() {\n        super(...arguments);\n        this.extentValid = true;\n    }\n}\n/** Values for [[ProjectExtentsClipDecoration.onChanged] event.\n * @beta\n */\nexport var ProjectLocationChanged;\n(function (ProjectLocationChanged) {\n    /** Extents has been modified (unsaved changes) */\n    ProjectLocationChanged[ProjectLocationChanged[\"Extents\"] = 0] = \"Extents\";\n    /** Geolocation has been modified (unsaved changes) */\n    ProjectLocationChanged[ProjectLocationChanged[\"Geolocation\"] = 1] = \"Geolocation\";\n    /** Abandon unsaved changes to extents */\n    ProjectLocationChanged[ProjectLocationChanged[\"ResetExtents\"] = 2] = \"ResetExtents\";\n    /** Abandon unsaved changes to geolocation */\n    ProjectLocationChanged[ProjectLocationChanged[\"ResetGeolocation\"] = 3] = \"ResetGeolocation\";\n    /** Decoration hidden (unsaved changes preserved) */\n    ProjectLocationChanged[ProjectLocationChanged[\"Hide\"] = 4] = \"Hide\";\n    /** Decoration shown (unsaved changes restored) */\n    ProjectLocationChanged[ProjectLocationChanged[\"Show\"] = 5] = \"Show\";\n    /** Save changes to extents and geolocation */\n    ProjectLocationChanged[ProjectLocationChanged[\"Save\"] = 6] = \"Save\";\n})(ProjectLocationChanged || (ProjectLocationChanged = {}));\n/** Controls to modify project extents shown using view clip\n * @beta\n */\nexport class ProjectExtentsClipDecoration extends EditManipulator.HandleProvider {\n    constructor(viewport) {\n        super(viewport.iModel);\n        this.viewport = viewport;\n        this._extentsLengthValid = true;\n        this._extentsWidthValid = true;\n        this._extentsHeightValid = true;\n        this._allowEcefLocationChange = false;\n        this._controlIds = [];\n        this._controls = [];\n        this._suspendDecorator = false;\n        this.suspendGeolocationDecorations = false;\n        /** Called when project extents or geolocation is modified */\n        this.onChanged = new BeEvent();\n        if (!this.init())\n            return;\n        this._monumentId = this.iModel.transientIds.getNext();\n        this._northId = this.iModel.transientIds.getNext();\n        this._clipId = this.iModel.transientIds.getNext();\n        this.start();\n    }\n    start() {\n        this.updateDecorationListener(true);\n        this._removeViewCloseListener = IModelApp.viewManager.onViewClose.addListener((vp) => this.onViewClose(vp));\n        this.iModel.selectionSet.replace(this._clipId); // Always select decoration on create...\n    }\n    stop() {\n        const selectedId = (undefined !== this._clipId && this.iModel.selectionSet.has(this._clipId)) ? this._clipId : undefined;\n        this._clipId = undefined; // Invalidate id so that decorator will be dropped...\n        super.stop();\n        if (undefined !== selectedId)\n            this.iModel.selectionSet.remove(selectedId); // Don't leave decorator id in selection set...\n        if (undefined !== this._removeViewCloseListener) {\n            this._removeViewCloseListener();\n            this._removeViewCloseListener = undefined;\n        }\n    }\n    init() {\n        if (!this.getClipData())\n            return false;\n        this._ecefLocation = this.iModel.ecefLocation;\n        this._monumentPoint = this.getMonumentPoint();\n        this._northDirection = this.getNorthDirection();\n        return true;\n    }\n    onViewClose(vp) {\n        if (this.viewport === vp)\n            ProjectExtentsClipDecoration.clear();\n    }\n    getClipData() {\n        this._clip = this._clipShape = this._clipShapeExtents = this._clipRange = undefined;\n        const clip = this.viewport.view.getViewClip();\n        if (undefined === clip)\n            return false;\n        const clipShape = ViewClipTool.isSingleClipShape(clip);\n        if (undefined === clipShape)\n            return false;\n        if (5 !== clipShape.polygon.length || undefined === clipShape.zLow || undefined === clipShape.zHigh)\n            return false; // Not a box, can't be project extents clip...\n        if (undefined !== clipShape.transformFromClip && !clipShape.transformFromClip.isIdentity)\n            return false; // Not axis aligned, can't be project extents clip...\n        this._clipShapeExtents = Range1d.createXX(clipShape.zLow, clipShape.zHigh);\n        this._clipShape = clipShape;\n        this._clip = clip;\n        this._clipRange = Range3d.create();\n        const shapePtsLo = ViewClipTool.getClipShapePoints(this._clipShape, this._clipShapeExtents.low);\n        const shapePtsHi = ViewClipTool.getClipShapePoints(this._clipShape, this._clipShapeExtents.high);\n        this._clipRange.extendArray(shapePtsLo);\n        this._clipRange.extendArray(shapePtsHi);\n        return true;\n    }\n    ensureNumControls(numReqControls) {\n        const numCurrent = this._controlIds.length;\n        if (numCurrent < numReqControls) {\n            const transientIds = this.iModel.transientIds;\n            for (let i = numCurrent; i < numReqControls; i++)\n                this._controlIds[i] = transientIds.getNext();\n        }\n        else if (numCurrent > numReqControls) {\n            this._controlIds.length = numReqControls;\n        }\n    }\n    createClipShapeControls() {\n        if (undefined === this._clipShape)\n            return false;\n        const shapePtsLo = ViewClipTool.getClipShapePoints(this._clipShape, this._clipShapeExtents.low);\n        const shapePtsHi = ViewClipTool.getClipShapePoints(this._clipShape, this._clipShapeExtents.high);\n        const shapeArea = PolygonOps.centroidAreaNormal(shapePtsLo);\n        if (undefined === shapeArea)\n            return false;\n        const numControls = shapePtsLo.length + 1; // Number of edge midpoints plus zLow and zHigh...\n        this.ensureNumControls(numControls);\n        for (let i = 0; i < numControls - 2; i++) {\n            const midPtLo = shapePtsLo[i].interpolate(0.5, shapePtsLo[i + 1]);\n            const midPtHi = shapePtsHi[i].interpolate(0.5, shapePtsHi[i + 1]);\n            const faceCenter = midPtLo.interpolate(0.5, midPtHi);\n            const edgeTangent = Vector3d.createStartEnd(shapePtsLo[i], shapePtsLo[i + 1]);\n            const faceNormal = edgeTangent.crossProduct(shapeArea.direction);\n            faceNormal.normalizeInPlace();\n            this._controls[i] = new ProjectExtentsControlArrow(faceCenter, faceNormal, 0.75);\n            this._controls[i].extentValid = (faceNormal.isParallelTo(Vector3d.unitX(), true) ? this._extentsLengthValid : this._extentsWidthValid);\n        }\n        const zFillColor = ColorDef.from(150, 150, 250);\n        this._controls[numControls - 2] = new ProjectExtentsControlArrow(shapeArea.origin, Vector3d.unitZ(-1.0), 0.75, zFillColor, undefined, \"zLow\");\n        this._controls[numControls - 1] = new ProjectExtentsControlArrow(shapeArea.origin.plusScaled(Vector3d.unitZ(), shapePtsLo[0].distance(shapePtsHi[0])), Vector3d.unitZ(), 0.75, zFillColor, undefined, \"zHigh\");\n        this._controls[numControls - 2].extentValid = this._extentsHeightValid;\n        this._controls[numControls - 1].extentValid = this._extentsHeightValid;\n        return true;\n    }\n    /** Allow project extents for map projections to be larger since curvature of the earth is accounted for. */\n    get maxExtentLength() { return ((this._allowEcefLocationChange ? 20 : 350) * Constant.oneKilometer); }\n    /** Impose some reasonable height limit for project extents. */\n    get maxExtentHeight() { return (2 * Constant.oneKilometer); }\n    hasValidGCS() {\n        if (!this.iModel.isGeoLocated || this.iModel.noGcsDefined)\n            return false;\n        const gcs = this.iModel.geographicCoordinateSystem;\n        if (undefined === gcs || undefined === gcs.horizontalCRS)\n            return false; // A valid GCS ought to have horizontalCR defined...\n        // Check for approximate GCS (such as from MicroStation's \"From Placemark\" tool) and allow it to be replaced...\n        const hasValidId = (undefined !== gcs.horizontalCRS.id && 0 !== gcs.horizontalCRS.id.length);\n        const hasValidDescr = (undefined !== gcs.horizontalCRS.description && 0 !== gcs.horizontalCRS.description.length);\n        const hasValidProjection = (undefined !== gcs.horizontalCRS.projection && \"AzimuthalEqualArea\" !== gcs.horizontalCRS.projection.method);\n        return hasValidId || hasValidDescr || hasValidProjection;\n    }\n    async createControls() {\n        // Always update to current view clip to handle post-modify, etc.\n        if (undefined === this._clipId || !this.getClipData())\n            return false;\n        this._allowEcefLocationChange = !this.hasValidGCS();\n        if (undefined !== this._clipRange) {\n            this._extentsLengthValid = (this._clipRange.xLength() < this.maxExtentLength);\n            this._extentsWidthValid = (this._clipRange.yLength() < this.maxExtentLength);\n            this._extentsHeightValid = (this._clipRange.zLength() < this.maxExtentHeight);\n        }\n        // Show controls if only range box and it's controls are selected, selection set doesn't include any other elements...\n        let showControls = false;\n        if (this.iModel.selectionSet.size <= this._controlIds.length + 1 && this.iModel.selectionSet.has(this._clipId)) {\n            showControls = true;\n            if (this.iModel.selectionSet.size > 1) {\n                this.iModel.selectionSet.elements.forEach((val) => {\n                    if (this._clipId !== val && !this._controlIds.includes(val))\n                        showControls = false;\n                });\n            }\n        }\n        if (!showControls)\n            return false; // Don't clear decoration on de-select...\n        return this.createClipShapeControls();\n    }\n    clearControls() {\n        this.iModel.selectionSet.remove(this._controlIds); // Remove any selected controls as they won't continue to be displayed...\n        super.clearControls();\n    }\n    async modifyControls(hit, _ev) {\n        if (undefined === this._clip || hit.sourceId === this._clipId)\n            return false;\n        const saveQualifiers = IModelApp.toolAdmin.currentInputState.qualifiers;\n        if (undefined !== this._clipShape) {\n            const clipShapeModifyTool = new ViewClipShapeModifyTool(this, this._clip, this.viewport, hit.sourceId, this._controlIds, this._controls);\n            this._suspendDecorator = await clipShapeModifyTool.run();\n        }\n        if (this._suspendDecorator)\n            IModelApp.toolAdmin.currentInputState.qualifiers = saveQualifiers; // onInstallTool cleared qualifiers, preserve for \"modify all\" behavior when shift was held and drag started...\n        return this._suspendDecorator;\n    }\n    async onRightClick(_hit, _ev) { return EventHandled.No; }\n    async onTouchTap(hit, ev) { return (hit.sourceId === this._clipId ? EventHandled.No : super.onTouchTap(hit, ev)); }\n    async onDecorationButtonEvent(hit, ev) {\n        if (hit.sourceId === this._monumentId) {\n            if (BeButton.Data === ev.button && !ev.isDown && !ev.isDragging)\n                await ProjectGeolocationPointTool.startTool();\n            return EventHandled.Yes; // Only pickable for tooltip, don't allow selection...\n        }\n        if (hit.sourceId === this._northId) {\n            if (BeButton.Data === ev.button && !ev.isDown && !ev.isDragging)\n                await ProjectGeolocationNorthTool.startTool();\n            return EventHandled.Yes; // Only pickable for tooltip, don't allow selection...\n        }\n        return super.onDecorationButtonEvent(hit, ev);\n    }\n    onManipulatorEvent(eventType) {\n        if (EditManipulator.EventType.Accept === eventType)\n            this.onChanged.raiseEvent(this.iModel, ProjectLocationChanged.Extents);\n        this._suspendDecorator = false;\n        super.onManipulatorEvent(eventType);\n    }\n    async getDecorationToolTip(hit) {\n        const quantityFormatter = IModelApp.quantityFormatter;\n        const toolTip = document.createElement(\"div\");\n        let toolTipHtml = \"\";\n        if (hit.sourceId === this._monumentId) {\n            toolTipHtml += `${translateMessage(\"ModifyGeolocation\")}<br>`;\n            const coordFormatterSpec = quantityFormatter.findFormatterSpecByQuantityType(QuantityType.Coordinate);\n            if (undefined !== coordFormatterSpec) {\n                const pointAdjusted = this._monumentPoint.minus(this.iModel.globalOrigin);\n                const formattedPointX = quantityFormatter.formatQuantity(pointAdjusted.x, coordFormatterSpec);\n                const formattedPointY = quantityFormatter.formatQuantity(pointAdjusted.y, coordFormatterSpec);\n                const formattedPointZ = quantityFormatter.formatQuantity(pointAdjusted.z, coordFormatterSpec);\n                toolTipHtml += `${translateCoreMeasureBold(\"Coordinate\") + formattedPointX}, ${formattedPointY}, ${formattedPointZ}<br>`;\n            }\n            const latLongFormatterSpec = quantityFormatter.findFormatterSpecByQuantityType(QuantityType.LatLong);\n            if (undefined !== latLongFormatterSpec && undefined !== coordFormatterSpec && this.iModel.isGeoLocated) {\n                const cartographic = this.iModel.spatialToCartographicFromEcef(this._monumentPoint);\n                const formattedLat = quantityFormatter.formatQuantity(Math.abs(cartographic.latitude), latLongFormatterSpec);\n                const formattedLong = quantityFormatter.formatQuantity(Math.abs(cartographic.longitude), latLongFormatterSpec);\n                const formattedHeight = quantityFormatter.formatQuantity(cartographic.height, coordFormatterSpec);\n                const latDir = CoreTools.translate(cartographic.latitude < 0 ? \"Measure.Labels.S\" : \"Measure.Labels.N\");\n                const longDir = CoreTools.translate(cartographic.longitude < 0 ? \"Measure.Labels.W\" : \"Measure.Labels.E\");\n                toolTipHtml += `${translateCoreMeasureBold(\"LatLong\") + formattedLat + latDir}, ${formattedLong}${longDir}<br>`;\n                toolTipHtml += `${translateCoreMeasureBold(\"Altitude\") + formattedHeight}<br>`;\n            }\n        }\n        else if (hit.sourceId === this._northId) {\n            toolTipHtml += `${translateMessage(\"ModifyNorthDirection\")}<br>`;\n            const angleFormatterSpec = quantityFormatter.findFormatterSpecByQuantityType(QuantityType.Angle);\n            if (undefined !== angleFormatterSpec) {\n                const formattedAngle = quantityFormatter.formatQuantity(this.getClockwiseAngleToNorth().radians, angleFormatterSpec);\n                toolTipHtml += `${translateMessageBold(\"Angle\") + formattedAngle}<br>`;\n            }\n        }\n        else if (hit.sourceId === this._clipId) {\n            const extentsValid = (this._extentsLengthValid && this._extentsWidthValid && this._extentsHeightValid);\n            toolTipHtml += `${translateMessage(extentsValid ? \"ProjectExtents\" : \"LargeProjectExtents\")}<br>`;\n            const distanceFormatterSpec = quantityFormatter.findFormatterSpecByQuantityType(QuantityType.Length);\n            if (undefined !== distanceFormatterSpec && undefined !== this._clipRange) {\n                const formattedLength = quantityFormatter.formatQuantity(this._clipRange.xLength(), distanceFormatterSpec);\n                const formattedWidth = quantityFormatter.formatQuantity(this._clipRange.yLength(), distanceFormatterSpec);\n                const formattedHeight = quantityFormatter.formatQuantity(this._clipRange.zLength(), distanceFormatterSpec);\n                toolTipHtml += `${translateMessageBold(\"Length\") + formattedLength}<br>`;\n                toolTipHtml += `${translateMessageBold(\"Width\") + formattedWidth}<br>`;\n                toolTipHtml += `${translateMessageBold(\"Height\") + formattedHeight}<br>`;\n            }\n        }\n        else {\n            const arrowIndex = this._controlIds.indexOf(hit.sourceId);\n            if (-1 !== arrowIndex) {\n                toolTipHtml += `${translateMessage(\"ModifyProjectExtents\")}<br>`;\n                const distanceFormatterSpec = quantityFormatter.findFormatterSpecByQuantityType(QuantityType.Length);\n                if (undefined !== distanceFormatterSpec && undefined !== this._clipRange) {\n                    const arrowControl = this._controls[arrowIndex];\n                    let arrowLabel = \"\";\n                    let arrowLength = 0.0;\n                    let arrowLengthMax = 0.0;\n                    if (arrowControl.direction.isParallelTo(Vector3d.unitX(), true)) {\n                        arrowLabel = \"Length\";\n                        arrowLength = this._clipRange.xLength();\n                        if (!this._extentsLengthValid)\n                            arrowLengthMax = this.maxExtentLength;\n                    }\n                    else if (arrowControl.direction.isParallelTo(Vector3d.unitY(), true)) {\n                        arrowLabel = \"Width\";\n                        arrowLength = this._clipRange.yLength();\n                        if (!this._extentsWidthValid)\n                            arrowLengthMax = this.maxExtentLength;\n                    }\n                    else {\n                        arrowLabel = \"Height\";\n                        arrowLength = this._clipRange.zLength();\n                        if (!this._extentsHeightValid)\n                            arrowLengthMax = this.maxExtentHeight;\n                        const coordFormatterSpec = (this.iModel.isGeoLocated ? quantityFormatter.findFormatterSpecByQuantityType(QuantityType.Coordinate) : undefined);\n                        if (undefined !== coordFormatterSpec) {\n                            const heightPt = (\"zLow\" === arrowControl.name ? this._clipRange.low : this._clipRange.high);\n                            const cartographic = this.iModel.spatialToCartographicFromEcef(heightPt);\n                            const formattedAltitude = quantityFormatter.formatQuantity(cartographic.height, coordFormatterSpec);\n                            toolTipHtml += `${translateCoreMeasureBold(\"Altitude\") + formattedAltitude}<br>`;\n                        }\n                    }\n                    const formattedLength = quantityFormatter.formatQuantity(arrowLength, distanceFormatterSpec);\n                    toolTipHtml += `${translateMessageBold(arrowLabel) + formattedLength}<br>`;\n                    if (0.0 !== arrowLengthMax) {\n                        const formattedMaxLength = quantityFormatter.formatQuantity(arrowLengthMax, distanceFormatterSpec);\n                        toolTipHtml += `${translateMessageBold(\"MaxExtent\") + formattedMaxLength}<br>`;\n                    }\n                }\n            }\n        }\n        toolTip.innerHTML = toolTipHtml;\n        return toolTip;\n    }\n    testDecorationHit(id) { return (id === this._monumentId || id === this._northId || id === this._clipId || this._controlIds.includes(id)); }\n    updateDecorationListener(_add) { super.updateDecorationListener(undefined !== this._clipId); } // Decorator isn't just for resize controls...\n    getMonumentPoint() {\n        const origin = Point3d.createZero();\n        if (this.iModel.ecefLocation && this.iModel.ecefLocation.cartographicOrigin)\n            return this.iModel.cartographicToSpatialFromEcef(this.iModel.ecefLocation.cartographicOrigin, origin);\n        origin.setFrom(this.iModel.projectExtents.low);\n        if (0.0 > this.iModel.projectExtents.low.z && 0.0 < this.iModel.projectExtents.high.z)\n            origin.z = 0.0;\n        return origin;\n    }\n    getClockwiseAngleToNorth() {\n        const angle = this.getNorthAngle();\n        angle.setRadians(Angle.adjustRadians0To2Pi(angle.radians));\n        return angle;\n    }\n    getNorthAngle() {\n        const northDirection = (undefined !== this._northDirection ? this._northDirection : this.getNorthDirection());\n        return northDirection.direction.angleToXY(Vector3d.unitY());\n    }\n    getNorthDirection(refOrigin) {\n        const origin = (undefined !== refOrigin ? refOrigin : this.iModel.projectExtents.center);\n        if (!this.iModel.isGeoLocated)\n            return Ray3d.create(origin, Vector3d.unitY());\n        const cartographic = this.iModel.spatialToCartographicFromEcef(origin);\n        cartographic.latitude += Angle.createDegrees(0.01).radians;\n        const pt2 = this.iModel.cartographicToSpatialFromEcef(cartographic);\n        const northVec = Vector3d.createStartEnd(origin, pt2);\n        northVec.z = 0.0;\n        northVec.normalizeInPlace();\n        return Ray3d.create(origin, northVec);\n    }\n    drawNorthArrow(context, northDir, id) {\n        const vp = context.viewport;\n        const pixelSize = vp.pixelsFromInches(0.55);\n        const scale = vp.viewingSpace.getPixelSizeAtPoint(northDir.origin) * pixelSize;\n        const matrix = Matrix3d.createRigidFromColumns(northDir.direction, Vector3d.unitZ(), AxisOrder.YZX);\n        if (undefined === matrix)\n            return;\n        matrix.scaleColumnsInPlace(scale, scale, scale);\n        const arrowTrans = Transform.createRefs(northDir.origin, matrix);\n        const northArrowBuilder = context.createGraphicBuilder(GraphicType.WorldOverlay, arrowTrans, id);\n        const color = ColorDef.white;\n        const arrowOutline = [];\n        arrowOutline[0] = Point3d.create(0.0, 0.65);\n        arrowOutline[1] = Point3d.create(-0.45, -0.5);\n        arrowOutline[2] = Point3d.create(0.0, -0.2);\n        arrowOutline[3] = Point3d.create(0.45, -0.5);\n        arrowOutline[4] = arrowOutline[0].clone();\n        const arrowLeftFill = [];\n        arrowLeftFill[0] = arrowOutline[0].clone();\n        arrowLeftFill[1] = arrowOutline[1].clone();\n        arrowLeftFill[2] = arrowOutline[2].clone();\n        arrowLeftFill[3] = arrowLeftFill[0].clone();\n        const arrowRightFill = [];\n        arrowRightFill[0] = arrowOutline[0].clone();\n        arrowRightFill[1] = arrowOutline[3].clone();\n        arrowRightFill[2] = arrowOutline[2].clone();\n        arrowRightFill[3] = arrowRightFill[0].clone();\n        northArrowBuilder.setSymbology(color, ColorDef.from(0, 0, 0, 200), 1);\n        northArrowBuilder.addArc(Arc3d.createXY(Point3d.createZero(), 0.6), true, true);\n        northArrowBuilder.addArc(Arc3d.createXY(Point3d.create(0.0, 0.85), 0.2), true, true);\n        northArrowBuilder.setSymbology(color, color, 2);\n        northArrowBuilder.addArc(Arc3d.createXY(Point3d.createZero(), 0.5), false, false);\n        northArrowBuilder.addLineString([Point3d.create(0.6, 0.0), Point3d.create(-0.6, 0.0)]);\n        northArrowBuilder.addLineString([Point3d.create(0.0, 0.6), Point3d.create(0.0, -0.6)]);\n        northArrowBuilder.setSymbology(color, ColorDef.from(150, 150, 150), 1);\n        northArrowBuilder.addShape(arrowLeftFill);\n        northArrowBuilder.setSymbology(color, ColorDef.black, 1);\n        northArrowBuilder.addShape(arrowRightFill);\n        northArrowBuilder.setSymbology(color, color, 1);\n        northArrowBuilder.addLineString(arrowOutline);\n        northArrowBuilder.setSymbology(color, color, 3);\n        northArrowBuilder.addLineString([Point3d.create(-0.1, 0.75), Point3d.create(-0.1, 0.95), Point3d.create(0.1, 0.75), Point3d.create(0.1, 0.95)]);\n        context.addDecorationFromBuilder(northArrowBuilder);\n    }\n    drawMonumentPoint(context, point, scaleFactor, id) {\n        const vp = context.viewport;\n        const pixelSize = vp.pixelsFromInches(0.25) * scaleFactor;\n        const scale = vp.viewingSpace.getPixelSizeAtPoint(point) * pixelSize;\n        const matrix = Matrix3d.createRotationAroundAxisIndex(AxisIndex.Z, Angle.createDegrees(45.0));\n        matrix.scaleColumnsInPlace(scale, scale, scale);\n        const monumentTrans = Transform.createRefs(point, matrix);\n        const monumentPointBuilder = context.createGraphicBuilder(GraphicType.WorldOverlay, monumentTrans, id);\n        const color = ColorDef.white;\n        monumentPointBuilder.setSymbology(color, ColorDef.from(0, 0, 0, 150), 1);\n        monumentPointBuilder.addArc(Arc3d.createXY(Point3d.createZero(), 0.7), true, true);\n        monumentPointBuilder.setSymbology(color, color, 2);\n        monumentPointBuilder.addArc(Arc3d.createXY(Point3d.createZero(), 0.5), false, false);\n        monumentPointBuilder.addLineString([Point3d.create(0.5, 0.0), Point3d.create(-0.5, 0.0)]);\n        monumentPointBuilder.addLineString([Point3d.create(0.0, 0.5), Point3d.create(0.0, -0.5)]);\n        context.addDecorationFromBuilder(monumentPointBuilder);\n    }\n    drawAreaTooLargeIndicator(context) {\n        if ((this._extentsLengthValid && this._extentsWidthValid) || undefined === this._clipRange)\n            return;\n        const corners = this._clipRange.corners();\n        const indices = Range3d.faceCornerIndices(5);\n        const points = [];\n        for (const index of indices)\n            points.push(corners[index]);\n        const areaWarnColor = ColorDef.red.withAlpha(50);\n        const areaWarnBuilder = context.createGraphicBuilder(GraphicType.WorldDecoration);\n        areaWarnBuilder.setSymbology(areaWarnColor, areaWarnColor, 1);\n        areaWarnBuilder.addShape(points);\n        context.addDecorationFromBuilder(areaWarnBuilder);\n    }\n    drawExtentTooLargeIndicator(context, worldPoint, sizePixels) {\n        const position = context.viewport.worldToView(worldPoint);\n        position.x = Math.floor(position.x) + 0.5;\n        position.y = Math.floor(position.y) + 0.5;\n        const drawDecoration = (ctx) => {\n            ctx.lineWidth = 4;\n            ctx.lineCap = \"round\";\n            ctx.strokeStyle = \"rgba(255,0,0,.75)\";\n            ctx.fillStyle = \"rgba(255,255,255,.75)\";\n            ctx.shadowColor = \"black\";\n            ctx.shadowBlur = 5;\n            ctx.beginPath();\n            ctx.moveTo(0, -sizePixels);\n            ctx.lineTo(-sizePixels, sizePixels);\n            ctx.lineTo(sizePixels, sizePixels);\n            ctx.lineTo(0, -sizePixels);\n            ctx.fill();\n            ctx.shadowBlur = 0;\n            ctx.beginPath();\n            ctx.moveTo(0, -sizePixels);\n            ctx.lineTo(-sizePixels, sizePixels);\n            ctx.lineTo(sizePixels, sizePixels);\n            ctx.lineTo(0, -sizePixels);\n            ctx.stroke();\n            ctx.strokeStyle = \"black\";\n            ctx.lineWidth = 3;\n            ctx.beginPath();\n            ctx.moveTo(0, -sizePixels * 0.2);\n            ctx.lineTo(0, sizePixels * 0.3);\n            ctx.moveTo(0, (sizePixels * 0.3) + 4);\n            ctx.lineTo(0, (sizePixels * 0.3) + 4.5);\n            ctx.stroke();\n        };\n        context.addCanvasDecoration({ position, drawDecoration });\n    }\n    decorate(context) {\n        if (this._suspendDecorator)\n            return;\n        if (undefined === this._clipId || undefined === this._clipShape || undefined === this._clipRange)\n            return;\n        const vp = context.viewport;\n        if (this.viewport !== vp)\n            return;\n        if (!this.suspendGeolocationDecorations && undefined !== this._northDirection && this.iModel.isGeoLocated)\n            this.drawNorthArrow(context, this._northDirection, this._allowEcefLocationChange ? this._northId : undefined); // Show north, but don't make pickable if it shouldn't be modified...\n        const maxSizeInches = ((this._clipRange.maxLength() / vp.viewingSpace.getPixelSizeAtPoint(this._clipRange.center)) / vp.pixelsPerInch) * 0.5; // Display size limit when zooming out...\n        if (maxSizeInches < 0.5)\n            return;\n        if (!this.suspendGeolocationDecorations && undefined !== this._monumentPoint && this._allowEcefLocationChange)\n            this.drawMonumentPoint(context, this._monumentPoint, 1.0, this._monumentId);\n        ViewClipTool.drawClipShape(context, this._clipShape, this._clipShapeExtents, ColorDef.white.adjustedForContrast(context.viewport.view.backgroundColor), 3, this._clipId);\n        this.drawAreaTooLargeIndicator(context);\n        if (!this._isActive)\n            return;\n        const outlineColor = ColorDef.from(0, 0, 0, 50).adjustedForContrast(vp.view.backgroundColor);\n        const fillVisColor = ColorDef.from(150, 250, 200, 225).adjustedForContrast(vp.view.backgroundColor);\n        const fillHidColor = fillVisColor.withAlpha(200);\n        const fillSelColor = fillVisColor.inverse().withAlpha(75);\n        const shapePts = EditManipulator.HandleUtils.getArrowShape(0.0, 0.15, 0.55, 1.0, 0.3, 0.5, 0.1);\n        for (let iFace = 0; iFace < this._controlIds.length; iFace++) {\n            const sizeInches = Math.min(this._controls[iFace].sizeInches, maxSizeInches);\n            if (0.0 === sizeInches)\n                continue;\n            const anchorRay = ViewClipTool.getClipRayTransformed(this._controls[iFace].origin, this._controls[iFace].direction, undefined !== this._clipShape ? this._clipShape.transformFromClip : undefined);\n            const transform = EditManipulator.HandleUtils.getArrowTransform(vp, anchorRay.origin, anchorRay.direction, sizeInches);\n            if (undefined === transform)\n                continue;\n            // deep copies because we're using a builder transform w/addLineString...\n            const visPts = shapePts.map((pt) => pt.clone());\n            const hidPts = shapePts.map((pt) => pt.clone());\n            const arrowVisBuilder = context.createGraphicBuilder(GraphicType.WorldOverlay, transform, this._controlIds[iFace]);\n            const arrowHidBuilder = context.createGraphicBuilder(GraphicType.WorldDecoration, transform);\n            const isSelected = this.iModel.selectionSet.has(this._controlIds[iFace]);\n            let outlineColorOvr = this._controls[iFace].outline;\n            if (undefined !== outlineColorOvr) {\n                outlineColorOvr = outlineColorOvr.adjustedForContrast(vp.view.backgroundColor);\n                outlineColorOvr = outlineColorOvr.withAlpha(outlineColor.getAlpha());\n            }\n            else {\n                outlineColorOvr = outlineColor;\n            }\n            let fillVisColorOvr = this._controls[iFace].fill;\n            let fillHidColorOvr = fillHidColor;\n            let fillSelColorOvr = fillSelColor;\n            if (undefined !== fillVisColorOvr) {\n                fillVisColorOvr = fillVisColorOvr.adjustedForContrast(vp.view.backgroundColor);\n                fillVisColorOvr = fillVisColorOvr.withAlpha(fillVisColor.getAlpha());\n                fillHidColorOvr = fillVisColorOvr.withAlpha(fillHidColor.getAlpha());\n                fillSelColorOvr = fillVisColorOvr.inverse().withAlpha(fillSelColor.getAlpha());\n            }\n            else {\n                fillVisColorOvr = fillVisColor;\n            }\n            arrowVisBuilder.setSymbology(outlineColorOvr, outlineColorOvr, isSelected ? 4 : 2);\n            arrowVisBuilder.addLineString(visPts);\n            arrowVisBuilder.setBlankingFill(isSelected ? fillSelColorOvr : fillVisColorOvr);\n            arrowVisBuilder.addShape(visPts);\n            context.addDecorationFromBuilder(arrowVisBuilder);\n            arrowHidBuilder.setSymbology(fillHidColorOvr, fillHidColorOvr, 1);\n            arrowHidBuilder.addShape(hidPts);\n            context.addDecorationFromBuilder(arrowHidBuilder);\n            if (this._controls[iFace].extentValid)\n                continue;\n            const warnPixels = 15.0;\n            const warnOffset = vp.viewingSpace.getPixelSizeAtPoint(anchorRay.origin) * warnPixels * 1.5;\n            const warnOrigin = anchorRay.origin.plusScaled(anchorRay.direction, -warnOffset);\n            this.drawExtentTooLargeIndicator(context, warnOrigin, warnPixels);\n        }\n    }\n    resetViewClip() {\n        if (!clearViewClip(this.viewport))\n            return false;\n        if (undefined !== this.getModifiedExtents())\n            this.onChanged.raiseEvent(this.iModel, ProjectLocationChanged.ResetExtents);\n        return true;\n    }\n    resetGeolocation() {\n        if (!this._allowEcefLocationChange)\n            return false;\n        if (undefined === this.getModifiedEcefLocation())\n            return false; // Wasn't changed...\n        this.iModel.disableGCS(false);\n        this.iModel.ecefLocation = this._ecefLocation;\n        this._monumentPoint = this.getMonumentPoint();\n        this._northDirection = this.getNorthDirection();\n        updateMapDisplay(this.viewport, false);\n        this.onChanged.raiseEvent(this.iModel, ProjectLocationChanged.ResetGeolocation);\n        return true;\n    }\n    updateEcefLocation(origin, point, angle) {\n        if (!this._allowEcefLocationChange)\n            return false;\n        const newEcefLocation = EcefLocation.createFromCartographicOrigin(origin, point, (undefined !== angle ? angle : this.getNorthAngle())); // Preserve modified north direction...\n        const ecefLocation = this.iModel.ecefLocation;\n        if (undefined !== ecefLocation && ecefLocation.isAlmostEqual(newEcefLocation))\n            return false;\n        this.iModel.disableGCS(true); // Map display will ignore change to ecef location when GCS is present...\n        this.iModel.setEcefLocation(newEcefLocation);\n        this._monumentPoint = this.getMonumentPoint();\n        this._northDirection = this.getNorthDirection(undefined !== this._northDirection ? this._northDirection.origin : undefined); // Preserve modified north reference point...\n        updateMapDisplay(this.viewport, true);\n        this.onChanged.raiseEvent(this.iModel, ProjectLocationChanged.Geolocation);\n        return true;\n    }\n    updateNorthDirection(northDir) {\n        if (!this._allowEcefLocationChange || !this.iModel.isGeoLocated)\n            return false;\n        const point = (undefined !== this._monumentPoint ? this._monumentPoint : this.getMonumentPoint()); // Preserve modified monument point...\n        const origin = this.iModel.spatialToCartographicFromEcef(point);\n        const saveDirection = this._northDirection;\n        this._northDirection = northDir; // Change reference point to input location...\n        const angle = this.getNorthAngle();\n        if (!this.updateEcefLocation(origin, point, angle)) {\n            this._northDirection = saveDirection;\n            return false;\n        }\n        return true;\n    }\n    getModifiedEcefLocation() {\n        const ecefLocation = this.iModel.ecefLocation;\n        if (undefined === ecefLocation)\n            return undefined; // geolocation wasn't added...\n        if (undefined === this._ecefLocation)\n            return ecefLocation; // geolocation didn't exist previously...\n        if (this._ecefLocation.isAlmostEqual(ecefLocation))\n            return undefined;\n        return ecefLocation;\n    }\n    getModifiedExtents() {\n        if (undefined === this._clipRange)\n            return undefined;\n        return this._clipRange.isAlmostEqual(this.iModel.projectExtents) ? undefined : this._clipRange;\n    }\n    static allowEcefLocationChange(requireExisting, outputError = true) {\n        if (undefined === ProjectExtentsClipDecoration._decorator) {\n            if (outputError)\n                IModelApp.notifications.outputMessage(new NotifyMessageDetails(OutputMessagePriority.Info, translateMessage(\"NotActive\")));\n            return false;\n        }\n        else if (!ProjectExtentsClipDecoration._decorator._allowEcefLocationChange) {\n            if (outputError)\n                IModelApp.notifications.outputMessage(new NotifyMessageDetails(OutputMessagePriority.Info, translateMessage(\"NotAllowed\")));\n            return false;\n        }\n        else if (requireExisting && !ProjectExtentsClipDecoration._decorator.iModel.isGeoLocated) {\n            if (outputError)\n                IModelApp.notifications.outputMessage(new NotifyMessageDetails(OutputMessagePriority.Info, translateMessage(\"NotGeolocated\")));\n            return false;\n        }\n        return true;\n    }\n    fitExtents() {\n        if (undefined === this._clipRange)\n            return undefined;\n        const options = { animateFrustumChange: true, animationTime: BeDuration.fromSeconds(2).milliseconds };\n        const aspect = this.viewport.viewRect.aspect;\n        this.viewport.view.lookAtVolume(this._clipRange, aspect);\n        this.viewport.synchWithView(options);\n        this.viewport.viewCmdTargetCenter = undefined;\n    }\n    static get() {\n        if (undefined === ProjectExtentsClipDecoration._decorator)\n            return undefined;\n        return ProjectExtentsClipDecoration._decorator;\n    }\n    static show(vp, fitExtents = true) {\n        if (!vp.view.isSpatialView())\n            return false;\n        if (undefined !== ProjectExtentsClipDecoration._decorator) {\n            const deco = ProjectExtentsClipDecoration._decorator;\n            if (vp === deco.viewport && undefined !== deco._clipId && undefined !== deco._clip) {\n                if (deco._clip !== vp.view.getViewClip()) {\n                    clearViewClip(vp);\n                    ViewClipTool.enableClipVolume(vp);\n                    ViewClipTool.setViewClip(vp, deco._clip);\n                }\n                if (undefined === deco._removeManipulatorToolListener) {\n                    deco._removeManipulatorToolListener = IModelApp.toolAdmin.manipulatorToolEvent.addListener((tool, event) => deco.onManipulatorToolEvent(tool, event));\n                    deco.start();\n                    deco.onChanged.raiseEvent(deco.iModel, ProjectLocationChanged.Show);\n                }\n                return true;\n            }\n            ProjectExtentsClipDecoration.clear();\n        }\n        if (!clipToProjectExtents(vp))\n            return false;\n        ProjectExtentsClipDecoration._decorator = new ProjectExtentsClipDecoration(vp);\n        if (fitExtents)\n            ProjectExtentsClipDecoration._decorator.fitExtents();\n        vp.onChangeView.addOnce(() => this.clear(false, true));\n        return (undefined !== ProjectExtentsClipDecoration._decorator._clipId);\n    }\n    static hide() {\n        if (undefined === ProjectExtentsClipDecoration._decorator)\n            return;\n        const saveClipId = ProjectExtentsClipDecoration._decorator._clipId; // cleared by stop to trigger decorator removal...\n        ProjectExtentsClipDecoration._decorator.stop();\n        ProjectExtentsClipDecoration._decorator._clipId = saveClipId;\n        ProjectExtentsClipDecoration._decorator.onChanged.raiseEvent(ProjectExtentsClipDecoration._decorator.iModel, ProjectLocationChanged.Hide);\n    }\n    static clear(clearClip = true, resetGeolocation = true) {\n        if (undefined === ProjectExtentsClipDecoration._decorator)\n            return;\n        if (clearClip)\n            ProjectExtentsClipDecoration._decorator.resetViewClip(); // Clear project extents view clip...\n        if (resetGeolocation)\n            ProjectExtentsClipDecoration._decorator.resetGeolocation(); // Restore modified geolocation back to create state...\n        ProjectExtentsClipDecoration._decorator.stop();\n        ProjectExtentsClipDecoration._decorator = undefined;\n    }\n    static async update() {\n        const deco = ProjectExtentsClipDecoration._decorator;\n        if (undefined === deco)\n            return;\n        clipToProjectExtents(deco.viewport);\n        deco.init();\n        return deco.updateControls();\n    }\n}\n/** Show project location decoration. Project extents represented by view clip.\n * @beta\n */\nclass ProjectLocationShowTool extends Tool {\n    async run() {\n        const vp = IModelApp.viewManager.selectedView;\n        if (undefined === vp || !ProjectExtentsClipDecoration.show(vp))\n            return false;\n        await IModelApp.toolAdmin.startDefaultTool();\n        return true;\n    }\n}\nProjectLocationShowTool.toolId = \"ProjectLocation.Show\";\nexport { ProjectLocationShowTool };\n/** Hide project location decoration. Preserves changes to project extents view clip and geolocation.\n * @beta\n */\nclass ProjectLocationHideTool extends Tool {\n    async run() {\n        ProjectExtentsClipDecoration.hide();\n        await IModelApp.toolAdmin.startDefaultTool();\n        return true;\n    }\n}\nProjectLocationHideTool.toolId = \"ProjectLocation.Hide\";\nexport { ProjectLocationHideTool };\n/** Clear project location decoration. Restore modified geolocation and remove view clip.\n * @beta\n */\nclass ProjectLocationCancelTool extends Tool {\n    async run() {\n        ProjectExtentsClipDecoration.clear();\n        await IModelApp.toolAdmin.startDefaultTool();\n        return true;\n    }\n}\nProjectLocationCancelTool.toolId = \"ProjectLocation.Cancel\";\nexport { ProjectLocationCancelTool };\n/** Save modified project extents and geolocation. Updates decoration to reflect saved state.\n * @note Allowing this change to be undone is both problematic and undesirable.\n * Warns the user if called with previous changes to cancel restarting the TxnManager session.\n * @beta\n */\nclass ProjectLocationSaveTool extends Tool {\n    async allowRestartTxnSession(iModel) {\n        if (!await iModel.txns.isUndoPossible())\n            return true;\n        // NOTE: Default if openMessageBox isn't implemented is MessageBoxValue.Ok, so we'll check No instead of Yes...\n        if (MessageBoxValue.No === await IModelApp.notifications.openMessageBox(MessageBoxType.YesNo, translateMessage(\"RestartTxn\"), MessageBoxIconType.Question))\n            return false;\n        return true;\n    }\n    async saveChanges(deco, extents, ecefLocation) {\n        if (!deco.iModel.isBriefcaseConnection())\n            return;\n        if (!await this.allowRestartTxnSession(deco.iModel))\n            return;\n        try {\n            await EditTools.startCommand({ commandId: editorBuiltInCmdIds.cmdBasicManipulation, iModelKey: deco.iModel.key });\n            if (undefined !== extents)\n                await basicManipulationIpc.updateProjectExtents(extents);\n            if (undefined !== ecefLocation)\n                await basicManipulationIpc.updateEcefLocation(ecefLocation);\n            await deco.iModel.saveChanges(this.toolId);\n            await deco.iModel.txns.restartTxnSession();\n        }\n        catch (err) {\n            IModelApp.notifications.outputMessage(new NotifyMessageDetails(OutputMessagePriority.Error, BentleyError.getErrorMessage(err) || \"An unknown error occurred.\"));\n        }\n        deco.onChanged.raiseEvent(deco.iModel, ProjectLocationChanged.Save);\n        await ProjectExtentsClipDecoration.update();\n        return IModelApp.toolAdmin.startDefaultTool();\n    }\n    async run() {\n        const deco = ProjectExtentsClipDecoration.get();\n        if (undefined === deco) {\n            IModelApp.notifications.outputMessage(new NotifyMessageDetails(OutputMessagePriority.Info, translateMessage(\"NotActive\")));\n            return false;\n        }\n        if (deco.iModel.isReadonly) {\n            IModelApp.notifications.outputMessage(new NotifyMessageDetails(OutputMessagePriority.Info, translateMessage(\"Readonly\")));\n            return true;\n        }\n        const extents = deco.getModifiedExtents();\n        const ecefLocation = deco.getModifiedEcefLocation();\n        if (undefined === extents && undefined === ecefLocation) {\n            IModelApp.notifications.outputMessage(new NotifyMessageDetails(OutputMessagePriority.Info, translateMessage(\"NoChanges\")));\n            return true;\n        }\n        await this.saveChanges(deco, extents, ecefLocation);\n        return true;\n    }\n}\nProjectLocationSaveTool.toolId = \"ProjectLocation.Save\";\nexport { ProjectLocationSaveTool };\n//# sourceMappingURL=ProjectExtentsDecoration.js.map",
      "start": 1693508122922,
      "end": 1693508123037,
      "sourcemaps": null
    }
  ]
}
