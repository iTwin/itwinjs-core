{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/glsl/Animation.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { assert } from \"@itwin/core-bentley\";\nimport { ThematicGradientSettings } from \"@itwin/core-common\";\nimport { TextureUnit } from \"../RenderFlags\";\nimport { octDecodeNormal } from \"./Surface\";\nimport { unquantizePosition } from \"./Vertex\";\nconst initialize = `\r\n  g_anim_step = vec2(1.0) / u_animLUTParams.xy;\r\n  g_anim_center = g_anim_step * 0.5;\r\n`;\n// The vertex index is an integer in [0..numVertices].\n// The frame index is an integer in [0..numBytesPerVertex/2].\n// Therefore each frame index points at 2 bytes within the texture.\n// The third component of the return value is 0.0 if the input index points to the first 2 bytes of the texel, or 1.0 if pointing to the second 2 bytes\nconst computeAnimLUTCoords = `\r\nvec3 computeAnimLUTCoords(float vertIndex, float frameIndex) {\r\n  // float baseIndex = (vertIndex * 2.0) + frameIndex;\r\n  float baseIndex = (vertIndex * u_animLUTParams.z) + frameIndex;\r\n  float halfIndex = baseIndex * 0.5;\r\n  float index = floor(halfIndex);\r\n\r\n  float epsilon = 0.5 / u_animLUTParams.x;\r\n  float yId = floor(index / u_animLUTParams.x + epsilon);\r\n  float xId = index - u_animLUTParams.x * yId;\r\n\r\n  vec2 texCoord = g_anim_center + vec2(xId / u_animLUTParams.x, yId / u_animLUTParams.y);\r\n  return vec3(texCoord, 2.0 * (halfIndex - index));\r\n}\r\n`;\n// Sample 2 bytes at the specified index.\nconst sampleAnimVec2 = `\r\nvec2 sampleAnimVec2(float vertIndex, float frameIndex) {\r\n  vec3 tc = computeAnimLUTCoords(vertIndex, frameIndex);\r\n  vec4 texel = floor(TEXTURE(u_animLUT, tc.xy) * 255.0 + 0.5);\r\n  return texel.xy * (1.0 - tc.z) + texel.zw * tc.z;\r\n}\r\n`;\n// Position is quantized to 6 bytes (2 bytes per component). So we always must sample two adjacent texels. We discard two bytes based on whether the index is even or odd.\nconst computeAnimationFrameDisplacement = `\r\nvec3 computeAnimationFrameDisplacement(float vertIndex, float frameIndex, vec3 origin, vec3 scale) {\r\n  vec3 tc = computeAnimLUTCoords(vertIndex, frameIndex);\r\n  vec4 enc1 = floor(TEXTURE(u_animLUT, tc.xy) * 255.0 + 0.5);\r\n  tc.x += g_anim_step.x;\r\n  vec4 enc2 = floor(TEXTURE(u_animLUT, tc.xy) * 255.0 + 0.5);\r\n\r\n  vec2 ex = enc1.xy * (1.0 - tc.z) + enc1.zw * tc.z;\r\n  vec2 ey = enc1.zw * (1.0 - tc.z) + enc2.xy * tc.z;\r\n  vec2 ez = enc2.xy * (1.0 - tc.z) + enc2.zw * tc.z;\r\n\r\n  vec3 qpos = vec3(decodeUInt16(ex), decodeUInt16(ey), decodeUInt16(ez));\r\n  return unquantizePosition(qpos, origin, scale).xyz;\r\n}\r\n`;\nconst computeAnimationDisplacement = `\r\nvec3 computeAnimationDisplacement(float vertIndex, float frameIndex0, float frameIndex1, float fraction, vec3 origin, vec3 scale) {\r\n  if (frameIndex0 < 0.0)\r\n    return vec3(0.0, 0.0, 0.0);\r\n\r\n  vec3 displacement = computeAnimationFrameDisplacement(vertIndex, frameIndex0, origin, scale);\r\n  if (fraction > 0.0) {\r\n    vec3 displacement1 = computeAnimationFrameDisplacement(vertIndex, frameIndex1, origin, scale);\r\n    displacement += fraction * (displacement1 - displacement);\r\n    }\r\n\r\n  return displacement;\r\n}\r\n`;\nconst adjustRawPosition = `\r\n  rawPos.xyz += computeAnimationDisplacement(g_vertexLUTIndex, u_animDispParams.x, u_animDispParams.y, u_animDispParams.z, u_qAnimDispOrigin, u_qAnimDispScale);\r\n  return rawPos;\r\n`;\nconst computeAnimationFrameNormal = `\r\nvec3 computeAnimationFrameNormal(float frameIndex) {\r\n  vec2 enc = sampleAnimVec2(g_vertexLUTIndex, frameIndex);\r\n  return octDecodeNormal(enc);\r\n}\r\n`;\nconst computeAnimationNormal = `\r\nvec3 computeAnimationNormal(float frameIndex0, float frameIndex1, float fraction) {\r\n  vec3 normal = computeAnimationFrameNormal(frameIndex0);\r\n  if (fraction > 0.0) {\r\n    vec3 normal1 = computeAnimationFrameNormal(frameIndex1);\r\n    normal += fraction * (normal1 - normal);\r\n    }\r\n\r\n  return normal;\r\n}\r\n`;\nconst computeAnimationFrameParam = `\r\nfloat computeAnimationFrameParam(float frameIndex, float origin, float scale) {\r\n  vec2 enc = sampleAnimVec2(g_vertexLUTIndex, frameIndex);\r\n  return clamp((origin + scale * decodeUInt16(enc)), 0.0, 1.0);\r\n}\r\n`;\nconst computeAnimationParam = `\r\nvec2 computeAnimationParam(float frameIndex0, float frameIndex1, float fraction, float origin, float scale) {\r\n  float param = computeAnimationFrameParam(frameIndex0, origin, scale);\r\n  if (fraction > 0.0) {\r\n    float param1 = computeAnimationFrameParam(frameIndex1, origin, scale);\r\n    param += fraction * (param1 - param);\r\n  }\r\n\r\n  return vec2(.5, param);\r\n}\r\n`;\nconst scratchAnimParams = [\n    undefined,\n    undefined,\n    new Float32Array(2),\n    new Float32Array(3), // index0, index1, fraction\n];\nfunction getAnimParams(size, initialValue) {\n    const array = scratchAnimParams[size];\n    if (undefined !== initialValue)\n        for (let i = 0; i < array.length; i++)\n            array[i] = initialValue;\n    return array;\n}\nfunction getDisplacementChannel(params) {\n    const displacement = params.target.analysisStyle?.displacement;\n    if (!displacement)\n        return undefined;\n    const channel = params.geometry.asLUT?.lut.auxChannels?.displacements?.get(displacement.channelName);\n    return channel ? { channel, displacement } : undefined;\n}\nfunction getNormalChannel(params) {\n    const channelName = params.target.analysisStyle?.normalChannelName;\n    if (undefined === channelName)\n        return undefined;\n    return params.geometry.asLUT?.lut.auxChannels?.normals?.get(channelName);\n}\nfunction getScalarChannel(params) {\n    const scalar = params.target.analysisStyle?.thematic;\n    if (!scalar)\n        return undefined;\n    const channel = params.geometry.asMesh?.lut.auxChannels?.params?.get(scalar.channelName);\n    return channel ? { channel, scalar } : undefined;\n}\nfunction computeAnimParams(params, channel, fraction) {\n    const { inputs, indices } = channel;\n    const inputValue = fraction * inputs[inputs.length - 1];\n    for (let i = 0; i < inputs.length - 1; i++) {\n        if (inputValue >= inputs[i] && inputValue < inputs[i + 1]) {\n            params[0] = indices[i];\n            params[1] = indices[i + 1];\n            params[2] = inputValue - inputs[i] / (inputs[i + 1] - inputs[i]);\n            return;\n        }\n    }\n    params[0] = params[1] = indices[inputs.length - 1];\n    params[2] = 0.0;\n}\n/** @internal */\nexport function addAnimation(vert, isSurface) {\n    // Lookup table\n    vert.addGlobal(\"g_anim_step\", 3 /* VariableType.Vec2 */);\n    vert.addGlobal(\"g_anim_center\", 3 /* VariableType.Vec2 */);\n    vert.addInitializer(initialize);\n    vert.addFunction(unquantizePosition);\n    vert.addUniform(\"u_animLUT\", 8 /* VariableType.Sampler2D */, (prog) => {\n        prog.addGraphicUniform(\"u_animLUT\", (uniform, params) => {\n            const channels = (params.geometry.asLUT).lut.auxChannels;\n            assert(undefined !== channels);\n            channels.texture.bindSampler(uniform, TextureUnit.AuxChannelLUT);\n        });\n    });\n    vert.addUniform(\"u_animLUTParams\", 4 /* VariableType.Vec3 */, (prog) => {\n        prog.addGraphicUniform(\"u_animLUTParams\", (uniform, params) => {\n            const geom = params.geometry.asLUT;\n            assert(undefined !== geom && undefined !== geom.lut.auxChannels);\n            const tex = geom.lut.auxChannels.texture;\n            const array = getAnimParams(3);\n            array[0] = tex.width;\n            array[1] = tex.height;\n            array[2] = geom.lut.auxChannels.numBytesPerVertex / 2;\n            uniform.setUniform3fv(array);\n        });\n    });\n    vert.addFunction(computeAnimLUTCoords);\n    vert.addFunction(sampleAnimVec2);\n    // Displacement\n    vert.addFunction(computeAnimationFrameDisplacement);\n    vert.addFunction(computeAnimationDisplacement);\n    vert.set(1 /* VertexShaderComponent.AdjustRawPosition */, adjustRawPosition);\n    vert.addUniform(\"u_animDispParams\", 4 /* VariableType.Vec3 */, (prog) => {\n        prog.addGraphicUniform(\"u_animDispParams\", (uniform, params) => {\n            const animParams = getAnimParams(3, 0.0);\n            const disp = getDisplacementChannel(params);\n            if (undefined !== disp)\n                computeAnimParams(animParams, disp.channel, params.target.analysisFraction);\n            uniform.setUniform3fv(animParams);\n        });\n    });\n    vert.addUniform(\"u_qAnimDispScale\", 4 /* VariableType.Vec3 */, (prog) => {\n        prog.addGraphicUniform(\"u_qAnimDispScale\", (uniform, params) => {\n            const animParams = getAnimParams(3, 0.0);\n            const disp = getDisplacementChannel(params);\n            if (undefined !== disp)\n                for (let i = 0; i < 3; i++)\n                    animParams[i] = disp.channel.qScale[i] * disp.displacement.scale;\n            uniform.setUniform3fv(animParams);\n        });\n    });\n    vert.addUniform(\"u_qAnimDispOrigin\", 4 /* VariableType.Vec3 */, (prog) => {\n        prog.addGraphicUniform(\"u_qAnimDispOrigin\", (uniform, params) => {\n            const animParams = getAnimParams(3, 0.0);\n            const disp = getDisplacementChannel(params);\n            if (undefined !== disp)\n                for (let i = 0; i < 3; i++)\n                    animParams[i] = disp.channel.qOrigin[i] * disp.displacement.scale;\n            uniform.setUniform3fv(animParams);\n        });\n    });\n    // Normal and param\n    if (isSurface) {\n        vert.addFunction(octDecodeNormal);\n        vert.addFunction(computeAnimationFrameNormal);\n        vert.addFunction(computeAnimationNormal);\n        vert.addFunction(computeAnimationFrameParam);\n        vert.addFunction(computeAnimationParam);\n        vert.addUniform(\"u_animNormalParams\", 4 /* VariableType.Vec3 */, (prog) => {\n            prog.addGraphicUniform(\"u_animNormalParams\", (uniform, params) => {\n                const animParams = getAnimParams(3, -1.0);\n                const channel = getNormalChannel(params);\n                if (undefined !== channel)\n                    computeAnimParams(animParams, channel, params.target.analysisFraction);\n                uniform.setUniform3fv(animParams);\n            });\n        });\n        vert.addUniform(\"u_animScalarParams\", 4 /* VariableType.Vec3 */, (prog) => {\n            prog.addGraphicUniform(\"u_animScalarParams\", (uniform, params) => {\n                const scalars = getScalarChannel(params);\n                const animParams = getAnimParams(3, -1.0);\n                if (scalars)\n                    computeAnimParams(animParams, scalars.channel, params.target.analysisFraction);\n                uniform.setUniform3fv(animParams);\n            });\n        });\n        vert.addUniform(\"u_animScalarQParams\", 3 /* VariableType.Vec2 */, (prog) => {\n            prog.addGraphicUniform(\"u_animScalarQParams\", (uniform, params) => {\n                const scalars = getScalarChannel(params);\n                const animParams = getAnimParams(2, 1.0);\n                if (scalars) {\n                    const range = scalars.scalar.range;\n                    let rangeScale = range.high - range.low;\n                    if (rangeScale === 0)\n                        rangeScale = 1;\n                    animParams[0] = ThematicGradientSettings.margin + (scalars.channel.qOrigin - range.low) / rangeScale;\n                    animParams[1] = ThematicGradientSettings.contentRange * scalars.channel.qScale / rangeScale;\n                }\n                uniform.setUniform2fv(animParams);\n            });\n        });\n    }\n}\n//# sourceMappingURL=Animation.js.map",
      "start": 1693508126470,
      "end": 1693508126568,
      "sourcemaps": null
    }
  ]
}
