{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/Mesh.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { assert, dispose } from \"@itwin/core-bentley\";\nimport { SurfaceType } from \"../../common/render/primitives/SurfaceParams\";\nimport { CachedGeometry } from \"./CachedGeometry\";\nimport { Graphic } from \"./Graphic\";\nimport { InstanceBuffers, PatternBuffers } from \"./InstancedGeometry\";\nimport { Primitive } from \"./Primitive\";\nimport { EdgeGeometry, PolylineEdgeGeometry, SilhouetteEdgeGeometry } from \"./EdgeGeometry\";\nimport { IndexedEdgeGeometry } from \"./IndexedEdgeGeometry\";\nimport { SurfaceGeometry } from \"./SurfaceGeometry\";\nimport { MeshData } from \"./MeshData\";\n/** @internal */\nexport class MeshRenderGeometry {\n    constructor(data, params) {\n        this.data = data;\n        this.range = params.vertices.qparams.computeRange();\n        this.surface = SurfaceGeometry.create(data, params.surface.indices);\n        const edges = params.edges;\n        if (!edges || data.type === SurfaceType.VolumeClassifier)\n            return;\n        if (edges.silhouettes)\n            this.silhouetteEdges = SilhouetteEdgeGeometry.createSilhouettes(data, edges.silhouettes);\n        if (edges.segments)\n            this.segmentEdges = EdgeGeometry.create(data, edges.segments);\n        if (edges.polylines)\n            this.polylineEdges = PolylineEdgeGeometry.create(data, edges.polylines);\n        if (edges.indexed)\n            this.indexedEdges = IndexedEdgeGeometry.create(data, edges.indexed);\n    }\n    static create(params, viewIndependentOrigin) {\n        const data = MeshData.create(params, viewIndependentOrigin);\n        return data ? new this(data, params) : undefined;\n    }\n    dispose() {\n        dispose(this.data);\n        dispose(this.surface);\n        dispose(this.segmentEdges);\n        dispose(this.silhouetteEdges);\n        dispose(this.polylineEdges);\n        dispose(this.indexedEdges);\n    }\n    collectStatistics(stats) {\n        this.data.collectStatistics(stats);\n        this.surface?.collectStatistics(stats);\n        this.segmentEdges?.collectStatistics(stats);\n        this.silhouetteEdges?.collectStatistics(stats);\n        this.polylineEdges?.collectStatistics(stats);\n        this.indexedEdges?.collectStatistics(stats);\n    }\n}\n/** @internal */\nexport class MeshGraphic extends Graphic {\n    static create(geometry, instances) {\n        let buffers;\n        if (instances) {\n            if (instances instanceof PatternBuffers) {\n                buffers = instances;\n            }\n            else {\n                const instancesRange = instances.range ?? InstanceBuffers.computeRange(geometry.range, instances.transforms, instances.transformCenter);\n                buffers = InstanceBuffers.create(instances, instancesRange);\n                if (!buffers)\n                    return undefined;\n            }\n        }\n        return new MeshGraphic(geometry, buffers);\n    }\n    addPrimitive(geometry) {\n        if (!geometry)\n            return;\n        assert(geometry instanceof CachedGeometry);\n        const primitive = Primitive.createShared(geometry, this._instances);\n        if (primitive)\n            this._primitives.push(primitive);\n    }\n    constructor(geometry, instances) {\n        super();\n        this._primitives = [];\n        this.meshData = geometry.data;\n        this._instances = instances;\n        this.addPrimitive(geometry.surface);\n        this.addPrimitive(geometry.segmentEdges);\n        this.addPrimitive(geometry.silhouetteEdges);\n        this.addPrimitive(geometry.polylineEdges);\n        this.addPrimitive(geometry.indexedEdges);\n    }\n    get isDisposed() { return this.meshData.isDisposed && 0 === this._primitives.length; }\n    get isPickable() { return false; }\n    dispose() {\n        for (const primitive of this._primitives)\n            dispose(primitive);\n        dispose(this.meshData);\n        dispose(this._instances);\n        this._primitives.length = 0;\n    }\n    collectStatistics(stats) {\n        this.meshData.collectStatistics(stats);\n        this._primitives.forEach((prim) => prim.collectStatistics(stats));\n        this._instances?.collectStatistics(stats);\n    }\n    addCommands(cmds) { this._primitives.forEach((prim) => prim.addCommands(cmds)); }\n    addHiliteCommands(cmds, pass) { this._primitives.forEach((prim) => prim.addHiliteCommands(cmds, pass)); }\n    get surfaceType() { return this.meshData.type; }\n}\n//# sourceMappingURL=Mesh.js.map",
      "start": 1693508124528,
      "end": 1693508124591,
      "sourcemaps": null
    }
  ]
}
