{
  "resolvedId": "D:/hub2023A/itwinjs-core/common/temp/node_modules/.pnpm/@loaders.gl+schema@3.4.7/node_modules/@loaders.gl/schema/dist/esm/lib/schema/impl/schema.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { assert } from '../../utils/assert';\nexport default class Schema {\n  constructor(fields, metadata) {\n    _defineProperty(this, \"fields\", void 0);\n    _defineProperty(this, \"metadata\", void 0);\n    assert(Array.isArray(fields));\n    checkNames(fields);\n    this.fields = fields;\n    this.metadata = metadata || new Map();\n  }\n  compareTo(other) {\n    if (this.metadata !== other.metadata) {\n      return false;\n    }\n    if (this.fields.length !== other.fields.length) {\n      return false;\n    }\n    for (let i = 0; i < this.fields.length; ++i) {\n      if (!this.fields[i].compareTo(other.fields[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  select() {\n    const nameMap = Object.create(null);\n    for (var _len = arguments.length, columnNames = new Array(_len), _key = 0; _key < _len; _key++) {\n      columnNames[_key] = arguments[_key];\n    }\n    for (const name of columnNames) {\n      nameMap[name] = true;\n    }\n    const selectedFields = this.fields.filter(field => nameMap[field.name]);\n    return new Schema(selectedFields, this.metadata);\n  }\n  selectAt() {\n    for (var _len2 = arguments.length, columnIndices = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      columnIndices[_key2] = arguments[_key2];\n    }\n    const selectedFields = columnIndices.map(index => this.fields[index]).filter(Boolean);\n    return new Schema(selectedFields, this.metadata);\n  }\n  assign(schemaOrFields) {\n    let fields;\n    let metadata = this.metadata;\n    if (schemaOrFields instanceof Schema) {\n      const otherSchema = schemaOrFields;\n      fields = otherSchema.fields;\n      metadata = mergeMaps(mergeMaps(new Map(), this.metadata), otherSchema.metadata);\n    } else {\n      fields = schemaOrFields;\n    }\n    const fieldMap = Object.create(null);\n    for (const field of this.fields) {\n      fieldMap[field.name] = field;\n    }\n    for (const field of fields) {\n      fieldMap[field.name] = field;\n    }\n    const mergedFields = Object.values(fieldMap);\n    return new Schema(mergedFields, metadata);\n  }\n}\nfunction checkNames(fields) {\n  const usedNames = {};\n  for (const field of fields) {\n    if (usedNames[field.name]) {\n      console.warn('Schema: duplicated field name', field.name, field);\n    }\n    usedNames[field.name] = true;\n  }\n}\nfunction mergeMaps(m1, m2) {\n  return new Map([...(m1 || new Map()), ...(m2 || new Map())]);\n}\n//# sourceMappingURL=schema.js.map",
      "start": 1693508127173,
      "end": 1693508127211,
      "sourcemaps": null
    }
  ]
}
