{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/clipping/BooleanClipNode.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\nimport { Range1d } from \"../geometry3d/Range\";\nimport { Range1dArray } from \"../numerics/Range1dArray\";\nimport { ClipStepAction, ClipUtilities } from \"./ClipUtils\";\n/** BooleanClipNode is an abstract base class for boolean actions by an array of clippers.\n * * Derived class must implement\n *   * The single point test `isPointOnOrInsideChildren`\n *   * Boolean operation on 1d intervals `combineIntervals`\n * * The `keepInside` flag controls an additional optional flip of the boolean result.\n *   * if `keepInside === true`, accept the \"inside\" of the clip clippers\n *   * if `keepInside === false`, accept the \"outside\" of the child clippers.\n * * Hence the combinations of derived classes for (OR, AND, XOR) and keepInside are\n *   * (OR, true) = simple union (OR), i.e. \"in\" one or more clips\n *   * (OR, false) = complement of union (NOR), i.e. \"outside\" all clips\n *   * (AND, true) = simple intersection (AND), i.e. \"in\" all clips\n *   * (AND, false) = complement of intersection (NAND), i.e. \"outside\" one or more clips\n *   * (XOR,true) = simple parity, i.e. \"in\" an odd number of clips\n *   * (XOR,false) = complement of parity ), i.e. \"in\" an even number of clips\n * @internal\n */\nexport class BooleanClipNode {\n    constructor(keepInside) {\n        this._keepInside = keepInside;\n        this._clippers = [];\n        this._intervalsA = [];\n        this._intervalsB = [];\n    }\n    toJSON() {\n        const data = [];\n        for (const c of this._clippers) {\n            const c1 = c;\n            if (c1.toJSON)\n                data.push(c1.toJSON());\n        }\n        // return this.formatJSON(data);\n        const s = this.operationName;\n        const json = {};\n        json[s] = data;\n        return json;\n    }\n    /** Capture a (reference to a) child node or nodes */\n    captureChild(child) {\n        if (Array.isArray(child)) {\n            for (const c of child)\n                this.captureChild(c);\n        }\n        else {\n            this._clippers.push(child);\n        }\n    }\n    /** Toggle the \"keepInside\" behavior.  Return the prior value.  */\n    toggleResult() {\n        return this.selectResult(!this._keepInside);\n    }\n    /** Set the \"keepInside\" behavior  */\n    selectResult(keepInside) {\n        const s = this._keepInside;\n        this._keepInside = keepInside;\n        return s;\n    }\n    /**\n     * Conditionally (if a1 > a0 strictly) call announce (a0, a1).\n     * * Return 0 if not called, 1 if called.\n     */\n    testedAnnounceNN(a0, a1, announce) {\n        if (a0 < a1) {\n            if (announce)\n                announce(a0, a1);\n            return 1;\n        }\n        return 0;\n    }\n    /**\n     * Conditionally (if a1 > a0 strictly) call announce (a0, a1, cp).\n     * * Return 0 if not called, 1 if called.\n     */\n    testedAnnounceNNC(a0, a1, cp, announce) {\n        if (a0 < a1) {\n            if (announce)\n                announce(a0, a1, cp);\n            return 1;\n        }\n        return 0;\n    }\n    /** Swap the _intervalsA and _intervalsB */\n    swapAB() {\n        const q = this._intervalsA;\n        this._intervalsA = this._intervalsB;\n        this._intervalsB = q;\n    }\n    /**\n     * Announce all \"outside intervals\" --not masked by intervals\n     * * Return true if any intervals announced.\n     */\n    announcePartsNN(keepInside, intervals, f0, f1, announce) {\n        let numAnnounce = 0;\n        if (!keepInside) {\n            let lowFraction = f0;\n            for (const interval of intervals) {\n                numAnnounce += this.testedAnnounceNN(lowFraction, interval.low, announce);\n                lowFraction = interval.high;\n            }\n            numAnnounce += this.testedAnnounceNN(lowFraction, f1, announce);\n        }\n        else {\n            for (const interval of intervals) {\n                // use f0..f1 ?\n                numAnnounce += this.testedAnnounceNN(interval.low, interval.high, announce);\n            }\n        }\n        return numAnnounce > 0;\n    }\n    /**\n     * Announce all \"outside intervals\" --not masked by intervals\n     * * Return true if any intervals announced.\n     */\n    announcePartsNNC(keepInside, intervals, f0, f1, cp, announce) {\n        let numAnnounce = 0;\n        if (!keepInside) {\n            let lowFraction = f0;\n            for (const interval of intervals) {\n                numAnnounce += this.testedAnnounceNNC(lowFraction, interval.low, cp, announce);\n                lowFraction = interval.high;\n            }\n            numAnnounce += this.testedAnnounceNNC(lowFraction, f1, cp, announce);\n        }\n        else {\n            for (const interval of intervals) {\n                // use f0..f1 ?\n                numAnnounce += this.testedAnnounceNNC(interval.low, interval.high, cp, announce);\n            }\n        }\n        return numAnnounce > 0;\n    }\n    /** Invoke callback to test if a point is \"in\" this clipper */\n    isPointOnOrInside(point) {\n        const q = this.isPointOnOrInsideChildren(point);\n        return this._keepInside ? q : !q;\n    }\n    /** Announce \"in\" portions of a line segment. See `Clipper.announceClippedSegmentIntervals` */\n    announceClippedSegmentIntervals(f0, f1, pointA, pointB, announce) {\n        this._intervalsA.length = 0;\n        const announceIntervalB = (a0, a1) => {\n            this._intervalsB.push(Range1d.createXX(a0, a1));\n        };\n        // Strategy:\n        //  _intervalsA is the accumulated UNION of from clippers\n        // _intervalsB is the current clipper.\n        // announceIntervalB appends single new interval to _intervalB\n        // at end, output gaps in _intervalsA\n        //\n        let i = 0;\n        for (const c of this._clippers) {\n            this._intervalsB.length = 0;\n            c.announceClippedSegmentIntervals(f0, f1, pointA, pointB, announceIntervalB);\n            Range1dArray.simplifySortUnion(this._intervalsB);\n            if (i === 0) {\n                this.swapAB();\n            }\n            else {\n                this._intervalsA = this.combineIntervals(this._intervalsA, this._intervalsB);\n            }\n            i++;\n        }\n        return this.announcePartsNN(this._keepInside, this._intervalsA, f0, f1, announce);\n    }\n    /** Announce \"in\" portions of a line segment.  See `Clipper.announceClippedSegmentIntervals` */\n    announceClippedArcIntervals(arc, announce) {\n        this._intervalsA.length = 0;\n        const announceIntervalB = (a0, a1) => {\n            this._intervalsB.push(Range1d.createXX(a0, a1));\n        };\n        let i = 0;\n        for (const c of this._clippers) {\n            this._intervalsB.length = 0;\n            c.announceClippedArcIntervals(arc, announceIntervalB);\n            Range1dArray.simplifySortUnion(this._intervalsB);\n            if (i === 0) {\n                this.swapAB();\n            }\n            else {\n                this._intervalsA = this.combineIntervals(this._intervalsA, this._intervalsB);\n            }\n            i++;\n        }\n        return this.announcePartsNNC(this._keepInside, this._intervalsA, 0, 1, arc, announce);\n    }\n}\n/**\n * Implement [BooleanClipNode] virtual methods for intersection (boolean OR) among children\n * @internal\n */\nexport class BooleanClipNodeUnion extends BooleanClipNode {\n    get operationName() { return this._keepInside ? \"OR\" : \"NOR\"; }\n    constructor(keepInside) {\n        super(keepInside);\n    }\n    /** Return true if inside any child clipper */\n    isPointOnOrInsideChildren(point) {\n        for (const clipper of this._clippers) {\n            if (clipper.isPointOnOrInside(point))\n                return true;\n        }\n        return false;\n    }\n    combineIntervals(operandA, operandB) {\n        return Range1dArray.unionSorted(operandA, operandB);\n    }\n    appendPolygonClip(xyz, insideFragments, outsideFragments, arrayCache) {\n        ClipUtilities.doPolygonClipSequence(xyz, this._clippers, this._keepInside ? insideFragments : outsideFragments, this._keepInside ? outsideFragments : insideFragments, undefined, ClipStepAction.acceptIn, ClipStepAction.passToNextStep, ClipStepAction.acceptOut, arrayCache);\n    }\n}\n/**\n * Implement [BooleanClipNode] virtual methods for intersection (boolean OR) among children\n * @internal\n */\nexport class BooleanClipNodeParity extends BooleanClipNode {\n    get operationName() { return this._keepInside ? \"XOR\" : \"NXOR\"; }\n    constructor(keepInside) {\n        super(keepInside);\n    }\n    /** Return true if inside an odd number of clippers child clipper */\n    isPointOnOrInsideChildren(point) {\n        let q = false;\n        for (const clipper of this._clippers) {\n            if (clipper.isPointOnOrInside(point))\n                q = !q;\n        }\n        return q;\n    }\n    combineIntervals(operandA, operandB) {\n        return Range1dArray.paritySorted(operandA, operandB);\n    }\n    appendPolygonClip(xyz, insideFragments, outsideFragments, arrayCache) {\n        ClipUtilities.doPolygonClipParitySequence(xyz, this._clippers, this._keepInside ? insideFragments : outsideFragments, this._keepInside ? outsideFragments : insideFragments, arrayCache);\n    }\n}\n/**\n * Implement [BooleanClipNode] virtual methods for intersection (boolean OR) among children\n * @internal\n */\nexport class BooleanClipNodeIntersection extends BooleanClipNode {\n    get operationName() { return this._keepInside ? \"AND\" : \"NAND\"; }\n    constructor(keepInside) {\n        super(keepInside);\n    }\n    /** Return false if outside of any child clipper */\n    isPointOnOrInsideChildren(point) {\n        for (const clipper of this._clippers) {\n            if (!clipper.isPointOnOrInside(point))\n                return false;\n        }\n        return true;\n    }\n    combineIntervals(operandA, operandB) {\n        return Range1dArray.intersectSorted(operandA, operandB);\n    }\n    appendPolygonClip(xyz, insideFragments, outsideFragments, arrayCache) {\n        ClipUtilities.doPolygonClipSequence(xyz, this._clippers, this._keepInside ? insideFragments : outsideFragments, this._keepInside ? outsideFragments : insideFragments, undefined, ClipStepAction.passToNextStep, ClipStepAction.acceptOut, ClipStepAction.acceptIn, arrayCache);\n    }\n}\n//# sourceMappingURL=BooleanClipNode.js.map",
      "start": 1693508125181,
      "end": 1693508125335,
      "sourcemaps": null
    }
  ]
}
