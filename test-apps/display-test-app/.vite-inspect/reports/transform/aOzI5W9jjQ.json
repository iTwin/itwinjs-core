{
  "resolvedId": "D:/hub2023A/itwinjs-core/editor/frontend/lib/esm/SolidModelingTools.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Editing\n */\nimport { DialogProperty, PropertyDescriptionHelper } from \"@itwin/appui-abstract\";\nimport { ColorDef, ElementGeometry } from \"@itwin/core-common\";\nimport { AccuDraw, AccuDrawHintBuilder, AngleDescription, EventHandled, GraphicType, IModelApp, LengthDescription, TentativeOrAccuSnap, } from \"@itwin/core-frontend\";\nimport { Angle, Geometry, LineString3d, Matrix3d, Point3d, Vector3d } from \"@itwin/core-geometry\";\nimport { BooleanMode, BRepEntityType, ChamferMode, CutDepthMode, CutDirectionMode, EmbossDirectionMode, ProfileClosure, SubEntityType, } from \"@itwin/editor-common\";\nimport { computeChordToleranceFromPoint } from \"./CreateElementTool\";\nimport { EditTools } from \"./EditTool\";\nimport { ElementGeometryCacheTool, isSameSubEntity, LocateSubEntityTool, SubEntityData } from \"./ElementGeometryTool\";\nimport { solidModelingIpc } from \"./EditToolIpc\";\n/** @alpha Base class for tools that perform boolean operations on a set of elements. */\nexport class BooleanOperationTool extends ElementGeometryCacheTool {\n    get allowSelectionSet() { return BooleanMode.Subtract !== this.mode; }\n    get allowDragSelect() { return BooleanMode.Subtract !== this.mode; }\n    get controlKeyContinuesSelection() { return true; }\n    get requiredElementCount() { return 2; }\n    get geometryCacheFilter() {\n        return { parts: true, curves: false, surfaces: BooleanMode.Subtract === this.mode && !this.agenda.isEmpty, solids: true, other: false };\n    }\n    async onAgendaModified() {\n        // Filter changes to allow surfaces as tools, invalidate cached accept status...\n        if (BooleanMode.Subtract === this.mode && (this.agenda.isEmpty || 1 === this.agenda.length))\n            this.onGeometryCacheFilterChanged();\n    }\n    async applyAgendaOperation() {\n        if (this.agenda.length < this.requiredElementCount)\n            return undefined;\n        try {\n            this._startedCmd = await this.startCommand();\n            const target = this.agenda.elements[0];\n            const tools = this.agenda.elements.slice(1);\n            const params = { mode: this.mode, tools };\n            const opts = { writeChanges: true };\n            return await solidModelingIpc.booleanOperation(target, params, opts);\n        }\n        catch (err) {\n            return undefined;\n        }\n    }\n    async processAgenda(_ev) {\n        const result = await this.applyAgendaOperation();\n        if (result?.elementId)\n            await this.saveChanges();\n    }\n}\n/** @alpha Perform boolean union of solid geometry. */\nclass UniteSolidElementsTool extends BooleanOperationTool {\n    get mode() { return BooleanMode.Unite; }\n    async onRestartTool() {\n        const tool = new UniteSolidElementsTool();\n        if (!await tool.run())\n            return this.exitTool();\n    }\n}\nUniteSolidElementsTool.toolId = \"UniteSolids\";\nUniteSolidElementsTool.iconSpec = \"icon-move\"; // TODO: Need better icon...\nexport { UniteSolidElementsTool };\n/** @alpha Perform boolean subtract of solid geometry. */\nclass SubtractSolidElementsTool extends BooleanOperationTool {\n    get mode() { return BooleanMode.Subtract; }\n    async onRestartTool() {\n        const tool = new SubtractSolidElementsTool();\n        if (!await tool.run())\n            return this.exitTool();\n    }\n}\nSubtractSolidElementsTool.toolId = \"SubtractSolids\";\nSubtractSolidElementsTool.iconSpec = \"icon-move\"; // TODO: Need better icon...\nexport { SubtractSolidElementsTool };\n/** @alpha Perform boolean intersection of solid geometry. */\nclass IntersectSolidElementsTool extends BooleanOperationTool {\n    get mode() { return BooleanMode.Intersect; }\n    async onRestartTool() {\n        const tool = new IntersectSolidElementsTool();\n        if (!await tool.run())\n            return this.exitTool();\n    }\n}\nIntersectSolidElementsTool.toolId = \"IntersectSolids\";\nIntersectSolidElementsTool.iconSpec = \"icon-move\"; // TODO: Need better icon...\nexport { IntersectSolidElementsTool };\n/** @alpha Perform sew operation on surface geometry. */\nclass SewSheetElementsTool extends ElementGeometryCacheTool {\n    get allowSelectionSet() { return true; }\n    get allowDragSelect() { return true; }\n    get controlKeyContinuesSelection() { return true; }\n    get requiredElementCount() { return 2; }\n    get geometryCacheFilter() {\n        return { parts: true, curves: false, surfaces: true, solids: false, other: false };\n    }\n    async applyAgendaOperation() {\n        if (this.agenda.length < this.requiredElementCount)\n            return undefined;\n        try {\n            this._startedCmd = await this.startCommand();\n            const target = this.agenda.elements[0];\n            const tools = this.agenda.elements.slice(1);\n            const params = { tools };\n            const opts = { writeChanges: true };\n            return await solidModelingIpc.sewSheets(target, params, opts);\n        }\n        catch (err) {\n            return undefined;\n        }\n    }\n    async processAgenda(_ev) {\n        const result = await this.applyAgendaOperation();\n        if (result?.elementId)\n            await this.saveChanges();\n    }\n    async onRestartTool() {\n        const tool = new SewSheetElementsTool();\n        if (!await tool.run())\n            return this.exitTool();\n    }\n}\nSewSheetElementsTool.toolId = \"SewSheets\";\nSewSheetElementsTool.iconSpec = \"icon-move\"; // TODO: Need better icon...\nexport { SewSheetElementsTool };\n/** @alpha Perform thicken operation on surface geometry. */\nclass ThickenSheetElementsTool extends ElementGeometryCacheTool {\n    get frontDistanceProperty() {\n        if (!this._frontDistanceProperty)\n            this._frontDistanceProperty = new DialogProperty(new LengthDescription(\"thickenFront\", EditTools.translate(\"ThickenSheets.Label.FrontDistance\")), 0.1, undefined);\n        return this._frontDistanceProperty;\n    }\n    get frontDistance() { return this.frontDistanceProperty.value; }\n    set frontDistance(value) { this.frontDistanceProperty.value = value; }\n    get backDistanceProperty() {\n        if (!this._backDistanceProperty)\n            this._backDistanceProperty = new DialogProperty(new LengthDescription(\"thickenBack\", EditTools.translate(\"ThickenSheets.Label.BackDistance\")), 0.0, undefined);\n        return this._backDistanceProperty;\n    }\n    get backDistance() { return this.backDistanceProperty.value; }\n    set backDistance(value) { this.backDistanceProperty.value = value; }\n    get geometryCacheFilter() {\n        return { parts: true, curves: false, surfaces: true, solids: false, other: false };\n    }\n    async applyAgendaOperation() {\n        if (this.agenda.length < this.requiredElementCount)\n            return undefined;\n        try {\n            this._startedCmd = await this.startCommand();\n            const target = this.agenda.elements[0];\n            const params = { front: this.frontDistance, back: this.backDistance };\n            const opts = { writeChanges: true };\n            return await solidModelingIpc.thickenSheets(target, params, opts);\n        }\n        catch (err) {\n            return undefined;\n        }\n    }\n    async processAgenda(_ev) {\n        const result = await this.applyAgendaOperation();\n        if (result?.elementId)\n            await this.saveChanges();\n    }\n    async applyToolSettingPropertyChange(updatedValue) {\n        return this.changeToolSettingPropertyValue(updatedValue);\n    }\n    supplyToolSettingsProperties() {\n        this.initializeToolSettingPropertyValues([this.frontDistanceProperty, this.backDistanceProperty]);\n        const toolSettings = new Array();\n        toolSettings.push(this.frontDistanceProperty.toDialogItem({ rowPriority: 1, columnIndex: 0 }));\n        toolSettings.push(this.backDistanceProperty.toDialogItem({ rowPriority: 2, columnIndex: 0 }));\n        return toolSettings;\n    }\n    async onRestartTool() {\n        const tool = new ThickenSheetElementsTool();\n        if (!await tool.run())\n            return this.exitTool();\n    }\n}\nThickenSheetElementsTool.toolId = \"ThickenSheets\";\nThickenSheetElementsTool.iconSpec = \"icon-move\"; // TODO: Need better icon...\nexport { ThickenSheetElementsTool };\n/** @alpha Perform cut operation on solid using region or path profile. */\nclass CutSolidElementsTool extends ElementGeometryCacheTool {\n    get bothDirectionsProperty() {\n        if (!this._bothDirectionsProperty)\n            this._bothDirectionsProperty = new DialogProperty(PropertyDescriptionHelper.buildToggleDescription(\"cutBothDirections\", EditTools.translate(\"CutSolids.Label.BothDirections\")), false);\n        return this._bothDirectionsProperty;\n    }\n    get bothDirections() { return this.bothDirectionsProperty.value; }\n    set bothDirections(value) { this.bothDirectionsProperty.value = value; }\n    get outsideProperty() {\n        if (!this._outsideProperty)\n            this._outsideProperty = new DialogProperty(PropertyDescriptionHelper.buildToggleDescription(\"cutOutside\", EditTools.translate(\"CutSolids.Label.Outside\")), false);\n        return this._outsideProperty;\n    }\n    get outside() { return this.outsideProperty.value; }\n    set outside(value) { this.outsideProperty.value = value; }\n    get useDepthProperty() {\n        if (!this._useDepthProperty)\n            this._useDepthProperty = new DialogProperty(PropertyDescriptionHelper.buildLockPropertyDescription(\"useCutDepth\"), false);\n        return this._useDepthProperty;\n    }\n    get useDepth() { return this.useDepthProperty.value; }\n    set useDepth(value) { this.useDepthProperty.value = value; }\n    get depthProperty() {\n        if (!this._depthProperty)\n            this._depthProperty = new DialogProperty(new LengthDescription(\"cutDepth\", EditTools.translate(\"CutSolids.Label.Depth\")), 0.1, undefined, !this.useDepth);\n        return this._depthProperty;\n    }\n    get depth() { return this.depthProperty.value; }\n    set depth(value) { this.depthProperty.value = value; }\n    get requiredElementCount() { return 2; }\n    get isProfilePhase() { return !this.agenda.isEmpty; }\n    get geometryCacheFilter() {\n        const profilePhase = this.isProfilePhase;\n        return { minGeom: 1, maxGeom: profilePhase ? 1 : undefined, parts: true, curves: profilePhase, surfaces: profilePhase, solids: !profilePhase, other: false };\n    }\n    async createElementGeometryCache(id) {\n        if (!await super.createElementGeometryCache(id))\n            return false;\n        if (!this.isProfilePhase)\n            return true;\n        try {\n            this._startedCmd = await this.startCommand();\n            return await solidModelingIpc.isPlanarBody(id, 0);\n        }\n        catch (err) {\n            return false;\n        }\n    }\n    async onAgendaModified() {\n        // Filter changes to allow sheets and wires as profiles, invalidate cached accept status...\n        if (this.agenda.isEmpty || 1 === this.agenda.length)\n            this.onGeometryCacheFilterChanged();\n    }\n    async applyAgendaOperation() {\n        if (this.agenda.length < this.requiredElementCount)\n            return undefined;\n        const direction = (this.bothDirections ? CutDirectionMode.Both : CutDirectionMode.Auto);\n        const depth = (this.useDepth ? CutDepthMode.Blind : CutDepthMode.All);\n        try {\n            this._startedCmd = await this.startCommand();\n            const target = this.agenda.elements[0];\n            const profile = this.agenda.elements[1];\n            const params = { profile, direction, depth, distance: this.depth, outside: this.outside ? true : undefined, closeOpen: ProfileClosure.Auto, targetPoint: this.targetPoint, toolPoint: this.toolPoint };\n            const opts = { writeChanges: true };\n            return await solidModelingIpc.cutSolid(target, params, opts);\n        }\n        catch (err) {\n            return undefined;\n        }\n    }\n    async processAgenda(_ev) {\n        const result = await this.applyAgendaOperation();\n        if (result?.elementId)\n            await this.saveChanges();\n    }\n    async buildLocateAgenda(hit) {\n        if (this.isProfilePhase)\n            this.toolPoint = hit.hitPoint;\n        else\n            this.targetPoint = hit.hitPoint;\n        return super.buildLocateAgenda(hit);\n    }\n    getToolSettingPropertyLocked(property) {\n        return (property === this.useDepthProperty ? this.depthProperty : undefined);\n    }\n    async applyToolSettingPropertyChange(updatedValue) {\n        return this.changeToolSettingPropertyValue(updatedValue);\n    }\n    supplyToolSettingsProperties() {\n        this.initializeToolSettingPropertyValues([this.bothDirectionsProperty, this.outsideProperty, this.useDepthProperty, this.depthProperty]);\n        const toolSettings = new Array();\n        toolSettings.push(this.bothDirectionsProperty.toDialogItem({ rowPriority: 1, columnIndex: 0 }));\n        toolSettings.push(this.outsideProperty.toDialogItem({ rowPriority: 2, columnIndex: 0 }));\n        // ensure controls are enabled/disabled based on current lock property state\n        this.depthProperty.isDisabled = !this.useDepth;\n        const useDepthLock = this.useDepthProperty.toDialogItem({ rowPriority: 3, columnIndex: 0 });\n        toolSettings.push(this.depthProperty.toDialogItem({ rowPriority: 3, columnIndex: 1 }, useDepthLock));\n        return toolSettings;\n    }\n    async onRestartTool() {\n        const tool = new CutSolidElementsTool();\n        if (!await tool.run())\n            return this.exitTool();\n    }\n}\nCutSolidElementsTool.toolId = \"CutSolids\";\nCutSolidElementsTool.iconSpec = \"icon-move\"; // TODO: Need better icon...\nexport { CutSolidElementsTool };\n/** @alpha Perform emboss operation on solid or sheet using sheet profile. */\nclass EmbossSolidElementsTool extends ElementGeometryCacheTool {\n    get requiredElementCount() { return 2; }\n    get isProfilePhase() { return !this.agenda.isEmpty; }\n    get geometryCacheFilter() {\n        const profilePhase = this.isProfilePhase;\n        return { minGeom: 1, maxGeom: 1, parts: true, curves: false, surfaces: true, solids: !profilePhase, other: false };\n    }\n    async onAgendaModified() {\n        // Filter changes to disallow solids as profiles, invalidate cached accept status...\n        if (this.agenda.isEmpty || 1 === this.agenda.length)\n            this.onGeometryCacheFilterChanged();\n    }\n    async applyAgendaOperation() {\n        if (this.agenda.length < this.requiredElementCount)\n            return undefined;\n        try {\n            this._startedCmd = await this.startCommand();\n            const target = this.agenda.elements[0];\n            const profile = this.agenda.elements[1];\n            const params = { profile, direction: EmbossDirectionMode.Auto, targetPoint: this.targetPoint };\n            const opts = { writeChanges: true };\n            return await solidModelingIpc.embossBody(target, params, opts);\n        }\n        catch (err) {\n            return undefined;\n        }\n    }\n    async processAgenda(_ev) {\n        const result = await this.applyAgendaOperation();\n        if (result?.elementId)\n            await this.saveChanges();\n    }\n    async buildLocateAgenda(hit) {\n        if (!this.isProfilePhase)\n            this.targetPoint = hit.hitPoint;\n        return super.buildLocateAgenda(hit);\n    }\n    async onRestartTool() {\n        const tool = new EmbossSolidElementsTool();\n        if (!await tool.run())\n            return this.exitTool();\n    }\n}\nEmbossSolidElementsTool.toolId = \"EmbossSolids\";\nEmbossSolidElementsTool.iconSpec = \"icon-move\"; // TODO: Need better icon...\nexport { EmbossSolidElementsTool };\n/** @alpha Create a solid for sheet by sweeping a profile along a path. */\nclass SweepAlongPathTool extends ElementGeometryCacheTool {\n    get requiredElementCount() { return 2; }\n    get geometryCacheFilter() {\n        return { minGeom: 1, maxGeom: 1, parts: true, curves: true, surfaces: true, solids: false, other: false };\n    }\n    async applyAgendaOperation() {\n        if (this.agenda.length < this.requiredElementCount)\n            return undefined;\n        try {\n            this._startedCmd = await this.startCommand();\n            const target = this.agenda.elements[0];\n            const path = this.agenda.elements[1];\n            const params = { path };\n            const opts = { writeChanges: true };\n            return await solidModelingIpc.sweepAlongPath(target, params, opts);\n        }\n        catch (err) {\n            return undefined;\n        }\n    }\n    async processAgenda(_ev) {\n        const result = await this.applyAgendaOperation();\n        if (result?.elementId)\n            await this.saveChanges();\n    }\n    async onRestartTool() {\n        const tool = new SweepAlongPathTool();\n        if (!await tool.run())\n            return this.exitTool();\n    }\n}\nSweepAlongPathTool.toolId = \"SweepAlongPath\";\nSweepAlongPathTool.iconSpec = \"icon-move\"; // TODO: Need better icon...\nexport { SweepAlongPathTool };\n/** @alpha Create a new sheet or solid body by lofting through a set of profiles. */\nclass LoftProfilesTool extends ElementGeometryCacheTool {\n    get requiredElementCount() { return 2; }\n    get controlKeyContinuesSelection() { return true; }\n    get geometryCacheFilter() {\n        return { minGeom: 1, maxGeom: 1, parts: true, curves: true, surfaces: true, solids: false, other: false };\n    }\n    async applyAgendaOperation() {\n        if (this.agenda.length < this.requiredElementCount)\n            return undefined;\n        try {\n            this._startedCmd = await this.startCommand();\n            const target = this.agenda.elements[0];\n            const tools = this.agenda.elements.slice(1);\n            const params = { tools, orderCurves: this.isSelectionSetModify ? true : undefined, orientCurves: true };\n            const opts = { writeChanges: true };\n            return await solidModelingIpc.loftProfiles(target, params, opts);\n        }\n        catch (err) {\n            return undefined;\n        }\n    }\n    async processAgenda(_ev) {\n        const result = await this.applyAgendaOperation();\n        if (result?.elementId)\n            await this.saveChanges();\n    }\n    async onRestartTool() {\n        const tool = new LoftProfilesTool();\n        if (!await tool.run())\n            return this.exitTool();\n    }\n}\nLoftProfilesTool.toolId = \"LoftProfiles\";\nLoftProfilesTool.iconSpec = \"icon-move\"; // TODO: Need better icon...\nexport { LoftProfilesTool };\n/** @alpha */\nexport class FaceLocationData {\n    constructor(point, normal) {\n        this.point = point;\n        this.normal = normal;\n    }\n    static create(pointProps, normalProps) {\n        const point = Point3d.fromJSON(pointProps);\n        const normal = Vector3d.fromJSON(normalProps);\n        return new FaceLocationData(point, normal);\n    }\n}\n/** @alpha Identify faces of solids and surfaces to offset. */\nclass OffsetFacesTool extends LocateSubEntityTool {\n    get addSmoothProperty() {\n        if (!this._addSmoothProperty)\n            this._addSmoothProperty = new DialogProperty(PropertyDescriptionHelper.buildToggleDescription(\"offsetSmooth\", EditTools.translate(\"OffsetFaces.Label.AddSmooth\")), false);\n        return this._addSmoothProperty;\n    }\n    get addSmooth() { return this.addSmoothProperty.value; }\n    set addSmooth(value) { this.addSmoothProperty.value = value; }\n    get useDistanceProperty() {\n        if (!this._useDistanceProperty)\n            this._useDistanceProperty = new DialogProperty(PropertyDescriptionHelper.buildLockPropertyDescription(\"useOffsetDistance\"), false);\n        return this._useDistanceProperty;\n    }\n    get useDistance() { return this.useDistanceProperty.value; }\n    set useDistance(value) { this.useDistanceProperty.value = value; }\n    get distanceProperty() {\n        if (!this._distanceProperty)\n            this._distanceProperty = new DialogProperty(new LengthDescription(\"offsetDistance\", EditTools.translate(\"OffsetFaces.Label.Distance\")), 0.1, undefined, !this.useDistance);\n        return this._distanceProperty;\n    }\n    get distance() { return this.distanceProperty.value; }\n    set distance(value) { this.distanceProperty.value = value; }\n    get wantDynamics() { return true; }\n    get wantAccuSnap() { return this.isDynamicsStarted; }\n    get geometryCacheFilter() {\n        return { parts: true, curves: false, surfaces: true, solids: true, other: false };\n    }\n    async createSubEntityData(id, hit) {\n        const data = await super.createSubEntityData(id, hit);\n        if (undefined !== hit.point && undefined !== hit.normal)\n            data.toolData = FaceLocationData.create(hit.point, hit.normal);\n        return data;\n    }\n    drawAcceptedSubEntities(context) {\n        super.drawAcceptedSubEntities(context);\n        // Show pick point on last identified face, offset direction/distance will be computed from this location...\n        const faceData = this.getAcceptedSubEntityData()?.toolData;\n        if (undefined === faceData)\n            return;\n        const builder = context.createGraphic({ type: GraphicType.WorldOverlay });\n        builder.setSymbology(context.viewport.getContrastToBackgroundColor(), ColorDef.black, 10);\n        builder.addPointString([faceData.point]);\n        context.addDecorationFromBuilder(builder);\n    }\n    async getSmoothFaces(id, face) {\n        try {\n            // NOTE: For offset, include all smoothly connected faces, not just adjacent...\n            return await solidModelingIpc.getConnectedSubEntities(id, face, SubEntityType.Face, { smoothFaces: true });\n        }\n        catch (err) {\n            return undefined;\n        }\n    }\n    async applyAgendaOperation(ev, isAccept) {\n        if (undefined === ev.viewport || this.agenda.isEmpty || !this.haveAcceptedSubEntities)\n            return undefined;\n        const faceData = this.getAcceptedSubEntityData()?.toolData;\n        if (undefined === faceData)\n            return undefined;\n        const projPt = AccuDrawHintBuilder.projectPointToLineInView(ev.point, faceData.point, faceData.normal, ev.viewport);\n        if (undefined === projPt)\n            return undefined;\n        const offsetDir = Vector3d.createStartEnd(faceData.point, projPt);\n        if (this.useDistance && undefined === offsetDir.scaleToLength(this.distance, offsetDir))\n            return undefined;\n        let offset = offsetDir.magnitude();\n        if (offset < Geometry.smallMetricDistance)\n            return undefined;\n        if (offsetDir.dotProduct(faceData.normal) < 0.0)\n            offset = -offset;\n        if (!this.useDistance) {\n            this.distance = offset;\n            this.syncToolSettingPropertyValue(this.distanceProperty);\n            if (isAccept)\n                this.saveToolSettingPropertyValue(this.distanceProperty, this.distanceProperty.dialogItemValue);\n        }\n        try {\n            this._startedCmd = await this.startCommand();\n            const id = this.agenda.elements[0];\n            const faces = this.getAcceptedSubEntities();\n            if (this.addSmooth) {\n                const allSmoothFaces = [];\n                for (const face of faces) {\n                    const smoothFaces = await this.getSmoothFaces(id, face);\n                    if (undefined !== smoothFaces)\n                        allSmoothFaces.push(...smoothFaces);\n                }\n                for (const smooth of allSmoothFaces) {\n                    if (undefined === faces.find((selected) => isSameSubEntity(selected, smooth)))\n                        faces.unshift(smooth); // Preserve last selected entry as reference face...\n                }\n            }\n            const params = { faces, distances: offset };\n            const opts = {\n                wantGraphic: isAccept ? undefined : true,\n                chordTolerance: computeChordToleranceFromPoint(ev.viewport, ev.point),\n                requestId: `${this.toolId}:${id}`,\n                writeChanges: isAccept ? true : undefined,\n            };\n            return await solidModelingIpc.offsetFaces(id, params, opts);\n        }\n        catch (err) {\n            return undefined;\n        }\n    }\n    setupAccuDraw() {\n        if (!this.haveAcceptedSubEntities)\n            return;\n        const faceData = this.getAcceptedSubEntityData()?.toolData;\n        if (undefined === faceData)\n            return;\n        const hints = new AccuDrawHintBuilder();\n        hints.setOriginFixed = true;\n        hints.setLockY = true;\n        hints.setLockZ = true;\n        hints.setModeRectangular();\n        hints.setOrigin(faceData.point);\n        hints.setXAxis2(faceData.normal);\n        hints.sendHints(false);\n    }\n    getToolSettingPropertyLocked(property) {\n        return (property === this.useDistanceProperty ? this.distanceProperty : undefined);\n    }\n    async applyToolSettingPropertyChange(updatedValue) {\n        return this.changeToolSettingPropertyValue(updatedValue);\n    }\n    supplyToolSettingsProperties() {\n        this.initializeToolSettingPropertyValues([this.addSmoothProperty, this.useDistanceProperty, this.distanceProperty]);\n        const toolSettings = new Array();\n        // ensure controls are enabled/disabled based on current lock property state\n        this.distanceProperty.isDisabled = !this.useDistance;\n        const useDistanceLock = this.useDistanceProperty.toDialogItem({ rowPriority: 1, columnIndex: 0 });\n        toolSettings.push(this.distanceProperty.toDialogItem({ rowPriority: 1, columnIndex: 1 }, useDistanceLock));\n        toolSettings.push(this.addSmoothProperty.toDialogItem({ rowPriority: 2, columnIndex: 0 }));\n        return toolSettings;\n    }\n    async onRestartTool() {\n        const tool = new OffsetFacesTool();\n        if (!await tool.run())\n            return this.exitTool();\n    }\n}\nOffsetFacesTool.toolId = \"OffsetFaces\";\nOffsetFacesTool.iconSpec = \"icon-move\"; // TODO: Need better icon...\nexport { OffsetFacesTool };\n/** @alpha Identify faces to offset to hollow solids. */\nclass HollowFacesTool extends LocateSubEntityTool {\n    get shellThicknessProperty() {\n        if (!this._shellThicknessProperty)\n            this._shellThicknessProperty = new DialogProperty(new LengthDescription(\"hollowShellThickness\", EditTools.translate(\"HollowFaces.Label.ShellThickness\")), 0.1, undefined);\n        return this._shellThicknessProperty;\n    }\n    get shellThickness() { return this.shellThicknessProperty.value; }\n    set shellThickness(value) { this.shellThicknessProperty.value = value; }\n    get faceThicknessProperty() {\n        if (!this._faceThicknessProperty)\n            this._faceThicknessProperty = new DialogProperty(new LengthDescription(\"hollowFaceThickness\", EditTools.translate(\"HollowFaces.Label.FaceThickness\")), 0.0, undefined);\n        return this._faceThicknessProperty;\n    }\n    get faceThickness() { return this.faceThicknessProperty.value; }\n    set faceThickness(value) { this.faceThicknessProperty.value = value; }\n    get geometryCacheFilter() {\n        return { parts: true, curves: false, surfaces: false, solids: true, other: false };\n    }\n    async applyAgendaOperation(ev, isAccept) {\n        if (undefined === ev.viewport || this.agenda.isEmpty || !this.haveAcceptedSubEntities)\n            return undefined;\n        try {\n            this._startedCmd = await this.startCommand();\n            const params = { faces: this.getAcceptedSubEntities(), distances: this.faceThickness, defaultDistance: this.shellThickness };\n            const opts = {\n                wantGraphic: isAccept ? undefined : true,\n                chordTolerance: computeChordToleranceFromPoint(ev.viewport, ev.point),\n                requestId: `${this.toolId}:${this.agenda.elements[0]}`,\n                writeChanges: isAccept ? true : undefined,\n            };\n            return await solidModelingIpc.hollowFaces(this.agenda.elements[0], params, opts);\n        }\n        catch (err) {\n            return undefined;\n        }\n    }\n    async applyToolSettingPropertyChange(updatedValue) {\n        return this.changeToolSettingPropertyValue(updatedValue);\n    }\n    supplyToolSettingsProperties() {\n        this.initializeToolSettingPropertyValues([this.shellThicknessProperty, this.faceThicknessProperty]);\n        const toolSettings = new Array();\n        toolSettings.push(this.shellThicknessProperty.toDialogItem({ rowPriority: 1, columnIndex: 0 }));\n        toolSettings.push(this.faceThicknessProperty.toDialogItem({ rowPriority: 2, columnIndex: 0 }));\n        return toolSettings;\n    }\n    async onRestartTool() {\n        const tool = new HollowFacesTool();\n        if (!await tool.run())\n            return this.exitTool();\n    }\n}\nHollowFacesTool.toolId = \"HollowFaces\";\nHollowFacesTool.iconSpec = \"icon-move\"; // TODO: Need better icon...\nexport { HollowFacesTool };\n/** @alpha Identify faces or edges for removal by growing surrounding faces. */\nclass DeleteSubEntitiesTool extends LocateSubEntityTool {\n    wantSubEntityType(type) {\n        switch (type) {\n            case SubEntityType.Face:\n            case SubEntityType.Edge:\n                // Choose all faces or all edges...\n                return (0 === this._acceptedSubEntities.length || this._acceptedSubEntities[0].props.type === type);\n            default:\n                return false;\n        }\n    }\n    getMaximumSubEntityHits(type) {\n        if (!this.wantSubEntityType(type))\n            return 0;\n        // Only return single closest edge, avoids having to test for redundant edges on reset...\n        return (SubEntityType.Edge === type ? 1 : 25);\n    }\n    get geometryCacheFilter() {\n        return { parts: true, curves: false, surfaces: true, solids: true, other: false };\n    }\n    async doPickSubEntities(id, ev) {\n        const hits = await super.doPickSubEntities(id, ev);\n        if (undefined === hits)\n            return hits;\n        // Don't allow reset to select a back edge...\n        if (SubEntityType.Face === hits[0].subEntity.type)\n            return hits.filter((hit) => { return SubEntityType.Face === hit.subEntity.type; });\n        try {\n            const accept = await solidModelingIpc.isRedundantEdge(id, hits[0].subEntity);\n            if (accept)\n                return hits;\n            if (hits.length > 1 && SubEntityType.Face === hits[1].subEntity.type)\n                return hits.slice(1); // Accept face of rejected edge...\n            return undefined;\n        }\n        catch (err) {\n            return undefined;\n        }\n    }\n    async applyAgendaOperation(ev, isAccept) {\n        if (undefined === ev.viewport || this.agenda.isEmpty || !this.haveAcceptedSubEntities)\n            return undefined;\n        try {\n            this._startedCmd = await this.startCommand();\n            const params = { subEntities: this.getAcceptedSubEntities() };\n            const opts = {\n                wantGraphic: isAccept ? undefined : true,\n                chordTolerance: computeChordToleranceFromPoint(ev.viewport, ev.point),\n                requestId: `${this.toolId}:${this.agenda.elements[0]}`,\n                writeChanges: isAccept ? true : undefined,\n            };\n            return await solidModelingIpc.deleteSubEntities(this.agenda.elements[0], params, opts);\n        }\n        catch (err) {\n            return undefined;\n        }\n    }\n    async onRestartTool() {\n        const tool = new DeleteSubEntitiesTool();\n        if (!await tool.run())\n            return this.exitTool();\n    }\n}\nDeleteSubEntitiesTool.toolId = \"DeleteSubEntities\";\nDeleteSubEntitiesTool.iconSpec = \"icon-move\"; // TODO: Need better icon...\nexport { DeleteSubEntitiesTool };\n/** @alpha */\nexport var ImprintSolidMethod;\n(function (ImprintSolidMethod) {\n    /** Imprint intersection with another element */\n    ImprintSolidMethod[ImprintSolidMethod[\"Element\"] = 0] = \"Element\";\n    /** Imprint offset edges onto face */\n    ImprintSolidMethod[ImprintSolidMethod[\"Edges\"] = 1] = \"Edges\";\n    /** Imprint line string defined by points onto face */\n    ImprintSolidMethod[ImprintSolidMethod[\"Points\"] = 2] = \"Points\";\n})(ImprintSolidMethod || (ImprintSolidMethod = {}));\n/** @alpha Identify edges or elements to imprint on solid or surface. */\nclass ImprintSolidElementsTool extends LocateSubEntityTool {\n    constructor() {\n        super(...arguments);\n        this.points = [];\n    }\n    static methodMessage(str) { return EditTools.translate(`ImprintSolids.Method.${str}`); }\n    get methodProperty() {\n        if (!this._methodProperty)\n            this._methodProperty = new DialogProperty(PropertyDescriptionHelper.buildEnumPicklistEditorDescription(\"imprintMethod\", EditTools.translate(\"ImprintSolids.Label.Method\"), ImprintSolidElementsTool.getMethodChoices()), ImprintSolidMethod.Element);\n        return this._methodProperty;\n    }\n    get method() { return this.methodProperty.value; }\n    set method(method) { this.methodProperty.value = method; }\n    get distanceProperty() {\n        if (!this._distanceProperty)\n            this._distanceProperty = new DialogProperty(new LengthDescription(\"imprintDistance\", EditTools.translate(\"ImprintSolids.Label.Distance\")), 0.1, undefined);\n        return this._distanceProperty;\n    }\n    get distance() { return this.distanceProperty.value; }\n    set distance(value) { this.distanceProperty.value = value; }\n    get extendProperty() {\n        if (!this._extendProperty)\n            this._extendProperty = new DialogProperty(PropertyDescriptionHelper.buildToggleDescription(\"imprintExtend\", EditTools.translate(\"ImprintSolids.Label.Extend\")), false);\n        return this._extendProperty;\n    }\n    get extend() { return this.extendProperty.value; }\n    set extend(value) { this.extendProperty.value = value; }\n    get requiredSubEntityCount() { return ImprintSolidMethod.Element === this.method ? 0 : 1; }\n    get requiredElementCount() { return ImprintSolidMethod.Element === this.method ? 2 : 1; }\n    get allowSubEntityControlSelect() { return ImprintSolidMethod.Edges === this.method; }\n    get inhibitSubEntityDisplay() { return ImprintSolidMethod.Points === this.method ? false : super.inhibitSubEntityDisplay; }\n    wantSubEntityType(type) {\n        switch (type) {\n            case SubEntityType.Face:\n                return ImprintSolidMethod.Points === this.method;\n            case SubEntityType.Edge:\n                return ImprintSolidMethod.Edges === this.method;\n            default:\n                return false;\n        }\n    }\n    get wantDynamics() { return ImprintSolidMethod.Points === this.method; }\n    get wantAccuSnap() { return ImprintSolidMethod.Points === this.method && this.isDynamicsStarted; }\n    get geometryCacheFilter() {\n        return { parts: true, curves: !this.agenda.isEmpty, surfaces: true, solids: true, other: false };\n    }\n    async onAgendaModified() {\n        // Filter changes to allow imprinting an open path, invalidate cached accept status...\n        if (ImprintSolidMethod.Element === this.method && (this.agenda.isEmpty || 1 === this.agenda.length))\n            this.onGeometryCacheFilterChanged();\n    }\n    async createSubEntityData(id, hit) {\n        const data = await super.createSubEntityData(id, hit);\n        if (undefined !== hit.point && undefined !== hit.normal)\n            data.toolData = FaceLocationData.create(hit.point, hit.normal);\n        return data;\n    }\n    async applyAgendaOperation(_ev, isAccept) {\n        if (!isAccept || this.agenda.length < this.requiredElementCount)\n            return undefined;\n        const id = this.agenda.elements[0];\n        try {\n            this._startedCmd = await this.startCommand();\n            let params;\n            if (ImprintSolidMethod.Points === this.method) {\n                if (!this.haveAcceptedSubEntities)\n                    return undefined;\n                const geom = ElementGeometry.fromGeometryQuery(LineString3d.create(this.points));\n                if (undefined === geom)\n                    return undefined;\n                params = { imprint: geom, face: this.getAcceptedSubEntityData(0)?.props, extend: this.extend ? true : undefined };\n            }\n            else if (ImprintSolidMethod.Edges === this.method) {\n                if (!this.haveAcceptedSubEntities)\n                    return undefined;\n                // TODO: Include all accepted edges...\n                const edge = this.getAcceptedSubEntityData(0)?.props;\n                if (undefined === edge)\n                    return undefined;\n                const edgeFaces = await solidModelingIpc.getConnectedSubEntities(id, edge, SubEntityType.Face);\n                if (undefined === edgeFaces || 0 === edgeFaces.length)\n                    return undefined;\n                // TODO: Check planar face...get preferred face from cursor location in dynamics, etc.\n                const edgeLoop = await solidModelingIpc.getConnectedSubEntities(id, edge, SubEntityType.Edge, { loopFace: edgeFaces[0] });\n                if (undefined === edgeLoop || 0 === edgeLoop.length)\n                    return undefined;\n                params = { imprint: edgeLoop, face: edgeFaces[0], distance: this.distance, extend: this.extend ? true : undefined };\n            }\n            else {\n                params = { imprint: this.agenda.elements[1], extend: this.extend ? true : undefined };\n            }\n            const opts = { writeChanges: true };\n            return await solidModelingIpc.imprintBody(id, params, opts);\n        }\n        catch (err) {\n            return undefined;\n        }\n    }\n    onDynamicFrame(ev, context) {\n        if (ImprintSolidMethod.Points !== this.method || 0 === this.points.length)\n            return;\n        const pts = this.points.slice();\n        pts.push(ev.point.clone());\n        const builder = context.createGraphic({ type: GraphicType.WorldOverlay });\n        builder.setSymbology(context.viewport.getContrastToBackgroundColor(), ColorDef.black, 3);\n        builder.addLineString(pts);\n        context.addGraphic(builder.finish());\n    }\n    async gatherInput(ev) {\n        switch (this.method) {\n            case ImprintSolidMethod.Points: {\n                if (!this.haveAcceptedSubEntities)\n                    break;\n                this.points.push(ev.point.clone());\n                if (!ev.isControlKey)\n                    break;\n                this.setupAndPromptForNextAction();\n                return EventHandled.No;\n            }\n            default:\n                break;\n        }\n        return super.gatherInput(ev);\n    }\n    get wantAdditionalInput() {\n        switch (this.method) {\n            case ImprintSolidMethod.Element:\n                return false;\n            case ImprintSolidMethod.Edges:\n                return super.wantAdditionalInput;\n            case ImprintSolidMethod.Points:\n                return super.wantAdditionalInput || this.points.length < 2;\n        }\n    }\n    setupAccuDraw() {\n        if (ImprintSolidMethod.Points !== this.method || 0 !== this.points.length)\n            return;\n        if (!this.haveAcceptedSubEntities)\n            return;\n        const faceData = this.getAcceptedSubEntityData()?.toolData;\n        if (undefined === faceData)\n            return;\n        const hints = new AccuDrawHintBuilder();\n        hints.setModeRectangular();\n        hints.setOrigin(faceData.point);\n        hints.setNormal(faceData.normal);\n        hints.sendHints(false);\n    }\n    async applyToolSettingPropertyChange(updatedValue) {\n        if (!this.changeToolSettingPropertyValue(updatedValue))\n            return false;\n        if (updatedValue.propertyName === this.methodProperty.name)\n            await this.onReinitialize();\n        return true;\n    }\n    supplyToolSettingsProperties() {\n        this.initializeToolSettingPropertyValues([this.methodProperty, this.extendProperty, this.distanceProperty]);\n        const toolSettings = new Array();\n        toolSettings.push(this.methodProperty.toDialogItem({ rowPriority: 1, columnIndex: 0 }));\n        switch (this.method) {\n            case ImprintSolidMethod.Element:\n                toolSettings.push(this.extendProperty.toDialogItem({ rowPriority: 2, columnIndex: 0 }));\n                break;\n            case ImprintSolidMethod.Edges:\n                toolSettings.push(this.distanceProperty.toDialogItem({ rowPriority: 2, columnIndex: 0 }));\n                break;\n            case ImprintSolidMethod.Points:\n                toolSettings.push(this.extendProperty.toDialogItem({ rowPriority: 2, columnIndex: 0 }));\n                break;\n        }\n        return toolSettings;\n    }\n    async onRestartTool() {\n        const tool = new ImprintSolidElementsTool();\n        if (!await tool.run())\n            return this.exitTool();\n    }\n}\nImprintSolidElementsTool.toolId = \"ImprintSolids\";\nImprintSolidElementsTool.iconSpec = \"icon-move\"; // TODO: Need better icon...\nImprintSolidElementsTool.getMethodChoices = () => {\n    return [\n        { label: ImprintSolidElementsTool.methodMessage(\"Element\"), value: ImprintSolidMethod.Element },\n        { label: ImprintSolidElementsTool.methodMessage(\"Edges\"), value: ImprintSolidMethod.Edges },\n        { label: ImprintSolidElementsTool.methodMessage(\"Points\"), value: ImprintSolidMethod.Points },\n    ];\n};\nexport { ImprintSolidElementsTool };\n/** @alpha Base class for tools to identify edges of solids and surfaces and apply blends. */\nexport class BlendEdgesTool extends LocateSubEntityTool {\n    get addSmoothProperty() {\n        if (!this._addSmoothProperty)\n            this._addSmoothProperty = new DialogProperty(PropertyDescriptionHelper.buildToggleDescription(\"blendSmooth\", EditTools.translate(\"RoundEdges.Label.AddSmooth\")), false);\n        return this._addSmoothProperty;\n    }\n    get addSmooth() { return this.addSmoothProperty.value; }\n    set addSmooth(value) { this.addSmoothProperty.value = value; }\n    wantSubEntityType(type) { return SubEntityType.Edge === type; }\n    getSubEntityFilter() {\n        return { laminarEdges: true, smoothEdges: true };\n    }\n    get geometryCacheFilter() {\n        return { parts: true, curves: false, surfaces: true, solids: true, other: false };\n    }\n    async getTangentEdges(id, edge) {\n        try {\n            return await solidModelingIpc.getConnectedSubEntities(id, edge, SubEntityType.Edge, { smoothEdges: true });\n        }\n        catch (err) {\n            return undefined;\n        }\n    }\n    async addTangentEdges(id, edge, chordTolerance) {\n        if (undefined === edge) {\n            this._acceptedSubEntities.forEach(async (accepted) => {\n                if (undefined === accepted.toolData)\n                    await this.addTangentEdges(id, accepted.props, accepted.chordTolerance);\n            });\n            return;\n        }\n        const tangentEdges = await this.getTangentEdges(id, edge);\n        if (undefined === tangentEdges)\n            return;\n        tangentEdges.forEach(async (entry) => {\n            if (!isSameSubEntity(entry, edge)) {\n                const data = new SubEntityData(entry);\n                data.toolData = edge; // Mark edge so we know it was added as tangent edge...\n                await this.createSubEntityGraphic(id, data, chordTolerance);\n                this._acceptedSubEntities.push(data);\n            }\n        });\n    }\n    async removeTangentEdges(_id, edge) {\n        if (undefined === edge) {\n            this._acceptedSubEntities = this._acceptedSubEntities.filter((entry) => undefined === entry.toolData);\n            return;\n        }\n        const edgeData = this._acceptedSubEntities.find((entry) => isSameSubEntity(entry.props, edge));\n        if (undefined === edgeData)\n            return undefined;\n        const isTangentEdge = (other) => {\n            const primaryOther = (undefined !== other.toolData ? other.toolData : other.props);\n            return isSameSubEntity(primaryEdge, primaryOther);\n        };\n        const primaryEdge = (undefined !== edgeData.toolData ? edgeData.toolData : edgeData.props);\n        this._acceptedSubEntities = this._acceptedSubEntities.filter((entry) => !isTangentEdge(entry));\n    }\n    async syncTangentEdges() {\n        const id = this.getCurrentElement();\n        if (undefined === id)\n            return;\n        if (this.addSmooth)\n            await this.addTangentEdges(id);\n        else\n            await this.removeTangentEdges(id);\n        IModelApp.viewManager.invalidateDecorationsAllViews();\n    }\n    async addSubEntity(id, props) {\n        await super.addSubEntity(id, props);\n        if (!this.addSmooth)\n            return;\n        const chordTolerance = (this.targetView ? computeChordToleranceFromPoint(this.targetView, Point3d.fromJSON(props.point)) : undefined);\n        return this.addTangentEdges(id, props.subEntity, chordTolerance);\n    }\n    async removeSubEntity(id, props) {\n        if (!this.addSmooth)\n            return super.removeSubEntity(id, props);\n        const edge = (undefined !== props) ? props.subEntity : this.getAcceptedSubEntityData()?.props;\n        if (undefined === edge)\n            return;\n        return this.removeTangentEdges(id, edge);\n    }\n    getAcceptedSubEntities() {\n        const edges = [];\n        this._acceptedSubEntities.forEach((entry) => {\n            if (undefined === entry.toolData)\n                edges.push(entry.props);\n        });\n        return edges;\n    }\n}\n/** @alpha Identify edges of solids and surfaces to apply a rolling ball blend to. */\nclass RoundEdgesTool extends BlendEdgesTool {\n    get radiusProperty() {\n        if (!this._radiusProperty)\n            this._radiusProperty = new DialogProperty(new LengthDescription(\"roundRadius\", EditTools.translate(\"RoundEdges.Label.Radius\")), 0.1, undefined);\n        return this._radiusProperty;\n    }\n    get radius() { return this.radiusProperty.value; }\n    set radius(value) { this.radiusProperty.value = value; }\n    async applyAgendaOperation(ev, isAccept) {\n        if (undefined === ev.viewport || this.agenda.isEmpty || !this.haveAcceptedSubEntities)\n            return undefined;\n        try {\n            this._startedCmd = await this.startCommand();\n            const params = { edges: this.getAcceptedSubEntities(), radii: this.radius, propagateSmooth: this.addSmooth };\n            const opts = {\n                wantGraphic: isAccept ? undefined : true,\n                chordTolerance: computeChordToleranceFromPoint(ev.viewport, ev.point),\n                requestId: `${this.toolId}:${this.agenda.elements[0]}`,\n                writeChanges: isAccept ? true : undefined,\n            };\n            return await solidModelingIpc.blendEdges(this.agenda.elements[0], params, opts);\n        }\n        catch (err) {\n            return undefined;\n        }\n    }\n    async applyToolSettingPropertyChange(updatedValue) {\n        if (!this.changeToolSettingPropertyValue(updatedValue))\n            return false;\n        if (updatedValue.propertyName === this.addSmoothProperty.name)\n            await this.syncTangentEdges();\n        return true;\n    }\n    supplyToolSettingsProperties() {\n        this.initializeToolSettingPropertyValues([this.radiusProperty, this.addSmoothProperty]);\n        const toolSettings = new Array();\n        toolSettings.push(this.radiusProperty.toDialogItem({ rowPriority: 1, columnIndex: 0 }));\n        toolSettings.push(this.addSmoothProperty.toDialogItem({ rowPriority: 2, columnIndex: 0 }));\n        return toolSettings;\n    }\n    async onRestartTool() {\n        const tool = new RoundEdgesTool();\n        if (!await tool.run())\n            return this.exitTool();\n    }\n}\nRoundEdgesTool.toolId = \"RoundEdges\";\nRoundEdgesTool.iconSpec = \"icon-move\"; // TODO: Need better icon...\nexport { RoundEdgesTool };\n/** @alpha Identify edges of solids and surfaces to apply a rolling ball blend to. */\nclass ChamferEdgesTool extends BlendEdgesTool {\n    static methodMessage(str) { return EditTools.translate(`ChamferEdges.Method.${str}`); }\n    get methodProperty() {\n        if (!this._methodProperty)\n            this._methodProperty = new DialogProperty(PropertyDescriptionHelper.buildEnumPicklistEditorDescription(\"chamferMethod\", EditTools.translate(\"ChamferEdges.Label.Method\"), ChamferEdgesTool.getMethodChoices()), ChamferMode.Length);\n        return this._methodProperty;\n    }\n    get method() { return this.methodProperty.value; }\n    set method(method) { this.methodProperty.value = method; }\n    get lengthProperty() {\n        if (!this._lengthProperty)\n            this._lengthProperty = new DialogProperty(new LengthDescription(\"chamferLength\", EditTools.translate(\"ChamferEdges.Label.Length\")), 0.1, undefined);\n        return this._lengthProperty;\n    }\n    get length() { return this.lengthProperty.value; }\n    set length(value) { this.lengthProperty.value = value; }\n    get distanceLeftProperty() {\n        if (!this._distanceLeftProperty)\n            this._distanceLeftProperty = new DialogProperty(new LengthDescription(\"chamferLeftDist\", EditTools.translate(\"ChamferEdges.Label.LeftDistance\")), 0.1, undefined);\n        return this._distanceLeftProperty;\n    }\n    get distanceLeft() { return this.distanceLeftProperty.value; }\n    set distanceLeft(value) { this.distanceLeftProperty.value = value; }\n    get distanceRightProperty() {\n        if (!this._distanceRightProperty)\n            this._distanceRightProperty = new DialogProperty(new LengthDescription(\"chamferRightDist\", EditTools.translate(\"ChamferEdges.Label.RightDistance\")), 0.1, undefined);\n        return this._distanceRightProperty;\n    }\n    get distanceRight() { return this.distanceRightProperty.value; }\n    set distanceRight(value) { this.distanceRightProperty.value = value; }\n    get angleProperty() {\n        if (!this._angleProperty)\n            this._angleProperty = new DialogProperty(new AngleDescription(\"chamferAngle\", EditTools.translate(\"ChamferEdges.Label.Angle\")), Angle.piOver4Radians, undefined, false);\n        return this._angleProperty;\n    }\n    get angle() { return this.angleProperty.value; }\n    set angle(value) { this.angleProperty.value = value; }\n    async applyAgendaOperation(ev, isAccept) {\n        if (undefined === ev.viewport || this.agenda.isEmpty || !this.haveAcceptedSubEntities)\n            return undefined;\n        try {\n            this._startedCmd = await this.startCommand();\n            let values1;\n            let values2;\n            switch (this.method) {\n                case ChamferMode.Length:\n                    values1 = this.length;\n                    break;\n                case ChamferMode.Distances:\n                    values1 = this.distanceLeft;\n                    values2 = this.distanceRight;\n                    break;\n                case ChamferMode.DistanceAngle:\n                    values1 = this.distanceLeft;\n                    values2 = this.angle;\n                    break;\n                case ChamferMode.AngleDistance:\n                    values1 = this.angle;\n                    values2 = this.distanceRight;\n                    break;\n                default:\n                    return undefined;\n            }\n            const params = { edges: this.getAcceptedSubEntities(), mode: this.method, values1, values2, propagateSmooth: this.addSmooth };\n            const opts = {\n                wantGraphic: isAccept ? undefined : true,\n                chordTolerance: computeChordToleranceFromPoint(ev.viewport, ev.point),\n                requestId: `${this.toolId}:${this.agenda.elements[0]}`,\n                writeChanges: isAccept ? true : undefined,\n            };\n            return await solidModelingIpc.chamferEdges(this.agenda.elements[0], params, opts);\n        }\n        catch (err) {\n            return undefined;\n        }\n    }\n    async applyToolSettingPropertyChange(updatedValue) {\n        if (!this.changeToolSettingPropertyValue(updatedValue))\n            return false;\n        if (updatedValue.propertyName === this.methodProperty.name)\n            await this.onReinitialize();\n        return true;\n    }\n    supplyToolSettingsProperties() {\n        this.initializeToolSettingPropertyValues([this.methodProperty, this.addSmoothProperty, this.lengthProperty, this.distanceLeftProperty, this.distanceRightProperty, this.angleProperty]);\n        const toolSettings = new Array();\n        toolSettings.push(this.methodProperty.toDialogItem({ rowPriority: 1, columnIndex: 0 }));\n        toolSettings.push(this.addSmoothProperty.toDialogItem({ rowPriority: ChamferMode.Length === this.method ? 3 : 4, columnIndex: 0 }));\n        switch (this.method) {\n            case ChamferMode.Length:\n                toolSettings.push(this.lengthProperty.toDialogItem({ rowPriority: 2, columnIndex: 0 }));\n                break;\n            case ChamferMode.Distances:\n                toolSettings.push(this.distanceLeftProperty.toDialogItem({ rowPriority: 2, columnIndex: 0 }));\n                toolSettings.push(this.distanceRightProperty.toDialogItem({ rowPriority: 3, columnIndex: 0 }));\n                break;\n            case ChamferMode.DistanceAngle:\n                toolSettings.push(this.distanceLeftProperty.toDialogItem({ rowPriority: 2, columnIndex: 0 }));\n                toolSettings.push(this.angleProperty.toDialogItem({ rowPriority: 3, columnIndex: 0 }));\n                break;\n            case ChamferMode.AngleDistance:\n                toolSettings.push(this.distanceRightProperty.toDialogItem({ rowPriority: 2, columnIndex: 0 }));\n                toolSettings.push(this.angleProperty.toDialogItem({ rowPriority: 3, columnIndex: 0 }));\n                break;\n        }\n        return toolSettings;\n    }\n    async onRestartTool() {\n        const tool = new ChamferEdgesTool();\n        if (!await tool.run())\n            return this.exitTool();\n    }\n}\nChamferEdgesTool.toolId = \"ChamferEdges\";\nChamferEdgesTool.iconSpec = \"icon-move\"; // TODO: Need better icon...\nChamferEdgesTool.getMethodChoices = () => {\n    return [\n        { label: ChamferEdgesTool.methodMessage(\"Length\"), value: ChamferMode.Length },\n        { label: ChamferEdgesTool.methodMessage(\"Distances\"), value: ChamferMode.Distances },\n        { label: ChamferEdgesTool.methodMessage(\"DistanceAngle\"), value: ChamferMode.DistanceAngle },\n        { label: ChamferEdgesTool.methodMessage(\"AngleDistance\"), value: ChamferMode.AngleDistance },\n    ];\n};\nexport { ChamferEdgesTool };\n/** @alpha */\nexport class ProfileLocationData {\n    constructor(point, orientation) {\n        this.point = point;\n        this.orientation = orientation;\n    }\n}\n/** @alpha Base class for picking profiles (open paths and regions) or faces of solids. */\nexport class LocateFaceOrProfileTool extends LocateSubEntityTool {\n    get wantGeometrySummary() { return true; }\n    wantSubEntityType(type) {\n        switch (type) {\n            case SubEntityType.Face:\n            case SubEntityType.Edge:\n                // Choose all faces or all edges...\n                return (0 === this._acceptedSubEntities.length || this._acceptedSubEntities[0].props.type === type);\n            default:\n                return false;\n        }\n    }\n    get geometryCacheFilter() {\n        return { parts: true, curves: true, surfaces: true, solids: true, other: false };\n    }\n    async doPickSubEntities(id, ev) {\n        const hits = await super.doPickSubEntities(id, ev);\n        if (undefined === hits)\n            return hits;\n        // Only want edges from wire bodies...\n        const accept = (BRepEntityType.Wire === this.getBRepEntityTypeForSubEntity(id, hits[0].subEntity) ? SubEntityType.Edge : SubEntityType.Face);\n        return hits.filter((hit) => accept === hit.subEntity.type);\n    }\n    async createSubEntityData(id, hit) {\n        const data = await super.createSubEntityData(id, hit);\n        // Prefer orientation from snap to take entire path curve as well as placement z into account...\n        const snap = TentativeOrAccuSnap.getCurrentSnap(false);\n        const point = (id === snap?.sourceId && snap.isHot ? snap.snapPoint : Point3d.fromJSON(hit.point));\n        const matrix = (id === snap?.sourceId ? AccuDraw.getSnapRotation(snap, undefined) : undefined);\n        const invMatrix = matrix?.inverse(); // getSnapRotation returns row matrix...\n        if (undefined !== invMatrix)\n            data.toolData = new ProfileLocationData(point, invMatrix);\n        else\n            data.toolData = new ProfileLocationData(point, undefined !== hit.normal ? Vector3d.fromJSON(hit.normal) : Vector3d.unitZ());\n        return data;\n    }\n    drawSubEntity(context, subEntity, accepted) {\n        const id = this.getCurrentElement();\n        if (undefined !== id && BRepEntityType.Solid !== this.getBRepEntityTypeForSubEntity(id, subEntity.props))\n            return; // Operation will be applied to wire or sheet body, don't display sub-entity...\n        super.drawSubEntity(context, subEntity, accepted);\n    }\n    drawAcceptedSubEntities(context) {\n        super.drawAcceptedSubEntities(context);\n        // Show pick point on last identified face...\n        const profileData = this.getAcceptedSubEntityData()?.toolData;\n        if (undefined === profileData)\n            return;\n        const builder = context.createGraphic({ type: GraphicType.WorldOverlay });\n        builder.setSymbology(context.viewport.getContrastToBackgroundColor(), ColorDef.black, 10);\n        builder.addPointString([profileData.point]);\n        context.addDecorationFromBuilder(builder);\n    }\n}\n/** @alpha Identify faces of solids and surfaces to translate. */\nclass SweepFacesTool extends LocateFaceOrProfileTool {\n    get wantDynamics() { return true; }\n    get wantAccuSnap() { return true; }\n    get wantSubEntitySnap() { return true; }\n    get addSmoothProperty() {\n        if (!this._addSmoothProperty)\n            this._addSmoothProperty = new DialogProperty(PropertyDescriptionHelper.buildToggleDescription(\"sweepSmooth\", EditTools.translate(\"SweepFaces.Label.AddSmooth\")), false);\n        return this._addSmoothProperty;\n    }\n    get addSmooth() { return this.addSmoothProperty.value; }\n    set addSmooth(value) { this.addSmoothProperty.value = value; }\n    get useDistanceProperty() {\n        if (!this._useDistanceProperty)\n            this._useDistanceProperty = new DialogProperty(PropertyDescriptionHelper.buildLockPropertyDescription(\"useOffsetDistance\"), false);\n        return this._useDistanceProperty;\n    }\n    get useDistance() { return this.useDistanceProperty.value; }\n    set useDistance(value) { this.useDistanceProperty.value = value; }\n    get distanceProperty() {\n        if (!this._distanceProperty)\n            this._distanceProperty = new DialogProperty(new LengthDescription(\"sweepDistance\", EditTools.translate(\"SweepFaces.Label.Distance\")), 0.1, undefined, !this.useDistance);\n        return this._distanceProperty;\n    }\n    get distance() { return this.distanceProperty.value; }\n    set distance(value) { this.distanceProperty.value = value; }\n    async getSmoothFaces(id, face) {\n        try {\n            // NOTE: For sweep/translation, it makes sense to limit smooth to immediately adjacent...\n            return await solidModelingIpc.getConnectedSubEntities(id, face, SubEntityType.Face, { smoothFaces: true, adjacentFaces: true });\n        }\n        catch (err) {\n            return undefined;\n        }\n    }\n    async applyAgendaOperation(ev, isAccept) {\n        if (undefined === ev.viewport || this.agenda.isEmpty || !this.haveAcceptedSubEntities)\n            return undefined;\n        const profileData = this.getAcceptedSubEntityData()?.toolData;\n        if (undefined === profileData)\n            return undefined;\n        const path = Vector3d.createStartEnd(profileData.point, ev.point);\n        if (this.useDistance && undefined === path.scaleToLength(this.distance, path))\n            return undefined;\n        if (path.magnitude() < Geometry.smallMetricDistance)\n            return undefined;\n        if (!this.useDistance) {\n            this.distance = path.magnitude();\n            this.syncToolSettingPropertyValue(this.distanceProperty);\n            if (isAccept)\n                this.saveToolSettingPropertyValue(this.distanceProperty, this.distanceProperty.dialogItemValue);\n        }\n        try {\n            this._startedCmd = await this.startCommand();\n            const id = this.agenda.elements[0];\n            const opts = {\n                wantGraphic: isAccept ? undefined : true,\n                chordTolerance: computeChordToleranceFromPoint(ev.viewport, ev.point),\n                requestId: `${this.toolId}:${id}`,\n                writeChanges: isAccept ? true : undefined,\n            };\n            const subEntities = this.getAcceptedSubEntities();\n            const params = { path };\n            if (SubEntityType.Edge === subEntities[0].type || BRepEntityType.Solid !== this.getBRepEntityTypeForSubEntity(id, subEntities[0])) {\n                return await solidModelingIpc.sweepFaces(id, params, opts);\n            }\n            if (this.addSmooth) {\n                const allSmoothFaces = [];\n                for (const face of subEntities) {\n                    const smoothFaces = await this.getSmoothFaces(id, face);\n                    if (undefined !== smoothFaces)\n                        allSmoothFaces.push(...smoothFaces);\n                }\n                for (const smooth of allSmoothFaces) {\n                    if (undefined === subEntities.find((selected) => isSameSubEntity(selected, smooth)))\n                        subEntities.unshift(smooth); // Preserve last selected entry as reference face...\n                }\n            }\n            params.faces = subEntities;\n            return await solidModelingIpc.sweepFaces(id, params, opts);\n        }\n        catch (err) {\n            return undefined;\n        }\n    }\n    setupAccuDraw() {\n        if (!this.haveAcceptedSubEntities)\n            return;\n        const profileData = this.getAcceptedSubEntityData()?.toolData;\n        if (undefined === profileData)\n            return;\n        const hints = new AccuDrawHintBuilder();\n        hints.setOriginFixed = true;\n        hints.setLockY = true;\n        hints.setLockZ = true;\n        hints.setModeRectangular();\n        hints.setOrigin(profileData.point);\n        hints.setXAxis2(profileData.orientation instanceof Matrix3d ? profileData.orientation.getColumn(2) : profileData.orientation);\n        hints.sendHints(false);\n    }\n    async applyToolSettingPropertyChange(updatedValue) {\n        return this.changeToolSettingPropertyValue(updatedValue);\n    }\n    supplyToolSettingsProperties() {\n        this.initializeToolSettingPropertyValues([this.addSmoothProperty, this.useDistanceProperty, this.distanceProperty]);\n        const toolSettings = new Array();\n        // ensure controls are enabled/disabled based on current lock property state\n        this.distanceProperty.isDisabled = !this.useDistance;\n        const useDistanceLock = this.useDistanceProperty.toDialogItem({ rowPriority: 1, columnIndex: 0 });\n        toolSettings.push(this.distanceProperty.toDialogItem({ rowPriority: 1, columnIndex: 1 }, useDistanceLock));\n        toolSettings.push(this.addSmoothProperty.toDialogItem({ rowPriority: 2, columnIndex: 0 }));\n        return toolSettings;\n    }\n    async onRestartTool() {\n        const tool = new SweepFacesTool();\n        if (!await tool.run())\n            return this.exitTool();\n    }\n}\nSweepFacesTool.toolId = \"SweepFaces\";\nSweepFacesTool.iconSpec = \"icon-move\"; // TODO: Need better icon...\nexport { SweepFacesTool };\n/** @alpha Identify faces of solids and surfaces to revolve. */\nclass SpinFacesTool extends LocateFaceOrProfileTool {\n    constructor() {\n        super(...arguments);\n        this.points = [];\n    }\n    get angleProperty() {\n        if (!this._angleProperty)\n            this._angleProperty = new DialogProperty(new AngleDescription(\"spinAngle\", EditTools.translate(\"SpinFaces.Label.Angle\")), Angle.piOver2Radians, undefined, false);\n        return this._angleProperty;\n    }\n    get angle() { return this.angleProperty.value; }\n    set angle(value) { this.angleProperty.value = value; }\n    get wantDynamics() { return true; }\n    get wantAccuSnap() { return true; }\n    get wantSubEntitySnap() { return true; }\n    async applyAgendaOperation(ev, isAccept) {\n        if (undefined === ev.viewport || this.agenda.isEmpty || !this.haveAcceptedSubEntities || this.points.length < (isAccept ? 2 : 1))\n            return undefined;\n        const direction = Vector3d.createStartEnd(this.points[0], isAccept ? this.points[1] : ev.point);\n        if (direction.magnitude() < Geometry.smallMetricDistance)\n            return undefined;\n        const origin = this.points[0];\n        const angle = Angle.createRadians(this.angle);\n        try {\n            this._startedCmd = await this.startCommand();\n            const id = this.agenda.elements[0];\n            const opts = {\n                wantGraphic: isAccept ? undefined : true,\n                chordTolerance: computeChordToleranceFromPoint(ev.viewport, ev.point),\n                requestId: `${this.toolId}:${id}`,\n                writeChanges: isAccept ? true : undefined,\n            };\n            const subEntities = this.getAcceptedSubEntities();\n            const params = { origin, direction, angle };\n            if (SubEntityType.Edge === subEntities[0].type || BRepEntityType.Solid !== this.getBRepEntityTypeForSubEntity(id, subEntities[0])) {\n                return await solidModelingIpc.spinFaces(id, params, opts);\n            }\n            params.faces = subEntities;\n            let result = await solidModelingIpc.spinFaces(id, params, opts);\n            // Spun face can be used to create a pocket...retry with negative sweep...\n            if (undefined === result) {\n                angle.setRadians(-angle.radians);\n                result = await solidModelingIpc.spinFaces(id, params, opts);\n            }\n            return result;\n        }\n        catch (err) {\n            return undefined;\n        }\n    }\n    onDynamicFrame(ev, context) {\n        if (0 === this.points.length)\n            return;\n        const pts = this.points.slice();\n        pts.push(ev.point.clone());\n        const builder = context.createGraphic({ type: GraphicType.WorldOverlay });\n        builder.setSymbology(context.viewport.getContrastToBackgroundColor(), ColorDef.black, 3);\n        builder.addLineString(pts);\n        context.addGraphic(builder.finish());\n        super.onDynamicFrame(ev, context);\n    }\n    async gatherInput(ev) {\n        if (!this.wantAdditionalSubEntities)\n            this.points.push(ev.point.clone());\n        return super.gatherInput(ev);\n    }\n    get wantAdditionalInput() {\n        return super.wantAdditionalInput || this.points.length < 2;\n    }\n    setupAccuDraw() {\n        if (!this.haveAcceptedSubEntities || 0 !== this.points.length)\n            return;\n        const profileData = this.getAcceptedSubEntityData()?.toolData;\n        if (undefined === profileData)\n            return;\n        const hints = new AccuDrawHintBuilder();\n        hints.setModeRectangular();\n        hints.setOrigin(profileData.point);\n        if (profileData.orientation instanceof Matrix3d)\n            hints.setMatrix(profileData.orientation);\n        else\n            hints.setNormal(profileData.orientation);\n        hints.sendHints(false);\n    }\n    async applyToolSettingPropertyChange(updatedValue) {\n        return this.changeToolSettingPropertyValue(updatedValue);\n    }\n    supplyToolSettingsProperties() {\n        this.initializeToolSettingPropertyValues([this.angleProperty]);\n        const toolSettings = new Array();\n        toolSettings.push(this.angleProperty.toDialogItem({ rowPriority: 1, columnIndex: 0 }));\n        return toolSettings;\n    }\n    async onRestartTool() {\n        const tool = new SpinFacesTool();\n        if (!await tool.run())\n            return this.exitTool();\n    }\n}\nSpinFacesTool.toolId = \"SpinFaces\";\nSpinFacesTool.iconSpec = \"icon-move\"; // TODO: Need better icon...\nexport { SpinFacesTool };\n//# sourceMappingURL=SolidModelingTools.js.map",
      "start": 1693508122942,
      "end": 1693508123114,
      "sourcemaps": null
    }
  ]
}
