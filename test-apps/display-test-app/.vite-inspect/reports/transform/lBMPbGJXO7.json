{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/Technique.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { assert, dispose, using } from \"@itwin/core-bentley\";\nimport { BlurType } from \"./CachedGeometry\";\nimport { createClippingProgram } from \"./ClippingProgram\";\nimport { createAmbientOcclusionProgram } from \"./glsl/AmbientOcclusion\";\nimport { createBlurProgram } from \"./glsl/Blur\";\nimport { createEDLCalcBasicProgram, createEDLCalcFullProgram, createEDLFilterProgram, createEDLMixProgram } from \"./glsl/EDL\";\nimport { createClearPickAndColorProgram } from \"./glsl/ClearPickAndColor\";\nimport { createClearTranslucentProgram } from \"./glsl/ClearTranslucent\";\nimport { createCombine3TexturesProgram } from \"./glsl/Combine3Textures\";\nimport { createCombineTexturesProgram } from \"./glsl/CombineTextures\";\nimport { addEyeSpace, addFrustum, addShaderFlags } from \"./glsl/Common\";\nimport { createCompositeProgram } from \"./glsl/Composite\";\nimport { createCopyColorProgram } from \"./glsl/CopyColor\";\nimport { createCopyPickBuffersProgram } from \"./glsl/CopyPickBuffers\";\nimport { createVolClassBlendProgram, createVolClassColorUsingStencilProgram, createVolClassCopyZProgram, createVolClassSetBlendProgram, } from \"./glsl/CopyStencil\";\nimport { createEdgeBuilder } from \"./glsl/Edge\";\nimport { createEVSMProgram } from \"./glsl/EVSMFromDepth\";\nimport { addFeatureId, addFeatureSymbology, addRenderOrder, addUniformFeatureSymbology, mixFeatureColor } from \"./glsl/FeatureSymbology\";\nimport { addFragColorWithPreMultipliedAlpha, addPickBufferOutputs } from \"./glsl/Fragment\";\nimport { addLogDepth } from \"./glsl/LogarithmicDepthBuffer\";\nimport { addUnlitMonochrome } from \"./glsl/Monochrome\";\nimport createPlanarGridProgram from \"./glsl/PlanarGrid\";\nimport { createPointCloudBuilder, createPointCloudHiliter } from \"./glsl/PointCloud\";\nimport { createPointStringBuilder, createPointStringHiliter } from \"./glsl/PointString\";\nimport { createPolylineBuilder, createPolylineHiliter } from \"./glsl/Polyline\";\nimport { addColorOverrideMix, createClassifierRealityMeshHiliter, createRealityMeshBuilder, createRealityMeshHiliter, } from \"./glsl/RealityMesh\";\nimport { createSkyBoxProgram } from \"./glsl/SkyBox\";\nimport { createSkySphereBuilder } from \"./glsl/SkySphere\";\nimport { createSurfaceBuilder, createSurfaceHiliter } from \"./glsl/Surface\";\nimport { addTranslucency } from \"./glsl/Translucency\";\nimport { addModelViewMatrix } from \"./glsl/Vertex\";\nimport { ShaderProgramExecutor } from \"./ShaderProgram\";\nimport { System } from \"./System\";\nimport { TechniqueFlags, } from \"./TechniqueFlags\";\nimport { computeCompositeTechniqueId } from \"./TechniqueId\";\n/** A rendering technique implemented using a single shader program, typically for some specialized purpose.\n * @internal\n */\nexport class SingularTechnique {\n    // Note: Technique assumes ownership of a program\n    constructor(program) { this.program = program; }\n    getShader(_flags) { return this.program; }\n    getShaderByIndex(_index) { return this.program; }\n    getShaderCount() { return 1; }\n    compileShaders() { return this.program.compile() === 0 /* CompileStatus.Success */; }\n    get isDisposed() { return this.program.isDisposed; }\n    dispose() {\n        dispose(this.program);\n    }\n}\nfunction numFeatureVariants(numBaseShaders) {\n    return numBaseShaders * 3;\n}\nconst numHiliteVariants = 2; // instanced and non-instanced.\nconst featureModes = [0 /* FeatureMode.None */, 1 /* FeatureMode.Pick */, 2 /* FeatureMode.Overrides */];\nconst scratchTechniqueFlags = new TechniqueFlags();\nconst scratchHiliteFlags = new TechniqueFlags();\n/** A rendering technique implemented using multiple shader programs, selected based on TechniqueFlags.\n * @internal\n */\nexport class VariedTechnique {\n    compileShaders() {\n        let allCompiled = true;\n        for (const program of this._basicPrograms) {\n            if (program.compile() !== 0 /* CompileStatus.Success */)\n                allCompiled = false;\n        }\n        for (const clipper of this._clippingPrograms)\n            if (!clipper.compile())\n                allCompiled = false;\n        return allCompiled;\n    }\n    finishConstruction() {\n        this._earlyZFlags.length = 0;\n        // Confirm no empty entries in our array.\n        let emptyShaderIndex = -1;\n        assert(-1 === (emptyShaderIndex = this._basicPrograms.findIndex((prog) => undefined === prog)), `Shader index ${emptyShaderIndex} is undefined in ${this.constructor.name}`);\n    }\n    get isDisposed() { return this._isDisposed; }\n    dispose() {\n        if (this._isDisposed)\n            return;\n        for (const program of this._basicPrograms) {\n            assert(undefined !== program);\n            dispose(program);\n        }\n        this._basicPrograms.length = 0;\n        for (const clipShaderObj of this._clippingPrograms) {\n            assert(undefined !== clipShaderObj);\n            clipShaderObj.dispose();\n        }\n        this._clippingPrograms.length = 0;\n        this._isDisposed = true;\n    }\n    constructor(numPrograms) {\n        this._basicPrograms = [];\n        this._clippingPrograms = [];\n        /** TechniqueFlags identifying shader programs for which the fragment shader writes depth but does not contain any discards.\n         * Buggy Intel HD 620/630 drivers incorrectly apply early-Z optimization in this case; we must insert a never-executed\n         * conditional discard to prevent that.\n         */\n        this._earlyZFlags = [];\n        this._isDisposed = false;\n        this._basicPrograms.length = numPrograms;\n    }\n    addShader(builder, flags, gl) {\n        const descr = `${this._debugDescription}: ${flags.buildDescription()}`;\n        builder.setDebugDescription(descr);\n        if (System.instance.supportsLogZBuffer) {\n            addLogDepth(builder);\n            assert(!builder.frag.requiresEarlyZWorkaround);\n            if (System.instance.fragDepthDoesNotDisableEarlyZ)\n                builder.frag.requiresEarlyZWorkaround = -1 !== this._earlyZFlags.findIndex((x) => x.equals(flags));\n        }\n        const index = this.getShaderIndex(flags);\n        this.addProgram(builder, index, gl);\n        assert(!builder.frag.requiresEarlyZWorkaround);\n    }\n    addProgram(builder, index, gl) {\n        assert(this._basicPrograms[index] === undefined);\n        this._basicPrograms[index] = builder.buildProgram(gl);\n        assert(this._basicPrograms[index] !== undefined);\n        // Clipping programs always include a discard, so never require workaround.\n        builder.frag.requiresEarlyZWorkaround = false;\n        assert(this._clippingPrograms[index] === undefined);\n        this._clippingPrograms[index] = createClippingProgram(builder);\n        assert(this._clippingPrograms[index] !== undefined);\n    }\n    addHiliteShader(gl, instanced, classified, posType, create) {\n        const builder = create(instanced, classified, posType);\n        scratchHiliteFlags.initForHilite(0, instanced, classified, posType);\n        this.addShader(builder, scratchHiliteFlags, gl);\n    }\n    addTranslucentShader(builder, flags, gl) {\n        flags.isTranslucent = true;\n        addTranslucency(builder);\n        this.addShader(builder, flags, gl);\n    }\n    addFeatureId(builder, feat) {\n        const frag = builder.frag;\n        if (0 /* FeatureMode.None */ === feat) {\n            addFragColorWithPreMultipliedAlpha(frag);\n        }\n        else {\n            const vert = builder.vert;\n            addFrustum(builder);\n            addEyeSpace(builder);\n            addModelViewMatrix(vert);\n            addRenderOrder(frag);\n            addFeatureId(builder, false);\n            addPickBufferOutputs(frag);\n        }\n    }\n    getShaderIndex(flags) {\n        assert(!flags.isHilite || (!flags.isTranslucent && (flags.isClassified === 1 /* IsClassified.Yes */ || flags.hasFeatures)), \"invalid technique flags\");\n        const index = this.computeShaderIndex(flags);\n        assert(index < this._basicPrograms.length, \"shader index out of bounds\");\n        return index;\n    }\n    getShader(flags) {\n        const index = this.getShaderIndex(flags);\n        let program;\n        if (flags.hasClip) {\n            const entry = this._clippingPrograms[index];\n            assert(undefined !== entry);\n            program = entry.getProgram(flags.numClipPlanes);\n        }\n        if (program === undefined)\n            program = this._basicPrograms[index];\n        return program;\n    }\n    // NB: Will ignore clipping shaders.\n    getShaderByIndex(index) {\n        return this._basicPrograms[index];\n    }\n    // NB: Will ignore clipping shaders.\n    getShaderCount() {\n        return this._basicPrograms.length;\n    }\n    /** For tests. */\n    forEachProgram(func) {\n        for (const basic of this._basicPrograms)\n            func(basic);\n        for (const clip of this._clippingPrograms) {\n            const prog = clip.getProgram(1);\n            assert(undefined !== prog);\n            func(prog);\n        }\n    }\n}\nconst positionTypes = [\"quantized\", \"unquantized\"];\nclass SurfaceTechnique extends VariedTechnique {\n    constructor(gl) {\n        super(SurfaceTechnique._kUnquantized * 2);\n        this._earlyZFlags = [\n            TechniqueFlags.fromDescription(\"Opaque-Hilite-Overrides\"),\n            TechniqueFlags.fromDescription(\"Opaque-Instanced-Hilite-Overrides\"),\n            TechniqueFlags.fromDescription(\"Opaque-Hilite-Classified\"),\n            TechniqueFlags.fromDescription(\"Unquantized-Opaque-Hilite-Overrides\"),\n            TechniqueFlags.fromDescription(\"Unquantized-Opaque-Instanced-Hilite-Overrides\"),\n            TechniqueFlags.fromDescription(\"Unquantized-Opaque-Hilite-Classified\"),\n        ];\n        const flags = scratchTechniqueFlags;\n        for (const posType of positionTypes) {\n            for (let instanced = 0 /* IsInstanced.No */; instanced <= 1 /* IsInstanced.Yes */; instanced++) {\n                this.addHiliteShader(gl, instanced, 0 /* IsClassified.No */, posType, createSurfaceHiliter);\n                for (let iAnimate = 0 /* IsAnimated.No */; iAnimate <= 1 /* IsAnimated.Yes */; iAnimate++) {\n                    for (let shadowable = 0 /* IsShadowable.No */; shadowable <= 1 /* IsShadowable.Yes */; shadowable++) {\n                        for (let wiremesh = 0 /* IsWiremesh.No */; wiremesh <= 1 /* IsWiremesh.Yes */; wiremesh++) {\n                            for (let thematic = 0 /* IsThematic.No */; thematic <= 1 /* IsThematic.Yes */; thematic++) {\n                                for (let edgeTestNeeded = 0 /* IsEdgeTestNeeded.No */; edgeTestNeeded <= 1 /* IsEdgeTestNeeded.Yes */; edgeTestNeeded++) {\n                                    for (const featureMode of featureModes) {\n                                        for (let iTranslucent = 0; iTranslucent <= 1; iTranslucent++) {\n                                            if (0 /* FeatureMode.None */ !== featureMode || 0 /* IsEdgeTestNeeded.No */ === edgeTestNeeded) {\n                                                if (1 /* IsThematic.Yes */ === thematic && 1 /* IsShadowable.Yes */ === shadowable)\n                                                    continue; // currently this combination is disallowed.\n                                                flags.reset(featureMode, instanced, shadowable, thematic, posType);\n                                                flags.isAnimated = iAnimate;\n                                                flags.isEdgeTestNeeded = edgeTestNeeded;\n                                                flags.isTranslucent = 1 === iTranslucent;\n                                                flags.isWiremesh = wiremesh;\n                                                const builder = createSurfaceBuilder(flags);\n                                                this.addShader(builder, flags, gl);\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        this.addHiliteShader(gl, 0 /* IsInstanced.No */, 1 /* IsClassified.Yes */, \"quantized\", createSurfaceHiliter);\n        this.addHiliteShader(gl, 0 /* IsInstanced.No */, 1 /* IsClassified.Yes */, \"unquantized\", createSurfaceHiliter);\n        for (const posType of positionTypes) {\n            for (let translucent = 0; translucent < 2; translucent++) {\n                for (let shadowable = 0 /* IsShadowable.No */; shadowable <= 1 /* IsShadowable.Yes */; shadowable++) {\n                    for (let thematic = 0 /* IsThematic.No */; thematic <= 1 /* IsThematic.Yes */; thematic++) {\n                        for (const featureMode of featureModes) {\n                            if (1 /* IsThematic.Yes */ === thematic && 1 /* IsShadowable.Yes */ === shadowable)\n                                continue; // currently this combination is disallowed.\n                            flags.reset(featureMode, 0 /* IsInstanced.No */, shadowable, thematic, posType);\n                            flags.isClassified = 1 /* IsClassified.Yes */;\n                            flags.isTranslucent = (0 !== translucent);\n                            const builder = createSurfaceBuilder(flags);\n                            if (flags.isTranslucent)\n                                addTranslucency(builder);\n                            this.addShader(builder, flags, gl);\n                        }\n                    }\n                }\n            }\n        }\n        this.finishConstruction();\n    }\n    get _debugDescription() { return \"Surface\"; }\n    computeShaderIndex(flags) {\n        assert(!(flags.isThematic && flags.isShadowable));\n        const idxOffset = flags.positionType === \"unquantized\" ? SurfaceTechnique._kUnquantized : 0;\n        if (flags.isClassified) {\n            assert(!flags.isAnimated);\n            assert(!flags.isInstanced);\n            assert(!flags.isEdgeTestNeeded);\n            // First classified shader is for hilite\n            if (flags.isHilite)\n                return SurfaceTechnique._kClassified + idxOffset;\n            // The rest are organized in 3 groups of 6 - one group per feature mode.\n            // Each group contains opaque, translucent, opaque+thematic, translucent+thematic, opaque+shadowable, and translucent+shadowable variants.\n            let baseIndex = SurfaceTechnique._kClassified + 1;\n            if (flags.isTranslucent)\n                baseIndex += 1;\n            if (flags.isShadowable)\n                baseIndex += 2;\n            if (flags.isThematic)\n                baseIndex += 4;\n            const featureOffset = 6 * flags.featureMode;\n            return baseIndex + featureOffset + idxOffset;\n        }\n        else if (flags.isHilite) {\n            assert(flags.hasFeatures);\n            return SurfaceTechnique._kHilite + flags.isInstanced + idxOffset;\n        }\n        assert(flags.hasFeatures || flags.isEdgeTestNeeded === 0 /* IsEdgeTestNeeded.No */);\n        let index = flags.isTranslucent ? SurfaceTechnique._kTranslucent : SurfaceTechnique._kOpaque;\n        index += SurfaceTechnique._kInstanced * flags.isInstanced;\n        index += SurfaceTechnique._kAnimated * flags.isAnimated;\n        index += SurfaceTechnique._kShadowable * flags.isShadowable;\n        index += SurfaceTechnique._kThematic * flags.isThematic;\n        index += SurfaceTechnique._kWiremesh * flags.isWiremesh;\n        if (flags.isEdgeTestNeeded)\n            index += SurfaceTechnique._kEdgeTestNeeded + (flags.featureMode - 1) * SurfaceTechnique._kFeature;\n        else\n            index += SurfaceTechnique._kFeature * flags.featureMode;\n        return index + idxOffset;\n    }\n}\nSurfaceTechnique._kOpaque = 0;\nSurfaceTechnique._kTranslucent = 1;\nSurfaceTechnique._kInstanced = 2;\nSurfaceTechnique._kAnimated = 4;\nSurfaceTechnique._kWiremesh = 8;\nSurfaceTechnique._kShadowable = 16;\nSurfaceTechnique._kThematic = 32;\nSurfaceTechnique._kFeature = 48;\nSurfaceTechnique._kEdgeTestNeeded = SurfaceTechnique._kFeature * 3; // only when hasFeatures\nSurfaceTechnique._kHilite = SurfaceTechnique._kEdgeTestNeeded + SurfaceTechnique._kFeature * 2;\n// Classifiers are never animated or instanced. They do support shadows, thematic display, and translucency.\n// There are 3 base variations - 1 per feature mode - each with translucent/shadowed/thematic variants; plus 1 for hilite.\nSurfaceTechnique._kClassified = SurfaceTechnique._kHilite + numHiliteVariants;\n// 3 base classified variations - 1 per feature mode.\n// Plus thematic variant of each and shadowable variant of each = 9\n// Plus translucent variant of each of those = 18\n// Plus 1 hilite shader = 19\nSurfaceTechnique._kUnquantized = SurfaceTechnique._kClassified + 19;\nclass PolylineTechnique extends VariedTechnique {\n    constructor(gl) {\n        super(PolylineTechnique._kUnquantized * 2);\n        this._earlyZFlags = [\n            TechniqueFlags.fromDescription(\"Opaque-Hilite-Overrides\"),\n            TechniqueFlags.fromDescription(\"Opaque-Instanced-Hilite-Overrides\"),\n            TechniqueFlags.fromDescription(\"Unquantized-Opaque-Hilite-Overrides\"),\n            TechniqueFlags.fromDescription(\"Unquantized-Opaque-Instanced-Hilite-Overrides\"),\n        ];\n        const flags = scratchTechniqueFlags;\n        for (const posType of positionTypes) {\n            for (let instanced = 0 /* IsInstanced.No */; instanced <= 1 /* IsInstanced.Yes */; instanced++) {\n                this.addHiliteShader(gl, instanced, 0 /* IsClassified.No */, posType, (inst, _class, pos) => createPolylineHiliter(inst, pos));\n                for (const featureMode of featureModes) {\n                    flags.reset(featureMode, instanced, 0 /* IsShadowable.No */, 0 /* IsThematic.No */, posType);\n                    const builder = createPolylineBuilder(instanced, posType);\n                    addUnlitMonochrome(builder.frag);\n                    // The translucent shaders do not need the element IDs.\n                    const builderTrans = createPolylineBuilder(instanced, posType);\n                    addUnlitMonochrome(builderTrans.frag);\n                    if (2 /* FeatureMode.Overrides */ === featureMode) {\n                        addFeatureSymbology(builderTrans, featureMode, 31 /* FeatureSymbologyOptions.Linear */);\n                        addFeatureSymbology(builder, featureMode, 31 /* FeatureSymbologyOptions.Linear */);\n                        this.addTranslucentShader(builderTrans, flags, gl);\n                    }\n                    else {\n                        this.addTranslucentShader(builderTrans, flags, gl);\n                        addFeatureSymbology(builder, featureMode, 0 /* FeatureSymbologyOptions.None */);\n                    }\n                    this.addFeatureId(builder, featureMode);\n                    flags.reset(featureMode, instanced, 0 /* IsShadowable.No */, 0 /* IsThematic.No */, posType);\n                    this.addShader(builder, flags, gl);\n                }\n            }\n        }\n        this.finishConstruction();\n    }\n    get _debugDescription() { return \"Polyline\"; }\n    computeShaderIndex(flags) {\n        const idxOffset = flags.positionType === \"unquantized\" ? PolylineTechnique._kUnquantized : 0;\n        if (flags.isHilite) {\n            assert(flags.hasFeatures);\n            return PolylineTechnique._kHilite + flags.isInstanced + idxOffset;\n        }\n        let index = flags.isTranslucent ? PolylineTechnique._kTranslucent : PolylineTechnique._kOpaque;\n        index += PolylineTechnique._kFeature * flags.featureMode;\n        index += PolylineTechnique._kInstanced * flags.isInstanced;\n        return index + idxOffset;\n    }\n}\nPolylineTechnique._kOpaque = 0;\nPolylineTechnique._kTranslucent = 1;\nPolylineTechnique._kInstanced = 2;\nPolylineTechnique._kFeature = 4;\nPolylineTechnique._kHilite = numFeatureVariants(PolylineTechnique._kFeature);\nPolylineTechnique._kUnquantized = PolylineTechnique._kHilite + numHiliteVariants;\nclass EdgeTechnique extends VariedTechnique {\n    constructor(gl, type) {\n        super(EdgeTechnique._kUnquantized * 2);\n        this._type = type;\n        const flags = scratchTechniqueFlags;\n        for (const posType of positionTypes) {\n            for (let instanced = 0 /* IsInstanced.No */; instanced <= 1 /* IsInstanced.Yes */; instanced++) {\n                for (let iAnimate = 0 /* IsAnimated.No */; iAnimate <= 1 /* IsAnimated.Yes */; iAnimate++) {\n                    for (const featureMode of featureModes) {\n                        flags.reset(featureMode, instanced, 0 /* IsShadowable.No */, 0 /* IsThematic.No */, posType);\n                        flags.isAnimated = iAnimate;\n                        const builder = createEdgeBuilder(type, flags.isInstanced, flags.isAnimated, posType);\n                        addUnlitMonochrome(builder.frag);\n                        // The translucent shaders do not need the element IDs.\n                        const builderTrans = createEdgeBuilder(type, flags.isInstanced, flags.isAnimated, posType);\n                        addUnlitMonochrome(builderTrans.frag);\n                        if (2 /* FeatureMode.Overrides */ === featureMode) {\n                            addFeatureSymbology(builderTrans, featureMode, 31 /* FeatureSymbologyOptions.Linear */);\n                            addFeatureSymbology(builder, featureMode, 31 /* FeatureSymbologyOptions.Linear */);\n                            this.addTranslucentShader(builderTrans, flags, gl);\n                        }\n                        else {\n                            this.addTranslucentShader(builderTrans, flags, gl);\n                            addFeatureSymbology(builder, featureMode, 0 /* FeatureSymbologyOptions.None */);\n                        }\n                        this.addFeatureId(builder, featureMode);\n                        flags.reset(featureMode, instanced, 0 /* IsShadowable.No */, 0 /* IsThematic.No */, posType);\n                        flags.isAnimated = iAnimate;\n                        this.addShader(builder, flags, gl);\n                    }\n                }\n            }\n        }\n        this.finishConstruction();\n    }\n    get _debugDescription() { return this._type; }\n    computeShaderIndex(flags) {\n        let index = flags.isTranslucent ? EdgeTechnique._kTranslucent : EdgeTechnique._kOpaque;\n        index += EdgeTechnique._kFeature * flags.featureMode;\n        if (flags.isAnimated)\n            index += EdgeTechnique._kAnimated;\n        if (flags.isInstanced)\n            index += EdgeTechnique._kInstanced;\n        if (\"unquantized\" === flags.positionType)\n            index += EdgeTechnique._kUnquantized;\n        return index;\n    }\n}\nEdgeTechnique._kOpaque = 0;\nEdgeTechnique._kTranslucent = 1;\nEdgeTechnique._kAnimated = 2;\nEdgeTechnique._kInstanced = 4;\nEdgeTechnique._kFeature = 8;\nEdgeTechnique._kUnquantized = numFeatureVariants(EdgeTechnique._kFeature);\nclass PointStringTechnique extends VariedTechnique {\n    constructor(gl) {\n        super(PointStringTechnique._kUnquantized * 2);\n        const flags = scratchTechniqueFlags;\n        for (const posType of positionTypes) {\n            for (let instanced = 0 /* IsInstanced.No */; instanced <= 1 /* IsInstanced.Yes */; instanced++) {\n                this.addHiliteShader(gl, instanced, 0 /* IsClassified.No */, posType, (inst, _class, pos) => createPointStringHiliter(inst, pos));\n                for (const featureMode of featureModes) {\n                    flags.reset(featureMode, instanced, 0 /* IsShadowable.No */, 0 /* IsThematic.No */, posType);\n                    const builder = createPointStringBuilder(instanced, posType);\n                    addUnlitMonochrome(builder.frag);\n                    // The translucent shaders do not need the element IDs.\n                    const builderTrans = createPointStringBuilder(instanced, posType);\n                    addUnlitMonochrome(builderTrans.frag);\n                    if (2 /* FeatureMode.Overrides */ === featureMode) {\n                        addFeatureSymbology(builderTrans, featureMode, 29 /* FeatureSymbologyOptions.Point */);\n                        addFeatureSymbology(builder, featureMode, 29 /* FeatureSymbologyOptions.Point */);\n                        this.addTranslucentShader(builderTrans, flags, gl);\n                    }\n                    else {\n                        this.addTranslucentShader(builderTrans, flags, gl);\n                        addFeatureSymbology(builder, featureMode, 0 /* FeatureSymbologyOptions.None */);\n                    }\n                    this.addFeatureId(builder, featureMode);\n                    flags.reset(featureMode, instanced, 0 /* IsShadowable.No */, 0 /* IsThematic.No */, posType);\n                    this.addShader(builder, flags, gl);\n                }\n            }\n        }\n        this.finishConstruction();\n    }\n    get _debugDescription() { return \"PointString\"; }\n    computeShaderIndex(flags) {\n        const idxOffset = \"quantized\" === flags.positionType ? 0 : PointStringTechnique._kUnquantized;\n        if (flags.isHilite) {\n            assert(flags.hasFeatures);\n            return PointStringTechnique._kHilite + flags.isInstanced + idxOffset;\n        }\n        let index = flags.isTranslucent ? PointStringTechnique._kTranslucent : PointStringTechnique._kOpaque;\n        index += PointStringTechnique._kFeature * flags.featureMode;\n        index += PointStringTechnique._kInstanced * flags.isInstanced;\n        return index + idxOffset;\n    }\n}\nPointStringTechnique._kOpaque = 0;\nPointStringTechnique._kTranslucent = 1;\nPointStringTechnique._kInstanced = 2;\nPointStringTechnique._kFeature = 4;\nPointStringTechnique._kHilite = numFeatureVariants(PointStringTechnique._kFeature);\nPointStringTechnique._kUnquantized = PointStringTechnique._kHilite + numHiliteVariants;\nclass PointCloudTechnique extends VariedTechnique {\n    constructor(gl) {\n        super(PointCloudTechnique._kHilite + 2);\n        for (let iClassified = 0 /* IsClassified.No */; iClassified <= 1 /* IsClassified.Yes */; iClassified++) {\n            this.addHiliteShader(gl, 0 /* IsInstanced.No */, iClassified, \"quantized\", (_inst, classified) => createPointCloudHiliter(classified));\n            const flags = scratchTechniqueFlags;\n            for (let thematic = 0 /* IsThematic.No */; thematic <= 1 /* IsThematic.Yes */; thematic++) {\n                const pointCloudFeatureModes = [0 /* FeatureMode.None */, 2 /* FeatureMode.Overrides */];\n                for (const featureMode of pointCloudFeatureModes) {\n                    flags.reset(featureMode, 0 /* IsInstanced.No */, 0 /* IsShadowable.No */, thematic, \"quantized\");\n                    flags.isClassified = iClassified;\n                    const builder = createPointCloudBuilder(flags.isClassified, featureMode, thematic);\n                    if (2 /* FeatureMode.Overrides */ === featureMode) {\n                        addUniformFeatureSymbology(builder, true);\n                        addColorOverrideMix(builder.vert);\n                        builder.vert.set(7 /* VertexShaderComponent.ApplyFeatureColor */, mixFeatureColor);\n                    }\n                    this.addFeatureId(builder, featureMode);\n                    this.addShader(builder, flags, gl);\n                }\n            }\n        }\n        this.finishConstruction();\n    }\n    get _debugDescription() { return \"PointCloud\"; }\n    computeShaderIndex(flags) {\n        assert(flags.positionType === \"quantized\", \"Unquantized point cloud positions not currently supported\");\n        if (flags.isHilite)\n            return PointCloudTechnique._kHilite + flags.isClassified;\n        else {\n            let ndx = 0;\n            if (flags.isClassified)\n                ndx++;\n            if (flags.featureMode !== 0 /* FeatureMode.None */)\n                ndx += 2;\n            if (flags.isThematic)\n                ndx += 4;\n            return ndx;\n        }\n    }\n}\nPointCloudTechnique._kHilite = 8;\nclass RealityMeshTechnique extends VariedTechnique {\n    constructor(gl) {\n        super(RealityMeshTechnique._numVariants);\n        this._earlyZFlags = [\n            TechniqueFlags.fromDescription(\"Opaque-Hilite-Overrides\"),\n            TechniqueFlags.fromDescription(\"Opaque-Hilite-Classified\"),\n        ];\n        this.addHiliteShader(gl, 0 /* IsInstanced.No */, 0 /* IsClassified.No */, \"quantized\", createRealityMeshHiliter);\n        this.addHiliteShader(gl, 0 /* IsInstanced.No */, 1 /* IsClassified.Yes */, \"quantized\", createClassifierRealityMeshHiliter);\n        for (let iClassified = 0 /* IsClassified.No */; iClassified <= 1 /* IsClassified.Yes */; iClassified++) {\n            for (let iTranslucent = 0; iTranslucent <= 1; iTranslucent++) {\n                for (let shadowable = 0 /* IsShadowable.No */; shadowable <= 1 /* IsShadowable.Yes */; shadowable++) {\n                    for (let thematic = 0 /* IsThematic.No */; thematic <= 1 /* IsThematic.Yes */; thematic++) {\n                        for (let wiremesh = 0 /* IsWiremesh.No */; wiremesh <= 1 /* IsWiremesh.Yes */; wiremesh++) {\n                            for (let enableAtmosphere = 0 /* EnableAtmosphere.No */; enableAtmosphere <= 1 /* EnableAtmosphere.Yes */; enableAtmosphere++) {\n                                const flags = scratchTechniqueFlags;\n                                for (const featureMode of featureModes) {\n                                    flags.reset(featureMode, 0 /* IsInstanced.No */, shadowable, thematic, \"quantized\");\n                                    flags.isClassified = iClassified;\n                                    flags.isWiremesh = wiremesh;\n                                    flags.isTranslucent = 1 === iTranslucent;\n                                    flags.enableAtmosphere = enableAtmosphere;\n                                    const builder = createRealityMeshBuilder(flags);\n                                    if (flags.isTranslucent) {\n                                        addShaderFlags(builder);\n                                        addTranslucency(builder);\n                                    }\n                                    else\n                                        this.addFeatureId(builder, featureMode);\n                                    this.addShader(builder, flags, gl);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        this.finishConstruction();\n    }\n    get _debugDescription() { return \"RealityMesh\"; }\n    computeShaderIndex(flags) {\n        assert(\"quantized\" === flags.positionType, \"Unquantized reality mesh positions not currently supported.\");\n        if (flags.isHilite)\n            return flags.isClassified ? 1 : 0;\n        let ndx = 2;\n        if (flags.isClassified)\n            ndx++;\n        if (flags.isShadowable)\n            ndx += 2;\n        if (flags.isTranslucent)\n            ndx += 4;\n        ndx += 8 * flags.featureMode;\n        if (flags.isThematic)\n            ndx += 24;\n        if (flags.isWiremesh)\n            ndx += 48;\n        if (flags.enableAtmosphere)\n            ndx += 96;\n        return ndx;\n    }\n}\nRealityMeshTechnique._numVariants = 194;\n/**\n * More generalized version of VariedTechnique, without assuming usage of clipping, logDepth, eyeSpace, etc.\n * Similar to SingularTechnique in its simplicity, but with support for multiple shader programs per technique.\n */\nclass MultipleTechnique {\n    get isDisposed() { return this._isDisposed; }\n    constructor(numPrograms) {\n        this._programs = [];\n        this._isDisposed = false;\n        this._programs.length = numPrograms;\n    }\n    getShaderIndex(flags) {\n        assert(!flags.isHilite || (!flags.isTranslucent && (flags.isClassified === 1 /* IsClassified.Yes */ || flags.hasFeatures)), \"invalid technique flags\");\n        const index = this.computeShaderIndex(flags);\n        assert(index < this._programs.length, \"shader index out of bounds\");\n        return index;\n    }\n    getShader(flags) {\n        const index = this.getShaderIndex(flags);\n        let program;\n        if (program === undefined)\n            program = this._programs[index];\n        return program;\n    }\n    getShaderByIndex(index) {\n        return this._programs[index];\n    }\n    getShaderCount() {\n        return this._programs.length;\n    }\n    compileShaders() {\n        let allCompiled = true;\n        for (const program of this._programs) {\n            if (program.compile() !== 0 /* CompileStatus.Success */)\n                allCompiled = false;\n        }\n        return allCompiled;\n    }\n    dispose() {\n        if (this._isDisposed)\n            return;\n        for (const program of this._programs) {\n            assert(undefined !== program);\n            dispose(program);\n        }\n        this._programs.length = 0;\n        this._isDisposed = true;\n    }\n    addShader(builder, flags, gl) {\n        const descr = `${this._debugDescription}: ${flags.buildDescription()}`;\n        builder.setDebugDescription(descr);\n        const index = this.getShaderIndex(flags);\n        this.addProgram(builder, index, gl);\n        assert(!builder.frag.requiresEarlyZWorkaround);\n    }\n    addProgram(builder, index, gl) {\n        assert(this._programs[index] === undefined);\n        this._programs[index] = builder.buildProgram(gl);\n        assert(this._programs[index] !== undefined);\n    }\n    finishConstruction() {\n        // Confirm no empty entries in our array.\n        let emptyShaderIndex = -1;\n        assert(-1 === (emptyShaderIndex = this._programs.findIndex((prog) => undefined === prog)), `Shader index ${emptyShaderIndex} is undefined in ${this.constructor.name}`);\n    }\n}\nclass SkySphereTechnique extends MultipleTechnique {\n    constructor(gl, isGradient) {\n        super(SkySphereTechnique._numVariants);\n        this._isGradient = isGradient;\n        for (let enableAtmosphere = 0 /* EnableAtmosphere.No */; enableAtmosphere <= 1 /* EnableAtmosphere.Yes */; enableAtmosphere++) {\n            const tempFlags = scratchTechniqueFlags;\n            tempFlags.reset(0 /* FeatureMode.None */, 0 /* IsInstanced.No */, 0 /* IsShadowable.No */, 0 /* IsThematic.No */, \"quantized\");\n            tempFlags.enableAtmosphere = enableAtmosphere;\n            const builder = createSkySphereBuilder(isGradient, tempFlags);\n            this.addShader(builder, tempFlags, gl);\n        }\n        this.finishConstruction();\n    }\n    get _debugDescription() { return `SkySphere-${this._isGradient ? \"Gradient\" : \"Texture\"}`; }\n    computeShaderIndex(flags) {\n        let index = 0;\n        if (flags.enableAtmosphere)\n            index += 1 << 0;\n        return index;\n    }\n}\nSkySphereTechnique._numVariants = 2; // one binary flag (2 ** 1)\nconst techniquesByPriority = [\n    // Compile these specific shader variations first because they seem most likely to be used immediately upon opening a file.\n    { techniqueId: 0 /* TechniqueId.Surface */, specificShader: { featureMode: 0 /* FeatureMode.None */, isInstanced: 0 /* IsInstanced.No */, isShadowable: 0 /* IsShadowable.No */, isEdgeTestedNeeded: 0 /* IsEdgeTestNeeded.No */, isTranslucent: false } },\n    { techniqueId: 0 /* TechniqueId.Surface */, specificShader: { featureMode: 1 /* FeatureMode.Pick */, isInstanced: 0 /* IsInstanced.No */, isShadowable: 0 /* IsShadowable.No */, isEdgeTestedNeeded: 0 /* IsEdgeTestNeeded.No */, isTranslucent: false } },\n    { techniqueId: 0 /* TechniqueId.Surface */, specificShader: { featureMode: 1 /* FeatureMode.Pick */, isInstanced: 0 /* IsInstanced.No */, isShadowable: 0 /* IsShadowable.No */, isEdgeTestedNeeded: 1 /* IsEdgeTestNeeded.Yes */, isTranslucent: false } },\n    { techniqueId: 0 /* TechniqueId.Surface */, specificShader: { featureMode: 2 /* FeatureMode.Overrides */, isInstanced: 0 /* IsInstanced.No */, isShadowable: 0 /* IsShadowable.No */, isEdgeTestedNeeded: 0 /* IsEdgeTestNeeded.No */, isTranslucent: false } },\n    { techniqueId: 0 /* TechniqueId.Surface */, specificShader: { featureMode: 2 /* FeatureMode.Overrides */, isInstanced: 0 /* IsInstanced.No */, isShadowable: 0 /* IsShadowable.No */, isEdgeTestedNeeded: 1 /* IsEdgeTestNeeded.Yes */, isTranslucent: false } },\n    { techniqueId: 0 /* TechniqueId.Surface */, specificShader: { featureMode: 0 /* FeatureMode.None */, isInstanced: 0 /* IsInstanced.No */, isShadowable: 0 /* IsShadowable.No */, isEdgeTestedNeeded: 0 /* IsEdgeTestNeeded.No */, isTranslucent: true } },\n    { techniqueId: 0 /* TechniqueId.Surface */, specificShader: { featureMode: 1 /* FeatureMode.Pick */, isInstanced: 0 /* IsInstanced.No */, isShadowable: 0 /* IsShadowable.No */, isEdgeTestedNeeded: 0 /* IsEdgeTestNeeded.No */, isTranslucent: true } },\n    { techniqueId: 0 /* TechniqueId.Surface */, specificShader: { featureMode: 1 /* FeatureMode.Pick */, isInstanced: 0 /* IsInstanced.No */, isShadowable: 0 /* IsShadowable.No */, isEdgeTestedNeeded: 1 /* IsEdgeTestNeeded.Yes */, isTranslucent: true } },\n    { techniqueId: 0 /* TechniqueId.Surface */, specificShader: { featureMode: 2 /* FeatureMode.Overrides */, isInstanced: 0 /* IsInstanced.No */, isShadowable: 0 /* IsShadowable.No */, isEdgeTestedNeeded: 0 /* IsEdgeTestNeeded.No */, isTranslucent: true } },\n    { techniqueId: 0 /* TechniqueId.Surface */, specificShader: { featureMode: 2 /* FeatureMode.Overrides */, isInstanced: 0 /* IsInstanced.No */, isShadowable: 0 /* IsShadowable.No */, isEdgeTestedNeeded: 1 /* IsEdgeTestNeeded.Yes */, isTranslucent: true } },\n    // Next, compile all shaders in specific techniques.\n    // Do surfaces first because (1) they are the most commonly used and (2) they take longer to compile.\n    { techniqueId: 0 /* TechniqueId.Surface */ },\n    { techniqueId: 4 /* TechniqueId.Edge */ },\n    { techniqueId: 5 /* TechniqueId.SilhouetteEdge */ },\n    { techniqueId: 1 /* TechniqueId.Polyline */ },\n    { techniqueId: 3 /* TechniqueId.PointString */ },\n    { techniqueId: 2 /* TechniqueId.PointCloud */ },\n    { techniqueId: 7 /* TechniqueId.RealityMesh */ },\n    // The following techniques take a trivial amount of time to compile - do them last\n    { techniqueId: 16 /* TechniqueId.OITClearTranslucent */ },\n    { techniqueId: 17 /* TechniqueId.CopyPickBuffers */ },\n    { techniqueId: 18 /* TechniqueId.CopyColor */ },\n    { techniqueId: 19 /* TechniqueId.CopyColorNoAlpha */ },\n    { techniqueId: 21 /* TechniqueId.ClearPickAndColor */ },\n    { techniqueId: 10 /* TechniqueId.CompositeTranslucent */ },\n    { techniqueId: 9 /* TechniqueId.CompositeHilite */ },\n    { techniqueId: 11 /* TechniqueId.CompositeHiliteAndTranslucent */ },\n    { techniqueId: 12 /* TechniqueId.CompositeOcclusion */ },\n    { techniqueId: 13 /* TechniqueId.CompositeTranslucentAndOcclusion */ },\n    { techniqueId: 14 /* TechniqueId.CompositeHiliteAndOcclusion */ },\n    { techniqueId: 15 /* TechniqueId.CompositeAll */ },\n    { techniqueId: 20 /* TechniqueId.VolClassColorUsingStencil */ },\n    { techniqueId: 22 /* TechniqueId.EVSMFromDepth */ },\n    { techniqueId: 23 /* TechniqueId.SkyBox */ },\n    { techniqueId: 24 /* TechniqueId.SkySphereGradient */ },\n    { techniqueId: 25 /* TechniqueId.SkySphereTexture */ },\n    { techniqueId: 26 /* TechniqueId.AmbientOcclusion */ },\n    { techniqueId: 27 /* TechniqueId.Blur */ },\n    { techniqueId: 28 /* TechniqueId.BlurTestOrder */ },\n    { techniqueId: 29 /* TechniqueId.CombineTextures */ },\n    { techniqueId: 31 /* TechniqueId.VolClassCopyZ */ },\n    { techniqueId: 32 /* TechniqueId.VolClassSetBlend */ },\n    { techniqueId: 33 /* TechniqueId.VolClassBlend */ },\n    { techniqueId: 30 /* TechniqueId.Combine3Textures */ },\n    { techniqueId: 8 /* TechniqueId.PlanarGrid */ },\n    { techniqueId: 34 /* TechniqueId.EDLCalcBasic */ },\n    { techniqueId: 35 /* TechniqueId.EDLCalcFull */ },\n    { techniqueId: 36 /* TechniqueId.EDLFilter */ },\n    { techniqueId: 37 /* TechniqueId.EDLMix */ },\n];\nconst numTechniquesByPriority = techniquesByPriority.length;\n/** A collection of rendering techniques accessed by ID.\n * @internal\n */\nexport class Techniques {\n    static create(gl) {\n        const techs = new Techniques();\n        techs.initializeBuiltIns(gl);\n        return techs;\n    }\n    getTechnique(id) {\n        assert(id < this._list.length, \"technique index out of bounds\");\n        return this._list[id];\n    }\n    get numTechniques() {\n        return this._list.length;\n    }\n    addDynamicTechnique(technique, name) {\n        const id = this.getDynamicTechniqueId(name);\n        if (undefined !== id)\n            return id;\n        this._dynamicTechniqueIds.push(name);\n        this._list.push(technique);\n        return 38 /* TechniqueId.NumBuiltIn */ + this._dynamicTechniqueIds.length - 1;\n    }\n    getDynamicTechniqueId(name) {\n        const index = this._dynamicTechniqueIds.indexOf(name);\n        return -1 !== index ? index + 38 /* TechniqueId.NumBuiltIn */ + index : undefined;\n    }\n    /** Execute each command in the list */\n    execute(target, commands, renderPass) {\n        assert(255 /* RenderPass.None */ !== renderPass, \"invalid render pass\");\n        using(new ShaderProgramExecutor(target, renderPass), (executor) => {\n            for (const command of commands)\n                command.execute(executor);\n        });\n        System.instance.frameBufferStack.markTargetsDirty();\n    }\n    /** Execute the commands for a single given classification primitive (the first 3 commands should be a push, the primitive, then a pop) */\n    executeForIndexedClassifier(target, cmdsByIndex, renderPass) {\n        // ###TODO: Disable shadows. Probably in the ClassifierTileTree's ViewFlagOverrides.\n        this.execute(target, cmdsByIndex, renderPass);\n    }\n    /** Draw a single primitive. Usually used for special-purpose rendering techniques. */\n    draw(params) {\n        const tech = this.getTechnique(params.geometry.techniqueId);\n        const program = tech.getShader(TechniqueFlags.defaults);\n        using(new ShaderProgramExecutor(params.target, params.renderPass, program), (executor) => {\n            assert(executor.isValid);\n            if (executor.isValid) {\n                executor.draw(params);\n            }\n        });\n        System.instance.frameBufferStack.markTargetsDirty();\n    }\n    get isDisposed() { return 0 === this._list.length; }\n    dispose() {\n        for (const tech of this._list)\n            dispose(tech);\n        this._list.length = 0;\n    }\n    // Chiefly for tests - compiles all shader programs - more generally programs are compiled on demand.\n    compileShaders() {\n        let allCompiled = true;\n        for (const tech of this._list) {\n            if (!tech.compileShaders())\n                allCompiled = false;\n        }\n        return allCompiled;\n    }\n    /** Compile shader of next highest priority. Called when possible during an idle situation before any viewports exist. */\n    idleCompileNextShader() {\n        let compileStatus = 0 /* CompileStatus.Success */;\n        let wasPreviouslyCompiled = false;\n        do {\n            if (this._techniqueByPriorityIndex >= numTechniquesByPriority)\n                return false;\n            let shader;\n            let numShaders = 0;\n            const pTech = techniquesByPriority[this._techniqueByPriorityIndex];\n            const tech = this._list[pTech.techniqueId];\n            if (pTech.specificShader !== undefined) { // if this entry consists of a specific shader, just compile that\n                const flags = scratchTechniqueFlags;\n                flags.reset(pTech.specificShader.featureMode, pTech.specificShader.isInstanced, pTech.specificShader.isShadowable, 0 /* IsThematic.No */, \"quantized\");\n                flags.isEdgeTestNeeded = pTech.specificShader.isEdgeTestedNeeded;\n                flags.isTranslucent = pTech.specificShader.isTranslucent;\n                shader = tech.getShader(flags);\n            }\n            else { // if this entry only contains a techniqueId, then compile all uncompiled shaders for that technique\n                shader = tech.getShaderByIndex(this._shaderIndex);\n                this._shaderIndex++;\n                numShaders = tech.getShaderCount();\n            }\n            if (shader.isCompiled)\n                wasPreviouslyCompiled = true;\n            else {\n                compileStatus = shader.compile();\n                wasPreviouslyCompiled = false;\n            }\n            if (this._shaderIndex >= numShaders) {\n                this._techniqueByPriorityIndex++;\n                this._shaderIndex = 0;\n            }\n        } while (wasPreviouslyCompiled);\n        return compileStatus === 0 /* CompileStatus.Success */;\n    }\n    /** For tests. */\n    forEachVariedProgram(func) {\n        for (const technique of this._list)\n            if (technique instanceof VariedTechnique)\n                technique.forEachProgram(func);\n    }\n    constructor() {\n        this._list = new Array(); // indexed by TechniqueId, which may exceed TechniqueId.NumBuiltIn for dynamic techniques.\n        this._dynamicTechniqueIds = new Array(); // technique ID = (index in this array) + TechniqueId.NumBuiltIn\n        this._techniqueByPriorityIndex = 0;\n        this._shaderIndex = 0;\n    }\n    initializeBuiltIns(gl) {\n        this._list[16 /* TechniqueId.OITClearTranslucent */] = new SingularTechnique(createClearTranslucentProgram(gl));\n        this._list[21 /* TechniqueId.ClearPickAndColor */] = new SingularTechnique(createClearPickAndColorProgram(gl));\n        this._list[18 /* TechniqueId.CopyColor */] = new SingularTechnique(createCopyColorProgram(gl));\n        this._list[19 /* TechniqueId.CopyColorNoAlpha */] = new SingularTechnique(createCopyColorProgram(gl, false));\n        this._list[17 /* TechniqueId.CopyPickBuffers */] = new SingularTechnique(createCopyPickBuffersProgram(gl));\n        this._list[22 /* TechniqueId.EVSMFromDepth */] = new SingularTechnique(createEVSMProgram(gl));\n        this._list[23 /* TechniqueId.SkyBox */] = new SingularTechnique(createSkyBoxProgram(gl));\n        this._list[24 /* TechniqueId.SkySphereGradient */] = new SkySphereTechnique(gl, true);\n        this._list[25 /* TechniqueId.SkySphereTexture */] = new SkySphereTechnique(gl, false);\n        this._list[26 /* TechniqueId.AmbientOcclusion */] = new SingularTechnique(createAmbientOcclusionProgram(gl));\n        this._list[27 /* TechniqueId.Blur */] = new SingularTechnique(createBlurProgram(gl, BlurType.NoTest));\n        this._list[28 /* TechniqueId.BlurTestOrder */] = new SingularTechnique(createBlurProgram(gl, BlurType.TestOrder));\n        this._list[29 /* TechniqueId.CombineTextures */] = new SingularTechnique(createCombineTexturesProgram(gl));\n        this._list[30 /* TechniqueId.Combine3Textures */] = new SingularTechnique(createCombine3TexturesProgram(gl));\n        this._list[0 /* TechniqueId.Surface */] = new SurfaceTechnique(gl);\n        this._list[4 /* TechniqueId.Edge */] = new EdgeTechnique(gl, \"SegmentEdge\");\n        this._list[5 /* TechniqueId.SilhouetteEdge */] = new EdgeTechnique(gl, \"Silhouette\");\n        this._list[1 /* TechniqueId.Polyline */] = new PolylineTechnique(gl);\n        this._list[3 /* TechniqueId.PointString */] = new PointStringTechnique(gl);\n        this._list[2 /* TechniqueId.PointCloud */] = new PointCloudTechnique(gl);\n        this._list[7 /* TechniqueId.RealityMesh */] = new RealityMeshTechnique(gl);\n        this._list[8 /* TechniqueId.PlanarGrid */] = new SingularTechnique(createPlanarGridProgram(gl));\n        this._list[34 /* TechniqueId.EDLCalcBasic */] = new SingularTechnique(createEDLCalcBasicProgram(gl));\n        this._list[35 /* TechniqueId.EDLCalcFull */] = new SingularTechnique(createEDLCalcFullProgram(gl));\n        this._list[36 /* TechniqueId.EDLFilter */] = new SingularTechnique(createEDLFilterProgram(gl));\n        this._list[37 /* TechniqueId.EDLMix */] = new SingularTechnique(createEDLMixProgram(gl));\n        this._list[6 /* TechniqueId.IndexedEdge */] = new EdgeTechnique(gl, \"IndexedEdge\");\n        this._list[31 /* TechniqueId.VolClassCopyZ */] = new SingularTechnique(createVolClassCopyZProgram(gl));\n        this._list[32 /* TechniqueId.VolClassSetBlend */] = new SingularTechnique(createVolClassSetBlendProgram(gl));\n        this._list[33 /* TechniqueId.VolClassBlend */] = new SingularTechnique(createVolClassBlendProgram(gl));\n        this._list[20 /* TechniqueId.VolClassColorUsingStencil */] = new SingularTechnique(createVolClassColorUsingStencilProgram(gl));\n        for (let compositeFlags = 1; compositeFlags <= 7; compositeFlags++) {\n            const techId = computeCompositeTechniqueId(compositeFlags);\n            this._list[techId] = new SingularTechnique(createCompositeProgram(compositeFlags, gl));\n        }\n        assert(this._list.length === 38 /* TechniqueId.NumBuiltIn */, \"unexpected number of built-in techniques\");\n    }\n}\n//# sourceMappingURL=Technique.js.map",
      "start": 1693508124547,
      "end": 1693508124672,
      "sourcemaps": null
    }
  ]
}
